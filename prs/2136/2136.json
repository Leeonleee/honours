{
  "repo": "duckdb/duckdb",
  "pull_number": 2136,
  "instance_id": "duckdb__duckdb-2136",
  "issue_numbers": [
    "741"
  ],
  "base_commit": "0d2a2778ae50857bac3cb1788af5a2b66334f0e9",
  "patch": "diff --git a/tools/rpkg/NAMESPACE b/tools/rpkg/NAMESPACE\nindex e0279ae05cda..8850579c34c0 100644\n--- a/tools/rpkg/NAMESPACE\n+++ b/tools/rpkg/NAMESPACE\n@@ -32,6 +32,7 @@ exportMethods(dbHasCompleted)\n exportMethods(dbIsValid)\n exportMethods(dbListFields)\n exportMethods(dbListTables)\n+exportMethods(dbQuoteLiteral)\n exportMethods(dbRemoveTable)\n exportMethods(dbRollback)\n exportMethods(dbSendQuery)\ndiff --git a/tools/rpkg/R/Connection.R b/tools/rpkg/R/Connection.R\nindex fd39616b83f8..428853fcae22 100644\n--- a/tools/rpkg/R/Connection.R\n+++ b/tools/rpkg/R/Connection.R\n@@ -208,19 +208,9 @@ setMethod(\n       stop(\"Column name mismatch for append\")\n     }\n \n-    is_factor <- vapply(value, is.factor, logical(1))\n-    if (any(is_factor)) {\n-      warning(\"Factors converted to character\")\n-    }\n+    value <- encode_values(value)\n \n     if (nrow(value)) {\n-      is_character <- vapply(value, is.character, logical(1))\n-      value[is_character] <- lapply(value[is_character], enc2utf8)\n-      value[is_factor] <- lapply(value[is_factor], function(x) {\n-        levels(x) <- enc2utf8(levels(x))\n-        as.character(x)\n-      })\n-\n       table_name <- dbQuoteIdentifier(conn, name)\n \n       view_name <- sprintf(\"_duckdb_append_view_%s\", duckdb_random_string())\n@@ -235,6 +225,26 @@ setMethod(\n   }\n )\n \n+encode_values <- function(value) {\n+  is_factor <- vapply(value, is.factor, logical(1))\n+  if (any(is_factor)) {\n+    warning(\"Factors converted to character\")\n+  }\n+\n+  value[is_factor] <- lapply(value[is_factor], function(x) {\n+    levels(x) <- enc2utf8(levels(x))\n+    as.character(x)\n+  })\n+\n+  is_character <- vapply(value, is.character, logical(1))\n+  value[is_character] <- lapply(value[is_character], enc2utf8)\n+\n+  is_posixlt <- vapply(value, inherits, \"POSIXlt\", FUN.VALUE = logical(1))\n+  value[is_posixlt] <- lapply(value[is_posixlt], as.POSIXct)\n+\n+  value\n+}\n+\n #' @rdname duckdb_connection-class\n #' @inheritParams DBI::dbListTables\n #' @export\n@@ -364,3 +374,65 @@ setMethod(\n     invisible(TRUE)\n   }\n )\n+\n+#' @rdname duckdb_connection-class\n+#' @export\n+setMethod(\n+  \"dbQuoteLiteral\", signature(\"duckdb_connection\"),\n+  function(conn, x, ...) {\n+    # Switchpatching to avoid ambiguous S4 dispatch, so that our method\n+    # is used only if no alternatives are available.\n+\n+    if (is(x, \"SQL\")) {\n+      return(x)\n+    }\n+\n+    if (is.factor(x)) {\n+      return(dbQuoteString(conn, as.character(x)))\n+    }\n+\n+    if (is.character(x)) {\n+      return(dbQuoteString(conn, x))\n+    }\n+\n+    if (inherits(x, \"POSIXt\")) {\n+      out <- dbQuoteString(\n+        conn,\n+        strftime(as.POSIXct(x), \"%Y-%m-%d %H:%M:%S\", tz = \"UTC\")\n+      )\n+\n+      return(SQL(paste0(out, \"::timestamp\")))\n+    }\n+\n+    if (inherits(x, \"Date\")) {\n+      out <- callNextMethod()\n+      return(SQL(paste0(out, \"::date\")))\n+    }\n+\n+    if (inherits(x, \"difftime\")) {\n+      out <- callNextMethod()\n+      return(SQL(paste0(out, \"::time\")))\n+    }\n+\n+    if (is.list(x)) {\n+      blob_data <- vapply(\n+        x,\n+        function(x) {\n+          if (is.null(x)) {\n+            \"NULL\"\n+          } else if (is.raw(x)) {\n+            paste0(\"X'\", paste(format(x), collapse = \"\"), \"'\")\n+          } else {\n+            stop(\"Lists must contain raw vectors or NULL\", call. = FALSE)\n+          }\n+        },\n+        character(1)\n+      )\n+      return(SQL(blob_data, names = names(x)))\n+    }\n+\n+    x <- as.character(x)\n+    x[is.na(x)] <- \"NULL\"\n+    SQL(x, names = names(x))\n+  }\n+)\ndiff --git a/tools/rpkg/R/Result.R b/tools/rpkg/R/Result.R\nindex dc3c167f5d08..31ff904b9e36 100644\n--- a/tools/rpkg/R/Result.R\n+++ b/tools/rpkg/R/Result.R\n@@ -42,19 +42,31 @@ duckdb_result <- function(connection, stmt_lst, arrow) {\n }\n \n duckdb_execute <- function(res) {\n-  if (res@arrow){\n-    query <- .Call(duckdb_execute_R, res@stmt_lst$ref, res@arrow)\n-    return (query)\n-  }\n-  res@env$resultset <- .Call(duckdb_execute_R, res@stmt_lst$ref, res@arrow)\n+  out <- .Call(duckdb_execute_R, res@stmt_lst$ref, res@arrow)\n+  duckdb_post_execute(res, out)\n+}\n+\n+duckdb_post_execute <- function(res, out) {\n   if (!res@arrow) {\n-      attr(res@env$resultset, \"row.names\") <-\n-        c(NA_integer_, as.integer(-1 * length(res@env$resultset[[1]])))\n-      class(res@env$resultset) <- \"data.frame\"\n+    out <- list_to_df(out)\n+\n+    if (res@stmt_lst$type != \"SELECT\") {\n+      res@env$rows_affected <- sum(as.numeric(out[[1]]))\n+    }\n+\n+    res@env$resultset <- out\n   }\n-  if (res@stmt_lst$type != \"SELECT\") {\n-    res@env$rows_affected <- as.numeric(res@env$resultset[[1]][1])\n+\n+  out\n+}\n+\n+list_to_df <- function(x) {\n+  if (is.data.frame(x)) {\n+    return(x)\n   }\n+  attr(x, \"row.names\") <- c(NA_integer_, -length(x[[1]]))\n+  class(x) <- \"data.frame\"\n+  x\n }\n \n \n@@ -127,6 +139,10 @@ setMethod(\n     if (!res@env$open) {\n       stop(\"result set was closed\")\n     }\n+    if (is.null(res@env$resultset)) {\n+      stop(\"Need to call `dbBind()` before `dbFetch()`\")\n+    }\n+\n     if (length(n) != 1) {\n       stop(\"need exactly one value in n\")\n     }\n@@ -195,10 +211,14 @@ setMethod(\n     if (!res@env$open) {\n       stop(\"result has already been cleared\")\n     }\n-    if (res@stmt_lst$type != \"SELECT\") {\n-      return(TRUE)\n+\n+    if (is.null(res@env$resultset)) {\n+      FALSE\n+    } else if (res@stmt_lst$type == \"SELECT\") {\n+      res@env$rows_fetched == nrow(res@env$resultset)\n+    } else {\n+      TRUE\n     }\n-    return(res@env$rows_fetched == nrow(res@env$resultset))\n   }\n )\n \n@@ -271,6 +291,9 @@ setMethod(\n     if (!res@env$open) {\n       stop(\"result has already been cleared\")\n     }\n+    if (is.null(res@env$resultset)) {\n+      return(NA_integer_)\n+    }\n     return(res@env$rows_affected)\n   }\n )\n@@ -287,8 +310,23 @@ setMethod(\n     res@env$rows_fetched <- 0\n     res@env$resultset <- data.frame()\n \n-    invisible(.Call(duckdb_bind_R, res@stmt_lst$ref, params))\n-    duckdb_execute(res)\n+    params <- as.list(params)\n+    if (!is.null(names(params))) {\n+      stop(\"`params` must not be named\")\n+    }\n+\n+    params <- encode_values(params)\n+\n+    out <- .Call(duckdb_bind_R, res@stmt_lst$ref, params, res@arrow)\n+    if (length(out) == 1) {\n+      out <- out[[1]]\n+    } else if (length(out) == 0) {\n+      out <- data.frame()\n+    } else {\n+      out <- do.call(rbind, lapply(out, list_to_df))\n+    }\n+    duckdb_post_execute(res, out)\n+    invisible(res)\n   }\n )\n \ndiff --git a/tools/rpkg/man/duckdb_connection-class.Rd b/tools/rpkg/man/duckdb_connection-class.Rd\nindex c50c9253d2da..1c25b073490d 100644\n--- a/tools/rpkg/man/duckdb_connection-class.Rd\n+++ b/tools/rpkg/man/duckdb_connection-class.Rd\n@@ -18,6 +18,7 @@\n \\alias{dbBegin,duckdb_connection-method}\n \\alias{dbCommit,duckdb_connection-method}\n \\alias{dbRollback,duckdb_connection-method}\n+\\alias{dbQuoteLiteral,duckdb_connection-method}\n \\title{DuckDB connection class}\n \\usage{\n \\S4method{show}{duckdb_connection}(object)\n@@ -57,6 +58,8 @@\n \\S4method{dbCommit}{duckdb_connection}(conn, ...)\n \n \\S4method{dbRollback}{duckdb_connection}(conn, ...)\n+\n+\\S4method{dbQuoteLiteral}{duckdb_connection}(conn, x, ...)\n }\n \\arguments{\n \\item{object}{Any R object}\ndiff --git a/tools/rpkg/src/include/rapi.hpp b/tools/rpkg/src/include/rapi.hpp\nindex e33992ee1c3f..c4e2c70002e1 100644\n--- a/tools/rpkg/src/include/rapi.hpp\n+++ b/tools/rpkg/src/include/rapi.hpp\n@@ -21,7 +21,7 @@ struct RApi {\n \n \tstatic SEXP Prepare(SEXP connsexp, SEXP querysexp);\n \n-\tstatic SEXP Bind(SEXP stmtsexp, SEXP paramsexp);\n+\tstatic SEXP Bind(SEXP stmtsexp, SEXP paramsexp, SEXP arrowsexp);\n \n \tstatic SEXP Execute(SEXP stmtsexp, SEXP arrowsexp);\n \ndiff --git a/tools/rpkg/src/include/typesr.hpp b/tools/rpkg/src/include/typesr.hpp\nindex 9fac65fca1e9..2501dd99d591 100644\n--- a/tools/rpkg/src/include/typesr.hpp\n+++ b/tools/rpkg/src/include/typesr.hpp\n@@ -15,17 +15,23 @@ enum class RType {\n \tSTRING,\n \tFACTOR,\n \tDATE,\n+\tDATE_INTEGER,\n \tTIMESTAMP,\n \tTIME_SECONDS,\n \tTIME_MINUTES,\n \tTIME_HOURS,\n \tTIME_DAYS,\n-\tTIME_WEEKS\n+\tTIME_WEEKS,\n+\tTIME_SECONDS_INTEGER,\n+\tTIME_MINUTES_INTEGER,\n+\tTIME_HOURS_INTEGER,\n+\tTIME_DAYS_INTEGER,\n+\tTIME_WEEKS_INTEGER,\n };\n \n struct RApiTypes {\n \tstatic RType DetectRType(SEXP v);\n-\tstatic Value SexpToValue(SEXP valsexp);\n+\tstatic Value SexpToValue(SEXP valsexp, R_len_t idx);\n \tstatic SEXP ValueToSexp(Value &val);\n };\n \ndiff --git a/tools/rpkg/src/rapi.cpp b/tools/rpkg/src/rapi.cpp\nindex 60d89d73e81e..5680b727a9ee 100644\n--- a/tools/rpkg/src/rapi.cpp\n+++ b/tools/rpkg/src/rapi.cpp\n@@ -5,7 +5,7 @@ using namespace duckdb;\n static const R_CallMethodDef R_CallDef[] = {{\"duckdb_startup_R\", (DL_FUNC)RApi::Startup, 3},\n                                             {\"duckdb_connect_R\", (DL_FUNC)RApi::Connect, 1},\n                                             {\"duckdb_prepare_R\", (DL_FUNC)RApi::Prepare, 2},\n-                                            {\"duckdb_bind_R\", (DL_FUNC)RApi::Bind, 2},\n+                                            {\"duckdb_bind_R\", (DL_FUNC)RApi::Bind, 3},\n                                             {\"duckdb_execute_R\", (DL_FUNC)RApi::Execute, 2},\n                                             {\"duckdb_fetch_arrow_R\", (DL_FUNC)RApi::DuckDBExecuteArrow, 4},\n                                             {\"duckdb_fetch_record_batch_R\", (DL_FUNC)RApi::DuckDBRecordBatchR, 1},\ndiff --git a/tools/rpkg/src/scan.cpp b/tools/rpkg/src/scan.cpp\nindex 459154d1dae8..364bdb2814fa 100644\n--- a/tools/rpkg/src/scan.cpp\n+++ b/tools/rpkg/src/scan.cpp\n@@ -101,9 +101,15 @@ static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vect\n \t\tcase RType::TIME_HOURS:\n \t\tcase RType::TIME_DAYS:\n \t\tcase RType::TIME_WEEKS:\n+\t\tcase RType::TIME_SECONDS_INTEGER:\n+\t\tcase RType::TIME_MINUTES_INTEGER:\n+\t\tcase RType::TIME_HOURS_INTEGER:\n+\t\tcase RType::TIME_DAYS_INTEGER:\n+\t\tcase RType::TIME_WEEKS_INTEGER:\n \t\t\tduckdb_col_type = LogicalType::TIME;\n \t\t\tbreak;\n \t\tcase RType::DATE:\n+\t\tcase RType::DATE_INTEGER:\n \t\t\tduckdb_col_type = LogicalType::DATE;\n \t\t\tbreak;\n \t\tdefault:\n@@ -190,11 +196,41 @@ static void dataframe_scan_function(ClientContext &context, const FunctionData *\n \t\t\tAppendColumnSegment<double, dtime_t, RTimeWeeksType>(data_ptr, v, this_count);\n \t\t\tbreak;\n \t\t}\n+\t\tcase RType::TIME_SECONDS_INTEGER: {\n+\t\t\tauto data_ptr = INTEGER_POINTER(coldata) + state.position;\n+\t\t\tAppendColumnSegment<int, dtime_t, RTimeSecondsType>(data_ptr, v, this_count);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase RType::TIME_MINUTES_INTEGER: {\n+\t\t\tauto data_ptr = INTEGER_POINTER(coldata) + state.position;\n+\t\t\tAppendColumnSegment<int, dtime_t, RTimeMinutesType>(data_ptr, v, this_count);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase RType::TIME_HOURS_INTEGER: {\n+\t\t\tauto data_ptr = INTEGER_POINTER(coldata) + state.position;\n+\t\t\tAppendColumnSegment<int, dtime_t, RTimeHoursType>(data_ptr, v, this_count);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase RType::TIME_DAYS_INTEGER: {\n+\t\t\tauto data_ptr = INTEGER_POINTER(coldata) + state.position;\n+\t\t\tAppendColumnSegment<int, dtime_t, RTimeDaysType>(data_ptr, v, this_count);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase RType::TIME_WEEKS_INTEGER: {\n+\t\t\tauto data_ptr = INTEGER_POINTER(coldata) + state.position;\n+\t\t\tAppendColumnSegment<int, dtime_t, RTimeWeeksType>(data_ptr, v, this_count);\n+\t\t\tbreak;\n+\t\t}\n \t\tcase RType::DATE: {\n \t\t\tauto data_ptr = NUMERIC_POINTER(coldata) + state.position;\n \t\t\tAppendColumnSegment<double, date_t, RDateType>(data_ptr, v, this_count);\n \t\t\tbreak;\n \t\t}\n+\t\tcase RType::DATE_INTEGER: {\n+\t\t\tauto data_ptr = INTEGER_POINTER(coldata) + state.position;\n+\t\t\tAppendColumnSegment<int, date_t, RDateType>(data_ptr, v, this_count);\n+\t\t\tbreak;\n+\t\t}\n \t\tdefault:\n \t\t\tthrow;\n \t\t}\ndiff --git a/tools/rpkg/src/statement.cpp b/tools/rpkg/src/statement.cpp\nindex 88db412d4062..61793825d9f3 100644\n--- a/tools/rpkg/src/statement.cpp\n+++ b/tools/rpkg/src/statement.cpp\n@@ -137,7 +137,7 @@ SEXP RApi::Prepare(SEXP connsexp, SEXP querysexp) {\n \treturn retlist;\n }\n \n-SEXP RApi::Bind(SEXP stmtsexp, SEXP paramsexp) {\n+SEXP RApi::Bind(SEXP stmtsexp, SEXP paramsexp, SEXP arrowsexp) {\n \tif (TYPEOF(stmtsexp) != EXTPTRSXP) {\n \t\tRf_error(\"duckdb_bind_R: Need external pointer parameter\");\n \t}\n@@ -151,22 +151,47 @@ SEXP RApi::Bind(SEXP stmtsexp, SEXP paramsexp) {\n \n \tif (stmtholder->stmt->n_param == 0) {\n \t\tRf_error(\"duckdb_bind_R: dbBind called but query takes no parameters\");\n-\t\treturn R_NilValue;\n \t}\n \n \tif (TYPEOF(paramsexp) != VECSXP || (idx_t)Rf_length(paramsexp) != stmtholder->stmt->n_param) {\n \t\tRf_error(\"duckdb_bind_R: bind parameters need to be a list of length %i\", stmtholder->stmt->n_param);\n \t}\n \n-\tfor (idx_t param_idx = 0; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {\n+\tif (TYPEOF(arrowsexp) != LGLSXP) {\n+\t\tRf_error(\"duckdb_bind_R: Need logical for third parameter\");\n+\t}\n+\n+\tbool arrow_fetch = LOGICAL_POINTER(arrowsexp)[0] != 0;\n+\n+\tR_len_t n_rows = Rf_length(VECTOR_ELT(paramsexp, 0));\n+\n+\tfor (idx_t param_idx = 1; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {\n \t\tSEXP valsexp = VECTOR_ELT(paramsexp, param_idx);\n-\t\tif (Rf_length(valsexp) != 1) {\n-\t\t\tRf_error(\"duckdb_bind_R: bind parameter values need to have length 1\");\n+\t\tif (Rf_length(valsexp) != n_rows) {\n+\t\t\tRf_error(\"duckdb_bind_R: bind parameter values need to have the same length\");\n \t\t}\n-\t\tauto val = RApiTypes::SexpToValue(valsexp);\n-\t\tstmtholder->parameters[param_idx] = val;\n \t}\n-\treturn R_NilValue;\n+\n+\tif (n_rows != 1 && arrow_fetch) {\n+\t\tRf_error(\"duckdb_bind_R: bind parameter values need to have length one for arrow queries\");\n+\t}\n+\n+\tRProtector r;\n+\tauto out = r.Protect(NEW_LIST(n_rows));\n+\n+\tfor (idx_t row_idx = 0; row_idx < n_rows; ++row_idx) {\n+\t\tfor (idx_t param_idx = 0; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {\n+\t\t\tSEXP valsexp = VECTOR_ELT(paramsexp, param_idx);\n+\t\t\tauto val = RApiTypes::SexpToValue(valsexp, row_idx);\n+\t\t\tstmtholder->parameters[param_idx] = val;\n+\t\t}\n+\n+\t\t// No protection, assigned immediately\n+\t\tauto exec_result = RApi::Execute(stmtsexp, arrowsexp);\n+\t\tSET_VECTOR_ELT(out, row_idx, exec_result);\n+\t}\n+\n+\treturn out;\n }\n \n static SEXP duckdb_execute_R_impl(MaterializedQueryResult *result) {\ndiff --git a/tools/rpkg/src/types.cpp b/tools/rpkg/src/types.cpp\nindex 625125bfb912..42d0543bfb88 100644\n--- a/tools/rpkg/src/types.cpp\n+++ b/tools/rpkg/src/types.cpp\n@@ -13,6 +13,8 @@ RType RApiTypes::DetectRType(SEXP v) {\n \t\treturn RType::TIMESTAMP;\n \t} else if (TYPEOF(v) == REALSXP && Rf_inherits(v, \"Date\")) {\n \t\treturn RType::DATE;\n+\t} else if (TYPEOF(v) == INTSXP && Rf_inherits(v, \"Date\")) {\n+\t\treturn RType::DATE_INTEGER;\n \t} else if (TYPEOF(v) == REALSXP && Rf_inherits(v, \"difftime\")) {\n \t\tSEXP units = Rf_getAttrib(v, Rf_install(\"units\"));\n \t\tif (TYPEOF(units) != STRSXP) {\n@@ -32,6 +34,25 @@ RType RApiTypes::DetectRType(SEXP v) {\n \t\t} else {\n \t\t\treturn RType::UNKNOWN;\n \t\t}\n+\t} else if (TYPEOF(v) == INTSXP && Rf_inherits(v, \"difftime\")) {\n+\t\tSEXP units = Rf_getAttrib(v, Rf_install(\"units\"));\n+\t\tif (TYPEOF(units) != STRSXP) {\n+\t\t\treturn RType::UNKNOWN;\n+\t\t}\n+\t\tSEXP units0 = STRING_ELT(units, 0);\n+\t\tif (units0 == RStrings::get().secs) {\n+\t\t\treturn RType::TIME_SECONDS_INTEGER;\n+\t\t} else if (units0 == RStrings::get().mins) {\n+\t\t\treturn RType::TIME_MINUTES_INTEGER;\n+\t\t} else if (units0 == RStrings::get().hours) {\n+\t\t\treturn RType::TIME_HOURS_INTEGER;\n+\t\t} else if (units0 == RStrings::get().days) {\n+\t\t\treturn RType::TIME_DAYS_INTEGER;\n+\t\t} else if (units0 == RStrings::get().weeks) {\n+\t\t\treturn RType::TIME_WEEKS_INTEGER;\n+\t\t} else {\n+\t\t\treturn RType::UNKNOWN;\n+\t\t}\n \t} else if (Rf_isFactor(v) && TYPEOF(v) == INTSXP) {\n \t\treturn RType::FACTOR;\n \t} else if (TYPEOF(v) == LGLSXP) {\ndiff --git a/tools/rpkg/src/utils.cpp b/tools/rpkg/src/utils.cpp\nindex 46b6c7ef5316..758daa7c0a42 100644\n--- a/tools/rpkg/src/utils.cpp\n+++ b/tools/rpkg/src/utils.cpp\n@@ -65,36 +65,40 @@ static void AppendColumnSegment(SRC *source_data, Vector &result, idx_t count) {\n \t}\n }\n \n-Value RApiTypes::SexpToValue(SEXP valsexp) {\n+Value RApiTypes::SexpToValue(SEXP valsexp, R_len_t idx) {\n \tValue val;\n \tauto rtype = RApiTypes::DetectRType(valsexp);\n \tswitch (rtype) {\n \tcase RType::LOGICAL: {\n-\t\tauto lgl_val = INTEGER_POINTER(valsexp)[0];\n+\t\tauto lgl_val = INTEGER_POINTER(valsexp)[idx];\n \t\tval = Value::BOOLEAN(lgl_val);\n \t\tval.is_null = RBooleanType::IsNull(lgl_val);\n \t\tbreak;\n \t}\n \tcase RType::INTEGER: {\n-\t\tauto int_val = INTEGER_POINTER(valsexp)[0];\n+\t\tauto int_val = INTEGER_POINTER(valsexp)[idx];\n \t\tval = Value::INTEGER(int_val);\n \t\tval.is_null = RIntegerType::IsNull(int_val);\n \t\tbreak;\n \t}\n \tcase RType::NUMERIC: {\n-\t\tauto dbl_val = NUMERIC_POINTER(valsexp)[0];\n-\t\tval = Value::DOUBLE(dbl_val);\n-\t\tval.is_null = RDoubleType::IsNull(dbl_val);\n+\t\tauto dbl_val = NUMERIC_POINTER(valsexp)[idx];\n+\t\tbool is_null = RDoubleType::IsNull(dbl_val);\n+\t\tif (is_null) {\n+\t\t\tval = Value(LogicalType::DOUBLE);\n+\t\t} else {\n+\t\t\tval = Value::DOUBLE(dbl_val);\n+\t\t}\n \t\tbreak;\n \t}\n \tcase RType::STRING: {\n-\t\tauto str_val = STRING_ELT(valsexp, 0);\n+\t\tauto str_val = STRING_ELT(valsexp, idx);\n \t\tval = Value(CHAR(str_val));\n \t\tval.is_null = str_val == NA_STRING;\n \t\tbreak;\n \t}\n \tcase RType::FACTOR: {\n-\t\tauto int_val = INTEGER_POINTER(valsexp)[0];\n+\t\tauto int_val = INTEGER_POINTER(valsexp)[idx];\n \t\tauto levels = GET_LEVELS(valsexp);\n \t\tbool is_null = RIntegerType::IsNull(int_val);\n \t\tif (!is_null) {\n@@ -106,47 +110,87 @@ Value RApiTypes::SexpToValue(SEXP valsexp) {\n \t\tbreak;\n \t}\n \tcase RType::TIMESTAMP: {\n-\t\tauto ts_val = NUMERIC_POINTER(valsexp)[0];\n-\t\tval = Value::TIMESTAMP(RTimestampType::Convert(ts_val));\n-\t\tval.is_null = RTimestampType::IsNull(ts_val);\n+\t\tauto ts_val = NUMERIC_POINTER(valsexp)[idx];\n+\t\tbool is_null = RTimestampType::IsNull(ts_val);\n+\t\tif (!is_null) {\n+\t\t\tval = Value::TIMESTAMP(RTimestampType::Convert(ts_val));\n+\t\t} else {\n+\t\t\tval = Value(LogicalType::TIMESTAMP);\n+\t\t}\n \t\tbreak;\n \t}\n \tcase RType::DATE: {\n-\t\tauto d_val = NUMERIC_POINTER(valsexp)[0];\n+\t\tauto d_val = NUMERIC_POINTER(valsexp)[idx];\n \t\tval = Value::DATE(RDateType::Convert(d_val));\n \t\tval.is_null = RDateType::IsNull(d_val);\n \t\tbreak;\n \t}\n+\tcase RType::DATE_INTEGER: {\n+\t\tauto d_val = INTEGER_POINTER(valsexp)[idx];\n+\t\tval = Value::DATE(RDateType::Convert(d_val));\n+\t\tval.is_null = RIntegerType::IsNull(d_val);\n+\t\tbreak;\n+\t}\n \tcase RType::TIME_SECONDS: {\n-\t\tauto ts_val = NUMERIC_POINTER(valsexp)[0];\n+\t\tauto ts_val = NUMERIC_POINTER(valsexp)[idx];\n \t\tval = Value::TIME(RTimeSecondsType::Convert(ts_val));\n \t\tval.is_null = RTimeSecondsType::IsNull(ts_val);\n \t\tbreak;\n \t}\n \tcase RType::TIME_MINUTES: {\n-\t\tauto ts_val = NUMERIC_POINTER(valsexp)[0];\n+\t\tauto ts_val = NUMERIC_POINTER(valsexp)[idx];\n \t\tval = Value::TIME(RTimeMinutesType::Convert(ts_val));\n \t\tval.is_null = RTimeMinutesType::IsNull(ts_val);\n \t\tbreak;\n \t}\n \tcase RType::TIME_HOURS: {\n-\t\tauto ts_val = NUMERIC_POINTER(valsexp)[0];\n+\t\tauto ts_val = NUMERIC_POINTER(valsexp)[idx];\n \t\tval = Value::TIME(RTimeHoursType::Convert(ts_val));\n \t\tval.is_null = RTimeHoursType::IsNull(ts_val);\n \t\tbreak;\n \t}\n \tcase RType::TIME_DAYS: {\n-\t\tauto ts_val = NUMERIC_POINTER(valsexp)[0];\n+\t\tauto ts_val = NUMERIC_POINTER(valsexp)[idx];\n \t\tval = Value::TIME(RTimeDaysType::Convert(ts_val));\n \t\tval.is_null = RTimeDaysType::IsNull(ts_val);\n \t\tbreak;\n \t}\n \tcase RType::TIME_WEEKS: {\n-\t\tauto ts_val = NUMERIC_POINTER(valsexp)[0];\n+\t\tauto ts_val = NUMERIC_POINTER(valsexp)[idx];\n \t\tval = Value::TIME(RTimeWeeksType::Convert(ts_val));\n \t\tval.is_null = RTimeWeeksType::IsNull(ts_val);\n \t\tbreak;\n \t}\n+\tcase RType::TIME_SECONDS_INTEGER: {\n+\t\tauto ts_val = INTEGER_POINTER(valsexp)[idx];\n+\t\tval = Value::TIME(RTimeSecondsType::Convert(ts_val));\n+\t\tval.is_null = RIntegerType::IsNull(ts_val);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_MINUTES_INTEGER: {\n+\t\tauto ts_val = INTEGER_POINTER(valsexp)[idx];\n+\t\tval = Value::TIME(RTimeMinutesType::Convert(ts_val));\n+\t\tval.is_null = RIntegerType::IsNull(ts_val);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_HOURS_INTEGER: {\n+\t\tauto ts_val = INTEGER_POINTER(valsexp)[idx];\n+\t\tval = Value::TIME(RTimeHoursType::Convert(ts_val));\n+\t\tval.is_null = RIntegerType::IsNull(ts_val);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_DAYS_INTEGER: {\n+\t\tauto ts_val = INTEGER_POINTER(valsexp)[idx];\n+\t\tval = Value::TIME(RTimeDaysType::Convert(ts_val));\n+\t\tval.is_null = RIntegerType::IsNull(ts_val);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_WEEKS_INTEGER: {\n+\t\tauto ts_val = INTEGER_POINTER(valsexp)[idx];\n+\t\tval = Value::TIME(RTimeWeeksType::Convert(ts_val));\n+\t\tval.is_null = RIntegerType::IsNull(ts_val);\n+\t\tbreak;\n+\t}\n \tdefault:\n \t\tRf_error(\"duckdb_sexp_to_value: Unsupported type\");\n \t}\n",
  "test_patch": "diff --git a/tools/rpkg/tests/testthat/test-DBItest.R b/tools/rpkg/tests/testthat/test-DBItest.R\nindex 2c384e4d5ed2..e025f5edaf57 100644\n--- a/tools/rpkg/tests/testthat/test-DBItest.R\n+++ b/tools/rpkg/tests/testthat/test-DBItest.R\n@@ -11,22 +11,6 @@ DBItest::test_all(c(\n \n   if (packageVersion(\"DBItest\") < \"1.7.0.9004\") \"roundtrip_timestamp\", # broken test\n \n-  \"send_query_params\", # multiple bind parameters\n-  \"get_query_params\",\n-  \"bind_return_value\",\n-  \"bind_too_many\",\n-  \"bind_not_enough\",\n-  \"bind_multi_row_unequal_length\",\n-  \"bind_unnamed_param_named_placeholders\",\n-  \"bind_multi_row\",\n-  \"bind_multi_row_zero_length\",\n-  \"bind_multi_row_statement\",\n-  \"bind_repeated\",\n-  \"bind_integer\",\n-  \"bind_repeated_untouched\",\n-  \"bind_.*\",\n-\n-\n   \"data_64_bit_numeric_warning\", # 64 bit, not now\n   \"data_64_bit_lossless\",\n   \"roundtrip_64_bit_character\",\n@@ -38,4 +22,4 @@ DBItest::test_all(c(\n   \"append_roundtrip_64_bit_roundtrip\",\n \n   \"column_info_consistent\" # won't fix: https://github.com/r-dbi/DBItest/issues/181\n-))\n\\ No newline at end of file\n+))\ndiff --git a/tools/rpkg/tests/testthat/test_bind.R b/tools/rpkg/tests/testthat/test_bind.R\nindex 4447143ad616..1587cecca8e3 100644\n--- a/tools/rpkg/tests/testthat/test_bind.R\n+++ b/tools/rpkg/tests/testthat/test_bind.R\n@@ -44,7 +44,7 @@ test_that(\"dbBind() works as expected for all types\", {\n \n   test_convert(con, \"TIMESTAMP\", as.POSIXct(\"2019-11-26 21:11Z\", \"UTC\"))\n \n-  test_convert(con, \"STRING\", as.factor(\"Hello, World\"))\n+  expect_warning(test_convert(con, \"STRING\", as.factor(\"Hello, World\")))\n \n   dbDisconnect(con, shutdown = T)\n })\n@@ -106,18 +106,15 @@ test_that(\"various error cases for dbBind()\", {\n \n   expect_error(dbBind(q, list()))\n   expect_error(dbBind(q, list(1, 2)))\n+  expect_error(dbBind(q, list(\"asdf\")))\n   expect_error(dbBind(q, list(\"asdf\", \"asdf\")))\n \n   expect_error(dbBind(q))\n \n-  expect_error(dbBind(q, 1))\n-  expect_error(dbBind(q, 1, 2))\n   expect_error(dbBind(q, \"asdf\"))\n-  expect_error(dbBind(q, \"asdf\", \"asdf\"))\n \n   dbClearResult(q)\n \n-  expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", 1, 2))\n   expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", \"asdf\"))\n   expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", \"asdf\", \"asdf\"))\n   expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\"))\n",
  "problem_statement": "R: Fix DBItest tests\nhttps://github.com/cwida/duckdb/pull/738/commits/7b610e930071eb90fd3721d5cc358e9f88d7a92c and others.\n",
  "hints_text": "",
  "created_at": "2021-08-11T19:28:18Z"
}