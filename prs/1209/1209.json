{
  "repo": "duckdb/duckdb",
  "pull_number": 1209,
  "instance_id": "duckdb__duckdb-1209",
  "issue_numbers": [
    "1206"
  ],
  "base_commit": "0db93ef41c030ed613e0a5713d43e69cea6bc66e",
  "patch": "diff --git a/tools/shell/linenoise.cpp b/tools/shell/linenoise.cpp\nindex 24eac454a67f..8f1e6259758f 100644\n--- a/tools/shell/linenoise.cpp\n+++ b/tools/shell/linenoise.cpp\n@@ -137,6 +137,7 @@ static int atexit_registered = 0;   /* Register atexit just 1 time. */\n static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;\n static int history_len = 0;\n static char **history = NULL;\n+static char *history_file = NULL;\n #ifndef DISABLE_HIGHLIGHT\n #include <string>\n \n@@ -1418,6 +1419,19 @@ int linenoiseHistoryAdd(const char *line) {\n \t}\n \thistory[history_len] = linecopy;\n \thistory_len++;\n+\tif (history_file && strlen(line) > 0) {\n+\t\t// if there is a history file that we loaded from\n+\t\t// append to the history\n+\t\t// this way we can recover history in case of a crash\n+\t\tFILE *fp;\n+\n+\t\tfp = fopen(history_file, \"a\");\n+\t\tif (fp == NULL) {\n+\t\t\treturn 1;\n+\t\t}\n+\t\tfprintf(fp, \"%s\\n\", line);\n+\t\tfclose(fp);\n+\t}\n \treturn 1;\n }\n \n@@ -1483,19 +1497,24 @@ int linenoiseHistoryLoad(const char *filename) {\n \tFILE *fp = fopen(filename, \"r\");\n \tchar buf[LINENOISE_MAX_LINE];\n \n-\tif (fp == NULL)\n+\tif (fp == NULL) {\n \t\treturn -1;\n+\t}\n \n \twhile (fgets(buf, LINENOISE_MAX_LINE, fp) != NULL) {\n \t\tchar *p;\n \n \t\tp = strchr(buf, '\\r');\n-\t\tif (!p)\n+\t\tif (!p) {\n \t\t\tp = strchr(buf, '\\n');\n-\t\tif (p)\n+\t\t}\n+\t\tif (p) {\n \t\t\t*p = '\\0';\n+\t\t}\n \t\tlinenoiseHistoryAdd(buf);\n \t}\n \tfclose(fp);\n+\n+\thistory_file = strdup(filename);\n \treturn 0;\n }\ndiff --git a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\nindex 57d8962ab73b..8fe3046c13ba 100644\n--- a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n+++ b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n@@ -552,7 +552,11 @@ int sqlite3_bind_text(sqlite3_stmt *stmt, int idx, const char *val, int length,\n \tif (free_func && ((ptrdiff_t)free_func) != -1) {\n \t\tfree_func((void *)val);\n \t}\n-\treturn sqlite3_internal_bind_value(stmt, idx, Value(value));\n+\ttry {\n+\t\treturn sqlite3_internal_bind_value(stmt, idx, Value(value));\n+\t} catch(std::exception &ex) {\n+\t\treturn SQLITE_ERROR;\n+\t}\n }\n \n int sqlite3_clear_bindings(sqlite3_stmt *stmt) {\n",
  "test_patch": "diff --git a/tools/shell/shell-test.py b/tools/shell/shell-test.py\nindex fd46a1845953..222abddfa027 100644\n--- a/tools/shell/shell-test.py\n+++ b/tools/shell/shell-test.py\n@@ -414,6 +414,19 @@ def tf():\n \n shutil.rmtree(target_dir)\n \n+# test using .import with a CSV file containing invalid UTF8\n+\n+duckdb_nonsensecsv = 'duckdbtest_nonsensecsv.csv'\n+with open(duckdb_nonsensecsv, 'wb+') as f:\n+     f.write(b'\\xFF\\n')\n+test('''\n+.nullvalue NULL\n+CREATE TABLE test(i INTEGER);\n+.import duckdbtest_nonsensecsv.csv test\n+SELECT * FROM test;\n+''', out=\"NULL\")\n+os.remove(duckdb_nonsensecsv)\n+\n # dump blobs: FIXME\n # test('''\n # CREATE TABLE a (b BLOB);\n",
  "problem_statement": "Abort on gziped csv files when doing import\n```\r\nD .import '/mnt/volatile/export/raw/HTM_KV6_20201208.csv.gz' 'kv6_import'\r\nterminate called after throwing an instance of 'duckdb::Exception'\r\n  what():  String value is not valid UTF8\r\nAborted (core dumped)\r\n```\r\n\r\nThis works;\r\n```\r\nINSERT INTO kv6_import SELECT * FROM read_csv_auto('/mnt/volatile/export/raw/HTM_KV6_20201208.csv.gz');\r\n```\n",
  "hints_text": "Thanks for the report! `.import` uses the SQLite shell's built-in CSV reader rather than DuckDB's csv reader, which is rather barebones and seems to not support `.csv.gz`. It actually correctly throws an exception here but this should be caught and reported rather than crashing the client.",
  "created_at": "2020-12-08T21:33:57Z"
}