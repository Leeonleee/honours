You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Abort on gziped csv files when doing import
```
D .import '/mnt/volatile/export/raw/HTM_KV6_20201208.csv.gz' 'kv6_import'
terminate called after throwing an instance of 'duckdb::Exception'
  what():  String value is not valid UTF8
Aborted (core dumped)
```

This works;
```
INSERT INTO kv6_import SELECT * FROM read_csv_auto('/mnt/volatile/export/raw/HTM_KV6_20201208.csv.gz');
```

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of tools/shell/linenoise.cpp]
1: /* linenoise.c -- guerrilla line editing library against the idea that a
2:  * line editing lib needs to be 20,000 lines of C code.
3:  *
4:  * You can find the latest source code at:
5:  *
6:  *   http://github.com/antirez/linenoise
7:  *
8:  * Does a number of crazy assumptions that happen to be true in 99.9999% of
9:  * the 2010 UNIX computers around.
10:  *
11:  * ------------------------------------------------------------------------
12:  *
13:  * Copyright (c) 2010-2016, Salvatore Sanfilippo <antirez at gmail dot com>
14:  * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>
15:  *
16:  * All rights reserved.
17:  *
18:  * Redistribution and use in source and binary forms, with or without
19:  * modification, are permitted provided that the following conditions are
20:  * met:
21:  *
22:  *  *  Redistributions of source code must retain the above copyright
23:  *     notice, this list of conditions and the following disclaimer.
24:  *
25:  *  *  Redistributions in binary form must reproduce the above copyright
26:  *     notice, this list of conditions and the following disclaimer in the
27:  *     documentation and/or other materials provided with the distribution.
28:  *
29:  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
30:  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
31:  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
32:  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
33:  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
34:  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
35:  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
36:  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
37:  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
38:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
39:  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
40:  *
41:  * ------------------------------------------------------------------------
42:  *
43:  * References:
44:  * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
45:  * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html
46:  *
47:  * Todo list:
48:  * - Filter bogus Ctrl+<char> combinations.
49:  * - Win32 support
50:  *
51:  * Bloat:
52:  * - History search like Ctrl+r in readline?
53:  *
54:  * List of escape sequences used by this program, we do everything just
55:  * with three sequences. In order to be so cheap we may have some
56:  * flickering effect with some slow terminal, but the lesser sequences
57:  * the more compatible.
58:  *
59:  * EL (Erase Line)
60:  *    Sequence: ESC [ n K
61:  *    Effect: if n is 0 or missing, clear from cursor to end of line
62:  *    Effect: if n is 1, clear from beginning of line to cursor
63:  *    Effect: if n is 2, clear entire line
64:  *
65:  * CUF (CUrsor Forward)
66:  *    Sequence: ESC [ n C
67:  *    Effect: moves cursor forward n chars
68:  *
69:  * CUB (CUrsor Backward)
70:  *    Sequence: ESC [ n D
71:  *    Effect: moves cursor backward n chars
72:  *
73:  * The following is used to get the terminal width if getting
74:  * the width with the TIOCGWINSZ ioctl fails
75:  *
76:  * DSR (Device Status Report)
77:  *    Sequence: ESC [ 6 n
78:  *    Effect: reports the current cusor position as ESC [ n ; m R
79:  *            where n is the row and m is the column
80:  *
81:  * When multi line mode is enabled, we also use an additional escape
82:  * sequence. However multi line editing is disabled by default.
83:  *
84:  * CUU (Cursor Up)
85:  *    Sequence: ESC [ n A
86:  *    Effect: moves cursor up of n chars.
87:  *
88:  * CUD (Cursor Down)
89:  *    Sequence: ESC [ n B
90:  *    Effect: moves cursor down of n chars.
91:  *
92:  * When linenoiseClearScreen() is called, two additional escape sequences
93:  * are used in order to clear the screen and position the cursor at home
94:  * position.
95:  *
96:  * CUP (Cursor position)
97:  *    Sequence: ESC [ H
98:  *    Effect: moves the cursor to upper left corner
99:  *
100:  * ED (Erase display)
101:  *    Sequence: ESC [ 2 J
102:  *    Effect: clear the whole screen
103:  *
104:  */
105: 
106: #include <termios.h>
107: #include <unistd.h>
108: #include <stdlib.h>
109: #include <stdio.h>
110: #include <errno.h>
111: #include <string.h>
112: #include <stdlib.h>
113: #include <ctype.h>
114: #include <sys/stat.h>
115: #include <sys/types.h>
116: #include <sys/ioctl.h>
117: #include <unistd.h>
118: #include "linenoise.h"
119: #include "utf8proc_wrapper.h"
120: 
121: #if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
122: // disable highlighting on windows (for now?)
123: #define DISABLE_HIGHLIGHT
124: #endif
125: 
126: #define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100
127: #define LINENOISE_MAX_LINE 4096
128: static const char *unsupported_term[] = {"dumb", "cons25", "emacs", NULL};
129: static linenoiseCompletionCallback *completionCallback = NULL;
130: static linenoiseHintsCallback *hintsCallback = NULL;
131: static linenoiseFreeHintsCallback *freeHintsCallback = NULL;
132: 
133: static struct termios orig_termios; /* In order to restore at exit.*/
134: static int rawmode = 0;             /* For atexit() function to check if restore is needed*/
135: static int mlmode = 0;              /* Multi line mode. Default is single line. */
136: static int atexit_registered = 0;   /* Register atexit just 1 time. */
137: static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;
138: static int history_len = 0;
139: static char **history = NULL;
140: #ifndef DISABLE_HIGHLIGHT
141: #include <string>
142: 
143: static int enableHighlighting = 1;
144: struct Color {
145: 	const char *color_name;
146: 	const char *highlight;
147: };
148: static Color terminal_colors[] = {
149: 	{"red", "\033[31m"},
150: 	{"green", "\033[32m"},
151: 	{"yellow", "\033[33m"},
152: 	{"blue", "\033[34m"},
153: 	{"magenta", "\033[35m"},
154: 	{"cyan", "\033[36m"},
155: 	{"white", "\033[37m"},
156: 	{"brightblack", "\033[90m"},
157: 	{"brightred", "\033[91m"},
158: 	{"brightgreen", "\033[92m"},
159: 	{"brightyellow", "\033[93m"},
160: 	{"brightblue", "\033[94m"},
161: 	{"brightmagenta", "\033[95m"},
162: 	{"brightcyan", "\033[96m"},
163: 	{"brightwhite", "\033[97m"},
164: 	{nullptr, nullptr}
165: };
166: static std::string bold = "\033[1m";
167: static std::string keyword = "\033[32m\033[1m";
168: static std::string constant = "\033[33m";
169: static std::string reset = "\033[00m";
170: #endif
171: 
172: /* The linenoiseState structure represents the state during line editing.
173:  * We pass this state to functions implementing specific editing
174:  * functionalities. */
175: struct linenoiseState {
176: 	int ifd;            /* Terminal stdin file descriptor. */
177: 	int ofd;            /* Terminal stdout file descriptor. */
178: 	char *buf;          /* Edited line buffer. */
179: 	size_t buflen;      /* Edited line buffer size. */
180: 	const char *prompt; /* Prompt to display. */
181: 	size_t plen;        /* Prompt length. */
182: 	size_t pos;         /* Current cursor position. */
183: 	size_t oldpos;      /* Previous refresh cursor position. */
184: 	size_t len;         /* Current edited line length. */
185: 	size_t cols;        /* Number of columns in terminal. */
186: 	size_t maxrows;     /* Maximum num of rows used so far (multiline mode) */
187: 	int history_index;  /* The history index we are currently editing. */
188: };
189: 
190: enum KEY_ACTION {
191: 	KEY_NULL = 0,   /* NULL */
192: 	CTRL_A = 1,     /* Ctrl+a */
193: 	CTRL_B = 2,     /* Ctrl-b */
194: 	CTRL_C = 3,     /* Ctrl-c */
195: 	CTRL_D = 4,     /* Ctrl-d */
196: 	CTRL_E = 5,     /* Ctrl-e */
197: 	CTRL_F = 6,     /* Ctrl-f */
198: 	CTRL_H = 8,     /* Ctrl-h */
199: 	TAB = 9,        /* Tab */
200: 	CTRL_K = 11,    /* Ctrl+k */
201: 	CTRL_L = 12,    /* Ctrl+l */
202: 	ENTER = 13,     /* Enter */
203: 	CTRL_N = 14,    /* Ctrl-n */
204: 	CTRL_P = 16,    /* Ctrl-p */
205: 	CTRL_T = 20,    /* Ctrl-t */
206: 	CTRL_U = 21,    /* Ctrl+u */
207: 	CTRL_W = 23,    /* Ctrl+w */
208: 	ESC = 27,       /* Escape */
209: 	BACKSPACE = 127 /* Backspace */
210: };
211: 
212: static void linenoiseAtExit(void);
213: int linenoiseHistoryAdd(const char *line);
214: static void refreshLine(struct linenoiseState *l);
215: 
216: /* Debugging macro. */
217: #if 0
218: FILE *lndebug_fp = NULL;
219: #define lndebug(...)                                                                                                   \
220: 	do {                                                                                                               \
221: 		if (lndebug_fp == NULL) {                                                                                      \
222: 			lndebug_fp = fopen("/tmp/lndebug.txt", "a");                                                               \
223: 			fprintf(lndebug_fp, "[%d %d %d] p: %d, rows: %d, rpos: %d, max: %d, oldmax: %d\n", (int)l->len,            \
224: 			        (int)l->pos, (int)l->oldpos, plen, rows, rpos, (int)l->maxrows, old_rows);                         \
225: 		}                                                                                                              \
226: 		fprintf(lndebug_fp, ", " __VA_ARGS__);                                                                         \
227: 		fflush(lndebug_fp);                                                                                            \
228: 	} while (0)
229: #else
230: #define lndebug(fmt, ...)
231: #endif
232: 
233: /* ======================= Low level terminal handling ====================== */
234: 
235: /* Set if to use or not the multi line mode. */
236: void linenoiseSetMultiLine(int ml) {
237: 	mlmode = ml;
238: }
239: 
240: /* Return true if the terminal name is in the list of terminals we know are
241:  * not able to understand basic escape sequences. */
242: static int isUnsupportedTerm(void) {
243: 	char *term = getenv("TERM");
244: 	int j;
245: 
246: 	if (term == NULL)
247: 		return 0;
248: 	for (j = 0; unsupported_term[j]; j++)
249: 		if (!strcasecmp(term, unsupported_term[j]))
250: 			return 1;
251: 	return 0;
252: }
253: 
254: /* Raw mode: 1960 magic shit. */
255: static int enableRawMode(int fd) {
256: 	struct termios raw;
257: 
258: 	if (!isatty(STDIN_FILENO))
259: 		goto fatal;
260: 	if (!atexit_registered) {
261: 		atexit(linenoiseAtExit);
262: 		atexit_registered = 1;
263: 	}
264: 	if (tcgetattr(fd, &orig_termios) == -1)
265: 		goto fatal;
266: 
267: 	raw = orig_termios; /* modify the original mode */
268: 	/* input modes: no break, no CR to NL, no parity check, no strip char,
269: 	 * no start/stop output control. */
270: 	raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
271: 	/* output modes - disable post processing */
272: 	raw.c_oflag &= ~(OPOST);
273: 	/* control modes - set 8 bit chars */
274: 	raw.c_cflag |= (CS8);
275: 	/* local modes - choing off, canonical off, no extended functions,
276: 	 * no signal chars (^Z,^C) */
277: 	raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
278: 	/* control chars - set return condition: min number of bytes and timer.
279: 	 * We want read to return every single byte, without timeout. */
280: 	raw.c_cc[VMIN] = 1;
281: 	raw.c_cc[VTIME] = 0; /* 1 byte, no timer */
282: 
283: 	/* put terminal in raw mode after flushing */
284: 	if (tcsetattr(fd, TCSADRAIN, &raw) < 0)
285: 		goto fatal;
286: 	rawmode = 1;
287: 	return 0;
288: 
289: fatal:
290: 	errno = ENOTTY;
291: 	return -1;
292: }
293: 
294: static void disableRawMode(int fd) {
295: 	/* Don't even check the return value as it's too late. */
296: 	if (rawmode && tcsetattr(fd, TCSADRAIN, &orig_termios) != -1)
297: 		rawmode = 0;
298: }
299: 
300: /* Use the ESC [6n escape sequence to query the horizontal cursor position
301:  * and return it. On error -1 is returned, on success the position of the
302:  * cursor. */
303: static int getCursorPosition(int ifd, int ofd) {
304: 	char buf[32];
305: 	int cols, rows;
306: 	unsigned int i = 0;
307: 
308: 	/* Report cursor location */
309: 	if (write(ofd, "\x1b[6n", 4) != 4)
310: 		return -1;
311: 
312: 	/* Read the response: ESC [ rows ; cols R */
313: 	while (i < sizeof(buf) - 1) {
314: 		if (read(ifd, buf + i, 1) != 1)
315: 			break;
316: 		if (buf[i] == 'R')
317: 			break;
318: 		i++;
319: 	}
320: 	buf[i] = '\0';
321: 
322: 	/* Parse it. */
323: 	if (buf[0] != ESC || buf[1] != '[')
324: 		return -1;
325: 	if (sscanf(buf + 2, "%d;%d", &rows, &cols) != 2)
326: 		return -1;
327: 	return cols;
328: }
329: 
330: /* Try to get the number of columns in the current terminal, or assume 80
331:  * if it fails. */
332: static int getColumns(int ifd, int ofd) {
333: 	struct winsize ws;
334: 
335: 	if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {
336: 		/* ioctl() failed. Try to query the terminal itself. */
337: 		int start, cols;
338: 
339: 		/* Get the initial position so we can restore it later. */
340: 		start = getCursorPosition(ifd, ofd);
341: 		if (start == -1)
342: 			goto failed;
343: 
344: 		/* Go to right margin and get position. */
345: 		if (write(ofd, "\x1b[999C", 6) != 6)
346: 			goto failed;
347: 		cols = getCursorPosition(ifd, ofd);
348: 		if (cols == -1)
349: 			goto failed;
350: 
351: 		/* Restore position. */
352: 		if (cols > start) {
353: 			char seq[32];
354: 			snprintf(seq, 32, "\x1b[%dD", cols - start);
355: 			if (write(ofd, seq, strlen(seq)) == -1) {
356: 				/* Can't recover... */
357: 			}
358: 		}
359: 		return cols;
360: 	} else {
361: 		return ws.ws_col;
362: 	}
363: 
364: failed:
365: 	return 80;
366: }
367: 
368: /* Clear the screen. Used to handle ctrl+l */
369: void linenoiseClearScreen(void) {
370: 	if (write(STDOUT_FILENO, "\x1b[H\x1b[2J", 7) <= 0) {
371: 		/* nothing to do, just to avoid warning. */
372: 	}
373: }
374: 
375: /* Beep, used for completion when there is nothing to complete or when all
376:  * the choices were already shown. */
377: static void linenoiseBeep(void) {
378: 	fprintf(stderr, "\x7");
379: 	fflush(stderr);
380: }
381: 
382: /* ============================== Completion ================================ */
383: 
384: /* Free a list of completion option populated by linenoiseAddCompletion(). */
385: static void freeCompletions(linenoiseCompletions *lc) {
386: 	size_t i;
387: 	for (i = 0; i < lc->len; i++)
388: 		free(lc->cvec[i]);
389: 	if (lc->cvec != NULL)
390: 		free(lc->cvec);
391: }
392: 
393: /* This is an helper function for linenoiseEdit() and is called when the
394:  * user types the <tab> key in order to complete the string currently in the
395:  * input.
396:  *
397:  * The state of the editing is encapsulated into the pointed linenoiseState
398:  * structure as described in the structure definition. */
399: static int completeLine(struct linenoiseState *ls) {
400: 	linenoiseCompletions lc = {0, NULL};
401: 	int nread, nwritten;
402: 	char c = 0;
403: 
404: 	completionCallback(ls->buf, &lc);
405: 	if (lc.len == 0) {
406: 		linenoiseBeep();
407: 	} else {
408: 		size_t stop = 0, i = 0;
409: 
410: 		while (!stop) {
411: 			/* Show completion or original buffer */
412: 			if (i < lc.len) {
413: 				struct linenoiseState saved = *ls;
414: 
415: 				ls->len = ls->pos = strlen(lc.cvec[i]);
416: 				ls->buf = lc.cvec[i];
417: 				refreshLine(ls);
418: 				ls->len = saved.len;
419: 				ls->pos = saved.pos;
420: 				ls->buf = saved.buf;
421: 			} else {
422: 				refreshLine(ls);
423: 			}
424: 
425: 			nread = read(ls->ifd, &c, 1);
426: 			if (nread <= 0) {
427: 				freeCompletions(&lc);
428: 				return -1;
429: 			}
430: 
431: 			switch (c) {
432: 			case 9: /* tab */
433: 				i = (i + 1) % (lc.len + 1);
434: 				if (i == lc.len)
435: 					linenoiseBeep();
436: 				break;
437: 			case 27: /* escape */
438: 				/* Re-show original buffer */
439: 				if (i < lc.len)
440: 					refreshLine(ls);
441: 				stop = 1;
442: 				break;
443: 			default:
444: 				/* Update buffer and return */
445: 				if (i < lc.len) {
446: 					nwritten = snprintf(ls->buf, ls->buflen, "%s", lc.cvec[i]);
447: 					ls->len = ls->pos = nwritten;
448: 				}
449: 				stop = 1;
450: 				break;
451: 			}
452: 		}
453: 	}
454: 
455: 	freeCompletions(&lc);
456: 	return c; /* Return last read character */
457: }
458: 
459: /* Register a callback function to be called for tab-completion. */
460: void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {
461: 	completionCallback = fn;
462: }
463: 
464: /* Register a hits function to be called to show hits to the user at the
465:  * right of the prompt. */
466: void linenoiseSetHintsCallback(linenoiseHintsCallback *fn) {
467: 	hintsCallback = fn;
468: }
469: 
470: /* Register a function to free the hints returned by the hints callback
471:  * registered with linenoiseSetHintsCallback(). */
472: void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *fn) {
473: 	freeHintsCallback = fn;
474: }
475: 
476: /* This function is used by the callback function registered by the user
477:  * in order to add completion options given the input string when the
478:  * user typed <tab>. See the example.c source code for a very easy to
479:  * understand example. */
480: void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
481: 	size_t len = strlen(str);
482: 	char *copy, **cvec;
483: 
484: 	copy = (char*) malloc(len + 1);
485: 	if (copy == NULL)
486: 		return;
487: 	memcpy(copy, str, len + 1);
488: 	cvec = (char**) realloc(lc->cvec, sizeof(char *) * (lc->len + 1));
489: 	if (cvec == NULL) {
490: 		free(copy);
491: 		return;
492: 	}
493: 	lc->cvec = cvec;
494: 	lc->cvec[lc->len++] = copy;
495: }
496: 
497: /* =========================== Line editing ================================= */
498: 
499: /* We define a very simple "append buffer" structure, that is an heap
500:  * allocated string where we can append to. This is useful in order to
501:  * write all the escape sequences in a buffer and flush them to the standard
502:  * output in a single call, to avoid flickering effects. */
503: struct abuf {
504: 	char *b;
505: 	int len;
506: };
507: 
508: static void abInit(struct abuf *ab) {
509: 	ab->b = NULL;
510: 	ab->len = 0;
511: }
512: 
513: static void abAppend(struct abuf *ab, const char *s, int len) {
514: 	char *new_entry = (char*) realloc(ab->b, ab->len + len);
515: 
516: 	if (new_entry == NULL)
517: 		return;
518: 	memcpy(new_entry + ab->len, s, len);
519: 	ab->b = new_entry;
520: 	ab->len += len;
521: }
522: 
523: static void abFree(struct abuf *ab) {
524: 	free(ab->b);
525: }
526: 
527: /* Helper of refreshSingleLine() and refreshMultiLine() to show hints
528:  * to the right of the prompt. */
529: void refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {
530: 	char seq[64];
531: 	if (hintsCallback && plen + l->len < l->cols) {
532: 		int color = -1, bold = 0;
533: 		char *hint = hintsCallback(l->buf, &color, &bold);
534: 		if (hint) {
535: 			int hintlen = strlen(hint);
536: 			int hintmaxlen = l->cols - (plen + l->len);
537: 			if (hintlen > hintmaxlen)
538: 				hintlen = hintmaxlen;
539: 			if (bold == 1 && color == -1)
540: 				color = 37;
541: 			if (color != -1 || bold != 0)
542: 				snprintf(seq, 64, "\033[%d;%d;49m", bold, color);
543: 			else
544: 				seq[0] = '\0';
545: 			abAppend(ab, seq, strlen(seq));
546: 			abAppend(ab, hint, hintlen);
547: 			if (color != -1 || bold != 0)
548: 				abAppend(ab, "\033[0m", 4);
549: 			/* Call the function to free the hint returned. */
550: 			if (freeHintsCallback)
551: 				freeHintsCallback(hint);
552: 		}
553: 	}
554: }
555: 
556: size_t linenoiseComputeRenderWidth(const char *buf, size_t len) {
557: 	if (utf8proc_is_valid(buf, len)) {
558: 		// utf8 in prompt, get render width
559: 		size_t cpos = 0;
560: 		size_t render_width = 0;
561: 		while (cpos < len) {
562: 			size_t char_render_width = utf8proc_render_width(buf, len, cpos);
563: 			cpos = utf8proc_next_grapheme_cluster(buf, len, cpos);
564: 			render_width += char_render_width;
565: 		}
566: 		return render_width;
567: 	} else {
568: 		// invalid utf8 in prompt, use length in bytes
569: 		return len;
570: 	}
571: }
572: 
573: int linenoiseGetRenderPosition(const char *buf, size_t len, int max_width, int *n) {
574: 	if (utf8proc_is_valid(buf, len)) {
575: 		// utf8 in prompt, get render width
576: 		size_t cpos = 0;
577: 		size_t render_width = 0;
578: 		while (cpos < len) {
579: 			size_t char_render_width = utf8proc_render_width(buf, len, cpos);
580: 			if (int(render_width + char_render_width) > max_width) {
581: 				*n = render_width;
582: 				return cpos;
583: 			}
584: 			cpos = utf8proc_next_grapheme_cluster(buf, len, cpos);
585: 			render_width += char_render_width;
586: 		}
587: 		*n = render_width;
588: 		return len;
589: 	} else {
590: 		// invalid utf8, return -1
591: 		return -1;
592: 	}
593: }
594: 
595: #ifndef DISABLE_HIGHLIGHT
596: const char *getColorOption(const char *option) {
597: 	size_t index = 0;
598: 	while(terminal_colors[index].color_name) {
599: 		if (strcmp(terminal_colors[index].color_name, option) == 0) {
600: 			return terminal_colors[index].highlight;
601: 		}
602: 		index++;
603: 	}
604: 	return nullptr;
605: }
606: #endif
607: 
608: int linenoiseParseOption(const char **azArg, int nArg, const char **out_error) {
609: #ifndef DISABLE_HIGHLIGHT
610: 	if (strcmp(azArg[0], "highlight") == 0) {
611: 		if (nArg == 2) {
612: 			if (strcmp(azArg[1], "off") == 0 || strcmp(azArg[1], "0") == 0) {
613: 				enableHighlighting = 0;
614: 				return 1;
615: 			} else if (strcmp(azArg[1], "on") == 0 || strcmp(azArg[1], "1") == 0) {
616: 				enableHighlighting = 1;
617: 				return 1;
618: 			}
619: 		}
620: 		*out_error = "Expected usage: .highlight [off|on]";
621: 		return 1;
622: 	} else if (strcmp(azArg[0], "keyword") == 0) {
623: 		if (nArg == 2) {
624: 			const char *option = getColorOption(azArg[1]);
625: 			if (option) {
626: 				keyword = option;
627: 				return 1;
628: 			}
629: 		}
630: 		*out_error = "Expected usage: .keyword [red|green|yellow|blue|magenta|cyan|white|brightblack|brightred|brightgreen|brightyellow|brightblue|brightmagenta|brightcyan|brightwhite]";
631: 		return 1;
632: 	} else if (strcmp(azArg[0], "constant") == 0) {
633: 		if (nArg == 2) {
634: 			const char *option = getColorOption(azArg[1]);
635: 			if (option) {
636: 				constant = option;
637: 				return 1;
638: 			}
639: 		}
640: 		*out_error = "Expected usage: .constant [red|green|yellow|blue|magenta|cyan|white|brightblack|brightred|brightgreen|brightyellow|brightblue|brightmagenta|brightcyan|brightwhite]";
641: 		return 1;
642: 	} else if (strcmp(azArg[0], "keywordcode") == 0) {
643: 		if (nArg == 2) {
644: 			keyword = azArg[1];
645: 			return 1;
646: 		}
647: 		*out_error = "Expected usage: .keywordcode [terminal_code]";
648: 		return 1;
649: 	} else if (strcmp(azArg[0], "constantcode") == 0) {
650: 		if (nArg == 2) {
651: 			constant = azArg[1];
652: 			return 1;
653: 		}
654: 		*out_error = "Expected usage: .constantcode [terminal_code]";
655: 		return 1;
656: 	}
657: #endif
658: 	return 0;
659: }
660: 
661: #ifndef DISABLE_HIGHLIGHT
662: #include <sstream>
663: #include "duckdb/parser/parser.hpp"
664: 
665: std::string highlightText(char *buf, size_t len, size_t start_pos, size_t end_pos) {
666: 	std::string sql(buf, len);
667: 	auto tokens = duckdb::Parser::Tokenize(sql);
668: 	std::stringstream ss;
669: 	for(size_t i = 0; i < tokens.size(); i++) {
670: 		size_t next = i  + 1 < tokens.size() ? tokens[i + 1].start : len;
671: 		if (next < start_pos) {
672: 			// this token is not rendered at all
673: 			continue;
674: 		}
675: 
676: 		auto &token = tokens[i];
677: 		size_t start = token.start > start_pos ? token.start : start_pos;
678: 		size_t end = next > end_pos ? end_pos : next;
679: 		if (end <= start) {
680: 			continue;
681: 		}
682: 		std::string text = std::string(buf + start, end - start);
683: 		switch(token.type) {
684: 		case duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_KEYWORD:
685: 			ss << keyword << text << reset;
686: 			break;
687: 		case duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_NUMERIC_CONSTANT:
688: 		case duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_STRING_CONSTANT:
689: 			ss << constant << text << reset;
690: 			break;
691: 		default:
692: 			ss << text;
693: 		}
694: 	}
695: 	return ss.str();
696: }
697: #endif
698: 
699: 
700: /* Single line low level line refresh.
701:  *
702:  * Rewrite the currently edited line accordingly to the buffer content,
703:  * cursor position, and number of columns of the terminal. */
704: static void refreshSingleLine(struct linenoiseState *l) {
705: 	char seq[64];
706: 	size_t plen = linenoiseComputeRenderWidth(l->prompt, strlen(l->prompt));
707: 	int fd = l->ofd;
708: 	char *buf = l->buf;
709: 	size_t len = l->len;
710: 	size_t pos = l->pos;
711: 	struct abuf ab;
712: 	size_t render_pos = 0;
713: #ifndef DISABLE_HIGHLIGHT
714: 	std::string highlight_buffer;
715: #endif
716: 
717: 	if (utf8proc_is_valid(l->buf, l->len)) {
718: 		// utf8 in prompt, handle rendering
719: 		size_t remaining_render_width = l->cols - plen - 1;
720: 		size_t start_pos = 0;
721: 		size_t cpos = 0;
722: 		size_t prev_pos = 0;
723: 		size_t total_render_width = 0;
724: 		while (cpos < len) {
725: 			size_t char_render_width = utf8proc_render_width(buf, len, cpos);
726: 			prev_pos = cpos;
727: 			cpos = utf8proc_next_grapheme_cluster(buf, len, cpos);
728: 			total_render_width += cpos - prev_pos;
729: 			if (total_render_width >= remaining_render_width) {
730: 				// character does not fit anymore! we need to figure something out
731: 				if (prev_pos >= l->pos) {
732: 					// we passed the cursor: break
733: 					cpos = prev_pos;
734: 					break;
735: 				} else {
736: 					// we did not pass the cursor yet! remove characters from the start until it fits again
737: 					while (total_render_width >= remaining_render_width) {
738: 						size_t start_char_width = utf8proc_render_width(buf, len, start_pos);
739: 						size_t new_start = utf8proc_next_grapheme_cluster(buf, len, start_pos);
740: 						total_render_width -= new_start - start_pos;
741: 						start_pos = new_start;
742: 						render_pos -= start_char_width;
743: 					}
744: 				}
745: 			}
746: 			if (prev_pos < l->pos) {
747: 				render_pos += char_render_width;
748: 			}
749: 		}
750: #ifndef DISABLE_HIGHLIGHT
751: 		if (enableHighlighting) {
752: 			highlight_buffer = highlightText(l->buf, l->len, start_pos, cpos);
753: 			buf = (char*) highlight_buffer.c_str();
754: 			len = highlight_buffer.size();
755: 		} else
756: #endif
757: 		{
758: 			buf = buf + start_pos;
759: 			len = cpos - start_pos;
760: 		}
761: 	} else {
762: 		// invalid UTF8: fallback
763: 		while ((plen + pos) >= l->cols) {
764: 			buf++;
765: 			len--;
766: 			pos--;
767: 		}
768: 		while (plen + len > l->cols) {
769: 			len--;
770: 		}
771: 		render_pos = pos;
772: 	}
773: 
774: 	abInit(&ab);
775: 	/* Cursor to left edge */
776: 	snprintf(seq, 64, "\r");
777: 	abAppend(&ab, seq, strlen(seq));
778: 	/* Write the prompt and the current buffer content */
779: 	abAppend(&ab, l->prompt, strlen(l->prompt));
780: 	abAppend(&ab, buf, len);
781: 	/* Show hits if any. */
782: 	refreshShowHints(&ab, l, plen);
783: 	/* Erase to right */
784: 	snprintf(seq, 64, "\x1b[0K");
785: 	abAppend(&ab, seq, strlen(seq));
786: 	/* Move cursor to original position. */
787: 	snprintf(seq, 64, "\r\x1b[%dC", (int)(render_pos + plen));
788: 	abAppend(&ab, seq, strlen(seq));
789: 	if (write(fd, ab.b, ab.len) == -1) {
790: 	} /* Can't recover from write error. */
791: 	abFree(&ab);
792: }
793: 
794: /* Multi line low level line refresh.
795:  *
796:  * Rewrite the currently edited line accordingly to the buffer content,
797:  * cursor position, and number of columns of the terminal. */
798: static void refreshMultiLine(struct linenoiseState *l) {
799: 	char seq[64];
800: 	int plen = strlen(l->prompt);
801: 	int rows = (plen + l->len + l->cols - 1) / l->cols; /* rows used by current buf. */
802: 	int rpos = (plen + l->oldpos + l->cols) / l->cols;  /* cursor relative row. */
803: 	int rpos2;                                          /* rpos after refresh. */
804: 	int col;                                            /* colum position, zero-based. */
805: 	int old_rows = l->maxrows;
806: 	int fd = l->ofd, j;
807: 	struct abuf ab;
808: 
809: 	/* Update maxrows if needed. */
810: 	if (rows > (int)l->maxrows)
811: 		l->maxrows = rows;
812: 
813: 	/* First step: clear all the lines used before. To do so start by
814: 	 * going to the last row. */
815: 	abInit(&ab);
816: 	if (old_rows - rpos > 0) {
817: 		lndebug("go down %d", old_rows - rpos);
818: 		snprintf(seq, 64, "\x1b[%dB", old_rows - rpos);
819: 		abAppend(&ab, seq, strlen(seq));
820: 	}
821: 
822: 	/* Now for every row clear it, go up. */
823: 	for (j = 0; j < old_rows - 1; j++) {
824: 		lndebug("clear+up");
825: 		snprintf(seq, 64, "\r\x1b[0K\x1b[1A");
826: 		abAppend(&ab, seq, strlen(seq));
827: 	}
828: 
829: 	/* Clean the top line. */
830: 	lndebug("clear");
831: 	snprintf(seq, 64, "\r\x1b[0K");
832: 	abAppend(&ab, seq, strlen(seq));
833: 
834: 	/* Write the prompt and the current buffer content */
835: 	abAppend(&ab, l->prompt, strlen(l->prompt));
836: 	abAppend(&ab, l->buf, l->len);
837: 
838: 	/* Show hits if any. */
839: 	refreshShowHints(&ab, l, plen);
840: 
841: 	/* If we are at the very end of the screen with our prompt, we need to
842: 	 * emit a newline and move the prompt to the first column. */
843: 	if (l->pos && l->pos == l->len && (l->pos + plen) % l->cols == 0) {
844: 		lndebug("<newline>");
845: 		abAppend(&ab, "\n", 1);
846: 		snprintf(seq, 64, "\r");
847: 		abAppend(&ab, seq, strlen(seq));
848: 		rows++;
849: 		if (rows > (int)l->maxrows)
850: 			l->maxrows = rows;
851: 	}
852: 
853: 	/* Move cursor to right position. */
854: 	rpos2 = (plen + l->pos + l->cols) / l->cols; /* current cursor relative row. */
855: 	lndebug("rpos2 %d", rpos2);
856: 
857: 	/* Go up till we reach the expected positon. */
858: 	if (rows - rpos2 > 0) {
859: 		lndebug("go-up %d", rows - rpos2);
860: 		snprintf(seq, 64, "\x1b[%dA", rows - rpos2);
861: 		abAppend(&ab, seq, strlen(seq));
862: 	}
863: 
864: 	/* Set column. */
865: 	col = (plen + (int)l->pos) % (int)l->cols;
866: 	lndebug("set col %d", 1 + col);
867: 	if (col)
868: 		snprintf(seq, 64, "\r\x1b[%dC", col);
869: 	else
870: 		snprintf(seq, 64, "\r");
871: 	abAppend(&ab, seq, strlen(seq));
872: 
873: 	lndebug("\n");
874: 	l->oldpos = l->pos;
875: 
876: 	if (write(fd, ab.b, ab.len) == -1) {
877: 	} /* Can't recover from write error. */
878: 	abFree(&ab);
879: }
880: 
881: /* Calls the two low level functions refreshSingleLine() or
882:  * refreshMultiLine() according to the selected mode. */
883: static void refreshLine(struct linenoiseState *l) {
884: 	if (mlmode)
885: 		refreshMultiLine(l);
886: 	else
887: 		refreshSingleLine(l);
888: }
889: 
890: /* Insert the character 'c' at cursor current position.
891:  *
892:  * On error writing to the terminal -1 is returned, otherwise 0. */
893: int linenoiseEditInsert(struct linenoiseState *l, char c) {
894: 	if (l->len < l->buflen) {
895: 		if (l->len == l->pos) {
896: 			l->buf[l->pos] = c;
897: 			l->pos++;
898: 			l->len++;
899: 			l->buf[l->len] = '\0';
900: 			if ((!mlmode && l->plen + l->len < l->cols && !hintsCallback)) {
901: 				/* Avoid a full update of the line in the
902: 				 * trivial case. */
903: 				if (write(l->ofd, &c, 1) == -1)
904: 					return -1;
905: 			} else {
906: 				refreshLine(l);
907: 			}
908: 		} else {
909: 			memmove(l->buf + l->pos + 1, l->buf + l->pos, l->len - l->pos);
910: 			l->buf[l->pos] = c;
911: 			l->len++;
912: 			l->pos++;
913: 			l->buf[l->len] = '\0';
914: 			refreshLine(l);
915: 		}
916: 	}
917: 	refreshLine(l);
918: 	return 0;
919: }
920: 
921: static size_t prev_char(struct linenoiseState *l) {
922: 	return utf8proc_prev_grapheme_cluster(l->buf, l->len, l->pos);
923: }
924: 
925: static size_t next_char(struct linenoiseState *l) {
926: 	return utf8proc_next_grapheme_cluster(l->buf, l->len, l->pos);
927: }
928: 
929: /* Move cursor on the left. */
930: void linenoiseEditMoveLeft(struct linenoiseState *l) {
931: 	if (l->pos > 0) {
932: 		l->pos = prev_char(l);
933: 		refreshLine(l);
934: 	}
935: }
936: 
937: /* Move cursor on the right. */
938: void linenoiseEditMoveRight(struct linenoiseState *l) {
939: 	if (l->pos != l->len) {
940: 		l->pos = next_char(l);
941: 		refreshLine(l);
942: 	}
943: }
944: 
945: /* Move cursor to the start of the line. */
946: void linenoiseEditMoveHome(struct linenoiseState *l) {
947: 	if (l->pos != 0) {
948: 		l->pos = 0;
949: 		refreshLine(l);
950: 	}
951: }
952: 
953: /* Move cursor to the end of the line. */
954: void linenoiseEditMoveEnd(struct linenoiseState *l) {
955: 	if (l->pos != l->len) {
956: 		l->pos = l->len;
957: 		refreshLine(l);
958: 	}
959: }
960: 
961: /* Substitute the currently edited line with the next or previous history
962:  * entry as specified by 'dir'. */
963: #define LINENOISE_HISTORY_NEXT 0
964: #define LINENOISE_HISTORY_PREV 1
965: void linenoiseEditHistoryNext(struct linenoiseState *l, int dir) {
966: 	if (history_len > 1) {
967: 		/* Update the current history entry before to
968: 		 * overwrite it with the next one. */
969: 		free(history[history_len - 1 - l->history_index]);
970: 		history[history_len - 1 - l->history_index] = strdup(l->buf);
971: 		/* Show the new entry */
972: 		l->history_index += (dir == LINENOISE_HISTORY_PREV) ? 1 : -1;
973: 		if (l->history_index < 0) {
974: 			l->history_index = 0;
975: 			return;
976: 		} else if (l->history_index >= history_len) {
977: 			l->history_index = history_len - 1;
978: 			return;
979: 		}
980: 		strncpy(l->buf, history[history_len - 1 - l->history_index], l->buflen);
981: 		l->buf[l->buflen - 1] = '\0';
982: 		l->len = l->pos = strlen(l->buf);
983: 		refreshLine(l);
984: 	}
985: }
986: 
987: /* Delete the character at the right of the cursor without altering the cursor
988:  * position. Basically this is what happens with the "Delete" keyboard key. */
989: void linenoiseEditDelete(struct linenoiseState *l) {
990: 	if (l->len > 0 && l->pos < l->len) {
991: 		size_t new_pos = next_char(l);
992: 		size_t char_sz = new_pos - l->pos;
993: 		memmove(l->buf + l->pos, l->buf + new_pos, l->len - new_pos);
994: 		l->len -= char_sz;
995: 		l->buf[l->len] = '\0';
996: 		refreshLine(l);
997: 	}
998: }
999: 
1000: /* Backspace implementation. */
1001: void linenoiseEditBackspace(struct linenoiseState *l) {
1002: 	if (l->pos > 0 && l->len > 0) {
1003: 		size_t new_pos = prev_char(l);
1004: 		size_t char_sz = l->pos - new_pos;
1005: 		memmove(l->buf + new_pos, l->buf + l->pos, l->len - l->pos);
1006: 		l->len -= char_sz;
1007: 		l->pos = new_pos;
1008: 		l->buf[l->len] = '\0';
1009: 		refreshLine(l);
1010: 	}
1011: }
1012: 
1013: /* Delete the previosu word, maintaining the cursor at the start of the
1014:  * current word. */
1015: void linenoiseEditDeletePrevWord(struct linenoiseState *l) {
1016: 	size_t old_pos = l->pos;
1017: 	size_t diff;
1018: 
1019: 	while (l->pos > 0 && l->buf[l->pos - 1] == ' ')
1020: 		l->pos--;
1021: 	while (l->pos > 0 && l->buf[l->pos - 1] != ' ')
1022: 		l->pos--;
1023: 	diff = old_pos - l->pos;
1024: 	memmove(l->buf + l->pos, l->buf + old_pos, l->len - old_pos + 1);
1025: 	l->len -= diff;
1026: 	refreshLine(l);
1027: }
1028: 
1029: /* This function is the core of the line editing capability of linenoise.
1030:  * It expects 'fd' to be already in "raw mode" so that every key pressed
1031:  * will be returned ASAP to read().
1032:  *
1033:  * The resulting string is put into 'buf' when the user type enter, or
1034:  * when ctrl+d is typed.
1035:  *
1036:  * The function returns the length of the current buffer. */
1037: static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen, const char *prompt) {
1038: 	struct linenoiseState l;
1039: 
1040: 	/* Populate the linenoise state that we pass to functions implementing
1041: 	 * specific editing functionalities. */
1042: 	l.ifd = stdin_fd;
1043: 	l.ofd = stdout_fd;
1044: 	l.buf = buf;
1045: 	l.buflen = buflen;
1046: 	l.prompt = prompt;
1047: 	l.plen = strlen(prompt);
1048: 	l.oldpos = l.pos = 0;
1049: 	l.len = 0;
1050: 	l.cols = getColumns(stdin_fd, stdout_fd);
1051: 	l.maxrows = 0;
1052: 	l.history_index = 0;
1053: 
1054: 	/* Buffer starts empty. */
1055: 	l.buf[0] = '\0';
1056: 	l.buflen--; /* Make sure there is always space for the nulterm */
1057: 
1058: 	/* The latest history entry is always our current buffer, that
1059: 	 * initially is just an empty string. */
1060: 	linenoiseHistoryAdd("");
1061: 
1062: 	if (write(l.ofd, prompt, l.plen) == -1)
1063: 		return -1;
1064: 	while (1) {
1065: 		char c;
1066: 		int nread;
1067: 		char seq[3];
1068: 
1069: 		nread = read(l.ifd, &c, 1);
1070: 		if (nread <= 0)
1071: 			return l.len;
1072: 
1073: 		/* Only autocomplete when the callback is set. It returns < 0 when
1074: 		 * there was an error reading from fd. Otherwise it will return the
1075: 		 * character that should be handled next. */
1076: 		if (c == 9 && completionCallback != NULL) {
1077: 			c = completeLine(&l);
1078: 			/* Return on errors */
1079: 			if (c < 0)
1080: 				return l.len;
1081: 			/* Read next character when 0 */
1082: 			if (c == 0)
1083: 				continue;
1084: 		}
1085: 
1086: 		switch (c) {
1087: 		case 10:
1088: 		case ENTER: /* enter */
1089: 			history_len--;
1090: 			free(history[history_len]);
1091: 			if (mlmode)
1092: 				linenoiseEditMoveEnd(&l);
1093: 			if (hintsCallback) {
1094: 				/* Force a refresh without hints to leave the previous
1095: 				 * line as the user typed it after a newline. */
1096: 				linenoiseHintsCallback *hc = hintsCallback;
1097: 				hintsCallback = NULL;
1098: 				refreshLine(&l);
1099: 				hintsCallback = hc;
1100: 			}
1101: 			return (int)l.len;
1102: 		case CTRL_C: /* ctrl-c */
1103: 			errno = EAGAIN;
1104: 			return -1;
1105: 		case BACKSPACE: /* backspace */
1106: 		case 8:         /* ctrl-h */
1107: 			linenoiseEditBackspace(&l);
1108: 			break;
1109: 		case CTRL_D: /* ctrl-d, remove char at right of cursor, or if the
1110: 		                line is empty, act as end-of-file. */
1111: 			if (l.len > 0) {
1112: 				linenoiseEditDelete(&l);
1113: 			} else {
1114: 				history_len--;
1115: 				free(history[history_len]);
1116: 				return -1;
1117: 			}
1118: 			break;
1119: 		case CTRL_T: /* ctrl-t, swaps current character with previous. */
1120: 			if (l.pos > 0 && l.pos < l.len) {
1121: 				char temp_buffer[128];
1122: 				int prev_pos = prev_char(&l);
1123: 				int next_pos = next_char(&l);
1124: 				int prev_char_size = l.pos - prev_pos;
1125: 				int cur_char_size = next_pos - l.pos;
1126: 				memcpy(temp_buffer, l.buf + prev_pos, prev_char_size);
1127: 				memmove(l.buf + prev_pos, l.buf + l.pos, cur_char_size);
1128: 				memcpy(l.buf + prev_pos + cur_char_size, temp_buffer, prev_char_size);
1129: 				l.pos = next_pos;
1130: 				refreshLine(&l);
1131: 			}
1132: 			break;
1133: 		case CTRL_B: /* ctrl-b */
1134: 			linenoiseEditMoveLeft(&l);
1135: 			break;
1136: 		case CTRL_F: /* ctrl-f */
1137: 			linenoiseEditMoveRight(&l);
1138: 			break;
1139: 		case CTRL_P: /* ctrl-p */
1140: 			linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
1141: 			break;
1142: 		case CTRL_N: /* ctrl-n */
1143: 			linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
1144: 			break;
1145: 		case ESC: /* escape sequence */
1146: 			/* Read the next two bytes representing the escape sequence.
1147: 			 * Use two calls to handle slow terminals returning the two
1148: 			 * chars at different times. */
1149: 			if (read(l.ifd, seq, 1) == -1)
1150: 				break;
1151: 			if (read(l.ifd, seq + 1, 1) == -1)
1152: 				break;
1153: 
1154: 			/* ESC [ sequences. */
1155: 			if (seq[0] == '[') {
1156: 				if (seq[1] >= '0' && seq[1] <= '9') {
1157: 					/* Extended escape, read additional byte. */
1158: 					if (read(l.ifd, seq + 2, 1) == -1)
1159: 						break;
1160: 					if (seq[2] == '~') {
1161: 						switch (seq[1]) {
1162: 						case '3': /* Delete key. */
1163: 							linenoiseEditDelete(&l);
1164: 							break;
1165: 						}
1166: 					}
1167: 				} else {
1168: 					switch (seq[1]) {
1169: 					case 'A': /* Up */
1170: 						linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
1171: 						break;
1172: 					case 'B': /* Down */
1173: 						linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
1174: 						break;
1175: 					case 'C': /* Right */
1176: 						linenoiseEditMoveRight(&l);
1177: 						break;
1178: 					case 'D': /* Left */
1179: 						linenoiseEditMoveLeft(&l);
1180: 						break;
1181: 					case 'H': /* Home */
1182: 						linenoiseEditMoveHome(&l);
1183: 						break;
1184: 					case 'F': /* End*/
1185: 						linenoiseEditMoveEnd(&l);
1186: 						break;
1187: 					}
1188: 				}
1189: 			}
1190: 
1191: 			/* ESC O sequences. */
1192: 			else if (seq[0] == 'O') {
1193: 				switch (seq[1]) {
1194: 				case 'H': /* Home */
1195: 					linenoiseEditMoveHome(&l);
1196: 					break;
1197: 				case 'F': /* End*/
1198: 					linenoiseEditMoveEnd(&l);
1199: 					break;
1200: 				}
1201: 			}
1202: 			break;
1203: 		case CTRL_U: /* Ctrl+u, delete the whole line. */
1204: 			buf[0] = '\0';
1205: 			l.pos = l.len = 0;
1206: 			refreshLine(&l);
1207: 			break;
1208: 		case CTRL_K: /* Ctrl+k, delete from current to end of line. */
1209: 			buf[l.pos] = '\0';
1210: 			l.len = l.pos;
1211: 			refreshLine(&l);
1212: 			break;
1213: 		case CTRL_A: /* Ctrl+a, go to the start of the line */
1214: 			linenoiseEditMoveHome(&l);
1215: 			break;
1216: 		case CTRL_E: /* ctrl+e, go to the end of the line */
1217: 			linenoiseEditMoveEnd(&l);
1218: 			break;
1219: 		case CTRL_L: /* ctrl+l, clear screen */
1220: 			linenoiseClearScreen();
1221: 			refreshLine(&l);
1222: 			break;
1223: 		case CTRL_W: /* ctrl+w, delete previous word */
1224: 			linenoiseEditDeletePrevWord(&l);
1225: 			break;
1226: 		default:
1227: 			if (linenoiseEditInsert(&l, c))
1228: 				return -1;
1229: 			break;
1230: 		}
1231: 	}
1232: 	return l.len;
1233: }
1234: 
1235: /* This special mode is used by linenoise in order to print scan codes
1236:  * on screen for debugging / development purposes. It is implemented
1237:  * by the linenoise_example program using the --keycodes option. */
1238: void linenoisePrintKeyCodes(void) {
1239: 	char quit[4];
1240: 
1241: 	printf("Linenoise key codes debugging mode.\n"
1242: 	       "Press keys to see scan codes. Type 'quit' at any time to exit.\n");
1243: 	if (enableRawMode(STDIN_FILENO) == -1)
1244: 		return;
1245: 	memset(quit, ' ', 4);
1246: 	while (1) {
1247: 		char c;
1248: 		int nread;
1249: 
1250: 		nread = read(STDIN_FILENO, &c, 1);
1251: 		if (nread <= 0)
1252: 			continue;
1253: 		memmove(quit, quit + 1, sizeof(quit) - 1); /* shift string to left. */
1254: 		quit[sizeof(quit) - 1] = c;                /* Insert current char on the right. */
1255: 		if (memcmp(quit, "quit", sizeof(quit)) == 0)
1256: 			break;
1257: 
1258: 		printf("'%c' %02x (%d) (type quit to exit)\n", isprint(c) ? c : '?', (int)c, (int)c);
1259: 		printf("\r"); /* Go left edge manually, we are in raw mode. */
1260: 		fflush(stdout);
1261: 	}
1262: 	disableRawMode(STDIN_FILENO);
1263: }
1264: 
1265: /* This function calls the line editing function linenoiseEdit() using
1266:  * the STDIN file descriptor set in raw mode. */
1267: static int linenoiseRaw(char *buf, size_t buflen, const char *prompt) {
1268: 	int count;
1269: 
1270: 	if (buflen == 0) {
1271: 		errno = EINVAL;
1272: 		return -1;
1273: 	}
1274: 
1275: 	if (enableRawMode(STDIN_FILENO) == -1)
1276: 		return -1;
1277: 	count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, buflen, prompt);
1278: 	disableRawMode(STDIN_FILENO);
1279: 	printf("\n");
1280: 	return count;
1281: }
1282: 
1283: /* This function is called when linenoise() is called with the standard
1284:  * input file descriptor not attached to a TTY. So for example when the
1285:  * program using linenoise is called in pipe or with a file redirected
1286:  * to its standard input. In this case, we want to be able to return the
1287:  * line regardless of its length (by default we are limited to 4k). */
1288: static char *linenoiseNoTTY(void) {
1289: 	char *line = NULL;
1290: 	size_t len = 0, maxlen = 0;
1291: 
1292: 	while (1) {
1293: 		if (len == maxlen) {
1294: 			if (maxlen == 0)
1295: 				maxlen = 16;
1296: 			maxlen *= 2;
1297: 			char *oldval = line;
1298: 			line = (char*) realloc(line, maxlen);
1299: 			if (line == NULL) {
1300: 				if (oldval)
1301: 					free(oldval);
1302: 				return NULL;
1303: 			}
1304: 		}
1305: 		int c = fgetc(stdin);
1306: 		if (c == EOF || c == '\n') {
1307: 			if (c == EOF && len == 0) {
1308: 				free(line);
1309: 				return NULL;
1310: 			} else {
1311: 				line[len] = '\0';
1312: 				return line;
1313: 			}
1314: 		} else {
1315: 			line[len] = c;
1316: 			len++;
1317: 		}
1318: 	}
1319: }
1320: 
1321: /* The high level function that is the main API of the linenoise library.
1322:  * This function checks if the terminal has basic capabilities, just checking
1323:  * for a blacklist of stupid terminals, and later either calls the line
1324:  * editing function or uses dummy fgets() so that you will be able to type
1325:  * something even in the most desperate of the conditions. */
1326: char *linenoise(const char *prompt) {
1327: 	char buf[LINENOISE_MAX_LINE];
1328: 	int count;
1329: 
1330: 
1331: 	if (!isatty(STDIN_FILENO)) {
1332: 		/* Not a tty: read from file / pipe. In this mode we don't want any
1333: 		 * limit to the line size, so we call a function to handle that. */
1334: 		return linenoiseNoTTY();
1335: 	} else if (isUnsupportedTerm()) {
1336: 		size_t len;
1337: 
1338: 		printf("%s", prompt);
1339: 		fflush(stdout);
1340: 		if (fgets(buf, LINENOISE_MAX_LINE, stdin) == NULL)
1341: 			return NULL;
1342: 		len = strlen(buf);
1343: 		while (len && (buf[len - 1] == '\n' || buf[len - 1] == '\r')) {
1344: 			len--;
1345: 			buf[len] = '\0';
1346: 		}
1347: 		return strdup(buf);
1348: 	} else {
1349: 		count = linenoiseRaw(buf, LINENOISE_MAX_LINE, prompt);
1350: 		if (count == -1)
1351: 			return NULL;
1352: 		return strdup(buf);
1353: 	}
1354: }
1355: 
1356: /* This is just a wrapper the user may want to call in order to make sure
1357:  * the linenoise returned buffer is freed with the same allocator it was
1358:  * created with. Useful when the main program is using an alternative
1359:  * allocator. */
1360: void linenoiseFree(void *ptr) {
1361: 	free(ptr);
1362: }
1363: 
1364: /* ================================ History ================================= */
1365: 
1366: /* Free the history, but does not reset it. Only used when we have to
1367:  * exit() to avoid memory leaks are reported by valgrind & co. */
1368: static void freeHistory(void) {
1369: 	if (history) {
1370: 		int j;
1371: 
1372: 		for (j = 0; j < history_len; j++)
1373: 			free(history[j]);
1374: 		free(history);
1375: 	}
1376: }
1377: 
1378: /* At exit we'll try to fix the terminal to the initial conditions. */
1379: static void linenoiseAtExit(void) {
1380: 	disableRawMode(STDIN_FILENO);
1381: 	freeHistory();
1382: }
1383: 
1384: /* This is the API call to add a new entry in the linenoise history.
1385:  * It uses a fixed array of char pointers that are shifted (memmoved)
1386:  * when the history max length is reached in order to remove the older
1387:  * entry and make room for the new one, so it is not exactly suitable for huge
1388:  * histories, but will work well for a few hundred of entries.
1389:  *
1390:  * Using a circular buffer is smarter, but a bit more complex to handle. */
1391: int linenoiseHistoryAdd(const char *line) {
1392: 	char *linecopy;
1393: 
1394: 	if (history_max_len == 0)
1395: 		return 0;
1396: 
1397: 	/* Initialization on first call. */
1398: 	if (history == NULL) {
1399: 		history = (char**) malloc(sizeof(char *) * history_max_len);
1400: 		if (history == NULL)
1401: 			return 0;
1402: 		memset(history, 0, (sizeof(char *) * history_max_len));
1403: 	}
1404: 
1405: 	/* Don't add duplicated lines. */
1406: 	if (history_len && !strcmp(history[history_len - 1], line))
1407: 		return 0;
1408: 
1409: 	/* Add an heap allocated copy of the line in the history.
1410: 	 * If we reached the max length, remove the older line. */
1411: 	linecopy = strdup(line);
1412: 	if (!linecopy)
1413: 		return 0;
1414: 	if (history_len == history_max_len) {
1415: 		free(history[0]);
1416: 		memmove(history, history + 1, sizeof(char *) * (history_max_len - 1));
1417: 		history_len--;
1418: 	}
1419: 	history[history_len] = linecopy;
1420: 	history_len++;
1421: 	return 1;
1422: }
1423: 
1424: /* Set the maximum length for the history. This function can be called even
1425:  * if there is already some history, the function will make sure to retain
1426:  * just the latest 'len' elements if the new history length value is smaller
1427:  * than the amount of items already inside the history. */
1428: int linenoiseHistorySetMaxLen(int len) {
1429: 	char **new_entry;
1430: 
1431: 	if (len < 1)
1432: 		return 0;
1433: 	if (history) {
1434: 		int tocopy = history_len;
1435: 
1436: 		new_entry = (char**) malloc(sizeof(char *) * len);
1437: 		if (new_entry == NULL)
1438: 			return 0;
1439: 
1440: 		/* If we can't copy everything, free the elements we'll not use. */
1441: 		if (len < tocopy) {
1442: 			int j;
1443: 
1444: 			for (j = 0; j < tocopy - len; j++)
1445: 				free(history[j]);
1446: 			tocopy = len;
1447: 		}
1448: 		memset(new_entry, 0, sizeof(char *) * len);
1449: 		memcpy(new_entry, history + (history_len - tocopy), sizeof(char *) * tocopy);
1450: 		free(history);
1451: 		history = new_entry;
1452: 	}
1453: 	history_max_len = len;
1454: 	if (history_len > history_max_len)
1455: 		history_len = history_max_len;
1456: 	return 1;
1457: }
1458: 
1459: /* Save the history in the specified file. On success 0 is returned
1460:  * otherwise -1 is returned. */
1461: int linenoiseHistorySave(const char *filename) {
1462: 	mode_t old_umask = umask(S_IXUSR | S_IRWXG | S_IRWXO);
1463: 	FILE *fp;
1464: 	int j;
1465: 
1466: 	fp = fopen(filename, "w");
1467: 	umask(old_umask);
1468: 	if (fp == NULL)
1469: 		return -1;
1470: 	chmod(filename, S_IRUSR | S_IWUSR);
1471: 	for (j = 0; j < history_len; j++)
1472: 		fprintf(fp, "%s\n", history[j]);
1473: 	fclose(fp);
1474: 	return 0;
1475: }
1476: 
1477: /* Load the history from the specified file. If the file does not exist
1478:  * zero is returned and no operation is performed.
1479:  *
1480:  * If the file exists and the operation succeeded 0 is returned, otherwise
1481:  * on error -1 is returned. */
1482: int linenoiseHistoryLoad(const char *filename) {
1483: 	FILE *fp = fopen(filename, "r");
1484: 	char buf[LINENOISE_MAX_LINE];
1485: 
1486: 	if (fp == NULL)
1487: 		return -1;
1488: 
1489: 	while (fgets(buf, LINENOISE_MAX_LINE, fp) != NULL) {
1490: 		char *p;
1491: 
1492: 		p = strchr(buf, '\r');
1493: 		if (!p)
1494: 			p = strchr(buf, '\n');
1495: 		if (p)
1496: 			*p = '\0';
1497: 		linenoiseHistoryAdd(buf);
1498: 	}
1499: 	fclose(fp);
1500: 	return 0;
1501: }
[end of tools/shell/linenoise.cpp]
[start of tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp]
1: #include "sqlite3.h"
2: 
3: #include "duckdb.hpp"
4: #include "duckdb/parser/parser.hpp"
5: #include "duckdb/planner/pragma_handler.hpp"
6: 
7: #include <ctype.h>
8: #include <stdio.h>
9: #include <stdlib.h>
10: #include <string.h>
11: #include <time.h>
12: #include <string>
13: #include <chrono>
14: #include <cassert>
15: 
16: #include "extension_helper.hpp"
17: 
18: using namespace duckdb;
19: using namespace std;
20: 
21: static char *sqlite3_strdup(const char *str);
22: 
23: struct sqlite3_string_buffer {
24: 	//! String data
25: 	unique_ptr<char[]> data;
26: };
27: 
28: struct sqlite3_stmt {
29: 	//! The DB object that this statement belongs to
30: 	sqlite3 *db;
31: 	//! The query string
32: 	string query_string;
33: 	//! The prepared statement object, if successfully prepared
34: 	unique_ptr<PreparedStatement> prepared;
35: 	//! The result object, if successfully executed
36: 	unique_ptr<QueryResult> result;
37: 	//! The current chunk that we are iterating over
38: 	unique_ptr<DataChunk> current_chunk;
39: 	//! The current row into the current chunk that we are iterating over
40: 	int64_t current_row;
41: 	//! Bound values, used for binding to the prepared statement
42: 	vector<Value> bound_values;
43: 	//! Names of the prepared parameters
44: 	vector<string> bound_names;
45: 	//! The current column values converted to string, used and filled by sqlite3_column_text
46: 	unique_ptr<sqlite3_string_buffer[]> current_text;
47: };
48: 
49: struct sqlite3 {
50: 	unique_ptr<DuckDB> db;
51: 	unique_ptr<Connection> con;
52: 	string last_error;
53: };
54: 
55: void sqlite3_randomness(int N, void *pBuf) {
56: 	static bool init = false;
57: 	if (!init) {
58: 		srand(time(NULL));
59: 		init = true;
60: 	}
61: 	unsigned char *zBuf = (unsigned char *)pBuf;
62: 	while (N--) {
63: 		unsigned char nextByte = rand() % 255;
64: 		zBuf[N] = nextByte;
65: 	}
66: }
67: 
68: int sqlite3_open(const char *filename, /* Database filename (UTF-8) */
69:                  sqlite3 **ppDb        /* OUT: SQLite db handle */
70: ) {
71: 	return sqlite3_open_v2(filename, ppDb, 0, NULL);
72: }
73: 
74: int sqlite3_open_v2(const char *filename, /* Database filename (UTF-8) */
75:                     sqlite3 **ppDb,       /* OUT: SQLite db handle */
76:                     int flags,            /* Flags */
77:                     const char *zVfs      /* Name of VFS module to use */
78: ) {
79: 	if (filename && strcmp(filename, ":memory:") == 0) {
80: 		filename = NULL;
81: 	}
82: 	*ppDb = nullptr;
83: 	if (zVfs) { /* unsupported so if set we complain */
84: 		return SQLITE_ERROR;
85: 	}
86: 	sqlite3 *pDb = nullptr;
87: 	try {
88: 		pDb = new sqlite3();
89: 		DBConfig config;
90: 		config.access_mode = AccessMode::AUTOMATIC;
91: 		if (flags & SQLITE_OPEN_READONLY) {
92: 			config.access_mode = AccessMode::READ_ONLY;
93: 		}
94: 		pDb->db = make_unique<DuckDB>(filename, &config);
95: 		pDb->con = make_unique<Connection>(*pDb->db);
96: 
97: 		ExtensionHelper::LoadAllExtensions(*pDb->db);
98: 	} catch (std::exception &ex) {
99: 		if (pDb) {
100: 			pDb->last_error = ex.what();
101: 		}
102: 		return SQLITE_ERROR;
103: 	}
104: 	*ppDb = pDb;
105: 	return SQLITE_OK;
106: }
107: 
108: int sqlite3_close(sqlite3 *db) {
109: 	if (db) {
110: 		delete db;
111: 	}
112: 	return SQLITE_OK;
113: }
114: 
115: int sqlite3_shutdown(void) {
116: 	return SQLITE_OK;
117: }
118: 
119: /* In SQLite this function compiles the query into VDBE bytecode,
120:  * in the implementation it currently executes the query */
121: // TODO: prepare the statement instead of executing right away
122: int sqlite3_prepare_v2(sqlite3 *db,           /* Database handle */
123:                        const char *zSql,      /* SQL statement, UTF-8 encoded */
124:                        int nByte,             /* Maximum length of zSql in bytes. */
125:                        sqlite3_stmt **ppStmt, /* OUT: Statement handle */
126:                        const char **pzTail    /* OUT: Pointer to unused portion of zSql */
127: ) {
128: 	if (!db || !ppStmt || !zSql) {
129: 		return SQLITE_MISUSE;
130: 	}
131: 	*ppStmt = nullptr;
132: 	string query = nByte < 0 ? zSql : string(zSql, nByte);
133: 	if (pzTail) {
134: 		*pzTail = zSql + query.size();
135: 	}
136: 	try {
137: 		Parser parser;
138: 		parser.ParseQuery(query);
139: 		if (parser.statements.size() == 0) {
140: 			return SQLITE_OK;
141: 		}
142: 		// extract the remainder
143: 		idx_t next_location = parser.statements[0]->stmt_location + parser.statements[0]->stmt_length;
144: 		bool set_remainder = next_location < query.size();
145: 
146: 		// extract the first statement
147: 		vector<unique_ptr<SQLStatement>> statements;
148: 		statements.push_back(move(parser.statements[0]));
149: 
150: 		PragmaHandler handler(*db->con->context);
151: 		handler.HandlePragmaStatements(statements);
152: 
153: 		// if there are multiple statements here, we are dealing with an import database statement
154: 		// we directly execute all statements besides the final one
155: 		for(idx_t i = 0; i + 1 < statements.size(); i++) {
156: 			auto res = db->con->Query(move(statements[i]));
157: 			if (!res->success) {
158: 				db->last_error = res->error;
159: 				return SQLITE_ERROR;
160: 			}
161: 		}
162: 
163: 		// now prepare the query
164: 		auto prepared = db->con->Prepare(move(statements.back()));
165: 		if (!prepared->success) {
166: 			// failed to prepare: set the error message
167: 			db->last_error = prepared->error;
168: 			return SQLITE_ERROR;
169: 		}
170: 
171: 		// create the statement entry
172: 		unique_ptr<sqlite3_stmt> stmt = make_unique<sqlite3_stmt>();
173: 		stmt->db = db;
174: 		stmt->query_string = query;
175: 		stmt->prepared = move(prepared);
176: 		stmt->current_row = -1;
177: 		for (idx_t i = 0; i < stmt->prepared->n_param; i++) {
178: 			stmt->bound_names.push_back("$" + to_string(i + 1));
179: 			stmt->bound_values.push_back(Value());
180: 		}
181: 
182: 		// extract the remainder of the query and assign it to the pzTail
183: 		if (pzTail && set_remainder) {
184: 			*pzTail = zSql + next_location + 1;
185: 		}
186: 
187: 		*ppStmt = stmt.release();
188: 		return SQLITE_OK;
189: 	} catch (std::exception &ex) {
190: 		db->last_error = ex.what();
191: 		return SQLITE_ERROR;
192: 	}
193: }
194: 
195: bool sqlite3_display_result(StatementType type) {
196: 	switch (type) {
197: 	case StatementType::EXECUTE_STATEMENT:
198: 	case StatementType::EXPLAIN_STATEMENT:
199: 	case StatementType::PRAGMA_STATEMENT:
200: 	case StatementType::SELECT_STATEMENT:
201: 		return true;
202: 	default:
203: 		return false;
204: 	}
205: }
206: 
207: /* Prepare the next result to be retrieved */
208: int sqlite3_step(sqlite3_stmt *pStmt) {
209: 	if (!pStmt) {
210: 		return SQLITE_MISUSE;
211: 	}
212: 	if (!pStmt->prepared) {
213: 		pStmt->db->last_error = "Attempting sqlite3_step() on a non-successfully prepared statement";
214: 		return SQLITE_ERROR;
215: 	}
216: 	pStmt->current_text = nullptr;
217: 	if (!pStmt->result) {
218: 		// no result yet! call Execute()
219: 		pStmt->result = pStmt->prepared->Execute(pStmt->bound_values);
220: 		if (!pStmt->result->success) {
221: 			// error in execute: clear prepared statement
222: 			pStmt->db->last_error = pStmt->result->error;
223: 			pStmt->prepared = nullptr;
224: 			return SQLITE_ERROR;
225: 		}
226: 		// fetch a chunk
227: 		pStmt->current_chunk = pStmt->result->Fetch();
228: 		pStmt->current_row = -1;
229: 		if (!sqlite3_display_result(pStmt->prepared->type)) {
230: 			// only SELECT statements return results
231: 			sqlite3_reset(pStmt);
232: 		}
233: 	}
234: 	if (!pStmt->current_chunk) {
235: 		return SQLITE_DONE;
236: 	}
237: 	pStmt->current_row++;
238: 	if (pStmt->current_row >= (int32_t)pStmt->current_chunk->size()) {
239: 		// have to fetch again!
240: 		pStmt->current_row = 0;
241: 		pStmt->current_chunk = pStmt->result->Fetch();
242: 		if (!pStmt->current_chunk || pStmt->current_chunk->size() == 0) {
243: 			sqlite3_reset(pStmt);
244: 			return SQLITE_DONE;
245: 		}
246: 	}
247: 	return SQLITE_ROW;
248: }
249: 
250: /* Execute multiple semicolon separated SQL statements
251:  * and execute the passed callback for each produced result,
252:  * largely copied from the original sqlite3 source */
253: int sqlite3_exec(sqlite3 *db,                /* The database on which the SQL executes */
254:                  const char *zSql,           /* The SQL to be executed */
255:                  sqlite3_callback xCallback, /* Invoke this callback routine */
256:                  void *pArg,                 /* First argument to xCallback() */
257:                  char **pzErrMsg             /* Write error messages here */
258: ) {
259: 	int rc = SQLITE_OK;            /* Return code */
260: 	const char *zLeftover;         /* Tail of unprocessed SQL */
261: 	sqlite3_stmt *pStmt = nullptr; /* The current SQL statement */
262: 	char **azCols = nullptr;       /* Names of result columns */
263: 	char **azVals = nullptr;       /* Result values */
264: 
265: 	if (zSql == nullptr) {
266: 		zSql = "";
267: 	}
268: 
269: 	while (rc == SQLITE_OK && zSql[0]) {
270: 		int nCol;
271: 
272: 		pStmt = nullptr;
273: 		rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
274: 		if (rc != SQLITE_OK) {
275: 			if (pzErrMsg) {
276: 				auto errmsg = sqlite3_errmsg(db);
277: 				*pzErrMsg = errmsg ? sqlite3_strdup(errmsg) : nullptr;
278: 			}
279: 			continue;
280: 		}
281: 		if (!pStmt) {
282: 			/* this happens for a comment or white-space */
283: 			zSql = zLeftover;
284: 			continue;
285: 		}
286: 
287: 		nCol = sqlite3_column_count(pStmt);
288: 		azCols = (char **)malloc(nCol * sizeof(const char *));
289: 		azVals = (char **)malloc(nCol * sizeof(const char *));
290: 		if (!azCols || !azVals) {
291: 			goto exec_out;
292: 		}
293: 		for (int i = 0; i < nCol; i++) {
294: 			azCols[i] = (char *)sqlite3_column_name(pStmt, i);
295: 		}
296: 
297: 		while (true) {
298: 			rc = sqlite3_step(pStmt);
299: 
300: 			/* Invoke the callback function if required */
301: 			if (xCallback && rc == SQLITE_ROW) {
302: 				for (int i = 0; i < nCol; i++) {
303: 					azVals[i] = (char *)sqlite3_column_text(pStmt, i);
304: 					if (!azVals[i] && sqlite3_column_type(pStmt, i) != SQLITE_NULL) {
305: 						fprintf(stderr, "sqlite3_exec: out of memory.\n");
306: 						goto exec_out;
307: 					}
308: 				}
309: 				if (xCallback(pArg, nCol, azVals, azCols)) {
310: 					/* EVIDENCE-OF: R-38229-40159 If the callback function to
311: 					** sqlite3_exec() returns non-zero, then sqlite3_exec() will
312: 					** return SQLITE_ABORT. */
313: 					rc = SQLITE_ABORT;
314: 					sqlite3_finalize(pStmt);
315: 					pStmt = 0;
316: 					fprintf(stderr, "sqlite3_exec: callback returned non-zero. "
317: 					                "Aborting.\n");
318: 					goto exec_out;
319: 				}
320: 			}
321: 			if (rc == SQLITE_DONE) {
322: 				rc = sqlite3_finalize(pStmt);
323: 				pStmt = nullptr;
324: 				zSql = zLeftover;
325: 				while (isspace(zSql[0]))
326: 					zSql++;
327: 				break;
328: 			} else if (rc != SQLITE_ROW) {
329: 				// error
330: 				if (pzErrMsg) {
331: 					auto errmsg = sqlite3_errmsg(db);
332: 					*pzErrMsg = errmsg ? sqlite3_strdup(errmsg) : nullptr;
333: 				}
334: 				goto exec_out;
335: 			}
336: 		}
337: 
338: 		sqlite3_free(azCols);
339: 		sqlite3_free(azVals);
340: 		azCols = nullptr;
341: 		azVals = nullptr;
342: 	}
343: 
344: exec_out:
345: 	if (pStmt) {
346: 		sqlite3_finalize(pStmt);
347: 	}
348: 	sqlite3_free(azCols);
349: 	sqlite3_free(azVals);
350: 	if (rc != SQLITE_OK && pzErrMsg && !*pzErrMsg) {
351: 		// error but no error message set
352: 		*pzErrMsg = sqlite3_strdup("Unknown error in DuckDB!");
353: 	}
354: 	return rc;
355: }
356: 
357: /* Return the text of the SQL that was used to prepare the statement */
358: const char *sqlite3_sql(sqlite3_stmt *pStmt) {
359: 	return pStmt->query_string.c_str();
360: }
361: 
362: int sqlite3_column_count(sqlite3_stmt *pStmt) {
363: 	if (!pStmt) {
364: 		return 0;
365: 	}
366: 	return (int)pStmt->prepared->types.size();
367: }
368: 
369: ////////////////////////////
370: //     sqlite3_column     //
371: ////////////////////////////
372: int sqlite3_column_type(sqlite3_stmt *pStmt, int iCol) {
373: 	if (!pStmt || !pStmt->result || !pStmt->current_chunk) {
374: 		return 0;
375: 	}
376: 	if (FlatVector::IsNull(pStmt->current_chunk->data[iCol], pStmt->current_row)) {
377: 		return SQLITE_NULL;
378: 	}
379: 	auto column_type = pStmt->result->types[iCol];
380: 	switch (column_type.id()) {
381: 	case LogicalTypeId::BOOLEAN:
382: 	case LogicalTypeId::TINYINT:
383: 	case LogicalTypeId::SMALLINT:
384: 	case LogicalTypeId::INTEGER:
385: 	case LogicalTypeId::BIGINT: /* TODO: Maybe blob? */
386: 		return SQLITE_INTEGER;
387: 	case LogicalTypeId::FLOAT:
388: 	case LogicalTypeId::DOUBLE:
389: 	case LogicalTypeId::DECIMAL:
390: 		return SQLITE_FLOAT;
391: 	case LogicalTypeId::DATE:
392: 	case LogicalTypeId::TIME:
393: 	case LogicalTypeId::TIMESTAMP:
394: 	case LogicalTypeId::VARCHAR:
395: 	case LogicalTypeId::LIST:
396: 	case LogicalTypeId::STRUCT:
397: 		return SQLITE_TEXT;
398: 	case LogicalTypeId::BLOB:
399: 		return SQLITE_BLOB;
400: 	default:
401: 		return 0;
402: 	}
403: 	return 0;
404: }
405: 
406: const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N) {
407: 	if (!pStmt) {
408: 		return nullptr;
409: 	}
410: 	return pStmt->prepared->names[N].c_str();
411: }
412: 
413: static bool sqlite3_column_has_value(sqlite3_stmt *pStmt, int iCol, LogicalType target_type, Value &val) {
414: 	if (!pStmt || !pStmt->result || !pStmt->current_chunk) {
415: 		return false;
416: 	}
417: 	if (iCol < 0 || iCol >= (int)pStmt->result->types.size()) {
418: 		return false;
419: 	}
420: 	if (FlatVector::IsNull(pStmt->current_chunk->data[iCol], pStmt->current_row)) {
421: 		return false;
422: 	}
423: 	try {
424: 		val = pStmt->current_chunk->data[iCol].GetValue(pStmt->current_row).CastAs(target_type);
425: 	} catch (...) {
426: 		return false;
427: 	}
428: 	return true;
429: }
430: 
431: double sqlite3_column_double(sqlite3_stmt *stmt, int iCol) {
432: 	Value val;
433: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::DOUBLE, val)) {
434: 		return 0;
435: 	}
436: 	return val.value_.double_;
437: }
438: 
439: int sqlite3_column_int(sqlite3_stmt *stmt, int iCol) {
440: 	Value val;
441: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::INTEGER, val)) {
442: 		return 0;
443: 	}
444: 	return val.value_.integer;
445: }
446: 
447: sqlite3_int64 sqlite3_column_int64(sqlite3_stmt *stmt, int iCol) {
448: 	Value val;
449: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::BIGINT, val)) {
450: 		return 0;
451: 	}
452: 	return val.value_.bigint;
453: }
454: 
455: const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int iCol) {
456: 	Value val;
457: 	if (!sqlite3_column_has_value(pStmt, iCol, LogicalType::VARCHAR, val)) {
458: 		return nullptr;
459: 	}
460: 	try {
461: 		if (!pStmt->current_text) {
462: 			pStmt->current_text =
463: 			    unique_ptr<sqlite3_string_buffer[]>(new sqlite3_string_buffer[pStmt->result->types.size()]);
464: 		}
465: 		auto &entry = pStmt->current_text[iCol];
466: 		if (!entry.data) {
467: 			// not initialized yet, convert the value and initialize it
468: 			entry.data = unique_ptr<char[]>(new char[val.str_value.size() + 1]);
469: 			memcpy(entry.data.get(), val.str_value.c_str(), val.str_value.size() + 1);
470: 		}
471: 		return (const unsigned char *)entry.data.get();
472: 	} catch (...) {
473: 		// memory error!
474: 		return nullptr;
475: 	}
476: }
477: 
478: ////////////////////////////
479: //      sqlite3_bind      //
480: ////////////////////////////
481: int sqlite3_bind_parameter_count(sqlite3_stmt *stmt) {
482: 	if (!stmt) {
483: 		return 0;
484: 	}
485: 	return stmt->prepared->n_param;
486: }
487: 
488: const char *sqlite3_bind_parameter_name(sqlite3_stmt *stmt, int idx) {
489: 	if (!stmt) {
490: 		return nullptr;
491: 	}
492: 	if (idx < 1 || idx > (int)stmt->prepared->n_param) {
493: 		return nullptr;
494: 	}
495: 	return stmt->bound_names[idx - 1].c_str();
496: }
497: 
498: int sqlite3_bind_parameter_index(sqlite3_stmt *stmt, const char *zName) {
499: 	if (!stmt || !zName) {
500: 		return 0;
501: 	}
502: 	for (idx_t i = 0; i < stmt->bound_names.size(); i++) {
503: 		if (stmt->bound_names[i] == string(zName)) {
504: 			return i + 1;
505: 		}
506: 	}
507: 	return 0;
508: }
509: 
510: int sqlite3_internal_bind_value(sqlite3_stmt *stmt, int idx, Value value) {
511: 	if (!stmt || !stmt->prepared || stmt->result) {
512: 		return SQLITE_MISUSE;
513: 	}
514: 	if (idx < 1 || idx > (int)stmt->prepared->n_param) {
515: 		return SQLITE_RANGE;
516: 	}
517: 	stmt->bound_values[idx - 1] = value;
518: 	return SQLITE_OK;
519: }
520: 
521: int sqlite3_bind_int(sqlite3_stmt *stmt, int idx, int val) {
522: 	return sqlite3_internal_bind_value(stmt, idx, Value::INTEGER(val));
523: }
524: 
525: int sqlite3_bind_int64(sqlite3_stmt *stmt, int idx, sqlite3_int64 val) {
526: 	return sqlite3_internal_bind_value(stmt, idx, Value::BIGINT(val));
527: }
528: 
529: int sqlite3_bind_double(sqlite3_stmt *stmt, int idx, double val) {
530: 	return sqlite3_internal_bind_value(stmt, idx, Value::DOUBLE(val));
531: }
532: 
533: int sqlite3_bind_null(sqlite3_stmt *stmt, int idx) {
534: 	return sqlite3_internal_bind_value(stmt, idx, Value());
535: }
536: 
537: SQLITE_API int sqlite3_bind_value(sqlite3_stmt *, int, const sqlite3_value *) {
538: 	fprintf(stderr, "sqlite3_bind_value: unsupported.\n");
539: 	return SQLITE_ERROR;
540: }
541: 
542: int sqlite3_bind_text(sqlite3_stmt *stmt, int idx, const char *val, int length, void (*free_func)(void *)) {
543: 	if (!val) {
544: 		return SQLITE_MISUSE;
545: 	}
546: 	string value;
547: 	if (length < 0) {
548: 		value = string(val);
549: 	} else {
550: 		value = string(val, val + length);
551: 	}
552: 	if (free_func && ((ptrdiff_t)free_func) != -1) {
553: 		free_func((void *)val);
554: 	}
555: 	return sqlite3_internal_bind_value(stmt, idx, Value(value));
556: }
557: 
558: int sqlite3_clear_bindings(sqlite3_stmt *stmt) {
559: 	if (!stmt) {
560: 		return SQLITE_MISUSE;
561: 	}
562: 	return SQLITE_OK;
563: }
564: 
565: int sqlite3_initialize(void) {
566: 	return SQLITE_OK;
567: }
568: 
569: int sqlite3_finalize(sqlite3_stmt *pStmt) {
570: 	if (pStmt) {
571: 		if (pStmt->result && !pStmt->result->success) {
572: 			pStmt->db->last_error = string(pStmt->result->error);
573: 			delete pStmt;
574: 			return SQLITE_ERROR;
575: 		}
576: 
577: 		delete pStmt;
578: 	}
579: 	return SQLITE_OK;
580: }
581: 
582: /*
583: ** Some systems have stricmp().  Others have strcasecmp().  Because
584: ** there is no consistency, we will define our own.
585: **
586: ** IMPLEMENTATION-OF: R-30243-02494 The sqlite3_stricmp() and
587: ** sqlite3_strnicmp() APIs allow applications and extensions to compare
588: ** the contents of two buffers containing UTF-8 strings in a
589: ** case-independent fashion, using the same definition of "case
590: ** independence" that SQLite uses internally when comparing identifiers.
591: */
592: 
593: const unsigned char sqlite3UpperToLower[] = {
594:     0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,
595:     22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,
596:     44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  97,
597:     98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
598:     120, 121, 122, 91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
599:     110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
600:     132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,
601:     154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
602:     176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,
603:     198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
604:     220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
605:     242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255};
606: 
607: int sqlite3StrICmp(const char *zLeft, const char *zRight) {
608: 	unsigned char *a, *b;
609: 	int c;
610: 	a = (unsigned char *)zLeft;
611: 	b = (unsigned char *)zRight;
612: 	for (;;) {
613: 		c = (int)sqlite3UpperToLower[*a] - (int)sqlite3UpperToLower[*b];
614: 		if (c || *a == 0)
615: 			break;
616: 		a++;
617: 		b++;
618: 	}
619: 	return c;
620: }
621: 
622: SQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight) {
623: 	if (zLeft == 0) {
624: 		return zRight ? -1 : 0;
625: 	} else if (zRight == 0) {
626: 		return 1;
627: 	}
628: 	return sqlite3StrICmp(zLeft, zRight);
629: }
630: 
631: SQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N) {
632: 	unsigned char *a, *b;
633: 	if (zLeft == 0) {
634: 		return zRight ? -1 : 0;
635: 	} else if (zRight == 0) {
636: 		return 1;
637: 	}
638: 	a = (unsigned char *)zLeft;
639: 	b = (unsigned char *)zRight;
640: 	while (N-- > 0 && *a != 0 && sqlite3UpperToLower[*a] == sqlite3UpperToLower[*b]) {
641: 		a++;
642: 		b++;
643: 	}
644: 	return N < 0 ? 0 : sqlite3UpperToLower[*a] - sqlite3UpperToLower[*b];
645: }
646: 
647: char *sqlite3_strdup(const char *str) {
648: 	char *result = (char *)sqlite3_malloc64(strlen(str) + 1);
649: 	strcpy(result, str);
650: 	return result;
651: }
652: 
653: void *sqlite3_malloc64(sqlite3_uint64 n) {
654: 	return malloc(n);
655: }
656: void sqlite3_free(void *pVoid) {
657: 	free(pVoid);
658: }
659: 
660: void *sqlite3_malloc(int n) {
661: 	return sqlite3_malloc64(n);
662: }
663: 
664: void *sqlite3_realloc(void *ptr, int n) {
665: 	return sqlite3_realloc64(ptr, n);
666: }
667: 
668: void *sqlite3_realloc64(void *ptr, sqlite3_uint64 n) {
669: 	return realloc(ptr, n);
670: }
671: 
672: // TODO: stub
673: int sqlite3_config(int i, ...) {
674: 	return SQLITE_OK;
675: }
676: 
677: int sqlite3_errcode(sqlite3 *db) {
678: 	if (!db) {
679: 		return SQLITE_MISUSE;
680: 	}
681: 	return db->last_error.empty() ? SQLITE_OK : SQLITE_ERROR;
682: }
683: 
684: int sqlite3_extended_errcode(sqlite3 *db) {
685: 	return sqlite3_errcode(db);
686: }
687: 
688: const char *sqlite3_errmsg(sqlite3 *db) {
689: 	if (!db) {
690: 		return "";
691: 	}
692: 	return db->last_error.c_str();
693: }
694: 
695: void sqlite3_interrupt(sqlite3 *db) {
696: 	if (db) {
697: 		db->con->Interrupt();
698: 	}
699: }
700: 
701: const char *sqlite3_libversion(void) {
702: 	return DuckDB::LibraryVersion();
703: }
704: const char *sqlite3_sourceid(void) {
705: 	return DuckDB::SourceID();
706: }
707: 
708: int sqlite3_reset(sqlite3_stmt *stmt) {
709: 	if (stmt) {
710: 		stmt->result = nullptr;
711: 		stmt->current_chunk = nullptr;
712: 	}
713: 	return SQLITE_OK;
714: }
715: 
716: // support functions for shell.c
717: // most are dummies, we don't need them really
718: 
719: int sqlite3_db_status(sqlite3 *, int op, int *pCur, int *pHiwtr, int resetFlg) {
720: 	fprintf(stderr, "sqlite3_db_status: unsupported.\n");
721: 	return -1;
722: }
723: 
724: // TODO these should eventually be implemented
725: 
726: int sqlite3_changes(sqlite3 *db) {
727: 	fprintf(stderr, "sqlite3_changes: unsupported.\n");
728: 	return 0;
729: }
730: 
731: int sqlite3_total_changes(sqlite3 *) {
732: 	fprintf(stderr, "sqlite3_total_changes: unsupported.\n");
733: 	return 0;
734: }
735: 
736: // checks if input ends with ;
737: int sqlite3_complete(const char *sql) {
738: 	// FIXME fprintf(stderr, "sqlite3_complete: unsupported.\n");
739: 	return -1;
740: }
741: 
742: int sqlite3_bind_blob(sqlite3_stmt *, int, const void *, int n, void (*)(void *)) {
743: 	fprintf(stderr, "sqlite3_bind_blob: unsupported.\n");
744: 	return -1;
745: }
746: 
747: const void *sqlite3_column_blob(sqlite3_stmt *, int iCol) {
748: 	fprintf(stderr, "sqlite3_column_blob: unsupported.\n");
749: 	return nullptr;
750: }
751: 
752: // length of varchar or blob value
753: int sqlite3_column_bytes(sqlite3_stmt *, int iCol) {
754: 	fprintf(stderr, "sqlite3_column_bytes: unsupported.\n");
755: 	return -1;
756: }
757: 
758: sqlite3_value *sqlite3_column_value(sqlite3_stmt *, int iCol) {
759: 	fprintf(stderr, "sqlite3_column_value: unsupported.\n");
760: 	return nullptr;
761: }
762: 
763: int sqlite3_db_config(sqlite3 *, int op, ...) {
764: 	fprintf(stderr, "sqlite3_db_config: unsupported.\n");
765: 	return -1;
766: }
767: 
768: int sqlite3_get_autocommit(sqlite3 *db) {
769: 	return 1;
770: 	// TODO fix this
771: 	// return db->con->context->transaction.IsAutoCommit();
772: 	fprintf(stderr, "sqlite3_get_autocommit: unsupported.\n");
773: }
774: 
775: int sqlite3_limit(sqlite3 *, int id, int newVal) {
776: 	fprintf(stderr, "sqlite3_limit: unsupported.\n");
777: 	return -1;
778: }
779: 
780: int sqlite3_stmt_readonly(sqlite3_stmt *pStmt) {
781: 	fprintf(stderr, "sqlite3_stmt_readonly: unsupported.\n");
782: 	return -1;
783: }
784: 
785: // TODO pretty easy schema lookup
786: int sqlite3_table_column_metadata(sqlite3 *db,             /* Connection handle */
787:                                   const char *zDbName,     /* Database name or NULL */
788:                                   const char *zTableName,  /* Table name */
789:                                   const char *zColumnName, /* Column name */
790:                                   char const **pzDataType, /* OUTPUT: Declared data type */
791:                                   char const **pzCollSeq,  /* OUTPUT: Collation sequence name */
792:                                   int *pNotNull,           /* OUTPUT: True if NOT NULL constraint exists */
793:                                   int *pPrimaryKey,        /* OUTPUT: True if column part of PK */
794:                                   int *pAutoinc            /* OUTPUT: True if column is auto-increment */
795: ) {
796: 	fprintf(stderr, "sqlite3_table_column_metadata: unsupported.\n");
797: 	return -1;
798: }
799: 
800: const char *sqlite3_column_decltype(sqlite3_stmt *stmt, int col) {
801: 	fprintf(stderr, "sqlite3_column_decltype: unsupported.\n");
802: 	return nullptr;
803: }
804: 
805: int sqlite3_status64(int op, sqlite3_int64 *pCurrent, sqlite3_int64 *pHighwater, int resetFlag) {
806: 	fprintf(stderr, "sqlite3_status64: unsupported.\n");
807: 	return -1;
808: }
809: 
810: int sqlite3_status64(sqlite3 *, int op, int *pCur, int *pHiwtr, int resetFlg) {
811: 	fprintf(stderr, "sqlite3_status64: unsupported.\n");
812: 	return -1;
813: }
814: 
815: int sqlite3_stmt_status(sqlite3_stmt *, int op, int resetFlg) {
816: 	fprintf(stderr, "sqlite3_stmt_status: unsupported.\n");
817: 	return -1;
818: }
819: 
820: int sqlite3_file_control(sqlite3 *, const char *zDbName, int op, void *) {
821: 	fprintf(stderr, "sqlite3_file_control: unsupported.\n");
822: 	return -1;
823: }
824: 
825: int sqlite3_declare_vtab(sqlite3 *, const char *zSQL) {
826: 	fprintf(stderr, "sqlite3_declare_vtab: unsupported.\n");
827: 	return -1;
828: }
829: 
830: const char *sqlite3_vtab_collation(sqlite3_index_info *, int) {
831: 	fprintf(stderr, "sqlite3_vtab_collation: unsupported.\n");
832: 	return nullptr;
833: }
834: 
835: int sqlite3_sleep(int) {
836: 	fprintf(stderr, "sqlite3_sleep: unsupported.\n");
837: 	return -1;
838: }
839: 
840: int sqlite3_busy_timeout(sqlite3 *, int ms) {
841: 	fprintf(stderr, "sqlite3_busy_timeout: unsupported.\n");
842: 	return -1;
843: }
844: 
845: // unlikely to be supported
846: 
847: int sqlite3_trace_v2(sqlite3 *, unsigned uMask, int (*xCallback)(unsigned, void *, void *, void *), void *pCtx) {
848: 	fprintf(stderr, "sqlite3_trace_v2: unsupported.\n");
849: 	return -1;
850: }
851: 
852: int sqlite3_test_control(int op, ...) {
853: 	fprintf(stderr, "sqlite3_test_control: unsupported.\n");
854: 	return -1;
855: }
856: 
857: int sqlite3_enable_load_extension(sqlite3 *db, int onoff) {
858: 	// fprintf(stderr, "sqlite3_enable_load_extension: unsupported.\n");
859: 	return -1;
860: }
861: 
862: int sqlite3_load_extension(sqlite3 *db,       /* Load the extension into this database connection */
863:                            const char *zFile, /* Name of the shared library containing extension */
864:                            const char *zProc, /* Entry point.  Derived from zFile if 0 */
865:                            char **pzErrMsg    /* Put error message here if not 0 */
866: ) {
867: 	// fprintf(stderr, "sqlite3_load_extension: unsupported.\n");
868: 	return -1;
869: }
870: 
871: int sqlite3_create_module(sqlite3 *db,             /* SQLite connection to register module with */
872:                           const char *zName,       /* Name of the module */
873:                           const sqlite3_module *p, /* Methods for the module */
874:                           void *pClientData        /* Client data for xCreate/xConnect */
875: ) {
876: 	// fprintf(stderr, "sqlite3_create_module: unsupported.\n");
877: 	return -1;
878: }
879: 
880: int sqlite3_create_function(sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep, void *pApp,
881:                             void (*xFunc)(sqlite3_context *, int, sqlite3_value **),
882:                             void (*xStep)(sqlite3_context *, int, sqlite3_value **),
883:                             void (*xFinal)(sqlite3_context *)) {
884: 	// fprintf(stderr, "sqlite3_create_function: unsupported.\n");
885: 	return -1;
886: }
887: 
888: int sqlite3_set_authorizer(sqlite3 *, int (*xAuth)(void *, int, const char *, const char *, const char *, const char *),
889:                            void *pUserData) {
890: 	fprintf(stderr, "sqlite3_set_authorizer: unsupported.\n");
891: 	return -1;
892: }
893: 
894: // needed in shell timer
895: static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow) {
896: 	using namespace std::chrono;
897: 	*piNow = (sqlite3_int64)duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
898: 	return SQLITE_OK;
899: }
900: 
901: // virtual file system, providing some dummies to avoid crashes
902: sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName) {
903: 	// return a dummy because the shell does not check the return code.
904: 	// fprintf(stderr, "sqlite3_vfs_find: unsupported.\n");
905: 	sqlite3_vfs *res = (sqlite3_vfs *)sqlite3_malloc(sizeof(sqlite3_vfs));
906: 	res->xCurrentTimeInt64 = unixCurrentTimeInt64;
907: 	res->iVersion = 2;
908: 	res->zName = "dummy";
909: 	res->pNext = nullptr;
910: 	assert(res);
911: 	return res;
912: }
913: int sqlite3_vfs_register(sqlite3_vfs *, int makeDflt) {
914: 	// fprintf(stderr, "sqlite3_vfs_register: unsupported.\n");
915: 	return -1;
916: }
917: 
918: // backups, unused
919: 
920: int sqlite3_backup_step(sqlite3_backup *p, int nPage) {
921: 	fprintf(stderr, "sqlite3_backup_step: unsupported.\n");
922: 	return -1;
923: }
924: int sqlite3_backup_finish(sqlite3_backup *p) {
925: 	fprintf(stderr, "sqlite3_backup_finish: unsupported.\n");
926: 	return -1;
927: }
928: 
929: sqlite3_backup *sqlite3_backup_init(sqlite3 *pDest,         /* Destination database handle */
930:                                     const char *zDestName,  /* Destination database name */
931:                                     sqlite3 *pSource,       /* Source database handle */
932:                                     const char *zSourceName /* Source database name */
933: ) {
934: 	fprintf(stderr, "sqlite3_backup_init: unsupported.\n");
935: 	return nullptr;
936: }
937: 
938: // UDF support stuff, unused for now. These cannot be called as create_function above is disabled
939: 
940: SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context *) {
941: 	return nullptr;
942: }
943: 
944: void *sqlite3_user_data(sqlite3_context *) {
945: 	return nullptr;
946: }
947: 
948: #ifdef _WIN32
949: #include <windows.h>
950: 
951: static void *sqlite3MallocZero(size_t n) {
952: 	auto res = sqlite3_malloc(n);
953: 	assert(res);
954: 	memset(res, 0, n);
955: 	return res;
956: }
957: 
958: static LPWSTR winUtf8ToUnicode(const char *zText) {
959: 	int nChar;
960: 	LPWSTR zWideText;
961: 
962: 	nChar = MultiByteToWideChar(CP_UTF8, 0, zText, -1, NULL, 0);
963: 	if (nChar == 0) {
964: 		return 0;
965: 	}
966: 	zWideText = (LPWSTR)sqlite3MallocZero(nChar * sizeof(WCHAR));
967: 	if (zWideText == 0) {
968: 		return 0;
969: 	}
970: 	nChar = MultiByteToWideChar(CP_UTF8, 0, zText, -1, zWideText, nChar);
971: 	if (nChar == 0) {
972: 		sqlite3_free(zWideText);
973: 		zWideText = 0;
974: 	}
975: 	return zWideText;
976: }
977: 
978: static char *winUnicodeToMbcs(LPCWSTR zWideText, int useAnsi) {
979: 	int nByte;
980: 	char *zText;
981: 	int codepage = useAnsi ? CP_ACP : CP_OEMCP;
982: 
983: 	nByte = WideCharToMultiByte(codepage, 0, zWideText, -1, 0, 0, 0, 0);
984: 	if (nByte == 0) {
985: 		return 0;
986: 	}
987: 	zText = (char *)sqlite3MallocZero(nByte);
988: 	if (zText == 0) {
989: 		return 0;
990: 	}
991: 	nByte = WideCharToMultiByte(codepage, 0, zWideText, -1, zText, nByte, 0, 0);
992: 	if (nByte == 0) {
993: 		sqlite3_free(zText);
994: 		zText = 0;
995: 	}
996: 	return zText;
997: }
998: 
999: static char *winUtf8ToMbcs(const char *zText, int useAnsi) {
1000: 	char *zTextMbcs;
1001: 	LPWSTR zTmpWide;
1002: 
1003: 	zTmpWide = winUtf8ToUnicode(zText);
1004: 	if (zTmpWide == 0) {
1005: 		return 0;
1006: 	}
1007: 	zTextMbcs = winUnicodeToMbcs(zTmpWide, useAnsi);
1008: 	sqlite3_free(zTmpWide);
1009: 	return zTextMbcs;
1010: }
1011: 
1012: SQLITE_API char *sqlite3_win32_utf8_to_mbcs_v2(const char *zText, int useAnsi) {
1013: 	return winUtf8ToMbcs(zText, useAnsi);
1014: }
1015: 
1016: LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText) {
1017: 	return winUtf8ToUnicode(zText);
1018: }
1019: 
1020: static LPWSTR winMbcsToUnicode(const char *zText, int useAnsi) {
1021: 	int nByte;
1022: 	LPWSTR zMbcsText;
1023: 	int codepage = useAnsi ? CP_ACP : CP_OEMCP;
1024: 
1025: 	nByte = MultiByteToWideChar(codepage, 0, zText, -1, NULL, 0) * sizeof(WCHAR);
1026: 	if (nByte == 0) {
1027: 		return 0;
1028: 	}
1029: 	zMbcsText = (LPWSTR)sqlite3MallocZero(nByte * sizeof(WCHAR));
1030: 	if (zMbcsText == 0) {
1031: 		return 0;
1032: 	}
1033: 	nByte = MultiByteToWideChar(codepage, 0, zText, -1, zMbcsText, nByte);
1034: 	if (nByte == 0) {
1035: 		sqlite3_free(zMbcsText);
1036: 		zMbcsText = 0;
1037: 	}
1038: 	return zMbcsText;
1039: }
1040: 
1041: static char *winUnicodeToUtf8(LPCWSTR zWideText) {
1042: 	int nByte;
1043: 	char *zText;
1044: 
1045: 	nByte = WideCharToMultiByte(CP_UTF8, 0, zWideText, -1, 0, 0, 0, 0);
1046: 	if (nByte == 0) {
1047: 		return 0;
1048: 	}
1049: 	zText = (char *)sqlite3MallocZero(nByte);
1050: 	if (zText == 0) {
1051: 		return 0;
1052: 	}
1053: 	nByte = WideCharToMultiByte(CP_UTF8, 0, zWideText, -1, zText, nByte, 0, 0);
1054: 	if (nByte == 0) {
1055: 		sqlite3_free(zText);
1056: 		zText = 0;
1057: 	}
1058: 	return zText;
1059: }
1060: 
1061: static char *winMbcsToUtf8(const char *zText, int useAnsi) {
1062: 	char *zTextUtf8;
1063: 	LPWSTR zTmpWide;
1064: 
1065: 	zTmpWide = winMbcsToUnicode(zText, useAnsi);
1066: 	if (zTmpWide == 0) {
1067: 		return 0;
1068: 	}
1069: 	zTextUtf8 = winUnicodeToUtf8(zTmpWide);
1070: 	sqlite3_free(zTmpWide);
1071: 	return zTextUtf8;
1072: }
1073: 
1074: SQLITE_API char *sqlite3_win32_mbcs_to_utf8_v2(const char *zText, int useAnsi) {
1075: 	return winMbcsToUtf8(zText, useAnsi);
1076: }
1077: 
1078: SQLITE_API char *sqlite3_win32_unicode_to_utf8(LPCWSTR zWideText) {
1079: 	return winUnicodeToUtf8(zWideText);
1080: }
1081: 
1082: #endif
1083: 
1084: // TODO complain
1085: SQLITE_API void sqlite3_result_blob(sqlite3_context *, const void *, int, void (*)(void *)) {
1086: }
1087: SQLITE_API void sqlite3_result_blob64(sqlite3_context *, const void *, sqlite3_uint64, void (*)(void *)) {
1088: }
1089: SQLITE_API void sqlite3_result_double(sqlite3_context *, double) {
1090: }
1091: SQLITE_API void sqlite3_result_error(sqlite3_context *, const char *, int) {
1092: }
1093: SQLITE_API void sqlite3_result_error16(sqlite3_context *, const void *, int) {
1094: }
1095: SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *) {
1096: }
1097: SQLITE_API void sqlite3_result_error_nomem(sqlite3_context *) {
1098: }
1099: SQLITE_API void sqlite3_result_error_code(sqlite3_context *, int) {
1100: }
1101: SQLITE_API void sqlite3_result_int(sqlite3_context *, int) {
1102: }
1103: SQLITE_API void sqlite3_result_int64(sqlite3_context *, sqlite3_int64) {
1104: }
1105: SQLITE_API void sqlite3_result_null(sqlite3_context *) {
1106: }
1107: SQLITE_API void sqlite3_result_text(sqlite3_context *, const char *, int, void (*)(void *)) {
1108: }
1109: SQLITE_API void sqlite3_result_text64(sqlite3_context *, const char *, sqlite3_uint64, void (*)(void *),
1110:                                       unsigned char encoding) {
1111: }
1112: SQLITE_API void sqlite3_result_text16(sqlite3_context *, const void *, int, void (*)(void *)) {
1113: }
1114: SQLITE_API void sqlite3_result_text16le(sqlite3_context *, const void *, int, void (*)(void *)) {
1115: }
1116: SQLITE_API void sqlite3_result_text16be(sqlite3_context *, const void *, int, void (*)(void *)) {
1117: }
1118: SQLITE_API void sqlite3_result_value(sqlite3_context *, sqlite3_value *) {
1119: }
1120: SQLITE_API void sqlite3_result_pointer(sqlite3_context *, void *, const char *, void (*)(void *)) {
1121: }
1122: SQLITE_API void sqlite3_result_zeroblob(sqlite3_context *, int n) {
1123: }
1124: SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context *, sqlite3_uint64 n) {
1125: 	return -1;
1126: }
1127: 
1128: // TODO complain
1129: const void *sqlite3_value_blob(sqlite3_value *) {
1130: 	return nullptr;
1131: }
1132: double sqlite3_value_double(sqlite3_value *) {
1133: 	return 0;
1134: }
1135: int sqlite3_value_int(sqlite3_value *) {
1136: 	return 0;
1137: }
1138: sqlite3_int64 sqlite3_value_int64(sqlite3_value *) {
1139: 	return 0;
1140: }
1141: void *sqlite3_value_pointer(sqlite3_value *, const char *) {
1142: 	return nullptr;
1143: }
1144: const unsigned char *sqlite3_value_text(sqlite3_value *) {
1145: 	return nullptr;
1146: }
1147: SQLITE_API const void *sqlite3_value_text16(sqlite3_value *) {
1148: 	return nullptr;
1149: }
1150: SQLITE_API const void *sqlite3_value_text16le(sqlite3_value *) {
1151: 	return nullptr;
1152: }
1153: SQLITE_API const void *sqlite3_value_text16be(sqlite3_value *) {
1154: 	return nullptr;
1155: }
1156: SQLITE_API int sqlite3_value_bytes(sqlite3_value *) {
1157: 	return 0;
1158: }
1159: SQLITE_API int sqlite3_value_bytes16(sqlite3_value *) {
1160: 	return 0;
1161: }
1162: SQLITE_API int sqlite3_value_type(sqlite3_value *) {
1163: 	return 0;
1164: }
1165: SQLITE_API int sqlite3_value_numeric_type(sqlite3_value *) {
1166: 	return 0;
1167: }
1168: SQLITE_API int sqlite3_value_nochange(sqlite3_value *) {
1169: 	return 0;
1170: }
1171: 
1172: SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *, int nBytes) {
1173: 	fprintf(stderr, "sqlite3_aggregate_context: unsupported.\n");
1174: 
1175: 	return nullptr;
1176: }
1177: 
1178: SQLITE_API int sqlite3_create_collation(sqlite3 *, const char *zName, int eTextRep, void *pArg,
1179:                                         int (*xCompare)(void *, int, const void *, int, const void *)) {
1180: 
1181: 	return SQLITE_ERROR;
1182: }
1183: 
1184: SQLITE_API int sqlite3_create_window_function(sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep,
1185:                                               void *pApp, void (*xStep)(sqlite3_context *, int, sqlite3_value **),
1186:                                               void (*xFinal)(sqlite3_context *), void (*xValue)(sqlite3_context *),
1187:                                               void (*xInverse)(sqlite3_context *, int, sqlite3_value **),
1188:                                               void (*xDestroy)(void *)) {
1189: 	fprintf(stderr, "sqlite3_create_window_function: unsupported.\n");
1190: 	return SQLITE_ERROR;
1191: }
1192: 
1193: SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *s) {
1194: 	return s->db;
1195: }
1196: 
1197: SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt) {
1198: 	fprintf(stderr, "sqlite3_expanded_sql: unsupported.\n");
1199: 	return nullptr;
1200: }
1201: 
1202: SQLITE_API int sqlite3_keyword_check(const char *str, int len) {
1203: 	return Parser::IsKeyword(std::string(str, len));
1204: }
1205: 
1206: SQLITE_API int sqlite3_keyword_count(void) {
1207: 	fprintf(stderr, "sqlite3_keyword_count: unsupported.\n");
1208: 	return 0;
1209: }
1210: 
1211: SQLITE_API int sqlite3_keyword_name(int, const char **, int *) {
1212: 	fprintf(stderr, "sqlite3_keyword_name: unsupported.\n");
1213: 	return 0;
1214: }
1215: 
1216: SQLITE_API void sqlite3_progress_handler(sqlite3 *, int, int (*)(void *), void *) {
1217: 	fprintf(stderr, "sqlite3_progress_handler: unsupported.\n");
1218: }
1219: 
1220: SQLITE_API int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt) {
1221: 	if (!pStmt || !pStmt->prepared) {
1222: 		return 0;
1223: 	}
1224: 	return pStmt->prepared->type == StatementType::EXPLAIN_STATEMENT;
1225: }
1226: 
1227: SQLITE_API int sqlite3_vtab_config(sqlite3 *, int op, ...) {
1228: 	fprintf(stderr, "sqlite3_vtab_config: unsupported.\n");
1229: 	return SQLITE_ERROR;
1230: }
[end of tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: