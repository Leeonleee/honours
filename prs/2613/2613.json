{
  "repo": "duckdb/duckdb",
  "pull_number": 2613,
  "instance_id": "duckdb__duckdb-2613",
  "issue_numbers": [
    "2401"
  ],
  "base_commit": "9fd0403b69f768bb6dca03aa5a841a96cd306348",
  "patch": "diff --git a/src/common/enums/physical_operator_type.cpp b/src/common/enums/physical_operator_type.cpp\nindex c8a07eed567d..df03381f302c 100644\n--- a/src/common/enums/physical_operator_type.cpp\n+++ b/src/common/enums/physical_operator_type.cpp\n@@ -71,6 +71,8 @@ string PhysicalOperatorToString(PhysicalOperatorType type) {\n \t\treturn \"CREATE_INDEX\";\n \tcase PhysicalOperatorType::EXPLAIN:\n \t\treturn \"EXPLAIN\";\n+\tcase PhysicalOperatorType::EXPLAIN_ANALYZE:\n+\t\treturn \"EXPLAIN_ANALYZE\";\n \tcase PhysicalOperatorType::EXECUTE:\n \t\treturn \"EXECUTE\";\n \tcase PhysicalOperatorType::VACUUM:\ndiff --git a/src/execution/operator/helper/CMakeLists.txt b/src/execution/operator/helper/CMakeLists.txt\nindex 1a54fd5ea374..1256f94a8426 100644\n--- a/src/execution/operator/helper/CMakeLists.txt\n+++ b/src/execution/operator/helper/CMakeLists.txt\n@@ -2,6 +2,7 @@ add_library_unity(\n   duckdb_operator_helper\n   OBJECT\n   physical_execute.cpp\n+  physical_explain_analyze.cpp\n   physical_limit.cpp\n   physical_load.cpp\n   physical_pragma.cpp\ndiff --git a/src/execution/operator/helper/physical_explain_analyze.cpp b/src/execution/operator/helper/physical_explain_analyze.cpp\nnew file mode 100644\nindex 000000000000..697a8a53594d\n--- /dev/null\n+++ b/src/execution/operator/helper/physical_explain_analyze.cpp\n@@ -0,0 +1,60 @@\n+#include \"duckdb/execution/operator/helper/physical_explain_analyze.hpp\"\n+#include \"duckdb/main/client_context.hpp\"\n+#include \"duckdb/main/query_profiler.hpp\"\n+\n+namespace duckdb {\n+\n+//===--------------------------------------------------------------------===//\n+// Sink\n+//===--------------------------------------------------------------------===//\n+class ExplainAnalyzeStateGlobalState : public GlobalSinkState {\n+public:\n+\tstring analyzed_plan;\n+};\n+\n+SinkResultType PhysicalExplainAnalyze::Sink(ExecutionContext &context, GlobalSinkState &state, LocalSinkState &lstate,\n+                                            DataChunk &input) const {\n+\treturn SinkResultType::NEED_MORE_INPUT;\n+}\n+\n+SinkFinalizeType PhysicalExplainAnalyze::Finalize(Pipeline &pipeline, Event &event, ClientContext &context,\n+                                                  GlobalSinkState &gstate_p) const {\n+\tauto &gstate = (ExplainAnalyzeStateGlobalState &)gstate_p;\n+\tgstate.analyzed_plan = context.profiler->ToString();\n+\treturn SinkFinalizeType::READY;\n+}\n+\n+unique_ptr<GlobalSinkState> PhysicalExplainAnalyze::GetGlobalSinkState(ClientContext &context) const {\n+\treturn make_unique<ExplainAnalyzeStateGlobalState>();\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// Source\n+//===--------------------------------------------------------------------===//\n+class ExplainAnalyzeState : public GlobalSourceState {\n+public:\n+\tExplainAnalyzeState() : finished(false) {\n+\t}\n+\n+\tbool finished;\n+};\n+\n+unique_ptr<GlobalSourceState> PhysicalExplainAnalyze::GetGlobalSourceState(ClientContext &context) const {\n+\treturn make_unique<ExplainAnalyzeState>();\n+}\n+\n+void PhysicalExplainAnalyze::GetData(ExecutionContext &context, DataChunk &chunk, GlobalSourceState &source_state,\n+                                     LocalSourceState &lstate) const {\n+\tauto &state = (ExplainAnalyzeState &)source_state;\n+\tauto &gstate = (ExplainAnalyzeStateGlobalState &)*sink_state;\n+\tif (state.finished) {\n+\t\treturn;\n+\t}\n+\tchunk.SetValue(0, 0, Value(\"analyzed_plan\"));\n+\tchunk.SetValue(1, 0, Value(gstate.analyzed_plan));\n+\tchunk.SetCardinality(1);\n+\n+\tstate.finished = true;\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/execution/physical_plan/plan_explain.cpp b/src/execution/physical_plan/plan_explain.cpp\nindex 8c2a316bcd60..2b7482cd0518 100644\n--- a/src/execution/physical_plan/plan_explain.cpp\n+++ b/src/execution/physical_plan/plan_explain.cpp\n@@ -1,6 +1,7 @@\n #include \"duckdb/execution/operator/scan/physical_chunk_scan.hpp\"\n #include \"duckdb/execution/physical_plan_generator.hpp\"\n #include \"duckdb/planner/operator/logical_explain.hpp\"\n+#include \"duckdb/execution/operator/helper/physical_explain_analyze.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n \n #include \"duckdb/common/tree_renderer.hpp\"\n@@ -11,9 +12,13 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalExplain &o\n \tD_ASSERT(op.children.size() == 1);\n \tauto logical_plan_opt = op.children[0]->ToString();\n \tauto plan = CreatePlan(*op.children[0]);\n+\tif (op.explain_type == ExplainType::EXPLAIN_ANALYZE) {\n+\t\tauto result = make_unique<PhysicalExplainAnalyze>(op.types);\n+\t\tresult->children.push_back(move(plan));\n+\t\treturn move(result);\n+\t}\n \n \top.physical_plan = plan->ToString();\n-\n \t// the output of the explain\n \tvector<string> keys, values;\n \tswitch (context.explain_output_type) {\ndiff --git a/src/include/duckdb/common/enums/physical_operator_type.hpp b/src/include/duckdb/common/enums/physical_operator_type.hpp\nindex 797d40f9dc91..27708d587a18 100644\n--- a/src/include/duckdb/common/enums/physical_operator_type.hpp\n+++ b/src/include/duckdb/common/enums/physical_operator_type.hpp\n@@ -82,6 +82,7 @@ enum class PhysicalOperatorType : uint8_t {\n \t// Helpers\n \t// -----------------------------\n \tEXPLAIN,\n+\tEXPLAIN_ANALYZE,\n \tEMPTY_RESULT,\n \tEXECUTE,\n \tPREPARE,\ndiff --git a/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp b/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp\nindex 26ef0345cb47..8a04558432f9 100644\n--- a/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp\n+++ b/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp\n@@ -47,7 +47,6 @@ class PhysicalSimpleAggregate : public PhysicalOperator {\n \t}\n \n \tbool ParallelSink() const override {\n-\t\t// we can only parallelize if all aggregates are combinable\n \t\treturn true;\n \t}\n };\ndiff --git a/src/include/duckdb/execution/operator/helper/physical_explain_analyze.hpp b/src/include/duckdb/execution/operator/helper/physical_explain_analyze.hpp\nnew file mode 100644\nindex 000000000000..07d49fb27744\n--- /dev/null\n+++ b/src/include/duckdb/execution/operator/helper/physical_explain_analyze.hpp\n@@ -0,0 +1,46 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/execution/operator/helper/physical_explain_analyze.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/execution/physical_operator.hpp\"\n+#include \"duckdb/planner/expression.hpp\"\n+\n+namespace duckdb {\n+\n+class PhysicalExplainAnalyze : public PhysicalOperator {\n+public:\n+\tPhysicalExplainAnalyze(vector<LogicalType> types)\n+\t    : PhysicalOperator(PhysicalOperatorType::EXPLAIN_ANALYZE, move(types), 1) {\n+\t}\n+\n+public:\n+\t// Source interface\n+\tunique_ptr<GlobalSourceState> GetGlobalSourceState(ClientContext &context) const override;\n+\tvoid GetData(ExecutionContext &context, DataChunk &chunk, GlobalSourceState &gstate,\n+\t             LocalSourceState &lstate) const override;\n+\n+public:\n+\t// Sink Interface\n+\tSinkResultType Sink(ExecutionContext &context, GlobalSinkState &state, LocalSinkState &lstate,\n+\t                    DataChunk &input) const override;\n+\tSinkFinalizeType Finalize(Pipeline &pipeline, Event &event, ClientContext &context,\n+\t                          GlobalSinkState &gstate) const override;\n+\n+\tunique_ptr<GlobalSinkState> GetGlobalSinkState(ClientContext &context) const override;\n+\n+\tbool IsSink() const override {\n+\t\treturn true;\n+\t}\n+\n+\tbool ParallelSink() const override {\n+\t\treturn true;\n+\t}\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/main/query_profiler.hpp b/src/include/duckdb/main/query_profiler.hpp\nindex f07e06b34d24..fa491bcaaa03 100644\n--- a/src/include/duckdb/main/query_profiler.hpp\n+++ b/src/include/duckdb/main/query_profiler.hpp\n@@ -34,6 +34,7 @@ struct ExpressionInfo {\n \tvector<unique_ptr<ExpressionInfo>> children;\n \t// Extract ExpressionInformation from a given expression state\n \tvoid ExtractExpressionsRecursive(unique_ptr<ExpressionState> &state);\n+\n \t//! Whether or not expression has function\n \tbool hasfunction;\n \t//! The function Name\n@@ -49,6 +50,7 @@ struct ExpressionInfo {\n //! The ExpressionRootInfo keeps information related to the root of an expression tree\n struct ExpressionRootInfo {\n \tExpressionRootInfo(ExpressionExecutorState &executor, string name);\n+\n \t//! Count the number of time the executor called\n \tuint64_t total_count = 0;\n \t//! Count the number of time the executor called since last sampling\n@@ -72,6 +74,7 @@ struct ExpressionRootInfo {\n struct ExpressionExecutorInfo {\n \texplicit ExpressionExecutorInfo() {};\n \texplicit ExpressionExecutorInfo(ExpressionExecutor &executor, const string &name, int id);\n+\n \t//! A vector which contain the pointer to all ExpressionRootInfo\n \tvector<unique_ptr<ExpressionRootInfo>> roots;\n \t//! Id, it will be used as index for executors_info vector\n@@ -79,11 +82,12 @@ struct ExpressionExecutorInfo {\n };\n \n struct OperatorInformation {\n+\texplicit OperatorInformation(double time_ = 0, idx_t elements_ = 0) : time(time_), elements(elements_) {\n+\t}\n+\n \tdouble time = 0;\n \tidx_t elements = 0;\n \tstring name;\n-\texplicit OperatorInformation(double time_ = 0, idx_t elements_ = 0) : time(time_), elements(elements_) {\n-\t}\n \t//! A vector of Expression Executor Info\n \tvector<unique_ptr<ExpressionExecutorInfo>> executors_info;\n };\n@@ -121,9 +125,16 @@ class QueryProfiler {\n public:\n \tDUCKDB_API QueryProfiler()\n \t    : automatic_print_format(ProfilerPrintFormat::NONE), enabled(false), detailed_enabled(false), running(false),\n-\t      query_requires_profiling(false) {\n+\t      query_requires_profiling(false), is_explain_analyze(false), stored_enabled(false),\n+\t      stored_automatic_print_format(ProfilerPrintFormat::NONE) {\n \t}\n \n+\t//! The format to automatically print query profiling information in (default: disabled)\n+\tProfilerPrintFormat automatic_print_format;\n+\t//! The file to save query profiling information to, instead of printing it to the console (empty = print to\n+\t//! console)\n+\tstring save_location;\n+\n public:\n \tstruct TreeNode {\n \t\tPhysicalOperatorType type;\n@@ -167,9 +178,11 @@ class QueryProfiler {\n \t\treturn detailed_enabled;\n \t}\n \n-\tDUCKDB_API void StartQuery(string query);\n+\tDUCKDB_API void StartQuery(string query, bool is_explain_analyze = false);\n \tDUCKDB_API void EndQuery();\n \n+\tDUCKDB_API void StartExplainAnalyze();\n+\n \t//! Adds the timings gathered by an OperatorProfiler to this query profiler\n \tDUCKDB_API void Flush(OperatorProfiler &profiler);\n \n@@ -185,12 +198,6 @@ class QueryProfiler {\n \tDUCKDB_API string ToJSON() const;\n \tDUCKDB_API void WriteToFile(const char *path, string &info) const;\n \n-\t//! The format to automatically print query profiling information in (default: disabled)\n-\tProfilerPrintFormat automatic_print_format;\n-\t//! The file to save query profiling information to, instead of printing it to the console (empty = print to\n-\t//! console)\n-\tstring save_location;\n-\n \tidx_t OperatorSize() {\n \t\treturn tree_map.size();\n \t}\n@@ -216,6 +223,11 @@ class QueryProfiler {\n \t//! A map of a Physical Operator pointer to a tree node\n \tTreeMap tree_map;\n \n+\tbool is_explain_analyze;\n+\tbool stored_enabled;\n+\tProfilerPrintFormat stored_automatic_print_format;\n+\tstring stored_save_location;\n+\n public:\n \tconst TreeMap &GetTreeMap() const {\n \t\treturn tree_map;\ndiff --git a/src/include/duckdb/parser/statement/explain_statement.hpp b/src/include/duckdb/parser/statement/explain_statement.hpp\nindex c6745c2563fb..d94e32aa0a95 100644\n--- a/src/include/duckdb/parser/statement/explain_statement.hpp\n+++ b/src/include/duckdb/parser/statement/explain_statement.hpp\n@@ -13,11 +13,14 @@\n \n namespace duckdb {\n \n+enum class ExplainType : uint8_t { EXPLAIN_STANDARD, EXPLAIN_ANALYZE };\n+\n class ExplainStatement : public SQLStatement {\n public:\n-\texplicit ExplainStatement(unique_ptr<SQLStatement> stmt);\n+\tExplainStatement(unique_ptr<SQLStatement> stmt, ExplainType explain_type = ExplainType::EXPLAIN_STANDARD);\n \n \tunique_ptr<SQLStatement> stmt;\n+\tExplainType explain_type;\n \n public:\n \tunique_ptr<SQLStatement> Copy() const override;\ndiff --git a/src/include/duckdb/planner/operator/logical_explain.hpp b/src/include/duckdb/planner/operator/logical_explain.hpp\nindex 3a48238566a5..2e287bfab02d 100644\n--- a/src/include/duckdb/planner/operator/logical_explain.hpp\n+++ b/src/include/duckdb/planner/operator/logical_explain.hpp\n@@ -9,15 +9,18 @@\n #pragma once\n \n #include \"duckdb/planner/logical_operator.hpp\"\n+#include \"duckdb/parser/statement/explain_statement.hpp\"\n \n namespace duckdb {\n \n class LogicalExplain : public LogicalOperator {\n public:\n-\texplicit LogicalExplain(unique_ptr<LogicalOperator> plan) : LogicalOperator(LogicalOperatorType::LOGICAL_EXPLAIN) {\n+\tLogicalExplain(unique_ptr<LogicalOperator> plan, ExplainType explain_type)\n+\t    : LogicalOperator(LogicalOperatorType::LOGICAL_EXPLAIN), explain_type(explain_type) {\n \t\tchildren.push_back(move(plan));\n \t}\n \n+\tExplainType explain_type;\n \tstring physical_plan;\n \tstring logical_plan_unopt;\n \tstring logical_plan_opt;\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex 0a02933fc723..ac513f0712ad 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -405,6 +405,17 @@ unique_ptr<QueryResult> ClientContext::RunStatementInternal(ClientContextLock &l\n \treturn ExecutePreparedStatement(lock, query, move(prepared), move(bound_values), allow_stream_result);\n }\n \n+static bool IsExplainAnalyze(SQLStatement *statement) {\n+\tif (!statement) {\n+\t\treturn false;\n+\t}\n+\tif (statement->type != StatementType::EXPLAIN_STATEMENT) {\n+\t\treturn false;\n+\t}\n+\tauto &explain = (ExplainStatement &)*statement;\n+\treturn explain.explain_type == ExplainType::EXPLAIN_ANALYZE;\n+}\n+\n unique_ptr<QueryResult> ClientContext::RunStatementOrPreparedStatement(ClientContextLock &lock, const string &query,\n                                                                        unique_ptr<SQLStatement> statement,\n                                                                        shared_ptr<PreparedStatementData> &prepared,\n@@ -436,7 +447,7 @@ unique_ptr<QueryResult> ClientContext::RunStatementOrPreparedStatement(ClientCon\n \t\tstatement = move(copied_statement);\n \t}\n \t// start the profiler\n-\tprofiler->StartQuery(query);\n+\tprofiler->StartQuery(query, IsExplainAnalyze(statement ? statement.get() : prepared->unbound_statement.get()));\n \ttry {\n \t\tif (statement) {\n \t\t\tresult = RunStatementInternal(lock, query, move(statement), allow_stream_result);\ndiff --git a/src/main/query_profiler.cpp b/src/main/query_profiler.cpp\nindex 618bb9060f82..f98b76903009 100644\n--- a/src/main/query_profiler.cpp\n+++ b/src/main/query_profiler.cpp\n@@ -16,7 +16,10 @@\n \n namespace duckdb {\n \n-void QueryProfiler::StartQuery(string query) {\n+void QueryProfiler::StartQuery(string query, bool is_explain_analyze) {\n+\tif (is_explain_analyze) {\n+\t\tStartExplainAnalyze();\n+\t}\n \tif (!enabled) {\n \t\treturn;\n \t}\n@@ -72,6 +75,17 @@ void QueryProfiler::Finalize(TreeNode &node) {\n \t}\n }\n \n+void QueryProfiler::StartExplainAnalyze() {\n+\tthis->is_explain_analyze = true;\n+\tthis->stored_enabled = enabled;\n+\tthis->stored_automatic_print_format = automatic_print_format;\n+\tthis->stored_save_location = save_location;\n+\n+\tthis->enabled = true;\n+\tthis->save_location = string();\n+\tthis->automatic_print_format = ProfilerPrintFormat::NONE;\n+}\n+\n void QueryProfiler::EndQuery() {\n \tif (!enabled || !running) {\n \t\treturn;\n@@ -101,6 +115,12 @@ void QueryProfiler::EndQuery() {\n \t\t\tWriteToFile(save_location.c_str(), query_info);\n \t\t}\n \t}\n+\tif (is_explain_analyze) {\n+\t\tthis->is_explain_analyze = false;\n+\t\tthis->enabled = stored_enabled;\n+\t\tthis->automatic_print_format = stored_automatic_print_format;\n+\t\tthis->save_location = stored_save_location;\n+\t}\n }\n \n void QueryProfiler::StartPhase(string new_phase) {\ndiff --git a/src/parallel/executor.cpp b/src/parallel/executor.cpp\nindex bb7560f3e81c..7a2b2c249b92 100644\n--- a/src/parallel/executor.cpp\n+++ b/src/parallel/executor.cpp\n@@ -411,6 +411,7 @@ void Executor::BuildPipelines(PhysicalOperator *op, Pipeline *current) {\n \t\tcase PhysicalOperatorType::COPY_TO_FILE:\n \t\tcase PhysicalOperatorType::LIMIT:\n \t\tcase PhysicalOperatorType::EXPRESSION_SCAN:\n+\t\tcase PhysicalOperatorType::EXPLAIN_ANALYZE:\n \t\t\tD_ASSERT(op->children.size() == 1);\n \t\t\t// single operator:\n \t\t\t// the operator becomes the data source of the current pipeline\ndiff --git a/src/parser/statement/explain_statement.cpp b/src/parser/statement/explain_statement.cpp\nindex 6cf4383b36d8..6848b955382f 100644\n--- a/src/parser/statement/explain_statement.cpp\n+++ b/src/parser/statement/explain_statement.cpp\n@@ -2,12 +2,12 @@\n \n namespace duckdb {\n \n-ExplainStatement::ExplainStatement(unique_ptr<SQLStatement> stmt)\n-    : SQLStatement(StatementType::EXPLAIN_STATEMENT), stmt(move(stmt)) {\n+ExplainStatement::ExplainStatement(unique_ptr<SQLStatement> stmt, ExplainType explain_type)\n+    : SQLStatement(StatementType::EXPLAIN_STATEMENT), stmt(move(stmt)), explain_type(explain_type) {\n }\n \n unique_ptr<SQLStatement> ExplainStatement::Copy() const {\n-\tauto result = make_unique<ExplainStatement>(stmt->Copy());\n+\tauto result = make_unique<ExplainStatement>(stmt->Copy(), explain_type);\n \treturn move(result);\n }\n \ndiff --git a/src/parser/transform/statement/transform_explain.cpp b/src/parser/transform/statement/transform_explain.cpp\nindex 2b212105c6ad..0d344b07655f 100644\n--- a/src/parser/transform/statement/transform_explain.cpp\n+++ b/src/parser/transform/statement/transform_explain.cpp\n@@ -6,7 +6,19 @@ namespace duckdb {\n unique_ptr<ExplainStatement> Transformer::TransformExplain(duckdb_libpgquery::PGNode *node) {\n \tauto stmt = reinterpret_cast<duckdb_libpgquery::PGExplainStmt *>(node);\n \tD_ASSERT(stmt);\n-\treturn make_unique<ExplainStatement>(TransformStatement(stmt->query));\n+\tauto explain_type = ExplainType::EXPLAIN_STANDARD;\n+\tif (stmt->options) {\n+\t\tfor (auto n = stmt->options->head; n; n = n->next) {\n+\t\t\tauto def_elem = ((duckdb_libpgquery::PGDefElem *)n->data.ptr_value)->defname;\n+\t\t\tstring elem(def_elem);\n+\t\t\tif (elem == \"analyze\") {\n+\t\t\t\texplain_type = ExplainType::EXPLAIN_ANALYZE;\n+\t\t\t} else {\n+\t\t\t\tthrow NotImplementedException(\"Unimplemented explain type: %s\", elem);\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn make_unique<ExplainStatement>(TransformStatement(stmt->query), explain_type);\n }\n \n } // namespace duckdb\ndiff --git a/src/planner/binder/statement/bind_explain.cpp b/src/planner/binder/statement/bind_explain.cpp\nindex 17bf21cba304..2a06c5d34687 100644\n--- a/src/planner/binder/statement/bind_explain.cpp\n+++ b/src/planner/binder/statement/bind_explain.cpp\n@@ -11,7 +11,7 @@ BoundStatement Binder::Bind(ExplainStatement &stmt) {\n \tauto plan = Bind(*stmt.stmt);\n \t// get the unoptimized logical plan, and create the explain statement\n \tauto logical_plan_unopt = plan.plan->ToString();\n-\tauto explain = make_unique<LogicalExplain>(move(plan.plan));\n+\tauto explain = make_unique<LogicalExplain>(move(plan.plan), stmt.explain_type);\n \texplain->logical_plan_unopt = logical_plan_unopt;\n \n \tresult.plan = move(explain);\n",
  "test_patch": "diff --git a/test/sql/explain/test_explain_analyze.test b/test/sql/explain/test_explain_analyze.test\nnew file mode 100644\nindex 000000000000..e5be671b06e3\n--- /dev/null\n+++ b/test/sql/explain/test_explain_analyze.test\n@@ -0,0 +1,66 @@\n+# name: test/sql/explain/test_explain_analyze.test\n+# description: Test explain analyze\n+# group: [explain]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE integers AS SELECT * FROM range(100) tbl(i);\n+\n+query II\n+EXPLAIN ANALYZE SELECT SUM(i) FROM integers\n+----\n+analyzed_plan\t<REGEX>:.*integers.*\n+\n+query II\n+EXPLAIN ANALYZE SELECT SUM(i) FROM (SELECT * FROM integers i1, integers i2 UNION ALL SELECT * FROM integers i1, integers i2);\n+----\n+analyzed_plan\t<REGEX>:.*CROSS_PRODUCT.*\n+\n+statement ok\n+PRAGMA enable_profiling\n+\n+query II\n+EXPLAIN ANALYZE SELECT SUM(i) FROM (SELECT * FROM integers i1, integers i2 UNION ALL SELECT * FROM integers i1, integers i2);\n+----\n+analyzed_plan\t<REGEX>:.*CROSS_PRODUCT.*\n+\n+statement ok\n+PRAGMA disable_profiling\n+\n+query II\n+EXPLAIN ANALYZE SELECT SUM(i) FROM (SELECT * FROM integers i1, integers i2 UNION ALL SELECT * FROM integers i1, integers i2);\n+----\n+analyzed_plan\t<REGEX>:.*CROSS_PRODUCT.*\n+\n+statement ok\n+PRAGMA profiling_output='__TEST_DIR__/test.json'\n+\n+statement ok\n+PRAGMA enable_profiling='json'\n+\n+statement ok\n+SELECT 42\n+\n+statement ok\n+PRAGMA disable_profiling\n+\n+query I nosort json_output\n+SELECT * FROM read_csv('__TEST_DIR__/test.json', columns={'json': 'VARCHAR'}, sep='\ud83e\udd86');\n+----\n+\n+statement ok\n+PRAGMA enable_profiling='json'\n+\n+query II\n+EXPLAIN ANALYZE SELECT SUM(i) FROM integers\n+----\n+analyzed_plan\t<REGEX>:.*integers.*\n+\n+statement ok\n+PRAGMA disable_profiling\n+\n+query I nosort json_output\n+SELECT * FROM read_csv('__TEST_DIR__/test.json', columns={'json': 'VARCHAR'}, sep='\ud83e\udd86');\n+----\ndiff --git a/test/sql/explain/test_explain_analyze_tpch.test_slow b/test/sql/explain/test_explain_analyze_tpch.test_slow\nnew file mode 100644\nindex 000000000000..76e39eed6632\n--- /dev/null\n+++ b/test/sql/explain/test_explain_analyze_tpch.test_slow\n@@ -0,0 +1,43 @@\n+# name: test/sql/explain/test_explain_analyze_tpch.test_slow\n+# description: Test explain analyze TPC-H\n+# group: [explain]\n+\n+require tpch\n+\n+statement ok\n+CALL dbgen(sf=0.01);\n+\n+statement ok\n+PRAGMA enable_profiling\n+\n+loop i 0 2\n+\n+query II\n+EXPLAIN ANALYZE SELECT\n+    l_returnflag,\n+    l_linestatus,\n+    sum(l_quantity) AS sum_qty,\n+    sum(l_extendedprice) AS sum_base_price,\n+    sum(l_extendedprice * (1 - l_discount)) AS sum_disc_price,\n+    sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) AS sum_charge,\n+    avg(l_quantity) AS avg_qty,\n+    avg(l_extendedprice) AS avg_price,\n+    avg(l_discount) AS avg_disc,\n+    count(*) AS count_order\n+FROM\n+    lineitem\n+WHERE\n+    l_shipdate <= CAST('1998-09-02' AS date)\n+GROUP BY\n+    l_returnflag,\n+    l_linestatus\n+ORDER BY\n+    l_returnflag,\n+    l_linestatus;\n+----\n+analyzed_plan\t<REGEX>:.*lineitem.*\n+\n+statement ok\n+PRAGMA disable_profiling\n+\n+endloop\ndiff --git a/tools/shell/shell-test.py b/tools/shell/shell-test.py\nindex 37277577115a..ef54f06edf73 100644\n--- a/tools/shell/shell-test.py\n+++ b/tools/shell/shell-test.py\n@@ -166,6 +166,11 @@ def tf():\n SELECT x::INT FROM (SELECT x::VARCHAR x FROM range(10) tbl(x) UNION ALL SELECT 'hello' x) tbl(x);\n ''', err='Could not convert string')\n \n+# test explain\n+test('explain select sum(i) from range(1000) tbl(i)', out='RANGE')\n+test('explain analyze select sum(i) from range(1000) tbl(i)', out='RANGE')\n+\n+\n # this should be fixed\n test('.selftest', err='sqlite3_table_column_metadata')\n \n",
  "problem_statement": "Support EXPLAIN ANALYZE\nPostgres supports `EXPLAIN ANALYZE` which runs the query and shows query times, etc for the query. We should support the same, as this is essentially the same as our profiling output (`PRAGMA enable_profiling`) but actually returned as a query result which makes it easier to integrate into clients, etc.\n",
  "hints_text": "",
  "created_at": "2021-11-17T13:33:36Z"
}