diff --git a/src/common/enums/physical_operator_type.cpp b/src/common/enums/physical_operator_type.cpp
index c8a07eed567d..df03381f302c 100644
--- a/src/common/enums/physical_operator_type.cpp
+++ b/src/common/enums/physical_operator_type.cpp
@@ -71,6 +71,8 @@ string PhysicalOperatorToString(PhysicalOperatorType type) {
 		return "CREATE_INDEX";
 	case PhysicalOperatorType::EXPLAIN:
 		return "EXPLAIN";
+	case PhysicalOperatorType::EXPLAIN_ANALYZE:
+		return "EXPLAIN_ANALYZE";
 	case PhysicalOperatorType::EXECUTE:
 		return "EXECUTE";
 	case PhysicalOperatorType::VACUUM:
diff --git a/src/execution/operator/helper/CMakeLists.txt b/src/execution/operator/helper/CMakeLists.txt
index 1a54fd5ea374..1256f94a8426 100644
--- a/src/execution/operator/helper/CMakeLists.txt
+++ b/src/execution/operator/helper/CMakeLists.txt
@@ -2,6 +2,7 @@ add_library_unity(
   duckdb_operator_helper
   OBJECT
   physical_execute.cpp
+  physical_explain_analyze.cpp
   physical_limit.cpp
   physical_load.cpp
   physical_pragma.cpp
diff --git a/src/execution/operator/helper/physical_explain_analyze.cpp b/src/execution/operator/helper/physical_explain_analyze.cpp
new file mode 100644
index 000000000000..697a8a53594d
--- /dev/null
+++ b/src/execution/operator/helper/physical_explain_analyze.cpp
@@ -0,0 +1,60 @@
+#include "duckdb/execution/operator/helper/physical_explain_analyze.hpp"
+#include "duckdb/main/client_context.hpp"
+#include "duckdb/main/query_profiler.hpp"
+
+namespace duckdb {
+
+//===--------------------------------------------------------------------===//
+// Sink
+//===--------------------------------------------------------------------===//
+class ExplainAnalyzeStateGlobalState : public GlobalSinkState {
+public:
+	string analyzed_plan;
+};
+
+SinkResultType PhysicalExplainAnalyze::Sink(ExecutionContext &context, GlobalSinkState &state, LocalSinkState &lstate,
+                                            DataChunk &input) const {
+	return SinkResultType::NEED_MORE_INPUT;
+}
+
+SinkFinalizeType PhysicalExplainAnalyze::Finalize(Pipeline &pipeline, Event &event, ClientContext &context,
+                                                  GlobalSinkState &gstate_p) const {
+	auto &gstate = (ExplainAnalyzeStateGlobalState &)gstate_p;
+	gstate.analyzed_plan = context.profiler->ToString();
+	return SinkFinalizeType::READY;
+}
+
+unique_ptr<GlobalSinkState> PhysicalExplainAnalyze::GetGlobalSinkState(ClientContext &context) const {
+	return make_unique<ExplainAnalyzeStateGlobalState>();
+}
+
+//===--------------------------------------------------------------------===//
+// Source
+//===--------------------------------------------------------------------===//
+class ExplainAnalyzeState : public GlobalSourceState {
+public:
+	ExplainAnalyzeState() : finished(false) {
+	}
+
+	bool finished;
+};
+
+unique_ptr<GlobalSourceState> PhysicalExplainAnalyze::GetGlobalSourceState(ClientContext &context) const {
+	return make_unique<ExplainAnalyzeState>();
+}
+
+void PhysicalExplainAnalyze::GetData(ExecutionContext &context, DataChunk &chunk, GlobalSourceState &source_state,
+                                     LocalSourceState &lstate) const {
+	auto &state = (ExplainAnalyzeState &)source_state;
+	auto &gstate = (ExplainAnalyzeStateGlobalState &)*sink_state;
+	if (state.finished) {
+		return;
+	}
+	chunk.SetValue(0, 0, Value("analyzed_plan"));
+	chunk.SetValue(1, 0, Value(gstate.analyzed_plan));
+	chunk.SetCardinality(1);
+
+	state.finished = true;
+}
+
+} // namespace duckdb
diff --git a/src/execution/physical_plan/plan_explain.cpp b/src/execution/physical_plan/plan_explain.cpp
index 8c2a316bcd60..2b7482cd0518 100644
--- a/src/execution/physical_plan/plan_explain.cpp
+++ b/src/execution/physical_plan/plan_explain.cpp
@@ -1,6 +1,7 @@
 #include "duckdb/execution/operator/scan/physical_chunk_scan.hpp"
 #include "duckdb/execution/physical_plan_generator.hpp"
 #include "duckdb/planner/operator/logical_explain.hpp"
+#include "duckdb/execution/operator/helper/physical_explain_analyze.hpp"
 #include "duckdb/main/client_context.hpp"
 
 #include "duckdb/common/tree_renderer.hpp"
@@ -11,9 +12,13 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalExplain &o
 	D_ASSERT(op.children.size() == 1);
 	auto logical_plan_opt = op.children[0]->ToString();
 	auto plan = CreatePlan(*op.children[0]);
+	if (op.explain_type == ExplainType::EXPLAIN_ANALYZE) {
+		auto result = make_unique<PhysicalExplainAnalyze>(op.types);
+		result->children.push_back(move(plan));
+		return move(result);
+	}
 
 	op.physical_plan = plan->ToString();
-
 	// the output of the explain
 	vector<string> keys, values;
 	switch (context.explain_output_type) {
diff --git a/src/include/duckdb/common/enums/physical_operator_type.hpp b/src/include/duckdb/common/enums/physical_operator_type.hpp
index 797d40f9dc91..27708d587a18 100644
--- a/src/include/duckdb/common/enums/physical_operator_type.hpp
+++ b/src/include/duckdb/common/enums/physical_operator_type.hpp
@@ -82,6 +82,7 @@ enum class PhysicalOperatorType : uint8_t {
 	// Helpers
 	// -----------------------------
 	EXPLAIN,
+	EXPLAIN_ANALYZE,
 	EMPTY_RESULT,
 	EXECUTE,
 	PREPARE,
diff --git a/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp b/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp
index 26ef0345cb47..8a04558432f9 100644
--- a/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp
+++ b/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp
@@ -47,7 +47,6 @@ class PhysicalSimpleAggregate : public PhysicalOperator {
 	}
 
 	bool ParallelSink() const override {
-		// we can only parallelize if all aggregates are combinable
 		return true;
 	}
 };
diff --git a/src/include/duckdb/execution/operator/helper/physical_explain_analyze.hpp b/src/include/duckdb/execution/operator/helper/physical_explain_analyze.hpp
new file mode 100644
index 000000000000..07d49fb27744
--- /dev/null
+++ b/src/include/duckdb/execution/operator/helper/physical_explain_analyze.hpp
@@ -0,0 +1,46 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// duckdb/execution/operator/helper/physical_explain_analyze.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include "duckdb/execution/physical_operator.hpp"
+#include "duckdb/planner/expression.hpp"
+
+namespace duckdb {
+
+class PhysicalExplainAnalyze : public PhysicalOperator {
+public:
+	PhysicalExplainAnalyze(vector<LogicalType> types)
+	    : PhysicalOperator(PhysicalOperatorType::EXPLAIN_ANALYZE, move(types), 1) {
+	}
+
+public:
+	// Source interface
+	unique_ptr<GlobalSourceState> GetGlobalSourceState(ClientContext &context) const override;
+	void GetData(ExecutionContext &context, DataChunk &chunk, GlobalSourceState &gstate,
+	             LocalSourceState &lstate) const override;
+
+public:
+	// Sink Interface
+	SinkResultType Sink(ExecutionContext &context, GlobalSinkState &state, LocalSinkState &lstate,
+	                    DataChunk &input) const override;
+	SinkFinalizeType Finalize(Pipeline &pipeline, Event &event, ClientContext &context,
+	                          GlobalSinkState &gstate) const override;
+
+	unique_ptr<GlobalSinkState> GetGlobalSinkState(ClientContext &context) const override;
+
+	bool IsSink() const override {
+		return true;
+	}
+
+	bool ParallelSink() const override {
+		return true;
+	}
+};
+
+} // namespace duckdb
diff --git a/src/include/duckdb/main/query_profiler.hpp b/src/include/duckdb/main/query_profiler.hpp
index f07e06b34d24..fa491bcaaa03 100644
--- a/src/include/duckdb/main/query_profiler.hpp
+++ b/src/include/duckdb/main/query_profiler.hpp
@@ -34,6 +34,7 @@ struct ExpressionInfo {
 	vector<unique_ptr<ExpressionInfo>> children;
 	// Extract ExpressionInformation from a given expression state
 	void ExtractExpressionsRecursive(unique_ptr<ExpressionState> &state);
+
 	//! Whether or not expression has function
 	bool hasfunction;
 	//! The function Name
@@ -49,6 +50,7 @@ struct ExpressionInfo {
 //! The ExpressionRootInfo keeps information related to the root of an expression tree
 struct ExpressionRootInfo {
 	ExpressionRootInfo(ExpressionExecutorState &executor, string name);
+
 	//! Count the number of time the executor called
 	uint64_t total_count = 0;
 	//! Count the number of time the executor called since last sampling
@@ -72,6 +74,7 @@ struct ExpressionRootInfo {
 struct ExpressionExecutorInfo {
 	explicit ExpressionExecutorInfo() {};
 	explicit ExpressionExecutorInfo(ExpressionExecutor &executor, const string &name, int id);
+
 	//! A vector which contain the pointer to all ExpressionRootInfo
 	vector<unique_ptr<ExpressionRootInfo>> roots;
 	//! Id, it will be used as index for executors_info vector
@@ -79,11 +82,12 @@ struct ExpressionExecutorInfo {
 };
 
 struct OperatorInformation {
+	explicit OperatorInformation(double time_ = 0, idx_t elements_ = 0) : time(time_), elements(elements_) {
+	}
+
 	double time = 0;
 	idx_t elements = 0;
 	string name;
-	explicit OperatorInformation(double time_ = 0, idx_t elements_ = 0) : time(time_), elements(elements_) {
-	}
 	//! A vector of Expression Executor Info
 	vector<unique_ptr<ExpressionExecutorInfo>> executors_info;
 };
@@ -121,9 +125,16 @@ class QueryProfiler {
 public:
 	DUCKDB_API QueryProfiler()
 	    : automatic_print_format(ProfilerPrintFormat::NONE), enabled(false), detailed_enabled(false), running(false),
-	      query_requires_profiling(false) {
+	      query_requires_profiling(false), is_explain_analyze(false), stored_enabled(false),
+	      stored_automatic_print_format(ProfilerPrintFormat::NONE) {
 	}
 
+	//! The format to automatically print query profiling information in (default: disabled)
+	ProfilerPrintFormat automatic_print_format;
+	//! The file to save query profiling information to, instead of printing it to the console (empty = print to
+	//! console)
+	string save_location;
+
 public:
 	struct TreeNode {
 		PhysicalOperatorType type;
@@ -167,9 +178,11 @@ class QueryProfiler {
 		return detailed_enabled;
 	}
 
-	DUCKDB_API void StartQuery(string query);
+	DUCKDB_API void StartQuery(string query, bool is_explain_analyze = false);
 	DUCKDB_API void EndQuery();
 
+	DUCKDB_API void StartExplainAnalyze();
+
 	//! Adds the timings gathered by an OperatorProfiler to this query profiler
 	DUCKDB_API void Flush(OperatorProfiler &profiler);
 
@@ -185,12 +198,6 @@ class QueryProfiler {
 	DUCKDB_API string ToJSON() const;
 	DUCKDB_API void WriteToFile(const char *path, string &info) const;
 
-	//! The format to automatically print query profiling information in (default: disabled)
-	ProfilerPrintFormat automatic_print_format;
-	//! The file to save query profiling information to, instead of printing it to the console (empty = print to
-	//! console)
-	string save_location;
-
 	idx_t OperatorSize() {
 		return tree_map.size();
 	}
@@ -216,6 +223,11 @@ class QueryProfiler {
 	//! A map of a Physical Operator pointer to a tree node
 	TreeMap tree_map;
 
+	bool is_explain_analyze;
+	bool stored_enabled;
+	ProfilerPrintFormat stored_automatic_print_format;
+	string stored_save_location;
+
 public:
 	const TreeMap &GetTreeMap() const {
 		return tree_map;
diff --git a/src/include/duckdb/parser/statement/explain_statement.hpp b/src/include/duckdb/parser/statement/explain_statement.hpp
index c6745c2563fb..d94e32aa0a95 100644
--- a/src/include/duckdb/parser/statement/explain_statement.hpp
+++ b/src/include/duckdb/parser/statement/explain_statement.hpp
@@ -13,11 +13,14 @@
 
 namespace duckdb {
 
+enum class ExplainType : uint8_t { EXPLAIN_STANDARD, EXPLAIN_ANALYZE };
+
 class ExplainStatement : public SQLStatement {
 public:
-	explicit ExplainStatement(unique_ptr<SQLStatement> stmt);
+	ExplainStatement(unique_ptr<SQLStatement> stmt, ExplainType explain_type = ExplainType::EXPLAIN_STANDARD);
 
 	unique_ptr<SQLStatement> stmt;
+	ExplainType explain_type;
 
 public:
 	unique_ptr<SQLStatement> Copy() const override;
diff --git a/src/include/duckdb/planner/operator/logical_explain.hpp b/src/include/duckdb/planner/operator/logical_explain.hpp
index 3a48238566a5..2e287bfab02d 100644
--- a/src/include/duckdb/planner/operator/logical_explain.hpp
+++ b/src/include/duckdb/planner/operator/logical_explain.hpp
@@ -9,15 +9,18 @@
 #pragma once
 
 #include "duckdb/planner/logical_operator.hpp"
+#include "duckdb/parser/statement/explain_statement.hpp"
 
 namespace duckdb {
 
 class LogicalExplain : public LogicalOperator {
 public:
-	explicit LogicalExplain(unique_ptr<LogicalOperator> plan) : LogicalOperator(LogicalOperatorType::LOGICAL_EXPLAIN) {
+	LogicalExplain(unique_ptr<LogicalOperator> plan, ExplainType explain_type)
+	    : LogicalOperator(LogicalOperatorType::LOGICAL_EXPLAIN), explain_type(explain_type) {
 		children.push_back(move(plan));
 	}
 
+	ExplainType explain_type;
 	string physical_plan;
 	string logical_plan_unopt;
 	string logical_plan_opt;
diff --git a/src/main/client_context.cpp b/src/main/client_context.cpp
index 0a02933fc723..ac513f0712ad 100644
--- a/src/main/client_context.cpp
+++ b/src/main/client_context.cpp
@@ -405,6 +405,17 @@ unique_ptr<QueryResult> ClientContext::RunStatementInternal(ClientContextLock &l
 	return ExecutePreparedStatement(lock, query, move(prepared), move(bound_values), allow_stream_result);
 }
 
+static bool IsExplainAnalyze(SQLStatement *statement) {
+	if (!statement) {
+		return false;
+	}
+	if (statement->type != StatementType::EXPLAIN_STATEMENT) {
+		return false;
+	}
+	auto &explain = (ExplainStatement &)*statement;
+	return explain.explain_type == ExplainType::EXPLAIN_ANALYZE;
+}
+
 unique_ptr<QueryResult> ClientContext::RunStatementOrPreparedStatement(ClientContextLock &lock, const string &query,
                                                                        unique_ptr<SQLStatement> statement,
                                                                        shared_ptr<PreparedStatementData> &prepared,
@@ -436,7 +447,7 @@ unique_ptr<QueryResult> ClientContext::RunStatementOrPreparedStatement(ClientCon
 		statement = move(copied_statement);
 	}
 	// start the profiler
-	profiler->StartQuery(query);
+	profiler->StartQuery(query, IsExplainAnalyze(statement ? statement.get() : prepared->unbound_statement.get()));
 	try {
 		if (statement) {
 			result = RunStatementInternal(lock, query, move(statement), allow_stream_result);
diff --git a/src/main/query_profiler.cpp b/src/main/query_profiler.cpp
index 618bb9060f82..f98b76903009 100644
--- a/src/main/query_profiler.cpp
+++ b/src/main/query_profiler.cpp
@@ -16,7 +16,10 @@
 
 namespace duckdb {
 
-void QueryProfiler::StartQuery(string query) {
+void QueryProfiler::StartQuery(string query, bool is_explain_analyze) {
+	if (is_explain_analyze) {
+		StartExplainAnalyze();
+	}
 	if (!enabled) {
 		return;
 	}
@@ -72,6 +75,17 @@ void QueryProfiler::Finalize(TreeNode &node) {
 	}
 }
 
+void QueryProfiler::StartExplainAnalyze() {
+	this->is_explain_analyze = true;
+	this->stored_enabled = enabled;
+	this->stored_automatic_print_format = automatic_print_format;
+	this->stored_save_location = save_location;
+
+	this->enabled = true;
+	this->save_location = string();
+	this->automatic_print_format = ProfilerPrintFormat::NONE;
+}
+
 void QueryProfiler::EndQuery() {
 	if (!enabled || !running) {
 		return;
@@ -101,6 +115,12 @@ void QueryProfiler::EndQuery() {
 			WriteToFile(save_location.c_str(), query_info);
 		}
 	}
+	if (is_explain_analyze) {
+		this->is_explain_analyze = false;
+		this->enabled = stored_enabled;
+		this->automatic_print_format = stored_automatic_print_format;
+		this->save_location = stored_save_location;
+	}
 }
 
 void QueryProfiler::StartPhase(string new_phase) {
diff --git a/src/parallel/executor.cpp b/src/parallel/executor.cpp
index bb7560f3e81c..7a2b2c249b92 100644
--- a/src/parallel/executor.cpp
+++ b/src/parallel/executor.cpp
@@ -411,6 +411,7 @@ void Executor::BuildPipelines(PhysicalOperator *op, Pipeline *current) {
 		case PhysicalOperatorType::COPY_TO_FILE:
 		case PhysicalOperatorType::LIMIT:
 		case PhysicalOperatorType::EXPRESSION_SCAN:
+		case PhysicalOperatorType::EXPLAIN_ANALYZE:
 			D_ASSERT(op->children.size() == 1);
 			// single operator:
 			// the operator becomes the data source of the current pipeline
diff --git a/src/parser/statement/explain_statement.cpp b/src/parser/statement/explain_statement.cpp
index 6cf4383b36d8..6848b955382f 100644
--- a/src/parser/statement/explain_statement.cpp
+++ b/src/parser/statement/explain_statement.cpp
@@ -2,12 +2,12 @@
 
 namespace duckdb {
 
-ExplainStatement::ExplainStatement(unique_ptr<SQLStatement> stmt)
-    : SQLStatement(StatementType::EXPLAIN_STATEMENT), stmt(move(stmt)) {
+ExplainStatement::ExplainStatement(unique_ptr<SQLStatement> stmt, ExplainType explain_type)
+    : SQLStatement(StatementType::EXPLAIN_STATEMENT), stmt(move(stmt)), explain_type(explain_type) {
 }
 
 unique_ptr<SQLStatement> ExplainStatement::Copy() const {
-	auto result = make_unique<ExplainStatement>(stmt->Copy());
+	auto result = make_unique<ExplainStatement>(stmt->Copy(), explain_type);
 	return move(result);
 }
 
diff --git a/src/parser/transform/statement/transform_explain.cpp b/src/parser/transform/statement/transform_explain.cpp
index 2b212105c6ad..0d344b07655f 100644
--- a/src/parser/transform/statement/transform_explain.cpp
+++ b/src/parser/transform/statement/transform_explain.cpp
@@ -6,7 +6,19 @@ namespace duckdb {
 unique_ptr<ExplainStatement> Transformer::TransformExplain(duckdb_libpgquery::PGNode *node) {
 	auto stmt = reinterpret_cast<duckdb_libpgquery::PGExplainStmt *>(node);
 	D_ASSERT(stmt);
-	return make_unique<ExplainStatement>(TransformStatement(stmt->query));
+	auto explain_type = ExplainType::EXPLAIN_STANDARD;
+	if (stmt->options) {
+		for (auto n = stmt->options->head; n; n = n->next) {
+			auto def_elem = ((duckdb_libpgquery::PGDefElem *)n->data.ptr_value)->defname;
+			string elem(def_elem);
+			if (elem == "analyze") {
+				explain_type = ExplainType::EXPLAIN_ANALYZE;
+			} else {
+				throw NotImplementedException("Unimplemented explain type: %s", elem);
+			}
+		}
+	}
+	return make_unique<ExplainStatement>(TransformStatement(stmt->query), explain_type);
 }
 
 } // namespace duckdb
diff --git a/src/planner/binder/statement/bind_explain.cpp b/src/planner/binder/statement/bind_explain.cpp
index 17bf21cba304..2a06c5d34687 100644
--- a/src/planner/binder/statement/bind_explain.cpp
+++ b/src/planner/binder/statement/bind_explain.cpp
@@ -11,7 +11,7 @@ BoundStatement Binder::Bind(ExplainStatement &stmt) {
 	auto plan = Bind(*stmt.stmt);
 	// get the unoptimized logical plan, and create the explain statement
 	auto logical_plan_unopt = plan.plan->ToString();
-	auto explain = make_unique<LogicalExplain>(move(plan.plan));
+	auto explain = make_unique<LogicalExplain>(move(plan.plan), stmt.explain_type);
 	explain->logical_plan_unopt = logical_plan_unopt;
 
 	result.plan = move(explain);
