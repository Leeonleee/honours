diff --git a/test/issues/general/test_2407.test b/test/issues/general/test_2407.test
new file mode 100644
index 000000000000..8ebb08520de7
--- /dev/null
+++ b/test/issues/general/test_2407.test
@@ -0,0 +1,39 @@
+# name: test/issues/general/test_2407.test
+# description: Issue 2407: arg_max/arg_min doesn't work properly with DATE
+# group: [general]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE test(d DATE, i INTEGER);
+
+statement ok
+INSERT INTO test VALUES ('2021-01-01', 1), ('2021-02-01', 2), ('2021-03-01', 3), ('2021-04-01', 4);
+
+query II
+select arg_max(i, d), arg_max(d, i) from test;
+----
+4	2021-04-01
+
+query II
+select arg_min(i, d), arg_min(d, i) from test;
+----
+1	2021-01-01
+
+# bigint
+statement ok
+CREATE TABLE test2(d BIGINT, i INTEGER);
+
+statement ok
+INSERT INTO test2 VALUES (-9223372036854775807, 1), (-1, 2), (1, 3), (9223372036854775807, 4);
+
+query II
+select arg_max(i, d), arg_max(d, i) from test2;
+----
+4	9223372036854775807
+
+query II
+select arg_min(i, d), arg_min(d, i) from test2;
+----
+1	-9223372036854775807
diff --git a/test/issues/general/test_2416.test b/test/issues/general/test_2416.test
new file mode 100644
index 000000000000..46a8dcd3c13a
--- /dev/null
+++ b/test/issues/general/test_2416.test
@@ -0,0 +1,90 @@
+# name: test/issues/general/test_2416.test
+# description: Issue 2416: Segmentation fault on macro creation
+# group: [general]
+
+statement ok
+PRAGMA enable_verification
+
+query I
+select list_extract(null, null);
+----
+NULL
+
+query I
+select list_extract(null, 1);
+----
+NULL
+
+query I
+select list_extract([1, 2, 3], NULL);
+----
+NULL
+
+query I
+SELECT list_extract([1, 2, 3], 1)
+----
+2
+
+statement ok
+PREPARE v1 AS SELECT list_extract($1::int[], 1)
+
+query I
+EXECUTE v1([1, 2, 3])
+----
+2
+
+query I
+EXECUTE v1(NULL)
+----
+NULL
+
+statement ok
+PREPARE v2 AS SELECT list_extract([1, 2, 3], $1)
+
+query I
+EXECUTE v2(1)
+----
+2
+
+query I
+EXECUTE v2(NULL)
+----
+NULL
+
+statement ok
+create macro extract_field(my_struct, my_field) as my_struct[my_field];
+
+query I
+SELECT extract_field([1, 2, 3], 1)
+----
+2
+
+# the same but with array_length
+query I
+select array_length(null);
+----
+NULL
+
+statement ok
+PREPARE v3 AS SELECT array_length($1::int[])
+
+query I
+EXECUTE v3([1, 2, 3])
+----
+3
+
+query I
+EXECUTE v3(NULL)
+----
+NULL
+
+statement error
+PREPARE v4 AS SELECT array_length($1)
+
+statement ok
+create macro array_l(my_arr) as array_length(my_arr);
+
+query I
+SELECT array_l([1, 2, 3])
+----
+3
diff --git a/test/issues/monetdb/analytics10.test b/test/issues/monetdb/analytics10.test
new file mode 100644
index 000000000000..0f130fbdf4b1
--- /dev/null
+++ b/test/issues/monetdb/analytics10.test
@@ -0,0 +1,994 @@
+# name: test/issues/monetdb/analytics10.test
+# description: MonetDB Test for grouping sets
+# group: [monetdb]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE tbl_ProductSales (ColID int, Product_Category  varchar(64), Product_Name  varchar(64), TotalSales int)
+
+statement ok
+INSERT INTO tbl_ProductSales VALUES (1,'Game','Mobo Game',200),(2,'Game','PKO Game',400),(3,'Fashion','Shirt',500),(4,'Fashion','Shorts',100)
+
+query I rowsort
+SELECT CAST(SUM(TotalSales) as BIGINT) AS TotalSales FROM tbl_ProductSales
+----
+1200
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ()
+----
+1200
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY (), ()
+----
+1200
+
+statement error
+SELECT
+    *
+FROM tbl_ProductSales
+GROUP BY ()
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY Product_Category
+----
+600
+600
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY Product_Category, ()
+----
+600
+600
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY Product_Name
+----
+100
+200
+400
+500
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY Product_Category, Product_Name
+----
+100
+200
+400
+500
+
+statement error
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ROLLUP ()
+
+query TI rowsort
+SELECT
+    Product_Category, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category)
+----
+Fashion
+600
+Game
+600
+NULL
+1200
+
+query TI rowsort
+SELECT
+    Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Name)
+----
+Mobo Game
+200
+NULL
+1200
+PKO Game
+400
+Shirt
+500
+Shorts
+100
+
+query TTI rowsort
+SELECT
+    Product_Category, Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category, Product_Name)
+----
+Fashion
+NULL
+600
+Fashion
+Shirt
+500
+Fashion
+Shorts
+100
+Game
+Mobo Game
+200
+Game
+NULL
+600
+Game
+PKO Game
+400
+NULL
+NULL
+1200
+
+query TTI rowsort
+SELECT
+    Product_Category, Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category, Product_Name) HAVING SUM(TotalSales) > 400
+----
+Fashion
+NULL
+600
+Fashion
+Shirt
+500
+Game
+NULL
+600
+NULL
+NULL
+1200
+
+statement error
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY CUBE()
+
+query TI rowsort
+SELECT
+    Product_Category, CAST(SUM(TotalSales) as BIGINT) AS TotalSales FROM tbl_ProductSales
+GROUP BY CUBE(Product_Category)
+----
+Fashion
+600
+Game
+600
+NULL
+1200
+
+query TI rowsort
+SELECT
+    Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY CUBE(Product_Name)
+----
+Mobo Game
+200
+NULL
+1200
+PKO Game
+400
+Shirt
+500
+Shorts
+100
+
+query TTI rowsort
+SELECT
+    Product_Category, Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY CUBE(Product_Category, Product_Name)
+----
+Fashion
+NULL
+600
+Fashion
+Shirt
+500
+Fashion
+Shorts
+100
+Game
+Mobo Game
+200
+Game
+NULL
+600
+Game
+PKO Game
+400
+NULL
+Mobo Game
+200
+NULL
+NULL
+1200
+NULL
+PKO Game
+400
+NULL
+Shirt
+500
+NULL
+Shorts
+100
+
+query TTI rowsort
+SELECT
+    Product_Category, Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY CUBE(Product_Category, Product_Name) ORDER BY Product_Category, Product_Name
+----
+Fashion
+NULL
+600
+Fashion
+Shirt
+500
+Fashion
+Shorts
+100
+Game
+Mobo Game
+200
+Game
+NULL
+600
+Game
+PKO Game
+400
+NULL
+Mobo Game
+200
+NULL
+NULL
+1200
+NULL
+PKO Game
+400
+NULL
+Shirt
+500
+NULL
+Shorts
+100
+
+query II
+SELECT
+    Product_Category, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category), 1+1
+ORDER BY 1, 2
+----
+NULL	1200
+Fashion	600
+Game	600
+
+query TTI rowsort
+SELECT
+    Product_Category, Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ColID, ROLLUP(Product_Category, Product_Name)
+----
+Fashion
+NULL
+100
+Fashion
+NULL
+500
+Fashion
+Shirt
+500
+Fashion
+Shorts
+100
+Game
+Mobo Game
+200
+Game
+NULL
+200
+Game
+NULL
+400
+Game
+PKO Game
+400
+NULL
+NULL
+100
+NULL
+NULL
+200
+NULL
+NULL
+400
+NULL
+NULL
+500
+
+query TTI rowsort
+SELECT
+    Product_Category, Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY (ColID), ROLLUP(Product_Category, Product_Name)
+----
+Fashion
+NULL
+100
+Fashion
+NULL
+500
+Fashion
+Shirt
+500
+Fashion
+Shorts
+100
+Game
+Mobo Game
+200
+Game
+NULL
+200
+Game
+NULL
+400
+Game
+PKO Game
+400
+NULL
+NULL
+100
+NULL
+NULL
+200
+NULL
+NULL
+400
+NULL
+NULL
+500
+
+query TTI rowsort
+SELECT
+    Product_Category, Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY (ColID), CUBE(Product_Category, Product_Name)
+----
+Fashion
+NULL
+100
+Fashion
+NULL
+500
+Fashion
+Shirt
+500
+Fashion
+Shorts
+100
+Game
+Mobo Game
+200
+Game
+NULL
+200
+Game
+NULL
+400
+Game
+PKO Game
+400
+NULL
+Mobo Game
+200
+NULL
+NULL
+100
+NULL
+NULL
+200
+NULL
+NULL
+400
+NULL
+NULL
+500
+NULL
+PKO Game
+400
+NULL
+Shirt
+500
+NULL
+Shorts
+100
+
+query TI rowsort
+SELECT
+    Product_Category, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category), ROLLUP(Product_Category)
+----
+Fashion
+600
+Fashion
+600
+Fashion
+600
+Game
+600
+Game
+600
+Game
+600
+NULL
+1200
+
+query TI rowsort
+SELECT
+    Product_Category, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY CUBE(Product_Category), CUBE(Product_Category)
+----
+Fashion
+600
+Fashion
+600
+Fashion
+600
+Game
+600
+Game
+600
+Game
+600
+NULL
+1200
+
+query TTI rowsort
+SELECT
+    Product_Category, Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category, Product_Name), ROLLUP(Product_Category, Product_Name)
+----
+Fashion
+NULL
+600
+Fashion
+NULL
+600
+Fashion
+NULL
+600
+Fashion
+Shirt
+500
+Fashion
+Shirt
+500
+Fashion
+Shirt
+500
+Fashion
+Shirt
+500
+Fashion
+Shirt
+500
+Fashion
+Shorts
+100
+Fashion
+Shorts
+100
+Fashion
+Shorts
+100
+Fashion
+Shorts
+100
+Fashion
+Shorts
+100
+Game
+Mobo Game
+200
+Game
+Mobo Game
+200
+Game
+Mobo Game
+200
+Game
+Mobo Game
+200
+Game
+Mobo Game
+200
+Game
+NULL
+600
+Game
+NULL
+600
+Game
+NULL
+600
+Game
+PKO Game
+400
+Game
+PKO Game
+400
+Game
+PKO Game
+400
+Game
+PKO Game
+400
+Game
+PKO Game
+400
+NULL
+NULL
+1200
+
+query TTI rowsort
+SELECT
+    Product_Category, Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY CUBE(Product_Category, Product_Name), CUBE(Product_Category, Product_Name)
+----
+165 values hashing to 4830997d5df2eb81b7b9155f4902b4df
+
+query TTI rowsort
+SELECT
+    Product_Category, Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category, Product_Name), CUBE(Product_Category, Product_Name)
+----
+117 values hashing to 58a2e9e8748cc0488ecca1227621241f
+
+query TI rowsort
+SELECT
+    Product_Name, CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY CUBE((Product_Name))
+----
+Mobo Game
+200
+NULL
+1200
+PKO Game
+400
+Shirt
+500
+Shorts
+100
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY CUBE((Product_Category, Product_Name, ColID))
+----
+100
+1200
+200
+400
+500
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ROLLUP((Product_Category, Product_Name), ColID)
+----
+100
+100
+1200
+200
+200
+400
+400
+500
+500
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ROLLUP((Product_Category, Product_Name), ColID), ColID
+----
+100
+100
+100
+200
+200
+200
+400
+400
+400
+500
+500
+500
+
+query II rowsort
+SELECT
+    COUNT(*), CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY CUBE((Product_Category, Product_Name), ColID), ColID, ROLLUP((Product_Category, ColID), Product_Name)
+----
+1
+100
+1
+100
+1
+100
+1
+100
+1
+100
+1
+100
+1
+100
+1
+100
+1
+100
+1
+100
+1
+100
+1
+100
+1
+200
+1
+200
+1
+200
+1
+200
+1
+200
+1
+200
+1
+200
+1
+200
+1
+200
+1
+200
+1
+200
+1
+200
+1
+400
+1
+400
+1
+400
+1
+400
+1
+400
+1
+400
+1
+400
+1
+400
+1
+400
+1
+400
+1
+400
+1
+400
+1
+500
+1
+500
+1
+500
+1
+500
+1
+500
+1
+500
+1
+500
+1
+500
+1
+500
+1
+500
+1
+500
+1
+500
+
+query I rowsort
+SELECT
+    DISTINCT CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY CUBE((Product_Category, Product_Name), ColID), ColID, ROLLUP((Product_Category, ColID), Product_Name)
+----
+100
+200
+400
+500
+
+statement error
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS()
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS(())
+----
+1200
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS((Product_Category))
+----
+600
+600
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS((Product_Category, Product_Name), (ColID))
+----
+100
+100
+200
+200
+400
+400
+500
+500
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS((Product_Category), ())
+----
+1200
+600
+600
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS((Product_Category), (Product_Category))
+----
+600
+600
+600
+600
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ColID, GROUPING SETS ((Product_Name), (Product_Category))
+----
+100
+100
+200
+200
+400
+400
+500
+500
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ColID, CUBE (Product_Category, ColID), GROUPING SETS ((Product_Name), (Product_Category))
+----
+100
+100
+100
+100
+100
+100
+100
+100
+200
+200
+200
+200
+200
+200
+200
+200
+400
+400
+400
+400
+400
+400
+400
+400
+500
+500
+500
+500
+500
+500
+500
+500
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS(CUBE(Product_Category, Product_Name), ROLLUP(ColID, Product_Name))
+----
+100
+100
+100
+100
+1200
+1200
+200
+200
+200
+200
+400
+400
+400
+400
+500
+500
+500
+500
+600
+600
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ColID, GROUPING SETS (GROUPING SETS (()), (Product_Name), (Product_Category))
+----
+100
+100
+100
+200
+200
+200
+400
+400
+400
+500
+500
+500
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS (ROLLUP(ColID), (), GROUPING SETS ((Product_Category, Product_Name), CUBE(ColID), ColID))
+----
+100
+100
+100
+100
+1200
+1200
+1200
+200
+200
+200
+200
+400
+400
+400
+400
+500
+500
+500
+500
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales
+GROUP BY ColID, GROUPING SETS (GROUPING SETS (()), (Product_Name), (Product_Category)) LIMIT 1 OFFSET 2
+----
+500
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales GROUP BY ROLLUP (Product_Category, ColID)
+ORDER BY SUM(TotalSales)
+----
+100
+1200
+200
+400
+500
+600
+600
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales GROUP BY ROLLUP (Product_Category, ColID)
+HAVING SUM(TotalSales) > 600
+----
+1200
+
+query I rowsort
+SELECT
+    DISTINCT CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales GROUP BY ROLLUP (Product_Category, ColID)
+ORDER BY SUM(TotalSales)
+----
+100
+1200
+200
+400
+500
+600
+
+query I rowsort
+SELECT
+    CAST(SUM(TotalSales) as BIGINT) AS TotalSales
+FROM tbl_ProductSales GROUP BY ROLLUP (Product_Category, ColID)
+HAVING SUM(TotalSales) > 600
+ORDER BY AVG(TotalSales)
+----
+1200
+
+statement ok
+DROP TABLE tbl_ProductSales
+
diff --git a/test/issues/monetdb/analytics11.test b/test/issues/monetdb/analytics11.test
new file mode 100644
index 000000000000..a7c2a69f2cd8
--- /dev/null
+++ b/test/issues/monetdb/analytics11.test
@@ -0,0 +1,469 @@
+# name: test/issues/monetdb/analytics11.test
+# description: MonetDB Test for grouping sets
+# group: [monetdb]
+
+require vector_size 512
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE tbl_ProductSales (ColID int, Product_Category  varchar(64), Product_Name  varchar(64), TotalSales int)
+
+statement ok
+CREATE TABLE another_T (col1 INT, col2 INT, col3 INT, col4 INT, col5 INT, col6 INT, col7 INT, col8 INT)
+
+statement ok
+INSERT INTO tbl_ProductSales VALUES (1,'Game','Mobo Game',200),(2,'Game','PKO Game',400),(3,'Fashion','Shirt',500),(4,'Fashion','Shorts',100)
+
+statement ok
+INSERT INTO another_T VALUES (1,2,3,4,5,6,7,8), (11,22,33,44,55,66,77,88), (111,222,333,444,555,666,777,888), (1111,2222,3333,4444,5555,6666,7777,8888)
+
+query I rowsort
+SELECT 1
+FROM tbl_ProductSales
+GROUP BY Product_Category
+----
+1
+1
+
+query I rowsort
+SELECT 1
+FROM tbl_ProductSales
+GROUP BY ()
+----
+1
+
+statement error
+SELECT
+    GROUPING()
+FROM tbl_ProductSales
+GROUP BY Product_Category
+
+statement error
+SELECT
+    1
+FROM tbl_ProductSales
+GROUP BY GROUPING(Product_Name)
+
+statement error
+SELECT
+    1
+FROM tbl_ProductSales
+WHERE GROUPING(Product_Category) > 1
+GROUP BY GROUPING SETS((Product_Category))
+
+statement error
+SELECT
+    AVG(GROUPING(Product_Category))
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS((Product_Category))
+
+statement error
+SELECT
+    GROUPING(1)
+FROM tbl_ProductSales
+GROUP BY Product_Category
+
+statement error
+SELECT
+    col1 IN (SELECT ColID + col2 FROM tbl_ProductSales)
+FROM another_T
+GROUP BY ROLLUP(col1)
+
+statement error
+SELECT
+    (SELECT GROUPING(t1.col1) FROM tbl_ProductSales)
+FROM another_T t1
+
+statement error
+SELECT
+    GROUPING(Product_Name)
+FROM tbl_ProductSales
+
+statement error
+SELECT
+    GROUPING(Product_Name)
+FROM tbl_ProductSales GROUP BY ()
+
+query I rowsort
+SELECT
+    GROUPING(Product_Category) AS myalias
+FROM tbl_ProductSales
+GROUP BY Product_Category
+----
+0
+0
+
+query I rowsort
+SELECT
+    GROUPING(Product_Category) myalias
+FROM tbl_ProductSales
+GROUP BY Product_Category, Product_Name
+----
+0
+0
+0
+0
+
+query I rowsort
+SELECT
+    GROUPING(Product_Name, Product_Category)
+FROM tbl_ProductSales
+GROUP BY Product_Category, Product_Name
+----
+0
+0
+0
+0
+
+query I rowsort
+SELECT
+    GROUPING(Product_Category) AS myalias
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category)
+----
+0
+0
+1
+
+query I rowsort
+SELECT
+    GROUPING(Product_Category) AS myalias
+FROM tbl_ProductSales
+GROUP BY Product_Category, ROLLUP(Product_Category)
+----
+0
+0
+0
+0
+
+query I rowsort
+SELECT
+    GROUPING(Product_Category, Product_Name, ColID)
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category, Product_Name, ColID)
+----
+0
+0
+0
+0
+1
+1
+1
+1
+3
+3
+7
+
+query I rowsort
+SELECT
+    GROUPING(Product_Category, Product_Name, ColID)
+FROM tbl_ProductSales
+GROUP BY ROLLUP((Product_Category, Product_Name, ColID))
+----
+0
+0
+0
+0
+7
+
+query I rowsort
+SELECT
+    GROUPING(Product_Category, ColID)
+FROM tbl_ProductSales
+GROUP BY ROLLUP((Product_Category, Product_Name, ColID))
+----
+0
+0
+0
+0
+3
+
+query I rowsort
+SELECT
+    GROUPING(Product_Category, ColID)
+FROM tbl_ProductSales
+GROUP BY CUBE((Product_Category, Product_Name, ColID))
+----
+0
+0
+0
+0
+3
+
+query I rowsort
+SELECT
+    GROUPING(Product_Category)
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS((Product_Category), (Product_Name), (Product_Category, Product_Name), ())
+ORDER BY GROUPING(Product_Category)
+----
+0
+0
+0
+0
+0
+0
+1
+1
+1
+1
+1
+
+query I rowsort
+SELECT
+    GROUPING(Product_Category)
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS((Product_Category), (Product_Name), (Product_Category, Product_Name), ())
+HAVING GROUPING(Product_Category) = 0
+----
+0
+0
+0
+0
+0
+0
+
+query II rowsort
+SELECT
+    GROUPING(Product_Category, Product_Name, ColID), GROUPING(Product_Name, ColID)
+FROM tbl_ProductSales
+GROUP BY CUBE((Product_Category, Product_Name, ColID))
+ORDER BY GROUPING(Product_Category, ColID)
+----
+0
+0
+0
+0
+0
+0
+0
+0
+7
+3
+
+query I rowsort
+SELECT
+    GROUPING(Product_Category, Product_Name, ColID) + 1
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category, Product_Name, ColID)
+HAVING GROUPING(Product_Category, Product_Name, ColID) <> 3
+ORDER BY GROUPING(Product_Category, Product_Name, ColID) DESC
+----
+1
+1
+1
+1
+2
+2
+2
+2
+8
+
+query IR rowsort
+SELECT
+    GROUPING(Product_Category), AVG(SUM(TotalSales)) OVER (ROWS UNBOUNDED PRECEDING)
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS((Product_Category), (Product_Name), (Product_Category, Product_Name), ())
+----
+0
+360.000
+0
+371.429
+0
+375.000
+0
+388.889
+0
+600.000
+0
+600.000
+1
+400.000
+1
+436.364
+1
+450.000
+1
+460.000
+1
+466.667
+
+query II rowsort
+SELECT
+    GROUPING(Product_Category), RANK() OVER (PARTITION BY SUM(TotalSales))
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS((Product_Category), (Product_Name), (Product_Category, Product_Name), ())
+----
+0
+1
+0
+1
+0
+1
+0
+1
+0
+1
+0
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+
+query I rowsort
+SELECT
+    CASE WHEN GROUPING(Product_Category, Product_Name, ColID) * 10 = 30 THEN 2 ELSE NULL END
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category, Product_Name, ColID)
+----
+2
+2
+NULL
+NULL
+NULL
+NULL
+NULL
+NULL
+NULL
+NULL
+NULL
+
+query II
+SELECT
+    GROUPING(Product_Category, Product_Name), SUM(TotalSales)
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS((Product_Category), (Product_Name), (Product_Category, Product_Name), ())
+ORDER BY 1, 2
+----
+0	100
+0	200
+0	400
+0	500
+1	600
+1	600
+2	100
+2	200
+2	400
+2	500
+3	1200
+
+query IIII rowsort
+SELECT
+    GROUPING(Product_Category),
+    CAST(SUM(SUM(TotalSales)) OVER (RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS BIGINT),
+    CAST(SUM(GROUPING(Product_Category, Product_Name)) OVER (RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS BIGINT),
+    RANK() OVER (PARTITION BY SUM(ColID))
+FROM tbl_ProductSales
+GROUP BY GROUPING SETS((Product_Category), (Product_Name), (Product_Category, Product_Name), ())
+----
+0
+4800
+13
+1
+0
+4800
+13
+1
+0
+4800
+13
+1
+0
+4800
+13
+1
+0
+4800
+13
+1
+0
+4800
+13
+1
+1
+4800
+13
+1
+1
+4800
+13
+1
+1
+4800
+13
+1
+1
+4800
+13
+1
+1
+4800
+13
+1
+
+statement ok
+CREATE TABLE tbl_X (ColID int, NItems int)
+
+statement ok
+INSERT INTO tbl_X VALUES (1,1000),(2,500),(3,323),(4,0)
+
+query II rowsort
+SELECT myalias, COUNT(*) FROM
+(
+    SELECT
+        GROUPING(tbl_ProductSales.ColID, tbl_X.ColID) AS myalias
+    FROM tbl_ProductSales
+    INNER JOIN tbl_X
+    ON tbl_ProductSales.ColID = tbl_X.ColID
+    WHERE tbl_X.NItems < 1000
+    GROUP BY CUBE(tbl_ProductSales.Product_Category, tbl_ProductSales.Product_Name, tbl_ProductSales.ColID), ROLLUP(tbl_X.ColID, tbl_X.NItems)
+) AS SubTables GROUP BY myalias ORDER BY myalias
+----
+0
+24
+1
+12
+2
+24
+3
+9
+
+statement error
+SELECT
+    GROUPING(ColID, ColID)
+FROM tbl_ProductSales
+INNER JOIN tbl_X
+ON tbl_ProductSales.ColID = tbl_X.ColID
+GROUP BY CUBE(tbl_ProductSales.Product_Category)
+
+query I rowsort
+SELECT
+    GROUPING(tbl_ProductSales.ColID, tbl_X.ColID) AS myalias
+FROM tbl_ProductSales
+INNER JOIN tbl_X
+ON tbl_ProductSales.ColID = tbl_X.ColID
+WHERE tbl_X.NItems < 1000
+GROUP BY CUBE(Product_Category, Product_Name, tbl_ProductSales.ColID), ROLLUP(tbl_X.ColID, tbl_X.NItems)
+ORDER BY SUM(TotalSales) DESC
+LIMIT 1
+----
+3
+
+statement ok
+DROP TABLE tbl_ProductSales
+
+statement ok
+DROP TABLE tbl_X
+
+statement ok
+DROP TABLE another_T
+
diff --git a/test/issues/monetdb/analytics12.test b/test/issues/monetdb/analytics12.test
new file mode 100644
index 000000000000..c11f8ec46888
--- /dev/null
+++ b/test/issues/monetdb/analytics12.test
@@ -0,0 +1,179 @@
+# name: test/issues/monetdb/analytics12.test
+# description: MonetDB Test for grouping sets
+# group: [monetdb]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+START TRANSACTION
+
+statement ok
+CREATE TABLE tbl_ProductSales (ColID int, Product_Category  varchar(64), Product_Name  varchar(64), TotalSales int);
+
+statement ok
+INSERT INTO tbl_ProductSales VALUES (1,'Game','Mobo Game',200),(2,'Game','PKO Game',400),(3,'Fashion','Shirt',500),(4,'Fashion','Shorts',100);
+
+query IIII rowsort
+SELECT
+    GROUPING(Product_Category, Product_Name, ColID), GROUPING(ColID, Product_Category, Product_Name),
+    GROUPING(Product_Category, Product_Name), GROUPING(Product_Name, Product_Category)
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category, Product_Name, ColID)
+----
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+1
+4
+0
+0
+1
+4
+0
+0
+1
+4
+0
+0
+1
+4
+0
+0
+3
+5
+1
+2
+3
+5
+1
+2
+7
+7
+3
+3
+
+query IIIII rowsort
+SELECT
+    GROUPING(Product_Name, Product_Name),
+    GROUPING(Product_Category, ColID),
+    GROUPING(ColID, Product_Category),
+    GROUPING(Product_Category) + GROUPING(Product_Category, Product_Name) + GROUPING(Product_Category, Product_Name, ColID),
+    CAST(SUM(ColID) AS BIGINT)
+FROM tbl_ProductSales
+GROUP BY ROLLUP(Product_Category, Product_Name, ColID)
+----
+0
+0
+0
+0
+1
+0
+0
+0
+0
+2
+0
+0
+0
+0
+3
+0
+0
+0
+0
+4
+0
+1
+2
+1
+1
+0
+1
+2
+1
+2
+0
+1
+2
+1
+3
+0
+1
+2
+1
+4
+3
+1
+2
+4
+3
+3
+1
+2
+4
+7
+3
+3
+3
+11
+10
+
+query IIII
+WITH "groupings" AS (
+    SELECT
+        GROUPING(Product_Category, Product_Name, ColID) AS col1, GROUPING(ColID, Product_Category, Product_Name) AS col2,
+        GROUPING(Product_Category, Product_Name) col3, GROUPING(Product_Name, Product_Category) "col4"
+    FROM tbl_ProductSales
+    GROUP BY GROUPING SETS ( Product_Category, (Product_Name), ColID,
+                            ROLLUP (Product_Category, ColID),
+                            CUBE (Product_Name, Product_Category),
+                            () )
+) SELECT col1, col2, col3, col4 FROM "groupings" ORDER BY col1 NULLS FIRST, col2 NULLS FIRST, col3 NULLS FIRST, col4 NULLS FIRST
+----
+1	4	0	0
+1	4	0	0
+1	4	0	0
+1	4	0	0
+2	1	1	2
+2	1	1	2
+2	1	1	2
+2	1	1	2
+3	5	1	2
+3	5	1	2
+3	5	1	2
+3	5	1	2
+3	5	1	2
+3	5	1	2
+5	6	2	1
+5	6	2	1
+5	6	2	1
+5	6	2	1
+5	6	2	1
+5	6	2	1
+5	6	2	1
+5	6	2	1
+6	3	3	3
+6	3	3	3
+6	3	3	3
+6	3	3	3
+7	7	3	3
+7	7	3	3
+7	7	3	3
+
+statement ok
+ROLLBACK
+
diff --git a/test/issues/monetdb/analytics13.test b/test/issues/monetdb/analytics13.test
new file mode 100644
index 000000000000..71189543ef77
--- /dev/null
+++ b/test/issues/monetdb/analytics13.test
@@ -0,0 +1,485 @@
+# name: test/issues/monetdb/analytics13.test
+# description: MonetDB Test for grouping sets
+# group: [monetdb]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE tbl_ProductSales (ColID int, Product_Category  varchar(64), Product_Name  varchar(64), TotalSales int);
+
+statement ok
+CREATE TABLE another_T (col1 INT, col2 INT, col3 INT, col4 INT, col5 INT, col6 INT, col7 INT, col8 INT);
+
+statement ok
+INSERT INTO tbl_ProductSales VALUES (1,'Game','Mobo Game',200),(2,'Game','PKO Game',400),(3,'Fashion','Shirt',500),(4,'Fashion','Shorts',100);
+
+statement ok
+INSERT INTO another_T VALUES (1,2,3,4,5,6,7,8), (11,22,33,44,55,66,77,88), (111,222,333,444,555,666,777,888), (1111,2222,3333,4444,5555,6666,7777,8888);
+
+statement error
+SELECT
+    (SELECT GROUPING(colID) FROM tbl_ProductSales)
+FROM another_T t1
+
+query I rowsort
+SELECT
+    col1 IN (SELECT ColID FROM tbl_ProductSales)
+FROM another_T
+GROUP BY ROLLUP(col1)
+----
+0
+0
+0
+1
+NULL
+
+query I rowsort
+SELECT
+    col1 IN (SELECT ColID + col1 FROM tbl_ProductSales)
+FROM another_T
+GROUP BY ROLLUP(col1)
+----
+0
+0
+0
+0
+NULL
+
+query I rowsort
+SELECT
+    col1 IN (SELECT SUM(ColID + col1) FROM tbl_ProductSales)
+FROM another_T
+GROUP BY ROLLUP(col1)
+----
+0
+0
+0
+0
+NULL
+
+query I rowsort
+SELECT
+    col3 > ALL (SELECT 1 FROM tbl_ProductSales HAVING MIN(col4) > 30)
+FROM another_T
+GROUP BY ROLLUP(col3, col4)
+----
+1
+1
+1
+1
+1
+1
+1
+1
+1
+
+query I rowsort
+SELECT
+    col1 = ALL (SELECT 1 FROM tbl_ProductSales HAVING MIN(col2) IS NULL)
+FROM another_T
+GROUP BY CUBE(col1, col2)
+----
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+
+query I rowsort
+SELECT
+    SUM(col1) IN (SELECT DISTINCT col2 FROM another_T GROUP BY col2)
+FROM another_T
+GROUP BY CUBE(col4)
+----
+0
+0
+0
+0
+0
+
+query I rowsort
+SELECT
+    1 IN (SELECT 1 FROM tbl_ProductSales GROUP BY CUBE(t1.col1, tbl_ProductSales.ColID))
+FROM another_T t1
+----
+1
+1
+1
+1
+
+query I rowsort
+SELECT
+    t1.col1 IN (SELECT ColID FROM tbl_ProductSales GROUP BY CUBE(t1.col1, tbl_ProductSales.ColID))
+FROM another_T t1
+GROUP BY CUBE(col1, col2)
+----
+1
+1
+NULL
+NULL
+NULL
+NULL
+NULL
+NULL
+NULL
+NULL
+NULL
+NULL
+NULL
+
+query IIIIIII rowsort
+SELECT
+    NOT GROUPING(t1.col6) IN (SELECT SUM(t1.col6) FROM tbl_ProductSales tp HAVING MAX(t1.col1) > MIN(tp.colID)),
+    GROUPING(t1.col6) IN (SELECT SUM(t1.col7) HAVING GROUPING(t1.col7) < SUM(t1.col4)),
+    GROUPING(t1.col6) = ALL (SELECT 1),
+    GROUPING(t1.col6) = ALL (SELECT SUM(t1.col7)),
+    SUM(t1.col6) = ALL (SELECT GROUPING(t1.col7)),
+    GROUPING(t1.col6) = ALL (SELECT GROUPING(t1.col7)),
+    GROUPING(t1.col6) = ALL (SELECT GROUPING(t1.col7) FROM tbl_ProductSales)
+FROM another_T t1
+GROUP BY CUBE(t1.col6, t1.col7)
+----
+1
+0
+0
+0
+0
+0
+0
+1
+0
+0
+0
+0
+0
+0
+1
+0
+0
+0
+0
+0
+0
+1
+0
+0
+0
+0
+0
+0
+1
+0
+0
+0
+0
+1
+1
+1
+0
+0
+0
+0
+1
+1
+1
+0
+0
+0
+0
+1
+1
+1
+0
+0
+0
+0
+1
+1
+1
+0
+1
+0
+0
+0
+0
+1
+0
+1
+0
+0
+0
+0
+1
+0
+1
+0
+0
+0
+0
+1
+0
+1
+0
+0
+0
+0
+1
+0
+1
+0
+0
+1
+1
+
+query IIIIIII rowsort
+SELECT
+    DISTINCT
+    NOT GROUPING(t1.col6) IN (SELECT SUM(t1.col6) FROM tbl_ProductSales tp HAVING MAX(t1.col1) > MIN(tp.colID)),
+    GROUPING(t1.col6) IN (SELECT SUM(t1.col7) HAVING GROUPING(t1.col7) < SUM(t1.col4)),
+    GROUPING(t1.col6) = ALL (SELECT 1),
+    GROUPING(t1.col6) = ALL (SELECT SUM(t1.col7)),
+    SUM(t1.col6) = ALL (SELECT GROUPING(t1.col7)),
+    GROUPING(t1.col6) = ALL (SELECT GROUPING(t1.col7)),
+    GROUPING(t1.col6) = ALL (SELECT GROUPING(t1.col7) FROM tbl_ProductSales)
+FROM another_T t1
+GROUP BY CUBE(t1.col6, t1.col7)
+----
+1
+0
+0
+0
+0
+0
+0
+1
+0
+0
+0
+0
+1
+1
+1
+0
+1
+0
+0
+0
+0
+1
+0
+1
+0
+0
+1
+1
+
+query IIIII rowsort
+SELECT
+    NOT col1 * col5 = ALL (SELECT 1 FROM tbl_ProductSales HAVING MAX(col2) > 2),
+    NOT AVG(col2) * col1 <> ANY (SELECT 20 FROM tbl_ProductSales HAVING MAX(col1) IS NULL),
+    NOT EXISTS (SELECT ColID - 12 FROM tbl_ProductSales GROUP BY ColID HAVING MAX(col1) IS NOT NULL OR MIN(col1) < MIN(col2)),
+    CAST (NOT col1 IN (SELECT col2 FROM another_T GROUP BY col2) AS INTEGER) | CAST (col2 IN (SELECT col2 FROM another_T GROUP BY col2) AS INTEGER),
+    CAST (EXISTS (SELECT MAX(col5) * MAX(col4) FROM another_T GROUP BY col5, col4) AS INTEGER) & CAST (GROUPING(col1, col5) IN (SELECT DISTINCT col2 FROM another_T GROUP BY col2) AS INTEGER)
+FROM another_T
+GROUP BY CUBE(col1, col2, col5)
+----
+145 values hashing to 2180373d9debdb69ad704a767deb2e0a
+
+query IIIII rowsort
+SELECT
+    NOT col1 * col5 = ALL (SELECT 1 FROM tbl_ProductSales HAVING MAX(col2) > 2) AS a1,
+    NOT AVG(col2) * col1 <> ANY (SELECT 20 FROM tbl_ProductSales HAVING MAX(col1) IS NULL) AS a2,
+    NOT EXISTS (SELECT ColID - 12 FROM tbl_ProductSales GROUP BY ColID HAVING MAX(col1) IS NOT NULL OR MIN(col1) < MIN(col2)) AS a3,
+    CAST (NOT col1 IN (SELECT col2 FROM another_T GROUP BY col2) AS INTEGER) | CAST (col2 IN (SELECT col2 FROM another_T GROUP BY col2) AS INTEGER) AS a4,
+    CAST (EXISTS (SELECT MAX(col5) * MAX(col4) FROM another_T GROUP BY col5, col4) AS INTEGER) & CAST (GROUPING(col1, col5) IN (SELECT DISTINCT col2 FROM another_T GROUP BY col2) AS INTEGER) AS a5
+FROM another_T
+GROUP BY CUBE(col1, col2, col5)
+ORDER BY a1 NULLS FIRST, a2 NULLS FIRST, a3 NULLS FIRST, a4 NULLS FIRST, a5 NULLS FIRST
+----
+145 values hashing to 2180373d9debdb69ad704a767deb2e0a
+
+query IRIIIIII
+SELECT
+    GROUPING(col1, col2, col3, col4, col5, col6, col7, col8), AVG(col1), CAST(SUM(col2) * 3 AS BIGINT), col3 + col4,
+    CAST(MAX(col5) * MIN(col6) AS BIGINT), col7, col1 IN (SELECT ColID FROM tbl_ProductSales), col2 IN (SELECT ColID + col3 FROM tbl_ProductSales)
+FROM another_T
+GROUP BY ROLLUP(col1, col2, col3, col4, col5, col6, col7, col8)
+ORDER BY GROUPING(col1, col2, col3, col4, col5, col6, col7, col8), 2, 3, 4
+----
+0	1.00000000000000000000	6	7	30	7	True	False
+0	11.0000000000000000	66	77	3630	77	False	False
+0	111.0000000000000000	666	777	369630	777	False	False
+0	1111.0000000000000000	6666	7777	37029630	7777	False	False
+1	1.00000000000000000000	6	7	30	7	True	False
+1	11.0000000000000000	66	77	3630	77	False	False
+1	111.0000000000000000	666	777	369630	777	False	False
+1	1111.0000000000000000	6666	7777	37029630	7777	False	False
+3	1.00000000000000000000	6	7	30	NULL	True	False
+3	11.0000000000000000	66	77	3630	NULL	False	False
+3	111.0000000000000000	666	777	369630	NULL	False	False
+3	1111.0000000000000000	6666	7777	37029630	NULL	False	False
+7	1.00000000000000000000	6	7	30	NULL	True	False
+7	11.0000000000000000	66	77	3630	NULL	False	False
+7	111.0000000000000000	666	777	369630	NULL	False	False
+7	1111.0000000000000000	6666	7777	37029630	NULL	False	False
+15	1.00000000000000000000	6	7	30	NULL	True	False
+15	11.0000000000000000	66	77	3630	NULL	False	False
+15	111.0000000000000000	666	777	369630	NULL	False	False
+15	1111.0000000000000000	6666	7777	37029630	NULL	False	False
+31	1.00000000000000000000	6	NULL	30	NULL	True	False
+31	11.0000000000000000	66	NULL	3630	NULL	False	False
+31	111.0000000000000000	666	NULL	369630	NULL	False	False
+31	1111.0000000000000000	6666	NULL	37029630	NULL	False	False
+63	1.00000000000000000000	6	NULL	30	NULL	True	NULL
+63	11.0000000000000000	66	NULL	3630	NULL	False	NULL
+63	111.0000000000000000	666	NULL	369630	NULL	False	NULL
+63	1111.0000000000000000	6666	NULL	37029630	NULL	False	NULL
+127	1.00000000000000000000	6	NULL	30	NULL	True	NULL
+127	11.0000000000000000	66	NULL	3630	NULL	False	NULL
+127	111.0000000000000000	666	NULL	369630	NULL	False	NULL
+127	1111.0000000000000000	6666	NULL	37029630	NULL	False	NULL
+255	308.5000000000000000	7404	NULL	33330	NULL	NULL	NULL
+
+query I rowsort
+SELECT
+    DISTINCT
+    NOT col1 IN (SELECT col2 FROM another_T GROUP BY col2)
+FROM another_T
+GROUP BY ROLLUP(col1)
+----
+1
+NULL
+
+query IIIII rowsort
+SELECT
+    DISTINCT
+    NOT col1 * col5 = ALL (SELECT 1 FROM tbl_ProductSales HAVING MAX(col2) > 2),
+    NOT AVG(col2) * col1 <> ANY (SELECT 20 FROM tbl_ProductSales HAVING MAX(col1) IS NULL),
+    NOT EXISTS (SELECT ColID - 12 FROM tbl_ProductSales GROUP BY ColID HAVING MAX(col1) IS NOT NULL OR MIN(col1) < MIN(col2)),
+    CAST (NOT col1 IN (SELECT col2 FROM another_T GROUP BY col2) AS INTEGER) | CAST (col2 IN (SELECT col2 FROM another_T GROUP BY col2) AS INTEGER),
+    CAST (EXISTS (SELECT MAX(col5) * MAX(col4) FROM another_T GROUP BY col5, col4) AS INTEGER) & CAST (GROUPING(col1, col5) IN (SELECT DISTINCT col2 FROM another_T GROUP BY col2) AS INTEGER)
+FROM another_T
+GROUP BY CUBE(col1, col2, col5)
+----
+0
+1
+0
+1
+0
+0
+1
+0
+NULL
+0
+0
+1
+0
+NULL
+1
+1
+1
+0
+1
+0
+1
+1
+0
+NULL
+0
+NULL
+1
+0
+1
+0
+NULL
+1
+0
+NULL
+0
+NULL
+1
+0
+NULL
+1
+
+query IIIII rowsort
+SELECT
+    DISTINCT
+    NOT col1 * col5 = ALL (SELECT 1 FROM tbl_ProductSales HAVING MAX(col2) > 2) AS a1,
+    NOT AVG(col2) * col1 <> ANY (SELECT 20 FROM tbl_ProductSales HAVING MAX(col1) IS NULL) AS a2,
+    NOT EXISTS (SELECT ColID - 12 FROM tbl_ProductSales GROUP BY ColID HAVING MAX(col1) IS NOT NULL OR MIN(col1) < MIN(col2)) AS a3,
+    CAST (NOT col1 IN (SELECT col2 FROM another_T GROUP BY col2) AS INTEGER) | CAST (col2 IN (SELECT col2 FROM another_T GROUP BY col2) AS INTEGER) AS a4,
+    CAST (EXISTS (SELECT MAX(col5) * MAX(col4) FROM another_T GROUP BY col5, col4) AS INTEGER) & CAST (GROUPING(col1, col5) IN (SELECT DISTINCT col2 FROM another_T GROUP BY col2) AS INTEGER) AS a5
+FROM another_T
+GROUP BY CUBE(col1, col2, col5)
+ORDER BY a1 NULLS FIRST, a2 NULLS FIRST, a3 NULLS FIRST, a4 NULLS FIRST, a5 NULLS FIRST
+----
+0
+1
+0
+1
+0
+0
+1
+0
+NULL
+0
+0
+1
+0
+NULL
+1
+1
+1
+0
+1
+0
+1
+1
+0
+NULL
+0
+NULL
+1
+0
+1
+0
+NULL
+1
+0
+NULL
+0
+NULL
+1
+0
+NULL
+1
+
+query I rowsort
+SELECT
+    NOT GROUPING(t1.col2, t1.col4) <> ALL (SELECT t1.col2 FROM tbl_ProductSales tp WHERE tp.colID = 1) a1
+FROM another_T t1
+GROUP BY ROLLUP(t1.col1, t1.col2), GROUPING SETS ((t1.col4))
+HAVING (t1.col1 = ANY (SELECT MAX(ColID + col2) FROM tbl_ProductSales)) NOT IN
+    ((SELECT NOT EXISTS (SELECT t1.col2 FROM tbl_ProductSales WHERE tbl_ProductSales.ColID = t1.col1)) UNION ALL
+     (SELECT NOT GROUPING(t1.col1) BETWEEN (SELECT MAX(t1.col7) EXCEPT SELECT tp.ColID FROM tbl_ProductSales tp) AND (SELECT MIN(t1.col5) EXCEPT SELECT t1.col2)))
+ORDER BY a1 DESC NULLS FIRST
+----
+0
+0
+0
+
+statement ok
+DROP TABLE tbl_ProductSales
+
+statement ok
+DROP TABLE another_T
diff --git a/test/issues/monetdb/groupings.test b/test/issues/monetdb/groupings.test
new file mode 100644
index 000000000000..998767754db1
--- /dev/null
+++ b/test/issues/monetdb/groupings.test
@@ -0,0 +1,165 @@
+# name: test/issues/monetdb/groupings.test
+# description: MonetDB Test for grouping sets
+# group: [monetdb]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+START TRANSACTION
+
+statement ok
+CREATE TABLE categories (id INTEGER, "description" TEXT)
+
+statement ok
+CREATE TABLE sections (id INTEGER, "description" TEXT)
+
+statement ok
+CREATE TABLE products (id INTEGER, categoryid int, sectionid INTEGER, "description" TEXT, price DECIMAL(6,2))
+
+statement ok
+CREATE TABLE sales (productid INTEGER, sale_day DATE, units INTEGER)
+
+statement ok
+INSERT INTO categories VALUES (1, 'fresh food'), (2, 'dry food'), (3, 'drinks')
+
+statement ok
+INSERT INTO sections VALUES (1, 'front'), (2, 'side'), (3, 'back')
+
+statement ok
+INSERT INTO products VALUES (1, 1, 1, 'apples', 1.5), (2, 1, 2, 'melons', 4.0), (3, 2, 2, 'peanuts', 2.0), (4, 3, 1, 'water', 1.0), (5, 3, 3, 'wine', 5.0), (6, 2, 3, 'walnuts', 1.5)
+
+statement ok
+INSERT INTO sales VALUES (1, date '2020-03-01', 10), (2, date '2020-03-01', 3), (4, date '2020-03-01', 4), (1, date '2020-03-02', 6), (4, date '2020-03-02', 5), (5, date '2020-03-02', 2), (1, date '2020-03-03', 7), (3, date '2020-03-03', 4), (2, date '2020-03-03', 3), (5, date '2020-03-03', 1), (6, date '2020-03-03', 1)
+
+query TTR rowsort
+SELECT COALESCE(products."description", 'all_products') AS "description",
+       COALESCE(sale_day, 'all_days') AS sale_day,
+       CAST(totals.total AS DECIMAL (12,4))
+FROM (
+    SELECT productid, sale_day, SUM(units * price) AS total
+    FROM products
+    LEFT JOIN sales ON sales.productid = products.id
+    GROUP BY ROLLUP(productid, sale_day)
+) AS totals
+LEFT JOIN products ON products.id = totals.productid
+ORDER BY sale_day NULLS LAST, productid NULLS LAST
+----
+all_products
+all_days
+92.000
+apples
+2020-03-01
+15.000
+apples
+2020-03-02
+9.000
+apples
+2020-03-03
+10.500
+apples
+all_days
+34.500
+melons
+2020-03-01
+12.000
+melons
+2020-03-03
+12.000
+melons
+all_days
+24.000
+peanuts
+2020-03-03
+8.000
+peanuts
+all_days
+8.000
+walnuts
+2020-03-03
+1.500
+walnuts
+all_days
+1.500
+water
+2020-03-01
+4.000
+water
+2020-03-02
+5.000
+water
+all_days
+9.000
+wine
+2020-03-02
+10.000
+wine
+2020-03-03
+5.000
+wine
+all_days
+15.000
+
+query TTR rowsort
+SELECT COALESCE(sections."description", 'all_sections') AS section,
+       COALESCE(categories."description", 'all_categories') AS category,
+       CAST(totals.total AS DECIMAL (12,4))
+FROM (
+    SELECT categoryid, sectionid, SUM(units * price) AS total
+    FROM products
+    LEFT JOIN sales ON sales.productid = products.id
+    GROUP BY GROUPING SETS ((categoryid), (sectionid), ())
+) AS totals
+LEFT JOIN categories ON totals.categoryid = categories.id
+LEFT JOIN sections ON totals.sectionid = sections.id
+----
+all_sections
+all_categories
+92.000
+all_sections
+drinks
+24.000
+all_sections
+dry food
+9.500
+all_sections
+fresh food
+58.500
+back
+all_categories
+16.500
+front
+all_categories
+43.500
+side
+all_categories
+32.000
+
+statement ok
+CREATE VIEW sales_totals AS
+    SELECT GROUPING(categoryid) AS category_aggregates,
+           GROUPING(sectionid) AS section_aggregates,
+           categoryid, sectionid, SUM(units * price) AS total
+    FROM products
+    LEFT JOIN sales ON sales.productid = products.id
+    GROUP BY GROUPING SETS ((categoryid), (sectionid), ())
+
+query TR rowsort
+SELECT "description", CAST(total AS DECIMAL (12,4))
+FROM sales_totals
+LEFT JOIN categories ON sales_totals.categoryid = categories.id
+WHERE category_aggregates = 0
+----
+drinks
+24.000
+dry food
+9.500
+fresh food
+58.500
+
+statement error
+SELECT * FROM categories GROUP BY ()
+
+statement ok
+ROLLBACK
+
diff --git a/test/sql/aggregate/aggregates/test_quantile_disc.test b/test/sql/aggregate/aggregates/test_quantile_disc.test
index 1d2022f8364d..752d590f2f34 100644
--- a/test/sql/aggregate/aggregates/test_quantile_disc.test
+++ b/test/sql/aggregate/aggregates/test_quantile_disc.test
@@ -70,7 +70,47 @@ FROM range(0,100) tbl(d)
 
 endloop
 
-# multiple groups
+#
+# VARCHAR. Remember, this is dictionary ordering, not numeric ordering!
+#
+query III
+SELECT quantile_disc(d::VARCHAR, 0.1), quantile_disc(d::VARCHAR, 0.5), quantile_disc(d::VARCHAR, 0.9)
+FROM range(0,100) tbl(d)
+----
+17	53	9
+
+# A string column that has only NULL values
+query I
+SELECT quantile_disc(NULL::VARCHAR, 0.1)
+FROM range(0,100) tbl(d)
+----
+NULL
+
+# A string column that has long strings (>12 characters)
+query I
+SELECT quantile_disc('prefix-' || d::VARCHAR || '-suffix', 0.1)
+FROM range(0,100) tbl(d)
+----
+prefix-17-suffix
+
+# Using median itself on a string (just an alias for quantile_disc)
+query I
+SELECT median(d::VARCHAR)
+FROM range(0,100) tbl(d)
+----
+53
+
+# Median on an empty table
+query I
+SELECT median(d::VARCHAR)
+FROM range(0,100) tbl(d)
+WHERE d > 100
+----
+NULL
+
+#
+# Multiple groups
+#
 query II
 SELECT mod(r,10) as g, quantile_disc(r, 0.1) FROM quantile GROUP BY 1 ORDER BY 1
 ----
@@ -107,7 +147,6 @@ SELECT quantile_disc(interval (r) second, 0.5) FROM quantile
 ----
 01:23:19
 
-
 # constant input
 query I
 SELECT quantile_disc(1, 0.1) FROM quantile
@@ -133,9 +172,6 @@ SELECT quantile_disc(r, "string") FROM quantile
 statement error
 SELECT quantile_disc(r, NULL) FROM quantile
 
-statement error
-SELECT quantile_disc(r::string, 0.5) FROM quantile
-
 statement error
 SELECT quantile_disc(r) FROM quantile
 
diff --git a/test/sql/aggregate/aggregates/test_quantile_disc_list.test b/test/sql/aggregate/aggregates/test_quantile_disc_list.test
index 3e39f18a0536..53c0c6fc8759 100644
--- a/test/sql/aggregate/aggregates/test_quantile_disc_list.test
+++ b/test/sql/aggregate/aggregates/test_quantile_disc_list.test
@@ -25,6 +25,13 @@ FROM range(0,100) tbl(d)
 
 endloop
 
+# VARCHAR. Remember, this is dictionary ordering, not numeric ordering!
+query I
+SELECT quantile_disc(d::VARCHAR, [0.1, 0.5, 0.9])
+FROM range(0,100) tbl(d)
+----
+[17, 53, 9]
+
 # multiple groups
 query II
 SELECT mod(r,10) as g, quantile_disc(r, [0.1, 0.5, 0.9]) FROM quantiles GROUP BY 1 ORDER BY 1
@@ -138,8 +145,5 @@ SELECT quantile_disc(r, [0.1, 0.5, NULL]) FROM quantiles
 statement error
 SELECT quantile_disc(r, ["0.1", "0.5", "0.9"]) FROM quantiles
 
-statement error
-SELECT quantile_disc(r::string, [0.1, 0.5, 0.9]) FROM quantiles
-
 statement error
 SELECT quantile_disc(r, [0.1, 0.5, 0.9], 50) FROM quantiles
diff --git a/test/sql/aggregate/grouping_sets/cube.test b/test/sql/aggregate/grouping_sets/cube.test
new file mode 100644
index 000000000000..c3cbe1b1d572
--- /dev/null
+++ b/test/sql/aggregate/grouping_sets/cube.test
@@ -0,0 +1,175 @@
+# name: test/sql/aggregate/grouping_sets/cube.test
+# description: Test CUBE
+# group: [grouping_sets]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+create table students (course VARCHAR, type VARCHAR, highest_grade INTEGER);
+
+statement ok
+insert into students
+		(course, type, highest_grade)
+	values
+		('CS', 'Bachelor', 8),
+		('CS', 'Bachelor', 8),
+		('CS', 'PhD', 10),
+		('Math', 'Masters', NULL),
+		('CS', NULL, 7),
+		('CS', NULL, 7),
+		('Math', NULL, 8);
+
+query II
+select course, count(*) from students group by cube (course) order by 1, 2;
+----
+NULL	7
+CS	5
+Math	2
+
+query III
+select course, type, count(*) from students group by cube (course, type) order by 1, 2, 3;
+----
+NULL	NULL	3
+NULL	NULL	7
+NULL	Bachelor	2
+NULL	Masters	1
+NULL	PhD	1
+CS	NULL	2
+CS	NULL	5
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	NULL	2
+Math	Masters	1
+
+# if we have brackets in a CUBE group, it counts as one unit within the CUBE statement
+# i.e. in this case (course, type) are not cubed up
+query III
+select course, type, count(*) from students group by cube ((course, type)) order by 1, 2, 3;
+----
+NULL	NULL	7
+CS	NULL	2
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	Masters	1
+
+# duplicate group expressions in cube
+query III
+select course, type, count(*) from students group by cube (course, type, course) order by 1, 2, 3;
+----
+NULL	NULL	3
+NULL	NULL	7
+NULL	Bachelor	2
+NULL	Masters	1
+NULL	PhD	1
+CS	NULL	2
+CS	NULL	2
+CS	NULL	2
+CS	NULL	5
+CS	NULL	5
+CS	NULL	5
+CS	Bachelor	2
+CS	Bachelor	2
+CS	Bachelor	2
+CS	PhD	1
+CS	PhD	1
+CS	PhD	1
+Math	NULL	1
+Math	NULL	1
+Math	NULL	1
+Math	NULL	2
+Math	NULL	2
+Math	NULL	2
+Math	Masters	1
+Math	Masters	1
+Math	Masters	1
+
+query IIII
+select course, type, highest_grade, count(*) from students group by cube (course, type, highest_grade) order by 1, 2, 3, 4;
+----
+NULL	NULL	NULL	1
+NULL	NULL	NULL	3
+NULL	NULL	NULL	7
+NULL	NULL	7	2
+NULL	NULL	7	2
+NULL	NULL	8	1
+NULL	NULL	8	3
+NULL	NULL	10	1
+NULL	Bachelor	NULL	2
+NULL	Bachelor	8	2
+NULL	Masters	NULL	1
+NULL	Masters	NULL	1
+NULL	PhD	NULL	1
+NULL	PhD	10	1
+CS	NULL	NULL	2
+CS	NULL	NULL	5
+CS	NULL	7	2
+CS	NULL	7	2
+CS	NULL	8	2
+CS	NULL	10	1
+CS	Bachelor	NULL	2
+CS	Bachelor	8	2
+CS	PhD	NULL	1
+CS	PhD	10	1
+Math	NULL	NULL	1
+Math	NULL	NULL	1
+Math	NULL	NULL	2
+Math	NULL	8	1
+Math	NULL	8	1
+Math	Masters	NULL	1
+Math	Masters	NULL	1
+
+# multiple cubes ups causes a cross product of them
+query III
+select course, type, count(*) from students group by cube (course), cube (type) order by 1, 2, 3;
+----
+NULL	NULL	3
+NULL	NULL	7
+NULL	Bachelor	2
+NULL	Masters	1
+NULL	PhD	1
+CS	NULL	2
+CS	NULL	5
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	NULL	2
+Math	Masters	1
+
+query III
+select course as crs, type, count(*) from students group by cube (crs), (), type order by 1, 2, 3;
+----
+NULL	NULL	3
+NULL	Bachelor	2
+NULL	Masters	1
+NULL	PhD	1
+CS	NULL	2
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	Masters	1
+
+# we can also use cube within a grouping set
+query III
+select course as crs, type as tp, count(*) from students group by grouping sets (cube (crs)), (), tp order by 1, 2, 3;
+----
+NULL	NULL	3
+NULL	Bachelor	2
+NULL	Masters	1
+NULL	PhD	1
+CS	NULL	2
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	Masters	1
+
+statement error
+select course, count(*) from students group by cube () order by 1, 2;
+
+statement error
+select course, count(*) from students group by cube (cube (course)) order by 1, 2;
+
+statement error
+select course, count(*) from students group by cube (grouping_sets (course)) order by 1, 2;
diff --git a/test/sql/aggregate/grouping_sets/grouping.test b/test/sql/aggregate/grouping_sets/grouping.test
new file mode 100644
index 000000000000..8568530a70dd
--- /dev/null
+++ b/test/sql/aggregate/grouping_sets/grouping.test
@@ -0,0 +1,206 @@
+# name: test/sql/aggregate/grouping_sets/grouping.test
+# description: Test GROUPING statement
+# group: [grouping_sets]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+create table students (course VARCHAR, type VARCHAR);
+
+statement ok
+insert into students
+		(course, type)
+	values
+		('CS', 'Bachelor'),
+		('CS', 'Bachelor'),
+		('CS', 'PhD'),
+		('Math', 'Masters'),
+		('CS', NULL),
+		('CS', NULL),
+		('Math', NULL);
+
+query III
+SELECT GROUPING(course), course, COUNT(*) FROM students GROUP BY course ORDER BY 1, 2, 3;
+----
+0	CS	5
+0	Math	2
+
+query III
+SELECT GROUPING_ID(course), course, COUNT(*) FROM students GROUP BY course ORDER BY 1, 2, 3;
+----
+0	CS	5
+0	Math	2
+
+query IIIII
+SELECT GROUPING(course), GROUPING(type), course, type, COUNT(*) FROM students GROUP BY course, type ORDER BY 1, 2, 3, 4, 5;
+----
+0	0	CS	NULL	2
+0	0	CS	Bachelor	2
+0	0	CS	PhD	1
+0	0	Math	NULL	1
+0	0	Math	Masters	1
+
+query IIIII
+SELECT GROUPING(course), GROUPING(type), course, type, COUNT(*) FROM students GROUP BY CUBE(course, type) ORDER BY 1, 2, 3, 4, 5;
+----
+0	0	CS	NULL	2
+0	0	CS	Bachelor	2
+0	0	CS	PhD	1
+0	0	Math	NULL	1
+0	0	Math	Masters	1
+0	1	CS	NULL	5
+0	1	Math	NULL	2
+1	0	NULL	NULL	3
+1	0	NULL	Bachelor	2
+1	0	NULL	Masters	1
+1	0	NULL	PhD	1
+1	1	NULL	NULL	7
+
+query IIII
+SELECT GROUPING(course, type), course, type, COUNT(*) FROM students GROUP BY CUBE(course, type) ORDER BY 1, 2, 3, 4;
+----
+0	CS	NULL	2
+0	CS	Bachelor	2
+0	CS	PhD	1
+0	Math	NULL	1
+0	Math	Masters	1
+1	CS	NULL	5
+1	Math	NULL	2
+2	NULL	NULL	3
+2	NULL	Bachelor	2
+2	NULL	Masters	1
+2	NULL	PhD	1
+3	NULL	NULL	7
+
+query IIIIII
+SELECT GROUPING(course), GROUPING(type), GROUPING(course)+GROUPING(type), course, type, COUNT(*) FROM students GROUP BY CUBE(course, type) ORDER BY 1, 2, 3, 4, 5;
+----
+0	0	0	CS	NULL	2
+0	0	0	CS	Bachelor	2
+0	0	0	CS	PhD	1
+0	0	0	Math	NULL	1
+0	0	0	Math	Masters	1
+0	1	1	CS	NULL	5
+0	1	1	Math	NULL	2
+1	0	1	NULL	NULL	3
+1	0	1	NULL	Bachelor	2
+1	0	1	NULL	Masters	1
+1	0	1	NULL	PhD	1
+1	1	2	NULL	NULL	7
+
+# many repeated groupings
+query IIII
+SELECT GROUPING(course, type, course, course, type, type, course), course, type, COUNT(*) FROM students GROUP BY CUBE(course, type) ORDER BY 1, 2, 3, 4;
+----
+0	CS	NULL	2
+0	CS	Bachelor	2
+0	CS	PhD	1
+0	Math	NULL	1
+0	Math	Masters	1
+38	CS	NULL	5
+38	Math	NULL	2
+89	NULL	NULL	3
+89	NULL	Bachelor	2
+89	NULL	Masters	1
+89	NULL	PhD	1
+127	NULL	NULL	7
+
+# GROUPING with different table qualifications
+query IIIIII
+SELECT GROUPING(students.course), GROUPING(students.type), GROUPING(course)+GROUPING(type), course, type, COUNT(*) FROM students GROUP BY CUBE(course, type) ORDER BY 1, 2, 3, 4, 5;
+----
+0	0	0	CS	NULL	2
+0	0	0	CS	Bachelor	2
+0	0	0	CS	PhD	1
+0	0	0	Math	NULL	1
+0	0	0	Math	Masters	1
+0	1	1	CS	NULL	5
+0	1	1	Math	NULL	2
+1	0	1	NULL	NULL	3
+1	0	1	NULL	Bachelor	2
+1	0	1	NULL	Masters	1
+1	0	1	NULL	PhD	1
+1	1	2	NULL	NULL	7
+
+query IIIIII
+SELECT GROUPING(course), GROUPING(type), GROUPING(course)+GROUPING(type), course, type, COUNT(*) FROM students GROUP BY CUBE(students.course, students.type) ORDER BY 1, 2, 3, 4, 5;
+----
+0	0	0	CS	NULL	2
+0	0	0	CS	Bachelor	2
+0	0	0	CS	PhD	1
+0	0	0	Math	NULL	1
+0	0	0	Math	Masters	1
+0	1	1	CS	NULL	5
+0	1	1	Math	NULL	2
+1	0	1	NULL	NULL	3
+1	0	1	NULL	Bachelor	2
+1	0	1	NULL	Masters	1
+1	0	1	NULL	PhD	1
+1	1	2	NULL	NULL	7
+
+# GROUPING in HAVING clause
+query IIIII
+SELECT GROUPING(course), GROUPING(type), course, type, COUNT(*) FROM students GROUP BY CUBE(course, type) HAVING GROUPING(course)=0 ORDER BY 1, 2, 3, 4, 5;
+----
+0	0	CS	NULL	2
+0	0	CS	Bachelor	2
+0	0	CS	PhD	1
+0	0	Math	NULL	1
+0	0	Math	Masters	1
+0	1	CS	NULL	5
+0	1	Math	NULL	2
+
+query IIIII
+SELECT GROUPING(course), GROUPING(type), course, type, COUNT(*) FROM students GROUP BY CUBE(course, type) HAVING GROUPING(students.course)=0 ORDER BY 1, 2, 3, 4, 5;
+----
+0	0	CS	NULL	2
+0	0	CS	Bachelor	2
+0	0	CS	PhD	1
+0	0	Math	NULL	1
+0	0	Math	Masters	1
+0	1	CS	NULL	5
+0	1	Math	NULL	2
+
+# GROUPING in ORDER BY clause
+query III
+SELECT course, type, COUNT(*) FROM students GROUP BY CUBE(course, type) ORDER BY GROUPING(course), GROUPING(type), 1, 2, 3;
+----
+CS	NULL	2
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	Masters	1
+CS	NULL	5
+Math	NULL	2
+NULL	NULL	3
+NULL	Bachelor	2
+NULL	Masters	1
+NULL	PhD	1
+NULL	NULL	7
+
+# test incorrect grouping usage
+statement error
+SELECT GROUPING();
+
+statement error
+SELECT GROUPING() FROM students;
+
+statement error
+SELECT GROUPING(NULL) FROM students;
+
+statement error
+SELECT GROUPING(course) FROM students;
+
+statement error
+SELECT GROUPING(course) FROM students GROUP BY ();
+
+statement error
+SELECT GROUPING(type) FROM students GROUP BY course;
+
+statement error
+SELECT GROUPING(course) FROM students WHERE GROUPING(course)=0 GROUP BY course;
+
+# we have a limit on how many children the grouping clause can contain
+statement error
+SELECT GROUPING(course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course, course), course, type, COUNT(*) FROM students GROUP BY CUBE(course, type) ORDER BY 1, 2, 3, 4;
diff --git a/test/sql/aggregate/grouping_sets/grouping_sets.test b/test/sql/aggregate/grouping_sets/grouping_sets.test
new file mode 100644
index 000000000000..5d83f7bb6719
--- /dev/null
+++ b/test/sql/aggregate/grouping_sets/grouping_sets.test
@@ -0,0 +1,273 @@
+# name: test/sql/aggregate/grouping_sets/grouping_sets.test
+# description: Test basic grouping sets
+# group: [grouping_sets]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+create table students (course VARCHAR, type VARCHAR);
+
+statement ok
+insert into students
+		(course, type)
+	values
+		('CS', 'Bachelor'),
+		('CS', 'Bachelor'),
+		('CS', 'PhD'),
+		('Math', 'Masters'),
+		('CS', NULL),
+		('CS', NULL),
+		('Math', NULL);
+
+query I
+select 1 from students group by ();
+----
+1
+
+query I
+select count(*) from students group by ();
+----
+7
+
+query III
+select course, type, count(*) from students group by course, type order by 1, 2, 3;
+----
+CS	NULL	2
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	Masters	1
+
+query III
+select course, type, count(*) from students group by (course, type) order by 1, 2, 3;
+----
+CS	NULL	2
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	Masters	1
+
+query II
+select course, count(*) from students group by (), course, () ORDER BY 1;
+----
+CS	5
+Math	2
+
+# multiple grouping sets
+query III
+select count(*), course, type
+	from students
+	group by grouping sets ((course), (type))
+	order by 1, 2, 3;
+----
+1	NULL	Masters
+1	NULL	PhD
+2	NULL	Bachelor
+2	Math	NULL
+3	NULL	NULL
+5	CS	NULL
+
+# multiple grouping sets
+# these are combined as if they are regular GROUP BY expressions
+# i.e. the result is just GROUP BY course, type
+
+# If multiple grouping items are specified in a single GROUP BY clause,
+# then the final list of grouping sets is the cross product of the individual items.
+query III
+select count(*), course, type
+	from students
+	group by grouping sets (course), grouping sets(type)
+	order by 1, 2, 3;
+----
+1	CS	PhD
+1	Math	NULL
+1	Math	Masters
+2	CS	NULL
+2	CS	Bachelor
+
+# combining grouping sets with non-grouping sets
+query III
+select count(*), course, type
+	from students
+	group by course, grouping sets(type)
+	order by 1, 2, 3;
+----
+1	CS	PhD
+1	Math	NULL
+1	Math	Masters
+2	CS	NULL
+2	CS	Bachelor
+
+# with multiple grouping sets...
+query III
+select count(*), course, type
+	from students
+	group by course, grouping sets(type, ())
+	order by 1, 2, 3;
+----
+1	CS	PhD
+1	Math	NULL
+1	Math	Masters
+2	CS	NULL
+2	CS	Bachelor
+2	Math	NULL
+5	CS	NULL
+
+query III
+select count(*), course, type
+	from students
+	group by grouping sets((course, type), (course))
+	order by 1, 2, 3;
+----
+1	CS	PhD
+1	Math	NULL
+1	Math	Masters
+2	CS	NULL
+2	CS	Bachelor
+2	Math	NULL
+5	CS	NULL
+
+# nested grouping sets
+# If one GROUPING SETS clause is nested inside another,
+# the effect is the same as if all the elements of the inner clause had been written directly in the outer clause.
+query III
+select count(*), course, type
+	from students
+	group by grouping sets (grouping sets(course), grouping sets(type))
+	order by 1, 2, 3;
+----
+1	NULL	Masters
+1	NULL	PhD
+2	NULL	Bachelor
+2	Math	NULL
+3	NULL	NULL
+5	CS	NULL
+
+query III
+select count(*), course, type
+        from students
+        group by grouping sets (grouping sets(course, ()), grouping sets(type))
+        order by 1, 2, 3;
+----
+1	NULL	Masters
+1	NULL	PhD
+2	NULL	Bachelor
+2	Math	NULL
+3	NULL	NULL
+5	CS	NULL
+7	NULL	NULL
+
+query III
+select count(*), course, type
+        from students
+        group by grouping sets ((course), (), (type))
+        order by 1, 2, 3;
+----
+1	NULL	Masters
+1	NULL	PhD
+2	NULL	Bachelor
+2	Math	NULL
+3	NULL	NULL
+5	CS	NULL
+7	NULL	NULL
+
+query III
+select count(*), course, type
+        from students
+        group by grouping sets(course, ()), grouping sets(type)
+        order by 1, 2, 3;
+----
+1	NULL	Masters
+1	NULL	PhD
+1	CS	PhD
+1	Math	NULL
+1	Math	Masters
+2	NULL	Bachelor
+2	CS	NULL
+2	CS	Bachelor
+3	NULL	NULL
+
+query III
+select count(*), course, type
+        from students
+        group by grouping sets(course, ()), type
+        order by 1, 2, 3;
+----
+1	NULL	Masters
+1	NULL	PhD
+1	CS	PhD
+1	Math	NULL
+1	Math	Masters
+2	NULL	Bachelor
+2	CS	NULL
+2	CS	Bachelor
+3	NULL	NULL
+
+query III
+select count(*), course, type
+        from students
+        group by grouping sets((course, type), (type))
+        order by 1, 2, 3;
+----
+1	NULL	Masters
+1	NULL	PhD
+1	CS	PhD
+1	Math	NULL
+1	Math	Masters
+2	NULL	Bachelor
+2	CS	NULL
+2	CS	Bachelor
+3	NULL	NULL
+
+# references to group ids by index
+query III
+select count(*), course, type
+        from students
+        group by grouping sets((2, 3), (3))
+        order by 1, 2, 3;
+----
+1	NULL	Masters
+1	NULL	PhD
+1	CS	PhD
+1	Math	NULL
+1	Math	Masters
+2	NULL	Bachelor
+2	CS	NULL
+2	CS	Bachelor
+3	NULL	NULL
+
+query III
+select count(*), course AS crs, type AS tp
+        from students
+        group by grouping sets((crs, tp), (tp))
+        order by 1, 2, 3;
+----
+1	NULL	Masters
+1	NULL	PhD
+1	CS	PhD
+1	Math	NULL
+1	Math	Masters
+2	NULL	Bachelor
+2	CS	NULL
+2	CS	Bachelor
+3	NULL	NULL
+
+query III
+select count(*), course, type
+        from students
+        group by grouping sets (grouping sets(course, ()), grouping sets(type, ()))
+        order by 1, 2, 3;
+----
+1	NULL	Masters
+1	NULL	PhD
+2	NULL	Bachelor
+2	Math	NULL
+3	NULL	NULL
+5	CS	NULL
+7	NULL	NULL
+7	NULL	NULL
+
+# course is not a group or aggregate column
+statement error
+select course from students group by ();
diff --git a/test/sql/aggregate/grouping_sets/large_grouping_sets.test_slow b/test/sql/aggregate/grouping_sets/large_grouping_sets.test_slow
new file mode 100644
index 000000000000..101dea93c5ea
--- /dev/null
+++ b/test/sql/aggregate/grouping_sets/large_grouping_sets.test_slow
@@ -0,0 +1,16 @@
+# name: test/sql/aggregate/grouping_sets/large_grouping_sets.test_slow
+# description: Test GROUPING sets with many groups to trigger radix partitioning
+# group: [grouping_sets]
+
+statement ok
+CREATE TABLE integers AS SELECT i, i::VARCHAR j FROM generate_series(0, 1000000, 1) tbl(i);
+
+query I
+SELECT COUNT(*) FROM (SELECT * FROM integers GROUP BY CUBE (i, j)) tbl;
+----
+3000004
+
+query I
+SELECT COUNT(*) FROM (SELECT * FROM integers GROUP BY ROLLUP (i, j)) tbl;
+----
+2000003
diff --git a/test/sql/aggregate/grouping_sets/rollup.test b/test/sql/aggregate/grouping_sets/rollup.test
new file mode 100644
index 000000000000..f6adddef3b88
--- /dev/null
+++ b/test/sql/aggregate/grouping_sets/rollup.test
@@ -0,0 +1,135 @@
+# name: test/sql/aggregate/grouping_sets/rollup.test
+# description: Test ROLLUP
+# group: [grouping_sets]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+create table students (course VARCHAR, type VARCHAR);
+
+statement ok
+insert into students
+		(course, type)
+	values
+		('CS', 'Bachelor'),
+		('CS', 'Bachelor'),
+		('CS', 'PhD'),
+		('Math', 'Masters'),
+		('CS', NULL),
+		('CS', NULL),
+		('Math', NULL);
+
+query II
+select course, count(*) from students group by rollup (course) order by 1, 2;
+----
+NULL	7
+CS	5
+Math	2
+
+query III
+select course, type, count(*) from students group by rollup (course, type) order by 1, 2, 3;
+----
+NULL	NULL	7
+CS	NULL	2
+CS	NULL	5
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	NULL	2
+Math	Masters	1
+
+# if we have brackets in a ROLLUP group, it counts as one unit within the ROLLUP statement
+# i.e. in this case (course, type) are not individually rolled up
+query III
+select course, type, count(*) from students group by rollup ((course, type)) order by 1, 2, 3;
+----
+NULL	NULL	7
+CS	NULL	2
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	Masters	1
+
+# duplicate group expressions in rollup
+query III
+select course, type, count(*) from students group by rollup (course, type, course) order by 1, 2, 3;
+----
+NULL	NULL	7
+CS	NULL	2
+CS	NULL	2
+CS	NULL	5
+CS	Bachelor	2
+CS	Bachelor	2
+CS	PhD	1
+CS	PhD	1
+Math	NULL	1
+Math	NULL	1
+Math	NULL	2
+Math	Masters	1
+Math	Masters	1
+
+query III
+select course, type, count(*) from students group by grouping sets ((course, type), (course), ()) order by 1, 2, 3;
+----
+NULL	NULL	7
+CS	NULL	2
+CS	NULL	5
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	NULL	2
+Math	Masters	1
+
+# multiple roll ups causes a cross product of them
+query III
+select course, type, count(*) from students group by rollup (course), rollup (type) order by 1, 2, 3;
+----
+NULL	NULL	3
+NULL	NULL	7
+NULL	Bachelor	2
+NULL	Masters	1
+NULL	PhD	1
+CS	NULL	2
+CS	NULL	5
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	NULL	2
+Math	Masters	1
+
+query III
+select course as crs, type, count(*) from students group by rollup (crs), (), type order by 1, 2, 3;
+----
+NULL	NULL	3
+NULL	Bachelor	2
+NULL	Masters	1
+NULL	PhD	1
+CS	NULL	2
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	Masters	1
+
+# we can also use rollup within a grouping set
+query III
+select course as crs, type as tp, count(*) from students group by grouping sets (rollup (crs)), (), tp order by 1, 2, 3;
+----
+NULL	NULL	3
+NULL	Bachelor	2
+NULL	Masters	1
+NULL	PhD	1
+CS	NULL	2
+CS	Bachelor	2
+CS	PhD	1
+Math	NULL	1
+Math	Masters	1
+
+statement error
+select course, count(*) from students group by rollup () order by 1, 2;
+
+statement error
+select course, count(*) from students group by rollup (rollup (course)) order by 1, 2;
+
+statement error
+select course, count(*) from students group by rollup (grouping_sets (course)) order by 1, 2;
diff --git a/test/sql/create/create_or_replace.test b/test/sql/create/create_or_replace.test
new file mode 100644
index 000000000000..7486011517d2
--- /dev/null
+++ b/test/sql/create/create_or_replace.test
@@ -0,0 +1,21 @@
+# name: test/sql/create/create_or_replace.test
+# description: Test CREATE OR REPLACE TABLE
+# group: [create]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE integers(i INTEGER)
+
+statement ok
+CREATE OR REPLACE TABLE integers(i INTEGER, j INTEGER)
+
+statement ok
+CREATE TABLE IF NOT EXISTS integers(i INTEGER)
+
+statement ok
+INSERT INTO integers VALUES (1, 2);
+
+statement error
+CREATE OR REPLACE TABLE IF NOT EXISTS integers(i INTEGER)
diff --git a/test/sql/create/create_table_as_duplicate_names.test b/test/sql/create/create_table_as_duplicate_names.test
index 724f3cf5b515..ef2d91b5c699 100644
--- a/test/sql/create/create_table_as_duplicate_names.test
+++ b/test/sql/create/create_table_as_duplicate_names.test
@@ -2,6 +2,9 @@
 # description: Test CREATE TABLE AS with duplicate column names
 # group: [create]
 
+statement ok
+PRAGMA enable_verification
+
 query II
 SELECT * FROM range(5) tbl1(i) JOIN range(5) tbl2(i) ON tbl1.i=tbl2.i;
 ----
diff --git a/test/sql/storage_version/storage_version.db b/test/sql/storage_version/storage_version.db
index 44409c6ea089..f6cae75bc0ec 100644
Binary files a/test/sql/storage_version/storage_version.db and b/test/sql/storage_version/storage_version.db differ
diff --git a/test/sql/subquery/scalar/test_correlated_grouping_set.test b/test/sql/subquery/scalar/test_correlated_grouping_set.test
new file mode 100644
index 000000000000..a58bd2e76eac
--- /dev/null
+++ b/test/sql/subquery/scalar/test_correlated_grouping_set.test
@@ -0,0 +1,62 @@
+# name: test/sql/subquery/scalar/test_correlated_grouping_set.test
+# description: Test correlated aggregate subqueries
+# group: [scalar]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE integers(i INTEGER);
+
+statement ok
+INSERT INTO integers VALUES (1), (2), (3), (NULL);
+
+# aggregate with correlation in GROUPING SET
+query II
+SELECT i, (SELECT COUNT(*) FROM (SELECT i1.i FROM integers GROUP BY GROUPING SETS(i1.i)) tbl) AS j FROM integers i1 ORDER BY i;
+----
+NULL	1
+1	1
+2	1
+3	1
+
+# many grouping sets
+query II
+SELECT i, (SELECT COUNT(*) FROM (SELECT i1.i FROM integers GROUP BY GROUPING SETS((i1.i), (), (i1.i), (i1.i, i1.i))) tbl) AS j FROM integers i1 ORDER BY i;
+----
+NULL	4
+1	4
+2	4
+3	4
+
+# rollup
+query II
+SELECT i, (SELECT COUNT(*) FROM (SELECT i1.i FROM integers GROUP BY ROLLUP (i1.i, i1.i, i1.i, i1.i)) tbl) AS j FROM integers i1 ORDER BY i;
+----
+NULL	5
+1	5
+2	5
+3	5
+
+# cube
+query II
+SELECT i, (SELECT COUNT(*) FROM (SELECT i1.i FROM integers GROUP BY CUBE (i1.i, i1.i, i1.i, i1.i)) tbl) AS j FROM integers i1 ORDER BY i;
+----
+NULL	16
+1	16
+2	16
+3	16
+
+# aggregate with correlation in GROUPING SET and HAVING
+# FIXME: this is borked, related to #2335
+mode skip
+
+query II
+SELECT i, (SELECT MIN(i) FROM integers GROUP BY GROUPING SETS(i1.i, i) HAVING i1.i=i) AS j FROM integers i1 ORDER BY i;
+----
+NULL	NULL
+1	NULL
+2	NULL
+3	NULL
+
+mode unskip
diff --git a/test/sql/tpch/tpch_grouping_sets.test_slow b/test/sql/tpch/tpch_grouping_sets.test_slow
new file mode 100644
index 000000000000..7715df18411b
--- /dev/null
+++ b/test/sql/tpch/tpch_grouping_sets.test_slow
@@ -0,0 +1,45 @@
+# name: test/sql/tpch/tpch_grouping_sets.test_slow
+# description: Test TPC-H SF0.01 Q1 with unions
+# group: [tpch]
+
+require tpch
+
+statement ok
+PRAGMA threads=4
+
+statement ok
+PRAGMA verify_parallelism
+
+statement ok
+CALL dbgen(sf=0.1);
+
+query IIIIIIIIII
+SELECT
+    l_returnflag,
+    l_linestatus,
+    sum(l_quantity) AS sum_qty,
+    sum(l_extendedprice) AS sum_base_price,
+    sum(l_extendedprice * (1 - l_discount)) AS sum_disc_price,
+    sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) AS sum_charge,
+    avg(l_quantity) AS avg_qty,
+    avg(l_extendedprice) AS avg_price,
+    avg(l_discount) AS avg_disc,
+    count(*) AS count_order
+FROM
+	lineitem
+GROUP BY
+	GROUPING SETS ((l_returnflag, l_linestatus), (l_returnflag), (l_linestatus), ())
+ORDER BY
+    l_returnflag NULLS LAST,
+    l_linestatus NULLS LAST;
+----
+A	F	3774200	5320753880.69	5054096266.6828	5256751331.449234	25.5375871168549970	36002.123829014142	0.05014459706340077136	147790
+A	NULL	3774200	5320753880.69	5054096266.6828	5256751331.449234	25.5375871168549970	36002.123829014142	0.05014459706340077136	147790
+N	F	95257	133737795.84	127132372.6512	132286291.229445	25.3006640106241700	35521.326916334661	0.04939442231075697211	3765
+N	O	7679822	10823487077.24	10282025059.1390	10693158047.350890	25.5384548876680988	35992.388423761955	0.05008945317176339137	300716
+N	NULL	7775079	10957224873.08	10409157431.7902	10825444338.580335	25.5355145312843823	35986.563605216746	0.05008085890416807617	304481
+R	F	3785523	5337950526.47	5071818532.9420	5274405503.049367	25.5259438574251017	35994.029214030924	0.04998927856184381764	148301
+R	NULL	3785523	5337950526.47	5071818532.9420	5274405503.049367	25.5259438574251017	35994.029214030924	0.04998927856184381764	148301
+NULL	F	7654980	10792442203.00	10253047172.2760	10663443125.728046	25.5288538498479270	35992.083543434182	0.05005836134677978763	299856
+NULL	O	7679822	10823487077.24	10282025059.1390	10693158047.350890	25.5384548876680988	35992.388423761955	0.05008945317176339137	300716
+NULL	NULL	15334802	21615929280.24	20535072231.4150	21356601173.078936	25.5336612429483892	35992.236201887534	0.05007392952052376734	600572
