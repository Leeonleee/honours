{
  "repo": "duckdb/duckdb",
  "pull_number": 8738,
  "instance_id": "duckdb__duckdb-8738",
  "issue_numbers": [
    "8735"
  ],
  "base_commit": "26931f7ac687e8323c24e7f7b1e081114400d1b3",
  "patch": "diff --git a/tools/pythonpkg/src/dataframe.cpp b/tools/pythonpkg/src/dataframe.cpp\nindex e45231083cb9..21f41a2a1781 100644\n--- a/tools/pythonpkg/src/dataframe.cpp\n+++ b/tools/pythonpkg/src/dataframe.cpp\n@@ -37,7 +37,7 @@ bool PandasDataFrame::IsPyArrowBacked(const py::handle &df) {\n \t\treturn false;\n \t}\n \n-\tauto arrow_dtype = import_cache.pandas().core.arrays.arrow.dtype.ArrowDtype();\n+\tauto arrow_dtype = import_cache.pandas().ArrowDtype();\n \tfor (auto &dtype : dtypes) {\n \t\tif (py::isinstance(dtype, arrow_dtype)) {\n \t\t\treturn true;\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp\nindex d785787139ae..21ea6fbd821c 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp\n@@ -12,63 +12,6 @@\n \n namespace duckdb {\n \n-// pandas.core.arrays.arrow.dtype\n-struct PandasCoreArraysArrowDtypeCacheItem : public PythonImportCacheItem {\n-public:\n-\t~PandasCoreArraysArrowDtypeCacheItem() override {\n-\t}\n-\tvirtual void LoadSubtypes(PythonImportCache &cache) override {\n-\t\tArrowDtype.LoadAttribute(\"ArrowDtype\", cache, *this);\n-\t}\n-\n-public:\n-\tPythonImportCacheItem ArrowDtype;\n-};\n-\n-// pandas.core.arrays.arrow\n-struct PandasCoreArraysArrowCacheItem : public PythonImportCacheItem {\n-public:\n-\t~PandasCoreArraysArrowCacheItem() override {\n-\t}\n-\tvirtual void LoadSubtypes(PythonImportCache &cache) override {\n-\t\tdtype.LoadModule(\"pandas.core.arrays.arrow.dtype\", cache);\n-\t}\n-\n-public:\n-\tPandasCoreArraysArrowDtypeCacheItem dtype;\n-\n-protected:\n-\tbool IsRequired() const override final {\n-\t\treturn false;\n-\t}\n-};\n-\n-// pandas.core.arrays\n-struct PandasCoreArraysCacheItem : public PythonImportCacheItem {\n-public:\n-\t~PandasCoreArraysCacheItem() override {\n-\t}\n-\tvirtual void LoadSubtypes(PythonImportCache &cache) override {\n-\t\tarrow.LoadModule(\"pandas.core.arrays.arrow\", cache);\n-\t}\n-\n-public:\n-\tPandasCoreArraysArrowCacheItem arrow;\n-};\n-\n-// pandas.core\n-struct PandasCoreCacheItem : public PythonImportCacheItem {\n-public:\n-\t~PandasCoreCacheItem() override {\n-\t}\n-\tvirtual void LoadSubtypes(PythonImportCache &cache) override {\n-\t\tarrays.LoadModule(\"pandas.core.arrays\", cache);\n-\t}\n-\n-public:\n-\tPandasCoreArraysCacheItem arrays;\n-};\n-\n // pandas.libs\n struct PandasLibsCacheItem : public PythonImportCacheItem {\n public:\n@@ -97,16 +40,16 @@ struct PandasCacheItem : public PythonImportCacheItem {\n \tvirtual void LoadSubtypes(PythonImportCache &cache) override {\n \t\tDataFrame.LoadAttribute(\"DataFrame\", cache, *this);\n \t\tlibs.LoadModule(\"pandas._libs.missing\", cache);\n-\t\tcore.LoadModule(\"pandas.core\", cache);\n \t\tisnull.LoadAttribute(\"isnull\", cache, *this);\n+\t\tArrowDtype.LoadAttribute(\"ArrowDtype\", cache, *this);\n \t}\n \n public:\n \t//! pandas.DataFrame\n \tPythonImportCacheItem DataFrame;\n \tPandasLibsCacheItem libs;\n-\tPandasCoreCacheItem core;\n \tPythonImportCacheItem isnull;\n+\tPythonImportCacheItem ArrowDtype;\n \n protected:\n \tbool IsRequired() const override final {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/conftest.py b/tools/pythonpkg/tests/conftest.py\nindex d56ebff766dd..a10d40b2ccd6 100644\n--- a/tools/pythonpkg/tests/conftest.py\n+++ b/tools/pythonpkg/tests/conftest.py\n@@ -8,7 +8,7 @@\n try:\n     import pandas\n \n-    pyarrow_dtype = pandas.core.arrays.arrow.dtype.ArrowDtype\n+    pyarrow_dtype = pandas.ArrowDtype\n except:\n     pyarrow_dtype = None\n \ndiff --git a/tools/pythonpkg/tests/fast/api/test_dbapi08.py b/tools/pythonpkg/tests/fast/api/test_dbapi08.py\nindex 0f4ef7aa06de..70272b76b769 100644\n--- a/tools/pythonpkg/tests/fast/api/test_dbapi08.py\n+++ b/tools/pythonpkg/tests/fast/api/test_dbapi08.py\n@@ -6,7 +6,7 @@\n \n \n class TestType(object):\n-    @pytest.mark.parametrize('pandas', [NumpyPandas(), ArrowPandas()])\n+    @pytest.mark.parametrize('pandas', [NumpyPandas()])\n     def test_fetchdf(self, pandas):\n         con = duckdb.connect()\n         con.execute(\"CREATE TABLE items(item VARCHAR)\")\ndiff --git a/tools/pythonpkg/tests/fast/pandas/test_pandas_arrow.py b/tools/pythonpkg/tests/fast/pandas/test_pandas_arrow.py\nindex d4b29473ad0a..f313383e4bc6 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_pandas_arrow.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_pandas_arrow.py\n@@ -6,6 +6,7 @@\n \n pd = pytest.importorskip(\"pandas\", '2.0.0')\n import numpy as np\n+from pandas.api.types import is_integer_dtype\n \n \n @pytest.mark.skipif(not pandas_supports_arrow_backend(), reason=\"pandas does not support the 'pyarrow' backend\")\n@@ -56,9 +57,9 @@ def test_mixed_columns(self):\n         python_df = pd.DataFrame({'a': pd.Series(['test', [5, 4, 3], {'a': 42}])}).convert_dtypes()\n \n         df = pd.concat([numpy_df['a'], arrow_df['a'], python_df['a']], axis=1, keys=['numpy', 'arrow', 'python'])\n-        assert isinstance(df.dtypes[0], pd.core.arrays.integer.IntegerDtype)\n-        assert isinstance(df.dtypes[1], pd.core.arrays.arrow.dtype.ArrowDtype)\n-        assert isinstance(df.dtypes[2], np.dtype('O').__class__)\n+        assert is_integer_dtype(df.dtypes['numpy'])\n+        assert isinstance(df.dtypes['arrow'], pd.ArrowDtype)\n+        assert isinstance(df.dtypes['python'], np.dtype('O').__class__)\n \n         with pytest.raises(duckdb.InvalidInputException, match='Conversion failed for column python with type object'):\n             res = con.sql('select * from df').fetchall()\n",
  "problem_statement": "pandas 2.1.0 breaks duckdb when using arrow and query contains bind parameters\n### What happens?\r\n\r\nWhen executing a query using `duckdb` from Python that contains bind parameters, I am unable to convert the result to Arrow using pandas 2.1.0 (I realize that it came out today). Without bind parameters, the query works.\r\n\r\n### To Reproduce\r\n\r\n```\r\nIn [1]: import duckdb\r\n\r\nIn [2]: import pandas as pd\r\n\r\nIn [3]: pd.__version__\r\nOut[3]: '2.1.0'\r\n\r\nIn [4]: duckdb.execute(\"select ? as a\", (1,)).arrow()\r\n---------------------------------------------------------------------------\r\nInvalidInputException                     Traceback (most recent call last)\r\nCell In[4], line 1\r\n----> 1 duckdb.execute(\"select ? as a\", (1,)).arrow()\r\n\r\nInvalidInputException: Invalid Input Error: Required module 'pandas.core.arrays.arrow.dtype' failed to import, due to the following Python exception:\r\nModuleNotFoundError: No module named 'pandas.core.arrays.arrow.dtype'\r\n```\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n0.8.1\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nPhillip Cloud\r\n\r\n### Affiliation:\r\n\r\nVoltron Data\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a release build (and could not test with a main build)\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2023-08-30T17:45:22Z"
}