{
  "repo": "duckdb/duckdb",
  "pull_number": 2529,
  "instance_id": "duckdb__duckdb-2529",
  "issue_numbers": [
    "2523"
  ],
  "base_commit": "482421f6cc690e015b845420372ed431f3501e41",
  "patch": "diff --git a/src/function/scalar/string/regexp.cpp b/src/function/scalar/string/regexp.cpp\nindex da67caf89288..dbe175e96ead 100644\n--- a/src/function/scalar/string/regexp.cpp\n+++ b/src/function/scalar/string/regexp.cpp\n@@ -1,15 +1,15 @@\n-#include \"duckdb/function/scalar/string_functions.hpp\"\n+#include \"duckdb/function/scalar/regexp.hpp\"\n+\n #include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/vector_operations/binary_executor.hpp\"\n+#include \"duckdb/common/vector_operations/ternary_executor.hpp\"\n+#include \"duckdb/common/vector_operations/unary_executor.hpp\"\n #include \"duckdb/common/vector_operations/vector_operations.hpp\"\n #include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/function/scalar/string_functions.hpp\"\n #include \"duckdb/planner/expression/bound_function_expression.hpp\"\n-#include \"duckdb/common/vector_operations/unary_executor.hpp\"\n-#include \"duckdb/common/vector_operations/binary_executor.hpp\"\n-#include \"duckdb/common/vector_operations/ternary_executor.hpp\"\n #include \"utf8proc_wrapper.hpp\"\n \n-#include \"duckdb/function/scalar/regexp.hpp\"\n-\n namespace duckdb {\n \n RegexpMatchesBindData::RegexpMatchesBindData(duckdb_re2::RE2::Options options, string constant_string_p)\n@@ -97,6 +97,11 @@ struct RegexLocalState : public FunctionData {\n \t\tD_ASSERT(info.constant_pattern);\n \t}\n \n+\texplicit RegexLocalState(RegexpExtractBindData &info)\n+\t    : constant_pattern(duckdb_re2::StringPiece(info.constant_string.c_str(), info.constant_string.size())) {\n+\t\tD_ASSERT(info.constant_pattern);\n+\t}\n+\n \tRE2 constant_pattern;\n };\n \n@@ -203,6 +208,85 @@ static unique_ptr<FunctionData> RegexReplaceBind(ClientContext &context, ScalarF\n \treturn move(data);\n }\n \n+inline static string_t Extract(const string_t &input, Vector &result, const RE2 &re,\n+                               const duckdb_re2::StringPiece &rewrite) {\n+\tstd::string extracted;\n+\tRE2::Extract(input.GetString(), re, rewrite, &extracted);\n+\treturn StringVector::AddString(result, extracted.c_str(), extracted.size());\n+}\n+\n+static void RegexExtractFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tauto &func_expr = (BoundFunctionExpression &)state.expr;\n+\tconst auto &info = (RegexpExtractBindData &)*func_expr.bind_info;\n+\n+\tauto &strings = args.data[0];\n+\tauto &patterns = args.data[1];\n+\tif (info.constant_pattern) {\n+\t\tauto &lstate = (RegexLocalState &)*ExecuteFunctionState::GetFunctionState(state);\n+\t\tUnaryExecutor::Execute<string_t, string_t>(strings, result, args.size(), [&](string_t input) {\n+\t\t\treturn Extract(input, result, lstate.constant_pattern, info.rewrite);\n+\t\t});\n+\t} else {\n+\t\tBinaryExecutor::Execute<string_t, string_t, string_t>(strings, patterns, result, args.size(),\n+\t\t                                                      [&](string_t input, string_t pattern) {\n+\t\t\t                                                      RE2 re(CreateStringPiece(pattern));\n+\t\t\t                                                      return Extract(input, result, re, info.rewrite);\n+\t\t                                                      });\n+\t}\n+}\n+\n+static unique_ptr<FunctionData> RegexExtractInitLocalState(const BoundFunctionExpression &expr,\n+                                                           FunctionData *bind_data) {\n+\tauto &info = (RegexpExtractBindData &)*bind_data;\n+\tif (info.constant_pattern) {\n+\t\treturn make_unique<RegexLocalState>(info);\n+\t}\n+\treturn nullptr;\n+}\n+\n+RegexpExtractBindData::RegexpExtractBindData(bool constant_pattern, const string &constant_string,\n+                                             const string &group_string_p)\n+    : constant_pattern(constant_pattern), constant_string(constant_string), group_string(group_string_p),\n+      rewrite(group_string) {\n+}\n+\n+unique_ptr<FunctionData> RegexpExtractBindData::Copy() {\n+\treturn make_unique<RegexpExtractBindData>(constant_pattern, constant_string, group_string);\n+}\n+\n+static unique_ptr<FunctionData> RegexExtractBind(ClientContext &context, ScalarFunction &bound_function,\n+                                                 vector<unique_ptr<Expression>> &arguments) {\n+\tD_ASSERT(arguments.size() >= 2);\n+\n+\tbool constant_pattern = arguments[1]->IsFoldable();\n+\tstring pattern = \"\";\n+\tif (constant_pattern) {\n+\t\tValue pattern_str = ExpressionExecutor::EvaluateScalar(*arguments[1]);\n+\t\tif (!pattern_str.is_null && pattern_str.type().id() == LogicalTypeId::VARCHAR) {\n+\t\t\tpattern = pattern_str.str_value;\n+\t\t}\n+\t}\n+\n+\tstring group_string = \"\";\n+\tif (arguments.size() == 3) {\n+\t\tif (!arguments[2]->IsFoldable()) {\n+\t\t\tthrow InvalidInputException(\"Group index field field must be a constant!\");\n+\t\t}\n+\t\tValue group = ExpressionExecutor::EvaluateScalar(*arguments[2]);\n+\t\tif (!group.is_null) {\n+\t\t\tauto group_idx = group.GetValue<int32_t>();\n+\t\t\tif (group_idx < 0 || group_idx > 9) {\n+\t\t\t\tthrow InvalidInputException(\"Group index must be between 0 and 9!\");\n+\t\t\t}\n+\t\t\tgroup_string = \"\\\\\" + to_string(group_idx);\n+\t\t}\n+\t} else {\n+\t\tgroup_string = \"\\\\0\";\n+\t}\n+\n+\treturn make_unique<RegexpExtractBindData>(constant_pattern, pattern, group_string);\n+}\n+\n void RegexpFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunctionSet regexp_full_match(\"regexp_full_match\");\n \tregexp_full_match.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::BOOLEAN,\n@@ -227,9 +311,18 @@ void RegexpFun::RegisterFunction(BuiltinFunctions &set) {\n \t    ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR},\n \t                   LogicalType::VARCHAR, RegexReplaceFunction, false, RegexReplaceBind));\n \n+\tScalarFunctionSet regexp_extract(\"regexp_extract\");\n+\tregexp_extract.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::VARCHAR,\n+\t                                          RegexExtractFunction, false, RegexExtractBind, nullptr, nullptr,\n+\t                                          RegexExtractInitLocalState));\n+\tregexp_extract.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::INTEGER},\n+\t                                          LogicalType::VARCHAR, RegexExtractFunction, false, RegexExtractBind,\n+\t                                          nullptr, nullptr, RegexExtractInitLocalState));\n+\n \tset.AddFunction(regexp_full_match);\n \tset.AddFunction(regexp_partial_match);\n \tset.AddFunction(regexp_replace);\n+\tset.AddFunction(regexp_extract);\n }\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/function/scalar/regexp.hpp b/src/include/duckdb/function/scalar/regexp.hpp\nindex debf8881ea62..e259f83d35e8 100644\n--- a/src/include/duckdb/function/scalar/regexp.hpp\n+++ b/src/include/duckdb/function/scalar/regexp.hpp\n@@ -34,4 +34,16 @@ struct RegexpReplaceBindData : public FunctionData {\n \tunique_ptr<FunctionData> Copy() override;\n };\n \n+struct RegexpExtractBindData : public FunctionData {\n+\tRegexpExtractBindData(bool constant_pattern, const string &pattern, const string &group_string_p);\n+\n+\tconst bool constant_pattern;\n+\tconst string constant_string;\n+\n+\tconst string group_string;\n+\tconst duckdb_re2::StringPiece rewrite;\n+\n+\tunique_ptr<FunctionData> Copy() override;\n+};\n+\n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/function/string/regex_extract.test b/test/sql/function/string/regex_extract.test\nnew file mode 100644\nindex 000000000000..1bf6963b49a3\n--- /dev/null\n+++ b/test/sql/function/string/regex_extract.test\n@@ -0,0 +1,91 @@\n+# name: test/sql/function/string/regex_extract.test\n+# description: regex extract test\n+# group: [string]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query T\n+SELECT regexp_extract('foobarbaz', 'b..')\n+----\n+bar\n+\n+query T\n+SELECT regexp_extract('foobarbaz', 'b..', 1)\n+----\n+(empty)\n+\n+query T\n+SELECT regexp_extract('foobarbaz', '(b..)(b..)')\n+----\n+barbaz\n+\n+query T\n+SELECT regexp_extract('foobarbaz', '(b..)(b..)', 1)\n+----\n+bar\n+\n+query T\n+SELECT regexp_extract('foobarbaz', '(b..)(b..)', 2)\n+----\n+baz\n+\n+statement error\n+SELECT regexp_extract('foobarbaz', '(b..)(b..)', -1)\n+\n+statement error\n+SELECT regexp_extract('foobarbaz', '(b..)(b..)', 42)\n+\n+statement ok\n+CREATE TABLE test (s VARCHAR, p VARCHAR, i INT)\n+\n+statement ok\n+INSERT INTO test VALUES\n+    ('foobarbaz', 'b..', 0),\n+    ('foobarbaz', 'b..', 1),\n+    ('foobarbaz', '(b..)(b..)', 0),\n+    ('foobarbaz', '(b..)(b..)', 1),\n+    ('foobarbaz', '(b..)(b..)', 2)\n+\n+statement error\n+SELECT regexp_extract(s, p, i) FROM test\n+\n+query T\n+SELECT regexp_extract(s, p, 0) FROM test\n+----\n+bar\n+bar\n+barbaz\n+barbaz\n+barbaz\n+\n+query T\n+SELECT regexp_extract(s, 'b..', 0) FROM test\n+----\n+bar\n+bar\n+bar\n+bar\n+bar\n+\n+statement error\n+SELECT regexp_extract(s, '(b..)(b..)', i) FROM test\n+\n+# null values\n+query T\n+SELECT regexp_extract('foobarbaz', NULL, 0)\n+----\n+(empty)\n+\n+query T\n+SELECT regexp_extract('foobarbaz', 'b..', NULL)\n+----\n+(empty)\n+\n+query T\n+SELECT regexp_extract(NULL, 'b..')\n+----\n+NULL\n+\n+statement error\n+SELECT regexp_extract('foobarbaz', 'b..', '1')\n",
  "problem_statement": "Support for regexp_extract\nSometimes I need to extract nth appearance of some regexp-matching value. For example, 2nd `\\d{4}` in string. In spark I can do it with regexp_extract, but how will I do it in duckdb?\n",
  "hints_text": "I would recommend the string_split_regex function (which returns a list), and then just select the nth value of the list with the [n] syntax!\n@Alex-Monahan I thoought about it, but still can,t understand how should I do it. For example, I have string `mycomplex1886string1663` and need to obtain 1663 here. Could you please write example SQL based on `string_split_regex` to perform this task?\nOf course I mean that I always need 2nd entrance of `\\d{4}`, no matter how the string is organized\nMaybe you could invert the problem and split the string on text? Then you could grab the nth result from that list since only numbers would be left.\n@Alex-Monahan maybe I could, but strings are potentially very complex. We need to split by every non-number symbol and then take nth entrance, but TBH it looks almost unusable\nBut obviously, it won't solve the general problem , for example, if I need the second appearance of `[a-d]|[e-m]|[n-z]{11,14}|\\d+`\nHmm, well, I am not a regex expert, but maybe you could try another workaround. If you have another example that would help!\r\n\r\nHow about splitting on the inverse pattern, then grabbing the [n-1] list element, doing an INSTR to find the character position of it, and then a substring to grab what you want?\r\nSelect SUBSTR(text_col, INSTR(text_col, regex_list[2]),length(regex_list[2])) from (subquery that returns original text_col and regex_list)\nAh, that's not quite right. You need to offset by the length and calculate the next length by finding the INSTR of the nth element. \r\n\r\nIn any case, does that type of idea work as a workaround?\nOK, let's take a simple example actually. We need to find 5th word in \"Romeo and Juliet\" longer than 7 symbols. Regexp is quite simple: `[A-Z][a-z]{6,}`. Given your idea with invert regexp we should start by breaking the text into tokens. It will be something like `string_split_regex(text, '[ \\n\\r.,;-\u2014]')` and then we should somehow search In array, or unnest and filter by length. Both sound tricky and error-prone.\nI don't know C++, so I can't build the general solution for you - I'm just trying to help you in the meantime! Have you also had a look at the Python UDF capability? Maybe that would work well here.\r\n\r\nhttps://github.com/duckdb/duckdb/pull/1569\n@Alex-Monahan yeah, my issue was general feature request, thank yo very much for your help!\nI've been having a go at this, writing some tests now, hoping to send the PR soon.\n@lnkuiper so cool, thank you!",
  "created_at": "2021-11-03T16:55:41Z"
}