{
  "repo": "duckdb/duckdb",
  "pull_number": 9581,
  "instance_id": "duckdb__duckdb-9581",
  "issue_numbers": [
    "5328"
  ],
  "base_commit": "3f96a90635d351089a0214b8f1d11b7c7244e3bd",
  "patch": "diff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp\nindex 1400ad0f9217..38dc161cf96a 100644\n--- a/src/common/operator/cast_operators.cpp\n+++ b/src/common/operator/cast_operators.cpp\n@@ -4,6 +4,8 @@\n #include \"duckdb/common/operator/numeric_cast.hpp\"\n #include \"duckdb/common/operator/decimal_cast_operators.hpp\"\n #include \"duckdb/common/operator/multiply.hpp\"\n+#include \"duckdb/common/operator/add.hpp\"\n+#include \"duckdb/common/operator/subtract.hpp\"\n \n #include \"duckdb/common/exception.hpp\"\n #include \"duckdb/common/limits.hpp\"\n@@ -788,24 +790,25 @@ bool TryCast::Operation(double input, double &result, bool strict) {\n //===--------------------------------------------------------------------===//\n // Cast String -> Numeric\n //===--------------------------------------------------------------------===//\n+\n template <typename T>\n struct IntegerCastData {\n-\tusing Result = T;\n-\tResult result;\n-\tbool seen_decimal;\n+\tusing ResultType = T;\n+\tusing StoreType = T;\n+\tResultType result;\n };\n \n struct IntegerCastOperation {\n \ttemplate <class T, bool NEGATIVE>\n \tstatic bool HandleDigit(T &state, uint8_t digit) {\n-\t\tusing result_t = typename T::Result;\n+\t\tusing store_t = typename T::StoreType;\n \t\tif (NEGATIVE) {\n-\t\t\tif (state.result < (NumericLimits<result_t>::Minimum() + digit) / 10) {\n+\t\t\tif (DUCKDB_UNLIKELY(state.result < (NumericLimits<store_t>::Minimum() + digit) / 10)) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tstate.result = state.result * 10 - digit;\n \t\t} else {\n-\t\t\tif (state.result > (NumericLimits<result_t>::Maximum() - digit) / 10) {\n+\t\t\tif (DUCKDB_UNLIKELY(state.result > (NumericLimits<store_t>::Maximum() - digit) / 10)) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tstate.result = state.result * 10 + digit;\n@@ -815,8 +818,8 @@ struct IntegerCastOperation {\n \n \ttemplate <class T, bool NEGATIVE>\n \tstatic bool HandleHexDigit(T &state, uint8_t digit) {\n-\t\tusing result_t = typename T::Result;\n-\t\tif (state.result > (NumericLimits<result_t>::Maximum() - digit) / 16) {\n+\t\tusing store_t = typename T::StoreType;\n+\t\tif (DUCKDB_UNLIKELY(state.result > (NumericLimits<store_t>::Maximum() - digit) / 16)) {\n \t\t\treturn false;\n \t\t}\n \t\tstate.result = state.result * 16 + digit;\n@@ -825,8 +828,8 @@ struct IntegerCastOperation {\n \n \ttemplate <class T, bool NEGATIVE>\n \tstatic bool HandleBinaryDigit(T &state, uint8_t digit) {\n-\t\tusing result_t = typename T::Result;\n-\t\tif (state.result > (NumericLimits<result_t>::Maximum() - digit) / 2) {\n+\t\tusing store_t = typename T::StoreType;\n+\t\tif (DUCKDB_UNLIKELY(state.result > (NumericLimits<store_t>::Maximum() - digit) / 2)) {\n \t\t\treturn false;\n \t\t}\n \t\tstate.result = state.result * 2 + digit;\n@@ -834,46 +837,143 @@ struct IntegerCastOperation {\n \t}\n \n \ttemplate <class T, bool NEGATIVE>\n-\tstatic bool HandleExponent(T &state, int32_t exponent) {\n-\t\tusing result_t = typename T::Result;\n-\t\tdouble dbl_res = state.result * std::pow(10.0L, exponent);\n-\t\tif (dbl_res < (double)NumericLimits<result_t>::Minimum() ||\n-\t\t    dbl_res > (double)NumericLimits<result_t>::Maximum()) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tstate.result = (result_t)std::nearbyint(dbl_res);\n-\t\treturn true;\n+\tstatic bool HandleExponent(T &state, int16_t exponent) {\n+\t\t// Simple integers don't deal with Exponents\n+\t\treturn false;\n \t}\n \n \ttemplate <class T, bool NEGATIVE, bool ALLOW_EXPONENT>\n \tstatic bool HandleDecimal(T &state, uint8_t digit) {\n-\t\tif (state.seen_decimal) {\n-\t\t\treturn true;\n-\t\t}\n-\t\tstate.seen_decimal = true;\n-\t\t// round the integer based on what is after the decimal point\n-\t\t// if digit >= 5, then we round up (or down in case of negative numbers)\n-\t\tauto increment = digit >= 5;\n-\t\tif (!increment) {\n-\t\t\treturn true;\n+\t\t// Simple integers don't deal with Decimals\n+\t\treturn false;\n+\t}\n+\n+\ttemplate <class T, bool NEGATIVE>\n+\tstatic bool Finalize(T &state) {\n+\t\treturn true;\n+\t}\n+};\n+\n+template <typename T>\n+struct IntegerDecimalCastData {\n+\tusing ResultType = T;\n+\tusing StoreType = int64_t;\n+\tStoreType result;\n+\tStoreType decimal;\n+\tuint16_t decimal_digits;\n+};\n+\n+template <>\n+struct IntegerDecimalCastData<uint64_t> {\n+\tusing ResultType = uint64_t;\n+\tusing StoreType = uint64_t;\n+\tStoreType result;\n+\tStoreType decimal;\n+\tuint16_t decimal_digits;\n+};\n+\n+struct IntegerDecimalCastOperation : IntegerCastOperation {\n+\ttemplate <class T, bool NEGATIVE>\n+\tstatic bool HandleExponent(T &state, int16_t exponent) {\n+\t\tusing store_t = typename T::StoreType;\n+\n+\t\tint16_t e = exponent;\n+\t\t// Negative Exponent\n+\t\tif (e < 0) {\n+\t\t\twhile (state.result != 0 && e++ < 0) {\n+\t\t\t\tstate.decimal = state.result % 10;\n+\t\t\t\tstate.result /= 10;\n+\t\t\t}\n+\t\t\tif (state.decimal < 0) {\n+\t\t\t\tstate.decimal = -state.decimal;\n+\t\t\t}\n+\t\t\tstate.decimal_digits = 1;\n+\t\t\treturn Finalize<T, NEGATIVE>(state);\n \t\t}\n-\t\tif (NEGATIVE) {\n-\t\t\tif (state.result == NumericLimits<typename T::Result>::Minimum()) {\n+\n+\t\t// Positive Exponent\n+\t\twhile (state.result != 0 && e-- > 0) {\n+\t\t\tif (!TryMultiplyOperator::Operation(state.result, (store_t)10, state.result)) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tstate.result--;\n+\t\t}\n+\n+\t\tif (state.decimal == 0) {\n+\t\t\treturn Finalize<T, NEGATIVE>(state);\n+\t\t}\n+\n+\t\t// Handle decimals\n+\t\te = exponent - state.decimal_digits;\n+\t\tstore_t remainder = 0;\n+\t\tif (e < 0) {\n+\t\t\tif (static_cast<uint16_t>(-e) <= NumericLimits<store_t>::Digits()) {\n+\t\t\t\tstore_t power = 1;\n+\t\t\t\twhile (e++ < 0) {\n+\t\t\t\t\tpower *= 10;\n+\t\t\t\t}\n+\t\t\t\tremainder = state.decimal % power;\n+\t\t\t\tstate.decimal /= power;\n+\t\t\t} else {\n+\t\t\t\tstate.decimal = 0;\n+\t\t\t}\n \t\t} else {\n-\t\t\tif (state.result == NumericLimits<typename T::Result>::Maximum()) {\n+\t\t\twhile (e-- > 0) {\n+\t\t\t\tif (!TryMultiplyOperator::Operation(state.decimal, (store_t)10, state.decimal)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tstate.decimal_digits -= exponent;\n+\n+\t\tif (NEGATIVE) {\n+\t\t\tif (!TrySubtractOperator::Operation(state.result, state.decimal, state.result)) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tstate.result++;\n+\t\t} else if (!TryAddOperator::Operation(state.result, state.decimal, state.result)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tstate.decimal = remainder;\n+\t\treturn Finalize<T, NEGATIVE>(state);\n+\t}\n+\n+\ttemplate <class T, bool NEGATIVE, bool ALLOW_EXPONENT>\n+\tstatic bool HandleDecimal(T &state, uint8_t digit) {\n+\t\tusing store_t = typename T::StoreType;\n+\t\tif (DUCKDB_UNLIKELY(state.decimal > (NumericLimits<store_t>::Maximum() - digit) / 10)) {\n+\t\t\t// Simply ignore any more decimals\n+\t\t\treturn true;\n \t\t}\n+\t\tstate.decimal_digits++;\n+\t\tstate.decimal = state.decimal * 10 + digit;\n \t\treturn true;\n \t}\n \n \ttemplate <class T, bool NEGATIVE>\n \tstatic bool Finalize(T &state) {\n-\t\treturn true;\n+\t\tusing result_t = typename T::ResultType;\n+\t\tusing store_t = typename T::StoreType;\n+\n+\t\tresult_t tmp;\n+\t\tif (!TryCast::Operation<store_t, result_t>(state.result, tmp)) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\twhile (state.decimal > 10) {\n+\t\t\tstate.decimal /= 10;\n+\t\t\tstate.decimal_digits--;\n+\t\t}\n+\n+\t\tbool success = true;\n+\t\tif (state.decimal_digits == 1 && state.decimal >= 5) {\n+\t\t\tif (NEGATIVE) {\n+\t\t\t\tsuccess = TrySubtractOperator::Operation(tmp, (result_t)1, tmp);\n+\t\t\t} else {\n+\t\t\t\tsuccess = TryAddOperator::Operation(tmp, (result_t)1, tmp);\n+\t\t\t}\n+\t\t}\n+\t\tstate.result = tmp;\n+\t\treturn success;\n \t}\n };\n \n@@ -943,8 +1043,8 @@ static bool IntegerCastLoop(const char *buf, idx_t len, T &result, bool strict)\n \t\t\t\t\tif (pos >= len) {\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n-\t\t\t\t\tusing ExponentData = IntegerCastData<int32_t>;\n-\t\t\t\t\tExponentData exponent {0, false};\n+\t\t\t\t\tusing ExponentData = IntegerCastData<int16_t>;\n+\t\t\t\t\tExponentData exponent {};\n \t\t\t\t\tint negative = buf[pos] == '-';\n \t\t\t\t\tif (negative) {\n \t\t\t\t\t\tif (!IntegerCastLoop<ExponentData, true, false, IntegerCastOperation, decimal_separator>(\n@@ -1088,9 +1188,19 @@ static bool TryIntegerCast(const char *buf, idx_t len, T &result, bool strict) {\n \n template <typename T, bool IS_SIGNED = true>\n static inline bool TrySimpleIntegerCast(const char *buf, idx_t len, T &result, bool strict) {\n-\tIntegerCastData<T> data;\n-\tif (TryIntegerCast<IntegerCastData<T>, IS_SIGNED>(buf, len, data, strict)) {\n-\t\tresult = data.result;\n+\tIntegerCastData<T> simple_data;\n+\tif (TryIntegerCast<IntegerCastData<T>, IS_SIGNED, false, IntegerCastOperation>(buf, len, simple_data, strict)) {\n+\t\tresult = (T)simple_data.result;\n+\t\treturn true;\n+\t}\n+\n+\t// Simple integer cast failed, try again with decimals/exponents included\n+\t// FIXME: This could definitely be improved as some extra work is being done here. It is more important that\n+\t//  \"normal\" integers (without exponent/decimals) are still being parsed quickly.\n+\tIntegerDecimalCastData<T> cast_data;\n+\tif (TryIntegerCast<IntegerDecimalCastData<T>, IS_SIGNED, true, IntegerDecimalCastOperation>(buf, len, cast_data,\n+\t                                                                                            strict)) {\n+\t\tresult = (T)cast_data.result;\n \t\treturn true;\n \t}\n \treturn false;\n@@ -1719,130 +1829,199 @@ bool TryCastErrorMessage::Operation(string_t input, interval_t &result, string *\n // when that value is full, we perform a HUGEINT multiplication to flush it into the hugeint\n // this takes the number of HUGEINT multiplications down from [0-38] to [0-2]\n struct HugeIntCastData {\n-\thugeint_t hugeint;\n+\thugeint_t result;\n \tint64_t intermediate;\n \tuint8_t digits;\n-\tbool decimal;\n+\n+\thugeint_t decimal;\n+\tuint16_t decimal_total_digits;\n+\tint64_t decimal_intermediate;\n+\tuint16_t decimal_intermediate_digits;\n \n \tbool Flush() {\n \t\tif (digits == 0 && intermediate == 0) {\n \t\t\treturn true;\n \t\t}\n-\t\tif (hugeint.lower != 0 || hugeint.upper != 0) {\n+\t\tif (result.lower != 0 || result.upper != 0) {\n \t\t\tif (digits > 38) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tif (!Hugeint::TryMultiply(hugeint, Hugeint::POWERS_OF_TEN[digits], hugeint)) {\n+\t\t\tif (!Hugeint::TryMultiply(result, Hugeint::POWERS_OF_TEN[digits], result)) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n-\t\tif (!Hugeint::AddInPlace(hugeint, hugeint_t(intermediate))) {\n+\t\tif (!Hugeint::AddInPlace(result, hugeint_t(intermediate))) {\n \t\t\treturn false;\n \t\t}\n \t\tdigits = 0;\n \t\tintermediate = 0;\n \t\treturn true;\n \t}\n+\n+\tbool FlushDecimal() {\n+\t\tif (decimal_intermediate_digits == 0 && decimal_intermediate == 0) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (decimal.lower != 0 || decimal.upper != 0) {\n+\t\t\tif (decimal_intermediate_digits > 38) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!Hugeint::TryMultiply(decimal, Hugeint::POWERS_OF_TEN[decimal_intermediate_digits], decimal)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\tif (!Hugeint::AddInPlace(decimal, hugeint_t(decimal_intermediate))) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tdecimal_total_digits += decimal_intermediate_digits;\n+\t\tdecimal_intermediate_digits = 0;\n+\t\tdecimal_intermediate = 0;\n+\t\treturn true;\n+\t}\n };\n \n struct HugeIntegerCastOperation {\n \ttemplate <class T, bool NEGATIVE>\n-\tstatic bool HandleDigit(T &result, uint8_t digit) {\n+\tstatic bool HandleDigit(T &state, uint8_t digit) {\n \t\tif (NEGATIVE) {\n-\t\t\tif (result.intermediate < (NumericLimits<int64_t>::Minimum() + digit) / 10) {\n+\t\t\tif (DUCKDB_UNLIKELY(state.intermediate < (NumericLimits<int64_t>::Minimum() + digit) / 10)) {\n \t\t\t\t// intermediate is full: need to flush it\n-\t\t\t\tif (!result.Flush()) {\n+\t\t\t\tif (!state.Flush()) {\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tresult.intermediate = result.intermediate * 10 - digit;\n+\t\t\tstate.intermediate = state.intermediate * 10 - digit;\n \t\t} else {\n-\t\t\tif (result.intermediate > (NumericLimits<int64_t>::Maximum() - digit) / 10) {\n-\t\t\t\tif (!result.Flush()) {\n+\t\t\tif (DUCKDB_UNLIKELY(state.intermediate > (NumericLimits<int64_t>::Maximum() - digit) / 10)) {\n+\t\t\t\tif (!state.Flush()) {\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tresult.intermediate = result.intermediate * 10 + digit;\n+\t\t\tstate.intermediate = state.intermediate * 10 + digit;\n \t\t}\n-\t\tresult.digits++;\n+\t\tstate.digits++;\n \t\treturn true;\n \t}\n \n \ttemplate <class T, bool NEGATIVE>\n-\tstatic bool HandleHexDigit(T &result, uint8_t digit) {\n+\tstatic bool HandleHexDigit(T &state, uint8_t digit) {\n \t\treturn false;\n \t}\n \n \ttemplate <class T, bool NEGATIVE>\n-\tstatic bool HandleBinaryDigit(T &result, uint8_t digit) {\n-\t\tif (result.intermediate > (NumericLimits<int64_t>::Maximum() - digit) / 2) {\n-\t\t\t// intermediate is full: need to flush it\n-\t\t\tif (!result.Flush()) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\tresult.intermediate = result.intermediate * 2 + digit;\n-\t\tresult.digits++;\n-\t\treturn true;\n+\tstatic bool HandleBinaryDigit(T &state, uint8_t digit) {\n+\t\treturn false;\n \t}\n \n \ttemplate <class T, bool NEGATIVE>\n-\tstatic bool HandleExponent(T &result, int32_t exponent) {\n-\t\tif (!result.Flush()) {\n+\tstatic bool HandleExponent(T &state, int32_t exponent) {\n+\t\tif (!state.Flush()) {\n \t\t\treturn false;\n \t\t}\n-\t\tif (exponent < -38 || exponent > 38) {\n-\t\t\t// out of range for exact exponent: use double and convert\n-\t\t\tdouble dbl_res = Hugeint::Cast<double>(result.hugeint) * std::pow(10.0L, exponent);\n-\t\t\tif (dbl_res < Hugeint::Cast<double>(NumericLimits<hugeint_t>::Minimum()) ||\n-\t\t\t    dbl_res > Hugeint::Cast<double>(NumericLimits<hugeint_t>::Maximum())) {\n+\n+\t\tint32_t e = exponent;\n+\t\tif (e < -38) {\n+\t\t\tstate.result = 0;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t// Negative Exponent\n+\t\thugeint_t remainder = 0;\n+\t\tif (e < 0) {\n+\t\t\tstate.result = Hugeint::DivMod(state.result, Hugeint::POWERS_OF_TEN[-e], remainder);\n+\t\t\tstate.decimal = remainder;\n+\t\t\tstate.decimal_total_digits = -e;\n+\t\t\tstate.decimal_intermediate = 0;\n+\t\t\tstate.decimal_intermediate_digits = 0;\n+\t\t\treturn Finalize<T, NEGATIVE>(state);\n+\t\t}\n+\n+\t\t// Positive Exponent\n+\t\tif (state.result != 0) {\n+\t\t\tif (e > 38 || !TryMultiplyOperator::Operation(state.result, Hugeint::POWERS_OF_TEN[e], state.result)) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tresult.hugeint = Hugeint::Convert(dbl_res);\n-\t\t\treturn true;\n \t\t}\n-\t\tif (exponent < 0) {\n-\t\t\t// negative exponent: divide by power of 10\n-\t\t\tresult.hugeint = Hugeint::Divide(result.hugeint, Hugeint::POWERS_OF_TEN[-exponent]);\n-\t\t\treturn true;\n+\t\tif (!state.FlushDecimal()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (state.decimal == 0) {\n+\t\t\treturn Finalize<T, NEGATIVE>(state);\n+\t\t}\n+\n+\t\te = exponent - state.decimal_total_digits;\n+\t\tif (e < 0) {\n+\t\t\tstate.decimal = Hugeint::DivMod(state.decimal, Hugeint::POWERS_OF_TEN[-e], remainder);\n+\t\t\tstate.decimal_total_digits -= (exponent);\n \t\t} else {\n-\t\t\t// positive exponent: multiply by power of 10\n-\t\t\treturn Hugeint::TryMultiply(result.hugeint, Hugeint::POWERS_OF_TEN[exponent], result.hugeint);\n+\t\t\tif (e > 38 || !TryMultiplyOperator::Operation(state.decimal, Hugeint::POWERS_OF_TEN[e], state.decimal)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (NEGATIVE) {\n+\t\t\tif (!TrySubtractOperator::Operation(state.result, state.decimal, state.result)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t} else if (!TryAddOperator::Operation(state.result, state.decimal, state.result)) {\n+\t\t\treturn false;\n \t\t}\n+\t\tstate.decimal = remainder;\n+\t\treturn Finalize<T, NEGATIVE>(state);\n \t}\n \n \ttemplate <class T, bool NEGATIVE, bool ALLOW_EXPONENT>\n-\tstatic bool HandleDecimal(T &result, uint8_t digit) {\n-\t\t// Integer casts round\n-\t\tif (!result.decimal) {\n-\t\t\tif (!result.Flush()) {\n+\tstatic bool HandleDecimal(T &state, uint8_t digit) {\n+\t\tif (!state.Flush()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (DUCKDB_UNLIKELY(state.decimal_intermediate > (NumericLimits<int64_t>::Maximum() - digit) / 10)) {\n+\t\t\tif (!state.FlushDecimal()) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tif (NEGATIVE) {\n-\t\t\t\tresult.intermediate = -(digit >= 5);\n-\t\t\t} else {\n-\t\t\t\tresult.intermediate = (digit >= 5);\n-\t\t\t}\n \t\t}\n-\t\tresult.decimal = true;\n-\n+\t\tstate.decimal_intermediate = state.decimal_intermediate * 10 + digit;\n+\t\tstate.decimal_intermediate_digits++;\n \t\treturn true;\n \t}\n \n \ttemplate <class T, bool NEGATIVE>\n-\tstatic bool Finalize(T &result) {\n-\t\treturn result.Flush();\n+\tstatic bool Finalize(T &state) {\n+\t\tif (!state.Flush() || !state.FlushDecimal()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (state.decimal == 0 || state.decimal_total_digits == 0) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t// Get the first (left-most) digit of the decimals\n+\t\twhile (state.decimal_total_digits > 39) {\n+\t\t\tstate.decimal /= Hugeint::POWERS_OF_TEN[39];\n+\t\t\tstate.decimal_total_digits -= 39;\n+\t\t}\n+\t\tD_ASSERT((state.decimal_total_digits - 1) >= 0 && (state.decimal_total_digits - 1) <= 39);\n+\t\tstate.decimal /= Hugeint::POWERS_OF_TEN[state.decimal_total_digits - 1];\n+\n+\t\tif (state.decimal >= 5 || state.decimal <= -5) {\n+\t\t\tif (NEGATIVE) {\n+\t\t\t\treturn TrySubtractOperator::Operation(state.result, hugeint_t(1), state.result);\n+\t\t\t} else {\n+\t\t\t\treturn TryAddOperator::Operation(state.result, hugeint_t(1), state.result);\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n \t}\n };\n \n template <>\n bool TryCast::Operation(string_t input, hugeint_t &result, bool strict) {\n-\tHugeIntCastData data;\n-\tif (!TryIntegerCast<HugeIntCastData, true, true, HugeIntegerCastOperation>(input.GetData(), input.GetSize(), data,\n+\tHugeIntCastData state {};\n+\tif (!TryIntegerCast<HugeIntCastData, true, true, HugeIntegerCastOperation>(input.GetData(), input.GetSize(), state,\n \t                                                                           strict)) {\n \t\treturn false;\n \t}\n-\tresult = data.hugeint;\n+\tresult = state.result;\n \treturn true;\n }\n \n@@ -1850,10 +2029,10 @@ bool TryCast::Operation(string_t input, hugeint_t &result, bool strict) {\n // Decimal String Cast\n //===--------------------------------------------------------------------===//\n \n-template <class TYPE>\n+template <class T>\n struct DecimalCastData {\n-\ttypedef TYPE type_t;\n-\tTYPE result;\n+\tusing StoreType = T;\n+\tStoreType result;\n \tuint8_t width;\n \tuint8_t scale;\n \tuint8_t digit_count;\n@@ -1881,12 +2060,12 @@ struct DecimalCastOperation {\n \t\t}\n \t\tstate.digit_count++;\n \t\tif (NEGATIVE) {\n-\t\t\tif (state.result < (NumericLimits<typename T::type_t>::Minimum() / 10)) {\n+\t\t\tif (state.result < (NumericLimits<typename T::StoreType>::Minimum() / 10)) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tstate.result = state.result * 10 - digit;\n \t\t} else {\n-\t\t\tif (state.result > (NumericLimits<typename T::type_t>::Maximum() / 10)) {\n+\t\t\tif (state.result > (NumericLimits<typename T::StoreType>::Maximum() / 10)) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tstate.result = state.result * 10 + digit;\n",
  "test_patch": "diff --git a/test/common/test_cast.cpp b/test/common/test_cast.cpp\nindex e753d929f9d3..3085e2da51fc 100644\n--- a/test/common/test_cast.cpp\n+++ b/test/common/test_cast.cpp\n@@ -155,7 +155,7 @@ TEST_CASE(\"Test casting to int8_t\", \"[cast]\") {\n \t                                            \"1e-\",\n \t                                            \"1e100\",\n \t                                            \"1e100000000\",\n-\t                                            \"1000e-1\",\n+\t                                            \"10000e-1\",\n \t                                            \" 3 2\",\n \t                                            \"+\"};\n \tTestStringCast<int8_t>(working_values_str, expected_values_str, broken_values_str);\ndiff --git a/test/sql/cast/string_to_integer_decimal_cast.test b/test/sql/cast/string_to_integer_decimal_cast.test\nnew file mode 100644\nindex 000000000000..583fc93dc25b\n--- /dev/null\n+++ b/test/sql/cast/string_to_integer_decimal_cast.test\n@@ -0,0 +1,180 @@\n+# name: test/sql/cast/string_to_integer_decimal_cast.test\n+# description: String to Integer casts with Decimals\n+# group: [cast]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# Positive numbers (includes unsigned)\n+foreach type <integral>\n+\n+query I\n+select '0.000005'::${type};\n+----\n+0\n+\n+query I\n+select '1.100004'::${type};\n+----\n+1\n+\n+query I\n+select '0.5'::${type};\n+----\n+1\n+\n+query I\n+select '1.50004'::${type};\n+----\n+2\n+\n+\n+endloop\n+\n+# Negative numbers (excludes unsigned)\n+foreach type <signed>\n+\n+query I\n+select '-0.000005'::${type};\n+----\n+0\n+\n+query I\n+select '-1.100004'::${type};\n+----\n+-1\n+\n+query I\n+select '-0.5'::${type};\n+----\n+-1\n+\n+query I\n+select '-1.50004'::${type};\n+----\n+-2\n+\n+endloop\n+\n+# Check limits (signed)\n+\n+query II\n+select '127.1'::TINYINT, '-128.1'::TINYINT;\n+----\n+127\t-128\n+\n+query II\n+select '32767.1'::SMALLINT, '-32768.1'::SMALLINT;\n+----\n+32767\t-32768\n+\n+query II\n+select '2147483647.1'::INTEGER, '-2147483648.1'::INTEGER;\n+----\n+2147483647\t-2147483648\n+\n+query II\n+select '9223372036854775807.1'::BIGINT, '-9223372036854775808.1'::BIGINT;\n+----\n+9223372036854775807\t-9223372036854775808\n+\n+query II\n+select '170141183460469231731687303715884105727.1'::HUGEINT, '-170141183460469231731687303715884105728.1'::HUGEINT;\n+----\n+170141183460469231731687303715884105727\t-170141183460469231731687303715884105728\n+\n+# Check limits (unsigned)\n+\n+query I\n+select '255.1'::UTINYINT;\n+----\n+255\n+\n+query I\n+select '65535.1'::USMALLINT;\n+----\n+65535\n+\n+query I\n+select '4294967295.1'::UINTEGER;\n+----\n+4294967295\n+\n+query I\n+select '18446744073709551615.1'::UBIGINT;\n+----\n+18446744073709551615\n+\n+# going over limit should error (signed)\n+\n+statement error\n+select '127.5'::TINYINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '32767.5'::SMALLINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '2147483647.5'::INTEGER;\n+----\n+Conversion Error\n+\n+statement error\n+select '9223372036854775807.5'::BIGINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '170141183460469231731687303715884105727.5'::HUGEINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '-128.5'::TINYINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '-32768.5'::SMALLINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '-2147483648.5'::INTEGER;\n+----\n+Conversion Error\n+\n+statement error\n+select '-9223372036854775808.5'::BIGINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '-170141183460469231731687303715884105728.5'::HUGEINT;\n+----\n+Conversion Error\n+\n+# going over limit should error (unsigned)\n+\n+statement error\n+select '255.5'::UTINYINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '65535.5'::USMALLINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '4294967295.5'::UINTEGER;\n+----\n+Conversion Error\n+\n+statement error\n+select '18446744073709551615.5'::UBIGINT;\n+----\n+Conversion Error\n\\ No newline at end of file\ndiff --git a/test/sql/cast/string_to_integer_exponent_cast.test b/test/sql/cast/string_to_integer_exponent_cast.test\nnew file mode 100644\nindex 000000000000..5894873e4956\n--- /dev/null\n+++ b/test/sql/cast/string_to_integer_exponent_cast.test\n@@ -0,0 +1,284 @@\n+# name: test/sql/cast/string_to_integer_exponent_cast.test\n+# description: String to Integer casts with Decimals and Exponents\n+# group: [cast]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# Positive numbers (includes unsigned)\n+foreach type <integral>\n+\n+# Positive Number - Positive Exponent\n+\n+query I\n+select '1e2'::${type};\n+----\n+100\n+\n+query I\n+select '1.23e2'::${type};\n+----\n+123\n+\n+query I\n+select '1.234e2'::${type};\n+----\n+123\n+\n+query I\n+select '1.235e2'::${type};\n+----\n+124\n+\n+# Positive Number - Negative Exponent\n+\n+query I\n+select '1e-2'::${type};\n+----\n+0\n+\n+query I\n+select '123.456e-2'::${type};\n+----\n+1\n+\n+query I\n+select '1584.92e-2'::${type};\n+----\n+16\n+\n+query I\n+select '1214.235e-2'::${type};\n+----\n+12\n+\n+# Out of range\n+\n+statement error\n+select '10e40'::${type};\n+----\n+Conversion Error\n+\n+endloop\n+\n+# Negative numbers (excludes unsigned)\n+foreach type <signed>\n+\n+# Negative Number - Positive Exponent\n+\n+query I\n+select '-1e2'::${type};\n+----\n+-100\n+\n+query I\n+select '-1.23456e2'::${type};\n+----\n+-123\n+\n+query I\n+select '-0.158492e2'::${type};\n+----\n+-16\n+\n+query I\n+select '-1.235e2'::${type};\n+----\n+-124\n+\n+# Negative Number - Negative Exponent\n+\n+query I\n+select '-100e-2'::${type};\n+----\n+-1\n+\n+query I\n+select '-50.23456e-2'::${type};\n+----\n+-1\n+\n+query I\n+select '-1584.92e-2'::${type};\n+----\n+-16\n+\n+query I\n+select '-1.235e-2'::${type};\n+----\n+0\n+\n+statement error\n+select '-10e40'::${type};\n+----\n+Conversion Error\n+\n+endloop\n+\n+# Check limits (signed)\n+\n+query II\n+select '12.7e1'::TINYINT, '-12.8e1'::TINYINT;\n+----\n+127\t-128\n+\n+query II\n+select '3276.7e1'::SMALLINT, '-3276.8e1'::SMALLINT;\n+----\n+32767\t-32768\n+\n+query II\n+select '214748364.7e1'::INTEGER, '-214748364.8e1'::INTEGER;\n+----\n+2147483647\t-2147483648\n+\n+query II\n+select '922337203685477580.7e1'::BIGINT, '-922337203685477580.8e1'::BIGINT;\n+----\n+9223372036854775807\t-9223372036854775808\n+\n+query II\n+select '17014118346046923173168730371588410572.7e1'::HUGEINT, '-17014118346046923173168730371588410572.8e1'::HUGEINT;\n+----\n+170141183460469231731687303715884105727\t-170141183460469231731687303715884105728\n+\n+# Check limits (unsigned)\n+\n+query I\n+select '25.5e1'::UTINYINT;\n+----\n+255\n+\n+query I\n+select '6553.5e1'::USMALLINT;\n+----\n+65535\n+\n+query I\n+select '429496729.5e1'::UINTEGER;\n+----\n+4294967295\n+\n+query I\n+select '1844674407370955161.5e1'::UBIGINT;\n+----\n+18446744073709551615\n+\n+# going over limit should error (signed)\n+\n+statement error\n+select '12.8e1'::TINYINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '3276.8e1'::SMALLINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '214748364.8e1'::INTEGER;\n+----\n+Conversion Error\n+\n+statement error\n+select '922337203685477580.8e1'::BIGINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '17014118346046923173168730371588410572.8e1'::HUGEINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '-12.9e1'::TINYINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '-3276.9e1'::SMALLINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '-214748364.9e1'::INTEGER;\n+----\n+Conversion Error\n+\n+statement error\n+select '-922337203685477580.9e1'::BIGINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '-17014118346046923173168730371588410572.9e1'::HUGEINT;\n+----\n+Conversion Error\n+\n+# going over limit should error (unsigned)\n+\n+statement error\n+select '25.6e1'::UTINYINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '6553.6e1'::USMALLINT;\n+----\n+Conversion Error\n+\n+statement error\n+select '429496729.6e1'::UINTEGER;\n+----\n+Conversion Error\n+\n+statement error\n+select '1844674407370955161.6e1'::UBIGINT;\n+----\n+Conversion Error\n+\n+# exponent limit\n+\n+statement error\n+select '1e100000'::int;\n+----\n+Conversion Error\n+\n+statement error\n+select '1e-100000'::int;\n+----\n+Conversion Error\n+\n+# some more \"extreme\" cases\n+\n+query I\n+select '0.00000000000000000000000000000009223372036854775807e50'::BIGINT;\n+----\n+9223372036854775807\n+\n+query I\n+select '-0.00000000000000000000000000000009223372036854775807e50'::BIGINT;\n+----\n+-9223372036854775807\n+\n+query I\n+select '0.00000000000170141183460469231731687303715884105727e50'::HUGEINT;\n+----\n+170141183460469231731687303715884105727\n+\n+query I\n+select '-0.00000000000170141183460469231731687303715884105727e50'::HUGEINT;\n+----\n+-170141183460469231731687303715884105727\n+\n+query I\n+select '15123456789e-32768'::int;\n+----\n+0\n+\n+query I\n+select '0e32767'::int;\n+----\n+0\n+\ndiff --git a/test/sql/types/decimal/decimal_exponent.test b/test/sql/types/decimal/decimal_exponent.test\nindex 890d683fca13..be0044475ff0 100644\n--- a/test/sql/types/decimal/decimal_exponent.test\n+++ b/test/sql/types/decimal/decimal_exponent.test\n@@ -31,7 +31,7 @@ SELECT '1e-100'::DECIMAL\n \n # large negative exponent\n query I\n-SELECT '1e-99999999'::DECIMAL\n+SELECT '1e-9999'::DECIMAL\n ----\n 0\n \n",
  "problem_statement": "String to HUGEINT cast bug\n### What happens?\n\nCasting from string to hugeint behaves incorrect.\n\n### To Reproduce\n\n```sql\r\nD  select '1.8259857912588366e+37'::hugeint;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 CAST('1.8259857912588366e+37' AS HUGEINT) \u2502\r\n\u2502                  int128                   \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502    20000000000000000000000000000000000000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nBut this works.\r\n```sql\r\nD select 1.8259857912588366e+37::hugeint;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 CAST(1.8259857912588366e+37 AS HUGEINT) \u2502\r\n\u2502                 int128                  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502  18259857912588365870837119913054699520 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n\n### OS:\n\niOS\n\n### DuckDB Version:\n\nmaster\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nTania Bogatsch\n\n### Affiliation:\n\nDuckDB Labs\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-11-06T13:34:15Z"
}