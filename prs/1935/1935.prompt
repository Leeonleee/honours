You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
use INTERVAL function Time out of bounds report error
<version>0.2.7</version>
today is 6.30
in postgres
![image](https://user-images.githubusercontent.com/86718222/123948415-f5cb4b80-d9d3-11eb-906a-41cd69043125.png)


in duckdb

 ** preparedStatement = conn.prepareStatement("SELECT CURRENT_DATE - INTERVAL '4 MONTH';");
    rs = preparedStatement.executeQuery();**

![image](https://user-images.githubusercontent.com/86718222/123948532-14314700-d9d4-11eb-88ea-e9c727696dfa.png)




</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/common/types/date.cpp]
1: #include "duckdb/common/types/date.hpp"
2: #include "duckdb/common/types/timestamp.hpp"
3: #include "duckdb/common/types/interval.hpp"
4: #include "duckdb/common/types/cast_helpers.hpp"
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/common/string_util.hpp"
7: #include "duckdb/common/assert.hpp"
8: #include "duckdb/common/limits.hpp"
9: 
10: #include <cstring>
11: #include <cctype>
12: #include <algorithm>
13: 
14: namespace duckdb {
15: 
16: static_assert(sizeof(date_t) == sizeof(int32_t), "date_t was padded");
17: 
18: const string_t Date::MONTH_NAMES_ABBREVIATED[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
19:                                                   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
20: const string_t Date::MONTH_NAMES[] = {"January", "February", "March",     "April",   "May",      "June",
21:                                       "July",    "August",   "September", "October", "November", "December"};
22: const string_t Date::DAY_NAMES[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
23: const string_t Date::DAY_NAMES_ABBREVIATED[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
24: 
25: const int32_t Date::NORMAL_DAYS[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
26: const int32_t Date::CUMULATIVE_DAYS[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
27: const int32_t Date::LEAP_DAYS[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
28: const int32_t Date::CUMULATIVE_LEAP_DAYS[] = {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
29: const int8_t Date::MONTH_PER_DAY_OF_YEAR[] = {
30:     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
31:     1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
32:     2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
33:     3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
34:     4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
35:     5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
36:     6,  6,  6,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
37:     7,  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,
38:     8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,
39:     9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
40:     10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
41:     11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
42:     12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12};
43: const int8_t Date::LEAP_MONTH_PER_DAY_OF_YEAR[] = {
44:     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
45:     1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
46:     2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
47:     3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
48:     4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
49:     5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
50:     6,  6,  6,  6,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
51:     7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,
52:     8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,
53:     9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
54:     10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
55:     11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
56:     12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12};
57: const int32_t Date::CUMULATIVE_YEAR_DAYS[] = {
58:     0,      365,    730,    1096,   1461,   1826,   2191,   2557,   2922,   3287,   3652,   4018,   4383,   4748,
59:     5113,   5479,   5844,   6209,   6574,   6940,   7305,   7670,   8035,   8401,   8766,   9131,   9496,   9862,
60:     10227,  10592,  10957,  11323,  11688,  12053,  12418,  12784,  13149,  13514,  13879,  14245,  14610,  14975,
61:     15340,  15706,  16071,  16436,  16801,  17167,  17532,  17897,  18262,  18628,  18993,  19358,  19723,  20089,
62:     20454,  20819,  21184,  21550,  21915,  22280,  22645,  23011,  23376,  23741,  24106,  24472,  24837,  25202,
63:     25567,  25933,  26298,  26663,  27028,  27394,  27759,  28124,  28489,  28855,  29220,  29585,  29950,  30316,
64:     30681,  31046,  31411,  31777,  32142,  32507,  32872,  33238,  33603,  33968,  34333,  34699,  35064,  35429,
65:     35794,  36160,  36525,  36890,  37255,  37621,  37986,  38351,  38716,  39082,  39447,  39812,  40177,  40543,
66:     40908,  41273,  41638,  42004,  42369,  42734,  43099,  43465,  43830,  44195,  44560,  44926,  45291,  45656,
67:     46021,  46387,  46752,  47117,  47482,  47847,  48212,  48577,  48942,  49308,  49673,  50038,  50403,  50769,
68:     51134,  51499,  51864,  52230,  52595,  52960,  53325,  53691,  54056,  54421,  54786,  55152,  55517,  55882,
69:     56247,  56613,  56978,  57343,  57708,  58074,  58439,  58804,  59169,  59535,  59900,  60265,  60630,  60996,
70:     61361,  61726,  62091,  62457,  62822,  63187,  63552,  63918,  64283,  64648,  65013,  65379,  65744,  66109,
71:     66474,  66840,  67205,  67570,  67935,  68301,  68666,  69031,  69396,  69762,  70127,  70492,  70857,  71223,
72:     71588,  71953,  72318,  72684,  73049,  73414,  73779,  74145,  74510,  74875,  75240,  75606,  75971,  76336,
73:     76701,  77067,  77432,  77797,  78162,  78528,  78893,  79258,  79623,  79989,  80354,  80719,  81084,  81450,
74:     81815,  82180,  82545,  82911,  83276,  83641,  84006,  84371,  84736,  85101,  85466,  85832,  86197,  86562,
75:     86927,  87293,  87658,  88023,  88388,  88754,  89119,  89484,  89849,  90215,  90580,  90945,  91310,  91676,
76:     92041,  92406,  92771,  93137,  93502,  93867,  94232,  94598,  94963,  95328,  95693,  96059,  96424,  96789,
77:     97154,  97520,  97885,  98250,  98615,  98981,  99346,  99711,  100076, 100442, 100807, 101172, 101537, 101903,
78:     102268, 102633, 102998, 103364, 103729, 104094, 104459, 104825, 105190, 105555, 105920, 106286, 106651, 107016,
79:     107381, 107747, 108112, 108477, 108842, 109208, 109573, 109938, 110303, 110669, 111034, 111399, 111764, 112130,
80:     112495, 112860, 113225, 113591, 113956, 114321, 114686, 115052, 115417, 115782, 116147, 116513, 116878, 117243,
81:     117608, 117974, 118339, 118704, 119069, 119435, 119800, 120165, 120530, 120895, 121260, 121625, 121990, 122356,
82:     122721, 123086, 123451, 123817, 124182, 124547, 124912, 125278, 125643, 126008, 126373, 126739, 127104, 127469,
83:     127834, 128200, 128565, 128930, 129295, 129661, 130026, 130391, 130756, 131122, 131487, 131852, 132217, 132583,
84:     132948, 133313, 133678, 134044, 134409, 134774, 135139, 135505, 135870, 136235, 136600, 136966, 137331, 137696,
85:     138061, 138427, 138792, 139157, 139522, 139888, 140253, 140618, 140983, 141349, 141714, 142079, 142444, 142810,
86:     143175, 143540, 143905, 144271, 144636, 145001, 145366, 145732, 146097};
87: 
88: void Date::ExtractYearOffset(int32_t &n, int32_t &year, int32_t &year_offset) {
89: 	year = Date::EPOCH_YEAR;
90: 	// first we normalize n to be in the year range [1970, 2370]
91: 	// since leap years repeat every 400 years, we can safely normalize just by "shifting" the CumulativeYearDays array
92: 	while (n < 0) {
93: 		n += Date::DAYS_PER_YEAR_INTERVAL;
94: 		year -= Date::YEAR_INTERVAL;
95: 	}
96: 	while (n >= Date::DAYS_PER_YEAR_INTERVAL) {
97: 		n -= Date::DAYS_PER_YEAR_INTERVAL;
98: 		year += Date::YEAR_INTERVAL;
99: 	}
100: 	// interpolation search
101: 	// we can find an upper bound of the year by assuming each year has 365 days
102: 	year_offset = n / 365;
103: 	// because of leap years we might be off by a little bit: compensate by decrementing the year offset until we find
104: 	// our year
105: 	while (n < Date::CUMULATIVE_YEAR_DAYS[year_offset]) {
106: 		year_offset--;
107: 		D_ASSERT(year_offset >= 0);
108: 	}
109: 	year += year_offset;
110: 	D_ASSERT(n >= Date::CUMULATIVE_YEAR_DAYS[year_offset]);
111: }
112: 
113: void Date::Convert(date_t d, int32_t &year, int32_t &month, int32_t &day) {
114: 	auto n = d.days;
115: 	int32_t year_offset;
116: 	Date::ExtractYearOffset(n, year, year_offset);
117: 
118: 	day = n - Date::CUMULATIVE_YEAR_DAYS[year_offset];
119: 	D_ASSERT(day >= 0 && day <= 365);
120: 
121: 	bool is_leap_year = (Date::CUMULATIVE_YEAR_DAYS[year_offset + 1] - Date::CUMULATIVE_YEAR_DAYS[year_offset]) == 366;
122: 	if (is_leap_year) {
123: 		month = Date::LEAP_MONTH_PER_DAY_OF_YEAR[day];
124: 		day -= Date::CUMULATIVE_LEAP_DAYS[month - 1];
125: 	} else {
126: 		month = Date::MONTH_PER_DAY_OF_YEAR[day];
127: 		day -= Date::CUMULATIVE_DAYS[month - 1];
128: 	}
129: 	day++;
130: 	D_ASSERT(day > 0 && day <= (is_leap_year ? Date::LEAP_DAYS[month] : Date::NORMAL_DAYS[month]));
131: 	D_ASSERT(month > 0 && month <= 12);
132: }
133: 
134: date_t Date::FromDate(int32_t year, int32_t month, int32_t day) {
135: 	int32_t n = 0;
136: 	if (!Date::IsValid(year, month, day)) {
137: 		throw ConversionException("Date out of range: %d-%d-%d", year, month, day);
138: 	}
139: 	while (year < 1970) {
140: 		year += Date::YEAR_INTERVAL;
141: 		n -= Date::DAYS_PER_YEAR_INTERVAL;
142: 	}
143: 	while (year >= 2370) {
144: 		year -= Date::YEAR_INTERVAL;
145: 		n += Date::DAYS_PER_YEAR_INTERVAL;
146: 	}
147: 	n += Date::CUMULATIVE_YEAR_DAYS[year - 1970];
148: 	n += Date::IsLeapYear(year) ? Date::CUMULATIVE_LEAP_DAYS[month - 1] : Date::CUMULATIVE_DAYS[month - 1];
149: 	n += day - 1;
150: 	return date_t(n);
151: }
152: 
153: bool Date::ParseDoubleDigit(const char *buf, idx_t len, idx_t &pos, int32_t &result) {
154: 	if (pos < len && StringUtil::CharacterIsDigit(buf[pos])) {
155: 		result = buf[pos++] - '0';
156: 		if (pos < len && StringUtil::CharacterIsDigit(buf[pos])) {
157: 			result = (buf[pos++] - '0') + result * 10;
158: 		}
159: 		return true;
160: 	}
161: 	return false;
162: }
163: 
164: bool Date::TryConvertDate(const char *buf, idx_t len, idx_t &pos, date_t &result, bool strict) {
165: 	pos = 0;
166: 	if (len == 0) {
167: 		return false;
168: 	}
169: 
170: 	int32_t day = 0;
171: 	int32_t month = -1;
172: 	int32_t year = 0;
173: 	bool yearneg = false;
174: 	int sep;
175: 
176: 	// skip leading spaces
177: 	while (pos < len && StringUtil::CharacterIsSpace(buf[pos])) {
178: 		pos++;
179: 	}
180: 
181: 	if (pos >= len) {
182: 		return false;
183: 	}
184: 	if (buf[pos] == '-') {
185: 		yearneg = true;
186: 		pos++;
187: 		if (pos >= len) {
188: 			return false;
189: 		}
190: 	}
191: 	if (!StringUtil::CharacterIsDigit(buf[pos])) {
192: 		return false;
193: 	}
194: 	// first parse the year
195: 	for (; pos < len && StringUtil::CharacterIsDigit(buf[pos]); pos++) {
196: 		year = (buf[pos] - '0') + year * 10;
197: 		if (year > Date::MAX_YEAR) {
198: 			break;
199: 		}
200: 	}
201: 	if (yearneg) {
202: 		year = -year;
203: 		if (year < Date::MIN_YEAR) {
204: 			return false;
205: 		}
206: 	}
207: 
208: 	if (pos >= len) {
209: 		return false;
210: 	}
211: 
212: 	// fetch the separator
213: 	sep = buf[pos++];
214: 	if (sep != ' ' && sep != '-' && sep != '/' && sep != '\\') {
215: 		// invalid separator
216: 		return false;
217: 	}
218: 
219: 	// parse the month
220: 	if (!Date::ParseDoubleDigit(buf, len, pos, month)) {
221: 		return false;
222: 	}
223: 
224: 	if (pos >= len) {
225: 		return false;
226: 	}
227: 
228: 	if (buf[pos++] != sep) {
229: 		return false;
230: 	}
231: 
232: 	if (pos >= len) {
233: 		return false;
234: 	}
235: 
236: 	// now parse the day
237: 	if (!Date::ParseDoubleDigit(buf, len, pos, day)) {
238: 		return false;
239: 	}
240: 
241: 	// check for an optional trailing " (BC)""
242: 	if (len - pos >= 5 && StringUtil::CharacterIsSpace(buf[pos]) && buf[pos + 1] == '(' && buf[pos + 2] == 'B' &&
243: 	    buf[pos + 3] == 'C' && buf[pos + 4] == ')') {
244: 		if (yearneg || year == 0) {
245: 			return false;
246: 		}
247: 		year = -year + 1;
248: 		pos += 5;
249: 
250: 		if (year < Date::MIN_YEAR) {
251: 			return false;
252: 		}
253: 	}
254: 
255: 	// in strict mode, check remaining string for non-space characters
256: 	if (strict) {
257: 		// skip trailing spaces
258: 		while (pos < len && StringUtil::CharacterIsSpace((unsigned char)buf[pos])) {
259: 			pos++;
260: 		}
261: 		// check position. if end was not reached, non-space chars remaining
262: 		if (pos < len) {
263: 			return false;
264: 		}
265: 	} else {
266: 		// in non-strict mode, check for any direct trailing digits
267: 		if (pos < len && StringUtil::CharacterIsDigit((unsigned char)buf[pos])) {
268: 			return false;
269: 		}
270: 	}
271: 
272: 	result = Date::FromDate(year, month, day);
273: 	return true;
274: }
275: 
276: date_t Date::FromCString(const char *buf, idx_t len, bool strict) {
277: 	date_t result;
278: 	idx_t pos;
279: 	if (!TryConvertDate(buf, len, pos, result, strict)) {
280: 		throw ConversionException("date/time field value out of range: \"%s\", "
281: 		                          "expected format is (YYYY-MM-DD)",
282: 		                          string(buf, len));
283: 	}
284: 	return result;
285: }
286: 
287: date_t Date::FromString(const string &str, bool strict) {
288: 	return Date::FromCString(str.c_str(), str.size(), strict);
289: }
290: 
291: string Date::ToString(date_t date) {
292: 	int32_t date_units[3];
293: 	idx_t year_length;
294: 	bool add_bc;
295: 	Date::Convert(date, date_units[0], date_units[1], date_units[2]);
296: 
297: 	auto length = DateToStringCast::Length(date_units, year_length, add_bc);
298: 	auto buffer = unique_ptr<char[]>(new char[length]);
299: 	DateToStringCast::Format(buffer.get(), date_units, year_length, add_bc);
300: 	return string(buffer.get(), length);
301: }
302: 
303: string Date::Format(int32_t year, int32_t month, int32_t day) {
304: 	return ToString(Date::FromDate(year, month, day));
305: }
306: 
307: bool Date::IsLeapYear(int32_t year) {
308: 	return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
309: }
310: 
311: bool Date::IsValid(int32_t year, int32_t month, int32_t day) {
312: 	if (month < 1 || month > 12) {
313: 		return false;
314: 	}
315: 	if (year < Date::MIN_YEAR || year > Date::MAX_YEAR) {
316: 		return false;
317: 	}
318: 	if (day < 1) {
319: 		return false;
320: 	}
321: 	return Date::IsLeapYear(year) ? day <= Date::LEAP_DAYS[month] : day <= Date::NORMAL_DAYS[month];
322: }
323: 
324: date_t Date::EpochDaysToDate(int32_t epoch) {
325: 	return (date_t)epoch;
326: }
327: 
328: int32_t Date::EpochDays(date_t date) {
329: 	return date.days;
330: }
331: 
332: date_t Date::EpochToDate(int64_t epoch) {
333: 	return date_t(epoch / Interval::SECS_PER_DAY);
334: }
335: 
336: int64_t Date::Epoch(date_t date) {
337: 	return ((int64_t)date.days) * Interval::SECS_PER_DAY;
338: }
339: 
340: int64_t Date::EpochNanoseconds(date_t date) {
341: 	return ((int64_t)date.days) * (Interval::MICROS_PER_DAY * 1000);
342: }
343: 
344: int32_t Date::ExtractYear(date_t d, int32_t *last_year) {
345: 	auto n = d.days;
346: 	// cached look up: check if year of this date is the same as the last one we looked up
347: 	// note that this only works for years in the range [1970, 2370]
348: 	if (n >= Date::CUMULATIVE_YEAR_DAYS[*last_year] && n < Date::CUMULATIVE_YEAR_DAYS[*last_year + 1]) {
349: 		return Date::EPOCH_YEAR + *last_year;
350: 	}
351: 	int32_t year;
352: 	Date::ExtractYearOffset(n, year, *last_year);
353: 	return year;
354: }
355: 
356: int32_t Date::ExtractYear(timestamp_t ts, int32_t *last_year) {
357: 	return Date::ExtractYear(Timestamp::GetDate(ts), last_year);
358: }
359: 
360: int32_t Date::ExtractYear(date_t d) {
361: 	int32_t year, year_offset;
362: 	Date::ExtractYearOffset(d.days, year, year_offset);
363: 	return year;
364: }
365: 
366: int32_t Date::ExtractMonth(date_t date) {
367: 	int32_t out_year, out_month, out_day;
368: 	Date::Convert(date, out_year, out_month, out_day);
369: 	return out_month;
370: }
371: 
372: int32_t Date::ExtractDay(date_t date) {
373: 	int32_t out_year, out_month, out_day;
374: 	Date::Convert(date, out_year, out_month, out_day);
375: 	return out_day;
376: }
377: 
378: int32_t Date::ExtractDayOfTheYear(date_t date) {
379: 	int32_t year, year_offset;
380: 	Date::ExtractYearOffset(date.days, year, year_offset);
381: 	return date.days - Date::CUMULATIVE_YEAR_DAYS[year_offset] + 1;
382: }
383: 
384: int32_t Date::ExtractISODayOfTheWeek(date_t date) {
385: 	// date of 0 is 1970-01-01, which was a Thursday (4)
386: 	// -7 = 4
387: 	// -6 = 5
388: 	// -5 = 6
389: 	// -4 = 7
390: 	// -3 = 1
391: 	// -2 = 2
392: 	// -1 = 3
393: 	// 0  = 4
394: 	// 1  = 5
395: 	// 2  = 6
396: 	// 3  = 7
397: 	// 4  = 1
398: 	// 5  = 2
399: 	// 6  = 3
400: 	// 7  = 4
401: 	if (date.days < 0) {
402: 		// negative date: start off at 4 and cycle downwards
403: 		return (7 - ((-date.days + 3) % 7));
404: 	} else {
405: 		// positive date: start off at 4 and cycle upwards
406: 		return ((date.days + 3) % 7) + 1;
407: 	}
408: }
409: 
410: static int32_t GetISOWeek(int32_t year, int32_t month, int32_t day) {
411: 	auto day_of_the_year =
412: 	    (Date::IsLeapYear(year) ? Date::CUMULATIVE_LEAP_DAYS[month] : Date::CUMULATIVE_DAYS[month]) + day;
413: 	// get the first day of the first week of the year
414: 	// the first week is the week that has the 4th of January in it
415: 	auto day_of_the_fourth = Date::ExtractISODayOfTheWeek(Date::FromDate(year, 1, 4));
416: 	// if fourth is monday, then fourth is the first day
417: 	// if fourth is tuesday, third is the first day
418: 	// if fourth is wednesday, second is the first day
419: 	// if fourth is thursday - sunday, first is the first day
420: 	auto first_day_of_the_first_week = day_of_the_fourth >= 4 ? 0 : 5 - day_of_the_fourth;
421: 	if (day_of_the_year < first_day_of_the_first_week) {
422: 		// day is part of last year
423: 		return GetISOWeek(year - 1, 12, day);
424: 	} else {
425: 		return ((day_of_the_year - first_day_of_the_first_week) / 7) + 1;
426: 	}
427: }
428: 
429: int32_t Date::ExtractISOWeekNumber(date_t date) {
430: 	int32_t year, month, day;
431: 	Date::Convert(date, year, month, day);
432: 	return GetISOWeek(year, month - 1, day - 1);
433: }
434: 
435: int32_t Date::ExtractWeekNumberRegular(date_t date, bool monday_first) {
436: 	int32_t year, month, day;
437: 	Date::Convert(date, year, month, day);
438: 	month -= 1;
439: 	day -= 1;
440: 	// get the day of the year
441: 	auto day_of_the_year =
442: 	    (Date::IsLeapYear(year) ? Date::CUMULATIVE_LEAP_DAYS[month] : Date::CUMULATIVE_DAYS[month]) + day;
443: 	// now figure out the first monday or sunday of the year
444: 	// what day is January 1st?
445: 	auto day_of_jan_first = Date::ExtractISODayOfTheWeek(Date::FromDate(year, 1, 1));
446: 	// monday = 1, sunday = 7
447: 	int32_t first_week_start;
448: 	if (monday_first) {
449: 		// have to find next "1"
450: 		if (day_of_jan_first == 1) {
451: 			// jan 1 is monday: starts immediately
452: 			first_week_start = 0;
453: 		} else {
454: 			// jan 1 is not monday: count days until next monday
455: 			first_week_start = 8 - day_of_jan_first;
456: 		}
457: 	} else {
458: 		first_week_start = 7 - day_of_jan_first;
459: 	}
460: 	if (day_of_the_year < first_week_start) {
461: 		// day occurs before first week starts: week 0
462: 		return 0;
463: 	}
464: 	return ((day_of_the_year - first_week_start) / 7) + 1;
465: }
466: 
467: // Returns the date of the monday of the current week.
468: date_t Date::GetMondayOfCurrentWeek(date_t date) {
469: 	int32_t dotw = Date::ExtractISODayOfTheWeek(date);
470: 	return date - (dotw - 1);
471: }
472: 
473: } // namespace duckdb
[end of src/common/types/date.cpp]
[start of src/function/scalar/operators/add.cpp]
1: #include "duckdb/common/operator/add.hpp"
2: 
3: #include "duckdb/common/limits.hpp"
4: #include "duckdb/common/types/value.hpp"
5: 
6: #include "duckdb/common/types/date.hpp"
7: #include "duckdb/common/types/interval.hpp"
8: #include "duckdb/common/types/timestamp.hpp"
9: #include "duckdb/common/types/hugeint.hpp"
10: #include "duckdb/common/windows_undefs.hpp"
11: 
12: #include <limits>
13: 
14: namespace duckdb {
15: 
16: //===--------------------------------------------------------------------===//
17: // + [add]
18: //===--------------------------------------------------------------------===//
19: template <>
20: float AddOperator::Operation(float left, float right) {
21: 	auto result = left + right;
22: 	if (!Value::FloatIsValid(result)) {
23: 		throw OutOfRangeException("Overflow in addition of float!");
24: 	}
25: 	return result;
26: }
27: 
28: template <>
29: double AddOperator::Operation(double left, double right) {
30: 	auto result = left + right;
31: 	if (!Value::DoubleIsValid(result)) {
32: 		throw OutOfRangeException("Overflow in addition of double!");
33: 	}
34: 	return result;
35: }
36: 
37: template <>
38: interval_t AddOperator::Operation(interval_t left, interval_t right) {
39: 	left.months = AddOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.months, right.months);
40: 	left.days = AddOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.days, right.days);
41: 	left.micros = AddOperatorOverflowCheck::Operation<int64_t, int64_t, int64_t>(left.micros, right.micros);
42: 	return left;
43: }
44: 
45: template <>
46: date_t AddOperator::Operation(date_t left, interval_t right) {
47: 	date_t result;
48: 	if (right.months != 0) {
49: 		int32_t year, month, day;
50: 		Date::Convert(left, year, month, day);
51: 		int32_t year_diff = right.months / Interval::MONTHS_PER_YEAR;
52: 		year += year_diff;
53: 		month += right.months - year_diff * Interval::MONTHS_PER_YEAR;
54: 		if (month > Interval::MONTHS_PER_YEAR) {
55: 			year++;
56: 			month -= Interval::MONTHS_PER_YEAR;
57: 		} else if (month <= 0) {
58: 			year--;
59: 			month += Interval::MONTHS_PER_YEAR;
60: 		}
61: 		result = Date::FromDate(year, month, day);
62: 	} else {
63: 		result = left;
64: 	}
65: 	if (right.days != 0) {
66: 		result += right.days;
67: 	}
68: 	if (right.micros != 0) {
69: 		result += right.micros / Interval::MICROS_PER_DAY;
70: 	}
71: 	return result;
72: }
73: 
74: template <>
75: date_t AddOperator::Operation(interval_t left, date_t right) {
76: 	return AddOperator::Operation<date_t, interval_t, date_t>(right, left);
77: }
78: 
79: dtime_t AddIntervalToTimeOperation(dtime_t left, interval_t right, date_t &date) {
80: 	int64_t diff = right.micros - ((right.micros / Interval::MICROS_PER_DAY) * Interval::MICROS_PER_DAY);
81: 	left += diff;
82: 	if (left.micros >= Interval::MICROS_PER_DAY) {
83: 		left.micros -= Interval::MICROS_PER_DAY;
84: 		date.days++;
85: 	} else if (left.micros < 0) {
86: 		left.micros += Interval::MICROS_PER_DAY;
87: 		date.days--;
88: 	}
89: 	return left;
90: }
91: 
92: template <>
93: timestamp_t AddOperator::Operation(timestamp_t left, interval_t right) {
94: 	date_t date;
95: 	dtime_t time;
96: 	Timestamp::Convert(left, date, time);
97: 	auto new_date = AddOperator::Operation<date_t, interval_t, date_t>(date, right);
98: 	auto new_time = AddIntervalToTimeOperation(time, right, new_date);
99: 	return Timestamp::FromDatetime(new_date, new_time);
100: }
101: 
102: template <>
103: timestamp_t AddOperator::Operation(interval_t left, timestamp_t right) {
104: 	return AddOperator::Operation<timestamp_t, interval_t, timestamp_t>(right, left);
105: }
106: 
107: //===--------------------------------------------------------------------===//
108: // + [add] with overflow check
109: //===--------------------------------------------------------------------===//
110: struct OverflowCheckedAddition {
111: 	template <class SRCTYPE, class UTYPE>
112: 	static inline bool Operation(SRCTYPE left, SRCTYPE right, SRCTYPE &result) {
113: 		UTYPE uresult = AddOperator::Operation<UTYPE, UTYPE, UTYPE>(UTYPE(left), UTYPE(right));
114: 		if (uresult < NumericLimits<SRCTYPE>::Minimum() || uresult > NumericLimits<SRCTYPE>::Maximum()) {
115: 			return false;
116: 		}
117: 		result = SRCTYPE(uresult);
118: 		return true;
119: 	}
120: };
121: 
122: template <>
123: bool TryAddOperator::Operation(uint8_t left, uint8_t right, uint8_t &result) {
124: 	return OverflowCheckedAddition::Operation<uint8_t, uint16_t>(left, right, result);
125: }
126: template <>
127: bool TryAddOperator::Operation(uint16_t left, uint16_t right, uint16_t &result) {
128: 	return OverflowCheckedAddition::Operation<uint16_t, uint32_t>(left, right, result);
129: }
130: template <>
131: bool TryAddOperator::Operation(uint32_t left, uint32_t right, uint32_t &result) {
132: 	return OverflowCheckedAddition::Operation<uint32_t, uint64_t>(left, right, result);
133: }
134: 
135: template <>
136: bool TryAddOperator::Operation(uint64_t left, uint64_t right, uint64_t &result) {
137: 	if (NumericLimits<uint64_t>::Maximum() - left < right) {
138: 		return false;
139: 	}
140: 	return OverflowCheckedAddition::Operation<uint64_t, uint64_t>(left, right, result);
141: }
142: 
143: template <>
144: bool TryAddOperator::Operation(int8_t left, int8_t right, int8_t &result) {
145: 	return OverflowCheckedAddition::Operation<int8_t, int16_t>(left, right, result);
146: }
147: 
148: template <>
149: bool TryAddOperator::Operation(int16_t left, int16_t right, int16_t &result) {
150: 	return OverflowCheckedAddition::Operation<int16_t, int32_t>(left, right, result);
151: }
152: 
153: template <>
154: bool TryAddOperator::Operation(int32_t left, int32_t right, int32_t &result) {
155: 	return OverflowCheckedAddition::Operation<int32_t, int64_t>(left, right, result);
156: }
157: 
158: template <>
159: bool TryAddOperator::Operation(int64_t left, int64_t right, int64_t &result) {
160: #if (__GNUC__ >= 5) || defined(__clang__)
161: 	if (__builtin_add_overflow(left, right, &result)) {
162: 		return false;
163: 	}
164: #else
165: 	// https://blog.regehr.org/archives/1139
166: 	result = int64_t((uint64_t)left + (uint64_t)right);
167: 	if ((left < 0 && right < 0 && result >= 0) || (left >= 0 && right >= 0 && result < 0)) {
168: 		return false;
169: 	}
170: #endif
171: 	return true;
172: }
173: 
174: //===--------------------------------------------------------------------===//
175: // add decimal with overflow check
176: //===--------------------------------------------------------------------===//
177: template <class T, T min, T max>
178: bool TryDecimalAddTemplated(T left, T right, T &result) {
179: 	if (right < 0) {
180: 		if (min - right > left) {
181: 			return false;
182: 		}
183: 	} else {
184: 		if (max - right < left) {
185: 			return false;
186: 		}
187: 	}
188: 	result = left + right;
189: 	return true;
190: }
191: 
192: template <>
193: bool TryDecimalAdd::Operation(int16_t left, int16_t right, int16_t &result) {
194: 	return TryDecimalAddTemplated<int16_t, -9999, 9999>(left, right, result);
195: }
196: 
197: template <>
198: bool TryDecimalAdd::Operation(int32_t left, int32_t right, int32_t &result) {
199: 	return TryDecimalAddTemplated<int32_t, -999999999, 999999999>(left, right, result);
200: }
201: 
202: template <>
203: bool TryDecimalAdd::Operation(int64_t left, int64_t right, int64_t &result) {
204: 	return TryDecimalAddTemplated<int64_t, -999999999999999999, 999999999999999999>(left, right, result);
205: }
206: 
207: template <>
208: bool TryDecimalAdd::Operation(hugeint_t left, hugeint_t right, hugeint_t &result) {
209: 	result = left + right;
210: 	if (result <= -Hugeint::POWERS_OF_TEN[38] || result >= Hugeint::POWERS_OF_TEN[38]) {
211: 		return false;
212: 	}
213: 	return true;
214: }
215: 
216: template <>
217: hugeint_t DecimalAddOverflowCheck::Operation(hugeint_t left, hugeint_t right) {
218: 	hugeint_t result;
219: 	if (!TryDecimalAdd::Operation(left, right, result)) {
220: 		throw OutOfRangeException("Overflow in addition of DECIMAL(38) (%s + %s);", left.ToString(), right.ToString());
221: 	}
222: 	return result;
223: }
224: 
225: //===--------------------------------------------------------------------===//
226: // add time operator
227: //===--------------------------------------------------------------------===//
228: template <>
229: dtime_t AddTimeOperator::Operation(dtime_t left, interval_t right) {
230: 	date_t date(0);
231: 	return AddIntervalToTimeOperation(left, right, date);
232: }
233: 
234: template <>
235: dtime_t AddTimeOperator::Operation(interval_t left, dtime_t right) {
236: 	return AddTimeOperator::Operation<dtime_t, interval_t, dtime_t>(right, left);
237: }
238: 
239: } // namespace duckdb
[end of src/function/scalar/operators/add.cpp]
[start of src/include/duckdb/common/types/date.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/date.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types.hpp"
13: #include "duckdb/common/types/string_type.hpp"
14: 
15: namespace duckdb {
16: 
17: //! The Date class is a static class that holds helper functions for the Date
18: //! type.
19: class Date {
20: public:
21: 	static const string_t MONTH_NAMES[12];
22: 	static const string_t MONTH_NAMES_ABBREVIATED[12];
23: 	static const string_t DAY_NAMES[7];
24: 	static const string_t DAY_NAMES_ABBREVIATED[7];
25: 	static const int32_t NORMAL_DAYS[13];
26: 	static const int32_t CUMULATIVE_DAYS[13];
27: 	static const int32_t LEAP_DAYS[13];
28: 	static const int32_t CUMULATIVE_LEAP_DAYS[13];
29: 	static const int32_t CUMULATIVE_YEAR_DAYS[401];
30: 	static const int8_t MONTH_PER_DAY_OF_YEAR[365];
31: 	static const int8_t LEAP_MONTH_PER_DAY_OF_YEAR[366];
32: 
33: 	constexpr static const int32_t MIN_YEAR = -290307;
34: 	constexpr static const int32_t MAX_YEAR = 294247;
35: 	constexpr static const int32_t EPOCH_YEAR = 1970;
36: 
37: 	constexpr static const int32_t YEAR_INTERVAL = 400;
38: 	constexpr static const int32_t DAYS_PER_YEAR_INTERVAL = 146097;
39: 
40: public:
41: 	//! Convert a string in the format "YYYY-MM-DD" to a date object
42: 	static date_t FromString(const string &str, bool strict = false);
43: 	//! Convert a string in the format "YYYY-MM-DD" to a date object
44: 	static date_t FromCString(const char *str, idx_t len, bool strict = false);
45: 	//! Convert a date object to a string in the format "YYYY-MM-DD"
46: 	static string ToString(date_t date);
47: 	//! Try to convert text in a buffer to a date; returns true if parsing was successful
48: 	static bool TryConvertDate(const char *buf, idx_t len, idx_t &pos, date_t &result, bool strict = false);
49: 
50: 	//! Create a string "YYYY-MM-DD" from a specified (year, month, day)
51: 	//! combination
52: 	static string Format(int32_t year, int32_t month, int32_t day);
53: 
54: 	//! Extract the year, month and day from a given date object
55: 	static void Convert(date_t date, int32_t &out_year, int32_t &out_month, int32_t &out_day);
56: 	//! Create a Date object from a specified (year, month, day) combination
57: 	static date_t FromDate(int32_t year, int32_t month, int32_t day);
58: 
59: 	//! Returns true if (year) is a leap year, and false otherwise
60: 	static bool IsLeapYear(int32_t year);
61: 
62: 	//! Returns true if the specified (year, month, day) combination is a valid
63: 	//! date
64: 	static bool IsValid(int32_t year, int32_t month, int32_t day);
65: 
66: 	//! Extract the epoch from the date (seconds since 1970-01-01)
67: 	static int64_t Epoch(date_t date);
68: 	//! Extract the epoch from the date (nanoseconds since 1970-01-01)
69: 	static int64_t EpochNanoseconds(date_t date);
70: 	//! Convert the epoch (seconds since 1970-01-01) to a date_t
71: 	static date_t EpochToDate(int64_t epoch);
72: 
73: 	//! Extract the number of days since epoch (days since 1970-01-01)
74: 	static int32_t EpochDays(date_t date);
75: 	//! Convert the epoch number of days to a date_t
76: 	static date_t EpochDaysToDate(int32_t epoch);
77: 
78: 	//! Extract year of a date entry
79: 	static int32_t ExtractYear(date_t date);
80: 	//! Extract year of a date entry, but optimized to first try the last year found
81: 	static int32_t ExtractYear(date_t date, int32_t *last_year);
82: 	static int32_t ExtractYear(timestamp_t ts, int32_t *last_year);
83: 	//! Extract month of a date entry
84: 	static int32_t ExtractMonth(date_t date);
85: 	//! Extract day of a date entry
86: 	static int32_t ExtractDay(date_t date);
87: 	//! Extract the day of the week (1-7)
88: 	static int32_t ExtractISODayOfTheWeek(date_t date);
89: 	//! Extract the day of the year
90: 	static int32_t ExtractDayOfTheYear(date_t date);
91: 	//! Extract the ISO week number
92: 	//! ISO weeks start on Monday and the first week of a year
93: 	//! contains January 4 of that year.
94: 	//! In the ISO week-numbering system, it is possible for early-January dates
95: 	//! to be part of the 52nd or 53rd week of the previous year.
96: 	static int32_t ExtractISOWeekNumber(date_t date);
97: 	//! Extract the week number as Python handles it.
98: 	//! Either Monday or Sunday is the first day of the week,
99: 	//! and any date before the first Monday/Sunday returns week 0
100: 	//! This is a bit more consistent because week numbers in a year are always incrementing
101: 	static int32_t ExtractWeekNumberRegular(date_t date, bool monday_first = true);
102: 	//! Returns the date of the monday of the current week.
103: 	static date_t GetMondayOfCurrentWeek(date_t date);
104: 
105: 	//! Helper function to parse two digits from a string (e.g. "30" -> 30, "03" -> 3, "3" -> 3)
106: 	static bool ParseDoubleDigit(const char *buf, idx_t len, idx_t &pos, int32_t &result);
107: 
108: private:
109: 	static void ExtractYearOffset(int32_t &n, int32_t &year, int32_t &year_offset);
110: };
111: } // namespace duckdb
[end of src/include/duckdb/common/types/date.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: