{
  "repo": "duckdb/duckdb",
  "pull_number": 4690,
  "instance_id": "duckdb__duckdb-4690",
  "issue_numbers": [
    "4688"
  ],
  "base_commit": "a991beaf1ba592595dc5ad159b2c5a4f0c2af5e0",
  "patch": "diff --git a/tools/pythonpkg/src/include/duckdb_python/python_conversion.hpp b/tools/pythonpkg/src/include/duckdb_python/python_conversion.hpp\nindex 23918a6075c4..5c1fb05ee224 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/python_conversion.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/python_conversion.hpp\n@@ -40,6 +40,8 @@ enum class PythonObjectType {\n \tNdArray,\n };\n \n+PythonObjectType GetPythonObjectType(py::handle &ele);\n+\n bool TryTransformPythonNumeric(Value &res, py::handle ele);\n bool DictionaryHasMapFormat(const PyDictionary &dict);\n Value TransformPythonValue(py::handle ele, const LogicalType &target_type = LogicalType::UNKNOWN,\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp b/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\nindex 90a58181454d..0d72ba641a93 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\n@@ -5,6 +5,8 @@\n #include \"duckdb/common/types/date.hpp\"\n #include \"duckdb/common/types/timestamp.hpp\"\n #include \"duckdb/common/types/interval.hpp\"\n+#include \"duckdb/common/types/value.hpp\"\n+#include \"duckdb/common/types/cast_helpers.hpp\"\n \n #include \"datetime.h\" //from python\n \n@@ -50,6 +52,42 @@ enum class PyDecimalExponentType {\n };\n \n struct PyDecimal {\n+\n+\tstruct PyDecimalScaleConverter {\n+\t\ttemplate <typename T, typename = std::enable_if<std::numeric_limits<T>::is_integer, T>>\n+\t\tstatic Value Operation(bool signed_value, vector<uint8_t> &digits, uint8_t width, uint8_t scale) {\n+\t\t\tT value = 0;\n+\t\t\tfor (auto it = digits.begin(); it != digits.end(); it++) {\n+\t\t\t\tvalue = value * 10 + *it;\n+\t\t\t}\n+\t\t\tif (signed_value) {\n+\t\t\t\tvalue = -value;\n+\t\t\t}\n+\t\t\treturn Value::DECIMAL(value, width, scale);\n+\t\t}\n+\t};\n+\n+\tstruct PyDecimalPowerConverter {\n+\t\ttemplate <typename T, typename = std::enable_if<std::numeric_limits<T>::is_integer, T>>\n+\t\tstatic Value Operation(bool signed_value, vector<uint8_t> &digits, uint8_t width, uint8_t scale) {\n+\t\t\tT value = 0;\n+\t\t\tfor (auto &digit : digits) {\n+\t\t\t\tvalue = value * 10 + digit;\n+\t\t\t}\n+\t\t\tD_ASSERT(scale >= 0);\n+\t\t\tint64_t multiplier =\n+\t\t\t    NumericHelper::POWERS_OF_TEN[MinValue<uint8_t>(scale, NumericHelper::CACHED_POWERS_OF_TEN - 1)];\n+\t\t\tfor (auto power = scale; power > NumericHelper::CACHED_POWERS_OF_TEN; power--) {\n+\t\t\t\tmultiplier *= 10;\n+\t\t\t}\n+\t\t\tvalue *= multiplier;\n+\t\t\tif (signed_value) {\n+\t\t\t\tvalue = -value;\n+\t\t\t}\n+\t\t\treturn Value::DECIMAL(value, width, scale);\n+\t\t}\n+\t};\n+\n public:\n \tPyDecimal(py::handle &obj);\n \tvector<uint8_t> digits;\ndiff --git a/tools/pythonpkg/src/pandas_analyzer.cpp b/tools/pythonpkg/src/pandas_analyzer.cpp\nindex ec9a7ed60c14..8b69181f428f 100644\n--- a/tools/pythonpkg/src/pandas_analyzer.cpp\n+++ b/tools/pythonpkg/src/pandas_analyzer.cpp\n@@ -256,50 +256,53 @@ LogicalType PandasAnalyzer::DictToStruct(const PyDictionary &dict, bool &can_con\n LogicalType PandasAnalyzer::GetItemType(py::handle ele, bool &can_convert) {\n \tauto &import_cache = *DuckDBPyConnection::ImportCache();\n \n-\tif (ele.is_none()) {\n+\tauto object_type = GetPythonObjectType(ele);\n+\n+\tswitch (object_type) {\n+\tcase PythonObjectType::None:\n \t\treturn LogicalType::SQLNULL;\n-\t} else if (py::isinstance<py::bool_>(ele)) {\n+\tcase PythonObjectType::Bool:\n \t\treturn LogicalType::BOOLEAN;\n-\t} else if (py::isinstance<py::int_>(ele)) {\n+\tcase PythonObjectType::Integer: {\n \t\tValue integer;\n \t\tif (!TryTransformPythonNumeric(integer, ele)) {\n \t\t\tcan_convert = false;\n \t\t\treturn LogicalType::SQLNULL;\n \t\t}\n \t\treturn integer.type();\n-\t} else if (py::isinstance<py::float_>(ele)) {\n+\t}\n+\tcase PythonObjectType::Float:\n \t\tif (std::isnan(PyFloat_AsDouble(ele.ptr()))) {\n \t\t\treturn LogicalType::SQLNULL;\n \t\t}\n \t\treturn LogicalType::DOUBLE;\n-\t} else if (py::isinstance(ele, import_cache.decimal.Decimal())) {\n+\tcase PythonObjectType::Decimal: {\n \t\tPyDecimal decimal(ele);\n \t\tLogicalType type;\n \t\tif (!decimal.TryGetType(type)) {\n \t\t\tcan_convert = false;\n \t\t}\n \t\treturn type;\n-\t} else if (py::isinstance(ele, import_cache.datetime.datetime())) {\n+\t}\n+\tcase PythonObjectType::Datetime:\n \t\treturn LogicalType::TIMESTAMP;\n-\t} else if (py::isinstance(ele, import_cache.datetime.time())) {\n+\tcase PythonObjectType::Time:\n \t\treturn LogicalType::TIME;\n-\t} else if (py::isinstance(ele, import_cache.datetime.date())) {\n+\tcase PythonObjectType::Date:\n \t\treturn LogicalType::DATE;\n-\t} else if (py::isinstance(ele, import_cache.datetime.timedelta())) {\n+\tcase PythonObjectType::Timedelta:\n \t\treturn LogicalType::INTERVAL;\n-\t} else if (py::isinstance<py::str>(ele)) {\n+\tcase PythonObjectType::String:\n \t\treturn LogicalType::VARCHAR;\n-\t} else if (py::isinstance(ele, import_cache.uuid.UUID())) {\n+\tcase PythonObjectType::Uuid:\n \t\treturn LogicalType::UUID;\n-\t} else if (py::isinstance<py::bytearray>(ele)) {\n-\t\treturn LogicalType::BLOB;\n-\t} else if (py::isinstance<py::memoryview>(ele)) {\n+\tcase PythonObjectType::ByteArray:\n+\tcase PythonObjectType::MemoryView:\n+\tcase PythonObjectType::Bytes:\n \t\treturn LogicalType::BLOB;\n-\t} else if (py::isinstance<py::bytes>(ele)) {\n-\t\treturn LogicalType::BLOB;\n-\t} else if (py::isinstance<py::list>(ele)) {\n+\tcase PythonObjectType::List:\n \t\treturn GetListType(ele, can_convert);\n-\t} else if (py::isinstance<py::dict>(ele)) {\n+\tcase PythonObjectType::Dict: {\n \t\tPyDictionary dict = PyDictionary(py::reinterpret_borrow<py::object>(ele));\n \t\t// Assuming keys and values are the same size\n \n@@ -310,7 +313,8 @@ LogicalType PandasAnalyzer::GetItemType(py::handle ele, bool &can_convert) {\n \t\t\treturn DictToMap(dict, can_convert);\n \t\t}\n \t\treturn DictToStruct(dict, can_convert);\n-\t} else if (py::isinstance(ele, import_cache.numpy.ndarray())) {\n+\t}\n+\tcase PythonObjectType::NdArray: {\n \t\tauto extended_type = ConvertPandasType(ele.attr(\"dtype\"));\n \t\tLogicalType ltype;\n \t\tltype = PandasToLogicalType(extended_type);\n@@ -321,7 +325,8 @@ LogicalType PandasAnalyzer::GetItemType(py::handle ele, bool &can_convert) {\n \t\t\t}\n \t\t}\n \t\treturn LogicalType::LIST(ltype);\n-\t} else {\n+\t}\n+\tcase PythonObjectType::Other:\n \t\t// Fall back to string for unknown types\n \t\tcan_convert = false;\n \t\treturn LogicalType::VARCHAR;\ndiff --git a/tools/pythonpkg/src/python_conversion.cpp b/tools/pythonpkg/src/python_conversion.cpp\nindex aa5a2df87592..abafa9fa64ed 100644\n--- a/tools/pythonpkg/src/python_conversion.cpp\n+++ b/tools/pythonpkg/src/python_conversion.cpp\n@@ -201,7 +201,7 @@ bool TryTransformPythonNumeric(Value &res, py::handle ele) {\n \treturn true;\n }\n \n-PythonObjectType GetObjectType(py::handle &ele) {\n+PythonObjectType GetPythonObjectType(py::handle &ele) {\n \tauto &import_cache = *DuckDBPyConnection::ImportCache();\n \n \tif (ele.is_none()) {\n@@ -244,9 +244,7 @@ PythonObjectType GetObjectType(py::handle &ele) {\n }\n \n Value TransformPythonValue(py::handle ele, const LogicalType &target_type, bool nan_as_null) {\n-\tauto &import_cache = *DuckDBPyConnection::ImportCache();\n-\n-\tauto object_type = GetObjectType(ele);\n+\tauto object_type = GetPythonObjectType(ele);\n \n \tswitch (object_type) {\n \tcase PythonObjectType::None:\ndiff --git a/tools/pythonpkg/src/python_objects.cpp b/tools/pythonpkg/src/python_objects.cpp\nindex fe01c5e486e2..6258d943943d 100644\n--- a/tools/pythonpkg/src/python_objects.cpp\n+++ b/tools/pythonpkg/src/python_objects.cpp\n@@ -63,7 +63,12 @@ bool PyDecimal::TryGetType(LogicalType &type) {\n \t\tif (exponent_type == PyDecimalExponentType::EXPONENT_POWER) {\n \t\t\twidth += scale;\n \t\t}\n-\t\tif (width > Decimal::MAX_WIDTH_INT64) {\n+\t\tif (scale > width) {\n+\t\t\t//! The value starts with 1 or more zeros, which are optimized out of the 'digits' array\n+\t\t\t//! 0.001 - width=1, exponent=-3\n+\t\t\twidth = scale + 1; // DECIMAL(4,3) - add 1 for the non-decimal values\n+\t\t}\n+\t\tif (width > Decimal::MAX_WIDTH_INT128) {\n \t\t\treturn false;\n \t\t}\n \t\ttype = LogicalType::DECIMAL(width, scale);\n@@ -116,7 +121,21 @@ void PyDecimal::SetExponent(py::handle &exponent) {\n static void UnsupportedWidth(uint16_t width) {\n \tthrow ConversionException(\n \t    \"Failed to convert to a DECIMAL value with a width of %d because it exceeds the max supported with of %d\",\n-\t    width, Decimal::MAX_WIDTH_INT64);\n+\t    width, Decimal::MAX_WIDTH_INT128);\n+}\n+\n+template <class OP>\n+Value PyDecimalCastSwitch(PyDecimal &decimal, uint8_t width, uint8_t scale) {\n+\tif (width > DecimalWidth<int64_t>::max) {\n+\t\treturn OP::template Operation<hugeint_t>(decimal.signed_value, decimal.digits, width, scale);\n+\t}\n+\tif (width > DecimalWidth<int32_t>::max) {\n+\t\treturn OP::template Operation<int64_t>(decimal.signed_value, decimal.digits, width, scale);\n+\t}\n+\tif (width > DecimalWidth<int16_t>::max) {\n+\t\treturn OP::template Operation<int32_t>(decimal.signed_value, decimal.digits, width, scale);\n+\t}\n+\treturn OP::template Operation<int16_t>(decimal.signed_value, decimal.digits, width, scale);\n }\n \n Value PyDecimal::ToDuckValue() {\n@@ -124,39 +143,22 @@ Value PyDecimal::ToDuckValue() {\n \tswitch (exponent_type) {\n \tcase PyDecimalExponentType::EXPONENT_SCALE: {\n \t\tuint8_t scale = exponent_value;\n-\t\tif (width > Decimal::MAX_WIDTH_INT64) {\n+\t\tif (width > Decimal::MAX_WIDTH_INT128) {\n \t\t\tUnsupportedWidth(width);\n \t\t}\n-\t\tint64_t value = 0;\n-\t\tfor (auto it = digits.begin(); it != digits.end(); it++) {\n-\t\t\tvalue = value * 10 + *it;\n-\t\t}\n-\t\tif (signed_value) {\n-\t\t\tvalue = -value;\n+\t\tif (scale > width) {\n+\t\t\t//! Values like '0.001'\n+\t\t\twidth = scale + 1; //! leave 1 room for the non-decimal value\n \t\t}\n-\t\treturn Value::DECIMAL(value, width, scale);\n+\t\treturn PyDecimalCastSwitch<PyDecimalScaleConverter>(*this, width, scale);\n \t}\n \tcase PyDecimalExponentType::EXPONENT_POWER: {\n \t\tuint8_t scale = exponent_value;\n \t\twidth += scale;\n-\t\tif (width > Decimal::MAX_WIDTH_INT64) {\n+\t\tif (width > Decimal::MAX_WIDTH_INT128) {\n \t\t\tUnsupportedWidth(width);\n \t\t}\n-\t\tint64_t value = 0;\n-\t\tfor (auto &digit : digits) {\n-\t\t\tvalue = value * 10 + digit;\n-\t\t}\n-\t\tD_ASSERT(scale >= 0);\n-\t\tint64_t multiplier =\n-\t\t    NumericHelper::POWERS_OF_TEN[MinValue<uint8_t>(scale, NumericHelper::CACHED_POWERS_OF_TEN - 1)];\n-\t\tfor (auto power = scale; power > NumericHelper::CACHED_POWERS_OF_TEN; power--) {\n-\t\t\tmultiplier *= 10;\n-\t\t}\n-\t\tvalue *= multiplier;\n-\t\tif (signed_value) {\n-\t\t\tvalue = -value;\n-\t\t}\n-\t\treturn Value::DECIMAL(value, width, scale);\n+\t\treturn PyDecimalCastSwitch<PyDecimalPowerConverter>(*this, width, scale);\n \t}\n \tcase PyDecimalExponentType::EXPONENT_NAN: {\n \t\treturn Value::FLOAT(NAN);\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py b/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py\nindex 084e564b6462..5d987a6e91a1 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py\n@@ -4,6 +4,7 @@\n import numpy as np\n import pytest\n import decimal\n+from decimal import Decimal\n \n def create_generic_dataframe(data):\n     return pd.DataFrame({'0': pd.Series(data=data, dtype='object')})\n@@ -467,6 +468,39 @@ def test_analyze_sample_too_small(self):\n         with pytest.raises(duckdb.InvalidInputException, match=\"Failed to cast value: Unimplemented type for cast\"):\n             res = duckdb.query_df(x, \"x\", \"select * from x\").df()\n \n+    def test_numeric_decimal_zero_fractional(self):\n+        duckdb_conn = duckdb.connect()\n+        decimals = pd.DataFrame(\n+            data={\n+                \"0\": [\n+                    Decimal(\"0.00\"),\n+                    Decimal(\"125.90\"),\n+                    Decimal(\"0.001\"),\n+                    Decimal(\"2502.63\"),\n+                    Decimal(\"0.000123\"),\n+                    Decimal(\"0.00\"),\n+                    Decimal(\"321.00\"),\n+                ]\n+            }\n+        )\n+        reference_query = \"\"\"\n+            CREATE TABLE tbl AS SELECT * FROM (\n+                VALUES\n+                (0.00),\n+                (125.90),\n+                (0.001),\n+                (2502.63),\n+                (0.000123),\n+                (0.00),\n+                (321.00)\n+            ) tbl(a);\n+        \"\"\"\n+        duckdb_conn.execute(reference_query)\n+        reference = duckdb.query(\"select * from tbl\", connection=duckdb_conn).fetchall()\n+        conversion = duckdb.query_df(decimals, \"x\", \"select * from x\").fetchall()\n+\n+        assert(conversion == reference)\n+\n     def test_numeric_decimal_incompatible(self):\n         duckdb_conn = duckdb.connect()\n         reference_query = \"\"\"\n@@ -490,4 +524,80 @@ def test_numeric_decimal_incompatible(self):\n         conversion = duckdb.query_df(x, \"x\", \"select * from x\").fetchall()\n \n         assert(conversion == reference)\n+        print(reference)\n+        print(conversion)\n+\n+    #result: [('1E-28',), ('10000000000000000000000000.0',)]\n+    def test_numeric_decimal_combined(self):\n+        duckdb_conn = duckdb.connect()\n+        decimals = pd.DataFrame(\n+            data={\n+                \"0\": [\n+                    Decimal(\"0.0000000000000000000000000001\"),\n+                    Decimal(\"10000000000000000000000000.0\")\n+                ]\n+            }\n+        )\n+        reference_query = \"\"\"\n+            CREATE TABLE tbl AS SELECT * FROM (\n+                VALUES\n+                (0.0000000000000000000000000001),\n+                (10000000000000000000000000.0),\n+            ) tbl(a);\n+        \"\"\"\n+        duckdb_conn.execute(reference_query)\n+        reference = duckdb.query(\"select * from tbl\", connection=duckdb_conn).fetchall()\n+        conversion = duckdb.query_df(decimals, \"x\", \"select * from x\").fetchall()\n+        assert(conversion == reference)\n+        print(reference)\n+        print(conversion)\n+\n+    #result: [('1234.0',), ('123456789.0',), ('1234567890123456789.0',), ('0.1234567890123456789',)]\n+    def test_numeric_decimal_varying_sizes(self):\n+        duckdb_conn = duckdb.connect()\n+        decimals = pd.DataFrame(\n+            data={\n+                \"0\": [\n+                    Decimal(\"1234.0\"),\n+                    Decimal(\"123456789.0\"),\n+                    Decimal(\"1234567890123456789.0\"),\n+                    Decimal(\"0.1234567890123456789\")\n+                ]\n+            }\n+        )\n+        reference_query = \"\"\"\n+            CREATE TABLE tbl AS SELECT * FROM (\n+                VALUES\n+                    (1234.0),\n+                    (123456789.0),\n+                    (1234567890123456789.0),\n+                    (0.1234567890123456789)\n+            ) tbl(a);\n+        \"\"\"\n+        duckdb_conn.execute(reference_query)\n+        reference = duckdb.query(\"select * from tbl\", connection=duckdb_conn).fetchall()\n+        conversion = duckdb.query_df(decimals, \"x\", \"select * from x\").fetchall()\n+        assert(conversion == reference)\n+        print(reference)\n+        print(conversion)\n+\n+    def test_numeric_decimal_out_of_range(self):\n+        duckdb_conn = duckdb.connect()\n+        data = [Decimal(\"1.234567890123456789012345678901234567\"), Decimal(\"123456789012345678901234567890123456.0\")]\n+        decimals = pd.DataFrame(\n+            data={\n+                \"0\": data\n+            }\n+        )\n+        reference_query = \"\"\"\n+            CREATE TABLE tbl AS SELECT * FROM (\n+                VALUES\n+                    (1.234567890123456789012345678901234567),\n+                    (123456789012345678901234567890123456.0)\n+            ) tbl(a);\n+        \"\"\"\n+        duckdb_conn.execute(reference_query)\n+        reference = duckdb.query(\"select * from tbl\", connection=duckdb_conn).fetchall()\n+        conversion = duckdb.query_df(decimals, \"x\", \"select * from x\").fetchall()\n+        assert(conversion == reference)\n \n",
  "problem_statement": "Regression in Decimal handling in 0.5.0\n### What happens?\n\nWe are encountering a regression with the handling of dataframes with Python `Decimal` values in them with the 0.5.0 release. It appears to be an issue with how the width and scale parameters are inferred. I have checked our minimal repro and 0.4.0 is not affected, but 0.5.0 and the latest master branch builds are.\n\n### To Reproduce\n\nFirst we construct a dataframe with some Decimal values in it:\r\n\r\n```python\r\nimport pandas as pd\r\nfrom decimal import Decimal\r\n\r\ndecimals = pd.DataFrame(\r\n    data={\r\n        \"decimals\": [\r\n            Decimal(\"0.00\"),\r\n            Decimal(\"125.90\"),\r\n            Decimal(\"0.00\"),\r\n            Decimal(\"2502.63\"),\r\n            Decimal(\"0.00\"),\r\n            Decimal(\"0.00\"),\r\n            Decimal(\"321.00\"),\r\n        ]\r\n    }\r\n)\r\n```\r\n\r\nThen we try to query it:\r\n\r\n```python\r\nimport duckdb\r\n\r\nconn = duckdb.connect(database= \":memory\", read_only=False)\r\nconn.register(\"decimals\", decimals)\r\n\r\nconn.execute(\"select * from decimals\")\r\nresult = conn.df()\r\n```\r\n\r\nThis yields the error:\r\n\r\n```\r\nInvalidInputException: Invalid Input Error: Failed to cast value: Casting value \"125.90\" to type DECIMAL(38,39) failed: value is out of range!\r\n```\n\n### OS:\n\nmacOS, Linux\n\n### DuckDB Version:\n\n0.5.0\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nDylan Scott\n\n### Affiliation:\n\nHex Technologies\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "There is a very high chance that is my fault, as I've worked on the DECIMAL type in the last couple weeks, but it's not immediately clear to me why this example would (try to) produce DECIMAL(38,39) unless it's being passed as a plain float/double and the precision hell turns it into a value with a huge amount of decimals.\r\n\r\nBut it's passed as a string so that shouldn't happen, I'll have a look first thing tomorrow!\r\n\r\nAh.. decimal.Decimal logic..\r\n```py\r\ndecimal.Decimal(\"0.00\").as_tuple()\r\n----\r\nDecimalTuple(sign=0, digits=(0,), exponent=-2)\r\n```\r\nI expect the exponent to be the scale, which it is, but the width is 1, which is smaller than the scale..\r\nfor reference, \"12.00\" behaves properly\r\n```py\r\n>>> value = decimal.Decimal(\"12.00\")\r\n>>> value.as_tuple()\r\nDecimalTuple(sign=0, digits=(1, 2, 0, 0), exponent=-2)\r\n```\r\n\r\nAlso the fun doesn't stop there, any value starting with 0 \"optimizes\" out the extra digits\r\n```py\r\nDecimalTuple(sign=0, digits=(0,), exponent=-2)\r\n>>> decimal.Decimal(\".00\").as_tuple()\r\nDecimalTuple(sign=0, digits=(0,), exponent=-2)\r\n>>> decimal.Decimal(\"000.00\").as_tuple()\r\nDecimalTuple(sign=0, digits=(0,), exponent=-2)\r\n```\nTo elaborate, the issue is caused by one or more of these (**but not all**) conversions not being recognized as a valid decimal, falling back to double/float - And casting this to the final type of the column (DECIMAL) causes this error to be thrown",
  "created_at": "2022-09-12T21:52:25Z"
}