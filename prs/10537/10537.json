{
  "repo": "duckdb/duckdb",
  "pull_number": 10537,
  "instance_id": "duckdb__duckdb-10537",
  "issue_numbers": [
    "10486",
    "10486"
  ],
  "base_commit": "3f4d49ad91cd6b9a1e13eb3153d2bd2f2f3053f9",
  "patch": "diff --git a/src/common/types.cpp b/src/common/types.cpp\nindex 8fbec1d57ece..7a44b205f037 100644\n--- a/src/common/types.cpp\n+++ b/src/common/types.cpp\n@@ -1053,9 +1053,39 @@ LogicalType LogicalType::MaxLogicalType(ClientContext &context, const LogicalTyp\n \n void LogicalType::Verify() const {\n #ifdef DEBUG\n-\tif (id_ == LogicalTypeId::DECIMAL) {\n+\tswitch (id_) {\n+\tcase LogicalTypeId::DECIMAL:\n \t\tD_ASSERT(DecimalType::GetWidth(*this) >= 1 && DecimalType::GetWidth(*this) <= Decimal::MAX_WIDTH_DECIMAL);\n \t\tD_ASSERT(DecimalType::GetScale(*this) >= 0 && DecimalType::GetScale(*this) <= DecimalType::GetWidth(*this));\n+\t\tbreak;\n+\tcase LogicalTypeId::STRUCT: {\n+\t\t// verify child types\n+\t\tcase_insensitive_set_t child_names;\n+\t\tbool all_empty = true;\n+\t\tfor (auto &entry : StructType::GetChildTypes(*this)) {\n+\t\t\tif (entry.first.empty()) {\n+\t\t\t\tD_ASSERT(all_empty);\n+\t\t\t} else {\n+\t\t\t\t// check for duplicate struct names\n+\t\t\t\tall_empty = false;\n+\t\t\t\tauto existing_entry = child_names.find(entry.first);\n+\t\t\t\tD_ASSERT(existing_entry == child_names.end());\n+\t\t\t\tchild_names.insert(entry.first);\n+\t\t\t}\n+\t\t\tentry.second.Verify();\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::LIST:\n+\t\tListType::GetChildType(*this).Verify();\n+\t\tbreak;\n+\tcase LogicalTypeId::MAP: {\n+\t\tMapType::KeyType(*this).Verify();\n+\t\tMapType::ValueType(*this).Verify();\n+\t\tbreak;\n+\t}\n+\tdefault:\n+\t\tbreak;\n \t}\n #endif\n }\ndiff --git a/src/function/cast/struct_cast.cpp b/src/function/cast/struct_cast.cpp\nindex 3fbb46b53420..4aadeee393b2 100644\n--- a/src/function/cast/struct_cast.cpp\n+++ b/src/function/cast/struct_cast.cpp\n@@ -16,15 +16,42 @@ unique_ptr<BoundCastData> StructBoundCastData::BindStructToStructCast(BindCastIn\n \tif (source_child_types.size() != result_child_types.size()) {\n \t\tthrow TypeMismatchException(source, target, \"Cannot cast STRUCTs of different size\");\n \t}\n-\tfor (idx_t i = 0; i < source_child_types.size(); i++) {\n-\t\tif (!target_is_unnamed && !source_is_unnamed &&\n-\t\t    !StringUtil::CIEquals(source_child_types[i].first, result_child_types[i].first)) {\n-\t\t\tthrow TypeMismatchException(source, target, \"Cannot cast STRUCTs with different names\");\n+\tbool named_struct_cast = !source_is_unnamed && !target_is_unnamed;\n+\tcase_insensitive_map_t<idx_t> target_members;\n+\tif (named_struct_cast) {\n+\t\tfor (idx_t i = 0; i < result_child_types.size(); i++) {\n+\t\t\tauto &target_name = result_child_types[i].first;\n+\t\t\tif (target_members.find(target_name) != target_members.end()) {\n+\t\t\t\tthrow NotImplementedException(\"Error while casting - duplicate name \\\"%s\\\" in struct\", target_name);\n+\t\t\t}\n+\t\t\ttarget_members[target_name] = i;\n+\t\t}\n+\t}\n+\tvector<idx_t> child_member_map;\n+\tchild_member_map.reserve(source_child_types.size());\n+\tfor (idx_t source_idx = 0; source_idx < source_child_types.size(); source_idx++) {\n+\t\tauto &source_child = source_child_types[source_idx];\n+\t\tidx_t target_idx;\n+\t\tif (named_struct_cast) {\n+\t\t\t// named struct cast - find corresponding member in target\n+\t\t\tauto entry = target_members.find(source_child.first);\n+\t\t\tif (entry == target_members.end()) {\n+\t\t\t\tthrow TypeMismatchException(source, target,\n+\t\t\t\t                            \"Cannot cast STRUCTs - element \\\"\" + source_child.first +\n+\t\t\t\t                                \"\\\" in source struct was not found in target struct\");\n+\t\t\t}\n+\t\t\ttarget_idx = entry->second;\n+\t\t\ttarget_members.erase(entry);\n+\t\t} else {\n+\t\t\t// unnamed struct cast - positionally cast elements\n+\t\t\ttarget_idx = source_idx;\n \t\t}\n-\t\tauto child_cast = input.GetCastFunction(source_child_types[i].second, result_child_types[i].second);\n+\t\tchild_member_map.push_back(target_idx);\n+\t\tauto child_cast = input.GetCastFunction(source_child.second, result_child_types[target_idx].second);\n \t\tchild_cast_info.push_back(std::move(child_cast));\n \t}\n-\treturn make_uniq<StructBoundCastData>(std::move(child_cast_info), target);\n+\tD_ASSERT(child_member_map.size() == source_child_types.size());\n+\treturn make_uniq<StructBoundCastData>(std::move(child_cast_info), target, std::move(child_member_map));\n }\n \n unique_ptr<FunctionLocalState> StructBoundCastData::InitStructCastLocalState(CastLocalStateParameters &parameters) {\n@@ -52,8 +79,10 @@ static bool StructToStructCast(Vector &source, Vector &result, idx_t count, Cast\n \tauto &result_children = StructVector::GetEntries(result);\n \tbool all_converted = true;\n \tfor (idx_t c_idx = 0; c_idx < source_child_types.size(); c_idx++) {\n-\t\tauto &result_child_vector = *result_children[c_idx];\n-\t\tauto &source_child_vector = *source_children[c_idx];\n+\t\tauto source_idx = c_idx;\n+\t\tauto target_idx = cast_data.child_member_map[source_idx];\n+\t\tauto &source_child_vector = *source_children[source_idx];\n+\t\tauto &result_child_vector = *result_children[target_idx];\n \t\tCastParameters child_parameters(parameters, cast_data.child_cast_info[c_idx].cast_data,\n \t\t                                lstate.local_states[c_idx]);\n \t\tif (!cast_data.child_cast_info[c_idx].function(source_child_vector, result_child_vector, count,\ndiff --git a/src/function/scalar/list/list_zip.cpp b/src/function/scalar/list/list_zip.cpp\nindex ab5548321c71..fac930857e93 100644\n--- a/src/function/scalar/list/list_zip.cpp\n+++ b/src/function/scalar/list/list_zip.cpp\n@@ -130,17 +130,15 @@ static unique_ptr<FunctionData> ListZipBind(ClientContext &context, ScalarFuncti\n \t\tsize--;\n \t}\n \n+\tcase_insensitive_set_t struct_names;\n \tfor (idx_t i = 0; i < size; i++) {\n \t\tauto &child = arguments[i];\n-\t\tif (child->alias.empty()) {\n-\t\t\tchild->alias = \"list_\" + to_string(i + 1);\n-\t\t}\n \t\tswitch (child->return_type.id()) {\n \t\tcase LogicalTypeId::LIST:\n-\t\t\tstruct_children.push_back(make_pair(child->alias, ListType::GetChildType(child->return_type)));\n+\t\t\tstruct_children.push_back(make_pair(string(), ListType::GetChildType(child->return_type)));\n \t\t\tbreak;\n \t\tcase LogicalTypeId::SQLNULL:\n-\t\t\tstruct_children.push_back(make_pair(child->alias, LogicalTypeId::SQLNULL));\n+\t\t\tstruct_children.push_back(make_pair(string(), LogicalTypeId::SQLNULL));\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tthrow ParameterNotResolvedException();\ndiff --git a/src/include/duckdb/function/cast/bound_cast_data.hpp b/src/include/duckdb/function/cast/bound_cast_data.hpp\nindex 8645c24dd85d..50b4c70abba7 100644\n--- a/src/include/duckdb/function/cast/bound_cast_data.hpp\n+++ b/src/include/duckdb/function/cast/bound_cast_data.hpp\n@@ -48,12 +48,21 @@ struct ListCast {\n };\n \n struct StructBoundCastData : public BoundCastData {\n+\tStructBoundCastData(vector<BoundCastInfo> child_casts, LogicalType target_p, vector<idx_t> child_member_map_p)\n+\t    : child_cast_info(std::move(child_casts)), target(std::move(target_p)),\n+\t      child_member_map(std::move(child_member_map_p)) {\n+\t\tD_ASSERT(child_cast_info.size() == child_member_map.size());\n+\t}\n \tStructBoundCastData(vector<BoundCastInfo> child_casts, LogicalType target_p)\n \t    : child_cast_info(std::move(child_casts)), target(std::move(target_p)) {\n+\t\tfor (idx_t i = 0; i < child_cast_info.size(); i++) {\n+\t\t\tchild_member_map.push_back(i);\n+\t\t}\n \t}\n \n \tvector<BoundCastInfo> child_cast_info;\n \tLogicalType target;\n+\tvector<idx_t> child_member_map;\n \n \tstatic unique_ptr<BoundCastData> BindStructToStructCast(BindCastInput &input, const LogicalType &source,\n \t                                                        const LogicalType &target);\n@@ -65,7 +74,7 @@ struct StructBoundCastData : public BoundCastData {\n \t\tfor (auto &info : child_cast_info) {\n \t\t\tcopy_info.push_back(info.Copy());\n \t\t}\n-\t\treturn make_uniq<StructBoundCastData>(std::move(copy_info), target);\n+\t\treturn make_uniq<StructBoundCastData>(std::move(copy_info), target, child_member_map);\n \t}\n };\n \n",
  "test_patch": "diff --git a/src/function/table/system/test_all_types.cpp b/src/function/table/system/test_all_types.cpp\nindex da43d20ec034..53e41672a1c6 100644\n--- a/src/function/table/system/test_all_types.cpp\n+++ b/src/function/table/system/test_all_types.cpp\n@@ -196,7 +196,7 @@ vector<TestType> TestAllTypesFun::GetTestTypes(bool use_large_enum) {\n \tmap_struct1.push_back(make_pair(\"value\", Value(\"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\")));\n \tchild_list_t<Value> map_struct2;\n \tmap_struct2.push_back(make_pair(\"key\", Value(\"key2\")));\n-\tmap_struct2.push_back(make_pair(\"key\", Value(\"goose\")));\n+\tmap_struct2.push_back(make_pair(\"value\", Value(\"goose\")));\n \n \tvector<Value> map_values;\n \tmap_values.push_back(Value::STRUCT(map_struct1));\ndiff --git a/test/common/test_cast_struct.test b/test/common/test_cast_struct.test\nindex 7b96b6c442cc..c62b2a6d80c1 100644\n--- a/test/common/test_cast_struct.test\n+++ b/test/common/test_cast_struct.test\n@@ -9,7 +9,7 @@ PRAGMA enable_verification\n statement error\n select struct_extract(struct_pack(b=>42)::struct(a integer), 'a');\n ----\n-Mismatch Type Error: Type STRUCT(b INTEGER) does not match with STRUCT(a INTEGER). Cannot cast STRUCTs with different names\n+element \"b\" in source struct was not found in target struct\n \n query I\n select struct_extract(struct_pack(a=>42)::struct(a string), 'a');\n@@ -20,7 +20,7 @@ select struct_extract(struct_pack(a=>42)::struct(a string), 'a');\n statement error\n select struct_extract(struct_pack(b=>42)::row(a integer), 'a');\n ----\n-Mismatch Type Error: Type STRUCT(b INTEGER) does not match with STRUCT(a INTEGER). Cannot cast STRUCTs with different names\n+element \"b\" in source struct was not found in target struct\n \n query I\n select struct_extract(struct_pack(a=>42)::row(a integer), 'a');\n@@ -31,7 +31,7 @@ select struct_extract(struct_pack(a=>42)::row(a integer), 'a');\n statement error\n select struct_extract(struct_pack(b=>42::double)::struct(a integer), 'a');\n ----\n-Mismatch Type Error: Type STRUCT(b DOUBLE) does not match with STRUCT(a INTEGER). Cannot cast STRUCTs with different names\n+element \"b\" in source struct was not found in target struct\n \n query I\n select struct_extract(struct_pack(a=>42::double)::struct(a integer), 'a');\n@@ -41,7 +41,7 @@ select struct_extract(struct_pack(a=>42::double)::struct(a integer), 'a');\n statement error\n select struct_extract(struct_pack(b=>'42'::double)::struct(a integer), 'a');\n ----\n-Mismatch Type Error: Type STRUCT(b DOUBLE) does not match with STRUCT(a INTEGER). Cannot cast STRUCTs with different names\n+element \"b\" in source struct was not found in target struct\n \n query I\n select struct_extract(struct_pack(a=>'42'::double)::struct(a integer), 'a');\n@@ -76,12 +76,12 @@ Unimplemented type for cast (STRUCT(b INTEGER) -> INTEGER)\n statement error\n select struct_pack(b=>'hello'::string)::struct(a integer)\n ----\n-Mismatch Type Error: Type STRUCT(b VARCHAR) does not match with STRUCT(a INTEGER). Cannot cast STRUCTs with different names\n+element \"b\" in source struct was not found in target struct\n \n statement error\n select struct_pack(b=>'42'::double, c => 'asdf'::string)::struct(a1 integer, a2 string);\n ----\n-Mismatch Type Error: Type STRUCT(b DOUBLE, c VARCHAR) does not match with STRUCT(a1 INTEGER, a2 VARCHAR). Cannot cast STRUCTs with different names\n+element \"b\" in source struct was not found in target struct\n \n query I\n select struct_pack(a1 =>'42'::double, a2 => 'asdf'::string)::struct(a1 integer, a2 string);\ndiff --git a/test/sql/function/list/list_zip.test b/test/sql/function/list/list_zip.test\nindex 86ae5701c2ce..b6565d081716 100644\n--- a/test/sql/function/list/list_zip.test\n+++ b/test/sql/function/list/list_zip.test\n@@ -23,41 +23,41 @@ CREATE TABLE integers2 (j int[])\n statement ok\n INSERT INTO integers2 VALUES ([]), (NULL)\n \n-#normal use of list_zip\n+# normal use of list_zip\n query I\n SELECT list_zip([1,2,3])\n ----\n-[{'list_1': 1}, {'list_1': 2}, {'list_1': 3}]\n+[(1), (2), (3)]\n \n query I\n SELECT list_zip([1,2,3], [2,3,4], [3,4,5], []);\n ----\n-[{'list_1': 1, 'list_2': 2, 'list_3': 3, 'list_4': NULL}, {'list_1': 2, 'list_2': 3, 'list_3': 4, 'list_4': NULL}, {'list_1': 3, 'list_2': 4, 'list_3': 5, 'list_4': NULL}]\n+[(1, 2, 3, NULL), (2, 3, 4, NULL), (3, 4, 5, NULL)]\n \n query I\n SELECT list_zip([1,2,3], [1,2,3])\n ----\n-[{'list_1': 1, 'list_2': 1}, {'list_1': 2, 'list_2': 2}, {'list_1': 3, 'list_2': 3}]\n+[(1, 1), (2, 2), (3, 3)]\n \n query I\n SELECT list_zip([1,2,3], [1,2])\n ----\n-[{'list_1': 1, 'list_2': 1}, {'list_1': 2, 'list_2': 2}, {'list_1': 3, 'list_2': NULL}]\n+[(1, 1), (2, 2), (3, NULL)]\n \n query I\n SELECT list_zip([1,2], [1,2,3])\n ----\n-[{'list_1': 1, 'list_2': 1}, {'list_1': 2, 'list_2': 2}, {'list_1': NULL, 'list_2': 3}]\n+[(1, 1), (2, 2), (NULL, 3)]\n \n query I\n SELECT list_zip([1,2,3], NULL)\n ----\n-[{'list_1': 1, 'list_2': NULL}, {'list_1': 2, 'list_2': NULL}, {'list_1': 3, 'list_2': NULL}]\n+[(1, NULL), (2, NULL), (3, NULL)]\n \n query I\n SELECT list_zip([1,2,3], [])\n ----\n-[{'list_1': 1, 'list_2': NULL}, {'list_1': 2, 'list_2': NULL}, {'list_1': 3, 'list_2': NULL}]\n+[(1, NULL), (2, NULL), (3, NULL)]\n \n query I\n SELECT list_zip([1,2,3], NULL, true)\n@@ -77,46 +77,46 @@ SELECT list_zip([1,2,3], [2,3,4], [3,4,5], [], true);\n query I\n SELECT list_zip(a.i, b.i) as zipped_list FROM integers AS a, integers as b order by all;\n ----\n-[{'i': 1, 'i': 1}, {'i': 2, 'i': 2}, {'i': 3, 'i': 3}]\n-[{'i': 1, 'i': 4}, {'i': 2, 'i': 5}, {'i': 3, 'i': 6}]\n-[{'i': 4, 'i': 1}, {'i': 5, 'i': 2}, {'i': 6, 'i': 3}]\n-[{'i': 4, 'i': 4}, {'i': 5, 'i': 5}, {'i': 6, 'i': 6}]\n+[(1, 1), (2, 2), (3, 3)]\n+[(1, 4), (2, 5), (3, 6)]\n+[(4, 1), (5, 2), (6, 3)]\n+[(4, 4), (5, 5), (6, 6)]\n \n query I\n SELECT list_zip(a.i, b.i, b.i) FROM integers AS a, integers AS b order by all\n ----\n-[{'i': 1, 'i': 1, 'i': 1}, {'i': 2, 'i': 2, 'i': 2}, {'i': 3, 'i': 3, 'i': 3}]\n-[{'i': 1, 'i': 4, 'i': 4}, {'i': 2, 'i': 5, 'i': 5}, {'i': 3, 'i': 6, 'i': 6}]\n-[{'i': 4, 'i': 1, 'i': 1}, {'i': 5, 'i': 2, 'i': 2}, {'i': 6, 'i': 3, 'i': 3}]\n-[{'i': 4, 'i': 4, 'i': 4}, {'i': 5, 'i': 5, 'i': 5}, {'i': 6, 'i': 6, 'i': 6}]\n+[(1, 1, 1), (2, 2, 2), (3, 3, 3)]\n+[(1, 4, 4), (2, 5, 5), (3, 6, 6)]\n+[(4, 1, 1), (5, 2, 2), (6, 3, 3)]\n+[(4, 4, 4), (5, 5, 5), (6, 6, 6)]\n \n query I\n SELECT list_zip([1,2,3], true)\n ----\n-[{'list_1': 1}, {'list_1': 2}, {'list_1': 3}]\n+[(1), (2), (3)]\n \n query I\n SELECT list_zip([1,2,3], [1,2,3], true)\n ----\n-[{'list_1': 1, 'list_2': 1}, {'list_1': 2, 'list_2': 2}, {'list_1': 3, 'list_2': 3}]\n+[(1, 1), (2, 2), (3, 3)]\n \n query I\n SELECT list_zip([1,2,3], [1,2], true)\n ----\n-[{'list_1': 1, 'list_2': 1}, {'list_1': 2, 'list_2': 2}]\n+[(1, 1), (2, 2)]\n \n query I\n SELECT list_zip([1,2], [1,2,3], true)\n ----\n-[{'list_1': 1, 'list_2': 1}, {'list_1': 2, 'list_2': 2}]\n+[(1, 1), (2, 2)]\n \n query I\n SELECT list_zip(i, j, b) FROM integers, integers2, bools order by all desc\n ----\n-[{'i': 4, 'j': NULL}, {'i': 5, 'j': NULL}, {'i': 6, 'j': NULL}]\n-[{'i': 4, 'j': NULL}, {'i': 5, 'j': NULL}, {'i': 6, 'j': NULL}]\n-[{'i': 1, 'j': NULL}, {'i': 2, 'j': NULL}, {'i': 3, 'j': NULL}]\n-[{'i': 1, 'j': NULL}, {'i': 2, 'j': NULL}, {'i': 3, 'j': NULL}]\n+[(4, NULL), (5, NULL), (6, NULL)]\n+[(4, NULL), (5, NULL), (6, NULL)]\n+[(1, NULL), (2, NULL), (3, NULL)]\n+[(1, NULL), (2, NULL), (3, NULL)]\n []\n []\n []\n@@ -139,23 +139,23 @@ SELECT list_zip([1,2,3], [true, false, NULL], [{'list_1': 1}, {'list_1': 2}, {'l\n query I\n SELECT list_zip([true, false, NULL])\n ----\n-[{'list_1': true}, {'list_1': false}, {'list_1': NULL}]\n+[(true), (false), (NULL)]\n \n query I\n SELECT list_zip([NULL::BOOLEAN, true])\n ----\n-[{'list_1': NULL}, {'list_1': true}]\n+[(NULL), (true)]\n \n # VARCHAR\n query I\n SELECT list_zip(['aa', 'a'])\n ----\n-[{'list_1': aa}, {'list_1': a}]\n+[(aa), (a)]\n \n query I\n SELECT list_zip([NULL::VARCHAR])\n ----\n-[{'list_1': NULL}]\n+[(NULL)]\n \n # INTEGER types\n foreach type tinyint smallint integer bigint hugeint utinyint usmallint uinteger ubigint\n@@ -163,12 +163,12 @@ foreach type tinyint smallint integer bigint hugeint utinyint usmallint uinteger\n query I\n SELECT list_zip([1::${type}, NULL, 2::${type}])\n ----\n-[{'list_1': 1}, {'list_1': NULL}, {'list_1': 2}]\n+[(1), (NULL), (2)]\n \n query I\n SELECT list_zip([NULL::${type}])\n ----\n-[{'list_1': NULL}]\n+[(NULL)]\n \n endloop\n \n@@ -182,7 +182,7 @@ SELECT list_zip([1::${type}])\n query I\n SELECT list_zip([NULL::${type}])\n ----\n-[{'list_1': NULL}]\n+[(NULL)]\n \n endloop\n \n@@ -192,62 +192,62 @@ endloop\n query I\n SELECT list_zip(['2021-08-20'::DATE])\n ----\n-[{'list_1': 2021-08-20}]\n+[(2021-08-20)]\n \n # time\n query I\n SELECT list_zip(['14:59:37'::TIME])\n ----\n-[{'list_1': 14:59:37}]\n+[(14:59:37)]\n \n # timestamp\n query I\n SELECT list_zip(['2021-08-20'::TIMESTAMP])\n ----\n-[{'list_1': 2021-08-20 00:00:00}]\n+[(2021-08-20 00:00:00)]\n \n # timestamp s\n query I\n SELECT list_zip(['2021-08-20'::TIMESTAMP_S])\n ----\n-[{'list_1': 2021-08-20 00:00:00}]\n+[(2021-08-20 00:00:00)]\n \n # timestamp ms\n query I\n SELECT list_zip(['2021-08-20 00:00:00.123'::TIMESTAMP_MS])\n ----\n-[{'list_1': 2021-08-20 00:00:00.123}]\n+[(2021-08-20 00:00:00.123)]\n \n # timestamp ns\n query I\n SELECT list_zip(['2021-08-20 00:00:00.123456'::TIMESTAMP_NS])\n ----\n-[{'list_1': 2021-08-20 00:00:00.123456}]\n+[(2021-08-20 00:00:00.123456)]\n \n # time with time zone\n query I\n SELECT list_zip(['14:59:37'::TIMETZ])\n ----\n-[{'list_1': 14:59:37+00}]\n+[(14:59:37+00)]\n \n # timestamp with time zone\n query I\n SELECT list_zip(['2021-08-20'::TIMESTAMPTZ])\n ----\n-[{'list_1': 2021-08-20 00:00:00+00}]\n+[(2021-08-20 00:00:00+00)]\n \n # interval\n query I\n SELECT list_zip([INTERVAL 1 YEAR])\n ----\n-[{'list_1': 1 year}]\n+[(1 year)]\n \n foreach type date time timestamp timestamp_s timestamp_ms timestamp_ns timetz timestamptz interval\n \n query I\n SELECT list_zip([NULL::${type}])\n ----\n-[{'list_1': NULL}]\n+[(NULL)]\n \n endloop\n \n@@ -256,12 +256,12 @@ endloop\n query I\n SELECT list_zip(['{a: 1}'::BLOB, '{a: 3}'::BLOB])\n ----\n-[{'list_1': {a: 1}}, {'list_1': {a: 3}}]\n+[({a: 1}), ({a: 3})]\n \n query I\n SELECT list_zip([NULL::BLOB])\n ----\n-[{'list_1': NULL}]\n+[(NULL)]\n \n # ENUMS\n \n@@ -277,17 +277,17 @@ INSERT INTO enums VALUES (['happy', 'sad'])\n query I\n SELECT list_zip(e) FROM enums\n ----\n-[{'e': happy}, {'e': sad}]\n+[(happy), (sad)]\n \n # NESTED types\n \n query I\n SELECT list_zip([[1], [1, 2], NULL])\n ----\n-[{'list_1': [1]}, {'list_1': [1, 2]}, {'list_1': NULL}]\n+[([1]), ([1, 2]), (NULL)]\n \n query I\n SELECT list_zip([{'a': 1}, {'a': 5}, {'a': 3}])\n ----\n-[{'list_1': {'a': 1}}, {'list_1': {'a': 5}}, {'list_1': {'a': 3}}]\n+[({'a': 1}), ({'a': 5}), ({'a': 3})]\n \ndiff --git a/test/sql/types/struct/struct_different_names.test b/test/sql/types/struct/struct_different_names.test\nindex adeeddde7ad5..b6eaf5052af7 100644\n--- a/test/sql/types/struct/struct_different_names.test\n+++ b/test/sql/types/struct/struct_different_names.test\n@@ -17,7 +17,7 @@ CREATE TABLE foo (bar struct(pip int));\n statement error\n INSERT INTO foo VALUES ({'ignoreme': 3});\n ----\n-Mismatch Type Error: Type STRUCT(ignoreme INTEGER) does not match with STRUCT(pip INTEGER). Cannot cast STRUCTs with different names\n+element \"ignoreme\" in source struct was not found in target struct\n \n statement error\n create table wrong as from (VALUES (ROW(3)));\n@@ -35,15 +35,15 @@ SELECT * FROM foo;\n statement ok\n CREATE OR REPLACE TABLE T AS SELECT [{'a': 'A', 'b':'B'}] as x, [{'b':'BB','a':'AA'}] as y;\n \n-statement error\n+query III\n SELECT x, y, ARRAY_CONCAT(x, y) FROM T;\n ----\n-Mismatch Type Error: Type STRUCT(b VARCHAR, a VARCHAR) does not match with STRUCT(a VARCHAR, b VARCHAR). Cannot cast STRUCTs with different names\n+[{'a': A, 'b': B}]\t[{'b': BB, 'a': AA}]\t[{'a': A, 'b': B}, {'a': AA, 'b': BB}]\n \n statement error\n INSERT INTO t1 VALUES ({c: 34});\n ----\n-Mismatch Type Error: Type STRUCT(c INTEGER) does not match with STRUCT(v VARCHAR). Cannot cast STRUCTs with different names\n+element \"c\" in source struct was not found in target struct\n \n statement ok\n CREATE OR REPLACE TABLE T (s STRUCT(a INT, b INT));\n@@ -51,7 +51,7 @@ CREATE OR REPLACE TABLE T (s STRUCT(a INT, b INT));\n statement error\n INSERT INTO T VALUES ({l: 1, m: 2}), ({x: 3, y: 4});\n ----\n-Mismatch Type Error: Type STRUCT(l INTEGER, m INTEGER) does not match with STRUCT(a INTEGER, b INTEGER). Cannot cast STRUCTs with different names\n+element \"l\" in source struct was not found in target struct\n \n # Can insert unnamed struct into named struct\n \n@@ -70,7 +70,7 @@ Invalid Input Error: A table cannot be created from an unnamed struct\n statement error\n SELECT [{'foo': True}, {'bar': False}, {'foobar': NULL}];\n ----\n-Mismatch Type Error: Type STRUCT(bar BOOLEAN) does not match with STRUCT(foo BOOLEAN). Cannot cast STRUCTs with different names\n+element \"bar\" in source struct was not found in target struct\n \n statement ok\n PREPARE v1 as SELECT ROW(?);\ndiff --git a/test/sql/types/struct/struct_named_cast.test b/test/sql/types/struct/struct_named_cast.test\nnew file mode 100644\nindex 000000000000..f64d0c514137\n--- /dev/null\n+++ b/test/sql/types/struct/struct_named_cast.test\n@@ -0,0 +1,35 @@\n+# name: test/sql/types/struct/struct_named_cast.test\n+# description: Test struct named casts\n+# group: [struct]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+SELECT {'a': 42, 'b': 84}::STRUCT(b INT, a INT)\n+----\n+{'b': 84, 'a': 42}\n+\n+# nested\n+query I\n+SELECT {'a': ['1', '2', '3'], 'b': 84}::STRUCT(b INT, a INT[])\n+----\n+{'b': 84, 'a': [1, 2, 3]}\n+\n+# case insensitivity\n+query I\n+SELECT {'a': ['1', '2', '3'], 'b': 84}::STRUCT(b INT, A INT[])\n+----\n+{'b': 84, 'A': [1, 2, 3]}\n+\n+# name mismatch\n+statement error\n+SELECT {'a': ['1', '2', '3'], 'b': 84}::STRUCT(b INT, c INT[])\n+----\n+element \"a\" in source struct was not found in target struct\n+\n+# unnamed struct cast\n+query I\n+SELECT ROW(42, 84)::STRUCT(a INT, b INT)\n+----\n+{'a': 42, 'b': 84}\n",
  "problem_statement": "Casting structs with fields of the same name, but in a different order fails with `Mismatch Type Error`\n### What happens?\n\nCasting structs with fields of the same name, but in a different order fails with `duckdb.duckdb.TypeMismatchException: Mismatch Type Error`.\r\n\r\n[The documentation](https://duckdb.org/docs/sql/data_types/struct.html) about casting structs only mention that field names have to match:\r\n\r\n> When casting structs, the names of fields have to match\r\n\r\nIf the requirement is that the fields have to be in the same order, then perhaps it could be made more explicit in the documentation.\n\n### To Reproduce\n\n```sql\r\nCREATE TABLE t1 (s STRUCT(a STRING, b INT));\r\nINSERT INTO t1 SELECT {'b': 42, 'a': 'foo'};\r\n```\r\n\r\n```\r\nduckdb.duckdb.TypeMismatchException: Mismatch Type Error: Type STRUCT(b INTEGER, a VARCHAR) does not match with STRUCT(a VARCHAR, b INTEGER). Cannot cast STRUCTs with different names\r\n```\n\n### OS:\n\naarch64\n\n### DuckDB Version:\n\n0.9.2\n\n### DuckDB Client:\n\npython\n\n### Full Name:\n\nPhilippe Laflamme\n\n### Affiliation:\n\nN/A\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a nightly build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\nCasting structs with fields of the same name, but in a different order fails with `Mismatch Type Error`\n### What happens?\n\nCasting structs with fields of the same name, but in a different order fails with `duckdb.duckdb.TypeMismatchException: Mismatch Type Error`.\r\n\r\n[The documentation](https://duckdb.org/docs/sql/data_types/struct.html) about casting structs only mention that field names have to match:\r\n\r\n> When casting structs, the names of fields have to match\r\n\r\nIf the requirement is that the fields have to be in the same order, then perhaps it could be made more explicit in the documentation.\n\n### To Reproduce\n\n```sql\r\nCREATE TABLE t1 (s STRUCT(a STRING, b INT));\r\nINSERT INTO t1 SELECT {'b': 42, 'a': 'foo'};\r\n```\r\n\r\n```\r\nduckdb.duckdb.TypeMismatchException: Mismatch Type Error: Type STRUCT(b INTEGER, a VARCHAR) does not match with STRUCT(a VARCHAR, b INTEGER). Cannot cast STRUCTs with different names\r\n```\n\n### OS:\n\naarch64\n\n### DuckDB Version:\n\n0.9.2\n\n### DuckDB Client:\n\npython\n\n### Full Name:\n\nPhilippe Laflamme\n\n### Affiliation:\n\nN/A\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a nightly build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2024-02-08T16:11:45Z"
}