You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
NullPointer at sqlite3_api_wrapper.cpp:237:75
#### What happens?
NullPointer at sqlite3_api_wrapper.cpp:237:75

#### To Reproduce
```sql
CREATE TABLE strings (a INTEGER DEFAULT -1, b INTEGER DEFAULT -2, t0 INTEGER DEFAULT -3);
DELETE FROM strings
WHERE b IN (SELECT sum(a) FROM strings GROUP BY b)
RETURNING *;
```

#### Environment (please complete the following information):
 - OS: linux
 - DuckDB Version: v0.3.3-dev1395 80ae1e12d
 - DuckDB Client: /usr/local/bin/duckdb

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

#### UBSAN detail
```
/root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:237:75: runtime error: member call on null pointer of type 'duckdb::DataChunk'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:237:75 in 
```
NullPointer at sqlite3_api_wrapper.cpp:237:75
#### What happens?
NullPointer at sqlite3_api_wrapper.cpp:237:75

#### To Reproduce
```sql
CREATE TABLE strings (a INTEGER DEFAULT -1, b INTEGER DEFAULT -2, t0 INTEGER DEFAULT -3);
DELETE FROM strings
WHERE b IN (SELECT sum(a) FROM strings GROUP BY b)
RETURNING *;
```

#### Environment (please complete the following information):
 - OS: linux
 - DuckDB Version: v0.3.3-dev1395 80ae1e12d
 - DuckDB Client: /usr/local/bin/duckdb

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

#### UBSAN detail
```
/root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:237:75: runtime error: member call on null pointer of type 'duckdb::DataChunk'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:237:75 in 
```

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp]
1: #include "sqlite3.h"
2: #include "udf_struct_sqlite3.h"
3: #include "sqlite3_udf_wrapper.hpp"
4: 
5: #include "duckdb.hpp"
6: #include "duckdb/parser/parser.hpp"
7: #include "duckdb/main/client_context.hpp"
8: #include "duckdb/common/types.hpp"
9: #include "duckdb/common/operator/cast_operators.hpp"
10: 
11: #include "utf8proc_wrapper.hpp"
12: 
13: #include <ctype.h>
14: #include <stdio.h>
15: #include <stdlib.h>
16: #include <string.h>
17: #include <time.h>
18: #include <string>
19: #include <chrono>
20: #include <cassert>
21: #include <climits>
22: 
23: using namespace duckdb;
24: using namespace std;
25: 
26: static char *sqlite3_strdup(const char *str);
27: 
28: struct sqlite3_string_buffer {
29: 	//! String data
30: 	unique_ptr<char[]> data;
31: 	//! String length
32: 	int data_len;
33: };
34: 
35: struct sqlite3_stmt {
36: 	//! The DB object that this statement belongs to
37: 	sqlite3 *db;
38: 	//! The query string
39: 	string query_string;
40: 	//! The prepared statement object, if successfully prepared
41: 	unique_ptr<PreparedStatement> prepared;
42: 	//! The result object, if successfully executed
43: 	unique_ptr<QueryResult> result;
44: 	//! The current chunk that we are iterating over
45: 	unique_ptr<DataChunk> current_chunk;
46: 	//! The current row into the current chunk that we are iterating over
47: 	int64_t current_row;
48: 	//! Bound values, used for binding to the prepared statement
49: 	vector<Value> bound_values;
50: 	//! Names of the prepared parameters
51: 	vector<string> bound_names;
52: 	//! The current column values converted to string, used and filled by sqlite3_column_text
53: 	unique_ptr<sqlite3_string_buffer[]> current_text;
54: };
55: 
56: void sqlite3_randomness(int N, void *pBuf) {
57: 	static bool init = false;
58: 	if (!init) {
59: 		srand(time(NULL));
60: 		init = true;
61: 	}
62: 	unsigned char *zBuf = (unsigned char *)pBuf;
63: 	while (N--) {
64: 		unsigned char nextByte = rand() % 255;
65: 		zBuf[N] = nextByte;
66: 	}
67: }
68: 
69: int sqlite3_open(const char *filename, /* Database filename (UTF-8) */
70:                  sqlite3 **ppDb        /* OUT: SQLite db handle */
71: ) {
72: 	return sqlite3_open_v2(filename, ppDb, 0, NULL);
73: }
74: 
75: int sqlite3_open_v2(const char *filename, /* Database filename (UTF-8) */
76:                     sqlite3 **ppDb,       /* OUT: SQLite db handle */
77:                     int flags,            /* Flags */
78:                     const char *zVfs      /* Name of VFS module to use */
79: ) {
80: 	if (filename && strcmp(filename, ":memory:") == 0) {
81: 		filename = NULL;
82: 	}
83: 	*ppDb = nullptr;
84: 	if (zVfs) { /* unsupported so if set we complain */
85: 		return SQLITE_ERROR;
86: 	}
87: 	int rc = SQLITE_OK;
88: 	sqlite3 *pDb = nullptr;
89: 	try {
90: 		pDb = new sqlite3();
91: 		DBConfig config;
92: 		config.access_mode = AccessMode::AUTOMATIC;
93: 		if (flags & SQLITE_OPEN_READONLY) {
94: 			config.access_mode = AccessMode::READ_ONLY;
95: 		}
96: 		pDb->db = make_unique<DuckDB>(filename, &config);
97: 		pDb->con = make_unique<Connection>(*pDb->db);
98: 	} catch (std::exception &ex) {
99: 		if (pDb) {
100: 			pDb->last_error = ex.what();
101: 			pDb->errCode = SQLITE_ERROR;
102: 		}
103: 		rc = SQLITE_ERROR;
104: 	}
105: 	*ppDb = pDb;
106: 	return rc;
107: }
108: 
109: int sqlite3_close(sqlite3 *db) {
110: 	if (db) {
111: 		delete db;
112: 	}
113: 	return SQLITE_OK;
114: }
115: 
116: int sqlite3_shutdown(void) {
117: 	return SQLITE_OK;
118: }
119: 
120: /* In SQLite this function compiles the query into VDBE bytecode,
121:  * in the implementation it currently executes the query */
122: // TODO: prepare the statement instead of executing right away
123: int sqlite3_prepare_v2(sqlite3 *db,           /* Database handle */
124:                        const char *zSql,      /* SQL statement, UTF-8 encoded */
125:                        int nByte,             /* Maximum length of zSql in bytes. */
126:                        sqlite3_stmt **ppStmt, /* OUT: Statement handle */
127:                        const char **pzTail    /* OUT: Pointer to unused portion of zSql */
128: ) {
129: 	if (!db || !ppStmt || !zSql) {
130: 		return SQLITE_MISUSE;
131: 	}
132: 	*ppStmt = nullptr;
133: 	string query = nByte < 0 ? zSql : string(zSql, nByte);
134: 	if (pzTail) {
135: 		*pzTail = zSql + query.size();
136: 	}
137: 	try {
138: 		Parser parser(db->con->context->GetParserOptions());
139: 		parser.ParseQuery(query);
140: 		if (parser.statements.size() == 0) {
141: 			return SQLITE_OK;
142: 		}
143: 		// extract the remainder
144: 		idx_t next_location = parser.statements[0]->stmt_location + parser.statements[0]->stmt_length;
145: 		bool set_remainder = next_location < query.size();
146: 
147: 		// extract the first statement
148: 		vector<unique_ptr<SQLStatement>> statements;
149: 		statements.push_back(move(parser.statements[0]));
150: 
151: 		db->con->context->HandlePragmaStatements(statements);
152: 
153: 		// if there are multiple statements here, we are dealing with an import database statement
154: 		// we directly execute all statements besides the final one
155: 		for (idx_t i = 0; i + 1 < statements.size(); i++) {
156: 			auto res = db->con->Query(move(statements[i]));
157: 			if (!res->success) {
158: 				db->last_error = res->error;
159: 				return SQLITE_ERROR;
160: 			}
161: 		}
162: 
163: 		// now prepare the query
164: 		auto prepared = db->con->Prepare(move(statements.back()));
165: 		if (!prepared->success) {
166: 			// failed to prepare: set the error message
167: 			db->last_error = prepared->error;
168: 			return SQLITE_ERROR;
169: 		}
170: 
171: 		// create the statement entry
172: 		unique_ptr<sqlite3_stmt> stmt = make_unique<sqlite3_stmt>();
173: 		stmt->db = db;
174: 		stmt->query_string = query;
175: 		stmt->prepared = move(prepared);
176: 		stmt->current_row = -1;
177: 		for (idx_t i = 0; i < stmt->prepared->n_param; i++) {
178: 			stmt->bound_names.push_back("$" + to_string(i + 1));
179: 			stmt->bound_values.push_back(Value());
180: 		}
181: 
182: 		// extract the remainder of the query and assign it to the pzTail
183: 		if (pzTail && set_remainder) {
184: 			*pzTail = zSql + next_location + 1;
185: 		}
186: 
187: 		*ppStmt = stmt.release();
188: 		return SQLITE_OK;
189: 	} catch (std::exception &ex) {
190: 		db->last_error = ex.what();
191: 		return SQLITE_ERROR;
192: 	}
193: }
194: 
195: bool sqlite3_display_result(StatementType type) {
196: 	switch (type) {
197: 	case StatementType::EXECUTE_STATEMENT:
198: 	case StatementType::EXPLAIN_STATEMENT:
199: 	case StatementType::PRAGMA_STATEMENT:
200: 	case StatementType::SELECT_STATEMENT:
201: 	case StatementType::SHOW_STATEMENT:
202: 	case StatementType::CALL_STATEMENT:
203: 		return true;
204: 	default:
205: 		return false;
206: 	}
207: }
208: 
209: /* Prepare the next result to be retrieved */
210: int sqlite3_step(sqlite3_stmt *pStmt) {
211: 	if (!pStmt) {
212: 		return SQLITE_MISUSE;
213: 	}
214: 	if (!pStmt->prepared) {
215: 		pStmt->db->last_error = "Attempting sqlite3_step() on a non-successfully prepared statement";
216: 		return SQLITE_ERROR;
217: 	}
218: 	pStmt->current_text = nullptr;
219: 	if (!pStmt->result) {
220: 		// no result yet! call Execute()
221: 		pStmt->result = pStmt->prepared->Execute(pStmt->bound_values, true);
222: 		if (!pStmt->result->success) {
223: 			// error in execute: clear prepared statement
224: 			pStmt->db->last_error = pStmt->result->error;
225: 			pStmt->prepared = nullptr;
226: 			return SQLITE_ERROR;
227: 		}
228: 		// fetch a chunk
229: 		if (!pStmt->result->TryFetch(pStmt->current_chunk, pStmt->db->last_error)) {
230: 			pStmt->prepared = nullptr;
231: 			return SQLITE_ERROR;
232: 		}
233: 
234: 		pStmt->current_row = -1;
235: 
236: 		auto statement_type = pStmt->prepared->GetStatementType();
237: 		if (StatementTypeReturnChanges(statement_type) && pStmt->current_chunk->size() > 0) {
238: 			// update total changes
239: 			auto row_changes = pStmt->current_chunk->GetValue(0, 0);
240: 			if (!row_changes.IsNull() && row_changes.TryCastAs(LogicalType::BIGINT)) {
241: 				pStmt->db->last_changes = row_changes.GetValue<int64_t>();
242: 				pStmt->db->total_changes += row_changes.GetValue<int64_t>();
243: 			}
244: 		}
245: 		if (!sqlite3_display_result(statement_type)) {
246: 			// only SELECT statements return results
247: 			sqlite3_reset(pStmt);
248: 		}
249: 	}
250: 	if (!pStmt->current_chunk || pStmt->current_chunk->size() == 0) {
251: 		return SQLITE_DONE;
252: 	}
253: 	pStmt->current_row++;
254: 	if (pStmt->current_row >= (int32_t)pStmt->current_chunk->size()) {
255: 		// have to fetch again!
256: 		pStmt->current_row = 0;
257: 		if (!pStmt->result->TryFetch(pStmt->current_chunk, pStmt->db->last_error)) {
258: 			pStmt->prepared = nullptr;
259: 			return SQLITE_ERROR;
260: 		}
261: 		if (!pStmt->current_chunk || pStmt->current_chunk->size() == 0) {
262: 			sqlite3_reset(pStmt);
263: 			return SQLITE_DONE;
264: 		}
265: 	}
266: 	return SQLITE_ROW;
267: }
268: 
269: /* Execute multiple semicolon separated SQL statements
270:  * and execute the passed callback for each produced result,
271:  * largely copied from the original sqlite3 source */
272: int sqlite3_exec(sqlite3 *db,                /* The database on which the SQL executes */
273:                  const char *zSql,           /* The SQL to be executed */
274:                  sqlite3_callback xCallback, /* Invoke this callback routine */
275:                  void *pArg,                 /* First argument to xCallback() */
276:                  char **pzErrMsg             /* Write error messages here */
277: ) {
278: 	int rc = SQLITE_OK;            /* Return code */
279: 	const char *zLeftover;         /* Tail of unprocessed SQL */
280: 	sqlite3_stmt *pStmt = nullptr; /* The current SQL statement */
281: 	char **azCols = nullptr;       /* Names of result columns */
282: 	char **azVals = nullptr;       /* Result values */
283: 
284: 	if (zSql == nullptr) {
285: 		zSql = "";
286: 	}
287: 
288: 	while (rc == SQLITE_OK && zSql[0]) {
289: 		int nCol;
290: 
291: 		pStmt = nullptr;
292: 		rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
293: 		if (rc != SQLITE_OK) {
294: 			if (pzErrMsg) {
295: 				auto errmsg = sqlite3_errmsg(db);
296: 				*pzErrMsg = errmsg ? sqlite3_strdup(errmsg) : nullptr;
297: 			}
298: 			continue;
299: 		}
300: 		if (!pStmt) {
301: 			/* this happens for a comment or white-space */
302: 			zSql = zLeftover;
303: 			continue;
304: 		}
305: 
306: 		nCol = sqlite3_column_count(pStmt);
307: 		azCols = (char **)malloc(nCol * sizeof(const char *));
308: 		azVals = (char **)malloc(nCol * sizeof(const char *));
309: 		if (!azCols || !azVals) {
310: 			goto exec_out;
311: 		}
312: 		for (int i = 0; i < nCol; i++) {
313: 			azCols[i] = (char *)sqlite3_column_name(pStmt, i);
314: 		}
315: 
316: 		while (true) {
317: 			rc = sqlite3_step(pStmt);
318: 
319: 			/* Invoke the callback function if required */
320: 			if (xCallback && rc == SQLITE_ROW) {
321: 				for (int i = 0; i < nCol; i++) {
322: 					azVals[i] = (char *)sqlite3_column_text(pStmt, i);
323: 					if (!azVals[i] && sqlite3_column_type(pStmt, i) != SQLITE_NULL) {
324: 						fprintf(stderr, "sqlite3_exec: out of memory.\n");
325: 						goto exec_out;
326: 					}
327: 				}
328: 				if (xCallback(pArg, nCol, azVals, azCols)) {
329: 					/* EVIDENCE-OF: R-38229-40159 If the callback function to
330: 					** sqlite3_exec() returns non-zero, then sqlite3_exec() will
331: 					** return SQLITE_ABORT. */
332: 					rc = SQLITE_ABORT;
333: 					sqlite3_finalize(pStmt);
334: 					pStmt = 0;
335: 					fprintf(stderr, "sqlite3_exec: callback returned non-zero. "
336: 					                "Aborting.\n");
337: 					goto exec_out;
338: 				}
339: 			}
340: 			if (rc == SQLITE_DONE) {
341: 				rc = sqlite3_finalize(pStmt);
342: 				pStmt = nullptr;
343: 				zSql = zLeftover;
344: 				while (isspace(zSql[0]))
345: 					zSql++;
346: 				break;
347: 			} else if (rc != SQLITE_ROW) {
348: 				// error
349: 				if (pzErrMsg) {
350: 					auto errmsg = sqlite3_errmsg(db);
351: 					*pzErrMsg = errmsg ? sqlite3_strdup(errmsg) : nullptr;
352: 				}
353: 				goto exec_out;
354: 			}
355: 		}
356: 
357: 		sqlite3_free(azCols);
358: 		sqlite3_free(azVals);
359: 		azCols = nullptr;
360: 		azVals = nullptr;
361: 	}
362: 
363: exec_out:
364: 	if (pStmt) {
365: 		sqlite3_finalize(pStmt);
366: 	}
367: 	sqlite3_free(azCols);
368: 	sqlite3_free(azVals);
369: 	if (rc != SQLITE_OK && pzErrMsg && !*pzErrMsg) {
370: 		// error but no error message set
371: 		*pzErrMsg = sqlite3_strdup("Unknown error in DuckDB!");
372: 	}
373: 	return rc;
374: }
375: 
376: /* Return the text of the SQL that was used to prepare the statement */
377: const char *sqlite3_sql(sqlite3_stmt *pStmt) {
378: 	return pStmt->query_string.c_str();
379: }
380: 
381: int sqlite3_column_count(sqlite3_stmt *pStmt) {
382: 	if (!pStmt || !pStmt->prepared) {
383: 		return 0;
384: 	}
385: 	return (int)pStmt->prepared->ColumnCount();
386: }
387: 
388: ////////////////////////////
389: //     sqlite3_column     //
390: ////////////////////////////
391: int sqlite3_column_type(sqlite3_stmt *pStmt, int iCol) {
392: 	if (!pStmt || !pStmt->result || !pStmt->current_chunk) {
393: 		return 0;
394: 	}
395: 	if (FlatVector::IsNull(pStmt->current_chunk->data[iCol], pStmt->current_row)) {
396: 		return SQLITE_NULL;
397: 	}
398: 	auto column_type = pStmt->result->types[iCol];
399: 	switch (column_type.id()) {
400: 	case LogicalTypeId::BOOLEAN:
401: 	case LogicalTypeId::TINYINT:
402: 	case LogicalTypeId::SMALLINT:
403: 	case LogicalTypeId::INTEGER:
404: 	case LogicalTypeId::BIGINT: /* TODO: Maybe blob? */
405: 		return SQLITE_INTEGER;
406: 	case LogicalTypeId::FLOAT:
407: 	case LogicalTypeId::DOUBLE:
408: 	case LogicalTypeId::DECIMAL:
409: 		return SQLITE_FLOAT;
410: 	case LogicalTypeId::DATE:
411: 	case LogicalTypeId::TIME:
412: 	case LogicalTypeId::TIMESTAMP:
413: 	case LogicalTypeId::TIMESTAMP_SEC:
414: 	case LogicalTypeId::TIMESTAMP_MS:
415: 	case LogicalTypeId::TIMESTAMP_NS:
416: 	case LogicalTypeId::VARCHAR:
417: 	case LogicalTypeId::LIST:
418: 	case LogicalTypeId::STRUCT:
419: 	case LogicalTypeId::MAP:
420: 		return SQLITE_TEXT;
421: 	case LogicalTypeId::BLOB:
422: 		return SQLITE_BLOB;
423: 	default:
424: 		// TODO(wangfenjin): agg function don't have type?
425: 		return SQLITE_TEXT;
426: 	}
427: 	return 0;
428: }
429: 
430: const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N) {
431: 	if (!pStmt || !pStmt->prepared) {
432: 		return nullptr;
433: 	}
434: 	return pStmt->prepared->GetNames()[N].c_str();
435: }
436: 
437: static bool sqlite3_column_has_value(sqlite3_stmt *pStmt, int iCol, LogicalType target_type, Value &val) {
438: 	if (!pStmt || !pStmt->result || !pStmt->current_chunk) {
439: 		return false;
440: 	}
441: 	if (iCol < 0 || iCol >= (int)pStmt->result->types.size()) {
442: 		return false;
443: 	}
444: 	if (FlatVector::IsNull(pStmt->current_chunk->data[iCol], pStmt->current_row)) {
445: 		return false;
446: 	}
447: 	try {
448: 		val = pStmt->current_chunk->data[iCol].GetValue(pStmt->current_row).CastAs(target_type);
449: 	} catch (...) {
450: 		return false;
451: 	}
452: 	return true;
453: }
454: 
455: double sqlite3_column_double(sqlite3_stmt *stmt, int iCol) {
456: 	Value val;
457: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::DOUBLE, val)) {
458: 		return 0;
459: 	}
460: 	return DoubleValue::Get(val);
461: }
462: 
463: int sqlite3_column_int(sqlite3_stmt *stmt, int iCol) {
464: 	Value val;
465: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::INTEGER, val)) {
466: 		return 0;
467: 	}
468: 	return IntegerValue::Get(val);
469: }
470: 
471: sqlite3_int64 sqlite3_column_int64(sqlite3_stmt *stmt, int iCol) {
472: 	Value val;
473: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::BIGINT, val)) {
474: 		return 0;
475: 	}
476: 	return BigIntValue::Get(val);
477: }
478: 
479: const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int iCol) {
480: 	Value val;
481: 	if (!sqlite3_column_has_value(pStmt, iCol, LogicalType::VARCHAR, val)) {
482: 		return nullptr;
483: 	}
484: 	try {
485: 		if (!pStmt->current_text) {
486: 			pStmt->current_text =
487: 			    unique_ptr<sqlite3_string_buffer[]>(new sqlite3_string_buffer[pStmt->result->types.size()]);
488: 		}
489: 		auto &entry = pStmt->current_text[iCol];
490: 		if (!entry.data) {
491: 			// not initialized yet, convert the value and initialize it
492: 			auto &str_val = StringValue::Get(val);
493: 			entry.data = unique_ptr<char[]>(new char[str_val.size() + 1]);
494: 			memcpy(entry.data.get(), str_val.c_str(), str_val.size() + 1);
495: 			entry.data_len = str_val.length();
496: 		}
497: 		return (const unsigned char *)entry.data.get();
498: 	} catch (...) {
499: 		// memory error!
500: 		return nullptr;
501: 	}
502: }
503: 
504: const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int iCol) {
505: 	Value val;
506: 	if (!sqlite3_column_has_value(pStmt, iCol, LogicalType::BLOB, val)) {
507: 		return nullptr;
508: 	}
509: 	try {
510: 		if (!pStmt->current_text) {
511: 			pStmt->current_text =
512: 			    unique_ptr<sqlite3_string_buffer[]>(new sqlite3_string_buffer[pStmt->result->types.size()]);
513: 		}
514: 		auto &entry = pStmt->current_text[iCol];
515: 		if (!entry.data) {
516: 			// not initialized yet, convert the value and initialize it
517: 			auto &str_val = StringValue::Get(val);
518: 			entry.data = unique_ptr<char[]>(new char[str_val.size() + 1]);
519: 			memcpy(entry.data.get(), str_val.c_str(), str_val.size() + 1);
520: 			entry.data_len = str_val.length();
521: 		}
522: 		return (const unsigned char *)entry.data.get();
523: 	} catch (...) {
524: 		// memory error!
525: 		return nullptr;
526: 	}
527: }
528: 
529: ////////////////////////////
530: //      sqlite3_bind      //
531: ////////////////////////////
532: int sqlite3_bind_parameter_count(sqlite3_stmt *stmt) {
533: 	if (!stmt) {
534: 		return 0;
535: 	}
536: 	return stmt->prepared->n_param;
537: }
538: 
539: const char *sqlite3_bind_parameter_name(sqlite3_stmt *stmt, int idx) {
540: 	if (!stmt) {
541: 		return nullptr;
542: 	}
543: 	if (idx < 1 || idx > (int)stmt->prepared->n_param) {
544: 		return nullptr;
545: 	}
546: 	return stmt->bound_names[idx - 1].c_str();
547: }
548: 
549: int sqlite3_bind_parameter_index(sqlite3_stmt *stmt, const char *zName) {
550: 	if (!stmt || !zName) {
551: 		return 0;
552: 	}
553: 	for (idx_t i = 0; i < stmt->bound_names.size(); i++) {
554: 		if (stmt->bound_names[i] == string(zName)) {
555: 			return i + 1;
556: 		}
557: 	}
558: 	return 0;
559: }
560: 
561: int sqlite3_internal_bind_value(sqlite3_stmt *stmt, int idx, Value value) {
562: 	if (!stmt || !stmt->prepared || stmt->result) {
563: 		return SQLITE_MISUSE;
564: 	}
565: 	if (idx < 1 || idx > (int)stmt->prepared->n_param) {
566: 		return SQLITE_RANGE;
567: 	}
568: 	stmt->bound_values[idx - 1] = value;
569: 	return SQLITE_OK;
570: }
571: 
572: int sqlite3_bind_int(sqlite3_stmt *stmt, int idx, int val) {
573: 	return sqlite3_internal_bind_value(stmt, idx, Value::INTEGER(val));
574: }
575: 
576: int sqlite3_bind_int64(sqlite3_stmt *stmt, int idx, sqlite3_int64 val) {
577: 	return sqlite3_internal_bind_value(stmt, idx, Value::BIGINT(val));
578: }
579: 
580: int sqlite3_bind_double(sqlite3_stmt *stmt, int idx, double val) {
581: 	return sqlite3_internal_bind_value(stmt, idx, Value::DOUBLE(val));
582: }
583: 
584: int sqlite3_bind_null(sqlite3_stmt *stmt, int idx) {
585: 	return sqlite3_internal_bind_value(stmt, idx, Value());
586: }
587: 
588: SQLITE_API int sqlite3_bind_value(sqlite3_stmt *, int, const sqlite3_value *) {
589: 	fprintf(stderr, "sqlite3_bind_value: unsupported.\n");
590: 	return SQLITE_ERROR;
591: }
592: 
593: int sqlite3_bind_text(sqlite3_stmt *stmt, int idx, const char *val, int length, void (*free_func)(void *)) {
594: 	if (!val) {
595: 		return SQLITE_MISUSE;
596: 	}
597: 	string value;
598: 	if (length < 0) {
599: 		value = string(val);
600: 	} else {
601: 		value = string(val, length);
602: 	}
603: 	if (free_func && ((ptrdiff_t)free_func) != -1) {
604: 		free_func((void *)val);
605: 		val = nullptr;
606: 	}
607: 	try {
608: 		return sqlite3_internal_bind_value(stmt, idx, Value(value));
609: 	} catch (std::exception &ex) {
610: 		return SQLITE_ERROR;
611: 	}
612: }
613: 
614: int sqlite3_bind_blob(sqlite3_stmt *stmt, int idx, const void *val, int length, void (*free_func)(void *)) {
615: 	if (!val) {
616: 		return SQLITE_MISUSE;
617: 	}
618: 	Value blob;
619: 	if (length < 0) {
620: 		blob = Value::BLOB(string((const char *)val));
621: 	} else {
622: 		blob = Value::BLOB((const_data_ptr_t)val, length);
623: 	}
624: 	if (free_func && ((ptrdiff_t)free_func) != -1) {
625: 		free_func((void *)val);
626: 		val = nullptr;
627: 	}
628: 	try {
629: 		return sqlite3_internal_bind_value(stmt, idx, blob);
630: 	} catch (std::exception &ex) {
631: 		return SQLITE_ERROR;
632: 	}
633: }
634: 
635: SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *stmt, int idx, int length) {
636: 	fprintf(stderr, "sqlite3_bind_zeroblob: unsupported.\n");
637: 	return SQLITE_ERROR;
638: }
639: 
640: int sqlite3_clear_bindings(sqlite3_stmt *stmt) {
641: 	if (!stmt) {
642: 		return SQLITE_MISUSE;
643: 	}
644: 	return SQLITE_OK;
645: }
646: 
647: int sqlite3_initialize(void) {
648: 	return SQLITE_OK;
649: }
650: 
651: int sqlite3_finalize(sqlite3_stmt *pStmt) {
652: 	if (pStmt) {
653: 		if (pStmt->result && !pStmt->result->success) {
654: 			pStmt->db->last_error = string(pStmt->result->error);
655: 			delete pStmt;
656: 			return SQLITE_ERROR;
657: 		}
658: 
659: 		delete pStmt;
660: 	}
661: 	return SQLITE_OK;
662: }
663: 
664: /*
665: ** Some systems have stricmp().  Others have strcasecmp().  Because
666: ** there is no consistency, we will define our own.
667: **
668: ** IMPLEMENTATION-OF: R-30243-02494 The sqlite3_stricmp() and
669: ** sqlite3_strnicmp() APIs allow applications and extensions to compare
670: ** the contents of two buffers containing UTF-8 strings in a
671: ** case-independent fashion, using the same definition of "case
672: ** independence" that SQLite uses internally when comparing identifiers.
673: */
674: 
675: const unsigned char sqlite3UpperToLower[] = {
676:     0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,
677:     22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,
678:     44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  97,
679:     98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
680:     120, 121, 122, 91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
681:     110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
682:     132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,
683:     154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
684:     176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,
685:     198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
686:     220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
687:     242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255};
688: 
689: int sqlite3StrICmp(const char *zLeft, const char *zRight) {
690: 	unsigned char *a, *b;
691: 	int c;
692: 	a = (unsigned char *)zLeft;
693: 	b = (unsigned char *)zRight;
694: 	for (;;) {
695: 		c = (int)sqlite3UpperToLower[*a] - (int)sqlite3UpperToLower[*b];
696: 		if (c || *a == 0)
697: 			break;
698: 		a++;
699: 		b++;
700: 	}
701: 	return c;
702: }
703: 
704: SQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight) {
705: 	if (zLeft == 0) {
706: 		return zRight ? -1 : 0;
707: 	} else if (zRight == 0) {
708: 		return 1;
709: 	}
710: 	return sqlite3StrICmp(zLeft, zRight);
711: }
712: 
713: SQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N) {
714: 	unsigned char *a, *b;
715: 	if (zLeft == 0) {
716: 		return zRight ? -1 : 0;
717: 	} else if (zRight == 0) {
718: 		return 1;
719: 	}
720: 	a = (unsigned char *)zLeft;
721: 	b = (unsigned char *)zRight;
722: 	while (N-- > 0 && *a != 0 && sqlite3UpperToLower[*a] == sqlite3UpperToLower[*b]) {
723: 		a++;
724: 		b++;
725: 	}
726: 	return N < 0 ? 0 : sqlite3UpperToLower[*a] - sqlite3UpperToLower[*b];
727: }
728: 
729: char *sqlite3_strdup(const char *str) {
730: 	char *result = (char *)sqlite3_malloc64(strlen(str) + 1);
731: 	strcpy(result, str);
732: 	return result;
733: }
734: 
735: void *sqlite3_malloc64(sqlite3_uint64 n) {
736: 	return malloc(n);
737: }
738: 
739: void sqlite3_free(void *pVoid) {
740: 	free(pVoid);
741: }
742: 
743: void *sqlite3_malloc(int n) {
744: 	return sqlite3_malloc64(n);
745: }
746: 
747: void *sqlite3_realloc(void *ptr, int n) {
748: 	return sqlite3_realloc64(ptr, n);
749: }
750: 
751: void *sqlite3_realloc64(void *ptr, sqlite3_uint64 n) {
752: 	return realloc(ptr, n);
753: }
754: 
755: // TODO: stub
756: int sqlite3_config(int i, ...) {
757: 	return SQLITE_OK;
758: }
759: 
760: int sqlite3_errcode(sqlite3 *db) {
761: 	if (!db) {
762: 		return SQLITE_NOMEM;
763: 	}
764: 	// return db->last_error.empty() ? SQLITE_OK : SQLITE_ERROR;
765: 	return db->errCode; //! We should return the exact error code
766: }
767: 
768: int sqlite3_extended_errcode(sqlite3 *db) {
769: 	return sqlite3_errcode(db);
770: }
771: 
772: const char *sqlite3_errmsg(sqlite3 *db) {
773: 	if (!db) {
774: 		return "";
775: 	}
776: 	return db->last_error.c_str();
777: }
778: 
779: void sqlite3_interrupt(sqlite3 *db) {
780: 	if (db) {
781: 		db->con->Interrupt();
782: 	}
783: }
784: 
785: const char *sqlite3_libversion(void) {
786: 	return DuckDB::LibraryVersion();
787: }
788: 
789: const char *sqlite3_sourceid(void) {
790: 	return DuckDB::SourceID();
791: }
792: 
793: int sqlite3_reset(sqlite3_stmt *stmt) {
794: 	if (stmt) {
795: 		stmt->result = nullptr;
796: 		stmt->current_chunk = nullptr;
797: 	}
798: 	return SQLITE_OK;
799: }
800: 
801: // support functions for shell.c
802: // most are dummies, we don't need them really
803: 
804: int sqlite3_db_status(sqlite3 *, int op, int *pCur, int *pHiwtr, int resetFlg) {
805: 	fprintf(stderr, "sqlite3_db_status: unsupported.\n");
806: 	return -1;
807: }
808: 
809: int sqlite3_changes(sqlite3 *db) {
810: 	return db->last_changes;
811: }
812: 
813: int sqlite3_total_changes(sqlite3 *db) {
814: 	return db->total_changes;
815: }
816: 
817: SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3 *db) {
818: 	return SQLITE_ERROR;
819: }
820: 
821: // some code borrowed from sqlite
822: // its probably best to match its behavior
823: 
824: typedef uint8_t u8;
825: 
826: /*
827: ** Token types used by the sqlite3_complete() routine.  See the header
828: ** comments on that procedure for additional information.
829: */
830: #define tkSEMI  0
831: #define tkWS    1
832: #define tkOTHER 2
833: 
834: const unsigned char sqlite3CtypeMap[256] = {
835:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 00..07    ........ */
836:     0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, /* 08..0f    ........ */
837:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 10..17    ........ */
838:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 18..1f    ........ */
839:     0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80, /* 20..27     !"#$%&' */
840:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 28..2f    ()*+,-./ */
841:     0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, /* 30..37    01234567 */
842:     0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 38..3f    89:;<=>? */
843: 
844:     0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02, /* 40..47    @ABCDEFG */
845:     0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, /* 48..4f    HIJKLMNO */
846:     0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, /* 50..57    PQRSTUVW */
847:     0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40, /* 58..5f    XYZ[\]^_ */
848:     0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22, /* 60..67    `abcdefg */
849:     0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, /* 68..6f    hijklmno */
850:     0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, /* 70..77    pqrstuvw */
851:     0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, /* 78..7f    xyz{|}~. */
852: 
853:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 80..87    ........ */
854:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 88..8f    ........ */
855:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 90..97    ........ */
856:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 98..9f    ........ */
857:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* a0..a7    ........ */
858:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* a8..af    ........ */
859:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* b0..b7    ........ */
860:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* b8..bf    ........ */
861: 
862:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* c0..c7    ........ */
863:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* c8..cf    ........ */
864:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* d0..d7    ........ */
865:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* d8..df    ........ */
866:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* e0..e7    ........ */
867:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* e8..ef    ........ */
868:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* f0..f7    ........ */
869:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40  /* f8..ff    ........ */
870: };
871: 
872: // TODO this can probably be simplified
873: #define IdChar(C) ((sqlite3CtypeMap[(unsigned char)C] & 0x46) != 0)
874: 
875: int sqlite3_complete(const char *zSql) {
876: 	u8 state = 0; /* Current state, using numbers defined in header comment */
877: 	u8 token;     /* Value of the next token */
878: 
879: 	/* If triggers are not supported by this compile then the statement machine
880: 	 ** used to detect the end of a statement is much simpler
881: 	 */
882: 	static const u8 trans[3][3] = {
883: 	    /* Token:           */
884: 	    /* State:       **  SEMI  WS  OTHER */
885: 	    /* 0 INVALID: */ {
886: 	        1,
887: 	        0,
888: 	        2,
889: 	    },
890: 	    /* 1   START: */
891: 	    {
892: 	        1,
893: 	        1,
894: 	        2,
895: 	    },
896: 	    /* 2  NORMAL: */
897: 	    {
898: 	        1,
899: 	        2,
900: 	        2,
901: 	    },
902: 	};
903: 
904: 	while (*zSql) {
905: 		switch (*zSql) {
906: 		case ';': { /* A semicolon */
907: 			token = tkSEMI;
908: 			break;
909: 		}
910: 		case ' ':
911: 		case '\r':
912: 		case '\t':
913: 		case '\n':
914: 		case '\f': { /* White space is ignored */
915: 			token = tkWS;
916: 			break;
917: 		}
918: 		case '/': { /* C-style comments */
919: 			if (zSql[1] != '*') {
920: 				token = tkOTHER;
921: 				break;
922: 			}
923: 			zSql += 2;
924: 			while (zSql[0] && (zSql[0] != '*' || zSql[1] != '/')) {
925: 				zSql++;
926: 			}
927: 			if (zSql[0] == 0)
928: 				return 0;
929: 			zSql++;
930: 			token = tkWS;
931: 			break;
932: 		}
933: 		case '-': { /* SQL-style comments from "--" to end of line */
934: 			if (zSql[1] != '-') {
935: 				token = tkOTHER;
936: 				break;
937: 			}
938: 			while (*zSql && *zSql != '\n') {
939: 				zSql++;
940: 			}
941: 			if (*zSql == 0)
942: 				return state == 1;
943: 			token = tkWS;
944: 			break;
945: 		}
946: 		case '`': /* Grave-accent quoted symbols used by MySQL */
947: 		case '"': /* single- and double-quoted strings */
948: 		case '\'': {
949: 			int c = *zSql;
950: 			zSql++;
951: 			while (*zSql && *zSql != c) {
952: 				zSql++;
953: 			}
954: 			if (*zSql == 0)
955: 				return 0;
956: 			token = tkOTHER;
957: 			break;
958: 		}
959: 		default: {
960: 
961: 			if (IdChar((u8)*zSql)) {
962: 				/* Keywords and unquoted identifiers */
963: 				int nId;
964: 				for (nId = 1; IdChar(zSql[nId]); nId++) {
965: 				}
966: 				token = tkOTHER;
967: 
968: 				zSql += nId - 1;
969: 			} else {
970: 				/* Operators and special symbols */
971: 				token = tkOTHER;
972: 			}
973: 			break;
974: 		}
975: 		}
976: 		state = trans[state][token];
977: 		zSql++;
978: 	}
979: 	return state == 1;
980: }
981: 
982: // checks if input ends with ;
983: int sqlite3_complete_old(const char *sql) {
984: 	fprintf(stderr, "sqlite3_complete: unsupported. '%s'\n", sql);
985: 	return -1;
986: }
987: 
988: // length of varchar or blob value
989: int sqlite3_column_bytes(sqlite3_stmt *pStmt, int iCol) {
990: 	// fprintf(stderr, "sqlite3_column_bytes: unsupported.\n");
991: 	return pStmt->current_text[iCol].data_len;
992: 	// return -1;
993: }
994: 
995: sqlite3_value *sqlite3_column_value(sqlite3_stmt *, int iCol) {
996: 	fprintf(stderr, "sqlite3_column_value: unsupported.\n");
997: 	return nullptr;
998: }
999: 
1000: int sqlite3_db_config(sqlite3 *, int op, ...) {
1001: 	fprintf(stderr, "sqlite3_db_config: unsupported.\n");
1002: 	return -1;
1003: }
1004: 
1005: int sqlite3_get_autocommit(sqlite3 *db) {
1006: 	return db->con->context->transaction.IsAutoCommit();
1007: }
1008: 
1009: int sqlite3_limit(sqlite3 *, int id, int newVal) {
1010: 	fprintf(stderr, "sqlite3_limit: unsupported.\n");
1011: 	return -1;
1012: }
1013: 
1014: int sqlite3_stmt_readonly(sqlite3_stmt *pStmt) {
1015: 	fprintf(stderr, "sqlite3_stmt_readonly: unsupported.\n");
1016: 	return -1;
1017: }
1018: 
1019: // TODO pretty easy schema lookup
1020: int sqlite3_table_column_metadata(sqlite3 *db,             /* Connection handle */
1021:                                   const char *zDbName,     /* Database name or NULL */
1022:                                   const char *zTableName,  /* Table name */
1023:                                   const char *zColumnName, /* Column name */
1024:                                   char const **pzDataType, /* OUTPUT: Declared data type */
1025:                                   char const **pzCollSeq,  /* OUTPUT: Collation sequence name */
1026:                                   int *pNotNull,           /* OUTPUT: True if NOT NULL constraint exists */
1027:                                   int *pPrimaryKey,        /* OUTPUT: True if column part of PK */
1028:                                   int *pAutoinc            /* OUTPUT: True if column is auto-increment */
1029: ) {
1030: 	fprintf(stderr, "sqlite3_table_column_metadata: unsupported.\n");
1031: 	return -1;
1032: }
1033: 
1034: const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int iCol) {
1035: 	if (!pStmt || !pStmt->prepared) {
1036: 		return NULL;
1037: 	}
1038: 	auto column_type = pStmt->prepared->GetTypes()[iCol];
1039: 	switch (column_type.id()) {
1040: 	case LogicalTypeId::BOOLEAN:
1041: 		return "BOOLEAN";
1042: 	case LogicalTypeId::TINYINT:
1043: 		return "TINYINT";
1044: 	case LogicalTypeId::SMALLINT:
1045: 		return "SMALLINT";
1046: 	case LogicalTypeId::INTEGER:
1047: 		return "INTEGER";
1048: 	case LogicalTypeId::BIGINT:
1049: 		return "BIGINT";
1050: 	case LogicalTypeId::FLOAT:
1051: 		return "FLOAT";
1052: 	case LogicalTypeId::DOUBLE:
1053: 		return "DOUBLE";
1054: 	case LogicalTypeId::DECIMAL:
1055: 		return "DECIMAL";
1056: 	case LogicalTypeId::DATE:
1057: 		return "DATE";
1058: 	case LogicalTypeId::TIME:
1059: 		return "TIME";
1060: 	case LogicalTypeId::TIMESTAMP:
1061: 	case LogicalTypeId::TIMESTAMP_NS:
1062: 	case LogicalTypeId::TIMESTAMP_MS:
1063: 	case LogicalTypeId::TIMESTAMP_SEC:
1064: 		return "TIMESTAMP";
1065: 	case LogicalTypeId::VARCHAR:
1066: 		return "VARCHAR";
1067: 	case LogicalTypeId::LIST:
1068: 		return "LIST";
1069: 	case LogicalTypeId::MAP:
1070: 		return "MAP";
1071: 	case LogicalTypeId::STRUCT:
1072: 		return "STRUCT";
1073: 	case LogicalTypeId::BLOB:
1074: 		return "BLOB";
1075: 	default:
1076: 		return NULL;
1077: 	}
1078: 	return NULL;
1079: }
1080: 
1081: int sqlite3_status64(int op, sqlite3_int64 *pCurrent, sqlite3_int64 *pHighwater, int resetFlag) {
1082: 	fprintf(stderr, "sqlite3_status64: unsupported.\n");
1083: 	return -1;
1084: }
1085: 
1086: int sqlite3_status64(sqlite3 *, int op, int *pCur, int *pHiwtr, int resetFlg) {
1087: 	fprintf(stderr, "sqlite3_status64: unsupported.\n");
1088: 	return -1;
1089: }
1090: 
1091: int sqlite3_stmt_status(sqlite3_stmt *, int op, int resetFlg) {
1092: 	fprintf(stderr, "sqlite3_stmt_status: unsupported.\n");
1093: 	return -1;
1094: }
1095: 
1096: int sqlite3_file_control(sqlite3 *, const char *zDbName, int op, void *) {
1097: 	fprintf(stderr, "sqlite3_file_control: unsupported.\n");
1098: 	return -1;
1099: }
1100: 
1101: int sqlite3_declare_vtab(sqlite3 *, const char *zSQL) {
1102: 	fprintf(stderr, "sqlite3_declare_vtab: unsupported.\n");
1103: 	return -1;
1104: }
1105: 
1106: const char *sqlite3_vtab_collation(sqlite3_index_info *, int) {
1107: 	fprintf(stderr, "sqlite3_vtab_collation: unsupported.\n");
1108: 	return nullptr;
1109: }
1110: 
1111: int sqlite3_sleep(int) {
1112: 	fprintf(stderr, "sqlite3_sleep: unsupported.\n");
1113: 	return -1;
1114: }
1115: 
1116: int sqlite3_busy_timeout(sqlite3 *, int ms) {
1117: 	fprintf(stderr, "sqlite3_busy_timeout: unsupported.\n");
1118: 	return -1;
1119: }
1120: 
1121: // unlikely to be supported
1122: 
1123: int sqlite3_trace_v2(sqlite3 *, unsigned uMask, int (*xCallback)(unsigned, void *, void *, void *), void *pCtx) {
1124: 	fprintf(stderr, "sqlite3_trace_v2: unsupported.\n");
1125: 	return -1;
1126: }
1127: 
1128: int sqlite3_test_control(int op, ...) {
1129: 	fprintf(stderr, "sqlite3_test_control: unsupported.\n");
1130: 	return -1;
1131: }
1132: 
1133: int sqlite3_enable_load_extension(sqlite3 *db, int onoff) {
1134: 	// fprintf(stderr, "sqlite3_enable_load_extension: unsupported.\n");
1135: 	return -1;
1136: }
1137: 
1138: int sqlite3_load_extension(sqlite3 *db,       /* Load the extension into this database connection */
1139:                            const char *zFile, /* Name of the shared library containing extension */
1140:                            const char *zProc, /* Entry point.  Derived from zFile if 0 */
1141:                            char **pzErrMsg    /* Put error message here if not 0 */
1142: ) {
1143: 	// fprintf(stderr, "sqlite3_load_extension: unsupported.\n");
1144: 	return -1;
1145: }
1146: 
1147: int sqlite3_create_module(sqlite3 *db,             /* SQLite connection to register module with */
1148:                           const char *zName,       /* Name of the module */
1149:                           const sqlite3_module *p, /* Methods for the module */
1150:                           void *pClientData        /* Client data for xCreate/xConnect */
1151: ) {
1152: 	// fprintf(stderr, "sqlite3_create_module: unsupported.\n");
1153: 	return -1;
1154: }
1155: 
1156: int sqlite3_create_function(sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep, void *pApp,
1157:                             void (*xFunc)(sqlite3_context *, int, sqlite3_value **),
1158:                             void (*xStep)(sqlite3_context *, int, sqlite3_value **),
1159:                             void (*xFinal)(sqlite3_context *)) {
1160: 	if ((!xFunc && !xStep && !xFinal) || !zFunctionName || nArg < -1) {
1161: 		return SQLITE_MISUSE;
1162: 	}
1163: 	string fname = string(zFunctionName);
1164: 
1165: 	// Scalar function
1166: 	if (!xFunc) {
1167: 		return SQLITE_MISUSE;
1168: 	}
1169: 	auto udf_sqlite3 = SQLiteUDFWrapper::CreateSQLiteScalarFunction(xFunc, db, pApp);
1170: 	LogicalType varargs = LogicalType::INVALID;
1171: 	if (nArg == -1) {
1172: 		varargs = LogicalType::ANY;
1173: 		nArg = 0;
1174: 	}
1175: 
1176: 	vector<LogicalType> argv_types(nArg);
1177: 	for (idx_t i = 0; i < (idx_t)nArg; ++i) {
1178: 		argv_types[i] = LogicalType::ANY;
1179: 	}
1180: 
1181: 	UDFWrapper::RegisterFunction(fname, argv_types, LogicalType::VARCHAR, udf_sqlite3, *(db->con->context), varargs);
1182: 	return SQLITE_OK;
1183: }
1184: 
1185: int sqlite3_create_function_v2(sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep, void *pApp,
1186:                                void (*xFunc)(sqlite3_context *, int, sqlite3_value **),
1187:                                void (*xStep)(sqlite3_context *, int, sqlite3_value **),
1188:                                void (*xFinal)(sqlite3_context *), void (*xDestroy)(void *)) {
1189: 	return -1;
1190: }
1191: 
1192: int sqlite3_set_authorizer(sqlite3 *, int (*xAuth)(void *, int, const char *, const char *, const char *, const char *),
1193:                            void *pUserData) {
1194: 	fprintf(stderr, "sqlite3_set_authorizer: unsupported.\n");
1195: 	return -1;
1196: }
1197: 
1198: // needed in shell timer
1199: static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow) {
1200: 	using namespace std::chrono;
1201: 	*piNow = (sqlite3_int64)duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
1202: 	return SQLITE_OK;
1203: }
1204: 
1205: static sqlite3_vfs static_sqlite3_virtual_file_systems[] = {{
1206:     3,                    // int iVersion;            /* Structure version number (currently 3) */
1207:     0,                    // int szOsFile;            /* Size of subclassed sqlite3_file */
1208:     0,                    // int mxPathname;          /* Maximum file pathname length */
1209:     nullptr,              // sqlite3_vfs *pNext;      /* Next registered VFS */
1210:     "dummy",              // const char *zName;       /* Name of this virtual file system */
1211:     nullptr,              // void *pAppData;          /* Pointer to application-specific data */
1212:     nullptr,              // int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*, int flags, int *pOutFlags);
1213:     nullptr,              // int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);
1214:     nullptr,              // int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);
1215:     nullptr,              // int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);
1216:     nullptr,              // void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);
1217:     nullptr,              // void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);
1218:     nullptr,              // void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);
1219:     nullptr,              // void (*xDlClose)(sqlite3_vfs*, void*);
1220:     nullptr,              // int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);
1221:     nullptr,              // int (*xSleep)(sqlite3_vfs*, int microseconds);
1222:     nullptr,              // int (*xCurrentTime)(sqlite3_vfs*, double*);
1223:     nullptr,              // int (*xGetLastError)(sqlite3_vfs*, int, char *);
1224:     unixCurrentTimeInt64, // int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);
1225:     nullptr,              // int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);
1226:     nullptr,              // sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);
1227:     nullptr               // const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);
1228: }};
1229: 
1230: // virtual file system, providing some dummies to avoid crashes
1231: sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName) {
1232: 	// return a dummy because the shell does not check the return code.
1233: 	return static_sqlite3_virtual_file_systems;
1234: }
1235: 
1236: int sqlite3_vfs_register(sqlite3_vfs *, int makeDflt) {
1237: 	// fprintf(stderr, "sqlite3_vfs_register: unsupported.\n");
1238: 	return -1;
1239: }
1240: 
1241: // backups, unused
1242: 
1243: int sqlite3_backup_step(sqlite3_backup *p, int nPage) {
1244: 	fprintf(stderr, "sqlite3_backup_step: unsupported.\n");
1245: 	return -1;
1246: }
1247: 
1248: int sqlite3_backup_finish(sqlite3_backup *p) {
1249: 	fprintf(stderr, "sqlite3_backup_finish: unsupported.\n");
1250: 	return -1;
1251: }
1252: 
1253: sqlite3_backup *sqlite3_backup_init(sqlite3 *pDest,         /* Destination database handle */
1254:                                     const char *zDestName,  /* Destination database name */
1255:                                     sqlite3 *pSource,       /* Source database handle */
1256:                                     const char *zSourceName /* Source database name */
1257: ) {
1258: 	fprintf(stderr, "sqlite3_backup_init: unsupported.\n");
1259: 	return nullptr;
1260: }
1261: 
1262: // UDF support stuff, unused for now. These cannot be called as create_function above is disabled
1263: 
1264: SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context *) {
1265: 	return nullptr;
1266: }
1267: 
1268: void *sqlite3_user_data(sqlite3_context *context) {
1269: 	assert(context);
1270: 	return context->pFunc.pUserData;
1271: }
1272: 
1273: #ifdef _WIN32
1274: #include <windows.h>
1275: 
1276: static void *sqlite3MallocZero(size_t n) {
1277: 	auto res = sqlite3_malloc(n);
1278: 	assert(res);
1279: 	memset(res, 0, n);
1280: 	return res;
1281: }
1282: 
1283: static LPWSTR winUtf8ToUnicode(const char *zText) {
1284: 	int nChar;
1285: 	LPWSTR zWideText;
1286: 
1287: 	nChar = MultiByteToWideChar(CP_UTF8, 0, zText, -1, NULL, 0);
1288: 	if (nChar == 0) {
1289: 		return 0;
1290: 	}
1291: 	zWideText = (LPWSTR)sqlite3MallocZero(nChar * sizeof(WCHAR));
1292: 	if (zWideText == 0) {
1293: 		return 0;
1294: 	}
1295: 	nChar = MultiByteToWideChar(CP_UTF8, 0, zText, -1, zWideText, nChar);
1296: 	if (nChar == 0) {
1297: 		sqlite3_free(zWideText);
1298: 		zWideText = 0;
1299: 	}
1300: 	return zWideText;
1301: }
1302: 
1303: static char *winUnicodeToMbcs(LPCWSTR zWideText, int useAnsi) {
1304: 	int nByte;
1305: 	char *zText;
1306: 	int codepage = useAnsi ? CP_ACP : CP_OEMCP;
1307: 
1308: 	nByte = WideCharToMultiByte(codepage, 0, zWideText, -1, 0, 0, 0, 0);
1309: 	if (nByte == 0) {
1310: 		return 0;
1311: 	}
1312: 	zText = (char *)sqlite3MallocZero(nByte);
1313: 	if (zText == 0) {
1314: 		return 0;
1315: 	}
1316: 	nByte = WideCharToMultiByte(codepage, 0, zWideText, -1, zText, nByte, 0, 0);
1317: 	if (nByte == 0) {
1318: 		sqlite3_free(zText);
1319: 		zText = 0;
1320: 	}
1321: 	return zText;
1322: }
1323: 
1324: static char *winUtf8ToMbcs(const char *zText, int useAnsi) {
1325: 	char *zTextMbcs;
1326: 	LPWSTR zTmpWide;
1327: 
1328: 	zTmpWide = winUtf8ToUnicode(zText);
1329: 	if (zTmpWide == 0) {
1330: 		return 0;
1331: 	}
1332: 	zTextMbcs = winUnicodeToMbcs(zTmpWide, useAnsi);
1333: 	sqlite3_free(zTmpWide);
1334: 	return zTextMbcs;
1335: }
1336: 
1337: SQLITE_API char *sqlite3_win32_utf8_to_mbcs_v2(const char *zText, int useAnsi) {
1338: 	return winUtf8ToMbcs(zText, useAnsi);
1339: }
1340: 
1341: LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText) {
1342: 	return winUtf8ToUnicode(zText);
1343: }
1344: 
1345: static LPWSTR winMbcsToUnicode(const char *zText, int useAnsi) {
1346: 	int nByte;
1347: 	LPWSTR zMbcsText;
1348: 	int codepage = useAnsi ? CP_ACP : CP_OEMCP;
1349: 
1350: 	nByte = MultiByteToWideChar(codepage, 0, zText, -1, NULL, 0) * sizeof(WCHAR);
1351: 	if (nByte == 0) {
1352: 		return 0;
1353: 	}
1354: 	zMbcsText = (LPWSTR)sqlite3MallocZero(nByte * sizeof(WCHAR));
1355: 	if (zMbcsText == 0) {
1356: 		return 0;
1357: 	}
1358: 	nByte = MultiByteToWideChar(codepage, 0, zText, -1, zMbcsText, nByte);
1359: 	if (nByte == 0) {
1360: 		sqlite3_free(zMbcsText);
1361: 		zMbcsText = 0;
1362: 	}
1363: 	return zMbcsText;
1364: }
1365: 
1366: static char *winUnicodeToUtf8(LPCWSTR zWideText) {
1367: 	int nByte;
1368: 	char *zText;
1369: 
1370: 	nByte = WideCharToMultiByte(CP_UTF8, 0, zWideText, -1, 0, 0, 0, 0);
1371: 	if (nByte == 0) {
1372: 		return 0;
1373: 	}
1374: 	zText = (char *)sqlite3MallocZero(nByte);
1375: 	if (zText == 0) {
1376: 		return 0;
1377: 	}
1378: 	nByte = WideCharToMultiByte(CP_UTF8, 0, zWideText, -1, zText, nByte, 0, 0);
1379: 	if (nByte == 0) {
1380: 		sqlite3_free(zText);
1381: 		zText = 0;
1382: 	}
1383: 	return zText;
1384: }
1385: 
1386: static char *winMbcsToUtf8(const char *zText, int useAnsi) {
1387: 	char *zTextUtf8;
1388: 	LPWSTR zTmpWide;
1389: 
1390: 	zTmpWide = winMbcsToUnicode(zText, useAnsi);
1391: 	if (zTmpWide == 0) {
1392: 		return 0;
1393: 	}
1394: 	zTextUtf8 = winUnicodeToUtf8(zTmpWide);
1395: 	sqlite3_free(zTmpWide);
1396: 	return zTextUtf8;
1397: }
1398: 
1399: SQLITE_API char *sqlite3_win32_mbcs_to_utf8_v2(const char *zText, int useAnsi) {
1400: 	return winMbcsToUtf8(zText, useAnsi);
1401: }
1402: 
1403: SQLITE_API char *sqlite3_win32_unicode_to_utf8(LPCWSTR zWideText) {
1404: 	return winUnicodeToUtf8(zWideText);
1405: }
1406: 
1407: #endif
1408: 
1409: // TODO complain
1410: SQLITE_API void sqlite3_result_blob(sqlite3_context *context, const void *blob, int n_bytes, void (*)(void *)) {
1411: 	if (!blob) {
1412: 		context->isError = SQLITE_MISUSE;
1413: 		return;
1414: 	}
1415: 	context->result.type = SQLiteTypeValue::BLOB;
1416: 	context->result.n = n_bytes;
1417: 	string_t str = string_t((const char *)blob, n_bytes);
1418: 	context->result.str_t = str;
1419: }
1420: 
1421: SQLITE_API void sqlite3_result_blob64(sqlite3_context *, const void *, sqlite3_uint64, void (*)(void *)) {
1422: }
1423: 
1424: SQLITE_API void sqlite3_result_double(sqlite3_context *context, double val) {
1425: 	context->result.u.r = val;
1426: 	context->result.type = SQLiteTypeValue::FLOAT;
1427: }
1428: 
1429: SQLITE_API void sqlite3_result_error(sqlite3_context *context, const char *msg, int n_bytes) {
1430: 	context->isError = SQLITE_ERROR;
1431: 	sqlite3_result_text(context, msg, n_bytes, nullptr);
1432: }
1433: 
1434: SQLITE_API void sqlite3_result_error16(sqlite3_context *, const void *, int) {
1435: }
1436: 
1437: SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *) {
1438: }
1439: 
1440: SQLITE_API void sqlite3_result_error_nomem(sqlite3_context *) {
1441: }
1442: 
1443: SQLITE_API void sqlite3_result_error_code(sqlite3_context *, int) {
1444: }
1445: 
1446: SQLITE_API void sqlite3_result_int(sqlite3_context *context, int val) {
1447: 	sqlite3_result_int64(context, val);
1448: }
1449: 
1450: SQLITE_API void sqlite3_result_int64(sqlite3_context *context, sqlite3_int64 val) {
1451: 	context->result.u.i = val;
1452: 	context->result.type = SQLiteTypeValue::INTEGER;
1453: }
1454: 
1455: SQLITE_API void sqlite3_result_null(sqlite3_context *context) {
1456: 	context->result.type = SQLiteTypeValue::NULL_VALUE;
1457: }
1458: 
1459: SQLITE_API void sqlite3_result_text(sqlite3_context *context, const char *str_c, int n_chars, void (*)(void *)) {
1460: 	if (!str_c) {
1461: 		context->isError = SQLITE_MISUSE;
1462: 		return;
1463: 	}
1464: 
1465: 	auto utf_type = Utf8Proc::Analyze(str_c, n_chars);
1466: 	if (utf_type == UnicodeType::INVALID) {
1467: 		context->isError = SQLITE_MISUSE;
1468: 		return;
1469: 	}
1470: 	context->result.type = SQLiteTypeValue::TEXT;
1471: 	context->result.n = n_chars;
1472: 	context->result.str_t = string_t(str_c, n_chars);
1473: }
1474: 
1475: SQLITE_API void sqlite3_result_text64(sqlite3_context *, const char *, sqlite3_uint64, void (*)(void *),
1476:                                       unsigned char encoding) {
1477: }
1478: 
1479: SQLITE_API void sqlite3_result_text16(sqlite3_context *, const void *, int, void (*)(void *)) {
1480: }
1481: 
1482: SQLITE_API void sqlite3_result_text16le(sqlite3_context *, const void *, int, void (*)(void *)) {
1483: }
1484: 
1485: SQLITE_API void sqlite3_result_text16be(sqlite3_context *, const void *, int, void (*)(void *)) {
1486: }
1487: 
1488: SQLITE_API void sqlite3_result_value(sqlite3_context *, sqlite3_value *) {
1489: }
1490: 
1491: SQLITE_API void sqlite3_result_pointer(sqlite3_context *, void *, const char *, void (*)(void *)) {
1492: }
1493: 
1494: SQLITE_API void sqlite3_result_zeroblob(sqlite3_context *, int n) {
1495: }
1496: 
1497: SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context *, sqlite3_uint64 n) {
1498: 	return -1;
1499: }
1500: 
1501: // TODO complain
1502: const void *sqlite3_value_blob(sqlite3_value *pVal) {
1503: 	return sqlite3_value_text(pVal);
1504: }
1505: 
1506: double sqlite3_value_double(sqlite3_value *pVal) {
1507: 	if (!pVal) {
1508: 		pVal->db->errCode = SQLITE_MISUSE;
1509: 		return 0.0;
1510: 	}
1511: 	switch (pVal->type) {
1512: 	case SQLiteTypeValue::FLOAT:
1513: 		return pVal->u.r;
1514: 	case SQLiteTypeValue::INTEGER:
1515: 		return (double)pVal->u.i;
1516: 	case SQLiteTypeValue::TEXT:
1517: 	case SQLiteTypeValue::BLOB:
1518: 		double res;
1519: 		if (TryCast::Operation<string_t, double>(pVal->str_t, res)) {
1520: 			return res;
1521: 		}
1522: 		break;
1523: 	default:
1524: 		break;
1525: 	}
1526: 	pVal->db->errCode = SQLITE_MISMATCH;
1527: 	return 0.0;
1528: }
1529: 
1530: int sqlite3_value_int(sqlite3_value *pVal) {
1531: 	int64_t res = sqlite3_value_int64(pVal);
1532: 	if (res >= NumericLimits<int>::Minimum() && res <= NumericLimits<int>::Maximum()) {
1533: 		return res;
1534: 	}
1535: 	pVal->db->errCode = SQLITE_MISMATCH;
1536: 	return 0;
1537: }
1538: 
1539: sqlite3_int64 sqlite3_value_int64(sqlite3_value *pVal) {
1540: 	if (!pVal) {
1541: 		pVal->db->errCode = SQLITE_MISUSE;
1542: 		return 0;
1543: 	}
1544: 	int64_t res;
1545: 	switch (pVal->type) {
1546: 	case SQLiteTypeValue::INTEGER:
1547: 		return pVal->u.i;
1548: 	case SQLiteTypeValue::FLOAT:
1549: 		if (TryCast::Operation<double, int64_t>(pVal->u.r, res)) {
1550: 			return res;
1551: 		}
1552: 		break;
1553: 	case SQLiteTypeValue::TEXT:
1554: 	case SQLiteTypeValue::BLOB:
1555: 		if (TryCast::Operation<string_t, int64_t>(pVal->str_t, res)) {
1556: 			return res;
1557: 		}
1558: 		break;
1559: 	default:
1560: 		break;
1561: 	}
1562: 	pVal->db->errCode = SQLITE_MISMATCH;
1563: 	return 0;
1564: }
1565: 
1566: void *sqlite3_value_pointer(sqlite3_value *, const char *) {
1567: 	return nullptr;
1568: }
1569: 
1570: const unsigned char *sqlite3_value_text(sqlite3_value *pVal) {
1571: 	if (!pVal) {
1572: 		pVal->db->errCode = SQLITE_MISUSE;
1573: 		return nullptr;
1574: 	}
1575: 	// check if the string has already been allocated
1576: 	if (pVal->szMalloc > 0) {
1577: 		return (const unsigned char *)pVal->zMalloc;
1578: 	}
1579: 
1580: 	if (pVal->type == SQLiteTypeValue::TEXT || pVal->type == SQLiteTypeValue::BLOB) {
1581: 		auto length = pVal->str_t.GetSize();
1582: 		// new string including space for the null-terminated char ('\0')
1583: 		pVal->zMalloc = (char *)malloc(sizeof(char) * length + 1);
1584: 		if (!pVal->zMalloc) {
1585: 			pVal->db->errCode = SQLITE_NOMEM;
1586: 			return nullptr;
1587: 		}
1588: 		pVal->szMalloc = length + 1;
1589: 		memcpy(pVal->zMalloc, pVal->str_t.GetDataUnsafe(), length);
1590: 		pVal->zMalloc[length] = '\0';
1591: 		return (const unsigned char *)pVal->zMalloc;
1592: 	}
1593: 
1594: 	if (pVal->type == SQLiteTypeValue::INTEGER || pVal->type == SQLiteTypeValue::FLOAT) {
1595: 		Value value = (pVal->type == SQLiteTypeValue::INTEGER) ? Value::BIGINT(pVal->u.i) : Value::DOUBLE(pVal->u.r);
1596: 		if (!value.TryCastAs(LogicalType::VARCHAR)) {
1597: 			pVal->db->errCode = SQLITE_NOMEM;
1598: 			return nullptr;
1599: 		}
1600: 		auto &str_val = StringValue::Get(value);
1601: 		size_t str_len = str_val.size();
1602: 		pVal->zMalloc = (char *)malloc(sizeof(char) * (str_len + 1));
1603: 		if (!pVal->zMalloc) {
1604: 			pVal->db->errCode = SQLITE_NOMEM;
1605: 			return nullptr;
1606: 		}
1607: 		pVal->szMalloc = str_len + 1; // +1 null-terminated char
1608: 		memcpy(pVal->zMalloc, str_val.c_str(), pVal->szMalloc);
1609: 
1610: 		pVal->str_t = string_t(pVal->zMalloc, pVal->szMalloc - 1); // -1 null-terminated char
1611: 		pVal->n = pVal->str_t.GetSize();
1612: 		pVal->type = SQLiteTypeValue::TEXT;
1613: 		return (const unsigned char *)pVal->zMalloc;
1614: 	}
1615: 	if (pVal->type == SQLiteTypeValue::NULL_VALUE) {
1616: 		return nullptr;
1617: 	}
1618: 	pVal->db->errCode = SQLITE_MISMATCH;
1619: 	return nullptr;
1620: }
1621: 
1622: SQLITE_API const void *sqlite3_value_text16(sqlite3_value *) {
1623: 	return nullptr;
1624: }
1625: 
1626: SQLITE_API const void *sqlite3_value_text16le(sqlite3_value *) {
1627: 	return nullptr;
1628: }
1629: 
1630: SQLITE_API const void *sqlite3_value_text16be(sqlite3_value *) {
1631: 	return nullptr;
1632: }
1633: 
1634: SQLITE_API int sqlite3_value_bytes(sqlite3_value *pVal) {
1635: 	if (pVal->type == SQLiteTypeValue::TEXT || pVal->type == SQLiteTypeValue::BLOB) {
1636: 		return pVal->n;
1637: 	}
1638: 	return 0;
1639: }
1640: 
1641: SQLITE_API int sqlite3_value_bytes16(sqlite3_value *) {
1642: 	return 0;
1643: }
1644: 
1645: SQLITE_API int sqlite3_value_type(sqlite3_value *pVal) {
1646: 	return (int)pVal->type;
1647: }
1648: 
1649: SQLITE_API int sqlite3_value_numeric_type(sqlite3_value *) {
1650: 	return 0;
1651: }
1652: 
1653: SQLITE_API int sqlite3_value_nochange(sqlite3_value *) {
1654: 	return 0;
1655: }
1656: 
1657: SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *, int nBytes) {
1658: 	fprintf(stderr, "sqlite3_aggregate_context: unsupported.\n");
1659: 
1660: 	return nullptr;
1661: }
1662: 
1663: SQLITE_API int sqlite3_create_collation(sqlite3 *, const char *zName, int eTextRep, void *pArg,
1664:                                         int (*xCompare)(void *, int, const void *, int, const void *)) {
1665: 	return SQLITE_ERROR;
1666: }
1667: 
1668: SQLITE_API int sqlite3_create_window_function(sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep,
1669:                                               void *pApp, void (*xStep)(sqlite3_context *, int, sqlite3_value **),
1670:                                               void (*xFinal)(sqlite3_context *), void (*xValue)(sqlite3_context *),
1671:                                               void (*xInverse)(sqlite3_context *, int, sqlite3_value **),
1672:                                               void (*xDestroy)(void *)) {
1673: 	// commented for now because such error message prevents the shell-test.py to pass
1674: 	//	fprintf(stderr, "sqlite3_create_window_function: unsupported.\n");
1675: 	return SQLITE_ERROR;
1676: }
1677: 
1678: SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *s) {
1679: 	return s->db;
1680: }
1681: 
1682: SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt) {
1683: 	fprintf(stderr, "sqlite3_expanded_sql: unsupported.\n");
1684: 	return nullptr;
1685: }
1686: 
1687: SQLITE_API int sqlite3_keyword_check(const char *str, int len) {
1688: 	return Parser::IsKeyword(std::string(str, len));
1689: }
1690: 
1691: SQLITE_API int sqlite3_keyword_count(void) {
1692: 	fprintf(stderr, "sqlite3_keyword_count: unsupported.\n");
1693: 	return 0;
1694: }
1695: 
1696: SQLITE_API int sqlite3_keyword_name(int, const char **, int *) {
1697: 	fprintf(stderr, "sqlite3_keyword_name: unsupported.\n");
1698: 	return 0;
1699: }
1700: 
1701: SQLITE_API void sqlite3_progress_handler(sqlite3 *, int, int (*)(void *), void *) {
1702: 	fprintf(stderr, "sqlite3_progress_handler: unsupported.\n");
1703: }
1704: 
1705: SQLITE_API int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt) {
1706: 	if (!pStmt || !pStmt->prepared) {
1707: 		return 0;
1708: 	}
1709: 	return pStmt->prepared->GetStatementType() == StatementType::EXPLAIN_STATEMENT;
1710: }
1711: 
1712: SQLITE_API int sqlite3_vtab_config(sqlite3 *, int op, ...) {
1713: 	fprintf(stderr, "sqlite3_vtab_config: unsupported.\n");
1714: 	return SQLITE_ERROR;
1715: }
1716: 
1717: SQLITE_API int sqlite3_busy_handler(sqlite3 *, int (*)(void *, int), void *) {
1718: 	return SQLITE_ERROR;
1719: }
1720: 
1721: SQLITE_API int sqlite3_get_table(sqlite3 *db,       /* An open database */
1722:                                  const char *zSql,  /* SQL to be evaluated */
1723:                                  char ***pazResult, /* Results of the query */
1724:                                  int *pnRow,        /* Number of result rows written here */
1725:                                  int *pnColumn,     /* Number of result columns written here */
1726:                                  char **pzErrmsg    /* Error msg written here */
1727: ) {
1728: 	fprintf(stderr, "sqlite3_get_table: unsupported.\n");
1729: 	return SQLITE_ERROR;
1730: }
1731: 
1732: SQLITE_API void sqlite3_free_table(char **result) {
1733: 	fprintf(stderr, "sqlite3_free_table: unsupported.\n");
1734: }
1735: 
1736: SQLITE_API int sqlite3_prepare(sqlite3 *db,           /* Database handle */
1737:                                const char *zSql,      /* SQL statement, UTF-8 encoded */
1738:                                int nByte,             /* Maximum length of zSql in bytes. */
1739:                                sqlite3_stmt **ppStmt, /* OUT: Statement handle */
1740:                                const char **pzTail    /* OUT: Pointer to unused portion of zSql */
1741: ) {
1742: 	return sqlite3_prepare_v2(db, zSql, nByte, ppStmt, pzTail);
1743: }
1744: 
1745: SQLITE_API void *sqlite3_trace(sqlite3 *, void (*xTrace)(void *, const char *), void *) {
1746: 	fprintf(stderr, "sqlite3_trace: unsupported.\n");
1747: 	return nullptr;
1748: }
1749: 
1750: SQLITE_API void *sqlite3_profile(sqlite3 *, void (*xProfile)(void *, const char *, sqlite3_uint64), void *) {
1751: 	fprintf(stderr, "sqlite3_profile: unsupported.\n");
1752: 	return nullptr;
1753: }
1754: 
1755: SQLITE_API int sqlite3_libversion_number(void) {
1756: 	return SQLITE_VERSION_NUMBER;
1757: }
1758: 
1759: SQLITE_API int sqlite3_threadsafe(void) {
1760: 	return SQLITE_OK;
1761: }
1762: 
1763: SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int) {
1764: 	fprintf(stderr, "sqlite3_mutex_alloc: unsupported.\n");
1765: 	return nullptr;
1766: }
1767: 
1768: SQLITE_API void sqlite3_mutex_free(sqlite3_mutex *) {
1769: 	fprintf(stderr, "sqlite3_mutex_free: unsupported.\n");
1770: }
1771: 
1772: SQLITE_API int sqlite3_extended_result_codes(sqlite3 *db, int onoff) {
1773: 	fprintf(stderr, "sqlite3_extended_result_codes: unsupported.\n");
1774: 	return SQLITE_ERROR;
1775: }
1776: 
1777: SQLITE_API void *sqlite3_update_hook(sqlite3 *db, /* Attach the hook to this database */
1778:                                      void (*xCallback)(void *, int, char const *, char const *, sqlite_int64),
1779:                                      void *pArg /* Argument to the function */
1780: ) {
1781: 	fprintf(stderr, "sqlite3_update_hook: unsupported.\n");
1782: 	return nullptr;
1783: }
1784: 
1785: SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...) {
1786: 	fprintf(stderr, "sqlite3_log: unsupported.\n");
1787: }
1788: 
1789: SQLITE_API int sqlite3_unlock_notify(sqlite3 *db, void (*xNotify)(void **, int), void *pArg) {
1790: 	fprintf(stderr, "sqlite3_unlock_notify: unsupported.\n");
1791: 	return SQLITE_ERROR;
1792: }
1793: 
1794: SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg) {
1795: 	fprintf(stderr, "sqlite3_get_auxdata: unsupported.\n");
1796: 	return nullptr;
1797: }
1798: 
1799: SQLITE_API void *sqlite3_rollback_hook(sqlite3 *db,               /* Attach the hook to this database */
1800:                                        void (*xCallback)(void *), /* Callback function */
1801:                                        void *pArg                 /* Argument to the function */
1802: ) {
1803: 	fprintf(stderr, "sqlite3_rollback_hook: unsupported.\n");
1804: 	return nullptr;
1805: }
1806: 
1807: SQLITE_API void *sqlite3_commit_hook(sqlite3 *db,              /* Attach the hook to this database */
1808:                                      int (*xCallback)(void *), /* Function to invoke on each commit */
1809:                                      void *pArg                /* Argument to the function */
1810: ) {
1811: 	fprintf(stderr, "sqlite3_commit_hook: unsupported.\n");
1812: 	return nullptr;
1813: }
1814: 
1815: SQLITE_API int sqlite3_blob_open(sqlite3 *db,          /* The database connection */
1816:                                  const char *zDb,      /* The attached database containing the blob */
1817:                                  const char *zTable,   /* The table containing the blob */
1818:                                  const char *zColumn,  /* The column containing the blob */
1819:                                  sqlite_int64 iRow,    /* The row containing the glob */
1820:                                  int wrFlag,           /* True -> read/write access, false -> read-only */
1821:                                  sqlite3_blob **ppBlob /* Handle for accessing the blob returned here */
1822: ) {
1823: 	fprintf(stderr, "sqlite3_blob_open: unsupported.\n");
1824: 	return SQLITE_ERROR;
1825: }
1826: 
1827: SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName) {
1828: 	fprintf(stderr, "sqlite3_db_filename: unsupported.\n");
1829: 	return nullptr;
1830: }
1831: 
1832: SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt *) {
1833: 	fprintf(stderr, "sqlite3_stmt_busy: unsupported.\n");
1834: 	return false;
1835: }
1836: 
1837: SQLITE_API int sqlite3_bind_pointer(sqlite3_stmt *pStmt, int i, void *pPtr, const char *zPTtype,
1838:                                     void (*xDestructor)(void *)) {
1839: 	fprintf(stderr, "sqlite3_bind_pointer: unsupported.\n");
1840: 	return SQLITE_ERROR;
1841: }
1842: 
1843: SQLITE_API int sqlite3_create_module_v2(sqlite3 *db,                   /* Database in which module is registered */
1844:                                         const char *zName,             /* Name assigned to this module */
1845:                                         const sqlite3_module *pModule, /* The definition of the module */
1846:                                         void *pAux,                    /* Context pointer for xCreate/xConnect */
1847:                                         void (*xDestroy)(void *)       /* Module destructor function */
1848: ) {
1849: 	fprintf(stderr, "sqlite3_create_module_v2: unsupported.\n");
1850: 	return SQLITE_ERROR;
1851: }
1852: 
1853: SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset) {
1854: 	fprintf(stderr, "sqlite3_blob_write: unsupported.\n");
1855: 	return SQLITE_ERROR;
1856: }
1857: 
1858: SQLITE_API void sqlite3_set_auxdata(sqlite3_context *, int N, void *, void (*)(void *)) {
1859: 	fprintf(stderr, "sqlite3_set_auxdata: unsupported.\n");
1860: }
1861: 
1862: SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt) {
1863: 	fprintf(stderr, "sqlite3_next_stmt: unsupported.\n");
1864: 	return nullptr;
1865: }
1866: 
1867: SQLITE_API int sqlite3_collation_needed(sqlite3 *, void *, void (*)(void *, sqlite3 *, int eTextRep, const char *)) {
1868: 	fprintf(stderr, "sqlite3_collation_needed: unsupported.\n");
1869: 	return SQLITE_ERROR;
1870: }
1871: 
1872: SQLITE_API int sqlite3_create_collation_v2(sqlite3 *, const char *zName, int eTextRep, void *pArg,
1873:                                            int (*xCompare)(void *, int, const void *, int, const void *),
1874:                                            void (*xDestroy)(void *)) {
1875: 	fprintf(stderr, "sqlite3_create_collation_v2: unsupported.\n");
1876: 	return SQLITE_ERROR;
1877: }
[end of tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: