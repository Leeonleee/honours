{
  "repo": "duckdb/duckdb",
  "pull_number": 12224,
  "instance_id": "duckdb__duckdb-12224",
  "issue_numbers": [
    "12114"
  ],
  "base_commit": "1678c7fd74318bce263b093acc5443ce89cc14b4",
  "patch": "diff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex b64d4abf40e2..941d4d440244 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -1436,9 +1436,7 @@ case_insensitive_map_t<Value> TransformPyConfigDict(const py::dict &py_config_di\n void CreateNewInstance(DuckDBPyConnection &res, const string &database, DBConfig &config) {\n \t// We don't cache unnamed memory instances (i.e., :memory:)\n \tbool cache_instance = database != \":memory:\" && !database.empty();\n-\tif (config.options.enable_external_access) {\n-\t\tconfig.replacement_scans.emplace_back(PythonReplacementScan::Replace);\n-\t}\n+\tconfig.replacement_scans.emplace_back(PythonReplacementScan::Replace);\n \tres.database = instance_cache.CreateInstance(database, config, cache_instance);\n \tres.connection = make_uniq<Connection>(*res.database);\n \tauto &context = *res.connection->context;\ndiff --git a/tools/pythonpkg/src/python_replacement_scan.cpp b/tools/pythonpkg/src/python_replacement_scan.cpp\nindex a5a61fe81995..8c0d136afb89 100644\n--- a/tools/pythonpkg/src/python_replacement_scan.cpp\n+++ b/tools/pythonpkg/src/python_replacement_scan.cpp\n@@ -182,6 +182,11 @@ unique_ptr<TableRef> PythonReplacementScan::Replace(ClientContext &context, Repl\n                                                     optional_ptr<ReplacementScanData> data) {\n \tauto &table_name = input.table_name;\n \n+\tauto &config = DBConfig::GetConfig(context);\n+\tif (!config.options.enable_external_access) {\n+\t\treturn nullptr;\n+\t}\n+\n \tauto &table_ref = input.ref;\n \tif (table_ref.external_dependency) {\n \t\tauto dependency_item = table_ref.external_dependency->GetDependency(\"replacement_cache\");\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_replacement_scan.py b/tools/pythonpkg/tests/fast/test_replacement_scan.py\nindex 89430bc09ee7..6796ac10855c 100644\n--- a/tools/pythonpkg/tests/fast/test_replacement_scan.py\n+++ b/tools/pythonpkg/tests/fast/test_replacement_scan.py\n@@ -125,6 +125,38 @@ def test_replacement_scan_fail(self):\n         ):\n             con.execute(\"select count(*) from random_object\").fetchone()\n \n+    def test_replacement_disabled(self):\n+        df = pd.DataFrame({'a': [1, 2, 3]})\n+        # Create regular connection, not disabled\n+        con = duckdb.connect()\n+        res = con.sql(\"select * from df\").fetchall()\n+        assert res == [(1,), (2,), (3,)]\n+\n+        ## disable external access\n+        con.execute(\"set enable_external_access=false\")\n+        with pytest.raises(duckdb.CatalogException, match='Table with name df does not exist!'):\n+            res = con.sql(\"select * from df\").fetchall()\n+        with pytest.raises(\n+            duckdb.InvalidInputException, match='Cannot change enable_external_access setting while database is running'\n+        ):\n+            con.execute(\"set enable_external_access=true\")\n+\n+        # Create connection with external access disabled\n+        con = duckdb.connect(config={'enable_external_access': False})\n+        with pytest.raises(duckdb.CatalogException, match='Table with name df does not exist!'):\n+            res = con.sql(\"select * from df\").fetchall()\n+\n+        # Create regular connection, disable inbetween creation and execution\n+        con = duckdb.connect()\n+        rel = con.sql(\"select * from df\")\n+\n+        con.execute(\"set enable_external_access=false\")\n+\n+        with pytest.raises(\n+            duckdb.InvalidInputException, match='Attempting to execute an unsuccessful or closed pending query result'\n+        ):\n+            res = rel.fetchall()\n+\n     def test_replacement_of_cross_connection_relation(self):\n         con1 = duckdb.connect(':memory:')\n         con2 = duckdb.connect(':memory:')\n",
  "problem_statement": "Disabling enable_external_access does not disable replacement scans\n### What happens?\r\n\r\nWhen the `enable_external_access` configuration setting is set to false, pandas and numpy replacement scans are not disabled. This contradicts the documentation, which states that it must be set to true to\r\n\r\n> Allow the database to access external state (through e.g., loading/installing modules, COPY TO/FROM, CSV readers, pandas replacement scans, etc)\r\n\r\n### To Reproduce\r\n\r\nCode:\r\n```\r\nimport duckdb\r\nprint(f\"duckdb version = {duckdb.__version__}\")\r\nimport numpy as np\r\nimport pandas as pd\r\nsecrets = np.array([1,2,3])\r\nsecrets_df = pd.DataFrame(secrets)\r\nduckdb.execute(\"SET enable_external_access = false\")\r\nduckdb.sql(\"SELECT name, value FROM duckdb_settings() WHERE name='enable_external_access'\").show()\r\nprint(\"looking for numpy array\")\r\ndf1 = duckdb.sql(\"SELECT * FROM secrets\").to_df()\r\nprint(df1)\r\nprint(\"looking for pandas df\")\r\ndf2 = duckdb.sql(\"SELECT * FROM secrets_df\").to_df()\r\nprint(df2)\r\n```\r\n\r\nOutput:\r\n```\r\n$ python3 --version\r\nPython 3.11.9\r\n$ python3 duckdb_repro.py \r\nduckdb version = 0.10.2\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502          name          \u2502  value  \u2502\r\n\u2502        varchar         \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 enable_external_access \u2502 false   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nlooking for numpy array\r\n   column0\r\n0        1\r\n1        2\r\n2        3\r\nlooking for pandas df\r\n   0\r\n0  1\r\n1  2\r\n2  3\r\n```\r\n\r\n### OS:\r\n\r\nRocky Linux 8.0, x64\r\n\r\n### DuckDB Version:\r\n\r\n0.10.2\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nJack Wimberley\r\n\r\n### Affiliation:\r\n\r\nParadigm4\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "That does sound like a bug\r\n\r\nIf others agree, it should likely be fixed here: `Binder::BindWithReplacementScan` as that is where all replacement scans take place\nCurrently `enable_external_access` must be set on `connect` for replacement scans to be disabled, e.g.:\r\n\r\n```py\r\nimport duckdb\r\nimport numpy as np\r\nimport pandas as pd\r\ncon = duckdb.connect(':memory:', config={'enable_external_access': False})\r\nsecrets = np.array([1,2,3])\r\nsecrets_df = pd.DataFrame(secrets)\r\ncon.sql('SELECT * FROM secrets_df')\r\n# duckdb.duckdb.CatalogException: Catalog Error: Table with name secrets_df does not exist!\r\n```\r\n\r\nIt should work using `SET` as well. We'll look into it.",
  "created_at": "2024-05-24T10:54:04Z",
  "modified_files": [
    "tools/pythonpkg/src/pyconnection.cpp",
    "tools/pythonpkg/src/python_replacement_scan.cpp"
  ]
}