You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
When using read_json to read data, it always converts the md5 string to uuid format.
### What happens?

Any 32-character string that conforms to the UUID specification will be converted to a UUID.


### To Reproduce

For the following json file, `iss16684.json`:

```json
{"md5":"00000000000000000000000000000000"}
```

Execute:

```
FROM 'iss16684.json';
```

Actual

```text
┌──────────────────────────────────────┐
│                 md5                  │
│                 uuid                 │
├──────────────────────────────────────┤
│ 00000000-0000-0000-0000-000000000000 │
└──────────────────────────────────────┘

```
---
Expected

```text
┌───────────────────────────────────┐
│                md5                │
│              varchar              │
├───────────────────────────────────┤
│ 00000000000000000000000000000000  │
└───────────────────────────────────┘

```

### OS:

Windows

### DuckDB Version:

v1.2.1 8e52ec4395

### DuckDB Client:

cli

### Hardware:

_No response_

### Full Name:

Jim Zhang

### Affiliation:

Winhc Co.

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [x] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/stable/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/stable/clients/cli/overview) and has clients for [Python](https://duckdb.org/docs/stable/clients/python/overview), [R](https://duckdb.org/docs/stable/clients/r), [Java](https://duckdb.org/docs/stable/clients/java), [Wasm](https://duckdb.org/docs/stable/clients/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdb.org/docs/stable/clients/r#duckplyr-dplyr-api).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/stable/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/stable/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/stable/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/docs/stable/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/common/operator/cast_operators.cpp]
1: #include "duckdb/common/operator/cast_operators.hpp"
2: #include "duckdb/common/hugeint.hpp"
3: #include "duckdb/common/operator/string_cast.hpp"
4: #include "duckdb/common/operator/numeric_cast.hpp"
5: #include "duckdb/common/operator/decimal_cast_operators.hpp"
6: #include "duckdb/common/operator/multiply.hpp"
7: #include "duckdb/common/operator/add.hpp"
8: #include "duckdb/common/operator/subtract.hpp"
9: 
10: #include "duckdb/common/exception.hpp"
11: #include "duckdb/common/limits.hpp"
12: #include "duckdb/common/string_util.hpp"
13: #include "duckdb/common/types/blob.hpp"
14: #include "duckdb/common/types/cast_helpers.hpp"
15: #include "duckdb/common/types/date.hpp"
16: #include "duckdb/common/types/decimal.hpp"
17: #include "duckdb/common/types/hugeint.hpp"
18: #include "duckdb/common/types/uuid.hpp"
19: #include "duckdb/common/types/interval.hpp"
20: #include "duckdb/common/types/time.hpp"
21: #include "duckdb/common/types/timestamp.hpp"
22: #include "duckdb/common/types/vector.hpp"
23: #include "duckdb/common/types.hpp"
24: #include "fast_float/fast_float.h"
25: #include "fmt/format.h"
26: #include "duckdb/common/types/bit.hpp"
27: #include "duckdb/common/operator/integer_cast_operator.hpp"
28: #include "duckdb/common/operator/double_cast_operator.hpp"
29: 
30: #include <cctype>
31: #include <cmath>
32: #include <cstdlib>
33: 
34: namespace duckdb {
35: 
36: //===--------------------------------------------------------------------===//
37: // Cast bool -> Numeric
38: //===--------------------------------------------------------------------===//
39: template <>
40: bool TryCast::Operation(bool input, bool &result, bool strict) {
41: 	return NumericTryCast::Operation<bool, bool>(input, result, strict);
42: }
43: 
44: template <>
45: bool TryCast::Operation(bool input, int8_t &result, bool strict) {
46: 	return NumericTryCast::Operation<bool, int8_t>(input, result, strict);
47: }
48: 
49: template <>
50: bool TryCast::Operation(bool input, int16_t &result, bool strict) {
51: 	return NumericTryCast::Operation<bool, int16_t>(input, result, strict);
52: }
53: 
54: template <>
55: bool TryCast::Operation(bool input, int32_t &result, bool strict) {
56: 	return NumericTryCast::Operation<bool, int32_t>(input, result, strict);
57: }
58: 
59: template <>
60: bool TryCast::Operation(bool input, int64_t &result, bool strict) {
61: 	return NumericTryCast::Operation<bool, int64_t>(input, result, strict);
62: }
63: 
64: template <>
65: bool TryCast::Operation(bool input, hugeint_t &result, bool strict) {
66: 	return NumericTryCast::Operation<bool, hugeint_t>(input, result, strict);
67: }
68: 
69: template <>
70: bool TryCast::Operation(bool input, uhugeint_t &result, bool strict) {
71: 	return NumericTryCast::Operation<bool, uhugeint_t>(input, result, strict);
72: }
73: 
74: template <>
75: bool TryCast::Operation(bool input, uint8_t &result, bool strict) {
76: 	return NumericTryCast::Operation<bool, uint8_t>(input, result, strict);
77: }
78: 
79: template <>
80: bool TryCast::Operation(bool input, uint16_t &result, bool strict) {
81: 	return NumericTryCast::Operation<bool, uint16_t>(input, result, strict);
82: }
83: 
84: template <>
85: bool TryCast::Operation(bool input, uint32_t &result, bool strict) {
86: 	return NumericTryCast::Operation<bool, uint32_t>(input, result, strict);
87: }
88: 
89: template <>
90: bool TryCast::Operation(bool input, uint64_t &result, bool strict) {
91: 	return NumericTryCast::Operation<bool, uint64_t>(input, result, strict);
92: }
93: 
94: template <>
95: bool TryCast::Operation(bool input, float &result, bool strict) {
96: 	return NumericTryCast::Operation<bool, float>(input, result, strict);
97: }
98: 
99: template <>
100: bool TryCast::Operation(bool input, double &result, bool strict) {
101: 	return NumericTryCast::Operation<bool, double>(input, result, strict);
102: }
103: 
104: //===--------------------------------------------------------------------===//
105: // Cast int8_t -> Numeric
106: //===--------------------------------------------------------------------===//
107: template <>
108: bool TryCast::Operation(int8_t input, bool &result, bool strict) {
109: 	return NumericTryCast::Operation<int8_t, bool>(input, result, strict);
110: }
111: 
112: template <>
113: bool TryCast::Operation(int8_t input, int8_t &result, bool strict) {
114: 	return NumericTryCast::Operation<int8_t, int8_t>(input, result, strict);
115: }
116: 
117: template <>
118: bool TryCast::Operation(int8_t input, int16_t &result, bool strict) {
119: 	return NumericTryCast::Operation<int8_t, int16_t>(input, result, strict);
120: }
121: 
122: template <>
123: bool TryCast::Operation(int8_t input, int32_t &result, bool strict) {
124: 	return NumericTryCast::Operation<int8_t, int32_t>(input, result, strict);
125: }
126: 
127: template <>
128: bool TryCast::Operation(int8_t input, int64_t &result, bool strict) {
129: 	return NumericTryCast::Operation<int8_t, int64_t>(input, result, strict);
130: }
131: 
132: template <>
133: bool TryCast::Operation(int8_t input, hugeint_t &result, bool strict) {
134: 	return NumericTryCast::Operation<int8_t, hugeint_t>(input, result, strict);
135: }
136: 
137: template <>
138: bool TryCast::Operation(int8_t input, uhugeint_t &result, bool strict) {
139: 	return NumericTryCast::Operation<int8_t, uhugeint_t>(input, result, strict);
140: }
141: 
142: template <>
143: bool TryCast::Operation(int8_t input, uint8_t &result, bool strict) {
144: 	return NumericTryCast::Operation<int8_t, uint8_t>(input, result, strict);
145: }
146: 
147: template <>
148: bool TryCast::Operation(int8_t input, uint16_t &result, bool strict) {
149: 	return NumericTryCast::Operation<int8_t, uint16_t>(input, result, strict);
150: }
151: 
152: template <>
153: bool TryCast::Operation(int8_t input, uint32_t &result, bool strict) {
154: 	return NumericTryCast::Operation<int8_t, uint32_t>(input, result, strict);
155: }
156: 
157: template <>
158: bool TryCast::Operation(int8_t input, uint64_t &result, bool strict) {
159: 	return NumericTryCast::Operation<int8_t, uint64_t>(input, result, strict);
160: }
161: 
162: template <>
163: bool TryCast::Operation(int8_t input, float &result, bool strict) {
164: 	return NumericTryCast::Operation<int8_t, float>(input, result, strict);
165: }
166: 
167: template <>
168: bool TryCast::Operation(int8_t input, double &result, bool strict) {
169: 	return NumericTryCast::Operation<int8_t, double>(input, result, strict);
170: }
171: 
172: //===--------------------------------------------------------------------===//
173: // Cast int16_t -> Numeric
174: //===--------------------------------------------------------------------===//
175: template <>
176: bool TryCast::Operation(int16_t input, bool &result, bool strict) {
177: 	return NumericTryCast::Operation<int16_t, bool>(input, result, strict);
178: }
179: 
180: template <>
181: bool TryCast::Operation(int16_t input, int8_t &result, bool strict) {
182: 	return NumericTryCast::Operation<int16_t, int8_t>(input, result, strict);
183: }
184: 
185: template <>
186: bool TryCast::Operation(int16_t input, int16_t &result, bool strict) {
187: 	return NumericTryCast::Operation<int16_t, int16_t>(input, result, strict);
188: }
189: 
190: template <>
191: bool TryCast::Operation(int16_t input, int32_t &result, bool strict) {
192: 	return NumericTryCast::Operation<int16_t, int32_t>(input, result, strict);
193: }
194: 
195: template <>
196: bool TryCast::Operation(int16_t input, int64_t &result, bool strict) {
197: 	return NumericTryCast::Operation<int16_t, int64_t>(input, result, strict);
198: }
199: 
200: template <>
201: bool TryCast::Operation(int16_t input, hugeint_t &result, bool strict) {
202: 	return NumericTryCast::Operation<int16_t, hugeint_t>(input, result, strict);
203: }
204: 
205: template <>
206: bool TryCast::Operation(int16_t input, uhugeint_t &result, bool strict) {
207: 	return NumericTryCast::Operation<int16_t, uhugeint_t>(input, result, strict);
208: }
209: 
210: template <>
211: bool TryCast::Operation(int16_t input, uint8_t &result, bool strict) {
212: 	return NumericTryCast::Operation<int16_t, uint8_t>(input, result, strict);
213: }
214: 
215: template <>
216: bool TryCast::Operation(int16_t input, uint16_t &result, bool strict) {
217: 	return NumericTryCast::Operation<int16_t, uint16_t>(input, result, strict);
218: }
219: 
220: template <>
221: bool TryCast::Operation(int16_t input, uint32_t &result, bool strict) {
222: 	return NumericTryCast::Operation<int16_t, uint32_t>(input, result, strict);
223: }
224: 
225: template <>
226: bool TryCast::Operation(int16_t input, uint64_t &result, bool strict) {
227: 	return NumericTryCast::Operation<int16_t, uint64_t>(input, result, strict);
228: }
229: 
230: template <>
231: bool TryCast::Operation(int16_t input, float &result, bool strict) {
232: 	return NumericTryCast::Operation<int16_t, float>(input, result, strict);
233: }
234: 
235: template <>
236: bool TryCast::Operation(int16_t input, double &result, bool strict) {
237: 	return NumericTryCast::Operation<int16_t, double>(input, result, strict);
238: }
239: 
240: //===--------------------------------------------------------------------===//
241: // Cast int32_t -> Numeric
242: //===--------------------------------------------------------------------===//
243: template <>
244: bool TryCast::Operation(int32_t input, bool &result, bool strict) {
245: 	return NumericTryCast::Operation<int32_t, bool>(input, result, strict);
246: }
247: 
248: template <>
249: bool TryCast::Operation(int32_t input, int8_t &result, bool strict) {
250: 	return NumericTryCast::Operation<int32_t, int8_t>(input, result, strict);
251: }
252: 
253: template <>
254: bool TryCast::Operation(int32_t input, int16_t &result, bool strict) {
255: 	return NumericTryCast::Operation<int32_t, int16_t>(input, result, strict);
256: }
257: 
258: template <>
259: bool TryCast::Operation(int32_t input, int32_t &result, bool strict) {
260: 	return NumericTryCast::Operation<int32_t, int32_t>(input, result, strict);
261: }
262: 
263: template <>
264: bool TryCast::Operation(int32_t input, int64_t &result, bool strict) {
265: 	return NumericTryCast::Operation<int32_t, int64_t>(input, result, strict);
266: }
267: 
268: template <>
269: bool TryCast::Operation(int32_t input, hugeint_t &result, bool strict) {
270: 	return NumericTryCast::Operation<int32_t, hugeint_t>(input, result, strict);
271: }
272: 
273: template <>
274: bool TryCast::Operation(int32_t input, uhugeint_t &result, bool strict) {
275: 	return NumericTryCast::Operation<int32_t, uhugeint_t>(input, result, strict);
276: }
277: 
278: template <>
279: bool TryCast::Operation(int32_t input, uint8_t &result, bool strict) {
280: 	return NumericTryCast::Operation<int32_t, uint8_t>(input, result, strict);
281: }
282: 
283: template <>
284: bool TryCast::Operation(int32_t input, uint16_t &result, bool strict) {
285: 	return NumericTryCast::Operation<int32_t, uint16_t>(input, result, strict);
286: }
287: 
288: template <>
289: bool TryCast::Operation(int32_t input, uint32_t &result, bool strict) {
290: 	return NumericTryCast::Operation<int32_t, uint32_t>(input, result, strict);
291: }
292: 
293: template <>
294: bool TryCast::Operation(int32_t input, uint64_t &result, bool strict) {
295: 	return NumericTryCast::Operation<int32_t, uint64_t>(input, result, strict);
296: }
297: 
298: template <>
299: bool TryCast::Operation(int32_t input, float &result, bool strict) {
300: 	return NumericTryCast::Operation<int32_t, float>(input, result, strict);
301: }
302: 
303: template <>
304: bool TryCast::Operation(int32_t input, double &result, bool strict) {
305: 	return NumericTryCast::Operation<int32_t, double>(input, result, strict);
306: }
307: 
308: //===--------------------------------------------------------------------===//
309: // Cast int64_t -> Numeric
310: //===--------------------------------------------------------------------===//
311: template <>
312: bool TryCast::Operation(int64_t input, bool &result, bool strict) {
313: 	return NumericTryCast::Operation<int64_t, bool>(input, result, strict);
314: }
315: 
316: template <>
317: bool TryCast::Operation(int64_t input, int8_t &result, bool strict) {
318: 	return NumericTryCast::Operation<int64_t, int8_t>(input, result, strict);
319: }
320: 
321: template <>
322: bool TryCast::Operation(int64_t input, int16_t &result, bool strict) {
323: 	return NumericTryCast::Operation<int64_t, int16_t>(input, result, strict);
324: }
325: 
326: template <>
327: bool TryCast::Operation(int64_t input, int32_t &result, bool strict) {
328: 	return NumericTryCast::Operation<int64_t, int32_t>(input, result, strict);
329: }
330: 
331: template <>
332: bool TryCast::Operation(int64_t input, int64_t &result, bool strict) {
333: 	return NumericTryCast::Operation<int64_t, int64_t>(input, result, strict);
334: }
335: 
336: template <>
337: bool TryCast::Operation(int64_t input, hugeint_t &result, bool strict) {
338: 	return NumericTryCast::Operation<int64_t, hugeint_t>(input, result, strict);
339: }
340: 
341: template <>
342: bool TryCast::Operation(int64_t input, uhugeint_t &result, bool strict) {
343: 	return NumericTryCast::Operation<int64_t, uhugeint_t>(input, result, strict);
344: }
345: 
346: template <>
347: bool TryCast::Operation(int64_t input, uint8_t &result, bool strict) {
348: 	return NumericTryCast::Operation<int64_t, uint8_t>(input, result, strict);
349: }
350: 
351: template <>
352: bool TryCast::Operation(int64_t input, uint16_t &result, bool strict) {
353: 	return NumericTryCast::Operation<int64_t, uint16_t>(input, result, strict);
354: }
355: 
356: template <>
357: bool TryCast::Operation(int64_t input, uint32_t &result, bool strict) {
358: 	return NumericTryCast::Operation<int64_t, uint32_t>(input, result, strict);
359: }
360: 
361: template <>
362: bool TryCast::Operation(int64_t input, uint64_t &result, bool strict) {
363: 	return NumericTryCast::Operation<int64_t, uint64_t>(input, result, strict);
364: }
365: 
366: template <>
367: bool TryCast::Operation(int64_t input, float &result, bool strict) {
368: 	return NumericTryCast::Operation<int64_t, float>(input, result, strict);
369: }
370: 
371: template <>
372: bool TryCast::Operation(int64_t input, double &result, bool strict) {
373: 	return NumericTryCast::Operation<int64_t, double>(input, result, strict);
374: }
375: 
376: //===--------------------------------------------------------------------===//
377: // Cast hugeint_t -> Numeric
378: //===--------------------------------------------------------------------===//
379: template <>
380: bool TryCast::Operation(hugeint_t input, bool &result, bool strict) {
381: 	return NumericTryCast::Operation<hugeint_t, bool>(input, result, strict);
382: }
383: 
384: template <>
385: bool TryCast::Operation(hugeint_t input, int8_t &result, bool strict) {
386: 	return NumericTryCast::Operation<hugeint_t, int8_t>(input, result, strict);
387: }
388: 
389: template <>
390: bool TryCast::Operation(hugeint_t input, int16_t &result, bool strict) {
391: 	return NumericTryCast::Operation<hugeint_t, int16_t>(input, result, strict);
392: }
393: 
394: template <>
395: bool TryCast::Operation(hugeint_t input, int32_t &result, bool strict) {
396: 	return NumericTryCast::Operation<hugeint_t, int32_t>(input, result, strict);
397: }
398: 
399: template <>
400: bool TryCast::Operation(hugeint_t input, int64_t &result, bool strict) {
401: 	return NumericTryCast::Operation<hugeint_t, int64_t>(input, result, strict);
402: }
403: 
404: template <>
405: bool TryCast::Operation(hugeint_t input, hugeint_t &result, bool strict) {
406: 	return NumericTryCast::Operation<hugeint_t, hugeint_t>(input, result, strict);
407: }
408: 
409: template <>
410: bool TryCast::Operation(hugeint_t input, uhugeint_t &result, bool strict) {
411: 	return NumericTryCast::Operation<hugeint_t, uhugeint_t>(input, result, strict);
412: }
413: 
414: template <>
415: bool TryCast::Operation(hugeint_t input, uint8_t &result, bool strict) {
416: 	return NumericTryCast::Operation<hugeint_t, uint8_t>(input, result, strict);
417: }
418: 
419: template <>
420: bool TryCast::Operation(hugeint_t input, uint16_t &result, bool strict) {
421: 	return NumericTryCast::Operation<hugeint_t, uint16_t>(input, result, strict);
422: }
423: 
424: template <>
425: bool TryCast::Operation(hugeint_t input, uint32_t &result, bool strict) {
426: 	return NumericTryCast::Operation<hugeint_t, uint32_t>(input, result, strict);
427: }
428: 
429: template <>
430: bool TryCast::Operation(hugeint_t input, uint64_t &result, bool strict) {
431: 	return NumericTryCast::Operation<hugeint_t, uint64_t>(input, result, strict);
432: }
433: 
434: template <>
435: bool TryCast::Operation(hugeint_t input, float &result, bool strict) {
436: 	return NumericTryCast::Operation<hugeint_t, float>(input, result, strict);
437: }
438: 
439: template <>
440: bool TryCast::Operation(hugeint_t input, double &result, bool strict) {
441: 	return NumericTryCast::Operation<hugeint_t, double>(input, result, strict);
442: }
443: 
444: //===--------------------------------------------------------------------===//
445: // Cast uhugeint_t -> Numeric
446: //===--------------------------------------------------------------------===//
447: template <>
448: bool TryCast::Operation(uhugeint_t input, bool &result, bool strict) {
449: 	return NumericTryCast::Operation<uhugeint_t, bool>(input, result, strict);
450: }
451: 
452: template <>
453: bool TryCast::Operation(uhugeint_t input, int8_t &result, bool strict) {
454: 	return NumericTryCast::Operation<uhugeint_t, int8_t>(input, result, strict);
455: }
456: 
457: template <>
458: bool TryCast::Operation(uhugeint_t input, int16_t &result, bool strict) {
459: 	return NumericTryCast::Operation<uhugeint_t, int16_t>(input, result, strict);
460: }
461: 
462: template <>
463: bool TryCast::Operation(uhugeint_t input, int32_t &result, bool strict) {
464: 	return NumericTryCast::Operation<uhugeint_t, int32_t>(input, result, strict);
465: }
466: 
467: template <>
468: bool TryCast::Operation(uhugeint_t input, int64_t &result, bool strict) {
469: 	return NumericTryCast::Operation<uhugeint_t, int64_t>(input, result, strict);
470: }
471: 
472: template <>
473: bool TryCast::Operation(uhugeint_t input, uhugeint_t &result, bool strict) {
474: 	return NumericTryCast::Operation<uhugeint_t, uhugeint_t>(input, result, strict);
475: }
476: 
477: template <>
478: bool TryCast::Operation(uhugeint_t input, hugeint_t &result, bool strict) {
479: 	return NumericTryCast::Operation<uhugeint_t, hugeint_t>(input, result, strict);
480: }
481: 
482: template <>
483: bool TryCast::Operation(uhugeint_t input, uint8_t &result, bool strict) {
484: 	return NumericTryCast::Operation<uhugeint_t, uint8_t>(input, result, strict);
485: }
486: 
487: template <>
488: bool TryCast::Operation(uhugeint_t input, uint16_t &result, bool strict) {
489: 	return NumericTryCast::Operation<uhugeint_t, uint16_t>(input, result, strict);
490: }
491: 
492: template <>
493: bool TryCast::Operation(uhugeint_t input, uint32_t &result, bool strict) {
494: 	return NumericTryCast::Operation<uhugeint_t, uint32_t>(input, result, strict);
495: }
496: 
497: template <>
498: bool TryCast::Operation(uhugeint_t input, uint64_t &result, bool strict) {
499: 	return NumericTryCast::Operation<uhugeint_t, uint64_t>(input, result, strict);
500: }
501: 
502: template <>
503: bool TryCast::Operation(uhugeint_t input, float &result, bool strict) {
504: 	return NumericTryCast::Operation<uhugeint_t, float>(input, result, strict);
505: }
506: 
507: template <>
508: bool TryCast::Operation(uhugeint_t input, double &result, bool strict) {
509: 	return NumericTryCast::Operation<uhugeint_t, double>(input, result, strict);
510: }
511: 
512: //===--------------------------------------------------------------------===//
513: // Cast uint8_t -> Numeric
514: //===--------------------------------------------------------------------===//
515: template <>
516: bool TryCast::Operation(uint8_t input, bool &result, bool strict) {
517: 	return NumericTryCast::Operation<uint8_t, bool>(input, result, strict);
518: }
519: 
520: template <>
521: bool TryCast::Operation(uint8_t input, int8_t &result, bool strict) {
522: 	return NumericTryCast::Operation<uint8_t, int8_t>(input, result, strict);
523: }
524: 
525: template <>
526: bool TryCast::Operation(uint8_t input, int16_t &result, bool strict) {
527: 	return NumericTryCast::Operation<uint8_t, int16_t>(input, result, strict);
528: }
529: 
530: template <>
531: bool TryCast::Operation(uint8_t input, int32_t &result, bool strict) {
532: 	return NumericTryCast::Operation<uint8_t, int32_t>(input, result, strict);
533: }
534: 
535: template <>
536: bool TryCast::Operation(uint8_t input, int64_t &result, bool strict) {
537: 	return NumericTryCast::Operation<uint8_t, int64_t>(input, result, strict);
538: }
539: 
540: template <>
541: bool TryCast::Operation(uint8_t input, hugeint_t &result, bool strict) {
542: 	return NumericTryCast::Operation<uint8_t, hugeint_t>(input, result, strict);
543: }
544: 
545: template <>
546: bool TryCast::Operation(uint8_t input, uhugeint_t &result, bool strict) {
547: 	return NumericTryCast::Operation<uint8_t, uhugeint_t>(input, result, strict);
548: }
549: 
550: template <>
551: bool TryCast::Operation(uint8_t input, uint8_t &result, bool strict) {
552: 	return NumericTryCast::Operation<uint8_t, uint8_t>(input, result, strict);
553: }
554: 
555: template <>
556: bool TryCast::Operation(uint8_t input, uint16_t &result, bool strict) {
557: 	return NumericTryCast::Operation<uint8_t, uint16_t>(input, result, strict);
558: }
559: 
560: template <>
561: bool TryCast::Operation(uint8_t input, uint32_t &result, bool strict) {
562: 	return NumericTryCast::Operation<uint8_t, uint32_t>(input, result, strict);
563: }
564: 
565: template <>
566: bool TryCast::Operation(uint8_t input, uint64_t &result, bool strict) {
567: 	return NumericTryCast::Operation<uint8_t, uint64_t>(input, result, strict);
568: }
569: 
570: template <>
571: bool TryCast::Operation(uint8_t input, float &result, bool strict) {
572: 	return NumericTryCast::Operation<uint8_t, float>(input, result, strict);
573: }
574: 
575: template <>
576: bool TryCast::Operation(uint8_t input, double &result, bool strict) {
577: 	return NumericTryCast::Operation<uint8_t, double>(input, result, strict);
578: }
579: 
580: //===--------------------------------------------------------------------===//
581: // Cast uint16_t -> Numeric
582: //===--------------------------------------------------------------------===//
583: template <>
584: bool TryCast::Operation(uint16_t input, bool &result, bool strict) {
585: 	return NumericTryCast::Operation<uint16_t, bool>(input, result, strict);
586: }
587: 
588: template <>
589: bool TryCast::Operation(uint16_t input, int8_t &result, bool strict) {
590: 	return NumericTryCast::Operation<uint16_t, int8_t>(input, result, strict);
591: }
592: 
593: template <>
594: bool TryCast::Operation(uint16_t input, int16_t &result, bool strict) {
595: 	return NumericTryCast::Operation<uint16_t, int16_t>(input, result, strict);
596: }
597: 
598: template <>
599: bool TryCast::Operation(uint16_t input, int32_t &result, bool strict) {
600: 	return NumericTryCast::Operation<uint16_t, int32_t>(input, result, strict);
601: }
602: 
603: template <>
604: bool TryCast::Operation(uint16_t input, int64_t &result, bool strict) {
605: 	return NumericTryCast::Operation<uint16_t, int64_t>(input, result, strict);
606: }
607: 
608: template <>
609: bool TryCast::Operation(uint16_t input, hugeint_t &result, bool strict) {
610: 	return NumericTryCast::Operation<uint16_t, hugeint_t>(input, result, strict);
611: }
612: 
613: template <>
614: bool TryCast::Operation(uint16_t input, uhugeint_t &result, bool strict) {
615: 	return NumericTryCast::Operation<uint16_t, uhugeint_t>(input, result, strict);
616: }
617: 
618: template <>
619: bool TryCast::Operation(uint16_t input, uint8_t &result, bool strict) {
620: 	return NumericTryCast::Operation<uint16_t, uint8_t>(input, result, strict);
621: }
622: 
623: template <>
624: bool TryCast::Operation(uint16_t input, uint16_t &result, bool strict) {
625: 	return NumericTryCast::Operation<uint16_t, uint16_t>(input, result, strict);
626: }
627: 
628: template <>
629: bool TryCast::Operation(uint16_t input, uint32_t &result, bool strict) {
630: 	return NumericTryCast::Operation<uint16_t, uint32_t>(input, result, strict);
631: }
632: 
633: template <>
634: bool TryCast::Operation(uint16_t input, uint64_t &result, bool strict) {
635: 	return NumericTryCast::Operation<uint16_t, uint64_t>(input, result, strict);
636: }
637: 
638: template <>
639: bool TryCast::Operation(uint16_t input, float &result, bool strict) {
640: 	return NumericTryCast::Operation<uint16_t, float>(input, result, strict);
641: }
642: 
643: template <>
644: bool TryCast::Operation(uint16_t input, double &result, bool strict) {
645: 	return NumericTryCast::Operation<uint16_t, double>(input, result, strict);
646: }
647: 
648: //===--------------------------------------------------------------------===//
649: // Cast uint32_t -> Numeric
650: //===--------------------------------------------------------------------===//
651: template <>
652: bool TryCast::Operation(uint32_t input, bool &result, bool strict) {
653: 	return NumericTryCast::Operation<uint32_t, bool>(input, result, strict);
654: }
655: 
656: template <>
657: bool TryCast::Operation(uint32_t input, int8_t &result, bool strict) {
658: 	return NumericTryCast::Operation<uint32_t, int8_t>(input, result, strict);
659: }
660: 
661: template <>
662: bool TryCast::Operation(uint32_t input, int16_t &result, bool strict) {
663: 	return NumericTryCast::Operation<uint32_t, int16_t>(input, result, strict);
664: }
665: 
666: template <>
667: bool TryCast::Operation(uint32_t input, int32_t &result, bool strict) {
668: 	return NumericTryCast::Operation<uint32_t, int32_t>(input, result, strict);
669: }
670: 
671: template <>
672: bool TryCast::Operation(uint32_t input, int64_t &result, bool strict) {
673: 	return NumericTryCast::Operation<uint32_t, int64_t>(input, result, strict);
674: }
675: 
676: template <>
677: bool TryCast::Operation(uint32_t input, hugeint_t &result, bool strict) {
678: 	return NumericTryCast::Operation<uint32_t, hugeint_t>(input, result, strict);
679: }
680: 
681: template <>
682: bool TryCast::Operation(uint32_t input, uhugeint_t &result, bool strict) {
683: 	return NumericTryCast::Operation<uint32_t, uhugeint_t>(input, result, strict);
684: }
685: 
686: template <>
687: bool TryCast::Operation(uint32_t input, uint8_t &result, bool strict) {
688: 	return NumericTryCast::Operation<uint32_t, uint8_t>(input, result, strict);
689: }
690: 
691: template <>
692: bool TryCast::Operation(uint32_t input, uint16_t &result, bool strict) {
693: 	return NumericTryCast::Operation<uint32_t, uint16_t>(input, result, strict);
694: }
695: 
696: template <>
697: bool TryCast::Operation(uint32_t input, uint32_t &result, bool strict) {
698: 	return NumericTryCast::Operation<uint32_t, uint32_t>(input, result, strict);
699: }
700: 
701: template <>
702: bool TryCast::Operation(uint32_t input, uint64_t &result, bool strict) {
703: 	return NumericTryCast::Operation<uint32_t, uint64_t>(input, result, strict);
704: }
705: 
706: template <>
707: bool TryCast::Operation(uint32_t input, float &result, bool strict) {
708: 	return NumericTryCast::Operation<uint32_t, float>(input, result, strict);
709: }
710: 
711: template <>
712: bool TryCast::Operation(uint32_t input, double &result, bool strict) {
713: 	return NumericTryCast::Operation<uint32_t, double>(input, result, strict);
714: }
715: 
716: //===--------------------------------------------------------------------===//
717: // Cast uint64_t -> Numeric
718: //===--------------------------------------------------------------------===//
719: template <>
720: bool TryCast::Operation(uint64_t input, bool &result, bool strict) {
721: 	return NumericTryCast::Operation<uint64_t, bool>(input, result, strict);
722: }
723: 
724: template <>
725: bool TryCast::Operation(uint64_t input, int8_t &result, bool strict) {
726: 	return NumericTryCast::Operation<uint64_t, int8_t>(input, result, strict);
727: }
728: 
729: template <>
730: bool TryCast::Operation(uint64_t input, int16_t &result, bool strict) {
731: 	return NumericTryCast::Operation<uint64_t, int16_t>(input, result, strict);
732: }
733: 
734: template <>
735: bool TryCast::Operation(uint64_t input, int32_t &result, bool strict) {
736: 	return NumericTryCast::Operation<uint64_t, int32_t>(input, result, strict);
737: }
738: 
739: template <>
740: bool TryCast::Operation(uint64_t input, int64_t &result, bool strict) {
741: 	return NumericTryCast::Operation<uint64_t, int64_t>(input, result, strict);
742: }
743: 
744: template <>
745: bool TryCast::Operation(uint64_t input, hugeint_t &result, bool strict) {
746: 	return NumericTryCast::Operation<uint64_t, hugeint_t>(input, result, strict);
747: }
748: 
749: template <>
750: bool TryCast::Operation(uint64_t input, uhugeint_t &result, bool strict) {
751: 	return NumericTryCast::Operation<uint64_t, uhugeint_t>(input, result, strict);
752: }
753: 
754: template <>
755: bool TryCast::Operation(uint64_t input, uint8_t &result, bool strict) {
756: 	return NumericTryCast::Operation<uint64_t, uint8_t>(input, result, strict);
757: }
758: 
759: template <>
760: bool TryCast::Operation(uint64_t input, uint16_t &result, bool strict) {
761: 	return NumericTryCast::Operation<uint64_t, uint16_t>(input, result, strict);
762: }
763: 
764: template <>
765: bool TryCast::Operation(uint64_t input, uint32_t &result, bool strict) {
766: 	return NumericTryCast::Operation<uint64_t, uint32_t>(input, result, strict);
767: }
768: 
769: template <>
770: bool TryCast::Operation(uint64_t input, uint64_t &result, bool strict) {
771: 	return NumericTryCast::Operation<uint64_t, uint64_t>(input, result, strict);
772: }
773: 
774: template <>
775: bool TryCast::Operation(uint64_t input, float &result, bool strict) {
776: 	return NumericTryCast::Operation<uint64_t, float>(input, result, strict);
777: }
778: 
779: template <>
780: bool TryCast::Operation(uint64_t input, double &result, bool strict) {
781: 	return NumericTryCast::Operation<uint64_t, double>(input, result, strict);
782: }
783: 
784: //===--------------------------------------------------------------------===//
785: // Cast float -> Numeric
786: //===--------------------------------------------------------------------===//
787: template <>
788: bool TryCast::Operation(float input, bool &result, bool strict) {
789: 	return NumericTryCast::Operation<float, bool>(input, result, strict);
790: }
791: 
792: template <>
793: bool TryCast::Operation(float input, int8_t &result, bool strict) {
794: 	return NumericTryCast::Operation<float, int8_t>(input, result, strict);
795: }
796: 
797: template <>
798: bool TryCast::Operation(float input, int16_t &result, bool strict) {
799: 	return NumericTryCast::Operation<float, int16_t>(input, result, strict);
800: }
801: 
802: template <>
803: bool TryCast::Operation(float input, int32_t &result, bool strict) {
804: 	return NumericTryCast::Operation<float, int32_t>(input, result, strict);
805: }
806: 
807: template <>
808: bool TryCast::Operation(float input, int64_t &result, bool strict) {
809: 	return NumericTryCast::Operation<float, int64_t>(input, result, strict);
810: }
811: 
812: template <>
813: bool TryCast::Operation(float input, hugeint_t &result, bool strict) {
814: 	return NumericTryCast::Operation<float, hugeint_t>(input, result, strict);
815: }
816: 
817: template <>
818: bool TryCast::Operation(float input, uhugeint_t &result, bool strict) {
819: 	return NumericTryCast::Operation<float, uhugeint_t>(input, result, strict);
820: }
821: 
822: template <>
823: bool TryCast::Operation(float input, uint8_t &result, bool strict) {
824: 	return NumericTryCast::Operation<float, uint8_t>(input, result, strict);
825: }
826: 
827: template <>
828: bool TryCast::Operation(float input, uint16_t &result, bool strict) {
829: 	return NumericTryCast::Operation<float, uint16_t>(input, result, strict);
830: }
831: 
832: template <>
833: bool TryCast::Operation(float input, uint32_t &result, bool strict) {
834: 	return NumericTryCast::Operation<float, uint32_t>(input, result, strict);
835: }
836: 
837: template <>
838: bool TryCast::Operation(float input, uint64_t &result, bool strict) {
839: 	return NumericTryCast::Operation<float, uint64_t>(input, result, strict);
840: }
841: 
842: template <>
843: bool TryCast::Operation(float input, float &result, bool strict) {
844: 	return NumericTryCast::Operation<float, float>(input, result, strict);
845: }
846: 
847: template <>
848: bool TryCast::Operation(float input, double &result, bool strict) {
849: 	return NumericTryCast::Operation<float, double>(input, result, strict);
850: }
851: 
852: //===--------------------------------------------------------------------===//
853: // Cast double -> Numeric
854: //===--------------------------------------------------------------------===//
855: template <>
856: bool TryCast::Operation(double input, bool &result, bool strict) {
857: 	return NumericTryCast::Operation<double, bool>(input, result, strict);
858: }
859: 
860: template <>
861: bool TryCast::Operation(double input, int8_t &result, bool strict) {
862: 	return NumericTryCast::Operation<double, int8_t>(input, result, strict);
863: }
864: 
865: template <>
866: bool TryCast::Operation(double input, int16_t &result, bool strict) {
867: 	return NumericTryCast::Operation<double, int16_t>(input, result, strict);
868: }
869: 
870: template <>
871: bool TryCast::Operation(double input, int32_t &result, bool strict) {
872: 	return NumericTryCast::Operation<double, int32_t>(input, result, strict);
873: }
874: 
875: template <>
876: bool TryCast::Operation(double input, int64_t &result, bool strict) {
877: 	return NumericTryCast::Operation<double, int64_t>(input, result, strict);
878: }
879: 
880: template <>
881: bool TryCast::Operation(double input, hugeint_t &result, bool strict) {
882: 	return NumericTryCast::Operation<double, hugeint_t>(input, result, strict);
883: }
884: 
885: template <>
886: bool TryCast::Operation(double input, uhugeint_t &result, bool strict) {
887: 	return NumericTryCast::Operation<double, uhugeint_t>(input, result, strict);
888: }
889: 
890: template <>
891: bool TryCast::Operation(double input, uint8_t &result, bool strict) {
892: 	return NumericTryCast::Operation<double, uint8_t>(input, result, strict);
893: }
894: 
895: template <>
896: bool TryCast::Operation(double input, uint16_t &result, bool strict) {
897: 	return NumericTryCast::Operation<double, uint16_t>(input, result, strict);
898: }
899: 
900: template <>
901: bool TryCast::Operation(double input, uint32_t &result, bool strict) {
902: 	return NumericTryCast::Operation<double, uint32_t>(input, result, strict);
903: }
904: 
905: template <>
906: bool TryCast::Operation(double input, uint64_t &result, bool strict) {
907: 	return NumericTryCast::Operation<double, uint64_t>(input, result, strict);
908: }
909: 
910: template <>
911: bool TryCast::Operation(double input, float &result, bool strict) {
912: 	return NumericTryCast::Operation<double, float>(input, result, strict);
913: }
914: 
915: template <>
916: bool TryCast::Operation(double input, double &result, bool strict) {
917: 	return NumericTryCast::Operation<double, double>(input, result, strict);
918: }
919: 
920: //===--------------------------------------------------------------------===//
921: // Cast String -> Numeric
922: //===--------------------------------------------------------------------===//
923: 
924: template <>
925: bool TryCast::Operation(string_t input, bool &result, bool strict) {
926: 	auto input_data = reinterpret_cast<const char *>(input.GetData());
927: 	auto input_size = input.GetSize();
928: 	return TryCastStringBool(input_data, input_size, result, strict);
929: }
930: template <>
931: bool TryCast::Operation(string_t input, int8_t &result, bool strict) {
932: 	return TrySimpleIntegerCast<int8_t>(input.GetData(), input.GetSize(), result, strict);
933: }
934: template <>
935: bool TryCast::Operation(string_t input, int16_t &result, bool strict) {
936: 	return TrySimpleIntegerCast<int16_t>(input.GetData(), input.GetSize(), result, strict);
937: }
938: template <>
939: bool TryCast::Operation(string_t input, int32_t &result, bool strict) {
940: 	return TrySimpleIntegerCast<int32_t>(input.GetData(), input.GetSize(), result, strict);
941: }
942: template <>
943: bool TryCast::Operation(string_t input, int64_t &result, bool strict) {
944: 	return TrySimpleIntegerCast<int64_t>(input.GetData(), input.GetSize(), result, strict);
945: }
946: 
947: template <>
948: bool TryCast::Operation(string_t input, uint8_t &result, bool strict) {
949: 	return TrySimpleIntegerCast<uint8_t, false>(input.GetData(), input.GetSize(), result, strict);
950: }
951: template <>
952: bool TryCast::Operation(string_t input, uint16_t &result, bool strict) {
953: 	return TrySimpleIntegerCast<uint16_t, false>(input.GetData(), input.GetSize(), result, strict);
954: }
955: template <>
956: bool TryCast::Operation(string_t input, uint32_t &result, bool strict) {
957: 	return TrySimpleIntegerCast<uint32_t, false>(input.GetData(), input.GetSize(), result, strict);
958: }
959: template <>
960: bool TryCast::Operation(string_t input, uint64_t &result, bool strict) {
961: 	return TrySimpleIntegerCast<uint64_t, false>(input.GetData(), input.GetSize(), result, strict);
962: }
963: 
964: template <>
965: bool TryCast::Operation(string_t input, float &result, bool strict) {
966: 	return TryDoubleCast<float>(input.GetData(), input.GetSize(), result, strict);
967: }
968: 
969: template <>
970: bool TryCast::Operation(string_t input, double &result, bool strict) {
971: 	return TryDoubleCast<double>(input.GetData(), input.GetSize(), result, strict);
972: }
973: 
974: template <>
975: bool TryCastErrorMessageCommaSeparated::Operation(string_t input, float &result, CastParameters &parameters) {
976: 	if (!TryDoubleCast<float>(input.GetData(), input.GetSize(), result, parameters.strict, ',')) {
977: 		HandleCastError::AssignError(StringUtil::Format("Could not cast string to float: \"%s\"", input.GetString()),
978: 		                             parameters);
979: 		return false;
980: 	}
981: 	return true;
982: }
983: 
984: template <>
985: bool TryCastErrorMessageCommaSeparated::Operation(string_t input, double &result, CastParameters &parameters) {
986: 	if (!TryDoubleCast<double>(input.GetData(), input.GetSize(), result, parameters.strict, ',')) {
987: 		HandleCastError::AssignError(StringUtil::Format("Could not cast string to double: \"%s\"", input.GetString()),
988: 		                             parameters);
989: 		return false;
990: 	}
991: 	return true;
992: }
993: 
994: //===--------------------------------------------------------------------===//
995: // Cast From Date
996: //===--------------------------------------------------------------------===//
997: template <>
998: bool TryCast::Operation(date_t input, date_t &result, bool strict) {
999: 	result = input;
1000: 	return true;
1001: }
1002: 
1003: template <>
1004: bool TryCast::Operation(date_t input, timestamp_t &result, bool strict) {
1005: 	if (input == date_t::infinity()) {
1006: 		result = timestamp_t::infinity();
1007: 		return true;
1008: 	} else if (input == date_t::ninfinity()) {
1009: 		result = timestamp_t::ninfinity();
1010: 		return true;
1011: 	}
1012: 	return Timestamp::TryFromDatetime(input, Time::FromTime(0, 0, 0), result);
1013: }
1014: 
1015: //===--------------------------------------------------------------------===//
1016: // Cast From Time
1017: //===--------------------------------------------------------------------===//
1018: template <>
1019: bool TryCast::Operation(dtime_t input, dtime_t &result, bool strict) {
1020: 	result = input;
1021: 	return true;
1022: }
1023: 
1024: template <>
1025: bool TryCast::Operation(dtime_t input, dtime_tz_t &result, bool strict) {
1026: 	result = dtime_tz_t(input, 0);
1027: 	return true;
1028: }
1029: 
1030: //===--------------------------------------------------------------------===//
1031: // Cast From Time With Time Zone (Offset)
1032: //===--------------------------------------------------------------------===//
1033: template <>
1034: bool TryCast::Operation(dtime_tz_t input, dtime_tz_t &result, bool strict) {
1035: 	result = input;
1036: 	return true;
1037: }
1038: 
1039: template <>
1040: bool TryCast::Operation(dtime_tz_t input, dtime_t &result, bool strict) {
1041: 	result = input.time();
1042: 	return true;
1043: }
1044: 
1045: //===--------------------------------------------------------------------===//
1046: // Cast From Timestamps
1047: //===--------------------------------------------------------------------===//
1048: template <>
1049: bool TryCast::Operation(timestamp_t input, date_t &result, bool strict) {
1050: 	result = Timestamp::GetDate(input);
1051: 	return true;
1052: }
1053: 
1054: template <>
1055: bool TryCast::Operation(timestamp_t input, dtime_t &result, bool strict) {
1056: 	if (!Timestamp::IsFinite(input)) {
1057: 		return false;
1058: 	}
1059: 	result = Timestamp::GetTime(input);
1060: 	return true;
1061: }
1062: 
1063: template <>
1064: bool TryCast::Operation(timestamp_t input, timestamp_t &result, bool strict) {
1065: 	result = input;
1066: 	return true;
1067: }
1068: 
1069: template <>
1070: bool TryCast::Operation(timestamp_sec_t input, timestamp_sec_t &result, bool strict) {
1071: 	result.value = input.value;
1072: 	return true;
1073: }
1074: 
1075: template <>
1076: bool TryCast::Operation(timestamp_t input, timestamp_sec_t &result, bool strict) {
1077: 	D_ASSERT(Timestamp::IsFinite(input));
1078: 	result.value = input.value / Interval::MICROS_PER_SEC;
1079: 	return true;
1080: }
1081: 
1082: template <>
1083: bool TryCast::Operation(timestamp_ms_t input, timestamp_ms_t &result, bool strict) {
1084: 	result.value = input.value;
1085: 	return true;
1086: }
1087: 
1088: template <>
1089: bool TryCast::Operation(timestamp_t input, timestamp_ms_t &result, bool strict) {
1090: 	D_ASSERT(Timestamp::IsFinite(input));
1091: 	result.value = input.value / Interval::MICROS_PER_MSEC;
1092: 	return true;
1093: }
1094: 
1095: template <>
1096: bool TryCast::Operation(timestamp_ns_t input, timestamp_ns_t &result, bool strict) {
1097: 	result.value = input.value;
1098: 	return true;
1099: }
1100: 
1101: template <>
1102: bool TryCast::Operation(timestamp_t input, timestamp_ns_t &result, bool strict) {
1103: 	D_ASSERT(Timestamp::IsFinite(input));
1104: 	if (!TryMultiplyOperator::Operation(input.value, Interval::NANOS_PER_MSEC, result.value)) {
1105: 		throw ConversionException("Could not convert TIMESTAMP to TIMESTAMP_NS");
1106: 	}
1107: 	return true;
1108: }
1109: 
1110: template <>
1111: bool TryCast::Operation(timestamp_tz_t input, timestamp_tz_t &result, bool strict) {
1112: 	result.value = input.value;
1113: 	return true;
1114: }
1115: 
1116: template <>
1117: bool TryCast::Operation(timestamp_t input, timestamp_tz_t &result, bool strict) {
1118: 	result.value = input.value;
1119: 	return true;
1120: }
1121: 
1122: template <>
1123: bool TryCast::Operation(timestamp_t input, dtime_tz_t &result, bool strict) {
1124: 	if (!Timestamp::IsFinite(input)) {
1125: 		return false;
1126: 	}
1127: 	result = dtime_tz_t(Timestamp::GetTime(input), 0);
1128: 	return true;
1129: }
1130: 
1131: //===--------------------------------------------------------------------===//
1132: // Cast from Interval
1133: //===--------------------------------------------------------------------===//
1134: template <>
1135: bool TryCast::Operation(interval_t input, interval_t &result, bool strict) {
1136: 	result = input;
1137: 	return true;
1138: }
1139: 
1140: //===--------------------------------------------------------------------===//
1141: // Non-Standard Timestamps
1142: //===--------------------------------------------------------------------===//
1143: template <>
1144: duckdb::string_t CastFromTimestampNS::Operation(duckdb::timestamp_ns_t input, Vector &result) {
1145: 	return StringCast::Operation<timestamp_ns_t>(input, result);
1146: }
1147: template <>
1148: duckdb::string_t CastFromTimestampMS::Operation(duckdb::timestamp_t input, Vector &result) {
1149: 	return StringCast::Operation<timestamp_t>(CastTimestampMsToUs::Operation<timestamp_t, timestamp_t>(input), result);
1150: }
1151: template <>
1152: duckdb::string_t CastFromTimestampSec::Operation(duckdb::timestamp_t input, Vector &result) {
1153: 	return StringCast::Operation<timestamp_t>(CastTimestampSecToUs::Operation<timestamp_t, timestamp_t>(input), result);
1154: }
1155: 
1156: template <>
1157: timestamp_t CastTimestampUsToMs::Operation(timestamp_t input) {
1158: 	if (!Timestamp::IsFinite(input)) {
1159: 		return input;
1160: 	}
1161: 	timestamp_t cast_timestamp(Timestamp::GetEpochRounded(input, Interval::MICROS_PER_MSEC));
1162: 	return cast_timestamp;
1163: }
1164: 
1165: template <>
1166: timestamp_t CastTimestampUsToNs::Operation(timestamp_t input) {
1167: 	if (!Timestamp::IsFinite(input)) {
1168: 		return input;
1169: 	}
1170: 	timestamp_t cast_timestamp(Timestamp::GetEpochNanoSeconds(input));
1171: 	return cast_timestamp;
1172: }
1173: 
1174: template <>
1175: timestamp_t CastTimestampUsToSec::Operation(timestamp_t input) {
1176: 	if (!Timestamp::IsFinite(input)) {
1177: 		return input;
1178: 	}
1179: 	timestamp_t cast_timestamp(Timestamp::GetEpochRounded(input, Interval::MICROS_PER_SEC));
1180: 	return cast_timestamp;
1181: }
1182: 
1183: template <>
1184: timestamp_t CastTimestampMsToUs::Operation(timestamp_t input) {
1185: 	if (!Timestamp::IsFinite(input)) {
1186: 		return input;
1187: 	}
1188: 	return Timestamp::FromEpochMs(input.value);
1189: }
1190: 
1191: template <>
1192: date_t CastTimestampMsToDate::Operation(timestamp_t input) {
1193: 	return Timestamp::GetDate(Timestamp::FromEpochMs(input.value));
1194: }
1195: 
1196: template <>
1197: dtime_t CastTimestampMsToTime::Operation(timestamp_t input) {
1198: 	return Timestamp::GetTime(Timestamp::FromEpochMs(input.value));
1199: }
1200: 
1201: template <>
1202: timestamp_t CastTimestampMsToNs::Operation(timestamp_t input) {
1203: 	if (!Timestamp::IsFinite(input)) {
1204: 		return input;
1205: 	}
1206: 	auto us = CastTimestampMsToUs::Operation<timestamp_t, timestamp_t>(input);
1207: 	return CastTimestampUsToNs::Operation<timestamp_t, timestamp_t>(us);
1208: }
1209: 
1210: template <>
1211: timestamp_t CastTimestampNsToUs::Operation(timestamp_t input) {
1212: 	if (!Timestamp::IsFinite(input)) {
1213: 		return input;
1214: 	}
1215: 	return Timestamp::FromEpochNanoSeconds(input.value);
1216: }
1217: 
1218: template <>
1219: timestamp_t CastTimestampSecToUs::Operation(timestamp_t input) {
1220: 	if (!Timestamp::IsFinite(input)) {
1221: 		return input;
1222: 	}
1223: 	return Timestamp::FromEpochSeconds(input.value);
1224: }
1225: 
1226: template <>
1227: date_t CastTimestampNsToDate::Operation(timestamp_t input) {
1228: 	if (input == timestamp_t::infinity()) {
1229: 		return date_t::infinity();
1230: 	} else if (input == timestamp_t::ninfinity()) {
1231: 		return date_t::ninfinity();
1232: 	}
1233: 	const auto us = CastTimestampNsToUs::Operation<timestamp_t, timestamp_t>(input);
1234: 	return Timestamp::GetDate(us);
1235: }
1236: 
1237: template <>
1238: dtime_t CastTimestampNsToTime::Operation(timestamp_t input) {
1239: 	const auto us = CastTimestampNsToUs::Operation<timestamp_t, timestamp_t>(input);
1240: 	return Timestamp::GetTime(us);
1241: }
1242: 
1243: template <>
1244: timestamp_t CastTimestampSecToMs::Operation(timestamp_t input) {
1245: 	if (!Timestamp::IsFinite(input)) {
1246: 		return input;
1247: 	}
1248: 	auto us = CastTimestampSecToUs::Operation<timestamp_t, timestamp_t>(input);
1249: 	return CastTimestampUsToMs::Operation<timestamp_t, timestamp_t>(us);
1250: }
1251: 
1252: template <>
1253: timestamp_t CastTimestampSecToNs::Operation(timestamp_t input) {
1254: 	if (!Timestamp::IsFinite(input)) {
1255: 		return input;
1256: 	}
1257: 	auto us = CastTimestampSecToUs::Operation<timestamp_t, timestamp_t>(input);
1258: 	return CastTimestampUsToNs::Operation<timestamp_t, timestamp_t>(us);
1259: }
1260: 
1261: template <>
1262: date_t CastTimestampSecToDate::Operation(timestamp_t input) {
1263: 	const auto us = CastTimestampSecToUs::Operation<timestamp_t, timestamp_t>(input);
1264: 	return Timestamp::GetDate(us);
1265: }
1266: 
1267: template <>
1268: dtime_t CastTimestampSecToTime::Operation(timestamp_t input) {
1269: 	const auto us = CastTimestampSecToUs::Operation<timestamp_t, timestamp_t>(input);
1270: 	return Timestamp::GetTime(us);
1271: }
1272: 
1273: //===--------------------------------------------------------------------===//
1274: // Cast To Timestamp
1275: //===--------------------------------------------------------------------===//
1276: template <>
1277: bool TryCastToTimestampNS::Operation(string_t input, timestamp_ns_t &result, bool strict) {
1278: 	return TryCast::Operation<string_t, timestamp_ns_t>(input, result, strict);
1279: }
1280: 
1281: template <>
1282: bool TryCastToTimestampMS::Operation(string_t input, timestamp_t &result, bool strict) {
1283: 	if (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {
1284: 		return false;
1285: 	}
1286: 	result = CastTimestampUsToMs::Operation<timestamp_t, timestamp_t>(result);
1287: 	return true;
1288: }
1289: 
1290: template <>
1291: bool TryCastToTimestampSec::Operation(string_t input, timestamp_t &result, bool strict) {
1292: 	if (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {
1293: 		return false;
1294: 	}
1295: 	result = CastTimestampUsToSec::Operation<timestamp_t, timestamp_t>(result);
1296: 	return true;
1297: }
1298: 
1299: template <>
1300: bool TryCastToTimestampNS::Operation(date_t input, timestamp_ns_t &result, bool strict) {
1301: 	if (!TryCast::Operation<date_t, timestamp_t>(input, result, strict)) {
1302: 		return false;
1303: 	}
1304: 	if (!Timestamp::IsFinite(result)) {
1305: 		return true;
1306: 	}
1307: 	if (!TryMultiplyOperator::Operation(result.value, Interval::NANOS_PER_MICRO, result.value)) {
1308: 		return false;
1309: 	}
1310: 	return true;
1311: }
1312: 
1313: template <>
1314: bool TryCastToTimestampMS::Operation(date_t input, timestamp_t &result, bool strict) {
1315: 	if (!TryCast::Operation<date_t, timestamp_t>(input, result, strict)) {
1316: 		return false;
1317: 	}
1318: 	if (!Timestamp::IsFinite(result)) {
1319: 		return true;
1320: 	}
1321: 	result.value /= Interval::MICROS_PER_MSEC;
1322: 	return true;
1323: }
1324: 
1325: template <>
1326: bool TryCastToTimestampSec::Operation(date_t input, timestamp_t &result, bool strict) {
1327: 	if (!TryCast::Operation<date_t, timestamp_t>(input, result, strict)) {
1328: 		return false;
1329: 	}
1330: 	if (!Timestamp::IsFinite(result)) {
1331: 		return true;
1332: 	}
1333: 	result.value /= Interval::MICROS_PER_MSEC * Interval::MSECS_PER_SEC;
1334: 	return true;
1335: }
1336: 
1337: //===--------------------------------------------------------------------===//
1338: // Cast From Blob
1339: //===--------------------------------------------------------------------===//
1340: template <>
1341: string_t CastFromBlob::Operation(string_t input, Vector &vector) {
1342: 	idx_t result_size = Blob::GetStringSize(input);
1343: 
1344: 	string_t result = StringVector::EmptyString(vector, result_size);
1345: 	Blob::ToString(input, result.GetDataWriteable());
1346: 	result.Finalize();
1347: 
1348: 	return result;
1349: }
1350: 
1351: template <>
1352: string_t CastFromBlobToBit::Operation(string_t input, Vector &vector) {
1353: 	idx_t result_size = input.GetSize() + 1;
1354: 	if (result_size <= 1) {
1355: 		throw ConversionException("Cannot cast empty BLOB to BIT");
1356: 	}
1357: 	return StringVector::AddStringOrBlob(vector, Bit::BlobToBit(input));
1358: }
1359: 
1360: //===--------------------------------------------------------------------===//
1361: // Cast From Bit
1362: //===--------------------------------------------------------------------===//
1363: template <>
1364: string_t CastFromBitToString::Operation(string_t input, Vector &vector) {
1365: 
1366: 	idx_t result_size = Bit::BitLength(input);
1367: 	string_t result = StringVector::EmptyString(vector, result_size);
1368: 	Bit::ToString(input, result.GetDataWriteable());
1369: 	result.Finalize();
1370: 
1371: 	return result;
1372: }
1373: 
1374: //===--------------------------------------------------------------------===//
1375: // Cast From Pointer
1376: //===--------------------------------------------------------------------===//
1377: template <>
1378: string_t CastFromPointer::Operation(uintptr_t input, Vector &vector) {
1379: 	std::string s = duckdb_fmt::format("0x{:x}", input);
1380: 	return StringVector::AddString(vector, s);
1381: }
1382: 
1383: //===--------------------------------------------------------------------===//
1384: // Cast To Blob
1385: //===--------------------------------------------------------------------===//
1386: template <>
1387: bool TryCastToBlob::Operation(string_t input, string_t &result, Vector &result_vector, CastParameters &parameters) {
1388: 	idx_t result_size;
1389: 	if (!Blob::TryGetBlobSize(input, result_size, parameters)) {
1390: 		return false;
1391: 	}
1392: 
1393: 	result = StringVector::EmptyString(result_vector, result_size);
1394: 	Blob::ToBlob(input, data_ptr_cast(result.GetDataWriteable()));
1395: 	result.Finalize();
1396: 	return true;
1397: }
1398: 
1399: //===--------------------------------------------------------------------===//
1400: // Cast To Bit
1401: //===--------------------------------------------------------------------===//
1402: template <>
1403: bool TryCastToBit::Operation(string_t input, string_t &result, Vector &result_vector, CastParameters &parameters) {
1404: 	idx_t result_size;
1405: 	if (!Bit::TryGetBitStringSize(input, result_size, parameters.error_message)) {
1406: 		return false;
1407: 	}
1408: 
1409: 	result = StringVector::EmptyString(result_vector, result_size);
1410: 	Bit::ToBit(input, result);
1411: 	result.Finalize();
1412: 	return true;
1413: }
1414: 
1415: template <>
1416: bool CastFromBitToNumeric::Operation(string_t input, bool &result, CastParameters &parameters) {
1417: 	D_ASSERT(input.GetSize() > 1);
1418: 
1419: 	uint8_t value;
1420: 	bool success = CastFromBitToNumeric::Operation(input, value, parameters);
1421: 	result = (value > 0);
1422: 	return (success);
1423: }
1424: 
1425: template <>
1426: bool CastFromBitToNumeric::Operation(string_t input, hugeint_t &result, CastParameters &parameters) {
1427: 	D_ASSERT(input.GetSize() > 1);
1428: 
1429: 	if (input.GetSize() - 1 > sizeof(hugeint_t)) {
1430: 		throw ConversionException(parameters.query_location, "Bitstring doesn't fit inside of %s",
1431: 		                          GetTypeId<hugeint_t>());
1432: 	}
1433: 	Bit::BitToNumeric(input, result);
1434: 	return (true);
1435: }
1436: 
1437: template <>
1438: bool CastFromBitToNumeric::Operation(string_t input, uhugeint_t &result, CastParameters &parameters) {
1439: 	D_ASSERT(input.GetSize() > 1);
1440: 
1441: 	if (input.GetSize() - 1 > sizeof(uhugeint_t)) {
1442: 		throw ConversionException(parameters.query_location, "Bitstring doesn't fit inside of %s",
1443: 		                          GetTypeId<uhugeint_t>());
1444: 	}
1445: 	Bit::BitToNumeric(input, result);
1446: 	return (true);
1447: }
1448: 
1449: //===--------------------------------------------------------------------===//
1450: // Cast From UUID
1451: //===--------------------------------------------------------------------===//
1452: template <>
1453: string_t CastFromUUID::Operation(hugeint_t input, Vector &vector) {
1454: 	string_t result = StringVector::EmptyString(vector, 36);
1455: 	UUID::ToString(input, result.GetDataWriteable());
1456: 	result.Finalize();
1457: 	return result;
1458: }
1459: 
1460: //===--------------------------------------------------------------------===//
1461: // Cast To UUID
1462: //===--------------------------------------------------------------------===//
1463: template <>
1464: bool TryCastToUUID::Operation(string_t input, hugeint_t &result, Vector &result_vector, CastParameters &parameters) {
1465: 	return UUID::FromString(input.GetString(), result);
1466: }
1467: 
1468: //===--------------------------------------------------------------------===//
1469: // Cast To Date
1470: //===--------------------------------------------------------------------===//
1471: template <>
1472: bool TryCastErrorMessage::Operation(string_t input, date_t &result, CastParameters &parameters) {
1473: 	idx_t pos;
1474: 	bool special = false;
1475: 	switch (Date::TryConvertDate(input.GetData(), input.GetSize(), pos, result, special, parameters.strict)) {
1476: 	case DateCastResult::SUCCESS:
1477: 		break;
1478: 	case DateCastResult::ERROR_INCORRECT_FORMAT:
1479: 		HandleCastError::AssignError(Date::FormatError(input), parameters);
1480: 		return false;
1481: 	case DateCastResult::ERROR_RANGE:
1482: 		HandleCastError::AssignError(Date::RangeError(input), parameters);
1483: 		return false;
1484: 	}
1485: 	return true;
1486: }
1487: 
1488: template <>
1489: bool TryCast::Operation(string_t input, date_t &result, bool strict) {
1490: 	idx_t pos;
1491: 	bool special = false;
1492: 	return Date::TryConvertDate(input.GetData(), input.GetSize(), pos, result, special, strict) ==
1493: 	       DateCastResult::SUCCESS;
1494: }
1495: 
1496: template <>
1497: date_t Cast::Operation(string_t input) {
1498: 	return Date::FromCString(input.GetData(), input.GetSize());
1499: }
1500: 
1501: //===--------------------------------------------------------------------===//
1502: // Cast To Time
1503: //===--------------------------------------------------------------------===//
1504: template <>
1505: bool TryCastErrorMessage::Operation(string_t input, dtime_t &result, CastParameters &parameters) {
1506: 	if (!TryCast::Operation<string_t, dtime_t>(input, result, parameters.strict)) {
1507: 		HandleCastError::AssignError(Time::ConversionError(input), parameters);
1508: 		return false;
1509: 	}
1510: 	return true;
1511: }
1512: 
1513: template <>
1514: bool TryCast::Operation(string_t input, dtime_t &result, bool strict) {
1515: 	idx_t pos;
1516: 	return Time::TryConvertTime(input.GetData(), input.GetSize(), pos, result, strict);
1517: }
1518: 
1519: template <>
1520: dtime_t Cast::Operation(string_t input) {
1521: 	return Time::FromCString(input.GetData(), input.GetSize());
1522: }
1523: 
1524: //===--------------------------------------------------------------------===//
1525: // Cast To TimeTZ
1526: //===--------------------------------------------------------------------===//
1527: template <>
1528: bool TryCastErrorMessage::Operation(string_t input, dtime_tz_t &result, CastParameters &parameters) {
1529: 	if (!TryCast::Operation<string_t, dtime_tz_t>(input, result, parameters.strict)) {
1530: 		HandleCastError::AssignError(Time::ConversionError(input), parameters);
1531: 		return false;
1532: 	}
1533: 	return true;
1534: }
1535: 
1536: template <>
1537: bool TryCast::Operation(string_t input, dtime_tz_t &result, bool strict) {
1538: 	idx_t pos;
1539: 	bool has_offset;
1540: 	return Time::TryConvertTimeTZ(input.GetData(), input.GetSize(), pos, result, has_offset, strict);
1541: }
1542: 
1543: template <>
1544: dtime_tz_t Cast::Operation(string_t input) {
1545: 	dtime_tz_t result;
1546: 	if (!TryCast::Operation(input, result, false)) {
1547: 		throw ConversionException(Time::ConversionError(input));
1548: 	}
1549: 	return result;
1550: }
1551: 
1552: //===--------------------------------------------------------------------===//
1553: // Cast To Timestamp
1554: //===--------------------------------------------------------------------===//
1555: template <>
1556: bool TryCastErrorMessage::Operation(string_t input, timestamp_t &result, CastParameters &parameters) {
1557: 	switch (Timestamp::TryConvertTimestamp(input.GetData(), input.GetSize(), result)) {
1558: 	case TimestampCastResult::SUCCESS:
1559: 	case TimestampCastResult::STRICT_UTC:
1560: 		return true;
1561: 	case TimestampCastResult::ERROR_INCORRECT_FORMAT:
1562: 		HandleCastError::AssignError(Timestamp::FormatError(input), parameters);
1563: 		break;
1564: 	case TimestampCastResult::ERROR_NON_UTC_TIMEZONE:
1565: 		HandleCastError::AssignError(Timestamp::UnsupportedTimezoneError(input), parameters);
1566: 		break;
1567: 	case TimestampCastResult::ERROR_RANGE:
1568: 		HandleCastError::AssignError(Timestamp::RangeError(input), parameters);
1569: 		break;
1570: 	}
1571: 	return false;
1572: }
1573: 
1574: template <>
1575: bool TryCast::Operation(string_t input, timestamp_t &result, bool strict) {
1576: 	return Timestamp::TryConvertTimestamp(input.GetData(), input.GetSize(), result) == TimestampCastResult::SUCCESS;
1577: }
1578: 
1579: template <>
1580: bool TryCast::Operation(string_t input, timestamp_ns_t &result, bool strict) {
1581: 	return Timestamp::TryConvertTimestamp(input.GetData(), input.GetSize(), result) == TimestampCastResult::SUCCESS;
1582: }
1583: 
1584: template <>
1585: timestamp_t Cast::Operation(string_t input) {
1586: 	return Timestamp::FromCString(input.GetData(), input.GetSize());
1587: }
1588: 
1589: template <>
1590: timestamp_ns_t Cast::Operation(string_t input) {
1591: 	int32_t nanos;
1592: 	const auto ts = Timestamp::FromCString(input.GetData(), input.GetSize(), &nanos);
1593: 	timestamp_ns_t result;
1594: 	if (!Timestamp::TryFromTimestampNanos(ts, nanos, result)) {
1595: 		throw ConversionException(Timestamp::RangeError(input));
1596: 	}
1597: 	return result;
1598: }
1599: 
1600: //===--------------------------------------------------------------------===//
1601: // Cast From Interval
1602: //===--------------------------------------------------------------------===//
1603: template <>
1604: bool TryCastErrorMessage::Operation(string_t input, interval_t &result, CastParameters &parameters) {
1605: 	return Interval::FromCString(input.GetData(), input.GetSize(), result, parameters.error_message, parameters.strict);
1606: }
1607: 
1608: //===--------------------------------------------------------------------===//
1609: // Cast to hugeint / uhugeint
1610: //===--------------------------------------------------------------------===//
1611: // parsing hugeint from string is done a bit differently for performance reasons
1612: // for other integer types we keep track of a single value
1613: // and multiply that value by 10 for every digit we read
1614: // however, for hugeints, multiplication is very expensive (>20X as expensive as for int64)
1615: // for that reason, we parse numbers first into an int64 value
1616: // when that value is full, we perform a HUGEINT multiplication to flush it into the hugeint
1617: // this takes the number of HUGEINT multiplications down from [0-38] to [0-2]
1618: 
1619: template <typename T, typename OP, typename INTERMEDIATE_T>
1620: struct HugeIntCastData {
1621: 	using ResultType = T;
1622: 	using IntermediateType = INTERMEDIATE_T;
1623: 	using Operation = OP;
1624: 	ResultType result;
1625: 	IntermediateType intermediate;
1626: 	uint8_t digits;
1627: 
1628: 	ResultType decimal;
1629: 	uint16_t decimal_total_digits;
1630: 	ResultType decimal_intermediate;
1631: 	uint16_t decimal_intermediate_digits;
1632: 
1633: 	bool Flush() {
1634: 		if (digits == 0 && intermediate == 0) {
1635: 			return true;
1636: 		}
1637: 		if (result.lower != 0 || result.upper != 0) {
1638: 			if (digits > 38) {
1639: 				return false;
1640: 			}
1641: 			if (!OP::TryMultiply(result, OP::POWERS_OF_TEN[digits], result)) {
1642: 				return false;
1643: 			}
1644: 		}
1645: 		if (!OP::TryAddInPlace(result, ResultType(intermediate))) {
1646: 			return false;
1647: 		}
1648: 		digits = 0;
1649: 		intermediate = 0;
1650: 		return true;
1651: 	}
1652: 
1653: 	bool FlushDecimal() {
1654: 		if (decimal_intermediate_digits == 0 && decimal_intermediate == 0) {
1655: 			return true;
1656: 		}
1657: 		if (decimal.lower != 0 || decimal.upper != 0) {
1658: 			if (decimal_intermediate_digits > 38) {
1659: 				return false;
1660: 			}
1661: 			if (!OP::TryMultiply(decimal, OP::POWERS_OF_TEN[decimal_intermediate_digits], decimal)) {
1662: 				return false;
1663: 			}
1664: 		}
1665: 		if (!OP::TryAddInPlace(decimal, ResultType(decimal_intermediate))) {
1666: 			return false;
1667: 		}
1668: 		decimal_total_digits += decimal_intermediate_digits;
1669: 		decimal_intermediate_digits = 0;
1670: 		decimal_intermediate = 0;
1671: 		return true;
1672: 	}
1673: };
1674: 
1675: struct HugeIntegerCastOperation {
1676: 	template <class T, bool NEGATIVE>
1677: 	static bool HandleDigit(T &state, uint8_t digit) {
1678: 		if (NEGATIVE) {
1679: 			if (DUCKDB_UNLIKELY(state.intermediate <
1680: 			                    (NumericLimits<typename T::IntermediateType>::Minimum() + digit) / 10)) {
1681: 				// intermediate is full: need to flush it
1682: 				if (!state.Flush()) {
1683: 					return false;
1684: 				}
1685: 			}
1686: 			state.intermediate = state.intermediate * 10 - digit;
1687: 		} else {
1688: 			if (DUCKDB_UNLIKELY(state.intermediate >
1689: 			                    (NumericLimits<typename T::IntermediateType>::Maximum() - digit) / 10)) {
1690: 				if (!state.Flush()) {
1691: 					return false;
1692: 				}
1693: 			}
1694: 			state.intermediate = state.intermediate * 10 + digit;
1695: 		}
1696: 		state.digits++;
1697: 		return true;
1698: 	}
1699: 
1700: 	template <class T, bool NEGATIVE>
1701: 	static bool HandleHexDigit(T &state, uint8_t digit) {
1702: 		return false;
1703: 	}
1704: 
1705: 	template <class T, bool NEGATIVE>
1706: 	static bool HandleBinaryDigit(T &state, uint8_t digit) {
1707: 		return false;
1708: 	}
1709: 
1710: 	template <class T, bool NEGATIVE>
1711: 	static bool HandleExponent(T &state, int32_t exponent) {
1712: 		using result_t = typename T::ResultType;
1713: 		if (!state.Flush()) {
1714: 			return false;
1715: 		}
1716: 
1717: 		int32_t e = exponent;
1718: 		if (e < -38) {
1719: 			state.result = 0;
1720: 			return true;
1721: 		}
1722: 
1723: 		// Negative Exponent
1724: 		result_t remainder = 0;
1725: 		if (e < 0) {
1726: 			state.result = T::Operation::DivMod(state.result, T::Operation::POWERS_OF_TEN[-e], remainder);
1727: 			if (remainder < 0) {
1728: 				result_t negate_result;
1729: 				if (!T::Operation::TryNegate(remainder, negate_result)) {
1730: 					return false;
1731: 				}
1732: 				remainder = negate_result;
1733: 			}
1734: 			state.decimal = remainder;
1735: 			state.decimal_total_digits = static_cast<uint16_t>(-e);
1736: 			state.decimal_intermediate = 0;
1737: 			state.decimal_intermediate_digits = 0;
1738: 			return Finalize<T, NEGATIVE>(state);
1739: 		}
1740: 
1741: 		// Positive Exponent
1742: 		if (state.result != 0) {
1743: 			if (e > 38 || !TryMultiplyOperator::Operation(state.result, T::Operation::POWERS_OF_TEN[e], state.result)) {
1744: 				return false;
1745: 			}
1746: 		}
1747: 		if (!state.FlushDecimal()) {
1748: 			return false;
1749: 		}
1750: 		if (state.decimal == 0) {
1751: 			return Finalize<T, NEGATIVE>(state);
1752: 		}
1753: 
1754: 		e = exponent - state.decimal_total_digits;
1755: 		if (e < 0) {
1756: 			state.decimal = T::Operation::DivMod(state.decimal, T::Operation::POWERS_OF_TEN[-e], remainder);
1757: 			state.decimal_total_digits -= (exponent);
1758: 		} else {
1759: 			if (e > 38 ||
1760: 			    !TryMultiplyOperator::Operation(state.decimal, T::Operation::POWERS_OF_TEN[e], state.decimal)) {
1761: 				return false;
1762: 			}
1763: 		}
1764: 
1765: 		if (NEGATIVE) {
1766: 			if (!TrySubtractOperator::Operation(state.result, state.decimal, state.result)) {
1767: 				return false;
1768: 			}
1769: 		} else if (!TryAddOperator::Operation(state.result, state.decimal, state.result)) {
1770: 			return false;
1771: 		}
1772: 		state.decimal = remainder;
1773: 		return Finalize<T, NEGATIVE>(state);
1774: 	}
1775: 
1776: 	template <class T, bool NEGATIVE, bool ALLOW_EXPONENT>
1777: 	static bool HandleDecimal(T &state, uint8_t digit) {
1778: 		if (!state.Flush()) {
1779: 			return false;
1780: 		}
1781: 		if (DUCKDB_UNLIKELY(state.decimal_intermediate > (NumericLimits<int64_t>::Maximum() - digit) / 10)) {
1782: 			if (!state.FlushDecimal()) {
1783: 				return false;
1784: 			}
1785: 		}
1786: 		state.decimal_intermediate = state.decimal_intermediate * 10 + digit;
1787: 		state.decimal_intermediate_digits++;
1788: 		return true;
1789: 	}
1790: 
1791: 	template <class T, bool NEGATIVE>
1792: 	static bool Finalize(T &state) {
1793: 		using result_t = typename T::ResultType;
1794: 		if (!state.Flush() || !state.FlushDecimal()) {
1795: 			return false;
1796: 		}
1797: 
1798: 		if (state.decimal == 0 || state.decimal_total_digits == 0) {
1799: 			return true;
1800: 		}
1801: 
1802: 		// Get the first (left-most) digit of the decimals
1803: 		while (state.decimal_total_digits > 39) {
1804: 			state.decimal /= T::Operation::POWERS_OF_TEN[39];
1805: 			state.decimal_total_digits -= 39;
1806: 		}
1807: 		D_ASSERT((state.decimal_total_digits - 1) >= 0 && (state.decimal_total_digits - 1) <= 39);
1808: 		state.decimal /= T::Operation::POWERS_OF_TEN[state.decimal_total_digits - 1];
1809: 
1810: 		if (state.decimal >= 5) {
1811: 			if (NEGATIVE) {
1812: 				return TrySubtractOperator::Operation(state.result, result_t(1), state.result);
1813: 			} else {
1814: 				return TryAddOperator::Operation(state.result, result_t(1), state.result);
1815: 			}
1816: 		}
1817: 		return true;
1818: 	}
1819: };
1820: 
1821: template <>
1822: bool TryCast::Operation(string_t input, hugeint_t &result, bool strict) {
1823: 	HugeIntCastData<hugeint_t, Hugeint, int64_t> state {};
1824: 	if (!TryIntegerCast<HugeIntCastData<hugeint_t, Hugeint, int64_t>, true, true, HugeIntegerCastOperation>(
1825: 	        input.GetData(), input.GetSize(), state, strict)) {
1826: 		return false;
1827: 	}
1828: 	result = state.result;
1829: 	return true;
1830: }
1831: 
1832: template <>
1833: bool TryCast::Operation(string_t input, uhugeint_t &result, bool strict) {
1834: 	HugeIntCastData<uhugeint_t, Uhugeint, uint64_t> state {};
1835: 	if (!TryIntegerCast<HugeIntCastData<uhugeint_t, Uhugeint, uint64_t>, false, true, HugeIntegerCastOperation>(
1836: 	        input.GetData(), input.GetSize(), state, strict)) {
1837: 		return false;
1838: 	}
1839: 	result = state.result;
1840: 	return true;
1841: }
1842: 
1843: //===--------------------------------------------------------------------===//
1844: // Decimal String Cast
1845: //===--------------------------------------------------------------------===//
1846: 
1847: template <>
1848: bool TryCastToDecimal::Operation(string_t input, int16_t &result, CastParameters &parameters, uint8_t width,
1849:                                  uint8_t scale) {
1850: 	return TryDecimalStringCast<int16_t>(input, result, parameters, width, scale);
1851: }
1852: 
1853: template <>
1854: bool TryCastToDecimal::Operation(string_t input, int32_t &result, CastParameters &parameters, uint8_t width,
1855:                                  uint8_t scale) {
1856: 	return TryDecimalStringCast<int32_t>(input, result, parameters, width, scale);
1857: }
1858: 
1859: template <>
1860: bool TryCastToDecimal::Operation(string_t input, int64_t &result, CastParameters &parameters, uint8_t width,
1861:                                  uint8_t scale) {
1862: 	return TryDecimalStringCast<int64_t>(input, result, parameters, width, scale);
1863: }
1864: 
1865: template <>
1866: bool TryCastToDecimal::Operation(string_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
1867:                                  uint8_t scale) {
1868: 	return TryDecimalStringCast<hugeint_t>(input, result, parameters, width, scale);
1869: }
1870: 
1871: template <>
1872: bool TryCastToDecimalCommaSeparated::Operation(string_t input, int16_t &result, CastParameters &parameters,
1873:                                                uint8_t width, uint8_t scale) {
1874: 	return TryDecimalStringCast<int16_t, ','>(input, result, parameters, width, scale);
1875: }
1876: 
1877: template <>
1878: bool TryCastToDecimalCommaSeparated::Operation(string_t input, int32_t &result, CastParameters &parameters,
1879:                                                uint8_t width, uint8_t scale) {
1880: 	return TryDecimalStringCast<int32_t, ','>(input, result, parameters, width, scale);
1881: }
1882: 
1883: template <>
1884: bool TryCastToDecimalCommaSeparated::Operation(string_t input, int64_t &result, CastParameters &parameters,
1885:                                                uint8_t width, uint8_t scale) {
1886: 	return TryDecimalStringCast<int64_t, ','>(input, result, parameters, width, scale);
1887: }
1888: 
1889: template <>
1890: bool TryCastToDecimalCommaSeparated::Operation(string_t input, hugeint_t &result, CastParameters &parameters,
1891:                                                uint8_t width, uint8_t scale) {
1892: 	return TryDecimalStringCast<hugeint_t, ','>(input, result, parameters, width, scale);
1893: }
1894: 
1895: template <>
1896: string_t StringCastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale, Vector &result) {
1897: 	return DecimalToString::Format<int16_t>(input, width, scale, result);
1898: }
1899: 
1900: template <>
1901: string_t StringCastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale, Vector &result) {
1902: 	return DecimalToString::Format<int32_t>(input, width, scale, result);
1903: }
1904: 
1905: template <>
1906: string_t StringCastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale, Vector &result) {
1907: 	return DecimalToString::Format<int64_t>(input, width, scale, result);
1908: }
1909: 
1910: template <>
1911: string_t StringCastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale, Vector &result) {
1912: 	return DecimalToString::Format<hugeint_t>(input, width, scale, result);
1913: }
1914: 
1915: //===--------------------------------------------------------------------===//
1916: // Decimal Casts
1917: //===--------------------------------------------------------------------===//
1918: // Decimal <-> Bool
1919: //===--------------------------------------------------------------------===//
1920: template <class T, class OP = NumericHelper>
1921: bool TryCastBoolToDecimal(bool input, T &result, CastParameters &parameters, uint8_t width, uint8_t scale) {
1922: 	if (width > scale) {
1923: 		result = UnsafeNumericCast<T>(input ? OP::POWERS_OF_TEN[scale] : 0);
1924: 		return true;
1925: 	} else {
1926: 		return TryCast::Operation<bool, T>(input, result);
1927: 	}
1928: }
1929: 
1930: template <>
1931: bool TryCastToDecimal::Operation(bool input, int16_t &result, CastParameters &parameters, uint8_t width,
1932:                                  uint8_t scale) {
1933: 	return TryCastBoolToDecimal<int16_t>(input, result, parameters, width, scale);
1934: }
1935: 
1936: template <>
1937: bool TryCastToDecimal::Operation(bool input, int32_t &result, CastParameters &parameters, uint8_t width,
1938:                                  uint8_t scale) {
1939: 	return TryCastBoolToDecimal<int32_t>(input, result, parameters, width, scale);
1940: }
1941: 
1942: template <>
1943: bool TryCastToDecimal::Operation(bool input, int64_t &result, CastParameters &parameters, uint8_t width,
1944:                                  uint8_t scale) {
1945: 	return TryCastBoolToDecimal<int64_t>(input, result, parameters, width, scale);
1946: }
1947: 
1948: template <>
1949: bool TryCastToDecimal::Operation(bool input, hugeint_t &result, CastParameters &parameters, uint8_t width,
1950:                                  uint8_t scale) {
1951: 	return TryCastBoolToDecimal<hugeint_t, Hugeint>(input, result, parameters, width, scale);
1952: }
1953: 
1954: template <>
1955: bool TryCastFromDecimal::Operation(int16_t input, bool &result, CastParameters &parameters, uint8_t width,
1956:                                    uint8_t scale) {
1957: 	return TryCast::Operation<int16_t, bool>(input, result);
1958: }
1959: 
1960: template <>
1961: bool TryCastFromDecimal::Operation(int32_t input, bool &result, CastParameters &parameters, uint8_t width,
1962:                                    uint8_t scale) {
1963: 	return TryCast::Operation<int32_t, bool>(input, result);
1964: }
1965: 
1966: template <>
1967: bool TryCastFromDecimal::Operation(int64_t input, bool &result, CastParameters &parameters, uint8_t width,
1968:                                    uint8_t scale) {
1969: 	return TryCast::Operation<int64_t, bool>(input, result);
1970: }
1971: 
1972: template <>
1973: bool TryCastFromDecimal::Operation(hugeint_t input, bool &result, CastParameters &parameters, uint8_t width,
1974:                                    uint8_t scale) {
1975: 	return TryCast::Operation<hugeint_t, bool>(input, result);
1976: }
1977: 
1978: //===--------------------------------------------------------------------===//
1979: // Numeric -> Decimal Cast
1980: //===--------------------------------------------------------------------===//
1981: struct SignedToDecimalOperator {
1982: 	template <class SRC, class DST>
1983: 	static bool Operation(SRC input, DST max_width) {
1984: 		return int64_t(input) >= int64_t(max_width) || int64_t(input) <= int64_t(-max_width);
1985: 	}
1986: };
1987: 
1988: struct UnsignedToDecimalOperator {
1989: 	template <class SRC, class DST>
1990: 	static bool Operation(SRC input, DST max_width) {
1991: 		return uint64_t(input) >= uint64_t(max_width);
1992: 	}
1993: };
1994: 
1995: template <class SRC, class DST, class OP = SignedToDecimalOperator>
1996: bool StandardNumericToDecimalCast(SRC input, DST &result, CastParameters &parameters, uint8_t width, uint8_t scale) {
1997: 	// check for overflow
1998: 	DST max_width = UnsafeNumericCast<DST>(NumericHelper::POWERS_OF_TEN[width - scale]);
1999: 	if (OP::template Operation<SRC, DST>(input, max_width)) {
2000: 		string error = StringUtil::Format("Could not cast value %d to DECIMAL(%d,%d)", input, width, scale);
2001: 		HandleCastError::AssignError(error, parameters);
2002: 		return false;
2003: 	}
2004: 	result = UnsafeNumericCast<DST>(DST(input) * NumericHelper::POWERS_OF_TEN[scale]);
2005: 	return true;
2006: }
2007: 
2008: template <class SRC>
2009: bool NumericToHugeDecimalCast(SRC input, hugeint_t &result, CastParameters &parameters, uint8_t width, uint8_t scale) {
2010: 	// check for overflow
2011: 	hugeint_t max_width = Hugeint::POWERS_OF_TEN[width - scale];
2012: 	hugeint_t hinput = Hugeint::Convert(input);
2013: 	if (hinput >= max_width || hinput <= -max_width) {
2014: 		string error = StringUtil::Format("Could not cast value %s to DECIMAL(%d,%d)", hinput.ToString(), width, scale);
2015: 		HandleCastError::AssignError(error, parameters);
2016: 		return false;
2017: 	}
2018: 	result = hinput * Hugeint::POWERS_OF_TEN[scale];
2019: 	return true;
2020: }
2021: 
2022: //===--------------------------------------------------------------------===//
2023: // Cast int8_t -> Decimal
2024: //===--------------------------------------------------------------------===//
2025: template <>
2026: bool TryCastToDecimal::Operation(int8_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2027:                                  uint8_t scale) {
2028: 	return StandardNumericToDecimalCast<int8_t, int16_t>(input, result, parameters, width, scale);
2029: }
2030: template <>
2031: bool TryCastToDecimal::Operation(int8_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2032:                                  uint8_t scale) {
2033: 	return StandardNumericToDecimalCast<int8_t, int32_t>(input, result, parameters, width, scale);
2034: }
2035: template <>
2036: bool TryCastToDecimal::Operation(int8_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2037:                                  uint8_t scale) {
2038: 	return StandardNumericToDecimalCast<int8_t, int64_t>(input, result, parameters, width, scale);
2039: }
2040: template <>
2041: bool TryCastToDecimal::Operation(int8_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2042:                                  uint8_t scale) {
2043: 	return NumericToHugeDecimalCast<int8_t>(input, result, parameters, width, scale);
2044: }
2045: 
2046: //===--------------------------------------------------------------------===//
2047: // Cast int16_t -> Decimal
2048: //===--------------------------------------------------------------------===//
2049: template <>
2050: bool TryCastToDecimal::Operation(int16_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2051:                                  uint8_t scale) {
2052: 	return StandardNumericToDecimalCast<int16_t, int16_t>(input, result, parameters, width, scale);
2053: }
2054: template <>
2055: bool TryCastToDecimal::Operation(int16_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2056:                                  uint8_t scale) {
2057: 	return StandardNumericToDecimalCast<int16_t, int32_t>(input, result, parameters, width, scale);
2058: }
2059: template <>
2060: bool TryCastToDecimal::Operation(int16_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2061:                                  uint8_t scale) {
2062: 	return StandardNumericToDecimalCast<int16_t, int64_t>(input, result, parameters, width, scale);
2063: }
2064: template <>
2065: bool TryCastToDecimal::Operation(int16_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2066:                                  uint8_t scale) {
2067: 	return NumericToHugeDecimalCast<int16_t>(input, result, parameters, width, scale);
2068: }
2069: 
2070: //===--------------------------------------------------------------------===//
2071: // Cast int32_t -> Decimal
2072: //===--------------------------------------------------------------------===//
2073: template <>
2074: bool TryCastToDecimal::Operation(int32_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2075:                                  uint8_t scale) {
2076: 	return StandardNumericToDecimalCast<int32_t, int16_t>(input, result, parameters, width, scale);
2077: }
2078: template <>
2079: bool TryCastToDecimal::Operation(int32_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2080:                                  uint8_t scale) {
2081: 	return StandardNumericToDecimalCast<int32_t, int32_t>(input, result, parameters, width, scale);
2082: }
2083: template <>
2084: bool TryCastToDecimal::Operation(int32_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2085:                                  uint8_t scale) {
2086: 	return StandardNumericToDecimalCast<int32_t, int64_t>(input, result, parameters, width, scale);
2087: }
2088: template <>
2089: bool TryCastToDecimal::Operation(int32_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2090:                                  uint8_t scale) {
2091: 	return NumericToHugeDecimalCast<int32_t>(input, result, parameters, width, scale);
2092: }
2093: 
2094: //===--------------------------------------------------------------------===//
2095: // Cast int64_t -> Decimal
2096: //===--------------------------------------------------------------------===//
2097: template <>
2098: bool TryCastToDecimal::Operation(int64_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2099:                                  uint8_t scale) {
2100: 	return StandardNumericToDecimalCast<int64_t, int16_t>(input, result, parameters, width, scale);
2101: }
2102: template <>
2103: bool TryCastToDecimal::Operation(int64_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2104:                                  uint8_t scale) {
2105: 	return StandardNumericToDecimalCast<int64_t, int32_t>(input, result, parameters, width, scale);
2106: }
2107: template <>
2108: bool TryCastToDecimal::Operation(int64_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2109:                                  uint8_t scale) {
2110: 	return StandardNumericToDecimalCast<int64_t, int64_t>(input, result, parameters, width, scale);
2111: }
2112: template <>
2113: bool TryCastToDecimal::Operation(int64_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2114:                                  uint8_t scale) {
2115: 	return NumericToHugeDecimalCast<int64_t>(input, result, parameters, width, scale);
2116: }
2117: 
2118: //===--------------------------------------------------------------------===//
2119: // Cast uint8_t -> Decimal
2120: //===--------------------------------------------------------------------===//
2121: template <>
2122: bool TryCastToDecimal::Operation(uint8_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2123:                                  uint8_t scale) {
2124: 	return StandardNumericToDecimalCast<uint8_t, int16_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2125: 	                                                                                 scale);
2126: }
2127: template <>
2128: bool TryCastToDecimal::Operation(uint8_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2129:                                  uint8_t scale) {
2130: 	return StandardNumericToDecimalCast<uint8_t, int32_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2131: 	                                                                                 scale);
2132: }
2133: template <>
2134: bool TryCastToDecimal::Operation(uint8_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2135:                                  uint8_t scale) {
2136: 	return StandardNumericToDecimalCast<uint8_t, int64_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2137: 	                                                                                 scale);
2138: }
2139: template <>
2140: bool TryCastToDecimal::Operation(uint8_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2141:                                  uint8_t scale) {
2142: 	return NumericToHugeDecimalCast<uint8_t>(input, result, parameters, width, scale);
2143: }
2144: 
2145: //===--------------------------------------------------------------------===//
2146: // Cast uint16_t -> Decimal
2147: //===--------------------------------------------------------------------===//
2148: template <>
2149: bool TryCastToDecimal::Operation(uint16_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2150:                                  uint8_t scale) {
2151: 	return StandardNumericToDecimalCast<uint16_t, int16_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2152: 	                                                                                  scale);
2153: }
2154: template <>
2155: bool TryCastToDecimal::Operation(uint16_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2156:                                  uint8_t scale) {
2157: 	return StandardNumericToDecimalCast<uint16_t, int32_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2158: 	                                                                                  scale);
2159: }
2160: template <>
2161: bool TryCastToDecimal::Operation(uint16_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2162:                                  uint8_t scale) {
2163: 	return StandardNumericToDecimalCast<uint16_t, int64_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2164: 	                                                                                  scale);
2165: }
2166: template <>
2167: bool TryCastToDecimal::Operation(uint16_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2168:                                  uint8_t scale) {
2169: 	return NumericToHugeDecimalCast<uint16_t>(input, result, parameters, width, scale);
2170: }
2171: 
2172: //===--------------------------------------------------------------------===//
2173: // Cast uint32_t -> Decimal
2174: //===--------------------------------------------------------------------===//
2175: template <>
2176: bool TryCastToDecimal::Operation(uint32_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2177:                                  uint8_t scale) {
2178: 	return StandardNumericToDecimalCast<uint32_t, int16_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2179: 	                                                                                  scale);
2180: }
2181: template <>
2182: bool TryCastToDecimal::Operation(uint32_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2183:                                  uint8_t scale) {
2184: 	return StandardNumericToDecimalCast<uint32_t, int32_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2185: 	                                                                                  scale);
2186: }
2187: template <>
2188: bool TryCastToDecimal::Operation(uint32_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2189:                                  uint8_t scale) {
2190: 	return StandardNumericToDecimalCast<uint32_t, int64_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2191: 	                                                                                  scale);
2192: }
2193: template <>
2194: bool TryCastToDecimal::Operation(uint32_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2195:                                  uint8_t scale) {
2196: 	return NumericToHugeDecimalCast<uint32_t>(input, result, parameters, width, scale);
2197: }
2198: 
2199: //===--------------------------------------------------------------------===//
2200: // Cast uint64_t -> Decimal
2201: //===--------------------------------------------------------------------===//
2202: template <>
2203: bool TryCastToDecimal::Operation(uint64_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2204:                                  uint8_t scale) {
2205: 	return StandardNumericToDecimalCast<uint64_t, int16_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2206: 	                                                                                  scale);
2207: }
2208: template <>
2209: bool TryCastToDecimal::Operation(uint64_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2210:                                  uint8_t scale) {
2211: 	return StandardNumericToDecimalCast<uint64_t, int32_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2212: 	                                                                                  scale);
2213: }
2214: template <>
2215: bool TryCastToDecimal::Operation(uint64_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2216:                                  uint8_t scale) {
2217: 	return StandardNumericToDecimalCast<uint64_t, int64_t, UnsignedToDecimalOperator>(input, result, parameters, width,
2218: 	                                                                                  scale);
2219: }
2220: template <>
2221: bool TryCastToDecimal::Operation(uint64_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2222:                                  uint8_t scale) {
2223: 	return NumericToHugeDecimalCast<uint64_t>(input, result, parameters, width, scale);
2224: }
2225: 
2226: //===--------------------------------------------------------------------===//
2227: // Hugeint -> Decimal Cast
2228: //===--------------------------------------------------------------------===//
2229: template <class DST>
2230: bool HugeintToDecimalCast(hugeint_t input, DST &result, CastParameters &parameters, uint8_t width, uint8_t scale) {
2231: 	// check for overflow
2232: 	hugeint_t max_width = Hugeint::POWERS_OF_TEN[width - scale];
2233: 	if (input >= max_width || input <= -max_width) {
2234: 		string error = StringUtil::Format("Could not cast value %s to DECIMAL(%d,%d)", input.ToString(), width, scale);
2235: 		HandleCastError::AssignError(error, parameters);
2236: 		return false;
2237: 	}
2238: 	result = Hugeint::Cast<DST>(input * Hugeint::POWERS_OF_TEN[scale]);
2239: 	return true;
2240: }
2241: 
2242: template <>
2243: bool TryCastToDecimal::Operation(hugeint_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2244:                                  uint8_t scale) {
2245: 	return HugeintToDecimalCast<int16_t>(input, result, parameters, width, scale);
2246: }
2247: 
2248: template <>
2249: bool TryCastToDecimal::Operation(hugeint_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2250:                                  uint8_t scale) {
2251: 	return HugeintToDecimalCast<int32_t>(input, result, parameters, width, scale);
2252: }
2253: 
2254: template <>
2255: bool TryCastToDecimal::Operation(hugeint_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2256:                                  uint8_t scale) {
2257: 	return HugeintToDecimalCast<int64_t>(input, result, parameters, width, scale);
2258: }
2259: 
2260: template <>
2261: bool TryCastToDecimal::Operation(hugeint_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2262:                                  uint8_t scale) {
2263: 	return HugeintToDecimalCast<hugeint_t>(input, result, parameters, width, scale);
2264: }
2265: 
2266: //===--------------------------------------------------------------------===//
2267: // Uhugeint -> Decimal Cast
2268: //===--------------------------------------------------------------------===//
2269: template <class DST>
2270: bool UhugeintToDecimalCast(uhugeint_t input, DST &result, CastParameters &parameters, uint8_t width, uint8_t scale) {
2271: 	// check for overflow
2272: 	uhugeint_t max_width = Uhugeint::POWERS_OF_TEN[width - scale];
2273: 	if (input >= max_width) {
2274: 		string error = StringUtil::Format("Could not cast value %s to DECIMAL(%d,%d)", input.ToString(), width, scale);
2275: 		HandleCastError::AssignError(error, parameters);
2276: 		return false;
2277: 	}
2278: 	result = Uhugeint::Cast<DST>(input * Uhugeint::POWERS_OF_TEN[scale]);
2279: 	return true;
2280: }
2281: 
2282: template <>
2283: bool TryCastToDecimal::Operation(uhugeint_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2284:                                  uint8_t scale) {
2285: 	return UhugeintToDecimalCast<int16_t>(input, result, parameters, width, scale);
2286: }
2287: 
2288: template <>
2289: bool TryCastToDecimal::Operation(uhugeint_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2290:                                  uint8_t scale) {
2291: 	return UhugeintToDecimalCast<int32_t>(input, result, parameters, width, scale);
2292: }
2293: 
2294: template <>
2295: bool TryCastToDecimal::Operation(uhugeint_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2296:                                  uint8_t scale) {
2297: 	return UhugeintToDecimalCast<int64_t>(input, result, parameters, width, scale);
2298: }
2299: 
2300: template <>
2301: bool TryCastToDecimal::Operation(uhugeint_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2302:                                  uint8_t scale) {
2303: 	return UhugeintToDecimalCast<hugeint_t>(input, result, parameters, width, scale);
2304: }
2305: 
2306: //===--------------------------------------------------------------------===//
2307: // Float/Double -> Decimal Cast
2308: //===--------------------------------------------------------------------===//
2309: template <class SRC, class DST>
2310: bool DoubleToDecimalCast(SRC input, DST &result, CastParameters &parameters, uint8_t width, uint8_t scale) {
2311: 	double value = input * NumericHelper::DOUBLE_POWERS_OF_TEN[scale];
2312: 	double roundedValue = round(value);
2313: 	if (roundedValue <= -NumericHelper::DOUBLE_POWERS_OF_TEN[width] ||
2314: 	    roundedValue >= NumericHelper::DOUBLE_POWERS_OF_TEN[width]) {
2315: 		string error = StringUtil::Format("Could not cast value %f to DECIMAL(%d,%d)", input, width, scale);
2316: 		HandleCastError::AssignError(error, parameters);
2317: 		return false;
2318: 	}
2319: 	result = Cast::Operation<SRC, DST>(static_cast<SRC>(value));
2320: 	return true;
2321: }
2322: 
2323: template <>
2324: bool TryCastToDecimal::Operation(float input, int16_t &result, CastParameters &parameters, uint8_t width,
2325:                                  uint8_t scale) {
2326: 	return DoubleToDecimalCast<float, int16_t>(input, result, parameters, width, scale);
2327: }
2328: 
2329: template <>
2330: bool TryCastToDecimal::Operation(float input, int32_t &result, CastParameters &parameters, uint8_t width,
2331:                                  uint8_t scale) {
2332: 	return DoubleToDecimalCast<float, int32_t>(input, result, parameters, width, scale);
2333: }
2334: 
2335: template <>
2336: bool TryCastToDecimal::Operation(float input, int64_t &result, CastParameters &parameters, uint8_t width,
2337:                                  uint8_t scale) {
2338: 	return DoubleToDecimalCast<float, int64_t>(input, result, parameters, width, scale);
2339: }
2340: 
2341: template <>
2342: bool TryCastToDecimal::Operation(float input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2343:                                  uint8_t scale) {
2344: 	return DoubleToDecimalCast<float, hugeint_t>(input, result, parameters, width, scale);
2345: }
2346: 
2347: template <>
2348: bool TryCastToDecimal::Operation(double input, int16_t &result, CastParameters &parameters, uint8_t width,
2349:                                  uint8_t scale) {
2350: 	return DoubleToDecimalCast<double, int16_t>(input, result, parameters, width, scale);
2351: }
2352: 
2353: template <>
2354: bool TryCastToDecimal::Operation(double input, int32_t &result, CastParameters &parameters, uint8_t width,
2355:                                  uint8_t scale) {
2356: 	return DoubleToDecimalCast<double, int32_t>(input, result, parameters, width, scale);
2357: }
2358: 
2359: template <>
2360: bool TryCastToDecimal::Operation(double input, int64_t &result, CastParameters &parameters, uint8_t width,
2361:                                  uint8_t scale) {
2362: 	return DoubleToDecimalCast<double, int64_t>(input, result, parameters, width, scale);
2363: }
2364: 
2365: template <>
2366: bool TryCastToDecimal::Operation(double input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2367:                                  uint8_t scale) {
2368: 	return DoubleToDecimalCast<double, hugeint_t>(input, result, parameters, width, scale);
2369: }
2370: 
2371: //===--------------------------------------------------------------------===//
2372: // Decimal -> Numeric Cast
2373: //===--------------------------------------------------------------------===//
2374: template <class SRC, class DST>
2375: bool TryCastDecimalToNumeric(SRC input, DST &result, CastParameters &parameters, uint8_t scale) {
2376: 	// Round away from 0.
2377: 	const auto power = NumericHelper::POWERS_OF_TEN[scale];
2378: 	// https://graphics.stanford.edu/~seander/bithacks.html#ConditionalNegate
2379: 	const auto fNegate = int64_t(input < 0);
2380: 	const auto rounding = ((power ^ -fNegate) + fNegate) / 2;
2381: 	const auto scaled_value = (input + rounding) / power;
2382: 	if (!TryCast::Operation<SRC, DST>(UnsafeNumericCast<SRC>(scaled_value), result)) {
2383: 		string error = StringUtil::Format("Failed to cast decimal value %d to type %s", scaled_value, GetTypeId<DST>());
2384: 		HandleCastError::AssignError(error, parameters);
2385: 		return false;
2386: 	}
2387: 	return true;
2388: }
2389: 
2390: template <class DST>
2391: bool TryCastHugeDecimalToNumeric(hugeint_t input, DST &result, CastParameters &parameters, uint8_t scale) {
2392: 	const auto power = Hugeint::POWERS_OF_TEN[scale];
2393: 	const auto rounding = ((input < 0) ? -power : power) / 2;
2394: 	auto scaled_value = (input + rounding) / power;
2395: 	if (!TryCast::Operation<hugeint_t, DST>(scaled_value, result)) {
2396: 		string error = StringUtil::Format("Failed to cast decimal value %s to type %s",
2397: 		                                  ConvertToString::Operation(scaled_value), GetTypeId<DST>());
2398: 		HandleCastError::AssignError(error, parameters);
2399: 		return false;
2400: 	}
2401: 	return true;
2402: }
2403: 
2404: //===--------------------------------------------------------------------===//
2405: // Cast Decimal -> int8_t
2406: //===--------------------------------------------------------------------===//
2407: template <>
2408: bool TryCastFromDecimal::Operation(int16_t input, int8_t &result, CastParameters &parameters, uint8_t width,
2409:                                    uint8_t scale) {
2410: 	return TryCastDecimalToNumeric<int16_t, int8_t>(input, result, parameters, scale);
2411: }
2412: template <>
2413: bool TryCastFromDecimal::Operation(int32_t input, int8_t &result, CastParameters &parameters, uint8_t width,
2414:                                    uint8_t scale) {
2415: 	return TryCastDecimalToNumeric<int32_t, int8_t>(input, result, parameters, scale);
2416: }
2417: template <>
2418: bool TryCastFromDecimal::Operation(int64_t input, int8_t &result, CastParameters &parameters, uint8_t width,
2419:                                    uint8_t scale) {
2420: 	return TryCastDecimalToNumeric<int64_t, int8_t>(input, result, parameters, scale);
2421: }
2422: template <>
2423: bool TryCastFromDecimal::Operation(hugeint_t input, int8_t &result, CastParameters &parameters, uint8_t width,
2424:                                    uint8_t scale) {
2425: 	return TryCastHugeDecimalToNumeric<int8_t>(input, result, parameters, scale);
2426: }
2427: 
2428: //===--------------------------------------------------------------------===//
2429: // Cast Decimal -> int16_t
2430: //===--------------------------------------------------------------------===//
2431: template <>
2432: bool TryCastFromDecimal::Operation(int16_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2433:                                    uint8_t scale) {
2434: 	return TryCastDecimalToNumeric<int16_t, int16_t>(input, result, parameters, scale);
2435: }
2436: template <>
2437: bool TryCastFromDecimal::Operation(int32_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2438:                                    uint8_t scale) {
2439: 	return TryCastDecimalToNumeric<int32_t, int16_t>(input, result, parameters, scale);
2440: }
2441: template <>
2442: bool TryCastFromDecimal::Operation(int64_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2443:                                    uint8_t scale) {
2444: 	return TryCastDecimalToNumeric<int64_t, int16_t>(input, result, parameters, scale);
2445: }
2446: template <>
2447: bool TryCastFromDecimal::Operation(hugeint_t input, int16_t &result, CastParameters &parameters, uint8_t width,
2448:                                    uint8_t scale) {
2449: 	return TryCastHugeDecimalToNumeric<int16_t>(input, result, parameters, scale);
2450: }
2451: 
2452: //===--------------------------------------------------------------------===//
2453: // Cast Decimal -> int32_t
2454: //===--------------------------------------------------------------------===//
2455: template <>
2456: bool TryCastFromDecimal::Operation(int16_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2457:                                    uint8_t scale) {
2458: 	return TryCastDecimalToNumeric<int16_t, int32_t>(input, result, parameters, scale);
2459: }
2460: template <>
2461: bool TryCastFromDecimal::Operation(int32_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2462:                                    uint8_t scale) {
2463: 	return TryCastDecimalToNumeric<int32_t, int32_t>(input, result, parameters, scale);
2464: }
2465: template <>
2466: bool TryCastFromDecimal::Operation(int64_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2467:                                    uint8_t scale) {
2468: 	return TryCastDecimalToNumeric<int64_t, int32_t>(input, result, parameters, scale);
2469: }
2470: template <>
2471: bool TryCastFromDecimal::Operation(hugeint_t input, int32_t &result, CastParameters &parameters, uint8_t width,
2472:                                    uint8_t scale) {
2473: 	return TryCastHugeDecimalToNumeric<int32_t>(input, result, parameters, scale);
2474: }
2475: 
2476: //===--------------------------------------------------------------------===//
2477: // Cast Decimal -> int64_t
2478: //===--------------------------------------------------------------------===//
2479: template <>
2480: bool TryCastFromDecimal::Operation(int16_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2481:                                    uint8_t scale) {
2482: 	return TryCastDecimalToNumeric<int16_t, int64_t>(input, result, parameters, scale);
2483: }
2484: template <>
2485: bool TryCastFromDecimal::Operation(int32_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2486:                                    uint8_t scale) {
2487: 	return TryCastDecimalToNumeric<int32_t, int64_t>(input, result, parameters, scale);
2488: }
2489: template <>
2490: bool TryCastFromDecimal::Operation(int64_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2491:                                    uint8_t scale) {
2492: 	return TryCastDecimalToNumeric<int64_t, int64_t>(input, result, parameters, scale);
2493: }
2494: template <>
2495: bool TryCastFromDecimal::Operation(hugeint_t input, int64_t &result, CastParameters &parameters, uint8_t width,
2496:                                    uint8_t scale) {
2497: 	return TryCastHugeDecimalToNumeric<int64_t>(input, result, parameters, scale);
2498: }
2499: 
2500: //===--------------------------------------------------------------------===//
2501: // Cast Decimal -> uint8_t
2502: //===--------------------------------------------------------------------===//
2503: template <>
2504: bool TryCastFromDecimal::Operation(int16_t input, uint8_t &result, CastParameters &parameters, uint8_t width,
2505:                                    uint8_t scale) {
2506: 	return TryCastDecimalToNumeric<int16_t, uint8_t>(input, result, parameters, scale);
2507: }
2508: template <>
2509: bool TryCastFromDecimal::Operation(int32_t input, uint8_t &result, CastParameters &parameters, uint8_t width,
2510:                                    uint8_t scale) {
2511: 	return TryCastDecimalToNumeric<int32_t, uint8_t>(input, result, parameters, scale);
2512: }
2513: template <>
2514: bool TryCastFromDecimal::Operation(int64_t input, uint8_t &result, CastParameters &parameters, uint8_t width,
2515:                                    uint8_t scale) {
2516: 	return TryCastDecimalToNumeric<int64_t, uint8_t>(input, result, parameters, scale);
2517: }
2518: template <>
2519: bool TryCastFromDecimal::Operation(hugeint_t input, uint8_t &result, CastParameters &parameters, uint8_t width,
2520:                                    uint8_t scale) {
2521: 	return TryCastHugeDecimalToNumeric<uint8_t>(input, result, parameters, scale);
2522: }
2523: 
2524: //===--------------------------------------------------------------------===//
2525: // Cast Decimal -> uint16_t
2526: //===--------------------------------------------------------------------===//
2527: template <>
2528: bool TryCastFromDecimal::Operation(int16_t input, uint16_t &result, CastParameters &parameters, uint8_t width,
2529:                                    uint8_t scale) {
2530: 	return TryCastDecimalToNumeric<int16_t, uint16_t>(input, result, parameters, scale);
2531: }
2532: template <>
2533: bool TryCastFromDecimal::Operation(int32_t input, uint16_t &result, CastParameters &parameters, uint8_t width,
2534:                                    uint8_t scale) {
2535: 	return TryCastDecimalToNumeric<int32_t, uint16_t>(input, result, parameters, scale);
2536: }
2537: template <>
2538: bool TryCastFromDecimal::Operation(int64_t input, uint16_t &result, CastParameters &parameters, uint8_t width,
2539:                                    uint8_t scale) {
2540: 	return TryCastDecimalToNumeric<int64_t, uint16_t>(input, result, parameters, scale);
2541: }
2542: template <>
2543: bool TryCastFromDecimal::Operation(hugeint_t input, uint16_t &result, CastParameters &parameters, uint8_t width,
2544:                                    uint8_t scale) {
2545: 	return TryCastHugeDecimalToNumeric<uint16_t>(input, result, parameters, scale);
2546: }
2547: 
2548: //===--------------------------------------------------------------------===//
2549: // Cast Decimal -> uint32_t
2550: //===--------------------------------------------------------------------===//
2551: template <>
2552: bool TryCastFromDecimal::Operation(int16_t input, uint32_t &result, CastParameters &parameters, uint8_t width,
2553:                                    uint8_t scale) {
2554: 	return TryCastDecimalToNumeric<int16_t, uint32_t>(input, result, parameters, scale);
2555: }
2556: template <>
2557: bool TryCastFromDecimal::Operation(int32_t input, uint32_t &result, CastParameters &parameters, uint8_t width,
2558:                                    uint8_t scale) {
2559: 	return TryCastDecimalToNumeric<int32_t, uint32_t>(input, result, parameters, scale);
2560: }
2561: template <>
2562: bool TryCastFromDecimal::Operation(int64_t input, uint32_t &result, CastParameters &parameters, uint8_t width,
2563:                                    uint8_t scale) {
2564: 	return TryCastDecimalToNumeric<int64_t, uint32_t>(input, result, parameters, scale);
2565: }
2566: template <>
2567: bool TryCastFromDecimal::Operation(hugeint_t input, uint32_t &result, CastParameters &parameters, uint8_t width,
2568:                                    uint8_t scale) {
2569: 	return TryCastHugeDecimalToNumeric<uint32_t>(input, result, parameters, scale);
2570: }
2571: 
2572: //===--------------------------------------------------------------------===//
2573: // Cast Decimal -> uint64_t
2574: //===--------------------------------------------------------------------===//
2575: template <>
2576: bool TryCastFromDecimal::Operation(int16_t input, uint64_t &result, CastParameters &parameters, uint8_t width,
2577:                                    uint8_t scale) {
2578: 	return TryCastDecimalToNumeric<int16_t, uint64_t>(input, result, parameters, scale);
2579: }
2580: template <>
2581: bool TryCastFromDecimal::Operation(int32_t input, uint64_t &result, CastParameters &parameters, uint8_t width,
2582:                                    uint8_t scale) {
2583: 	return TryCastDecimalToNumeric<int32_t, uint64_t>(input, result, parameters, scale);
2584: }
2585: template <>
2586: bool TryCastFromDecimal::Operation(int64_t input, uint64_t &result, CastParameters &parameters, uint8_t width,
2587:                                    uint8_t scale) {
2588: 	return TryCastDecimalToNumeric<int64_t, uint64_t>(input, result, parameters, scale);
2589: }
2590: template <>
2591: bool TryCastFromDecimal::Operation(hugeint_t input, uint64_t &result, CastParameters &parameters, uint8_t width,
2592:                                    uint8_t scale) {
2593: 	return TryCastHugeDecimalToNumeric<uint64_t>(input, result, parameters, scale);
2594: }
2595: 
2596: //===--------------------------------------------------------------------===//
2597: // Cast Decimal -> hugeint_t
2598: //===--------------------------------------------------------------------===//
2599: template <>
2600: bool TryCastFromDecimal::Operation(int16_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2601:                                    uint8_t scale) {
2602: 	return TryCastDecimalToNumeric<int16_t, hugeint_t>(input, result, parameters, scale);
2603: }
2604: template <>
2605: bool TryCastFromDecimal::Operation(int32_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2606:                                    uint8_t scale) {
2607: 	return TryCastDecimalToNumeric<int32_t, hugeint_t>(input, result, parameters, scale);
2608: }
2609: template <>
2610: bool TryCastFromDecimal::Operation(int64_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2611:                                    uint8_t scale) {
2612: 	return TryCastDecimalToNumeric<int64_t, hugeint_t>(input, result, parameters, scale);
2613: }
2614: template <>
2615: bool TryCastFromDecimal::Operation(hugeint_t input, hugeint_t &result, CastParameters &parameters, uint8_t width,
2616:                                    uint8_t scale) {
2617: 	return TryCastHugeDecimalToNumeric<hugeint_t>(input, result, parameters, scale);
2618: }
2619: 
2620: //===--------------------------------------------------------------------===//
2621: // Cast Decimal -> uhugeint_t
2622: //===--------------------------------------------------------------------===//
2623: template <>
2624: bool TryCastFromDecimal::Operation(int16_t input, uhugeint_t &result, CastParameters &parameters, uint8_t width,
2625:                                    uint8_t scale) {
2626: 	return TryCastDecimalToNumeric<int16_t, uhugeint_t>(input, result, parameters, scale);
2627: }
2628: template <>
2629: bool TryCastFromDecimal::Operation(int32_t input, uhugeint_t &result, CastParameters &parameters, uint8_t width,
2630:                                    uint8_t scale) {
2631: 	return TryCastDecimalToNumeric<int32_t, uhugeint_t>(input, result, parameters, scale);
2632: }
2633: template <>
2634: bool TryCastFromDecimal::Operation(int64_t input, uhugeint_t &result, CastParameters &parameters, uint8_t width,
2635:                                    uint8_t scale) {
2636: 	return TryCastDecimalToNumeric<int64_t, uhugeint_t>(input, result, parameters, scale);
2637: }
2638: template <>
2639: bool TryCastFromDecimal::Operation(hugeint_t input, uhugeint_t &result, CastParameters &parameters, uint8_t width,
2640:                                    uint8_t scale) {
2641: 	return TryCastHugeDecimalToNumeric<uhugeint_t>(input, result, parameters, scale);
2642: }
2643: 
2644: //===--------------------------------------------------------------------===//
2645: // Decimal -> Float/Double Cast
2646: //===--------------------------------------------------------------------===//
2647: template <class SRC, class DST>
2648: static bool IsRepresentableExactly(SRC input, DST);
2649: 
2650: template <>
2651: bool IsRepresentableExactly(int16_t input, float dst) {
2652: 	return true;
2653: }
2654: 
2655: const int64_t MAX_INT_REPRESENTABLE_IN_FLOAT = 0x001000000LL;
2656: const int64_t MAX_INT_REPRESENTABLE_IN_DOUBLE = 0x0020000000000000LL;
2657: 
2658: template <>
2659: bool IsRepresentableExactly(int32_t input, float dst) {
2660: 	return (input <= MAX_INT_REPRESENTABLE_IN_FLOAT && input >= -MAX_INT_REPRESENTABLE_IN_FLOAT);
2661: }
2662: 
2663: template <>
2664: bool IsRepresentableExactly(int64_t input, float dst) {
2665: 	return (input <= MAX_INT_REPRESENTABLE_IN_FLOAT && input >= -MAX_INT_REPRESENTABLE_IN_FLOAT);
2666: }
2667: 
2668: template <>
2669: bool IsRepresentableExactly(hugeint_t input, float dst) {
2670: 	return (input <= MAX_INT_REPRESENTABLE_IN_FLOAT && input >= -MAX_INT_REPRESENTABLE_IN_FLOAT);
2671: }
2672: 
2673: template <>
2674: bool IsRepresentableExactly(int16_t input, double dst) {
2675: 	return true;
2676: }
2677: 
2678: template <>
2679: bool IsRepresentableExactly(int32_t input, double dst) {
2680: 	return true;
2681: }
2682: 
2683: template <>
2684: bool IsRepresentableExactly(int64_t input, double dst) {
2685: 	return (input <= MAX_INT_REPRESENTABLE_IN_DOUBLE && input >= -MAX_INT_REPRESENTABLE_IN_DOUBLE);
2686: }
2687: 
2688: template <>
2689: bool IsRepresentableExactly(hugeint_t input, double dst) {
2690: 	return (input <= MAX_INT_REPRESENTABLE_IN_DOUBLE && input >= -MAX_INT_REPRESENTABLE_IN_DOUBLE);
2691: }
2692: 
2693: template <class SRC>
2694: static SRC GetPowerOfTen(SRC input, uint8_t scale) {
2695: 	return static_cast<SRC>(NumericHelper::POWERS_OF_TEN[scale]);
2696: }
2697: 
2698: template <>
2699: hugeint_t GetPowerOfTen(hugeint_t input, uint8_t scale) {
2700: 	return Hugeint::POWERS_OF_TEN[scale];
2701: }
2702: 
2703: template <class SRC>
2704: static void GetDivMod(SRC lhs, SRC rhs, SRC &div, SRC &mod) {
2705: 	div = lhs / rhs;
2706: 	mod = lhs % rhs;
2707: }
2708: 
2709: template <>
2710: void GetDivMod(hugeint_t lhs, hugeint_t rhs, hugeint_t &div, hugeint_t &mod) {
2711: 	div = Hugeint::DivMod(lhs, rhs, mod);
2712: }
2713: 
2714: template <class SRC, class DST>
2715: bool TryCastDecimalToFloatingPoint(SRC input, DST &result, uint8_t scale) {
2716: 	if (IsRepresentableExactly<SRC, DST>(input, DST(0.0)) || scale == 0) {
2717: 		// Fast path, integer is representable exaclty as a float/double
2718: 		result = Cast::Operation<SRC, DST>(input) / DST(NumericHelper::DOUBLE_POWERS_OF_TEN[scale]);
2719: 		return true;
2720: 	}
2721: 	auto power_of_ten = GetPowerOfTen(input, scale);
2722: 
2723: 	SRC div = 0;
2724: 	SRC mod = 0;
2725: 	GetDivMod(input, power_of_ten, div, mod);
2726: 
2727: 	result = Cast::Operation<SRC, DST>(div) +
2728: 	         Cast::Operation<SRC, DST>(mod) / DST(NumericHelper::DOUBLE_POWERS_OF_TEN[scale]);
2729: 	return true;
2730: }
2731: 
2732: // DECIMAL -> FLOAT
2733: template <>
2734: bool TryCastFromDecimal::Operation(int16_t input, float &result, CastParameters &parameters, uint8_t width,
2735:                                    uint8_t scale) {
2736: 	return TryCastDecimalToFloatingPoint<int16_t, float>(input, result, scale);
2737: }
2738: 
2739: template <>
2740: bool TryCastFromDecimal::Operation(int32_t input, float &result, CastParameters &parameters, uint8_t width,
2741:                                    uint8_t scale) {
2742: 	return TryCastDecimalToFloatingPoint<int32_t, float>(input, result, scale);
2743: }
2744: 
2745: template <>
2746: bool TryCastFromDecimal::Operation(int64_t input, float &result, CastParameters &parameters, uint8_t width,
2747:                                    uint8_t scale) {
2748: 	return TryCastDecimalToFloatingPoint<int64_t, float>(input, result, scale);
2749: }
2750: 
2751: template <>
2752: bool TryCastFromDecimal::Operation(hugeint_t input, float &result, CastParameters &parameters, uint8_t width,
2753:                                    uint8_t scale) {
2754: 	return TryCastDecimalToFloatingPoint<hugeint_t, float>(input, result, scale);
2755: }
2756: 
2757: // DECIMAL -> DOUBLE
2758: template <>
2759: bool TryCastFromDecimal::Operation(int16_t input, double &result, CastParameters &parameters, uint8_t width,
2760:                                    uint8_t scale) {
2761: 	return TryCastDecimalToFloatingPoint<int16_t, double>(input, result, scale);
2762: }
2763: 
2764: template <>
2765: bool TryCastFromDecimal::Operation(int32_t input, double &result, CastParameters &parameters, uint8_t width,
2766:                                    uint8_t scale) {
2767: 	return TryCastDecimalToFloatingPoint<int32_t, double>(input, result, scale);
2768: }
2769: 
2770: template <>
2771: bool TryCastFromDecimal::Operation(int64_t input, double &result, CastParameters &parameters, uint8_t width,
2772:                                    uint8_t scale) {
2773: 	return TryCastDecimalToFloatingPoint<int64_t, double>(input, result, scale);
2774: }
2775: 
2776: template <>
2777: bool TryCastFromDecimal::Operation(hugeint_t input, double &result, CastParameters &parameters, uint8_t width,
2778:                                    uint8_t scale) {
2779: 	return TryCastDecimalToFloatingPoint<hugeint_t, double>(input, result, scale);
2780: }
2781: 
2782: } // namespace duckdb
[end of src/common/operator/cast_operators.cpp]
[start of src/common/types/uuid.cpp]
1: #include "duckdb/common/types/uuid.hpp"
2: #include "duckdb/common/random_engine.hpp"
3: 
4: namespace duckdb {
5: 
6: //////////////////
7: // Base UUID
8: //////////////////
9: bool BaseUUID::FromString(const string &str, hugeint_t &result) {
10: 	auto hex2char = [](char ch) -> unsigned char {
11: 		if (ch >= '0' && ch <= '9') {
12: 			return UnsafeNumericCast<unsigned char>(ch - '0');
13: 		}
14: 		if (ch >= 'a' && ch <= 'f') {
15: 			return UnsafeNumericCast<unsigned char>(10 + ch - 'a');
16: 		}
17: 		if (ch >= 'A' && ch <= 'F') {
18: 			return UnsafeNumericCast<unsigned char>(10 + ch - 'A');
19: 		}
20: 		return 0;
21: 	};
22: 	auto is_hex = [](char ch) -> bool {
23: 		return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F');
24: 	};
25: 
26: 	if (str.empty()) {
27: 		return false;
28: 	}
29: 	idx_t has_braces = 0;
30: 	if (str.front() == '{') {
31: 		has_braces = 1;
32: 	}
33: 	if (has_braces && str.back() != '}') {
34: 		return false;
35: 	}
36: 
37: 	result.lower = 0;
38: 	result.upper = 0;
39: 	size_t count = 0;
40: 	for (size_t i = has_braces; i < str.size() - has_braces; ++i) {
41: 		if (str[i] == '-') {
42: 			continue;
43: 		}
44: 		if (count >= 32 || !is_hex(str[i])) {
45: 			return false;
46: 		}
47: 		if (count >= 16) {
48: 			result.lower = (result.lower << 4) | hex2char(str[i]);
49: 		} else {
50: 			result.upper = (result.upper << 4) | hex2char(str[i]);
51: 		}
52: 		count++;
53: 	}
54: 	// Flip the first bit to make `order by uuid` same as `order by uuid::varchar`
55: 	result.upper ^= NumericLimits<int64_t>::Minimum();
56: 	return count == 32;
57: }
58: 
59: void BaseUUID::ToString(hugeint_t input, char *buf) {
60: 	auto byte_to_hex = [](uint64_t byte_val, char *buf, idx_t &pos) {
61: 		D_ASSERT(byte_val <= 0xFF);
62: 		static char const HEX_DIGITS[] = "0123456789abcdef";
63: 		buf[pos++] = HEX_DIGITS[(byte_val >> 4) & 0xf];
64: 		buf[pos++] = HEX_DIGITS[byte_val & 0xf];
65: 	};
66: 
67: 	// Flip back before convert to string
68: 	int64_t upper = int64_t(uint64_t(input.upper) ^ (uint64_t(1) << 63));
69: 	idx_t pos = 0;
70: 	byte_to_hex(upper >> 56 & 0xFF, buf, pos);
71: 	byte_to_hex(upper >> 48 & 0xFF, buf, pos);
72: 	byte_to_hex(upper >> 40 & 0xFF, buf, pos);
73: 	byte_to_hex(upper >> 32 & 0xFF, buf, pos);
74: 	buf[pos++] = '-';
75: 	byte_to_hex(upper >> 24 & 0xFF, buf, pos);
76: 	byte_to_hex(upper >> 16 & 0xFF, buf, pos);
77: 	buf[pos++] = '-';
78: 	byte_to_hex(upper >> 8 & 0xFF, buf, pos);
79: 	byte_to_hex(upper & 0xFF, buf, pos);
80: 	buf[pos++] = '-';
81: 	byte_to_hex(input.lower >> 56 & 0xFF, buf, pos);
82: 	byte_to_hex(input.lower >> 48 & 0xFF, buf, pos);
83: 	buf[pos++] = '-';
84: 	byte_to_hex(input.lower >> 40 & 0xFF, buf, pos);
85: 	byte_to_hex(input.lower >> 32 & 0xFF, buf, pos);
86: 	byte_to_hex(input.lower >> 24 & 0xFF, buf, pos);
87: 	byte_to_hex(input.lower >> 16 & 0xFF, buf, pos);
88: 	byte_to_hex(input.lower >> 8 & 0xFF, buf, pos);
89: 	byte_to_hex(input.lower & 0xFF, buf, pos);
90: }
91: 
92: hugeint_t BaseUUID::FromUHugeint(uhugeint_t input) {
93: 	hugeint_t result;
94: 	result.lower = input.lower;
95: 	if (input.upper > uint64_t(NumericLimits<int64_t>::Maximum())) {
96: 		result.upper = int64_t(input.upper - uint64_t(NumericLimits<int64_t>::Maximum()) - 1);
97: 	} else {
98: 		result.upper = int64_t(input.upper) - NumericLimits<int64_t>::Maximum() - 1;
99: 	}
100: 	return result;
101: }
102: 
103: uhugeint_t BaseUUID::ToUHugeint(hugeint_t input) {
104: 	uhugeint_t result;
105: 	result.lower = input.lower;
106: 	if (input.upper >= 0) {
107: 		result.upper = uint64_t(input.upper) + uint64_t(NumericLimits<int64_t>::Maximum()) + 1;
108: 	} else {
109: 		result.upper = uint64_t(input.upper + NumericLimits<int64_t>::Maximum() + 1);
110: 	}
111: 	return result;
112: }
113: 
114: hugeint_t BaseUUID::Convert(const std::array<uint8_t, 16> &bytes) {
115: 	hugeint_t result;
116: 	result.upper = 0;
117: 	result.upper |= ((int64_t)bytes[0] << 56);
118: 	result.upper |= ((int64_t)bytes[1] << 48);
119: 	result.upper |= ((int64_t)bytes[2] << 40);
120: 	result.upper |= ((int64_t)bytes[3] << 32);
121: 	result.upper |= ((int64_t)bytes[4] << 24);
122: 	result.upper |= ((int64_t)bytes[5] << 16);
123: 	result.upper |= ((int64_t)bytes[6] << 8);
124: 	result.upper |= bytes[7];
125: 	result.lower = 0;
126: 	result.lower |= ((uint64_t)bytes[8] << 56);
127: 	result.lower |= ((uint64_t)bytes[9] << 48);
128: 	result.lower |= ((uint64_t)bytes[10] << 40);
129: 	result.lower |= ((uint64_t)bytes[11] << 32);
130: 	result.lower |= ((uint64_t)bytes[12] << 24);
131: 	result.lower |= ((uint64_t)bytes[13] << 16);
132: 	result.lower |= ((uint64_t)bytes[14] << 8);
133: 	result.lower |= bytes[15];
134: 	return result;
135: }
136: 
137: //////////////////
138: // UUIDv4
139: //////////////////
140: hugeint_t UUIDv4::GenerateRandomUUID(RandomEngine &engine) {
141: 	std::array<uint8_t, 16> bytes;
142: 	for (int i = 0; i < 16; i += 4) {
143: 		*reinterpret_cast<uint32_t *>(bytes.data() + i) = engine.NextRandomInteger();
144: 	}
145: 	// variant must be 10xxxxxx
146: 	bytes[8] &= 0xBF;
147: 	bytes[8] |= 0x80;
148: 	// version must be 0100xxxx
149: 	bytes[6] &= 0x4F;
150: 	bytes[6] |= 0x40;
151: 
152: 	return Convert(bytes);
153: }
154: 
155: hugeint_t UUIDv4::GenerateRandomUUID() {
156: 	RandomEngine engine;
157: 	return GenerateRandomUUID(engine);
158: }
159: 
160: //////////////////
161: // UUIDv7
162: //////////////////
163: hugeint_t UUIDv7::GenerateRandomUUID(RandomEngine &engine) {
164: 	std::array<uint8_t, 16> bytes; // Intentionally no initialization.
165: 
166: 	const auto now = std::chrono::system_clock::now();
167: 	const auto time_ns = std::chrono::time_point_cast<std::chrono::nanoseconds>(now);
168: 	const auto unix_ts_ns = static_cast<uint64_t>(time_ns.time_since_epoch().count());
169: 
170: 	// Begins with a 48 bit big-endian Unix Epoch timestamp with millisecond granularity.
171: 	static constexpr uint64_t kNanoToMilli = 1000000;
172: 	const uint64_t unix_ts_ms = unix_ts_ns / kNanoToMilli;
173: 	bytes[0] = static_cast<uint8_t>(unix_ts_ms >> 40);
174: 	bytes[1] = static_cast<uint8_t>(unix_ts_ms >> 32);
175: 	bytes[2] = static_cast<uint8_t>(unix_ts_ms >> 24);
176: 	bytes[3] = static_cast<uint8_t>(unix_ts_ms >> 16);
177: 	bytes[4] = static_cast<uint8_t>(unix_ts_ms >> 8);
178: 	bytes[5] = static_cast<uint8_t>(unix_ts_ms);
179: 
180: 	// Fill in random bits.
181: 	const uint32_t random_a = engine.NextRandomInteger();
182: 	const uint32_t random_b = engine.NextRandomInteger();
183: 	const uint32_t random_c = engine.NextRandomInteger();
184: 	bytes[6] = static_cast<uint8_t>(random_a >> 24);
185: 	bytes[7] = static_cast<uint8_t>(random_a >> 16);
186: 	bytes[8] = static_cast<uint8_t>(random_a >> 8);
187: 	bytes[9] = static_cast<uint8_t>(random_a);
188: 	bytes[10] = static_cast<uint8_t>(random_b >> 24);
189: 	bytes[11] = static_cast<uint8_t>(random_b >> 16);
190: 	bytes[12] = static_cast<uint8_t>(random_b >> 8);
191: 	bytes[13] = static_cast<uint8_t>(random_b);
192: 	bytes[14] = static_cast<uint8_t>(random_c >> 24);
193: 	bytes[15] = static_cast<uint8_t>(random_c >> 16);
194: 
195: 	// Fill in version number.
196: 	constexpr uint8_t kVersion = 7;
197: 	bytes[6] = (bytes[6] & 0x0f) | (kVersion << 4);
198: 
199: 	// Fill in variant field.
200: 	bytes[8] = (bytes[8] & 0x3f) | 0x80;
201: 
202: 	return Convert(bytes);
203: }
204: 
205: hugeint_t UUIDv7::GenerateRandomUUID() {
206: 	RandomEngine engine;
207: 	return GenerateRandomUUID(engine);
208: }
209: 
210: } // namespace duckdb
[end of src/common/types/uuid.cpp]
[start of src/include/duckdb/common/types/uuid.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/uuid.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include <array>
12: 
13: #include "duckdb/common/types.hpp"
14: #include "duckdb/common/types/string_type.hpp"
15: 
16: namespace duckdb {
17: class RandomEngine;
18: 
19: //! The BaseUUID class contains UUID related common and util functions.
20: class BaseUUID {
21: public:
22: 	constexpr static const uint8_t STRING_SIZE = 36;
23: 	//! Convert a uuid string to a hugeint object
24: 	static bool FromString(const string &str, hugeint_t &result);
25: 	//! Convert a uuid string to a hugeint object
26: 	static bool FromCString(const char *str, idx_t len, hugeint_t &result) {
27: 		return FromString(string(str, 0, len), result);
28: 	}
29: 	//! Convert a hugeint object to a uuid style string
30: 	static void ToString(hugeint_t input, char *buf);
31: 
32: 	//! Convert a uhugeint_t object to a uuid value
33: 	static hugeint_t FromUHugeint(uhugeint_t input);
34: 	//! Convert a uuid value to a uhugeint_t object
35: 	static uhugeint_t ToUHugeint(hugeint_t input);
36: 
37: 	//! Convert a hugeint object to a uuid style string
38: 	static string ToString(hugeint_t input) {
39: 		char buff[STRING_SIZE];
40: 		ToString(input, buff);
41: 		return string(buff, STRING_SIZE);
42: 	}
43: 
44: 	static hugeint_t FromString(const string &str) {
45: 		hugeint_t result;
46: 		FromString(str, result);
47: 		return result;
48: 	}
49: 
50: protected:
51: 	//! Util function, which converts uint8_t array to hugeint_t.
52: 	static hugeint_t Convert(const std::array<uint8_t, 16> &bytes);
53: };
54: 
55: //! The UUIDv4 class contains static operations for the UUIDv4 type
56: class UUID : public BaseUUID {
57: public:
58: 	//! Generate a random UUID v4 value.
59: 	static hugeint_t GenerateRandomUUID(RandomEngine &engine);
60: 	static hugeint_t GenerateRandomUUID();
61: };
62: 
63: using UUIDv4 = UUID;
64: 
65: //! The UUIDv7 class contains static operations for the UUIDv7 type.
66: class UUIDv7 : public BaseUUID {
67: public:
68: 	//! Generate a random UUID v7 value.
69: 	static hugeint_t GenerateRandomUUID(RandomEngine &engine);
70: 	static hugeint_t GenerateRandomUUID();
71: };
72: 
73: } // namespace duckdb
[end of src/include/duckdb/common/types/uuid.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: