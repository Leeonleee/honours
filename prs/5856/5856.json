{
  "repo": "duckdb/duckdb",
  "pull_number": 5856,
  "instance_id": "duckdb__duckdb-5856",
  "issue_numbers": [
    "5853",
    "5853"
  ],
  "base_commit": "46f8e0b7cee4ebdb0762a676e75cd976ce314cd1",
  "patch": "diff --git a/src/include/duckdb/function/function_serialization.hpp b/src/include/duckdb/function/function_serialization.hpp\nindex 694d60bf6200..71bafce37354 100644\n--- a/src/include/duckdb/function/function_serialization.hpp\n+++ b/src/include/duckdb/function/function_serialization.hpp\n@@ -47,7 +47,7 @@ class FunctionSerializer {\n \t\t// note: original_arguments are optional (can be list of size 0)\n \t\tauto original_arguments = reader.ReadRequiredSerializableList<LogicalType, LogicalType>();\n \n-\t\tauto func_catalog = Catalog::GetEntry(context, type, INVALID_CATALOG, DEFAULT_SCHEMA, name);\n+\t\tauto func_catalog = Catalog::GetEntry(context, type, SYSTEM_CATALOG, DEFAULT_SCHEMA, name);\n \t\tif (!func_catalog || func_catalog->type != type) {\n \t\t\tthrow InternalException(\"Cant find catalog entry for function %s\", name);\n \t\t}\ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex 56ed2f9edf23..0c5c11ef6262 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -5,6 +5,7 @@\n #include \"duckdb/main/client_context.hpp\"\n #include \"duckdb/main/database.hpp\"\n #include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/expression/function_expression.hpp\"\n #include \"duckdb/parser/expression/subquery_expression.hpp\"\n #include \"duckdb/parser/parsed_data/create_index_info.hpp\"\n #include \"duckdb/parser/parsed_data/create_macro_info.hpp\"\n@@ -128,6 +129,33 @@ void Binder::BindCreateViewInfo(CreateViewInfo &base) {\n \tbase.types = query_node.types;\n }\n \n+static void QualifyFunctionNames(ClientContext &context, unique_ptr<ParsedExpression> &expr) {\n+\tswitch (expr->GetExpressionClass()) {\n+\tcase ExpressionClass::FUNCTION: {\n+\t\tauto &func = (FunctionExpression &)*expr;\n+\t\tauto function = (StandardEntry *)Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, func.catalog,\n+\t\t                                                   func.schema, func.function_name, true);\n+\t\tif (function) {\n+\t\t\tfunc.catalog = function->catalog->GetName();\n+\t\t\tfunc.schema = function->schema->name;\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase ExpressionClass::SUBQUERY: {\n+\t\t// replacing parameters within a subquery is slightly different\n+\t\tauto &sq = ((SubqueryExpression &)*expr).subquery;\n+\t\tParsedExpressionIterator::EnumerateQueryNodeChildren(\n+\t\t    *sq->node, [&](unique_ptr<ParsedExpression> &child) { QualifyFunctionNames(context, child); });\n+\t\tbreak;\n+\t}\n+\tdefault: // fall through\n+\t\tbreak;\n+\t}\n+\t// unfold child expressions\n+\tParsedExpressionIterator::EnumerateChildren(\n+\t    *expr, [&](unique_ptr<ParsedExpression> &child) { QualifyFunctionNames(context, child); });\n+}\n+\n SchemaCatalogEntry *Binder::BindCreateFunctionInfo(CreateInfo &info) {\n \tauto &base = (CreateMacroInfo &)info;\n \tauto &scalar_function = (ScalarMacroFunction &)*base.function;\n@@ -157,6 +185,7 @@ SchemaCatalogEntry *Binder::BindCreateFunctionInfo(CreateInfo &info) {\n \tauto this_macro_binding = make_unique<DummyBinding>(dummy_types, dummy_names, base.name);\n \tmacro_binding = this_macro_binding.get();\n \tExpressionBinder::QualifyColumnNames(*this, scalar_function.expression);\n+\tQualifyFunctionNames(context, scalar_function.expression);\n \n \t// create a copy of the expression because we do not want to alter the original\n \tauto expression = scalar_function.expression->Copy();\n",
  "test_patch": "diff --git a/test/sql/catalog/function/test_recursive_macro.test b/test/sql/catalog/function/test_recursive_macro.test\nnew file mode 100644\nindex 000000000000..ea877bca26d6\n--- /dev/null\n+++ b/test/sql/catalog/function/test_recursive_macro.test\n@@ -0,0 +1,33 @@\n+# name: test/sql/catalog/function/test_recursive_macro.test\n+# description: Test recursive macros\n+# group: [function]\n+\n+statement ok\n+CREATE MACRO \"sum\"(x) AS (CASE WHEN sum(x) IS NULL THEN 0 ELSE sum(x) END);\n+\n+query I\n+SELECT sum(1);\n+----\n+1\n+\n+query I\n+SELECT sum(1) WHERE 42=0\n+----\n+0\n+\n+statement ok\n+DROP MACRO sum\n+\n+# recursive macro with explicit qualification\n+statement ok\n+CREATE MACRO \"sum\"(x) AS (CASE WHEN system.main.sum(x) IS NULL THEN 0 ELSE system.main.sum(x) END);\n+\n+query I\n+SELECT sum(1);\n+----\n+1\n+\n+query I\n+SELECT sum(1) WHERE 42=0\n+----\n+0\n",
  "problem_statement": "Segmentation fault when creating a macro that references a function with the same name\n### What happens?\n\nWhen issuing a `CREATE MACRO` for a macro named identically to a function it uses, a segmentation fault occurs.\r\n\r\nIs there a workaround?\n\n### To Reproduce\n\n```sh\r\ncat <<EOF | build/debug/duckdb\r\nCREATE MACRO \"sum\"(x) AS (CASE WHEN SUM(x) IS NULL THEN 0 ELSE SUM(x) END);\r\nSELECT sum(1);\r\nEOF\r\n# [1]    14483 done                cat <<<'' |\r\n#        14484 segmentation fault  build/debug/duckdb\r\n```\r\n\n\n### OS:\n\nmacOS aarch64\n\n### DuckDB Version:\n\nb056090a0cc009a55a9b3b9efdc4ef07235f2f13\n\n### DuckDB Client:\n\nduckdb\n\n### Full Name:\n\nKirill M\u00fcller\n\n### Affiliation:\n\ncynkra GmbH\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nSegmentation fault when creating a macro that references a function with the same name\n### What happens?\n\nWhen issuing a `CREATE MACRO` for a macro named identically to a function it uses, a segmentation fault occurs.\r\n\r\nIs there a workaround?\n\n### To Reproduce\n\n```sh\r\ncat <<EOF | build/debug/duckdb\r\nCREATE MACRO \"sum\"(x) AS (CASE WHEN SUM(x) IS NULL THEN 0 ELSE SUM(x) END);\r\nSELECT sum(1);\r\nEOF\r\n# [1]    14483 done                cat <<<'' |\r\n#        14484 segmentation fault  build/debug/duckdb\r\n```\r\n\n\n### OS:\n\nmacOS aarch64\n\n### DuckDB Version:\n\nb056090a0cc009a55a9b3b9efdc4ef07235f2f13\n\n### DuckDB Client:\n\nduckdb\n\n### Full Name:\n\nKirill M\u00fcller\n\n### Affiliation:\n\ncynkra GmbH\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "\n",
  "created_at": "2023-01-08T14:38:08Z"
}