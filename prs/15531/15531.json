{
  "repo": "duckdb/duckdb",
  "pull_number": 15531,
  "instance_id": "duckdb__duckdb-15531",
  "issue_numbers": [
    "15465"
  ],
  "base_commit": "6c4d2a394ff166af23cfd9be499d96f2b1bfb0de",
  "patch": "diff --git a/src/common/vector_operations/comparison_operators.cpp b/src/common/vector_operations/comparison_operators.cpp\nindex 8a56cdfc3b59..9c5c3d662d09 100644\n--- a/src/common/vector_operations/comparison_operators.cpp\n+++ b/src/common/vector_operations/comparison_operators.cpp\n@@ -223,7 +223,8 @@ struct ComparisonExecutor {\n public:\n \ttemplate <class OP>\n \tstatic inline void Execute(Vector &left, Vector &right, Vector &result, idx_t count) {\n-\t\tD_ASSERT(left.GetType() == right.GetType() && result.GetType() == LogicalType::BOOLEAN);\n+\t\tD_ASSERT(left.GetType().InternalType() == right.GetType().InternalType() &&\n+\t\t         result.GetType() == LogicalType::BOOLEAN);\n \t\t// the inplace loops take the result as the last parameter\n \t\tswitch (left.GetType().InternalType()) {\n \t\tcase PhysicalType::BOOL:\ndiff --git a/src/parser/transform/tableref/transform_pivot.cpp b/src/parser/transform/tableref/transform_pivot.cpp\nindex 3a51ba0f7bcd..d042d881d3c1 100644\n--- a/src/parser/transform/tableref/transform_pivot.cpp\n+++ b/src/parser/transform/tableref/transform_pivot.cpp\n@@ -73,6 +73,7 @@ PivotColumn Transformer::TransformPivotColumn(duckdb_libpgquery::PGPivot &pivot,\n \t\t\t\t\t                      \"PIVOT IN list must contain columns or lists of columns\");\n \t\t\t\t} else {\n \t\t\t\t\t// for unpivot - we can forward the expression immediately\n+\t\t\t\t\tentry.values.clear();\n \t\t\t\t\tentry.expr = std::move(expr);\n \t\t\t\t}\n \t\t\t}\ndiff --git a/src/planner/bind_context.cpp b/src/planner/bind_context.cpp\nindex 58ddbaac63d9..d135ed2ae604 100644\n--- a/src/planner/bind_context.cpp\n+++ b/src/planner/bind_context.cpp\n@@ -695,14 +695,6 @@ void BindContext::AddContext(BindContext other) {\n \t}\n \tfor (auto &entry : other.using_columns) {\n \t\tfor (auto &alias : entry.second) {\n-#ifdef DEBUG\n-\t\t\tfor (auto &other_alias : using_columns[entry.first]) {\n-\t\t\t\tfor (auto &col : alias.get().bindings) {\n-\t\t\t\t\tD_ASSERT(std::find(other_alias.get().bindings.begin(), other_alias.get().bindings.end(), col) ==\n-\t\t\t\t\t         other_alias.get().bindings.end());\n-\t\t\t\t}\n-\t\t\t}\n-#endif\n \t\t\tusing_columns[entry.first].insert(alias);\n \t\t}\n \t}\n@@ -719,22 +711,22 @@ vector<BindingAlias> BindContext::GetBindingAliases() {\n void BindContext::RemoveContext(const vector<BindingAlias> &aliases) {\n \tfor (auto &alias : aliases) {\n \t\t// remove the binding from any USING columns\n+\t\tvector<string> removed_using_columns;\n \t\tfor (auto &using_sets : using_columns) {\n \t\t\tfor (auto &using_set_ref : using_sets.second) {\n \t\t\t\tauto &using_set = using_set_ref.get();\n \t\t\t\tauto it = std::remove_if(using_set.bindings.begin(), using_set.bindings.end(),\n \t\t\t\t                         [&](const BindingAlias &using_alias) { return using_alias == alias; });\n \t\t\t\tusing_set.bindings.erase(it, using_set.bindings.end());\n-\t\t\t\tif (using_set.bindings.empty()) {\n-\t\t\t\t\tthrow InternalException(\n-\t\t\t\t\t    \"BindContext::RemoveContext - no more tables that refer to this using binding\");\n-\t\t\t\t}\n-\t\t\t\tif (using_set.primary_binding == alias) {\n-\t\t\t\t\tthrow InternalException(\n-\t\t\t\t\t    \"BindContext::RemoveContext - cannot remove primary binding from using binding\");\n+\t\t\t\tif (using_set.bindings.empty() || using_set.primary_binding == alias) {\n+\t\t\t\t\t// if the using column is no longer referred to - remove it entirely\n+\t\t\t\t\tremoved_using_columns.push_back(using_sets.first);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfor (auto &removed_col : removed_using_columns) {\n+\t\t\tusing_columns.erase(removed_col);\n+\t\t}\n \n \t\t// remove the binding from the list of bindings\n \t\tauto it = std::remove_if(bindings_list.begin(), bindings_list.end(),\ndiff --git a/src/planner/binder/expression/bind_window_expression.cpp b/src/planner/binder/expression/bind_window_expression.cpp\nindex 7fcf96e69ade..72a6c4be2c32 100644\n--- a/src/planner/binder/expression/bind_window_expression.cpp\n+++ b/src/planner/binder/expression/bind_window_expression.cpp\n@@ -155,7 +155,7 @@ BindResult BaseSelectBinder::BindWindow(WindowExpression &window, idx_t depth) {\n \t\treturn BindMacro(*macro, entry->Cast<ScalarMacroCatalogEntry>(), depth, macro_expr);\n \t}\n \n-\tauto name = window.GetName();\n+\tauto name = window.alias;\n \n \tif (inside_window) {\n \t\tthrow BinderException(error_context, \"window function calls cannot be nested\");\ndiff --git a/src/planner/binder/statement/bind_vacuum.cpp b/src/planner/binder/statement/bind_vacuum.cpp\nindex 34b0ec56eb79..93e70fe5b8be 100644\n--- a/src/planner/binder/statement/bind_vacuum.cpp\n+++ b/src/planner/binder/statement/bind_vacuum.cpp\n@@ -27,8 +27,9 @@ void Binder::BindVacuumTable(LogicalVacuum &vacuum, unique_ptr<LogicalOperator>\n \tauto &columns = info.columns;\n \tif (columns.empty()) {\n \t\t// Empty means ALL columns should be vacuumed/analyzed\n-\t\tauto &get = ref->get->Cast<LogicalGet>();\n-\t\tcolumns.insert(columns.end(), get.names.begin(), get.names.end());\n+\t\tfor (auto &col : table.GetColumns().Physical()) {\n+\t\t\tcolumns.push_back(col.GetName());\n+\t\t}\n \t}\n \n \tcase_insensitive_set_t column_name_set;\n@@ -45,7 +46,9 @@ void Binder::BindVacuumTable(LogicalVacuum &vacuum, unique_ptr<LogicalOperator>\n \t\tauto &col = table.GetColumn(col_name);\n \t\t// ignore generated column\n \t\tif (col.Generated()) {\n-\t\t\tcontinue;\n+\t\t\tthrow BinderException(\n+\t\t\t    \"cannot vacuum or analyze generated column \\\"%s\\\" - specify non-generated columns to vacuum or analyze\",\n+\t\t\t    col.GetName());\n \t\t}\n \t\tnon_generated_column_names.push_back(col_name);\n \t\tColumnRefExpression colref(col_name, table.name);\n@@ -56,8 +59,6 @@ void Binder::BindVacuumTable(LogicalVacuum &vacuum, unique_ptr<LogicalOperator>\n \t\tselect_list.push_back(std::move(result.expression));\n \t}\n \tinfo.columns = std::move(non_generated_column_names);\n-\t// Creating a table without any physical columns is not supported\n-\tD_ASSERT(!select_list.empty());\n \n \tauto table_scan = CreatePlan(*ref);\n \tD_ASSERT(table_scan->type == LogicalOperatorType::LOGICAL_GET);\ndiff --git a/src/planner/subquery/flatten_dependent_join.cpp b/src/planner/subquery/flatten_dependent_join.cpp\nindex af79baa83e8b..a297a7855dae 100644\n--- a/src/planner/subquery/flatten_dependent_join.cpp\n+++ b/src/planner/subquery/flatten_dependent_join.cpp\n@@ -414,7 +414,7 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t\t\t\treturn plan;\n \t\t\t}\n \t\t} else if (join.join_type == JoinType::RIGHT) {\n-\t\t\t// left outer join\n+\t\t\t// right outer join\n \t\t\tif (!left_has_correlation) {\n \t\t\t\t// only right has correlation: push into right\n \t\t\t\tplan->children[1] = PushDownDependentJoinInternal(std::move(plan->children[1]),\n@@ -450,6 +450,7 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t\t\tthis->base_binding = left_binding;\n \t\t} else if (join.join_type == JoinType::RIGHT) {\n \t\t\tthis->base_binding = right_binding;\n+\t\t\tdelim_offset += plan->children[0]->GetColumnBindings().size();\n \t\t}\n \t\t// add the correlated columns to the join conditions\n \t\tfor (idx_t i = 0; i < correlated_columns.size(); i++) {\ndiff --git a/tools/shell/shell.cpp b/tools/shell/shell.cpp\nindex 911d8efebdb1..024db0db922c 100644\n--- a/tools/shell/shell.cpp\n+++ b/tools/shell/shell.cpp\n@@ -1772,6 +1772,17 @@ int ShellState::ExecuteSQL(const char *zSql, /* SQL to be evaluated */\n \t\t\t\t\tzSql++;\n \t\t\t\tcontinue;\n \t\t\t}\n+\t\t\tif (sqlite3_bind_parameter_count(pStmt) != 0) {\n+\t\t\t\tzSql = zLeftover;\n+\t\t\t\twhile (IsSpace(zSql[0]))\n+\t\t\t\t\tzSql++;\n+\t\t\t\tif (pzErrMsg) {\n+\t\t\t\t\t*pzErrMsg = strdup(\"Prepared statement parameters cannot be used directly\\nTo use prepared \"\n+\t\t\t\t\t                   \"statement parameters, use PREPARE to prepare a statement, followed by EXECUTE\");\n+\t\t\t\t}\n+\t\t\t\tsqlite3_finalize(pStmt);\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tzStmtSql = sqlite3_sql(pStmt);\n \t\t\tif (zStmtSql == 0)\n \t\t\t\tzStmtSql = \"\";\ndiff --git a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\nindex b9b7529249a9..8e8fee65e70a 100644\n--- a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n+++ b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n@@ -264,7 +264,6 @@ void sqlite3_print_duckbox(sqlite3_stmt *pStmt, size_t max_rows, size_t max_widt\n \t\t\tpStmt->db->last_error = ErrorData(\"Statement has already been executed\");\n \t\t\treturn;\n \t\t}\n-\n \t\tif (pStmt->prepared) {\n \t\t\tpStmt->result = pStmt->prepared->Execute(pStmt->bound_values, false);\n \t\t} else if (pStmt->pending) {\n",
  "test_patch": "diff --git a/test/fuzzer/pedro/vacuum_table_with_generated_column.test b/test/fuzzer/pedro/vacuum_table_with_generated_column.test\nindex 98f1a09224cf..10959d2bd79f 100644\n--- a/test/fuzzer/pedro/vacuum_table_with_generated_column.test\n+++ b/test/fuzzer/pedro/vacuum_table_with_generated_column.test\n@@ -18,8 +18,15 @@ ANALYZE test(x, x);\n ----\n <REGEX>:Binder Error.*cannot vacuum.*the same column twice.*\n \n-statement ok\n+statement error\n+ANALYZE test(y);\n+----\n+cannot vacuum or analyze generated column \"y\"\n+\n+statement error\n ANALYZE test(y, x);\n+----\n+cannot vacuum or analyze generated column \"y\"\n \n statement ok\n INSERT INTO test SELECT range % 5000 FROM range(10000);\n@@ -38,6 +45,9 @@ SELECT stats(y) FROM test LIMIT 1;\n statement ok\n PRAGMA verify_parallelism;\n \n+statement ok\n+ANALYZE test\n+\n statement ok\n ANALYZE test(x);\n \ndiff --git a/test/fuzzer/public/duplicate_alias_using.test b/test/fuzzer/public/duplicate_alias_using.test\nnew file mode 100644\nindex 000000000000..4d1c3c22a79e\n--- /dev/null\n+++ b/test/fuzzer/public/duplicate_alias_using.test\n@@ -0,0 +1,16 @@\n+# name: test/fuzzer/public/duplicate_alias_using.test\n+# description: Duplicate alias in USING\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE t1 (c1 INT);\n+\n+statement error\n+SELECT c1\n+FROM t1 AS same_alias JOIN t1 AS same_alias2 USING (c1),\n+     t1 AS same_alias JOIN t1 AS same_alias2 USING (c1);\n+----\n+Ambiguous\ndiff --git a/test/fuzzer/public/lateral_right_join.test b/test/fuzzer/public/lateral_right_join.test\nnew file mode 100644\nindex 000000000000..3b86215899c9\n--- /dev/null\n+++ b/test/fuzzer/public/lateral_right_join.test\n@@ -0,0 +1,22 @@\n+# name: test/fuzzer/public/lateral_right_join.test\n+# description: Lateral join followed by a right join\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE tbl (c01 INT, c02 VARCHAR);\n+\n+statement ok\n+INSERT INTO tbl (c01, c02) VALUES (0, 'abc');\n+\n+query IIIIII\n+SELECT * FROM tbl, LATERAL (SELECT tbl.c01 AS lat_c01) AS subq CROSS JOIN tbl AS t1 RIGHT JOIN tbl AS t2 USING (c02);\n+----\n+0\tabc\t0\t0\tabc\t0\n+\n+query IIIII\n+SELECT * FROM tbl, LATERAL (SELECT tbl.c01 AS lat_c01) AS subq CROSS JOIN tbl AS t1 RIGHT JOIN tbl AS t2 USING (c02, c01);\n+----\n+0\tabc\t0\t0\tabc\ndiff --git a/test/fuzzer/public/regex_range_filter_mismatch.test b/test/fuzzer/public/regex_range_filter_mismatch.test\nnew file mode 100644\nindex 000000000000..d7203f62f9b8\n--- /dev/null\n+++ b/test/fuzzer/public/regex_range_filter_mismatch.test\n@@ -0,0 +1,13 @@\n+# name: test/fuzzer/public/regex_range_filter_mismatch.test\n+# description: Type mismatch in regex range filter optimizer\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE v00 ( c01 INTEGER ) ;\n+\n+query I\n+SELECT * FROM v00 WHERE concat(c01 IS NOT NULL, 'string') SIMILAR TO 'string';\n+----\ndiff --git a/test/fuzzer/public/semi_anti_join_using.test b/test/fuzzer/public/semi_anti_join_using.test\nnew file mode 100644\nindex 000000000000..d925080f7a02\n--- /dev/null\n+++ b/test/fuzzer/public/semi_anti_join_using.test\n@@ -0,0 +1,21 @@\n+# name: test/fuzzer/public/semi_anti_join_using.test\n+# description: Test semi/anti join in combination with USING columns\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE v00 (c01 INT);\n+\n+statement ok\n+INSERT INTO v00 VALUES (42);\n+\n+query I\n+SELECT c01 FROM ( v00 AS ta03 SEMI JOIN ( v00 AS ta04 JOIN v00 AS ta05 USING ( c01 ) ) ON 42 ) ;\n+----\n+42\n+\n+query I\n+SELECT c01 FROM ( v00 AS ta03 ANTI JOIN ( v00 AS ta04 JOIN v00 AS ta05 USING ( c01 ) ) ON 42 ) ;\n+----\ndiff --git a/test/fuzzer/public/unpivot_partial_values.test b/test/fuzzer/public/unpivot_partial_values.test\nnew file mode 100644\nindex 000000000000..1937f2bea8f9\n--- /dev/null\n+++ b/test/fuzzer/public/unpivot_partial_values.test\n@@ -0,0 +1,9 @@\n+# name: test/fuzzer/public/unpivot_partial_values.test\n+# description: Test UNPIVOT on a row that contains a mix of expressions and values\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+FROM (SELECT 42 c1) AS ta06 UNPIVOT (c1 FOR 'v' IN ( ( c1, 'a' || 'b' ) ) ) ;\ndiff --git a/test/fuzzer/public/window_subquery_error.test b/test/fuzzer/public/window_subquery_error.test\nnew file mode 100644\nindex 000000000000..12dc78c59c62\n--- /dev/null\n+++ b/test/fuzzer/public/window_subquery_error.test\n@@ -0,0 +1,14 @@\n+# name: test/fuzzer/public/window_subquery_error.test\n+# description: Test window function with a subquery that generates an error message\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE v00 (c01 INT, c02 STRING);\n+\n+statement error\n+SELECT 'string' IN ( SELECT string_agg ('str') OVER ( PARTITION BY c02 + 'string' IN ( SELECT 'string' )) );\n+----\n+correlated columns in window functions not supported\ndiff --git a/test/sql/vacuum/vacuum_nested_types.test b/test/sql/vacuum/vacuum_nested_types.test\nindex 5c8627983855..955fe69f47ea 100644\n--- a/test/sql/vacuum/vacuum_nested_types.test\n+++ b/test/sql/vacuum/vacuum_nested_types.test\n@@ -6,7 +6,7 @@ statement ok\n CREATE TABLE test (x INT[], y AS (x || [100]));\n \n statement ok\n-ANALYZE test(y, x);\n+ANALYZE test(x);\n \n statement ok\n INSERT INTO test SELECT [range % 5000] FROM range(10000);\ndiff --git a/tools/shell/tests/test_shell_basics.py b/tools/shell/tests/test_shell_basics.py\nindex 7cd0984e9407..f888d752ad64 100644\n--- a/tools/shell/tests/test_shell_basics.py\n+++ b/tools/shell/tests/test_shell_basics.py\n@@ -1035,4 +1035,10 @@ def test_decimal_sep(shell):\n     result.check_stdout(\"10.5\")\n     result.check_stdout(\"current decimal separator\")\n \n+def test_prepared_statement(shell):\n+    test = ShellTest(shell).statement(\"select ?\")\n+    result = test.run()\n+    result.check_stderr(\"Prepared statement parameters cannot be used directly\")\n+\n+\n # fmt: on\n",
  "problem_statement": "DuckDB Assertion Failure: comparison_operators.cpp on line 226: left.GetType() == right.GetType() && result.GetType() == LogicalType::BOOLEAN\n### What happens?\r\n\r\nThe latest version of the DuckDB (latest main: v1.1.4-dev3741 ab8c909857) triggers Assertion Failure when running the following SQL statement: \r\n\r\n```sql\r\nCREATE TABLE v00 ( c01 INT ) ;\r\nSELECT * FROM v00 WHERE c01 IS NOT NULL ->> 'string' SIMILAR TO 'string';\r\n```\r\n\r\nHere is the stack trace: \r\n\r\n```\r\ncomparison_operators.cpp on line 226: left.GetType() == right.GetType() && result.GetType() == LogicalType::BOOLEAN\r\n\r\n#0  duckdb::InternalException::InternalException (this=0x60d0000251e0, Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nmsg=) at /home/duckdb/duckdb/src/common/exception.cpp:320\r\n#1  0x00000000020c1089 in duckdb::InternalException::InternalException<char const*, int, char const*> (this=0x60d0000251e0, msg=...,\r\n    params=<optimized out>, params=<optimized out>, params=<optimized out>) at ../../src/include/duckdb/common/exception.hpp:313\r\n#2  0x0000000001e672b1 in duckdb::DuckDBAssertInternal (condition=<optimized out>, condition_name=<optimized out>, file=<optimized out>,\r\n    linenr=<optimized out>) at /home/duckdb/duckdb/src/common/assert.cpp:13\r\n#3  0x0000000001b6ef0a in duckdb::ComparisonExecutor::Execute<duckdb::GreaterThanEquals> (left=..., right=..., result=..., count=<optimized out>)\r\n    at ../../src/common/vector_operations/comparison_operators.cpp:226\r\n#4  0x0000000002734cad in duckdb::ExpressionExecutor::Execute (this=0x7ffd491d6c00, expr=..., state=<optimized out>, sel=<optimized out>,\r\n    count=<optimized out>, result=...) at /home/duckdb/duckdb/src/execution/expression_executor/execute_comparison.cpp:49\r\n#5  0x00000000030afb5a in duckdb::ExpressionExecutor::Execute (this=0x7ffd491d6c00, expr=..., state=<optimized out>, sel=<optimized out>,\r\n    count=<optimized out>, result=...) at /home/duckdb/duckdb/src/execution/expression_executor.cpp:208\r\n#6  0x00000000030ace07 in duckdb::ExpressionExecutor::ExecuteExpression (this=<optimized out>, expr_idx=<optimized out>, result=...)\r\n    at /home/duckdb/duckdb/src/execution/expression_executor.cpp:102\r\n#7  0x00000000030ad61d in duckdb::ExpressionExecutor::ExecuteExpression (this=<optimized out>, result=...)\r\n    at /home/duckdb/duckdb/src/execution/expression_executor.cpp:96\r\n#8  0x00000000030b233e in duckdb::ExpressionExecutor::EvaluateScalar (context=..., expr=..., allow_unfoldable=<optimized out>)\r\n    at /home/duckdb/duckdb/src/execution/expression_executor.cpp:112\r\n#9  0x000000000b127756 in duckdb::StatisticsPropagator::PropagateExpression (this=0x7ffd491d8760, expr=..., expr_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics/expression/propagate_conjunction.cpp:22\r\n#10 0x0000000005859520 in duckdb::StatisticsPropagator::PropagateExpression (this=0x7ffd491d8760, expr=..., expr_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics_propagator.cpp:107\r\n#11 0x000000000585b415 in duckdb::StatisticsPropagator::PropagateExpression (this=0x7ffd491d8760, expr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics_propagator.cpp:128\r\n#12 0x000000000b148a40 in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, filter=..., node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics/operator/propagate_filter.cpp:239\r\n#13 0x00000000058573b7 in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, node=..., node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics_propagator.cpp:51\r\n#14 0x0000000005855e58 in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics_propagator.cpp:94\r\n#15 0x000000000b161e28 in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, proj=..., node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics/operator/propagate_projection.cpp:9\r\n#16 0x000000000585716c in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, node=..., node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics_propagator.cpp:57\r\n#17 0x0000000005855e58 in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics_propagator.cpp:94\r\n#18 0x000000000b1481f1 in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, filter=..., node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics/operator/propagate_filter.cpp:230\r\n#19 0x00000000058573b7 in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, node=..., node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics_propagator.cpp:51\r\n#20 0x0000000005855e58 in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics_propagator.cpp:94\r\n#21 0x000000000b161e28 in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, proj=..., node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics/operator/propagate_projection.cpp:9\r\n#22 0x000000000585716c in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, node=..., node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics_propagator.cpp:57\r\n#23 0x0000000005855e58 in duckdb::StatisticsPropagator::PropagateStatistics (this=0x7ffd491d8760, node_ptr=...)\r\n    at /home/duckdb/duckdb/src/optimizer/statistics_propagator.cpp:94\r\n#24 0x00000000058ceb31 in duckdb::Optimizer::RunBuiltInOptimizers()::$_31::operator()() const (this=0x7ffd491d91a0)\r\n    at /home/duckdb/duckdb/src/optimizer/optimizer.cpp:234\r\n#25 std::_Function_handler<void (), duckdb::Optimizer::RunBuiltInOptimizers()::$_31>::_M_invoke(std::_Any_data const&) (__functor=...) at /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/std_function.h:300\r\n#26 0x00000000058248e6 in duckdb::Optimizer::RunOptimizer(duckdb::OptimizerType, std::function<void ()> const&) (this=0x7ffd491d9840, type=<optimized out>, callback=...) at /home/duckdb/duckdb/src/optimizer/optimizer.cpp:89\r\n#27 0x0000000005829ee2 in duckdb::Optimizer::RunBuiltInOptimizers (this=<optimized out>) at /home/duckdb/duckdb/src/optimizer/optimizer.cpp:232\r\n#28 0x000000000582c57f in duckdb::Optimizer::Optimize (this=0x7ffd491d9840, plan_p=...) at /home/duckdb/duckdb/src/optimizer/optimizer.cpp:268\r\n#29 0x00000000035f3604 in duckdb::ClientContext::CreatePreparedStatementInternal (this=0x616000080190, lock=..., query=..., statement=..., values=...) at /home/duckdb/duckdb/src/main/client_context.cpp:363\r\n#30 0x00000000035f9584 in duckdb::ClientContext::CreatePreparedStatement (this=0x616000080190, lock=..., query=..., statement=..., values=..., mode=<optimized out>) at /home/duckdb/duckdb/src/main/client_context.cpp:430\r\n#31 0x000000000361b5ea in duckdb::ClientContext::PendingStatementInternal (this=0x616000080190, lock=..., query=..., statement=..., parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:749\r\n#32 0x0000000003628214 in duckdb::ClientContext::PendingStatementOrPreparedStatement (this=0x616000080190, lock=..., query=..., statement=..., prepared=..., parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:867\r\n#33 0x0000000003616cf8 in duckdb::ClientContext::PendingStatementOrPreparedStatementInternal (this=0x616000080190, lock=..., query=..., statement=..., prepared=..., parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:841\r\n#34 0x000000000361ea4b in duckdb::ClientContext::PendingQueryInternal (this=0x616000080190, lock=..., statement=..., parameters=..., verify=<optimized out>) at /home/duckdb/duckdb/src/main/client_context.cpp:1058\r\n#35 0x0000000003634b0e in duckdb::ClientContext::PendingQuery (this=0x616000080190, statement=..., values=..., allow_stream_result=<optimized out>) at /home/duckdb/duckdb/src/main/client_context.cpp:1045\r\n#36 0x000000000362c020 in duckdb::ClientContext::PendingQuery (this=0x616000080190, statement=..., allow_stream_result=<optimized out>) at /home/duckdb/duckdb/src/main/client_context.cpp:1005\r\n#37 0x000000000367b5a8 in duckdb::Connection::PendingQuery (this=<optimized out>, statement=..., allow_stream_result=<optimized out>) at /home/duckdb/duckdb/src/main/connection.cpp:140\r\n#38 0x000000000071a344 in duckdb_shell_sqlite3_prepare_v2 (db=0x60f0000006d0, zSql=<optimized out>, nByte=<optimized out>, ppStmt=<optimized out>, pzTail=<optimized out>) at ../../tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:224\r\n#39 0x00000000006720f6 in duckdb_shell::ShellState::ExecuteSQL (this=0x7ffd491dbcc0, zSql=0x60d0000005f0 \"SELECT * FROM v00 WHERE c01 IS NOT NULL ->> 'string' SIMILAR TO 'string';\", pzErrMsg=<optimized out>) at ../../tools/shell/shell.cpp:3524\r\n#40 0x000000000069d6b3 in duckdb_shell::ShellState::RunOneSqlLine (this=<optimized out>, zSql=<optimized out>) at ../../tools/shell/shell.cpp:8706\r\n#41 0x0000000000692c74 in duckdb_shell::ShellState::ProcessInput (this=0x7ffd491dbcc0) at ../../tools/shell/shell.cpp:8936\r\n#42 0x00000000006a396d in main (argc=<optimized out>, argv=<optimized out>) at ../../tools/shell/shell.cpp:10152\r\n```\r\n\r\n### To Reproduce\r\n\r\n1. Clone the DuckDB Git from the official repo.\r\n2. Checkout to the latest main (v1.1.4-dev3741 ab8c909857).\r\n3. Compile the DuckDB binary by using `make debug`.\r\n4. Run the compiled DuckDB and input the following SQL: \r\n\r\n```sql\r\nCREATE TABLE v00 ( c01 INT ) ;\r\nSELECT * FROM v00 WHERE c01 IS NOT NULL ->> 'string' SIMILAR TO 'string';\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu 24.04 LTS\r\n\r\n### DuckDB Version:\r\n\r\nv1.1.4-dev3741 ab8c909857\r\n\r\n### DuckDB Client:\r\n\r\ncli\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nYu Liang\r\n\r\n### Affiliation:\r\n\r\nThe Pennsylvania State University\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a source build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2025-01-02T22:03:23Z"
}