diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp
index 33f6c1e4f154..e334e504ac16 100644
--- a/src/catalog/catalog_entry/table_catalog_entry.cpp
+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp
@@ -32,7 +32,7 @@ bool TableCatalogEntry::HasGeneratedColumns() const {
 	return columns.LogicalColumnCount() != columns.PhysicalColumnCount();
 }
 
-LogicalIndex TableCatalogEntry::GetColumnIndex(string &column_name, bool if_exists) {
+LogicalIndex TableCatalogEntry::GetColumnIndex(string &column_name, bool if_exists) const {
 	auto entry = columns.GetColumnIndex(column_name);
 	if (!entry.IsValid()) {
 		if (if_exists) {
@@ -43,15 +43,15 @@ LogicalIndex TableCatalogEntry::GetColumnIndex(string &column_name, bool if_exis
 	return entry;
 }
 
-bool TableCatalogEntry::ColumnExists(const string &name) {
+bool TableCatalogEntry::ColumnExists(const string &name) const {
 	return columns.ColumnExists(name);
 }
 
-const ColumnDefinition &TableCatalogEntry::GetColumn(const string &name) {
+const ColumnDefinition &TableCatalogEntry::GetColumn(const string &name) const {
 	return columns.GetColumn(name);
 }
 
-vector<LogicalType> TableCatalogEntry::GetTypes() {
+vector<LogicalType> TableCatalogEntry::GetTypes() const {
 	vector<LogicalType> types;
 	for (auto &col : columns.Physical()) {
 		types.push_back(col.Type());
@@ -185,7 +185,7 @@ const ColumnList &TableCatalogEntry::GetColumns() const {
 	return columns;
 }
 
-const ColumnDefinition &TableCatalogEntry::GetColumn(LogicalIndex idx) {
+const ColumnDefinition &TableCatalogEntry::GetColumn(LogicalIndex idx) const {
 	return columns.GetColumn(idx);
 }
 
diff --git a/src/catalog/default/default_views.cpp b/src/catalog/default/default_views.cpp
index aeec58653d74..6da1854ee356 100644
--- a/src/catalog/default/default_views.cpp
+++ b/src/catalog/default/default_views.cpp
@@ -50,9 +50,9 @@ static const DefaultView internal_views[] = {
     {"information_schema", "schemata", "SELECT database_name catalog_name, schema_name, 'duckdb' schema_owner, NULL::VARCHAR default_character_set_catalog, NULL::VARCHAR default_character_set_schema, NULL::VARCHAR default_character_set_name, sql sql_path FROM duckdb_schemas()"},
     {"information_schema", "tables", "SELECT database_name table_catalog, schema_name table_schema, table_name, CASE WHEN temporary THEN 'LOCAL TEMPORARY' ELSE 'BASE TABLE' END table_type, NULL::VARCHAR self_referencing_column_name, NULL::VARCHAR reference_generation, NULL::VARCHAR user_defined_type_catalog, NULL::VARCHAR user_defined_type_schema, NULL::VARCHAR user_defined_type_name, 'YES' is_insertable_into, 'NO' is_typed, CASE WHEN temporary THEN 'PRESERVE' ELSE NULL END commit_action, comment AS TABLE_COMMENT FROM duckdb_tables() UNION ALL SELECT database_name table_catalog, schema_name table_schema, view_name table_name, 'VIEW' table_type, NULL self_referencing_column_name, NULL reference_generation, NULL user_defined_type_catalog, NULL user_defined_type_schema, NULL user_defined_type_name, 'NO' is_insertable_into, 'NO' is_typed, NULL commit_action, comment AS TABLE_COMMENT FROM duckdb_views;"},
 	{"information_schema", "character_sets", "SELECT NULL::VARCHAR character_set_catalog, NULL::VARCHAR character_set_schema, 'UTF8' character_set_name, 'UCS' character_repertoire, 'UTF8' form_of_use, current_database() default_collate_catalog, 'pg_catalog' default_collate_schema, 'ucs_basic' default_collate_name;"},
-	{"information_schema", "referential_constraints", "SELECT f.database_name constraint_catalog, f.schema_name constraint_schema, concat(f.table_name, '_', f.source, '_fkey') constraint_name, current_database() unique_constraint_catalog, c.schema_name unique_constraint_schema, concat(c.table_name, '_', f.target_column, '_', CASE WHEN c.constraint_type == 'UNIQUE' THEN 'key' ELSE 'pkey' END) unique_constraint_name, 'NONE' match_option, 'NO ACTION' update_rule, 'NO ACTION' delete_rule FROM duckdb_constraints() c JOIN (SELECT *, name_extract['source'] as source, name_extract['target'] as target, name_extract['target_column'] as target_column FROM (SELECT *, regexp_extract(constraint_text, 'FOREIGN KEY \\(([a-zA-Z_0-9]+)\\) REFERENCES ([a-zA-Z_0-9]+)\\(([a-zA-Z_0-9]+)\\)', ['source', 'target', 'target_column']) name_extract FROM duckdb_constraints() WHERE constraint_type = 'FOREIGN KEY')) f ON name_extract['target'] = c.table_name AND (c.constraint_type = 'UNIQUE' OR c.constraint_type = 'PRIMARY KEY')"},
-	{"information_schema", "key_column_usage", "SELECT current_database() constraint_catalog, schema_name constraint_schema, concat(table_name, '_', constraint_column_names[1], CASE constraint_type WHEN 'FOREIGN KEY' THEN '_fkey' WHEN 'PRIMARY KEY' THEN '_pkey' ELSE '_key' END) constraint_name, current_database() table_catalog, schema_name table_schema, table_name, constraint_column_names[1] column_name, 1 ordinal_position, CASE constraint_type WHEN 'FOREIGN KEY' THEN 1 ELSE NULL END position_in_unique_constraint FROM duckdb_constraints() WHERE constraint_type = 'FOREIGN KEY' OR constraint_type = 'PRIMARY KEY' OR constraint_type = 'UNIQUE';"},
-	{"information_schema", "table_constraints", "SELECT current_database() constraint_catalog, schema_name constraint_schema, concat(table_name, '_', CASE WHEN length(constraint_column_names) > 1 THEN NULL ELSE constraint_column_names[1] || '_' END, CASE constraint_type WHEN 'FOREIGN KEY' THEN 'fkey' WHEN 'PRIMARY KEY' THEN 'pkey' WHEN 'UNIQUE' THEN 'key' WHEN 'CHECK' THEN 'check' WHEN 'NOT NULL' THEN 'not_null'  END) constraint_name, current_database() table_catalog, schema_name table_schema, table_name, CASE constraint_type WHEN 'NOT NULL' THEN 'CHECK' ELSE constraint_type END constraint_type, 'NO' is_deferrable, 'NO' initially_deferred, 'YES' enforced, 'YES' nulls_distinct FROM duckdb_constraints() WHERE constraint_type = 'PRIMARY KEY' OR constraint_type = 'FOREIGN KEY' OR constraint_type = 'UNIQUE' OR constraint_type = 'CHECK' OR constraint_type = 'NOT NULL';"},
+	{"information_schema", "referential_constraints", "SELECT f.database_name constraint_catalog, f.schema_name constraint_schema, f.constraint_name constraint_name, c.database_name unique_constraint_catalog, c.schema_name unique_constraint_schema, c.constraint_name unique_constraint_name, 'NONE' match_option, 'NO ACTION' update_rule, 'NO ACTION' delete_rule FROM duckdb_constraints() c, duckdb_constraints() f WHERE f.constraint_type = 'FOREIGN KEY' AND (c.constraint_type = 'UNIQUE' OR c.constraint_type = 'PRIMARY KEY') AND f.database_oid = c.database_oid AND f.schema_oid = c.schema_oid AND lower(f.referenced_table) = lower(c.table_name) AND [lower(x) for x in f.referenced_column_names] = [lower(x) for x in c.constraint_column_names]"},
+	{"information_schema", "key_column_usage", "SELECT database_name constraint_catalog, schema_name constraint_schema, constraint_name, database_name table_catalog, schema_name table_schema, table_name, UNNEST(constraint_column_names) column_name, UNNEST(generate_series(1, len(constraint_column_names))) ordinal_position, CASE constraint_type WHEN 'FOREIGN KEY' THEN 1 ELSE NULL END position_in_unique_constraint FROM duckdb_constraints() WHERE constraint_type = 'FOREIGN KEY' OR constraint_type = 'PRIMARY KEY' OR constraint_type = 'UNIQUE';"},
+	{"information_schema", "table_constraints", "SELECT database_name constraint_catalog, schema_name constraint_schema, constraint_name, database_name table_catalog, schema_name table_schema, table_name, CASE constraint_type WHEN 'NOT NULL' THEN 'CHECK' ELSE constraint_type END constraint_type, 'NO' is_deferrable, 'NO' initially_deferred, 'YES' enforced, 'YES' nulls_distinct FROM duckdb_constraints() WHERE constraint_type = 'PRIMARY KEY' OR constraint_type = 'FOREIGN KEY' OR constraint_type = 'UNIQUE' OR constraint_type = 'CHECK' OR constraint_type = 'NOT NULL';"},
     {nullptr, nullptr, nullptr}};
 
 static unique_ptr<CreateViewInfo> GetDefaultView(ClientContext &context, const string &input_schema, const string &input_name) {
diff --git a/src/function/table/system/duckdb_constraints.cpp b/src/function/table/system/duckdb_constraints.cpp
index 71fabb16b5ce..b422f61badbf 100644
--- a/src/function/table/system/duckdb_constraints.cpp
+++ b/src/function/table/system/duckdb_constraints.cpp
@@ -1,52 +1,19 @@
-#include "duckdb/function/table/system_functions.hpp"
-
 #include "duckdb/catalog/catalog.hpp"
 #include "duckdb/catalog/catalog_entry/duck_table_entry.hpp"
 #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
 #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
 #include "duckdb/common/exception.hpp"
+#include "duckdb/function/table/system_functions.hpp"
 #include "duckdb/main/client_context.hpp"
 #include "duckdb/main/client_data.hpp"
 #include "duckdb/parser/constraint.hpp"
 #include "duckdb/parser/constraints/check_constraint.hpp"
+#include "duckdb/parser/constraints/foreign_key_constraint.hpp"
+#include "duckdb/parser/constraints/not_null_constraint.hpp"
 #include "duckdb/parser/constraints/unique_constraint.hpp"
-#include "duckdb/planner/constraints/bound_unique_constraint.hpp"
-#include "duckdb/planner/constraints/bound_check_constraint.hpp"
-#include "duckdb/planner/constraints/bound_not_null_constraint.hpp"
-#include "duckdb/planner/constraints/bound_foreign_key_constraint.hpp"
-#include "duckdb/storage/data_table.hpp"
 #include "duckdb/planner/binder.hpp"
-
-namespace duckdb {
-
-struct UniqueKeyInfo {
-	string schema;
-	string table;
-	vector<LogicalIndex> columns;
-
-	bool operator==(const UniqueKeyInfo &other) const {
-		return (schema == other.schema) && (table == other.table) && (columns == other.columns);
-	}
-};
-
-} // namespace duckdb
-
-namespace std {
-
-template <>
-struct hash<duckdb::UniqueKeyInfo> {
-	template <class X>
-	static size_t ComputeHash(const X &x) {
-		return hash<X>()(x);
-	}
-
-	size_t operator()(const duckdb::UniqueKeyInfo &j) const {
-		D_ASSERT(j.columns.size() > 0);
-		return ComputeHash(j.schema) + ComputeHash(j.table) + ComputeHash(j.columns[0].index);
-	}
-};
-
-} // namespace std
+#include "duckdb/planner/constraints/bound_check_constraint.hpp"
+#include "duckdb/parser/parsed_expression_iterator.hpp"
 
 namespace duckdb {
 
@@ -71,7 +38,7 @@ struct DuckDBConstraintsData : public GlobalTableFunctionState {
 	idx_t offset;
 	idx_t constraint_offset;
 	idx_t unique_constraint_offset;
-	unordered_map<UniqueKeyInfo, idx_t> known_fk_unique_constraint_offsets;
+	case_insensitive_set_t constraint_names;
 };
 
 static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, TableFunctionBindInput &input,
@@ -94,6 +61,9 @@ static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, Ta
 	names.emplace_back("table_oid");
 	return_types.emplace_back(LogicalType::BIGINT);
 
+	names.emplace_back("constraint_name");
+	return_types.emplace_back(LogicalType::VARCHAR);
+
 	names.emplace_back("constraint_index");
 	return_types.emplace_back(LogicalType::BIGINT);
 
@@ -108,11 +78,18 @@ static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, Ta
 	return_types.emplace_back(LogicalType::VARCHAR);
 
 	names.emplace_back("constraint_column_indexes");
-	return_types.push_back(LogicalType::LIST(LogicalType::BIGINT));
+	return_types.push_back(LogicalType::LIST(LogicalType::UBIGINT));
 
 	names.emplace_back("constraint_column_names");
 	return_types.push_back(LogicalType::LIST(LogicalType::VARCHAR));
 
+	// FOREIGN KEY
+	names.emplace_back("referenced_table");
+	return_types.emplace_back(LogicalType::VARCHAR);
+
+	names.emplace_back("referenced_column_names");
+	return_types.push_back(LogicalType::LIST(LogicalType::VARCHAR));
+
 	return nullptr;
 }
 
@@ -140,6 +117,97 @@ unique_ptr<GlobalTableFunctionState> DuckDBConstraintsInit(ClientContext &contex
 	return std::move(result);
 }
 
+struct ExtraConstraintInfo {
+	vector<LogicalIndex> column_indexes;
+	vector<string> column_names;
+	string referenced_table;
+	vector<string> referenced_columns;
+};
+
+void ExtractReferencedColumns(const ParsedExpression &expr, vector<string> &result) {
+	if (expr.GetExpressionClass() == ExpressionClass::COLUMN_REF) {
+		auto &colref = expr.Cast<ColumnRefExpression>();
+		result.push_back(colref.GetColumnName());
+	}
+	ParsedExpressionIterator::EnumerateChildren(
+	    expr, [&](const ParsedExpression &child) { ExtractReferencedColumns(child, result); });
+}
+
+ExtraConstraintInfo GetExtraConstraintInfo(const TableCatalogEntry &table, const Constraint &constraint) {
+	ExtraConstraintInfo result;
+	switch (constraint.type) {
+	case ConstraintType::CHECK: {
+		auto &check_constraint = constraint.Cast<CheckConstraint>();
+		ExtractReferencedColumns(*check_constraint.expression, result.column_names);
+		break;
+	}
+	case ConstraintType::NOT_NULL: {
+		auto &not_null_constraint = constraint.Cast<NotNullConstraint>();
+		result.column_indexes.push_back(not_null_constraint.index);
+		break;
+	}
+	case ConstraintType::UNIQUE: {
+		auto &unique = constraint.Cast<UniqueConstraint>();
+		if (unique.HasIndex()) {
+			result.column_indexes.push_back(unique.GetIndex());
+		} else {
+			result.column_names = unique.GetColumnNames();
+		}
+		break;
+	}
+	case ConstraintType::FOREIGN_KEY: {
+		auto &fk = constraint.Cast<ForeignKeyConstraint>();
+		result.referenced_columns = fk.pk_columns;
+		result.referenced_table = fk.info.table;
+		result.column_names = fk.fk_columns;
+		break;
+	}
+	default:
+		throw InternalException("Unsupported type for constraint name");
+	}
+	if (result.column_indexes.empty()) {
+		// generate column indexes from names
+		for (auto &name : result.column_names) {
+			result.column_indexes.push_back(table.GetColumnIndex(name));
+		}
+	} else {
+		// generate names from column indexes
+		for (auto &index : result.column_indexes) {
+			result.column_names.push_back(table.GetColumn(index).GetName());
+		}
+	}
+	return result;
+}
+
+string GetConstraintName(const TableCatalogEntry &table, Constraint &constraint, const ExtraConstraintInfo &info) {
+	string result = table.name + "_";
+	for (auto &col : info.column_names) {
+		result += StringUtil::Lower(col) + "_";
+	}
+	for (auto &col : info.referenced_columns) {
+		result += StringUtil::Lower(col) + "_";
+	}
+	switch (constraint.type) {
+	case ConstraintType::CHECK:
+		result += "check";
+		break;
+	case ConstraintType::NOT_NULL:
+		result += "not_null";
+		break;
+	case ConstraintType::UNIQUE: {
+		auto &unique = constraint.Cast<UniqueConstraint>();
+		result += unique.IsPrimaryKey() ? "pkey" : "key";
+		break;
+	}
+	case ConstraintType::FOREIGN_KEY:
+		result += "fkey";
+		break;
+	default:
+		throw InternalException("Unsupported type for constraint name");
+	}
+	return result;
+}
+
 void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {
 	auto &data = data_p.global_state->Cast<DuckDBConstraintsData>();
 	if (data.offset >= data.entries.size()) {
@@ -154,7 +222,6 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_
 
 		auto &table = entry.table;
 		auto &constraints = table.GetConstraints();
-		bool is_duck_table = table.IsDuckTable();
 		for (; data.constraint_offset < constraints.size() && count < STANDARD_VECTOR_SIZE; data.constraint_offset++) {
 			auto &constraint = constraints[data.constraint_offset];
 			// return values:
@@ -174,12 +241,8 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_
 				constraint_type = "NOT NULL";
 				break;
 			case ConstraintType::FOREIGN_KEY: {
-				if (!is_duck_table) {
-					continue;
-				}
-				auto &bound_constraints = entry.bound_constraints;
-				auto &bound_foreign_key = bound_constraints[data.constraint_offset]->Cast<BoundForeignKeyConstraint>();
-				if (bound_foreign_key.info.type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE) {
+				auto &fk = constraint->Cast<ForeignKeyConstraint>();
+				if (fk.info.type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE) {
 					// Those are already covered by PRIMARY KEY and UNIQUE entries
 					continue;
 				}
@@ -204,52 +267,24 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_
 			// table_oid, LogicalType::BIGINT
 			output.SetValue(col++, count, Value::BIGINT(NumericCast<int64_t>(table.oid)));
 
-			// constraint_index, BIGINT
-			UniqueKeyInfo uk_info;
-
-			if (is_duck_table) {
-				auto &bound_constraint = *entry.bound_constraints[data.constraint_offset];
-				switch (bound_constraint.type) {
-				case ConstraintType::UNIQUE: {
-					auto &bound_unique = bound_constraint.Cast<BoundUniqueConstraint>();
-					uk_info = {table.schema.name, table.name, bound_unique.keys};
-					break;
-				}
-				case ConstraintType::FOREIGN_KEY: {
-					const auto &bound_foreign_key = bound_constraint.Cast<BoundForeignKeyConstraint>();
-					const auto &info = bound_foreign_key.info;
-					// find the other table
-					auto table_entry = Catalog::GetEntry<TableCatalogEntry>(
-					    context, table.catalog.GetName(), info.schema, info.table, OnEntryNotFound::RETURN_NULL);
-					if (!table_entry) {
-						throw InternalException("dukdb_constraints: entry %s.%s referenced in foreign key not found",
-						                        info.schema, info.table);
-					}
-					vector<LogicalIndex> index;
-					for (auto &key : info.pk_keys) {
-						index.push_back(table_entry->GetColumns().PhysicalToLogical(key));
-					}
-					uk_info = {table_entry->schema.name, table_entry->name, index};
-					break;
-				}
-				default:
-					break;
+			auto info = GetExtraConstraintInfo(table, *constraint);
+			// constraint_name, VARCHAR
+			auto constraint_name = GetConstraintName(table, *constraint, info);
+			if (data.constraint_names.find(constraint_name) != data.constraint_names.end()) {
+				// duplicate constraint name
+				idx_t index = 2;
+				while (data.constraint_names.find(constraint_name + "_" + to_string(index)) !=
+				       data.constraint_names.end()) {
+					index++;
 				}
+				constraint_name += "_" + to_string(index);
 			}
+			output.SetValue(col++, count, Value(std::move(constraint_name)));
 
-			if (uk_info.columns.empty()) {
-				output.SetValue(col++, count, Value::BIGINT(NumericCast<int64_t>(data.unique_constraint_offset++)));
-			} else {
-				auto known_unique_constraint_offset = data.known_fk_unique_constraint_offsets.find(uk_info);
-				if (known_unique_constraint_offset == data.known_fk_unique_constraint_offsets.end()) {
-					data.known_fk_unique_constraint_offsets.insert(make_pair(uk_info, data.unique_constraint_offset));
-					output.SetValue(col++, count, Value::BIGINT(NumericCast<int64_t>(data.unique_constraint_offset)));
-					data.unique_constraint_offset++;
-				} else {
-					output.SetValue(col++, count,
-					                Value::BIGINT(NumericCast<int64_t>(known_unique_constraint_offset->second)));
-				}
-			}
+			// constraint_index, BIGINT
+			output.SetValue(col++, count, Value::BIGINT(NumericCast<int64_t>(data.unique_constraint_offset++)));
+
+			// constraint_type, VARCHAR
 			output.SetValue(col++, count, Value(constraint_type));
 
 			// constraint_text, VARCHAR
@@ -263,54 +298,31 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_
 			}
 			output.SetValue(col++, count, expression_text);
 
-			vector<LogicalIndex> column_index_list;
-			if (is_duck_table) {
-				auto &bound_constraint = *entry.bound_constraints[data.constraint_offset];
-				switch (bound_constraint.type) {
-				case ConstraintType::CHECK: {
-					auto &bound_check = bound_constraint.Cast<BoundCheckConstraint>();
-					for (auto &col_idx : bound_check.bound_columns) {
-						column_index_list.push_back(table.GetColumns().PhysicalToLogical(col_idx));
-					}
-					break;
-				}
-				case ConstraintType::UNIQUE: {
-					auto &bound_unique = bound_constraint.Cast<BoundUniqueConstraint>();
-					for (auto &col_idx : bound_unique.keys) {
-						column_index_list.push_back(col_idx);
-					}
-					break;
-				}
-				case ConstraintType::NOT_NULL: {
-					auto &bound_not_null = bound_constraint.Cast<BoundNotNullConstraint>();
-					column_index_list.push_back(table.GetColumns().PhysicalToLogical(bound_not_null.index));
-					break;
-				}
-				case ConstraintType::FOREIGN_KEY: {
-					auto &bound_foreign_key = bound_constraint.Cast<BoundForeignKeyConstraint>();
-					for (auto &col_idx : bound_foreign_key.info.fk_keys) {
-						column_index_list.push_back(table.GetColumns().PhysicalToLogical(col_idx));
-					}
-					break;
-				}
-				default:
-					throw NotImplementedException("Unimplemented constraint for duckdb_constraints");
-				}
-			}
-
-			vector<Value> index_list;
+			vector<Value> column_index_list;
 			vector<Value> column_name_list;
-			for (auto column_index : column_index_list) {
-				index_list.push_back(Value::BIGINT(NumericCast<int64_t>(column_index.index)));
-				column_name_list.emplace_back(table.GetColumn(column_index).Name());
+			vector<Value> referenced_column_name_list;
+			for (auto &col_index : info.column_indexes) {
+				column_index_list.push_back(Value::UBIGINT(col_index.index));
+			}
+			for (auto &name : info.column_names) {
+				column_name_list.push_back(Value(std::move(name)));
+			}
+			for (auto &name : info.referenced_columns) {
+				referenced_column_name_list.push_back(Value(std::move(name)));
 			}
 
 			// constraint_column_indexes, LIST
-			output.SetValue(col++, count, Value::LIST(LogicalType::BIGINT, std::move(index_list)));
+			output.SetValue(col++, count, Value::LIST(LogicalType::BIGINT, std::move(column_index_list)));
 
 			// constraint_column_names, LIST
 			output.SetValue(col++, count, Value::LIST(LogicalType::VARCHAR, std::move(column_name_list)));
 
+			// referenced_table, VARCHAR
+			output.SetValue(col++, count,
+			                info.referenced_table.empty() ? Value() : Value(std::move(info.referenced_table)));
+
+			// referenced_column_names, LIST
+			output.SetValue(col++, count, Value::LIST(LogicalType::VARCHAR, std::move(referenced_column_name_list)));
 			count++;
 		}
 		if (data.constraint_offset >= constraints.size()) {
diff --git a/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp b/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp
index 6e8c0f248944..0dd78f3ccb5f 100644
--- a/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp
+++ b/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp
@@ -62,15 +62,15 @@ class TableCatalogEntry : public StandardEntry {
 	DUCKDB_API bool HasGeneratedColumns() const;
 
 	//! Returns whether or not a column with the given name exists
-	DUCKDB_API bool ColumnExists(const string &name);
+	DUCKDB_API bool ColumnExists(const string &name) const;
 	//! Returns a reference to the column of the specified name. Throws an
 	//! exception if the column does not exist.
-	DUCKDB_API const ColumnDefinition &GetColumn(const string &name);
+	DUCKDB_API const ColumnDefinition &GetColumn(const string &name) const;
 	//! Returns a reference to the column of the specified logical index. Throws an
 	//! exception if the column does not exist.
-	DUCKDB_API const ColumnDefinition &GetColumn(LogicalIndex idx);
+	DUCKDB_API const ColumnDefinition &GetColumn(LogicalIndex idx) const;
 	//! Returns a list of types of the table, excluding generated columns
-	DUCKDB_API vector<LogicalType> GetTypes();
+	DUCKDB_API vector<LogicalType> GetTypes() const;
 	//! Returns a list of the columns of the table
 	DUCKDB_API const ColumnList &GetColumns() const;
 	//! Returns the underlying storage of the table
@@ -87,7 +87,7 @@ class TableCatalogEntry : public StandardEntry {
 	//! If the column does not exist:
 	//! If if_column_exists is true, returns DConstants::INVALID_INDEX
 	//! If if_column_exists is false, throws an exception
-	DUCKDB_API LogicalIndex GetColumnIndex(string &name, bool if_exists = false);
+	DUCKDB_API LogicalIndex GetColumnIndex(string &name, bool if_exists = false) const;
 
 	//! Returns the scan function that can be used to scan the given table
 	virtual TableFunction GetScanFunction(ClientContext &context, unique_ptr<FunctionData> &bind_data) = 0;
