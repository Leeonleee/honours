{
  "repo": "duckdb/duckdb",
  "pull_number": 12914,
  "instance_id": "duckdb__duckdb-12914",
  "issue_numbers": [
    "12838"
  ],
  "base_commit": "fd883da87821a3e4a60169df7cba49f29d7a252e",
  "patch": "diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp\nindex 33f6c1e4f154..e334e504ac16 100644\n--- a/src/catalog/catalog_entry/table_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp\n@@ -32,7 +32,7 @@ bool TableCatalogEntry::HasGeneratedColumns() const {\n \treturn columns.LogicalColumnCount() != columns.PhysicalColumnCount();\n }\n \n-LogicalIndex TableCatalogEntry::GetColumnIndex(string &column_name, bool if_exists) {\n+LogicalIndex TableCatalogEntry::GetColumnIndex(string &column_name, bool if_exists) const {\n \tauto entry = columns.GetColumnIndex(column_name);\n \tif (!entry.IsValid()) {\n \t\tif (if_exists) {\n@@ -43,15 +43,15 @@ LogicalIndex TableCatalogEntry::GetColumnIndex(string &column_name, bool if_exis\n \treturn entry;\n }\n \n-bool TableCatalogEntry::ColumnExists(const string &name) {\n+bool TableCatalogEntry::ColumnExists(const string &name) const {\n \treturn columns.ColumnExists(name);\n }\n \n-const ColumnDefinition &TableCatalogEntry::GetColumn(const string &name) {\n+const ColumnDefinition &TableCatalogEntry::GetColumn(const string &name) const {\n \treturn columns.GetColumn(name);\n }\n \n-vector<LogicalType> TableCatalogEntry::GetTypes() {\n+vector<LogicalType> TableCatalogEntry::GetTypes() const {\n \tvector<LogicalType> types;\n \tfor (auto &col : columns.Physical()) {\n \t\ttypes.push_back(col.Type());\n@@ -185,7 +185,7 @@ const ColumnList &TableCatalogEntry::GetColumns() const {\n \treturn columns;\n }\n \n-const ColumnDefinition &TableCatalogEntry::GetColumn(LogicalIndex idx) {\n+const ColumnDefinition &TableCatalogEntry::GetColumn(LogicalIndex idx) const {\n \treturn columns.GetColumn(idx);\n }\n \ndiff --git a/src/catalog/default/default_views.cpp b/src/catalog/default/default_views.cpp\nindex aeec58653d74..6da1854ee356 100644\n--- a/src/catalog/default/default_views.cpp\n+++ b/src/catalog/default/default_views.cpp\n@@ -50,9 +50,9 @@ static const DefaultView internal_views[] = {\n     {\"information_schema\", \"schemata\", \"SELECT database_name catalog_name, schema_name, 'duckdb' schema_owner, NULL::VARCHAR default_character_set_catalog, NULL::VARCHAR default_character_set_schema, NULL::VARCHAR default_character_set_name, sql sql_path FROM duckdb_schemas()\"},\n     {\"information_schema\", \"tables\", \"SELECT database_name table_catalog, schema_name table_schema, table_name, CASE WHEN temporary THEN 'LOCAL TEMPORARY' ELSE 'BASE TABLE' END table_type, NULL::VARCHAR self_referencing_column_name, NULL::VARCHAR reference_generation, NULL::VARCHAR user_defined_type_catalog, NULL::VARCHAR user_defined_type_schema, NULL::VARCHAR user_defined_type_name, 'YES' is_insertable_into, 'NO' is_typed, CASE WHEN temporary THEN 'PRESERVE' ELSE NULL END commit_action, comment AS TABLE_COMMENT FROM duckdb_tables() UNION ALL SELECT database_name table_catalog, schema_name table_schema, view_name table_name, 'VIEW' table_type, NULL self_referencing_column_name, NULL reference_generation, NULL user_defined_type_catalog, NULL user_defined_type_schema, NULL user_defined_type_name, 'NO' is_insertable_into, 'NO' is_typed, NULL commit_action, comment AS TABLE_COMMENT FROM duckdb_views;\"},\n \t{\"information_schema\", \"character_sets\", \"SELECT NULL::VARCHAR character_set_catalog, NULL::VARCHAR character_set_schema, 'UTF8' character_set_name, 'UCS' character_repertoire, 'UTF8' form_of_use, current_database() default_collate_catalog, 'pg_catalog' default_collate_schema, 'ucs_basic' default_collate_name;\"},\n-\t{\"information_schema\", \"referential_constraints\", \"SELECT f.database_name constraint_catalog, f.schema_name constraint_schema, concat(f.table_name, '_', f.source, '_fkey') constraint_name, current_database() unique_constraint_catalog, c.schema_name unique_constraint_schema, concat(c.table_name, '_', f.target_column, '_', CASE WHEN c.constraint_type == 'UNIQUE' THEN 'key' ELSE 'pkey' END) unique_constraint_name, 'NONE' match_option, 'NO ACTION' update_rule, 'NO ACTION' delete_rule FROM duckdb_constraints() c JOIN (SELECT *, name_extract['source'] as source, name_extract['target'] as target, name_extract['target_column'] as target_column FROM (SELECT *, regexp_extract(constraint_text, 'FOREIGN KEY \\\\(([a-zA-Z_0-9]+)\\\\) REFERENCES ([a-zA-Z_0-9]+)\\\\(([a-zA-Z_0-9]+)\\\\)', ['source', 'target', 'target_column']) name_extract FROM duckdb_constraints() WHERE constraint_type = 'FOREIGN KEY')) f ON name_extract['target'] = c.table_name AND (c.constraint_type = 'UNIQUE' OR c.constraint_type = 'PRIMARY KEY')\"},\n-\t{\"information_schema\", \"key_column_usage\", \"SELECT current_database() constraint_catalog, schema_name constraint_schema, concat(table_name, '_', constraint_column_names[1], CASE constraint_type WHEN 'FOREIGN KEY' THEN '_fkey' WHEN 'PRIMARY KEY' THEN '_pkey' ELSE '_key' END) constraint_name, current_database() table_catalog, schema_name table_schema, table_name, constraint_column_names[1] column_name, 1 ordinal_position, CASE constraint_type WHEN 'FOREIGN KEY' THEN 1 ELSE NULL END position_in_unique_constraint FROM duckdb_constraints() WHERE constraint_type = 'FOREIGN KEY' OR constraint_type = 'PRIMARY KEY' OR constraint_type = 'UNIQUE';\"},\n-\t{\"information_schema\", \"table_constraints\", \"SELECT current_database() constraint_catalog, schema_name constraint_schema, concat(table_name, '_', CASE WHEN length(constraint_column_names) > 1 THEN NULL ELSE constraint_column_names[1] || '_' END, CASE constraint_type WHEN 'FOREIGN KEY' THEN 'fkey' WHEN 'PRIMARY KEY' THEN 'pkey' WHEN 'UNIQUE' THEN 'key' WHEN 'CHECK' THEN 'check' WHEN 'NOT NULL' THEN 'not_null'  END) constraint_name, current_database() table_catalog, schema_name table_schema, table_name, CASE constraint_type WHEN 'NOT NULL' THEN 'CHECK' ELSE constraint_type END constraint_type, 'NO' is_deferrable, 'NO' initially_deferred, 'YES' enforced, 'YES' nulls_distinct FROM duckdb_constraints() WHERE constraint_type = 'PRIMARY KEY' OR constraint_type = 'FOREIGN KEY' OR constraint_type = 'UNIQUE' OR constraint_type = 'CHECK' OR constraint_type = 'NOT NULL';\"},\n+\t{\"information_schema\", \"referential_constraints\", \"SELECT f.database_name constraint_catalog, f.schema_name constraint_schema, f.constraint_name constraint_name, c.database_name unique_constraint_catalog, c.schema_name unique_constraint_schema, c.constraint_name unique_constraint_name, 'NONE' match_option, 'NO ACTION' update_rule, 'NO ACTION' delete_rule FROM duckdb_constraints() c, duckdb_constraints() f WHERE f.constraint_type = 'FOREIGN KEY' AND (c.constraint_type = 'UNIQUE' OR c.constraint_type = 'PRIMARY KEY') AND f.database_oid = c.database_oid AND f.schema_oid = c.schema_oid AND lower(f.referenced_table) = lower(c.table_name) AND [lower(x) for x in f.referenced_column_names] = [lower(x) for x in c.constraint_column_names]\"},\n+\t{\"information_schema\", \"key_column_usage\", \"SELECT database_name constraint_catalog, schema_name constraint_schema, constraint_name, database_name table_catalog, schema_name table_schema, table_name, UNNEST(constraint_column_names) column_name, UNNEST(generate_series(1, len(constraint_column_names))) ordinal_position, CASE constraint_type WHEN 'FOREIGN KEY' THEN 1 ELSE NULL END position_in_unique_constraint FROM duckdb_constraints() WHERE constraint_type = 'FOREIGN KEY' OR constraint_type = 'PRIMARY KEY' OR constraint_type = 'UNIQUE';\"},\n+\t{\"information_schema\", \"table_constraints\", \"SELECT database_name constraint_catalog, schema_name constraint_schema, constraint_name, database_name table_catalog, schema_name table_schema, table_name, CASE constraint_type WHEN 'NOT NULL' THEN 'CHECK' ELSE constraint_type END constraint_type, 'NO' is_deferrable, 'NO' initially_deferred, 'YES' enforced, 'YES' nulls_distinct FROM duckdb_constraints() WHERE constraint_type = 'PRIMARY KEY' OR constraint_type = 'FOREIGN KEY' OR constraint_type = 'UNIQUE' OR constraint_type = 'CHECK' OR constraint_type = 'NOT NULL';\"},\n     {nullptr, nullptr, nullptr}};\n \n static unique_ptr<CreateViewInfo> GetDefaultView(ClientContext &context, const string &input_schema, const string &input_name) {\ndiff --git a/src/function/table/system/duckdb_constraints.cpp b/src/function/table/system/duckdb_constraints.cpp\nindex 71fabb16b5ce..b422f61badbf 100644\n--- a/src/function/table/system/duckdb_constraints.cpp\n+++ b/src/function/table/system/duckdb_constraints.cpp\n@@ -1,52 +1,19 @@\n-#include \"duckdb/function/table/system_functions.hpp\"\n-\n #include \"duckdb/catalog/catalog.hpp\"\n #include \"duckdb/catalog/catalog_entry/duck_table_entry.hpp\"\n #include \"duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\"\n #include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n #include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/function/table/system_functions.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n #include \"duckdb/main/client_data.hpp\"\n #include \"duckdb/parser/constraint.hpp\"\n #include \"duckdb/parser/constraints/check_constraint.hpp\"\n+#include \"duckdb/parser/constraints/foreign_key_constraint.hpp\"\n+#include \"duckdb/parser/constraints/not_null_constraint.hpp\"\n #include \"duckdb/parser/constraints/unique_constraint.hpp\"\n-#include \"duckdb/planner/constraints/bound_unique_constraint.hpp\"\n-#include \"duckdb/planner/constraints/bound_check_constraint.hpp\"\n-#include \"duckdb/planner/constraints/bound_not_null_constraint.hpp\"\n-#include \"duckdb/planner/constraints/bound_foreign_key_constraint.hpp\"\n-#include \"duckdb/storage/data_table.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n-\n-namespace duckdb {\n-\n-struct UniqueKeyInfo {\n-\tstring schema;\n-\tstring table;\n-\tvector<LogicalIndex> columns;\n-\n-\tbool operator==(const UniqueKeyInfo &other) const {\n-\t\treturn (schema == other.schema) && (table == other.table) && (columns == other.columns);\n-\t}\n-};\n-\n-} // namespace duckdb\n-\n-namespace std {\n-\n-template <>\n-struct hash<duckdb::UniqueKeyInfo> {\n-\ttemplate <class X>\n-\tstatic size_t ComputeHash(const X &x) {\n-\t\treturn hash<X>()(x);\n-\t}\n-\n-\tsize_t operator()(const duckdb::UniqueKeyInfo &j) const {\n-\t\tD_ASSERT(j.columns.size() > 0);\n-\t\treturn ComputeHash(j.schema) + ComputeHash(j.table) + ComputeHash(j.columns[0].index);\n-\t}\n-};\n-\n-} // namespace std\n+#include \"duckdb/planner/constraints/bound_check_constraint.hpp\"\n+#include \"duckdb/parser/parsed_expression_iterator.hpp\"\n \n namespace duckdb {\n \n@@ -71,7 +38,7 @@ struct DuckDBConstraintsData : public GlobalTableFunctionState {\n \tidx_t offset;\n \tidx_t constraint_offset;\n \tidx_t unique_constraint_offset;\n-\tunordered_map<UniqueKeyInfo, idx_t> known_fk_unique_constraint_offsets;\n+\tcase_insensitive_set_t constraint_names;\n };\n \n static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, TableFunctionBindInput &input,\n@@ -94,6 +61,9 @@ static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, Ta\n \tnames.emplace_back(\"table_oid\");\n \treturn_types.emplace_back(LogicalType::BIGINT);\n \n+\tnames.emplace_back(\"constraint_name\");\n+\treturn_types.emplace_back(LogicalType::VARCHAR);\n+\n \tnames.emplace_back(\"constraint_index\");\n \treturn_types.emplace_back(LogicalType::BIGINT);\n \n@@ -108,11 +78,18 @@ static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, Ta\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \n \tnames.emplace_back(\"constraint_column_indexes\");\n-\treturn_types.push_back(LogicalType::LIST(LogicalType::BIGINT));\n+\treturn_types.push_back(LogicalType::LIST(LogicalType::UBIGINT));\n \n \tnames.emplace_back(\"constraint_column_names\");\n \treturn_types.push_back(LogicalType::LIST(LogicalType::VARCHAR));\n \n+\t// FOREIGN KEY\n+\tnames.emplace_back(\"referenced_table\");\n+\treturn_types.emplace_back(LogicalType::VARCHAR);\n+\n+\tnames.emplace_back(\"referenced_column_names\");\n+\treturn_types.push_back(LogicalType::LIST(LogicalType::VARCHAR));\n+\n \treturn nullptr;\n }\n \n@@ -140,6 +117,97 @@ unique_ptr<GlobalTableFunctionState> DuckDBConstraintsInit(ClientContext &contex\n \treturn std::move(result);\n }\n \n+struct ExtraConstraintInfo {\n+\tvector<LogicalIndex> column_indexes;\n+\tvector<string> column_names;\n+\tstring referenced_table;\n+\tvector<string> referenced_columns;\n+};\n+\n+void ExtractReferencedColumns(const ParsedExpression &expr, vector<string> &result) {\n+\tif (expr.GetExpressionClass() == ExpressionClass::COLUMN_REF) {\n+\t\tauto &colref = expr.Cast<ColumnRefExpression>();\n+\t\tresult.push_back(colref.GetColumnName());\n+\t}\n+\tParsedExpressionIterator::EnumerateChildren(\n+\t    expr, [&](const ParsedExpression &child) { ExtractReferencedColumns(child, result); });\n+}\n+\n+ExtraConstraintInfo GetExtraConstraintInfo(const TableCatalogEntry &table, const Constraint &constraint) {\n+\tExtraConstraintInfo result;\n+\tswitch (constraint.type) {\n+\tcase ConstraintType::CHECK: {\n+\t\tauto &check_constraint = constraint.Cast<CheckConstraint>();\n+\t\tExtractReferencedColumns(*check_constraint.expression, result.column_names);\n+\t\tbreak;\n+\t}\n+\tcase ConstraintType::NOT_NULL: {\n+\t\tauto &not_null_constraint = constraint.Cast<NotNullConstraint>();\n+\t\tresult.column_indexes.push_back(not_null_constraint.index);\n+\t\tbreak;\n+\t}\n+\tcase ConstraintType::UNIQUE: {\n+\t\tauto &unique = constraint.Cast<UniqueConstraint>();\n+\t\tif (unique.HasIndex()) {\n+\t\t\tresult.column_indexes.push_back(unique.GetIndex());\n+\t\t} else {\n+\t\t\tresult.column_names = unique.GetColumnNames();\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase ConstraintType::FOREIGN_KEY: {\n+\t\tauto &fk = constraint.Cast<ForeignKeyConstraint>();\n+\t\tresult.referenced_columns = fk.pk_columns;\n+\t\tresult.referenced_table = fk.info.table;\n+\t\tresult.column_names = fk.fk_columns;\n+\t\tbreak;\n+\t}\n+\tdefault:\n+\t\tthrow InternalException(\"Unsupported type for constraint name\");\n+\t}\n+\tif (result.column_indexes.empty()) {\n+\t\t// generate column indexes from names\n+\t\tfor (auto &name : result.column_names) {\n+\t\t\tresult.column_indexes.push_back(table.GetColumnIndex(name));\n+\t\t}\n+\t} else {\n+\t\t// generate names from column indexes\n+\t\tfor (auto &index : result.column_indexes) {\n+\t\t\tresult.column_names.push_back(table.GetColumn(index).GetName());\n+\t\t}\n+\t}\n+\treturn result;\n+}\n+\n+string GetConstraintName(const TableCatalogEntry &table, Constraint &constraint, const ExtraConstraintInfo &info) {\n+\tstring result = table.name + \"_\";\n+\tfor (auto &col : info.column_names) {\n+\t\tresult += StringUtil::Lower(col) + \"_\";\n+\t}\n+\tfor (auto &col : info.referenced_columns) {\n+\t\tresult += StringUtil::Lower(col) + \"_\";\n+\t}\n+\tswitch (constraint.type) {\n+\tcase ConstraintType::CHECK:\n+\t\tresult += \"check\";\n+\t\tbreak;\n+\tcase ConstraintType::NOT_NULL:\n+\t\tresult += \"not_null\";\n+\t\tbreak;\n+\tcase ConstraintType::UNIQUE: {\n+\t\tauto &unique = constraint.Cast<UniqueConstraint>();\n+\t\tresult += unique.IsPrimaryKey() ? \"pkey\" : \"key\";\n+\t\tbreak;\n+\t}\n+\tcase ConstraintType::FOREIGN_KEY:\n+\t\tresult += \"fkey\";\n+\t\tbreak;\n+\tdefault:\n+\t\tthrow InternalException(\"Unsupported type for constraint name\");\n+\t}\n+\treturn result;\n+}\n+\n void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {\n \tauto &data = data_p.global_state->Cast<DuckDBConstraintsData>();\n \tif (data.offset >= data.entries.size()) {\n@@ -154,7 +222,6 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_\n \n \t\tauto &table = entry.table;\n \t\tauto &constraints = table.GetConstraints();\n-\t\tbool is_duck_table = table.IsDuckTable();\n \t\tfor (; data.constraint_offset < constraints.size() && count < STANDARD_VECTOR_SIZE; data.constraint_offset++) {\n \t\t\tauto &constraint = constraints[data.constraint_offset];\n \t\t\t// return values:\n@@ -174,12 +241,8 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_\n \t\t\t\tconstraint_type = \"NOT NULL\";\n \t\t\t\tbreak;\n \t\t\tcase ConstraintType::FOREIGN_KEY: {\n-\t\t\t\tif (!is_duck_table) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tauto &bound_constraints = entry.bound_constraints;\n-\t\t\t\tauto &bound_foreign_key = bound_constraints[data.constraint_offset]->Cast<BoundForeignKeyConstraint>();\n-\t\t\t\tif (bound_foreign_key.info.type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE) {\n+\t\t\t\tauto &fk = constraint->Cast<ForeignKeyConstraint>();\n+\t\t\t\tif (fk.info.type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE) {\n \t\t\t\t\t// Those are already covered by PRIMARY KEY and UNIQUE entries\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n@@ -204,52 +267,24 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_\n \t\t\t// table_oid, LogicalType::BIGINT\n \t\t\toutput.SetValue(col++, count, Value::BIGINT(NumericCast<int64_t>(table.oid)));\n \n-\t\t\t// constraint_index, BIGINT\n-\t\t\tUniqueKeyInfo uk_info;\n-\n-\t\t\tif (is_duck_table) {\n-\t\t\t\tauto &bound_constraint = *entry.bound_constraints[data.constraint_offset];\n-\t\t\t\tswitch (bound_constraint.type) {\n-\t\t\t\tcase ConstraintType::UNIQUE: {\n-\t\t\t\t\tauto &bound_unique = bound_constraint.Cast<BoundUniqueConstraint>();\n-\t\t\t\t\tuk_info = {table.schema.name, table.name, bound_unique.keys};\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tcase ConstraintType::FOREIGN_KEY: {\n-\t\t\t\t\tconst auto &bound_foreign_key = bound_constraint.Cast<BoundForeignKeyConstraint>();\n-\t\t\t\t\tconst auto &info = bound_foreign_key.info;\n-\t\t\t\t\t// find the other table\n-\t\t\t\t\tauto table_entry = Catalog::GetEntry<TableCatalogEntry>(\n-\t\t\t\t\t    context, table.catalog.GetName(), info.schema, info.table, OnEntryNotFound::RETURN_NULL);\n-\t\t\t\t\tif (!table_entry) {\n-\t\t\t\t\t\tthrow InternalException(\"dukdb_constraints: entry %s.%s referenced in foreign key not found\",\n-\t\t\t\t\t\t                        info.schema, info.table);\n-\t\t\t\t\t}\n-\t\t\t\t\tvector<LogicalIndex> index;\n-\t\t\t\t\tfor (auto &key : info.pk_keys) {\n-\t\t\t\t\t\tindex.push_back(table_entry->GetColumns().PhysicalToLogical(key));\n-\t\t\t\t\t}\n-\t\t\t\t\tuk_info = {table_entry->schema.name, table_entry->name, index};\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tdefault:\n-\t\t\t\t\tbreak;\n+\t\t\tauto info = GetExtraConstraintInfo(table, *constraint);\n+\t\t\t// constraint_name, VARCHAR\n+\t\t\tauto constraint_name = GetConstraintName(table, *constraint, info);\n+\t\t\tif (data.constraint_names.find(constraint_name) != data.constraint_names.end()) {\n+\t\t\t\t// duplicate constraint name\n+\t\t\t\tidx_t index = 2;\n+\t\t\t\twhile (data.constraint_names.find(constraint_name + \"_\" + to_string(index)) !=\n+\t\t\t\t       data.constraint_names.end()) {\n+\t\t\t\t\tindex++;\n \t\t\t\t}\n+\t\t\t\tconstraint_name += \"_\" + to_string(index);\n \t\t\t}\n+\t\t\toutput.SetValue(col++, count, Value(std::move(constraint_name)));\n \n-\t\t\tif (uk_info.columns.empty()) {\n-\t\t\t\toutput.SetValue(col++, count, Value::BIGINT(NumericCast<int64_t>(data.unique_constraint_offset++)));\n-\t\t\t} else {\n-\t\t\t\tauto known_unique_constraint_offset = data.known_fk_unique_constraint_offsets.find(uk_info);\n-\t\t\t\tif (known_unique_constraint_offset == data.known_fk_unique_constraint_offsets.end()) {\n-\t\t\t\t\tdata.known_fk_unique_constraint_offsets.insert(make_pair(uk_info, data.unique_constraint_offset));\n-\t\t\t\t\toutput.SetValue(col++, count, Value::BIGINT(NumericCast<int64_t>(data.unique_constraint_offset)));\n-\t\t\t\t\tdata.unique_constraint_offset++;\n-\t\t\t\t} else {\n-\t\t\t\t\toutput.SetValue(col++, count,\n-\t\t\t\t\t                Value::BIGINT(NumericCast<int64_t>(known_unique_constraint_offset->second)));\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\t// constraint_index, BIGINT\n+\t\t\toutput.SetValue(col++, count, Value::BIGINT(NumericCast<int64_t>(data.unique_constraint_offset++)));\n+\n+\t\t\t// constraint_type, VARCHAR\n \t\t\toutput.SetValue(col++, count, Value(constraint_type));\n \n \t\t\t// constraint_text, VARCHAR\n@@ -263,54 +298,31 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_\n \t\t\t}\n \t\t\toutput.SetValue(col++, count, expression_text);\n \n-\t\t\tvector<LogicalIndex> column_index_list;\n-\t\t\tif (is_duck_table) {\n-\t\t\t\tauto &bound_constraint = *entry.bound_constraints[data.constraint_offset];\n-\t\t\t\tswitch (bound_constraint.type) {\n-\t\t\t\tcase ConstraintType::CHECK: {\n-\t\t\t\t\tauto &bound_check = bound_constraint.Cast<BoundCheckConstraint>();\n-\t\t\t\t\tfor (auto &col_idx : bound_check.bound_columns) {\n-\t\t\t\t\t\tcolumn_index_list.push_back(table.GetColumns().PhysicalToLogical(col_idx));\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tcase ConstraintType::UNIQUE: {\n-\t\t\t\t\tauto &bound_unique = bound_constraint.Cast<BoundUniqueConstraint>();\n-\t\t\t\t\tfor (auto &col_idx : bound_unique.keys) {\n-\t\t\t\t\t\tcolumn_index_list.push_back(col_idx);\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tcase ConstraintType::NOT_NULL: {\n-\t\t\t\t\tauto &bound_not_null = bound_constraint.Cast<BoundNotNullConstraint>();\n-\t\t\t\t\tcolumn_index_list.push_back(table.GetColumns().PhysicalToLogical(bound_not_null.index));\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tcase ConstraintType::FOREIGN_KEY: {\n-\t\t\t\t\tauto &bound_foreign_key = bound_constraint.Cast<BoundForeignKeyConstraint>();\n-\t\t\t\t\tfor (auto &col_idx : bound_foreign_key.info.fk_keys) {\n-\t\t\t\t\t\tcolumn_index_list.push_back(table.GetColumns().PhysicalToLogical(col_idx));\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tdefault:\n-\t\t\t\t\tthrow NotImplementedException(\"Unimplemented constraint for duckdb_constraints\");\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tvector<Value> index_list;\n+\t\t\tvector<Value> column_index_list;\n \t\t\tvector<Value> column_name_list;\n-\t\t\tfor (auto column_index : column_index_list) {\n-\t\t\t\tindex_list.push_back(Value::BIGINT(NumericCast<int64_t>(column_index.index)));\n-\t\t\t\tcolumn_name_list.emplace_back(table.GetColumn(column_index).Name());\n+\t\t\tvector<Value> referenced_column_name_list;\n+\t\t\tfor (auto &col_index : info.column_indexes) {\n+\t\t\t\tcolumn_index_list.push_back(Value::UBIGINT(col_index.index));\n+\t\t\t}\n+\t\t\tfor (auto &name : info.column_names) {\n+\t\t\t\tcolumn_name_list.push_back(Value(std::move(name)));\n+\t\t\t}\n+\t\t\tfor (auto &name : info.referenced_columns) {\n+\t\t\t\treferenced_column_name_list.push_back(Value(std::move(name)));\n \t\t\t}\n \n \t\t\t// constraint_column_indexes, LIST\n-\t\t\toutput.SetValue(col++, count, Value::LIST(LogicalType::BIGINT, std::move(index_list)));\n+\t\t\toutput.SetValue(col++, count, Value::LIST(LogicalType::BIGINT, std::move(column_index_list)));\n \n \t\t\t// constraint_column_names, LIST\n \t\t\toutput.SetValue(col++, count, Value::LIST(LogicalType::VARCHAR, std::move(column_name_list)));\n \n+\t\t\t// referenced_table, VARCHAR\n+\t\t\toutput.SetValue(col++, count,\n+\t\t\t                info.referenced_table.empty() ? Value() : Value(std::move(info.referenced_table)));\n+\n+\t\t\t// referenced_column_names, LIST\n+\t\t\toutput.SetValue(col++, count, Value::LIST(LogicalType::VARCHAR, std::move(referenced_column_name_list)));\n \t\t\tcount++;\n \t\t}\n \t\tif (data.constraint_offset >= constraints.size()) {\ndiff --git a/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp b/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp\nindex 6e8c0f248944..0dd78f3ccb5f 100644\n--- a/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp\n+++ b/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp\n@@ -62,15 +62,15 @@ class TableCatalogEntry : public StandardEntry {\n \tDUCKDB_API bool HasGeneratedColumns() const;\n \n \t//! Returns whether or not a column with the given name exists\n-\tDUCKDB_API bool ColumnExists(const string &name);\n+\tDUCKDB_API bool ColumnExists(const string &name) const;\n \t//! Returns a reference to the column of the specified name. Throws an\n \t//! exception if the column does not exist.\n-\tDUCKDB_API const ColumnDefinition &GetColumn(const string &name);\n+\tDUCKDB_API const ColumnDefinition &GetColumn(const string &name) const;\n \t//! Returns a reference to the column of the specified logical index. Throws an\n \t//! exception if the column does not exist.\n-\tDUCKDB_API const ColumnDefinition &GetColumn(LogicalIndex idx);\n+\tDUCKDB_API const ColumnDefinition &GetColumn(LogicalIndex idx) const;\n \t//! Returns a list of types of the table, excluding generated columns\n-\tDUCKDB_API vector<LogicalType> GetTypes();\n+\tDUCKDB_API vector<LogicalType> GetTypes() const;\n \t//! Returns a list of the columns of the table\n \tDUCKDB_API const ColumnList &GetColumns() const;\n \t//! Returns the underlying storage of the table\n@@ -87,7 +87,7 @@ class TableCatalogEntry : public StandardEntry {\n \t//! If the column does not exist:\n \t//! If if_column_exists is true, returns DConstants::INVALID_INDEX\n \t//! If if_column_exists is false, throws an exception\n-\tDUCKDB_API LogicalIndex GetColumnIndex(string &name, bool if_exists = false);\n+\tDUCKDB_API LogicalIndex GetColumnIndex(string &name, bool if_exists = false) const;\n \n \t//! Returns the scan function that can be used to scan the given table\n \tvirtual TableFunction GetScanFunction(ClientContext &context, unique_ptr<FunctionData> &bind_data) = 0;\n",
  "test_patch": "diff --git a/test/sql/attach/attach_table_constraints.test b/test/sql/attach/attach_table_constraints.test\nnew file mode 100644\nindex 000000000000..fd5144c8ef17\n--- /dev/null\n+++ b/test/sql/attach/attach_table_constraints.test\n@@ -0,0 +1,19 @@\n+# name: test/sql/attach/attach_table_constraints.test\n+# description: Test information_schema.table_constraints with attach\n+# group: [attach]\n+\n+require skip_reload\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+ATTACH '__TEST_DIR__/constraint_test.db' as test\n+\n+statement ok\n+CREATE TABLE test.tbl(i INTEGER PRIMARY KEY);\n+\n+query III\n+select constraint_catalog, table_catalog, table_name from information_schema.table_constraints limit 1\n+----\n+test\ttest\ttbl\n\\ No newline at end of file\ndiff --git a/test/sql/table_function/duckdb_constraints.test b/test/sql/table_function/duckdb_constraints.test\nindex 1c65c3f45ad3..53939decfa9e 100644\n--- a/test/sql/table_function/duckdb_constraints.test\n+++ b/test/sql/table_function/duckdb_constraints.test\n@@ -27,35 +27,35 @@ query IIII\n SELECT table_name, constraint_index, constraint_type, UNNEST(constraint_column_names) col_name FROM duckdb_constraints ORDER BY table_name, constraint_index, col_name\n ----\n fk_integers\t0\tFOREIGN KEY\tj\n-fk_integers_2\t0\tFOREIGN KEY\tk\n-integers\t0\tPRIMARY KEY\ti\n-integers\t1\tCHECK\ti\n-integers\t2\tNOT NULL\ti\n-test\t3\tUNIQUE\ti\n-test\t4\tCHECK\ti\n-test\t4\tCHECK\tk\n+fk_integers_2\t1\tFOREIGN KEY\tk\n+integers\t2\tPRIMARY KEY\ti\n+integers\t3\tCHECK\ti\n+integers\t4\tNOT NULL\ti\n+test\t5\tUNIQUE\ti\n+test\t6\tCHECK\ti\n+test\t6\tCHECK\tk\n \n query II\n SELECT constraint_name, unique_constraint_name FROM information_schema.referential_constraints ORDER BY constraint_name\n ----\n-fk_integers_2_k_fkey\tintegers_i_pkey\n-fk_integers_j_fkey\tintegers_i_pkey\n+fk_integers_2_k_i_fkey\tintegers_i_pkey\n+fk_integers_j_i_fkey\tintegers_i_pkey\n \n query IIII\n SELECT column_name, constraint_name, table_name, position_in_unique_constraint FROM information_schema.key_column_usage ORDER BY constraint_name\n ----\n-k\tfk_integers_2_k_fkey\tfk_integers_2\t1\n-j\tfk_integers_j_fkey\tfk_integers\t1\n+k\tfk_integers_2_k_i_fkey\tfk_integers_2\t1\n+j\tfk_integers_j_i_fkey\tfk_integers\t1\n i\tintegers_i_pkey\tintegers\tNULL\n i\ttest_i_key\ttest\tNULL\n \n query III\n SELECT constraint_name, table_name, constraint_type FROM information_schema.table_constraints ORDER BY constraint_name;\n ----\n-fk_integers_2_k_fkey\tfk_integers_2\tFOREIGN KEY\n-fk_integers_j_fkey\tfk_integers\tFOREIGN KEY\n+fk_integers_2_k_i_fkey\tfk_integers_2\tFOREIGN KEY\n+fk_integers_j_i_fkey\tfk_integers\tFOREIGN KEY\n integers_i_check\tintegers\tCHECK\n integers_i_not_null\tintegers\tCHECK\n integers_i_pkey\tintegers\tPRIMARY KEY\n-test_check\ttest\tCHECK\n-test_i_key\ttest\tUNIQUE\n\\ No newline at end of file\n+test_i_k_check\ttest\tCHECK\n+test_i_key\ttest\tUNIQUE\ndiff --git a/test/sql/table_function/duckdb_constraints_fk.test b/test/sql/table_function/duckdb_constraints_fk.test\nindex 4762935010d1..90648f6e43ad 100644\n--- a/test/sql/table_function/duckdb_constraints_fk.test\n+++ b/test/sql/table_function/duckdb_constraints_fk.test\n@@ -35,20 +35,20 @@ CREATE TABLE tf_4 (\n   FOREIGN KEY (h) REFERENCES tf_3 (h),\n );\n \n-query IIIIIIIII\n-SELECT * EXCLUDE (schema_oid, table_oid, database_oid) FROM duckdb_constraints();\n+query IIIIIIIIIII\n+SELECT * EXCLUDE (schema_oid, table_oid, database_oid, constraint_name) FROM duckdb_constraints();\n ----\n-memory\tmain\ttf_1\t0\tPRIMARY KEY\tPRIMARY KEY(a)\tNULL\t[0]\t[a]\n-memory\tmain\ttf_1\t1\tUNIQUE\tUNIQUE(\"b c\")\tNULL\t[1]\t[b c]\n-memory\tmain\ttf_1\t2\tUNIQUE\tUNIQUE(\"d e\")\tNULL\t[2]\t[d e]\n-memory\tmain\ttf_1\t3\tNOT NULL\tNOT NULL\tNULL\t[0]\t[a]\n-memory\tmain\ttf_2\t4\tPRIMARY KEY\tPRIMARY KEY(c)\tNULL\t[0]\t[c]\n-memory\tmain\ttf_2\t0\tFOREIGN KEY\tFOREIGN KEY (d) REFERENCES tf_1(a)\tNULL\t[1]\t[d]\n-memory\tmain\ttf_2\t1\tFOREIGN KEY\tFOREIGN KEY (e) REFERENCES tf_1(\"b c\")\tNULL\t[2]\t[e]\n-memory\tmain\ttf_2\t2\tFOREIGN KEY\tFOREIGN KEY (f) REFERENCES tf_1(\"d e\")\tNULL\t[3]\t[f]\n-memory\tmain\ttf_2\t5\tFOREIGN KEY\tFOREIGN KEY (g) REFERENCES tf_3(g)\tNULL\t[4]\t[g]\n-memory\tmain\ttf_2\t6\tNOT NULL\tNOT NULL\tNULL\t[0]\t[c]\n-memory\tmain\ttf_3\t5\tPRIMARY KEY\tPRIMARY KEY(g)\tNULL\t[0]\t[g]\n-memory\tmain\ttf_3\t7\tUNIQUE\tUNIQUE(h)\tNULL\t[1]\t[h]\n-memory\tmain\ttf_3\t8\tNOT NULL\tNOT NULL\tNULL\t[0]\t[g]\n-memory\tmain\ttf_4\t7\tFOREIGN KEY\tFOREIGN KEY (h) REFERENCES tf_3(h)\tNULL\t[0]\t[h]\n+memory\tmain\ttf_1\t0\tPRIMARY KEY\tPRIMARY KEY(a)\tNULL\t[0]\t[a]\tNULL\t[]\n+memory\tmain\ttf_1\t1\tUNIQUE\tUNIQUE(\"b c\")\tNULL\t[1]\t[b c]\tNULL\t[]\n+memory\tmain\ttf_1\t2\tUNIQUE\tUNIQUE(\"d e\")\tNULL\t[2]\t[d e]\tNULL\t[]\n+memory\tmain\ttf_1\t3\tNOT NULL\tNOT NULL\tNULL\t[0]\t[a]\tNULL\t[]\n+memory\tmain\ttf_2\t4\tPRIMARY KEY\tPRIMARY KEY(c)\tNULL\t[0]\t[c]\tNULL\t[]\n+memory\tmain\ttf_2\t5\tFOREIGN KEY\tFOREIGN KEY (d) REFERENCES tf_1(a)\tNULL\t[1]\t[d]\ttf_1\t[a]\n+memory\tmain\ttf_2\t6\tFOREIGN KEY\tFOREIGN KEY (e) REFERENCES tf_1(\"b c\")\tNULL\t[2]\t[e]\ttf_1\t[b c]\n+memory\tmain\ttf_2\t7\tFOREIGN KEY\tFOREIGN KEY (f) REFERENCES tf_1(\"d e\")\tNULL\t[3]\t[f]\ttf_1\t[d e]\n+memory\tmain\ttf_2\t8\tFOREIGN KEY\tFOREIGN KEY (g) REFERENCES tf_3(g)\tNULL\t[4]\t[g]\ttf_3\t[g]\n+memory\tmain\ttf_2\t9\tNOT NULL\tNOT NULL\tNULL\t[0]\t[c]\tNULL\t[]\n+memory\tmain\ttf_3\t10\tPRIMARY KEY\tPRIMARY KEY(g)\tNULL\t[0]\t[g]\tNULL\t[]\n+memory\tmain\ttf_3\t11\tUNIQUE\tUNIQUE(h)\tNULL\t[1]\t[h]\tNULL\t[]\n+memory\tmain\ttf_3\t12\tNOT NULL\tNOT NULL\tNULL\t[0]\t[g]\tNULL\t[]\n+memory\tmain\ttf_4\t13\tFOREIGN KEY\tFOREIGN KEY (h) REFERENCES tf_3(h)\tNULL\t[0]\t[h]\ttf_3\t[h]\ndiff --git a/test/sql/table_function/duckdb_constraints_issue12863.test b/test/sql/table_function/duckdb_constraints_issue12863.test\nnew file mode 100644\nindex 000000000000..69d75678e640\n--- /dev/null\n+++ b/test/sql/table_function/duckdb_constraints_issue12863.test\n@@ -0,0 +1,32 @@\n+# name: test/sql/table_function/duckdb_constraints_issue12863.test\n+# description: Issue #12863 - INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS doesn't list foreign keys when declaration case doesn't match reference case\n+# group: [table_function]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE a (ID int PRIMARY KEY);\n+\n+statement ok\n+CREATE TABLE b (id int REFERENCES A);\n+\n+query II\n+SELECT constraint_name, unique_constraint_name FROM information_schema.referential_constraints;\n+----\n+b_id_id_fkey\ta_id_pkey\n+\n+# test multiple schemas with the same table names/references\n+statement ok\n+CREATE SCHEMA s1;\n+\n+statement ok\n+CREATE TABLE s1.a (ID int PRIMARY KEY);\n+\n+statement ok\n+CREATE TABLE s1.b (id int REFERENCES s1.A);\n+\n+query I\n+SELECT COUNT(*) FROM information_schema.referential_constraints;\n+----\n+2\ndiff --git a/test/sql/table_function/information_schema_fkey_constraint_names.test b/test/sql/table_function/information_schema_fkey_constraint_names.test\nindex c46c660baeb6..05a380415e0d 100644\n--- a/test/sql/table_function/information_schema_fkey_constraint_names.test\n+++ b/test/sql/table_function/information_schema_fkey_constraint_names.test\n@@ -15,7 +15,7 @@ where constraint_type like '%KEY'\n order by 1\n ----\n t_i_pkey\n-u_i_fkey\n+u_i_i_fkey\n \n query I\n select constraint_name\n@@ -23,13 +23,13 @@ from information_schema.key_column_usage\n order by 1\n ----\n t_i_pkey\n-u_i_fkey\n+u_i_i_fkey\n \n query II\n select constraint_name, unique_constraint_name\n from information_schema.referential_constraints;\n ----\n-u_i_fkey\tt_i_pkey\n+u_i_i_fkey\tt_i_pkey\n \n statement ok\n drop table u\n@@ -49,7 +49,7 @@ from information_schema.table_constraints\n where constraint_type like '%KEY'\n order by 1\n ----\n-source_tbl_source_col_fkey\n+source_tbl_source_col_target_col_fkey\n target_tbl_target_col_pkey\n \n query I\n@@ -57,11 +57,39 @@ select constraint_name\n from information_schema.key_column_usage\n order by 1\n ----\n-source_tbl_source_col_fkey\n+source_tbl_source_col_target_col_fkey\n target_tbl_target_col_pkey\n \n query II\n select constraint_name, unique_constraint_name\n from information_schema.referential_constraints;\n ----\n-source_tbl_source_col_fkey\ttarget_tbl_target_col_pkey\n+source_tbl_source_col_target_col_fkey\ttarget_tbl_target_col_pkey\n+\n+# multiple constraints\n+statement ok\n+DROP TABLE source_tbl;\n+\n+statement ok\n+DROP TABLE target_tbl;\n+\n+statement ok\n+CREATE TABLE a (\n+  a1 INT, a2 INT, a3 INT,\n+  UNIQUE (a1, a2), UNIQUE (a2, a3)\n+);\n+\n+statement ok\n+CREATE TABLE b (\n+  a1 INT, a2 INT, a3 INT,\n+  FOREIGN KEY (a1, a2) REFERENCES a (a1, a2),\n+  FOREIGN KEY (a2, a3) REFERENCES a (a2, a3)\n+);\n+\n+query II\n+SELECT constraint_name, constraint_type FROM information_schema.table_constraints ORDER BY ALL\n+----\n+a_a1_a2_key\tUNIQUE\n+a_a2_a3_key\tUNIQUE\n+b_a1_a2_a1_a2_fkey\tFOREIGN KEY\n+b_a2_a3_a2_a3_fkey\tFOREIGN KEY\ndiff --git a/test/sql/table_function/information_schema_issue12867.test b/test/sql/table_function/information_schema_issue12867.test\nnew file mode 100644\nindex 000000000000..2ff615161f89\n--- /dev/null\n+++ b/test/sql/table_function/information_schema_issue12867.test\n@@ -0,0 +1,19 @@\n+# name: test/sql/table_function/information_schema_issue12867.test\n+# description: Issue #12867: INFORMATION_SCHEMA.KEY_COLUMN_USAGE only lists first column of composite keys\n+# group: [table_function]\n+\n+require skip_reload\n+\n+statement ok\n+CREATE TABLE a (a1 int, a2 int, PRIMARY KEY (a1, a2));\n+\n+statement ok\n+CREATE TABLE b (a1 int, a2 int, FOREIGN KEY (a1, a2) REFERENCES a);\n+\n+query III\n+SELECT table_name, column_name, ordinal_position FROM information_schema.key_column_usage ORDER BY table_name, ordinal_position;\n+----\n+a\ta1\t1\n+a\ta2\t2\n+b\ta1\t1\n+b\ta2\t2\n",
  "problem_statement": "information_schema.table_constraints and key_column_usage always list \"memory\" for table_catalog on ATTACHed databases\n### What happens?\r\n\r\nWhen using the `ATTACH` statement, the `information_schema.table_constraints` and `information_schema.key_column_usage` tables will always list `memory` for the `constraint_catalog` and `table_catalog`.\r\n\r\nThis makes it impossible to determine which attached database the constraints come from when multiple database files are attached, especially when some have some tables or constraints with the same names.\r\n\r\nThus making it not possible to read the full database schema from the `information_schema` of those attached databases.\r\n\r\n### To Reproduce\r\n\r\nFirst test behavior when starting duckdb with specified database which works correctly:\r\n1. From command line run `duckdb test.db`  where test.db is a DuckDB file with some tables.\r\n2. Run `select * from information_schema.table_constraints;`\r\n3. Notice `constraint_catalog` and `table_catalog` for all tables from `test.db` are correctly listed as `test`\r\n4. Same with `select * from information_schema.key_column_usage;`\r\n5. Now try `select * from information_schema.tables;`\r\n6. Notice `table_catalog` is correctly listed as `test`\r\n\r\nThen check behavior when using `ATTACH`\r\n1. From command line run `duckdb` \r\n2. Attach a `duckdb` database eg. `ATTACH 'test.db' as test`\r\n3. Run `select * from information_schema.table_constraints;`\r\n4. Notice `constraint_catalog` and `table_catalog` for all tables are listed as `memory`\r\n7. Same with `select * from information_schema.key_column_usage;`\r\n8. Now try `select * from information_schema.tables;`\r\n9. Notice in this case `table_catalog` is correctly listed as `test`\r\n\r\n(Didn't share data set because it is reproducible with any DuckDB database file that has tables with constraints.)\r\n\r\n### OS:\r\n\r\nTested on Mac OS (ARM64) and Windows (x64) with same behavior through both command line and Node.js sdk.\r\n\r\n### DuckDB Version:\r\n\r\nv1.0.0 1f98600c2c\r\n\r\n### DuckDB Client:\r\n\r\nCommand Line, Node.js SDK\r\n\r\n### Full Name:\r\n\r\nChanon Sajamanochai\r\n\r\n### Affiliation:\r\n\r\nIndependent developer\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNo - Other reason (please specify in the issue body)\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-07-09T11:48:57Z"
}