You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Incorrect result for SUM() and negative number 
Consider the following statements:
```sql
CREATE TABLE t0 (c0 INT);
INSERT INTO t0 VALUES (0);
SELECT SUM(-1) FROM t0; -- expected: {-1}, actual: {1.8446744073709552e+19}
```
Unexpectedly, the `SELECT` returns `1.8446744073709552e+19`. Since `t0` contains only a single row, I would expect `-1` to be fetched. I found this based on commit 3cf167887fa9cd375a4b1c67d0b427affa0a1430.
SELECT with CASE expression causes an assertion failure "Assertion `!entry.first->Equals(&expr)' failed"
Consider the following statements:

```sql
CREATE TABLE t0(c0 INT);
SELECT * FROM t0 GROUP BY -4.40304405E8 ORDER BY (CASE 1 WHEN 0 THEN 0 ELSE -440304405 END); -- Assertion `!entry.first->Equals(&expr)' failed.
```

When executing the debug build, the statements result in the following assertion failure:
```
/duckdb/src/planner/expression_binder/select_binder.cpp:54: duckdb::idx_t duckdb::SelectBinder::TryBindGroup(duckdb::ParsedExpression&, duckdb::idx_t): Assertion `!entry.first->Equals(&expr)' failed. 
```

I found this based on commit 3cf167887fa9cd375a4b1c67d0b427affa0a1430.

</issue>
<code>
[start of README.md]
1: <img align="left" src="logo/duckdb-logo.png" height="120">
2: 
3: # DuckDB, the SQLite for Analytics
4: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
5: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
6: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
7: 
8: <br>
9: 
10: 
11: # Requirements
12: DuckDB requires [CMake](https://cmake.org) to be installed and a `C++11` compliant compiler. GCC 4.9 and newer, Clang 3.9 and newer and VisualStudio 2017 are tested on each revision.
13: 
14: ## Compiling
15: Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You may run `make unit` and `make allunit` to verify that your version works properly after making changes.
16: 
17: # Usage
18: A command line utility based on `sqlite3` can be found in either `build/release/duckdb_cli` (release, the default) or `build/debug/duckdb_cli` (debug).
19: 
20: # Embedding
21: As DuckDB is an embedded database, there is no database server to launch or client to connect to a running server. However, the database server can be embedded directly into an application using the C or C++ bindings. The main build process creates the shared library `build/release/src/libduckdb.[so|dylib|dll]` that can be linked against. A static library is built as well.
22: 
23: For examples on how to embed DuckDB into your application, see the [examples](https://github.com/cwida/duckdb/tree/master/examples) folder.
24: 
25: ## Benchmarks
26: After compiling, benchmarks can be executed from the root directory by executing `./build/release/benchmark/benchmark_runner`.
27: 
28: ## Standing on the Shoulders of Giants
29: DuckDB is implemented in C++ 11, should compile with GCC and clang, uses CMake to build and [Catch2](https://github.com/catchorg/Catch2) for testing. DuckDB uses some components from various Open-Source databases and draws inspiration from scientific publications. Here is an overview:
30: 
31: * Parser: We use the PostgreSQL parser that was [repackaged as a stand-alone library](https://github.com/lfittl/libpg_query). The translation to our own parse tree is inspired by [Peloton](https://pelotondb.io).
32: * Shell: We have adapted the [SQLite shell](https://sqlite.org/cli.html) to work with DuckDB.
33: * Tests: We use the [SQL Logic Tests from SQLite](https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki) to test DuckDB.
34: * Query fuzzing: We use [SQLsmith](https://github.com/anse1/sqlsmith) to generate random queries for additional testing.
35: * Date Math: We use the date math component from [MonetDB](https://www.monetdb.org).
36: * SQL Window Functions: DuckDB's window functions implementation uses Segment Tree Aggregation as described in the paper "Efficient Processing of Window Functions in Analytical SQL Queries" by Viktor Leis, Kan Kundhikanjana, Alfons Kemper and Thomas Neumann.
37: * Execution engine: The vectorized execution engine is inspired by the paper "MonetDB/X100: Hyper-Pipelining Query Execution" by Peter Boncz, Marcin Zukowski and Niels Nes.
38: * Optimizer: DuckDB's optimizer draws inspiration from the papers "Dynamic programming strikes back" by Guido Moerkotte and Thomas Neumman as well as "Unnesting Arbitrary Queries" by Thomas Neumann and Alfons Kemper.
39: * Concurrency control: Our MVCC implementation is inspired by the paper "Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems" by Thomas Neumann, Tobias Mühlbauer and Alfons Kemper.
40: * Regular Expression: DuckDB uses Google's [RE2](https://github.com/google/re2) regular expression engine.
41: 
42: ## Other pages
43: * [Continuous Benchmarking (CB™)](https://www.duckdb.org/benchmarks/index.html), runs TPC-H, TPC-DS and some microbenchmarks on every commit
[end of README.md]
[start of src/function/aggregate/distributive/sum.cpp]
1: #include "duckdb/function/aggregate/distributive_functions.hpp"
2: #include "duckdb/common/exception.hpp"
3: #include "duckdb/common/types/null_value.hpp"
4: #include "duckdb/common/vector_operations/vector_operations.hpp"
5: #include "duckdb/common/vector_operations/aggregate_executor.hpp"
6: #include "duckdb/common/operator/numeric_binary_operators.hpp"
7: 
8: using namespace std;
9: 
10: namespace duckdb {
11: 
12: struct sum_state_t {
13: 	double value;
14: 	bool isset;
15: };
16: 
17: struct SumOperation {
18: 	template <class STATE> static void Initialize(STATE *state) {
19: 		state->value = 0;
20: 		state->isset = false;
21: 	}
22: 
23: 	template <class INPUT_TYPE, class STATE, class OP>
24: 	static void Operation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t idx) {
25: 		state->isset = true;
26: 		state->value += input[idx];
27: 	}
28: 
29: 	template <class INPUT_TYPE, class STATE, class OP>
30: 	static void ConstantOperation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t count) {
31: 		state->isset = true;
32: 		state->value += input[0] * count;
33: 	}
34: 
35: 	template <class T, class STATE>
36: 	static void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {
37: 		if (!state->isset) {
38: 			nullmask[idx] = true;
39: 		} else {
40: 			if (!Value::DoubleIsValid(state->value)) {
41: 				throw OutOfRangeException("SUM is out of range!");
42: 			}
43: 			target[idx] = state->value;
44: 		}
45: 	}
46: 
47: 	template <class STATE, class OP> static void Combine(STATE source, STATE *target) {
48: 		if (!source.isset) {
49: 			// source is NULL, nothing to do
50: 			return;
51: 		}
52: 		if (!target->isset) {
53: 			// target is NULL, use source value directly
54: 			*target = source;
55: 		} else {
56: 			// else perform the operation
57: 			target->value += source.value;
58: 		}
59: 	}
60: 
61: 	static bool IgnoreNull() {
62: 		return true;
63: 	}
64: };
65: 
66: void SumFun::RegisterFunction(BuiltinFunctions &set) {
67: 	AggregateFunctionSet sum("sum");
68: 	// integer sums to bigint
69: 	sum.AddFunction(
70: 	    AggregateFunction::UnaryAggregate<sum_state_t, int32_t, double, SumOperation>(SQLType::INTEGER, SQLType::DOUBLE));
71: 	sum.AddFunction(
72: 	    AggregateFunction::UnaryAggregate<sum_state_t, int64_t, double, SumOperation>(SQLType::BIGINT, SQLType::DOUBLE));
73: 	// float sums to float
74: 	sum.AddFunction(
75: 	    AggregateFunction::UnaryAggregate<sum_state_t, double, double, SumOperation>(SQLType::DOUBLE, SQLType::DOUBLE));
76: 
77: 	set.AddFunction(sum);
78: }
79: 
80: } // namespace duckdb
[end of src/function/aggregate/distributive/sum.cpp]
[start of src/parser/expression/constant_expression.cpp]
1: #include "duckdb/parser/expression/constant_expression.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/types/hash.hpp"
5: #include "duckdb/common/value_operations/value_operations.hpp"
6: 
7: using namespace duckdb;
8: using namespace std;
9: 
10: ConstantExpression::ConstantExpression(SQLType sql_type, Value val)
11:     : ParsedExpression(ExpressionType::VALUE_CONSTANT, ExpressionClass::CONSTANT), value(val), sql_type(sql_type) {
12: }
13: 
14: string ConstantExpression::ToString() const {
15: 	return value.ToString();
16: }
17: 
18: bool ConstantExpression::Equals(const ConstantExpression *a, const ConstantExpression *b) {
19: 	return a->value == b->value;
20: }
21: 
22: hash_t ConstantExpression::Hash() const {
23: 	hash_t result = ParsedExpression::Hash();
24: 	return CombineHash(ValueOperations::Hash(value), result);
25: }
26: 
27: unique_ptr<ParsedExpression> ConstantExpression::Copy() const {
28: 	auto copy = make_unique<ConstantExpression>(sql_type, value);
29: 	copy->CopyProperties(*this);
30: 	return move(copy);
31: }
32: 
33: void ConstantExpression::Serialize(Serializer &serializer) {
34: 	ParsedExpression::Serialize(serializer);
35: 	value.Serialize(serializer);
36: 	sql_type.Serialize(serializer);
37: }
38: 
39: unique_ptr<ParsedExpression> ConstantExpression::Deserialize(ExpressionType type, Deserializer &source) {
40: 	Value value = Value::Deserialize(source);
41: 	auto sql_type = SQLType::Deserialize(source);
42: 	return make_unique<ConstantExpression>(sql_type, value);
43: }
[end of src/parser/expression/constant_expression.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: