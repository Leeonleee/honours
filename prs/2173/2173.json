{
  "repo": "duckdb/duckdb",
  "pull_number": 2173,
  "instance_id": "duckdb__duckdb-2173",
  "issue_numbers": [
    "2170"
  ],
  "base_commit": "c2a67240edcb0ce1f38a381aba50e7b7e4061a0f",
  "patch": "diff --git a/src/include/duckdb.h b/src/include/duckdb.h\nindex 360f8fb2e560..4c134157121b 100644\n--- a/src/include/duckdb.h\n+++ b/src/include/duckdb.h\n@@ -826,7 +826,7 @@ DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, con\n Returns the error message associated with the given appender.\n If the appender has no error message, this returns `nullptr` instead.\n \n-The error message should be freed using `duckdb_free`.\n+The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.\n \n * appender: The appender to get the error from.\n * returns: The error message, or `nullptr` if there is none.\n@@ -1031,7 +1031,7 @@ DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);\n Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns\n `DuckDBError`.\n \n-The result should be freed using `duckdb_free`.\n+The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.\n \n * result: The result object to fetch the nullmask from.\n * returns: The error of the result.\ndiff --git a/src/main/capi/appender-c.cpp b/src/main/capi/appender-c.cpp\nindex 24ecd1777612..f8e55139febd 100644\n--- a/src/main/capi/appender-c.cpp\n+++ b/src/main/capi/appender-c.cpp\n@@ -76,7 +76,7 @@ const char *duckdb_appender_error(duckdb_appender appender) {\n \tif (wrapper->error.empty()) {\n \t\treturn nullptr;\n \t}\n-\treturn strdup(wrapper->error.c_str());\n+\treturn wrapper->error.c_str();\n }\n \n duckdb_state duckdb_appender_begin_row(duckdb_appender appender) {\ndiff --git a/src/main/capi/arrow-c.cpp b/src/main/capi/arrow-c.cpp\nindex c2f233dcc249..9de8240f65ca 100644\n--- a/src/main/capi/arrow-c.cpp\n+++ b/src/main/capi/arrow-c.cpp\n@@ -67,7 +67,7 @@ idx_t duckdb_arrow_rows_changed(duckdb_arrow result) {\n \n const char *duckdb_query_arrow_error(duckdb_arrow result) {\n \tauto wrapper = (ArrowResultWrapper *)result;\n-\treturn strdup(wrapper->result->error.c_str());\n+\treturn wrapper->result->error.c_str();\n }\n \n void duckdb_destroy_arrow(duckdb_arrow *result) {\n",
  "test_patch": "diff --git a/test/api/capi/test_capi.cpp b/test/api/capi/test_capi.cpp\nindex 20431cc80656..66718eb1ab80 100644\n--- a/test/api/capi/test_capi.cpp\n+++ b/test/api/capi/test_capi.cpp\n@@ -525,8 +525,7 @@ TEST_CASE(\"Test errors in C API\", \"[capi]\") {\n \tREQUIRE(duckdb_prepare(tester.connection, \"SELECT * from INVALID_TABLE\", &stmt) == DuckDBError);\n \tREQUIRE(duckdb_prepare_error(nullptr) == nullptr);\n \tREQUIRE(stmt != nullptr);\n-\tauto err_msg = duckdb_prepare_error(stmt);\n-\tREQUIRE(err_msg != nullptr);\n+\tREQUIRE(duckdb_prepare_error(stmt) != nullptr);\n \tduckdb_destroy_prepare(&stmt);\n \n \tREQUIRE(duckdb_bind_boolean(NULL, 0, true) == DuckDBError);\n@@ -536,9 +535,7 @@ TEST_CASE(\"Test errors in C API\", \"[capi]\") {\n \t// fail to query arrow\n \tduckdb_arrow out_arrow;\n \tREQUIRE(duckdb_query_arrow(tester.connection, \"SELECT * from INVALID_TABLE\", &out_arrow) == DuckDBError);\n-\terr_msg = duckdb_query_arrow_error(out_arrow);\n-\tREQUIRE(err_msg != nullptr);\n-\tduckdb_free((void *)err_msg);\n+\tREQUIRE(duckdb_query_arrow_error(out_arrow) != nullptr);\n \tduckdb_destroy_arrow(&out_arrow);\n \n \t// various edge cases/nullptrs\n@@ -799,9 +796,7 @@ TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n \tstatus = duckdb_appender_create(tester.connection, nullptr, \"nonexistant-table\", &appender);\n \tREQUIRE(status == DuckDBError);\n \tREQUIRE(appender != nullptr);\n-\tauto msg = duckdb_appender_error(appender);\n-\tREQUIRE(msg != nullptr);\n-\tduckdb_free((void *)msg);\n+\tREQUIRE(duckdb_appender_error(appender) != nullptr);\n \tREQUIRE(duckdb_appender_destroy(&appender) == DuckDBSuccess);\n \tREQUIRE(duckdb_appender_destroy(nullptr) == DuckDBError);\n \n@@ -846,9 +841,7 @@ TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n \t// not enough cols here\n \tstatus = duckdb_appender_end_row(appender);\n \tREQUIRE(status == DuckDBError);\n-\tauto err_msg = duckdb_appender_error(appender);\n-\tREQUIRE(err_msg != nullptr);\n-\tduckdb_free((void *)err_msg);\n+\tREQUIRE(duckdb_appender_error(appender) != nullptr);\n \n \tstatus = duckdb_append_varchar(appender, \"Hello, World\");\n \tREQUIRE(status == DuckDBSuccess);\n@@ -857,9 +850,7 @@ TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n \tstatus = duckdb_append_int32(appender, 42);\n \tREQUIRE(status == DuckDBError);\n \n-\terr_msg = duckdb_appender_error(appender);\n-\tREQUIRE(err_msg != nullptr);\n-\tduckdb_free((void *)err_msg);\n+\tREQUIRE(duckdb_appender_error(appender) != nullptr);\n \n \tstatus = duckdb_appender_end_row(appender);\n \tREQUIRE(status == DuckDBSuccess);\n",
  "problem_statement": "capi: behaviour not consistent\nhttps://github.com/duckdb/duckdb/blob/0d2a2778ae50857bac3cb1788af5a2b66334f0e9/src/include/duckdb.h#L829\r\nFor appender_error, user need to free it\r\n\r\nhttps://github.com/duckdb/duckdb/blob/0d2a2778ae50857bac3cb1788af5a2b66334f0e9/src/include/duckdb.h#L641\r\nBut for prepare_error, user shouldn't free it\r\n\r\nI think we'd better make it consistent, and I prefer to let user free it\n",
  "hints_text": "Yes, I agree it should be consistent. I almost modified it when I did the last patch but did not because it would break people's code.\r\n\r\nI would instead prefer the change so that `duckdb_query_arrow_error` and `duckdb_appender_error` should not be freed. They are the most recent additions to the API, and hence changes to those will break the lowest amount of code. \r\n\r\nWhy would you prefer to let the user free it? In all cases where error messages are used they are associated with a context that owns them and needs to be destroyed independently. What is the advantage to explicitly creating a copy just so the user has to free the message? If the user wants to keep around a copy they can just make a copy themselves, no? Perhaps we could add a `duckdb_strdup` method for this purpose?\nWhat I'm thinking is if the error string attach to the query context, then any operation on that context might invalid the error string, if user mistakenly hold and use the error again there might be problem\r\n\r\nBut what you said also reasonable. Would you like me to create a PR to make it consistent? Or we keep it for compatibility?\n> What I'm thinking is if the error string attach to the query context, then any operation on that context might invalid the error string, if user mistakenly hold and use the error again there might be problem\r\n\r\nThat is fair, but as far as I can tell in all cases the error message is attached to an object that becomes invalid when an error happens (e.g. a query result that has an error cannot be re-used, or an appender that has an error cannot be re-used, etc). I don't think it will be a big problem in practice.\r\n\r\n> But what you said also reasonable. Would you like me to create a PR to make it consistent? Or we keep it for compatibility?\r\n\r\nYes, please! That would be great. Thanks.",
  "created_at": "2021-08-21T14:13:29Z"
}