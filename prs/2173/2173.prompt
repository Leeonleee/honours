You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
capi: behaviour not consistent
https://github.com/duckdb/duckdb/blob/0d2a2778ae50857bac3cb1788af5a2b66334f0e9/src/include/duckdb.h#L829
For appender_error, user need to free it

https://github.com/duckdb/duckdb/blob/0d2a2778ae50857bac3cb1788af5a2b66334f0e9/src/include/duckdb.h#L641
But for prepare_error, user shouldn't free it

I think we'd better make it consistent, and I prefer to let user free it

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![codecov](https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN)](https://codecov.io/gh/duckdb/duckdb)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/include/duckdb.h]
1: //===----------------------------------------------------------------------===//
2: //
3: //                         DuckDB
4: //
5: // duckdb.h
6: //
7: //
8: //===----------------------------------------------------------------------===//
9: 
10: #pragma once
11: 
12: #ifdef _WIN32
13: #ifdef DUCKDB_BUILD_LIBRARY
14: #define DUCKDB_API __declspec(dllexport)
15: #else
16: #define DUCKDB_API __declspec(dllimport)
17: #endif
18: #else
19: #define DUCKDB_API
20: #endif
21: 
22: #include <stdbool.h>
23: #include <stdint.h>
24: #include <stdlib.h>
25: 
26: #ifdef __cplusplus
27: extern "C" {
28: #endif
29: 
30: //===--------------------------------------------------------------------===//
31: // Type Information
32: //===--------------------------------------------------------------------===//
33: typedef uint64_t idx_t;
34: 
35: typedef enum DUCKDB_TYPE {
36: 	DUCKDB_TYPE_INVALID = 0,
37: 	// bool
38: 	DUCKDB_TYPE_BOOLEAN,
39: 	// int8_t
40: 	DUCKDB_TYPE_TINYINT,
41: 	// int16_t
42: 	DUCKDB_TYPE_SMALLINT,
43: 	// int32_t
44: 	DUCKDB_TYPE_INTEGER,
45: 	// int64_t
46: 	DUCKDB_TYPE_BIGINT,
47: 	// uint8_t
48: 	DUCKDB_TYPE_UTINYINT,
49: 	// uint16_t
50: 	DUCKDB_TYPE_USMALLINT,
51: 	// uint32_t
52: 	DUCKDB_TYPE_UINTEGER,
53: 	// uint64_t
54: 	DUCKDB_TYPE_UBIGINT,
55: 	// float
56: 	DUCKDB_TYPE_FLOAT,
57: 	// double
58: 	DUCKDB_TYPE_DOUBLE,
59: 	// duckdb_timestamp
60: 	DUCKDB_TYPE_TIMESTAMP,
61: 	// duckdb_date
62: 	DUCKDB_TYPE_DATE,
63: 	// duckdb_time
64: 	DUCKDB_TYPE_TIME,
65: 	// duckdb_interval
66: 	DUCKDB_TYPE_INTERVAL,
67: 	// duckdb_hugeint
68: 	DUCKDB_TYPE_HUGEINT,
69: 	// const char*
70: 	DUCKDB_TYPE_VARCHAR,
71: 	// duckdb_blob
72: 	DUCKDB_TYPE_BLOB
73: } duckdb_type;
74: 
75: //! Days are stored as days since 1970-01-01
76: //! Use the duckdb_from_date/duckdb_to_date function to extract individual information
77: typedef struct {
78: 	int32_t days;
79: } duckdb_date;
80: 
81: typedef struct {
82: 	int32_t year;
83: 	int8_t month;
84: 	int8_t day;
85: } duckdb_date_struct;
86: 
87: //! Time is stored as microseconds since 00:00:00
88: //! Use the duckdb_from_time/duckdb_to_time function to extract individual information
89: typedef struct {
90: 	int64_t micros;
91: } duckdb_time;
92: 
93: typedef struct {
94: 	int8_t hour;
95: 	int8_t min;
96: 	int8_t sec;
97: 	int32_t micros;
98: } duckdb_time_struct;
99: 
100: //! Timestamps are stored as microseconds since 1970-01-01
101: //! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information
102: typedef struct {
103: 	int64_t micros;
104: } duckdb_timestamp;
105: 
106: typedef struct {
107: 	duckdb_date_struct date;
108: 	duckdb_time_struct time;
109: } duckdb_timestamp_struct;
110: 
111: typedef struct {
112: 	int32_t months;
113: 	int32_t days;
114: 	int64_t micros;
115: } duckdb_interval;
116: 
117: //! Hugeints are composed in a (lower, upper) component
118: //! The value of the hugeint is upper * 2^64 + lower
119: //! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended
120: typedef struct {
121: 	uint64_t lower;
122: 	int64_t upper;
123: } duckdb_hugeint;
124: 
125: typedef struct {
126: 	void *data;
127: 	idx_t size;
128: } duckdb_blob;
129: 
130: typedef struct {
131: 	void *data;
132: 	bool *nullmask;
133: 	duckdb_type type;
134: 	char *name;
135: 	void *internal_data;
136: } duckdb_column;
137: 
138: typedef struct {
139: 	idx_t column_count;
140: 	idx_t row_count;
141: 	idx_t rows_changed;
142: 	duckdb_column *columns;
143: 	char *error_message;
144: 	void *internal_data;
145: } duckdb_result;
146: 
147: typedef void *duckdb_database;
148: typedef void *duckdb_connection;
149: typedef void *duckdb_prepared_statement;
150: typedef void *duckdb_appender;
151: typedef void *duckdb_arrow;
152: typedef void *duckdb_config;
153: typedef void *duckdb_arrow_schema;
154: typedef void *duckdb_arrow_array;
155: 
156: typedef enum { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;
157: 
158: //===--------------------------------------------------------------------===//
159: // Open/Connect
160: //===--------------------------------------------------------------------===//
161: 
162: /*!
163: Creates a new database or opens an existing database file stored at the the given path.
164: If no path is given a new in-memory database is created instead.
165: 
166: * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
167: * out_database: The result database object.
168: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
169: */
170: DUCKDB_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);
171: 
172: /*!
173: Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the the given path.
174: 
175: * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
176: * out_database: The result database object.
177: * config: (Optional) configuration used to start up the database system.
178: * out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.
179: Note that the error must be freed using `duckdb_free`.
180: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
181: */
182: DUCKDB_API duckdb_state duckdb_open_ext(const char *path, duckdb_database *out_database, duckdb_config config,
183:                                         char **out_error);
184: 
185: /*!
186: Closes the specified database and de-allocates all memory allocated for that database.
187: This should be called after you are done with any database allocated through `duckdb_open`.
188: Note that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.
189: Still it is recommended to always correctly close a database object after you are done with it.
190: 
191: * database: The database object to shut down.
192: */
193: DUCKDB_API void duckdb_close(duckdb_database *database);
194: 
195: /*!
196: Opens a connection to a database. Connections are required to query the database, and store transactional state
197: associated with the connection.
198: 
199: * database: The database file to connect to.
200: * out_connection: The result connection object.
201: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
202: */
203: DUCKDB_API duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out_connection);
204: 
205: /*!
206: Closes the specified connection and de-allocates all memory allocated for that connection.
207: 
208: * connection: The connection to close.
209: */
210: DUCKDB_API void duckdb_disconnect(duckdb_connection *connection);
211: 
212: //===--------------------------------------------------------------------===//
213: // Configuration
214: //===--------------------------------------------------------------------===//
215: /*!
216: Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance
217: through `duckdb_open_ext`.
218: 
219: This will always succeed unless there is a malloc failure.
220: 
221: * out_config: The result configuration object.
222: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
223: */
224: DUCKDB_API duckdb_state duckdb_create_config(duckdb_config *out_config);
225: 
226: /*!
227: This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.
228: 
229: This should not be called in a loop as it internally loops over all the options.
230: 
231: * returns: The amount of config options available.
232: */
233: DUCKDB_API size_t duckdb_config_count();
234: 
235: /*!
236: Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.
237: display configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).
238: 
239: The result name or description MUST NOT be freed.
240: 
241: * index: The index of the configuration option (between 0 and `duckdb_config_count`)
242: * out_name: A name of the configuration flag.
243: * out_description: A description of the configuration flag.
244: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
245: */
246: DUCKDB_API duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description);
247: 
248: /*!
249: Sets the specified option for the specified configuration. The configuration option is indicated by name.
250: To obtain a list of config options, see `duckdb_get_config_flag`.
251: 
252: In the source code, configuration options are defined in `config.cpp`.
253: 
254: This can fail if either the name is invalid, or if the value provided for the option is invalid.
255: 
256: * duckdb_config: The configuration object to set the option on.
257: * name: The name of the configuration flag to set.
258: * option: The value to set the configuration flag to.
259: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
260: */
261: DUCKDB_API duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option);
262: 
263: /*!
264: Destroys the specified configuration option and de-allocates all memory allocated for the object.
265: 
266: * config: The configuration object to destroy.
267: */
268: DUCKDB_API void duckdb_destroy_config(duckdb_config *config);
269: 
270: //===--------------------------------------------------------------------===//
271: // Query Execution
272: //===--------------------------------------------------------------------===//
273: /*!
274: Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.
275: If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
276: `duckdb_result_error`.
277: 
278: Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the
279: query fails, otherwise the error stored within the result will not be freed correctly.
280: 
281: * connection: The connection to perform the query in.
282: * query: The SQL query to run.
283: * out_result: The query result.
284: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
285: */
286: DUCKDB_API duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out_result);
287: 
288: /*!
289: Closes the result and de-allocates all memory allocated for that connection.
290: 
291: * result: The result to destroy.
292: */
293: DUCKDB_API void duckdb_destroy_result(duckdb_result *result);
294: 
295: /*!
296: Returns the column name of the specified column. The result should not need be freed; the column names will
297: automatically be destroyed when the result is destroyed.
298: 
299: Returns `NULL` if the column is out of range.
300: 
301: * result: The result object to fetch the column name from.
302: * col: The column index.
303: * returns: The column name of the specified column.
304: */
305: DUCKDB_API const char *duckdb_column_name(duckdb_result *result, idx_t col);
306: 
307: /*!
308: Returns the column type of the specified column.
309: 
310: Returns `DUCKDB_TYPE_INVALID` if the column is out of range.
311: 
312: * result: The result object to fetch the column type from.
313: * col: The column index.
314: * returns: The column type of the specified column.
315: */
316: DUCKDB_API duckdb_type duckdb_column_type(duckdb_result *result, idx_t col);
317: 
318: /*!
319: Returns the number of columns present in a the result object.
320: 
321: * result: The result object.
322: * returns: The number of columns present in the result object.
323: */
324: DUCKDB_API idx_t duckdb_column_count(duckdb_result *result);
325: 
326: /*!
327: Returns the number of rows present in a the result object.
328: 
329: * result: The result object.
330: * returns: The number of rows present in the result object.
331: */
332: DUCKDB_API idx_t duckdb_row_count(duckdb_result *result);
333: 
334: /*!
335: Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE
336: queries. For other queries the rows_changed will be 0.
337: 
338: * result: The result object.
339: * returns: The number of rows changed.
340: */
341: DUCKDB_API idx_t duckdb_rows_changed(duckdb_result *result);
342: 
343: /*!
344: Returns the data of a specific column of a result in columnar format. This is the fastest way of accessing data in a
345: query result, as no conversion or type checking must be performed (outside of the original switch). If performance
346: is a concern, it is recommended to use this API over the `duckdb_value` functions.
347: 
348: The function returns a dense array which contains the result data. The exact type stored in the array depends on the
349: corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
350: accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.
351: 
352: For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:
353: ```c
354: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
355: printf("Data for row %d: %d\n", row, data[row]);
356: ```
357: 
358: * result: The result object to fetch the column data from.
359: * col: The column index.
360: * returns: The column data of the specified column.
361: */
362: DUCKDB_API void *duckdb_column_data(duckdb_result *result, idx_t col);
363: 
364: /*!
365: Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
366: whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
367: by `duckdb_column_data` are undefined.
368: 
369: ```c
370: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
371: bool *nullmask = duckdb_nullmask_data(&result, 0);
372: if (nullmask[row]) {
373:     printf("Data for row %d: NULL\n", row);
374: } else {
375:     printf("Data for row %d: %d\n", row, data[row]);
376: }
377: ```
378: 
379: * result: The result object to fetch the nullmask from.
380: * col: The column index.
381: * returns: The nullmask of the specified column.
382: */
383: DUCKDB_API bool *duckdb_nullmask_data(duckdb_result *result, idx_t col);
384: 
385: /*!
386: Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.
387: 
388: The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.
389: 
390: * result: The result object to fetch the nullmask from.
391: * returns: The error of the result.
392: */
393: DUCKDB_API char *duckdb_result_error(duckdb_result *result);
394: 
395: //===--------------------------------------------------------------------===//
396: // Result Functions
397: //===--------------------------------------------------------------------===//
398: 
399: // Safe fetch functions
400: // These functions will perform conversions if necessary.
401: // On failure (e.g. if conversion cannot be performed or if the value is NULL) a default value is returned.
402: // Note that these functions are slow since they perform bounds checking and conversion
403: // For fast access of values prefer using duckdb_column_data and duckdb_nullmask_data
404: 
405: /*!
406:  * returns: The boolean value at the specified location, or false if the value cannot be converted.
407:  */
408: DUCKDB_API bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row);
409: 
410: /*!
411:  * returns: The int8_t value at the specified location, or 0 if the value cannot be converted.
412:  */
413: DUCKDB_API int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row);
414: 
415: /*!
416:  * returns: The int16_t value at the specified location, or 0 if the value cannot be converted.
417:  */
418: DUCKDB_API int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row);
419: 
420: /*!
421:  * returns: The int32_t value at the specified location, or 0 if the value cannot be converted.
422:  */
423: DUCKDB_API int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row);
424: 
425: /*!
426:  * returns: The int64_t value at the specified location, or 0 if the value cannot be converted.
427:  */
428: DUCKDB_API int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row);
429: 
430: /*!
431:  * returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.
432:  */
433: DUCKDB_API duckdb_hugeint duckdb_value_hugeint(duckdb_result *result, idx_t col, idx_t row);
434: 
435: /*!
436:  * returns: The uint8_t value at the specified location, or 0 if the value cannot be converted.
437:  */
438: DUCKDB_API uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row);
439: 
440: /*!
441:  * returns: The uint16_t value at the specified location, or 0 if the value cannot be converted.
442:  */
443: DUCKDB_API uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row);
444: 
445: /*!
446:  * returns: The uint32_t value at the specified location, or 0 if the value cannot be converted.
447:  */
448: DUCKDB_API uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row);
449: 
450: /*!
451:  * returns: The uint64_t value at the specified location, or 0 if the value cannot be converted.
452:  */
453: DUCKDB_API uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row);
454: 
455: /*!
456:  * returns: The float value at the specified location, or 0 if the value cannot be converted.
457:  */
458: DUCKDB_API float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row);
459: 
460: /*!
461:  * returns: The double value at the specified location, or 0 if the value cannot be converted.
462:  */
463: DUCKDB_API double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row);
464: 
465: /*!
466:  * returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted.
467:  */
468: DUCKDB_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);
469: 
470: /*!
471:  * returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted.
472:  */
473: DUCKDB_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);
474: 
475: /*!
476:  * returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.
477:  */
478: DUCKDB_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);
479: 
480: /*!
481:  * returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted.
482:  */
483: DUCKDB_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);
484: 
485: /*!
486: * returns: The char* value at the specified location, or nullptr if the value cannot be converted.
487: The result must be freed with `duckdb_free`.
488: */
489: DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);
490: 
491: /*!
492: * returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
493: If the column is NOT a VARCHAR column this function will return NULL.
494: 
495: The result must NOT be freed.
496: */
497: DUCKDB_API char *duckdb_value_varchar_internal(duckdb_result *result, idx_t col, idx_t row);
498: 
499: /*!
500: * returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the
501: value cannot be converted. The resulting "blob.data" must be freed with `duckdb_free.`
502: */
503: DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);
504: 
505: /*!
506:  * returns: Returns true if the value at the specified index is NULL, and false otherwise.
507:  */
508: DUCKDB_API bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row);
509: 
510: //===--------------------------------------------------------------------===//
511: // Helpers
512: //===--------------------------------------------------------------------===//
513: /*!
514: Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner
515: should be freed using `duckdb_free`.
516: 
517: * size: The number of bytes to allocate.
518: * returns: A pointer to the allocated memory region.
519: */
520: DUCKDB_API void *duckdb_malloc(size_t size);
521: 
522: /*!
523: Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_value_blob`.
524: 
525: * ptr: The memory region to de-allocate.
526: */
527: DUCKDB_API void duckdb_free(void *ptr);
528: 
529: //===--------------------------------------------------------------------===//
530: // Date/Time/Timestamp Helpers
531: //===--------------------------------------------------------------------===//
532: /*!
533: Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).
534: 
535: * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
536: * returns: The `duckdb_date_struct` with the decomposed elements.
537: */
538: DUCKDB_API duckdb_date_struct duckdb_from_date(duckdb_date date);
539: 
540: /*!
541: Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).
542: 
543: * date: The year, month and date stored in a `duckdb_date_struct`.
544: * returns: The `duckdb_date` element.
545: */
546: DUCKDB_API duckdb_date duckdb_to_date(duckdb_date_struct date);
547: 
548: /*!
549: Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).
550: 
551: * time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.
552: * returns: The `duckdb_time_struct` with the decomposed elements.
553: */
554: DUCKDB_API duckdb_time_struct duckdb_from_time(duckdb_time time);
555: 
556: /*!
557: Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).
558: 
559: * time: The hour, minute, second and microsecond in a `duckdb_time_struct`.
560: * returns: The `duckdb_time` element.
561: */
562: DUCKDB_API duckdb_time duckdb_to_time(duckdb_time_struct time);
563: 
564: /*!
565: Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.
566: 
567: * ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
568: * returns: The `duckdb_timestamp_struct` with the decomposed elements.
569: */
570: DUCKDB_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts);
571: 
572: /*!
573: Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.
574: 
575: * ts: The de-composed elements in a `duckdb_timestamp_struct`.
576: * returns: The `duckdb_timestamp` element.
577: */
578: DUCKDB_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts);
579: 
580: //===--------------------------------------------------------------------===//
581: // Hugeint Helpers
582: //===--------------------------------------------------------------------===//
583: /*!
584: Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.
585: 
586: * val: The hugeint value.
587: * returns: The converted `double` element.
588: */
589: DUCKDB_API double duckdb_hugeint_to_double(duckdb_hugeint val);
590: 
591: /*!
592: Converts a double value to a duckdb_hugeint object.
593: 
594: If the conversion fails because the double value is too big the result will be 0.
595: 
596: * val: The double value.
597: * returns: The converted `duckdb_hugeint` element.
598: */
599: DUCKDB_API duckdb_hugeint duckdb_double_to_hugeint(double val);
600: 
601: //===--------------------------------------------------------------------===//
602: // Prepared Statements
603: //===--------------------------------------------------------------------===//
604: // A prepared statement is a parameterized query that allows you to bind parameters to it.
605: // * This is useful to easily supply parameters to functions and avoid SQL injection attacks.
606: // * This is useful to speed up queries that you will execute several times with different parameters.
607: // Because the query will only be parsed, bound, optimized and planned once during the prepare stage,
608: // rather than once per execution.
609: // For example:
610: //   SELECT * FROM tbl WHERE id=?
611: // Or a query with multiple parameters:
612: //   SELECT * FROM tbl WHERE id=$1 OR name=$2
613: 
614: /*!
615: Create a prepared statement object from a query.
616: 
617: Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using
618: `duckdb_destroy_prepare`, even if the prepare fails.
619: 
620: If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
621: 
622: * connection: The connection object
623: * query: The SQL query to prepare
624: * out_prepared_statement: The resulting prepared statement object
625: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
626: */
627: DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
628:                                        duckdb_prepared_statement *out_prepared_statement);
629: 
630: /*!
631: Closes the prepared statement and de-allocates all memory allocated for that connection.
632: 
633: * prepared_statement: The prepared statement to destroy.
634: */
635: DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);
636: 
637: /*!
638: Returns the error message associated with the given prepared statement.
639: If the prepared statement has no error message, this returns `nullptr` instead.
640: 
641: The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.
642: 
643: * prepared_statement: The prepared statement to obtain the error from.
644: * returns: The error message, or `nullptr` if there is none.
645: */
646: DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);
647: 
648: /*!
649: Returns the number of parameters that can be provided to the given prepared statement.
650: 
651: Returns 0 if the query was not successfully prepared.
652: 
653: * prepared_statement: The prepared statement to obtain the number of parameters for.
654: */
655: DUCKDB_API idx_t duckdb_nparams(duckdb_prepared_statement prepared_statement);
656: 
657: /*!
658: Returns the parameter type for the parameter at the given index.
659: 
660: Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.
661: 
662: * prepared_statement: The prepared statement.
663: * param_idx: The parameter index.
664: * returns: The parameter type
665: */
666: DUCKDB_API duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_t param_idx);
667: 
668: /*!
669: Binds a bool value to the prepared statement at the specified index.
670: */
671: DUCKDB_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);
672: 
673: /*!
674: Binds an int8_t value to the prepared statement at the specified index.
675: */
676: DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
677: 
678: /*!
679: Binds an int16_t value to the prepared statement at the specified index.
680: */
681: DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
682: 
683: /*!
684: Binds an int32_t value to the prepared statement at the specified index.
685: */
686: DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);
687: 
688: /*!
689: Binds an int64_t value to the prepared statement at the specified index.
690: */
691: DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);
692: 
693: /*!
694: Binds an duckdb_hugeint value to the prepared statement at the specified index.
695: */
696: DUCKDB_API duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,
697:                                             duckdb_hugeint val);
698: 
699: /*!
700: Binds an uint8_t value to the prepared statement at the specified index.
701: */
702: DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);
703: 
704: /*!
705: Binds an uint16_t value to the prepared statement at the specified index.
706: */
707: DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val);
708: 
709: /*!
710: Binds an uint32_t value to the prepared statement at the specified index.
711: */
712: DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);
713: 
714: /*!
715: Binds an uint64_t value to the prepared statement at the specified index.
716: */
717: DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);
718: 
719: /*!
720: Binds an float value to the prepared statement at the specified index.
721: */
722: DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);
723: 
724: /*!
725: Binds an double value to the prepared statement at the specified index.
726: */
727: DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);
728: 
729: /*!
730: Binds a duckdb_date value to the prepared statement at the specified index.
731: */
732: DUCKDB_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,
733:                                          duckdb_date val);
734: 
735: /*!
736: Binds a duckdb_time value to the prepared statement at the specified index.
737: */
738: DUCKDB_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,
739:                                          duckdb_time val);
740: 
741: /*!
742: Binds a duckdb_timestamp value to the prepared statement at the specified index.
743: */
744: DUCKDB_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,
745:                                               duckdb_timestamp val);
746: 
747: /*!
748: Binds a duckdb_interval value to the prepared statement at the specified index.
749: */
750: DUCKDB_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,
751:                                              duckdb_interval val);
752: 
753: /*!
754: Binds a null-terminated varchar value to the prepared statement at the specified index.
755: */
756: DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,
757:                                             const char *val);
758: 
759: /*!
760: Binds a varchar value to the prepared statement at the specified index.
761: */
762: DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,
763:                                                    const char *val, idx_t length);
764: 
765: /*!
766: Binds a blob value to the prepared statement at the specified index.
767: */
768: DUCKDB_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,
769:                                          const void *data, idx_t length);
770: 
771: /*!
772: Binds a NULL value to the prepared statement at the specified index.
773: */
774: DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);
775: 
776: /*!
777: Executes the prepared statement with the given bound parameters, and returns a materialized query result.
778: 
779: This method can be called multiple times for each prepared statement, and the parameters can be modified
780: between calls to this function.
781: 
782: * prepared_statement: The prepared statement to execute.
783: * out_result: The query result.
784: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
785: */
786: DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,
787:                                                 duckdb_result *out_result);
788: 
789: /*!
790: Executes the prepared statement with the given bound parameters, and returns an arrow query result.
791: 
792: * prepared_statement: The prepared statement to execute.
793: * out_result: The query result.
794: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
795: */
796: DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,
797:                                                       duckdb_arrow *out_result);
798: 
799: //===--------------------------------------------------------------------===//
800: // Appender
801: //===--------------------------------------------------------------------===//
802: 
803: // Appenders are the most efficient way of loading data into DuckDB from within the C interface, and are recommended for
804: // fast data loading. The appender is much faster than using prepared statements or individual `INSERT INTO` statements.
805: 
806: // Appends are made in row-wise format. For every column, a `duckdb_append_[type]` call should be made, after which
807: // the row should be finished by calling `duckdb_appender_end_row`. After all rows have been appended,
808: // `duckdb_appender_destroy` should be used to finalize the appender and clean up the resulting memory.
809: 
810: // Note that `duckdb_appender_destroy` should always be called on the resulting appender, even if the function returns
811: // `DuckDBError`.
812: 
813: /*!
814: Creates an appender object.
815: 
816: * connection: The connection context to create the appender in.
817: * schema: The schema of the table to append to, or `nullptr` for the default schema.
818: * table: The table name to append to.
819: * out_appender: The resulting appender object.
820: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
821: */
822: DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
823:                                                duckdb_appender *out_appender);
824: 
825: /*!
826: Returns the error message associated with the given appender.
827: If the appender has no error message, this returns `nullptr` instead.
828: 
829: The error message should be freed using `duckdb_free`.
830: 
831: * appender: The appender to get the error from.
832: * returns: The error message, or `nullptr` if there is none.
833: */
834: DUCKDB_API const char *duckdb_appender_error(duckdb_appender appender);
835: 
836: /*!
837: Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the
838: base table.
839: 
840: This should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you
841: are done with the appender.
842: 
843: * appender: The appender to flush.
844: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
845: */
846: DUCKDB_API duckdb_state duckdb_appender_flush(duckdb_appender appender);
847: 
848: /*!
849: Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.
850: 
851: This is generally not necessary. Call `duckdb_appender_destroy` instead.
852: 
853: * appender: The appender to flush and close.
854: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
855: */
856: DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);
857: 
858: /*!
859: Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating
860: all memory associated with the appender.
861: 
862: * appender: The appender to flush, close and destroy.
863: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
864: */
865: DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);
866: 
867: /*!
868: A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.
869: */
870: DUCKDB_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);
871: 
872: /*!
873: Finish the current row of appends. After end_row is called, the next row can be appended.
874: 
875: * appender: The appender.
876: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
877: */
878: DUCKDB_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);
879: 
880: /*!
881: Append a bool value to the appender.
882: */
883: DUCKDB_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);
884: 
885: /*!
886: Append an int8_t value to the appender.
887: */
888: DUCKDB_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);
889: /*!
890: Append an int16_t value to the appender.
891: */
892: DUCKDB_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);
893: /*!
894: Append an int32_t value to the appender.
895: */
896: DUCKDB_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);
897: /*!
898: Append an int64_t value to the appender.
899: */
900: DUCKDB_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);
901: /*!
902: Append a duckdb_hugeint value to the appender.
903: */
904: DUCKDB_API duckdb_state duckdb_append_hugeint(duckdb_appender appender, duckdb_hugeint value);
905: 
906: /*!
907: Append a uint8_t value to the appender.
908: */
909: DUCKDB_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);
910: /*!
911: Append a uint16_t value to the appender.
912: */
913: DUCKDB_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);
914: /*!
915: Append a uint32_t value to the appender.
916: */
917: DUCKDB_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);
918: /*!
919: Append a uint64_t value to the appender.
920: */
921: DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);
922: 
923: /*!
924: Append a float value to the appender.
925: */
926: DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);
927: /*!
928: Append a double value to the appender.
929: */
930: DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);
931: 
932: /*!
933: Append a duckdb_date value to the appender.
934: */
935: DUCKDB_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);
936: /*!
937: Append a duckdb_time value to the appender.
938: */
939: DUCKDB_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);
940: /*!
941: Append a duckdb_timestamp value to the appender.
942: */
943: DUCKDB_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);
944: /*!
945: Append a duckdb_interval value to the appender.
946: */
947: DUCKDB_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);
948: 
949: /*!
950: Append a varchar value to the appender.
951: */
952: DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);
953: /*!
954: Append a varchar value to the appender.
955: */
956: DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);
957: /*!
958: Append a blob value to the appender.
959: */
960: DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);
961: /*!
962: Append a NULL value to the appender (of any type).
963: */
964: DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);
965: 
966: //===--------------------------------------------------------------------===//
967: // Arrow Interface
968: //===--------------------------------------------------------------------===//
969: /*!
970: Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.
971: If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
972: `duckdb_query_arrow_error`.
973: 
974: Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the
975: query fails, otherwise the error stored within the result will not be freed correctly.
976: 
977: * connection: The connection to perform the query in.
978: * query: The SQL query to run.
979: * out_result: The query result.
980: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
981: */
982: DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);
983: 
984: /*!
985: Fetch the internal arrow schema from the arrow result.
986: 
987: * result: The result to fetch the schema from.
988: * out_schema: The output schema.
989: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
990: */
991: DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);
992: 
993: /*!
994: Fetch an internal arrow array from the arrow result.
995: 
996: This function can be called multiple time to get next chunks, which will free the previous out_array.
997: So consume the out_array before calling this function again.
998: 
999: * result: The result to fetch the array from.
1000: * out_array: The output array.
1001: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1002: */
1003: DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);
1004: 
1005: /*!
1006: Returns the number of columns present in a the arrow result object.
1007: 
1008: * result: The result object.
1009: * returns: The number of columns present in the result object.
1010: */
1011: DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);
1012: 
1013: /*!
1014: Returns the number of rows present in a the arrow result object.
1015: 
1016: * result: The result object.
1017: * returns: The number of rows present in the result object.
1018: */
1019: DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);
1020: 
1021: /*!
1022: Returns the number of rows changed by the query stored in the arrow result. This is relevant only for
1023: INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.
1024: 
1025: * result: The result object.
1026: * returns: The number of rows changed.
1027: */
1028: DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);
1029: 
1030: /*!
1031: Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns
1032: `DuckDBError`.
1033: 
1034: The result should be freed using `duckdb_free`.
1035: 
1036: * result: The result object to fetch the nullmask from.
1037: * returns: The error of the result.
1038: */
1039: DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);
1040: 
1041: /*!
1042: Closes the result and de-allocates all memory allocated for the arrow result.
1043: 
1044: * result: The result to destroy.
1045: */
1046: DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
1047: 
1048: #ifdef __cplusplus
1049: }
1050: #endif
[end of src/include/duckdb.h]
[start of src/main/capi/appender-c.cpp]
1: #include "duckdb/main/capi_internal.hpp"
2: 
3: using duckdb::Appender;
4: using duckdb::AppenderWrapper;
5: using duckdb::Connection;
6: using duckdb::date_t;
7: using duckdb::dtime_t;
8: using duckdb::hugeint_t;
9: using duckdb::interval_t;
10: using duckdb::string_t;
11: using duckdb::timestamp_t;
12: 
13: duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
14:                                     duckdb_appender *out_appender) {
15: 	Connection *conn = (Connection *)connection;
16: 
17: 	if (!connection || !table || !out_appender) {
18: 		return DuckDBError;
19: 	}
20: 	if (schema == nullptr) {
21: 		schema = DEFAULT_SCHEMA;
22: 	}
23: 	auto wrapper = new AppenderWrapper();
24: 	*out_appender = (duckdb_appender)wrapper;
25: 	try {
26: 		wrapper->appender = duckdb::make_unique<Appender>(*conn, schema, table);
27: 	} catch (std::exception &ex) {
28: 		wrapper->error = ex.what();
29: 		return DuckDBError;
30: 	} catch (...) { // LCOV_EXCL_START
31: 		wrapper->error = "Unknown create appender error";
32: 		return DuckDBError;
33: 	} // LCOV_EXCL_STOP
34: 	return DuckDBSuccess;
35: }
36: 
37: duckdb_state duckdb_appender_destroy(duckdb_appender *appender) {
38: 	if (!appender || !*appender) {
39: 		return DuckDBError;
40: 	}
41: 	duckdb_appender_close(*appender);
42: 	auto wrapper = (AppenderWrapper *)*appender;
43: 	if (wrapper) {
44: 		delete wrapper;
45: 	}
46: 	*appender = nullptr;
47: 	return DuckDBSuccess;
48: }
49: 
50: template <class FUN>
51: duckdb_state duckdb_appender_run_function(duckdb_appender appender, FUN &&function) {
52: 	if (!appender) {
53: 		return DuckDBError;
54: 	}
55: 	auto wrapper = (AppenderWrapper *)appender;
56: 	if (!wrapper->appender) {
57: 		return DuckDBError;
58: 	}
59: 	try {
60: 		function(*wrapper->appender);
61: 	} catch (std::exception &ex) {
62: 		wrapper->error = ex.what();
63: 		return DuckDBError;
64: 	} catch (...) { // LCOV_EXCL_START
65: 		wrapper->error = "Unknown error";
66: 		return DuckDBError;
67: 	} // LCOV_EXCL_STOP
68: 	return DuckDBSuccess;
69: }
70: 
71: const char *duckdb_appender_error(duckdb_appender appender) {
72: 	if (!appender) {
73: 		return nullptr;
74: 	}
75: 	auto wrapper = (AppenderWrapper *)appender;
76: 	if (wrapper->error.empty()) {
77: 		return nullptr;
78: 	}
79: 	return strdup(wrapper->error.c_str());
80: }
81: 
82: duckdb_state duckdb_appender_begin_row(duckdb_appender appender) {
83: 	return DuckDBSuccess;
84: }
85: 
86: duckdb_state duckdb_appender_end_row(duckdb_appender appender) {
87: 	return duckdb_appender_run_function(appender, [&](Appender &appender) { appender.EndRow(); });
88: }
89: 
90: template <class T>
91: duckdb_state duckdb_append_internal(duckdb_appender appender, T value) {
92: 	if (!appender) {
93: 		return DuckDBError;
94: 	}
95: 	auto *appender_instance = (AppenderWrapper *)appender;
96: 	try {
97: 		appender_instance->appender->Append<T>(value);
98: 	} catch (...) {
99: 		return DuckDBError;
100: 	}
101: 	return DuckDBSuccess;
102: }
103: 
104: duckdb_state duckdb_append_bool(duckdb_appender appender, bool value) {
105: 	return duckdb_append_internal<bool>(appender, value);
106: }
107: 
108: duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value) {
109: 	return duckdb_append_internal<int8_t>(appender, value);
110: }
111: 
112: duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value) {
113: 	return duckdb_append_internal<int16_t>(appender, value);
114: }
115: 
116: duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value) {
117: 	return duckdb_append_internal<int32_t>(appender, value);
118: }
119: 
120: duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value) {
121: 	return duckdb_append_internal<int64_t>(appender, value);
122: }
123: 
124: duckdb_state duckdb_append_hugeint(duckdb_appender appender, duckdb_hugeint value) {
125: 	hugeint_t internal;
126: 	internal.lower = value.lower;
127: 	internal.upper = value.upper;
128: 	return duckdb_append_internal<hugeint_t>(appender, internal);
129: }
130: 
131: duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value) {
132: 	return duckdb_append_internal<uint8_t>(appender, value);
133: }
134: 
135: duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value) {
136: 	return duckdb_append_internal<uint16_t>(appender, value);
137: }
138: 
139: duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value) {
140: 	return duckdb_append_internal<uint32_t>(appender, value);
141: }
142: 
143: duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value) {
144: 	return duckdb_append_internal<uint64_t>(appender, value);
145: }
146: 
147: duckdb_state duckdb_append_float(duckdb_appender appender, float value) {
148: 	return duckdb_append_internal<float>(appender, value);
149: }
150: 
151: duckdb_state duckdb_append_double(duckdb_appender appender, double value) {
152: 	return duckdb_append_internal<double>(appender, value);
153: }
154: 
155: duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value) {
156: 	return duckdb_append_internal<date_t>(appender, date_t(value.days));
157: }
158: 
159: duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value) {
160: 	return duckdb_append_internal<dtime_t>(appender, dtime_t(value.micros));
161: }
162: 
163: duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value) {
164: 	return duckdb_append_internal<timestamp_t>(appender, timestamp_t(value.micros));
165: }
166: 
167: duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value) {
168: 	interval_t interval;
169: 	interval.months = value.months;
170: 	interval.days = value.days;
171: 	interval.micros = value.micros;
172: 	return duckdb_append_internal<interval_t>(appender, interval);
173: }
174: 
175: duckdb_state duckdb_append_null(duckdb_appender appender) {
176: 	return duckdb_append_internal<std::nullptr_t>(appender, nullptr);
177: }
178: 
179: duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val) {
180: 	return duckdb_append_internal<const char *>(appender, val);
181: }
182: 
183: duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length) {
184: 	return duckdb_append_internal<string_t>(appender, string_t(val, length));
185: }
186: duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length) {
187: 	return duckdb_append_internal<string_t>(appender, string_t((const char *)data, length));
188: }
189: 
190: duckdb_state duckdb_appender_flush(duckdb_appender appender) {
191: 	return duckdb_appender_run_function(appender, [&](Appender &appender) { appender.Flush(); });
192: }
193: 
194: duckdb_state duckdb_appender_close(duckdb_appender appender) {
195: 	return duckdb_appender_run_function(appender, [&](Appender &appender) { appender.Close(); });
196: }
[end of src/main/capi/appender-c.cpp]
[start of src/main/capi/arrow-c.cpp]
1: #include "duckdb/main/capi_internal.hpp"
2: 
3: using duckdb::ArrowResultWrapper;
4: using duckdb::Connection;
5: using duckdb::DataChunk;
6: using duckdb::LogicalType;
7: using duckdb::MaterializedQueryResult;
8: using duckdb::PreparedStatementWrapper;
9: using duckdb::QueryResult;
10: using duckdb::QueryResultType;
11: 
12: duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result) {
13: 	Connection *conn = (Connection *)connection;
14: 	auto wrapper = new ArrowResultWrapper();
15: 	wrapper->result = conn->Query(query);
16: 	*out_result = (duckdb_arrow)wrapper;
17: 	return wrapper->result->success ? DuckDBSuccess : DuckDBError;
18: }
19: 
20: duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema) {
21: 	if (!out_schema) {
22: 		return DuckDBSuccess;
23: 	}
24: 	auto wrapper = (ArrowResultWrapper *)result;
25: 	wrapper->result->ToArrowSchema((ArrowSchema *)*out_schema);
26: 	return DuckDBSuccess;
27: }
28: 
29: duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array) {
30: 	if (!out_array) {
31: 		return DuckDBSuccess;
32: 	}
33: 	auto wrapper = (ArrowResultWrapper *)result;
34: 	auto success = wrapper->result->TryFetch(wrapper->current_chunk, wrapper->result->error);
35: 	if (!success) { // LCOV_EXCL_START
36: 		return DuckDBError;
37: 	} // LCOV_EXCL_STOP
38: 	if (!wrapper->current_chunk || wrapper->current_chunk->size() == 0) {
39: 		return DuckDBSuccess;
40: 	}
41: 	wrapper->current_chunk->ToArrowArray((ArrowArray *)*out_array);
42: 	return DuckDBSuccess;
43: }
44: 
45: idx_t duckdb_arrow_row_count(duckdb_arrow result) {
46: 	auto wrapper = (ArrowResultWrapper *)result;
47: 	return wrapper->result->collection.Count();
48: }
49: 
50: idx_t duckdb_arrow_column_count(duckdb_arrow result) {
51: 	auto wrapper = (ArrowResultWrapper *)result;
52: 	return wrapper->result->types.size();
53: }
54: 
55: idx_t duckdb_arrow_rows_changed(duckdb_arrow result) {
56: 	auto wrapper = (ArrowResultWrapper *)result;
57: 	idx_t rows_changed = 0;
58: 	idx_t row_count = wrapper->result->collection.Count();
59: 	if (row_count > 0 && StatementTypeReturnChanges(wrapper->result->statement_type)) {
60: 		auto row_changes = wrapper->result->GetValue(0, 0);
61: 		if (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {
62: 			rows_changed = row_changes.GetValue<int64_t>();
63: 		}
64: 	}
65: 	return rows_changed;
66: }
67: 
68: const char *duckdb_query_arrow_error(duckdb_arrow result) {
69: 	auto wrapper = (ArrowResultWrapper *)result;
70: 	return strdup(wrapper->result->error.c_str());
71: }
72: 
73: void duckdb_destroy_arrow(duckdb_arrow *result) {
74: 	if (*result) {
75: 		auto wrapper = (ArrowResultWrapper *)*result;
76: 		delete wrapper;
77: 		*result = nullptr;
78: 	}
79: }
80: 
81: duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement, duckdb_arrow *out_result) {
82: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
83: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success || !out_result) {
84: 		return DuckDBError;
85: 	}
86: 	auto arrow_wrapper = new ArrowResultWrapper();
87: 	auto result = wrapper->statement->Execute(wrapper->values, false);
88: 	D_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);
89: 	arrow_wrapper->result = duckdb::unique_ptr_cast<QueryResult, MaterializedQueryResult>(move(result));
90: 	*out_result = (duckdb_arrow)arrow_wrapper;
91: 	return arrow_wrapper->result->success ? DuckDBSuccess : DuckDBError;
92: }
[end of src/main/capi/arrow-c.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: