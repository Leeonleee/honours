{
  "repo": "duckdb/duckdb",
  "pull_number": 4346,
  "instance_id": "duckdb__duckdb-4346",
  "issue_numbers": [
    "4024"
  ],
  "base_commit": "c0a4ab96c626426961c207f49c19aa81448e91da",
  "patch": "diff --git a/src/function/table/system/duckdb_constraints.cpp b/src/function/table/system/duckdb_constraints.cpp\nindex e9ea10c087cd..98a5ef51c758 100644\n--- a/src/function/table/system/duckdb_constraints.cpp\n+++ b/src/function/table/system/duckdb_constraints.cpp\n@@ -17,13 +17,45 @@\n \n namespace duckdb {\n \n+struct UniqueKeyInfo {\n+\tstring schema, table;\n+\tvector<storage_t> columns;\n+\n+\tbool operator==(const UniqueKeyInfo &other) const {\n+\t\treturn (schema == other.schema) && (table == other.table) && (columns == other.columns);\n+\t}\n+};\n+\n+} // namespace duckdb\n+\n+namespace std {\n+\n+template <>\n+struct hash<duckdb::UniqueKeyInfo> {\n+\ttemplate <class X>\n+\tstatic size_t ComputeHash(const X &x) {\n+\t\treturn hash<X>()(x);\n+\t}\n+\n+\tsize_t operator()(const duckdb::UniqueKeyInfo &j) const {\n+\t\tD_ASSERT(j.columns.size() > 0);\n+\t\treturn ComputeHash(j.schema) + ComputeHash(j.table) + ComputeHash(j.columns[0]);\n+\t}\n+};\n+\n+} // namespace std\n+\n+namespace duckdb {\n+\n struct DuckDBConstraintsData : public GlobalTableFunctionState {\n-\tDuckDBConstraintsData() : offset(0), constraint_offset(0) {\n+\tDuckDBConstraintsData() : offset(0), constraint_offset(0), unique_constraint_offset(0) {\n \t}\n \n \tvector<CatalogEntry *> entries;\n \tidx_t offset;\n \tidx_t constraint_offset;\n+\tidx_t unique_constraint_offset;\n+\tunordered_map<UniqueKeyInfo, idx_t> known_fk_unique_constraint_offsets;\n };\n \n static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, TableFunctionBindInput &input,\n@@ -54,7 +86,6 @@ static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, Ta\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \n \tnames.emplace_back(\"constraint_column_indexes\");\n-\t;\n \treturn_types.push_back(LogicalType::LIST(LogicalType::BIGINT));\n \n \tnames.emplace_back(\"constraint_column_names\");\n@@ -66,15 +97,29 @@ static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, Ta\n unique_ptr<GlobalTableFunctionState> DuckDBConstraintsInit(ClientContext &context, TableFunctionInitInput &input) {\n \tauto result = make_unique<DuckDBConstraintsData>();\n \n-\t// scan all the schemas for tables and collect themand collect them\n+\t// scan all the schemas for tables and collect them\n \tauto schemas = Catalog::GetCatalog(context).schemas->GetEntries<SchemaCatalogEntry>(context);\n+\n+\tsort(schemas.begin(), schemas.end(), [&](CatalogEntry *x, CatalogEntry *y) { return (x->name < y->name); });\n+\n+\t// check the temp schema as well\n+\tauto &temp_schema = ClientData::Get(context).temporary_objects;\n+\tschemas.push_back(temp_schema.get());\n+\n \tfor (auto &schema : schemas) {\n-\t\tschema->Scan(context, CatalogType::TABLE_ENTRY, [&](CatalogEntry *entry) { result->entries.push_back(entry); });\n+\t\tvector<CatalogEntry *> entries;\n+\n+\t\tschema->Scan(context, CatalogType::TABLE_ENTRY, [&](CatalogEntry *entry) {\n+\t\t\tif (entry->type == CatalogType::TABLE_ENTRY) {\n+\t\t\t\tentries.push_back(entry);\n+\t\t\t}\n+\t\t});\n+\n+\t\tsort(entries.begin(), entries.end(), [&](CatalogEntry *x, CatalogEntry *y) { return (x->name < y->name); });\n+\n+\t\tresult->entries.insert(result->entries.end(), entries.begin(), entries.end());\n \t};\n \n-\t// check the temp schema as well\n-\tClientData::Get(context).temporary_objects->Scan(context, CatalogType::TABLE_ENTRY,\n-\t                                                 [&](CatalogEntry *entry) { result->entries.push_back(entry); });\n \treturn move(result);\n }\n \n@@ -89,30 +134,15 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_\n \tidx_t count = 0;\n \twhile (data.offset < data.entries.size() && count < STANDARD_VECTOR_SIZE) {\n \t\tauto &entry = data.entries[data.offset];\n-\n-\t\tif (entry->type != CatalogType::TABLE_ENTRY) {\n-\t\t\tdata.offset++;\n-\t\t\tcontinue;\n-\t\t}\n+\t\tD_ASSERT(entry->type == CatalogType::TABLE_ENTRY);\n \n \t\tauto &table = (TableCatalogEntry &)*entry;\n \t\tfor (; data.constraint_offset < table.constraints.size() && count < STANDARD_VECTOR_SIZE;\n \t\t     data.constraint_offset++) {\n \t\t\tauto &constraint = table.constraints[data.constraint_offset];\n \t\t\t// return values:\n-\t\t\t// schema_name, LogicalType::VARCHAR\n-\t\t\toutput.SetValue(0, count, Value(table.schema->name));\n-\t\t\t// schema_oid, LogicalType::BIGINT\n-\t\t\toutput.SetValue(1, count, Value::BIGINT(table.schema->oid));\n-\t\t\t// table_name, LogicalType::VARCHAR\n-\t\t\toutput.SetValue(2, count, Value(table.name));\n-\t\t\t// table_oid, LogicalType::BIGINT\n-\t\t\toutput.SetValue(3, count, Value::BIGINT(table.oid));\n-\n-\t\t\t// constraint_index, BIGINT\n-\t\t\toutput.SetValue(4, count, Value::BIGINT(data.constraint_offset));\n-\n \t\t\t// constraint_type, VARCHAR\n+\t\t\t// Processing this first due to shortcut (early continue)\n \t\t\tstring constraint_type;\n \t\t\tswitch (constraint->type) {\n \t\t\tcase ConstraintType::CHECK:\n@@ -126,14 +156,73 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_\n \t\t\tcase ConstraintType::NOT_NULL:\n \t\t\t\tconstraint_type = \"NOT NULL\";\n \t\t\t\tbreak;\n-\t\t\tcase ConstraintType::FOREIGN_KEY:\n+\t\t\tcase ConstraintType::FOREIGN_KEY: {\n+\t\t\t\tauto &bound_foreign_key =\n+\t\t\t\t    (const BoundForeignKeyConstraint &)*table.bound_constraints[data.constraint_offset];\n+\t\t\t\tif (bound_foreign_key.info.type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE) {\n+\t\t\t\t\t// Those are already covered by PRIMARY KEY and UNIQUE entries\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \t\t\t\tconstraint_type = \"FOREIGN KEY\";\n \t\t\t\tbreak;\n+\t\t\t}\n \t\t\tdefault:\n \t\t\t\tthrow NotImplementedException(\"Unimplemented constraint for duckdb_constraints\");\n \t\t\t}\n \t\t\toutput.SetValue(5, count, Value(constraint_type));\n \n+\t\t\t// schema_name, LogicalType::VARCHAR\n+\t\t\toutput.SetValue(0, count, Value(table.schema->name));\n+\t\t\t// schema_oid, LogicalType::BIGINT\n+\t\t\toutput.SetValue(1, count, Value::BIGINT(table.schema->oid));\n+\t\t\t// table_name, LogicalType::VARCHAR\n+\t\t\toutput.SetValue(2, count, Value(table.name));\n+\t\t\t// table_oid, LogicalType::BIGINT\n+\t\t\toutput.SetValue(3, count, Value::BIGINT(table.oid));\n+\n+\t\t\t// constraint_index, BIGINT\n+\t\t\tauto &bound_constraint = (BoundConstraint &)*table.bound_constraints[data.constraint_offset];\n+\t\t\tUniqueKeyInfo uk_info;\n+\t\t\tswitch (bound_constraint.type) {\n+\t\t\tcase ConstraintType::UNIQUE: {\n+\t\t\t\tauto &bound_unique = (BoundUniqueConstraint &)bound_constraint;\n+\t\t\t\tuk_info = {table.schema->name, table.name, bound_unique.keys};\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tcase ConstraintType::FOREIGN_KEY: {\n+\t\t\t\tconst auto &bound_foreign_key = (const BoundForeignKeyConstraint &)bound_constraint;\n+\t\t\t\tconst auto &info = bound_foreign_key.info;\n+\t\t\t\tuk_info = {info.schema, info.table, info.pk_keys};\n+\t\t\t\tif (uk_info.schema.empty()) {\n+\t\t\t\t\t// FIXME: Can we somehow make use of Binder::BindSchema() here?\n+\t\t\t\t\t// From experiments, an omitted schema in REFERENCES ... means \"main\" or \"temp\", even if the table\n+\t\t\t\t\t// resides in a different schema. Is this guaranteed to be stable?\n+\t\t\t\t\tif (entry->temporary) {\n+\t\t\t\t\t\tuk_info.schema = \"temp\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tuk_info.schema = \"main\";\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tif (uk_info.columns.empty()) {\n+\t\t\t\toutput.SetValue(4, count, Value::BIGINT(data.unique_constraint_offset++));\n+\t\t\t} else {\n+\t\t\t\tauto known_unique_constraint_offset = data.known_fk_unique_constraint_offsets.find(uk_info);\n+\t\t\t\tif (known_unique_constraint_offset == data.known_fk_unique_constraint_offsets.end()) {\n+\t\t\t\t\tdata.known_fk_unique_constraint_offsets.insert(make_pair(uk_info, data.unique_constraint_offset));\n+\t\t\t\t\toutput.SetValue(4, count, Value::BIGINT(data.unique_constraint_offset));\n+\t\t\t\t\tdata.unique_constraint_offset++;\n+\t\t\t\t} else {\n+\t\t\t\t\toutput.SetValue(4, count, Value::BIGINT(known_unique_constraint_offset->second));\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\t// constraint_text, VARCHAR\n \t\t\toutput.SetValue(6, count, Value(constraint->ToString()));\n \n@@ -145,7 +234,6 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_\n \t\t\t}\n \t\t\toutput.SetValue(7, count, expression_text);\n \n-\t\t\tauto &bound_constraint = (BoundConstraint &)*table.bound_constraints[data.constraint_offset];\n \t\t\tvector<column_t> column_index_list;\n \t\t\tswitch (bound_constraint.type) {\n \t\t\tcase ConstraintType::CHECK: {\n@@ -168,7 +256,7 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase ConstraintType::FOREIGN_KEY: {\n-\t\t\t\tauto &bound_foreign_key = (BoundForeignKeyConstraint &)bound_constraint;\n+\t\t\t\tauto &bound_foreign_key = (const BoundForeignKeyConstraint &)bound_constraint;\n \t\t\t\tfor (auto &col_idx : bound_foreign_key.info.fk_keys) {\n \t\t\t\t\tcolumn_index_list.push_back(column_t(col_idx));\n \t\t\t\t}\ndiff --git a/src/include/duckdb/parser/constraint.hpp b/src/include/duckdb/parser/constraint.hpp\nindex baf3c9fd713a..d3db616179f6 100644\n--- a/src/include/duckdb/parser/constraint.hpp\n+++ b/src/include/duckdb/parser/constraint.hpp\n@@ -44,7 +44,7 @@ struct ForeignKeyInfo {\n \t//! The set of main key table's column's index\n \tvector<storage_t> pk_keys;\n \t//! The set of foreign key table's column's index\n-\tvector<idx_t> fk_keys;\n+\tvector<storage_t> fk_keys;\n };\n \n //! Constraint is the base class of any type of table constraint.\n",
  "test_patch": "diff --git a/test/sql/table_function/duckdb_constraints.test b/test/sql/table_function/duckdb_constraints.test\nindex 9fdffc9b6c65..94f3920f526a 100644\n--- a/test/sql/table_function/duckdb_constraints.test\n+++ b/test/sql/table_function/duckdb_constraints.test\n@@ -14,6 +14,9 @@ create table test(i varchar unique, k varchar, check(len(i || k) < 10));\n statement ok\n create table fk_integers(j int, foreign key (j) references integers(i));\n \n+statement ok\n+create table fk_integers_2(k int, foreign key (k) references integers(i));\n+\n statement ok nosort duckdb_col\n SELECT * FROM duckdb_constraints();\n \n@@ -24,10 +27,10 @@ query IIII\n SELECT table_name, constraint_index, constraint_type, UNNEST(constraint_column_names) col_name FROM duckdb_constraints ORDER BY table_name, constraint_index, col_name\n ----\n fk_integers\t0\tFOREIGN KEY\tj\n+fk_integers_2\t0\tFOREIGN KEY\tk\n integers\t0\tPRIMARY KEY\ti\n integers\t1\tCHECK\ti\n integers\t2\tNOT NULL\ti\n-integers\t3\tFOREIGN KEY\ti\n-test\t0\tUNIQUE\ti\n-test\t1\tCHECK\ti\n-test\t1\tCHECK\tk\n+test\t3\tUNIQUE\ti\n+test\t4\tCHECK\ti\n+test\t4\tCHECK\tk\ndiff --git a/test/sql/table_function/duckdb_constraints_fk.test b/test/sql/table_function/duckdb_constraints_fk.test\nnew file mode 100644\nindex 000000000000..649147433c19\n--- /dev/null\n+++ b/test/sql/table_function/duckdb_constraints_fk.test\n@@ -0,0 +1,55 @@\n+# name: test/sql/table_function/duckdb_constraints_fk.test\n+# description: Test duckdb_constraints function\n+# group: [table_function]\n+\n+require skip_reload\n+\n+\n+statement ok\n+CREATE TABLE tf_1 (\n+  a integer, \"b c\" integer, \"d e\" integer,\n+  PRIMARY KEY (a),\n+  UNIQUE (\"b c\"),\n+  UNIQUE (\"d e\")\n+);\n+\n+statement ok\n+CREATE TABLE tf_3 (\n+  g integer, h integer,\n+  PRIMARY KEY (g),\n+  UNIQUE (h)\n+);\n+\n+statement ok\n+CREATE TABLE tf_2 (\n+  c integer, d integer, e integer, f integer, g integer,\n+  PRIMARY KEY (c),\n+  FOREIGN KEY (d) REFERENCES tf_1 (a),\n+  FOREIGN KEY (e) REFERENCES tf_1 (\"b c\"),\n+  FOREIGN KEY (f) REFERENCES tf_1 (\"d e\"),\n+  FOREIGN KEY (g) REFERENCES tf_3 (g),\n+);\n+\n+statement ok\n+CREATE TABLE tf_4 (\n+  h integer,\n+  FOREIGN KEY (h) REFERENCES tf_3 (h),\n+);\n+\n+query IIIIIIII\n+SELECT * EXCLUDE (schema_oid, table_oid) FROM duckdb_constraints();\n+----\n+main\ttf_1\t0\tPRIMARY KEY\tPRIMARY KEY(a)\tNULL\t[0]\t[a]\n+main\ttf_1\t1\tUNIQUE\tUNIQUE(\"b c\")\tNULL\t[1]\t[b c]\n+main\ttf_1\t2\tUNIQUE\tUNIQUE(\"d e\")\tNULL\t[2]\t[d e]\n+main\ttf_1\t3\tNOT NULL\tNOT NULL\tNULL\t[0]\t[a]\n+main\ttf_2\t4\tPRIMARY KEY\tPRIMARY KEY(c)\tNULL\t[0]\t[c]\n+main\ttf_2\t0\tFOREIGN KEY\tFOREIGN KEY (d) REFERENCES tf_1(a)\tNULL\t[1]\t[d]\n+main\ttf_2\t1\tFOREIGN KEY\tFOREIGN KEY (e) REFERENCES tf_1(\"b c\")\tNULL\t[2]\t[e]\n+main\ttf_2\t2\tFOREIGN KEY\tFOREIGN KEY (f) REFERENCES tf_1(\"d e\")\tNULL\t[3]\t[f]\n+main\ttf_2\t5\tFOREIGN KEY\tFOREIGN KEY (g) REFERENCES tf_3(g)\tNULL\t[4]\t[g]\n+main\ttf_2\t6\tNOT NULL\tNOT NULL\tNULL\t[0]\t[c]\n+main\ttf_3\t5\tPRIMARY KEY\tPRIMARY KEY(g)\tNULL\t[0]\t[g]\n+main\ttf_3\t7\tUNIQUE\tUNIQUE(h)\tNULL\t[1]\t[h]\n+main\ttf_3\t8\tNOT NULL\tNOT NULL\tNULL\t[0]\t[g]\n+main\ttf_4\t7\tFOREIGN KEY\tFOREIGN KEY (h) REFERENCES tf_3(h)\tNULL\t[0]\t[h]\n",
  "problem_statement": "Does duckdb_constraints() contain all relevant information?\n#### What happens?\r\n\r\nIn the example below, it seems that only the `constraint_text` column contains all information necessary to recreate a foreign key, in particular if it points to a `UNIQUE` index and not to a primary key. I'm missing:\r\n\r\n- the table being referenced\r\n- the constraint in the referenced tabled used as PK or unique constraint\r\n\r\nI also wonder if you'd like to support `information_schema.table_constraints`, `information_schema.key_column_usage` and `information_schema.constraint_column_usage` . Especially the last view is different in *all* DBMS I've looked at, but I think there's a \"correct\" version very close to the Postgres implementation. (I believe the latter is broken in some corner cases, we can do better here.)\r\n\r\n#### To Reproduce\r\n\r\n```sql\r\nCREATE TEMPORARY TABLE tf_1 (\r\n  a integer, \"b c\" integer,\r\n  PRIMARY KEY (a),\r\n  UNIQUE (\"b c\")\r\n);\r\nCREATE TEMPORARY TABLE tf_2 (\r\n  c integer, d integer, e integer,\r\n  PRIMARY KEY (c),\r\n  FOREIGN KEY (d) REFERENCES tf_1 (a),\r\n  FOREIGN KEY (e) REFERENCES tf_1 (\"b c\")\r\n);\r\n\r\nSELECT * FROM duckdb_constraints();\r\n```\r\n\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 schema_name \u2502 schema_oid \u2502 table_name \u2502 table_oid \u2502 constraint_index \u2502 constraint_type \u2502            constraint_text             \u2502 expression \u2502 constraint_column_indexes \u2502 constraint_column_names \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 temp        \u2502 1207       \u2502 tf_2       \u2502 1262      \u2502 0                \u2502 PRIMARY KEY     \u2502 PRIMARY KEY(c)                         \u2502            \u2502 [0]                       \u2502 [c]                     \u2502\r\n\u2502 temp        \u2502 1207       \u2502 tf_2       \u2502 1262      \u2502 1                \u2502 FOREIGN KEY     \u2502 FOREIGN KEY (d) REFERENCES tf_1(a)     \u2502            \u2502 [1]                       \u2502 [d]                     \u2502\r\n\u2502 temp        \u2502 1207       \u2502 tf_2       \u2502 1262      \u2502 2                \u2502 FOREIGN KEY     \u2502 FOREIGN KEY (e) REFERENCES tf_1(\"b c\") \u2502            \u2502 [2]                       \u2502 [e]                     \u2502\r\n\u2502 temp        \u2502 1207       \u2502 tf_2       \u2502 1262      \u2502 3                \u2502 NOT NULL        \u2502 NOT NULL                               \u2502            \u2502 [0]                       \u2502 [c]                     \u2502\r\n\u2502 temp        \u2502 1207       \u2502 tf_1       \u2502 1267      \u2502 0                \u2502 PRIMARY KEY     \u2502 PRIMARY KEY(a)                         \u2502            \u2502 [0]                       \u2502 [a]                     \u2502\r\n\u2502 temp        \u2502 1207       \u2502 tf_1       \u2502 1267      \u2502 1                \u2502 UNIQUE          \u2502 UNIQUE(\"b c\")                          \u2502            \u2502 [1]                       \u2502 [b c]                   \u2502\r\n\u2502 temp        \u2502 1207       \u2502 tf_1       \u2502 1267      \u2502 2                \u2502 NOT NULL        \u2502 NOT NULL                               \u2502            \u2502 [0]                       \u2502 [a]                     \u2502\r\n\u2502 temp        \u2502 1207       \u2502 tf_1       \u2502 1267      \u2502 3                \u2502 NOT NULL        \u2502 NOT NULL                               \u2502            \u2502 [0]                       \u2502 [a]                     \u2502\r\n\u2502 temp        \u2502 1207       \u2502 tf_1       \u2502 1267      \u2502 4                \u2502 FOREIGN KEY     \u2502                                        \u2502            \u2502 [2]                       \u2502 []                      \u2502\r\n\u2502 temp        \u2502 1207       \u2502 tf_1       \u2502 1267      \u2502 5                \u2502 NOT NULL        \u2502 NOT NULL                               \u2502            \u2502 [0]                       \u2502 [a]                     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n\r\n#### Environment (please complete the following information):\r\n - OS: macOS\r\n - DuckDB Version: 4d39f040c115177d7d00b5dd26b3306193f90149\r\n - DuckDB Client: CLI\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "CC @hannes.\nExpanding the `duckdb_constraints` to include more information seems fine to me. Could you submit a PR?\nStill in c0af3bf87c45f1f918adee75004376eaf2041fb9. Taking a look now.\nProposing new column names: `reference_table_name`, `reference_table_oid`, `reference_column_indexes`, `reference_column_names` .\nSounds good to me\nI only now noticed the second-to-last row in the example: `constraint_index = 4` . This row doesn't seem quite right.\r\n\r\nAn alternative approach to adding more columns is to add more *rows*, I think this particular row be expanded to contain the necessary information. From my experiments with various `INFORMATION_SCHEMA` variants, the \"longer\" form here (with more rows) is preferable because it's easier to analyze. (Only MySQL goes \"wide\" here, it's a bit of a pain.)\r\n\r\nI'll experiment with slightly different examples to see how this affects this one bogus row.\nIs it a requirement that `constraint_index` values are dense and start at 0 for each tables? Or could they be unique within the returned table?",
  "created_at": "2022-08-10T18:41:49Z"
}