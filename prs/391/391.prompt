You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Sub-second precision for TIMESTAMP
I was just wondering if someone could answer some questions around the timestamp type in duckdb?

Using fetchall:
```
>>> print(cursor.execute("SELECT TIMESTAMP '2020-01-10 00:00:00.500' as test_time").fetchall())
[[3168822576022004]]
```

Simple question... If I am creating a TIMESTAMP column, how would I convert the stored number back to a python datetime?

Using fetchnumpy:
```
>>> print(cursor.execute("SELECT TIMESTAMP '2020-01-10 00:00:00.500' as test_time").fetchnumpy())
{'test_time': masked_array(data=['2020-01-10T00:00:00.000'],
             mask=False,
       fill_value=numpy.datetime64('NaT'),
            dtype='datetime64[ms]')}
```
Looks like it is truncating the millisecond part of the timestamp.  Is that correct?

I received the same result using 0.1.1 and 0.1.2


</issue>
<code>
[start of README.md]
1: <img align="left" src="logo/duckdb-logo.png" height="120">
2: 
3: # DuckDB, the SQLite for Analytics
4: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
5: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
6: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
7: 
8: <br>
9: 
10: 
11: # Requirements
12: DuckDB requires [CMake](https://cmake.org) to be installed and a `C++11` compliant compiler. GCC 4.9 and newer, Clang 3.9 and newer and VisualStudio 2017 are tested on each revision.
13: 
14: ## Compiling
15: Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You may run `make unit` and `make allunit` to verify that your version works properly after making changes.
16: 
17: # Usage
18: A command line utility based on `sqlite3` can be found in either `build/release/tools/shell/shell` (release, the default) or `build/debug/tools/shell/shell` (debug).
19: 
20: # Embedding
21: As DuckDB is an embedded database, there is no database server to launch or client to connect to a running server. However, the database server can be embedded directly into an application using the C or C++ bindings. The main build process creates the shared library `build/release/src/libduckdb.[so|dylib|dll]` that can be linked against. A static library is built as well.
22: 
23: For examples on how to embed DuckDB into your application, see the [examples](https://github.com/cwida/duckdb/tree/master/examples) folder.
24: 
25: ## Benchmarks
26: After compiling, benchmarks can be executed from the root directory by executing `./build/release/benchmark/benchmark_runner`.
27: 
28: ## Standing on the Shoulders of Giants
29: DuckDB is implemented in C++ 11, should compile with GCC and clang, uses CMake to build and [Catch2](https://github.com/catchorg/Catch2) for testing. DuckDB uses some components from various Open-Source databases and draws inspiration from scientific publications. Here is an overview:
30: 
31: * Parser: We use the PostgreSQL parser that was [repackaged as a stand-alone library](https://github.com/lfittl/libpg_query). The translation to our own parse tree is inspired by [Peloton](https://pelotondb.io).
32: * Shell: We have adapted the [SQLite shell](https://sqlite.org/cli.html) to work with DuckDB.
33: * Tests: We use the [SQL Logic Tests from SQLite](https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki) to test DuckDB.
34: * Query fuzzing: We use [SQLsmith](https://github.com/anse1/sqlsmith) to generate random queries for additional testing.
35: * Date Math: We use the date math component from [MonetDB](https://www.monetdb.org).
36: * SQL Window Functions: DuckDB's window functions implementation uses Segment Tree Aggregation as described in the paper "Efficient Processing of Window Functions in Analytical SQL Queries" by Viktor Leis, Kan Kundhikanjana, Alfons Kemper and Thomas Neumann.
37: * Execution engine: The vectorized execution engine is inspired by the paper "MonetDB/X100: Hyper-Pipelining Query Execution" by Peter Boncz, Marcin Zukowski and Niels Nes.
38: * Optimizer: DuckDB's optimizer draws inspiration from the papers "Dynamic programming strikes back" by Guido Moerkotte and Thomas Neumman as well as "Unnesting Arbitrary Queries" by Thomas Neumann and Alfons Kemper.
39: * Concurrency control: Our MVCC implementation is inspired by the paper "Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems" by Thomas Neumann, Tobias Mühlbauer and Alfons Kemper.
40: * Regular Expression: DuckDB uses Google's [RE2](https://github.com/google/re2) regular expression engine.
41: 
42: ## Other pages
43: * [Continuous Benchmarking (CB™)](https://www.duckdb.org/benchmarks/index.html), runs TPC-H, TPC-DS and some microbenchmarks on every commit
[end of README.md]
[start of tools/pythonpkg/cursor.cpp]
1: #include "cursor.h"
2: #include <vector>
3: #include "module.h"
4: 
5: #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION // motherfucker
6: 
7: #include <numpy/arrayobject.h>
8: #include <numpy/npy_common.h>
9: 
10: PyObject *duckdb_cursor_iternext(duckdb_Cursor *self);
11: 
12: static const char errmsg_fetch_across_rollback[] =
13:     "Cursor needed to be reset because of commit/rollback and can no longer be fetched from.";
14: 
15: static int duckdb_cursor_init(duckdb_Cursor *self, PyObject *args, PyObject *kwargs) {
16: 	duckdb_Connection *connection;
17: 
18: 	if (!PyArg_ParseTuple(args, "O!", &duckdb_ConnectionType, &connection)) {
19: 		return -1;
20: 	}
21: 
22: 	Py_INCREF(connection);
23: 	// unclear but works
24: 	Py_XSETREF(self->connection, connection);
25: 	self->closed = 0;
26: 	self->reset = 0;
27: 	self->rowcount = -1L;
28: 
29: 	self->initialized = 1;
30: 
31: 	return 0;
32: }
33: 
34: static void duckdb_cursor_dealloc(duckdb_Cursor *self) {
35: 	/* Reset the statement if the user has not closed the cursor */
36: 	duckdb_cursor_close(self, NULL);
37: 
38: 	Py_XDECREF(self->connection);
39: 	Py_TYPE(self)->tp_free((PyObject *)self);
40: }
41: 
42: /*
43:  * Checks if a cursor object is usable.
44:  *
45:  * 0 => error; 1 => ok
46:  */
47: static int check_cursor(duckdb_Cursor *cur) {
48: 	if (!cur->initialized) {
49: 		PyErr_SetString(duckdb_DatabaseError, "Base Cursor.__init__ not called.");
50: 		return 0;
51: 	}
52: 
53: 	if (cur->closed) {
54: 		PyErr_SetString(duckdb_DatabaseError, "Cannot operate on a closed cursor.");
55: 		return 0;
56: 	}
57: 
58: 	return duckdb_check_connection(cur->connection);
59: }
60: 
61: static const char *_duckdb_stringconvert(PyObject *pystr) {
62: 	const char *cstr;
63: #if PY_MAJOR_VERSION >= 3
64: 	assert(PyUnicode_Check(pystr));
65: 	Py_ssize_t cstr_len;
66: 	cstr = PyUnicode_AsUTF8AndSize(pystr, &cstr_len);
67: 
68: 	if (cstr == NULL) {
69: 		throw std::runtime_error("Got NULL pointer from string object");
70: 	}
71: 	if (strlen(cstr) != (size_t)cstr_len) {
72: 		throw std::runtime_error("String object has embedded NULL");
73: 	}
74: #else
75: 	if (PyString_Check(pystr)) {
76: 		cstr = PyString_AsString(pystr);
77: 	} else {
78: 		auto bytestr = PyUnicode_AsUTF8String(pystr);
79: 		if (!bytestr) {
80: 			throw std::runtime_error("Can't convert string object to unicode");
81: 		}
82: 		cstr = PyString_AsString(bytestr);
83: 	}
84: 	if (cstr == NULL) {
85: 		throw std::runtime_error("Got NULL pointer from string object");
86: 	}
87: #endif
88: 	return cstr;
89: }
90: 
91: typedef enum { TYPE_INT, TYPE_LONG, TYPE_FLOAT, TYPE_STRING, TYPE_BUFFER, TYPE_UNKNOWN } parameter_type;
92: 
93: #ifdef WORDS_BIGENDIAN
94: #define IS_LITTLE_ENDIAN 0
95: #else
96: #define IS_LITTLE_ENDIAN 1
97: #endif
98: 
99: duckdb::Value _duckdb_pyobject_to_value(PyObject *parameter) {
100: 	parameter_type paramtype = TYPE_UNKNOWN;
101: 
102: 	if (parameter == Py_None) {
103: 		return duckdb::Value();
104: 	}
105: #if PY_MAJOR_VERSION < 3
106: 	if (PyInt_CheckExact(parameter)) {
107: 		paramtype = TYPE_INT;
108: 	} else
109: #endif
110: 	    if (PyLong_CheckExact(parameter)) {
111: 		paramtype = TYPE_LONG;
112: 	} else if (PyFloat_CheckExact(parameter)) {
113: 		paramtype = TYPE_FLOAT;
114: #if PY_MAJOR_VERSION >= 3
115: 	} else if (PyUnicode_CheckExact(parameter)) {
116: #else
117: 	} else if (PyString_CheckExact(parameter)) {
118: #endif
119: 		paramtype = TYPE_STRING;
120: 	} else if (PyLong_Check(parameter)) {
121: 		paramtype = TYPE_LONG;
122: 	} else if (PyFloat_Check(parameter)) {
123: 		paramtype = TYPE_FLOAT;
124: 	} else if (PyUnicode_Check(parameter)) {
125: 		paramtype = TYPE_STRING;
126: 	} else if (PyObject_CheckBuffer(parameter)) {
127: 		paramtype = TYPE_BUFFER;
128: 	} else {
129: 		paramtype = TYPE_UNKNOWN;
130: 	}
131: 
132: 	switch (paramtype) {
133: #if PY_MAJOR_VERSION < 3
134: 	case TYPE_INT: {
135: 		return duckdb::Value::BIGINT(PyInt_AsLong(parameter));
136: 	}
137: #endif
138: 	case TYPE_LONG: {
139: 		int overflow;
140: 		int64_t value = PyLong_AsLongLongAndOverflow(parameter, &overflow);
141: 		if (overflow) {
142: 			throw std::runtime_error("Overflow in long object");
143: 		}
144: 		return duckdb::Value::BIGINT(value);
145: 	}
146: 	case TYPE_FLOAT:
147: 		return duckdb::Value::DOUBLE(PyFloat_AsDouble(parameter));
148: 	case TYPE_STRING:
149: 		return duckdb::Value(_duckdb_stringconvert(parameter));
150: 	default:
151: 		break;
152: 	}
153: 	// TODO complain
154: 	throw std::runtime_error("Failed to convert object");
155: }
156: 
157: // this parameter binding mess is inherited from pysqlite
158: 
159: void _duckdb_bind_parameters(PyObject *parameters, std::vector<duckdb::Value> &params) {
160: 	PyObject *current_param;
161: 	int i;
162: 	int num_params_needed = params.size();
163: 	Py_ssize_t num_params = 0;
164: 
165: 	if (PyTuple_CheckExact(parameters) || PyList_CheckExact(parameters) ||
166: 	    (!PyDict_Check(parameters) && PySequence_Check(parameters))) {
167: 		/* parameters passed as sequence */
168: 		if (PyTuple_CheckExact(parameters)) {
169: 			num_params = PyTuple_GET_SIZE(parameters);
170: 		} else if (PyList_CheckExact(parameters)) {
171: 			num_params = PyList_GET_SIZE(parameters);
172: 		} else {
173: 			num_params = PySequence_Size(parameters);
174: 		}
175: 		if (num_params != num_params_needed) {
176: 			PyErr_Format(duckdb_DatabaseError,
177: 			             "Incorrect number of bindings supplied. The current "
178: 			             "statement uses %d, and there are %zd supplied.",
179: 			             num_params_needed, num_params);
180: 			return;
181: 		}
182: 		for (i = 0; i < num_params; i++) {
183: 			if (PyTuple_CheckExact(parameters)) {
184: 				current_param = PyTuple_GET_ITEM(parameters, i);
185: 				Py_XINCREF(current_param);
186: 			} else if (PyList_CheckExact(parameters)) {
187: 				current_param = PyList_GET_ITEM(parameters, i);
188: 				Py_XINCREF(current_param);
189: 			} else {
190: 				current_param = PySequence_GetItem(parameters, i);
191: 			}
192: 			if (!current_param) {
193: 				return;
194: 			}
195: 
196: 			try {
197: 				params[i] = _duckdb_pyobject_to_value(current_param);
198: 			} catch (std::exception &e) {
199: 				PyErr_Format(duckdb_DatabaseError, "Error binding parameter %d - %s", i, e.what());
200: 				return;
201: 			}
202: 		}
203: 	} else {
204: 		PyErr_SetString(duckdb_DatabaseError, "parameters are of unsupported type");
205: 	}
206: }
207: 
208: // many hatred
209: #if PY_MAJOR_VERSION >= 3
210: #define STRING_PARSE_FLAG "U"
211: #else
212: #define STRING_PARSE_FLAG "O"
213: #endif
214: 
215: // borrowed from the sqlite module
216: static PyObject *_duckdb_query_execute(duckdb_Cursor *self, int multiple, PyObject *args) {
217: 	PyObject *operation;
218: 	PyObject *parameters_list = NULL;
219: 	PyObject *parameters_iter = NULL;
220: 	PyObject *parameters = NULL;
221: 	PyObject *second_argument = NULL;
222: 
223: 	bool need_transaction;
224: 
225: 	std::vector<duckdb::Value> params;
226: 	std::unique_ptr<duckdb::PreparedStatement> prep;
227: 	const char *sql_cstr;
228: 
229: 	if (!check_cursor(self)) {
230: 		goto error;
231: 	}
232: 
233: 	need_transaction = multiple && self->connection->conn->context->transaction.IsAutoCommit();
234: 
235: 	if (need_transaction) {
236: 		self->connection->conn->Query("BEGIN TRANSACTION");
237: 	}
238: 
239: 	// unify the various possible parameters from `args` into `parameters_iter`
240: 	if (multiple) {
241: 		/* executemany() */
242: 		if (!PyArg_ParseTuple(args, STRING_PARSE_FLAG "O", &operation, &second_argument)) {
243: 			goto error;
244: 		}
245: 
246: 		if (PyIter_Check(second_argument)) {
247: 			/* iterator */
248: 			Py_INCREF(second_argument);
249: 			parameters_iter = second_argument;
250: 		} else {
251: 			/* sequence */
252: 			parameters_iter = PyObject_GetIter(second_argument);
253: 			if (!parameters_iter) {
254: 				goto error;
255: 			}
256: 		}
257: 	} else {
258: 		/* execute() */
259: 		if (!PyArg_ParseTuple(args, STRING_PARSE_FLAG "|O", &operation, &second_argument)) {
260: 			goto error;
261: 		}
262: 
263: 		parameters_list = PyList_New(0);
264: 		if (!parameters_list) {
265: 			goto error;
266: 		}
267: 
268: 		if (second_argument == NULL) {
269: 			second_argument = PyTuple_New(0); // push an empty tuple so we have an entry in parameters_list
270: 			if (!second_argument) {
271: 				goto error;
272: 			}
273: 		} else {
274: 			Py_INCREF(second_argument);
275: 		}
276: 		if (PyList_Append(parameters_list, second_argument) != 0) {
277: 			Py_DECREF(second_argument);
278: 			goto error;
279: 		}
280: 		Py_DECREF(second_argument);
281: 
282: 		parameters_iter = PyObject_GetIter(parameters_list);
283: 		if (!parameters_iter) {
284: 			goto error;
285: 		}
286: 	}
287: 	self->rowcount = 0L;
288: 	self->reset = 0;
289: 
290: 	sql_cstr = _duckdb_stringconvert(operation);
291: 	if (!sql_cstr) {
292: 		PyErr_SetString(duckdb_DatabaseError, "Can't convert query to string");
293: 		goto error;
294: 	}
295: 
296: 	prep = self->connection->conn->Prepare(sql_cstr);
297: 	if (!prep->success) {
298: 		PyErr_SetString(duckdb_DatabaseError, prep->error.c_str());
299: 		goto error;
300: 	}
301: 
302: 	params.resize(prep->n_param);
303: 
304: 	while (1) {
305: 		parameters = PyIter_Next(parameters_iter);
306: 		if (!parameters) {
307: 			break;
308: 		}
309: 
310: 		// bind aprameters if any
311: 		_duckdb_bind_parameters(parameters, params);
312: 		if (PyErr_Occurred()) {
313: 			goto error;
314: 		}
315: 
316: 		// fire!
317: 		auto res = prep->Execute(params, false); // TODO we could do streaming results here
318: 		if (!res->success) {
319: 			PyErr_SetString(duckdb_DatabaseError, res->error.c_str());
320: 			goto error;
321: 		}
322: 		assert(res->type == duckdb::QueryResultType::MATERIALIZED_RESULT);
323: 		self->result = std::unique_ptr<duckdb::MaterializedQueryResult>(
324: 		    static_cast<duckdb::MaterializedQueryResult *>(res.release()));
325: 		Py_XDECREF(parameters);
326: 		self->rowcount = self->result->collection.count;
327: 		self->closed = 0;
328: 		self->offset = 0;
329: 	}
330: 
331: error:
332: 	Py_XDECREF(parameters);
333: 	Py_XDECREF(parameters_iter);
334: 	Py_XDECREF(parameters_list);
335: 
336: 	if (PyErr_Occurred()) {
337: 		if (need_transaction) {
338: 			self->connection->conn->Query("ROLLBACK");
339: 		}
340: 		self->rowcount = -1L;
341: 		return NULL;
342: 	} else {
343: 		if (need_transaction) {
344: 			self->connection->conn->Query("COMMIT");
345: 		}
346: 		Py_INCREF(self);
347: 		return (PyObject *)self;
348: 	}
349: }
350: 
351: PyObject *duckdb_cursor_execute(duckdb_Cursor *self, PyObject *args) {
352: 	return _duckdb_query_execute(self, 0, args);
353: }
354: 
355: PyObject *duckdb_cursor_executemany(duckdb_Cursor *self, PyObject *args) {
356: 	return _duckdb_query_execute(self, 1, args);
357: }
358: 
359: PyObject *duckdb_cursor_fetchone(duckdb_Cursor *self) {
360: 	PyObject *row;
361: 
362: 	row = duckdb_cursor_iternext(self);
363: 	if (!row && !PyErr_Occurred()) {
364: 		Py_RETURN_NONE;
365: 	}
366: 
367: 	return row;
368: }
369: 
370: PyObject *duckdb_cursor_fetchall(duckdb_Cursor *self) {
371: 	PyObject *row;
372: 	PyObject *list;
373: 
374: 	list = PyList_New(0);
375: 	if (!list) {
376: 		return NULL;
377: 	}
378: 
379: 	/* just make sure we enter the loop */
380: 	row = (PyObject *)Py_None;
381: 	while (row) {
382: 		row = duckdb_cursor_iternext(self);
383: 		if (row) {
384: 			PyList_Append(list, row);
385: 			Py_DECREF(row);
386: 		}
387: 	}
388: 
389: 	if (PyErr_Occurred()) {
390: 		Py_DECREF(list);
391: 		return NULL;
392: 	} else {
393: 		return list;
394: 	}
395: }
396: 
397: static PyObject *fromdict_ref = NULL;
398: static PyObject *mafunc_ref = NULL;
399: 
400: static uint8_t duckdb_type_to_numpy_type(duckdb::TypeId type, duckdb::SQLTypeId sql_type) {
401: 	switch (type) {
402: 	case duckdb::TypeId::BOOLEAN:
403: 	case duckdb::TypeId::TINYINT:
404: 		return NPY_INT8;
405: 	case duckdb::TypeId::SMALLINT:
406: 		return NPY_INT16;
407: 	case duckdb::TypeId::INTEGER:
408: 		return NPY_INT32;
409: 	case duckdb::TypeId::BIGINT:
410: 		if (sql_type == duckdb::SQLTypeId::TIMESTAMP) {
411: 			return NPY_DATETIME;
412: 		} else {
413: 			return NPY_INT64;
414: 		}
415: 	case duckdb::TypeId::FLOAT:
416: 		return NPY_FLOAT32;
417: 	case duckdb::TypeId::DOUBLE:
418: 		return NPY_FLOAT64;
419: 	case duckdb::TypeId::VARCHAR:
420: 		return NPY_OBJECT;
421: 	default:
422: 		assert(0);
423: 	}
424: 	return 0;
425: }
426: 
427: typedef struct {
428: 	PyObject *array = nullptr;
429: 	PyObject *nullmask = nullptr;
430: 	bool found_nil = false;
431: } duckdb_numpy_result;
432: 
433: PyObject *duckdb_cursor_fetchnumpy(duckdb_Cursor *self) {
434: 	if (!check_cursor(self)) {
435: 		return NULL;
436: 	}
437: 
438: 	auto result = self->result.get();
439: 	assert(result);
440: 
441: 	auto ncol = result->collection.column_count();
442: 	auto nrow = result->collection.count;
443: 
444: 	auto cols = new duckdb_numpy_result[ncol];
445: 	npy_intp dims[1] = {static_cast<npy_intp>(nrow)};
446: 
447: 	// step 1: allocate data and nullmasks for columns
448: 	for (size_t col_idx = 0; col_idx < ncol; col_idx++) {
449: 
450: 		// two owned references for each column, .array and .nullmask
451: 		PyArray_Descr *descr =
452: 		    PyArray_DescrNewFromType(duckdb_type_to_numpy_type(result->types[col_idx], result->sql_types[col_idx].id));
453: 		// In the case of timestamps, we need to set the datetime64 unit explicitly.
454: 		if (result->sql_types[col_idx].id == duckdb::SQLTypeId::TIMESTAMP) {
455: 			auto dtype = reinterpret_cast<PyArray_DatetimeDTypeMetaData *>(descr->c_metadata);
456: 			dtype->meta.base = NPY_FR_ms;
457: 		}
458: 		cols[col_idx].array = PyArray_Empty(1, dims, descr, 0);
459: 		cols[col_idx].nullmask = PyArray_EMPTY(1, dims, NPY_BOOL, 0);
460: 		if (!cols[col_idx].array || !cols[col_idx].nullmask) {
461: 			PyErr_SetString(duckdb_DatabaseError, "memory allocation error");
462: 			self->result = nullptr;
463: 			return NULL;
464: 		}
465: 	}
466: 
467: 	// step 2: fetch into the allocated arrays
468: 	size_t offset = 0;
469: 	while (true) {
470: 		auto chunk = result->Fetch();
471: 		if (chunk->size() == 0)
472: 			break;
473: 		for (size_t col_idx = 0; col_idx < ncol; col_idx++) {
474: 
475: 			auto duckdb_type = result->types[col_idx];
476: 			auto duckdb_type_size = duckdb::GetTypeIdSize(duckdb_type);
477: 
478: 			char *array_data = (char *)PyArray_DATA((PyArrayObject *)cols[col_idx].array);
479: 			bool *mask_data = (bool *)PyArray_DATA((PyArrayObject *)cols[col_idx].nullmask);
480: 
481: 			// collect null mask into numpy array for masked arrays
482: 			for (size_t chunk_idx = 0; chunk_idx < chunk->size(); chunk_idx++) {
483: 				mask_data[chunk_idx + offset] = chunk->data[col_idx].nullmask[chunk_idx];
484: 				cols[col_idx].found_nil = cols[col_idx].found_nil || mask_data[chunk_idx + offset];
485: 			}
486: 
487: 			switch (duckdb_type) {
488: 			case duckdb::TypeId::VARCHAR:
489: 				for (size_t chunk_idx = 0; chunk_idx < chunk->size(); chunk_idx++) {
490: 					assert(!chunk->data[col_idx].sel_vector);
491: 					PyObject *str_obj;
492: 					if (!mask_data[chunk_idx + offset]) {
493: 						str_obj = PyUnicode_FromString(((const char **)chunk->data[col_idx].data)[chunk_idx]);
494: 					} else {
495: 						assert(cols[col_idx].found_nil);
496: 						str_obj = Py_None;
497: 						Py_INCREF(str_obj);
498: 					}
499: 					((PyObject **)array_data)[offset + chunk_idx] = str_obj;
500: 				}
501: 				break;
502: 			case duckdb::TypeId::BIGINT:
503: 				if (result->sql_types[col_idx].id == duckdb::SQLTypeId::TIMESTAMP) {
504: 					int64_t *array_data_ptr = reinterpret_cast<int64_t *>(array_data + (offset * duckdb_type_size));
505: 					duckdb::timestamp_t *chunk_data_ptr = reinterpret_cast<int64_t *>(chunk->data[col_idx].data);
506: 					for (size_t chunk_idx = 0; chunk_idx < chunk->size(); chunk_idx++) {
507: 						array_data_ptr[chunk_idx] = duckdb::Timestamp::GetEpoch(chunk_data_ptr[chunk_idx]) * 1000;
508: 					}
509: 					break;
510: 				}    // else fall-through-to-default
511: 			default: // direct mapping types
512: 				// TODO need to assert the types
513: 				assert(duckdb::TypeIsConstantSize(duckdb_type));
514: 				memcpy(array_data + (offset * duckdb_type_size), chunk->data[col_idx].data,
515: 				       duckdb_type_size * chunk->size());
516: 			}
517: 		}
518: 		offset += chunk->size();
519: 	}
520: 
521: 	// step 4: convert to masked arrays
522: 	PyObject *col_dict = PyDict_New();
523: 	assert(mafunc_ref);
524: 
525: 	for (size_t col_idx = 0; col_idx < ncol; col_idx++) {
526: 		PyObject *mask;
527: 		PyObject *maargs;
528: 
529: 		// PyTuple_SetItem() is an exception and takes over ownership, hence no DECREF for arguments to it
530: 		// https://docs.python.org/3/extending/extending.html#ownership-rules
531: 
532: 		if (!cols[col_idx].found_nil) {
533: 			maargs = PyTuple_New(1);
534: 			PyTuple_SetItem(maargs, 0, cols[col_idx].array);
535: 			Py_DECREF(cols[col_idx].nullmask);
536: 		} else {
537: 			maargs = PyTuple_New(2);
538: 			PyTuple_SetItem(maargs, 0, cols[col_idx].array);
539: 			PyTuple_SetItem(maargs, 1, cols[col_idx].nullmask);
540: 		}
541: 
542: 		// actually construct the mask by calling the masked array constructor
543: 		mask = PyObject_CallObject(mafunc_ref, maargs);
544: 		Py_DECREF(maargs);
545: 
546: 		if (!mask) {
547: 			PyErr_SetString(duckdb_DatabaseError, "unknown error");
548: 			self->result = nullptr;
549: 			return NULL;
550: 		}
551: 		auto name = PyUnicode_FromString(self->result->names[col_idx].c_str());
552: 		PyDict_SetItem(col_dict, name, mask);
553: 		Py_DECREF(name);
554: 		Py_DECREF(mask);
555: 	}
556: 	// delete our holder object, the arrays within are either gone or we transferred ownership
557: 	delete[] cols;
558: 	self->result = nullptr;
559: 
560: 	return col_dict;
561: }
562: 
563: PyObject *duckdb_cursor_fetchdf(duckdb_Cursor *self) {
564: 
565: 	PyObject *res = PyObject_CallFunctionObjArgs(fromdict_ref, duckdb_cursor_fetchnumpy(self), NULL);
566: 	if (!res) {
567: 		return NULL;
568: 	}
569: 	Py_INCREF(res);
570: 	return res;
571: }
572: 
573: PyObject *duckdb_cursor_iternext(duckdb_Cursor *self) {
574: 
575: 	if (!check_cursor(self)) {
576: 		return NULL;
577: 	}
578: 
579: 	if (self->offset >= self->rowcount) {
580: 		return NULL;
581: 	}
582: 	if (self->reset) {
583: 		PyErr_SetString(duckdb_DatabaseError, errmsg_fetch_across_rollback);
584: 		return NULL;
585: 	}
586: 
587: 	auto ncol = self->result->collection.column_count();
588: 
589: 	PyObject *row = PyList_New(ncol);
590: 
591: 	//	DUCKDB_TYPE_TIMESTAMP,
592: 	//	DUCKDB_TYPE_DATE,
593: 
594: 	// FIXME actually switch on SQL types
595: 	for (size_t col_idx = 0; col_idx < ncol; col_idx++) {
596: 		PyObject *val = NULL;
597: 		auto dval = self->result->collection.GetValue(col_idx, self->offset);
598: 
599: 		if (dval.is_null) {
600: 			PyList_SetItem(row, col_idx, Py_None);
601: 			continue;
602: 		}
603: 		switch (dval.type) {
604: 		case duckdb::TypeId::BOOLEAN:
605: 		case duckdb::TypeId::TINYINT:
606: 			val = Py_BuildValue("b", dval.value_.tinyint);
607: 			break;
608: 		case duckdb::TypeId::SMALLINT:
609: 			val = Py_BuildValue("h", dval.value_.smallint);
610: 			break;
611: 		case duckdb::TypeId::INTEGER:
612: 			val = Py_BuildValue("i", dval.value_.integer);
613: 			break;
614: 		case duckdb::TypeId::BIGINT:
615: 			val = Py_BuildValue("L", dval.value_.bigint);
616: 			break;
617: 		case duckdb::TypeId::FLOAT:
618: 			val = Py_BuildValue("f", dval.value_.float_);
619: 			break;
620: 		case duckdb::TypeId::DOUBLE:
621: 			val = Py_BuildValue("d", dval.value_.double_);
622: 			break;
623: 		case duckdb::TypeId::VARCHAR:
624: 			val = Py_BuildValue("s", dval.str_value.c_str());
625: 			break;
626: 		default:
627: 			// TODO complain
628: 			break;
629: 		}
630: 		if (val) {
631: 			Py_INCREF(val);
632: 			PyList_SetItem(row, col_idx, val);
633: 			Py_DECREF(val);
634: 		}
635: 	}
636: 
637: 	Py_INCREF(row);
638: 	self->offset++;
639: 
640: 	return row;
641: }
642: 
643: PyObject *duckdb_cursor_close(duckdb_Cursor *self, PyObject *args) {
644: 	if (!self->connection) {
645: 		PyErr_SetString(duckdb_DatabaseError, "Base Cursor.__init__ not called.");
646: 		return NULL;
647: 	}
648: 	if (!duckdb_check_connection(self->connection)) {
649: 		return NULL;
650: 	}
651: 	self->result = nullptr;
652: 
653: 	self->closed = 1;
654: 	self->rowcount = 0;
655: 	self->offset = 0;
656: 
657: 	Py_RETURN_NONE;
658: }
659: 
660: PyObject *duckdb_cursor_profile(duckdb_Cursor *self, PyObject *args) {
661: 	int check = PyObject_IsTrue(args);
662: 	if (check == -1) {
663: 		PyErr_SetString(PyExc_TypeError,
664: 		                "expected a boolean corresponding to either true (json) or false (query graph)");
665: 		return NULL;
666: 	}
667: 	if (!self->connection) {
668: 		PyErr_SetString(duckdb_DatabaseError, "Base Cursor.__init__ not called.");
669: 		return NULL;
670: 	}
671: 	if (!duckdb_check_connection(self->connection)) {
672: 		return NULL;
673: 	}
674: 	duckdb::ProfilerPrintFormat format =
675: 	    check ? duckdb::ProfilerPrintFormat::JSON : duckdb::ProfilerPrintFormat::QUERY_TREE;
676: 	return PyUnicode_FromString(self->connection->conn->GetProfilingInformation(format).c_str());
677: }
678: 
679: static PyMethodDef cursor_methods[] = {
680:     {"execute", (PyCFunction)duckdb_cursor_execute, METH_VARARGS, PyDoc_STR("Executes a SQL statement.")},
681:     {"executemany", (PyCFunction)duckdb_cursor_executemany, METH_VARARGS,
682:      PyDoc_STR("Repeatedly executes a SQL statement.")},
683:     {"fetchone", (PyCFunction)duckdb_cursor_fetchone, METH_NOARGS, PyDoc_STR("Fetches one row from the resultset.")},
684:     {"fetchall", (PyCFunction)duckdb_cursor_fetchall, METH_NOARGS, PyDoc_STR("Fetches all rows from the resultset.")},
685:     {"fetchnumpy", (PyCFunction)duckdb_cursor_fetchnumpy, METH_NOARGS,
686:      PyDoc_STR("Fetches all rows from the  resultset as a dict of numpy arrays.")},
687:     {"fetchdf", (PyCFunction)duckdb_cursor_fetchdf, METH_NOARGS,
688:      PyDoc_STR("Fetches all rows from the result set as a pandas DataFrame.")},
689:     {"close", (PyCFunction)duckdb_cursor_close, METH_NOARGS, PyDoc_STR("Closes the cursor.")},
690:     {"profile_info", (PyCFunction)duckdb_cursor_profile, METH_O,
691:      PyDoc_STR("Returns the profile information of the last running query.")},
692:     {NULL, NULL}};
693: 
694: static struct PyMemberDef cursor_members[] = {
695:     {"connection", T_OBJECT, offsetof(duckdb_Cursor, connection), READONLY},
696:     //    {"lastrowid", T_OBJECT, offsetof(pysqlite_Cursor, lastrowid), READONLY},
697:     {"rowcount", T_LONG, offsetof(duckdb_Cursor, rowcount), READONLY},
698:     {NULL}};
699: 
700: static const char cursor_doc[] = PyDoc_STR("DuckDB database cursor class.");
701: 
702: PyTypeObject duckdb_CursorType = {
703:     PyVarObject_HEAD_INIT(NULL, 0) "" MODULE_NAME ".Cursor", /* tp_name */
704:     sizeof(duckdb_Cursor),                                   /* tp_basicsize */
705:     0,                                                       /* tp_itemsize */
706:     (destructor)duckdb_cursor_dealloc,                       /* tp_dealloc */
707:     0,                                                       /* tp_print */
708:     0,                                                       /* tp_getattr */
709:     0,                                                       /* tp_setattr */
710:     0,                                                       /* tp_reserved */
711:     0,                                                       /* tp_repr */
712:     0,                                                       /* tp_as_number */
713:     0,                                                       /* tp_as_sequence */
714:     0,                                                       /* tp_as_mapping */
715:     0,                                                       /* tp_hash */
716:     0,                                                       /* tp_call */
717:     0,                                                       /* tp_str */
718:     0,                                                       /* tp_getattro */
719:     0,                                                       /* tp_setattro */
720:     0,                                                       /* tp_as_buffer */
721:     Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                /* tp_flags */
722:     cursor_doc,                                              /* tp_doc */
723:     0,                                                       /* tp_traverse */
724:     0,                                                       /* tp_clear */
725:     0,                                                       /* tp_richcompare */
726:     0,                 // offsetof(duckdb_Cursor, in_weakreflist),              /* tp_weaklistoffset */
727:     PyObject_SelfIter, /* tp_iter */
728:     (iternextfunc)duckdb_cursor_iternext, /* tp_iternext */
729:     cursor_methods,                       /* tp_methods */
730:     cursor_members,                       /* tp_members */
731:     0,                                    /* tp_getset */
732:     0,                                    /* tp_base */
733:     0,                                    /* tp_dict */
734:     0,                                    /* tp_descr_get */
735:     0,                                    /* tp_descr_set */
736:     0,                                    /* tp_dictoffset */
737:     (initproc)duckdb_cursor_init,         /* tp_init */
738:     0,                                    /* tp_alloc */
739:     0,                                    /* tp_new */
740:     0                                     /* tp_free */
741: };
742: 
743: #if PY_MAJOR_VERSION >= 3
744: static void *duckdb_pandas_init() {
745: 	if (PyArray_API == NULL) {
746: 		import_array();
747: 	}
748: 	return NULL;
749: }
750: #else
751: static void duckdb_pandas_init() {
752: 	if (PyArray_API == NULL) {
753: 		import_array();
754: 	}
755: }
756: #endif
757: 
758: extern int duckdb_cursor_setup_types(void) {
759: 	duckdb_pandas_init();
760: 
761: 	PyObject *pandas = PyImport_Import(PyUnicode_FromString("pandas"));
762: 	if (!pandas) {
763: 		return -1;
764: 	}
765: 	PyObject *dataframe = PyObject_GetAttrString(pandas, "DataFrame");
766: 	if (!dataframe) {
767: 		return -1;
768: 	}
769: 	fromdict_ref = PyObject_GetAttrString(dataframe, "from_dict");
770: 	if (!fromdict_ref) {
771: 		return -1;
772: 	}
773: 
774: 	mafunc_ref = PyObject_GetAttrString(PyImport_Import(PyUnicode_FromString("numpy.ma")), "masked_array");
775: 	if (!mafunc_ref) {
776: 		return -1;
777: 	}
778: 
779: 	duckdb_CursorType.tp_new = PyType_GenericNew;
780: 	return PyType_Ready(&duckdb_CursorType);
781: }
[end of tools/pythonpkg/cursor.cpp]
[start of tools/pythonpkg/setup.py]
1: #!/usr/bin/env python
2: # -*- coding: utf-8 -*-
3: 
4: import os
5: import numpy
6: import sys
7: import subprocess
8: import shutil
9: import platform
10: 
11: 
12: import distutils.spawn
13: from setuptools import setup, Extension
14: from setuptools.command.sdist import sdist
15: 
16: 
17: # make sure we are in the right directory
18: os.chdir(os.path.dirname(os.path.realpath(__file__)))
19: 
20: if not os.path.exists('duckdb.cpp'):
21:     prev_wd = os.getcwd()
22:     os.chdir('../..')
23:     subprocess.Popen('python scripts/amalgamation.py'.split(' ')).wait()
24:     os.chdir(prev_wd)
25:     shutil.copyfile('../../src/amalgamation/duckdb.hpp', 'duckdb.hpp')
26:     shutil.copyfile('../../src/amalgamation/duckdb.cpp', 'duckdb.cpp')
27: 
28: 
29: includes = [numpy.get_include(), '.']
30: sources = ['duckdb.cpp', 'connection.cpp', 'cursor.cpp', 'module.cpp']
31: 
32: toolchain_args = ['-std=c++11', '-Wall']
33: 
34: if platform.system() == 'Darwin':
35:     toolchain_args.extend(['-stdlib=libc++', '-mmacosx-version-min=10.7'])
36: 
37: 
38: libduckdb = Extension('duckdb',
39:     include_dirs=includes,
40:     sources=sources,
41:     extra_compile_args=toolchain_args,
42:     extra_link_args=toolchain_args,
43:     language='c++')
44: 
45: # Only include pytest-runner in setup_requires if we're invoking tests
46: if {'pytest', 'test', 'ptr'}.intersection(sys.argv):
47:     setup_requires = ['pytest-runner']
48: else:
49:     setup_requires = []
50: 
51: setup(
52:     name = "duckdb",
53:     description = 'DuckDB embedded database',
54:     keywords = 'DuckDB Database SQL OLAP',
55:     url="https://github.com/cwida/duckdb",
56:     long_description = '',
57:     install_requires=[ # these versions are still available for Python 2, newer ones aren't
58:          'numpy>=1.14',
59:          'pandas>=0.23'
60:     ],
61:     packages=['duckdb_query_graph'],
62:     include_package_data=True,
63:     setup_requires=setup_requires + ["setuptools_scm"],
64:     use_scm_version = {"root": "../..", "relative_to": __file__},
65:     tests_require=['pytest'],
66:     classifiers = [
67:         'Topic :: Database :: Database Engines/Servers',
68:         'Intended Audience :: Developers',
69:         'Development Status :: 3 - Alpha'
70:     ],
71:     ext_modules = [libduckdb],
72:     maintainer = "Hannes Muehleisen",
73:     maintainer_email = "hannes@cwi.nl"
74: )
[end of tools/pythonpkg/setup.py]
[start of tools/rpkg/DESCRIPTION]
1: Package: duckdb
2: Title: DBI Package for DuckDB
3: Version: 0.1.1
4: Author: Hannes Muehleisen <hannes@cwi.nl>
5: Maintainer: Hannes Muehleisen <hannes@cwi.nl>
6: Description: TODO
7: Depends:
8:     R (>= 3.5.0)
9: License: MPL
10: LazyData: true
11: Encoding: UTF-8
12: Imports:
13:     DBI,
14:     dbplyr,
15:     methods,
16:     testthat,
17:     utils
18: Suggests:
19:     DBItest,
20:     callr
21: GitHub: https://github.com/cwida/duckdb
22: Collate:
23:     'duckdb.R'
24:     'Driver.R'
25:     'Connection.R'
26:     'Result.R'
27: RoxygenNote: 6.1.1
28: SystemRequirements: C++11
[end of tools/rpkg/DESCRIPTION]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: