{
  "repo": "duckdb/duckdb",
  "pull_number": 14045,
  "instance_id": "duckdb__duckdb-14045",
  "issue_numbers": [
    "14026",
    "14026"
  ],
  "base_commit": "4ce455c84029195ffa4c3e540c10360ae8c73724",
  "patch": "diff --git a/src/optimizer/statistics/expression/propagate_cast.cpp b/src/optimizer/statistics/expression/propagate_cast.cpp\nindex 9cb590823b62..b5fcc8cedc9a 100644\n--- a/src/optimizer/statistics/expression/propagate_cast.cpp\n+++ b/src/optimizer/statistics/expression/propagate_cast.cpp\n@@ -27,6 +27,9 @@ static unique_ptr<BaseStatistics> StatisticsNumericCastSwitch(const BaseStatisti\n \tcase LogicalTypeId::TIME: {\n \t\tswitch (input.GetType().id()) {\n \t\tcase LogicalTypeId::TIMESTAMP:\n+\t\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\tcase LogicalTypeId::TIMESTAMP_NS:\n \t\tcase LogicalTypeId::TIMESTAMP_TZ:\n \t\t\treturn nullptr;\n \t\tdefault:\n",
  "test_patch": "diff --git a/test/sql/types/timestamp/test_timestamp_types.test b/test/sql/types/timestamp/test_timestamp_types.test\nindex 297fa17b3d0e..436576c5346b 100644\n--- a/test/sql/types/timestamp/test_timestamp_types.test\n+++ b/test/sql/types/timestamp/test_timestamp_types.test\n@@ -260,3 +260,15 @@ query I\n select '2008-01-01 00:00:11'::TIMESTAMP_NS = '2008-01-01 00:00:11'::TIMESTAMP_S\n ----\n true\n+\n+query I\n+SELECT CAST(t0.c0 AS TIME)>=('12:34:56') FROM  values ('2030-01-01'::TIMESTAMP_S), ('1969-12-23 20:44:40'::TIMESTAMP_S) as t0(c0)\n+----\n+false\n+true\n+\n+query I\n+SELECT NOT CAST(t0.c0 AS TIME)>=('12:34:56') FROM  values ('2030-01-01'::TIMESTAMP_MS), ('1969-12-23 20:44:40'::TIMESTAMP_MS) as t0(c0)\n+----\n+true\n+false\n",
  "problem_statement": "Unexpected result when casting `TIMESTAMP_S` to `TIME`\n### What happens?\n\nConsider the following test cases. The second and the third queries are unexpected since the expression and its negation cannot be evaluated as `true` at the same time. I could reproduce it using `TIMESTAMP_S`, `TIMESTAMP_NS`, and `TIMESTAMP_MS`. Things work well for `TIMESTAMP`.\n\n### To Reproduce\n\n```sql\r\nCREATE TABLE  t0(c0 TIMESTAMP_S); -- also for TIMESTAMP_NS and TIMESTAMP_MS\r\nINSERT INTO t0(c0) VALUES ('2030-01-01');\r\nINSERT INTO t0( c0) VALUES ('1969-12-23 20:44:40');\r\n\r\nSELECT * FROM t0; -- 2030-01-01 00:00:00, 1969-12-23 20:44:40\r\n-- Unexpected that both query returns the same result\r\nSELECT (CAST(t0.c0 AS TIME)>=('12:34:56')) FROM t0; -- true, true\r\nSELECT NOT (CAST(t0.c0 AS TIME)>=('12:34:56')) FROM t0; -- true, true\r\n\r\n\r\n-- original query found by TLP\r\nSELECT * FROM t0 WHERE (CAST(t0.c0 AS TIME)>=('12:34:56')) UNION ALL SELECT * FROM t0 WHERE (NOT (CAST(t0.c0 AS TIME)>=('12:34:56'))) UNION ALL SELECT * FROM t0 WHERE (((CAST(t0.c0 AS TIME)>=('12:34:56'))) IS NULL);\r\n-- 4 rows (unexpected)\r\n```\n\n### OS:\n\nUbuntu 22.04\n\n### DuckDB Version:\n\nv1.1.1-dev238 f0f78913a5\n\n### DuckDB Client:\n\nCLI\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nSuyang Zhong\n\n### Affiliation:\n\nNUS\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a source build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\nUnexpected result when casting `TIMESTAMP_S` to `TIME`\n### What happens?\n\nConsider the following test cases. The second and the third queries are unexpected since the expression and its negation cannot be evaluated as `true` at the same time. I could reproduce it using `TIMESTAMP_S`, `TIMESTAMP_NS`, and `TIMESTAMP_MS`. Things work well for `TIMESTAMP`.\n\n### To Reproduce\n\n```sql\r\nCREATE TABLE  t0(c0 TIMESTAMP_S); -- also for TIMESTAMP_NS and TIMESTAMP_MS\r\nINSERT INTO t0(c0) VALUES ('2030-01-01');\r\nINSERT INTO t0( c0) VALUES ('1969-12-23 20:44:40');\r\n\r\nSELECT * FROM t0; -- 2030-01-01 00:00:00, 1969-12-23 20:44:40\r\n-- Unexpected that both query returns the same result\r\nSELECT (CAST(t0.c0 AS TIME)>=('12:34:56')) FROM t0; -- true, true\r\nSELECT NOT (CAST(t0.c0 AS TIME)>=('12:34:56')) FROM t0; -- true, true\r\n\r\n\r\n-- original query found by TLP\r\nSELECT * FROM t0 WHERE (CAST(t0.c0 AS TIME)>=('12:34:56')) UNION ALL SELECT * FROM t0 WHERE (NOT (CAST(t0.c0 AS TIME)>=('12:34:56'))) UNION ALL SELECT * FROM t0 WHERE (((CAST(t0.c0 AS TIME)>=('12:34:56'))) IS NULL);\r\n-- 4 rows (unexpected)\r\n```\n\n### OS:\n\nUbuntu 22.04\n\n### DuckDB Version:\n\nv1.1.1-dev238 f0f78913a5\n\n### DuckDB Client:\n\nCLI\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nSuyang Zhong\n\n### Affiliation:\n\nNUS\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a source build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2024-09-20T04:30:11Z"
}