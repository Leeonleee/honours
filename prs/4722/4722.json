{
  "repo": "duckdb/duckdb",
  "pull_number": 4722,
  "instance_id": "duckdb__duckdb-4722",
  "issue_numbers": [
    "4584",
    "4584"
  ],
  "base_commit": "547e20988249dea52b080b6aec98d96fda4d0350",
  "patch": "diff --git a/src/execution/operator/schema/physical_create_index.cpp b/src/execution/operator/schema/physical_create_index.cpp\nindex f4b02bbd50a6..f82c6bf726e9 100644\n--- a/src/execution/operator/schema/physical_create_index.cpp\n+++ b/src/execution/operator/schema/physical_create_index.cpp\n@@ -40,10 +40,17 @@ void PhysicalCreateIndex::GetData(ExecutionContext &context, DataChunk &chunk, G\n \t\treturn;\n \t}\n \n+\t// convert virtual column ids to storage column ids\n+\tvector<column_t> storage_ids;\n+\tfor (auto &column_id : column_ids) {\n+\t\tD_ASSERT(column_id < table.columns.size());\n+\t\tstorage_ids.push_back(table.columns[column_id].StorageOid());\n+\t}\n+\n \tunique_ptr<Index> index;\n \tswitch (info->index_type) {\n \tcase IndexType::ART: {\n-\t\tindex = make_unique<ART>(column_ids, unbound_expressions, info->constraint_type, *context.client.db);\n+\t\tindex = make_unique<ART>(storage_ids, unbound_expressions, info->constraint_type, *context.client.db);\n \t\tbreak;\n \t}\n \tdefault:\ndiff --git a/src/include/duckdb/parser/expression/function_expression.hpp b/src/include/duckdb/parser/expression/function_expression.hpp\nindex 793273692c2c..c329a0fc31bf 100644\n--- a/src/include/duckdb/parser/expression/function_expression.hpp\n+++ b/src/include/duckdb/parser/expression/function_expression.hpp\n@@ -72,8 +72,8 @@ class FunctionExpression : public ParsedExpression {\n \t\t\t\t\treturn function_name + \"(\" + entry.children[0]->ToString() + \")\";\n \t\t\t\t}\n \t\t\t} else if (entry.children.size() == 2) {\n-\t\t\t\treturn \"(\" + entry.children[0]->ToString() + \" \" + function_name + \" \" + entry.children[1]->ToString() +\n-\t\t\t\t       \")\";\n+\t\t\t\treturn StringUtil::Format(\"(%s) %s (%s)\", entry.children[0]->ToString(), function_name,\n+\t\t\t\t                          entry.children[1]->ToString());\n \t\t\t}\n \t\t}\n \t\t// standard function call\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 95ee9c8396df..a94be21a1ee3 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -142,7 +142,6 @@ class ExpressionBinder {\n \n \tvirtual string UnsupportedAggregateMessage();\n \tvirtual string UnsupportedUnnestMessage();\n-\tvirtual bool CanContainSubqueries();\n \n \tBinder &binder;\n \tClientContext &context;\ndiff --git a/src/include/duckdb/planner/expression_binder/constant_binder.hpp b/src/include/duckdb/planner/expression_binder/constant_binder.hpp\nindex b0a699391f1d..c912aa941571 100644\n--- a/src/include/duckdb/planner/expression_binder/constant_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/constant_binder.hpp\n@@ -24,7 +24,6 @@ class ConstantBinder : public ExpressionBinder {\n \tBindResult BindExpression(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression = false) override;\n \n \tstring UnsupportedAggregateMessage() override;\n-\tbool CanContainSubqueries() override;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression_binder/order_binder.hpp b/src/include/duckdb/planner/expression_binder/order_binder.hpp\nindex cf11434365a0..500760947931 100644\n--- a/src/include/duckdb/planner/expression_binder/order_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/order_binder.hpp\n@@ -29,10 +29,13 @@ class OrderBinder {\n public:\n \tunique_ptr<Expression> Bind(unique_ptr<ParsedExpression> expr);\n \n-\tidx_t MaxCount() {\n+\tidx_t MaxCount() const {\n \t\treturn max_count;\n \t}\n \n+\tbool HasExtraList() const {\n+\t\treturn extra_list;\n+\t}\n \tunique_ptr<Expression> CreateExtraReference(unique_ptr<ParsedExpression> expr);\n \n private:\ndiff --git a/src/optimizer/filter_combiner.cpp b/src/optimizer/filter_combiner.cpp\nindex 892c9b47803b..590bea21c430 100644\n--- a/src/optimizer/filter_combiner.cpp\n+++ b/src/optimizer/filter_combiner.cpp\n@@ -581,7 +581,10 @@ FilterResult FilterCombiner::AddBoundComparisonFilter(Expression *expr) {\n \t\tauto node = GetNode(left_is_scalar ? comparison.right.get() : comparison.left.get());\n \t\tidx_t equivalence_set = GetEquivalenceSet(node);\n \t\tauto scalar = left_is_scalar ? comparison.left.get() : comparison.right.get();\n-\t\tauto constant_value = ExpressionExecutor::EvaluateScalar(*scalar);\n+\t\tValue constant_value;\n+\t\tif (!ExpressionExecutor::TryEvaluateScalar(*scalar, constant_value)) {\n+\t\t\treturn FilterResult::UNSATISFIABLE;\n+\t\t}\n \t\tif (constant_value.IsNull()) {\n \t\t\t// comparisons with null are always null (i.e. will never result in rows)\n \t\t\treturn FilterResult::UNSATISFIABLE;\n@@ -662,7 +665,11 @@ FilterResult FilterCombiner::AddFilter(Expression *expr) {\n \t}\n \tif (expr->IsFoldable()) {\n \t\t// scalar condition, evaluate it\n-\t\tauto result = ExpressionExecutor::EvaluateScalar(*expr).CastAs(LogicalType::BOOLEAN);\n+\t\tValue result;\n+\t\tif (!ExpressionExecutor::TryEvaluateScalar(*expr, result)) {\n+\t\t\treturn FilterResult::UNSUPPORTED;\n+\t\t}\n+\t\tresult = result.CastAs(LogicalType::BOOLEAN);\n \t\t// check if the filter passes\n \t\tif (result.IsNull() || !BooleanValue::Get(result)) {\n \t\t\t// the filter does not pass the scalar test, create an empty result\n@@ -686,7 +693,10 @@ FilterResult FilterCombiner::AddFilter(Expression *expr) {\n \n \t\t\tif (lower_is_scalar) {\n \t\t\t\tauto scalar = comparison.lower.get();\n-\t\t\t\tauto constant_value = ExpressionExecutor::EvaluateScalar(*scalar);\n+\t\t\t\tValue constant_value;\n+\t\t\t\tif (!ExpressionExecutor::TryEvaluateScalar(*scalar, constant_value)) {\n+\t\t\t\t\treturn FilterResult::UNSUPPORTED;\n+\t\t\t\t}\n \n \t\t\t\t// create the ExpressionValueInformation\n \t\t\t\tExpressionValueInformation info;\n@@ -719,7 +729,10 @@ FilterResult FilterCombiner::AddFilter(Expression *expr) {\n \n \t\t\tif (upper_is_scalar) {\n \t\t\t\tauto scalar = comparison.upper.get();\n-\t\t\t\tauto constant_value = ExpressionExecutor::EvaluateScalar(*scalar);\n+\t\t\t\tValue constant_value;\n+\t\t\t\tif (!ExpressionExecutor::TryEvaluateScalar(*scalar, constant_value)) {\n+\t\t\t\t\treturn FilterResult::UNSUPPORTED;\n+\t\t\t\t}\n \n \t\t\t\t// create the ExpressionValueInformation\n \t\t\t\tExpressionValueInformation info;\ndiff --git a/src/optimizer/in_clause_rewriter.cpp b/src/optimizer/in_clause_rewriter.cpp\nindex b505613e0ceb..9ed78e9141db 100644\n--- a/src/optimizer/in_clause_rewriter.cpp\n+++ b/src/optimizer/in_clause_rewriter.cpp\n@@ -34,7 +34,6 @@ unique_ptr<Expression> InClauseRewriter::VisitReplace(BoundOperatorExpression &e\n \t// IN clause with many children: try to generate a mark join that replaces this IN expression\n \t// we can only do this if the expressions in the expression list are scalar\n \tfor (idx_t i = 1; i < expr.children.size(); i++) {\n-\t\tD_ASSERT(expr.children[i]->return_type == in_type);\n \t\tif (!expr.children[i]->IsFoldable()) {\n \t\t\t// non-scalar expression\n \t\t\tall_scalar = false;\ndiff --git a/src/parser/query_node.cpp b/src/parser/query_node.cpp\nindex 0c8089810a61..80b1acf202a9 100644\n--- a/src/parser/query_node.cpp\n+++ b/src/parser/query_node.cpp\n@@ -89,7 +89,7 @@ string QueryNode::ResultModifiersToString() const {\n \t\t} else if (modifier.type == ResultModifierType::LIMIT_PERCENT_MODIFIER) {\n \t\t\tauto &limit_p_modifier = (LimitPercentModifier &)modifier;\n \t\t\tif (limit_p_modifier.limit) {\n-\t\t\t\tresult += \" LIMIT \" + limit_p_modifier.limit->ToString() + \" %\";\n+\t\t\t\tresult += \" LIMIT (\" + limit_p_modifier.limit->ToString() + \") %\";\n \t\t\t}\n \t\t\tif (limit_p_modifier.offset) {\n \t\t\t\tresult += \" OFFSET \" + limit_p_modifier.offset->ToString();\ndiff --git a/src/planner/binder/expression/bind_aggregate_expression.cpp b/src/planner/binder/expression/bind_aggregate_expression.cpp\nindex 1b3ca92b3bfc..e349583aaef1 100644\n--- a/src/planner/binder/expression/bind_aggregate_expression.cpp\n+++ b/src/planner/binder/expression/bind_aggregate_expression.cpp\n@@ -116,6 +116,8 @@ BindResult SelectBinder::BindAggregate(FunctionExpression &aggr, AggregateFuncti\n \t\t\t// we didn't bind columns, try again in children\n \t\t\treturn BindResult(error);\n \t\t}\n+\t} else if (depth > 0 && !aggregate_binder.HasBoundColumns()) {\n+\t\treturn BindResult(\"Aggregate with only constant parameters has to be bound in the root subquery\");\n \t}\n \tif (!filter_error.empty()) {\n \t\treturn BindResult(filter_error);\n@@ -123,8 +125,9 @@ BindResult SelectBinder::BindAggregate(FunctionExpression &aggr, AggregateFuncti\n \n \tif (aggr.filter) {\n \t\tauto &child = (BoundExpression &)*aggr.filter;\n-\t\tbound_filter = move(child.expr);\n+\t\tbound_filter = BoundCastExpression::AddCastToType(move(child.expr), LogicalType::BOOLEAN);\n \t}\n+\n \t// all children bound successfully\n \t// extract the children and types\n \tvector<LogicalType> types;\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 1ee22eeaed6d..105e432d5e1e 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -39,6 +39,9 @@ unique_ptr<Expression> Binder::BindDelimiter(ClientContext &context, OrderBinder\n                                              Value &delimiter_value) {\n \tauto new_binder = Binder::CreateBinder(context, this, true);\n \tif (delimiter->HasSubquery()) {\n+\t\tif (!order_binder.HasExtraList()) {\n+\t\t\tthrow BinderException(\"Subquery in LIMIT/OFFSET not supported in set operation\");\n+\t\t}\n \t\treturn order_binder.CreateExtraReference(move(delimiter));\n \t}\n \tExpressionBinder expr_binder(*new_binder, context);\n@@ -49,6 +52,8 @@ unique_ptr<Expression> Binder::BindDelimiter(ClientContext &context, OrderBinder\n \t\tdelimiter_value = ExpressionExecutor::EvaluateScalar(*expr).CastAs(type);\n \t\treturn nullptr;\n \t}\n+\t// move any correlated columns to this binder\n+\tMoveCorrelatedExpressions(*new_binder);\n \treturn expr;\n }\n \ndiff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp\nindex 9e191595d950..d37f85344ea0 100644\n--- a/src/planner/expression_binder.cpp\n+++ b/src/planner/expression_binder.cpp\n@@ -170,9 +170,6 @@ unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr\n \t// bind the main expression\n \tauto error_msg = Bind(&expr, 0, root_expression);\n \tif (!error_msg.empty()) {\n-\t\tif (!CanContainSubqueries()) {\n-\t\t\tthrow BinderException(error_msg);\n-\t\t}\n \t\t// failed to bind: try to bind correlated columns in the expression (if any)\n \t\tbool success = BindCorrelatedColumns(expr);\n \t\tif (!success) {\n@@ -230,8 +227,4 @@ string ExpressionBinder::Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, b\n \treturn string();\n }\n \n-bool ExpressionBinder::CanContainSubqueries() {\n-\treturn true;\n-}\n-\n } // namespace duckdb\ndiff --git a/src/planner/expression_binder/constant_binder.cpp b/src/planner/expression_binder/constant_binder.cpp\nindex e989aba63603..d4541a512205 100644\n--- a/src/planner/expression_binder/constant_binder.cpp\n+++ b/src/planner/expression_binder/constant_binder.cpp\n@@ -12,7 +12,7 @@ BindResult ConstantBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr\n \tcase ExpressionClass::COLUMN_REF:\n \t\treturn BindResult(clause + \" cannot contain column names\");\n \tcase ExpressionClass::SUBQUERY:\n-\t\treturn BindResult(clause + \" cannot contain subqueries\");\n+\t\tthrow BinderException(clause + \" cannot contain subqueries\");\n \tcase ExpressionClass::DEFAULT:\n \t\treturn BindResult(clause + \" cannot contain DEFAULT clause\");\n \tcase ExpressionClass::WINDOW:\n@@ -26,8 +26,4 @@ string ConstantBinder::UnsupportedAggregateMessage() {\n \treturn clause + \" cannot contain aggregates!\";\n }\n \n-bool ConstantBinder::CanContainSubqueries() {\n-\treturn false;\n-}\n-\n } // namespace duckdb\ndiff --git a/src/planner/expression_binder/order_binder.cpp b/src/planner/expression_binder/order_binder.cpp\nindex f272300399f5..eb6b6dbbe036 100644\n--- a/src/planner/expression_binder/order_binder.cpp\n+++ b/src/planner/expression_binder/order_binder.cpp\n@@ -38,6 +38,9 @@ unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &\n }\n \n unique_ptr<Expression> OrderBinder::CreateExtraReference(unique_ptr<ParsedExpression> expr) {\n+\tif (!extra_list) {\n+\t\tthrow InternalException(\"CreateExtraReference called without extra_list\");\n+\t}\n \tauto result = CreateProjectionReference(*expr, extra_list->size());\n \textra_list->push_back(move(expr));\n \treturn result;\ndiff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp\nindex 91e88268f071..fde43f7cde71 100644\n--- a/src/storage/data_table.cpp\n+++ b/src/storage/data_table.cpp\n@@ -346,7 +346,7 @@ void DataTable::InitializeParallelScan(ClientContext &context, ParallelTableScan\n \n bool DataTable::NextParallelScan(ClientContext &context, ParallelTableScanState &state, TableScanState &scan_state,\n                                  const vector<column_t> &column_ids) {\n-\twhile (state.current_row_group) {\n+\twhile (state.current_row_group && state.current_row_group->count > 0) {\n \t\tidx_t vector_index;\n \t\tidx_t max_row;\n \t\tif (ClientConfig::GetConfig(context).verify_parallelism) {\n@@ -360,13 +360,8 @@ bool DataTable::NextParallelScan(ClientContext &context, ParallelTableScanState\n \t\t\tmax_row = state.current_row_group->start + state.current_row_group->count;\n \t\t}\n \t\tmax_row = MinValue<idx_t>(max_row, state.max_row);\n-\t\tbool need_to_scan;\n-\t\tif (state.current_row_group->count == 0) {\n-\t\t\tneed_to_scan = false;\n-\t\t} else {\n-\t\t\tneed_to_scan = InitializeScanInRowGroup(scan_state, column_ids, scan_state.table_filters,\n-\t\t\t                                        state.current_row_group, vector_index, max_row);\n-\t\t}\n+\t\tbool need_to_scan = InitializeScanInRowGroup(scan_state, column_ids, scan_state.table_filters,\n+\t\t                                             state.current_row_group, vector_index, max_row);\n \t\tif (ClientConfig::GetConfig(context).verify_parallelism) {\n \t\t\tstate.vector_index++;\n \t\t\tif (state.vector_index * STANDARD_VECTOR_SIZE >= state.current_row_group->count) {\n",
  "test_patch": "diff --git a/test/fuzzer/pedro/complex_offset_clause_crash.test b/test/fuzzer/pedro/complex_offset_clause_crash.test\nnew file mode 100644\nindex 000000000000..10575329cdcc\n--- /dev/null\n+++ b/test/fuzzer/pedro/complex_offset_clause_crash.test\n@@ -0,0 +1,9 @@\n+# name: test/fuzzer/pedro/complex_offset_clause_crash.test\n+# description: Issue #4581: NULL pointer on complex OFFSET clause\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement error\n+SELECT 6 OFFSET count(*) FILTER ((SELECT 2 UNION (SELECT 2) OFFSET (SELECT LAST))) OVER ();\ndiff --git a/test/fuzzer/pedro/correlated_offset_subquery.test b/test/fuzzer/pedro/correlated_offset_subquery.test\nnew file mode 100644\nindex 000000000000..317055289001\n--- /dev/null\n+++ b/test/fuzzer/pedro/correlated_offset_subquery.test\n@@ -0,0 +1,12 @@\n+# name: test/fuzzer/pedro/correlated_offset_subquery.test\n+# description: Issue #4563: Correlated offset subquery\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement error\n+SELECT (SELECT 1 OFFSET c0) FROM (VALUES(1)) c0;\n+\n+statement error\n+SELECT 0 FROM (SELECT 8 c0) WHERE (SELECT 1 LIMIT c0);\ndiff --git a/test/fuzzer/pedro/correlated_subquery_downcast_error.test b/test/fuzzer/pedro/correlated_subquery_downcast_error.test\nnew file mode 100644\nindex 000000000000..b06613fab777\n--- /dev/null\n+++ b/test/fuzzer/pedro/correlated_subquery_downcast_error.test\n@@ -0,0 +1,13 @@\n+# name: test/fuzzer/pedro/correlated_subquery_downcast_error.test\n+# description: Issue #4568: UndefinedBehaviorSanitizer on downcast from correlated subquery\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t0(c0 INT);\n+\n+query I\n+SELECT count(*) OVER() = ANY(SELECT * FROM t0 t1 WHERE(c0 = t0.c0)) FROM t0;\n+----\ndiff --git a/test/fuzzer/pedro/date_int_optimizer_error.test b/test/fuzzer/pedro/date_int_optimizer_error.test\nnew file mode 100644\nindex 000000000000..10438b4cf102\n--- /dev/null\n+++ b/test/fuzzer/pedro/date_int_optimizer_error.test\n@@ -0,0 +1,17 @@\n+# name: test/fuzzer/pedro/date_int_optimizer_error.test\n+# description: Issue #4573: Date = int optimized vs non optimized\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t0 (c0 INT);\n+\n+query I\n+SELECT 1 FROM t0 WHERE DATE '2010-1-1' = 2;\n+----\n+\n+query I\n+SELECT 1 FROM (VALUES (1),(2),(NULL)) t0(c0) WHERE c0 BETWEEN 3 AND (CAST('inf' AS REAL) - 2);\n+----\ndiff --git a/test/fuzzer/pedro/escaped_trim_function_call.test b/test/fuzzer/pedro/escaped_trim_function_call.test\nnew file mode 100644\nindex 000000000000..d74843943265\n--- /dev/null\n+++ b/test/fuzzer/pedro/escaped_trim_function_call.test\n@@ -0,0 +1,12 @@\n+# name: test/fuzzer/pedro/escaped_trim_function_call.test\n+# description: Issue #4586: Escaped trim function call\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+SELECT \"trim\"(1);\n+\n+statement ok\n+SELECT trim(1);\ndiff --git a/test/fuzzer/pedro/forced_parallelism_empty_select.test b/test/fuzzer/pedro/forced_parallelism_empty_select.test\nnew file mode 100644\nindex 000000000000..58d8fc791088\n--- /dev/null\n+++ b/test/fuzzer/pedro/forced_parallelism_empty_select.test\n@@ -0,0 +1,12 @@\n+# name: test/fuzzer/pedro/forced_parallelism_empty_select.test\n+# description: Issue #4574: Forced parallelism with an empty select\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA verify_parallelism;\n+\n+statement ok\n+CREATE TABLE t0 (c0 INT, c1 INT);\n+\n+statement ok\n+SELECT c1 FROM t0 WHERE (c0 + c1) = 2;\ndiff --git a/test/fuzzer/pedro/in_clause_optimization_error.test b/test/fuzzer/pedro/in_clause_optimization_error.test\nnew file mode 100644\nindex 000000000000..c5f86d924ea0\n--- /dev/null\n+++ b/test/fuzzer/pedro/in_clause_optimization_error.test\n@@ -0,0 +1,39 @@\n+# name: test/fuzzer/pedro/in_clause_optimization_error.test\n+# description: Issue #4584: In clause optimization error\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t0(c0 INT);\n+\n+statement ok\n+INSERT INTO t0 VALUES (42)\n+\n+statement error\n+SELECT 0 FROM t0 WHERE ? IN (1);\n+\n+statement ok\n+PREPARE v1 AS SELECT 0 FROM t0 WHERE ? IN (1);\n+\n+query I\n+EXECUTE v1(0)\n+----\n+\n+query I\n+EXECUTE v1(1)\n+----\n+0\n+\n+statement ok\n+PREPARE v2 AS SELECT $1 FROM t0 WHERE $1 IN (1);\n+\n+query I\n+EXECUTE v2(0)\n+----\n+\n+query I\n+EXECUTE v2(1)\n+----\n+1\ndiff --git a/test/fuzzer/pedro/incorrect_offset_result.test b/test/fuzzer/pedro/incorrect_offset_result.test\nnew file mode 100644\nindex 000000000000..bd130bd00707\n--- /dev/null\n+++ b/test/fuzzer/pedro/incorrect_offset_result.test\n@@ -0,0 +1,16 @@\n+# name: test/fuzzer/pedro/incorrect_offset_result.test\n+# description: Issue #4575: OFFSET query with wrong results\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t0 (c0 INT, c1 INT);\n+\n+statement ok\n+INSERT INTO t0 (VALUES (1, 1),(2, 2),(3, 3));\n+\n+query I\n+SELECT c0 FROM t0 WHERE ((c0 + c1) = 2) OFFSET 10;\n+----\ndiff --git a/test/fuzzer/pedro/index_generated_column.test b/test/fuzzer/pedro/index_generated_column.test\nnew file mode 100644\nindex 000000000000..ac18db2f2c4d\n--- /dev/null\n+++ b/test/fuzzer/pedro/index_generated_column.test\n@@ -0,0 +1,31 @@\n+# name: test/fuzzer/pedro/index_generated_column.test\n+# description: Issue #4580: heap-buffer-overflow when creating index on table with generated columns\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t0 (c0 INT AS (1), c1 INT);\n+\n+statement ok\n+CREATE INDEX i0 ON t0 USING ART ((c0 + c1));\n+\n+query II\n+SELECT * FROM t0 WHERE (c0 + c1) = 3\n+----\n+\n+statement ok\n+INSERT INTO t0 VALUES (2)\n+\n+query II\n+SELECT * FROM t0 WHERE (c0 + c1) = 3\n+----\n+1\t2\n+\n+statement ok\n+DELETE FROM t0\n+\n+query II\n+SELECT * FROM t0 WHERE (c0 + c1) = 3\n+----\ndiff --git a/test/fuzzer/pedro/missing_subquery_error.test b/test/fuzzer/pedro/missing_subquery_error.test\nnew file mode 100644\nindex 000000000000..503bfaa8df0e\n--- /dev/null\n+++ b/test/fuzzer/pedro/missing_subquery_error.test\n@@ -0,0 +1,15 @@\n+# name: test/fuzzer/pedro/missing_subquery_error.test\n+# description: Issue #4570: Missing error message at subquery\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement error\n+WITH t2 AS (SELECT 3 WHERE count(*) FILTER (1)) SELECT 0 FROM t2\n+\n+statement error\n+SELECT (WITH t2 AS (SELECT 3 WHERE count(*)) SELECT 0 FROM t2);\n+\n+statement error\n+SELECT (WITH t2 AS (SELECT 3 WHERE count(*) FILTER (1)) SELECT 0 FROM t2);\ndiff --git a/test/fuzzer/pedro/multiplication_verification.test b/test/fuzzer/pedro/multiplication_verification.test\nnew file mode 100644\nindex 000000000000..1ee3833afbff\n--- /dev/null\n+++ b/test/fuzzer/pedro/multiplication_verification.test\n@@ -0,0 +1,14 @@\n+# name: test/fuzzer/pedro/multiplication_verification.test\n+# description: Issue #4567: Multiplication verification issue\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement error\n+SELECT 1 * (1 < 1);\n+\n+query I\n+SELECT 2 * (1 << 2);\n+----\n+8\ndiff --git a/test/fuzzer/pedro/non_boolean_aggregate_filter.test b/test/fuzzer/pedro/non_boolean_aggregate_filter.test\nnew file mode 100644\nindex 000000000000..376d96698f6e\n--- /dev/null\n+++ b/test/fuzzer/pedro/non_boolean_aggregate_filter.test\n@@ -0,0 +1,16 @@\n+# name: test/fuzzer/pedro/non_boolean_aggregate_filter.test\n+# description: Issue #4570: Non-boolean aggregate filter\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+SELECT mode(1) FILTER (0);\n+----\n+NULL\n+\n+query II\n+SELECT SUM(i), SUM(i) FILTER (i%2) FROM range(10) tbl(i);\n+----\n+45\t25\ndiff --git a/test/fuzzer/pedro/offset_query_allocator_assertion.test b/test/fuzzer/pedro/offset_query_allocator_assertion.test\nnew file mode 100644\nindex 000000000000..0b4ef0344e0c\n--- /dev/null\n+++ b/test/fuzzer/pedro/offset_query_allocator_assertion.test\n@@ -0,0 +1,16 @@\n+# name: test/fuzzer/pedro/offset_query_allocator_assertion.test\n+# description: Issue #4576: OFFSET query taking too long\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t0 (c0 INT, c1 INT);\n+\n+statement ok\n+INSERT INTO t0 (VALUES (1, 1),(2, 2),(3, 3));\n+\n+query I\n+SELECT c0 FROM t0 OFFSET 42949672960;\n+----\ndiff --git a/test/issues/rigger/string_comparison_bug.test b/test/issues/rigger/string_comparison_bug.test\nindex 1b47673d8fac..bd17beec5748 100644\n--- a/test/issues/rigger/string_comparison_bug.test\n+++ b/test/issues/rigger/string_comparison_bug.test\n@@ -212,5 +212,11 @@ COMMIT;\n statement ok\n SELECT * FROM t0 WHERE (('NN')<((t0.rowid NOT IN (t0.c1)))::VARCHAR);\n \n+statement ok\n+PRAGMA disable_verification\n+\n+statement ok\n+PRAGMA disable_optimizer\n+\n statement error\n SELECT * FROM t0 WHERE (('NN')<((t0.rowid NOT IN (t0.c1))));\ndiff --git a/tools/sqlite3_api_wrapper/test/test_sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/test/test_sqlite3_api_wrapper.cpp\nindex 0f83573ce06e..7c54b67a31a7 100644\n--- a/tools/sqlite3_api_wrapper/test/test_sqlite3_api_wrapper.cpp\n+++ b/tools/sqlite3_api_wrapper/test/test_sqlite3_api_wrapper.cpp\n@@ -148,7 +148,7 @@ TEST_CASE(\"Basic prepared statement usage\", \"[sqlite3wrapper]\") {\n \tREQUIRE(sqlite3_finalize(nullptr) == SQLITE_OK);\n \n \t// first prepare the statement again\n-\tREQUIRE(stmt.Prepare(db.db, \"SELECT * FROM test WHERE i=CAST($1 AS INTEGER)\", -1, nullptr) == SQLITE_OK);\n+\tREQUIRE(stmt.Prepare(db.db, \"SELECT CAST($1 AS INTEGER) FROM test\", -1, nullptr) == SQLITE_OK);\n \t// bind a non-integer here\n \tREQUIRE(sqlite3_bind_text(stmt.stmt, 1, \"hello\", -1, nullptr) == SQLITE_OK);\n #ifndef SQLITE_TEST\n",
  "problem_statement": "[Fuzzer] In clause optimization error\nOriginally discovered in https://github.com/duckdb/duckdb/issues/4152\n\n```\nCREATE TABLE t0(c0 INT);\nSELECT 0 FROM t0 WHERE $0 IN (1);\n```\n\nActual:\nsrc/optimizer/in_clause_rewriter.cpp:37: virtual unique_ptrduckdb::Expression duckdb::InClauseRewriter::VisitReplace(duckdb::BoundOperatorExpression &, unique_ptrduckdb::Expression *): Assertion `expr.children[i]->return_type == in_type' failed\n\nExpected:\nA proper error should be thrown.\n[Fuzzer] In clause optimization error\nOriginally discovered in https://github.com/duckdb/duckdb/issues/4152\n\n```\nCREATE TABLE t0(c0 INT);\nSELECT 0 FROM t0 WHERE $0 IN (1);\n```\n\nActual:\nsrc/optimizer/in_clause_rewriter.cpp:37: virtual unique_ptrduckdb::Expression duckdb::InClauseRewriter::VisitReplace(duckdb::BoundOperatorExpression &, unique_ptrduckdb::Expression *): Assertion `expr.children[i]->return_type == in_type' failed\n\nExpected:\nA proper error should be thrown.\n",
  "hints_text": "\n",
  "created_at": "2022-09-15T05:14:04Z"
}