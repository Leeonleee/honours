{
  "repo": "duckdb/duckdb",
  "pull_number": 4377,
  "instance_id": "duckdb__duckdb-4377",
  "issue_numbers": [
    "4116"
  ],
  "base_commit": "c0a4ab96c626426961c207f49c19aa81448e91da",
  "patch": "diff --git a/tools/rpkg/R/dbDataType__duckdb_driver.R b/tools/rpkg/R/dbDataType__duckdb_driver.R\nindex 5734efe820e1..fbf9ee635a72 100644\n--- a/tools/rpkg/R/dbDataType__duckdb_driver.R\n+++ b/tools/rpkg/R/dbDataType__duckdb_driver.R\n@@ -1,6 +1,7 @@\n #' @rdname duckdb_driver-class\n #' @usage NULL\n dbDataType__duckdb_driver <- function(dbObj, obj, ...) {\n+  # FIXME: Use RApiTypes::DetectRType()\n   if (is.null(obj)) stop(\"NULL parameter\")\n   if (is.data.frame(obj)) {\n     return(vapply(obj, function(x) dbDataType(dbObj, x), FUN.VALUE = \"character\"))\n@@ -18,7 +19,7 @@ dbDataType__duckdb_driver <- function(dbObj, obj, ...) {\n     \"DOUBLE\"\n   } else if (inherits(obj, \"POSIXt\")) {\n     \"TIMESTAMP\"\n-  } else if (is.list(obj) && all(vapply(obj, typeof, FUN.VALUE = \"character\") == \"raw\" || is.na(obj))) {\n+  } else if (inherits(obj, \"blob\") || (is.list(obj) && all(vapply(obj, typeof, FUN.VALUE = \"character\") %in% c(\"raw\", \"NULL\")))) {\n     \"BLOB\"\n   } else {\n     \"STRING\"\ndiff --git a/tools/rpkg/R/dbQuoteLiteral__duckdb_connection.R b/tools/rpkg/R/dbQuoteLiteral__duckdb_connection.R\nindex 714956e0ada4..1a204e952052 100644\n--- a/tools/rpkg/R/dbQuoteLiteral__duckdb_connection.R\n+++ b/tools/rpkg/R/dbQuoteLiteral__duckdb_connection.R\n@@ -42,7 +42,7 @@ dbQuoteLiteral__duckdb_connection <- function(conn, x, ...) {\n         if (is.null(x)) {\n           \"NULL\"\n         } else if (is.raw(x)) {\n-          paste0(\"X'\", paste(format(x), collapse = \"\"), \"'\")\n+          paste0(\"'\", paste0(\"\\\\x\", format(x), collapse = \"\"), \"'\")\n         } else {\n           stop(\"Lists must contain raw vectors or NULL\", call. = FALSE)\n         }\ndiff --git a/tools/rpkg/R/register.R b/tools/rpkg/R/register.R\nindex b6bdd0513e29..e8bdc67af678 100644\n--- a/tools/rpkg/R/register.R\n+++ b/tools/rpkg/R/register.R\n@@ -1,7 +1,8 @@\n # helper to clean up non-utf and posixlt vectors\n encode_values <- function(value) {\n-  value <- as.data.frame(value)\n-  names(value) <- enc2utf8(names(value))\n+  if (!is.null(names(value))) {\n+    names(value) <- enc2utf8(names(value))\n+  }\n \n   is_character <- vapply(value, is.character, logical(1))\n   value[is_character] <- lapply(value[is_character], enc2utf8)\ndiff --git a/tools/rpkg/src/include/typesr.hpp b/tools/rpkg/src/include/typesr.hpp\nindex 340af7d0f8e9..8c7e6987952c 100644\n--- a/tools/rpkg/src/include/typesr.hpp\n+++ b/tools/rpkg/src/include/typesr.hpp\n@@ -37,6 +37,8 @@ enum class RType {\n \tTIME_DAYS_INTEGER,\n \tTIME_WEEKS_INTEGER,\n \tINTEGER64,\n+\tLIST_OF_NULLS,\n+\tBLOB,\n };\n \n struct RApiTypes {\ndiff --git a/tools/rpkg/src/scan.cpp b/tools/rpkg/src/scan.cpp\nindex 33b5b6266a9f..458c11006846 100644\n--- a/tools/rpkg/src/scan.cpp\n+++ b/tools/rpkg/src/scan.cpp\n@@ -33,6 +33,19 @@ static void AppendStringSegment(SEXP coldata, Vector &result, idx_t row_idx, idx\n \t}\n }\n \n+static void AppendBLOBSegment(SEXP coldata, Vector &result, idx_t row_idx, idx_t count) {\n+\tauto result_data = FlatVector::GetData<string_t>(result);\n+\tauto &result_mask = FlatVector::Validity(result);\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tSEXP val = VECTOR_ELT(coldata, row_idx + i);\n+\t\tif (val == R_NilValue) {\n+\t\t\tresult_mask.SetInvalid(i);\n+\t\t} else {\n+\t\t\tresult_data[i] = string_t((char *)RAW(val), Rf_xlength(val));\n+\t\t}\n+\t}\n+}\n+\n static bool get_bool_param(named_parameter_map_t &named_parameters, string name, bool dflt = false) {\n \tbool res = dflt;\n \tauto entry = named_parameters.find(name);\n@@ -157,6 +170,9 @@ static unique_ptr<FunctionData> DataFrameScanBind(ClientContext &context, TableF\n \t\t\tcoldata_ptr = (data_ptr_t)NUMERIC_POINTER(coldata);\n \t\t\tduckdb_col_type = LogicalType::DATE;\n \t\t\tbreak;\n+\t\tcase RType::BLOB:\n+\t\t\tduckdb_col_type = LogicalType::BLOB;\n+\t\t\tbreak;\n \t\tdefault:\n \t\t\tcpp11::stop(\"rapi_execute: Unsupported column type for bind\");\n \t\t}\n@@ -370,6 +386,12 @@ static void DataFrameScanFunc(ClientContext &context, TableFunctionInput &data,\n \t\t\tAppendColumnSegment<int, date_t, RDateType>(data_ptr, v, this_count);\n \t\t\tbreak;\n \t\t}\n+\t\tcase RType::BLOB: {\n+\t\t\tAppendBLOBSegment(((data_frame)bind_data.df)[(R_xlen_t)src_df_col_idx], v, sexp_offset, this_count);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase RType::LIST_OF_NULLS:\n+\t\t\tbreak;\n \t\tdefault:\n \t\t\tcpp11::stop(\"rapi_execute: Unsupported column type for scan\");\n \t\t}\ndiff --git a/tools/rpkg/src/statement.cpp b/tools/rpkg/src/statement.cpp\nindex 0c04c4e2ab9c..83804736700b 100644\n--- a/tools/rpkg/src/statement.cpp\n+++ b/tools/rpkg/src/statement.cpp\n@@ -503,7 +503,7 @@ static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n, b\n \t\tauto &mask = FlatVector::Validity(src_vec);\n \t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n \t\t\tif (!mask.RowIsValid(row_idx)) {\n-\t\t\t\tSET_VECTOR_ELT(dest, dest_offset + row_idx, Rf_ScalarLogical(NA_LOGICAL));\n+\t\t\t\tSET_VECTOR_ELT(dest, dest_offset + row_idx, R_NilValue);\n \t\t\t} else {\n \t\t\t\tSEXP rawval = NEW_RAW(src_ptr[row_idx].GetSize());\n \t\t\t\tif (!rawval) {\ndiff --git a/tools/rpkg/src/types.cpp b/tools/rpkg/src/types.cpp\nindex ad1e69b092a2..d40e6d361c7b 100644\n--- a/tools/rpkg/src/types.cpp\n+++ b/tools/rpkg/src/types.cpp\n@@ -66,6 +66,35 @@ RType RApiTypes::DetectRType(SEXP v, bool integer64) {\n \t\treturn RType::NUMERIC;\n \t} else if (TYPEOF(v) == STRSXP) {\n \t\treturn RType::STRING;\n+\t} else if (TYPEOF(v) == VECSXP) {\n+\t\tif (Rf_inherits(v, \"blob\")) {\n+\t\t\treturn RType::BLOB;\n+\t\t}\n+\n+\t\tR_xlen_t len = Rf_length(v);\n+\t\tR_xlen_t i = 0;\n+\t\tfor (; i < len; ++i) {\n+\t\t\tauto elt = VECTOR_ELT(v, i);\n+\t\t\tif (TYPEOF(elt) == RAWSXP) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (elt != R_NilValue) {\n+\t\t\t\treturn RType::UNKNOWN;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (i == len) {\n+\t\t\treturn RType::LIST_OF_NULLS;\n+\t\t}\n+\n+\t\tfor (; i < len; ++i) {\n+\t\t\tauto elt = VECTOR_ELT(v, i);\n+\t\t\tif (TYPEOF(elt) != RAWSXP && elt != R_NilValue) {\n+\t\t\t\treturn RType::UNKNOWN;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn RType::BLOB;\n \t}\n \treturn RType::UNKNOWN;\n }\ndiff --git a/tools/rpkg/src/utils.cpp b/tools/rpkg/src/utils.cpp\nindex 2a522f04abb3..b0c76d0a9e1b 100644\n--- a/tools/rpkg/src/utils.cpp\n+++ b/tools/rpkg/src/utils.cpp\n@@ -189,6 +189,12 @@ Value RApiTypes::SexpToValue(SEXP valsexp, R_len_t idx) {\n \t\tauto ts_val = INTEGER_POINTER(valsexp)[idx];\n \t\treturn RIntegerType::IsNull(ts_val) ? Value(LogicalType::TIME) : Value::TIME(RTimeWeeksType::Convert(ts_val));\n \t}\n+\tcase RType::LIST_OF_NULLS:\n+\t\treturn Value();\n+\tcase RType::BLOB: {\n+\t\tauto ts_val = VECTOR_ELT(valsexp, idx);\n+\t\treturn Rf_isNull(ts_val) ? Value(LogicalType::BLOB) : Value::BLOB(RAW(ts_val), Rf_xlength(ts_val));\n+\t}\n \tdefault:\n \t\tcpp11::stop(\"duckdb_sexp_to_value: Unsupported type\");\n \t\treturn Value();\n",
  "test_patch": "diff --git a/tools/rpkg/tests/testthat/_snaps/types.md b/tools/rpkg/tests/testthat/_snaps/types.md\nindex 19e1fb157f8a..edb9f758bf93 100644\n--- a/tools/rpkg/tests/testthat/_snaps/types.md\n+++ b/tools/rpkg/tests/testthat/_snaps/types.md\n@@ -87,7 +87,7 @@\n       [1] 00 00 00 61\n       \n       $blob[[3]]\n-      [1] NA\n+      NULL\n       \n       \n       $small_enum\ndiff --git a/tools/rpkg/tests/testthat/helper-DBItest.R b/tools/rpkg/tests/testthat/helper-DBItest.R\nnew file mode 100644\nindex 000000000000..4bf52bbbca9b\n--- /dev/null\n+++ b/tools/rpkg/tests/testthat/helper-DBItest.R\n@@ -0,0 +1,22 @@\n+drv <- duckdb::duckdb()\n+reg.finalizer(drv@database_ref, function(x) duckdb:::rapi_shutdown(x))\n+\n+# remotes::install_github(\"r-dbi/dblog\")\n+# Then, use DBItest::test_some() to see the DBI calls emitted by the tests\n+#\n+# This call must stay here, otherwise DBItest::test_some() doesn't work\n+DBItest::make_context(\n+  drv,\n+  # dblog::dblog(drv),\n+  list(debug = FALSE),\n+  tweaks = DBItest::tweaks(\n+    omit_blob_tests = FALSE,\n+    temporary_tables = FALSE,\n+    placeholder_pattern = \"?\",\n+    timestamp_cast = function(x) sprintf(\"CAST('%s' AS TIMESTAMP)\", x),\n+    date_cast = function(x) sprintf(\"CAST('%s' AS DATE)\", x),\n+    time_cast = function(x) sprintf(\"CAST('%s' AS TIME)\", x),\n+    blob_cast = function(x) sprintf(\"%s::BLOB\", x)\n+  ),\n+  name = \"duckdb\"\n+)\ndiff --git a/tools/rpkg/tests/testthat/test-DBItest.R b/tools/rpkg/tests/testthat/test-DBItest.R\nindex a4d4f2fc4ff9..7ecf8b3bb7aa 100644\n--- a/tools/rpkg/tests/testthat/test-DBItest.R\n+++ b/tools/rpkg/tests/testthat/test-DBItest.R\n@@ -1,25 +1,5 @@\n skip_on_cran()\n \n-# remotes::install_github(\"r-dbi/dblog\")\n-# Then, use dblog::dblog(duckdb::duckdb()) in conjunction with DBItest::test_some()\n-# to see the DBI calls emitted by the tests\n-drv <- duckdb::duckdb()\n-reg.finalizer(drv@database_ref, function(x) duckdb:::rapi_shutdown(x))\n-DBItest::make_context(\n-  drv,\n-  # dblog::dblog(duckdb::duckdb()),\n-  list(debug = F),\n-  tweaks = DBItest::tweaks(\n-    omit_blob_tests = TRUE,\n-    temporary_tables = FALSE,\n-    placeholder_pattern = \"?\",\n-    timestamp_cast = function(x) sprintf(\"CAST('%s' AS TIMESTAMP)\", x),\n-    date_cast = function(x) sprintf(\"CAST('%s' AS DATE)\", x),\n-    time_cast = function(x) sprintf(\"CAST('%s' AS TIME)\", x)\n-  ),\n-  name = \"duckdb\"\n-)\n-\n DBItest::test_all(c(\n   \"package_name\", # wontfix\n   \"package_dependencies\", # wontfix\n@@ -60,5 +40,7 @@ DBItest::test_all(c(\n   \"write_table_row_names_string_missing\",\n   \"write_table_row_names_na_missing\",\n   \"append_roundtrip_factor\",\n-  \"bind_factor\"\n+  \"bind_factor\",\n+\n+  NULL\n ))\n",
  "problem_statement": "Can't write raw data from R\n#### What happens?\r\nSerialising R objects to `<raw>`  type, then attempting to write to a `duckdb` connection results in the following errors:\r\n```\r\nError: rapi_execute: Unsupported column type for scan\r\nError: rapi_register_df: Failed to register data frame: std::exception\r\n```\r\n\r\n#### To Reproduce\r\nHere is some minimal R code to reproduce the issue:\r\n```\r\ncon <- DBI::dbConnect(duckdb::duckdb())\r\n# This would work:\r\n# con <- DBI::dbConnect(RSQLite::SQLite())\r\n\r\nDBI::dbCreateTable(\r\n  conn = con,\r\n  name = \"raw_test\",\r\n  fields = list(file = \"blob\")\r\n)\r\n\r\nDBI::dbAppendTable(\r\n  conn = con,\r\n  name = \"raw_test\",\r\n  value = data.frame(file = I(list(as.raw(1:3)))),\r\n  field.types = list(file = \"blob\")\r\n)\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Windows 10\r\n - DuckDB Version: R package 0.4.0\r\n - DuckDB Client: R\r\n\r\nR session info:\r\n```\r\nR version 4.1.3 (2022-03-10)\r\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\r\nRunning under: Windows 10 x64 (build 19044)\r\n\r\nMatrix products: default\r\n\r\nlocale:\r\n[1] LC_COLLATE=English_United Kingdom.1252  LC_CTYPE=English_United Kingdom.1252   \r\n[3] LC_MONETARY=English_United Kingdom.1252 LC_NUMERIC=C                           \r\n[5] LC_TIME=English_United Kingdom.1252    \r\n\r\nattached base packages:\r\n[1] stats     graphics  grDevices utils     datasets  methods   base     \r\n\r\nother attached packages:\r\n[1] databasePackage_0.0.0.9000 testthat_3.1.4            \r\n\r\nloaded via a namespace (and not attached):\r\n [1] Rcpp_1.0.8        compiler_4.1.3    prettyunits_1.1.1 remotes_2.4.2     tools_4.1.3      \r\n [6] odbc_1.3.3        bit_4.0.4         digest_0.6.29     pkgbuild_1.3.1    pkgload_1.3.0    \r\n[11] memoise_2.0.1     evaluate_0.15     lifecycle_1.0.1   pkgconfig_2.0.3   rlang_1.0.3      \r\n[16] cli_3.3.0         DBI_1.1.3         rstudioapi_0.13   yaml_2.3.5        xfun_0.30        \r\n[21] fastmap_1.1.0     duckdb_0.4.0      withr_2.5.0       knitr_1.39        hms_1.1.1        \r\n[26] vctrs_0.4.1       desc_1.4.1        fs_1.5.2          devtools_2.4.3    bit64_4.0.5      \r\n[31] rprojroot_2.0.2   glue_1.6.2        R6_2.5.1          processx_3.5.2    rmarkdown_2.14   \r\n[36] sessioninfo_1.2.2 blob_1.2.2        callr_3.7.0       purrr_0.3.4       magrittr_2.0.3   \r\n[41] ps_1.6.0          ellipsis_0.3.2    htmltools_0.5.2   usethis_2.1.6     rsconnect_0.8.26 \r\n[46] cachem_1.0.6      crayon_1.5.1      brio_1.1.3       \r\n```\r\n\r\n#### Identity Disclosure:\r\n - Full Name: Jacob Scott\r\n - Affiliation: UK Government\n",
  "hints_text": "Please see also #3229\nNow:\r\n\r\n``` r\r\ncon <- DBI::dbConnect(duckdb::duckdb())\r\n# This would work:\r\n# con <- DBI::dbConnect(RSQLite::SQLite())\r\n\r\nDBI::dbCreateTable(\r\n  conn = con,\r\n  name = \"raw_test\",\r\n  fields = list(file = \"blob\")\r\n)\r\n\r\nDBI::dbAppendTable(\r\n  conn = con,\r\n  name = \"raw_test\",\r\n  value = data.frame(file = I(list(as.raw(1:3)))),\r\n  field.types = list(file = \"blob\")\r\n)\r\n#> Error: rapi_execute: Unsupported column type for bind\r\n#> Error: rapi_register_df: Failed to register data frame: std::exception\r\n```\r\n\r\n<sup>Created on 2022-08-06 by the [reprex package](https://reprex.tidyverse.org) (v2.0.1)</sup>\nWe should have DBItest coverage with `omit_blob_tests = FALSE` .\n@krlmlr is the view then that this isn\u2019t going to be supported, so the errors should just be more informative?\nWe should fix it, and then use `omit_blob_tests = FALSE` to test the implementation.\nWe need a new `RType::BLOB`, and later also `RType::LIST` and `RType::STRUCT` (or similar). To disentangle, we should start with `RType::BLOB` and be strict with what we accept -- either lists that inherit from `\"blob\"` or where each vector is a raw element. Zero-length bare lists should return `RType::UNKNOWN` ?",
  "created_at": "2022-08-13T15:44:07Z"
}