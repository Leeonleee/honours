You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Transactional `INSERT` + `ALTER TABLE ADD COLUMN` + `INSERT`  erases data values written to new column
#### What happens?
If, within the same transaction, you:
1. add a row
2. add a column without specifying a default
3. add another row, attempting to put a value in the new column

then no matter what you try to write to the new column, and no matter what its data type, the write will fail and you will always read back NULL. The only way to write a non-NULL value is to commit the transaction and start a new one.

According to the DuckDB documentation, adding a column should fully respect transactional semantics.
> ALTER TABLE changes the schema of an existing table. All the changes made by ALTER TABLE fully respect the transactional semantics - that is - they will not be visible to other transactions until committed, and can be fully reverted through a rollback.


#### To Reproduce
```
D create table test (c1 bigint);


D begin transaction;
D insert into test values (11);          -- For some reason, this step is necessary to trigger the bug.
D alter table test add column c2 bigint;  -- For some reason, it's crucial that we do not specify a DEFAULT value.
D insert into test (c1, c2) values (22, 666);
D select * from test;
┌────┬────┐
│ c1 │ c2 │
├────┼────┤
│ 11 │    │
│ 22 │    │
└────┴────┘
D rollback transaction;

-- But if we commit the transaction after adding the column, we will get the expected result. 

D begin transaction;
D insert into test values (11);
D alter table test add column c2 bigint;
D commit transaction;
D insert into test (c1, c2) values (22, 666);
D select * from test;
┌────┬─────┐
│ c1 │ c2  │
├────┼─────┤
│ 11 │     │
│ 22 │ 666 │
└────┴─────┘
```

#### Environment:
 - OS: Monterey 12.2
 - DuckDB Version: The bug is present in duckdb 0.3.1 and 0.3.2. This issue notably was NOT present in duckdb 0.2.9!
 - DuckDB Client: CLI (but I discovered it with a unit test against the Rust library duckdb-rs)


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of src/include/duckdb/common/types/validity_mask.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/validity_mask.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types.hpp"
13: #include "duckdb/common/vector_size.hpp"
14: #include "duckdb/common/to_string.hpp"
15: 
16: namespace duckdb {
17: struct ValidityMask;
18: 
19: template <typename V>
20: struct TemplatedValidityData {
21: 	static constexpr const int BITS_PER_VALUE = sizeof(V) * 8;
22: 	static constexpr const V MAX_ENTRY = ~V(0);
23: 
24: public:
25: 	inline explicit TemplatedValidityData(idx_t count) {
26: 		auto entry_count = EntryCount(count);
27: 		owned_data = unique_ptr<V[]>(new V[entry_count]);
28: 		for (idx_t entry_idx = 0; entry_idx < entry_count; entry_idx++) {
29: 			owned_data[entry_idx] = MAX_ENTRY;
30: 		}
31: 	}
32: 	inline TemplatedValidityData(const V *validity_mask, idx_t count) {
33: 		D_ASSERT(validity_mask);
34: 		auto entry_count = EntryCount(count);
35: 		owned_data = unique_ptr<V[]>(new V[entry_count]);
36: 		for (idx_t entry_idx = 0; entry_idx < entry_count; entry_idx++) {
37: 			owned_data[entry_idx] = validity_mask[entry_idx];
38: 		}
39: 	}
40: 
41: 	unique_ptr<V[]> owned_data;
42: 
43: public:
44: 	static inline idx_t EntryCount(idx_t count) {
45: 		return (count + (BITS_PER_VALUE - 1)) / BITS_PER_VALUE;
46: 	}
47: };
48: 
49: using validity_t = uint64_t;
50: 
51: struct ValidityData : TemplatedValidityData<validity_t> {
52: public:
53: 	DUCKDB_API explicit ValidityData(idx_t count);
54: 	DUCKDB_API ValidityData(const ValidityMask &original, idx_t count);
55: };
56: 
57: //! Type used for validity masks
58: template <typename V>
59: struct TemplatedValidityMask {
60: 	using ValidityBuffer = TemplatedValidityData<V>;
61: 
62: public:
63: 	static constexpr const int BITS_PER_VALUE = ValidityBuffer::BITS_PER_VALUE;
64: 	static constexpr const int STANDARD_ENTRY_COUNT = (STANDARD_VECTOR_SIZE + (BITS_PER_VALUE - 1)) / BITS_PER_VALUE;
65: 	static constexpr const int STANDARD_MASK_SIZE = STANDARD_ENTRY_COUNT * sizeof(validity_t);
66: 
67: public:
68: 	inline TemplatedValidityMask() : validity_mask(nullptr) {
69: 	}
70: 	inline explicit TemplatedValidityMask(idx_t max_count) {
71: 		Initialize(max_count);
72: 	}
73: 	inline explicit TemplatedValidityMask(V *ptr) : validity_mask(ptr) {
74: 	}
75: 	inline TemplatedValidityMask(const TemplatedValidityMask &original, idx_t count) {
76: 		Copy(original, count);
77: 	}
78: 
79: 	static inline idx_t ValidityMaskSize(idx_t count = STANDARD_VECTOR_SIZE) {
80: 		return ValidityBuffer::EntryCount(count) * sizeof(V);
81: 	}
82: 	inline bool AllValid() const {
83: 		return !validity_mask;
84: 	}
85: 	inline bool CheckAllValid(idx_t count) const {
86: 		if (AllValid()) {
87: 			return true;
88: 		}
89: 		idx_t entry_count = ValidityBuffer::EntryCount(count);
90: 		idx_t valid_count = 0;
91: 		for (idx_t i = 0; i < entry_count; i++) {
92: 			valid_count += validity_mask[i] == ValidityBuffer::MAX_ENTRY;
93: 		}
94: 		return valid_count == entry_count;
95: 	}
96: 
97: 	inline bool CheckAllValid(idx_t to, idx_t from) const {
98: 		if (AllValid()) {
99: 			return true;
100: 		}
101: 		for (idx_t i = from; i < to; i++) {
102: 			if (!RowIsValid(i)) {
103: 				return false;
104: 			}
105: 		}
106: 		return true;
107: 	}
108: 
109: 	idx_t CountValid(const idx_t count) const {
110: 		if (AllValid() || count == 0) {
111: 			return count;
112: 		}
113: 
114: 		idx_t valid = 0;
115: 		const auto entry_count = EntryCount(count);
116: 		for (idx_t entry_idx = 0; entry_idx < entry_count;) {
117: 			auto entry = GetValidityEntry(entry_idx++);
118: 			// Handle ragged end
119: 			if (entry_idx == entry_count) {
120: 				idx_t idx_in_entry;
121: 				GetEntryIndex(count, entry_idx, idx_in_entry);
122: 				for (idx_t i = 0; i < idx_in_entry; ++i) {
123: 					valid += idx_t(RowIsValid(entry, i));
124: 				}
125: 				break;
126: 			}
127: 
128: 			// Handle all set
129: 			if (AllValid(entry)) {
130: 				valid += BITS_PER_VALUE;
131: 				continue;
132: 			}
133: 
134: 			// Count partial entry (Kernighan's algorithm)
135: 			while (entry) {
136: 				entry &= (entry - 1);
137: 				++valid;
138: 			}
139: 		}
140: 
141: 		return valid;
142: 	}
143: 
144: 	inline V *GetData() const {
145: 		return validity_mask;
146: 	}
147: 	inline void Reset() {
148: 		validity_mask = nullptr;
149: 		validity_data.reset();
150: 	}
151: 
152: 	static inline idx_t EntryCount(idx_t count) {
153: 		return ValidityBuffer::EntryCount(count);
154: 	}
155: 	inline V GetValidityEntry(idx_t entry_idx) const {
156: 		if (!validity_mask) {
157: 			return ValidityBuffer::MAX_ENTRY;
158: 		}
159: 		return validity_mask[entry_idx];
160: 	}
161: 	static inline bool AllValid(V entry) {
162: 		return entry == ValidityBuffer::MAX_ENTRY;
163: 	}
164: 	static inline bool NoneValid(V entry) {
165: 		return entry == 0;
166: 	}
167: 	static inline bool RowIsValid(V entry, idx_t idx_in_entry) {
168: 		return entry & (V(1) << V(idx_in_entry));
169: 	}
170: 	static inline void GetEntryIndex(idx_t row_idx, idx_t &entry_idx, idx_t &idx_in_entry) {
171: 		entry_idx = row_idx / BITS_PER_VALUE;
172: 		idx_in_entry = row_idx % BITS_PER_VALUE;
173: 	}
174: 
175: 	//! RowIsValidUnsafe should only be used if AllValid() is false: it achieves the same as RowIsValid but skips a
176: 	//! not-null check
177: 	inline bool RowIsValidUnsafe(idx_t row_idx) const {
178: 		D_ASSERT(validity_mask);
179: 		idx_t entry_idx, idx_in_entry;
180: 		GetEntryIndex(row_idx, entry_idx, idx_in_entry);
181: 		auto entry = GetValidityEntry(entry_idx);
182: 		return RowIsValid(entry, idx_in_entry);
183: 	}
184: 
185: 	//! Returns true if a row is valid (i.e. not null), false otherwise
186: 	inline bool RowIsValid(idx_t row_idx) const {
187: 		if (!validity_mask) {
188: 			return true;
189: 		}
190: 		return RowIsValidUnsafe(row_idx);
191: 	}
192: 
193: 	//! Same as SetValid, but skips a null check on validity_mask
194: 	inline void SetValidUnsafe(idx_t row_idx) {
195: 		D_ASSERT(validity_mask);
196: 		idx_t entry_idx, idx_in_entry;
197: 		GetEntryIndex(row_idx, entry_idx, idx_in_entry);
198: 		validity_mask[entry_idx] |= (V(1) << V(idx_in_entry));
199: 	}
200: 
201: 	//! Marks the entry at the specified row index as valid (i.e. not-null)
202: 	inline void SetValid(idx_t row_idx) {
203: 		if (!validity_mask) {
204: 			// if AllValid() we don't need to do anything
205: 			// the row is already valid
206: 			return;
207: 		}
208: 		SetValidUnsafe(row_idx);
209: 	}
210: 
211: 	//! Marks the bit at the specified entry as invalid (i.e. null)
212: 	inline void SetInvalidUnsafe(idx_t entry_idx, idx_t idx_in_entry) {
213: 		D_ASSERT(validity_mask);
214: 		validity_mask[entry_idx] &= ~(V(1) << V(idx_in_entry));
215: 	}
216: 
217: 	//! Marks the bit at the specified row index as invalid (i.e. null)
218: 	inline void SetInvalidUnsafe(idx_t row_idx) {
219: 		idx_t entry_idx, idx_in_entry;
220: 		GetEntryIndex(row_idx, entry_idx, idx_in_entry);
221: 		SetInvalidUnsafe(entry_idx, idx_in_entry);
222: 	}
223: 
224: 	//! Marks the entry at the specified row index as invalid (i.e. null)
225: 	inline void SetInvalid(idx_t row_idx) {
226: 		if (!validity_mask) {
227: 			D_ASSERT(row_idx <= STANDARD_VECTOR_SIZE);
228: 			Initialize(STANDARD_VECTOR_SIZE);
229: 		}
230: 		SetInvalidUnsafe(row_idx);
231: 	}
232: 
233: 	//! Mark the entry at the specified index as either valid or invalid (non-null or null)
234: 	inline void Set(idx_t row_idx, bool valid) {
235: 		if (valid) {
236: 			SetValid(row_idx);
237: 		} else {
238: 			SetInvalid(row_idx);
239: 		}
240: 	}
241: 
242: 	//! Ensure the validity mask is writable, allocating space if it is not initialized
243: 	inline void EnsureWritable() {
244: 		if (!validity_mask) {
245: 			Initialize();
246: 		}
247: 	}
248: 
249: 	//! Marks "count" entries in the validity mask as invalid (null)
250: 	inline void SetAllInvalid(idx_t count) {
251: 		EnsureWritable();
252: 		for (idx_t i = 0; i < ValidityBuffer::EntryCount(count); i++) {
253: 			validity_mask[i] = 0;
254: 		}
255: 	}
256: 
257: 	//! Marks "count" entries in the validity mask as valid (not null)
258: 	inline void SetAllValid(idx_t count) {
259: 		EnsureWritable();
260: 		for (idx_t i = 0; i < ValidityBuffer::EntryCount(count); i++) {
261: 			validity_mask[i] = ValidityBuffer::MAX_ENTRY;
262: 		}
263: 	}
264: 
265: 	inline bool IsMaskSet() const {
266: 		if (validity_mask) {
267: 			return true;
268: 		}
269: 		return false;
270: 	}
271: 
272: public:
273: 	inline void Initialize(validity_t *validity) {
274: 		validity_data.reset();
275: 		validity_mask = validity;
276: 	}
277: 	inline void Initialize(const TemplatedValidityMask &other) {
278: 		validity_mask = other.validity_mask;
279: 		validity_data = other.validity_data;
280: 	}
281: 	inline void Initialize(idx_t count = STANDARD_VECTOR_SIZE) {
282: 		validity_data = make_buffer<ValidityBuffer>(count);
283: 		validity_mask = validity_data->owned_data.get();
284: 	}
285: 	inline void Copy(const TemplatedValidityMask &other, idx_t count) {
286: 		if (other.AllValid()) {
287: 			validity_data = nullptr;
288: 			validity_mask = nullptr;
289: 		} else {
290: 			validity_data = make_buffer<ValidityBuffer>(other.validity_mask, count);
291: 			validity_mask = validity_data->owned_data.get();
292: 		}
293: 	}
294: 
295: protected:
296: 	V *validity_mask;
297: 	buffer_ptr<ValidityBuffer> validity_data;
298: };
299: 
300: struct ValidityMask : public TemplatedValidityMask<validity_t> {
301: public:
302: 	inline ValidityMask() : TemplatedValidityMask(nullptr) {
303: 	}
304: 	inline explicit ValidityMask(idx_t max_count) : TemplatedValidityMask(max_count) {
305: 	}
306: 	inline explicit ValidityMask(validity_t *ptr) : TemplatedValidityMask(ptr) {
307: 	}
308: 	inline ValidityMask(const ValidityMask &original, idx_t count) : TemplatedValidityMask(original, count) {
309: 	}
310: 
311: public:
312: 	DUCKDB_API void Resize(idx_t old_size, idx_t new_size);
313: 
314: 	DUCKDB_API void Slice(const ValidityMask &other, idx_t offset);
315: 	DUCKDB_API void Combine(const ValidityMask &other, idx_t count);
316: 	DUCKDB_API string ToString(idx_t count) const;
317: };
318: 
319: } // namespace duckdb
[end of src/include/duckdb/common/types/validity_mask.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: