{
  "repo": "duckdb/duckdb",
  "pull_number": 3436,
  "instance_id": "duckdb__duckdb-3436",
  "issue_numbers": [
    "3127"
  ],
  "base_commit": "e11559378c1ed8128a55b9b4e6272628836f3fd1",
  "patch": "diff --git a/src/include/duckdb/common/types/validity_mask.hpp b/src/include/duckdb/common/types/validity_mask.hpp\nindex be709eedc41f..e5a86f59587a 100644\n--- a/src/include/duckdb/common/types/validity_mask.hpp\n+++ b/src/include/duckdb/common/types/validity_mask.hpp\n@@ -171,6 +171,13 @@ struct TemplatedValidityMask {\n \t\tentry_idx = row_idx / BITS_PER_VALUE;\n \t\tidx_in_entry = row_idx % BITS_PER_VALUE;\n \t}\n+\t//! Get an entry that has first-n bits set as valid and rest set as invalid\n+\tstatic inline V EntryWithValidBits(idx_t n) {\n+\t\tif (n == 0) {\n+\t\t\treturn V(0);\n+\t\t}\n+\t\treturn ValidityBuffer::MAX_ENTRY >> (BITS_PER_VALUE - n);\n+\t}\n \n \t//! RowIsValidUnsafe should only be used if AllValid() is false: it achieves the same as RowIsValid but skips a\n \t//! not-null check\n@@ -246,20 +253,33 @@ struct TemplatedValidityMask {\n \t\t}\n \t}\n \n-\t//! Marks \"count\" entries in the validity mask as invalid (null)\n+\t//! Marks exactly \"count\" bits in the validity mask as invalid (null)\n \tinline void SetAllInvalid(idx_t count) {\n \t\tEnsureWritable();\n-\t\tfor (idx_t i = 0; i < ValidityBuffer::EntryCount(count); i++) {\n+\t\tif (count == 0) {\n+\t\t\treturn;\n+\t\t}\n+\t\tauto last_entry_index = ValidityBuffer::EntryCount(count) - 1;\n+\t\tfor (idx_t i = 0; i < last_entry_index; i++) {\n \t\t\tvalidity_mask[i] = 0;\n \t\t}\n+\t\tauto last_entry_bits = count % static_cast<idx_t>(BITS_PER_VALUE);\n+\t\tvalidity_mask[last_entry_index] = (last_entry_bits == 0) ? 0 : (ValidityBuffer::MAX_ENTRY << (last_entry_bits));\n \t}\n \n-\t//! Marks \"count\" entries in the validity mask as valid (not null)\n+\t//! Marks exactly \"count\" bits in the validity mask as valid (not null)\n \tinline void SetAllValid(idx_t count) {\n \t\tEnsureWritable();\n-\t\tfor (idx_t i = 0; i < ValidityBuffer::EntryCount(count); i++) {\n+\t\tif (count == 0) {\n+\t\t\treturn;\n+\t\t}\n+\t\tauto last_entry_index = ValidityBuffer::EntryCount(count) - 1;\n+\t\tfor (idx_t i = 0; i < last_entry_index; i++) {\n \t\t\tvalidity_mask[i] = ValidityBuffer::MAX_ENTRY;\n \t\t}\n+\t\tauto last_entry_bits = count % static_cast<idx_t>(BITS_PER_VALUE);\n+\t\tvalidity_mask[last_entry_index] |=\n+\t\t    (last_entry_bits == 0) ? ValidityBuffer::MAX_ENTRY : ~(ValidityBuffer::MAX_ENTRY << (last_entry_bits));\n \t}\n \n \tinline bool IsMaskSet() const {\n",
  "test_patch": "diff --git a/test/issues/general/test_3127.test b/test/issues/general/test_3127.test\nnew file mode 100644\nindex 000000000000..00367b231dfd\n--- /dev/null\n+++ b/test/issues/general/test_3127.test\n@@ -0,0 +1,25 @@\n+# name: test/issues/general/test_3127.test\n+# description: Issue 3127: Transactional INSERT + ALTER TABLE ADD COLUMN + INSERT erases data values written to new column\n+# group: [general]\n+\n+statement ok\n+CREATE TABLE test(i INTEGER, j INTEGER)\n+\n+statement ok\n+BEGIN TRANSACTION\n+\n+statement ok\n+INSERT INTO test VALUES (1, 1), (2, 2)\n+\n+statement ok\n+ALTER TABLE test ADD COLUMN k INTEGER\n+\n+statement ok\n+INSERT INTO test VALUES (3, 3, 3)\n+\n+query III\n+SELECT * FROM test\n+----\n+1\t1\tNULL\n+2\t2\tNULL\n+3\t3\t3\n",
  "problem_statement": "Transactional `INSERT` + `ALTER TABLE ADD COLUMN` + `INSERT`  erases data values written to new column\n#### What happens?\r\nIf, within the same transaction, you:\r\n1. add a row\r\n2. add a column without specifying a default\r\n3. add another row, attempting to put a value in the new column\r\n\r\nthen no matter what you try to write to the new column, and no matter what its data type, the write will fail and you will always read back NULL. The only way to write a non-NULL value is to commit the transaction and start a new one.\r\n\r\nAccording to the DuckDB documentation, adding a column should fully respect transactional semantics.\r\n> ALTER TABLE changes the schema of an existing table. All the changes made by ALTER TABLE fully respect the transactional semantics - that is - they will not be visible to other transactions until committed, and can be fully reverted through a rollback.\r\n\r\n\r\n#### To Reproduce\r\n```\r\nD create table test (c1 bigint);\r\n\r\n\r\nD begin transaction;\r\nD insert into test values (11);          -- For some reason, this step is necessary to trigger the bug.\r\nD alter table test add column c2 bigint;  -- For some reason, it's crucial that we do not specify a DEFAULT value.\r\nD insert into test (c1, c2) values (22, 666);\r\nD select * from test;\r\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\r\n\u2502 c1 \u2502 c2 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2524\r\n\u2502 11 \u2502    \u2502\r\n\u2502 22 \u2502    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\r\nD rollback transaction;\r\n\r\n-- But if we commit the transaction after adding the column, we will get the expected result. \r\n\r\nD begin transaction;\r\nD insert into test values (11);\r\nD alter table test add column c2 bigint;\r\nD commit transaction;\r\nD insert into test (c1, c2) values (22, 666);\r\nD select * from test;\r\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 c1 \u2502 c2  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 11 \u2502     \u2502\r\n\u2502 22 \u2502 666 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n#### Environment:\r\n - OS: Monterey 12.2\r\n - DuckDB Version: The bug is present in duckdb 0.3.1 and 0.3.2. This issue notably was NOT present in duckdb 0.2.9!\r\n - DuckDB Client: CLI (but I discovered it with a unit test against the Rust library duckdb-rs)\r\n\n",
  "hints_text": "Hi @Mytherin, thanks for self-assigning this. I put up a simple PR which adds this as a test case. https://github.com/duckdb/duckdb/pull/3131\r\n\r\nOf course, it fails right now, but maybe you could merge it when you're done with your fix.\r\n\r\nI was going to upgrade from DuckDB 0.2.9 to 0.3.2 but now I'll just wait until the version where this is patched \ud83d\ude38 \r\nThanks again!",
  "created_at": "2022-04-16T15:49:50Z"
}