You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
DELETE triggers assertion with STANDARD_VECTOR_SIZE = 2
#### What happens?

I created a table and then inserted some lists into that table. This followed by a `DELETE` on that table triggers an assertion. This happens when compiling DuckDB with a `STANDARD_VECTOR_SIZE` of 2. I am assuming that this is a bug because we test DuckDB for different vector sizes.

#### To Reproduce
Steps to reproduce the behavior.

Change the `STANDARD_VECTOR_SIZE` in `vector_size.hpp` to 2. Then compile and run the following queries.

```
CREATE TABLE aggr (k int[]);
INSERT INTO aggr VALUES ([0, 1, 1, 1, 4, 0, 3, 3, 2, 2, 4, 4, 2, 4, 0, 0, 0, 1, 2, 3, 4, 2, 3, 3, 1]);
INSERT INTO aggr VALUES ([]), ([NULL]), (NULL), ([0, 1, 1, 1, 4, NULL, 0, 3, 3, 2, NULL, 2, 4, 4, 2, 4, 0, 0, 0, 1, NULL, 2, 3, 4, 2, 3, 3, 1]);

DELETE FROM aggr;
```

With the following assertion:
```
Error: INTERNAL Error: INTERNAL Error: Assertion triggered in file "/Users/tania/DuckDB/duckdb-master/duckdb/src/include/duckdb/common/types/validity_mask.hpp" on line 227: row_idx <= STANDARD_VECTOR_SIZE
```

#### Environment (please complete the following information):
 - OS: iOS
 - DuckDB Version: 22
 - DuckDB Client: CLI

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

DELETE triggers assertion with STANDARD_VECTOR_SIZE = 2
#### What happens?

I created a table and then inserted some lists into that table. This followed by a `DELETE` on that table triggers an assertion. This happens when compiling DuckDB with a `STANDARD_VECTOR_SIZE` of 2. I am assuming that this is a bug because we test DuckDB for different vector sizes.

#### To Reproduce
Steps to reproduce the behavior.

Change the `STANDARD_VECTOR_SIZE` in `vector_size.hpp` to 2. Then compile and run the following queries.

```
CREATE TABLE aggr (k int[]);
INSERT INTO aggr VALUES ([0, 1, 1, 1, 4, 0, 3, 3, 2, 2, 4, 4, 2, 4, 0, 0, 0, 1, 2, 3, 4, 2, 3, 3, 1]);
INSERT INTO aggr VALUES ([]), ([NULL]), (NULL), ([0, 1, 1, 1, 4, NULL, 0, 3, 3, 2, NULL, 2, 4, 4, 2, 4, 0, 0, 0, 1, NULL, 2, 3, 4, 2, 3, 3, 1]);

DELETE FROM aggr;
```

With the following assertion:
```
Error: INTERNAL Error: INTERNAL Error: Assertion triggered in file "/Users/tania/DuckDB/duckdb-master/duckdb/src/include/duckdb/common/types/validity_mask.hpp" on line 227: row_idx <= STANDARD_VECTOR_SIZE
```

#### Environment (please complete the following information):
 - OS: iOS
 - DuckDB Version: 22
 - DuckDB Client: CLI

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of src/storage/compression/validity_uncompressed.cpp]
1: #include "duckdb/storage/segment/uncompressed.hpp"
2: #include "duckdb/storage/buffer_manager.hpp"
3: #include "duckdb/common/types/vector.hpp"
4: #include "duckdb/storage/table/append_state.hpp"
5: #include "duckdb/storage/statistics/validity_statistics.hpp"
6: #include "duckdb/common/types/null_value.hpp"
7: #include "duckdb/storage/table/column_segment.hpp"
8: #include "duckdb/function/compression_function.hpp"
9: #include "duckdb/main/config.hpp"
10: 
11: namespace duckdb {
12: 
13: //===--------------------------------------------------------------------===//
14: // Mask constants
15: //===--------------------------------------------------------------------===//
16: // LOWER_MASKS contains masks with all the lower bits set until a specific value
17: // LOWER_MASKS[0] has the 0 lowest bits set, i.e.:
18: // 0b0000000000000000000000000000000000000000000000000000000000000000,
19: // LOWER_MASKS[10] has the 10 lowest bits set, i.e.:
20: // 0b0000000000000000000000000000000000000000000000000000000111111111,
21: // etc...
22: // 0b0000000000000000000000000000000000000001111111111111111111111111,
23: // ...
24: // 0b0000000000000000000001111111111111111111111111111111111111111111,
25: // until LOWER_MASKS[64], which has all bits set:
26: // 0b1111111111111111111111111111111111111111111111111111111111111111
27: // generated with this python snippet:
28: // for i in range(65):
29: //   print(hex(int((64 - i) * '0' + i * '1', 2)) + ",")
30: const validity_t ValidityUncompressed::LOWER_MASKS[] = {0x0,
31:                                                         0x1,
32:                                                         0x3,
33:                                                         0x7,
34:                                                         0xf,
35:                                                         0x1f,
36:                                                         0x3f,
37:                                                         0x7f,
38:                                                         0xff,
39:                                                         0x1ff,
40:                                                         0x3ff,
41:                                                         0x7ff,
42:                                                         0xfff,
43:                                                         0x1fff,
44:                                                         0x3fff,
45:                                                         0x7fff,
46:                                                         0xffff,
47:                                                         0x1ffff,
48:                                                         0x3ffff,
49:                                                         0x7ffff,
50:                                                         0xfffff,
51:                                                         0x1fffff,
52:                                                         0x3fffff,
53:                                                         0x7fffff,
54:                                                         0xffffff,
55:                                                         0x1ffffff,
56:                                                         0x3ffffff,
57:                                                         0x7ffffff,
58:                                                         0xfffffff,
59:                                                         0x1fffffff,
60:                                                         0x3fffffff,
61:                                                         0x7fffffff,
62:                                                         0xffffffff,
63:                                                         0x1ffffffff,
64:                                                         0x3ffffffff,
65:                                                         0x7ffffffff,
66:                                                         0xfffffffff,
67:                                                         0x1fffffffff,
68:                                                         0x3fffffffff,
69:                                                         0x7fffffffff,
70:                                                         0xffffffffff,
71:                                                         0x1ffffffffff,
72:                                                         0x3ffffffffff,
73:                                                         0x7ffffffffff,
74:                                                         0xfffffffffff,
75:                                                         0x1fffffffffff,
76:                                                         0x3fffffffffff,
77:                                                         0x7fffffffffff,
78:                                                         0xffffffffffff,
79:                                                         0x1ffffffffffff,
80:                                                         0x3ffffffffffff,
81:                                                         0x7ffffffffffff,
82:                                                         0xfffffffffffff,
83:                                                         0x1fffffffffffff,
84:                                                         0x3fffffffffffff,
85:                                                         0x7fffffffffffff,
86:                                                         0xffffffffffffff,
87:                                                         0x1ffffffffffffff,
88:                                                         0x3ffffffffffffff,
89:                                                         0x7ffffffffffffff,
90:                                                         0xfffffffffffffff,
91:                                                         0x1fffffffffffffff,
92:                                                         0x3fffffffffffffff,
93:                                                         0x7fffffffffffffff,
94:                                                         0xffffffffffffffff};
95: 
96: // UPPER_MASKS contains masks with all the highest bits set until a specific value
97: // UPPER_MASKS[0] has the 0 highest bits set, i.e.:
98: // 0b0000000000000000000000000000000000000000000000000000000000000000,
99: // UPPER_MASKS[10] has the 10 highest bits set, i.e.:
100: // 0b1111111111110000000000000000000000000000000000000000000000000000,
101: // etc...
102: // 0b1111111111111111111111110000000000000000000000000000000000000000,
103: // ...
104: // 0b1111111111111111111111111111111111111110000000000000000000000000,
105: // until UPPER_MASKS[64], which has all bits set:
106: // 0b1111111111111111111111111111111111111111111111111111111111111111
107: // generated with this python snippet:
108: // for i in range(65):
109: //   print(hex(int(i * '1' + (64 - i) * '0', 2)) + ",")
110: const validity_t ValidityUncompressed::UPPER_MASKS[] = {0x0,
111:                                                         0x8000000000000000,
112:                                                         0xc000000000000000,
113:                                                         0xe000000000000000,
114:                                                         0xf000000000000000,
115:                                                         0xf800000000000000,
116:                                                         0xfc00000000000000,
117:                                                         0xfe00000000000000,
118:                                                         0xff00000000000000,
119:                                                         0xff80000000000000,
120:                                                         0xffc0000000000000,
121:                                                         0xffe0000000000000,
122:                                                         0xfff0000000000000,
123:                                                         0xfff8000000000000,
124:                                                         0xfffc000000000000,
125:                                                         0xfffe000000000000,
126:                                                         0xffff000000000000,
127:                                                         0xffff800000000000,
128:                                                         0xffffc00000000000,
129:                                                         0xffffe00000000000,
130:                                                         0xfffff00000000000,
131:                                                         0xfffff80000000000,
132:                                                         0xfffffc0000000000,
133:                                                         0xfffffe0000000000,
134:                                                         0xffffff0000000000,
135:                                                         0xffffff8000000000,
136:                                                         0xffffffc000000000,
137:                                                         0xffffffe000000000,
138:                                                         0xfffffff000000000,
139:                                                         0xfffffff800000000,
140:                                                         0xfffffffc00000000,
141:                                                         0xfffffffe00000000,
142:                                                         0xffffffff00000000,
143:                                                         0xffffffff80000000,
144:                                                         0xffffffffc0000000,
145:                                                         0xffffffffe0000000,
146:                                                         0xfffffffff0000000,
147:                                                         0xfffffffff8000000,
148:                                                         0xfffffffffc000000,
149:                                                         0xfffffffffe000000,
150:                                                         0xffffffffff000000,
151:                                                         0xffffffffff800000,
152:                                                         0xffffffffffc00000,
153:                                                         0xffffffffffe00000,
154:                                                         0xfffffffffff00000,
155:                                                         0xfffffffffff80000,
156:                                                         0xfffffffffffc0000,
157:                                                         0xfffffffffffe0000,
158:                                                         0xffffffffffff0000,
159:                                                         0xffffffffffff8000,
160:                                                         0xffffffffffffc000,
161:                                                         0xffffffffffffe000,
162:                                                         0xfffffffffffff000,
163:                                                         0xfffffffffffff800,
164:                                                         0xfffffffffffffc00,
165:                                                         0xfffffffffffffe00,
166:                                                         0xffffffffffffff00,
167:                                                         0xffffffffffffff80,
168:                                                         0xffffffffffffffc0,
169:                                                         0xffffffffffffffe0,
170:                                                         0xfffffffffffffff0,
171:                                                         0xfffffffffffffff8,
172:                                                         0xfffffffffffffffc,
173:                                                         0xfffffffffffffffe,
174:                                                         0xffffffffffffffff};
175: 
176: //===--------------------------------------------------------------------===//
177: // Analyze
178: //===--------------------------------------------------------------------===//
179: struct ValidityAnalyzeState : public AnalyzeState {
180: 	ValidityAnalyzeState() : count(0) {
181: 	}
182: 
183: 	idx_t count;
184: };
185: 
186: unique_ptr<AnalyzeState> ValidityInitAnalyze(ColumnData &col_data, PhysicalType type) {
187: 	return make_unique<ValidityAnalyzeState>();
188: }
189: 
190: bool ValidityAnalyze(AnalyzeState &state_p, Vector &input, idx_t count) {
191: 	auto &state = (ValidityAnalyzeState &)state_p;
192: 	state.count += count;
193: 	return true;
194: }
195: 
196: idx_t ValidityFinalAnalyze(AnalyzeState &state_p) {
197: 	auto &state = (ValidityAnalyzeState &)state_p;
198: 	return (state.count + 7) / 8;
199: }
200: 
201: //===--------------------------------------------------------------------===//
202: // Scan
203: //===--------------------------------------------------------------------===//
204: struct ValidityScanState : public SegmentScanState {
205: 	unique_ptr<BufferHandle> handle;
206: };
207: 
208: unique_ptr<SegmentScanState> ValidityInitScan(ColumnSegment &segment) {
209: 	auto result = make_unique<ValidityScanState>();
210: 	auto &buffer_manager = BufferManager::GetBufferManager(segment.db);
211: 	result->handle = buffer_manager.Pin(segment.block);
212: 	return move(result);
213: }
214: 
215: //===--------------------------------------------------------------------===//
216: // Scan base data
217: //===--------------------------------------------------------------------===//
218: void ValidityScanPartial(ColumnSegment &segment, ColumnScanState &state, idx_t scan_count, Vector &result,
219:                          idx_t result_offset) {
220: 	auto start = segment.GetRelativeIndex(state.row_index);
221: 
222: 	static_assert(sizeof(validity_t) == sizeof(uint64_t), "validity_t should be 64-bit");
223: 	auto &scan_state = (ValidityScanState &)*state.scan_state;
224: 
225: 	auto &result_mask = FlatVector::Validity(result);
226: 	auto buffer_ptr = scan_state.handle->node->buffer + segment.GetBlockOffset();
227: 	auto input_data = (validity_t *)buffer_ptr;
228: 
229: #ifdef DEBUG
230: 	// this method relies on all the bits we are going to write to being set to valid
231: 	for (idx_t i = 0; i < scan_count; i++) {
232: 		D_ASSERT(result_mask.RowIsValid(result_offset + i));
233: 	}
234: #endif
235: #if STANDARD_VECTOR_SIZE < 128
236: 	// fallback for tiny vector sizes
237: 	// the bitwise ops we use below don't work if the vector size is too small
238: 	ValidityMask source_mask(input_data);
239: 	for (idx_t i = 0; i < scan_count; i++) {
240: 		result_mask.Set(result_offset + i, source_mask.RowIsValid(start + i));
241: 	}
242: #else
243: 	// the code below does what the fallback code above states, but using bitwise ops:
244: 	auto result_data = (validity_t *)result_mask.GetData();
245: 
246: 	// set up the initial positions
247: 	// we need to find the validity_entry to modify, together with the bit-index WITHIN the validity entry
248: 	idx_t result_entry = result_offset / ValidityMask::BITS_PER_VALUE;
249: 	idx_t result_idx = result_offset - result_entry * ValidityMask::BITS_PER_VALUE;
250: 
251: 	// same for the input: find the validity_entry we are pulling from, together with the bit-index WITHIN that entry
252: 	idx_t input_entry = start / ValidityMask::BITS_PER_VALUE;
253: 	idx_t input_idx = start - input_entry * ValidityMask::BITS_PER_VALUE;
254: 
255: 	// now start the bit games
256: 	idx_t pos = 0;
257: 	while (pos < scan_count) {
258: 		// these are the current validity entries we are dealing with
259: 		idx_t current_result_idx = result_entry;
260: 		idx_t offset;
261: 		validity_t input_mask = input_data[input_entry];
262: 
263: 		// construct the mask to AND together with the result
264: 		if (result_idx < input_idx) {
265: 			// we have to shift the input RIGHT if the result_idx is smaller than the input_idx
266: 			auto shift_amount = input_idx - result_idx;
267: 			D_ASSERT(shift_amount > 0 && shift_amount <= ValidityMask::BITS_PER_VALUE);
268: 
269: 			input_mask = input_mask >> shift_amount;
270: 
271: 			// now the upper "shift_amount" bits are set to 0
272: 			// we need them to be set to 1
273: 			// otherwise the subsequent bitwise & will modify values outside of the range of values we want to alter
274: 			input_mask |= ValidityUncompressed::UPPER_MASKS[shift_amount];
275: 
276: 			// after this, we move to the next input_entry
277: 			offset = ValidityMask::BITS_PER_VALUE - input_idx;
278: 			input_entry++;
279: 			input_idx = 0;
280: 			result_idx += offset;
281: 		} else if (result_idx > input_idx) {
282: 			// we have to shift the input LEFT if the result_idx is bigger than the input_idx
283: 			auto shift_amount = result_idx - input_idx;
284: 			D_ASSERT(shift_amount > 0 && shift_amount <= ValidityMask::BITS_PER_VALUE);
285: 
286: 			// to avoid overflows, we set the upper "shift_amount" values to 0 first
287: 			input_mask = (input_mask & ~ValidityUncompressed::UPPER_MASKS[shift_amount]) << shift_amount;
288: 
289: 			// now the lower "shift_amount" bits are set to 0
290: 			// we need them to be set to 1
291: 			// otherwise the subsequent bitwise & will modify values outside of the range of values we want to alter
292: 			input_mask |= ValidityUncompressed::LOWER_MASKS[shift_amount];
293: 
294: 			// after this, we move to the next result_entry
295: 			offset = ValidityMask::BITS_PER_VALUE - result_idx;
296: 			result_entry++;
297: 			result_idx = 0;
298: 			input_idx += offset;
299: 		} else {
300: 			// if the input_idx is equal to result_idx they are already aligned
301: 			// we just move to the next entry for both after this
302: 			offset = ValidityMask::BITS_PER_VALUE - result_idx;
303: 			input_entry++;
304: 			result_entry++;
305: 			result_idx = input_idx = 0;
306: 		}
307: 		// now we need to check if we should include the ENTIRE mask
308: 		// OR if we need to mask from the right side
309: 		pos += offset;
310: 		if (pos > scan_count) {
311: 			// we need to set any bits that are past the scan_count on the right-side to 1
312: 			// this is required so we don't influence any bits that are not part of the scan
313: 			input_mask |= ValidityUncompressed::UPPER_MASKS[pos - scan_count];
314: 		}
315: 		// now finally we can merge the input mask with the result mask
316: 		if (input_mask != ValidityMask::ValidityBuffer::MAX_ENTRY) {
317: 			if (!result_data) {
318: 				result_mask.Initialize(MaxValue<idx_t>(STANDARD_VECTOR_SIZE, result_offset + scan_count));
319: 				result_data = (validity_t *)result_mask.GetData();
320: 			}
321: 			result_data[current_result_idx] &= input_mask;
322: 		}
323: 	}
324: #endif
325: 
326: #ifdef DEBUG
327: 	// verify that we actually accomplished the bitwise ops equivalent that we wanted to do
328: 	ValidityMask input_mask(input_data);
329: 	for (idx_t i = 0; i < scan_count; i++) {
330: 		D_ASSERT(result_mask.RowIsValid(result_offset + i) == input_mask.RowIsValid(start + i));
331: 	}
332: #endif
333: }
334: 
335: void ValidityScan(ColumnSegment &segment, ColumnScanState &state, idx_t scan_count, Vector &result) {
336: 	result.Normalify(scan_count);
337: 
338: 	auto start = segment.GetRelativeIndex(state.row_index);
339: 	if (start % ValidityMask::BITS_PER_VALUE == 0) {
340: 		auto &scan_state = (ValidityScanState &)*state.scan_state;
341: 
342: 		// aligned scan: no need to do anything fancy
343: 		// note: this is only an optimization which avoids having to do messy bitshifting in the common case
344: 		// it is not required for correctness
345: 		auto &result_mask = FlatVector::Validity(result);
346: 		auto buffer_ptr = scan_state.handle->node->buffer + segment.GetBlockOffset();
347: 		auto input_data = (validity_t *)buffer_ptr;
348: 		auto result_data = (validity_t *)result_mask.GetData();
349: 		idx_t start_offset = start / ValidityMask::BITS_PER_VALUE;
350: 		idx_t entry_scan_count = (scan_count + ValidityMask::BITS_PER_VALUE - 1) / ValidityMask::BITS_PER_VALUE;
351: 		for (idx_t i = 0; i < entry_scan_count; i++) {
352: 			auto input_entry = input_data[start_offset + i];
353: 			if (!result_data && input_entry == ValidityMask::ValidityBuffer::MAX_ENTRY) {
354: 				continue;
355: 			}
356: 			if (!result_data) {
357: 				result_mask.Initialize(MaxValue<idx_t>(STANDARD_VECTOR_SIZE, scan_count));
358: 				result_data = (validity_t *)result_mask.GetData();
359: 			}
360: 			result_data[i] = input_entry;
361: 		}
362: 	} else {
363: 		// unaligned scan: fall back to scan_partial which does bitshift tricks
364: 		ValidityScanPartial(segment, state, scan_count, result, 0);
365: 	}
366: }
367: 
368: //===--------------------------------------------------------------------===//
369: // Fetch
370: //===--------------------------------------------------------------------===//
371: void ValidityFetchRow(ColumnSegment &segment, ColumnFetchState &state, row_t row_id, Vector &result, idx_t result_idx) {
372: 	D_ASSERT(row_id >= 0 && row_id < row_t(segment.count));
373: 	auto &buffer_manager = BufferManager::GetBufferManager(segment.db);
374: 	auto handle = buffer_manager.Pin(segment.block);
375: 	auto dataptr = handle->node->buffer + segment.GetBlockOffset();
376: 	ValidityMask mask((validity_t *)dataptr);
377: 	auto &result_mask = FlatVector::Validity(result);
378: 	if (!mask.RowIsValidUnsafe(row_id)) {
379: 		result_mask.SetInvalid(result_idx);
380: 	}
381: }
382: 
383: //===--------------------------------------------------------------------===//
384: // Append
385: //===--------------------------------------------------------------------===//
386: unique_ptr<CompressedSegmentState> ValidityInitSegment(ColumnSegment &segment, block_id_t block_id) {
387: 	auto &buffer_manager = BufferManager::GetBufferManager(segment.db);
388: 	if (block_id == INVALID_BLOCK) {
389: 		auto handle = buffer_manager.Pin(segment.block);
390: 		memset(handle->node->buffer, 0xFF, Storage::BLOCK_SIZE);
391: 	}
392: 	return nullptr;
393: }
394: 
395: idx_t ValidityAppend(ColumnSegment &segment, SegmentStatistics &stats, VectorData &data, idx_t offset, idx_t vcount) {
396: 	D_ASSERT(segment.GetBlockOffset() == 0);
397: 	auto &validity_stats = (ValidityStatistics &)*stats.statistics;
398: 
399: 	auto max_tuples = Storage::BLOCK_SIZE / ValidityMask::STANDARD_MASK_SIZE * STANDARD_VECTOR_SIZE;
400: 	idx_t append_count = MinValue<idx_t>(vcount, max_tuples - segment.count);
401: 	if (data.validity.AllValid()) {
402: 		// no null values: skip append
403: 		segment.count += append_count;
404: 		validity_stats.has_no_null = true;
405: 		return append_count;
406: 	}
407: 	auto &buffer_manager = BufferManager::GetBufferManager(segment.db);
408: 	auto handle = buffer_manager.Pin(segment.block);
409: 
410: 	ValidityMask mask((validity_t *)handle->node->buffer);
411: 	for (idx_t i = 0; i < append_count; i++) {
412: 		auto idx = data.sel->get_index(offset + i);
413: 		if (!data.validity.RowIsValidUnsafe(idx)) {
414: 			mask.SetInvalidUnsafe(segment.count + i);
415: 			validity_stats.has_null = true;
416: 		} else {
417: 			validity_stats.has_no_null = true;
418: 		}
419: 	}
420: 	segment.count += append_count;
421: 	return append_count;
422: }
423: 
424: idx_t ValidityFinalizeAppend(ColumnSegment &segment, SegmentStatistics &stats) {
425: 	return ((segment.count + STANDARD_VECTOR_SIZE - 1) / STANDARD_VECTOR_SIZE) * ValidityMask::STANDARD_MASK_SIZE;
426: }
427: 
428: void ValidityRevertAppend(ColumnSegment &segment, idx_t start_row) {
429: 	idx_t start_bit = start_row - segment.start;
430: 
431: 	auto &buffer_manager = BufferManager::GetBufferManager(segment.db);
432: 	auto handle = buffer_manager.Pin(segment.block);
433: 	idx_t revert_start;
434: 	if (start_bit % 8 != 0) {
435: 		// handle sub-bit stuff (yay)
436: 		idx_t byte_pos = start_bit / 8;
437: 		idx_t bit_start = byte_pos * 8;
438: 		idx_t bit_end = (byte_pos + 1) * 8;
439: 		ValidityMask mask((validity_t *)handle->node->buffer + byte_pos);
440: 		for (idx_t i = start_bit; i < bit_end; i++) {
441: 			mask.SetValid(i - bit_start);
442: 		}
443: 		revert_start = bit_end / 8;
444: 	} else {
445: 		revert_start = start_bit / 8;
446: 	}
447: 	// for the rest, we just memset
448: 	memset(handle->node->buffer + revert_start, 0xFF, Storage::BLOCK_SIZE - revert_start);
449: }
450: 
451: //===--------------------------------------------------------------------===//
452: // Get Function
453: //===--------------------------------------------------------------------===//
454: CompressionFunction ValidityUncompressed::GetFunction(PhysicalType data_type) {
455: 	D_ASSERT(data_type == PhysicalType::BIT);
456: 	return CompressionFunction(CompressionType::COMPRESSION_UNCOMPRESSED, data_type, ValidityInitAnalyze,
457: 	                           ValidityAnalyze, ValidityFinalAnalyze, UncompressedFunctions::InitCompression,
458: 	                           UncompressedFunctions::Compress, UncompressedFunctions::FinalizeCompress,
459: 	                           ValidityInitScan, ValidityScan, ValidityScanPartial, ValidityFetchRow,
460: 	                           UncompressedFunctions::EmptySkip, ValidityInitSegment, ValidityAppend,
461: 	                           ValidityFinalizeAppend, ValidityRevertAppend);
462: }
463: 
464: } // namespace duckdb
[end of src/storage/compression/validity_uncompressed.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: