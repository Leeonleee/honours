{
  "repo": "duckdb/duckdb",
  "pull_number": 6361,
  "instance_id": "duckdb__duckdb-6361",
  "issue_numbers": [
    "6357"
  ],
  "base_commit": "88290f2c1c4fdd109c70a83353a157b89b2e0b4b",
  "patch": "diff --git a/tools/pythonpkg/src/include/duckdb_python/pyfilesystem.hpp b/tools/pythonpkg/src/include/duckdb_python/pyfilesystem.hpp\nindex c5946085b725..eb7bd749d462 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyfilesystem.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyfilesystem.hpp\n@@ -29,7 +29,7 @@ class PythonFileHandle : public FileHandle {\n \t}\n \n \tstatic const py::object &GetHandle(const FileHandle &handle) {\n-\t\treturn ((PythonFileHandle &)handle).handle;\n+\t\treturn ((const PythonFileHandle &)handle).handle;\n \t}\n \n private:\n@@ -39,15 +39,6 @@ class PythonFilesystem : public FileSystem {\n private:\n \tconst vector<string> protocols;\n \tconst AbstractFileSystem filesystem;\n-\tstring stripPrefix(string input) {\n-\t\tfor (const auto &protocol : protocols) {\n-\t\t\tauto prefix = protocol + \"://\";\n-\t\t\tif (StringUtil::StartsWith(input, prefix)) {\n-\t\t\t\treturn input.substr(prefix.size());\n-\t\t\t}\n-\t\t}\n-\t\treturn input;\n-\t}\n \tstd::string DecodeFlags(uint8_t flags);\n \n public:\ndiff --git a/tools/pythonpkg/src/pyfilesystem.cpp b/tools/pythonpkg/src/pyfilesystem.cpp\nindex 670b32cc154b..37c24e28a9a5 100644\n--- a/tools/pythonpkg/src/pyfilesystem.cpp\n+++ b/tools/pythonpkg/src/pyfilesystem.cpp\n@@ -57,8 +57,7 @@ unique_ptr<FileHandle> PythonFilesystem::OpenFile(const string &path, uint8_t fl\n \tstring flags_s = DecodeFlags(flags);\n \n \t// `seekable` is passed here for `ArrowFSWrapper`, other implementations seem happy enough to ignore it\n-\tconst auto &handle =\n-\t    filesystem.attr(\"open\")(py::str(stripPrefix(path)), py::str(flags_s), py::arg(\"seekable\") = true);\n+\tconst auto &handle = filesystem.attr(\"open\")(path, py::str(flags_s), py::arg(\"seekable\") = true);\n \treturn make_unique<PythonFileHandle>(*this, path, handle);\n }\n \n@@ -105,7 +104,7 @@ vector<string> PythonFilesystem::Glob(const string &path, FileOpener *opener) {\n \tif (!path.size()) {\n \t\treturn {path};\n \t}\n-\tauto returner = py::list(filesystem.attr(\"glob\")(py::str(stripPrefix(path))));\n+\tauto returner = py::list(filesystem.attr(\"glob\")(path));\n \n \tstd::vector<string> results;\n \tauto unstrip_protocol = filesystem.attr(\"unstrip_protocol\");\n@@ -118,7 +117,7 @@ int64_t PythonFilesystem::GetFileSize(FileHandle &handle) {\n \t// TODO: this value should be cached on the PythonFileHandle\n \tPythonGILWrapper gil;\n \n-\treturn py::int_(filesystem.attr(\"size\")(stripPrefix(handle.path)));\n+\treturn py::int_(filesystem.attr(\"size\")(handle.path));\n }\n void PythonFilesystem::Seek(duckdb::FileHandle &handle, uint64_t location) {\n \tPythonGILWrapper gil;\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_filesystem.py b/tools/pythonpkg/tests/fast/test_filesystem.py\nindex 5ae899ec6209..c681cd45a156 100644\n--- a/tools/pythonpkg/tests/fast/test_filesystem.py\n+++ b/tools/pythonpkg/tests/fast/test_filesystem.py\n@@ -4,6 +4,7 @@\n from shutil import copyfileobj\n from typing import Callable, List\n from os.path import exists\n+from pathlib import PurePosixPath\n \n import duckdb\n from duckdb import DuckDBPyConnection, InvalidInputException\n@@ -23,19 +24,31 @@ def intercept(monkeypatch: MonkeyPatch, obj: object, name: str) -> List[str]:\n     error_occured = []\n     orig = getattr(obj, name)\n \n-    def ceptor(*args,**kwargs):\n+    def ceptor(*args, **kwargs):\n         try:\n-            return orig(*args,**kwargs)\n+            return orig(*args, **kwargs)\n         except Exception as e:\n             error_occured.append(e)\n             raise e\n+\n     monkeypatch.setattr(obj, name, ceptor)\n     return error_occured\n \n \n+@fixture()\n+def duckdb_cursor():\n+    with duckdb.connect() as conn:\n+        yield conn\n+\n+\n @fixture()\n def memory():\n     fs = filesystem('memory', skip_instance_cache=True)\n+\n+    # ensure each instance is independent (to work around a weird quirk in fsspec)\n+    fs.store = {}\n+    fs.pseudo_dirs = ['']\n+\n     # copy csv into memory filesystem\n     add_file(fs)\n     return fs\n@@ -72,11 +85,14 @@ def test_unregister_builtin(self, require: Callable[[str], DuckDBPyConnection]):\n         duckdb_cursor.unregister_filesystem('S3FileSystem')\n \n     def test_multiple_protocol_filesystems(self, duckdb_cursor: DuckDBPyConnection):\n-        memory = MemoryFileSystem(skip_instance_cache=True)\n+        class ExtendedMemoryFileSystem(MemoryFileSystem):\n+            protocol = ('file', 'local')\n+            # defer to the original implementation that doesn't hardcode the protocol\n+            _strip_protocol = classmethod(AbstractFileSystem._strip_protocol.__func__)\n+\n+        memory = ExtendedMemoryFileSystem(skip_instance_cache=True)\n         add_file(memory)\n-        memory.protocol = ('file', 'local')\n         duckdb_cursor.register_filesystem(memory)\n-\n         for protocol in memory.protocol:\n             duckdb_cursor.execute(f\"select * from '{protocol}://{FILENAME}'\")\n \n@@ -123,20 +139,20 @@ def test_when_fsspec_not_installed(self, duckdb_cursor: DuckDBPyConnection, monk\n             duckdb_cursor.register_filesystem(None)\n \n     @mark.skipif(sys.version_info < (3, 8), reason=\"ArrowFSWrapper requires python 3.8 or higher\")\n-    def test_arrow_fs_wrapper(self, tmp_path: Path):\n+    def test_arrow_fs_wrapper(self, tmp_path: Path, duckdb_cursor: DuckDBPyConnection):\n         fs = importorskip('pyarrow.fs')\n         from fsspec.implementations.arrow import ArrowFSWrapper\n \n         local = fs.LocalFileSystem()\n         local_fsspec = ArrowFSWrapper(local, skip_instance_cache=True)\n         local_fsspec.protocol = \"local\"\n-        filename = str(tmp_path / \"test.csv\")\n+        # posix calls here required as ArrowFSWrapper only supports url-like paths (not Windows paths)\n+        filename = str(PurePosixPath(tmp_path.as_posix()) / \"test.csv\")\n         with local_fsspec.open(filename, mode='w') as f:\n             f.write(\"a,b,c\\n\")\n             f.write(\"1,2,3\\n\")\n             f.write(\"4,5,6\\n\")\n \n-        duckdb_cursor = duckdb.connect()\n         duckdb_cursor.register_filesystem(local_fsspec)\n         duckdb_cursor.execute(f\"select * from read_csv_auto('local://{filename}', header=true)\")\n \n@@ -163,7 +179,7 @@ def test_database_attach(self, tmp_path: Path, monkeypatch: MonkeyPatch):\n             conn.execute('INSERT INTO hello.t VALUES (1)')\n \n             conn.execute('FROM hello.t')\n-            assert conn.fetchall() == [(0, ), (1, )]\n+            assert conn.fetchall() == [(0,), (1,)]\n \n         # duckdb sometimes seems to swallow write errors, so we use this to ensure that \n         # isn't happening\n",
  "problem_statement": "`fsspec` integration cannot parse non-basic URL schemas\n### What happens?\n\nThe `fsspec` integration fails to parse non-basic URL schemas making it impossible to query more complex filesystems.\r\n\r\nBy monkey-patching `fsspec`'s methods, it seems the issue stems from using [`stripPrefix`](https://github.com/duckdb/duckdb/blob/d2ef69494ef54f50d8c9073fdaa5d2b8dad7c99d/tools/pythonpkg/src/include/duckdb_python/pyfilesystem.hpp#L42) and not `fsspec`'s [`_strip_protocol`](https://github.com/fsspec/filesystem_spec/blob/35da646cf4baea2a4be43b61fbfd9a952f480c3f/fsspec/spec.py#L178) - e.g., the path segment of the( `fsspec`) URL \"github://mwaskom:seaborn-data@/anagrams.csv\" is \"anagrams.csv\", but `stripPrefix` parses it as \"mwaskom:seaborn-data@/anagrams.csv\", which later fails on reading/globbing the files.\r\n\r\ncc @Mause (*the issue originally reported in https://github.com/huggingface/hffs/pull/10*)\n\n### To Reproduce\n\nExecute a query on  a `GithubFileSystem`:\r\n\r\n```python\r\n# !pip install fsspec pandas duckdb>=0.7.0\r\nimport fsspec\r\nimport duckdb\r\nimport pandas as pd\r\nfrom fsspec.implementations.github import GithubFileSystem\r\n\r\nfs_url = \"github://mwaskom:seaborn-data@/anagrams.csv\"\r\nfs, _, paths = fsspec.get_fs_token_paths(fs_url)\r\n\r\n# No issues for Pandas\r\ndf = pd.read_csv(fs_url)\r\n\r\n# DuckDB fails\r\nduckdb.register_filesystem(fs)\r\n\r\nduckdb.execute(f\"SELECT * FROM '{fs_url}'\")\r\n# error: IOException: IO Error: No files found that match the pattern \"github://mwaskom:seaborn-data@/anagrams.csv\"\r\n```\n\n### OS:\n\nmacOS aarch64\n\n### DuckDB Version:\n\n0.7.0\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nMario Sasko\n\n### Affiliation:\n\nHugging Face\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-02-18T16:20:13Z"
}