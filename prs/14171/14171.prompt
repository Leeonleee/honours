You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Failed to create prepared statement for insert-statement after called ToString method
### What happens?

`duckdb::Connection` has `Prepare` method accepting `duckdb::SQLStatement`
Calling `Prepare` method after `duckdb::SQLStatement::ToString` led to throwing an exception: 

> GetUsingBinding: expected non-empty binding_name.

it seems to forget reverting `alias` property.
https://github.com/duckdb/duckdb/blob/45559f5eeb1834454a30490fc4ffad1807e13f3b/src/parser/statement/insert_statement.cpp#L99-L103

Is this expected feature?

### To Reproduce

## Code

```cpp
auto db = duckdb::Duckdb(nullptr);
auto conn = duckdb::Connection(db);

// It supporses to exist `Foo` table
// `Foo` table is `CREATE TABLE Foo (id int primary key, name varchar, age int)`
std::string sql("INSERT INTO Foo values (1, 'qwerty', 42)";

// get parsed statements
auto stmts = conn.ExtractStatements(sql);
auto &stmt = stmts[0];

// Call Tostring
stmt->ToString();

// Call prepare
auto prepared_stmt = conn.Prepare(stmt); // <- `duckdb::InternalException` is throws here
```

## Expected result
`duckdb::unique_ptr<duckdb::PreparedStatement>` is returned successfully.

## Actual result
`duckdb::InternalException` is throws
from https://github.com/duckdb/duckdb/blob/45559f5eeb1834454a30490fc4ffad1807e13f3b/src/planner/bind_context.cpp#L100

## Workaround

```cpp
stmt->Copy()->ToString();
auto prepared_stmt = conn.Prepare(stmt);
```

### OS:

MacOS Ventura 13.6.7 (x86_64 16GB RAM)

### DuckDB Version:

1.1.0

### DuckDB Client:

C++

### Hardware:

_No response_

### Full Name:

Kazuhiko TAMURA

### Affiliation:

Free

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of .github/config/out_of_tree_extensions.cmake]
1: #
2: # This config file holds all out-of-tree extension that are built with DuckDB's CI
3: #
4: # to build duckdb with this configuration run:
5: #   EXTENSION_CONFIGS=.github/config/out_of_tree_extensions.cmake make
6: #
7: #  Note that many of these packages require vcpkg, and a merged manifest must be created to
8: #  compile multiple of them.
9: #
10: #  After setting up vcpkg, build using e.g. the following commands:
11: #  USE_MERGED_VCPKG_MANIFEST=1 BUILD_ALL_EXT=1 make extension_configuration
12: #  USE_MERGED_VCPKG_MANIFEST=1 BUILD_ALL_EXT=1 make debug
13: #
14: #  Make sure the VCPKG_TOOLCHAIN_PATH and VCPKG_TARGET_TRIPLET are set. For example:
15: #  VCPKG_TOOLCHAIN_PATH=~/vcpkg/scripts/buildsystems/vcpkg.cmake
16: #  VCPKG_TARGET_TRIPLET=arm64-osx
17: 
18: ################# ARROW
19: if (NOT MINGW)
20:     duckdb_extension_load(arrow
21:             LOAD_TESTS DONT_LINK
22:             GIT_URL https://github.com/duckdb/arrow
23:             GIT_TAG c50862c82c065096722745631f4230832a3a04e8
24:             )
25: endif()
26: 
27: ################## AWS
28: if (NOT MINGW)
29:     duckdb_extension_load(aws
30:             LOAD_TESTS
31:             GIT_URL https://github.com/duckdb/duckdb_aws
32:             GIT_TAG e738b4cc07a86d323db8b38220323752cd183a04
33:             )
34: endif()
35: 
36: ################# AZURE
37: if (NOT MINGW)
38:     duckdb_extension_load(azure
39:             LOAD_TESTS
40:             GIT_URL https://github.com/duckdb/duckdb_azure
41:             GIT_TAG b0ffe7ada20cdbd0bee2bbe5461ecd22fb468062
42:             )
43: endif()
44: 
45: ################# DELTA
46: # MinGW build is not available, and our current manylinux ci does not have enough storage space to run the rust build
47: # for Delta
48: if (NOT MINGW AND NOT "${OS_NAME}" STREQUAL "linux")
49:     duckdb_extension_load(delta
50:             LOAD_TESTS
51:             GIT_URL https://github.com/duckdb/duckdb_delta
52:             GIT_TAG 3933ebd800ad06a64656c9aef6ca7d62897fa4db
53:     )
54: endif()
55: 
56: ################# EXCEL
57: duckdb_extension_load(excel
58:     LOAD_TESTS
59:     GIT_URL https://github.com/duckdb/duckdb_excel
60:     GIT_TAG 0e99dc789038c7af658e30d579b818473a6d6ea8
61:     INCLUDE_DIR extension/excel/include
62:     )
63: 
64: ################# ICEBERG
65: # Windows tests for iceberg currently not working
66: if (NOT WIN32)
67:     set(LOAD_ICEBERG_TESTS "LOAD_TESTS")
68: else ()
69:     set(LOAD_ICEBERG_TESTS "")
70: endif()
71: 
72: if (NOT MINGW)
73:     duckdb_extension_load(iceberg
74:             ${LOAD_ICEBERG_TESTS}
75:             GIT_URL https://github.com/duckdb/duckdb_iceberg
76:             GIT_TAG 3f6d753787252e3da1d12157910b62edf729fc6e
77:             )
78: endif()
79: 
80: ################# INET
81: duckdb_extension_load(inet
82:     LOAD_TESTS
83:     GIT_URL https://github.com/duckdb/duckdb_inet
84:     GIT_TAG eca867b2517af06eabc89ccd6234266e9a7d6d71
85:     INCLUDE_DIR src/include
86:     TEST_DIR test/sql
87:     )
88: 
89: ################# POSTGRES_SCANNER
90: # Note: tests for postgres_scanner are currently not run. All of them need a postgres server running. One test
91: #       uses a remote rds server but that's not something we want to run here.
92: if (NOT MINGW)
93:     duckdb_extension_load(postgres_scanner
94:             DONT_LINK
95:             GIT_URL https://github.com/duckdb/postgres_scanner
96:             GIT_TAG 03eaed75f0ec5500609b7a97aa05468493b229d1
97:             )
98: endif()
99: 
100: ################# SPATIAL
101: duckdb_extension_load(spatial
102:     DONT_LINK LOAD_TESTS
103:     GIT_URL https://github.com/duckdb/duckdb_spatial.git
104:     GIT_TAG bb9c829693965f029eb5a312aefed4c538fad781
105:     INCLUDE_DIR spatial/include
106:     TEST_DIR test/sql
107:     )
108: 
109: ################# SQLITE_SCANNER
110: # Static linking on windows does not properly work due to symbol collision
111: if (WIN32)
112:     set(STATIC_LINK_SQLITE "DONT_LINK")
113: else ()
114:     set(STATIC_LINK_SQLITE "")
115: endif()
116: 
117: duckdb_extension_load(sqlite_scanner
118:         ${STATIC_LINK_SQLITE} LOAD_TESTS
119:         GIT_URL https://github.com/duckdb/sqlite_scanner
120:         GIT_TAG 315861963c8106397af36cbda10faebc8dae485a
121:         )
122: 
123: duckdb_extension_load(sqlsmith
124:         DONT_LINK LOAD_TESTS
125:         GIT_URL https://github.com/duckdb/duckdb_sqlsmith
126:         GIT_TAG f24be8b5b0cd0eeed7541e10cff42d7050771afc
127:         )
128: 
129: ################# SUBSTRAIT
130: if (NOT WIN32)
131:     duckdb_extension_load(substrait
132:             LOAD_TESTS DONT_LINK
133:             GIT_URL https://github.com/duckdb/substrait
134:             GIT_TAG be71387cf0a484dc7b261a0cb21abec0d0e0ce5c
135:             )
136: endif()
137: 
138: 
139: ################# VSS
140: duckdb_extension_load(vss
141:         LOAD_TESTS
142:         DONT_LINK
143:         GIT_URL https://github.com/duckdb/duckdb_vss
144:         GIT_TAG 77739ea5382cce3220af83803ac0b1e98b3ab7d8
145:         TEST_DIR test/sql
146:     )
147: 
148: ################# MYSQL
149: if (NOT MINGW)
150:     duckdb_extension_load(mysql_scanner
151:             DONT_LINK
152:             LOAD_TESTS
153:             GIT_URL https://github.com/duckdb/duckdb_mysql
154:             GIT_TAG f2a15013fb4559e1591e977c1c023aa0a369c6f3
155:             )
156: endif()
[end of .github/config/out_of_tree_extensions.cmake]
[start of src/parser/statement/insert_statement.cpp]
1: #include "duckdb/parser/statement/insert_statement.hpp"
2: #include "duckdb/parser/query_node/select_node.hpp"
3: #include "duckdb/parser/tableref/expressionlistref.hpp"
4: #include "duckdb/parser/statement/update_statement.hpp"
5: 
6: namespace duckdb {
7: 
8: OnConflictInfo::OnConflictInfo() : action_type(OnConflictAction::THROW) {
9: }
10: 
11: OnConflictInfo::OnConflictInfo(const OnConflictInfo &other)
12:     : action_type(other.action_type), indexed_columns(other.indexed_columns) {
13: 	if (other.set_info) {
14: 		set_info = other.set_info->Copy();
15: 	}
16: 	if (other.condition) {
17: 		condition = other.condition->Copy();
18: 	}
19: }
20: 
21: unique_ptr<OnConflictInfo> OnConflictInfo::Copy() const {
22: 	return unique_ptr<OnConflictInfo>(new OnConflictInfo(*this));
23: }
24: 
25: InsertStatement::InsertStatement()
26:     : SQLStatement(StatementType::INSERT_STATEMENT), schema(DEFAULT_SCHEMA), catalog(INVALID_CATALOG) {
27: }
28: 
29: InsertStatement::InsertStatement(const InsertStatement &other)
30:     : SQLStatement(other), select_statement(unique_ptr_cast<SQLStatement, SelectStatement>(
31:                                other.select_statement ? other.select_statement->Copy() : nullptr)),
32:       columns(other.columns), table(other.table), schema(other.schema), catalog(other.catalog),
33:       default_values(other.default_values), column_order(other.column_order) {
34: 	cte_map = other.cte_map.Copy();
35: 	for (auto &expr : other.returning_list) {
36: 		returning_list.emplace_back(expr->Copy());
37: 	}
38: 	if (other.table_ref) {
39: 		table_ref = other.table_ref->Copy();
40: 	}
41: 	if (other.on_conflict_info) {
42: 		on_conflict_info = other.on_conflict_info->Copy();
43: 	}
44: }
45: 
46: string InsertStatement::OnConflictActionToString(OnConflictAction action) {
47: 	switch (action) {
48: 	case OnConflictAction::NOTHING:
49: 		return "DO NOTHING";
50: 	case OnConflictAction::REPLACE:
51: 	case OnConflictAction::UPDATE:
52: 		return "DO UPDATE";
53: 	case OnConflictAction::THROW:
54: 		// Explicitly left empty, for ToString purposes
55: 		return "";
56: 	default: {
57: 		throw NotImplementedException("type not implemented for OnConflictActionType");
58: 	}
59: 	}
60: }
61: 
62: string InsertStatement::ToString() const {
63: 	bool or_replace_shorthand_set = false;
64: 	string result;
65: 
66: 	result = cte_map.ToString();
67: 	result += "INSERT";
68: 	if (on_conflict_info && on_conflict_info->action_type == OnConflictAction::REPLACE) {
69: 		or_replace_shorthand_set = true;
70: 		result += " OR REPLACE";
71: 	}
72: 	result += " INTO ";
73: 	if (!catalog.empty()) {
74: 		result += KeywordHelper::WriteOptionallyQuoted(catalog) + ".";
75: 	}
76: 	if (!schema.empty()) {
77: 		result += KeywordHelper::WriteOptionallyQuoted(schema) + ".";
78: 	}
79: 	result += KeywordHelper::WriteOptionallyQuoted(table);
80: 	// Write the (optional) alias of the insert target
81: 	if (table_ref && !table_ref->alias.empty()) {
82: 		result += StringUtil::Format(" AS %s", KeywordHelper::WriteOptionallyQuoted(table_ref->alias));
83: 	}
84: 	if (column_order == InsertColumnOrder::INSERT_BY_NAME) {
85: 		result += " BY NAME";
86: 	}
87: 	if (!columns.empty()) {
88: 		result += " (";
89: 		for (idx_t i = 0; i < columns.size(); i++) {
90: 			if (i > 0) {
91: 				result += ", ";
92: 			}
93: 			result += KeywordHelper::WriteOptionallyQuoted(columns[i]);
94: 		}
95: 		result += " )";
96: 	}
97: 	result += " ";
98: 	auto values_list = GetValuesList();
99: 	if (values_list) {
100: 		D_ASSERT(!default_values);
101: 		values_list->alias = string();
102: 		result += values_list->ToString();
103: 	} else if (select_statement) {
104: 		D_ASSERT(!default_values);
105: 		result += select_statement->ToString();
106: 	} else {
107: 		D_ASSERT(default_values);
108: 		result += "DEFAULT VALUES";
109: 	}
110: 	if (!or_replace_shorthand_set && on_conflict_info) {
111: 		auto &conflict_info = *on_conflict_info;
112: 		result += " ON CONFLICT ";
113: 		// (optional) conflict target
114: 		if (!conflict_info.indexed_columns.empty()) {
115: 			result += "(";
116: 			auto &columns = conflict_info.indexed_columns;
117: 			for (auto it = columns.begin(); it != columns.end();) {
118: 				result += StringUtil::Lower(*it);
119: 				if (++it != columns.end()) {
120: 					result += ", ";
121: 				}
122: 			}
123: 			result += " )";
124: 		}
125: 
126: 		// (optional) where clause
127: 		if (conflict_info.condition) {
128: 			result += " WHERE " + conflict_info.condition->ToString();
129: 		}
130: 		result += " " + OnConflictActionToString(conflict_info.action_type);
131: 		if (conflict_info.set_info) {
132: 			D_ASSERT(conflict_info.action_type == OnConflictAction::UPDATE);
133: 			result += " SET ";
134: 			auto &set_info = *conflict_info.set_info;
135: 			D_ASSERT(set_info.columns.size() == set_info.expressions.size());
136: 			// SET <column_name> = <expression>
137: 			for (idx_t i = 0; i < set_info.columns.size(); i++) {
138: 				auto &column = set_info.columns[i];
139: 				auto &expr = set_info.expressions[i];
140: 				if (i) {
141: 					result += ", ";
142: 				}
143: 				result += StringUtil::Lower(column) + " = " + expr->ToString();
144: 			}
145: 			// (optional) where clause
146: 			if (set_info.condition) {
147: 				result += " WHERE " + set_info.condition->ToString();
148: 			}
149: 		}
150: 	}
151: 	if (!returning_list.empty()) {
152: 		result += " RETURNING ";
153: 		for (idx_t i = 0; i < returning_list.size(); i++) {
154: 			if (i > 0) {
155: 				result += ", ";
156: 			}
157: 			result += returning_list[i]->ToString();
158: 		}
159: 	}
160: 	return result;
161: }
162: 
163: unique_ptr<SQLStatement> InsertStatement::Copy() const {
164: 	return unique_ptr<InsertStatement>(new InsertStatement(*this));
165: }
166: 
167: optional_ptr<ExpressionListRef> InsertStatement::GetValuesList() const {
168: 	if (!select_statement) {
169: 		return nullptr;
170: 	}
171: 	if (select_statement->node->type != QueryNodeType::SELECT_NODE) {
172: 		return nullptr;
173: 	}
174: 	auto &node = select_statement->node->Cast<SelectNode>();
175: 	if (node.where_clause || node.qualify || node.having) {
176: 		return nullptr;
177: 	}
178: 	if (!node.cte_map.map.empty()) {
179: 		return nullptr;
180: 	}
181: 	if (!node.groups.grouping_sets.empty()) {
182: 		return nullptr;
183: 	}
184: 	if (node.aggregate_handling != AggregateHandling::STANDARD_HANDLING) {
185: 		return nullptr;
186: 	}
187: 	if (node.select_list.size() != 1 || node.select_list[0]->type != ExpressionType::STAR) {
188: 		return nullptr;
189: 	}
190: 	if (!node.from_table || node.from_table->type != TableReferenceType::EXPRESSION_LIST) {
191: 		return nullptr;
192: 	}
193: 	return &node.from_table->Cast<ExpressionListRef>();
194: }
195: 
196: } // namespace duckdb
[end of src/parser/statement/insert_statement.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: