{
  "repo": "duckdb/duckdb",
  "pull_number": 14171,
  "instance_id": "duckdb__duckdb-14171",
  "issue_numbers": [
    "14130"
  ],
  "base_commit": "d58cc56f8554057f9646ea343d845e1b1ba6466e",
  "patch": "diff --git a/.github/config/out_of_tree_extensions.cmake b/.github/config/out_of_tree_extensions.cmake\nindex b162b27a54bb..76d7d141eeec 100644\n--- a/.github/config/out_of_tree_extensions.cmake\n+++ b/.github/config/out_of_tree_extensions.cmake\n@@ -124,6 +124,7 @@ duckdb_extension_load(sqlsmith\n         DONT_LINK LOAD_TESTS\n         GIT_URL https://github.com/duckdb/duckdb_sqlsmith\n         GIT_TAG f24be8b5b0cd0eeed7541e10cff42d7050771afc\n+        APPLY_PATCHES\n         )\n \n ################# SUBSTRAIT\ndiff --git a/.github/patches/extensions/sqlsmith/insert_statement_to_string.patch b/.github/patches/extensions/sqlsmith/insert_statement_to_string.patch\nnew file mode 100644\nindex 000000000000..30845ddf62ce\n--- /dev/null\n+++ b/.github/patches/extensions/sqlsmith/insert_statement_to_string.patch\n@@ -0,0 +1,13 @@\n+diff --git a/test/sql/sql_reduce.test b/test/sql/sql_reduce.test\n+index 428ae92..af0530f 100644\n+--- a/test/sql/sql_reduce.test\n++++ b/test/sql/sql_reduce.test\n+@@ -48,7 +48,7 @@ INSERT INTO tbl (VALUES (1))\n+ INSERT INTO tbl (VALUES (1, 2))\n+ INSERT INTO tbl (VALUES (2))\n+ INSERT INTO tbl SELECT *\n+-INSERT INTO tbl SELECT NULL FROM (VALUES (1, 2))\n++INSERT INTO tbl SELECT NULL FROM (VALUES (1, 2)) AS valueslist\n+ INSERT INTO tbl SELECT NULL FROM (VALUES (1, 2)) AS valueslist\n+ \n+ query I\ndiff --git a/src/parser/statement/insert_statement.cpp b/src/parser/statement/insert_statement.cpp\nindex 4255ebb97b61..4035632975fd 100644\n--- a/src/parser/statement/insert_statement.cpp\n+++ b/src/parser/statement/insert_statement.cpp\n@@ -98,8 +98,10 @@ string InsertStatement::ToString() const {\n \tauto values_list = GetValuesList();\n \tif (values_list) {\n \t\tD_ASSERT(!default_values);\n+\t\tauto saved_alias = values_list->alias;\n \t\tvalues_list->alias = string();\n \t\tresult += values_list->ToString();\n+\t\tvalues_list->alias = saved_alias;\n \t} else if (select_statement) {\n \t\tD_ASSERT(!default_values);\n \t\tresult += select_statement->ToString();\n",
  "test_patch": "diff --git a/test/api/test_api.cpp b/test/api/test_api.cpp\nindex 3452604e4066..8df86cdf9f0b 100644\n--- a/test/api/test_api.cpp\n+++ b/test/api/test_api.cpp\n@@ -580,6 +580,25 @@ TEST_CASE(\"Issue #4583: Catch Insert/Update/Delete errors\", \"[api]\") {\n \tREQUIRE(CHECK_COLUMN(result, 0, {1}));\n }\n \n+TEST_CASE(\"Issue #14130: InsertStatement::ToString causes InternalException later on\", \"[api][.]\") {\n+\tauto db = DuckDB(nullptr);\n+\tauto conn = Connection(db);\n+\n+\tconn.Query(\"CREATE TABLE foo(a int, b varchar, c int)\");\n+\n+\tauto query = \"INSERT INTO Foo values (1, 'qwerty', 42)\";\n+\n+\tauto stmts = conn.ExtractStatements(query);\n+\tauto &stmt = stmts[0];\n+\n+\t// Issue was here: calling ToString destroyed the 'alias' of the ValuesList\n+\tstmt->ToString();\n+\t// Which caused an 'InternalException: expected non-empty binding_name' here\n+\tauto prepared_stmt = conn.Prepare(std::move(stmt));\n+\tREQUIRE(!prepared_stmt->HasError());\n+\tREQUIRE_NO_FAIL(prepared_stmt->Execute());\n+}\n+\n TEST_CASE(\"Issue #6284: CachingPhysicalOperator in pull causes issues\", \"[api][.]\") {\n \n \tDBConfig config;\n",
  "problem_statement": "Failed to create prepared statement for insert-statement after called ToString method\n### What happens?\r\n\r\n`duckdb::Connection` has `Prepare` method accepting `duckdb::SQLStatement`\r\nCalling `Prepare` method after `duckdb::SQLStatement::ToString` led to throwing an exception: \r\n\r\n> GetUsingBinding: expected non-empty binding_name.\r\n\r\nit seems to forget reverting `alias` property.\r\nhttps://github.com/duckdb/duckdb/blob/45559f5eeb1834454a30490fc4ffad1807e13f3b/src/parser/statement/insert_statement.cpp#L99-L103\r\n\r\nIs this expected feature?\r\n\r\n### To Reproduce\r\n\r\n## Code\r\n\r\n```cpp\r\nauto db = duckdb::Duckdb(nullptr);\r\nauto conn = duckdb::Connection(db);\r\n\r\n// It supporses to exist `Foo` table\r\n// `Foo` table is `CREATE TABLE Foo (id int primary key, name varchar, age int)`\r\nstd::string sql(\"INSERT INTO Foo values (1, 'qwerty', 42)\";\r\n\r\n// get parsed statements\r\nauto stmts = conn.ExtractStatements(sql);\r\nauto &stmt = stmts[0];\r\n\r\n// Call Tostring\r\nstmt->ToString();\r\n\r\n// Call prepare\r\nauto prepared_stmt = conn.Prepare(stmt); // <- `duckdb::InternalException` is throws here\r\n```\r\n\r\n## Expected result\r\n`duckdb::unique_ptr<duckdb::PreparedStatement>` is returned successfully.\r\n\r\n## Actual result\r\n`duckdb::InternalException` is throws\r\nfrom https://github.com/duckdb/duckdb/blob/45559f5eeb1834454a30490fc4ffad1807e13f3b/src/planner/bind_context.cpp#L100\r\n\r\n## Workaround\r\n\r\n```cpp\r\nstmt->Copy()->ToString();\r\nauto prepared_stmt = conn.Prepare(stmt);\r\n```\r\n\r\n### OS:\r\n\r\nMacOS Ventura 13.6.7 (x86_64 16GB RAM)\r\n\r\n### DuckDB Version:\r\n\r\n1.1.0\r\n\r\n### DuckDB Client:\r\n\r\nC++\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nKazuhiko TAMURA\r\n\r\n### Affiliation:\r\n\r\nFree\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have not tested with any build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-09-30T09:11:26Z"
}