{
  "repo": "duckdb/duckdb",
  "pull_number": 7180,
  "instance_id": "duckdb__duckdb-7180",
  "issue_numbers": [
    "7154"
  ],
  "base_commit": "8a0c3ecb126b11b701332811ae49353015c2a486",
  "patch": "diff --git a/src/common/radix_partitioning.cpp b/src/common/radix_partitioning.cpp\nindex 7d45313e90af..68290deb7af4 100644\n--- a/src/common/radix_partitioning.cpp\n+++ b/src/common/radix_partitioning.cpp\n@@ -9,7 +9,7 @@\n namespace duckdb {\n \n template <class OP, class RETURN_TYPE, typename... ARGS>\n-RETURN_TYPE RadixBitsSwitch(idx_t radix_bits, ARGS &&...args) {\n+RETURN_TYPE RadixBitsSwitch(idx_t radix_bits, ARGS &&... args) {\n \tD_ASSERT(radix_bits <= sizeof(hash_t) * 8);\n \tswitch (radix_bits) {\n \tcase 1:\ndiff --git a/src/include/duckdb.h b/src/include/duckdb.h\nindex e13720fe33aa..9d870acb3a04 100644\n--- a/src/include/duckdb.h\n+++ b/src/include/duckdb.h\n@@ -190,6 +190,23 @@ typedef struct {\n \tidx_t size;\n } duckdb_string;\n \n+/*\n+    The internal data representation of a VARCHAR/BLOB column\n+*/\n+typedef struct {\n+\tunion {\n+\t\tstruct {\n+\t\t\tuint32_t length;\n+\t\t\tchar prefix[4];\n+\t\t\tchar *ptr;\n+\t\t} pointer;\n+\t\tstruct {\n+\t\t\tuint32_t length;\n+\t\t\tchar inlined[12];\n+\t\t} inlined;\n+\t} value;\n+} duckdb_string_t;\n+\n typedef struct {\n \tvoid *data;\n \tidx_t size;\n@@ -298,6 +315,7 @@ typedef enum {\n /*!\n Creates a new database or opens an existing database file stored at the the given path.\n If no path is given a new in-memory database is created instead.\n+The instantiated database should be closed with 'duckdb_close'\n \n * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.\n * out_database: The result database object.\n@@ -331,6 +349,7 @@ DUCKDB_API void duckdb_close(duckdb_database *database);\n /*!\n Opens a connection to a database. Connections are required to query the database, and store transactional state\n associated with the connection.\n+The instantiated connection should be closed using 'duckdb_disconnect'\n \n * database: The database file to connect to.\n * out_connection: The result connection object.\n@@ -751,6 +770,13 @@ This is the amount of tuples that will fit into a data chunk created by `duckdb_\n */\n DUCKDB_API idx_t duckdb_vector_size();\n \n+/*!\n+Whether or not the duckdb_string_t value is inlined.\n+This means that the data of the string does not have a separate allocation.\n+\n+*/\n+DUCKDB_API bool duckdb_string_is_inlined(duckdb_string_t string);\n+\n //===--------------------------------------------------------------------===//\n // Date/Time/Timestamp Helpers\n //===--------------------------------------------------------------------===//\ndiff --git a/src/main/capi/helper-c.cpp b/src/main/capi/helper-c.cpp\nindex 23d4f6e4348a..cf8001e13e44 100644\n--- a/src/main/capi/helper-c.cpp\n+++ b/src/main/capi/helper-c.cpp\n@@ -186,3 +186,10 @@ void duckdb_free(void *ptr) {\n idx_t duckdb_vector_size() {\n \treturn STANDARD_VECTOR_SIZE;\n }\n+\n+bool duckdb_string_is_inlined(duckdb_string_t string_p) {\n+\tstatic_assert(sizeof(duckdb_string_t) == sizeof(duckdb::string_t),\n+\t              \"duckdb_string_t should have the same memory layout as duckdb::string_t\");\n+\tauto &string = *(duckdb::string_t *)(&string_p);\n+\treturn string.IsInlined();\n+}\n",
  "test_patch": "diff --git a/test/api/capi/test_capi_data_chunk.cpp b/test/api/capi/test_capi_data_chunk.cpp\nindex 27a56c1c501d..4d5c15ffc350 100644\n--- a/test/api/capi/test_capi_data_chunk.cpp\n+++ b/test/api/capi/test_capi_data_chunk.cpp\n@@ -193,6 +193,84 @@ TEST_CASE(\"Test DataChunk C API\", \"[capi]\") {\n \tduckdb_destroy_logical_type(&types[1]);\n }\n \n+TEST_CASE(\"Test DataChunk varchar result fetch in C API\", \"[capi]\") {\n+\tif (duckdb_vector_size() < 64) {\n+\t\treturn;\n+\t}\n+\n+\tduckdb_database database;\n+\tduckdb_connection connection;\n+\tduckdb_state state;\n+\n+\tstate = duckdb_open(nullptr, &database);\n+\tREQUIRE(state == DuckDBSuccess);\n+\tstate = duckdb_connect(database, &connection);\n+\tREQUIRE(state == DuckDBSuccess);\n+\n+\tconstexpr const char *VARCHAR_TEST_QUERY = \"select case when i != 0 and i % 42 = 0 then NULL else repeat(chr((65 + \"\n+\t                                           \"(i % 26))::INTEGER), (4 + (i % 12))) end from range(5000) tbl(i);\";\n+\n+\t// fetch a small result set\n+\tduckdb_result result;\n+\tstate = duckdb_query(connection, VARCHAR_TEST_QUERY, &result);\n+\tREQUIRE(state == DuckDBSuccess);\n+\n+\tREQUIRE(duckdb_column_count(&result) == 1);\n+\tREQUIRE(duckdb_row_count(&result) == 5000);\n+\tREQUIRE(duckdb_result_error(&result) == nullptr);\n+\n+\tidx_t expected_chunk_count = (5000 / STANDARD_VECTOR_SIZE) + (5000 % STANDARD_VECTOR_SIZE != 0);\n+\n+\tREQUIRE(duckdb_result_chunk_count(result) == expected_chunk_count);\n+\n+\tauto chunk = duckdb_result_get_chunk(result, 0);\n+\n+\tREQUIRE(duckdb_data_chunk_get_column_count(chunk) == 1);\n+\tREQUIRE(STANDARD_VECTOR_SIZE < 5000);\n+\tREQUIRE(duckdb_data_chunk_get_size(chunk) == STANDARD_VECTOR_SIZE);\n+\tduckdb_destroy_data_chunk(&chunk);\n+\n+\tidx_t tuple_index = 0;\n+\tauto chunk_amount = duckdb_result_chunk_count(result);\n+\tfor (idx_t chunk_index = 0; chunk_index < chunk_amount; chunk_index++) {\n+\t\tchunk = duckdb_result_get_chunk(result, chunk_index);\n+\t\t// Our result only has one column\n+\t\tauto vector = duckdb_data_chunk_get_vector(chunk, 0);\n+\t\tauto validity = duckdb_vector_get_validity(vector);\n+\t\tauto string_data = (duckdb_string_t *)duckdb_vector_get_data(vector);\n+\n+\t\tauto tuples_in_chunk = duckdb_data_chunk_get_size(chunk);\n+\t\tfor (idx_t i = 0; i < tuples_in_chunk; i++, tuple_index++) {\n+\t\t\tif (!duckdb_validity_row_is_valid(validity, i)) {\n+\t\t\t\t// This entry is NULL\n+\t\t\t\tREQUIRE((tuple_index != 0 && tuple_index % 42 == 0));\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tidx_t expected_length = (tuple_index % 12) + 4;\n+\t\t\tchar expected_character = (tuple_index % 26) + 'A';\n+\n+\t\t\t// TODO: how does the c-api handle non-flat vectors?\n+\t\t\tauto tuple = string_data[i];\n+\t\t\tauto length = tuple.value.inlined.length;\n+\t\t\tREQUIRE(length == expected_length);\n+\t\t\tif (duckdb_string_is_inlined(tuple)) {\n+\t\t\t\t// The data is small enough to fit in the string_t, it does not have a separate allocation\n+\t\t\t\tfor (idx_t string_index = 0; string_index < length; string_index++) {\n+\t\t\t\t\tREQUIRE(tuple.value.inlined.inlined[string_index] == expected_character);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor (idx_t string_index = 0; string_index < length; string_index++) {\n+\t\t\t\t\tREQUIRE(tuple.value.pointer.ptr[string_index] == expected_character);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tduckdb_destroy_data_chunk(&chunk);\n+\t}\n+\tduckdb_destroy_result(&result);\n+\tduckdb_disconnect(&connection);\n+\tduckdb_close(&database);\n+}\n+\n TEST_CASE(\"Test DataChunk result fetch in C API\", \"[capi]\") {\n \tCAPITester tester;\n \tduckdb::unique_ptr<CAPIResult> result;\n",
  "problem_statement": "[C-API] `string_t` definition is missing from `duckdb.h`\n### What happens?\r\n\r\nWhen using the data chunk API, to access the data of the Vectors, we need to cast the data pointer into a type that has the same memory layout as `duckdb::string_t`, which is defined in the C++ API, and currently not exposed to the C-API\r\n\r\nThis should also be added to the docs once it's added, since it's not super obvious what the internal representation of our VARCHAR columns is.\r\n\r\n\r\n### To Reproduce\r\n\r\n-\r\n\r\n### OS:\r\n\r\nMacOS\r\n\r\n### DuckDB Version:\r\n\r\nmaster\r\n\r\n### DuckDB Client:\r\n\r\nC-API\r\n\r\n### Full Name:\r\n\r\nThijs Bruineman\r\n\r\n### Affiliation:\r\n\r\nDuckDB Labs\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "Agreed we should add this, the `duckdb_string` that is in there is legacy used for the materialized format.\n> Agreed we should add this, the `duckdb_string` that is in there is legacy used for the materialized format.\r\n\r\nNot really sure what it should be called then, as `duckdb_string_t` is a little too close \ud83d\ude05 \r\n\r\n`duckdb_string_view` sounds promising ?\nI think `duckdb_string_t` is better to keep the consistency with the internal code-base.",
  "created_at": "2023-04-21T09:23:49Z"
}