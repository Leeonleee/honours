{
  "repo": "duckdb/duckdb",
  "pull_number": 6283,
  "instance_id": "duckdb__duckdb-6283",
  "issue_numbers": [
    "6253"
  ],
  "base_commit": "51a773a0f4e2c01eab387f4a8738cdd9b67d32c0",
  "patch": "diff --git a/data/csv/timestamp_with_tz.csv b/data/csv/timestamp_with_tz.csv\nnew file mode 100644\nindex 000000000000..b73a3f58a8ee\n--- /dev/null\n+++ b/data/csv/timestamp_with_tz.csv\n@@ -0,0 +1,3 @@\n+id,timestamps\n+1,2021-05-25 04:55:03.382494 UTC\n+2,2021-05-25 04:55:03.382494 EST\ndiff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp\nindex 70569f9dbef1..56548e5a6f8e 100644\n--- a/src/common/operator/cast_operators.cpp\n+++ b/src/common/operator/cast_operators.cpp\n@@ -1554,16 +1554,22 @@ dtime_t Cast::Operation(string_t input) {\n //===--------------------------------------------------------------------===//\n template <>\n bool TryCastErrorMessage::Operation(string_t input, timestamp_t &result, string *error_message, bool strict) {\n-\tif (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {\n+\tauto cast_result = Timestamp::TryConvertTimestamp(input.GetDataUnsafe(), input.GetSize(), result);\n+\tif (cast_result == TimestampCastResult::SUCCESS) {\n+\t\treturn true;\n+\t}\n+\tif (cast_result == TimestampCastResult::ERROR_INCORRECT_FORMAT) {\n \t\tHandleCastError::AssignError(Timestamp::ConversionError(input), error_message);\n-\t\treturn false;\n+\t} else {\n+\t\tHandleCastError::AssignError(Timestamp::UnsupportedTimezoneError(input), error_message);\n \t}\n-\treturn true;\n+\treturn false;\n }\n \n template <>\n bool TryCast::Operation(string_t input, timestamp_t &result, bool strict) {\n-\treturn Timestamp::TryConvertTimestamp(input.GetDataUnsafe(), input.GetSize(), result);\n+\treturn Timestamp::TryConvertTimestamp(input.GetDataUnsafe(), input.GetSize(), result) ==\n+\t       TimestampCastResult::SUCCESS;\n }\n \n template <>\ndiff --git a/src/common/types/time.cpp b/src/common/types/time.cpp\nindex 61231fd74e41..4656a23b3f47 100644\n--- a/src/common/types/time.cpp\n+++ b/src/common/types/time.cpp\n@@ -115,7 +115,7 @@ bool Time::TryConvertTime(const char *buf, idx_t len, idx_t &pos, dtime_t &resul\n \t\tif (!strict) {\n \t\t\t// last chance, check if we can parse as timestamp\n \t\t\ttimestamp_t timestamp;\n-\t\t\tif (Timestamp::TryConvertTimestamp(buf, len, timestamp)) {\n+\t\t\tif (Timestamp::TryConvertTimestamp(buf, len, timestamp) == TimestampCastResult::SUCCESS) {\n \t\t\t\tif (!Timestamp::IsFinite(timestamp)) {\n \t\t\t\t\treturn false;\n \t\t\t\t}\ndiff --git a/src/common/types/timestamp.cpp b/src/common/types/timestamp.cpp\nindex dd8ef0b0c284..abe51ab1a17b 100644\n--- a/src/common/types/timestamp.cpp\n+++ b/src/common/types/timestamp.cpp\n@@ -88,11 +88,27 @@ bool Timestamp::TryConvertTimestampTZ(const char *str, idx_t len, timestamp_t &r\n \treturn true;\n }\n \n-bool Timestamp::TryConvertTimestamp(const char *str, idx_t len, timestamp_t &result) {\n+TimestampCastResult Timestamp::TryConvertTimestamp(const char *str, idx_t len, timestamp_t &result) {\n \tstring_t tz(nullptr, 0);\n \tbool has_offset = false;\n \t// We don't understand TZ without an extension, so fail if one was provided.\n-\treturn TryConvertTimestampTZ(str, len, result, has_offset, tz) && !tz.GetSize();\n+\tauto success = TryConvertTimestampTZ(str, len, result, has_offset, tz);\n+\tif (!success) {\n+\t\treturn TimestampCastResult::ERROR_INCORRECT_FORMAT;\n+\t}\n+\tif (tz.GetSize() == 0) {\n+\t\t// no timezone provided - success!\n+\t\treturn TimestampCastResult::SUCCESS;\n+\t}\n+\tif (tz.GetSize() == 3) {\n+\t\t// we can ONLY handle UTC without ICU being loaded\n+\t\tauto tz_ptr = tz.GetDataUnsafe();\n+\t\tif ((tz_ptr[0] == 'u' || tz_ptr[0] == 'U') && (tz_ptr[1] == 't' || tz_ptr[1] == 'T') &&\n+\t\t    (tz_ptr[2] == 'c' || tz_ptr[2] == 'C')) {\n+\t\t\treturn TimestampCastResult::SUCCESS;\n+\t\t}\n+\t}\n+\treturn TimestampCastResult::ERROR_NON_UTC_TIMEZONE;\n }\n \n string Timestamp::ConversionError(const string &str) {\n@@ -101,16 +117,31 @@ string Timestamp::ConversionError(const string &str) {\n \t                          str);\n }\n \n+string Timestamp::UnsupportedTimezoneError(const string &str) {\n+\treturn StringUtil::Format(\"timestamp field value \\\"%s\\\" has a timestamp that is not UTC.\\nUse the TIMESTAMPTZ type \"\n+\t                          \"with the ICU extension loaded to handle non-UTC timestamps.\",\n+\t                          str);\n+}\n+\n string Timestamp::ConversionError(string_t str) {\n \treturn Timestamp::ConversionError(str.GetString());\n }\n \n+string Timestamp::UnsupportedTimezoneError(string_t str) {\n+\treturn Timestamp::UnsupportedTimezoneError(str.GetString());\n+}\n+\n timestamp_t Timestamp::FromCString(const char *str, idx_t len) {\n \ttimestamp_t result;\n-\tif (!Timestamp::TryConvertTimestamp(str, len, result)) {\n+\tauto cast_result = Timestamp::TryConvertTimestamp(str, len, result);\n+\tif (cast_result == TimestampCastResult::SUCCESS) {\n+\t\treturn result;\n+\t}\n+\tif (cast_result == TimestampCastResult::ERROR_NON_UTC_TIMEZONE) {\n+\t\tthrow ConversionException(Timestamp::UnsupportedTimezoneError(string(str, len)));\n+\t} else {\n \t\tthrow ConversionException(Timestamp::ConversionError(string(str, len)));\n \t}\n-\treturn result;\n }\n \n bool Timestamp::TryParseUTCOffset(const char *str, idx_t &pos, idx_t len, int &hour_offset, int &minute_offset) {\ndiff --git a/src/execution/operator/persistent/base_csv_reader.cpp b/src/execution/operator/persistent/base_csv_reader.cpp\nindex a6ed254ee647..636308d8bdd9 100644\n--- a/src/execution/operator/persistent/base_csv_reader.cpp\n+++ b/src/execution/operator/persistent/base_csv_reader.cpp\n@@ -30,15 +30,10 @@ string BaseCSVReader::GetLineNumberStr(idx_t linenr, bool linenr_estimated) {\n \treturn to_string(linenr + 1) + estimated;\n }\n \n-BaseCSVReader::BaseCSVReader(FileSystem &fs_p, Allocator &allocator, FileOpener *opener_p,\n-                             BufferedCSVReaderOptions options_p, const vector<LogicalType> &requested_types)\n-    : fs(fs_p), allocator(allocator), opener(opener_p), options(std::move(options_p)) {\n-}\n-\n-BaseCSVReader::BaseCSVReader(ClientContext &context, BufferedCSVReaderOptions options_p,\n+BaseCSVReader::BaseCSVReader(ClientContext &context_p, BufferedCSVReaderOptions options_p,\n                              const vector<LogicalType> &requested_types)\n-    : BaseCSVReader(FileSystem::GetFileSystem(context), Allocator::Get(context), FileSystem::GetFileOpener(context),\n-                    std::move(options_p), requested_types) {\n+    : context(context_p), fs(FileSystem::GetFileSystem(context)), allocator(Allocator::Get(context)),\n+      opener(FileSystem::GetFileOpener(context)), options(std::move(options_p)) {\n }\n \n BaseCSVReader::~BaseCSVReader() {\n@@ -144,7 +139,7 @@ bool BaseCSVReader::TryCastValue(const Value &value, const LogicalType &sql_type\n \t} else {\n \t\tValue new_value;\n \t\tstring error_message;\n-\t\treturn value.DefaultTryCastAs(sql_type, new_value, &error_message, true);\n+\t\treturn value.TryCastAs(context, sql_type, new_value, &error_message, true);\n \t}\n }\n \n@@ -481,8 +476,8 @@ bool BaseCSVReader::Flush(DataChunk &insert_chunk, bool try_add_line) {\n \t\t\t\t                                             error_message, return_types[col_idx]);\n \t\t\t} else {\n \t\t\t\t// target type is not varchar: perform a cast\n-\t\t\t\tsuccess = VectorOperations::DefaultTryCast(parse_chunk.data[col_idx], insert_chunk.data[insert_idx],\n-\t\t\t\t                                           parse_chunk.size(), &error_message);\n+\t\t\t\tsuccess = VectorOperations::TryCast(context, parse_chunk.data[col_idx], insert_chunk.data[insert_idx],\n+\t\t\t\t                                    parse_chunk.size(), &error_message);\n \t\t\t}\n \t\t\tif (success) {\n \t\t\t\tcontinue;\ndiff --git a/src/execution/operator/persistent/buffered_csv_reader.cpp b/src/execution/operator/persistent/buffered_csv_reader.cpp\nindex 84210d5323c7..bc576be0ab87 100644\n--- a/src/execution/operator/persistent/buffered_csv_reader.cpp\n+++ b/src/execution/operator/persistent/buffered_csv_reader.cpp\n@@ -23,25 +23,16 @@\n \n namespace duckdb {\n \n-BufferedCSVReader::BufferedCSVReader(FileSystem &fs_p, Allocator &allocator, FileOpener *opener_p,\n-                                     BufferedCSVReaderOptions options_p, const vector<LogicalType> &requested_types)\n-    : BaseCSVReader(fs_p, allocator, opener_p, std::move(options_p), requested_types), buffer_size(0), position(0),\n-      start(0) {\n-\tfile_handle = OpenCSV(options);\n-\tInitialize(requested_types);\n-}\n-\n BufferedCSVReader::BufferedCSVReader(ClientContext &context, BufferedCSVReaderOptions options_p,\n                                      const vector<LogicalType> &requested_types)\n-    : BufferedCSVReader(FileSystem::GetFileSystem(context), Allocator::Get(context), FileSystem::GetFileOpener(context),\n-                        std::move(options_p), requested_types) {\n+    : BaseCSVReader(context, std::move(options_p), requested_types), buffer_size(0), position(0), start(0) {\n+\tfile_handle = OpenCSV(options);\n+\tInitialize(requested_types);\n }\n \n BufferedCSVReader::BufferedCSVReader(ClientContext &context, string filename, BufferedCSVReaderOptions options_p,\n                                      const vector<LogicalType> &requested_types)\n-    : BaseCSVReader(FileSystem::GetFileSystem(context), Allocator::Get(context), FileSystem::GetFileOpener(context),\n-                    std::move(options_p), requested_types),\n-      buffer_size(0), position(0), start(0) {\n+    : BaseCSVReader(context, std::move(options_p), requested_types), buffer_size(0), position(0), start(0) {\n \toptions.file_path = std::move(filename);\n \tfile_handle = OpenCSV(options);\n \tInitialize(requested_types);\ndiff --git a/src/include/duckdb/common/types/timestamp.hpp b/src/include/duckdb/common/types/timestamp.hpp\nindex a796ba44a5f1..4065313b0060 100644\n--- a/src/include/duckdb/common/types/timestamp.hpp\n+++ b/src/include/duckdb/common/types/timestamp.hpp\n@@ -93,6 +93,8 @@ struct timestamp_ns_t : public timestamp_t {};  // NOLINT\n struct timestamp_ms_t : public timestamp_t {};  // NOLINT\n struct timestamp_sec_t : public timestamp_t {}; // NOLINT\n \n+enum class TimestampCastResult : uint8_t { SUCCESS, ERROR_INCORRECT_FORMAT, ERROR_NON_UTC_TIMEZONE };\n+\n //! The Timestamp class is a static class that holds helper functions for the Timestamp\n //! type.\n class Timestamp {\n@@ -110,7 +112,7 @@ class Timestamp {\n \t//! If the tz is not empty, the result is still an instant, but the parts can be extracted and applied to the TZ\n \tDUCKDB_API static bool TryConvertTimestampTZ(const char *str, idx_t len, timestamp_t &result, bool &has_offset,\n \t                                             string_t &tz);\n-\tDUCKDB_API static bool TryConvertTimestamp(const char *str, idx_t len, timestamp_t &result);\n+\tDUCKDB_API static TimestampCastResult TryConvertTimestamp(const char *str, idx_t len, timestamp_t &result);\n \tDUCKDB_API static timestamp_t FromCString(const char *str, idx_t len);\n \t//! Convert a date object to a string in the format \"YYYY-MM-DD hh:mm:ss\"\n \tDUCKDB_API static string ToString(timestamp_t timestamp);\n@@ -161,6 +163,8 @@ class Timestamp {\n \n \tDUCKDB_API static string ConversionError(const string &str);\n \tDUCKDB_API static string ConversionError(string_t str);\n+\tDUCKDB_API static string UnsupportedTimezoneError(const string &str);\n+\tDUCKDB_API static string UnsupportedTimezoneError(string_t str);\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/execution/operator/persistent/base_csv_reader.hpp b/src/include/duckdb/execution/operator/persistent/base_csv_reader.hpp\nindex 70d2e0d0bace..2c480cbd63c2 100644\n--- a/src/include/duckdb/execution/operator/persistent/base_csv_reader.hpp\n+++ b/src/include/duckdb/execution/operator/persistent/base_csv_reader.hpp\n@@ -35,11 +35,9 @@ class BaseCSVReader {\n public:\n \tBaseCSVReader(ClientContext &context, BufferedCSVReaderOptions options,\n \t              const vector<LogicalType> &requested_types = vector<LogicalType>());\n-\n-\tBaseCSVReader(FileSystem &fs, Allocator &allocator, FileOpener *opener, BufferedCSVReaderOptions options,\n-\t              const vector<LogicalType> &requested_types = vector<LogicalType>());\n \t~BaseCSVReader();\n \n+\tClientContext &context;\n \tFileSystem &fs;\n \tAllocator &allocator;\n \tFileOpener *opener;\ndiff --git a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\nindex e1f7790fa83f..8049b57e3b8d 100644\n--- a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\n+++ b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\n@@ -55,8 +55,6 @@ class BufferedCSVReader : public BaseCSVReader {\n public:\n \tBufferedCSVReader(ClientContext &context, BufferedCSVReaderOptions options,\n \t                  const vector<LogicalType> &requested_types = vector<LogicalType>());\n-\tBufferedCSVReader(FileSystem &fs, Allocator &allocator, FileOpener *opener, BufferedCSVReaderOptions options,\n-\t                  const vector<LogicalType> &requested_types = vector<LogicalType>());\n \tBufferedCSVReader(ClientContext &context, string filename, BufferedCSVReaderOptions options,\n \t                  const vector<LogicalType> &requested_types = vector<LogicalType>());\n \t~BufferedCSVReader();\n",
  "test_patch": "diff --git a/test/sql/copy/csv/timestamp_with_tz.test b/test/sql/copy/csv/timestamp_with_tz.test\nnew file mode 100644\nindex 000000000000..c5947dcfc8af\n--- /dev/null\n+++ b/test/sql/copy/csv/timestamp_with_tz.test\n@@ -0,0 +1,30 @@\n+# name: test/sql/copy/csv/timestamp_with_tz.test\n+# description: Test reading timestamp with timezones\n+# group: [csv]\n+\n+statement ok\n+CREATE TABLE tbl(id int, ts timestamp);\n+\n+# this fails without ICU loaded\n+statement error\n+COPY tbl FROM 'data/csv/timestamp_with_tz.csv' (HEADER)\n+----\n+timestamp that is not UTC\n+\n+require icu\n+\n+# we can load this into a timestamptz table\n+statement ok\n+CREATE TABLE tbl_tz(id int, ts timestamptz);\n+\n+statement ok\n+COPY tbl_tz FROM 'data/csv/timestamp_with_tz.csv' (HEADER)\n+\n+statement ok\n+SET TimeZone='UTC'\n+\n+query II\n+SELECT * FROM tbl_tz\n+----\n+1\t2021-05-25 04:55:03.382494+00\n+2\t2021-05-25 09:55:03.382494+00\ndiff --git a/test/sql/timezone/test_icu_calendar.test b/test/sql/timezone/test_icu_calendar.test\nindex e635c7ebf4e2..4d4901538230 100644\n--- a/test/sql/timezone/test_icu_calendar.test\n+++ b/test/sql/timezone/test_icu_calendar.test\n@@ -89,10 +89,8 @@ Reiwa\t2022-01-01 09:00:00+09\t{'era': 236, 'year': 4, 'month': 1, 'day': 1}\n statement ok\n SET CALENDAR='islamic-umalqura';\n \n-query I\n+statement ok\n SELECT strftime(TIMESTAMPTZ '-260722-3-4 0:3:52',TIMESTAMP '-285441-5-3 8:3:4');\n-----\n-285442-05-03 (BC) 08:03:04\n \n # Issue #5235\n statement ok\ndiff --git a/test/sql/types/timestamp/timestamp_timezone_cast.test b/test/sql/types/timestamp/timestamp_timezone_cast.test\nnew file mode 100644\nindex 000000000000..432b04445480\n--- /dev/null\n+++ b/test/sql/types/timestamp/timestamp_timezone_cast.test\n@@ -0,0 +1,43 @@\n+# name: test/sql/types/timestamp/timestamp_timezone_cast.test\n+# description: Test timestamp with timezones cast\n+# group: [timestamp]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# we can cast timestamps with UTC in them\n+query I\n+SELECT TIMESTAMP '2021-05-25 04:55:03.382494 UTC';\n+----\n+2021-05-25 04:55:03.382494\n+\n+query I\n+SELECT TIMESTAMP '2021-05-25 04:55:03.382494 utc';\n+----\n+2021-05-25 04:55:03.382494\n+\n+query I\n+SELECT TIMESTAMP '2021-05-25 04:55:03.382494 uTc';\n+----\n+2021-05-25 04:55:03.382494\n+\n+statement error\n+SELECT TIMESTAMP '2021-05-25 04:55:03.382494 EST';\n+----\n+has a timestamp that is not UTC\n+\n+require icu\n+\n+# FIXME: we should be able to make this work\n+statement error\n+SELECT TIMESTAMP '2021-05-25 04:55:03.382494 EST';\n+----\n+has a timestamp that is not UTC\n+\n+statement ok\n+SET TimeZone='UTC'\n+\n+query I\n+SELECT TIMESTAMPTZ '2021-05-25 04:55:03.382494 EST';\n+----\n+2021-05-25 09:55:03.382494+00\n",
  "problem_statement": "Better handling of timezones in regular varchar -> timestamp cast\nThe regular `VARCHAR -> TIMESTAMP` cast fails if timezones are provided, for example:\r\n\r\n```sql\r\nSELECT TIMESTAMP '2021-05-25 04:55:03.382494 UTC';\r\n-- Error: Conversion Error: timestamp field value out of range: \"2021-05-25 04:55:03.382494 UTC\", expected format is (YYYY-MM-DD HH:MM:SS[.US][\u00b1HH:MM| ZONE])\r\n```\r\n\r\nThe error message is not very descriptive - particularly because the string is in the right format. The error is intentional in the code - however.\r\n\r\nI suggest the following three improvements:\r\n\r\n- [ ] Always handle the TimeZone if it is UTC (just ignore it)\r\n- [ ] If there is a different TimeZone - throw an error that is more descriptive (e.g. cannot handle timezones without ICU being loaded)\r\n- [ ] If ICU is loaded it should override the `VARCHAR -> TIMESTAMP` cast, so that the regular `VARCHAR -> TIMESTAMP` cast can handle all time zones (and convert to UTC as expected)\n",
  "hints_text": "@Mytherin thanks for reporting my error in the right place \ud83d\udc4d \r\n\r\nIs there a workaround for those who run across this error (myself included)? I had issues with the `timezonetz` column type, too, as I saw several different timezones in the resulting table; however, the data is - from what I can tell - 100% UTC.\nSeems like using the `TIMEZONETZ` data type (instead of plain `TIMEZONE`) neatly solves the issue - in this case, the UTC text string is parsed neatly.\r\n\r\nAnother workaround (for my case) is to simply remove the ` UTC` text string in a find-and-replace script, using e.g. `sed`, python's `re` module, or whatever.\n> Seems like using the `TIMEZONETZ` data type (instead of plain `TIMEZONE`) neatly solves the issue - in this case, the UTC text string is parsed neatly.\r\n> \r\n> Another workaround (for my case) is to simply remove the ` UTC` text string in a find-and-replace script, using e.g. `sed`, python's `re` module, or whatever.\r\n\r\nYou can also use an explicit format string that just has `UTC` in it.",
  "created_at": "2023-02-14T16:22:07Z"
}