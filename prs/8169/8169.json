{
  "repo": "duckdb/duckdb",
  "pull_number": 8169,
  "instance_id": "duckdb__duckdb-8169",
  "issue_numbers": [
    "8124"
  ],
  "base_commit": "fef9667e6f81da0955b6303bf8b585d0b5cb04aa",
  "patch": "diff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 4c97a4fabdef..d115a2d3d7ab 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -335,6 +335,10 @@ DuckDBPyConnection::RegisterScalarUDF(const string &name, const py::function &ud\n \t}\n \tauto &context = *connection->context;\n \n+\tif (context.transaction.HasActiveTransaction()) {\n+\t\tthrow InvalidInputException(\n+\t\t    \"This function can not be called with an active transaction!, commit or abort the existing one first\");\n+\t}\n \tif (registered_functions.find(name) != registered_functions.end()) {\n \t\tthrow NotImplementedException(\"A function by the name of '%s' is already created, creating multiple \"\n \t\t                              \"functions with the same name is not supported yet, please remove it first\",\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/udf/test_scalar.py b/tools/pythonpkg/tests/fast/udf/test_scalar.py\nindex 6259182e1c96..3ea369732607 100644\n--- a/tools/pythonpkg/tests/fast/udf/test_scalar.py\n+++ b/tools/pythonpkg/tests/fast/udf/test_scalar.py\n@@ -286,3 +286,25 @@ def return_null():\n         assert rel.types[0] == data_type\n         assert rel.fetchall()[0][0] == None\n \n+    def test_udf_transaction_interaction(self):\n+        def func(x: int) -> int:\n+            return x\n+\n+        con = duckdb.connect()\n+        rel = con.sql('select 42')\n+        # Using fetchone keeps the result open, with a transaction\n+        rel.fetchone()\n+\n+        # If we would allow a UDF to be created when a transaction is active\n+        # then starting a new result-fetch would cancel the transaction\n+        # which would corrupt our internal mechanism used to check if a UDF is already registered\n+        # because that isn't transaction-aware\n+        with pytest.raises(duckdb.InvalidInputException, match='This function can not be called with an active transaction!, commit or abort the existing one first'):\n+            con.create_function('func', func)\n+\n+        # This would cancel the previous transaction, causing the function to no longer exist\n+        rel.fetchall()\n+\n+        con.create_function('func', func)\n+        res = con.sql('select func(5)').fetchall()\n+        assert res == [(5,)]\n\\ No newline at end of file\n",
  "problem_statement": "Python create_function() getting stuck after fetchone()\n### What happens?\n\nThis is within the context of using `create_function()` in a Jupyter Notebook / Interactive Python window. Honestly I am not sure whether this is intended behaviour but here goes:\r\n\r\nWhen the main module imports another module that runs duckdb's `fetchone` within its scope, the main module's `duckdb.create_function` will become stuck when one attempts to create a function. The function is never really created (?), which can be confirmed in `duckdb_functions()` + it cannot be deleted - says scalar function not found. At the same time, when you run `create_function` within the same session it says the function has already been created. Hence, stuck.\n\n### To Reproduce\n\n1. `main.py`\r\n```python\r\nimport duckdb\r\nimport some_module\r\n\r\ndef some_function() -> bool:\r\n    return True\r\n\r\nduckdb.create_function(\"some_function\", some_function)\r\nduckdb.sql(\"SELECT some_function()\").show()\r\n```\r\n\r\n2. `some_module.py`\r\n```python\r\nimport duckdb\r\n\r\nduckdb.sql(\"SELECT 123\").fetchone()[0]\r\n```\r\n\r\n3. run `main.py` (both terminal and interactive window result in error)\r\n\r\nFirst error will be:\r\n```\r\nInvalidInputException: Invalid Input Error: Attempting to execute an unsuccessful or closed pending query result\r\nError: Catalog Error: Scalar Function with name some_function does not exist!\r\nDid you mean \"second\"?\r\n```\r\n\r\nWithin the same session, running `duckdb.sql(\"SELECT some_function()\").show()` again or trying to remove the function will result in:\r\n```\r\nCatalogException: Catalog Error: Scalar Function with name some_function does not exist!\r\nDid you mean \"second\"?\r\n```\r\n\r\nWithin the same session, trying to create the function again using `duckdb.create_function(\"some_function\", some_function)` results in:\r\n```\r\nNotImplementedException: Not implemented Error: A function by the name of 'some_function' is already created, creating multiple functions with the same name is not supported yet, please remove it first\r\n```\n\n### OS:\n\nWindows 10 x64\n\n### DuckDB Version:\n\n0.8.1\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nTing Teck Pei\n\n### Affiliation:\n\nHobbyist coder\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "I would be interested to know what happens when you create different connections in the two modules.\r\n\r\nCurrently these are using the same (the default) connection.",
  "created_at": "2023-07-06T13:27:57Z"
}