You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
FATAL Error: 'Operation requires a flat vector but a non-flat vector was encountered' on CASE conditional expression
### What happens?

The latest versions of the DuckDB (latest main: v1.1.4-dev2317 a4963a5aea and released version: v1.1.3 19864453f7) crash when running the following SQL statement:

```sql
SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;
```

Here is the stack frame that triggers the Internal Error: 

```
#0  duckdb::InternalException::InternalException (this=0xaaaaea5738f0, msg="Operation requires a flat vector but a non-flat vector was encountered")
    at /home/duckdb/duckdb/src/common/exception.cpp:333
#1  0x0000aaaadb9cd190 in duckdb::FlatVector::VerifyFlatVector (vector=...) at /usr/include/c++/9/ext/new_allocator.h:80
#2  0x0000aaaadc1792b4 in duckdb::FlatVector::Validity (vector=...) at ../../src/include/duckdb/common/types/vector.hpp:361
#3  duckdb::VectorStringToMap::StringToNestedTypeCastLoop (source_data=source_data@entry=0xaaaaea550280, source_mask=..., result=..., result_mask=..., count=count@entry=1, 
    parameters=..., sel=sel@entry=0x0) at /home/duckdb/duckdb/src/function/cast/string_cast.cpp:345
#4  0x0000aaaadc216dec in duckdb::StringToNestedTypeCast<duckdb::VectorStringToMap> (count=<optimized out>, parameters=..., result=..., source=...)
    at ../../src/include/duckdb/common/types/vector.hpp:362
#5  duckdb::StringToNestedTypeCast<duckdb::VectorStringToMap> (source=..., result=..., count=<optimized out>, parameters=...)
    at /home/duckdb/duckdb/src/function/cast/string_cast.cpp:440
#6  0x0000aaaadbb54350 in duckdb::ExpressionExecutor::Execute (this=this@entry=0xffffe54a2a60, expr=..., state=state@entry=0xaaaaea54b980, sel=sel@entry=0x0, 
    count=count@entry=1, result=...) at /home/duckdb/duckdb/src/execution/expression_executor/execute_cast.cpp:42
#7  0x0000aaaadbc83f48 in duckdb::ExpressionExecutor::Execute (this=this@entry=0xffffe54a2a60, expr=..., state=0xaaaaea54b980, sel=sel@entry=0x0, count=count@entry=1, 
    result=...) at /home/duckdb/duckdb/src/execution/expression_executor.cpp:205
#8  0x0000aaaadbb567f4 in duckdb::ExpressionExecutor::Select (this=0xffffe54a2a60, expr=..., state=<optimized out>, sel=0x0, count=1, true_sel=0xaaaaea530380, 
    false_sel=0xaaaaea530398) at /usr/include/c++/9/bits/unique_ptr.h:360
#9  0x0000aaaadbc849c0 in duckdb::ExpressionExecutor::Select (false_sel=0xaaaaea530380, true_sel=0xaaaaea530380, count=1, sel=0x0, state=<optimized out>, expr=..., 
    this=0xffffe54a2a60) at ../../src/include/duckdb/parser/base_expression.hpp:98
#10 duckdb::ExpressionExecutor::Select (this=this@entry=0xffffe54a2a60, expr=..., state=<optimized out>, sel=sel@entry=0x0, count=count@entry=1, 
    true_sel=true_sel@entry=0xaaaaea530380, false_sel=false_sel@entry=0xaaaaea530398) at /home/duckdb/duckdb/src/execution/expression_executor.cpp:231
#11 0x0000aaaadbb57224 in duckdb::ExpressionExecutor::Execute (this=this@entry=0xffffe54a2a60, expr=..., state_p=state_p@entry=0xaaaaea5302d0, sel=sel@entry=0x0, 
    count=count@entry=1, result=...) at ../../src/include/duckdb/common/unique_ptr.hpp:20
#12 0x0000aaaadbc83fa8 in duckdb::ExpressionExecutor::Execute (this=0xffffe54a2a60, expr=..., state=0xaaaaea5302d0, sel=sel@entry=0x0, count=1, result=...)
    at /home/duckdb/duckdb/src/execution/expression_executor.cpp:202
#13 0x0000aaaadbc89518 in duckdb::ExpressionExecutor::ExecuteExpression (this=this@entry=0xffffe54a2a60, expr_idx=expr_idx@entry=0, result=...)
    at ../../src/include/duckdb/common/types/data_chunk.hpp:54
#14 0x0000aaaadbc896bc in duckdb::ExpressionExecutor::ExecuteExpression (this=this@entry=0xffffe54a2a60, result=...)
    at /home/duckdb/duckdb/src/execution/expression_executor.cpp:96
#15 0x0000aaaadbc89750 in duckdb::ExpressionExecutor::EvaluateScalar (context=..., expr=..., allow_unfoldable=allow_unfoldable@entry=false)
    at /home/duckdb/duckdb/src/execution/expression_executor.cpp:112
#16 0x0000aaaadbc899c8 in duckdb::ExpressionExecutor::TryEvaluateScalar (context=..., expr=..., result=...) at /home/duckdb/duckdb/src/execution/expression_executor.cpp:122
#17 0x0000aaaadbf5f2fc in duckdb::ConstantFoldingRule::Apply (this=0xaaaaea2f66c0, op=..., bindings=..., changes_made=<optimized out>, is_root=<optimized out>)
    at /home/duckdb/duckdb/src/optimizer/rule/constant_folding.cpp:36
#18 0x0000aaaadbf6ec40 in duckdb::ExpressionRewriter::ApplyRules (op=..., rules=..., expr=..., changes_made=@0xffffe54a2da7: false, is_root=is_root@entry=true)
    at /home/duckdb/duckdb/src/optimizer/expression_rewriter.cpp:20
#19 0x0000aaaadbf6f0a8 in duckdb::ExpressionRewriter::VisitExpression (this=0xffffe54a32f8, expression=0xaaaaea52eec0) at /usr/include/c++/9/bits/move.h:74
#20 0x0000aaaadc0657b8 in std::function<void (duckdb::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression>, true>*)>::operator()(duckdb::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression>, true>*) const (__args#0=<optimized out>, this=0xffffe54a2ed8) at /usr/include/c++/9/bits/std_function.h:683
#21 duckdb::LogicalOperatorVisitor::EnumerateExpressions(duckdb::LogicalOperator&, std::function<void (duckdb::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression>, true>*)> const&) (op=..., callback=...) at /home/duckdb/duckdb/src/planner/logical_operator_visitor.cpp:175
#22 0x0000aaaadc065b7c in duckdb::LogicalOperatorVisitor::VisitOperatorExpressions (this=this@entry=0xffffe54a32f8, op=...) at /usr/include/c++/9/new:174
#23 0x0000aaaadbf6b8c8 in duckdb::ExpressionRewriter::VisitOperator (this=0xffffe54a32f8, op=...) at /home/duckdb/duckdb/src/optimizer/expression_rewriter.cpp:68
#24 0x0000aaaadc07341c in duckdb::LogicalOperatorVisitor::VisitOperatorChildren (op=..., this=0xffffe54a32f8) at ../../src/include/duckdb/common/unique_ptr.hpp:20
#25 duckdb::LogicalOperatorVisitor::VisitOperatorChildren (this=this@entry=0xffffe54a32f8, op=...) at /home/duckdb/duckdb/src/planner/logical_operator_visitor.cpp:14
#26 0x0000aaaadbf6b788 in duckdb::ExpressionRewriter::VisitOperator (this=0xffffe54a32f8, op=...) at /home/duckdb/duckdb/src/optimizer/expression_rewriter.cpp:60
#27 0x0000aaaadbf6ba34 in duckdb::Optimizer::<lambda()>::operator() (__closure=<optimized out>) at ../../src/include/duckdb/common/unique_ptr.hpp:20
#28 std::_Function_handler<void(), duckdb::Optimizer::RunBuiltInOptimizers()::<lambda()> >::_M_invoke(const std::_Any_data &) (__functor=...)
    at /usr/include/c++/9/bits/std_function.h:300
#29 0x0000aaaadbf6c624 in std::function<void ()>::operator()() const (this=0xffffe54a31a8) at /usr/include/c++/9/bits/std_function.h:683
#30 duckdb::Optimizer::RunOptimizer(duckdb::OptimizerType, std::function<void ()> const&) (callback=..., type=duckdb::OptimizerType::EXPRESSION_REWRITER, 
    this=0xffffe54a32e8) at /home/duckdb/duckdb/src/optimizer/optimizer.cpp:80
#31 duckdb::Optimizer::RunOptimizer(duckdb::OptimizerType, std::function<void ()> const&) (this=0xffffe54a32e8, type=duckdb::OptimizerType::EXPRESSION_REWRITER, 
    callback=...) at /home/duckdb/duckdb/src/optimizer/optimizer.cpp:73
#32 0x0000aaaadbf6dc78 in duckdb::Optimizer::RunBuiltInOptimizers (this=this@entry=0xffffe54a32e8) at /usr/include/c++/9/new:174
#33 0x0000aaaadbf6e6b0 in duckdb::Optimizer::Optimize (this=this@entry=0xffffe54a32e8, plan_p=...) at /home/duckdb/duckdb/src/optimizer/optimizer.cpp:253
#34 0x0000aaaadbd75a50 in duckdb::ClientContext::CreatePreparedStatementInternal (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", statement=..., values=values@entry=...) at /usr/include/c++/9/bits/move.h:74
#35 0x0000aaaadbd76108 in duckdb::ClientContext::CreatePreparedStatement (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", statement=..., values=..., 
    mode=mode@entry=duckdb::PreparedStatementMode::PREPARE_ONLY) at /usr/include/c++/9/bits/move.h:74
#36 0x0000aaaadbd76550 in duckdb::ClientContext::RebindPreparedStatement (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", prepared=..., parameters=...) at /usr/include/c++/9/bits/unique_ptr.h:360
#37 0x0000aaaadbd777b8 in duckdb::ClientContext::PendingPreparedStatement (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", prepared=..., parameters=...)
    at /home/duckdb/duckdb/src/main/client_context.cpp:544
#38 0x0000aaaadbd7802c in duckdb::ClientContext::PendingStatementOrPreparedStatement (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", statement=..., prepared=..., parameters=...)
    at /usr/include/c++/9/ext/atomicity.h:96
#39 0x0000aaaadbd79400 in duckdb::ClientContext::PendingStatementOrPreparedStatementInternal (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", statement=..., prepared=..., parameters=...)
    at /usr/include/c++/9/bits/move.h:74
#40 0x0000aaaadbd79724 in duckdb::ClientContext::PendingQueryPreparedInternal (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", prepared=..., parameters=...) at /usr/include/c++/9/tuple:918
#41 0x0000aaaadbd79864 in duckdb::ClientContext::PendingQuery (this=this@entry=0xaaaaea3954e0, 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", prepared=..., parameters=...)
    at ../../src/include/duckdb/common/unique_ptr.hpp:20
#42 0x0000aaaadbd79a80 in duckdb::PreparedStatement::PendingQuery (this=this@entry=0xaaaaea379bf0, named_values=std::unordered_map with 1 element = {...}, 
    allow_stream_result=allow_stream_result@entry=false) at ../../src/include/duckdb/common/shared_ptr_ipp.hpp:204
#43 0x0000aaaadbd79fa4 in duckdb::PreparedStatement::PendingQuery (this=0xaaaaea379bf0, values=..., allow_stream_result=allow_stream_result@entry=false)
    at /home/duckdb/duckdb/src/main/prepared_statement.cpp:94
#44 0x0000aaaadbd7a210 in duckdb::PreparedStatement::Execute (this=<optimized out>, values=..., allow_stream_result=allow_stream_result@entry=false)
    at /home/duckdb/duckdb/src/main/prepared_statement.cpp:81
#45 0x0000aaaadb8a55fc in duckdb_shell_sqlite3_print_duckbox (pStmt=0xaaaaea52ac70, max_rows=40, max_width=0, null_value=0xffffe54a4948 "NULL", columnar=0, 
    thousand_separator=0 '\000', decimal_separator=0 '\000', result_renderer=0xffffe54a4530) at ../../src/include/duckdb/common/unique_ptr.hpp:39
#46 0x0000aaaadb895dfc in duckdb_shell::ShellState::ExecutePreparedStatement (this=0xffffe54a4840, pStmt=0xaaaaea52ac70) at /usr/include/c++/9/bits/basic_string.h:2304
#47 0x0000aaaadb896384 in duckdb_shell::ShellState::ExecuteSQL (this=0xffffe54a4840, 
    zSql=0xaaaaea2f2f10 "SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", pzErrMsg=0xffffe54a4660) at ../../tools/shell/shell.cpp:1788
#48 0x0000aaaadb896c74 in duckdb_shell::ShellState::RunOneSqlLine (this=0xffffe54a4840, 
    zSql=0xaaaaea2f2f10 "SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;") at ../../tools/shell/shell.cpp:4318
#49 0x0000aaaadb897298 in duckdb_shell::ShellState::ProcessInput (this=0xffffe54a4840) at ../../tools/shell/shell.cpp:4433
#50 0x0000aaaadb87bd9c in main (argc=<optimized out>, argv=0xffffe54a4b28) at ../../tools/shell/shell.cpp:5032
```

### To Reproduce

1. Clone the DuckDB Git from the official repo.
2. Checkout to the latest main (v1.1.4-dev2317 a4963a5aea).
3. Compile the DuckDB binary by using `CORE_EXTENSIONS='autocomplete;httpfs;icu;parquet;json' GEN=ninja make debug`.
4. Run the compiled DuckDB and input the following SQL:

```sql
SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;
```

### OS:

Ubuntu 24.04.01 LTS (x86-64 & aarch64)

### DuckDB Version:

v1.1.3 19864453f7 and v1.1.4-dev2317 a4963a5aea

### DuckDB Client:

cli

### Hardware:

_No response_

### Full Name:

Yu Liang

### Affiliation:

The Pennsylvania State University

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
FATAL Error: 'Operation requires a flat vector but a non-flat vector was encountered' on CASE conditional expression
### What happens?

The latest versions of the DuckDB (latest main: v1.1.4-dev2317 a4963a5aea and released version: v1.1.3 19864453f7) crash when running the following SQL statement:

```sql
SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;
```

Here is the stack frame that triggers the Internal Error: 

```
#0  duckdb::InternalException::InternalException (this=0xaaaaea5738f0, msg="Operation requires a flat vector but a non-flat vector was encountered")
    at /home/duckdb/duckdb/src/common/exception.cpp:333
#1  0x0000aaaadb9cd190 in duckdb::FlatVector::VerifyFlatVector (vector=...) at /usr/include/c++/9/ext/new_allocator.h:80
#2  0x0000aaaadc1792b4 in duckdb::FlatVector::Validity (vector=...) at ../../src/include/duckdb/common/types/vector.hpp:361
#3  duckdb::VectorStringToMap::StringToNestedTypeCastLoop (source_data=source_data@entry=0xaaaaea550280, source_mask=..., result=..., result_mask=..., count=count@entry=1, 
    parameters=..., sel=sel@entry=0x0) at /home/duckdb/duckdb/src/function/cast/string_cast.cpp:345
#4  0x0000aaaadc216dec in duckdb::StringToNestedTypeCast<duckdb::VectorStringToMap> (count=<optimized out>, parameters=..., result=..., source=...)
    at ../../src/include/duckdb/common/types/vector.hpp:362
#5  duckdb::StringToNestedTypeCast<duckdb::VectorStringToMap> (source=..., result=..., count=<optimized out>, parameters=...)
    at /home/duckdb/duckdb/src/function/cast/string_cast.cpp:440
#6  0x0000aaaadbb54350 in duckdb::ExpressionExecutor::Execute (this=this@entry=0xffffe54a2a60, expr=..., state=state@entry=0xaaaaea54b980, sel=sel@entry=0x0, 
    count=count@entry=1, result=...) at /home/duckdb/duckdb/src/execution/expression_executor/execute_cast.cpp:42
#7  0x0000aaaadbc83f48 in duckdb::ExpressionExecutor::Execute (this=this@entry=0xffffe54a2a60, expr=..., state=0xaaaaea54b980, sel=sel@entry=0x0, count=count@entry=1, 
    result=...) at /home/duckdb/duckdb/src/execution/expression_executor.cpp:205
#8  0x0000aaaadbb567f4 in duckdb::ExpressionExecutor::Select (this=0xffffe54a2a60, expr=..., state=<optimized out>, sel=0x0, count=1, true_sel=0xaaaaea530380, 
    false_sel=0xaaaaea530398) at /usr/include/c++/9/bits/unique_ptr.h:360
#9  0x0000aaaadbc849c0 in duckdb::ExpressionExecutor::Select (false_sel=0xaaaaea530380, true_sel=0xaaaaea530380, count=1, sel=0x0, state=<optimized out>, expr=..., 
    this=0xffffe54a2a60) at ../../src/include/duckdb/parser/base_expression.hpp:98
#10 duckdb::ExpressionExecutor::Select (this=this@entry=0xffffe54a2a60, expr=..., state=<optimized out>, sel=sel@entry=0x0, count=count@entry=1, 
    true_sel=true_sel@entry=0xaaaaea530380, false_sel=false_sel@entry=0xaaaaea530398) at /home/duckdb/duckdb/src/execution/expression_executor.cpp:231
#11 0x0000aaaadbb57224 in duckdb::ExpressionExecutor::Execute (this=this@entry=0xffffe54a2a60, expr=..., state_p=state_p@entry=0xaaaaea5302d0, sel=sel@entry=0x0, 
    count=count@entry=1, result=...) at ../../src/include/duckdb/common/unique_ptr.hpp:20
#12 0x0000aaaadbc83fa8 in duckdb::ExpressionExecutor::Execute (this=0xffffe54a2a60, expr=..., state=0xaaaaea5302d0, sel=sel@entry=0x0, count=1, result=...)
    at /home/duckdb/duckdb/src/execution/expression_executor.cpp:202
#13 0x0000aaaadbc89518 in duckdb::ExpressionExecutor::ExecuteExpression (this=this@entry=0xffffe54a2a60, expr_idx=expr_idx@entry=0, result=...)
    at ../../src/include/duckdb/common/types/data_chunk.hpp:54
#14 0x0000aaaadbc896bc in duckdb::ExpressionExecutor::ExecuteExpression (this=this@entry=0xffffe54a2a60, result=...)
    at /home/duckdb/duckdb/src/execution/expression_executor.cpp:96
#15 0x0000aaaadbc89750 in duckdb::ExpressionExecutor::EvaluateScalar (context=..., expr=..., allow_unfoldable=allow_unfoldable@entry=false)
    at /home/duckdb/duckdb/src/execution/expression_executor.cpp:112
#16 0x0000aaaadbc899c8 in duckdb::ExpressionExecutor::TryEvaluateScalar (context=..., expr=..., result=...) at /home/duckdb/duckdb/src/execution/expression_executor.cpp:122
#17 0x0000aaaadbf5f2fc in duckdb::ConstantFoldingRule::Apply (this=0xaaaaea2f66c0, op=..., bindings=..., changes_made=<optimized out>, is_root=<optimized out>)
    at /home/duckdb/duckdb/src/optimizer/rule/constant_folding.cpp:36
#18 0x0000aaaadbf6ec40 in duckdb::ExpressionRewriter::ApplyRules (op=..., rules=..., expr=..., changes_made=@0xffffe54a2da7: false, is_root=is_root@entry=true)
    at /home/duckdb/duckdb/src/optimizer/expression_rewriter.cpp:20
#19 0x0000aaaadbf6f0a8 in duckdb::ExpressionRewriter::VisitExpression (this=0xffffe54a32f8, expression=0xaaaaea52eec0) at /usr/include/c++/9/bits/move.h:74
#20 0x0000aaaadc0657b8 in std::function<void (duckdb::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression>, true>*)>::operator()(duckdb::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression>, true>*) const (__args#0=<optimized out>, this=0xffffe54a2ed8) at /usr/include/c++/9/bits/std_function.h:683
#21 duckdb::LogicalOperatorVisitor::EnumerateExpressions(duckdb::LogicalOperator&, std::function<void (duckdb::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression>, true>*)> const&) (op=..., callback=...) at /home/duckdb/duckdb/src/planner/logical_operator_visitor.cpp:175
#22 0x0000aaaadc065b7c in duckdb::LogicalOperatorVisitor::VisitOperatorExpressions (this=this@entry=0xffffe54a32f8, op=...) at /usr/include/c++/9/new:174
#23 0x0000aaaadbf6b8c8 in duckdb::ExpressionRewriter::VisitOperator (this=0xffffe54a32f8, op=...) at /home/duckdb/duckdb/src/optimizer/expression_rewriter.cpp:68
#24 0x0000aaaadc07341c in duckdb::LogicalOperatorVisitor::VisitOperatorChildren (op=..., this=0xffffe54a32f8) at ../../src/include/duckdb/common/unique_ptr.hpp:20
#25 duckdb::LogicalOperatorVisitor::VisitOperatorChildren (this=this@entry=0xffffe54a32f8, op=...) at /home/duckdb/duckdb/src/planner/logical_operator_visitor.cpp:14
#26 0x0000aaaadbf6b788 in duckdb::ExpressionRewriter::VisitOperator (this=0xffffe54a32f8, op=...) at /home/duckdb/duckdb/src/optimizer/expression_rewriter.cpp:60
#27 0x0000aaaadbf6ba34 in duckdb::Optimizer::<lambda()>::operator() (__closure=<optimized out>) at ../../src/include/duckdb/common/unique_ptr.hpp:20
#28 std::_Function_handler<void(), duckdb::Optimizer::RunBuiltInOptimizers()::<lambda()> >::_M_invoke(const std::_Any_data &) (__functor=...)
    at /usr/include/c++/9/bits/std_function.h:300
#29 0x0000aaaadbf6c624 in std::function<void ()>::operator()() const (this=0xffffe54a31a8) at /usr/include/c++/9/bits/std_function.h:683
#30 duckdb::Optimizer::RunOptimizer(duckdb::OptimizerType, std::function<void ()> const&) (callback=..., type=duckdb::OptimizerType::EXPRESSION_REWRITER, 
    this=0xffffe54a32e8) at /home/duckdb/duckdb/src/optimizer/optimizer.cpp:80
#31 duckdb::Optimizer::RunOptimizer(duckdb::OptimizerType, std::function<void ()> const&) (this=0xffffe54a32e8, type=duckdb::OptimizerType::EXPRESSION_REWRITER, 
    callback=...) at /home/duckdb/duckdb/src/optimizer/optimizer.cpp:73
#32 0x0000aaaadbf6dc78 in duckdb::Optimizer::RunBuiltInOptimizers (this=this@entry=0xffffe54a32e8) at /usr/include/c++/9/new:174
#33 0x0000aaaadbf6e6b0 in duckdb::Optimizer::Optimize (this=this@entry=0xffffe54a32e8, plan_p=...) at /home/duckdb/duckdb/src/optimizer/optimizer.cpp:253
#34 0x0000aaaadbd75a50 in duckdb::ClientContext::CreatePreparedStatementInternal (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", statement=..., values=values@entry=...) at /usr/include/c++/9/bits/move.h:74
#35 0x0000aaaadbd76108 in duckdb::ClientContext::CreatePreparedStatement (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", statement=..., values=..., 
    mode=mode@entry=duckdb::PreparedStatementMode::PREPARE_ONLY) at /usr/include/c++/9/bits/move.h:74
#36 0x0000aaaadbd76550 in duckdb::ClientContext::RebindPreparedStatement (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", prepared=..., parameters=...) at /usr/include/c++/9/bits/unique_ptr.h:360
#37 0x0000aaaadbd777b8 in duckdb::ClientContext::PendingPreparedStatement (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", prepared=..., parameters=...)
    at /home/duckdb/duckdb/src/main/client_context.cpp:544
#38 0x0000aaaadbd7802c in duckdb::ClientContext::PendingStatementOrPreparedStatement (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", statement=..., prepared=..., parameters=...)
    at /usr/include/c++/9/ext/atomicity.h:96
#39 0x0000aaaadbd79400 in duckdb::ClientContext::PendingStatementOrPreparedStatementInternal (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", statement=..., prepared=..., parameters=...)
    at /usr/include/c++/9/bits/move.h:74
#40 0x0000aaaadbd79724 in duckdb::ClientContext::PendingQueryPreparedInternal (this=this@entry=0xaaaaea3954e0, lock=..., 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", prepared=..., parameters=...) at /usr/include/c++/9/tuple:918
#41 0x0000aaaadbd79864 in duckdb::ClientContext::PendingQuery (this=this@entry=0xaaaaea3954e0, 
    query="SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", prepared=..., parameters=...)
    at ../../src/include/duckdb/common/unique_ptr.hpp:20
#42 0x0000aaaadbd79a80 in duckdb::PreparedStatement::PendingQuery (this=this@entry=0xaaaaea379bf0, named_values=std::unordered_map with 1 element = {...}, 
    allow_stream_result=allow_stream_result@entry=false) at ../../src/include/duckdb/common/shared_ptr_ipp.hpp:204
#43 0x0000aaaadbd79fa4 in duckdb::PreparedStatement::PendingQuery (this=0xaaaaea379bf0, values=..., allow_stream_result=allow_stream_result@entry=false)
    at /home/duckdb/duckdb/src/main/prepared_statement.cpp:94
#44 0x0000aaaadbd7a210 in duckdb::PreparedStatement::Execute (this=<optimized out>, values=..., allow_stream_result=allow_stream_result@entry=false)
    at /home/duckdb/duckdb/src/main/prepared_statement.cpp:81
#45 0x0000aaaadb8a55fc in duckdb_shell_sqlite3_print_duckbox (pStmt=0xaaaaea52ac70, max_rows=40, max_width=0, null_value=0xffffe54a4948 "NULL", columnar=0, 
    thousand_separator=0 '\000', decimal_separator=0 '\000', result_renderer=0xffffe54a4530) at ../../src/include/duckdb/common/unique_ptr.hpp:39
#46 0x0000aaaadb895dfc in duckdb_shell::ShellState::ExecutePreparedStatement (this=0xffffe54a4840, pStmt=0xaaaaea52ac70) at /usr/include/c++/9/bits/basic_string.h:2304
#47 0x0000aaaadb896384 in duckdb_shell::ShellState::ExecuteSQL (this=0xffffe54a4840, 
    zSql=0xaaaaea2f2f10 "SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;", pzErrMsg=0xffffe54a4660) at ../../tools/shell/shell.cpp:1788
#48 0x0000aaaadb896c74 in duckdb_shell::ShellState::RunOneSqlLine (this=0xffffe54a4840, 
    zSql=0xaaaaea2f2f10 "SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;") at ../../tools/shell/shell.cpp:4318
#49 0x0000aaaadb897298 in duckdb_shell::ShellState::ProcessInput (this=0xffffe54a4840) at ../../tools/shell/shell.cpp:4433
#50 0x0000aaaadb87bd9c in main (argc=<optimized out>, argv=0xffffe54a4b28) at ../../tools/shell/shell.cpp:5032
```

### To Reproduce

1. Clone the DuckDB Git from the official repo.
2. Checkout to the latest main (v1.1.4-dev2317 a4963a5aea).
3. Compile the DuckDB binary by using `CORE_EXTENSIONS='autocomplete;httpfs;icu;parquet;json' GEN=ninja make debug`.
4. Run the compiled DuckDB and input the following SQL:

```sql
SELECT TRUE WHERE CASE MAP { } WHEN 'abc' [ 'any_string' IN ? : ] THEN TRUE END ;
```

### OS:

Ubuntu 24.04.01 LTS (x86-64 & aarch64)

### DuckDB Version:

v1.1.3 19864453f7 and v1.1.4-dev2317 a4963a5aea

### DuckDB Client:

cli

### Hardware:

_No response_

### Full Name:

Yu Liang

### Affiliation:

The Pennsylvania State University

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/function/cast/string_cast.cpp]
1: #include "duckdb/function/cast/default_casts.hpp"
2: #include "duckdb/function/cast/vector_cast_helpers.hpp"
3: #include "duckdb/common/exception/conversion_exception.hpp"
4: #include "duckdb/common/numeric_utils.hpp"
5: #include "duckdb/common/pair.hpp"
6: #include "duckdb/common/vector.hpp"
7: #include "duckdb/function/scalar/nested_functions.hpp"
8: #include "duckdb/function/cast/bound_cast_data.hpp"
9: #include "duckdb/common/types/varint.hpp"
10: 
11: namespace duckdb {
12: 
13: template <class T>
14: bool StringEnumCastLoop(const string_t *source_data, ValidityMask &source_mask, const LogicalType &source_type,
15:                         T *result_data, ValidityMask &result_mask, const LogicalType &result_type, idx_t count,
16:                         VectorTryCastData &vector_cast_data, const SelectionVector *sel) {
17: 	for (idx_t i = 0; i < count; i++) {
18: 		idx_t source_idx = i;
19: 		if (sel) {
20: 			source_idx = sel->get_index(i);
21: 		}
22: 		if (source_mask.RowIsValid(source_idx)) {
23: 			auto pos = EnumType::GetPos(result_type, source_data[source_idx]);
24: 			if (pos == -1) {
25: 				result_data[i] = HandleVectorCastError::Operation<T>(
26: 				    CastExceptionText<string_t, T>(source_data[source_idx]), result_mask, i, vector_cast_data);
27: 			} else {
28: 				result_data[i] = UnsafeNumericCast<T>(pos);
29: 			}
30: 		} else {
31: 			result_mask.SetInvalid(i);
32: 		}
33: 	}
34: 	return vector_cast_data.all_converted;
35: }
36: 
37: template <class T>
38: bool StringEnumCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {
39: 	D_ASSERT(source.GetType().id() == LogicalTypeId::VARCHAR);
40: 	switch (source.GetVectorType()) {
41: 	case VectorType::CONSTANT_VECTOR: {
42: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
43: 
44: 		auto source_data = ConstantVector::GetData<string_t>(source);
45: 		auto source_mask = ConstantVector::Validity(source);
46: 		auto result_data = ConstantVector::GetData<T>(result);
47: 		auto &result_mask = ConstantVector::Validity(result);
48: 
49: 		VectorTryCastData vector_cast_data(result, parameters);
50: 		return StringEnumCastLoop(source_data, source_mask, source.GetType(), result_data, result_mask,
51: 		                          result.GetType(), 1, vector_cast_data, nullptr);
52: 	}
53: 	default: {
54: 		UnifiedVectorFormat vdata;
55: 		source.ToUnifiedFormat(count, vdata);
56: 
57: 		result.SetVectorType(VectorType::FLAT_VECTOR);
58: 
59: 		auto source_data = UnifiedVectorFormat::GetData<string_t>(vdata);
60: 		auto source_sel = vdata.sel;
61: 		auto source_mask = vdata.validity;
62: 		auto result_data = FlatVector::GetData<T>(result);
63: 		auto &result_mask = FlatVector::Validity(result);
64: 
65: 		VectorTryCastData vector_cast_data(result, parameters);
66: 		return StringEnumCastLoop(source_data, source_mask, source.GetType(), result_data, result_mask,
67: 		                          result.GetType(), count, vector_cast_data, source_sel);
68: 	}
69: 	}
70: }
71: 
72: static BoundCastInfo VectorStringCastNumericSwitch(BindCastInput &input, const LogicalType &source,
73:                                                    const LogicalType &target) {
74: 	// now switch on the result type
75: 	switch (target.id()) {
76: 	case LogicalTypeId::ENUM: {
77: 		switch (target.InternalType()) {
78: 		case PhysicalType::UINT8:
79: 			return StringEnumCast<uint8_t>;
80: 		case PhysicalType::UINT16:
81: 			return StringEnumCast<uint16_t>;
82: 		case PhysicalType::UINT32:
83: 			return StringEnumCast<uint32_t>;
84: 		default:
85: 			throw InternalException("ENUM can only have unsigned integers (except UINT64) as physical types");
86: 		}
87: 	}
88: 	case LogicalTypeId::BOOLEAN:
89: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, bool, duckdb::TryCast>);
90: 	case LogicalTypeId::TINYINT:
91: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, int8_t, duckdb::TryCast>);
92: 	case LogicalTypeId::SMALLINT:
93: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, int16_t, duckdb::TryCast>);
94: 	case LogicalTypeId::INTEGER:
95: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, int32_t, duckdb::TryCast>);
96: 	case LogicalTypeId::BIGINT:
97: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, int64_t, duckdb::TryCast>);
98: 	case LogicalTypeId::UTINYINT:
99: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, uint8_t, duckdb::TryCast>);
100: 	case LogicalTypeId::USMALLINT:
101: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, uint16_t, duckdb::TryCast>);
102: 	case LogicalTypeId::UINTEGER:
103: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, uint32_t, duckdb::TryCast>);
104: 	case LogicalTypeId::UBIGINT:
105: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, uint64_t, duckdb::TryCast>);
106: 	case LogicalTypeId::HUGEINT:
107: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, hugeint_t, duckdb::TryCast>);
108: 	case LogicalTypeId::UHUGEINT:
109: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, uhugeint_t, duckdb::TryCast>);
110: 	case LogicalTypeId::FLOAT:
111: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, float, duckdb::TryCast>);
112: 	case LogicalTypeId::DOUBLE:
113: 		return BoundCastInfo(&VectorCastHelpers::TryCastStrictLoop<string_t, double, duckdb::TryCast>);
114: 	case LogicalTypeId::INTERVAL:
115: 		return BoundCastInfo(&VectorCastHelpers::TryCastErrorLoop<string_t, interval_t, duckdb::TryCastErrorMessage>);
116: 	case LogicalTypeId::DECIMAL:
117: 		return BoundCastInfo(&VectorCastHelpers::ToDecimalCast<string_t>);
118: 	default:
119: 		return DefaultCasts::TryVectorNullCast;
120: 	}
121: }
122: 
123: //===--------------------------------------------------------------------===//
124: // string -> list casting
125: //===--------------------------------------------------------------------===//
126: bool VectorStringToList::StringToNestedTypeCastLoop(const string_t *source_data, ValidityMask &source_mask,
127:                                                     Vector &result, ValidityMask &result_mask, idx_t count,
128:                                                     CastParameters &parameters, const SelectionVector *sel) {
129: 	idx_t total_list_size = 0;
130: 	for (idx_t i = 0; i < count; i++) {
131: 		idx_t idx = i;
132: 		if (sel) {
133: 			idx = sel->get_index(i);
134: 		}
135: 		if (!source_mask.RowIsValid(idx)) {
136: 			continue;
137: 		}
138: 		total_list_size += VectorStringToList::CountPartsList(source_data[idx]);
139: 	}
140: 
141: 	Vector varchar_vector(LogicalType::VARCHAR, total_list_size);
142: 
143: 	ListVector::Reserve(result, total_list_size);
144: 	ListVector::SetListSize(result, total_list_size);
145: 
146: 	auto list_data = ListVector::GetData(result);
147: 	auto child_data = FlatVector::GetData<string_t>(varchar_vector);
148: 
149: 	VectorTryCastData vector_cast_data(result, parameters);
150: 	idx_t total = 0;
151: 	for (idx_t i = 0; i < count; i++) {
152: 		idx_t idx = i;
153: 		if (sel) {
154: 			idx = sel->get_index(i);
155: 		}
156: 		if (!source_mask.RowIsValid(idx)) {
157: 			result_mask.SetInvalid(i);
158: 			continue;
159: 		}
160: 
161: 		list_data[i].offset = total;
162: 		if (!VectorStringToList::SplitStringList(source_data[idx], child_data, total, varchar_vector)) {
163: 			string text = "Type VARCHAR with value '" + source_data[idx].GetString() +
164: 			              "' can't be cast to the destination type LIST";
165: 			HandleVectorCastError::Operation<string_t>(text, result_mask, i, vector_cast_data);
166: 		}
167: 		list_data[i].length = total - list_data[i].offset; // length is the amount of parts coming from this string
168: 	}
169: 	D_ASSERT(total_list_size == total);
170: 
171: 	auto &result_child = ListVector::GetEntry(result);
172: 	auto &cast_data = parameters.cast_data->Cast<ListBoundCastData>();
173: 	CastParameters child_parameters(parameters, cast_data.child_cast_info.cast_data, parameters.local_state);
174: 	bool all_converted =
175: 	    cast_data.child_cast_info.function(varchar_vector, result_child, total_list_size, child_parameters) &&
176: 	    vector_cast_data.all_converted;
177: 	if (!all_converted && parameters.nullify_parent) {
178: 		UnifiedVectorFormat inserted_column_data;
179: 		result_child.ToUnifiedFormat(total_list_size, inserted_column_data);
180: 		UnifiedVectorFormat parse_column_data;
181: 		varchar_vector.ToUnifiedFormat(total_list_size, parse_column_data);
182: 		// Something went wrong in the conversion, we need to nullify the parent
183: 		for (idx_t i = 0; i < count; i++) {
184: 			for (idx_t j = list_data[i].offset; j < list_data[i].offset + list_data[i].length; j++) {
185: 				if (!inserted_column_data.validity.RowIsValid(j) && parse_column_data.validity.RowIsValid(j)) {
186: 					result_mask.SetInvalid(i);
187: 					break;
188: 				}
189: 			}
190: 		}
191: 	}
192: 	return all_converted;
193: }
194: 
195: static LogicalType InitVarcharStructType(const LogicalType &target) {
196: 	child_list_t<LogicalType> child_types;
197: 	for (auto &child : StructType::GetChildTypes(target)) {
198: 		child_types.push_back(make_pair(child.first, LogicalType::VARCHAR));
199: 	}
200: 
201: 	return LogicalType::STRUCT(child_types);
202: }
203: 
204: //===--------------------------------------------------------------------===//
205: // string -> struct casting
206: //===--------------------------------------------------------------------===//
207: bool VectorStringToStruct::StringToNestedTypeCastLoop(const string_t *source_data, ValidityMask &source_mask,
208:                                                       Vector &result, ValidityMask &result_mask, idx_t count,
209:                                                       CastParameters &parameters, const SelectionVector *sel) {
210: 	auto varchar_struct_type = InitVarcharStructType(result.GetType());
211: 	Vector varchar_vector(varchar_struct_type, count);
212: 	auto &child_vectors = StructVector::GetEntries(varchar_vector);
213: 	auto &result_children = StructVector::GetEntries(result);
214: 	auto is_unnamed = StructType::IsUnnamed(result.GetType());
215: 
216: 	string_map_t<idx_t> child_names;
217: 	vector<reference<ValidityMask>> child_masks;
218: 	for (idx_t child_idx = 0; child_idx < result_children.size(); child_idx++) {
219: 		if (!is_unnamed) {
220: 			child_names.insert({StructType::GetChildName(result.GetType(), child_idx), child_idx});
221: 		}
222: 		child_masks.emplace_back(FlatVector::Validity(*child_vectors[child_idx]));
223: 		child_masks[child_idx].get().SetAllInvalid(count);
224: 	}
225: 
226: 	VectorTryCastData vector_cast_data(result, parameters);
227: 	for (idx_t i = 0; i < count; i++) {
228: 		idx_t idx = i;
229: 		if (sel) {
230: 			idx = sel->get_index(i);
231: 		}
232: 		if (!source_mask.RowIsValid(idx)) {
233: 			result_mask.SetInvalid(i);
234: 			continue;
235: 		}
236: 		if (is_unnamed) {
237: 			throw ConversionException("Casting strings to unnamed structs is unsupported");
238: 		}
239: 		if (!VectorStringToStruct::SplitStruct(source_data[idx], child_vectors, i, child_names, child_masks)) {
240: 			string text = "Type VARCHAR with value '" + source_data[idx].GetString() +
241: 			              "' can't be cast to the destination type STRUCT";
242: 			for (auto &child_mask : child_masks) {
243: 				child_mask.get().SetInvalid(i); // some values may have already been found and set valid
244: 			}
245: 			HandleVectorCastError::Operation<string_t>(text, result_mask, i, vector_cast_data);
246: 		}
247: 	}
248: 
249: 	auto &cast_data = parameters.cast_data->Cast<StructBoundCastData>();
250: 	auto &lstate = parameters.local_state->Cast<StructCastLocalState>();
251: 	D_ASSERT(cast_data.child_cast_info.size() == result_children.size());
252: 
253: 	for (idx_t child_idx = 0; child_idx < result_children.size(); child_idx++) {
254: 		auto &child_varchar_vector = *child_vectors[child_idx];
255: 		auto &result_child_vector = *result_children[child_idx];
256: 		auto &child_cast_info = cast_data.child_cast_info[child_idx];
257: 		CastParameters child_parameters(parameters, child_cast_info.cast_data, lstate.local_states[child_idx]);
258: 		if (!child_cast_info.function(child_varchar_vector, result_child_vector, count, child_parameters)) {
259: 			vector_cast_data.all_converted = false;
260: 		}
261: 	}
262: 	return vector_cast_data.all_converted;
263: }
264: 
265: //===--------------------------------------------------------------------===//
266: // string -> map casting
267: //===--------------------------------------------------------------------===//
268: unique_ptr<FunctionLocalState> InitMapCastLocalState(CastLocalStateParameters &parameters) {
269: 	auto &cast_data = parameters.cast_data->Cast<MapBoundCastData>();
270: 	auto result = make_uniq<MapCastLocalState>();
271: 
272: 	if (cast_data.key_cast.init_local_state) {
273: 		CastLocalStateParameters child_params(parameters, cast_data.key_cast.cast_data);
274: 		result->key_state = cast_data.key_cast.init_local_state(child_params);
275: 	}
276: 	if (cast_data.value_cast.init_local_state) {
277: 		CastLocalStateParameters child_params(parameters, cast_data.value_cast.cast_data);
278: 		result->value_state = cast_data.value_cast.init_local_state(child_params);
279: 	}
280: 	return std::move(result);
281: }
282: 
283: bool VectorStringToMap::StringToNestedTypeCastLoop(const string_t *source_data, ValidityMask &source_mask,
284:                                                    Vector &result, ValidityMask &result_mask, idx_t count,
285:                                                    CastParameters &parameters, const SelectionVector *sel) {
286: 	idx_t total_elements = 0;
287: 	for (idx_t i = 0; i < count; i++) {
288: 		idx_t idx = i;
289: 		if (sel) {
290: 			idx = sel->get_index(i);
291: 		}
292: 		if (!source_mask.RowIsValid(idx)) {
293: 			continue;
294: 		}
295: 		total_elements += (VectorStringToMap::CountPartsMap(source_data[idx]) + 1) / 2;
296: 	}
297: 
298: 	Vector varchar_key_vector(LogicalType::VARCHAR, total_elements);
299: 	Vector varchar_val_vector(LogicalType::VARCHAR, total_elements);
300: 	auto child_key_data = FlatVector::GetData<string_t>(varchar_key_vector);
301: 	auto child_val_data = FlatVector::GetData<string_t>(varchar_val_vector);
302: 
303: 	ListVector::Reserve(result, total_elements);
304: 	ListVector::SetListSize(result, total_elements);
305: 	auto list_data = ListVector::GetData(result);
306: 
307: 	VectorTryCastData vector_cast_data(result, parameters);
308: 	idx_t total = 0;
309: 	for (idx_t i = 0; i < count; i++) {
310: 		idx_t idx = i;
311: 		if (sel) {
312: 			idx = sel->get_index(i);
313: 		}
314: 		if (!source_mask.RowIsValid(idx)) {
315: 			result_mask.SetInvalid(i);
316: 			continue;
317: 		}
318: 
319: 		list_data[i].offset = total;
320: 		if (!VectorStringToMap::SplitStringMap(source_data[idx], child_key_data, child_val_data, total,
321: 		                                       varchar_key_vector, varchar_val_vector)) {
322: 			string text = "Type VARCHAR with value '" + source_data[idx].GetString() +
323: 			              "' can't be cast to the destination type MAP";
324: 			FlatVector::SetNull(result, i, true);
325: 			HandleVectorCastError::Operation<string_t>(text, result_mask, i, vector_cast_data);
326: 		}
327: 		list_data[i].length = total - list_data[i].offset;
328: 	}
329: 	D_ASSERT(total_elements == total);
330: 
331: 	auto &result_key_child = MapVector::GetKeys(result);
332: 	auto &result_val_child = MapVector::GetValues(result);
333: 	auto &cast_data = parameters.cast_data->Cast<MapBoundCastData>();
334: 	auto &lstate = parameters.local_state->Cast<MapCastLocalState>();
335: 
336: 	CastParameters key_params(parameters, cast_data.key_cast.cast_data, lstate.key_state);
337: 	if (!cast_data.key_cast.function(varchar_key_vector, result_key_child, total_elements, key_params)) {
338: 		vector_cast_data.all_converted = false;
339: 	}
340: 	CastParameters val_params(parameters, cast_data.value_cast.cast_data, lstate.value_state);
341: 	if (!cast_data.value_cast.function(varchar_val_vector, result_val_child, total_elements, val_params)) {
342: 		vector_cast_data.all_converted = false;
343: 	}
344: 
345: 	auto &key_validity = FlatVector::Validity(result_key_child);
346: 	if (!vector_cast_data.all_converted) {
347: 		for (idx_t row_idx = 0; row_idx < count; row_idx++) {
348: 			if (!result_mask.RowIsValid(row_idx)) {
349: 				continue;
350: 			}
351: 			auto list = list_data[row_idx];
352: 			for (idx_t list_idx = 0; list_idx < list.length; list_idx++) {
353: 				auto idx = list.offset + list_idx;
354: 				if (!key_validity.RowIsValid(idx)) {
355: 					result_mask.SetInvalid(row_idx);
356: 				}
357: 			}
358: 		}
359: 	}
360: 	MapVector::MapConversionVerify(result, count);
361: 	return vector_cast_data.all_converted;
362: }
363: 
364: //===--------------------------------------------------------------------===//
365: // string -> array casting
366: //===--------------------------------------------------------------------===//
367: bool VectorStringToArray::StringToNestedTypeCastLoop(const string_t *source_data, ValidityMask &source_mask,
368:                                                      Vector &result, ValidityMask &result_mask, idx_t count,
369:                                                      CastParameters &parameters, const SelectionVector *sel) {
370: 	idx_t array_size = ArrayType::GetSize(result.GetType());
371: 	bool all_lengths_match = true;
372: 
373: 	for (idx_t i = 0; i < count; i++) {
374: 		idx_t idx = i;
375: 		if (sel) {
376: 			idx = sel->get_index(i);
377: 		}
378: 		if (!source_mask.RowIsValid(idx)) {
379: 			continue;
380: 		}
381: 		auto str_array_size = VectorStringToList::CountPartsList(source_data[idx]);
382: 		if (array_size != str_array_size) {
383: 			if (all_lengths_match) {
384: 				all_lengths_match = false;
385: 				auto msg =
386: 				    StringUtil::Format("Type VARCHAR with value '%s' can't be cast to the destination type ARRAY[%u]"
387: 				                       ", the size of the array must match the destination type",
388: 				                       source_data[idx].GetString(), array_size);
389: 				if (parameters.strict) {
390: 					throw ConversionException(msg);
391: 				}
392: 				HandleCastError::AssignError(msg, parameters);
393: 			}
394: 			result_mask.SetInvalid(i);
395: 		}
396: 	}
397: 
398: 	auto child_count = array_size * count;
399: 	Vector varchar_vector(LogicalType::VARCHAR, child_count);
400: 	auto child_data = FlatVector::GetData<string_t>(varchar_vector);
401: 
402: 	VectorTryCastData vector_cast_data(result, parameters);
403: 	idx_t total = 0;
404: 	for (idx_t i = 0; i < count; i++) {
405: 		idx_t idx = i;
406: 		if (sel) {
407: 			idx = sel->get_index(i);
408: 		}
409: 
410: 		if (!source_mask.RowIsValid(idx) || !result_mask.RowIsValid(i)) {
411: 			// The source is null, or there was a size-mismatch above, so dont try to split the string
412: 			result_mask.SetInvalid(i);
413: 
414: 			// Null the entire array
415: 			for (idx_t j = 0; j < array_size; j++) {
416: 				FlatVector::SetNull(varchar_vector, i * array_size + j, true);
417: 			}
418: 
419: 			total += array_size;
420: 			continue;
421: 		}
422: 
423: 		if (!VectorStringToList::SplitStringList(source_data[idx], child_data, total, varchar_vector)) {
424: 			auto text = StringUtil::Format("Type VARCHAR with value '%s' can't be cast to the destination type ARRAY",
425: 			                               source_data[idx].GetString());
426: 			HandleVectorCastError::Operation<string_t>(text, result_mask, i, vector_cast_data);
427: 		}
428: 	}
429: 	D_ASSERT(total == child_count);
430: 
431: 	auto &result_child = ArrayVector::GetEntry(result);
432: 	auto &cast_data = parameters.cast_data->Cast<ArrayBoundCastData>();
433: 	CastParameters child_parameters(parameters, cast_data.child_cast_info.cast_data, parameters.local_state);
434: 	bool cast_result = cast_data.child_cast_info.function(varchar_vector, result_child, child_count, child_parameters);
435: 
436: 	return all_lengths_match && cast_result && vector_cast_data.all_converted;
437: }
438: 
439: template <class T>
440: bool StringToNestedTypeCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {
441: 	D_ASSERT(source.GetType().id() == LogicalTypeId::VARCHAR);
442: 
443: 	switch (source.GetVectorType()) {
444: 	case VectorType::CONSTANT_VECTOR: {
445: 		auto source_data = ConstantVector::GetData<string_t>(source);
446: 		auto &source_mask = ConstantVector::Validity(source);
447: 		auto &result_mask = FlatVector::Validity(result);
448: 		auto ret = T::StringToNestedTypeCastLoop(source_data, source_mask, result, result_mask, 1, parameters, nullptr);
449: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
450: 		return ret;
451: 	}
452: 	default: {
453: 		UnifiedVectorFormat unified_source;
454: 
455: 		source.ToUnifiedFormat(count, unified_source);
456: 		auto source_sel = unified_source.sel;
457: 		auto source_data = UnifiedVectorFormat::GetData<string_t>(unified_source);
458: 		auto &source_mask = unified_source.validity;
459: 		auto &result_mask = FlatVector::Validity(result);
460: 
461: 		return T::StringToNestedTypeCastLoop(source_data, source_mask, result, result_mask, count, parameters,
462: 		                                     source_sel);
463: 	}
464: 	}
465: }
466: 
467: BoundCastInfo DefaultCasts::StringCastSwitch(BindCastInput &input, const LogicalType &source,
468:                                              const LogicalType &target) {
469: 	switch (target.id()) {
470: 	case LogicalTypeId::DATE:
471: 		return BoundCastInfo(&VectorCastHelpers::TryCastErrorLoop<string_t, date_t, duckdb::TryCastErrorMessage>);
472: 	case LogicalTypeId::TIME:
473: 		return BoundCastInfo(&VectorCastHelpers::TryCastErrorLoop<string_t, dtime_t, duckdb::TryCastErrorMessage>);
474: 	case LogicalTypeId::TIME_TZ:
475: 		return BoundCastInfo(&VectorCastHelpers::TryCastErrorLoop<string_t, dtime_tz_t, duckdb::TryCastErrorMessage>);
476: 	case LogicalTypeId::TIMESTAMP:
477: 	case LogicalTypeId::TIMESTAMP_TZ:
478: 		return BoundCastInfo(&VectorCastHelpers::TryCastErrorLoop<string_t, timestamp_t, duckdb::TryCastErrorMessage>);
479: 	case LogicalTypeId::TIMESTAMP_NS:
480: 		return BoundCastInfo(
481: 		    &VectorCastHelpers::TryCastStrictLoop<string_t, timestamp_ns_t, duckdb::TryCastToTimestampNS>);
482: 	case LogicalTypeId::TIMESTAMP_SEC:
483: 		return BoundCastInfo(
484: 		    &VectorCastHelpers::TryCastStrictLoop<string_t, timestamp_t, duckdb::TryCastToTimestampSec>);
485: 	case LogicalTypeId::TIMESTAMP_MS:
486: 		return BoundCastInfo(
487: 		    &VectorCastHelpers::TryCastStrictLoop<string_t, timestamp_t, duckdb::TryCastToTimestampMS>);
488: 	case LogicalTypeId::BLOB:
489: 		return BoundCastInfo(&VectorCastHelpers::TryCastStringLoop<string_t, string_t, duckdb::TryCastToBlob>);
490: 	case LogicalTypeId::BIT:
491: 		return BoundCastInfo(&VectorCastHelpers::TryCastStringLoop<string_t, string_t, duckdb::TryCastToBit>);
492: 	case LogicalTypeId::UUID:
493: 		return BoundCastInfo(&VectorCastHelpers::TryCastStringLoop<string_t, hugeint_t, duckdb::TryCastToUUID>);
494: 	case LogicalTypeId::SQLNULL:
495: 		return &DefaultCasts::TryVectorNullCast;
496: 	case LogicalTypeId::VARCHAR:
497: 		return &DefaultCasts::ReinterpretCast;
498: 	case LogicalTypeId::LIST:
499: 		// the second argument allows for a secondary casting function to be passed in the CastParameters
500: 		return BoundCastInfo(
501: 		    &StringToNestedTypeCast<VectorStringToList>,
502: 		    ListBoundCastData::BindListToListCast(input, LogicalType::LIST(LogicalType::VARCHAR), target),
503: 		    ListBoundCastData::InitListLocalState);
504: 	case LogicalTypeId::ARRAY:
505: 		// the second argument allows for a secondary casting function to be passed in the CastParameters
506: 		return BoundCastInfo(&StringToNestedTypeCast<VectorStringToArray>,
507: 		                     ArrayBoundCastData::BindArrayToArrayCast(
508: 		                         input, LogicalType::ARRAY(LogicalType::VARCHAR, optional_idx()), target),
509: 		                     ArrayBoundCastData::InitArrayLocalState);
510: 	case LogicalTypeId::STRUCT:
511: 		return BoundCastInfo(&StringToNestedTypeCast<VectorStringToStruct>,
512: 		                     StructBoundCastData::BindStructToStructCast(input, InitVarcharStructType(target), target),
513: 		                     StructBoundCastData::InitStructCastLocalState);
514: 	case LogicalTypeId::MAP:
515: 		return BoundCastInfo(&StringToNestedTypeCast<VectorStringToMap>,
516: 		                     MapBoundCastData::BindMapToMapCast(
517: 		                         input, LogicalType::MAP(LogicalType::VARCHAR, LogicalType::VARCHAR), target),
518: 		                     InitMapCastLocalState);
519: 	case LogicalTypeId::VARINT:
520: 		return BoundCastInfo(&VectorCastHelpers::TryCastStringLoop<string_t, string_t, TryCastToVarInt>);
521: 	default:
522: 		return VectorStringCastNumericSwitch(input, source, target);
523: 	}
524: }
525: 
526: } // namespace duckdb
[end of src/function/cast/string_cast.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: