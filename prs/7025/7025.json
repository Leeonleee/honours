{
  "repo": "duckdb/duckdb",
  "pull_number": 7025,
  "instance_id": "duckdb__duckdb-7025",
  "issue_numbers": [
    "7022",
    "7022"
  ],
  "base_commit": "7312132f84cbc0960751a06d4f610af0043c8ae3",
  "patch": "diff --git a/src/include/duckdb/planner/pragma_handler.hpp b/src/include/duckdb/planner/pragma_handler.hpp\nindex 7345e3d4ca2c..81ba353a5155 100644\n--- a/src/include/duckdb/planner/pragma_handler.hpp\n+++ b/src/include/duckdb/planner/pragma_handler.hpp\n@@ -29,8 +29,9 @@ class PragmaHandler {\n \tClientContext &context;\n \n private:\n-\t//! Handles a pragma statement, (potentially) returning a new statement to replace the current one\n-\tstring HandlePragma(SQLStatement *statement);\n+\t//! Handles a pragma statement, returns whether the statement was expanded, if it was expanded the 'resulting_query'\n+\t//! contains the statement(s) to replace the current one\n+\tbool HandlePragma(SQLStatement *statement, string &resulting_query);\n \n \tvoid HandlePragmaStatementsInternal(vector<unique_ptr<SQLStatement>> &statements);\n };\ndiff --git a/src/planner/pragma_handler.cpp b/src/planner/pragma_handler.cpp\nindex be6f5083952f..43a2568f267c 100644\n--- a/src/planner/pragma_handler.cpp\n+++ b/src/planner/pragma_handler.cpp\n@@ -32,8 +32,9 @@ void PragmaHandler::HandlePragmaStatementsInternal(vector<unique_ptr<SQLStatemen\n \t\tif (statements[i]->type == StatementType::PRAGMA_STATEMENT) {\n \t\t\t// PRAGMA statement: check if we need to replace it by a new set of statements\n \t\t\tPragmaHandler handler(context);\n-\t\t\tauto new_query = handler.HandlePragma(statements[i].get());\n-\t\t\tif (!new_query.empty()) {\n+\t\t\tstring new_query;\n+\t\t\tbool expanded = handler.HandlePragma(statements[i].get(), new_query);\n+\t\t\tif (expanded) {\n \t\t\t\t// this PRAGMA statement gets replaced by a new query string\n \t\t\t\t// push the new query string through the parser again and add it to the transformer\n \t\t\t\tParser parser(context.GetParserOptions());\n@@ -67,7 +68,7 @@ void PragmaHandler::HandlePragmaStatements(ClientContextLock &lock, vector<uniqu\n \tcontext.RunFunctionInTransactionInternal(lock, [&]() { HandlePragmaStatementsInternal(statements); });\n }\n \n-string PragmaHandler::HandlePragma(SQLStatement *statement) { // PragmaInfo &info\n+bool PragmaHandler::HandlePragma(SQLStatement *statement, string &resulting_query) { // PragmaInfo &info\n \tauto info = *(statement->Cast<PragmaStatement>()).info;\n \tauto entry =\n \t    Catalog::GetEntry<PragmaFunctionCatalogEntry>(context, INVALID_CATALOG, DEFAULT_SCHEMA, info.name, false);\n@@ -84,9 +85,10 @@ string PragmaHandler::HandlePragma(SQLStatement *statement) { // PragmaInfo &inf\n \t\tBinder::BindNamedParameters(bound_function.named_parameters, info.named_parameters, error_context,\n \t\t                            bound_function.name);\n \t\tFunctionParameters parameters {info.parameters, info.named_parameters};\n-\t\treturn bound_function.query(context, parameters);\n+\t\tresulting_query = bound_function.query(context, parameters);\n+\t\treturn true;\n \t}\n-\treturn string();\n+\treturn false;\n }\n \n } // namespace duckdb\ndiff --git a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\nindex 88b7d8739cf7..a7e88d8020f0 100644\n--- a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n+++ b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n@@ -174,6 +174,9 @@ int sqlite3_prepare_v2(sqlite3 *db,           /* Database handle */\n \t\tstatements.push_back(std::move(parser.statements[0]));\n \n \t\tdb->con->context->HandlePragmaStatements(statements);\n+\t\tif (statements.empty()) {\n+\t\t\treturn SQLITE_OK;\n+\t\t}\n \n \t\t// if there are multiple statements here, we are dealing with an import database statement\n \t\t// we directly execute all statements besides the final one\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_import_export.py b/tools/pythonpkg/tests/fast/test_import_export.py\nindex 2aed89d999e5..6fc3889e73a8 100644\n--- a/tools/pythonpkg/tests/fast/test_import_export.py\n+++ b/tools/pythonpkg/tests/fast/test_import_export.py\n@@ -3,40 +3,27 @@\n from os import path\n import shutil\n import os\n-\n-@pytest.fixture(scope=\"session\")\n-def export_path(tmp_path_factory):\n-    database = tmp_path_factory.mktemp(\"export_dbs\", numbered=True)\n-    return str(database)\n-\n-@pytest.fixture(scope=\"session\")\n-def import_path(tmp_path_factory):\n-    database = tmp_path_factory.mktemp(\"import_dbs\", numbered=True)\n-    return str(database)\n+from pathlib import Path\n \n def export_database(export_location):\n     # Create the db\n-    duckdb.execute(\"create table tbl (a integer, b integer);\");\n-    duckdb.execute(\"insert into tbl values (5,1);\");\n+    con = duckdb.connect()\n+    con.execute(\"create table tbl (a integer, b integer);\");\n+    con.execute(\"insert into tbl values (5,1);\");\n \n     # Export the db\n-    duckdb.execute(f\"export database '{export_location}';\");\n+    con.execute(f\"export database '{export_location}';\");\n     print(f\"Exported database to {export_location}\")\n \n-    # Destroy the db\n-    duckdb.execute(\"drop table tbl\");\n-\n def import_database(import_location):\n-    duckdb.execute(f\"import database '{import_location}'\")\n+    con = duckdb.connect()\n+    con.execute(f\"import database '{import_location}'\")\n     print(f\"Imported database from {import_location}\");\n \n-    res = duckdb.query(\"select * from tbl\").fetchall()\n+    res = con.query(\"select * from tbl\").fetchall()\n     assert res == [(5,1),]\n     print(\"Successfully queried an imported database that was moved from its original export location!\")\n \n-    # Destroy the db\n-    duckdb.execute(\"drop table tbl\");\n-\n def move_database(export_location, import_location):\n     assert path.exists(export_location)\n     assert path.exists(import_location)\n@@ -44,9 +31,47 @@ def move_database(export_location, import_location):\n     for file in ['schema.sql', 'load.sql', 'tbl.csv']:\n         shutil.move(path.join(export_location, file), import_location)\n \n+def export_move_and_import(export_path, import_path):\n+    export_database(export_path)\n+    move_database(export_path, import_path)\n+    import_database(import_path)\n+\n+def export_and_import_empty_db(db_path, _):\n+    con = duckdb.connect()\n+\n+    # Export the db\n+    con.execute(f\"export database '{db_path}';\");\n+    print(f\"Exported database to {db_path}\")\n+\n+    con.close();\n+    con = duckdb.connect()\n+    con.execute(f\"import database '{db_path}'\")\n+\n class TestDuckDBImportExport():\n-\t\n-    def test_import_and_export(self, export_path, import_path):\n-        export_database(export_path)\n-        move_database(export_path, import_path)\n-        import_database(import_path)\n+\n+    @pytest.mark.parametrize('routine', [\n+        export_move_and_import,\n+        export_and_import_empty_db\n+    ])\n+    def test_import_and_export(self, routine, tmp_path_factory):\n+        export_path = str(tmp_path_factory.mktemp(\"export_dbs\", numbered=True))\n+        import_path = str(tmp_path_factory.mktemp(\"import_dbs\", numbered=True))\n+        routine(export_path, import_path)\n+\n+    def test_import_empty_db(self, tmp_path_factory):\n+        import_path = str(tmp_path_factory.mktemp(\"empty_db\", numbered=True))\n+\n+        # Create an empty db folder structure\n+        Path(Path(import_path) / 'load.sql').touch()\n+        Path(Path(import_path) / 'schema.sql').touch()\n+\n+        con = duckdb.connect()\n+        con.execute(f\"import database '{import_path}'\")\n+\n+        # Put a single comment into the 'schema.sql' file\n+        with open(Path(import_path) / 'schema.sql', 'w') as f:\n+            f.write('--\\n')\n+\n+        con.close()\n+        con = duckdb.connect()\n+        con.execute(f\"import database '{import_path}'\")\n",
  "problem_statement": "import database 'foo.export' segment faults if schema.sql is empty or has no commands\n### What happens?\n\nA schema.sql with no statement causes a segfault on \"import database\"\r\n\r\nPutting any statement in schema.sql makes it work.\n\n### To Reproduce\n\n\r\n# zero-length files causes a binder error\r\n\r\n```\r\n% ls -l foo3.export \r\n-rw-r--r--  1 mark  staff  0 Apr 10 21:25 load.sql\r\n-rw-r--r--  1 mark  staff  0 Apr 10 21:25 schema.sql\r\n% duckdb\r\nD import database 'foo3.export';\r\nError: Binder Error: PRAGMA function does not have a function specified\r\n```\r\n\r\n# one comment line causes segfault\r\n\r\n```\r\n% echo \"--\" >foo3.export/schema.sql\r\nD import database 'foo3.export';\r\nzsh: segmentation fault  duckdb\r\n\r\n# any command makes it work\r\n\r\nl% echo \"set username='';\" >foo3.export/schema.sql \r\nD import database 'foo3.export';\r\nD \r\n```\r\n\r\n% duckdb-v0.7.2-dev1146 \r\nD import database 'foo3.export';\r\nzsh: segmentation fault  duckdb-v0.7.2-dev1146\r\n\n\n### OS:\n\nmacos\n\n### DuckDB Version:\n\nv0.7.1 b00b93f0b1\n\n### DuckDB Client:\n\ncli\n\n### Full Name:\n\nMark Harrison\n\n### Affiliation:\n\nTigerEye\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nimport database 'foo.export' segment faults if schema.sql is empty or has no commands\n### What happens?\n\nA schema.sql with no statement causes a segfault on \"import database\"\r\n\r\nPutting any statement in schema.sql makes it work.\n\n### To Reproduce\n\n\r\n# zero-length files causes a binder error\r\n\r\n```\r\n% ls -l foo3.export \r\n-rw-r--r--  1 mark  staff  0 Apr 10 21:25 load.sql\r\n-rw-r--r--  1 mark  staff  0 Apr 10 21:25 schema.sql\r\n% duckdb\r\nD import database 'foo3.export';\r\nError: Binder Error: PRAGMA function does not have a function specified\r\n```\r\n\r\n# one comment line causes segfault\r\n\r\n```\r\n% echo \"--\" >foo3.export/schema.sql\r\nD import database 'foo3.export';\r\nzsh: segmentation fault  duckdb\r\n\r\n# any command makes it work\r\n\r\nl% echo \"set username='';\" >foo3.export/schema.sql \r\nD import database 'foo3.export';\r\nD \r\n```\r\n\r\n% duckdb-v0.7.2-dev1146 \r\nD import database 'foo3.export';\r\nzsh: segmentation fault  duckdb-v0.7.2-dev1146\r\n\n\n### OS:\n\nmacos\n\n### DuckDB Version:\n\nv0.7.1 b00b93f0b1\n\n### DuckDB Client:\n\ncli\n\n### Full Name:\n\nMark Harrison\n\n### Affiliation:\n\nTigerEye\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "\n",
  "created_at": "2023-04-11T09:20:57Z"
}