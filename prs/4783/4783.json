{
  "repo": "duckdb/duckdb",
  "pull_number": 4783,
  "instance_id": "duckdb__duckdb-4783",
  "issue_numbers": [
    "4152"
  ],
  "base_commit": "8e80985727fc27a86b026d28bcbf251e23fce189",
  "patch": "diff --git a/src/include/duckdb/planner/bind_context.hpp b/src/include/duckdb/planner/bind_context.hpp\nindex 1818adb4fc78..a547c8ccbdea 100644\n--- a/src/include/duckdb/planner/bind_context.hpp\n+++ b/src/include/duckdb/planner/bind_context.hpp\n@@ -80,10 +80,10 @@ class BindContext {\n \n \t//! Adds a base table with the given alias to the BindContext.\n \tvoid AddBaseTable(idx_t index, const string &alias, const vector<string> &names, const vector<LogicalType> &types,\n-\t                  LogicalGet &get);\n+\t                  vector<column_t> &bound_column_ids, StandardEntry *entry);\n \t//! Adds a call to a table function with the given alias to the BindContext.\n \tvoid AddTableFunction(idx_t index, const string &alias, const vector<string> &names,\n-\t                      const vector<LogicalType> &types, LogicalGet &get);\n+\t                      const vector<LogicalType> &types, vector<column_t> &bound_column_ids, StandardEntry *entry);\n \t//! Adds a table view with a given alias to the BindContext.\n \tvoid AddView(idx_t index, const string &alias, SubqueryRef &ref, BoundQueryNode &subquery, ViewCatalogEntry *view);\n \t//! Adds a subquery with a given alias to the BindContext.\ndiff --git a/src/include/duckdb/planner/operator/logical_delete.hpp b/src/include/duckdb/planner/operator/logical_delete.hpp\nindex 1be7cd0bfbaf..23abff7f67a3 100644\n--- a/src/include/duckdb/planner/operator/logical_delete.hpp\n+++ b/src/include/duckdb/planner/operator/logical_delete.hpp\n@@ -31,7 +31,7 @@ class LogicalDelete : public LogicalOperator {\n protected:\n \tvector<ColumnBinding> GetColumnBindings() override {\n \t\tif (return_chunk) {\n-\t\t\treturn GenerateColumnBindings(table_index, table->columns.size());\n+\t\t\treturn GenerateColumnBindings(table_index, table->GetTypes().size());\n \t\t}\n \t\treturn {ColumnBinding(0, 0)};\n \t}\ndiff --git a/src/include/duckdb/planner/operator/logical_insert.hpp b/src/include/duckdb/planner/operator/logical_insert.hpp\nindex 26d83debf5c0..fbd08af0cf8c 100644\n--- a/src/include/duckdb/planner/operator/logical_insert.hpp\n+++ b/src/include/duckdb/planner/operator/logical_insert.hpp\n@@ -39,7 +39,7 @@ class LogicalInsert : public LogicalOperator {\n protected:\n \tvector<ColumnBinding> GetColumnBindings() override {\n \t\tif (return_chunk) {\n-\t\t\treturn GenerateColumnBindings(table_index, table->columns.size());\n+\t\t\treturn GenerateColumnBindings(table_index, table->GetTypes().size());\n \t\t}\n \t\treturn {ColumnBinding(0, 0)};\n \t}\ndiff --git a/src/include/duckdb/planner/operator/logical_update.hpp b/src/include/duckdb/planner/operator/logical_update.hpp\nindex 9c21359ccd4d..ab5a1f38efea 100644\n--- a/src/include/duckdb/planner/operator/logical_update.hpp\n+++ b/src/include/duckdb/planner/operator/logical_update.hpp\n@@ -36,7 +36,7 @@ class LogicalUpdate : public LogicalOperator {\n protected:\n \tvector<ColumnBinding> GetColumnBindings() override {\n \t\tif (return_chunk) {\n-\t\t\treturn GenerateColumnBindings(table_index, table->columns.size());\n+\t\t\treturn GenerateColumnBindings(table_index, table->GetTypes().size());\n \t\t}\n \t\treturn {ColumnBinding(0, 0)};\n \t}\ndiff --git a/src/include/duckdb/planner/table_binding.hpp b/src/include/duckdb/planner/table_binding.hpp\nindex 40c1f46ab749..d7ad75087af0 100644\n--- a/src/include/duckdb/planner/table_binding.hpp\n+++ b/src/include/duckdb/planner/table_binding.hpp\n@@ -68,11 +68,13 @@ struct EntryBinding : public Binding {\n //! TableBinding is exactly like the Binding, except it keeps track of which columns were bound in the linked LogicalGet\n //! node for projection pushdown purposes.\n struct TableBinding : public Binding {\n-\tTableBinding(const string &alias, vector<LogicalType> types, vector<string> names, LogicalGet &get, idx_t index,\n-\t             bool add_row_id = false);\n+\tTableBinding(const string &alias, vector<LogicalType> types, vector<string> names,\n+\t             vector<column_t> &bound_column_ids, StandardEntry *entry, idx_t index, bool add_row_id = false);\n \n-\t//! the underlying LogicalGet\n-\tLogicalGet &get;\n+\t//! A reference to the set of bound column ids\n+\tvector<column_t> &bound_column_ids;\n+\t//! The underlying catalog entry (if any)\n+\tStandardEntry *entry;\n \n public:\n \tunique_ptr<ParsedExpression> ExpandGeneratedColumn(const string &column_name);\ndiff --git a/src/planner/bind_context.cpp b/src/planner/bind_context.cpp\nindex e032a63e969a..894d1276fd19 100644\n--- a/src/planner/bind_context.cpp\n+++ b/src/planner/bind_context.cpp\n@@ -167,7 +167,9 @@ unique_ptr<ParsedExpression> BindContext::ExpandGeneratedColumn(const string &ta\n \tauto binding = GetBinding(table_name, error_message);\n \tD_ASSERT(binding);\n \tauto &table_binding = *(TableBinding *)binding;\n-\treturn table_binding.ExpandGeneratedColumn(column_name);\n+\tauto result = table_binding.ExpandGeneratedColumn(column_name);\n+\tresult->alias = column_name;\n+\treturn result;\n }\n \n unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const string &table_name, const string &column_name) {\n@@ -419,13 +421,15 @@ void BindContext::AddBinding(const string &alias, unique_ptr<Binding> binding) {\n }\n \n void BindContext::AddBaseTable(idx_t index, const string &alias, const vector<string> &names,\n-                               const vector<LogicalType> &types, LogicalGet &get) {\n-\tAddBinding(alias, make_unique<TableBinding>(alias, types, names, get, index, true));\n+                               const vector<LogicalType> &types, vector<column_t> &bound_column_ids,\n+                               StandardEntry *entry) {\n+\tAddBinding(alias, make_unique<TableBinding>(alias, types, names, bound_column_ids, entry, index, true));\n }\n \n void BindContext::AddTableFunction(idx_t index, const string &alias, const vector<string> &names,\n-                                   const vector<LogicalType> &types, LogicalGet &get) {\n-\tAddBinding(alias, make_unique<TableBinding>(alias, types, names, get, index));\n+                                   const vector<LogicalType> &types, vector<column_t> &bound_column_ids,\n+                                   StandardEntry *entry) {\n+\tAddBinding(alias, make_unique<TableBinding>(alias, types, names, bound_column_ids, entry, index));\n }\n \n static string AddColumnNameToBinding(const string &base_name, case_insensitive_set_t &current_names) {\ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex 5a02d33ae6b7..a6e6934df1de 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -409,12 +409,18 @@ BoundStatement Binder::BindReturning(vector<unique_ptr<ParsedExpression>> return\n \n \tauto binder = Binder::CreateBinder(context);\n \n+\tvector<column_t> bound_columns;\n+\tidx_t column_count = 0;\n \tfor (auto &col : table->columns) {\n \t\tnames.push_back(col.Name());\n \t\ttypes.push_back(col.Type());\n+\t\tif (!col.Generated()) {\n+\t\t\tbound_columns.push_back(column_count);\n+\t\t}\n+\t\tcolumn_count++;\n \t}\n \n-\tbinder->bind_context.AddGenericBinding(update_table_index, table->name, names, types);\n+\tbinder->bind_context.AddBaseTable(update_table_index, table->name, names, types, bound_columns, table);\n \tReturningBinder returning_binder(*binder, context);\n \n \tvector<unique_ptr<Expression>> projection_expressions;\ndiff --git a/src/planner/binder/expression/bind_columnref_expression.cpp b/src/planner/binder/expression/bind_columnref_expression.cpp\nindex 71357d502c68..47917d8ae599 100644\n--- a/src/planner/binder/expression/bind_columnref_expression.cpp\n+++ b/src/planner/binder/expression/bind_columnref_expression.cpp\n@@ -245,7 +245,12 @@ BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref_p, idx_t\n \t}\n \t//! Generated column returns generated expression\n \tif (expr->type != ExpressionType::COLUMN_REF) {\n-\t\treturn BindExpression(&expr, depth);\n+\t\tauto alias = expr->alias;\n+\t\tauto result = BindExpression(&expr, depth);\n+\t\tif (result.expression) {\n+\t\t\tresult.expression->alias = move(alias);\n+\t\t}\n+\t\treturn result;\n \t}\n \tauto &colref = (ColumnRefExpression &)*expr;\n \tD_ASSERT(colref.IsQualified());\ndiff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex b33e0c58c8d0..a41f46e956d1 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -120,7 +120,8 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \n \t\tauto logical_get = make_unique<LogicalGet>(table_index, scan_function, move(bind_data), move(return_types),\n \t\t                                           move(return_names));\n-\t\tbind_context.AddBaseTable(table_index, alias, table_names, table_types, *logical_get);\n+\t\tbind_context.AddBaseTable(table_index, alias, table_names, table_types, logical_get->column_ids,\n+\t\t                          logical_get->GetTable());\n \t\treturn make_unique_base<BoundTableRef, BoundBaseTableRef>(table, move(logical_get));\n \t}\n \tcase CatalogType::VIEW_ENTRY: {\ndiff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp\nindex 4e89f6ccac3e..28fb8d7dd659 100644\n--- a/src/planner/binder/tableref/bind_table_function.cpp\n+++ b/src/planner/binder/tableref/bind_table_function.cpp\n@@ -154,7 +154,8 @@ Binder::BindTableFunctionInternal(TableFunction &table_function, const string &f\n \tget->input_table_types = input_table_types;\n \tget->input_table_names = input_table_names;\n \t// now add the table function to the bind context so its columns can be bound\n-\tbind_context.AddTableFunction(bind_index, function_name, return_names, return_types, *get);\n+\tbind_context.AddTableFunction(bind_index, function_name, return_names, return_types, get->column_ids,\n+\t                              get->GetTable());\n \treturn move(get);\n }\n \ndiff --git a/src/planner/table_binding.cpp b/src/planner/table_binding.cpp\nindex 248fdfd7f992..793523e50557 100644\n--- a/src/planner/table_binding.cpp\n+++ b/src/planner/table_binding.cpp\n@@ -8,7 +8,6 @@\n #include \"duckdb/planner/bind_context.hpp\"\n #include \"duckdb/planner/bound_query_node.hpp\"\n #include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n-#include \"duckdb/planner/operator/logical_get.hpp\"\n #include \"duckdb/parser/parsed_expression_iterator.hpp\"\n \n namespace duckdb {\n@@ -84,9 +83,10 @@ StandardEntry *EntryBinding::GetStandardEntry() {\n \treturn &this->entry;\n }\n \n-TableBinding::TableBinding(const string &alias, vector<LogicalType> types_p, vector<string> names_p, LogicalGet &get,\n-                           idx_t index, bool add_row_id)\n-    : Binding(BindingType::TABLE, alias, move(types_p), move(names_p), index), get(get) {\n+TableBinding::TableBinding(const string &alias, vector<LogicalType> types_p, vector<string> names_p,\n+                           vector<column_t> &bound_column_ids, StandardEntry *entry, idx_t index, bool add_row_id)\n+    : Binding(BindingType::TABLE, alias, move(types_p), move(names_p), index), bound_column_ids(bound_column_ids),\n+      entry(entry) {\n \tif (add_row_id) {\n \t\tif (name_map.find(\"rowid\") == name_map.end()) {\n \t\t\tname_map[\"rowid\"] = COLUMN_IDENTIFIER_ROW_ID;\n@@ -153,7 +153,7 @@ BindResult TableBinding::Bind(ColumnRefExpression &colref, idx_t depth) {\n \t\t}\n \t}\n \n-\tauto &column_ids = get.column_ids;\n+\tauto &column_ids = bound_column_ids;\n \t// check if the entry already exists in the column list for the table\n \tColumnBinding binding;\n \n@@ -173,7 +173,7 @@ BindResult TableBinding::Bind(ColumnRefExpression &colref, idx_t depth) {\n }\n \n StandardEntry *TableBinding::GetStandardEntry() {\n-\treturn get.GetTable();\n+\treturn entry;\n }\n \n string TableBinding::ColumnNotFoundError(const string &column_name) const {\n",
  "test_patch": "diff --git a/test/fuzzer/pedro/returning_clause_sizes_not_match.test b/test/fuzzer/pedro/returning_clause_sizes_not_match.test\nnew file mode 100644\nindex 000000000000..ac34d8768ff7\n--- /dev/null\n+++ b/test/fuzzer/pedro/returning_clause_sizes_not_match.test\n@@ -0,0 +1,79 @@\n+# name: test/fuzzer/pedro/returning_clause_sizes_not_match.test\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+statement ok\n+CREATE TABLE test (x INT, y AS(x + 100));\n+\n+query II\n+INSERT INTO test VALUES (1), (2) RETURNING *;\n+----\n+1\t101\n+2\t102\n+\n+query I\n+SELECT test FROM test\n+----\n+{'x': 1, 'y': 101}\n+{'x': 2, 'y': 102}\n+\n+query IIII\n+INSERT INTO test VALUES (1), (2) RETURNING *, *;\n+----\n+1\t101\t1\t101\n+2\t102\t2\t102\n+\n+query II\n+DELETE FROM test WHERE x=2 RETURNING *;\n+----\n+2\t102\n+2\t102\n+\n+query II\n+UPDATE test SET x=0 WHERE x = 1 RETURNING *;\n+----\n+0\t100\n+0\t100\n+\n+# Error: Binder Error: Referenced table \"y\" not found!\n+statement error\n+INSERT INTO test VALUES(1) RETURNING y.y;\n+\n+# Error: Binder Error: Referenced table \"y\" not found!\n+statement error\n+INSERT INTO test VALUES(1) RETURNING y.*;\n+\n+query I\n+INSERT INTO test VALUES(1) RETURNING test;\n+----\n+{'x': 1, 'y': 101}\n+\n+query I\n+INSERT INTO test VALUES(1) RETURNING test.y;\n+----\n+101\n+\n+query I\n+INSERT INTO test VALUES(1) RETURNING {'i' : x, 'j' : y};\n+----\n+{'i': 1, 'j': 101}\n+\n+query I\n+INSERT INTO test VALUES (1), (2) RETURNING y;\n+----\n+101\n+102\n+\n+query IIII\n+INSERT INTO test VALUES (1), (2) RETURNING y, y, y, x;\n+----\n+101\t101\t101\t1\n+102\t102\t102\t2\n+\n+query II\n+INSERT INTO test VALUES (1), (2) RETURNING y + y, x + y;\n+----\n+202\t102\n+204\t104\n",
  "problem_statement": "Fuzzer issues 2\n#### The issues\r\nThis is the follow-up to #4067. I will keep updating this issue with new issues from fuzzers I find.\r\n\r\n#### If exists flag ignored for alter statements (now fixed)\r\n```\r\nALTER TABLE IF EXISTS t0 RENAME TO t1;\r\nALTER SEQUENCE IF EXISTS seq OWNED BY x;\r\n```\r\nError: Catalog Error: Table with name t0 does not exist!\r\n\r\nThe error shouldn't be thrown.\r\n\r\n#### If not exists flag ignored for alter table add column statement (now fixed)\r\n```\r\nCREATE TABLE t0 (c0 INT);\r\nALTER TABLE t0 ADD COLUMN IF NOT EXISTS c0 INT;\r\n```\r\nError: Catalog Error: Column with name c0 already exists!\r\n\r\nThe error shouldn't be thrown.\r\n\r\n#### Generate series with NULL value (now fixed)\r\n```\r\nSELECT c0 FROM generate_series(NULL) t3(c0);\r\nSELECT c0 FROM range(NULL) t3(c0);\r\n```\r\nError: INTERNAL Error: Calling GetValue on a value that is NULL\r\n\r\nHere maybe a non-internal error should be thrown. For scalar functions, NULL values are already handled separately. For table UDF ones, maybe this is missing, ie an optional check for any NULL input throw error.\r\n\r\n#### Integer overflow while flattening dependent join (now fixed)\r\n```\r\nSELECT (SELECT c0 OFFSET 1) FROM (VALUES(1)) c0;\r\n```\r\nsrc/planner/subquery/flatten_dependent_join.cpp:397:90: runtime error: signed integer overflow: 1 + 9223372036854775807 cannot be represented in type 'long'\r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior src/planner/subquery/flatten_dependent_join.cpp:397:90 in\r\n\r\nThe query should output a single NULL value.\r\n\r\n#### NOT SIMILAR TO at FILTER clause (now fixed)\r\n```\r\nDuckDB db(nullptr);\r\nConnection con(db);\r\ncon.EnableQueryVerification();\r\ncon.SendQuery(\"SELECT count(*) FILTER (WHERE 0 NOT SIMILAR TO '2' = FALSE);\");\r\n```\r\nsrc/main/client_context.cpp:931: std::string duckdb::ClientContext::VerifyQuery(duckdb::ClientContextLock &, const std::string &, unique_ptr<duckdb::SQLStatement>): Assertion `orig_expr_list[i]->Equals(verify_statements[v_idx].select_list[i].get())' failed\r\n\r\nI can only reproduce it via the C-API. I think the internal ToString call doesn't match the parsed query.\r\n\r\nThe query should output a single 0 value.\r\n\r\n#### Escaped trim function call? (now fixed)\r\n```\r\nDuckDB db(nullptr);\r\nConnection con(db);\r\ncon.EnableQueryVerification();\r\ncon.SendQuery(\"SELECT \\\"trim\\\"(1);\");\r\n```\r\nsrc/main/client_context.cpp:931: std::string duckdb::ClientContext::VerifyQuery(duckdb::ClientContextLock &, const std::string &, unique_ptr<duckdb::SQLStatement>): Assertion `orig_expr_list[i]->Equals(verify_statements[v_idx].select_list[i].get())' failed\r\n\r\nSame issue as the previous one?\r\n\r\nThe query should output a single 1 value.\r\n\r\n#### Partition by UTF-8 string (now fixed)\r\n\r\nBecause the query uses non-printable UTF-8 characters, I upload it in a zip file:\r\n[window_issue.zip](https://github.com/duckdb/duckdb/files/9158568/window_issue.zip)\r\n\r\n/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:9: runtime error: reference binding to null pointer of type 'duckdb::RowDataBlock'\r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:9 in\r\n\r\nThe query should output 11 11 values,\r\n\r\n#### Floating-point validation (now fixed)\r\n```\r\nDuckDB db(nullptr);\r\nConnection con(db);\r\ncon.EnableQueryVerification();\r\ncon.SendQuery(\"SELECT 0E6\");\r\ncon.SendQuery(\"SELECT .0E7382504816742;\");\r\n```\r\nsrc/main/client_context.cpp:931: std::string duckdb::ClientContext::VerifyQuery(duckdb::ClientContextLock &, const std::string &, unique_ptr<duckdb::SQLStatement>): Assertion `orig_expr_list[i]->Equals(verify_statements[v_idx].select_list[i].get())' failed\r\n\r\nToString method not matching again?\r\n\r\n#### IS DISTINCT FROM validation (now fixed)\r\n```\r\nDuckDB db(nullptr);\r\nConnection con(db);\r\ncon.EnableQueryVerification();\r\ncon.SendQuery(\"SELECT (0 IS DISTINCT FROM 2) = 0;\");\r\ncon.SendQuery(\"SELECT CASE 8 WHEN(0 IS DISTINCT FROM 0) THEN 2 END;\");\r\n```\r\nsrc/main/client_context.cpp:931: std::string duckdb::ClientContext::VerifyQuery(duckdb::ClientContextLock &, const std::string &, unique_ptr<duckdb::SQLStatement>): Assertion `orig_expr_list[i]->Equals(verify_statements[v_idx].select_list[i].get())' failed\r\n\r\nAnother validation issue. A single false and NULL value is expected.\r\n\r\n#### UndefinedBehaviorSanitizer on downcast from correlated subquery\r\n```\r\nCREATE TABLE t0(c0 INT);\r\nSELECT count(*) OVER() = ANY(SELECT * FROM t0 t1 WHERE(c0 = t0.c0)) FROM t0;\r\n```\r\nsrc/optimizer/deliminator.cpp:38:19: runtime error: downcast of address 0x608000009120 which does not point to an object of type 'duckdb::BoundColumnRefExpression'\r\n0x608000009120: note: object is of type 'duckdb::BoundCastExpression'\r\n 00 00 00 00  50 d0 ea 09 20 56 00 00  0c 1b be be be be be be  40 91 00 00 80 60 00 00  00 00 00 00\r\n              ^~~~~~~~~~~~~~~~~~~~~~~\r\n              vptr for 'duckdb::BoundCastExpression'\r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior src/optimizer/deliminator.cpp:38:19 in\r\n\r\nAn empty result set is expected.\r\n\r\n#### Assertion error on correlated cube (now fixed)\r\n```\r\nCREATE TABLE t0(c0 INT);\r\nINSERT INTO t0 VALUES(NULL);\r\nSELECT (SELECT count(*) OVER() GROUP BY CUBE(c0)) FROM t0;\r\n```\r\nduckdb: src/execution/expression_executor.cpp:146: void duckdb::ExpressionExecutor::Execute(const duckdb::Expression &, duckdb::ExpressionState *, const duckdb::SelectionVector *, duckdb::idx_t, duckdb::Vector &): Assertion `FlatVector::Validity(result).CheckAllValid(count)' failed.\r\n\r\nBecause the cube returns more than one row, here the result may not be deterministic.\r\n\r\n#### Limit 0% on ANY subquery (now fixed)\r\n```\r\nSELECT 1 WHERE 1 < ANY(SELECT 2 LIMIT 0%);\r\n```\r\nThe query outputs 1, but because of LIMIT 0% I expect the ANY to be empty, then the predicate output should be empty.\r\n\r\n#### Correlated offset subquery\r\n```\r\nSELECT (SELECT 1 OFFSET c0) FROM (VALUES(1)) c0;\r\n```\r\nsrc/execution/column_binding_resolver.cpp:74: virtual unique_ptr<duckdb::Expression> duckdb::ColumnBindingResolver::VisitReplace(duckdb::BoundColumnRefExpression &, unique_ptr<duckdb::Expression> *): Assertion `expr.depth == 0' failed.\r\n\r\nThe query should output NULL.\r\n\r\n#### Missing error message at subquery\r\n```\r\nSELECT (WITH t2 AS (SELECT 3 WHERE count(*) FILTER (1)) SELECT 0 FROM t2);\r\n```\r\nsrc/execution/expression_executor.cpp:196: duckdb::idx_t duckdb::ExpressionExecutor::Select(const duckdb::Expression &, duckdb::ExpressionState *, const duckdb::SelectionVector *, duckdb::idx_t, duckdb::SelectionVector *, duckdb::SelectionVector *): Assertion `expr.return_type.id() == LogicalTypeId::BOOLEAN' failed.\r\n\r\nThis one is tricky, count(*) should bind in the inner query, then the error about aggregates in the WHERE clause should be thrown.\r\n\r\n#### NaN as LIMIT % (now fixed)\r\n```\r\nSELECT 1 LIMIT CAST('NaN' AS REAL)%;\r\n```\r\n/src/execution/operator/helper/physical_limit_percent.cpp:121:18: runtime error: nan is outside the range of representable values of type 'unsigned long'\r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior src/execution/operator/helper/physical_limit_percent.cpp:121:18\r\n\r\nA missing error here.\r\n\r\n#### Simple multiplication issue\r\n```\r\nDuckDB db(nullptr);\r\nConnection con(db);\r\ncon.EnableQueryVerification();\r\ncon.SendQuery(\"SELECT 1 * (1 < 1);\");\r\n```\r\nsrc/main/client_context.cpp:931: std::string duckdb::ClientContext::VerifyQuery(duckdb::ClientContextLock &, const std::string &, unique_ptr<duckdb::SQLStatement>): Assertion `orig_expr_list[i]->Equals(verify_statements[v_idx].select_list[i].get())' failed\r\n\r\nI didn't have time to look at the details of this yet.\r\n\r\n#### Duplicate table name at CTE\r\n```\r\nCREATE TABLE t0(c0 INT);\r\nWITH t0 AS (SELECT 2) INSERT INTO t0 (WITH t0 AS (SELECT 2) SELECT 2);\r\n```\r\nError: INTERNAL Error: Duplicate CTE \"t0\" in query!\r\n\r\nThis one maybe is mine. If we consider both CTEs to be at the same level, then the error shouldn't be internal.\r\n\r\n#### Order by ALL with UNION query (now fixed)\r\n```\r\n(SELECT 2 ORDER BY(SELECT 2)) UNION SELECT 1 ORDER BY ALL;\r\n```\r\nsrc/planner/binder/query_node/bind_select_node.cpp:241: void duckdb::Binder::BindModifierTypes(duckdb::BoundQueryNode &, const vector<duckdb::LogicalType> &, duckdb::idx_t): Assertion `bound_colref.binding.column_index < sql_types.size()' failed\r\n\r\nThe query should output the rows with values 1 and 2.\r\n\r\n#### Date = int optimized vs non optimized\r\n```\r\nCREATE TABLE t0 (c0 INT);\r\nPRAGMA enable_optimizer;\r\nSELECT 1 FROM t0 WHERE DATE '2010-1-1' = 2;\r\n-- Error: Conversion Error: Unimplemented type for cast (INTEGER -> DATE)\r\nPRAGMA disable_optimizer;\r\nSELECT 1 FROM t0 WHERE DATE '2010-1-1' = 2;\r\n-- Empty result\r\n```\r\n\r\nThis one is tricky. I would expect without any optimization the error to be thrown?\r\n\r\nAnother similar issue:\r\n```\r\nPRAGMA enable_optimizer;\r\nVALUES (1),(INTERVAL '1' MICROSECONDS) LIMIT 0;\r\n-- Empty result\r\nPRAGMA disable_optimizer;\r\nVALUES (1),(INTERVAL '1' MICROSECONDS) LIMIT 0;\r\n-- Error: Conversion Error: Unimplemented type for cast (INTEGER -> INTERVAL)\r\n```\r\nHere it's reverted and what I expect, prune with optimizers enabled.\r\n\r\nAnother similar issue:\r\n```\r\nPRAGMA enable_optimizer;\r\nSELECT 1 FROM (VALUES (1),(2),(NULL)) t0(c0) WHERE c0 BETWEEN 3 AND (CAST('inf' AS REAL) - 2);\r\n-- Error: Out of Range Error: Overflow in subtraction of float!\r\nPRAGMA disable_optimizer;\r\nSELECT 1 FROM (VALUES (1),(2),(NULL)) t0(c0) WHERE c0 BETWEEN 3 AND (CAST('inf' AS REAL) - 2);\r\n-- Empty result\r\n```\r\n\r\nThis seems to be happening with runtime errors.\r\n\r\n#### Select with forced parallelism\r\n```\r\nPRAGMA verify_parallelism;\r\nCREATE TABLE t0 (c0 INT, c1 INT);\r\nSELECT c1 FROM t0 WHERE (c0 + c1) = 2;\r\n```\r\nsrc/storage/data_table.cpp:333: bool duckdb::DataTable::NextParallelScan(duckdb::ClientContext &, duckdb::ParallelTableScanState &, duckdb::TableScanState &, const vector<duckdb::column_t> &): Assertion `vector_index * STANDARD_VECTOR_SIZE < state.current_row_group->count' failed\r\n\r\nMy test machine has 32 cores, and I am using 1024 as the vector size.\r\n\r\nThe [documentation](https://duckdb.org/docs/sql/pragmas) still mentions the pragma as `force_parallelism`. It needs to be updated.\r\n\r\n#### OFFSET query with wrong results\r\n```\r\nCREATE TABLE t0 (c0 INT, c1 INT);\r\nINSERT INTO t0 (VALUES (1, 1),(2, 2),(3, 3));\r\nSELECT c0 FROM t0 WHERE ((c0 + c1) = 2) OFFSET 10;\r\n```\r\nThe query outputs 1, it should be empty instead.\r\n\r\n#### OFFSET query taking too long\r\n```\r\nCREATE TABLE t0 (c0 INT, c1 INT);\r\nINSERT INTO t0 (VALUES (1, 1),(2, 2),(3, 3));\r\nSELECT c0 FROM t0 OFFSET 42949672960;\r\n```\r\nThe SELECT query runs for a very long time. I would expect it to end very shortly.\r\n\r\nWhile running this on the shell and sending the interrupt signal to it, I get:\r\nsrc/common/allocator.cpp:144: duckdb::AllocatorDebugInfo::~AllocatorDebugInfo(): Assertion `allocation_count == 0' failed\r\n\r\nMaybe this is another unrelated issue.\r\n\r\n#### heap-buffer-overflow with ART index\r\n```\r\nCREATE TABLE t0 (c0 INT AS (1), c1 INT);\r\nCREATE INDEX i0 ON t0 USING ART ((c0 + c1));\r\n```\r\nWith the address sanitizer, this results in a heap-buffer-overflow at src/common/types.cpp:36:17\r\n\r\n#### NULL pointer on complex OFFSET clause\r\n```\r\nSELECT 6 OFFSET count(*) FILTER ((SELECT 2 UNION (SELECT 2) OFFSET (SELECT LAST))) OVER ();\r\n```\r\nsrc/planner/expression_binder/order_binder.cpp:39:61: runtime error: member call on null pointer of type 'std::vector<std::unique_ptr<duckdb::ParsedExpression>>'\r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior src/planner/expression_binder/order_binder.cpp:39:61\r\n\r\n#### Analyze inexisting column (now fixed)\r\n```\r\nCREATE TABLE t0(c0 TINYINT);\r\nANALYZE t0(c4);\r\n```\r\nsrc/planner/binder/statement/bind_vacuum.cpp:35: duckdb::BoundStatement duckdb::Binder::Bind(duckdb::VacuumStatement &): Assertion `!result.HasError()' failed\r\n\r\nA proper error should be thrown.\r\n\r\n#### Analyze rowid column (now fixed)\r\n```\r\nCREATE TABLE t0(c0 INT);\r\nANALYZE t0(rowid);\r\n```\r\nsrc/storage/data_table.cpp:1319: void duckdb::DataTable::SetStatistics(duckdb::column_t, const std::function<void (BaseStatistics &)> &): Assertion `column_id != COLUMN_IDENTIFIER_ROW_ID' failed\r\n\r\nA proper error should be thrown.\r\n\r\n#### Alter table statements with rowid column\r\n```\r\nCREATE TABLE t0(c0 INTEGER, c1 INTEGER);\r\nALTER TABLE t0 DROP COLUMN rowid;\r\nALTER TABLE t0 RENAME rowid TO ups;\r\nALTER TABLE t0 ALTER rowid TYPE VARCHAR;\r\nALTER TABLE t0 ALTER rowid SET DEFAULT 0;\r\n```\r\n/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34: runtime error: addition of unsigned offset to 0x611000049880 overflowed to 0x611000049818\r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:34\r\n\r\nA proper error should be thrown.\r\n\r\n#### C-API invalid query\r\n```\r\nDuckDB db(nullptr);\r\nConnection con(db);\r\ncon.EnableQueryVerification();\r\ncon.SendQuery(\"INSERT INTO t0(VALUES(0 = (OVER = 2)));\");\r\n```\r\nTerminates the process while throwing the error.\r\n\r\nA proper error should be thrown.\r\n\r\n#### In clause optimization error\r\n```\r\nCREATE TABLE t0(c0 INT);\r\nSELECT 0 FROM t0 WHERE $0 IN (1);\r\n```\r\nsrc/optimizer/in_clause_rewriter.cpp:37: virtual unique_ptr<duckdb::Expression> duckdb::InClauseRewriter::VisitReplace(duckdb::BoundOperatorExpression &, unique_ptr<duckdb::Expression> *): Assertion `expr.children[i]->return_type == in_type' failed\r\n\r\nA proper error should be thrown.\r\n\r\n#### Lag window function issue (now fixed)\r\n```\r\nSELECT lag(1) OVER (ORDER BY 0 RANGE BETWEEN CURRENT ROW AND 1 FOLLOWING);\r\n```\r\nsrc/include/duckdb/common/types/vector.hpp:298: static bool duckdb::FlatVector::IsNull(const duckdb::Vector &, duckdb::idx_t): Assertion `vector.GetVectorType() == VectorType::FLAT_VECTOR' failed\r\n\r\nA single NULL value is expected.\r\n\r\n#### Statistics propagation mistmatch (now fixed)\r\n```\r\nPRAGMA enable_verification;\r\nSELECT CAST(\"sum\"(1) AS BIGINT) FROM (SELECT CAST((SELECT EXISTS(SELECT 1)) AS BIGINT));\r\n```\r\nError: INTERNAL Error: Statistics mismatch: value is smaller than min.\r\nStatistics: [Min: 42, Max: 42][Has Null: false, Has No Null: true][Approx Unique: 1]\r\nVector: CONSTANT BIGINT: 1 = [ 1]\r\n\r\n#### C-API IN query row index out chunk size (now fixed)\r\n```\r\nDuckDB db(nullptr);\r\nConnection con(db);\r\ncon.EnableQueryVerification();\r\ncon.SendQuery(\"SELECT(SELECT DATE '3764356-1-1' IN(1)) HAVING 0;\");\r\n```\r\nsrc/common/types/column_data_collection.cpp:98: duckdb::Value duckdb::ColumnDataRow::GetValue(duckdb::idx_t) const: Assertion `row_index < chunk.size()' failed.\r\n\r\nI would expect an unimplemented type for cast error.\r\n\r\n#### Force no cross-product issue (now fixed)\r\n```\r\nPRAGMA debug_force_no_cross_product=1;\r\nSELECT 1 FROM (SELECT 1) t0(c0), (SELECT 1) t1(c1);\r\n```\r\nError: INTERNAL Error: HyperGraph isn't connected\r\n\r\nThe query should output 1.\r\n\r\n#### Subquery error\r\n```\r\nSELECT (VALUES(1 != ALL(SELECT 2)));\r\n```\r\nsrc/common/types/vector.cpp:94: void duckdb::Vector::Reference(duckdb::Vector &): Assertion `other.GetType() == GetType()' failed.\r\n\r\nThe query should output a single true value.\r\n\r\n#### Database collation not reloaded?\r\n\r\nOn a persisted database create this table: `CREATE TABLE t0 (c0 VARCHAR(0) COLLATE AF);`.\r\nThen after the restart, will give the error: `Error: unable to open database \"<name>\": Catalog Error: Collation with name af does not exist!`\r\n\r\nI think collations need to be loaded earlier while starting a database.\r\n\r\n#### Capi error assertion (now fixed)\r\n```\r\nDuckDB db(nullptr);\r\nConnection con(db);\r\ncon.EnableQueryVerification();\r\ncon.SendQuery(\"SELECT 2 UNION(SELECT 2) ORDER BY 1;\");\r\n```\r\n\r\nsrc/main/query_result.cpp:23: void duckdb::BaseQueryResult::ThrowError(const std::string &) const: Assertion `HasError()' failed.\r\n\r\nThe query should output a single 2.\r\n\r\n#### Returning clause sizes not matching\r\n```\r\nCREATE TABLE t1(c0 INT, INT AS(1));\r\nINSERT INTO t1 VALUES (1) RETURNING *;\r\n```\r\nsrc/planner/logical_operator.cpp:57: void duckdb::LogicalOperator::ResolveOperatorTypes(): Assertion `types.size() == GetColumnBindings().size()' failed\r\n\r\nThe insert should succeed.\r\n\r\n#### Binding assertion error\r\n```\r\nCREATE TABLE t1(c0 INT);\r\nSELECT * FROM (t1 JOIN t1 t2 USING (c0, c0)), (SELECT 2);\r\n```\r\nsrc/planner/bind_context.cpp:513: void duckdb::BindContext::AddContext(duckdb::BindContext): Assertion `other_alias->bindings.find(col) == other_alias->bindings.end()' failed\r\n\r\nAn error about duplicate \"c0\" reference in using clause expected.\r\n\r\n#### Environment:\r\n - OS: Linux\r\n - DuckDB Version: Latest from the development master branch\r\n - DuckDB Client: Shell and C-API\r\n\r\n#### Identity Disclosure:\r\n - Full Name: Pedro Ferreira\r\n - Affiliation: Huawei\n",
  "hints_text": "I've made progress on this in #4474, you can assign me to this issue @hannes \nI am looking at `Database collation not reloaded?`\r\nBut I am having trouble reproducing the issue, AF is not a recognized collation name, so the first step already fails to complete:\r\n```\r\nCREATE TABLE t0 (c0 VARCHAR(0) COLLATE AF);\r\n================================================================================\r\nCatalog Error: Collation with name af does not exist!\r\nDid you mean \"nfc\"?\r\n```\r\n\r\nWhen using a recognized COLLATION no error occurs, even after restart\nI think I have the ICU extension enabled somehow. That's because `AF` shows on the collations list at `PRAGMA collations;`.\n`C-API IN query row index out chunk size`\r\nThis is not actually a C-API specific issue, I can reproduce it with the unittester as well\r\n```sql\r\n# name: test/fuzzer/pedro/force_no_cross_product.test\r\n# group: [pedro]\r\n\r\nstatement ok\r\nPRAGMA enable_verification\r\n\r\nquery I\r\nSELECT(SELECT DATE '3764356-1-1' IN(1)) HAVING 0;\r\n----\r\n\r\n```\r\nThe assertion that was being triggered is no longer triggered, but there are differences between the optimized/non-optimized result\r\n```\r\nSQL Query\r\nSELECT(SELECT DATE '3764356-1-1' IN(1)) HAVING 0;\r\n================================================================================\r\nActual result:\r\nInvalid Error: Unoptimized statement differs from original result!\r\nOriginal Result:\r\n(SELECT (CAST('3764356-1-1' AS DATE) IN (1)))\r\nBOOLEAN\r\n[ Rows: 0]\r\n\r\nUnoptimized:\r\nConversion Error: Unimplemented type for cast (INTEGER -> DATE)\r\n```\nI am noticing something strange in the capi today. Attempting to run a comment gives an assertion error:\r\n\r\nsrc/common/types/column_data_collection.cpp:79: void duckdb::ColumnDataCollection::Initialize(vector<duckdb::LogicalType>): Assertion `!types.empty()' failed\r\n\r\n```\r\nDuckDB db(nullptr);\r\nConnection con(db);\r\ncon.EnableQueryVerification();\r\ncon.SendQuery(\"--ups\");\r\n```\nThe issue in __Floating-point validation__ is that the result is parsed back as decimal after the ToString roundtrip. It is not immediately apparent to me how to solve this elegantly... I generally think it doesn't really make sense to validate the query like this since ToString is not invertible, and we should probably remove it. \r\nhttps://github.com/duckdb/duckdb/blob/0d2d7930d2789405a0d07a15e37485fe70faee3e/src/verification/statement_verifier.cpp#L76-L81\r\nThe same issue is present with maps (which shares literal syntax with, and is parsed back as, structs)\r\n\r\n```\r\nstatement ok\r\nPRAGMA enable_verification;\r\n\r\nquery I\r\nSELECT map([1, 5], ['a', 'e'])\r\n----\r\n{1=a, 5=e}\r\n```\r\n```\r\nINTERNAL Error: Assertion triggered in file \"[...]/src/verification/statement_verifier.cpp\" on line 80: parsed_list[0]->Equals(select_list[i].get())\r\n```\r\n\r\nI suspect it will also break for any extension functions that return custom logical types aliases.\nTo help with coordination Im splitting this into multiple issues and will track them on [this project](https://github.com/orgs/duckdb/projects/2/views/1). Please file separate issues if you find any more fuzzing bugs instead of updating this thread. \r\n\r\nWe should probably close this as well as soon as all the existing PR's referencing it are closed.\nSure I can create new issues from now on. One thing I mentioned on Discord is this issue:\r\n`SELECT e'\\xF0\\x9F\\x98\\x84' = '\ud83d\ude04';`\r\nOn PostgreSQL this gives true, while on DuckDB I get a parser error. I would expect both representations to match.\n> Sure I can create new issues from now on. One thing I mentioned on Discord is this issue:\r\n> `SELECT e'\\xF0\\x9F\\x98\\x84' = '\ud83d\ude04';`\r\n> On PostgreSQL this gives true, while on DuckDB I get a parser error. I would expect both representations to match.\r\n\r\nWe currently don't support the `e''` syntax, so this is expected behaviour. Inconsistency with Postgres is not always a bug.\nSo what's the way to input UTF-8 strings using hex notation?\n> So what's the way to input UTF-8 strings using hex notation?\r\n\r\nthis works `SELECT decode('\\xF0\\x9F\\x98\\x84'::BLOB) = '\ud83d\ude04';`\nOk, thanks\nThis has been converted to a bunch of different issues.",
  "created_at": "2022-09-22T16:52:12Z"
}