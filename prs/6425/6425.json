{
  "repo": "duckdb/duckdb",
  "pull_number": 6425,
  "instance_id": "duckdb__duckdb-6425",
  "issue_numbers": [
    "5878",
    "5878"
  ],
  "base_commit": "1aec9fc75e7cccfa78ef97f7449b38647da56023",
  "patch": "diff --git a/src/storage/buffer_manager.cpp b/src/storage/buffer_manager.cpp\nindex 59701d0cbe51..1a62877edacb 100644\n--- a/src/storage/buffer_manager.cpp\n+++ b/src/storage/buffer_manager.cpp\n@@ -230,6 +230,7 @@ class TemporaryDirectoryHandle {\n private:\n \tDatabaseInstance &db;\n \tstring temp_directory;\n+\tbool created_directory = false;\n \tunique_ptr<TemporaryFileManager> temp_file;\n };\n \n@@ -868,7 +869,10 @@ TemporaryDirectoryHandle::TemporaryDirectoryHandle(DatabaseInstance &db, string\n     : db(db), temp_directory(std::move(path_p)), temp_file(make_unique<TemporaryFileManager>(db, temp_directory)) {\n \tauto &fs = FileSystem::GetFileSystem(db);\n \tif (!temp_directory.empty()) {\n-\t\tfs.CreateDirectory(temp_directory);\n+\t\tif (!fs.DirectoryExists(temp_directory)) {\n+\t\t\tfs.CreateDirectory(temp_directory);\n+\t\t\tcreated_directory = true;\n+\t\t}\n \t}\n }\n TemporaryDirectoryHandle::~TemporaryDirectoryHandle() {\n@@ -877,7 +881,30 @@ TemporaryDirectoryHandle::~TemporaryDirectoryHandle() {\n \t// then delete the temporary file directory\n \tauto &fs = FileSystem::GetFileSystem(db);\n \tif (!temp_directory.empty()) {\n-\t\tfs.RemoveDirectory(temp_directory);\n+\t\tbool delete_directory = created_directory;\n+\t\tvector<string> files_to_delete;\n+\t\tif (!created_directory) {\n+\t\t\tbool deleted_everything = true;\n+\t\t\tfs.ListFiles(temp_directory, [&](const string &path, bool isdir) {\n+\t\t\t\tif (isdir) {\n+\t\t\t\t\tdeleted_everything = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tif (!StringUtil::StartsWith(path, \"duckdb_temp_\")) {\n+\t\t\t\t\tdeleted_everything = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tfiles_to_delete.push_back(path);\n+\t\t\t});\n+\t\t}\n+\t\tif (delete_directory) {\n+\t\t\t// we want to remove all files in the directory\n+\t\t\tfs.RemoveDirectory(temp_directory);\n+\t\t} else {\n+\t\t\tfor (auto &file : files_to_delete) {\n+\t\t\t\tfs.RemoveFile(fs.JoinPath(temp_directory, file));\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n@@ -887,7 +914,7 @@ TemporaryFileManager &TemporaryDirectoryHandle::GetTempFile() {\n \n string BufferManager::GetTemporaryPath(block_id_t id) {\n \tauto &fs = FileSystem::GetFileSystem(db);\n-\treturn fs.JoinPath(temp_directory, to_string(id) + \".block\");\n+\treturn fs.JoinPath(temp_directory, \"duckdb_temp_block-\" + to_string(id) + \".block\");\n }\n \n void BufferManager::RequireTemporaryDirectory() {\n",
  "test_patch": "diff --git a/tools/shell/shell-test.py b/tools/shell/shell-test.py\nindex 937e904ca185..9a1a12635f0b 100644\n--- a/tools/shell/shell-test.py\n+++ b/tools/shell/shell-test.py\n@@ -896,6 +896,41 @@ def tf():\n # null byte in error message\n test('select chr(0)::int', err='INT32')\n \n+# test temp directory behavior (issue #5878)\n+# use an existing temp directory\n+temp_dir = tf()\n+temp_file = os.path.join(temp_dir, 'myfile')\n+os.mkdir(temp_dir)\n+with open(temp_file, 'w+') as f:\n+     f.write('hello world')\n+\n+test(f'''\n+SET temp_directory='{temp_dir}';\n+PRAGMA memory_limit='2MB';\n+CREATE TABLE t1 AS SELECT * FROM range(1000000);\n+''')\n+\n+# make sure the temp directory or existing files are not deleted\n+assert os.path.isdir(temp_dir)\n+with open(temp_file, 'r') as f:\n+     assert f.read() == \"hello world\"\n+\n+# all other files are gone\n+assert os.listdir(temp_dir) == ['myfile']\n+\n+os.remove(temp_file)\n+os.rmdir(temp_dir)\n+\n+# now use a new temp directory\n+test(f'''\n+SET temp_directory='{temp_dir}';\n+PRAGMA memory_limit='2MB';\n+CREATE TABLE t1 AS SELECT * FROM range(1000000);\n+''')\n+\n+# make sure the temp directory is deleted\n+assert not os.path.isdir(temp_dir)\n+\n if os.name != 'nt':\n      shell_test_dir = 'shell_test_dir'\n      try:\n",
  "problem_statement": "DuckDB deletes `temp_directory` path rather than just its contents\n### What happens?\n\nIf I configure DuckDB to use some existing folder in my system as its temporary directory, when it cleans up the temporary directory, it deletes the folder itself rather than just its contents (i.e. the path will not exist anymore afterwards), which is something that's not obvious from the docs. Would be ideal if it could make a check for whether the folder was auto-created by duckdb or not before deleting it for good, or at least mention in the docs that it deletes the configured folder when it cleans up.\n\n### To Reproduce\n\nAdapted from the tests:\r\n```sql\r\nPRAGMA memory_limit='2MB';\r\nPRAGMA temp_directory='/some/existing/path';\r\nCREATE TABLE t2 AS SELECT * FROM range(1000000);\r\n```\r\n(Then terminate the duckdb process)\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n0.6.1\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nDavid Cortes\n\n### Affiliation:\n\nNone\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nDuckDB deletes `temp_directory` path rather than just its contents\n### What happens?\n\nIf I configure DuckDB to use some existing folder in my system as its temporary directory, when it cleans up the temporary directory, it deletes the folder itself rather than just its contents (i.e. the path will not exist anymore afterwards), which is something that's not obvious from the docs. Would be ideal if it could make a check for whether the folder was auto-created by duckdb or not before deleting it for good, or at least mention in the docs that it deletes the configured folder when it cleans up.\n\n### To Reproduce\n\nAdapted from the tests:\r\n```sql\r\nPRAGMA memory_limit='2MB';\r\nPRAGMA temp_directory='/some/existing/path';\r\nCREATE TABLE t2 AS SELECT * FROM range(1000000);\r\n```\r\n(Then terminate the duckdb process)\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n0.6.1\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nDavid Cortes\n\n### Affiliation:\n\nNone\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Apart from this being a relatively sensitive part of the codebase, I think this qualifies as a \"good first issue\"\r\n\r\nThe code lives in `src/storage/buffer_manager.cpp`, line 862\r\n```c++\r\nTemporaryDirectoryHandle::~TemporaryDirectoryHandle() {\r\n\t// first release any temporary files\r\n\ttemp_file.reset();\r\n\t// then delete the temporary file directory\r\n\tauto &fs = FileSystem::GetFileSystem(db);\r\n\tif (!temp_directory.empty()) {\r\n\t\tfs.RemoveDirectory(temp_directory);\r\n\t}\r\n}\r\n```\r\nOn creation of the directory handle it should check whether the folder exists or not, then save that in a boolean so we can act accordingly (maybe make a subfolder within that folder that we can delete)\r\nOr just throw an InvalidInputException stating that this folder can't exist yet, because it needs to be managed by duckdb and deleted afterwards\r\n\r\nIf we don't create a folder that we can delete we have to manage the individual files, which would be a more involved change\n> Apart from this being a relatively sensitive part of the codebase, I think this qualifies as a \"good first issue\"\r\n> \r\n> The code lives in `src/storage/buffer_manager.cpp`, line 862\r\n> \r\n> ```c++\r\n> TemporaryDirectoryHandle::~TemporaryDirectoryHandle() {\r\n> \t// first release any temporary files\r\n> \ttemp_file.reset();\r\n> \t// then delete the temporary file directory\r\n> \tauto &fs = FileSystem::GetFileSystem(db);\r\n> \tif (!temp_directory.empty()) {\r\n> \t\tfs.RemoveDirectory(temp_directory);\r\n> \t}\r\n> }\r\n> ```\r\n> \r\n> On creation of the directory handle it should check whether the folder exists or not, then save that in a boolean so we can act accordingly (maybe make a subfolder within that folder that we can delete) Or just throw an InvalidInputException stating that this folder can't exist yet, because it needs to be managed by duckdb and deleted afterwards\r\n> \r\n> If we don't create a folder that we can delete we have to manage the individual files, which would be a more involved change\r\n\r\nOne thing to consider there is if DuckDB exits unexpectedly (e.g. due to a power outage or crash) temporary files might be left behind. We might want to name the temporary files predictably (e.g. `duckdb_temp_{id}.tmp` or so) and do a glob delete of files in the directory that match that pattern. If the directory is empty after deleting all temporary duckdb files we can delete the entire directory.\nApart from this being a relatively sensitive part of the codebase, I think this qualifies as a \"good first issue\"\r\n\r\nThe code lives in `src/storage/buffer_manager.cpp`, line 862\r\n```c++\r\nTemporaryDirectoryHandle::~TemporaryDirectoryHandle() {\r\n\t// first release any temporary files\r\n\ttemp_file.reset();\r\n\t// then delete the temporary file directory\r\n\tauto &fs = FileSystem::GetFileSystem(db);\r\n\tif (!temp_directory.empty()) {\r\n\t\tfs.RemoveDirectory(temp_directory);\r\n\t}\r\n}\r\n```\r\nOn creation of the directory handle it should check whether the folder exists or not, then save that in a boolean so we can act accordingly (maybe make a subfolder within that folder that we can delete)\r\nOr just throw an InvalidInputException stating that this folder can't exist yet, because it needs to be managed by duckdb and deleted afterwards\r\n\r\nIf we don't create a folder that we can delete we have to manage the individual files, which would be a more involved change\n> Apart from this being a relatively sensitive part of the codebase, I think this qualifies as a \"good first issue\"\r\n> \r\n> The code lives in `src/storage/buffer_manager.cpp`, line 862\r\n> \r\n> ```c++\r\n> TemporaryDirectoryHandle::~TemporaryDirectoryHandle() {\r\n> \t// first release any temporary files\r\n> \ttemp_file.reset();\r\n> \t// then delete the temporary file directory\r\n> \tauto &fs = FileSystem::GetFileSystem(db);\r\n> \tif (!temp_directory.empty()) {\r\n> \t\tfs.RemoveDirectory(temp_directory);\r\n> \t}\r\n> }\r\n> ```\r\n> \r\n> On creation of the directory handle it should check whether the folder exists or not, then save that in a boolean so we can act accordingly (maybe make a subfolder within that folder that we can delete) Or just throw an InvalidInputException stating that this folder can't exist yet, because it needs to be managed by duckdb and deleted afterwards\r\n> \r\n> If we don't create a folder that we can delete we have to manage the individual files, which would be a more involved change\r\n\r\nOne thing to consider there is if DuckDB exits unexpectedly (e.g. due to a power outage or crash) temporary files might be left behind. We might want to name the temporary files predictably (e.g. `duckdb_temp_{id}.tmp` or so) and do a glob delete of files in the directory that match that pattern. If the directory is empty after deleting all temporary duckdb files we can delete the entire directory.",
  "created_at": "2023-02-22T15:03:33Z"
}