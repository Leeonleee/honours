diff --git a/src/function/table/system/test_all_types.cpp b/src/function/table/system/test_all_types.cpp
index db1e261a405c..cfb5213c0196 100644
--- a/src/function/table/system/test_all_types.cpp
+++ b/src/function/table/system/test_all_types.cpp
@@ -167,11 +167,8 @@ static vector<TestType> GetTestTypes() {
 	return result;
 }
 
-static unique_ptr<FunctionData> TestAllTypesBind(ClientContext &context, vector<Value> &inputs,
-                                                 named_parameter_map_t &named_parameters,
-                                                 vector<LogicalType> &input_table_types,
-                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                 vector<string> &names) {
+static unique_ptr<FunctionData> TestAllTypesBind(ClientContext &context, TableFunctionBindInput &input,
+                                                 vector<LogicalType> &return_types, vector<string> &names) {
 	auto test_types = GetTestTypes();
 	for (auto &test_type : test_types) {
 		return_types.push_back(move(test_type.type));
diff --git a/test/api/capi/CMakeLists.txt b/test/api/capi/CMakeLists.txt
index 834d2ccee31c..cc836b26de02 100644
--- a/test/api/capi/CMakeLists.txt
+++ b/test/api/capi/CMakeLists.txt
@@ -1,4 +1,16 @@
-add_library_unity(test_sql_capi OBJECT test_capi.cpp test_starting_database.cpp)
+add_library_unity(
+  test_sql_capi
+  OBJECT
+  capi_table_functions.cpp
+  test_capi.cpp
+  test_starting_database.cpp
+  test_capi_appender.cpp
+  test_capi_arrow.cpp
+  test_capi_data_chunk.cpp
+  test_capi_prepared.cpp
+  test_capi_website.cpp
+  test_capi_complex_types.cpp
+  test_capi_replacement_scan.cpp)
 set(ALL_OBJECT_FILES
     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:test_sql_capi>
     PARENT_SCOPE)
diff --git a/test/api/capi/capi_table_functions.cpp b/test/api/capi/capi_table_functions.cpp
new file mode 100644
index 000000000000..9665efef2df4
--- /dev/null
+++ b/test/api/capi/capi_table_functions.cpp
@@ -0,0 +1,140 @@
+#include "capi_tester.hpp"
+
+using namespace duckdb;
+using namespace std;
+
+struct my_bind_data_struct {
+	int64_t size;
+};
+
+void my_bind(duckdb_bind_info info) {
+	REQUIRE(duckdb_bind_get_parameter_count(info) == 1);
+
+	duckdb_logical_type type = duckdb_create_logical_type(DUCKDB_TYPE_BIGINT);
+	duckdb_bind_add_result_column(info, "forty_two", type);
+	duckdb_destroy_logical_type(&type);
+
+	auto my_bind_data = (my_bind_data_struct *)malloc(sizeof(my_bind_data_struct));
+	auto param = duckdb_bind_get_parameter(info, 0);
+	my_bind_data->size = duckdb_get_int64(param);
+	duckdb_destroy_value(&param);
+
+	duckdb_bind_set_bind_data(info, my_bind_data, free);
+}
+
+struct my_init_data_struct {
+	int64_t pos;
+};
+
+void my_init(duckdb_init_info info) {
+	REQUIRE(duckdb_init_get_bind_data(info) != nullptr);
+	REQUIRE(duckdb_init_get_bind_data(nullptr) == nullptr);
+
+	auto my_init_data = (my_init_data_struct *)malloc(sizeof(my_init_data_struct));
+	my_init_data->pos = 0;
+	duckdb_init_set_init_data(info, my_init_data, free);
+}
+
+void my_function(duckdb_function_info info, duckdb_data_chunk output) {
+	auto bind_data = (my_bind_data_struct *)duckdb_function_get_bind_data(info);
+	auto init_data = (my_init_data_struct *)duckdb_function_get_init_data(info);
+	auto ptr = (int64_t *)duckdb_vector_get_data(duckdb_data_chunk_get_vector(output, 0));
+	idx_t i;
+	for (i = 0; i < STANDARD_VECTOR_SIZE; i++) {
+		if (init_data->pos >= bind_data->size) {
+			break;
+		}
+		ptr[i] = init_data->pos % 2 == 0 ? 42 : 84;
+		init_data->pos++;
+	}
+	duckdb_data_chunk_set_size(output, i);
+}
+
+static void capi_register_table_function(duckdb_connection connection, const char *name,
+                                         duckdb_table_function_bind_t bind, duckdb_table_function_init_t init,
+                                         duckdb_table_function_t f) {
+	duckdb_state status;
+
+	// create a table function
+	auto function = duckdb_create_table_function();
+	duckdb_table_function_set_name(nullptr, name);
+	duckdb_table_function_set_name(function, nullptr);
+	duckdb_table_function_set_name(function, name);
+	duckdb_table_function_set_name(function, name);
+
+	// add a string parameter
+	duckdb_logical_type type = duckdb_create_logical_type(DUCKDB_TYPE_BIGINT);
+	duckdb_table_function_add_parameter(function, type);
+	duckdb_destroy_logical_type(&type);
+
+	// set up the function pointers
+	duckdb_table_function_set_bind(function, bind);
+	duckdb_table_function_set_init(function, init);
+	duckdb_table_function_set_function(function, f);
+
+	// register and cleanup
+	status = duckdb_register_table_function(connection, function);
+	REQUIRE(status == DuckDBSuccess);
+
+	duckdb_destroy_table_function(&function);
+	duckdb_destroy_table_function(&function);
+	duckdb_destroy_table_function(nullptr);
+}
+
+TEST_CASE("Test Table Functions C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+
+	REQUIRE(tester.OpenDatabase(nullptr));
+	capi_register_table_function(tester.connection, "my_function", my_bind, my_init, my_function);
+
+	// now call it
+	result = tester.Query("SELECT * FROM my_function(1)");
+	REQUIRE_NO_FAIL(*result);
+	REQUIRE(result->Fetch<int64_t>(0, 0) == 42);
+
+	result = tester.Query("SELECT * FROM my_function(3)");
+	REQUIRE_NO_FAIL(*result);
+	REQUIRE(result->Fetch<int64_t>(0, 0) == 42);
+	REQUIRE(result->Fetch<int64_t>(0, 1) == 84);
+	REQUIRE(result->Fetch<int64_t>(0, 2) == 42);
+
+	result = tester.Query("SELECT forty_two, COUNT(*) FROM my_function(10000) GROUP BY 1 ORDER BY 1");
+	REQUIRE_NO_FAIL(*result);
+	REQUIRE(result->Fetch<int64_t>(0, 0) == 42);
+	REQUIRE(result->Fetch<int64_t>(0, 1) == 84);
+	REQUIRE(result->Fetch<int64_t>(1, 0) == 5000);
+	REQUIRE(result->Fetch<int64_t>(1, 1) == 5000);
+}
+
+void my_error_bind(duckdb_bind_info info) {
+	duckdb_bind_set_error(nullptr, nullptr);
+	duckdb_bind_set_error(info, "My error message");
+}
+
+void my_error_init(duckdb_init_info info) {
+	duckdb_init_set_error(nullptr, nullptr);
+	duckdb_init_set_error(info, "My error message");
+}
+
+void my_error_function(duckdb_function_info info, duckdb_data_chunk output) {
+	duckdb_function_set_error(nullptr, nullptr);
+	duckdb_function_set_error(info, "My error message");
+}
+
+TEST_CASE("Test Table Function errors in C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+
+	REQUIRE(tester.OpenDatabase(nullptr));
+	capi_register_table_function(tester.connection, "my_error_bind", my_error_bind, my_init, my_function);
+	capi_register_table_function(tester.connection, "my_error_init", my_bind, my_error_init, my_function);
+	capi_register_table_function(tester.connection, "my_error_function", my_bind, my_init, my_error_function);
+
+	result = tester.Query("SELECT * FROM my_error_bind(1)");
+	REQUIRE(!result->success);
+	result = tester.Query("SELECT * FROM my_error_init(1)");
+	REQUIRE(!result->success);
+	result = tester.Query("SELECT * FROM my_error_function(1)");
+	REQUIRE(!result->success);
+}
diff --git a/test/api/capi/test_capi.cpp b/test/api/capi/test_capi.cpp
index 49bf7c4b4478..60e54ea425ef 100644
--- a/test/api/capi/test_capi.cpp
+++ b/test/api/capi/test_capi.cpp
@@ -1,244 +1,8 @@
-#include "catch.hpp"
-#include "duckdb.h"
-#include "test_helpers.hpp"
-#include "duckdb/common/arrow.hpp"
-#include "duckdb/common/exception.hpp"
+#include "capi_tester.hpp"
 
 using namespace duckdb;
 using namespace std;
 
-class CAPIResult {
-public:
-	~CAPIResult() {
-		duckdb_destroy_result(&result);
-	}
-	void Query(duckdb_connection connection, string query) {
-		success = (duckdb_query(connection, query.c_str(), &result) == DuckDBSuccess);
-		if (!success) {
-			REQUIRE(ErrorMessage() != nullptr);
-		}
-	}
-
-	duckdb_type ColumnType(idx_t col) {
-		return duckdb_column_type(&result, col);
-	}
-
-	template <class T>
-	T *ColumnData(idx_t col) {
-		return (T *)duckdb_column_data(&result, col);
-	}
-
-	idx_t ColumnCount() {
-		return duckdb_column_count(&result);
-	}
-
-	idx_t row_count() {
-		return duckdb_row_count(&result);
-	}
-
-	idx_t rows_changed() {
-		return duckdb_rows_changed(&result);
-	}
-
-	template <class T>
-	T Fetch(idx_t col, idx_t row) {
-		throw NotImplementedException("Unimplemented type for fetch");
-	}
-
-	bool IsNull(idx_t col, idx_t row) {
-		auto nullmask_ptr = duckdb_nullmask_data(&result, col);
-		REQUIRE(duckdb_value_is_null(&result, col, row) == nullmask_ptr[row]);
-		return nullmask_ptr[row];
-	}
-
-	char *ErrorMessage() {
-		return duckdb_result_error(&result);
-	}
-
-	string ColumnName(idx_t col) {
-		auto colname = duckdb_column_name(&result, col);
-		return colname ? string(colname) : string();
-	}
-
-	duckdb_result &InternalResult() {
-		return result;
-	}
-
-public:
-	bool success = false;
-
-private:
-	duckdb_result result;
-};
-
-static bool NO_FAIL(CAPIResult &result) {
-	return result.success;
-}
-
-static bool NO_FAIL(unique_ptr<CAPIResult> result) {
-	return NO_FAIL(*result);
-}
-
-template <>
-bool CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_boolean(&result, col, row);
-}
-
-template <>
-int8_t CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_int8(&result, col, row);
-}
-
-template <>
-int16_t CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_int16(&result, col, row);
-}
-
-template <>
-int32_t CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_int32(&result, col, row);
-}
-
-template <>
-int64_t CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_int64(&result, col, row);
-}
-
-template <>
-uint8_t CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_uint8(&result, col, row);
-}
-
-template <>
-uint16_t CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_uint16(&result, col, row);
-}
-
-template <>
-uint32_t CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_uint32(&result, col, row);
-}
-
-template <>
-uint64_t CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_uint64(&result, col, row);
-}
-
-template <>
-float CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_float(&result, col, row);
-}
-
-template <>
-double CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_double(&result, col, row);
-}
-
-template <>
-duckdb_decimal CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_decimal(&result, col, row);
-}
-
-template <>
-duckdb_date CAPIResult::Fetch(idx_t col, idx_t row) {
-	auto data = (duckdb_date *)duckdb_column_data(&result, col);
-	return data[row];
-}
-
-template <>
-duckdb_time CAPIResult::Fetch(idx_t col, idx_t row) {
-	auto data = (duckdb_time *)duckdb_column_data(&result, col);
-	return data[row];
-}
-
-template <>
-duckdb_timestamp CAPIResult::Fetch(idx_t col, idx_t row) {
-	auto data = (duckdb_timestamp *)duckdb_column_data(&result, col);
-	return data[row];
-}
-
-template <>
-duckdb_interval CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_interval(&result, col, row);
-}
-
-template <>
-duckdb_blob CAPIResult::Fetch(idx_t col, idx_t row) {
-	auto data = (duckdb_blob *)duckdb_column_data(&result, col);
-	return data[row];
-}
-
-template <>
-string CAPIResult::Fetch(idx_t col, idx_t row) {
-	auto value = duckdb_value_varchar(&result, col, row);
-	string strval = value ? string(value) : string();
-	free((void *)value);
-	return strval;
-}
-
-template <>
-duckdb_date_struct CAPIResult::Fetch(idx_t col, idx_t row) {
-	auto value = duckdb_value_date(&result, col, row);
-	return duckdb_from_date(value);
-}
-
-template <>
-duckdb_time_struct CAPIResult::Fetch(idx_t col, idx_t row) {
-	auto value = duckdb_value_time(&result, col, row);
-	return duckdb_from_time(value);
-}
-
-template <>
-duckdb_timestamp_struct CAPIResult::Fetch(idx_t col, idx_t row) {
-	auto value = duckdb_value_timestamp(&result, col, row);
-	return duckdb_from_timestamp(value);
-}
-
-template <>
-duckdb_hugeint CAPIResult::Fetch(idx_t col, idx_t row) {
-	return duckdb_value_hugeint(&result, col, row);
-}
-
-class CAPITester {
-public:
-	CAPITester() : database(nullptr), connection(nullptr) {
-	}
-	~CAPITester() {
-		Cleanup();
-	}
-
-	void Cleanup() {
-		if (connection) {
-			duckdb_disconnect(&connection);
-			connection = nullptr;
-		}
-		if (database) {
-			duckdb_close(&database);
-			database = nullptr;
-		}
-	}
-
-	bool OpenDatabase(const char *path) {
-		Cleanup();
-		if (duckdb_open(path, &database) != DuckDBSuccess) {
-			return false;
-		}
-		if (duckdb_connect(database, &connection) != DuckDBSuccess) {
-			return false;
-		}
-		return true;
-	}
-
-	unique_ptr<CAPIResult> Query(string query) {
-		auto result = make_unique<CAPIResult>();
-		result->Query(connection, query);
-		return result;
-	}
-
-	duckdb_database database = nullptr;
-	duckdb_connection connection = nullptr;
-};
-
 TEST_CASE("Basic test of C API", "[capi]") {
 	CAPITester tester;
 	unique_ptr<CAPIResult> result;
@@ -258,6 +22,8 @@ TEST_CASE("Basic test of C API", "[capi]") {
 	// out of range fetch
 	REQUIRE(result->Fetch<int64_t>(1, 0) == 0);
 	REQUIRE(result->Fetch<int64_t>(0, 1) == 0);
+	// cannot fetch data chunk after using the value API
+	REQUIRE(result->FetchChunk(0) == nullptr);
 
 	// select scalar NULL
 	result = tester.Query("SELECT NULL");
@@ -431,33 +197,6 @@ TEST_CASE("Test different types of C API", "[capi]") {
 	REQUIRE(date.day == 20);
 	REQUIRE(result->Fetch<string>(0, 2) == Value::DATE(30000, 9, 20).ToString());
 
-	// timestamp columns
-	REQUIRE_NO_FAIL(tester.Query(
-	    "CREATE TABLE timestamp (sec TIMESTAMP_S, milli TIMESTAMP_MS,micro TIMESTAMP_US, nano TIMESTAMP_NS );"));
-	REQUIRE_NO_FAIL(tester.Query("INSERT INTO timestamp VALUES (NULL,NULL,NULL,NULL )"));
-	REQUIRE_NO_FAIL(tester.Query("INSERT INTO timestamp VALUES ('1992-09-20 12:01:30','1992-09-20 "
-	                             "12:01:30','1992-09-20 12:01:30','1992-09-20 12:01:30')"));
-
-	result = tester.Query("SELECT * FROM timestamp ORDER BY sec");
-	REQUIRE_NO_FAIL(*result);
-	REQUIRE(result->IsNull(0, 0));
-	REQUIRE(result->IsNull(1, 0));
-	REQUIRE(result->IsNull(2, 0));
-	REQUIRE(result->IsNull(3, 0));
-	for (idx_t i = 0; i < 4; i++) {
-		duckdb_timestamp_struct stamp = duckdb_from_timestamp(result->Fetch<duckdb_timestamp>(i, 1));
-		REQUIRE(stamp.date.year == 1992);
-		REQUIRE(stamp.date.month == 9);
-		REQUIRE(stamp.date.day == 20);
-		REQUIRE(stamp.time.hour == 12);
-		REQUIRE(stamp.time.min == 1);
-		REQUIRE(stamp.time.sec == 30);
-		REQUIRE(stamp.time.micros == 0);
-		auto result_string = result->Fetch<string>(i, 1);
-		auto timestamp_string = Value::TIMESTAMP(1992, 9, 20, 12, 1, 30, 0).ToString();
-		REQUIRE(result->Fetch<string>(i, 1) == timestamp_string);
-	}
-
 	// time columns
 	REQUIRE_NO_FAIL(tester.Query("CREATE TABLE times(d TIME)"));
 	REQUIRE_NO_FAIL(tester.Query("INSERT INTO times VALUES ('12:00:30.1234'), (NULL), ('02:30:01')"));
@@ -583,744 +322,6 @@ TEST_CASE("Test errors in C API", "[capi]") {
 	REQUIRE(d.day == 1);
 }
 
-TEST_CASE("Test prepared statements in C API", "[capi]") {
-	CAPITester tester;
-	unique_ptr<CAPIResult> result;
-	duckdb_result res;
-	duckdb_prepared_statement stmt = nullptr;
-	duckdb_state status;
-
-	// open the database in in-memory mode
-	REQUIRE(tester.OpenDatabase(nullptr));
-
-	status = duckdb_prepare(tester.connection, "SELECT CAST($1 AS BIGINT)", &stmt);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(stmt != nullptr);
-
-	status = duckdb_bind_boolean(stmt, 1, 1);
-	REQUIRE(status == DuckDBSuccess);
-	status = duckdb_bind_boolean(stmt, 2, 1);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_int64(&res, 0, 0) == 1);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_int8(stmt, 1, 8);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_int64(&res, 0, 0) == 8);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_int16(stmt, 1, 16);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_int64(&res, 0, 0) == 16);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_int32(stmt, 1, 32);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_int64(&res, 0, 0) == 32);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_int64(stmt, 1, 64);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_int64(&res, 0, 0) == 64);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_hugeint(stmt, 1, duckdb_double_to_hugeint(64));
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_hugeint_to_double(duckdb_value_hugeint(&res, 0, 0)) == 64.0);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_uint8(stmt, 1, 8);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_uint8(&res, 0, 0) == 8);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_uint16(stmt, 1, 8);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_uint16(&res, 0, 0) == 8);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_uint32(stmt, 1, 8);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_uint32(&res, 0, 0) == 8);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_uint64(stmt, 1, 8);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_uint64(&res, 0, 0) == 8);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_float(stmt, 1, 42.0);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_int64(&res, 0, 0) == 42);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_double(stmt, 1, 43.0);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_int64(&res, 0, 0) == 43);
-	duckdb_destroy_result(&res);
-
-	REQUIRE(duckdb_bind_float(stmt, 1, NAN) == DuckDBError);
-	REQUIRE(duckdb_bind_double(stmt, 1, NAN) == DuckDBError);
-
-	duckdb_bind_varchar(stmt, 1, "44");
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_int64(&res, 0, 0) == 44);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_null(stmt, 1);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_nullmask_data(&res, 0)[0] == true);
-	duckdb_destroy_result(&res);
-
-	duckdb_destroy_prepare(&stmt);
-	// again to make sure it does not crash
-	duckdb_destroy_result(&res);
-	duckdb_destroy_prepare(&stmt);
-
-	status = duckdb_prepare(tester.connection, "SELECT CAST($1 AS VARCHAR)", &stmt);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(stmt != nullptr);
-
-	duckdb_bind_varchar_length(stmt, 1, "hello world", 5);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	auto value = duckdb_value_varchar(&res, 0, 0);
-	REQUIRE(string(value) == "hello");
-	REQUIRE(duckdb_value_int8(&res, 0, 0) == 0);
-	duckdb_free(value);
-	duckdb_destroy_result(&res);
-
-	duckdb_bind_blob(stmt, 1, "hello\0world", 11);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	value = duckdb_value_varchar(&res, 0, 0);
-	REQUIRE(string(value) == "hello\\x00world");
-	REQUIRE(duckdb_value_int8(&res, 0, 0) == 0);
-	duckdb_free(value);
-	duckdb_destroy_result(&res);
-
-	duckdb_date_struct date_struct;
-	date_struct.year = 1992;
-	date_struct.month = 9;
-	date_struct.day = 3;
-
-	duckdb_bind_date(stmt, 1, duckdb_to_date(date_struct));
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	value = duckdb_value_varchar(&res, 0, 0);
-	REQUIRE(string(value) == "1992-09-03");
-	duckdb_free(value);
-	duckdb_destroy_result(&res);
-
-	duckdb_time_struct time_struct;
-	time_struct.hour = 12;
-	time_struct.min = 22;
-	time_struct.sec = 33;
-	time_struct.micros = 123400;
-
-	duckdb_bind_time(stmt, 1, duckdb_to_time(time_struct));
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	value = duckdb_value_varchar(&res, 0, 0);
-	REQUIRE(string(value) == "12:22:33.1234");
-	duckdb_free(value);
-	duckdb_destroy_result(&res);
-
-	duckdb_timestamp_struct ts;
-	ts.date = date_struct;
-	ts.time = time_struct;
-
-	duckdb_bind_timestamp(stmt, 1, duckdb_to_timestamp(ts));
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	value = duckdb_value_varchar(&res, 0, 0);
-	REQUIRE(string(value) == "1992-09-03 12:22:33.1234");
-	duckdb_free(value);
-	duckdb_destroy_result(&res);
-
-	duckdb_interval interval;
-	interval.months = 3;
-	interval.days = 0;
-	interval.micros = 0;
-
-	duckdb_bind_interval(stmt, 1, interval);
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	value = duckdb_value_varchar(&res, 0, 0);
-	REQUIRE(string(value) == "3 months");
-	duckdb_free(value);
-	duckdb_destroy_result(&res);
-
-	duckdb_destroy_prepare(&stmt);
-
-	status = duckdb_query(tester.connection, "CREATE TABLE a (i INTEGER)", NULL);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_prepare(tester.connection, "INSERT INTO a VALUES (?)", &stmt);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(stmt != nullptr);
-	REQUIRE(duckdb_nparams(nullptr) == 0);
-	REQUIRE(duckdb_nparams(stmt) == 1);
-	REQUIRE(duckdb_param_type(nullptr, 0) == DUCKDB_TYPE_INVALID);
-	REQUIRE(duckdb_param_type(stmt, 0) == DUCKDB_TYPE_INVALID);
-	REQUIRE(duckdb_param_type(stmt, 1) == DUCKDB_TYPE_INTEGER);
-	REQUIRE(duckdb_param_type(stmt, 2) == DUCKDB_TYPE_INVALID);
-
-	for (int32_t i = 1; i <= 1000; i++) {
-		duckdb_bind_int32(stmt, 1, i);
-		status = duckdb_execute_prepared(stmt, nullptr);
-		REQUIRE(status == DuckDBSuccess);
-	}
-	duckdb_destroy_prepare(&stmt);
-
-	status = duckdb_prepare(tester.connection, "SELECT SUM(i)*$1-$2 FROM a", &stmt);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(stmt != nullptr);
-	duckdb_bind_int32(stmt, 1, 2);
-	duckdb_bind_int32(stmt, 2, 1000);
-
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_value_int32(&res, 0, 0) == 1000000);
-	duckdb_destroy_result(&res);
-	duckdb_destroy_prepare(&stmt);
-
-	// not-so-happy path
-	status = duckdb_prepare(tester.connection, "SELECT XXXXX", &stmt);
-	REQUIRE(status == DuckDBError);
-	duckdb_destroy_prepare(&stmt);
-
-	status = duckdb_prepare(tester.connection, "SELECT CAST($1 AS INTEGER)", &stmt);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(stmt != nullptr);
-
-	status = duckdb_execute_prepared(stmt, &res);
-	REQUIRE(status == DuckDBError);
-	duckdb_destroy_result(&res);
-	duckdb_destroy_prepare(&stmt);
-
-	// test duckdb_malloc explicitly
-	auto malloced_data = duckdb_malloc(100);
-	memcpy(malloced_data, "hello\0", 6);
-	REQUIRE(string((char *)malloced_data) == "hello");
-	duckdb_free(malloced_data);
-}
-
-TEST_CASE("Test appender statements in C API", "[capi]") {
-	CAPITester tester;
-	unique_ptr<CAPIResult> result;
-	duckdb_state status;
-
-	// open the database in in-memory mode
-	REQUIRE(tester.OpenDatabase(nullptr));
-
-	tester.Query("CREATE TABLE test (i INTEGER, d double, s string)");
-	duckdb_appender appender;
-
-	status = duckdb_appender_create(tester.connection, nullptr, "nonexistant-table", &appender);
-	REQUIRE(status == DuckDBError);
-	REQUIRE(appender != nullptr);
-	REQUIRE(duckdb_appender_error(appender) != nullptr);
-	REQUIRE(duckdb_appender_destroy(&appender) == DuckDBSuccess);
-	REQUIRE(duckdb_appender_destroy(nullptr) == DuckDBError);
-
-	status = duckdb_appender_create(tester.connection, nullptr, "test", nullptr);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_appender_create(tester.connection, nullptr, "test", &appender);
-	REQUIRE(status == DuckDBSuccess);
-	REQUIRE(duckdb_appender_error(appender) == nullptr);
-
-	status = duckdb_appender_begin_row(appender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_int32(appender, 42);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_double(appender, 4.2);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_varchar(appender, "Hello, World");
-	REQUIRE(status == DuckDBSuccess);
-
-	// out of cols here
-	status = duckdb_append_int32(appender, 42);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_appender_end_row(appender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_appender_flush(appender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_appender_begin_row(appender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_int32(appender, 42);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_double(appender, 4.2);
-	REQUIRE(status == DuckDBSuccess);
-
-	// not enough cols here
-	status = duckdb_appender_end_row(appender);
-	REQUIRE(status == DuckDBError);
-	REQUIRE(duckdb_appender_error(appender) != nullptr);
-
-	status = duckdb_append_varchar(appender, "Hello, World");
-	REQUIRE(status == DuckDBSuccess);
-
-	// out of cols here
-	status = duckdb_append_int32(appender, 42);
-	REQUIRE(status == DuckDBError);
-
-	REQUIRE(duckdb_appender_error(appender) != nullptr);
-
-	status = duckdb_appender_end_row(appender);
-	REQUIRE(status == DuckDBSuccess);
-
-	// we can flush again why not
-	status = duckdb_appender_flush(appender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_appender_close(appender);
-	REQUIRE(status == DuckDBSuccess);
-
-	result = tester.Query("SELECT * FROM test");
-	REQUIRE_NO_FAIL(*result);
-	REQUIRE(result->Fetch<int32_t>(0, 0) == 42);
-	REQUIRE(result->Fetch<double>(1, 0) == 4.2);
-	REQUIRE(result->Fetch<string>(2, 0) == "Hello, World");
-
-	status = duckdb_appender_destroy(&appender);
-	REQUIRE(status == DuckDBSuccess);
-
-	// this has been destroyed
-
-	status = duckdb_appender_close(appender);
-	REQUIRE(status == DuckDBError);
-	REQUIRE(duckdb_appender_error(appender) == nullptr);
-
-	status = duckdb_appender_flush(appender);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_appender_end_row(appender);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_append_int32(appender, 42);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_appender_destroy(&appender);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_appender_close(nullptr);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_appender_flush(nullptr);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_appender_end_row(nullptr);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_append_int32(nullptr, 42);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_appender_destroy(nullptr);
-	REQUIRE(status == DuckDBError);
-
-	status = duckdb_appender_destroy(nullptr);
-	REQUIRE(status == DuckDBError);
-
-	// many types
-	REQUIRE_NO_FAIL(tester.Query("CREATE TABLE many_types(bool boolean, t TINYINT, s SMALLINT, b BIGINT, ut UTINYINT, "
-	                             "us USMALLINT, ui UINTEGER, ub UBIGINT, uf REAL, ud DOUBLE, txt VARCHAR, blb BLOB, dt "
-	                             "DATE, tm TIME, ts TIMESTAMP, ival INTERVAL, h HUGEINT)"));
-	duckdb_appender tappender;
-
-	status = duckdb_appender_create(tester.connection, nullptr, "many_types", &tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_appender_begin_row(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_bool(tappender, true);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_int8(tappender, 1);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_int16(tappender, 1);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_int64(tappender, 1);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_uint8(tappender, 1);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_uint16(tappender, 1);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_uint32(tappender, 1);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_uint64(tappender, 1);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_float(tappender, 0.5f);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_double(tappender, 0.5);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_varchar_length(tappender, "hello world", 5);
-	REQUIRE(status == DuckDBSuccess);
-
-	duckdb_date_struct date_struct;
-	date_struct.year = 1992;
-	date_struct.month = 9;
-	date_struct.day = 3;
-
-	auto str = strdup("hello world this is my long string");
-	status = duckdb_append_blob(tappender, str, strlen(str));
-	free(str);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_date(tappender, duckdb_to_date(date_struct));
-	REQUIRE(status == DuckDBSuccess);
-
-	duckdb_time_struct time_struct;
-	time_struct.hour = 12;
-	time_struct.min = 22;
-	time_struct.sec = 33;
-	time_struct.micros = 1234;
-
-	status = duckdb_append_time(tappender, duckdb_to_time(time_struct));
-	REQUIRE(status == DuckDBSuccess);
-
-	duckdb_timestamp_struct ts;
-	ts.date = date_struct;
-	ts.time = time_struct;
-
-	status = duckdb_append_timestamp(tappender, duckdb_to_timestamp(ts));
-	REQUIRE(status == DuckDBSuccess);
-
-	duckdb_interval interval;
-	interval.months = 3;
-	interval.days = 0;
-	interval.micros = 0;
-
-	status = duckdb_append_interval(tappender, interval);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_hugeint(tappender, duckdb_double_to_hugeint(27));
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_appender_end_row(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_appender_begin_row(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_append_null(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_appender_end_row(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_appender_flush(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_appender_close(tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	status = duckdb_appender_destroy(&tappender);
-	REQUIRE(status == DuckDBSuccess);
-
-	result = tester.Query("SELECT * FROM many_types");
-	REQUIRE_NO_FAIL(*result);
-	REQUIRE(result->Fetch<bool>(0, 0) == true);
-	REQUIRE(result->Fetch<int8_t>(1, 0) == 1);
-	REQUIRE(result->Fetch<int16_t>(2, 0) == 1);
-	REQUIRE(result->Fetch<int64_t>(3, 0) == 1);
-	REQUIRE(result->Fetch<uint8_t>(4, 0) == 1);
-	REQUIRE(result->Fetch<uint16_t>(5, 0) == 1);
-	REQUIRE(result->Fetch<uint32_t>(6, 0) == 1);
-	REQUIRE(result->Fetch<uint64_t>(7, 0) == 1);
-	REQUIRE(result->Fetch<float>(8, 0) == 0.5f);
-	REQUIRE(result->Fetch<double>(9, 0) == 0.5);
-	REQUIRE(result->Fetch<string>(10, 0) == "hello");
-
-	auto blob = duckdb_value_blob(&result->InternalResult(), 11, 0);
-	REQUIRE(blob.size == 34);
-	REQUIRE(memcmp(blob.data, "hello world this is my long string", 34) == 0);
-	duckdb_free(blob.data);
-	REQUIRE(duckdb_value_int32(&result->InternalResult(), 11, 0) == 0);
-
-	auto date = result->Fetch<duckdb_date_struct>(12, 0);
-	REQUIRE(date.year == 1992);
-	REQUIRE(date.month == 9);
-	REQUIRE(date.day == 3);
-
-	auto time = result->Fetch<duckdb_time_struct>(13, 0);
-	REQUIRE(time.hour == 12);
-	REQUIRE(time.min == 22);
-	REQUIRE(time.sec == 33);
-	REQUIRE(time.micros == 1234);
-
-	auto timestamp = result->Fetch<duckdb_timestamp_struct>(14, 0);
-	REQUIRE(timestamp.date.year == 1992);
-	REQUIRE(timestamp.date.month == 9);
-	REQUIRE(timestamp.date.day == 3);
-	REQUIRE(timestamp.time.hour == 12);
-	REQUIRE(timestamp.time.min == 22);
-	REQUIRE(timestamp.time.sec == 33);
-	REQUIRE(timestamp.time.micros == 1234);
-
-	interval = result->Fetch<duckdb_interval>(15, 0);
-	REQUIRE(interval.months == 3);
-	REQUIRE(interval.days == 0);
-	REQUIRE(interval.micros == 0);
-
-	auto hugeint = result->Fetch<duckdb_hugeint>(16, 0);
-	REQUIRE(duckdb_hugeint_to_double(hugeint) == 27);
-
-	REQUIRE(result->IsNull(0, 1));
-	REQUIRE(result->IsNull(1, 1));
-	REQUIRE(result->IsNull(2, 1));
-	REQUIRE(result->IsNull(3, 1));
-	REQUIRE(result->IsNull(4, 1));
-	REQUIRE(result->IsNull(5, 1));
-	REQUIRE(result->IsNull(6, 1));
-	REQUIRE(result->IsNull(7, 1));
-	REQUIRE(result->IsNull(8, 1));
-	REQUIRE(result->IsNull(9, 1));
-	REQUIRE(result->IsNull(10, 1));
-	REQUIRE(result->IsNull(11, 1));
-	REQUIRE(result->IsNull(12, 1));
-	REQUIRE(result->IsNull(13, 1));
-	REQUIRE(result->IsNull(14, 1));
-	REQUIRE(result->IsNull(15, 1));
-	REQUIRE(result->IsNull(16, 1));
-
-	REQUIRE(result->Fetch<bool>(0, 1) == false);
-	REQUIRE(result->Fetch<int8_t>(1, 1) == 0);
-	REQUIRE(result->Fetch<int16_t>(2, 1) == 0);
-	REQUIRE(result->Fetch<int64_t>(3, 1) == 0);
-	REQUIRE(result->Fetch<uint8_t>(4, 1) == 0);
-	REQUIRE(result->Fetch<uint16_t>(5, 1) == 0);
-	REQUIRE(result->Fetch<uint32_t>(6, 1) == 0);
-	REQUIRE(result->Fetch<uint64_t>(7, 1) == 0);
-	REQUIRE(result->Fetch<float>(8, 1) == 0);
-	REQUIRE(result->Fetch<double>(9, 1) == 0);
-	REQUIRE(result->Fetch<string>(10, 1) == "");
-
-	blob = duckdb_value_blob(&result->InternalResult(), 11, 1);
-	REQUIRE(blob.size == 0);
-
-	date = result->Fetch<duckdb_date_struct>(12, 1);
-	REQUIRE(date.year == 1970);
-
-	time = result->Fetch<duckdb_time_struct>(13, 1);
-	REQUIRE(time.hour == 0);
-
-	timestamp = result->Fetch<duckdb_timestamp_struct>(14, 1);
-	REQUIRE(timestamp.date.year == 1970);
-	REQUIRE(timestamp.time.hour == 0);
-
-	interval = result->Fetch<duckdb_interval>(15, 1);
-	REQUIRE(interval.months == 0);
-
-	hugeint = result->Fetch<duckdb_hugeint>(16, 1);
-	REQUIRE(duckdb_hugeint_to_double(hugeint) == 0);
-
-	// double out of range for hugeint
-	hugeint = duckdb_double_to_hugeint(1e300);
-	REQUIRE(hugeint.lower == 0);
-	REQUIRE(hugeint.upper == 0);
-
-	hugeint = duckdb_double_to_hugeint(NAN);
-	REQUIRE(hugeint.lower == 0);
-	REQUIRE(hugeint.upper == 0);
-}
-
-TEST_CASE("Test arrow in C API", "[capi]") {
-	CAPITester tester;
-	unique_ptr<CAPIResult> result;
-	duckdb_prepared_statement stmt = nullptr;
-	duckdb_arrow arrow_result;
-
-	// open the database in in-memory mode
-	REQUIRE(tester.OpenDatabase(nullptr));
-
-	// test rows changed
-	{
-		REQUIRE_NO_FAIL(tester.Query("CREATE TABLE test(a INTEGER)"));
-		REQUIRE(duckdb_query_arrow(tester.connection, "INSERT INTO test VALUES (1), (2);", &arrow_result) ==
-		        DuckDBSuccess);
-		REQUIRE(duckdb_arrow_rows_changed(arrow_result) == 2);
-		duckdb_destroy_arrow(&arrow_result);
-		REQUIRE_NO_FAIL(tester.Query("drop table test"));
-	}
-
-	// test query arrow
-	{
-		REQUIRE(duckdb_query_arrow(tester.connection, "SELECT 42 AS VALUE", &arrow_result) == DuckDBSuccess);
-		REQUIRE(duckdb_arrow_row_count(arrow_result) == 1);
-		REQUIRE(duckdb_arrow_column_count(arrow_result) == 1);
-		REQUIRE(duckdb_arrow_rows_changed(arrow_result) == 0);
-
-		// query schema
-		ArrowSchema *arrow_schema = new ArrowSchema();
-		REQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);
-		REQUIRE(string(arrow_schema->name) == "duckdb_query_result");
-		// User need to release the data themselves
-		arrow_schema->release(arrow_schema);
-		delete arrow_schema;
-
-		// query array data
-		ArrowArray *arrow_array = new ArrowArray();
-		REQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);
-		REQUIRE(arrow_array->length == 1);
-		arrow_array->release(arrow_array);
-		delete arrow_array;
-
-		duckdb_arrow_array null_array = nullptr;
-		REQUIRE(duckdb_query_arrow_array(arrow_result, &null_array) == DuckDBSuccess);
-		REQUIRE(null_array == nullptr);
-
-		// destroy result
-		duckdb_destroy_arrow(&arrow_result);
-	}
-
-	// test multiple chunks
-	{
-		// create table that consists of multiple chunks
-		REQUIRE_NO_FAIL(tester.Query("BEGIN TRANSACTION"));
-		REQUIRE_NO_FAIL(tester.Query("CREATE TABLE test(a INTEGER)"));
-		for (size_t i = 0; i < 500; i++) {
-			REQUIRE_NO_FAIL(
-			    tester.Query("INSERT INTO test VALUES (1); INSERT INTO test VALUES (2); INSERT INTO test VALUES "
-			                 "(3); INSERT INTO test VALUES (4); INSERT INTO test VALUES (5);"));
-		}
-		REQUIRE_NO_FAIL(tester.Query("COMMIT"));
-
-		REQUIRE(duckdb_query_arrow(tester.connection, "SELECT CAST(a AS INTEGER) AS a FROM test ORDER BY a",
-		                           &arrow_result) == DuckDBSuccess);
-
-		ArrowSchema *arrow_schema = new ArrowSchema();
-		REQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);
-		REQUIRE(arrow_schema->release != nullptr);
-		arrow_schema->release(arrow_schema);
-		delete arrow_schema;
-
-		int total_count = 0;
-		while (true) {
-			ArrowArray *arrow_array = new ArrowArray();
-			REQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);
-			if (arrow_array->length == 0) {
-				delete arrow_array;
-				REQUIRE(total_count == 2500);
-				break;
-			}
-			REQUIRE(arrow_array->length > 0);
-			total_count += arrow_array->length;
-			arrow_array->release(arrow_array);
-			delete arrow_array;
-		}
-		duckdb_destroy_arrow(&arrow_result);
-		REQUIRE_NO_FAIL(tester.Query("drop table test"));
-	}
-
-	// test prepare query arrow
-	{
-		REQUIRE(duckdb_prepare(tester.connection, "SELECT CAST($1 AS BIGINT)", &stmt) == DuckDBSuccess);
-		REQUIRE(stmt != nullptr);
-		REQUIRE(duckdb_bind_int64(stmt, 1, 42) == DuckDBSuccess);
-		REQUIRE(duckdb_execute_prepared_arrow(stmt, nullptr) == DuckDBError);
-		REQUIRE(duckdb_execute_prepared_arrow(stmt, &arrow_result) == DuckDBSuccess);
-
-		ArrowSchema *arrow_schema = new ArrowSchema();
-		REQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);
-		REQUIRE(string(arrow_schema->format) == "+s");
-		arrow_schema->release(arrow_schema);
-		delete arrow_schema;
-
-		ArrowArray *arrow_array = new ArrowArray();
-		REQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);
-		REQUIRE(arrow_array->length == 1);
-		arrow_array->release(arrow_array);
-		delete arrow_array;
-
-		duckdb_destroy_arrow(&arrow_result);
-		duckdb_destroy_prepare(&stmt);
-	}
-}
-
 TEST_CASE("Test C API config", "[capi]") {
 	duckdb_database db = nullptr;
 	duckdb_connection con = nullptr;
@@ -1422,186 +423,3 @@ TEST_CASE("Issue #2058: Cleanup after execution of invalid SQL statement causes
 	duckdb_disconnect(&con);
 	duckdb_close(&db);
 }
-
-TEST_CASE("Test C API examples from the website", "[capi]") {
-	// NOTE: if any of these break and need to be changed, the website also needs to be updated!
-	SECTION("connect") {
-		duckdb_database db;
-		duckdb_connection con;
-
-		if (duckdb_open(NULL, &db) == DuckDBError) {
-			// handle error
-		}
-		if (duckdb_connect(db, &con) == DuckDBError) {
-			// handle error
-		}
-
-		// run queries...
-
-		// cleanup
-		duckdb_disconnect(&con);
-		duckdb_close(&db);
-	}
-	SECTION("config") {
-		duckdb_database db;
-		duckdb_config config;
-
-		// create the configuration object
-		if (duckdb_create_config(&config) == DuckDBError) {
-			REQUIRE(1 == 0);
-		}
-		// set some configuration options
-		duckdb_set_config(config, "access_mode", "READ_WRITE");
-		duckdb_set_config(config, "threads", "8");
-		duckdb_set_config(config, "max_memory", "8GB");
-		duckdb_set_config(config, "default_order", "DESC");
-
-		// open the database using the configuration
-		if (duckdb_open_ext(NULL, &db, config, NULL) == DuckDBError) {
-			REQUIRE(1 == 0);
-		}
-		// cleanup the configuration object
-		duckdb_destroy_config(&config);
-
-		// run queries...
-
-		// cleanup
-		duckdb_close(&db);
-	}
-	SECTION("query") {
-		duckdb_database db;
-		duckdb_connection con;
-		duckdb_state state;
-		duckdb_result result;
-
-		duckdb_open(NULL, &db);
-		duckdb_connect(db, &con);
-
-		// create a table
-		state = duckdb_query(con, "CREATE TABLE integers(i INTEGER, j INTEGER);", NULL);
-		if (state == DuckDBError) {
-			REQUIRE(1 == 0);
-		}
-		// insert three rows into the table
-		state = duckdb_query(con, "INSERT INTO integers VALUES (3, 4), (5, 6), (7, NULL);", NULL);
-		if (state == DuckDBError) {
-			REQUIRE(1 == 0);
-		}
-		// query rows again
-		state = duckdb_query(con, "SELECT * FROM integers", &result);
-		if (state == DuckDBError) {
-			REQUIRE(1 == 0);
-		}
-		// handle the result
-		idx_t row_count = duckdb_row_count(&result);
-		idx_t column_count = duckdb_column_count(&result);
-		for (idx_t row = 0; row < row_count; row++) {
-			for (idx_t col = 0; col < column_count; col++) {
-				// if (col > 0) printf(",");
-				auto str_val = duckdb_value_varchar(&result, col, row);
-				// printf("%s", str_val);
-				REQUIRE(1 == 1);
-				duckdb_free(str_val);
-			}
-			//	printf("
");
-		}
-
-		int32_t *i_data = (int32_t *)duckdb_column_data(&result, 0);
-		int32_t *j_data = (int32_t *)duckdb_column_data(&result, 1);
-		bool *i_mask = duckdb_nullmask_data(&result, 0);
-		bool *j_mask = duckdb_nullmask_data(&result, 1);
-		for (idx_t row = 0; row < row_count; row++) {
-			if (i_mask[row]) {
-				// printf("NULL");
-			} else {
-				REQUIRE(i_data[row] > 0);
-				// printf("%d", i_data[row]);
-			}
-			// printf(",");
-			if (j_mask[row]) {
-				// printf("NULL");
-			} else {
-				REQUIRE(j_data[row] > 0);
-				// printf("%d", j_data[row]);
-			}
-			// printf("
");
-		}
-
-		// destroy the result after we are done with it
-		duckdb_destroy_result(&result);
-		duckdb_disconnect(&con);
-		duckdb_close(&db);
-	}
-	SECTION("prepared") {
-		duckdb_database db;
-		duckdb_connection con;
-		duckdb_open(NULL, &db);
-		duckdb_connect(db, &con);
-		duckdb_query(con, "CREATE TABLE integers(i INTEGER, j INTEGER)", NULL);
-
-		duckdb_prepared_statement stmt;
-		duckdb_result result;
-		if (duckdb_prepare(con, "INSERT INTO integers VALUES ($1, $2)", &stmt) == DuckDBError) {
-			REQUIRE(1 == 0);
-		}
-
-		duckdb_bind_int32(stmt, 1, 42); // the parameter index starts counting at 1!
-		duckdb_bind_int32(stmt, 2, 43);
-		// NULL as second parameter means no result set is requested
-		duckdb_execute_prepared(stmt, NULL);
-		duckdb_destroy_prepare(&stmt);
-
-		// we can also query result sets using prepared statements
-		if (duckdb_prepare(con, "SELECT * FROM integers WHERE i = ?", &stmt) == DuckDBError) {
-			REQUIRE(1 == 0);
-		}
-		duckdb_bind_int32(stmt, 1, 42);
-		duckdb_execute_prepared(stmt, &result);
-
-		// do something with result
-
-		// clean up
-		duckdb_destroy_result(&result);
-		duckdb_destroy_prepare(&stmt);
-
-		duckdb_disconnect(&con);
-		duckdb_close(&db);
-	}
-	SECTION("appender") {
-		duckdb_database db;
-		duckdb_connection con;
-		duckdb_open(NULL, &db);
-		duckdb_connect(db, &con);
-		duckdb_query(con, "CREATE TABLE people(id INTEGER, name VARCHAR)", NULL);
-
-		duckdb_appender appender;
-		if (duckdb_appender_create(con, NULL, "people", &appender) == DuckDBError) {
-			REQUIRE(1 == 0);
-		}
-		duckdb_append_int32(appender, 1);
-		duckdb_append_varchar(appender, "Mark");
-		duckdb_appender_end_row(appender);
-
-		duckdb_append_int32(appender, 2);
-		duckdb_append_varchar(appender, "Hannes");
-		duckdb_appender_end_row(appender);
-
-		duckdb_appender_destroy(&appender);
-
-		duckdb_result result;
-		duckdb_query(con, "SELECT * FROM people", &result);
-		REQUIRE(duckdb_value_int32(&result, 0, 0) == 1);
-		REQUIRE(duckdb_value_int32(&result, 0, 1) == 2);
-		REQUIRE(string(duckdb_value_varchar_internal(&result, 1, 0)) == "Mark");
-		REQUIRE(string(duckdb_value_varchar_internal(&result, 1, 1)) == "Hannes");
-
-		// error conditions: we cannot
-		REQUIRE(duckdb_value_varchar_internal(&result, 0, 0) == nullptr);
-		REQUIRE(duckdb_value_varchar_internal(nullptr, 0, 0) == nullptr);
-
-		duckdb_destroy_result(&result);
-
-		duckdb_disconnect(&con);
-		duckdb_close(&db);
-	}
-}
diff --git a/test/api/capi/test_capi_appender.cpp b/test/api/capi/test_capi_appender.cpp
new file mode 100644
index 000000000000..975d04abf8fa
--- /dev/null
+++ b/test/api/capi/test_capi_appender.cpp
@@ -0,0 +1,390 @@
+#include "capi_tester.hpp"
+
+using namespace duckdb;
+using namespace std;
+
+TEST_CASE("Test appender statements in C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+	duckdb_state status;
+
+	// open the database in in-memory mode
+	REQUIRE(tester.OpenDatabase(nullptr));
+
+	tester.Query("CREATE TABLE test (i INTEGER, d double, s string)");
+	duckdb_appender appender;
+
+	status = duckdb_appender_create(tester.connection, nullptr, "nonexistant-table", &appender);
+	REQUIRE(status == DuckDBError);
+	REQUIRE(appender != nullptr);
+	REQUIRE(duckdb_appender_error(appender) != nullptr);
+	REQUIRE(duckdb_appender_destroy(&appender) == DuckDBSuccess);
+	REQUIRE(duckdb_appender_destroy(nullptr) == DuckDBError);
+
+	status = duckdb_appender_create(tester.connection, nullptr, "test", nullptr);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_appender_create(tester.connection, nullptr, "test", &appender);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_appender_error(appender) == nullptr);
+
+	status = duckdb_appender_begin_row(appender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_int32(appender, 42);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_double(appender, 4.2);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_varchar(appender, "Hello, World");
+	REQUIRE(status == DuckDBSuccess);
+
+	// out of cols here
+	status = duckdb_append_int32(appender, 42);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_appender_end_row(appender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_appender_flush(appender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_appender_begin_row(appender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_int32(appender, 42);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_double(appender, 4.2);
+	REQUIRE(status == DuckDBSuccess);
+
+	// not enough cols here
+	status = duckdb_appender_end_row(appender);
+	REQUIRE(status == DuckDBError);
+	REQUIRE(duckdb_appender_error(appender) != nullptr);
+
+	status = duckdb_append_varchar(appender, "Hello, World");
+	REQUIRE(status == DuckDBSuccess);
+
+	// out of cols here
+	status = duckdb_append_int32(appender, 42);
+	REQUIRE(status == DuckDBError);
+
+	REQUIRE(duckdb_appender_error(appender) != nullptr);
+
+	status = duckdb_appender_end_row(appender);
+	REQUIRE(status == DuckDBSuccess);
+
+	// we can flush again why not
+	status = duckdb_appender_flush(appender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_appender_close(appender);
+	REQUIRE(status == DuckDBSuccess);
+
+	result = tester.Query("SELECT * FROM test");
+	REQUIRE_NO_FAIL(*result);
+	REQUIRE(result->Fetch<int32_t>(0, 0) == 42);
+	REQUIRE(result->Fetch<double>(1, 0) == 4.2);
+	REQUIRE(result->Fetch<string>(2, 0) == "Hello, World");
+
+	status = duckdb_appender_destroy(&appender);
+	REQUIRE(status == DuckDBSuccess);
+
+	// this has been destroyed
+
+	status = duckdb_appender_close(appender);
+	REQUIRE(status == DuckDBError);
+	REQUIRE(duckdb_appender_error(appender) == nullptr);
+
+	status = duckdb_appender_flush(appender);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_appender_end_row(appender);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_append_int32(appender, 42);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_appender_destroy(&appender);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_appender_close(nullptr);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_appender_flush(nullptr);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_appender_end_row(nullptr);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_append_int32(nullptr, 42);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_appender_destroy(nullptr);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_appender_destroy(nullptr);
+	REQUIRE(status == DuckDBError);
+
+	// many types
+	REQUIRE_NO_FAIL(tester.Query("CREATE TABLE many_types(bool boolean, t TINYINT, s SMALLINT, b BIGINT, ut UTINYINT, "
+	                             "us USMALLINT, ui UINTEGER, ub UBIGINT, uf REAL, ud DOUBLE, txt VARCHAR, blb BLOB, dt "
+	                             "DATE, tm TIME, ts TIMESTAMP, ival INTERVAL, h HUGEINT)"));
+	duckdb_appender tappender;
+
+	status = duckdb_appender_create(tester.connection, nullptr, "many_types", &tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_appender_begin_row(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_bool(tappender, true);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_int8(tappender, 1);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_int16(tappender, 1);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_int64(tappender, 1);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_uint8(tappender, 1);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_uint16(tappender, 1);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_uint32(tappender, 1);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_uint64(tappender, 1);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_float(tappender, 0.5f);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_double(tappender, 0.5);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_varchar_length(tappender, "hello world", 5);
+	REQUIRE(status == DuckDBSuccess);
+
+	duckdb_date_struct date_struct;
+	date_struct.year = 1992;
+	date_struct.month = 9;
+	date_struct.day = 3;
+
+	auto str = strdup("hello world this is my long string");
+	status = duckdb_append_blob(tappender, str, strlen(str));
+	free(str);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_date(tappender, duckdb_to_date(date_struct));
+	REQUIRE(status == DuckDBSuccess);
+
+	duckdb_time_struct time_struct;
+	time_struct.hour = 12;
+	time_struct.min = 22;
+	time_struct.sec = 33;
+	time_struct.micros = 1234;
+
+	status = duckdb_append_time(tappender, duckdb_to_time(time_struct));
+	REQUIRE(status == DuckDBSuccess);
+
+	duckdb_timestamp_struct ts;
+	ts.date = date_struct;
+	ts.time = time_struct;
+
+	status = duckdb_append_timestamp(tappender, duckdb_to_timestamp(ts));
+	REQUIRE(status == DuckDBSuccess);
+
+	duckdb_interval interval;
+	interval.months = 3;
+	interval.days = 0;
+	interval.micros = 0;
+
+	status = duckdb_append_interval(tappender, interval);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_hugeint(tappender, duckdb_double_to_hugeint(27));
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_appender_end_row(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_appender_begin_row(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_append_null(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_appender_end_row(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_appender_flush(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_appender_close(tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_appender_destroy(&tappender);
+	REQUIRE(status == DuckDBSuccess);
+
+	result = tester.Query("SELECT * FROM many_types");
+	REQUIRE_NO_FAIL(*result);
+	REQUIRE(result->Fetch<bool>(0, 0) == true);
+	REQUIRE(result->Fetch<int8_t>(1, 0) == 1);
+	REQUIRE(result->Fetch<int16_t>(2, 0) == 1);
+	REQUIRE(result->Fetch<int64_t>(3, 0) == 1);
+	REQUIRE(result->Fetch<uint8_t>(4, 0) == 1);
+	REQUIRE(result->Fetch<uint16_t>(5, 0) == 1);
+	REQUIRE(result->Fetch<uint32_t>(6, 0) == 1);
+	REQUIRE(result->Fetch<uint64_t>(7, 0) == 1);
+	REQUIRE(result->Fetch<float>(8, 0) == 0.5f);
+	REQUIRE(result->Fetch<double>(9, 0) == 0.5);
+	REQUIRE(result->Fetch<string>(10, 0) == "hello");
+
+	auto blob = duckdb_value_blob(&result->InternalResult(), 11, 0);
+	REQUIRE(blob.size == 34);
+	REQUIRE(memcmp(blob.data, "hello world this is my long string", 34) == 0);
+	duckdb_free(blob.data);
+	REQUIRE(duckdb_value_int32(&result->InternalResult(), 11, 0) == 0);
+
+	auto date = result->Fetch<duckdb_date_struct>(12, 0);
+	REQUIRE(date.year == 1992);
+	REQUIRE(date.month == 9);
+	REQUIRE(date.day == 3);
+
+	auto time = result->Fetch<duckdb_time_struct>(13, 0);
+	REQUIRE(time.hour == 12);
+	REQUIRE(time.min == 22);
+	REQUIRE(time.sec == 33);
+	REQUIRE(time.micros == 1234);
+
+	auto timestamp = result->Fetch<duckdb_timestamp_struct>(14, 0);
+	REQUIRE(timestamp.date.year == 1992);
+	REQUIRE(timestamp.date.month == 9);
+	REQUIRE(timestamp.date.day == 3);
+	REQUIRE(timestamp.time.hour == 12);
+	REQUIRE(timestamp.time.min == 22);
+	REQUIRE(timestamp.time.sec == 33);
+	REQUIRE(timestamp.time.micros == 1234);
+
+	interval = result->Fetch<duckdb_interval>(15, 0);
+	REQUIRE(interval.months == 3);
+	REQUIRE(interval.days == 0);
+	REQUIRE(interval.micros == 0);
+
+	auto hugeint = result->Fetch<duckdb_hugeint>(16, 0);
+	REQUIRE(duckdb_hugeint_to_double(hugeint) == 27);
+
+	REQUIRE(result->IsNull(0, 1));
+	REQUIRE(result->IsNull(1, 1));
+	REQUIRE(result->IsNull(2, 1));
+	REQUIRE(result->IsNull(3, 1));
+	REQUIRE(result->IsNull(4, 1));
+	REQUIRE(result->IsNull(5, 1));
+	REQUIRE(result->IsNull(6, 1));
+	REQUIRE(result->IsNull(7, 1));
+	REQUIRE(result->IsNull(8, 1));
+	REQUIRE(result->IsNull(9, 1));
+	REQUIRE(result->IsNull(10, 1));
+	REQUIRE(result->IsNull(11, 1));
+	REQUIRE(result->IsNull(12, 1));
+	REQUIRE(result->IsNull(13, 1));
+	REQUIRE(result->IsNull(14, 1));
+	REQUIRE(result->IsNull(15, 1));
+	REQUIRE(result->IsNull(16, 1));
+
+	REQUIRE(result->Fetch<bool>(0, 1) == false);
+	REQUIRE(result->Fetch<int8_t>(1, 1) == 0);
+	REQUIRE(result->Fetch<int16_t>(2, 1) == 0);
+	REQUIRE(result->Fetch<int64_t>(3, 1) == 0);
+	REQUIRE(result->Fetch<uint8_t>(4, 1) == 0);
+	REQUIRE(result->Fetch<uint16_t>(5, 1) == 0);
+	REQUIRE(result->Fetch<uint32_t>(6, 1) == 0);
+	REQUIRE(result->Fetch<uint64_t>(7, 1) == 0);
+	REQUIRE(result->Fetch<float>(8, 1) == 0);
+	REQUIRE(result->Fetch<double>(9, 1) == 0);
+	REQUIRE(result->Fetch<string>(10, 1) == "");
+
+	blob = duckdb_value_blob(&result->InternalResult(), 11, 1);
+	REQUIRE(blob.size == 0);
+
+	date = result->Fetch<duckdb_date_struct>(12, 1);
+	REQUIRE(date.year == 1970);
+
+	time = result->Fetch<duckdb_time_struct>(13, 1);
+	REQUIRE(time.hour == 0);
+
+	timestamp = result->Fetch<duckdb_timestamp_struct>(14, 1);
+	REQUIRE(timestamp.date.year == 1970);
+	REQUIRE(timestamp.time.hour == 0);
+
+	interval = result->Fetch<duckdb_interval>(15, 1);
+	REQUIRE(interval.months == 0);
+
+	hugeint = result->Fetch<duckdb_hugeint>(16, 1);
+	REQUIRE(duckdb_hugeint_to_double(hugeint) == 0);
+
+	// double out of range for hugeint
+	hugeint = duckdb_double_to_hugeint(1e300);
+	REQUIRE(hugeint.lower == 0);
+	REQUIRE(hugeint.upper == 0);
+
+	hugeint = duckdb_double_to_hugeint(NAN);
+	REQUIRE(hugeint.lower == 0);
+	REQUIRE(hugeint.upper == 0);
+}
diff --git a/test/api/capi/test_capi_arrow.cpp b/test/api/capi/test_capi_arrow.cpp
new file mode 100644
index 000000000000..210ae3cece83
--- /dev/null
+++ b/test/api/capi/test_capi_arrow.cpp
@@ -0,0 +1,117 @@
+#include "capi_tester.hpp"
+
+using namespace duckdb;
+using namespace std;
+
+TEST_CASE("Test arrow in C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+	duckdb_prepared_statement stmt = nullptr;
+	duckdb_arrow arrow_result;
+
+	// open the database in in-memory mode
+	REQUIRE(tester.OpenDatabase(nullptr));
+
+	// test rows changed
+	{
+		REQUIRE_NO_FAIL(tester.Query("CREATE TABLE test(a INTEGER)"));
+		REQUIRE(duckdb_query_arrow(tester.connection, "INSERT INTO test VALUES (1), (2);", &arrow_result) ==
+		        DuckDBSuccess);
+		REQUIRE(duckdb_arrow_rows_changed(arrow_result) == 2);
+		duckdb_destroy_arrow(&arrow_result);
+		REQUIRE_NO_FAIL(tester.Query("drop table test"));
+	}
+
+	// test query arrow
+	{
+		REQUIRE(duckdb_query_arrow(tester.connection, "SELECT 42 AS VALUE", &arrow_result) == DuckDBSuccess);
+		REQUIRE(duckdb_arrow_row_count(arrow_result) == 1);
+		REQUIRE(duckdb_arrow_column_count(arrow_result) == 1);
+		REQUIRE(duckdb_arrow_rows_changed(arrow_result) == 0);
+
+		// query schema
+		ArrowSchema *arrow_schema = new ArrowSchema();
+		REQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);
+		REQUIRE(string(arrow_schema->name) == "duckdb_query_result");
+		// User need to release the data themselves
+		arrow_schema->release(arrow_schema);
+		delete arrow_schema;
+
+		// query array data
+		ArrowArray *arrow_array = new ArrowArray();
+		REQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);
+		REQUIRE(arrow_array->length == 1);
+		arrow_array->release(arrow_array);
+		delete arrow_array;
+
+		duckdb_arrow_array null_array = nullptr;
+		REQUIRE(duckdb_query_arrow_array(arrow_result, &null_array) == DuckDBSuccess);
+		REQUIRE(null_array == nullptr);
+
+		// destroy result
+		duckdb_destroy_arrow(&arrow_result);
+	}
+
+	// test multiple chunks
+	{
+		// create table that consists of multiple chunks
+		REQUIRE_NO_FAIL(tester.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(tester.Query("CREATE TABLE test(a INTEGER)"));
+		for (size_t i = 0; i < 500; i++) {
+			REQUIRE_NO_FAIL(
+			    tester.Query("INSERT INTO test VALUES (1); INSERT INTO test VALUES (2); INSERT INTO test VALUES "
+			                 "(3); INSERT INTO test VALUES (4); INSERT INTO test VALUES (5);"));
+		}
+		REQUIRE_NO_FAIL(tester.Query("COMMIT"));
+
+		REQUIRE(duckdb_query_arrow(tester.connection, "SELECT CAST(a AS INTEGER) AS a FROM test ORDER BY a",
+		                           &arrow_result) == DuckDBSuccess);
+
+		ArrowSchema *arrow_schema = new ArrowSchema();
+		REQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);
+		REQUIRE(arrow_schema->release != nullptr);
+		arrow_schema->release(arrow_schema);
+		delete arrow_schema;
+
+		int total_count = 0;
+		while (true) {
+			ArrowArray *arrow_array = new ArrowArray();
+			REQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);
+			if (arrow_array->length == 0) {
+				delete arrow_array;
+				REQUIRE(total_count == 2500);
+				break;
+			}
+			REQUIRE(arrow_array->length > 0);
+			total_count += arrow_array->length;
+			arrow_array->release(arrow_array);
+			delete arrow_array;
+		}
+		duckdb_destroy_arrow(&arrow_result);
+		REQUIRE_NO_FAIL(tester.Query("drop table test"));
+	}
+
+	// test prepare query arrow
+	{
+		REQUIRE(duckdb_prepare(tester.connection, "SELECT CAST($1 AS BIGINT)", &stmt) == DuckDBSuccess);
+		REQUIRE(stmt != nullptr);
+		REQUIRE(duckdb_bind_int64(stmt, 1, 42) == DuckDBSuccess);
+		REQUIRE(duckdb_execute_prepared_arrow(stmt, nullptr) == DuckDBError);
+		REQUIRE(duckdb_execute_prepared_arrow(stmt, &arrow_result) == DuckDBSuccess);
+
+		ArrowSchema *arrow_schema = new ArrowSchema();
+		REQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);
+		REQUIRE(string(arrow_schema->format) == "+s");
+		arrow_schema->release(arrow_schema);
+		delete arrow_schema;
+
+		ArrowArray *arrow_array = new ArrowArray();
+		REQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);
+		REQUIRE(arrow_array->length == 1);
+		arrow_array->release(arrow_array);
+		delete arrow_array;
+
+		duckdb_destroy_arrow(&arrow_result);
+		duckdb_destroy_prepare(&stmt);
+	}
+}
diff --git a/test/api/capi/test_capi_complex_types.cpp b/test/api/capi/test_capi_complex_types.cpp
new file mode 100644
index 000000000000..2a9b471bb435
--- /dev/null
+++ b/test/api/capi/test_capi_complex_types.cpp
@@ -0,0 +1,174 @@
+#include "capi_tester.hpp"
+
+using namespace duckdb;
+using namespace std;
+
+TEST_CASE("Test decimal types C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+
+	REQUIRE(tester.OpenDatabase(nullptr));
+
+	// decimal types
+	result =
+	    tester.Query("SELECT 1.0::DECIMAL(4,1), 2.0::DECIMAL(9,2), 3.0::DECIMAL(18,3), 4.0::DECIMAL(38,4), 5::INTEGER");
+	REQUIRE(NO_FAIL(*result));
+	REQUIRE(result->ColumnCount() == 5);
+	REQUIRE(result->ErrorMessage() == nullptr);
+
+	if (duckdb_vector_size() < 64) {
+		return;
+	}
+
+	// fetch the first chunk
+	REQUIRE(result->ChunkCount() == 1);
+	auto chunk = result->FetchChunk(0);
+	REQUIRE(chunk);
+
+	vector<uint8_t> widths = {4, 9, 18, 38, 0};
+	vector<uint8_t> scales = {1, 2, 3, 4, 0};
+	vector<duckdb_type> types = {DUCKDB_TYPE_DECIMAL, DUCKDB_TYPE_DECIMAL, DUCKDB_TYPE_DECIMAL, DUCKDB_TYPE_DECIMAL,
+	                             DUCKDB_TYPE_INTEGER};
+	vector<duckdb_type> internal_types = {DUCKDB_TYPE_SMALLINT, DUCKDB_TYPE_INTEGER, DUCKDB_TYPE_BIGINT,
+	                                      DUCKDB_TYPE_HUGEINT, DUCKDB_TYPE_INVALID};
+	for (idx_t i = 0; i < result->ColumnCount(); i++) {
+		auto logical_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(chunk->GetChunk(), i));
+		REQUIRE(logical_type);
+		REQUIRE(duckdb_get_type_id(logical_type) == types[i]);
+		REQUIRE(duckdb_decimal_width(logical_type) == widths[i]);
+		REQUIRE(duckdb_decimal_scale(logical_type) == scales[i]);
+		REQUIRE(duckdb_decimal_internal_type(logical_type) == internal_types[i]);
+
+		duckdb_destroy_logical_type(&logical_type);
+	}
+	REQUIRE(duckdb_decimal_width(nullptr) == 0);
+	REQUIRE(duckdb_decimal_scale(nullptr) == 0);
+	REQUIRE(duckdb_decimal_internal_type(nullptr) == DUCKDB_TYPE_INVALID);
+}
+
+TEST_CASE("Test enum types C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+
+	if (duckdb_vector_size() < 64) {
+		return;
+	}
+
+	REQUIRE(tester.OpenDatabase(nullptr));
+	result = tester.Query("select small_enum, medium_enum, large_enum, int from test_all_types();");
+	REQUIRE(NO_FAIL(*result));
+	REQUIRE(result->ColumnCount() == 4);
+	REQUIRE(result->ErrorMessage() == nullptr);
+
+	// fetch the first chunk
+	REQUIRE(result->ChunkCount() == 1);
+	auto chunk = result->FetchChunk(0);
+	REQUIRE(chunk);
+
+	vector<duckdb_type> types = {DUCKDB_TYPE_ENUM, DUCKDB_TYPE_ENUM, DUCKDB_TYPE_ENUM, DUCKDB_TYPE_INTEGER};
+	vector<duckdb_type> internal_types = {DUCKDB_TYPE_UTINYINT, DUCKDB_TYPE_USMALLINT, DUCKDB_TYPE_UINTEGER,
+	                                      DUCKDB_TYPE_INVALID};
+	vector<uint32_t> dictionary_sizes = {2, 300, 70000, 0};
+	vector<string> dictionary_strings = {"DUCK_DUCK_ENUM", "enum_0", "enum_0", string()};
+	for (idx_t i = 0; i < result->ColumnCount(); i++) {
+		auto logical_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(chunk->GetChunk(), i));
+		REQUIRE(logical_type);
+		REQUIRE(duckdb_get_type_id(logical_type) == types[i]);
+		REQUIRE(duckdb_enum_internal_type(logical_type) == internal_types[i]);
+		REQUIRE(duckdb_enum_dictionary_size(logical_type) == dictionary_sizes[i]);
+
+		auto value = duckdb_enum_dictionary_value(logical_type, 0);
+		string str_val = value ? string(value) : string();
+		duckdb_free(value);
+
+		REQUIRE(str_val == dictionary_strings[i]);
+
+		duckdb_destroy_logical_type(&logical_type);
+	}
+	REQUIRE(duckdb_enum_internal_type(nullptr) == DUCKDB_TYPE_INVALID);
+	REQUIRE(duckdb_enum_dictionary_size(nullptr) == 0);
+	REQUIRE(duckdb_enum_dictionary_value(nullptr, 0) == nullptr);
+}
+
+TEST_CASE("Test list types C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+
+	REQUIRE(tester.OpenDatabase(nullptr));
+	result = tester.Query("select [1, 2, 3] l, ['hello', 'world'] s, [[1, 2, 3], [4, 5]] nested, 3::int");
+	REQUIRE(NO_FAIL(*result));
+	REQUIRE(result->ColumnCount() == 4);
+	REQUIRE(result->ErrorMessage() == nullptr);
+
+	// fetch the first chunk
+	REQUIRE(result->ChunkCount() == 1);
+	auto chunk = result->FetchChunk(0);
+	REQUIRE(chunk);
+
+	vector<duckdb_type> types = {DUCKDB_TYPE_LIST, DUCKDB_TYPE_LIST, DUCKDB_TYPE_LIST, DUCKDB_TYPE_INTEGER};
+	vector<duckdb_type> child_types_1 = {DUCKDB_TYPE_INTEGER, DUCKDB_TYPE_VARCHAR, DUCKDB_TYPE_LIST,
+	                                     DUCKDB_TYPE_INVALID};
+	vector<duckdb_type> child_types_2 = {DUCKDB_TYPE_INVALID, DUCKDB_TYPE_INVALID, DUCKDB_TYPE_INTEGER,
+	                                     DUCKDB_TYPE_INVALID};
+	for (idx_t i = 0; i < result->ColumnCount(); i++) {
+		auto logical_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(chunk->GetChunk(), i));
+		REQUIRE(logical_type);
+		REQUIRE(duckdb_get_type_id(logical_type) == types[i]);
+
+		auto child_type = duckdb_list_type_child_type(logical_type);
+		auto child_type_2 = duckdb_list_type_child_type(child_type);
+
+		REQUIRE(duckdb_get_type_id(child_type) == child_types_1[i]);
+		REQUIRE(duckdb_get_type_id(child_type_2) == child_types_2[i]);
+
+		duckdb_destroy_logical_type(&child_type);
+		duckdb_destroy_logical_type(&child_type_2);
+		duckdb_destroy_logical_type(&logical_type);
+	}
+	REQUIRE(duckdb_list_type_child_type(nullptr) == nullptr);
+}
+
+TEST_CASE("Test struct types C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+
+	REQUIRE(tester.OpenDatabase(nullptr));
+	result = tester.Query("select {'a': 42::int}, {'b': 'hello', 'c': [1, 2, 3]}, {'d': {'e': 42}}, 3::int");
+	REQUIRE(NO_FAIL(*result));
+	REQUIRE(result->ColumnCount() == 4);
+	REQUIRE(result->ErrorMessage() == nullptr);
+
+	// fetch the first chunk
+	REQUIRE(result->ChunkCount() == 1);
+	auto chunk = result->FetchChunk(0);
+	REQUIRE(chunk);
+
+	vector<duckdb_type> types = {DUCKDB_TYPE_STRUCT, DUCKDB_TYPE_STRUCT, DUCKDB_TYPE_STRUCT, DUCKDB_TYPE_INTEGER};
+	vector<idx_t> child_count = {1, 2, 1, 0};
+	vector<vector<string>> child_names = {{"a"}, {"b", "c"}, {"d"}, {}};
+	vector<vector<duckdb_type>> child_types = {
+	    {DUCKDB_TYPE_INTEGER}, {DUCKDB_TYPE_VARCHAR, DUCKDB_TYPE_LIST}, {DUCKDB_TYPE_STRUCT}, {}};
+	for (idx_t i = 0; i < result->ColumnCount(); i++) {
+		auto logical_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(chunk->GetChunk(), i));
+		REQUIRE(logical_type);
+		REQUIRE(duckdb_get_type_id(logical_type) == types[i]);
+
+		REQUIRE(duckdb_struct_type_child_count(logical_type) == child_count[i]);
+		for (idx_t c_idx = 0; c_idx < child_count[i]; c_idx++) {
+			auto val = duckdb_struct_type_child_name(logical_type, c_idx);
+			string str_val(val);
+			duckdb_free(val);
+
+			REQUIRE(child_names[i][c_idx] == str_val);
+
+			auto child_type = duckdb_struct_type_child_type(logical_type, c_idx);
+			REQUIRE(duckdb_get_type_id(child_type) == child_types[i][c_idx]);
+			duckdb_destroy_logical_type(&child_type);
+		}
+
+		duckdb_destroy_logical_type(&logical_type);
+	}
+	REQUIRE(duckdb_struct_type_child_count(nullptr) == 0);
+	REQUIRE(duckdb_struct_type_child_name(nullptr, 0) == nullptr);
+	REQUIRE(duckdb_struct_type_child_type(nullptr, 0) == nullptr);
+}
diff --git a/test/api/capi/test_capi_data_chunk.cpp b/test/api/capi/test_capi_data_chunk.cpp
new file mode 100644
index 000000000000..795941b7f4fd
--- /dev/null
+++ b/test/api/capi/test_capi_data_chunk.cpp
@@ -0,0 +1,158 @@
+#include "capi_tester.hpp"
+
+using namespace duckdb;
+using namespace std;
+
+TEST_CASE("Test Logical Types C API", "[capi]") {
+	duckdb_logical_type type = duckdb_create_logical_type(DUCKDB_TYPE_BIGINT);
+	REQUIRE(type);
+	REQUIRE(duckdb_get_type_id(type) == DUCKDB_TYPE_BIGINT);
+	duckdb_destroy_logical_type(&type);
+	duckdb_destroy_logical_type(&type);
+
+	duckdb_destroy_logical_type(nullptr);
+}
+
+TEST_CASE("Test DataChunk C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+	duckdb_state status;
+
+	REQUIRE(tester.OpenDatabase(nullptr));
+
+	REQUIRE(duckdb_vector_size() == STANDARD_VECTOR_SIZE);
+
+	tester.Query("CREATE TABLE test(i BIGINT, j SMALLINT)");
+
+	duckdb_logical_type types[2];
+	types[0] = duckdb_create_logical_type(DUCKDB_TYPE_BIGINT);
+	types[1] = duckdb_create_logical_type(DUCKDB_TYPE_SMALLINT);
+
+	auto data_chunk = duckdb_create_data_chunk(types, 2);
+	REQUIRE(data_chunk);
+
+	REQUIRE(duckdb_data_chunk_get_column_count(data_chunk) == 2);
+
+	auto first_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(data_chunk, 0));
+	REQUIRE(duckdb_get_type_id(first_type) == DUCKDB_TYPE_BIGINT);
+	duckdb_destroy_logical_type(&first_type);
+
+	auto second_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(data_chunk, 1));
+	REQUIRE(duckdb_get_type_id(second_type) == DUCKDB_TYPE_SMALLINT);
+	duckdb_destroy_logical_type(&second_type);
+
+	REQUIRE(duckdb_data_chunk_get_vector(data_chunk, 999) == nullptr);
+	REQUIRE(duckdb_data_chunk_get_vector(nullptr, 0) == nullptr);
+	REQUIRE(duckdb_vector_get_column_type(nullptr) == nullptr);
+
+	REQUIRE(duckdb_data_chunk_get_size(data_chunk) == 0);
+	REQUIRE(duckdb_data_chunk_get_size(nullptr) == 0);
+
+	// use the appender to insert a value using the data chunk API
+
+	duckdb_appender appender;
+	status = duckdb_appender_create(tester.connection, nullptr, "test", &appender);
+	REQUIRE(status == DuckDBSuccess);
+
+	// append standard primitive values
+	auto col1_ptr = (int64_t *)duckdb_vector_get_data(duckdb_data_chunk_get_vector(data_chunk, 0));
+	*col1_ptr = 42;
+	auto col2_ptr = (int16_t *)duckdb_vector_get_data(duckdb_data_chunk_get_vector(data_chunk, 1));
+	*col2_ptr = 84;
+
+	REQUIRE(duckdb_vector_get_data(nullptr) == nullptr);
+
+	duckdb_data_chunk_set_size(data_chunk, 1);
+	REQUIRE(duckdb_data_chunk_get_size(data_chunk) == 1);
+
+	REQUIRE(duckdb_append_data_chunk(appender, data_chunk) == DuckDBSuccess);
+	REQUIRE(duckdb_append_data_chunk(appender, nullptr) == DuckDBError);
+	REQUIRE(duckdb_append_data_chunk(nullptr, data_chunk) == DuckDBError);
+
+	// append nulls
+	duckdb_data_chunk_reset(data_chunk);
+	REQUIRE(duckdb_data_chunk_get_size(data_chunk) == 0);
+
+	duckdb_vector_ensure_validity_writable(duckdb_data_chunk_get_vector(data_chunk, 0));
+	duckdb_vector_ensure_validity_writable(duckdb_data_chunk_get_vector(data_chunk, 1));
+	auto col1_validity = duckdb_vector_get_validity(duckdb_data_chunk_get_vector(data_chunk, 0));
+	REQUIRE(duckdb_validity_row_is_valid(col1_validity, 0));
+	duckdb_validity_set_row_validity(col1_validity, 0, false);
+	REQUIRE(!duckdb_validity_row_is_valid(col1_validity, 0));
+
+	auto col2_validity = duckdb_vector_get_validity(duckdb_data_chunk_get_vector(data_chunk, 1));
+	REQUIRE(col2_validity);
+	REQUIRE(duckdb_validity_row_is_valid(col2_validity, 0));
+	duckdb_validity_set_row_validity(col2_validity, 0, false);
+	REQUIRE(!duckdb_validity_row_is_valid(col2_validity, 0));
+
+	duckdb_data_chunk_set_size(data_chunk, 1);
+	REQUIRE(duckdb_data_chunk_get_size(data_chunk) == 1);
+
+	REQUIRE(duckdb_append_data_chunk(appender, data_chunk) == DuckDBSuccess);
+
+	REQUIRE(duckdb_vector_get_validity(nullptr) == nullptr);
+
+	duckdb_appender_destroy(&appender);
+
+	result = tester.Query("SELECT * FROM test");
+	REQUIRE_NO_FAIL(*result);
+	REQUIRE(result->Fetch<int64_t>(0, 0) == 42);
+	REQUIRE(result->Fetch<int16_t>(1, 0) == 84);
+	REQUIRE(result->IsNull(0, 1));
+	REQUIRE(result->IsNull(1, 1));
+
+	duckdb_data_chunk_reset(data_chunk);
+	duckdb_data_chunk_reset(nullptr);
+	REQUIRE(duckdb_data_chunk_get_size(data_chunk) == 0);
+
+	duckdb_destroy_data_chunk(&data_chunk);
+	duckdb_destroy_data_chunk(&data_chunk);
+
+	duckdb_destroy_data_chunk(nullptr);
+
+	duckdb_destroy_logical_type(&types[0]);
+	duckdb_destroy_logical_type(&types[1]);
+}
+
+TEST_CASE("Test DataChunk result fetch in C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+
+	if (duckdb_vector_size() < 64) {
+		return;
+	}
+
+	REQUIRE(tester.OpenDatabase(nullptr));
+
+	// fetch a small result set
+	result = tester.Query("SELECT CASE WHEN i=1 THEN NULL ELSE i::INTEGER END i FROM range(3) tbl(i)");
+	REQUIRE(NO_FAIL(*result));
+	REQUIRE(result->ColumnCount() == 1);
+	REQUIRE(result->row_count() == 3);
+	REQUIRE(result->ErrorMessage() == nullptr);
+
+	// fetch the first chunk
+	REQUIRE(result->ChunkCount() == 1);
+	auto chunk = result->FetchChunk(0);
+	REQUIRE(chunk);
+
+	REQUIRE(chunk->ColumnCount() == 1);
+	REQUIRE(chunk->size() == 3);
+
+	auto data = (int32_t *)chunk->GetData(0);
+	auto validity = chunk->GetValidity(0);
+	REQUIRE(data[0] == 0);
+	REQUIRE(data[2] == 2);
+	REQUIRE(duckdb_validity_row_is_valid(validity, 0));
+	REQUIRE(!duckdb_validity_row_is_valid(validity, 1));
+	REQUIRE(duckdb_validity_row_is_valid(validity, 2));
+
+	// after fetching a chunk, we cannot use the old API anymore
+	REQUIRE(result->ColumnData<int32_t>(0) == nullptr);
+	REQUIRE(result->Fetch<int32_t>(0, 1) == 0);
+
+	// result set is exhausted!
+	chunk = result->FetchChunk(1);
+	REQUIRE(!chunk);
+}
diff --git a/test/api/capi/test_capi_prepared.cpp b/test/api/capi/test_capi_prepared.cpp
new file mode 100644
index 000000000000..b20ab3b5bfa6
--- /dev/null
+++ b/test/api/capi/test_capi_prepared.cpp
@@ -0,0 +1,245 @@
+#include "capi_tester.hpp"
+
+using namespace duckdb;
+using namespace std;
+
+TEST_CASE("Test prepared statements in C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+	duckdb_result res;
+	duckdb_prepared_statement stmt = nullptr;
+	duckdb_state status;
+
+	// open the database in in-memory mode
+	REQUIRE(tester.OpenDatabase(nullptr));
+
+	status = duckdb_prepare(tester.connection, "SELECT CAST($1 AS BIGINT)", &stmt);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(stmt != nullptr);
+
+	status = duckdb_bind_boolean(stmt, 1, 1);
+	REQUIRE(status == DuckDBSuccess);
+	status = duckdb_bind_boolean(stmt, 2, 1);
+	REQUIRE(status == DuckDBError);
+
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_int64(&res, 0, 0) == 1);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_int8(stmt, 1, 8);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_int64(&res, 0, 0) == 8);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_int16(stmt, 1, 16);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_int64(&res, 0, 0) == 16);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_int32(stmt, 1, 32);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_int64(&res, 0, 0) == 32);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_int64(stmt, 1, 64);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_int64(&res, 0, 0) == 64);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_hugeint(stmt, 1, duckdb_double_to_hugeint(64));
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_hugeint_to_double(duckdb_value_hugeint(&res, 0, 0)) == 64.0);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_uint8(stmt, 1, 8);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_uint8(&res, 0, 0) == 8);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_uint16(stmt, 1, 8);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_uint16(&res, 0, 0) == 8);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_uint32(stmt, 1, 8);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_uint32(&res, 0, 0) == 8);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_uint64(stmt, 1, 8);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_uint64(&res, 0, 0) == 8);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_float(stmt, 1, 42.0);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_int64(&res, 0, 0) == 42);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_double(stmt, 1, 43.0);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_int64(&res, 0, 0) == 43);
+	duckdb_destroy_result(&res);
+
+	REQUIRE(duckdb_bind_float(stmt, 1, NAN) == DuckDBError);
+	REQUIRE(duckdb_bind_double(stmt, 1, NAN) == DuckDBError);
+
+	REQUIRE(duckdb_bind_varchar(stmt, 1, "\x80\x40\x41") == DuckDBError);
+	duckdb_bind_varchar(stmt, 1, "44");
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_int64(&res, 0, 0) == 44);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_null(stmt, 1);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_nullmask_data(&res, 0)[0] == true);
+	duckdb_destroy_result(&res);
+
+	duckdb_destroy_prepare(&stmt);
+	// again to make sure it does not crash
+	duckdb_destroy_result(&res);
+	duckdb_destroy_prepare(&stmt);
+
+	status = duckdb_prepare(tester.connection, "SELECT CAST($1 AS VARCHAR)", &stmt);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(stmt != nullptr);
+
+	REQUIRE(duckdb_bind_varchar_length(stmt, 1, "\x00\x40\x41", 3) == DuckDBError);
+	duckdb_bind_varchar_length(stmt, 1, "hello world", 5);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	auto value = duckdb_value_varchar(&res, 0, 0);
+	REQUIRE(string(value) == "hello");
+	REQUIRE(duckdb_value_int8(&res, 0, 0) == 0);
+	duckdb_free(value);
+	duckdb_destroy_result(&res);
+
+	duckdb_bind_blob(stmt, 1, "hello\0world", 11);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	value = duckdb_value_varchar(&res, 0, 0);
+	REQUIRE(string(value) == "hello\\x00world");
+	REQUIRE(duckdb_value_int8(&res, 0, 0) == 0);
+	duckdb_free(value);
+	duckdb_destroy_result(&res);
+
+	duckdb_date_struct date_struct;
+	date_struct.year = 1992;
+	date_struct.month = 9;
+	date_struct.day = 3;
+
+	duckdb_bind_date(stmt, 1, duckdb_to_date(date_struct));
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	value = duckdb_value_varchar(&res, 0, 0);
+	REQUIRE(string(value) == "1992-09-03");
+	duckdb_free(value);
+	duckdb_destroy_result(&res);
+
+	duckdb_time_struct time_struct;
+	time_struct.hour = 12;
+	time_struct.min = 22;
+	time_struct.sec = 33;
+	time_struct.micros = 123400;
+
+	duckdb_bind_time(stmt, 1, duckdb_to_time(time_struct));
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	value = duckdb_value_varchar(&res, 0, 0);
+	REQUIRE(string(value) == "12:22:33.1234");
+	duckdb_free(value);
+	duckdb_destroy_result(&res);
+
+	duckdb_timestamp_struct ts;
+	ts.date = date_struct;
+	ts.time = time_struct;
+
+	duckdb_bind_timestamp(stmt, 1, duckdb_to_timestamp(ts));
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	value = duckdb_value_varchar(&res, 0, 0);
+	REQUIRE(string(value) == "1992-09-03 12:22:33.1234");
+	duckdb_free(value);
+	duckdb_destroy_result(&res);
+
+	duckdb_interval interval;
+	interval.months = 3;
+	interval.days = 0;
+	interval.micros = 0;
+
+	duckdb_bind_interval(stmt, 1, interval);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	value = duckdb_value_varchar(&res, 0, 0);
+	REQUIRE(string(value) == "3 months");
+	duckdb_free(value);
+	duckdb_destroy_result(&res);
+
+	duckdb_destroy_prepare(&stmt);
+
+	status = duckdb_query(tester.connection, "CREATE TABLE a (i INTEGER)", NULL);
+	REQUIRE(status == DuckDBSuccess);
+
+	status = duckdb_prepare(tester.connection, "INSERT INTO a VALUES (?)", &stmt);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(stmt != nullptr);
+	REQUIRE(duckdb_nparams(nullptr) == 0);
+	REQUIRE(duckdb_nparams(stmt) == 1);
+	REQUIRE(duckdb_param_type(nullptr, 0) == DUCKDB_TYPE_INVALID);
+	REQUIRE(duckdb_param_type(stmt, 0) == DUCKDB_TYPE_INVALID);
+	REQUIRE(duckdb_param_type(stmt, 1) == DUCKDB_TYPE_INTEGER);
+	REQUIRE(duckdb_param_type(stmt, 2) == DUCKDB_TYPE_INVALID);
+
+	for (int32_t i = 1; i <= 1000; i++) {
+		duckdb_bind_int32(stmt, 1, i);
+		status = duckdb_execute_prepared(stmt, nullptr);
+		REQUIRE(status == DuckDBSuccess);
+	}
+	duckdb_destroy_prepare(&stmt);
+
+	status = duckdb_prepare(tester.connection, "SELECT SUM(i)*$1-$2 FROM a", &stmt);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(stmt != nullptr);
+	duckdb_bind_int32(stmt, 1, 2);
+	duckdb_bind_int32(stmt, 2, 1000);
+
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(duckdb_value_int32(&res, 0, 0) == 1000000);
+	duckdb_destroy_result(&res);
+	duckdb_destroy_prepare(&stmt);
+
+	// not-so-happy path
+	status = duckdb_prepare(tester.connection, "SELECT XXXXX", &stmt);
+	REQUIRE(status == DuckDBError);
+	duckdb_destroy_prepare(&stmt);
+
+	status = duckdb_prepare(tester.connection, "SELECT CAST($1 AS INTEGER)", &stmt);
+	REQUIRE(status == DuckDBSuccess);
+	REQUIRE(stmt != nullptr);
+
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBError);
+	duckdb_destroy_result(&res);
+	duckdb_destroy_prepare(&stmt);
+
+	// test duckdb_malloc explicitly
+	auto malloced_data = duckdb_malloc(100);
+	memcpy(malloced_data, "hello\0", 6);
+	REQUIRE(string((char *)malloced_data) == "hello");
+	duckdb_free(malloced_data);
+}
diff --git a/test/api/capi/test_capi_replacement_scan.cpp b/test/api/capi/test_capi_replacement_scan.cpp
new file mode 100644
index 000000000000..c3d0c7a4d981
--- /dev/null
+++ b/test/api/capi/test_capi_replacement_scan.cpp
@@ -0,0 +1,62 @@
+#include "capi_tester.hpp"
+
+using namespace duckdb;
+using namespace std;
+
+struct MyBaseNumber {
+	int number;
+};
+
+void destroy_base_number(void *data) {
+	auto num = (MyBaseNumber *)data;
+	delete num;
+}
+
+void number_scanner(duckdb_replacement_scan_info info, const char *table_name, void *data) {
+	// check if the table name is a number
+	long long number;
+	try {
+		number = std::stoll(table_name);
+	} catch (...) {
+		// not a number!
+		return;
+	}
+	auto num_data = (MyBaseNumber *)data;
+	duckdb_replacement_scan_set_function_name(info, "range");
+	auto val = duckdb_create_int64(number + num_data->number);
+	duckdb_replacement_scan_add_parameter(info, val);
+	duckdb_destroy_value(&val);
+}
+
+TEST_CASE("Test replacement scans in C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+
+	// open the database in in-memory mode
+	REQUIRE(tester.OpenDatabase(nullptr));
+
+	auto base_number = new MyBaseNumber();
+	base_number->number = 3;
+
+	duckdb_add_replacement_scan(tester.database, number_scanner, (void *)base_number, destroy_base_number);
+
+	// 0-4
+	result = tester.Query("SELECT * FROM \"2\"");
+	REQUIRE(result->row_count() == 5);
+	REQUIRE(result->Fetch<int64_t>(0, 0) == 0);
+	REQUIRE(result->Fetch<int64_t>(0, 1) == 1);
+	REQUIRE(result->Fetch<int64_t>(0, 2) == 2);
+	REQUIRE(result->Fetch<int64_t>(0, 3) == 3);
+	REQUIRE(result->Fetch<int64_t>(0, 4) == 4);
+
+	base_number->number = 1;
+	// 0-2
+	result = tester.Query("SELECT * FROM \"2\"");
+	REQUIRE(result->row_count() == 3);
+	REQUIRE(result->Fetch<int64_t>(0, 0) == 0);
+	REQUIRE(result->Fetch<int64_t>(0, 1) == 1);
+	REQUIRE(result->Fetch<int64_t>(0, 2) == 2);
+
+	// not a number
+	REQUIRE_FAIL(tester.Query("SELECT * FROM nonexistant"));
+}
diff --git a/test/api/capi/test_capi_website.cpp b/test/api/capi/test_capi_website.cpp
new file mode 100644
index 000000000000..42d6c2350fea
--- /dev/null
+++ b/test/api/capi/test_capi_website.cpp
@@ -0,0 +1,187 @@
+#include "capi_tester.hpp"
+
+using namespace duckdb;
+using namespace std;
+
+TEST_CASE("Test C API examples from the website", "[capi]") {
+	// NOTE: if any of these break and need to be changed, the website also needs to be updated!
+	SECTION("connect") {
+		duckdb_database db;
+		duckdb_connection con;
+
+		if (duckdb_open(NULL, &db) == DuckDBError) {
+			// handle error
+		}
+		if (duckdb_connect(db, &con) == DuckDBError) {
+			// handle error
+		}
+
+		// run queries...
+
+		// cleanup
+		duckdb_disconnect(&con);
+		duckdb_close(&db);
+	}
+	SECTION("config") {
+		duckdb_database db;
+		duckdb_config config;
+
+		// create the configuration object
+		if (duckdb_create_config(&config) == DuckDBError) {
+			REQUIRE(1 == 0);
+		}
+		// set some configuration options
+		duckdb_set_config(config, "access_mode", "READ_WRITE");
+		duckdb_set_config(config, "threads", "8");
+		duckdb_set_config(config, "max_memory", "8GB");
+		duckdb_set_config(config, "default_order", "DESC");
+
+		// open the database using the configuration
+		if (duckdb_open_ext(NULL, &db, config, NULL) == DuckDBError) {
+			REQUIRE(1 == 0);
+		}
+		// cleanup the configuration object
+		duckdb_destroy_config(&config);
+
+		// run queries...
+
+		// cleanup
+		duckdb_close(&db);
+	}
+	SECTION("query") {
+		duckdb_database db;
+		duckdb_connection con;
+		duckdb_state state;
+		duckdb_result result;
+
+		duckdb_open(NULL, &db);
+		duckdb_connect(db, &con);
+
+		// create a table
+		state = duckdb_query(con, "CREATE TABLE integers(i INTEGER, j INTEGER);", NULL);
+		if (state == DuckDBError) {
+			REQUIRE(1 == 0);
+		}
+		// insert three rows into the table
+		state = duckdb_query(con, "INSERT INTO integers VALUES (3, 4), (5, 6), (7, NULL);", NULL);
+		if (state == DuckDBError) {
+			REQUIRE(1 == 0);
+		}
+		// query rows again
+		state = duckdb_query(con, "SELECT * FROM integers", &result);
+		if (state == DuckDBError) {
+			REQUIRE(1 == 0);
+		}
+		// handle the result
+		idx_t row_count = duckdb_row_count(&result);
+		idx_t column_count = duckdb_column_count(&result);
+		for (idx_t row = 0; row < row_count; row++) {
+			for (idx_t col = 0; col < column_count; col++) {
+				// if (col > 0) printf(",");
+				auto str_val = duckdb_value_varchar(&result, col, row);
+				// printf("%s", str_val);
+				REQUIRE(1 == 1);
+				duckdb_free(str_val);
+			}
+			//	printf("
");
+		}
+
+		int32_t *i_data = (int32_t *)duckdb_column_data(&result, 0);
+		int32_t *j_data = (int32_t *)duckdb_column_data(&result, 1);
+		bool *i_mask = duckdb_nullmask_data(&result, 0);
+		bool *j_mask = duckdb_nullmask_data(&result, 1);
+		for (idx_t row = 0; row < row_count; row++) {
+			if (i_mask[row]) {
+				// printf("NULL");
+			} else {
+				REQUIRE(i_data[row] > 0);
+				// printf("%d", i_data[row]);
+			}
+			// printf(",");
+			if (j_mask[row]) {
+				// printf("NULL");
+			} else {
+				REQUIRE(j_data[row] > 0);
+				// printf("%d", j_data[row]);
+			}
+			// printf("
");
+		}
+
+		// destroy the result after we are done with it
+		duckdb_destroy_result(&result);
+		duckdb_disconnect(&con);
+		duckdb_close(&db);
+	}
+	SECTION("prepared") {
+		duckdb_database db;
+		duckdb_connection con;
+		duckdb_open(NULL, &db);
+		duckdb_connect(db, &con);
+		duckdb_query(con, "CREATE TABLE integers(i INTEGER, j INTEGER)", NULL);
+
+		duckdb_prepared_statement stmt;
+		duckdb_result result;
+		if (duckdb_prepare(con, "INSERT INTO integers VALUES ($1, $2)", &stmt) == DuckDBError) {
+			REQUIRE(1 == 0);
+		}
+
+		duckdb_bind_int32(stmt, 1, 42); // the parameter index starts counting at 1!
+		duckdb_bind_int32(stmt, 2, 43);
+		// NULL as second parameter means no result set is requested
+		duckdb_execute_prepared(stmt, NULL);
+		duckdb_destroy_prepare(&stmt);
+
+		// we can also query result sets using prepared statements
+		if (duckdb_prepare(con, "SELECT * FROM integers WHERE i = ?", &stmt) == DuckDBError) {
+			REQUIRE(1 == 0);
+		}
+		duckdb_bind_int32(stmt, 1, 42);
+		duckdb_execute_prepared(stmt, &result);
+
+		// do something with result
+
+		// clean up
+		duckdb_destroy_result(&result);
+		duckdb_destroy_prepare(&stmt);
+
+		duckdb_disconnect(&con);
+		duckdb_close(&db);
+	}
+	SECTION("appender") {
+		duckdb_database db;
+		duckdb_connection con;
+		duckdb_open(NULL, &db);
+		duckdb_connect(db, &con);
+		duckdb_query(con, "CREATE TABLE people(id INTEGER, name VARCHAR)", NULL);
+
+		duckdb_appender appender;
+		if (duckdb_appender_create(con, NULL, "people", &appender) == DuckDBError) {
+			REQUIRE(1 == 0);
+		}
+		duckdb_append_int32(appender, 1);
+		duckdb_append_varchar(appender, "Mark");
+		duckdb_appender_end_row(appender);
+
+		duckdb_append_int32(appender, 2);
+		duckdb_append_varchar(appender, "Hannes");
+		duckdb_appender_end_row(appender);
+
+		duckdb_appender_destroy(&appender);
+
+		duckdb_result result;
+		duckdb_query(con, "SELECT * FROM people", &result);
+		REQUIRE(duckdb_value_int32(&result, 0, 0) == 1);
+		REQUIRE(duckdb_value_int32(&result, 0, 1) == 2);
+		REQUIRE(string(duckdb_value_varchar_internal(&result, 1, 0)) == "Mark");
+		REQUIRE(string(duckdb_value_varchar_internal(&result, 1, 1)) == "Hannes");
+
+		// error conditions: we cannot
+		REQUIRE(duckdb_value_varchar_internal(&result, 0, 0) == nullptr);
+		REQUIRE(duckdb_value_varchar_internal(nullptr, 0, 0) == nullptr);
+
+		duckdb_destroy_result(&result);
+
+		duckdb_disconnect(&con);
+		duckdb_close(&db);
+	}
+}
diff --git a/test/helpers/CMakeLists.txt b/test/helpers/CMakeLists.txt
index 37171ba6ae1d..914488596538 100644
--- a/test/helpers/CMakeLists.txt
+++ b/test/helpers/CMakeLists.txt
@@ -1,4 +1,5 @@
-set(DUCKDB_TEST_HELPERS_UNITS test_helpers.cpp test_helper_extension.cpp)
+set(DUCKDB_TEST_HELPERS_UNITS test_helpers.cpp test_helper_extension.cpp
+                              capi_tester.cpp)
 
 add_library(test_helpers STATIC ${DUCKDB_TEST_HELPERS_UNITS})
 
diff --git a/test/helpers/capi_tester.cpp b/test/helpers/capi_tester.cpp
new file mode 100644
index 000000000000..1054da40f465
--- /dev/null
+++ b/test/helpers/capi_tester.cpp
@@ -0,0 +1,133 @@
+#include "capi_tester.hpp"
+
+bool NO_FAIL(duckdb::CAPIResult &result) {
+	return result.success;
+}
+
+bool NO_FAIL(duckdb::unique_ptr<duckdb::CAPIResult> result) {
+	return NO_FAIL(*result);
+}
+
+namespace duckdb {
+
+template <>
+bool CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_boolean(&result, col, row);
+}
+
+template <>
+int8_t CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_int8(&result, col, row);
+}
+
+template <>
+int16_t CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_int16(&result, col, row);
+}
+
+template <>
+int32_t CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_int32(&result, col, row);
+}
+
+template <>
+int64_t CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_int64(&result, col, row);
+}
+
+template <>
+uint8_t CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_uint8(&result, col, row);
+}
+
+template <>
+uint16_t CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_uint16(&result, col, row);
+}
+
+template <>
+uint32_t CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_uint32(&result, col, row);
+}
+
+template <>
+uint64_t CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_uint64(&result, col, row);
+}
+
+template <>
+float CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_float(&result, col, row);
+}
+
+template <>
+double CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_double(&result, col, row);
+}
+
+template <>
+duckdb_decimal CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_decimal(&result, col, row);
+}
+
+template <>
+duckdb_date CAPIResult::Fetch(idx_t col, idx_t row) {
+	auto data = (duckdb_date *)duckdb_column_data(&result, col);
+	return data[row];
+}
+
+template <>
+duckdb_time CAPIResult::Fetch(idx_t col, idx_t row) {
+	auto data = (duckdb_time *)duckdb_column_data(&result, col);
+	return data[row];
+}
+
+template <>
+duckdb_timestamp CAPIResult::Fetch(idx_t col, idx_t row) {
+	auto data = (duckdb_timestamp *)duckdb_column_data(&result, col);
+	return data[row];
+}
+
+template <>
+duckdb_interval CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_interval(&result, col, row);
+}
+
+template <>
+duckdb_blob CAPIResult::Fetch(idx_t col, idx_t row) {
+	auto data = (duckdb_blob *)duckdb_column_data(&result, col);
+	return data[row];
+}
+
+template <>
+string CAPIResult::Fetch(idx_t col, idx_t row) {
+	auto value = duckdb_value_varchar(&result, col, row);
+	string strval = value ? string(value) : string();
+	free((void *)value);
+	return strval;
+}
+
+template <>
+duckdb_date_struct CAPIResult::Fetch(idx_t col, idx_t row) {
+	auto value = duckdb_value_date(&result, col, row);
+	return duckdb_from_date(value);
+}
+
+template <>
+duckdb_time_struct CAPIResult::Fetch(idx_t col, idx_t row) {
+	auto value = duckdb_value_time(&result, col, row);
+	return duckdb_from_time(value);
+}
+
+template <>
+duckdb_timestamp_struct CAPIResult::Fetch(idx_t col, idx_t row) {
+	auto value = duckdb_value_timestamp(&result, col, row);
+	return duckdb_from_timestamp(value);
+}
+
+template <>
+duckdb_hugeint CAPIResult::Fetch(idx_t col, idx_t row) {
+	return duckdb_value_hugeint(&result, col, row);
+}
+
+} // namespace duckdb
diff --git a/test/include/capi_tester.hpp b/test/include/capi_tester.hpp
new file mode 100644
index 000000000000..cd404ee4bc10
--- /dev/null
+++ b/test/include/capi_tester.hpp
@@ -0,0 +1,207 @@
+#pragma once
+
+#include "catch.hpp"
+#include "duckdb.h"
+#include "test_helpers.hpp"
+#include "duckdb/common/arrow.hpp"
+#include "duckdb/common/exception.hpp"
+
+namespace duckdb {
+
+class CAPIDataChunk {
+public:
+	CAPIDataChunk(duckdb_data_chunk chunk_p) : chunk(chunk_p) {
+	}
+	~CAPIDataChunk() {
+		duckdb_destroy_data_chunk(&chunk);
+	}
+
+	idx_t ColumnCount() {
+		return duckdb_data_chunk_get_column_count(chunk);
+	}
+	idx_t size() {
+		return duckdb_data_chunk_get_size(chunk);
+	}
+	duckdb_vector GetVector(idx_t col) {
+		return duckdb_data_chunk_get_vector(chunk, col);
+	}
+	void *GetData(idx_t col) {
+		return duckdb_vector_get_data(GetVector(col));
+	}
+	uint64_t *GetValidity(idx_t col) {
+		return duckdb_vector_get_validity(GetVector(col));
+	}
+	duckdb_data_chunk GetChunk() {
+		return chunk;
+	}
+
+private:
+	duckdb_data_chunk chunk;
+};
+
+class CAPIResult {
+public:
+	~CAPIResult() {
+		duckdb_destroy_result(&result);
+	}
+	void Query(duckdb_connection connection, string query) {
+		success = (duckdb_query(connection, query.c_str(), &result) == DuckDBSuccess);
+		if (!success) {
+			REQUIRE(ErrorMessage() != nullptr);
+		}
+	}
+
+	duckdb_type ColumnType(idx_t col) {
+		return duckdb_column_type(&result, col);
+	}
+
+	idx_t ChunkCount() {
+		return duckdb_result_chunk_count(result);
+	}
+
+	unique_ptr<CAPIDataChunk> FetchChunk(idx_t chunk_idx) {
+		auto chunk = duckdb_result_get_chunk(result, chunk_idx);
+		if (!chunk) {
+			return nullptr;
+		}
+		return make_unique<CAPIDataChunk>(chunk);
+	}
+
+	template <class T>
+	T *ColumnData(idx_t col) {
+		return (T *)duckdb_column_data(&result, col);
+	}
+
+	idx_t ColumnCount() {
+		return duckdb_column_count(&result);
+	}
+
+	idx_t row_count() {
+		return duckdb_row_count(&result);
+	}
+
+	idx_t rows_changed() {
+		return duckdb_rows_changed(&result);
+	}
+
+	template <class T>
+	T Fetch(idx_t col, idx_t row) {
+		throw NotImplementedException("Unimplemented type for fetch");
+	}
+
+	bool IsNull(idx_t col, idx_t row) {
+		auto nullmask_ptr = duckdb_nullmask_data(&result, col);
+		REQUIRE(duckdb_value_is_null(&result, col, row) == nullmask_ptr[row]);
+		return nullmask_ptr[row];
+	}
+
+	const char *ErrorMessage() {
+		return duckdb_result_error(&result);
+	}
+
+	string ColumnName(idx_t col) {
+		auto colname = duckdb_column_name(&result, col);
+		return colname ? string(colname) : string();
+	}
+
+	duckdb_result &InternalResult() {
+		return result;
+	}
+
+public:
+	bool success = false;
+
+private:
+	duckdb_result result;
+};
+
+template <>
+bool CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+int8_t CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+int16_t CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+int32_t CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+int64_t CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+uint8_t CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+uint16_t CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+uint32_t CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+uint64_t CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+float CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+double CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+duckdb_decimal CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+duckdb_date CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+duckdb_time CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+duckdb_timestamp CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+duckdb_interval CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+duckdb_blob CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+string CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+duckdb_date_struct CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+duckdb_time_struct CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+duckdb_timestamp_struct CAPIResult::Fetch(idx_t col, idx_t row);
+template <>
+duckdb_hugeint CAPIResult::Fetch(idx_t col, idx_t row);
+
+class CAPITester {
+public:
+	CAPITester() : database(nullptr), connection(nullptr) {
+	}
+	~CAPITester() {
+		Cleanup();
+	}
+
+	void Cleanup() {
+		if (connection) {
+			duckdb_disconnect(&connection);
+			connection = nullptr;
+		}
+		if (database) {
+			duckdb_close(&database);
+			database = nullptr;
+		}
+	}
+
+	bool OpenDatabase(const char *path) {
+		Cleanup();
+		if (duckdb_open(path, &database) != DuckDBSuccess) {
+			return false;
+		}
+		if (duckdb_connect(database, &connection) != DuckDBSuccess) {
+			return false;
+		}
+		return true;
+	}
+
+	unique_ptr<CAPIResult> Query(string query) {
+		D_ASSERT(connection);
+		auto result = make_unique<CAPIResult>();
+		result->Query(connection, query);
+		return result;
+	}
+
+	duckdb_database database = nullptr;
+	duckdb_connection connection = nullptr;
+};
+
+} // namespace duckdb
+
+bool NO_FAIL(duckdb::CAPIResult &result);
+bool NO_FAIL(duckdb::unique_ptr<duckdb::CAPIResult> result);
diff --git a/tools/juliapkg/test.sh b/tools/juliapkg/test.sh
new file mode 100755
index 000000000000..8b700f4fe94f
--- /dev/null
+++ b/tools/juliapkg/test.sh
@@ -0,0 +1,8 @@
+set -e
+
+#julia -e "import Pkg; Pkg.activate(\".\"); Pkg.instantiate(); include(\"test/runtests.jl\")" $1
+
+export JULIA_DUCKDB_LIBRARY="/Users/myth/Programs/duckdb-bugfix/build/debug/src/libduckdb.dylib"
+#export JULIA_DUCKDB_LIBRARY="/Users/myth/Programs/duckdb-bugfix/build/release/src/libduckdb.dylib"
+
+julia -e "import Pkg; Pkg.activate(\".\"); include(\"test/runtests.jl\")" $1
diff --git a/tools/juliapkg/test/Project.toml b/tools/juliapkg/test/Project.toml
new file mode 100644
index 000000000000..ab19f1c36989
--- /dev/null
+++ b/tools/juliapkg/test/Project.toml
@@ -0,0 +1,6 @@
+[deps]
+DBInterface = "a10d1c49-ce27-4219-8d33-6db1a4562965"
+SQLite = "0aa819cd-b072-5ff4-a722-6bc24af294d9"
+Tables = "bd369af6-aec1-5ad0-b16a-f7cc5008161c"
+Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"
+WeakRefStrings = "ea10d353-3f73-51f8-a26c-33c1cb351aa5"
diff --git a/tools/juliapkg/test/runtests.jl b/tools/juliapkg/test/runtests.jl
new file mode 100644
index 000000000000..a20ca3a02431
--- /dev/null
+++ b/tools/juliapkg/test/runtests.jl
@@ -0,0 +1,35 @@
+using DataFrames
+using DuckDB
+using Test
+using Dates
+using UUIDs
+
+test_files = [
+    "test_appender.jl",
+    "test_basic_queries.jl",
+    "test_config.jl",
+    "test_connection.jl",
+    "test_df_scan.jl",
+    "test_prepare.jl",
+    "test_transaction.jl",
+    "test_sqlite.jl",
+    "test_replacement_scan.jl",
+    "test_table_function.jl",
+    "test_old_interface.jl",
+    "test_all_types.jl"
+]
+
+if size(ARGS)[1] > 0
+    filtered_test_files = []
+    for test_file in test_files
+        if test_file == ARGS[1]
+            push!(filtered_test_files, test_file)
+        end
+    end
+    test_files = filtered_test_files
+end
+
+for fname in test_files
+    println(fname)
+    include(fname)
+end
diff --git a/tools/juliapkg/test/test_all_types.jl b/tools/juliapkg/test/test_all_types.jl
new file mode 100644
index 000000000000..a2c2769ae645
--- /dev/null
+++ b/tools/juliapkg/test/test_all_types.jl
@@ -0,0 +1,132 @@
+# test_all_types.jl
+
+
+@testset "Test All Types" begin
+    db = DBInterface.connect(DuckDB.DB)
+    con = DBInterface.connect(db)
+
+    df = DataFrame(DBInterface.execute(con, "SELECT * FROM test_all_types()"))
+
+    @test isequal(df.bool, [false, true, missing])
+    @test isequal(df.tinyint, [-128, 127, missing])
+    @test isequal(df.smallint, [-32768, 32767, missing])
+    @test isequal(df.int, [-2147483648, 2147483647, missing])
+    @test isequal(df.bigint, [-9223372036854775808, 9223372036854775807, missing])
+    @test isequal(
+        df.hugeint,
+        [-170141183460469231731687303715884105727, 170141183460469231731687303715884105727, missing]
+    )
+    @test isequal(df.utinyint, [0, 255, missing])
+    @test isequal(df.usmallint, [0, 65535, missing])
+    @test isequal(df.uint, [0, 4294967295, missing])
+    @test isequal(df.ubigint, [0, 18446744073709551615, missing])
+    @test isequal(df.float, [-3.4028235f38, 3.4028235f38, missing])
+    @test isequal(df.double, [-1.7976931348623157e308, 1.7976931348623157e308, missing])
+    @test isequal(df.dec_4_1, [-999.9, 999.9, missing])
+    @test isequal(df.dec_9_4, [-99999.9999, 99999.9999, missing])
+    @test isequal(df.dec_18_6, [-999999999999.999999, 999999999999.999999, missing])
+    @test isequal(
+        df.dec38_10,
+        [-9999999999999999999999999999.9999999999, 9999999999999999999999999999.9999999999, missing]
+    )
+    @test isequal(
+        df.dec38_10,
+        [-9999999999999999999999999999.9999999999, 9999999999999999999999999999.9999999999, missing]
+    )
+    @test isequal(
+        df.dec38_10,
+        [-9999999999999999999999999999.9999999999, 9999999999999999999999999999.9999999999, missing]
+    )
+    @test isequal(df.json, ["🦆🦆🦆🦆🦆🦆", "goose", missing])
+    @test isequal(df.small_enum, ["DUCK_DUCK_ENUM", "GOOSE", missing])
+    @test isequal(df.medium_enum, ["enum_0", "enum_299", missing])
+    @test isequal(df.large_enum, ["enum_0", "enum_69999", missing])
+    @test isequal(df.date, [Dates.Date(-5877641, 6, 23), Dates.Date(5881580, 7, 11), missing])
+    @test isequal(df.time, [Dates.Time(0, 0, 0), Dates.Time(23, 59, 59, 999, 999), missing])
+    @test isequal(df.time_tz, [Dates.Time(0, 0, 0), Dates.Time(23, 59, 59, 999, 999), missing])
+    @test isequal(
+        df.timestamp,
+        [Dates.DateTime(-290308, 12, 22, 0, 0, 0), Dates.DateTime(294247, 1, 10, 4, 0, 54, 775), missing]
+    )
+    @test isequal(
+        df.timestamp_tz,
+        [Dates.DateTime(-290308, 12, 22, 0, 0, 0), Dates.DateTime(294247, 1, 10, 4, 0, 54, 775), missing]
+    )
+    @test isequal(
+        df.timestamp_s,
+        [Dates.DateTime(-290308, 12, 22, 0, 0, 0), Dates.DateTime(294247, 1, 10, 4, 0, 54, 0), missing]
+    )
+    @test isequal(
+        df.timestamp_ms,
+        [Dates.DateTime(-290308, 12, 22, 0, 0, 0), Dates.DateTime(294247, 1, 10, 4, 0, 54, 775), missing]
+    )
+    @test isequal(
+        df.timestamp_ns,
+        [Dates.DateTime(1677, 9, 21, 0, 12, 43, 146), Dates.DateTime(2262, 4, 11, 23, 47, 16, 854), missing]
+    )
+    @test isequal(
+        df.interval,
+        [
+            Dates.CompoundPeriod(Dates.Month(0), Dates.Day(0), Dates.Microsecond(0)),
+            Dates.CompoundPeriod(Dates.Month(999), Dates.Day(999), Dates.Microsecond(999999999)),
+            missing
+        ]
+    )
+    @test isequal(df.varchar, ["🦆🦆🦆🦆🦆🦆", "goose", missing])
+    @test isequal(
+        df.blob,
+        [
+            UInt8[
+                0x74,
+                0x68,
+                0x69,
+                0x73,
+                0x69,
+                0x73,
+                0x61,
+                0x6c,
+                0x6f,
+                0x6e,
+                0x67,
+                0x62,
+                0x6c,
+                0x6f,
+                0x62,
+                0x00,
+                0x77,
+                0x69,
+                0x74,
+                0x68,
+                0x6e,
+                0x75,
+                0x6c,
+                0x6c,
+                0x62,
+                0x79,
+                0x74,
+                0x65,
+                0x73
+            ],
+            UInt8[0x5c, 0x78, 0x30, 0x30, 0x5c, 0x78, 0x30, 0x30, 0x5c, 0x78, 0x30, 0x30, 0x61],
+            missing
+        ]
+    )
+    @test isequal(df.uuid, [UUID(1), UUID(UInt128(340282366920938463463374607431768211455)), missing])
+    @test isequal(df.int_array, [[], [42, 999, missing, missing, -42], missing])
+    @test isequal(df.varchar_array, [[], ["🦆🦆🦆🦆🦆🦆", "goose", missing, ""], missing])
+    @test isequal(
+        df.nested_int_array,
+        [[], [[], [42, 999, missing, missing, -42], missing, [], [42, 999, missing, missing, -42]], missing]
+    )
+    @test isequal(df.struct, [(a = missing, b = missing), (a = 42, b = "🦆🦆🦆🦆🦆🦆"), missing])
+    @test isequal(
+        df.struct_of_arrays,
+        [
+            (a = missing, b = missing),
+            (a = [42, 999, missing, missing, -42], b = ["🦆🦆🦆🦆🦆🦆", "goose", missing, ""]),
+            missing
+        ]
+    )
+    @test isequal(df.array_of_structs, [[], [(a = missing, b = missing), (a = 42, b = "🦆🦆🦆🦆🦆🦆"), missing], missing])
+    @test isequal(df.map, [Dict(), Dict("key1" => "🦆🦆🦆🦆🦆🦆", "key2" => "goose"), missing])
+end
diff --git a/tools/juliapkg/test/test_appender.jl b/tools/juliapkg/test/test_appender.jl
new file mode 100644
index 000000000000..64a7c2c6b71b
--- /dev/null
+++ b/tools/juliapkg/test/test_appender.jl
@@ -0,0 +1,89 @@
+
+@testset "Appender Error" begin
+    db = DBInterface.connect(DuckDB.DB)
+    con = DBInterface.connect(db)
+
+    @test_throws DuckDB.QueryException DuckDB.Appender(db, "nonexistanttable")
+    @test_throws DuckDB.QueryException DuckDB.Appender(con, "t")
+end
+
+@testset "Appender Usage" begin
+    db = DBInterface.connect(DuckDB.DB)
+
+    DBInterface.execute(db, "CREATE TABLE integers(i INTEGER)")
+
+    appender = DuckDB.Appender(db, "integers")
+    DuckDB.close(appender)
+    DuckDB.close(appender)
+
+    appender = DuckDB.Appender(db, "integers")
+    for i in 0:9
+        DuckDB.Append(appender, i)
+        DuckDB.EndRow(appender)
+    end
+    DuckDB.Flush(appender)
+
+    results = DBInterface.execute(db, "SELECT * FROM integers")
+    df = DataFrame(results)
+    @test names(df) == ["i"]
+    @test size(df, 1) == 10
+    @test df.i == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
+end
+
+# @testset "Appender API" begin
+#     # Open the database
+#     db = DuckDB.open(":memory:")
+#     con = DuckDB.connect(db)
+#
+#     # Create the table the data is appended to
+#     DuckDB.execute(con, "CREATE TABLE dtypes(bol BOOLEAN, tint TINYINT, sint SMALLINT, int INTEGER, bint BIGINT, utint UTINYINT, usint USMALLINT, uint UINTEGER, ubint UBIGINT, float FLOAT, double DOUBLE, date DATE, time TIME, vchar VARCHAR, nullval INTEGER)")
+#
+#     # Create the appender
+#     appender = DuckDB.appender_create(con, "dtypes")
+#
+#     # Append the different data types
+#     DuckDB.duckdb_append_bool(appender, true)
+#     DuckDB.duckdb_append_int8(appender, 1)
+#     DuckDB.duckdb_append_int16(appender, 2)
+#     DuckDB.duckdb_append_int32(appender, 3)
+#     DuckDB.duckdb_append_int64(appender, 4)
+#     DuckDB.duckdb_append_uint8(appender, 1)
+#     DuckDB.duckdb_append_uint16(appender, 2)
+#     DuckDB.duckdb_append_uint32(appender, 3)
+#     DuckDB.duckdb_append_uint64(appender, 4)
+#     DuckDB.duckdb_append_float(appender, 1.0)
+#     DuckDB.duckdb_append_double(appender, 2.0)
+#     DuckDB.duckdb_append_date(appender, 100)
+#     DuckDB.duckdb_append_time(appender, 200)
+#     DuckDB.duckdb_append_varchar(appender, "Foo")
+#     DuckDB.duckdb_append_null(appender)
+#     # End the row of the appender
+#     DuckDB.duckdb_appender_end_row(appender)
+#     # Destroy the appender and flush the data
+#     DuckDB.duckdb_appender_destroy(appender)
+#
+#     # Retrive the data from the table and store it in  a vector
+#     df = DuckDB.toDataFrame(con, "select * from dtypes;")
+#     data = Matrix(df)
+#
+#     # Test if the correct types have been appended to the table
+#     @test data[1] === true
+#     @test data[2] === Int8(1)
+#     @test data[3] === Int16(2)
+#     @test data[4] === Int32(3)
+#     @test data[5] === Int64(4)
+#     @test data[6] === UInt8(1)
+#     @test data[7] === UInt16(2)
+#     @test data[8] === UInt32(3)
+#     @test data[9] === UInt64(4)
+#     @test data[10] === Float32(1.0)
+#     @test data[11] === Float64(2.0)
+#     @test data[12] === Dates.Date("1970-04-11")
+#     @test data[13] === Dates.Time(0, 0, 0, 0, 200)
+#     @test data[14] === "Foo"
+#     @test data[15] === missing
+#
+#     # Disconnect and close the database
+#     DuckDB.disconnect(con)
+#     DuckDB.close(db)
+# end
diff --git a/tools/juliapkg/test/test_basic_queries.jl b/tools/juliapkg/test/test_basic_queries.jl
new file mode 100644
index 000000000000..64b045e1f9d9
--- /dev/null
+++ b/tools/juliapkg/test/test_basic_queries.jl
@@ -0,0 +1,91 @@
+# test_basic_queries.jl
+
+@testset "Test DBInterface.execute" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    results = DBInterface.execute(con, "SELECT 42 a")
+
+    # iterator
+    for row in results
+        @test row.a == 42
+        @test row[1] == 42
+    end
+
+    # convert to DataFrame
+    df = DataFrame(results)
+    @test names(df) == ["a"]
+    @test size(df, 1) == 1
+    @test df.a == [42]
+
+    DBInterface.close!(con)
+end
+
+@testset "Test numeric data types" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    results = DBInterface.execute(
+        con,
+        """
+SELECT 42::TINYINT a, 42::INT16 b, 42::INT32 c, 42::INT64 d, 42::UINT8 e, 42::UINT16 f, 42::UINT32 g, 42::UINT64 h
+UNION ALL
+SELECT NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
+"""
+    )
+
+    df = DataFrame(results)
+
+    @test size(df, 1) == 2
+    @test isequal(df.a, [42, missing])
+    @test isequal(df.b, [42, missing])
+    @test isequal(df.c, [42, missing])
+    @test isequal(df.d, [42, missing])
+    @test isequal(df.e, [42, missing])
+    @test isequal(df.f, [42, missing])
+    @test isequal(df.g, [42, missing])
+    @test isequal(df.h, [42, missing])
+
+    DBInterface.close!(con)
+end
+
+@testset "Test strings" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    results = DBInterface.execute(
+        con,
+        """
+SELECT 'hello world' s
+UNION ALL
+SELECT NULL
+UNION ALL
+SELECT 'this is a long string'
+UNION ALL
+SELECT 'obligatory mühleisen'
+UNION ALL
+SELECT '🦆🍞🦆'
+"""
+    )
+
+    df = DataFrame(results)
+    @test size(df, 1) == 5
+    @test isequal(df.s, ["hello world", missing, "this is a long string", "obligatory mühleisen", "🦆🍞🦆"])
+
+    DBInterface.close!(con)
+end
+
+@testset "DBInterface.execute errors" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    # parser error
+    @test_throws DuckDB.QueryException DBInterface.execute(con, "SELEC")
+
+    # binder error
+    @test_throws DuckDB.QueryException DBInterface.execute(con, "SELECT * FROM this_table_does_not_exist")
+
+    # run-time error
+    @test_throws DuckDB.QueryException DBInterface.execute(
+        con,
+        "SELECT i::int FROM (SELECT '42' UNION ALL SELECT 'hello') tbl(i)"
+    )
+
+    DBInterface.close!(con)
+end
diff --git a/tools/juliapkg/test/test_config.jl b/tools/juliapkg/test/test_config.jl
new file mode 100644
index 000000000000..554d56148bc3
--- /dev/null
+++ b/tools/juliapkg/test/test_config.jl
@@ -0,0 +1,32 @@
+# test_config.jl
+
+@testset "Test configuration parameters" begin
+    # by default NULLs come first
+    con = DBInterface.connect(DuckDB.DB, ":memory:")
+
+    results = DBInterface.execute(con, "SELECT 42 a UNION ALL SELECT NULL ORDER BY a")
+    df = DataFrame(results)
+    @test names(df) == ["a"]
+    @test size(df, 1) == 2
+    @test isequal(df.a, [missing, 42])
+
+    DBInterface.close!(con)
+
+    # if we add this configuration flag, nulls should come last
+    config = DuckDB.Config()
+    DuckDB.SetConfig(config, "default_null_order", "nulls_last")
+    @test_throws DuckDB.QueryException DuckDB.SetConfig(config, "unrecognized option", "aaa")
+
+    con = DBInterface.connect(DuckDB.DB, ":memory:", config)
+
+    # NULL should come last now
+    results = DBInterface.execute(con, "SELECT 42 a UNION ALL SELECT NULL ORDER BY a")
+    df = DataFrame(results)
+    @test names(df) == ["a"]
+    @test size(df, 1) == 2
+    @test isequal(df.a, [42, missing])
+
+    DBInterface.close!(config)
+    DBInterface.close!(config)
+    DBInterface.close!(con)
+end
diff --git a/tools/juliapkg/test/test_connection.jl b/tools/juliapkg/test/test_connection.jl
new file mode 100644
index 000000000000..7086ae538bcd
--- /dev/null
+++ b/tools/juliapkg/test/test_connection.jl
@@ -0,0 +1,14 @@
+# test_connection.jl
+
+@testset "Test opening and closing an in-memory database" begin
+    con = DBInterface.connect(DuckDB.DB, ":memory:")
+    DBInterface.close!(con)
+    # verify that double-closing does not cause any problems
+    DBInterface.close!(con)
+    DBInterface.close!(con)
+    @test 1 == 1
+end
+
+@testset "Test opening a bogus directory" begin
+    @test_throws DuckDB.ConnectionException DBInterface.connect(DuckDB.DB, "/path/to/bogus/directory")
+end
diff --git a/tools/juliapkg/test/test_df_scan.jl b/tools/juliapkg/test/test_df_scan.jl
new file mode 100644
index 000000000000..f4c1086e6ee6
--- /dev/null
+++ b/tools/juliapkg/test/test_df_scan.jl
@@ -0,0 +1,96 @@
+# test_df_scan.jl
+
+@testset "Test standard DataFrame scan" begin
+    con = DBInterface.connect(DuckDB.DB)
+    df = DataFrame(a = [1, 2, 3], b = [42, 84, 42])
+
+    DuckDB.RegisterDataFrame(con, df, "my_df")
+    GC.gc()
+
+    results = DBInterface.execute(con, "SELECT * FROM my_df")
+    GC.gc()
+    df = DataFrame(results)
+    @test names(df) == ["a", "b"]
+    @test size(df, 1) == 3
+    @test df.a == [1, 2, 3]
+    @test df.b == [42, 84, 42]
+
+    DBInterface.close!(con)
+end
+
+@testset "Test DataFrame scan with NULL values" begin
+    con = DBInterface.connect(DuckDB.DB)
+    df = DataFrame(a = [1, missing, 3], b = [missing, 84, missing])
+
+    DuckDB.RegisterDataFrame(con, df, "my_df")
+
+    results = DBInterface.execute(con, "SELECT * FROM my_df")
+    df = DataFrame(results)
+    @test names(df) == ["a", "b"]
+    @test size(df, 1) == 3
+    @test isequal(df.a, [1, missing, 3])
+    @test isequal(df.b, [missing, 84, missing])
+
+    DBInterface.close!(con)
+end
+
+@testset "Test DataFrame scan with numerics" begin
+    con = DBInterface.connect(DuckDB.DB)
+    numeric_types = [Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64, Float32, Float64]
+    for type in numeric_types
+        my_df = DataFrame(a = [1, missing, 3], b = [missing, 84, missing])
+        my_df[!, :a] = convert.(Union{type, Missing}, my_df[!, :a])
+        my_df[!, :b] = convert.(Union{type, Missing}, my_df[!, :b])
+
+        DuckDB.RegisterDataFrame(con, my_df, "my_df")
+
+        results = DBInterface.execute(con, "SELECT * FROM my_df")
+        df = DataFrame(results)
+        @test isequal(df, my_df)
+    end
+
+    DBInterface.close!(con)
+end
+
+@testset "Test DataFrame scan with various types" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    # boolean
+    my_df = DataFrame(a = [true, false, missing])
+
+    DuckDB.RegisterDataFrame(con, my_df, "my_df")
+
+    results = DBInterface.execute(con, "SELECT * FROM my_df")
+    df = DataFrame(results)
+    @test isequal(df, my_df)
+
+    # date/time/timestamp
+    my_df = DataFrame(
+        date = [Date(1992, 9, 20), missing, Date(1950, 2, 3)],
+        time = [Time(23, 3, 1), Time(11, 49, 33), missing],
+        timestamp = [DateTime(1992, 9, 20, 23, 3, 1), DateTime(1950, 2, 3, 11, 49, 3), missing]
+    )
+
+    DuckDB.RegisterDataFrame(con, my_df, "my_df")
+
+    results = DBInterface.execute(con, "SELECT * FROM my_df")
+    df = DataFrame(results)
+    @test isequal(df, my_df)
+
+    DBInterface.close!(con)
+end
+
+@testset "Test DataFrame scan with strings" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    # date/time/timestamp
+    my_df = DataFrame(str = ["hello", "this is a very long string", missing, "obligatory mühleisen"])
+
+    DuckDB.RegisterDataFrame(con, my_df, "my_df")
+
+    results = DBInterface.execute(con, "SELECT * FROM my_df")
+    df = DataFrame(results)
+    @test isequal(df, my_df)
+
+    DBInterface.close!(con)
+end
diff --git a/tools/juliapkg/test/test_old_interface.jl b/tools/juliapkg/test/test_old_interface.jl
new file mode 100644
index 000000000000..7dec1e0d3e02
--- /dev/null
+++ b/tools/juliapkg/test/test_old_interface.jl
@@ -0,0 +1,138 @@
+# test_old_interface.jl
+
+@testset "DB Connection" begin
+    db = DuckDB.open(":memory:")
+    con = DuckDB.connect(db)
+    @test isa(con, DuckDB.Connection)
+    DuckDB.disconnect(con)
+    DuckDB.close(db)
+end
+
+@testset "Test append DataFrame" begin
+    # Open the database
+    db = DuckDB.open(":memory:")
+    con = DuckDB.connect(db)
+
+    # Create the table the data is appended to
+    DuckDB.execute(
+        con,
+        "CREATE TABLE dtypes(bool BOOLEAN, tint TINYINT, sint SMALLINT, int INTEGER, bint BIGINT, utint UTINYINT, usint USMALLINT, uint UINTEGER, ubint UBIGINT, float FLOAT, double DOUBLE, date DATE, time TIME, vchar VARCHAR, nullval INTEGER)"
+    )
+
+    # Create test DataFrame
+    input_df = DataFrame(
+        bool = [true, false],
+        tint = Int8.(1:2),
+        sint = Int16.(1:2),
+        int = Int32.(1:2),
+        bint = Int64.(1:2),
+        utint = UInt8.(1:2),
+        usint = UInt16.(1:2),
+        uint = UInt32.(1:2),
+        ubint = UInt64.(1:2),
+        float = Float32.(1:2),
+        double = Float64.(1:2),
+        date = [Dates.Date("1970-04-11"), Dates.Date("1970-04-12")],
+        time = [Dates.Time(0, 0, 0, 100, 0), Dates.Time(0, 0, 0, 200, 0)],
+        vchar = ["Foo", "Bar"],
+        nullval = [missing, Int32(2)]
+    )
+
+    # append the DataFrame to the table
+    DuckDB.appendDataFrame(input_df, con, "dtypes")
+
+    # Output the data from the table
+    output_df = DuckDB.toDataFrame(con, "select * from dtypes;")
+
+    # Compare each column of the input and output dataframe with each other
+    for (col_pos, input_col) in enumerate(eachcol(input_df))
+        @test isequal(input_col, output_df[:, col_pos])
+    end
+
+    # Disconnect and close the database
+    DuckDB.disconnect(con)
+    DuckDB.close(db)
+end
+
+@testset "Test README" begin
+    db = DuckDB.open(":memory:")
+    con = DuckDB.connect(db)
+    res = DuckDB.execute(con, "CREATE TABLE integers(date DATE, jcol INTEGER)")
+    res = DuckDB.execute(con, "INSERT INTO integers VALUES ('2021-09-27', 4), ('2021-09-28', 6), ('2021-09-29', 8)")
+    res = DuckDB.execute(con, "SELECT * FROM integers")
+    df = DuckDB.toDataFrame(res)
+    @test isa(df, DataFrame)
+    df = DuckDB.toDataFrame(con, "SELECT * FROM integers")
+    println(typeof(df))
+    @test isa(df, DataFrame)
+    DuckDB.appendDataFrame(df, con, "integers")
+    DuckDB.disconnect(con)
+    DuckDB.close(db)
+end
+#
+@testset "HUGE Int test" begin
+    db = DuckDB.open(":memory:")
+    con = DuckDB.connect(db)
+    res = DuckDB.execute(con, "CREATE TABLE huge(id INTEGER,data HUGEINT);")
+    res = DuckDB.execute(con, "INSERT INTO huge VALUES (1,NULL), (2, 1761718171), (3, 171661889178);")
+    res = DuckDB.toDataFrame(con, "SELECT * FROM huge")
+    DuckDB.disconnect(con)
+    DuckDB.close(db)
+end
+
+@testset "Interval type" begin
+    db = DuckDB.open(":memory:")
+    con = DuckDB.connect(db)
+    res = DuckDB.execute(con, "CREATE TABLE interval(interval INTERVAL);")
+    res = DuckDB.execute(
+        con,
+        """
+INSERT INTO interval VALUES
+(INTERVAL 5 HOUR),
+(INTERVAL 12 MONTH),
+(INTERVAL 12 MICROSECOND),
+(INTERVAL 1 YEAR);
+"""
+    )
+    res = DuckDB.toDataFrame(con, "SELECT * FROM interval;")
+    @test isa(res, DataFrame)
+    DuckDB.disconnect(con)
+    DuckDB.close(db)
+end
+
+@testset "Timestamp" begin
+    db = DuckDB.open(":memory:")
+    con = DuckDB.connect(db)
+    res = DuckDB.execute(con, "CREATE TABLE timestamp(timestamp TIMESTAMP , data INTEGER);")
+    res = DuckDB.execute(
+        con,
+        "INSERT INTO timestamp VALUES ('2021-09-27 11:30:00.000', 4), ('2021-09-28 12:30:00.000', 6), ('2021-09-29 13:30:00.000', 8);"
+    )
+    res = DuckDB.execute(con, "SELECT * FROM timestamp;")
+    res = DuckDB.toDataFrame(res)
+    @test isa(res, DataFrame)
+    DuckDB.disconnect(con)
+    DuckDB.close(db)
+end
+
+@testset "Items table" begin
+    db = DuckDB.open(":memory:")
+    con = DuckDB.connect(db)
+    res = DuckDB.execute(con, "CREATE TABLE items(item VARCHAR, value DECIMAL(10,2), count INTEGER);")
+    res = DuckDB.execute(con, "INSERT INTO items VALUES ('jeans', 20.0, 1), ('hammer', 42.2, 2);")
+    res = DuckDB.toDataFrame(con, "SELECT * FROM items;")
+    @test isa(res, DataFrame)
+    DuckDB.disconnect(con)
+end
+
+@testset "Integers and dates table" begin
+    db = DuckDB.DB()
+    res = DBInterface.execute(db, "CREATE TABLE integers(date DATE, data INTEGER);")
+    res =
+        DBInterface.execute(db, "INSERT INTO integers VALUES ('2021-09-27', 4), ('2021-09-28', 6), ('2021-09-29', 8);")
+    res = DBInterface.execute(db, "SELECT * FROM integers;")
+    res = DuckDB.toDataFrame(res)
+    @test res.date == [Date(2021, 9, 27), Date(2021, 9, 28), Date(2021, 9, 29)]
+    @test isa(res, DataFrame)
+    DBInterface.close!(db)
+end
diff --git a/tools/juliapkg/test/test_prepare.jl b/tools/juliapkg/test/test_prepare.jl
new file mode 100644
index 000000000000..1edafd90afdc
--- /dev/null
+++ b/tools/juliapkg/test/test_prepare.jl
@@ -0,0 +1,88 @@
+# test_prepare.jl
+
+@testset "Test DBInterface.prepare" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    DBInterface.execute(con, "CREATE TABLE test_table(i INTEGER, j DOUBLE)")
+    stmt = DBInterface.prepare(con, "INSERT INTO test_table VALUES(?, ?)")
+
+    DBInterface.execute(stmt, [1, 3.5])
+    DBInterface.execute(stmt, [missing, nothing])
+    DBInterface.execute(stmt, [2, 0.5])
+
+    results = DBInterface.execute(con, "SELECT * FROM test_table")
+    df = DataFrame(results)
+
+    @test isequal(df.i, [1, missing, 2])
+    @test isequal(df.j, [3.5, missing, 0.5])
+
+    # execute many
+    DBInterface.executemany(stmt, (col1 = [1, 2, 3, 4, 5], col2 = [1, 2, 4, 8, -0.5]))
+
+    results = DBInterface.execute(con, "SELECT * FROM test_table")
+    df = DataFrame(results)
+
+    @test isequal(df.i, [1, missing, 2, 1, 2, 3, 4, 5])
+    @test isequal(df.j, [3.5, missing, 0.5, 1, 2, 4, 8, -0.5])
+
+    # verify that double-closing does not cause any problems
+    DBInterface.close!(stmt)
+    DBInterface.close!(stmt)
+    DBInterface.close!(con)
+    DBInterface.close!(con)
+end
+
+@testset "Test DBInterface.prepare with various types" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    type_names = [
+        "BOOLEAN",
+        "TINYINT",
+        "SMALLINT",
+        "INTEGER",
+        "BIGINT",
+        "UTINYINT",
+        "USMALLINT",
+        "UINTEGER",
+        "UBIGINT",
+        "FLOAT",
+        "DOUBLE",
+        "DATE",
+        "TIME",
+        "TIMESTAMP",
+        "VARCHAR",
+        "INTEGER"
+    ]
+    type_values = [
+        Bool(true),
+        Int8(3),
+        Int16(4),
+        Int32(8),
+        Int64(20),
+        UInt8(42),
+        UInt16(300),
+        UInt32(420421),
+        UInt64(43294832),
+        Float32(0.5),
+        Float64(0.25),
+        Date(1992, 9, 20),
+        Time(23, 10, 33),
+        DateTime(1992, 9, 20, 23, 10, 33),
+        String("hello world"),
+        missing
+    ]
+    for i in 1:size(type_values, 1)
+        stmt = DBInterface.prepare(con, string("SELECT ?::", type_names[i], " a"))
+        result = DataFrame(DBInterface.execute(stmt, [type_values[i]]))
+        @test isequal(result.a, [type_values[i]])
+    end
+end
+
+@testset "DBInterface.prepare: named parameters not supported yet" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    DBInterface.execute(con, "CREATE TABLE test_table(i INTEGER, j DOUBLE)")
+    @test_throws DuckDB.QueryException DBInterface.prepare(con, "INSERT INTO test_table VALUES(:col1, :col2)")
+
+    DBInterface.close!(con)
+end
diff --git a/tools/juliapkg/test/test_replacement_scan.jl b/tools/juliapkg/test/test_replacement_scan.jl
new file mode 100644
index 000000000000..8e86cb540efe
--- /dev/null
+++ b/tools/juliapkg/test/test_replacement_scan.jl
@@ -0,0 +1,27 @@
+# test_replacement_scan.jl
+
+function RangeReplacementScan(info)
+    table_name = DuckDB.GetTableName(info)
+    number = tryparse(Int64, table_name)
+    if number === nothing
+        return
+    end
+    DuckDB.SetFunctionName(info, "range")
+    DuckDB.AddFunctionParameter(info, DuckDB.CreateValue(number))
+    return
+end
+
+@testset "Test replacement scans" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    # add a replacement scan that turns any number provided as a table name into range(X)
+    DuckDB.AddReplacementScan(con, RangeReplacementScan, nothing)
+
+    df = DataFrame(DBInterface.execute(con, "SELECT * FROM \"2\" tbl(a)"))
+    @test df.a == [0, 1]
+
+    # this still fails
+    @test_throws DuckDB.QueryException DBInterface.execute(con, "SELECT * FROM nonexistant")
+
+    DBInterface.close!(con)
+end
diff --git a/tools/juliapkg/test/test_sqlite.jl b/tools/juliapkg/test/test_sqlite.jl
new file mode 100644
index 000000000000..2f10c8d8ebbf
--- /dev/null
+++ b/tools/juliapkg/test/test_sqlite.jl
@@ -0,0 +1,319 @@
+# test_sqlite.jl
+# tests adopted from SQLite.jl
+
+using Tables
+
+function setup_clean_test_db(f::Function, args...)
+    tables = [
+        "album",
+        "artist",
+        "customer",
+        "employee",
+        "genre",
+        "invoice",
+        "invoiceline",
+        "mediatype",
+        "playlist",
+        "playlisttrack",
+        "track"
+    ]
+    con = DBInterface.connect(DuckDB.DB)
+    for table in tables
+        DBInterface.execute(con, "CREATE TABLE $table AS SELECT * FROM 'data/$table.parquet'")
+    end
+
+    try
+        f(con)
+    finally
+        close(con)
+    end
+end
+
+@testset "DB Connection" begin
+    con = DBInterface.connect(DuckDB.DB)
+    @test con isa DuckDB.DB
+    DBInterface.close!(con)
+end
+
+
+@testset "Issue #207: 32 bit integers" begin
+    setup_clean_test_db() do db
+        ds = DBInterface.execute(db, "SELECT 42::INT64 a FROM Track LIMIT 1") |> columntable
+        @test ds.a[1] isa Int64
+    end
+end
+
+@testset "Regular DuckDB Tests" begin
+    setup_clean_test_db() do db
+        @test_throws DuckDB.QueryException DBInterface.execute(db, "just some syntax error")
+        # syntax correct, table missing
+        @test_throws DuckDB.QueryException DBInterface.execute(
+            db,
+            "SELECT name FROM sqlite_nomaster WHERE type='table';"
+        )
+    end
+end
+
+@testset "close!(query)" begin
+    setup_clean_test_db() do db
+        qry = DBInterface.execute(db, "SELECT name FROM sqlite_master WHERE type='table';")
+        DBInterface.close!(qry)
+        return DBInterface.close!(qry) # test it doesn't throw on double-close
+    end
+end
+
+@testset "Query tables" begin
+    setup_clean_test_db() do db
+        ds = DBInterface.execute(db, "SELECT name FROM sqlite_master WHERE type='table';") |> columntable
+        @test length(ds) == 1
+        @test keys(ds) == (:name,)
+        @test length(ds.name) == 11
+    end
+end
+
+@testset "DBInterface.execute([f])" begin
+    setup_clean_test_db() do db
+
+        # pipe approach
+        results = DBInterface.execute(db, "SELECT * FROM Employee;") |> columntable
+        @test length(results) == 15
+        @test length(results[1]) == 8
+        # callable approach
+        @test isequal(DBInterface.execute(columntable, db, "SELECT * FROM Employee"), results)
+        employees_stmt = DBInterface.prepare(db, "SELECT * FROM Employee")
+        @test isequal(columntable(DBInterface.execute(employees_stmt)), results)
+        @test isequal(DBInterface.execute(columntable, employees_stmt), results)
+        @testset "throwing from f()" begin
+            f(::DuckDB.QueryResult) = error("I'm throwing!")
+            @test_throws ErrorException DBInterface.execute(f, employees_stmt)
+            @test_throws ErrorException DBInterface.execute(f, db, "SELECT * FROM Employee")
+        end
+        return DBInterface.close!(employees_stmt)
+    end
+end
+
+@testset "isempty(::Query)" begin
+    setup_clean_test_db() do db
+
+        @test !DBInterface.execute(isempty, db, "SELECT * FROM Employee")
+        @test DBInterface.execute(isempty, db, "SELECT * FROM Employee WHERE FirstName='Joanne'")
+    end
+end
+
+@testset "empty query has correct schema and return type" begin
+    setup_clean_test_db() do db
+        empty_scheme = DBInterface.execute(Tables.schema, db, "SELECT * FROM Employee WHERE FirstName='Joanne'")
+        all_scheme = DBInterface.execute(Tables.schema, db, "SELECT * FROM Employee WHERE FirstName='Joanne'")
+        @test empty_scheme.names == all_scheme.names
+        @test all(ea -> ea[1] <: ea[2], zip(empty_scheme.types, all_scheme.types))
+
+        empty_tbl = DBInterface.execute(columntable, db, "SELECT * FROM Employee WHERE FirstName='Joanne'")
+        all_tbl = DBInterface.execute(columntable, db, "SELECT * FROM Employee")
+        @test propertynames(empty_tbl) == propertynames(all_tbl)
+    end
+end
+
+@testset "Create table, run commit/rollback tests" begin
+    setup_clean_test_db() do db
+        DBInterface.execute(db, "create table temp as select * from album")
+        DBInterface.execute(db, "alter table temp add column colyear int")
+        DBInterface.execute(db, "update temp set colyear = 2014")
+        r = DBInterface.execute(db, "select * from temp limit 10") |> columntable
+        @test length(r) == 4 && length(r[1]) == 10
+        @test all(==(2014), r[4])
+
+        @test_throws DuckDB.QueryException DuckDB.rollback(db)
+        @test_throws DuckDB.QueryException DuckDB.commit(db)
+
+        DuckDB.transaction(db)
+        DBInterface.execute(db, "update temp set colyear = 2015")
+        DuckDB.rollback(db)
+        r = DBInterface.execute(db, "select * from temp limit 10") |> columntable
+        @test all(==(2014), r[4])
+
+        DuckDB.transaction(db)
+        DBInterface.execute(db, "update temp set colyear = 2015")
+        DuckDB.commit(db)
+        r = DBInterface.execute(db, "select * from temp limit 10") |> columntable
+        @test all(==(2015), r[4])
+    end
+end
+
+@testset "Dates" begin
+    setup_clean_test_db() do db
+        DBInterface.execute(db, "create table temp as select * from album")
+        DBInterface.execute(db, "alter table temp add column dates date")
+        stmt = DBInterface.prepare(db, "update temp set dates = ?")
+        DBInterface.execute(stmt, (Date(2014, 1, 1),))
+
+        r = DBInterface.execute(db, "select * from temp limit 10") |> columntable
+        @test length(r) == 4 && length(r[1]) == 10
+        @test isa(r[4][1], Date)
+        @test all(Bool[x == Date(2014, 1, 1) for x in r[4]])
+        return DBInterface.execute(db, "drop table temp")
+    end
+end
+
+@testset "Prepared Statements" begin
+    setup_clean_test_db() do db
+
+        DBInterface.execute(db, "CREATE TABLE temp AS SELECT * FROM Album")
+        r = DBInterface.execute(db, "SELECT * FROM temp LIMIT ?", [3]) |> columntable
+        @test length(r) == 3 && length(r[1]) == 3
+        r = DBInterface.execute(db, "SELECT * FROM temp WHERE Title ILIKE ?", ["%time%"]) |> columntable
+        @test r[1] == [76, 111, 187]
+        DBInterface.execute(db, "INSERT INTO temp VALUES (?1, ?3, ?2)", [0, 0, "Test Album"])
+        r = DBInterface.execute(db, "SELECT * FROM temp WHERE AlbumId = 0") |> columntable
+        @test r[1][1] == 0
+        @test r[2][1] == "Test Album"
+        @test r[3][1] == 0
+        DuckDB.drop!(db, "temp")
+
+        DBInterface.execute(db, "CREATE TABLE temp AS SELECT * FROM Album")
+        r = DBInterface.execute(db, "SELECT * FROM temp LIMIT ?", (a = 3,)) |> columntable
+        @test length(r) == 3 && length(r[1]) == 3
+        r = DBInterface.execute(db, "SELECT * FROM temp LIMIT ?", a = 3) |> columntable
+        @test length(r) == 3 && length(r[1]) == 3
+        r = DBInterface.execute(db, "SELECT * FROM temp WHERE Title ILIKE ?", (word = "%time%",)) |> columntable
+        @test r[1] == [76, 111, 187]
+        # FIXME: these are supposed to be named parameter tests, but we don't support that yet
+        DBInterface.execute(db, "INSERT INTO temp VALUES (?, ?, ?)", (lid = 0, title = "Test Album", rid = 1))
+        DBInterface.execute(db, "INSERT INTO temp VALUES (?, ?, ?)", lid = 400, title = "Test2 Album", rid = 3)
+        r = DBInterface.execute(db, "SELECT * FROM temp WHERE AlbumId IN (0, 400)") |> columntable
+        @test r[1] == [0, 400]
+        @test r[2] == ["Test Album", "Test2 Album"]
+        @test r[3] == [1, 3]
+        return DuckDB.drop!(db, "temp")
+    end
+end
+
+
+@testset "DuckDB to Julia type conversion" begin
+    binddb = DBInterface.connect(DuckDB.DB)
+    DBInterface.execute(
+        binddb,
+        "CREATE TABLE temp (n INTEGER, i1 INT, i2 integer,
+        					f1 REAL, f2 FLOAT, f3 NUMERIC,
+        					s1 TEXT, s2 CHAR(10), s3 VARCHAR(15), s4 NVARCHAR(5),
+        					d1 DATETIME, ts1 TIMESTAMP)"
+    )
+    DBInterface.execute(
+        binddb,
+        "INSERT INTO temp VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
+        [
+            missing,
+            Int64(6),
+            Int64(4),
+            6.4,
+            6.3,
+            Int64(7),
+            "some long text",
+            "short text",
+            "another text",
+            "short",
+            "2021-02-21",
+            "2021-02-12 12:01:32"
+        ]
+    )
+    rr = DBInterface.execute(rowtable, binddb, "SELECT * FROM temp")
+    @test length(rr) == 1
+    r = first(rr)
+    @test typeof.(Tuple(r)) ==
+          (Missing, Int32, Int32, Float32, Float32, Float64, String, String, String, String, DateTime, DateTime)
+end
+
+@testset "Issue #158: Missing DB File" begin
+    @test_throws DuckDB.ConnectionException DuckDB.DB("nonexistentdir/not_there.db")
+end
+
+@testset "Issue #180, Query" begin
+    param = "Hello!"
+    query = DBInterface.execute(DuckDB.DB(), "SELECT ?1 UNION ALL SELECT ?1", [param])
+    param = "x"
+    for row in query
+        @test row[1] == "Hello!"
+        GC.gc() # this must NOT garbage collect the "Hello!" bound value
+    end
+
+    db = DBInterface.connect(DuckDB.DB)
+    DBInterface.execute(db, "CREATE TABLE T (a TEXT, PRIMARY KEY (a))")
+
+    q = DBInterface.prepare(db, "INSERT INTO T VALUES(?)")
+    DBInterface.execute(q, ["a"])
+
+    @test_throws DuckDB.QueryException DBInterface.execute(q, [1, "a"])
+end
+
+@testset "show(DB)" begin
+    io = IOBuffer()
+    db = DuckDB.DB()
+
+    show(io, db)
+    @test String(take!(io)) == "DuckDB.DB(\":memory:\")"
+
+    DBInterface.close!(db)
+end
+
+@testset "DuckDB.execute()" begin
+    db = DBInterface.connect(DuckDB.DB)
+    DBInterface.execute(db, "CREATE TABLE T (x INT UNIQUE)")
+
+    q = DBInterface.prepare(db, "INSERT INTO T VALUES(?)")
+    DuckDB.execute(q, (1,))
+    r = DBInterface.execute(db, "SELECT * FROM T") |> columntable
+    @test r[1] == [1]
+
+    DuckDB.execute(q, [2])
+    r = DBInterface.execute(db, "SELECT * FROM T") |> columntable
+    @test r[1] == [1, 2]
+
+    q = DBInterface.prepare(db, "INSERT INTO T VALUES(?)")
+    DuckDB.execute(q, [3])
+    r = DBInterface.execute(columntable, db, "SELECT * FROM T")
+    @test r[1] == [1, 2, 3]
+
+    DuckDB.execute(q, [4])
+    r = DBInterface.execute(columntable, db, "SELECT * FROM T")
+    @test r[1] == [1, 2, 3, 4]
+
+    DuckDB.execute(db, "INSERT INTO T VALUES(?)", [5])
+    r = DBInterface.execute(columntable, db, "SELECT * FROM T")
+    @test r[1] == [1, 2, 3, 4, 5]
+
+    r = DBInterface.execute(db, strip("   SELECT * FROM T  ")) |> columntable
+    @test r[1] == [1, 2, 3, 4, 5]
+
+    r = DBInterface.execute(db, "SELECT * FROM T")
+    @test Tables.istable(r)
+    @test Tables.rowaccess(r)
+    @test Tables.rows(r) === r
+    @test Base.IteratorSize(typeof(r)) == Base.SizeUnknown()
+    row = first(r)
+end
+
+@testset "last_insert_rowid unsupported" begin
+    db = DBInterface.connect(DuckDB.DB)
+    @test_throws DuckDB.NotImplementedException DBInterface.lastrowid(db)
+    @test DuckDB.esc_id(["1", "2", "3"]) == "\"1\",\"2\",\"3\""
+end
+
+@testset "Escaping" begin
+    @test DuckDB.esc_id(["1", "2", "3"]) == "\"1\",\"2\",\"3\""
+end
+
+@testset "Issue #253: Ensure query column names are unique by default" begin
+    db = DuckDB.DB()
+    res = DBInterface.execute(db, "select 1 as x2, 2 as x2, 3 as x2, 4 as x2_2") |> columntable
+    @test res == (x2 = [1], x2_1 = [2], x2_2 = [3], x2_2_1 = [4])
+end
+
+@testset "drop!() table name escaping" begin
+    db = DuckDB.DB()
+    DBInterface.execute(db, "CREATE TABLE \"escape 10.0%\"(i INTEGER)")
+    # table exists
+    DBInterface.execute(db, "SELECT * FROM \"escape 10.0%\"")
+    # drop the table
+    DuckDB.drop!(db, "escape 10.0%")
+    # it should no longer exist
+    @test_throws DuckDB.QueryException DBInterface.execute(db, "SELECT * FROM \"escape 10.0%\"")
+end
diff --git a/tools/juliapkg/test/test_table_function.jl b/tools/juliapkg/test/test_table_function.jl
new file mode 100644
index 000000000000..7bca180ac48a
--- /dev/null
+++ b/tools/juliapkg/test/test_table_function.jl
@@ -0,0 +1,138 @@
+# test_table_function.jl
+
+struct MyBindStruct
+    count::Int64
+
+    function MyBindStruct(count::Int64)
+        return new(count)
+    end
+end
+
+function MyBindFunction(info::DuckDB.BindInfo)
+    DuckDB.AddResultColumn(info, "forty_two", Int64)
+
+    parameter = DuckDB.GetParameter(info, 0)
+    number = DuckDB.GetValue(parameter, Int64)
+    return MyBindStruct(number)
+end
+
+mutable struct MyInitStruct
+    pos::Int64
+
+    function MyInitStruct()
+        return new(0)
+    end
+end
+
+function MyInitFunction(info::DuckDB.InitInfo)
+    return MyInitStruct()
+end
+
+function MyMainFunction(info::DuckDB.FunctionInfo, output::DuckDB.DataChunk)
+    bind_info = DuckDB.GetBindInfo(info, MyBindStruct)
+    init_info = DuckDB.GetInitInfo(info, MyInitStruct)
+
+    result_array = DuckDB.GetArray(output, 1, Int64)
+    count = 0
+    for i in 1:(DuckDB.VECTOR_SIZE)
+        if init_info.pos >= bind_info.count
+            break
+        end
+        result_array[count + 1] = init_info.pos % 2 == 0 ? 42 : 84
+        count += 1
+        init_info.pos += 1
+    end
+
+    DuckDB.SetSize(output, count)
+    return
+end
+
+function MyMainFunctionNulls(info::DuckDB.FunctionInfo, output::DuckDB.DataChunk)
+    bind_info = DuckDB.GetBindInfo(info, MyBindStruct)
+    init_info = DuckDB.GetInitInfo(info, MyInitStruct)
+
+    result_array = DuckDB.GetArray(output, 1, Int64)
+    validity = DuckDB.GetValidity(output, 1)
+    count = 0
+    for i in 1:(DuckDB.VECTOR_SIZE)
+        if init_info.pos >= bind_info.count
+            break
+        end
+        if init_info.pos % 2 == 0
+            result_array[count + 1] = 42
+        else
+            DuckDB.SetInvalid(validity, count + 1)
+        end
+        count += 1
+        init_info.pos += 1
+    end
+
+    DuckDB.SetSize(output, count)
+    return
+end
+
+@testset "Test custom table functions" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    DuckDB.CreateTableFunction(con, "forty_two", [Int64], MyBindFunction, MyInitFunction, MyMainFunction)
+    GC.gc()
+
+    # 3 elements
+    results = DBInterface.execute(con, "SELECT * FROM forty_two(3)")
+    GC.gc()
+
+    df = DataFrame(results)
+    @test names(df) == ["forty_two"]
+    @test size(df, 1) == 3
+    @test df.forty_two == [42, 84, 42]
+
+    # > vsize elements
+    results = DBInterface.execute(con, "SELECT COUNT(*) cnt FROM forty_two(10000)")
+    GC.gc()
+
+    df = DataFrame(results)
+    @test df.cnt == [10000]
+
+    # 	@time begin
+    # 		results = DBInterface.execute(con, "SELECT SUM(forty_two) cnt FROM forty_two(10000000)")
+    # 	end
+    # 	df = DataFrame(results)
+    # 	println(df)
+
+    # return null values from a table function
+    DuckDB.CreateTableFunction(con, "forty_two_nulls", [Int64], MyBindFunction, MyInitFunction, MyMainFunctionNulls)
+    results = DBInterface.execute(con, "SELECT COUNT(*) total_cnt, COUNT(forty_two) cnt FROM forty_two_nulls(10000)")
+    df = DataFrame(results)
+    @test df.total_cnt == [10000]
+    @test df.cnt == [5000]
+
+    # 	@time begin
+    # 		results = DBInterface.execute(con, "SELECT SUM(forty_two) cnt FROM forty_two_nulls(10000000)")
+    # 	end
+    # 	df = DataFrame(results)
+    # 	println(df)
+end
+
+function MyBindErrorFunction(info::DuckDB.BindInfo)
+    throw("bind error")
+end
+
+function MyInitErrorFunction(info::DuckDB.InitInfo)
+    throw("init error")
+end
+
+function MyMainErrorFunction(info::DuckDB.FunctionInfo, output::DuckDB.DataChunk)
+    throw("runtime error")
+end
+
+@testset "Test table function errors" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    DuckDB.CreateTableFunction(con, "bind_error_function", [Int64], MyBindErrorFunction, MyInitFunction, MyMainFunction)
+    DuckDB.CreateTableFunction(con, "init_error_function", [Int64], MyBindFunction, MyInitErrorFunction, MyMainFunction)
+    DuckDB.CreateTableFunction(con, "main_error_function", [Int64], MyBindFunction, MyInitFunction, MyMainErrorFunction)
+
+    @test_throws DuckDB.QueryException DBInterface.execute(con, "SELECT * FROM bind_error_function(3)")
+    @test_throws DuckDB.QueryException DBInterface.execute(con, "SELECT * FROM init_error_function(3)")
+    @test_throws DuckDB.QueryException DBInterface.execute(con, "SELECT * FROM main_error_function(3)")
+end
diff --git a/tools/juliapkg/test/test_transaction.jl b/tools/juliapkg/test/test_transaction.jl
new file mode 100644
index 000000000000..562bfa586cb4
--- /dev/null
+++ b/tools/juliapkg/test/test_transaction.jl
@@ -0,0 +1,23 @@
+# test_transaction.jl
+
+@testset "Test DBInterface.transaction" begin
+    con = DBInterface.connect(DuckDB.DB, ":memory:")
+
+    # throw an exception in DBInterface.transaction
+    # this should cause a rollback to happen
+    @test_throws DuckDB.QueryException DBInterface.transaction(con) do
+        DBInterface.execute(con, "CREATE TABLE integers(i INTEGER)")
+        return DBInterface.execute(con, "SELEC")
+    end
+
+    # verify that the table does not exist
+    @test_throws DuckDB.QueryException DBInterface.execute(con, "SELECT * FROM integers")
+
+    # no exception, this should work and be committed
+    DBInterface.transaction(con) do
+        return DBInterface.execute(con, "CREATE TABLE integers(i INTEGER)")
+    end
+    DBInterface.execute(con, "SELECT * FROM integers")
+
+    DBInterface.close!(con)
+end
