diff --git a/.github/workflows/Julia.yml b/.github/workflows/Julia.yml
new file mode 100644
index 000000000000..70b0a178b584
--- /dev/null
+++ b/.github/workflows/Julia.yml
@@ -0,0 +1,77 @@
+name: Julia
+on:
+   push:
+     paths-ignore:
+       - '**.md'
+   pull_request:
+     paths-ignore:
+       - '**.md'
+       - 'examples/**'
+       - 'test/**'
+       - 'tools/nodejs/**'
+       - 'tools/pythonpkg/**'
+       - 'tools/rpkg/**'
+       - '.github/workflows/**'
+       - '!.github/workflows/Julia.yml'
+concurrency:
+  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}
+  cancel-in-progress: true
+
+defaults:
+  run:
+    shell: bash
+
+jobs:
+  format_check:
+    name: Julia Format Check
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v2
+        with:
+          fetch-depth: 0
+
+      - uses: julia-actions/setup-julia@v1
+        with:
+          version: 1.7
+          arch: x64
+
+      - name: Format Check
+        run: |
+            cd tools/juliapkg
+            julia -e "import Pkg; Pkg.add(\"JuliaFormatter\")"
+            ./format_check.sh 
+
+  main_julia:
+    name: Julia ${{ matrix.version }}
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        version:
+          - '1.6'
+          - '1.7'
+          - 'nightly'
+        os:
+          - ubuntu-latest
+        arch:
+          - x64
+    steps:
+      - uses: actions/checkout@v2
+        with:
+          fetch-depth: 0
+
+      - uses: julia-actions/setup-julia@v1
+        with:
+          version: ${{ matrix.version }}
+          arch: ${{ matrix.arch }}
+
+      - name: Build DuckDB
+        run: |
+            make
+
+      - name: Run Tests
+        run: |
+          export JULIA_DUCKDB_LIBRARY="`pwd`/build/release/src/libduckdb.so"
+          ls $JULIA_DUCKDB_LIBRARY
+          cd tools/juliapkg
+          julia -e "import Pkg; Pkg.activate(\".\"); Pkg.instantiate(); include(\"test/runtests.jl\")"
\ No newline at end of file
diff --git a/.github/workflows/LinuxRelease.yml b/.github/workflows/LinuxRelease.yml
index 8f3f082734fc..5f9c3720e7a5 100644
--- a/.github/workflows/LinuxRelease.yml
+++ b/.github/workflows/LinuxRelease.yml
@@ -7,11 +7,11 @@ on:
     paths-ignore:
       - '**.md'
       - 'tools/nodejs/**'
+      - 'tools/juliapkg/**'
       - 'tools/pythonpkg/**'
       - 'tools/rpkg/**'
-      - '.github/workflows/NodeJS.yml'
-      - '.github/workflows/Python.yml'
-      - '.github/workflows/R.yml'
+      - '.github/workflows/**'
+      - '!.github/workflows/LinuxRelease.yml'
 
 concurrency:
   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}
diff --git a/.github/workflows/Main.yml b/.github/workflows/Main.yml
index 32f0fd6ce5d2..2d9d93939d2a 100644
--- a/.github/workflows/Main.yml
+++ b/.github/workflows/Main.yml
@@ -7,11 +7,11 @@ on:
     paths-ignore:
       - '**.md'
       - 'tools/nodejs/**'
+      - 'tools/juliapkg/**'
       - 'tools/pythonpkg/**'
       - 'tools/rpkg/**'
-      - '.github/workflows/NodeJS.yml'
-      - '.github/workflows/Python.yml'
-      - '.github/workflows/R.yml'
+      - '.github/workflows/**'
+      - '!.github/workflows/Main.yml'
 
 concurrency:
   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}
diff --git a/.github/workflows/NodeJS.yml b/.github/workflows/NodeJS.yml
index 11a33790889f..940b52de6d14 100644
--- a/.github/workflows/NodeJS.yml
+++ b/.github/workflows/NodeJS.yml
@@ -6,10 +6,14 @@ on:
   pull_request:
     paths-ignore:
       - '**.md'
+      - 'data/**'
+      - 'examples/**'
+      - 'test/**'
+      - 'tools/juliapkg/**'
       - 'tools/pythonpkg/**'
       - 'tools/rpkg/**'
-      - '.github/workflows/Python.yml'
-      - '.github/workflows/R.yml'
+      - '.github/workflows/**'
+      - '!.github/workflows/NodeJS.yml'
 
 concurrency:
   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}
diff --git a/.github/workflows/Python.yml b/.github/workflows/Python.yml
index adc6972e729a..7bb4e80a6759 100644
--- a/.github/workflows/Python.yml
+++ b/.github/workflows/Python.yml
@@ -6,10 +6,13 @@ on:
   pull_request:
     paths-ignore:
       - '**.md'
+      - 'examples/**'
+      - 'test/**'
+      - 'tools/juliapkg/**'
       - 'tools/nodejs/**'
       - 'tools/rpkg/**'
-      - '.github/workflows/NodeJS.yml'
-      - '.github/workflows/R.yml'
+      - '.github/workflows/**'
+      - '!.github/workflows/Python.yml'
 
 concurrency:
   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}
diff --git a/.github/workflows/R.yml b/.github/workflows/R.yml
index b9e5bd82e674..8c26a20e53c6 100644
--- a/.github/workflows/R.yml
+++ b/.github/workflows/R.yml
@@ -6,10 +6,13 @@ on:
   pull_request:
     paths-ignore:
       - '**.md'
+      - 'examples/**'
+      - 'test/**'
+      - 'tools/juliapkg/**'
       - 'tools/nodejs/**'
       - 'tools/pythonpkg/**'
-      - '.github/workflows/NodeJS.yml'
-      - '.github/workflows/Python.yml'
+      - '.github/workflows/**'
+      - '!.github/workflows/R.yml'
 
 concurrency:
   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}
diff --git a/.github/workflows/Regression.yml b/.github/workflows/Regression.yml
index 686b62d11433..2b2a04fb3f12 100644
--- a/.github/workflows/Regression.yml
+++ b/.github/workflows/Regression.yml
@@ -6,11 +6,11 @@ on:
   pull_request:
     paths-ignore:
       - '**.md'
+      - 'tools/juliapkg/**'
       - 'tools/nodejs/**'
       - 'tools/rpkg/**'
-      - '.github/workflows/NodeJS.yml'
-      - '.github/workflows/Python.yml'
-      - '.github/workflows/R.yml'
+      - '.github/workflows/**'
+      - '!.github/workflows/Regression.yml'
 
 concurrency:
   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}
diff --git a/.github/workflows/Windows.yml b/.github/workflows/Windows.yml
index cd23f1c09406..c26cfdc767ab 100644
--- a/.github/workflows/Windows.yml
+++ b/.github/workflows/Windows.yml
@@ -6,12 +6,12 @@ on:
   pull_request:
     paths-ignore:
       - '**.md'
+      - 'tools/juliapkg/**'
       - 'tools/nodejs/**'
       - 'tools/pythonpkg/**'
       - 'tools/rpkg/**'
-      - '.github/workflows/NodeJS.yml'
-      - '.github/workflows/Python.yml'
-      - '.github/workflows/R.yml'
+      - '.github/workflows/**'
+      - '!.github/workflows/Windows.yml'
 
 concurrency:
   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}
diff --git a/examples/standalone-plan/main.cpp b/examples/standalone-plan/main.cpp
index 0f4adcff2f52..ef09c2d0bece 100644
--- a/examples/standalone-plan/main.cpp
+++ b/examples/standalone-plan/main.cpp
@@ -98,7 +98,8 @@ void RunExampleDuckDBCatalog() {
 //===--------------------------------------------------------------------===//
 void CreateMyScanFunction(Connection &con);
 
-unique_ptr<TableFunctionRef> MyReplacementScan(const string &table_name, void *data) {
+unique_ptr<TableFunctionRef> MyReplacementScan(ClientContext &context, const string &table_name,
+                                               ReplacementScanData *data) {
 	auto table_function = make_unique<TableFunctionRef>();
 	vector<unique_ptr<ParsedExpression>> children;
 	children.push_back(make_unique<ConstantExpression>(Value(table_name)));
@@ -200,11 +201,9 @@ struct MyBindData : public FunctionData {
 // myothertable
 // k: 1, 10, 20
 // (see MyScanNode)
-static unique_ptr<FunctionData> MyScanBind(ClientContext &context, vector<Value> &inputs,
-                                           named_parameter_map_t &named_parameters,
-                                           vector<LogicalType> &input_table_types, vector<string> &input_table_names,
+static unique_ptr<FunctionData> MyScanBind(ClientContext &context, TableFunctionBindInput &input,
                                            vector<LogicalType> &return_types, vector<string> &names) {
-	auto table_name = inputs[0].ToString();
+	auto table_name = input.inputs[0].ToString();
 	if (table_name == "mytable") {
 		names.emplace_back("i");
 		return_types.emplace_back(LogicalType::INTEGER);
diff --git a/extension/icu/icu-extension.cpp b/extension/icu/icu-extension.cpp
index 611486b500a6..71f14bdd766c 100644
--- a/extension/icu/icu-extension.cpp
+++ b/extension/icu/icu-extension.cpp
@@ -149,11 +149,8 @@ struct ICUTimeZoneData : public FunctionOperatorData {
 	UDate now;
 };
 
-static unique_ptr<FunctionData> ICUTimeZoneBind(ClientContext &context, vector<Value> &inputs,
-                                                named_parameter_map_t &named_parameters,
-                                                vector<LogicalType> &input_table_types,
-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                vector<string> &names) {
+static unique_ptr<FunctionData> ICUTimeZoneBind(ClientContext &context, TableFunctionBindInput &input,
+                                                vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("name");
 	return_types.emplace_back(LogicalType::VARCHAR);
 	names.emplace_back("abbrev");
@@ -235,11 +232,8 @@ struct ICUCalendarData : public FunctionOperatorData {
 	std::unique_ptr<icu::StringEnumeration> calendars;
 };
 
-static unique_ptr<FunctionData> ICUCalendarBind(ClientContext &context, vector<Value> &inputs,
-                                                named_parameter_map_t &named_parameters,
-                                                vector<LogicalType> &input_table_types,
-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                vector<string> &names) {
+static unique_ptr<FunctionData> ICUCalendarBind(ClientContext &context, TableFunctionBindInput &input,
+                                                vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("name");
 	return_types.emplace_back(LogicalType::VARCHAR);
 
diff --git a/extension/parquet/parquet-extension.cpp b/extension/parquet/parquet-extension.cpp
index c39376fe13b7..fc1b6890894a 100644
--- a/extension/parquet/parquet-extension.cpp
+++ b/extension/parquet/parquet-extension.cpp
@@ -199,18 +199,15 @@ class ParquetScanFunction {
 		return files;
 	}
 
-	static unique_ptr<FunctionData> ParquetScanBind(ClientContext &context, vector<Value> &inputs,
-	                                                named_parameter_map_t &named_parameters,
-	                                                vector<LogicalType> &input_table_types,
-	                                                vector<string> &input_table_names,
+	static unique_ptr<FunctionData> ParquetScanBind(ClientContext &context, TableFunctionBindInput &input,
 	                                                vector<LogicalType> &return_types, vector<string> &names) {
 		auto &config = DBConfig::GetConfig(context);
 		if (!config.enable_external_access) {
 			throw PermissionException("Scanning Parquet files is disabled through configuration");
 		}
-		auto file_name = inputs[0].GetValue<string>();
+		auto file_name = input.inputs[0].GetValue<string>();
 		ParquetOptions parquet_options(context);
-		for (auto &kv : named_parameters) {
+		for (auto &kv : input.named_parameters) {
 			if (kv.first == "binary_as_string") {
 				parquet_options.binary_as_string = BooleanValue::Get(kv.second);
 			}
@@ -220,10 +217,7 @@ class ParquetScanFunction {
 		return ParquetScanBindInternal(context, move(files), return_types, names, parquet_options);
 	}
 
-	static unique_ptr<FunctionData> ParquetScanBindList(ClientContext &context, vector<Value> &inputs,
-	                                                    named_parameter_map_t &named_parameters,
-	                                                    vector<LogicalType> &input_table_types,
-	                                                    vector<string> &input_table_names,
+	static unique_ptr<FunctionData> ParquetScanBindList(ClientContext &context, TableFunctionBindInput &input,
 	                                                    vector<LogicalType> &return_types, vector<string> &names) {
 		auto &config = DBConfig::GetConfig(context);
 		if (!config.enable_external_access) {
@@ -231,7 +225,7 @@ class ParquetScanFunction {
 		}
 		FileSystem &fs = FileSystem::GetFileSystem(context);
 		vector<string> files;
-		for (auto &val : ListValue::GetChildren(inputs[0])) {
+		for (auto &val : ListValue::GetChildren(input.inputs[0])) {
 			auto glob_files = ParquetGlob(fs, val.ToString(), context);
 			files.insert(files.end(), glob_files.begin(), glob_files.end());
 		}
@@ -239,7 +233,7 @@ class ParquetScanFunction {
 			throw IOException("Parquet reader needs at least one file to read");
 		}
 		ParquetOptions parquet_options(context);
-		for (auto &kv : named_parameters) {
+		for (auto &kv : input.named_parameters) {
 			if (kv.first == "binary_as_string") {
 				parquet_options.binary_as_string = BooleanValue::Get(kv.second);
 			}
@@ -496,7 +490,8 @@ unique_ptr<LocalFunctionData> ParquetWriteInitializeLocal(ClientContext &context
 	return make_unique<ParquetWriteLocalState>();
 }
 
-unique_ptr<TableFunctionRef> ParquetScanReplacement(const string &table_name, void *data) {
+unique_ptr<TableFunctionRef> ParquetScanReplacement(ClientContext &context, const string &table_name,
+                                                    ReplacementScanData *data) {
 	if (!StringUtil::EndsWith(StringUtil::Lower(table_name), ".parquet")) {
 		return nullptr;
 	}
diff --git a/extension/parquet/parquet_metadata.cpp b/extension/parquet/parquet_metadata.cpp
index 50cf527d8082..813b83a7b614 100644
--- a/extension/parquet/parquet_metadata.cpp
+++ b/extension/parquet/parquet_metadata.cpp
@@ -384,9 +384,7 @@ void ParquetMetaDataOperatorData::LoadSchemaData(ClientContext &context, const v
 }
 
 template <bool SCHEMA>
-unique_ptr<FunctionData> ParquetMetaDataBind(ClientContext &context, vector<Value> &inputs,
-                                             named_parameter_map_t &named_parameters,
-                                             vector<LogicalType> &input_table_types, vector<string> &input_table_names,
+unique_ptr<FunctionData> ParquetMetaDataBind(ClientContext &context, TableFunctionBindInput &input,
                                              vector<LogicalType> &return_types, vector<string> &names) {
 	auto &config = DBConfig::GetConfig(context);
 	if (!config.enable_external_access) {
@@ -398,7 +396,7 @@ unique_ptr<FunctionData> ParquetMetaDataBind(ClientContext &context, vector<Valu
 		ParquetMetaDataOperatorData::BindMetaData(return_types, names);
 	}
 
-	auto file_name = inputs[0].GetValue<string>();
+	auto file_name = input.inputs[0].GetValue<string>();
 	auto result = make_unique<ParquetMetaDataBindData>();
 
 	FileSystem &fs = FileSystem::GetFileSystem(context);
diff --git a/extension/substrait/substrait-extension.cpp b/extension/substrait/substrait-extension.cpp
index 64f726671f19..ad82b6c1601b 100644
--- a/extension/substrait/substrait-extension.cpp
+++ b/extension/substrait/substrait-extension.cpp
@@ -21,13 +21,10 @@ struct ToSubstraitFunctionData : public TableFunctionData {
 	bool finished = false;
 };
 
-static unique_ptr<FunctionData> ToSubstraitBind(ClientContext &context, vector<Value> &inputs,
-                                                named_parameter_map_t &named_parameters,
-                                                vector<LogicalType> &input_table_types,
-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                vector<string> &names) {
+static unique_ptr<FunctionData> ToSubstraitBind(ClientContext &context, TableFunctionBindInput &input,
+                                                vector<LogicalType> &return_types, vector<string> &names) {
 	auto result = make_unique<ToSubstraitFunctionData>();
-	result->query = inputs[0].ToString();
+	result->query = input.inputs[0].ToString();
 	return_types.emplace_back(LogicalType::BLOB);
 	names.emplace_back("Plan Blob");
 	return move(result);
@@ -73,14 +70,11 @@ struct FromSubstraitFunctionData : public TableFunctionData {
 	unique_ptr<Connection> conn;
 };
 
-static unique_ptr<FunctionData> FromSubstraitBind(ClientContext &context, vector<Value> &inputs,
-                                                  named_parameter_map_t &named_parameters,
-                                                  vector<LogicalType> &input_table_types,
-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                  vector<string> &names) {
+static unique_ptr<FunctionData> FromSubstraitBind(ClientContext &context, TableFunctionBindInput &input,
+                                                  vector<LogicalType> &return_types, vector<string> &names) {
 	auto result = make_unique<FromSubstraitFunctionData>();
 	result->conn = make_unique<Connection>(*context.db);
-	string serialized = inputs[0].GetValueUnsafe<string>();
+	string serialized = input.inputs[0].GetValueUnsafe<string>();
 	result->plan = SubstraitPlanToDuckDBRel(*result->conn, serialized);
 	for (auto &column : result->plan->Columns()) {
 		return_types.emplace_back(column.type);
diff --git a/extension/tpcds/tpcds-extension.cpp b/extension/tpcds/tpcds-extension.cpp
index 72e711291685..198d57bc5aa7 100644
--- a/extension/tpcds/tpcds-extension.cpp
+++ b/extension/tpcds/tpcds-extension.cpp
@@ -27,12 +27,10 @@ struct DSDGenFunctionData : public TableFunctionData {
 	bool keys = false;
 };
 
-static unique_ptr<FunctionData> DsdgenBind(ClientContext &context, vector<Value> &inputs,
-                                           named_parameter_map_t &named_parameters,
-                                           vector<LogicalType> &input_table_types, vector<string> &input_table_names,
+static unique_ptr<FunctionData> DsdgenBind(ClientContext &context, TableFunctionBindInput &input,
                                            vector<LogicalType> &return_types, vector<string> &names) {
 	auto result = make_unique<DSDGenFunctionData>();
-	for (auto &kv : named_parameters) {
+	for (auto &kv : input.named_parameters) {
 		if (kv.first == "sf") {
 			result->sf = kv.second.GetValue<double>();
 		} else if (kv.first == "schema") {
@@ -74,11 +72,8 @@ unique_ptr<FunctionOperatorData> TPCDSInit(ClientContext &context, const Functio
 	return move(result);
 }
 
-static unique_ptr<FunctionData> TPCDSQueryBind(ClientContext &context, vector<Value> &inputs,
-                                               named_parameter_map_t &named_parameters,
-                                               vector<LogicalType> &input_table_types,
-                                               vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                               vector<string> &names) {
+static unique_ptr<FunctionData> TPCDSQueryBind(ClientContext &context, TableFunctionBindInput &input,
+                                               vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("query_nr");
 	return_types.emplace_back(LogicalType::INTEGER);
 
@@ -109,10 +104,7 @@ static void TPCDSQueryFunction(ClientContext &context, const FunctionData *bind_
 	output.SetCardinality(chunk_count);
 }
 
-static unique_ptr<FunctionData> TPCDSQueryAnswerBind(ClientContext &context, vector<Value> &inputs,
-                                                     named_parameter_map_t &named_parameters,
-                                                     vector<LogicalType> &input_table_types,
-                                                     vector<string> &input_table_names,
+static unique_ptr<FunctionData> TPCDSQueryAnswerBind(ClientContext &context, TableFunctionBindInput &input,
                                                      vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("query_nr");
 	return_types.emplace_back(LogicalType::INTEGER);
diff --git a/extension/tpch/tpch-extension.cpp b/extension/tpch/tpch-extension.cpp
index 9dadde939e46..15bdec4314ba 100644
--- a/extension/tpch/tpch-extension.cpp
+++ b/extension/tpch/tpch-extension.cpp
@@ -27,12 +27,10 @@ struct DBGenFunctionData : public TableFunctionData {
 	bool overwrite = false;
 };
 
-static unique_ptr<FunctionData> DbgenBind(ClientContext &context, vector<Value> &inputs,
-                                          named_parameter_map_t &named_parameters,
-                                          vector<LogicalType> &input_table_types, vector<string> &input_table_names,
+static unique_ptr<FunctionData> DbgenBind(ClientContext &context, TableFunctionBindInput &input,
                                           vector<LogicalType> &return_types, vector<string> &names) {
 	auto result = make_unique<DBGenFunctionData>();
-	for (auto &kv : named_parameters) {
+	for (auto &kv : input.named_parameters) {
 		if (kv.first == "sf") {
 			result->sf = DoubleValue::Get(kv.second);
 		} else if (kv.first == "schema") {
@@ -72,9 +70,7 @@ unique_ptr<FunctionOperatorData> TPCHInit(ClientContext &context, const Function
 	return move(result);
 }
 
-static unique_ptr<FunctionData> TPCHQueryBind(ClientContext &context, vector<Value> &inputs,
-                                              named_parameter_map_t &named_parameters,
-                                              vector<LogicalType> &input_table_types, vector<string> &input_table_names,
+static unique_ptr<FunctionData> TPCHQueryBind(ClientContext &context, TableFunctionBindInput &input,
                                               vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("query_nr");
 	return_types.emplace_back(LogicalType::INTEGER);
@@ -106,10 +102,7 @@ static void TPCHQueryFunction(ClientContext &context, const FunctionData *bind_d
 	output.SetCardinality(chunk_count);
 }
 
-static unique_ptr<FunctionData> TPCHQueryAnswerBind(ClientContext &context, vector<Value> &inputs,
-                                                    named_parameter_map_t &named_parameters,
-                                                    vector<LogicalType> &input_table_types,
-                                                    vector<string> &input_table_names,
+static unique_ptr<FunctionData> TPCHQueryAnswerBind(ClientContext &context, TableFunctionBindInput &input,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("query_nr");
 	return_types.emplace_back(LogicalType::INTEGER);
diff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp
index 58fcc24aab0d..b3b0b241400e 100644
--- a/src/common/types/vector.cpp
+++ b/src/common/types/vector.cpp
@@ -913,6 +913,10 @@ void Vector::Deserialize(idx_t count, Deserializer &source) {
 
 void Vector::SetVectorType(VectorType vector_type_p) {
 	this->vector_type = vector_type_p;
+	if (TypeIsConstantSize(GetType().InternalType()) &&
+	    (GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR)) {
+		auxiliary.reset();
+	}
 	if (vector_type == VectorType::CONSTANT_VECTOR && GetType().InternalType() == PhysicalType::STRUCT) {
 		auto &entries = StructVector::GetEntries(*this);
 		for (auto &entry : entries) {
diff --git a/src/execution/operator/join/perfect_hash_join_executor.cpp b/src/execution/operator/join/perfect_hash_join_executor.cpp
index 154c99934782..f1219e147b93 100644
--- a/src/execution/operator/join/perfect_hash_join_executor.cpp
+++ b/src/execution/operator/join/perfect_hash_join_executor.cpp
@@ -153,6 +153,7 @@ OperatorResultType PerfectHashJoinExecutor::ProbePerfectHashTable(ExecutionConte
 	idx_t probe_sel_count = 0;
 
 	// fetch the join keys from the chunk
+	state.join_keys.Reset();
 	state.probe_executor.Execute(input, state.join_keys);
 	// select the keys that are in the min-max range
 	auto &keys_vec = state.join_keys.data[0];
diff --git a/src/execution/operator/join/physical_nested_loop_join.cpp b/src/execution/operator/join/physical_nested_loop_join.cpp
index 51e4bdff3ad0..f5d7d54e38eb 100644
--- a/src/execution/operator/join/physical_nested_loop_join.cpp
+++ b/src/execution/operator/join/physical_nested_loop_join.cpp
@@ -340,6 +340,7 @@ OperatorResultType PhysicalNestedLoopJoin::ResolveComplexJoin(ExecutionContext &
 		}
 		if (state.fetch_next_left) {
 			// resolve the left join condition for the current chunk
+			state.left_condition.Reset();
 			state.lhs_executor.Execute(input, state.left_condition);
 
 			state.left_tuple = 0;
diff --git a/src/function/table/arrow.cpp b/src/function/table/arrow.cpp
index 6d12ea929e82..7c6530aaca36 100644
--- a/src/function/table/arrow.cpp
+++ b/src/function/table/arrow.cpp
@@ -161,18 +161,15 @@ LogicalType GetArrowLogicalType(ArrowSchema &schema,
 	}
 }
 
-unique_ptr<FunctionData> ArrowTableFunction::ArrowScanBind(ClientContext &context, vector<Value> &inputs,
-                                                           named_parameter_map_t &named_parameters,
-                                                           vector<LogicalType> &input_table_types,
-                                                           vector<string> &input_table_names,
+unique_ptr<FunctionData> ArrowTableFunction::ArrowScanBind(ClientContext &context, TableFunctionBindInput &input,
                                                            vector<LogicalType> &return_types, vector<string> &names) {
 	typedef unique_ptr<ArrowArrayStreamWrapper> (*stream_factory_produce_t)(
 	    uintptr_t stream_factory_ptr,
 	    std::pair<std::unordered_map<idx_t, string>, std::vector<string>> & project_columns,
 	    TableFilterCollection * filters);
-	auto stream_factory_ptr = inputs[0].GetPointer();
-	auto stream_factory_produce = (stream_factory_produce_t)inputs[1].GetPointer();
-	auto rows_per_thread = inputs[2].GetValue<uint64_t>();
+	auto stream_factory_ptr = input.inputs[0].GetPointer();
+	auto stream_factory_produce = (stream_factory_produce_t)input.inputs[1].GetPointer();
+	auto rows_per_thread = input.inputs[2].GetValue<uint64_t>();
 	std::pair<std::unordered_map<idx_t, string>, std::vector<string>> project_columns;
 #ifndef DUCKDB_NO_THREADS
 
diff --git a/src/function/table/checkpoint.cpp b/src/function/table/checkpoint.cpp
index a3a18964cf01..acdca79b8590 100644
--- a/src/function/table/checkpoint.cpp
+++ b/src/function/table/checkpoint.cpp
@@ -5,11 +5,8 @@
 
 namespace duckdb {
 
-static unique_ptr<FunctionData> CheckpointBind(ClientContext &context, vector<Value> &inputs,
-                                               named_parameter_map_t &named_parameters,
-                                               vector<LogicalType> &input_table_types,
-                                               vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                               vector<string> &names) {
+static unique_ptr<FunctionData> CheckpointBind(ClientContext &context, TableFunctionBindInput &input,
+                                               vector<LogicalType> &return_types, vector<string> &names) {
 	return_types.emplace_back(LogicalType::BOOLEAN);
 	names.emplace_back("Success");
 	return nullptr;
diff --git a/src/function/table/glob.cpp b/src/function/table/glob.cpp
index 5a4c1a9965e7..30236e3b1536 100644
--- a/src/function/table/glob.cpp
+++ b/src/function/table/glob.cpp
@@ -10,18 +10,15 @@ struct GlobFunctionBindData : public TableFunctionData {
 	vector<string> files;
 };
 
-static unique_ptr<FunctionData> GlobFunctionBind(ClientContext &context, vector<Value> &inputs,
-                                                 named_parameter_map_t &named_parameters,
-                                                 vector<LogicalType> &input_table_types,
-                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                 vector<string> &names) {
+static unique_ptr<FunctionData> GlobFunctionBind(ClientContext &context, TableFunctionBindInput &input,
+                                                 vector<LogicalType> &return_types, vector<string> &names) {
 	auto &config = DBConfig::GetConfig(context);
 	if (!config.enable_external_access) {
 		throw PermissionException("Globbing is disabled through configuration");
 	}
 	auto result = make_unique<GlobFunctionBindData>();
 	auto &fs = FileSystem::GetFileSystem(context);
-	result->files = fs.Glob(StringValue::Get(inputs[0]), context);
+	result->files = fs.Glob(StringValue::Get(input.inputs[0]), context);
 	return_types.emplace_back(LogicalType::VARCHAR);
 	names.emplace_back("file");
 	return move(result);
diff --git a/src/function/table/pragma_detailed_profiling_output.cpp b/src/function/table/pragma_detailed_profiling_output.cpp
index 87620c9e9dfd..98ddb8cf60f2 100644
--- a/src/function/table/pragma_detailed_profiling_output.cpp
+++ b/src/function/table/pragma_detailed_profiling_output.cpp
@@ -21,10 +21,7 @@ struct PragmaDetailedProfilingOutputData : public TableFunctionData {
 	vector<LogicalType> types;
 };
 
-static unique_ptr<FunctionData> PragmaDetailedProfilingOutputBind(ClientContext &context, vector<Value> &inputs,
-                                                                  named_parameter_map_t &named_parameters,
-                                                                  vector<LogicalType> &input_table_types,
-                                                                  vector<string> &input_table_names,
+static unique_ptr<FunctionData> PragmaDetailedProfilingOutputBind(ClientContext &context, TableFunctionBindInput &input,
                                                                   vector<LogicalType> &return_types,
                                                                   vector<string> &names) {
 	names.emplace_back("OPERATOR_ID");
diff --git a/src/function/table/pragma_last_profiling_output.cpp b/src/function/table/pragma_last_profiling_output.cpp
index 67d863371d3a..d7d3326194e8 100644
--- a/src/function/table/pragma_last_profiling_output.cpp
+++ b/src/function/table/pragma_last_profiling_output.cpp
@@ -22,10 +22,9 @@ struct PragmaLastProfilingOutputData : public TableFunctionData {
 	vector<LogicalType> types;
 };
 
-static unique_ptr<FunctionData>
-PragmaLastProfilingOutputBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,
-                              vector<LogicalType> &input_table_types, vector<string> &input_table_names,
-                              vector<LogicalType> &return_types, vector<string> &names) {
+static unique_ptr<FunctionData> PragmaLastProfilingOutputBind(ClientContext &context, TableFunctionBindInput &input,
+                                                              vector<LogicalType> &return_types,
+                                                              vector<string> &names) {
 	names.emplace_back("OPERATOR_ID");
 	return_types.emplace_back(LogicalType::INTEGER);
 
diff --git a/src/function/table/range.cpp b/src/function/table/range.cpp
index ad6f66ecf5ba..8c819935f1b9 100644
--- a/src/function/table/range.cpp
+++ b/src/function/table/range.cpp
@@ -17,11 +17,10 @@ struct RangeFunctionBindData : public TableFunctionData {
 };
 
 template <bool GENERATE_SERIES>
-static unique_ptr<FunctionData>
-RangeFunctionBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,
-                  vector<LogicalType> &input_table_types, vector<string> &input_table_names,
-                  vector<LogicalType> &return_types, vector<string> &names) {
+static unique_ptr<FunctionData> RangeFunctionBind(ClientContext &context, TableFunctionBindInput &input,
+                                                  vector<LogicalType> &return_types, vector<string> &names) {
 	auto result = make_unique<RangeFunctionBindData>();
+	auto &inputs = input.inputs;
 	if (inputs.size() < 2) {
 		// single argument: only the end is specified
 		result->start = 0;
@@ -128,11 +127,10 @@ struct RangeDateTimeBindData : public TableFunctionData {
 };
 
 template <bool GENERATE_SERIES>
-static unique_ptr<FunctionData>
-RangeDateTimeBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,
-                  vector<LogicalType> &input_table_types, vector<string> &input_table_names,
-                  vector<LogicalType> &return_types, vector<string> &names) {
+static unique_ptr<FunctionData> RangeDateTimeBind(ClientContext &context, TableFunctionBindInput &input,
+                                                  vector<LogicalType> &return_types, vector<string> &names) {
 	auto result = make_unique<RangeDateTimeBindData>();
+	auto &inputs = input.inputs;
 	D_ASSERT(inputs.size() == 3);
 	result->start = inputs[0].GetValue<timestamp_t>();
 	result->end = inputs[1].GetValue<timestamp_t>();
diff --git a/src/function/table/read_csv.cpp b/src/function/table/read_csv.cpp
index 0476d0852d54..6f067a9eddd7 100644
--- a/src/function/table/read_csv.cpp
+++ b/src/function/table/read_csv.cpp
@@ -14,9 +14,7 @@
 
 namespace duckdb {
 
-static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value> &inputs,
-                                            named_parameter_map_t &named_parameters,
-                                            vector<LogicalType> &input_table_types, vector<string> &input_table_names,
+static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, TableFunctionBindInput &input,
                                             vector<LogicalType> &return_types, vector<string> &names) {
 	auto &config = DBConfig::GetConfig(context);
 	if (!config.enable_external_access) {
@@ -25,7 +23,7 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value
 	auto result = make_unique<ReadCSVData>();
 	auto &options = result->options;
 
-	auto &file_pattern = StringValue::Get(inputs[0]);
+	auto &file_pattern = StringValue::Get(input.inputs[0]);
 
 	auto &fs = FileSystem::GetFileSystem(context);
 	result->files = fs.Glob(file_pattern, context);
@@ -33,7 +31,7 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value
 		throw IOException("No files found that match the pattern \"%s\"", file_pattern);
 	}
 
-	for (auto &kv : named_parameters) {
+	for (auto &kv : input.named_parameters) {
 		auto loption = StringUtil::Lower(kv.first);
 		if (loption == "auto_detect") {
 			options.auto_detect = BooleanValue::Get(kv.second);
@@ -180,13 +178,10 @@ static unique_ptr<FunctionOperatorData> ReadCSVInit(ClientContext &context, cons
 	return move(result);
 }
 
-static unique_ptr<FunctionData> ReadCSVAutoBind(ClientContext &context, vector<Value> &inputs,
-                                                named_parameter_map_t &named_parameters,
-                                                vector<LogicalType> &input_table_types,
-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                vector<string> &names) {
-	named_parameters["auto_detect"] = Value::BOOLEAN(true);
-	return ReadCSVBind(context, inputs, named_parameters, input_table_types, input_table_names, return_types, names);
+static unique_ptr<FunctionData> ReadCSVAutoBind(ClientContext &context, TableFunctionBindInput &input,
+                                                vector<LogicalType> &return_types, vector<string> &names) {
+	input.named_parameters["auto_detect"] = Value::BOOLEAN(true);
+	return ReadCSVBind(context, input, return_types, names);
 }
 
 static void ReadCSVFunction(ClientContext &context, const FunctionData *bind_data_p,
@@ -261,7 +256,8 @@ void ReadCSVTableFunction::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(read_csv_auto);
 }
 
-unique_ptr<TableFunctionRef> ReadCSVReplacement(const string &table_name, void *data) {
+unique_ptr<TableFunctionRef> ReadCSVReplacement(ClientContext &context, const string &table_name,
+                                                ReplacementScanData *data) {
 	auto lower_name = StringUtil::Lower(table_name);
 	// remove any compression
 	if (StringUtil::EndsWith(lower_name, ".gz")) {
diff --git a/src/function/table/repeat.cpp b/src/function/table/repeat.cpp
index 933e0deefb18..ef0ab75d924b 100644
--- a/src/function/table/repeat.cpp
+++ b/src/function/table/repeat.cpp
@@ -17,11 +17,10 @@ struct RepeatOperatorData : public FunctionOperatorData {
 	idx_t current_count;
 };
 
-static unique_ptr<FunctionData> RepeatBind(ClientContext &context, vector<Value> &inputs,
-                                           named_parameter_map_t &named_parameters,
-                                           vector<LogicalType> &input_table_types, vector<string> &input_table_names,
+static unique_ptr<FunctionData> RepeatBind(ClientContext &context, TableFunctionBindInput &input,
                                            vector<LogicalType> &return_types, vector<string> &names) {
 	// the repeat function returns the type of the first argument
+	auto &inputs = input.inputs;
 	return_types.push_back(inputs[0].type());
 	names.push_back(inputs[0].ToString());
 	return make_unique<RepeatFunctionData>(inputs[0], inputs[1].GetValue<int64_t>());
diff --git a/src/function/table/summary.cpp b/src/function/table/summary.cpp
index eb8bf1189753..ef9c36b70f35 100644
--- a/src/function/table/summary.cpp
+++ b/src/function/table/summary.cpp
@@ -7,18 +7,15 @@
 
 namespace duckdb {
 
-static unique_ptr<FunctionData> SummaryFunctionBind(ClientContext &context, vector<Value> &inputs,
-                                                    named_parameter_map_t &named_parameters,
-                                                    vector<LogicalType> &input_table_types,
-                                                    vector<string> &input_table_names,
+static unique_ptr<FunctionData> SummaryFunctionBind(ClientContext &context, TableFunctionBindInput &input,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
 
 	return_types.emplace_back(LogicalType::VARCHAR);
 	names.emplace_back("summary");
 
-	for (idx_t i = 0; i < input_table_types.size(); i++) {
-		return_types.push_back(input_table_types[i]);
-		names.emplace_back(input_table_names[i]);
+	for (idx_t i = 0; i < input.input_table_types.size(); i++) {
+		return_types.push_back(input.input_table_types[i]);
+		names.emplace_back(input.input_table_names[i]);
 	}
 
 	return make_unique<TableFunctionData>();
diff --git a/src/function/table/system/duckdb_columns.cpp b/src/function/table/system/duckdb_columns.cpp
index 295cf271c478..aa6c90f9905c 100644
--- a/src/function/table/system/duckdb_columns.cpp
+++ b/src/function/table/system/duckdb_columns.cpp
@@ -20,11 +20,8 @@ struct DuckDBColumnsData : public FunctionOperatorData {
 	idx_t column_offset;
 };
 
-static unique_ptr<FunctionData> DuckDBColumnsBind(ClientContext &context, vector<Value> &inputs,
-                                                  named_parameter_map_t &named_parameters,
-                                                  vector<LogicalType> &input_table_types,
-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                  vector<string> &names) {
+static unique_ptr<FunctionData> DuckDBColumnsBind(ClientContext &context, TableFunctionBindInput &input,
+                                                  vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("schema_oid");
 	return_types.emplace_back(LogicalType::BIGINT);
 
diff --git a/src/function/table/system/duckdb_constraints.cpp b/src/function/table/system/duckdb_constraints.cpp
index e3196e7e0512..b852e04ec8be 100644
--- a/src/function/table/system/duckdb_constraints.cpp
+++ b/src/function/table/system/duckdb_constraints.cpp
@@ -25,10 +25,7 @@ struct DuckDBConstraintsData : public FunctionOperatorData {
 	idx_t constraint_offset;
 };
 
-static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, vector<Value> &inputs,
-                                                      named_parameter_map_t &named_parameters,
-                                                      vector<LogicalType> &input_table_types,
-                                                      vector<string> &input_table_names,
+static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, TableFunctionBindInput &input,
                                                       vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("schema_name");
 	return_types.emplace_back(LogicalType::VARCHAR);
diff --git a/src/function/table/system/duckdb_dependencies.cpp b/src/function/table/system/duckdb_dependencies.cpp
index 281f52361619..eaf25bb51271 100644
--- a/src/function/table/system/duckdb_dependencies.cpp
+++ b/src/function/table/system/duckdb_dependencies.cpp
@@ -21,10 +21,7 @@ struct DuckDBDependenciesData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> DuckDBDependenciesBind(ClientContext &context, vector<Value> &inputs,
-                                                       named_parameter_map_t &named_parameters,
-                                                       vector<LogicalType> &input_table_types,
-                                                       vector<string> &input_table_names,
+static unique_ptr<FunctionData> DuckDBDependenciesBind(ClientContext &context, TableFunctionBindInput &input,
                                                        vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("classid");
 	return_types.emplace_back(LogicalType::BIGINT);
diff --git a/src/function/table/system/duckdb_functions.cpp b/src/function/table/system/duckdb_functions.cpp
index 8b9b38030f8b..d3c2d0c9ffd3 100644
--- a/src/function/table/system/duckdb_functions.cpp
+++ b/src/function/table/system/duckdb_functions.cpp
@@ -21,10 +21,7 @@ struct DuckDBFunctionsData : public FunctionOperatorData {
 	idx_t offset_in_entry;
 };
 
-static unique_ptr<FunctionData> DuckDBFunctionsBind(ClientContext &context, vector<Value> &inputs,
-                                                    named_parameter_map_t &named_parameters,
-                                                    vector<LogicalType> &input_table_types,
-                                                    vector<string> &input_table_names,
+static unique_ptr<FunctionData> DuckDBFunctionsBind(ClientContext &context, TableFunctionBindInput &input,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("schema_name");
 	return_types.emplace_back(LogicalType::VARCHAR);
diff --git a/src/function/table/system/duckdb_indexes.cpp b/src/function/table/system/duckdb_indexes.cpp
index 710dc8284db6..a545838dc03e 100644
--- a/src/function/table/system/duckdb_indexes.cpp
+++ b/src/function/table/system/duckdb_indexes.cpp
@@ -18,11 +18,8 @@ struct DuckDBIndexesData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> DuckDBIndexesBind(ClientContext &context, vector<Value> &inputs,
-                                                  named_parameter_map_t &named_parameters,
-                                                  vector<LogicalType> &input_table_types,
-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                  vector<string> &names) {
+static unique_ptr<FunctionData> DuckDBIndexesBind(ClientContext &context, TableFunctionBindInput &input,
+                                                  vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("schema_name");
 	return_types.emplace_back(LogicalType::VARCHAR);
 
diff --git a/src/function/table/system/duckdb_keywords.cpp b/src/function/table/system/duckdb_keywords.cpp
index bf60bcf6aff9..44c073cf07a7 100644
--- a/src/function/table/system/duckdb_keywords.cpp
+++ b/src/function/table/system/duckdb_keywords.cpp
@@ -14,11 +14,8 @@ struct DuckDBKeywordsData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> DuckDBKeywordsBind(ClientContext &context, vector<Value> &inputs,
-                                                   named_parameter_map_t &named_parameters,
-                                                   vector<LogicalType> &input_table_types,
-                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                   vector<string> &names) {
+static unique_ptr<FunctionData> DuckDBKeywordsBind(ClientContext &context, TableFunctionBindInput &input,
+                                                   vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("keyword_name");
 	return_types.emplace_back(LogicalType::VARCHAR);
 
diff --git a/src/function/table/system/duckdb_schemas.cpp b/src/function/table/system/duckdb_schemas.cpp
index 8ed9495d9dee..8405b6152d70 100644
--- a/src/function/table/system/duckdb_schemas.cpp
+++ b/src/function/table/system/duckdb_schemas.cpp
@@ -15,11 +15,8 @@ struct DuckDBSchemasData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> DuckDBSchemasBind(ClientContext &context, vector<Value> &inputs,
-                                                  named_parameter_map_t &named_parameters,
-                                                  vector<LogicalType> &input_table_types,
-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                  vector<string> &names) {
+static unique_ptr<FunctionData> DuckDBSchemasBind(ClientContext &context, TableFunctionBindInput &input,
+                                                  vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("oid");
 	return_types.emplace_back(LogicalType::BIGINT);
 
diff --git a/src/function/table/system/duckdb_sequences.cpp b/src/function/table/system/duckdb_sequences.cpp
index 46b9bd0cd387..42b3f3bdad04 100644
--- a/src/function/table/system/duckdb_sequences.cpp
+++ b/src/function/table/system/duckdb_sequences.cpp
@@ -16,10 +16,7 @@ struct DuckDBSequencesData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> DuckDBSequencesBind(ClientContext &context, vector<Value> &inputs,
-                                                    named_parameter_map_t &named_parameters,
-                                                    vector<LogicalType> &input_table_types,
-                                                    vector<string> &input_table_names,
+static unique_ptr<FunctionData> DuckDBSequencesBind(ClientContext &context, TableFunctionBindInput &input,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("schema_name");
 	return_types.emplace_back(LogicalType::VARCHAR);
diff --git a/src/function/table/system/duckdb_settings.cpp b/src/function/table/system/duckdb_settings.cpp
index 9793d393f148..4d663778f22d 100644
--- a/src/function/table/system/duckdb_settings.cpp
+++ b/src/function/table/system/duckdb_settings.cpp
@@ -20,11 +20,8 @@ struct DuckDBSettingsData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> DuckDBSettingsBind(ClientContext &context, vector<Value> &inputs,
-                                                   named_parameter_map_t &named_parameters,
-                                                   vector<LogicalType> &input_table_types,
-                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                   vector<string> &names) {
+static unique_ptr<FunctionData> DuckDBSettingsBind(ClientContext &context, TableFunctionBindInput &input,
+                                                   vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("name");
 	return_types.emplace_back(LogicalType::VARCHAR);
 
diff --git a/src/function/table/system/duckdb_tables.cpp b/src/function/table/system/duckdb_tables.cpp
index 7f96ac432f50..6bbb6ffc8dfe 100644
--- a/src/function/table/system/duckdb_tables.cpp
+++ b/src/function/table/system/duckdb_tables.cpp
@@ -19,11 +19,8 @@ struct DuckDBTablesData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> DuckDBTablesBind(ClientContext &context, vector<Value> &inputs,
-                                                 named_parameter_map_t &named_parameters,
-                                                 vector<LogicalType> &input_table_types,
-                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                 vector<string> &names) {
+static unique_ptr<FunctionData> DuckDBTablesBind(ClientContext &context, TableFunctionBindInput &input,
+                                                 vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("schema_name");
 	return_types.emplace_back(LogicalType::VARCHAR);
 
diff --git a/src/function/table/system/duckdb_types.cpp b/src/function/table/system/duckdb_types.cpp
index 8beb5ef94c0f..fed0ebbd60f2 100644
--- a/src/function/table/system/duckdb_types.cpp
+++ b/src/function/table/system/duckdb_types.cpp
@@ -16,11 +16,8 @@ struct DuckDBTypesData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> DuckDBTypesBind(ClientContext &context, vector<Value> &inputs,
-                                                named_parameter_map_t &named_parameters,
-                                                vector<LogicalType> &input_table_types,
-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                vector<string> &names) {
+static unique_ptr<FunctionData> DuckDBTypesBind(ClientContext &context, TableFunctionBindInput &input,
+                                                vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("schema_name");
 	return_types.emplace_back(LogicalType::VARCHAR);
 
diff --git a/src/function/table/system/duckdb_views.cpp b/src/function/table/system/duckdb_views.cpp
index 05ec83c76281..600f7eec4ec4 100644
--- a/src/function/table/system/duckdb_views.cpp
+++ b/src/function/table/system/duckdb_views.cpp
@@ -16,11 +16,8 @@ struct DuckDBViewsData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> DuckDBViewsBind(ClientContext &context, vector<Value> &inputs,
-                                                named_parameter_map_t &named_parameters,
-                                                vector<LogicalType> &input_table_types,
-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                vector<string> &names) {
+static unique_ptr<FunctionData> DuckDBViewsBind(ClientContext &context, TableFunctionBindInput &input,
+                                                vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("schema_name");
 	return_types.emplace_back(LogicalType::VARCHAR);
 
diff --git a/src/function/table/system/pragma_collations.cpp b/src/function/table/system/pragma_collations.cpp
index cdf19ef7cfb8..285759c3bd23 100644
--- a/src/function/table/system/pragma_collations.cpp
+++ b/src/function/table/system/pragma_collations.cpp
@@ -15,11 +15,8 @@ struct PragmaCollateData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> PragmaCollateBind(ClientContext &context, vector<Value> &inputs,
-                                                  named_parameter_map_t &named_parameters,
-                                                  vector<LogicalType> &input_table_types,
-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                  vector<string> &names) {
+static unique_ptr<FunctionData> PragmaCollateBind(ClientContext &context, TableFunctionBindInput &input,
+                                                  vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("collname");
 	return_types.emplace_back(LogicalType::VARCHAR);
 
diff --git a/src/function/table/system/pragma_database_list.cpp b/src/function/table/system/pragma_database_list.cpp
index d94cf039638d..fb5e1b2f05d7 100644
--- a/src/function/table/system/pragma_database_list.cpp
+++ b/src/function/table/system/pragma_database_list.cpp
@@ -11,10 +11,7 @@ struct PragmaDatabaseListData : public FunctionOperatorData {
 	bool finished;
 };
 
-static unique_ptr<FunctionData> PragmaDatabaseListBind(ClientContext &context, vector<Value> &inputs,
-                                                       named_parameter_map_t &named_parameters,
-                                                       vector<LogicalType> &input_table_types,
-                                                       vector<string> &input_table_names,
+static unique_ptr<FunctionData> PragmaDatabaseListBind(ClientContext &context, TableFunctionBindInput &input,
                                                        vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("seq");
 	return_types.emplace_back(LogicalType::INTEGER);
diff --git a/src/function/table/system/pragma_database_size.cpp b/src/function/table/system/pragma_database_size.cpp
index 2b314ca0490d..2fa8b0097b89 100644
--- a/src/function/table/system/pragma_database_size.cpp
+++ b/src/function/table/system/pragma_database_size.cpp
@@ -15,10 +15,7 @@ struct PragmaDatabaseSizeData : public FunctionOperatorData {
 	bool finished;
 };
 
-static unique_ptr<FunctionData> PragmaDatabaseSizeBind(ClientContext &context, vector<Value> &inputs,
-                                                       named_parameter_map_t &named_parameters,
-                                                       vector<LogicalType> &input_table_types,
-                                                       vector<string> &input_table_names,
+static unique_ptr<FunctionData> PragmaDatabaseSizeBind(ClientContext &context, TableFunctionBindInput &input,
                                                        vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("database_size");
 	return_types.emplace_back(LogicalType::VARCHAR);
diff --git a/src/function/table/system/pragma_functions.cpp b/src/function/table/system/pragma_functions.cpp
index 39f69d0eb632..8f01cbef90e5 100644
--- a/src/function/table/system/pragma_functions.cpp
+++ b/src/function/table/system/pragma_functions.cpp
@@ -18,10 +18,7 @@ struct PragmaFunctionsData : public FunctionOperatorData {
 	idx_t offset_in_entry;
 };
 
-static unique_ptr<FunctionData> PragmaFunctionsBind(ClientContext &context, vector<Value> &inputs,
-                                                    named_parameter_map_t &named_parameters,
-                                                    vector<LogicalType> &input_table_types,
-                                                    vector<string> &input_table_names,
+static unique_ptr<FunctionData> PragmaFunctionsBind(ClientContext &context, TableFunctionBindInput &input,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("name");
 	return_types.emplace_back(LogicalType::VARCHAR);
diff --git a/src/function/table/system/pragma_storage_info.cpp b/src/function/table/system/pragma_storage_info.cpp
index 563b3ef22448..deb8e126f316 100644
--- a/src/function/table/system/pragma_storage_info.cpp
+++ b/src/function/table/system/pragma_storage_info.cpp
@@ -30,10 +30,7 @@ struct PragmaStorageOperatorData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> PragmaStorageInfoBind(ClientContext &context, vector<Value> &inputs,
-                                                      named_parameter_map_t &named_parameters,
-                                                      vector<LogicalType> &input_table_types,
-                                                      vector<string> &input_table_names,
+static unique_ptr<FunctionData> PragmaStorageInfoBind(ClientContext &context, TableFunctionBindInput &input,
                                                       vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("row_group_id");
 	return_types.emplace_back(LogicalType::BIGINT);
@@ -77,7 +74,7 @@ static unique_ptr<FunctionData> PragmaStorageInfoBind(ClientContext &context, ve
 	names.emplace_back("block_offset");
 	return_types.emplace_back(LogicalType::BIGINT);
 
-	auto qname = QualifiedName::Parse(inputs[0].GetValue<string>());
+	auto qname = QualifiedName::Parse(input.inputs[0].GetValue<string>());
 
 	// look up the table name in the catalog
 	auto &catalog = Catalog::GetCatalog(context);
diff --git a/src/function/table/system/pragma_table_info.cpp b/src/function/table/system/pragma_table_info.cpp
index e022f02e5820..8cc24865361c 100644
--- a/src/function/table/system/pragma_table_info.cpp
+++ b/src/function/table/system/pragma_table_info.cpp
@@ -27,10 +27,7 @@ struct PragmaTableOperatorData : public FunctionOperatorData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> PragmaTableInfoBind(ClientContext &context, vector<Value> &inputs,
-                                                    named_parameter_map_t &named_parameters,
-                                                    vector<LogicalType> &input_table_types,
-                                                    vector<string> &input_table_names,
+static unique_ptr<FunctionData> PragmaTableInfoBind(ClientContext &context, TableFunctionBindInput &input,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("cid");
 	return_types.emplace_back(LogicalType::INTEGER);
@@ -50,7 +47,7 @@ static unique_ptr<FunctionData> PragmaTableInfoBind(ClientContext &context, vect
 	names.emplace_back("pk");
 	return_types.emplace_back(LogicalType::BOOLEAN);
 
-	auto qname = QualifiedName::Parse(inputs[0].GetValue<string>());
+	auto qname = QualifiedName::Parse(input.inputs[0].GetValue<string>());
 
 	// look up the table name in the catalog
 	auto &catalog = Catalog::GetCatalog(context);
diff --git a/src/function/table/unnest.cpp b/src/function/table/unnest.cpp
index 6786427462c5..7050fda731c4 100644
--- a/src/function/table/unnest.cpp
+++ b/src/function/table/unnest.cpp
@@ -17,10 +17,9 @@ struct UnnestOperatorData : public FunctionOperatorData {
 	idx_t current_count;
 };
 
-static unique_ptr<FunctionData> UnnestBind(ClientContext &context, vector<Value> &inputs,
-                                           named_parameter_map_t &named_parameters,
-                                           vector<LogicalType> &input_table_types, vector<string> &input_table_names,
+static unique_ptr<FunctionData> UnnestBind(ClientContext &context, TableFunctionBindInput &input,
                                            vector<LogicalType> &return_types, vector<string> &names) {
+	auto &inputs = input.inputs;
 	return_types.push_back(ListType::GetChildType(inputs[0].type()));
 	names.push_back(inputs[0].ToString());
 	return make_unique<UnnestFunctionData>(inputs[0]);
diff --git a/src/function/table/version/pragma_version.cpp b/src/function/table/version/pragma_version.cpp
index 9674327d2210..ee6365897bd0 100644
--- a/src/function/table/version/pragma_version.cpp
+++ b/src/function/table/version/pragma_version.cpp
@@ -9,11 +9,8 @@ struct PragmaVersionData : public FunctionOperatorData {
 	bool finished;
 };
 
-static unique_ptr<FunctionData> PragmaVersionBind(ClientContext &context, vector<Value> &inputs,
-                                                  named_parameter_map_t &named_parameters,
-                                                  vector<LogicalType> &input_table_types,
-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,
-                                                  vector<string> &names) {
+static unique_ptr<FunctionData> PragmaVersionBind(ClientContext &context, TableFunctionBindInput &input,
+                                                  vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("library_version");
 	return_types.emplace_back(LogicalType::VARCHAR);
 	names.emplace_back("source_id");
diff --git a/src/function/table_function.cpp b/src/function/table_function.cpp
index 6dec47c5d6e0..944b4df1696a 100644
--- a/src/function/table_function.cpp
+++ b/src/function/table_function.cpp
@@ -5,6 +5,9 @@ namespace duckdb {
 FunctionOperatorData::~FunctionOperatorData() {
 }
 
+TableFunctionInfo::~TableFunctionInfo() {
+}
+
 TableFilterCollection::TableFilterCollection(TableFilterSet *table_filters) : table_filters(table_filters) {
 }
 
diff --git a/src/include/duckdb.h b/src/include/duckdb.h
index 0bf2334c6c47..9f88539f9eb2 100644
--- a/src/include/duckdb.h
+++ b/src/include/duckdb.h
@@ -74,7 +74,7 @@ typedef enum DUCKDB_TYPE {
 	DUCKDB_TYPE_FLOAT,
 	// double
 	DUCKDB_TYPE_DOUBLE,
-	// duckdb_timestamp
+	// duckdb_timestamp, in microseconds
 	DUCKDB_TYPE_TIMESTAMP,
 	// duckdb_date
 	DUCKDB_TYPE_DATE,
@@ -89,7 +89,25 @@ typedef enum DUCKDB_TYPE {
 	// duckdb_blob
 	DUCKDB_TYPE_BLOB,
 	// decimal
-	DUCKDB_TYPE_DECIMAL
+	DUCKDB_TYPE_DECIMAL,
+	// duckdb_timestamp, in seconds
+	DUCKDB_TYPE_TIMESTAMP_S,
+	// duckdb_timestamp, in milliseconds
+	DUCKDB_TYPE_TIMESTAMP_MS,
+	// duckdb_timestamp, in nanoseconds
+	DUCKDB_TYPE_TIMESTAMP_NS,
+	// enum type, only useful as logical type
+	DUCKDB_TYPE_ENUM,
+	// list type, only useful as logical type
+	DUCKDB_TYPE_LIST,
+	// struct type, only useful as logical type
+	DUCKDB_TYPE_STRUCT,
+	// map type, only useful as logical type
+	DUCKDB_TYPE_MAP,
+	// duckdb_hugeint
+	DUCKDB_TYPE_UUID,
+	// const char*
+	DUCKDB_TYPE_JSON,
 } duckdb_type;
 
 //! Days are stored as days since 1970-01-01
@@ -203,6 +221,10 @@ typedef void *duckdb_arrow;
 typedef void *duckdb_config;
 typedef void *duckdb_arrow_schema;
 typedef void *duckdb_arrow_array;
+typedef void *duckdb_logical_type;
+typedef void *duckdb_data_chunk;
+typedef void *duckdb_vector;
+typedef void *duckdb_value;
 
 typedef enum { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;
 
@@ -366,6 +388,19 @@ Returns `DUCKDB_TYPE_INVALID` if the column is out of range.
 */
 DUCKDB_API duckdb_type duckdb_column_type(duckdb_result *result, idx_t col);
 
+/*!
+Returns the logical column type of the specified column.
+
+The return type of this call should be destroyed with `duckdb_destroy_logical_type`.
+
+Returns `NULL` if the column is out of range.
+
+* result: The result object to fetch the column type from.
+* col: The column index.
+* returns: The logical column type of the specified column.
+*/
+DUCKDB_API duckdb_logical_type duckdb_column_logical_type(duckdb_result *result, idx_t col);
+
 /*!
 Returns the number of columns present in a the result object.
 
@@ -392,9 +427,9 @@ queries. For other queries the rows_changed will be 0.
 DUCKDB_API idx_t duckdb_rows_changed(duckdb_result *result);
 
 /*!
-Returns the data of a specific column of a result in columnar format. This is the fastest way of accessing data in a
-query result, as no conversion or type checking must be performed (outside of the original switch). If performance
-is a concern, it is recommended to use this API over the `duckdb_value` functions.
+**DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.
+
+Returns the data of a specific column of a result in columnar format.
 
 The function returns a dense array which contains the result data. The exact type stored in the array depends on the
 corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
@@ -413,6 +448,8 @@ printf("Data for row %d: %d
", row, data[row]);
 DUCKDB_API void *duckdb_column_data(duckdb_result *result, idx_t col);
 
 /*!
+**DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.
+
 Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
 whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
 by `duckdb_column_data` are undefined.
@@ -441,17 +478,42 @@ The result of this function must not be freed. It will be cleaned up when `duckd
 * result: The result object to fetch the nullmask from.
 * returns: The error of the result.
 */
-DUCKDB_API char *duckdb_result_error(duckdb_result *result);
+DUCKDB_API const char *duckdb_result_error(duckdb_result *result);
 
 //===--------------------------------------------------------------------===//
 // Result Functions
 //===--------------------------------------------------------------------===//
 
+/*!
+Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.
+
+This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data`
+functions. It results in significantly better performance, and should be preferred in newer code-bases.
+
+If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be
+mixed with the legacy result functions).
+
+Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.
+
+* result: The result object to fetch the data chunk from.
+* chunk_index: The chunk index to fetch from.
+* returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
+*/
+DUCKDB_API duckdb_data_chunk duckdb_result_get_chunk(duckdb_result result, idx_t chunk_index);
+
+/*!
+Returns the number of data chunks present in the result.
+
+* result: The result object
+* returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
+*/
+DUCKDB_API idx_t duckdb_result_chunk_count(duckdb_result result);
+
 // Safe fetch functions
 // These functions will perform conversions if necessary.
 // On failure (e.g. if conversion cannot be performed or if the value is NULL) a default value is returned.
 // Note that these functions are slow since they perform bounds checking and conversion
-// For fast access of values prefer using duckdb_column_data and duckdb_nullmask_data
+// For fast access of values prefer using `duckdb_result_get_chunk`
 
 /*!
  * returns: The boolean value at the specified location, or false if the value cannot be converted.
@@ -582,6 +644,14 @@ Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_va
 */
 DUCKDB_API void duckdb_free(void *ptr);
 
+/*!
+The internal vector size used by DuckDB.
+This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.
+
+* returns: The vector size.
+*/
+DUCKDB_API idx_t duckdb_vector_size();
+
 //===--------------------------------------------------------------------===//
 // Date/Time/Timestamp Helpers
 //===--------------------------------------------------------------------===//
@@ -695,7 +765,7 @@ DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char
                                        duckdb_prepared_statement *out_prepared_statement);
 
 /*!
-Closes the prepared statement and de-allocates all memory allocated for that connection.
+Closes the prepared statement and de-allocates all memory allocated for the statement.
 
 * prepared_statement: The prepared statement to destroy.
 */
@@ -863,6 +933,642 @@ Executes the prepared statement with the given bound parameters, and returns an
 DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,
                                                       duckdb_arrow *out_result);
 
+//===--------------------------------------------------------------------===//
+// Value Interface
+//===--------------------------------------------------------------------===//
+/*!
+Destroys the value and de-allocates all memory allocated for that type.
+
+* value: The value to destroy.
+*/
+DUCKDB_API void duckdb_destroy_value(duckdb_value *value);
+
+/*!
+Creates a value from a varchar
+
+* value: The varchar value
+* returns: The value. This must be destroyed with `duckdb_destroy_value`.
+*/
+DUCKDB_API duckdb_value duckdb_create_varchar(const char *text);
+
+/*!
+Creates a value from an int64
+
+* value: The bigint value
+* returns: The value. This must be destroyed with `duckdb_destroy_value`.
+*/
+DUCKDB_API duckdb_value duckdb_create_int64(int64_t val);
+
+/*!
+Obtains a string representation of the given value.
+The result must be destroyed with `duckdb_free`.
+
+* value: The value
+* returns: The string value. This must be destroyed with `duckdb_free`.
+*/
+DUCKDB_API char *duckdb_get_varchar(duckdb_value value);
+
+/*!
+Obtains an int64 of the given value.
+
+* value: The value
+* returns: The int64 value, or 0 if no conversion is possible
+*/
+DUCKDB_API int64_t duckdb_get_int64(duckdb_value value);
+
+//===--------------------------------------------------------------------===//
+// Logical Type Interface
+//===--------------------------------------------------------------------===//
+
+/*!
+Creates a `duckdb_logical_type` from a standard primitive type.
+The resulting type should be destroyed with `duckdb_destroy_logical_type`.
+
+This should not be used with `DUCKDB_TYPE_DECIMAL`.
+
+* type: The primitive type to create.
+* returns: The logical type type.
+*/
+DUCKDB_API duckdb_logical_type duckdb_create_logical_type(duckdb_type type);
+
+/*!
+Retrieves the type class of a `duckdb_logical_type`.
+
+* type: The logical type object
+* returns: The type id
+*/
+DUCKDB_API duckdb_type duckdb_get_type_id(duckdb_logical_type type);
+
+/*!
+Retrieves the width of a decimal type.
+
+* type: The logical type object
+* returns: The width of the decimal type
+*/
+DUCKDB_API uint8_t duckdb_decimal_width(duckdb_logical_type type);
+
+/*!
+Retrieves the scale of a decimal type.
+
+* type: The logical type object
+* returns: The scale of the decimal type
+*/
+DUCKDB_API uint8_t duckdb_decimal_scale(duckdb_logical_type type);
+
+/*!
+Retrieves the internal storage type of a decimal type.
+
+* type: The logical type object
+* returns: The internal type of the decimal type
+*/
+DUCKDB_API duckdb_type duckdb_decimal_internal_type(duckdb_logical_type type);
+
+/*!
+Retrieves the internal storage type of an enum type.
+
+* type: The logical type object
+* returns: The internal type of the enum type
+*/
+DUCKDB_API duckdb_type duckdb_enum_internal_type(duckdb_logical_type type);
+
+/*!
+Retrieves the dictionary size of the enum type
+
+* type: The logical type object
+* returns: The dictionary size of the enum type
+*/
+DUCKDB_API uint32_t duckdb_enum_dictionary_size(duckdb_logical_type type);
+
+/*!
+Retrieves the dictionary value at the specified position from the enum.
+
+The result must be freed with `duckdb_free`
+
+* type: The logical type object
+* index: The index in the dictionary
+* returns: The string value of the enum type. Must be freed with `duckdb_free`.
+*/
+DUCKDB_API char *duckdb_enum_dictionary_value(duckdb_logical_type type, idx_t index);
+
+/*!
+Retrieves the child type of the given list type.
+
+The result must be freed with `duckdb_destroy_logical_type`
+
+* type: The logical type object
+* returns: The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`.
+*/
+DUCKDB_API duckdb_logical_type duckdb_list_type_child_type(duckdb_logical_type type);
+
+/*!
+Returns the number of children of a struct type.
+
+* type: The logical type object
+* returns: The number of children of a struct type.
+*/
+DUCKDB_API idx_t duckdb_struct_type_child_count(duckdb_logical_type type);
+
+/*!
+Retrieves the name of the struct child.
+
+The result must be freed with `duckdb_free`
+
+* type: The logical type object
+* index: The child index
+* returns: The name of the struct type. Must be freed with `duckdb_free`.
+*/
+DUCKDB_API char *duckdb_struct_type_child_name(duckdb_logical_type type, idx_t index);
+
+/*!
+Retrieves the child type of the given struct type at the specified index.
+
+The result must be freed with `duckdb_destroy_logical_type`
+
+* type: The logical type object
+* index: The child index
+* returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.
+*/
+DUCKDB_API duckdb_logical_type duckdb_struct_type_child_type(duckdb_logical_type type, idx_t index);
+
+/*!
+Destroys the logical type and de-allocates all memory allocated for that type.
+
+* type: The logical type to destroy.
+*/
+DUCKDB_API void duckdb_destroy_logical_type(duckdb_logical_type *type);
+
+//===--------------------------------------------------------------------===//
+// Data Chunk Interface
+//===--------------------------------------------------------------------===//
+/*!
+Creates an empty DataChunk with the specified set of types.
+
+* types: An array of types of the data chunk.
+* column_count: The number of columns.
+* returns: The data chunk.
+*/
+DUCKDB_API duckdb_data_chunk duckdb_create_data_chunk(duckdb_logical_type *types, idx_t column_count);
+
+/*!
+Destroys the data chunk and de-allocates all memory allocated for that chunk.
+
+* chunk: The data chunk to destroy.
+*/
+DUCKDB_API void duckdb_destroy_data_chunk(duckdb_data_chunk *chunk);
+
+/*!
+Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.
+
+* chunk: The data chunk to reset.
+*/
+DUCKDB_API void duckdb_data_chunk_reset(duckdb_data_chunk chunk);
+
+/*!
+Retrieves the number of columns in a data chunk.
+
+* chunk: The data chunk to get the data from
+* returns: The number of columns in the data chunk
+*/
+DUCKDB_API idx_t duckdb_data_chunk_get_column_count(duckdb_data_chunk chunk);
+
+/*!
+Retrieves the vector at the specified column index in the data chunk.
+
+The pointer to the vector is valid for as long as the chunk is alive.
+It does NOT need to be destroyed.
+
+* chunk: The data chunk to get the data from
+* returns: The vector
+*/
+DUCKDB_API duckdb_vector duckdb_data_chunk_get_vector(duckdb_data_chunk chunk, idx_t col_idx);
+
+/*!
+Retrieves the current number of tuples in a data chunk.
+
+* chunk: The data chunk to get the data from
+* returns: The number of tuples in the data chunk
+*/
+DUCKDB_API idx_t duckdb_data_chunk_get_size(duckdb_data_chunk chunk);
+
+/*!
+Sets the current number of tuples in a data chunk.
+
+* chunk: The data chunk to set the size in
+* size: The number of tuples in the data chunk
+*/
+DUCKDB_API void duckdb_data_chunk_set_size(duckdb_data_chunk chunk, idx_t size);
+
+//===--------------------------------------------------------------------===//
+// Vector Interface
+//===--------------------------------------------------------------------===//
+/*!
+Retrieves the column type of the specified vector.
+
+The result must be destroyed with `duckdb_destroy_logical_type`.
+
+* vector: The vector get the data from
+* returns: The type of the vector
+*/
+DUCKDB_API duckdb_logical_type duckdb_vector_get_column_type(duckdb_vector vector);
+
+/*!
+Retrieves the data pointer of the vector.
+
+The data pointer can be used to read or write values from the vector.
+How to read or write values depends on the type of the vector.
+
+* vector: The vector to get the data from
+* returns: The data pointer
+*/
+DUCKDB_API void *duckdb_vector_get_data(duckdb_vector vector);
+
+/*!
+Retrieves the validity mask pointer of the specified vector.
+
+If all values are valid, this function MIGHT return NULL!
+
+The validity mask is a bitset that signifies null-ness within the data chunk.
+It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.
+The bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).
+
+Validity of a specific value can be obtained like this:
+
+idx_t entry_idx = row_idx / 64;
+idx_t idx_in_entry = row_idx % 64;
+bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);
+
+Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.
+
+* vector: The vector to get the data from
+* returns: The pointer to the validity mask, or NULL if no validity mask is present
+*/
+DUCKDB_API uint64_t *duckdb_vector_get_validity(duckdb_vector vector);
+
+/*!
+Ensures the validity mask is writable by allocating it.
+
+After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.
+This allows null values to be written to the vector, regardless of whether a validity mask was present before.
+
+* vector: The vector to alter
+*/
+DUCKDB_API void duckdb_vector_ensure_validity_writable(duckdb_vector vector);
+
+/*!
+Assigns a string element in the vector at the specified location.
+
+* vector: The vector to alter
+* index: The row position in the vector to assign the string to
+* str: The null-terminated string
+*/
+DUCKDB_API void duckdb_vector_assign_string_element(duckdb_vector vector, idx_t index, const char *str);
+
+/*!
+Assigns a string element in the vector at the specified location.
+
+* vector: The vector to alter
+* index: The row position in the vector to assign the string to
+* str: The string
+* str_len: The length of the string (in bytes)
+*/
+DUCKDB_API void duckdb_vector_assign_string_element_len(duckdb_vector vector, idx_t index, const char *str,
+                                                        idx_t str_len);
+
+/*!
+Retrieves the child vector of a list vector.
+
+The resulting vector is valid as long as the parent vector is valid.
+
+* vector: The vector
+* returns: The child vector
+*/
+DUCKDB_API duckdb_vector duckdb_list_vector_get_child(duckdb_vector vector);
+
+/*!
+Returns the size of the child vector of the list
+
+* vector: The vector
+* returns: The size of the child list
+*/
+DUCKDB_API idx_t duckdb_list_vector_get_size(duckdb_vector vector);
+
+/*!
+Retrieves the child vector of a struct vector.
+
+The resulting vector is valid as long as the parent vector is valid.
+
+* vector: The vector
+* index: The child index
+* returns: The child vector
+*/
+DUCKDB_API duckdb_vector duckdb_struct_vector_get_child(duckdb_vector vector, idx_t index);
+
+//===--------------------------------------------------------------------===//
+// Validity Mask Functions
+//===--------------------------------------------------------------------===//
+/*!
+Returns whether or not a row is valid (i.e. not NULL) in the given validity mask.
+
+* validity: The validity mask, as obtained through `duckdb_data_chunk_get_validity`
+* row: The row index
+* returns: true if the row is valid, false otherwise
+*/
+DUCKDB_API bool duckdb_validity_row_is_valid(uint64_t *validity, idx_t row);
+
+/*!
+In a validity mask, sets a specific row to either valid or invalid.
+
+Note that `duckdb_data_chunk_ensure_validity_writable` should be called before calling `duckdb_data_chunk_get_validity`,
+to ensure that there is a validity mask to write to.
+
+* validity: The validity mask, as obtained through `duckdb_data_chunk_get_validity`.
+* row: The row index
+* valid: Whether or not to set the row to valid, or invalid
+*/
+DUCKDB_API void duckdb_validity_set_row_validity(uint64_t *validity, idx_t row, bool valid);
+
+/*!
+In a validity mask, sets a specific row to invalid.
+
+Equivalent to `duckdb_validity_set_row_validity` with valid set to false.
+
+* validity: The validity mask
+* row: The row index
+*/
+DUCKDB_API void duckdb_validity_set_row_invalid(uint64_t *validity, idx_t row);
+
+/*!
+In a validity mask, sets a specific row to valid.
+
+Equivalent to `duckdb_validity_set_row_validity` with valid set to true.
+
+* validity: The validity mask
+* row: The row index
+*/
+DUCKDB_API void duckdb_validity_set_row_valid(uint64_t *validity, idx_t row);
+
+//===--------------------------------------------------------------------===//
+// Table Functions
+//===--------------------------------------------------------------------===//
+typedef void *duckdb_table_function;
+typedef void *duckdb_bind_info;
+typedef void *duckdb_init_info;
+typedef void *duckdb_function_info;
+
+typedef void (*duckdb_table_function_bind_t)(duckdb_bind_info info);
+typedef void (*duckdb_table_function_init_t)(duckdb_init_info info);
+typedef void (*duckdb_table_function_t)(duckdb_function_info info, duckdb_data_chunk output);
+typedef void (*duckdb_delete_callback_t)(void *data);
+
+/*!
+Creates a new empty table function.
+
+The return value should be destroyed with `duckdb_destroy_table_function`.
+
+* returns: The table function object.
+*/
+DUCKDB_API duckdb_table_function duckdb_create_table_function();
+
+/*!
+Destroys the given table function object.
+
+* table_function: The table function to destroy
+*/
+DUCKDB_API void duckdb_destroy_table_function(duckdb_table_function *table_function);
+
+/*!
+Sets the name of the given table function.
+
+* table_function: The table function
+* name: The name of the table function
+*/
+DUCKDB_API void duckdb_table_function_set_name(duckdb_table_function table_function, const char *name);
+
+/*!
+Adds a parameter to the table function.
+
+* table_function: The table function
+* type: The type of the parameter to add.
+*/
+DUCKDB_API void duckdb_table_function_add_parameter(duckdb_table_function table_function, duckdb_logical_type type);
+
+/*!
+Assigns extra information to the table function that can be fetched during binding, etc.
+
+* table_function: The table function
+* extra_info: The extra information
+* destroy: The callback that will be called to destroy the bind data (if any)
+*/
+DUCKDB_API void duckdb_table_function_set_extra_info(duckdb_table_function table_function, void *extra_info,
+                                                     duckdb_delete_callback_t destroy);
+
+/*!
+Sets the bind function of the table function
+
+* table_function: The table function
+* bind: The bind function
+*/
+DUCKDB_API void duckdb_table_function_set_bind(duckdb_table_function table_function, duckdb_table_function_bind_t bind);
+
+/*!
+Sets the init function of the table function
+
+* table_function: The table function
+* init: The init function
+*/
+DUCKDB_API void duckdb_table_function_set_init(duckdb_table_function table_function, duckdb_table_function_init_t init);
+
+/*!
+Sets the main function of the table function
+
+* table_function: The table function
+* function: The function
+*/
+DUCKDB_API void duckdb_table_function_set_function(duckdb_table_function table_function,
+                                                   duckdb_table_function_t function);
+
+/*!
+Register the table function object within the given connection.
+
+The function requires at least a name, a bind function, an init function and a main function.
+
+If the function is incomplete or a function with this name already exists DuckDBError is returned.
+
+* con: The connection to register it in.
+* function: The function pointer
+* returns: Whether or not the registration was successful.
+*/
+DUCKDB_API duckdb_state duckdb_register_table_function(duckdb_connection con, duckdb_table_function function);
+
+//===--------------------------------------------------------------------===//
+// Table Function Bind
+//===--------------------------------------------------------------------===//
+/*!
+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
+
+* info: The info object
+* returns: The extra info
+*/
+DUCKDB_API void *duckdb_bind_get_extra_info(duckdb_bind_info info);
+
+/*!
+Adds a result column to the output of the table function.
+
+* info: The info object
+* name: The name of the column
+* type: The logical type of the column
+*/
+DUCKDB_API void duckdb_bind_add_result_column(duckdb_bind_info info, const char *name, duckdb_logical_type type);
+
+/*!
+Retrieves the number of regular (non-named) parameters to the function.
+
+* info: The info object
+* returns: The number of parameters
+*/
+DUCKDB_API idx_t duckdb_bind_get_parameter_count(duckdb_bind_info info);
+
+/*!
+Retrieves the parameter at the given index.
+
+The result must be destroyed with `duckdb_destroy_value`.
+
+* info: The info object
+* index: The index of the parameter to get
+* returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
+*/
+DUCKDB_API duckdb_value duckdb_bind_get_parameter(duckdb_bind_info info, idx_t index);
+
+/*!
+Sets the user-provided bind data in the bind object. This object can be retrieved again during execution.
+
+* info: The info object
+* extra_data: The bind data object.
+* destroy: The callback that will be called to destroy the bind data (if any)
+*/
+DUCKDB_API void duckdb_bind_set_bind_data(duckdb_bind_info info, void *bind_data, duckdb_delete_callback_t destroy);
+
+/*!
+Report that an error has occurred while calling bind.
+
+* info: The info object
+* error: The error message
+*/
+DUCKDB_API void duckdb_bind_set_error(duckdb_bind_info info, const char *error);
+
+//===--------------------------------------------------------------------===//
+// Table Function Init
+//===--------------------------------------------------------------------===//
+
+/*!
+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
+
+* info: The info object
+* returns: The extra info
+*/
+DUCKDB_API void *duckdb_init_get_extra_info(duckdb_init_info info);
+
+/*!
+Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
+
+Note that the bind data should be considered as read-only.
+For tracking state, use the init data instead.
+
+* info: The info object
+* returns: The bind data object
+*/
+DUCKDB_API void *duckdb_init_get_bind_data(duckdb_init_info info);
+
+/*!
+Sets the user-provided init data in the init object. This object can be retrieved again during execution.
+
+* info: The info object
+* extra_data: The init data object.
+* destroy: The callback that will be called to destroy the init data (if any)
+*/
+DUCKDB_API void duckdb_init_set_init_data(duckdb_init_info info, void *init_data, duckdb_delete_callback_t destroy);
+
+/*!
+Report that an error has occurred while calling init.
+
+* info: The info object
+* error: The error message
+*/
+DUCKDB_API void duckdb_init_set_error(duckdb_init_info info, const char *error);
+
+//===--------------------------------------------------------------------===//
+// Table Function
+//===--------------------------------------------------------------------===//
+
+/*!
+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
+
+* info: The info object
+* returns: The extra info
+*/
+DUCKDB_API void *duckdb_function_get_extra_info(duckdb_function_info info);
+/*!
+Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
+
+Note that the bind data should be considered as read-only.
+For tracking state, use the init data instead.
+
+* info: The info object
+* returns: The bind data object
+*/
+DUCKDB_API void *duckdb_function_get_bind_data(duckdb_function_info info);
+
+/*!
+Gets the init data set by `duckdb_bind_set_init_data` during the bind.
+
+* info: The info object
+* returns: The init data object
+*/
+DUCKDB_API void *duckdb_function_get_init_data(duckdb_function_info info);
+
+/*!
+Report that an error has occurred while executing the function.
+
+* info: The info object
+* error: The error message
+*/
+DUCKDB_API void duckdb_function_set_error(duckdb_function_info info, const char *error);
+
+//===--------------------------------------------------------------------===//
+// Replacement Scans
+//===--------------------------------------------------------------------===//
+typedef void *duckdb_replacement_scan_info;
+
+typedef void (*duckdb_replacement_callback_t)(duckdb_replacement_scan_info info, const char *table_name, void *data);
+
+/*!
+Add a replacement scan definition to the specified database
+
+* db: The database object to add the replacement scan to
+* replacement: The replacement scan callback
+* extra_data: Extra data that is passed back into the specified callback
+* delete_callback: The delete callback to call on the extra data, if any
+*/
+DUCKDB_API void duckdb_add_replacement_scan(duckdb_database db, duckdb_replacement_callback_t replacement,
+                                            void *extra_data, duckdb_delete_callback_t delete_callback);
+
+/*!
+Sets the replacement function name to use. If this function is called in the replacement callback,
+ the replacement scan is performed. If it is not called, the replacement callback is not performed.
+
+* info: The info object
+* function_name: The function name to substitute.
+*/
+DUCKDB_API void duckdb_replacement_scan_set_function_name(duckdb_replacement_scan_info info, const char *function_name);
+
+/*!
+Adds a parameter to the replacement scan function.
+
+* info: The info object
+* parameter: The parameter to add.
+*/
+DUCKDB_API void duckdb_replacement_scan_add_parameter(duckdb_replacement_scan_info info, duckdb_value parameter);
+
 //===--------------------------------------------------------------------===//
 // Appender
 //===--------------------------------------------------------------------===//
@@ -1030,6 +1736,19 @@ Append a NULL value to the appender (of any type).
 */
 DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);
 
+/*!
+Appends a pre-filled data chunk to the specified appender.
+
+The types of the data chunk must exactly match the types of the table, no casting is performed.
+If the types do not match or the appender is in an invalid state, DuckDBError is returned.
+If the append is successful, DuckDBSuccess is returned.
+
+* appender: The appender to append to.
+* chunk: The data chunk to append.
+* returns: The return state.
+*/
+DUCKDB_API duckdb_state duckdb_append_data_chunk(duckdb_appender appender, duckdb_data_chunk chunk);
+
 //===--------------------------------------------------------------------===//
 // Arrow Interface
 //===--------------------------------------------------------------------===//
diff --git a/src/include/duckdb/function/replacement_scan.hpp b/src/include/duckdb/function/replacement_scan.hpp
index 3907cf0588c6..3f0be11613ae 100644
--- a/src/include/duckdb/function/replacement_scan.hpp
+++ b/src/include/duckdb/function/replacement_scan.hpp
@@ -12,18 +12,26 @@
 
 namespace duckdb {
 
+class ClientContext;
 class TableFunctionRef;
 
-typedef unique_ptr<TableFunctionRef> (*replacement_scan_t)(const string &table_name, void *data);
+struct ReplacementScanData {
+	virtual ~ReplacementScanData() {
+	}
+};
+
+typedef unique_ptr<TableFunctionRef> (*replacement_scan_t)(ClientContext &context, const string &table_name,
+                                                           ReplacementScanData *data);
 
 //! Replacement table scans are automatically attempted when a table name cannot be found in the schema
 //! This allows you to do e.g. SELECT * FROM 'filename.csv', and automatically convert this into a CSV scan
 struct ReplacementScan {
-	explicit ReplacementScan(replacement_scan_t function, void *data = nullptr) : function(function), data(data) {
+	explicit ReplacementScan(replacement_scan_t function, unique_ptr<ReplacementScanData> data_p = nullptr)
+	    : function(function), data(move(data_p)) {
 	}
 
 	replacement_scan_t function;
-	void *data;
+	unique_ptr<ReplacementScanData> data;
 };
 
 } // namespace duckdb
diff --git a/src/include/duckdb/function/table/arrow.hpp b/src/include/duckdb/function/table/arrow.hpp
index bdbdebc47413..91601492397c 100644
--- a/src/include/duckdb/function/table/arrow.hpp
+++ b/src/include/duckdb/function/table/arrow.hpp
@@ -114,11 +114,8 @@ struct ArrowTableFunction {
 
 private:
 	//! Binds an arrow table
-	static unique_ptr<FunctionData> ArrowScanBind(ClientContext &context, vector<Value> &inputs,
-	                                              named_parameter_map_t &named_parameters,
-	                                              vector<LogicalType> &input_table_types,
-	                                              vector<string> &input_table_names, vector<LogicalType> &return_types,
-	                                              vector<string> &names);
+	static unique_ptr<FunctionData> ArrowScanBind(ClientContext &context, TableFunctionBindInput &input,
+	                                              vector<LogicalType> &return_types, vector<string> &names);
 	//! Actual conversion from Arrow to DuckDB
 	static void ArrowToDuckDB(ArrowScanState &scan_state,
 	                          std::unordered_map<idx_t, unique_ptr<ArrowConvertData>> &arrow_convert_data,
diff --git a/src/include/duckdb/function/table_function.hpp b/src/include/duckdb/function/table_function.hpp
index 0215e4579f25..29d7c9fe7aa1 100644
--- a/src/include/duckdb/function/table_function.hpp
+++ b/src/include/duckdb/function/table_function.hpp
@@ -22,16 +22,32 @@ struct FunctionOperatorData {
 	DUCKDB_API virtual ~FunctionOperatorData();
 };
 
+struct TableFunctionInfo {
+	DUCKDB_API virtual ~TableFunctionInfo();
+};
+
 struct TableFilterCollection {
 	DUCKDB_API explicit TableFilterCollection(TableFilterSet *table_filters);
 
 	TableFilterSet *table_filters;
 };
 
-typedef unique_ptr<FunctionData> (*table_function_bind_t)(ClientContext &context, vector<Value> &inputs,
-                                                          named_parameter_map_t &named_parameters,
-                                                          vector<LogicalType> &input_table_types,
-                                                          vector<string> &input_table_names,
+struct TableFunctionBindInput {
+	TableFunctionBindInput(vector<Value> &inputs, named_parameter_map_t &named_parameters,
+	                       vector<LogicalType> &input_table_types, vector<string> &input_table_names,
+	                       TableFunctionInfo *info)
+	    : inputs(inputs), named_parameters(named_parameters), input_table_types(input_table_types),
+	      input_table_names(input_table_names), info(info) {
+	}
+
+	vector<Value> &inputs;
+	named_parameter_map_t &named_parameters;
+	vector<LogicalType> &input_table_types;
+	vector<string> &input_table_names;
+	TableFunctionInfo *info;
+};
+
+typedef unique_ptr<FunctionData> (*table_function_bind_t)(ClientContext &context, TableFunctionBindInput &input,
                                                           vector<LogicalType> &return_types, vector<string> &names);
 typedef unique_ptr<FunctionOperatorData> (*table_function_init_t)(ClientContext &context, const FunctionData *bind_data,
                                                                   const vector<column_t> &column_ids,
@@ -142,6 +158,8 @@ class TableFunction : public SimpleNamedParameterFunction {
 	//! Whether or not the table function supports filter pushdown. If not supported a filter will be added
 	//! that applies the table filter directly.
 	bool filter_pushdown;
+	//! Additional function info, passed to the bind
+	shared_ptr<TableFunctionInfo> function_info;
 };
 
 } // namespace duckdb
diff --git a/src/include/duckdb/main/appender.hpp b/src/include/duckdb/main/appender.hpp
index 0e68cc466210..550bb7b25d0b 100644
--- a/src/include/duckdb/main/appender.hpp
+++ b/src/include/duckdb/main/appender.hpp
@@ -73,6 +73,7 @@ class BaseAppender {
 	DUCKDB_API idx_t CurrentColumn() {
 		return column;
 	}
+	DUCKDB_API void AppendDataChunk(DataChunk &value);
 
 protected:
 	void Destructor();
diff --git a/src/include/duckdb/main/capi_internal.hpp b/src/include/duckdb/main/capi_internal.hpp
index a70767b911ea..d608ac0096e2 100644
--- a/src/include/duckdb/main/capi_internal.hpp
+++ b/src/include/duckdb/main/capi_internal.hpp
@@ -43,12 +43,24 @@ struct AppenderWrapper {
 	string error;
 };
 
-duckdb_type ConvertCPPTypeToC(const LogicalType &type);
-idx_t GetCTypeSize(duckdb_type type);
-duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out);
+enum class CAPIResultSetType : uint8_t {
+	CAPI_RESULT_TYPE_NONE = 0,
+	CAPI_RESULT_TYPE_MATERIALIZED,
+	CAPI_RESULT_TYPE_DEPRECATED
+};
 
-struct DuckDBColumnData {
-	LogicalType type;
+struct DuckDBResultData {
+	//! The underlying query result
+	unique_ptr<QueryResult> result;
+	// Results can only use either the new API or the old API, not a mix of the two
+	// They start off as "none" and switch to one or the other when an API method is used
+	CAPIResultSetType result_set_type;
 };
 
+duckdb_type ConvertCPPTypeToC(const LogicalType &type);
+LogicalTypeId ConvertCTypeToCPP(duckdb_type c_type);
+idx_t GetCTypeSize(duckdb_type type);
+duckdb_state duckdb_translate_result(unique_ptr<QueryResult> result, duckdb_result *out);
+bool deprecated_materialize_result(duckdb_result *result);
+
 } // namespace duckdb
diff --git a/src/main/appender.cpp b/src/main/appender.cpp
index 6994172c1285..d182621a19c4 100644
--- a/src/main/appender.cpp
+++ b/src/main/appender.cpp
@@ -264,6 +264,16 @@ void BaseAppender::AppendValue(const Value &value) {
 	column++;
 }
 
+void BaseAppender::AppendDataChunk(DataChunk &chunk) {
+	if (chunk.GetTypes() != types) {
+		throw InvalidInputException("Type mismatch in Append DataChunk and the types required for appender");
+	}
+	collection.Append(chunk);
+	if (collection.ChunkCount() >= FLUSH_COUNT) {
+		Flush();
+	}
+}
+
 void BaseAppender::FlushChunk() {
 	if (chunk->size() == 0) {
 		return;
diff --git a/src/main/capi/CMakeLists.txt b/src/main/capi/CMakeLists.txt
index 8b6ea56b2393..fbab937b5cdc 100644
--- a/src/main/capi/CMakeLists.txt
+++ b/src/main/capi/CMakeLists.txt
@@ -4,12 +4,17 @@ add_library_unity(
   appender-c.cpp
   arrow-c.cpp
   config-c.cpp
+  data_chunk-c.cpp
   datetime-c.cpp
   duckdb-c.cpp
+  duckdb_value-c.cpp
   helper-c.cpp
   hugeint-c.cpp
+  logical_types-c.cpp
   prepared-c.cpp
+  replacement_scan-c.cpp
   result-c.cpp
+  table_function-c.cpp
   value-c.cpp)
 
 set(ALL_OBJECT_FILES
diff --git a/src/main/capi/appender-c.cpp b/src/main/capi/appender-c.cpp
index f8e55139febd..7e8f9db86963 100644
--- a/src/main/capi/appender-c.cpp
+++ b/src/main/capi/appender-c.cpp
@@ -194,3 +194,11 @@ duckdb_state duckdb_appender_flush(duckdb_appender appender) {
 duckdb_state duckdb_appender_close(duckdb_appender appender) {
 	return duckdb_appender_run_function(appender, [&](Appender &appender) { appender.Close(); });
 }
+
+duckdb_state duckdb_append_data_chunk(duckdb_appender appender, duckdb_data_chunk chunk) {
+	if (!chunk) {
+		return DuckDBError;
+	}
+	auto data_chunk = (duckdb::DataChunk *)chunk;
+	return duckdb_appender_run_function(appender, [&](Appender &appender) { appender.AppendDataChunk(*data_chunk); });
+}
diff --git a/src/main/capi/data_chunk-c.cpp b/src/main/capi/data_chunk-c.cpp
new file mode 100644
index 000000000000..cfae42324825
--- /dev/null
+++ b/src/main/capi/data_chunk-c.cpp
@@ -0,0 +1,172 @@
+#include "duckdb/main/capi_internal.hpp"
+#include "duckdb/common/types/data_chunk.hpp"
+#include "duckdb/common/types/string_type.hpp"
+#include <string.h>
+
+duckdb_data_chunk duckdb_create_data_chunk(duckdb_logical_type *ctypes, idx_t column_count) {
+	if (!ctypes) {
+		return nullptr;
+	}
+	duckdb::vector<duckdb::LogicalType> types;
+	for (idx_t i = 0; i < column_count; i++) {
+		auto ltype = (duckdb::LogicalType *)ctypes[i];
+		types.push_back(*ltype);
+	}
+
+	auto result = new duckdb::DataChunk();
+	result->Initialize(types);
+	return result;
+}
+
+void duckdb_destroy_data_chunk(duckdb_data_chunk *chunk) {
+	if (chunk && *chunk) {
+		auto dchunk = (duckdb::DataChunk *)*chunk;
+		delete dchunk;
+		*chunk = nullptr;
+	}
+}
+
+void duckdb_data_chunk_reset(duckdb_data_chunk chunk) {
+	if (!chunk) {
+		return;
+	}
+	auto dchunk = (duckdb::DataChunk *)chunk;
+	dchunk->Reset();
+}
+
+idx_t duckdb_data_chunk_get_column_count(duckdb_data_chunk chunk) {
+	if (!chunk) {
+		return 0;
+	}
+	auto dchunk = (duckdb::DataChunk *)chunk;
+	return dchunk->ColumnCount();
+}
+
+duckdb_vector duckdb_data_chunk_get_vector(duckdb_data_chunk chunk, idx_t col_idx) {
+	if (!chunk || col_idx >= duckdb_data_chunk_get_column_count(chunk)) {
+		return nullptr;
+	}
+	auto dchunk = (duckdb::DataChunk *)chunk;
+	return &dchunk->data[col_idx];
+}
+
+idx_t duckdb_data_chunk_get_size(duckdb_data_chunk chunk) {
+	if (!chunk) {
+		return 0;
+	}
+	auto dchunk = (duckdb::DataChunk *)chunk;
+	return dchunk->size();
+}
+
+void duckdb_data_chunk_set_size(duckdb_data_chunk chunk, idx_t size) {
+	if (!chunk) {
+		return;
+	}
+	auto dchunk = (duckdb::DataChunk *)chunk;
+	dchunk->SetCardinality(size);
+}
+
+duckdb_logical_type duckdb_vector_get_column_type(duckdb_vector vector) {
+	if (!vector) {
+		return nullptr;
+	}
+	auto v = (duckdb::Vector *)vector;
+	return new duckdb::LogicalType(v->GetType());
+}
+
+void *duckdb_vector_get_data(duckdb_vector vector) {
+	if (!vector) {
+		return nullptr;
+	}
+	auto v = (duckdb::Vector *)vector;
+	return duckdb::FlatVector::GetData(*v);
+}
+
+uint64_t *duckdb_vector_get_validity(duckdb_vector vector) {
+	if (!vector) {
+		return nullptr;
+	}
+	auto v = (duckdb::Vector *)vector;
+	return duckdb::FlatVector::Validity(*v).GetData();
+}
+
+void duckdb_vector_ensure_validity_writable(duckdb_vector vector) {
+	if (!vector) {
+		return;
+	}
+	auto v = (duckdb::Vector *)vector;
+	auto &validity = duckdb::FlatVector::Validity(*v);
+	validity.EnsureWritable();
+}
+
+void duckdb_vector_assign_string_element(duckdb_vector vector, idx_t index, const char *str) {
+	duckdb_vector_assign_string_element_len(vector, index, str, strlen(str));
+}
+
+void duckdb_vector_assign_string_element_len(duckdb_vector vector, idx_t index, const char *str, idx_t str_len) {
+	if (!vector) {
+		return;
+	}
+	auto v = (duckdb::Vector *)vector;
+	auto data = duckdb::FlatVector::GetData<duckdb::string_t>(*v);
+	data[index] = duckdb::StringVector::AddString(*v, str, str_len);
+}
+
+duckdb_vector duckdb_list_vector_get_child(duckdb_vector vector) {
+	if (!vector) {
+		return nullptr;
+	}
+	auto v = (duckdb::Vector *)vector;
+	return &duckdb::ListVector::GetEntry(*v);
+}
+
+idx_t duckdb_list_vector_get_size(duckdb_vector vector) {
+	if (!vector) {
+		return 0;
+	}
+	auto v = (duckdb::Vector *)vector;
+	return duckdb::ListVector::GetListSize(*v);
+}
+
+duckdb_vector duckdb_struct_vector_get_child(duckdb_vector vector, idx_t index) {
+	if (!vector) {
+		return nullptr;
+	}
+	auto v = (duckdb::Vector *)vector;
+	return duckdb::StructVector::GetEntries(*v)[index].get();
+}
+
+bool duckdb_validity_row_is_valid(uint64_t *validity, idx_t row) {
+	if (!validity) {
+		return true;
+	}
+	idx_t entry_idx = row / 64;
+	idx_t idx_in_entry = row % 64;
+	return validity[entry_idx] & (1 << idx_in_entry);
+}
+
+void duckdb_validity_set_row_validity(uint64_t *validity, idx_t row, bool valid) {
+	if (valid) {
+		duckdb_validity_set_row_valid(validity, row);
+	} else {
+		duckdb_validity_set_row_invalid(validity, row);
+	}
+}
+
+void duckdb_validity_set_row_invalid(uint64_t *validity, idx_t row) {
+	if (!validity) {
+		return;
+	}
+	idx_t entry_idx = row / 64;
+	idx_t idx_in_entry = row % 64;
+	validity[entry_idx] &= ~(1 << idx_in_entry);
+}
+
+void duckdb_validity_set_row_valid(uint64_t *validity, idx_t row) {
+	if (!validity) {
+		return;
+	}
+	idx_t entry_idx = row / 64;
+	idx_t idx_in_entry = row % 64;
+	validity[entry_idx] |= 1 << idx_in_entry;
+}
diff --git a/src/main/capi/duckdb-c.cpp b/src/main/capi/duckdb-c.cpp
index 575f6699a8ae..d882607b3439 100644
--- a/src/main/capi/duckdb-c.cpp
+++ b/src/main/capi/duckdb-c.cpp
@@ -65,5 +65,5 @@ void duckdb_disconnect(duckdb_connection *connection) {
 duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out) {
 	Connection *conn = (Connection *)connection;
 	auto result = conn->Query(query);
-	return duckdb_translate_result(result.get(), out);
+	return duckdb_translate_result(move(result), out);
 }
diff --git a/src/main/capi/duckdb_value-c.cpp b/src/main/capi/duckdb_value-c.cpp
new file mode 100644
index 000000000000..731bb8672b41
--- /dev/null
+++ b/src/main/capi/duckdb_value-c.cpp
@@ -0,0 +1,37 @@
+#include "duckdb/main/capi_internal.hpp"
+
+void duckdb_destroy_value(duckdb_value *value) {
+	if (value && *value) {
+		auto val = (duckdb::Value *)*value;
+		delete val;
+		*value = nullptr;
+	}
+}
+
+duckdb_value duckdb_create_varchar(const char *text) {
+	return (duckdb_value) new duckdb::Value(text);
+}
+
+duckdb_value duckdb_create_int64(int64_t input) {
+	auto val = duckdb::Value::BIGINT(input);
+	return (duckdb_value) new duckdb::Value(val);
+}
+
+char *duckdb_get_varchar(duckdb_value value) {
+	auto val = (duckdb::Value *)value;
+	auto str_val = val->CastAs(duckdb::LogicalType::VARCHAR);
+	auto &str = duckdb::StringValue::Get(str_val);
+
+	auto result = (char *)malloc(sizeof(char *) * (str.size() + 1));
+	memcpy(result, str.c_str(), str.size());
+	result[str.size()] = '\0';
+	return result;
+}
+
+int64_t duckdb_get_int64(duckdb_value value) {
+	auto val = (duckdb::Value *)value;
+	if (!val->TryCastAs(duckdb::LogicalType::BIGINT)) {
+		return 0;
+	}
+	return duckdb::BigIntValue::Get(*val);
+}
diff --git a/src/main/capi/helper-c.cpp b/src/main/capi/helper-c.cpp
index c754432fb5f1..8f545c53c6f2 100644
--- a/src/main/capi/helper-c.cpp
+++ b/src/main/capi/helper-c.cpp
@@ -2,6 +2,60 @@
 
 namespace duckdb {
 
+LogicalTypeId ConvertCTypeToCPP(duckdb_type c_type) {
+	switch (c_type) {
+	case DUCKDB_TYPE_BOOLEAN:
+		return LogicalTypeId::BOOLEAN;
+	case DUCKDB_TYPE_TINYINT:
+		return LogicalTypeId::TINYINT;
+	case DUCKDB_TYPE_SMALLINT:
+		return LogicalTypeId::SMALLINT;
+	case DUCKDB_TYPE_INTEGER:
+		return LogicalTypeId::INTEGER;
+	case DUCKDB_TYPE_BIGINT:
+		return LogicalTypeId::BIGINT;
+	case DUCKDB_TYPE_UTINYINT:
+		return LogicalTypeId::UTINYINT;
+	case DUCKDB_TYPE_USMALLINT:
+		return LogicalTypeId::USMALLINT;
+	case DUCKDB_TYPE_UINTEGER:
+		return LogicalTypeId::UINTEGER;
+	case DUCKDB_TYPE_UBIGINT:
+		return LogicalTypeId::UBIGINT;
+	case DUCKDB_TYPE_HUGEINT:
+		return LogicalTypeId::HUGEINT;
+	case DUCKDB_TYPE_FLOAT:
+		return LogicalTypeId::FLOAT;
+	case DUCKDB_TYPE_DOUBLE:
+		return LogicalTypeId::DOUBLE;
+	case DUCKDB_TYPE_TIMESTAMP:
+		return LogicalTypeId::TIMESTAMP;
+	case DUCKDB_TYPE_DATE:
+		return LogicalTypeId::DATE;
+	case DUCKDB_TYPE_TIME:
+		return LogicalTypeId::TIME;
+	case DUCKDB_TYPE_VARCHAR:
+		return LogicalTypeId::VARCHAR;
+	case DUCKDB_TYPE_JSON:
+		return LogicalTypeId::JSON;
+	case DUCKDB_TYPE_BLOB:
+		return LogicalTypeId::BLOB;
+	case DUCKDB_TYPE_INTERVAL:
+		return LogicalTypeId::INTERVAL;
+	case DUCKDB_TYPE_TIMESTAMP_S:
+		return LogicalTypeId::TIMESTAMP_SEC;
+	case DUCKDB_TYPE_TIMESTAMP_MS:
+		return LogicalTypeId::TIMESTAMP_MS;
+	case DUCKDB_TYPE_TIMESTAMP_NS:
+		return LogicalTypeId::TIMESTAMP_NS;
+	case DUCKDB_TYPE_UUID:
+		return LogicalTypeId::UUID;
+	default: // LCOV_EXCL_START
+		D_ASSERT(0);
+		return LogicalTypeId::INVALID;
+	} // LCOV_EXCL_STOP
+}
+
 duckdb_type ConvertCPPTypeToC(const LogicalType &sql_type) {
 	switch (sql_type.id()) {
 	case LogicalTypeId::BOOLEAN:
@@ -29,11 +83,14 @@ duckdb_type ConvertCPPTypeToC(const LogicalType &sql_type) {
 	case LogicalTypeId::DOUBLE:
 		return DUCKDB_TYPE_DOUBLE;
 	case LogicalTypeId::TIMESTAMP:
+	case LogicalTypeId::TIMESTAMP_TZ:
+		return DUCKDB_TYPE_TIMESTAMP;
 	case LogicalTypeId::TIMESTAMP_SEC:
+		return DUCKDB_TYPE_TIMESTAMP_S;
 	case LogicalTypeId::TIMESTAMP_MS:
+		return DUCKDB_TYPE_TIMESTAMP_MS;
 	case LogicalTypeId::TIMESTAMP_NS:
-	case LogicalTypeId::TIMESTAMP_TZ:
-		return DUCKDB_TYPE_TIMESTAMP;
+		return DUCKDB_TYPE_TIMESTAMP_NS;
 	case LogicalTypeId::DATE:
 		return DUCKDB_TYPE_DATE;
 	case LogicalTypeId::TIME:
@@ -41,17 +98,30 @@ duckdb_type ConvertCPPTypeToC(const LogicalType &sql_type) {
 		return DUCKDB_TYPE_TIME;
 	case LogicalTypeId::VARCHAR:
 		return DUCKDB_TYPE_VARCHAR;
+	case LogicalTypeId::JSON:
+		return DUCKDB_TYPE_JSON;
 	case LogicalTypeId::BLOB:
 		return DUCKDB_TYPE_BLOB;
 	case LogicalTypeId::INTERVAL:
 		return DUCKDB_TYPE_INTERVAL;
 	case LogicalTypeId::DECIMAL:
 		return DUCKDB_TYPE_DECIMAL;
+	case LogicalTypeId::ENUM:
+		return DUCKDB_TYPE_ENUM;
+	case LogicalTypeId::LIST:
+		return DUCKDB_TYPE_LIST;
+	case LogicalTypeId::STRUCT:
+		return DUCKDB_TYPE_STRUCT;
+	case LogicalTypeId::MAP:
+		return DUCKDB_TYPE_MAP;
+	case LogicalTypeId::UUID:
+		return DUCKDB_TYPE_UUID;
 	default: // LCOV_EXCL_START
 		D_ASSERT(0);
 		return DUCKDB_TYPE_INVALID;
 	} // LCOV_EXCL_STOP
 }
+
 idx_t GetCTypeSize(duckdb_type type) {
 	switch (type) {
 	case DUCKDB_TYPE_BOOLEAN:
@@ -73,6 +143,7 @@ idx_t GetCTypeSize(duckdb_type type) {
 	case DUCKDB_TYPE_UBIGINT:
 		return sizeof(uint64_t);
 	case DUCKDB_TYPE_HUGEINT:
+	case DUCKDB_TYPE_UUID:
 		return sizeof(duckdb_hugeint);
 	case DUCKDB_TYPE_FLOAT:
 		return sizeof(float);
@@ -83,6 +154,9 @@ idx_t GetCTypeSize(duckdb_type type) {
 	case DUCKDB_TYPE_TIME:
 		return sizeof(duckdb_time);
 	case DUCKDB_TYPE_TIMESTAMP:
+	case DUCKDB_TYPE_TIMESTAMP_S:
+	case DUCKDB_TYPE_TIMESTAMP_MS:
+	case DUCKDB_TYPE_TIMESTAMP_NS:
 		return sizeof(duckdb_timestamp);
 	case DUCKDB_TYPE_VARCHAR:
 		return sizeof(const char *);
@@ -108,3 +182,7 @@ void *duckdb_malloc(size_t size) {
 void duckdb_free(void *ptr) {
 	free(ptr);
 }
+
+idx_t duckdb_vector_size() {
+	return STANDARD_VECTOR_SIZE;
+}
diff --git a/src/main/capi/logical_types-c.cpp b/src/main/capi/logical_types-c.cpp
new file mode 100644
index 000000000000..44825001fc44
--- /dev/null
+++ b/src/main/capi/logical_types-c.cpp
@@ -0,0 +1,153 @@
+#include "duckdb/main/capi_internal.hpp"
+
+duckdb_logical_type duckdb_create_logical_type(duckdb_type type) {
+	return new duckdb::LogicalType(duckdb::ConvertCTypeToCPP(type));
+}
+
+duckdb_type duckdb_get_type_id(duckdb_logical_type type) {
+	if (!type) {
+		return DUCKDB_TYPE_INVALID;
+	}
+	auto ltype = (duckdb::LogicalType *)type;
+	return duckdb::ConvertCPPTypeToC(*ltype);
+}
+
+void duckdb_destroy_logical_type(duckdb_logical_type *type) {
+	if (type && *type) {
+		auto ltype = (duckdb::LogicalType *)*type;
+		delete ltype;
+		*type = nullptr;
+	}
+}
+
+uint8_t duckdb_decimal_width(duckdb_logical_type type) {
+	if (!type) {
+		return 0;
+	}
+	auto &ltype = *((duckdb::LogicalType *)type);
+	if (ltype.id() != duckdb::LogicalTypeId::DECIMAL) {
+		return 0;
+	}
+	return duckdb::DecimalType::GetWidth(ltype);
+}
+
+uint8_t duckdb_decimal_scale(duckdb_logical_type type) {
+	if (!type) {
+		return 0;
+	}
+	auto &ltype = *((duckdb::LogicalType *)type);
+	if (ltype.id() != duckdb::LogicalTypeId::DECIMAL) {
+		return 0;
+	}
+	return duckdb::DecimalType::GetScale(ltype);
+}
+
+duckdb_type duckdb_decimal_internal_type(duckdb_logical_type type) {
+	if (!type) {
+		return DUCKDB_TYPE_INVALID;
+	}
+	auto &ltype = *((duckdb::LogicalType *)type);
+	if (ltype.id() != duckdb::LogicalTypeId::DECIMAL) {
+		return DUCKDB_TYPE_INVALID;
+	}
+	switch (ltype.InternalType()) {
+	case duckdb::PhysicalType::INT16:
+		return DUCKDB_TYPE_SMALLINT;
+	case duckdb::PhysicalType::INT32:
+		return DUCKDB_TYPE_INTEGER;
+	case duckdb::PhysicalType::INT64:
+		return DUCKDB_TYPE_BIGINT;
+	case duckdb::PhysicalType::INT128:
+		return DUCKDB_TYPE_HUGEINT;
+	default:
+		return DUCKDB_TYPE_INVALID;
+	}
+}
+
+duckdb_type duckdb_enum_internal_type(duckdb_logical_type type) {
+	if (!type) {
+		return DUCKDB_TYPE_INVALID;
+	}
+	auto &ltype = *((duckdb::LogicalType *)type);
+	if (ltype.id() != duckdb::LogicalTypeId::ENUM) {
+		return DUCKDB_TYPE_INVALID;
+	}
+	switch (ltype.InternalType()) {
+	case duckdb::PhysicalType::UINT8:
+		return DUCKDB_TYPE_UTINYINT;
+	case duckdb::PhysicalType::UINT16:
+		return DUCKDB_TYPE_USMALLINT;
+	case duckdb::PhysicalType::UINT32:
+		return DUCKDB_TYPE_UINTEGER;
+	default:
+		return DUCKDB_TYPE_INVALID;
+	}
+}
+
+uint32_t duckdb_enum_dictionary_size(duckdb_logical_type type) {
+	if (!type) {
+		return 0;
+	}
+	auto &ltype = *((duckdb::LogicalType *)type);
+	if (ltype.id() != duckdb::LogicalTypeId::ENUM) {
+		return 0;
+	}
+	return duckdb::EnumType::GetSize(ltype);
+}
+
+char *duckdb_enum_dictionary_value(duckdb_logical_type type, idx_t index) {
+	if (!type) {
+		return nullptr;
+	}
+	auto &ltype = *((duckdb::LogicalType *)type);
+	if (ltype.id() != duckdb::LogicalTypeId::ENUM) {
+		return nullptr;
+	}
+	auto &vector = duckdb::EnumType::GetValuesInsertOrder(ltype);
+	auto value = vector.GetValue(index);
+	return strdup(duckdb::StringValue::Get(value).c_str());
+}
+
+duckdb_logical_type duckdb_list_type_child_type(duckdb_logical_type type) {
+	if (!type) {
+		return nullptr;
+	}
+	auto &ltype = *((duckdb::LogicalType *)type);
+	if (ltype.id() != duckdb::LogicalTypeId::LIST) {
+		return nullptr;
+	}
+	return new duckdb::LogicalType(duckdb::ListType::GetChildType(ltype));
+}
+
+idx_t duckdb_struct_type_child_count(duckdb_logical_type type) {
+	if (!type) {
+		return 0;
+	}
+	auto &ltype = *((duckdb::LogicalType *)type);
+	if (ltype.InternalType() != duckdb::PhysicalType::STRUCT) {
+		return 0;
+	}
+	return duckdb::StructType::GetChildCount(ltype);
+}
+
+char *duckdb_struct_type_child_name(duckdb_logical_type type, idx_t index) {
+	if (!type) {
+		return nullptr;
+	}
+	auto &ltype = *((duckdb::LogicalType *)type);
+	if (ltype.InternalType() != duckdb::PhysicalType::STRUCT) {
+		return nullptr;
+	}
+	return strdup(duckdb::StructType::GetChildName(ltype, index).c_str());
+}
+
+duckdb_logical_type duckdb_struct_type_child_type(duckdb_logical_type type, idx_t index) {
+	if (!type) {
+		return nullptr;
+	}
+	auto &ltype = *((duckdb::LogicalType *)type);
+	if (ltype.InternalType() != duckdb::PhysicalType::STRUCT) {
+		return nullptr;
+	}
+	return new duckdb::LogicalType(duckdb::StructType::GetChildType(ltype, index));
+}
diff --git a/src/main/capi/prepared-c.cpp b/src/main/capi/prepared-c.cpp
index ab2eb84ed684..ac6ad15004bd 100644
--- a/src/main/capi/prepared-c.cpp
+++ b/src/main/capi/prepared-c.cpp
@@ -58,7 +58,7 @@ static duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_stateme
 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
 		return DuckDBError;
 	}
-	if (param_idx > wrapper->statement->n_param) {
+	if (param_idx <= 0 || param_idx > wrapper->statement->n_param) {
 		return DuckDBError;
 	}
 	if (param_idx > wrapper->values.size()) {
@@ -143,12 +143,20 @@ duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement,
 }
 
 duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
+	try {
+		return duckdb_bind_value(prepared_statement, param_idx, Value(val));
+	} catch (...) {
+		return DuckDBError;
+	}
 }
 
 duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val,
                                         idx_t length) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value(std::string(val, length)));
+	try {
+		return duckdb_bind_value(prepared_statement, param_idx, Value(std::string(val, length)));
+	} catch (...) {
+		return DuckDBError;
+	}
 }
 
 duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx, const void *data,
@@ -166,9 +174,7 @@ duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statemen
 		return DuckDBError;
 	}
 	auto result = wrapper->statement->Execute(wrapper->values, false);
-	D_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);
-	auto mat_res = (MaterializedQueryResult *)result.get();
-	return duckdb_translate_result(mat_res, out_result);
+	return duckdb_translate_result(move(result), out_result);
 }
 
 void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement) {
diff --git a/src/main/capi/replacement_scan-c.cpp b/src/main/capi/replacement_scan-c.cpp
new file mode 100644
index 000000000000..b666f165986a
--- /dev/null
+++ b/src/main/capi/replacement_scan-c.cpp
@@ -0,0 +1,82 @@
+#include "duckdb/main/capi_internal.hpp"
+#include "duckdb/main/config.hpp"
+#include "duckdb/parser/tableref/table_function_ref.hpp"
+#include "duckdb/parser/expression/constant_expression.hpp"
+#include "duckdb/parser/expression/function_expression.hpp"
+
+namespace duckdb {
+
+struct CAPIReplacementScanData : public ReplacementScanData {
+	~CAPIReplacementScanData() {
+		if (delete_callback) {
+			delete_callback(extra_data);
+		}
+	}
+
+	duckdb_replacement_callback_t callback;
+	void *extra_data;
+	duckdb_delete_callback_t delete_callback;
+};
+
+struct CAPIReplacementScanInfo {
+	CAPIReplacementScanInfo(CAPIReplacementScanData *data) : data(data) {
+	}
+
+	CAPIReplacementScanData *data;
+	string function_name;
+	vector<Value> parameters;
+};
+
+unique_ptr<TableFunctionRef> duckdb_capi_replacement_callback(ClientContext &context, const string &table_name,
+                                                              ReplacementScanData *data) {
+	auto &scan_data = (CAPIReplacementScanData &)*data;
+
+	CAPIReplacementScanInfo info(&scan_data);
+	scan_data.callback((duckdb_replacement_scan_info)&info, table_name.c_str(), scan_data.extra_data);
+	if (info.function_name.empty()) {
+		// no function provided: bail-out
+		return nullptr;
+	}
+	auto table_function = make_unique<TableFunctionRef>();
+	vector<unique_ptr<ParsedExpression>> children;
+	for (auto &param : info.parameters) {
+		children.push_back(make_unique<ConstantExpression>(move(param)));
+	}
+	table_function->function = make_unique<FunctionExpression>(info.function_name, move(children));
+	return table_function;
+}
+
+} // namespace duckdb
+
+void duckdb_add_replacement_scan(duckdb_database db, duckdb_replacement_callback_t replacement, void *extra_data,
+                                 duckdb_delete_callback_t delete_callback) {
+	if (!db || !replacement) {
+		return;
+	}
+	auto wrapper = (duckdb::DatabaseData *)db;
+	auto scan_info = duckdb::make_unique<duckdb::CAPIReplacementScanData>();
+	scan_info->callback = replacement;
+	scan_info->extra_data = extra_data;
+	scan_info->delete_callback = delete_callback;
+
+	auto &config = duckdb::DBConfig::GetConfig(*wrapper->database->instance);
+	config.replacement_scans.push_back(
+	    duckdb::ReplacementScan(duckdb::duckdb_capi_replacement_callback, move(scan_info)));
+}
+
+void duckdb_replacement_scan_set_function_name(duckdb_replacement_scan_info info_p, const char *function_name) {
+	if (!info_p || !function_name) {
+		return;
+	}
+	auto info = (duckdb::CAPIReplacementScanInfo *)info_p;
+	info->function_name = function_name;
+}
+
+void duckdb_replacement_scan_add_parameter(duckdb_replacement_scan_info info_p, duckdb_value parameter) {
+	if (!info_p || !parameter) {
+		return;
+	}
+	auto info = (duckdb::CAPIReplacementScanInfo *)info_p;
+	auto val = (duckdb::Value *)parameter;
+	info->parameters.push_back(*val);
+}
diff --git a/src/main/capi/result-c.cpp b/src/main/capi/result-c.cpp
index 25d31f9d39a7..d65f590c1045 100644
--- a/src/main/capi/result-c.cpp
+++ b/src/main/capi/result-c.cpp
@@ -4,9 +4,9 @@
 namespace duckdb {
 
 template <class T>
-void WriteData(duckdb_result *out, ChunkCollection &source, idx_t col) {
+void WriteData(duckdb_column *column, ChunkCollection &source, idx_t col) {
 	idx_t row = 0;
-	auto target = (T *)out->__deprecated_columns[col].__deprecated_data;
+	auto target = (T *)column->__deprecated_data;
 	for (auto &chunk : source.Chunks()) {
 		auto source = FlatVector::GetData<T>(chunk->data[col]);
 		auto &mask = FlatVector::Validity(chunk->data[col]);
@@ -20,276 +20,317 @@ void WriteData(duckdb_result *out, ChunkCollection &source, idx_t col) {
 	}
 }
 
-duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out) {
-	D_ASSERT(result);
-	if (!out) {
-		// no result to write to, only return the status
-		return result->success ? DuckDBSuccess : DuckDBError;
-	}
-	memset(out, 0, sizeof(duckdb_result));
-	if (!result->success) {
-		// write the error message
-		out->__deprecated_error_message = strdup(result->error.c_str());
-		return DuckDBError;
-	}
-	// copy the data
-	// first write the meta data
-	out->__deprecated_column_count = result->types.size();
-	out->__deprecated_row_count = result->collection.Count();
-	out->__deprecated_rows_changed = 0;
-	if (out->__deprecated_row_count > 0 && StatementTypeReturnChanges(result->statement_type)) {
-		// update total changes
-		auto row_changes = result->GetValue(0, 0);
-		if (!row_changes.IsNull() && row_changes.TryCastAs(LogicalType::BIGINT)) {
-			out->__deprecated_rows_changed = row_changes.GetValue<int64_t>();
-		}
-	}
-	out->__deprecated_columns = (duckdb_column *)duckdb_malloc(sizeof(duckdb_column) * out->__deprecated_column_count);
-	if (!out->__deprecated_columns) { // LCOV_EXCL_START
+duckdb_state deprecated_duckdb_translate_column(MaterializedQueryResult &result, duckdb_column *column, idx_t col) {
+	idx_t row_count = result.collection.Count();
+	column->__deprecated_nullmask = (bool *)duckdb_malloc(sizeof(bool) * result.collection.Count());
+	column->__deprecated_data = duckdb_malloc(GetCTypeSize(column->__deprecated_type) * row_count);
+	if (!column->__deprecated_nullmask || !column->__deprecated_data) { // LCOV_EXCL_START
 		// malloc failure
 		return DuckDBError;
 	} // LCOV_EXCL_STOP
 
-	// zero initialize the columns (so we can cleanly delete it in case a malloc fails)
-	memset(out->__deprecated_columns, 0, sizeof(duckdb_column) * out->__deprecated_column_count);
-	for (idx_t i = 0; i < out->__deprecated_column_count; i++) {
-		auto column_data = new DuckDBColumnData();
-		column_data->type = result->types[i];
-		out->__deprecated_columns[i].internal_data = column_data;
-		out->__deprecated_columns[i].__deprecated_type = ConvertCPPTypeToC(result->types[i]);
-		out->__deprecated_columns[i].__deprecated_name = strdup(result->names[i].c_str());
-		out->__deprecated_columns[i].__deprecated_nullmask =
-		    (bool *)duckdb_malloc(sizeof(bool) * out->__deprecated_row_count);
-		out->__deprecated_columns[i].__deprecated_data =
-		    duckdb_malloc(GetCTypeSize(out->__deprecated_columns[i].__deprecated_type) * out->__deprecated_row_count);
-		if (!out->__deprecated_columns[i].__deprecated_nullmask || !out->__deprecated_columns[i].__deprecated_name ||
-		    !out->__deprecated_columns[i].__deprecated_data) { // LCOV_EXCL_START
-			// malloc failure
-			return DuckDBError;
-		} // LCOV_EXCL_STOP
+	// first convert the nullmask
+	idx_t row = 0;
+	for (auto &chunk : result.collection.Chunks()) {
+		for (idx_t k = 0; k < chunk->size(); k++) {
+			column->__deprecated_nullmask[row++] = FlatVector::IsNull(chunk->data[col], k);
+		}
 	}
-	// now write the data
-	for (idx_t col = 0; col < out->__deprecated_column_count; col++) {
-		// first set the nullmask
+	// then write the data
+	switch (result.types[col].id()) {
+	case LogicalTypeId::BOOLEAN:
+		WriteData<bool>(column, result.collection, col);
+		break;
+	case LogicalTypeId::TINYINT:
+		WriteData<int8_t>(column, result.collection, col);
+		break;
+	case LogicalTypeId::SMALLINT:
+		WriteData<int16_t>(column, result.collection, col);
+		break;
+	case LogicalTypeId::INTEGER:
+		WriteData<int32_t>(column, result.collection, col);
+		break;
+	case LogicalTypeId::BIGINT:
+		WriteData<int64_t>(column, result.collection, col);
+		break;
+	case LogicalTypeId::UTINYINT:
+		WriteData<uint8_t>(column, result.collection, col);
+		break;
+	case LogicalTypeId::USMALLINT:
+		WriteData<uint16_t>(column, result.collection, col);
+		break;
+	case LogicalTypeId::UINTEGER:
+		WriteData<uint32_t>(column, result.collection, col);
+		break;
+	case LogicalTypeId::UBIGINT:
+		WriteData<uint64_t>(column, result.collection, col);
+		break;
+	case LogicalTypeId::FLOAT:
+		WriteData<float>(column, result.collection, col);
+		break;
+	case LogicalTypeId::DOUBLE:
+		WriteData<double>(column, result.collection, col);
+		break;
+	case LogicalTypeId::DATE:
+		WriteData<date_t>(column, result.collection, col);
+		break;
+	case LogicalTypeId::TIME:
+	case LogicalTypeId::TIME_TZ:
+		WriteData<dtime_t>(column, result.collection, col);
+		break;
+	case LogicalTypeId::TIMESTAMP:
+	case LogicalTypeId::TIMESTAMP_TZ:
+		WriteData<timestamp_t>(column, result.collection, col);
+		break;
+	case LogicalTypeId::VARCHAR: {
 		idx_t row = 0;
-		for (auto &chunk : result->collection.Chunks()) {
+		auto target = (const char **)column->__deprecated_data;
+		for (auto &chunk : result.collection.Chunks()) {
+			auto source = FlatVector::GetData<string_t>(chunk->data[col]);
 			for (idx_t k = 0; k < chunk->size(); k++) {
-				out->__deprecated_columns[col].__deprecated_nullmask[row++] = FlatVector::IsNull(chunk->data[col], k);
+				if (!FlatVector::IsNull(chunk->data[col], k)) {
+					target[row] = (char *)duckdb_malloc(source[k].GetSize() + 1);
+					assert(target[row]);
+					memcpy((void *)target[row], source[k].GetDataUnsafe(), source[k].GetSize());
+					auto write_arr = (char *)target[row];
+					write_arr[source[k].GetSize()] = '\0';
+				} else {
+					target[row] = nullptr;
+				}
+				row++;
 			}
 		}
-		// then write the data
-		switch (result->types[col].id()) {
-		case LogicalTypeId::BOOLEAN:
-			WriteData<bool>(out, result->collection, col);
-			break;
-		case LogicalTypeId::TINYINT:
-			WriteData<int8_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::SMALLINT:
-			WriteData<int16_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::INTEGER:
-			WriteData<int32_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::BIGINT:
-			WriteData<int64_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::UTINYINT:
-			WriteData<uint8_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::USMALLINT:
-			WriteData<uint16_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::UINTEGER:
-			WriteData<uint32_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::UBIGINT:
-			WriteData<uint64_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::FLOAT:
-			WriteData<float>(out, result->collection, col);
-			break;
-		case LogicalTypeId::DOUBLE:
-			WriteData<double>(out, result->collection, col);
-			break;
-		case LogicalTypeId::DATE:
-			WriteData<date_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::TIME:
-		case LogicalTypeId::TIME_TZ:
-			WriteData<dtime_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::TIMESTAMP:
-		case LogicalTypeId::TIMESTAMP_TZ:
-			WriteData<timestamp_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::VARCHAR: {
-			idx_t row = 0;
-			auto target = (const char **)out->__deprecated_columns[col].__deprecated_data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
-				for (idx_t k = 0; k < chunk->size(); k++) {
-					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						target[row] = (char *)duckdb_malloc(source[k].GetSize() + 1);
-						assert(target[row]);
-						memcpy((void *)target[row], source[k].GetDataUnsafe(), source[k].GetSize());
-						auto write_arr = (char *)target[row];
-						write_arr[source[k].GetSize()] = '\0';
+		break;
+	}
+	case LogicalTypeId::BLOB: {
+		idx_t row = 0;
+		auto target = (duckdb_blob *)column->__deprecated_data;
+		for (auto &chunk : result.collection.Chunks()) {
+			auto source = FlatVector::GetData<string_t>(chunk->data[col]);
+			for (idx_t k = 0; k < chunk->size(); k++) {
+				if (!FlatVector::IsNull(chunk->data[col], k)) {
+					target[row].data = (char *)duckdb_malloc(source[k].GetSize());
+					target[row].size = source[k].GetSize();
+					assert(target[row].data);
+					memcpy((void *)target[row].data, source[k].GetDataUnsafe(), source[k].GetSize());
+				} else {
+					target[row].data = nullptr;
+					target[row].size = 0;
+				}
+				row++;
+			}
+		}
+		break;
+	}
+	case LogicalTypeId::TIMESTAMP_NS:
+	case LogicalTypeId::TIMESTAMP_MS:
+	case LogicalTypeId::TIMESTAMP_SEC: {
+		idx_t row = 0;
+		auto target = (timestamp_t *)column->__deprecated_data;
+		for (auto &chunk : result.collection.Chunks()) {
+			auto source = FlatVector::GetData<timestamp_t>(chunk->data[col]);
+
+			for (idx_t k = 0; k < chunk->size(); k++) {
+				if (!FlatVector::IsNull(chunk->data[col], k)) {
+					if (result.types[col].id() == LogicalTypeId::TIMESTAMP_NS) {
+						target[row] = Timestamp::FromEpochNanoSeconds(source[k].value);
+					} else if (result.types[col].id() == LogicalTypeId::TIMESTAMP_MS) {
+						target[row] = Timestamp::FromEpochMs(source[k].value);
 					} else {
-						target[row] = nullptr;
+						D_ASSERT(result.types[col].id() == LogicalTypeId::TIMESTAMP_SEC);
+						target[row] = Timestamp::FromEpochSeconds(source[k].value);
 					}
-					row++;
 				}
+				row++;
+			}
+		}
+		break;
+	}
+	case LogicalTypeId::HUGEINT: {
+		idx_t row = 0;
+		auto target = (duckdb_hugeint *)column->__deprecated_data;
+		for (auto &chunk : result.collection.Chunks()) {
+			auto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);
+			for (idx_t k = 0; k < chunk->size(); k++) {
+				if (!FlatVector::IsNull(chunk->data[col], k)) {
+					target[row].lower = source[k].lower;
+					target[row].upper = source[k].upper;
+				}
+				row++;
+			}
+		}
+		break;
+	}
+	case LogicalTypeId::INTERVAL: {
+		idx_t row = 0;
+		auto target = (duckdb_interval *)column->__deprecated_data;
+		for (auto &chunk : result.collection.Chunks()) {
+			auto source = FlatVector::GetData<interval_t>(chunk->data[col]);
+			for (idx_t k = 0; k < chunk->size(); k++) {
+				if (!FlatVector::IsNull(chunk->data[col], k)) {
+					target[row].days = source[k].days;
+					target[row].months = source[k].months;
+					target[row].micros = source[k].micros;
+				}
+				row++;
 			}
-			break;
 		}
-		case LogicalTypeId::BLOB: {
-			idx_t row = 0;
-			auto target = (duckdb_blob *)out->__deprecated_columns[col].__deprecated_data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
+		break;
+	}
+	case LogicalTypeId::DECIMAL: {
+		// get data
+		idx_t row = 0;
+		auto target = (hugeint_t *)column->__deprecated_data;
+		switch (result.types[col].InternalType()) {
+		case PhysicalType::INT16: {
+			for (auto &chunk : result.collection.Chunks()) {
+				auto source = FlatVector::GetData<int16_t>(chunk->data[col]);
 				for (idx_t k = 0; k < chunk->size(); k++) {
 					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						target[row].data = (char *)duckdb_malloc(source[k].GetSize());
-						target[row].size = source[k].GetSize();
-						assert(target[row].data);
-						memcpy((void *)target[row].data, source[k].GetDataUnsafe(), source[k].GetSize());
-					} else {
-						target[row].data = nullptr;
-						target[row].size = 0;
+						target[row].lower = source[k];
+						target[row].upper = 0;
 					}
 					row++;
 				}
 			}
 			break;
 		}
-		case LogicalTypeId::TIMESTAMP_NS:
-		case LogicalTypeId::TIMESTAMP_MS:
-		case LogicalTypeId::TIMESTAMP_SEC: {
-			idx_t row = 0;
-			auto target = (timestamp_t *)out->__deprecated_columns[col].__deprecated_data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<timestamp_t>(chunk->data[col]);
-
+		case PhysicalType::INT32: {
+			for (auto &chunk : result.collection.Chunks()) {
+				auto source = FlatVector::GetData<int32_t>(chunk->data[col]);
 				for (idx_t k = 0; k < chunk->size(); k++) {
 					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						if (result->types[col].id() == LogicalTypeId::TIMESTAMP_NS) {
-							target[row] = Timestamp::FromEpochNanoSeconds(source[k].value);
-						} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_MS) {
-							target[row] = Timestamp::FromEpochMs(source[k].value);
-						} else {
-							D_ASSERT(result->types[col].id() == LogicalTypeId::TIMESTAMP_SEC);
-							target[row] = Timestamp::FromEpochSeconds(source[k].value);
-						}
+						target[row].lower = source[k];
+						target[row].upper = 0;
 					}
 					row++;
 				}
 			}
 			break;
 		}
-		case LogicalTypeId::HUGEINT: {
-			idx_t row = 0;
-			auto target = (duckdb_hugeint *)out->__deprecated_columns[col].__deprecated_data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);
+		case PhysicalType::INT64: {
+			for (auto &chunk : result.collection.Chunks()) {
+				auto source = FlatVector::GetData<int64_t>(chunk->data[col]);
 				for (idx_t k = 0; k < chunk->size(); k++) {
 					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						target[row].lower = source[k].lower;
-						target[row].upper = source[k].upper;
+						target[row].lower = source[k];
+						target[row].upper = 0;
 					}
 					row++;
 				}
 			}
 			break;
 		}
-		case LogicalTypeId::INTERVAL: {
-			idx_t row = 0;
-			auto target = (duckdb_interval *)out->__deprecated_columns[col].__deprecated_data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<interval_t>(chunk->data[col]);
+		case PhysicalType::INT128: {
+			for (auto &chunk : result.collection.Chunks()) {
+				auto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);
 				for (idx_t k = 0; k < chunk->size(); k++) {
 					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						target[row].days = source[k].days;
-						target[row].months = source[k].months;
-						target[row].micros = source[k].micros;
+						target[row].lower = source[k].lower;
+						target[row].upper = source[k].upper;
 					}
 					row++;
 				}
 			}
 			break;
 		}
-		case LogicalTypeId::DECIMAL: {
-			// get data
-			idx_t row = 0;
-			auto target = (hugeint_t *)out->__deprecated_columns[col].__deprecated_data;
-			switch (result->types[col].InternalType()) {
-			case PhysicalType::INT16: {
-				for (auto &chunk : result->collection.Chunks()) {
-					auto source = FlatVector::GetData<int16_t>(chunk->data[col]);
-					for (idx_t k = 0; k < chunk->size(); k++) {
-						if (!FlatVector::IsNull(chunk->data[col], k)) {
-							target[row].lower = source[k];
-							target[row].upper = 0;
-						}
-						row++;
-					}
-				}
-				break;
-			}
-			case PhysicalType::INT32: {
-				for (auto &chunk : result->collection.Chunks()) {
-					auto source = FlatVector::GetData<int32_t>(chunk->data[col]);
-					for (idx_t k = 0; k < chunk->size(); k++) {
-						if (!FlatVector::IsNull(chunk->data[col], k)) {
-							target[row].lower = source[k];
-							target[row].upper = 0;
-						}
-						row++;
-					}
-				}
-				break;
-			}
-			case PhysicalType::INT64: {
-				for (auto &chunk : result->collection.Chunks()) {
-					auto source = FlatVector::GetData<int64_t>(chunk->data[col]);
-					for (idx_t k = 0; k < chunk->size(); k++) {
-						if (!FlatVector::IsNull(chunk->data[col], k)) {
-							target[row].lower = source[k];
-							target[row].upper = 0;
-						}
-						row++;
-					}
-				}
-				break;
-			}
-			case PhysicalType::INT128: {
-				for (auto &chunk : result->collection.Chunks()) {
-					auto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);
-					for (idx_t k = 0; k < chunk->size(); k++) {
-						if (!FlatVector::IsNull(chunk->data[col], k)) {
-							target[row].lower = source[k].lower;
-							target[row].upper = source[k].upper;
-						}
-						row++;
-					}
-				}
-				break;
-			}
-			default:
-				throw std::runtime_error("Unsupported physical type for Decimal" +
-				                         TypeIdToString(result->types[col].InternalType()));
-			}
-			break;
+		default:
+			throw std::runtime_error("Unsupported physical type for Decimal" +
+			                         TypeIdToString(result.types[col].InternalType()));
 		}
-		default: // LCOV_EXCL_START
-			std::string err_msg = "Unsupported type for C API: " + result->types[col].ToString();
-			out->__deprecated_error_message = strdup(err_msg.c_str());
-			return DuckDBError;
-		} // LCOV_EXCL_STOP
+		break;
+	}
+	default: // LCOV_EXCL_START
+		return DuckDBError;
+	} // LCOV_EXCL_STOP
+	return DuckDBSuccess;
+}
+
+duckdb_state duckdb_translate_result(unique_ptr<QueryResult> result_p, duckdb_result *out) {
+	auto &result = *result_p;
+	D_ASSERT(result_p);
+	if (!out) {
+		// no result to write to, only return the status
+		return result.success ? DuckDBSuccess : DuckDBError;
+	}
+
+	memset(out, 0, sizeof(duckdb_result));
+
+	// initialize the result_data object
+	auto result_data = new DuckDBResultData();
+	result_data->result = move(result_p);
+	result_data->result_set_type = CAPIResultSetType::CAPI_RESULT_TYPE_NONE;
+	out->internal_data = result_data;
+
+	if (!result.success) {
+		// write the error message
+		out->__deprecated_error_message = (char *)result.error.c_str();
+		return DuckDBError;
 	}
+	// copy the data
+	// first write the meta data
+	out->__deprecated_column_count = result.ColumnCount();
+	out->__deprecated_rows_changed = 0;
 	return DuckDBSuccess;
 }
 
+bool deprecated_materialize_result(duckdb_result *result) {
+	if (!result) {
+		return false;
+	}
+	auto result_data = (duckdb::DuckDBResultData *)result->internal_data;
+	if (!result_data->result->success) {
+		return false;
+	}
+	if (result_data->result_set_type == CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED) {
+		// already materialized into deprecated result format
+		return true;
+	}
+	if (result_data->result_set_type == CAPIResultSetType::CAPI_RESULT_TYPE_MATERIALIZED) {
+		// already used as a new result set
+		return false;
+	}
+	// materialize as deprecated result set
+	result_data->result_set_type = CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED;
+	auto column_count = result_data->result->ColumnCount();
+	result->__deprecated_columns = (duckdb_column *)duckdb_malloc(sizeof(duckdb_column) * column_count);
+	if (!result->__deprecated_columns) { // LCOV_EXCL_START
+		// malloc failure
+		return DuckDBError;
+	} // LCOV_EXCL_STOP
+	if (result_data->result->type == QueryResultType::STREAM_RESULT) {
+		// if we are dealing with a stream result, convert it to a materialized result first
+		auto &stream_result = (StreamQueryResult &)*result_data->result;
+		result_data->result = stream_result.Materialize();
+	}
+	D_ASSERT(result_data->result->type == QueryResultType::MATERIALIZED_RESULT);
+	auto &materialized = (MaterializedQueryResult &)*result_data->result;
+
+	// convert the result to a materialized result
+	// zero initialize the columns (so we can cleanly delete it in case a malloc fails)
+	memset(result->__deprecated_columns, 0, sizeof(duckdb_column) * column_count);
+	for (idx_t i = 0; i < column_count; i++) {
+		result->__deprecated_columns[i].__deprecated_type = ConvertCPPTypeToC(result_data->result->types[i]);
+		result->__deprecated_columns[i].__deprecated_name = (char *)result_data->result->names[i].c_str();
+	}
+	result->__deprecated_row_count = materialized.collection.Count();
+	if (result->__deprecated_row_count > 0 && StatementTypeReturnChanges(materialized.statement_type)) {
+		// update total changes
+		auto row_changes = materialized.GetValue(0, 0);
+		if (!row_changes.IsNull() && row_changes.TryCastAs(LogicalType::BIGINT)) {
+			result->__deprecated_rows_changed = row_changes.GetValue<int64_t>();
+		}
+	}
+	// now write the data
+	for (idx_t col = 0; col < column_count; col++) {
+		auto state = deprecated_duckdb_translate_column(materialized, &result->__deprecated_columns[col], col);
+		if (state != DuckDBSuccess) {
+			return false;
+		}
+	}
+	return true;
+}
+
 } // namespace duckdb
 
 static void DuckdbDestroyColumn(duckdb_column column, idx_t count) {
@@ -316,60 +357,70 @@ static void DuckdbDestroyColumn(duckdb_column column, idx_t count) {
 	if (column.__deprecated_nullmask) {
 		duckdb_free(column.__deprecated_nullmask);
 	}
-	if (column.__deprecated_name) {
-		duckdb_free(column.__deprecated_name);
-	}
-	if (column.internal_data) {
-		auto column_data = (duckdb::DuckDBColumnData *)column.internal_data;
-		delete column_data;
-	}
 }
 
 void duckdb_destroy_result(duckdb_result *result) {
-	if (result->__deprecated_error_message) {
-		duckdb_free(result->__deprecated_error_message);
-	}
 	if (result->__deprecated_columns) {
 		for (idx_t i = 0; i < result->__deprecated_column_count; i++) {
 			DuckdbDestroyColumn(result->__deprecated_columns[i], result->__deprecated_row_count);
 		}
 		duckdb_free(result->__deprecated_columns);
 	}
+	if (result->internal_data) {
+		auto result_data = (duckdb::DuckDBResultData *)result->internal_data;
+		delete result_data;
+	}
 	memset(result, 0, sizeof(duckdb_result));
 }
 
 const char *duckdb_column_name(duckdb_result *result, idx_t col) {
-	if (!result || col >= result->__deprecated_column_count) {
+	if (!result || col >= duckdb_column_count(result)) {
 		return nullptr;
 	}
-	return result->__deprecated_columns[col].__deprecated_name;
+	auto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);
+	return result_data.result->names[col].c_str();
 }
 
 duckdb_type duckdb_column_type(duckdb_result *result, idx_t col) {
-	if (!result || col >= result->__deprecated_column_count) {
+	if (!result || col >= duckdb_column_count(result)) {
 		return DUCKDB_TYPE_INVALID;
 	}
-	return result->__deprecated_columns[col].__deprecated_type;
+	auto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);
+	return duckdb::ConvertCPPTypeToC(result_data.result->types[col]);
+}
+
+duckdb_logical_type duckdb_column_logical_type(duckdb_result *result, idx_t col) {
+	if (!result || col >= duckdb_column_count(result)) {
+		return nullptr;
+	}
+	auto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);
+	return new duckdb::LogicalType(result_data.result->types[col]);
 }
 
 idx_t duckdb_column_count(duckdb_result *result) {
 	if (!result) {
 		return 0;
 	}
-	return result->__deprecated_column_count;
+	auto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);
+	return result_data.result->ColumnCount();
 }
 
 idx_t duckdb_row_count(duckdb_result *result) {
 	if (!result) {
 		return 0;
 	}
-	return result->__deprecated_row_count;
+	auto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);
+	auto &materialized = (duckdb::MaterializedQueryResult &)*result_data.result;
+	return materialized.collection.Count();
 }
 
 idx_t duckdb_rows_changed(duckdb_result *result) {
 	if (!result) {
 		return 0;
 	}
+	if (!duckdb::deprecated_materialize_result(result)) {
+		return 0;
+	}
 	return result->__deprecated_rows_changed;
 }
 
@@ -377,6 +428,9 @@ void *duckdb_column_data(duckdb_result *result, idx_t col) {
 	if (!result || col >= result->__deprecated_column_count) {
 		return nullptr;
 	}
+	if (!duckdb::deprecated_materialize_result(result)) {
+		return nullptr;
+	}
 	return result->__deprecated_columns[col].__deprecated_data;
 }
 
@@ -384,12 +438,48 @@ bool *duckdb_nullmask_data(duckdb_result *result, idx_t col) {
 	if (!result || col >= result->__deprecated_column_count) {
 		return nullptr;
 	}
+	if (!duckdb::deprecated_materialize_result(result)) {
+		return nullptr;
+	}
 	return result->__deprecated_columns[col].__deprecated_nullmask;
 }
 
-char *duckdb_result_error(duckdb_result *result) {
+const char *duckdb_result_error(duckdb_result *result) {
 	if (!result) {
 		return nullptr;
 	}
-	return result->__deprecated_error_message;
+	auto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);
+	return result_data.result->success ? nullptr : result_data.result->error.c_str();
+}
+
+idx_t duckdb_result_chunk_count(duckdb_result result) {
+	if (!result.internal_data) {
+		return 0;
+	}
+	auto &result_data = *((duckdb::DuckDBResultData *)result.internal_data);
+	if (result_data.result_set_type == duckdb::CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED) {
+		return 0;
+	}
+	D_ASSERT(result_data.result->type == duckdb::QueryResultType::MATERIALIZED_RESULT);
+	auto &materialized = (duckdb::MaterializedQueryResult &)*result_data.result;
+	return materialized.collection.ChunkCount();
+}
+
+duckdb_data_chunk duckdb_result_get_chunk(duckdb_result result, idx_t chunk_idx) {
+	if (!result.internal_data) {
+		return nullptr;
+	}
+	auto &result_data = *((duckdb::DuckDBResultData *)result.internal_data);
+	if (result_data.result_set_type == duckdb::CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED) {
+		return nullptr;
+	}
+	result_data.result_set_type = duckdb::CAPIResultSetType::CAPI_RESULT_TYPE_MATERIALIZED;
+	auto &materialized = (duckdb::MaterializedQueryResult &)*result_data.result;
+	if (chunk_idx >= materialized.collection.ChunkCount()) {
+		return nullptr;
+	}
+	auto chunk = duckdb::make_unique<duckdb::DataChunk>();
+	chunk->InitializeEmpty(materialized.collection.Types());
+	chunk->Reference(*materialized.collection.Chunks()[chunk_idx]);
+	return chunk.release();
 }
diff --git a/src/main/capi/table_function-c.cpp b/src/main/capi/table_function-c.cpp
new file mode 100644
index 000000000000..14cb6bdc8055
--- /dev/null
+++ b/src/main/capi/table_function-c.cpp
@@ -0,0 +1,351 @@
+#include "duckdb/main/capi_internal.hpp"
+#include "duckdb/function/table_function.hpp"
+#include "duckdb/parser/parsed_data/create_table_function_info.hpp"
+#include "duckdb/catalog/catalog.hpp"
+#include "duckdb/main/client_context.hpp"
+
+namespace duckdb {
+
+struct CTableFunctionInfo : public TableFunctionInfo {
+	~CTableFunctionInfo() {
+		if (extra_info && delete_callback) {
+			delete_callback(extra_info);
+		}
+		extra_info = nullptr;
+		delete_callback = nullptr;
+	}
+
+	duckdb_table_function_bind_t bind = nullptr;
+	duckdb_table_function_init_t init = nullptr;
+	duckdb_table_function_t function = nullptr;
+	void *extra_info = nullptr;
+	duckdb_delete_callback_t delete_callback = nullptr;
+};
+
+struct CTableBindData : public FunctionData {
+	~CTableBindData() {
+		if (bind_data && delete_callback) {
+			delete_callback(bind_data);
+		}
+		bind_data = nullptr;
+		delete_callback = nullptr;
+	}
+
+	CTableFunctionInfo *info = nullptr;
+	void *bind_data = nullptr;
+	duckdb_delete_callback_t delete_callback = nullptr;
+};
+
+struct CTableInternalBindInfo {
+	CTableInternalBindInfo(ClientContext &context, TableFunctionBindInput &input, vector<LogicalType> &return_types,
+	                       vector<string> &names, CTableBindData &bind_data, CTableFunctionInfo &function_info)
+	    : context(context), input(input), return_types(return_types), names(names), bind_data(bind_data),
+	      function_info(function_info), success(true) {
+	}
+
+	ClientContext &context;
+	TableFunctionBindInput &input;
+	vector<LogicalType> &return_types;
+	vector<string> &names;
+	CTableBindData &bind_data;
+	CTableFunctionInfo &function_info;
+	bool success;
+	string error;
+};
+
+struct CTableInitData : public FunctionOperatorData {
+	~CTableInitData() {
+		if (init_data && delete_callback) {
+			delete_callback(init_data);
+		}
+		init_data = nullptr;
+		delete_callback = nullptr;
+	}
+
+	void *init_data = nullptr;
+	duckdb_delete_callback_t delete_callback = nullptr;
+};
+
+struct CTableInternalInitInfo {
+	CTableInternalInitInfo(CTableBindData &bind_data, CTableInitData &init_data)
+	    : bind_data(bind_data), init_data(init_data), success(true) {
+	}
+
+	CTableBindData &bind_data;
+	CTableInitData &init_data;
+	bool success;
+	string error;
+};
+
+struct CTableInternalFunctionInfo {
+	CTableInternalFunctionInfo(CTableBindData &bind_data, CTableInitData &init_data)
+	    : bind_data(bind_data), init_data(init_data), success(true) {
+	}
+
+	CTableBindData &bind_data;
+	CTableInitData &init_data;
+	bool success;
+	string error;
+};
+
+unique_ptr<FunctionData> CTableFunctionBind(ClientContext &context, TableFunctionBindInput &input,
+                                            vector<LogicalType> &return_types, vector<string> &names) {
+	auto info = (CTableFunctionInfo *)input.info;
+	D_ASSERT(info->bind && info->function && info->init);
+	auto result = make_unique<CTableBindData>();
+	CTableInternalBindInfo bind_info(context, input, return_types, names, *result, *info);
+	info->bind(&bind_info);
+	if (!bind_info.success) {
+		throw Exception(bind_info.error);
+	}
+
+	result->info = info;
+	return move(result);
+}
+
+unique_ptr<FunctionOperatorData> CTableFunctionInit(ClientContext &context, const FunctionData *bind_data_p,
+                                                    const vector<column_t> &column_ids,
+                                                    TableFilterCollection *filters) {
+	auto &bind_data = (CTableBindData &)*bind_data_p;
+	auto result = make_unique<CTableInitData>();
+
+	CTableInternalInitInfo init_info(bind_data, *result);
+	bind_data.info->init(&init_info);
+	if (!init_info.success) {
+		throw Exception(init_info.error);
+	}
+	return move(result);
+}
+
+void CTableFunction(ClientContext &context, const FunctionData *bind_data_p, FunctionOperatorData *operator_state,
+                    DataChunk *input, DataChunk &output) {
+	auto &bind_data = (CTableBindData &)*bind_data_p;
+	auto &init_data = (CTableInitData &)*operator_state;
+	CTableInternalFunctionInfo function_info(bind_data, init_data);
+	bind_data.info->function(&function_info, &output);
+	if (!function_info.success) {
+		throw Exception(function_info.error);
+	}
+}
+
+} // namespace duckdb
+
+//===--------------------------------------------------------------------===//
+// Table Function
+//===--------------------------------------------------------------------===//
+duckdb_table_function duckdb_create_table_function() {
+	auto function = new duckdb::TableFunction("", {}, duckdb::CTableFunction, duckdb::CTableFunctionBind,
+	                                          duckdb::CTableFunctionInit);
+	function->function_info = duckdb::make_shared<duckdb::CTableFunctionInfo>();
+	return function;
+}
+
+void duckdb_destroy_table_function(duckdb_table_function *function) {
+	if (function && *function) {
+		auto tf = (duckdb::TableFunction *)*function;
+		delete tf;
+		*function = nullptr;
+	}
+}
+
+void duckdb_table_function_set_name(duckdb_table_function function, const char *name) {
+	if (!function || !name) {
+		return;
+	}
+	auto tf = (duckdb::TableFunction *)function;
+	tf->name = name;
+}
+
+void duckdb_table_function_add_parameter(duckdb_table_function function, duckdb_logical_type type) {
+	if (!function || !type) {
+		return;
+	}
+	auto tf = (duckdb::TableFunction *)function;
+	auto logical_type = (duckdb::LogicalType *)type;
+	tf->arguments.push_back(*logical_type);
+}
+
+void duckdb_table_function_set_extra_info(duckdb_table_function function, void *extra_info,
+                                          duckdb_delete_callback_t destroy) {
+	if (!function) {
+		return;
+	}
+	auto tf = (duckdb::TableFunction *)function;
+	auto info = (duckdb::CTableFunctionInfo *)tf->function_info.get();
+	info->extra_info = extra_info;
+	info->delete_callback = destroy;
+}
+
+void duckdb_table_function_set_bind(duckdb_table_function function, duckdb_table_function_bind_t bind) {
+	if (!function || !bind) {
+		return;
+	}
+	auto tf = (duckdb::TableFunction *)function;
+	auto info = (duckdb::CTableFunctionInfo *)tf->function_info.get();
+	info->bind = bind;
+}
+
+void duckdb_table_function_set_init(duckdb_table_function function, duckdb_table_function_init_t init) {
+	if (!function || !init) {
+		return;
+	}
+	auto tf = (duckdb::TableFunction *)function;
+	auto info = (duckdb::CTableFunctionInfo *)tf->function_info.get();
+	info->init = init;
+}
+
+void duckdb_table_function_set_function(duckdb_table_function table_function, duckdb_table_function_t function) {
+	if (!table_function || !function) {
+		return;
+	}
+	auto tf = (duckdb::TableFunction *)table_function;
+	auto info = (duckdb::CTableFunctionInfo *)tf->function_info.get();
+	info->function = function;
+}
+
+duckdb_state duckdb_register_table_function(duckdb_connection connection, duckdb_table_function function) {
+	if (!connection || !function) {
+		return DuckDBError;
+	}
+	auto con = (duckdb::Connection *)connection;
+	auto tf = (duckdb::TableFunction *)function;
+	auto info = (duckdb::CTableFunctionInfo *)tf->function_info.get();
+	if (tf->name.empty() || !info->bind || !info->init || !info->function) {
+		return DuckDBError;
+	}
+	con->context->RunFunctionInTransaction([&]() {
+		auto &catalog = duckdb::Catalog::GetCatalog(*con->context);
+		duckdb::CreateTableFunctionInfo tf_info(*tf);
+
+		// create the function in the catalog
+		catalog.CreateTableFunction(*con->context, &tf_info);
+	});
+	return DuckDBSuccess;
+}
+
+//===--------------------------------------------------------------------===//
+// Bind Interface
+//===--------------------------------------------------------------------===//
+void *duckdb_bind_get_extra_info(duckdb_bind_info info) {
+	if (!info) {
+		return nullptr;
+	}
+	auto bind_info = (duckdb::CTableInternalBindInfo *)info;
+	return bind_info->function_info.extra_info;
+}
+
+void duckdb_bind_add_result_column(duckdb_bind_info info, const char *name, duckdb_logical_type type) {
+	if (!info || !name || !type) {
+		return;
+	}
+	auto bind_info = (duckdb::CTableInternalBindInfo *)info;
+	bind_info->names.push_back(name);
+	bind_info->return_types.push_back(*((duckdb::LogicalType *)type));
+}
+
+idx_t duckdb_bind_get_parameter_count(duckdb_bind_info info) {
+	if (!info) {
+		return 0;
+	}
+	auto bind_info = (duckdb::CTableInternalBindInfo *)info;
+	return bind_info->input.inputs.size();
+}
+
+duckdb_value duckdb_bind_get_parameter(duckdb_bind_info info, idx_t index) {
+	if (!info || index >= duckdb_bind_get_parameter_count(info)) {
+		return nullptr;
+	}
+	auto bind_info = (duckdb::CTableInternalBindInfo *)info;
+	return new duckdb::Value(bind_info->input.inputs[index]);
+}
+
+void duckdb_bind_set_bind_data(duckdb_bind_info info, void *bind_data, duckdb_delete_callback_t destroy) {
+	if (!info) {
+		return;
+	}
+	auto bind_info = (duckdb::CTableInternalBindInfo *)info;
+	bind_info->bind_data.bind_data = bind_data;
+	bind_info->bind_data.delete_callback = destroy;
+}
+
+void duckdb_bind_set_error(duckdb_bind_info info, const char *error) {
+	if (!info || !error) {
+		return;
+	}
+	auto function_info = (duckdb::CTableInternalBindInfo *)info;
+	function_info->error = error;
+	function_info->success = false;
+}
+
+//===--------------------------------------------------------------------===//
+// Init Interface
+//===--------------------------------------------------------------------===//
+void *duckdb_init_get_extra_info(duckdb_init_info info) {
+	if (!info) {
+		return nullptr;
+	}
+	auto init_info = (duckdb::CTableInternalInitInfo *)info;
+	return init_info->bind_data.info->extra_info;
+}
+
+void *duckdb_init_get_bind_data(duckdb_init_info info) {
+	if (!info) {
+		return nullptr;
+	}
+	auto init_info = (duckdb::CTableInternalInitInfo *)info;
+	return init_info->bind_data.bind_data;
+}
+
+void duckdb_init_set_init_data(duckdb_init_info info, void *init_data, duckdb_delete_callback_t destroy) {
+	if (!info) {
+		return;
+	}
+	auto init_info = (duckdb::CTableInternalInitInfo *)info;
+	init_info->init_data.init_data = init_data;
+	init_info->init_data.delete_callback = destroy;
+}
+
+void duckdb_init_set_error(duckdb_init_info info, const char *error) {
+	if (!info || !error) {
+		return;
+	}
+	auto function_info = (duckdb::CTableInternalInitInfo *)info;
+	function_info->error = error;
+	function_info->success = false;
+}
+
+//===--------------------------------------------------------------------===//
+// Function Interface
+//===--------------------------------------------------------------------===//
+void *duckdb_function_get_extra_info(duckdb_function_info info) {
+	if (!info) {
+		return nullptr;
+	}
+	auto function_info = (duckdb::CTableInternalFunctionInfo *)info;
+	return function_info->bind_data.info->extra_info;
+}
+
+void *duckdb_function_get_bind_data(duckdb_function_info info) {
+	if (!info) {
+		return nullptr;
+	}
+	auto function_info = (duckdb::CTableInternalFunctionInfo *)info;
+	return function_info->bind_data.bind_data;
+}
+
+void *duckdb_function_get_init_data(duckdb_function_info info) {
+	if (!info) {
+		return nullptr;
+	}
+	auto function_info = (duckdb::CTableInternalFunctionInfo *)info;
+	return function_info->init_data.init_data;
+}
+
+void duckdb_function_set_error(duckdb_function_info info, const char *error) {
+	if (!info || !error) {
+		return;
+	}
+	auto function_info = (duckdb::CTableInternalFunctionInfo *)info;
+	function_info->error = error;
+	function_info->success = false;
+}
diff --git a/src/main/capi/value-c.cpp b/src/main/capi/value-c.cpp
index 284aaa2b38fa..e394ae56f471 100644
--- a/src/main/capi/value-c.cpp
+++ b/src/main/capi/value-c.cpp
@@ -154,6 +154,9 @@ RESULT_TYPE TryCastCInternal(duckdb_result *result, idx_t col, idx_t row) {
 }
 
 static bool CanFetchValue(duckdb_result *result, idx_t col, idx_t row) {
+	if (!duckdb::deprecated_materialize_result(result)) {
+		return false;
+	}
 	if (!result || col >= result->__deprecated_column_count || row >= result->__deprecated_row_count) {
 		return false;
 	}
@@ -240,8 +243,8 @@ int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row) {
 duckdb_decimal duckdb_value_decimal(duckdb_result *result, idx_t col, idx_t row) {
 	duckdb_decimal result_value;
 
-	auto column_data = (duckdb::DuckDBColumnData *)result->__deprecated_columns[col].internal_data;
-	column_data->type.GetDecimalProperties(result_value.width, result_value.scale);
+	auto result_data = (duckdb::DuckDBResultData *)result->internal_data;
+	result_data->result->types[col].GetDecimalProperties(result_value.width, result_value.scale);
 
 	auto internal_value = GetInternalCValue<hugeint_t>(result, col, row);
 	result_value.value.lower = internal_value.lower;
diff --git a/src/planner/binder/statement/bind_export.cpp b/src/planner/binder/statement/bind_export.cpp
index a4a6cdeb455a..f66f34a2661d 100644
--- a/src/planner/binder/statement/bind_export.cpp
+++ b/src/planner/binder/statement/bind_export.cpp
@@ -122,7 +122,7 @@ BoundStatement Binder::Bind(ExportStatement &stmt) {
 
 	BoundExportData exported_tables;
 
-	idx_t id = 0; // Id for table
+	unordered_set<string> table_name_index;
 	for (auto &table : tables) {
 		auto info = make_unique<CopyInfo>();
 		// we copy the options supplied to the EXPORT
@@ -131,16 +131,26 @@ BoundStatement Binder::Bind(ExportStatement &stmt) {
 		// set up the file name for the COPY TO
 
 		auto exported_data = ExportedTableData();
-		if (table->schema->name == DEFAULT_SCHEMA) {
-			info->file_path =
-			    fs.JoinPath(stmt.info->file_path,
-			                StringUtil::Format("%s_%s.%s", to_string(id), SanitizeExportIdentifier(table->name),
-			                                   copy_function->function.extension));
-		} else {
-			info->file_path = fs.JoinPath(
-			    stmt.info->file_path,
-			    StringUtil::Format("%s_%s_%s.%s", SanitizeExportIdentifier(table->schema->name), to_string(id),
-			                       SanitizeExportIdentifier(table->name), copy_function->function.extension));
+		idx_t id = 0;
+		while (true) {
+			string id_suffix = id == 0 ? string() : "_" + to_string(id);
+			if (table->schema->name == DEFAULT_SCHEMA) {
+				info->file_path = fs.JoinPath(stmt.info->file_path,
+				                              StringUtil::Format("%s%s.%s", SanitizeExportIdentifier(table->name),
+				                                                 id_suffix, copy_function->function.extension));
+			} else {
+				info->file_path =
+				    fs.JoinPath(stmt.info->file_path,
+				                StringUtil::Format("%s_%s%s.%s", SanitizeExportIdentifier(table->schema->name),
+				                                   SanitizeExportIdentifier(table->name), id_suffix,
+				                                   copy_function->function.extension));
+			}
+			if (table_name_index.find(info->file_path) == table_name_index.end()) {
+				// this name was not yet taken: take it
+				table_name_index.insert(info->file_path);
+				break;
+			}
+			id++;
 		}
 		info->is_from = false;
 		info->schema = table->schema->name;
diff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp
index ccebd1b31f9c..6ec382d7ae17 100644
--- a/src/planner/binder/tableref/bind_basetableref.cpp
+++ b/src/planner/binder/tableref/bind_basetableref.cpp
@@ -69,7 +69,7 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {
 		// table could not be found: try to bind a replacement scan
 		auto &config = DBConfig::GetConfig(context);
 		for (auto &scan : config.replacement_scans) {
-			auto replacement_function = scan.function(ref.table_name, scan.data);
+			auto replacement_function = scan.function(context, ref.table_name, scan.data.get());
 			if (replacement_function) {
 				replacement_function->alias = ref.alias.empty() ? ref.table_name : ref.alias;
 				replacement_function->column_name_alias = ref.column_name_alias;
diff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp
index 5f13518e824e..154b5d9d2f97 100644
--- a/src/planner/binder/tableref/bind_table_function.cpp
+++ b/src/planner/binder/tableref/bind_table_function.cpp
@@ -125,11 +125,19 @@ unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {
 	vector<LogicalType> return_types;
 	vector<string> return_names;
 	if (table_function.bind) {
-		bind_data = table_function.bind(context, parameters, named_parameters, input_table_types, input_table_names,
-		                                return_types, return_names);
+		TableFunctionBindInput bind_input(parameters, named_parameters, input_table_types, input_table_names,
+		                                  table_function.function_info.get());
+		bind_data = table_function.bind(context, bind_input, return_types, return_names);
+	}
+	if (return_types.size() != return_names.size()) {
+		throw InternalException(
+		    "Failed to bind \"%s\": Table function return_types and return_names must be of the same size",
+		    table_function.name);
+	}
+	if (return_types.empty()) {
+		throw InternalException("Failed to bind \"%s\": Table function must return at least one column",
+		                        table_function.name);
 	}
-	D_ASSERT(return_types.size() == return_names.size());
-	D_ASSERT(return_types.size() > 0);
 	// overwrite the names with any supplied aliases
 	for (idx_t i = 0; i < ref.column_name_alias.size() && i < return_names.size(); i++) {
 		return_names[i] = ref.column_name_alias[i];
diff --git a/tools/juliapkg/.JuliaFormatter.toml b/tools/juliapkg/.JuliaFormatter.toml
new file mode 100644
index 000000000000..9c42e1459705
--- /dev/null
+++ b/tools/juliapkg/.JuliaFormatter.toml
@@ -0,0 +1,7 @@
+margin = 120
+always_for_in = true
+whitespace_typedefs = true
+whitespace_ops_in_indices = true
+always_use_return = true
+annotate_untyped_fields_with_any = true
+trailing_comma = false
diff --git a/tools/juliapkg/.gitignore b/tools/juliapkg/.gitignore
new file mode 100644
index 000000000000..4fc652755ab5
--- /dev/null
+++ b/tools/juliapkg/.gitignore
@@ -0,0 +1,2 @@
+Manifest.toml
+
diff --git a/tools/juliapkg/Project.toml b/tools/juliapkg/Project.toml
new file mode 100644
index 000000000000..c4f7931487f8
--- /dev/null
+++ b/tools/juliapkg/Project.toml
@@ -0,0 +1,13 @@
+name = "DuckDB"
+uuid = "dc41c802-e0d0-4f5a-8bba-22eb8b17d8a4"
+authors = ["Mark Raasveldt <mark@duckdblabs.com", "Hannes Mhleisen <hannes@duckdblabs.com>"]
+version = "0.3.2"
+
+[deps]
+DBInterface = "a10d1c49-ce27-4219-8d33-6db1a4562965"
+DataFrames = "a93c6f00-e57d-5684-b7b6-d8193f3e46c0"
+Dates = "ade2ca70-3891-5945-98fb-dc099432e06a"
+DuckDB_jll = "2cbbab25-fc8b-58cf-88d4-687a02676033"
+Tables = "bd369af6-aec1-5ad0-b16a-f7cc5008161c"
+UUIDs = "cf7118a7-6976-5b1a-9a39-7adc72f591a4"
+WeakRefStrings = "ea10d353-3f73-51f8-a26c-33c1cb351aa5"
diff --git a/tools/juliapkg/README.md b/tools/juliapkg/README.md
new file mode 100644
index 000000000000..9fff0df317f1
--- /dev/null
+++ b/tools/juliapkg/README.md
@@ -0,0 +1,27 @@
+
+#### Installing the Package
+
+
+#### Formatting
+The format script must be run when changing anything. This can be done by running the following command from within the root directory of the project:
+
+```bash
+julia tools/juliapkg/scripts/format.jl
+```
+
+#### Testing
+
+You can run the tests using the `test.sh` script:
+
+```
+./test.sh
+```
+
+Specific test files can be run by adding the name of the file as an argument:
+
+```
+./test.sh test_connection.jl
+```
+
+#### Original Julia Connector
+Credits to kimmolinna for the [original DuckDB Julia connector](https://github.com/kimmolinna/DuckDB.jl).
\ No newline at end of file
diff --git a/tools/juliapkg/data/album.parquet b/tools/juliapkg/data/album.parquet
new file mode 100644
index 000000000000..b9c660f0cde5
Binary files /dev/null and b/tools/juliapkg/data/album.parquet differ
diff --git a/tools/juliapkg/data/artist.parquet b/tools/juliapkg/data/artist.parquet
new file mode 100644
index 000000000000..be7a49e4ac82
Binary files /dev/null and b/tools/juliapkg/data/artist.parquet differ
diff --git a/tools/juliapkg/data/customer.parquet b/tools/juliapkg/data/customer.parquet
new file mode 100644
index 000000000000..650ba7aff058
Binary files /dev/null and b/tools/juliapkg/data/customer.parquet differ
diff --git a/tools/juliapkg/data/employee.parquet b/tools/juliapkg/data/employee.parquet
new file mode 100644
index 000000000000..5a5f1feb1026
Binary files /dev/null and b/tools/juliapkg/data/employee.parquet differ
diff --git a/tools/juliapkg/data/genre.parquet b/tools/juliapkg/data/genre.parquet
new file mode 100644
index 000000000000..6950dae0eaeb
Binary files /dev/null and b/tools/juliapkg/data/genre.parquet differ
diff --git a/tools/juliapkg/data/invoice.parquet b/tools/juliapkg/data/invoice.parquet
new file mode 100644
index 000000000000..d6716e342b8f
Binary files /dev/null and b/tools/juliapkg/data/invoice.parquet differ
diff --git a/tools/juliapkg/data/invoiceline.parquet b/tools/juliapkg/data/invoiceline.parquet
new file mode 100644
index 000000000000..d5b66dd07aac
Binary files /dev/null and b/tools/juliapkg/data/invoiceline.parquet differ
diff --git a/tools/juliapkg/data/mediatype.parquet b/tools/juliapkg/data/mediatype.parquet
new file mode 100644
index 000000000000..44afb1bcfeb5
Binary files /dev/null and b/tools/juliapkg/data/mediatype.parquet differ
diff --git a/tools/juliapkg/data/playlist.parquet b/tools/juliapkg/data/playlist.parquet
new file mode 100644
index 000000000000..5229249bae81
Binary files /dev/null and b/tools/juliapkg/data/playlist.parquet differ
diff --git a/tools/juliapkg/data/playlisttrack.parquet b/tools/juliapkg/data/playlisttrack.parquet
new file mode 100644
index 000000000000..b95ad32e2833
Binary files /dev/null and b/tools/juliapkg/data/playlisttrack.parquet differ
diff --git a/tools/juliapkg/data/track.parquet b/tools/juliapkg/data/track.parquet
new file mode 100644
index 000000000000..f74f33d26bce
Binary files /dev/null and b/tools/juliapkg/data/track.parquet differ
diff --git a/tools/juliapkg/format.sh b/tools/juliapkg/format.sh
new file mode 100755
index 000000000000..c2db4d5c1dc7
--- /dev/null
+++ b/tools/juliapkg/format.sh
@@ -0,0 +1,4 @@
+set -e
+
+cd ../..
+julia tools/juliapkg/scripts/format.jl
\ No newline at end of file
diff --git a/tools/juliapkg/format_check.sh b/tools/juliapkg/format_check.sh
new file mode 100755
index 000000000000..f02dccd7d9eb
--- /dev/null
+++ b/tools/juliapkg/format_check.sh
@@ -0,0 +1,16 @@
+set -e
+
+if [[ $(git diff) ]]; then
+  echo "There are already differences prior to the format! Commit your changes prior to running format_check.sh"
+  exit 1
+fi
+
+./format.sh
+if [[ $(git diff) ]]; then
+    echo "Julia format found differences:"
+    git diff
+    exit 1
+else
+    echo "No differences found"
+    exit 0
+fi
diff --git a/tools/juliapkg/scripts/format.jl b/tools/juliapkg/scripts/format.jl
new file mode 100644
index 000000000000..ed0460d3ce75
--- /dev/null
+++ b/tools/juliapkg/scripts/format.jl
@@ -0,0 +1,4 @@
+using JuliaFormatter
+
+format("tools/juliapkg/src")
+format("tools/juliapkg/test")
\ No newline at end of file
diff --git a/tools/juliapkg/src/DuckDB.jl b/tools/juliapkg/src/DuckDB.jl
new file mode 100644
index 000000000000..15354e589ae1
--- /dev/null
+++ b/tools/juliapkg/src/DuckDB.jl
@@ -0,0 +1,35 @@
+module DuckDB
+
+using DBInterface
+using WeakRefStrings
+using Tables
+using Base.Libc
+using Dates
+using DataFrames
+using Tables
+using UUIDs
+
+export DBInterface, DuckDBException
+
+include("helper.jl")
+include("exceptions.jl")
+include("ctypes.jl")
+include("api.jl")
+include("logical_type.jl")
+include("value.jl")
+include("validity_mask.jl")
+include("vector.jl")
+include("data_chunk.jl")
+include("config.jl")
+include("database.jl")
+include("statement.jl")
+include("result.jl")
+include("transaction.jl")
+include("ddl.jl")
+include("appender.jl")
+include("table_function.jl")
+include("replacement_scan.jl")
+include("data_frame_scan.jl")
+include("old_interface.jl")
+
+end # module
diff --git a/tools/juliapkg/src/api.jl b/tools/juliapkg/src/api.jl
new file mode 100644
index 000000000000..59bed1ecf287
--- /dev/null
+++ b/tools/juliapkg/src/api.jl
@@ -0,0 +1,2445 @@
+using Base.Libc
+
+if "JULIA_DUCKDB_LIBRARY" in keys(ENV)
+    libduckdb = ENV["JULIA_DUCKDB_LIBRARY"]
+else
+    using DuckDB_jll
+end
+
+#=//===--------------------------------------------------------------------===//
+// Open/Connect
+//===--------------------------------------------------------------------===//
+=#
+"""
+	duckdb_open(path, out_database)
+Creates a new database or opens an existing database file stored at the the given path.
+If no path is given a new in-memory database is created instead.
+* `path`: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
+* `out_database`: The result database object.
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+"""
+function duckdb_open(path, out_database)
+    return ccall((:duckdb_open, libduckdb), duckdb_state, (Ptr{UInt8}, Ref{duckdb_database}), path, out_database)
+end
+"""
+	Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the the given path.
+
+    * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
+    * out_database: The result database object.
+    * config: (Optional) configuration used to start up the database system.
+    * out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.
+    Note that the error must be freed using `duckdb_free`.
+    * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+"""
+function duckdb_open_ext(path, out_database, config, out_error)
+    return ccall(
+        (:duckdb_open_ext, libduckdb),
+        duckdb_state,
+        (Ptr{UInt8}, Ref{duckdb_database}, duckdb_config, Ptr{Ptr{UInt8}}),
+        path,
+        out_database,
+        config,
+        out_error
+    )
+end
+"""
+	duckdb_close(database)
+Closes the specified database and de-allocates all memory allocated for that database.
+This should be called after you are done with any database allocated through `duckdb_open`.
+Note that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.
+Still it is recommended to always correctly close a database object after you are done with it.
+* `database`: The database object to shut down.
+"""
+function duckdb_close(database)
+    return ccall((:duckdb_close, libduckdb), Cvoid, (Ref{duckdb_database},), database)
+end
+"""
+	duckdb_connect(database, out_connection)
+Opens a connection to a database. Connections are required to query the database, and store transactional state
+associated with the connection.
+* `database`: The database file to connect to.
+* `out_connection`: The result connection object.
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+"""
+function duckdb_connect(database, out_connection)
+    return ccall(
+        (:duckdb_connect, libduckdb),
+        duckdb_state,
+        (duckdb_database, Ref{duckdb_connection}),
+        database,
+        out_connection
+    )
+end
+
+"""
+	duckdb_disconnect(connection)
+Closes the specified connection and de-allocates all memory allocated for that connection.
+* `connection`: The connection to close.
+"""
+function duckdb_disconnect(connection)
+    return ccall((:duckdb_disconnect, libduckdb), Cvoid, (Ref{duckdb_connection},), connection)
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Configuration
+//===--------------------------------------------------------------------===//
+=#
+
+"""
+	duckdb_create_config(config)
+Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance
+through `duckdb_open_ext`.
+This will always succeed unless there is a malloc failure.
+* `out_config`: The result configuration object.
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+"""
+function duckdb_create_config(config)
+    return ccall((:duckdb_create_config, libduckdb), duckdb_state, (Ref{duckdb_config},), config)
+end
+
+"""
+	duckdb_config_count()
+This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.
+This should not be called in a loop as it internally loops over all the options.
+* returns: The amount of config options available.
+"""
+function duckdb_config_count()
+    return ccall((:duckdb_config_count, libduckdb), Int32, ())
+end
+
+"""
+	duckdb_get_config_flag(index,out_name,out_description)
+Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.
+display configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).
+The result name or description MUST NOT be freed.
+* `index`: The index of the configuration option (between 0 and `duckdb_config_count`)
+* `out_name`: A name of the configuration flag.
+* `out_description`: A description of the configuration flag.
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+"""
+function duckdb_get_config_flag(index, out_name, out_description)
+    return ccall(
+        (:duckdb_get_config_flag, libduckdb),
+        duckdb_state,
+        (Int32, Ptr{Ptr{UInt8}}, Ptr{Ptr{UInt8}}),
+        index,
+        out_name,
+        out_description
+    )
+end
+
+"""
+	duckdb_set_config(config,name,option)
+Sets the specified option for the specified configuration. The configuration option is indicated by name.
+To obtain a list of config options, see `duckdb_get_config_flag`.
+In the source code, configuration options are defined in `config.cpp`.
+This can fail if either the name is invalid, or if the value provided for the option is invalid.
+* `duckdb_config`: The configuration object to set the option on.
+* `name`: The name of the configuration flag to set.
+* `option`: The value to set the configuration flag to.
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+"""
+function duckdb_set_config(config, name, option)
+    return ccall(
+        (:duckdb_set_config, libduckdb),
+        duckdb_state,
+        (duckdb_config, Ptr{UInt8}, Ptr{UInt8}),
+        config,
+        name,
+        option
+    )
+end
+
+"""
+	duckdb_destroy_config(config)
+Destroys the specified configuration option and de-allocates all memory allocated for the object.
+* `config`: The configuration object to destroy.
+"""
+function duckdb_destroy_config(config)
+    return ccall((:duckdb_destroy_config, libduckdb), Cvoid, (Ref{duckdb_config},), config)
+end
+
+# #=
+# //===--------------------------------------------------------------------===//
+# // Query Execution
+# //===--------------------------------------------------------------------===//
+# =#
+#
+# """
+# 	duckdb_query(connection,query,out_result)
+# Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.
+# If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
+# `duckdb_result_error`.
+# Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the
+# query fails, otherwise the error stored within the result will not be freed correctly.
+# * `connection`: The connection to perform the query in.
+# * `query`: The SQL query to run.
+# * `out_result`: The query result.
+# * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+# """
+# function duckdb_query(connection, query, out_result)
+#     return ccall(
+#         (:duckdb_query, libduckdb),
+#         Int32,
+#         (Ptr{Cvoid}, Ptr{UInt8}, Ptr{Cvoid}),
+#         connection[],
+#         query,
+#         out_result,
+#     )
+# end
+#
+"""
+	duckdb_destroy_result(result)
+Closes the result and de-allocates all memory allocated for that connection.
+* `result`: The result to destroy.
+"""
+function duckdb_destroy_result(result)
+    return ccall((:duckdb_destroy_result, libduckdb), Cvoid, (Ref{duckdb_result},), result)
+end
+
+"""
+	duckdb_column_name(result,col)
+Returns the column name of the specified column. The result should not need be freed; the column names will
+automatically be destroyed when the result is destroyed.
+Returns `NULL` if the column is out of range.
+* `result`: The result object to fetch the column name from.
+* `col`: The column index.
+* returns: The column name of the specified column.
+"""
+function duckdb_column_name(result, col)
+    return ccall((:duckdb_column_name, libduckdb), Ptr{UInt8}, (Ref{duckdb_result}, Int32), result, col - 1)
+end
+
+"""
+	duckdb_column_type(result,col)
+Returns the column type of the specified column.
+Returns `DUCKDB_TYPE_INVALID` if the column is out of range.
+* `result`: The result object to fetch the column type from.
+* `col`: The column index.
+* returns: The column type of the specified column.
+"""
+function duckdb_column_type(result, col)
+    return ccall((:duckdb_column_type, libduckdb), DUCKDB_TYPE, (Ref{duckdb_result}, Int32), result, col - 1)
+end
+
+"""
+Returns the logical column type of the specified column.
+
+The return type of this call should be destroyed with `duckdb_destroy_logical_type`.
+
+Returns `NULL` if the column is out of range.
+
+* result: The result object to fetch the column type from.
+* col: The column index.
+* returns: The logical column type of the specified column.
+"""
+function duckdb_column_logical_type(result, col)
+    return ccall(
+        (:duckdb_column_logical_type, libduckdb),
+        duckdb_logical_type,
+        (Ref{duckdb_result}, Int32),
+        result,
+        col - 1
+    )
+end
+
+"""
+	duckdb_column_count(result)
+Returns the number of columns present in a the result object.
+* `result`: The result object.
+* returns: The number of columns present in the result object.
+"""
+function duckdb_column_count(result)
+    return ccall((:duckdb_column_count, libduckdb), Int32, (Ref{duckdb_result},), result)
+end
+
+"""
+	duckdb_row_count(result)
+Returns the number of rows present in a the result object.
+* `result`: The result object.
+* returns: The number of rows present in the result object.
+"""
+function duckdb_row_count(result)
+    return ccall((:duckdb_row_count, libduckdb), Int64, (Ref{duckdb_result},), result)
+end
+
+"""
+	duckdb_rows_changed(result)
+Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE
+queries. For other queries the rows_changed will be 0.
+* `result`: The result object.
+* returns: The number of rows changed.
+"""
+function duckdb_rows_changed(result)
+    return ccall((:duckdb_rows_changed, libduckdb), Int64, (Ptr{Cvoid},), result)
+end
+
+"""
+	duckdb_column_data(result,col)
+Returns the data of a specific column of a result in columnar format. This is the fastest way of accessing data in a
+query result, as no conversion or type checking must be performed (outside of the original switch). If performance
+is a concern, it is recommended to use this API over the `duckdb_value` functions.
+The function returns a dense array which contains the result data. The exact type stored in the array depends on the
+corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
+accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.
+For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:
+```c
+int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
+printf("Data for row %d: %d\
", row, data[row]);
+```
+* `result`: The result object to fetch the column data from.
+* `col`: The column index.
+* returns: The column data of the specified column.
+"""
+function duckdb_column_data(result, col)
+    return ccall((:duckdb_column_data, libduckdb), Ptr{Cvoid}, (Ref{duckdb_result}, Int32), result, col - 1)
+end
+
+"""
+	duckdb_nullmask_data(result,col)
+Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
+whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
+by `duckdb_column_data` are undefined.
+```c
+int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
+bool *nullmask = duckdb_nullmask_data(&result, 0);
+if (nullmask[row]) {
+    printf("Data for row %d: NULL
", row);
+} else {
+    printf("Data for row %d: %d
", row, data[row]);
+}
+```
+* `result`: The result object to fetch the nullmask from.
+* `col`: The column index.
+* returns: The nullmask of the specified column.
+"""
+function duckdb_nullmask_data(result, col)
+    return ccall((:duckdb_nullmask_data, libduckdb), Ptr{Int32}, (Ref{duckdb_result}, Int32), result, col - 1)
+end
+
+"""
+	duckdb_result_error(result)
+Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.
+The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.
+* `result`: The result object to fetch the nullmask from.
+* returns: The error of the result.
+"""
+function duckdb_result_error(result)
+    return ccall((:duckdb_result_error, libduckdb), Ptr{UInt8}, (Ref{duckdb_result},), result)
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Result Functions
+//===--------------------------------------------------------------------===//
+=#
+
+"""
+Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.
+
+This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data` functions.
+It results in significantly better performance, and should be preferred in newer code-bases.
+
+If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be mixed with the legacy result functions).
+
+Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.
+
+* result: The result object to fetch the data chunk from.
+* chunk_index: The chunk index to fetch from.
+* returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
+"""
+function duckdb_result_get_chunk(result, chunk_index)
+    return ccall(
+        (:duckdb_result_get_chunk, libduckdb),
+        duckdb_data_chunk,
+        (duckdb_result, UInt64),
+        result,
+        chunk_index - 1
+    )
+end
+
+"""
+Returns the number of data chunks present in the result.
+
+* result: The result object
+* returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
+"""
+function duckdb_result_chunk_count(result)
+    return ccall((:duckdb_result_chunk_count, libduckdb), UInt64, (duckdb_result,), result)
+end
+
+
+"""
+	duckdb_value_boolean(result,col,row)
+* returns: The boolean value at the specified location, or false if the value cannot be converted.
+"""
+function duckdb_value_boolean(result, col, row)
+    return ccall(
+        (:duckdb_value_boolean, libduckdb),
+        Int32,
+        (Ref{duckdb_result}, Int32, Int32),
+        result,
+        col - 1,
+        row - 1
+    )
+end
+
+"""
+	duckdb_value_int8(result,col,row)
+* returns: The int8_t value at the specified location, or 0 if the value cannot be converted.
+"""
+function duckdb_value_int8(result, col, row)
+    return ccall((:duckdb_value_int8, libduckdb), Int8, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
+end
+
+"""
+	duckdb_value_int16(result,col,row)
+ * returns: The int16_t value at the specified location, or 0 if the value cannot be converted.
+"""
+function duckdb_value_int16(result, col, row)
+    return ccall((:duckdb_value_int16, libduckdb), Int16, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
+end
+
+"""
+	duckdb_value_int32(result,col,row)
+ * returns: The int32_t value at the specified location, or 0 if the value cannot be converted.
+"""
+function duckdb_value_int32(result, col, row)
+    return ccall((:duckdb_value_int32, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
+end
+
+"""
+	duckdb_value_int64(result,col,row)
+ * returns: The int64_t value at the specified location, or 0 if the value cannot be converted.
+"""
+function duckdb_value_int64(result, col, row)
+    return ccall((:duckdb_value_int64, libduckdb), Int64, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
+end
+
+"""
+	duckdb_value_hugeint(result,col,row)
+ * returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.
+"""
+function duckdb_value_hugeint(result, col, row)
+    return ccall(
+        (:duckdb_value_hugeint, libduckdb),
+        Int64,
+        (Ref{duckdb_result}, Int32, Int32),
+        result,
+        col - 1,
+        row - 1
+    )
+end
+
+"""
+	duckdb_value_uint8(result,col,row)
+ * returns: The uint8_t value at the specified location, or 0 if the value cannot be converted.
+
+"""
+function duckdb_value_uint8(result, col, row)
+    return ccall((:duckdb_value_uint8, libduckdb), UInt8, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
+end
+
+"""
+	duckdb_value_uint16(result,col,row)
+ * returns: The uint16_t value at the specified location, or 0 if the value cannot be converted.
+"""
+function duckdb_value_uint16(result, col, row)
+    return ccall(
+        (:duckdb_value_uint16, libduckdb),
+        UInt16,
+        (Ref{duckdb_result}, Int32, Int32),
+        result,
+        col - 1,
+        row - 1
+    )
+end
+
+"""
+	duckdb_value_uint32(result,col,row)
+ * returns: The uint32_t value at the specified location, or 0 if the value cannot be converted.
+"""
+function duckdb_value_uint32(result, col, row)
+    return ccall(
+        (:duckdb_value_uint32, libduckdb),
+        UInt32,
+        (Ref{duckdb_result}, Int32, Int32),
+        result,
+        col - 1,
+        row - 1
+    )
+end
+
+"""
+	duckdb_value_uint64(result,col,row)
+* returns: The uint64_t value at the specified location, or 0 if the value cannot be converted.
+"""
+function duckdb_value_uint64(result, col, row)
+    return ccall(
+        (:duckdb_value_uint64, libduckdb),
+        UInt64,
+        (Ref{duckdb_result}, Int32, Int32),
+        result,
+        col - 1,
+        row - 1
+    )
+end
+
+"""
+	duckdb_value_float(result,col,row)
+ * returns: The float value at the specified location, or 0 if the value cannot be converted.
+"""
+function duckdb_value_float(result, col, row)
+    return ccall(
+        (:duckdb_value_float, libduckdb),
+        Float32,
+        (Ref{duckdb_result}, Int32, Int32),
+        result,
+        col - 1,
+        row - 1
+    )
+end
+
+"""
+	duckdb_value_double(result,col,row)
+ * returns: The double value at the specified location, or 0 if the value cannot be converted.
+"""
+function duckdb_value_double(result, col, row)
+    return ccall(
+        (:duckdb_value_double, libduckdb),
+        Float64,
+        (Ref{duckdb_result}, Int32, Int32),
+        result,
+        col - 1,
+        row - 1
+    )
+end
+
+"""
+duckdb_value_date(result,col,row)
+ * returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted.
+DUCKDB_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);
+"""
+function duckdb_value_date(result, col, row)
+    return ccall((:duckdb_value_date, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
+end
+
+"""
+duckdb_value_time(result,col,row)
+ * returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted.
+DUCKDB_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);
+"""
+function duckdb_value_time(result, col, row)
+    return ccall((:duckdb_value_time, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
+end
+
+"""
+duckdb_value_timestamp(result,col,row)
+ * returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.
+DUCKDB_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);
+"""
+function duckdb_value_timestamp(result, col, row)
+    return ccall(
+        (:duckdb_value_timestamp, libduckdb),
+        Int32,
+        (Ref{duckdb_result}, Int32, Int32),
+        result,
+        col - 1,
+        row - 1
+    )
+end
+
+"""
+duckdb_value_interval(result,col,row)
+ * returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted.
+DUCKDB_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);
+"""
+function duckdb_value_interval(result, col, row)
+    return ccall(
+        (:duckdb_value_interval, libduckdb),
+        Int32,
+        (Ref{duckdb_result}, Int32, Int32),
+        result,
+        col - 1,
+        row - 1
+    )
+end
+
+"""
+duckdb_value_varchar(result,col,row)
+* returns: The char* value at the specified location, or nullptr if the value cannot be converted.
+The result must be freed with `duckdb_free`.
+DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);
+"""
+function duckdb_value_varchar(result, col, row)
+    return ccall(
+        (:duckdb_value_varchar, libduckdb),
+        Ptr{UInt8},
+        (Ref{duckdb_result}, Int32, Int32),
+        result,
+        col - 1,
+        row - 1
+    )
+end
+
+"""
+duckdb_value_varchar_internal(result,col,row)
+* returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
+If the column is NOT a VARCHAR column this function will return NULL.
+The result must NOT be freed.
+DUCKDB_API char *duckdb_value_varchar_internal(duckdb_result *result, idx_t col, idx_t row);
+"""
+function duckdb_value_varchar_internal(result, col, row)
+    return ccall(
+        (:duckdb_value_varchar_internal, libduckdb),
+        Ptr{UInt8},
+        (Ref{duckdb_result}, Int32, Int32),
+        result,
+        col - 1,
+        row - 1
+    )
+end
+
+# """
+# duckdb_value_blob(result,col,row)
+# * returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the
+# value cannot be converted. The resulting "blob.data" must be freed with `duckdb_free.`
+# DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);
+# """
+# function duckdb_value_blob(result, col, row)
+#     return ccall(
+#         (:duckdb_value_blob, libduckdb),
+#         Ptr{Cvoid},
+#         (Ptr{Cvoid}, Int32, Int32),
+#         result,
+#         col - 1,
+#         row - 1,
+#     )
+# end
+
+"""
+duckdb_value_is_null(result,col,row)
+ * returns: Returns true if the value at the specified index is NULL, and false otherwise.
+DUCKDB_API bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row);
+"""
+function duckdb_value_is_null(result, col, row)
+    return ccall((:duckdb_value_is_null, libduckdb), Bool, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Helpers
+//===--------------------------------------------------------------------===//
+=#
+
+
+"""
+duckdb_malloc(size)
+
+Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner
+should be freed using `duckdb_free`.
+* size: The number of bytes to allocate.
+* returns: A pointer to the allocated memory region.
+DUCKDB_API void *duckdb_malloc(size_t size);
+"""
+function duckdb_malloc(size)
+    return ccall((:duckdb_malloc, libduckdb), Cvoid, (Csize_t,), size)
+end
+
+"""
+duckdb_free(ptr)
+Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_value_blob`.
+* ptr: The memory region to de-allocate.
+DUCKDB_API void duckdb_free(void *ptr);
+"""
+function duckdb_free(ptr)
+    return ccall((:duckdb_malloc, libduckdb), Cvoid, (Ptr{Cvoid},), ptr)
+end
+
+"""
+The internal vector size used by DuckDB.
+This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.
+
+* returns: The vector size.
+"""
+function duckdb_vector_size()
+    return ccall((:duckdb_vector_size, libduckdb), UInt64, ())
+end
+
+# #=
+# //===--------------------------------------------------------------------===//
+# // Date/Time/Timestamp Helpers
+# //===--------------------------------------------------------------------===//
+# =#
+#
+#
+# """
+# duckdb_from_date(date)
+# Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).
+# * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
+# * returns: The `duckdb_date_struct` with the decomposed elements.
+# DUCKDB_API duckdb_date_struct duckdb_from_date(duckdb_date date);
+# """
+# function duckdb_from_date(date)
+#     return ccall((:duckdb_from_date, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), date)
+# end
+#
+# """
+# duckdb_to_date(date)
+# Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).
+# * date: The year, month and date stored in a `duckdb_date_struct`.
+# * returns: The `duckdb_date` element.
+# DUCKDB_API duckdb_date duckdb_to_date(duckdb_date_struct date);
+# """
+# function duckdb_to_date(date)
+#     return ccall((:duckdb_to_date, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), date)
+# end
+#
+# """
+# duckdb_from_time(time)
+# Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).
+# * time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.
+# * returns: The `duckdb_time_struct` with the decomposed elements.
+# DUCKDB_API duckdb_time_struct duckdb_from_time(duckdb_time time);
+# """
+# function duckdb_from_time(time)
+#     return ccall((:duckdb_from_time, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), time)
+# end
+#
+# """
+# duckdb_to_time(time)
+# Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).
+# * time: The hour, minute, second and microsecond in a `duckdb_time_struct`.
+# * returns: The `duckdb_time` element.
+# DUCKDB_API duckdb_time duckdb_to_time(duckdb_time_struct time);
+# """
+# function duckdb_to_time(time)
+#     return ccall((:duckdb_to_time, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), time)
+# end
+#
+# """
+# duckdb_from_timestamp(ts)
+# Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.
+# * ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
+# * returns: The `duckdb_timestamp_struct` with the decomposed elements.
+# DUCKDB_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts);
+# """
+# function duckdb_from_timestamp(ts)
+#     return ccall((:duckdb_from_timestamp, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), ts)
+# end
+#
+# """
+# duckdb_to_timestamp(ts)
+# Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.
+# * ts: The de-composed elements in a `duckdb_timestamp_struct`.
+# * returns: The `duckdb_timestamp` element.
+# */
+# DUCKDB_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts);
+# """
+# function duckdb_to_timestamp(ts)
+#     return ccall((:duckdb_to_timestamp, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), ts)
+# end
+#
+# #=
+# //===--------------------------------------------------------------------===//
+# // Hugeint Helpers
+# //===--------------------------------------------------------------------===//
+# =#
+#
+#
+# """
+# duckdb_hugeint_to_double(val)
+# Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.
+# * val: The hugeint value.
+# * returns: The converted `double` element.
+# DUCKDB_API double duckdb_hugeint_to_double(duckdb_hugeint val);
+# """
+# function duckdb_hugeint_to_double(val)
+#     return ccall((:duckdb_hugeint_to_double, libduckdb), Float64, (Int64,), val)
+# end
+#
+# """
+# duckdb_double_to_hugeint(val)
+# Converts a double value to a duckdb_hugeint object.
+# If the conversion fails because the double value is too big the result will be 0.
+# * val: The double value.
+# * returns: The converted `duckdb_hugeint` element.
+# DUCKDB_API duckdb_hugeint duckdb_double_to_hugeint(double val);
+# """
+# function duckdb_double_to_hugeint(val)
+#     return ccall((:duckdb_double_to_hugeint, libduckdb), Int64, (Float64,), val)
+# end
+#
+# #=
+# //===--------------------------------------------------------------------===//
+# // Prepared Statements
+# //===--------------------------------------------------------------------===//
+# // A prepared statement is a parameterized query that allows you to bind parameters to it.
+# // * This is useful to easily supply parameters to functions and avoid SQL injection attacks.
+# // * This is useful to speed up queries that you will execute several times with different parameters.
+# // Because the query will only be parsed, bound, optimized and planned once during the prepare stage,
+# // rather than once per execution.
+# // For example:
+# //   SELECT * FROM tbl WHERE id=?
+# // Or a query with multiple parameters:
+# //   SELECT * FROM tbl WHERE id=$1 OR name=$2
+# =#
+
+
+"""
+Create a prepared statement object from a query.
+Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using
+`duckdb_destroy_prepare`, even if the prepare fails.
+If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
+* connection: The connection object
+* query: The SQL query to prepare
+* out_prepared_statement: The resulting prepared statement object
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
+                                       duckdb_prepared_statement *out_prepared_statement);
+"""
+function duckdb_prepare(connection, query, out_prepared_statement)
+    return ccall(
+        (:duckdb_prepare, libduckdb),
+        duckdb_state,
+        (duckdb_connection, Ptr{UInt8}, Ref{duckdb_prepared_statement}),
+        connection,
+        query,
+        out_prepared_statement
+    )
+end
+
+"""
+Closes the prepared statement and de-allocates all memory allocated for that connection.
+* prepared_statement: The prepared statement to destroy.
+DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);
+"""
+function duckdb_destroy_prepare(prepared_statement)
+    return ccall((:duckdb_destroy_prepare, libduckdb), Cvoid, (Ref{duckdb_prepared_statement},), prepared_statement)
+end
+
+"""
+Returns the error message associated with the given prepared statement.
+If the prepared statement has no error message, this returns `nullptr` instead.
+The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.
+* prepared_statement: The prepared statement to obtain the error from.
+* returns: The error message, or `nullptr` if there is none.
+DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);
+"""
+function duckdb_prepare_error(prepared_statement)
+    return ccall((:duckdb_prepare_error, libduckdb), Ptr{UInt8}, (duckdb_prepared_statement,), prepared_statement[])
+end
+
+"""
+Returns the number of parameters that can be provided to the given prepared statement.
+Returns 0 if the query was not successfully prepared.
+* prepared_statement: The prepared statement to obtain the number of parameters for.
+DUCKDB_API idx_t duckdb_nparams(duckdb_prepared_statement prepared_statement);
+"""
+function duckdb_nparams(prepared_statement)
+    return ccall((:duckdb_nparams, libduckdb), Int32, (duckdb_prepared_statement,), prepared_statement)
+end
+
+"""
+Returns the parameter type for the parameter at the given index.
+Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.
+* prepared_statement: The prepared statement.
+* param_idx: The parameter index.
+* returns: The parameter type
+DUCKDB_API duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_t param_idx);
+"""
+function duckdb_param_type(prepared_statement, param_idx)
+    return ccall(
+        (:duckdb_param_type, libduckdb),
+        Int32,
+        (duckdb_prepared_statement, Int32),
+        prepared_statement,
+        param_idx
+    )
+end
+
+"""
+Binds a bool value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);
+"""
+function duckdb_bind_boolean(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_boolean, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Int32),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds an int8_t value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
+"""
+function duckdb_bind_int8(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_int8, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Int8),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds an int16_t value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
+"""
+function duckdb_bind_int16(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_int16, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Int16),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds an int32_t value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);
+"""
+function duckdb_bind_int32(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_int32, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Int32),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds an int64_t value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);
+"""
+function duckdb_bind_int64(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_int64, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Int64),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds an duckdb_hugeint value to the prepared statement at the specified index.
+*/
+DUCKDB_API duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                            duckdb_hugeint val);
+"""
+function duckdb_bind_hugeint(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_hugeint, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, duckdb_hugeint),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds an uint8_t value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);
+"""
+function duckdb_bind_uint8(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_uint8, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, UInt8),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds an uint16_t value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val);
+"""
+function duckdb_bind_uint16(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_uint16, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, UInt16),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds an uint32_t value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);
+"""
+function duckdb_bind_uint32(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_uint32, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, UInt32),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds an uint64_t value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);
+"""
+function duckdb_bind_uint64(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_uint64, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, UInt64),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds an float value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);
+"""
+function duckdb_bind_float(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_float, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Float32),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds an double value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);
+"""
+function duckdb_bind_double(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_double, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Float64),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds a duckdb_date value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                         duckdb_date val);
+"""
+function duckdb_bind_date(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_date, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Int32),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds a duckdb_time value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                         duckdb_time val);
+"""
+function duckdb_bind_time(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_time, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Int64),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds a duckdb_timestamp value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                              duckdb_timestamp val);
+"""
+function duckdb_bind_timestamp(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_timestamp, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Int64),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds a duckdb_interval value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                             duckdb_interval val);
+"""
+function duckdb_bind_interval(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_interval, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Int32),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds a null-terminated varchar value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                            const char *val);
+"""
+function duckdb_bind_varchar(prepared_statement, param_idx, val)
+    return ccall(
+        (:duckdb_bind_varchar, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Ptr{UInt8}),
+        prepared_statement,
+        param_idx,
+        val
+    )
+end
+
+"""
+Binds a varchar value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                                   const char *val, idx_t length);
+"""
+function duckdb_bind_varchar_length(prepared_statement, param_idx, val, length)
+    return ccall(
+        (:duckdb_bind_varchar_length, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Ptr{UInt8}, Int32),
+        prepared_statement,
+        param_idx,
+        val,
+        length
+    )
+end
+
+"""
+Binds a blob value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                         const void *data, idx_t length);
+"""
+function duckdb_bind_blob(prepared_statement, param_idx, val, length)
+    return ccall(
+        (:duckdb_bind_blob, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32, Ptr{Cvoid}, Int32),
+        prepared_statement,
+        param_idx,
+        data,
+        length
+    )
+end
+
+"""
+Binds a NULL value to the prepared statement at the specified index.
+DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);
+"""
+function duckdb_bind_null(prepared_statement, param_idx)
+    return ccall(
+        (:duckdb_bind_null, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Int32),
+        prepared_statement,
+        param_idx
+    )
+end
+
+"""
+Executes the prepared statement with the given bound parameters, and returns a materialized query result.
+This method can be called multiple times for each prepared statement, and the parameters can be modified
+between calls to this function.
+* prepared_statement: The prepared statement to execute.
+* out_result: The query result.
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,
+                                                duckdb_result *out_result);
+"""
+function duckdb_execute_prepared(prepared_statement, out_result)
+    return ccall(
+        (:duckdb_execute_prepared, libduckdb),
+        duckdb_state,
+        (duckdb_prepared_statement, Ref{duckdb_result}),
+        prepared_statement,
+        out_result
+    )
+end
+
+# """
+# Executes the prepared statement with the given bound parameters, and returns an arrow query result.
+# * prepared_statement: The prepared statement to execute.
+# * out_result: The query result.
+# * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+# DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,
+#                                                       duckdb_arrow *out_result);
+# """
+# function duckdb_execute_prepared_arrow(prepared_statement, out_result)
+#     return ccall(
+#         (:duckdb_execute_prepared_arrow, libduckdb),
+#         duckdb_state,
+#         (Ptr{Cvoid}, Ptr{Cvoid}),
+#         prepared_statement,
+#         out_result,
+#     )
+# end
+
+
+#=
+//===--------------------------------------------------------------------===//
+// Value Interface
+//===--------------------------------------------------------------------===//
+=#
+"""
+Destroys the value and de-allocates all memory allocated for that type.
+
+* value: The value to destroy.
+"""
+function duckdb_destroy_value(handle)
+    return ccall((:duckdb_destroy_value, libduckdb), Cvoid, (Ref{duckdb_value},), handle)
+end
+
+"""
+Creates a value from a string
+
+* value: The varchar value
+* returns: The value. This must be destroyed with `duckdb_destroy_value`.
+"""
+function duckdb_create_varchar(handle)
+    return ccall((:duckdb_create_varchar, libduckdb), duckdb_value, (Ptr{UInt8},), handle)
+end
+
+"""
+Creates a value from an int64
+
+* value: The bigint value
+* returns: The value. This must be destroyed with `duckdb_destroy_value`.
+"""
+function duckdb_create_int64(handle)
+    return ccall((:duckdb_create_int64, libduckdb), duckdb_value, (Int64,), handle)
+end
+
+"""
+Obtains a string representation of the given value.
+The result must be destroyed with `duckdb_free`.
+
+* value: The value
+* returns: The string value. This must be destroyed with `duckdb_free`.
+"""
+function duckdb_get_varchar(handle)
+    return ccall((:duckdb_get_varchar, libduckdb), Ptr{UInt8}, (duckdb_value,), handle)
+end
+
+"""
+Obtains an int64 of the given value.
+
+* value: The value
+* returns: The int64 value, or 0 if no conversion is possible
+"""
+function duckdb_get_int64(handle)
+    return ccall((:duckdb_get_int64, libduckdb), Int64, (duckdb_value,), handle)
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Logical Type Interface
+//===--------------------------------------------------------------------===//
+=#
+"""
+Creates a `duckdb_logical_type` from a standard primitive type.
+The resulting type should be destroyed with `duckdb_destroy_logical_type`.
+
+This should not be used with `DUCKDB_TYPE_DECIMAL`.
+
+* type: The primitive type to create.
+* returns: The logical type type.
+"""
+function duckdb_create_logical_type(type)
+    return ccall((:duckdb_create_logical_type, libduckdb), duckdb_logical_type, (Int32,), type)
+end
+
+"""
+Retrieves the type class of a `duckdb_logical_type`.
+
+* type: The logical type object
+* returns: The type id
+"""
+function duckdb_get_type_id(handle)
+    return ccall((:duckdb_get_type_id, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)
+end
+
+"""
+Retrieves the width of a decimal type.
+
+* type: The logical type object
+* returns: The width of the decimal type
+"""
+function duckdb_decimal_width(handle)
+    return ccall((:duckdb_decimal_width, libduckdb), UInt8, (duckdb_logical_type,), handle)
+end
+
+"""
+Retrieves the scale of a decimal type.
+
+* type: The logical type object
+* returns: The scale of the decimal type
+"""
+function duckdb_decimal_scale(handle)
+    return ccall((:duckdb_decimal_scale, libduckdb), UInt8, (duckdb_logical_type,), handle)
+end
+
+"""
+Retrieves the internal storage type of a decimal type.
+
+* type: The logical type object
+* returns: The internal type of the decimal type
+"""
+function duckdb_decimal_internal_type(handle)
+    return ccall((:duckdb_decimal_internal_type, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)
+end
+
+"""
+Retrieves the internal storage type of an enum type.
+
+* type: The logical type object
+* returns: The internal type of the enum type
+"""
+function duckdb_enum_internal_type(handle)
+    return ccall((:duckdb_enum_internal_type, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)
+end
+
+"""
+Retrieves the dictionary size of the enum type
+
+* type: The logical type object
+* returns: The dictionary size of the enum type
+"""
+function duckdb_enum_dictionary_size(handle)
+    return ccall((:duckdb_enum_dictionary_size, libduckdb), UInt32, (duckdb_logical_type,), handle)
+end
+
+"""
+Retrieves the dictionary value at the specified position from the enum.
+
+The result must be freed with `duckdb_free`
+
+* type: The logical type object
+* index: The index in the dictionary
+* returns: The string value of the enum type. Must be freed with `duckdb_free`.
+"""
+function duckdb_enum_dictionary_value(handle, index)
+    return ccall(
+        (:duckdb_enum_dictionary_value, libduckdb),
+        Ptr{UInt8},
+        (duckdb_logical_type, UInt64),
+        handle,
+        index - 1
+    )
+end
+
+"""
+Retrieves the child type of the given list type.
+
+The result must be freed with `duckdb_destroy_logical_type`
+
+* type: The logical type object
+* returns: The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`.
+"""
+function duckdb_list_type_child_type(handle)
+    return ccall((:duckdb_list_type_child_type, libduckdb), duckdb_logical_type, (duckdb_logical_type,), handle)
+end
+
+"""
+Returns the number of children of a struct type.
+
+* type: The logical type object
+* returns: The number of children of a struct type.
+"""
+function duckdb_struct_type_child_count(handle)
+    return ccall((:duckdb_struct_type_child_count, libduckdb), UInt64, (duckdb_logical_type,), handle)
+end
+
+"""
+Retrieves the name of the struct child.
+
+The result must be freed with `duckdb_free`
+
+* type: The logical type object
+* index: The child index
+* returns: The name of the struct type. Must be freed with `duckdb_free`.
+"""
+function duckdb_struct_type_child_name(handle, index)
+    return ccall(
+        (:duckdb_struct_type_child_name, libduckdb),
+        Ptr{UInt8},
+        (duckdb_logical_type, UInt64),
+        handle,
+        index - 1
+    )
+end
+
+"""
+Retrieves the child type of the given struct type at the specified index.
+
+The result must be freed with `duckdb_destroy_logical_type`
+
+* type: The logical type object
+* index: The child index
+* returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.
+"""
+function duckdb_struct_type_child_type(handle, index)
+    return ccall(
+        (:duckdb_struct_type_child_type, libduckdb),
+        duckdb_logical_type,
+        (duckdb_logical_type, UInt64),
+        handle,
+        index - 1
+    )
+end
+
+"""
+Destroys the logical type and de-allocates all memory allocated for that type.
+
+* type: The logical type to destroy.
+"""
+function duckdb_destroy_logical_type(handle)
+    return ccall((:duckdb_destroy_logical_type, libduckdb), Cvoid, (Ref{duckdb_logical_type},), handle)
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Data Chunk Interface
+//===--------------------------------------------------------------------===//
+=#
+"""
+Creates an empty DataChunk with the specified set of types.
+
+* types: An array of types of the data chunk.
+* column_count: The number of columns.
+* returns: The data chunk.
+"""
+function duckdb_create_data_chunk(types, column_count)
+    return ccall(
+        (:duckdb_create_data_chunk, libduckdb),
+        duckdb_data_chunk,
+        (Ptr{duckdb_logical_type}, UInt64),
+        types,
+        column_count
+    )
+end
+
+"""
+Destroys the data chunk and de-allocates all memory allocated for that chunk.
+
+* chunk: The data chunk to destroy.
+"""
+function duckdb_destroy_data_chunk(chunk)
+    return ccall((:duckdb_destroy_data_chunk, libduckdb), Cvoid, (Ref{duckdb_data_chunk},), chunk)
+end
+
+"""
+Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.
+
+* chunk: The data chunk to reset.
+"""
+function duckdb_data_chunk_reset(chunk)
+    return ccall((:duckdb_data_chunk_reset, libduckdb), Cvoid, (duckdb_data_chunk,), chunk)
+end
+
+"""
+Retrieves the number of columns in a data chunk.
+
+* chunk: The data chunk to get the data from
+* returns: The number of columns in the data chunk
+"""
+function duckdb_data_chunk_get_column_count(chunk)
+    return ccall((:duckdb_data_chunk_get_column_count, libduckdb), UInt64, (duckdb_data_chunk,), chunk)
+end
+
+
+"""
+Retrieves the current number of tuples in a data chunk.
+
+* chunk: The data chunk to get the data from
+* returns: The number of tuples in the data chunk
+"""
+function duckdb_data_chunk_get_size(chunk)
+    return ccall((:duckdb_data_chunk_get_size, libduckdb), UInt64, (duckdb_data_chunk,), chunk)
+end
+
+"""
+Sets the current number of tuples in a data chunk.
+
+* chunk: The data chunk to set the size in
+* size: The number of tuples in the data chunk
+"""
+function duckdb_data_chunk_set_size(chunk, size)
+    return ccall((:duckdb_data_chunk_set_size, libduckdb), Cvoid, (duckdb_data_chunk, UInt64), chunk, size)
+end
+
+"""
+Retrieves the vector at the specified column index in the data chunk.
+
+The pointer to the vector is valid for as long as the chunk is alive.
+It does NOT need to be destroyed.
+
+* chunk: The data chunk to get the data from
+* returns: The vector
+"""
+function duckdb_data_chunk_get_vector(chunk, col_idx)
+    return ccall(
+        (:duckdb_data_chunk_get_vector, libduckdb),
+        duckdb_vector,
+        (duckdb_data_chunk, UInt64),
+        chunk,
+        col_idx - 1
+    )
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Vector Functions
+//===--------------------------------------------------------------------===//
+=#
+"""
+Retrieves the column type of the specified vector.
+
+The result must be destroyed with `duckdb_destroy_logical_type`.
+
+* vector: The vector get the data from
+* returns: The type of the vector
+"""
+function duckdb_vector_get_column_type(vector)
+    return ccall((:duckdb_vector_get_column_type, libduckdb), duckdb_logical_type, (duckdb_vector,), vector)
+end
+
+"""
+Retrieves the data pointer of the vector.
+
+The data pointer can be used to read or write values from the vector.
+How to read or write values depends on the type of the vector.
+
+* vector: The vector to get the data from
+* returns: The data pointer
+"""
+function duckdb_vector_get_data(vector)
+    return ccall((:duckdb_vector_get_data, libduckdb), Ptr{Cvoid}, (duckdb_vector,), vector)
+end
+
+"""
+Retrieves the validity mask pointer of the specified vector.
+
+If all values are valid, this function MIGHT return NULL!
+
+The validity mask is a bitset that signifies null-ness within the data chunk.
+It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.
+The bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).
+
+Validity of a specific value can be obtained like this:
+
+idx_t entry_idx = row_idx / 64;
+idx_t idx_in_entry = row_idx % 64;
+bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);
+
+Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.
+
+* vector: The vector to get the data from
+* returns: The pointer to the validity mask, or NULL if no validity mask is present
+"""
+function duckdb_vector_get_validity(vector)
+    return ccall((:duckdb_vector_get_validity, libduckdb), Ptr{UInt64}, (duckdb_vector,), vector)
+end
+
+"""
+Ensures the validity mask is writable by allocating it.
+
+After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.
+This allows null values to be written to the vector, regardless of whether a validity mask was present before.
+
+* vector: The vector to alter
+"""
+function duckdb_vector_ensure_validity_writable(vector)
+    return ccall((:duckdb_vector_ensure_validity_writable, libduckdb), Cvoid, (duckdb_vector,), vector)
+end
+
+"""
+Retrieves the child vector of a list vector.
+
+The resulting vector is valid as long as the parent vector is valid.
+
+* vector: The vector
+* returns: The child vector
+"""
+function duckdb_list_vector_get_child(vector)
+    return ccall((:duckdb_list_vector_get_child, libduckdb), duckdb_vector, (duckdb_vector,), vector)
+end
+
+"""
+Returns the size of the child vector of the list
+
+* vector: The vector
+* returns: The size of the child list
+"""
+function duckdb_list_vector_get_size(vector)
+    return ccall((:duckdb_list_vector_get_size, libduckdb), UInt64, (duckdb_vector,), vector)
+end
+
+"""
+Retrieves the child vector of a struct vector.
+
+The resulting vector is valid as long as the parent vector is valid.
+
+* vector: The vector
+* index: The child index
+* returns: The child vector
+"""
+function duckdb_struct_vector_get_child(vector, index)
+    return ccall(
+        (:duckdb_struct_vector_get_child, libduckdb),
+        duckdb_vector,
+        (duckdb_vector, UInt64),
+        vector,
+        index - 1
+    )
+end
+
+"""
+Assigns a string element in the vector at the specified location.
+
+* vector: The vector to alter
+* index: The row position in the vector to assign the string to
+* str: The null-terminated string
+"""
+function duckdb_vector_assign_string_element(vector, index, str)
+    return ccall(
+        (:duckdb_vector_assign_string_element, libduckdb),
+        Cvoid,
+        (duckdb_vector, UInt64, Ptr{UInt8}),
+        vector,
+        index - 1,
+        str
+    )
+end
+"""
+Assigns a string element in the vector at the specified location.
+
+* vector: The vector to alter
+* index: The row position in the vector to assign the string to
+* str: The null-terminated string
+* str_len: The string length
+"""
+function duckdb_vector_assign_string_element_len(vector, index, str, str_len)
+    return ccall(
+        (:duckdb_vector_assign_string_element_len, libduckdb),
+        Cvoid,
+        (duckdb_vector, UInt64, Ptr{UInt8}, UInt64),
+        vector,
+        index - 1,
+        str,
+        str_len
+    )
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Table Functions
+//===--------------------------------------------------------------------===//
+=#
+"""
+Creates a new empty table function.
+
+The return value should be destroyed with `duckdb_destroy_table_function`.
+
+* returns: The table function object.
+"""
+function duckdb_create_table_function()
+    return ccall((:duckdb_create_table_function, libduckdb), duckdb_table_function, ())
+end
+
+"""
+Destroys the given table function object.
+
+* table_function: The table function to destroy
+"""
+function duckdb_destroy_table_function(func)
+    return ccall((:duckdb_destroy_table_function, libduckdb), Cvoid, (Ref{duckdb_table_function},), func)
+end
+
+"""
+Sets the name of the given table function.
+
+* table_function: The table function
+* name: The name of the table function
+"""
+function duckdb_table_function_set_name(func, name)
+    return ccall((:duckdb_table_function_set_name, libduckdb), Cvoid, (duckdb_table_function, Ptr{UInt8}), func, name)
+end
+
+"""
+Adds a parameter to the table function.
+
+* table_function: The table function
+* type: The type of the parameter to add.
+"""
+function duckdb_table_function_add_parameter(func, type)
+    return ccall(
+        (:duckdb_table_function_add_parameter, libduckdb),
+        Cvoid,
+        (duckdb_table_function, duckdb_logical_type),
+        func,
+        type
+    )
+end
+
+"""
+Assigns extra information to the table function that can be fetched during binding, etc.
+
+* table_function: The table function
+* extra_info: The extra information
+* destroy: The callback that will be called to destroy the bind data (if any)
+"""
+function duckdb_table_function_set_extra_info(table_func, extra_data)
+    return ccall(
+        (:duckdb_table_function_set_extra_info, libduckdb),
+        Cvoid,
+        (duckdb_table_function, Ptr{Cvoid}, Ptr{Cvoid}),
+        table_func,
+        extra_data,
+        C_NULL
+    )
+end
+
+"""
+Sets the bind function of the table function
+
+* table_function: The table function
+* bind: The bind function
+"""
+function duckdb_table_function_set_bind(table_func, bind_func)
+    return ccall(
+        (:duckdb_table_function_set_bind, libduckdb),
+        Cvoid,
+        (duckdb_table_function, Ptr{Cvoid}),
+        table_func,
+        bind_func
+    )
+end
+
+"""
+Sets the init function of the table function
+
+* table_function: The table function
+* init: The init function
+"""
+function duckdb_table_function_set_init(table_func, init_func)
+    return ccall(
+        (:duckdb_table_function_set_init, libduckdb),
+        Cvoid,
+        (duckdb_table_function, Ptr{Cvoid}),
+        table_func,
+        init_func
+    )
+end
+
+
+"""
+Sets the main function of the table function
+
+* table_function: The table function
+* function: The function
+"""
+function duckdb_table_function_set_function(table_func, func)
+    return ccall(
+        (:duckdb_table_function_set_function, libduckdb),
+        Cvoid,
+        (duckdb_table_function, Ptr{Cvoid}),
+        table_func,
+        func
+    )
+end
+
+
+"""
+Register the table function object within the given connection.
+
+The function requires at least a name, a bind function, an init function and a main function.
+
+If the function is incomplete or a function with this name already exists DuckDBError is returned.
+
+* con: The connection to register it in.
+* function: The function pointer
+* returns: Whether or not the registration was successful.
+"""
+function duckdb_register_table_function(con, func)
+    return ccall(
+        (:duckdb_register_table_function, libduckdb),
+        Int32,
+        (duckdb_connection, duckdb_table_function),
+        con,
+        func
+    )
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Table Function Bind
+//===--------------------------------------------------------------------===//
+=#
+
+"""
+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
+
+* info: The info object
+* returns: The extra info
+"""
+function duckdb_bind_get_extra_info(bind_info)
+    return ccall((:duckdb_bind_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_bind_info,), bind_info)
+end
+
+"""
+Adds a result column to the output of the table function.
+
+* info: The info object
+* name: The name of the column
+* type: The logical type of the column
+"""
+function duckdb_bind_add_result_column(bind_info, name, type)
+    return ccall(
+        (:duckdb_bind_add_result_column, libduckdb),
+        Cvoid,
+        (duckdb_bind_info, Ptr{UInt8}, duckdb_logical_type),
+        bind_info,
+        name,
+        type
+    )
+end
+
+"""
+Retrieves the number of regular (non-named) parameters to the function.
+
+* info: The info object
+* returns: The number of parameters
+"""
+function duckdb_bind_get_parameter_count(bind_info)
+    return ccall((:duckdb_bind_get_parameter_count, libduckdb), Int32, (duckdb_bind_info,), bind_info)
+end
+
+"""
+Retrieves the parameter at the given index.
+
+The result must be destroyed with `duckdb_destroy_value`.
+
+* info: The info object
+* index: The index of the parameter to get
+* returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
+"""
+function duckdb_bind_get_parameter(bind_info, index)
+    return ccall((:duckdb_bind_get_parameter, libduckdb), duckdb_value, (duckdb_bind_info, Int32), bind_info, index)
+end
+
+"""
+Retrieves the parameter at the given index.
+
+The result must be destroyed with `duckdb_destroy_value`.
+
+* info: The info object
+* index: The index of the parameter to get
+* returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
+"""
+function duckdb_bind_set_bind_data(bind_info, bind_data, delete_callback)
+    return ccall(
+        (:duckdb_bind_set_bind_data, libduckdb),
+        Cvoid,
+        (duckdb_bind_info, Ptr{Cvoid}, Ptr{Cvoid}),
+        bind_info,
+        bind_data,
+        delete_callback
+    )
+end
+
+"""
+Report that an error has occurred during bind.
+
+* info: The info object
+* error: The error message
+"""
+function duckdb_bind_set_error(info, error_message)
+    return ccall((:duckdb_bind_set_error, libduckdb), Cvoid, (duckdb_bind_info, Ptr{UInt8}), info, error_message)
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Table Function Init
+//===--------------------------------------------------------------------===//
+=#
+"""
+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
+
+* info: The info object
+* returns: The extra info
+"""
+function duckdb_init_get_extra_info(info)
+    return ccall((:duckdb_init_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_init_info,), info)
+end
+
+"""
+Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
+
+Note that the bind data should be considered as read-only.
+For tracking state, use the init data instead.
+
+* info: The info object
+* returns: The bind data object
+"""
+function duckdb_init_get_bind_data(info)
+    return ccall((:duckdb_init_get_bind_data, libduckdb), Ptr{Cvoid}, (duckdb_init_info,), info)
+end
+
+"""
+Sets the user-provided init data in the init object. This object can be retrieved again during execution.
+
+* info: The info object
+* extra_data: The init data object.
+* destroy: The callback that will be called to destroy the init data (if any)
+"""
+function duckdb_init_set_init_data(init_info, init_data, delete_callback)
+    return ccall(
+        (:duckdb_init_set_init_data, libduckdb),
+        Cvoid,
+        (duckdb_init_info, Ptr{Cvoid}, Ptr{Cvoid}),
+        init_info,
+        init_data,
+        delete_callback
+    )
+end
+
+"""
+Report that an error has occurred during init.
+
+* info: The info object
+* error: The error message
+"""
+function duckdb_init_set_error(info, error_message)
+    return ccall((:duckdb_init_set_error, libduckdb), Cvoid, (duckdb_init_info, Ptr{UInt8}), info, error_message)
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Table Function
+//===--------------------------------------------------------------------===//
+=#
+"""
+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
+
+* info: The info object
+* returns: The extra info
+"""
+function duckdb_function_get_extra_info(info)
+    return ccall((:duckdb_function_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)
+end
+
+"""
+Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
+
+Note that the bind data should be considered as read-only.
+For tracking state, use the init data instead.
+
+* info: The info object
+* returns: The bind data object
+"""
+function duckdb_function_get_bind_data(info)
+    return ccall((:duckdb_function_get_bind_data, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)
+end
+
+"""
+Gets the init data set by `duckdb_bind_set_init_data` during the bind.
+
+* info: The info object
+* returns: The init data object
+"""
+function duckdb_function_get_init_data(info)
+    return ccall((:duckdb_function_get_init_data, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)
+end
+
+"""
+Report that an error has occurred while executing the function.
+
+* info: The info object
+* error: The error message
+"""
+function duckdb_function_set_error(info, error_message)
+    return ccall(
+        (:duckdb_function_set_error, libduckdb),
+        Cvoid,
+        (duckdb_function_info, Ptr{UInt8}),
+        info,
+        error_message
+    )
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Replacement scans
+//===--------------------------------------------------------------------===//
+=#
+"""
+Add a replacement scan definition to the specified database
+
+* db: The database object to add the replacement scan to
+* replacement: The replacement scan callback
+* extra_data: Extra data that is passed back into the specified callback
+* delete_callback: The delete callback to call on the extra data, if any
+"""
+function duckdb_add_replacement_scan(db, replacement, extra_data, delete_callback)
+    return ccall(
+        (:duckdb_add_replacement_scan, libduckdb),
+        Cvoid,
+        (duckdb_database, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}),
+        db,
+        replacement,
+        extra_data,
+        delete_callback
+    )
+end
+
+"""
+Sets the replacement function name to use. If this function is called in the replacement callback,
+ the replacement scan is performed. If it is not called, the replacement callback is not performed.
+
+* info: The info object
+* function_name: The function name to substitute.
+"""
+function duckdb_replacement_scan_set_function_name(info, function_name)
+    return ccall(
+        (:duckdb_replacement_scan_set_function_name, libduckdb),
+        Cvoid,
+        (duckdb_replacement_scan_info, Ptr{UInt8}),
+        info,
+        function_name
+    )
+end
+
+
+"""
+Adds a parameter to the replacement scan function.
+
+* info: The info object
+* parameter: The parameter to add. The function will call `duckdb_destroy_value` on the parameter.
+"""
+function duckdb_replacement_scan_add_parameter(info, parameter)
+    return ccall(
+        (:duckdb_replacement_scan_add_parameter, libduckdb),
+        Cvoid,
+        (duckdb_replacement_scan_info, duckdb_value),
+        info,
+        parameter
+    )
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Appender
+//===--------------------------------------------------------------------===//
+=#
+
+"""
+Creates an appender object.
+* connection: The connection context to create the appender in.
+* schema: The schema of the table to append to, or `nullptr` for the default schema.
+* table: The table name to append to.
+* out_appender: The resulting appender object.
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
+                                               duckdb_appender *out_appender);
+"""
+function duckdb_appender_create(connection, schema, table, out_appender)
+    return ccall(
+        (:duckdb_appender_create, libduckdb),
+        Int32,
+        (duckdb_connection, Ptr{UInt8}, Ptr{UInt8}, Ref{duckdb_appender}),
+        connection,
+        schema,
+        table,
+        out_appender
+    )
+end
+
+"""
+Returns the error message associated with the given appender.
+If the appender has no error message, this returns `nullptr` instead.
+The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.
+* appender: The appender to get the error from.
+* returns: The error message, or `nullptr` if there is none.
+DUCKDB_API const char *duckdb_appender_error(duckdb_appender appender);
+"""
+function duckdb_appender_error(appender)
+    return ccall((:duckdb_appender_error, libduckdb), Ptr{UInt8}, (duckdb_appender,), appender)
+end
+
+"""
+Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the
+base table.
+This should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you
+are done with the appender.
+* appender: The appender to flush.
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+DUCKDB_API duckdb_state duckdb_appender_flush(duckdb_appender appender);
+"""
+function duckdb_appender_flush(appender)
+    return ccall((:duckdb_appender_flush, libduckdb), duckdb_state, (duckdb_appender,), appender)
+end
+
+"""
+Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.
+This is generally not necessary. Call `duckdb_appender_destroy` instead.
+* appender: The appender to flush and close.
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);
+"""
+function duckdb_appender_close(appender)
+    return ccall((:duckdb_appender_close, libduckdb), duckdb_state, (duckdb_appender,), appender)
+end
+
+"""
+Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating
+all memory associated with the appender.
+* appender: The appender to flush, close and destroy.
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);
+"""
+function duckdb_appender_destroy(appender)
+    return ccall((:duckdb_appender_destroy, libduckdb), duckdb_state, (Ref{duckdb_appender},), appender)
+end
+
+"""
+A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.
+DUCKDB_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);
+"""
+function duckdb_appender_begin_row(appender)
+    return ccall((:duckdb_appender_begin_row, libduckdb), duckdb_state, (duckdb_appender,), appender)
+end
+
+"""
+Finish the current row of appends. After end_row is called, the next row can be appended.
+* appender: The appender.
+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+DUCKDB_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);
+"""
+function duckdb_appender_end_row(appender)
+    return ccall((:duckdb_appender_end_row, libduckdb), duckdb_state, (duckdb_appender,), appender)
+end
+
+"""
+Append a bool value to the appender.
+DUCKDB_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);
+"""
+function duckdb_append_bool(appender, value)
+    return ccall((:duckdb_append_bool, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
+end
+
+"""
+Append an int8_t value to the appender.
+DUCKDB_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);
+"""
+function duckdb_append_int8(appender, value)
+    return ccall((:duckdb_append_int8, libduckdb), duckdb_state, (duckdb_appender, Int16), appender, value)
+end
+
+"""
+Append an int16_t value to the appender.
+DUCKDB_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);
+"""
+function duckdb_append_int16(appender, value)
+    return ccall((:duckdb_append_int16, libduckdb), duckdb_state, (duckdb_appender, Int16), appender, value)
+end
+
+"""
+Append an int32_t value to the appender.
+DUCKDB_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);
+"""
+function duckdb_append_int32(appender, value)
+    return ccall((:duckdb_append_int16, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
+end
+
+"""
+Append an int64_t value to the appender.
+DUCKDB_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);
+"""
+function duckdb_append_int64(appender, value)
+    return ccall((:duckdb_append_int64, libduckdb), duckdb_state, (duckdb_appender, Int64), appender, value)
+end
+
+"""
+Append a duckdb_hugeint value to the appender.
+DUCKDB_API duckdb_state duckdb_append_hugeint(duckdb_appender appender, duckdb_hugeint value);
+"""
+function duckdb_append_hugeint(appender, value)
+    return ccall((:duckdb_append_hugeint, libduckdb), duckdb_state, (duckdb_appender, Int64), appender, value)
+end
+
+"""
+Append a uint8_t value to the appender.
+DUCKDB_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);
+"""
+function duckdb_append_uint8(appender, value)
+    return ccall((:duckdb_append_uint8, libduckdb), duckdb_state, (duckdb_appender, UInt16), appender, value)
+end
+
+"""
+Append a uint16_t value to the appender.
+DUCKDB_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);
+"""
+function duckdb_append_uint16(appender, value)
+    return ccall((:duckdb_append_uint16, libduckdb), duckdb_state, (duckdb_appender, UInt16), appender, value)
+end
+
+"""
+Append a uint32_t value to the appender.
+DUCKDB_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);
+"""
+function duckdb_append_uint32(appender, value)
+    return ccall((:duckdb_append_uint32, libduckdb), duckdb_state, (duckdb_appender, UInt32), appender, value)
+end
+
+"""
+Append a uint64_t value to the appender.
+DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);
+"""
+function duckdb_append_uint64(appender, value)
+    return ccall((:duckdb_append_uint64, libduckdb), duckdb_state, (duckdb_appender, UInt64), appender, value)
+end
+
+"""
+Append a float value to the appender.
+DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);
+"""
+function duckdb_append_float(appender, value)
+    return ccall((:duckdb_append_float, libduckdb), duckdb_state, (duckdb_appender, Float32), appender, value)
+end
+
+"""
+Append a double value to the appender.
+DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);
+"""
+function duckdb_append_double(appender, value)
+    return ccall((:duckdb_append_double, libduckdb), duckdb_state, (duckdb_appender, Float64), appender, value)
+end
+
+"""
+Append a duckdb_date value to the appender.
+DUCKDB_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);
+"""
+function duckdb_append_date(appender, value)
+    return ccall((:duckdb_append_date, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
+end
+
+"""
+Append a duckdb_time value to the appender.
+DUCKDB_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);
+"""
+function duckdb_append_time(appender, value)
+    return ccall((:duckdb_append_time, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
+end
+
+"""
+Append a duckdb_timestamp value to the appender.
+DUCKDB_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);
+"""
+function duckdb_append_timestamp(appender, value)
+    return ccall((:duckdb_append_timestamp, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
+end
+
+"""
+Append a duckdb_interval value to the appender.
+DUCKDB_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);
+"""
+function duckdb_append_interval(appender, value)
+    return ccall((:duckdb_append_interval, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
+end
+
+"""
+Append a varchar value to the appender.
+DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);
+"""
+function duckdb_append_varchar(appender, value)
+    return ccall((:duckdb_append_varchar, libduckdb), duckdb_state, (duckdb_appender, Ptr{UInt8}), appender, value)
+end
+
+"""
+Append a varchar value to the appender.
+DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);
+"""
+function duckdb_append_varchar_length(appender, value, length)
+    return ccall(
+        (:duckdb_append_varchar_length, libduckdb),
+        duckdb_state,
+        (duckdb_appender, Ptr{UInt8}, Int32),
+        appender,
+        value,
+        length
+    )
+end
+
+"""
+Append a blob value to the appender.
+DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);
+"""
+function duckdb_append_blob(appender, data, length)
+    return ccall(
+        (:duckdb_append_blob, libduckdb),
+        duckdb_state,
+        (duckdb_appender, Ptr{Cvoid}, Int32),
+        appender,
+        data,
+        length
+    )
+end
+
+"""
+Append a NULL value to the appender (of any type).
+DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);
+"""
+function duckdb_append_null(appender)
+    return ccall((:duckdb_append_null, libduckdb), duckdb_state, (duckdb_appender,), appender)
+end
+
+# #=
+# //===--------------------------------------------------------------------===//
+# // Arrow Interface
+# //===--------------------------------------------------------------------===//
+# =#
+#
+#
+# """
+# Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.
+# If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
+# `duckdb_query_arrow_error`.
+# Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the
+# query fails, otherwise the error stored within the result will not be freed correctly.
+# * connection: The connection to perform the query in.
+# * query: The SQL query to run.
+# * out_result: The query result.
+# * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+# DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);
+# """
+# function duckdb_query_arrow(connection, query, out_result)
+#     return ccall(
+#         (:duckdb_query_arrow, libduckdb),
+#         Int32,
+#         (Ptr{Cvoid}, Ptr{UInt8}, Ptr{Cvoid}),
+#         connection[],
+#         query,
+#         out_result,
+#     )
+# end
+#
+# """
+# Fetch the internal arrow schema from the arrow result.
+# * result: The result to fetch the schema from.
+# * out_schema: The output schema.
+# * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+# DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);
+# """
+# function duckdb_query_arrow_schema(result, out_schema)
+#     return ccall(
+#         (:duckdb_query_arrow_schema, libduckdb),
+#         duckdb_state,
+#         (Ptr{Cvoid}, Ptr{UInt8}),
+#         result,
+#         out_schema,
+#     )
+# end
+#
+# """
+# Fetch an internal arrow array from the arrow result.
+# This function can be called multiple time to get next chunks, which will free the previous out_array.
+# So consume the out_array before calling this function again.
+# * result: The result to fetch the array from.
+# * out_array: The output array.
+# * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
+# DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);
+# """
+# function duckdb_query_arrow_array(result, out_array)
+#     return ccall(
+#         (:duckdb_query_arrow_array, libduckdb),
+#         duckdb_state,
+#         (Ptr{Cvoid}, Ptr{Cvoid}),
+#         result,
+#         out_array,
+#     )
+# end
+#
+# """
+# Returns the number of columns present in a the arrow result object.
+# * result: The result object.
+# * returns: The number of columns present in the result object.
+# DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);
+# """
+# function duckdb_arrow_column_count(result)
+#     return ccall((:duckdb_arrow_column_count, libduckdb), Int32, (Ptr{Cvoid},), result)
+# end
+#
+# """
+# Returns the number of rows present in a the arrow result object.
+# * result: The result object.
+# * returns: The number of rows present in the result object.
+# DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);
+# """
+# function duckdb_arrow_row_count(result)
+#     return ccall((:duckdb_arrow_row_count, libduckdb), Int64, (Ptr{Cvoid},), result)
+# end
+#
+# """
+# Returns the number of rows changed by the query stored in the arrow result. This is relevant only for
+# INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.
+# * result: The result object.
+# * returns: The number of rows changed.
+# DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);
+# """
+# function duckdb_arrow_rows_changed(result)
+#     return ccall((:duckdb_arrow_rows_changed, libduckdb), Int64, (Ptr{Cvoid},), result)
+# end
+#
+# """
+# Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns
+# `DuckDBError`.
+# The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.
+# * result: The result object to fetch the nullmask from.
+# * returns: The error of the result.
+# DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);
+# """
+# function duckdb_query_arrow_error(result)
+#     return ccall((:duckdb_query_arrow_error, libduckdb), Ptr{UInt8}, (Ptr{Cvoid},), result)
+# end
+#
+# """
+# Closes the result and de-allocates all memory allocated for the arrow result.
+# * result: The result to destroy.
+# DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
+# """
+# function duckdb_destroy_arrow(result)
+#     return ccall((:duckdb_destroy_arrow, libduckdb), Cvoid, (Ptr{Ptr{Cvoid}},), result)
+# end
diff --git a/tools/juliapkg/src/appender.jl b/tools/juliapkg/src/appender.jl
new file mode 100644
index 000000000000..0cdcb1b017e8
--- /dev/null
+++ b/tools/juliapkg/src/appender.jl
@@ -0,0 +1,75 @@
+
+"""
+An appender object that can be used to append to a table
+"""
+mutable struct Appender
+    handle::duckdb_appender
+
+    function Appender(con::Connection, table::AbstractString)
+        handle = Ref{duckdb_appender}()
+        if duckdb_appender_create(con.handle, C_NULL, table, handle) != DuckDBSuccess
+            error_ptr = duckdb_appender_error(handle)
+            if error_ptr == C_NULL
+                error_message = string("Opening of Appender for table \"", table, "\" failed: unknown error")
+            else
+                error_message = unsafe_string(error_ptr)
+            end
+            duckdb_appender_destroy(handle)
+            throw(QueryException(error_message))
+        end
+        con = new(handle[])
+        finalizer(_close_appender, con)
+        return con
+    end
+    function Appender(db::DB, table::AbstractString)
+        return Appender(db.main_connection, table)
+    end
+end
+
+function _close_appender(appender::Appender)
+    if appender.handle != C_NULL
+        duckdb_appender_destroy(appender.handle)
+    end
+    appender.handle = C_NULL
+    return
+end
+
+function close(appender::Appender)
+    _close_appender(appender)
+    return
+end
+
+Append(appender::Appender, val::AbstractFloat) = duckdb_append_double(appender.handle, Float64(val));
+Append(appender::Appender, val::Bool) = duckdb_append_boolean(appender.handle, val);
+Append(appender::Appender, val::Int8) = duckdb_append_int8(appender.handle, val);
+Append(appender::Appender, val::Int16) = duckdb_append_int16(appender.handle, val);
+Append(appender::Appender, val::Int32) = duckdb_append_int32(appender.handle, val);
+Append(appender::Appender, val::Int64) = duckdb_append_int64(appender.handle, val);
+Append(appender::Appender, val::UInt8) = duckdb_append_uint8(appender.handle, val);
+Append(appender::Appender, val::UInt16) = duckdb_append_uint16(appender.handle, val);
+Append(appender::Appender, val::UInt32) = duckdb_append_uint32(appender.handle, val);
+Append(appender::Appender, val::UInt64) = duckdb_append_uint64(appender.handle, val);
+Append(appender::Appender, val::Float32) = duckdb_append_float(appender.handle, val);
+Append(appender::Appender, val::Float64) = duckdb_append_double(appender.handle, val);
+Append(appender::Appender, val::Missing) = duckdb_append_null(appender.handle);
+Append(appender::Appender, val::Nothing) = duckdb_append_null(appender.handle);
+Append(appender::Appender, val::AbstractString) = duckdb_append_varchar(appender.handle, val);
+Append(appender::Appender, val::Vector{UInt8}) = duckdb_append_blob(appender.handle, val, sizeof(val));
+Append(appender::Appender, val::WeakRefString{UInt8}) = duckdb_append_varchar(stmt.handle, i, val.ptr, val.len);
+
+function Append(appender::Appender, val::Any)
+    println(val)
+    throw(NotImplementedException("unsupported type for append"))
+end
+
+function EndRow(appender::Appender)
+    duckdb_appender_end_row(appender.handle)
+    return
+end
+
+function Flush(appender::Appender)
+    duckdb_appender_flush(appender.handle)
+    return
+end
+
+DBInterface.close!(appender::Appender) = _close_appender(db)
diff --git a/tools/juliapkg/src/config.jl b/tools/juliapkg/src/config.jl
new file mode 100644
index 000000000000..0f07d6c5c382
--- /dev/null
+++ b/tools/juliapkg/src/config.jl
@@ -0,0 +1,31 @@
+"""
+Configuration object
+"""
+mutable struct Config
+    handle::duckdb_config
+
+    function Config()
+        handle = Ref{duckdb_connection}()
+        duckdb_create_config(handle)
+
+        result = new(handle[])
+        finalizer(_destroy_config, result)
+        return result
+    end
+end
+
+function _destroy_config(config::Config)
+    if config.handle != C_NULL
+        duckdb_destroy_config(config.handle)
+    end
+    config.handle = C_NULL
+    return
+end
+
+function SetConfig(config::Config, name::AbstractString, option::AbstractString)
+    if duckdb_set_config(config.handle, name, option) != DuckDBSuccess
+        throw(QueryException(string("Unrecognized configuration option \"", name, "\"")))
+    end
+end
+
+DBInterface.close!(config::Config) = _destroy_config(config)
diff --git a/tools/juliapkg/src/ctypes.jl b/tools/juliapkg/src/ctypes.jl
new file mode 100644
index 000000000000..1aba17c4c171
--- /dev/null
+++ b/tools/juliapkg/src/ctypes.jl
@@ -0,0 +1,237 @@
+
+const duckdb_database = Ptr{Cvoid}
+const duckdb_config = Ptr{Cvoid}
+const duckdb_connection = Ptr{Cvoid}
+const duckdb_prepared_statement = Ptr{Cvoid}
+const duckdb_logical_type = Ptr{Cvoid}
+const duckdb_data_chunk = Ptr{Cvoid}
+const duckdb_vector = Ptr{Cvoid}
+const duckdb_appender = Ptr{Cvoid}
+const duckdb_logical_type = Ptr{Cvoid}
+const duckdb_value = Ptr{Cvoid}
+const duckdb_table_function = Ptr{Cvoid}
+const duckdb_bind_info = Ptr{Cvoid}
+const duckdb_init_info = Ptr{Cvoid}
+const duckdb_function_info = Ptr{Cvoid}
+const duckdb_replacement_scan_info = Ptr{Cvoid}
+const DuckDBSuccess = 0;
+const DuckDBError = 1;
+const duckdb_state = Int32;
+
+@enum DUCKDB_TYPE_::UInt32 begin
+    DUCKDB_TYPE_INVALID = 0
+    DUCKDB_TYPE_BOOLEAN
+    DUCKDB_TYPE_TINYINT
+    DUCKDB_TYPE_SMALLINT
+    DUCKDB_TYPE_INTEGER
+    DUCKDB_TYPE_BIGINT
+    DUCKDB_TYPE_UTINYINT
+    DUCKDB_TYPE_USMALLINT
+    DUCKDB_TYPE_UINTEGER
+    DUCKDB_TYPE_UBIGINT
+    DUCKDB_TYPE_FLOAT
+    DUCKDB_TYPE_DOUBLE
+    DUCKDB_TYPE_TIMESTAMP
+    DUCKDB_TYPE_DATE
+    DUCKDB_TYPE_TIME
+    DUCKDB_TYPE_INTERVAL
+    DUCKDB_TYPE_HUGEINT
+    DUCKDB_TYPE_VARCHAR
+    DUCKDB_TYPE_BLOB
+    DUCKDB_TYPE_DECIMAL
+    DUCKDB_TYPE_TIMESTAMP_S
+    DUCKDB_TYPE_TIMESTAMP_MS
+    DUCKDB_TYPE_TIMESTAMP_NS
+    DUCKDB_TYPE_ENUM
+    DUCKDB_TYPE_LIST
+    DUCKDB_TYPE_STRUCT
+    DUCKDB_TYPE_MAP
+    DUCKDB_TYPE_UUID
+    DUCKDB_TYPE_JSON
+end
+
+const DUCKDB_TYPE = DUCKDB_TYPE_
+
+"""
+Days are stored as days since 1970-01-01

+Use the duckdb_from_date/duckdb_to_date function to extract individual information
+
+"""
+struct duckdb_date
+    days::Int32
+end
+
+struct duckdb_date_struct
+    year::Int32
+    month::Int8
+    day::Int8
+end
+
+"""
+Time is stored as microseconds since 00:00:00

+Use the duckdb_from_time/duckdb_to_time function to extract individual information
+
+"""
+struct duckdb_time
+    micros::Int64
+end
+
+struct duckdb_time_struct
+    hour::Int8
+    min::Int8
+    sec::Int8
+    micros::Int32
+end
+
+"""
+Timestamps are stored as microseconds since 1970-01-01

+Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information
+
+"""
+struct duckdb_timestamp
+    micros::Int64
+end
+
+struct duckdb_timestamp_struct
+    date::Ref{duckdb_date_struct}
+    time::Ref{duckdb_time_struct}
+end
+
+struct duckdb_interval
+    months::Int32
+    days::Int32
+    micros::Int64
+end
+
+"""
+Hugeints are composed in a (lower, upper) component

+The value of the hugeint is upper * 2^64 + lower

+For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended
+
+"""
+struct duckdb_hugeint
+    lower::UInt64
+    upper::Int64
+end
+
+struct duckdb_string_t
+    length::UInt32
+    data::NTuple{12, UInt8}
+end
+
+struct duckdb_list_entry_t
+    offset::UInt64
+    length::UInt64
+end
+
+STRING_INLINE_LENGTH = 12
+
+struct duckdb_column
+    __deprecated_data::Ptr{Cvoid}
+    __deprecated_nullmask::Ptr{UInt8}
+    __deprecated_type::Ptr{DUCKDB_TYPE}
+    __deprecated_name::Ptr{UInt8}
+    internal_data::Ptr{Cvoid}
+end
+
+struct duckdb_result
+    __deprecated_column_count::Ptr{UInt64}
+    __deprecated_row_count::Ptr{UInt64}
+    __deprecated_rows_changed::Ptr{UInt64}
+    __deprecated_columns::Ptr{duckdb_column}
+    __deprecated_error_message::Ptr{UInt8}
+    internal_data::Ptr{Cvoid}
+end
+
+INTERNAL_TYPE_MAP = Dict(
+    DUCKDB_TYPE_BOOLEAN => Bool,
+    DUCKDB_TYPE_TINYINT => Int8,
+    DUCKDB_TYPE_SMALLINT => Int16,
+    DUCKDB_TYPE_INTEGER => Int32,
+    DUCKDB_TYPE_BIGINT => Int64,
+    DUCKDB_TYPE_UTINYINT => UInt8,
+    DUCKDB_TYPE_USMALLINT => UInt16,
+    DUCKDB_TYPE_UINTEGER => UInt32,
+    DUCKDB_TYPE_UBIGINT => UInt64,
+    DUCKDB_TYPE_FLOAT => Float32,
+    DUCKDB_TYPE_DOUBLE => Float64,
+    DUCKDB_TYPE_TIMESTAMP => Int64,
+    DUCKDB_TYPE_TIMESTAMP_S => Int64,
+    DUCKDB_TYPE_TIMESTAMP_MS => Int64,
+    DUCKDB_TYPE_TIMESTAMP_NS => Int64,
+    DUCKDB_TYPE_DATE => Int32,
+    DUCKDB_TYPE_TIME => Int64,
+    DUCKDB_TYPE_INTERVAL => duckdb_interval,
+    DUCKDB_TYPE_HUGEINT => duckdb_hugeint,
+    DUCKDB_TYPE_UUID => duckdb_hugeint,
+    DUCKDB_TYPE_VARCHAR => duckdb_string_t,
+    DUCKDB_TYPE_JSON => duckdb_string_t,
+    DUCKDB_TYPE_BLOB => duckdb_string_t,
+    DUCKDB_TYPE_UUID => duckdb_hugeint,
+    DUCKDB_TYPE_LIST => duckdb_list_entry_t,
+    DUCKDB_TYPE_STRUCT => Cvoid,
+    DUCKDB_TYPE_MAP => Cvoid
+)
+
+JULIA_TYPE_MAP = Dict(
+    DUCKDB_TYPE_INVALID => Missing,
+    DUCKDB_TYPE_BOOLEAN => Bool,
+    DUCKDB_TYPE_TINYINT => Int8,
+    DUCKDB_TYPE_SMALLINT => Int16,
+    DUCKDB_TYPE_INTEGER => Int32,
+    DUCKDB_TYPE_BIGINT => Int64,
+    DUCKDB_TYPE_HUGEINT => Int128,
+    DUCKDB_TYPE_UTINYINT => UInt8,
+    DUCKDB_TYPE_USMALLINT => UInt16,
+    DUCKDB_TYPE_UINTEGER => UInt32,
+    DUCKDB_TYPE_UBIGINT => UInt64,
+    DUCKDB_TYPE_FLOAT => Float32,
+    DUCKDB_TYPE_DOUBLE => Float64,
+    DUCKDB_TYPE_DECIMAL => Float64,
+    DUCKDB_TYPE_DATE => Date,
+    DUCKDB_TYPE_TIME => Time,
+    DUCKDB_TYPE_TIMESTAMP => DateTime,
+    DUCKDB_TYPE_TIMESTAMP_S => DateTime,
+    DUCKDB_TYPE_TIMESTAMP_MS => DateTime,
+    DUCKDB_TYPE_TIMESTAMP_NS => DateTime,
+    DUCKDB_TYPE_INTERVAL => Dates.CompoundPeriod,
+    DUCKDB_TYPE_UUID => UUID,
+    DUCKDB_TYPE_VARCHAR => AbstractString,
+    DUCKDB_TYPE_JSON => AbstractString,
+    DUCKDB_TYPE_ENUM => AbstractString,
+    DUCKDB_TYPE_BLOB => Base.CodeUnits{UInt8, String},
+    DUCKDB_TYPE_MAP => Dict
+)
+
+# convert a DuckDB type into Julia equivalent
+function duckdb_type_to_internal_type(x::DUCKDB_TYPE)
+    if !haskey(INTERNAL_TYPE_MAP, x)
+        throw(NotImplementedException(string("Unsupported type for duckdb_type_to_internal_type: ", x)))
+    end
+    return INTERNAL_TYPE_MAP[x]
+end
+
+function duckdb_type_to_julia_type(x)
+    type_id = GetTypeId(x)
+    if type_id == DUCKDB_TYPE_LIST
+        return Vector{Union{Missing, duckdb_type_to_julia_type(GetListChildType(x))}}
+    elseif type_id == DUCKDB_TYPE_STRUCT
+        child_count = GetStructChildCount(x)
+        names::Vector{Symbol} = Vector()
+        for i in 1:child_count
+            child_name::Symbol = Symbol(GetStructChildName(x, i))
+            push!(names, child_name)
+        end
+        names_tuple = Tuple(x for x in names)
+        return Union{Missing, NamedTuple{names_tuple}}
+    end
+    if !haskey(JULIA_TYPE_MAP, type_id)
+        throw(NotImplementedException(string("Unsupported type for duckdb_type_to_julia_type: ", type_id)))
+    end
+    return JULIA_TYPE_MAP[type_id]
+end
+
+const ROUNDING_EPOCH_TO_UNIX_EPOCH_DAYS = 719528
+const ROUNDING_EPOCH_TO_UNIX_EPOCH_MS = 62167219200000
+
+sym(ptr) = ccall(:jl_symbol, Ref{Symbol}, (Ptr{UInt8},), ptr)
diff --git a/tools/juliapkg/src/data_chunk.jl b/tools/juliapkg/src/data_chunk.jl
new file mode 100644
index 000000000000..2fdcbdc4be52
--- /dev/null
+++ b/tools/juliapkg/src/data_chunk.jl
@@ -0,0 +1,62 @@
+"""
+DuckDB data chunk
+"""
+mutable struct DataChunk
+    handle::duckdb_data_chunk
+
+    function DataChunk(handle::duckdb_data_chunk, destroy::Bool)
+        result = new(handle)
+        if destroy
+            finalizer(_destroy_data_chunk, result)
+        end
+        return result
+    end
+end
+
+function GetColumnCount(chunk::DataChunk)
+    return duckdb_data_chunk_get_column_count(chunk.handle)
+end
+
+function GetSize(chunk::DataChunk)
+    return duckdb_data_chunk_get_size(chunk.handle)
+end
+
+function SetSize(chunk::DataChunk, size::Int64)
+    return duckdb_data_chunk_set_size(chunk.handle, size)
+end
+
+function GetVector(chunk::DataChunk, col_idx::Int64)::Vec
+    if col_idx < 1 || col_idx > GetColumnCount(chunk)
+        throw(
+            InvalidInputException(
+                string(
+                    "GetArray column index ",
+                    col_idx,
+                    " out of range, expected value between 1 and ",
+                    GetColumnCount(chunk)
+                )
+            )
+        )
+    end
+    return Vec(duckdb_data_chunk_get_vector(chunk.handle, col_idx))
+end
+
+function GetArray(chunk::DataChunk, col_idx::Int64, ::Type{T})::Vector{T} where {T}
+    return GetArray(GetVector(chunk, col_idx), T)
+end
+
+function GetValidity(chunk::DataChunk, col_idx::Int64)::ValidityMask
+    return GetValidity(GetVector(chunk, col_idx))
+end
+
+function AllValid(chunk::DataChunk, col_idx::Int64)
+    return AllValid(GetVector(chunk, col_idx))
+end
+
+# this is only required when we own the data chunk
+function _destroy_data_chunk(chunk::DataChunk)
+    if chunk.handle != C_NULL
+        duckdb_destroy_data_chunk(chunk.handle)
+    end
+    return chunk.handle = C_NULL
+end
diff --git a/tools/juliapkg/src/data_frame_scan.jl b/tools/juliapkg/src/data_frame_scan.jl
new file mode 100644
index 000000000000..1f5e7d5e21b8
--- /dev/null
+++ b/tools/juliapkg/src/data_frame_scan.jl
@@ -0,0 +1,187 @@
+using DataFrames
+
+mutable struct DFBindInfo
+    df::DataFrame
+    result_types::Vector{Type}
+    scan_functions::Vector{Function}
+
+    function DFBindInfo(df::DataFrame, result_types::Vector{Type}, scan_functions::Vector{Function})
+        return new(df, result_types, scan_functions)
+    end
+end
+
+function DFResultType(df, entry)
+    column_type = eltype(df[!, entry])
+    if typeof(column_type) == Union
+        # remove Missing type from the union
+        column_type = Core.Compiler.typesubtract(column_type, Missing, 1)
+    end
+    return column_type
+end
+
+function DFJuliaType(column_type)
+    if column_type == Date
+        column_type = Int32
+    elseif column_type == Time
+        column_type = Int64
+    elseif column_type == DateTime
+        column_type = Int64
+    end
+    return column_type
+end
+
+ValueToDuckDB(val::T) where {T <: Date} = convert(Int32, Dates.date2epochdays(val) - ROUNDING_EPOCH_TO_UNIX_EPOCH_DAYS)
+ValueToDuckDB(val::T) where {T <: Time} = convert(Int64, Dates.value(val) / 1000)
+ValueToDuckDB(val::T) where {T <: DateTime} =
+    convert(Int64, (Dates.datetime2epochms(val) - ROUNDING_EPOCH_TO_UNIX_EPOCH_MS) * 1000)
+function ValueToDuckDB(val::T) where {T <: AbstractString}
+    throw(
+        NotImplementedException(
+            "Cannot use ValueToDuckDB to convert string values - use DuckDB.AssignStringElement on a vector instead"
+        )
+    )
+end
+function ValueToDuckDB(val::T) where {T}
+    return val
+end
+
+function DFScanColumn(
+    df::DataFrame,
+    df_offset::Int64,
+    col_idx::Int64,
+    scan_count::Int64,
+    output::DuckDB.DataChunk,
+    ::Type{T}
+) where {T}
+    vector = DuckDB.GetVector(output, col_idx)
+    result_array::Vector{T} = DuckDB.GetArray(vector, T)
+    validity = DuckDB.GetValidity(vector)
+    input_column = df[!, col_idx]
+    for i in 1:scan_count
+        if input_column[df_offset + i] === missing
+            DuckDB.SetInvalid(validity, i)
+        else
+            result_array[i] = ValueToDuckDB(input_column[df_offset + i])
+        end
+    end
+end
+
+function DFScanStringColumn(
+    df::DataFrame,
+    df_offset::Int64,
+    col_idx::Int64,
+    scan_count::Int64,
+    output::DuckDB.DataChunk,
+    ::Type{T}
+) where {T}
+    vector = DuckDB.GetVector(output, col_idx)
+    validity = DuckDB.GetValidity(vector)
+    input_column = df[!, col_idx]
+    for i in 1:scan_count
+        if input_column[df_offset + i] === missing
+            DuckDB.SetInvalid(validity, i)
+        else
+            DuckDB.AssignStringElement(vector, i, input_column[df_offset + i])
+        end
+    end
+end
+
+function DFScanFunction(df, entry)
+    result_type = DFResultType(df, entry)
+    if result_type <: AbstractString
+        return DFScanStringColumn
+    end
+    return DFScanColumn
+end
+
+function DFBindFunction(info::DuckDB.BindInfo)
+    # fetch the df name from the function parameters
+    parameter = DuckDB.GetParameter(info, 0)
+    name = DuckDB.GetValue(parameter, String)
+    # fetch the actual df using the function name
+    extra_data = DuckDB.GetExtraData(info)
+    df = extra_data[name]
+
+    # register the result columns
+    result_types::Vector{Type} = Vector()
+    scan_functions::Vector{Function} = Vector()
+    for entry in names(df)
+        result_type = DFResultType(df, entry)
+        scan_function = DFScanFunction(df, entry)
+        push!(result_types, DFJuliaType(result_type))
+        push!(scan_functions, scan_function)
+
+        DuckDB.AddResultColumn(info, entry, result_type)
+    end
+    return DFBindInfo(df, result_types, scan_functions)
+end
+
+mutable struct DFInitInfo
+    pos::Int64
+
+    function DFInitInfo()
+        return new(0)
+    end
+end
+
+function DFInitFunction(info::DuckDB.InitInfo)
+    return DFInitInfo()
+end
+
+function DFScanFunction(info::DuckDB.FunctionInfo, output::DuckDB.DataChunk)
+    bind_info = DuckDB.GetBindInfo(info, DFBindInfo)
+    init_info = DuckDB.GetInitInfo(info, DFInitInfo)
+
+    column_count = size(names(bind_info.df), 1)
+    row_count = size(bind_info.df, 1)
+    scan_count = DuckDB.VECTOR_SIZE
+    if init_info.pos + scan_count >= row_count
+        scan_count = row_count - init_info.pos
+    end
+
+    for col_idx in 1:column_count
+        bind_info.scan_functions[col_idx](
+            bind_info.df,
+            init_info.pos,
+            col_idx,
+            scan_count,
+            output,
+            bind_info.result_types[col_idx]
+        )
+    end
+    init_info.pos += scan_count
+    DuckDB.SetSize(output, scan_count)
+    return
+end
+
+function RegisterDataFrame(con::Connection, df::DataFrame, name::AbstractString)
+    con.db.data_frames[name] = df
+    DBInterface.execute(
+        con,
+        string("CREATE OR REPLACE VIEW \"", name, "\" AS SELECT * FROM julia_df_scan('", name, "')")
+    )
+    return
+end
+RegisterDataFrame(db::DB, df::DataFrame, name::AbstractString) = RegisterDataFrame(db.main_connection, df, name)
+
+function UnregisterDataFrame(con::Connection, name::AbstractString)
+    pop!(con.db.data_frames, name)
+    DBInterface.execute(con, string("DROP VIEW IF EXISTS \"", name, "\""))
+    return
+end
+UnregisterDataFrame(db::DB, name::AbstractString) = UnregisterDataFrame(db.main_connection, name)
+
+
+function AddDataFrameScan(db::DB)
+    # add the data frame scan function
+    DuckDB.CreateTableFunction(
+        db.main_connection,
+        "julia_df_scan",
+        [String],
+        DFBindFunction,
+        DFInitFunction,
+        DFScanFunction,
+        db.handle.data_frames
+    )
+    return
+end
diff --git a/tools/juliapkg/src/database.jl b/tools/juliapkg/src/database.jl
new file mode 100644
index 000000000000..61b10664f1a9
--- /dev/null
+++ b/tools/juliapkg/src/database.jl
@@ -0,0 +1,111 @@
+"""
+Internal DuckDB database handle.
+"""
+mutable struct DuckDBHandle
+    file::String
+    handle::duckdb_database
+    functions::Vector{Any}
+    data_frames::Dict{Any, Any}
+
+    function DuckDBHandle(f::AbstractString, config::Config)
+        f = String(isempty(f) ? f : expanduser(f))
+        handle = Ref{duckdb_database}()
+        error = Ref{Ptr{UInt8}}()
+        if duckdb_open_ext(f, handle, config.handle, error) != DuckDBSuccess
+            error_message = unsafe_string(error[])
+            duckdb_free(error[])
+            throw(ConnectionException(error_message))
+        end
+
+        db = new(f, handle[], Vector(), Dict())
+        finalizer(_close_database, db)
+        return db
+    end
+end
+
+function _close_database(db::DuckDBHandle)
+    # disconnect from DB
+    if db.handle != C_NULL
+        duckdb_close(db.handle)
+    end
+    return db.handle = C_NULL
+end
+
+"""
+A connection object to a DuckDB database.
+
+Transaction contexts are local to a single connection.
+
+A connection can only run a single query concurrently.
+It is possible to open multiple connections to a single DuckDB database instance.
+Multiple connections can run multiple queries concurrently.
+"""
+mutable struct Connection
+    db::DuckDBHandle
+    handle::duckdb_connection
+
+    function Connection(db::DuckDBHandle)
+        handle = Ref{duckdb_connection}()
+        if duckdb_connect(db.handle, handle) != DuckDBSuccess
+            throw(ConnectionException("Failed to open connection"))
+        end
+        con = new(db, handle[])
+        finalizer(_close_connection, con)
+        return con
+    end
+end
+
+function _close_connection(con::Connection)
+    # disconnect
+    if con.handle != C_NULL
+        duckdb_disconnect(con.handle)
+    end
+    con.handle = C_NULL
+    return
+end
+
+"""
+A DuckDB database object.
+
+By default a DuckDB database object has an open connection object (db.main_connection).
+When the database object is used directly in queries, it is actually the underlying main_connection that is used.
+
+It is possible to open new connections to a single database instance using DBInterface.connect(db).
+"""
+mutable struct DB <: DBInterface.Connection
+    handle::DuckDBHandle
+    main_connection::Connection
+
+    function DB(f::AbstractString, config::Config)
+        handle = DuckDBHandle(f, config)
+        main_connection = Connection(handle)
+
+        db = new(handle, main_connection)
+        AddDataFrameScan(db)
+        return db
+    end
+    function DB(f::AbstractString)
+        return DB(f, Config())
+    end
+end
+
+function close_database(db::DB)
+    _close_connection(db.main_connection)
+    _close_database(db.handle)
+    return
+end
+
+const VECTOR_SIZE = duckdb_vector_size()
+
+DB() = DB(":memory:")
+DBInterface.connect(::Type{DB}) = DB()
+DBInterface.connect(::Type{DB}, f::AbstractString) = DB(f)
+DBInterface.connect(::Type{DB}, f::AbstractString, config::Config) = DB(f, config)
+DBInterface.connect(db::DB) = Connection(db.handle)
+DBInterface.close!(db::DB) = close_database(db)
+DBInterface.close!(con::Connection) = _close_connection(con)
+Base.close(db::DB) = close_database(db)
+Base.isopen(db::DB) = db.handle != C_NULL
+
+Base.show(io::IO, db::DuckDB.DB) = print(io, string("DuckDB.DB(", "\"$(db.handle.file)\"", ")"))
+Base.show(io::IO, con::DuckDB.Connection) = print(io, string("DuckDB.Connection(", "\"$(con.db.file)\"", ")"))
diff --git a/tools/juliapkg/src/ddl.jl b/tools/juliapkg/src/ddl.jl
new file mode 100644
index 000000000000..0a18986ad27d
--- /dev/null
+++ b/tools/juliapkg/src/ddl.jl
@@ -0,0 +1,5 @@
+
+function drop!(db::DB, table::AbstractString; ifexists::Bool = false)
+    exists = ifexists ? "IF EXISTS" : ""
+    return execute(db, "DROP TABLE $exists $(esc_id(table))")
+end
diff --git a/tools/juliapkg/src/exceptions.jl b/tools/juliapkg/src/exceptions.jl
new file mode 100644
index 000000000000..0d982633d996
--- /dev/null
+++ b/tools/juliapkg/src/exceptions.jl
@@ -0,0 +1,17 @@
+mutable struct ConnectionException <: Exception
+    var::String
+end
+mutable struct QueryException <: Exception
+    var::String
+end
+mutable struct NotImplementedException <: Exception
+    var::String
+end
+mutable struct InvalidInputException <: Exception
+    var::String
+end
+
+Base.showerror(io::IO, e::ConnectionException) = print(io, e.var)
+Base.showerror(io::IO, e::QueryException) = print(io, e.var)
+Base.showerror(io::IO, e::NotImplementedException) = print(io, e.var)
+Base.showerror(io::IO, e::InvalidInputException) = print(io, e.var)
diff --git a/tools/juliapkg/src/helper.jl b/tools/juliapkg/src/helper.jl
new file mode 100644
index 000000000000..20f6e790c034
--- /dev/null
+++ b/tools/juliapkg/src/helper.jl
@@ -0,0 +1,5 @@
+
+function esc_id end
+
+esc_id(x::AbstractString) = "\"" * replace(x, "\"" => "\"\"") * "\""
+esc_id(X::AbstractVector{S}) where {S <: AbstractString} = join(map(esc_id, X), ',')
diff --git a/tools/juliapkg/src/logical_type.jl b/tools/juliapkg/src/logical_type.jl
new file mode 100644
index 000000000000..366f9b4da7d5
--- /dev/null
+++ b/tools/juliapkg/src/logical_type.jl
@@ -0,0 +1,96 @@
+"""
+DuckDB type
+"""
+mutable struct LogicalType
+    handle::duckdb_logical_type
+
+    function LogicalType(type::DUCKDB_TYPE)
+        handle = duckdb_create_logical_type(type)
+        result = new(handle)
+        finalizer(_destroy_type, result)
+        return result
+    end
+    function LogicalType(handle::duckdb_logical_type)
+        result = new(handle)
+        finalizer(_destroy_type, result)
+        return result
+    end
+end
+
+function _destroy_type(type::LogicalType)
+    if type.handle != C_NULL
+        duckdb_destroy_logical_type(type.handle)
+    end
+    type.handle = C_NULL
+    return
+end
+
+CreateLogicalType(::Type{T}) where {T <: String} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_VARCHAR)
+CreateLogicalType(::Type{T}) where {T <: Bool} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_BOOLEAN)
+CreateLogicalType(::Type{T}) where {T <: Int8} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_TINYINT)
+CreateLogicalType(::Type{T}) where {T <: Int16} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_SMALLINT)
+CreateLogicalType(::Type{T}) where {T <: Int32} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_INTEGER)
+CreateLogicalType(::Type{T}) where {T <: Int64} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_BIGINT)
+CreateLogicalType(::Type{T}) where {T <: UInt8} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_UTINYINT)
+CreateLogicalType(::Type{T}) where {T <: UInt16} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_USMALLINT)
+CreateLogicalType(::Type{T}) where {T <: UInt32} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_UINTEGER)
+CreateLogicalType(::Type{T}) where {T <: UInt64} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_UBIGINT)
+CreateLogicalType(::Type{T}) where {T <: Float32} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_FLOAT)
+CreateLogicalType(::Type{T}) where {T <: Float64} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_DOUBLE)
+CreateLogicalType(::Type{T}) where {T <: Date} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_DATE)
+CreateLogicalType(::Type{T}) where {T <: Time} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_TIME)
+CreateLogicalType(::Type{T}) where {T <: DateTime} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_TIMESTAMP)
+CreateLogicalType(::Type{T}) where {T <: AbstractString} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_VARCHAR)
+
+function CreateLogicalType(::Type{T}) where {T}
+    throw(NotImplementedException("Unsupported type for CreateLogicalType"))
+end
+
+function GetTypeId(type::LogicalType)
+    return duckdb_get_type_id(type.handle)
+end
+
+function GetInternalTypeId(type::LogicalType)
+    type_id = GetTypeId(type)
+    if type_id == DUCKDB_TYPE_DECIMAL
+        type_id = duckdb_decimal_internal_type(type.handle)
+    elseif type_id == DUCKDB_TYPE_ENUM
+        type_id = duckdb_enum_internal_type(type.handle)
+    end
+    return type_id
+end
+
+function GetDecimalScale(type::LogicalType)
+    return duckdb_decimal_scale(type.handle)
+end
+
+function GetEnumDictionary(type::LogicalType)
+    dict::Vector{String} = Vector{String}()
+    dict_size = duckdb_enum_dictionary_size(type.handle)
+    for i in 1:dict_size
+        val = duckdb_enum_dictionary_value(type.handle, i)
+        str_val = String(unsafe_string(val))
+        push!(dict, str_val)
+        duckdb_free(val)
+    end
+    return dict
+end
+
+function GetListChildType(type::LogicalType)
+    return LogicalType(duckdb_list_type_child_type(type.handle))
+end
+
+function GetStructChildCount(type::LogicalType)
+    return duckdb_struct_type_child_count(type.handle)
+end
+
+function GetStructChildName(type::LogicalType, index::UInt64)
+    val = duckdb_struct_type_child_name(type.handle, index)
+    result = unsafe_string(val)
+    duckdb_free(val)
+    return result
+end
+
+function GetStructChildType(type::LogicalType, index::UInt64)
+    return LogicalType(duckdb_struct_type_child_type(type.handle, index))
+end
diff --git a/tools/juliapkg/src/old_interface.jl b/tools/juliapkg/src/old_interface.jl
new file mode 100644
index 000000000000..89c887db3b6d
--- /dev/null
+++ b/tools/juliapkg/src/old_interface.jl
@@ -0,0 +1,21 @@
+# old interface, deprecated
+using DataFrames
+
+open(dbpath::AbstractString) = DBInterface.connect(DuckDB.DB, dbpath)
+
+connect(db::DB) = DBInterface.connect(db)
+
+disconnect(con::Connection) = DBInterface.close!(con)
+close(db::DB) = DBInterface.close!(db)
+
+toDataFrame(res::QueryResult) = res.df
+toDataFrame(con::Connection, sql::AbstractString) = toDataFrame(DBInterface.execute(con, sql))
+
+function appendDataFrame(input_df::DataFrame, con::Connection, table::AbstractString, schema::String = "main")
+    RegisterDataFrame(con, input_df, "__append_df")
+    DBInterface.execute(con, "INSERT INTO \"$schema\".\"$table\" SELECT * FROM __append_df")
+    return UnregisterDataFrame(con, "__append_df")
+end
+
+appendDataFrame(input_df::DataFrame, db::DB, table::AbstractString, schema::String = "main") =
+    appendDataFrame(input_df, db.main_connection, table, schema)
diff --git a/tools/juliapkg/src/replacement_scan.jl b/tools/juliapkg/src/replacement_scan.jl
new file mode 100644
index 000000000000..9070b149f438
--- /dev/null
+++ b/tools/juliapkg/src/replacement_scan.jl
@@ -0,0 +1,67 @@
+
+
+mutable struct ReplacementFunction
+    db::DB
+    replacement_func::Function
+    extra_data::Any
+end
+
+struct ReplacementFunctionInfo
+    handle::duckdb_replacement_scan_info
+    main_function::ReplacementFunction
+    table_name::String
+
+    function ReplacementFunctionInfo(
+        handle::duckdb_replacement_scan_info,
+        main_function::ReplacementFunction,
+        table_name::String
+    )
+        result = new(handle, main_function, table_name)
+        return result
+    end
+end
+
+function _replacement_scan_function(handle::duckdb_replacement_scan_info, table_name::Ptr{UInt8}, data::Ptr{Cvoid})
+    func::ReplacementFunction = unsafe_pointer_to_objref(data)
+    tname = unsafe_string(table_name)
+    info = ReplacementFunctionInfo(handle, func, tname)
+    func.replacement_func(info)
+    return
+end
+
+function GetDB(info::ReplacementFunctionInfo)
+    return info.main_function.db
+end
+
+function GetExtraData(info::ReplacementFunctionInfo)
+    return info.main_function.extra_data
+end
+
+function GetTableName(info::ReplacementFunctionInfo)
+    return info.table_name
+end
+
+function SetFunctionName(info::ReplacementFunctionInfo, function_name::String)
+    return duckdb_replacement_scan_set_function_name(info.handle, function_name)
+end
+
+function AddFunctionParameter(info::ReplacementFunctionInfo, parameter::Value)
+    return duckdb_replacement_scan_add_parameter(info.handle, parameter.handle)
+end
+
+function _replacement_func_cleanup(data::Ptr{Cvoid})
+    info::ReplacementFunction = unsafe_pointer_to_objref(data)
+    delete!(global_objects, info)
+    return
+end
+
+function AddReplacementScan(db::DB, replacement_func::Function, extra_data::Any)
+    func = ReplacementFunction(db, replacement_func, extra_data)
+    push!(global_objects, func)
+    return duckdb_add_replacement_scan(
+        db.handle.handle,
+        @cfunction(_replacement_scan_function, Cvoid, (duckdb_replacement_scan_info, Ptr{UInt8}, Ptr{Cvoid})),
+        pointer_from_objref(func),
+        @cfunction(_replacement_func_cleanup, Cvoid, (Ptr{Cvoid},))
+    )
+end
diff --git a/tools/juliapkg/src/result.jl b/tools/juliapkg/src/result.jl
new file mode 100644
index 000000000000..6461224f9b05
--- /dev/null
+++ b/tools/juliapkg/src/result.jl
@@ -0,0 +1,596 @@
+
+mutable struct QueryResult
+    handle::Ref{duckdb_result}
+    df::DataFrame
+
+    function QueryResult(handle::Ref{duckdb_result})
+        df = toDataFrame(handle)
+
+        result = new(handle, df)
+        finalizer(_close_result, result)
+        return result
+    end
+end
+
+function _close_result(result::QueryResult)
+    return duckdb_destroy_result(result.handle)
+end
+
+mutable struct ColumnConversionData
+    chunks::Vector{DataChunk}
+    col_idx::Int64
+    logical_type::LogicalType
+    conversion_data::Any
+end
+
+mutable struct ListConversionData
+    conversion_func::Function
+    conversion_loop_func::Function
+    child_type::LogicalType
+    internal_type::Type
+    target_type::Type
+    child_conversion_data::Any
+end
+
+mutable struct StructConversionData
+    tuple_type::Any
+    child_conversion_data::Vector{ListConversionData}
+end
+
+function nop_convert(column_data::ColumnConversionData, val)
+    return val
+end
+
+function convert_string(column_data::ColumnConversionData, val::Ptr{Cvoid}, idx::UInt64)
+    base_ptr = val + (idx - 1) * sizeof(duckdb_string_t)
+    length_ptr = Base.unsafe_convert(Ptr{Int32}, base_ptr)
+    length = unsafe_load(length_ptr)
+    if length <= STRING_INLINE_LENGTH
+        prefix_ptr = Base.unsafe_convert(Ptr{UInt8}, base_ptr + sizeof(Int32))
+        return unsafe_string(prefix_ptr, length)
+    else
+        ptr_ptr = Base.unsafe_convert(Ptr{Ptr{UInt8}}, base_ptr + sizeof(Int32) * 2)
+        data_ptr = Base.unsafe_load(ptr_ptr)
+        return unsafe_string(data_ptr, length)
+    end
+end
+
+function convert_blob(column_data::ColumnConversionData, val::Ptr{Cvoid}, idx::UInt64)::Base.CodeUnits{UInt8, String}
+    return Base.codeunits(convert_string(column_data, val, idx))
+end
+
+function convert_date(column_data::ColumnConversionData, val::Int32)::Date
+    return Dates.epochdays2date(val + ROUNDING_EPOCH_TO_UNIX_EPOCH_DAYS)
+end
+
+function convert_time(column_data::ColumnConversionData, val::Int64)::Time
+    return Dates.Time(Dates.Nanosecond(val * 1000))
+end
+
+function convert_timestamp(column_data::ColumnConversionData, val::Int64)::DateTime
+    return Dates.epochms2datetime((val  1000) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)
+end
+
+function convert_timestamp_s(column_data::ColumnConversionData, val::Int64)::DateTime
+    return Dates.epochms2datetime((val * 1000) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)
+end
+
+function convert_timestamp_ms(column_data::ColumnConversionData, val::Int64)::DateTime
+    return Dates.epochms2datetime((val) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)
+end
+
+function convert_timestamp_ns(column_data::ColumnConversionData, val::Int64)::DateTime
+    return Dates.epochms2datetime((val  1000000) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)
+end
+
+function convert_interval(column_data::ColumnConversionData, val::duckdb_interval)::Dates.CompoundPeriod
+    return Dates.CompoundPeriod(Dates.Month(val.months), Dates.Day(val.days), Dates.Microsecond(val.micros))
+end
+
+function convert_hugeint(column_data::ColumnConversionData, val::duckdb_hugeint)::Int128
+    return Int128(val.lower) + Int128(val.upper) << 64
+end
+
+function convert_uuid(column_data::ColumnConversionData, val::duckdb_hugeint)::UUID
+    hugeint = convert_hugeint(column_data, val)
+    base_value = Int128(170141183460469231731687303715884105727)
+    if hugeint < 0
+        return UUID(UInt128(hugeint + base_value) + 1)
+    else
+        return UUID(UInt128(hugeint) + base_value + 1)
+    end
+end
+
+function convert_enum(column_data::ColumnConversionData, val)::String
+    return column_data.conversion_data[val + 1]
+end
+
+function convert_decimal_hugeint(column_data::ColumnConversionData, val::duckdb_hugeint)::Float64
+    return convert_hugeint(column_data, val) / column_data.conversion_data
+end
+
+function convert_decimal(column_data::ColumnConversionData, val)::Float64
+    return val / column_data.conversion_data
+end
+
+function convert_vector(
+    column_data::ColumnConversionData,
+    vector::Vec,
+    size::UInt64,
+    convert_func::Function,
+    result,
+    position,
+    all_valid,
+    ::Type{SRC},
+    ::Type{DST}
+) where {SRC, DST}
+    array = GetArray(vector, SRC)
+    if !all_valid
+        validity = GetValidity(vector)
+    end
+    for i in 1:size
+        if all_valid || IsValid(validity, i)
+            result[position] = convert_func(column_data, array[i])
+        end
+        position += 1
+    end
+    return size
+end
+
+function convert_vector_string(
+    column_data::ColumnConversionData,
+    vector::Vec,
+    size::UInt64,
+    convert_func::Function,
+    result,
+    position,
+    all_valid,
+    ::Type{SRC},
+    ::Type{DST}
+) where {SRC, DST}
+    raw_ptr = duckdb_vector_get_data(vector.handle)
+    ptr = Base.unsafe_convert(Ptr{duckdb_string_t}, raw_ptr)
+    if !all_valid
+        validity = GetValidity(vector)
+    end
+    for i in 1:size
+        if all_valid || IsValid(validity, i)
+            result[position] = convert_func(column_data, raw_ptr, i)
+        end
+        position += 1
+    end
+    return size
+end
+
+function convert_vector_list(
+    column_data::ColumnConversionData,
+    vector::Vec,
+    size::UInt64,
+    convert_func::Function,
+    result,
+    position,
+    all_valid,
+    ::Type{SRC},
+    ::Type{DST}
+) where {SRC, DST}
+    child_vector = ListChild(vector)
+    list_size = ListSize(vector)
+
+    # convert the child vector
+    ldata = column_data.conversion_data
+
+    child_column_data =
+        ColumnConversionData(column_data.chunks, column_data.col_idx, ldata.child_type, ldata.child_conversion_data)
+    child_array = Array{Union{Missing, ldata.target_type}}(missing, list_size)
+    ldata.conversion_loop_func(
+        child_column_data,
+        child_vector,
+        list_size,
+        ldata.conversion_func,
+        child_array,
+        1,
+        false,
+        ldata.internal_type,
+        ldata.target_type
+    )
+
+    array = GetArray(vector, SRC)
+    if !all_valid
+        validity = GetValidity(vector)
+    end
+    for i in 1:size
+        if all_valid || IsValid(validity, i)
+            start_offset::UInt64 = array[i].offset + 1
+            end_offset::UInt64 = array[i].offset + array[i].length
+            result[position] = child_array[start_offset:end_offset]
+        end
+        position += 1
+    end
+    return size
+end
+
+function convert_struct_children(column_data::ColumnConversionData, vector::Vec, size::UInt64)
+    # convert the child vectors of the struct
+    child_count = GetStructChildCount(column_data.logical_type)
+    child_arrays = Vector()
+    for i in 1:child_count
+        child_vector = StructChild(vector, i)
+        ldata = column_data.conversion_data.child_conversion_data[i]
+
+        child_column_data =
+            ColumnConversionData(column_data.chunks, column_data.col_idx, ldata.child_type, ldata.child_conversion_data)
+        child_array = Array{Union{Missing, ldata.target_type}}(missing, size)
+        ldata.conversion_loop_func(
+            child_column_data,
+            child_vector,
+            size,
+            ldata.conversion_func,
+            child_array,
+            1,
+            false,
+            ldata.internal_type,
+            ldata.target_type
+        )
+        push!(child_arrays, child_array)
+    end
+    return child_arrays
+end
+
+
+function convert_vector_struct(
+    column_data::ColumnConversionData,
+    vector::Vec,
+    size::UInt64,
+    convert_func::Function,
+    result,
+    position,
+    all_valid,
+    ::Type{SRC},
+    ::Type{DST}
+) where {SRC, DST}
+    child_count = GetStructChildCount(column_data.logical_type)
+    child_arrays = convert_struct_children(column_data, vector, size)
+
+    if !all_valid
+        validity = GetValidity(vector)
+    end
+    for i in 1:size
+        if all_valid || IsValid(validity, i)
+            result_tuple = Vector()
+            for child_idx in 1:child_count
+                push!(result_tuple, child_arrays[child_idx][i])
+            end
+            result[position] = NamedTuple{column_data.conversion_data.tuple_type}(result_tuple)
+        end
+        position += 1
+    end
+    return size
+end
+
+function convert_vector_map(
+    column_data::ColumnConversionData,
+    vector::Vec,
+    size::UInt64,
+    convert_func::Function,
+    result,
+    position,
+    all_valid,
+    ::Type{SRC},
+    ::Type{DST}
+) where {SRC, DST}
+    child_arrays = convert_struct_children(column_data, vector, size)
+    keys = child_arrays[1]
+    values = child_arrays[2]
+
+    if !all_valid
+        validity = GetValidity(vector)
+    end
+    for i in 1:size
+        if all_valid || IsValid(validity, i)
+            result_dict = Dict()
+            key_count = length(keys[i])
+            for key_idx in 1:key_count
+                result_dict[keys[i][key_idx]] = values[i][key_idx]
+            end
+            result[position] = result_dict
+        end
+        position += 1
+    end
+    return size
+end
+
+function convert_column_loop(
+    column_data::ColumnConversionData,
+    convert_func::Function,
+    ::Type{SRC},
+    ::Type{DST},
+    convert_vector_func::Function
+) where {SRC, DST}
+    # first check if there are null values in any chunks
+    has_missing = false
+    row_count = 0
+    for chunk in column_data.chunks
+        if !AllValid(chunk, column_data.col_idx)
+            has_missing = true
+        end
+        row_count += GetSize(chunk)
+    end
+    if has_missing
+        # missing values
+        result = Array{Union{Missing, DST}}(missing, row_count)
+        position = 1
+        for chunk in column_data.chunks
+            position += convert_vector_func(
+                column_data,
+                GetVector(chunk, column_data.col_idx),
+                GetSize(chunk),
+                convert_func,
+                result,
+                position,
+                AllValid(chunk, column_data.col_idx),
+                SRC,
+                DST
+            )
+        end
+    else
+        # no missing values
+        result = Array{DST}(undef, row_count)
+        position = 1
+        for chunk in column_data.chunks
+            position += convert_vector_func(
+                column_data,
+                GetVector(chunk, column_data.col_idx),
+                GetSize(chunk),
+                convert_func,
+                result,
+                position,
+                true,
+                SRC,
+                DST
+            )
+        end
+    end
+    return result
+end
+
+function create_child_conversion_data(child_type::LogicalType)
+    internal_type_id = GetInternalTypeId(child_type)
+    internal_type = duckdb_type_to_internal_type(internal_type_id)
+    target_type = duckdb_type_to_julia_type(child_type)
+
+    conversion_func = get_conversion_function(child_type)
+    conversion_loop_func = get_conversion_loop_function(child_type)
+    child_conversion_data = init_conversion_loop(child_type)
+    return ListConversionData(
+        conversion_func,
+        conversion_loop_func,
+        child_type,
+        internal_type,
+        target_type,
+        child_conversion_data
+    )
+end
+
+function init_conversion_loop(logical_type::LogicalType)
+    type = GetTypeId(logical_type)
+    if type == DUCKDB_TYPE_DECIMAL
+        return 10^GetDecimalScale(logical_type)
+    elseif type == DUCKDB_TYPE_ENUM
+        return GetEnumDictionary(logical_type)
+    elseif type == DUCKDB_TYPE_LIST
+        child_type = GetListChildType(logical_type)
+        return create_child_conversion_data(child_type)
+    elseif type == DUCKDB_TYPE_STRUCT || type == DUCKDB_TYPE_MAP
+        child_count = GetStructChildCount(logical_type)
+        child_symbols::Vector{Symbol} = Vector()
+        child_data::Vector{ListConversionData} = Vector()
+        for i in 1:child_count
+            child_symbol = Symbol(GetStructChildName(logical_type, i))
+            child_type = GetStructChildType(logical_type, i)
+            child_conv_data = create_child_conversion_data(child_type)
+            push!(child_symbols, child_symbol)
+            push!(child_data, child_conv_data)
+        end
+        return StructConversionData(Tuple(x for x in child_symbols), child_data)
+    else
+        return nothing
+    end
+end
+
+function get_conversion_function(logical_type::LogicalType)::Function
+    type = GetTypeId(logical_type)
+    if type == DUCKDB_TYPE_VARCHAR || type == DUCKDB_TYPE_JSON
+        return convert_string
+    elseif type == DUCKDB_TYPE_BLOB
+        return convert_blob
+    elseif type == DUCKDB_TYPE_DATE
+        return convert_date
+    elseif type == DUCKDB_TYPE_TIME
+        return convert_time
+    elseif type == DUCKDB_TYPE_TIMESTAMP
+        return convert_timestamp
+    elseif type == DUCKDB_TYPE_TIMESTAMP_S
+        return convert_timestamp_s
+    elseif type == DUCKDB_TYPE_TIMESTAMP_MS
+        return convert_timestamp_ms
+    elseif type == DUCKDB_TYPE_TIMESTAMP_NS
+        return convert_timestamp_ns
+    elseif type == DUCKDB_TYPE_INTERVAL
+        return convert_interval
+    elseif type == DUCKDB_TYPE_HUGEINT
+        return convert_hugeint
+    elseif type == DUCKDB_TYPE_UUID
+        return convert_uuid
+    elseif type == DUCKDB_TYPE_DECIMAL
+        internal_type_id = GetInternalTypeId(logical_type)
+        if internal_type_id == DUCKDB_TYPE_HUGEINT
+            return convert_decimal_hugeint
+        else
+            return convert_decimal
+        end
+    elseif type == DUCKDB_TYPE_ENUM
+        return convert_enum
+    else
+        return nop_convert
+    end
+end
+
+function get_conversion_loop_function(logical_type::LogicalType)::Function
+    type = GetTypeId(logical_type)
+    if type == DUCKDB_TYPE_VARCHAR || type == DUCKDB_TYPE_BLOB || type == DUCKDB_TYPE_JSON
+        return convert_vector_string
+    elseif type == DUCKDB_TYPE_LIST
+        return convert_vector_list
+    elseif type == DUCKDB_TYPE_STRUCT
+        return convert_vector_struct
+    elseif type == DUCKDB_TYPE_MAP
+        return convert_vector_map
+    else
+        return convert_vector
+    end
+end
+
+function convert_column(column_data::ColumnConversionData)
+    internal_type_id = GetInternalTypeId(column_data.logical_type)
+    internal_type = duckdb_type_to_internal_type(internal_type_id)
+    target_type = duckdb_type_to_julia_type(column_data.logical_type)
+
+    conversion_func = get_conversion_function(column_data.logical_type)
+    conversion_loop_func = get_conversion_loop_function(column_data.logical_type)
+
+    column_data.conversion_data = init_conversion_loop(column_data.logical_type)
+    return convert_column_loop(column_data, conversion_func, internal_type, target_type, conversion_loop_func)
+end
+
+function toDataFrame(result::Ref{duckdb_result})::DataFrame
+    column_count = duckdb_column_count(result)
+    # duplicate eliminate the names
+    names = Vector{Symbol}(undef, column_count)
+    for i in 1:column_count
+        name = sym(duckdb_column_name(result, i))
+        if name in view(names, 1:(i - 1))
+            j = 1
+            new_name = Symbol(name, :_, j)
+            while new_name in view(names, 1:(i - 1))
+                j += 1
+                new_name = Symbol(name, :_, j)
+            end
+            name = new_name
+        end
+        names[i] = name
+    end
+    # gather all the data chunks
+    chunk_count = duckdb_result_chunk_count(result[])
+    chunks::Vector{DataChunk} = []
+    for i in 1:chunk_count
+        push!(chunks, DataChunk(duckdb_result_get_chunk(result[], i), true))
+    end
+
+    df = DataFrame()
+    for i in 1:column_count
+        name = names[i]
+        logical_type = LogicalType(duckdb_column_logical_type(result, i))
+        column_data = ColumnConversionData(chunks, i, logical_type, nothing)
+        df[!, name] = convert_column(column_data)
+    end
+    return df
+end
+
+function execute(stmt::Stmt, params::DBInterface.StatementParams = ())
+    BindParameters(stmt, params)
+
+    handle = Ref{duckdb_result}()
+    if duckdb_execute_prepared(stmt.handle, handle) != DuckDBSuccess
+        error_ptr = duckdb_result_error(handle)
+        if error_ptr == C_NULL
+            error_message = string("Execute of query \"", stmt.sql, "\" failed: unknown error")
+        else
+            error_message = string("Execute of query \"", stmt.sql, "\" failed: ", unsafe_string(error_ptr))
+        end
+        duckdb_destroy_result(handle)
+        throw(QueryException(error_message))
+    end
+    return QueryResult(handle)
+end
+
+# explicitly close prepared statement
+function DBInterface.close!(stmt::Stmt)
+    return _close_stmt(stmt)
+end
+
+function execute(con::Connection, sql::AbstractString, params::DBInterface.StatementParams)
+    stmt = Stmt(con, sql)
+    try
+        return execute(stmt, params)
+    finally
+        _close_stmt(stmt) # immediately close, don't wait for GC
+    end
+end
+
+execute(con::Connection, sql::AbstractString; kwargs...) = execute(con, sql, values(kwargs))
+execute(db::DB, sql::AbstractString, params::DBInterface.StatementParams) = execute(db.main_connection, sql, params)
+execute(db::DB, sql::AbstractString; kwargs...) = execute(db.main_connection, sql, values(kwargs))
+
+Tables.isrowtable(::Type{QueryResult}) = true
+Tables.columnnames(q::QueryResult) = Tables.columnnames(q.df)
+
+function Tables.schema(q::QueryResult)
+    return Tables.schema(q.df)
+end
+
+Base.IteratorSize(::Type{QueryResult}) = Base.SizeUnknown()
+Base.eltype(q::QueryResult) = Any
+
+function DBInterface.close!(q::QueryResult)
+    return _close_result(q)
+end
+
+function Base.iterate(q::QueryResult)
+    return Base.iterate(eachrow(q.df))
+end
+
+function Base.iterate(q::QueryResult, state)
+    return Base.iterate(eachrow(q.df), state)
+end
+
+DataFrames.DataFrame(q::QueryResult) = DataFrame(q.df)
+
+"Return the last row insert id from the executed statement"
+function DBInterface.lastrowid(con::Connection)
+    throw(NotImplementedException("Unimplemented: lastrowid"))
+end
+
+DBInterface.lastrowid(db::DB) = DBInterface.lastrowid(db.main_connection)
+
+"""
+    DBInterface.prepare(db::DuckDB.DB, sql::AbstractString)
+
+Prepare an SQL statement given as a string in the DuckDB database; returns a `DuckDB.Stmt` object.
+See `DBInterface.execute`(@ref) for information on executing a prepared statement and passing parameters to bind.
+A `DuckDB.Stmt` object can be closed (resources freed) using `DBInterface.close!`(@ref).
+"""
+DBInterface.prepare(con::Connection, sql::AbstractString) = Stmt(con, sql)
+DBInterface.prepare(db::DB, sql::AbstractString) = DBInterface.prepare(db.main_connection, sql)
+
+"""
+    DBInterface.execute(db::DuckDB.DB, sql::String, [params])
+    DBInterface.execute(stmt::SQLite.Stmt, [params])
+
+Bind any positional (`params` as `Vector` or `Tuple`) or named (`params` as `NamedTuple` or `Dict`) parameters to an SQL statement, given by `db` and `sql` or
+as an already prepared statement `stmt`, execute the query and return an iterator of result rows.
+
+Note that the returned result row iterator only supports a single-pass, forward-only iteration of the result rows.
+Calling `SQLite.reset!(result)` will re-execute the query and reset the iterator back to the beginning.
+
+The resultset iterator supports the [Tables.jl](https://github.com/JuliaData/Tables.jl) interface, so results can be collected in any Tables.jl-compatible sink,
+like `DataFrame(results)`, `CSV.write("results.csv", results)`, etc.
+"""
+function DBInterface.execute(stmt::Stmt, params::DBInterface.StatementParams)
+    return execute(stmt, params)
+end
+
+function DBInterface.execute(con::Connection, sql::AbstractString)
+    return execute(Stmt(con, sql))
+end
+
+Base.show(io::IO, result::DuckDB.QueryResult) = print(io, result.df)
diff --git a/tools/juliapkg/src/statement.jl b/tools/juliapkg/src/statement.jl
new file mode 100644
index 000000000000..e737b1aa463c
--- /dev/null
+++ b/tools/juliapkg/src/statement.jl
@@ -0,0 +1,68 @@
+mutable struct Stmt <: DBInterface.Statement
+    con::Connection
+    handle::duckdb_prepared_statement
+    sql::AbstractString
+
+    function Stmt(con::Connection, sql::AbstractString)
+        handle = Ref{duckdb_prepared_statement}()
+        if duckdb_prepare(con.handle, sql, handle) != DuckDBSuccess
+            error_message = unsafe_string(duckdb_prepare_error(handle))
+            duckdb_destroy_prepare(handle)
+            throw(QueryException(error_message))
+        end
+        stmt = new(con, handle[], sql)
+        finalizer(_close_stmt, stmt)
+        return stmt
+    end
+
+    function Stmt(db::DB, sql::AbstractString)
+        return Stmt(db.main_connection, sql)
+    end
+end
+
+function _close_stmt(stmt::Stmt)
+    if stmt.handle != C_NULL
+        duckdb_destroy_prepare(stmt.handle)
+    end
+    stmt.handle = C_NULL
+    return
+end
+
+DBInterface.getconnection(stmt::Stmt) = stmt.con
+
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::AbstractFloat) = duckdb_bind_double(stmt.handle, i, Float64(val));
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Bool) = duckdb_bind_boolean(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Int8) = duckdb_bind_int8(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Int16) = duckdb_bind_int16(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Int32) = duckdb_bind_int32(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Int64) = duckdb_bind_int64(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::UInt8) = duckdb_bind_uint8(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::UInt16) = duckdb_bind_uint16(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::UInt32) = duckdb_bind_uint32(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::UInt64) = duckdb_bind_uint64(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Float32) = duckdb_bind_float(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Float64) = duckdb_bind_double(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Date) = duckdb_bind_date(stmt.handle, i, ValueToDuckDB(val));
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Time) = duckdb_bind_time(stmt.handle, i, ValueToDuckDB(val));
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::DateTime) = duckdb_bind_timestamp(stmt.handle, i, ValueToDuckDB(val));
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Missing) = duckdb_bind_null(stmt.handle, i);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Nothing) = duckdb_bind_null(stmt.handle, i);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::AbstractString) = duckdb_bind_varchar(stmt.handle, i, val);
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Vector{UInt8}) = duckdb_bind_blob(stmt.handle, i, val, sizeof(val));
+duckdb_bind_internal(stmt::Stmt, i::Integer, val::WeakRefString{UInt8}) =
+    duckdb_bind_varchar(stmt.handle, i, val.ptr, val.len);
+
+function duckdb_bind_internal(stmt::Stmt, i::Integer, val::Any)
+    println(val)
+    throw(NotImplementedException("unsupported type for bind"))
+end
+
+function BindParameters(stmt::Stmt, params::DBInterface.StatementParams)
+    i = 1
+    for param in params
+        if duckdb_bind_internal(stmt, i, param) != DuckDBSuccess
+            throw(QueryException("Failed to bind parameter"))
+        end
+        i += 1
+    end
+end
diff --git a/tools/juliapkg/src/table_function.jl b/tools/juliapkg/src/table_function.jl
new file mode 100644
index 000000000000..3ff390c66575
--- /dev/null
+++ b/tools/juliapkg/src/table_function.jl
@@ -0,0 +1,245 @@
+global_objects = Set()
+
+#=
+//===--------------------------------------------------------------------===//
+// Table Function Bind
+//===--------------------------------------------------------------------===//
+=#
+struct BindInfo
+    handle::duckdb_bind_info
+    main_function::Any
+
+    function BindInfo(handle::duckdb_bind_info, main_function)
+        result = new(handle, main_function)
+        return result
+    end
+end
+
+mutable struct InfoWrapper
+    info::Any
+
+    function InfoWrapper(info)
+        return new(info)
+    end
+end
+
+function ParameterCount(bind_info::BindInfo)
+    return duckdb_bind_get_parameter_count(bind_info.handle)
+end
+
+function GetParameter(bind_info::BindInfo, index::Int64)
+    return Value(duckdb_bind_get_parameter(bind_info.handle, index))
+end
+
+function AddResultColumn(bind_info::BindInfo, name::AbstractString, type::DataType)
+    return AddResultColumn(bind_info, name, CreateLogicalType(type))
+end
+
+function AddResultColumn(bind_info::BindInfo, name::AbstractString, type::LogicalType)
+    return duckdb_bind_add_result_column(bind_info.handle, name, type.handle)
+end
+
+function GetExtraData(bind_info::BindInfo)
+    return bind_info.main_function.extra_data
+end
+
+function _table_bind_cleanup(data::Ptr{Cvoid})
+    info::InfoWrapper = unsafe_pointer_to_objref(data)
+    delete!(global_objects, info)
+    return
+end
+
+function _table_bind_function(info::duckdb_bind_info)
+    try
+        main_function = unsafe_pointer_to_objref(duckdb_bind_get_extra_info(info))
+        binfo = BindInfo(info, main_function)
+        bind_data = InfoWrapper(main_function.bind_func(binfo))
+        bind_data_pointer = pointer_from_objref(bind_data)
+        push!(global_objects, bind_data)
+        duckdb_bind_set_bind_data(info, bind_data_pointer, @cfunction(_table_bind_cleanup, Cvoid, (Ptr{Cvoid},)))
+    catch ex
+        duckdb_bind_set_error(info, sprint(showerror, ex))
+        return
+    end
+    return
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Table Function Init
+//===--------------------------------------------------------------------===//
+=#
+mutable struct InitInfo
+    handle::duckdb_init_info
+    main_function::Any
+
+    function InitInfo(handle::duckdb_init_info, main_function)
+        result = new(handle, main_function)
+        return result
+    end
+end
+
+function _table_init_function(info::duckdb_init_info)
+    try
+        main_function = unsafe_pointer_to_objref(duckdb_init_get_extra_info(info))
+        binfo = InitInfo(info, main_function)
+        init_data = InfoWrapper(main_function.init_func(binfo))
+        init_data_pointer = pointer_from_objref(init_data)
+        push!(global_objects, init_data)
+        duckdb_init_set_init_data(info, init_data_pointer, @cfunction(_table_bind_cleanup, Cvoid, (Ptr{Cvoid},)))
+    catch ex
+        duckdb_init_set_error(info, sprint(showerror, ex))
+        return
+    end
+    return
+end
+
+function GetBindInfo(info::InitInfo, ::Type{T})::T where {T}
+    return unsafe_pointer_to_objref(duckdb_init_get_bind_data(info.handle)).info
+end
+
+function GetExtraData(info::InitInfo)
+    return info.main_function.extra_data
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Main Table Function
+//===--------------------------------------------------------------------===//
+=#
+mutable struct FunctionInfo
+    handle::duckdb_function_info
+    main_function::Any
+
+    function FunctionInfo(handle::duckdb_function_info, main_function)
+        result = new(handle, main_function)
+        return result
+    end
+end
+
+function GetBindInfo(info::FunctionInfo, ::Type{T})::T where {T}
+    return unsafe_pointer_to_objref(duckdb_function_get_bind_data(info.handle)).info
+end
+
+function GetInitInfo(info::FunctionInfo, ::Type{T})::T where {T}
+    return unsafe_pointer_to_objref(duckdb_function_get_init_data(info.handle)).info
+end
+
+function _table_main_function(info::duckdb_function_info, chunk::duckdb_data_chunk)
+    main_function = unsafe_pointer_to_objref(duckdb_function_get_extra_info(info))
+    binfo = FunctionInfo(info, main_function)
+    try
+        main_function.main_func(binfo, DataChunk(chunk, false))
+    catch ex
+        duckdb_function_set_error(info, sprint(showerror, ex))
+    end
+    return
+end
+
+#=
+//===--------------------------------------------------------------------===//
+// Table Function
+//===--------------------------------------------------------------------===//
+=#
+"""
+DuckDB table function
+"""
+mutable struct TableFunction
+    handle::duckdb_table_function
+    bind_func::Function
+    init_func::Function
+    main_func::Function
+    extra_data::Any
+
+    function TableFunction(
+        name::AbstractString,
+        parameters::Vector{LogicalType},
+        bind_func::Function,
+        init_func::Function,
+        main_func::Function,
+        extra_data::Any
+    )
+        handle = duckdb_create_table_function()
+        duckdb_table_function_set_name(handle, name)
+        for param in parameters
+            duckdb_table_function_add_parameter(handle, param.handle)
+        end
+        result = new(handle, bind_func, init_func, main_func, extra_data)
+        finalizer(_destroy_table_function, result)
+
+        duckdb_table_function_set_extra_info(handle, pointer_from_objref(result))
+        duckdb_table_function_set_bind(handle, @cfunction(_table_bind_function, Cvoid, (duckdb_bind_info,)))
+        duckdb_table_function_set_init(handle, @cfunction(_table_init_function, Cvoid, (duckdb_init_info,)))
+        duckdb_table_function_set_function(
+            handle,
+            @cfunction(_table_main_function, Cvoid, (duckdb_function_info, duckdb_data_chunk))
+        )
+
+        return result
+    end
+end
+
+function _destroy_table_function(func::TableFunction)
+    # disconnect from DB
+    if func.handle != C_NULL
+        duckdb_destroy_table_function(func.handle)
+    end
+    return func.handle = C_NULL
+end
+
+function CreateTableFunction(
+    con::Connection,
+    name::AbstractString,
+    parameters::Vector{LogicalType},
+    bind_func::Function,
+    init_func::Function,
+    main_func::Function,
+    extra_data::Any = missing
+)
+    fun = TableFunction(name, parameters, bind_func, init_func, main_func, extra_data)
+    if duckdb_register_table_function(con.handle, fun.handle) != DuckDBSuccess
+        throw(QueryException(string("Failed to register table function \"", name, "\"")))
+    end
+    push!(con.db.functions, fun)
+    return
+end
+
+function CreateTableFunction(
+    con::Connection,
+    name::AbstractString,
+    parameters::Vector{DataType},
+    bind_func::Function,
+    init_func::Function,
+    main_func::Function,
+    extra_data::Any = missing
+)
+    parameter_types::Vector{LogicalType} = Vector()
+    for parameter_type in parameters
+        push!(parameter_types, CreateLogicalType(parameter_type))
+    end
+    return CreateTableFunction(con, name, parameter_types, bind_func, init_func, main_func, extra_data)
+end
+
+function CreateTableFunction(
+    db::DB,
+    name::AbstractString,
+    parameters::Vector{LogicalType},
+    bind_func::Function,
+    init_func::Function,
+    main_func::Function,
+    extra_data::Any = missing
+)
+    return CreateTableFunction(db.main_connection, name, parameters, bind_func, init_func, main_func)
+end
+
+function CreateTableFunction(
+    db::DB,
+    name::AbstractString,
+    parameters::Vector{DataType},
+    bind_func::Function,
+    init_func::Function,
+    main_func::Function,
+    extra_data::Any = missing
+)
+    return CreateTableFunction(db.main_connection, name, parameters, bind_func, init_func, main_func)
+end
diff --git a/tools/juliapkg/src/transaction.jl b/tools/juliapkg/src/transaction.jl
new file mode 100644
index 000000000000..4a57f5eb70c4
--- /dev/null
+++ b/tools/juliapkg/src/transaction.jl
@@ -0,0 +1,48 @@
+
+function DBInterface.transaction(f, con::Connection)
+    begin_transaction(con)
+    try
+        f()
+    catch
+        rollback(con)
+        rethrow()
+    finally
+        commit(con)
+    end
+end
+
+function DBInterface.transaction(f, db::DB)
+    return DBInterface.transaction(f, db.main_connection)
+end
+
+"""
+    DuckDB.begin(db)
+
+begin a transaction
+"""
+function begin_transaction end
+
+begin_transaction(con::Connection) = execute(con, "BEGIN TRANSACTION;")
+begin_transaction(db::DB) = begin_transaction(db.main_connection)
+transaction(con::Connection) = begin_transaction(con)
+transaction(db::DB) = begin_transaction(db)
+
+"""
+    DuckDB.commit(db)
+
+commit a transaction
+"""
+function commit end
+
+commit(con::Connection) = execute(con, "COMMIT TRANSACTION;")
+commit(db::DB) = commit(db.main_connection)
+
+"""
+    DuckDB.rollback(db)
+
+rollback transaction
+"""
+function rollback end
+
+rollback(con::Connection) = execute(con, "ROLLBACK TRANSACTION;")
+rollback(db::DB) = rollback(db.main_connection)
diff --git a/tools/juliapkg/src/validity_mask.jl b/tools/juliapkg/src/validity_mask.jl
new file mode 100644
index 000000000000..e55ec6a852f7
--- /dev/null
+++ b/tools/juliapkg/src/validity_mask.jl
@@ -0,0 +1,34 @@
+"""
+DuckDB validity mask
+"""
+mutable struct ValidityMask
+    data::Vector{UInt64}
+
+    function ValidityMask(data::Vector{UInt64})
+        result = new(data)
+        return result
+    end
+end
+
+const BITS_PER_VALUE = 64;
+
+function GetEntryIndex(row_idx)
+    return ((row_idx - 1)  BITS_PER_VALUE) + 1
+end
+
+function GetIndexInEntry(row_idx)
+    return (row_idx - 1) % BITS_PER_VALUE
+end
+
+function SetInvalid(mask::ValidityMask, index)
+    entry_idx = GetEntryIndex(index)
+    index_in_entry = GetIndexInEntry(index)
+    mask.data[entry_idx] &= ~(1 << index_in_entry)
+    return
+end
+
+function IsValid(mask::ValidityMask, index)::Bool
+    entry_idx = GetEntryIndex(index)
+    index_in_entry = GetIndexInEntry(index)
+    return (mask.data[entry_idx] & (1 << index_in_entry)) != 0
+end
diff --git a/tools/juliapkg/src/value.jl b/tools/juliapkg/src/value.jl
new file mode 100644
index 000000000000..5791d8c73554
--- /dev/null
+++ b/tools/juliapkg/src/value.jl
@@ -0,0 +1,37 @@
+"""
+DuckDB value
+"""
+mutable struct Value
+    handle::duckdb_value
+
+    function Value(handle::duckdb_value)
+        result = new(handle)
+        finalizer(_destroy_value, result)
+        return result
+    end
+end
+
+function _destroy_value(val::Value)
+    if val.handle != C_NULL
+        duckdb_destroy_value(val.handle)
+    end
+    val.handle = C_NULL
+    return
+end
+
+GetValue(val::Value, ::Type{T}) where {T <: Int64} = duckdb_get_int64(val.handle)
+function GetValue(val::Value, ::Type{T}) where {T <: String}
+    ptr = duckdb_get_varchar(val.handle)
+    result = unsafe_string(ptr)
+    duckdb_free(ptr)
+    return result
+end
+function GetValue(val::Value, ::Type{T}) where {T}
+    throw(NotImplementedException("Unsupported type for GetValue"))
+end
+
+
+CreateValue(val::T) where {T <: Int64} = Value(duckdb_create_int64(val))
+function CreateValue(val::T) where {T}
+    throw(NotImplementedException("Unsupported type for GetValue"))
+end
diff --git a/tools/juliapkg/src/vector.jl b/tools/juliapkg/src/vector.jl
new file mode 100644
index 000000000000..3357c4d81847
--- /dev/null
+++ b/tools/juliapkg/src/vector.jl
@@ -0,0 +1,45 @@
+"""
+DuckDB vector
+"""
+mutable struct Vec
+    handle::duckdb_vector
+
+    function Vec(handle::duckdb_vector)
+        result = new(handle)
+        return result
+    end
+end
+
+function GetArray(vector::Vec, ::Type{T})::Vector{T} where {T}
+    raw_ptr = duckdb_vector_get_data(vector.handle)
+    ptr = Base.unsafe_convert(Ptr{T}, raw_ptr)
+    return unsafe_wrap(Vector{T}, ptr, VECTOR_SIZE, own = false)
+end
+
+function GetValidity(vector::Vec)::ValidityMask
+    duckdb_vector_ensure_validity_writable(vector.handle)
+    validity_ptr = duckdb_vector_get_validity(vector.handle)
+    ptr = Base.unsafe_convert(Ptr{UInt64}, validity_ptr)
+    validity_vector = unsafe_wrap(Vector{UInt64}, ptr, VECTOR_SIZE  BITS_PER_VALUE, own = false)
+    return ValidityMask(validity_vector)
+end
+
+function AllValid(vector::Vec)::Bool
+    return duckdb_vector_get_validity(vector.handle) == C_NULL
+end
+
+function ListChild(vector::Vec)::Vec
+    return Vec(duckdb_list_vector_get_child(vector.handle))
+end
+
+function ListSize(vector::Vec)::UInt64
+    return duckdb_list_vector_get_size(vector.handle)
+end
+
+function StructChild(vector::Vec, index::UInt64)::Vec
+    return Vec(duckdb_struct_vector_get_child(vector.handle, index))
+end
+
+function AssignStringElement(vector::Vec, index, str::AbstractString)
+    return duckdb_vector_assign_string_element_len(vector.handle, index, str, sizeof(str))
+end
diff --git a/tools/pythonpkg/src/include/duckdb_python/map.hpp b/tools/pythonpkg/src/include/duckdb_python/map.hpp
index 24e5ef47ad8a..92edf82a808e 100644
--- a/tools/pythonpkg/src/include/duckdb_python/map.hpp
+++ b/tools/pythonpkg/src/include/duckdb_python/map.hpp
@@ -19,10 +19,7 @@ struct MapFunction : public TableFunction {
 public:
 	MapFunction();
 
-	static unique_ptr<FunctionData> MapFunctionBind(ClientContext &context, vector<Value> &inputs,
-	                                                named_parameter_map_t &named_parameters,
-	                                                vector<LogicalType> &input_table_types,
-	                                                vector<string> &input_table_names,
+	static unique_ptr<FunctionData> MapFunctionBind(ClientContext &context, TableFunctionBindInput &input,
 	                                                vector<LogicalType> &return_types, vector<string> &names);
 
 	static void MapFunctionExec(ClientContext &context, const FunctionData *bind_data,
diff --git a/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp b/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp
index 66c71428c415..bf59087207d6 100644
--- a/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp
+++ b/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp
@@ -20,11 +20,8 @@ struct PandasScanFunction : public TableFunction {
 public:
 	PandasScanFunction();
 
-	static unique_ptr<FunctionData> PandasScanBind(ClientContext &context, vector<Value> &inputs,
-	                                               named_parameter_map_t &named_parameters,
-	                                               vector<LogicalType> &input_table_types,
-	                                               vector<string> &input_table_names, vector<LogicalType> &return_types,
-	                                               vector<string> &names);
+	static unique_ptr<FunctionData> PandasScanBind(ClientContext &context, TableFunctionBindInput &input,
+	                                               vector<LogicalType> &return_types, vector<string> &names);
 
 	static unique_ptr<FunctionOperatorData> PandasScanInit(ClientContext &context, const FunctionData *bind_data_p,
 	                                                       const vector<column_t> &column_ids,
diff --git a/tools/pythonpkg/src/map.cpp b/tools/pythonpkg/src/map.cpp
index 67bc847ac794..866309da068c 100644
--- a/tools/pythonpkg/src/map.cpp
+++ b/tools/pythonpkg/src/map.cpp
@@ -43,18 +43,15 @@ static py::handle FunctionCall(NumpyResultConversion &conversion, vector<string>
 
 // we call the passed function with a zero-row data frame to infer the output columns and their names.
 // they better not change in the actual execution ^^
-unique_ptr<FunctionData> MapFunction::MapFunctionBind(ClientContext &context, vector<Value> &inputs,
-                                                      named_parameter_map_t &named_parameters,
-                                                      vector<LogicalType> &input_table_types,
-                                                      vector<string> &input_table_names,
+unique_ptr<FunctionData> MapFunction::MapFunctionBind(ClientContext &context, TableFunctionBindInput &input,
                                                       vector<LogicalType> &return_types, vector<string> &names) {
 	py::gil_scoped_acquire acquire;
 
 	auto data_uptr = make_unique<MapFunctionData>();
 	auto &data = *data_uptr;
-	data.function = (PyObject *)inputs[0].GetPointer();
-	data.in_names = input_table_names;
-	data.in_types = input_table_types;
+	data.function = (PyObject *)input.inputs[0].GetPointer();
+	data.in_names = input.input_table_names;
+	data.in_types = input.input_table_types;
 
 	NumpyResultConversion conversion(data.in_types, 0);
 	auto df = FunctionCall(conversion, data.in_names, data.function);
diff --git a/tools/pythonpkg/src/pandas_scan.cpp b/tools/pythonpkg/src/pandas_scan.cpp
index 65df98092fb5..847114ee9e76 100644
--- a/tools/pythonpkg/src/pandas_scan.cpp
+++ b/tools/pythonpkg/src/pandas_scan.cpp
@@ -52,13 +52,10 @@ PandasScanFunction::PandasScanFunction()
                     PandasScanParallelStateNext, true, false, PandasProgress) {
 }
 
-unique_ptr<FunctionData> PandasScanFunction::PandasScanBind(ClientContext &context, vector<Value> &inputs,
-                                                            named_parameter_map_t &named_parameters,
-                                                            vector<LogicalType> &input_table_types,
-                                                            vector<string> &input_table_names,
+unique_ptr<FunctionData> PandasScanFunction::PandasScanBind(ClientContext &context, TableFunctionBindInput &input,
                                                             vector<LogicalType> &return_types, vector<string> &names) {
 	py::gil_scoped_acquire acquire;
-	py::handle df((PyObject *)(inputs[0].GetPointer()));
+	py::handle df((PyObject *)(input.inputs[0].GetPointer()));
 
 	vector<PandasColumnBindData> pandas_bind_data;
 	VectorConversion::BindPandas(df, pandas_bind_data, return_types, names);
diff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp
index 573a02774ef5..8ac3c2a81f23 100644
--- a/tools/pythonpkg/src/pyconnection.cpp
+++ b/tools/pythonpkg/src/pyconnection.cpp
@@ -464,9 +464,15 @@ TryReplacement(py::dict &dict, py::str &table_name,
 	return table_function;
 }
 
-static unique_ptr<TableFunctionRef> ScanReplacement(const string &table_name, void *data) {
+struct ReplacementRegisteredObjects : public ReplacementScanData {
+	unordered_map<string, unique_ptr<RegisteredObject>> *registered_objects;
+};
+
+static unique_ptr<TableFunctionRef> ScanReplacement(ClientContext &context, const string &table_name,
+                                                    ReplacementScanData *data) {
 	py::gil_scoped_acquire acquire;
-	auto registered_objects = (unordered_map<string, unique_ptr<RegisteredObject>> *)data;
+	auto &registered_data = (ReplacementRegisteredObjects &)*data;
+	auto registered_objects = registered_data.registered_objects;
 	auto py_table_name = py::str(table_name);
 	// Here we do an exhaustive search on the frame lineage
 	auto current_frame = py::module::import("inspect").attr("currentframe")();
@@ -510,7 +516,9 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const string &databas
 		config.SetOption(*config_property, Value(val));
 	}
 	if (config.enable_external_access) {
-		config.replacement_scans.emplace_back(ScanReplacement, (void *)&res->registered_objects);
+		auto extra_data = make_unique<ReplacementRegisteredObjects>();
+		extra_data->registered_objects = &res->registered_objects;
+		config.replacement_scans.emplace_back(ScanReplacement, move(extra_data));
 	}
 
 	res->database = make_unique<DuckDB>(database, &config);
diff --git a/tools/rpkg/src/database.cpp b/tools/rpkg/src/database.cpp
index e15d2dea1b9b..de297e98700a 100644
--- a/tools/rpkg/src/database.cpp
+++ b/tools/rpkg/src/database.cpp
@@ -46,7 +46,10 @@ void duckdb::DBDeleter(DBWrapper *db) {
 
 	try {
 		wrapper = new DBWrapper();
-		config.replacement_scans.emplace_back(ArrowScanReplacement, wrapper);
+
+		auto data = make_unique<ArrowScanReplacementData>();
+		data->wrapper = wrapper;
+		config.replacement_scans.emplace_back(ArrowScanReplacement, move(data));
 		wrapper->db = make_unique<DuckDB>(dbdirchar, &config);
 	} catch (std::exception &e) {
 		cpp11::stop("rapi_startup: Failed to open database: %s", e.what());
diff --git a/tools/rpkg/src/include/rapi.hpp b/tools/rpkg/src/include/rapi.hpp
index 5b1cffee64a9..38e2fd008d77 100644
--- a/tools/rpkg/src/include/rapi.hpp
+++ b/tools/rpkg/src/include/rapi.hpp
@@ -46,7 +46,12 @@ struct RQueryResult {
 typedef cpp11::external_pointer<RQueryResult> rqry_eptr_t;
 
 // internal
-unique_ptr<TableFunctionRef> ArrowScanReplacement(const std::string &table_name, void *data);
+unique_ptr<TableFunctionRef> ArrowScanReplacement(ClientContext &context, const std::string &table_name,
+                                                  ReplacementScanData *data);
+
+struct ArrowScanReplacementData : public ReplacementScanData {
+	DBWrapper *wrapper;
+};
 
 SEXP StringsToSexp(vector<std::string> s);
 
diff --git a/tools/rpkg/src/register.cpp b/tools/rpkg/src/register.cpp
index 423a36000d40..6872aa653661 100644
--- a/tools/rpkg/src/register.cpp
+++ b/tools/rpkg/src/register.cpp
@@ -184,8 +184,10 @@ class RArrowTabularStreamFactory {
 	}
 };
 
-unique_ptr<TableFunctionRef> duckdb::ArrowScanReplacement(const string &table_name, void *data) {
-	auto db_wrapper = (DBWrapper *)data;
+unique_ptr<TableFunctionRef> duckdb::ArrowScanReplacement(ClientContext &context, const string &table_name,
+                                                          ReplacementScanData *data_p) {
+	auto &data = (ArrowScanReplacementData &)*data_p;
+	auto db_wrapper = data.wrapper;
 	lock_guard<mutex> arrow_scans_lock(db_wrapper->lock);
 	for (auto &e : db_wrapper->arrow_scans) {
 		if (e.first == table_name) {
diff --git a/tools/rpkg/src/scan.cpp b/tools/rpkg/src/scan.cpp
index fed729407b33..425f64df48f8 100644
--- a/tools/rpkg/src/scan.cpp
+++ b/tools/rpkg/src/scan.cpp
@@ -49,13 +49,10 @@ struct DataFrameScanState : public FunctionOperatorData {
 	idx_t position;
 };
 
-static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> &inputs,
-                                                    named_parameter_map_t &named_parameters,
-                                                    vector<LogicalType> &input_table_types,
-                                                    vector<string> &input_table_names,
+static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, TableFunctionBindInput &input,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
 	RProtector r;
-	SEXP df((SEXP)inputs[0].GetPointer());
+	SEXP df((SEXP)input.inputs[0].GetPointer());
 
 	auto df_names = r.Protect(GET_NAMES(df));
 	vector<RType> rtypes;
