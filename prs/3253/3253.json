{
  "repo": "duckdb/duckdb",
  "pull_number": 3253,
  "instance_id": "duckdb__duckdb-3253",
  "issue_numbers": [
    "2733",
    "3055"
  ],
  "base_commit": "8b798681f14a4e1bfd8eea86cde9fa72ab1ddeda",
  "patch": "diff --git a/.github/workflows/Julia.yml b/.github/workflows/Julia.yml\nnew file mode 100644\nindex 000000000000..70b0a178b584\n--- /dev/null\n+++ b/.github/workflows/Julia.yml\n@@ -0,0 +1,77 @@\n+name: Julia\n+on:\n+   push:\n+     paths-ignore:\n+       - '**.md'\n+   pull_request:\n+     paths-ignore:\n+       - '**.md'\n+       - 'examples/**'\n+       - 'test/**'\n+       - 'tools/nodejs/**'\n+       - 'tools/pythonpkg/**'\n+       - 'tools/rpkg/**'\n+       - '.github/workflows/**'\n+       - '!.github/workflows/Julia.yml'\n+concurrency:\n+  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}\n+  cancel-in-progress: true\n+\n+defaults:\n+  run:\n+    shell: bash\n+\n+jobs:\n+  format_check:\n+    name: Julia Format Check\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v2\n+        with:\n+          fetch-depth: 0\n+\n+      - uses: julia-actions/setup-julia@v1\n+        with:\n+          version: 1.7\n+          arch: x64\n+\n+      - name: Format Check\n+        run: |\n+            cd tools/juliapkg\n+            julia -e \"import Pkg; Pkg.add(\\\"JuliaFormatter\\\")\"\n+            ./format_check.sh \n+\n+  main_julia:\n+    name: Julia ${{ matrix.version }}\n+    runs-on: ${{ matrix.os }}\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        version:\n+          - '1.6'\n+          - '1.7'\n+          - 'nightly'\n+        os:\n+          - ubuntu-latest\n+        arch:\n+          - x64\n+    steps:\n+      - uses: actions/checkout@v2\n+        with:\n+          fetch-depth: 0\n+\n+      - uses: julia-actions/setup-julia@v1\n+        with:\n+          version: ${{ matrix.version }}\n+          arch: ${{ matrix.arch }}\n+\n+      - name: Build DuckDB\n+        run: |\n+            make\n+\n+      - name: Run Tests\n+        run: |\n+          export JULIA_DUCKDB_LIBRARY=\"`pwd`/build/release/src/libduckdb.so\"\n+          ls $JULIA_DUCKDB_LIBRARY\n+          cd tools/juliapkg\n+          julia -e \"import Pkg; Pkg.activate(\\\".\\\"); Pkg.instantiate(); include(\\\"test/runtests.jl\\\")\"\n\\ No newline at end of file\ndiff --git a/.github/workflows/LinuxRelease.yml b/.github/workflows/LinuxRelease.yml\nindex 8f3f082734fc..5f9c3720e7a5 100644\n--- a/.github/workflows/LinuxRelease.yml\n+++ b/.github/workflows/LinuxRelease.yml\n@@ -7,11 +7,11 @@ on:\n     paths-ignore:\n       - '**.md'\n       - 'tools/nodejs/**'\n+      - 'tools/juliapkg/**'\n       - 'tools/pythonpkg/**'\n       - 'tools/rpkg/**'\n-      - '.github/workflows/NodeJS.yml'\n-      - '.github/workflows/Python.yml'\n-      - '.github/workflows/R.yml'\n+      - '.github/workflows/**'\n+      - '!.github/workflows/LinuxRelease.yml'\n \n concurrency:\n   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}\ndiff --git a/.github/workflows/Main.yml b/.github/workflows/Main.yml\nindex 32f0fd6ce5d2..2d9d93939d2a 100644\n--- a/.github/workflows/Main.yml\n+++ b/.github/workflows/Main.yml\n@@ -7,11 +7,11 @@ on:\n     paths-ignore:\n       - '**.md'\n       - 'tools/nodejs/**'\n+      - 'tools/juliapkg/**'\n       - 'tools/pythonpkg/**'\n       - 'tools/rpkg/**'\n-      - '.github/workflows/NodeJS.yml'\n-      - '.github/workflows/Python.yml'\n-      - '.github/workflows/R.yml'\n+      - '.github/workflows/**'\n+      - '!.github/workflows/Main.yml'\n \n concurrency:\n   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}\ndiff --git a/.github/workflows/NodeJS.yml b/.github/workflows/NodeJS.yml\nindex 11a33790889f..940b52de6d14 100644\n--- a/.github/workflows/NodeJS.yml\n+++ b/.github/workflows/NodeJS.yml\n@@ -6,10 +6,14 @@ on:\n   pull_request:\n     paths-ignore:\n       - '**.md'\n+      - 'data/**'\n+      - 'examples/**'\n+      - 'test/**'\n+      - 'tools/juliapkg/**'\n       - 'tools/pythonpkg/**'\n       - 'tools/rpkg/**'\n-      - '.github/workflows/Python.yml'\n-      - '.github/workflows/R.yml'\n+      - '.github/workflows/**'\n+      - '!.github/workflows/NodeJS.yml'\n \n concurrency:\n   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}\ndiff --git a/.github/workflows/Python.yml b/.github/workflows/Python.yml\nindex adc6972e729a..7bb4e80a6759 100644\n--- a/.github/workflows/Python.yml\n+++ b/.github/workflows/Python.yml\n@@ -6,10 +6,13 @@ on:\n   pull_request:\n     paths-ignore:\n       - '**.md'\n+      - 'examples/**'\n+      - 'test/**'\n+      - 'tools/juliapkg/**'\n       - 'tools/nodejs/**'\n       - 'tools/rpkg/**'\n-      - '.github/workflows/NodeJS.yml'\n-      - '.github/workflows/R.yml'\n+      - '.github/workflows/**'\n+      - '!.github/workflows/Python.yml'\n \n concurrency:\n   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}\ndiff --git a/.github/workflows/R.yml b/.github/workflows/R.yml\nindex b9e5bd82e674..8c26a20e53c6 100644\n--- a/.github/workflows/R.yml\n+++ b/.github/workflows/R.yml\n@@ -6,10 +6,13 @@ on:\n   pull_request:\n     paths-ignore:\n       - '**.md'\n+      - 'examples/**'\n+      - 'test/**'\n+      - 'tools/juliapkg/**'\n       - 'tools/nodejs/**'\n       - 'tools/pythonpkg/**'\n-      - '.github/workflows/NodeJS.yml'\n-      - '.github/workflows/Python.yml'\n+      - '.github/workflows/**'\n+      - '!.github/workflows/R.yml'\n \n concurrency:\n   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}\ndiff --git a/.github/workflows/Regression.yml b/.github/workflows/Regression.yml\nindex 686b62d11433..2b2a04fb3f12 100644\n--- a/.github/workflows/Regression.yml\n+++ b/.github/workflows/Regression.yml\n@@ -6,11 +6,11 @@ on:\n   pull_request:\n     paths-ignore:\n       - '**.md'\n+      - 'tools/juliapkg/**'\n       - 'tools/nodejs/**'\n       - 'tools/rpkg/**'\n-      - '.github/workflows/NodeJS.yml'\n-      - '.github/workflows/Python.yml'\n-      - '.github/workflows/R.yml'\n+      - '.github/workflows/**'\n+      - '!.github/workflows/Regression.yml'\n \n concurrency:\n   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}\ndiff --git a/.github/workflows/Windows.yml b/.github/workflows/Windows.yml\nindex cd23f1c09406..c26cfdc767ab 100644\n--- a/.github/workflows/Windows.yml\n+++ b/.github/workflows/Windows.yml\n@@ -6,12 +6,12 @@ on:\n   pull_request:\n     paths-ignore:\n       - '**.md'\n+      - 'tools/juliapkg/**'\n       - 'tools/nodejs/**'\n       - 'tools/pythonpkg/**'\n       - 'tools/rpkg/**'\n-      - '.github/workflows/NodeJS.yml'\n-      - '.github/workflows/Python.yml'\n-      - '.github/workflows/R.yml'\n+      - '.github/workflows/**'\n+      - '!.github/workflows/Windows.yml'\n \n concurrency:\n   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}\ndiff --git a/examples/standalone-plan/main.cpp b/examples/standalone-plan/main.cpp\nindex 0f4adcff2f52..ef09c2d0bece 100644\n--- a/examples/standalone-plan/main.cpp\n+++ b/examples/standalone-plan/main.cpp\n@@ -98,7 +98,8 @@ void RunExampleDuckDBCatalog() {\n //===--------------------------------------------------------------------===//\n void CreateMyScanFunction(Connection &con);\n \n-unique_ptr<TableFunctionRef> MyReplacementScan(const string &table_name, void *data) {\n+unique_ptr<TableFunctionRef> MyReplacementScan(ClientContext &context, const string &table_name,\n+                                               ReplacementScanData *data) {\n \tauto table_function = make_unique<TableFunctionRef>();\n \tvector<unique_ptr<ParsedExpression>> children;\n \tchildren.push_back(make_unique<ConstantExpression>(Value(table_name)));\n@@ -200,11 +201,9 @@ struct MyBindData : public FunctionData {\n // myothertable\n // k: 1, 10, 20\n // (see MyScanNode)\n-static unique_ptr<FunctionData> MyScanBind(ClientContext &context, vector<Value> &inputs,\n-                                           named_parameter_map_t &named_parameters,\n-                                           vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n+static unique_ptr<FunctionData> MyScanBind(ClientContext &context, TableFunctionBindInput &input,\n                                            vector<LogicalType> &return_types, vector<string> &names) {\n-\tauto table_name = inputs[0].ToString();\n+\tauto table_name = input.inputs[0].ToString();\n \tif (table_name == \"mytable\") {\n \t\tnames.emplace_back(\"i\");\n \t\treturn_types.emplace_back(LogicalType::INTEGER);\ndiff --git a/extension/icu/icu-extension.cpp b/extension/icu/icu-extension.cpp\nindex 611486b500a6..71f14bdd766c 100644\n--- a/extension/icu/icu-extension.cpp\n+++ b/extension/icu/icu-extension.cpp\n@@ -149,11 +149,8 @@ struct ICUTimeZoneData : public FunctionOperatorData {\n \tUDate now;\n };\n \n-static unique_ptr<FunctionData> ICUTimeZoneBind(ClientContext &context, vector<Value> &inputs,\n-                                                named_parameter_map_t &named_parameters,\n-                                                vector<LogicalType> &input_table_types,\n-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                vector<string> &names) {\n+static unique_ptr<FunctionData> ICUTimeZoneBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \tnames.emplace_back(\"abbrev\");\n@@ -235,11 +232,8 @@ struct ICUCalendarData : public FunctionOperatorData {\n \tstd::unique_ptr<icu::StringEnumeration> calendars;\n };\n \n-static unique_ptr<FunctionData> ICUCalendarBind(ClientContext &context, vector<Value> &inputs,\n-                                                named_parameter_map_t &named_parameters,\n-                                                vector<LogicalType> &input_table_types,\n-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                vector<string> &names) {\n+static unique_ptr<FunctionData> ICUCalendarBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \ndiff --git a/extension/parquet/parquet-extension.cpp b/extension/parquet/parquet-extension.cpp\nindex c39376fe13b7..fc1b6890894a 100644\n--- a/extension/parquet/parquet-extension.cpp\n+++ b/extension/parquet/parquet-extension.cpp\n@@ -199,18 +199,15 @@ class ParquetScanFunction {\n \t\treturn files;\n \t}\n \n-\tstatic unique_ptr<FunctionData> ParquetScanBind(ClientContext &context, vector<Value> &inputs,\n-\t                                                named_parameter_map_t &named_parameters,\n-\t                                                vector<LogicalType> &input_table_types,\n-\t                                                vector<string> &input_table_names,\n+\tstatic unique_ptr<FunctionData> ParquetScanBind(ClientContext &context, TableFunctionBindInput &input,\n \t                                                vector<LogicalType> &return_types, vector<string> &names) {\n \t\tauto &config = DBConfig::GetConfig(context);\n \t\tif (!config.enable_external_access) {\n \t\t\tthrow PermissionException(\"Scanning Parquet files is disabled through configuration\");\n \t\t}\n-\t\tauto file_name = inputs[0].GetValue<string>();\n+\t\tauto file_name = input.inputs[0].GetValue<string>();\n \t\tParquetOptions parquet_options(context);\n-\t\tfor (auto &kv : named_parameters) {\n+\t\tfor (auto &kv : input.named_parameters) {\n \t\t\tif (kv.first == \"binary_as_string\") {\n \t\t\t\tparquet_options.binary_as_string = BooleanValue::Get(kv.second);\n \t\t\t}\n@@ -220,10 +217,7 @@ class ParquetScanFunction {\n \t\treturn ParquetScanBindInternal(context, move(files), return_types, names, parquet_options);\n \t}\n \n-\tstatic unique_ptr<FunctionData> ParquetScanBindList(ClientContext &context, vector<Value> &inputs,\n-\t                                                    named_parameter_map_t &named_parameters,\n-\t                                                    vector<LogicalType> &input_table_types,\n-\t                                                    vector<string> &input_table_names,\n+\tstatic unique_ptr<FunctionData> ParquetScanBindList(ClientContext &context, TableFunctionBindInput &input,\n \t                                                    vector<LogicalType> &return_types, vector<string> &names) {\n \t\tauto &config = DBConfig::GetConfig(context);\n \t\tif (!config.enable_external_access) {\n@@ -231,7 +225,7 @@ class ParquetScanFunction {\n \t\t}\n \t\tFileSystem &fs = FileSystem::GetFileSystem(context);\n \t\tvector<string> files;\n-\t\tfor (auto &val : ListValue::GetChildren(inputs[0])) {\n+\t\tfor (auto &val : ListValue::GetChildren(input.inputs[0])) {\n \t\t\tauto glob_files = ParquetGlob(fs, val.ToString(), context);\n \t\t\tfiles.insert(files.end(), glob_files.begin(), glob_files.end());\n \t\t}\n@@ -239,7 +233,7 @@ class ParquetScanFunction {\n \t\t\tthrow IOException(\"Parquet reader needs at least one file to read\");\n \t\t}\n \t\tParquetOptions parquet_options(context);\n-\t\tfor (auto &kv : named_parameters) {\n+\t\tfor (auto &kv : input.named_parameters) {\n \t\t\tif (kv.first == \"binary_as_string\") {\n \t\t\t\tparquet_options.binary_as_string = BooleanValue::Get(kv.second);\n \t\t\t}\n@@ -496,7 +490,8 @@ unique_ptr<LocalFunctionData> ParquetWriteInitializeLocal(ClientContext &context\n \treturn make_unique<ParquetWriteLocalState>();\n }\n \n-unique_ptr<TableFunctionRef> ParquetScanReplacement(const string &table_name, void *data) {\n+unique_ptr<TableFunctionRef> ParquetScanReplacement(ClientContext &context, const string &table_name,\n+                                                    ReplacementScanData *data) {\n \tif (!StringUtil::EndsWith(StringUtil::Lower(table_name), \".parquet\")) {\n \t\treturn nullptr;\n \t}\ndiff --git a/extension/parquet/parquet_metadata.cpp b/extension/parquet/parquet_metadata.cpp\nindex 50cf527d8082..813b83a7b614 100644\n--- a/extension/parquet/parquet_metadata.cpp\n+++ b/extension/parquet/parquet_metadata.cpp\n@@ -384,9 +384,7 @@ void ParquetMetaDataOperatorData::LoadSchemaData(ClientContext &context, const v\n }\n \n template <bool SCHEMA>\n-unique_ptr<FunctionData> ParquetMetaDataBind(ClientContext &context, vector<Value> &inputs,\n-                                             named_parameter_map_t &named_parameters,\n-                                             vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n+unique_ptr<FunctionData> ParquetMetaDataBind(ClientContext &context, TableFunctionBindInput &input,\n                                              vector<LogicalType> &return_types, vector<string> &names) {\n \tauto &config = DBConfig::GetConfig(context);\n \tif (!config.enable_external_access) {\n@@ -398,7 +396,7 @@ unique_ptr<FunctionData> ParquetMetaDataBind(ClientContext &context, vector<Valu\n \t\tParquetMetaDataOperatorData::BindMetaData(return_types, names);\n \t}\n \n-\tauto file_name = inputs[0].GetValue<string>();\n+\tauto file_name = input.inputs[0].GetValue<string>();\n \tauto result = make_unique<ParquetMetaDataBindData>();\n \n \tFileSystem &fs = FileSystem::GetFileSystem(context);\ndiff --git a/extension/substrait/substrait-extension.cpp b/extension/substrait/substrait-extension.cpp\nindex 64f726671f19..ad82b6c1601b 100644\n--- a/extension/substrait/substrait-extension.cpp\n+++ b/extension/substrait/substrait-extension.cpp\n@@ -21,13 +21,10 @@ struct ToSubstraitFunctionData : public TableFunctionData {\n \tbool finished = false;\n };\n \n-static unique_ptr<FunctionData> ToSubstraitBind(ClientContext &context, vector<Value> &inputs,\n-                                                named_parameter_map_t &named_parameters,\n-                                                vector<LogicalType> &input_table_types,\n-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                vector<string> &names) {\n+static unique_ptr<FunctionData> ToSubstraitBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                vector<LogicalType> &return_types, vector<string> &names) {\n \tauto result = make_unique<ToSubstraitFunctionData>();\n-\tresult->query = inputs[0].ToString();\n+\tresult->query = input.inputs[0].ToString();\n \treturn_types.emplace_back(LogicalType::BLOB);\n \tnames.emplace_back(\"Plan Blob\");\n \treturn move(result);\n@@ -73,14 +70,11 @@ struct FromSubstraitFunctionData : public TableFunctionData {\n \tunique_ptr<Connection> conn;\n };\n \n-static unique_ptr<FunctionData> FromSubstraitBind(ClientContext &context, vector<Value> &inputs,\n-                                                  named_parameter_map_t &named_parameters,\n-                                                  vector<LogicalType> &input_table_types,\n-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                  vector<string> &names) {\n+static unique_ptr<FunctionData> FromSubstraitBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                  vector<LogicalType> &return_types, vector<string> &names) {\n \tauto result = make_unique<FromSubstraitFunctionData>();\n \tresult->conn = make_unique<Connection>(*context.db);\n-\tstring serialized = inputs[0].GetValueUnsafe<string>();\n+\tstring serialized = input.inputs[0].GetValueUnsafe<string>();\n \tresult->plan = SubstraitPlanToDuckDBRel(*result->conn, serialized);\n \tfor (auto &column : result->plan->Columns()) {\n \t\treturn_types.emplace_back(column.type);\ndiff --git a/extension/tpcds/tpcds-extension.cpp b/extension/tpcds/tpcds-extension.cpp\nindex 72e711291685..198d57bc5aa7 100644\n--- a/extension/tpcds/tpcds-extension.cpp\n+++ b/extension/tpcds/tpcds-extension.cpp\n@@ -27,12 +27,10 @@ struct DSDGenFunctionData : public TableFunctionData {\n \tbool keys = false;\n };\n \n-static unique_ptr<FunctionData> DsdgenBind(ClientContext &context, vector<Value> &inputs,\n-                                           named_parameter_map_t &named_parameters,\n-                                           vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n+static unique_ptr<FunctionData> DsdgenBind(ClientContext &context, TableFunctionBindInput &input,\n                                            vector<LogicalType> &return_types, vector<string> &names) {\n \tauto result = make_unique<DSDGenFunctionData>();\n-\tfor (auto &kv : named_parameters) {\n+\tfor (auto &kv : input.named_parameters) {\n \t\tif (kv.first == \"sf\") {\n \t\t\tresult->sf = kv.second.GetValue<double>();\n \t\t} else if (kv.first == \"schema\") {\n@@ -74,11 +72,8 @@ unique_ptr<FunctionOperatorData> TPCDSInit(ClientContext &context, const Functio\n \treturn move(result);\n }\n \n-static unique_ptr<FunctionData> TPCDSQueryBind(ClientContext &context, vector<Value> &inputs,\n-                                               named_parameter_map_t &named_parameters,\n-                                               vector<LogicalType> &input_table_types,\n-                                               vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                               vector<string> &names) {\n+static unique_ptr<FunctionData> TPCDSQueryBind(ClientContext &context, TableFunctionBindInput &input,\n+                                               vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"query_nr\");\n \treturn_types.emplace_back(LogicalType::INTEGER);\n \n@@ -109,10 +104,7 @@ static void TPCDSQueryFunction(ClientContext &context, const FunctionData *bind_\n \toutput.SetCardinality(chunk_count);\n }\n \n-static unique_ptr<FunctionData> TPCDSQueryAnswerBind(ClientContext &context, vector<Value> &inputs,\n-                                                     named_parameter_map_t &named_parameters,\n-                                                     vector<LogicalType> &input_table_types,\n-                                                     vector<string> &input_table_names,\n+static unique_ptr<FunctionData> TPCDSQueryAnswerBind(ClientContext &context, TableFunctionBindInput &input,\n                                                      vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"query_nr\");\n \treturn_types.emplace_back(LogicalType::INTEGER);\ndiff --git a/extension/tpch/tpch-extension.cpp b/extension/tpch/tpch-extension.cpp\nindex 9dadde939e46..15bdec4314ba 100644\n--- a/extension/tpch/tpch-extension.cpp\n+++ b/extension/tpch/tpch-extension.cpp\n@@ -27,12 +27,10 @@ struct DBGenFunctionData : public TableFunctionData {\n \tbool overwrite = false;\n };\n \n-static unique_ptr<FunctionData> DbgenBind(ClientContext &context, vector<Value> &inputs,\n-                                          named_parameter_map_t &named_parameters,\n-                                          vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n+static unique_ptr<FunctionData> DbgenBind(ClientContext &context, TableFunctionBindInput &input,\n                                           vector<LogicalType> &return_types, vector<string> &names) {\n \tauto result = make_unique<DBGenFunctionData>();\n-\tfor (auto &kv : named_parameters) {\n+\tfor (auto &kv : input.named_parameters) {\n \t\tif (kv.first == \"sf\") {\n \t\t\tresult->sf = DoubleValue::Get(kv.second);\n \t\t} else if (kv.first == \"schema\") {\n@@ -72,9 +70,7 @@ unique_ptr<FunctionOperatorData> TPCHInit(ClientContext &context, const Function\n \treturn move(result);\n }\n \n-static unique_ptr<FunctionData> TPCHQueryBind(ClientContext &context, vector<Value> &inputs,\n-                                              named_parameter_map_t &named_parameters,\n-                                              vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n+static unique_ptr<FunctionData> TPCHQueryBind(ClientContext &context, TableFunctionBindInput &input,\n                                               vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"query_nr\");\n \treturn_types.emplace_back(LogicalType::INTEGER);\n@@ -106,10 +102,7 @@ static void TPCHQueryFunction(ClientContext &context, const FunctionData *bind_d\n \toutput.SetCardinality(chunk_count);\n }\n \n-static unique_ptr<FunctionData> TPCHQueryAnswerBind(ClientContext &context, vector<Value> &inputs,\n-                                                    named_parameter_map_t &named_parameters,\n-                                                    vector<LogicalType> &input_table_types,\n-                                                    vector<string> &input_table_names,\n+static unique_ptr<FunctionData> TPCHQueryAnswerBind(ClientContext &context, TableFunctionBindInput &input,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"query_nr\");\n \treturn_types.emplace_back(LogicalType::INTEGER);\ndiff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp\nindex 58fcc24aab0d..b3b0b241400e 100644\n--- a/src/common/types/vector.cpp\n+++ b/src/common/types/vector.cpp\n@@ -913,6 +913,10 @@ void Vector::Deserialize(idx_t count, Deserializer &source) {\n \n void Vector::SetVectorType(VectorType vector_type_p) {\n \tthis->vector_type = vector_type_p;\n+\tif (TypeIsConstantSize(GetType().InternalType()) &&\n+\t    (GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR)) {\n+\t\tauxiliary.reset();\n+\t}\n \tif (vector_type == VectorType::CONSTANT_VECTOR && GetType().InternalType() == PhysicalType::STRUCT) {\n \t\tauto &entries = StructVector::GetEntries(*this);\n \t\tfor (auto &entry : entries) {\ndiff --git a/src/execution/operator/join/perfect_hash_join_executor.cpp b/src/execution/operator/join/perfect_hash_join_executor.cpp\nindex 154c99934782..f1219e147b93 100644\n--- a/src/execution/operator/join/perfect_hash_join_executor.cpp\n+++ b/src/execution/operator/join/perfect_hash_join_executor.cpp\n@@ -153,6 +153,7 @@ OperatorResultType PerfectHashJoinExecutor::ProbePerfectHashTable(ExecutionConte\n \tidx_t probe_sel_count = 0;\n \n \t// fetch the join keys from the chunk\n+\tstate.join_keys.Reset();\n \tstate.probe_executor.Execute(input, state.join_keys);\n \t// select the keys that are in the min-max range\n \tauto &keys_vec = state.join_keys.data[0];\ndiff --git a/src/execution/operator/join/physical_nested_loop_join.cpp b/src/execution/operator/join/physical_nested_loop_join.cpp\nindex 51e4bdff3ad0..f5d7d54e38eb 100644\n--- a/src/execution/operator/join/physical_nested_loop_join.cpp\n+++ b/src/execution/operator/join/physical_nested_loop_join.cpp\n@@ -340,6 +340,7 @@ OperatorResultType PhysicalNestedLoopJoin::ResolveComplexJoin(ExecutionContext &\n \t\t}\n \t\tif (state.fetch_next_left) {\n \t\t\t// resolve the left join condition for the current chunk\n+\t\t\tstate.left_condition.Reset();\n \t\t\tstate.lhs_executor.Execute(input, state.left_condition);\n \n \t\t\tstate.left_tuple = 0;\ndiff --git a/src/function/table/arrow.cpp b/src/function/table/arrow.cpp\nindex 6d12ea929e82..7c6530aaca36 100644\n--- a/src/function/table/arrow.cpp\n+++ b/src/function/table/arrow.cpp\n@@ -161,18 +161,15 @@ LogicalType GetArrowLogicalType(ArrowSchema &schema,\n \t}\n }\n \n-unique_ptr<FunctionData> ArrowTableFunction::ArrowScanBind(ClientContext &context, vector<Value> &inputs,\n-                                                           named_parameter_map_t &named_parameters,\n-                                                           vector<LogicalType> &input_table_types,\n-                                                           vector<string> &input_table_names,\n+unique_ptr<FunctionData> ArrowTableFunction::ArrowScanBind(ClientContext &context, TableFunctionBindInput &input,\n                                                            vector<LogicalType> &return_types, vector<string> &names) {\n \ttypedef unique_ptr<ArrowArrayStreamWrapper> (*stream_factory_produce_t)(\n \t    uintptr_t stream_factory_ptr,\n \t    std::pair<std::unordered_map<idx_t, string>, std::vector<string>> & project_columns,\n \t    TableFilterCollection * filters);\n-\tauto stream_factory_ptr = inputs[0].GetPointer();\n-\tauto stream_factory_produce = (stream_factory_produce_t)inputs[1].GetPointer();\n-\tauto rows_per_thread = inputs[2].GetValue<uint64_t>();\n+\tauto stream_factory_ptr = input.inputs[0].GetPointer();\n+\tauto stream_factory_produce = (stream_factory_produce_t)input.inputs[1].GetPointer();\n+\tauto rows_per_thread = input.inputs[2].GetValue<uint64_t>();\n \tstd::pair<std::unordered_map<idx_t, string>, std::vector<string>> project_columns;\n #ifndef DUCKDB_NO_THREADS\n \ndiff --git a/src/function/table/checkpoint.cpp b/src/function/table/checkpoint.cpp\nindex a3a18964cf01..acdca79b8590 100644\n--- a/src/function/table/checkpoint.cpp\n+++ b/src/function/table/checkpoint.cpp\n@@ -5,11 +5,8 @@\n \n namespace duckdb {\n \n-static unique_ptr<FunctionData> CheckpointBind(ClientContext &context, vector<Value> &inputs,\n-                                               named_parameter_map_t &named_parameters,\n-                                               vector<LogicalType> &input_table_types,\n-                                               vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                               vector<string> &names) {\n+static unique_ptr<FunctionData> CheckpointBind(ClientContext &context, TableFunctionBindInput &input,\n+                                               vector<LogicalType> &return_types, vector<string> &names) {\n \treturn_types.emplace_back(LogicalType::BOOLEAN);\n \tnames.emplace_back(\"Success\");\n \treturn nullptr;\ndiff --git a/src/function/table/glob.cpp b/src/function/table/glob.cpp\nindex 5a4c1a9965e7..30236e3b1536 100644\n--- a/src/function/table/glob.cpp\n+++ b/src/function/table/glob.cpp\n@@ -10,18 +10,15 @@ struct GlobFunctionBindData : public TableFunctionData {\n \tvector<string> files;\n };\n \n-static unique_ptr<FunctionData> GlobFunctionBind(ClientContext &context, vector<Value> &inputs,\n-                                                 named_parameter_map_t &named_parameters,\n-                                                 vector<LogicalType> &input_table_types,\n-                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                 vector<string> &names) {\n+static unique_ptr<FunctionData> GlobFunctionBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                 vector<LogicalType> &return_types, vector<string> &names) {\n \tauto &config = DBConfig::GetConfig(context);\n \tif (!config.enable_external_access) {\n \t\tthrow PermissionException(\"Globbing is disabled through configuration\");\n \t}\n \tauto result = make_unique<GlobFunctionBindData>();\n \tauto &fs = FileSystem::GetFileSystem(context);\n-\tresult->files = fs.Glob(StringValue::Get(inputs[0]), context);\n+\tresult->files = fs.Glob(StringValue::Get(input.inputs[0]), context);\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \tnames.emplace_back(\"file\");\n \treturn move(result);\ndiff --git a/src/function/table/pragma_detailed_profiling_output.cpp b/src/function/table/pragma_detailed_profiling_output.cpp\nindex 87620c9e9dfd..98ddb8cf60f2 100644\n--- a/src/function/table/pragma_detailed_profiling_output.cpp\n+++ b/src/function/table/pragma_detailed_profiling_output.cpp\n@@ -21,10 +21,7 @@ struct PragmaDetailedProfilingOutputData : public TableFunctionData {\n \tvector<LogicalType> types;\n };\n \n-static unique_ptr<FunctionData> PragmaDetailedProfilingOutputBind(ClientContext &context, vector<Value> &inputs,\n-                                                                  named_parameter_map_t &named_parameters,\n-                                                                  vector<LogicalType> &input_table_types,\n-                                                                  vector<string> &input_table_names,\n+static unique_ptr<FunctionData> PragmaDetailedProfilingOutputBind(ClientContext &context, TableFunctionBindInput &input,\n                                                                   vector<LogicalType> &return_types,\n                                                                   vector<string> &names) {\n \tnames.emplace_back(\"OPERATOR_ID\");\ndiff --git a/src/function/table/pragma_last_profiling_output.cpp b/src/function/table/pragma_last_profiling_output.cpp\nindex 67d863371d3a..d7d3326194e8 100644\n--- a/src/function/table/pragma_last_profiling_output.cpp\n+++ b/src/function/table/pragma_last_profiling_output.cpp\n@@ -22,10 +22,9 @@ struct PragmaLastProfilingOutputData : public TableFunctionData {\n \tvector<LogicalType> types;\n };\n \n-static unique_ptr<FunctionData>\n-PragmaLastProfilingOutputBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,\n-                              vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n-                              vector<LogicalType> &return_types, vector<string> &names) {\n+static unique_ptr<FunctionData> PragmaLastProfilingOutputBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                              vector<LogicalType> &return_types,\n+                                                              vector<string> &names) {\n \tnames.emplace_back(\"OPERATOR_ID\");\n \treturn_types.emplace_back(LogicalType::INTEGER);\n \ndiff --git a/src/function/table/range.cpp b/src/function/table/range.cpp\nindex ad6f66ecf5ba..8c819935f1b9 100644\n--- a/src/function/table/range.cpp\n+++ b/src/function/table/range.cpp\n@@ -17,11 +17,10 @@ struct RangeFunctionBindData : public TableFunctionData {\n };\n \n template <bool GENERATE_SERIES>\n-static unique_ptr<FunctionData>\n-RangeFunctionBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,\n-                  vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n-                  vector<LogicalType> &return_types, vector<string> &names) {\n+static unique_ptr<FunctionData> RangeFunctionBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                  vector<LogicalType> &return_types, vector<string> &names) {\n \tauto result = make_unique<RangeFunctionBindData>();\n+\tauto &inputs = input.inputs;\n \tif (inputs.size() < 2) {\n \t\t// single argument: only the end is specified\n \t\tresult->start = 0;\n@@ -128,11 +127,10 @@ struct RangeDateTimeBindData : public TableFunctionData {\n };\n \n template <bool GENERATE_SERIES>\n-static unique_ptr<FunctionData>\n-RangeDateTimeBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,\n-                  vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n-                  vector<LogicalType> &return_types, vector<string> &names) {\n+static unique_ptr<FunctionData> RangeDateTimeBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                  vector<LogicalType> &return_types, vector<string> &names) {\n \tauto result = make_unique<RangeDateTimeBindData>();\n+\tauto &inputs = input.inputs;\n \tD_ASSERT(inputs.size() == 3);\n \tresult->start = inputs[0].GetValue<timestamp_t>();\n \tresult->end = inputs[1].GetValue<timestamp_t>();\ndiff --git a/src/function/table/read_csv.cpp b/src/function/table/read_csv.cpp\nindex 0476d0852d54..6f067a9eddd7 100644\n--- a/src/function/table/read_csv.cpp\n+++ b/src/function/table/read_csv.cpp\n@@ -14,9 +14,7 @@\n \n namespace duckdb {\n \n-static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value> &inputs,\n-                                            named_parameter_map_t &named_parameters,\n-                                            vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n+static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, TableFunctionBindInput &input,\n                                             vector<LogicalType> &return_types, vector<string> &names) {\n \tauto &config = DBConfig::GetConfig(context);\n \tif (!config.enable_external_access) {\n@@ -25,7 +23,7 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value\n \tauto result = make_unique<ReadCSVData>();\n \tauto &options = result->options;\n \n-\tauto &file_pattern = StringValue::Get(inputs[0]);\n+\tauto &file_pattern = StringValue::Get(input.inputs[0]);\n \n \tauto &fs = FileSystem::GetFileSystem(context);\n \tresult->files = fs.Glob(file_pattern, context);\n@@ -33,7 +31,7 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value\n \t\tthrow IOException(\"No files found that match the pattern \\\"%s\\\"\", file_pattern);\n \t}\n \n-\tfor (auto &kv : named_parameters) {\n+\tfor (auto &kv : input.named_parameters) {\n \t\tauto loption = StringUtil::Lower(kv.first);\n \t\tif (loption == \"auto_detect\") {\n \t\t\toptions.auto_detect = BooleanValue::Get(kv.second);\n@@ -180,13 +178,10 @@ static unique_ptr<FunctionOperatorData> ReadCSVInit(ClientContext &context, cons\n \treturn move(result);\n }\n \n-static unique_ptr<FunctionData> ReadCSVAutoBind(ClientContext &context, vector<Value> &inputs,\n-                                                named_parameter_map_t &named_parameters,\n-                                                vector<LogicalType> &input_table_types,\n-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                vector<string> &names) {\n-\tnamed_parameters[\"auto_detect\"] = Value::BOOLEAN(true);\n-\treturn ReadCSVBind(context, inputs, named_parameters, input_table_types, input_table_names, return_types, names);\n+static unique_ptr<FunctionData> ReadCSVAutoBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                vector<LogicalType> &return_types, vector<string> &names) {\n+\tinput.named_parameters[\"auto_detect\"] = Value::BOOLEAN(true);\n+\treturn ReadCSVBind(context, input, return_types, names);\n }\n \n static void ReadCSVFunction(ClientContext &context, const FunctionData *bind_data_p,\n@@ -261,7 +256,8 @@ void ReadCSVTableFunction::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(read_csv_auto);\n }\n \n-unique_ptr<TableFunctionRef> ReadCSVReplacement(const string &table_name, void *data) {\n+unique_ptr<TableFunctionRef> ReadCSVReplacement(ClientContext &context, const string &table_name,\n+                                                ReplacementScanData *data) {\n \tauto lower_name = StringUtil::Lower(table_name);\n \t// remove any compression\n \tif (StringUtil::EndsWith(lower_name, \".gz\")) {\ndiff --git a/src/function/table/repeat.cpp b/src/function/table/repeat.cpp\nindex 933e0deefb18..ef0ab75d924b 100644\n--- a/src/function/table/repeat.cpp\n+++ b/src/function/table/repeat.cpp\n@@ -17,11 +17,10 @@ struct RepeatOperatorData : public FunctionOperatorData {\n \tidx_t current_count;\n };\n \n-static unique_ptr<FunctionData> RepeatBind(ClientContext &context, vector<Value> &inputs,\n-                                           named_parameter_map_t &named_parameters,\n-                                           vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n+static unique_ptr<FunctionData> RepeatBind(ClientContext &context, TableFunctionBindInput &input,\n                                            vector<LogicalType> &return_types, vector<string> &names) {\n \t// the repeat function returns the type of the first argument\n+\tauto &inputs = input.inputs;\n \treturn_types.push_back(inputs[0].type());\n \tnames.push_back(inputs[0].ToString());\n \treturn make_unique<RepeatFunctionData>(inputs[0], inputs[1].GetValue<int64_t>());\ndiff --git a/src/function/table/summary.cpp b/src/function/table/summary.cpp\nindex eb8bf1189753..ef9c36b70f35 100644\n--- a/src/function/table/summary.cpp\n+++ b/src/function/table/summary.cpp\n@@ -7,18 +7,15 @@\n \n namespace duckdb {\n \n-static unique_ptr<FunctionData> SummaryFunctionBind(ClientContext &context, vector<Value> &inputs,\n-                                                    named_parameter_map_t &named_parameters,\n-                                                    vector<LogicalType> &input_table_types,\n-                                                    vector<string> &input_table_names,\n+static unique_ptr<FunctionData> SummaryFunctionBind(ClientContext &context, TableFunctionBindInput &input,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\n \n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \tnames.emplace_back(\"summary\");\n \n-\tfor (idx_t i = 0; i < input_table_types.size(); i++) {\n-\t\treturn_types.push_back(input_table_types[i]);\n-\t\tnames.emplace_back(input_table_names[i]);\n+\tfor (idx_t i = 0; i < input.input_table_types.size(); i++) {\n+\t\treturn_types.push_back(input.input_table_types[i]);\n+\t\tnames.emplace_back(input.input_table_names[i]);\n \t}\n \n \treturn make_unique<TableFunctionData>();\ndiff --git a/src/function/table/system/duckdb_columns.cpp b/src/function/table/system/duckdb_columns.cpp\nindex 295cf271c478..aa6c90f9905c 100644\n--- a/src/function/table/system/duckdb_columns.cpp\n+++ b/src/function/table/system/duckdb_columns.cpp\n@@ -20,11 +20,8 @@ struct DuckDBColumnsData : public FunctionOperatorData {\n \tidx_t column_offset;\n };\n \n-static unique_ptr<FunctionData> DuckDBColumnsBind(ClientContext &context, vector<Value> &inputs,\n-                                                  named_parameter_map_t &named_parameters,\n-                                                  vector<LogicalType> &input_table_types,\n-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                  vector<string> &names) {\n+static unique_ptr<FunctionData> DuckDBColumnsBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                  vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"schema_oid\");\n \treturn_types.emplace_back(LogicalType::BIGINT);\n \ndiff --git a/src/function/table/system/duckdb_constraints.cpp b/src/function/table/system/duckdb_constraints.cpp\nindex e3196e7e0512..b852e04ec8be 100644\n--- a/src/function/table/system/duckdb_constraints.cpp\n+++ b/src/function/table/system/duckdb_constraints.cpp\n@@ -25,10 +25,7 @@ struct DuckDBConstraintsData : public FunctionOperatorData {\n \tidx_t constraint_offset;\n };\n \n-static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, vector<Value> &inputs,\n-                                                      named_parameter_map_t &named_parameters,\n-                                                      vector<LogicalType> &input_table_types,\n-                                                      vector<string> &input_table_names,\n+static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, TableFunctionBindInput &input,\n                                                       vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"schema_name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\ndiff --git a/src/function/table/system/duckdb_dependencies.cpp b/src/function/table/system/duckdb_dependencies.cpp\nindex 281f52361619..eaf25bb51271 100644\n--- a/src/function/table/system/duckdb_dependencies.cpp\n+++ b/src/function/table/system/duckdb_dependencies.cpp\n@@ -21,10 +21,7 @@ struct DuckDBDependenciesData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> DuckDBDependenciesBind(ClientContext &context, vector<Value> &inputs,\n-                                                       named_parameter_map_t &named_parameters,\n-                                                       vector<LogicalType> &input_table_types,\n-                                                       vector<string> &input_table_names,\n+static unique_ptr<FunctionData> DuckDBDependenciesBind(ClientContext &context, TableFunctionBindInput &input,\n                                                        vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"classid\");\n \treturn_types.emplace_back(LogicalType::BIGINT);\ndiff --git a/src/function/table/system/duckdb_functions.cpp b/src/function/table/system/duckdb_functions.cpp\nindex 8b9b38030f8b..d3c2d0c9ffd3 100644\n--- a/src/function/table/system/duckdb_functions.cpp\n+++ b/src/function/table/system/duckdb_functions.cpp\n@@ -21,10 +21,7 @@ struct DuckDBFunctionsData : public FunctionOperatorData {\n \tidx_t offset_in_entry;\n };\n \n-static unique_ptr<FunctionData> DuckDBFunctionsBind(ClientContext &context, vector<Value> &inputs,\n-                                                    named_parameter_map_t &named_parameters,\n-                                                    vector<LogicalType> &input_table_types,\n-                                                    vector<string> &input_table_names,\n+static unique_ptr<FunctionData> DuckDBFunctionsBind(ClientContext &context, TableFunctionBindInput &input,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"schema_name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\ndiff --git a/src/function/table/system/duckdb_indexes.cpp b/src/function/table/system/duckdb_indexes.cpp\nindex 710dc8284db6..a545838dc03e 100644\n--- a/src/function/table/system/duckdb_indexes.cpp\n+++ b/src/function/table/system/duckdb_indexes.cpp\n@@ -18,11 +18,8 @@ struct DuckDBIndexesData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> DuckDBIndexesBind(ClientContext &context, vector<Value> &inputs,\n-                                                  named_parameter_map_t &named_parameters,\n-                                                  vector<LogicalType> &input_table_types,\n-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                  vector<string> &names) {\n+static unique_ptr<FunctionData> DuckDBIndexesBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                  vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"schema_name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \ndiff --git a/src/function/table/system/duckdb_keywords.cpp b/src/function/table/system/duckdb_keywords.cpp\nindex bf60bcf6aff9..44c073cf07a7 100644\n--- a/src/function/table/system/duckdb_keywords.cpp\n+++ b/src/function/table/system/duckdb_keywords.cpp\n@@ -14,11 +14,8 @@ struct DuckDBKeywordsData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> DuckDBKeywordsBind(ClientContext &context, vector<Value> &inputs,\n-                                                   named_parameter_map_t &named_parameters,\n-                                                   vector<LogicalType> &input_table_types,\n-                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                   vector<string> &names) {\n+static unique_ptr<FunctionData> DuckDBKeywordsBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                   vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"keyword_name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \ndiff --git a/src/function/table/system/duckdb_schemas.cpp b/src/function/table/system/duckdb_schemas.cpp\nindex 8ed9495d9dee..8405b6152d70 100644\n--- a/src/function/table/system/duckdb_schemas.cpp\n+++ b/src/function/table/system/duckdb_schemas.cpp\n@@ -15,11 +15,8 @@ struct DuckDBSchemasData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> DuckDBSchemasBind(ClientContext &context, vector<Value> &inputs,\n-                                                  named_parameter_map_t &named_parameters,\n-                                                  vector<LogicalType> &input_table_types,\n-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                  vector<string> &names) {\n+static unique_ptr<FunctionData> DuckDBSchemasBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                  vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"oid\");\n \treturn_types.emplace_back(LogicalType::BIGINT);\n \ndiff --git a/src/function/table/system/duckdb_sequences.cpp b/src/function/table/system/duckdb_sequences.cpp\nindex 46b9bd0cd387..42b3f3bdad04 100644\n--- a/src/function/table/system/duckdb_sequences.cpp\n+++ b/src/function/table/system/duckdb_sequences.cpp\n@@ -16,10 +16,7 @@ struct DuckDBSequencesData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> DuckDBSequencesBind(ClientContext &context, vector<Value> &inputs,\n-                                                    named_parameter_map_t &named_parameters,\n-                                                    vector<LogicalType> &input_table_types,\n-                                                    vector<string> &input_table_names,\n+static unique_ptr<FunctionData> DuckDBSequencesBind(ClientContext &context, TableFunctionBindInput &input,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"schema_name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\ndiff --git a/src/function/table/system/duckdb_settings.cpp b/src/function/table/system/duckdb_settings.cpp\nindex 9793d393f148..4d663778f22d 100644\n--- a/src/function/table/system/duckdb_settings.cpp\n+++ b/src/function/table/system/duckdb_settings.cpp\n@@ -20,11 +20,8 @@ struct DuckDBSettingsData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> DuckDBSettingsBind(ClientContext &context, vector<Value> &inputs,\n-                                                   named_parameter_map_t &named_parameters,\n-                                                   vector<LogicalType> &input_table_types,\n-                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                   vector<string> &names) {\n+static unique_ptr<FunctionData> DuckDBSettingsBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                   vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \ndiff --git a/src/function/table/system/duckdb_tables.cpp b/src/function/table/system/duckdb_tables.cpp\nindex 7f96ac432f50..6bbb6ffc8dfe 100644\n--- a/src/function/table/system/duckdb_tables.cpp\n+++ b/src/function/table/system/duckdb_tables.cpp\n@@ -19,11 +19,8 @@ struct DuckDBTablesData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> DuckDBTablesBind(ClientContext &context, vector<Value> &inputs,\n-                                                 named_parameter_map_t &named_parameters,\n-                                                 vector<LogicalType> &input_table_types,\n-                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                 vector<string> &names) {\n+static unique_ptr<FunctionData> DuckDBTablesBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                 vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"schema_name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \ndiff --git a/src/function/table/system/duckdb_types.cpp b/src/function/table/system/duckdb_types.cpp\nindex 8beb5ef94c0f..fed0ebbd60f2 100644\n--- a/src/function/table/system/duckdb_types.cpp\n+++ b/src/function/table/system/duckdb_types.cpp\n@@ -16,11 +16,8 @@ struct DuckDBTypesData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> DuckDBTypesBind(ClientContext &context, vector<Value> &inputs,\n-                                                named_parameter_map_t &named_parameters,\n-                                                vector<LogicalType> &input_table_types,\n-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                vector<string> &names) {\n+static unique_ptr<FunctionData> DuckDBTypesBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"schema_name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \ndiff --git a/src/function/table/system/duckdb_views.cpp b/src/function/table/system/duckdb_views.cpp\nindex 05ec83c76281..600f7eec4ec4 100644\n--- a/src/function/table/system/duckdb_views.cpp\n+++ b/src/function/table/system/duckdb_views.cpp\n@@ -16,11 +16,8 @@ struct DuckDBViewsData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> DuckDBViewsBind(ClientContext &context, vector<Value> &inputs,\n-                                                named_parameter_map_t &named_parameters,\n-                                                vector<LogicalType> &input_table_types,\n-                                                vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                vector<string> &names) {\n+static unique_ptr<FunctionData> DuckDBViewsBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"schema_name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \ndiff --git a/src/function/table/system/pragma_collations.cpp b/src/function/table/system/pragma_collations.cpp\nindex cdf19ef7cfb8..285759c3bd23 100644\n--- a/src/function/table/system/pragma_collations.cpp\n+++ b/src/function/table/system/pragma_collations.cpp\n@@ -15,11 +15,8 @@ struct PragmaCollateData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> PragmaCollateBind(ClientContext &context, vector<Value> &inputs,\n-                                                  named_parameter_map_t &named_parameters,\n-                                                  vector<LogicalType> &input_table_types,\n-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                  vector<string> &names) {\n+static unique_ptr<FunctionData> PragmaCollateBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                  vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"collname\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \ndiff --git a/src/function/table/system/pragma_database_list.cpp b/src/function/table/system/pragma_database_list.cpp\nindex d94cf039638d..fb5e1b2f05d7 100644\n--- a/src/function/table/system/pragma_database_list.cpp\n+++ b/src/function/table/system/pragma_database_list.cpp\n@@ -11,10 +11,7 @@ struct PragmaDatabaseListData : public FunctionOperatorData {\n \tbool finished;\n };\n \n-static unique_ptr<FunctionData> PragmaDatabaseListBind(ClientContext &context, vector<Value> &inputs,\n-                                                       named_parameter_map_t &named_parameters,\n-                                                       vector<LogicalType> &input_table_types,\n-                                                       vector<string> &input_table_names,\n+static unique_ptr<FunctionData> PragmaDatabaseListBind(ClientContext &context, TableFunctionBindInput &input,\n                                                        vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"seq\");\n \treturn_types.emplace_back(LogicalType::INTEGER);\ndiff --git a/src/function/table/system/pragma_database_size.cpp b/src/function/table/system/pragma_database_size.cpp\nindex 2b314ca0490d..2fa8b0097b89 100644\n--- a/src/function/table/system/pragma_database_size.cpp\n+++ b/src/function/table/system/pragma_database_size.cpp\n@@ -15,10 +15,7 @@ struct PragmaDatabaseSizeData : public FunctionOperatorData {\n \tbool finished;\n };\n \n-static unique_ptr<FunctionData> PragmaDatabaseSizeBind(ClientContext &context, vector<Value> &inputs,\n-                                                       named_parameter_map_t &named_parameters,\n-                                                       vector<LogicalType> &input_table_types,\n-                                                       vector<string> &input_table_names,\n+static unique_ptr<FunctionData> PragmaDatabaseSizeBind(ClientContext &context, TableFunctionBindInput &input,\n                                                        vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"database_size\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\ndiff --git a/src/function/table/system/pragma_functions.cpp b/src/function/table/system/pragma_functions.cpp\nindex 39f69d0eb632..8f01cbef90e5 100644\n--- a/src/function/table/system/pragma_functions.cpp\n+++ b/src/function/table/system/pragma_functions.cpp\n@@ -18,10 +18,7 @@ struct PragmaFunctionsData : public FunctionOperatorData {\n \tidx_t offset_in_entry;\n };\n \n-static unique_ptr<FunctionData> PragmaFunctionsBind(ClientContext &context, vector<Value> &inputs,\n-                                                    named_parameter_map_t &named_parameters,\n-                                                    vector<LogicalType> &input_table_types,\n-                                                    vector<string> &input_table_names,\n+static unique_ptr<FunctionData> PragmaFunctionsBind(ClientContext &context, TableFunctionBindInput &input,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"name\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\ndiff --git a/src/function/table/system/pragma_storage_info.cpp b/src/function/table/system/pragma_storage_info.cpp\nindex 563b3ef22448..deb8e126f316 100644\n--- a/src/function/table/system/pragma_storage_info.cpp\n+++ b/src/function/table/system/pragma_storage_info.cpp\n@@ -30,10 +30,7 @@ struct PragmaStorageOperatorData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> PragmaStorageInfoBind(ClientContext &context, vector<Value> &inputs,\n-                                                      named_parameter_map_t &named_parameters,\n-                                                      vector<LogicalType> &input_table_types,\n-                                                      vector<string> &input_table_names,\n+static unique_ptr<FunctionData> PragmaStorageInfoBind(ClientContext &context, TableFunctionBindInput &input,\n                                                       vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"row_group_id\");\n \treturn_types.emplace_back(LogicalType::BIGINT);\n@@ -77,7 +74,7 @@ static unique_ptr<FunctionData> PragmaStorageInfoBind(ClientContext &context, ve\n \tnames.emplace_back(\"block_offset\");\n \treturn_types.emplace_back(LogicalType::BIGINT);\n \n-\tauto qname = QualifiedName::Parse(inputs[0].GetValue<string>());\n+\tauto qname = QualifiedName::Parse(input.inputs[0].GetValue<string>());\n \n \t// look up the table name in the catalog\n \tauto &catalog = Catalog::GetCatalog(context);\ndiff --git a/src/function/table/system/pragma_table_info.cpp b/src/function/table/system/pragma_table_info.cpp\nindex e022f02e5820..8cc24865361c 100644\n--- a/src/function/table/system/pragma_table_info.cpp\n+++ b/src/function/table/system/pragma_table_info.cpp\n@@ -27,10 +27,7 @@ struct PragmaTableOperatorData : public FunctionOperatorData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> PragmaTableInfoBind(ClientContext &context, vector<Value> &inputs,\n-                                                    named_parameter_map_t &named_parameters,\n-                                                    vector<LogicalType> &input_table_types,\n-                                                    vector<string> &input_table_names,\n+static unique_ptr<FunctionData> PragmaTableInfoBind(ClientContext &context, TableFunctionBindInput &input,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"cid\");\n \treturn_types.emplace_back(LogicalType::INTEGER);\n@@ -50,7 +47,7 @@ static unique_ptr<FunctionData> PragmaTableInfoBind(ClientContext &context, vect\n \tnames.emplace_back(\"pk\");\n \treturn_types.emplace_back(LogicalType::BOOLEAN);\n \n-\tauto qname = QualifiedName::Parse(inputs[0].GetValue<string>());\n+\tauto qname = QualifiedName::Parse(input.inputs[0].GetValue<string>());\n \n \t// look up the table name in the catalog\n \tauto &catalog = Catalog::GetCatalog(context);\ndiff --git a/src/function/table/unnest.cpp b/src/function/table/unnest.cpp\nindex 6786427462c5..7050fda731c4 100644\n--- a/src/function/table/unnest.cpp\n+++ b/src/function/table/unnest.cpp\n@@ -17,10 +17,9 @@ struct UnnestOperatorData : public FunctionOperatorData {\n \tidx_t current_count;\n };\n \n-static unique_ptr<FunctionData> UnnestBind(ClientContext &context, vector<Value> &inputs,\n-                                           named_parameter_map_t &named_parameters,\n-                                           vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n+static unique_ptr<FunctionData> UnnestBind(ClientContext &context, TableFunctionBindInput &input,\n                                            vector<LogicalType> &return_types, vector<string> &names) {\n+\tauto &inputs = input.inputs;\n \treturn_types.push_back(ListType::GetChildType(inputs[0].type()));\n \tnames.push_back(inputs[0].ToString());\n \treturn make_unique<UnnestFunctionData>(inputs[0]);\ndiff --git a/src/function/table/version/pragma_version.cpp b/src/function/table/version/pragma_version.cpp\nindex 9674327d2210..ee6365897bd0 100644\n--- a/src/function/table/version/pragma_version.cpp\n+++ b/src/function/table/version/pragma_version.cpp\n@@ -9,11 +9,8 @@ struct PragmaVersionData : public FunctionOperatorData {\n \tbool finished;\n };\n \n-static unique_ptr<FunctionData> PragmaVersionBind(ClientContext &context, vector<Value> &inputs,\n-                                                  named_parameter_map_t &named_parameters,\n-                                                  vector<LogicalType> &input_table_types,\n-                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                  vector<string> &names) {\n+static unique_ptr<FunctionData> PragmaVersionBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                  vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"library_version\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n \tnames.emplace_back(\"source_id\");\ndiff --git a/src/function/table_function.cpp b/src/function/table_function.cpp\nindex 6dec47c5d6e0..944b4df1696a 100644\n--- a/src/function/table_function.cpp\n+++ b/src/function/table_function.cpp\n@@ -5,6 +5,9 @@ namespace duckdb {\n FunctionOperatorData::~FunctionOperatorData() {\n }\n \n+TableFunctionInfo::~TableFunctionInfo() {\n+}\n+\n TableFilterCollection::TableFilterCollection(TableFilterSet *table_filters) : table_filters(table_filters) {\n }\n \ndiff --git a/src/include/duckdb.h b/src/include/duckdb.h\nindex 0bf2334c6c47..9f88539f9eb2 100644\n--- a/src/include/duckdb.h\n+++ b/src/include/duckdb.h\n@@ -74,7 +74,7 @@ typedef enum DUCKDB_TYPE {\n \tDUCKDB_TYPE_FLOAT,\n \t// double\n \tDUCKDB_TYPE_DOUBLE,\n-\t// duckdb_timestamp\n+\t// duckdb_timestamp, in microseconds\n \tDUCKDB_TYPE_TIMESTAMP,\n \t// duckdb_date\n \tDUCKDB_TYPE_DATE,\n@@ -89,7 +89,25 @@ typedef enum DUCKDB_TYPE {\n \t// duckdb_blob\n \tDUCKDB_TYPE_BLOB,\n \t// decimal\n-\tDUCKDB_TYPE_DECIMAL\n+\tDUCKDB_TYPE_DECIMAL,\n+\t// duckdb_timestamp, in seconds\n+\tDUCKDB_TYPE_TIMESTAMP_S,\n+\t// duckdb_timestamp, in milliseconds\n+\tDUCKDB_TYPE_TIMESTAMP_MS,\n+\t// duckdb_timestamp, in nanoseconds\n+\tDUCKDB_TYPE_TIMESTAMP_NS,\n+\t// enum type, only useful as logical type\n+\tDUCKDB_TYPE_ENUM,\n+\t// list type, only useful as logical type\n+\tDUCKDB_TYPE_LIST,\n+\t// struct type, only useful as logical type\n+\tDUCKDB_TYPE_STRUCT,\n+\t// map type, only useful as logical type\n+\tDUCKDB_TYPE_MAP,\n+\t// duckdb_hugeint\n+\tDUCKDB_TYPE_UUID,\n+\t// const char*\n+\tDUCKDB_TYPE_JSON,\n } duckdb_type;\n \n //! Days are stored as days since 1970-01-01\n@@ -203,6 +221,10 @@ typedef void *duckdb_arrow;\n typedef void *duckdb_config;\n typedef void *duckdb_arrow_schema;\n typedef void *duckdb_arrow_array;\n+typedef void *duckdb_logical_type;\n+typedef void *duckdb_data_chunk;\n+typedef void *duckdb_vector;\n+typedef void *duckdb_value;\n \n typedef enum { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;\n \n@@ -366,6 +388,19 @@ Returns `DUCKDB_TYPE_INVALID` if the column is out of range.\n */\n DUCKDB_API duckdb_type duckdb_column_type(duckdb_result *result, idx_t col);\n \n+/*!\n+Returns the logical column type of the specified column.\n+\n+The return type of this call should be destroyed with `duckdb_destroy_logical_type`.\n+\n+Returns `NULL` if the column is out of range.\n+\n+* result: The result object to fetch the column type from.\n+* col: The column index.\n+* returns: The logical column type of the specified column.\n+*/\n+DUCKDB_API duckdb_logical_type duckdb_column_logical_type(duckdb_result *result, idx_t col);\n+\n /*!\n Returns the number of columns present in a the result object.\n \n@@ -392,9 +427,9 @@ queries. For other queries the rows_changed will be 0.\n DUCKDB_API idx_t duckdb_rows_changed(duckdb_result *result);\n \n /*!\n-Returns the data of a specific column of a result in columnar format. This is the fastest way of accessing data in a\n-query result, as no conversion or type checking must be performed (outside of the original switch). If performance\n-is a concern, it is recommended to use this API over the `duckdb_value` functions.\n+**DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.\n+\n+Returns the data of a specific column of a result in columnar format.\n \n The function returns a dense array which contains the result data. The exact type stored in the array depends on the\n corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be\n@@ -413,6 +448,8 @@ printf(\"Data for row %d: %d\\n\", row, data[row]);\n DUCKDB_API void *duckdb_column_data(duckdb_result *result, idx_t col);\n \n /*!\n+**DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.\n+\n Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row\n whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided\n by `duckdb_column_data` are undefined.\n@@ -441,17 +478,42 @@ The result of this function must not be freed. It will be cleaned up when `duckd\n * result: The result object to fetch the nullmask from.\n * returns: The error of the result.\n */\n-DUCKDB_API char *duckdb_result_error(duckdb_result *result);\n+DUCKDB_API const char *duckdb_result_error(duckdb_result *result);\n \n //===--------------------------------------------------------------------===//\n // Result Functions\n //===--------------------------------------------------------------------===//\n \n+/*!\n+Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.\n+\n+This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data`\n+functions. It results in significantly better performance, and should be preferred in newer code-bases.\n+\n+If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be\n+mixed with the legacy result functions).\n+\n+Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.\n+\n+* result: The result object to fetch the data chunk from.\n+* chunk_index: The chunk index to fetch from.\n+* returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.\n+*/\n+DUCKDB_API duckdb_data_chunk duckdb_result_get_chunk(duckdb_result result, idx_t chunk_index);\n+\n+/*!\n+Returns the number of data chunks present in the result.\n+\n+* result: The result object\n+* returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.\n+*/\n+DUCKDB_API idx_t duckdb_result_chunk_count(duckdb_result result);\n+\n // Safe fetch functions\n // These functions will perform conversions if necessary.\n // On failure (e.g. if conversion cannot be performed or if the value is NULL) a default value is returned.\n // Note that these functions are slow since they perform bounds checking and conversion\n-// For fast access of values prefer using duckdb_column_data and duckdb_nullmask_data\n+// For fast access of values prefer using `duckdb_result_get_chunk`\n \n /*!\n  * returns: The boolean value at the specified location, or false if the value cannot be converted.\n@@ -582,6 +644,14 @@ Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_va\n */\n DUCKDB_API void duckdb_free(void *ptr);\n \n+/*!\n+The internal vector size used by DuckDB.\n+This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.\n+\n+* returns: The vector size.\n+*/\n+DUCKDB_API idx_t duckdb_vector_size();\n+\n //===--------------------------------------------------------------------===//\n // Date/Time/Timestamp Helpers\n //===--------------------------------------------------------------------===//\n@@ -695,7 +765,7 @@ DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char\n                                        duckdb_prepared_statement *out_prepared_statement);\n \n /*!\n-Closes the prepared statement and de-allocates all memory allocated for that connection.\n+Closes the prepared statement and de-allocates all memory allocated for the statement.\n \n * prepared_statement: The prepared statement to destroy.\n */\n@@ -863,6 +933,642 @@ Executes the prepared statement with the given bound parameters, and returns an\n DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,\n                                                       duckdb_arrow *out_result);\n \n+//===--------------------------------------------------------------------===//\n+// Value Interface\n+//===--------------------------------------------------------------------===//\n+/*!\n+Destroys the value and de-allocates all memory allocated for that type.\n+\n+* value: The value to destroy.\n+*/\n+DUCKDB_API void duckdb_destroy_value(duckdb_value *value);\n+\n+/*!\n+Creates a value from a varchar\n+\n+* value: The varchar value\n+* returns: The value. This must be destroyed with `duckdb_destroy_value`.\n+*/\n+DUCKDB_API duckdb_value duckdb_create_varchar(const char *text);\n+\n+/*!\n+Creates a value from an int64\n+\n+* value: The bigint value\n+* returns: The value. This must be destroyed with `duckdb_destroy_value`.\n+*/\n+DUCKDB_API duckdb_value duckdb_create_int64(int64_t val);\n+\n+/*!\n+Obtains a string representation of the given value.\n+The result must be destroyed with `duckdb_free`.\n+\n+* value: The value\n+* returns: The string value. This must be destroyed with `duckdb_free`.\n+*/\n+DUCKDB_API char *duckdb_get_varchar(duckdb_value value);\n+\n+/*!\n+Obtains an int64 of the given value.\n+\n+* value: The value\n+* returns: The int64 value, or 0 if no conversion is possible\n+*/\n+DUCKDB_API int64_t duckdb_get_int64(duckdb_value value);\n+\n+//===--------------------------------------------------------------------===//\n+// Logical Type Interface\n+//===--------------------------------------------------------------------===//\n+\n+/*!\n+Creates a `duckdb_logical_type` from a standard primitive type.\n+The resulting type should be destroyed with `duckdb_destroy_logical_type`.\n+\n+This should not be used with `DUCKDB_TYPE_DECIMAL`.\n+\n+* type: The primitive type to create.\n+* returns: The logical type type.\n+*/\n+DUCKDB_API duckdb_logical_type duckdb_create_logical_type(duckdb_type type);\n+\n+/*!\n+Retrieves the type class of a `duckdb_logical_type`.\n+\n+* type: The logical type object\n+* returns: The type id\n+*/\n+DUCKDB_API duckdb_type duckdb_get_type_id(duckdb_logical_type type);\n+\n+/*!\n+Retrieves the width of a decimal type.\n+\n+* type: The logical type object\n+* returns: The width of the decimal type\n+*/\n+DUCKDB_API uint8_t duckdb_decimal_width(duckdb_logical_type type);\n+\n+/*!\n+Retrieves the scale of a decimal type.\n+\n+* type: The logical type object\n+* returns: The scale of the decimal type\n+*/\n+DUCKDB_API uint8_t duckdb_decimal_scale(duckdb_logical_type type);\n+\n+/*!\n+Retrieves the internal storage type of a decimal type.\n+\n+* type: The logical type object\n+* returns: The internal type of the decimal type\n+*/\n+DUCKDB_API duckdb_type duckdb_decimal_internal_type(duckdb_logical_type type);\n+\n+/*!\n+Retrieves the internal storage type of an enum type.\n+\n+* type: The logical type object\n+* returns: The internal type of the enum type\n+*/\n+DUCKDB_API duckdb_type duckdb_enum_internal_type(duckdb_logical_type type);\n+\n+/*!\n+Retrieves the dictionary size of the enum type\n+\n+* type: The logical type object\n+* returns: The dictionary size of the enum type\n+*/\n+DUCKDB_API uint32_t duckdb_enum_dictionary_size(duckdb_logical_type type);\n+\n+/*!\n+Retrieves the dictionary value at the specified position from the enum.\n+\n+The result must be freed with `duckdb_free`\n+\n+* type: The logical type object\n+* index: The index in the dictionary\n+* returns: The string value of the enum type. Must be freed with `duckdb_free`.\n+*/\n+DUCKDB_API char *duckdb_enum_dictionary_value(duckdb_logical_type type, idx_t index);\n+\n+/*!\n+Retrieves the child type of the given list type.\n+\n+The result must be freed with `duckdb_destroy_logical_type`\n+\n+* type: The logical type object\n+* returns: The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`.\n+*/\n+DUCKDB_API duckdb_logical_type duckdb_list_type_child_type(duckdb_logical_type type);\n+\n+/*!\n+Returns the number of children of a struct type.\n+\n+* type: The logical type object\n+* returns: The number of children of a struct type.\n+*/\n+DUCKDB_API idx_t duckdb_struct_type_child_count(duckdb_logical_type type);\n+\n+/*!\n+Retrieves the name of the struct child.\n+\n+The result must be freed with `duckdb_free`\n+\n+* type: The logical type object\n+* index: The child index\n+* returns: The name of the struct type. Must be freed with `duckdb_free`.\n+*/\n+DUCKDB_API char *duckdb_struct_type_child_name(duckdb_logical_type type, idx_t index);\n+\n+/*!\n+Retrieves the child type of the given struct type at the specified index.\n+\n+The result must be freed with `duckdb_destroy_logical_type`\n+\n+* type: The logical type object\n+* index: The child index\n+* returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.\n+*/\n+DUCKDB_API duckdb_logical_type duckdb_struct_type_child_type(duckdb_logical_type type, idx_t index);\n+\n+/*!\n+Destroys the logical type and de-allocates all memory allocated for that type.\n+\n+* type: The logical type to destroy.\n+*/\n+DUCKDB_API void duckdb_destroy_logical_type(duckdb_logical_type *type);\n+\n+//===--------------------------------------------------------------------===//\n+// Data Chunk Interface\n+//===--------------------------------------------------------------------===//\n+/*!\n+Creates an empty DataChunk with the specified set of types.\n+\n+* types: An array of types of the data chunk.\n+* column_count: The number of columns.\n+* returns: The data chunk.\n+*/\n+DUCKDB_API duckdb_data_chunk duckdb_create_data_chunk(duckdb_logical_type *types, idx_t column_count);\n+\n+/*!\n+Destroys the data chunk and de-allocates all memory allocated for that chunk.\n+\n+* chunk: The data chunk to destroy.\n+*/\n+DUCKDB_API void duckdb_destroy_data_chunk(duckdb_data_chunk *chunk);\n+\n+/*!\n+Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.\n+\n+* chunk: The data chunk to reset.\n+*/\n+DUCKDB_API void duckdb_data_chunk_reset(duckdb_data_chunk chunk);\n+\n+/*!\n+Retrieves the number of columns in a data chunk.\n+\n+* chunk: The data chunk to get the data from\n+* returns: The number of columns in the data chunk\n+*/\n+DUCKDB_API idx_t duckdb_data_chunk_get_column_count(duckdb_data_chunk chunk);\n+\n+/*!\n+Retrieves the vector at the specified column index in the data chunk.\n+\n+The pointer to the vector is valid for as long as the chunk is alive.\n+It does NOT need to be destroyed.\n+\n+* chunk: The data chunk to get the data from\n+* returns: The vector\n+*/\n+DUCKDB_API duckdb_vector duckdb_data_chunk_get_vector(duckdb_data_chunk chunk, idx_t col_idx);\n+\n+/*!\n+Retrieves the current number of tuples in a data chunk.\n+\n+* chunk: The data chunk to get the data from\n+* returns: The number of tuples in the data chunk\n+*/\n+DUCKDB_API idx_t duckdb_data_chunk_get_size(duckdb_data_chunk chunk);\n+\n+/*!\n+Sets the current number of tuples in a data chunk.\n+\n+* chunk: The data chunk to set the size in\n+* size: The number of tuples in the data chunk\n+*/\n+DUCKDB_API void duckdb_data_chunk_set_size(duckdb_data_chunk chunk, idx_t size);\n+\n+//===--------------------------------------------------------------------===//\n+// Vector Interface\n+//===--------------------------------------------------------------------===//\n+/*!\n+Retrieves the column type of the specified vector.\n+\n+The result must be destroyed with `duckdb_destroy_logical_type`.\n+\n+* vector: The vector get the data from\n+* returns: The type of the vector\n+*/\n+DUCKDB_API duckdb_logical_type duckdb_vector_get_column_type(duckdb_vector vector);\n+\n+/*!\n+Retrieves the data pointer of the vector.\n+\n+The data pointer can be used to read or write values from the vector.\n+How to read or write values depends on the type of the vector.\n+\n+* vector: The vector to get the data from\n+* returns: The data pointer\n+*/\n+DUCKDB_API void *duckdb_vector_get_data(duckdb_vector vector);\n+\n+/*!\n+Retrieves the validity mask pointer of the specified vector.\n+\n+If all values are valid, this function MIGHT return NULL!\n+\n+The validity mask is a bitset that signifies null-ness within the data chunk.\n+It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.\n+The bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).\n+\n+Validity of a specific value can be obtained like this:\n+\n+idx_t entry_idx = row_idx / 64;\n+idx_t idx_in_entry = row_idx % 64;\n+bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);\n+\n+Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.\n+\n+* vector: The vector to get the data from\n+* returns: The pointer to the validity mask, or NULL if no validity mask is present\n+*/\n+DUCKDB_API uint64_t *duckdb_vector_get_validity(duckdb_vector vector);\n+\n+/*!\n+Ensures the validity mask is writable by allocating it.\n+\n+After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.\n+This allows null values to be written to the vector, regardless of whether a validity mask was present before.\n+\n+* vector: The vector to alter\n+*/\n+DUCKDB_API void duckdb_vector_ensure_validity_writable(duckdb_vector vector);\n+\n+/*!\n+Assigns a string element in the vector at the specified location.\n+\n+* vector: The vector to alter\n+* index: The row position in the vector to assign the string to\n+* str: The null-terminated string\n+*/\n+DUCKDB_API void duckdb_vector_assign_string_element(duckdb_vector vector, idx_t index, const char *str);\n+\n+/*!\n+Assigns a string element in the vector at the specified location.\n+\n+* vector: The vector to alter\n+* index: The row position in the vector to assign the string to\n+* str: The string\n+* str_len: The length of the string (in bytes)\n+*/\n+DUCKDB_API void duckdb_vector_assign_string_element_len(duckdb_vector vector, idx_t index, const char *str,\n+                                                        idx_t str_len);\n+\n+/*!\n+Retrieves the child vector of a list vector.\n+\n+The resulting vector is valid as long as the parent vector is valid.\n+\n+* vector: The vector\n+* returns: The child vector\n+*/\n+DUCKDB_API duckdb_vector duckdb_list_vector_get_child(duckdb_vector vector);\n+\n+/*!\n+Returns the size of the child vector of the list\n+\n+* vector: The vector\n+* returns: The size of the child list\n+*/\n+DUCKDB_API idx_t duckdb_list_vector_get_size(duckdb_vector vector);\n+\n+/*!\n+Retrieves the child vector of a struct vector.\n+\n+The resulting vector is valid as long as the parent vector is valid.\n+\n+* vector: The vector\n+* index: The child index\n+* returns: The child vector\n+*/\n+DUCKDB_API duckdb_vector duckdb_struct_vector_get_child(duckdb_vector vector, idx_t index);\n+\n+//===--------------------------------------------------------------------===//\n+// Validity Mask Functions\n+//===--------------------------------------------------------------------===//\n+/*!\n+Returns whether or not a row is valid (i.e. not NULL) in the given validity mask.\n+\n+* validity: The validity mask, as obtained through `duckdb_data_chunk_get_validity`\n+* row: The row index\n+* returns: true if the row is valid, false otherwise\n+*/\n+DUCKDB_API bool duckdb_validity_row_is_valid(uint64_t *validity, idx_t row);\n+\n+/*!\n+In a validity mask, sets a specific row to either valid or invalid.\n+\n+Note that `duckdb_data_chunk_ensure_validity_writable` should be called before calling `duckdb_data_chunk_get_validity`,\n+to ensure that there is a validity mask to write to.\n+\n+* validity: The validity mask, as obtained through `duckdb_data_chunk_get_validity`.\n+* row: The row index\n+* valid: Whether or not to set the row to valid, or invalid\n+*/\n+DUCKDB_API void duckdb_validity_set_row_validity(uint64_t *validity, idx_t row, bool valid);\n+\n+/*!\n+In a validity mask, sets a specific row to invalid.\n+\n+Equivalent to `duckdb_validity_set_row_validity` with valid set to false.\n+\n+* validity: The validity mask\n+* row: The row index\n+*/\n+DUCKDB_API void duckdb_validity_set_row_invalid(uint64_t *validity, idx_t row);\n+\n+/*!\n+In a validity mask, sets a specific row to valid.\n+\n+Equivalent to `duckdb_validity_set_row_validity` with valid set to true.\n+\n+* validity: The validity mask\n+* row: The row index\n+*/\n+DUCKDB_API void duckdb_validity_set_row_valid(uint64_t *validity, idx_t row);\n+\n+//===--------------------------------------------------------------------===//\n+// Table Functions\n+//===--------------------------------------------------------------------===//\n+typedef void *duckdb_table_function;\n+typedef void *duckdb_bind_info;\n+typedef void *duckdb_init_info;\n+typedef void *duckdb_function_info;\n+\n+typedef void (*duckdb_table_function_bind_t)(duckdb_bind_info info);\n+typedef void (*duckdb_table_function_init_t)(duckdb_init_info info);\n+typedef void (*duckdb_table_function_t)(duckdb_function_info info, duckdb_data_chunk output);\n+typedef void (*duckdb_delete_callback_t)(void *data);\n+\n+/*!\n+Creates a new empty table function.\n+\n+The return value should be destroyed with `duckdb_destroy_table_function`.\n+\n+* returns: The table function object.\n+*/\n+DUCKDB_API duckdb_table_function duckdb_create_table_function();\n+\n+/*!\n+Destroys the given table function object.\n+\n+* table_function: The table function to destroy\n+*/\n+DUCKDB_API void duckdb_destroy_table_function(duckdb_table_function *table_function);\n+\n+/*!\n+Sets the name of the given table function.\n+\n+* table_function: The table function\n+* name: The name of the table function\n+*/\n+DUCKDB_API void duckdb_table_function_set_name(duckdb_table_function table_function, const char *name);\n+\n+/*!\n+Adds a parameter to the table function.\n+\n+* table_function: The table function\n+* type: The type of the parameter to add.\n+*/\n+DUCKDB_API void duckdb_table_function_add_parameter(duckdb_table_function table_function, duckdb_logical_type type);\n+\n+/*!\n+Assigns extra information to the table function that can be fetched during binding, etc.\n+\n+* table_function: The table function\n+* extra_info: The extra information\n+* destroy: The callback that will be called to destroy the bind data (if any)\n+*/\n+DUCKDB_API void duckdb_table_function_set_extra_info(duckdb_table_function table_function, void *extra_info,\n+                                                     duckdb_delete_callback_t destroy);\n+\n+/*!\n+Sets the bind function of the table function\n+\n+* table_function: The table function\n+* bind: The bind function\n+*/\n+DUCKDB_API void duckdb_table_function_set_bind(duckdb_table_function table_function, duckdb_table_function_bind_t bind);\n+\n+/*!\n+Sets the init function of the table function\n+\n+* table_function: The table function\n+* init: The init function\n+*/\n+DUCKDB_API void duckdb_table_function_set_init(duckdb_table_function table_function, duckdb_table_function_init_t init);\n+\n+/*!\n+Sets the main function of the table function\n+\n+* table_function: The table function\n+* function: The function\n+*/\n+DUCKDB_API void duckdb_table_function_set_function(duckdb_table_function table_function,\n+                                                   duckdb_table_function_t function);\n+\n+/*!\n+Register the table function object within the given connection.\n+\n+The function requires at least a name, a bind function, an init function and a main function.\n+\n+If the function is incomplete or a function with this name already exists DuckDBError is returned.\n+\n+* con: The connection to register it in.\n+* function: The function pointer\n+* returns: Whether or not the registration was successful.\n+*/\n+DUCKDB_API duckdb_state duckdb_register_table_function(duckdb_connection con, duckdb_table_function function);\n+\n+//===--------------------------------------------------------------------===//\n+// Table Function Bind\n+//===--------------------------------------------------------------------===//\n+/*!\n+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`\n+\n+* info: The info object\n+* returns: The extra info\n+*/\n+DUCKDB_API void *duckdb_bind_get_extra_info(duckdb_bind_info info);\n+\n+/*!\n+Adds a result column to the output of the table function.\n+\n+* info: The info object\n+* name: The name of the column\n+* type: The logical type of the column\n+*/\n+DUCKDB_API void duckdb_bind_add_result_column(duckdb_bind_info info, const char *name, duckdb_logical_type type);\n+\n+/*!\n+Retrieves the number of regular (non-named) parameters to the function.\n+\n+* info: The info object\n+* returns: The number of parameters\n+*/\n+DUCKDB_API idx_t duckdb_bind_get_parameter_count(duckdb_bind_info info);\n+\n+/*!\n+Retrieves the parameter at the given index.\n+\n+The result must be destroyed with `duckdb_destroy_value`.\n+\n+* info: The info object\n+* index: The index of the parameter to get\n+* returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.\n+*/\n+DUCKDB_API duckdb_value duckdb_bind_get_parameter(duckdb_bind_info info, idx_t index);\n+\n+/*!\n+Sets the user-provided bind data in the bind object. This object can be retrieved again during execution.\n+\n+* info: The info object\n+* extra_data: The bind data object.\n+* destroy: The callback that will be called to destroy the bind data (if any)\n+*/\n+DUCKDB_API void duckdb_bind_set_bind_data(duckdb_bind_info info, void *bind_data, duckdb_delete_callback_t destroy);\n+\n+/*!\n+Report that an error has occurred while calling bind.\n+\n+* info: The info object\n+* error: The error message\n+*/\n+DUCKDB_API void duckdb_bind_set_error(duckdb_bind_info info, const char *error);\n+\n+//===--------------------------------------------------------------------===//\n+// Table Function Init\n+//===--------------------------------------------------------------------===//\n+\n+/*!\n+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`\n+\n+* info: The info object\n+* returns: The extra info\n+*/\n+DUCKDB_API void *duckdb_init_get_extra_info(duckdb_init_info info);\n+\n+/*!\n+Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.\n+\n+Note that the bind data should be considered as read-only.\n+For tracking state, use the init data instead.\n+\n+* info: The info object\n+* returns: The bind data object\n+*/\n+DUCKDB_API void *duckdb_init_get_bind_data(duckdb_init_info info);\n+\n+/*!\n+Sets the user-provided init data in the init object. This object can be retrieved again during execution.\n+\n+* info: The info object\n+* extra_data: The init data object.\n+* destroy: The callback that will be called to destroy the init data (if any)\n+*/\n+DUCKDB_API void duckdb_init_set_init_data(duckdb_init_info info, void *init_data, duckdb_delete_callback_t destroy);\n+\n+/*!\n+Report that an error has occurred while calling init.\n+\n+* info: The info object\n+* error: The error message\n+*/\n+DUCKDB_API void duckdb_init_set_error(duckdb_init_info info, const char *error);\n+\n+//===--------------------------------------------------------------------===//\n+// Table Function\n+//===--------------------------------------------------------------------===//\n+\n+/*!\n+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`\n+\n+* info: The info object\n+* returns: The extra info\n+*/\n+DUCKDB_API void *duckdb_function_get_extra_info(duckdb_function_info info);\n+/*!\n+Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.\n+\n+Note that the bind data should be considered as read-only.\n+For tracking state, use the init data instead.\n+\n+* info: The info object\n+* returns: The bind data object\n+*/\n+DUCKDB_API void *duckdb_function_get_bind_data(duckdb_function_info info);\n+\n+/*!\n+Gets the init data set by `duckdb_bind_set_init_data` during the bind.\n+\n+* info: The info object\n+* returns: The init data object\n+*/\n+DUCKDB_API void *duckdb_function_get_init_data(duckdb_function_info info);\n+\n+/*!\n+Report that an error has occurred while executing the function.\n+\n+* info: The info object\n+* error: The error message\n+*/\n+DUCKDB_API void duckdb_function_set_error(duckdb_function_info info, const char *error);\n+\n+//===--------------------------------------------------------------------===//\n+// Replacement Scans\n+//===--------------------------------------------------------------------===//\n+typedef void *duckdb_replacement_scan_info;\n+\n+typedef void (*duckdb_replacement_callback_t)(duckdb_replacement_scan_info info, const char *table_name, void *data);\n+\n+/*!\n+Add a replacement scan definition to the specified database\n+\n+* db: The database object to add the replacement scan to\n+* replacement: The replacement scan callback\n+* extra_data: Extra data that is passed back into the specified callback\n+* delete_callback: The delete callback to call on the extra data, if any\n+*/\n+DUCKDB_API void duckdb_add_replacement_scan(duckdb_database db, duckdb_replacement_callback_t replacement,\n+                                            void *extra_data, duckdb_delete_callback_t delete_callback);\n+\n+/*!\n+Sets the replacement function name to use. If this function is called in the replacement callback,\n+ the replacement scan is performed. If it is not called, the replacement callback is not performed.\n+\n+* info: The info object\n+* function_name: The function name to substitute.\n+*/\n+DUCKDB_API void duckdb_replacement_scan_set_function_name(duckdb_replacement_scan_info info, const char *function_name);\n+\n+/*!\n+Adds a parameter to the replacement scan function.\n+\n+* info: The info object\n+* parameter: The parameter to add.\n+*/\n+DUCKDB_API void duckdb_replacement_scan_add_parameter(duckdb_replacement_scan_info info, duckdb_value parameter);\n+\n //===--------------------------------------------------------------------===//\n // Appender\n //===--------------------------------------------------------------------===//\n@@ -1030,6 +1736,19 @@ Append a NULL value to the appender (of any type).\n */\n DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);\n \n+/*!\n+Appends a pre-filled data chunk to the specified appender.\n+\n+The types of the data chunk must exactly match the types of the table, no casting is performed.\n+If the types do not match or the appender is in an invalid state, DuckDBError is returned.\n+If the append is successful, DuckDBSuccess is returned.\n+\n+* appender: The appender to append to.\n+* chunk: The data chunk to append.\n+* returns: The return state.\n+*/\n+DUCKDB_API duckdb_state duckdb_append_data_chunk(duckdb_appender appender, duckdb_data_chunk chunk);\n+\n //===--------------------------------------------------------------------===//\n // Arrow Interface\n //===--------------------------------------------------------------------===//\ndiff --git a/src/include/duckdb/function/replacement_scan.hpp b/src/include/duckdb/function/replacement_scan.hpp\nindex 3907cf0588c6..3f0be11613ae 100644\n--- a/src/include/duckdb/function/replacement_scan.hpp\n+++ b/src/include/duckdb/function/replacement_scan.hpp\n@@ -12,18 +12,26 @@\n \n namespace duckdb {\n \n+class ClientContext;\n class TableFunctionRef;\n \n-typedef unique_ptr<TableFunctionRef> (*replacement_scan_t)(const string &table_name, void *data);\n+struct ReplacementScanData {\n+\tvirtual ~ReplacementScanData() {\n+\t}\n+};\n+\n+typedef unique_ptr<TableFunctionRef> (*replacement_scan_t)(ClientContext &context, const string &table_name,\n+                                                           ReplacementScanData *data);\n \n //! Replacement table scans are automatically attempted when a table name cannot be found in the schema\n //! This allows you to do e.g. SELECT * FROM 'filename.csv', and automatically convert this into a CSV scan\n struct ReplacementScan {\n-\texplicit ReplacementScan(replacement_scan_t function, void *data = nullptr) : function(function), data(data) {\n+\texplicit ReplacementScan(replacement_scan_t function, unique_ptr<ReplacementScanData> data_p = nullptr)\n+\t    : function(function), data(move(data_p)) {\n \t}\n \n \treplacement_scan_t function;\n-\tvoid *data;\n+\tunique_ptr<ReplacementScanData> data;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/function/table/arrow.hpp b/src/include/duckdb/function/table/arrow.hpp\nindex bdbdebc47413..91601492397c 100644\n--- a/src/include/duckdb/function/table/arrow.hpp\n+++ b/src/include/duckdb/function/table/arrow.hpp\n@@ -114,11 +114,8 @@ struct ArrowTableFunction {\n \n private:\n \t//! Binds an arrow table\n-\tstatic unique_ptr<FunctionData> ArrowScanBind(ClientContext &context, vector<Value> &inputs,\n-\t                                              named_parameter_map_t &named_parameters,\n-\t                                              vector<LogicalType> &input_table_types,\n-\t                                              vector<string> &input_table_names, vector<LogicalType> &return_types,\n-\t                                              vector<string> &names);\n+\tstatic unique_ptr<FunctionData> ArrowScanBind(ClientContext &context, TableFunctionBindInput &input,\n+\t                                              vector<LogicalType> &return_types, vector<string> &names);\n \t//! Actual conversion from Arrow to DuckDB\n \tstatic void ArrowToDuckDB(ArrowScanState &scan_state,\n \t                          std::unordered_map<idx_t, unique_ptr<ArrowConvertData>> &arrow_convert_data,\ndiff --git a/src/include/duckdb/function/table_function.hpp b/src/include/duckdb/function/table_function.hpp\nindex 0215e4579f25..29d7c9fe7aa1 100644\n--- a/src/include/duckdb/function/table_function.hpp\n+++ b/src/include/duckdb/function/table_function.hpp\n@@ -22,16 +22,32 @@ struct FunctionOperatorData {\n \tDUCKDB_API virtual ~FunctionOperatorData();\n };\n \n+struct TableFunctionInfo {\n+\tDUCKDB_API virtual ~TableFunctionInfo();\n+};\n+\n struct TableFilterCollection {\n \tDUCKDB_API explicit TableFilterCollection(TableFilterSet *table_filters);\n \n \tTableFilterSet *table_filters;\n };\n \n-typedef unique_ptr<FunctionData> (*table_function_bind_t)(ClientContext &context, vector<Value> &inputs,\n-                                                          named_parameter_map_t &named_parameters,\n-                                                          vector<LogicalType> &input_table_types,\n-                                                          vector<string> &input_table_names,\n+struct TableFunctionBindInput {\n+\tTableFunctionBindInput(vector<Value> &inputs, named_parameter_map_t &named_parameters,\n+\t                       vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n+\t                       TableFunctionInfo *info)\n+\t    : inputs(inputs), named_parameters(named_parameters), input_table_types(input_table_types),\n+\t      input_table_names(input_table_names), info(info) {\n+\t}\n+\n+\tvector<Value> &inputs;\n+\tnamed_parameter_map_t &named_parameters;\n+\tvector<LogicalType> &input_table_types;\n+\tvector<string> &input_table_names;\n+\tTableFunctionInfo *info;\n+};\n+\n+typedef unique_ptr<FunctionData> (*table_function_bind_t)(ClientContext &context, TableFunctionBindInput &input,\n                                                           vector<LogicalType> &return_types, vector<string> &names);\n typedef unique_ptr<FunctionOperatorData> (*table_function_init_t)(ClientContext &context, const FunctionData *bind_data,\n                                                                   const vector<column_t> &column_ids,\n@@ -142,6 +158,8 @@ class TableFunction : public SimpleNamedParameterFunction {\n \t//! Whether or not the table function supports filter pushdown. If not supported a filter will be added\n \t//! that applies the table filter directly.\n \tbool filter_pushdown;\n+\t//! Additional function info, passed to the bind\n+\tshared_ptr<TableFunctionInfo> function_info;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/main/appender.hpp b/src/include/duckdb/main/appender.hpp\nindex 0e68cc466210..550bb7b25d0b 100644\n--- a/src/include/duckdb/main/appender.hpp\n+++ b/src/include/duckdb/main/appender.hpp\n@@ -73,6 +73,7 @@ class BaseAppender {\n \tDUCKDB_API idx_t CurrentColumn() {\n \t\treturn column;\n \t}\n+\tDUCKDB_API void AppendDataChunk(DataChunk &value);\n \n protected:\n \tvoid Destructor();\ndiff --git a/src/include/duckdb/main/capi_internal.hpp b/src/include/duckdb/main/capi_internal.hpp\nindex a70767b911ea..d608ac0096e2 100644\n--- a/src/include/duckdb/main/capi_internal.hpp\n+++ b/src/include/duckdb/main/capi_internal.hpp\n@@ -43,12 +43,24 @@ struct AppenderWrapper {\n \tstring error;\n };\n \n-duckdb_type ConvertCPPTypeToC(const LogicalType &type);\n-idx_t GetCTypeSize(duckdb_type type);\n-duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out);\n+enum class CAPIResultSetType : uint8_t {\n+\tCAPI_RESULT_TYPE_NONE = 0,\n+\tCAPI_RESULT_TYPE_MATERIALIZED,\n+\tCAPI_RESULT_TYPE_DEPRECATED\n+};\n \n-struct DuckDBColumnData {\n-\tLogicalType type;\n+struct DuckDBResultData {\n+\t//! The underlying query result\n+\tunique_ptr<QueryResult> result;\n+\t// Results can only use either the new API or the old API, not a mix of the two\n+\t// They start off as \"none\" and switch to one or the other when an API method is used\n+\tCAPIResultSetType result_set_type;\n };\n \n+duckdb_type ConvertCPPTypeToC(const LogicalType &type);\n+LogicalTypeId ConvertCTypeToCPP(duckdb_type c_type);\n+idx_t GetCTypeSize(duckdb_type type);\n+duckdb_state duckdb_translate_result(unique_ptr<QueryResult> result, duckdb_result *out);\n+bool deprecated_materialize_result(duckdb_result *result);\n+\n } // namespace duckdb\ndiff --git a/src/main/appender.cpp b/src/main/appender.cpp\nindex 6994172c1285..d182621a19c4 100644\n--- a/src/main/appender.cpp\n+++ b/src/main/appender.cpp\n@@ -264,6 +264,16 @@ void BaseAppender::AppendValue(const Value &value) {\n \tcolumn++;\n }\n \n+void BaseAppender::AppendDataChunk(DataChunk &chunk) {\n+\tif (chunk.GetTypes() != types) {\n+\t\tthrow InvalidInputException(\"Type mismatch in Append DataChunk and the types required for appender\");\n+\t}\n+\tcollection.Append(chunk);\n+\tif (collection.ChunkCount() >= FLUSH_COUNT) {\n+\t\tFlush();\n+\t}\n+}\n+\n void BaseAppender::FlushChunk() {\n \tif (chunk->size() == 0) {\n \t\treturn;\ndiff --git a/src/main/capi/CMakeLists.txt b/src/main/capi/CMakeLists.txt\nindex 8b6ea56b2393..fbab937b5cdc 100644\n--- a/src/main/capi/CMakeLists.txt\n+++ b/src/main/capi/CMakeLists.txt\n@@ -4,12 +4,17 @@ add_library_unity(\n   appender-c.cpp\n   arrow-c.cpp\n   config-c.cpp\n+  data_chunk-c.cpp\n   datetime-c.cpp\n   duckdb-c.cpp\n+  duckdb_value-c.cpp\n   helper-c.cpp\n   hugeint-c.cpp\n+  logical_types-c.cpp\n   prepared-c.cpp\n+  replacement_scan-c.cpp\n   result-c.cpp\n+  table_function-c.cpp\n   value-c.cpp)\n \n set(ALL_OBJECT_FILES\ndiff --git a/src/main/capi/appender-c.cpp b/src/main/capi/appender-c.cpp\nindex f8e55139febd..7e8f9db86963 100644\n--- a/src/main/capi/appender-c.cpp\n+++ b/src/main/capi/appender-c.cpp\n@@ -194,3 +194,11 @@ duckdb_state duckdb_appender_flush(duckdb_appender appender) {\n duckdb_state duckdb_appender_close(duckdb_appender appender) {\n \treturn duckdb_appender_run_function(appender, [&](Appender &appender) { appender.Close(); });\n }\n+\n+duckdb_state duckdb_append_data_chunk(duckdb_appender appender, duckdb_data_chunk chunk) {\n+\tif (!chunk) {\n+\t\treturn DuckDBError;\n+\t}\n+\tauto data_chunk = (duckdb::DataChunk *)chunk;\n+\treturn duckdb_appender_run_function(appender, [&](Appender &appender) { appender.AppendDataChunk(*data_chunk); });\n+}\ndiff --git a/src/main/capi/data_chunk-c.cpp b/src/main/capi/data_chunk-c.cpp\nnew file mode 100644\nindex 000000000000..cfae42324825\n--- /dev/null\n+++ b/src/main/capi/data_chunk-c.cpp\n@@ -0,0 +1,172 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+#include \"duckdb/common/types/data_chunk.hpp\"\n+#include \"duckdb/common/types/string_type.hpp\"\n+#include <string.h>\n+\n+duckdb_data_chunk duckdb_create_data_chunk(duckdb_logical_type *ctypes, idx_t column_count) {\n+\tif (!ctypes) {\n+\t\treturn nullptr;\n+\t}\n+\tduckdb::vector<duckdb::LogicalType> types;\n+\tfor (idx_t i = 0; i < column_count; i++) {\n+\t\tauto ltype = (duckdb::LogicalType *)ctypes[i];\n+\t\ttypes.push_back(*ltype);\n+\t}\n+\n+\tauto result = new duckdb::DataChunk();\n+\tresult->Initialize(types);\n+\treturn result;\n+}\n+\n+void duckdb_destroy_data_chunk(duckdb_data_chunk *chunk) {\n+\tif (chunk && *chunk) {\n+\t\tauto dchunk = (duckdb::DataChunk *)*chunk;\n+\t\tdelete dchunk;\n+\t\t*chunk = nullptr;\n+\t}\n+}\n+\n+void duckdb_data_chunk_reset(duckdb_data_chunk chunk) {\n+\tif (!chunk) {\n+\t\treturn;\n+\t}\n+\tauto dchunk = (duckdb::DataChunk *)chunk;\n+\tdchunk->Reset();\n+}\n+\n+idx_t duckdb_data_chunk_get_column_count(duckdb_data_chunk chunk) {\n+\tif (!chunk) {\n+\t\treturn 0;\n+\t}\n+\tauto dchunk = (duckdb::DataChunk *)chunk;\n+\treturn dchunk->ColumnCount();\n+}\n+\n+duckdb_vector duckdb_data_chunk_get_vector(duckdb_data_chunk chunk, idx_t col_idx) {\n+\tif (!chunk || col_idx >= duckdb_data_chunk_get_column_count(chunk)) {\n+\t\treturn nullptr;\n+\t}\n+\tauto dchunk = (duckdb::DataChunk *)chunk;\n+\treturn &dchunk->data[col_idx];\n+}\n+\n+idx_t duckdb_data_chunk_get_size(duckdb_data_chunk chunk) {\n+\tif (!chunk) {\n+\t\treturn 0;\n+\t}\n+\tauto dchunk = (duckdb::DataChunk *)chunk;\n+\treturn dchunk->size();\n+}\n+\n+void duckdb_data_chunk_set_size(duckdb_data_chunk chunk, idx_t size) {\n+\tif (!chunk) {\n+\t\treturn;\n+\t}\n+\tauto dchunk = (duckdb::DataChunk *)chunk;\n+\tdchunk->SetCardinality(size);\n+}\n+\n+duckdb_logical_type duckdb_vector_get_column_type(duckdb_vector vector) {\n+\tif (!vector) {\n+\t\treturn nullptr;\n+\t}\n+\tauto v = (duckdb::Vector *)vector;\n+\treturn new duckdb::LogicalType(v->GetType());\n+}\n+\n+void *duckdb_vector_get_data(duckdb_vector vector) {\n+\tif (!vector) {\n+\t\treturn nullptr;\n+\t}\n+\tauto v = (duckdb::Vector *)vector;\n+\treturn duckdb::FlatVector::GetData(*v);\n+}\n+\n+uint64_t *duckdb_vector_get_validity(duckdb_vector vector) {\n+\tif (!vector) {\n+\t\treturn nullptr;\n+\t}\n+\tauto v = (duckdb::Vector *)vector;\n+\treturn duckdb::FlatVector::Validity(*v).GetData();\n+}\n+\n+void duckdb_vector_ensure_validity_writable(duckdb_vector vector) {\n+\tif (!vector) {\n+\t\treturn;\n+\t}\n+\tauto v = (duckdb::Vector *)vector;\n+\tauto &validity = duckdb::FlatVector::Validity(*v);\n+\tvalidity.EnsureWritable();\n+}\n+\n+void duckdb_vector_assign_string_element(duckdb_vector vector, idx_t index, const char *str) {\n+\tduckdb_vector_assign_string_element_len(vector, index, str, strlen(str));\n+}\n+\n+void duckdb_vector_assign_string_element_len(duckdb_vector vector, idx_t index, const char *str, idx_t str_len) {\n+\tif (!vector) {\n+\t\treturn;\n+\t}\n+\tauto v = (duckdb::Vector *)vector;\n+\tauto data = duckdb::FlatVector::GetData<duckdb::string_t>(*v);\n+\tdata[index] = duckdb::StringVector::AddString(*v, str, str_len);\n+}\n+\n+duckdb_vector duckdb_list_vector_get_child(duckdb_vector vector) {\n+\tif (!vector) {\n+\t\treturn nullptr;\n+\t}\n+\tauto v = (duckdb::Vector *)vector;\n+\treturn &duckdb::ListVector::GetEntry(*v);\n+}\n+\n+idx_t duckdb_list_vector_get_size(duckdb_vector vector) {\n+\tif (!vector) {\n+\t\treturn 0;\n+\t}\n+\tauto v = (duckdb::Vector *)vector;\n+\treturn duckdb::ListVector::GetListSize(*v);\n+}\n+\n+duckdb_vector duckdb_struct_vector_get_child(duckdb_vector vector, idx_t index) {\n+\tif (!vector) {\n+\t\treturn nullptr;\n+\t}\n+\tauto v = (duckdb::Vector *)vector;\n+\treturn duckdb::StructVector::GetEntries(*v)[index].get();\n+}\n+\n+bool duckdb_validity_row_is_valid(uint64_t *validity, idx_t row) {\n+\tif (!validity) {\n+\t\treturn true;\n+\t}\n+\tidx_t entry_idx = row / 64;\n+\tidx_t idx_in_entry = row % 64;\n+\treturn validity[entry_idx] & (1 << idx_in_entry);\n+}\n+\n+void duckdb_validity_set_row_validity(uint64_t *validity, idx_t row, bool valid) {\n+\tif (valid) {\n+\t\tduckdb_validity_set_row_valid(validity, row);\n+\t} else {\n+\t\tduckdb_validity_set_row_invalid(validity, row);\n+\t}\n+}\n+\n+void duckdb_validity_set_row_invalid(uint64_t *validity, idx_t row) {\n+\tif (!validity) {\n+\t\treturn;\n+\t}\n+\tidx_t entry_idx = row / 64;\n+\tidx_t idx_in_entry = row % 64;\n+\tvalidity[entry_idx] &= ~(1 << idx_in_entry);\n+}\n+\n+void duckdb_validity_set_row_valid(uint64_t *validity, idx_t row) {\n+\tif (!validity) {\n+\t\treturn;\n+\t}\n+\tidx_t entry_idx = row / 64;\n+\tidx_t idx_in_entry = row % 64;\n+\tvalidity[entry_idx] |= 1 << idx_in_entry;\n+}\ndiff --git a/src/main/capi/duckdb-c.cpp b/src/main/capi/duckdb-c.cpp\nindex 575f6699a8ae..d882607b3439 100644\n--- a/src/main/capi/duckdb-c.cpp\n+++ b/src/main/capi/duckdb-c.cpp\n@@ -65,5 +65,5 @@ void duckdb_disconnect(duckdb_connection *connection) {\n duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out) {\n \tConnection *conn = (Connection *)connection;\n \tauto result = conn->Query(query);\n-\treturn duckdb_translate_result(result.get(), out);\n+\treturn duckdb_translate_result(move(result), out);\n }\ndiff --git a/src/main/capi/duckdb_value-c.cpp b/src/main/capi/duckdb_value-c.cpp\nnew file mode 100644\nindex 000000000000..731bb8672b41\n--- /dev/null\n+++ b/src/main/capi/duckdb_value-c.cpp\n@@ -0,0 +1,37 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+\n+void duckdb_destroy_value(duckdb_value *value) {\n+\tif (value && *value) {\n+\t\tauto val = (duckdb::Value *)*value;\n+\t\tdelete val;\n+\t\t*value = nullptr;\n+\t}\n+}\n+\n+duckdb_value duckdb_create_varchar(const char *text) {\n+\treturn (duckdb_value) new duckdb::Value(text);\n+}\n+\n+duckdb_value duckdb_create_int64(int64_t input) {\n+\tauto val = duckdb::Value::BIGINT(input);\n+\treturn (duckdb_value) new duckdb::Value(val);\n+}\n+\n+char *duckdb_get_varchar(duckdb_value value) {\n+\tauto val = (duckdb::Value *)value;\n+\tauto str_val = val->CastAs(duckdb::LogicalType::VARCHAR);\n+\tauto &str = duckdb::StringValue::Get(str_val);\n+\n+\tauto result = (char *)malloc(sizeof(char *) * (str.size() + 1));\n+\tmemcpy(result, str.c_str(), str.size());\n+\tresult[str.size()] = '\\0';\n+\treturn result;\n+}\n+\n+int64_t duckdb_get_int64(duckdb_value value) {\n+\tauto val = (duckdb::Value *)value;\n+\tif (!val->TryCastAs(duckdb::LogicalType::BIGINT)) {\n+\t\treturn 0;\n+\t}\n+\treturn duckdb::BigIntValue::Get(*val);\n+}\ndiff --git a/src/main/capi/helper-c.cpp b/src/main/capi/helper-c.cpp\nindex c754432fb5f1..8f545c53c6f2 100644\n--- a/src/main/capi/helper-c.cpp\n+++ b/src/main/capi/helper-c.cpp\n@@ -2,6 +2,60 @@\n \n namespace duckdb {\n \n+LogicalTypeId ConvertCTypeToCPP(duckdb_type c_type) {\n+\tswitch (c_type) {\n+\tcase DUCKDB_TYPE_BOOLEAN:\n+\t\treturn LogicalTypeId::BOOLEAN;\n+\tcase DUCKDB_TYPE_TINYINT:\n+\t\treturn LogicalTypeId::TINYINT;\n+\tcase DUCKDB_TYPE_SMALLINT:\n+\t\treturn LogicalTypeId::SMALLINT;\n+\tcase DUCKDB_TYPE_INTEGER:\n+\t\treturn LogicalTypeId::INTEGER;\n+\tcase DUCKDB_TYPE_BIGINT:\n+\t\treturn LogicalTypeId::BIGINT;\n+\tcase DUCKDB_TYPE_UTINYINT:\n+\t\treturn LogicalTypeId::UTINYINT;\n+\tcase DUCKDB_TYPE_USMALLINT:\n+\t\treturn LogicalTypeId::USMALLINT;\n+\tcase DUCKDB_TYPE_UINTEGER:\n+\t\treturn LogicalTypeId::UINTEGER;\n+\tcase DUCKDB_TYPE_UBIGINT:\n+\t\treturn LogicalTypeId::UBIGINT;\n+\tcase DUCKDB_TYPE_HUGEINT:\n+\t\treturn LogicalTypeId::HUGEINT;\n+\tcase DUCKDB_TYPE_FLOAT:\n+\t\treturn LogicalTypeId::FLOAT;\n+\tcase DUCKDB_TYPE_DOUBLE:\n+\t\treturn LogicalTypeId::DOUBLE;\n+\tcase DUCKDB_TYPE_TIMESTAMP:\n+\t\treturn LogicalTypeId::TIMESTAMP;\n+\tcase DUCKDB_TYPE_DATE:\n+\t\treturn LogicalTypeId::DATE;\n+\tcase DUCKDB_TYPE_TIME:\n+\t\treturn LogicalTypeId::TIME;\n+\tcase DUCKDB_TYPE_VARCHAR:\n+\t\treturn LogicalTypeId::VARCHAR;\n+\tcase DUCKDB_TYPE_JSON:\n+\t\treturn LogicalTypeId::JSON;\n+\tcase DUCKDB_TYPE_BLOB:\n+\t\treturn LogicalTypeId::BLOB;\n+\tcase DUCKDB_TYPE_INTERVAL:\n+\t\treturn LogicalTypeId::INTERVAL;\n+\tcase DUCKDB_TYPE_TIMESTAMP_S:\n+\t\treturn LogicalTypeId::TIMESTAMP_SEC;\n+\tcase DUCKDB_TYPE_TIMESTAMP_MS:\n+\t\treturn LogicalTypeId::TIMESTAMP_MS;\n+\tcase DUCKDB_TYPE_TIMESTAMP_NS:\n+\t\treturn LogicalTypeId::TIMESTAMP_NS;\n+\tcase DUCKDB_TYPE_UUID:\n+\t\treturn LogicalTypeId::UUID;\n+\tdefault: // LCOV_EXCL_START\n+\t\tD_ASSERT(0);\n+\t\treturn LogicalTypeId::INVALID;\n+\t} // LCOV_EXCL_STOP\n+}\n+\n duckdb_type ConvertCPPTypeToC(const LogicalType &sql_type) {\n \tswitch (sql_type.id()) {\n \tcase LogicalTypeId::BOOLEAN:\n@@ -29,11 +83,14 @@ duckdb_type ConvertCPPTypeToC(const LogicalType &sql_type) {\n \tcase LogicalTypeId::DOUBLE:\n \t\treturn DUCKDB_TYPE_DOUBLE;\n \tcase LogicalTypeId::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\t\treturn DUCKDB_TYPE_TIMESTAMP;\n \tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\treturn DUCKDB_TYPE_TIMESTAMP_S;\n \tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\treturn DUCKDB_TYPE_TIMESTAMP_MS;\n \tcase LogicalTypeId::TIMESTAMP_NS:\n-\tcase LogicalTypeId::TIMESTAMP_TZ:\n-\t\treturn DUCKDB_TYPE_TIMESTAMP;\n+\t\treturn DUCKDB_TYPE_TIMESTAMP_NS;\n \tcase LogicalTypeId::DATE:\n \t\treturn DUCKDB_TYPE_DATE;\n \tcase LogicalTypeId::TIME:\n@@ -41,17 +98,30 @@ duckdb_type ConvertCPPTypeToC(const LogicalType &sql_type) {\n \t\treturn DUCKDB_TYPE_TIME;\n \tcase LogicalTypeId::VARCHAR:\n \t\treturn DUCKDB_TYPE_VARCHAR;\n+\tcase LogicalTypeId::JSON:\n+\t\treturn DUCKDB_TYPE_JSON;\n \tcase LogicalTypeId::BLOB:\n \t\treturn DUCKDB_TYPE_BLOB;\n \tcase LogicalTypeId::INTERVAL:\n \t\treturn DUCKDB_TYPE_INTERVAL;\n \tcase LogicalTypeId::DECIMAL:\n \t\treturn DUCKDB_TYPE_DECIMAL;\n+\tcase LogicalTypeId::ENUM:\n+\t\treturn DUCKDB_TYPE_ENUM;\n+\tcase LogicalTypeId::LIST:\n+\t\treturn DUCKDB_TYPE_LIST;\n+\tcase LogicalTypeId::STRUCT:\n+\t\treturn DUCKDB_TYPE_STRUCT;\n+\tcase LogicalTypeId::MAP:\n+\t\treturn DUCKDB_TYPE_MAP;\n+\tcase LogicalTypeId::UUID:\n+\t\treturn DUCKDB_TYPE_UUID;\n \tdefault: // LCOV_EXCL_START\n \t\tD_ASSERT(0);\n \t\treturn DUCKDB_TYPE_INVALID;\n \t} // LCOV_EXCL_STOP\n }\n+\n idx_t GetCTypeSize(duckdb_type type) {\n \tswitch (type) {\n \tcase DUCKDB_TYPE_BOOLEAN:\n@@ -73,6 +143,7 @@ idx_t GetCTypeSize(duckdb_type type) {\n \tcase DUCKDB_TYPE_UBIGINT:\n \t\treturn sizeof(uint64_t);\n \tcase DUCKDB_TYPE_HUGEINT:\n+\tcase DUCKDB_TYPE_UUID:\n \t\treturn sizeof(duckdb_hugeint);\n \tcase DUCKDB_TYPE_FLOAT:\n \t\treturn sizeof(float);\n@@ -83,6 +154,9 @@ idx_t GetCTypeSize(duckdb_type type) {\n \tcase DUCKDB_TYPE_TIME:\n \t\treturn sizeof(duckdb_time);\n \tcase DUCKDB_TYPE_TIMESTAMP:\n+\tcase DUCKDB_TYPE_TIMESTAMP_S:\n+\tcase DUCKDB_TYPE_TIMESTAMP_MS:\n+\tcase DUCKDB_TYPE_TIMESTAMP_NS:\n \t\treturn sizeof(duckdb_timestamp);\n \tcase DUCKDB_TYPE_VARCHAR:\n \t\treturn sizeof(const char *);\n@@ -108,3 +182,7 @@ void *duckdb_malloc(size_t size) {\n void duckdb_free(void *ptr) {\n \tfree(ptr);\n }\n+\n+idx_t duckdb_vector_size() {\n+\treturn STANDARD_VECTOR_SIZE;\n+}\ndiff --git a/src/main/capi/logical_types-c.cpp b/src/main/capi/logical_types-c.cpp\nnew file mode 100644\nindex 000000000000..44825001fc44\n--- /dev/null\n+++ b/src/main/capi/logical_types-c.cpp\n@@ -0,0 +1,153 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+\n+duckdb_logical_type duckdb_create_logical_type(duckdb_type type) {\n+\treturn new duckdb::LogicalType(duckdb::ConvertCTypeToCPP(type));\n+}\n+\n+duckdb_type duckdb_get_type_id(duckdb_logical_type type) {\n+\tif (!type) {\n+\t\treturn DUCKDB_TYPE_INVALID;\n+\t}\n+\tauto ltype = (duckdb::LogicalType *)type;\n+\treturn duckdb::ConvertCPPTypeToC(*ltype);\n+}\n+\n+void duckdb_destroy_logical_type(duckdb_logical_type *type) {\n+\tif (type && *type) {\n+\t\tauto ltype = (duckdb::LogicalType *)*type;\n+\t\tdelete ltype;\n+\t\t*type = nullptr;\n+\t}\n+}\n+\n+uint8_t duckdb_decimal_width(duckdb_logical_type type) {\n+\tif (!type) {\n+\t\treturn 0;\n+\t}\n+\tauto &ltype = *((duckdb::LogicalType *)type);\n+\tif (ltype.id() != duckdb::LogicalTypeId::DECIMAL) {\n+\t\treturn 0;\n+\t}\n+\treturn duckdb::DecimalType::GetWidth(ltype);\n+}\n+\n+uint8_t duckdb_decimal_scale(duckdb_logical_type type) {\n+\tif (!type) {\n+\t\treturn 0;\n+\t}\n+\tauto &ltype = *((duckdb::LogicalType *)type);\n+\tif (ltype.id() != duckdb::LogicalTypeId::DECIMAL) {\n+\t\treturn 0;\n+\t}\n+\treturn duckdb::DecimalType::GetScale(ltype);\n+}\n+\n+duckdb_type duckdb_decimal_internal_type(duckdb_logical_type type) {\n+\tif (!type) {\n+\t\treturn DUCKDB_TYPE_INVALID;\n+\t}\n+\tauto &ltype = *((duckdb::LogicalType *)type);\n+\tif (ltype.id() != duckdb::LogicalTypeId::DECIMAL) {\n+\t\treturn DUCKDB_TYPE_INVALID;\n+\t}\n+\tswitch (ltype.InternalType()) {\n+\tcase duckdb::PhysicalType::INT16:\n+\t\treturn DUCKDB_TYPE_SMALLINT;\n+\tcase duckdb::PhysicalType::INT32:\n+\t\treturn DUCKDB_TYPE_INTEGER;\n+\tcase duckdb::PhysicalType::INT64:\n+\t\treturn DUCKDB_TYPE_BIGINT;\n+\tcase duckdb::PhysicalType::INT128:\n+\t\treturn DUCKDB_TYPE_HUGEINT;\n+\tdefault:\n+\t\treturn DUCKDB_TYPE_INVALID;\n+\t}\n+}\n+\n+duckdb_type duckdb_enum_internal_type(duckdb_logical_type type) {\n+\tif (!type) {\n+\t\treturn DUCKDB_TYPE_INVALID;\n+\t}\n+\tauto &ltype = *((duckdb::LogicalType *)type);\n+\tif (ltype.id() != duckdb::LogicalTypeId::ENUM) {\n+\t\treturn DUCKDB_TYPE_INVALID;\n+\t}\n+\tswitch (ltype.InternalType()) {\n+\tcase duckdb::PhysicalType::UINT8:\n+\t\treturn DUCKDB_TYPE_UTINYINT;\n+\tcase duckdb::PhysicalType::UINT16:\n+\t\treturn DUCKDB_TYPE_USMALLINT;\n+\tcase duckdb::PhysicalType::UINT32:\n+\t\treturn DUCKDB_TYPE_UINTEGER;\n+\tdefault:\n+\t\treturn DUCKDB_TYPE_INVALID;\n+\t}\n+}\n+\n+uint32_t duckdb_enum_dictionary_size(duckdb_logical_type type) {\n+\tif (!type) {\n+\t\treturn 0;\n+\t}\n+\tauto &ltype = *((duckdb::LogicalType *)type);\n+\tif (ltype.id() != duckdb::LogicalTypeId::ENUM) {\n+\t\treturn 0;\n+\t}\n+\treturn duckdb::EnumType::GetSize(ltype);\n+}\n+\n+char *duckdb_enum_dictionary_value(duckdb_logical_type type, idx_t index) {\n+\tif (!type) {\n+\t\treturn nullptr;\n+\t}\n+\tauto &ltype = *((duckdb::LogicalType *)type);\n+\tif (ltype.id() != duckdb::LogicalTypeId::ENUM) {\n+\t\treturn nullptr;\n+\t}\n+\tauto &vector = duckdb::EnumType::GetValuesInsertOrder(ltype);\n+\tauto value = vector.GetValue(index);\n+\treturn strdup(duckdb::StringValue::Get(value).c_str());\n+}\n+\n+duckdb_logical_type duckdb_list_type_child_type(duckdb_logical_type type) {\n+\tif (!type) {\n+\t\treturn nullptr;\n+\t}\n+\tauto &ltype = *((duckdb::LogicalType *)type);\n+\tif (ltype.id() != duckdb::LogicalTypeId::LIST) {\n+\t\treturn nullptr;\n+\t}\n+\treturn new duckdb::LogicalType(duckdb::ListType::GetChildType(ltype));\n+}\n+\n+idx_t duckdb_struct_type_child_count(duckdb_logical_type type) {\n+\tif (!type) {\n+\t\treturn 0;\n+\t}\n+\tauto &ltype = *((duckdb::LogicalType *)type);\n+\tif (ltype.InternalType() != duckdb::PhysicalType::STRUCT) {\n+\t\treturn 0;\n+\t}\n+\treturn duckdb::StructType::GetChildCount(ltype);\n+}\n+\n+char *duckdb_struct_type_child_name(duckdb_logical_type type, idx_t index) {\n+\tif (!type) {\n+\t\treturn nullptr;\n+\t}\n+\tauto &ltype = *((duckdb::LogicalType *)type);\n+\tif (ltype.InternalType() != duckdb::PhysicalType::STRUCT) {\n+\t\treturn nullptr;\n+\t}\n+\treturn strdup(duckdb::StructType::GetChildName(ltype, index).c_str());\n+}\n+\n+duckdb_logical_type duckdb_struct_type_child_type(duckdb_logical_type type, idx_t index) {\n+\tif (!type) {\n+\t\treturn nullptr;\n+\t}\n+\tauto &ltype = *((duckdb::LogicalType *)type);\n+\tif (ltype.InternalType() != duckdb::PhysicalType::STRUCT) {\n+\t\treturn nullptr;\n+\t}\n+\treturn new duckdb::LogicalType(duckdb::StructType::GetChildType(ltype, index));\n+}\ndiff --git a/src/main/capi/prepared-c.cpp b/src/main/capi/prepared-c.cpp\nindex ab2eb84ed684..ac6ad15004bd 100644\n--- a/src/main/capi/prepared-c.cpp\n+++ b/src/main/capi/prepared-c.cpp\n@@ -58,7 +58,7 @@ static duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_stateme\n \tif (!wrapper || !wrapper->statement || !wrapper->statement->success) {\n \t\treturn DuckDBError;\n \t}\n-\tif (param_idx > wrapper->statement->n_param) {\n+\tif (param_idx <= 0 || param_idx > wrapper->statement->n_param) {\n \t\treturn DuckDBError;\n \t}\n \tif (param_idx > wrapper->values.size()) {\n@@ -143,12 +143,20 @@ duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement,\n }\n \n duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value(val));\n+\ttry {\n+\t\treturn duckdb_bind_value(prepared_statement, param_idx, Value(val));\n+\t} catch (...) {\n+\t\treturn DuckDBError;\n+\t}\n }\n \n duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val,\n                                         idx_t length) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value(std::string(val, length)));\n+\ttry {\n+\t\treturn duckdb_bind_value(prepared_statement, param_idx, Value(std::string(val, length)));\n+\t} catch (...) {\n+\t\treturn DuckDBError;\n+\t}\n }\n \n duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx, const void *data,\n@@ -166,9 +174,7 @@ duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statemen\n \t\treturn DuckDBError;\n \t}\n \tauto result = wrapper->statement->Execute(wrapper->values, false);\n-\tD_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);\n-\tauto mat_res = (MaterializedQueryResult *)result.get();\n-\treturn duckdb_translate_result(mat_res, out_result);\n+\treturn duckdb_translate_result(move(result), out_result);\n }\n \n void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement) {\ndiff --git a/src/main/capi/replacement_scan-c.cpp b/src/main/capi/replacement_scan-c.cpp\nnew file mode 100644\nindex 000000000000..b666f165986a\n--- /dev/null\n+++ b/src/main/capi/replacement_scan-c.cpp\n@@ -0,0 +1,82 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+#include \"duckdb/main/config.hpp\"\n+#include \"duckdb/parser/tableref/table_function_ref.hpp\"\n+#include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/expression/function_expression.hpp\"\n+\n+namespace duckdb {\n+\n+struct CAPIReplacementScanData : public ReplacementScanData {\n+\t~CAPIReplacementScanData() {\n+\t\tif (delete_callback) {\n+\t\t\tdelete_callback(extra_data);\n+\t\t}\n+\t}\n+\n+\tduckdb_replacement_callback_t callback;\n+\tvoid *extra_data;\n+\tduckdb_delete_callback_t delete_callback;\n+};\n+\n+struct CAPIReplacementScanInfo {\n+\tCAPIReplacementScanInfo(CAPIReplacementScanData *data) : data(data) {\n+\t}\n+\n+\tCAPIReplacementScanData *data;\n+\tstring function_name;\n+\tvector<Value> parameters;\n+};\n+\n+unique_ptr<TableFunctionRef> duckdb_capi_replacement_callback(ClientContext &context, const string &table_name,\n+                                                              ReplacementScanData *data) {\n+\tauto &scan_data = (CAPIReplacementScanData &)*data;\n+\n+\tCAPIReplacementScanInfo info(&scan_data);\n+\tscan_data.callback((duckdb_replacement_scan_info)&info, table_name.c_str(), scan_data.extra_data);\n+\tif (info.function_name.empty()) {\n+\t\t// no function provided: bail-out\n+\t\treturn nullptr;\n+\t}\n+\tauto table_function = make_unique<TableFunctionRef>();\n+\tvector<unique_ptr<ParsedExpression>> children;\n+\tfor (auto &param : info.parameters) {\n+\t\tchildren.push_back(make_unique<ConstantExpression>(move(param)));\n+\t}\n+\ttable_function->function = make_unique<FunctionExpression>(info.function_name, move(children));\n+\treturn table_function;\n+}\n+\n+} // namespace duckdb\n+\n+void duckdb_add_replacement_scan(duckdb_database db, duckdb_replacement_callback_t replacement, void *extra_data,\n+                                 duckdb_delete_callback_t delete_callback) {\n+\tif (!db || !replacement) {\n+\t\treturn;\n+\t}\n+\tauto wrapper = (duckdb::DatabaseData *)db;\n+\tauto scan_info = duckdb::make_unique<duckdb::CAPIReplacementScanData>();\n+\tscan_info->callback = replacement;\n+\tscan_info->extra_data = extra_data;\n+\tscan_info->delete_callback = delete_callback;\n+\n+\tauto &config = duckdb::DBConfig::GetConfig(*wrapper->database->instance);\n+\tconfig.replacement_scans.push_back(\n+\t    duckdb::ReplacementScan(duckdb::duckdb_capi_replacement_callback, move(scan_info)));\n+}\n+\n+void duckdb_replacement_scan_set_function_name(duckdb_replacement_scan_info info_p, const char *function_name) {\n+\tif (!info_p || !function_name) {\n+\t\treturn;\n+\t}\n+\tauto info = (duckdb::CAPIReplacementScanInfo *)info_p;\n+\tinfo->function_name = function_name;\n+}\n+\n+void duckdb_replacement_scan_add_parameter(duckdb_replacement_scan_info info_p, duckdb_value parameter) {\n+\tif (!info_p || !parameter) {\n+\t\treturn;\n+\t}\n+\tauto info = (duckdb::CAPIReplacementScanInfo *)info_p;\n+\tauto val = (duckdb::Value *)parameter;\n+\tinfo->parameters.push_back(*val);\n+}\ndiff --git a/src/main/capi/result-c.cpp b/src/main/capi/result-c.cpp\nindex 25d31f9d39a7..d65f590c1045 100644\n--- a/src/main/capi/result-c.cpp\n+++ b/src/main/capi/result-c.cpp\n@@ -4,9 +4,9 @@\n namespace duckdb {\n \n template <class T>\n-void WriteData(duckdb_result *out, ChunkCollection &source, idx_t col) {\n+void WriteData(duckdb_column *column, ChunkCollection &source, idx_t col) {\n \tidx_t row = 0;\n-\tauto target = (T *)out->__deprecated_columns[col].__deprecated_data;\n+\tauto target = (T *)column->__deprecated_data;\n \tfor (auto &chunk : source.Chunks()) {\n \t\tauto source = FlatVector::GetData<T>(chunk->data[col]);\n \t\tauto &mask = FlatVector::Validity(chunk->data[col]);\n@@ -20,276 +20,317 @@ void WriteData(duckdb_result *out, ChunkCollection &source, idx_t col) {\n \t}\n }\n \n-duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out) {\n-\tD_ASSERT(result);\n-\tif (!out) {\n-\t\t// no result to write to, only return the status\n-\t\treturn result->success ? DuckDBSuccess : DuckDBError;\n-\t}\n-\tmemset(out, 0, sizeof(duckdb_result));\n-\tif (!result->success) {\n-\t\t// write the error message\n-\t\tout->__deprecated_error_message = strdup(result->error.c_str());\n-\t\treturn DuckDBError;\n-\t}\n-\t// copy the data\n-\t// first write the meta data\n-\tout->__deprecated_column_count = result->types.size();\n-\tout->__deprecated_row_count = result->collection.Count();\n-\tout->__deprecated_rows_changed = 0;\n-\tif (out->__deprecated_row_count > 0 && StatementTypeReturnChanges(result->statement_type)) {\n-\t\t// update total changes\n-\t\tauto row_changes = result->GetValue(0, 0);\n-\t\tif (!row_changes.IsNull() && row_changes.TryCastAs(LogicalType::BIGINT)) {\n-\t\t\tout->__deprecated_rows_changed = row_changes.GetValue<int64_t>();\n-\t\t}\n-\t}\n-\tout->__deprecated_columns = (duckdb_column *)duckdb_malloc(sizeof(duckdb_column) * out->__deprecated_column_count);\n-\tif (!out->__deprecated_columns) { // LCOV_EXCL_START\n+duckdb_state deprecated_duckdb_translate_column(MaterializedQueryResult &result, duckdb_column *column, idx_t col) {\n+\tidx_t row_count = result.collection.Count();\n+\tcolumn->__deprecated_nullmask = (bool *)duckdb_malloc(sizeof(bool) * result.collection.Count());\n+\tcolumn->__deprecated_data = duckdb_malloc(GetCTypeSize(column->__deprecated_type) * row_count);\n+\tif (!column->__deprecated_nullmask || !column->__deprecated_data) { // LCOV_EXCL_START\n \t\t// malloc failure\n \t\treturn DuckDBError;\n \t} // LCOV_EXCL_STOP\n \n-\t// zero initialize the columns (so we can cleanly delete it in case a malloc fails)\n-\tmemset(out->__deprecated_columns, 0, sizeof(duckdb_column) * out->__deprecated_column_count);\n-\tfor (idx_t i = 0; i < out->__deprecated_column_count; i++) {\n-\t\tauto column_data = new DuckDBColumnData();\n-\t\tcolumn_data->type = result->types[i];\n-\t\tout->__deprecated_columns[i].internal_data = column_data;\n-\t\tout->__deprecated_columns[i].__deprecated_type = ConvertCPPTypeToC(result->types[i]);\n-\t\tout->__deprecated_columns[i].__deprecated_name = strdup(result->names[i].c_str());\n-\t\tout->__deprecated_columns[i].__deprecated_nullmask =\n-\t\t    (bool *)duckdb_malloc(sizeof(bool) * out->__deprecated_row_count);\n-\t\tout->__deprecated_columns[i].__deprecated_data =\n-\t\t    duckdb_malloc(GetCTypeSize(out->__deprecated_columns[i].__deprecated_type) * out->__deprecated_row_count);\n-\t\tif (!out->__deprecated_columns[i].__deprecated_nullmask || !out->__deprecated_columns[i].__deprecated_name ||\n-\t\t    !out->__deprecated_columns[i].__deprecated_data) { // LCOV_EXCL_START\n-\t\t\t// malloc failure\n-\t\t\treturn DuckDBError;\n-\t\t} // LCOV_EXCL_STOP\n+\t// first convert the nullmask\n+\tidx_t row = 0;\n+\tfor (auto &chunk : result.collection.Chunks()) {\n+\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\tcolumn->__deprecated_nullmask[row++] = FlatVector::IsNull(chunk->data[col], k);\n+\t\t}\n \t}\n-\t// now write the data\n-\tfor (idx_t col = 0; col < out->__deprecated_column_count; col++) {\n-\t\t// first set the nullmask\n+\t// then write the data\n+\tswitch (result.types[col].id()) {\n+\tcase LogicalTypeId::BOOLEAN:\n+\t\tWriteData<bool>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::TINYINT:\n+\t\tWriteData<int8_t>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::SMALLINT:\n+\t\tWriteData<int16_t>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::INTEGER:\n+\t\tWriteData<int32_t>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::BIGINT:\n+\t\tWriteData<int64_t>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::UTINYINT:\n+\t\tWriteData<uint8_t>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::USMALLINT:\n+\t\tWriteData<uint16_t>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::UINTEGER:\n+\t\tWriteData<uint32_t>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::UBIGINT:\n+\t\tWriteData<uint64_t>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::FLOAT:\n+\t\tWriteData<float>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::DOUBLE:\n+\t\tWriteData<double>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::DATE:\n+\t\tWriteData<date_t>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::TIME:\n+\tcase LogicalTypeId::TIME_TZ:\n+\t\tWriteData<dtime_t>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\t\tWriteData<timestamp_t>(column, result.collection, col);\n+\t\tbreak;\n+\tcase LogicalTypeId::VARCHAR: {\n \t\tidx_t row = 0;\n-\t\tfor (auto &chunk : result->collection.Chunks()) {\n+\t\tauto target = (const char **)column->__deprecated_data;\n+\t\tfor (auto &chunk : result.collection.Chunks()) {\n+\t\t\tauto source = FlatVector::GetData<string_t>(chunk->data[col]);\n \t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\tout->__deprecated_columns[col].__deprecated_nullmask[row++] = FlatVector::IsNull(chunk->data[col], k);\n+\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\ttarget[row] = (char *)duckdb_malloc(source[k].GetSize() + 1);\n+\t\t\t\t\tassert(target[row]);\n+\t\t\t\t\tmemcpy((void *)target[row], source[k].GetDataUnsafe(), source[k].GetSize());\n+\t\t\t\t\tauto write_arr = (char *)target[row];\n+\t\t\t\t\twrite_arr[source[k].GetSize()] = '\\0';\n+\t\t\t\t} else {\n+\t\t\t\t\ttarget[row] = nullptr;\n+\t\t\t\t}\n+\t\t\t\trow++;\n \t\t\t}\n \t\t}\n-\t\t// then write the data\n-\t\tswitch (result->types[col].id()) {\n-\t\tcase LogicalTypeId::BOOLEAN:\n-\t\t\tWriteData<bool>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::TINYINT:\n-\t\t\tWriteData<int8_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::SMALLINT:\n-\t\t\tWriteData<int16_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::INTEGER:\n-\t\t\tWriteData<int32_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::BIGINT:\n-\t\t\tWriteData<int64_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::UTINYINT:\n-\t\t\tWriteData<uint8_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::USMALLINT:\n-\t\t\tWriteData<uint16_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::UINTEGER:\n-\t\t\tWriteData<uint32_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::UBIGINT:\n-\t\t\tWriteData<uint64_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::FLOAT:\n-\t\t\tWriteData<float>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::DOUBLE:\n-\t\t\tWriteData<double>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::DATE:\n-\t\t\tWriteData<date_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::TIME:\n-\t\tcase LogicalTypeId::TIME_TZ:\n-\t\t\tWriteData<dtime_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::TIMESTAMP:\n-\t\tcase LogicalTypeId::TIMESTAMP_TZ:\n-\t\t\tWriteData<timestamp_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::VARCHAR: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (const char **)out->__deprecated_columns[col].__deprecated_data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<string_t>(chunk->data[col]);\n-\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\ttarget[row] = (char *)duckdb_malloc(source[k].GetSize() + 1);\n-\t\t\t\t\t\tassert(target[row]);\n-\t\t\t\t\t\tmemcpy((void *)target[row], source[k].GetDataUnsafe(), source[k].GetSize());\n-\t\t\t\t\t\tauto write_arr = (char *)target[row];\n-\t\t\t\t\t\twrite_arr[source[k].GetSize()] = '\\0';\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::BLOB: {\n+\t\tidx_t row = 0;\n+\t\tauto target = (duckdb_blob *)column->__deprecated_data;\n+\t\tfor (auto &chunk : result.collection.Chunks()) {\n+\t\t\tauto source = FlatVector::GetData<string_t>(chunk->data[col]);\n+\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\ttarget[row].data = (char *)duckdb_malloc(source[k].GetSize());\n+\t\t\t\t\ttarget[row].size = source[k].GetSize();\n+\t\t\t\t\tassert(target[row].data);\n+\t\t\t\t\tmemcpy((void *)target[row].data, source[k].GetDataUnsafe(), source[k].GetSize());\n+\t\t\t\t} else {\n+\t\t\t\t\ttarget[row].data = nullptr;\n+\t\t\t\t\ttarget[row].size = 0;\n+\t\t\t\t}\n+\t\t\t\trow++;\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\tcase LogicalTypeId::TIMESTAMP_SEC: {\n+\t\tidx_t row = 0;\n+\t\tauto target = (timestamp_t *)column->__deprecated_data;\n+\t\tfor (auto &chunk : result.collection.Chunks()) {\n+\t\t\tauto source = FlatVector::GetData<timestamp_t>(chunk->data[col]);\n+\n+\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\tif (result.types[col].id() == LogicalTypeId::TIMESTAMP_NS) {\n+\t\t\t\t\t\ttarget[row] = Timestamp::FromEpochNanoSeconds(source[k].value);\n+\t\t\t\t\t} else if (result.types[col].id() == LogicalTypeId::TIMESTAMP_MS) {\n+\t\t\t\t\t\ttarget[row] = Timestamp::FromEpochMs(source[k].value);\n \t\t\t\t\t} else {\n-\t\t\t\t\t\ttarget[row] = nullptr;\n+\t\t\t\t\t\tD_ASSERT(result.types[col].id() == LogicalTypeId::TIMESTAMP_SEC);\n+\t\t\t\t\t\ttarget[row] = Timestamp::FromEpochSeconds(source[k].value);\n \t\t\t\t\t}\n-\t\t\t\t\trow++;\n \t\t\t\t}\n+\t\t\t\trow++;\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::HUGEINT: {\n+\t\tidx_t row = 0;\n+\t\tauto target = (duckdb_hugeint *)column->__deprecated_data;\n+\t\tfor (auto &chunk : result.collection.Chunks()) {\n+\t\t\tauto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);\n+\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\ttarget[row].lower = source[k].lower;\n+\t\t\t\t\ttarget[row].upper = source[k].upper;\n+\t\t\t\t}\n+\t\t\t\trow++;\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::INTERVAL: {\n+\t\tidx_t row = 0;\n+\t\tauto target = (duckdb_interval *)column->__deprecated_data;\n+\t\tfor (auto &chunk : result.collection.Chunks()) {\n+\t\t\tauto source = FlatVector::GetData<interval_t>(chunk->data[col]);\n+\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\ttarget[row].days = source[k].days;\n+\t\t\t\t\ttarget[row].months = source[k].months;\n+\t\t\t\t\ttarget[row].micros = source[k].micros;\n+\t\t\t\t}\n+\t\t\t\trow++;\n \t\t\t}\n-\t\t\tbreak;\n \t\t}\n-\t\tcase LogicalTypeId::BLOB: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (duckdb_blob *)out->__deprecated_columns[col].__deprecated_data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<string_t>(chunk->data[col]);\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::DECIMAL: {\n+\t\t// get data\n+\t\tidx_t row = 0;\n+\t\tauto target = (hugeint_t *)column->__deprecated_data;\n+\t\tswitch (result.types[col].InternalType()) {\n+\t\tcase PhysicalType::INT16: {\n+\t\t\tfor (auto &chunk : result.collection.Chunks()) {\n+\t\t\t\tauto source = FlatVector::GetData<int16_t>(chunk->data[col]);\n \t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n \t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\ttarget[row].data = (char *)duckdb_malloc(source[k].GetSize());\n-\t\t\t\t\t\ttarget[row].size = source[k].GetSize();\n-\t\t\t\t\t\tassert(target[row].data);\n-\t\t\t\t\t\tmemcpy((void *)target[row].data, source[k].GetDataUnsafe(), source[k].GetSize());\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\ttarget[row].data = nullptr;\n-\t\t\t\t\t\ttarget[row].size = 0;\n+\t\t\t\t\t\ttarget[row].lower = source[k];\n+\t\t\t\t\t\ttarget[row].upper = 0;\n \t\t\t\t\t}\n \t\t\t\t\trow++;\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n-\t\tcase LogicalTypeId::TIMESTAMP_NS:\n-\t\tcase LogicalTypeId::TIMESTAMP_MS:\n-\t\tcase LogicalTypeId::TIMESTAMP_SEC: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (timestamp_t *)out->__deprecated_columns[col].__deprecated_data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<timestamp_t>(chunk->data[col]);\n-\n+\t\tcase PhysicalType::INT32: {\n+\t\t\tfor (auto &chunk : result.collection.Chunks()) {\n+\t\t\t\tauto source = FlatVector::GetData<int32_t>(chunk->data[col]);\n \t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n \t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\tif (result->types[col].id() == LogicalTypeId::TIMESTAMP_NS) {\n-\t\t\t\t\t\t\ttarget[row] = Timestamp::FromEpochNanoSeconds(source[k].value);\n-\t\t\t\t\t\t} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_MS) {\n-\t\t\t\t\t\t\ttarget[row] = Timestamp::FromEpochMs(source[k].value);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tD_ASSERT(result->types[col].id() == LogicalTypeId::TIMESTAMP_SEC);\n-\t\t\t\t\t\t\ttarget[row] = Timestamp::FromEpochSeconds(source[k].value);\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\ttarget[row].lower = source[k];\n+\t\t\t\t\t\ttarget[row].upper = 0;\n \t\t\t\t\t}\n \t\t\t\t\trow++;\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n-\t\tcase LogicalTypeId::HUGEINT: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (duckdb_hugeint *)out->__deprecated_columns[col].__deprecated_data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);\n+\t\tcase PhysicalType::INT64: {\n+\t\t\tfor (auto &chunk : result.collection.Chunks()) {\n+\t\t\t\tauto source = FlatVector::GetData<int64_t>(chunk->data[col]);\n \t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n \t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\ttarget[row].lower = source[k].lower;\n-\t\t\t\t\t\ttarget[row].upper = source[k].upper;\n+\t\t\t\t\t\ttarget[row].lower = source[k];\n+\t\t\t\t\t\ttarget[row].upper = 0;\n \t\t\t\t\t}\n \t\t\t\t\trow++;\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n-\t\tcase LogicalTypeId::INTERVAL: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (duckdb_interval *)out->__deprecated_columns[col].__deprecated_data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<interval_t>(chunk->data[col]);\n+\t\tcase PhysicalType::INT128: {\n+\t\t\tfor (auto &chunk : result.collection.Chunks()) {\n+\t\t\t\tauto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);\n \t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n \t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\ttarget[row].days = source[k].days;\n-\t\t\t\t\t\ttarget[row].months = source[k].months;\n-\t\t\t\t\t\ttarget[row].micros = source[k].micros;\n+\t\t\t\t\t\ttarget[row].lower = source[k].lower;\n+\t\t\t\t\t\ttarget[row].upper = source[k].upper;\n \t\t\t\t\t}\n \t\t\t\t\trow++;\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n-\t\tcase LogicalTypeId::DECIMAL: {\n-\t\t\t// get data\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (hugeint_t *)out->__deprecated_columns[col].__deprecated_data;\n-\t\t\tswitch (result->types[col].InternalType()) {\n-\t\t\tcase PhysicalType::INT16: {\n-\t\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\t\tauto source = FlatVector::GetData<int16_t>(chunk->data[col]);\n-\t\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\t\ttarget[row].lower = source[k];\n-\t\t\t\t\t\t\ttarget[row].upper = 0;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\trow++;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tcase PhysicalType::INT32: {\n-\t\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\t\tauto source = FlatVector::GetData<int32_t>(chunk->data[col]);\n-\t\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\t\ttarget[row].lower = source[k];\n-\t\t\t\t\t\t\ttarget[row].upper = 0;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\trow++;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tcase PhysicalType::INT64: {\n-\t\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\t\tauto source = FlatVector::GetData<int64_t>(chunk->data[col]);\n-\t\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\t\ttarget[row].lower = source[k];\n-\t\t\t\t\t\t\ttarget[row].upper = 0;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\trow++;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tcase PhysicalType::INT128: {\n-\t\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\t\tauto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);\n-\t\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\t\ttarget[row].lower = source[k].lower;\n-\t\t\t\t\t\t\ttarget[row].upper = source[k].upper;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\trow++;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tdefault:\n-\t\t\t\tthrow std::runtime_error(\"Unsupported physical type for Decimal\" +\n-\t\t\t\t                         TypeIdToString(result->types[col].InternalType()));\n-\t\t\t}\n-\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow std::runtime_error(\"Unsupported physical type for Decimal\" +\n+\t\t\t                         TypeIdToString(result.types[col].InternalType()));\n \t\t}\n-\t\tdefault: // LCOV_EXCL_START\n-\t\t\tstd::string err_msg = \"Unsupported type for C API: \" + result->types[col].ToString();\n-\t\t\tout->__deprecated_error_message = strdup(err_msg.c_str());\n-\t\t\treturn DuckDBError;\n-\t\t} // LCOV_EXCL_STOP\n+\t\tbreak;\n+\t}\n+\tdefault: // LCOV_EXCL_START\n+\t\treturn DuckDBError;\n+\t} // LCOV_EXCL_STOP\n+\treturn DuckDBSuccess;\n+}\n+\n+duckdb_state duckdb_translate_result(unique_ptr<QueryResult> result_p, duckdb_result *out) {\n+\tauto &result = *result_p;\n+\tD_ASSERT(result_p);\n+\tif (!out) {\n+\t\t// no result to write to, only return the status\n+\t\treturn result.success ? DuckDBSuccess : DuckDBError;\n+\t}\n+\n+\tmemset(out, 0, sizeof(duckdb_result));\n+\n+\t// initialize the result_data object\n+\tauto result_data = new DuckDBResultData();\n+\tresult_data->result = move(result_p);\n+\tresult_data->result_set_type = CAPIResultSetType::CAPI_RESULT_TYPE_NONE;\n+\tout->internal_data = result_data;\n+\n+\tif (!result.success) {\n+\t\t// write the error message\n+\t\tout->__deprecated_error_message = (char *)result.error.c_str();\n+\t\treturn DuckDBError;\n \t}\n+\t// copy the data\n+\t// first write the meta data\n+\tout->__deprecated_column_count = result.ColumnCount();\n+\tout->__deprecated_rows_changed = 0;\n \treturn DuckDBSuccess;\n }\n \n+bool deprecated_materialize_result(duckdb_result *result) {\n+\tif (!result) {\n+\t\treturn false;\n+\t}\n+\tauto result_data = (duckdb::DuckDBResultData *)result->internal_data;\n+\tif (!result_data->result->success) {\n+\t\treturn false;\n+\t}\n+\tif (result_data->result_set_type == CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED) {\n+\t\t// already materialized into deprecated result format\n+\t\treturn true;\n+\t}\n+\tif (result_data->result_set_type == CAPIResultSetType::CAPI_RESULT_TYPE_MATERIALIZED) {\n+\t\t// already used as a new result set\n+\t\treturn false;\n+\t}\n+\t// materialize as deprecated result set\n+\tresult_data->result_set_type = CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED;\n+\tauto column_count = result_data->result->ColumnCount();\n+\tresult->__deprecated_columns = (duckdb_column *)duckdb_malloc(sizeof(duckdb_column) * column_count);\n+\tif (!result->__deprecated_columns) { // LCOV_EXCL_START\n+\t\t// malloc failure\n+\t\treturn DuckDBError;\n+\t} // LCOV_EXCL_STOP\n+\tif (result_data->result->type == QueryResultType::STREAM_RESULT) {\n+\t\t// if we are dealing with a stream result, convert it to a materialized result first\n+\t\tauto &stream_result = (StreamQueryResult &)*result_data->result;\n+\t\tresult_data->result = stream_result.Materialize();\n+\t}\n+\tD_ASSERT(result_data->result->type == QueryResultType::MATERIALIZED_RESULT);\n+\tauto &materialized = (MaterializedQueryResult &)*result_data->result;\n+\n+\t// convert the result to a materialized result\n+\t// zero initialize the columns (so we can cleanly delete it in case a malloc fails)\n+\tmemset(result->__deprecated_columns, 0, sizeof(duckdb_column) * column_count);\n+\tfor (idx_t i = 0; i < column_count; i++) {\n+\t\tresult->__deprecated_columns[i].__deprecated_type = ConvertCPPTypeToC(result_data->result->types[i]);\n+\t\tresult->__deprecated_columns[i].__deprecated_name = (char *)result_data->result->names[i].c_str();\n+\t}\n+\tresult->__deprecated_row_count = materialized.collection.Count();\n+\tif (result->__deprecated_row_count > 0 && StatementTypeReturnChanges(materialized.statement_type)) {\n+\t\t// update total changes\n+\t\tauto row_changes = materialized.GetValue(0, 0);\n+\t\tif (!row_changes.IsNull() && row_changes.TryCastAs(LogicalType::BIGINT)) {\n+\t\t\tresult->__deprecated_rows_changed = row_changes.GetValue<int64_t>();\n+\t\t}\n+\t}\n+\t// now write the data\n+\tfor (idx_t col = 0; col < column_count; col++) {\n+\t\tauto state = deprecated_duckdb_translate_column(materialized, &result->__deprecated_columns[col], col);\n+\t\tif (state != DuckDBSuccess) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\treturn true;\n+}\n+\n } // namespace duckdb\n \n static void DuckdbDestroyColumn(duckdb_column column, idx_t count) {\n@@ -316,60 +357,70 @@ static void DuckdbDestroyColumn(duckdb_column column, idx_t count) {\n \tif (column.__deprecated_nullmask) {\n \t\tduckdb_free(column.__deprecated_nullmask);\n \t}\n-\tif (column.__deprecated_name) {\n-\t\tduckdb_free(column.__deprecated_name);\n-\t}\n-\tif (column.internal_data) {\n-\t\tauto column_data = (duckdb::DuckDBColumnData *)column.internal_data;\n-\t\tdelete column_data;\n-\t}\n }\n \n void duckdb_destroy_result(duckdb_result *result) {\n-\tif (result->__deprecated_error_message) {\n-\t\tduckdb_free(result->__deprecated_error_message);\n-\t}\n \tif (result->__deprecated_columns) {\n \t\tfor (idx_t i = 0; i < result->__deprecated_column_count; i++) {\n \t\t\tDuckdbDestroyColumn(result->__deprecated_columns[i], result->__deprecated_row_count);\n \t\t}\n \t\tduckdb_free(result->__deprecated_columns);\n \t}\n+\tif (result->internal_data) {\n+\t\tauto result_data = (duckdb::DuckDBResultData *)result->internal_data;\n+\t\tdelete result_data;\n+\t}\n \tmemset(result, 0, sizeof(duckdb_result));\n }\n \n const char *duckdb_column_name(duckdb_result *result, idx_t col) {\n-\tif (!result || col >= result->__deprecated_column_count) {\n+\tif (!result || col >= duckdb_column_count(result)) {\n \t\treturn nullptr;\n \t}\n-\treturn result->__deprecated_columns[col].__deprecated_name;\n+\tauto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);\n+\treturn result_data.result->names[col].c_str();\n }\n \n duckdb_type duckdb_column_type(duckdb_result *result, idx_t col) {\n-\tif (!result || col >= result->__deprecated_column_count) {\n+\tif (!result || col >= duckdb_column_count(result)) {\n \t\treturn DUCKDB_TYPE_INVALID;\n \t}\n-\treturn result->__deprecated_columns[col].__deprecated_type;\n+\tauto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);\n+\treturn duckdb::ConvertCPPTypeToC(result_data.result->types[col]);\n+}\n+\n+duckdb_logical_type duckdb_column_logical_type(duckdb_result *result, idx_t col) {\n+\tif (!result || col >= duckdb_column_count(result)) {\n+\t\treturn nullptr;\n+\t}\n+\tauto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);\n+\treturn new duckdb::LogicalType(result_data.result->types[col]);\n }\n \n idx_t duckdb_column_count(duckdb_result *result) {\n \tif (!result) {\n \t\treturn 0;\n \t}\n-\treturn result->__deprecated_column_count;\n+\tauto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);\n+\treturn result_data.result->ColumnCount();\n }\n \n idx_t duckdb_row_count(duckdb_result *result) {\n \tif (!result) {\n \t\treturn 0;\n \t}\n-\treturn result->__deprecated_row_count;\n+\tauto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);\n+\tauto &materialized = (duckdb::MaterializedQueryResult &)*result_data.result;\n+\treturn materialized.collection.Count();\n }\n \n idx_t duckdb_rows_changed(duckdb_result *result) {\n \tif (!result) {\n \t\treturn 0;\n \t}\n+\tif (!duckdb::deprecated_materialize_result(result)) {\n+\t\treturn 0;\n+\t}\n \treturn result->__deprecated_rows_changed;\n }\n \n@@ -377,6 +428,9 @@ void *duckdb_column_data(duckdb_result *result, idx_t col) {\n \tif (!result || col >= result->__deprecated_column_count) {\n \t\treturn nullptr;\n \t}\n+\tif (!duckdb::deprecated_materialize_result(result)) {\n+\t\treturn nullptr;\n+\t}\n \treturn result->__deprecated_columns[col].__deprecated_data;\n }\n \n@@ -384,12 +438,48 @@ bool *duckdb_nullmask_data(duckdb_result *result, idx_t col) {\n \tif (!result || col >= result->__deprecated_column_count) {\n \t\treturn nullptr;\n \t}\n+\tif (!duckdb::deprecated_materialize_result(result)) {\n+\t\treturn nullptr;\n+\t}\n \treturn result->__deprecated_columns[col].__deprecated_nullmask;\n }\n \n-char *duckdb_result_error(duckdb_result *result) {\n+const char *duckdb_result_error(duckdb_result *result) {\n \tif (!result) {\n \t\treturn nullptr;\n \t}\n-\treturn result->__deprecated_error_message;\n+\tauto &result_data = *((duckdb::DuckDBResultData *)result->internal_data);\n+\treturn result_data.result->success ? nullptr : result_data.result->error.c_str();\n+}\n+\n+idx_t duckdb_result_chunk_count(duckdb_result result) {\n+\tif (!result.internal_data) {\n+\t\treturn 0;\n+\t}\n+\tauto &result_data = *((duckdb::DuckDBResultData *)result.internal_data);\n+\tif (result_data.result_set_type == duckdb::CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED) {\n+\t\treturn 0;\n+\t}\n+\tD_ASSERT(result_data.result->type == duckdb::QueryResultType::MATERIALIZED_RESULT);\n+\tauto &materialized = (duckdb::MaterializedQueryResult &)*result_data.result;\n+\treturn materialized.collection.ChunkCount();\n+}\n+\n+duckdb_data_chunk duckdb_result_get_chunk(duckdb_result result, idx_t chunk_idx) {\n+\tif (!result.internal_data) {\n+\t\treturn nullptr;\n+\t}\n+\tauto &result_data = *((duckdb::DuckDBResultData *)result.internal_data);\n+\tif (result_data.result_set_type == duckdb::CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED) {\n+\t\treturn nullptr;\n+\t}\n+\tresult_data.result_set_type = duckdb::CAPIResultSetType::CAPI_RESULT_TYPE_MATERIALIZED;\n+\tauto &materialized = (duckdb::MaterializedQueryResult &)*result_data.result;\n+\tif (chunk_idx >= materialized.collection.ChunkCount()) {\n+\t\treturn nullptr;\n+\t}\n+\tauto chunk = duckdb::make_unique<duckdb::DataChunk>();\n+\tchunk->InitializeEmpty(materialized.collection.Types());\n+\tchunk->Reference(*materialized.collection.Chunks()[chunk_idx]);\n+\treturn chunk.release();\n }\ndiff --git a/src/main/capi/table_function-c.cpp b/src/main/capi/table_function-c.cpp\nnew file mode 100644\nindex 000000000000..14cb6bdc8055\n--- /dev/null\n+++ b/src/main/capi/table_function-c.cpp\n@@ -0,0 +1,351 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+#include \"duckdb/function/table_function.hpp\"\n+#include \"duckdb/parser/parsed_data/create_table_function_info.hpp\"\n+#include \"duckdb/catalog/catalog.hpp\"\n+#include \"duckdb/main/client_context.hpp\"\n+\n+namespace duckdb {\n+\n+struct CTableFunctionInfo : public TableFunctionInfo {\n+\t~CTableFunctionInfo() {\n+\t\tif (extra_info && delete_callback) {\n+\t\t\tdelete_callback(extra_info);\n+\t\t}\n+\t\textra_info = nullptr;\n+\t\tdelete_callback = nullptr;\n+\t}\n+\n+\tduckdb_table_function_bind_t bind = nullptr;\n+\tduckdb_table_function_init_t init = nullptr;\n+\tduckdb_table_function_t function = nullptr;\n+\tvoid *extra_info = nullptr;\n+\tduckdb_delete_callback_t delete_callback = nullptr;\n+};\n+\n+struct CTableBindData : public FunctionData {\n+\t~CTableBindData() {\n+\t\tif (bind_data && delete_callback) {\n+\t\t\tdelete_callback(bind_data);\n+\t\t}\n+\t\tbind_data = nullptr;\n+\t\tdelete_callback = nullptr;\n+\t}\n+\n+\tCTableFunctionInfo *info = nullptr;\n+\tvoid *bind_data = nullptr;\n+\tduckdb_delete_callback_t delete_callback = nullptr;\n+};\n+\n+struct CTableInternalBindInfo {\n+\tCTableInternalBindInfo(ClientContext &context, TableFunctionBindInput &input, vector<LogicalType> &return_types,\n+\t                       vector<string> &names, CTableBindData &bind_data, CTableFunctionInfo &function_info)\n+\t    : context(context), input(input), return_types(return_types), names(names), bind_data(bind_data),\n+\t      function_info(function_info), success(true) {\n+\t}\n+\n+\tClientContext &context;\n+\tTableFunctionBindInput &input;\n+\tvector<LogicalType> &return_types;\n+\tvector<string> &names;\n+\tCTableBindData &bind_data;\n+\tCTableFunctionInfo &function_info;\n+\tbool success;\n+\tstring error;\n+};\n+\n+struct CTableInitData : public FunctionOperatorData {\n+\t~CTableInitData() {\n+\t\tif (init_data && delete_callback) {\n+\t\t\tdelete_callback(init_data);\n+\t\t}\n+\t\tinit_data = nullptr;\n+\t\tdelete_callback = nullptr;\n+\t}\n+\n+\tvoid *init_data = nullptr;\n+\tduckdb_delete_callback_t delete_callback = nullptr;\n+};\n+\n+struct CTableInternalInitInfo {\n+\tCTableInternalInitInfo(CTableBindData &bind_data, CTableInitData &init_data)\n+\t    : bind_data(bind_data), init_data(init_data), success(true) {\n+\t}\n+\n+\tCTableBindData &bind_data;\n+\tCTableInitData &init_data;\n+\tbool success;\n+\tstring error;\n+};\n+\n+struct CTableInternalFunctionInfo {\n+\tCTableInternalFunctionInfo(CTableBindData &bind_data, CTableInitData &init_data)\n+\t    : bind_data(bind_data), init_data(init_data), success(true) {\n+\t}\n+\n+\tCTableBindData &bind_data;\n+\tCTableInitData &init_data;\n+\tbool success;\n+\tstring error;\n+};\n+\n+unique_ptr<FunctionData> CTableFunctionBind(ClientContext &context, TableFunctionBindInput &input,\n+                                            vector<LogicalType> &return_types, vector<string> &names) {\n+\tauto info = (CTableFunctionInfo *)input.info;\n+\tD_ASSERT(info->bind && info->function && info->init);\n+\tauto result = make_unique<CTableBindData>();\n+\tCTableInternalBindInfo bind_info(context, input, return_types, names, *result, *info);\n+\tinfo->bind(&bind_info);\n+\tif (!bind_info.success) {\n+\t\tthrow Exception(bind_info.error);\n+\t}\n+\n+\tresult->info = info;\n+\treturn move(result);\n+}\n+\n+unique_ptr<FunctionOperatorData> CTableFunctionInit(ClientContext &context, const FunctionData *bind_data_p,\n+                                                    const vector<column_t> &column_ids,\n+                                                    TableFilterCollection *filters) {\n+\tauto &bind_data = (CTableBindData &)*bind_data_p;\n+\tauto result = make_unique<CTableInitData>();\n+\n+\tCTableInternalInitInfo init_info(bind_data, *result);\n+\tbind_data.info->init(&init_info);\n+\tif (!init_info.success) {\n+\t\tthrow Exception(init_info.error);\n+\t}\n+\treturn move(result);\n+}\n+\n+void CTableFunction(ClientContext &context, const FunctionData *bind_data_p, FunctionOperatorData *operator_state,\n+                    DataChunk *input, DataChunk &output) {\n+\tauto &bind_data = (CTableBindData &)*bind_data_p;\n+\tauto &init_data = (CTableInitData &)*operator_state;\n+\tCTableInternalFunctionInfo function_info(bind_data, init_data);\n+\tbind_data.info->function(&function_info, &output);\n+\tif (!function_info.success) {\n+\t\tthrow Exception(function_info.error);\n+\t}\n+}\n+\n+} // namespace duckdb\n+\n+//===--------------------------------------------------------------------===//\n+// Table Function\n+//===--------------------------------------------------------------------===//\n+duckdb_table_function duckdb_create_table_function() {\n+\tauto function = new duckdb::TableFunction(\"\", {}, duckdb::CTableFunction, duckdb::CTableFunctionBind,\n+\t                                          duckdb::CTableFunctionInit);\n+\tfunction->function_info = duckdb::make_shared<duckdb::CTableFunctionInfo>();\n+\treturn function;\n+}\n+\n+void duckdb_destroy_table_function(duckdb_table_function *function) {\n+\tif (function && *function) {\n+\t\tauto tf = (duckdb::TableFunction *)*function;\n+\t\tdelete tf;\n+\t\t*function = nullptr;\n+\t}\n+}\n+\n+void duckdb_table_function_set_name(duckdb_table_function function, const char *name) {\n+\tif (!function || !name) {\n+\t\treturn;\n+\t}\n+\tauto tf = (duckdb::TableFunction *)function;\n+\ttf->name = name;\n+}\n+\n+void duckdb_table_function_add_parameter(duckdb_table_function function, duckdb_logical_type type) {\n+\tif (!function || !type) {\n+\t\treturn;\n+\t}\n+\tauto tf = (duckdb::TableFunction *)function;\n+\tauto logical_type = (duckdb::LogicalType *)type;\n+\ttf->arguments.push_back(*logical_type);\n+}\n+\n+void duckdb_table_function_set_extra_info(duckdb_table_function function, void *extra_info,\n+                                          duckdb_delete_callback_t destroy) {\n+\tif (!function) {\n+\t\treturn;\n+\t}\n+\tauto tf = (duckdb::TableFunction *)function;\n+\tauto info = (duckdb::CTableFunctionInfo *)tf->function_info.get();\n+\tinfo->extra_info = extra_info;\n+\tinfo->delete_callback = destroy;\n+}\n+\n+void duckdb_table_function_set_bind(duckdb_table_function function, duckdb_table_function_bind_t bind) {\n+\tif (!function || !bind) {\n+\t\treturn;\n+\t}\n+\tauto tf = (duckdb::TableFunction *)function;\n+\tauto info = (duckdb::CTableFunctionInfo *)tf->function_info.get();\n+\tinfo->bind = bind;\n+}\n+\n+void duckdb_table_function_set_init(duckdb_table_function function, duckdb_table_function_init_t init) {\n+\tif (!function || !init) {\n+\t\treturn;\n+\t}\n+\tauto tf = (duckdb::TableFunction *)function;\n+\tauto info = (duckdb::CTableFunctionInfo *)tf->function_info.get();\n+\tinfo->init = init;\n+}\n+\n+void duckdb_table_function_set_function(duckdb_table_function table_function, duckdb_table_function_t function) {\n+\tif (!table_function || !function) {\n+\t\treturn;\n+\t}\n+\tauto tf = (duckdb::TableFunction *)table_function;\n+\tauto info = (duckdb::CTableFunctionInfo *)tf->function_info.get();\n+\tinfo->function = function;\n+}\n+\n+duckdb_state duckdb_register_table_function(duckdb_connection connection, duckdb_table_function function) {\n+\tif (!connection || !function) {\n+\t\treturn DuckDBError;\n+\t}\n+\tauto con = (duckdb::Connection *)connection;\n+\tauto tf = (duckdb::TableFunction *)function;\n+\tauto info = (duckdb::CTableFunctionInfo *)tf->function_info.get();\n+\tif (tf->name.empty() || !info->bind || !info->init || !info->function) {\n+\t\treturn DuckDBError;\n+\t}\n+\tcon->context->RunFunctionInTransaction([&]() {\n+\t\tauto &catalog = duckdb::Catalog::GetCatalog(*con->context);\n+\t\tduckdb::CreateTableFunctionInfo tf_info(*tf);\n+\n+\t\t// create the function in the catalog\n+\t\tcatalog.CreateTableFunction(*con->context, &tf_info);\n+\t});\n+\treturn DuckDBSuccess;\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// Bind Interface\n+//===--------------------------------------------------------------------===//\n+void *duckdb_bind_get_extra_info(duckdb_bind_info info) {\n+\tif (!info) {\n+\t\treturn nullptr;\n+\t}\n+\tauto bind_info = (duckdb::CTableInternalBindInfo *)info;\n+\treturn bind_info->function_info.extra_info;\n+}\n+\n+void duckdb_bind_add_result_column(duckdb_bind_info info, const char *name, duckdb_logical_type type) {\n+\tif (!info || !name || !type) {\n+\t\treturn;\n+\t}\n+\tauto bind_info = (duckdb::CTableInternalBindInfo *)info;\n+\tbind_info->names.push_back(name);\n+\tbind_info->return_types.push_back(*((duckdb::LogicalType *)type));\n+}\n+\n+idx_t duckdb_bind_get_parameter_count(duckdb_bind_info info) {\n+\tif (!info) {\n+\t\treturn 0;\n+\t}\n+\tauto bind_info = (duckdb::CTableInternalBindInfo *)info;\n+\treturn bind_info->input.inputs.size();\n+}\n+\n+duckdb_value duckdb_bind_get_parameter(duckdb_bind_info info, idx_t index) {\n+\tif (!info || index >= duckdb_bind_get_parameter_count(info)) {\n+\t\treturn nullptr;\n+\t}\n+\tauto bind_info = (duckdb::CTableInternalBindInfo *)info;\n+\treturn new duckdb::Value(bind_info->input.inputs[index]);\n+}\n+\n+void duckdb_bind_set_bind_data(duckdb_bind_info info, void *bind_data, duckdb_delete_callback_t destroy) {\n+\tif (!info) {\n+\t\treturn;\n+\t}\n+\tauto bind_info = (duckdb::CTableInternalBindInfo *)info;\n+\tbind_info->bind_data.bind_data = bind_data;\n+\tbind_info->bind_data.delete_callback = destroy;\n+}\n+\n+void duckdb_bind_set_error(duckdb_bind_info info, const char *error) {\n+\tif (!info || !error) {\n+\t\treturn;\n+\t}\n+\tauto function_info = (duckdb::CTableInternalBindInfo *)info;\n+\tfunction_info->error = error;\n+\tfunction_info->success = false;\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// Init Interface\n+//===--------------------------------------------------------------------===//\n+void *duckdb_init_get_extra_info(duckdb_init_info info) {\n+\tif (!info) {\n+\t\treturn nullptr;\n+\t}\n+\tauto init_info = (duckdb::CTableInternalInitInfo *)info;\n+\treturn init_info->bind_data.info->extra_info;\n+}\n+\n+void *duckdb_init_get_bind_data(duckdb_init_info info) {\n+\tif (!info) {\n+\t\treturn nullptr;\n+\t}\n+\tauto init_info = (duckdb::CTableInternalInitInfo *)info;\n+\treturn init_info->bind_data.bind_data;\n+}\n+\n+void duckdb_init_set_init_data(duckdb_init_info info, void *init_data, duckdb_delete_callback_t destroy) {\n+\tif (!info) {\n+\t\treturn;\n+\t}\n+\tauto init_info = (duckdb::CTableInternalInitInfo *)info;\n+\tinit_info->init_data.init_data = init_data;\n+\tinit_info->init_data.delete_callback = destroy;\n+}\n+\n+void duckdb_init_set_error(duckdb_init_info info, const char *error) {\n+\tif (!info || !error) {\n+\t\treturn;\n+\t}\n+\tauto function_info = (duckdb::CTableInternalInitInfo *)info;\n+\tfunction_info->error = error;\n+\tfunction_info->success = false;\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// Function Interface\n+//===--------------------------------------------------------------------===//\n+void *duckdb_function_get_extra_info(duckdb_function_info info) {\n+\tif (!info) {\n+\t\treturn nullptr;\n+\t}\n+\tauto function_info = (duckdb::CTableInternalFunctionInfo *)info;\n+\treturn function_info->bind_data.info->extra_info;\n+}\n+\n+void *duckdb_function_get_bind_data(duckdb_function_info info) {\n+\tif (!info) {\n+\t\treturn nullptr;\n+\t}\n+\tauto function_info = (duckdb::CTableInternalFunctionInfo *)info;\n+\treturn function_info->bind_data.bind_data;\n+}\n+\n+void *duckdb_function_get_init_data(duckdb_function_info info) {\n+\tif (!info) {\n+\t\treturn nullptr;\n+\t}\n+\tauto function_info = (duckdb::CTableInternalFunctionInfo *)info;\n+\treturn function_info->init_data.init_data;\n+}\n+\n+void duckdb_function_set_error(duckdb_function_info info, const char *error) {\n+\tif (!info || !error) {\n+\t\treturn;\n+\t}\n+\tauto function_info = (duckdb::CTableInternalFunctionInfo *)info;\n+\tfunction_info->error = error;\n+\tfunction_info->success = false;\n+}\ndiff --git a/src/main/capi/value-c.cpp b/src/main/capi/value-c.cpp\nindex 284aaa2b38fa..e394ae56f471 100644\n--- a/src/main/capi/value-c.cpp\n+++ b/src/main/capi/value-c.cpp\n@@ -154,6 +154,9 @@ RESULT_TYPE TryCastCInternal(duckdb_result *result, idx_t col, idx_t row) {\n }\n \n static bool CanFetchValue(duckdb_result *result, idx_t col, idx_t row) {\n+\tif (!duckdb::deprecated_materialize_result(result)) {\n+\t\treturn false;\n+\t}\n \tif (!result || col >= result->__deprecated_column_count || row >= result->__deprecated_row_count) {\n \t\treturn false;\n \t}\n@@ -240,8 +243,8 @@ int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row) {\n duckdb_decimal duckdb_value_decimal(duckdb_result *result, idx_t col, idx_t row) {\n \tduckdb_decimal result_value;\n \n-\tauto column_data = (duckdb::DuckDBColumnData *)result->__deprecated_columns[col].internal_data;\n-\tcolumn_data->type.GetDecimalProperties(result_value.width, result_value.scale);\n+\tauto result_data = (duckdb::DuckDBResultData *)result->internal_data;\n+\tresult_data->result->types[col].GetDecimalProperties(result_value.width, result_value.scale);\n \n \tauto internal_value = GetInternalCValue<hugeint_t>(result, col, row);\n \tresult_value.value.lower = internal_value.lower;\ndiff --git a/src/planner/binder/statement/bind_export.cpp b/src/planner/binder/statement/bind_export.cpp\nindex a4a6cdeb455a..f66f34a2661d 100644\n--- a/src/planner/binder/statement/bind_export.cpp\n+++ b/src/planner/binder/statement/bind_export.cpp\n@@ -122,7 +122,7 @@ BoundStatement Binder::Bind(ExportStatement &stmt) {\n \n \tBoundExportData exported_tables;\n \n-\tidx_t id = 0; // Id for table\n+\tunordered_set<string> table_name_index;\n \tfor (auto &table : tables) {\n \t\tauto info = make_unique<CopyInfo>();\n \t\t// we copy the options supplied to the EXPORT\n@@ -131,16 +131,26 @@ BoundStatement Binder::Bind(ExportStatement &stmt) {\n \t\t// set up the file name for the COPY TO\n \n \t\tauto exported_data = ExportedTableData();\n-\t\tif (table->schema->name == DEFAULT_SCHEMA) {\n-\t\t\tinfo->file_path =\n-\t\t\t    fs.JoinPath(stmt.info->file_path,\n-\t\t\t                StringUtil::Format(\"%s_%s.%s\", to_string(id), SanitizeExportIdentifier(table->name),\n-\t\t\t                                   copy_function->function.extension));\n-\t\t} else {\n-\t\t\tinfo->file_path = fs.JoinPath(\n-\t\t\t    stmt.info->file_path,\n-\t\t\t    StringUtil::Format(\"%s_%s_%s.%s\", SanitizeExportIdentifier(table->schema->name), to_string(id),\n-\t\t\t                       SanitizeExportIdentifier(table->name), copy_function->function.extension));\n+\t\tidx_t id = 0;\n+\t\twhile (true) {\n+\t\t\tstring id_suffix = id == 0 ? string() : \"_\" + to_string(id);\n+\t\t\tif (table->schema->name == DEFAULT_SCHEMA) {\n+\t\t\t\tinfo->file_path = fs.JoinPath(stmt.info->file_path,\n+\t\t\t\t                              StringUtil::Format(\"%s%s.%s\", SanitizeExportIdentifier(table->name),\n+\t\t\t\t                                                 id_suffix, copy_function->function.extension));\n+\t\t\t} else {\n+\t\t\t\tinfo->file_path =\n+\t\t\t\t    fs.JoinPath(stmt.info->file_path,\n+\t\t\t\t                StringUtil::Format(\"%s_%s%s.%s\", SanitizeExportIdentifier(table->schema->name),\n+\t\t\t\t                                   SanitizeExportIdentifier(table->name), id_suffix,\n+\t\t\t\t                                   copy_function->function.extension));\n+\t\t\t}\n+\t\t\tif (table_name_index.find(info->file_path) == table_name_index.end()) {\n+\t\t\t\t// this name was not yet taken: take it\n+\t\t\t\ttable_name_index.insert(info->file_path);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tid++;\n \t\t}\n \t\tinfo->is_from = false;\n \t\tinfo->schema = table->schema->name;\ndiff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex ccebd1b31f9c..6ec382d7ae17 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -69,7 +69,7 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \t\t// table could not be found: try to bind a replacement scan\n \t\tauto &config = DBConfig::GetConfig(context);\n \t\tfor (auto &scan : config.replacement_scans) {\n-\t\t\tauto replacement_function = scan.function(ref.table_name, scan.data);\n+\t\t\tauto replacement_function = scan.function(context, ref.table_name, scan.data.get());\n \t\t\tif (replacement_function) {\n \t\t\t\treplacement_function->alias = ref.alias.empty() ? ref.table_name : ref.alias;\n \t\t\t\treplacement_function->column_name_alias = ref.column_name_alias;\ndiff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp\nindex 5f13518e824e..154b5d9d2f97 100644\n--- a/src/planner/binder/tableref/bind_table_function.cpp\n+++ b/src/planner/binder/tableref/bind_table_function.cpp\n@@ -125,11 +125,19 @@ unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {\n \tvector<LogicalType> return_types;\n \tvector<string> return_names;\n \tif (table_function.bind) {\n-\t\tbind_data = table_function.bind(context, parameters, named_parameters, input_table_types, input_table_names,\n-\t\t                                return_types, return_names);\n+\t\tTableFunctionBindInput bind_input(parameters, named_parameters, input_table_types, input_table_names,\n+\t\t                                  table_function.function_info.get());\n+\t\tbind_data = table_function.bind(context, bind_input, return_types, return_names);\n+\t}\n+\tif (return_types.size() != return_names.size()) {\n+\t\tthrow InternalException(\n+\t\t    \"Failed to bind \\\"%s\\\": Table function return_types and return_names must be of the same size\",\n+\t\t    table_function.name);\n+\t}\n+\tif (return_types.empty()) {\n+\t\tthrow InternalException(\"Failed to bind \\\"%s\\\": Table function must return at least one column\",\n+\t\t                        table_function.name);\n \t}\n-\tD_ASSERT(return_types.size() == return_names.size());\n-\tD_ASSERT(return_types.size() > 0);\n \t// overwrite the names with any supplied aliases\n \tfor (idx_t i = 0; i < ref.column_name_alias.size() && i < return_names.size(); i++) {\n \t\treturn_names[i] = ref.column_name_alias[i];\ndiff --git a/tools/juliapkg/.JuliaFormatter.toml b/tools/juliapkg/.JuliaFormatter.toml\nnew file mode 100644\nindex 000000000000..9c42e1459705\n--- /dev/null\n+++ b/tools/juliapkg/.JuliaFormatter.toml\n@@ -0,0 +1,7 @@\n+margin = 120\n+always_for_in = true\n+whitespace_typedefs = true\n+whitespace_ops_in_indices = true\n+always_use_return = true\n+annotate_untyped_fields_with_any = true\n+trailing_comma = false\ndiff --git a/tools/juliapkg/.gitignore b/tools/juliapkg/.gitignore\nnew file mode 100644\nindex 000000000000..4fc652755ab5\n--- /dev/null\n+++ b/tools/juliapkg/.gitignore\n@@ -0,0 +1,2 @@\n+Manifest.toml\n+\ndiff --git a/tools/juliapkg/Project.toml b/tools/juliapkg/Project.toml\nnew file mode 100644\nindex 000000000000..c4f7931487f8\n--- /dev/null\n+++ b/tools/juliapkg/Project.toml\n@@ -0,0 +1,13 @@\n+name = \"DuckDB\"\n+uuid = \"dc41c802-e0d0-4f5a-8bba-22eb8b17d8a4\"\n+authors = [\"Mark Raasveldt <mark@duckdblabs.com\", \"Hannes M\u00fchleisen <hannes@duckdblabs.com>\"]\n+version = \"0.3.2\"\n+\n+[deps]\n+DBInterface = \"a10d1c49-ce27-4219-8d33-6db1a4562965\"\n+DataFrames = \"a93c6f00-e57d-5684-b7b6-d8193f3e46c0\"\n+Dates = \"ade2ca70-3891-5945-98fb-dc099432e06a\"\n+DuckDB_jll = \"2cbbab25-fc8b-58cf-88d4-687a02676033\"\n+Tables = \"bd369af6-aec1-5ad0-b16a-f7cc5008161c\"\n+UUIDs = \"cf7118a7-6976-5b1a-9a39-7adc72f591a4\"\n+WeakRefStrings = \"ea10d353-3f73-51f8-a26c-33c1cb351aa5\"\ndiff --git a/tools/juliapkg/README.md b/tools/juliapkg/README.md\nnew file mode 100644\nindex 000000000000..9fff0df317f1\n--- /dev/null\n+++ b/tools/juliapkg/README.md\n@@ -0,0 +1,27 @@\n+\n+#### Installing the Package\n+\n+\n+#### Formatting\n+The format script must be run when changing anything. This can be done by running the following command from within the root directory of the project:\n+\n+```bash\n+julia tools/juliapkg/scripts/format.jl\n+```\n+\n+#### Testing\n+\n+You can run the tests using the `test.sh` script:\n+\n+```\n+./test.sh\n+```\n+\n+Specific test files can be run by adding the name of the file as an argument:\n+\n+```\n+./test.sh test_connection.jl\n+```\n+\n+#### Original Julia Connector\n+Credits to kimmolinna for the [original DuckDB Julia connector](https://github.com/kimmolinna/DuckDB.jl).\n\\ No newline at end of file\ndiff --git a/tools/juliapkg/data/album.parquet b/tools/juliapkg/data/album.parquet\nnew file mode 100644\nindex 000000000000..b9c660f0cde5\nBinary files /dev/null and b/tools/juliapkg/data/album.parquet differ\ndiff --git a/tools/juliapkg/data/artist.parquet b/tools/juliapkg/data/artist.parquet\nnew file mode 100644\nindex 000000000000..be7a49e4ac82\nBinary files /dev/null and b/tools/juliapkg/data/artist.parquet differ\ndiff --git a/tools/juliapkg/data/customer.parquet b/tools/juliapkg/data/customer.parquet\nnew file mode 100644\nindex 000000000000..650ba7aff058\nBinary files /dev/null and b/tools/juliapkg/data/customer.parquet differ\ndiff --git a/tools/juliapkg/data/employee.parquet b/tools/juliapkg/data/employee.parquet\nnew file mode 100644\nindex 000000000000..5a5f1feb1026\nBinary files /dev/null and b/tools/juliapkg/data/employee.parquet differ\ndiff --git a/tools/juliapkg/data/genre.parquet b/tools/juliapkg/data/genre.parquet\nnew file mode 100644\nindex 000000000000..6950dae0eaeb\nBinary files /dev/null and b/tools/juliapkg/data/genre.parquet differ\ndiff --git a/tools/juliapkg/data/invoice.parquet b/tools/juliapkg/data/invoice.parquet\nnew file mode 100644\nindex 000000000000..d6716e342b8f\nBinary files /dev/null and b/tools/juliapkg/data/invoice.parquet differ\ndiff --git a/tools/juliapkg/data/invoiceline.parquet b/tools/juliapkg/data/invoiceline.parquet\nnew file mode 100644\nindex 000000000000..d5b66dd07aac\nBinary files /dev/null and b/tools/juliapkg/data/invoiceline.parquet differ\ndiff --git a/tools/juliapkg/data/mediatype.parquet b/tools/juliapkg/data/mediatype.parquet\nnew file mode 100644\nindex 000000000000..44afb1bcfeb5\nBinary files /dev/null and b/tools/juliapkg/data/mediatype.parquet differ\ndiff --git a/tools/juliapkg/data/playlist.parquet b/tools/juliapkg/data/playlist.parquet\nnew file mode 100644\nindex 000000000000..5229249bae81\nBinary files /dev/null and b/tools/juliapkg/data/playlist.parquet differ\ndiff --git a/tools/juliapkg/data/playlisttrack.parquet b/tools/juliapkg/data/playlisttrack.parquet\nnew file mode 100644\nindex 000000000000..b95ad32e2833\nBinary files /dev/null and b/tools/juliapkg/data/playlisttrack.parquet differ\ndiff --git a/tools/juliapkg/data/track.parquet b/tools/juliapkg/data/track.parquet\nnew file mode 100644\nindex 000000000000..f74f33d26bce\nBinary files /dev/null and b/tools/juliapkg/data/track.parquet differ\ndiff --git a/tools/juliapkg/format.sh b/tools/juliapkg/format.sh\nnew file mode 100755\nindex 000000000000..c2db4d5c1dc7\n--- /dev/null\n+++ b/tools/juliapkg/format.sh\n@@ -0,0 +1,4 @@\n+set -e\n+\n+cd ../..\n+julia tools/juliapkg/scripts/format.jl\n\\ No newline at end of file\ndiff --git a/tools/juliapkg/format_check.sh b/tools/juliapkg/format_check.sh\nnew file mode 100755\nindex 000000000000..f02dccd7d9eb\n--- /dev/null\n+++ b/tools/juliapkg/format_check.sh\n@@ -0,0 +1,16 @@\n+set -e\n+\n+if [[ $(git diff) ]]; then\n+  echo \"There are already differences prior to the format! Commit your changes prior to running format_check.sh\"\n+  exit 1\n+fi\n+\n+./format.sh\n+if [[ $(git diff) ]]; then\n+    echo \"Julia format found differences:\"\n+    git diff\n+    exit 1\n+else\n+    echo \"No differences found\"\n+    exit 0\n+fi\ndiff --git a/tools/juliapkg/scripts/format.jl b/tools/juliapkg/scripts/format.jl\nnew file mode 100644\nindex 000000000000..ed0460d3ce75\n--- /dev/null\n+++ b/tools/juliapkg/scripts/format.jl\n@@ -0,0 +1,4 @@\n+using JuliaFormatter\n+\n+format(\"tools/juliapkg/src\")\n+format(\"tools/juliapkg/test\")\n\\ No newline at end of file\ndiff --git a/tools/juliapkg/src/DuckDB.jl b/tools/juliapkg/src/DuckDB.jl\nnew file mode 100644\nindex 000000000000..15354e589ae1\n--- /dev/null\n+++ b/tools/juliapkg/src/DuckDB.jl\n@@ -0,0 +1,35 @@\n+module DuckDB\n+\n+using DBInterface\n+using WeakRefStrings\n+using Tables\n+using Base.Libc\n+using Dates\n+using DataFrames\n+using Tables\n+using UUIDs\n+\n+export DBInterface, DuckDBException\n+\n+include(\"helper.jl\")\n+include(\"exceptions.jl\")\n+include(\"ctypes.jl\")\n+include(\"api.jl\")\n+include(\"logical_type.jl\")\n+include(\"value.jl\")\n+include(\"validity_mask.jl\")\n+include(\"vector.jl\")\n+include(\"data_chunk.jl\")\n+include(\"config.jl\")\n+include(\"database.jl\")\n+include(\"statement.jl\")\n+include(\"result.jl\")\n+include(\"transaction.jl\")\n+include(\"ddl.jl\")\n+include(\"appender.jl\")\n+include(\"table_function.jl\")\n+include(\"replacement_scan.jl\")\n+include(\"data_frame_scan.jl\")\n+include(\"old_interface.jl\")\n+\n+end # module\ndiff --git a/tools/juliapkg/src/api.jl b/tools/juliapkg/src/api.jl\nnew file mode 100644\nindex 000000000000..59bed1ecf287\n--- /dev/null\n+++ b/tools/juliapkg/src/api.jl\n@@ -0,0 +1,2445 @@\n+using Base.Libc\n+\n+if \"JULIA_DUCKDB_LIBRARY\" in keys(ENV)\n+    libduckdb = ENV[\"JULIA_DUCKDB_LIBRARY\"]\n+else\n+    using DuckDB_jll\n+end\n+\n+#=//===--------------------------------------------------------------------===//\n+// Open/Connect\n+//===--------------------------------------------------------------------===//\n+=#\n+\"\"\"\n+\tduckdb_open(path, out_database)\n+Creates a new database or opens an existing database file stored at the the given path.\n+If no path is given a new in-memory database is created instead.\n+* `path`: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.\n+* `out_database`: The result database object.\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+\"\"\"\n+function duckdb_open(path, out_database)\n+    return ccall((:duckdb_open, libduckdb), duckdb_state, (Ptr{UInt8}, Ref{duckdb_database}), path, out_database)\n+end\n+\"\"\"\n+\tExtended version of duckdb_open. Creates a new database or opens an existing database file stored at the the given path.\n+\n+    * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.\n+    * out_database: The result database object.\n+    * config: (Optional) configuration used to start up the database system.\n+    * out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.\n+    Note that the error must be freed using `duckdb_free`.\n+    * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+\"\"\"\n+function duckdb_open_ext(path, out_database, config, out_error)\n+    return ccall(\n+        (:duckdb_open_ext, libduckdb),\n+        duckdb_state,\n+        (Ptr{UInt8}, Ref{duckdb_database}, duckdb_config, Ptr{Ptr{UInt8}}),\n+        path,\n+        out_database,\n+        config,\n+        out_error\n+    )\n+end\n+\"\"\"\n+\tduckdb_close(database)\n+Closes the specified database and de-allocates all memory allocated for that database.\n+This should be called after you are done with any database allocated through `duckdb_open`.\n+Note that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.\n+Still it is recommended to always correctly close a database object after you are done with it.\n+* `database`: The database object to shut down.\n+\"\"\"\n+function duckdb_close(database)\n+    return ccall((:duckdb_close, libduckdb), Cvoid, (Ref{duckdb_database},), database)\n+end\n+\"\"\"\n+\tduckdb_connect(database, out_connection)\n+Opens a connection to a database. Connections are required to query the database, and store transactional state\n+associated with the connection.\n+* `database`: The database file to connect to.\n+* `out_connection`: The result connection object.\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+\"\"\"\n+function duckdb_connect(database, out_connection)\n+    return ccall(\n+        (:duckdb_connect, libduckdb),\n+        duckdb_state,\n+        (duckdb_database, Ref{duckdb_connection}),\n+        database,\n+        out_connection\n+    )\n+end\n+\n+\"\"\"\n+\tduckdb_disconnect(connection)\n+Closes the specified connection and de-allocates all memory allocated for that connection.\n+* `connection`: The connection to close.\n+\"\"\"\n+function duckdb_disconnect(connection)\n+    return ccall((:duckdb_disconnect, libduckdb), Cvoid, (Ref{duckdb_connection},), connection)\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Configuration\n+//===--------------------------------------------------------------------===//\n+=#\n+\n+\"\"\"\n+\tduckdb_create_config(config)\n+Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance\n+through `duckdb_open_ext`.\n+This will always succeed unless there is a malloc failure.\n+* `out_config`: The result configuration object.\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+\"\"\"\n+function duckdb_create_config(config)\n+    return ccall((:duckdb_create_config, libduckdb), duckdb_state, (Ref{duckdb_config},), config)\n+end\n+\n+\"\"\"\n+\tduckdb_config_count()\n+This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.\n+This should not be called in a loop as it internally loops over all the options.\n+* returns: The amount of config options available.\n+\"\"\"\n+function duckdb_config_count()\n+    return ccall((:duckdb_config_count, libduckdb), Int32, ())\n+end\n+\n+\"\"\"\n+\tduckdb_get_config_flag(index,out_name,out_description)\n+Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.\n+display configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).\n+The result name or description MUST NOT be freed.\n+* `index`: The index of the configuration option (between 0 and `duckdb_config_count`)\n+* `out_name`: A name of the configuration flag.\n+* `out_description`: A description of the configuration flag.\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+\"\"\"\n+function duckdb_get_config_flag(index, out_name, out_description)\n+    return ccall(\n+        (:duckdb_get_config_flag, libduckdb),\n+        duckdb_state,\n+        (Int32, Ptr{Ptr{UInt8}}, Ptr{Ptr{UInt8}}),\n+        index,\n+        out_name,\n+        out_description\n+    )\n+end\n+\n+\"\"\"\n+\tduckdb_set_config(config,name,option)\n+Sets the specified option for the specified configuration. The configuration option is indicated by name.\n+To obtain a list of config options, see `duckdb_get_config_flag`.\n+In the source code, configuration options are defined in `config.cpp`.\n+This can fail if either the name is invalid, or if the value provided for the option is invalid.\n+* `duckdb_config`: The configuration object to set the option on.\n+* `name`: The name of the configuration flag to set.\n+* `option`: The value to set the configuration flag to.\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+\"\"\"\n+function duckdb_set_config(config, name, option)\n+    return ccall(\n+        (:duckdb_set_config, libduckdb),\n+        duckdb_state,\n+        (duckdb_config, Ptr{UInt8}, Ptr{UInt8}),\n+        config,\n+        name,\n+        option\n+    )\n+end\n+\n+\"\"\"\n+\tduckdb_destroy_config(config)\n+Destroys the specified configuration option and de-allocates all memory allocated for the object.\n+* `config`: The configuration object to destroy.\n+\"\"\"\n+function duckdb_destroy_config(config)\n+    return ccall((:duckdb_destroy_config, libduckdb), Cvoid, (Ref{duckdb_config},), config)\n+end\n+\n+# #=\n+# //===--------------------------------------------------------------------===//\n+# // Query Execution\n+# //===--------------------------------------------------------------------===//\n+# =#\n+#\n+# \"\"\"\n+# \tduckdb_query(connection,query,out_result)\n+# Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.\n+# If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling\n+# `duckdb_result_error`.\n+# Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the\n+# query fails, otherwise the error stored within the result will not be freed correctly.\n+# * `connection`: The connection to perform the query in.\n+# * `query`: The SQL query to run.\n+# * `out_result`: The query result.\n+# * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+# \"\"\"\n+# function duckdb_query(connection, query, out_result)\n+#     return ccall(\n+#         (:duckdb_query, libduckdb),\n+#         Int32,\n+#         (Ptr{Cvoid}, Ptr{UInt8}, Ptr{Cvoid}),\n+#         connection[],\n+#         query,\n+#         out_result,\n+#     )\n+# end\n+#\n+\"\"\"\n+\tduckdb_destroy_result(result)\n+Closes the result and de-allocates all memory allocated for that connection.\n+* `result`: The result to destroy.\n+\"\"\"\n+function duckdb_destroy_result(result)\n+    return ccall((:duckdb_destroy_result, libduckdb), Cvoid, (Ref{duckdb_result},), result)\n+end\n+\n+\"\"\"\n+\tduckdb_column_name(result,col)\n+Returns the column name of the specified column. The result should not need be freed; the column names will\n+automatically be destroyed when the result is destroyed.\n+Returns `NULL` if the column is out of range.\n+* `result`: The result object to fetch the column name from.\n+* `col`: The column index.\n+* returns: The column name of the specified column.\n+\"\"\"\n+function duckdb_column_name(result, col)\n+    return ccall((:duckdb_column_name, libduckdb), Ptr{UInt8}, (Ref{duckdb_result}, Int32), result, col - 1)\n+end\n+\n+\"\"\"\n+\tduckdb_column_type(result,col)\n+Returns the column type of the specified column.\n+Returns `DUCKDB_TYPE_INVALID` if the column is out of range.\n+* `result`: The result object to fetch the column type from.\n+* `col`: The column index.\n+* returns: The column type of the specified column.\n+\"\"\"\n+function duckdb_column_type(result, col)\n+    return ccall((:duckdb_column_type, libduckdb), DUCKDB_TYPE, (Ref{duckdb_result}, Int32), result, col - 1)\n+end\n+\n+\"\"\"\n+Returns the logical column type of the specified column.\n+\n+The return type of this call should be destroyed with `duckdb_destroy_logical_type`.\n+\n+Returns `NULL` if the column is out of range.\n+\n+* result: The result object to fetch the column type from.\n+* col: The column index.\n+* returns: The logical column type of the specified column.\n+\"\"\"\n+function duckdb_column_logical_type(result, col)\n+    return ccall(\n+        (:duckdb_column_logical_type, libduckdb),\n+        duckdb_logical_type,\n+        (Ref{duckdb_result}, Int32),\n+        result,\n+        col - 1\n+    )\n+end\n+\n+\"\"\"\n+\tduckdb_column_count(result)\n+Returns the number of columns present in a the result object.\n+* `result`: The result object.\n+* returns: The number of columns present in the result object.\n+\"\"\"\n+function duckdb_column_count(result)\n+    return ccall((:duckdb_column_count, libduckdb), Int32, (Ref{duckdb_result},), result)\n+end\n+\n+\"\"\"\n+\tduckdb_row_count(result)\n+Returns the number of rows present in a the result object.\n+* `result`: The result object.\n+* returns: The number of rows present in the result object.\n+\"\"\"\n+function duckdb_row_count(result)\n+    return ccall((:duckdb_row_count, libduckdb), Int64, (Ref{duckdb_result},), result)\n+end\n+\n+\"\"\"\n+\tduckdb_rows_changed(result)\n+Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE\n+queries. For other queries the rows_changed will be 0.\n+* `result`: The result object.\n+* returns: The number of rows changed.\n+\"\"\"\n+function duckdb_rows_changed(result)\n+    return ccall((:duckdb_rows_changed, libduckdb), Int64, (Ptr{Cvoid},), result)\n+end\n+\n+\"\"\"\n+\tduckdb_column_data(result,col)\n+Returns the data of a specific column of a result in columnar format. This is the fastest way of accessing data in a\n+query result, as no conversion or type checking must be performed (outside of the original switch). If performance\n+is a concern, it is recommended to use this API over the `duckdb_value` functions.\n+The function returns a dense array which contains the result data. The exact type stored in the array depends on the\n+corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be\n+accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.\n+For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:\n+```c\n+int32_t *data = (int32_t *) duckdb_column_data(&result, 0);\n+printf(\"Data for row %d: %d\\\\n\", row, data[row]);\n+```\n+* `result`: The result object to fetch the column data from.\n+* `col`: The column index.\n+* returns: The column data of the specified column.\n+\"\"\"\n+function duckdb_column_data(result, col)\n+    return ccall((:duckdb_column_data, libduckdb), Ptr{Cvoid}, (Ref{duckdb_result}, Int32), result, col - 1)\n+end\n+\n+\"\"\"\n+\tduckdb_nullmask_data(result,col)\n+Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row\n+whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided\n+by `duckdb_column_data` are undefined.\n+```c\n+int32_t *data = (int32_t *) duckdb_column_data(&result, 0);\n+bool *nullmask = duckdb_nullmask_data(&result, 0);\n+if (nullmask[row]) {\n+    printf(\"Data for row %d: NULL\\n\", row);\n+} else {\n+    printf(\"Data for row %d: %d\\n\", row, data[row]);\n+}\n+```\n+* `result`: The result object to fetch the nullmask from.\n+* `col`: The column index.\n+* returns: The nullmask of the specified column.\n+\"\"\"\n+function duckdb_nullmask_data(result, col)\n+    return ccall((:duckdb_nullmask_data, libduckdb), Ptr{Int32}, (Ref{duckdb_result}, Int32), result, col - 1)\n+end\n+\n+\"\"\"\n+\tduckdb_result_error(result)\n+Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.\n+The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.\n+* `result`: The result object to fetch the nullmask from.\n+* returns: The error of the result.\n+\"\"\"\n+function duckdb_result_error(result)\n+    return ccall((:duckdb_result_error, libduckdb), Ptr{UInt8}, (Ref{duckdb_result},), result)\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Result Functions\n+//===--------------------------------------------------------------------===//\n+=#\n+\n+\"\"\"\n+Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.\n+\n+This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data` functions.\n+It results in significantly better performance, and should be preferred in newer code-bases.\n+\n+If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be mixed with the legacy result functions).\n+\n+Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.\n+\n+* result: The result object to fetch the data chunk from.\n+* chunk_index: The chunk index to fetch from.\n+* returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.\n+\"\"\"\n+function duckdb_result_get_chunk(result, chunk_index)\n+    return ccall(\n+        (:duckdb_result_get_chunk, libduckdb),\n+        duckdb_data_chunk,\n+        (duckdb_result, UInt64),\n+        result,\n+        chunk_index - 1\n+    )\n+end\n+\n+\"\"\"\n+Returns the number of data chunks present in the result.\n+\n+* result: The result object\n+* returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.\n+\"\"\"\n+function duckdb_result_chunk_count(result)\n+    return ccall((:duckdb_result_chunk_count, libduckdb), UInt64, (duckdb_result,), result)\n+end\n+\n+\n+\"\"\"\n+\tduckdb_value_boolean(result,col,row)\n+* returns: The boolean value at the specified location, or false if the value cannot be converted.\n+\"\"\"\n+function duckdb_value_boolean(result, col, row)\n+    return ccall(\n+        (:duckdb_value_boolean, libduckdb),\n+        Int32,\n+        (Ref{duckdb_result}, Int32, Int32),\n+        result,\n+        col - 1,\n+        row - 1\n+    )\n+end\n+\n+\"\"\"\n+\tduckdb_value_int8(result,col,row)\n+* returns: The int8_t value at the specified location, or 0 if the value cannot be converted.\n+\"\"\"\n+function duckdb_value_int8(result, col, row)\n+    return ccall((:duckdb_value_int8, libduckdb), Int8, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)\n+end\n+\n+\"\"\"\n+\tduckdb_value_int16(result,col,row)\n+ * returns: The int16_t value at the specified location, or 0 if the value cannot be converted.\n+\"\"\"\n+function duckdb_value_int16(result, col, row)\n+    return ccall((:duckdb_value_int16, libduckdb), Int16, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)\n+end\n+\n+\"\"\"\n+\tduckdb_value_int32(result,col,row)\n+ * returns: The int32_t value at the specified location, or 0 if the value cannot be converted.\n+\"\"\"\n+function duckdb_value_int32(result, col, row)\n+    return ccall((:duckdb_value_int32, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)\n+end\n+\n+\"\"\"\n+\tduckdb_value_int64(result,col,row)\n+ * returns: The int64_t value at the specified location, or 0 if the value cannot be converted.\n+\"\"\"\n+function duckdb_value_int64(result, col, row)\n+    return ccall((:duckdb_value_int64, libduckdb), Int64, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)\n+end\n+\n+\"\"\"\n+\tduckdb_value_hugeint(result,col,row)\n+ * returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.\n+\"\"\"\n+function duckdb_value_hugeint(result, col, row)\n+    return ccall(\n+        (:duckdb_value_hugeint, libduckdb),\n+        Int64,\n+        (Ref{duckdb_result}, Int32, Int32),\n+        result,\n+        col - 1,\n+        row - 1\n+    )\n+end\n+\n+\"\"\"\n+\tduckdb_value_uint8(result,col,row)\n+ * returns: The uint8_t value at the specified location, or 0 if the value cannot be converted.\n+\n+\"\"\"\n+function duckdb_value_uint8(result, col, row)\n+    return ccall((:duckdb_value_uint8, libduckdb), UInt8, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)\n+end\n+\n+\"\"\"\n+\tduckdb_value_uint16(result,col,row)\n+ * returns: The uint16_t value at the specified location, or 0 if the value cannot be converted.\n+\"\"\"\n+function duckdb_value_uint16(result, col, row)\n+    return ccall(\n+        (:duckdb_value_uint16, libduckdb),\n+        UInt16,\n+        (Ref{duckdb_result}, Int32, Int32),\n+        result,\n+        col - 1,\n+        row - 1\n+    )\n+end\n+\n+\"\"\"\n+\tduckdb_value_uint32(result,col,row)\n+ * returns: The uint32_t value at the specified location, or 0 if the value cannot be converted.\n+\"\"\"\n+function duckdb_value_uint32(result, col, row)\n+    return ccall(\n+        (:duckdb_value_uint32, libduckdb),\n+        UInt32,\n+        (Ref{duckdb_result}, Int32, Int32),\n+        result,\n+        col - 1,\n+        row - 1\n+    )\n+end\n+\n+\"\"\"\n+\tduckdb_value_uint64(result,col,row)\n+* returns: The uint64_t value at the specified location, or 0 if the value cannot be converted.\n+\"\"\"\n+function duckdb_value_uint64(result, col, row)\n+    return ccall(\n+        (:duckdb_value_uint64, libduckdb),\n+        UInt64,\n+        (Ref{duckdb_result}, Int32, Int32),\n+        result,\n+        col - 1,\n+        row - 1\n+    )\n+end\n+\n+\"\"\"\n+\tduckdb_value_float(result,col,row)\n+ * returns: The float value at the specified location, or 0 if the value cannot be converted.\n+\"\"\"\n+function duckdb_value_float(result, col, row)\n+    return ccall(\n+        (:duckdb_value_float, libduckdb),\n+        Float32,\n+        (Ref{duckdb_result}, Int32, Int32),\n+        result,\n+        col - 1,\n+        row - 1\n+    )\n+end\n+\n+\"\"\"\n+\tduckdb_value_double(result,col,row)\n+ * returns: The double value at the specified location, or 0 if the value cannot be converted.\n+\"\"\"\n+function duckdb_value_double(result, col, row)\n+    return ccall(\n+        (:duckdb_value_double, libduckdb),\n+        Float64,\n+        (Ref{duckdb_result}, Int32, Int32),\n+        result,\n+        col - 1,\n+        row - 1\n+    )\n+end\n+\n+\"\"\"\n+duckdb_value_date(result,col,row)\n+ * returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted.\n+DUCKDB_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);\n+\"\"\"\n+function duckdb_value_date(result, col, row)\n+    return ccall((:duckdb_value_date, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)\n+end\n+\n+\"\"\"\n+duckdb_value_time(result,col,row)\n+ * returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted.\n+DUCKDB_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);\n+\"\"\"\n+function duckdb_value_time(result, col, row)\n+    return ccall((:duckdb_value_time, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)\n+end\n+\n+\"\"\"\n+duckdb_value_timestamp(result,col,row)\n+ * returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.\n+DUCKDB_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);\n+\"\"\"\n+function duckdb_value_timestamp(result, col, row)\n+    return ccall(\n+        (:duckdb_value_timestamp, libduckdb),\n+        Int32,\n+        (Ref{duckdb_result}, Int32, Int32),\n+        result,\n+        col - 1,\n+        row - 1\n+    )\n+end\n+\n+\"\"\"\n+duckdb_value_interval(result,col,row)\n+ * returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted.\n+DUCKDB_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);\n+\"\"\"\n+function duckdb_value_interval(result, col, row)\n+    return ccall(\n+        (:duckdb_value_interval, libduckdb),\n+        Int32,\n+        (Ref{duckdb_result}, Int32, Int32),\n+        result,\n+        col - 1,\n+        row - 1\n+    )\n+end\n+\n+\"\"\"\n+duckdb_value_varchar(result,col,row)\n+* returns: The char* value at the specified location, or nullptr if the value cannot be converted.\n+The result must be freed with `duckdb_free`.\n+DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);\n+\"\"\"\n+function duckdb_value_varchar(result, col, row)\n+    return ccall(\n+        (:duckdb_value_varchar, libduckdb),\n+        Ptr{UInt8},\n+        (Ref{duckdb_result}, Int32, Int32),\n+        result,\n+        col - 1,\n+        row - 1\n+    )\n+end\n+\n+\"\"\"\n+duckdb_value_varchar_internal(result,col,row)\n+* returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.\n+If the column is NOT a VARCHAR column this function will return NULL.\n+The result must NOT be freed.\n+DUCKDB_API char *duckdb_value_varchar_internal(duckdb_result *result, idx_t col, idx_t row);\n+\"\"\"\n+function duckdb_value_varchar_internal(result, col, row)\n+    return ccall(\n+        (:duckdb_value_varchar_internal, libduckdb),\n+        Ptr{UInt8},\n+        (Ref{duckdb_result}, Int32, Int32),\n+        result,\n+        col - 1,\n+        row - 1\n+    )\n+end\n+\n+# \"\"\"\n+# duckdb_value_blob(result,col,row)\n+# * returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the\n+# value cannot be converted. The resulting \"blob.data\" must be freed with `duckdb_free.`\n+# DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);\n+# \"\"\"\n+# function duckdb_value_blob(result, col, row)\n+#     return ccall(\n+#         (:duckdb_value_blob, libduckdb),\n+#         Ptr{Cvoid},\n+#         (Ptr{Cvoid}, Int32, Int32),\n+#         result,\n+#         col - 1,\n+#         row - 1,\n+#     )\n+# end\n+\n+\"\"\"\n+duckdb_value_is_null(result,col,row)\n+ * returns: Returns true if the value at the specified index is NULL, and false otherwise.\n+DUCKDB_API bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row);\n+\"\"\"\n+function duckdb_value_is_null(result, col, row)\n+    return ccall((:duckdb_value_is_null, libduckdb), Bool, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Helpers\n+//===--------------------------------------------------------------------===//\n+=#\n+\n+\n+\"\"\"\n+duckdb_malloc(size)\n+\n+Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner\n+should be freed using `duckdb_free`.\n+* size: The number of bytes to allocate.\n+* returns: A pointer to the allocated memory region.\n+DUCKDB_API void *duckdb_malloc(size_t size);\n+\"\"\"\n+function duckdb_malloc(size)\n+    return ccall((:duckdb_malloc, libduckdb), Cvoid, (Csize_t,), size)\n+end\n+\n+\"\"\"\n+duckdb_free(ptr)\n+Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_value_blob`.\n+* ptr: The memory region to de-allocate.\n+DUCKDB_API void duckdb_free(void *ptr);\n+\"\"\"\n+function duckdb_free(ptr)\n+    return ccall((:duckdb_malloc, libduckdb), Cvoid, (Ptr{Cvoid},), ptr)\n+end\n+\n+\"\"\"\n+The internal vector size used by DuckDB.\n+This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.\n+\n+* returns: The vector size.\n+\"\"\"\n+function duckdb_vector_size()\n+    return ccall((:duckdb_vector_size, libduckdb), UInt64, ())\n+end\n+\n+# #=\n+# //===--------------------------------------------------------------------===//\n+# // Date/Time/Timestamp Helpers\n+# //===--------------------------------------------------------------------===//\n+# =#\n+#\n+#\n+# \"\"\"\n+# duckdb_from_date(date)\n+# Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).\n+# * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.\n+# * returns: The `duckdb_date_struct` with the decomposed elements.\n+# DUCKDB_API duckdb_date_struct duckdb_from_date(duckdb_date date);\n+# \"\"\"\n+# function duckdb_from_date(date)\n+#     return ccall((:duckdb_from_date, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), date)\n+# end\n+#\n+# \"\"\"\n+# duckdb_to_date(date)\n+# Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).\n+# * date: The year, month and date stored in a `duckdb_date_struct`.\n+# * returns: The `duckdb_date` element.\n+# DUCKDB_API duckdb_date duckdb_to_date(duckdb_date_struct date);\n+# \"\"\"\n+# function duckdb_to_date(date)\n+#     return ccall((:duckdb_to_date, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), date)\n+# end\n+#\n+# \"\"\"\n+# duckdb_from_time(time)\n+# Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).\n+# * time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.\n+# * returns: The `duckdb_time_struct` with the decomposed elements.\n+# DUCKDB_API duckdb_time_struct duckdb_from_time(duckdb_time time);\n+# \"\"\"\n+# function duckdb_from_time(time)\n+#     return ccall((:duckdb_from_time, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), time)\n+# end\n+#\n+# \"\"\"\n+# duckdb_to_time(time)\n+# Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).\n+# * time: The hour, minute, second and microsecond in a `duckdb_time_struct`.\n+# * returns: The `duckdb_time` element.\n+# DUCKDB_API duckdb_time duckdb_to_time(duckdb_time_struct time);\n+# \"\"\"\n+# function duckdb_to_time(time)\n+#     return ccall((:duckdb_to_time, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), time)\n+# end\n+#\n+# \"\"\"\n+# duckdb_from_timestamp(ts)\n+# Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.\n+# * ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.\n+# * returns: The `duckdb_timestamp_struct` with the decomposed elements.\n+# DUCKDB_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts);\n+# \"\"\"\n+# function duckdb_from_timestamp(ts)\n+#     return ccall((:duckdb_from_timestamp, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), ts)\n+# end\n+#\n+# \"\"\"\n+# duckdb_to_timestamp(ts)\n+# Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.\n+# * ts: The de-composed elements in a `duckdb_timestamp_struct`.\n+# * returns: The `duckdb_timestamp` element.\n+# */\n+# DUCKDB_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts);\n+# \"\"\"\n+# function duckdb_to_timestamp(ts)\n+#     return ccall((:duckdb_to_timestamp, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), ts)\n+# end\n+#\n+# #=\n+# //===--------------------------------------------------------------------===//\n+# // Hugeint Helpers\n+# //===--------------------------------------------------------------------===//\n+# =#\n+#\n+#\n+# \"\"\"\n+# duckdb_hugeint_to_double(val)\n+# Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.\n+# * val: The hugeint value.\n+# * returns: The converted `double` element.\n+# DUCKDB_API double duckdb_hugeint_to_double(duckdb_hugeint val);\n+# \"\"\"\n+# function duckdb_hugeint_to_double(val)\n+#     return ccall((:duckdb_hugeint_to_double, libduckdb), Float64, (Int64,), val)\n+# end\n+#\n+# \"\"\"\n+# duckdb_double_to_hugeint(val)\n+# Converts a double value to a duckdb_hugeint object.\n+# If the conversion fails because the double value is too big the result will be 0.\n+# * val: The double value.\n+# * returns: The converted `duckdb_hugeint` element.\n+# DUCKDB_API duckdb_hugeint duckdb_double_to_hugeint(double val);\n+# \"\"\"\n+# function duckdb_double_to_hugeint(val)\n+#     return ccall((:duckdb_double_to_hugeint, libduckdb), Int64, (Float64,), val)\n+# end\n+#\n+# #=\n+# //===--------------------------------------------------------------------===//\n+# // Prepared Statements\n+# //===--------------------------------------------------------------------===//\n+# // A prepared statement is a parameterized query that allows you to bind parameters to it.\n+# // * This is useful to easily supply parameters to functions and avoid SQL injection attacks.\n+# // * This is useful to speed up queries that you will execute several times with different parameters.\n+# // Because the query will only be parsed, bound, optimized and planned once during the prepare stage,\n+# // rather than once per execution.\n+# // For example:\n+# //   SELECT * FROM tbl WHERE id=?\n+# // Or a query with multiple parameters:\n+# //   SELECT * FROM tbl WHERE id=$1 OR name=$2\n+# =#\n+\n+\n+\"\"\"\n+Create a prepared statement object from a query.\n+Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using\n+`duckdb_destroy_prepare`, even if the prepare fails.\n+If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.\n+* connection: The connection object\n+* query: The SQL query to prepare\n+* out_prepared_statement: The resulting prepared statement object\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,\n+                                       duckdb_prepared_statement *out_prepared_statement);\n+\"\"\"\n+function duckdb_prepare(connection, query, out_prepared_statement)\n+    return ccall(\n+        (:duckdb_prepare, libduckdb),\n+        duckdb_state,\n+        (duckdb_connection, Ptr{UInt8}, Ref{duckdb_prepared_statement}),\n+        connection,\n+        query,\n+        out_prepared_statement\n+    )\n+end\n+\n+\"\"\"\n+Closes the prepared statement and de-allocates all memory allocated for that connection.\n+* prepared_statement: The prepared statement to destroy.\n+DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);\n+\"\"\"\n+function duckdb_destroy_prepare(prepared_statement)\n+    return ccall((:duckdb_destroy_prepare, libduckdb), Cvoid, (Ref{duckdb_prepared_statement},), prepared_statement)\n+end\n+\n+\"\"\"\n+Returns the error message associated with the given prepared statement.\n+If the prepared statement has no error message, this returns `nullptr` instead.\n+The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.\n+* prepared_statement: The prepared statement to obtain the error from.\n+* returns: The error message, or `nullptr` if there is none.\n+DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);\n+\"\"\"\n+function duckdb_prepare_error(prepared_statement)\n+    return ccall((:duckdb_prepare_error, libduckdb), Ptr{UInt8}, (duckdb_prepared_statement,), prepared_statement[])\n+end\n+\n+\"\"\"\n+Returns the number of parameters that can be provided to the given prepared statement.\n+Returns 0 if the query was not successfully prepared.\n+* prepared_statement: The prepared statement to obtain the number of parameters for.\n+DUCKDB_API idx_t duckdb_nparams(duckdb_prepared_statement prepared_statement);\n+\"\"\"\n+function duckdb_nparams(prepared_statement)\n+    return ccall((:duckdb_nparams, libduckdb), Int32, (duckdb_prepared_statement,), prepared_statement)\n+end\n+\n+\"\"\"\n+Returns the parameter type for the parameter at the given index.\n+Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.\n+* prepared_statement: The prepared statement.\n+* param_idx: The parameter index.\n+* returns: The parameter type\n+DUCKDB_API duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_t param_idx);\n+\"\"\"\n+function duckdb_param_type(prepared_statement, param_idx)\n+    return ccall(\n+        (:duckdb_param_type, libduckdb),\n+        Int32,\n+        (duckdb_prepared_statement, Int32),\n+        prepared_statement,\n+        param_idx\n+    )\n+end\n+\n+\"\"\"\n+Binds a bool value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);\n+\"\"\"\n+function duckdb_bind_boolean(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_boolean, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Int32),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds an int8_t value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);\n+\"\"\"\n+function duckdb_bind_int8(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_int8, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Int8),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds an int16_t value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);\n+\"\"\"\n+function duckdb_bind_int16(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_int16, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Int16),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds an int32_t value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);\n+\"\"\"\n+function duckdb_bind_int32(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_int32, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Int32),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds an int64_t value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);\n+\"\"\"\n+function duckdb_bind_int64(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_int64, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Int64),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds an duckdb_hugeint value to the prepared statement at the specified index.\n+*/\n+DUCKDB_API duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                            duckdb_hugeint val);\n+\"\"\"\n+function duckdb_bind_hugeint(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_hugeint, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, duckdb_hugeint),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds an uint8_t value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);\n+\"\"\"\n+function duckdb_bind_uint8(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_uint8, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, UInt8),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds an uint16_t value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val);\n+\"\"\"\n+function duckdb_bind_uint16(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_uint16, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, UInt16),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds an uint32_t value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);\n+\"\"\"\n+function duckdb_bind_uint32(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_uint32, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, UInt32),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds an uint64_t value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);\n+\"\"\"\n+function duckdb_bind_uint64(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_uint64, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, UInt64),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds an float value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);\n+\"\"\"\n+function duckdb_bind_float(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_float, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Float32),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds an double value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);\n+\"\"\"\n+function duckdb_bind_double(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_double, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Float64),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds a duckdb_date value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                         duckdb_date val);\n+\"\"\"\n+function duckdb_bind_date(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_date, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Int32),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds a duckdb_time value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                         duckdb_time val);\n+\"\"\"\n+function duckdb_bind_time(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_time, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Int64),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds a duckdb_timestamp value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                              duckdb_timestamp val);\n+\"\"\"\n+function duckdb_bind_timestamp(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_timestamp, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Int64),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds a duckdb_interval value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                             duckdb_interval val);\n+\"\"\"\n+function duckdb_bind_interval(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_interval, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Int32),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds a null-terminated varchar value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                            const char *val);\n+\"\"\"\n+function duckdb_bind_varchar(prepared_statement, param_idx, val)\n+    return ccall(\n+        (:duckdb_bind_varchar, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Ptr{UInt8}),\n+        prepared_statement,\n+        param_idx,\n+        val\n+    )\n+end\n+\n+\"\"\"\n+Binds a varchar value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                                   const char *val, idx_t length);\n+\"\"\"\n+function duckdb_bind_varchar_length(prepared_statement, param_idx, val, length)\n+    return ccall(\n+        (:duckdb_bind_varchar_length, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Ptr{UInt8}, Int32),\n+        prepared_statement,\n+        param_idx,\n+        val,\n+        length\n+    )\n+end\n+\n+\"\"\"\n+Binds a blob value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                         const void *data, idx_t length);\n+\"\"\"\n+function duckdb_bind_blob(prepared_statement, param_idx, val, length)\n+    return ccall(\n+        (:duckdb_bind_blob, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32, Ptr{Cvoid}, Int32),\n+        prepared_statement,\n+        param_idx,\n+        data,\n+        length\n+    )\n+end\n+\n+\"\"\"\n+Binds a NULL value to the prepared statement at the specified index.\n+DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);\n+\"\"\"\n+function duckdb_bind_null(prepared_statement, param_idx)\n+    return ccall(\n+        (:duckdb_bind_null, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Int32),\n+        prepared_statement,\n+        param_idx\n+    )\n+end\n+\n+\"\"\"\n+Executes the prepared statement with the given bound parameters, and returns a materialized query result.\n+This method can be called multiple times for each prepared statement, and the parameters can be modified\n+between calls to this function.\n+* prepared_statement: The prepared statement to execute.\n+* out_result: The query result.\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,\n+                                                duckdb_result *out_result);\n+\"\"\"\n+function duckdb_execute_prepared(prepared_statement, out_result)\n+    return ccall(\n+        (:duckdb_execute_prepared, libduckdb),\n+        duckdb_state,\n+        (duckdb_prepared_statement, Ref{duckdb_result}),\n+        prepared_statement,\n+        out_result\n+    )\n+end\n+\n+# \"\"\"\n+# Executes the prepared statement with the given bound parameters, and returns an arrow query result.\n+# * prepared_statement: The prepared statement to execute.\n+# * out_result: The query result.\n+# * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+# DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,\n+#                                                       duckdb_arrow *out_result);\n+# \"\"\"\n+# function duckdb_execute_prepared_arrow(prepared_statement, out_result)\n+#     return ccall(\n+#         (:duckdb_execute_prepared_arrow, libduckdb),\n+#         duckdb_state,\n+#         (Ptr{Cvoid}, Ptr{Cvoid}),\n+#         prepared_statement,\n+#         out_result,\n+#     )\n+# end\n+\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Value Interface\n+//===--------------------------------------------------------------------===//\n+=#\n+\"\"\"\n+Destroys the value and de-allocates all memory allocated for that type.\n+\n+* value: The value to destroy.\n+\"\"\"\n+function duckdb_destroy_value(handle)\n+    return ccall((:duckdb_destroy_value, libduckdb), Cvoid, (Ref{duckdb_value},), handle)\n+end\n+\n+\"\"\"\n+Creates a value from a string\n+\n+* value: The varchar value\n+* returns: The value. This must be destroyed with `duckdb_destroy_value`.\n+\"\"\"\n+function duckdb_create_varchar(handle)\n+    return ccall((:duckdb_create_varchar, libduckdb), duckdb_value, (Ptr{UInt8},), handle)\n+end\n+\n+\"\"\"\n+Creates a value from an int64\n+\n+* value: The bigint value\n+* returns: The value. This must be destroyed with `duckdb_destroy_value`.\n+\"\"\"\n+function duckdb_create_int64(handle)\n+    return ccall((:duckdb_create_int64, libduckdb), duckdb_value, (Int64,), handle)\n+end\n+\n+\"\"\"\n+Obtains a string representation of the given value.\n+The result must be destroyed with `duckdb_free`.\n+\n+* value: The value\n+* returns: The string value. This must be destroyed with `duckdb_free`.\n+\"\"\"\n+function duckdb_get_varchar(handle)\n+    return ccall((:duckdb_get_varchar, libduckdb), Ptr{UInt8}, (duckdb_value,), handle)\n+end\n+\n+\"\"\"\n+Obtains an int64 of the given value.\n+\n+* value: The value\n+* returns: The int64 value, or 0 if no conversion is possible\n+\"\"\"\n+function duckdb_get_int64(handle)\n+    return ccall((:duckdb_get_int64, libduckdb), Int64, (duckdb_value,), handle)\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Logical Type Interface\n+//===--------------------------------------------------------------------===//\n+=#\n+\"\"\"\n+Creates a `duckdb_logical_type` from a standard primitive type.\n+The resulting type should be destroyed with `duckdb_destroy_logical_type`.\n+\n+This should not be used with `DUCKDB_TYPE_DECIMAL`.\n+\n+* type: The primitive type to create.\n+* returns: The logical type type.\n+\"\"\"\n+function duckdb_create_logical_type(type)\n+    return ccall((:duckdb_create_logical_type, libduckdb), duckdb_logical_type, (Int32,), type)\n+end\n+\n+\"\"\"\n+Retrieves the type class of a `duckdb_logical_type`.\n+\n+* type: The logical type object\n+* returns: The type id\n+\"\"\"\n+function duckdb_get_type_id(handle)\n+    return ccall((:duckdb_get_type_id, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)\n+end\n+\n+\"\"\"\n+Retrieves the width of a decimal type.\n+\n+* type: The logical type object\n+* returns: The width of the decimal type\n+\"\"\"\n+function duckdb_decimal_width(handle)\n+    return ccall((:duckdb_decimal_width, libduckdb), UInt8, (duckdb_logical_type,), handle)\n+end\n+\n+\"\"\"\n+Retrieves the scale of a decimal type.\n+\n+* type: The logical type object\n+* returns: The scale of the decimal type\n+\"\"\"\n+function duckdb_decimal_scale(handle)\n+    return ccall((:duckdb_decimal_scale, libduckdb), UInt8, (duckdb_logical_type,), handle)\n+end\n+\n+\"\"\"\n+Retrieves the internal storage type of a decimal type.\n+\n+* type: The logical type object\n+* returns: The internal type of the decimal type\n+\"\"\"\n+function duckdb_decimal_internal_type(handle)\n+    return ccall((:duckdb_decimal_internal_type, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)\n+end\n+\n+\"\"\"\n+Retrieves the internal storage type of an enum type.\n+\n+* type: The logical type object\n+* returns: The internal type of the enum type\n+\"\"\"\n+function duckdb_enum_internal_type(handle)\n+    return ccall((:duckdb_enum_internal_type, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)\n+end\n+\n+\"\"\"\n+Retrieves the dictionary size of the enum type\n+\n+* type: The logical type object\n+* returns: The dictionary size of the enum type\n+\"\"\"\n+function duckdb_enum_dictionary_size(handle)\n+    return ccall((:duckdb_enum_dictionary_size, libduckdb), UInt32, (duckdb_logical_type,), handle)\n+end\n+\n+\"\"\"\n+Retrieves the dictionary value at the specified position from the enum.\n+\n+The result must be freed with `duckdb_free`\n+\n+* type: The logical type object\n+* index: The index in the dictionary\n+* returns: The string value of the enum type. Must be freed with `duckdb_free`.\n+\"\"\"\n+function duckdb_enum_dictionary_value(handle, index)\n+    return ccall(\n+        (:duckdb_enum_dictionary_value, libduckdb),\n+        Ptr{UInt8},\n+        (duckdb_logical_type, UInt64),\n+        handle,\n+        index - 1\n+    )\n+end\n+\n+\"\"\"\n+Retrieves the child type of the given list type.\n+\n+The result must be freed with `duckdb_destroy_logical_type`\n+\n+* type: The logical type object\n+* returns: The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`.\n+\"\"\"\n+function duckdb_list_type_child_type(handle)\n+    return ccall((:duckdb_list_type_child_type, libduckdb), duckdb_logical_type, (duckdb_logical_type,), handle)\n+end\n+\n+\"\"\"\n+Returns the number of children of a struct type.\n+\n+* type: The logical type object\n+* returns: The number of children of a struct type.\n+\"\"\"\n+function duckdb_struct_type_child_count(handle)\n+    return ccall((:duckdb_struct_type_child_count, libduckdb), UInt64, (duckdb_logical_type,), handle)\n+end\n+\n+\"\"\"\n+Retrieves the name of the struct child.\n+\n+The result must be freed with `duckdb_free`\n+\n+* type: The logical type object\n+* index: The child index\n+* returns: The name of the struct type. Must be freed with `duckdb_free`.\n+\"\"\"\n+function duckdb_struct_type_child_name(handle, index)\n+    return ccall(\n+        (:duckdb_struct_type_child_name, libduckdb),\n+        Ptr{UInt8},\n+        (duckdb_logical_type, UInt64),\n+        handle,\n+        index - 1\n+    )\n+end\n+\n+\"\"\"\n+Retrieves the child type of the given struct type at the specified index.\n+\n+The result must be freed with `duckdb_destroy_logical_type`\n+\n+* type: The logical type object\n+* index: The child index\n+* returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.\n+\"\"\"\n+function duckdb_struct_type_child_type(handle, index)\n+    return ccall(\n+        (:duckdb_struct_type_child_type, libduckdb),\n+        duckdb_logical_type,\n+        (duckdb_logical_type, UInt64),\n+        handle,\n+        index - 1\n+    )\n+end\n+\n+\"\"\"\n+Destroys the logical type and de-allocates all memory allocated for that type.\n+\n+* type: The logical type to destroy.\n+\"\"\"\n+function duckdb_destroy_logical_type(handle)\n+    return ccall((:duckdb_destroy_logical_type, libduckdb), Cvoid, (Ref{duckdb_logical_type},), handle)\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Data Chunk Interface\n+//===--------------------------------------------------------------------===//\n+=#\n+\"\"\"\n+Creates an empty DataChunk with the specified set of types.\n+\n+* types: An array of types of the data chunk.\n+* column_count: The number of columns.\n+* returns: The data chunk.\n+\"\"\"\n+function duckdb_create_data_chunk(types, column_count)\n+    return ccall(\n+        (:duckdb_create_data_chunk, libduckdb),\n+        duckdb_data_chunk,\n+        (Ptr{duckdb_logical_type}, UInt64),\n+        types,\n+        column_count\n+    )\n+end\n+\n+\"\"\"\n+Destroys the data chunk and de-allocates all memory allocated for that chunk.\n+\n+* chunk: The data chunk to destroy.\n+\"\"\"\n+function duckdb_destroy_data_chunk(chunk)\n+    return ccall((:duckdb_destroy_data_chunk, libduckdb), Cvoid, (Ref{duckdb_data_chunk},), chunk)\n+end\n+\n+\"\"\"\n+Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.\n+\n+* chunk: The data chunk to reset.\n+\"\"\"\n+function duckdb_data_chunk_reset(chunk)\n+    return ccall((:duckdb_data_chunk_reset, libduckdb), Cvoid, (duckdb_data_chunk,), chunk)\n+end\n+\n+\"\"\"\n+Retrieves the number of columns in a data chunk.\n+\n+* chunk: The data chunk to get the data from\n+* returns: The number of columns in the data chunk\n+\"\"\"\n+function duckdb_data_chunk_get_column_count(chunk)\n+    return ccall((:duckdb_data_chunk_get_column_count, libduckdb), UInt64, (duckdb_data_chunk,), chunk)\n+end\n+\n+\n+\"\"\"\n+Retrieves the current number of tuples in a data chunk.\n+\n+* chunk: The data chunk to get the data from\n+* returns: The number of tuples in the data chunk\n+\"\"\"\n+function duckdb_data_chunk_get_size(chunk)\n+    return ccall((:duckdb_data_chunk_get_size, libduckdb), UInt64, (duckdb_data_chunk,), chunk)\n+end\n+\n+\"\"\"\n+Sets the current number of tuples in a data chunk.\n+\n+* chunk: The data chunk to set the size in\n+* size: The number of tuples in the data chunk\n+\"\"\"\n+function duckdb_data_chunk_set_size(chunk, size)\n+    return ccall((:duckdb_data_chunk_set_size, libduckdb), Cvoid, (duckdb_data_chunk, UInt64), chunk, size)\n+end\n+\n+\"\"\"\n+Retrieves the vector at the specified column index in the data chunk.\n+\n+The pointer to the vector is valid for as long as the chunk is alive.\n+It does NOT need to be destroyed.\n+\n+* chunk: The data chunk to get the data from\n+* returns: The vector\n+\"\"\"\n+function duckdb_data_chunk_get_vector(chunk, col_idx)\n+    return ccall(\n+        (:duckdb_data_chunk_get_vector, libduckdb),\n+        duckdb_vector,\n+        (duckdb_data_chunk, UInt64),\n+        chunk,\n+        col_idx - 1\n+    )\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Vector Functions\n+//===--------------------------------------------------------------------===//\n+=#\n+\"\"\"\n+Retrieves the column type of the specified vector.\n+\n+The result must be destroyed with `duckdb_destroy_logical_type`.\n+\n+* vector: The vector get the data from\n+* returns: The type of the vector\n+\"\"\"\n+function duckdb_vector_get_column_type(vector)\n+    return ccall((:duckdb_vector_get_column_type, libduckdb), duckdb_logical_type, (duckdb_vector,), vector)\n+end\n+\n+\"\"\"\n+Retrieves the data pointer of the vector.\n+\n+The data pointer can be used to read or write values from the vector.\n+How to read or write values depends on the type of the vector.\n+\n+* vector: The vector to get the data from\n+* returns: The data pointer\n+\"\"\"\n+function duckdb_vector_get_data(vector)\n+    return ccall((:duckdb_vector_get_data, libduckdb), Ptr{Cvoid}, (duckdb_vector,), vector)\n+end\n+\n+\"\"\"\n+Retrieves the validity mask pointer of the specified vector.\n+\n+If all values are valid, this function MIGHT return NULL!\n+\n+The validity mask is a bitset that signifies null-ness within the data chunk.\n+It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.\n+The bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).\n+\n+Validity of a specific value can be obtained like this:\n+\n+idx_t entry_idx = row_idx / 64;\n+idx_t idx_in_entry = row_idx % 64;\n+bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);\n+\n+Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.\n+\n+* vector: The vector to get the data from\n+* returns: The pointer to the validity mask, or NULL if no validity mask is present\n+\"\"\"\n+function duckdb_vector_get_validity(vector)\n+    return ccall((:duckdb_vector_get_validity, libduckdb), Ptr{UInt64}, (duckdb_vector,), vector)\n+end\n+\n+\"\"\"\n+Ensures the validity mask is writable by allocating it.\n+\n+After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.\n+This allows null values to be written to the vector, regardless of whether a validity mask was present before.\n+\n+* vector: The vector to alter\n+\"\"\"\n+function duckdb_vector_ensure_validity_writable(vector)\n+    return ccall((:duckdb_vector_ensure_validity_writable, libduckdb), Cvoid, (duckdb_vector,), vector)\n+end\n+\n+\"\"\"\n+Retrieves the child vector of a list vector.\n+\n+The resulting vector is valid as long as the parent vector is valid.\n+\n+* vector: The vector\n+* returns: The child vector\n+\"\"\"\n+function duckdb_list_vector_get_child(vector)\n+    return ccall((:duckdb_list_vector_get_child, libduckdb), duckdb_vector, (duckdb_vector,), vector)\n+end\n+\n+\"\"\"\n+Returns the size of the child vector of the list\n+\n+* vector: The vector\n+* returns: The size of the child list\n+\"\"\"\n+function duckdb_list_vector_get_size(vector)\n+    return ccall((:duckdb_list_vector_get_size, libduckdb), UInt64, (duckdb_vector,), vector)\n+end\n+\n+\"\"\"\n+Retrieves the child vector of a struct vector.\n+\n+The resulting vector is valid as long as the parent vector is valid.\n+\n+* vector: The vector\n+* index: The child index\n+* returns: The child vector\n+\"\"\"\n+function duckdb_struct_vector_get_child(vector, index)\n+    return ccall(\n+        (:duckdb_struct_vector_get_child, libduckdb),\n+        duckdb_vector,\n+        (duckdb_vector, UInt64),\n+        vector,\n+        index - 1\n+    )\n+end\n+\n+\"\"\"\n+Assigns a string element in the vector at the specified location.\n+\n+* vector: The vector to alter\n+* index: The row position in the vector to assign the string to\n+* str: The null-terminated string\n+\"\"\"\n+function duckdb_vector_assign_string_element(vector, index, str)\n+    return ccall(\n+        (:duckdb_vector_assign_string_element, libduckdb),\n+        Cvoid,\n+        (duckdb_vector, UInt64, Ptr{UInt8}),\n+        vector,\n+        index - 1,\n+        str\n+    )\n+end\n+\"\"\"\n+Assigns a string element in the vector at the specified location.\n+\n+* vector: The vector to alter\n+* index: The row position in the vector to assign the string to\n+* str: The null-terminated string\n+* str_len: The string length\n+\"\"\"\n+function duckdb_vector_assign_string_element_len(vector, index, str, str_len)\n+    return ccall(\n+        (:duckdb_vector_assign_string_element_len, libduckdb),\n+        Cvoid,\n+        (duckdb_vector, UInt64, Ptr{UInt8}, UInt64),\n+        vector,\n+        index - 1,\n+        str,\n+        str_len\n+    )\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Table Functions\n+//===--------------------------------------------------------------------===//\n+=#\n+\"\"\"\n+Creates a new empty table function.\n+\n+The return value should be destroyed with `duckdb_destroy_table_function`.\n+\n+* returns: The table function object.\n+\"\"\"\n+function duckdb_create_table_function()\n+    return ccall((:duckdb_create_table_function, libduckdb), duckdb_table_function, ())\n+end\n+\n+\"\"\"\n+Destroys the given table function object.\n+\n+* table_function: The table function to destroy\n+\"\"\"\n+function duckdb_destroy_table_function(func)\n+    return ccall((:duckdb_destroy_table_function, libduckdb), Cvoid, (Ref{duckdb_table_function},), func)\n+end\n+\n+\"\"\"\n+Sets the name of the given table function.\n+\n+* table_function: The table function\n+* name: The name of the table function\n+\"\"\"\n+function duckdb_table_function_set_name(func, name)\n+    return ccall((:duckdb_table_function_set_name, libduckdb), Cvoid, (duckdb_table_function, Ptr{UInt8}), func, name)\n+end\n+\n+\"\"\"\n+Adds a parameter to the table function.\n+\n+* table_function: The table function\n+* type: The type of the parameter to add.\n+\"\"\"\n+function duckdb_table_function_add_parameter(func, type)\n+    return ccall(\n+        (:duckdb_table_function_add_parameter, libduckdb),\n+        Cvoid,\n+        (duckdb_table_function, duckdb_logical_type),\n+        func,\n+        type\n+    )\n+end\n+\n+\"\"\"\n+Assigns extra information to the table function that can be fetched during binding, etc.\n+\n+* table_function: The table function\n+* extra_info: The extra information\n+* destroy: The callback that will be called to destroy the bind data (if any)\n+\"\"\"\n+function duckdb_table_function_set_extra_info(table_func, extra_data)\n+    return ccall(\n+        (:duckdb_table_function_set_extra_info, libduckdb),\n+        Cvoid,\n+        (duckdb_table_function, Ptr{Cvoid}, Ptr{Cvoid}),\n+        table_func,\n+        extra_data,\n+        C_NULL\n+    )\n+end\n+\n+\"\"\"\n+Sets the bind function of the table function\n+\n+* table_function: The table function\n+* bind: The bind function\n+\"\"\"\n+function duckdb_table_function_set_bind(table_func, bind_func)\n+    return ccall(\n+        (:duckdb_table_function_set_bind, libduckdb),\n+        Cvoid,\n+        (duckdb_table_function, Ptr{Cvoid}),\n+        table_func,\n+        bind_func\n+    )\n+end\n+\n+\"\"\"\n+Sets the init function of the table function\n+\n+* table_function: The table function\n+* init: The init function\n+\"\"\"\n+function duckdb_table_function_set_init(table_func, init_func)\n+    return ccall(\n+        (:duckdb_table_function_set_init, libduckdb),\n+        Cvoid,\n+        (duckdb_table_function, Ptr{Cvoid}),\n+        table_func,\n+        init_func\n+    )\n+end\n+\n+\n+\"\"\"\n+Sets the main function of the table function\n+\n+* table_function: The table function\n+* function: The function\n+\"\"\"\n+function duckdb_table_function_set_function(table_func, func)\n+    return ccall(\n+        (:duckdb_table_function_set_function, libduckdb),\n+        Cvoid,\n+        (duckdb_table_function, Ptr{Cvoid}),\n+        table_func,\n+        func\n+    )\n+end\n+\n+\n+\"\"\"\n+Register the table function object within the given connection.\n+\n+The function requires at least a name, a bind function, an init function and a main function.\n+\n+If the function is incomplete or a function with this name already exists DuckDBError is returned.\n+\n+* con: The connection to register it in.\n+* function: The function pointer\n+* returns: Whether or not the registration was successful.\n+\"\"\"\n+function duckdb_register_table_function(con, func)\n+    return ccall(\n+        (:duckdb_register_table_function, libduckdb),\n+        Int32,\n+        (duckdb_connection, duckdb_table_function),\n+        con,\n+        func\n+    )\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Table Function Bind\n+//===--------------------------------------------------------------------===//\n+=#\n+\n+\"\"\"\n+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`\n+\n+* info: The info object\n+* returns: The extra info\n+\"\"\"\n+function duckdb_bind_get_extra_info(bind_info)\n+    return ccall((:duckdb_bind_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_bind_info,), bind_info)\n+end\n+\n+\"\"\"\n+Adds a result column to the output of the table function.\n+\n+* info: The info object\n+* name: The name of the column\n+* type: The logical type of the column\n+\"\"\"\n+function duckdb_bind_add_result_column(bind_info, name, type)\n+    return ccall(\n+        (:duckdb_bind_add_result_column, libduckdb),\n+        Cvoid,\n+        (duckdb_bind_info, Ptr{UInt8}, duckdb_logical_type),\n+        bind_info,\n+        name,\n+        type\n+    )\n+end\n+\n+\"\"\"\n+Retrieves the number of regular (non-named) parameters to the function.\n+\n+* info: The info object\n+* returns: The number of parameters\n+\"\"\"\n+function duckdb_bind_get_parameter_count(bind_info)\n+    return ccall((:duckdb_bind_get_parameter_count, libduckdb), Int32, (duckdb_bind_info,), bind_info)\n+end\n+\n+\"\"\"\n+Retrieves the parameter at the given index.\n+\n+The result must be destroyed with `duckdb_destroy_value`.\n+\n+* info: The info object\n+* index: The index of the parameter to get\n+* returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.\n+\"\"\"\n+function duckdb_bind_get_parameter(bind_info, index)\n+    return ccall((:duckdb_bind_get_parameter, libduckdb), duckdb_value, (duckdb_bind_info, Int32), bind_info, index)\n+end\n+\n+\"\"\"\n+Retrieves the parameter at the given index.\n+\n+The result must be destroyed with `duckdb_destroy_value`.\n+\n+* info: The info object\n+* index: The index of the parameter to get\n+* returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.\n+\"\"\"\n+function duckdb_bind_set_bind_data(bind_info, bind_data, delete_callback)\n+    return ccall(\n+        (:duckdb_bind_set_bind_data, libduckdb),\n+        Cvoid,\n+        (duckdb_bind_info, Ptr{Cvoid}, Ptr{Cvoid}),\n+        bind_info,\n+        bind_data,\n+        delete_callback\n+    )\n+end\n+\n+\"\"\"\n+Report that an error has occurred during bind.\n+\n+* info: The info object\n+* error: The error message\n+\"\"\"\n+function duckdb_bind_set_error(info, error_message)\n+    return ccall((:duckdb_bind_set_error, libduckdb), Cvoid, (duckdb_bind_info, Ptr{UInt8}), info, error_message)\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Table Function Init\n+//===--------------------------------------------------------------------===//\n+=#\n+\"\"\"\n+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`\n+\n+* info: The info object\n+* returns: The extra info\n+\"\"\"\n+function duckdb_init_get_extra_info(info)\n+    return ccall((:duckdb_init_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_init_info,), info)\n+end\n+\n+\"\"\"\n+Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.\n+\n+Note that the bind data should be considered as read-only.\n+For tracking state, use the init data instead.\n+\n+* info: The info object\n+* returns: The bind data object\n+\"\"\"\n+function duckdb_init_get_bind_data(info)\n+    return ccall((:duckdb_init_get_bind_data, libduckdb), Ptr{Cvoid}, (duckdb_init_info,), info)\n+end\n+\n+\"\"\"\n+Sets the user-provided init data in the init object. This object can be retrieved again during execution.\n+\n+* info: The info object\n+* extra_data: The init data object.\n+* destroy: The callback that will be called to destroy the init data (if any)\n+\"\"\"\n+function duckdb_init_set_init_data(init_info, init_data, delete_callback)\n+    return ccall(\n+        (:duckdb_init_set_init_data, libduckdb),\n+        Cvoid,\n+        (duckdb_init_info, Ptr{Cvoid}, Ptr{Cvoid}),\n+        init_info,\n+        init_data,\n+        delete_callback\n+    )\n+end\n+\n+\"\"\"\n+Report that an error has occurred during init.\n+\n+* info: The info object\n+* error: The error message\n+\"\"\"\n+function duckdb_init_set_error(info, error_message)\n+    return ccall((:duckdb_init_set_error, libduckdb), Cvoid, (duckdb_init_info, Ptr{UInt8}), info, error_message)\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Table Function\n+//===--------------------------------------------------------------------===//\n+=#\n+\"\"\"\n+Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`\n+\n+* info: The info object\n+* returns: The extra info\n+\"\"\"\n+function duckdb_function_get_extra_info(info)\n+    return ccall((:duckdb_function_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)\n+end\n+\n+\"\"\"\n+Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.\n+\n+Note that the bind data should be considered as read-only.\n+For tracking state, use the init data instead.\n+\n+* info: The info object\n+* returns: The bind data object\n+\"\"\"\n+function duckdb_function_get_bind_data(info)\n+    return ccall((:duckdb_function_get_bind_data, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)\n+end\n+\n+\"\"\"\n+Gets the init data set by `duckdb_bind_set_init_data` during the bind.\n+\n+* info: The info object\n+* returns: The init data object\n+\"\"\"\n+function duckdb_function_get_init_data(info)\n+    return ccall((:duckdb_function_get_init_data, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)\n+end\n+\n+\"\"\"\n+Report that an error has occurred while executing the function.\n+\n+* info: The info object\n+* error: The error message\n+\"\"\"\n+function duckdb_function_set_error(info, error_message)\n+    return ccall(\n+        (:duckdb_function_set_error, libduckdb),\n+        Cvoid,\n+        (duckdb_function_info, Ptr{UInt8}),\n+        info,\n+        error_message\n+    )\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Replacement scans\n+//===--------------------------------------------------------------------===//\n+=#\n+\"\"\"\n+Add a replacement scan definition to the specified database\n+\n+* db: The database object to add the replacement scan to\n+* replacement: The replacement scan callback\n+* extra_data: Extra data that is passed back into the specified callback\n+* delete_callback: The delete callback to call on the extra data, if any\n+\"\"\"\n+function duckdb_add_replacement_scan(db, replacement, extra_data, delete_callback)\n+    return ccall(\n+        (:duckdb_add_replacement_scan, libduckdb),\n+        Cvoid,\n+        (duckdb_database, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}),\n+        db,\n+        replacement,\n+        extra_data,\n+        delete_callback\n+    )\n+end\n+\n+\"\"\"\n+Sets the replacement function name to use. If this function is called in the replacement callback,\n+ the replacement scan is performed. If it is not called, the replacement callback is not performed.\n+\n+* info: The info object\n+* function_name: The function name to substitute.\n+\"\"\"\n+function duckdb_replacement_scan_set_function_name(info, function_name)\n+    return ccall(\n+        (:duckdb_replacement_scan_set_function_name, libduckdb),\n+        Cvoid,\n+        (duckdb_replacement_scan_info, Ptr{UInt8}),\n+        info,\n+        function_name\n+    )\n+end\n+\n+\n+\"\"\"\n+Adds a parameter to the replacement scan function.\n+\n+* info: The info object\n+* parameter: The parameter to add. The function will call `duckdb_destroy_value` on the parameter.\n+\"\"\"\n+function duckdb_replacement_scan_add_parameter(info, parameter)\n+    return ccall(\n+        (:duckdb_replacement_scan_add_parameter, libduckdb),\n+        Cvoid,\n+        (duckdb_replacement_scan_info, duckdb_value),\n+        info,\n+        parameter\n+    )\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Appender\n+//===--------------------------------------------------------------------===//\n+=#\n+\n+\"\"\"\n+Creates an appender object.\n+* connection: The connection context to create the appender in.\n+* schema: The schema of the table to append to, or `nullptr` for the default schema.\n+* table: The table name to append to.\n+* out_appender: The resulting appender object.\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,\n+                                               duckdb_appender *out_appender);\n+\"\"\"\n+function duckdb_appender_create(connection, schema, table, out_appender)\n+    return ccall(\n+        (:duckdb_appender_create, libduckdb),\n+        Int32,\n+        (duckdb_connection, Ptr{UInt8}, Ptr{UInt8}, Ref{duckdb_appender}),\n+        connection,\n+        schema,\n+        table,\n+        out_appender\n+    )\n+end\n+\n+\"\"\"\n+Returns the error message associated with the given appender.\n+If the appender has no error message, this returns `nullptr` instead.\n+The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.\n+* appender: The appender to get the error from.\n+* returns: The error message, or `nullptr` if there is none.\n+DUCKDB_API const char *duckdb_appender_error(duckdb_appender appender);\n+\"\"\"\n+function duckdb_appender_error(appender)\n+    return ccall((:duckdb_appender_error, libduckdb), Ptr{UInt8}, (duckdb_appender,), appender)\n+end\n+\n+\"\"\"\n+Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the\n+base table.\n+This should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you\n+are done with the appender.\n+* appender: The appender to flush.\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+DUCKDB_API duckdb_state duckdb_appender_flush(duckdb_appender appender);\n+\"\"\"\n+function duckdb_appender_flush(appender)\n+    return ccall((:duckdb_appender_flush, libduckdb), duckdb_state, (duckdb_appender,), appender)\n+end\n+\n+\"\"\"\n+Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.\n+This is generally not necessary. Call `duckdb_appender_destroy` instead.\n+* appender: The appender to flush and close.\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);\n+\"\"\"\n+function duckdb_appender_close(appender)\n+    return ccall((:duckdb_appender_close, libduckdb), duckdb_state, (duckdb_appender,), appender)\n+end\n+\n+\"\"\"\n+Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating\n+all memory associated with the appender.\n+* appender: The appender to flush, close and destroy.\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);\n+\"\"\"\n+function duckdb_appender_destroy(appender)\n+    return ccall((:duckdb_appender_destroy, libduckdb), duckdb_state, (Ref{duckdb_appender},), appender)\n+end\n+\n+\"\"\"\n+A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.\n+DUCKDB_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);\n+\"\"\"\n+function duckdb_appender_begin_row(appender)\n+    return ccall((:duckdb_appender_begin_row, libduckdb), duckdb_state, (duckdb_appender,), appender)\n+end\n+\n+\"\"\"\n+Finish the current row of appends. After end_row is called, the next row can be appended.\n+* appender: The appender.\n+* returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+DUCKDB_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);\n+\"\"\"\n+function duckdb_appender_end_row(appender)\n+    return ccall((:duckdb_appender_end_row, libduckdb), duckdb_state, (duckdb_appender,), appender)\n+end\n+\n+\"\"\"\n+Append a bool value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);\n+\"\"\"\n+function duckdb_append_bool(appender, value)\n+    return ccall((:duckdb_append_bool, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)\n+end\n+\n+\"\"\"\n+Append an int8_t value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);\n+\"\"\"\n+function duckdb_append_int8(appender, value)\n+    return ccall((:duckdb_append_int8, libduckdb), duckdb_state, (duckdb_appender, Int16), appender, value)\n+end\n+\n+\"\"\"\n+Append an int16_t value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);\n+\"\"\"\n+function duckdb_append_int16(appender, value)\n+    return ccall((:duckdb_append_int16, libduckdb), duckdb_state, (duckdb_appender, Int16), appender, value)\n+end\n+\n+\"\"\"\n+Append an int32_t value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);\n+\"\"\"\n+function duckdb_append_int32(appender, value)\n+    return ccall((:duckdb_append_int16, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)\n+end\n+\n+\"\"\"\n+Append an int64_t value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);\n+\"\"\"\n+function duckdb_append_int64(appender, value)\n+    return ccall((:duckdb_append_int64, libduckdb), duckdb_state, (duckdb_appender, Int64), appender, value)\n+end\n+\n+\"\"\"\n+Append a duckdb_hugeint value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_hugeint(duckdb_appender appender, duckdb_hugeint value);\n+\"\"\"\n+function duckdb_append_hugeint(appender, value)\n+    return ccall((:duckdb_append_hugeint, libduckdb), duckdb_state, (duckdb_appender, Int64), appender, value)\n+end\n+\n+\"\"\"\n+Append a uint8_t value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);\n+\"\"\"\n+function duckdb_append_uint8(appender, value)\n+    return ccall((:duckdb_append_uint8, libduckdb), duckdb_state, (duckdb_appender, UInt16), appender, value)\n+end\n+\n+\"\"\"\n+Append a uint16_t value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);\n+\"\"\"\n+function duckdb_append_uint16(appender, value)\n+    return ccall((:duckdb_append_uint16, libduckdb), duckdb_state, (duckdb_appender, UInt16), appender, value)\n+end\n+\n+\"\"\"\n+Append a uint32_t value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);\n+\"\"\"\n+function duckdb_append_uint32(appender, value)\n+    return ccall((:duckdb_append_uint32, libduckdb), duckdb_state, (duckdb_appender, UInt32), appender, value)\n+end\n+\n+\"\"\"\n+Append a uint64_t value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);\n+\"\"\"\n+function duckdb_append_uint64(appender, value)\n+    return ccall((:duckdb_append_uint64, libduckdb), duckdb_state, (duckdb_appender, UInt64), appender, value)\n+end\n+\n+\"\"\"\n+Append a float value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);\n+\"\"\"\n+function duckdb_append_float(appender, value)\n+    return ccall((:duckdb_append_float, libduckdb), duckdb_state, (duckdb_appender, Float32), appender, value)\n+end\n+\n+\"\"\"\n+Append a double value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);\n+\"\"\"\n+function duckdb_append_double(appender, value)\n+    return ccall((:duckdb_append_double, libduckdb), duckdb_state, (duckdb_appender, Float64), appender, value)\n+end\n+\n+\"\"\"\n+Append a duckdb_date value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);\n+\"\"\"\n+function duckdb_append_date(appender, value)\n+    return ccall((:duckdb_append_date, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)\n+end\n+\n+\"\"\"\n+Append a duckdb_time value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);\n+\"\"\"\n+function duckdb_append_time(appender, value)\n+    return ccall((:duckdb_append_time, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)\n+end\n+\n+\"\"\"\n+Append a duckdb_timestamp value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);\n+\"\"\"\n+function duckdb_append_timestamp(appender, value)\n+    return ccall((:duckdb_append_timestamp, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)\n+end\n+\n+\"\"\"\n+Append a duckdb_interval value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);\n+\"\"\"\n+function duckdb_append_interval(appender, value)\n+    return ccall((:duckdb_append_interval, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)\n+end\n+\n+\"\"\"\n+Append a varchar value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);\n+\"\"\"\n+function duckdb_append_varchar(appender, value)\n+    return ccall((:duckdb_append_varchar, libduckdb), duckdb_state, (duckdb_appender, Ptr{UInt8}), appender, value)\n+end\n+\n+\"\"\"\n+Append a varchar value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);\n+\"\"\"\n+function duckdb_append_varchar_length(appender, value, length)\n+    return ccall(\n+        (:duckdb_append_varchar_length, libduckdb),\n+        duckdb_state,\n+        (duckdb_appender, Ptr{UInt8}, Int32),\n+        appender,\n+        value,\n+        length\n+    )\n+end\n+\n+\"\"\"\n+Append a blob value to the appender.\n+DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);\n+\"\"\"\n+function duckdb_append_blob(appender, data, length)\n+    return ccall(\n+        (:duckdb_append_blob, libduckdb),\n+        duckdb_state,\n+        (duckdb_appender, Ptr{Cvoid}, Int32),\n+        appender,\n+        data,\n+        length\n+    )\n+end\n+\n+\"\"\"\n+Append a NULL value to the appender (of any type).\n+DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);\n+\"\"\"\n+function duckdb_append_null(appender)\n+    return ccall((:duckdb_append_null, libduckdb), duckdb_state, (duckdb_appender,), appender)\n+end\n+\n+# #=\n+# //===--------------------------------------------------------------------===//\n+# // Arrow Interface\n+# //===--------------------------------------------------------------------===//\n+# =#\n+#\n+#\n+# \"\"\"\n+# Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.\n+# If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling\n+# `duckdb_query_arrow_error`.\n+# Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the\n+# query fails, otherwise the error stored within the result will not be freed correctly.\n+# * connection: The connection to perform the query in.\n+# * query: The SQL query to run.\n+# * out_result: The query result.\n+# * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+# DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);\n+# \"\"\"\n+# function duckdb_query_arrow(connection, query, out_result)\n+#     return ccall(\n+#         (:duckdb_query_arrow, libduckdb),\n+#         Int32,\n+#         (Ptr{Cvoid}, Ptr{UInt8}, Ptr{Cvoid}),\n+#         connection[],\n+#         query,\n+#         out_result,\n+#     )\n+# end\n+#\n+# \"\"\"\n+# Fetch the internal arrow schema from the arrow result.\n+# * result: The result to fetch the schema from.\n+# * out_schema: The output schema.\n+# * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+# DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);\n+# \"\"\"\n+# function duckdb_query_arrow_schema(result, out_schema)\n+#     return ccall(\n+#         (:duckdb_query_arrow_schema, libduckdb),\n+#         duckdb_state,\n+#         (Ptr{Cvoid}, Ptr{UInt8}),\n+#         result,\n+#         out_schema,\n+#     )\n+# end\n+#\n+# \"\"\"\n+# Fetch an internal arrow array from the arrow result.\n+# This function can be called multiple time to get next chunks, which will free the previous out_array.\n+# So consume the out_array before calling this function again.\n+# * result: The result to fetch the array from.\n+# * out_array: The output array.\n+# * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.\n+# DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);\n+# \"\"\"\n+# function duckdb_query_arrow_array(result, out_array)\n+#     return ccall(\n+#         (:duckdb_query_arrow_array, libduckdb),\n+#         duckdb_state,\n+#         (Ptr{Cvoid}, Ptr{Cvoid}),\n+#         result,\n+#         out_array,\n+#     )\n+# end\n+#\n+# \"\"\"\n+# Returns the number of columns present in a the arrow result object.\n+# * result: The result object.\n+# * returns: The number of columns present in the result object.\n+# DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);\n+# \"\"\"\n+# function duckdb_arrow_column_count(result)\n+#     return ccall((:duckdb_arrow_column_count, libduckdb), Int32, (Ptr{Cvoid},), result)\n+# end\n+#\n+# \"\"\"\n+# Returns the number of rows present in a the arrow result object.\n+# * result: The result object.\n+# * returns: The number of rows present in the result object.\n+# DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);\n+# \"\"\"\n+# function duckdb_arrow_row_count(result)\n+#     return ccall((:duckdb_arrow_row_count, libduckdb), Int64, (Ptr{Cvoid},), result)\n+# end\n+#\n+# \"\"\"\n+# Returns the number of rows changed by the query stored in the arrow result. This is relevant only for\n+# INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.\n+# * result: The result object.\n+# * returns: The number of rows changed.\n+# DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);\n+# \"\"\"\n+# function duckdb_arrow_rows_changed(result)\n+#     return ccall((:duckdb_arrow_rows_changed, libduckdb), Int64, (Ptr{Cvoid},), result)\n+# end\n+#\n+# \"\"\"\n+# Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns\n+# `DuckDBError`.\n+# The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.\n+# * result: The result object to fetch the nullmask from.\n+# * returns: The error of the result.\n+# DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);\n+# \"\"\"\n+# function duckdb_query_arrow_error(result)\n+#     return ccall((:duckdb_query_arrow_error, libduckdb), Ptr{UInt8}, (Ptr{Cvoid},), result)\n+# end\n+#\n+# \"\"\"\n+# Closes the result and de-allocates all memory allocated for the arrow result.\n+# * result: The result to destroy.\n+# DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);\n+# \"\"\"\n+# function duckdb_destroy_arrow(result)\n+#     return ccall((:duckdb_destroy_arrow, libduckdb), Cvoid, (Ptr{Ptr{Cvoid}},), result)\n+# end\ndiff --git a/tools/juliapkg/src/appender.jl b/tools/juliapkg/src/appender.jl\nnew file mode 100644\nindex 000000000000..0cdcb1b017e8\n--- /dev/null\n+++ b/tools/juliapkg/src/appender.jl\n@@ -0,0 +1,75 @@\n+\n+\"\"\"\n+An appender object that can be used to append to a table\n+\"\"\"\n+mutable struct Appender\n+    handle::duckdb_appender\n+\n+    function Appender(con::Connection, table::AbstractString)\n+        handle = Ref{duckdb_appender}()\n+        if duckdb_appender_create(con.handle, C_NULL, table, handle) != DuckDBSuccess\n+            error_ptr = duckdb_appender_error(handle)\n+            if error_ptr == C_NULL\n+                error_message = string(\"Opening of Appender for table \\\"\", table, \"\\\" failed: unknown error\")\n+            else\n+                error_message = unsafe_string(error_ptr)\n+            end\n+            duckdb_appender_destroy(handle)\n+            throw(QueryException(error_message))\n+        end\n+        con = new(handle[])\n+        finalizer(_close_appender, con)\n+        return con\n+    end\n+    function Appender(db::DB, table::AbstractString)\n+        return Appender(db.main_connection, table)\n+    end\n+end\n+\n+function _close_appender(appender::Appender)\n+    if appender.handle != C_NULL\n+        duckdb_appender_destroy(appender.handle)\n+    end\n+    appender.handle = C_NULL\n+    return\n+end\n+\n+function close(appender::Appender)\n+    _close_appender(appender)\n+    return\n+end\n+\n+Append(appender::Appender, val::AbstractFloat) = duckdb_append_double(appender.handle, Float64(val));\n+Append(appender::Appender, val::Bool) = duckdb_append_boolean(appender.handle, val);\n+Append(appender::Appender, val::Int8) = duckdb_append_int8(appender.handle, val);\n+Append(appender::Appender, val::Int16) = duckdb_append_int16(appender.handle, val);\n+Append(appender::Appender, val::Int32) = duckdb_append_int32(appender.handle, val);\n+Append(appender::Appender, val::Int64) = duckdb_append_int64(appender.handle, val);\n+Append(appender::Appender, val::UInt8) = duckdb_append_uint8(appender.handle, val);\n+Append(appender::Appender, val::UInt16) = duckdb_append_uint16(appender.handle, val);\n+Append(appender::Appender, val::UInt32) = duckdb_append_uint32(appender.handle, val);\n+Append(appender::Appender, val::UInt64) = duckdb_append_uint64(appender.handle, val);\n+Append(appender::Appender, val::Float32) = duckdb_append_float(appender.handle, val);\n+Append(appender::Appender, val::Float64) = duckdb_append_double(appender.handle, val);\n+Append(appender::Appender, val::Missing) = duckdb_append_null(appender.handle);\n+Append(appender::Appender, val::Nothing) = duckdb_append_null(appender.handle);\n+Append(appender::Appender, val::AbstractString) = duckdb_append_varchar(appender.handle, val);\n+Append(appender::Appender, val::Vector{UInt8}) = duckdb_append_blob(appender.handle, val, sizeof(val));\n+Append(appender::Appender, val::WeakRefString{UInt8}) = duckdb_append_varchar(stmt.handle, i, val.ptr, val.len);\n+\n+function Append(appender::Appender, val::Any)\n+    println(val)\n+    throw(NotImplementedException(\"unsupported type for append\"))\n+end\n+\n+function EndRow(appender::Appender)\n+    duckdb_appender_end_row(appender.handle)\n+    return\n+end\n+\n+function Flush(appender::Appender)\n+    duckdb_appender_flush(appender.handle)\n+    return\n+end\n+\n+DBInterface.close!(appender::Appender) = _close_appender(db)\ndiff --git a/tools/juliapkg/src/config.jl b/tools/juliapkg/src/config.jl\nnew file mode 100644\nindex 000000000000..0f07d6c5c382\n--- /dev/null\n+++ b/tools/juliapkg/src/config.jl\n@@ -0,0 +1,31 @@\n+\"\"\"\n+Configuration object\n+\"\"\"\n+mutable struct Config\n+    handle::duckdb_config\n+\n+    function Config()\n+        handle = Ref{duckdb_connection}()\n+        duckdb_create_config(handle)\n+\n+        result = new(handle[])\n+        finalizer(_destroy_config, result)\n+        return result\n+    end\n+end\n+\n+function _destroy_config(config::Config)\n+    if config.handle != C_NULL\n+        duckdb_destroy_config(config.handle)\n+    end\n+    config.handle = C_NULL\n+    return\n+end\n+\n+function SetConfig(config::Config, name::AbstractString, option::AbstractString)\n+    if duckdb_set_config(config.handle, name, option) != DuckDBSuccess\n+        throw(QueryException(string(\"Unrecognized configuration option \\\"\", name, \"\\\"\")))\n+    end\n+end\n+\n+DBInterface.close!(config::Config) = _destroy_config(config)\ndiff --git a/tools/juliapkg/src/ctypes.jl b/tools/juliapkg/src/ctypes.jl\nnew file mode 100644\nindex 000000000000..1aba17c4c171\n--- /dev/null\n+++ b/tools/juliapkg/src/ctypes.jl\n@@ -0,0 +1,237 @@\n+\n+const duckdb_database = Ptr{Cvoid}\n+const duckdb_config = Ptr{Cvoid}\n+const duckdb_connection = Ptr{Cvoid}\n+const duckdb_prepared_statement = Ptr{Cvoid}\n+const duckdb_logical_type = Ptr{Cvoid}\n+const duckdb_data_chunk = Ptr{Cvoid}\n+const duckdb_vector = Ptr{Cvoid}\n+const duckdb_appender = Ptr{Cvoid}\n+const duckdb_logical_type = Ptr{Cvoid}\n+const duckdb_value = Ptr{Cvoid}\n+const duckdb_table_function = Ptr{Cvoid}\n+const duckdb_bind_info = Ptr{Cvoid}\n+const duckdb_init_info = Ptr{Cvoid}\n+const duckdb_function_info = Ptr{Cvoid}\n+const duckdb_replacement_scan_info = Ptr{Cvoid}\n+const DuckDBSuccess = 0;\n+const DuckDBError = 1;\n+const duckdb_state = Int32;\n+\n+@enum DUCKDB_TYPE_::UInt32 begin\n+    DUCKDB_TYPE_INVALID = 0\n+    DUCKDB_TYPE_BOOLEAN\n+    DUCKDB_TYPE_TINYINT\n+    DUCKDB_TYPE_SMALLINT\n+    DUCKDB_TYPE_INTEGER\n+    DUCKDB_TYPE_BIGINT\n+    DUCKDB_TYPE_UTINYINT\n+    DUCKDB_TYPE_USMALLINT\n+    DUCKDB_TYPE_UINTEGER\n+    DUCKDB_TYPE_UBIGINT\n+    DUCKDB_TYPE_FLOAT\n+    DUCKDB_TYPE_DOUBLE\n+    DUCKDB_TYPE_TIMESTAMP\n+    DUCKDB_TYPE_DATE\n+    DUCKDB_TYPE_TIME\n+    DUCKDB_TYPE_INTERVAL\n+    DUCKDB_TYPE_HUGEINT\n+    DUCKDB_TYPE_VARCHAR\n+    DUCKDB_TYPE_BLOB\n+    DUCKDB_TYPE_DECIMAL\n+    DUCKDB_TYPE_TIMESTAMP_S\n+    DUCKDB_TYPE_TIMESTAMP_MS\n+    DUCKDB_TYPE_TIMESTAMP_NS\n+    DUCKDB_TYPE_ENUM\n+    DUCKDB_TYPE_LIST\n+    DUCKDB_TYPE_STRUCT\n+    DUCKDB_TYPE_MAP\n+    DUCKDB_TYPE_UUID\n+    DUCKDB_TYPE_JSON\n+end\n+\n+const DUCKDB_TYPE = DUCKDB_TYPE_\n+\n+\"\"\"\n+Days are stored as days since 1970-01-01\\n\n+Use the duckdb_from_date/duckdb_to_date function to extract individual information\n+\n+\"\"\"\n+struct duckdb_date\n+    days::Int32\n+end\n+\n+struct duckdb_date_struct\n+    year::Int32\n+    month::Int8\n+    day::Int8\n+end\n+\n+\"\"\"\n+Time is stored as microseconds since 00:00:00\\n\n+Use the duckdb_from_time/duckdb_to_time function to extract individual information\n+\n+\"\"\"\n+struct duckdb_time\n+    micros::Int64\n+end\n+\n+struct duckdb_time_struct\n+    hour::Int8\n+    min::Int8\n+    sec::Int8\n+    micros::Int32\n+end\n+\n+\"\"\"\n+Timestamps are stored as microseconds since 1970-01-01\\n\n+Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information\n+\n+\"\"\"\n+struct duckdb_timestamp\n+    micros::Int64\n+end\n+\n+struct duckdb_timestamp_struct\n+    date::Ref{duckdb_date_struct}\n+    time::Ref{duckdb_time_struct}\n+end\n+\n+struct duckdb_interval\n+    months::Int32\n+    days::Int32\n+    micros::Int64\n+end\n+\n+\"\"\"\n+Hugeints are composed in a (lower, upper) component\\n\n+The value of the hugeint is upper * 2^64 + lower\\n\n+For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended\n+\n+\"\"\"\n+struct duckdb_hugeint\n+    lower::UInt64\n+    upper::Int64\n+end\n+\n+struct duckdb_string_t\n+    length::UInt32\n+    data::NTuple{12, UInt8}\n+end\n+\n+struct duckdb_list_entry_t\n+    offset::UInt64\n+    length::UInt64\n+end\n+\n+STRING_INLINE_LENGTH = 12\n+\n+struct duckdb_column\n+    __deprecated_data::Ptr{Cvoid}\n+    __deprecated_nullmask::Ptr{UInt8}\n+    __deprecated_type::Ptr{DUCKDB_TYPE}\n+    __deprecated_name::Ptr{UInt8}\n+    internal_data::Ptr{Cvoid}\n+end\n+\n+struct duckdb_result\n+    __deprecated_column_count::Ptr{UInt64}\n+    __deprecated_row_count::Ptr{UInt64}\n+    __deprecated_rows_changed::Ptr{UInt64}\n+    __deprecated_columns::Ptr{duckdb_column}\n+    __deprecated_error_message::Ptr{UInt8}\n+    internal_data::Ptr{Cvoid}\n+end\n+\n+INTERNAL_TYPE_MAP = Dict(\n+    DUCKDB_TYPE_BOOLEAN => Bool,\n+    DUCKDB_TYPE_TINYINT => Int8,\n+    DUCKDB_TYPE_SMALLINT => Int16,\n+    DUCKDB_TYPE_INTEGER => Int32,\n+    DUCKDB_TYPE_BIGINT => Int64,\n+    DUCKDB_TYPE_UTINYINT => UInt8,\n+    DUCKDB_TYPE_USMALLINT => UInt16,\n+    DUCKDB_TYPE_UINTEGER => UInt32,\n+    DUCKDB_TYPE_UBIGINT => UInt64,\n+    DUCKDB_TYPE_FLOAT => Float32,\n+    DUCKDB_TYPE_DOUBLE => Float64,\n+    DUCKDB_TYPE_TIMESTAMP => Int64,\n+    DUCKDB_TYPE_TIMESTAMP_S => Int64,\n+    DUCKDB_TYPE_TIMESTAMP_MS => Int64,\n+    DUCKDB_TYPE_TIMESTAMP_NS => Int64,\n+    DUCKDB_TYPE_DATE => Int32,\n+    DUCKDB_TYPE_TIME => Int64,\n+    DUCKDB_TYPE_INTERVAL => duckdb_interval,\n+    DUCKDB_TYPE_HUGEINT => duckdb_hugeint,\n+    DUCKDB_TYPE_UUID => duckdb_hugeint,\n+    DUCKDB_TYPE_VARCHAR => duckdb_string_t,\n+    DUCKDB_TYPE_JSON => duckdb_string_t,\n+    DUCKDB_TYPE_BLOB => duckdb_string_t,\n+    DUCKDB_TYPE_UUID => duckdb_hugeint,\n+    DUCKDB_TYPE_LIST => duckdb_list_entry_t,\n+    DUCKDB_TYPE_STRUCT => Cvoid,\n+    DUCKDB_TYPE_MAP => Cvoid\n+)\n+\n+JULIA_TYPE_MAP = Dict(\n+    DUCKDB_TYPE_INVALID => Missing,\n+    DUCKDB_TYPE_BOOLEAN => Bool,\n+    DUCKDB_TYPE_TINYINT => Int8,\n+    DUCKDB_TYPE_SMALLINT => Int16,\n+    DUCKDB_TYPE_INTEGER => Int32,\n+    DUCKDB_TYPE_BIGINT => Int64,\n+    DUCKDB_TYPE_HUGEINT => Int128,\n+    DUCKDB_TYPE_UTINYINT => UInt8,\n+    DUCKDB_TYPE_USMALLINT => UInt16,\n+    DUCKDB_TYPE_UINTEGER => UInt32,\n+    DUCKDB_TYPE_UBIGINT => UInt64,\n+    DUCKDB_TYPE_FLOAT => Float32,\n+    DUCKDB_TYPE_DOUBLE => Float64,\n+    DUCKDB_TYPE_DECIMAL => Float64,\n+    DUCKDB_TYPE_DATE => Date,\n+    DUCKDB_TYPE_TIME => Time,\n+    DUCKDB_TYPE_TIMESTAMP => DateTime,\n+    DUCKDB_TYPE_TIMESTAMP_S => DateTime,\n+    DUCKDB_TYPE_TIMESTAMP_MS => DateTime,\n+    DUCKDB_TYPE_TIMESTAMP_NS => DateTime,\n+    DUCKDB_TYPE_INTERVAL => Dates.CompoundPeriod,\n+    DUCKDB_TYPE_UUID => UUID,\n+    DUCKDB_TYPE_VARCHAR => AbstractString,\n+    DUCKDB_TYPE_JSON => AbstractString,\n+    DUCKDB_TYPE_ENUM => AbstractString,\n+    DUCKDB_TYPE_BLOB => Base.CodeUnits{UInt8, String},\n+    DUCKDB_TYPE_MAP => Dict\n+)\n+\n+# convert a DuckDB type into Julia equivalent\n+function duckdb_type_to_internal_type(x::DUCKDB_TYPE)\n+    if !haskey(INTERNAL_TYPE_MAP, x)\n+        throw(NotImplementedException(string(\"Unsupported type for duckdb_type_to_internal_type: \", x)))\n+    end\n+    return INTERNAL_TYPE_MAP[x]\n+end\n+\n+function duckdb_type_to_julia_type(x)\n+    type_id = GetTypeId(x)\n+    if type_id == DUCKDB_TYPE_LIST\n+        return Vector{Union{Missing, duckdb_type_to_julia_type(GetListChildType(x))}}\n+    elseif type_id == DUCKDB_TYPE_STRUCT\n+        child_count = GetStructChildCount(x)\n+        names::Vector{Symbol} = Vector()\n+        for i in 1:child_count\n+            child_name::Symbol = Symbol(GetStructChildName(x, i))\n+            push!(names, child_name)\n+        end\n+        names_tuple = Tuple(x for x in names)\n+        return Union{Missing, NamedTuple{names_tuple}}\n+    end\n+    if !haskey(JULIA_TYPE_MAP, type_id)\n+        throw(NotImplementedException(string(\"Unsupported type for duckdb_type_to_julia_type: \", type_id)))\n+    end\n+    return JULIA_TYPE_MAP[type_id]\n+end\n+\n+const ROUNDING_EPOCH_TO_UNIX_EPOCH_DAYS = 719528\n+const ROUNDING_EPOCH_TO_UNIX_EPOCH_MS = 62167219200000\n+\n+sym(ptr) = ccall(:jl_symbol, Ref{Symbol}, (Ptr{UInt8},), ptr)\ndiff --git a/tools/juliapkg/src/data_chunk.jl b/tools/juliapkg/src/data_chunk.jl\nnew file mode 100644\nindex 000000000000..2fdcbdc4be52\n--- /dev/null\n+++ b/tools/juliapkg/src/data_chunk.jl\n@@ -0,0 +1,62 @@\n+\"\"\"\n+DuckDB data chunk\n+\"\"\"\n+mutable struct DataChunk\n+    handle::duckdb_data_chunk\n+\n+    function DataChunk(handle::duckdb_data_chunk, destroy::Bool)\n+        result = new(handle)\n+        if destroy\n+            finalizer(_destroy_data_chunk, result)\n+        end\n+        return result\n+    end\n+end\n+\n+function GetColumnCount(chunk::DataChunk)\n+    return duckdb_data_chunk_get_column_count(chunk.handle)\n+end\n+\n+function GetSize(chunk::DataChunk)\n+    return duckdb_data_chunk_get_size(chunk.handle)\n+end\n+\n+function SetSize(chunk::DataChunk, size::Int64)\n+    return duckdb_data_chunk_set_size(chunk.handle, size)\n+end\n+\n+function GetVector(chunk::DataChunk, col_idx::Int64)::Vec\n+    if col_idx < 1 || col_idx > GetColumnCount(chunk)\n+        throw(\n+            InvalidInputException(\n+                string(\n+                    \"GetArray column index \",\n+                    col_idx,\n+                    \" out of range, expected value between 1 and \",\n+                    GetColumnCount(chunk)\n+                )\n+            )\n+        )\n+    end\n+    return Vec(duckdb_data_chunk_get_vector(chunk.handle, col_idx))\n+end\n+\n+function GetArray(chunk::DataChunk, col_idx::Int64, ::Type{T})::Vector{T} where {T}\n+    return GetArray(GetVector(chunk, col_idx), T)\n+end\n+\n+function GetValidity(chunk::DataChunk, col_idx::Int64)::ValidityMask\n+    return GetValidity(GetVector(chunk, col_idx))\n+end\n+\n+function AllValid(chunk::DataChunk, col_idx::Int64)\n+    return AllValid(GetVector(chunk, col_idx))\n+end\n+\n+# this is only required when we own the data chunk\n+function _destroy_data_chunk(chunk::DataChunk)\n+    if chunk.handle != C_NULL\n+        duckdb_destroy_data_chunk(chunk.handle)\n+    end\n+    return chunk.handle = C_NULL\n+end\ndiff --git a/tools/juliapkg/src/data_frame_scan.jl b/tools/juliapkg/src/data_frame_scan.jl\nnew file mode 100644\nindex 000000000000..1f5e7d5e21b8\n--- /dev/null\n+++ b/tools/juliapkg/src/data_frame_scan.jl\n@@ -0,0 +1,187 @@\n+using DataFrames\n+\n+mutable struct DFBindInfo\n+    df::DataFrame\n+    result_types::Vector{Type}\n+    scan_functions::Vector{Function}\n+\n+    function DFBindInfo(df::DataFrame, result_types::Vector{Type}, scan_functions::Vector{Function})\n+        return new(df, result_types, scan_functions)\n+    end\n+end\n+\n+function DFResultType(df, entry)\n+    column_type = eltype(df[!, entry])\n+    if typeof(column_type) == Union\n+        # remove Missing type from the union\n+        column_type = Core.Compiler.typesubtract(column_type, Missing, 1)\n+    end\n+    return column_type\n+end\n+\n+function DFJuliaType(column_type)\n+    if column_type == Date\n+        column_type = Int32\n+    elseif column_type == Time\n+        column_type = Int64\n+    elseif column_type == DateTime\n+        column_type = Int64\n+    end\n+    return column_type\n+end\n+\n+ValueToDuckDB(val::T) where {T <: Date} = convert(Int32, Dates.date2epochdays(val) - ROUNDING_EPOCH_TO_UNIX_EPOCH_DAYS)\n+ValueToDuckDB(val::T) where {T <: Time} = convert(Int64, Dates.value(val) / 1000)\n+ValueToDuckDB(val::T) where {T <: DateTime} =\n+    convert(Int64, (Dates.datetime2epochms(val) - ROUNDING_EPOCH_TO_UNIX_EPOCH_MS) * 1000)\n+function ValueToDuckDB(val::T) where {T <: AbstractString}\n+    throw(\n+        NotImplementedException(\n+            \"Cannot use ValueToDuckDB to convert string values - use DuckDB.AssignStringElement on a vector instead\"\n+        )\n+    )\n+end\n+function ValueToDuckDB(val::T) where {T}\n+    return val\n+end\n+\n+function DFScanColumn(\n+    df::DataFrame,\n+    df_offset::Int64,\n+    col_idx::Int64,\n+    scan_count::Int64,\n+    output::DuckDB.DataChunk,\n+    ::Type{T}\n+) where {T}\n+    vector = DuckDB.GetVector(output, col_idx)\n+    result_array::Vector{T} = DuckDB.GetArray(vector, T)\n+    validity = DuckDB.GetValidity(vector)\n+    input_column = df[!, col_idx]\n+    for i in 1:scan_count\n+        if input_column[df_offset + i] === missing\n+            DuckDB.SetInvalid(validity, i)\n+        else\n+            result_array[i] = ValueToDuckDB(input_column[df_offset + i])\n+        end\n+    end\n+end\n+\n+function DFScanStringColumn(\n+    df::DataFrame,\n+    df_offset::Int64,\n+    col_idx::Int64,\n+    scan_count::Int64,\n+    output::DuckDB.DataChunk,\n+    ::Type{T}\n+) where {T}\n+    vector = DuckDB.GetVector(output, col_idx)\n+    validity = DuckDB.GetValidity(vector)\n+    input_column = df[!, col_idx]\n+    for i in 1:scan_count\n+        if input_column[df_offset + i] === missing\n+            DuckDB.SetInvalid(validity, i)\n+        else\n+            DuckDB.AssignStringElement(vector, i, input_column[df_offset + i])\n+        end\n+    end\n+end\n+\n+function DFScanFunction(df, entry)\n+    result_type = DFResultType(df, entry)\n+    if result_type <: AbstractString\n+        return DFScanStringColumn\n+    end\n+    return DFScanColumn\n+end\n+\n+function DFBindFunction(info::DuckDB.BindInfo)\n+    # fetch the df name from the function parameters\n+    parameter = DuckDB.GetParameter(info, 0)\n+    name = DuckDB.GetValue(parameter, String)\n+    # fetch the actual df using the function name\n+    extra_data = DuckDB.GetExtraData(info)\n+    df = extra_data[name]\n+\n+    # register the result columns\n+    result_types::Vector{Type} = Vector()\n+    scan_functions::Vector{Function} = Vector()\n+    for entry in names(df)\n+        result_type = DFResultType(df, entry)\n+        scan_function = DFScanFunction(df, entry)\n+        push!(result_types, DFJuliaType(result_type))\n+        push!(scan_functions, scan_function)\n+\n+        DuckDB.AddResultColumn(info, entry, result_type)\n+    end\n+    return DFBindInfo(df, result_types, scan_functions)\n+end\n+\n+mutable struct DFInitInfo\n+    pos::Int64\n+\n+    function DFInitInfo()\n+        return new(0)\n+    end\n+end\n+\n+function DFInitFunction(info::DuckDB.InitInfo)\n+    return DFInitInfo()\n+end\n+\n+function DFScanFunction(info::DuckDB.FunctionInfo, output::DuckDB.DataChunk)\n+    bind_info = DuckDB.GetBindInfo(info, DFBindInfo)\n+    init_info = DuckDB.GetInitInfo(info, DFInitInfo)\n+\n+    column_count = size(names(bind_info.df), 1)\n+    row_count = size(bind_info.df, 1)\n+    scan_count = DuckDB.VECTOR_SIZE\n+    if init_info.pos + scan_count >= row_count\n+        scan_count = row_count - init_info.pos\n+    end\n+\n+    for col_idx in 1:column_count\n+        bind_info.scan_functions[col_idx](\n+            bind_info.df,\n+            init_info.pos,\n+            col_idx,\n+            scan_count,\n+            output,\n+            bind_info.result_types[col_idx]\n+        )\n+    end\n+    init_info.pos += scan_count\n+    DuckDB.SetSize(output, scan_count)\n+    return\n+end\n+\n+function RegisterDataFrame(con::Connection, df::DataFrame, name::AbstractString)\n+    con.db.data_frames[name] = df\n+    DBInterface.execute(\n+        con,\n+        string(\"CREATE OR REPLACE VIEW \\\"\", name, \"\\\" AS SELECT * FROM julia_df_scan('\", name, \"')\")\n+    )\n+    return\n+end\n+RegisterDataFrame(db::DB, df::DataFrame, name::AbstractString) = RegisterDataFrame(db.main_connection, df, name)\n+\n+function UnregisterDataFrame(con::Connection, name::AbstractString)\n+    pop!(con.db.data_frames, name)\n+    DBInterface.execute(con, string(\"DROP VIEW IF EXISTS \\\"\", name, \"\\\"\"))\n+    return\n+end\n+UnregisterDataFrame(db::DB, name::AbstractString) = UnregisterDataFrame(db.main_connection, name)\n+\n+\n+function AddDataFrameScan(db::DB)\n+    # add the data frame scan function\n+    DuckDB.CreateTableFunction(\n+        db.main_connection,\n+        \"julia_df_scan\",\n+        [String],\n+        DFBindFunction,\n+        DFInitFunction,\n+        DFScanFunction,\n+        db.handle.data_frames\n+    )\n+    return\n+end\ndiff --git a/tools/juliapkg/src/database.jl b/tools/juliapkg/src/database.jl\nnew file mode 100644\nindex 000000000000..61b10664f1a9\n--- /dev/null\n+++ b/tools/juliapkg/src/database.jl\n@@ -0,0 +1,111 @@\n+\"\"\"\n+Internal DuckDB database handle.\n+\"\"\"\n+mutable struct DuckDBHandle\n+    file::String\n+    handle::duckdb_database\n+    functions::Vector{Any}\n+    data_frames::Dict{Any, Any}\n+\n+    function DuckDBHandle(f::AbstractString, config::Config)\n+        f = String(isempty(f) ? f : expanduser(f))\n+        handle = Ref{duckdb_database}()\n+        error = Ref{Ptr{UInt8}}()\n+        if duckdb_open_ext(f, handle, config.handle, error) != DuckDBSuccess\n+            error_message = unsafe_string(error[])\n+            duckdb_free(error[])\n+            throw(ConnectionException(error_message))\n+        end\n+\n+        db = new(f, handle[], Vector(), Dict())\n+        finalizer(_close_database, db)\n+        return db\n+    end\n+end\n+\n+function _close_database(db::DuckDBHandle)\n+    # disconnect from DB\n+    if db.handle != C_NULL\n+        duckdb_close(db.handle)\n+    end\n+    return db.handle = C_NULL\n+end\n+\n+\"\"\"\n+A connection object to a DuckDB database.\n+\n+Transaction contexts are local to a single connection.\n+\n+A connection can only run a single query concurrently.\n+It is possible to open multiple connections to a single DuckDB database instance.\n+Multiple connections can run multiple queries concurrently.\n+\"\"\"\n+mutable struct Connection\n+    db::DuckDBHandle\n+    handle::duckdb_connection\n+\n+    function Connection(db::DuckDBHandle)\n+        handle = Ref{duckdb_connection}()\n+        if duckdb_connect(db.handle, handle) != DuckDBSuccess\n+            throw(ConnectionException(\"Failed to open connection\"))\n+        end\n+        con = new(db, handle[])\n+        finalizer(_close_connection, con)\n+        return con\n+    end\n+end\n+\n+function _close_connection(con::Connection)\n+    # disconnect\n+    if con.handle != C_NULL\n+        duckdb_disconnect(con.handle)\n+    end\n+    con.handle = C_NULL\n+    return\n+end\n+\n+\"\"\"\n+A DuckDB database object.\n+\n+By default a DuckDB database object has an open connection object (db.main_connection).\n+When the database object is used directly in queries, it is actually the underlying main_connection that is used.\n+\n+It is possible to open new connections to a single database instance using DBInterface.connect(db).\n+\"\"\"\n+mutable struct DB <: DBInterface.Connection\n+    handle::DuckDBHandle\n+    main_connection::Connection\n+\n+    function DB(f::AbstractString, config::Config)\n+        handle = DuckDBHandle(f, config)\n+        main_connection = Connection(handle)\n+\n+        db = new(handle, main_connection)\n+        AddDataFrameScan(db)\n+        return db\n+    end\n+    function DB(f::AbstractString)\n+        return DB(f, Config())\n+    end\n+end\n+\n+function close_database(db::DB)\n+    _close_connection(db.main_connection)\n+    _close_database(db.handle)\n+    return\n+end\n+\n+const VECTOR_SIZE = duckdb_vector_size()\n+\n+DB() = DB(\":memory:\")\n+DBInterface.connect(::Type{DB}) = DB()\n+DBInterface.connect(::Type{DB}, f::AbstractString) = DB(f)\n+DBInterface.connect(::Type{DB}, f::AbstractString, config::Config) = DB(f, config)\n+DBInterface.connect(db::DB) = Connection(db.handle)\n+DBInterface.close!(db::DB) = close_database(db)\n+DBInterface.close!(con::Connection) = _close_connection(con)\n+Base.close(db::DB) = close_database(db)\n+Base.isopen(db::DB) = db.handle != C_NULL\n+\n+Base.show(io::IO, db::DuckDB.DB) = print(io, string(\"DuckDB.DB(\", \"\\\"$(db.handle.file)\\\"\", \")\"))\n+Base.show(io::IO, con::DuckDB.Connection) = print(io, string(\"DuckDB.Connection(\", \"\\\"$(con.db.file)\\\"\", \")\"))\ndiff --git a/tools/juliapkg/src/ddl.jl b/tools/juliapkg/src/ddl.jl\nnew file mode 100644\nindex 000000000000..0a18986ad27d\n--- /dev/null\n+++ b/tools/juliapkg/src/ddl.jl\n@@ -0,0 +1,5 @@\n+\n+function drop!(db::DB, table::AbstractString; ifexists::Bool = false)\n+    exists = ifexists ? \"IF EXISTS\" : \"\"\n+    return execute(db, \"DROP TABLE $exists $(esc_id(table))\")\n+end\ndiff --git a/tools/juliapkg/src/exceptions.jl b/tools/juliapkg/src/exceptions.jl\nnew file mode 100644\nindex 000000000000..0d982633d996\n--- /dev/null\n+++ b/tools/juliapkg/src/exceptions.jl\n@@ -0,0 +1,17 @@\n+mutable struct ConnectionException <: Exception\n+    var::String\n+end\n+mutable struct QueryException <: Exception\n+    var::String\n+end\n+mutable struct NotImplementedException <: Exception\n+    var::String\n+end\n+mutable struct InvalidInputException <: Exception\n+    var::String\n+end\n+\n+Base.showerror(io::IO, e::ConnectionException) = print(io, e.var)\n+Base.showerror(io::IO, e::QueryException) = print(io, e.var)\n+Base.showerror(io::IO, e::NotImplementedException) = print(io, e.var)\n+Base.showerror(io::IO, e::InvalidInputException) = print(io, e.var)\ndiff --git a/tools/juliapkg/src/helper.jl b/tools/juliapkg/src/helper.jl\nnew file mode 100644\nindex 000000000000..20f6e790c034\n--- /dev/null\n+++ b/tools/juliapkg/src/helper.jl\n@@ -0,0 +1,5 @@\n+\n+function esc_id end\n+\n+esc_id(x::AbstractString) = \"\\\"\" * replace(x, \"\\\"\" => \"\\\"\\\"\") * \"\\\"\"\n+esc_id(X::AbstractVector{S}) where {S <: AbstractString} = join(map(esc_id, X), ',')\ndiff --git a/tools/juliapkg/src/logical_type.jl b/tools/juliapkg/src/logical_type.jl\nnew file mode 100644\nindex 000000000000..366f9b4da7d5\n--- /dev/null\n+++ b/tools/juliapkg/src/logical_type.jl\n@@ -0,0 +1,96 @@\n+\"\"\"\n+DuckDB type\n+\"\"\"\n+mutable struct LogicalType\n+    handle::duckdb_logical_type\n+\n+    function LogicalType(type::DUCKDB_TYPE)\n+        handle = duckdb_create_logical_type(type)\n+        result = new(handle)\n+        finalizer(_destroy_type, result)\n+        return result\n+    end\n+    function LogicalType(handle::duckdb_logical_type)\n+        result = new(handle)\n+        finalizer(_destroy_type, result)\n+        return result\n+    end\n+end\n+\n+function _destroy_type(type::LogicalType)\n+    if type.handle != C_NULL\n+        duckdb_destroy_logical_type(type.handle)\n+    end\n+    type.handle = C_NULL\n+    return\n+end\n+\n+CreateLogicalType(::Type{T}) where {T <: String} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_VARCHAR)\n+CreateLogicalType(::Type{T}) where {T <: Bool} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_BOOLEAN)\n+CreateLogicalType(::Type{T}) where {T <: Int8} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_TINYINT)\n+CreateLogicalType(::Type{T}) where {T <: Int16} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_SMALLINT)\n+CreateLogicalType(::Type{T}) where {T <: Int32} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_INTEGER)\n+CreateLogicalType(::Type{T}) where {T <: Int64} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_BIGINT)\n+CreateLogicalType(::Type{T}) where {T <: UInt8} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_UTINYINT)\n+CreateLogicalType(::Type{T}) where {T <: UInt16} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_USMALLINT)\n+CreateLogicalType(::Type{T}) where {T <: UInt32} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_UINTEGER)\n+CreateLogicalType(::Type{T}) where {T <: UInt64} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_UBIGINT)\n+CreateLogicalType(::Type{T}) where {T <: Float32} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_FLOAT)\n+CreateLogicalType(::Type{T}) where {T <: Float64} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_DOUBLE)\n+CreateLogicalType(::Type{T}) where {T <: Date} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_DATE)\n+CreateLogicalType(::Type{T}) where {T <: Time} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_TIME)\n+CreateLogicalType(::Type{T}) where {T <: DateTime} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_TIMESTAMP)\n+CreateLogicalType(::Type{T}) where {T <: AbstractString} = DuckDB.LogicalType(DuckDB.DUCKDB_TYPE_VARCHAR)\n+\n+function CreateLogicalType(::Type{T}) where {T}\n+    throw(NotImplementedException(\"Unsupported type for CreateLogicalType\"))\n+end\n+\n+function GetTypeId(type::LogicalType)\n+    return duckdb_get_type_id(type.handle)\n+end\n+\n+function GetInternalTypeId(type::LogicalType)\n+    type_id = GetTypeId(type)\n+    if type_id == DUCKDB_TYPE_DECIMAL\n+        type_id = duckdb_decimal_internal_type(type.handle)\n+    elseif type_id == DUCKDB_TYPE_ENUM\n+        type_id = duckdb_enum_internal_type(type.handle)\n+    end\n+    return type_id\n+end\n+\n+function GetDecimalScale(type::LogicalType)\n+    return duckdb_decimal_scale(type.handle)\n+end\n+\n+function GetEnumDictionary(type::LogicalType)\n+    dict::Vector{String} = Vector{String}()\n+    dict_size = duckdb_enum_dictionary_size(type.handle)\n+    for i in 1:dict_size\n+        val = duckdb_enum_dictionary_value(type.handle, i)\n+        str_val = String(unsafe_string(val))\n+        push!(dict, str_val)\n+        duckdb_free(val)\n+    end\n+    return dict\n+end\n+\n+function GetListChildType(type::LogicalType)\n+    return LogicalType(duckdb_list_type_child_type(type.handle))\n+end\n+\n+function GetStructChildCount(type::LogicalType)\n+    return duckdb_struct_type_child_count(type.handle)\n+end\n+\n+function GetStructChildName(type::LogicalType, index::UInt64)\n+    val = duckdb_struct_type_child_name(type.handle, index)\n+    result = unsafe_string(val)\n+    duckdb_free(val)\n+    return result\n+end\n+\n+function GetStructChildType(type::LogicalType, index::UInt64)\n+    return LogicalType(duckdb_struct_type_child_type(type.handle, index))\n+end\ndiff --git a/tools/juliapkg/src/old_interface.jl b/tools/juliapkg/src/old_interface.jl\nnew file mode 100644\nindex 000000000000..89c887db3b6d\n--- /dev/null\n+++ b/tools/juliapkg/src/old_interface.jl\n@@ -0,0 +1,21 @@\n+# old interface, deprecated\n+using DataFrames\n+\n+open(dbpath::AbstractString) = DBInterface.connect(DuckDB.DB, dbpath)\n+\n+connect(db::DB) = DBInterface.connect(db)\n+\n+disconnect(con::Connection) = DBInterface.close!(con)\n+close(db::DB) = DBInterface.close!(db)\n+\n+toDataFrame(res::QueryResult) = res.df\n+toDataFrame(con::Connection, sql::AbstractString) = toDataFrame(DBInterface.execute(con, sql))\n+\n+function appendDataFrame(input_df::DataFrame, con::Connection, table::AbstractString, schema::String = \"main\")\n+    RegisterDataFrame(con, input_df, \"__append_df\")\n+    DBInterface.execute(con, \"INSERT INTO \\\"$schema\\\".\\\"$table\\\" SELECT * FROM __append_df\")\n+    return UnregisterDataFrame(con, \"__append_df\")\n+end\n+\n+appendDataFrame(input_df::DataFrame, db::DB, table::AbstractString, schema::String = \"main\") =\n+    appendDataFrame(input_df, db.main_connection, table, schema)\ndiff --git a/tools/juliapkg/src/replacement_scan.jl b/tools/juliapkg/src/replacement_scan.jl\nnew file mode 100644\nindex 000000000000..9070b149f438\n--- /dev/null\n+++ b/tools/juliapkg/src/replacement_scan.jl\n@@ -0,0 +1,67 @@\n+\n+\n+mutable struct ReplacementFunction\n+    db::DB\n+    replacement_func::Function\n+    extra_data::Any\n+end\n+\n+struct ReplacementFunctionInfo\n+    handle::duckdb_replacement_scan_info\n+    main_function::ReplacementFunction\n+    table_name::String\n+\n+    function ReplacementFunctionInfo(\n+        handle::duckdb_replacement_scan_info,\n+        main_function::ReplacementFunction,\n+        table_name::String\n+    )\n+        result = new(handle, main_function, table_name)\n+        return result\n+    end\n+end\n+\n+function _replacement_scan_function(handle::duckdb_replacement_scan_info, table_name::Ptr{UInt8}, data::Ptr{Cvoid})\n+    func::ReplacementFunction = unsafe_pointer_to_objref(data)\n+    tname = unsafe_string(table_name)\n+    info = ReplacementFunctionInfo(handle, func, tname)\n+    func.replacement_func(info)\n+    return\n+end\n+\n+function GetDB(info::ReplacementFunctionInfo)\n+    return info.main_function.db\n+end\n+\n+function GetExtraData(info::ReplacementFunctionInfo)\n+    return info.main_function.extra_data\n+end\n+\n+function GetTableName(info::ReplacementFunctionInfo)\n+    return info.table_name\n+end\n+\n+function SetFunctionName(info::ReplacementFunctionInfo, function_name::String)\n+    return duckdb_replacement_scan_set_function_name(info.handle, function_name)\n+end\n+\n+function AddFunctionParameter(info::ReplacementFunctionInfo, parameter::Value)\n+    return duckdb_replacement_scan_add_parameter(info.handle, parameter.handle)\n+end\n+\n+function _replacement_func_cleanup(data::Ptr{Cvoid})\n+    info::ReplacementFunction = unsafe_pointer_to_objref(data)\n+    delete!(global_objects, info)\n+    return\n+end\n+\n+function AddReplacementScan(db::DB, replacement_func::Function, extra_data::Any)\n+    func = ReplacementFunction(db, replacement_func, extra_data)\n+    push!(global_objects, func)\n+    return duckdb_add_replacement_scan(\n+        db.handle.handle,\n+        @cfunction(_replacement_scan_function, Cvoid, (duckdb_replacement_scan_info, Ptr{UInt8}, Ptr{Cvoid})),\n+        pointer_from_objref(func),\n+        @cfunction(_replacement_func_cleanup, Cvoid, (Ptr{Cvoid},))\n+    )\n+end\ndiff --git a/tools/juliapkg/src/result.jl b/tools/juliapkg/src/result.jl\nnew file mode 100644\nindex 000000000000..6461224f9b05\n--- /dev/null\n+++ b/tools/juliapkg/src/result.jl\n@@ -0,0 +1,596 @@\n+\n+mutable struct QueryResult\n+    handle::Ref{duckdb_result}\n+    df::DataFrame\n+\n+    function QueryResult(handle::Ref{duckdb_result})\n+        df = toDataFrame(handle)\n+\n+        result = new(handle, df)\n+        finalizer(_close_result, result)\n+        return result\n+    end\n+end\n+\n+function _close_result(result::QueryResult)\n+    return duckdb_destroy_result(result.handle)\n+end\n+\n+mutable struct ColumnConversionData\n+    chunks::Vector{DataChunk}\n+    col_idx::Int64\n+    logical_type::LogicalType\n+    conversion_data::Any\n+end\n+\n+mutable struct ListConversionData\n+    conversion_func::Function\n+    conversion_loop_func::Function\n+    child_type::LogicalType\n+    internal_type::Type\n+    target_type::Type\n+    child_conversion_data::Any\n+end\n+\n+mutable struct StructConversionData\n+    tuple_type::Any\n+    child_conversion_data::Vector{ListConversionData}\n+end\n+\n+function nop_convert(column_data::ColumnConversionData, val)\n+    return val\n+end\n+\n+function convert_string(column_data::ColumnConversionData, val::Ptr{Cvoid}, idx::UInt64)\n+    base_ptr = val + (idx - 1) * sizeof(duckdb_string_t)\n+    length_ptr = Base.unsafe_convert(Ptr{Int32}, base_ptr)\n+    length = unsafe_load(length_ptr)\n+    if length <= STRING_INLINE_LENGTH\n+        prefix_ptr = Base.unsafe_convert(Ptr{UInt8}, base_ptr + sizeof(Int32))\n+        return unsafe_string(prefix_ptr, length)\n+    else\n+        ptr_ptr = Base.unsafe_convert(Ptr{Ptr{UInt8}}, base_ptr + sizeof(Int32) * 2)\n+        data_ptr = Base.unsafe_load(ptr_ptr)\n+        return unsafe_string(data_ptr, length)\n+    end\n+end\n+\n+function convert_blob(column_data::ColumnConversionData, val::Ptr{Cvoid}, idx::UInt64)::Base.CodeUnits{UInt8, String}\n+    return Base.codeunits(convert_string(column_data, val, idx))\n+end\n+\n+function convert_date(column_data::ColumnConversionData, val::Int32)::Date\n+    return Dates.epochdays2date(val + ROUNDING_EPOCH_TO_UNIX_EPOCH_DAYS)\n+end\n+\n+function convert_time(column_data::ColumnConversionData, val::Int64)::Time\n+    return Dates.Time(Dates.Nanosecond(val * 1000))\n+end\n+\n+function convert_timestamp(column_data::ColumnConversionData, val::Int64)::DateTime\n+    return Dates.epochms2datetime((val \u00f7 1000) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)\n+end\n+\n+function convert_timestamp_s(column_data::ColumnConversionData, val::Int64)::DateTime\n+    return Dates.epochms2datetime((val * 1000) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)\n+end\n+\n+function convert_timestamp_ms(column_data::ColumnConversionData, val::Int64)::DateTime\n+    return Dates.epochms2datetime((val) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)\n+end\n+\n+function convert_timestamp_ns(column_data::ColumnConversionData, val::Int64)::DateTime\n+    return Dates.epochms2datetime((val \u00f7 1000000) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)\n+end\n+\n+function convert_interval(column_data::ColumnConversionData, val::duckdb_interval)::Dates.CompoundPeriod\n+    return Dates.CompoundPeriod(Dates.Month(val.months), Dates.Day(val.days), Dates.Microsecond(val.micros))\n+end\n+\n+function convert_hugeint(column_data::ColumnConversionData, val::duckdb_hugeint)::Int128\n+    return Int128(val.lower) + Int128(val.upper) << 64\n+end\n+\n+function convert_uuid(column_data::ColumnConversionData, val::duckdb_hugeint)::UUID\n+    hugeint = convert_hugeint(column_data, val)\n+    base_value = Int128(170141183460469231731687303715884105727)\n+    if hugeint < 0\n+        return UUID(UInt128(hugeint + base_value) + 1)\n+    else\n+        return UUID(UInt128(hugeint) + base_value + 1)\n+    end\n+end\n+\n+function convert_enum(column_data::ColumnConversionData, val)::String\n+    return column_data.conversion_data[val + 1]\n+end\n+\n+function convert_decimal_hugeint(column_data::ColumnConversionData, val::duckdb_hugeint)::Float64\n+    return convert_hugeint(column_data, val) / column_data.conversion_data\n+end\n+\n+function convert_decimal(column_data::ColumnConversionData, val)::Float64\n+    return val / column_data.conversion_data\n+end\n+\n+function convert_vector(\n+    column_data::ColumnConversionData,\n+    vector::Vec,\n+    size::UInt64,\n+    convert_func::Function,\n+    result,\n+    position,\n+    all_valid,\n+    ::Type{SRC},\n+    ::Type{DST}\n+) where {SRC, DST}\n+    array = GetArray(vector, SRC)\n+    if !all_valid\n+        validity = GetValidity(vector)\n+    end\n+    for i in 1:size\n+        if all_valid || IsValid(validity, i)\n+            result[position] = convert_func(column_data, array[i])\n+        end\n+        position += 1\n+    end\n+    return size\n+end\n+\n+function convert_vector_string(\n+    column_data::ColumnConversionData,\n+    vector::Vec,\n+    size::UInt64,\n+    convert_func::Function,\n+    result,\n+    position,\n+    all_valid,\n+    ::Type{SRC},\n+    ::Type{DST}\n+) where {SRC, DST}\n+    raw_ptr = duckdb_vector_get_data(vector.handle)\n+    ptr = Base.unsafe_convert(Ptr{duckdb_string_t}, raw_ptr)\n+    if !all_valid\n+        validity = GetValidity(vector)\n+    end\n+    for i in 1:size\n+        if all_valid || IsValid(validity, i)\n+            result[position] = convert_func(column_data, raw_ptr, i)\n+        end\n+        position += 1\n+    end\n+    return size\n+end\n+\n+function convert_vector_list(\n+    column_data::ColumnConversionData,\n+    vector::Vec,\n+    size::UInt64,\n+    convert_func::Function,\n+    result,\n+    position,\n+    all_valid,\n+    ::Type{SRC},\n+    ::Type{DST}\n+) where {SRC, DST}\n+    child_vector = ListChild(vector)\n+    list_size = ListSize(vector)\n+\n+    # convert the child vector\n+    ldata = column_data.conversion_data\n+\n+    child_column_data =\n+        ColumnConversionData(column_data.chunks, column_data.col_idx, ldata.child_type, ldata.child_conversion_data)\n+    child_array = Array{Union{Missing, ldata.target_type}}(missing, list_size)\n+    ldata.conversion_loop_func(\n+        child_column_data,\n+        child_vector,\n+        list_size,\n+        ldata.conversion_func,\n+        child_array,\n+        1,\n+        false,\n+        ldata.internal_type,\n+        ldata.target_type\n+    )\n+\n+    array = GetArray(vector, SRC)\n+    if !all_valid\n+        validity = GetValidity(vector)\n+    end\n+    for i in 1:size\n+        if all_valid || IsValid(validity, i)\n+            start_offset::UInt64 = array[i].offset + 1\n+            end_offset::UInt64 = array[i].offset + array[i].length\n+            result[position] = child_array[start_offset:end_offset]\n+        end\n+        position += 1\n+    end\n+    return size\n+end\n+\n+function convert_struct_children(column_data::ColumnConversionData, vector::Vec, size::UInt64)\n+    # convert the child vectors of the struct\n+    child_count = GetStructChildCount(column_data.logical_type)\n+    child_arrays = Vector()\n+    for i in 1:child_count\n+        child_vector = StructChild(vector, i)\n+        ldata = column_data.conversion_data.child_conversion_data[i]\n+\n+        child_column_data =\n+            ColumnConversionData(column_data.chunks, column_data.col_idx, ldata.child_type, ldata.child_conversion_data)\n+        child_array = Array{Union{Missing, ldata.target_type}}(missing, size)\n+        ldata.conversion_loop_func(\n+            child_column_data,\n+            child_vector,\n+            size,\n+            ldata.conversion_func,\n+            child_array,\n+            1,\n+            false,\n+            ldata.internal_type,\n+            ldata.target_type\n+        )\n+        push!(child_arrays, child_array)\n+    end\n+    return child_arrays\n+end\n+\n+\n+function convert_vector_struct(\n+    column_data::ColumnConversionData,\n+    vector::Vec,\n+    size::UInt64,\n+    convert_func::Function,\n+    result,\n+    position,\n+    all_valid,\n+    ::Type{SRC},\n+    ::Type{DST}\n+) where {SRC, DST}\n+    child_count = GetStructChildCount(column_data.logical_type)\n+    child_arrays = convert_struct_children(column_data, vector, size)\n+\n+    if !all_valid\n+        validity = GetValidity(vector)\n+    end\n+    for i in 1:size\n+        if all_valid || IsValid(validity, i)\n+            result_tuple = Vector()\n+            for child_idx in 1:child_count\n+                push!(result_tuple, child_arrays[child_idx][i])\n+            end\n+            result[position] = NamedTuple{column_data.conversion_data.tuple_type}(result_tuple)\n+        end\n+        position += 1\n+    end\n+    return size\n+end\n+\n+function convert_vector_map(\n+    column_data::ColumnConversionData,\n+    vector::Vec,\n+    size::UInt64,\n+    convert_func::Function,\n+    result,\n+    position,\n+    all_valid,\n+    ::Type{SRC},\n+    ::Type{DST}\n+) where {SRC, DST}\n+    child_arrays = convert_struct_children(column_data, vector, size)\n+    keys = child_arrays[1]\n+    values = child_arrays[2]\n+\n+    if !all_valid\n+        validity = GetValidity(vector)\n+    end\n+    for i in 1:size\n+        if all_valid || IsValid(validity, i)\n+            result_dict = Dict()\n+            key_count = length(keys[i])\n+            for key_idx in 1:key_count\n+                result_dict[keys[i][key_idx]] = values[i][key_idx]\n+            end\n+            result[position] = result_dict\n+        end\n+        position += 1\n+    end\n+    return size\n+end\n+\n+function convert_column_loop(\n+    column_data::ColumnConversionData,\n+    convert_func::Function,\n+    ::Type{SRC},\n+    ::Type{DST},\n+    convert_vector_func::Function\n+) where {SRC, DST}\n+    # first check if there are null values in any chunks\n+    has_missing = false\n+    row_count = 0\n+    for chunk in column_data.chunks\n+        if !AllValid(chunk, column_data.col_idx)\n+            has_missing = true\n+        end\n+        row_count += GetSize(chunk)\n+    end\n+    if has_missing\n+        # missing values\n+        result = Array{Union{Missing, DST}}(missing, row_count)\n+        position = 1\n+        for chunk in column_data.chunks\n+            position += convert_vector_func(\n+                column_data,\n+                GetVector(chunk, column_data.col_idx),\n+                GetSize(chunk),\n+                convert_func,\n+                result,\n+                position,\n+                AllValid(chunk, column_data.col_idx),\n+                SRC,\n+                DST\n+            )\n+        end\n+    else\n+        # no missing values\n+        result = Array{DST}(undef, row_count)\n+        position = 1\n+        for chunk in column_data.chunks\n+            position += convert_vector_func(\n+                column_data,\n+                GetVector(chunk, column_data.col_idx),\n+                GetSize(chunk),\n+                convert_func,\n+                result,\n+                position,\n+                true,\n+                SRC,\n+                DST\n+            )\n+        end\n+    end\n+    return result\n+end\n+\n+function create_child_conversion_data(child_type::LogicalType)\n+    internal_type_id = GetInternalTypeId(child_type)\n+    internal_type = duckdb_type_to_internal_type(internal_type_id)\n+    target_type = duckdb_type_to_julia_type(child_type)\n+\n+    conversion_func = get_conversion_function(child_type)\n+    conversion_loop_func = get_conversion_loop_function(child_type)\n+    child_conversion_data = init_conversion_loop(child_type)\n+    return ListConversionData(\n+        conversion_func,\n+        conversion_loop_func,\n+        child_type,\n+        internal_type,\n+        target_type,\n+        child_conversion_data\n+    )\n+end\n+\n+function init_conversion_loop(logical_type::LogicalType)\n+    type = GetTypeId(logical_type)\n+    if type == DUCKDB_TYPE_DECIMAL\n+        return 10^GetDecimalScale(logical_type)\n+    elseif type == DUCKDB_TYPE_ENUM\n+        return GetEnumDictionary(logical_type)\n+    elseif type == DUCKDB_TYPE_LIST\n+        child_type = GetListChildType(logical_type)\n+        return create_child_conversion_data(child_type)\n+    elseif type == DUCKDB_TYPE_STRUCT || type == DUCKDB_TYPE_MAP\n+        child_count = GetStructChildCount(logical_type)\n+        child_symbols::Vector{Symbol} = Vector()\n+        child_data::Vector{ListConversionData} = Vector()\n+        for i in 1:child_count\n+            child_symbol = Symbol(GetStructChildName(logical_type, i))\n+            child_type = GetStructChildType(logical_type, i)\n+            child_conv_data = create_child_conversion_data(child_type)\n+            push!(child_symbols, child_symbol)\n+            push!(child_data, child_conv_data)\n+        end\n+        return StructConversionData(Tuple(x for x in child_symbols), child_data)\n+    else\n+        return nothing\n+    end\n+end\n+\n+function get_conversion_function(logical_type::LogicalType)::Function\n+    type = GetTypeId(logical_type)\n+    if type == DUCKDB_TYPE_VARCHAR || type == DUCKDB_TYPE_JSON\n+        return convert_string\n+    elseif type == DUCKDB_TYPE_BLOB\n+        return convert_blob\n+    elseif type == DUCKDB_TYPE_DATE\n+        return convert_date\n+    elseif type == DUCKDB_TYPE_TIME\n+        return convert_time\n+    elseif type == DUCKDB_TYPE_TIMESTAMP\n+        return convert_timestamp\n+    elseif type == DUCKDB_TYPE_TIMESTAMP_S\n+        return convert_timestamp_s\n+    elseif type == DUCKDB_TYPE_TIMESTAMP_MS\n+        return convert_timestamp_ms\n+    elseif type == DUCKDB_TYPE_TIMESTAMP_NS\n+        return convert_timestamp_ns\n+    elseif type == DUCKDB_TYPE_INTERVAL\n+        return convert_interval\n+    elseif type == DUCKDB_TYPE_HUGEINT\n+        return convert_hugeint\n+    elseif type == DUCKDB_TYPE_UUID\n+        return convert_uuid\n+    elseif type == DUCKDB_TYPE_DECIMAL\n+        internal_type_id = GetInternalTypeId(logical_type)\n+        if internal_type_id == DUCKDB_TYPE_HUGEINT\n+            return convert_decimal_hugeint\n+        else\n+            return convert_decimal\n+        end\n+    elseif type == DUCKDB_TYPE_ENUM\n+        return convert_enum\n+    else\n+        return nop_convert\n+    end\n+end\n+\n+function get_conversion_loop_function(logical_type::LogicalType)::Function\n+    type = GetTypeId(logical_type)\n+    if type == DUCKDB_TYPE_VARCHAR || type == DUCKDB_TYPE_BLOB || type == DUCKDB_TYPE_JSON\n+        return convert_vector_string\n+    elseif type == DUCKDB_TYPE_LIST\n+        return convert_vector_list\n+    elseif type == DUCKDB_TYPE_STRUCT\n+        return convert_vector_struct\n+    elseif type == DUCKDB_TYPE_MAP\n+        return convert_vector_map\n+    else\n+        return convert_vector\n+    end\n+end\n+\n+function convert_column(column_data::ColumnConversionData)\n+    internal_type_id = GetInternalTypeId(column_data.logical_type)\n+    internal_type = duckdb_type_to_internal_type(internal_type_id)\n+    target_type = duckdb_type_to_julia_type(column_data.logical_type)\n+\n+    conversion_func = get_conversion_function(column_data.logical_type)\n+    conversion_loop_func = get_conversion_loop_function(column_data.logical_type)\n+\n+    column_data.conversion_data = init_conversion_loop(column_data.logical_type)\n+    return convert_column_loop(column_data, conversion_func, internal_type, target_type, conversion_loop_func)\n+end\n+\n+function toDataFrame(result::Ref{duckdb_result})::DataFrame\n+    column_count = duckdb_column_count(result)\n+    # duplicate eliminate the names\n+    names = Vector{Symbol}(undef, column_count)\n+    for i in 1:column_count\n+        name = sym(duckdb_column_name(result, i))\n+        if name in view(names, 1:(i - 1))\n+            j = 1\n+            new_name = Symbol(name, :_, j)\n+            while new_name in view(names, 1:(i - 1))\n+                j += 1\n+                new_name = Symbol(name, :_, j)\n+            end\n+            name = new_name\n+        end\n+        names[i] = name\n+    end\n+    # gather all the data chunks\n+    chunk_count = duckdb_result_chunk_count(result[])\n+    chunks::Vector{DataChunk} = []\n+    for i in 1:chunk_count\n+        push!(chunks, DataChunk(duckdb_result_get_chunk(result[], i), true))\n+    end\n+\n+    df = DataFrame()\n+    for i in 1:column_count\n+        name = names[i]\n+        logical_type = LogicalType(duckdb_column_logical_type(result, i))\n+        column_data = ColumnConversionData(chunks, i, logical_type, nothing)\n+        df[!, name] = convert_column(column_data)\n+    end\n+    return df\n+end\n+\n+function execute(stmt::Stmt, params::DBInterface.StatementParams = ())\n+    BindParameters(stmt, params)\n+\n+    handle = Ref{duckdb_result}()\n+    if duckdb_execute_prepared(stmt.handle, handle) != DuckDBSuccess\n+        error_ptr = duckdb_result_error(handle)\n+        if error_ptr == C_NULL\n+            error_message = string(\"Execute of query \\\"\", stmt.sql, \"\\\" failed: unknown error\")\n+        else\n+            error_message = string(\"Execute of query \\\"\", stmt.sql, \"\\\" failed: \", unsafe_string(error_ptr))\n+        end\n+        duckdb_destroy_result(handle)\n+        throw(QueryException(error_message))\n+    end\n+    return QueryResult(handle)\n+end\n+\n+# explicitly close prepared statement\n+function DBInterface.close!(stmt::Stmt)\n+    return _close_stmt(stmt)\n+end\n+\n+function execute(con::Connection, sql::AbstractString, params::DBInterface.StatementParams)\n+    stmt = Stmt(con, sql)\n+    try\n+        return execute(stmt, params)\n+    finally\n+        _close_stmt(stmt) # immediately close, don't wait for GC\n+    end\n+end\n+\n+execute(con::Connection, sql::AbstractString; kwargs...) = execute(con, sql, values(kwargs))\n+execute(db::DB, sql::AbstractString, params::DBInterface.StatementParams) = execute(db.main_connection, sql, params)\n+execute(db::DB, sql::AbstractString; kwargs...) = execute(db.main_connection, sql, values(kwargs))\n+\n+Tables.isrowtable(::Type{QueryResult}) = true\n+Tables.columnnames(q::QueryResult) = Tables.columnnames(q.df)\n+\n+function Tables.schema(q::QueryResult)\n+    return Tables.schema(q.df)\n+end\n+\n+Base.IteratorSize(::Type{QueryResult}) = Base.SizeUnknown()\n+Base.eltype(q::QueryResult) = Any\n+\n+function DBInterface.close!(q::QueryResult)\n+    return _close_result(q)\n+end\n+\n+function Base.iterate(q::QueryResult)\n+    return Base.iterate(eachrow(q.df))\n+end\n+\n+function Base.iterate(q::QueryResult, state)\n+    return Base.iterate(eachrow(q.df), state)\n+end\n+\n+DataFrames.DataFrame(q::QueryResult) = DataFrame(q.df)\n+\n+\"Return the last row insert id from the executed statement\"\n+function DBInterface.lastrowid(con::Connection)\n+    throw(NotImplementedException(\"Unimplemented: lastrowid\"))\n+end\n+\n+DBInterface.lastrowid(db::DB) = DBInterface.lastrowid(db.main_connection)\n+\n+\"\"\"\n+    DBInterface.prepare(db::DuckDB.DB, sql::AbstractString)\n+\n+Prepare an SQL statement given as a string in the DuckDB database; returns a `DuckDB.Stmt` object.\n+See `DBInterface.execute`(@ref) for information on executing a prepared statement and passing parameters to bind.\n+A `DuckDB.Stmt` object can be closed (resources freed) using `DBInterface.close!`(@ref).\n+\"\"\"\n+DBInterface.prepare(con::Connection, sql::AbstractString) = Stmt(con, sql)\n+DBInterface.prepare(db::DB, sql::AbstractString) = DBInterface.prepare(db.main_connection, sql)\n+\n+\"\"\"\n+    DBInterface.execute(db::DuckDB.DB, sql::String, [params])\n+    DBInterface.execute(stmt::SQLite.Stmt, [params])\n+\n+Bind any positional (`params` as `Vector` or `Tuple`) or named (`params` as `NamedTuple` or `Dict`) parameters to an SQL statement, given by `db` and `sql` or\n+as an already prepared statement `stmt`, execute the query and return an iterator of result rows.\n+\n+Note that the returned result row iterator only supports a single-pass, forward-only iteration of the result rows.\n+Calling `SQLite.reset!(result)` will re-execute the query and reset the iterator back to the beginning.\n+\n+The resultset iterator supports the [Tables.jl](https://github.com/JuliaData/Tables.jl) interface, so results can be collected in any Tables.jl-compatible sink,\n+like `DataFrame(results)`, `CSV.write(\"results.csv\", results)`, etc.\n+\"\"\"\n+function DBInterface.execute(stmt::Stmt, params::DBInterface.StatementParams)\n+    return execute(stmt, params)\n+end\n+\n+function DBInterface.execute(con::Connection, sql::AbstractString)\n+    return execute(Stmt(con, sql))\n+end\n+\n+Base.show(io::IO, result::DuckDB.QueryResult) = print(io, result.df)\ndiff --git a/tools/juliapkg/src/statement.jl b/tools/juliapkg/src/statement.jl\nnew file mode 100644\nindex 000000000000..e737b1aa463c\n--- /dev/null\n+++ b/tools/juliapkg/src/statement.jl\n@@ -0,0 +1,68 @@\n+mutable struct Stmt <: DBInterface.Statement\n+    con::Connection\n+    handle::duckdb_prepared_statement\n+    sql::AbstractString\n+\n+    function Stmt(con::Connection, sql::AbstractString)\n+        handle = Ref{duckdb_prepared_statement}()\n+        if duckdb_prepare(con.handle, sql, handle) != DuckDBSuccess\n+            error_message = unsafe_string(duckdb_prepare_error(handle))\n+            duckdb_destroy_prepare(handle)\n+            throw(QueryException(error_message))\n+        end\n+        stmt = new(con, handle[], sql)\n+        finalizer(_close_stmt, stmt)\n+        return stmt\n+    end\n+\n+    function Stmt(db::DB, sql::AbstractString)\n+        return Stmt(db.main_connection, sql)\n+    end\n+end\n+\n+function _close_stmt(stmt::Stmt)\n+    if stmt.handle != C_NULL\n+        duckdb_destroy_prepare(stmt.handle)\n+    end\n+    stmt.handle = C_NULL\n+    return\n+end\n+\n+DBInterface.getconnection(stmt::Stmt) = stmt.con\n+\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::AbstractFloat) = duckdb_bind_double(stmt.handle, i, Float64(val));\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Bool) = duckdb_bind_boolean(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Int8) = duckdb_bind_int8(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Int16) = duckdb_bind_int16(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Int32) = duckdb_bind_int32(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Int64) = duckdb_bind_int64(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::UInt8) = duckdb_bind_uint8(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::UInt16) = duckdb_bind_uint16(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::UInt32) = duckdb_bind_uint32(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::UInt64) = duckdb_bind_uint64(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Float32) = duckdb_bind_float(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Float64) = duckdb_bind_double(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Date) = duckdb_bind_date(stmt.handle, i, ValueToDuckDB(val));\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Time) = duckdb_bind_time(stmt.handle, i, ValueToDuckDB(val));\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::DateTime) = duckdb_bind_timestamp(stmt.handle, i, ValueToDuckDB(val));\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Missing) = duckdb_bind_null(stmt.handle, i);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Nothing) = duckdb_bind_null(stmt.handle, i);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::AbstractString) = duckdb_bind_varchar(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::Vector{UInt8}) = duckdb_bind_blob(stmt.handle, i, val, sizeof(val));\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::WeakRefString{UInt8}) =\n+    duckdb_bind_varchar(stmt.handle, i, val.ptr, val.len);\n+\n+function duckdb_bind_internal(stmt::Stmt, i::Integer, val::Any)\n+    println(val)\n+    throw(NotImplementedException(\"unsupported type for bind\"))\n+end\n+\n+function BindParameters(stmt::Stmt, params::DBInterface.StatementParams)\n+    i = 1\n+    for param in params\n+        if duckdb_bind_internal(stmt, i, param) != DuckDBSuccess\n+            throw(QueryException(\"Failed to bind parameter\"))\n+        end\n+        i += 1\n+    end\n+end\ndiff --git a/tools/juliapkg/src/table_function.jl b/tools/juliapkg/src/table_function.jl\nnew file mode 100644\nindex 000000000000..3ff390c66575\n--- /dev/null\n+++ b/tools/juliapkg/src/table_function.jl\n@@ -0,0 +1,245 @@\n+global_objects = Set()\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Table Function Bind\n+//===--------------------------------------------------------------------===//\n+=#\n+struct BindInfo\n+    handle::duckdb_bind_info\n+    main_function::Any\n+\n+    function BindInfo(handle::duckdb_bind_info, main_function)\n+        result = new(handle, main_function)\n+        return result\n+    end\n+end\n+\n+mutable struct InfoWrapper\n+    info::Any\n+\n+    function InfoWrapper(info)\n+        return new(info)\n+    end\n+end\n+\n+function ParameterCount(bind_info::BindInfo)\n+    return duckdb_bind_get_parameter_count(bind_info.handle)\n+end\n+\n+function GetParameter(bind_info::BindInfo, index::Int64)\n+    return Value(duckdb_bind_get_parameter(bind_info.handle, index))\n+end\n+\n+function AddResultColumn(bind_info::BindInfo, name::AbstractString, type::DataType)\n+    return AddResultColumn(bind_info, name, CreateLogicalType(type))\n+end\n+\n+function AddResultColumn(bind_info::BindInfo, name::AbstractString, type::LogicalType)\n+    return duckdb_bind_add_result_column(bind_info.handle, name, type.handle)\n+end\n+\n+function GetExtraData(bind_info::BindInfo)\n+    return bind_info.main_function.extra_data\n+end\n+\n+function _table_bind_cleanup(data::Ptr{Cvoid})\n+    info::InfoWrapper = unsafe_pointer_to_objref(data)\n+    delete!(global_objects, info)\n+    return\n+end\n+\n+function _table_bind_function(info::duckdb_bind_info)\n+    try\n+        main_function = unsafe_pointer_to_objref(duckdb_bind_get_extra_info(info))\n+        binfo = BindInfo(info, main_function)\n+        bind_data = InfoWrapper(main_function.bind_func(binfo))\n+        bind_data_pointer = pointer_from_objref(bind_data)\n+        push!(global_objects, bind_data)\n+        duckdb_bind_set_bind_data(info, bind_data_pointer, @cfunction(_table_bind_cleanup, Cvoid, (Ptr{Cvoid},)))\n+    catch ex\n+        duckdb_bind_set_error(info, sprint(showerror, ex))\n+        return\n+    end\n+    return\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Table Function Init\n+//===--------------------------------------------------------------------===//\n+=#\n+mutable struct InitInfo\n+    handle::duckdb_init_info\n+    main_function::Any\n+\n+    function InitInfo(handle::duckdb_init_info, main_function)\n+        result = new(handle, main_function)\n+        return result\n+    end\n+end\n+\n+function _table_init_function(info::duckdb_init_info)\n+    try\n+        main_function = unsafe_pointer_to_objref(duckdb_init_get_extra_info(info))\n+        binfo = InitInfo(info, main_function)\n+        init_data = InfoWrapper(main_function.init_func(binfo))\n+        init_data_pointer = pointer_from_objref(init_data)\n+        push!(global_objects, init_data)\n+        duckdb_init_set_init_data(info, init_data_pointer, @cfunction(_table_bind_cleanup, Cvoid, (Ptr{Cvoid},)))\n+    catch ex\n+        duckdb_init_set_error(info, sprint(showerror, ex))\n+        return\n+    end\n+    return\n+end\n+\n+function GetBindInfo(info::InitInfo, ::Type{T})::T where {T}\n+    return unsafe_pointer_to_objref(duckdb_init_get_bind_data(info.handle)).info\n+end\n+\n+function GetExtraData(info::InitInfo)\n+    return info.main_function.extra_data\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Main Table Function\n+//===--------------------------------------------------------------------===//\n+=#\n+mutable struct FunctionInfo\n+    handle::duckdb_function_info\n+    main_function::Any\n+\n+    function FunctionInfo(handle::duckdb_function_info, main_function)\n+        result = new(handle, main_function)\n+        return result\n+    end\n+end\n+\n+function GetBindInfo(info::FunctionInfo, ::Type{T})::T where {T}\n+    return unsafe_pointer_to_objref(duckdb_function_get_bind_data(info.handle)).info\n+end\n+\n+function GetInitInfo(info::FunctionInfo, ::Type{T})::T where {T}\n+    return unsafe_pointer_to_objref(duckdb_function_get_init_data(info.handle)).info\n+end\n+\n+function _table_main_function(info::duckdb_function_info, chunk::duckdb_data_chunk)\n+    main_function = unsafe_pointer_to_objref(duckdb_function_get_extra_info(info))\n+    binfo = FunctionInfo(info, main_function)\n+    try\n+        main_function.main_func(binfo, DataChunk(chunk, false))\n+    catch ex\n+        duckdb_function_set_error(info, sprint(showerror, ex))\n+    end\n+    return\n+end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Table Function\n+//===--------------------------------------------------------------------===//\n+=#\n+\"\"\"\n+DuckDB table function\n+\"\"\"\n+mutable struct TableFunction\n+    handle::duckdb_table_function\n+    bind_func::Function\n+    init_func::Function\n+    main_func::Function\n+    extra_data::Any\n+\n+    function TableFunction(\n+        name::AbstractString,\n+        parameters::Vector{LogicalType},\n+        bind_func::Function,\n+        init_func::Function,\n+        main_func::Function,\n+        extra_data::Any\n+    )\n+        handle = duckdb_create_table_function()\n+        duckdb_table_function_set_name(handle, name)\n+        for param in parameters\n+            duckdb_table_function_add_parameter(handle, param.handle)\n+        end\n+        result = new(handle, bind_func, init_func, main_func, extra_data)\n+        finalizer(_destroy_table_function, result)\n+\n+        duckdb_table_function_set_extra_info(handle, pointer_from_objref(result))\n+        duckdb_table_function_set_bind(handle, @cfunction(_table_bind_function, Cvoid, (duckdb_bind_info,)))\n+        duckdb_table_function_set_init(handle, @cfunction(_table_init_function, Cvoid, (duckdb_init_info,)))\n+        duckdb_table_function_set_function(\n+            handle,\n+            @cfunction(_table_main_function, Cvoid, (duckdb_function_info, duckdb_data_chunk))\n+        )\n+\n+        return result\n+    end\n+end\n+\n+function _destroy_table_function(func::TableFunction)\n+    # disconnect from DB\n+    if func.handle != C_NULL\n+        duckdb_destroy_table_function(func.handle)\n+    end\n+    return func.handle = C_NULL\n+end\n+\n+function CreateTableFunction(\n+    con::Connection,\n+    name::AbstractString,\n+    parameters::Vector{LogicalType},\n+    bind_func::Function,\n+    init_func::Function,\n+    main_func::Function,\n+    extra_data::Any = missing\n+)\n+    fun = TableFunction(name, parameters, bind_func, init_func, main_func, extra_data)\n+    if duckdb_register_table_function(con.handle, fun.handle) != DuckDBSuccess\n+        throw(QueryException(string(\"Failed to register table function \\\"\", name, \"\\\"\")))\n+    end\n+    push!(con.db.functions, fun)\n+    return\n+end\n+\n+function CreateTableFunction(\n+    con::Connection,\n+    name::AbstractString,\n+    parameters::Vector{DataType},\n+    bind_func::Function,\n+    init_func::Function,\n+    main_func::Function,\n+    extra_data::Any = missing\n+)\n+    parameter_types::Vector{LogicalType} = Vector()\n+    for parameter_type in parameters\n+        push!(parameter_types, CreateLogicalType(parameter_type))\n+    end\n+    return CreateTableFunction(con, name, parameter_types, bind_func, init_func, main_func, extra_data)\n+end\n+\n+function CreateTableFunction(\n+    db::DB,\n+    name::AbstractString,\n+    parameters::Vector{LogicalType},\n+    bind_func::Function,\n+    init_func::Function,\n+    main_func::Function,\n+    extra_data::Any = missing\n+)\n+    return CreateTableFunction(db.main_connection, name, parameters, bind_func, init_func, main_func)\n+end\n+\n+function CreateTableFunction(\n+    db::DB,\n+    name::AbstractString,\n+    parameters::Vector{DataType},\n+    bind_func::Function,\n+    init_func::Function,\n+    main_func::Function,\n+    extra_data::Any = missing\n+)\n+    return CreateTableFunction(db.main_connection, name, parameters, bind_func, init_func, main_func)\n+end\ndiff --git a/tools/juliapkg/src/transaction.jl b/tools/juliapkg/src/transaction.jl\nnew file mode 100644\nindex 000000000000..4a57f5eb70c4\n--- /dev/null\n+++ b/tools/juliapkg/src/transaction.jl\n@@ -0,0 +1,48 @@\n+\n+function DBInterface.transaction(f, con::Connection)\n+    begin_transaction(con)\n+    try\n+        f()\n+    catch\n+        rollback(con)\n+        rethrow()\n+    finally\n+        commit(con)\n+    end\n+end\n+\n+function DBInterface.transaction(f, db::DB)\n+    return DBInterface.transaction(f, db.main_connection)\n+end\n+\n+\"\"\"\n+    DuckDB.begin(db)\n+\n+begin a transaction\n+\"\"\"\n+function begin_transaction end\n+\n+begin_transaction(con::Connection) = execute(con, \"BEGIN TRANSACTION;\")\n+begin_transaction(db::DB) = begin_transaction(db.main_connection)\n+transaction(con::Connection) = begin_transaction(con)\n+transaction(db::DB) = begin_transaction(db)\n+\n+\"\"\"\n+    DuckDB.commit(db)\n+\n+commit a transaction\n+\"\"\"\n+function commit end\n+\n+commit(con::Connection) = execute(con, \"COMMIT TRANSACTION;\")\n+commit(db::DB) = commit(db.main_connection)\n+\n+\"\"\"\n+    DuckDB.rollback(db)\n+\n+rollback transaction\n+\"\"\"\n+function rollback end\n+\n+rollback(con::Connection) = execute(con, \"ROLLBACK TRANSACTION;\")\n+rollback(db::DB) = rollback(db.main_connection)\ndiff --git a/tools/juliapkg/src/validity_mask.jl b/tools/juliapkg/src/validity_mask.jl\nnew file mode 100644\nindex 000000000000..e55ec6a852f7\n--- /dev/null\n+++ b/tools/juliapkg/src/validity_mask.jl\n@@ -0,0 +1,34 @@\n+\"\"\"\n+DuckDB validity mask\n+\"\"\"\n+mutable struct ValidityMask\n+    data::Vector{UInt64}\n+\n+    function ValidityMask(data::Vector{UInt64})\n+        result = new(data)\n+        return result\n+    end\n+end\n+\n+const BITS_PER_VALUE = 64;\n+\n+function GetEntryIndex(row_idx)\n+    return ((row_idx - 1) \u00f7 BITS_PER_VALUE) + 1\n+end\n+\n+function GetIndexInEntry(row_idx)\n+    return (row_idx - 1) % BITS_PER_VALUE\n+end\n+\n+function SetInvalid(mask::ValidityMask, index)\n+    entry_idx = GetEntryIndex(index)\n+    index_in_entry = GetIndexInEntry(index)\n+    mask.data[entry_idx] &= ~(1 << index_in_entry)\n+    return\n+end\n+\n+function IsValid(mask::ValidityMask, index)::Bool\n+    entry_idx = GetEntryIndex(index)\n+    index_in_entry = GetIndexInEntry(index)\n+    return (mask.data[entry_idx] & (1 << index_in_entry)) != 0\n+end\ndiff --git a/tools/juliapkg/src/value.jl b/tools/juliapkg/src/value.jl\nnew file mode 100644\nindex 000000000000..5791d8c73554\n--- /dev/null\n+++ b/tools/juliapkg/src/value.jl\n@@ -0,0 +1,37 @@\n+\"\"\"\n+DuckDB value\n+\"\"\"\n+mutable struct Value\n+    handle::duckdb_value\n+\n+    function Value(handle::duckdb_value)\n+        result = new(handle)\n+        finalizer(_destroy_value, result)\n+        return result\n+    end\n+end\n+\n+function _destroy_value(val::Value)\n+    if val.handle != C_NULL\n+        duckdb_destroy_value(val.handle)\n+    end\n+    val.handle = C_NULL\n+    return\n+end\n+\n+GetValue(val::Value, ::Type{T}) where {T <: Int64} = duckdb_get_int64(val.handle)\n+function GetValue(val::Value, ::Type{T}) where {T <: String}\n+    ptr = duckdb_get_varchar(val.handle)\n+    result = unsafe_string(ptr)\n+    duckdb_free(ptr)\n+    return result\n+end\n+function GetValue(val::Value, ::Type{T}) where {T}\n+    throw(NotImplementedException(\"Unsupported type for GetValue\"))\n+end\n+\n+\n+CreateValue(val::T) where {T <: Int64} = Value(duckdb_create_int64(val))\n+function CreateValue(val::T) where {T}\n+    throw(NotImplementedException(\"Unsupported type for GetValue\"))\n+end\ndiff --git a/tools/juliapkg/src/vector.jl b/tools/juliapkg/src/vector.jl\nnew file mode 100644\nindex 000000000000..3357c4d81847\n--- /dev/null\n+++ b/tools/juliapkg/src/vector.jl\n@@ -0,0 +1,45 @@\n+\"\"\"\n+DuckDB vector\n+\"\"\"\n+mutable struct Vec\n+    handle::duckdb_vector\n+\n+    function Vec(handle::duckdb_vector)\n+        result = new(handle)\n+        return result\n+    end\n+end\n+\n+function GetArray(vector::Vec, ::Type{T})::Vector{T} where {T}\n+    raw_ptr = duckdb_vector_get_data(vector.handle)\n+    ptr = Base.unsafe_convert(Ptr{T}, raw_ptr)\n+    return unsafe_wrap(Vector{T}, ptr, VECTOR_SIZE, own = false)\n+end\n+\n+function GetValidity(vector::Vec)::ValidityMask\n+    duckdb_vector_ensure_validity_writable(vector.handle)\n+    validity_ptr = duckdb_vector_get_validity(vector.handle)\n+    ptr = Base.unsafe_convert(Ptr{UInt64}, validity_ptr)\n+    validity_vector = unsafe_wrap(Vector{UInt64}, ptr, VECTOR_SIZE \u00f7 BITS_PER_VALUE, own = false)\n+    return ValidityMask(validity_vector)\n+end\n+\n+function AllValid(vector::Vec)::Bool\n+    return duckdb_vector_get_validity(vector.handle) == C_NULL\n+end\n+\n+function ListChild(vector::Vec)::Vec\n+    return Vec(duckdb_list_vector_get_child(vector.handle))\n+end\n+\n+function ListSize(vector::Vec)::UInt64\n+    return duckdb_list_vector_get_size(vector.handle)\n+end\n+\n+function StructChild(vector::Vec, index::UInt64)::Vec\n+    return Vec(duckdb_struct_vector_get_child(vector.handle, index))\n+end\n+\n+function AssignStringElement(vector::Vec, index, str::AbstractString)\n+    return duckdb_vector_assign_string_element_len(vector.handle, index, str, sizeof(str))\n+end\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/map.hpp b/tools/pythonpkg/src/include/duckdb_python/map.hpp\nindex 24e5ef47ad8a..92edf82a808e 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/map.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/map.hpp\n@@ -19,10 +19,7 @@ struct MapFunction : public TableFunction {\n public:\n \tMapFunction();\n \n-\tstatic unique_ptr<FunctionData> MapFunctionBind(ClientContext &context, vector<Value> &inputs,\n-\t                                                named_parameter_map_t &named_parameters,\n-\t                                                vector<LogicalType> &input_table_types,\n-\t                                                vector<string> &input_table_names,\n+\tstatic unique_ptr<FunctionData> MapFunctionBind(ClientContext &context, TableFunctionBindInput &input,\n \t                                                vector<LogicalType> &return_types, vector<string> &names);\n \n \tstatic void MapFunctionExec(ClientContext &context, const FunctionData *bind_data,\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp b/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp\nindex 66c71428c415..bf59087207d6 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp\n@@ -20,11 +20,8 @@ struct PandasScanFunction : public TableFunction {\n public:\n \tPandasScanFunction();\n \n-\tstatic unique_ptr<FunctionData> PandasScanBind(ClientContext &context, vector<Value> &inputs,\n-\t                                               named_parameter_map_t &named_parameters,\n-\t                                               vector<LogicalType> &input_table_types,\n-\t                                               vector<string> &input_table_names, vector<LogicalType> &return_types,\n-\t                                               vector<string> &names);\n+\tstatic unique_ptr<FunctionData> PandasScanBind(ClientContext &context, TableFunctionBindInput &input,\n+\t                                               vector<LogicalType> &return_types, vector<string> &names);\n \n \tstatic unique_ptr<FunctionOperatorData> PandasScanInit(ClientContext &context, const FunctionData *bind_data_p,\n \t                                                       const vector<column_t> &column_ids,\ndiff --git a/tools/pythonpkg/src/map.cpp b/tools/pythonpkg/src/map.cpp\nindex 67bc847ac794..866309da068c 100644\n--- a/tools/pythonpkg/src/map.cpp\n+++ b/tools/pythonpkg/src/map.cpp\n@@ -43,18 +43,15 @@ static py::handle FunctionCall(NumpyResultConversion &conversion, vector<string>\n \n // we call the passed function with a zero-row data frame to infer the output columns and their names.\n // they better not change in the actual execution ^^\n-unique_ptr<FunctionData> MapFunction::MapFunctionBind(ClientContext &context, vector<Value> &inputs,\n-                                                      named_parameter_map_t &named_parameters,\n-                                                      vector<LogicalType> &input_table_types,\n-                                                      vector<string> &input_table_names,\n+unique_ptr<FunctionData> MapFunction::MapFunctionBind(ClientContext &context, TableFunctionBindInput &input,\n                                                       vector<LogicalType> &return_types, vector<string> &names) {\n \tpy::gil_scoped_acquire acquire;\n \n \tauto data_uptr = make_unique<MapFunctionData>();\n \tauto &data = *data_uptr;\n-\tdata.function = (PyObject *)inputs[0].GetPointer();\n-\tdata.in_names = input_table_names;\n-\tdata.in_types = input_table_types;\n+\tdata.function = (PyObject *)input.inputs[0].GetPointer();\n+\tdata.in_names = input.input_table_names;\n+\tdata.in_types = input.input_table_types;\n \n \tNumpyResultConversion conversion(data.in_types, 0);\n \tauto df = FunctionCall(conversion, data.in_names, data.function);\ndiff --git a/tools/pythonpkg/src/pandas_scan.cpp b/tools/pythonpkg/src/pandas_scan.cpp\nindex 65df98092fb5..847114ee9e76 100644\n--- a/tools/pythonpkg/src/pandas_scan.cpp\n+++ b/tools/pythonpkg/src/pandas_scan.cpp\n@@ -52,13 +52,10 @@ PandasScanFunction::PandasScanFunction()\n                     PandasScanParallelStateNext, true, false, PandasProgress) {\n }\n \n-unique_ptr<FunctionData> PandasScanFunction::PandasScanBind(ClientContext &context, vector<Value> &inputs,\n-                                                            named_parameter_map_t &named_parameters,\n-                                                            vector<LogicalType> &input_table_types,\n-                                                            vector<string> &input_table_names,\n+unique_ptr<FunctionData> PandasScanFunction::PandasScanBind(ClientContext &context, TableFunctionBindInput &input,\n                                                             vector<LogicalType> &return_types, vector<string> &names) {\n \tpy::gil_scoped_acquire acquire;\n-\tpy::handle df((PyObject *)(inputs[0].GetPointer()));\n+\tpy::handle df((PyObject *)(input.inputs[0].GetPointer()));\n \n \tvector<PandasColumnBindData> pandas_bind_data;\n \tVectorConversion::BindPandas(df, pandas_bind_data, return_types, names);\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 573a02774ef5..8ac3c2a81f23 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -464,9 +464,15 @@ TryReplacement(py::dict &dict, py::str &table_name,\n \treturn table_function;\n }\n \n-static unique_ptr<TableFunctionRef> ScanReplacement(const string &table_name, void *data) {\n+struct ReplacementRegisteredObjects : public ReplacementScanData {\n+\tunordered_map<string, unique_ptr<RegisteredObject>> *registered_objects;\n+};\n+\n+static unique_ptr<TableFunctionRef> ScanReplacement(ClientContext &context, const string &table_name,\n+                                                    ReplacementScanData *data) {\n \tpy::gil_scoped_acquire acquire;\n-\tauto registered_objects = (unordered_map<string, unique_ptr<RegisteredObject>> *)data;\n+\tauto &registered_data = (ReplacementRegisteredObjects &)*data;\n+\tauto registered_objects = registered_data.registered_objects;\n \tauto py_table_name = py::str(table_name);\n \t// Here we do an exhaustive search on the frame lineage\n \tauto current_frame = py::module::import(\"inspect\").attr(\"currentframe\")();\n@@ -510,7 +516,9 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const string &databas\n \t\tconfig.SetOption(*config_property, Value(val));\n \t}\n \tif (config.enable_external_access) {\n-\t\tconfig.replacement_scans.emplace_back(ScanReplacement, (void *)&res->registered_objects);\n+\t\tauto extra_data = make_unique<ReplacementRegisteredObjects>();\n+\t\textra_data->registered_objects = &res->registered_objects;\n+\t\tconfig.replacement_scans.emplace_back(ScanReplacement, move(extra_data));\n \t}\n \n \tres->database = make_unique<DuckDB>(database, &config);\ndiff --git a/tools/rpkg/src/database.cpp b/tools/rpkg/src/database.cpp\nindex e15d2dea1b9b..de297e98700a 100644\n--- a/tools/rpkg/src/database.cpp\n+++ b/tools/rpkg/src/database.cpp\n@@ -46,7 +46,10 @@ void duckdb::DBDeleter(DBWrapper *db) {\n \n \ttry {\n \t\twrapper = new DBWrapper();\n-\t\tconfig.replacement_scans.emplace_back(ArrowScanReplacement, wrapper);\n+\n+\t\tauto data = make_unique<ArrowScanReplacementData>();\n+\t\tdata->wrapper = wrapper;\n+\t\tconfig.replacement_scans.emplace_back(ArrowScanReplacement, move(data));\n \t\twrapper->db = make_unique<DuckDB>(dbdirchar, &config);\n \t} catch (std::exception &e) {\n \t\tcpp11::stop(\"rapi_startup: Failed to open database: %s\", e.what());\ndiff --git a/tools/rpkg/src/include/rapi.hpp b/tools/rpkg/src/include/rapi.hpp\nindex 5b1cffee64a9..38e2fd008d77 100644\n--- a/tools/rpkg/src/include/rapi.hpp\n+++ b/tools/rpkg/src/include/rapi.hpp\n@@ -46,7 +46,12 @@ struct RQueryResult {\n typedef cpp11::external_pointer<RQueryResult> rqry_eptr_t;\n \n // internal\n-unique_ptr<TableFunctionRef> ArrowScanReplacement(const std::string &table_name, void *data);\n+unique_ptr<TableFunctionRef> ArrowScanReplacement(ClientContext &context, const std::string &table_name,\n+                                                  ReplacementScanData *data);\n+\n+struct ArrowScanReplacementData : public ReplacementScanData {\n+\tDBWrapper *wrapper;\n+};\n \n SEXP StringsToSexp(vector<std::string> s);\n \ndiff --git a/tools/rpkg/src/register.cpp b/tools/rpkg/src/register.cpp\nindex 423a36000d40..6872aa653661 100644\n--- a/tools/rpkg/src/register.cpp\n+++ b/tools/rpkg/src/register.cpp\n@@ -184,8 +184,10 @@ class RArrowTabularStreamFactory {\n \t}\n };\n \n-unique_ptr<TableFunctionRef> duckdb::ArrowScanReplacement(const string &table_name, void *data) {\n-\tauto db_wrapper = (DBWrapper *)data;\n+unique_ptr<TableFunctionRef> duckdb::ArrowScanReplacement(ClientContext &context, const string &table_name,\n+                                                          ReplacementScanData *data_p) {\n+\tauto &data = (ArrowScanReplacementData &)*data_p;\n+\tauto db_wrapper = data.wrapper;\n \tlock_guard<mutex> arrow_scans_lock(db_wrapper->lock);\n \tfor (auto &e : db_wrapper->arrow_scans) {\n \t\tif (e.first == table_name) {\ndiff --git a/tools/rpkg/src/scan.cpp b/tools/rpkg/src/scan.cpp\nindex fed729407b33..425f64df48f8 100644\n--- a/tools/rpkg/src/scan.cpp\n+++ b/tools/rpkg/src/scan.cpp\n@@ -49,13 +49,10 @@ struct DataFrameScanState : public FunctionOperatorData {\n \tidx_t position;\n };\n \n-static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> &inputs,\n-                                                    named_parameter_map_t &named_parameters,\n-                                                    vector<LogicalType> &input_table_types,\n-                                                    vector<string> &input_table_names,\n+static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, TableFunctionBindInput &input,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\n \tRProtector r;\n-\tSEXP df((SEXP)inputs[0].GetPointer());\n+\tSEXP df((SEXP)input.inputs[0].GetPointer());\n \n \tauto df_names = r.Protect(GET_NAMES(df));\n \tvector<RType> rtypes;\n",
  "test_patch": "diff --git a/src/function/table/system/test_all_types.cpp b/src/function/table/system/test_all_types.cpp\nindex db1e261a405c..cfb5213c0196 100644\n--- a/src/function/table/system/test_all_types.cpp\n+++ b/src/function/table/system/test_all_types.cpp\n@@ -167,11 +167,8 @@ static vector<TestType> GetTestTypes() {\n \treturn result;\n }\n \n-static unique_ptr<FunctionData> TestAllTypesBind(ClientContext &context, vector<Value> &inputs,\n-                                                 named_parameter_map_t &named_parameters,\n-                                                 vector<LogicalType> &input_table_types,\n-                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,\n-                                                 vector<string> &names) {\n+static unique_ptr<FunctionData> TestAllTypesBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                 vector<LogicalType> &return_types, vector<string> &names) {\n \tauto test_types = GetTestTypes();\n \tfor (auto &test_type : test_types) {\n \t\treturn_types.push_back(move(test_type.type));\ndiff --git a/test/api/capi/CMakeLists.txt b/test/api/capi/CMakeLists.txt\nindex 834d2ccee31c..cc836b26de02 100644\n--- a/test/api/capi/CMakeLists.txt\n+++ b/test/api/capi/CMakeLists.txt\n@@ -1,4 +1,16 @@\n-add_library_unity(test_sql_capi OBJECT test_capi.cpp test_starting_database.cpp)\n+add_library_unity(\n+  test_sql_capi\n+  OBJECT\n+  capi_table_functions.cpp\n+  test_capi.cpp\n+  test_starting_database.cpp\n+  test_capi_appender.cpp\n+  test_capi_arrow.cpp\n+  test_capi_data_chunk.cpp\n+  test_capi_prepared.cpp\n+  test_capi_website.cpp\n+  test_capi_complex_types.cpp\n+  test_capi_replacement_scan.cpp)\n set(ALL_OBJECT_FILES\n     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:test_sql_capi>\n     PARENT_SCOPE)\ndiff --git a/test/api/capi/capi_table_functions.cpp b/test/api/capi/capi_table_functions.cpp\nnew file mode 100644\nindex 000000000000..9665efef2df4\n--- /dev/null\n+++ b/test/api/capi/capi_table_functions.cpp\n@@ -0,0 +1,140 @@\n+#include \"capi_tester.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+struct my_bind_data_struct {\n+\tint64_t size;\n+};\n+\n+void my_bind(duckdb_bind_info info) {\n+\tREQUIRE(duckdb_bind_get_parameter_count(info) == 1);\n+\n+\tduckdb_logical_type type = duckdb_create_logical_type(DUCKDB_TYPE_BIGINT);\n+\tduckdb_bind_add_result_column(info, \"forty_two\", type);\n+\tduckdb_destroy_logical_type(&type);\n+\n+\tauto my_bind_data = (my_bind_data_struct *)malloc(sizeof(my_bind_data_struct));\n+\tauto param = duckdb_bind_get_parameter(info, 0);\n+\tmy_bind_data->size = duckdb_get_int64(param);\n+\tduckdb_destroy_value(&param);\n+\n+\tduckdb_bind_set_bind_data(info, my_bind_data, free);\n+}\n+\n+struct my_init_data_struct {\n+\tint64_t pos;\n+};\n+\n+void my_init(duckdb_init_info info) {\n+\tREQUIRE(duckdb_init_get_bind_data(info) != nullptr);\n+\tREQUIRE(duckdb_init_get_bind_data(nullptr) == nullptr);\n+\n+\tauto my_init_data = (my_init_data_struct *)malloc(sizeof(my_init_data_struct));\n+\tmy_init_data->pos = 0;\n+\tduckdb_init_set_init_data(info, my_init_data, free);\n+}\n+\n+void my_function(duckdb_function_info info, duckdb_data_chunk output) {\n+\tauto bind_data = (my_bind_data_struct *)duckdb_function_get_bind_data(info);\n+\tauto init_data = (my_init_data_struct *)duckdb_function_get_init_data(info);\n+\tauto ptr = (int64_t *)duckdb_vector_get_data(duckdb_data_chunk_get_vector(output, 0));\n+\tidx_t i;\n+\tfor (i = 0; i < STANDARD_VECTOR_SIZE; i++) {\n+\t\tif (init_data->pos >= bind_data->size) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tptr[i] = init_data->pos % 2 == 0 ? 42 : 84;\n+\t\tinit_data->pos++;\n+\t}\n+\tduckdb_data_chunk_set_size(output, i);\n+}\n+\n+static void capi_register_table_function(duckdb_connection connection, const char *name,\n+                                         duckdb_table_function_bind_t bind, duckdb_table_function_init_t init,\n+                                         duckdb_table_function_t f) {\n+\tduckdb_state status;\n+\n+\t// create a table function\n+\tauto function = duckdb_create_table_function();\n+\tduckdb_table_function_set_name(nullptr, name);\n+\tduckdb_table_function_set_name(function, nullptr);\n+\tduckdb_table_function_set_name(function, name);\n+\tduckdb_table_function_set_name(function, name);\n+\n+\t// add a string parameter\n+\tduckdb_logical_type type = duckdb_create_logical_type(DUCKDB_TYPE_BIGINT);\n+\tduckdb_table_function_add_parameter(function, type);\n+\tduckdb_destroy_logical_type(&type);\n+\n+\t// set up the function pointers\n+\tduckdb_table_function_set_bind(function, bind);\n+\tduckdb_table_function_set_init(function, init);\n+\tduckdb_table_function_set_function(function, f);\n+\n+\t// register and cleanup\n+\tstatus = duckdb_register_table_function(connection, function);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tduckdb_destroy_table_function(&function);\n+\tduckdb_destroy_table_function(&function);\n+\tduckdb_destroy_table_function(nullptr);\n+}\n+\n+TEST_CASE(\"Test Table Functions C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\tcapi_register_table_function(tester.connection, \"my_function\", my_bind, my_init, my_function);\n+\n+\t// now call it\n+\tresult = tester.Query(\"SELECT * FROM my_function(1)\");\n+\tREQUIRE_NO_FAIL(*result);\n+\tREQUIRE(result->Fetch<int64_t>(0, 0) == 42);\n+\n+\tresult = tester.Query(\"SELECT * FROM my_function(3)\");\n+\tREQUIRE_NO_FAIL(*result);\n+\tREQUIRE(result->Fetch<int64_t>(0, 0) == 42);\n+\tREQUIRE(result->Fetch<int64_t>(0, 1) == 84);\n+\tREQUIRE(result->Fetch<int64_t>(0, 2) == 42);\n+\n+\tresult = tester.Query(\"SELECT forty_two, COUNT(*) FROM my_function(10000) GROUP BY 1 ORDER BY 1\");\n+\tREQUIRE_NO_FAIL(*result);\n+\tREQUIRE(result->Fetch<int64_t>(0, 0) == 42);\n+\tREQUIRE(result->Fetch<int64_t>(0, 1) == 84);\n+\tREQUIRE(result->Fetch<int64_t>(1, 0) == 5000);\n+\tREQUIRE(result->Fetch<int64_t>(1, 1) == 5000);\n+}\n+\n+void my_error_bind(duckdb_bind_info info) {\n+\tduckdb_bind_set_error(nullptr, nullptr);\n+\tduckdb_bind_set_error(info, \"My error message\");\n+}\n+\n+void my_error_init(duckdb_init_info info) {\n+\tduckdb_init_set_error(nullptr, nullptr);\n+\tduckdb_init_set_error(info, \"My error message\");\n+}\n+\n+void my_error_function(duckdb_function_info info, duckdb_data_chunk output) {\n+\tduckdb_function_set_error(nullptr, nullptr);\n+\tduckdb_function_set_error(info, \"My error message\");\n+}\n+\n+TEST_CASE(\"Test Table Function errors in C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\tcapi_register_table_function(tester.connection, \"my_error_bind\", my_error_bind, my_init, my_function);\n+\tcapi_register_table_function(tester.connection, \"my_error_init\", my_bind, my_error_init, my_function);\n+\tcapi_register_table_function(tester.connection, \"my_error_function\", my_bind, my_init, my_error_function);\n+\n+\tresult = tester.Query(\"SELECT * FROM my_error_bind(1)\");\n+\tREQUIRE(!result->success);\n+\tresult = tester.Query(\"SELECT * FROM my_error_init(1)\");\n+\tREQUIRE(!result->success);\n+\tresult = tester.Query(\"SELECT * FROM my_error_function(1)\");\n+\tREQUIRE(!result->success);\n+}\ndiff --git a/test/api/capi/test_capi.cpp b/test/api/capi/test_capi.cpp\nindex 49bf7c4b4478..60e54ea425ef 100644\n--- a/test/api/capi/test_capi.cpp\n+++ b/test/api/capi/test_capi.cpp\n@@ -1,244 +1,8 @@\n-#include \"catch.hpp\"\n-#include \"duckdb.h\"\n-#include \"test_helpers.hpp\"\n-#include \"duckdb/common/arrow.hpp\"\n-#include \"duckdb/common/exception.hpp\"\n+#include \"capi_tester.hpp\"\n \n using namespace duckdb;\n using namespace std;\n \n-class CAPIResult {\n-public:\n-\t~CAPIResult() {\n-\t\tduckdb_destroy_result(&result);\n-\t}\n-\tvoid Query(duckdb_connection connection, string query) {\n-\t\tsuccess = (duckdb_query(connection, query.c_str(), &result) == DuckDBSuccess);\n-\t\tif (!success) {\n-\t\t\tREQUIRE(ErrorMessage() != nullptr);\n-\t\t}\n-\t}\n-\n-\tduckdb_type ColumnType(idx_t col) {\n-\t\treturn duckdb_column_type(&result, col);\n-\t}\n-\n-\ttemplate <class T>\n-\tT *ColumnData(idx_t col) {\n-\t\treturn (T *)duckdb_column_data(&result, col);\n-\t}\n-\n-\tidx_t ColumnCount() {\n-\t\treturn duckdb_column_count(&result);\n-\t}\n-\n-\tidx_t row_count() {\n-\t\treturn duckdb_row_count(&result);\n-\t}\n-\n-\tidx_t rows_changed() {\n-\t\treturn duckdb_rows_changed(&result);\n-\t}\n-\n-\ttemplate <class T>\n-\tT Fetch(idx_t col, idx_t row) {\n-\t\tthrow NotImplementedException(\"Unimplemented type for fetch\");\n-\t}\n-\n-\tbool IsNull(idx_t col, idx_t row) {\n-\t\tauto nullmask_ptr = duckdb_nullmask_data(&result, col);\n-\t\tREQUIRE(duckdb_value_is_null(&result, col, row) == nullmask_ptr[row]);\n-\t\treturn nullmask_ptr[row];\n-\t}\n-\n-\tchar *ErrorMessage() {\n-\t\treturn duckdb_result_error(&result);\n-\t}\n-\n-\tstring ColumnName(idx_t col) {\n-\t\tauto colname = duckdb_column_name(&result, col);\n-\t\treturn colname ? string(colname) : string();\n-\t}\n-\n-\tduckdb_result &InternalResult() {\n-\t\treturn result;\n-\t}\n-\n-public:\n-\tbool success = false;\n-\n-private:\n-\tduckdb_result result;\n-};\n-\n-static bool NO_FAIL(CAPIResult &result) {\n-\treturn result.success;\n-}\n-\n-static bool NO_FAIL(unique_ptr<CAPIResult> result) {\n-\treturn NO_FAIL(*result);\n-}\n-\n-template <>\n-bool CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_boolean(&result, col, row);\n-}\n-\n-template <>\n-int8_t CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_int8(&result, col, row);\n-}\n-\n-template <>\n-int16_t CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_int16(&result, col, row);\n-}\n-\n-template <>\n-int32_t CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_int32(&result, col, row);\n-}\n-\n-template <>\n-int64_t CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_int64(&result, col, row);\n-}\n-\n-template <>\n-uint8_t CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_uint8(&result, col, row);\n-}\n-\n-template <>\n-uint16_t CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_uint16(&result, col, row);\n-}\n-\n-template <>\n-uint32_t CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_uint32(&result, col, row);\n-}\n-\n-template <>\n-uint64_t CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_uint64(&result, col, row);\n-}\n-\n-template <>\n-float CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_float(&result, col, row);\n-}\n-\n-template <>\n-double CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_double(&result, col, row);\n-}\n-\n-template <>\n-duckdb_decimal CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_decimal(&result, col, row);\n-}\n-\n-template <>\n-duckdb_date CAPIResult::Fetch(idx_t col, idx_t row) {\n-\tauto data = (duckdb_date *)duckdb_column_data(&result, col);\n-\treturn data[row];\n-}\n-\n-template <>\n-duckdb_time CAPIResult::Fetch(idx_t col, idx_t row) {\n-\tauto data = (duckdb_time *)duckdb_column_data(&result, col);\n-\treturn data[row];\n-}\n-\n-template <>\n-duckdb_timestamp CAPIResult::Fetch(idx_t col, idx_t row) {\n-\tauto data = (duckdb_timestamp *)duckdb_column_data(&result, col);\n-\treturn data[row];\n-}\n-\n-template <>\n-duckdb_interval CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_interval(&result, col, row);\n-}\n-\n-template <>\n-duckdb_blob CAPIResult::Fetch(idx_t col, idx_t row) {\n-\tauto data = (duckdb_blob *)duckdb_column_data(&result, col);\n-\treturn data[row];\n-}\n-\n-template <>\n-string CAPIResult::Fetch(idx_t col, idx_t row) {\n-\tauto value = duckdb_value_varchar(&result, col, row);\n-\tstring strval = value ? string(value) : string();\n-\tfree((void *)value);\n-\treturn strval;\n-}\n-\n-template <>\n-duckdb_date_struct CAPIResult::Fetch(idx_t col, idx_t row) {\n-\tauto value = duckdb_value_date(&result, col, row);\n-\treturn duckdb_from_date(value);\n-}\n-\n-template <>\n-duckdb_time_struct CAPIResult::Fetch(idx_t col, idx_t row) {\n-\tauto value = duckdb_value_time(&result, col, row);\n-\treturn duckdb_from_time(value);\n-}\n-\n-template <>\n-duckdb_timestamp_struct CAPIResult::Fetch(idx_t col, idx_t row) {\n-\tauto value = duckdb_value_timestamp(&result, col, row);\n-\treturn duckdb_from_timestamp(value);\n-}\n-\n-template <>\n-duckdb_hugeint CAPIResult::Fetch(idx_t col, idx_t row) {\n-\treturn duckdb_value_hugeint(&result, col, row);\n-}\n-\n-class CAPITester {\n-public:\n-\tCAPITester() : database(nullptr), connection(nullptr) {\n-\t}\n-\t~CAPITester() {\n-\t\tCleanup();\n-\t}\n-\n-\tvoid Cleanup() {\n-\t\tif (connection) {\n-\t\t\tduckdb_disconnect(&connection);\n-\t\t\tconnection = nullptr;\n-\t\t}\n-\t\tif (database) {\n-\t\t\tduckdb_close(&database);\n-\t\t\tdatabase = nullptr;\n-\t\t}\n-\t}\n-\n-\tbool OpenDatabase(const char *path) {\n-\t\tCleanup();\n-\t\tif (duckdb_open(path, &database) != DuckDBSuccess) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (duckdb_connect(database, &connection) != DuckDBSuccess) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tunique_ptr<CAPIResult> Query(string query) {\n-\t\tauto result = make_unique<CAPIResult>();\n-\t\tresult->Query(connection, query);\n-\t\treturn result;\n-\t}\n-\n-\tduckdb_database database = nullptr;\n-\tduckdb_connection connection = nullptr;\n-};\n-\n TEST_CASE(\"Basic test of C API\", \"[capi]\") {\n \tCAPITester tester;\n \tunique_ptr<CAPIResult> result;\n@@ -258,6 +22,8 @@ TEST_CASE(\"Basic test of C API\", \"[capi]\") {\n \t// out of range fetch\n \tREQUIRE(result->Fetch<int64_t>(1, 0) == 0);\n \tREQUIRE(result->Fetch<int64_t>(0, 1) == 0);\n+\t// cannot fetch data chunk after using the value API\n+\tREQUIRE(result->FetchChunk(0) == nullptr);\n \n \t// select scalar NULL\n \tresult = tester.Query(\"SELECT NULL\");\n@@ -431,33 +197,6 @@ TEST_CASE(\"Test different types of C API\", \"[capi]\") {\n \tREQUIRE(date.day == 20);\n \tREQUIRE(result->Fetch<string>(0, 2) == Value::DATE(30000, 9, 20).ToString());\n \n-\t// timestamp columns\n-\tREQUIRE_NO_FAIL(tester.Query(\n-\t    \"CREATE TABLE timestamp (sec TIMESTAMP_S, milli TIMESTAMP_MS,micro TIMESTAMP_US, nano TIMESTAMP_NS );\"));\n-\tREQUIRE_NO_FAIL(tester.Query(\"INSERT INTO timestamp VALUES (NULL,NULL,NULL,NULL )\"));\n-\tREQUIRE_NO_FAIL(tester.Query(\"INSERT INTO timestamp VALUES ('1992-09-20 12:01:30','1992-09-20 \"\n-\t                             \"12:01:30','1992-09-20 12:01:30','1992-09-20 12:01:30')\"));\n-\n-\tresult = tester.Query(\"SELECT * FROM timestamp ORDER BY sec\");\n-\tREQUIRE_NO_FAIL(*result);\n-\tREQUIRE(result->IsNull(0, 0));\n-\tREQUIRE(result->IsNull(1, 0));\n-\tREQUIRE(result->IsNull(2, 0));\n-\tREQUIRE(result->IsNull(3, 0));\n-\tfor (idx_t i = 0; i < 4; i++) {\n-\t\tduckdb_timestamp_struct stamp = duckdb_from_timestamp(result->Fetch<duckdb_timestamp>(i, 1));\n-\t\tREQUIRE(stamp.date.year == 1992);\n-\t\tREQUIRE(stamp.date.month == 9);\n-\t\tREQUIRE(stamp.date.day == 20);\n-\t\tREQUIRE(stamp.time.hour == 12);\n-\t\tREQUIRE(stamp.time.min == 1);\n-\t\tREQUIRE(stamp.time.sec == 30);\n-\t\tREQUIRE(stamp.time.micros == 0);\n-\t\tauto result_string = result->Fetch<string>(i, 1);\n-\t\tauto timestamp_string = Value::TIMESTAMP(1992, 9, 20, 12, 1, 30, 0).ToString();\n-\t\tREQUIRE(result->Fetch<string>(i, 1) == timestamp_string);\n-\t}\n-\n \t// time columns\n \tREQUIRE_NO_FAIL(tester.Query(\"CREATE TABLE times(d TIME)\"));\n \tREQUIRE_NO_FAIL(tester.Query(\"INSERT INTO times VALUES ('12:00:30.1234'), (NULL), ('02:30:01')\"));\n@@ -583,744 +322,6 @@ TEST_CASE(\"Test errors in C API\", \"[capi]\") {\n \tREQUIRE(d.day == 1);\n }\n \n-TEST_CASE(\"Test prepared statements in C API\", \"[capi]\") {\n-\tCAPITester tester;\n-\tunique_ptr<CAPIResult> result;\n-\tduckdb_result res;\n-\tduckdb_prepared_statement stmt = nullptr;\n-\tduckdb_state status;\n-\n-\t// open the database in in-memory mode\n-\tREQUIRE(tester.OpenDatabase(nullptr));\n-\n-\tstatus = duckdb_prepare(tester.connection, \"SELECT CAST($1 AS BIGINT)\", &stmt);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(stmt != nullptr);\n-\n-\tstatus = duckdb_bind_boolean(stmt, 1, 1);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tstatus = duckdb_bind_boolean(stmt, 2, 1);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 1);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_int8(stmt, 1, 8);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 8);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_int16(stmt, 1, 16);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 16);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_int32(stmt, 1, 32);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 32);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_int64(stmt, 1, 64);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 64);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_hugeint(stmt, 1, duckdb_double_to_hugeint(64));\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_hugeint_to_double(duckdb_value_hugeint(&res, 0, 0)) == 64.0);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_uint8(stmt, 1, 8);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_uint8(&res, 0, 0) == 8);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_uint16(stmt, 1, 8);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_uint16(&res, 0, 0) == 8);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_uint32(stmt, 1, 8);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_uint32(&res, 0, 0) == 8);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_uint64(stmt, 1, 8);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_uint64(&res, 0, 0) == 8);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_float(stmt, 1, 42.0);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 42);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_double(stmt, 1, 43.0);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 43);\n-\tduckdb_destroy_result(&res);\n-\n-\tREQUIRE(duckdb_bind_float(stmt, 1, NAN) == DuckDBError);\n-\tREQUIRE(duckdb_bind_double(stmt, 1, NAN) == DuckDBError);\n-\n-\tduckdb_bind_varchar(stmt, 1, \"44\");\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 44);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_null(stmt, 1);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_nullmask_data(&res, 0)[0] == true);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_destroy_prepare(&stmt);\n-\t// again to make sure it does not crash\n-\tduckdb_destroy_result(&res);\n-\tduckdb_destroy_prepare(&stmt);\n-\n-\tstatus = duckdb_prepare(tester.connection, \"SELECT CAST($1 AS VARCHAR)\", &stmt);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(stmt != nullptr);\n-\n-\tduckdb_bind_varchar_length(stmt, 1, \"hello world\", 5);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tauto value = duckdb_value_varchar(&res, 0, 0);\n-\tREQUIRE(string(value) == \"hello\");\n-\tREQUIRE(duckdb_value_int8(&res, 0, 0) == 0);\n-\tduckdb_free(value);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_bind_blob(stmt, 1, \"hello\\0world\", 11);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tvalue = duckdb_value_varchar(&res, 0, 0);\n-\tREQUIRE(string(value) == \"hello\\\\x00world\");\n-\tREQUIRE(duckdb_value_int8(&res, 0, 0) == 0);\n-\tduckdb_free(value);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_date_struct date_struct;\n-\tdate_struct.year = 1992;\n-\tdate_struct.month = 9;\n-\tdate_struct.day = 3;\n-\n-\tduckdb_bind_date(stmt, 1, duckdb_to_date(date_struct));\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tvalue = duckdb_value_varchar(&res, 0, 0);\n-\tREQUIRE(string(value) == \"1992-09-03\");\n-\tduckdb_free(value);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_time_struct time_struct;\n-\ttime_struct.hour = 12;\n-\ttime_struct.min = 22;\n-\ttime_struct.sec = 33;\n-\ttime_struct.micros = 123400;\n-\n-\tduckdb_bind_time(stmt, 1, duckdb_to_time(time_struct));\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tvalue = duckdb_value_varchar(&res, 0, 0);\n-\tREQUIRE(string(value) == \"12:22:33.1234\");\n-\tduckdb_free(value);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_timestamp_struct ts;\n-\tts.date = date_struct;\n-\tts.time = time_struct;\n-\n-\tduckdb_bind_timestamp(stmt, 1, duckdb_to_timestamp(ts));\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tvalue = duckdb_value_varchar(&res, 0, 0);\n-\tREQUIRE(string(value) == \"1992-09-03 12:22:33.1234\");\n-\tduckdb_free(value);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_interval interval;\n-\tinterval.months = 3;\n-\tinterval.days = 0;\n-\tinterval.micros = 0;\n-\n-\tduckdb_bind_interval(stmt, 1, interval);\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tvalue = duckdb_value_varchar(&res, 0, 0);\n-\tREQUIRE(string(value) == \"3 months\");\n-\tduckdb_free(value);\n-\tduckdb_destroy_result(&res);\n-\n-\tduckdb_destroy_prepare(&stmt);\n-\n-\tstatus = duckdb_query(tester.connection, \"CREATE TABLE a (i INTEGER)\", NULL);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_prepare(tester.connection, \"INSERT INTO a VALUES (?)\", &stmt);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(stmt != nullptr);\n-\tREQUIRE(duckdb_nparams(nullptr) == 0);\n-\tREQUIRE(duckdb_nparams(stmt) == 1);\n-\tREQUIRE(duckdb_param_type(nullptr, 0) == DUCKDB_TYPE_INVALID);\n-\tREQUIRE(duckdb_param_type(stmt, 0) == DUCKDB_TYPE_INVALID);\n-\tREQUIRE(duckdb_param_type(stmt, 1) == DUCKDB_TYPE_INTEGER);\n-\tREQUIRE(duckdb_param_type(stmt, 2) == DUCKDB_TYPE_INVALID);\n-\n-\tfor (int32_t i = 1; i <= 1000; i++) {\n-\t\tduckdb_bind_int32(stmt, 1, i);\n-\t\tstatus = duckdb_execute_prepared(stmt, nullptr);\n-\t\tREQUIRE(status == DuckDBSuccess);\n-\t}\n-\tduckdb_destroy_prepare(&stmt);\n-\n-\tstatus = duckdb_prepare(tester.connection, \"SELECT SUM(i)*$1-$2 FROM a\", &stmt);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(stmt != nullptr);\n-\tduckdb_bind_int32(stmt, 1, 2);\n-\tduckdb_bind_int32(stmt, 2, 1000);\n-\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_value_int32(&res, 0, 0) == 1000000);\n-\tduckdb_destroy_result(&res);\n-\tduckdb_destroy_prepare(&stmt);\n-\n-\t// not-so-happy path\n-\tstatus = duckdb_prepare(tester.connection, \"SELECT XXXXX\", &stmt);\n-\tREQUIRE(status == DuckDBError);\n-\tduckdb_destroy_prepare(&stmt);\n-\n-\tstatus = duckdb_prepare(tester.connection, \"SELECT CAST($1 AS INTEGER)\", &stmt);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(stmt != nullptr);\n-\n-\tstatus = duckdb_execute_prepared(stmt, &res);\n-\tREQUIRE(status == DuckDBError);\n-\tduckdb_destroy_result(&res);\n-\tduckdb_destroy_prepare(&stmt);\n-\n-\t// test duckdb_malloc explicitly\n-\tauto malloced_data = duckdb_malloc(100);\n-\tmemcpy(malloced_data, \"hello\\0\", 6);\n-\tREQUIRE(string((char *)malloced_data) == \"hello\");\n-\tduckdb_free(malloced_data);\n-}\n-\n-TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n-\tCAPITester tester;\n-\tunique_ptr<CAPIResult> result;\n-\tduckdb_state status;\n-\n-\t// open the database in in-memory mode\n-\tREQUIRE(tester.OpenDatabase(nullptr));\n-\n-\ttester.Query(\"CREATE TABLE test (i INTEGER, d double, s string)\");\n-\tduckdb_appender appender;\n-\n-\tstatus = duckdb_appender_create(tester.connection, nullptr, \"nonexistant-table\", &appender);\n-\tREQUIRE(status == DuckDBError);\n-\tREQUIRE(appender != nullptr);\n-\tREQUIRE(duckdb_appender_error(appender) != nullptr);\n-\tREQUIRE(duckdb_appender_destroy(&appender) == DuckDBSuccess);\n-\tREQUIRE(duckdb_appender_destroy(nullptr) == DuckDBError);\n-\n-\tstatus = duckdb_appender_create(tester.connection, nullptr, \"test\", nullptr);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_appender_create(tester.connection, nullptr, \"test\", &appender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\tREQUIRE(duckdb_appender_error(appender) == nullptr);\n-\n-\tstatus = duckdb_appender_begin_row(appender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_int32(appender, 42);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_double(appender, 4.2);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_varchar(appender, \"Hello, World\");\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\t// out of cols here\n-\tstatus = duckdb_append_int32(appender, 42);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_appender_end_row(appender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_appender_flush(appender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_appender_begin_row(appender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_int32(appender, 42);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_double(appender, 4.2);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\t// not enough cols here\n-\tstatus = duckdb_appender_end_row(appender);\n-\tREQUIRE(status == DuckDBError);\n-\tREQUIRE(duckdb_appender_error(appender) != nullptr);\n-\n-\tstatus = duckdb_append_varchar(appender, \"Hello, World\");\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\t// out of cols here\n-\tstatus = duckdb_append_int32(appender, 42);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tREQUIRE(duckdb_appender_error(appender) != nullptr);\n-\n-\tstatus = duckdb_appender_end_row(appender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\t// we can flush again why not\n-\tstatus = duckdb_appender_flush(appender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_appender_close(appender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tresult = tester.Query(\"SELECT * FROM test\");\n-\tREQUIRE_NO_FAIL(*result);\n-\tREQUIRE(result->Fetch<int32_t>(0, 0) == 42);\n-\tREQUIRE(result->Fetch<double>(1, 0) == 4.2);\n-\tREQUIRE(result->Fetch<string>(2, 0) == \"Hello, World\");\n-\n-\tstatus = duckdb_appender_destroy(&appender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\t// this has been destroyed\n-\n-\tstatus = duckdb_appender_close(appender);\n-\tREQUIRE(status == DuckDBError);\n-\tREQUIRE(duckdb_appender_error(appender) == nullptr);\n-\n-\tstatus = duckdb_appender_flush(appender);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_appender_end_row(appender);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_append_int32(appender, 42);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_appender_destroy(&appender);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_appender_close(nullptr);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_appender_flush(nullptr);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_appender_end_row(nullptr);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_append_int32(nullptr, 42);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_appender_destroy(nullptr);\n-\tREQUIRE(status == DuckDBError);\n-\n-\tstatus = duckdb_appender_destroy(nullptr);\n-\tREQUIRE(status == DuckDBError);\n-\n-\t// many types\n-\tREQUIRE_NO_FAIL(tester.Query(\"CREATE TABLE many_types(bool boolean, t TINYINT, s SMALLINT, b BIGINT, ut UTINYINT, \"\n-\t                             \"us USMALLINT, ui UINTEGER, ub UBIGINT, uf REAL, ud DOUBLE, txt VARCHAR, blb BLOB, dt \"\n-\t                             \"DATE, tm TIME, ts TIMESTAMP, ival INTERVAL, h HUGEINT)\"));\n-\tduckdb_appender tappender;\n-\n-\tstatus = duckdb_appender_create(tester.connection, nullptr, \"many_types\", &tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_appender_begin_row(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_bool(tappender, true);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_int8(tappender, 1);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_int16(tappender, 1);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_int64(tappender, 1);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_uint8(tappender, 1);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_uint16(tappender, 1);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_uint32(tappender, 1);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_uint64(tappender, 1);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_float(tappender, 0.5f);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_double(tappender, 0.5);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_varchar_length(tappender, \"hello world\", 5);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tduckdb_date_struct date_struct;\n-\tdate_struct.year = 1992;\n-\tdate_struct.month = 9;\n-\tdate_struct.day = 3;\n-\n-\tauto str = strdup(\"hello world this is my long string\");\n-\tstatus = duckdb_append_blob(tappender, str, strlen(str));\n-\tfree(str);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_date(tappender, duckdb_to_date(date_struct));\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tduckdb_time_struct time_struct;\n-\ttime_struct.hour = 12;\n-\ttime_struct.min = 22;\n-\ttime_struct.sec = 33;\n-\ttime_struct.micros = 1234;\n-\n-\tstatus = duckdb_append_time(tappender, duckdb_to_time(time_struct));\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tduckdb_timestamp_struct ts;\n-\tts.date = date_struct;\n-\tts.time = time_struct;\n-\n-\tstatus = duckdb_append_timestamp(tappender, duckdb_to_timestamp(ts));\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tduckdb_interval interval;\n-\tinterval.months = 3;\n-\tinterval.days = 0;\n-\tinterval.micros = 0;\n-\n-\tstatus = duckdb_append_interval(tappender, interval);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_hugeint(tappender, duckdb_double_to_hugeint(27));\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_appender_end_row(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_appender_begin_row(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_append_null(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_appender_end_row(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_appender_flush(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_appender_close(tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tstatus = duckdb_appender_destroy(&tappender);\n-\tREQUIRE(status == DuckDBSuccess);\n-\n-\tresult = tester.Query(\"SELECT * FROM many_types\");\n-\tREQUIRE_NO_FAIL(*result);\n-\tREQUIRE(result->Fetch<bool>(0, 0) == true);\n-\tREQUIRE(result->Fetch<int8_t>(1, 0) == 1);\n-\tREQUIRE(result->Fetch<int16_t>(2, 0) == 1);\n-\tREQUIRE(result->Fetch<int64_t>(3, 0) == 1);\n-\tREQUIRE(result->Fetch<uint8_t>(4, 0) == 1);\n-\tREQUIRE(result->Fetch<uint16_t>(5, 0) == 1);\n-\tREQUIRE(result->Fetch<uint32_t>(6, 0) == 1);\n-\tREQUIRE(result->Fetch<uint64_t>(7, 0) == 1);\n-\tREQUIRE(result->Fetch<float>(8, 0) == 0.5f);\n-\tREQUIRE(result->Fetch<double>(9, 0) == 0.5);\n-\tREQUIRE(result->Fetch<string>(10, 0) == \"hello\");\n-\n-\tauto blob = duckdb_value_blob(&result->InternalResult(), 11, 0);\n-\tREQUIRE(blob.size == 34);\n-\tREQUIRE(memcmp(blob.data, \"hello world this is my long string\", 34) == 0);\n-\tduckdb_free(blob.data);\n-\tREQUIRE(duckdb_value_int32(&result->InternalResult(), 11, 0) == 0);\n-\n-\tauto date = result->Fetch<duckdb_date_struct>(12, 0);\n-\tREQUIRE(date.year == 1992);\n-\tREQUIRE(date.month == 9);\n-\tREQUIRE(date.day == 3);\n-\n-\tauto time = result->Fetch<duckdb_time_struct>(13, 0);\n-\tREQUIRE(time.hour == 12);\n-\tREQUIRE(time.min == 22);\n-\tREQUIRE(time.sec == 33);\n-\tREQUIRE(time.micros == 1234);\n-\n-\tauto timestamp = result->Fetch<duckdb_timestamp_struct>(14, 0);\n-\tREQUIRE(timestamp.date.year == 1992);\n-\tREQUIRE(timestamp.date.month == 9);\n-\tREQUIRE(timestamp.date.day == 3);\n-\tREQUIRE(timestamp.time.hour == 12);\n-\tREQUIRE(timestamp.time.min == 22);\n-\tREQUIRE(timestamp.time.sec == 33);\n-\tREQUIRE(timestamp.time.micros == 1234);\n-\n-\tinterval = result->Fetch<duckdb_interval>(15, 0);\n-\tREQUIRE(interval.months == 3);\n-\tREQUIRE(interval.days == 0);\n-\tREQUIRE(interval.micros == 0);\n-\n-\tauto hugeint = result->Fetch<duckdb_hugeint>(16, 0);\n-\tREQUIRE(duckdb_hugeint_to_double(hugeint) == 27);\n-\n-\tREQUIRE(result->IsNull(0, 1));\n-\tREQUIRE(result->IsNull(1, 1));\n-\tREQUIRE(result->IsNull(2, 1));\n-\tREQUIRE(result->IsNull(3, 1));\n-\tREQUIRE(result->IsNull(4, 1));\n-\tREQUIRE(result->IsNull(5, 1));\n-\tREQUIRE(result->IsNull(6, 1));\n-\tREQUIRE(result->IsNull(7, 1));\n-\tREQUIRE(result->IsNull(8, 1));\n-\tREQUIRE(result->IsNull(9, 1));\n-\tREQUIRE(result->IsNull(10, 1));\n-\tREQUIRE(result->IsNull(11, 1));\n-\tREQUIRE(result->IsNull(12, 1));\n-\tREQUIRE(result->IsNull(13, 1));\n-\tREQUIRE(result->IsNull(14, 1));\n-\tREQUIRE(result->IsNull(15, 1));\n-\tREQUIRE(result->IsNull(16, 1));\n-\n-\tREQUIRE(result->Fetch<bool>(0, 1) == false);\n-\tREQUIRE(result->Fetch<int8_t>(1, 1) == 0);\n-\tREQUIRE(result->Fetch<int16_t>(2, 1) == 0);\n-\tREQUIRE(result->Fetch<int64_t>(3, 1) == 0);\n-\tREQUIRE(result->Fetch<uint8_t>(4, 1) == 0);\n-\tREQUIRE(result->Fetch<uint16_t>(5, 1) == 0);\n-\tREQUIRE(result->Fetch<uint32_t>(6, 1) == 0);\n-\tREQUIRE(result->Fetch<uint64_t>(7, 1) == 0);\n-\tREQUIRE(result->Fetch<float>(8, 1) == 0);\n-\tREQUIRE(result->Fetch<double>(9, 1) == 0);\n-\tREQUIRE(result->Fetch<string>(10, 1) == \"\");\n-\n-\tblob = duckdb_value_blob(&result->InternalResult(), 11, 1);\n-\tREQUIRE(blob.size == 0);\n-\n-\tdate = result->Fetch<duckdb_date_struct>(12, 1);\n-\tREQUIRE(date.year == 1970);\n-\n-\ttime = result->Fetch<duckdb_time_struct>(13, 1);\n-\tREQUIRE(time.hour == 0);\n-\n-\ttimestamp = result->Fetch<duckdb_timestamp_struct>(14, 1);\n-\tREQUIRE(timestamp.date.year == 1970);\n-\tREQUIRE(timestamp.time.hour == 0);\n-\n-\tinterval = result->Fetch<duckdb_interval>(15, 1);\n-\tREQUIRE(interval.months == 0);\n-\n-\thugeint = result->Fetch<duckdb_hugeint>(16, 1);\n-\tREQUIRE(duckdb_hugeint_to_double(hugeint) == 0);\n-\n-\t// double out of range for hugeint\n-\thugeint = duckdb_double_to_hugeint(1e300);\n-\tREQUIRE(hugeint.lower == 0);\n-\tREQUIRE(hugeint.upper == 0);\n-\n-\thugeint = duckdb_double_to_hugeint(NAN);\n-\tREQUIRE(hugeint.lower == 0);\n-\tREQUIRE(hugeint.upper == 0);\n-}\n-\n-TEST_CASE(\"Test arrow in C API\", \"[capi]\") {\n-\tCAPITester tester;\n-\tunique_ptr<CAPIResult> result;\n-\tduckdb_prepared_statement stmt = nullptr;\n-\tduckdb_arrow arrow_result;\n-\n-\t// open the database in in-memory mode\n-\tREQUIRE(tester.OpenDatabase(nullptr));\n-\n-\t// test rows changed\n-\t{\n-\t\tREQUIRE_NO_FAIL(tester.Query(\"CREATE TABLE test(a INTEGER)\"));\n-\t\tREQUIRE(duckdb_query_arrow(tester.connection, \"INSERT INTO test VALUES (1), (2);\", &arrow_result) ==\n-\t\t        DuckDBSuccess);\n-\t\tREQUIRE(duckdb_arrow_rows_changed(arrow_result) == 2);\n-\t\tduckdb_destroy_arrow(&arrow_result);\n-\t\tREQUIRE_NO_FAIL(tester.Query(\"drop table test\"));\n-\t}\n-\n-\t// test query arrow\n-\t{\n-\t\tREQUIRE(duckdb_query_arrow(tester.connection, \"SELECT 42 AS VALUE\", &arrow_result) == DuckDBSuccess);\n-\t\tREQUIRE(duckdb_arrow_row_count(arrow_result) == 1);\n-\t\tREQUIRE(duckdb_arrow_column_count(arrow_result) == 1);\n-\t\tREQUIRE(duckdb_arrow_rows_changed(arrow_result) == 0);\n-\n-\t\t// query schema\n-\t\tArrowSchema *arrow_schema = new ArrowSchema();\n-\t\tREQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);\n-\t\tREQUIRE(string(arrow_schema->name) == \"duckdb_query_result\");\n-\t\t// User need to release the data themselves\n-\t\tarrow_schema->release(arrow_schema);\n-\t\tdelete arrow_schema;\n-\n-\t\t// query array data\n-\t\tArrowArray *arrow_array = new ArrowArray();\n-\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);\n-\t\tREQUIRE(arrow_array->length == 1);\n-\t\tarrow_array->release(arrow_array);\n-\t\tdelete arrow_array;\n-\n-\t\tduckdb_arrow_array null_array = nullptr;\n-\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, &null_array) == DuckDBSuccess);\n-\t\tREQUIRE(null_array == nullptr);\n-\n-\t\t// destroy result\n-\t\tduckdb_destroy_arrow(&arrow_result);\n-\t}\n-\n-\t// test multiple chunks\n-\t{\n-\t\t// create table that consists of multiple chunks\n-\t\tREQUIRE_NO_FAIL(tester.Query(\"BEGIN TRANSACTION\"));\n-\t\tREQUIRE_NO_FAIL(tester.Query(\"CREATE TABLE test(a INTEGER)\"));\n-\t\tfor (size_t i = 0; i < 500; i++) {\n-\t\t\tREQUIRE_NO_FAIL(\n-\t\t\t    tester.Query(\"INSERT INTO test VALUES (1); INSERT INTO test VALUES (2); INSERT INTO test VALUES \"\n-\t\t\t                 \"(3); INSERT INTO test VALUES (4); INSERT INTO test VALUES (5);\"));\n-\t\t}\n-\t\tREQUIRE_NO_FAIL(tester.Query(\"COMMIT\"));\n-\n-\t\tREQUIRE(duckdb_query_arrow(tester.connection, \"SELECT CAST(a AS INTEGER) AS a FROM test ORDER BY a\",\n-\t\t                           &arrow_result) == DuckDBSuccess);\n-\n-\t\tArrowSchema *arrow_schema = new ArrowSchema();\n-\t\tREQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);\n-\t\tREQUIRE(arrow_schema->release != nullptr);\n-\t\tarrow_schema->release(arrow_schema);\n-\t\tdelete arrow_schema;\n-\n-\t\tint total_count = 0;\n-\t\twhile (true) {\n-\t\t\tArrowArray *arrow_array = new ArrowArray();\n-\t\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);\n-\t\t\tif (arrow_array->length == 0) {\n-\t\t\t\tdelete arrow_array;\n-\t\t\t\tREQUIRE(total_count == 2500);\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tREQUIRE(arrow_array->length > 0);\n-\t\t\ttotal_count += arrow_array->length;\n-\t\t\tarrow_array->release(arrow_array);\n-\t\t\tdelete arrow_array;\n-\t\t}\n-\t\tduckdb_destroy_arrow(&arrow_result);\n-\t\tREQUIRE_NO_FAIL(tester.Query(\"drop table test\"));\n-\t}\n-\n-\t// test prepare query arrow\n-\t{\n-\t\tREQUIRE(duckdb_prepare(tester.connection, \"SELECT CAST($1 AS BIGINT)\", &stmt) == DuckDBSuccess);\n-\t\tREQUIRE(stmt != nullptr);\n-\t\tREQUIRE(duckdb_bind_int64(stmt, 1, 42) == DuckDBSuccess);\n-\t\tREQUIRE(duckdb_execute_prepared_arrow(stmt, nullptr) == DuckDBError);\n-\t\tREQUIRE(duckdb_execute_prepared_arrow(stmt, &arrow_result) == DuckDBSuccess);\n-\n-\t\tArrowSchema *arrow_schema = new ArrowSchema();\n-\t\tREQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);\n-\t\tREQUIRE(string(arrow_schema->format) == \"+s\");\n-\t\tarrow_schema->release(arrow_schema);\n-\t\tdelete arrow_schema;\n-\n-\t\tArrowArray *arrow_array = new ArrowArray();\n-\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);\n-\t\tREQUIRE(arrow_array->length == 1);\n-\t\tarrow_array->release(arrow_array);\n-\t\tdelete arrow_array;\n-\n-\t\tduckdb_destroy_arrow(&arrow_result);\n-\t\tduckdb_destroy_prepare(&stmt);\n-\t}\n-}\n-\n TEST_CASE(\"Test C API config\", \"[capi]\") {\n \tduckdb_database db = nullptr;\n \tduckdb_connection con = nullptr;\n@@ -1422,186 +423,3 @@ TEST_CASE(\"Issue #2058: Cleanup after execution of invalid SQL statement causes\n \tduckdb_disconnect(&con);\n \tduckdb_close(&db);\n }\n-\n-TEST_CASE(\"Test C API examples from the website\", \"[capi]\") {\n-\t// NOTE: if any of these break and need to be changed, the website also needs to be updated!\n-\tSECTION(\"connect\") {\n-\t\tduckdb_database db;\n-\t\tduckdb_connection con;\n-\n-\t\tif (duckdb_open(NULL, &db) == DuckDBError) {\n-\t\t\t// handle error\n-\t\t}\n-\t\tif (duckdb_connect(db, &con) == DuckDBError) {\n-\t\t\t// handle error\n-\t\t}\n-\n-\t\t// run queries...\n-\n-\t\t// cleanup\n-\t\tduckdb_disconnect(&con);\n-\t\tduckdb_close(&db);\n-\t}\n-\tSECTION(\"config\") {\n-\t\tduckdb_database db;\n-\t\tduckdb_config config;\n-\n-\t\t// create the configuration object\n-\t\tif (duckdb_create_config(&config) == DuckDBError) {\n-\t\t\tREQUIRE(1 == 0);\n-\t\t}\n-\t\t// set some configuration options\n-\t\tduckdb_set_config(config, \"access_mode\", \"READ_WRITE\");\n-\t\tduckdb_set_config(config, \"threads\", \"8\");\n-\t\tduckdb_set_config(config, \"max_memory\", \"8GB\");\n-\t\tduckdb_set_config(config, \"default_order\", \"DESC\");\n-\n-\t\t// open the database using the configuration\n-\t\tif (duckdb_open_ext(NULL, &db, config, NULL) == DuckDBError) {\n-\t\t\tREQUIRE(1 == 0);\n-\t\t}\n-\t\t// cleanup the configuration object\n-\t\tduckdb_destroy_config(&config);\n-\n-\t\t// run queries...\n-\n-\t\t// cleanup\n-\t\tduckdb_close(&db);\n-\t}\n-\tSECTION(\"query\") {\n-\t\tduckdb_database db;\n-\t\tduckdb_connection con;\n-\t\tduckdb_state state;\n-\t\tduckdb_result result;\n-\n-\t\tduckdb_open(NULL, &db);\n-\t\tduckdb_connect(db, &con);\n-\n-\t\t// create a table\n-\t\tstate = duckdb_query(con, \"CREATE TABLE integers(i INTEGER, j INTEGER);\", NULL);\n-\t\tif (state == DuckDBError) {\n-\t\t\tREQUIRE(1 == 0);\n-\t\t}\n-\t\t// insert three rows into the table\n-\t\tstate = duckdb_query(con, \"INSERT INTO integers VALUES (3, 4), (5, 6), (7, NULL);\", NULL);\n-\t\tif (state == DuckDBError) {\n-\t\t\tREQUIRE(1 == 0);\n-\t\t}\n-\t\t// query rows again\n-\t\tstate = duckdb_query(con, \"SELECT * FROM integers\", &result);\n-\t\tif (state == DuckDBError) {\n-\t\t\tREQUIRE(1 == 0);\n-\t\t}\n-\t\t// handle the result\n-\t\tidx_t row_count = duckdb_row_count(&result);\n-\t\tidx_t column_count = duckdb_column_count(&result);\n-\t\tfor (idx_t row = 0; row < row_count; row++) {\n-\t\t\tfor (idx_t col = 0; col < column_count; col++) {\n-\t\t\t\t// if (col > 0) printf(\",\");\n-\t\t\t\tauto str_val = duckdb_value_varchar(&result, col, row);\n-\t\t\t\t// printf(\"%s\", str_val);\n-\t\t\t\tREQUIRE(1 == 1);\n-\t\t\t\tduckdb_free(str_val);\n-\t\t\t}\n-\t\t\t//\tprintf(\"\\n\");\n-\t\t}\n-\n-\t\tint32_t *i_data = (int32_t *)duckdb_column_data(&result, 0);\n-\t\tint32_t *j_data = (int32_t *)duckdb_column_data(&result, 1);\n-\t\tbool *i_mask = duckdb_nullmask_data(&result, 0);\n-\t\tbool *j_mask = duckdb_nullmask_data(&result, 1);\n-\t\tfor (idx_t row = 0; row < row_count; row++) {\n-\t\t\tif (i_mask[row]) {\n-\t\t\t\t// printf(\"NULL\");\n-\t\t\t} else {\n-\t\t\t\tREQUIRE(i_data[row] > 0);\n-\t\t\t\t// printf(\"%d\", i_data[row]);\n-\t\t\t}\n-\t\t\t// printf(\",\");\n-\t\t\tif (j_mask[row]) {\n-\t\t\t\t// printf(\"NULL\");\n-\t\t\t} else {\n-\t\t\t\tREQUIRE(j_data[row] > 0);\n-\t\t\t\t// printf(\"%d\", j_data[row]);\n-\t\t\t}\n-\t\t\t// printf(\"\\n\");\n-\t\t}\n-\n-\t\t// destroy the result after we are done with it\n-\t\tduckdb_destroy_result(&result);\n-\t\tduckdb_disconnect(&con);\n-\t\tduckdb_close(&db);\n-\t}\n-\tSECTION(\"prepared\") {\n-\t\tduckdb_database db;\n-\t\tduckdb_connection con;\n-\t\tduckdb_open(NULL, &db);\n-\t\tduckdb_connect(db, &con);\n-\t\tduckdb_query(con, \"CREATE TABLE integers(i INTEGER, j INTEGER)\", NULL);\n-\n-\t\tduckdb_prepared_statement stmt;\n-\t\tduckdb_result result;\n-\t\tif (duckdb_prepare(con, \"INSERT INTO integers VALUES ($1, $2)\", &stmt) == DuckDBError) {\n-\t\t\tREQUIRE(1 == 0);\n-\t\t}\n-\n-\t\tduckdb_bind_int32(stmt, 1, 42); // the parameter index starts counting at 1!\n-\t\tduckdb_bind_int32(stmt, 2, 43);\n-\t\t// NULL as second parameter means no result set is requested\n-\t\tduckdb_execute_prepared(stmt, NULL);\n-\t\tduckdb_destroy_prepare(&stmt);\n-\n-\t\t// we can also query result sets using prepared statements\n-\t\tif (duckdb_prepare(con, \"SELECT * FROM integers WHERE i = ?\", &stmt) == DuckDBError) {\n-\t\t\tREQUIRE(1 == 0);\n-\t\t}\n-\t\tduckdb_bind_int32(stmt, 1, 42);\n-\t\tduckdb_execute_prepared(stmt, &result);\n-\n-\t\t// do something with result\n-\n-\t\t// clean up\n-\t\tduckdb_destroy_result(&result);\n-\t\tduckdb_destroy_prepare(&stmt);\n-\n-\t\tduckdb_disconnect(&con);\n-\t\tduckdb_close(&db);\n-\t}\n-\tSECTION(\"appender\") {\n-\t\tduckdb_database db;\n-\t\tduckdb_connection con;\n-\t\tduckdb_open(NULL, &db);\n-\t\tduckdb_connect(db, &con);\n-\t\tduckdb_query(con, \"CREATE TABLE people(id INTEGER, name VARCHAR)\", NULL);\n-\n-\t\tduckdb_appender appender;\n-\t\tif (duckdb_appender_create(con, NULL, \"people\", &appender) == DuckDBError) {\n-\t\t\tREQUIRE(1 == 0);\n-\t\t}\n-\t\tduckdb_append_int32(appender, 1);\n-\t\tduckdb_append_varchar(appender, \"Mark\");\n-\t\tduckdb_appender_end_row(appender);\n-\n-\t\tduckdb_append_int32(appender, 2);\n-\t\tduckdb_append_varchar(appender, \"Hannes\");\n-\t\tduckdb_appender_end_row(appender);\n-\n-\t\tduckdb_appender_destroy(&appender);\n-\n-\t\tduckdb_result result;\n-\t\tduckdb_query(con, \"SELECT * FROM people\", &result);\n-\t\tREQUIRE(duckdb_value_int32(&result, 0, 0) == 1);\n-\t\tREQUIRE(duckdb_value_int32(&result, 0, 1) == 2);\n-\t\tREQUIRE(string(duckdb_value_varchar_internal(&result, 1, 0)) == \"Mark\");\n-\t\tREQUIRE(string(duckdb_value_varchar_internal(&result, 1, 1)) == \"Hannes\");\n-\n-\t\t// error conditions: we cannot\n-\t\tREQUIRE(duckdb_value_varchar_internal(&result, 0, 0) == nullptr);\n-\t\tREQUIRE(duckdb_value_varchar_internal(nullptr, 0, 0) == nullptr);\n-\n-\t\tduckdb_destroy_result(&result);\n-\n-\t\tduckdb_disconnect(&con);\n-\t\tduckdb_close(&db);\n-\t}\n-}\ndiff --git a/test/api/capi/test_capi_appender.cpp b/test/api/capi/test_capi_appender.cpp\nnew file mode 100644\nindex 000000000000..975d04abf8fa\n--- /dev/null\n+++ b/test/api/capi/test_capi_appender.cpp\n@@ -0,0 +1,390 @@\n+#include \"capi_tester.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\tduckdb_state status;\n+\n+\t// open the database in in-memory mode\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\n+\ttester.Query(\"CREATE TABLE test (i INTEGER, d double, s string)\");\n+\tduckdb_appender appender;\n+\n+\tstatus = duckdb_appender_create(tester.connection, nullptr, \"nonexistant-table\", &appender);\n+\tREQUIRE(status == DuckDBError);\n+\tREQUIRE(appender != nullptr);\n+\tREQUIRE(duckdb_appender_error(appender) != nullptr);\n+\tREQUIRE(duckdb_appender_destroy(&appender) == DuckDBSuccess);\n+\tREQUIRE(duckdb_appender_destroy(nullptr) == DuckDBError);\n+\n+\tstatus = duckdb_appender_create(tester.connection, nullptr, \"test\", nullptr);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_appender_create(tester.connection, nullptr, \"test\", &appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_appender_error(appender) == nullptr);\n+\n+\tstatus = duckdb_appender_begin_row(appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_int32(appender, 42);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_double(appender, 4.2);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_varchar(appender, \"Hello, World\");\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\t// out of cols here\n+\tstatus = duckdb_append_int32(appender, 42);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_appender_end_row(appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_flush(appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_begin_row(appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_int32(appender, 42);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_double(appender, 4.2);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\t// not enough cols here\n+\tstatus = duckdb_appender_end_row(appender);\n+\tREQUIRE(status == DuckDBError);\n+\tREQUIRE(duckdb_appender_error(appender) != nullptr);\n+\n+\tstatus = duckdb_append_varchar(appender, \"Hello, World\");\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\t// out of cols here\n+\tstatus = duckdb_append_int32(appender, 42);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tREQUIRE(duckdb_appender_error(appender) != nullptr);\n+\n+\tstatus = duckdb_appender_end_row(appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\t// we can flush again why not\n+\tstatus = duckdb_appender_flush(appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_close(appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tresult = tester.Query(\"SELECT * FROM test\");\n+\tREQUIRE_NO_FAIL(*result);\n+\tREQUIRE(result->Fetch<int32_t>(0, 0) == 42);\n+\tREQUIRE(result->Fetch<double>(1, 0) == 4.2);\n+\tREQUIRE(result->Fetch<string>(2, 0) == \"Hello, World\");\n+\n+\tstatus = duckdb_appender_destroy(&appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\t// this has been destroyed\n+\n+\tstatus = duckdb_appender_close(appender);\n+\tREQUIRE(status == DuckDBError);\n+\tREQUIRE(duckdb_appender_error(appender) == nullptr);\n+\n+\tstatus = duckdb_appender_flush(appender);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_appender_end_row(appender);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_append_int32(appender, 42);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_appender_destroy(&appender);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_appender_close(nullptr);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_appender_flush(nullptr);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_appender_end_row(nullptr);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_append_int32(nullptr, 42);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_appender_destroy(nullptr);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_appender_destroy(nullptr);\n+\tREQUIRE(status == DuckDBError);\n+\n+\t// many types\n+\tREQUIRE_NO_FAIL(tester.Query(\"CREATE TABLE many_types(bool boolean, t TINYINT, s SMALLINT, b BIGINT, ut UTINYINT, \"\n+\t                             \"us USMALLINT, ui UINTEGER, ub UBIGINT, uf REAL, ud DOUBLE, txt VARCHAR, blb BLOB, dt \"\n+\t                             \"DATE, tm TIME, ts TIMESTAMP, ival INTERVAL, h HUGEINT)\"));\n+\tduckdb_appender tappender;\n+\n+\tstatus = duckdb_appender_create(tester.connection, nullptr, \"many_types\", &tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_begin_row(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_bool(tappender, true);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_int8(tappender, 1);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_int16(tappender, 1);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_int64(tappender, 1);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_uint8(tappender, 1);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_uint16(tappender, 1);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_uint32(tappender, 1);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_uint64(tappender, 1);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_float(tappender, 0.5f);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_double(tappender, 0.5);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_varchar_length(tappender, \"hello world\", 5);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tduckdb_date_struct date_struct;\n+\tdate_struct.year = 1992;\n+\tdate_struct.month = 9;\n+\tdate_struct.day = 3;\n+\n+\tauto str = strdup(\"hello world this is my long string\");\n+\tstatus = duckdb_append_blob(tappender, str, strlen(str));\n+\tfree(str);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_date(tappender, duckdb_to_date(date_struct));\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tduckdb_time_struct time_struct;\n+\ttime_struct.hour = 12;\n+\ttime_struct.min = 22;\n+\ttime_struct.sec = 33;\n+\ttime_struct.micros = 1234;\n+\n+\tstatus = duckdb_append_time(tappender, duckdb_to_time(time_struct));\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tduckdb_timestamp_struct ts;\n+\tts.date = date_struct;\n+\tts.time = time_struct;\n+\n+\tstatus = duckdb_append_timestamp(tappender, duckdb_to_timestamp(ts));\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tduckdb_interval interval;\n+\tinterval.months = 3;\n+\tinterval.days = 0;\n+\tinterval.micros = 0;\n+\n+\tstatus = duckdb_append_interval(tappender, interval);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_hugeint(tappender, duckdb_double_to_hugeint(27));\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_end_row(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_begin_row(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_end_row(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_flush(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_close(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_destroy(&tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tresult = tester.Query(\"SELECT * FROM many_types\");\n+\tREQUIRE_NO_FAIL(*result);\n+\tREQUIRE(result->Fetch<bool>(0, 0) == true);\n+\tREQUIRE(result->Fetch<int8_t>(1, 0) == 1);\n+\tREQUIRE(result->Fetch<int16_t>(2, 0) == 1);\n+\tREQUIRE(result->Fetch<int64_t>(3, 0) == 1);\n+\tREQUIRE(result->Fetch<uint8_t>(4, 0) == 1);\n+\tREQUIRE(result->Fetch<uint16_t>(5, 0) == 1);\n+\tREQUIRE(result->Fetch<uint32_t>(6, 0) == 1);\n+\tREQUIRE(result->Fetch<uint64_t>(7, 0) == 1);\n+\tREQUIRE(result->Fetch<float>(8, 0) == 0.5f);\n+\tREQUIRE(result->Fetch<double>(9, 0) == 0.5);\n+\tREQUIRE(result->Fetch<string>(10, 0) == \"hello\");\n+\n+\tauto blob = duckdb_value_blob(&result->InternalResult(), 11, 0);\n+\tREQUIRE(blob.size == 34);\n+\tREQUIRE(memcmp(blob.data, \"hello world this is my long string\", 34) == 0);\n+\tduckdb_free(blob.data);\n+\tREQUIRE(duckdb_value_int32(&result->InternalResult(), 11, 0) == 0);\n+\n+\tauto date = result->Fetch<duckdb_date_struct>(12, 0);\n+\tREQUIRE(date.year == 1992);\n+\tREQUIRE(date.month == 9);\n+\tREQUIRE(date.day == 3);\n+\n+\tauto time = result->Fetch<duckdb_time_struct>(13, 0);\n+\tREQUIRE(time.hour == 12);\n+\tREQUIRE(time.min == 22);\n+\tREQUIRE(time.sec == 33);\n+\tREQUIRE(time.micros == 1234);\n+\n+\tauto timestamp = result->Fetch<duckdb_timestamp_struct>(14, 0);\n+\tREQUIRE(timestamp.date.year == 1992);\n+\tREQUIRE(timestamp.date.month == 9);\n+\tREQUIRE(timestamp.date.day == 3);\n+\tREQUIRE(timestamp.time.hour == 12);\n+\tREQUIRE(timestamp.time.min == 22);\n+\tREQUIRE(timestamp.time.sec == 33);\n+\tREQUIRE(timestamp.time.micros == 1234);\n+\n+\tinterval = result->Fetch<duckdb_interval>(15, 0);\n+\tREQUIRE(interval.months == 3);\n+\tREQUIRE(interval.days == 0);\n+\tREQUIRE(interval.micros == 0);\n+\n+\tauto hugeint = result->Fetch<duckdb_hugeint>(16, 0);\n+\tREQUIRE(duckdb_hugeint_to_double(hugeint) == 27);\n+\n+\tREQUIRE(result->IsNull(0, 1));\n+\tREQUIRE(result->IsNull(1, 1));\n+\tREQUIRE(result->IsNull(2, 1));\n+\tREQUIRE(result->IsNull(3, 1));\n+\tREQUIRE(result->IsNull(4, 1));\n+\tREQUIRE(result->IsNull(5, 1));\n+\tREQUIRE(result->IsNull(6, 1));\n+\tREQUIRE(result->IsNull(7, 1));\n+\tREQUIRE(result->IsNull(8, 1));\n+\tREQUIRE(result->IsNull(9, 1));\n+\tREQUIRE(result->IsNull(10, 1));\n+\tREQUIRE(result->IsNull(11, 1));\n+\tREQUIRE(result->IsNull(12, 1));\n+\tREQUIRE(result->IsNull(13, 1));\n+\tREQUIRE(result->IsNull(14, 1));\n+\tREQUIRE(result->IsNull(15, 1));\n+\tREQUIRE(result->IsNull(16, 1));\n+\n+\tREQUIRE(result->Fetch<bool>(0, 1) == false);\n+\tREQUIRE(result->Fetch<int8_t>(1, 1) == 0);\n+\tREQUIRE(result->Fetch<int16_t>(2, 1) == 0);\n+\tREQUIRE(result->Fetch<int64_t>(3, 1) == 0);\n+\tREQUIRE(result->Fetch<uint8_t>(4, 1) == 0);\n+\tREQUIRE(result->Fetch<uint16_t>(5, 1) == 0);\n+\tREQUIRE(result->Fetch<uint32_t>(6, 1) == 0);\n+\tREQUIRE(result->Fetch<uint64_t>(7, 1) == 0);\n+\tREQUIRE(result->Fetch<float>(8, 1) == 0);\n+\tREQUIRE(result->Fetch<double>(9, 1) == 0);\n+\tREQUIRE(result->Fetch<string>(10, 1) == \"\");\n+\n+\tblob = duckdb_value_blob(&result->InternalResult(), 11, 1);\n+\tREQUIRE(blob.size == 0);\n+\n+\tdate = result->Fetch<duckdb_date_struct>(12, 1);\n+\tREQUIRE(date.year == 1970);\n+\n+\ttime = result->Fetch<duckdb_time_struct>(13, 1);\n+\tREQUIRE(time.hour == 0);\n+\n+\ttimestamp = result->Fetch<duckdb_timestamp_struct>(14, 1);\n+\tREQUIRE(timestamp.date.year == 1970);\n+\tREQUIRE(timestamp.time.hour == 0);\n+\n+\tinterval = result->Fetch<duckdb_interval>(15, 1);\n+\tREQUIRE(interval.months == 0);\n+\n+\thugeint = result->Fetch<duckdb_hugeint>(16, 1);\n+\tREQUIRE(duckdb_hugeint_to_double(hugeint) == 0);\n+\n+\t// double out of range for hugeint\n+\thugeint = duckdb_double_to_hugeint(1e300);\n+\tREQUIRE(hugeint.lower == 0);\n+\tREQUIRE(hugeint.upper == 0);\n+\n+\thugeint = duckdb_double_to_hugeint(NAN);\n+\tREQUIRE(hugeint.lower == 0);\n+\tREQUIRE(hugeint.upper == 0);\n+}\ndiff --git a/test/api/capi/test_capi_arrow.cpp b/test/api/capi/test_capi_arrow.cpp\nnew file mode 100644\nindex 000000000000..210ae3cece83\n--- /dev/null\n+++ b/test/api/capi/test_capi_arrow.cpp\n@@ -0,0 +1,117 @@\n+#include \"capi_tester.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+TEST_CASE(\"Test arrow in C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\tduckdb_prepared_statement stmt = nullptr;\n+\tduckdb_arrow arrow_result;\n+\n+\t// open the database in in-memory mode\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\n+\t// test rows changed\n+\t{\n+\t\tREQUIRE_NO_FAIL(tester.Query(\"CREATE TABLE test(a INTEGER)\"));\n+\t\tREQUIRE(duckdb_query_arrow(tester.connection, \"INSERT INTO test VALUES (1), (2);\", &arrow_result) ==\n+\t\t        DuckDBSuccess);\n+\t\tREQUIRE(duckdb_arrow_rows_changed(arrow_result) == 2);\n+\t\tduckdb_destroy_arrow(&arrow_result);\n+\t\tREQUIRE_NO_FAIL(tester.Query(\"drop table test\"));\n+\t}\n+\n+\t// test query arrow\n+\t{\n+\t\tREQUIRE(duckdb_query_arrow(tester.connection, \"SELECT 42 AS VALUE\", &arrow_result) == DuckDBSuccess);\n+\t\tREQUIRE(duckdb_arrow_row_count(arrow_result) == 1);\n+\t\tREQUIRE(duckdb_arrow_column_count(arrow_result) == 1);\n+\t\tREQUIRE(duckdb_arrow_rows_changed(arrow_result) == 0);\n+\n+\t\t// query schema\n+\t\tArrowSchema *arrow_schema = new ArrowSchema();\n+\t\tREQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);\n+\t\tREQUIRE(string(arrow_schema->name) == \"duckdb_query_result\");\n+\t\t// User need to release the data themselves\n+\t\tarrow_schema->release(arrow_schema);\n+\t\tdelete arrow_schema;\n+\n+\t\t// query array data\n+\t\tArrowArray *arrow_array = new ArrowArray();\n+\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);\n+\t\tREQUIRE(arrow_array->length == 1);\n+\t\tarrow_array->release(arrow_array);\n+\t\tdelete arrow_array;\n+\n+\t\tduckdb_arrow_array null_array = nullptr;\n+\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, &null_array) == DuckDBSuccess);\n+\t\tREQUIRE(null_array == nullptr);\n+\n+\t\t// destroy result\n+\t\tduckdb_destroy_arrow(&arrow_result);\n+\t}\n+\n+\t// test multiple chunks\n+\t{\n+\t\t// create table that consists of multiple chunks\n+\t\tREQUIRE_NO_FAIL(tester.Query(\"BEGIN TRANSACTION\"));\n+\t\tREQUIRE_NO_FAIL(tester.Query(\"CREATE TABLE test(a INTEGER)\"));\n+\t\tfor (size_t i = 0; i < 500; i++) {\n+\t\t\tREQUIRE_NO_FAIL(\n+\t\t\t    tester.Query(\"INSERT INTO test VALUES (1); INSERT INTO test VALUES (2); INSERT INTO test VALUES \"\n+\t\t\t                 \"(3); INSERT INTO test VALUES (4); INSERT INTO test VALUES (5);\"));\n+\t\t}\n+\t\tREQUIRE_NO_FAIL(tester.Query(\"COMMIT\"));\n+\n+\t\tREQUIRE(duckdb_query_arrow(tester.connection, \"SELECT CAST(a AS INTEGER) AS a FROM test ORDER BY a\",\n+\t\t                           &arrow_result) == DuckDBSuccess);\n+\n+\t\tArrowSchema *arrow_schema = new ArrowSchema();\n+\t\tREQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);\n+\t\tREQUIRE(arrow_schema->release != nullptr);\n+\t\tarrow_schema->release(arrow_schema);\n+\t\tdelete arrow_schema;\n+\n+\t\tint total_count = 0;\n+\t\twhile (true) {\n+\t\t\tArrowArray *arrow_array = new ArrowArray();\n+\t\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);\n+\t\t\tif (arrow_array->length == 0) {\n+\t\t\t\tdelete arrow_array;\n+\t\t\t\tREQUIRE(total_count == 2500);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tREQUIRE(arrow_array->length > 0);\n+\t\t\ttotal_count += arrow_array->length;\n+\t\t\tarrow_array->release(arrow_array);\n+\t\t\tdelete arrow_array;\n+\t\t}\n+\t\tduckdb_destroy_arrow(&arrow_result);\n+\t\tREQUIRE_NO_FAIL(tester.Query(\"drop table test\"));\n+\t}\n+\n+\t// test prepare query arrow\n+\t{\n+\t\tREQUIRE(duckdb_prepare(tester.connection, \"SELECT CAST($1 AS BIGINT)\", &stmt) == DuckDBSuccess);\n+\t\tREQUIRE(stmt != nullptr);\n+\t\tREQUIRE(duckdb_bind_int64(stmt, 1, 42) == DuckDBSuccess);\n+\t\tREQUIRE(duckdb_execute_prepared_arrow(stmt, nullptr) == DuckDBError);\n+\t\tREQUIRE(duckdb_execute_prepared_arrow(stmt, &arrow_result) == DuckDBSuccess);\n+\n+\t\tArrowSchema *arrow_schema = new ArrowSchema();\n+\t\tREQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);\n+\t\tREQUIRE(string(arrow_schema->format) == \"+s\");\n+\t\tarrow_schema->release(arrow_schema);\n+\t\tdelete arrow_schema;\n+\n+\t\tArrowArray *arrow_array = new ArrowArray();\n+\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);\n+\t\tREQUIRE(arrow_array->length == 1);\n+\t\tarrow_array->release(arrow_array);\n+\t\tdelete arrow_array;\n+\n+\t\tduckdb_destroy_arrow(&arrow_result);\n+\t\tduckdb_destroy_prepare(&stmt);\n+\t}\n+}\ndiff --git a/test/api/capi/test_capi_complex_types.cpp b/test/api/capi/test_capi_complex_types.cpp\nnew file mode 100644\nindex 000000000000..2a9b471bb435\n--- /dev/null\n+++ b/test/api/capi/test_capi_complex_types.cpp\n@@ -0,0 +1,174 @@\n+#include \"capi_tester.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+TEST_CASE(\"Test decimal types C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\n+\t// decimal types\n+\tresult =\n+\t    tester.Query(\"SELECT 1.0::DECIMAL(4,1), 2.0::DECIMAL(9,2), 3.0::DECIMAL(18,3), 4.0::DECIMAL(38,4), 5::INTEGER\");\n+\tREQUIRE(NO_FAIL(*result));\n+\tREQUIRE(result->ColumnCount() == 5);\n+\tREQUIRE(result->ErrorMessage() == nullptr);\n+\n+\tif (duckdb_vector_size() < 64) {\n+\t\treturn;\n+\t}\n+\n+\t// fetch the first chunk\n+\tREQUIRE(result->ChunkCount() == 1);\n+\tauto chunk = result->FetchChunk(0);\n+\tREQUIRE(chunk);\n+\n+\tvector<uint8_t> widths = {4, 9, 18, 38, 0};\n+\tvector<uint8_t> scales = {1, 2, 3, 4, 0};\n+\tvector<duckdb_type> types = {DUCKDB_TYPE_DECIMAL, DUCKDB_TYPE_DECIMAL, DUCKDB_TYPE_DECIMAL, DUCKDB_TYPE_DECIMAL,\n+\t                             DUCKDB_TYPE_INTEGER};\n+\tvector<duckdb_type> internal_types = {DUCKDB_TYPE_SMALLINT, DUCKDB_TYPE_INTEGER, DUCKDB_TYPE_BIGINT,\n+\t                                      DUCKDB_TYPE_HUGEINT, DUCKDB_TYPE_INVALID};\n+\tfor (idx_t i = 0; i < result->ColumnCount(); i++) {\n+\t\tauto logical_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(chunk->GetChunk(), i));\n+\t\tREQUIRE(logical_type);\n+\t\tREQUIRE(duckdb_get_type_id(logical_type) == types[i]);\n+\t\tREQUIRE(duckdb_decimal_width(logical_type) == widths[i]);\n+\t\tREQUIRE(duckdb_decimal_scale(logical_type) == scales[i]);\n+\t\tREQUIRE(duckdb_decimal_internal_type(logical_type) == internal_types[i]);\n+\n+\t\tduckdb_destroy_logical_type(&logical_type);\n+\t}\n+\tREQUIRE(duckdb_decimal_width(nullptr) == 0);\n+\tREQUIRE(duckdb_decimal_scale(nullptr) == 0);\n+\tREQUIRE(duckdb_decimal_internal_type(nullptr) == DUCKDB_TYPE_INVALID);\n+}\n+\n+TEST_CASE(\"Test enum types C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\n+\tif (duckdb_vector_size() < 64) {\n+\t\treturn;\n+\t}\n+\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\tresult = tester.Query(\"select small_enum, medium_enum, large_enum, int from test_all_types();\");\n+\tREQUIRE(NO_FAIL(*result));\n+\tREQUIRE(result->ColumnCount() == 4);\n+\tREQUIRE(result->ErrorMessage() == nullptr);\n+\n+\t// fetch the first chunk\n+\tREQUIRE(result->ChunkCount() == 1);\n+\tauto chunk = result->FetchChunk(0);\n+\tREQUIRE(chunk);\n+\n+\tvector<duckdb_type> types = {DUCKDB_TYPE_ENUM, DUCKDB_TYPE_ENUM, DUCKDB_TYPE_ENUM, DUCKDB_TYPE_INTEGER};\n+\tvector<duckdb_type> internal_types = {DUCKDB_TYPE_UTINYINT, DUCKDB_TYPE_USMALLINT, DUCKDB_TYPE_UINTEGER,\n+\t                                      DUCKDB_TYPE_INVALID};\n+\tvector<uint32_t> dictionary_sizes = {2, 300, 70000, 0};\n+\tvector<string> dictionary_strings = {\"DUCK_DUCK_ENUM\", \"enum_0\", \"enum_0\", string()};\n+\tfor (idx_t i = 0; i < result->ColumnCount(); i++) {\n+\t\tauto logical_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(chunk->GetChunk(), i));\n+\t\tREQUIRE(logical_type);\n+\t\tREQUIRE(duckdb_get_type_id(logical_type) == types[i]);\n+\t\tREQUIRE(duckdb_enum_internal_type(logical_type) == internal_types[i]);\n+\t\tREQUIRE(duckdb_enum_dictionary_size(logical_type) == dictionary_sizes[i]);\n+\n+\t\tauto value = duckdb_enum_dictionary_value(logical_type, 0);\n+\t\tstring str_val = value ? string(value) : string();\n+\t\tduckdb_free(value);\n+\n+\t\tREQUIRE(str_val == dictionary_strings[i]);\n+\n+\t\tduckdb_destroy_logical_type(&logical_type);\n+\t}\n+\tREQUIRE(duckdb_enum_internal_type(nullptr) == DUCKDB_TYPE_INVALID);\n+\tREQUIRE(duckdb_enum_dictionary_size(nullptr) == 0);\n+\tREQUIRE(duckdb_enum_dictionary_value(nullptr, 0) == nullptr);\n+}\n+\n+TEST_CASE(\"Test list types C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\tresult = tester.Query(\"select [1, 2, 3] l, ['hello', 'world'] s, [[1, 2, 3], [4, 5]] nested, 3::int\");\n+\tREQUIRE(NO_FAIL(*result));\n+\tREQUIRE(result->ColumnCount() == 4);\n+\tREQUIRE(result->ErrorMessage() == nullptr);\n+\n+\t// fetch the first chunk\n+\tREQUIRE(result->ChunkCount() == 1);\n+\tauto chunk = result->FetchChunk(0);\n+\tREQUIRE(chunk);\n+\n+\tvector<duckdb_type> types = {DUCKDB_TYPE_LIST, DUCKDB_TYPE_LIST, DUCKDB_TYPE_LIST, DUCKDB_TYPE_INTEGER};\n+\tvector<duckdb_type> child_types_1 = {DUCKDB_TYPE_INTEGER, DUCKDB_TYPE_VARCHAR, DUCKDB_TYPE_LIST,\n+\t                                     DUCKDB_TYPE_INVALID};\n+\tvector<duckdb_type> child_types_2 = {DUCKDB_TYPE_INVALID, DUCKDB_TYPE_INVALID, DUCKDB_TYPE_INTEGER,\n+\t                                     DUCKDB_TYPE_INVALID};\n+\tfor (idx_t i = 0; i < result->ColumnCount(); i++) {\n+\t\tauto logical_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(chunk->GetChunk(), i));\n+\t\tREQUIRE(logical_type);\n+\t\tREQUIRE(duckdb_get_type_id(logical_type) == types[i]);\n+\n+\t\tauto child_type = duckdb_list_type_child_type(logical_type);\n+\t\tauto child_type_2 = duckdb_list_type_child_type(child_type);\n+\n+\t\tREQUIRE(duckdb_get_type_id(child_type) == child_types_1[i]);\n+\t\tREQUIRE(duckdb_get_type_id(child_type_2) == child_types_2[i]);\n+\n+\t\tduckdb_destroy_logical_type(&child_type);\n+\t\tduckdb_destroy_logical_type(&child_type_2);\n+\t\tduckdb_destroy_logical_type(&logical_type);\n+\t}\n+\tREQUIRE(duckdb_list_type_child_type(nullptr) == nullptr);\n+}\n+\n+TEST_CASE(\"Test struct types C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\tresult = tester.Query(\"select {'a': 42::int}, {'b': 'hello', 'c': [1, 2, 3]}, {'d': {'e': 42}}, 3::int\");\n+\tREQUIRE(NO_FAIL(*result));\n+\tREQUIRE(result->ColumnCount() == 4);\n+\tREQUIRE(result->ErrorMessage() == nullptr);\n+\n+\t// fetch the first chunk\n+\tREQUIRE(result->ChunkCount() == 1);\n+\tauto chunk = result->FetchChunk(0);\n+\tREQUIRE(chunk);\n+\n+\tvector<duckdb_type> types = {DUCKDB_TYPE_STRUCT, DUCKDB_TYPE_STRUCT, DUCKDB_TYPE_STRUCT, DUCKDB_TYPE_INTEGER};\n+\tvector<idx_t> child_count = {1, 2, 1, 0};\n+\tvector<vector<string>> child_names = {{\"a\"}, {\"b\", \"c\"}, {\"d\"}, {}};\n+\tvector<vector<duckdb_type>> child_types = {\n+\t    {DUCKDB_TYPE_INTEGER}, {DUCKDB_TYPE_VARCHAR, DUCKDB_TYPE_LIST}, {DUCKDB_TYPE_STRUCT}, {}};\n+\tfor (idx_t i = 0; i < result->ColumnCount(); i++) {\n+\t\tauto logical_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(chunk->GetChunk(), i));\n+\t\tREQUIRE(logical_type);\n+\t\tREQUIRE(duckdb_get_type_id(logical_type) == types[i]);\n+\n+\t\tREQUIRE(duckdb_struct_type_child_count(logical_type) == child_count[i]);\n+\t\tfor (idx_t c_idx = 0; c_idx < child_count[i]; c_idx++) {\n+\t\t\tauto val = duckdb_struct_type_child_name(logical_type, c_idx);\n+\t\t\tstring str_val(val);\n+\t\t\tduckdb_free(val);\n+\n+\t\t\tREQUIRE(child_names[i][c_idx] == str_val);\n+\n+\t\t\tauto child_type = duckdb_struct_type_child_type(logical_type, c_idx);\n+\t\t\tREQUIRE(duckdb_get_type_id(child_type) == child_types[i][c_idx]);\n+\t\t\tduckdb_destroy_logical_type(&child_type);\n+\t\t}\n+\n+\t\tduckdb_destroy_logical_type(&logical_type);\n+\t}\n+\tREQUIRE(duckdb_struct_type_child_count(nullptr) == 0);\n+\tREQUIRE(duckdb_struct_type_child_name(nullptr, 0) == nullptr);\n+\tREQUIRE(duckdb_struct_type_child_type(nullptr, 0) == nullptr);\n+}\ndiff --git a/test/api/capi/test_capi_data_chunk.cpp b/test/api/capi/test_capi_data_chunk.cpp\nnew file mode 100644\nindex 000000000000..795941b7f4fd\n--- /dev/null\n+++ b/test/api/capi/test_capi_data_chunk.cpp\n@@ -0,0 +1,158 @@\n+#include \"capi_tester.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+TEST_CASE(\"Test Logical Types C API\", \"[capi]\") {\n+\tduckdb_logical_type type = duckdb_create_logical_type(DUCKDB_TYPE_BIGINT);\n+\tREQUIRE(type);\n+\tREQUIRE(duckdb_get_type_id(type) == DUCKDB_TYPE_BIGINT);\n+\tduckdb_destroy_logical_type(&type);\n+\tduckdb_destroy_logical_type(&type);\n+\n+\tduckdb_destroy_logical_type(nullptr);\n+}\n+\n+TEST_CASE(\"Test DataChunk C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\tduckdb_state status;\n+\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\n+\tREQUIRE(duckdb_vector_size() == STANDARD_VECTOR_SIZE);\n+\n+\ttester.Query(\"CREATE TABLE test(i BIGINT, j SMALLINT)\");\n+\n+\tduckdb_logical_type types[2];\n+\ttypes[0] = duckdb_create_logical_type(DUCKDB_TYPE_BIGINT);\n+\ttypes[1] = duckdb_create_logical_type(DUCKDB_TYPE_SMALLINT);\n+\n+\tauto data_chunk = duckdb_create_data_chunk(types, 2);\n+\tREQUIRE(data_chunk);\n+\n+\tREQUIRE(duckdb_data_chunk_get_column_count(data_chunk) == 2);\n+\n+\tauto first_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(data_chunk, 0));\n+\tREQUIRE(duckdb_get_type_id(first_type) == DUCKDB_TYPE_BIGINT);\n+\tduckdb_destroy_logical_type(&first_type);\n+\n+\tauto second_type = duckdb_vector_get_column_type(duckdb_data_chunk_get_vector(data_chunk, 1));\n+\tREQUIRE(duckdb_get_type_id(second_type) == DUCKDB_TYPE_SMALLINT);\n+\tduckdb_destroy_logical_type(&second_type);\n+\n+\tREQUIRE(duckdb_data_chunk_get_vector(data_chunk, 999) == nullptr);\n+\tREQUIRE(duckdb_data_chunk_get_vector(nullptr, 0) == nullptr);\n+\tREQUIRE(duckdb_vector_get_column_type(nullptr) == nullptr);\n+\n+\tREQUIRE(duckdb_data_chunk_get_size(data_chunk) == 0);\n+\tREQUIRE(duckdb_data_chunk_get_size(nullptr) == 0);\n+\n+\t// use the appender to insert a value using the data chunk API\n+\n+\tduckdb_appender appender;\n+\tstatus = duckdb_appender_create(tester.connection, nullptr, \"test\", &appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\t// append standard primitive values\n+\tauto col1_ptr = (int64_t *)duckdb_vector_get_data(duckdb_data_chunk_get_vector(data_chunk, 0));\n+\t*col1_ptr = 42;\n+\tauto col2_ptr = (int16_t *)duckdb_vector_get_data(duckdb_data_chunk_get_vector(data_chunk, 1));\n+\t*col2_ptr = 84;\n+\n+\tREQUIRE(duckdb_vector_get_data(nullptr) == nullptr);\n+\n+\tduckdb_data_chunk_set_size(data_chunk, 1);\n+\tREQUIRE(duckdb_data_chunk_get_size(data_chunk) == 1);\n+\n+\tREQUIRE(duckdb_append_data_chunk(appender, data_chunk) == DuckDBSuccess);\n+\tREQUIRE(duckdb_append_data_chunk(appender, nullptr) == DuckDBError);\n+\tREQUIRE(duckdb_append_data_chunk(nullptr, data_chunk) == DuckDBError);\n+\n+\t// append nulls\n+\tduckdb_data_chunk_reset(data_chunk);\n+\tREQUIRE(duckdb_data_chunk_get_size(data_chunk) == 0);\n+\n+\tduckdb_vector_ensure_validity_writable(duckdb_data_chunk_get_vector(data_chunk, 0));\n+\tduckdb_vector_ensure_validity_writable(duckdb_data_chunk_get_vector(data_chunk, 1));\n+\tauto col1_validity = duckdb_vector_get_validity(duckdb_data_chunk_get_vector(data_chunk, 0));\n+\tREQUIRE(duckdb_validity_row_is_valid(col1_validity, 0));\n+\tduckdb_validity_set_row_validity(col1_validity, 0, false);\n+\tREQUIRE(!duckdb_validity_row_is_valid(col1_validity, 0));\n+\n+\tauto col2_validity = duckdb_vector_get_validity(duckdb_data_chunk_get_vector(data_chunk, 1));\n+\tREQUIRE(col2_validity);\n+\tREQUIRE(duckdb_validity_row_is_valid(col2_validity, 0));\n+\tduckdb_validity_set_row_validity(col2_validity, 0, false);\n+\tREQUIRE(!duckdb_validity_row_is_valid(col2_validity, 0));\n+\n+\tduckdb_data_chunk_set_size(data_chunk, 1);\n+\tREQUIRE(duckdb_data_chunk_get_size(data_chunk) == 1);\n+\n+\tREQUIRE(duckdb_append_data_chunk(appender, data_chunk) == DuckDBSuccess);\n+\n+\tREQUIRE(duckdb_vector_get_validity(nullptr) == nullptr);\n+\n+\tduckdb_appender_destroy(&appender);\n+\n+\tresult = tester.Query(\"SELECT * FROM test\");\n+\tREQUIRE_NO_FAIL(*result);\n+\tREQUIRE(result->Fetch<int64_t>(0, 0) == 42);\n+\tREQUIRE(result->Fetch<int16_t>(1, 0) == 84);\n+\tREQUIRE(result->IsNull(0, 1));\n+\tREQUIRE(result->IsNull(1, 1));\n+\n+\tduckdb_data_chunk_reset(data_chunk);\n+\tduckdb_data_chunk_reset(nullptr);\n+\tREQUIRE(duckdb_data_chunk_get_size(data_chunk) == 0);\n+\n+\tduckdb_destroy_data_chunk(&data_chunk);\n+\tduckdb_destroy_data_chunk(&data_chunk);\n+\n+\tduckdb_destroy_data_chunk(nullptr);\n+\n+\tduckdb_destroy_logical_type(&types[0]);\n+\tduckdb_destroy_logical_type(&types[1]);\n+}\n+\n+TEST_CASE(\"Test DataChunk result fetch in C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\n+\tif (duckdb_vector_size() < 64) {\n+\t\treturn;\n+\t}\n+\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\n+\t// fetch a small result set\n+\tresult = tester.Query(\"SELECT CASE WHEN i=1 THEN NULL ELSE i::INTEGER END i FROM range(3) tbl(i)\");\n+\tREQUIRE(NO_FAIL(*result));\n+\tREQUIRE(result->ColumnCount() == 1);\n+\tREQUIRE(result->row_count() == 3);\n+\tREQUIRE(result->ErrorMessage() == nullptr);\n+\n+\t// fetch the first chunk\n+\tREQUIRE(result->ChunkCount() == 1);\n+\tauto chunk = result->FetchChunk(0);\n+\tREQUIRE(chunk);\n+\n+\tREQUIRE(chunk->ColumnCount() == 1);\n+\tREQUIRE(chunk->size() == 3);\n+\n+\tauto data = (int32_t *)chunk->GetData(0);\n+\tauto validity = chunk->GetValidity(0);\n+\tREQUIRE(data[0] == 0);\n+\tREQUIRE(data[2] == 2);\n+\tREQUIRE(duckdb_validity_row_is_valid(validity, 0));\n+\tREQUIRE(!duckdb_validity_row_is_valid(validity, 1));\n+\tREQUIRE(duckdb_validity_row_is_valid(validity, 2));\n+\n+\t// after fetching a chunk, we cannot use the old API anymore\n+\tREQUIRE(result->ColumnData<int32_t>(0) == nullptr);\n+\tREQUIRE(result->Fetch<int32_t>(0, 1) == 0);\n+\n+\t// result set is exhausted!\n+\tchunk = result->FetchChunk(1);\n+\tREQUIRE(!chunk);\n+}\ndiff --git a/test/api/capi/test_capi_prepared.cpp b/test/api/capi/test_capi_prepared.cpp\nnew file mode 100644\nindex 000000000000..b20ab3b5bfa6\n--- /dev/null\n+++ b/test/api/capi/test_capi_prepared.cpp\n@@ -0,0 +1,245 @@\n+#include \"capi_tester.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+TEST_CASE(\"Test prepared statements in C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\tduckdb_result res;\n+\tduckdb_prepared_statement stmt = nullptr;\n+\tduckdb_state status;\n+\n+\t// open the database in in-memory mode\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\n+\tstatus = duckdb_prepare(tester.connection, \"SELECT CAST($1 AS BIGINT)\", &stmt);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(stmt != nullptr);\n+\n+\tstatus = duckdb_bind_boolean(stmt, 1, 1);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tstatus = duckdb_bind_boolean(stmt, 2, 1);\n+\tREQUIRE(status == DuckDBError);\n+\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 1);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_int8(stmt, 1, 8);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 8);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_int16(stmt, 1, 16);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 16);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_int32(stmt, 1, 32);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 32);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_int64(stmt, 1, 64);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 64);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_hugeint(stmt, 1, duckdb_double_to_hugeint(64));\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_hugeint_to_double(duckdb_value_hugeint(&res, 0, 0)) == 64.0);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_uint8(stmt, 1, 8);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_uint8(&res, 0, 0) == 8);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_uint16(stmt, 1, 8);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_uint16(&res, 0, 0) == 8);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_uint32(stmt, 1, 8);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_uint32(&res, 0, 0) == 8);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_uint64(stmt, 1, 8);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_uint64(&res, 0, 0) == 8);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_float(stmt, 1, 42.0);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 42);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_double(stmt, 1, 43.0);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 43);\n+\tduckdb_destroy_result(&res);\n+\n+\tREQUIRE(duckdb_bind_float(stmt, 1, NAN) == DuckDBError);\n+\tREQUIRE(duckdb_bind_double(stmt, 1, NAN) == DuckDBError);\n+\n+\tREQUIRE(duckdb_bind_varchar(stmt, 1, \"\\x80\\x40\\x41\") == DuckDBError);\n+\tduckdb_bind_varchar(stmt, 1, \"44\");\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_int64(&res, 0, 0) == 44);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_null(stmt, 1);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_nullmask_data(&res, 0)[0] == true);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_destroy_prepare(&stmt);\n+\t// again to make sure it does not crash\n+\tduckdb_destroy_result(&res);\n+\tduckdb_destroy_prepare(&stmt);\n+\n+\tstatus = duckdb_prepare(tester.connection, \"SELECT CAST($1 AS VARCHAR)\", &stmt);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(stmt != nullptr);\n+\n+\tREQUIRE(duckdb_bind_varchar_length(stmt, 1, \"\\x00\\x40\\x41\", 3) == DuckDBError);\n+\tduckdb_bind_varchar_length(stmt, 1, \"hello world\", 5);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tauto value = duckdb_value_varchar(&res, 0, 0);\n+\tREQUIRE(string(value) == \"hello\");\n+\tREQUIRE(duckdb_value_int8(&res, 0, 0) == 0);\n+\tduckdb_free(value);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_blob(stmt, 1, \"hello\\0world\", 11);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tvalue = duckdb_value_varchar(&res, 0, 0);\n+\tREQUIRE(string(value) == \"hello\\\\x00world\");\n+\tREQUIRE(duckdb_value_int8(&res, 0, 0) == 0);\n+\tduckdb_free(value);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_date_struct date_struct;\n+\tdate_struct.year = 1992;\n+\tdate_struct.month = 9;\n+\tdate_struct.day = 3;\n+\n+\tduckdb_bind_date(stmt, 1, duckdb_to_date(date_struct));\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tvalue = duckdb_value_varchar(&res, 0, 0);\n+\tREQUIRE(string(value) == \"1992-09-03\");\n+\tduckdb_free(value);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_time_struct time_struct;\n+\ttime_struct.hour = 12;\n+\ttime_struct.min = 22;\n+\ttime_struct.sec = 33;\n+\ttime_struct.micros = 123400;\n+\n+\tduckdb_bind_time(stmt, 1, duckdb_to_time(time_struct));\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tvalue = duckdb_value_varchar(&res, 0, 0);\n+\tREQUIRE(string(value) == \"12:22:33.1234\");\n+\tduckdb_free(value);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_timestamp_struct ts;\n+\tts.date = date_struct;\n+\tts.time = time_struct;\n+\n+\tduckdb_bind_timestamp(stmt, 1, duckdb_to_timestamp(ts));\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tvalue = duckdb_value_varchar(&res, 0, 0);\n+\tREQUIRE(string(value) == \"1992-09-03 12:22:33.1234\");\n+\tduckdb_free(value);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_interval interval;\n+\tinterval.months = 3;\n+\tinterval.days = 0;\n+\tinterval.micros = 0;\n+\n+\tduckdb_bind_interval(stmt, 1, interval);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tvalue = duckdb_value_varchar(&res, 0, 0);\n+\tREQUIRE(string(value) == \"3 months\");\n+\tduckdb_free(value);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_destroy_prepare(&stmt);\n+\n+\tstatus = duckdb_query(tester.connection, \"CREATE TABLE a (i INTEGER)\", NULL);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_prepare(tester.connection, \"INSERT INTO a VALUES (?)\", &stmt);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(stmt != nullptr);\n+\tREQUIRE(duckdb_nparams(nullptr) == 0);\n+\tREQUIRE(duckdb_nparams(stmt) == 1);\n+\tREQUIRE(duckdb_param_type(nullptr, 0) == DUCKDB_TYPE_INVALID);\n+\tREQUIRE(duckdb_param_type(stmt, 0) == DUCKDB_TYPE_INVALID);\n+\tREQUIRE(duckdb_param_type(stmt, 1) == DUCKDB_TYPE_INTEGER);\n+\tREQUIRE(duckdb_param_type(stmt, 2) == DUCKDB_TYPE_INVALID);\n+\n+\tfor (int32_t i = 1; i <= 1000; i++) {\n+\t\tduckdb_bind_int32(stmt, 1, i);\n+\t\tstatus = duckdb_execute_prepared(stmt, nullptr);\n+\t\tREQUIRE(status == DuckDBSuccess);\n+\t}\n+\tduckdb_destroy_prepare(&stmt);\n+\n+\tstatus = duckdb_prepare(tester.connection, \"SELECT SUM(i)*$1-$2 FROM a\", &stmt);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(stmt != nullptr);\n+\tduckdb_bind_int32(stmt, 1, 2);\n+\tduckdb_bind_int32(stmt, 2, 1000);\n+\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_int32(&res, 0, 0) == 1000000);\n+\tduckdb_destroy_result(&res);\n+\tduckdb_destroy_prepare(&stmt);\n+\n+\t// not-so-happy path\n+\tstatus = duckdb_prepare(tester.connection, \"SELECT XXXXX\", &stmt);\n+\tREQUIRE(status == DuckDBError);\n+\tduckdb_destroy_prepare(&stmt);\n+\n+\tstatus = duckdb_prepare(tester.connection, \"SELECT CAST($1 AS INTEGER)\", &stmt);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(stmt != nullptr);\n+\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBError);\n+\tduckdb_destroy_result(&res);\n+\tduckdb_destroy_prepare(&stmt);\n+\n+\t// test duckdb_malloc explicitly\n+\tauto malloced_data = duckdb_malloc(100);\n+\tmemcpy(malloced_data, \"hello\\0\", 6);\n+\tREQUIRE(string((char *)malloced_data) == \"hello\");\n+\tduckdb_free(malloced_data);\n+}\ndiff --git a/test/api/capi/test_capi_replacement_scan.cpp b/test/api/capi/test_capi_replacement_scan.cpp\nnew file mode 100644\nindex 000000000000..c3d0c7a4d981\n--- /dev/null\n+++ b/test/api/capi/test_capi_replacement_scan.cpp\n@@ -0,0 +1,62 @@\n+#include \"capi_tester.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+struct MyBaseNumber {\n+\tint number;\n+};\n+\n+void destroy_base_number(void *data) {\n+\tauto num = (MyBaseNumber *)data;\n+\tdelete num;\n+}\n+\n+void number_scanner(duckdb_replacement_scan_info info, const char *table_name, void *data) {\n+\t// check if the table name is a number\n+\tlong long number;\n+\ttry {\n+\t\tnumber = std::stoll(table_name);\n+\t} catch (...) {\n+\t\t// not a number!\n+\t\treturn;\n+\t}\n+\tauto num_data = (MyBaseNumber *)data;\n+\tduckdb_replacement_scan_set_function_name(info, \"range\");\n+\tauto val = duckdb_create_int64(number + num_data->number);\n+\tduckdb_replacement_scan_add_parameter(info, val);\n+\tduckdb_destroy_value(&val);\n+}\n+\n+TEST_CASE(\"Test replacement scans in C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\n+\t// open the database in in-memory mode\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\n+\tauto base_number = new MyBaseNumber();\n+\tbase_number->number = 3;\n+\n+\tduckdb_add_replacement_scan(tester.database, number_scanner, (void *)base_number, destroy_base_number);\n+\n+\t// 0-4\n+\tresult = tester.Query(\"SELECT * FROM \\\"2\\\"\");\n+\tREQUIRE(result->row_count() == 5);\n+\tREQUIRE(result->Fetch<int64_t>(0, 0) == 0);\n+\tREQUIRE(result->Fetch<int64_t>(0, 1) == 1);\n+\tREQUIRE(result->Fetch<int64_t>(0, 2) == 2);\n+\tREQUIRE(result->Fetch<int64_t>(0, 3) == 3);\n+\tREQUIRE(result->Fetch<int64_t>(0, 4) == 4);\n+\n+\tbase_number->number = 1;\n+\t// 0-2\n+\tresult = tester.Query(\"SELECT * FROM \\\"2\\\"\");\n+\tREQUIRE(result->row_count() == 3);\n+\tREQUIRE(result->Fetch<int64_t>(0, 0) == 0);\n+\tREQUIRE(result->Fetch<int64_t>(0, 1) == 1);\n+\tREQUIRE(result->Fetch<int64_t>(0, 2) == 2);\n+\n+\t// not a number\n+\tREQUIRE_FAIL(tester.Query(\"SELECT * FROM nonexistant\"));\n+}\ndiff --git a/test/api/capi/test_capi_website.cpp b/test/api/capi/test_capi_website.cpp\nnew file mode 100644\nindex 000000000000..42d6c2350fea\n--- /dev/null\n+++ b/test/api/capi/test_capi_website.cpp\n@@ -0,0 +1,187 @@\n+#include \"capi_tester.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+TEST_CASE(\"Test C API examples from the website\", \"[capi]\") {\n+\t// NOTE: if any of these break and need to be changed, the website also needs to be updated!\n+\tSECTION(\"connect\") {\n+\t\tduckdb_database db;\n+\t\tduckdb_connection con;\n+\n+\t\tif (duckdb_open(NULL, &db) == DuckDBError) {\n+\t\t\t// handle error\n+\t\t}\n+\t\tif (duckdb_connect(db, &con) == DuckDBError) {\n+\t\t\t// handle error\n+\t\t}\n+\n+\t\t// run queries...\n+\n+\t\t// cleanup\n+\t\tduckdb_disconnect(&con);\n+\t\tduckdb_close(&db);\n+\t}\n+\tSECTION(\"config\") {\n+\t\tduckdb_database db;\n+\t\tduckdb_config config;\n+\n+\t\t// create the configuration object\n+\t\tif (duckdb_create_config(&config) == DuckDBError) {\n+\t\t\tREQUIRE(1 == 0);\n+\t\t}\n+\t\t// set some configuration options\n+\t\tduckdb_set_config(config, \"access_mode\", \"READ_WRITE\");\n+\t\tduckdb_set_config(config, \"threads\", \"8\");\n+\t\tduckdb_set_config(config, \"max_memory\", \"8GB\");\n+\t\tduckdb_set_config(config, \"default_order\", \"DESC\");\n+\n+\t\t// open the database using the configuration\n+\t\tif (duckdb_open_ext(NULL, &db, config, NULL) == DuckDBError) {\n+\t\t\tREQUIRE(1 == 0);\n+\t\t}\n+\t\t// cleanup the configuration object\n+\t\tduckdb_destroy_config(&config);\n+\n+\t\t// run queries...\n+\n+\t\t// cleanup\n+\t\tduckdb_close(&db);\n+\t}\n+\tSECTION(\"query\") {\n+\t\tduckdb_database db;\n+\t\tduckdb_connection con;\n+\t\tduckdb_state state;\n+\t\tduckdb_result result;\n+\n+\t\tduckdb_open(NULL, &db);\n+\t\tduckdb_connect(db, &con);\n+\n+\t\t// create a table\n+\t\tstate = duckdb_query(con, \"CREATE TABLE integers(i INTEGER, j INTEGER);\", NULL);\n+\t\tif (state == DuckDBError) {\n+\t\t\tREQUIRE(1 == 0);\n+\t\t}\n+\t\t// insert three rows into the table\n+\t\tstate = duckdb_query(con, \"INSERT INTO integers VALUES (3, 4), (5, 6), (7, NULL);\", NULL);\n+\t\tif (state == DuckDBError) {\n+\t\t\tREQUIRE(1 == 0);\n+\t\t}\n+\t\t// query rows again\n+\t\tstate = duckdb_query(con, \"SELECT * FROM integers\", &result);\n+\t\tif (state == DuckDBError) {\n+\t\t\tREQUIRE(1 == 0);\n+\t\t}\n+\t\t// handle the result\n+\t\tidx_t row_count = duckdb_row_count(&result);\n+\t\tidx_t column_count = duckdb_column_count(&result);\n+\t\tfor (idx_t row = 0; row < row_count; row++) {\n+\t\t\tfor (idx_t col = 0; col < column_count; col++) {\n+\t\t\t\t// if (col > 0) printf(\",\");\n+\t\t\t\tauto str_val = duckdb_value_varchar(&result, col, row);\n+\t\t\t\t// printf(\"%s\", str_val);\n+\t\t\t\tREQUIRE(1 == 1);\n+\t\t\t\tduckdb_free(str_val);\n+\t\t\t}\n+\t\t\t//\tprintf(\"\\n\");\n+\t\t}\n+\n+\t\tint32_t *i_data = (int32_t *)duckdb_column_data(&result, 0);\n+\t\tint32_t *j_data = (int32_t *)duckdb_column_data(&result, 1);\n+\t\tbool *i_mask = duckdb_nullmask_data(&result, 0);\n+\t\tbool *j_mask = duckdb_nullmask_data(&result, 1);\n+\t\tfor (idx_t row = 0; row < row_count; row++) {\n+\t\t\tif (i_mask[row]) {\n+\t\t\t\t// printf(\"NULL\");\n+\t\t\t} else {\n+\t\t\t\tREQUIRE(i_data[row] > 0);\n+\t\t\t\t// printf(\"%d\", i_data[row]);\n+\t\t\t}\n+\t\t\t// printf(\",\");\n+\t\t\tif (j_mask[row]) {\n+\t\t\t\t// printf(\"NULL\");\n+\t\t\t} else {\n+\t\t\t\tREQUIRE(j_data[row] > 0);\n+\t\t\t\t// printf(\"%d\", j_data[row]);\n+\t\t\t}\n+\t\t\t// printf(\"\\n\");\n+\t\t}\n+\n+\t\t// destroy the result after we are done with it\n+\t\tduckdb_destroy_result(&result);\n+\t\tduckdb_disconnect(&con);\n+\t\tduckdb_close(&db);\n+\t}\n+\tSECTION(\"prepared\") {\n+\t\tduckdb_database db;\n+\t\tduckdb_connection con;\n+\t\tduckdb_open(NULL, &db);\n+\t\tduckdb_connect(db, &con);\n+\t\tduckdb_query(con, \"CREATE TABLE integers(i INTEGER, j INTEGER)\", NULL);\n+\n+\t\tduckdb_prepared_statement stmt;\n+\t\tduckdb_result result;\n+\t\tif (duckdb_prepare(con, \"INSERT INTO integers VALUES ($1, $2)\", &stmt) == DuckDBError) {\n+\t\t\tREQUIRE(1 == 0);\n+\t\t}\n+\n+\t\tduckdb_bind_int32(stmt, 1, 42); // the parameter index starts counting at 1!\n+\t\tduckdb_bind_int32(stmt, 2, 43);\n+\t\t// NULL as second parameter means no result set is requested\n+\t\tduckdb_execute_prepared(stmt, NULL);\n+\t\tduckdb_destroy_prepare(&stmt);\n+\n+\t\t// we can also query result sets using prepared statements\n+\t\tif (duckdb_prepare(con, \"SELECT * FROM integers WHERE i = ?\", &stmt) == DuckDBError) {\n+\t\t\tREQUIRE(1 == 0);\n+\t\t}\n+\t\tduckdb_bind_int32(stmt, 1, 42);\n+\t\tduckdb_execute_prepared(stmt, &result);\n+\n+\t\t// do something with result\n+\n+\t\t// clean up\n+\t\tduckdb_destroy_result(&result);\n+\t\tduckdb_destroy_prepare(&stmt);\n+\n+\t\tduckdb_disconnect(&con);\n+\t\tduckdb_close(&db);\n+\t}\n+\tSECTION(\"appender\") {\n+\t\tduckdb_database db;\n+\t\tduckdb_connection con;\n+\t\tduckdb_open(NULL, &db);\n+\t\tduckdb_connect(db, &con);\n+\t\tduckdb_query(con, \"CREATE TABLE people(id INTEGER, name VARCHAR)\", NULL);\n+\n+\t\tduckdb_appender appender;\n+\t\tif (duckdb_appender_create(con, NULL, \"people\", &appender) == DuckDBError) {\n+\t\t\tREQUIRE(1 == 0);\n+\t\t}\n+\t\tduckdb_append_int32(appender, 1);\n+\t\tduckdb_append_varchar(appender, \"Mark\");\n+\t\tduckdb_appender_end_row(appender);\n+\n+\t\tduckdb_append_int32(appender, 2);\n+\t\tduckdb_append_varchar(appender, \"Hannes\");\n+\t\tduckdb_appender_end_row(appender);\n+\n+\t\tduckdb_appender_destroy(&appender);\n+\n+\t\tduckdb_result result;\n+\t\tduckdb_query(con, \"SELECT * FROM people\", &result);\n+\t\tREQUIRE(duckdb_value_int32(&result, 0, 0) == 1);\n+\t\tREQUIRE(duckdb_value_int32(&result, 0, 1) == 2);\n+\t\tREQUIRE(string(duckdb_value_varchar_internal(&result, 1, 0)) == \"Mark\");\n+\t\tREQUIRE(string(duckdb_value_varchar_internal(&result, 1, 1)) == \"Hannes\");\n+\n+\t\t// error conditions: we cannot\n+\t\tREQUIRE(duckdb_value_varchar_internal(&result, 0, 0) == nullptr);\n+\t\tREQUIRE(duckdb_value_varchar_internal(nullptr, 0, 0) == nullptr);\n+\n+\t\tduckdb_destroy_result(&result);\n+\n+\t\tduckdb_disconnect(&con);\n+\t\tduckdb_close(&db);\n+\t}\n+}\ndiff --git a/test/helpers/CMakeLists.txt b/test/helpers/CMakeLists.txt\nindex 37171ba6ae1d..914488596538 100644\n--- a/test/helpers/CMakeLists.txt\n+++ b/test/helpers/CMakeLists.txt\n@@ -1,4 +1,5 @@\n-set(DUCKDB_TEST_HELPERS_UNITS test_helpers.cpp test_helper_extension.cpp)\n+set(DUCKDB_TEST_HELPERS_UNITS test_helpers.cpp test_helper_extension.cpp\n+                              capi_tester.cpp)\n \n add_library(test_helpers STATIC ${DUCKDB_TEST_HELPERS_UNITS})\n \ndiff --git a/test/helpers/capi_tester.cpp b/test/helpers/capi_tester.cpp\nnew file mode 100644\nindex 000000000000..1054da40f465\n--- /dev/null\n+++ b/test/helpers/capi_tester.cpp\n@@ -0,0 +1,133 @@\n+#include \"capi_tester.hpp\"\n+\n+bool NO_FAIL(duckdb::CAPIResult &result) {\n+\treturn result.success;\n+}\n+\n+bool NO_FAIL(duckdb::unique_ptr<duckdb::CAPIResult> result) {\n+\treturn NO_FAIL(*result);\n+}\n+\n+namespace duckdb {\n+\n+template <>\n+bool CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_boolean(&result, col, row);\n+}\n+\n+template <>\n+int8_t CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_int8(&result, col, row);\n+}\n+\n+template <>\n+int16_t CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_int16(&result, col, row);\n+}\n+\n+template <>\n+int32_t CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_int32(&result, col, row);\n+}\n+\n+template <>\n+int64_t CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_int64(&result, col, row);\n+}\n+\n+template <>\n+uint8_t CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_uint8(&result, col, row);\n+}\n+\n+template <>\n+uint16_t CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_uint16(&result, col, row);\n+}\n+\n+template <>\n+uint32_t CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_uint32(&result, col, row);\n+}\n+\n+template <>\n+uint64_t CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_uint64(&result, col, row);\n+}\n+\n+template <>\n+float CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_float(&result, col, row);\n+}\n+\n+template <>\n+double CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_double(&result, col, row);\n+}\n+\n+template <>\n+duckdb_decimal CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_decimal(&result, col, row);\n+}\n+\n+template <>\n+duckdb_date CAPIResult::Fetch(idx_t col, idx_t row) {\n+\tauto data = (duckdb_date *)duckdb_column_data(&result, col);\n+\treturn data[row];\n+}\n+\n+template <>\n+duckdb_time CAPIResult::Fetch(idx_t col, idx_t row) {\n+\tauto data = (duckdb_time *)duckdb_column_data(&result, col);\n+\treturn data[row];\n+}\n+\n+template <>\n+duckdb_timestamp CAPIResult::Fetch(idx_t col, idx_t row) {\n+\tauto data = (duckdb_timestamp *)duckdb_column_data(&result, col);\n+\treturn data[row];\n+}\n+\n+template <>\n+duckdb_interval CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_interval(&result, col, row);\n+}\n+\n+template <>\n+duckdb_blob CAPIResult::Fetch(idx_t col, idx_t row) {\n+\tauto data = (duckdb_blob *)duckdb_column_data(&result, col);\n+\treturn data[row];\n+}\n+\n+template <>\n+string CAPIResult::Fetch(idx_t col, idx_t row) {\n+\tauto value = duckdb_value_varchar(&result, col, row);\n+\tstring strval = value ? string(value) : string();\n+\tfree((void *)value);\n+\treturn strval;\n+}\n+\n+template <>\n+duckdb_date_struct CAPIResult::Fetch(idx_t col, idx_t row) {\n+\tauto value = duckdb_value_date(&result, col, row);\n+\treturn duckdb_from_date(value);\n+}\n+\n+template <>\n+duckdb_time_struct CAPIResult::Fetch(idx_t col, idx_t row) {\n+\tauto value = duckdb_value_time(&result, col, row);\n+\treturn duckdb_from_time(value);\n+}\n+\n+template <>\n+duckdb_timestamp_struct CAPIResult::Fetch(idx_t col, idx_t row) {\n+\tauto value = duckdb_value_timestamp(&result, col, row);\n+\treturn duckdb_from_timestamp(value);\n+}\n+\n+template <>\n+duckdb_hugeint CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_hugeint(&result, col, row);\n+}\n+\n+} // namespace duckdb\ndiff --git a/test/include/capi_tester.hpp b/test/include/capi_tester.hpp\nnew file mode 100644\nindex 000000000000..cd404ee4bc10\n--- /dev/null\n+++ b/test/include/capi_tester.hpp\n@@ -0,0 +1,207 @@\n+#pragma once\n+\n+#include \"catch.hpp\"\n+#include \"duckdb.h\"\n+#include \"test_helpers.hpp\"\n+#include \"duckdb/common/arrow.hpp\"\n+#include \"duckdb/common/exception.hpp\"\n+\n+namespace duckdb {\n+\n+class CAPIDataChunk {\n+public:\n+\tCAPIDataChunk(duckdb_data_chunk chunk_p) : chunk(chunk_p) {\n+\t}\n+\t~CAPIDataChunk() {\n+\t\tduckdb_destroy_data_chunk(&chunk);\n+\t}\n+\n+\tidx_t ColumnCount() {\n+\t\treturn duckdb_data_chunk_get_column_count(chunk);\n+\t}\n+\tidx_t size() {\n+\t\treturn duckdb_data_chunk_get_size(chunk);\n+\t}\n+\tduckdb_vector GetVector(idx_t col) {\n+\t\treturn duckdb_data_chunk_get_vector(chunk, col);\n+\t}\n+\tvoid *GetData(idx_t col) {\n+\t\treturn duckdb_vector_get_data(GetVector(col));\n+\t}\n+\tuint64_t *GetValidity(idx_t col) {\n+\t\treturn duckdb_vector_get_validity(GetVector(col));\n+\t}\n+\tduckdb_data_chunk GetChunk() {\n+\t\treturn chunk;\n+\t}\n+\n+private:\n+\tduckdb_data_chunk chunk;\n+};\n+\n+class CAPIResult {\n+public:\n+\t~CAPIResult() {\n+\t\tduckdb_destroy_result(&result);\n+\t}\n+\tvoid Query(duckdb_connection connection, string query) {\n+\t\tsuccess = (duckdb_query(connection, query.c_str(), &result) == DuckDBSuccess);\n+\t\tif (!success) {\n+\t\t\tREQUIRE(ErrorMessage() != nullptr);\n+\t\t}\n+\t}\n+\n+\tduckdb_type ColumnType(idx_t col) {\n+\t\treturn duckdb_column_type(&result, col);\n+\t}\n+\n+\tidx_t ChunkCount() {\n+\t\treturn duckdb_result_chunk_count(result);\n+\t}\n+\n+\tunique_ptr<CAPIDataChunk> FetchChunk(idx_t chunk_idx) {\n+\t\tauto chunk = duckdb_result_get_chunk(result, chunk_idx);\n+\t\tif (!chunk) {\n+\t\t\treturn nullptr;\n+\t\t}\n+\t\treturn make_unique<CAPIDataChunk>(chunk);\n+\t}\n+\n+\ttemplate <class T>\n+\tT *ColumnData(idx_t col) {\n+\t\treturn (T *)duckdb_column_data(&result, col);\n+\t}\n+\n+\tidx_t ColumnCount() {\n+\t\treturn duckdb_column_count(&result);\n+\t}\n+\n+\tidx_t row_count() {\n+\t\treturn duckdb_row_count(&result);\n+\t}\n+\n+\tidx_t rows_changed() {\n+\t\treturn duckdb_rows_changed(&result);\n+\t}\n+\n+\ttemplate <class T>\n+\tT Fetch(idx_t col, idx_t row) {\n+\t\tthrow NotImplementedException(\"Unimplemented type for fetch\");\n+\t}\n+\n+\tbool IsNull(idx_t col, idx_t row) {\n+\t\tauto nullmask_ptr = duckdb_nullmask_data(&result, col);\n+\t\tREQUIRE(duckdb_value_is_null(&result, col, row) == nullmask_ptr[row]);\n+\t\treturn nullmask_ptr[row];\n+\t}\n+\n+\tconst char *ErrorMessage() {\n+\t\treturn duckdb_result_error(&result);\n+\t}\n+\n+\tstring ColumnName(idx_t col) {\n+\t\tauto colname = duckdb_column_name(&result, col);\n+\t\treturn colname ? string(colname) : string();\n+\t}\n+\n+\tduckdb_result &InternalResult() {\n+\t\treturn result;\n+\t}\n+\n+public:\n+\tbool success = false;\n+\n+private:\n+\tduckdb_result result;\n+};\n+\n+template <>\n+bool CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+int8_t CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+int16_t CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+int32_t CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+int64_t CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+uint8_t CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+uint16_t CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+uint32_t CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+uint64_t CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+float CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+double CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+duckdb_decimal CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+duckdb_date CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+duckdb_time CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+duckdb_timestamp CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+duckdb_interval CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+duckdb_blob CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+string CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+duckdb_date_struct CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+duckdb_time_struct CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+duckdb_timestamp_struct CAPIResult::Fetch(idx_t col, idx_t row);\n+template <>\n+duckdb_hugeint CAPIResult::Fetch(idx_t col, idx_t row);\n+\n+class CAPITester {\n+public:\n+\tCAPITester() : database(nullptr), connection(nullptr) {\n+\t}\n+\t~CAPITester() {\n+\t\tCleanup();\n+\t}\n+\n+\tvoid Cleanup() {\n+\t\tif (connection) {\n+\t\t\tduckdb_disconnect(&connection);\n+\t\t\tconnection = nullptr;\n+\t\t}\n+\t\tif (database) {\n+\t\t\tduckdb_close(&database);\n+\t\t\tdatabase = nullptr;\n+\t\t}\n+\t}\n+\n+\tbool OpenDatabase(const char *path) {\n+\t\tCleanup();\n+\t\tif (duckdb_open(path, &database) != DuckDBSuccess) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (duckdb_connect(database, &connection) != DuckDBSuccess) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tunique_ptr<CAPIResult> Query(string query) {\n+\t\tD_ASSERT(connection);\n+\t\tauto result = make_unique<CAPIResult>();\n+\t\tresult->Query(connection, query);\n+\t\treturn result;\n+\t}\n+\n+\tduckdb_database database = nullptr;\n+\tduckdb_connection connection = nullptr;\n+};\n+\n+} // namespace duckdb\n+\n+bool NO_FAIL(duckdb::CAPIResult &result);\n+bool NO_FAIL(duckdb::unique_ptr<duckdb::CAPIResult> result);\ndiff --git a/tools/juliapkg/test.sh b/tools/juliapkg/test.sh\nnew file mode 100755\nindex 000000000000..8b700f4fe94f\n--- /dev/null\n+++ b/tools/juliapkg/test.sh\n@@ -0,0 +1,8 @@\n+set -e\n+\n+#julia -e \"import Pkg; Pkg.activate(\\\".\\\"); Pkg.instantiate(); include(\\\"test/runtests.jl\\\")\" $1\n+\n+export JULIA_DUCKDB_LIBRARY=\"/Users/myth/Programs/duckdb-bugfix/build/debug/src/libduckdb.dylib\"\n+#export JULIA_DUCKDB_LIBRARY=\"/Users/myth/Programs/duckdb-bugfix/build/release/src/libduckdb.dylib\"\n+\n+julia -e \"import Pkg; Pkg.activate(\\\".\\\"); include(\\\"test/runtests.jl\\\")\" $1\ndiff --git a/tools/juliapkg/test/Project.toml b/tools/juliapkg/test/Project.toml\nnew file mode 100644\nindex 000000000000..ab19f1c36989\n--- /dev/null\n+++ b/tools/juliapkg/test/Project.toml\n@@ -0,0 +1,6 @@\n+[deps]\n+DBInterface = \"a10d1c49-ce27-4219-8d33-6db1a4562965\"\n+SQLite = \"0aa819cd-b072-5ff4-a722-6bc24af294d9\"\n+Tables = \"bd369af6-aec1-5ad0-b16a-f7cc5008161c\"\n+Test = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n+WeakRefStrings = \"ea10d353-3f73-51f8-a26c-33c1cb351aa5\"\ndiff --git a/tools/juliapkg/test/runtests.jl b/tools/juliapkg/test/runtests.jl\nnew file mode 100644\nindex 000000000000..a20ca3a02431\n--- /dev/null\n+++ b/tools/juliapkg/test/runtests.jl\n@@ -0,0 +1,35 @@\n+using DataFrames\n+using DuckDB\n+using Test\n+using Dates\n+using UUIDs\n+\n+test_files = [\n+    \"test_appender.jl\",\n+    \"test_basic_queries.jl\",\n+    \"test_config.jl\",\n+    \"test_connection.jl\",\n+    \"test_df_scan.jl\",\n+    \"test_prepare.jl\",\n+    \"test_transaction.jl\",\n+    \"test_sqlite.jl\",\n+    \"test_replacement_scan.jl\",\n+    \"test_table_function.jl\",\n+    \"test_old_interface.jl\",\n+    \"test_all_types.jl\"\n+]\n+\n+if size(ARGS)[1] > 0\n+    filtered_test_files = []\n+    for test_file in test_files\n+        if test_file == ARGS[1]\n+            push!(filtered_test_files, test_file)\n+        end\n+    end\n+    test_files = filtered_test_files\n+end\n+\n+for fname in test_files\n+    println(fname)\n+    include(fname)\n+end\ndiff --git a/tools/juliapkg/test/test_all_types.jl b/tools/juliapkg/test/test_all_types.jl\nnew file mode 100644\nindex 000000000000..a2c2769ae645\n--- /dev/null\n+++ b/tools/juliapkg/test/test_all_types.jl\n@@ -0,0 +1,132 @@\n+# test_all_types.jl\n+\n+\n+@testset \"Test All Types\" begin\n+    db = DBInterface.connect(DuckDB.DB)\n+    con = DBInterface.connect(db)\n+\n+    df = DataFrame(DBInterface.execute(con, \"SELECT * FROM test_all_types()\"))\n+\n+    @test isequal(df.bool, [false, true, missing])\n+    @test isequal(df.tinyint, [-128, 127, missing])\n+    @test isequal(df.smallint, [-32768, 32767, missing])\n+    @test isequal(df.int, [-2147483648, 2147483647, missing])\n+    @test isequal(df.bigint, [-9223372036854775808, 9223372036854775807, missing])\n+    @test isequal(\n+        df.hugeint,\n+        [-170141183460469231731687303715884105727, 170141183460469231731687303715884105727, missing]\n+    )\n+    @test isequal(df.utinyint, [0, 255, missing])\n+    @test isequal(df.usmallint, [0, 65535, missing])\n+    @test isequal(df.uint, [0, 4294967295, missing])\n+    @test isequal(df.ubigint, [0, 18446744073709551615, missing])\n+    @test isequal(df.float, [-3.4028235f38, 3.4028235f38, missing])\n+    @test isequal(df.double, [-1.7976931348623157e308, 1.7976931348623157e308, missing])\n+    @test isequal(df.dec_4_1, [-999.9, 999.9, missing])\n+    @test isequal(df.dec_9_4, [-99999.9999, 99999.9999, missing])\n+    @test isequal(df.dec_18_6, [-999999999999.999999, 999999999999.999999, missing])\n+    @test isequal(\n+        df.dec38_10,\n+        [-9999999999999999999999999999.9999999999, 9999999999999999999999999999.9999999999, missing]\n+    )\n+    @test isequal(\n+        df.dec38_10,\n+        [-9999999999999999999999999999.9999999999, 9999999999999999999999999999.9999999999, missing]\n+    )\n+    @test isequal(\n+        df.dec38_10,\n+        [-9999999999999999999999999999.9999999999, 9999999999999999999999999999.9999999999, missing]\n+    )\n+    @test isequal(df.json, [\"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\", \"goose\", missing])\n+    @test isequal(df.small_enum, [\"DUCK_DUCK_ENUM\", \"GOOSE\", missing])\n+    @test isequal(df.medium_enum, [\"enum_0\", \"enum_299\", missing])\n+    @test isequal(df.large_enum, [\"enum_0\", \"enum_69999\", missing])\n+    @test isequal(df.date, [Dates.Date(-5877641, 6, 23), Dates.Date(5881580, 7, 11), missing])\n+    @test isequal(df.time, [Dates.Time(0, 0, 0), Dates.Time(23, 59, 59, 999, 999), missing])\n+    @test isequal(df.time_tz, [Dates.Time(0, 0, 0), Dates.Time(23, 59, 59, 999, 999), missing])\n+    @test isequal(\n+        df.timestamp,\n+        [Dates.DateTime(-290308, 12, 22, 0, 0, 0), Dates.DateTime(294247, 1, 10, 4, 0, 54, 775), missing]\n+    )\n+    @test isequal(\n+        df.timestamp_tz,\n+        [Dates.DateTime(-290308, 12, 22, 0, 0, 0), Dates.DateTime(294247, 1, 10, 4, 0, 54, 775), missing]\n+    )\n+    @test isequal(\n+        df.timestamp_s,\n+        [Dates.DateTime(-290308, 12, 22, 0, 0, 0), Dates.DateTime(294247, 1, 10, 4, 0, 54, 0), missing]\n+    )\n+    @test isequal(\n+        df.timestamp_ms,\n+        [Dates.DateTime(-290308, 12, 22, 0, 0, 0), Dates.DateTime(294247, 1, 10, 4, 0, 54, 775), missing]\n+    )\n+    @test isequal(\n+        df.timestamp_ns,\n+        [Dates.DateTime(1677, 9, 21, 0, 12, 43, 146), Dates.DateTime(2262, 4, 11, 23, 47, 16, 854), missing]\n+    )\n+    @test isequal(\n+        df.interval,\n+        [\n+            Dates.CompoundPeriod(Dates.Month(0), Dates.Day(0), Dates.Microsecond(0)),\n+            Dates.CompoundPeriod(Dates.Month(999), Dates.Day(999), Dates.Microsecond(999999999)),\n+            missing\n+        ]\n+    )\n+    @test isequal(df.varchar, [\"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\", \"goose\", missing])\n+    @test isequal(\n+        df.blob,\n+        [\n+            UInt8[\n+                0x74,\n+                0x68,\n+                0x69,\n+                0x73,\n+                0x69,\n+                0x73,\n+                0x61,\n+                0x6c,\n+                0x6f,\n+                0x6e,\n+                0x67,\n+                0x62,\n+                0x6c,\n+                0x6f,\n+                0x62,\n+                0x00,\n+                0x77,\n+                0x69,\n+                0x74,\n+                0x68,\n+                0x6e,\n+                0x75,\n+                0x6c,\n+                0x6c,\n+                0x62,\n+                0x79,\n+                0x74,\n+                0x65,\n+                0x73\n+            ],\n+            UInt8[0x5c, 0x78, 0x30, 0x30, 0x5c, 0x78, 0x30, 0x30, 0x5c, 0x78, 0x30, 0x30, 0x61],\n+            missing\n+        ]\n+    )\n+    @test isequal(df.uuid, [UUID(1), UUID(UInt128(340282366920938463463374607431768211455)), missing])\n+    @test isequal(df.int_array, [[], [42, 999, missing, missing, -42], missing])\n+    @test isequal(df.varchar_array, [[], [\"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\", \"goose\", missing, \"\"], missing])\n+    @test isequal(\n+        df.nested_int_array,\n+        [[], [[], [42, 999, missing, missing, -42], missing, [], [42, 999, missing, missing, -42]], missing]\n+    )\n+    @test isequal(df.struct, [(a = missing, b = missing), (a = 42, b = \"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\"), missing])\n+    @test isequal(\n+        df.struct_of_arrays,\n+        [\n+            (a = missing, b = missing),\n+            (a = [42, 999, missing, missing, -42], b = [\"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\", \"goose\", missing, \"\"]),\n+            missing\n+        ]\n+    )\n+    @test isequal(df.array_of_structs, [[], [(a = missing, b = missing), (a = 42, b = \"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\"), missing], missing])\n+    @test isequal(df.map, [Dict(), Dict(\"key1\" => \"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\", \"key2\" => \"goose\"), missing])\n+end\ndiff --git a/tools/juliapkg/test/test_appender.jl b/tools/juliapkg/test/test_appender.jl\nnew file mode 100644\nindex 000000000000..64a7c2c6b71b\n--- /dev/null\n+++ b/tools/juliapkg/test/test_appender.jl\n@@ -0,0 +1,89 @@\n+\n+@testset \"Appender Error\" begin\n+    db = DBInterface.connect(DuckDB.DB)\n+    con = DBInterface.connect(db)\n+\n+    @test_throws DuckDB.QueryException DuckDB.Appender(db, \"nonexistanttable\")\n+    @test_throws DuckDB.QueryException DuckDB.Appender(con, \"t\")\n+end\n+\n+@testset \"Appender Usage\" begin\n+    db = DBInterface.connect(DuckDB.DB)\n+\n+    DBInterface.execute(db, \"CREATE TABLE integers(i INTEGER)\")\n+\n+    appender = DuckDB.Appender(db, \"integers\")\n+    DuckDB.close(appender)\n+    DuckDB.close(appender)\n+\n+    appender = DuckDB.Appender(db, \"integers\")\n+    for i in 0:9\n+        DuckDB.Append(appender, i)\n+        DuckDB.EndRow(appender)\n+    end\n+    DuckDB.Flush(appender)\n+\n+    results = DBInterface.execute(db, \"SELECT * FROM integers\")\n+    df = DataFrame(results)\n+    @test names(df) == [\"i\"]\n+    @test size(df, 1) == 10\n+    @test df.i == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n+end\n+\n+# @testset \"Appender API\" begin\n+#     # Open the database\n+#     db = DuckDB.open(\":memory:\")\n+#     con = DuckDB.connect(db)\n+#\n+#     # Create the table the data is appended to\n+#     DuckDB.execute(con, \"CREATE TABLE dtypes(bol BOOLEAN, tint TINYINT, sint SMALLINT, int INTEGER, bint BIGINT, utint UTINYINT, usint USMALLINT, uint UINTEGER, ubint UBIGINT, float FLOAT, double DOUBLE, date DATE, time TIME, vchar VARCHAR, nullval INTEGER)\")\n+#\n+#     # Create the appender\n+#     appender = DuckDB.appender_create(con, \"dtypes\")\n+#\n+#     # Append the different data types\n+#     DuckDB.duckdb_append_bool(appender, true)\n+#     DuckDB.duckdb_append_int8(appender, 1)\n+#     DuckDB.duckdb_append_int16(appender, 2)\n+#     DuckDB.duckdb_append_int32(appender, 3)\n+#     DuckDB.duckdb_append_int64(appender, 4)\n+#     DuckDB.duckdb_append_uint8(appender, 1)\n+#     DuckDB.duckdb_append_uint16(appender, 2)\n+#     DuckDB.duckdb_append_uint32(appender, 3)\n+#     DuckDB.duckdb_append_uint64(appender, 4)\n+#     DuckDB.duckdb_append_float(appender, 1.0)\n+#     DuckDB.duckdb_append_double(appender, 2.0)\n+#     DuckDB.duckdb_append_date(appender, 100)\n+#     DuckDB.duckdb_append_time(appender, 200)\n+#     DuckDB.duckdb_append_varchar(appender, \"Foo\")\n+#     DuckDB.duckdb_append_null(appender)\n+#     # End the row of the appender\n+#     DuckDB.duckdb_appender_end_row(appender)\n+#     # Destroy the appender and flush the data\n+#     DuckDB.duckdb_appender_destroy(appender)\n+#\n+#     # Retrive the data from the table and store it in  a vector\n+#     df = DuckDB.toDataFrame(con, \"select * from dtypes;\")\n+#     data = Matrix(df)\n+#\n+#     # Test if the correct types have been appended to the table\n+#     @test data[1] === true\n+#     @test data[2] === Int8(1)\n+#     @test data[3] === Int16(2)\n+#     @test data[4] === Int32(3)\n+#     @test data[5] === Int64(4)\n+#     @test data[6] === UInt8(1)\n+#     @test data[7] === UInt16(2)\n+#     @test data[8] === UInt32(3)\n+#     @test data[9] === UInt64(4)\n+#     @test data[10] === Float32(1.0)\n+#     @test data[11] === Float64(2.0)\n+#     @test data[12] === Dates.Date(\"1970-04-11\")\n+#     @test data[13] === Dates.Time(0, 0, 0, 0, 200)\n+#     @test data[14] === \"Foo\"\n+#     @test data[15] === missing\n+#\n+#     # Disconnect and close the database\n+#     DuckDB.disconnect(con)\n+#     DuckDB.close(db)\n+# end\ndiff --git a/tools/juliapkg/test/test_basic_queries.jl b/tools/juliapkg/test/test_basic_queries.jl\nnew file mode 100644\nindex 000000000000..64b045e1f9d9\n--- /dev/null\n+++ b/tools/juliapkg/test/test_basic_queries.jl\n@@ -0,0 +1,91 @@\n+# test_basic_queries.jl\n+\n+@testset \"Test DBInterface.execute\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    results = DBInterface.execute(con, \"SELECT 42 a\")\n+\n+    # iterator\n+    for row in results\n+        @test row.a == 42\n+        @test row[1] == 42\n+    end\n+\n+    # convert to DataFrame\n+    df = DataFrame(results)\n+    @test names(df) == [\"a\"]\n+    @test size(df, 1) == 1\n+    @test df.a == [42]\n+\n+    DBInterface.close!(con)\n+end\n+\n+@testset \"Test numeric data types\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    results = DBInterface.execute(\n+        con,\n+        \"\"\"\n+SELECT 42::TINYINT a, 42::INT16 b, 42::INT32 c, 42::INT64 d, 42::UINT8 e, 42::UINT16 f, 42::UINT32 g, 42::UINT64 h\n+UNION ALL\n+SELECT NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n+\"\"\"\n+    )\n+\n+    df = DataFrame(results)\n+\n+    @test size(df, 1) == 2\n+    @test isequal(df.a, [42, missing])\n+    @test isequal(df.b, [42, missing])\n+    @test isequal(df.c, [42, missing])\n+    @test isequal(df.d, [42, missing])\n+    @test isequal(df.e, [42, missing])\n+    @test isequal(df.f, [42, missing])\n+    @test isequal(df.g, [42, missing])\n+    @test isequal(df.h, [42, missing])\n+\n+    DBInterface.close!(con)\n+end\n+\n+@testset \"Test strings\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    results = DBInterface.execute(\n+        con,\n+        \"\"\"\n+SELECT 'hello world' s\n+UNION ALL\n+SELECT NULL\n+UNION ALL\n+SELECT 'this is a long string'\n+UNION ALL\n+SELECT 'obligatory m\u00fchleisen'\n+UNION ALL\n+SELECT '\ud83e\udd86\ud83c\udf5e\ud83e\udd86'\n+\"\"\"\n+    )\n+\n+    df = DataFrame(results)\n+    @test size(df, 1) == 5\n+    @test isequal(df.s, [\"hello world\", missing, \"this is a long string\", \"obligatory m\u00fchleisen\", \"\ud83e\udd86\ud83c\udf5e\ud83e\udd86\"])\n+\n+    DBInterface.close!(con)\n+end\n+\n+@testset \"DBInterface.execute errors\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    # parser error\n+    @test_throws DuckDB.QueryException DBInterface.execute(con, \"SELEC\")\n+\n+    # binder error\n+    @test_throws DuckDB.QueryException DBInterface.execute(con, \"SELECT * FROM this_table_does_not_exist\")\n+\n+    # run-time error\n+    @test_throws DuckDB.QueryException DBInterface.execute(\n+        con,\n+        \"SELECT i::int FROM (SELECT '42' UNION ALL SELECT 'hello') tbl(i)\"\n+    )\n+\n+    DBInterface.close!(con)\n+end\ndiff --git a/tools/juliapkg/test/test_config.jl b/tools/juliapkg/test/test_config.jl\nnew file mode 100644\nindex 000000000000..554d56148bc3\n--- /dev/null\n+++ b/tools/juliapkg/test/test_config.jl\n@@ -0,0 +1,32 @@\n+# test_config.jl\n+\n+@testset \"Test configuration parameters\" begin\n+    # by default NULLs come first\n+    con = DBInterface.connect(DuckDB.DB, \":memory:\")\n+\n+    results = DBInterface.execute(con, \"SELECT 42 a UNION ALL SELECT NULL ORDER BY a\")\n+    df = DataFrame(results)\n+    @test names(df) == [\"a\"]\n+    @test size(df, 1) == 2\n+    @test isequal(df.a, [missing, 42])\n+\n+    DBInterface.close!(con)\n+\n+    # if we add this configuration flag, nulls should come last\n+    config = DuckDB.Config()\n+    DuckDB.SetConfig(config, \"default_null_order\", \"nulls_last\")\n+    @test_throws DuckDB.QueryException DuckDB.SetConfig(config, \"unrecognized option\", \"aaa\")\n+\n+    con = DBInterface.connect(DuckDB.DB, \":memory:\", config)\n+\n+    # NULL should come last now\n+    results = DBInterface.execute(con, \"SELECT 42 a UNION ALL SELECT NULL ORDER BY a\")\n+    df = DataFrame(results)\n+    @test names(df) == [\"a\"]\n+    @test size(df, 1) == 2\n+    @test isequal(df.a, [42, missing])\n+\n+    DBInterface.close!(config)\n+    DBInterface.close!(config)\n+    DBInterface.close!(con)\n+end\ndiff --git a/tools/juliapkg/test/test_connection.jl b/tools/juliapkg/test/test_connection.jl\nnew file mode 100644\nindex 000000000000..7086ae538bcd\n--- /dev/null\n+++ b/tools/juliapkg/test/test_connection.jl\n@@ -0,0 +1,14 @@\n+# test_connection.jl\n+\n+@testset \"Test opening and closing an in-memory database\" begin\n+    con = DBInterface.connect(DuckDB.DB, \":memory:\")\n+    DBInterface.close!(con)\n+    # verify that double-closing does not cause any problems\n+    DBInterface.close!(con)\n+    DBInterface.close!(con)\n+    @test 1 == 1\n+end\n+\n+@testset \"Test opening a bogus directory\" begin\n+    @test_throws DuckDB.ConnectionException DBInterface.connect(DuckDB.DB, \"/path/to/bogus/directory\")\n+end\ndiff --git a/tools/juliapkg/test/test_df_scan.jl b/tools/juliapkg/test/test_df_scan.jl\nnew file mode 100644\nindex 000000000000..f4c1086e6ee6\n--- /dev/null\n+++ b/tools/juliapkg/test/test_df_scan.jl\n@@ -0,0 +1,96 @@\n+# test_df_scan.jl\n+\n+@testset \"Test standard DataFrame scan\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+    df = DataFrame(a = [1, 2, 3], b = [42, 84, 42])\n+\n+    DuckDB.RegisterDataFrame(con, df, \"my_df\")\n+    GC.gc()\n+\n+    results = DBInterface.execute(con, \"SELECT * FROM my_df\")\n+    GC.gc()\n+    df = DataFrame(results)\n+    @test names(df) == [\"a\", \"b\"]\n+    @test size(df, 1) == 3\n+    @test df.a == [1, 2, 3]\n+    @test df.b == [42, 84, 42]\n+\n+    DBInterface.close!(con)\n+end\n+\n+@testset \"Test DataFrame scan with NULL values\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+    df = DataFrame(a = [1, missing, 3], b = [missing, 84, missing])\n+\n+    DuckDB.RegisterDataFrame(con, df, \"my_df\")\n+\n+    results = DBInterface.execute(con, \"SELECT * FROM my_df\")\n+    df = DataFrame(results)\n+    @test names(df) == [\"a\", \"b\"]\n+    @test size(df, 1) == 3\n+    @test isequal(df.a, [1, missing, 3])\n+    @test isequal(df.b, [missing, 84, missing])\n+\n+    DBInterface.close!(con)\n+end\n+\n+@testset \"Test DataFrame scan with numerics\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+    numeric_types = [Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64, Float32, Float64]\n+    for type in numeric_types\n+        my_df = DataFrame(a = [1, missing, 3], b = [missing, 84, missing])\n+        my_df[!, :a] = convert.(Union{type, Missing}, my_df[!, :a])\n+        my_df[!, :b] = convert.(Union{type, Missing}, my_df[!, :b])\n+\n+        DuckDB.RegisterDataFrame(con, my_df, \"my_df\")\n+\n+        results = DBInterface.execute(con, \"SELECT * FROM my_df\")\n+        df = DataFrame(results)\n+        @test isequal(df, my_df)\n+    end\n+\n+    DBInterface.close!(con)\n+end\n+\n+@testset \"Test DataFrame scan with various types\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    # boolean\n+    my_df = DataFrame(a = [true, false, missing])\n+\n+    DuckDB.RegisterDataFrame(con, my_df, \"my_df\")\n+\n+    results = DBInterface.execute(con, \"SELECT * FROM my_df\")\n+    df = DataFrame(results)\n+    @test isequal(df, my_df)\n+\n+    # date/time/timestamp\n+    my_df = DataFrame(\n+        date = [Date(1992, 9, 20), missing, Date(1950, 2, 3)],\n+        time = [Time(23, 3, 1), Time(11, 49, 33), missing],\n+        timestamp = [DateTime(1992, 9, 20, 23, 3, 1), DateTime(1950, 2, 3, 11, 49, 3), missing]\n+    )\n+\n+    DuckDB.RegisterDataFrame(con, my_df, \"my_df\")\n+\n+    results = DBInterface.execute(con, \"SELECT * FROM my_df\")\n+    df = DataFrame(results)\n+    @test isequal(df, my_df)\n+\n+    DBInterface.close!(con)\n+end\n+\n+@testset \"Test DataFrame scan with strings\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    # date/time/timestamp\n+    my_df = DataFrame(str = [\"hello\", \"this is a very long string\", missing, \"obligatory m\u00fchleisen\"])\n+\n+    DuckDB.RegisterDataFrame(con, my_df, \"my_df\")\n+\n+    results = DBInterface.execute(con, \"SELECT * FROM my_df\")\n+    df = DataFrame(results)\n+    @test isequal(df, my_df)\n+\n+    DBInterface.close!(con)\n+end\ndiff --git a/tools/juliapkg/test/test_old_interface.jl b/tools/juliapkg/test/test_old_interface.jl\nnew file mode 100644\nindex 000000000000..7dec1e0d3e02\n--- /dev/null\n+++ b/tools/juliapkg/test/test_old_interface.jl\n@@ -0,0 +1,138 @@\n+# test_old_interface.jl\n+\n+@testset \"DB Connection\" begin\n+    db = DuckDB.open(\":memory:\")\n+    con = DuckDB.connect(db)\n+    @test isa(con, DuckDB.Connection)\n+    DuckDB.disconnect(con)\n+    DuckDB.close(db)\n+end\n+\n+@testset \"Test append DataFrame\" begin\n+    # Open the database\n+    db = DuckDB.open(\":memory:\")\n+    con = DuckDB.connect(db)\n+\n+    # Create the table the data is appended to\n+    DuckDB.execute(\n+        con,\n+        \"CREATE TABLE dtypes(bool BOOLEAN, tint TINYINT, sint SMALLINT, int INTEGER, bint BIGINT, utint UTINYINT, usint USMALLINT, uint UINTEGER, ubint UBIGINT, float FLOAT, double DOUBLE, date DATE, time TIME, vchar VARCHAR, nullval INTEGER)\"\n+    )\n+\n+    # Create test DataFrame\n+    input_df = DataFrame(\n+        bool = [true, false],\n+        tint = Int8.(1:2),\n+        sint = Int16.(1:2),\n+        int = Int32.(1:2),\n+        bint = Int64.(1:2),\n+        utint = UInt8.(1:2),\n+        usint = UInt16.(1:2),\n+        uint = UInt32.(1:2),\n+        ubint = UInt64.(1:2),\n+        float = Float32.(1:2),\n+        double = Float64.(1:2),\n+        date = [Dates.Date(\"1970-04-11\"), Dates.Date(\"1970-04-12\")],\n+        time = [Dates.Time(0, 0, 0, 100, 0), Dates.Time(0, 0, 0, 200, 0)],\n+        vchar = [\"Foo\", \"Bar\"],\n+        nullval = [missing, Int32(2)]\n+    )\n+\n+    # append the DataFrame to the table\n+    DuckDB.appendDataFrame(input_df, con, \"dtypes\")\n+\n+    # Output the data from the table\n+    output_df = DuckDB.toDataFrame(con, \"select * from dtypes;\")\n+\n+    # Compare each column of the input and output dataframe with each other\n+    for (col_pos, input_col) in enumerate(eachcol(input_df))\n+        @test isequal(input_col, output_df[:, col_pos])\n+    end\n+\n+    # Disconnect and close the database\n+    DuckDB.disconnect(con)\n+    DuckDB.close(db)\n+end\n+\n+@testset \"Test README\" begin\n+    db = DuckDB.open(\":memory:\")\n+    con = DuckDB.connect(db)\n+    res = DuckDB.execute(con, \"CREATE TABLE integers(date DATE, jcol INTEGER)\")\n+    res = DuckDB.execute(con, \"INSERT INTO integers VALUES ('2021-09-27', 4), ('2021-09-28', 6), ('2021-09-29', 8)\")\n+    res = DuckDB.execute(con, \"SELECT * FROM integers\")\n+    df = DuckDB.toDataFrame(res)\n+    @test isa(df, DataFrame)\n+    df = DuckDB.toDataFrame(con, \"SELECT * FROM integers\")\n+    println(typeof(df))\n+    @test isa(df, DataFrame)\n+    DuckDB.appendDataFrame(df, con, \"integers\")\n+    DuckDB.disconnect(con)\n+    DuckDB.close(db)\n+end\n+#\n+@testset \"HUGE Int test\" begin\n+    db = DuckDB.open(\":memory:\")\n+    con = DuckDB.connect(db)\n+    res = DuckDB.execute(con, \"CREATE TABLE huge(id INTEGER,data HUGEINT);\")\n+    res = DuckDB.execute(con, \"INSERT INTO huge VALUES (1,NULL), (2, 1761718171), (3, 171661889178);\")\n+    res = DuckDB.toDataFrame(con, \"SELECT * FROM huge\")\n+    DuckDB.disconnect(con)\n+    DuckDB.close(db)\n+end\n+\n+@testset \"Interval type\" begin\n+    db = DuckDB.open(\":memory:\")\n+    con = DuckDB.connect(db)\n+    res = DuckDB.execute(con, \"CREATE TABLE interval(interval INTERVAL);\")\n+    res = DuckDB.execute(\n+        con,\n+        \"\"\"\n+INSERT INTO interval VALUES\n+(INTERVAL 5 HOUR),\n+(INTERVAL 12 MONTH),\n+(INTERVAL 12 MICROSECOND),\n+(INTERVAL 1 YEAR);\n+\"\"\"\n+    )\n+    res = DuckDB.toDataFrame(con, \"SELECT * FROM interval;\")\n+    @test isa(res, DataFrame)\n+    DuckDB.disconnect(con)\n+    DuckDB.close(db)\n+end\n+\n+@testset \"Timestamp\" begin\n+    db = DuckDB.open(\":memory:\")\n+    con = DuckDB.connect(db)\n+    res = DuckDB.execute(con, \"CREATE TABLE timestamp(timestamp TIMESTAMP , data INTEGER);\")\n+    res = DuckDB.execute(\n+        con,\n+        \"INSERT INTO timestamp VALUES ('2021-09-27 11:30:00.000', 4), ('2021-09-28 12:30:00.000', 6), ('2021-09-29 13:30:00.000', 8);\"\n+    )\n+    res = DuckDB.execute(con, \"SELECT * FROM timestamp;\")\n+    res = DuckDB.toDataFrame(res)\n+    @test isa(res, DataFrame)\n+    DuckDB.disconnect(con)\n+    DuckDB.close(db)\n+end\n+\n+@testset \"Items table\" begin\n+    db = DuckDB.open(\":memory:\")\n+    con = DuckDB.connect(db)\n+    res = DuckDB.execute(con, \"CREATE TABLE items(item VARCHAR, value DECIMAL(10,2), count INTEGER);\")\n+    res = DuckDB.execute(con, \"INSERT INTO items VALUES ('jeans', 20.0, 1), ('hammer', 42.2, 2);\")\n+    res = DuckDB.toDataFrame(con, \"SELECT * FROM items;\")\n+    @test isa(res, DataFrame)\n+    DuckDB.disconnect(con)\n+end\n+\n+@testset \"Integers and dates table\" begin\n+    db = DuckDB.DB()\n+    res = DBInterface.execute(db, \"CREATE TABLE integers(date DATE, data INTEGER);\")\n+    res =\n+        DBInterface.execute(db, \"INSERT INTO integers VALUES ('2021-09-27', 4), ('2021-09-28', 6), ('2021-09-29', 8);\")\n+    res = DBInterface.execute(db, \"SELECT * FROM integers;\")\n+    res = DuckDB.toDataFrame(res)\n+    @test res.date == [Date(2021, 9, 27), Date(2021, 9, 28), Date(2021, 9, 29)]\n+    @test isa(res, DataFrame)\n+    DBInterface.close!(db)\n+end\ndiff --git a/tools/juliapkg/test/test_prepare.jl b/tools/juliapkg/test/test_prepare.jl\nnew file mode 100644\nindex 000000000000..1edafd90afdc\n--- /dev/null\n+++ b/tools/juliapkg/test/test_prepare.jl\n@@ -0,0 +1,88 @@\n+# test_prepare.jl\n+\n+@testset \"Test DBInterface.prepare\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    DBInterface.execute(con, \"CREATE TABLE test_table(i INTEGER, j DOUBLE)\")\n+    stmt = DBInterface.prepare(con, \"INSERT INTO test_table VALUES(?, ?)\")\n+\n+    DBInterface.execute(stmt, [1, 3.5])\n+    DBInterface.execute(stmt, [missing, nothing])\n+    DBInterface.execute(stmt, [2, 0.5])\n+\n+    results = DBInterface.execute(con, \"SELECT * FROM test_table\")\n+    df = DataFrame(results)\n+\n+    @test isequal(df.i, [1, missing, 2])\n+    @test isequal(df.j, [3.5, missing, 0.5])\n+\n+    # execute many\n+    DBInterface.executemany(stmt, (col1 = [1, 2, 3, 4, 5], col2 = [1, 2, 4, 8, -0.5]))\n+\n+    results = DBInterface.execute(con, \"SELECT * FROM test_table\")\n+    df = DataFrame(results)\n+\n+    @test isequal(df.i, [1, missing, 2, 1, 2, 3, 4, 5])\n+    @test isequal(df.j, [3.5, missing, 0.5, 1, 2, 4, 8, -0.5])\n+\n+    # verify that double-closing does not cause any problems\n+    DBInterface.close!(stmt)\n+    DBInterface.close!(stmt)\n+    DBInterface.close!(con)\n+    DBInterface.close!(con)\n+end\n+\n+@testset \"Test DBInterface.prepare with various types\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    type_names = [\n+        \"BOOLEAN\",\n+        \"TINYINT\",\n+        \"SMALLINT\",\n+        \"INTEGER\",\n+        \"BIGINT\",\n+        \"UTINYINT\",\n+        \"USMALLINT\",\n+        \"UINTEGER\",\n+        \"UBIGINT\",\n+        \"FLOAT\",\n+        \"DOUBLE\",\n+        \"DATE\",\n+        \"TIME\",\n+        \"TIMESTAMP\",\n+        \"VARCHAR\",\n+        \"INTEGER\"\n+    ]\n+    type_values = [\n+        Bool(true),\n+        Int8(3),\n+        Int16(4),\n+        Int32(8),\n+        Int64(20),\n+        UInt8(42),\n+        UInt16(300),\n+        UInt32(420421),\n+        UInt64(43294832),\n+        Float32(0.5),\n+        Float64(0.25),\n+        Date(1992, 9, 20),\n+        Time(23, 10, 33),\n+        DateTime(1992, 9, 20, 23, 10, 33),\n+        String(\"hello world\"),\n+        missing\n+    ]\n+    for i in 1:size(type_values, 1)\n+        stmt = DBInterface.prepare(con, string(\"SELECT ?::\", type_names[i], \" a\"))\n+        result = DataFrame(DBInterface.execute(stmt, [type_values[i]]))\n+        @test isequal(result.a, [type_values[i]])\n+    end\n+end\n+\n+@testset \"DBInterface.prepare: named parameters not supported yet\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    DBInterface.execute(con, \"CREATE TABLE test_table(i INTEGER, j DOUBLE)\")\n+    @test_throws DuckDB.QueryException DBInterface.prepare(con, \"INSERT INTO test_table VALUES(:col1, :col2)\")\n+\n+    DBInterface.close!(con)\n+end\ndiff --git a/tools/juliapkg/test/test_replacement_scan.jl b/tools/juliapkg/test/test_replacement_scan.jl\nnew file mode 100644\nindex 000000000000..8e86cb540efe\n--- /dev/null\n+++ b/tools/juliapkg/test/test_replacement_scan.jl\n@@ -0,0 +1,27 @@\n+# test_replacement_scan.jl\n+\n+function RangeReplacementScan(info)\n+    table_name = DuckDB.GetTableName(info)\n+    number = tryparse(Int64, table_name)\n+    if number === nothing\n+        return\n+    end\n+    DuckDB.SetFunctionName(info, \"range\")\n+    DuckDB.AddFunctionParameter(info, DuckDB.CreateValue(number))\n+    return\n+end\n+\n+@testset \"Test replacement scans\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    # add a replacement scan that turns any number provided as a table name into range(X)\n+    DuckDB.AddReplacementScan(con, RangeReplacementScan, nothing)\n+\n+    df = DataFrame(DBInterface.execute(con, \"SELECT * FROM \\\"2\\\" tbl(a)\"))\n+    @test df.a == [0, 1]\n+\n+    # this still fails\n+    @test_throws DuckDB.QueryException DBInterface.execute(con, \"SELECT * FROM nonexistant\")\n+\n+    DBInterface.close!(con)\n+end\ndiff --git a/tools/juliapkg/test/test_sqlite.jl b/tools/juliapkg/test/test_sqlite.jl\nnew file mode 100644\nindex 000000000000..2f10c8d8ebbf\n--- /dev/null\n+++ b/tools/juliapkg/test/test_sqlite.jl\n@@ -0,0 +1,319 @@\n+# test_sqlite.jl\n+# tests adopted from SQLite.jl\n+\n+using Tables\n+\n+function setup_clean_test_db(f::Function, args...)\n+    tables = [\n+        \"album\",\n+        \"artist\",\n+        \"customer\",\n+        \"employee\",\n+        \"genre\",\n+        \"invoice\",\n+        \"invoiceline\",\n+        \"mediatype\",\n+        \"playlist\",\n+        \"playlisttrack\",\n+        \"track\"\n+    ]\n+    con = DBInterface.connect(DuckDB.DB)\n+    for table in tables\n+        DBInterface.execute(con, \"CREATE TABLE $table AS SELECT * FROM 'data/$table.parquet'\")\n+    end\n+\n+    try\n+        f(con)\n+    finally\n+        close(con)\n+    end\n+end\n+\n+@testset \"DB Connection\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+    @test con isa DuckDB.DB\n+    DBInterface.close!(con)\n+end\n+\n+\n+@testset \"Issue #207: 32 bit integers\" begin\n+    setup_clean_test_db() do db\n+        ds = DBInterface.execute(db, \"SELECT 42::INT64 a FROM Track LIMIT 1\") |> columntable\n+        @test ds.a[1] isa Int64\n+    end\n+end\n+\n+@testset \"Regular DuckDB Tests\" begin\n+    setup_clean_test_db() do db\n+        @test_throws DuckDB.QueryException DBInterface.execute(db, \"just some syntax error\")\n+        # syntax correct, table missing\n+        @test_throws DuckDB.QueryException DBInterface.execute(\n+            db,\n+            \"SELECT name FROM sqlite_nomaster WHERE type='table';\"\n+        )\n+    end\n+end\n+\n+@testset \"close!(query)\" begin\n+    setup_clean_test_db() do db\n+        qry = DBInterface.execute(db, \"SELECT name FROM sqlite_master WHERE type='table';\")\n+        DBInterface.close!(qry)\n+        return DBInterface.close!(qry) # test it doesn't throw on double-close\n+    end\n+end\n+\n+@testset \"Query tables\" begin\n+    setup_clean_test_db() do db\n+        ds = DBInterface.execute(db, \"SELECT name FROM sqlite_master WHERE type='table';\") |> columntable\n+        @test length(ds) == 1\n+        @test keys(ds) == (:name,)\n+        @test length(ds.name) == 11\n+    end\n+end\n+\n+@testset \"DBInterface.execute([f])\" begin\n+    setup_clean_test_db() do db\n+\n+        # pipe approach\n+        results = DBInterface.execute(db, \"SELECT * FROM Employee;\") |> columntable\n+        @test length(results) == 15\n+        @test length(results[1]) == 8\n+        # callable approach\n+        @test isequal(DBInterface.execute(columntable, db, \"SELECT * FROM Employee\"), results)\n+        employees_stmt = DBInterface.prepare(db, \"SELECT * FROM Employee\")\n+        @test isequal(columntable(DBInterface.execute(employees_stmt)), results)\n+        @test isequal(DBInterface.execute(columntable, employees_stmt), results)\n+        @testset \"throwing from f()\" begin\n+            f(::DuckDB.QueryResult) = error(\"I'm throwing!\")\n+            @test_throws ErrorException DBInterface.execute(f, employees_stmt)\n+            @test_throws ErrorException DBInterface.execute(f, db, \"SELECT * FROM Employee\")\n+        end\n+        return DBInterface.close!(employees_stmt)\n+    end\n+end\n+\n+@testset \"isempty(::Query)\" begin\n+    setup_clean_test_db() do db\n+\n+        @test !DBInterface.execute(isempty, db, \"SELECT * FROM Employee\")\n+        @test DBInterface.execute(isempty, db, \"SELECT * FROM Employee WHERE FirstName='Joanne'\")\n+    end\n+end\n+\n+@testset \"empty query has correct schema and return type\" begin\n+    setup_clean_test_db() do db\n+        empty_scheme = DBInterface.execute(Tables.schema, db, \"SELECT * FROM Employee WHERE FirstName='Joanne'\")\n+        all_scheme = DBInterface.execute(Tables.schema, db, \"SELECT * FROM Employee WHERE FirstName='Joanne'\")\n+        @test empty_scheme.names == all_scheme.names\n+        @test all(ea -> ea[1] <: ea[2], zip(empty_scheme.types, all_scheme.types))\n+\n+        empty_tbl = DBInterface.execute(columntable, db, \"SELECT * FROM Employee WHERE FirstName='Joanne'\")\n+        all_tbl = DBInterface.execute(columntable, db, \"SELECT * FROM Employee\")\n+        @test propertynames(empty_tbl) == propertynames(all_tbl)\n+    end\n+end\n+\n+@testset \"Create table, run commit/rollback tests\" begin\n+    setup_clean_test_db() do db\n+        DBInterface.execute(db, \"create table temp as select * from album\")\n+        DBInterface.execute(db, \"alter table temp add column colyear int\")\n+        DBInterface.execute(db, \"update temp set colyear = 2014\")\n+        r = DBInterface.execute(db, \"select * from temp limit 10\") |> columntable\n+        @test length(r) == 4 && length(r[1]) == 10\n+        @test all(==(2014), r[4])\n+\n+        @test_throws DuckDB.QueryException DuckDB.rollback(db)\n+        @test_throws DuckDB.QueryException DuckDB.commit(db)\n+\n+        DuckDB.transaction(db)\n+        DBInterface.execute(db, \"update temp set colyear = 2015\")\n+        DuckDB.rollback(db)\n+        r = DBInterface.execute(db, \"select * from temp limit 10\") |> columntable\n+        @test all(==(2014), r[4])\n+\n+        DuckDB.transaction(db)\n+        DBInterface.execute(db, \"update temp set colyear = 2015\")\n+        DuckDB.commit(db)\n+        r = DBInterface.execute(db, \"select * from temp limit 10\") |> columntable\n+        @test all(==(2015), r[4])\n+    end\n+end\n+\n+@testset \"Dates\" begin\n+    setup_clean_test_db() do db\n+        DBInterface.execute(db, \"create table temp as select * from album\")\n+        DBInterface.execute(db, \"alter table temp add column dates date\")\n+        stmt = DBInterface.prepare(db, \"update temp set dates = ?\")\n+        DBInterface.execute(stmt, (Date(2014, 1, 1),))\n+\n+        r = DBInterface.execute(db, \"select * from temp limit 10\") |> columntable\n+        @test length(r) == 4 && length(r[1]) == 10\n+        @test isa(r[4][1], Date)\n+        @test all(Bool[x == Date(2014, 1, 1) for x in r[4]])\n+        return DBInterface.execute(db, \"drop table temp\")\n+    end\n+end\n+\n+@testset \"Prepared Statements\" begin\n+    setup_clean_test_db() do db\n+\n+        DBInterface.execute(db, \"CREATE TABLE temp AS SELECT * FROM Album\")\n+        r = DBInterface.execute(db, \"SELECT * FROM temp LIMIT ?\", [3]) |> columntable\n+        @test length(r) == 3 && length(r[1]) == 3\n+        r = DBInterface.execute(db, \"SELECT * FROM temp WHERE Title ILIKE ?\", [\"%time%\"]) |> columntable\n+        @test r[1] == [76, 111, 187]\n+        DBInterface.execute(db, \"INSERT INTO temp VALUES (?1, ?3, ?2)\", [0, 0, \"Test Album\"])\n+        r = DBInterface.execute(db, \"SELECT * FROM temp WHERE AlbumId = 0\") |> columntable\n+        @test r[1][1] == 0\n+        @test r[2][1] == \"Test Album\"\n+        @test r[3][1] == 0\n+        DuckDB.drop!(db, \"temp\")\n+\n+        DBInterface.execute(db, \"CREATE TABLE temp AS SELECT * FROM Album\")\n+        r = DBInterface.execute(db, \"SELECT * FROM temp LIMIT ?\", (a = 3,)) |> columntable\n+        @test length(r) == 3 && length(r[1]) == 3\n+        r = DBInterface.execute(db, \"SELECT * FROM temp LIMIT ?\", a = 3) |> columntable\n+        @test length(r) == 3 && length(r[1]) == 3\n+        r = DBInterface.execute(db, \"SELECT * FROM temp WHERE Title ILIKE ?\", (word = \"%time%\",)) |> columntable\n+        @test r[1] == [76, 111, 187]\n+        # FIXME: these are supposed to be named parameter tests, but we don't support that yet\n+        DBInterface.execute(db, \"INSERT INTO temp VALUES (?, ?, ?)\", (lid = 0, title = \"Test Album\", rid = 1))\n+        DBInterface.execute(db, \"INSERT INTO temp VALUES (?, ?, ?)\", lid = 400, title = \"Test2 Album\", rid = 3)\n+        r = DBInterface.execute(db, \"SELECT * FROM temp WHERE AlbumId IN (0, 400)\") |> columntable\n+        @test r[1] == [0, 400]\n+        @test r[2] == [\"Test Album\", \"Test2 Album\"]\n+        @test r[3] == [1, 3]\n+        return DuckDB.drop!(db, \"temp\")\n+    end\n+end\n+\n+\n+@testset \"DuckDB to Julia type conversion\" begin\n+    binddb = DBInterface.connect(DuckDB.DB)\n+    DBInterface.execute(\n+        binddb,\n+        \"CREATE TABLE temp (n INTEGER, i1 INT, i2 integer,\n+        \t\t\t\t\tf1 REAL, f2 FLOAT, f3 NUMERIC,\n+        \t\t\t\t\ts1 TEXT, s2 CHAR(10), s3 VARCHAR(15), s4 NVARCHAR(5),\n+        \t\t\t\t\td1 DATETIME, ts1 TIMESTAMP)\"\n+    )\n+    DBInterface.execute(\n+        binddb,\n+        \"INSERT INTO temp VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n+        [\n+            missing,\n+            Int64(6),\n+            Int64(4),\n+            6.4,\n+            6.3,\n+            Int64(7),\n+            \"some long text\",\n+            \"short text\",\n+            \"another text\",\n+            \"short\",\n+            \"2021-02-21\",\n+            \"2021-02-12 12:01:32\"\n+        ]\n+    )\n+    rr = DBInterface.execute(rowtable, binddb, \"SELECT * FROM temp\")\n+    @test length(rr) == 1\n+    r = first(rr)\n+    @test typeof.(Tuple(r)) ==\n+          (Missing, Int32, Int32, Float32, Float32, Float64, String, String, String, String, DateTime, DateTime)\n+end\n+\n+@testset \"Issue #158: Missing DB File\" begin\n+    @test_throws DuckDB.ConnectionException DuckDB.DB(\"nonexistentdir/not_there.db\")\n+end\n+\n+@testset \"Issue #180, Query\" begin\n+    param = \"Hello!\"\n+    query = DBInterface.execute(DuckDB.DB(), \"SELECT ?1 UNION ALL SELECT ?1\", [param])\n+    param = \"x\"\n+    for row in query\n+        @test row[1] == \"Hello!\"\n+        GC.gc() # this must NOT garbage collect the \"Hello!\" bound value\n+    end\n+\n+    db = DBInterface.connect(DuckDB.DB)\n+    DBInterface.execute(db, \"CREATE TABLE T (a TEXT, PRIMARY KEY (a))\")\n+\n+    q = DBInterface.prepare(db, \"INSERT INTO T VALUES(?)\")\n+    DBInterface.execute(q, [\"a\"])\n+\n+    @test_throws DuckDB.QueryException DBInterface.execute(q, [1, \"a\"])\n+end\n+\n+@testset \"show(DB)\" begin\n+    io = IOBuffer()\n+    db = DuckDB.DB()\n+\n+    show(io, db)\n+    @test String(take!(io)) == \"DuckDB.DB(\\\":memory:\\\")\"\n+\n+    DBInterface.close!(db)\n+end\n+\n+@testset \"DuckDB.execute()\" begin\n+    db = DBInterface.connect(DuckDB.DB)\n+    DBInterface.execute(db, \"CREATE TABLE T (x INT UNIQUE)\")\n+\n+    q = DBInterface.prepare(db, \"INSERT INTO T VALUES(?)\")\n+    DuckDB.execute(q, (1,))\n+    r = DBInterface.execute(db, \"SELECT * FROM T\") |> columntable\n+    @test r[1] == [1]\n+\n+    DuckDB.execute(q, [2])\n+    r = DBInterface.execute(db, \"SELECT * FROM T\") |> columntable\n+    @test r[1] == [1, 2]\n+\n+    q = DBInterface.prepare(db, \"INSERT INTO T VALUES(?)\")\n+    DuckDB.execute(q, [3])\n+    r = DBInterface.execute(columntable, db, \"SELECT * FROM T\")\n+    @test r[1] == [1, 2, 3]\n+\n+    DuckDB.execute(q, [4])\n+    r = DBInterface.execute(columntable, db, \"SELECT * FROM T\")\n+    @test r[1] == [1, 2, 3, 4]\n+\n+    DuckDB.execute(db, \"INSERT INTO T VALUES(?)\", [5])\n+    r = DBInterface.execute(columntable, db, \"SELECT * FROM T\")\n+    @test r[1] == [1, 2, 3, 4, 5]\n+\n+    r = DBInterface.execute(db, strip(\"   SELECT * FROM T  \")) |> columntable\n+    @test r[1] == [1, 2, 3, 4, 5]\n+\n+    r = DBInterface.execute(db, \"SELECT * FROM T\")\n+    @test Tables.istable(r)\n+    @test Tables.rowaccess(r)\n+    @test Tables.rows(r) === r\n+    @test Base.IteratorSize(typeof(r)) == Base.SizeUnknown()\n+    row = first(r)\n+end\n+\n+@testset \"last_insert_rowid unsupported\" begin\n+    db = DBInterface.connect(DuckDB.DB)\n+    @test_throws DuckDB.NotImplementedException DBInterface.lastrowid(db)\n+    @test DuckDB.esc_id([\"1\", \"2\", \"3\"]) == \"\\\"1\\\",\\\"2\\\",\\\"3\\\"\"\n+end\n+\n+@testset \"Escaping\" begin\n+    @test DuckDB.esc_id([\"1\", \"2\", \"3\"]) == \"\\\"1\\\",\\\"2\\\",\\\"3\\\"\"\n+end\n+\n+@testset \"Issue #253: Ensure query column names are unique by default\" begin\n+    db = DuckDB.DB()\n+    res = DBInterface.execute(db, \"select 1 as x2, 2 as x2, 3 as x2, 4 as x2_2\") |> columntable\n+    @test res == (x2 = [1], x2_1 = [2], x2_2 = [3], x2_2_1 = [4])\n+end\n+\n+@testset \"drop!() table name escaping\" begin\n+    db = DuckDB.DB()\n+    DBInterface.execute(db, \"CREATE TABLE \\\"escape 10.0%\\\"(i INTEGER)\")\n+    # table exists\n+    DBInterface.execute(db, \"SELECT * FROM \\\"escape 10.0%\\\"\")\n+    # drop the table\n+    DuckDB.drop!(db, \"escape 10.0%\")\n+    # it should no longer exist\n+    @test_throws DuckDB.QueryException DBInterface.execute(db, \"SELECT * FROM \\\"escape 10.0%\\\"\")\n+end\ndiff --git a/tools/juliapkg/test/test_table_function.jl b/tools/juliapkg/test/test_table_function.jl\nnew file mode 100644\nindex 000000000000..7bca180ac48a\n--- /dev/null\n+++ b/tools/juliapkg/test/test_table_function.jl\n@@ -0,0 +1,138 @@\n+# test_table_function.jl\n+\n+struct MyBindStruct\n+    count::Int64\n+\n+    function MyBindStruct(count::Int64)\n+        return new(count)\n+    end\n+end\n+\n+function MyBindFunction(info::DuckDB.BindInfo)\n+    DuckDB.AddResultColumn(info, \"forty_two\", Int64)\n+\n+    parameter = DuckDB.GetParameter(info, 0)\n+    number = DuckDB.GetValue(parameter, Int64)\n+    return MyBindStruct(number)\n+end\n+\n+mutable struct MyInitStruct\n+    pos::Int64\n+\n+    function MyInitStruct()\n+        return new(0)\n+    end\n+end\n+\n+function MyInitFunction(info::DuckDB.InitInfo)\n+    return MyInitStruct()\n+end\n+\n+function MyMainFunction(info::DuckDB.FunctionInfo, output::DuckDB.DataChunk)\n+    bind_info = DuckDB.GetBindInfo(info, MyBindStruct)\n+    init_info = DuckDB.GetInitInfo(info, MyInitStruct)\n+\n+    result_array = DuckDB.GetArray(output, 1, Int64)\n+    count = 0\n+    for i in 1:(DuckDB.VECTOR_SIZE)\n+        if init_info.pos >= bind_info.count\n+            break\n+        end\n+        result_array[count + 1] = init_info.pos % 2 == 0 ? 42 : 84\n+        count += 1\n+        init_info.pos += 1\n+    end\n+\n+    DuckDB.SetSize(output, count)\n+    return\n+end\n+\n+function MyMainFunctionNulls(info::DuckDB.FunctionInfo, output::DuckDB.DataChunk)\n+    bind_info = DuckDB.GetBindInfo(info, MyBindStruct)\n+    init_info = DuckDB.GetInitInfo(info, MyInitStruct)\n+\n+    result_array = DuckDB.GetArray(output, 1, Int64)\n+    validity = DuckDB.GetValidity(output, 1)\n+    count = 0\n+    for i in 1:(DuckDB.VECTOR_SIZE)\n+        if init_info.pos >= bind_info.count\n+            break\n+        end\n+        if init_info.pos % 2 == 0\n+            result_array[count + 1] = 42\n+        else\n+            DuckDB.SetInvalid(validity, count + 1)\n+        end\n+        count += 1\n+        init_info.pos += 1\n+    end\n+\n+    DuckDB.SetSize(output, count)\n+    return\n+end\n+\n+@testset \"Test custom table functions\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    DuckDB.CreateTableFunction(con, \"forty_two\", [Int64], MyBindFunction, MyInitFunction, MyMainFunction)\n+    GC.gc()\n+\n+    # 3 elements\n+    results = DBInterface.execute(con, \"SELECT * FROM forty_two(3)\")\n+    GC.gc()\n+\n+    df = DataFrame(results)\n+    @test names(df) == [\"forty_two\"]\n+    @test size(df, 1) == 3\n+    @test df.forty_two == [42, 84, 42]\n+\n+    # > vsize elements\n+    results = DBInterface.execute(con, \"SELECT COUNT(*) cnt FROM forty_two(10000)\")\n+    GC.gc()\n+\n+    df = DataFrame(results)\n+    @test df.cnt == [10000]\n+\n+    # \t@time begin\n+    # \t\tresults = DBInterface.execute(con, \"SELECT SUM(forty_two) cnt FROM forty_two(10000000)\")\n+    # \tend\n+    # \tdf = DataFrame(results)\n+    # \tprintln(df)\n+\n+    # return null values from a table function\n+    DuckDB.CreateTableFunction(con, \"forty_two_nulls\", [Int64], MyBindFunction, MyInitFunction, MyMainFunctionNulls)\n+    results = DBInterface.execute(con, \"SELECT COUNT(*) total_cnt, COUNT(forty_two) cnt FROM forty_two_nulls(10000)\")\n+    df = DataFrame(results)\n+    @test df.total_cnt == [10000]\n+    @test df.cnt == [5000]\n+\n+    # \t@time begin\n+    # \t\tresults = DBInterface.execute(con, \"SELECT SUM(forty_two) cnt FROM forty_two_nulls(10000000)\")\n+    # \tend\n+    # \tdf = DataFrame(results)\n+    # \tprintln(df)\n+end\n+\n+function MyBindErrorFunction(info::DuckDB.BindInfo)\n+    throw(\"bind error\")\n+end\n+\n+function MyInitErrorFunction(info::DuckDB.InitInfo)\n+    throw(\"init error\")\n+end\n+\n+function MyMainErrorFunction(info::DuckDB.FunctionInfo, output::DuckDB.DataChunk)\n+    throw(\"runtime error\")\n+end\n+\n+@testset \"Test table function errors\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    DuckDB.CreateTableFunction(con, \"bind_error_function\", [Int64], MyBindErrorFunction, MyInitFunction, MyMainFunction)\n+    DuckDB.CreateTableFunction(con, \"init_error_function\", [Int64], MyBindFunction, MyInitErrorFunction, MyMainFunction)\n+    DuckDB.CreateTableFunction(con, \"main_error_function\", [Int64], MyBindFunction, MyInitFunction, MyMainErrorFunction)\n+\n+    @test_throws DuckDB.QueryException DBInterface.execute(con, \"SELECT * FROM bind_error_function(3)\")\n+    @test_throws DuckDB.QueryException DBInterface.execute(con, \"SELECT * FROM init_error_function(3)\")\n+    @test_throws DuckDB.QueryException DBInterface.execute(con, \"SELECT * FROM main_error_function(3)\")\n+end\ndiff --git a/tools/juliapkg/test/test_transaction.jl b/tools/juliapkg/test/test_transaction.jl\nnew file mode 100644\nindex 000000000000..562bfa586cb4\n--- /dev/null\n+++ b/tools/juliapkg/test/test_transaction.jl\n@@ -0,0 +1,23 @@\n+# test_transaction.jl\n+\n+@testset \"Test DBInterface.transaction\" begin\n+    con = DBInterface.connect(DuckDB.DB, \":memory:\")\n+\n+    # throw an exception in DBInterface.transaction\n+    # this should cause a rollback to happen\n+    @test_throws DuckDB.QueryException DBInterface.transaction(con) do\n+        DBInterface.execute(con, \"CREATE TABLE integers(i INTEGER)\")\n+        return DBInterface.execute(con, \"SELEC\")\n+    end\n+\n+    # verify that the table does not exist\n+    @test_throws DuckDB.QueryException DBInterface.execute(con, \"SELECT * FROM integers\")\n+\n+    # no exception, this should work and be committed\n+    DBInterface.transaction(con) do\n+        return DBInterface.execute(con, \"CREATE TABLE integers(i INTEGER)\")\n+    end\n+    DBInterface.execute(con, \"SELECT * FROM integers\")\n+\n+    DBInterface.close!(con)\n+end\n",
  "problem_statement": "Parquet export alters table names\n#### What happens?\r\nWhen exporting duckdb tables to parquet, the resulting parquet files are named based on sanitized versions of the table names: all uppercase are converted to lowercase (ok fine), and all digits are converted to underscores, and a number is prepended.  Luckily this can't create collisions of names, since at least all tables are then prefixed by a number, but I would still prefer the original table names.  \r\n`duckdb` helpfully generates a `load.sql` file mapping the mangled file-names back to their original table-names, which is helpful.  However, because `duckdb` now has the *amazing* ability to read the parquet files directly, I really don't want to run `load.sql` at all, I just want to point duckdb at these nice portable parquet files it just made.  It would be wonderful if duckdb would generate a `parquet.sql` file in this case, or more simply, just not mangle the table names used for the parquet files?\r\n\r\nNo doubt there are good reasons I'm overlooking for doing this, maybe related to #2075 and backwards compatibility, but it seems unnecessary here?   \r\n\r\n\r\n#### To Reproduce\r\n\r\nhttps://duckdb.org/docs/sql/statements/export\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: current release\r\n - DuckDB Client: R\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nWhen non utf8 data is passed to `duckdb_bind_varchar_length` it will crash the process instead of returning `DuckDBError`\n#### What happens?\r\n\r\nWhen you use `duckdb_bind_varchar_length`, and pass non utf8 data (by accident), it crashes the process, instead of returning `DuckDbError`.\r\n\r\nI know you should use blobs for arbitrary binary data, but you don't always have control over input in strings. Would it be possible to catch the exception below and return an error?\r\n\r\nOutput: \r\n```\r\nlibc++abi: terminating with uncaught exception of type duckdb::Exception: String value is not valid UTF8\r\nmake: *** [test] Abort trap: 6\r\n```\r\n\r\n#### To Reproduce\r\n\r\nCall `duckdb_varchar_length` with as input `[0, 40, 41]`, and length `3`.\r\n\r\n#### Environment (please complete the following information):\r\n - OS: macOS\r\n - DuckDB Version: 0.3.2\r\n - DuckDB Client: WIP erlang interface.\r\n\r\n#### Before Submitting\r\n\r\nTried the latest libduckdb.zip from GH\r\n\r\n\r\n### FYI\r\n\r\nTestcase looks like this:\r\n\r\n```erlang\r\nbind_varchar_test() ->\r\n    {ok, Db} = educkdb:open(\":memory:\"),\r\n    {ok, Conn} = educkdb:connect(Db),\r\n\r\n    {ok, [], []} = q(Conn, \"create table test(a varchar(10), b varchar(200));\"),\r\n    {ok, Insert} = educkdb:prepare(Conn, \"insert into test values($1, $2);\"),\r\n\r\n    ok = educkdb:bind_varchar(Insert, 1, \"hello\"),\r\n    ok = educkdb:bind_varchar(Insert, 2, \"world\"),\r\n\r\n    {ok, _, [[1]]} = x(Insert),\r\n\r\n    ok = educkdb:bind_varchar(Insert, 1, <<\"\ud83d\ude00\"/utf8>>),\r\n    ok = educkdb:bind_varchar(Insert, 2, <<0, \"()\">>),   % <-- crash here\r\n\r\n    {ok, _, [[1]]} = x(Insert),\r\n\r\n    {ok, _, [\r\n             [<<\"hello\">>, <<\"world\">>],\r\n             [<<\"\ud83d\ude00\"/utf8>>, <<\"1234567890\">>]\r\n            ]} = q(Conn, \"select * from test order by a\"),\r\n    ok.\r\n```\r\n\n",
  "hints_text": "We could offer a `VIEW` option along with the EXPORT that would generate `CREATE VIEW` statements instead of `CREATE TABLE` statements. `IMPORT` will then just create a bunch of views over the Parquet files. Perhaps that would be useful?\r\n\r\nLowercasing only happens related to #2075 if the tables are created unquoted from the parser, the case of quoted table names are preserved. \r\n\r\nThe mangling of names is related to not wanting to deal with any issues arising from strange characters in table names or e.g. file insensitivity of file systems. We could add a flag to disable this mangling, but `EXPORT` is not really intended for creating \"human-readable\" files. It is mostly intended to create files that will be loaded with an `IMPORT` again.\r\n\r\nIf you want parquet files with specific names can't you use [COPY](https://duckdb.org/docs/sql/statements/copy)?\nThanks Mark, yeah, I could probably just auto-generate my COPY commands (even through the EXPORT 1-liner is nice).  The CREATE VIEW .sql file would be a nice addition on parquet export.  \n",
  "created_at": "2022-03-17T20:21:26Z"
}