diff --git a/tools/pythonpkg/src/include/duckdb_python/numpy/numpy_type.hpp b/tools/pythonpkg/src/include/duckdb_python/numpy/numpy_type.hpp
index ab26b22b7a29..982f00ecf67d 100644
--- a/tools/pythonpkg/src/include/duckdb_python/numpy/numpy_type.hpp
+++ b/tools/pythonpkg/src/include/duckdb_python/numpy/numpy_type.hpp
@@ -42,6 +42,7 @@ enum class NumpyNullableType : uint8_t {
 	//! Extension Types
 	//! ------------------------------------------------------------
 	CATEGORY, //! category
+	STRING,   //! string
 };
 
 struct NumpyType {
diff --git a/tools/pythonpkg/src/numpy/numpy_bind.cpp b/tools/pythonpkg/src/numpy/numpy_bind.cpp
index ae334badc727..0ffef850312f 100644
--- a/tools/pythonpkg/src/numpy/numpy_bind.cpp
+++ b/tools/pythonpkg/src/numpy/numpy_bind.cpp
@@ -36,8 +36,7 @@ void NumpyBind::Bind(const ClientContext &context, py::handle df, vector<PandasC
 			bind_data.pandas_col = make_uniq<PandasNumpyColumn>(py::array(column.attr("astype")("float32")));
 			bind_data.numpy_type.type = NumpyNullableType::FLOAT_32;
 			duckdb_col_type = NumpyToLogicalType(bind_data.numpy_type);
-		} else if (bind_data.numpy_type.type == NumpyNullableType::OBJECT &&
-		           string(py::str(df_types[col_idx])) == "string") {
+		} else if (bind_data.numpy_type.type == NumpyNullableType::STRING) {
 			bind_data.numpy_type.type = NumpyNullableType::CATEGORY;
 			// here we call numpy.unique
 			// this function call will return the unique values of a given array
diff --git a/tools/pythonpkg/src/numpy/numpy_scan.cpp b/tools/pythonpkg/src/numpy/numpy_scan.cpp
index b4b1d3dbe276..ff8591ee0ff4 100644
--- a/tools/pythonpkg/src/numpy/numpy_scan.cpp
+++ b/tools/pythonpkg/src/numpy/numpy_scan.cpp
@@ -317,11 +317,13 @@ void NumpyScan::Scan(PandasColumnBindData &bind_data, idx_t count, idx_t offset,
 		}
 		break;
 	}
+	case NumpyNullableType::STRING:
 	case NumpyNullableType::OBJECT: {
-		//! We have determined the underlying logical type of this object column
 		// Get the source pointer of the numpy array
 		auto src_ptr = (PyObject **)array.data(); // NOLINT
-		if (out.GetType().id() != LogicalTypeId::VARCHAR) {
+		const bool is_object_col = bind_data.numpy_type.type == NumpyNullableType::OBJECT;
+		if (is_object_col && out.GetType().id() != LogicalTypeId::VARCHAR) {
+			//! We have determined the underlying logical type of this object column
 			return NumpyScan::ScanObjectColumn(src_ptr, numpy_col.stride, count, offset, out);
 		}
 
@@ -338,7 +340,7 @@ void NumpyScan::Scan(PandasColumnBindData &bind_data, idx_t count, idx_t offset,
 
 			// Get the pointer to the object
 			PyObject *val = src_ptr[source_idx];
-			if (bind_data.numpy_type.type == NumpyNullableType::OBJECT && !py::isinstance<py::str>(val)) {
+			if (!py::isinstance<py::str>(val)) {
 				if (val == Py_None) {
 					out_mask.SetInvalid(row);
 					continue;
diff --git a/tools/pythonpkg/src/numpy/type.cpp b/tools/pythonpkg/src/numpy/type.cpp
index 00d86cab4df6..92ac478574c2 100644
--- a/tools/pythonpkg/src/numpy/type.cpp
+++ b/tools/pythonpkg/src/numpy/type.cpp
@@ -55,8 +55,10 @@ static NumpyNullableType ConvertNumpyTypeInternal(const string &col_type_str) {
 	if (col_type_str == "float64" || col_type_str == "Float64") {
 		return NumpyNullableType::FLOAT_64;
 	}
-	if (col_type_str == "object" || col_type_str == "string") {
-		//! this better be castable to strings
+	if (col_type_str == "string") {
+		return NumpyNullableType::STRING;
+	}
+	if (col_type_str == "object") {
 		return NumpyNullableType::OBJECT;
 	}
 	if (col_type_str == "timedelta64[ns]") {
@@ -134,6 +136,8 @@ LogicalType NumpyToLogicalType(const NumpyType &col_type) {
 		return LogicalType::FLOAT;
 	case NumpyNullableType::FLOAT_64:
 		return LogicalType::DOUBLE;
+	case NumpyNullableType::STRING:
+		return LogicalType::VARCHAR;
 	case NumpyNullableType::OBJECT:
 		return LogicalType::VARCHAR;
 	case NumpyNullableType::TIMEDELTA:
diff --git a/tools/pythonpkg/src/pandas/scan.cpp b/tools/pythonpkg/src/pandas/scan.cpp
index 147d77f4a0a3..10424faab7ee 100644
--- a/tools/pythonpkg/src/pandas/scan.cpp
+++ b/tools/pythonpkg/src/pandas/scan.cpp
@@ -95,9 +95,12 @@ unique_ptr<FunctionData> PandasScanFunction::PandasScanBind(ClientContext &conte
 
 	shared_ptr<DependencyItem> dependency_item;
 	if (ref.external_dependency) {
-		// This was created during the replacement scan (see python_replacement_scan.cpp)
+		// This was created during the replacement scan if this was a pandas DataFrame (see python_replacement_scan.cpp)
 		dependency_item = ref.external_dependency->GetDependency("copy");
-		D_ASSERT(dependency_item);
+		if (!dependency_item) {
+			// This was created during the replacement if this was a numpy scan
+			dependency_item = ref.external_dependency->GetDependency("data");
+		}
 	}
 
 	auto get_fun = df.attr("__getitem__");
