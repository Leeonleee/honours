{
  "repo": "duckdb/duckdb",
  "pull_number": 11317,
  "instance_id": "duckdb__duckdb-11317",
  "issue_numbers": [
    "11281",
    "11281"
  ],
  "base_commit": "ef62c27528b726c0777b8f42b10b0c75d017e2d3",
  "patch": "diff --git a/src/catalog/default/default_views.cpp b/src/catalog/default/default_views.cpp\nindex 57c913c0e84e..db3d647f00bb 100644\n--- a/src/catalog/default/default_views.cpp\n+++ b/src/catalog/default/default_views.cpp\n@@ -46,10 +46,10 @@ static DefaultView internal_views[] = {\n     {\"pg_catalog\", \"pg_tablespace\", \"SELECT 0 oid, 'pg_default' spcname, 0 spcowner, NULL spcacl, NULL spcoptions\"},\n     {\"pg_catalog\", \"pg_type\", \"SELECT type_oid oid, format_pg_type(type_name) typname, schema_oid typnamespace, 0 typowner, type_size typlen, false typbyval, CASE WHEN logical_type='ENUM' THEN 'e' else 'b' end typtype, CASE WHEN type_category='NUMERIC' THEN 'N' WHEN type_category='STRING' THEN 'S' WHEN type_category='DATETIME' THEN 'D' WHEN type_category='BOOLEAN' THEN 'B' WHEN type_category='COMPOSITE' THEN 'C' WHEN type_category='USER' THEN 'U' ELSE 'X' END typcategory, false typispreferred, true typisdefined, NULL typdelim, NULL typrelid, NULL typsubscript, NULL typelem, NULL typarray, NULL typinput, NULL typoutput, NULL typreceive, NULL typsend, NULL typmodin, NULL typmodout, NULL typanalyze, 'd' typalign, 'p' typstorage, NULL typnotnull, NULL typbasetype, NULL typtypmod, NULL typndims, NULL typcollation, NULL typdefaultbin, NULL typdefault, NULL typacl FROM duckdb_types() WHERE type_size IS NOT NULL;\"},\n     {\"pg_catalog\", \"pg_views\", \"SELECT schema_name schemaname, view_name viewname, 'duckdb' viewowner, sql definition FROM duckdb_views()\"},\n-    {\"information_schema\", \"columns\", \"SELECT database_name table_catalog, schema_name table_schema, table_name, column_name, column_index ordinal_position, column_default, CASE WHEN is_nullable THEN 'YES' ELSE 'NO' END is_nullable, data_type, character_maximum_length, NULL character_octet_length, numeric_precision, numeric_precision_radix, numeric_scale, NULL datetime_precision, NULL interval_type, NULL interval_precision, NULL character_set_catalog, NULL character_set_schema, NULL character_set_name, NULL collation_catalog, NULL collation_schema, NULL collation_name, NULL domain_catalog, NULL domain_schema, NULL domain_name, NULL udt_catalog, NULL udt_schema, NULL udt_name, NULL scope_catalog, NULL scope_schema, NULL scope_name, NULL maximum_cardinality, NULL dtd_identifier, NULL is_self_referencing, NULL is_identity, NULL identity_generation, NULL identity_start, NULL identity_increment, NULL identity_maximum, NULL identity_minimum, NULL identity_cycle, NULL is_generated, NULL generation_expression, NULL is_updatable, comment AS COLUMN_COMMENT FROM duckdb_columns;\"},\n-    {\"information_schema\", \"schemata\", \"SELECT database_name catalog_name, schema_name, 'duckdb' schema_owner, NULL default_character_set_catalog, NULL default_character_set_schema, NULL default_character_set_name, sql sql_path FROM duckdb_schemas()\"},\n-    {\"information_schema\", \"tables\", \"SELECT database_name table_catalog, schema_name table_schema, table_name, CASE WHEN temporary THEN 'LOCAL TEMPORARY' ELSE 'BASE TABLE' END table_type, NULL self_referencing_column_name, NULL reference_generation, NULL user_defined_type_catalog, NULL user_defined_type_schema, NULL user_defined_type_name, 'YES' is_insertable_into, 'NO' is_typed, CASE WHEN temporary THEN 'PRESERVE' ELSE NULL END commit_action, comment AS TABLE_COMMENT FROM duckdb_tables() UNION ALL SELECT database_name table_catalog, schema_name table_schema, view_name table_name, 'VIEW' table_type, NULL self_referencing_column_name, NULL reference_generation, NULL user_defined_type_catalog, NULL user_defined_type_schema, NULL user_defined_type_name, 'NO' is_insertable_into, 'NO' is_typed, NULL commit_action, comment AS TABLE_COMMENT FROM duckdb_views;\"},\n-\t{\"information_schema\", \"character_sets\", \"SELECT NULL character_set_catalog, NULL character_set_schema, 'UTF8' character_set_name, 'UCS' character_repertoire, 'UTF8' form_of_use, current_database() default_collate_catalog, 'pg_catalog' default_collate_schema, 'ucs_basic' default_collate_name;\"},\n+    {\"information_schema\", \"columns\", \"SELECT database_name table_catalog, schema_name table_schema, table_name, column_name, column_index ordinal_position, column_default, CASE WHEN is_nullable THEN 'YES' ELSE 'NO' END is_nullable, data_type, character_maximum_length, NULL::INT character_octet_length, numeric_precision, numeric_precision_radix, numeric_scale, NULL::INT datetime_precision, NULL::VARCHAR interval_type, NULL::INT interval_precision, NULL::VARCHAR character_set_catalog, NULL::VARCHAR character_set_schema, NULL::VARCHAR character_set_name, NULL::VARCHAR collation_catalog, NULL::VARCHAR collation_schema, NULL::VARCHAR collation_name, NULL::VARCHAR domain_catalog, NULL::VARCHAR domain_schema, NULL::VARCHAR domain_name, NULL::VARCHAR udt_catalog, NULL::VARCHAR udt_schema, NULL::VARCHAR udt_name, NULL::VARCHAR scope_catalog, NULL::VARCHAR scope_schema, NULL::VARCHAR scope_name, NULL::BIGINT maximum_cardinality, NULL::VARCHAR dtd_identifier, NULL::BOOL is_self_referencing, NULL::BOOL is_identity, NULL::VARCHAR identity_generation, NULL::VARCHAR identity_start, NULL::VARCHAR identity_increment, NULL::VARCHAR identity_maximum, NULL::VARCHAR identity_minimum, NULL::BOOL identity_cycle, NULL::VARCHAR is_generated, NULL::VARCHAR generation_expression, NULL::BOOL is_updatable, comment AS COLUMN_COMMENT FROM duckdb_columns;\"},\n+    {\"information_schema\", \"schemata\", \"SELECT database_name catalog_name, schema_name, 'duckdb' schema_owner, NULL::VARCHAR default_character_set_catalog, NULL::VARCHAR default_character_set_schema, NULL::VARCHAR default_character_set_name, sql sql_path FROM duckdb_schemas()\"},\n+    {\"information_schema\", \"tables\", \"SELECT database_name table_catalog, schema_name table_schema, table_name, CASE WHEN temporary THEN 'LOCAL TEMPORARY' ELSE 'BASE TABLE' END table_type, NULL::VARCHAR self_referencing_column_name, NULL::VARCHAR reference_generation, NULL::VARCHAR user_defined_type_catalog, NULL::VARCHAR user_defined_type_schema, NULL::VARCHAR user_defined_type_name, 'YES' is_insertable_into, 'NO' is_typed, CASE WHEN temporary THEN 'PRESERVE' ELSE NULL END commit_action, comment AS TABLE_COMMENT FROM duckdb_tables() UNION ALL SELECT database_name table_catalog, schema_name table_schema, view_name table_name, 'VIEW' table_type, NULL self_referencing_column_name, NULL reference_generation, NULL user_defined_type_catalog, NULL user_defined_type_schema, NULL user_defined_type_name, 'NO' is_insertable_into, 'NO' is_typed, NULL commit_action, comment AS TABLE_COMMENT FROM duckdb_views;\"},\n+\t{\"information_schema\", \"character_sets\", \"SELECT NULL::VARCHAR character_set_catalog, NULL::VARCHAR character_set_schema, 'UTF8' character_set_name, 'UCS' character_repertoire, 'UTF8' form_of_use, current_database() default_collate_catalog, 'pg_catalog' default_collate_schema, 'ucs_basic' default_collate_name;\"},\n \t{\"information_schema\", \"referential_constraints\", \"SELECT f.database_name constraint_catalog, f.schema_name constraint_schema, concat(f.source, '_', f.target, '_', f.target_column, '_fkey') constraint_name, current_database() unique_constraint_catalog, c.schema_name unique_constraint_schema, concat(c.table_name, '_', f.target_column, '_', CASE WHEN c.constraint_type == 'UNIQUE' THEN 'key' ELSE 'pkey' END) unique_constraint_name, 'NONE' match_option, 'NO ACTION' update_rule, 'NO ACTION' delete_rule FROM duckdb_constraints() c JOIN (SELECT *, name_extract['source'] as source, name_extract['target'] as target, name_extract['target_column'] as target_column FROM (SELECT *, regexp_extract(constraint_text, 'FOREIGN KEY \\\\(([a-zA-Z_0-9]+)\\\\) REFERENCES ([a-zA-Z_0-9]+)\\\\(([a-zA-Z_0-9]+)\\\\)', ['source', 'target', 'target_column']) name_extract FROM duckdb_constraints() WHERE constraint_type = 'FOREIGN KEY')) f ON name_extract['target'] = c.table_name AND (c.constraint_type = 'UNIQUE' OR c.constraint_type = 'PRIMARY KEY')\"},\n \t{\"information_schema\", \"key_column_usage\", \"SELECT current_database() constraint_catalog, schema_name constraint_schema, concat(table_name, '_', constraint_column_names[1], CASE constraint_type WHEN 'FOREIGN KEY' THEN '_fkey' WHEN 'PRIMARY KEY' THEN '_pkey' ELSE '_key' END) constraint_name, current_database() table_catalog, schema_name table_schema, table_name, constraint_column_names[1] column_name, 1 ordinal_position, CASE constraint_type WHEN 'FOREIGN KEY' THEN 1 ELSE NULL END position_in_unique_constraint FROM duckdb_constraints() WHERE constraint_type = 'FOREIGN KEY' OR constraint_type = 'PRIMARY KEY' OR constraint_type = 'UNIQUE';\"},\n \t{\"information_schema\", \"table_constraints\", \"SELECT current_database() constraint_catalog, schema_name constraint_schema, concat(table_name, '_', CASE WHEN length(constraint_column_names) > 1 THEN NULL ELSE constraint_column_names[1] || '_' END, CASE constraint_type WHEN 'FOREIGN KEY' THEN 'fkey' WHEN 'PRIMARY KEY' THEN 'pkey' WHEN 'UNIQUE' THEN 'key' WHEN 'CHECK' THEN 'check' WHEN 'NOT NULL' THEN 'not_null'  END) constraint_name, current_database() table_catalog, schema_name table_schema, table_name, CASE constraint_type WHEN 'NOT NULL' THEN 'CHECK' ELSE constraint_type END constraint_type, 'NO' is_deferrable, 'NO' initially_deferred, 'YES' enforced, 'YES' nulls_distinct FROM duckdb_constraints() WHERE constraint_type = 'PRIMARY KEY' OR constraint_type = 'FOREIGN KEY' OR constraint_type = 'UNIQUE' OR constraint_type = 'CHECK' OR constraint_type = 'NOT NULL';\"},\n",
  "test_patch": "diff --git a/test/sql/table_function/information_schema_types.test b/test/sql/table_function/information_schema_types.test\nnew file mode 100644\nindex 000000000000..1bed4fe60fad\n--- /dev/null\n+++ b/test/sql/table_function/information_schema_types.test\n@@ -0,0 +1,16 @@\n+# name: test/sql/table_function/information_schema_types.test\n+# description: Issue #11281: duckdb_columns() produces NULL value as DATA_TYPE for certain INFORMATION_SCHEMA columns\n+# group: [table_function]\n+\n+# Verify all columns in the information_schema have explicitly defined types\n+\n+statement ok\n+pragma enable_verification\n+\n+query II\n+select table_name, column_name\n+from duckdb_columns()\n+where database_name = 'system'\n+and schema_name = 'information_schema'\n+and data_type = 'NULL'\n+----\n",
  "problem_statement": "duckdb_columns() produces NULL value as DATA_TYPE for certain INFORMATION_SCHEMA columns\n### What happens?\n\nWhen using `duckdb_columns()` to introspect the `INFORMATION_SCHEMA`, certain columns don't list the correct `DATA_TYPE`\n\n### To Reproduce\n\n```sql\r\nselect table_name, column_name\r\nfrom duckdb_columns()\r\nwhere database_name = 'system'\r\nand schema_name = 'information_schema'\r\nand data_type = 'NULL'\r\n```\r\n\r\nThis produces:\r\n\r\n```\r\n|table_name    |column_name                  |\r\n|--------------|-----------------------------|\r\n|character_sets|character_set_catalog        |\r\n|character_sets|character_set_schema         |\r\n|columns       |character_octet_length       |\r\n|columns       |datetime_precision           |\r\n|columns       |interval_type                |\r\n|columns       |interval_precision           |\r\n|columns       |character_set_catalog        |\r\n|columns       |character_set_schema         |\r\n|columns       |character_set_name           |\r\n|columns       |collation_catalog            |\r\n|columns       |collation_schema             |\r\n|columns       |collation_name               |\r\n|columns       |domain_catalog               |\r\n|columns       |domain_schema                |\r\n|columns       |domain_name                  |\r\n|columns       |udt_catalog                  |\r\n|columns       |udt_schema                   |\r\n|columns       |udt_name                     |\r\n|columns       |scope_catalog                |\r\n|columns       |scope_schema                 |\r\n|columns       |scope_name                   |\r\n|columns       |maximum_cardinality          |\r\n|columns       |dtd_identifier               |\r\n|columns       |is_self_referencing          |\r\n|columns       |is_identity                  |\r\n|columns       |identity_generation          |\r\n|columns       |identity_start               |\r\n|columns       |identity_increment           |\r\n|columns       |identity_maximum             |\r\n|columns       |identity_minimum             |\r\n|columns       |identity_cycle               |\r\n|columns       |is_generated                 |\r\n|columns       |generation_expression        |\r\n|columns       |is_updatable                 |\r\n|schemata      |default_character_set_catalog|\r\n|schemata      |default_character_set_schema |\r\n|schemata      |default_character_set_name   |\r\n|tables        |self_referencing_column_name |\r\n|tables        |reference_generation         |\r\n|tables        |user_defined_type_catalog    |\r\n|tables        |user_defined_type_schema     |\r\n|tables        |user_defined_type_name       |\r\n```\r\n\r\nNote, I couldn't test the latest snapshots because of:\r\n\r\n- https://github.com/duckdb/duckdb/issues/11244\n\n### OS:\n\nMicrosoft Windows [Version 10.0.22631.3296]\n\n### DuckDB Version:\n\n0.10.0\n\n### DuckDB Client:\n\nJDBC\n\n### Full Name:\n\nLukas Eder\n\n### Affiliation:\n\nData Geekery\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a release build (and could not test with a nightly build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\nduckdb_columns() produces NULL value as DATA_TYPE for certain INFORMATION_SCHEMA columns\n### What happens?\n\nWhen using `duckdb_columns()` to introspect the `INFORMATION_SCHEMA`, certain columns don't list the correct `DATA_TYPE`\n\n### To Reproduce\n\n```sql\r\nselect table_name, column_name\r\nfrom duckdb_columns()\r\nwhere database_name = 'system'\r\nand schema_name = 'information_schema'\r\nand data_type = 'NULL'\r\n```\r\n\r\nThis produces:\r\n\r\n```\r\n|table_name    |column_name                  |\r\n|--------------|-----------------------------|\r\n|character_sets|character_set_catalog        |\r\n|character_sets|character_set_schema         |\r\n|columns       |character_octet_length       |\r\n|columns       |datetime_precision           |\r\n|columns       |interval_type                |\r\n|columns       |interval_precision           |\r\n|columns       |character_set_catalog        |\r\n|columns       |character_set_schema         |\r\n|columns       |character_set_name           |\r\n|columns       |collation_catalog            |\r\n|columns       |collation_schema             |\r\n|columns       |collation_name               |\r\n|columns       |domain_catalog               |\r\n|columns       |domain_schema                |\r\n|columns       |domain_name                  |\r\n|columns       |udt_catalog                  |\r\n|columns       |udt_schema                   |\r\n|columns       |udt_name                     |\r\n|columns       |scope_catalog                |\r\n|columns       |scope_schema                 |\r\n|columns       |scope_name                   |\r\n|columns       |maximum_cardinality          |\r\n|columns       |dtd_identifier               |\r\n|columns       |is_self_referencing          |\r\n|columns       |is_identity                  |\r\n|columns       |identity_generation          |\r\n|columns       |identity_start               |\r\n|columns       |identity_increment           |\r\n|columns       |identity_maximum             |\r\n|columns       |identity_minimum             |\r\n|columns       |identity_cycle               |\r\n|columns       |is_generated                 |\r\n|columns       |generation_expression        |\r\n|columns       |is_updatable                 |\r\n|schemata      |default_character_set_catalog|\r\n|schemata      |default_character_set_schema |\r\n|schemata      |default_character_set_name   |\r\n|tables        |self_referencing_column_name |\r\n|tables        |reference_generation         |\r\n|tables        |user_defined_type_catalog    |\r\n|tables        |user_defined_type_schema     |\r\n|tables        |user_defined_type_name       |\r\n```\r\n\r\nNote, I couldn't test the latest snapshots because of:\r\n\r\n- https://github.com/duckdb/duckdb/issues/11244\n\n### OS:\n\nMicrosoft Windows [Version 10.0.22631.3296]\n\n### DuckDB Version:\n\n0.10.0\n\n### DuckDB Client:\n\nJDBC\n\n### Full Name:\n\nLukas Eder\n\n### Affiliation:\n\nData Geekery\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a release build (and could not test with a nightly build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2024-03-22T18:25:01Z"
}