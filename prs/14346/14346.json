{
  "repo": "duckdb/duckdb",
  "pull_number": 14346,
  "instance_id": "duckdb__duckdb-14346",
  "issue_numbers": [
    "14343"
  ],
  "base_commit": "56e2e0e5721b8547f564fccf252db0ba93c85471",
  "patch": "diff --git a/src/include/duckdb/main/table_description.hpp b/src/include/duckdb/main/table_description.hpp\nindex 2a35b4f16691..151592f49355 100644\n--- a/src/include/duckdb/main/table_description.hpp\n+++ b/src/include/duckdb/main/table_description.hpp\n@@ -13,12 +13,26 @@\n namespace duckdb {\n \n struct TableDescription {\n+public:\n \t//! The schema of the table\n \tstring schema;\n \t//! The table name of the table\n \tstring table;\n \t//! The columns of the table\n \tvector<ColumnDefinition> columns;\n+\n+public:\n+\tidx_t PhysicalColumnCount() const {\n+\t\tidx_t count = 0;\n+\t\tfor (auto &column : columns) {\n+\t\t\tif (column.Generated()) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tcount++;\n+\t\t}\n+\t\tD_ASSERT(count != 0);\n+\t\treturn count;\n+\t}\n };\n \n } // namespace duckdb\ndiff --git a/src/main/appender.cpp b/src/main/appender.cpp\nindex ae3608524149..33ef17bf444c 100644\n--- a/src/main/appender.cpp\n+++ b/src/main/appender.cpp\n@@ -62,6 +62,9 @@ Appender::Appender(Connection &con, const string &schema_name, const string &tab\n \t}\n \tvector<optional_ptr<const ParsedExpression>> defaults;\n \tfor (auto &column : description->columns) {\n+\t\tif (column.Generated()) {\n+\t\t\tcontinue;\n+\t\t}\n \t\ttypes.push_back(column.Type());\n \t\tdefaults.push_back(column.HasDefaultValue() ? &column.DefaultValue() : nullptr);\n \t}\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex 467f28dacde1..90c029ab498b 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -1132,13 +1132,19 @@ void ClientContext::Append(TableDescription &description, ColumnDataCollection &\n \t\tauto &table_entry =\n \t\t    Catalog::GetEntry<TableCatalogEntry>(*this, INVALID_CATALOG, description.schema, description.table);\n \t\t// verify that the table columns and types match up\n-\t\tif (description.columns.size() != table_entry.GetColumns().PhysicalColumnCount()) {\n+\t\tif (description.PhysicalColumnCount() != table_entry.GetColumns().PhysicalColumnCount()) {\n \t\t\tthrow InvalidInputException(\"Failed to append: table entry has different number of columns!\");\n \t\t}\n+\t\tidx_t table_entry_col_idx = 0;\n \t\tfor (idx_t i = 0; i < description.columns.size(); i++) {\n-\t\t\tif (description.columns[i].Type() != table_entry.GetColumns().GetColumn(PhysicalIndex(i)).Type()) {\n+\t\t\tauto &column = description.columns[i];\n+\t\t\tif (column.Generated()) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (column.Type() != table_entry.GetColumns().GetColumn(PhysicalIndex(table_entry_col_idx)).Type()) {\n \t\t\t\tthrow InvalidInputException(\"Failed to append: table entry has different number of columns!\");\n \t\t\t}\n+\t\t\ttable_entry_col_idx++;\n \t\t}\n \t\tauto binder = Binder::CreateBinder(*this);\n \t\tauto bound_constraints = binder->BindConstraints(table_entry);\n",
  "test_patch": "diff --git a/test/appender/test_appender.cpp b/test/appender/test_appender.cpp\nindex bb659982e2c5..e20d498c8833 100644\n--- a/test/appender/test_appender.cpp\n+++ b/test/appender/test_appender.cpp\n@@ -169,6 +169,69 @@ TEST_CASE(\"Test AppendRow\", \"[appender]\") {\n \tREQUIRE(CHECK_COLUMN(result, 2, {Value::TIMESTAMP(1992, 1, 1, 1, 1, 1, 0)}));\n }\n \n+TEST_CASE(\"Test appender with generated column\", \"[appender]\") {\n+\tDuckDB db(nullptr); // Create an in-memory DuckDB database\n+\tConnection con(db); // Create a connection to the database\n+\n+\tSECTION(\"Insert into table with generated column first\") {\n+\t\t// Try to create a table with a generated column\n+\t\tREQUIRE_NOTHROW(con.Query(R\"(\n+\t\t\tCREATE TABLE tbl (\n+\t\t\t\tb VARCHAR GENERATED ALWAYS AS (a),\n+\t\t\t\ta VARCHAR\n+\t\t\t)\n+\t\t)\"));\n+\n+\t\tAppender appender(con, \"tbl\");\n+\t\tREQUIRE_NOTHROW(appender.BeginRow());\n+\t\tREQUIRE_NOTHROW(appender.Append(\"a\"));\n+\n+\t\t// Column 'b' is generated from 'a', so it does not need to be explicitly appended\n+\t\t// End the row\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\n+\t\t// Close the appender\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\n+\t\t// Query the table to verify that the row was inserted correctly\n+\t\tauto result = con.Query(\"SELECT * FROM tbl\");\n+\t\tREQUIRE_NO_FAIL(*result);\n+\n+\t\t// Check that the column 'a' contains \"a\" and 'b' contains the generated value \"a\"\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {Value(\"a\")}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {Value(\"a\")}));\n+\t}\n+\n+\tSECTION(\"Insert into table with generated column second\") {\n+\t\t// Try to create a table with a generated column\n+\t\tREQUIRE_NOTHROW(con.Query(R\"(\n+\t\t\tCREATE TABLE tbl (\n+\t\t\t\ta VARCHAR,\n+\t\t\t\tb VARCHAR GENERATED ALWAYS AS (a)\n+\t\t\t)\n+\t\t)\"));\n+\n+\t\tAppender appender(con, \"tbl\");\n+\t\tREQUIRE_NOTHROW(appender.BeginRow());\n+\t\tREQUIRE_NOTHROW(appender.Append(\"a\"));\n+\n+\t\t// Column 'b' is generated from 'a', so it does not need to be explicitly appended\n+\t\t// End the row\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\n+\t\t// Close the appender\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\n+\t\t// Query the table to verify that the row was inserted correctly\n+\t\tauto result = con.Query(\"SELECT * FROM tbl\");\n+\t\tREQUIRE_NO_FAIL(*result);\n+\n+\t\t// Check that the column 'a' contains \"a\" and 'b' contains the generated value \"a\"\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {Value(\"a\")}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {Value(\"a\")}));\n+\t}\n+}\n+\n TEST_CASE(\"Test default value appender\", \"[appender]\") {\n \tduckdb::unique_ptr<QueryResult> result;\n \tDuckDB db(nullptr);\n",
  "problem_statement": "Appender C API does not support generated columns\n### What happens?\n\nInserting using the appender C API does not work:\r\n\r\n* Inserting a NULL or default value does not work, raises errors\r\n* Not inserting anything does not work either - errors with number of column mismatch \n\n### To Reproduce\n\n```cpp\r\n#include \"duckdb.h\"\r\n\r\nint main() {\r\n  duckdb_database db;\r\n  duckdb_connection con;\r\n\r\n  if (duckdb_open(\"db\", &db) == DuckDBError)\r\n    throw;\r\n  if (duckdb_connect(db, &con) == DuckDBError)\r\n    throw;\r\n\r\n  // works\r\n  // if (duckdb_query(con, \"create or replace table tbl (a varchar)\", NULL) == DuckDBError)\r\n  // does not work\r\n  if (duckdb_query(con, \"create or replace table tbl (a varchar, b varchar generated always as (a))\", NULL) == DuckDBError)\r\n    throw;\r\n\r\n  duckdb_appender appender;\r\n  if (duckdb_appender_create(con, NULL, \"tbl\", &appender) == DuckDBError)\r\n    throw;\r\n\r\n  // append row\r\n  duckdb_append_varchar(appender, \"a\");\r\n  // not appending anything at column b does not work\r\n  // duckdb_append_default(appender); // does not work either\r\n  // duckdb_append_varchar(appender, \"b\"); // does not work either\r\n  if (duckdb_appender_end_row(appender) == DuckDBError)\r\n    throw;\r\n\r\n  duckdb_appender_destroy(&appender);\r\n  duckdb_disconnect(&con);\r\n  duckdb_close(&db);\r\n\r\n  return 0;\r\n}\r\n```\n\n### OS:\n\nUbuntu 22.04.4 LTS (x86_64, WSL)\n\n### DuckDB Version:\n\nv1.1.1 af39bd0dcf\n\n### DuckDB Client:\n\nv1.1.1 af39bd0dcf\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nGerman Gambon\n\n### Affiliation:\n\nN/A\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-10-12T17:27:40Z"
}