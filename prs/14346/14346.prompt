You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Appender C API does not support generated columns
### What happens?

Inserting using the appender C API does not work:

* Inserting a NULL or default value does not work, raises errors
* Not inserting anything does not work either - errors with number of column mismatch 

### To Reproduce

```cpp
#include "duckdb.h"

int main() {
  duckdb_database db;
  duckdb_connection con;

  if (duckdb_open("db", &db) == DuckDBError)
    throw;
  if (duckdb_connect(db, &con) == DuckDBError)
    throw;

  // works
  // if (duckdb_query(con, "create or replace table tbl (a varchar)", NULL) == DuckDBError)
  // does not work
  if (duckdb_query(con, "create or replace table tbl (a varchar, b varchar generated always as (a))", NULL) == DuckDBError)
    throw;

  duckdb_appender appender;
  if (duckdb_appender_create(con, NULL, "tbl", &appender) == DuckDBError)
    throw;

  // append row
  duckdb_append_varchar(appender, "a");
  // not appending anything at column b does not work
  // duckdb_append_default(appender); // does not work either
  // duckdb_append_varchar(appender, "b"); // does not work either
  if (duckdb_appender_end_row(appender) == DuckDBError)
    throw;

  duckdb_appender_destroy(&appender);
  duckdb_disconnect(&con);
  duckdb_close(&db);

  return 0;
}
```

### OS:

Ubuntu 22.04.4 LTS (x86_64, WSL)

### DuckDB Version:

v1.1.1 af39bd0dcf

### DuckDB Client:

v1.1.1 af39bd0dcf

### Hardware:

_No response_

### Full Name:

German Gambon

### Affiliation:

N/A

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/include/duckdb/main/table_description.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/table_description.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/parser/column_definition.hpp"
12: 
13: namespace duckdb {
14: 
15: struct TableDescription {
16: 	//! The schema of the table
17: 	string schema;
18: 	//! The table name of the table
19: 	string table;
20: 	//! The columns of the table
21: 	vector<ColumnDefinition> columns;
22: };
23: 
24: } // namespace duckdb
[end of src/include/duckdb/main/table_description.hpp]
[start of src/main/appender.cpp]
1: #include "duckdb/main/appender.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/duck_table_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/common/operator/cast_operators.hpp"
7: #include "duckdb/common/operator/decimal_cast_operators.hpp"
8: #include "duckdb/common/operator/string_cast.hpp"
9: #include "duckdb/common/string_util.hpp"
10: #include "duckdb/common/types/column/column_data_collection.hpp"
11: #include "duckdb/main/client_context.hpp"
12: #include "duckdb/main/connection.hpp"
13: #include "duckdb/main/database.hpp"
14: #include "duckdb/storage/data_table.hpp"
15: #include "duckdb/planner/expression_binder/constant_binder.hpp"
16: #include "duckdb/planner/expression/bound_constant_expression.hpp"
17: #include "duckdb/execution/expression_executor.hpp"
18: 
19: namespace duckdb {
20: 
21: BaseAppender::BaseAppender(Allocator &allocator, AppenderType type_p)
22:     : allocator(allocator), column(0), appender_type(type_p) {
23: }
24: 
25: BaseAppender::BaseAppender(Allocator &allocator_p, vector<LogicalType> types_p, AppenderType type_p,
26:                            idx_t flush_count_p)
27:     : allocator(allocator_p), types(std::move(types_p)), collection(make_uniq<ColumnDataCollection>(allocator, types)),
28:       column(0), appender_type(type_p), flush_count(flush_count_p) {
29: 	InitializeChunk();
30: }
31: 
32: BaseAppender::~BaseAppender() {
33: }
34: 
35: void BaseAppender::Destructor() {
36: 	if (Exception::UncaughtException()) {
37: 		return;
38: 	}
39: 	// flush any remaining chunks, but only if we are not cleaning up the appender as part of an exception stack unwind
40: 	// wrapped in a try/catch because Close() can throw if the table was dropped in the meantime
41: 	try {
42: 		Close();
43: 	} catch (...) { // NOLINT
44: 	}
45: }
46: 
47: InternalAppender::InternalAppender(ClientContext &context_p, TableCatalogEntry &table_p, idx_t flush_count_p)
48:     : BaseAppender(Allocator::DefaultAllocator(), table_p.GetTypes(), AppenderType::PHYSICAL, flush_count_p),
49:       context(context_p), table(table_p) {
50: }
51: 
52: InternalAppender::~InternalAppender() {
53: 	Destructor();
54: }
55: 
56: Appender::Appender(Connection &con, const string &schema_name, const string &table_name)
57:     : BaseAppender(Allocator::DefaultAllocator(), AppenderType::LOGICAL), context(con.context) {
58: 	description = con.TableInfo(schema_name, table_name);
59: 	if (!description) {
60: 		// table could not be found
61: 		throw CatalogException(StringUtil::Format("Table \"%s.%s\" could not be found", schema_name, table_name));
62: 	}
63: 	vector<optional_ptr<const ParsedExpression>> defaults;
64: 	for (auto &column : description->columns) {
65: 		types.push_back(column.Type());
66: 		defaults.push_back(column.HasDefaultValue() ? &column.DefaultValue() : nullptr);
67: 	}
68: 	auto binder = Binder::CreateBinder(*context);
69: 
70: 	context->RunFunctionInTransaction([&]() {
71: 		for (idx_t i = 0; i < types.size(); i++) {
72: 			auto &type = types[i];
73: 			auto &expr = defaults[i];
74: 
75: 			if (!expr) {
76: 				// Insert NULL
77: 				default_values[i] = Value(type);
78: 				continue;
79: 			}
80: 			auto default_copy = expr->Copy();
81: 			D_ASSERT(!default_copy->HasParameter());
82: 			ConstantBinder default_binder(*binder, *context, "DEFAULT value");
83: 			default_binder.target_type = type;
84: 			auto bound_default = default_binder.Bind(default_copy);
85: 			Value result_value;
86: 			if (bound_default->IsFoldable() &&
87: 			    ExpressionExecutor::TryEvaluateScalar(*context, *bound_default, result_value)) {
88: 				// Insert the evaluated Value
89: 				default_values[i] = result_value;
90: 			} else {
91: 				// These are not supported currently, we don't add them to the 'default_values' map
92: 			}
93: 		}
94: 	});
95: 
96: 	InitializeChunk();
97: 	collection = make_uniq<ColumnDataCollection>(allocator, types);
98: }
99: 
100: Appender::Appender(Connection &con, const string &table_name) : Appender(con, DEFAULT_SCHEMA, table_name) {
101: }
102: 
103: Appender::~Appender() {
104: 	Destructor();
105: }
106: 
107: void BaseAppender::InitializeChunk() {
108: 	chunk.Initialize(allocator, types);
109: }
110: 
111: void BaseAppender::BeginRow() {
112: }
113: 
114: void BaseAppender::EndRow() {
115: 	// check that all rows have been appended to
116: 	if (column != chunk.ColumnCount()) {
117: 		throw InvalidInputException("Call to EndRow before all columns have been appended to!");
118: 	}
119: 	column = 0;
120: 	chunk.SetCardinality(chunk.size() + 1);
121: 	if (chunk.size() >= STANDARD_VECTOR_SIZE) {
122: 		FlushChunk();
123: 	}
124: }
125: 
126: template <class SRC, class DST>
127: void BaseAppender::AppendValueInternal(Vector &col, SRC input) {
128: 	FlatVector::GetData<DST>(col)[chunk.size()] = Cast::Operation<SRC, DST>(input);
129: }
130: 
131: template <class SRC, class DST>
132: void BaseAppender::AppendDecimalValueInternal(Vector &col, SRC input) {
133: 	switch (appender_type) {
134: 	case AppenderType::LOGICAL: {
135: 		auto &type = col.GetType();
136: 		D_ASSERT(type.id() == LogicalTypeId::DECIMAL);
137: 		auto width = DecimalType::GetWidth(type);
138: 		auto scale = DecimalType::GetScale(type);
139: 		CastParameters parameters;
140: 		TryCastToDecimal::Operation<SRC, DST>(input, FlatVector::GetData<DST>(col)[chunk.size()], parameters, width,
141: 		                                      scale);
142: 		return;
143: 	}
144: 	case AppenderType::PHYSICAL: {
145: 		AppendValueInternal<SRC, DST>(col, input);
146: 		return;
147: 	}
148: 	default:
149: 		throw InternalException("Type not implemented for AppenderType");
150: 	}
151: }
152: 
153: template <class T>
154: void BaseAppender::AppendValueInternal(T input) {
155: 	if (column >= types.size()) {
156: 		throw InvalidInputException("Too many appends for chunk!");
157: 	}
158: 	auto &col = chunk.data[column];
159: 	switch (col.GetType().id()) {
160: 	case LogicalTypeId::BOOLEAN:
161: 		AppendValueInternal<T, bool>(col, input);
162: 		break;
163: 	case LogicalTypeId::UTINYINT:
164: 		AppendValueInternal<T, uint8_t>(col, input);
165: 		break;
166: 	case LogicalTypeId::TINYINT:
167: 		AppendValueInternal<T, int8_t>(col, input);
168: 		break;
169: 	case LogicalTypeId::USMALLINT:
170: 		AppendValueInternal<T, uint16_t>(col, input);
171: 		break;
172: 	case LogicalTypeId::SMALLINT:
173: 		AppendValueInternal<T, int16_t>(col, input);
174: 		break;
175: 	case LogicalTypeId::UINTEGER:
176: 		AppendValueInternal<T, uint32_t>(col, input);
177: 		break;
178: 	case LogicalTypeId::INTEGER:
179: 		AppendValueInternal<T, int32_t>(col, input);
180: 		break;
181: 	case LogicalTypeId::UBIGINT:
182: 		AppendValueInternal<T, uint64_t>(col, input);
183: 		break;
184: 	case LogicalTypeId::BIGINT:
185: 		AppendValueInternal<T, int64_t>(col, input);
186: 		break;
187: 	case LogicalTypeId::HUGEINT:
188: 		AppendValueInternal<T, hugeint_t>(col, input);
189: 		break;
190: 	case LogicalTypeId::UHUGEINT:
191: 		AppendValueInternal<T, uhugeint_t>(col, input);
192: 		break;
193: 	case LogicalTypeId::FLOAT:
194: 		AppendValueInternal<T, float>(col, input);
195: 		break;
196: 	case LogicalTypeId::DOUBLE:
197: 		AppendValueInternal<T, double>(col, input);
198: 		break;
199: 	case LogicalTypeId::DECIMAL:
200: 		switch (col.GetType().InternalType()) {
201: 		case PhysicalType::INT16:
202: 			AppendDecimalValueInternal<T, int16_t>(col, input);
203: 			break;
204: 		case PhysicalType::INT32:
205: 			AppendDecimalValueInternal<T, int32_t>(col, input);
206: 			break;
207: 		case PhysicalType::INT64:
208: 			AppendDecimalValueInternal<T, int64_t>(col, input);
209: 			break;
210: 		case PhysicalType::INT128:
211: 			AppendDecimalValueInternal<T, hugeint_t>(col, input);
212: 			break;
213: 		default:
214: 			throw InternalException("Internal type not recognized for Decimal");
215: 		}
216: 		break;
217: 	case LogicalTypeId::DATE:
218: 		AppendValueInternal<T, date_t>(col, input);
219: 		break;
220: 	case LogicalTypeId::TIMESTAMP:
221: 	case LogicalTypeId::TIMESTAMP_TZ:
222: 		AppendValueInternal<T, timestamp_t>(col, input);
223: 		break;
224: 	case LogicalTypeId::TIME:
225: 		AppendValueInternal<T, dtime_t>(col, input);
226: 		break;
227: 	case LogicalTypeId::TIME_TZ:
228: 		AppendValueInternal<T, dtime_tz_t>(col, input);
229: 		break;
230: 	case LogicalTypeId::INTERVAL:
231: 		AppendValueInternal<T, interval_t>(col, input);
232: 		break;
233: 	case LogicalTypeId::VARCHAR:
234: 		FlatVector::GetData<string_t>(col)[chunk.size()] = StringCast::Operation<T>(input, col);
235: 		break;
236: 	default:
237: 		AppendValue(Value::CreateValue<T>(input));
238: 		return;
239: 	}
240: 	column++;
241: }
242: 
243: template <>
244: void BaseAppender::Append(bool value) {
245: 	AppendValueInternal<bool>(value);
246: }
247: 
248: template <>
249: void BaseAppender::Append(int8_t value) {
250: 	AppendValueInternal<int8_t>(value);
251: }
252: 
253: template <>
254: void BaseAppender::Append(int16_t value) {
255: 	AppendValueInternal<int16_t>(value);
256: }
257: 
258: template <>
259: void BaseAppender::Append(int32_t value) {
260: 	AppendValueInternal<int32_t>(value);
261: }
262: 
263: template <>
264: void BaseAppender::Append(int64_t value) {
265: 	AppendValueInternal<int64_t>(value);
266: }
267: 
268: template <>
269: void BaseAppender::Append(hugeint_t value) {
270: 	AppendValueInternal<hugeint_t>(value);
271: }
272: 
273: template <>
274: void BaseAppender::Append(uhugeint_t value) {
275: 	AppendValueInternal<uhugeint_t>(value);
276: }
277: 
278: template <>
279: void BaseAppender::Append(uint8_t value) {
280: 	AppendValueInternal<uint8_t>(value);
281: }
282: 
283: template <>
284: void BaseAppender::Append(uint16_t value) {
285: 	AppendValueInternal<uint16_t>(value);
286: }
287: 
288: template <>
289: void BaseAppender::Append(uint32_t value) {
290: 	AppendValueInternal<uint32_t>(value);
291: }
292: 
293: template <>
294: void BaseAppender::Append(uint64_t value) {
295: 	AppendValueInternal<uint64_t>(value);
296: }
297: 
298: template <>
299: void BaseAppender::Append(const char *value) {
300: 	AppendValueInternal<string_t>(string_t(value));
301: }
302: 
303: void BaseAppender::Append(const char *value, uint32_t length) {
304: 	AppendValueInternal<string_t>(string_t(value, length));
305: }
306: 
307: template <>
308: void BaseAppender::Append(string_t value) {
309: 	AppendValueInternal<string_t>(value);
310: }
311: 
312: template <>
313: void BaseAppender::Append(float value) {
314: 	AppendValueInternal<float>(value);
315: }
316: 
317: template <>
318: void BaseAppender::Append(double value) {
319: 	AppendValueInternal<double>(value);
320: }
321: 
322: template <>
323: void BaseAppender::Append(date_t value) {
324: 	AppendValueInternal<date_t>(value);
325: }
326: 
327: template <>
328: void BaseAppender::Append(dtime_t value) {
329: 	AppendValueInternal<dtime_t>(value);
330: }
331: 
332: template <>
333: void BaseAppender::Append(timestamp_t value) {
334: 	AppendValueInternal<timestamp_t>(value);
335: }
336: 
337: template <>
338: void BaseAppender::Append(interval_t value) {
339: 	AppendValueInternal<interval_t>(value);
340: }
341: 
342: template <>
343: void BaseAppender::Append(Value value) { // NOLINT: template shtuff
344: 	if (column >= chunk.ColumnCount()) {
345: 		throw InvalidInputException("Too many appends for chunk!");
346: 	}
347: 	AppendValue(value);
348: }
349: 
350: template <>
351: void BaseAppender::Append(std::nullptr_t value) {
352: 	if (column >= chunk.ColumnCount()) {
353: 		throw InvalidInputException("Too many appends for chunk!");
354: 	}
355: 	auto &col = chunk.data[column++];
356: 	FlatVector::SetNull(col, chunk.size(), true);
357: }
358: 
359: void BaseAppender::AppendValue(const Value &value) {
360: 	chunk.SetValue(column, chunk.size(), value);
361: 	column++;
362: }
363: 
364: void BaseAppender::AppendDataChunk(DataChunk &chunk) {
365: 	auto chunk_types = chunk.GetTypes();
366: 	if (chunk_types != types) {
367: 		for (idx_t i = 0; i < chunk.ColumnCount(); i++) {
368: 			if (chunk.data[i].GetType() != types[i]) {
369: 				throw InvalidInputException("Type mismatch in Append DataChunk and the types required for appender, "
370: 				                            "expected %s but got %s for column %d",
371: 				                            types[i].ToString(), chunk.data[i].GetType().ToString(), i + 1);
372: 			}
373: 		}
374: 	}
375: 	collection->Append(chunk);
376: 	if (collection->Count() >= flush_count) {
377: 		Flush();
378: 	}
379: }
380: 
381: void BaseAppender::FlushChunk() {
382: 	if (chunk.size() == 0) {
383: 		return;
384: 	}
385: 	collection->Append(chunk);
386: 	chunk.Reset();
387: 	if (collection->Count() >= flush_count) {
388: 		Flush();
389: 	}
390: }
391: 
392: void BaseAppender::Flush() {
393: 	// check that all vectors have the same length before appending
394: 	if (column != 0) {
395: 		throw InvalidInputException("Failed to Flush appender: incomplete append to row!");
396: 	}
397: 
398: 	FlushChunk();
399: 	if (collection->Count() == 0) {
400: 		return;
401: 	}
402: 	FlushInternal(*collection);
403: 
404: 	collection->Reset();
405: 	column = 0;
406: }
407: 
408: void Appender::FlushInternal(ColumnDataCollection &collection) {
409: 	context->Append(*description, collection);
410: }
411: 
412: void Appender::AppendDefault() {
413: 	auto it = default_values.find(column);
414: 	auto &column_def = description->columns[column];
415: 	if (it == default_values.end()) {
416: 		throw NotImplementedException(
417: 		    "AppendDefault is currently not supported for column \"%s\" because default expression is not foldable.",
418: 		    column_def.Name());
419: 	}
420: 	auto &default_value = it->second;
421: 	Append(default_value);
422: }
423: 
424: void InternalAppender::FlushInternal(ColumnDataCollection &collection) {
425: 	auto binder = Binder::CreateBinder(context);
426: 	auto bound_constraints = binder->BindConstraints(table);
427: 	table.GetStorage().LocalAppend(table, context, collection, bound_constraints);
428: }
429: 
430: void BaseAppender::Close() {
431: 	if (column == 0 || column == types.size()) {
432: 		Flush();
433: 	}
434: }
435: 
436: } // namespace duckdb
[end of src/main/appender.cpp]
[start of src/main/client_context.cpp]
1: #include "duckdb/main/client_context.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_search_path.hpp"
6: #include "duckdb/common/error_data.hpp"
7: #include "duckdb/common/exception/transaction_exception.hpp"
8: #include "duckdb/common/progress_bar/progress_bar.hpp"
9: #include "duckdb/common/serializer/buffered_file_writer.hpp"
10: #include "duckdb/common/types/column/column_data_collection.hpp"
11: #include "duckdb/execution/column_binding_resolver.hpp"
12: #include "duckdb/execution/operator/helper/physical_result_collector.hpp"
13: #include "duckdb/execution/physical_plan_generator.hpp"
14: #include "duckdb/main/appender.hpp"
15: #include "duckdb/main/attached_database.hpp"
16: #include "duckdb/main/client_context_file_opener.hpp"
17: #include "duckdb/main/client_context_state.hpp"
18: #include "duckdb/main/client_data.hpp"
19: #include "duckdb/main/database.hpp"
20: #include "duckdb/main/database_manager.hpp"
21: #include "duckdb/main/error_manager.hpp"
22: #include "duckdb/main/materialized_query_result.hpp"
23: #include "duckdb/main/query_profiler.hpp"
24: #include "duckdb/main/query_result.hpp"
25: #include "duckdb/main/relation.hpp"
26: #include "duckdb/main/stream_query_result.hpp"
27: #include "duckdb/optimizer/optimizer.hpp"
28: #include "duckdb/parser/expression/constant_expression.hpp"
29: #include "duckdb/parser/expression/parameter_expression.hpp"
30: #include "duckdb/parser/parsed_data/create_function_info.hpp"
31: #include "duckdb/parser/parser.hpp"
32: #include "duckdb/parser/query_node/select_node.hpp"
33: #include "duckdb/parser/statement/drop_statement.hpp"
34: #include "duckdb/parser/statement/execute_statement.hpp"
35: #include "duckdb/parser/statement/explain_statement.hpp"
36: #include "duckdb/parser/statement/prepare_statement.hpp"
37: #include "duckdb/parser/statement/relation_statement.hpp"
38: #include "duckdb/parser/statement/select_statement.hpp"
39: #include "duckdb/planner/operator/logical_execute.hpp"
40: #include "duckdb/planner/planner.hpp"
41: #include "duckdb/planner/pragma_handler.hpp"
42: #include "duckdb/storage/data_table.hpp"
43: #include "duckdb/transaction/meta_transaction.hpp"
44: #include "duckdb/transaction/transaction_manager.hpp"
45: 
46: namespace duckdb {
47: 
48: struct ActiveQueryContext {
49: public:
50: 	//! The query that is currently being executed
51: 	string query;
52: 	//! Prepared statement data
53: 	shared_ptr<PreparedStatementData> prepared;
54: 	//! The query executor
55: 	unique_ptr<Executor> executor;
56: 	//! The progress bar
57: 	unique_ptr<ProgressBar> progress_bar;
58: 
59: public:
60: 	void SetOpenResult(BaseQueryResult &result) {
61: 		open_result = &result;
62: 	}
63: 	bool IsOpenResult(BaseQueryResult &result) {
64: 		return open_result == &result;
65: 	}
66: 	bool HasOpenResult() const {
67: 		return open_result != nullptr;
68: 	}
69: 
70: private:
71: 	//! The currently open result
72: 	BaseQueryResult *open_result = nullptr;
73: };
74: 
75: #ifdef DEBUG
76: struct DebugClientContextState : public ClientContextState {
77: 	~DebugClientContextState() override {
78: 		D_ASSERT(!active_transaction);
79: 		D_ASSERT(!active_query);
80: 	}
81: 
82: 	bool active_transaction = false;
83: 	bool active_query = false;
84: 
85: 	void QueryBegin(ClientContext &context) override {
86: 		if (active_query) {
87: 			throw InternalException("DebugClientContextState::QueryBegin called when a query is already active");
88: 		}
89: 		active_query = true;
90: 	}
91: 	void QueryEnd(ClientContext &context) override {
92: 		if (!active_query) {
93: 			throw InternalException("DebugClientContextState::QueryEnd called when no query is active");
94: 		}
95: 		active_query = false;
96: 	}
97: 	void TransactionBegin(MetaTransaction &transaction, ClientContext &context) override {
98: 		if (active_transaction) {
99: 			throw InternalException(
100: 			    "DebugClientContextState::TransactionBegin called when a transaction is already active");
101: 		}
102: 		active_transaction = true;
103: 	}
104: 	void TransactionCommit(MetaTransaction &transaction, ClientContext &context) override {
105: 		if (!active_transaction) {
106: 			throw InternalException("DebugClientContextState::TransactionCommit called when no transaction is active");
107: 		}
108: 		active_transaction = false;
109: 	}
110: 	void TransactionRollback(MetaTransaction &transaction, ClientContext &context) override {
111: 		if (!active_transaction) {
112: 			throw InternalException(
113: 			    "DebugClientContextState::TransactionRollback called when no transaction is active");
114: 		}
115: 		active_transaction = false;
116: 	}
117: #ifdef DUCKDB_DEBUG_REBIND
118: 	RebindQueryInfo OnPlanningError(ClientContext &context, SQLStatement &statement, ErrorData &error) override {
119: 		return RebindQueryInfo::ATTEMPT_TO_REBIND;
120: 	}
121: 	RebindQueryInfo OnFinalizePrepare(ClientContext &context, PreparedStatementData &prepared,
122: 	                                  PreparedStatementMode mode) override {
123: 		if (mode == PreparedStatementMode::PREPARE_AND_EXECUTE) {
124: 			return RebindQueryInfo::ATTEMPT_TO_REBIND;
125: 		}
126: 		return RebindQueryInfo::DO_NOT_REBIND;
127: 	}
128: 	RebindQueryInfo OnExecutePrepared(ClientContext &context, PreparedStatementCallbackInfo &info,
129: 	                                  RebindQueryInfo current_rebind) override {
130: 		return RebindQueryInfo::ATTEMPT_TO_REBIND;
131: 	}
132: #endif
133: };
134: #endif
135: 
136: ClientContext::ClientContext(shared_ptr<DatabaseInstance> database)
137:     : db(std::move(database)), interrupted(false), client_data(make_uniq<ClientData>(*this)), transaction(*this) {
138: 	registered_state = make_uniq<RegisteredStateManager>();
139: #ifdef DEBUG
140: 	registered_state->GetOrCreate<DebugClientContextState>("debug_client_context_state");
141: #endif
142: }
143: 
144: ClientContext::~ClientContext() {
145: 	if (Exception::UncaughtException()) {
146: 		return;
147: 	}
148: 	// destroy the client context and rollback if there is an active transaction
149: 	// but only if we are not destroying this client context as part of an exception stack unwind
150: 	Destroy();
151: }
152: 
153: unique_ptr<ClientContextLock> ClientContext::LockContext() {
154: 	return make_uniq<ClientContextLock>(context_lock);
155: }
156: 
157: void ClientContext::Destroy() {
158: 	auto lock = LockContext();
159: 	if (transaction.HasActiveTransaction()) {
160: 		transaction.ResetActiveQuery();
161: 		if (!transaction.IsAutoCommit()) {
162: 			transaction.Rollback(nullptr);
163: 		}
164: 	}
165: 	CleanupInternal(*lock);
166: }
167: 
168: void ClientContext::ProcessError(ErrorData &error, const string &query) const {
169: 	if (config.errors_as_json) {
170: 		error.ConvertErrorToJSON();
171: 	} else if (!query.empty()) {
172: 		error.AddErrorLocation(query);
173: 	}
174: }
175: 
176: template <class T>
177: unique_ptr<T> ClientContext::ErrorResult(ErrorData error, const string &query) {
178: 	ProcessError(error, query);
179: 	return make_uniq<T>(std::move(error));
180: }
181: 
182: void ClientContext::BeginQueryInternal(ClientContextLock &lock, const string &query) {
183: 	// check if we are on AutoCommit. In this case we should start a transaction
184: 	D_ASSERT(!active_query);
185: 	auto &db_inst = DatabaseInstance::GetDatabase(*this);
186: 	if (ValidChecker::IsInvalidated(db_inst)) {
187: 		throw ErrorManager::InvalidatedDatabase(*this, ValidChecker::InvalidatedMessage(db_inst));
188: 	}
189: 	active_query = make_uniq<ActiveQueryContext>();
190: 	if (transaction.IsAutoCommit()) {
191: 		transaction.BeginTransaction();
192: 	}
193: 	transaction.SetActiveQuery(db->GetDatabaseManager().GetNewQueryNumber());
194: 	LogQueryInternal(lock, query);
195: 	active_query->query = query;
196: 
197: 	query_progress.Initialize();
198: 	// Notify any registered state of query begin
199: 	for (auto &state : registered_state->States()) {
200: 		state->QueryBegin(*this);
201: 	}
202: }
203: 
204: ErrorData ClientContext::EndQueryInternal(ClientContextLock &lock, bool success, bool invalidate_transaction,
205:                                           optional_ptr<ErrorData> previous_error) {
206: 	client_data->profiler->EndQuery();
207: 
208: 	if (active_query->executor) {
209: 		active_query->executor->CancelTasks();
210: 	}
211: 	active_query->progress_bar.reset();
212: 
213: 	D_ASSERT(active_query.get());
214: 	active_query.reset();
215: 	query_progress.Initialize();
216: 	ErrorData error;
217: 	try {
218: 		if (transaction.HasActiveTransaction()) {
219: 			transaction.ResetActiveQuery();
220: 			if (transaction.IsAutoCommit()) {
221: 				if (success) {
222: 					transaction.Commit();
223: 				} else {
224: 					transaction.Rollback(previous_error);
225: 				}
226: 			} else if (invalidate_transaction) {
227: 				D_ASSERT(!success);
228: 				ValidChecker::Invalidate(ActiveTransaction(), "Failed to commit");
229: 			}
230: 		}
231: 	} catch (std::exception &ex) {
232: 		error = ErrorData(ex);
233: 		if (Exception::InvalidatesDatabase(error.Type())) {
234: 			auto &db_inst = DatabaseInstance::GetDatabase(*this);
235: 			ValidChecker::Invalidate(db_inst, error.RawMessage());
236: 		}
237: 	} catch (...) { // LCOV_EXCL_START
238: 		error = ErrorData("Unhandled exception!");
239: 	} // LCOV_EXCL_STOP
240: 
241: 	// Notify any registered state of query end
242: 	for (auto const &s : registered_state->States()) {
243: 		if (error.HasError()) {
244: 			s->QueryEnd(*this, &error);
245: 		} else {
246: 			s->QueryEnd(*this, previous_error);
247: 		}
248: 	}
249: 
250: 	return error;
251: }
252: 
253: void ClientContext::CleanupInternal(ClientContextLock &lock, BaseQueryResult *result, bool invalidate_transaction) {
254: 	if (!active_query) {
255: 		// no query currently active
256: 		return;
257: 	}
258: 	if (active_query->executor) {
259: 		active_query->executor->CancelTasks();
260: 	}
261: 	active_query->progress_bar.reset();
262: 
263: 	// Relaunch the threads if a SET THREADS command was issued
264: 	auto &scheduler = TaskScheduler::GetScheduler(*this);
265: 	scheduler.RelaunchThreads();
266: 
267: 	optional_ptr<ErrorData> passed_error = nullptr;
268: 	if (result && result->HasError()) {
269: 		passed_error = result->GetErrorObject();
270: 	}
271: 	auto error = EndQueryInternal(lock, result ? !result->HasError() : false, invalidate_transaction, passed_error);
272: 	if (result && !result->HasError()) {
273: 		// if an error occurred while committing report it in the result
274: 		result->SetError(error);
275: 	}
276: 	D_ASSERT(!active_query);
277: }
278: 
279: Executor &ClientContext::GetExecutor() {
280: 	D_ASSERT(active_query);
281: 	D_ASSERT(active_query->executor);
282: 	return *active_query->executor;
283: }
284: 
285: const string &ClientContext::GetCurrentQuery() {
286: 	D_ASSERT(active_query);
287: 	return active_query->query;
288: }
289: 
290: unique_ptr<QueryResult> ClientContext::FetchResultInternal(ClientContextLock &lock, PendingQueryResult &pending) {
291: 	D_ASSERT(active_query);
292: 	D_ASSERT(active_query->IsOpenResult(pending));
293: 	D_ASSERT(active_query->prepared);
294: 	auto &executor = GetExecutor();
295: 	auto &prepared = *active_query->prepared;
296: 	bool create_stream_result = prepared.properties.allow_stream_result && pending.allow_stream_result;
297: 	unique_ptr<QueryResult> result;
298: 	D_ASSERT(executor.HasResultCollector());
299: 	// we have a result collector - fetch the result directly from the result collector
300: 	result = executor.GetResult();
301: 	if (!create_stream_result) {
302: 		CleanupInternal(lock, result.get(), false);
303: 	} else {
304: 		active_query->SetOpenResult(*result);
305: 	}
306: 	return result;
307: }
308: 
309: static bool IsExplainAnalyze(SQLStatement *statement) {
310: 	if (!statement) {
311: 		return false;
312: 	}
313: 	if (statement->type != StatementType::EXPLAIN_STATEMENT) {
314: 		return false;
315: 	}
316: 	auto &explain = statement->Cast<ExplainStatement>();
317: 	return explain.explain_type == ExplainType::EXPLAIN_ANALYZE;
318: }
319: 
320: shared_ptr<PreparedStatementData>
321: ClientContext::CreatePreparedStatementInternal(ClientContextLock &lock, const string &query,
322:                                                unique_ptr<SQLStatement> statement,
323:                                                optional_ptr<case_insensitive_map_t<BoundParameterData>> values) {
324: 	StatementType statement_type = statement->type;
325: 	auto result = make_shared_ptr<PreparedStatementData>(statement_type);
326: 
327: 	auto &profiler = QueryProfiler::Get(*this);
328: 	profiler.StartQuery(query, IsExplainAnalyze(statement.get()), true);
329: 	profiler.StartPhase(MetricsType::PLANNER);
330: 	Planner planner(*this);
331: 	if (values) {
332: 		auto &parameter_values = *values;
333: 		for (auto &value : parameter_values) {
334: 			planner.parameter_data.emplace(value.first, BoundParameterData(value.second));
335: 		}
336: 	}
337: 
338: 	planner.CreatePlan(std::move(statement));
339: 	D_ASSERT(planner.plan || !planner.properties.bound_all_parameters);
340: 	profiler.EndPhase();
341: 
342: 	auto plan = std::move(planner.plan);
343: 	// extract the result column names from the plan
344: 	result->properties = planner.properties;
345: 	result->names = planner.names;
346: 	result->types = planner.types;
347: 	result->value_map = std::move(planner.value_map);
348: 	if (!planner.properties.bound_all_parameters) {
349: 		return result;
350: 	}
351: #ifdef DEBUG
352: 	plan->Verify(*this);
353: #endif
354: 	if (config.enable_optimizer && plan->RequireOptimizer()) {
355: 		profiler.StartPhase(MetricsType::ALL_OPTIMIZERS);
356: 		Optimizer optimizer(*planner.binder, *this);
357: 		plan = optimizer.Optimize(std::move(plan));
358: 		D_ASSERT(plan);
359: 		profiler.EndPhase();
360: 
361: #ifdef DEBUG
362: 		plan->Verify(*this);
363: #endif
364: 	}
365: 
366: 	profiler.StartPhase(MetricsType::PHYSICAL_PLANNER);
367: 	// now convert logical query plan into a physical query plan
368: 	PhysicalPlanGenerator physical_planner(*this);
369: 	auto physical_plan = physical_planner.CreatePlan(std::move(plan));
370: 	profiler.EndPhase();
371: 
372: #ifdef DEBUG
373: 	D_ASSERT(!physical_plan->ToString().empty());
374: #endif
375: 	result->plan = std::move(physical_plan);
376: 	return result;
377: }
378: 
379: shared_ptr<PreparedStatementData>
380: ClientContext::CreatePreparedStatement(ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,
381:                                        optional_ptr<case_insensitive_map_t<BoundParameterData>> values,
382:                                        PreparedStatementMode mode) {
383: 	// check if any client context state could request a rebind
384: 	bool can_request_rebind = false;
385: 	for (auto &state : registered_state->States()) {
386: 		if (state->CanRequestRebind()) {
387: 			can_request_rebind = true;
388: 		}
389: 	}
390: 	if (can_request_rebind) {
391: 		bool rebind = false;
392: 		// if any registered state can request a rebind we do the binding on a copy first
393: 		shared_ptr<PreparedStatementData> result;
394: 		try {
395: 			result = CreatePreparedStatementInternal(lock, query, statement->Copy(), values);
396: 		} catch (std::exception &ex) {
397: 			ErrorData error(ex);
398: 			// check if any registered client context state wants to try a rebind
399: 			for (auto &state : registered_state->States()) {
400: 				auto info = state->OnPlanningError(*this, *statement, error);
401: 				if (info == RebindQueryInfo::ATTEMPT_TO_REBIND) {
402: 					rebind = true;
403: 				}
404: 			}
405: 			if (!rebind) {
406: 				throw;
407: 			}
408: 		}
409: 		if (result) {
410: 			D_ASSERT(!rebind);
411: 			for (auto &state : registered_state->States()) {
412: 				auto info = state->OnFinalizePrepare(*this, *result, mode);
413: 				if (info == RebindQueryInfo::ATTEMPT_TO_REBIND) {
414: 					rebind = true;
415: 				}
416: 			}
417: 		}
418: 		if (!rebind) {
419: 			return result;
420: 		}
421: 		// an extension wants to do a rebind - do it once
422: 	}
423: 
424: 	return CreatePreparedStatementInternal(lock, query, std::move(statement), values);
425: }
426: 
427: QueryProgress ClientContext::GetQueryProgress() {
428: 	return query_progress;
429: }
430: 
431: void BindPreparedStatementParameters(PreparedStatementData &statement, const PendingQueryParameters &parameters) {
432: 	case_insensitive_map_t<BoundParameterData> owned_values;
433: 	if (parameters.parameters) {
434: 		auto &params = *parameters.parameters;
435: 		for (auto &val : params) {
436: 			owned_values.emplace(val);
437: 		}
438: 	}
439: 	statement.Bind(std::move(owned_values));
440: }
441: 
442: void ClientContext::RebindPreparedStatement(ClientContextLock &lock, const string &query,
443:                                             shared_ptr<PreparedStatementData> &prepared,
444:                                             const PendingQueryParameters &parameters) {
445: 	if (!prepared->unbound_statement) {
446: 		throw InternalException("ClientContext::RebindPreparedStatement called but PreparedStatementData did not have "
447: 		                        "an unbound statement so rebinding cannot be done");
448: 	}
449: 	// catalog was modified: rebind the statement before execution
450: 	auto new_prepared =
451: 	    CreatePreparedStatement(lock, query, prepared->unbound_statement->Copy(), parameters.parameters);
452: 	D_ASSERT(new_prepared->properties.bound_all_parameters);
453: 	new_prepared->properties.parameter_count = prepared->properties.parameter_count;
454: 	prepared = std::move(new_prepared);
455: 	prepared->properties.bound_all_parameters = false;
456: }
457: 
458: void ClientContext::CheckIfPreparedStatementIsExecutable(PreparedStatementData &statement) {
459: 	if (ValidChecker::IsInvalidated(ActiveTransaction()) && statement.properties.requires_valid_transaction) {
460: 		throw ErrorManager::InvalidatedTransaction(*this);
461: 	}
462: 	auto &meta_transaction = MetaTransaction::Get(*this);
463: 	auto &manager = DatabaseManager::Get(*this);
464: 	for (auto &it : statement.properties.modified_databases) {
465: 		auto &modified_database = it.first;
466: 		auto entry = manager.GetDatabase(*this, modified_database);
467: 		if (!entry) {
468: 			throw InternalException("Database \"%s\" not found", modified_database);
469: 		}
470: 		if (entry->IsReadOnly()) {
471: 			throw InvalidInputException(StringUtil::Format(
472: 			    "Cannot execute statement of type \"%s\" on database \"%s\" which is attached in read-only mode!",
473: 			    StatementTypeToString(statement.statement_type), modified_database));
474: 		}
475: 		meta_transaction.ModifyDatabase(*entry);
476: 	}
477: }
478: 
479: unique_ptr<PendingQueryResult>
480: ClientContext::PendingPreparedStatementInternal(ClientContextLock &lock, shared_ptr<PreparedStatementData> statement_p,
481:                                                 const PendingQueryParameters &parameters) {
482: 	D_ASSERT(active_query);
483: 	auto &statement = *statement_p;
484: 
485: 	BindPreparedStatementParameters(statement, parameters);
486: 
487: 	active_query->executor = make_uniq<Executor>(*this);
488: 	auto &executor = *active_query->executor;
489: 	if (config.enable_progress_bar) {
490: 		progress_bar_display_create_func_t display_create_func = nullptr;
491: 		if (config.print_progress_bar) {
492: 			// If a custom display is set, use that, otherwise just use the default
493: 			display_create_func =
494: 			    config.display_create_func ? config.display_create_func : ProgressBar::DefaultProgressBarDisplay;
495: 		}
496: 		active_query->progress_bar =
497: 		    make_uniq<ProgressBar>(executor, NumericCast<idx_t>(config.wait_time), display_create_func);
498: 		active_query->progress_bar->Start();
499: 		query_progress.Restart();
500: 	}
501: 	auto stream_result = parameters.allow_stream_result && statement.properties.allow_stream_result;
502: 
503: 	get_result_collector_t get_method = PhysicalResultCollector::GetResultCollector;
504: 	auto &client_config = ClientConfig::GetConfig(*this);
505: 	if (!stream_result && client_config.result_collector) {
506: 		get_method = client_config.result_collector;
507: 	}
508: 	statement.is_streaming = stream_result;
509: 	auto collector = get_method(*this, statement);
510: 	D_ASSERT(collector->type == PhysicalOperatorType::RESULT_COLLECTOR);
511: 	executor.Initialize(std::move(collector));
512: 
513: 	auto types = executor.GetTypes();
514: 	D_ASSERT(types == statement.types);
515: 	D_ASSERT(!active_query->HasOpenResult());
516: 
517: 	auto pending_result =
518: 	    make_uniq<PendingQueryResult>(shared_from_this(), *statement_p, std::move(types), stream_result);
519: 	active_query->prepared = std::move(statement_p);
520: 	active_query->SetOpenResult(*pending_result);
521: 	return pending_result;
522: }
523: 
524: unique_ptr<PendingQueryResult> ClientContext::PendingPreparedStatement(ClientContextLock &lock, const string &query,
525:                                                                        shared_ptr<PreparedStatementData> prepared,
526:                                                                        const PendingQueryParameters &parameters) {
527: 	CheckIfPreparedStatementIsExecutable(*prepared);
528: 
529: 	RebindQueryInfo rebind = RebindQueryInfo::DO_NOT_REBIND;
530: 	if (prepared->RequireRebind(*this, parameters.parameters)) {
531: 		rebind = RebindQueryInfo::ATTEMPT_TO_REBIND;
532: 	}
533: 
534: 	for (auto &state : registered_state->States()) {
535: 		PreparedStatementCallbackInfo info(*prepared, parameters);
536: 		auto new_rebind = state->OnExecutePrepared(*this, info, rebind);
537: 		if (new_rebind == RebindQueryInfo::ATTEMPT_TO_REBIND) {
538: 			rebind = RebindQueryInfo::ATTEMPT_TO_REBIND;
539: 		}
540: 	}
541: 	if (rebind == RebindQueryInfo::ATTEMPT_TO_REBIND) {
542: 		RebindPreparedStatement(lock, query, prepared, parameters);
543: 	}
544: 	return PendingPreparedStatementInternal(lock, prepared, parameters);
545: }
546: 
547: void ClientContext::WaitForTask(ClientContextLock &lock, BaseQueryResult &result) {
548: 	active_query->executor->WaitForTask();
549: }
550: 
551: PendingExecutionResult ClientContext::ExecuteTaskInternal(ClientContextLock &lock, BaseQueryResult &result,
552:                                                           bool dry_run) {
553: 	D_ASSERT(active_query);
554: 	D_ASSERT(active_query->IsOpenResult(result));
555: 	bool invalidate_transaction = true;
556: 	try {
557: 		auto query_result = active_query->executor->ExecuteTask(dry_run);
558: 		if (active_query->progress_bar) {
559: 			auto is_finished = PendingQueryResult::IsResultReady(query_result);
560: 			active_query->progress_bar->Update(is_finished);
561: 			query_progress = active_query->progress_bar->GetDetailedQueryProgress();
562: 		}
563: 		return query_result;
564: 	} catch (std::exception &ex) {
565: 		auto error = ErrorData(ex);
566: 		if (error.Type() == ExceptionType::INTERRUPT) {
567: 			auto &executor = *active_query->executor;
568: 			if (!executor.HasError()) {
569: 				// Interrupted by the user
570: 				result.SetError(ex);
571: 				invalidate_transaction = true;
572: 			} else {
573: 				// Interrupted by an exception caused in a worker thread
574: 				error = executor.GetError();
575: 				invalidate_transaction = Exception::InvalidatesTransaction(error.Type());
576: 				result.SetError(error);
577: 			}
578: 		} else if (!Exception::InvalidatesTransaction(error.Type())) {
579: 			invalidate_transaction = false;
580: 		} else if (Exception::InvalidatesDatabase(error.Type())) {
581: 			// fatal exceptions invalidate the entire database
582: 			auto &db_instance = DatabaseInstance::GetDatabase(*this);
583: 			ValidChecker::Invalidate(db_instance, error.RawMessage());
584: 		}
585: 		ProcessError(error, active_query->query);
586: 		result.SetError(std::move(error));
587: 	} catch (...) { // LCOV_EXCL_START
588: 		result.SetError(ErrorData("Unhandled exception in ExecuteTaskInternal"));
589: 	} // LCOV_EXCL_STOP
590: 	EndQueryInternal(lock, false, invalidate_transaction, result.GetErrorObject());
591: 	return PendingExecutionResult::EXECUTION_ERROR;
592: }
593: 
594: void ClientContext::InitialCleanup(ClientContextLock &lock) {
595: 	//! Cleanup any open results and reset the interrupted flag
596: 	CleanupInternal(lock);
597: 	interrupted = false;
598: }
599: 
600: vector<unique_ptr<SQLStatement>> ClientContext::ParseStatements(const string &query) {
601: 	auto lock = LockContext();
602: 	return ParseStatementsInternal(*lock, query);
603: }
604: 
605: vector<unique_ptr<SQLStatement>> ClientContext::ParseStatementsInternal(ClientContextLock &lock, const string &query) {
606: 	Parser parser(GetParserOptions());
607: 	parser.ParseQuery(query);
608: 
609: 	PragmaHandler handler(*this);
610: 	handler.HandlePragmaStatements(lock, parser.statements);
611: 
612: 	return std::move(parser.statements);
613: }
614: 
615: void ClientContext::HandlePragmaStatements(vector<unique_ptr<SQLStatement>> &statements) {
616: 	auto lock = LockContext();
617: 
618: 	PragmaHandler handler(*this);
619: 	handler.HandlePragmaStatements(*lock, statements);
620: }
621: 
622: unique_ptr<LogicalOperator> ClientContext::ExtractPlan(const string &query) {
623: 	auto lock = LockContext();
624: 
625: 	auto statements = ParseStatementsInternal(*lock, query);
626: 	if (statements.size() != 1) {
627: 		throw InvalidInputException("ExtractPlan can only prepare a single statement");
628: 	}
629: 
630: 	unique_ptr<LogicalOperator> plan;
631: 	RunFunctionInTransactionInternal(*lock, [&]() {
632: 		Planner planner(*this);
633: 		planner.CreatePlan(std::move(statements[0]));
634: 		D_ASSERT(planner.plan);
635: 
636: 		plan = std::move(planner.plan);
637: 
638: 		if (config.enable_optimizer) {
639: 			Optimizer optimizer(*planner.binder, *this);
640: 			plan = optimizer.Optimize(std::move(plan));
641: 		}
642: 
643: 		ColumnBindingResolver resolver;
644: 		resolver.Verify(*plan);
645: 		resolver.VisitOperator(*plan);
646: 
647: 		plan->ResolveOperatorTypes();
648: 	});
649: 	return plan;
650: }
651: 
652: unique_ptr<PreparedStatement> ClientContext::PrepareInternal(ClientContextLock &lock,
653:                                                              unique_ptr<SQLStatement> statement) {
654: 	auto named_param_map = statement->named_param_map;
655: 	auto statement_query = statement->query;
656: 	shared_ptr<PreparedStatementData> prepared_data;
657: 	auto unbound_statement = statement->Copy();
658: 	RunFunctionInTransactionInternal(
659: 	    lock, [&]() { prepared_data = CreatePreparedStatement(lock, statement_query, std::move(statement)); }, false);
660: 	prepared_data->unbound_statement = std::move(unbound_statement);
661: 	return make_uniq<PreparedStatement>(shared_from_this(), std::move(prepared_data), std::move(statement_query),
662: 	                                    std::move(named_param_map));
663: }
664: 
665: unique_ptr<PreparedStatement> ClientContext::Prepare(unique_ptr<SQLStatement> statement) {
666: 	auto lock = LockContext();
667: 	// prepare the query
668: 	auto query = statement->query;
669: 	try {
670: 		InitialCleanup(*lock);
671: 		return PrepareInternal(*lock, std::move(statement));
672: 	} catch (std::exception &ex) {
673: 		return ErrorResult<PreparedStatement>(ErrorData(ex), query);
674: 	}
675: }
676: 
677: unique_ptr<PreparedStatement> ClientContext::Prepare(const string &query) {
678: 	auto lock = LockContext();
679: 	// prepare the query
680: 	try {
681: 		InitialCleanup(*lock);
682: 
683: 		// first parse the query
684: 		auto statements = ParseStatementsInternal(*lock, query);
685: 		if (statements.empty()) {
686: 			throw InvalidInputException("No statement to prepare!");
687: 		}
688: 		if (statements.size() > 1) {
689: 			throw InvalidInputException("Cannot prepare multiple statements at once!");
690: 		}
691: 		return PrepareInternal(*lock, std::move(statements[0]));
692: 	} catch (std::exception &ex) {
693: 		return ErrorResult<PreparedStatement>(ErrorData(ex), query);
694: 	}
695: }
696: 
697: unique_ptr<PendingQueryResult> ClientContext::PendingQueryPreparedInternal(ClientContextLock &lock, const string &query,
698:                                                                            shared_ptr<PreparedStatementData> &prepared,
699:                                                                            const PendingQueryParameters &parameters) {
700: 	try {
701: 		InitialCleanup(lock);
702: 	} catch (std::exception &ex) {
703: 		return ErrorResult<PendingQueryResult>(ErrorData(ex), query);
704: 	}
705: 	return PendingStatementOrPreparedStatementInternal(lock, query, nullptr, prepared, parameters);
706: }
707: 
708: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const string &query,
709:                                                            shared_ptr<PreparedStatementData> &prepared,
710:                                                            const PendingQueryParameters &parameters) {
711: 	auto lock = LockContext();
712: 	return PendingQueryPreparedInternal(*lock, query, prepared, parameters);
713: }
714: 
715: unique_ptr<QueryResult> ClientContext::Execute(const string &query, shared_ptr<PreparedStatementData> &prepared,
716:                                                const PendingQueryParameters &parameters) {
717: 	auto lock = LockContext();
718: 	auto pending = PendingQueryPreparedInternal(*lock, query, prepared, parameters);
719: 	if (pending->HasError()) {
720: 		return ErrorResult<MaterializedQueryResult>(pending->GetErrorObject());
721: 	}
722: 	return pending->ExecuteInternal(*lock);
723: }
724: 
725: unique_ptr<QueryResult> ClientContext::Execute(const string &query, shared_ptr<PreparedStatementData> &prepared,
726:                                                case_insensitive_map_t<BoundParameterData> &values,
727:                                                bool allow_stream_result) {
728: 	PendingQueryParameters parameters;
729: 	parameters.parameters = &values;
730: 	parameters.allow_stream_result = allow_stream_result;
731: 	return Execute(query, prepared, parameters);
732: }
733: 
734: unique_ptr<PendingQueryResult> ClientContext::PendingStatementInternal(ClientContextLock &lock, const string &query,
735:                                                                        unique_ptr<SQLStatement> statement,
736:                                                                        const PendingQueryParameters &parameters) {
737: 	// prepare the query for execution
738: 	auto prepared = CreatePreparedStatement(lock, query, std::move(statement), parameters.parameters,
739: 	                                        PreparedStatementMode::PREPARE_AND_EXECUTE);
740: 	idx_t parameter_count = !parameters.parameters ? 0 : parameters.parameters->size();
741: 	if (prepared->properties.parameter_count > 0 && parameter_count == 0) {
742: 		string error_message = StringUtil::Format("Expected %lld parameters, but none were supplied",
743: 		                                          prepared->properties.parameter_count);
744: 		return ErrorResult<PendingQueryResult>(InvalidInputException(error_message), query);
745: 	}
746: 	if (!prepared->properties.bound_all_parameters) {
747: 		return ErrorResult<PendingQueryResult>(InvalidInputException("Not all parameters were bound"), query);
748: 	}
749: 	// execute the prepared statement
750: 	CheckIfPreparedStatementIsExecutable(*prepared);
751: 	return PendingPreparedStatementInternal(lock, std::move(prepared), parameters);
752: }
753: 
754: unique_ptr<QueryResult> ClientContext::RunStatementInternal(ClientContextLock &lock, const string &query,
755:                                                             unique_ptr<SQLStatement> statement,
756:                                                             bool allow_stream_result, bool verify) {
757: 	PendingQueryParameters parameters;
758: 	parameters.allow_stream_result = allow_stream_result;
759: 	auto pending = PendingQueryInternal(lock, std::move(statement), parameters, verify);
760: 	if (pending->HasError()) {
761: 		return ErrorResult<MaterializedQueryResult>(pending->GetErrorObject());
762: 	}
763: 	return ExecutePendingQueryInternal(lock, *pending);
764: }
765: 
766: bool ClientContext::IsActiveResult(ClientContextLock &lock, BaseQueryResult &result) {
767: 	if (!active_query) {
768: 		return false;
769: 	}
770: 	return active_query->IsOpenResult(result);
771: }
772: 
773: unique_ptr<PendingQueryResult> ClientContext::PendingStatementOrPreparedStatementInternal(
774:     ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,
775:     shared_ptr<PreparedStatementData> &prepared, const PendingQueryParameters &parameters) {
776: #ifdef DUCKDB_ALTERNATIVE_VERIFY
777: 	if (statement && statement->type != StatementType::LOGICAL_PLAN_STATEMENT) {
778: 		statement = statement->Copy();
779: 	}
780: #endif
781: 	// check if we are on AutoCommit. In this case we should start a transaction.
782: 	if (statement && config.AnyVerification()) {
783: 		// query verification is enabled
784: 		// create a copy of the statement, and use the copy
785: 		// this way we verify that the copy correctly copies all properties
786: 		auto copied_statement = statement->Copy();
787: 		switch (statement->type) {
788: 		case StatementType::SELECT_STATEMENT: {
789: 			// in case this is a select query, we verify the original statement
790: 			ErrorData error;
791: 			try {
792: 				error = VerifyQuery(lock, query, std::move(statement));
793: 			} catch (std::exception &ex) {
794: 				error = ErrorData(ex);
795: 			}
796: 			if (error.HasError()) {
797: 				// error in verifying query
798: 				return ErrorResult<PendingQueryResult>(std::move(error), query);
799: 			}
800: 			statement = std::move(copied_statement);
801: 			break;
802: 		}
803: 		default: {
804: #ifndef DUCKDB_ALTERNATIVE_VERIFY
805: 			bool reparse_statement = true;
806: #else
807: 			bool reparse_statement = false;
808: #endif
809: 			statement = std::move(copied_statement);
810: 			if (statement->type == StatementType::RELATION_STATEMENT) {
811: 				reparse_statement = false;
812: 			}
813: 			if (reparse_statement) {
814: 				try {
815: 					Parser parser(GetParserOptions());
816: 					ErrorData error;
817: 					parser.ParseQuery(statement->ToString());
818: 					statement = std::move(parser.statements[0]);
819: 				} catch (const NotImplementedException &) {
820: 					// ToString was not implemented, just use the copied statement
821: 				}
822: 			}
823: 			break;
824: 		}
825: 		}
826: 	}
827: 	return PendingStatementOrPreparedStatement(lock, query, std::move(statement), prepared, parameters);
828: }
829: 
830: unique_ptr<PendingQueryResult> ClientContext::PendingStatementOrPreparedStatement(
831:     ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,
832:     shared_ptr<PreparedStatementData> &prepared, const PendingQueryParameters &parameters) {
833: 	unique_ptr<PendingQueryResult> pending;
834: 
835: 	try {
836: 		BeginQueryInternal(lock, query);
837: 	} catch (std::exception &ex) {
838: 		ErrorData error(ex);
839: 		if (Exception::InvalidatesDatabase(error.Type())) {
840: 			// fatal exceptions invalidate the entire database
841: 			auto &db_instance = DatabaseInstance::GetDatabase(*this);
842: 			ValidChecker::Invalidate(db_instance, error.RawMessage());
843: 		}
844: 		return ErrorResult<PendingQueryResult>(std::move(error), query);
845: 	}
846: 	// start the profiler
847: 	auto &profiler = QueryProfiler::Get(*this);
848: 	profiler.StartQuery(query, IsExplainAnalyze(statement ? statement.get() : prepared->unbound_statement.get()));
849: 
850: 	bool invalidate_query = true;
851: 	try {
852: 		if (statement) {
853: 			pending = PendingStatementInternal(lock, query, std::move(statement), parameters);
854: 		} else {
855: 			pending = PendingPreparedStatement(lock, query, prepared, parameters);
856: 		}
857: 	} catch (std::exception &ex) {
858: 		ErrorData error(ex);
859: 		if (!Exception::InvalidatesTransaction(error.Type())) {
860: 			// standard exceptions do not invalidate the current transaction
861: 			invalidate_query = false;
862: 		} else if (Exception::InvalidatesDatabase(error.Type())) {
863: 			// fatal exceptions invalidate the entire database
864: 			if (!config.query_verification_enabled) {
865: 				auto &db_instance = DatabaseInstance::GetDatabase(*this);
866: 				ValidChecker::Invalidate(db_instance, error.RawMessage());
867: 			}
868: 		}
869: 		// other types of exceptions do invalidate the current transaction
870: 		pending = ErrorResult<PendingQueryResult>(std::move(error), query);
871: 	}
872: 	if (pending->HasError()) {
873: 		// query failed: abort now
874: 		EndQueryInternal(lock, false, invalidate_query, pending->GetErrorObject());
875: 		return pending;
876: 	}
877: 	D_ASSERT(active_query->IsOpenResult(*pending));
878: 	return pending;
879: }
880: 
881: void ClientContext::LogQueryInternal(ClientContextLock &, const string &query) {
882: 	if (!client_data->log_query_writer) {
883: #ifdef DUCKDB_FORCE_QUERY_LOG
884: 		try {
885: 			string log_path(DUCKDB_FORCE_QUERY_LOG);
886: 			client_data->log_query_writer =
887: 			    make_uniq<BufferedFileWriter>(FileSystem::GetFileSystem(*this), log_path,
888: 			                                  BufferedFileWriter::DEFAULT_OPEN_FLAGS, client_data->file_opener.get());
889: 		} catch (...) {
890: 			return;
891: 		}
892: #else
893: 		return;
894: #endif
895: 	}
896: 	// log query path is set: log the query
897: 	client_data->log_query_writer->WriteData(const_data_ptr_cast(query.c_str()), query.size());
898: 	client_data->log_query_writer->WriteData(const_data_ptr_cast("\n"), 1);
899: 	client_data->log_query_writer->Flush();
900: 	client_data->log_query_writer->Sync();
901: }
902: 
903: unique_ptr<QueryResult> ClientContext::Query(unique_ptr<SQLStatement> statement, bool allow_stream_result) {
904: 	auto pending_query = PendingQuery(std::move(statement), allow_stream_result);
905: 	if (pending_query->HasError()) {
906: 		return ErrorResult<MaterializedQueryResult>(pending_query->GetErrorObject());
907: 	}
908: 	return pending_query->Execute();
909: }
910: 
911: unique_ptr<QueryResult> ClientContext::Query(const string &query, bool allow_stream_result) {
912: 	auto lock = LockContext();
913: 
914: 	ErrorData error;
915: 	vector<unique_ptr<SQLStatement>> statements;
916: 	if (!ParseStatements(*lock, query, statements, error)) {
917: 		return ErrorResult<MaterializedQueryResult>(std::move(error), query);
918: 	}
919: 	if (statements.empty()) {
920: 		// no statements, return empty successful result
921: 		StatementProperties properties;
922: 		vector<string> names;
923: 		auto collection = make_uniq<ColumnDataCollection>(Allocator::DefaultAllocator());
924: 		return make_uniq<MaterializedQueryResult>(StatementType::INVALID_STATEMENT, properties, std::move(names),
925: 		                                          std::move(collection), GetClientProperties());
926: 	}
927: 
928: 	unique_ptr<QueryResult> result;
929: 	QueryResult *last_result = nullptr;
930: 	bool last_had_result = false;
931: 	for (idx_t i = 0; i < statements.size(); i++) {
932: 		auto &statement = statements[i];
933: 		bool is_last_statement = i + 1 == statements.size();
934: 		PendingQueryParameters parameters;
935: 		parameters.allow_stream_result = allow_stream_result && is_last_statement;
936: 		auto pending_query = PendingQueryInternal(*lock, std::move(statement), parameters);
937: 		auto has_result = pending_query->properties.return_type == StatementReturnType::QUERY_RESULT;
938: 		unique_ptr<QueryResult> current_result;
939: 		if (pending_query->HasError()) {
940: 			current_result = ErrorResult<MaterializedQueryResult>(pending_query->GetErrorObject());
941: 		} else {
942: 			current_result = ExecutePendingQueryInternal(*lock, *pending_query);
943: 		}
944: 		// now append the result to the list of results
945: 		if (!last_result || !last_had_result) {
946: 			// first result of the query
947: 			result = std::move(current_result);
948: 			last_result = result.get();
949: 			last_had_result = has_result;
950: 		} else {
951: 			// later results; attach to the result chain
952: 			// but only if there is a result
953: 			if (!has_result) {
954: 				continue;
955: 			}
956: 			last_result->next = std::move(current_result);
957: 			last_result = last_result->next.get();
958: 		}
959: 		D_ASSERT(last_result);
960: 		if (last_result->HasError()) {
961: 			// Reset the interrupted flag, this was set by the task that found the error
962: 			// Next statements should not be bothered by that interruption
963: 			interrupted = false;
964: 		}
965: 	}
966: 	return result;
967: }
968: 
969: bool ClientContext::ParseStatements(ClientContextLock &lock, const string &query,
970:                                     vector<unique_ptr<SQLStatement>> &result, ErrorData &error) {
971: 	try {
972: 		InitialCleanup(lock);
973: 		// parse the query and transform it into a set of statements
974: 		result = ParseStatementsInternal(lock, query);
975: 		return true;
976: 	} catch (std::exception &ex) {
977: 		error = ErrorData(ex);
978: 		return false;
979: 	}
980: }
981: 
982: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const string &query, bool allow_stream_result) {
983: 	auto lock = LockContext();
984: 
985: 	ErrorData error;
986: 	vector<unique_ptr<SQLStatement>> statements;
987: 	if (!ParseStatements(*lock, query, statements, error)) {
988: 		return ErrorResult<PendingQueryResult>(std::move(error), query);
989: 	}
990: 	if (statements.size() != 1) {
991: 		return ErrorResult<PendingQueryResult>(ErrorData("PendingQuery can only take a single statement"), query);
992: 	}
993: 	PendingQueryParameters parameters;
994: 	parameters.allow_stream_result = allow_stream_result;
995: 	return PendingQueryInternal(*lock, std::move(statements[0]), parameters);
996: }
997: 
998: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(unique_ptr<SQLStatement> statement,
999:                                                            bool allow_stream_result) {
1000: 	auto lock = LockContext();
1001: 
1002: 	try {
1003: 		InitialCleanup(*lock);
1004: 	} catch (std::exception &ex) {
1005: 		return ErrorResult<PendingQueryResult>(ErrorData(ex));
1006: 	}
1007: 
1008: 	PendingQueryParameters parameters;
1009: 	parameters.allow_stream_result = allow_stream_result;
1010: 	return PendingQueryInternal(*lock, std::move(statement), parameters);
1011: }
1012: 
1013: unique_ptr<PendingQueryResult> ClientContext::PendingQueryInternal(ClientContextLock &lock,
1014:                                                                    unique_ptr<SQLStatement> statement,
1015:                                                                    const PendingQueryParameters &parameters,
1016:                                                                    bool verify) {
1017: 	auto query = statement->query;
1018: 	shared_ptr<PreparedStatementData> prepared;
1019: 	if (verify) {
1020: 		return PendingStatementOrPreparedStatementInternal(lock, query, std::move(statement), prepared, parameters);
1021: 	} else {
1022: 		return PendingStatementOrPreparedStatement(lock, query, std::move(statement), prepared, parameters);
1023: 	}
1024: }
1025: 
1026: unique_ptr<QueryResult> ClientContext::ExecutePendingQueryInternal(ClientContextLock &lock, PendingQueryResult &query) {
1027: 	return query.ExecuteInternal(lock);
1028: }
1029: 
1030: void ClientContext::Interrupt() {
1031: 	interrupted = true;
1032: }
1033: 
1034: void ClientContext::CancelTransaction() {
1035: 	auto lock = LockContext();
1036: 	InitialCleanup(*lock);
1037: }
1038: 
1039: void ClientContext::EnableProfiling() {
1040: 	auto lock = LockContext();
1041: 	auto &client_config = ClientConfig::GetConfig(*this);
1042: 	client_config.enable_profiler = true;
1043: 	client_config.emit_profiler_output = true;
1044: }
1045: 
1046: void ClientContext::DisableProfiling() {
1047: 	auto lock = LockContext();
1048: 	auto &client_config = ClientConfig::GetConfig(*this);
1049: 	client_config.enable_profiler = false;
1050: }
1051: 
1052: void ClientContext::RegisterFunction(CreateFunctionInfo &info) {
1053: 	RunFunctionInTransaction([&]() {
1054: 		auto existing_function = Catalog::GetEntry<ScalarFunctionCatalogEntry>(*this, INVALID_CATALOG, info.schema,
1055: 		                                                                       info.name, OnEntryNotFound::RETURN_NULL);
1056: 		if (existing_function) {
1057: 			auto &new_info = info.Cast<CreateScalarFunctionInfo>();
1058: 			if (new_info.functions.MergeFunctionSet(existing_function->functions)) {
1059: 				// function info was updated from catalog entry, rewrite is needed
1060: 				info.on_conflict = OnCreateConflict::REPLACE_ON_CONFLICT;
1061: 			}
1062: 		}
1063: 		// create function
1064: 		auto &catalog = Catalog::GetSystemCatalog(*this);
1065: 		catalog.CreateFunction(*this, info);
1066: 	});
1067: }
1068: 
1069: void ClientContext::RunFunctionInTransactionInternal(ClientContextLock &lock, const std::function<void(void)> &fun,
1070:                                                      bool requires_valid_transaction) {
1071: 	if (requires_valid_transaction && transaction.HasActiveTransaction() &&
1072: 	    ValidChecker::IsInvalidated(ActiveTransaction())) {
1073: 		throw TransactionException(ErrorManager::FormatException(*this, ErrorType::INVALIDATED_TRANSACTION));
1074: 	}
1075: 	// check if we are on AutoCommit. In this case we should start a transaction
1076: 	bool require_new_transaction = transaction.IsAutoCommit() && !transaction.HasActiveTransaction();
1077: 	if (require_new_transaction) {
1078: 		D_ASSERT(!active_query);
1079: 		transaction.BeginTransaction();
1080: 	}
1081: 	try {
1082: 		fun();
1083: 	} catch (std::exception &ex) {
1084: 		ErrorData error(ex);
1085: 		bool invalidates_transaction = true;
1086: 		if (!Exception::InvalidatesTransaction(error.Type())) {
1087: 			// standard exceptions don't invalidate the transaction
1088: 			invalidates_transaction = false;
1089: 		} else if (Exception::InvalidatesDatabase(error.Type())) {
1090: 			auto &db_instance = DatabaseInstance::GetDatabase(*this);
1091: 			ValidChecker::Invalidate(db_instance, error.RawMessage());
1092: 		}
1093: 		if (require_new_transaction) {
1094: 			transaction.Rollback(error);
1095: 		} else if (invalidates_transaction) {
1096: 			ValidChecker::Invalidate(ActiveTransaction(), error.RawMessage());
1097: 		}
1098: 		throw;
1099: 	}
1100: 	if (require_new_transaction) {
1101: 		transaction.Commit();
1102: 	}
1103: }
1104: 
1105: void ClientContext::RunFunctionInTransaction(const std::function<void(void)> &fun, bool requires_valid_transaction) {
1106: 	auto lock = LockContext();
1107: 	RunFunctionInTransactionInternal(*lock, fun, requires_valid_transaction);
1108: }
1109: 
1110: unique_ptr<TableDescription> ClientContext::TableInfo(const string &schema_name, const string &table_name) {
1111: 	unique_ptr<TableDescription> result;
1112: 	RunFunctionInTransaction([&]() {
1113: 		// obtain the table info
1114: 		auto table = Catalog::GetEntry<TableCatalogEntry>(*this, INVALID_CATALOG, schema_name, table_name,
1115: 		                                                  OnEntryNotFound::RETURN_NULL);
1116: 		if (!table) {
1117: 			return;
1118: 		}
1119: 		// write the table info to the result
1120: 		result = make_uniq<TableDescription>();
1121: 		result->schema = schema_name;
1122: 		result->table = table_name;
1123: 		for (auto &column : table->GetColumns().Logical()) {
1124: 			result->columns.emplace_back(column.Copy());
1125: 		}
1126: 	});
1127: 	return result;
1128: }
1129: 
1130: void ClientContext::Append(TableDescription &description, ColumnDataCollection &collection) {
1131: 	RunFunctionInTransaction([&]() {
1132: 		auto &table_entry =
1133: 		    Catalog::GetEntry<TableCatalogEntry>(*this, INVALID_CATALOG, description.schema, description.table);
1134: 		// verify that the table columns and types match up
1135: 		if (description.columns.size() != table_entry.GetColumns().PhysicalColumnCount()) {
1136: 			throw InvalidInputException("Failed to append: table entry has different number of columns!");
1137: 		}
1138: 		for (idx_t i = 0; i < description.columns.size(); i++) {
1139: 			if (description.columns[i].Type() != table_entry.GetColumns().GetColumn(PhysicalIndex(i)).Type()) {
1140: 				throw InvalidInputException("Failed to append: table entry has different number of columns!");
1141: 			}
1142: 		}
1143: 		auto binder = Binder::CreateBinder(*this);
1144: 		auto bound_constraints = binder->BindConstraints(table_entry);
1145: 		MetaTransaction::Get(*this).ModifyDatabase(table_entry.ParentCatalog().GetAttached());
1146: 		table_entry.GetStorage().LocalAppend(table_entry, *this, collection, bound_constraints);
1147: 	});
1148: }
1149: 
1150: void ClientContext::TryBindRelation(Relation &relation, vector<ColumnDefinition> &result_columns) {
1151: #ifdef DEBUG
1152: 	D_ASSERT(!relation.GetAlias().empty());
1153: 	D_ASSERT(!relation.ToString().empty());
1154: #endif
1155: 	RunFunctionInTransaction([&]() {
1156: 		// bind the expressions
1157: 		auto binder = Binder::CreateBinder(*this);
1158: 		auto result = relation.Bind(*binder);
1159: 		D_ASSERT(result.names.size() == result.types.size());
1160: 
1161: 		result_columns.reserve(result_columns.size() + result.names.size());
1162: 		for (idx_t i = 0; i < result.names.size(); i++) {
1163: 			result_columns.emplace_back(result.names[i], result.types[i]);
1164: 		}
1165: 	});
1166: }
1167: 
1168: unordered_set<string> ClientContext::GetTableNames(const string &query) {
1169: 	auto lock = LockContext();
1170: 
1171: 	auto statements = ParseStatementsInternal(*lock, query);
1172: 	if (statements.size() != 1) {
1173: 		throw InvalidInputException("Expected a single statement");
1174: 	}
1175: 
1176: 	unordered_set<string> result;
1177: 	RunFunctionInTransactionInternal(*lock, [&]() {
1178: 		// bind the expressions
1179: 		auto binder = Binder::CreateBinder(*this);
1180: 		binder->SetBindingMode(BindingMode::EXTRACT_NAMES);
1181: 		binder->Bind(*statements[0]);
1182: 		result = binder->GetTableNames();
1183: 	});
1184: 	return result;
1185: }
1186: 
1187: unique_ptr<PendingQueryResult> ClientContext::PendingQueryInternal(ClientContextLock &lock,
1188:                                                                    const shared_ptr<Relation> &relation,
1189:                                                                    bool allow_stream_result) {
1190: 	InitialCleanup(lock);
1191: 
1192: 	string query;
1193: 	if (config.query_verification_enabled) {
1194: 		// run the ToString method of any relation we run, mostly to ensure it doesn't crash
1195: 		relation->ToString();
1196: 		relation->GetAlias();
1197: 		if (relation->IsReadOnly()) {
1198: 			// verify read only statements by running a select statement
1199: 			auto select = make_uniq<SelectStatement>();
1200: 			select->node = relation->GetQueryNode();
1201: 			RunStatementInternal(lock, query, std::move(select), false);
1202: 		}
1203: 	}
1204: 
1205: 	auto relation_stmt = make_uniq<RelationStatement>(relation);
1206: 	PendingQueryParameters parameters;
1207: 	parameters.allow_stream_result = allow_stream_result;
1208: 	return PendingQueryInternal(lock, std::move(relation_stmt), parameters);
1209: }
1210: 
1211: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const shared_ptr<Relation> &relation,
1212:                                                            bool allow_stream_result) {
1213: 	auto lock = LockContext();
1214: 	return PendingQueryInternal(*lock, relation, allow_stream_result);
1215: }
1216: 
1217: unique_ptr<QueryResult> ClientContext::Execute(const shared_ptr<Relation> &relation) {
1218: 	auto lock = LockContext();
1219: 	auto &expected_columns = relation->Columns();
1220: 	auto pending = PendingQueryInternal(*lock, relation, false);
1221: 	if (!pending->success) {
1222: 		return ErrorResult<MaterializedQueryResult>(pending->GetErrorObject());
1223: 	}
1224: 
1225: 	unique_ptr<QueryResult> result;
1226: 	result = ExecutePendingQueryInternal(*lock, *pending);
1227: 	if (result->HasError()) {
1228: 		return result;
1229: 	}
1230: 	// verify that the result types and result names of the query match the expected result types/names
1231: 	if (result->types.size() == expected_columns.size()) {
1232: 		bool mismatch = false;
1233: 		for (idx_t i = 0; i < result->types.size(); i++) {
1234: 			if (result->types[i] != expected_columns[i].Type() || result->names[i] != expected_columns[i].Name()) {
1235: 				mismatch = true;
1236: 				break;
1237: 			}
1238: 		}
1239: 		if (!mismatch) {
1240: 			// all is as expected: return the result
1241: 			return result;
1242: 		}
1243: 	}
1244: 	// result mismatch
1245: 	string err_str = "Result mismatch in query!\nExpected the following columns: [";
1246: 	for (idx_t i = 0; i < expected_columns.size(); i++) {
1247: 		if (i > 0) {
1248: 			err_str += ", ";
1249: 		}
1250: 		err_str += expected_columns[i].Name() + " " + expected_columns[i].Type().ToString();
1251: 	}
1252: 	err_str += "]\nBut result contained the following: ";
1253: 	for (idx_t i = 0; i < result->types.size(); i++) {
1254: 		err_str += i == 0 ? "[" : ", ";
1255: 		err_str += result->names[i] + " " + result->types[i].ToString();
1256: 	}
1257: 	err_str += "]";
1258: 	return ErrorResult<MaterializedQueryResult>(ErrorData(err_str));
1259: }
1260: 
1261: SettingLookupResult ClientContext::TryGetCurrentSetting(const std::string &key, Value &result) const {
1262: 	// first check the built-in settings
1263: 	auto &db_config = DBConfig::GetConfig(*this);
1264: 	auto option = db_config.GetOptionByName(key);
1265: 	if (option) {
1266: 		result = option->get_setting(*this);
1267: 		return SettingLookupResult(SettingScope::LOCAL);
1268: 	}
1269: 
1270: 	// check the client session values
1271: 	const auto &session_config_map = config.set_variables;
1272: 
1273: 	auto session_value = session_config_map.find(key);
1274: 	bool found_session_value = session_value != session_config_map.end();
1275: 	if (found_session_value) {
1276: 		result = session_value->second;
1277: 		return SettingLookupResult(SettingScope::LOCAL);
1278: 	}
1279: 	// finally check the global session values
1280: 	return db->TryGetCurrentSetting(key, result);
1281: }
1282: 
1283: ParserOptions ClientContext::GetParserOptions() const {
1284: 	auto &client_config = ClientConfig::GetConfig(*this);
1285: 	ParserOptions options;
1286: 	options.preserve_identifier_case = client_config.preserve_identifier_case;
1287: 	options.integer_division = client_config.integer_division;
1288: 	options.max_expression_depth = client_config.max_expression_depth;
1289: 	options.extensions = &DBConfig::GetConfig(*this).parser_extensions;
1290: 	return options;
1291: }
1292: 
1293: ClientProperties ClientContext::GetClientProperties() const {
1294: 	string timezone = "UTC";
1295: 	Value result;
1296: 
1297: 	if (TryGetCurrentSetting("TimeZone", result)) {
1298: 		timezone = result.ToString();
1299: 	}
1300: 	return {timezone, db->config.options.arrow_offset_size, db->config.options.arrow_use_list_view,
1301: 	        db->config.options.produce_arrow_string_views, db->config.options.arrow_arrow_lossless_conversion};
1302: }
1303: 
1304: bool ClientContext::ExecutionIsFinished() {
1305: 	if (!active_query || !active_query->executor) {
1306: 		return false;
1307: 	}
1308: 	return active_query->executor->ExecutionIsFinished();
1309: }
1310: 
1311: } // namespace duckdb
[end of src/main/client_context.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: