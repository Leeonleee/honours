{
  "repo": "duckdb/duckdb",
  "pull_number": 8224,
  "instance_id": "duckdb__duckdb-8224",
  "issue_numbers": [
    "8141"
  ],
  "base_commit": "3cba1b0da8b25990cf95ab03b37deb51c5fbe531",
  "patch": "diff --git a/src/include/duckdb/common/stack_checker.hpp b/src/include/duckdb/common/stack_checker.hpp\nnew file mode 100644\nindex 000000000000..a2375e8ef966\n--- /dev/null\n+++ b/src/include/duckdb/common/stack_checker.hpp\n@@ -0,0 +1,34 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/stack_checker.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+namespace duckdb {\n+\n+template <class RECURSIVE_CLASS>\n+class StackChecker {\n+public:\n+\tStackChecker(RECURSIVE_CLASS &recursive_class_p, idx_t stack_usage_p)\n+\t    : recursive_class(recursive_class_p), stack_usage(stack_usage_p) {\n+\t\trecursive_class.stack_depth += stack_usage;\n+\t}\n+\t~StackChecker() {\n+\t\trecursive_class.stack_depth -= stack_usage;\n+\t}\n+\tStackChecker(StackChecker &&other) noexcept\n+\t    : recursive_class(other.recursive_class), stack_usage(other.stack_usage) {\n+\t\tother.stack_usage = 0;\n+\t}\n+\tStackChecker(const StackChecker &) = delete;\n+\n+private:\n+\tRECURSIVE_CLASS &recursive_class;\n+\tidx_t stack_usage;\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/parser/transformer.hpp b/src/include/duckdb/parser/transformer.hpp\nindex d9db17138533..849e8740683a 100644\n--- a/src/include/duckdb/parser/transformer.hpp\n+++ b/src/include/duckdb/parser/transformer.hpp\n@@ -11,6 +11,7 @@\n #include \"duckdb/common/case_insensitive_map.hpp\"\n #include \"duckdb/common/constants.hpp\"\n #include \"duckdb/common/enums/expression_type.hpp\"\n+#include \"duckdb/common/stack_checker.hpp\"\n #include \"duckdb/common/types.hpp\"\n #include \"duckdb/common/unordered_map.hpp\"\n #include \"duckdb/parser/group_by_node.hpp\"\n@@ -26,7 +27,6 @@\n namespace duckdb {\n \n class ColumnDefinition;\n-class StackChecker;\n struct OrderByNode;\n struct CopyInfo;\n struct CommonTableExpressionInfo;\n@@ -39,7 +39,7 @@ struct PivotColumn;\n //! The transformer class is responsible for transforming the internal Postgres\n //! parser representation into the DuckDB representation\n class Transformer {\n-\tfriend class StackChecker;\n+\tfriend class StackChecker<Transformer>;\n \n \tstruct CreatePivotEntry {\n \t\tstring enum_name;\n@@ -343,7 +343,7 @@ class Transformer {\n \tidx_t stack_depth;\n \n \tvoid InitializeStackCheck();\n-\tStackChecker StackCheck(idx_t extra_stack = 1);\n+\tStackChecker<Transformer> StackCheck(idx_t extra_stack = 1);\n \n public:\n \ttemplate <class T>\n@@ -356,18 +356,6 @@ class Transformer {\n \t}\n };\n \n-class StackChecker {\n-public:\n-\tStackChecker(Transformer &transformer, idx_t stack_usage);\n-\t~StackChecker();\n-\tStackChecker(StackChecker &&) noexcept;\n-\tStackChecker(const StackChecker &) = delete;\n-\n-private:\n-\tTransformer &transformer;\n-\tidx_t stack_usage;\n-};\n-\n vector<string> ReadPgListToString(duckdb_libpgquery::PGList *column_list);\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 3efc79964ee9..11e5a882c937 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -9,11 +9,12 @@\n #pragma once\n \n #include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/stack_checker.hpp\"\n+#include \"duckdb/common/unordered_map.hpp\"\n #include \"duckdb/parser/expression/bound_expression.hpp\"\n #include \"duckdb/parser/parsed_expression.hpp\"\n #include \"duckdb/parser/tokens.hpp\"\n #include \"duckdb/planner/expression.hpp\"\n-#include \"duckdb/common/unordered_map.hpp\"\n \n namespace duckdb {\n \n@@ -51,6 +52,8 @@ struct BindResult {\n };\n \n class ExpressionBinder {\n+\tfriend class StackChecker<ExpressionBinder>;\n+\n public:\n \tExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder = false);\n \tvirtual ~ExpressionBinder();\n@@ -110,6 +113,15 @@ class ExpressionBinder {\n \n \tvoid ReplaceMacroParametersRecursive(unique_ptr<ParsedExpression> &expr);\n \n+private:\n+\t//! Maximum stack depth\n+\tstatic constexpr const idx_t MAXIMUM_STACK_DEPTH = 128;\n+\t//! Current stack depth\n+\tidx_t stack_depth = DConstants::INVALID_INDEX;\n+\n+\tvoid InitializeStackCheck();\n+\tStackChecker<ExpressionBinder> StackCheck(const ParsedExpression &expr, idx_t extra_stack = 1);\n+\n protected:\n \tBindResult BindExpression(BetweenExpression &expr, idx_t depth);\n \tBindResult BindExpression(CaseExpression &expr, idx_t depth);\ndiff --git a/src/parser/transformer.cpp b/src/parser/transformer.cpp\nindex dafb83e9e30e..c6af4d92c53a 100644\n--- a/src/parser/transformer.cpp\n+++ b/src/parser/transformer.cpp\n@@ -9,20 +9,6 @@\n \n namespace duckdb {\n \n-StackChecker::StackChecker(Transformer &transformer_p, idx_t stack_usage_p)\n-    : transformer(transformer_p), stack_usage(stack_usage_p) {\n-\ttransformer.stack_depth += stack_usage;\n-}\n-\n-StackChecker::~StackChecker() {\n-\ttransformer.stack_depth -= stack_usage;\n-}\n-\n-StackChecker::StackChecker(StackChecker &&other) noexcept\n-    : transformer(other.transformer), stack_usage(other.stack_usage) {\n-\tother.stack_usage = 0;\n-}\n-\n Transformer::Transformer(ParserOptions &options)\n     : parent(nullptr), options(options), stack_depth(DConstants::INVALID_INDEX) {\n }\n@@ -59,7 +45,7 @@ void Transformer::InitializeStackCheck() {\n \tstack_depth = 0;\n }\n \n-StackChecker Transformer::StackCheck(idx_t extra_stack) {\n+StackChecker<Transformer> Transformer::StackCheck(idx_t extra_stack) {\n \tauto &root = RootTransformer();\n \tD_ASSERT(root.stack_depth != DConstants::INVALID_INDEX);\n \tif (root.stack_depth + extra_stack >= options.max_expression_depth) {\n@@ -67,7 +53,7 @@ StackChecker Transformer::StackCheck(idx_t extra_stack) {\n \t\t                      \"increase the maximum expression depth.\",\n \t\t                      options.max_expression_depth);\n \t}\n-\treturn StackChecker(root, extra_stack);\n+\treturn StackChecker<Transformer>(root, extra_stack);\n }\n \n unique_ptr<SQLStatement> Transformer::TransformStatement(duckdb_libpgquery::PGNode &stmt) {\ndiff --git a/src/planner/binder/expression/bind_macro_expression.cpp b/src/planner/binder/expression/bind_macro_expression.cpp\nindex 02962c0fdeeb..cce36d49d3ac 100644\n--- a/src/planner/binder/expression/bind_macro_expression.cpp\n+++ b/src/planner/binder/expression/bind_macro_expression.cpp\n@@ -1,12 +1,12 @@\n #include \"duckdb/catalog/catalog_entry/scalar_macro_catalog_entry.hpp\"\n+#include \"duckdb/common/reference_map.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/function/scalar_macro_function.hpp\"\n #include \"duckdb/parser/expression/function_expression.hpp\"\n #include \"duckdb/parser/expression/subquery_expression.hpp\"\n #include \"duckdb/parser/parsed_expression_iterator.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n \n-#include \"duckdb/function/scalar_macro_function.hpp\"\n-\n namespace duckdb {\n \n void ExpressionBinder::ReplaceMacroParametersRecursive(unique_ptr<ParsedExpression> &expr) {\n@@ -79,8 +79,10 @@ BindResult ExpressionBinder::BindMacro(FunctionExpression &function, ScalarMacro\n \tnew_macro_binding->arguments = &positionals;\n \tmacro_binding = new_macro_binding.get();\n \n-\t// replace current expression with stored macro expression, and replace params\n+\t// replace current expression with stored macro expression\n \texpr = macro_def.expression->Copy();\n+\n+\t// now replace the parameters\n \tReplaceMacroParametersRecursive(expr);\n \n \t// bind the unfolded macro\ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex 3a4ab533bb2c..3704b8d4f6a2 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -134,33 +134,6 @@ void Binder::BindCreateViewInfo(CreateViewInfo &base) {\n \tbase.types = query_node.types;\n }\n \n-static void QualifyFunctionNames(ClientContext &context, unique_ptr<ParsedExpression> &expr) {\n-\tswitch (expr->GetExpressionClass()) {\n-\tcase ExpressionClass::FUNCTION: {\n-\t\tauto &func = expr->Cast<FunctionExpression>();\n-\t\tauto function = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, func.catalog, func.schema,\n-\t\t                                  func.function_name, OnEntryNotFound::RETURN_NULL);\n-\t\tif (function) {\n-\t\t\tfunc.catalog = function->ParentCatalog().GetName();\n-\t\t\tfunc.schema = function->ParentSchema().name;\n-\t\t}\n-\t\tbreak;\n-\t}\n-\tcase ExpressionClass::SUBQUERY: {\n-\t\t// replacing parameters within a subquery is slightly different\n-\t\tauto &sq = (expr->Cast<SubqueryExpression>()).subquery;\n-\t\tParsedExpressionIterator::EnumerateQueryNodeChildren(\n-\t\t    *sq->node, [&](unique_ptr<ParsedExpression> &child) { QualifyFunctionNames(context, child); });\n-\t\tbreak;\n-\t}\n-\tdefault: // fall through\n-\t\tbreak;\n-\t}\n-\t// unfold child expressions\n-\tParsedExpressionIterator::EnumerateChildren(\n-\t    *expr, [&](unique_ptr<ParsedExpression> &child) { QualifyFunctionNames(context, child); });\n-}\n-\n SchemaCatalogEntry &Binder::BindCreateFunctionInfo(CreateInfo &info) {\n \tauto &base = info.Cast<CreateMacroInfo>();\n \tauto &scalar_function = base.function->Cast<ScalarMacroFunction>();\n@@ -190,7 +163,6 @@ SchemaCatalogEntry &Binder::BindCreateFunctionInfo(CreateInfo &info) {\n \tauto this_macro_binding = make_uniq<DummyBinding>(dummy_types, dummy_names, base.name);\n \tmacro_binding = this_macro_binding.get();\n \tExpressionBinder::QualifyColumnNames(*this, scalar_function.expression);\n-\tQualifyFunctionNames(context, scalar_function.expression);\n \n \t// create a copy of the expression because we do not want to alter the original\n \tauto expression = scalar_function.expression->Copy();\ndiff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp\nindex 1f1dcbb5c726..266b4102c5c0 100644\n--- a/src/planner/expression_binder.cpp\n+++ b/src/planner/expression_binder.cpp\n@@ -10,6 +10,7 @@ namespace duckdb {\n \n ExpressionBinder::ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder)\n     : binder(binder), context(context) {\n+\tInitializeStackCheck();\n \tif (replace_binder) {\n \t\tstored_binder = &binder.GetActiveBinder();\n \t\tbinder.SetActiveBinder(*this);\n@@ -28,7 +29,26 @@ ExpressionBinder::~ExpressionBinder() {\n \t}\n }\n \n+void ExpressionBinder::InitializeStackCheck() {\n+\tif (binder.HasActiveBinder()) {\n+\t\tstack_depth = binder.GetActiveBinder().stack_depth;\n+\t} else {\n+\t\tstack_depth = 0;\n+\t}\n+}\n+\n+StackChecker<ExpressionBinder> ExpressionBinder::StackCheck(const ParsedExpression &expr, idx_t extra_stack) {\n+\tD_ASSERT(stack_depth != DConstants::INVALID_INDEX);\n+\tif (stack_depth + extra_stack >= MAXIMUM_STACK_DEPTH) {\n+\t\tthrow BinderException(\"Maximum recursion depth exceeded (Maximum: %llu) while binding \\\"%s\\\"\",\n+\t\t                      MAXIMUM_STACK_DEPTH, expr.ToString());\n+\t}\n+\treturn StackChecker<ExpressionBinder>(*this, extra_stack);\n+}\n+\n BindResult ExpressionBinder::BindExpression(unique_ptr<ParsedExpression> &expr, idx_t depth, bool root_expression) {\n+\tauto stack_checker = StackCheck(*expr);\n+\n \tauto &expr_ref = *expr;\n \tswitch (expr_ref.expression_class) {\n \tcase ExpressionClass::BETWEEN:\n",
  "test_patch": "diff --git a/test/sql/catalog/function/test_recursive_macro.test b/test/sql/catalog/function/test_recursive_macro.test\nindex ea877bca26d6..be9739561679 100644\n--- a/test/sql/catalog/function/test_recursive_macro.test\n+++ b/test/sql/catalog/function/test_recursive_macro.test\n@@ -5,15 +5,15 @@\n statement ok\n CREATE MACRO \"sum\"(x) AS (CASE WHEN sum(x) IS NULL THEN 0 ELSE sum(x) END);\n \n-query I\n+statement error\n SELECT sum(1);\n ----\n-1\n+Binder Error: Maximum recursion depth exceeded\n \n-query I\n+statement error\n SELECT sum(1) WHERE 42=0\n ----\n-0\n+Binder Error: Maximum recursion depth exceeded\n \n statement ok\n DROP MACRO sum\n@@ -31,3 +31,33 @@ query I\n SELECT sum(1) WHERE 42=0\n ----\n 0\n+\n+# evil test case by Mark\n+statement ok\n+create macro m1(a) as a+1;\n+\n+statement ok\n+create macro m2(a) as m1(a)+1;\n+\n+statement ok\n+create or replace macro m1(a) as m2(a)+1;\n+\n+statement error\n+select m2(42);\n+----\n+Binder Error: Maximum recursion depth exceeded\n+\n+# also table macros\n+statement ok\n+create macro m3(a) as a+1;\n+\n+statement ok\n+create macro m4(a) as table select m3(a);\n+\n+statement ok\n+create or replace macro m3(a) as (from m4(42));\n+\n+statement error\n+select m3(42);\n+----\n+Binder Error: Maximum recursion depth exceeded\ndiff --git a/test/sql/fts/test_fts_attach.test b/test/sql/fts/test_fts_attach.test\nindex 7c4c5c2820ac..530108e0ce82 100644\n--- a/test/sql/fts/test_fts_attach.test\n+++ b/test/sql/fts/test_fts_attach.test\n@@ -19,3 +19,47 @@ PRAGMA create_fts_index(search_con.main.my_table, 'CustomerId', 'CustomerName')\n \n statement ok\n SELECT search_con.fts_main_my_table.match_bm25(1, 'han')\n+\n+statement ok\n+DETACH search_con\n+\n+# test reopened #8141\n+load __TEST_DIR__/index.db\n+\n+statement ok\n+CREATE TABLE data AS SELECT 0 __index, 0 id, 'lorem ipsum' nl, NULL code;\n+\n+statement ok\n+PRAGMA create_fts_index('data', '__index', '*', overwrite=1);\n+\n+# test that it works before doing the problematic stuff\n+query IIII\n+SELECT * FROM data WHERE fts_main_data.match_bm25(__index, 'lorem') IS NOT NULL;\n+----\n+0\t0\tlorem ipsum\tNULL\n+\n+statement ok\n+ATTACH ':memory:' AS memory;\n+\n+statement ok\n+USE memory;\n+\n+statement ok\n+DETACH \"index\";\n+\n+# now attach again\n+statement ok\n+ATTACH '__TEST_DIR__/index.db' AS db;\n+\n+statement ok\n+USE db;\n+\n+query T\n+SELECT COUNT(*) FROM data;\n+----\n+1\n+\n+query IIII\n+SELECT * FROM data WHERE fts_main_data.match_bm25(__index, 'lorem') IS NOT NULL;\n+----\n+0\t0\tlorem ipsum\tNULL\n",
  "problem_statement": "Error when attaching a remote db with FTS\n### What happens?\n\nWhen trying to attach a db that has a fts index, it fails to fetch data using match_bm25 macro.\r\nError:\r\n\r\n```\r\n line 22, in <module>\r\n    result = con.execute(\r\nduckdb.BinderException: Binder Error: Catalog \"index\" does not exist!\r\n\r\n```\n\n### To Reproduce\n\n```\r\nimport duckdb\r\n\r\ncon = duckdb.connect()\r\n\r\nINSTALL_EXTENSION_COMMAND = \"INSTALL '{extension}';\"\r\nLOAD_EXTENSION_COMMAND = \"LOAD '{extension}';\"\r\n\r\ncon.execute(INSTALL_EXTENSION_COMMAND.format(extension=\"httpfs\"))\r\ncon.execute(LOAD_EXTENSION_COMMAND.format(extension=\"httpfs\"))\r\ncon.execute(INSTALL_EXTENSION_COMMAND.format(extension=\"fts\"))\r\ncon.execute(LOAD_EXTENSION_COMMAND.format(extension=\"fts\"))\r\n\r\nINDEX_URL = \"https://huggingface.co/datasets/asoria/copy_e_glue/resolve/refs%2Fconvert%2Fparquet/default/test/index.duckdb\"\r\nATTACH_COMMAND = f\"ATTACH '{INDEX_URL}' as db;\"\r\n\r\ncon.execute(ATTACH_COMMAND)\r\ncon.execute(\"use db;\")\r\n\r\nquery = \"denominator\"\r\nresult = con.execute(\r\n    \"SELECT * FROM data WHERE fts_main_data.match_bm25(__hf_index_id, ?) IS NOT NULL;\",\r\n    [query],\r\n)\r\n\r\nrows = result.df()\r\nprint(f\"{rows=}\")\r\ncon.close()\r\n```\n\n### OS:\n\nUbuntu 22.04.2 LTS x86_64\n\n### DuckDB Version:\n\n0.8.2.dev161\n\n### DuckDB Client:\n\nPython 0.8.2.dev161\n\n### Full Name:\n\nAndrea Soria\n\n### Affiliation:\n\nHugging Face\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "This looks similar to https://github.com/duckdb/duckdb/issues/7384\nShould be fixed now\nI tried the fix with the master version (0.8.2.dev1212) but it is still failing:\r\n\r\n```\r\nimport duckdb\r\n\r\nINSTALL_EXTENSION_COMMAND = \"INSTALL '{extension}';\"\r\nLOAD_EXTENSION_COMMAND = \"LOAD '{extension}';\"\r\nINDEX_FILENAME = \"index.duckdb\"\r\nCREATE_SEQUENCE_COMMAND = \"CREATE OR REPLACE SEQUENCE serial START 1;\"\r\nCREATE_INDEX_COMMAND = \"PRAGMA create_fts_index('data', '__index', '*', overwrite=1);\"\r\nCREATE_TABLE_COMMAND = \"CREATE OR REPLACE TABLE data AS SELECT nextval('serial') AS __index, * FROM\"\r\n\r\ncon = duckdb.connect(INDEX_FILENAME)\r\n\r\ncon.execute(INSTALL_EXTENSION_COMMAND.format(extension=\"httpfs\"))\r\ncon.execute(LOAD_EXTENSION_COMMAND.format(extension=\"httpfs\"))\r\ncon.execute(INSTALL_EXTENSION_COMMAND.format(extension=\"fts\"))\r\ncon.execute(LOAD_EXTENSION_COMMAND.format(extension=\"fts\"))\r\n\r\ncon.sql(CREATE_SEQUENCE_COMMAND)\r\n\r\nparquet_urls = [\"https://huggingface.co/datasets/asoria/copy_e_glue/resolve/refs%2Fconvert%2Fparquet/default/copy_e_glue-test.parquet\"]\r\ncreate_command_sql = f\"{CREATE_TABLE_COMMAND} read_parquet({parquet_urls});\"\r\ncon.sql(create_command_sql)\r\n\r\ncreate_index_sql = CREATE_INDEX_COMMAND\r\ncon.sql(create_index_sql)\r\ncon.close()\r\n\r\nmem_con = duckdb.connect()\r\nmem_con.execute(INSTALL_EXTENSION_COMMAND.format(extension=\"httpfs\"))\r\nmem_con.execute(LOAD_EXTENSION_COMMAND.format(extension=\"httpfs\"))\r\nmem_con.execute(INSTALL_EXTENSION_COMMAND.format(extension=\"fts\"))\r\nmem_con.execute(LOAD_EXTENSION_COMMAND.format(extension=\"fts\"))\r\n\r\nATTACH_COMMAND = f\"ATTACH '{INDEX_FILENAME}' as db;\"\r\n\r\nmem_con.execute(ATTACH_COMMAND)\r\nmem_con.execute(\"use db;\")\r\nrecord_count = mem_con.sql(\"SELECT COUNT(*) FROM data;\").fetchall()\r\nprint(f\"{record_count=}\")  # OK -It returns the correct number of rows\r\n\r\nquery = \"denominator\"\r\nresult = mem_con.execute(\r\n    \"SELECT * FROM data WHERE fts_main_data.match_bm25(__index, ?) IS NOT NULL;\",\r\n    [query],\r\n)  # FAIL - Binder Error: Catalog \"index\" does not exist!\r\n\r\nrows = result.df()\r\nprint(f\"{rows=}\")\r\nmem_con.close()\r\n\r\n```\r\n\r\nAs you can see, in the first part I generate a db file with a fts index and then I try to load it for search but the problem is the same:\r\n\r\n\r\n```\r\n\r\n    result = mem_con.execute(\r\nduckdb.BinderException: Binder Error: Catalog \"index\" does not exist!\r\n```\r\n\r\nAm I doing something wrong? \n@lnkuiper could you have another look when you have time?",
  "created_at": "2023-07-12T13:44:33Z"
}