{
  "repo": "duckdb/duckdb",
  "pull_number": 15484,
  "instance_id": "duckdb__duckdb-15484",
  "issue_numbers": [
    "15466",
    "15466"
  ],
  "base_commit": "0959644c1d57409e78d2fae0262f792921a54c55",
  "patch": "diff --git a/src/parser/transform/statement/transform_select_node.cpp b/src/parser/transform/statement/transform_select_node.cpp\nindex ab206fdb860d..56ef6c71c744 100644\n--- a/src/parser/transform/statement/transform_select_node.cpp\n+++ b/src/parser/transform/statement/transform_select_node.cpp\n@@ -31,11 +31,20 @@ void Transformer::TransformModifiers(duckdb_libpgquery::PGSelectStmt &stmt, Quer\n \t\t\tnode.modifiers.push_back(std::move(limit_percent_modifier));\n \t\t} else {\n \t\t\tauto limit_modifier = make_uniq<LimitModifier>();\n-\t\t\tif (stmt.limitCount) {\n-\t\t\t\tlimit_modifier->limit = TransformExpression(stmt.limitCount);\n-\t\t\t}\n-\t\t\tif (stmt.limitOffset) {\n-\t\t\t\tlimit_modifier->offset = TransformExpression(stmt.limitOffset);\n+\t\t\tif (stmt.offset_first) {\n+\t\t\t\tif (stmt.limitOffset) {\n+\t\t\t\t\tlimit_modifier->offset = TransformExpression(stmt.limitOffset);\n+\t\t\t\t}\n+\t\t\t\tif (stmt.limitCount) {\n+\t\t\t\t\tlimit_modifier->limit = TransformExpression(stmt.limitCount);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (stmt.limitCount) {\n+\t\t\t\t\tlimit_modifier->limit = TransformExpression(stmt.limitCount);\n+\t\t\t\t}\n+\t\t\t\tif (stmt.limitOffset) {\n+\t\t\t\t\tlimit_modifier->offset = TransformExpression(stmt.limitOffset);\n+\t\t\t\t}\n \t\t\t}\n \t\t\tnode.modifiers.push_back(std::move(limit_modifier));\n \t\t}\ndiff --git a/third_party/libpg_query/grammar/grammar.cpp b/third_party/libpg_query/grammar/grammar.cpp\nindex 39f849278640..6774ce90ae53 100644\n--- a/third_party/libpg_query/grammar/grammar.cpp\n+++ b/third_party/libpg_query/grammar/grammar.cpp\n@@ -366,7 +366,7 @@ static PGNode* makeNamedParamRef(char *name, int location)\n static void\n insertSelectOptions(PGSelectStmt *stmt,\n \t\t\t\t\tPGList *sortClause, PGList *lockingClause,\n-\t\t\t\t\tPGNode *limitOffset, PGNode *limitCount,\n+\t\t\t\t\tPGNode *limitOffset, PGNode *limitCount, PGNode *isLimitOffsetFirst,\n \t\t\t\t\tPGWithClause *withClause,\n \t\t\t\t\tcore_yyscan_t yyscanner)\n {\n@@ -411,6 +411,9 @@ insertSelectOptions(PGSelectStmt *stmt,\n \t\t\t\t\t parser_errposition(exprLocation(limitCount))));\n \t\tstmt->limitCount = limitCount;\n \t}\n+\tif (limitOffset == isLimitOffsetFirst) {\n+\t\tstmt->offset_first = true;\n+\t}\n \tif (withClause)\n \t{\n \t\tif (stmt->withClause)\ndiff --git a/third_party/libpg_query/grammar/grammar.hpp b/third_party/libpg_query/grammar/grammar.hpp\nindex f442bd3edbd1..c50538d683c0 100644\n--- a/third_party/libpg_query/grammar/grammar.hpp\n+++ b/third_party/libpg_query/grammar/grammar.hpp\n@@ -197,7 +197,7 @@ static PGList *check_func_name(PGList *names, core_yyscan_t yyscanner);\n static PGList *check_indirection(PGList *indirection, core_yyscan_t yyscanner);\n static void insertSelectOptions(PGSelectStmt *stmt,\n \t\t\t\t\t\t\t\tPGList *sortClause, PGList *lockingClause,\n-\t\t\t\t\t\t\t\tPGNode *limitOffset, PGNode *limitCount,\n+\t\t\t\t\t\t\t\tPGNode *limitOffset, PGNode *limitCount, PGNode *isLimitOffsetFirst,\n \t\t\t\t\t\t\t\tPGWithClause *withClause,\n \t\t\t\t\t\t\t\tcore_yyscan_t yyscanner);\n static PGNode *makeSetOp(PGSetOperation op, bool all, PGNode *larg, PGNode *rarg);\ndiff --git a/third_party/libpg_query/grammar/statements/select.y b/third_party/libpg_query/grammar/statements/select.y\nindex f1b2200323e1..e6bb118cf6d6 100644\n--- a/third_party/libpg_query/grammar/statements/select.y\n+++ b/third_party/libpg_query/grammar/statements/select.y\n@@ -73,14 +73,14 @@ select_no_parens:\n \t\t\t| select_clause sort_clause\n \t\t\t\t{\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) $1, $2, NIL,\n-\t\t\t\t\t\t\t\t\t\tNULL, NULL, NULL,\n+\t\t\t\t\t\t\t\t\t\tNULL, NULL, NULL, NULL,\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t$$ = $1;\n \t\t\t\t}\n \t\t\t| select_clause opt_sort_clause for_locking_clause opt_select_limit\n \t\t\t\t{\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) $1, $2, $3,\n-\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth($4, 0), (PGNode*) list_nth($4, 1),\n+\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth($4, 0), (PGNode*) list_nth($4, 1), (PGNode*) list_nth($4, 2),\n \t\t\t\t\t\t\t\t\t\tNULL,\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t$$ = $1;\n@@ -88,7 +88,7 @@ select_no_parens:\n \t\t\t| select_clause opt_sort_clause select_limit opt_for_locking_clause\n \t\t\t\t{\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) $1, $2, $4,\n-\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth($3, 0), (PGNode*) list_nth($3, 1),\n+\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth($3, 0), (PGNode*) list_nth($3, 1), (PGNode*) list_nth($3, 2),\n \t\t\t\t\t\t\t\t\t\tNULL,\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t$$ = $1;\n@@ -96,7 +96,7 @@ select_no_parens:\n \t\t\t| with_clause select_clause\n \t\t\t\t{\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) $2, NULL, NIL,\n-\t\t\t\t\t\t\t\t\t\tNULL, NULL,\n+\t\t\t\t\t\t\t\t\t\tNULL, NULL, NULL,\n \t\t\t\t\t\t\t\t\t\t$1,\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t$$ = $2;\n@@ -104,7 +104,7 @@ select_no_parens:\n \t\t\t| with_clause select_clause sort_clause\n \t\t\t\t{\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) $2, $3, NIL,\n-\t\t\t\t\t\t\t\t\t\tNULL, NULL,\n+\t\t\t\t\t\t\t\t\t\tNULL, NULL, NULL,\n \t\t\t\t\t\t\t\t\t\t$1,\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t$$ = $2;\n@@ -112,7 +112,7 @@ select_no_parens:\n \t\t\t| with_clause select_clause opt_sort_clause for_locking_clause opt_select_limit\n \t\t\t\t{\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) $2, $3, $4,\n-\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth($5, 0), (PGNode*) list_nth($5, 1),\n+\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth($5, 0), (PGNode*) list_nth($5, 1), (PGNode*) list_nth($5, 2),\n \t\t\t\t\t\t\t\t\t\t$1,\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t$$ = $2;\n@@ -120,7 +120,7 @@ select_no_parens:\n \t\t\t| with_clause select_clause opt_sort_clause select_limit opt_for_locking_clause\n \t\t\t\t{\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) $2, $3, $5,\n-\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth($4, 0), (PGNode*) list_nth($4, 1),\n+\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth($4, 0), (PGNode*) list_nth($4, 1), (PGNode*) list_nth($4, 2),\n \t\t\t\t\t\t\t\t\t\t$1,\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t$$ = $2;\n@@ -640,15 +640,15 @@ opt_nulls_order: NULLS_LA FIRST_P\t\t\t{ $$ = PG_SORTBY_NULLS_FIRST; }\n \t\t;\n \n select_limit:\n-\t\t\tlimit_clause offset_clause\t\t\t{ $$ = list_make2($2, $1); }\n-\t\t\t| offset_clause limit_clause\t\t{ $$ = list_make2($1, $2); }\n-\t\t\t| limit_clause\t\t\t\t\t\t{ $$ = list_make2(NULL, $1); }\n-\t\t\t| offset_clause\t\t\t\t\t\t{ $$ = list_make2($1, NULL); }\n+\t\t\tlimit_clause offset_clause\t\t\t{ $$ = list_make3($2, $1, NULL); }\n+\t\t\t| offset_clause limit_clause\t\t{ $$ = list_make3($1, $2, $1); }\n+\t\t\t| limit_clause\t\t\t\t\t\t{ $$ = list_make3(NULL, $1, NULL); }\n+\t\t\t| offset_clause\t\t\t\t\t\t{ $$ = list_make3($1, NULL, $1); }\n \t\t;\n \n opt_select_limit:\n \t\t\tselect_limit\t\t\t\t\t\t{ $$ = $1; }\n-\t\t\t| /* EMPTY */\t\t\t\t\t\t{ $$ = list_make2(NULL,NULL); }\n+\t\t\t| /* EMPTY */\t\t\t\t\t\t{ $$ = list_make3(NULL,NULL,NULL); }\n \t\t;\n \n limit_clause:\ndiff --git a/third_party/libpg_query/include/nodes/parsenodes.hpp b/third_party/libpg_query/include/nodes/parsenodes.hpp\nindex 2fbf2cf75245..4789b88661c6 100755\n--- a/third_party/libpg_query/include/nodes/parsenodes.hpp\n+++ b/third_party/libpg_query/include/nodes/parsenodes.hpp\n@@ -1289,6 +1289,7 @@ typedef struct PGSelectStmt {\n \tPGSetOperation op;         /* type of set op */\n \tbool all;                  /* ALL specified? */\n \tbool from_first;           /* FROM first or SELECT first */\n+\tbool offset_first;         /* OFFSET first or LIMIT first */\n \tstruct PGNode *larg; /* left child */\n \tstruct PGNode *rarg; /* right child */\n \t                           /* Eventually add fields for CORRESPONDING spec here */\ndiff --git a/third_party/libpg_query/src_backend_parser_gram.cpp b/third_party/libpg_query/src_backend_parser_gram.cpp\nindex 71ed8b023f32..e8bf4eb50e38 100644\n--- a/third_party/libpg_query/src_backend_parser_gram.cpp\n+++ b/third_party/libpg_query/src_backend_parser_gram.cpp\n@@ -1292,7 +1292,7 @@ static PGList *check_func_name(PGList *names, core_yyscan_t yyscanner);\n static PGList *check_indirection(PGList *indirection, core_yyscan_t yyscanner);\n static void insertSelectOptions(PGSelectStmt *stmt,\n \t\t\t\t\t\t\t\tPGList *sortClause, PGList *lockingClause,\n-\t\t\t\t\t\t\t\tPGNode *limitOffset, PGNode *limitCount,\n+\t\t\t\t\t\t\t\tPGNode *limitOffset, PGNode *limitCount, PGNode *isLimitOffsetFirst,\n \t\t\t\t\t\t\t\tPGWithClause *withClause,\n \t\t\t\t\t\t\t\tcore_yyscan_t yyscanner);\n static PGNode *makeSetOp(PGSetOperation op, bool all, PGNode *larg, PGNode *rarg);\n@@ -24378,7 +24378,7 @@ YYLTYPE yylloc;\n #line 74 \"third_party/libpg_query/grammar/statements/select.y\"\n     {\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) (yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].list), NIL,\n-\t\t\t\t\t\t\t\t\t\tNULL, NULL, NULL,\n+\t\t\t\t\t\t\t\t\t\tNULL, NULL, NULL, NULL,\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t(yyval.node) = (yyvsp[(1) - (2)].node);\n \t\t\t\t;}\n@@ -24388,7 +24388,7 @@ YYLTYPE yylloc;\n #line 81 \"third_party/libpg_query/grammar/statements/select.y\"\n     {\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) (yyvsp[(1) - (4)].node), (yyvsp[(2) - (4)].list), (yyvsp[(3) - (4)].list),\n-\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth((yyvsp[(4) - (4)].list), 0), (PGNode*) list_nth((yyvsp[(4) - (4)].list), 1),\n+\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth((yyvsp[(4) - (4)].list), 0), (PGNode*) list_nth((yyvsp[(4) - (4)].list), 1), (PGNode*) list_nth((yyvsp[(4) - (4)].list), 2),\n \t\t\t\t\t\t\t\t\t\tNULL,\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t(yyval.node) = (yyvsp[(1) - (4)].node);\n@@ -24399,7 +24399,7 @@ YYLTYPE yylloc;\n #line 89 \"third_party/libpg_query/grammar/statements/select.y\"\n     {\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) (yyvsp[(1) - (4)].node), (yyvsp[(2) - (4)].list), (yyvsp[(4) - (4)].list),\n-\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth((yyvsp[(3) - (4)].list), 0), (PGNode*) list_nth((yyvsp[(3) - (4)].list), 1),\n+\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth((yyvsp[(3) - (4)].list), 0), (PGNode*) list_nth((yyvsp[(3) - (4)].list), 1), (PGNode*) list_nth((yyvsp[(3) - (4)].list), 2),\n \t\t\t\t\t\t\t\t\t\tNULL,\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t(yyval.node) = (yyvsp[(1) - (4)].node);\n@@ -24410,7 +24410,7 @@ YYLTYPE yylloc;\n #line 97 \"third_party/libpg_query/grammar/statements/select.y\"\n     {\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) (yyvsp[(2) - (2)].node), NULL, NIL,\n-\t\t\t\t\t\t\t\t\t\tNULL, NULL,\n+\t\t\t\t\t\t\t\t\t\tNULL, NULL, NULL,\n \t\t\t\t\t\t\t\t\t\t(yyvsp[(1) - (2)].with),\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t(yyval.node) = (yyvsp[(2) - (2)].node);\n@@ -24421,7 +24421,7 @@ YYLTYPE yylloc;\n #line 105 \"third_party/libpg_query/grammar/statements/select.y\"\n     {\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) (yyvsp[(2) - (3)].node), (yyvsp[(3) - (3)].list), NIL,\n-\t\t\t\t\t\t\t\t\t\tNULL, NULL,\n+\t\t\t\t\t\t\t\t\t\tNULL, NULL, NULL,\n \t\t\t\t\t\t\t\t\t\t(yyvsp[(1) - (3)].with),\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t(yyval.node) = (yyvsp[(2) - (3)].node);\n@@ -24432,7 +24432,7 @@ YYLTYPE yylloc;\n #line 113 \"third_party/libpg_query/grammar/statements/select.y\"\n     {\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) (yyvsp[(2) - (5)].node), (yyvsp[(3) - (5)].list), (yyvsp[(4) - (5)].list),\n-\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth((yyvsp[(5) - (5)].list), 0), (PGNode*) list_nth((yyvsp[(5) - (5)].list), 1),\n+\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth((yyvsp[(5) - (5)].list), 0), (PGNode*) list_nth((yyvsp[(5) - (5)].list), 1), (PGNode*) list_nth((yyvsp[(5) - (5)].list), 2),\n \t\t\t\t\t\t\t\t\t\t(yyvsp[(1) - (5)].with),\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t(yyval.node) = (yyvsp[(2) - (5)].node);\n@@ -24443,7 +24443,7 @@ YYLTYPE yylloc;\n #line 121 \"third_party/libpg_query/grammar/statements/select.y\"\n     {\n \t\t\t\t\tinsertSelectOptions((PGSelectStmt *) (yyvsp[(2) - (5)].node), (yyvsp[(3) - (5)].list), (yyvsp[(5) - (5)].list),\n-\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth((yyvsp[(4) - (5)].list), 0), (PGNode*) list_nth((yyvsp[(4) - (5)].list), 1),\n+\t\t\t\t\t\t\t\t\t\t(PGNode*) list_nth((yyvsp[(4) - (5)].list), 0), (PGNode*) list_nth((yyvsp[(4) - (5)].list), 1), (PGNode*) list_nth((yyvsp[(4) - (5)].list), 2),\n \t\t\t\t\t\t\t\t\t\t(yyvsp[(1) - (5)].with),\n \t\t\t\t\t\t\t\t\t\tyyscanner);\n \t\t\t\t\t(yyval.node) = (yyvsp[(2) - (5)].node);\n@@ -25103,22 +25103,22 @@ YYLTYPE yylloc;\n \n   case 622:\n #line 643 \"third_party/libpg_query/grammar/statements/select.y\"\n-    { (yyval.list) = list_make2((yyvsp[(2) - (2)].node), (yyvsp[(1) - (2)].node)); ;}\n+    { (yyval.list) = list_make3((yyvsp[(2) - (2)].node), (yyvsp[(1) - (2)].node), NULL); ;}\n     break;\n \n   case 623:\n #line 644 \"third_party/libpg_query/grammar/statements/select.y\"\n-    { (yyval.list) = list_make2((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node)); ;}\n+    { (yyval.list) = list_make3((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node), (yyvsp[(1) - (2)].node)); ;}\n     break;\n \n   case 624:\n #line 645 \"third_party/libpg_query/grammar/statements/select.y\"\n-    { (yyval.list) = list_make2(NULL, (yyvsp[(1) - (1)].node)); ;}\n+    { (yyval.list) = list_make3(NULL, (yyvsp[(1) - (1)].node), NULL); ;}\n     break;\n \n   case 625:\n #line 646 \"third_party/libpg_query/grammar/statements/select.y\"\n-    { (yyval.list) = list_make2((yyvsp[(1) - (1)].node), NULL); ;}\n+    { (yyval.list) = list_make3((yyvsp[(1) - (1)].node), NULL, (yyvsp[(1) - (1)].node)); ;}\n     break;\n \n   case 626:\n@@ -25128,7 +25128,7 @@ YYLTYPE yylloc;\n \n   case 627:\n #line 651 \"third_party/libpg_query/grammar/statements/select.y\"\n-    { (yyval.list) = list_make2(NULL,NULL); ;}\n+    { (yyval.list) = list_make3(NULL,NULL,NULL); ;}\n     break;\n \n   case 628:\n@@ -32114,7 +32114,7 @@ static PGNode* makeNamedParamRef(char *name, int location)\n static void\n insertSelectOptions(PGSelectStmt *stmt,\n \t\t\t\t\tPGList *sortClause, PGList *lockingClause,\n-\t\t\t\t\tPGNode *limitOffset, PGNode *limitCount,\n+\t\t\t\t\tPGNode *limitOffset, PGNode *limitCount, PGNode *isLimitOffsetFirst,\n \t\t\t\t\tPGWithClause *withClause,\n \t\t\t\t\tcore_yyscan_t yyscanner)\n {\n@@ -32159,6 +32159,9 @@ insertSelectOptions(PGSelectStmt *stmt,\n \t\t\t\t\t parser_errposition(exprLocation(limitCount))));\n \t\tstmt->limitCount = limitCount;\n \t}\n+  if (limitOffset == isLimitOffsetFirst) {\n+    stmt->offset_first = true;\n+  }\n \tif (withClause)\n \t{\n \t\tif (stmt->withClause)\n",
  "test_patch": "diff --git a/test/sql/prepared/prepare_offset_first.test b/test/sql/prepared/prepare_offset_first.test\nnew file mode 100644\nindex 000000000000..d7fb5b43c5cc\n--- /dev/null\n+++ b/test/sql/prepared/prepare_offset_first.test\n@@ -0,0 +1,30 @@\n+# name: test/sql/prepared/prepare_offset_first.test\n+# description: Test OFFSET and LIMIT with prepared statements\n+# group: [prepared]\n+\n+statement ok\n+pragma enable_verification\n+\n+# Prepare a query with OFFSET and LIMIT as parameters with OFFSET written first in the query\n+statement ok\n+PREPARE q AS SELECT x FROM generate_series(1, 10) t(x) OFFSET ? LIMIT ?;\n+\n+# Execute the prepared query with OFFSET = 3 and LIMIT = 5\n+query I\n+EXECUTE q(3, 5);\n+----\n+4\n+5\n+6\n+7\n+8\n+\n+# Verify the result matches the direct query\n+query I\n+SELECT x FROM generate_series(1, 10) t(x) OFFSET 3 LIMIT 5;\n+----\n+4\n+5\n+6\n+7\n+8\n",
  "problem_statement": "Parameters for OFFSET and LIMIT in a prepared statement get swapped\nI am experiencing a strange effect with DuckDB and Java when passing in OFFSET and LIMIT as parameters in a prepared statement. \r\n\r\nTo make it work I have to swap the assignment of the parameters compared to the expected i.e. set the desired limit as first parameter and the desired offset as second even though the order is the oposite in the prepared statement....\r\nIf I do not switch the order I get zero records in the result (because the limit seems to become zero).\r\n\r\nWhat am I doing wrong here or are there some known quirks/problems with DuckDB (1.1.3) parameter mapping?\r\n\r\nMy program (somewhat simplified) looks like this:\r\nimport java.sql.*;\r\n\r\n```\r\npublic class DuckDBParameterBindingTest {\r\n\r\n    private static final String JDBC_URL = \"jdbc:duckdb:demo.db\";\r\n    private static final String QUERY = \"SELECT a, b, c, d, e FROM table ORDER BY a, b, c, d, e OFFSET ? LIMIT ?\";\r\n\r\n    public static void main(String[] args) {\r\n        try (Connection connection = DriverManager.getConnection(JDBC_URL);\r\n             PreparedStatement preparedStatement = connection.prepareStatement(QUERY)) {\r\n\r\n            System.out.println(\"Test 1: Standard parameter binding (OFFSET=0, LIMIT=5)\");\r\n            preparedStatement.setInt(1, 0); // OFFSET\r\n            preparedStatement.setInt(2, 5); // LIMIT\r\n            runQuery(preparedStatement); // Incorrect result: No rows printed\r\n\r\n            System.out.println(\"Test 2: Swapped parameter binding (LIMIT=5, OFFSET=0)\");\r\n            preparedStatement.setInt(1, 5); // LIMIT\r\n            preparedStatement.setInt(2, 0); // OFFSET\r\n            runQuery(preparedStatement); // Correct result: 5 rows printed\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private static void runQuery(PreparedStatement preparedStatement) throws SQLException {\r\n        try (ResultSet resultSet = preparedStatement.executeQuery()) {\r\n            while (resultSet.next()) {\r\n                System.out.printf(\"%s, %s, %d, %d, %d%n\",\r\n                        resultSet.getString(1),\r\n                        resultSet.getString(2),\r\n                        resultSet.getLong(3),\r\n                        resultSet.getLong(4),\r\n                        resultSet.getLong(5));\r\n            }\r\n            System.out.println(\"-------------------------\");\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n_Originally posted by @javafanboy in https://github.com/duckdb/duckdb/discussions/14907_\nParameters for OFFSET and LIMIT in a prepared statement get swapped\nI am experiencing a strange effect with DuckDB and Java when passing in OFFSET and LIMIT as parameters in a prepared statement. \r\n\r\nTo make it work I have to swap the assignment of the parameters compared to the expected i.e. set the desired limit as first parameter and the desired offset as second even though the order is the oposite in the prepared statement....\r\nIf I do not switch the order I get zero records in the result (because the limit seems to become zero).\r\n\r\nWhat am I doing wrong here or are there some known quirks/problems with DuckDB (1.1.3) parameter mapping?\r\n\r\nMy program (somewhat simplified) looks like this:\r\nimport java.sql.*;\r\n\r\n```\r\npublic class DuckDBParameterBindingTest {\r\n\r\n    private static final String JDBC_URL = \"jdbc:duckdb:demo.db\";\r\n    private static final String QUERY = \"SELECT a, b, c, d, e FROM table ORDER BY a, b, c, d, e OFFSET ? LIMIT ?\";\r\n\r\n    public static void main(String[] args) {\r\n        try (Connection connection = DriverManager.getConnection(JDBC_URL);\r\n             PreparedStatement preparedStatement = connection.prepareStatement(QUERY)) {\r\n\r\n            System.out.println(\"Test 1: Standard parameter binding (OFFSET=0, LIMIT=5)\");\r\n            preparedStatement.setInt(1, 0); // OFFSET\r\n            preparedStatement.setInt(2, 5); // LIMIT\r\n            runQuery(preparedStatement); // Incorrect result: No rows printed\r\n\r\n            System.out.println(\"Test 2: Swapped parameter binding (LIMIT=5, OFFSET=0)\");\r\n            preparedStatement.setInt(1, 5); // LIMIT\r\n            preparedStatement.setInt(2, 0); // OFFSET\r\n            runQuery(preparedStatement); // Correct result: 5 rows printed\r\n\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private static void runQuery(PreparedStatement preparedStatement) throws SQLException {\r\n        try (ResultSet resultSet = preparedStatement.executeQuery()) {\r\n            while (resultSet.next()) {\r\n                System.out.printf(\"%s, %s, %d, %d, %d%n\",\r\n                        resultSet.getString(1),\r\n                        resultSet.getString(2),\r\n                        resultSet.getLong(3),\r\n                        resultSet.getLong(4),\r\n                        resultSet.getLong(5));\r\n            }\r\n            System.out.println(\"-------------------------\");\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n_Originally posted by @javafanboy in https://github.com/duckdb/duckdb/discussions/14907_\n",
  "hints_text": "Hi @javafanboy, thanks for reporting this! The issue can be reproduced in the DuckDB CLI client:\r\n\r\n```sql\r\nPREPARE q AS SELECT x FROM generate_series(1, 10) t(x) OFFSET ? LIMIT ?;\r\nEXECUTE q(3, 5);\r\n```\r\n```text\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   x   \u2502\r\n\u2502 int64 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     6 \u2502\r\n\u2502     7 \u2502\r\n\u2502     8 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nThe reason you're experiencing this issue is that the default order of these clauses is [`LIMIT` followed by `OFFSET`](https://duckdb.org/docs/sql/statements/select#order-by-limit-and-offset-clauses) and while DuckDB allows you to swap them, switching them up is not tracked by prepared statements, causing a mixup. This is similar to issue #13585, where switching up the `SELECT` and `FROM` clauses caused prepared statements to evaluate incorrectly.\r\n\r\nFor now, a workaround is to use `LIMIT ... OFFSET`. As this is a bug that can lead to uncorrect results, we'll fix it for the next release.\r\n\nThanks for the quick reply - will switch to the \"preferred order\" to avoid my code stop working once the problem is fixed!\n@javafanboy no need to close issues before they are actually fixed - that only increases the chance they'll slip through unfixed. \nhi @szarnyasg, I would like to work on this issue. I have identified the potential fix for this.\r\nPlease assign this issue to me.\n@ashwaniYDV thanks for offering your contribution! I assigned you. Please tag me in the PR of the proposed fix once it's ready to review.\nHi @javafanboy, thanks for reporting this! The issue can be reproduced in the DuckDB CLI client:\r\n\r\n```sql\r\nPREPARE q AS SELECT x FROM generate_series(1, 10) t(x) OFFSET ? LIMIT ?;\r\nEXECUTE q(3, 5);\r\n```\r\n```text\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   x   \u2502\r\n\u2502 int64 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     6 \u2502\r\n\u2502     7 \u2502\r\n\u2502     8 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nThe reason you're experiencing this issue is that the default order of these clauses is [`LIMIT` followed by `OFFSET`](https://duckdb.org/docs/sql/statements/select#order-by-limit-and-offset-clauses) and while DuckDB allows you to swap them, switching them up is not tracked by prepared statements, causing a mixup. This is similar to issue #13585, where switching up the `SELECT` and `FROM` clauses caused prepared statements to evaluate incorrectly.\r\n\r\nFor now, a workaround is to use `LIMIT ... OFFSET`. As this is a bug that can lead to uncorrect results, we'll fix it for the next release.\r\n\nThanks for the quick reply - will switch to the \"preferred order\" to avoid my code stop working once the problem is fixed!\n@javafanboy no need to close issues before they are actually fixed - that only increases the chance they'll slip through unfixed. \nhi @szarnyasg, I would like to work on this issue. I have identified the potential fix for this.\r\nPlease assign this issue to me.\n@ashwaniYDV thanks for offering your contribution! I assigned you. Please tag me in the PR of the proposed fix once it's ready to review.",
  "created_at": "2024-12-28T17:05:31Z"
}