You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
R: CI
Travis or GHA? -> TBD

@hannesmuehleisen 
Any important secrets that we need to be aware of?



</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="30">
2: 
3: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of tools/rpkg/.Rbuildignore]
1: .*\.sh
2: .*\.tar.gz
3: dependencies\.R
4: git
5: configure
6: ^.*\.Rproj$
7: ^\.Rproj\.user$
[end of tools/rpkg/.Rbuildignore]
[start of tools/rpkg/DESCRIPTION]
1: Package: duckdb
2: Title: DBI Package for the DuckDB Database Management System
3: Version: 0.2.0
4: Authors@R:
5:     c(person(given = "Hannes",
6:              family = "MÃ¼hleisen",
7:              role = c("aut", "cre"),
8:              email = "hannes@cwi.nl",
9:              comment = c(ORCID = "0000-0001-8552-0029")),
10:       person(given = "Mark",
11:              family = "Raasveldt",
12:              role = "aut",
13:              email = "mark.raasveldt@cwi.nl",
14:              comment = c(ORCID = "0000-0001-5005-6844")),
15:       person(given = "DuckDB Contributors",
16:              role = "aut"))
17: Description: DuckDB is an embedded analytical data management
18:     system with SQL support. This package includes all of DuckDB as well
19:     as R DBI & dplyr connectors.
20: License: MPL
21: URL: https://www.duckdb.org, https://github.com/cwida/duckdb
22: BugReports: https://github.com/cwida/duckdb/issues
23: Depends:
24:     DBI,
25:     R (>= 3.5.0)
26: Imports:
27:     dbplyr,
28:     methods,
29:     testthat,
30:     utils
31: Suggests:
32:     callr,
33:     DBItest,
34:     nycflights13
35: Encoding: UTF-8
36: LazyData: true
37: RoxygenNote: 7.1.0.9000
38: SystemRequirements: C++11
39: Collate:
40:     'duckdb.R'
41:     'Driver.R'
42:     'Connection.R'
43:     'Result.R'
44:     'duckdb-package.R'
[end of tools/rpkg/DESCRIPTION]
[start of tools/rpkg/NAMESPACE]
1: # Generated by roxygen2: do not edit by hand
2: 
3: export(duckdb)
4: export(duckdb_register)
5: export(duckdb_shutdown)
6: export(duckdb_unregister)
7: export(read_csv_duckdb)
8: export(src_duckdb)
9: exportClasses(duckdb_connection)
10: exportClasses(duckdb_driver)
11: exportClasses(duckdb_result)
12: exportMethods(dbBegin)
13: exportMethods(dbBind)
14: exportMethods(dbClearResult)
15: exportMethods(dbColumnInfo)
16: exportMethods(dbCommit)
17: exportMethods(dbConnect)
18: exportMethods(dbDataType)
19: exportMethods(dbDisconnect)
20: exportMethods(dbExistsTable)
21: exportMethods(dbFetch)
22: exportMethods(dbGetInfo)
23: exportMethods(dbGetRowCount)
24: exportMethods(dbGetRowsAffected)
25: exportMethods(dbGetStatement)
26: exportMethods(dbHasCompleted)
27: exportMethods(dbIsValid)
28: exportMethods(dbListFields)
29: exportMethods(dbListTables)
30: exportMethods(dbRemoveTable)
31: exportMethods(dbRollback)
32: exportMethods(dbSendQuery)
33: exportMethods(dbWriteTable)
34: exportMethods(show)
35: import(DBI)
36: import(methods)
37: importFrom(DBI,dbConnect)
38: importFrom(dbplyr,src_dbi)
39: importFrom(testthat,skip)
40: importFrom(utils,head)
41: useDynLib(duckdb, .registration = TRUE)
[end of tools/rpkg/NAMESPACE]
[start of tools/rpkg/R/Connection.R]
1: #' @include Driver.R
2: 
3: NULL
4: 
5: 
6: duckdb_connection <- function(duckdb_driver, debug) {
7:   new(
8:     "duckdb_connection",
9:     conn_ref = .Call(duckdb_connect_R, duckdb_driver@database_ref),
10:     driver = duckdb_driver,
11:     debug = debug
12:   )
13: }
14: 
15: #' @rdname DBI
16: #' @export
17: duckdb_register <- function(conn, name, df) {
18:   stopifnot(dbIsValid(conn))
19:   .Call(duckdb_register_R, conn@conn_ref, as.character(name), as.data.frame(df))
20:   invisible(TRUE)
21: }
22: 
23: #' @rdname DBI
24: #' @export
25: duckdb_unregister <- function(conn, name) {
26:   stopifnot(dbIsValid(conn))
27:   .Call(duckdb_unregister_R, conn@conn_ref, as.character(name))
28:   invisible(TRUE)
29: }
30: 
31: 
32: #' @rdname DBI
33: #' @export
34: setClass(
35:   "duckdb_connection",
36:   contains = "DBIConnection",
37:   slots = list(dbdir = "character", conn_ref = "externalptr", driver = "duckdb_driver", debug = "logical")
38: )
39: 
40: #' @rdname DBI
41: #' @inheritParams methods::show
42: #' @export
43: setMethod(
44:   "show", "duckdb_connection",
45:   function(object) {
46:     cat(sprintf("<duckdb_connection %s driver=%s>\n", extptr_str(object@conn_ref), drv_to_string(object@driver)))
47:   }
48: )
49: 
50: #' @rdname DBI
51: #' @inheritParams DBI::dbIsValid
52: #' @export
53: setMethod(
54:   "dbIsValid", "duckdb_connection",
55:   function(dbObj, ...) {
56:     valid <- FALSE
57:     tryCatch(
58:       {
59:         dbGetQuery(dbObj, SQL("SELECT 1"))
60:         valid <- TRUE
61:       },
62:       error = function(c) {
63:       }
64:     )
65:     valid
66:   }
67: )
68: 
69: #' @rdname DBI
70: #' @inheritParams DBI::dbDisconnect
71: #' @export
72: setMethod(
73:   "dbDisconnect", "duckdb_connection",
74:   function(conn, ..., shutdown = FALSE) {
75:     if (!dbIsValid(conn)) {
76:       warning("Connection already closed.", call. = FALSE)
77:     }
78:     .Call(duckdb_disconnect_R, conn@conn_ref)
79:     if (shutdown) {
80:       duckdb_shutdown(conn@driver)
81:     }
82: 
83:     invisible(TRUE)
84:   }
85: )
86: 
87: #' @rdname DBI
88: #' @inheritParams DBI::dbSendQuery
89: #' @export
90: setMethod(
91:   "dbSendQuery", c("duckdb_connection", "character"),
92:   function(conn, statement, ..., immediate = FALSE) {
93:     if (conn@debug) {
94:       cat("Q ", statement, "\n")
95:     }
96:     statement <- enc2utf8(statement)
97:     stmt_lst <- .Call(duckdb_prepare_R, conn@conn_ref, statement)
98: 
99:     res <- duckdb_result(
100:       connection = conn,
101:       stmt_lst = stmt_lst
102:     )
103:     params <- list(...)
104:     if (length(params) == 1 && class(params[[1]])[[1]] == "list") {
105:       params <- params[[1]]
106:     }
107:     if (length(params) > 0) {
108:       dbBind(res, params)
109:     }
110:     return(res)
111:   }
112: )
113: 
114: 
115: #' @rdname DBI
116: #' @inheritParams DBI::dbDataType
117: #' @export
118: setMethod(
119:   "dbDataType", "duckdb_connection",
120:   function(dbObj, obj, ...) {
121:     dbDataType(dbObj@driver, obj, ...)
122:   }
123: )
124: 
125: duckdb_random_string <- function(x) {
126:   paste(sample(letters, 10, replace = TRUE), collapse = "")
127: }
128: 
129: #' @rdname DBI
130: #' @inheritParams DBI::dbWriteTable
131: #' @param overwrite Allow overwriting the destination table. Cannot be
132: #'   `TRUE` if `append` is also `TRUE`.
133: #' @param append Allow appending to the destination table. Cannot be
134: #'   `TRUE` if `overwrite` is also `TRUE`.
135: #' @export
136: setMethod(
137:   "dbWriteTable", c("duckdb_connection", "character", "data.frame"),
138:   function(conn,
139:            name,
140:            value,
141:            row.names = FALSE,
142:            overwrite = FALSE,
143:            append = FALSE,
144:            field.types = NULL,
145:            temporary = FALSE,
146:            ...) {
147:     check_flag(overwrite)
148:     check_flag(append)
149:     check_flag(temporary)
150: 
151:     # TODO: start a transaction if one is not already running
152: 
153: 
154:     if (overwrite && append) {
155:       stop("Setting both overwrite and append makes no sense")
156:     }
157: 
158:     # oof
159:     if (!is.null(field.types) &&
160:       (
161:         !is.character(field.types) ||
162:           any(is.na(names(field.types))) ||
163:           length(unique(names(field.types))) != length(names(field.types)) ||
164:           append
165:       )) {
166:       stop("invalid field.types argument")
167:     }
168:     value <- as.data.frame(value)
169:     if (!is.data.frame(value)) {
170:       stop("need a data frame as parameter")
171:     }
172: 
173:     # use Kirill's magic, convert rownames to additional column
174:     value <- sqlRownamesToColumn(value, row.names)
175: 
176:     if (dbExistsTable(conn, name)) {
177:       if (overwrite) {
178:         dbRemoveTable(conn, name)
179:       }
180:       if (!overwrite && !append) {
181:         stop(
182:           "Table ",
183:           name,
184:           " already exists. Set overwrite=TRUE if you want
185:                   to remove the existing table. Set append=TRUE if you would like to add the new data to the
186:                   existing table."
187:         )
188:       }
189:       if (append && any(names(value) != dbListFields(conn, name))) {
190:         stop("Column name mismatch for append")
191:       }
192:     }
193:     table_name <- dbQuoteIdentifier(conn, name)
194: 
195:     if (!dbExistsTable(conn, name)) {
196:       column_names <- dbQuoteIdentifier(conn, names(value))
197:       column_types <-
198:         vapply(value, dbDataType, dbObj = conn, FUN.VALUE = "character")
199: 
200:       if (!is.null(field.types)) {
201:         mapped_column_types <- field.types[names(value)]
202:         if (any(is.na(mapped_column_types)) ||
203:           length(mapped_column_types) != length(names(value))) {
204:           stop("Column name/type mismatch")
205:         }
206:         column_types <- mapped_column_types
207:       }
208: 
209:       temp_str <- ""
210:       if (temporary) temp_str <- "TEMPORARY"
211: 
212:       schema_str <- paste(column_names, column_types, collapse = ", ")
213:       dbExecute(conn, SQL(sprintf(
214:         "CREATE %s TABLE %s (%s)", temp_str, table_name, schema_str
215:       )))
216:     }
217: 
218:     if (length(value[[1]])) {
219:       classes <- unlist(lapply(value, function(v) {
220:         class(v)[[1]]
221:       }))
222:       for (c in names(classes[classes == "character"])) {
223:         value[[c]] <- enc2utf8(value[[c]])
224:       }
225:       for (c in names(classes[classes == "factor"])) {
226:         levels(value[[c]]) <- enc2utf8(levels(value[[c]]))
227:       }
228:     }
229:     view_name <- sprintf("_duckdb_append_view_%s", duckdb_random_string())
230:     on.exit(duckdb_unregister(conn, view_name))
231:     duckdb_register(conn, view_name, value)
232:     dbExecute(conn, sprintf("INSERT INTO %s SELECT * FROM %s", table_name, view_name))
233: 
234:     invisible(TRUE)
235:   }
236: )
237: 
238: #' @rdname DBI
239: #' @inheritParams DBI::dbListTables
240: #' @export
241: setMethod(
242:   "dbListTables", "duckdb_connection",
243:   function(conn, ...) {
244:     dbGetQuery(
245:       conn,
246:       SQL(
247:         "SELECT name FROM sqlite_master() WHERE type='table' ORDER BY name"
248:       )
249:     )[[1]]
250:   }
251: )
252: 
253: #' @rdname DBI
254: #' @inheritParams DBI::dbExistsTable
255: #' @export
256: setMethod(
257:   "dbExistsTable", c("duckdb_connection", "character"),
258:   function(conn, name, ...) {
259:     if (!dbIsValid(conn)) {
260:       stop("Invalid connection")
261:     }
262:     if (length(name) != 1) {
263:       stop("Can only have a single name argument")
264:     }
265:     exists <- FALSE
266:     tryCatch(
267:       {
268:         dbGetQuery(
269:           conn,
270:           sqlInterpolate(
271:             conn,
272:             "SELECT * FROM ? WHERE FALSE",
273:             dbQuoteIdentifier(conn, name)
274:           )
275:         )
276:         exists <- TRUE
277:       },
278:       error = function(c) {
279:       }
280:     )
281:     exists
282:   }
283: )
284: 
285: #' @rdname DBI
286: #' @inheritParams DBI::dbListFields
287: #' @export
288: setMethod(
289:   "dbListFields", c("duckdb_connection", "character"),
290:   function(conn, name, ...) {
291:     names(dbGetQuery(
292:       conn,
293:       sqlInterpolate(
294:         conn,
295:         "SELECT * FROM ? WHERE FALSE",
296:         dbQuoteIdentifier(conn, name)
297:       )
298:     ))
299:   }
300: )
301: 
302: #' @rdname DBI
303: #' @inheritParams DBI::dbRemoveTable
304: #' @export
305: setMethod(
306:   "dbRemoveTable", c("duckdb_connection", "character"),
307:   function(conn, name, ...) {
308:     dbExecute(
309:       conn,
310:       sqlInterpolate(conn, "DROP TABLE ?", dbQuoteIdentifier(conn, name))
311:     )
312:     invisible(TRUE)
313:   }
314: )
315: 
316: #' @rdname DBI
317: #' @inheritParams DBI::dbGetInfo
318: #' @export
319: setMethod(
320:   "dbGetInfo", "duckdb_connection",
321:   function(dbObj, ...) {
322:     list(
323:       dbname = dbObj@dbdir,
324:       db.version = NA,
325:       username = NA,
326:       host = NA,
327:       port = NA
328:     )
329:   }
330: )
331: 
332: #' @rdname DBI
333: #' @inheritParams DBI::dbBegin
334: #' @export
335: setMethod(
336:   "dbBegin", "duckdb_connection",
337:   function(conn, ...) {
338:     dbExecute(conn, SQL("BEGIN TRANSACTION"))
339:     invisible(TRUE)
340:   }
341: )
342: 
343: #' @rdname DBI
344: #' @inheritParams DBI::dbCommit
345: #' @export
346: setMethod(
347:   "dbCommit", "duckdb_connection",
348:   function(conn, ...) {
349:     dbExecute(conn, SQL("COMMIT"))
350:     invisible(TRUE)
351:   }
352: )
353: 
354: #' @rdname DBI
355: #' @inheritParams DBI::dbRollback
356: #' @export
357: setMethod(
358:   "dbRollback", "duckdb_connection",
359:   function(conn, ...) {
360:     dbExecute(conn, SQL("ROLLBACK"))
361:     invisible(TRUE)
362:   }
363: )
364: 
365: #' @rdname DBI
366: #' @export
367: read_csv_duckdb <- duckdb.read.csv <- function(conn, files, tablename, header = TRUE, na.strings = "", nrow.check = 500,
368:                                                delim = ",", quote = "\"", col.names = NULL, lower.case.names = FALSE, sep = delim, transaction = TRUE, ...) {
369: 
370:   if (length(na.strings) > 1) stop("na.strings must be of length 1")
371:   if (!missing(sep)) delim <- sep
372: 
373:   headers <- lapply(files, utils::read.csv, sep = delim, na.strings = na.strings, quote = quote, nrows = nrow.check, header = header, ...)
374:   if (length(files) > 1) {
375:     nn <- sapply(headers, ncol)
376:     if (!all(nn == nn[1])) stop("Files have different numbers of columns")
377:     nms <- sapply(headers, names)
378:     if (!all(nms == nms[, 1])) stop("Files have different variable names")
379:     types <- sapply(headers, function(df) sapply(df, dbDataType, dbObj = conn))
380:     if (!all(types == types[, 1])) stop("Files have different variable types")
381:   }
382: 
383:   if (transaction) {
384:     dbBegin(conn)
385:     on.exit(tryCatch(dbRollback(conn), error = function(e) {}))
386:   }
387: 
388:   tablename <- dbQuoteIdentifier(conn, tablename)
389: 
390:   if (!dbExistsTable(conn, tablename)) {
391:     if (lower.case.names) names(headers[[1]]) <- tolower(names(headers[[1]]))
392:     if (!is.null(col.names)) {
393:       if (lower.case.names) {
394:         warning("Ignoring lower.case.names parameter as overriding col.names are supplied.")
395:       }
396:       col.names <- as.character(col.names)
397:       if (length(unique(col.names)) != length(names(headers[[1]]))) {
398:         stop(
399:           "You supplied ", length(unique(col.names)), " unique column names, but file has ",
400:           length(names(headers[[1]])), " columns."
401:         )
402:       }
403:       names(headers[[1]]) <- col.names
404:     }
405:     dbWriteTable(conn, tablename, headers[[1]][FALSE, , drop = FALSE])
406:   }
407: 
408:   for (i in seq_along(files)) {
409:     thefile <- dbQuoteString(conn, encodeString(normalizePath(files[i])))
410:     dbExecute(conn, sprintf("COPY %s FROM %s (DELIMITER %s, QUOTE %s, HEADER %s, NULL %s)", tablename, thefile, dbQuoteString(conn, delim), dbQuoteString(conn, quote), tolower(header), dbQuoteString(conn, na.strings[1])))
411:   }
412:   dbGetQuery(conn, paste("SELECT COUNT(*) FROM", tablename))[[1]]
413: 
414:   if (transaction) {
415:     dbCommit(conn)
416:     on.exit(NULL)
417:   }
418: }
[end of tools/rpkg/R/Connection.R]
[start of tools/rpkg/R/Driver.R]
1: #' @include duckdb.R
2: NULL
3: 
4: #' DBI methods
5: #'
6: #' Implementations of pure virtual functions defined in the `DBI` package.
7: #' @name DBI
8: NULL
9: 
10: DBDIR_MEMORY <- ":memory:"
11: 
12: #' DuckDB driver
13: #'
14: #' TBD.
15: #'
16: #' @export
17: #' @import methods DBI
18: #' @examples
19: #' \dontrun{
20: #' #' library(DBI)
21: #' duckdb::duckdb()
22: #' }
23: #'
24: duckdb <- function(dbdir = DBDIR_MEMORY, read_only = FALSE) {
25:   check_flag(read_only)
26:   new(
27:     "duckdb_driver",
28:     database_ref = .Call(duckdb_startup_R, dbdir, read_only),
29:     dbdir = dbdir,
30:     read_only = read_only
31:   )
32: }
33: 
34: #' @rdname DBI
35: #' @export
36: setClass("duckdb_driver", contains = "DBIDriver", slots = list(database_ref = "externalptr", dbdir = "character", read_only = "logical"))
37: 
38: extptr_str <- function(e, n = 5) {
39:   x <- .Call(duckdb_ptr_to_str, e)
40:   substr(x, nchar(x) - n + 1, nchar(x))
41: }
42: 
43: drv_to_string <- function(drv) {
44:   if (!is(drv, "duckdb_driver")) {
45:     stop("pass a duckdb_driver object")
46:   }
47:   sprintf("<duckdb_driver %s dbdir='%s' read_only=%s>", extptr_str(drv@database_ref), drv@dbdir, drv@read_only)
48: }
49: 
50: #' @rdname DBI
51: #' @inheritParams methods::show
52: #' @export
53: setMethod(
54:   "show", "duckdb_driver",
55:   function(object) {
56:     cat(drv_to_string(object))
57:     cat("\n")
58:   }
59: )
60: 
61: #' @rdname DBI
62: #' @inheritParams DBI::dbConnect
63: #' @export
64: setMethod(
65:   "dbConnect", "duckdb_driver",
66:   function(drv, dbdir = DBDIR_MEMORY, ..., debug = getOption("duckdb.debug", FALSE), read_only = FALSE) {
67: 
68:     check_flag(debug)
69: 
70:     missing_dbdir <- missing(dbdir)
71:     dbdir <- path.expand(as.character(dbdir))
72: 
73: 
74:     # aha, a late comer. let's make a new instance.
75:     if (!missing_dbdir && dbdir != drv@dbdir) {
76:       duckdb_shutdown(drv)
77:       drv <- duckdb(dbdir, read_only)
78:     }
79: 
80:     duckdb_connection(drv, debug = debug)
81:   }
82: )
83: 
84: #' @rdname DBI
85: #' @inheritParams DBI::dbDataType
86: #' @export
87: setMethod(
88:   "dbDataType", "duckdb_driver",
89:   function(dbObj, obj, ...) {
90: 
91:     if (is.null(obj)) stop("NULL parameter")
92:     if (is.data.frame(obj)) {
93:       return(vapply(obj, function(x) dbDataType(dbObj, x), FUN.VALUE = "character"))
94:     }
95:     #  else if (int64 && inherits(obj, "integer64")) "BIGINT"
96:     else if (inherits(obj, "Date")) {
97:       "DATE"
98:     } else if (inherits(obj, "difftime")) {
99:       "TIME"
100:     } else if (is.logical(obj)) {
101:       "BOOLEAN"
102:     } else if (is.integer(obj)) {
103:       "INTEGER"
104:     } else if (is.numeric(obj)) {
105:       "DOUBLE"
106:     } else if (inherits(obj, "POSIXt")) {
107:       "TIMESTAMP"
108:     } else if (is.list(obj) && all(vapply(obj, typeof, FUN.VALUE = "character") == "raw" || is.na(obj))) {
109:       "BLOB"
110:     } else {
111:       "STRING"
112:     }
113: 
114:   }
115: )
116: 
117: #' @rdname DBI
118: #' @inheritParams DBI::dbIsValid
119: #' @export
120: setMethod(
121:   "dbIsValid", "duckdb_driver",
122:   function(dbObj, ...) {
123:     valid <- FALSE
124:     tryCatch(
125:       {
126:         con <- dbConnect(dbObj)
127:         dbExecute(con, SQL("SELECT 1"))
128:         dbDisconnect(con)
129:         valid <- TRUE
130:       },
131:       error = function(c) {
132:       }
133:     )
134:     valid
135:   }
136: )
137: 
138: #' @rdname DBI
139: #' @inheritParams DBI::dbGetInfo
140: #' @export
141: setMethod(
142:   "dbGetInfo", "duckdb_driver",
143:   function(dbObj, ...) {
144:     list(driver.version = NA, client.version = NA)
145:   }
146: )
147: 
148: 
149: #' @rdname DBI
150: #' @export
151: duckdb_shutdown <- function(drv) {
152:   if (!is(drv, "duckdb_driver")) {
153:     stop("pass a duckdb_driver object")
154:   }
155:   if (!dbIsValid(drv)) {
156:     warning("invalid driver object, already closed?")
157:     invisible(FALSE)
158:   }
159:   .Call(duckdb_shutdown_R, drv@database_ref)
160:   invisible(TRUE)
161: }
162: 
163: is_installed <- function(pkg) {
164:   as.logical(requireNamespace(pkg, quietly = TRUE)) == TRUE
165: }
166: 
167: 
168: #' @importFrom DBI dbConnect
169: #' @importFrom dbplyr src_dbi
170: #' @export
171: src_duckdb <- function(path = ":memory:", create = FALSE, read_only = FALSE) {
172:   if (!is_installed("dbplyr")) {
173:     stop("Need package `dbplyr` installed.")
174:   }
175:   if (path != ":memory:" && !create && !file.exists(path)) {
176:     stop("`path` '", path, "' must already exist, unless `create` = TRUE")
177:   }
178:   con <- DBI::dbConnect(duckdb::duckdb(), path, read_only = read_only)
179:   dbplyr::src_dbi(con, auto_disconnect = TRUE)
180: }
[end of tools/rpkg/R/Driver.R]
[start of tools/rpkg/R/Result.R]
1: #' @include Connection.R
2: NULL
3: 
4: duckdb_result <- function(connection, stmt_lst) {
5:   env <- new.env(parent = emptyenv())
6:   env$rows_fetched <- 0
7:   env$open <- TRUE
8:   env$rows_affected <- 0
9: 
10:   res <- new("duckdb_result", connection = connection, stmt_lst = stmt_lst, env = env)
11: 
12:   if (stmt_lst$n_param == 0) {
13:     duckdb_execute(res)
14:   }
15: 
16:   return(res)
17: }
18: 
19: duckdb_execute <- function(res) {
20:   res@env$resultset <- .Call(duckdb_execute_R, res@stmt_lst$ref)
21:   attr(res@env$resultset, "row.names") <-
22:     c(NA_integer_, as.integer(-1 * length(res@env$resultset[[1]])))
23:   class(res@env$resultset) <- "data.frame"
24:   if (res@stmt_lst$type != "SELECT") {
25:     res@env$rows_affected <- as.numeric(res@env$resultset[[1]][1])
26:   }
27: }
28: 
29: #' @rdname DBI
30: #' @export
31: setClass(
32:   "duckdb_result",
33:   contains = "DBIResult",
34:   slots = list(
35:     connection = "duckdb_connection",
36:     stmt_lst = "list",
37:     env = "environment"
38:   )
39: )
40: 
41: #' @rdname DBI
42: #' @inheritParams methods::show
43: #' @export
44: setMethod(
45:   "show", "duckdb_result",
46:   function(object) {
47:     cat(sprintf("<duckdb_result %s connection=%s statement='%s'>\n", extptr_str(object@stmt_lst$ref), extptr_str(object@connection@conn_ref), object@stmt_lst$str))
48:   }
49: )
50: 
51: #' @rdname DBI
52: #' @inheritParams DBI::dbClearResult
53: #' @export
54: setMethod(
55:   "dbClearResult", "duckdb_result",
56:   function(res, ...) {
57:     if (res@env$open) {
58:       .Call(duckdb_release_R, res@stmt_lst$ref)
59:       res@env$open <- FALSE
60:     } else {
61:       warning("Result was cleared already")
62:     }
63:     return(invisible(TRUE))
64:   }
65: )
66: 
67: # as per is.integer documentation
68: is_wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - round(x)) < tol
69: 
70: fix_rownames <- function(df) {
71:   attr(df, "row.names") <- c(NA, as.integer(-nrow(df)))
72:   return(df)
73: }
74: 
75: 
76: #' @rdname DBI
77: #' @inheritParams DBI::dbFetch
78: #' @importFrom utils head
79: #' @export
80: setMethod(
81:   "dbFetch", "duckdb_result",
82:   function(res, n = -1, ...) {
83:     if (!res@env$open) {
84:       stop("result set was closed")
85:     }
86:     if (length(n) != 1) {
87:       stop("need exactly one value in n")
88:     }
89:     if (is.infinite(n)) {
90:       n <- -1
91:     }
92:     if (n < -1) {
93:       stop("cannot fetch negative n other than -1")
94:     }
95:     if (!is_wholenumber(n)) {
96:       stop("n needs to be not a whole number")
97:     }
98:     if (res@stmt_lst$type != "SELECT") {
99:       warning("Should not call dbFetch() on results that do not come from SELECT")
100:       return(data.frame())
101:     }
102: 
103:     # FIXME this is ugly
104:     if (n == 0) {
105:       return(utils::head(res@env$resultset, 0))
106:     }
107:     if (res@env$rows_fetched < 0) {
108:       res@env$rows_fetched <- 0
109:     }
110:     if (res@env$rows_fetched >= nrow(res@env$resultset)) {
111:       return(fix_rownames(res@env$resultset[F, , drop = F]))
112:     }
113:     # special case, return everything
114:     if (n == -1 && res@env$rows_fetched == 0) {
115:       res@env$rows_fetched <- nrow(res@env$resultset)
116:       return(res@env$resultset)
117:     }
118:     if (n > -1) {
119:       n <- min(n, nrow(res@env$resultset) - res@env$rows_fetched)
120:       res@env$rows_fetched <- res@env$rows_fetched + n
121:       df <- res@env$resultset[(res@env$rows_fetched - n + 1):(res@env$rows_fetched), , drop = F]
122:       return(fix_rownames(df))
123:     }
124:     start <- res@env$rows_fetched + 1
125:     res@env$rows_fetched <- nrow(res@env$resultset)
126:     df <- res@env$resultset[nrow(res@env$resultset), , drop = F]
127:     return(fix_rownames(df))
128:   }
129: )
130: 
131: #' @rdname DBI
132: #' @inheritParams DBI::dbHasCompleted
133: #' @export
134: setMethod(
135:   "dbHasCompleted", "duckdb_result",
136:   function(res, ...) {
137:     if (!res@env$open) {
138:       stop("result has already been cleared")
139:     }
140:     if (res@stmt_lst$type != "SELECT") {
141:       return(TRUE)
142:     }
143:     return(res@env$rows_fetched == nrow(res@env$resultset))
144:   }
145: )
146: 
147: #' @rdname DBI
148: #' @inheritParams DBI::dbGetInfo
149: #' @export
150: setMethod(
151:   "dbGetInfo", "duckdb_result",
152:   function(dbObj, ...) {
153:     # Optional
154:     getMethod("dbGetInfo", "DBIResult", asNamespace("DBI"))(dbObj, ...)
155:   }
156: )
157: 
158: #' @rdname DBI
159: #' @inheritParams DBI::dbIsValid
160: #' @export
161: setMethod(
162:   "dbIsValid", "duckdb_result",
163:   function(dbObj, ...) {
164:     return(dbObj@env$open)
165:   }
166: )
167: 
168: #' @rdname DBI
169: #' @inheritParams DBI::dbGetStatement
170: #' @export
171: setMethod(
172:   "dbGetStatement", "duckdb_result",
173:   function(res, ...) {
174:     if (!res@env$open) {
175:       stop("result has already been cleared")
176:     }
177:     return(res@stmt_lst$str)
178:   }
179: )
180: 
181: #' @rdname DBI
182: #' @inheritParams DBI::dbColumnInfo
183: #' @export
184: setMethod(
185:   "dbColumnInfo", "duckdb_result",
186:   function(res, ...) {
187:     return(data.frame(name = res@stmt_lst$names, type = res@stmt_lst$rtypes, stringsAsFactors = FALSE))
188: 
189:   }
190: )
191: 
192: #' @rdname DBI
193: #' @inheritParams DBI::dbGetRowCount
194: #' @export
195: setMethod(
196:   "dbGetRowCount", "duckdb_result",
197:   function(res, ...) {
198:     if (!res@env$open) {
199:       stop("result has already been cleared")
200:     }
201:     return(res@env$rows_fetched)
202:   }
203: )
204: 
205: #' @rdname DBI
206: #' @inheritParams DBI::dbGetRowsAffected
207: #' @export
208: setMethod(
209:   "dbGetRowsAffected", "duckdb_result",
210:   function(res, ...) {
211:     if (!res@env$open) {
212:       stop("result has already been cleared")
213:     }
214:     return(res@env$rows_affected)
215:   }
216: )
217: 
218: #' @rdname DBI
219: #' @inheritParams DBI::dbBind
220: #' @importFrom testthat skip
221: #' @export
222: setMethod(
223:   "dbBind", "duckdb_result",
224:   function(res, params, ...) {
225:     if (!res@env$open) {
226:       stop("result has already been cleared")
227:     }
228:     res@env$rows_fetched <- 0
229:     res@env$resultset <- data.frame()
230: 
231:     invisible(.Call(duckdb_bind_R, res@stmt_lst$ref, params))
232:     duckdb_execute(res)
233:   }
234: )
[end of tools/rpkg/R/Result.R]
[start of tools/rpkg/R/duckdb-package.R]
1: ## usethis namespace: start
2: #' @useDynLib duckdb, .registration = TRUE
3: ## usethis namespace: end
4: NULL
[end of tools/rpkg/R/duckdb-package.R]
[start of tools/rpkg/R/duckdb.R]
1: #' @details TBD.
2: "_PACKAGE"
3: 
4: check_flag <- function(x) {
5:   if (is.null(x) || length(x) != 1 || is.na(x) || !is.logical(x)) {
6:     stop("flags need to be scalar logicals")
7:   }
8: }
9: 
[end of tools/rpkg/R/duckdb.R]
[start of tools/rpkg/configure]
1: #!/bin/sh
2: 
3: if [ ! -f "../../scripts/amalgamation.py" ]; then
4: 	echo "Could find neither the amalgamation build script"
5: 	exit 1
6: fi
7: (cd ../.. && python scripts/amalgamation.py --source=tools/rpkg/src/duckdb.cpp --header=tools/rpkg/src/duckdb.hpp)
8: (cd ../.. && python extension/parquet/parquet_amalgamation.py --source=tools/rpkg/src/parquet-extension.cpp --header=tools/rpkg/src/parquet-extension.hpp)
[end of tools/rpkg/configure]
[start of tools/rpkg/man/DBI.Rd]
1: % Generated by roxygen2: do not edit by hand
2: % Please edit documentation in R/Driver.R, R/Connection.R, R/Result.R
3: \docType{class}
4: \name{DBI}
5: \alias{DBI}
6: \alias{duckdb_driver-class}
7: \alias{show,duckdb_driver-method}
8: \alias{dbConnect,duckdb_driver-method}
9: \alias{dbDataType,duckdb_driver-method}
10: \alias{dbIsValid,duckdb_driver-method}
11: \alias{dbGetInfo,duckdb_driver-method}
12: \alias{duckdb_shutdown}
13: \alias{duckdb_register}
14: \alias{duckdb_unregister}
15: \alias{duckdb_connection-class}
16: \alias{show,duckdb_connection-method}
17: \alias{dbIsValid,duckdb_connection-method}
18: \alias{dbDisconnect,duckdb_connection-method}
19: \alias{dbSendQuery,duckdb_connection,character-method}
20: \alias{dbDataType,duckdb_connection-method}
21: \alias{dbWriteTable,duckdb_connection,character,data.frame-method}
22: \alias{dbListTables,duckdb_connection-method}
23: \alias{dbExistsTable,duckdb_connection,character-method}
24: \alias{dbListFields,duckdb_connection,character-method}
25: \alias{dbRemoveTable,duckdb_connection,character-method}
26: \alias{dbGetInfo,duckdb_connection-method}
27: \alias{dbBegin,duckdb_connection-method}
28: \alias{dbCommit,duckdb_connection-method}
29: \alias{dbRollback,duckdb_connection-method}
30: \alias{read_csv_duckdb}
31: \alias{duckdb_result-class}
32: \alias{show,duckdb_result-method}
33: \alias{dbClearResult,duckdb_result-method}
34: \alias{dbFetch,duckdb_result-method}
35: \alias{dbHasCompleted,duckdb_result-method}
36: \alias{dbGetInfo,duckdb_result-method}
37: \alias{dbIsValid,duckdb_result-method}
38: \alias{dbGetStatement,duckdb_result-method}
39: \alias{dbColumnInfo,duckdb_result-method}
40: \alias{dbGetRowCount,duckdb_result-method}
41: \alias{dbGetRowsAffected,duckdb_result-method}
42: \alias{dbBind,duckdb_result-method}
43: \title{DBI methods}
44: \usage{
45: \S4method{show}{duckdb_driver}(object)
46: 
47: \S4method{dbConnect}{duckdb_driver}(
48:   drv,
49:   dbdir = DBDIR_MEMORY,
50:   ...,
51:   debug = getOption("duckdb.debug", FALSE),
52:   read_only = FALSE
53: )
54: 
55: \S4method{dbDataType}{duckdb_driver}(dbObj, obj, ...)
56: 
57: \S4method{dbIsValid}{duckdb_driver}(dbObj, ...)
58: 
59: \S4method{dbGetInfo}{duckdb_driver}(dbObj, ...)
60: 
61: duckdb_shutdown(drv)
62: 
63: duckdb_register(conn, name, df)
64: 
65: duckdb_unregister(conn, name)
66: 
67: \S4method{show}{duckdb_connection}(object)
68: 
69: \S4method{dbIsValid}{duckdb_connection}(dbObj, ...)
70: 
71: \S4method{dbDisconnect}{duckdb_connection}(conn, ..., shutdown = FALSE)
72: 
73: \S4method{dbSendQuery}{duckdb_connection,character}(conn, statement, ..., immediate = FALSE)
74: 
75: \S4method{dbDataType}{duckdb_connection}(dbObj, obj, ...)
76: 
77: \S4method{dbWriteTable}{duckdb_connection,character,data.frame}(
78:   conn,
79:   name,
80:   value,
81:   row.names = FALSE,
82:   overwrite = FALSE,
83:   append = FALSE,
84:   field.types = NULL,
85:   temporary = FALSE,
86:   ...
87: )
88: 
89: \S4method{dbListTables}{duckdb_connection}(conn, ...)
90: 
91: \S4method{dbExistsTable}{duckdb_connection,character}(conn, name, ...)
92: 
93: \S4method{dbListFields}{duckdb_connection,character}(conn, name, ...)
94: 
95: \S4method{dbRemoveTable}{duckdb_connection,character}(conn, name, ...)
96: 
97: \S4method{dbGetInfo}{duckdb_connection}(dbObj, ...)
98: 
99: \S4method{dbBegin}{duckdb_connection}(conn, ...)
100: 
101: \S4method{dbCommit}{duckdb_connection}(conn, ...)
102: 
103: \S4method{dbRollback}{duckdb_connection}(conn, ...)
104: 
105: read_csv_duckdb(
106:   conn,
107:   files,
108:   tablename,
109:   header = TRUE,
110:   na.strings = "",
111:   nrow.check = 500,
112:   delim = ",",
113:   quote = "\\"",
114:   col.names = NULL,
115:   lower.case.names = FALSE,
116:   sep = delim,
117:   transaction = TRUE,
118:   ...
119: )
120: 
121: \S4method{show}{duckdb_result}(object)
122: 
123: \S4method{dbClearResult}{duckdb_result}(res, ...)
124: 
125: \S4method{dbFetch}{duckdb_result}(res, n = -1, ...)
126: 
127: \S4method{dbHasCompleted}{duckdb_result}(res, ...)
128: 
129: \S4method{dbGetInfo}{duckdb_result}(dbObj, ...)
130: 
131: \S4method{dbIsValid}{duckdb_result}(dbObj, ...)
132: 
133: \S4method{dbGetStatement}{duckdb_result}(res, ...)
134: 
135: \S4method{dbColumnInfo}{duckdb_result}(res, ...)
136: 
137: \S4method{dbGetRowCount}{duckdb_result}(res, ...)
138: 
139: \S4method{dbGetRowsAffected}{duckdb_result}(res, ...)
140: 
141: \S4method{dbBind}{duckdb_result}(res, params, ...)
142: }
143: \arguments{
144: \item{object}{Any R object}
145: 
146: \item{drv}{an object that inherits from \linkS4class{DBIDriver},
147: or an existing \linkS4class{DBIConnection}
148: object (in order to clone an existing connection).}
149: 
150: \item{...}{authentication arguments needed by the DBMS instance; these
151: typically include \code{user}, \code{password}, \code{host}, \code{port}, \code{dbname}, etc.
152: For details see the appropriate \code{DBIDriver}.}
153: 
154: \item{dbObj}{A object inheriting from \linkS4class{DBIDriver}
155: or \linkS4class{DBIConnection}}
156: 
157: \item{obj}{An R object whose SQL type we want to determine.}
158: 
159: \item{conn}{A \linkS4class{DBIConnection} object, as returned by
160: \code{\link[DBI:dbConnect]{dbConnect()}}.}
161: 
162: \item{name}{A character string specifying the unquoted DBMS table name,
163: or the result of a call to \code{\link[DBI:dbQuoteIdentifier]{dbQuoteIdentifier()}}.}
164: 
165: \item{statement}{a character string containing SQL.}
166: 
167: \item{value}{a \link{data.frame} (or coercible to data.frame).}
168: 
169: \item{overwrite}{Allow overwriting the destination table. Cannot be
170: `TRUE` if `append` is also `TRUE`.}
171: 
172: \item{append}{Allow appending to the destination table. Cannot be
173: `TRUE` if `overwrite` is also `TRUE`.}
174: 
175: \item{res}{An object inheriting from \linkS4class{DBIResult}.}
176: 
177: \item{n}{maximum number of records to retrieve per fetch. Use \code{n = -1}
178: or \code{n = Inf}
179: to retrieve all pending records.  Some implementations may recognize other
180: special values.}
181: 
182: \item{params}{A list of bindings, named or unnamed.}
183: }
184: \description{
185: Implementations of pure virtual functions defined in the `DBI` package.
186: }
[end of tools/rpkg/man/DBI.Rd]
[start of tools/rpkg/man/duckdb-package.Rd]
1: % Generated by roxygen2: do not edit by hand
2: % Please edit documentation in R/duckdb.R
3: \docType{package}
4: \name{duckdb-package}
5: \alias{duckdb}
6: \alias{duckdb-package}
7: \title{duckdb: DBI Package for the DuckDB Database Management System}
8: \description{
9: DuckDB is an embedded analytical data management
10:     system with SQL support. This package includes all of DuckDB as well
11:     as R DBI & dplyr connectors.
12: }
13: \details{
14: TBD.
15: }
16: \seealso{
17: Useful links:
18: \itemize{
19:   \item \url{https://www.duckdb.org}
20:   \item \url{https://github.com/cwida/duckdb}
21:   \item Report bugs at \url{https://github.com/cwida/duckdb/issues}
22: }
23: 
24: }
25: \author{
26: \strong{Maintainer}: Hannes MÃ¼hleisen \email{hannes@cwi.nl} (\href{https://orcid.org/0000-0001-8552-0029}{ORCID})
27: 
28: Authors:
29: \itemize{
30:   \item Mark Raasveldt \email{mark.raasveldt@cwi.nl} (\href{https://orcid.org/0000-0001-5005-6844}{ORCID})
31:   \item DuckDB Contributors
32: }
33: 
34: }
[end of tools/rpkg/man/duckdb-package.Rd]
[start of tools/rpkg/man/duckdb.Rd]
1: % Generated by roxygen2: do not edit by hand
2: % Please edit documentation in R/Driver.R
3: \name{duckdb}
4: \alias{duckdb}
5: \title{DuckDB driver}
6: \usage{
7: duckdb(dbdir = DBDIR_MEMORY, read_only = FALSE)
8: }
9: \description{
10: TBD.
11: }
12: \examples{
13: \dontrun{
14: #' library(DBI)
15: duckdb::duckdb()
16: }
17: 
18: }
[end of tools/rpkg/man/duckdb.Rd]
[start of tools/rpkg/src/duckdbr.cpp]
1: #include "duckdb.hpp"
2: #include "parquet-extension.hpp"
3: 
4: #include <Rdefines.h>
5: #include <algorithm>
6: 
7: // motherfucker
8: #undef error
9: 
10: using namespace duckdb;
11: using namespace std;
12: 
13: struct RStatement {
14: 	unique_ptr<PreparedStatement> stmt;
15: 	vector<Value> parameters;
16: };
17: 
18: // converter for primitive types
19: template <class SRC, class DEST>
20: static void vector_to_r(Vector &src_vec, size_t count, void *dest, uint64_t dest_offset, DEST na_val) {
21: 	auto src_ptr = FlatVector::GetData<SRC>(src_vec);
22: 	auto &nullmask = FlatVector::Nullmask(src_vec);
23: 	auto dest_ptr = ((DEST *)dest) + dest_offset;
24: 	for (size_t row_idx = 0; row_idx < count; row_idx++) {
25: 		dest_ptr[row_idx] = nullmask[row_idx] ? na_val : src_ptr[row_idx];
26: 	}
27: }
28: 
29: struct RDoubleType {
30: 	static bool IsNull(double val) {
31: 		return ISNA(val);
32: 	}
33: 
34: 	static double Convert(double val) {
35: 		return val;
36: 	}
37: };
38: 
39: struct RDateType {
40: 	static bool IsNull(double val) {
41: 		return RDoubleType::IsNull(val);
42: 	}
43: 
44: 	static double Convert(double val) {
45: 		return (date_t)val + 719528; // MAGIC!
46: 	}
47: };
48: 
49: struct RTimestampType {
50: 	static bool IsNull(double val) {
51: 		return RDoubleType::IsNull(val);
52: 	}
53: 
54: 	static timestamp_t Convert(double val) {
55: 		date_t date = Date::EpochToDate((int64_t)val);
56: 		dtime_t time = (dtime_t)(((int64_t)val % (60 * 60 * 24)) * 1000);
57: 		return Timestamp::FromDatetime(date, time);
58: 	}
59: };
60: 
61: struct RIntegerType {
62: 	static bool IsNull(int val) {
63: 		return val == NA_INTEGER;
64: 	}
65: 
66: 	static int Convert(int val) {
67: 		return val;
68: 	}
69: };
70: 
71: struct RBooleanType {
72: 	static bool IsNull(int val) {
73: 		return RIntegerType::IsNull(val);
74: 	}
75: 
76: 	static bool Convert(int val) {
77: 		return val;
78: 	}
79: };
80: 
81: template <class SRC, class DST, class RTYPE>
82: static void AppendColumnSegment(SRC *source_data, Vector &result, idx_t count) {
83: 	auto result_data = FlatVector::GetData<DST>(result);
84: 	auto &result_mask = FlatVector::Nullmask(result);
85: 	for (idx_t i = 0; i < count; i++) {
86: 		auto val = source_data[i];
87: 		if (RTYPE::IsNull(val)) {
88: 			result_mask[i] = true;
89: 		} else {
90: 			result_data[i] = RTYPE::Convert(val);
91: 		}
92: 	}
93: }
94: 
95: static void AppendStringSegment(SEXP coldata, Vector &result, idx_t row_idx, idx_t count) {
96: 	auto result_data = FlatVector::GetData<string_t>(result);
97: 	auto &result_mask = FlatVector::Nullmask(result);
98: 	for (idx_t i = 0; i < count; i++) {
99: 		SEXP val = STRING_ELT(coldata, row_idx + i);
100: 		if (val == NA_STRING) {
101: 			result_mask[i] = true;
102: 		} else {
103: 			result_data[i] = string_t((char *)CHAR(val));
104: 		}
105: 	}
106: }
107: 
108: static void AppendFactor(SEXP coldata, Vector &result, idx_t row_idx, idx_t count) {
109: 	auto source_data = INTEGER_POINTER(coldata) + row_idx;
110: 	auto result_data = FlatVector::GetData<string_t>(result);
111: 	auto &result_mask = FlatVector::Nullmask(result);
112: 	SEXP factor_levels = GET_LEVELS(coldata);
113: 	for (idx_t i = 0; i < count; i++) {
114: 		int val = source_data[i];
115: 		if (RIntegerType::IsNull(val)) {
116: 			result_mask[i] = true;
117: 		} else {
118: 			result_data[i] = string_t(CHAR(STRING_ELT(factor_levels, val - 1)));
119: 		}
120: 	}
121: }
122: 
123: static SEXP cstr_to_charsexp(const char *s) {
124: 	SEXP retsexp = PROTECT(mkCharCE(s, CE_UTF8));
125: 	if (!retsexp) {
126: 		Rf_error("cpp_str_to_charsexp: Memory allocation failed");
127: 		UNPROTECT(1);
128: 	}
129: 	return retsexp;
130: }
131: 
132: static SEXP cpp_str_to_charsexp(string s) {
133: 	return cstr_to_charsexp(s.c_str());
134: }
135: 
136: static SEXP cpp_str_to_strsexp(vector<string> s) {
137: 	SEXP retsexp = PROTECT(NEW_STRING(s.size()));
138: 	if (!retsexp) {
139: 		Rf_error("cpp_str_to_strsexp: Memory allocation failed");
140: 		UNPROTECT(1);
141: 	}
142: 	for (idx_t i = 0; i < s.size(); i++) {
143: 		SET_STRING_ELT(retsexp, i, cpp_str_to_charsexp(s[i]));
144: 		UNPROTECT(1);
145: 	}
146: 	return retsexp;
147: }
148: 
149: enum class RType { UNKNOWN, LOGICAL, INTEGER, NUMERIC, STRING, FACTOR, DATE, TIMESTAMP };
150: 
151: static RType detect_rtype(SEXP v) {
152: 	if (TYPEOF(v) == REALSXP && TYPEOF(GET_CLASS(v)) == STRSXP &&
153: 	    strcmp("POSIXct", CHAR(STRING_ELT(GET_CLASS(v), 0))) == 0) {
154: 		return RType::TIMESTAMP;
155: 	} else if (TYPEOF(v) == REALSXP && TYPEOF(GET_CLASS(v)) == STRSXP &&
156: 	           strcmp("Date", CHAR(STRING_ELT(GET_CLASS(v), 0))) == 0) {
157: 		return RType::DATE;
158: 	} else if (isFactor(v) && TYPEOF(v) == INTSXP) {
159: 		return RType::FACTOR;
160: 	} else if (TYPEOF(v) == LGLSXP) {
161: 		return RType::LOGICAL;
162: 	} else if (TYPEOF(v) == INTSXP) {
163: 		return RType::INTEGER;
164: 	} else if (TYPEOF(v) == REALSXP) {
165: 		return RType::NUMERIC;
166: 	} else if (TYPEOF(v) == STRSXP) {
167: 		return RType::STRING;
168: 	}
169: 	return RType::UNKNOWN;
170: }
171: 
172: extern "C" {
173: 
174: SEXP duckdb_release_R(SEXP stmtsexp) {
175: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
176: 		Rf_error("duckdb_release_R: Need external pointer parameter");
177: 	}
178: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
179: 	if (stmtsexp) {
180: 		R_ClearExternalPtr(stmtsexp);
181: 		delete stmtholder;
182: 	}
183: 	return R_NilValue;
184: }
185: 
186: SEXP duckdb_finalize_statement_R(SEXP stmtsexp) {
187: 	return duckdb_release_R(stmtsexp);
188: }
189: 
190: SEXP duckdb_prepare_R(SEXP connsexp, SEXP querysexp) {
191: 	if (TYPEOF(querysexp) != STRSXP || LENGTH(querysexp) != 1) {
192: 		Rf_error("duckdb_prepare_R: Need single string parameter for query");
193: 	}
194: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
195: 		Rf_error("duckdb_prepare_R: Need external pointer parameter for connections");
196: 	}
197: 
198: 	char *query = (char *)CHAR(STRING_ELT(querysexp, 0));
199: 	if (!query) {
200: 		Rf_error("duckdb_prepare_R: No query");
201: 	}
202: 
203: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
204: 	if (!conn) {
205: 		Rf_error("duckdb_prepare_R: Invalid connection");
206: 	}
207: 
208: 	auto stmt = conn->Prepare(query);
209: 	if (!stmt->success) {
210: 		Rf_error("duckdb_prepare_R: Failed to prepare query %s\nError: %s", query, stmt->error.c_str());
211: 	}
212: 
213: 	auto stmtholder = new RStatement();
214: 	stmtholder->stmt = move(stmt);
215: 
216: 	SEXP stmtsexp = PROTECT(R_MakeExternalPtr(stmtholder, R_NilValue, R_NilValue));
217: 	R_RegisterCFinalizer(stmtsexp, (void (*)(SEXP))duckdb_finalize_statement_R);
218: 
219: 	SEXP retlist = PROTECT(NEW_LIST(6));
220: 	if (!retlist) {
221: 		UNPROTECT(2); // retlist, stmtsexp
222: 		Rf_error("duckdb_prepare_R: Memory allocation failed");
223: 	}
224: 	SEXP ret_names = cpp_str_to_strsexp({"str", "ref", "type", "names", "rtypes", "n_param"});
225: 	SET_NAMES(retlist, ret_names);
226: 	UNPROTECT(1); // ret_names
227: 
228: 	SET_VECTOR_ELT(retlist, 0, querysexp);
229: 	SET_VECTOR_ELT(retlist, 1, stmtsexp);
230: 	UNPROTECT(1); // stmtsxp
231: 
232: 	SEXP stmt_type = cpp_str_to_strsexp({StatementTypeToString(stmtholder->stmt->type)});
233: 	SET_VECTOR_ELT(retlist, 2, stmt_type);
234: 	UNPROTECT(1); // stmt_type
235: 
236: 	SEXP col_names = cpp_str_to_strsexp(stmtholder->stmt->names);
237: 	SET_VECTOR_ELT(retlist, 3, col_names);
238: 	UNPROTECT(1); // col_names
239: 
240: 	vector<string> rtypes;
241: 
242: 	for (auto &stype : stmtholder->stmt->types) {
243: 		string rtype = "";
244: 		switch (stype.id) {
245: 		case SQLTypeId::BOOLEAN:
246: 			rtype = "logical";
247: 			break;
248: 		case SQLTypeId::TINYINT:
249: 		case SQLTypeId::SMALLINT:
250: 		case SQLTypeId::INTEGER:
251: 			rtype = "integer";
252: 			break;
253: 		case SQLTypeId::TIMESTAMP:
254: 			rtype = "POSIXct";
255: 			break;
256: 		case SQLTypeId::DATE:
257: 			rtype = "Date";
258: 			break;
259: 		case SQLTypeId::TIME:
260: 			rtype = "difftime";
261: 			break;
262: 		case SQLTypeId::BIGINT:
263: 		case SQLTypeId::FLOAT:
264: 		case SQLTypeId::DOUBLE:
265: 			rtype = "numeric";
266: 			break;
267: 		case SQLTypeId::VARCHAR: {
268: 			rtype = "character";
269: 			break;
270: 		}
271: 		default:
272: 			UNPROTECT(1); // retlist
273: 			Rf_error("duckdb_prepare_R: Unknown column type %s", SQLTypeToString(stype).c_str());
274: 			break;
275: 		}
276: 		rtypes.push_back(rtype);
277: 	}
278: 
279: 	SEXP rtypessexp = cpp_str_to_strsexp(rtypes);
280: 	SET_VECTOR_ELT(retlist, 4, rtypessexp);
281: 	UNPROTECT(1); // rtypessexp
282: 
283: 	SET_VECTOR_ELT(retlist, 5, ScalarInteger(stmtholder->stmt->n_param));
284: 
285: 	UNPROTECT(1); // retlist
286: 	return retlist;
287: }
288: 
289: SEXP duckdb_bind_R(SEXP stmtsexp, SEXP paramsexp) {
290: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
291: 		Rf_error("duckdb_bind_R: Need external pointer parameter");
292: 	}
293: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
294: 	if (!stmtholder || !stmtholder->stmt) {
295: 		Rf_error("duckdb_bind_R: Invalid statement");
296: 	}
297: 
298: 	stmtholder->parameters.clear();
299: 	stmtholder->parameters.resize(stmtholder->stmt->n_param);
300: 
301: 	if (stmtholder->stmt->n_param == 0) {
302: 		Rf_error("duckdb_bind_R: dbBind called but query takes no parameters");
303: 		return R_NilValue;
304: 	}
305: 
306: 	if (TYPEOF(paramsexp) != VECSXP || LENGTH(paramsexp) != stmtholder->stmt->n_param) {
307: 		Rf_error("duckdb_bind_R: bind parameters need to be a list of length %i", stmtholder->stmt->n_param);
308: 	}
309: 
310: 	for (idx_t param_idx = 0; param_idx < LENGTH(paramsexp); param_idx++) {
311: 		Value val;
312: 		SEXP valsexp = VECTOR_ELT(paramsexp, param_idx);
313: 		if (LENGTH(valsexp) != 1) {
314: 			Rf_error("duckdb_bind_R: bind parameter values need to have length 1");
315: 		}
316: 		auto rtype = detect_rtype(valsexp);
317: 		switch (rtype) {
318: 		case RType::LOGICAL: {
319: 			auto lgl_val = INTEGER_POINTER(valsexp)[0];
320: 			val = Value::BOOLEAN(lgl_val);
321: 			val.is_null = RBooleanType::IsNull(lgl_val);
322: 			break;
323: 		}
324: 		case RType::INTEGER: {
325: 			auto int_val = INTEGER_POINTER(valsexp)[0];
326: 			val = Value::INTEGER(int_val);
327: 			val.is_null = RIntegerType::IsNull(int_val);
328: 			break;
329: 		}
330: 		case RType::NUMERIC: {
331: 			auto dbl_val = NUMERIC_POINTER(valsexp)[0];
332: 			val = Value::DOUBLE(dbl_val);
333: 			val.is_null = RDoubleType::IsNull(dbl_val);
334: 			break;
335: 		}
336: 		case RType::STRING: {
337: 			auto str_val = STRING_ELT(valsexp, 0);
338: 			val = Value(CHAR(str_val));
339: 			val.is_null = str_val == NA_STRING;
340: 			break;
341: 		}
342: 		case RType::FACTOR: {
343: 			auto int_val = INTEGER_POINTER(valsexp)[0];
344: 			auto levels = GET_LEVELS(valsexp);
345: 			val.type = TypeId::VARCHAR;
346: 			val.is_null = RIntegerType::IsNull(int_val);
347: 			if (!val.is_null) {
348: 				auto str_val = STRING_ELT(levels, int_val - 1);
349: 				val.str_value = string(CHAR(str_val));
350: 			}
351: 			break;
352: 		}
353: 		case RType::TIMESTAMP: {
354: 			auto ts_val = NUMERIC_POINTER(valsexp)[0];
355: 			val = Value::TIMESTAMP(RTimestampType::Convert(ts_val));
356: 			val.is_null = RTimestampType::IsNull(ts_val);
357: 			break;
358: 		}
359: 		case RType::DATE: {
360: 			auto d_val = NUMERIC_POINTER(valsexp)[0];
361: 			val = Value::DATE(RDateType::Convert(d_val));
362: 			val.is_null = RDateType::IsNull(d_val);
363: 			break;
364: 		}
365: 		default:
366: 			Rf_error("duckdb_bind_R: Unsupported parameter type");
367: 		}
368: 		stmtholder->parameters[param_idx] = val;
369: 	}
370: 	return R_NilValue;
371: }
372: 
373: SEXP duckdb_execute_R(SEXP stmtsexp) {
374: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
375: 		Rf_error("duckdb_execute_R: Need external pointer parameter");
376: 	}
377: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
378: 	if (!stmtholder || !stmtholder->stmt) {
379: 		Rf_error("duckdb_execute_R: Invalid statement");
380: 	}
381: 
382: 	auto generic_result = stmtholder->stmt->Execute(stmtholder->parameters, false);
383: 
384: 	if (!generic_result->success) {
385: 		Rf_error("duckdb_execute_R: Failed to run query\nError: %s", generic_result->error.c_str());
386: 	}
387: 	assert(generic_result->type == QueryResultType::MATERIALIZED_RESULT);
388: 	MaterializedQueryResult *result = (MaterializedQueryResult *)generic_result.get();
389: 
390: 	// step 2: create result data frame and allocate columns
391: 	uint32_t ncols = result->types.size();
392: 	uint64_t nrows = result->collection.count;
393: 
394: 	if (ncols > 0) {
395: 		SEXP retlist = PROTECT(NEW_LIST(ncols));
396: 		if (!retlist) {
397: 			UNPROTECT(1); // retlist
398: 			Rf_error("duckdb_execute_R: Memory allocation failed");
399: 		}
400: 		SET_NAMES(retlist, cpp_str_to_strsexp(result->names));
401: 		UNPROTECT(1); // names
402: 
403: 		for (size_t col_idx = 0; col_idx < ncols; col_idx++) {
404: 			SEXP varvalue = NULL;
405: 			switch (result->sql_types[col_idx].id) {
406: 			case SQLTypeId::BOOLEAN:
407: 				varvalue = PROTECT(NEW_LOGICAL(nrows));
408: 				break;
409: 			case SQLTypeId::TINYINT:
410: 			case SQLTypeId::SMALLINT:
411: 			case SQLTypeId::INTEGER:
412: 				varvalue = PROTECT(NEW_INTEGER(nrows));
413: 				break;
414: 			case SQLTypeId::BIGINT:
415: 			case SQLTypeId::FLOAT:
416: 			case SQLTypeId::DOUBLE:
417: 			case SQLTypeId::DECIMAL:
418: 			case SQLTypeId::TIMESTAMP:
419: 			case SQLTypeId::DATE:
420: 			case SQLTypeId::TIME:
421: 				varvalue = PROTECT(NEW_NUMERIC(nrows));
422: 				break;
423: 			case SQLTypeId::VARCHAR:
424: 				varvalue = PROTECT(NEW_STRING(nrows));
425: 				break;
426: 			default:
427: 				UNPROTECT(1); // retlist
428: 				Rf_error("duckdb_execute_R: Unknown column type %s/%s",
429: 				         SQLTypeToString(result->sql_types[col_idx]).c_str(),
430: 				         TypeIdToString(result->types[col_idx]).c_str());
431: 			}
432: 			if (!varvalue) {
433: 				UNPROTECT(2); // varvalue, retlist
434: 				Rf_error("duckdb_execute_R: Memory allocation failed");
435: 			}
436: 			SET_VECTOR_ELT(retlist, col_idx, varvalue);
437: 			UNPROTECT(1); /* varvalue */
438: 		}
439: 
440: 		// at this point retlist is fully allocated and the only protected SEXP
441: 
442: 		// step 3: set values from chunks
443: 		uint64_t dest_offset = 0;
444: 		while (true) {
445: 			auto chunk = result->Fetch();
446: 			if (chunk->size() == 0) {
447: 				break;
448: 			}
449: 			assert(chunk->column_count() == ncols);
450: 			assert(chunk->column_count() == LENGTH(retlist));
451: 			for (size_t col_idx = 0; col_idx < chunk->column_count(); col_idx++) {
452: 				SEXP dest = VECTOR_ELT(retlist, col_idx);
453: 				switch (result->sql_types[col_idx].id) {
454: 				case SQLTypeId::BOOLEAN:
455: 					vector_to_r<int8_t, uint32_t>(chunk->data[col_idx], chunk->size(), LOGICAL_POINTER(dest),
456: 					                              dest_offset, NA_LOGICAL);
457: 					break;
458: 				case SQLTypeId::TINYINT:
459: 					vector_to_r<int8_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest),
460: 					                              dest_offset, NA_INTEGER);
461: 					break;
462: 				case SQLTypeId::SMALLINT:
463: 					vector_to_r<int16_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest),
464: 					                               dest_offset, NA_INTEGER);
465: 					break;
466: 				case SQLTypeId::INTEGER:
467: 					vector_to_r<int32_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest),
468: 					                               dest_offset, NA_INTEGER);
469: 					break;
470: 				case SQLTypeId::TIMESTAMP: {
471: 					auto &src_vec = chunk->data[col_idx];
472: 					auto src_data = FlatVector::GetData<int64_t>(src_vec);
473: 					auto &nullmask = FlatVector::Nullmask(src_vec);
474: 					double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
475: 					for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
476: 						dest_ptr[row_idx] =
477: 						    nullmask[row_idx] ? NA_REAL : (double)Timestamp::GetEpoch(src_data[row_idx]);
478: 					}
479: 
480: 					// some dresssup for R
481: 					SEXP cl = PROTECT(NEW_STRING(2));
482: 					SET_STRING_ELT(cl, 0, PROTECT(mkChar("POSIXct")));
483: 					SET_STRING_ELT(cl, 1, PROTECT(mkChar("POSIXt")));
484: 					SET_CLASS(dest, cl);
485: 					setAttrib(dest, install("tzone"), PROTECT(mkString("UTC")));
486: 					UNPROTECT(4);
487: 					break;
488: 				}
489: 				case SQLTypeId::DATE: {
490: 					auto &src_vec = chunk->data[col_idx];
491: 					auto src_data = FlatVector::GetData<int32_t>(src_vec);
492: 					auto &nullmask = FlatVector::Nullmask(src_vec);
493: 					double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
494: 					for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
495: 						dest_ptr[row_idx] = nullmask[row_idx] ? NA_REAL : (double)(src_data[row_idx]) - 719528;
496: 					}
497: 
498: 					// some dresssup for R
499: 					SET_CLASS(dest, PROTECT(mkString("Date")));
500: 					UNPROTECT(1);
501: 					break;
502: 				}
503: 				case SQLTypeId::TIME: {
504: 					auto &src_vec = chunk->data[col_idx];
505: 					auto src_data = FlatVector::GetData<int32_t>(src_vec);
506: 					auto &nullmask = FlatVector::Nullmask(src_vec);
507: 					double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
508: 					for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
509: 
510: 						if (nullmask[row_idx]) {
511: 							dest_ptr[row_idx] = NA_REAL;
512: 						} else {
513: 							time_t n = src_data[row_idx];
514: 							int h;
515: 							double frac;
516: 							h = n / 3600000;
517: 							n -= h * 3600000;
518: 							frac = (n / 60000.0) / 60.0;
519: 							dest_ptr[row_idx] = h + frac;
520: 						}
521: 					}
522: 
523: 					// some dresssup for R
524: 					SET_CLASS(dest, PROTECT(mkString("difftime")));
525: 					setAttrib(dest, install("units"), PROTECT(mkString("hours")));
526: 					UNPROTECT(2);
527: 					break;
528: 				}
529: 				case SQLTypeId::BIGINT:
530: 					vector_to_r<int64_t, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest),
531: 					                             dest_offset, NA_REAL);
532: 					break;
533: 				case SQLTypeId::FLOAT:
534: 					vector_to_r<float, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
535: 					                           NA_REAL);
536: 					break;
537: 
538: 				case SQLTypeId::DOUBLE:
539: 					vector_to_r<double, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
540: 					                            NA_REAL);
541: 					break;
542: 				case SQLTypeId::VARCHAR: {
543: 					auto src_ptr = FlatVector::GetData<string_t>(chunk->data[col_idx]);
544: 					auto &nullmask = FlatVector::Nullmask(chunk->data[col_idx]);
545: 					for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
546: 						if (nullmask[row_idx]) {
547: 							SET_STRING_ELT(dest, dest_offset + row_idx, NA_STRING);
548: 						} else {
549: 							SET_STRING_ELT(dest, dest_offset + row_idx, mkCharCE(src_ptr[row_idx].GetData(), CE_UTF8));
550: 						}
551: 					}
552: 					break;
553: 				}
554: 				default:
555: 					Rf_error("duckdb_execute_R: Unknown column type %s",
556: 					         TypeIdToString(chunk->GetTypes()[col_idx]).c_str());
557: 					break;
558: 				}
559: 			}
560: 			dest_offset += chunk->size();
561: 		}
562: 
563: 		assert(dest_offset == nrows);
564: 		UNPROTECT(1); /* retlist */
565: 		return retlist;
566: 	}
567: 	return ScalarReal(0); // no need for protection because no allocation can happen afterwards
568: }
569: 
570: static SEXP duckdb_finalize_database_R(SEXP dbsexp) {
571: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
572: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
573: 	}
574: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
575: 	if (dbaddr) {
576: 		warning("duckdb_finalize_database_R: Database is garbage-collected, use dbDisconnect(con, shutdown=TRUE) or "
577: 		        "duckdb::duckdb_shutdown(drv) to avoid this.");
578: 		R_ClearExternalPtr(dbsexp);
579: 		delete dbaddr;
580: 	}
581: 	return R_NilValue;
582: }
583: 
584: struct DataFrameScanFunctionData : public TableFunctionData {
585: 	DataFrameScanFunctionData(SEXP df, idx_t row_count, vector<RType> rtypes)
586: 	    : df(df), row_count(row_count), rtypes(rtypes), position(0) {
587: 	}
588: 	SEXP df;
589: 	idx_t row_count;
590: 	vector<RType> rtypes;
591: 	idx_t position;
592: };
593: 
594: struct DataFrameScanFunction : public TableFunction {
595: 	DataFrameScanFunction()
596: 	    : TableFunction("dataframe_scan", {SQLType::VARCHAR}, dataframe_scan_bind, dataframe_scan_function, nullptr){};
597: 
598: 	static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> inputs,
599: 	                                                    vector<SQLType> &return_types, vector<string> &names) {
600: 		// TODO have a better way to pass this pointer
601: 		SEXP df((SEXP)std::stoull(inputs[0].GetValue<string>(), nullptr, 16));
602: 
603: 		auto df_names = GET_NAMES(df);
604: 		vector<RType> rtypes;
605: 
606: 		for (idx_t col_idx = 0; col_idx < LENGTH(df); col_idx++) {
607: 			names.push_back(string(CHAR(STRING_ELT(df_names, col_idx))));
608: 			SEXP coldata = VECTOR_ELT(df, col_idx);
609: 			rtypes.push_back(detect_rtype(coldata));
610: 			SQLType duckdb_col_type;
611: 			switch (rtypes[col_idx]) {
612: 			case RType::LOGICAL:
613: 				duckdb_col_type = SQLType::BOOLEAN;
614: 				break;
615: 			case RType::INTEGER:
616: 				duckdb_col_type = SQLType::INTEGER;
617: 				break;
618: 			case RType::NUMERIC:
619: 				duckdb_col_type = SQLType::DOUBLE;
620: 				break;
621: 			case RType::FACTOR:
622: 			case RType::STRING:
623: 				duckdb_col_type = SQLType::VARCHAR;
624: 				break;
625: 			case RType::TIMESTAMP:
626: 				duckdb_col_type = SQLType::TIMESTAMP;
627: 				break;
628: 			case RType::DATE:
629: 				duckdb_col_type = SQLType::DATE;
630: 				break;
631: 			default:
632: 				Rf_error("Unsupported column type for scan");
633: 			}
634: 			return_types.push_back(duckdb_col_type);
635: 		}
636: 
637: 		auto row_count = LENGTH(VECTOR_ELT(df, 0));
638: 		return make_unique<DataFrameScanFunctionData>(df, row_count, rtypes);
639: 	}
640: 
641: 	static void dataframe_scan_function(ClientContext &context, vector<Value> &input, DataChunk &output,
642: 	                                    FunctionData *dataptr) {
643: 		auto &data = *((DataFrameScanFunctionData *)dataptr);
644: 
645: 		if (data.position >= data.row_count) {
646: 			return;
647: 		}
648: 		idx_t this_count = std::min((idx_t)STANDARD_VECTOR_SIZE, data.row_count - data.position);
649: 
650: 		output.SetCardinality(this_count);
651: 
652: 		// TODO this is quite similar to append, unify!
653: 		for (idx_t col_idx = 0; col_idx < output.column_count(); col_idx++) {
654: 			auto &v = output.data[col_idx];
655: 			SEXP coldata = VECTOR_ELT(data.df, col_idx);
656: 
657: 			switch (data.rtypes[col_idx]) {
658: 			case RType::LOGICAL: {
659: 				auto data_ptr = INTEGER_POINTER(coldata) + data.position;
660: 				AppendColumnSegment<int, bool, RBooleanType>(data_ptr, v, this_count);
661: 				break;
662: 			}
663: 			case RType::INTEGER: {
664: 				auto data_ptr = INTEGER_POINTER(coldata) + data.position;
665: 				AppendColumnSegment<int, int, RIntegerType>(data_ptr, v, this_count);
666: 				break;
667: 			}
668: 			case RType::NUMERIC: {
669: 				auto data_ptr = NUMERIC_POINTER(coldata) + data.position;
670: 				AppendColumnSegment<double, double, RDoubleType>(data_ptr, v, this_count);
671: 				break;
672: 			}
673: 			case RType::STRING:
674: 				AppendStringSegment(coldata, v, data.position, this_count);
675: 				break;
676: 			case RType::FACTOR:
677: 				AppendFactor(coldata, v, data.position, this_count);
678: 				break;
679: 			case RType::TIMESTAMP: {
680: 				auto data_ptr = NUMERIC_POINTER(coldata) + data.position;
681: 				AppendColumnSegment<double, timestamp_t, RTimestampType>(data_ptr, v, this_count);
682: 				break;
683: 			}
684: 			case RType::DATE: {
685: 				auto data_ptr = NUMERIC_POINTER(coldata) + data.position;
686: 				AppendColumnSegment<double, date_t, RDateType>(data_ptr, v, this_count);
687: 				break;
688: 			}
689: 			default:
690: 				throw;
691: 			}
692: 		}
693: 
694: 		data.position += this_count;
695: 	}
696: };
697: 
698: SEXP duckdb_startup_R(SEXP dbdirsexp, SEXP readonlysexp) {
699: 	if (TYPEOF(dbdirsexp) != STRSXP || LENGTH(dbdirsexp) != 1) {
700: 		Rf_error("duckdb_startup_R: Need string parameter for dbdir");
701: 	}
702: 	char *dbdir = (char *)CHAR(STRING_ELT(dbdirsexp, 0));
703: 
704: 	if (TYPEOF(readonlysexp) != LGLSXP || LENGTH(readonlysexp) != 1) {
705: 		Rf_error("duckdb_startup_R: Need string parameter for read_only");
706: 	}
707: 	bool read_only = (bool)LOGICAL_ELT(readonlysexp, 0);
708: 
709: 	if (strlen(dbdir) == 0 || strcmp(dbdir, ":memory:") == 0) {
710: 		dbdir = NULL;
711: 	}
712: 
713: 	DBConfig config;
714: 	config.access_mode = AccessMode::READ_WRITE;
715: 	if (read_only) {
716: 		config.access_mode = AccessMode::READ_ONLY;
717: 	}
718: 	DuckDB *dbaddr;
719: 	try {
720: 		dbaddr = new DuckDB(dbdir, &config);
721: 	} catch (...) {
722: 		Rf_error("duckdb_startup_R: Failed to open database");
723: 	}
724: 	dbaddr->LoadExtension<ParquetExtension>();
725: 
726: 	DataFrameScanFunction scan_fun;
727: 	CreateTableFunctionInfo info(scan_fun);
728: 	Connection conn(*dbaddr);
729: 	auto &context = *conn.context;
730: 	context.transaction.BeginTransaction();
731: 	context.catalog.CreateTableFunction(context, &info);
732: 	context.transaction.Commit();
733: 
734: 	SEXP dbsexp = PROTECT(R_MakeExternalPtr(dbaddr, R_NilValue, R_NilValue));
735: 	R_RegisterCFinalizer(dbsexp, (void (*)(SEXP))duckdb_finalize_database_R);
736: 	UNPROTECT(1);
737: 	return dbsexp;
738: }
739: 
740: SEXP duckdb_shutdown_R(SEXP dbsexp) {
741: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
742: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
743: 	}
744: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
745: 	if (dbaddr) {
746: 		R_ClearExternalPtr(dbsexp);
747: 		delete dbaddr;
748: 	}
749: 
750: 	return R_NilValue;
751: }
752: 
753: static SEXP duckdb_finalize_connection_R(SEXP connsexp) {
754: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
755: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
756: 	}
757: 	Connection *connaddr = (Connection *)R_ExternalPtrAddr(connsexp);
758: 	if (connaddr) {
759: 		warning("duckdb_finalize_connection_R: Connection is garbage-collected, use dbDisconnect() to avoid this.");
760: 		R_ClearExternalPtr(connsexp);
761: 		delete connaddr;
762: 	}
763: 	return R_NilValue;
764: }
765: 
766: SEXP duckdb_register_R(SEXP connsexp, SEXP namesexp, SEXP valuesexp) {
767: 
768: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
769: 		Rf_error("duckdb_append_R: Need external pointer parameter for connection");
770: 	}
771: 
772: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
773: 	if (!conn) {
774: 		Rf_error("duckdb_append_R: Invalid connection");
775: 	}
776: 
777: 	if (TYPEOF(namesexp) != STRSXP || LENGTH(namesexp) != 1) {
778: 		Rf_error("duckdb_append_R: Need single string parameter for name");
779: 	}
780: 	auto name = string(CHAR(STRING_ELT(namesexp, 0)));
781: 
782: 	if (TYPEOF(valuesexp) != VECSXP || LENGTH(valuesexp) < 1 ||
783: 	    strcmp("data.frame", CHAR(STRING_ELT(GET_CLASS(valuesexp), 0))) != 0) {
784: 		Rf_error("duckdb_append_R: Need at least one-column data frame parameter for value");
785: 	}
786: 
787: 	auto key = install(("_registered_df_" + name).c_str());
788: 	setAttrib(connsexp, key, valuesexp);
789: 
790: 	// TODO put it into a conn attr that contains a named list to keep from gc!
791: 	std::ostringstream address;
792: 	address << (void const *)valuesexp;
793: 	string pointer_str = address.str();
794: 
795: 	// hack alert: put the pointer address into the function call as a string
796: 	auto res = conn->Query("CREATE OR REPLACE TEMPORARY VIEW \"" + name + "\" AS SELECT * FROM dataframe_scan('" +
797: 	                       pointer_str + "')");
798: 	if (!res->success) {
799: 		Rf_error(res->error.c_str());
800: 	}
801: 	return R_NilValue;
802: }
803: 
804: SEXP duckdb_unregister_R(SEXP connsexp, SEXP namesexp) {
805: 
806: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
807: 		Rf_error("duckdb_append_R: Need external pointer parameter for connection");
808: 	}
809: 
810: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
811: 	if (!conn) {
812: 		Rf_error("duckdb_append_R: Invalid connection");
813: 	}
814: 
815: 	if (TYPEOF(namesexp) != STRSXP || LENGTH(namesexp) != 1) {
816: 		Rf_error("duckdb_append_R: Need single string parameter for name");
817: 	}
818: 	auto name = string(CHAR(STRING_ELT(namesexp, 0)));
819: 
820: 	auto key = install(("_registered_df_" + name).c_str());
821: 	setAttrib(connsexp, key, R_NilValue);
822: 
823: 	auto res = conn->Query("DROP VIEW IF EXISTS \"" + name + "\"");
824: 	if (!res->success) {
825: 		Rf_error(res->error.c_str());
826: 	}
827: 
828: 	// TODO
829: 	return R_NilValue;
830: }
831: 
832: SEXP duckdb_connect_R(SEXP dbsexp) {
833: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
834: 		Rf_error("duckdb_connect_R: Need external pointer parameter");
835: 	}
836: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
837: 	if (!dbaddr) {
838: 		Rf_error("duckdb_connect_R: Invalid database reference");
839: 	}
840: 
841: 	SEXP connsexp = PROTECT(R_MakeExternalPtr(new Connection(*dbaddr), R_NilValue, R_NilValue));
842: 	R_RegisterCFinalizer(connsexp, (void (*)(SEXP))duckdb_finalize_connection_R);
843: 	UNPROTECT(1);
844: 
845: 	return connsexp;
846: }
847: 
848: SEXP duckdb_disconnect_R(SEXP connsexp) {
849: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
850: 		Rf_error("duckdb_disconnect_R: Need external pointer parameter");
851: 	}
852: 	Connection *connaddr = (Connection *)R_ExternalPtrAddr(connsexp);
853: 	if (connaddr) {
854: 		R_ClearExternalPtr(connsexp);
855: 		delete connaddr;
856: 	}
857: 	return R_NilValue;
858: }
859: 
860: SEXP duckdb_ptr_to_str(SEXP extptr) {
861: 	if (TYPEOF(extptr) != EXTPTRSXP) {
862: 		Rf_error("duckdb_ptr_to_str: Need external pointer parameter");
863: 	}
864: 	SEXP ret = PROTECT(NEW_STRING(1));
865: 	SET_STRING_ELT(ret, 0, NA_STRING);
866: 	void *ptr = R_ExternalPtrAddr(extptr);
867: 	if (ptr != NULL) {
868: 		char buf[100];
869: 		snprintf(buf, 100, "%p", ptr);
870: 		SET_STRING_ELT(ret, 0, mkChar(buf));
871: 	}
872: 	UNPROTECT(1);
873: 	return ret;
874: }
875: 
876: // R native routine registration
877: #define CALLDEF(name, n)                                                                                               \
878: 	{ #name, (DL_FUNC)&name, n }
879: static const R_CallMethodDef R_CallDef[] = {CALLDEF(duckdb_startup_R, 2),
880:                                             CALLDEF(duckdb_connect_R, 1),
881:                                             CALLDEF(duckdb_prepare_R, 2),
882:                                             CALLDEF(duckdb_bind_R, 2),
883:                                             CALLDEF(duckdb_execute_R, 1),
884:                                             CALLDEF(duckdb_release_R, 1),
885:                                             CALLDEF(duckdb_register_R, 3),
886:                                             CALLDEF(duckdb_unregister_R, 2),
887:                                             CALLDEF(duckdb_disconnect_R, 1),
888:                                             CALLDEF(duckdb_shutdown_R, 1),
889:                                             CALLDEF(duckdb_ptr_to_str, 1),
890: 
891:                                             {NULL, NULL, 0}};
892: 
893: void R_init_duckdb(DllInfo *dll) {
894: 	R_registerRoutines(dll, NULL, R_CallDef, NULL, NULL);
895: 	R_useDynamicSymbols(dll, FALSE);
896: }
897: }
[end of tools/rpkg/src/duckdbr.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: