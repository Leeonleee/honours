{
  "repo": "duckdb/duckdb",
  "pull_number": 12602,
  "instance_id": "duckdb__duckdb-12602",
  "issue_numbers": [
    "12543"
  ],
  "base_commit": "2b65e613a1881f042bf630807a3bfe537f1a1323",
  "patch": "diff --git a/tools/pythonpkg/scripts/cache_data.json b/tools/pythonpkg/scripts/cache_data.json\nindex fb0a6b674967..38fdb297dc17 100644\n--- a/tools/pythonpkg/scripts/cache_data.json\n+++ b/tools/pythonpkg/scripts/cache_data.json\n@@ -551,5 +551,34 @@\n         \"full_path\": \"uuid.UUID\",\n         \"name\": \"UUID\",\n         \"children\": []\n+    },\n+    \"collections\": {\n+        \"type\": \"module\",\n+        \"full_path\": \"collections\",\n+        \"name\": \"collections\",\n+        \"children\": [\n+            \"collections.abc\"\n+        ]\n+    },\n+    \"collections.abc\": {\n+        \"type\": \"module\",\n+        \"full_path\": \"collections.abc\",\n+        \"name\": \"abc\",\n+        \"children\": [\n+            \"collections.abc.Iterable\",\n+            \"collections.abc.Mapping\"\n+        ]\n+    },\n+    \"collections.abc.Iterable\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"collections.abc.Iterable\",\n+        \"name\": \"Iterable\",\n+        \"children\": []\n+    },\n+    \"collections.abc.Mapping\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"collections.abc.Mapping\",\n+        \"name\": \"Mapping\",\n+        \"children\": []\n     }\n }\n\\ No newline at end of file\ndiff --git a/tools/pythonpkg/scripts/imports.py b/tools/pythonpkg/scripts/imports.py\nindex d597ab1ed6b3..bc5e65f59646 100644\n--- a/tools/pythonpkg/scripts/imports.py\n+++ b/tools/pythonpkg/scripts/imports.py\n@@ -101,3 +101,9 @@\n import uuid\n \n uuid.UUID\n+\n+import collections\n+import collections.abc\n+\n+collections.abc.Iterable\n+collections.abc.Mapping\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/collections_module.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/collections_module.hpp\nnew file mode 100644\nindex 000000000000..4298d3591100\n--- /dev/null\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/collections_module.hpp\n@@ -0,0 +1,46 @@\n+\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb_python/import_cache/modules/collections_module.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb_python/import_cache/python_import_cache_item.hpp\"\n+\n+namespace duckdb {\n+\n+struct CollectionsAbcCacheItem : public PythonImportCacheItem {\n+\n+public:\n+\tstatic constexpr const char *Name = \"collections.abc\";\n+\n+public:\n+\tCollectionsAbcCacheItem()\n+\t    : PythonImportCacheItem(\"collections.abc\"), Iterable(\"Iterable\", this), Mapping(\"Mapping\", this) {\n+\t}\n+\t~CollectionsAbcCacheItem() override {\n+\t}\n+\n+\tPythonImportCacheItem Iterable;\n+\tPythonImportCacheItem Mapping;\n+};\n+\n+struct CollectionsCacheItem : public PythonImportCacheItem {\n+\n+public:\n+\tstatic constexpr const char *Name = \"collections\";\n+\n+public:\n+\tCollectionsCacheItem() : PythonImportCacheItem(\"collections\"), abc() {\n+\t}\n+\t~CollectionsCacheItem() override {\n+\t}\n+\n+\tCollectionsAbcCacheItem abc;\n+};\n+\n+} // namespace duckdb\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp\nindex 30a20c66cfab..5acab4202fcf 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp\n@@ -37,6 +37,7 @@ struct PythonImportCache {\n \tTypesCacheItem types;\n \tTypingCacheItem typing;\n \tUuidCacheItem uuid;\n+\tCollectionsCacheItem collections;\n \n public:\n \tpy::handle AddCache(py::object item);\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache_modules.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache_modules.hpp\nindex 7af7d9b4da1b..172c0513aec5 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache_modules.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache_modules.hpp\n@@ -12,3 +12,4 @@\n #include \"duckdb_python/import_cache/modules/types_module.hpp\"\n #include \"duckdb_python/import_cache/modules/typing_module.hpp\"\n #include \"duckdb_python/import_cache/modules/uuid_module.hpp\"\n+#include \"duckdb_python/import_cache/modules/collections_module.hpp\"\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp b/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp\nindex 56200f0bb59e..4ab31a90ef23 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp\n@@ -29,6 +29,8 @@ struct type_caster<duckdb::vector<Type, SAFE>> : list_caster<duckdb::vector<Type\n \n bool gil_check();\n void gil_assert();\n+bool is_list_like(handle obj);\n+bool is_dict_like(handle obj);\n \n } // namespace pybind11\n \ndiff --git a/tools/pythonpkg/src/pybind11/pybind_wrapper.cpp b/tools/pythonpkg/src/pybind11/pybind_wrapper.cpp\nindex 5bbc05428897..23bf80354a16 100644\n--- a/tools/pythonpkg/src/pybind11/pybind_wrapper.cpp\n+++ b/tools/pythonpkg/src/pybind11/pybind_wrapper.cpp\n@@ -1,5 +1,6 @@\n #include \"duckdb_python/pybind11/pybind_wrapper.hpp\"\n #include \"duckdb/common/exception.hpp\"\n+#include \"duckdb_python/pyconnection/pyconnection.hpp\"\n \n namespace pybind11 {\n \n@@ -15,4 +16,24 @@ void gil_assert() {\n \t}\n }\n \n+// NOLINTNEXTLINE(readability-identifier-naming)\n+bool is_list_like(handle obj) {\n+\tif (isinstance<str>(obj) || isinstance<bytes>(obj)) {\n+\t\treturn false;\n+\t}\n+\tif (is_dict_like(obj)) {\n+\t\treturn false;\n+\t}\n+\tauto &import_cache = *duckdb::DuckDBPyConnection::ImportCache();\n+\tauto iterable = import_cache.collections.abc.Iterable();\n+\treturn isinstance(obj, iterable);\n+}\n+\n+// NOLINTNEXTLINE(readability-identifier-naming)\n+bool is_dict_like(handle obj) {\n+\tauto &import_cache = *duckdb::DuckDBPyConnection::ImportCache();\n+\tauto mapping = import_cache.collections.abc.Mapping();\n+\treturn isinstance(obj, mapping);\n+}\n+\n } // namespace pybind11\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex e2e656b14e91..5702983377bf 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -441,7 +441,7 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::ExecuteMany(const py::object\n \n \tauto prep = PrepareQuery(std::move(last_statement));\n \n-\tif (!py::isinstance<py::list>(params_p)) {\n+\tif (!py::is_list_like(params_p)) {\n \t\tthrow InvalidInputException(\"executemany requires a list of parameter sets to be provided\");\n \t}\n \tauto outer_list = py::list(params_p);\n@@ -526,7 +526,7 @@ py::list TransformNamedParameters(const case_insensitive_map_t<idx_t> &named_par\n \n case_insensitive_map_t<Value> TransformPreparedParameters(PreparedStatement &prep, const py::object &params) {\n \tcase_insensitive_map_t<Value> named_values;\n-\tif (py::isinstance<py::list>(params) || py::isinstance<py::tuple>(params)) {\n+\tif (py::is_list_like(params)) {\n \t\tif (prep.n_param != py::len(params)) {\n \t\t\tthrow InvalidInputException(\"Prepared statement needs %d parameters, %d given\", prep.n_param,\n \t\t\t                            py::len(params));\n@@ -537,7 +537,7 @@ case_insensitive_map_t<Value> TransformPreparedParameters(PreparedStatement &pre\n \t\t\tauto identifier = std::to_string(i + 1);\n \t\t\tnamed_values[identifier] = std::move(value);\n \t\t}\n-\t} else if (py::isinstance<py::dict>(params)) {\n+\t} else if (py::is_dict_like(params)) {\n \t\tauto dict = py::cast<py::dict>(params);\n \t\tnamed_values = DuckDBPyConnection::TransformPythonParamDict(dict);\n \t} else {\n@@ -749,7 +749,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadJSON(const string &name, co\n \tnamed_parameter_map_t options;\n \n \tif (!py::none().is(columns)) {\n-\t\tif (!py::isinstance<py::dict>(columns)) {\n+\t\tif (!py::is_dict_like(columns)) {\n \t\t\tthrow BinderException(\"read_json only accepts 'columns' as a dict[str, str]\");\n \t\t}\n \t\tpy::dict columns_dict = columns;\n@@ -871,7 +871,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \t}\n \n \tif (!py::none().is(dtype)) {\n-\t\tif (py::isinstance<py::dict>(dtype)) {\n+\t\tif (py::is_dict_like(dtype)) {\n \t\t\tchild_list_t<Value> struct_fields;\n \t\t\tpy::dict dtype_dict = dtype;\n \t\t\tfor (auto &kv : dtype_dict) {\n@@ -883,7 +883,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \t\t\t}\n \t\t\tauto dtype_struct = Value::STRUCT(std::move(struct_fields));\n \t\t\tbind_parameters[\"dtypes\"] = std::move(dtype_struct);\n-\t\t} else if (py::isinstance<py::list>(dtype)) {\n+\t\t} else if (py::is_list_like(dtype)) {\n \t\t\tvector<Value> list_values;\n \t\t\tpy::list dtype_list = dtype;\n \t\t\tfor (auto &child : dtype_list) {\n@@ -911,7 +911,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \t}\n \n \tif (!py::none().is(names_p)) {\n-\t\tif (!py::isinstance<py::list>(names_p)) {\n+\t\tif (!py::is_list_like(names_p)) {\n \t\t\tthrow InvalidInputException(\"read_csv only accepts 'names' as a list of strings\");\n \t\t}\n \t\tvector<Value> names;\n@@ -927,7 +927,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \n \tif (!py::none().is(na_values)) {\n \t\tvector<Value> null_values;\n-\t\tif (!py::isinstance<py::str>(na_values) && !py::isinstance<py::list>(na_values)) {\n+\t\tif (!py::isinstance<py::str>(na_values) && !py::is_list_like(na_values)) {\n \t\t\tthrow InvalidInputException(\"read_csv only accepts 'na_values' as a string or a list of strings\");\n \t\t} else if (py::isinstance<py::str>(na_values)) {\n \t\t\tnull_values.push_back(Value(py::str(na_values)));\n@@ -1163,7 +1163,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::TableFunction(const string &fna\n \tif (params.is_none()) {\n \t\tparams = py::list();\n \t}\n-\tif (!py::isinstance<py::list>(params)) {\n+\tif (!py::is_list_like(params)) {\n \t\tthrow InvalidInputException(\"'params' has to be a list of parameters\");\n \t}\n \tif (!connection) {\n@@ -1723,7 +1723,7 @@ NumpyObjectType DuckDBPyConnection::IsAcceptedNumpyObject(const py::object &obje\n \t\tdefault:\n \t\t\treturn NumpyObjectType::INVALID;\n \t\t}\n-\t} else if (py::isinstance<py::dict>(object)) {\n+\t} else if (py::is_dict_like(object)) {\n \t\tint dim = -1;\n \t\tfor (auto item : py::cast<py::dict>(object)) {\n \t\t\tif (!IsValidNumpyDimensions(item.second, dim)) {\n@@ -1731,7 +1731,7 @@ NumpyObjectType DuckDBPyConnection::IsAcceptedNumpyObject(const py::object &obje\n \t\t\t}\n \t\t}\n \t\treturn NumpyObjectType::DICT;\n-\t} else if (py::isinstance<py::list>(object)) {\n+\t} else if (py::is_list_like(object)) {\n \t\tint dim = -1;\n \t\tfor (auto item : py::cast<py::list>(object)) {\n \t\t\tif (!IsValidNumpyDimensions(item, dim)) {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_duckdb_execute.py b/tools/pythonpkg/tests/fast/api/test_duckdb_execute.py\nindex ed7cfb711300..ded26df0973c 100644\n--- a/tools/pythonpkg/tests/fast/api/test_duckdb_execute.py\n+++ b/tools/pythonpkg/tests/fast/api/test_duckdb_execute.py\n@@ -60,3 +60,15 @@ def test_execute_many_error(self, duckdb_cursor):\n             \"\"\",\n                 (99,),\n             )\n+\n+    def test_execute_many_generator(self, duckdb_cursor):\n+        to_insert = [[1], [2], [3]]\n+\n+        def to_insert_from_generator(what):\n+            for x in what:\n+                yield x\n+\n+        gen = to_insert_from_generator(to_insert)\n+        duckdb_cursor.execute(\"CREATE TABLE unittest_generator (a INTEGER);\")\n+        duckdb_cursor.executemany(\"INSERT into unittest_generator (a) VALUES (?)\", gen)\n+        assert duckdb_cursor.table('unittest_generator').fetchall() == [(1,), (2,), (3,)]\n",
  "problem_statement": "Invalid Input Error: executemany requires a list of parameter sets to be provided\n### What happens?\r\n\r\nIn order to relieve memory presure I am using _generators_ (iterable) to provide the contents of what I want to insert into the database. This works well with the SQLite3 interface, sadly it produces an error in DuckDB.\r\n\r\n### To Reproduce\r\n\r\n```python\r\nfrom typing import List, Generator\r\n\r\nimport duckdb\r\n\r\ncon = duckdb.connect()\r\ncon.execute(\"CREATE TABLE unittest_generator (a INTEGER);\")\r\n\r\nto_insert = [[1],[2],[3]]\r\n\r\ncon.executemany(\"INSERT into unittest_generator (a) VALUES (?)\", to_insert)\r\n\r\ndef to_insert_from_generator(what: List) -> Generator:\r\n    for x in what:\r\n        yield x\r\n\r\ncon.executemany(\"INSERT into unittest_generator (a) VALUES (?)\", to_insert_from_generator(to_insert))\r\n```\r\n```console\r\nduckdb.duckdb.InvalidInputException: Invalid Input Error: executemany requires a list of parameter sets to be provided\r\n```\r\n\r\nCompare this to:\r\n\r\n```python\r\nfrom typing import List, Generator\r\n\r\nimport sqlite3\r\n\r\nto_insert = [[1],[2],[3]]\r\n\r\ndef to_insert_from_generator(what: List) -> Generator:\r\n    for x in what:\r\n        yield x\r\n\r\ncon = sqlite3.connect(database=\":memory:\")\r\ncon.execute(\"CREATE TABLE unittest_generator (a INTEGER);\")\r\ncon.executemany(\"INSERT into unittest_generator (a) VALUES (?)\", to_insert)\r\ncon.executemany(\"INSERT into unittest_generator (a) VALUES (?)\", to_insert_from_generator(to_insert))\r\n```\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nStefan de Konink\r\n\r\n### Affiliation:\r\n\r\nStichting OpenGeo\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-06-19T13:43:06Z"
}