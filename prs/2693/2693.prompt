You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Epoch function does not return seconds since midnight, but merely seconds.
#### What happens?

In the documentation on time functions it shows:

select epoch(TIME '14:21:13') returns 51673, but on my version its 13.

#### To Reproduce

select epoch(TIME '14:21:13')

#### Environment (please complete the following information):
 - OS: MacOSX
 - DuckDB Version: 0.3.1 88aa81c6b
 - DuckDB Client: CLI

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**: Yes
- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

Epoch function does not return seconds since midnight, but merely seconds.
#### What happens?

In the documentation on time functions it shows:

select epoch(TIME '14:21:13') returns 51673, but on my version its 13.

#### To Reproduce

select epoch(TIME '14:21:13')

#### Environment (please complete the following information):
 - OS: MacOSX
 - DuckDB Version: 0.3.1 88aa81c6b
 - DuckDB Client: CLI

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**: Yes
- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/function/scalar/date/date_part.cpp]
1: #include "duckdb/function/scalar/date_functions.hpp"
2: #include "duckdb/common/enums/date_part_specifier.hpp"
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/types/date.hpp"
5: #include "duckdb/common/types/timestamp.hpp"
6: #include "duckdb/common/vector_operations/vector_operations.hpp"
7: #include "duckdb/common/string_util.hpp"
8: #include "duckdb/storage/statistics/numeric_statistics.hpp"
9: 
10: namespace duckdb {
11: 
12: bool TryGetDatePartSpecifier(const string &specifier_p, DatePartSpecifier &result) {
13: 	auto specifier = StringUtil::Lower(specifier_p);
14: 	if (specifier == "year" || specifier == "y" || specifier == "years") {
15: 		result = DatePartSpecifier::YEAR;
16: 	} else if (specifier == "month" || specifier == "mon" || specifier == "months" || specifier == "mons") {
17: 		result = DatePartSpecifier::MONTH;
18: 	} else if (specifier == "day" || specifier == "days" || specifier == "d") {
19: 		result = DatePartSpecifier::DAY;
20: 	} else if (specifier == "decade" || specifier == "decades") {
21: 		result = DatePartSpecifier::DECADE;
22: 	} else if (specifier == "century" || specifier == "centuries") {
23: 		result = DatePartSpecifier::CENTURY;
24: 	} else if (specifier == "millennium" || specifier == "millennia") {
25: 		result = DatePartSpecifier::MILLENNIUM;
26: 	} else if (specifier == "microseconds" || specifier == "microsecond") {
27: 		result = DatePartSpecifier::MICROSECONDS;
28: 	} else if (specifier == "milliseconds" || specifier == "millisecond" || specifier == "ms" || specifier == "msec" ||
29: 	           specifier == "msecs") {
30: 		result = DatePartSpecifier::MILLISECONDS;
31: 	} else if (specifier == "second" || specifier == "seconds" || specifier == "s") {
32: 		result = DatePartSpecifier::SECOND;
33: 	} else if (specifier == "minute" || specifier == "minutes" || specifier == "m") {
34: 		result = DatePartSpecifier::MINUTE;
35: 	} else if (specifier == "hour" || specifier == "hours" || specifier == "h") {
36: 		result = DatePartSpecifier::HOUR;
37: 	} else if (specifier == "epoch") {
38: 		// seconds since 1970-01-01
39: 		result = DatePartSpecifier::EPOCH;
40: 	} else if (specifier == "dow" || specifier == "dayofweek") {
41: 		// day of the week (Sunday = 0, Saturday = 6)
42: 		result = DatePartSpecifier::DOW;
43: 	} else if (specifier == "isodow") {
44: 		// isodow (Monday = 1, Sunday = 7)
45: 		result = DatePartSpecifier::ISODOW;
46: 	} else if (specifier == "week" || specifier == "weeks" || specifier == "w") {
47: 		// week number
48: 		result = DatePartSpecifier::WEEK;
49: 	} else if (specifier == "doy" || specifier == "dayofyear") {
50: 		// day of the year (1-365/366)
51: 		result = DatePartSpecifier::DOY;
52: 	} else if (specifier == "quarter" || specifier == "quarters") {
53: 		// quarter of the year (1-4)
54: 		result = DatePartSpecifier::QUARTER;
55: 	} else if (specifier == "yearweek") {
56: 		// Combined year and week YYYYWW
57: 		result = DatePartSpecifier::YEARWEEK;
58: 	} else {
59: 		return false;
60: 	}
61: 	return true;
62: }
63: 
64: DatePartSpecifier GetDatePartSpecifier(const string &specifier) {
65: 	DatePartSpecifier result;
66: 	if (!TryGetDatePartSpecifier(specifier, result)) {
67: 		throw ConversionException("extract specifier \"%s\" not recognized", specifier);
68: 	}
69: 	return result;
70: }
71: 
72: template <class T>
73: static void LastYearFunction(DataChunk &args, ExpressionState &state, Vector &result) {
74: 	int32_t last_year = 0;
75: 	UnaryExecutor::Execute<T, int64_t>(args.data[0], result, args.size(),
76: 	                                   [&](T input) { return Date::ExtractYear(input, &last_year); });
77: }
78: 
79: template <class T, class OP>
80: static unique_ptr<BaseStatistics> PropagateDatePartStatistics(vector<unique_ptr<BaseStatistics>> &child_stats) {
81: 	// we can only propagate complex date part stats if the child has stats
82: 	if (!child_stats[0]) {
83: 		return nullptr;
84: 	}
85: 	auto &nstats = (NumericStatistics &)*child_stats[0];
86: 	if (nstats.min.is_null || nstats.max.is_null) {
87: 		return nullptr;
88: 	}
89: 	// run the operator on both the min and the max, this gives us the [min, max] bound
90: 	auto min = nstats.min.GetValueUnsafe<T>();
91: 	auto max = nstats.max.GetValueUnsafe<T>();
92: 	if (min > max) {
93: 		return nullptr;
94: 	}
95: 	auto min_part = OP::template Operation<T, int64_t>(min);
96: 	auto max_part = OP::template Operation<T, int64_t>(max);
97: 	auto result = make_unique<NumericStatistics>(LogicalType::BIGINT, Value::BIGINT(min_part), Value::BIGINT(max_part));
98: 	if (child_stats[0]->validity_stats) {
99: 		result->validity_stats = child_stats[0]->validity_stats->Copy();
100: 	}
101: 	return move(result);
102: }
103: 
104: template <int64_t MIN, int64_t MAX>
105: static unique_ptr<BaseStatistics> PropagateSimpleDatePartStatistics(vector<unique_ptr<BaseStatistics>> &child_stats) {
106: 	// we can always propagate simple date part statistics
107: 	// since the min and max can never exceed these bounds
108: 	auto result = make_unique<NumericStatistics>(LogicalType::BIGINT, Value::BIGINT(MIN), Value::BIGINT(MAX));
109: 	if (!child_stats[0]) {
110: 		// if there are no child stats, we don't know
111: 		result->validity_stats = make_unique<ValidityStatistics>(true);
112: 	} else if (child_stats[0]->validity_stats) {
113: 		result->validity_stats = child_stats[0]->validity_stats->Copy();
114: 	}
115: 	return move(result);
116: }
117: 
118: struct DatePart {
119: 	struct YearOperator {
120: 		template <class TA, class TR>
121: 		static inline TR Operation(TA input) {
122: 			return Date::ExtractYear(input);
123: 		}
124: 
125: 		template <class T>
126: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
127: 		                                                      FunctionData *bind_data,
128: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
129: 			return PropagateDatePartStatistics<T, YearOperator>(child_stats);
130: 		}
131: 	};
132: 
133: 	struct MonthOperator {
134: 		template <class TA, class TR>
135: 		static inline TR Operation(TA input) {
136: 			return Date::ExtractMonth(input);
137: 		}
138: 
139: 		template <class T>
140: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
141: 		                                                      FunctionData *bind_data,
142: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
143: 			// min/max of month operator is [1, 12]
144: 			return PropagateSimpleDatePartStatistics<1, 12>(child_stats);
145: 		}
146: 	};
147: 
148: 	struct DayOperator {
149: 		template <class TA, class TR>
150: 		static inline TR Operation(TA input) {
151: 			return Date::ExtractDay(input);
152: 		}
153: 
154: 		template <class T>
155: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
156: 		                                                      FunctionData *bind_data,
157: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
158: 			// min/max of day operator is [1, 31]
159: 			return PropagateSimpleDatePartStatistics<1, 31>(child_stats);
160: 		}
161: 	};
162: 
163: 	struct DecadeOperator {
164: 		template <class TA, class TR>
165: 		static inline TR Operation(TA input) {
166: 			return YearOperator::Operation<TA, TR>(input) / 10;
167: 		}
168: 
169: 		template <class T>
170: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
171: 		                                                      FunctionData *bind_data,
172: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
173: 			return PropagateDatePartStatistics<T, DecadeOperator>(child_stats);
174: 		}
175: 	};
176: 
177: 	struct CenturyOperator {
178: 		template <class TA, class TR>
179: 		static inline TR Operation(TA input) {
180: 			return ((YearOperator::Operation<TA, TR>(input) - 1) / 100) + 1;
181: 		}
182: 
183: 		template <class T>
184: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
185: 		                                                      FunctionData *bind_data,
186: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
187: 			return PropagateDatePartStatistics<T, CenturyOperator>(child_stats);
188: 		}
189: 	};
190: 
191: 	struct MilleniumOperator {
192: 		template <class TA, class TR>
193: 		static inline TR Operation(TA input) {
194: 			return ((YearOperator::Operation<TA, TR>(input) - 1) / 1000) + 1;
195: 		}
196: 
197: 		template <class T>
198: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
199: 		                                                      FunctionData *bind_data,
200: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
201: 			return PropagateDatePartStatistics<T, MilleniumOperator>(child_stats);
202: 		}
203: 	};
204: 
205: 	struct QuarterOperator {
206: 		template <class TA, class TR>
207: 		static inline TR Operation(TA input) {
208: 			return (Date::ExtractMonth(input) - 1) / Interval::MONTHS_PER_QUARTER + 1;
209: 		}
210: 
211: 		template <class T>
212: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
213: 		                                                      FunctionData *bind_data,
214: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
215: 			// min/max of quarter operator is [1, 4]
216: 			return PropagateSimpleDatePartStatistics<1, 4>(child_stats);
217: 		}
218: 	};
219: 
220: 	struct DayOfWeekOperator {
221: 		template <class TA, class TR>
222: 		static inline TR Operation(TA input) {
223: 			// day of the week (Sunday = 0, Saturday = 6)
224: 			// turn sunday into 0 by doing mod 7
225: 			return Date::ExtractISODayOfTheWeek(input) % 7;
226: 		}
227: 
228: 		template <class T>
229: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
230: 		                                                      FunctionData *bind_data,
231: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
232: 			return PropagateSimpleDatePartStatistics<0, 6>(child_stats);
233: 		}
234: 	};
235: 
236: 	struct ISODayOfWeekOperator {
237: 		template <class TA, class TR>
238: 		static inline TR Operation(TA input) {
239: 			// isodow (Monday = 1, Sunday = 7)
240: 			return Date::ExtractISODayOfTheWeek(input);
241: 		}
242: 
243: 		template <class T>
244: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
245: 		                                                      FunctionData *bind_data,
246: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
247: 			return PropagateSimpleDatePartStatistics<1, 7>(child_stats);
248: 		}
249: 	};
250: 
251: 	struct DayOfYearOperator {
252: 		template <class TA, class TR>
253: 		static inline TR Operation(TA input) {
254: 			return Date::ExtractDayOfTheYear(input);
255: 		}
256: 
257: 		template <class T>
258: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
259: 		                                                      FunctionData *bind_data,
260: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
261: 			return PropagateSimpleDatePartStatistics<1, 366>(child_stats);
262: 		}
263: 	};
264: 
265: 	struct WeekOperator {
266: 		template <class TA, class TR>
267: 		static inline TR Operation(TA input) {
268: 			return Date::ExtractISOWeekNumber(input);
269: 		}
270: 
271: 		template <class T>
272: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
273: 		                                                      FunctionData *bind_data,
274: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
275: 			return PropagateSimpleDatePartStatistics<1, 54>(child_stats);
276: 		}
277: 	};
278: 
279: 	struct YearWeekOperator {
280: 		template <class TA, class TR>
281: 		static inline TR Operation(TA input) {
282: 			return YearOperator::Operation<TA, TR>(input) * 100 + WeekOperator::Operation<TA, TR>(input);
283: 		}
284: 
285: 		template <class T>
286: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
287: 		                                                      FunctionData *bind_data,
288: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
289: 			return PropagateDatePartStatistics<T, YearWeekOperator>(child_stats);
290: 		}
291: 	};
292: 
293: 	struct MicrosecondsOperator {
294: 		template <class TA, class TR>
295: 		static inline TR Operation(TA input) {
296: 			return 0;
297: 		}
298: 
299: 		template <class T>
300: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
301: 		                                                      FunctionData *bind_data,
302: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
303: 			return PropagateSimpleDatePartStatistics<0, 60000000>(child_stats);
304: 		}
305: 	};
306: 
307: 	struct MillisecondsOperator {
308: 		template <class TA, class TR>
309: 		static inline TR Operation(TA input) {
310: 			return 0;
311: 		}
312: 
313: 		template <class T>
314: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
315: 		                                                      FunctionData *bind_data,
316: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
317: 			return PropagateSimpleDatePartStatistics<0, 60000>(child_stats);
318: 		}
319: 	};
320: 
321: 	struct SecondsOperator {
322: 		template <class TA, class TR>
323: 		static inline TR Operation(TA input) {
324: 			return 0;
325: 		}
326: 
327: 		template <class T>
328: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
329: 		                                                      FunctionData *bind_data,
330: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
331: 			return PropagateSimpleDatePartStatistics<0, 60>(child_stats);
332: 		}
333: 	};
334: 
335: 	struct MinutesOperator {
336: 		template <class TA, class TR>
337: 		static inline TR Operation(TA input) {
338: 			return 0;
339: 		}
340: 
341: 		template <class T>
342: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
343: 		                                                      FunctionData *bind_data,
344: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
345: 			return PropagateSimpleDatePartStatistics<0, 60>(child_stats);
346: 		}
347: 	};
348: 
349: 	struct HoursOperator {
350: 		template <class TA, class TR>
351: 		static inline TR Operation(TA input) {
352: 			return 0;
353: 		}
354: 
355: 		template <class T>
356: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
357: 		                                                      FunctionData *bind_data,
358: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
359: 			return PropagateSimpleDatePartStatistics<0, 24>(child_stats);
360: 		}
361: 	};
362: 
363: 	struct EpochOperator {
364: 		template <class TA, class TR>
365: 		static inline TR Operation(TA input) {
366: 			return Date::Epoch(input);
367: 		}
368: 
369: 		template <class T>
370: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
371: 		                                                      FunctionData *bind_data,
372: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
373: 			return PropagateDatePartStatistics<T, EpochOperator>(child_stats);
374: 		}
375: 	};
376: };
377: 
378: template <>
379: int64_t DatePart::YearOperator::Operation(timestamp_t input) {
380: 	return YearOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
381: }
382: 
383: template <>
384: int64_t DatePart::YearOperator::Operation(interval_t input) {
385: 	return input.months / Interval::MONTHS_PER_YEAR;
386: }
387: 
388: template <>
389: int64_t DatePart::YearOperator::Operation(dtime_t input) {
390: 	throw NotImplementedException("\"time\" units \"year\" not recognized");
391: }
392: 
393: template <>
394: int64_t DatePart::MonthOperator::Operation(timestamp_t input) {
395: 	return MonthOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
396: }
397: 
398: template <>
399: int64_t DatePart::MonthOperator::Operation(interval_t input) {
400: 	return input.months % Interval::MONTHS_PER_YEAR;
401: }
402: 
403: template <>
404: int64_t DatePart::MonthOperator::Operation(dtime_t input) {
405: 	throw NotImplementedException("\"time\" units \"month\" not recognized");
406: }
407: 
408: template <>
409: int64_t DatePart::DayOperator::Operation(timestamp_t input) {
410: 	return DayOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
411: }
412: 
413: template <>
414: int64_t DatePart::DayOperator::Operation(interval_t input) {
415: 	return input.days;
416: }
417: 
418: template <>
419: int64_t DatePart::DayOperator::Operation(dtime_t input) {
420: 	throw NotImplementedException("\"time\" units \"day\" not recognized");
421: }
422: 
423: template <>
424: int64_t DatePart::DecadeOperator::Operation(interval_t input) {
425: 	return input.months / Interval::MONTHS_PER_DECADE;
426: }
427: 
428: template <>
429: int64_t DatePart::DecadeOperator::Operation(dtime_t input) {
430: 	throw NotImplementedException("\"time\" units \"decade\" not recognized");
431: }
432: 
433: template <>
434: int64_t DatePart::CenturyOperator::Operation(interval_t input) {
435: 	return input.months / Interval::MONTHS_PER_CENTURY;
436: }
437: 
438: template <>
439: int64_t DatePart::CenturyOperator::Operation(dtime_t input) {
440: 	throw NotImplementedException("\"time\" units \"century\" not recognized");
441: }
442: 
443: template <>
444: int64_t DatePart::MilleniumOperator::Operation(interval_t input) {
445: 	return input.months / Interval::MONTHS_PER_MILLENIUM;
446: }
447: 
448: template <>
449: int64_t DatePart::MilleniumOperator::Operation(dtime_t input) {
450: 	throw NotImplementedException("\"time\" units \"millennium\" not recognized");
451: }
452: 
453: template <>
454: int64_t DatePart::QuarterOperator::Operation(timestamp_t input) {
455: 	return QuarterOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
456: }
457: 
458: template <>
459: int64_t DatePart::QuarterOperator::Operation(interval_t input) {
460: 	return MonthOperator::Operation<interval_t, int64_t>(input) / Interval::MONTHS_PER_QUARTER + 1;
461: }
462: 
463: template <>
464: int64_t DatePart::QuarterOperator::Operation(dtime_t input) {
465: 	throw NotImplementedException("\"time\" units \"quarter\" not recognized");
466: }
467: 
468: template <>
469: int64_t DatePart::DayOfWeekOperator::Operation(timestamp_t input) {
470: 	return DayOfWeekOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
471: }
472: 
473: template <>
474: int64_t DatePart::DayOfWeekOperator::Operation(interval_t input) {
475: 	throw NotImplementedException("interval units \"dow\" not recognized");
476: }
477: 
478: template <>
479: int64_t DatePart::DayOfWeekOperator::Operation(dtime_t input) {
480: 	throw NotImplementedException("\"time\" units \"dow\" not recognized");
481: }
482: 
483: template <>
484: int64_t DatePart::ISODayOfWeekOperator::Operation(timestamp_t input) {
485: 	return ISODayOfWeekOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
486: }
487: 
488: template <>
489: int64_t DatePart::ISODayOfWeekOperator::Operation(interval_t input) {
490: 	throw NotImplementedException("interval units \"isodow\" not recognized");
491: }
492: 
493: template <>
494: int64_t DatePart::ISODayOfWeekOperator::Operation(dtime_t input) {
495: 	throw NotImplementedException("\"time\" units \"isodow\" not recognized");
496: }
497: 
498: template <>
499: int64_t DatePart::DayOfYearOperator::Operation(timestamp_t input) {
500: 	return DayOfYearOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
501: }
502: 
503: template <>
504: int64_t DatePart::DayOfYearOperator::Operation(interval_t input) {
505: 	throw NotImplementedException("interval units \"doy\" not recognized");
506: }
507: 
508: template <>
509: int64_t DatePart::DayOfYearOperator::Operation(dtime_t input) {
510: 	throw NotImplementedException("\"time\" units \"doy\" not recognized");
511: }
512: 
513: template <>
514: int64_t DatePart::WeekOperator::Operation(timestamp_t input) {
515: 	return WeekOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
516: }
517: 
518: template <>
519: int64_t DatePart::WeekOperator::Operation(interval_t input) {
520: 	throw NotImplementedException("interval units \"week\" not recognized");
521: }
522: 
523: template <>
524: int64_t DatePart::WeekOperator::Operation(dtime_t input) {
525: 	throw NotImplementedException("\"time\" units \"week\" not recognized");
526: }
527: 
528: template <>
529: int64_t DatePart::YearWeekOperator::Operation(dtime_t input) {
530: 	throw NotImplementedException("\"time\" units \"yearweek\" not recognized");
531: }
532: 
533: template <>
534: int64_t DatePart::MicrosecondsOperator::Operation(timestamp_t input) {
535: 	auto time = Timestamp::GetTime(input);
536: 	// remove everything but the second & microsecond part
537: 	return time.micros % Interval::MICROS_PER_MINUTE;
538: }
539: 
540: template <>
541: int64_t DatePart::MicrosecondsOperator::Operation(interval_t input) {
542: 	// remove everything but the second & microsecond part
543: 	return input.micros % Interval::MICROS_PER_MINUTE;
544: }
545: 
546: template <>
547: int64_t DatePart::MicrosecondsOperator::Operation(dtime_t input) {
548: 	// remove everything but the second & microsecond part
549: 	return input.micros % Interval::MICROS_PER_MINUTE;
550: }
551: 
552: template <>
553: int64_t DatePart::MillisecondsOperator::Operation(timestamp_t input) {
554: 	return MicrosecondsOperator::Operation<timestamp_t, int64_t>(input) / Interval::MICROS_PER_MSEC;
555: }
556: 
557: template <>
558: int64_t DatePart::MillisecondsOperator::Operation(interval_t input) {
559: 	return MicrosecondsOperator::Operation<interval_t, int64_t>(input) / Interval::MICROS_PER_MSEC;
560: }
561: 
562: template <>
563: int64_t DatePart::MillisecondsOperator::Operation(dtime_t input) {
564: 	return MicrosecondsOperator::Operation<dtime_t, int64_t>(input) / Interval::MICROS_PER_MSEC;
565: }
566: 
567: template <>
568: int64_t DatePart::SecondsOperator::Operation(timestamp_t input) {
569: 	return MicrosecondsOperator::Operation<timestamp_t, int64_t>(input) / Interval::MICROS_PER_SEC;
570: }
571: 
572: template <>
573: int64_t DatePart::SecondsOperator::Operation(interval_t input) {
574: 	return MicrosecondsOperator::Operation<interval_t, int64_t>(input) / Interval::MICROS_PER_SEC;
575: }
576: 
577: template <>
578: int64_t DatePart::SecondsOperator::Operation(dtime_t input) {
579: 	return MicrosecondsOperator::Operation<dtime_t, int64_t>(input) / Interval::MICROS_PER_SEC;
580: }
581: 
582: template <>
583: int64_t DatePart::MinutesOperator::Operation(timestamp_t input) {
584: 	auto time = Timestamp::GetTime(input);
585: 	// remove the hour part, and truncate to minutes
586: 	return (time.micros % Interval::MICROS_PER_HOUR) / Interval::MICROS_PER_MINUTE;
587: }
588: 
589: template <>
590: int64_t DatePart::MinutesOperator::Operation(interval_t input) {
591: 	// remove the hour part, and truncate to minutes
592: 	return (input.micros % Interval::MICROS_PER_HOUR) / Interval::MICROS_PER_MINUTE;
593: }
594: 
595: template <>
596: int64_t DatePart::MinutesOperator::Operation(dtime_t input) {
597: 	// remove the hour part, and truncate to minutes
598: 	return (input.micros % Interval::MICROS_PER_HOUR) / Interval::MICROS_PER_MINUTE;
599: }
600: 
601: template <>
602: int64_t DatePart::HoursOperator::Operation(timestamp_t input) {
603: 	return Timestamp::GetTime(input).micros / Interval::MICROS_PER_HOUR;
604: }
605: 
606: template <>
607: int64_t DatePart::HoursOperator::Operation(interval_t input) {
608: 	return input.micros / Interval::MICROS_PER_HOUR;
609: }
610: 
611: template <>
612: int64_t DatePart::HoursOperator::Operation(dtime_t input) {
613: 	return input.micros / Interval::MICROS_PER_HOUR;
614: }
615: 
616: template <>
617: int64_t DatePart::EpochOperator::Operation(timestamp_t input) {
618: 	return Timestamp::GetEpochSeconds(input);
619: }
620: 
621: template <>
622: int64_t DatePart::EpochOperator::Operation(interval_t input) {
623: 	int64_t interval_years = input.months / Interval::MONTHS_PER_YEAR;
624: 	int64_t interval_days;
625: 	interval_days = Interval::DAYS_PER_YEAR * interval_years;
626: 	interval_days += Interval::DAYS_PER_MONTH * (input.months % Interval::MONTHS_PER_YEAR);
627: 	interval_days += input.days;
628: 	int64_t interval_epoch;
629: 	interval_epoch = interval_days * Interval::SECS_PER_DAY;
630: 	// we add 0.25 days per year to sort of account for leap days
631: 	interval_epoch += interval_years * (Interval::SECS_PER_DAY / 4);
632: 	interval_epoch += input.micros / Interval::MICROS_PER_SEC;
633: 	return interval_epoch;
634: }
635: 
636: template <>
637: int64_t DatePart::EpochOperator::Operation(dtime_t input) {
638: 	return SecondsOperator::Operation<dtime_t, int64_t>(input);
639: }
640: 
641: template <>
642: unique_ptr<BaseStatistics>
643: DatePart::EpochOperator::PropagateStatistics<dtime_t>(ClientContext &context, BoundFunctionExpression &expr,
644:                                                       FunctionData *bind_data,
645:                                                       vector<unique_ptr<BaseStatistics>> &child_stats) {
646: 	// time seconds range over a single day
647: 	return PropagateSimpleDatePartStatistics<0, 86400>(child_stats);
648: }
649: 
650: template <class T>
651: static int64_t ExtractElement(DatePartSpecifier type, T element) {
652: 	switch (type) {
653: 	case DatePartSpecifier::YEAR:
654: 		return DatePart::YearOperator::template Operation<T, int64_t>(element);
655: 	case DatePartSpecifier::MONTH:
656: 		return DatePart::MonthOperator::template Operation<T, int64_t>(element);
657: 	case DatePartSpecifier::DAY:
658: 		return DatePart::DayOperator::template Operation<T, int64_t>(element);
659: 	case DatePartSpecifier::DECADE:
660: 		return DatePart::DecadeOperator::template Operation<T, int64_t>(element);
661: 	case DatePartSpecifier::CENTURY:
662: 		return DatePart::CenturyOperator::template Operation<T, int64_t>(element);
663: 	case DatePartSpecifier::MILLENNIUM:
664: 		return DatePart::MilleniumOperator::template Operation<T, int64_t>(element);
665: 	case DatePartSpecifier::QUARTER:
666: 		return DatePart::QuarterOperator::template Operation<T, int64_t>(element);
667: 	case DatePartSpecifier::DOW:
668: 		return DatePart::DayOfWeekOperator::template Operation<T, int64_t>(element);
669: 	case DatePartSpecifier::ISODOW:
670: 		return DatePart::ISODayOfWeekOperator::template Operation<T, int64_t>(element);
671: 	case DatePartSpecifier::DOY:
672: 		return DatePart::DayOfYearOperator::template Operation<T, int64_t>(element);
673: 	case DatePartSpecifier::WEEK:
674: 		return DatePart::WeekOperator::template Operation<T, int64_t>(element);
675: 	case DatePartSpecifier::YEARWEEK:
676: 		return DatePart::YearWeekOperator::template Operation<T, int64_t>(element);
677: 	case DatePartSpecifier::EPOCH:
678: 		return DatePart::EpochOperator::template Operation<T, int64_t>(element);
679: 	case DatePartSpecifier::MICROSECONDS:
680: 		return DatePart::MicrosecondsOperator::template Operation<T, int64_t>(element);
681: 	case DatePartSpecifier::MILLISECONDS:
682: 		return DatePart::MillisecondsOperator::template Operation<T, int64_t>(element);
683: 	case DatePartSpecifier::SECOND:
684: 		return DatePart::SecondsOperator::template Operation<T, int64_t>(element);
685: 	case DatePartSpecifier::MINUTE:
686: 		return DatePart::MinutesOperator::template Operation<T, int64_t>(element);
687: 	case DatePartSpecifier::HOUR:
688: 		return DatePart::HoursOperator::template Operation<T, int64_t>(element);
689: 	default:
690: 		throw NotImplementedException("Specifier type not implemented for DATEPART");
691: 	}
692: }
693: 
694: struct DatePartBinaryOperator {
695: 	template <class TA, class TB, class TR>
696: 	static inline TR Operation(TA specifier, TB date) {
697: 		return ExtractElement<TB>(GetDatePartSpecifier(specifier.GetString()), date);
698: 	}
699: };
700: 
701: template <typename T>
702: static void DatePartFunction(DataChunk &args, ExpressionState &state, Vector &result) {
703: 	D_ASSERT(args.ColumnCount() == 2);
704: 	auto &part_arg = args.data[0];
705: 	auto &date_arg = args.data[1];
706: 
707: 	BinaryExecutor::ExecuteStandard<string_t, T, int64_t, DatePartBinaryOperator>(part_arg, date_arg, result,
708: 	                                                                              args.size());
709: }
710: 
711: void AddGenericDatePartOperator(BuiltinFunctions &set, const string &name, scalar_function_t date_func,
712:                                 scalar_function_t ts_func, scalar_function_t interval_func,
713:                                 function_statistics_t date_stats, function_statistics_t ts_stats) {
714: 	ScalarFunctionSet operator_set(name);
715: 	operator_set.AddFunction(
716: 	    ScalarFunction({LogicalType::DATE}, LogicalType::BIGINT, move(date_func), false, nullptr, nullptr, date_stats));
717: 	operator_set.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::BIGINT, move(ts_func), false,
718: 	                                        nullptr, nullptr, ts_stats));
719: 	operator_set.AddFunction(ScalarFunction({LogicalType::INTERVAL}, LogicalType::BIGINT, move(interval_func)));
720: 	set.AddFunction(operator_set);
721: }
722: 
723: template <class OP>
724: static void AddDatePartOperator(BuiltinFunctions &set, string name) {
725: 	AddGenericDatePartOperator(set, name, ScalarFunction::UnaryFunction<date_t, int64_t, OP>,
726: 	                           ScalarFunction::UnaryFunction<timestamp_t, int64_t, OP>,
727: 	                           ScalarFunction::UnaryFunction<interval_t, int64_t, OP>,
728: 	                           OP::template PropagateStatistics<date_t>, OP::template PropagateStatistics<timestamp_t>);
729: }
730: 
731: void AddGenericTimePartOperator(BuiltinFunctions &set, const string &name, scalar_function_t date_func,
732:                                 scalar_function_t ts_func, scalar_function_t interval_func, scalar_function_t time_func,
733:                                 function_statistics_t date_stats, function_statistics_t ts_stats,
734:                                 function_statistics_t time_stats) {
735: 	ScalarFunctionSet operator_set(name);
736: 	operator_set.AddFunction(
737: 	    ScalarFunction({LogicalType::DATE}, LogicalType::BIGINT, move(date_func), false, nullptr, nullptr, date_stats));
738: 	operator_set.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::BIGINT, move(ts_func), false,
739: 	                                        nullptr, nullptr, ts_stats));
740: 	operator_set.AddFunction(ScalarFunction({LogicalType::INTERVAL}, LogicalType::BIGINT, move(interval_func)));
741: 	operator_set.AddFunction(
742: 	    ScalarFunction({LogicalType::TIME}, LogicalType::BIGINT, move(time_func), false, nullptr, nullptr, time_stats));
743: 	set.AddFunction(operator_set);
744: }
745: 
746: template <class OP>
747: static void AddTimePartOperator(BuiltinFunctions &set, string name) {
748: 	AddGenericTimePartOperator(
749: 	    set, name, ScalarFunction::UnaryFunction<date_t, int64_t, OP>,
750: 	    ScalarFunction::UnaryFunction<timestamp_t, int64_t, OP>, ScalarFunction::UnaryFunction<interval_t, int64_t, OP>,
751: 	    ScalarFunction::UnaryFunction<dtime_t, int64_t, OP>, OP::template PropagateStatistics<date_t>,
752: 	    OP::template PropagateStatistics<timestamp_t>, OP::template PropagateStatistics<dtime_t>);
753: }
754: 
755: struct LastDayOperator {
756: 	template <class TA, class TR>
757: 	static inline TR Operation(TA input) {
758: 		int32_t yyyy, mm, dd;
759: 		Date::Convert(input, yyyy, mm, dd);
760: 		yyyy += (mm / 12);
761: 		mm %= 12;
762: 		++mm;
763: 		return Date::FromDate(yyyy, mm, 1) - 1;
764: 	}
765: };
766: 
767: template <>
768: date_t LastDayOperator::Operation(timestamp_t input) {
769: 	return LastDayOperator::Operation<date_t, date_t>(Timestamp::GetDate(input));
770: }
771: 
772: struct MonthNameOperator {
773: 	template <class TA, class TR>
774: 	static inline TR Operation(TA input) {
775: 		return Date::MONTH_NAMES[DatePart::MonthOperator::Operation<TA, int64_t>(input) - 1];
776: 	}
777: };
778: 
779: struct DayNameOperator {
780: 	template <class TA, class TR>
781: 	static inline TR Operation(TA input) {
782: 		return Date::DAY_NAMES[DatePart::DayOfWeekOperator::Operation<TA, int64_t>(input)];
783: 	}
784: };
785: 
786: void DatePartFun::RegisterFunction(BuiltinFunctions &set) {
787: 	// register the individual operators
788: 	AddGenericDatePartOperator(set, "year", LastYearFunction<date_t>, LastYearFunction<timestamp_t>,
789: 	                           ScalarFunction::UnaryFunction<interval_t, int64_t, DatePart::YearOperator>,
790: 	                           DatePart::YearOperator::PropagateStatistics<date_t>,
791: 	                           DatePart::YearOperator::PropagateStatistics<timestamp_t>);
792: 	AddDatePartOperator<DatePart::MonthOperator>(set, "month");
793: 	AddDatePartOperator<DatePart::DayOperator>(set, "day");
794: 	AddDatePartOperator<DatePart::DecadeOperator>(set, "decade");
795: 	AddDatePartOperator<DatePart::CenturyOperator>(set, "century");
796: 	AddDatePartOperator<DatePart::MilleniumOperator>(set, "millennium");
797: 	AddDatePartOperator<DatePart::QuarterOperator>(set, "quarter");
798: 	AddDatePartOperator<DatePart::DayOfWeekOperator>(set, "dayofweek");
799: 	AddDatePartOperator<DatePart::ISODayOfWeekOperator>(set, "isodow");
800: 	AddDatePartOperator<DatePart::DayOfYearOperator>(set, "dayofyear");
801: 	AddDatePartOperator<DatePart::WeekOperator>(set, "week");
802: 	AddTimePartOperator<DatePart::EpochOperator>(set, "epoch");
803: 	AddTimePartOperator<DatePart::MicrosecondsOperator>(set, "microsecond");
804: 	AddTimePartOperator<DatePart::MillisecondsOperator>(set, "millisecond");
805: 	AddTimePartOperator<DatePart::SecondsOperator>(set, "second");
806: 	AddTimePartOperator<DatePart::MinutesOperator>(set, "minute");
807: 	AddTimePartOperator<DatePart::HoursOperator>(set, "hour");
808: 
809: 	//  register combinations
810: 	AddDatePartOperator<DatePart::YearWeekOperator>(set, "yearweek");
811: 
812: 	//  register various aliases
813: 	AddDatePartOperator<DatePart::DayOperator>(set, "dayofmonth");
814: 	AddDatePartOperator<DatePart::DayOfWeekOperator>(set, "weekday");
815: 	AddDatePartOperator<DatePart::WeekOperator>(set, "weekofyear"); //  Note that WeekOperator is ISO-8601, not US
816: 
817: 	//  register the last_day function
818: 	ScalarFunctionSet last_day("last_day");
819: 	last_day.AddFunction(ScalarFunction({LogicalType::DATE}, LogicalType::DATE,
820: 	                                    ScalarFunction::UnaryFunction<date_t, date_t, LastDayOperator>));
821: 	last_day.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::DATE,
822: 	                                    ScalarFunction::UnaryFunction<timestamp_t, date_t, LastDayOperator>));
823: 	set.AddFunction(last_day);
824: 
825: 	//  register the monthname function
826: 	ScalarFunctionSet monthname("monthname");
827: 	monthname.AddFunction(ScalarFunction({LogicalType::DATE}, LogicalType::VARCHAR,
828: 	                                     ScalarFunction::UnaryFunction<date_t, string_t, MonthNameOperator>));
829: 	monthname.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::VARCHAR,
830: 	                                     ScalarFunction::UnaryFunction<timestamp_t, string_t, MonthNameOperator>));
831: 	set.AddFunction(monthname);
832: 
833: 	//  register the dayname function
834: 	ScalarFunctionSet dayname("dayname");
835: 	dayname.AddFunction(ScalarFunction({LogicalType::DATE}, LogicalType::VARCHAR,
836: 	                                   ScalarFunction::UnaryFunction<date_t, string_t, DayNameOperator>));
837: 	dayname.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::VARCHAR,
838: 	                                   ScalarFunction::UnaryFunction<timestamp_t, string_t, DayNameOperator>));
839: 	set.AddFunction(dayname);
840: 
841: 	// finally the actual date_part function
842: 	ScalarFunctionSet date_part("date_part");
843: 	date_part.AddFunction(
844: 	    ScalarFunction({LogicalType::VARCHAR, LogicalType::DATE}, LogicalType::BIGINT, DatePartFunction<date_t>));
845: 	date_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::TIMESTAMP}, LogicalType::BIGINT,
846: 	                                     DatePartFunction<timestamp_t>));
847: 	date_part.AddFunction(
848: 	    ScalarFunction({LogicalType::VARCHAR, LogicalType::TIME}, LogicalType::BIGINT, DatePartFunction<dtime_t>));
849: 	date_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::INTERVAL}, LogicalType::BIGINT,
850: 	                                     DatePartFunction<interval_t>));
851: 	set.AddFunction(date_part);
852: 	date_part.name = "datepart";
853: 	set.AddFunction(date_part);
854: }
855: 
856: } // namespace duckdb
[end of src/function/scalar/date/date_part.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: