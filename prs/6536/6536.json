{
  "repo": "duckdb/duckdb",
  "pull_number": 6536,
  "instance_id": "duckdb__duckdb-6536",
  "issue_numbers": [
    "6506"
  ],
  "base_commit": "7813eea9266bf255f532b7b10791ac5bf13c2724",
  "patch": "diff --git a/tools/rpkg/R/backend-dbplyr__duckdb_connection.R b/tools/rpkg/R/backend-dbplyr__duckdb_connection.R\nindex fe1e15f065b1..95bab831840c 100644\n--- a/tools/rpkg/R/backend-dbplyr__duckdb_connection.R\n+++ b/tools/rpkg/R/backend-dbplyr__duckdb_connection.R\n@@ -391,7 +391,7 @@ dbplyr_fill0.duckdb_connection <- function(.con, .data, cols_to_fill, order_by_c\n # @param cache Enable object cache for parquet files\n tbl.duckdb_connection <- function(src, from, cache = FALSE, ...) {\n   ident_q <- pkg_method(\"ident_q\", \"dbplyr\")\n-  if (!DBI::dbExistsTable(src, from)) from <- ident_q(from)\n+  if (!inherits(from, \"sql\") & !DBI::dbExistsTable(src, from)) from <- ident_q(from)\n   if (cache) DBI::dbExecute(src, \"PRAGMA enable_object_cache\")\n   NextMethod(\"tbl\")\n }\n",
  "test_patch": "diff --git a/tools/rpkg/tests/testthat/test_tbl__duckdb_connection.R b/tools/rpkg/tests/testthat/test_tbl__duckdb_connection.R\nindex fd57e02e146c..f0bb07d82bd6 100644\n--- a/tools/rpkg/tests/testthat/test_tbl__duckdb_connection.R\n+++ b/tools/rpkg/tests/testthat/test_tbl__duckdb_connection.R\n@@ -63,4 +63,13 @@ test_that(\"Other replacement scans or functions can be registered with dplyr::tb\n   expect_true(obj %>% dplyr::filter(keyword_name == \"all\") %>% dplyr::count() %>% dplyr::collect() == 1)\n })\n \n+test_that(\"Strings tagged as SQL will be handled correctly with dplyr::tbl()\", {\n+  con <- DBI::dbConnect(duckdb())\n+  on.exit(DBI::dbDisconnect(con, shutdown = TRUE))\n+  \n+  rs <- dplyr::tbl(con, dplyr::sql(\"SELECT 1\"))\n+  expect_true(inherits(rs, \"tbl_duckdb_connection\"))\n+  expect_true(rs %>% dplyr::collect() == 1)\n+})\n+\n rm(`%>%`)\n",
  "problem_statement": "Trouble creating a DuckDB table with `dbplyr::sql`\n### What happens?\n\nWhen attempting to use dbplyr::sql to create a dplyr::tbl using a duckdb connection, I receive the following error:\r\n\r\n```\r\nError: Parser Error: syntax error at or near \"SELECT\"\r\nLINE 2: FROM SELECT * FROM items AS q01\r\n```\r\n\r\nOriginally raised the issue in the dbplyr repo, but they asked me to ask here instead: https://github.com/tidyverse/dbplyr/issues/1173\n\n### To Reproduce\n\n```r\r\n# Creating connection and data\r\ncon <- DBI::dbConnect(duckdb::duckdb(), dbdir = \":memory:\")\r\nDBI::dbExecute(con, \"CREATE TABLE items(item VARCHAR, value DECIMAL(10,2), count INTEGER)\")\r\nDBI::dbExecute(con, \"INSERT INTO items VALUES ('jeans', 20.0, 1), ('hammer', 42.2, 2)\")\r\n\r\n# Confirming data is in the db\r\nDBI::dbGetQuery(con, \"SELECT * FROM items\")\r\n\r\n# Works\r\ndplyr::tbl(con, \"items\")\r\n\r\n# Does not work\r\ndplyr::tbl(con, dbplyr::sql(\"SELECT * FROM items\"))\r\n```\r\n\r\nIn other languages, this is not an issue, and it's worth noting that this issue is resolved by wrapping the SQL in parentheses (e.g. `dplyr::tbl(con, dbplyr::sql(\"(SELECT * FROM items)\"))`.\n\n### OS:\n\nx86\n\n### DuckDB Version:\n\n0.7.0\n\n### DuckDB Client:\n\nR\n\n### Full Name:\n\nChris Cardillo\n\n### Affiliation:\n\nmaintainer of the dbooper R package (chriscardillo/dbcooper)\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Thank you for the report.\r\n\r\nCurrently DuckDB's `tbl`-method is tailored (different from the `dbplyr`'s generic), because it checks if the string provided to it is corresponding to the database table and if not removes the quotes that `dbplyr` will add there otherwise in order to allow replacement scans and DuckDB functions to work directly (such as `dplyr::tbl(con, \"read_parquet('test.parquet')\")` ).\r\n\r\nCould you please add `debug=TRUE` to your connection (i.e. use  `con <- DBI::dbConnect(duckdb::duckdb(), debug=TRUE)` ) and run the repro again and with the \"parentheses added\" version. That will show where the problem occurs in terms of generated sql.\r\n\r\nIs there some specific reason that you could't use parenthesis there (wouldn't that work with `dbplyr`'s generic and therefore with other backends too) or create a view or temporary table before using `tbl`?\nRan without parenthesis:\r\n\r\n```\r\nQ SELECT 1\r\nQ SELECT * FROM \"SELECT * FROM items\" WHERE FALSE\r\nQ SELECT *\r\nFROM SELECT * FROM items AS q01\r\nWHERE (0 = 1)\r\n```\r\n\r\nRan with parentheses:\r\n\r\n```\r\nQ SELECT 1\r\nQ SELECT * FROM \"(SELECT * FROM items)\" WHERE FALSE\r\nQ SELECT *\r\nFROM (SELECT * FROM items) AS q02\r\nWHERE (0 = 1)\r\nQ SELECT *\r\nFROM (SELECT * FROM items)\r\nLIMIT 11\r\n```\r\n\r\nIt's the last `FROM` where the issue is occurring.\r\n\r\n> Is there some specific reason that you could't use parenthesis there.\r\n\r\nThere is no reason I cannot use parentheses there, and to alleviate the issue I did just use the parentheses there, but because this behavior was unexpected, relative to running the same statement (no parentheses) with three other SQL dialects (Postgres, SQLite, Snowflake), I raised it as a bug. I just wanted to bring the behavior to your attention, should it be something you would want to remediate.\r\n\r\nI will still be a big fan of DuckDB either way :grin:\nThanks! I took a closer look at the issue and it is indeed caused by the `tbl`-method I contributed to the DuckDB R client. I will create a PR that fixes this issue and leave it up to the core team to decide what to do with it.",
  "created_at": "2023-03-02T18:00:31Z"
}