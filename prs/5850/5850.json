{
  "repo": "duckdb/duckdb",
  "pull_number": 5850,
  "instance_id": "duckdb__duckdb-5850",
  "issue_numbers": [
    "5782"
  ],
  "base_commit": "8fa1b6e78631a8f566b9448cb99d9fe8918ec22b",
  "patch": "diff --git a/data/csv/leading_zeros.csv b/data/csv/leading_zeros.csv\nnew file mode 100644\nindex 000000000000..d14973e9d4db\n--- /dev/null\n+++ b/data/csv/leading_zeros.csv\n@@ -0,0 +1,7 @@\n+CODGEO,NAISD14,NAISD15,NAISD16,NAISD17,NAISD18,NAISD19,NAISD20\n+09001,0,0,0,1,1,1,0\n+09002,6,4,4,6,7,3,0\n+09003,4,1,4,0,1,1,3\n+09004,0,1,1,2,1,2,1\n+09005,2,1,0,2,0,1,0\n+09006,0,0,0,0,0,0,0\n\\ No newline at end of file\ndiff --git a/data/csv/leading_zeros2.csv b/data/csv/leading_zeros2.csv\nnew file mode 100644\nindex 000000000000..1347db6fa22e\n--- /dev/null\n+++ b/data/csv/leading_zeros2.csv\n@@ -0,0 +1,6 @@\n+comune,codice_regione,codice_provincia,codice_comune,denominazione_comune,sigla_provincia,data_entrata_in_carica\n+030151360,03,015,1360,POLPENAZZE DEL GARDA,BS,13/10/2021\n+030120530,03,012,0530,CAROBBIO DEGLI ANGELI,BG,04/10/2021\n+020040580,02,004,0580,SAINT-DENIS,AO,23/09/2020\n+030150870,03,015,0870,LOSINE,BS,04/10/2021\n+190480090,19,048,0090,CAPO D'ORLANDO,ME,27/10/2021\n\\ No newline at end of file\ndiff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp\nindex af83b4a369aa..e6f2e068be5e 100644\n--- a/src/common/operator/cast_operators.cpp\n+++ b/src/common/operator/cast_operators.cpp\n@@ -1050,22 +1050,23 @@ static bool TryIntegerCast(const char *buf, idx_t len, T &result, bool strict) {\n \t\t}\n \t\treturn IntegerCastLoop<T, true, ALLOW_EXPONENT, OP>(buf, len, result, strict);\n \t}\n-\t// If it starts with 0x or 0X, we parse it as a hex value\n-\telse if (len > 1 && *buf == '0' && (buf[1] == 'x' || buf[1] == 'X')) {\n-\t\t// Skip the 0x\n-\t\tbuf++;\n-\t\tlen--;\n-\t\treturn IntegerHexCastLoop<T, false, false, OP>(buf, len, result, strict);\n-\t}\n-\t// If it starts with 0b or 0B, we parse it as a binary value\n-\telse if (len > 1 && *buf == '0' && (buf[1] == 'b' || buf[1] == 'B')) {\n-\t\t// Skip the 0b\n-\t\tbuf++;\n-\t\tlen--;\n-\t\treturn IntegerBinaryCastLoop<T, false, false, OP>(buf, len, result, strict);\n-\t} else {\n-\t\treturn IntegerCastLoop<T, false, ALLOW_EXPONENT, OP>(buf, len, result, strict);\n+\tif (len > 1 && *buf == '0') {\n+\t\tif (buf[1] == 'x' || buf[1] == 'X') {\n+\t\t\t// If it starts with 0x or 0X, we parse it as a hex value\n+\t\t\tbuf++;\n+\t\t\tlen--;\n+\t\t\treturn IntegerHexCastLoop<T, false, false, OP>(buf, len, result, strict);\n+\t\t} else if (buf[1] == 'b' || buf[1] == 'B') {\n+\t\t\t// If it starts with 0b or 0B, we parse it as a binary value\n+\t\t\tbuf++;\n+\t\t\tlen--;\n+\t\t\treturn IntegerBinaryCastLoop<T, false, false, OP>(buf, len, result, strict);\n+\t\t} else if (strict && StringUtil::CharacterIsDigit(buf[1])) {\n+\t\t\t// leading zeros are not allowed in strict mode\n+\t\t\treturn false;\n+\t\t}\n \t}\n+\treturn IntegerCastLoop<T, false, ALLOW_EXPONENT, OP>(buf, len, result, strict);\n }\n \n template <typename T, bool IS_SIGNED = true>\n@@ -1170,6 +1171,12 @@ static bool TryDoubleCast(const char *buf, idx_t len, T &result, bool strict) {\n \t\tbuf++;\n \t\tlen--;\n \t}\n+\tif (strict && len >= 2) {\n+\t\tif (buf[0] == '0' && StringUtil::CharacterIsDigit(buf[1])) {\n+\t\t\t// leading zeros are not allowed in strict mode\n+\t\t\treturn false;\n+\t\t}\n+\t}\n \tauto endptr = buf + len;\n \tauto parse_result = duckdb_fast_float::from_chars(buf, buf + len, result);\n \tif (parse_result.ec != std::errc()) {\n",
  "test_patch": "diff --git a/test/sql/copy/csv/leading_zeros_autodetect.test b/test/sql/copy/csv/leading_zeros_autodetect.test\nnew file mode 100644\nindex 000000000000..446bf8d1562d\n--- /dev/null\n+++ b/test/sql/copy/csv/leading_zeros_autodetect.test\n@@ -0,0 +1,47 @@\n+# name: test/sql/copy/csv/leading_zeros_autodetect.test\n+# description: Issue #5782: Test leading zeros auto-detect\n+# group: [csv]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE leading_zeros AS SELECT * FROM read_csv_auto('data/csv/leading_zeros.csv')\n+\n+query I\n+SELECT CODGEO FROM leading_zeros LIMIT 1;\n+----\n+09001\n+\n+query I\n+SELECT typeof(CODGEO) FROM leading_zeros LIMIT 1;\n+----\n+VARCHAR\n+\n+statement ok\n+CREATE TABLE leading_zeros2 AS SELECT * FROM read_csv_auto('data/csv/leading_zeros2.csv')\n+\n+query IIIIIII\n+SELECT * FROM leading_zeros2;\n+----\n+030151360\t03\t015\t1360\tPOLPENAZZE DEL GARDA\tBS\t2021-10-13\n+030120530\t03\t012\t0530\tCAROBBIO DEGLI ANGELI\tBG\t2021-10-04\n+020040580\t02\t004\t0580\tSAINT-DENIS\tAO\t2020-09-23\n+030150870\t03\t015\t0870\tLOSINE\tBS\t2021-10-04\n+190480090\t19\t048\t0090\tCAPO D'ORLANDO\tME\t2021-10-27\n+\n+query III\n+SELECT typeof(comune), typeof(codice_regione), typeof(codice_provincia) FROM leading_zeros2 LIMIT 1;\n+----\n+VARCHAR\tVARCHAR\tVARCHAR\n+\n+# we can still cast integers with leading zeros normally\n+query I\n+select '09001'::int;\n+----\n+9001\n+\n+query I\n+select '00009001'::int;\n+----\n+9001\ndiff --git a/tools/pythonpkg/tests/fast/data/integers.csv b/tools/pythonpkg/tests/fast/data/integers.csv\nindex e5eb90bd68bf..763c61cd6d68 100644\n--- a/tools/pythonpkg/tests/fast/data/integers.csv\n+++ b/tools/pythonpkg/tests/fast/data/integers.csv\n@@ -1,2 +1,2 @@\n-1;10;00\n+1;10;0\n 2;50;30\n\\ No newline at end of file\n",
  "problem_statement": "read_csv_auto() reads a varchar column (starting with '0') as integer \n### What happens?\n\nMy csv file contains a column with zip codes, some starting with a '0':\r\n![image](https://user-images.githubusercontent.com/17407796/209432957-54e7ea06-a05e-4268-9a4f-528f9db2b33e.png)\r\n\r\nread_csv_auto() convert that column as integer, i exepectd a varchar, the leading '0' is lost\r\n![image](https://user-images.githubusercontent.com/17407796/209432994-63cbc91c-561d-412c-9f53-1fb90fc04d59.png)\r\n\n\n### To Reproduce\n\nSELECT * FROM read_csv_auto('test.csv');\r\n\r\n\r\n[test.csv](https://github.com/duckdb/duckdb/files/10298425/test.csv)\r\n\n\n### OS:\n\nx64\n\n### DuckDB Version:\n\n0.6\n\n### DuckDB Client:\n\nDBeaver\n\n### Full Name:\n\neric mauviere\n\n### Affiliation:\n\nicem7\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "You likely want to use `read_csv` and specify the columns and their types explicitly\r\nhttps://duckdb.org/docs/data/csv\n> You likely want to use `read_csv` and specify the columns and their types explicitly https://duckdb.org/docs/data/csv\r\n\r\nWell, i know i could, but i love the simplicity of read_csv_auto(), which is also used as a default in many third parties tools (Observable, Tad...)\nAh I see, but this requires context, there are definitely situations where this is the behavior you would want\r\nand besides that you can fix it up yourself with something like `format` (if the length of the CODGEO column is a constant)\nThanks once again for your reactivity! I understand, but i don't know other contexts where it would be appropriate for a 09001 code value to be altered into a number such as 9001. \r\n\r\nWith R for instance, readr::read_delim() reads properly such a file, without any particular specification. \nI am too fond of the R package `readr` and its nice well-chosen defaults for parsing CSV and similar formats - especially its convenient type guessing for column types. \r\n\r\nWhile there are parameters such as ALL_VARCHAR and SAMPLE_SIZE available for use with duckdb's `read_csv_auto` (where the first one disables the type guessing entirely for all columns), it seems those options wouldn't help much in a use case such as this one, where one would like for strings starting with leading zeroes by default to be guessed to be varchar rather than numerical.\r\n\r\nAnother nice thing that `readr` allows for is to specify column types for a subset of the columns and a default for all the rest, making it less onerous in comparison with having to specify all the types for all the columns. Also, when required, the column type specification can be made in a compact way. For [example](https://readr.tidyverse.org/reference/read_delim.html): `read_csv('test.csv', col_types = 'c??')` reads the first column as characters and guesses the type for the next two columns.",
  "created_at": "2023-01-07T18:50:18Z"
}