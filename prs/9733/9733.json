{
  "repo": "duckdb/duckdb",
  "pull_number": 9733,
  "instance_id": "duckdb__duckdb-9733",
  "issue_numbers": [
    "9717",
    "9717"
  ],
  "base_commit": "31f338d7bc82d4947bc77aca9abec3f5ae650587",
  "patch": "diff --git a/src/include/duckdb/storage/statistics/base_statistics.hpp b/src/include/duckdb/storage/statistics/base_statistics.hpp\nindex c2de957fa92a..2d9fbd7dbab0 100644\n--- a/src/include/duckdb/storage/statistics/base_statistics.hpp\n+++ b/src/include/duckdb/storage/statistics/base_statistics.hpp\n@@ -77,12 +77,20 @@ class BaseStatistics {\n \tvoid Set(StatsInfo info);\n \tvoid CombineValidity(BaseStatistics &left, BaseStatistics &right);\n \tvoid CopyValidity(BaseStatistics &stats);\n-\tinline void SetHasNull() {\n+\t//! Set that the CURRENT level can have null values\n+\t//! Note that this is not correct for nested types unless this information is propagated in a different manner\n+\t//! Use Set(StatsInfo::CAN_HAVE_NULL_VALUES) in the general case\n+\tinline void SetHasNullFast() {\n \t\thas_null = true;\n \t}\n-\tinline void SetHasNoNull() {\n+\t//! Set that the CURRENT level can have valiod values\n+\t//! Note that this is not correct for nested types unless this information is propagated in a different manner\n+\t//! Use Set(StatsInfo::CAN_HAVE_VALID_VALUES) in the general case\n+\tinline void SetHasNoNullFast() {\n \t\thas_no_null = true;\n \t}\n+\tvoid SetHasNull();\n+\tvoid SetHasNoNull();\n \n \tvoid Merge(const BaseStatistics &other);\n \ndiff --git a/src/storage/compression/validity_uncompressed.cpp b/src/storage/compression/validity_uncompressed.cpp\nindex feb46b7a6aa6..7dfa6bd1ad99 100644\n--- a/src/storage/compression/validity_uncompressed.cpp\n+++ b/src/storage/compression/validity_uncompressed.cpp\n@@ -418,7 +418,7 @@ idx_t ValidityAppend(CompressionAppendState &append_state, ColumnSegment &segmen\n \tif (data.validity.AllValid()) {\n \t\t// no null values: skip append\n \t\tsegment.count += append_count;\n-\t\tvalidity_stats.SetHasNoNull();\n+\t\tvalidity_stats.SetHasNoNullFast();\n \t\treturn append_count;\n \t}\n \n@@ -427,9 +427,9 @@ idx_t ValidityAppend(CompressionAppendState &append_state, ColumnSegment &segmen\n \t\tauto idx = data.sel->get_index(offset + i);\n \t\tif (!data.validity.RowIsValidUnsafe(idx)) {\n \t\t\tmask.SetInvalidUnsafe(segment.count + i);\n-\t\t\tvalidity_stats.SetHasNull();\n+\t\t\tvalidity_stats.SetHasNullFast();\n \t\t} else {\n-\t\t\tvalidity_stats.SetHasNoNull();\n+\t\t\tvalidity_stats.SetHasNoNullFast();\n \t\t}\n \t}\n \tsegment.count += append_count;\ndiff --git a/src/storage/statistics/base_statistics.cpp b/src/storage/statistics/base_statistics.cpp\nindex dfa389b3fcc6..9d03c29581bd 100644\n--- a/src/storage/statistics/base_statistics.cpp\n+++ b/src/storage/statistics/base_statistics.cpp\n@@ -255,26 +255,44 @@ void BaseStatistics::CopyBase(const BaseStatistics &other) {\n void BaseStatistics::Set(StatsInfo info) {\n \tswitch (info) {\n \tcase StatsInfo::CAN_HAVE_NULL_VALUES:\n-\t\thas_null = true;\n+\t\tSetHasNull();\n \t\tbreak;\n \tcase StatsInfo::CANNOT_HAVE_NULL_VALUES:\n \t\thas_null = false;\n \t\tbreak;\n \tcase StatsInfo::CAN_HAVE_VALID_VALUES:\n-\t\thas_no_null = true;\n+\t\tSetHasNoNull();\n \t\tbreak;\n \tcase StatsInfo::CANNOT_HAVE_VALID_VALUES:\n \t\thas_no_null = false;\n \t\tbreak;\n \tcase StatsInfo::CAN_HAVE_NULL_AND_VALID_VALUES:\n-\t\thas_null = true;\n-\t\thas_no_null = true;\n+\t\tSetHasNull();\n+\t\tSetHasNoNull();\n \t\tbreak;\n \tdefault:\n \t\tthrow InternalException(\"Unrecognized StatsInfo for BaseStatistics::Set\");\n \t}\n }\n \n+void BaseStatistics::SetHasNull() {\n+\thas_null = true;\n+\tif (type.InternalType() == PhysicalType::STRUCT) {\n+\t\tfor (idx_t c = 0; c < StructType::GetChildCount(type); c++) {\n+\t\t\tStructStats::GetChildStats(*this, c).SetHasNull();\n+\t\t}\n+\t}\n+}\n+\n+void BaseStatistics::SetHasNoNull() {\n+\thas_no_null = true;\n+\tif (type.InternalType() == PhysicalType::STRUCT) {\n+\t\tfor (idx_t c = 0; c < StructType::GetChildCount(type); c++) {\n+\t\t\tStructStats::GetChildStats(*this, c).SetHasNoNull();\n+\t\t}\n+\t}\n+}\n+\n void BaseStatistics::CombineValidity(BaseStatistics &left, BaseStatistics &right) {\n \thas_null = left.has_null || right.has_null;\n \thas_no_null = left.has_no_null || right.has_no_null;\ndiff --git a/src/storage/table/struct_column_data.cpp b/src/storage/table/struct_column_data.cpp\nindex cc9b64320873..7061510dfa32 100644\n--- a/src/storage/table/struct_column_data.cpp\n+++ b/src/storage/table/struct_column_data.cpp\n@@ -239,11 +239,11 @@ struct StructColumnCheckpointState : public ColumnCheckpointState {\n \n public:\n \tunique_ptr<BaseStatistics> GetStatistics() override {\n-\t\tauto stats = StructStats::CreateEmpty(column_data.type);\n+\t\tD_ASSERT(global_stats);\n \t\tfor (idx_t i = 0; i < child_states.size(); i++) {\n-\t\t\tStructStats::SetChildStats(stats, i, child_states[i]->GetStatistics());\n+\t\t\tStructStats::SetChildStats(*global_stats, i, child_states[i]->GetStatistics());\n \t\t}\n-\t\treturn stats.ToUnique();\n+\t\treturn std::move(global_stats);\n \t}\n \n \tvoid WriteDataPointers(RowGroupWriter &writer, Serializer &serializer) override {\ndiff --git a/src/storage/table/update_segment.cpp b/src/storage/table/update_segment.cpp\nindex 3e1cab7d4791..c831e2a2bd63 100644\n--- a/src/storage/table/update_segment.cpp\n+++ b/src/storage/table/update_segment.cpp\n@@ -895,7 +895,7 @@ idx_t UpdateValidityStatistics(UpdateSegment *segment, SegmentStatistics &stats,\n \tif (!mask.AllValid() && !validity.CanHaveNull()) {\n \t\tfor (idx_t i = 0; i < count; i++) {\n \t\t\tif (!mask.RowIsValid(i)) {\n-\t\t\t\tvalidity.SetHasNull();\n+\t\t\t\tvalidity.SetHasNullFast();\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n",
  "test_patch": "diff --git a/test/sql/types/nested/struct/struct_is_null.test b/test/sql/types/nested/struct/struct_is_null.test\nnew file mode 100644\nindex 000000000000..300836a50b65\n--- /dev/null\n+++ b/test/sql/types/nested/struct/struct_is_null.test\n@@ -0,0 +1,17 @@\n+# name: test/sql/types/nested/struct/struct_is_null.test\n+# description: Test structs with IS NULL\n+# group: [struct]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create table tbl (data struct(str varchar)[]);\n+\n+statement ok\n+insert into tbl (data) values ([struct_pack(str := 'value')]), (null), (null), (null);\n+\n+query I\n+select data[1].str as str from tbl where str is not null;\n+----\n+value\n",
  "problem_statement": "Unable to correctly filter out rows with null values.\n### What happens?\r\n\r\nwhen using `IS NOT NULL` to filter non-null values, the output data still contains `NULL`.\r\n\r\n```sql\r\n.nullvalue NULL\r\ncreate table tbl (data struct(str varchar)[]);\r\ninsert into tbl (data) values ([struct_pack(str := 'value')]), (null), (null), (null);\r\n-- still contains NULL\r\nselect data[1].str as str from tbl where str is not null;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   str   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 value   \u2502\r\n\u2502 NULL    \u2502\r\n\u2502 NULL    \u2502\r\n\u2502 NULL    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### To Reproduce\r\n\r\nSee above\r\n\r\n### OS:\r\n\r\nubuntu 2004\r\n\r\n### DuckDB Version:\r\n\r\nv0.9.2\r\n\r\n### DuckDB Client:\r\n\r\ncli\r\n\r\n### Full Name:\r\n\r\nYiyuan Liu\r\n\r\n### Affiliation:\r\n\r\nHigh-Flyer AI\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\nUnable to correctly filter out rows with null values.\n### What happens?\r\n\r\nwhen using `IS NOT NULL` to filter non-null values, the output data still contains `NULL`.\r\n\r\n```sql\r\n.nullvalue NULL\r\ncreate table tbl (data struct(str varchar)[]);\r\ninsert into tbl (data) values ([struct_pack(str := 'value')]), (null), (null), (null);\r\n-- still contains NULL\r\nselect data[1].str as str from tbl where str is not null;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   str   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 value   \u2502\r\n\u2502 NULL    \u2502\r\n\u2502 NULL    \u2502\r\n\u2502 NULL    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### To Reproduce\r\n\r\nSee above\r\n\r\n### OS:\r\n\r\nubuntu 2004\r\n\r\n### DuckDB Version:\r\n\r\nv0.9.2\r\n\r\n### DuckDB Client:\r\n\r\ncli\r\n\r\n### Full Name:\r\n\r\nYiyuan Liu\r\n\r\n### Affiliation:\r\n\r\nHigh-Flyer AI\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2023-11-20T14:14:00Z"
}