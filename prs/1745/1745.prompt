You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Breaking change in sum handling NAs?
**What does happen?**
Getting different values in 0.2.5 and 0.2.6

**What should happen?**
Should be the same

**To Reproduce**
Following instructions on https://github.com/h2oai/db-benchmark
Generate mentioned data.
Run mentioned queries,
Run checksum queries.

Preview of results:
```r
library(data.table)
t = fread("https://h2oai.github.io/db-benchmark/time.csv")
t[solution=="duckdb"
  ][.(c("groupby","join"), c("G1_1e7_1e2_5_0","J1_1e7_NA_5_0"), c("sum v3 count by id1:id6","small inner on int")), on=c("task","data","question")
    ][, .(task, data, question, version, run, chk)]
#      task           data                question version run                 chk
#1: groupby G1_1e7_1e2_5_0 sum v3 count by id1:id6   0.2.5   1  474969574;10000000
#2: groupby G1_1e7_1e2_5_0 sum v3 count by id1:id6   0.2.5   2  474969574;10000000
#3: groupby G1_1e7_1e2_5_0 sum v3 count by id1:id6   0.2.6   1  474832257;10000000
#4:    join  J1_1e7_NA_5_0      small inner on int   0.2.5   1 427503549;436095569
#5:    join  J1_1e7_NA_5_0      small inner on int   0.2.5   2 427503549;436095569
#6:    join  J1_1e7_NA_5_0      small inner on int   0.2.6   1 427370928;436095569
```

**Environment (please complete the following information):**
Ubuntu 16.04

**Before submitting**
- haven't yet tried to reproduce that interactively
- haven't tried on master because 0.2.6 is AFAIK near the to master.

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/storage/table/validity_segment.cpp]
1: #include "duckdb/storage/table/validity_segment.hpp"
2: #include "duckdb/storage/buffer_manager.hpp"
3: #include "duckdb/common/types/vector.hpp"
4: #include "duckdb/storage/statistics/validity_statistics.hpp"
5: 
6: namespace duckdb {
7: 
8: ValiditySegment::ValiditySegment(DatabaseInstance &db, idx_t row_start, block_id_t block_id)
9:     : UncompressedSegment(db, PhysicalType::BIT, row_start) {
10: 	// figure out how many vectors we want to store in this block
11: 
12: 	this->vector_size = ValidityMask::STANDARD_MASK_SIZE;
13: 	this->max_vector_count = Storage::BLOCK_SIZE / vector_size;
14: 	// FIXME: this is a fix for test/sql/storage/checkpointed_self_append_tinyint.test
15: 	// it is only required because of ToTemporary()
16: 	// this should be removed when ToTemporary() is removed
17: 	if (max_vector_count > 80) {
18: 		max_vector_count = 80;
19: 	}
20: 	auto &buffer_manager = BufferManager::GetBufferManager(db);
21: 	if (block_id == INVALID_BLOCK) {
22: 		// no block id specified: allocate a buffer for the uncompressed segment
23: 		this->block = buffer_manager.RegisterMemory(Storage::BLOCK_ALLOC_SIZE, false);
24: 		// pin the block and initialize
25: 		auto handle = buffer_manager.Pin(block);
26: 		memset(handle->node->buffer, 0xFF, Storage::BLOCK_SIZE);
27: 	} else {
28: 		this->block = buffer_manager.RegisterBlock(block_id);
29: 	}
30: }
31: 
32: ValiditySegment::~ValiditySegment() {
33: }
34: 
35: void ValiditySegment::InitializeScan(ColumnScanState &state) {
36: 	auto &buffer_manager = BufferManager::GetBufferManager(db);
37: 	state.primary_handle = buffer_manager.Pin(block);
38: }
39: 
40: void ValiditySegment::FetchRow(ColumnFetchState &state, row_t row_id, Vector &result, idx_t result_idx) {
41: 	D_ASSERT(row_id >= 0 && row_id < row_t(this->tuple_count));
42: 	auto &buffer_manager = BufferManager::GetBufferManager(db);
43: 	auto handle = buffer_manager.Pin(block);
44: 	ValidityMask mask((validity_t *)handle->node->buffer);
45: 	if (!mask.RowIsValidUnsafe(row_id)) {
46: 		FlatVector::SetNull(result, result_idx, true);
47: 	}
48: }
49: 
50: idx_t ValiditySegment::Append(SegmentStatistics &stats, VectorData &data, idx_t offset, idx_t vcount) {
51: 	idx_t append_count = MinValue<idx_t>(vcount, max_vector_count * STANDARD_VECTOR_SIZE - tuple_count);
52: 	if (data.validity.AllValid()) {
53: 		// no null values: skip append
54: 		tuple_count += append_count;
55: 		return append_count;
56: 	}
57: 	auto &buffer_manager = BufferManager::GetBufferManager(db);
58: 	auto handle = buffer_manager.Pin(block);
59: 
60: 	auto &validity_stats = (ValidityStatistics &)*stats.statistics;
61: 	ValidityMask mask((validity_t *)handle->node->buffer);
62: 	for (idx_t i = 0; i < append_count; i++) {
63: 		auto idx = data.sel->get_index(i);
64: 		if (!data.validity.RowIsValidUnsafe(idx)) {
65: 			mask.SetInvalidUnsafe(tuple_count + i);
66: 			validity_stats.has_null = true;
67: 		}
68: 	}
69: 	tuple_count += append_count;
70: 	return append_count;
71: }
72: 
73: void ValiditySegment::FetchBaseData(ColumnScanState &state, idx_t vector_index, Vector &result) {
74: #if STANDARD_VECTOR_SIZE >= 64
75: 	auto vector_ptr = state.primary_handle->node->buffer + vector_index * ValidityMask::STANDARD_MASK_SIZE;
76: 	ValidityMask vector_mask(vector_ptr);
77: 	if (!vector_mask.CheckAllValid(STANDARD_VECTOR_SIZE)) {
78: 		FlatVector::Validity(result).Copy(vector_mask, STANDARD_VECTOR_SIZE);
79: 	}
80: #else
81: 	idx_t base_tuple = vector_index * STANDARD_VECTOR_SIZE;
82: 	ValidityMask source_mask(state.primary_handle->node->buffer);
83: 	auto &target = FlatVector::Validity(result);
84: 	for (idx_t i = 0; i < STANDARD_VECTOR_SIZE; i++) {
85: 		target.Set(i, source_mask.RowIsValid(base_tuple + i));
86: 	}
87: #endif
88: }
89: 
90: void ValiditySegment::RevertAppend(idx_t start_row) {
91: 	idx_t start_bit = start_row - this->row_start;
92: 	UncompressedSegment::RevertAppend(start_row);
93: 
94: 	auto &buffer_manager = BufferManager::GetBufferManager(db);
95: 	auto handle = buffer_manager.Pin(block);
96: 	idx_t revert_start;
97: 	if (start_bit % 8 != 0) {
98: 		// handle sub-bit stuff (yay)
99: 		idx_t byte_pos = start_bit / 8;
100: 		idx_t bit_start = byte_pos * 8;
101: 		idx_t bit_end = (byte_pos + 1) * 8;
102: 		ValidityMask mask(handle->node->buffer + byte_pos);
103: 		for (idx_t i = start_bit; i < bit_end; i++) {
104: 			mask.SetValid(i - bit_start);
105: 		}
106: 		revert_start = bit_end / 8;
107: 	} else {
108: 		revert_start = start_bit / 8;
109: 	}
110: 	// for the rest, we just memset
111: 	memset(handle->node->buffer + revert_start, 0xFF, Storage::BLOCK_SIZE - revert_start);
112: }
113: 
114: } // namespace duckdb
[end of src/storage/table/validity_segment.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: