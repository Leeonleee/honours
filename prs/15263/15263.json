{
  "repo": "duckdb/duckdb",
  "pull_number": 15263,
  "instance_id": "duckdb__duckdb-15263",
  "issue_numbers": [
    "15261",
    "15261"
  ],
  "base_commit": "7e9bd28f0010bb82980e1c6c19a25b757ed4c1d7",
  "patch": "diff --git a/src/common/types.cpp b/src/common/types.cpp\nindex 7ec718928038..5c01b2692338 100644\n--- a/src/common/types.cpp\n+++ b/src/common/types.cpp\n@@ -711,6 +711,11 @@ bool LogicalType::IsComplete() const {\n \t\t\t\treturn true; // Missing or incorrect type info\n \t\t\t}\n \t\t\tbreak;\n+\t\tcase LogicalTypeId::ENUM:\n+\t\t\tif (!type.AuxInfo() || type.AuxInfo()->type != ExtraTypeInfoType::ENUM_TYPE_INFO) {\n+\t\t\t\treturn true; // Missing or incorrect type info\n+\t\t\t}\n+\t\t\tbreak;\n \t\tdefault:\n \t\t\treturn false;\n \t\t}\n@@ -1596,35 +1601,30 @@ const child_list_t<LogicalType> UnionType::CopyMemberTypes(const LogicalType &ty\n const string &UserType::GetCatalog(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::USER);\n \tauto info = type.AuxInfo();\n-\tD_ASSERT(info);\n \treturn info->Cast<UserTypeInfo>().catalog;\n }\n \n const string &UserType::GetSchema(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::USER);\n \tauto info = type.AuxInfo();\n-\tD_ASSERT(info);\n \treturn info->Cast<UserTypeInfo>().schema;\n }\n \n const string &UserType::GetTypeName(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::USER);\n \tauto info = type.AuxInfo();\n-\tD_ASSERT(info);\n \treturn info->Cast<UserTypeInfo>().user_type_name;\n }\n \n const vector<Value> &UserType::GetTypeModifiers(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::USER);\n \tauto info = type.AuxInfo();\n-\tD_ASSERT(info);\n \treturn info->Cast<UserTypeInfo>().user_type_modifiers;\n }\n \n vector<Value> &UserType::GetTypeModifiers(LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::USER);\n \tauto info = type.GetAuxInfoShrPtr();\n-\tD_ASSERT(info);\n \treturn info->Cast<UserTypeInfo>().user_type_modifiers;\n }\n \n@@ -1664,21 +1664,18 @@ const string EnumType::GetValue(const Value &val) {\n const Vector &EnumType::GetValuesInsertOrder(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::ENUM);\n \tauto info = type.AuxInfo();\n-\tD_ASSERT(info);\n \treturn info->Cast<EnumTypeInfo>().GetValuesInsertOrder();\n }\n \n idx_t EnumType::GetSize(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::ENUM);\n \tauto info = type.AuxInfo();\n-\tD_ASSERT(info);\n \treturn info->Cast<EnumTypeInfo>().GetDictSize();\n }\n \n PhysicalType EnumType::GetPhysicalType(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::ENUM);\n \tauto aux_info = type.AuxInfo();\n-\tD_ASSERT(aux_info);\n \tauto &info = aux_info->Cast<EnumTypeInfo>();\n \tD_ASSERT(info.GetEnumDictType() == EnumDictType::VECTOR_DICT);\n \treturn EnumTypeInfo::DictType(info.GetDictSize());\n@@ -1704,21 +1701,18 @@ bool LogicalType::IsJSONType() const {\n const LogicalType &ArrayType::GetChildType(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::ARRAY);\n \tauto info = type.AuxInfo();\n-\tD_ASSERT(info);\n \treturn info->Cast<ArrayTypeInfo>().child_type;\n }\n \n idx_t ArrayType::GetSize(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::ARRAY);\n \tauto info = type.AuxInfo();\n-\tD_ASSERT(info);\n \treturn info->Cast<ArrayTypeInfo>().size;\n }\n \n bool ArrayType::IsAnySize(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::ARRAY);\n \tauto info = type.AuxInfo();\n-\tD_ASSERT(info);\n \treturn info->Cast<ArrayTypeInfo>().size == 0;\n }\n \n@@ -1799,7 +1793,7 @@ idx_t AnyType::GetCastScore(const LogicalType &type) {\n LogicalType IntegerLiteral::GetType(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::INTEGER_LITERAL);\n \tauto info = type.AuxInfo();\n-\tD_ASSERT(info && info->type == ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO);\n+\tD_ASSERT(info->type == ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO);\n \treturn info->Cast<IntegerLiteralTypeInfo>().constant_value.type();\n }\n \n@@ -1814,7 +1808,7 @@ bool IntegerLiteral::FitsInType(const LogicalType &type, const LogicalType &targ\n \t}\n \t// we can cast to integral types if the constant value fits within that type\n \tauto info = type.AuxInfo();\n-\tD_ASSERT(info && info->type == ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO);\n+\tD_ASSERT(info->type == ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO);\n \tauto &literal_info = info->Cast<IntegerLiteralTypeInfo>();\n \tValue copy = literal_info.constant_value;\n \treturn copy.DefaultTryCastAs(target);\ndiff --git a/src/include/duckdb/common/types.hpp b/src/include/duckdb/common/types.hpp\nindex 72a9150150b7..5c2492f83969 100644\n--- a/src/include/duckdb/common/types.hpp\n+++ b/src/include/duckdb/common/types.hpp\n@@ -252,7 +252,7 @@ struct LogicalType {\n \tinline PhysicalType InternalType() const {\n \t\treturn physical_type_;\n \t}\n-\tinline const ExtraTypeInfo *AuxInfo() const {\n+\tinline const optional_ptr<ExtraTypeInfo> AuxInfo() const {\n \t\treturn type_info_.get();\n \t}\n \tinline bool IsNested() const {\ndiff --git a/src/planner/binder/tableref/bind_pivot.cpp b/src/planner/binder/tableref/bind_pivot.cpp\nindex a1b9789adf26..f81c09d3a24f 100644\n--- a/src/planner/binder/tableref/bind_pivot.cpp\n+++ b/src/planner/binder/tableref/bind_pivot.cpp\n@@ -422,6 +422,9 @@ unique_ptr<SelectNode> Binder::BindPivot(PivotRef &ref, vector<unique_ptr<Parsed\n \t\t\t\tthrow BinderException(ref, \"Pivot must reference an ENUM type: \\\"%s\\\" is of type \\\"%s\\\"\",\n \t\t\t\t                      pivot.pivot_enum, type.ToString());\n \t\t\t}\n+\t\t\tif (!type.IsComplete()) {\n+\t\t\t\tthrow BinderException(\"ENUM type is incomplete\");\n+\t\t\t}\n \t\t\tauto enum_size = EnumType::GetSize(type);\n \t\t\tfor (idx_t i = 0; i < enum_size; i++) {\n \t\t\t\tauto enum_value = EnumType::GetValue(Value::ENUM(i, type));\n",
  "test_patch": "diff --git a/test/fuzzer/public/pivot_empty_enum.test b/test/fuzzer/public/pivot_empty_enum.test\nnew file mode 100644\nindex 000000000000..89caa26ba7b7\n--- /dev/null\n+++ b/test/fuzzer/public/pivot_empty_enum.test\n@@ -0,0 +1,13 @@\n+# name: test/fuzzer/public/pivot_empty_enum.test\n+# description: Test pivot with an empty enum\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE t1 (c01 INT);\n+\n+statement error\n+PIVOT_WIDER t1 ON c01 IN ENUM;\n+----\n",
  "problem_statement": "DuckDB Segmentation Fault, with Assertion message:  \"types.cpp\" on line 1674: info\n### What happens?\r\n\r\nThe latest version of the DuckDB (latest main: v1.1.4-dev3226 07e3b42f75 and released version: v1.1.3 19864453f7) triggers Assertion Failure or Segmentation Fault when running the following SQL statement: \r\n\r\n```sql\r\nCREATE TABLE v00 (c01 INT);\r\nPIVOT_WIDER v00 AS ta02 ON ROW ( ) [ 'string' IN CASE WHEN 'string' THEN c01 END ] IN ENUM;\r\n```\r\n\r\nOn the latest main (v1.1.4-dev3226 07e3b42f75), getting crash stack trace: \r\n\r\n```\r\n#0  duckdb::EnumType::GetSize (type=...) at /home/duckdb/duckdb/src/common/types.cpp:1675\r\n#1  0x00000000027bd048 in duckdb::Binder::BindPivot (this=0x266133c0, ref=..., all_columns=...)\r\n    at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:425\r\n#2  0x00000000027dbc78 in duckdb::Binder::Bind (this=<optimized out>, ref=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:724\r\n#3  0x0000000002913e74 in duckdb::Binder::Bind (this=0x266133c0, ref=...) at /home/duckdb/duckdb/src/planner/binder.cpp:416\r\n#4  0x0000000004b4d5dc in duckdb::Binder::BindNode (this=0x266133c0, statement=...)\r\n    at /home/duckdb/duckdb/src/planner/binder/query_node/bind_select_node.cpp:371\r\n#5  0x0000000002911978 in duckdb::Binder::BindNode (this=0x266133c0, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:328\r\n#6  0x0000000002912250 in duckdb::Binder::Bind (this=0x266133c0, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:365\r\n#7  0x000000000290cbc4 in duckdb::Binder::Bind (this=0x266133c0, statement=...) at /home/duckdb/duckdb/src/planner/binder.cpp:150\r\n#8  0x000000000293f1dc in duckdb::Planner::CreatePlan (this=0xffffea3a1e50, statement=...) at /home/duckdb/duckdb/src/planner/planner.cpp:43\r\n#9  0x000000000188a7dc in duckdb::ClientContext::CreatePreparedStatementInternal (this=0x2647c4a0, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., values=...)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:340\r\n#10 0x000000000188ea4c in duckdb::ClientContext::CreatePreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., values=...,\r\n    mode=duckdb::PreparedStatementMode::PREPARE_AND_EXECUTE) at /home/duckdb/duckdb/src/main/client_context.cpp:426\r\n#11 0x00000000018a502c in duckdb::ClientContext::PendingStatementInternal (this=0x2647c4a0, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., parameters=...)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:745\r\n#12 0x00000000018ae9f8 in duckdb::ClientContext::PendingStatementOrPreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., prepared=...,\r\n    parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:863\r\n#13 0x00000000018a2bf0 in duckdb::ClientContext::PendingStatementOrPreparedStatementInternal (this=0x2647c4a0, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=...,\r\n    prepared=..., parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:837\r\n#14 0x00000000018a7534 in duckdb::ClientContext::PendingQueryInternal (this=0x2647c4a0, lock=..., statement=..., parameters=..., verify=<optimized out>)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:1054\r\n#15 0x00000000018b7a50 in duckdb::ClientContext::PendingQuery (this=0x2647c4a0, statement=..., values=..., allow_stream_result=<optimized out>)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:1041\r\n#16 0x00000000018b17e8 in duckdb::ClientContext::PendingQuery (this=0x2048, statement=..., allow_stream_result=false)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:1001\r\n#17 0x00000000018e622c in duckdb::Connection::PendingQuery (this=<optimized out>, statement=..., allow_stream_result=false)\r\n    at /home/duckdb/duckdb/src/main/connection.cpp:140\r\n#18 0x00000000004b3fe8 in duckdb_shell_sqlite3_prepare_v2 (db=0x263daa40, zSql=<optimized out>, nByte=<optimized out>, ppStmt=<optimized out>,\r\n    pzTail=<optimized out>) at ../../tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:224\r\n#19 0x000000000046f604 in duckdb_shell::ShellState::ExecuteSQL (this=<optimized out>,\r\n    zSql=0x263b5830 \"PIVOT_WIDER v00 AS ta02 ON ROW ( ) [ 'string' IN CASE WHEN 'string' THEN c01 END ] IN ENUM;\", pzErrMsg=0xffffea3a2e68)\r\n    at ../../tools/shell/shell.cpp:1762\r\n#20 0x0000000000485874 in duckdb_shell::ShellState::RunOneSqlLine (this=0xffffea3a3098,\r\n    zSql=0x263b5830 \"PIVOT_WIDER v00 AS ta02 ON ROW ( ) [ 'string' IN CASE WHEN 'string' THEN c01 END ] IN ENUM;\") at ../../tools/shell/shell.cpp:4353\r\n#21 0x0000000000480098 in duckdb_shell::ShellState::ProcessInput (this=<optimized out>) at ../../tools/shell/shell.cpp:4468\r\n#22 0x0000000000489b40 in main (argc=1, argv=0xffffea3a33e8) at ../../tools/shell/shell.cpp:5076\r\n```\r\n\r\n### To Reproduce\r\n\r\n1. Clone the DuckDB Git from the official repo.\r\n2. Checkout to the latest main (07e3b42f75).\r\n3. Compile the DuckDB binary by using `make relassert`(assertion failure) or `make reldebug` (SEGV).\r\n4. Run the compiled DuckDB and input the following SQL:\r\n\r\n```sql\r\nCREATE TABLE v00 (c01 INT);\r\nPIVOT_WIDER v00 AS ta02 ON ROW ( ) [ 'string' IN CASE WHEN 'string' THEN c01 END ] IN ENUM;\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu 24.04 LTS\r\n\r\n### DuckDB Version:\r\n\r\n07e3b42f75 and released version: v1.1.3 19864453f7\r\n\r\n### DuckDB Client:\r\n\r\ncli\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nYu Liang\r\n\r\n### Affiliation:\r\n\r\nThe Pennsylvania State Univerity\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\nDuckDB Segmentation Fault, with Assertion message:  \"types.cpp\" on line 1674: info\n### What happens?\r\n\r\nThe latest version of the DuckDB (latest main: v1.1.4-dev3226 07e3b42f75 and released version: v1.1.3 19864453f7) triggers Assertion Failure or Segmentation Fault when running the following SQL statement: \r\n\r\n```sql\r\nCREATE TABLE v00 (c01 INT);\r\nPIVOT_WIDER v00 AS ta02 ON ROW ( ) [ 'string' IN CASE WHEN 'string' THEN c01 END ] IN ENUM;\r\n```\r\n\r\nOn the latest main (v1.1.4-dev3226 07e3b42f75), getting crash stack trace: \r\n\r\n```\r\n#0  duckdb::EnumType::GetSize (type=...) at /home/duckdb/duckdb/src/common/types.cpp:1675\r\n#1  0x00000000027bd048 in duckdb::Binder::BindPivot (this=0x266133c0, ref=..., all_columns=...)\r\n    at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:425\r\n#2  0x00000000027dbc78 in duckdb::Binder::Bind (this=<optimized out>, ref=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:724\r\n#3  0x0000000002913e74 in duckdb::Binder::Bind (this=0x266133c0, ref=...) at /home/duckdb/duckdb/src/planner/binder.cpp:416\r\n#4  0x0000000004b4d5dc in duckdb::Binder::BindNode (this=0x266133c0, statement=...)\r\n    at /home/duckdb/duckdb/src/planner/binder/query_node/bind_select_node.cpp:371\r\n#5  0x0000000002911978 in duckdb::Binder::BindNode (this=0x266133c0, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:328\r\n#6  0x0000000002912250 in duckdb::Binder::Bind (this=0x266133c0, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:365\r\n#7  0x000000000290cbc4 in duckdb::Binder::Bind (this=0x266133c0, statement=...) at /home/duckdb/duckdb/src/planner/binder.cpp:150\r\n#8  0x000000000293f1dc in duckdb::Planner::CreatePlan (this=0xffffea3a1e50, statement=...) at /home/duckdb/duckdb/src/planner/planner.cpp:43\r\n#9  0x000000000188a7dc in duckdb::ClientContext::CreatePreparedStatementInternal (this=0x2647c4a0, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., values=...)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:340\r\n#10 0x000000000188ea4c in duckdb::ClientContext::CreatePreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., values=...,\r\n    mode=duckdb::PreparedStatementMode::PREPARE_AND_EXECUTE) at /home/duckdb/duckdb/src/main/client_context.cpp:426\r\n#11 0x00000000018a502c in duckdb::ClientContext::PendingStatementInternal (this=0x2647c4a0, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., parameters=...)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:745\r\n#12 0x00000000018ae9f8 in duckdb::ClientContext::PendingStatementOrPreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., prepared=...,\r\n    parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:863\r\n#13 0x00000000018a2bf0 in duckdb::ClientContext::PendingStatementOrPreparedStatementInternal (this=0x2647c4a0, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=...,\r\n    prepared=..., parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:837\r\n#14 0x00000000018a7534 in duckdb::ClientContext::PendingQueryInternal (this=0x2647c4a0, lock=..., statement=..., parameters=..., verify=<optimized out>)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:1054\r\n#15 0x00000000018b7a50 in duckdb::ClientContext::PendingQuery (this=0x2647c4a0, statement=..., values=..., allow_stream_result=<optimized out>)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:1041\r\n#16 0x00000000018b17e8 in duckdb::ClientContext::PendingQuery (this=0x2048, statement=..., allow_stream_result=false)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:1001\r\n#17 0x00000000018e622c in duckdb::Connection::PendingQuery (this=<optimized out>, statement=..., allow_stream_result=false)\r\n    at /home/duckdb/duckdb/src/main/connection.cpp:140\r\n#18 0x00000000004b3fe8 in duckdb_shell_sqlite3_prepare_v2 (db=0x263daa40, zSql=<optimized out>, nByte=<optimized out>, ppStmt=<optimized out>,\r\n    pzTail=<optimized out>) at ../../tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:224\r\n#19 0x000000000046f604 in duckdb_shell::ShellState::ExecuteSQL (this=<optimized out>,\r\n    zSql=0x263b5830 \"PIVOT_WIDER v00 AS ta02 ON ROW ( ) [ 'string' IN CASE WHEN 'string' THEN c01 END ] IN ENUM;\", pzErrMsg=0xffffea3a2e68)\r\n    at ../../tools/shell/shell.cpp:1762\r\n#20 0x0000000000485874 in duckdb_shell::ShellState::RunOneSqlLine (this=0xffffea3a3098,\r\n    zSql=0x263b5830 \"PIVOT_WIDER v00 AS ta02 ON ROW ( ) [ 'string' IN CASE WHEN 'string' THEN c01 END ] IN ENUM;\") at ../../tools/shell/shell.cpp:4353\r\n#21 0x0000000000480098 in duckdb_shell::ShellState::ProcessInput (this=<optimized out>) at ../../tools/shell/shell.cpp:4468\r\n#22 0x0000000000489b40 in main (argc=1, argv=0xffffea3a33e8) at ../../tools/shell/shell.cpp:5076\r\n```\r\n\r\n### To Reproduce\r\n\r\n1. Clone the DuckDB Git from the official repo.\r\n2. Checkout to the latest main (07e3b42f75).\r\n3. Compile the DuckDB binary by using `make relassert`(assertion failure) or `make reldebug` (SEGV).\r\n4. Run the compiled DuckDB and input the following SQL:\r\n\r\n```sql\r\nCREATE TABLE v00 (c01 INT);\r\nPIVOT_WIDER v00 AS ta02 ON ROW ( ) [ 'string' IN CASE WHEN 'string' THEN c01 END ] IN ENUM;\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu 24.04 LTS\r\n\r\n### DuckDB Version:\r\n\r\n07e3b42f75 and released version: v1.1.3 19864453f7\r\n\r\n### DuckDB Client:\r\n\r\ncli\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nYu Liang\r\n\r\n### Affiliation:\r\n\r\nThe Pennsylvania State Univerity\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Thanks!\nThanks!",
  "created_at": "2024-12-10T21:30:21Z"
}