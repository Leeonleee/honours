{
  "repo": "duckdb/duckdb",
  "pull_number": 3675,
  "instance_id": "duckdb__duckdb-3675",
  "issue_numbers": [
    "3659",
    "3659"
  ],
  "base_commit": "eecef371db7c17e2f1a2a6411ec693b8c1a01cdc",
  "patch": "diff --git a/src/common/types/chunk_collection.cpp b/src/common/types/chunk_collection.cpp\nindex e3532d1dae90..c44a2390268c 100644\n--- a/src/common/types/chunk_collection.cpp\n+++ b/src/common/types/chunk_collection.cpp\n@@ -431,11 +431,39 @@ bool ChunkCollection::Equals(ChunkCollection &other) {\n \tif (ColumnCount() != other.ColumnCount()) {\n \t\treturn false;\n \t}\n-\t// if count is equal amount of chunks should be equal\n+\t// first try to compare the results as-is\n+\tbool compare_equals = true;\n \tfor (idx_t row_idx = 0; row_idx < count; row_idx++) {\n \t\tfor (idx_t col_idx = 0; col_idx < ColumnCount(); col_idx++) {\n \t\t\tauto lvalue = GetValue(col_idx, row_idx);\n \t\t\tauto rvalue = other.GetValue(col_idx, row_idx);\n+\t\t\tif (!Value::ValuesAreEqual(lvalue, rvalue)) {\n+\t\t\t\tcompare_equals = false;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tif (!compare_equals) {\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\tif (compare_equals) {\n+\t\treturn true;\n+\t}\n+\t// if the results are not equal,\n+\t// sort both chunk collections to ensure the comparison is not order insensitive\n+\tvector<OrderType> desc(ColumnCount(), OrderType::DESCENDING);\n+\tvector<OrderByNullType> null_order(ColumnCount(), OrderByNullType::NULLS_FIRST);\n+\tauto this_order = unique_ptr<idx_t[]>(new idx_t[count]);\n+\tauto other_order = unique_ptr<idx_t[]>(new idx_t[count]);\n+\tSort(desc, null_order, this_order.get());\n+\tother.Sort(desc, null_order, other_order.get());\n+\n+\tfor (idx_t row_idx = 0; row_idx < count; row_idx++) {\n+\t\tauto lrow = this_order[row_idx];\n+\t\tauto rrow = other_order[row_idx];\n+\t\tfor (idx_t col_idx = 0; col_idx < ColumnCount(); col_idx++) {\n+\t\t\tauto lvalue = GetValue(col_idx, lrow);\n+\t\t\tauto rvalue = other.GetValue(col_idx, rrow);\n \t\t\tif (!Value::ValuesAreEqual(lvalue, rvalue)) {\n \t\t\t\treturn false;\n \t\t\t}\ndiff --git a/src/include/duckdb/optimizer/filter_combiner.hpp b/src/include/duckdb/optimizer/filter_combiner.hpp\nindex b460adaf7dc4..bdc8cca24a5e 100644\n--- a/src/include/duckdb/optimizer/filter_combiner.hpp\n+++ b/src/include/duckdb/optimizer/filter_combiner.hpp\n@@ -54,37 +54,37 @@ class FilterCombiner {\n \tExpression *GetNode(Expression *expr);\n \tidx_t GetEquivalenceSet(Expression *expr);\n \tFilterResult AddConstantComparison(vector<ExpressionValueInformation> &info_list, ExpressionValueInformation info);\n-\n-\t//! Functions used to push and generate OR Filters\n-\tvoid LookUpConjunctions(Expression *expr);\n-\tbool BFSLookUpConjunctions(BoundConjunctionExpression *conjunction);\n-\tvoid VerifyOrsToPush(Expression &expr);\n-\n-\tbool UpdateConjunctionFilter(BoundComparisonExpression *comparison_expr);\n-\tbool UpdateFilterByColumn(BoundColumnRefExpression *column_ref, BoundComparisonExpression *comparison_expr);\n-\tvoid GenerateORFilters(TableFilterSet &table_filter, vector<idx_t> &column_ids);\n-\n-\ttemplate <typename CONJUNCTION_TYPE>\n-\tvoid GenerateConjunctionFilter(BoundConjunctionExpression *conjunction, ConjunctionFilter *last_conj_filter) {\n-\t\tauto new_filter = NextConjunctionFilter<CONJUNCTION_TYPE>(conjunction);\n-\t\tauto conj_filter_ptr = (ConjunctionFilter *)new_filter.get();\n-\t\tlast_conj_filter->child_filters.push_back(move(new_filter));\n-\t\tlast_conj_filter = conj_filter_ptr;\n-\t}\n-\n-\ttemplate <typename CONJUNCTION_TYPE>\n-\tunique_ptr<TableFilter> NextConjunctionFilter(BoundConjunctionExpression *conjunction) {\n-\t\tunique_ptr<ConjunctionFilter> conj_filter = make_unique<CONJUNCTION_TYPE>();\n-\t\tfor (auto &expr : conjunction->children) {\n-\t\t\tauto comp_expr = (BoundComparisonExpression *)expr.get();\n-\t\t\tauto &const_expr =\n-\t\t\t    (comp_expr->left->type == ExpressionType::VALUE_CONSTANT) ? *comp_expr->left : *comp_expr->right;\n-\t\t\tauto const_value = ExpressionExecutor::EvaluateScalar(const_expr);\n-\t\t\tauto const_filter = make_unique<ConstantFilter>(comp_expr->type, const_value);\n-\t\t\tconj_filter->child_filters.push_back(move(const_filter));\n-\t\t}\n-\t\treturn move(conj_filter);\n-\t}\n+\t//\n+\t//\t//! Functions used to push and generate OR Filters\n+\t//\tvoid LookUpConjunctions(Expression *expr);\n+\t//\tbool BFSLookUpConjunctions(BoundConjunctionExpression *conjunction);\n+\t//\tvoid VerifyOrsToPush(Expression &expr);\n+\t//\n+\t//\tbool UpdateConjunctionFilter(BoundComparisonExpression *comparison_expr);\n+\t//\tbool UpdateFilterByColumn(BoundColumnRefExpression *column_ref, BoundComparisonExpression *comparison_expr);\n+\t//\tvoid GenerateORFilters(TableFilterSet &table_filter, vector<idx_t> &column_ids);\n+\t//\n+\t//\ttemplate <typename CONJUNCTION_TYPE>\n+\t//\tvoid GenerateConjunctionFilter(BoundConjunctionExpression *conjunction, ConjunctionFilter *last_conj_filter) {\n+\t//\t\tauto new_filter = NextConjunctionFilter<CONJUNCTION_TYPE>(conjunction);\n+\t//\t\tauto conj_filter_ptr = (ConjunctionFilter *)new_filter.get();\n+\t//\t\tlast_conj_filter->child_filters.push_back(move(new_filter));\n+\t//\t\tlast_conj_filter = conj_filter_ptr;\n+\t//\t}\n+\t//\n+\t//\ttemplate <typename CONJUNCTION_TYPE>\n+\t//\tunique_ptr<TableFilter> NextConjunctionFilter(BoundConjunctionExpression *conjunction) {\n+\t//\t\tunique_ptr<ConjunctionFilter> conj_filter = make_unique<CONJUNCTION_TYPE>();\n+\t//\t\tfor (auto &expr : conjunction->children) {\n+\t//\t\t\tauto comp_expr = (BoundComparisonExpression *)expr.get();\n+\t//\t\t\tauto &const_expr =\n+\t//\t\t\t    (comp_expr->left->type == ExpressionType::VALUE_CONSTANT) ? *comp_expr->left : *comp_expr->right;\n+\t//\t\t\tauto const_value = ExpressionExecutor::EvaluateScalar(const_expr);\n+\t//\t\t\tauto const_filter = make_unique<ConstantFilter>(comp_expr->type, const_value);\n+\t//\t\t\tconj_filter->child_filters.push_back(move(const_filter));\n+\t//\t\t}\n+\t//\t\treturn move(conj_filter);\n+\t//\t}\n \n private:\n \tvector<unique_ptr<Expression>> remaining_filters;\n@@ -94,26 +94,26 @@ class FilterCombiner {\n \tunordered_map<idx_t, vector<ExpressionValueInformation>> constant_values;\n \tunordered_map<idx_t, vector<Expression *>> equivalence_map;\n \tidx_t set_index = 0;\n-\n-\t//! Structures used for OR Filters\n-\n-\tstruct ConjunctionsToPush {\n-\t\tBoundConjunctionExpression *root_or;\n-\n-\t\t// only preserve AND if there is a single column in the expression\n-\t\tbool preserve_and = true;\n-\n-\t\t// conjunction chain for this column\n-\t\tvector<unique_ptr<BoundConjunctionExpression>> conjunctions;\n-\t};\n-\n-\texpression_map_t<vector<unique_ptr<ConjunctionsToPush>>> map_col_conjunctions;\n-\tvector<BoundColumnRefExpression *> vec_colref_insertion_order;\n-\n-\tBoundConjunctionExpression *cur_root_or;\n-\tBoundConjunctionExpression *cur_conjunction;\n-\n-\tBoundColumnRefExpression *cur_colref_to_push;\n+\t//\n+\t//\t//! Structures used for OR Filters\n+\t//\n+\t//\tstruct ConjunctionsToPush {\n+\t//\t\tBoundConjunctionExpression *root_or;\n+\t//\n+\t//\t\t// only preserve AND if there is a single column in the expression\n+\t//\t\tbool preserve_and = true;\n+\t//\n+\t//\t\t// conjunction chain for this column\n+\t//\t\tvector<unique_ptr<BoundConjunctionExpression>> conjunctions;\n+\t//\t};\n+\t//\n+\t//\texpression_map_t<vector<unique_ptr<ConjunctionsToPush>>> map_col_conjunctions;\n+\t//\tvector<BoundColumnRefExpression *> vec_colref_insertion_order;\n+\t//\n+\t//\tBoundConjunctionExpression *cur_root_or;\n+\t//\tBoundConjunctionExpression *cur_conjunction;\n+\t//\n+\t//\tBoundColumnRefExpression *cur_colref_to_push;\n };\n \n } // namespace duckdb\n\\ No newline at end of file\ndiff --git a/src/include/duckdb/optimizer/statistics_propagator.hpp b/src/include/duckdb/optimizer/statistics_propagator.hpp\nindex 12b78596c8dd..cc31bc7e6f0c 100644\n--- a/src/include/duckdb/optimizer/statistics_propagator.hpp\n+++ b/src/include/duckdb/optimizer/statistics_propagator.hpp\n@@ -82,6 +82,7 @@ class StatisticsPropagator {\n \tunique_ptr<BaseStatistics> PropagateExpression(BoundBetweenExpression &expr, unique_ptr<Expression> *expr_ptr);\n \tunique_ptr<BaseStatistics> PropagateExpression(BoundCaseExpression &expr, unique_ptr<Expression> *expr_ptr);\n \tunique_ptr<BaseStatistics> PropagateExpression(BoundCastExpression &expr, unique_ptr<Expression> *expr_ptr);\n+\tunique_ptr<BaseStatistics> PropagateExpression(BoundConjunctionExpression &expr, unique_ptr<Expression> *expr_ptr);\n \tunique_ptr<BaseStatistics> PropagateExpression(BoundFunctionExpression &expr, unique_ptr<Expression> *expr_ptr);\n \tunique_ptr<BaseStatistics> PropagateExpression(BoundComparisonExpression &expr, unique_ptr<Expression> *expr_ptr);\n \tunique_ptr<BaseStatistics> PropagateExpression(BoundConstantExpression &expr, unique_ptr<Expression> *expr_ptr);\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex c213ad878ec9..f71c1834ea43 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -33,6 +33,7 @@\n #include \"duckdb/planner/pragma_handler.hpp\"\n #include \"duckdb/common/file_system.hpp\"\n #include \"duckdb/execution/column_binding_resolver.hpp\"\n+#include \"duckdb/parser/query_node/select_node.hpp\"\n \n namespace duckdb {\n \n@@ -741,14 +742,16 @@ void ClientContext::DisableProfiling() {\n }\n \n struct VerifyStatement {\n-\tVerifyStatement(unique_ptr<SelectStatement> statement_p, string statement_name_p, bool require_equality = true)\n+\tVerifyStatement(unique_ptr<SelectStatement> statement_p, string statement_name_p, bool require_equality = true,\n+\t                bool disable_optimizer = false)\n \t    : statement(move(statement_p)), statement_name(move(statement_name_p)), require_equality(require_equality),\n-\t      select_list(statement->node->GetSelectList()) {\n+\t      disable_optimizer(disable_optimizer), select_list(statement->node->GetSelectList()) {\n \t}\n \n \tunique_ptr<SelectStatement> statement;\n \tstring statement_name;\n \tbool require_equality;\n+\tbool disable_optimizer;\n \tconst vector<unique_ptr<ParsedExpression>> &select_list;\n };\n \n@@ -776,8 +779,9 @@ string ClientContext::VerifyQuery(ClientContextLock &lock, const string &query,\n \tBufferedDeserializer source(serializer);\n \tauto deserialized_stmt = SelectStatement::Deserialize(source);\n \n+\tauto query_str = select_stmt->ToString();\n \tParser parser;\n-\tparser.ParseQuery(select_stmt->ToString());\n+\tparser.ParseQuery(query_str);\n \tD_ASSERT(parser.statements.size() == 1);\n \tD_ASSERT(parser.statements[0]->type == StatementType::SELECT_STATEMENT);\n \tauto parsed_statement = move(parser.statements[0]);\n@@ -788,6 +792,8 @@ string ClientContext::VerifyQuery(ClientContextLock &lock, const string &query,\n \tverify_statements.emplace_back(move(deserialized_stmt), \"Deserialized statement\");\n \tverify_statements.emplace_back(unique_ptr_cast<SQLStatement, SelectStatement>(move(parsed_statement)),\n \t                               \"Parsed statement\", false);\n+\tverify_statements.emplace_back(unique_ptr_cast<SQLStatement, SelectStatement>(move(unoptimized_stmt)),\n+\t                               \"Unoptimized\", true, true);\n \n \t// all the statements should be equal\n \tfor (idx_t i = 1; i < verify_statements.size(); i++) {\n@@ -852,9 +858,11 @@ string ClientContext::VerifyQuery(ClientContextLock &lock, const string &query,\n \tauto statement_copy_for_explain = select_stmt->Copy();\n \n \t// execute the original statement\n+\tauto optimizer_enabled = config.enable_optimizer;\n \tvector<unique_ptr<MaterializedQueryResult>> results;\n \tfor (idx_t i = 0; i < verify_statements.size(); i++) {\n \t\tinterrupted = false;\n+\t\tconfig.enable_optimizer = !verify_statements[i].disable_optimizer;\n \t\ttry {\n \t\t\tauto result = RunStatementInternal(lock, query, move(verify_statements[i].statement), false, false);\n \t\t\tresults.push_back(unique_ptr_cast<QueryResult, MaterializedQueryResult>(move(result)));\n@@ -862,6 +870,7 @@ string ClientContext::VerifyQuery(ClientContextLock &lock, const string &query,\n \t\t\tresults.push_back(make_unique<MaterializedQueryResult>(ex.what()));\n \t\t}\n \t}\n+\tconfig.enable_optimizer = optimizer_enabled;\n \n \t// check explain, only if q does not already contain EXPLAIN\n \tif (results[0]->success) {\n@@ -874,8 +883,6 @@ string ClientContext::VerifyQuery(ClientContextLock &lock, const string &query,\n \t\t} // LCOV_EXCL_STOP\n \t}\n \n-\tconfig.enable_optimizer = true;\n-\n \tif (profiling_is_enabled) {\n \t\tconfig.enable_profiler = true;\n \t}\ndiff --git a/src/optimizer/filter_combiner.cpp b/src/optimizer/filter_combiner.cpp\nindex 50dc2d6680ef..892c9b47803b 100644\n--- a/src/optimizer/filter_combiner.cpp\n+++ b/src/optimizer/filter_combiner.cpp\n@@ -80,7 +80,7 @@ FilterResult FilterCombiner::AddConstantComparison(vector<ExpressionValueInforma\n }\n \n FilterResult FilterCombiner::AddFilter(unique_ptr<Expression> expr) {\n-\tLookUpConjunctions(expr.get());\n+\t//\tLookUpConjunctions(expr.get());\n \t// try to push the filter into the combiner\n \tauto result = AddFilter(expr.get());\n \tif (result == FilterResult::UNSUPPORTED) {\n@@ -550,7 +550,7 @@ TableFilterSet FilterCombiner::GenerateTableScanFilters(vector<idx_t> &column_id\n \t\t}\n \t}\n \n-\tGenerateORFilters(table_filters, column_ids);\n+\t//\tGenerateORFilters(table_filters, column_ids);\n \n \treturn table_filters;\n }\n@@ -1019,175 +1019,175 @@ ValueComparisonResult CompareValueInformation(ExpressionValueInformation &left,\n \t\treturn InvertValueComparisonResult(CompareValueInformation(right, left));\n \t}\n }\n-\n-void FilterCombiner::LookUpConjunctions(Expression *expr) {\n-\tif (expr->GetExpressionType() == ExpressionType::CONJUNCTION_OR) {\n-\t\tauto root_or_expr = (BoundConjunctionExpression *)expr;\n-\t\tfor (const auto &entry : map_col_conjunctions) {\n-\t\t\tfor (const auto &conjs_to_push : entry.second) {\n-\t\t\t\tif (conjs_to_push->root_or->Equals(root_or_expr)) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tcur_root_or = root_or_expr;\n-\t\tcur_conjunction = root_or_expr;\n-\t\tcur_colref_to_push = nullptr;\n-\t\tif (!BFSLookUpConjunctions(cur_root_or)) {\n-\t\t\tif (cur_colref_to_push) {\n-\t\t\t\tauto entry = map_col_conjunctions.find(cur_colref_to_push);\n-\t\t\t\tauto &vec_conjs_to_push = entry->second;\n-\t\t\t\tif (vec_conjs_to_push.size() == 1) {\n-\t\t\t\t\tmap_col_conjunctions.erase(entry);\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tvec_conjs_to_push.pop_back();\n-\t\t\t}\n-\t\t}\n-\t\treturn;\n-\t}\n-\n-\t// Verify if the expression has a column already pushed down by other OR expression\n-\tVerifyOrsToPush(*expr);\n-}\n-\n-bool FilterCombiner::BFSLookUpConjunctions(BoundConjunctionExpression *conjunction) {\n-\tvector<BoundConjunctionExpression *> conjunctions_to_visit;\n-\n-\tfor (auto &child : conjunction->children) {\n-\t\tswitch (child->GetExpressionClass()) {\n-\t\tcase ExpressionClass::BOUND_CONJUNCTION: {\n-\t\t\tauto child_conjunction = (BoundConjunctionExpression *)child.get();\n-\t\t\tconjunctions_to_visit.emplace_back(child_conjunction);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase ExpressionClass::BOUND_COMPARISON: {\n-\t\t\tif (!UpdateConjunctionFilter((BoundComparisonExpression *)child.get())) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tdefault: {\n-\t\t\treturn false;\n-\t\t}\n-\t\t}\n-\t}\n-\n-\tfor (auto child_conjunction : conjunctions_to_visit) {\n-\t\tcur_conjunction = child_conjunction;\n-\t\t// traverse child conjuction\n-\t\tif (!BFSLookUpConjunctions(child_conjunction)) {\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\treturn true;\n-}\n-\n-void FilterCombiner::VerifyOrsToPush(Expression &expr) {\n-\tif (expr.type == ExpressionType::BOUND_COLUMN_REF) {\n-\t\tauto colref = (BoundColumnRefExpression *)&expr;\n-\t\tauto entry = map_col_conjunctions.find(colref);\n-\t\tif (entry == map_col_conjunctions.end()) {\n-\t\t\treturn;\n-\t\t}\n-\t\tmap_col_conjunctions.erase(entry);\n-\t}\n-\tExpressionIterator::EnumerateChildren(expr, [&](Expression &child) { VerifyOrsToPush(child); });\n-}\n-\n-bool FilterCombiner::UpdateConjunctionFilter(BoundComparisonExpression *comparison_expr) {\n-\tbool left_is_scalar = comparison_expr->left->IsFoldable();\n-\tbool right_is_scalar = comparison_expr->right->IsFoldable();\n-\n-\tExpression *non_scalar_expr;\n-\tif (left_is_scalar || right_is_scalar) {\n-\t\t// only support comparison with scalar\n-\t\tnon_scalar_expr = left_is_scalar ? comparison_expr->right.get() : comparison_expr->left.get();\n-\n-\t\tif (non_scalar_expr->GetExpressionType() == ExpressionType::BOUND_COLUMN_REF) {\n-\t\t\treturn UpdateFilterByColumn((BoundColumnRefExpression *)non_scalar_expr, comparison_expr);\n-\t\t}\n-\t}\n-\n-\treturn false;\n-}\n-\n-bool FilterCombiner::UpdateFilterByColumn(BoundColumnRefExpression *column_ref,\n-                                          BoundComparisonExpression *comparison_expr) {\n-\tif (cur_colref_to_push == nullptr) {\n-\t\tcur_colref_to_push = column_ref;\n-\n-\t\tauto or_conjunction = make_unique<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);\n-\t\tor_conjunction->children.emplace_back(comparison_expr->Copy());\n-\n-\t\tunique_ptr<ConjunctionsToPush> conjs_to_push = make_unique<ConjunctionsToPush>();\n-\t\tconjs_to_push->conjunctions.emplace_back(move(or_conjunction));\n-\t\tconjs_to_push->root_or = cur_root_or;\n-\n-\t\tauto &&vec_col_conjs = map_col_conjunctions[column_ref];\n-\t\tvec_col_conjs.emplace_back(move(conjs_to_push));\n-\t\tvec_colref_insertion_order.emplace_back(column_ref);\n-\t\treturn true;\n-\t}\n-\n-\tauto entry = map_col_conjunctions.find(cur_colref_to_push);\n-\tD_ASSERT(entry != map_col_conjunctions.end());\n-\tauto &conjunctions_to_push = entry->second.back();\n-\n-\tif (!cur_colref_to_push->Equals(column_ref)) {\n-\t\t// check for multiple colunms in the same root OR node\n-\t\tif (cur_root_or == cur_conjunction) {\n-\t\t\treturn false;\n-\t\t}\n-\t\t// found an AND using a different column, we should stop the look up\n-\t\tif (cur_conjunction->GetExpressionType() == ExpressionType::CONJUNCTION_AND) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t// found a different column, AND conditions cannot be preserved anymore\n-\t\tconjunctions_to_push->preserve_and = false;\n-\t\treturn true;\n-\t}\n-\n-\tauto &last_conjunction = conjunctions_to_push->conjunctions.back();\n-\tif (cur_conjunction->GetExpressionType() == last_conjunction->GetExpressionType()) {\n-\t\tlast_conjunction->children.emplace_back(comparison_expr->Copy());\n-\t} else {\n-\t\tauto new_conjunction = make_unique<BoundConjunctionExpression>(cur_conjunction->GetExpressionType());\n-\t\tnew_conjunction->children.emplace_back(comparison_expr->Copy());\n-\t\tconjunctions_to_push->conjunctions.emplace_back(move(new_conjunction));\n-\t}\n-\treturn true;\n-}\n-\n-void FilterCombiner::GenerateORFilters(TableFilterSet &table_filter, vector<idx_t> &column_ids) {\n-\tfor (const auto colref : vec_colref_insertion_order) {\n-\t\tauto column_index = column_ids[colref->binding.column_index];\n-\t\tif (column_index == COLUMN_IDENTIFIER_ROW_ID) {\n-\t\t\tbreak;\n-\t\t}\n-\n-\t\tfor (const auto &conjunctions_to_push : map_col_conjunctions[colref]) {\n-\t\t\t// root OR filter to push into the TableFilter\n-\t\t\tauto root_or_filter = make_unique<ConjunctionOrFilter>();\n-\t\t\t// variable to hold the last conjuntion filter pointer\n-\t\t\t// the next filter will be added into it, i.e., we create a chain of conjunction filters\n-\t\t\tConjunctionFilter *last_conj_filter = root_or_filter.get();\n-\n-\t\t\tfor (auto &conjunction : conjunctions_to_push->conjunctions) {\n-\t\t\t\tif (conjunction->GetExpressionType() == ExpressionType::CONJUNCTION_AND &&\n-\t\t\t\t    conjunctions_to_push->preserve_and) {\n-\t\t\t\t\tGenerateConjunctionFilter<ConjunctionAndFilter>(conjunction.get(), last_conj_filter);\n-\t\t\t\t} else {\n-\t\t\t\t\tGenerateConjunctionFilter<ConjunctionOrFilter>(conjunction.get(), last_conj_filter);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\ttable_filter.PushFilter(column_index, move(root_or_filter));\n-\t\t}\n-\t}\n-\tmap_col_conjunctions.clear();\n-\tvec_colref_insertion_order.clear();\n-}\n+//\n+// void FilterCombiner::LookUpConjunctions(Expression *expr) {\n+//\tif (expr->GetExpressionType() == ExpressionType::CONJUNCTION_OR) {\n+//\t\tauto root_or_expr = (BoundConjunctionExpression *)expr;\n+//\t\tfor (const auto &entry : map_col_conjunctions) {\n+//\t\t\tfor (const auto &conjs_to_push : entry.second) {\n+//\t\t\t\tif (conjs_to_push->root_or->Equals(root_or_expr)) {\n+//\t\t\t\t\treturn;\n+//\t\t\t\t}\n+//\t\t\t}\n+//\t\t}\n+//\n+//\t\tcur_root_or = root_or_expr;\n+//\t\tcur_conjunction = root_or_expr;\n+//\t\tcur_colref_to_push = nullptr;\n+//\t\tif (!BFSLookUpConjunctions(cur_root_or)) {\n+//\t\t\tif (cur_colref_to_push) {\n+//\t\t\t\tauto entry = map_col_conjunctions.find(cur_colref_to_push);\n+//\t\t\t\tauto &vec_conjs_to_push = entry->second;\n+//\t\t\t\tif (vec_conjs_to_push.size() == 1) {\n+//\t\t\t\t\tmap_col_conjunctions.erase(entry);\n+//\t\t\t\t\treturn;\n+//\t\t\t\t}\n+//\t\t\t\tvec_conjs_to_push.pop_back();\n+//\t\t\t}\n+//\t\t}\n+//\t\treturn;\n+//\t}\n+//\n+//\t// Verify if the expression has a column already pushed down by other OR expression\n+//\tVerifyOrsToPush(*expr);\n+//}\n+//\n+// bool FilterCombiner::BFSLookUpConjunctions(BoundConjunctionExpression *conjunction) {\n+//\tvector<BoundConjunctionExpression *> conjunctions_to_visit;\n+//\n+//\tfor (auto &child : conjunction->children) {\n+//\t\tswitch (child->GetExpressionClass()) {\n+//\t\tcase ExpressionClass::BOUND_CONJUNCTION: {\n+//\t\t\tauto child_conjunction = (BoundConjunctionExpression *)child.get();\n+//\t\t\tconjunctions_to_visit.emplace_back(child_conjunction);\n+//\t\t\tbreak;\n+//\t\t}\n+//\t\tcase ExpressionClass::BOUND_COMPARISON: {\n+//\t\t\tif (!UpdateConjunctionFilter((BoundComparisonExpression *)child.get())) {\n+//\t\t\t\treturn false;\n+//\t\t\t}\n+//\t\t\tbreak;\n+//\t\t}\n+//\t\tdefault: {\n+//\t\t\treturn false;\n+//\t\t}\n+//\t\t}\n+//\t}\n+//\n+//\tfor (auto child_conjunction : conjunctions_to_visit) {\n+//\t\tcur_conjunction = child_conjunction;\n+//\t\t// traverse child conjuction\n+//\t\tif (!BFSLookUpConjunctions(child_conjunction)) {\n+//\t\t\treturn false;\n+//\t\t}\n+//\t}\n+//\treturn true;\n+//}\n+//\n+// void FilterCombiner::VerifyOrsToPush(Expression &expr) {\n+//\tif (expr.type == ExpressionType::BOUND_COLUMN_REF) {\n+//\t\tauto colref = (BoundColumnRefExpression *)&expr;\n+//\t\tauto entry = map_col_conjunctions.find(colref);\n+//\t\tif (entry == map_col_conjunctions.end()) {\n+//\t\t\treturn;\n+//\t\t}\n+//\t\tmap_col_conjunctions.erase(entry);\n+//\t}\n+//\tExpressionIterator::EnumerateChildren(expr, [&](Expression &child) { VerifyOrsToPush(child); });\n+//}\n+//\n+// bool FilterCombiner::UpdateConjunctionFilter(BoundComparisonExpression *comparison_expr) {\n+//\tbool left_is_scalar = comparison_expr->left->IsFoldable();\n+//\tbool right_is_scalar = comparison_expr->right->IsFoldable();\n+//\n+//\tExpression *non_scalar_expr;\n+//\tif (left_is_scalar || right_is_scalar) {\n+//\t\t// only support comparison with scalar\n+//\t\tnon_scalar_expr = left_is_scalar ? comparison_expr->right.get() : comparison_expr->left.get();\n+//\n+//\t\tif (non_scalar_expr->GetExpressionType() == ExpressionType::BOUND_COLUMN_REF) {\n+//\t\t\treturn UpdateFilterByColumn((BoundColumnRefExpression *)non_scalar_expr, comparison_expr);\n+//\t\t}\n+//\t}\n+//\n+//\treturn false;\n+//}\n+//\n+// bool FilterCombiner::UpdateFilterByColumn(BoundColumnRefExpression *column_ref,\n+//                                          BoundComparisonExpression *comparison_expr) {\n+//\tif (cur_colref_to_push == nullptr) {\n+//\t\tcur_colref_to_push = column_ref;\n+//\n+//\t\tauto or_conjunction = make_unique<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);\n+//\t\tor_conjunction->children.emplace_back(comparison_expr->Copy());\n+//\n+//\t\tunique_ptr<ConjunctionsToPush> conjs_to_push = make_unique<ConjunctionsToPush>();\n+//\t\tconjs_to_push->conjunctions.emplace_back(move(or_conjunction));\n+//\t\tconjs_to_push->root_or = cur_root_or;\n+//\n+//\t\tauto &&vec_col_conjs = map_col_conjunctions[column_ref];\n+//\t\tvec_col_conjs.emplace_back(move(conjs_to_push));\n+//\t\tvec_colref_insertion_order.emplace_back(column_ref);\n+//\t\treturn true;\n+//\t}\n+//\n+//\tauto entry = map_col_conjunctions.find(cur_colref_to_push);\n+//\tD_ASSERT(entry != map_col_conjunctions.end());\n+//\tauto &conjunctions_to_push = entry->second.back();\n+//\n+//\tif (!cur_colref_to_push->Equals(column_ref)) {\n+//\t\t// check for multiple colunms in the same root OR node\n+//\t\tif (cur_root_or == cur_conjunction) {\n+//\t\t\treturn false;\n+//\t\t}\n+//\t\t// found an AND using a different column, we should stop the look up\n+//\t\tif (cur_conjunction->GetExpressionType() == ExpressionType::CONJUNCTION_AND) {\n+//\t\t\treturn false;\n+//\t\t}\n+//\n+//\t\t// found a different column, AND conditions cannot be preserved anymore\n+//\t\tconjunctions_to_push->preserve_and = false;\n+//\t\treturn true;\n+//\t}\n+//\n+//\tauto &last_conjunction = conjunctions_to_push->conjunctions.back();\n+//\tif (cur_conjunction->GetExpressionType() == last_conjunction->GetExpressionType()) {\n+//\t\tlast_conjunction->children.emplace_back(comparison_expr->Copy());\n+//\t} else {\n+//\t\tauto new_conjunction = make_unique<BoundConjunctionExpression>(cur_conjunction->GetExpressionType());\n+//\t\tnew_conjunction->children.emplace_back(comparison_expr->Copy());\n+//\t\tconjunctions_to_push->conjunctions.emplace_back(move(new_conjunction));\n+//\t}\n+//\treturn true;\n+//}\n+//\n+// void FilterCombiner::GenerateORFilters(TableFilterSet &table_filter, vector<idx_t> &column_ids) {\n+//\tfor (const auto colref : vec_colref_insertion_order) {\n+//\t\tauto column_index = column_ids[colref->binding.column_index];\n+//\t\tif (column_index == COLUMN_IDENTIFIER_ROW_ID) {\n+//\t\t\tbreak;\n+//\t\t}\n+//\n+//\t\tfor (const auto &conjunctions_to_push : map_col_conjunctions[colref]) {\n+//\t\t\t// root OR filter to push into the TableFilter\n+//\t\t\tauto root_or_filter = make_unique<ConjunctionOrFilter>();\n+//\t\t\t// variable to hold the last conjuntion filter pointer\n+//\t\t\t// the next filter will be added into it, i.e., we create a chain of conjunction filters\n+//\t\t\tConjunctionFilter *last_conj_filter = root_or_filter.get();\n+//\n+//\t\t\tfor (auto &conjunction : conjunctions_to_push->conjunctions) {\n+//\t\t\t\tif (conjunction->GetExpressionType() == ExpressionType::CONJUNCTION_AND &&\n+//\t\t\t\t    conjunctions_to_push->preserve_and) {\n+//\t\t\t\t\tGenerateConjunctionFilter<ConjunctionAndFilter>(conjunction.get(), last_conj_filter);\n+//\t\t\t\t} else {\n+//\t\t\t\t\tGenerateConjunctionFilter<ConjunctionOrFilter>(conjunction.get(), last_conj_filter);\n+//\t\t\t\t}\n+//\t\t\t}\n+//\t\t\ttable_filter.PushFilter(column_index, move(root_or_filter));\n+//\t\t}\n+//\t}\n+//\tmap_col_conjunctions.clear();\n+//\tvec_colref_insertion_order.clear();\n+//}\n \n } // namespace duckdb\ndiff --git a/src/optimizer/statistics/expression/propagate_conjunction.cpp b/src/optimizer/statistics/expression/propagate_conjunction.cpp\nindex 8b137891791f..3a16fb513579 100644\n--- a/src/optimizer/statistics/expression/propagate_conjunction.cpp\n+++ b/src/optimizer/statistics/expression/propagate_conjunction.cpp\n@@ -1,1 +1,68 @@\n \n+#include \"duckdb/optimizer/statistics_propagator.hpp\"\n+#include \"duckdb/planner/expression/bound_conjunction_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n+#include \"duckdb/storage/statistics/numeric_statistics.hpp\"\n+#include \"duckdb/optimizer/expression_rewriter.hpp\"\n+#include \"duckdb/execution/expression_executor.hpp\"\n+\n+namespace duckdb {\n+\n+unique_ptr<BaseStatistics> StatisticsPropagator::PropagateExpression(BoundConjunctionExpression &expr,\n+                                                                     unique_ptr<Expression> *expr_ptr) {\n+\tauto is_and = expr.type == ExpressionType::CONJUNCTION_AND;\n+\tfor (idx_t expr_idx = 0; expr_idx < expr.children.size(); expr_idx++) {\n+\t\tauto &child = expr.children[expr_idx];\n+\t\tauto stats = PropagateExpression(child);\n+\t\tif (!child->IsFoldable()) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// we have a constant in a conjunction\n+\t\t// we (1) either prune the child\n+\t\t// or (2) replace the entire conjunction with a constant\n+\t\tauto constant = ExpressionExecutor::EvaluateScalar(*child);\n+\t\tif (constant.IsNull()) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tauto b = BooleanValue::Get(constant);\n+\t\tbool prune_child = false;\n+\t\tbool constant_value = true;\n+\t\tif (b) {\n+\t\t\t// true\n+\t\t\tif (is_and) {\n+\t\t\t\t// true in and: prune child\n+\t\t\t\tprune_child = true;\n+\t\t\t} else {\n+\t\t\t\t// true in OR: replace with TRUE\n+\t\t\t\tconstant_value = true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// false\n+\t\t\tif (is_and) {\n+\t\t\t\t// false in AND: replace with FALSE\n+\t\t\t\tconstant_value = false;\n+\t\t\t} else {\n+\t\t\t\t// false in OR: prune child\n+\t\t\t\tprune_child = true;\n+\t\t\t}\n+\t\t}\n+\t\tif (prune_child) {\n+\t\t\texpr.children.erase(expr.children.begin() + expr_idx);\n+\t\t\texpr_idx--;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t*expr_ptr = make_unique<BoundConstantExpression>(Value::BOOLEAN(constant_value));\n+\t\treturn PropagateExpression(*expr_ptr);\n+\t}\n+\tif (expr.children.empty()) {\n+\t\t// if there are no children left, replace the conjunction with TRUE (for AND) or FALSE (for OR)\n+\t\t*expr_ptr = make_unique<BoundConstantExpression>(Value::BOOLEAN(is_and));\n+\t\treturn PropagateExpression(*expr_ptr);\n+\t} else if (expr.children.size() == 1) {\n+\t\t// if there is one child left, replace the conjunction with that one child\n+\t\t*expr_ptr = move(expr.children[0]);\n+\t}\n+\treturn nullptr;\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/optimizer/statistics/operator/propagate_filter.cpp b/src/optimizer/statistics/operator/propagate_filter.cpp\nindex fb2de0537395..e5abbe708407 100644\n--- a/src/optimizer/statistics/operator/propagate_filter.cpp\n+++ b/src/optimizer/statistics/operator/propagate_filter.cpp\n@@ -19,7 +19,7 @@ bool StatisticsPropagator::ExpressionIsConstant(Expression &expr, const Value &v\n \t}\n \tauto &bound_constant = (BoundConstantExpression &)expr;\n \tD_ASSERT(bound_constant.value.type() == val.type());\n-\treturn bound_constant.value == val;\n+\treturn Value::NotDistinctFrom(bound_constant.value, val);\n }\n \n bool StatisticsPropagator::ExpressionIsConstantOrNull(Expression &expr, const Value &val) {\ndiff --git a/src/optimizer/statistics_propagator.cpp b/src/optimizer/statistics_propagator.cpp\nindex bd983a1bb283..8e726177b38f 100644\n--- a/src/optimizer/statistics_propagator.cpp\n+++ b/src/optimizer/statistics_propagator.cpp\n@@ -65,6 +65,8 @@ unique_ptr<BaseStatistics> StatisticsPropagator::PropagateExpression(Expression\n \t\treturn PropagateExpression((BoundBetweenExpression &)expr, expr_ptr);\n \tcase ExpressionClass::BOUND_CASE:\n \t\treturn PropagateExpression((BoundCaseExpression &)expr, expr_ptr);\n+\tcase ExpressionClass::BOUND_CONJUNCTION:\n+\t\treturn PropagateExpression((BoundConjunctionExpression &)expr, expr_ptr);\n \tcase ExpressionClass::BOUND_FUNCTION:\n \t\treturn PropagateExpression((BoundFunctionExpression &)expr, expr_ptr);\n \tcase ExpressionClass::BOUND_CAST:\n",
  "test_patch": "diff --git a/test/optimizer/pushdown/parquet_or_pushdown.test b/test/optimizer/pushdown/parquet_or_pushdown.test\nindex 1902d5ba77ec..bc4b5418c87b 100644\n--- a/test/optimizer/pushdown/parquet_or_pushdown.test\n+++ b/test/optimizer/pushdown/parquet_or_pushdown.test\n@@ -7,6 +7,9 @@ require parquet\n statement ok\n PRAGMA enable_verification\n \n+# FIXME: re-enable when or pushdown is fixed\n+mode skip\n+\n # Multiple column in the root OR node, don't push down\n query II\n EXPLAIN  SELECT tbl.a, tbl.b FROM \"data/parquet-testing/arrow/alltypes_plain.parquet\" tbl(a, b) WHERE a=1 OR b=false\ndiff --git a/test/optimizer/pushdown/table_or_pushdown.test b/test/optimizer/pushdown/table_or_pushdown.test\nindex 99db649878b5..905e5ac8344b 100644\n--- a/test/optimizer/pushdown/table_or_pushdown.test\n+++ b/test/optimizer/pushdown/table_or_pushdown.test\n@@ -5,6 +5,9 @@\n statement ok\n PRAGMA enable_verification\n \n+# FIXME: re-enable when OR pushdown is fixed\n+mode skip\n+\n statement ok\n CREATE TABLE integers AS SELECT a as a, a as b FROM generate_series(1, 5, 1) tbl(a)\n \ndiff --git a/test/sql/catalog/sequence/test_verification_failure.test b/test/sql/catalog/sequence/test_verification_failure.test\ndeleted file mode 100644\nindex 098f9c5f4df6..000000000000\n--- a/test/sql/catalog/sequence/test_verification_failure.test\n+++ /dev/null\n@@ -1,18 +0,0 @@\n-# name: test/sql/catalog/sequence/test_verification_failure.test\n-# description: Test query verification failures\n-# group: [sequence]\n-\n-statement ok\n-PRAGMA enable_verification\n-\n-statement ok\n-CREATE SEQUENCE seq;\n-\n-statement error\n-SELECT nextval('seq')\n-\n-query I\n-SELECT 1\n-----\n-1\n-\ndiff --git a/test/sql/conjunction/or_between.test b/test/sql/conjunction/or_between.test\nnew file mode 100644\nindex 000000000000..47750fb0442b\n--- /dev/null\n+++ b/test/sql/conjunction/or_between.test\n@@ -0,0 +1,53 @@\n+# name: test/sql/conjunction/or_between.test\n+# description: Issue 3659: different query results with optimizer on vs. off\n+# group: [conjunction]\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+statement ok\n+CREATE TABLE tab0(pk INTEGER PRIMARY KEY, col0 INTEGER, col1 FLOAT, col2 VARCHAR, col3 INTEGER, col4 FLOAT, col5 VARCHAR);\n+\n+statement ok\n+INSERT INTO tab0 VALUES(0,22,43.95999908447265625,'yoyca',0,80.1399993896484375,'eoenc');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(1,51,34.900001525878905361,'zeqhw',44,13.489999771118164062,'easox');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(2,42,59.759998321533203125,'ylshk',15,4.4499998092651367187,'xgrvy');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(3,67,90.660003662109378552,'rnadc',77,50.360000610351560723,'knooo');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(4,48,53.099998474121097302,'txhlv',75,9.770000457763671875,'gvudx');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(5,18,40.580001831054683947,'wgfxz',96,12.5,'mmxbj');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(6,84,24.239999771118165838,'ttodp',31,72.999999999999998223,'wujjl');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(7,86,67.449996948242185723,'mwgbl',38,10.479999542236329013,'ypcha');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(8,68,38.470001220703125,'kaoqh',8,41.500000000000003552,'fyhzl');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(9,29,19.600000381469726562,'kbenw',20,19.579999923706054687,'gsszq');\n+\n+query I\n+SELECT pk FROM tab0 WHERE (col0 BETWEEN 67 AND 0 OR col0 > 17 AND (col0 > 3));\n+----\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\ndiff --git a/test/sql/conjunction/or_comparison.test b/test/sql/conjunction/or_comparison.test\nnew file mode 100644\nindex 000000000000..aaa4b994c0e6\n--- /dev/null\n+++ b/test/sql/conjunction/or_comparison.test\n@@ -0,0 +1,50 @@\n+# name: test/sql/conjunction/or_comparison.test\n+# description: Issue 3659: different query results with optimizer on vs. off\n+# group: [conjunction]\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+statement ok\n+CREATE TABLE tab0(pk INTEGER PRIMARY KEY, col0 INTEGER, col1 FLOAT, col2 VARCHAR, col3 INTEGER, col4 FLOAT, col5 VARCHAR);;\n+\n+statement ok\n+INSERT INTO tab0 VALUES(0,86,94.959999084472652697,'vuopk',91,47.779998779296875,'sikuk');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(1,37,20.850000381469726562,'zfuqj',30,10.689999580383300337,'rtcha');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(2,6,47.540000915527347302,'vubiv',38,46.630001068115234375,'nnuey');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(3,72,30.629999160766603338,'rezor',59,11.189999580383300781,'mdler');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(4,12,29.620000839233400213,'gvmir',68,69.669998168945310723,'yfnxa');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(5,64,21.489999771118162286,'ruygp',31,13.659999847412109819,'fhwkn');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(6,90,9.3699998855590820312,'tehgk',71,65.720001220703121447,'uibwi');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(7,38,43.139999389648435723,'axgch',27,98.949996948242180394,'oikcl');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(8,3,22.399999618530275213,'yigev',19,45.650001525878902697,'tbbkw');\n+\n+statement ok\n+INSERT INTO tab0 VALUES(9,95,14.31999969482421875,'vssyg',8,12.930000305175781605,'epgyr');\n+\n+query I\n+SELECT pk FROM tab0 WHERE col0 < 84 OR col0 < 8 ;\n+----\n+1\n+2\n+3\n+4\n+5\n+7\n+8\ndiff --git a/test/sql/join/natural/natural_join.test b/test/sql/join/natural/natural_join.test\nindex c14c4e72b24d..eddc633d6133 100644\n--- a/test/sql/join/natural/natural_join.test\n+++ b/test/sql/join/natural/natural_join.test\n@@ -242,6 +242,9 @@ SELECT COUNT(t1.rowid) FROM t1, v0 RIGHT JOIN t0 ON t1.c1=t0.c1 AND v0.c0=t0.c0;\n statement error\n select * from (values (1)) t1(i) join (values (1)) t2(i) on (t1.i=t2.i) natural join (values (1)) t3(i);\n \n+statement ok\n+PRAGMA disable_verification\n+\n # column name appears more than once on right side of the natural join\n statement error\n select * from (values (1)) t1(i) natural join ((values (1)) t2(i)  join (values (1)) t3(i) on (t2.i=t3.i))\ndiff --git a/test/sql/optimizer/expression/test_equal_or_null_optimization.test b/test/sql/optimizer/expression/test_equal_or_null_optimization.test\nindex 1c7ec5cc355a..b0ed9091b3d8 100644\n--- a/test/sql/optimizer/expression/test_equal_or_null_optimization.test\n+++ b/test/sql/optimizer/expression/test_equal_or_null_optimization.test\n@@ -52,7 +52,7 @@ physical_plan\t<REGEX>:.*DISTINCT.*\n \n # do a hash join\n query I rowsort\n-SELECT test1.i FROM test AS test1, test AS test2 WHERE (test1.i=test2.j) OR (test1.i IS NULL AND test2.j IS NULL);\n+SELECT test1.i FROM test AS test1, test AS test2 WHERE (test1.i=test2.j) OR (test1.i IS NULL AND test2.j IS NULL) ORDER BY 1;\n ----\n 1\n 2\ndiff --git a/test/sqlite/sqllogic_test_runner.cpp b/test/sqlite/sqllogic_test_runner.cpp\nindex 07d008239453..5d850bdec356 100644\n--- a/test/sqlite/sqllogic_test_runner.cpp\n+++ b/test/sqlite/sqllogic_test_runner.cpp\n@@ -73,6 +73,9 @@ void SQLLogicTestRunner::LoadDatabase(string dbpath) {\n \n \tdb = make_unique<DuckDB>(dbpath, config.get());\n \tcon = make_unique<Connection>(*db);\n+\tif (enable_verification) {\n+\t\tcon->EnableQueryVerification();\n+\t}\n \n \t// load any previously loaded extensions again\n \tfor (auto &extension : extensions) {\n@@ -209,6 +212,9 @@ void SQLLogicTestRunner::ExecuteFile(string script) {\n \t\t\t}\n \t\t\tauto system_name = StringUtil::Lower(token.parameters[0]);\n \t\t\tbool our_system = system_name == \"duckdb\";\n+\t\t\tif (original_sqlite_test) {\n+\t\t\t\tour_system = our_system || system_name == \"postgresql\";\n+\t\t\t}\n \t\t\tif (our_system == skip_if) {\n \t\t\t\t// we skip this command in two situations\n \t\t\t\t// (1) skipif duckdb\ndiff --git a/test/sqlite/sqllogic_test_runner.hpp b/test/sqlite/sqllogic_test_runner.hpp\nindex c3813dd0deb6..1f348eda5561 100644\n--- a/test/sqlite/sqllogic_test_runner.hpp\n+++ b/test/sqlite/sqllogic_test_runner.hpp\n@@ -38,11 +38,12 @@ class SQLLogicTestRunner {\n \tvector<LoopDefinition *> running_loops;\n \tbool original_sqlite_test = false;\n \tbool output_sql = false;\n+\tbool enable_verification = false;\n \n \t// If these error msgs occur in a test, the test will abort but still count as passed\n \tunordered_set<string> ignore_error_messages = {\"HTTP\", \"Unable to connect\"};\n \t// If these error msgs occur a statement that is expected to fail, the test will fail\n-\tunordered_set<string> always_fail_error_messages = {\"Unoptimized Result differs from original result!\", \"INTERNAL\"};\n+\tunordered_set<string> always_fail_error_messages = {\"differs from original result!\", \"INTERNAL\"};\n \n \t//! The map converting the labels to the hash values\n \tunordered_map<string, string> hash_label_map;\ndiff --git a/test/sqlite/test_sqllogictest.cpp b/test/sqlite/test_sqllogictest.cpp\nindex a3290e3bb079..90dada8a22ed 100644\n--- a/test/sqlite/test_sqllogictest.cpp\n+++ b/test/sqlite/test_sqllogictest.cpp\n@@ -33,6 +33,7 @@ static bool endsWith(const string &mainStr, const string &toMatch) {\n \t        mainStr.compare(mainStr.size() - toMatch.size(), toMatch.size(), toMatch) == 0);\n }\n \n+template <bool VERIFICATION>\n static void testRunner() {\n \t// this is an ugly hack that uses the test case name to pass the script file\n \t// name if someone has a better idea...\n@@ -47,6 +48,7 @@ static void testRunner() {\n \t}\n \tSQLLogicTestRunner runner(move(initial_dbpath));\n \trunner.output_sql = Catch::getCurrentContext().getConfig()->outputSQL();\n+\trunner.enable_verification = VERIFICATION;\n \trunner.ExecuteFile(name);\n }\n \n@@ -81,72 +83,99 @@ static string ParseGroupFromPath(string file) {\n namespace duckdb {\n \n void RegisterSqllogictests() {\n+\tvector<string> enable_verification_excludes = {\n+\t    // too slow for verification\n+\t    \"test/select5.test\",\n+\t    \"test/index\",\n+\t    // optimization masks int32 overflow\n+\t    \"test/random/aggregates/slt_good_102.test\",\n+\t    \"test/random/aggregates/slt_good_11.test\",\n+\t    \"test/random/aggregates/slt_good_115.test\",\n+\t    \"test/random/aggregates/slt_good_116.test\",\n+\t    \"test/random/aggregates/slt_good_118.test\",\n+\t    \"test/random/aggregates/slt_good_119.test\",\n+\t    \"test/random/aggregates/slt_good_122.test\",\n+\t    \"test/random/aggregates/slt_good_17.test\",\n+\t    \"test/random/aggregates/slt_good_20.test\",\n+\t    \"test/random/aggregates/slt_good_23.test\",\n+\t    \"test/random/aggregates/slt_good_25.test\",\n+\t    \"test/random/aggregates/slt_good_3.test\",\n+\t    \"test/random/aggregates/slt_good_30.test\",\n+\t    \"test/random/aggregates/slt_good_31.test\",\n+\t    \"test/random/aggregates/slt_good_38.test\",\n+\t    \"test/random/aggregates/slt_good_39.test\",\n+\t    \"test/random/aggregates/slt_good_4.test\",\n+\t    \"test/random/aggregates/slt_good_43.test\",\n+\t    \"test/random/aggregates/slt_good_46.test\",\n+\t    \"test/random/aggregates/slt_good_51.test\",\n+\t    \"test/random/aggregates/slt_good_56.test\",\n+\t    \"test/random/aggregates/slt_good_66.test\",\n+\t    \"test/random/aggregates/slt_good_7.test\",\n+\t    \"test/random/aggregates/slt_good_72.test\",\n+\t    \"test/random/aggregates/slt_good_82.test\",\n+\t    \"test/random/aggregates/slt_good_84.test\",\n+\t    \"test/random/aggregates/slt_good_85.test\",\n+\t    \"test/random/aggregates/slt_good_91.test\",\n+\t    \"test/random/expr/slt_good_15.test\",\n+\t    \"test/random/expr/slt_good_66.test\",\n+\t    \"test/random/expr/slt_good_91.test\",\n+\t};\n \tvector<string> excludes = {\n-\t    \"test/select1.test\", // tested separately\n-\t    \"test/select2.test\", \"test/select3.test\", \"test/select4.test\",\n-\t    \"test/index\",                     // no index yet\n-\t    \"random/groupby/\",                // having column binding issue with first\n-\t    \"random/select/slt_good_70.test\", // join on not between\n-\t    \"random/expr/slt_good_10.test\",   // these all fail because the AVG\n-\t                                      // decimal rewrite\n-\t    \"random/expr/slt_good_102.test\", \"random/expr/slt_good_107.test\", \"random/expr/slt_good_108.test\",\n-\t    \"random/expr/slt_good_109.test\", \"random/expr/slt_good_111.test\", \"random/expr/slt_good_112.test\",\n-\t    \"random/expr/slt_good_113.test\", \"random/expr/slt_good_115.test\", \"random/expr/slt_good_116.test\",\n-\t    \"random/expr/slt_good_117.test\", \"random/expr/slt_good_13.test\", \"random/expr/slt_good_15.test\",\n-\t    \"random/expr/slt_good_16.test\", \"random/expr/slt_good_17.test\", \"random/expr/slt_good_19.test\",\n-\t    \"random/expr/slt_good_21.test\", \"random/expr/slt_good_22.test\", \"random/expr/slt_good_24.test\",\n-\t    \"random/expr/slt_good_28.test\", \"random/expr/slt_good_29.test\", \"random/expr/slt_good_3.test\",\n-\t    \"random/expr/slt_good_30.test\", \"random/expr/slt_good_34.test\", \"random/expr/slt_good_38.test\",\n-\t    \"random/expr/slt_good_4.test\", \"random/expr/slt_good_41.test\", \"random/expr/slt_good_44.test\",\n-\t    \"random/expr/slt_good_45.test\", \"random/expr/slt_good_49.test\", \"random/expr/slt_good_52.test\",\n-\t    \"random/expr/slt_good_53.test\", \"random/expr/slt_good_55.test\", \"random/expr/slt_good_59.test\",\n-\t    \"random/expr/slt_good_6.test\", \"random/expr/slt_good_60.test\", \"random/expr/slt_good_63.test\",\n-\t    \"random/expr/slt_good_64.test\", \"random/expr/slt_good_67.test\", \"random/expr/slt_good_69.test\",\n-\t    \"random/expr/slt_good_7.test\", \"random/expr/slt_good_71.test\", \"random/expr/slt_good_72.test\",\n-\t    \"random/expr/slt_good_8.test\", \"random/expr/slt_good_80.test\", \"random/expr/slt_good_82.test\",\n-\t    \"random/expr/slt_good_85.test\", \"random/expr/slt_good_9.test\", \"random/expr/slt_good_90.test\",\n-\t    \"random/expr/slt_good_91.test\", \"random/expr/slt_good_94.test\", \"random/expr/slt_good_95.test\",\n-\t    \"random/expr/slt_good_96.test\", \"random/expr/slt_good_99.test\", \"random/aggregates/slt_good_2.test\",\n-\t    \"random/aggregates/slt_good_5.test\", \"random/aggregates/slt_good_7.test\", \"random/aggregates/slt_good_9.test\",\n-\t    \"random/aggregates/slt_good_17.test\", \"random/aggregates/slt_good_28.test\",\n-\t    \"random/aggregates/slt_good_45.test\", \"random/aggregates/slt_good_50.test\",\n-\t    \"random/aggregates/slt_good_52.test\", \"random/aggregates/slt_good_58.test\",\n-\t    \"random/aggregates/slt_good_65.test\", \"random/aggregates/slt_good_66.test\",\n-\t    \"random/aggregates/slt_good_76.test\", \"random/aggregates/slt_good_81.test\",\n-\t    \"random/aggregates/slt_good_90.test\", \"random/aggregates/slt_good_96.test\",\n-\t    \"random/aggregates/slt_good_102.test\", \"random/aggregates/slt_good_106.test\",\n-\t    \"random/aggregates/slt_good_112.test\", \"random/aggregates/slt_good_118.test\",\n-\t    \"third_party/sqllogictest/test/evidence/in1.test\", // UNIQUE index on text\n-\t    \"evidence/slt_lang_replace.test\",                  // feature not supported\n-\t    \"evidence/slt_lang_reindex.test\",                  // \"\n-\t    \"evidence/slt_lang_dropindex.test\",                // \"\n-\t    \"evidence/slt_lang_createtrigger.test\",            // \"\n-\t    \"evidence/slt_lang_droptrigger.test\",              // \"\n-\t    \"evidence/slt_lang_update.test\",                   //  Multiple assignments to same column \"x\"\n-\t    // these fail because of overflows in multiplications (sqlite does automatic upcasting)\n-\t    \"random/aggregates/slt_good_51.test\", \"random/aggregates/slt_good_73.test\", \"random/aggregates/slt_good_3.test\",\n-\t    \"random/aggregates/slt_good_64.test\", \"random/aggregates/slt_good_122.test\",\n-\t    \"random/aggregates/slt_good_110.test\", \"random/aggregates/slt_good_101.test\",\n-\t    \"random/aggregates/slt_good_56.test\", \"random/aggregates/slt_good_75.test\", \"random/expr/slt_good_51.test\",\n-\t    \"random/expr/slt_good_77.test\", \"random/expr/slt_good_66.test\", \"random/expr/slt_good_0.test\",\n-\t    \"random/expr/slt_good_61.test\", \"random/expr/slt_good_47.test\", \"random/expr/slt_good_11.test\",\n-\t    \"random/expr/slt_good_40.test\", \"random/expr/slt_good_42.test\", \"random/expr/slt_good_27.test\",\n-\t    \"random/expr/slt_good_103.test\", \"random/expr/slt_good_75.test\"};\n+\t    // tested separately\n+\t    \"test/select1.test\", \"test/select2.test\", \"test/select3.test\", \"test/select4.test\",\n+\t    // feature not supported\n+\t    \"evidence/slt_lang_replace.test\",       // INSERT OR REPLACE\n+\t    \"evidence/slt_lang_reindex.test\",       // REINDEX\n+\t    \"evidence/slt_lang_update.test\",        // Multiple assignments to same column \"x\" in update\n+\t    \"evidence/slt_lang_createtrigger.test\", // TRIGGER\n+\t    \"evidence/slt_lang_droptrigger.test\",   // TRIGGER\n+\t                                            // no + for varchar columns\n+\t    \"test/index/random/10/slt_good_14.test\", \"test/index/random/10/slt_good_1.test\",\n+\t    \"test/index/random/10/slt_good_0.test\", \"test/index/random/10/slt_good_12.test\",\n+\t    \"test/index/random/10/slt_good_6.test\", \"test/index/random/10/slt_good_13.test\",\n+\t    \"test/index/random/10/slt_good_5.test\", \"test/index/random/10/slt_good_10.test\",\n+\t    \"test/index/random/10/slt_good_11.test\", \"test/index/random/10/slt_good_4.test\",\n+\t    \"test/index/random/10/slt_good_8.test\", \"test/index/random/10/slt_good_3.test\",\n+\t    \"test/index/random/10/slt_good_2.test\", \"test/index/random/100/slt_good_1.test\",\n+\t    \"test/index/random/100/slt_good_0.test\", \"test/index/random/1000/slt_good_0.test\",\n+\t    \"test/index/random/1000/slt_good_7.test\", \"test/index/random/1000/slt_good_6.test\",\n+\t    \"test/index/random/1000/slt_good_5.test\", \"test/index/random/1000/slt_good_8.test\",\n+\t    // overflow in 32-bit integer multiplication (sqlite does automatic upcasting)\n+\t    \"test/random/aggregates/slt_good_96.test\", \"test/random/aggregates/slt_good_75.test\",\n+\t    \"test/random/aggregates/slt_good_64.test\", \"test/random/aggregates/slt_good_9.test\",\n+\t    \"test/random/aggregates/slt_good_110.test\", \"test/random/aggregates/slt_good_101.test\",\n+\t    \"test/random/expr/slt_good_55.test\", \"test/random/expr/slt_good_115.test\", \"test/random/expr/slt_good_103.test\",\n+\t    \"test/random/expr/slt_good_80.test\", \"test/random/expr/slt_good_75.test\", \"test/random/expr/slt_good_42.test\",\n+\t    \"test/random/expr/slt_good_49.test\", \"test/random/expr/slt_good_24.test\", \"test/random/expr/slt_good_30.test\",\n+\t    \"test/random/expr/slt_good_8.test\", \"test/random/expr/slt_good_61.test\",\n+\t    // strange error in hash comparison, results appear correct...\n+\t    \"test/index/random/10/slt_good_7.test\", \"test/index/random/10/slt_good_9.test\"};\n \tunique_ptr<FileSystem> fs = FileSystem::CreateLocal();\n-\tlistFiles(*fs, fs->JoinPath(fs->JoinPath(\"third_party\", \"sqllogictest\"), \"test\"), [excludes](const string &path) {\n+\tlistFiles(*fs, fs->JoinPath(fs->JoinPath(\"third_party\", \"sqllogictest\"), \"test\"), [&](const string &path) {\n \t\tif (endsWith(path, \".test\")) {\n-\t\t\tfor (auto excl : excludes) {\n+\t\t\tfor (auto &excl : excludes) {\n \t\t\t\tif (path.find(excl) != string::npos) {\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tREGISTER_TEST_CASE(testRunner, StringUtil::Replace(path, \"\\\\\", \"/\"), \"[sqlitelogic][.]\");\n+\t\t\tbool enable_verification = true;\n+\t\t\tfor (auto &excl : enable_verification_excludes) {\n+\t\t\t\tif (path.find(excl) != string::npos) {\n+\t\t\t\t\tenable_verification = false;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (enable_verification) {\n+\t\t\t\tREGISTER_TEST_CASE(testRunner<true>, StringUtil::Replace(path, \"\\\\\", \"/\"), \"[sqlitelogic][.]\");\n+\t\t\t} else {\n+\t\t\t\tREGISTER_TEST_CASE(testRunner<false>, StringUtil::Replace(path, \"\\\\\", \"/\"), \"[sqlitelogic][.]\");\n+\t\t\t}\n \t\t}\n \t});\n-\tlistFiles(*fs, \"test\", [excludes](const string &path) {\n+\tlistFiles(*fs, \"test\", [&](const string &path) {\n \t\tif (endsWith(path, \".test\") || endsWith(path, \".test_slow\") || endsWith(path, \".test_coverage\")) {\n \t\t\t// parse the name / group from the test\n-\t\t\tREGISTER_TEST_CASE(testRunner, StringUtil::Replace(path, \"\\\\\", \"/\"), ParseGroupFromPath(path));\n+\t\t\tREGISTER_TEST_CASE(testRunner<false>, StringUtil::Replace(path, \"\\\\\", \"/\"), ParseGroupFromPath(path));\n \t\t}\n \t});\n }\n",
  "problem_statement": "different query results with optimizer on vs. off\n#### What happens?\r\nWorking with @tiagokepe on ODBC driver in Windows. After running SQLite SqlLogicTests found a few queries that produced incorrect results:\r\n\r\n```\r\nSELECT pk FROM tab0 WHERE (col0 BETWEEN 67 AND 0 OR col0 > 17 AND (col0 > 3));\r\nSELECT pk FROM tab0 WHERE 84 > col0 OR 8 > col0 ;\r\n```\r\n\r\nDisabling the optimizer gives the correct result. Also changing the order of the elements in the where clause can produce the correct result. See the attached sql script files for more details. \r\n\r\n#### To Reproduce\r\nAttached are two SQL query script files. Open a CMD window and feed them to duckdb and each will generate an output txt file which are also attached.\r\n\r\n```\r\nduckdb < duckdb_issues_between.sql\r\nduckdb < duckdb_issues_between.sql\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Windows\r\n - DuckDB Version:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 library_version \u2502 source_id \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 v0.3.5-dev164   \u2502 e4ba94a4f \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n - DuckDB Client: command line\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\nYes.\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\nYes see attached .sql files. Note that I had to add .txt extension to upload to github. \r\n\r\n[duckdb_issues_between.sql.txt](https://github.com/duckdb/duckdb/files/8705268/duckdb_issues_between.sql.txt)\r\n[duckdb_issues_comparison.sql.txt](https://github.com/duckdb/duckdb/files/8705269/duckdb_issues_comparison.sql.txt)\r\n[between_issue.txt](https://github.com/duckdb/duckdb/files/8705283/between_issue.txt)\r\n[comparison.txt](https://github.com/duckdb/duckdb/files/8705284/comparison.txt)\r\n\r\n\ndifferent query results with optimizer on vs. off\n#### What happens?\r\nWorking with @tiagokepe on ODBC driver in Windows. After running SQLite SqlLogicTests found a few queries that produced incorrect results:\r\n\r\n```\r\nSELECT pk FROM tab0 WHERE (col0 BETWEEN 67 AND 0 OR col0 > 17 AND (col0 > 3));\r\nSELECT pk FROM tab0 WHERE 84 > col0 OR 8 > col0 ;\r\n```\r\n\r\nDisabling the optimizer gives the correct result. Also changing the order of the elements in the where clause can produce the correct result. See the attached sql script files for more details. \r\n\r\n#### To Reproduce\r\nAttached are two SQL query script files. Open a CMD window and feed them to duckdb and each will generate an output txt file which are also attached.\r\n\r\n```\r\nduckdb < duckdb_issues_between.sql\r\nduckdb < duckdb_issues_between.sql\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Windows\r\n - DuckDB Version:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 library_version \u2502 source_id \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 v0.3.5-dev164   \u2502 e4ba94a4f \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n - DuckDB Client: command line\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\nYes.\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\nYes see attached .sql files. Note that I had to add .txt extension to upload to github. \r\n\r\n[duckdb_issues_between.sql.txt](https://github.com/duckdb/duckdb/files/8705268/duckdb_issues_between.sql.txt)\r\n[duckdb_issues_comparison.sql.txt](https://github.com/duckdb/duckdb/files/8705269/duckdb_issues_comparison.sql.txt)\r\n[between_issue.txt](https://github.com/duckdb/duckdb/files/8705283/between_issue.txt)\r\n[comparison.txt](https://github.com/duckdb/duckdb/files/8705284/comparison.txt)\r\n\r\n\n",
  "hints_text": "Thanks for the detailed bug report.\r\n\r\nI think this is an error with statistics propagation. In most cases we verify statistics in our tests, but in `column_binding_resolver.cpp:78`, we create a `BoundReferenceExpression`, without copying the `verification_stats` from the `BoundColumnRefExpression` over to it. This can let bugs with statistics propagation slip through.\nThanks for the report!\r\n\r\nThe statistics propagation here actually seems correct. The problem appears to be in the `OR` filter pushdown. I will have a look to see if I can fix it.\nThanks for the detailed bug report.\r\n\r\nI think this is an error with statistics propagation. In most cases we verify statistics in our tests, but in `column_binding_resolver.cpp:78`, we create a `BoundReferenceExpression`, without copying the `verification_stats` from the `BoundColumnRefExpression` over to it. This can let bugs with statistics propagation slip through.\nThanks for the report!\r\n\r\nThe statistics propagation here actually seems correct. The problem appears to be in the `OR` filter pushdown. I will have a look to see if I can fix it.",
  "created_at": "2022-05-19T06:19:25Z"
}