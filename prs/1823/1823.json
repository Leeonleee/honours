{
  "repo": "duckdb/duckdb",
  "pull_number": 1823,
  "instance_id": "duckdb__duckdb-1823",
  "issue_numbers": [
    "1812"
  ],
  "base_commit": "cf9cb672c00373063f6458fcab5a366f4d985dc5",
  "patch": "diff --git a/src/optimizer/rule/distributivity.cpp b/src/optimizer/rule/distributivity.cpp\nindex cf527caa2088..50b1d3265b68 100644\n--- a/src/optimizer/rule/distributivity.cpp\n+++ b/src/optimizer/rule/distributivity.cpp\n@@ -95,11 +95,21 @@ unique_ptr<Expression> DistributivityRule::Apply(LogicalOperator &op, vector<Exp\n \t\t}\n \t\t// now we add the expression to the new root\n \t\tnew_root->children.push_back(move(result));\n-\t\t// remove any expressions that were set to nullptr\n-\t\tfor (idx_t i = 0; i < initial_or->children.size(); i++) {\n-\t\t\tif (!initial_or->children[i]) {\n-\t\t\t\tinitial_or->children.erase(initial_or->children.begin() + i);\n-\t\t\t\ti--;\n+\t}\n+\n+\t// check if we completely erased one of the children of the OR\n+\t// this happens if we have an OR in the form of \"X OR (X AND A)\"\n+\t// the left child will be completely empty, as it only contains common expressions\n+\t// in this case, any other children are not useful:\n+\t// X OR (X AND A) is the same as \"X\"\n+\t// since (1) only tuples that do not qualify \"X\" will not pass this predicate\n+\t//   and (2) all tuples that qualify \"X\" will pass this predicate\n+\tfor (idx_t i = 0; i < initial_or->children.size(); i++) {\n+\t\tif (!initial_or->children[i]) {\n+\t\t\tif (new_root->children.size() <= 1) {\n+\t\t\t\treturn move(new_root->children[0]);\n+\t\t\t} else {\n+\t\t\t\treturn move(new_root);\n \t\t\t}\n \t\t}\n \t}\n",
  "test_patch": "diff --git a/test/optimizer/distributivity_rule.test b/test/optimizer/distributivity_rule.test\nindex 8fec60298d97..ca12e4dfbdee 100644\n--- a/test/optimizer/distributivity_rule.test\n+++ b/test/optimizer/distributivity_rule.test\n@@ -31,10 +31,6 @@ query I nosort distributivity3\n EXPLAIN SELECT X OR X FROM test\n ----\n \n-query I nosort distributivity3\n-EXPLAIN SELECT X FROM test\n-----\n-\n query I nosort distributivity3\n EXPLAIN SELECT X OR X OR X OR X FROM test\n ----\n@@ -43,13 +39,13 @@ query I nosort distributivity3\n EXPLAIN SELECT X OR (X OR (X OR X)) FROM test\n ----\n \n-# X OR (X AND A) => X AND A\n+# X OR (X AND A) => X\n query I nosort distributivity4\n EXPLAIN SELECT X OR (X AND A) FROM test\n ----\n \n query I nosort distributivity4\n-EXPLAIN SELECT X AND A FROM test\n+EXPLAIN SELECT X OR X FROM test\n ----\n \n statement ok\ndiff --git a/test/sql/function/string/test_issue_1812.test b/test/sql/function/string/test_issue_1812.test\nnew file mode 100644\nindex 000000000000..787a24f1249f\n--- /dev/null\n+++ b/test/sql/function/string/test_issue_1812.test\n@@ -0,0 +1,58 @@\n+# name: test/sql/function/string/test_issue_1812.test\n+# description: Test LIKE statement\n+# group: [string]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t (str VARCHAR);\n+\n+statement ok\n+INSERT INTO t VALUES ('hello1'), ('hello2'), ('hello3'), ('world1'), ('world2'), ('world3');\n+\n+query I\n+SELECT COUNT(*) FROM t WHERE str LIKE '%o%'; -- 6\n+----\n+6\n+\n+query I\n+SELECT COUNT(*) FROM t WHERE str LIKE '%rld%'; -- 3\n+----\n+3\n+\n+query I\n+SELECT COUNT(*) FROM t WHERE str LIKE '%o%' OR (str LIKE '%o%' AND str LIKE '%rld%');\n+----\n+6\n+\n+query I\n+SELECT COUNT(*) FROM t\n+WHERE (str LIKE '%o%' AND str LIKE '%rld%')\n+    OR str LIKE '%o%';\n+----\n+6\n+\n+query I\n+SELECT COUNT(*) FROM t\n+WHERE (str LIKE '%o%' AND str LIKE '%rld%')\n+   OR (str LIKE '%o%')\n+   OR (str LIKE '%o%');\n+----\n+6\n+\n+query I\n+SELECT COUNT(*) FROM t\n+WHERE (str LIKE '%o%' AND str LIKE '%rld%')\n+   OR (str LIKE '%o%')\n+   OR (str LIKE '%o%' AND str LIKE 'blabla%');\n+----\n+6\n+\n+query I\n+SELECT COUNT(*) FROM t\n+WHERE (str LIKE '%o%' AND str LIKE '%1%')\n+   OR (str LIKE '%o%' AND str LIKE '%1%' AND str LIKE 'blabla%')\n+   OR (str LIKE '%o%' AND str LIKE '%1%' AND str LIKE 'blabla2%')\n+----\n+2\n",
  "problem_statement": "SQL AND/OR logic error with LIKE string matching\n**What does happen?**\r\n\r\n```\r\nSELECT COUNT(*) FROM table -- 117\r\nSELECT COUNT(*) FROM table WHERE url LIKE '%we%' -- 117\r\nSELECT COUNT(*) FROM table WHERE url LIKE '%about%' AND url LIKE '%we%' -- 3\r\nSELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR (url LIKE '%about%' AND url LIKE '%we%') -- 3 BUG\r\nSELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR ( url LIKE '%we%' AND url LIKE '%about%' ) -- 3 BUG\r\nSELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR ( url LIKE '%w%' AND url LIKE '%about%' ) -- 117\r\n```\r\n\r\n**What should happen?**\r\n\r\n```\r\nSELECT COUNT(*) FROM table -- 117\r\nSELECT COUNT(*) FROM table WHERE url LIKE '%we%' -- 117\r\nSELECT COUNT(*) FROM table WHERE url LIKE '%about%' AND url LIKE '%we%' -- 3\r\nSELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR (url LIKE '%about%' AND url LIKE '%we%') -- 117 CORRECT\r\nSELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR ( url LIKE '%we%' AND url LIKE '%about%' ) -- 117 CORRECT\r\nSELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR ( url LIKE '%w%' AND url LIKE '%about%' ) -- 117\r\n```\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n1. See the queries above\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Linux\r\n - DuckDB Version: `https://github.com/cwida/duckdb/archive/7c1a2f2867dfe5b02717e7bd7cf7ed46fbe08a34.tar.gz` (quite recent/latest master)\r\n\r\n**Before submitting**\r\n- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\n",
  "hints_text": "@hannesmuehleisen We found potential Parquet reader bug.\nMay have relation to this https://github.com/duckdb/duckdb/issues/1391\nNot that I know anything about the internals - but it looks like it would take the already calculated \"index\" for \"%we%\" then applies the AND \"%about%\" on it and gives the results (3). Whilst, instead it should honor the OR and calculate them separately (separate \"index\" for \"%we%\" for both queries on the sides of the OR statement).\r\n\r\n(using the \"%w%\" on the 2nd filter seems to hint towards this.)\nThanks, still missing whatever is in `table` here. Could you try to share a file that demonstrates the issue? Does this also happen with data in regular tables?\nIt actually does not have anything to do with Parquet.\r\n\r\n```\r\nCREATE TABLE t (str VARCHAR);\r\nINSERT INTO t VALUES ('hello1'), ('hello2'), ('hello3'), ('world1'), ('world2'), ('world3');\r\nSELECT COUNT(*) FROM t WHERE str LIKE '%o%'; -- 6\r\nSELECT COUNT(*) FROM t WHERE str LIKE '%rld%'; -- 3\r\nSELECT COUNT(*) FROM t WHERE str LIKE '%o%' OR (str LIKE '%o%' AND str LIKE '%rld%'); -- 3 BUG, should still be 6\r\n```\nThanks for the reproducible example! Will have a look.",
  "created_at": "2021-05-31T13:13:26Z"
}