diff --git a/src/optimizer/rule/distributivity.cpp b/src/optimizer/rule/distributivity.cpp
index cf527caa2088..50b1d3265b68 100644
--- a/src/optimizer/rule/distributivity.cpp
+++ b/src/optimizer/rule/distributivity.cpp
@@ -95,11 +95,21 @@ unique_ptr<Expression> DistributivityRule::Apply(LogicalOperator &op, vector<Exp
 		}
 		// now we add the expression to the new root
 		new_root->children.push_back(move(result));
-		// remove any expressions that were set to nullptr
-		for (idx_t i = 0; i < initial_or->children.size(); i++) {
-			if (!initial_or->children[i]) {
-				initial_or->children.erase(initial_or->children.begin() + i);
-				i--;
+	}
+
+	// check if we completely erased one of the children of the OR
+	// this happens if we have an OR in the form of "X OR (X AND A)"
+	// the left child will be completely empty, as it only contains common expressions
+	// in this case, any other children are not useful:
+	// X OR (X AND A) is the same as "X"
+	// since (1) only tuples that do not qualify "X" will not pass this predicate
+	//   and (2) all tuples that qualify "X" will pass this predicate
+	for (idx_t i = 0; i < initial_or->children.size(); i++) {
+		if (!initial_or->children[i]) {
+			if (new_root->children.size() <= 1) {
+				return move(new_root->children[0]);
+			} else {
+				return move(new_root);
 			}
 		}
 	}
