You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
SQL AND/OR logic error with LIKE string matching
**What does happen?**

```
SELECT COUNT(*) FROM table -- 117
SELECT COUNT(*) FROM table WHERE url LIKE '%we%' -- 117
SELECT COUNT(*) FROM table WHERE url LIKE '%about%' AND url LIKE '%we%' -- 3
SELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR (url LIKE '%about%' AND url LIKE '%we%') -- 3 BUG
SELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR ( url LIKE '%we%' AND url LIKE '%about%' ) -- 3 BUG
SELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR ( url LIKE '%w%' AND url LIKE '%about%' ) -- 117
```

**What should happen?**

```
SELECT COUNT(*) FROM table -- 117
SELECT COUNT(*) FROM table WHERE url LIKE '%we%' -- 117
SELECT COUNT(*) FROM table WHERE url LIKE '%about%' AND url LIKE '%we%' -- 3
SELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR (url LIKE '%about%' AND url LIKE '%we%') -- 117 CORRECT
SELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR ( url LIKE '%we%' AND url LIKE '%about%' ) -- 117 CORRECT
SELECT COUNT(*) FROM table WHERE url LIKE '%we%' OR ( url LIKE '%w%' AND url LIKE '%about%' ) -- 117
```

**To Reproduce**
Steps to reproduce the behavior. Bonus points if those are only SQL queries.
1. See the queries above

**Environment (please complete the following information):**
 - OS: Linux
 - DuckDB Version: `https://github.com/cwida/duckdb/archive/7c1a2f2867dfe5b02717e7bd7cf7ed46fbe08a34.tar.gz` (quite recent/latest master)

**Before submitting**
- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?
- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds


</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/optimizer/rule/distributivity.cpp]
1: #include "duckdb/optimizer/rule/distributivity.hpp"
2: 
3: #include "duckdb/optimizer/matcher/expression_matcher.hpp"
4: #include "duckdb/planner/expression/bound_conjunction_expression.hpp"
5: #include "duckdb/planner/expression/bound_constant_expression.hpp"
6: #include "duckdb/planner/expression_iterator.hpp"
7: #include "duckdb/planner/operator/logical_filter.hpp"
8: 
9: namespace duckdb {
10: 
11: DistributivityRule::DistributivityRule(ExpressionRewriter &rewriter) : Rule(rewriter) {
12: 	// we match on an OR expression within a LogicalFilter node
13: 	root = make_unique<ExpressionMatcher>();
14: 	root->expr_type = make_unique<SpecificExpressionTypeMatcher>(ExpressionType::CONJUNCTION_OR);
15: }
16: 
17: void DistributivityRule::AddExpressionSet(Expression &expr, expression_set_t &set) {
18: 	if (expr.type == ExpressionType::CONJUNCTION_AND) {
19: 		auto &and_expr = (BoundConjunctionExpression &)expr;
20: 		for (auto &child : and_expr.children) {
21: 			set.insert(child.get());
22: 		}
23: 	} else {
24: 		set.insert(&expr);
25: 	}
26: }
27: 
28: unique_ptr<Expression> DistributivityRule::ExtractExpression(BoundConjunctionExpression &conj, idx_t idx,
29:                                                              Expression &expr) {
30: 	auto &child = conj.children[idx];
31: 	unique_ptr<Expression> result;
32: 	if (child->type == ExpressionType::CONJUNCTION_AND) {
33: 		// AND, remove expression from the list
34: 		auto &and_expr = (BoundConjunctionExpression &)*child;
35: 		for (idx_t i = 0; i < and_expr.children.size(); i++) {
36: 			if (Expression::Equals(and_expr.children[i].get(), &expr)) {
37: 				result = move(and_expr.children[i]);
38: 				and_expr.children.erase(and_expr.children.begin() + i);
39: 				break;
40: 			}
41: 		}
42: 		if (and_expr.children.size() == 1) {
43: 			conj.children[idx] = move(and_expr.children[0]);
44: 		}
45: 	} else {
46: 		// not an AND node! remove the entire expression
47: 		// this happens in the case of e.g. (X AND B) OR X
48: 		D_ASSERT(Expression::Equals(child.get(), &expr));
49: 		result = move(child);
50: 		conj.children[idx] = nullptr;
51: 	}
52: 	D_ASSERT(result);
53: 	return result;
54: }
55: 
56: unique_ptr<Expression> DistributivityRule::Apply(LogicalOperator &op, vector<Expression *> &bindings,
57:                                                  bool &changes_made) {
58: 	auto initial_or = (BoundConjunctionExpression *)bindings[0];
59: 
60: 	// we want to find expressions that occur in each of the children of the OR
61: 	// i.e. (X AND A) OR (X AND B) => X occurs in all branches
62: 	// first, for the initial child, we create an expression set of which expressions occur
63: 	// this is our initial candidate set (in the example: [X, A])
64: 	expression_set_t candidate_set;
65: 	AddExpressionSet(*initial_or->children[0], candidate_set);
66: 	// now for each of the remaining children, we create a set again and intersect them
67: 	// in our example: the second set would be [X, B]
68: 	// the intersection would leave [X]
69: 	for (idx_t i = 1; i < initial_or->children.size(); i++) {
70: 		expression_set_t next_set;
71: 		AddExpressionSet(*initial_or->children[i], next_set);
72: 		expression_set_t intersect_result;
73: 		for (auto &expr : candidate_set) {
74: 			if (next_set.find(expr) != next_set.end()) {
75: 				intersect_result.insert(expr);
76: 			}
77: 		}
78: 		candidate_set = intersect_result;
79: 	}
80: 	if (candidate_set.empty()) {
81: 		// nothing found: abort
82: 		return nullptr;
83: 	}
84: 	// now for each of the remaining expressions in the candidate set we know that it is contained in all branches of
85: 	// the OR
86: 	auto new_root = make_unique<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
87: 	for (auto &expr : candidate_set) {
88: 		D_ASSERT(initial_or->children.size() > 0);
89: 
90: 		// extract the expression from the first child of the OR
91: 		auto result = ExtractExpression(*initial_or, 0, (Expression &)*expr);
92: 		// now for the subsequent expressions, simply remove the expression
93: 		for (idx_t i = 1; i < initial_or->children.size(); i++) {
94: 			ExtractExpression(*initial_or, i, *result);
95: 		}
96: 		// now we add the expression to the new root
97: 		new_root->children.push_back(move(result));
98: 		// remove any expressions that were set to nullptr
99: 		for (idx_t i = 0; i < initial_or->children.size(); i++) {
100: 			if (!initial_or->children[i]) {
101: 				initial_or->children.erase(initial_or->children.begin() + i);
102: 				i--;
103: 			}
104: 		}
105: 	}
106: 	// finally we need to add the remaining expressions in the OR to the new root
107: 	if (initial_or->children.size() == 1) {
108: 		// one child: skip the OR entirely and only add the single child
109: 		new_root->children.push_back(move(initial_or->children[0]));
110: 	} else if (initial_or->children.size() > 1) {
111: 		// multiple children still remain: push them into a new OR and add that to the new root
112: 		auto new_or = make_unique<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
113: 		for (auto &child : initial_or->children) {
114: 			new_or->children.push_back(move(child));
115: 		}
116: 		new_root->children.push_back(move(new_or));
117: 	}
118: 	// finally return the new root
119: 	if (new_root->children.size() == 1) {
120: 		return move(new_root->children[0]);
121: 	}
122: 	return move(new_root);
123: }
124: 
125: } // namespace duckdb
[end of src/optimizer/rule/distributivity.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: