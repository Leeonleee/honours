You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Should a UNION with untyped NULL preserve the type?
Currently it doesn't for `BOOLEAN`, DBItest `"data_logical"` .

``` r
library(DBI)

drv1 <- duckdb::duckdb()
conn1 <- dbConnect(drv1, debug = TRUE)
dbDataType(conn1, logical(0))
#> [1] "BOOLEAN"
dbGetQuery(conn1, "SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b")
#> Q SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b
#>      a     b
#> 1 TRUE FALSE
dbGetQuery(conn1, "SELECT NULL as a, NULL as b, 1 as id UNION SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 2 as id")
#> Q SELECT NULL as a, NULL as b, 1 as id UNION SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 2 as id
#>    a  b id
#> 1 NA NA  1
#> 2  1  0  2
dbGetQuery(conn1, "SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 1 as id UNION SELECT NULL as a, NULL as b, 2 as id")
#> Q SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 1 as id UNION SELECT NULL as a, NULL as b, 2 as id
#>    a  b id
#> 1  1  0  1
#> 2 NA NA  2
```

<sup>Created on 2020-10-25 by the [reprex package](https://reprex.tidyverse.org) (v0.3.0)</sup>

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![codecov](https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN)](https://codecov.io/gh/duckdb/duckdb)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/common/vector_operations/vector_cast.cpp]
1: #include "duckdb/common/operator/cast_operators.hpp"
2: #include "duckdb/common/types/cast_helpers.hpp"
3: #include "duckdb/common/types/chunk_collection.hpp"
4: #include "duckdb/common/operator/string_cast.hpp"
5: #include "duckdb/common/vector_operations/unary_executor.hpp"
6: #include "duckdb/common/vector_operations/vector_operations.hpp"
7: #include "duckdb/common/types/null_value.hpp"
8: #include "duckdb/common/string_util.hpp"
9: #include "duckdb/common/vector_operations/decimal_cast.hpp"
10: #include "duckdb/common/operator/numeric_cast.hpp"
11: #include "duckdb/common/likely.hpp"
12: 
13: namespace duckdb {
14: 
15: template <class OP>
16: struct VectorStringCastOperator {
17: 	template <class INPUT_TYPE, class RESULT_TYPE>
18: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
19: 		auto result = (Vector *)dataptr;
20: 		return OP::template Operation<INPUT_TYPE>(input, *result);
21: 	}
22: };
23: 
24: struct VectorTryCastData {
25: 	VectorTryCastData(Vector &result_p, string *error_message_p, bool strict_p)
26: 	    : result(result_p), error_message(error_message_p), strict(strict_p) {
27: 	}
28: 
29: 	Vector &result;
30: 	string *error_message;
31: 	bool strict;
32: 	bool all_converted = true;
33: };
34: 
35: template <class OP>
36: struct VectorTryCastOperator {
37: 	template <class INPUT_TYPE, class RESULT_TYPE>
38: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
39: 		RESULT_TYPE output;
40: 		if (DUCKDB_LIKELY(OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input, output))) {
41: 			return output;
42: 		}
43: 		auto data = (VectorTryCastData *)dataptr;
44: 		return HandleVectorCastError::Operation<RESULT_TYPE>(CastExceptionText<INPUT_TYPE, RESULT_TYPE>(input), mask,
45: 		                                                     idx, data->error_message, data->all_converted);
46: 	}
47: };
48: 
49: template <class OP>
50: struct VectorTryCastStrictOperator {
51: 	template <class INPUT_TYPE, class RESULT_TYPE>
52: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
53: 		auto data = (VectorTryCastData *)dataptr;
54: 		RESULT_TYPE output;
55: 		if (DUCKDB_LIKELY(OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input, output, data->strict))) {
56: 			return output;
57: 		}
58: 		return HandleVectorCastError::Operation<RESULT_TYPE>(CastExceptionText<INPUT_TYPE, RESULT_TYPE>(input), mask,
59: 		                                                     idx, data->error_message, data->all_converted);
60: 	}
61: };
62: 
63: template <class OP>
64: struct VectorTryCastErrorOperator {
65: 	template <class INPUT_TYPE, class RESULT_TYPE>
66: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
67: 		auto data = (VectorTryCastData *)dataptr;
68: 		RESULT_TYPE output;
69: 		if (DUCKDB_LIKELY(
70: 		        OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input, output, data->error_message, data->strict))) {
71: 			return output;
72: 		}
73: 		bool has_error = data->error_message && !data->error_message->empty();
74: 		return HandleVectorCastError::Operation<RESULT_TYPE>(
75: 		    has_error ? *data->error_message : CastExceptionText<INPUT_TYPE, RESULT_TYPE>(input), mask, idx,
76: 		    data->error_message, data->all_converted);
77: 	}
78: };
79: 
80: template <class OP>
81: struct VectorTryCastStringOperator {
82: 	template <class INPUT_TYPE, class RESULT_TYPE>
83: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
84: 		auto data = (VectorTryCastData *)dataptr;
85: 		RESULT_TYPE output;
86: 		if (DUCKDB_LIKELY(OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input, output, data->result,
87: 		                                                                  data->error_message, data->strict))) {
88: 			return output;
89: 		}
90: 		return HandleVectorCastError::Operation<RESULT_TYPE>(CastExceptionText<INPUT_TYPE, RESULT_TYPE>(input), mask,
91: 		                                                     idx, data->error_message, data->all_converted);
92: 	}
93: };
94: 
95: template <class SRC, class DST, class OP>
96: static bool TemplatedVectorTryCastLoop(Vector &source, Vector &result, idx_t count, bool strict,
97:                                        string *error_message) {
98: 	VectorTryCastData input(result, error_message, strict);
99: 	UnaryExecutor::GenericExecute<SRC, DST, OP>(source, result, count, &input, error_message);
100: 	return input.all_converted;
101: }
102: 
103: template <class SRC, class DST, class OP>
104: static bool VectorTryCastLoop(Vector &source, Vector &result, idx_t count, string *error_message) {
105: 	return TemplatedVectorTryCastLoop<SRC, DST, VectorTryCastOperator<OP>>(source, result, count, false, error_message);
106: }
107: 
108: template <class SRC, class DST, class OP>
109: static bool VectorTryCastStrictLoop(Vector &source, Vector &result, idx_t count, bool strict, string *error_message) {
110: 	return TemplatedVectorTryCastLoop<SRC, DST, VectorTryCastStrictOperator<OP>>(source, result, count, strict,
111: 	                                                                             error_message);
112: }
113: 
114: template <class SRC, class DST, class OP>
115: static bool VectorTryCastErrorLoop(Vector &source, Vector &result, idx_t count, bool strict, string *error_message) {
116: 	return TemplatedVectorTryCastLoop<SRC, DST, VectorTryCastErrorOperator<OP>>(source, result, count, strict,
117: 	                                                                            error_message);
118: }
119: 
120: template <class SRC, class DST, class OP>
121: static bool VectorTryCastStringLoop(Vector &source, Vector &result, idx_t count, bool strict, string *error_message) {
122: 	return TemplatedVectorTryCastLoop<SRC, DST, VectorTryCastStringOperator<OP>>(source, result, count, strict,
123: 	                                                                             error_message);
124: }
125: 
126: template <class SRC, class OP>
127: static void VectorStringCast(Vector &source, Vector &result, idx_t count) {
128: 	D_ASSERT(result.GetType().InternalType() == PhysicalType::VARCHAR);
129: 	UnaryExecutor::GenericExecute<SRC, string_t, VectorStringCastOperator<OP>>(source, result, count, (void *)&result);
130: }
131: 
132: template <class SRC>
133: static bool NumericCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {
134: 	// now switch on the result type
135: 	switch (result.GetType().id()) {
136: 	case LogicalTypeId::BOOLEAN:
137: 		return VectorTryCastLoop<SRC, bool, duckdb::NumericTryCast>(source, result, count, error_message);
138: 	case LogicalTypeId::TINYINT:
139: 		return VectorTryCastLoop<SRC, int8_t, duckdb::NumericTryCast>(source, result, count, error_message);
140: 	case LogicalTypeId::SMALLINT:
141: 		return VectorTryCastLoop<SRC, int16_t, duckdb::NumericTryCast>(source, result, count, error_message);
142: 	case LogicalTypeId::INTEGER:
143: 		return VectorTryCastLoop<SRC, int32_t, duckdb::NumericTryCast>(source, result, count, error_message);
144: 	case LogicalTypeId::BIGINT:
145: 		return VectorTryCastLoop<SRC, int64_t, duckdb::NumericTryCast>(source, result, count, error_message);
146: 	case LogicalTypeId::UTINYINT:
147: 		return VectorTryCastLoop<SRC, uint8_t, duckdb::NumericTryCast>(source, result, count, error_message);
148: 	case LogicalTypeId::USMALLINT:
149: 		return VectorTryCastLoop<SRC, uint16_t, duckdb::NumericTryCast>(source, result, count, error_message);
150: 	case LogicalTypeId::UINTEGER:
151: 		return VectorTryCastLoop<SRC, uint32_t, duckdb::NumericTryCast>(source, result, count, error_message);
152: 	case LogicalTypeId::UBIGINT:
153: 		return VectorTryCastLoop<SRC, uint64_t, duckdb::NumericTryCast>(source, result, count, error_message);
154: 	case LogicalTypeId::HUGEINT:
155: 		return VectorTryCastLoop<SRC, hugeint_t, duckdb::NumericTryCast>(source, result, count, error_message);
156: 	case LogicalTypeId::FLOAT:
157: 		return VectorTryCastLoop<SRC, float, duckdb::NumericTryCast>(source, result, count, error_message);
158: 	case LogicalTypeId::DOUBLE:
159: 		return VectorTryCastLoop<SRC, double, duckdb::NumericTryCast>(source, result, count, error_message);
160: 	case LogicalTypeId::DECIMAL:
161: 		return ToDecimalCast<SRC>(source, result, count, error_message);
162: 	case LogicalTypeId::VARCHAR: {
163: 		VectorStringCast<SRC, duckdb::StringCast>(source, result, count);
164: 		break;
165: 	}
166: 	case LogicalTypeId::LIST: {
167: 		VectorNullCast(source, result, count);
168: 		break;
169: 	}
170: 	default:
171: 		VectorNullCast(source, result, count);
172: 		break;
173: 	}
174: 	return true;
175: }
176: 
177: static bool VectorStringCastNumericSwitch(Vector &source, Vector &result, idx_t count, bool strict,
178:                                           string *error_message) {
179: 	// now switch on the result type
180: 	switch (result.GetType().id()) {
181: 	case LogicalTypeId::BOOLEAN:
182: 		return VectorTryCastStrictLoop<string_t, bool, duckdb::TryCast>(source, result, count, strict, error_message);
183: 	case LogicalTypeId::TINYINT:
184: 		return VectorTryCastStrictLoop<string_t, int8_t, duckdb::TryCast>(source, result, count, strict, error_message);
185: 	case LogicalTypeId::SMALLINT:
186: 		return VectorTryCastStrictLoop<string_t, int16_t, duckdb::TryCast>(source, result, count, strict,
187: 		                                                                   error_message);
188: 	case LogicalTypeId::INTEGER:
189: 		return VectorTryCastStrictLoop<string_t, int32_t, duckdb::TryCast>(source, result, count, strict,
190: 		                                                                   error_message);
191: 	case LogicalTypeId::BIGINT:
192: 		return VectorTryCastStrictLoop<string_t, int64_t, duckdb::TryCast>(source, result, count, strict,
193: 		                                                                   error_message);
194: 	case LogicalTypeId::UTINYINT:
195: 		return VectorTryCastStrictLoop<string_t, uint8_t, duckdb::TryCast>(source, result, count, strict,
196: 		                                                                   error_message);
197: 	case LogicalTypeId::USMALLINT:
198: 		return VectorTryCastStrictLoop<string_t, uint16_t, duckdb::TryCast>(source, result, count, strict,
199: 		                                                                    error_message);
200: 	case LogicalTypeId::UINTEGER:
201: 		return VectorTryCastStrictLoop<string_t, uint32_t, duckdb::TryCast>(source, result, count, strict,
202: 		                                                                    error_message);
203: 	case LogicalTypeId::UBIGINT:
204: 		return VectorTryCastStrictLoop<string_t, uint64_t, duckdb::TryCast>(source, result, count, strict,
205: 		                                                                    error_message);
206: 	case LogicalTypeId::HUGEINT:
207: 		return VectorTryCastStrictLoop<string_t, hugeint_t, duckdb::TryCast>(source, result, count, strict,
208: 		                                                                     error_message);
209: 	case LogicalTypeId::FLOAT:
210: 		return VectorTryCastStrictLoop<string_t, float, duckdb::TryCast>(source, result, count, strict, error_message);
211: 	case LogicalTypeId::DOUBLE:
212: 		return VectorTryCastStrictLoop<string_t, double, duckdb::TryCast>(source, result, count, strict, error_message);
213: 	case LogicalTypeId::INTERVAL:
214: 		return VectorTryCastErrorLoop<string_t, interval_t, duckdb::TryCastErrorMessage>(source, result, count, strict,
215: 		                                                                                 error_message);
216: 	case LogicalTypeId::DECIMAL:
217: 		return ToDecimalCast<string_t>(source, result, count, error_message);
218: 	default:
219: 		VectorNullCast(source, result, count);
220: 		break;
221: 	}
222: 	return true;
223: }
224: 
225: static bool StringCastSwitch(Vector &source, Vector &result, idx_t count, bool strict, string *error_message) {
226: 	// now switch on the result type
227: 	switch (result.GetType().id()) {
228: 	case LogicalTypeId::DATE:
229: 		return VectorTryCastErrorLoop<string_t, date_t, duckdb::TryCastErrorMessage>(source, result, count, strict,
230: 		                                                                             error_message);
231: 	case LogicalTypeId::TIME:
232: 		return VectorTryCastErrorLoop<string_t, dtime_t, duckdb::TryCastErrorMessage>(source, result, count, strict,
233: 		                                                                              error_message);
234: 	case LogicalTypeId::TIMESTAMP:
235: 		return VectorTryCastErrorLoop<string_t, timestamp_t, duckdb::TryCastErrorMessage>(source, result, count, strict,
236: 		                                                                                  error_message);
237: 	case LogicalTypeId::TIMESTAMP_NS:
238: 		return VectorTryCastStrictLoop<string_t, timestamp_t, duckdb::TryCastToTimestampNS>(source, result, count,
239: 		                                                                                    strict, error_message);
240: 	case LogicalTypeId::TIMESTAMP_SEC:
241: 		return VectorTryCastStrictLoop<string_t, timestamp_t, duckdb::TryCastToTimestampSec>(source, result, count,
242: 		                                                                                     strict, error_message);
243: 	case LogicalTypeId::TIMESTAMP_MS:
244: 		return VectorTryCastStrictLoop<string_t, timestamp_t, duckdb::TryCastToTimestampMS>(source, result, count,
245: 		                                                                                    strict, error_message);
246: 	case LogicalTypeId::BLOB:
247: 		return VectorTryCastStringLoop<string_t, string_t, duckdb::TryCastToBlob>(source, result, count, strict,
248: 		                                                                          error_message);
249: 	case LogicalTypeId::SQLNULL:
250: 		return TryVectorNullCast(source, result, count, error_message);
251: 	default:
252: 		return VectorStringCastNumericSwitch(source, result, count, strict, error_message);
253: 	}
254: }
255: 
256: static bool DateCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {
257: 	// now switch on the result type
258: 	switch (result.GetType().id()) {
259: 	case LogicalTypeId::VARCHAR:
260: 		// date to varchar
261: 		VectorStringCast<date_t, duckdb::StringCast>(source, result, count);
262: 		break;
263: 	case LogicalTypeId::TIMESTAMP:
264: 		// date to timestamp
265: 		return VectorTryCastLoop<date_t, timestamp_t, duckdb::TryCast>(source, result, count, error_message);
266: 	default:
267: 		VectorNullCast(source, result, count);
268: 		break;
269: 	}
270: 	return true;
271: }
272: 
273: static void TimeCastSwitch(Vector &source, Vector &result, idx_t count) {
274: 	// now switch on the result type
275: 	switch (result.GetType().id()) {
276: 	case LogicalTypeId::VARCHAR:
277: 		// time to varchar
278: 		VectorStringCast<dtime_t, duckdb::StringCast>(source, result, count);
279: 		break;
280: 	default:
281: 		VectorNullCast(source, result, count);
282: 		break;
283: 	}
284: }
285: 
286: static void TimestampCastSwitch(Vector &source, Vector &result, idx_t count) {
287: 	// now switch on the result type
288: 	switch (result.GetType().id()) {
289: 	case LogicalTypeId::VARCHAR:
290: 		// timestamp to varchar
291: 		VectorStringCast<timestamp_t, duckdb::StringCast>(source, result, count);
292: 		break;
293: 	case LogicalTypeId::DATE:
294: 		// timestamp to date
295: 		UnaryExecutor::Execute<timestamp_t, date_t, duckdb::Cast>(source, result, count);
296: 		break;
297: 	case LogicalTypeId::TIME:
298: 		// timestamp to time
299: 		UnaryExecutor::Execute<timestamp_t, dtime_t, duckdb::Cast>(source, result, count);
300: 		break;
301: 	case LogicalTypeId::TIMESTAMP_NS:
302: 		// timestamp (us) to timestamp (ns)
303: 		UnaryExecutor::Execute<timestamp_t, timestamp_t, duckdb::CastTimestampUsToNs>(source, result, count);
304: 		break;
305: 	case LogicalTypeId::TIMESTAMP_MS:
306: 		// timestamp (us) to timestamp (ms)
307: 		UnaryExecutor::Execute<timestamp_t, timestamp_t, duckdb::CastTimestampUsToMs>(source, result, count);
308: 		break;
309: 	case LogicalTypeId::TIMESTAMP_SEC:
310: 		// timestamp (us) to timestamp (s)
311: 		UnaryExecutor::Execute<timestamp_t, timestamp_t, duckdb::CastTimestampUsToSec>(source, result, count);
312: 		break;
313: 	default:
314: 		VectorNullCast(source, result, count);
315: 		break;
316: 	}
317: }
318: 
319: static void TimestampNsCastSwitch(Vector &source, Vector &result, idx_t count) {
320: 	// now switch on the result type
321: 	switch (result.GetType().id()) {
322: 	case LogicalTypeId::VARCHAR:
323: 		// timestamp (ns) to varchar
324: 		VectorStringCast<timestamp_t, duckdb::CastFromTimestampNS>(source, result, count);
325: 		break;
326: 	case LogicalTypeId::TIMESTAMP:
327: 		// timestamp (ns) to timestamp (us)
328: 		UnaryExecutor::Execute<timestamp_t, timestamp_t, duckdb::CastTimestampNsToUs>(source, result, count);
329: 		break;
330: 	default:
331: 		VectorNullCast(source, result, count);
332: 		break;
333: 	}
334: }
335: 
336: static void TimestampMsCastSwitch(Vector &source, Vector &result, idx_t count) {
337: 	// now switch on the result type
338: 	switch (result.GetType().id()) {
339: 	case LogicalTypeId::VARCHAR:
340: 		// timestamp (ms) to varchar
341: 		VectorStringCast<timestamp_t, duckdb::CastFromTimestampMS>(source, result, count);
342: 		break;
343: 	case LogicalTypeId::TIMESTAMP:
344: 		// timestamp (ms) to timestamp (us)
345: 		UnaryExecutor::Execute<timestamp_t, timestamp_t, duckdb::CastTimestampMsToUs>(source, result, count);
346: 		break;
347: 	default:
348: 		VectorNullCast(source, result, count);
349: 		break;
350: 	}
351: }
352: 
353: static void TimestampSecCastSwitch(Vector &source, Vector &result, idx_t count) {
354: 	// now switch on the result type
355: 	switch (result.GetType().id()) {
356: 	case LogicalTypeId::VARCHAR:
357: 		// timestamp (sec) to varchar
358: 		VectorStringCast<timestamp_t, duckdb::CastFromTimestampSec>(source, result, count);
359: 		break;
360: 	case LogicalTypeId::TIMESTAMP:
361: 		// timestamp (s) to timestamp (us)
362: 		UnaryExecutor::Execute<timestamp_t, timestamp_t, duckdb::CastTimestampSecToUs>(source, result, count);
363: 		break;
364: 	default:
365: 		VectorNullCast(source, result, count);
366: 		break;
367: 	}
368: }
369: 
370: static void IntervalCastSwitch(Vector &source, Vector &result, idx_t count) {
371: 	// now switch on the result type
372: 	switch (result.GetType().id()) {
373: 	case LogicalTypeId::VARCHAR:
374: 		// time to varchar
375: 		VectorStringCast<interval_t, duckdb::StringCast>(source, result, count);
376: 		break;
377: 	default:
378: 		VectorNullCast(source, result, count);
379: 		break;
380: 	}
381: }
382: 
383: static void BlobCastSwitch(Vector &source, Vector &result, idx_t count) {
384: 	// now switch on the result type
385: 	switch (result.GetType().id()) {
386: 	case LogicalTypeId::VARCHAR:
387: 		// blob to varchar
388: 		VectorStringCast<string_t, duckdb::CastFromBlob>(source, result, count);
389: 		break;
390: 	default:
391: 		VectorNullCast(source, result, count);
392: 		break;
393: 	}
394: }
395: 
396: static void ValueStringCastSwitch(Vector &source, Vector &result, idx_t count) {
397: 	switch (result.GetType().id()) {
398: 	case LogicalTypeId::VARCHAR:
399: 		if (source.GetVectorType() == VectorType::CONSTANT_VECTOR) {
400: 			result.SetVectorType(source.GetVectorType());
401: 		} else {
402: 			result.SetVectorType(VectorType::FLAT_VECTOR);
403: 		}
404: 		for (idx_t i = 0; i < count; i++) {
405: 			auto src_val = source.GetValue(i);
406: 			auto str_val = src_val.ToString();
407: 			result.SetValue(i, Value(str_val));
408: 		}
409: 		break;
410: 	default:
411: 		VectorNullCast(source, result, count);
412: 		break;
413: 	}
414: }
415: 
416: static void ListCastSwitch(Vector &source, Vector &result, idx_t count) {
417: 	switch (result.GetType().id()) {
418: 	case LogicalTypeId::LIST: {
419: 		// only handle constant and flat vectors here for now
420: 		if (source.GetVectorType() == VectorType::CONSTANT_VECTOR) {
421: 			result.SetVectorType(source.GetVectorType());
422: 			ConstantVector::SetNull(result, ConstantVector::IsNull(source));
423: 
424: 			auto ldata = ConstantVector::GetData<list_entry_t>(source);
425: 			auto tdata = ConstantVector::GetData<list_entry_t>(result);
426: 			*tdata = *ldata;
427: 		} else {
428: 			source.Normalify(count);
429: 			result.SetVectorType(VectorType::FLAT_VECTOR);
430: 			FlatVector::SetValidity(result, FlatVector::Validity(source));
431: 
432: 			auto ldata = FlatVector::GetData<list_entry_t>(source);
433: 			auto tdata = FlatVector::GetData<list_entry_t>(result);
434: 			for (idx_t i = 0; i < count; i++) {
435: 				tdata[i] = ldata[i];
436: 			}
437: 		}
438: 		auto &source_cc = ListVector::GetEntry(source);
439: 		auto source_size = ListVector::GetListSize(source);
440: 
441: 		ListVector::Reserve(result, source_size);
442: 		auto &append_vector = ListVector::GetEntry(result);
443: 
444: 		VectorOperations::Cast(source_cc, append_vector, source_size);
445: 		ListVector::SetListSize(result, source_size);
446: 		D_ASSERT(ListVector::GetListSize(result) == source_size);
447: 		break;
448: 	}
449: 	default:
450: 		ValueStringCastSwitch(source, result, count);
451: 		break;
452: 	}
453: }
454: 
455: static void StructCastSwitch(Vector &source, Vector &result, idx_t count) {
456: 	switch (result.GetType().id()) {
457: 	case LogicalTypeId::STRUCT:
458: 	case LogicalTypeId::MAP: {
459: 		auto &source_child_types = StructType::GetChildTypes(source.GetType());
460: 		auto &result_child_types = StructType::GetChildTypes(result.GetType());
461: 		if (source_child_types.size() != result_child_types.size()) {
462: 			throw TypeMismatchException(source.GetType(), result.GetType(), "Cannot cast STRUCTs of different size");
463: 		}
464: 		auto &source_children = StructVector::GetEntries(source);
465: 		D_ASSERT(source_children.size() == source_child_types.size());
466: 
467: 		auto &result_children = StructVector::GetEntries(result);
468: 		for (idx_t c_idx = 0; c_idx < result_child_types.size(); c_idx++) {
469: 			auto &result_child_vector = result_children[c_idx];
470: 			auto &source_child_vector = *source_children[c_idx];
471: 			if (result_child_vector->GetType() != source_child_vector.GetType()) {
472: 				VectorOperations::Cast(source_child_vector, *result_child_vector, count, false);
473: 			} else {
474: 				result_child_vector->Reference(source_child_vector);
475: 			}
476: 		}
477: 		if (source.GetVectorType() == VectorType::CONSTANT_VECTOR) {
478: 			result.SetVectorType(VectorType::CONSTANT_VECTOR);
479: 			ConstantVector::SetNull(result, ConstantVector::IsNull(source));
480: 		} else {
481: 			source.Normalify(count);
482: 			FlatVector::Validity(result) = FlatVector::Validity(source);
483: 		}
484: 
485: 		break;
486: 	}
487: 	case LogicalTypeId::VARCHAR:
488: 		if (source.GetVectorType() == VectorType::CONSTANT_VECTOR) {
489: 			result.SetVectorType(source.GetVectorType());
490: 		} else {
491: 			result.SetVectorType(VectorType::FLAT_VECTOR);
492: 		}
493: 		for (idx_t i = 0; i < count; i++) {
494: 			auto src_val = source.GetValue(i);
495: 			auto str_val = src_val.ToString();
496: 			result.SetValue(i, Value(str_val));
497: 		}
498: 		break;
499: 
500: 	default:
501: 		VectorNullCast(source, result, count);
502: 		break;
503: 	}
504: }
505: 
506: bool VectorOperations::TryCast(Vector &source, Vector &result, idx_t count, string *error_message, bool strict) {
507: 	D_ASSERT(source.GetType() != result.GetType());
508: 	// first switch on source type
509: 	switch (source.GetType().id()) {
510: 	case LogicalTypeId::BOOLEAN:
511: 		return NumericCastSwitch<bool>(source, result, count, error_message);
512: 	case LogicalTypeId::TINYINT:
513: 		return NumericCastSwitch<int8_t>(source, result, count, error_message);
514: 	case LogicalTypeId::SMALLINT:
515: 		return NumericCastSwitch<int16_t>(source, result, count, error_message);
516: 	case LogicalTypeId::INTEGER:
517: 		return NumericCastSwitch<int32_t>(source, result, count, error_message);
518: 	case LogicalTypeId::BIGINT:
519: 		return NumericCastSwitch<int64_t>(source, result, count, error_message);
520: 	case LogicalTypeId::UTINYINT:
521: 		return NumericCastSwitch<uint8_t>(source, result, count, error_message);
522: 	case LogicalTypeId::USMALLINT:
523: 		return NumericCastSwitch<uint16_t>(source, result, count, error_message);
524: 	case LogicalTypeId::UINTEGER:
525: 		return NumericCastSwitch<uint32_t>(source, result, count, error_message);
526: 	case LogicalTypeId::UBIGINT:
527: 		return NumericCastSwitch<uint64_t>(source, result, count, error_message);
528: 	case LogicalTypeId::HUGEINT:
529: 		return NumericCastSwitch<hugeint_t>(source, result, count, error_message);
530: 	case LogicalTypeId::DECIMAL:
531: 		return DecimalCastSwitch(source, result, count, error_message);
532: 	case LogicalTypeId::FLOAT:
533: 		return NumericCastSwitch<float>(source, result, count, error_message);
534: 	case LogicalTypeId::DOUBLE:
535: 		return NumericCastSwitch<double>(source, result, count, error_message);
536: 	case LogicalTypeId::DATE:
537: 		return DateCastSwitch(source, result, count, error_message);
538: 	case LogicalTypeId::TIME:
539: 		TimeCastSwitch(source, result, count);
540: 		break;
541: 	case LogicalTypeId::TIMESTAMP:
542: 		TimestampCastSwitch(source, result, count);
543: 		break;
544: 	case LogicalTypeId::TIMESTAMP_NS:
545: 		TimestampNsCastSwitch(source, result, count);
546: 		break;
547: 	case LogicalTypeId::TIMESTAMP_MS:
548: 		TimestampMsCastSwitch(source, result, count);
549: 		break;
550: 	case LogicalTypeId::TIMESTAMP_SEC:
551: 		TimestampSecCastSwitch(source, result, count);
552: 		break;
553: 	case LogicalTypeId::INTERVAL:
554: 		IntervalCastSwitch(source, result, count);
555: 		break;
556: 	case LogicalTypeId::VARCHAR:
557: 		return StringCastSwitch(source, result, count, strict, error_message);
558: 	case LogicalTypeId::BLOB:
559: 		BlobCastSwitch(source, result, count);
560: 		break;
561: 	case LogicalTypeId::SQLNULL: {
562: 		// cast a NULL to another type, just copy the properties and change the type
563: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
564: 		ConstantVector::SetNull(result, true);
565: 		return true;
566: 	}
567: 	case LogicalTypeId::MAP:
568: 	case LogicalTypeId::STRUCT:
569: 		StructCastSwitch(source, result, count);
570: 		break;
571: 	case LogicalTypeId::LIST:
572: 		ListCastSwitch(source, result, count);
573: 		break;
574: 	default:
575: 		throw UnimplementedCast(source.GetType(), result.GetType());
576: 	}
577: 	return true;
578: }
579: 
580: void VectorOperations::Cast(Vector &source, Vector &result, idx_t count, bool strict) {
581: 	VectorOperations::TryCast(source, result, count, nullptr, strict);
582: }
583: 
584: } // namespace duckdb
[end of src/common/vector_operations/vector_cast.cpp]
[start of src/include/duckdb/common/vector_operations/decimal_cast.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/vector_operations/decimal_cast.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/vector_operations/general_cast.hpp"
12: #include "duckdb/common/types/decimal.hpp"
13: #include "duckdb/common/operator/decimal_cast_operators.hpp"
14: 
15: namespace duckdb {
16: 
17: struct VectorDecimalCastData {
18: 	VectorDecimalCastData(string *error_message_p, uint8_t width_p, uint8_t scale_p)
19: 	    : error_message(error_message_p), width(width_p), scale(scale_p) {
20: 	}
21: 
22: 	string *error_message;
23: 	uint8_t width;
24: 	uint8_t scale;
25: 	bool all_converted = true;
26: };
27: 
28: template <class OP>
29: struct VectorDecimalCastOperator {
30: 	template <class INPUT_TYPE, class RESULT_TYPE>
31: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
32: 		auto data = (VectorDecimalCastData *)dataptr;
33: 		RESULT_TYPE result_value;
34: 		if (!OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input, result_value, data->error_message, data->width,
35: 		                                                     data->scale)) {
36: 			return HandleVectorCastError::Operation<RESULT_TYPE>("Failed to cast decimal value", mask, idx,
37: 			                                                     data->error_message, data->all_converted);
38: 		}
39: 		return result_value;
40: 	}
41: };
42: 
43: template <class SRC, class T, class OP>
44: bool TemplatedVectorDecimalCast(Vector &source, Vector &result, idx_t count, string *error_message, uint8_t width,
45:                                 uint8_t scale) {
46: 	VectorDecimalCastData input(error_message, width, scale);
47: 	UnaryExecutor::GenericExecute<SRC, T, VectorDecimalCastOperator<OP>>(source, result, count, (void *)&input,
48: 	                                                                     error_message);
49: 	return input.all_converted;
50: }
51: 
52: template <class T>
53: static bool ToDecimalCast(Vector &source, Vector &result, idx_t count, string *error_message) {
54: 	auto &result_type = result.GetType();
55: 	auto width = DecimalType::GetWidth(result_type);
56: 	auto scale = DecimalType::GetScale(result_type);
57: 	switch (result_type.InternalType()) {
58: 	case PhysicalType::INT16:
59: 		return TemplatedVectorDecimalCast<T, int16_t, TryCastToDecimal>(source, result, count, error_message, width,
60: 		                                                                scale);
61: 	case PhysicalType::INT32:
62: 		return TemplatedVectorDecimalCast<T, int32_t, TryCastToDecimal>(source, result, count, error_message, width,
63: 		                                                                scale);
64: 	case PhysicalType::INT64:
65: 		return TemplatedVectorDecimalCast<T, int64_t, TryCastToDecimal>(source, result, count, error_message, width,
66: 		                                                                scale);
67: 	case PhysicalType::INT128:
68: 		return TemplatedVectorDecimalCast<T, hugeint_t, TryCastToDecimal>(source, result, count, error_message, width,
69: 		                                                                  scale);
70: 	default:
71: 		throw InternalException("Unimplemented internal type for decimal");
72: 	}
73: }
74: 
75: template <class T>
76: static bool FromDecimalCast(Vector &source, Vector &result, idx_t count, string *error_message) {
77: 	auto &source_type = source.GetType();
78: 	auto width = DecimalType::GetWidth(source_type);
79: 	auto scale = DecimalType::GetScale(source_type);
80: 	switch (source_type.InternalType()) {
81: 	case PhysicalType::INT16:
82: 		return TemplatedVectorDecimalCast<int16_t, T, TryCastFromDecimal>(source, result, count, error_message, width,
83: 		                                                                  scale);
84: 	case PhysicalType::INT32:
85: 		return TemplatedVectorDecimalCast<int32_t, T, TryCastFromDecimal>(source, result, count, error_message, width,
86: 		                                                                  scale);
87: 	case PhysicalType::INT64:
88: 		return TemplatedVectorDecimalCast<int64_t, T, TryCastFromDecimal>(source, result, count, error_message, width,
89: 		                                                                  scale);
90: 	case PhysicalType::INT128:
91: 		return TemplatedVectorDecimalCast<hugeint_t, T, TryCastFromDecimal>(source, result, count, error_message, width,
92: 		                                                                    scale);
93: 	default:
94: 		throw InternalException("Unimplemented internal type for decimal");
95: 	}
96: }
97: 
98: template <class LIMIT_TYPE, class FACTOR_TYPE = LIMIT_TYPE>
99: struct DecimalScaleInput {
100: 	DecimalScaleInput(Vector &result_p, FACTOR_TYPE factor_p) : result(result_p), factor(factor_p) {
101: 	}
102: 	DecimalScaleInput(Vector &result_p, LIMIT_TYPE limit_p, FACTOR_TYPE factor_p, string *error_message_p,
103: 	                  uint8_t source_scale_p)
104: 	    : result(result_p), limit(limit_p), factor(factor_p), error_message(error_message_p),
105: 	      source_scale(source_scale_p) {
106: 	}
107: 
108: 	Vector &result;
109: 	LIMIT_TYPE limit;
110: 	FACTOR_TYPE factor;
111: 	bool all_converted = true;
112: 	string *error_message;
113: 	uint8_t source_scale;
114: };
115: 
116: struct DecimalScaleUpOperator {
117: 	template <class INPUT_TYPE, class RESULT_TYPE>
118: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
119: 		auto data = (DecimalScaleInput<INPUT_TYPE, RESULT_TYPE> *)dataptr;
120: 		return Cast::Operation<INPUT_TYPE, RESULT_TYPE>(input) * data->factor;
121: 	}
122: };
123: 
124: struct DecimalScaleUpCheckOperator {
125: 	template <class INPUT_TYPE, class RESULT_TYPE>
126: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
127: 		auto data = (DecimalScaleInput<INPUT_TYPE, RESULT_TYPE> *)dataptr;
128: 		if (input >= data->limit || input <= -data->limit) {
129: 			auto error =
130: 			    StringUtil::Format("Casting value \"%s\" to type %s failed: value is out of range!",
131: 			                       Decimal::ToString(input, data->source_scale), data->result.GetType().ToString());
132: 			return HandleVectorCastError::Operation<RESULT_TYPE>(move(error), mask, idx, data->error_message,
133: 			                                                     data->all_converted);
134: 		}
135: 		return Cast::Operation<INPUT_TYPE, RESULT_TYPE>(input) * data->factor;
136: 	}
137: };
138: 
139: template <class SOURCE, class DEST, class POWERS_SOURCE, class POWERS_DEST>
140: bool TemplatedDecimalScaleUp(Vector &source, Vector &result, idx_t count, string *error_message) {
141: 	auto source_scale = DecimalType::GetScale(source.GetType());
142: 	auto source_width = DecimalType::GetWidth(source.GetType());
143: 	auto result_scale = DecimalType::GetScale(result.GetType());
144: 	auto result_width = DecimalType::GetWidth(result.GetType());
145: 	D_ASSERT(result_scale >= source_scale);
146: 	idx_t scale_difference = result_scale - source_scale;
147: 	DEST multiply_factor = POWERS_DEST::POWERS_OF_TEN[scale_difference];
148: 	idx_t target_width = result_width - scale_difference;
149: 	if (source_width < target_width) {
150: 		DecimalScaleInput<SOURCE, DEST> input(result, multiply_factor);
151: 		// type will always fit: no need to check limit
152: 		UnaryExecutor::GenericExecute<SOURCE, DEST, DecimalScaleUpOperator>(source, result, count, &input);
153: 		return true;
154: 	} else {
155: 		// type might not fit: check limit
156: 		auto limit = POWERS_SOURCE::POWERS_OF_TEN[target_width];
157: 		DecimalScaleInput<SOURCE, DEST> input(result, limit, multiply_factor, error_message, source_scale);
158: 		UnaryExecutor::GenericExecute<SOURCE, DEST, DecimalScaleUpCheckOperator>(source, result, count, &input,
159: 		                                                                         error_message);
160: 		return input.all_converted;
161: 	}
162: }
163: 
164: struct DecimalScaleDownOperator {
165: 	template <class INPUT_TYPE, class RESULT_TYPE>
166: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
167: 		auto data = (DecimalScaleInput<INPUT_TYPE> *)dataptr;
168: 		return Cast::Operation<INPUT_TYPE, RESULT_TYPE>(input / data->factor);
169: 	}
170: };
171: 
172: struct DecimalScaleDownCheckOperator {
173: 	template <class INPUT_TYPE, class RESULT_TYPE>
174: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
175: 		auto data = (DecimalScaleInput<INPUT_TYPE> *)dataptr;
176: 		if (input >= data->limit || input <= -data->limit) {
177: 			auto error =
178: 			    StringUtil::Format("Casting value \"%s\" to type %s failed: value is out of range!",
179: 			                       Decimal::ToString(input, data->source_scale), data->result.GetType().ToString());
180: 			return HandleVectorCastError::Operation<RESULT_TYPE>(move(error), mask, idx, data->error_message,
181: 			                                                     data->all_converted);
182: 		}
183: 		return Cast::Operation<INPUT_TYPE, RESULT_TYPE>(input / data->factor);
184: 	}
185: };
186: 
187: template <class SOURCE, class DEST, class POWERS_SOURCE>
188: bool TemplatedDecimalScaleDown(Vector &source, Vector &result, idx_t count, string *error_message) {
189: 	auto source_scale = DecimalType::GetScale(source.GetType());
190: 	auto source_width = DecimalType::GetWidth(source.GetType());
191: 	auto result_scale = DecimalType::GetScale(result.GetType());
192: 	auto result_width = DecimalType::GetWidth(result.GetType());
193: 	D_ASSERT(result_scale < source_scale);
194: 	idx_t scale_difference = source_scale - result_scale;
195: 	idx_t target_width = result_width + scale_difference;
196: 	SOURCE divide_factor = POWERS_SOURCE::POWERS_OF_TEN[scale_difference];
197: 	if (source_width < target_width) {
198: 		DecimalScaleInput<SOURCE> input(result, divide_factor);
199: 		// type will always fit: no need to check limit
200: 		UnaryExecutor::GenericExecute<SOURCE, DEST, DecimalScaleDownOperator>(source, result, count, &input);
201: 		return true;
202: 	} else {
203: 		// type might not fit: check limit
204: 		auto limit = POWERS_SOURCE::POWERS_OF_TEN[target_width];
205: 		DecimalScaleInput<SOURCE> input(result, limit, divide_factor, error_message, source_scale);
206: 		UnaryExecutor::GenericExecute<SOURCE, DEST, DecimalScaleDownCheckOperator>(source, result, count, &input,
207: 		                                                                           error_message);
208: 		return input.all_converted;
209: 	}
210: }
211: 
212: template <class SOURCE, class POWERS_SOURCE>
213: static bool DecimalDecimalCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {
214: 	auto source_scale = DecimalType::GetScale(source.GetType());
215: 	auto result_scale = DecimalType::GetScale(result.GetType());
216: 	source.GetType().Verify();
217: 	result.GetType().Verify();
218: 
219: 	// we need to either multiply or divide by the difference in scales
220: 	if (result_scale >= source_scale) {
221: 		// multiply
222: 		switch (result.GetType().InternalType()) {
223: 		case PhysicalType::INT16:
224: 			return TemplatedDecimalScaleUp<SOURCE, int16_t, POWERS_SOURCE, NumericHelper>(source, result, count,
225: 			                                                                              error_message);
226: 		case PhysicalType::INT32:
227: 			return TemplatedDecimalScaleUp<SOURCE, int32_t, POWERS_SOURCE, NumericHelper>(source, result, count,
228: 			                                                                              error_message);
229: 		case PhysicalType::INT64:
230: 			return TemplatedDecimalScaleUp<SOURCE, int64_t, POWERS_SOURCE, NumericHelper>(source, result, count,
231: 			                                                                              error_message);
232: 		case PhysicalType::INT128:
233: 			return TemplatedDecimalScaleUp<SOURCE, hugeint_t, POWERS_SOURCE, Hugeint>(source, result, count,
234: 			                                                                          error_message);
235: 		default:
236: 			throw NotImplementedException("Unimplemented internal type for decimal");
237: 		}
238: 	} else {
239: 		// divide
240: 		switch (result.GetType().InternalType()) {
241: 		case PhysicalType::INT16:
242: 			return TemplatedDecimalScaleDown<SOURCE, int16_t, POWERS_SOURCE>(source, result, count, error_message);
243: 		case PhysicalType::INT32:
244: 			return TemplatedDecimalScaleDown<SOURCE, int32_t, POWERS_SOURCE>(source, result, count, error_message);
245: 		case PhysicalType::INT64:
246: 			return TemplatedDecimalScaleDown<SOURCE, int64_t, POWERS_SOURCE>(source, result, count, error_message);
247: 		case PhysicalType::INT128:
248: 			return TemplatedDecimalScaleDown<SOURCE, hugeint_t, POWERS_SOURCE>(source, result, count, error_message);
249: 		default:
250: 			throw NotImplementedException("Unimplemented internal type for decimal");
251: 		}
252: 	}
253: }
254: 
255: struct DecimalCastInput {
256: 	DecimalCastInput(Vector &result_p, uint8_t width_p, uint8_t scale_p)
257: 	    : result(result_p), width(width_p), scale(scale_p) {
258: 	}
259: 
260: 	Vector &result;
261: 	uint8_t width;
262: 	uint8_t scale;
263: };
264: 
265: struct StringCastFromDecimalOperator {
266: 	template <class INPUT_TYPE, class RESULT_TYPE>
267: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
268: 		auto data = (DecimalCastInput *)dataptr;
269: 		return StringCastFromDecimal::Operation<INPUT_TYPE>(input, data->width, data->scale, data->result);
270: 	}
271: };
272: 
273: static bool DecimalCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {
274: 	// now switch on the result type
275: 	switch (result.GetType().id()) {
276: 	case LogicalTypeId::BOOLEAN:
277: 		return FromDecimalCast<bool>(source, result, count, error_message);
278: 	case LogicalTypeId::TINYINT:
279: 		return FromDecimalCast<int8_t>(source, result, count, error_message);
280: 	case LogicalTypeId::SMALLINT:
281: 		return FromDecimalCast<int16_t>(source, result, count, error_message);
282: 	case LogicalTypeId::INTEGER:
283: 		return FromDecimalCast<int32_t>(source, result, count, error_message);
284: 	case LogicalTypeId::BIGINT:
285: 		return FromDecimalCast<int64_t>(source, result, count, error_message);
286: 	case LogicalTypeId::UTINYINT:
287: 		return FromDecimalCast<uint8_t>(source, result, count, error_message);
288: 	case LogicalTypeId::USMALLINT:
289: 		return FromDecimalCast<uint16_t>(source, result, count, error_message);
290: 	case LogicalTypeId::UINTEGER:
291: 		return FromDecimalCast<uint32_t>(source, result, count, error_message);
292: 	case LogicalTypeId::UBIGINT:
293: 		return FromDecimalCast<uint64_t>(source, result, count, error_message);
294: 	case LogicalTypeId::HUGEINT:
295: 		return FromDecimalCast<hugeint_t>(source, result, count, error_message);
296: 	case LogicalTypeId::DECIMAL: {
297: 		// decimal to decimal cast
298: 		// first we need to figure out the source and target internal types
299: 		switch (source.GetType().InternalType()) {
300: 		case PhysicalType::INT16:
301: 			return DecimalDecimalCastSwitch<int16_t, NumericHelper>(source, result, count, error_message);
302: 		case PhysicalType::INT32:
303: 			return DecimalDecimalCastSwitch<int32_t, NumericHelper>(source, result, count, error_message);
304: 		case PhysicalType::INT64:
305: 			return DecimalDecimalCastSwitch<int64_t, NumericHelper>(source, result, count, error_message);
306: 		case PhysicalType::INT128:
307: 			return DecimalDecimalCastSwitch<hugeint_t, Hugeint>(source, result, count, error_message);
308: 		default:
309: 			throw NotImplementedException("Unimplemented internal type for decimal in decimal_decimal cast");
310: 		}
311: 		break;
312: 	}
313: 	case LogicalTypeId::FLOAT:
314: 		return FromDecimalCast<float>(source, result, count, error_message);
315: 	case LogicalTypeId::DOUBLE:
316: 		return FromDecimalCast<double>(source, result, count, error_message);
317: 	case LogicalTypeId::VARCHAR: {
318: 		auto &source_type = source.GetType();
319: 		auto width = DecimalType::GetWidth(source_type);
320: 		auto scale = DecimalType::GetScale(source_type);
321: 		DecimalCastInput input(result, width, scale);
322: 		switch (source_type.InternalType()) {
323: 		case PhysicalType::INT16:
324: 			UnaryExecutor::GenericExecute<int16_t, string_t, StringCastFromDecimalOperator>(source, result, count,
325: 			                                                                                (void *)&input);
326: 			break;
327: 		case PhysicalType::INT32:
328: 			UnaryExecutor::GenericExecute<int32_t, string_t, StringCastFromDecimalOperator>(source, result, count,
329: 			                                                                                (void *)&input);
330: 			break;
331: 		case PhysicalType::INT64:
332: 			UnaryExecutor::GenericExecute<int64_t, string_t, StringCastFromDecimalOperator>(source, result, count,
333: 			                                                                                (void *)&input);
334: 			break;
335: 		case PhysicalType::INT128:
336: 			UnaryExecutor::GenericExecute<hugeint_t, string_t, StringCastFromDecimalOperator>(source, result, count,
337: 			                                                                                  (void *)&input);
338: 			break;
339: 		default:
340: 			throw InternalException("Unimplemented internal decimal type");
341: 		}
342: 		return true;
343: 	}
344: 	default:
345: 		VectorNullCast(source, result, count);
346: 		return true;
347: 	}
348: }
349: 
350: } // namespace duckdb
[end of src/include/duckdb/common/vector_operations/decimal_cast.hpp]
[start of src/include/duckdb/common/vector_operations/general_cast.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/vector_operations/general_cast.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/operator/cast_operators.hpp"
12: #include "duckdb/common/string_util.hpp"
13: 
14: namespace duckdb {
15: 
16: struct HandleVectorCastError {
17: 	template <class RESULT_TYPE>
18: 	static RESULT_TYPE Operation(string error_message, ValidityMask &mask, idx_t idx, string *error_message_ptr,
19: 	                             bool &all_converted) {
20: 		HandleCastError::AssignError(error_message, error_message_ptr);
21: 		all_converted = false;
22: 		mask.SetInvalid(idx);
23: 		return NullValue<RESULT_TYPE>();
24: 	}
25: };
26: 
27: static string UnimplementedCastMessage(const LogicalType &source_type, const LogicalType &target_type) {
28: 	return StringUtil::Format("Unimplemented type for cast (%s -> %s)", source_type.ToString(), target_type.ToString());
29: }
30: 
31: static NotImplementedException UnimplementedCast(const LogicalType &source_type, const LogicalType &target_type) {
32: 	return NotImplementedException(UnimplementedCastMessage(source_type, target_type));
33: }
34: 
35: // NULL cast only works if all values in source are NULL, otherwise an unimplemented cast exception is thrown
36: static bool TryVectorNullCast(Vector &source, Vector &result, idx_t count, string *error_message) {
37: 	bool success = true;
38: 	if (VectorOperations::HasNotNull(source, count)) {
39: 		HandleCastError::AssignError(UnimplementedCastMessage(source.GetType(), result.GetType()), error_message);
40: 		success = false;
41: 	}
42: 	result.SetVectorType(VectorType::CONSTANT_VECTOR);
43: 	ConstantVector::SetNull(result, true);
44: 	return success;
45: }
46: 
47: static void VectorNullCast(Vector &source, Vector &result, idx_t count) {
48: 	TryVectorNullCast(source, result, count, nullptr);
49: }
50: 
51: } // namespace duckdb
[end of src/include/duckdb/common/vector_operations/general_cast.hpp]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/parser/column_definition.hpp"
13: #include "duckdb/parser/tokens.hpp"
14: #include "duckdb/planner/bind_context.hpp"
15: #include "duckdb/planner/bound_tokens.hpp"
16: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
17: #include "duckdb/planner/logical_operator.hpp"
18: #include "duckdb/planner/bound_statement.hpp"
19: 
20: namespace duckdb {
21: class BoundResultModifier;
22: class ClientContext;
23: class ExpressionBinder;
24: class LimitModifier;
25: class OrderBinder;
26: class TableCatalogEntry;
27: class ViewCatalogEntry;
28: 
29: struct CreateInfo;
30: struct BoundCreateTableInfo;
31: struct BoundCreateFunctionInfo;
32: struct CommonTableExpressionInfo;
33: 
34: struct CorrelatedColumnInfo {
35: 	ColumnBinding binding;
36: 	LogicalType type;
37: 	string name;
38: 	idx_t depth;
39: 
40: 	explicit CorrelatedColumnInfo(BoundColumnRefExpression &expr)
41: 	    : binding(expr.binding), type(expr.return_type), name(expr.GetName()), depth(expr.depth) {
42: 	}
43: 
44: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
45: 		return binding == rhs.binding;
46: 	}
47: };
48: 
49: //! Bind the parsed query tree to the actual columns present in the catalog.
50: /*!
51:   The binder is responsible for binding tables and columns to actual physical
52:   tables and columns in the catalog. In the process, it also resolves types of
53:   all expressions.
54: */
55: class Binder : public std::enable_shared_from_this<Binder> {
56: 	friend class ExpressionBinder;
57: 	friend class RecursiveSubqueryPlanner;
58: 
59: public:
60: 	static shared_ptr<Binder> CreateBinder(ClientContext &context, Binder *parent = nullptr, bool inherit_ctes = true);
61: 
62: 	//! The client context
63: 	ClientContext &context;
64: 	//! A mapping of names to common table expressions
65: 	unordered_map<string, CommonTableExpressionInfo *> CTE_bindings;
66: 	//! The CTEs that have already been bound
67: 	unordered_set<CommonTableExpressionInfo *> bound_ctes;
68: 	//! The bind context
69: 	BindContext bind_context;
70: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
71: 	//! vector)
72: 	vector<CorrelatedColumnInfo> correlated_columns;
73: 	//! The set of parameter expressions bound by this binder
74: 	vector<BoundParameterExpression *> *parameters;
75: 	//! Whether or not the bound statement is read-only
76: 	bool read_only;
77: 	//! Whether or not the statement requires a valid transaction to run
78: 	bool requires_valid_transaction;
79: 	//! Whether or not the statement can be streamed to the client
80: 	bool allow_stream_result;
81: 	//! The alias for the currently processing subquery, if it exists
82: 	string alias;
83: 	//! Macro parameter bindings (if any)
84: 	MacroBinding *macro_binding = nullptr;
85: 
86: public:
87: 	BoundStatement Bind(SQLStatement &statement);
88: 	BoundStatement Bind(QueryNode &node);
89: 
90: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
91: 	void BindCreateViewInfo(CreateViewInfo &base);
92: 	SchemaCatalogEntry *BindSchema(CreateInfo &info);
93: 	SchemaCatalogEntry *BindCreateFunctionInfo(CreateInfo &info);
94: 
95: 	//! Check usage, and cast named parameters to their types
96: 	static void BindNamedParameters(unordered_map<string, LogicalType> &types, unordered_map<string, Value> &values,
97: 	                                QueryErrorContext &error_context, string &func_name);
98: 
99: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
100: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
101: 
102: 	//! Generates an unused index for a table
103: 	idx_t GenerateTableIndex();
104: 
105: 	//! Add a common table expression to the binder
106: 	void AddCTE(const string &name, CommonTableExpressionInfo *cte);
107: 	//! Find a common table expression by name; returns nullptr if none exists
108: 	CommonTableExpressionInfo *FindCTE(const string &name, bool skip = false);
109: 
110: 	bool CTEIsAlreadyBound(CommonTableExpressionInfo *cte);
111: 
112: 	void PushExpressionBinder(ExpressionBinder *binder);
113: 	void PopExpressionBinder();
114: 	void SetActiveBinder(ExpressionBinder *binder);
115: 	ExpressionBinder *GetActiveBinder();
116: 	bool HasActiveBinder();
117: 
118: 	vector<ExpressionBinder *> &GetActiveBinders();
119: 
120: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
121: 	//! Add a correlated column to this binder (if it does not exist)
122: 	void AddCorrelatedColumn(const CorrelatedColumnInfo &info);
123: 
124: 	string FormatError(ParsedExpression &expr_context, const string &message);
125: 	string FormatError(TableRef &ref_context, const string &message);
126: 
127: 	string FormatErrorRecursive(idx_t query_location, const string &message, vector<ExceptionFormatValue> &values);
128: 	template <class T, typename... Args>
129: 	string FormatErrorRecursive(idx_t query_location, const string &msg, vector<ExceptionFormatValue> &values, T param,
130: 	                            Args... params) {
131: 		values.push_back(ExceptionFormatValue::CreateFormatValue<T>(param));
132: 		return FormatErrorRecursive(query_location, msg, values, params...);
133: 	}
134: 
135: 	template <typename... Args>
136: 	string FormatError(idx_t query_location, const string &msg, Args... params) {
137: 		vector<ExceptionFormatValue> values;
138: 		return FormatErrorRecursive(query_location, msg, values, params...);
139: 	}
140: 
141: private:
142: 	//! The parent binder (if any)
143: 	shared_ptr<Binder> parent;
144: 	//! The vector of active binders
145: 	vector<ExpressionBinder *> active_binders;
146: 	//! The count of bound_tables
147: 	idx_t bound_tables;
148: 	//! Whether or not the binder has any unplanned subqueries that still need to be planned
149: 	bool has_unplanned_subqueries = false;
150: 	//! Whether or not subqueries should be planned already
151: 	bool plan_subquery = true;
152: 	//! Whether CTEs should reference the parent binder (if it exists)
153: 	bool inherit_ctes = true;
154: 	//! The root statement of the query that is currently being parsed
155: 	SQLStatement *root_statement = nullptr;
156: 
157: private:
158: 	//! Bind the default values of the columns of a table
159: 	void BindDefaultValues(vector<ColumnDefinition> &columns, vector<unique_ptr<Expression>> &bound_defaults);
160: 	//! Bind a delimiter value (LIMIT or OFFSET)
161: 	unique_ptr<Expression> BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,
162: 	                                     int64_t &delimiter_value);
163: 
164: 	//! Move correlated expressions from the child binder to this binder
165: 	void MoveCorrelatedExpressions(Binder &other);
166: 
167: 	BoundStatement Bind(SelectStatement &stmt);
168: 	BoundStatement Bind(InsertStatement &stmt);
169: 	BoundStatement Bind(CopyStatement &stmt);
170: 	BoundStatement Bind(DeleteStatement &stmt);
171: 	BoundStatement Bind(UpdateStatement &stmt);
172: 	BoundStatement Bind(CreateStatement &stmt);
173: 	BoundStatement Bind(DropStatement &stmt);
174: 	BoundStatement Bind(AlterStatement &stmt);
175: 	BoundStatement Bind(TransactionStatement &stmt);
176: 	BoundStatement Bind(PragmaStatement &stmt);
177: 	BoundStatement Bind(ExplainStatement &stmt);
178: 	BoundStatement Bind(VacuumStatement &stmt);
179: 	BoundStatement Bind(RelationStatement &stmt);
180: 	BoundStatement Bind(ShowStatement &stmt);
181: 	BoundStatement Bind(CallStatement &stmt);
182: 	BoundStatement Bind(ExportStatement &stmt);
183: 	BoundStatement Bind(SetStatement &stmt);
184: 	BoundStatement Bind(LoadStatement &stmt);
185: 
186: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
187: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
188: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
189: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
190: 
191: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
192: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
193: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
194: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
195: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
196: 
197: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
198: 	unique_ptr<BoundTableRef> Bind(CrossProductRef &ref);
199: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
200: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte = nullptr);
201: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
202: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
203: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
204: 
205: 	bool BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
206: 	                            vector<Value> &parameters, unordered_map<string, Value> &named_parameters,
207: 	                            unique_ptr<BoundSubqueryRef> &subquery, string &error);
208: 
209: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
210: 	unique_ptr<LogicalOperator> CreatePlan(BoundCrossProductRef &ref);
211: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
212: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
213: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
214: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
215: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
216: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
217: 
218: 	unique_ptr<LogicalOperator> BindTable(TableCatalogEntry &table, BaseTableRef &ref);
219: 	unique_ptr<LogicalOperator> BindView(ViewCatalogEntry &view, BaseTableRef &ref);
220: 	unique_ptr<LogicalOperator> BindTableOrView(BaseTableRef &ref);
221: 
222: 	BoundStatement BindCopyTo(CopyStatement &stmt);
223: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
224: 
225: 	void BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
226: 	void BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index);
227: 
228: 	unique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);
229: 	unique_ptr<Expression> BindFilter(unique_ptr<ParsedExpression> condition);
230: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
231: 
232: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
233: 
234: 	void PlanSubqueries(unique_ptr<Expression> *expr, unique_ptr<LogicalOperator> *root);
235: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
236: 
237: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,
238: 	                                                       vector<LogicalType> &target_types,
239: 	                                                       unique_ptr<LogicalOperator> op);
240: 
241: 	string FindBinding(const string &using_column, const string &join_side);
242: 	bool TryFindBinding(const string &using_column, const string &join_side, string &result);
243: 
244: public:
245: 	// This should really be a private constructor, but make_shared does not allow it...
246: 	Binder(bool I_know_what_I_am_doing, ClientContext &context, shared_ptr<Binder> parent, bool inherit_ctes);
247: };
248: 
249: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/include/duckdb/planner/expression_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/exception.hpp"
12: #include "duckdb/parser/expression/bound_expression.hpp"
13: #include "duckdb/parser/parsed_expression.hpp"
14: #include "duckdb/parser/tokens.hpp"
15: #include "duckdb/planner/expression.hpp"
16: #include "duckdb/common/unordered_map.hpp"
17: 
18: namespace duckdb {
19: 
20: class Binder;
21: class ClientContext;
22: class QueryNode;
23: 
24: class ScalarFunctionCatalogEntry;
25: class AggregateFunctionCatalogEntry;
26: class MacroCatalogEntry;
27: class CatalogEntry;
28: class SimpleFunction;
29: 
30: struct MacroBinding;
31: 
32: struct BindResult {
33: 	explicit BindResult(string error) : error(error) {
34: 	}
35: 	explicit BindResult(unique_ptr<Expression> expr) : expression(move(expr)) {
36: 	}
37: 
38: 	bool HasError() {
39: 		return !error.empty();
40: 	}
41: 
42: 	unique_ptr<Expression> expression;
43: 	string error;
44: };
45: 
46: class ExpressionBinder {
47: public:
48: 	ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder = false);
49: 	virtual ~ExpressionBinder();
50: 
51: 	//! The target type that should result from the binder. If the result is not of this type, a cast to this type will
52: 	//! be added. Defaults to INVALID.
53: 	LogicalType target_type;
54: 
55: public:
56: 	unique_ptr<Expression> Bind(unique_ptr<ParsedExpression> &expr, LogicalType *result_type = nullptr,
57: 	                            bool root_expression = true);
58: 
59: 	//! Returns whether or not any columns have been bound by the expression binder
60: 	bool BoundColumns() {
61: 		return bound_columns;
62: 	}
63: 
64: 	string Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression = false);
65: 
66: 	// Bind table names to ColumnRefExpressions
67: 	static void BindTableNames(Binder &binder, ParsedExpression &expr,
68: 	                           unordered_map<string, idx_t> *alias_map = nullptr);
69: 	static unique_ptr<Expression> PushCollation(ClientContext &context, unique_ptr<Expression> source,
70: 	                                            const string &collation, bool equality_only = false);
71: 	static void TestCollation(ClientContext &context, const string &collation);
72: 
73: 	bool BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr);
74: 
75: 	void BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, string &error);
76: 	static void ExtractCorrelatedExpressions(Binder &binder, Expression &expr);
77: 
78: protected:
79: 	virtual BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,
80: 	                                  bool root_expression = false);
81: 
82: 	BindResult BindExpression(BetweenExpression &expr, idx_t depth);
83: 	BindResult BindExpression(CaseExpression &expr, idx_t depth);
84: 	BindResult BindExpression(CollateExpression &expr, idx_t depth);
85: 	BindResult BindExpression(CastExpression &expr, idx_t depth);
86: 	BindResult BindExpression(ColumnRefExpression &expr, idx_t depth);
87: 	BindResult BindExpression(ComparisonExpression &expr, idx_t depth);
88: 	BindResult BindExpression(ConjunctionExpression &expr, idx_t depth);
89: 	BindResult BindExpression(ConstantExpression &expr, idx_t depth);
90: 	BindResult BindExpression(FunctionExpression &expr, idx_t depth, unique_ptr<ParsedExpression> *expr_ptr);
91: 	BindResult BindExpression(LambdaExpression &expr, idx_t depth);
92: 	BindResult BindExpression(OperatorExpression &expr, idx_t depth);
93: 	BindResult BindExpression(ParameterExpression &expr, idx_t depth);
94: 	BindResult BindExpression(PositionalReferenceExpression &ref, idx_t depth);
95: 	BindResult BindExpression(StarExpression &expr, idx_t depth);
96: 	BindResult BindExpression(SubqueryExpression &expr, idx_t depth);
97: 
98: protected:
99: 	virtual BindResult BindFunction(FunctionExpression &expr, ScalarFunctionCatalogEntry *function, idx_t depth);
100: 	virtual BindResult BindAggregate(FunctionExpression &expr, AggregateFunctionCatalogEntry *function, idx_t depth);
101: 	virtual BindResult BindUnnest(FunctionExpression &expr, idx_t depth);
102: 	virtual BindResult BindMacro(FunctionExpression &expr, MacroCatalogEntry *macro, idx_t depth,
103: 	                             unique_ptr<ParsedExpression> *expr_ptr);
104: 
105: 	virtual void ReplaceMacroParametersRecursive(unique_ptr<ParsedExpression> &expr);
106: 	virtual void ReplaceMacroParametersRecursive(ParsedExpression &expr, QueryNode &node);
107: 	virtual void ReplaceMacroParametersRecursive(ParsedExpression &expr, TableRef &ref);
108: 
109: 	virtual string UnsupportedAggregateMessage();
110: 	virtual string UnsupportedUnnestMessage();
111: 
112: 	Binder &binder;
113: 	ClientContext &context;
114: 	ExpressionBinder *stored_binder;
115: 	MacroBinding *macro_binding;
116: 	bool bound_columns = false;
117: };
118: 
119: } // namespace duckdb
[end of src/include/duckdb/planner/expression_binder.hpp]
[start of src/planner/binder/expression/bind_subquery_expression.cpp]
1: #include "duckdb/parser/expression/subquery_expression.hpp"
2: #include "duckdb/planner/binder.hpp"
3: #include "duckdb/planner/expression/bound_cast_expression.hpp"
4: #include "duckdb/planner/expression/bound_subquery_expression.hpp"
5: #include "duckdb/planner/expression_binder.hpp"
6: 
7: namespace duckdb {
8: 
9: class BoundSubqueryNode : public QueryNode {
10: public:
11: 	BoundSubqueryNode(shared_ptr<Binder> subquery_binder, unique_ptr<BoundQueryNode> bound_node,
12: 	                  unique_ptr<SelectStatement> subquery)
13: 	    : QueryNode(QueryNodeType::BOUND_SUBQUERY_NODE), subquery_binder(move(subquery_binder)),
14: 	      bound_node(move(bound_node)), subquery(move(subquery)) {
15: 	}
16: 
17: 	shared_ptr<Binder> subquery_binder;
18: 	unique_ptr<BoundQueryNode> bound_node;
19: 	unique_ptr<SelectStatement> subquery;
20: 
21: 	const vector<unique_ptr<ParsedExpression>> &GetSelectList() const override {
22: 		throw Exception("Cannot get select list of bound subquery node");
23: 	}
24: 
25: 	unique_ptr<QueryNode> Copy() override {
26: 		throw Exception("Cannot copy bound subquery node");
27: 	}
28: };
29: 
30: BindResult ExpressionBinder::BindExpression(SubqueryExpression &expr, idx_t depth) {
31: 	if (expr.subquery->node->type != QueryNodeType::BOUND_SUBQUERY_NODE) {
32: 		D_ASSERT(depth == 0);
33: 		// first bind the actual subquery in a new binder
34: 		auto subquery_binder = Binder::CreateBinder(context, &binder);
35: 		auto bound_node = subquery_binder->BindNode(*expr.subquery->node);
36: 		// check the correlated columns of the subquery for correlated columns with depth > 1
37: 		for (idx_t i = 0; i < subquery_binder->correlated_columns.size(); i++) {
38: 			CorrelatedColumnInfo corr = subquery_binder->correlated_columns[i];
39: 			if (corr.depth > 1) {
40: 				// depth > 1, the column references the query ABOVE the current one
41: 				// add to the set of correlated columns for THIS query
42: 				corr.depth -= 1;
43: 				binder.AddCorrelatedColumn(corr);
44: 			}
45: 		}
46: 		if (expr.subquery_type != SubqueryType::EXISTS && bound_node->types.size() > 1) {
47: 			throw BinderException("Subquery returns %zu columns - expected 1", bound_node->types.size());
48: 		}
49: 		auto prior_subquery = move(expr.subquery);
50: 		expr.subquery = make_unique<SelectStatement>();
51: 		expr.subquery->node =
52: 		    make_unique<BoundSubqueryNode>(move(subquery_binder), move(bound_node), move(prior_subquery));
53: 	}
54: 	// now bind the child node of the subquery
55: 	if (expr.child) {
56: 		// first bind the children of the subquery, if any
57: 		string error = Bind(&expr.child, depth);
58: 		if (!error.empty()) {
59: 			return BindResult(error);
60: 		}
61: 	}
62: 	// both binding the child and binding the subquery was successful
63: 	D_ASSERT(expr.subquery->node->type == QueryNodeType::BOUND_SUBQUERY_NODE);
64: 	auto bound_subquery = (BoundSubqueryNode *)expr.subquery->node.get();
65: 	auto child = (BoundExpression *)expr.child.get();
66: 	auto subquery_binder = move(bound_subquery->subquery_binder);
67: 	auto bound_node = move(bound_subquery->bound_node);
68: 	LogicalType return_type =
69: 	    expr.subquery_type == SubqueryType::SCALAR ? bound_node->types[0] : LogicalType(LogicalTypeId::BOOLEAN);
70: 	if (return_type.id() == LogicalTypeId::UNKNOWN) {
71: 		throw BinderException("Could not determine type of parameters: try adding explicit type casts");
72: 	}
73: 
74: 	auto result = make_unique<BoundSubqueryExpression>(return_type);
75: 	if (expr.subquery_type == SubqueryType::ANY) {
76: 		// ANY comparison
77: 		// cast child and subquery child to equivalent types
78: 		D_ASSERT(bound_node->types.size() == 1);
79: 		auto compare_type = LogicalType::MaxLogicalType(child->expr->return_type, bound_node->types[0]);
80: 		child->expr = BoundCastExpression::AddCastToType(move(child->expr), compare_type);
81: 		result->child_type = bound_node->types[0];
82: 		result->child_target = compare_type;
83: 	}
84: 	result->binder = move(subquery_binder);
85: 	result->subquery = move(bound_node);
86: 	result->subquery_type = expr.subquery_type;
87: 	result->child = child ? move(child->expr) : nullptr;
88: 	result->comparison_type = expr.comparison_type;
89: 
90: 	return BindResult(move(result));
91: }
92: 
93: } // namespace duckdb
[end of src/planner/binder/expression/bind_subquery_expression.cpp]
[start of src/planner/binder/query_node/bind_setop_node.cpp]
1: #include "duckdb/parser/expression/columnref_expression.hpp"
2: #include "duckdb/parser/expression/constant_expression.hpp"
3: #include "duckdb/parser/expression_map.hpp"
4: #include "duckdb/parser/query_node/select_node.hpp"
5: #include "duckdb/parser/query_node/set_operation_node.hpp"
6: #include "duckdb/planner/binder.hpp"
7: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
8: #include "duckdb/planner/query_node/bound_set_operation_node.hpp"
9: #include "duckdb/planner/query_node/bound_select_node.hpp"
10: #include "duckdb/planner/expression_binder/order_binder.hpp"
11: 
12: namespace duckdb {
13: 
14: static void GatherAliases(BoundQueryNode &node, unordered_map<string, idx_t> &aliases,
15:                           expression_map_t<idx_t> &expressions) {
16: 	if (node.type == QueryNodeType::SET_OPERATION_NODE) {
17: 		// setop, recurse
18: 		auto &setop = (BoundSetOperationNode &)node;
19: 		GatherAliases(*setop.left, aliases, expressions);
20: 		GatherAliases(*setop.right, aliases, expressions);
21: 	} else {
22: 		// query node
23: 		D_ASSERT(node.type == QueryNodeType::SELECT_NODE);
24: 		auto &select = (BoundSelectNode &)node;
25: 		// fill the alias lists
26: 		for (idx_t i = 0; i < select.names.size(); i++) {
27: 			auto &name = select.names[i];
28: 			auto &expr = select.original_expressions[i];
29: 			// first check if the alias is already in there
30: 			auto entry = aliases.find(name);
31: 			if (entry != aliases.end()) {
32: 				// the alias already exists
33: 				// check if there is a conflict
34: 				if (entry->second != i) {
35: 					// there is a conflict
36: 					// we place "-1" in the aliases map at this location
37: 					// "-1" signifies that there is an ambiguous reference
38: 					aliases[name] = INVALID_INDEX;
39: 				}
40: 			} else {
41: 				// the alias is not in there yet, just assign it
42: 				aliases[name] = i;
43: 			}
44: 			// now check if the node is already in the set of expressions
45: 			auto expr_entry = expressions.find(expr.get());
46: 			if (expr_entry != expressions.end()) {
47: 				// the node is in there
48: 				// repeat the same as with the alias: if there is an ambiguity we insert "-1"
49: 				if (expr_entry->second != i) {
50: 					expressions[expr.get()] = INVALID_INDEX;
51: 				}
52: 			} else {
53: 				// not in there yet, just place it in there
54: 				expressions[expr.get()] = i;
55: 			}
56: 		}
57: 	}
58: }
59: 
60: unique_ptr<BoundQueryNode> Binder::BindNode(SetOperationNode &statement) {
61: 	auto result = make_unique<BoundSetOperationNode>();
62: 	result->setop_type = statement.setop_type;
63: 
64: 	// first recursively visit the set operations
65: 	// both the left and right sides have an independent BindContext and Binder
66: 	D_ASSERT(statement.left);
67: 	D_ASSERT(statement.right);
68: 
69: 	result->setop_index = GenerateTableIndex();
70: 
71: 	result->left_binder = Binder::CreateBinder(context, this);
72: 	result->left = result->left_binder->BindNode(*statement.left);
73: 
74: 	result->right_binder = Binder::CreateBinder(context, this);
75: 	result->right = result->right_binder->BindNode(*statement.right);
76: 
77: 	if (!statement.modifiers.empty()) {
78: 		// handle the ORDER BY/DISTINCT clauses
79: 
80: 		// we recursively visit the children of this node to extract aliases and expressions that can be referenced in
81: 		// the ORDER BY
82: 		unordered_map<string, idx_t> alias_map;
83: 		expression_map_t<idx_t> expression_map;
84: 		GatherAliases(*result, alias_map, expression_map);
85: 
86: 		// now we perform the actual resolution of the ORDER BY/DISTINCT expressions
87: 		OrderBinder order_binder({result->left_binder.get(), result->right_binder.get()}, result->setop_index,
88: 		                         alias_map, expression_map, statement.left->GetSelectList().size());
89: 		BindModifiers(order_binder, statement, *result);
90: 	}
91: 
92: 	result->names = result->left->names;
93: 
94: 	// move the correlated expressions from the child binders to this binder
95: 	MoveCorrelatedExpressions(*result->left_binder);
96: 	MoveCorrelatedExpressions(*result->right_binder);
97: 
98: 	// now both sides have been bound we can resolve types
99: 	if (result->left->types.size() != result->right->types.size()) {
100: 		throw BinderException("Set operations can only apply to expressions with the "
101: 		                      "same number of result columns");
102: 	}
103: 
104: 	// figure out the types of the setop result by picking the max of both
105: 	for (idx_t i = 0; i < result->left->types.size(); i++) {
106: 		auto result_type = LogicalType::MaxLogicalType(result->left->types[i], result->right->types[i]);
107: 		result->types.push_back(result_type);
108: 	}
109: 
110: 	// finally bind the types of the ORDER/DISTINCT clause expressions
111: 	BindModifierTypes(*result, result->types, result->setop_index);
112: 	return move(result);
113: }
114: 
115: } // namespace duckdb
[end of src/planner/binder/query_node/bind_setop_node.cpp]
[start of src/planner/binder/statement/bind_create.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
3: #include "duckdb/main/client_context.hpp"
4: #include "duckdb/parser/expression/subquery_expression.hpp"
5: #include "duckdb/parser/expression/constant_expression.hpp"
6: #include "duckdb/parser/parsed_data/create_index_info.hpp"
7: #include "duckdb/parser/parsed_data/create_macro_info.hpp"
8: #include "duckdb/parser/parsed_data/create_view_info.hpp"
9: #include "duckdb/parser/parsed_expression_iterator.hpp"
10: #include "duckdb/parser/statement/create_statement.hpp"
11: #include "duckdb/planner/binder.hpp"
12: #include "duckdb/planner/bound_query_node.hpp"
13: #include "duckdb/planner/query_node/bound_select_node.hpp"
14: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
15: #include "duckdb/planner/expression_binder/index_binder.hpp"
16: #include "duckdb/planner/expression_binder/select_binder.hpp"
17: #include "duckdb/planner/operator/logical_create.hpp"
18: #include "duckdb/planner/operator/logical_create_index.hpp"
19: #include "duckdb/planner/operator/logical_create_table.hpp"
20: #include "duckdb/planner/operator/logical_get.hpp"
21: #include "duckdb/planner/parsed_data/bound_create_function_info.hpp"
22: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
23: #include "duckdb/planner/tableref/bound_basetableref.hpp"
24: 
25: namespace duckdb {
26: 
27: SchemaCatalogEntry *Binder::BindSchema(CreateInfo &info) {
28: 	if (info.schema.empty()) {
29: 		info.schema = info.temporary ? TEMP_SCHEMA : DEFAULT_SCHEMA;
30: 	}
31: 
32: 	if (!info.temporary) {
33: 		// non-temporary create: not read only
34: 		if (info.schema == TEMP_SCHEMA) {
35: 			throw ParserException("Only TEMPORARY table names can use the \"temp\" schema");
36: 		}
37: 		this->read_only = false;
38: 	} else {
39: 		if (info.schema != TEMP_SCHEMA) {
40: 			throw ParserException("TEMPORARY table names can *only* use the \"%s\" schema", TEMP_SCHEMA);
41: 		}
42: 	}
43: 	// fetch the schema in which we want to create the object
44: 	auto schema_obj = Catalog::GetCatalog(context).GetSchema(context, info.schema);
45: 	D_ASSERT(schema_obj->type == CatalogType::SCHEMA_ENTRY);
46: 	info.schema = schema_obj->name;
47: 	return schema_obj;
48: }
49: 
50: void Binder::BindCreateViewInfo(CreateViewInfo &base) {
51: 	// bind the view as if it were a query so we can catch errors
52: 	// note that we bind the original, and replace the original with a copy
53: 	// this is because the original has
54: 	auto copy = base.query->Copy();
55: 	auto query_node = Bind(*base.query);
56: 	base.query = unique_ptr_cast<SQLStatement, SelectStatement>(move(copy));
57: 	if (base.aliases.size() > query_node.names.size()) {
58: 		throw BinderException("More VIEW aliases than columns in query result");
59: 	}
60: 	// fill up the aliases with the remaining names of the bound query
61: 	for (idx_t i = base.aliases.size(); i < query_node.names.size(); i++) {
62: 		base.aliases.push_back(query_node.names[i]);
63: 	}
64: 	base.types = query_node.types;
65: }
66: 
67: SchemaCatalogEntry *Binder::BindCreateFunctionInfo(CreateInfo &info) {
68: 	auto &base = (CreateMacroInfo &)info;
69: 
70: 	if (base.function->expression->HasParameter()) {
71: 		throw BinderException("Parameter expressions within macro's are not supported!");
72: 	}
73: 
74: 	// create macro binding in order to bind the function
75: 	vector<LogicalType> dummy_types;
76: 	vector<string> dummy_names;
77: 	// positional parameters
78: 	for (idx_t i = 0; i < base.function->parameters.size(); i++) {
79: 		auto param = (ColumnRefExpression &)*base.function->parameters[i];
80: 		if (!param.table_name.empty()) {
81: 			throw BinderException("Invalid parameter name '%s'", param.ToString());
82: 		}
83: 		dummy_types.push_back(LogicalType::SQLNULL);
84: 		dummy_names.push_back(param.column_name);
85: 	}
86: 	// default parameters
87: 	for (auto it = base.function->default_parameters.begin(); it != base.function->default_parameters.end(); it++) {
88: 		auto &val = (ConstantExpression &)*it->second;
89: 		dummy_types.push_back(val.value.type());
90: 		dummy_names.push_back(it->first);
91: 	}
92: 	auto this_macro_binding = make_unique<MacroBinding>(dummy_types, dummy_names, base.name);
93: 	macro_binding = this_macro_binding.get();
94: 
95: 	// create a copy of the expression because we do not want to alter the original
96: 	auto expression = base.function->expression->Copy();
97: 
98: 	// bind it to verify the function was defined correctly
99: 	string error;
100: 	auto sel_node = make_unique<BoundSelectNode>();
101: 	auto group_info = make_unique<BoundGroupInformation>();
102: 	SelectBinder binder(*this, context, *sel_node, *group_info);
103: 	error = binder.Bind(&expression, 0, false);
104: 
105: 	if (!error.empty()) {
106: 		throw BinderException(error);
107: 	}
108: 
109: 	return BindSchema(info);
110: }
111: 
112: BoundStatement Binder::Bind(CreateStatement &stmt) {
113: 	BoundStatement result;
114: 	result.names = {"Count"};
115: 	result.types = {LogicalType::BIGINT};
116: 
117: 	auto catalog_type = stmt.info->type;
118: 	switch (catalog_type) {
119: 	case CatalogType::SCHEMA_ENTRY:
120: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_SCHEMA, move(stmt.info));
121: 		break;
122: 	case CatalogType::VIEW_ENTRY: {
123: 		auto &base = (CreateViewInfo &)*stmt.info;
124: 		// bind the schema
125: 		auto schema = BindSchema(*stmt.info);
126: 
127: 		BindCreateViewInfo(base);
128: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_VIEW, move(stmt.info), schema);
129: 		break;
130: 	}
131: 	case CatalogType::SEQUENCE_ENTRY: {
132: 		auto schema = BindSchema(*stmt.info);
133: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_SEQUENCE, move(stmt.info), schema);
134: 		break;
135: 	}
136: 	case CatalogType::MACRO_ENTRY: {
137: 		auto schema = BindCreateFunctionInfo(*stmt.info);
138: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_MACRO, move(stmt.info), schema);
139: 		break;
140: 	}
141: 	case CatalogType::INDEX_ENTRY: {
142: 		auto &base = (CreateIndexInfo &)*stmt.info;
143: 
144: 		// visit the table reference
145: 		auto bound_table = Bind(*base.table);
146: 		if (bound_table->type != TableReferenceType::BASE_TABLE) {
147: 			throw BinderException("Can only delete from base table!");
148: 		}
149: 		auto &table_binding = (BoundBaseTableRef &)*bound_table;
150: 		auto table = table_binding.table;
151: 		// bind the index expressions
152: 		vector<unique_ptr<Expression>> expressions;
153: 		IndexBinder binder(*this, context);
154: 		for (auto &expr : base.expressions) {
155: 			expressions.push_back(binder.Bind(expr));
156: 		}
157: 
158: 		auto plan = CreatePlan(*bound_table);
159: 		if (plan->type != LogicalOperatorType::LOGICAL_GET) {
160: 			throw BinderException("Cannot create index on a view!");
161: 		}
162: 		auto &get = (LogicalGet &)*plan;
163: 		for (auto &column_id : get.column_ids) {
164: 			if (column_id == COLUMN_IDENTIFIER_ROW_ID) {
165: 				throw BinderException("Cannot create an index on the rowid!");
166: 			}
167: 		}
168: 		// this gives us a logical table scan
169: 		// we take the required columns from here
170: 		// create the logical operator
171: 		result.plan = make_unique<LogicalCreateIndex>(*table, get.column_ids, move(expressions),
172: 		                                              unique_ptr_cast<CreateInfo, CreateIndexInfo>(move(stmt.info)));
173: 		break;
174: 	}
175: 	case CatalogType::TABLE_ENTRY: {
176: 		auto bound_info = BindCreateTableInfo(move(stmt.info));
177: 		auto root = move(bound_info->query);
178: 
179: 		// create the logical operator
180: 		auto &schema = bound_info->schema;
181: 		auto create_table = make_unique<LogicalCreateTable>(schema, move(bound_info));
182: 		if (root) {
183: 			create_table->children.push_back(move(root));
184: 		}
185: 		result.plan = move(create_table);
186: 		break;
187: 	}
188: 	default:
189: 		throw Exception("Unrecognized type!");
190: 	}
191: 	this->allow_stream_result = false;
192: 	return result;
193: }
194: 
195: } // namespace duckdb
[end of src/planner/binder/statement/bind_create.cpp]
[start of src/planner/binder/tableref/bind_basetableref.cpp]
1: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
2: #include "duckdb/parser/tableref/basetableref.hpp"
3: #include "duckdb/parser/tableref/subqueryref.hpp"
4: #include "duckdb/parser/query_node/select_node.hpp"
5: #include "duckdb/planner/binder.hpp"
6: #include "duckdb/planner/tableref/bound_basetableref.hpp"
7: #include "duckdb/planner/tableref/bound_subqueryref.hpp"
8: #include "duckdb/planner/tableref/bound_cteref.hpp"
9: #include "duckdb/planner/operator/logical_get.hpp"
10: #include "duckdb/parser/statement/select_statement.hpp"
11: #include "duckdb/function/table/table_scan.hpp"
12: #include "duckdb/common/string_util.hpp"
13: #include "duckdb/parser/tableref/table_function_ref.hpp"
14: #include "duckdb/main/config.hpp"
15: 
16: namespace duckdb {
17: 
18: unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {
19: 	QueryErrorContext error_context(root_statement, ref.query_location);
20: 	// CTEs and views are also referred to using BaseTableRefs, hence need to distinguish here
21: 	// check if the table name refers to a CTE
22: 	auto cte = FindCTE(ref.table_name, ref.table_name == alias);
23: 	if (cte) {
24: 		// Check if there is a CTE binding in the BindContext
25: 		auto ctebinding = bind_context.GetCTEBinding(ref.table_name);
26: 		if (!ctebinding) {
27: 			if (CTEIsAlreadyBound(cte)) {
28: 				throw BinderException("Circular reference to CTE \"%s\", use WITH RECURSIVE to use recursive CTEs",
29: 				                      ref.table_name);
30: 			}
31: 			// Move CTE to subquery and bind recursively
32: 			SubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(cte->query->Copy()));
33: 			subquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;
34: 			subquery.column_name_alias = cte->aliases;
35: 			for (idx_t i = 0; i < ref.column_name_alias.size(); i++) {
36: 				if (i < subquery.column_name_alias.size()) {
37: 					subquery.column_name_alias[i] = ref.column_name_alias[i];
38: 				} else {
39: 					subquery.column_name_alias.push_back(ref.column_name_alias[i]);
40: 				}
41: 			}
42: 			return Bind(subquery, cte);
43: 		} else {
44: 			// There is a CTE binding in the BindContext.
45: 			// This can only be the case if there is a recursive CTE present.
46: 			auto index = GenerateTableIndex();
47: 			auto result = make_unique<BoundCTERef>(index, ctebinding->index);
48: 			auto b = ctebinding;
49: 			auto alias = ref.alias.empty() ? ref.table_name : ref.alias;
50: 			auto names = BindContext::AliasColumnNames(alias, b->names, ref.column_name_alias);
51: 
52: 			bind_context.AddGenericBinding(index, alias, names, b->types);
53: 			// Update references to CTE
54: 			auto cteref = bind_context.cte_references[ref.table_name];
55: 			(*cteref)++;
56: 
57: 			result->types = b->types;
58: 			result->bound_columns = move(names);
59: 			return move(result);
60: 		}
61: 	}
62: 	// not a CTE
63: 	// extract a table or view from the catalog
64: 	auto table_or_view =
65: 	    Catalog::GetCatalog(context).GetEntry(context, CatalogType::TABLE_ENTRY, ref.schema_name, ref.table_name,
66: 	                                          ref.schema_name.empty() ? true : false, error_context);
67: 	if (!table_or_view) {
68: 		// table could not be found: try to bind a replacement scan
69: 		auto &config = DBConfig::GetConfig(context);
70: 		for (auto &scan : config.replacement_scans) {
71: 			auto replacement_function = scan.function(ref.table_name, scan.data);
72: 			if (replacement_function) {
73: 				replacement_function->alias = ref.alias.empty() ? ref.table_name : ref.alias;
74: 				replacement_function->column_name_alias = ref.column_name_alias;
75: 				return Bind(*replacement_function);
76: 			}
77: 		}
78: 		// could not find an alternative: bind again to get the error
79: 		table_or_view = Catalog::GetCatalog(context).GetEntry(context, CatalogType::TABLE_ENTRY, ref.schema_name,
80: 		                                                      ref.table_name, false, error_context);
81: 	}
82: 	switch (table_or_view->type) {
83: 	case CatalogType::TABLE_ENTRY: {
84: 		// base table: create the BoundBaseTableRef node
85: 		auto table_index = GenerateTableIndex();
86: 		auto table = (TableCatalogEntry *)table_or_view;
87: 
88: 		auto scan_function = TableScanFunction::GetFunction();
89: 		auto bind_data = make_unique<TableScanBindData>(table);
90: 		auto alias = ref.alias.empty() ? ref.table_name : ref.alias;
91: 		vector<LogicalType> table_types;
92: 		vector<string> table_names;
93: 		for (auto &col : table->columns) {
94: 			table_types.push_back(col.type);
95: 			table_names.push_back(col.name);
96: 		}
97: 		table_names = BindContext::AliasColumnNames(alias, table_names, ref.column_name_alias);
98: 
99: 		auto logical_get =
100: 		    make_unique<LogicalGet>(table_index, scan_function, move(bind_data), table_types, table_names);
101: 		bind_context.AddBaseTable(table_index, alias, table_names, table_types, *logical_get);
102: 		return make_unique_base<BoundTableRef, BoundBaseTableRef>(table, move(logical_get));
103: 	}
104: 	case CatalogType::VIEW_ENTRY: {
105: 		// the node is a view: get the query that the view represents
106: 		auto view_catalog_entry = (ViewCatalogEntry *)table_or_view;
107: 		// We need to use a new binder for the view that doesn't reference any CTEs
108: 		// defined for this binder so there are no collisions between the CTEs defined
109: 		// for the view and for the current query
110: 		bool inherit_ctes = false;
111: 		auto view_binder = Binder::CreateBinder(context, this, inherit_ctes);
112: 		SubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(view_catalog_entry->query->Copy()));
113: 		subquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;
114: 		subquery.column_name_alias =
115: 		    BindContext::AliasColumnNames(subquery.alias, view_catalog_entry->aliases, ref.column_name_alias);
116: 		// bind the child subquery
117: 		auto bound_child = view_binder->Bind(subquery);
118: 		D_ASSERT(bound_child->type == TableReferenceType::SUBQUERY);
119: 		// verify that the types and names match up with the expected types and names
120: 		auto &bound_subquery = (BoundSubqueryRef &)*bound_child;
121: 		if (bound_subquery.subquery->types != view_catalog_entry->types) {
122: 			throw BinderException("Contents of view were altered: types don't match!");
123: 		}
124: 		bind_context.AddSubquery(bound_subquery.subquery->GetRootIndex(), subquery.alias, subquery,
125: 		                         *bound_subquery.subquery);
126: 		return bound_child;
127: 	}
128: 	default:
129: 		throw InternalException("Catalog entry type");
130: 	}
131: }
132: } // namespace duckdb
[end of src/planner/binder/tableref/bind_basetableref.cpp]
[start of src/planner/binder/tableref/bind_subqueryref.cpp]
1: #include "duckdb/parser/tableref/subqueryref.hpp"
2: #include "duckdb/planner/binder.hpp"
3: #include "duckdb/planner/tableref/bound_subqueryref.hpp"
4: 
5: namespace duckdb {
6: 
7: unique_ptr<BoundTableRef> Binder::Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte) {
8: 	auto binder = Binder::CreateBinder(context, this);
9: 	if (cte) {
10: 		binder->bound_ctes.insert(cte);
11: 	}
12: 	binder->alias = ref.alias;
13: 	auto subquery = binder->BindNode(*ref.subquery->node);
14: 	idx_t bind_index = subquery->GetRootIndex();
15: 	auto result = make_unique<BoundSubqueryRef>(move(binder), move(subquery));
16: 
17: 	bind_context.AddSubquery(bind_index, ref.alias, ref, *result->subquery);
18: 	MoveCorrelatedExpressions(*result->binder);
19: 	return move(result);
20: }
21: 
22: } // namespace duckdb
[end of src/planner/binder/tableref/bind_subqueryref.cpp]
[start of src/planner/expression_binder.cpp]
1: #include "duckdb/planner/expression_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/expression/positional_reference_expression.hpp"
5: #include "duckdb/parser/expression/subquery_expression.hpp"
6: #include "duckdb/parser/parsed_expression_iterator.hpp"
7: #include "duckdb/planner/binder.hpp"
8: #include "duckdb/planner/expression/bound_cast_expression.hpp"
9: #include "duckdb/planner/expression/bound_default_expression.hpp"
10: #include "duckdb/planner/expression/bound_parameter_expression.hpp"
11: #include "duckdb/planner/expression/bound_subquery_expression.hpp"
12: #include "duckdb/planner/expression_iterator.hpp"
13: 
14: namespace duckdb {
15: 
16: ExpressionBinder::ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder)
17:     : binder(binder), context(context), stored_binder(nullptr) {
18: 	if (replace_binder) {
19: 		stored_binder = binder.GetActiveBinder();
20: 		binder.SetActiveBinder(this);
21: 	} else {
22: 		binder.PushExpressionBinder(this);
23: 	}
24: }
25: 
26: ExpressionBinder::~ExpressionBinder() {
27: 	if (binder.HasActiveBinder()) {
28: 		if (stored_binder) {
29: 			binder.SetActiveBinder(stored_binder);
30: 		} else {
31: 			binder.PopExpressionBinder();
32: 		}
33: 	}
34: }
35: 
36: BindResult ExpressionBinder::BindExpression(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression) {
37: 	auto &expr_ref = **expr;
38: 	switch (expr_ref.expression_class) {
39: 	case ExpressionClass::BETWEEN:
40: 		return BindExpression((BetweenExpression &)expr_ref, depth);
41: 	case ExpressionClass::CASE:
42: 		return BindExpression((CaseExpression &)expr_ref, depth);
43: 	case ExpressionClass::CAST:
44: 		return BindExpression((CastExpression &)expr_ref, depth);
45: 	case ExpressionClass::COLLATE:
46: 		return BindExpression((CollateExpression &)expr_ref, depth);
47: 	case ExpressionClass::COLUMN_REF:
48: 		return BindExpression((ColumnRefExpression &)expr_ref, depth);
49: 	case ExpressionClass::COMPARISON:
50: 		return BindExpression((ComparisonExpression &)expr_ref, depth);
51: 	case ExpressionClass::CONJUNCTION:
52: 		return BindExpression((ConjunctionExpression &)expr_ref, depth);
53: 	case ExpressionClass::CONSTANT:
54: 		return BindExpression((ConstantExpression &)expr_ref, depth);
55: 	case ExpressionClass::FUNCTION:
56: 		// binding function expression has extra parameter needed for macro's
57: 		return BindExpression((FunctionExpression &)expr_ref, depth, expr);
58: 	case ExpressionClass::LAMBDA:
59: 		return BindExpression((LambdaExpression &)expr_ref, depth);
60: 	case ExpressionClass::OPERATOR:
61: 		return BindExpression((OperatorExpression &)expr_ref, depth);
62: 	case ExpressionClass::SUBQUERY:
63: 		return BindExpression((SubqueryExpression &)expr_ref, depth);
64: 	case ExpressionClass::PARAMETER:
65: 		return BindExpression((ParameterExpression &)expr_ref, depth);
66: 	case ExpressionClass::POSITIONAL_REFERENCE:
67: 		return BindExpression((PositionalReferenceExpression &)expr_ref, depth);
68: 	default:
69: 		throw NotImplementedException("Unimplemented expression class");
70: 	}
71: }
72: 
73: bool ExpressionBinder::BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr) {
74: 	// try to bind in one of the outer queries, if the binding error occurred in a subquery
75: 	auto &active_binders = binder.GetActiveBinders();
76: 	// make a copy of the set of binders, so we can restore it later
77: 	auto binders = active_binders;
78: 	active_binders.pop_back();
79: 	idx_t depth = 1;
80: 	bool success = false;
81: 	while (!active_binders.empty()) {
82: 		auto &next_binder = active_binders.back();
83: 		ExpressionBinder::BindTableNames(next_binder->binder, *expr);
84: 		auto bind_result = next_binder->Bind(&expr, depth);
85: 		if (bind_result.empty()) {
86: 			success = true;
87: 			break;
88: 		}
89: 		depth++;
90: 		active_binders.pop_back();
91: 	}
92: 	active_binders = binders;
93: 	return success;
94: }
95: 
96: void ExpressionBinder::BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, string &error) {
97: 	if (expr) {
98: 		string bind_error = Bind(&expr, depth);
99: 		if (error.empty()) {
100: 			error = bind_error;
101: 		}
102: 	}
103: }
104: 
105: void ExpressionBinder::ExtractCorrelatedExpressions(Binder &binder, Expression &expr) {
106: 	if (expr.type == ExpressionType::BOUND_COLUMN_REF) {
107: 		auto &bound_colref = (BoundColumnRefExpression &)expr;
108: 		if (bound_colref.depth > 0) {
109: 			binder.AddCorrelatedColumn(CorrelatedColumnInfo(bound_colref));
110: 		}
111: 	}
112: 	ExpressionIterator::EnumerateChildren(expr,
113: 	                                      [&](Expression &child) { ExtractCorrelatedExpressions(binder, child); });
114: }
115: 
116: static bool ContainsNullType(const LogicalType &type) {
117: 	switch (type.id()) {
118: 	case LogicalTypeId::STRUCT:
119: 	case LogicalTypeId::MAP: {
120: 		auto child_count = StructType::GetChildCount(type);
121: 		for (idx_t i = 0; i < child_count; i++) {
122: 			if (ContainsNullType(StructType::GetChildType(type, i))) {
123: 				return true;
124: 			}
125: 		}
126: 		return false;
127: 	}
128: 	case LogicalTypeId::LIST:
129: 		return ContainsNullType(ListType::GetChildType(type));
130: 	case LogicalTypeId::SQLNULL:
131: 		return true;
132: 	default:
133: 		return false;
134: 	}
135: }
136: 
137: static LogicalType ExchangeNullType(const LogicalType &type) {
138: 	switch (type.id()) {
139: 	case LogicalTypeId::STRUCT:
140: 	case LogicalTypeId::MAP: {
141: 		// we make a copy of the child types of the struct here
142: 		auto child_types = StructType::GetChildTypes(type);
143: 		for (auto &child_type : child_types) {
144: 			child_type.second = ExchangeNullType(child_type.second);
145: 		}
146: 		return type.id() == LogicalTypeId::MAP ? LogicalType::MAP(move(child_types))
147: 		                                       : LogicalType::STRUCT(move(child_types));
148: 	}
149: 	case LogicalTypeId::LIST:
150: 		return LogicalType::LIST(ExchangeNullType(ListType::GetChildType(type)));
151: 	case LogicalTypeId::SQLNULL:
152: 		return LogicalType::INTEGER;
153: 	default:
154: 		return type;
155: 	}
156: }
157: 
158: unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr, LogicalType *result_type,
159:                                               bool root_expression) {
160: 	// bind the main expression
161: 	auto error_msg = Bind(&expr, 0, root_expression);
162: 	if (!error_msg.empty()) {
163: 		// failed to bind: try to bind correlated columns in the expression (if any)
164: 		bool success = BindCorrelatedColumns(expr);
165: 		if (!success) {
166: 			throw BinderException(error_msg);
167: 		}
168: 		auto bound_expr = (BoundExpression *)expr.get();
169: 		ExtractCorrelatedExpressions(binder, *bound_expr->expr);
170: 	}
171: 	D_ASSERT(expr->expression_class == ExpressionClass::BOUND_EXPRESSION);
172: 	auto bound_expr = (BoundExpression *)expr.get();
173: 	unique_ptr<Expression> result = move(bound_expr->expr);
174: 	if (target_type.id() != LogicalTypeId::INVALID) {
175: 		// the binder has a specific target type: add a cast to that type
176: 		result = BoundCastExpression::AddCastToType(move(result), target_type);
177: 	} else {
178: 		// SQL NULL type is only used internally in the binder
179: 		// cast to INTEGER if we encounter it outside of the binder
180: 		if (ContainsNullType(result->return_type)) {
181: 			auto result_type = ExchangeNullType(result->return_type);
182: 			result = BoundCastExpression::AddCastToType(move(result), result_type);
183: 		}
184: 	}
185: 	if (result_type) {
186: 		*result_type = result->return_type;
187: 	}
188: 	return result;
189: }
190: 
191: string ExpressionBinder::Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression) {
192: 	// bind the node, but only if it has not been bound yet
193: 	auto &expression = **expr;
194: 	auto alias = expression.alias;
195: 	if (expression.GetExpressionClass() == ExpressionClass::BOUND_EXPRESSION) {
196: 		// already bound, don't bind it again
197: 		return string();
198: 	}
199: 	// bind the expression
200: 	BindResult result = BindExpression(expr, depth, root_expression);
201: 	if (result.HasError()) {
202: 		return result.error;
203: 	} else {
204: 		// successfully bound: replace the node with a BoundExpression
205: 		*expr = make_unique<BoundExpression>(move(result.expression));
206: 		auto be = (BoundExpression *)expr->get();
207: 		D_ASSERT(be);
208: 		be->alias = alias;
209: 		if (!alias.empty()) {
210: 			be->expr->alias = alias;
211: 		}
212: 		return string();
213: 	}
214: }
215: 
216: void ExpressionBinder::BindTableNames(Binder &binder, ParsedExpression &expr, unordered_map<string, idx_t> *alias_map) {
217: 	if (expr.type == ExpressionType::COLUMN_REF) {
218: 		auto &colref = (ColumnRefExpression &)expr;
219: 		if (colref.table_name.empty()) {
220: 			// no table name: find a binding that contains this
221: 			if (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {
222: 				// macro parameters get priority
223: 				colref.table_name = binder.macro_binding->alias;
224: 			} else if (alias_map && alias_map->find(colref.column_name) != alias_map->end()) {
225: 				// alias: leave unqualified
226: 			} else {
227: 				colref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);
228: 			}
229: 		}
230: 		binder.bind_context.BindColumn(colref, 0);
231: 	} else if (expr.type == ExpressionType::POSITIONAL_REFERENCE) {
232: 		auto &ref = (PositionalReferenceExpression &)expr;
233: 		if (ref.alias.empty()) {
234: 			string table_name, column_name;
235: 			auto error = binder.bind_context.BindColumn(ref, table_name, column_name);
236: 			if (error.empty()) {
237: 				ref.alias = column_name;
238: 			}
239: 		}
240: 	}
241: 	ParsedExpressionIterator::EnumerateChildren(
242: 	    expr, [&](const ParsedExpression &child) { BindTableNames(binder, (ParsedExpression &)child, alias_map); });
243: }
244: 
245: } // namespace duckdb
[end of src/planner/expression_binder.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: