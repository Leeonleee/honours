{
  "repo": "duckdb/duckdb",
  "pull_number": 2120,
  "instance_id": "duckdb__duckdb-2120",
  "issue_numbers": [
    "1049"
  ],
  "base_commit": "13dcd6e8112eae62ad24de0aa17a805104b67d5e",
  "patch": "diff --git a/src/common/vector_operations/vector_cast.cpp b/src/common/vector_operations/vector_cast.cpp\nindex fdb53d0c6af5..8d3197167cbf 100644\n--- a/src/common/vector_operations/vector_cast.cpp\n+++ b/src/common/vector_operations/vector_cast.cpp\n@@ -161,17 +161,11 @@ static bool NumericCastSwitch(Vector &source, Vector &result, idx_t count, strin\n \t\treturn ToDecimalCast<SRC>(source, result, count, error_message);\n \tcase LogicalTypeId::VARCHAR: {\n \t\tVectorStringCast<SRC, duckdb::StringCast>(source, result, count);\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::LIST: {\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn true;\n \t}\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n-\treturn true;\n }\n \n static bool VectorStringCastNumericSwitch(Vector &source, Vector &result, idx_t count, bool strict,\n@@ -216,10 +210,8 @@ static bool VectorStringCastNumericSwitch(Vector &source, Vector &result, idx_t\n \tcase LogicalTypeId::DECIMAL:\n \t\treturn ToDecimalCast<string_t>(source, result, count, error_message);\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n-\treturn true;\n }\n \n static bool StringCastSwitch(Vector &source, Vector &result, idx_t count, bool strict, string *error_message) {\n@@ -259,31 +251,28 @@ static bool DateCastSwitch(Vector &source, Vector &result, idx_t count, string *\n \tcase LogicalTypeId::VARCHAR:\n \t\t// date to varchar\n \t\tVectorStringCast<date_t, duckdb::StringCast>(source, result, count);\n-\t\tbreak;\n+\t\treturn true;\n \tcase LogicalTypeId::TIMESTAMP:\n \t\t// date to timestamp\n \t\treturn VectorTryCastLoop<date_t, timestamp_t, duckdb::TryCast>(source, result, count, error_message);\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n-\treturn true;\n }\n \n-static void TimeCastSwitch(Vector &source, Vector &result, idx_t count) {\n+static bool TimeCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {\n \t// now switch on the result type\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::VARCHAR:\n \t\t// time to varchar\n \t\tVectorStringCast<dtime_t, duckdb::StringCast>(source, result, count);\n-\t\tbreak;\n+\t\treturn true;\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n }\n \n-static void TimestampCastSwitch(Vector &source, Vector &result, idx_t count) {\n+static bool TimestampCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {\n \t// now switch on the result type\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::VARCHAR:\n@@ -311,12 +300,12 @@ static void TimestampCastSwitch(Vector &source, Vector &result, idx_t count) {\n \t\tUnaryExecutor::Execute<timestamp_t, timestamp_t, duckdb::CastTimestampUsToSec>(source, result, count);\n \t\tbreak;\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n+\treturn true;\n }\n \n-static void TimestampNsCastSwitch(Vector &source, Vector &result, idx_t count) {\n+static bool TimestampNsCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {\n \t// now switch on the result type\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::VARCHAR:\n@@ -328,12 +317,12 @@ static void TimestampNsCastSwitch(Vector &source, Vector &result, idx_t count) {\n \t\tUnaryExecutor::Execute<timestamp_t, timestamp_t, duckdb::CastTimestampNsToUs>(source, result, count);\n \t\tbreak;\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n+\treturn true;\n }\n \n-static void TimestampMsCastSwitch(Vector &source, Vector &result, idx_t count) {\n+static bool TimestampMsCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {\n \t// now switch on the result type\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::VARCHAR:\n@@ -345,12 +334,12 @@ static void TimestampMsCastSwitch(Vector &source, Vector &result, idx_t count) {\n \t\tUnaryExecutor::Execute<timestamp_t, timestamp_t, duckdb::CastTimestampMsToUs>(source, result, count);\n \t\tbreak;\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n+\treturn true;\n }\n \n-static void TimestampSecCastSwitch(Vector &source, Vector &result, idx_t count) {\n+static bool TimestampSecCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {\n \t// now switch on the result type\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::VARCHAR:\n@@ -362,12 +351,12 @@ static void TimestampSecCastSwitch(Vector &source, Vector &result, idx_t count)\n \t\tUnaryExecutor::Execute<timestamp_t, timestamp_t, duckdb::CastTimestampSecToUs>(source, result, count);\n \t\tbreak;\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n+\treturn true;\n }\n \n-static void IntervalCastSwitch(Vector &source, Vector &result, idx_t count) {\n+static bool IntervalCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {\n \t// now switch on the result type\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::VARCHAR:\n@@ -375,12 +364,12 @@ static void IntervalCastSwitch(Vector &source, Vector &result, idx_t count) {\n \t\tVectorStringCast<interval_t, duckdb::StringCast>(source, result, count);\n \t\tbreak;\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n+\treturn true;\n }\n \n-static void BlobCastSwitch(Vector &source, Vector &result, idx_t count) {\n+static bool BlobCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {\n \t// now switch on the result type\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::VARCHAR:\n@@ -388,12 +377,12 @@ static void BlobCastSwitch(Vector &source, Vector &result, idx_t count) {\n \t\tVectorStringCast<string_t, duckdb::CastFromBlob>(source, result, count);\n \t\tbreak;\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n+\treturn true;\n }\n \n-static void ValueStringCastSwitch(Vector &source, Vector &result, idx_t count) {\n+static bool ValueStringCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::VARCHAR:\n \t\tif (source.GetVectorType() == VectorType::CONSTANT_VECTOR) {\n@@ -406,14 +395,13 @@ static void ValueStringCastSwitch(Vector &source, Vector &result, idx_t count) {\n \t\t\tauto str_val = src_val.ToString();\n \t\t\tresult.SetValue(i, Value(str_val));\n \t\t}\n-\t\tbreak;\n+\t\treturn true;\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n }\n \n-static void ListCastSwitch(Vector &source, Vector &result, idx_t count) {\n+static bool ListCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::LIST: {\n \t\t// only handle constant and flat vectors here for now\n@@ -444,15 +432,14 @@ static void ListCastSwitch(Vector &source, Vector &result, idx_t count) {\n \t\tVectorOperations::Cast(source_cc, append_vector, source_size);\n \t\tListVector::SetListSize(result, source_size);\n \t\tD_ASSERT(ListVector::GetListSize(result) == source_size);\n-\t\tbreak;\n+\t\treturn true;\n \t}\n \tdefault:\n-\t\tValueStringCastSwitch(source, result, count);\n-\t\tbreak;\n+\t\treturn ValueStringCastSwitch(source, result, count, error_message);\n \t}\n }\n \n-static void StructCastSwitch(Vector &source, Vector &result, idx_t count) {\n+static bool StructCastSwitch(Vector &source, Vector &result, idx_t count, string *error_message) {\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::STRUCT:\n \tcase LogicalTypeId::MAP: {\n@@ -481,8 +468,7 @@ static void StructCastSwitch(Vector &source, Vector &result, idx_t count) {\n \t\t\tsource.Normalify(count);\n \t\t\tFlatVector::Validity(result) = FlatVector::Validity(source);\n \t\t}\n-\n-\t\tbreak;\n+\t\treturn true;\n \t}\n \tcase LogicalTypeId::VARCHAR:\n \t\tif (source.GetVectorType() == VectorType::CONSTANT_VECTOR) {\n@@ -495,11 +481,9 @@ static void StructCastSwitch(Vector &source, Vector &result, idx_t count) {\n \t\t\tauto str_val = src_val.ToString();\n \t\t\tresult.SetValue(i, Value(str_val));\n \t\t}\n-\t\tbreak;\n-\n+\t\treturn true;\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\tbreak;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n }\n \n@@ -536,28 +520,21 @@ bool VectorOperations::TryCast(Vector &source, Vector &result, idx_t count, stri\n \tcase LogicalTypeId::DATE:\n \t\treturn DateCastSwitch(source, result, count, error_message);\n \tcase LogicalTypeId::TIME:\n-\t\tTimeCastSwitch(source, result, count);\n-\t\tbreak;\n+\t\treturn TimeCastSwitch(source, result, count, error_message);\n \tcase LogicalTypeId::TIMESTAMP:\n-\t\tTimestampCastSwitch(source, result, count);\n-\t\tbreak;\n+\t\treturn TimestampCastSwitch(source, result, count, error_message);\n \tcase LogicalTypeId::TIMESTAMP_NS:\n-\t\tTimestampNsCastSwitch(source, result, count);\n-\t\tbreak;\n+\t\treturn TimestampNsCastSwitch(source, result, count, error_message);\n \tcase LogicalTypeId::TIMESTAMP_MS:\n-\t\tTimestampMsCastSwitch(source, result, count);\n-\t\tbreak;\n+\t\treturn TimestampMsCastSwitch(source, result, count, error_message);\n \tcase LogicalTypeId::TIMESTAMP_SEC:\n-\t\tTimestampSecCastSwitch(source, result, count);\n-\t\tbreak;\n+\t\treturn TimestampSecCastSwitch(source, result, count, error_message);\n \tcase LogicalTypeId::INTERVAL:\n-\t\tIntervalCastSwitch(source, result, count);\n-\t\tbreak;\n+\t\treturn IntervalCastSwitch(source, result, count, error_message);\n \tcase LogicalTypeId::VARCHAR:\n \t\treturn StringCastSwitch(source, result, count, strict, error_message);\n \tcase LogicalTypeId::BLOB:\n-\t\tBlobCastSwitch(source, result, count);\n-\t\tbreak;\n+\t\treturn BlobCastSwitch(source, result, count, error_message);\n \tcase LogicalTypeId::SQLNULL: {\n \t\t// cast a NULL to another type, just copy the properties and change the type\n \t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n@@ -566,13 +543,11 @@ bool VectorOperations::TryCast(Vector &source, Vector &result, idx_t count, stri\n \t}\n \tcase LogicalTypeId::MAP:\n \tcase LogicalTypeId::STRUCT:\n-\t\tStructCastSwitch(source, result, count);\n-\t\tbreak;\n+\t\treturn StructCastSwitch(source, result, count, error_message);\n \tcase LogicalTypeId::LIST:\n-\t\tListCastSwitch(source, result, count);\n-\t\tbreak;\n+\t\treturn ListCastSwitch(source, result, count, error_message);\n \tdefault:\n-\t\tthrow UnimplementedCast(source.GetType(), result.GetType());\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n \treturn true;\n }\ndiff --git a/src/include/duckdb/common/vector_operations/decimal_cast.hpp b/src/include/duckdb/common/vector_operations/decimal_cast.hpp\nindex 94e041e19c62..e12cd39d92da 100644\n--- a/src/include/duckdb/common/vector_operations/decimal_cast.hpp\n+++ b/src/include/duckdb/common/vector_operations/decimal_cast.hpp\n@@ -342,8 +342,7 @@ static bool DecimalCastSwitch(Vector &source, Vector &result, idx_t count, strin\n \t\treturn true;\n \t}\n \tdefault:\n-\t\tVectorNullCast(source, result, count);\n-\t\treturn true;\n+\t\treturn TryVectorNullCast(source, result, count, error_message);\n \t}\n }\n \ndiff --git a/src/include/duckdb/common/vector_operations/general_cast.hpp b/src/include/duckdb/common/vector_operations/general_cast.hpp\nindex adf6984fea07..af2a883f96b5 100644\n--- a/src/include/duckdb/common/vector_operations/general_cast.hpp\n+++ b/src/include/duckdb/common/vector_operations/general_cast.hpp\n@@ -28,10 +28,6 @@ static string UnimplementedCastMessage(const LogicalType &source_type, const Log\n \treturn StringUtil::Format(\"Unimplemented type for cast (%s -> %s)\", source_type.ToString(), target_type.ToString());\n }\n \n-static NotImplementedException UnimplementedCast(const LogicalType &source_type, const LogicalType &target_type) {\n-\treturn NotImplementedException(UnimplementedCastMessage(source_type, target_type));\n-}\n-\n // NULL cast only works if all values in source are NULL, otherwise an unimplemented cast exception is thrown\n static bool TryVectorNullCast(Vector &source, Vector &result, idx_t count, string *error_message) {\n \tbool success = true;\n@@ -44,8 +40,4 @@ static bool TryVectorNullCast(Vector &source, Vector &result, idx_t count, strin\n \treturn success;\n }\n \n-static void VectorNullCast(Vector &source, Vector &result, idx_t count) {\n-\tTryVectorNullCast(source, result, count, nullptr);\n-}\n-\n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex dd2838f6b0f3..607c2113ba38 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -151,6 +151,8 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \tbool plan_subquery = true;\n \t//! Whether CTEs should reference the parent binder (if it exists)\n \tbool inherit_ctes = true;\n+\t//! Whether or not the binder can contain NULLs as the root of expressions\n+\tbool can_contain_nulls = false;\n \t//! The root statement of the query that is currently being parsed\n \tSQLStatement *root_statement = nullptr;\n \ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 737d2ece6543..08a7ccfd7475 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -75,6 +75,9 @@ class ExpressionBinder {\n \tvoid BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, string &error);\n \tstatic void ExtractCorrelatedExpressions(Binder &binder, Expression &expr);\n \n+\tstatic bool ContainsNullType(const LogicalType &type);\n+\tstatic LogicalType ExchangeNullType(const LogicalType &type);\n+\n protected:\n \tvirtual BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,\n \t                                  bool root_expression = false);\ndiff --git a/src/planner/binder/expression/bind_subquery_expression.cpp b/src/planner/binder/expression/bind_subquery_expression.cpp\nindex cbab7b4bbb0c..8f56b845da2d 100644\n--- a/src/planner/binder/expression/bind_subquery_expression.cpp\n+++ b/src/planner/binder/expression/bind_subquery_expression.cpp\n@@ -32,6 +32,7 @@ BindResult ExpressionBinder::BindExpression(SubqueryExpression &expr, idx_t dept\n \t\tD_ASSERT(depth == 0);\n \t\t// first bind the actual subquery in a new binder\n \t\tauto subquery_binder = Binder::CreateBinder(context, &binder);\n+\t\tsubquery_binder->can_contain_nulls = true;\n \t\tauto bound_node = subquery_binder->BindNode(*expr.subquery->node);\n \t\t// check the correlated columns of the subquery for correlated columns with depth > 1\n \t\tfor (idx_t i = 0; i < subquery_binder->correlated_columns.size(); i++) {\ndiff --git a/src/planner/binder/query_node/bind_setop_node.cpp b/src/planner/binder/query_node/bind_setop_node.cpp\nindex 349194253538..a5c47e158b24 100644\n--- a/src/planner/binder/query_node/bind_setop_node.cpp\n+++ b/src/planner/binder/query_node/bind_setop_node.cpp\n@@ -69,9 +69,11 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SetOperationNode &statement) {\n \tresult->setop_index = GenerateTableIndex();\n \n \tresult->left_binder = Binder::CreateBinder(context, this);\n+\tresult->left_binder->can_contain_nulls = true;\n \tresult->left = result->left_binder->BindNode(*statement.left);\n \n \tresult->right_binder = Binder::CreateBinder(context, this);\n+\tresult->right_binder->can_contain_nulls = true;\n \tresult->right = result->right_binder->BindNode(*statement.right);\n \n \tif (!statement.modifiers.empty()) {\n@@ -104,6 +106,11 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SetOperationNode &statement) {\n \t// figure out the types of the setop result by picking the max of both\n \tfor (idx_t i = 0; i < result->left->types.size(); i++) {\n \t\tauto result_type = LogicalType::MaxLogicalType(result->left->types[i], result->right->types[i]);\n+\t\tif (!can_contain_nulls) {\n+\t\t\tif (ExpressionBinder::ContainsNullType(result_type)) {\n+\t\t\t\tresult_type = ExpressionBinder::ExchangeNullType(result_type);\n+\t\t\t}\n+\t\t}\n \t\tresult->types.push_back(result_type);\n \t}\n \ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex 6ce08644a38e..7599f7d01314 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -51,6 +51,8 @@ void Binder::BindCreateViewInfo(CreateViewInfo &base) {\n \t// bind the view as if it were a query so we can catch errors\n \t// note that we bind the original, and replace the original with a copy\n \t// this is because the original has\n+\tthis->can_contain_nulls = true;\n+\n \tauto copy = base.query->Copy();\n \tauto query_node = Bind(*base.query);\n \tbase.query = unique_ptr_cast<SQLStatement, SelectStatement>(move(copy));\n@@ -123,7 +125,6 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {\n \t\tauto &base = (CreateViewInfo &)*stmt.info;\n \t\t// bind the schema\n \t\tauto schema = BindSchema(*stmt.info);\n-\n \t\tBindCreateViewInfo(base);\n \t\tresult.plan = make_unique<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_VIEW, move(stmt.info), schema);\n \t\tbreak;\ndiff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex 56f69f5a1543..4db6f1b0ead8 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -109,6 +109,7 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \t\t// for the view and for the current query\n \t\tbool inherit_ctes = false;\n \t\tauto view_binder = Binder::CreateBinder(context, this, inherit_ctes);\n+\t\tview_binder->can_contain_nulls = true;\n \t\tSubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(view_catalog_entry->query->Copy()));\n \t\tsubquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;\n \t\tsubquery.column_name_alias =\ndiff --git a/src/planner/binder/tableref/bind_subqueryref.cpp b/src/planner/binder/tableref/bind_subqueryref.cpp\nindex 4fe116796f09..c6e79b2c72c8 100644\n--- a/src/planner/binder/tableref/bind_subqueryref.cpp\n+++ b/src/planner/binder/tableref/bind_subqueryref.cpp\n@@ -6,6 +6,7 @@ namespace duckdb {\n \n unique_ptr<BoundTableRef> Binder::Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte) {\n \tauto binder = Binder::CreateBinder(context, this);\n+\tbinder->can_contain_nulls = true;\n \tif (cte) {\n \t\tbinder->bound_ctes.insert(cte);\n \t}\ndiff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp\nindex 8bc572e575c1..173eb5260b45 100644\n--- a/src/planner/expression_binder.cpp\n+++ b/src/planner/expression_binder.cpp\n@@ -113,7 +113,7 @@ void ExpressionBinder::ExtractCorrelatedExpressions(Binder &binder, Expression &\n \t                                      [&](Expression &child) { ExtractCorrelatedExpressions(binder, child); });\n }\n \n-static bool ContainsNullType(const LogicalType &type) {\n+bool ExpressionBinder::ContainsNullType(const LogicalType &type) {\n \tswitch (type.id()) {\n \tcase LogicalTypeId::STRUCT:\n \tcase LogicalTypeId::MAP: {\n@@ -134,7 +134,7 @@ static bool ContainsNullType(const LogicalType &type) {\n \t}\n }\n \n-static LogicalType ExchangeNullType(const LogicalType &type) {\n+LogicalType ExpressionBinder::ExchangeNullType(const LogicalType &type) {\n \tswitch (type.id()) {\n \tcase LogicalTypeId::STRUCT:\n \tcase LogicalTypeId::MAP: {\n@@ -177,9 +177,11 @@ unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr\n \t} else {\n \t\t// SQL NULL type is only used internally in the binder\n \t\t// cast to INTEGER if we encounter it outside of the binder\n-\t\tif (ContainsNullType(result->return_type)) {\n-\t\t\tauto result_type = ExchangeNullType(result->return_type);\n-\t\t\tresult = BoundCastExpression::AddCastToType(move(result), result_type);\n+\t\tif (!binder.can_contain_nulls) {\n+\t\t\tif (ContainsNullType(result->return_type)) {\n+\t\t\t\tauto result_type = ExchangeNullType(result->return_type);\n+\t\t\t\tresult = BoundCastExpression::AddCastToType(move(result), result_type);\n+\t\t\t}\n \t\t}\n \t}\n \tif (result_type) {\n",
  "test_patch": "diff --git a/test/sql/binder/test_null_type_propagation.test b/test/sql/binder/test_null_type_propagation.test\nnew file mode 100644\nindex 000000000000..f7c1a0c662c8\n--- /dev/null\n+++ b/test/sql/binder/test_null_type_propagation.test\n@@ -0,0 +1,203 @@\n+# name: test/sql/binder/test_null_type_propagation.test\n+# description: Test binding of NULL type\n+# group: [binder]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# regular binding\n+query I\n+SELECT NULL\n+----\n+NULL\n+\n+# union\n+query I\n+SELECT NULL UNION ALL SELECT CAST(1 AS BOOLEAN)\n+----\n+NULL\n+True\n+\n+query I\n+SELECT NULL UNION ALL SELECT NULL\n+----\n+NULL\n+NULL\n+\n+# mutliple unions\n+query I\n+SELECT NULL UNION ALL SELECT NULL UNION ALL SELECT NULL UNION ALL SELECT NULL UNION ALL SELECT CAST(1 AS BOOLEAN)\n+----\n+NULL\n+NULL\n+NULL\n+NULL\n+True\n+\n+# scalar subquery\n+query I\n+SELECT (SELECT NULL) UNION ALL SELECT CAST(1 AS BOOLEAN)\n+----\n+NULL\n+True\n+\n+# table subquery\n+query I\n+SELECT * FROM (SELECT NULL) tbl(i) UNION ALL SELECT CAST(1 AS BOOLEAN)\n+----\n+NULL\n+True\n+\n+query I\n+SELECT * FROM (SELECT (SELECT NULL) UNION ALL SELECT CAST(1 AS BOOLEAN)) tbl(i)\n+----\n+NULL\n+True\n+\n+query I\n+SELECT * FROM (SELECT NULL) tbl(i) UNION ALL SELECT NULL\n+----\n+NULL\n+NULL\n+\n+# bool_and\n+query I\n+SELECT bool_and(i) FROM (SELECT * FROM (SELECT NULL) tbl(i) UNION ALL SELECT CAST(1 as BOOLEAN)) tbl(i)\n+----\n+True\n+\n+# this wouldn't work if we would upcast to integer\n+statement error\n+SELECT bool_and(i) FROM (SELECT * FROM (SELECT NULL::INTEGER) tbl(i) UNION ALL SELECT CAST(1 as BOOLEAN)) tbl(i)\n+\n+# cross product\n+query II\n+SELECT * FROM (SELECT NULL) tbl(i), (SELECT NULL) tbl2(j)\n+----\n+NULL\tNULL\n+\n+query II\n+SELECT bool_and(i), bool_and(j) FROM (SELECT NULL) tbl(i), (SELECT NULL) tbl2(j)\n+----\n+NULL\tNULL\n+\n+# Issue #1049: Should a UNION with untyped NULL preserve the type?\n+query III\n+SELECT NULL as a, NULL as b, 1 as id UNION SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 2 as id\n+----\n+NULL\tNULL\t1\n+True\tFalse\t2\n+\n+query III\n+SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 1 as id UNION SELECT NULL as a, NULL as b, 2 as id\n+----\n+True\tFalse\t1\n+NULL\tNULL\t2\n+\n+# old behavior: cast NULL to integer explicitly\n+query III\n+SELECT NULL::INTEGER as a, NULL::INTEGER as b, 1 as id UNION SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 2 as id\n+----\n+NULL\tNULL\t1\n+1\t0\t2\n+\n+query III\n+SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 1 as id UNION SELECT NULL::INTEGER as a, NULL::INTEGER as b, 2 as id\n+----\n+1\t0\t1\n+NULL\tNULL\t2\n+\n+# NULL is auto-cast to integer for storage purposes\n+statement ok\n+CREATE TABLE tbl AS SELECT NULL UNION ALL SELECT NULL\n+\n+query I\n+SELECT * FROM tbl\n+----\n+NULL\n+NULL\n+\n+query I\n+SELECT typeof(#1) FROM tbl LIMIT 1\n+----\n+INTEGER\n+\n+# views preserve NULLs\n+statement ok\n+CREATE VIEW v1 AS SELECT NULL\n+\n+query I\n+SELECT * FROM v1\n+----\n+NULL\n+\n+query I\n+SELECT * FROM v1 UNION ALL SELECT CAST(1 AS BOOLEAN)\n+----\n+NULL\n+True\n+\n+query I\n+SELECT typeof(#1) FROM v1\n+----\n+NULL\n+\n+# also with unions\n+statement ok\n+CREATE VIEW v2 AS SELECT NULL UNION ALL SELECT NULL\n+\n+query I\n+SELECT * FROM v2\n+----\n+NULL\n+NULL\n+\n+query I\n+SELECT * FROM v2 UNION ALL SELECT CAST(1 AS BOOLEAN)\n+----\n+NULL\n+NULL\n+True\n+\n+query I\n+SELECT typeof(#1) FROM v2 LIMIT 1\n+----\n+NULL\n+\n+# nulls in lists\n+query I\n+SELECT [NULL]\n+----\n+[NULL]\n+\n+query I\n+SELECT [NULL] UNION ALL SELECT [True]\n+----\n+[NULL]\n+[True]\n+\n+# nulls in structs\n+query I\n+SELECT {'x': NULL}\n+----\n+{'x': NULL}\n+\n+query I\n+SELECT {'x': NULL} UNION ALL SELECT {'x': True}\n+----\n+{'x': NULL}\n+{'x': True}\n+\n+# ctes\n+query I\n+WITH cte AS (SELECT NULL)\n+SELECT * FROM cte\n+----\n+NULL\n+\n+query I\n+WITH cte AS (SELECT NULL)\n+SELECT * FROM cte UNION ALL SELECT CAST(1 AS BOOLEAN)\n+----\n+NULL\n+True\n",
  "problem_statement": "Should a UNION with untyped NULL preserve the type?\nCurrently it doesn't for `BOOLEAN`, DBItest `\"data_logical\"` .\r\n\r\n``` r\r\nlibrary(DBI)\r\n\r\ndrv1 <- duckdb::duckdb()\r\nconn1 <- dbConnect(drv1, debug = TRUE)\r\ndbDataType(conn1, logical(0))\r\n#> [1] \"BOOLEAN\"\r\ndbGetQuery(conn1, \"SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b\")\r\n#> Q SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b\r\n#>      a     b\r\n#> 1 TRUE FALSE\r\ndbGetQuery(conn1, \"SELECT NULL as a, NULL as b, 1 as id UNION SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 2 as id\")\r\n#> Q SELECT NULL as a, NULL as b, 1 as id UNION SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 2 as id\r\n#>    a  b id\r\n#> 1 NA NA  1\r\n#> 2  1  0  2\r\ndbGetQuery(conn1, \"SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 1 as id UNION SELECT NULL as a, NULL as b, 2 as id\")\r\n#> Q SELECT CAST(1 AS BOOLEAN) as a, CAST(0 AS BOOLEAN) as b, 1 as id UNION SELECT NULL as a, NULL as b, 2 as id\r\n#>    a  b id\r\n#> 1  1  0  1\r\n#> 2 NA NA  2\r\n```\r\n\r\n<sup>Created on 2020-10-25 by the [reprex package](https://reprex.tidyverse.org) (v0.3.0)</sup>\n",
  "hints_text": "It should not lose the boolean type, for sure\nThe `duckdb` shell shows a similar result:\r\n\r\n```\r\n$ echo 'select TRUE AS a UNION select NULL;' | ./duckdb\r\n\u250c\u2500\u2500\u2500\u2510\r\n\u2502 a \u2502\r\n\u251c\u2500\u2500\u2500\u2524\r\n\u2502   \u2502\r\n\u2502 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2518\r\n```\r\n\nThis is relevant for DBItest.\nI had a look at this and the problem here is that we don't allow the NULL type to exist outside of expressions. At the expression boundary the NULL type will instead be converted to an INTEGER type, which then leads to the union being (BOOL, INT) which gets promoted to (INT). The fix here is to allow the NULL type to exist outside of the expression binder, but this is a slightly more involved fix. I can have a go at this next week.\nThis still seems to be an issue with f2d7702421c151e9acd840d52ed1f46a5b8174f1.",
  "created_at": "2021-08-09T07:57:04Z"
}