{
  "repo": "duckdb/duckdb",
  "pull_number": 9385,
  "instance_id": "duckdb__duckdb-9385",
  "issue_numbers": [
    "9226"
  ],
  "base_commit": "5ec85a719940a9fade15c38e7601712e9cef58d8",
  "patch": "diff --git a/tools/pythonpkg/src/python_udf.cpp b/tools/pythonpkg/src/python_udf.cpp\nindex 66ae25e01da2..54494aeb39af 100644\n--- a/tools/pythonpkg/src/python_udf.cpp\n+++ b/tools/pythonpkg/src/python_udf.cpp\n@@ -279,9 +279,20 @@ struct PythonUDFData {\n \t\t}\n \t}\n \n-\tvoid AnalyzeSignature(const py::object &udf) {\n+\tpy::object GetSignature(const py::object &udf) {\n+\t\tconst int32_t PYTHON_3_10_HEX = 0x030a00f0;\n+\t\tauto python_version = PY_VERSION_HEX;\n+\n \t\tauto signature_func = py::module_::import(\"inspect\").attr(\"signature\");\n-\t\tauto signature = signature_func(udf);\n+\t\tif (python_version >= PYTHON_3_10_HEX) {\n+\t\t\treturn signature_func(udf, py::arg(\"eval_str\") = true);\n+\t\t} else {\n+\t\t\treturn signature_func(udf);\n+\t\t}\n+\t}\n+\n+\tvoid AnalyzeSignature(const py::object &udf) {\n+\t\tauto signature = GetSignature(udf);\n \t\tauto sig_params = signature.attr(\"parameters\");\n \t\tauto return_annotation = signature.attr(\"return_annotation\");\n \t\tif (!py::none().is(return_annotation)) {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_string_annotation.py b/tools/pythonpkg/tests/fast/test_string_annotation.py\nnew file mode 100644\nindex 000000000000..c5500c663ee1\n--- /dev/null\n+++ b/tools/pythonpkg/tests/fast/test_string_annotation.py\n@@ -0,0 +1,53 @@\n+import duckdb\n+import pytest\n+import sys\n+from typing import Union\n+\n+\n+def make_annotated_function(type: str):\n+    def test_base():\n+        return None\n+\n+    import types\n+\n+    test_function = types.FunctionType(\n+        test_base.__code__, test_base.__globals__, test_base.__name__, test_base.__defaults__, test_base.__closure__\n+    )\n+    # Add the 'type' string as return_annotation\n+    test_function.__annotations__ = {'return': type}\n+    return test_function\n+\n+\n+def python_version_lower_than_3_10():\n+    import sys\n+\n+    if sys.version_info[0] < 3:\n+        return True\n+    if sys.version_info[1] < 10:\n+        return True\n+    return False\n+\n+\n+class TestStringAnnotation(object):\n+    @pytest.mark.skipif(\n+        python_version_lower_than_3_10(), reason=\"inspect.signature(eval_str=True) only supported since 3.10 and higher\"\n+    )\n+    @pytest.mark.parametrize(\n+        ['input', 'expected'],\n+        [\n+            ('str', 'VARCHAR'),\n+            ('list[str]', 'VARCHAR[]'),\n+            ('dict[str, str]', 'MAP(VARCHAR, VARCHAR)'),\n+            ('dict[Union[str, bool], str]', 'MAP(UNION(u1 VARCHAR, u2 BOOLEAN), VARCHAR)'),\n+        ],\n+    )\n+    def test_string_annotations(self, duckdb_cursor, input, expected):\n+        from inspect import signature\n+\n+        func = make_annotated_function(input)\n+        sig = signature(func)\n+        assert sig.return_annotation.__class__ == str\n+\n+        duckdb_cursor.create_function(\"foo\", func)\n+        rel = duckdb_cursor.sql(\"select foo()\")\n+        assert rel.types == [expected]\n",
  "problem_statement": "`duckdb.create_function` type inferencing doesn't work with `from __future__ import annotations`\n### What happens?\n\nIn the Python UDF interface, `create_function` is able to infer types by inspecting the signature of the function to be registered. However, this doesn't work with [PEP 563](https://peps.python.org/pep-0563/) string annotations. The reason is [we use `inspect.signature`](https://github.com/duckdb/duckdb/blob/0894f3d6ab1321619c40c5ef870ad252f16f83ab/tools/pythonpkg/src/python_udf.cpp#L282) which does not evaluate string annotations.\r\n\r\nIn Python 3.10+, [we can pass `eval_str=True`](https://docs.python.org/3/library/inspect.html#inspect.signature) to `inspect.signature` and it will parse the annotations for us. This has the disadvantage of potentially raising an exception or executing arbitrary code, but on balance, I think the user opts into this by registering a function without passing explicit types, and it is more useful than the current behavior in most cases.\n\n### To Reproduce\n\n```python\r\nfrom __future__ import annotations\r\nimport duckdb\r\n\r\ndef foo(x: int) -> str:\r\n    return str(x * 2)\r\n\r\nduckdb.create_function(\"foo\", foo)\r\n```\r\n\r\nThis raises the following error:\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"test.py\", line 7, in <module>\r\n    duckdb.create_function(\"foo\", foo)\r\nduckdb.duckdb.InvalidInputException: Invalid Input Error: Could not infer the return type, please set it explicitly\r\n```\r\n\r\nRemoving the first line causes it to succeed.\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\nmain\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nBen Kurtovic\n\n### Affiliation:\n\nUnaffiliated\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "Just to clarify, your point is not about supporting the `__future__.annotations` module as a way to backport annotations to older python versions, but only about supporting the [PEP 563](https://peps.python.org/pep-0563/) aspect of this?\r\n\r\nBecause `eval_str` is only available since 3.10, so this wouldn't work in older versions anyways",
  "created_at": "2023-10-18T11:33:04Z"
}