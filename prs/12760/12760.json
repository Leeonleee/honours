{
  "repo": "duckdb/duckdb",
  "pull_number": 12760,
  "instance_id": "duckdb__duckdb-12760",
  "issue_numbers": [
    "12743"
  ],
  "base_commit": "9cc0998e2c5c8034b0cd7b431e0bd82b15892091",
  "patch": "diff --git a/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp b/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\nindex 2f75da624e70..14c813b59532 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\n@@ -23,10 +23,6 @@\n #endif\n #endif\n \n-#define PyDateTime_TIMEDELTA_GET_DAYS(o)         (((PyDateTime_Delta *)(o))->days)\n-#define PyDateTime_TIMEDELTA_GET_SECONDS(o)      (((PyDateTime_Delta *)(o))->seconds)\n-#define PyDateTime_TIMEDELTA_GET_MICROSECONDS(o) (((PyDateTime_Delta *)(o))->microseconds)\n-\n namespace duckdb {\n \n struct PyDictionary {\n@@ -198,7 +194,7 @@ struct PyTimezone {\n \n public:\n \tDUCKDB_API static int32_t GetUTCOffsetSeconds(py::handle &tzone_obj);\n-\tDUCKDB_API static interval_t GetUTCOffset(py::handle &tzone_obj);\n+\tDUCKDB_API static interval_t GetUTCOffset(py::handle &datetime, py::handle &tzone_obj);\n };\n \n struct PythonObject {\ndiff --git a/tools/pythonpkg/src/native/python_objects.cpp b/tools/pythonpkg/src/native/python_objects.cpp\nindex 5c19f2ae13e2..e1695cae7e56 100644\n--- a/tools/pythonpkg/src/native/python_objects.cpp\n+++ b/tools/pythonpkg/src/native/python_objects.cpp\n@@ -42,15 +42,15 @@ interval_t PyTimeDelta::ToInterval() {\n }\n \n int64_t PyTimeDelta::GetDays(py::handle &obj) {\n-\treturn PyDateTime_TIMEDELTA_GET_DAYS(obj.ptr()); // NOLINT\n+\treturn py::int_(obj.attr(\"days\")).cast<int64_t>();\n }\n \n int64_t PyTimeDelta::GetSeconds(py::handle &obj) {\n-\treturn PyDateTime_TIMEDELTA_GET_SECONDS(obj.ptr()); // NOLINT\n+\treturn py::int_(obj.attr(\"seconds\")).cast<int64_t>();\n }\n \n int64_t PyTimeDelta::GetMicros(py::handle &obj) {\n-\treturn PyDateTime_TIMEDELTA_GET_MICROSECONDS(obj.ptr()); // NOLINT\n+\treturn py::int_(obj.attr(\"microseconds\")).cast<int64_t>();\n }\n \n PyDecimal::PyDecimal(py::handle &obj) : obj(obj) {\n@@ -248,13 +248,15 @@ py::object PyTime::GetTZInfo(py::handle &obj) {\n \treturn py::reinterpret_borrow<py::object>(PyDateTime_TIME_GET_TZINFO(obj.ptr())); // NOLINT\n }\n \n-interval_t PyTimezone::GetUTCOffset(py::handle &tzone_obj) {\n-\tauto res = tzone_obj.attr(\"utcoffset\")(py::none());\n+interval_t PyTimezone::GetUTCOffset(py::handle &datetime, py::handle &tzone_obj) {\n+\t// The datetime object is provided because the utcoffset could be ambiguous\n+\tauto res = tzone_obj.attr(\"utcoffset\")(datetime);\n \tauto timedelta = PyTimeDelta(res);\n \treturn timedelta.ToInterval();\n }\n \n int32_t PyTimezone::GetUTCOffsetSeconds(py::handle &tzone_obj) {\n+\t// We should be able to use None here, the tzone_obj of a datetime.time should never be ambiguous\n \tauto res = tzone_obj.attr(\"utcoffset\")(py::none());\n \tauto timedelta = PyTimeDelta(res);\n \tif (timedelta.days != 0) {\n@@ -288,7 +290,7 @@ timestamp_t PyDateTime::ToTimestamp() {\n Value PyDateTime::ToDuckValue(const LogicalType &target_type) {\n \tauto timestamp = ToTimestamp();\n \tif (!py::none().is(tzone_obj)) {\n-\t\tauto utc_offset = PyTimezone::GetUTCOffset(tzone_obj);\n+\t\tauto utc_offset = PyTimezone::GetUTCOffset(obj, tzone_obj);\n \t\t// Need to subtract the UTC offset, so we invert the interval\n \t\tutc_offset = Interval::Invert(utc_offset);\n \t\ttimestamp = Interval::Add(timestamp, utc_offset);\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/pandas/test_pandas_timestamp.py b/tools/pythonpkg/tests/fast/pandas/test_pandas_timestamp.py\nindex 5ab311d1f994..cad5cf53eeb2 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_pandas_timestamp.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_pandas_timestamp.py\n@@ -1,16 +1,46 @@\n import duckdb\n-import pandas as pd\n-from pytest import mark\n+import pandas\n+import pytest\n \n+from datetime import datetime\n+from pytz import timezone\n \n-@mark.parametrize('timezone', ['UTC', 'CET', 'Asia/Kathmandu'])\n-def run_pandas_with_tz(timezone):\n+\n+@pytest.mark.parametrize('timezone', ['UTC', 'CET', 'Asia/Kathmandu'])\n+def test_run_pandas_with_tz(timezone):\n     con = duckdb.connect()\n-    con.execute(\"SET TimeZone = '\" + timezone + \"'\")\n-    df = pd.DataFrame({\"timestamp\": [pd.Timestamp(\"2022-01-01 10:15\", tz=timezone)]})\n+    con.execute(f\"SET TimeZone = '{timezone}'\")\n+    df = pandas.DataFrame(\n+        {\n+            'timestamp': pandas.Series(\n+                data=[pandas.Timestamp(year=2022, month=1, day=1, hour=10, minute=15, tz=timezone, unit='us')],\n+                dtype=f'datetime64[us, {timezone}]',\n+            )\n+        }\n+    )\n     duck_df = con.from_df(df).df()\n-    print(df['timestamp'].dtype)\n-    print(duck_df['timestamp'].dtype)\n-    print(df)\n-    print(duck_df)\n-    assert df.equals(duck_df)\n+    assert duck_df['timestamp'][0] == df['timestamp'][0]\n+\n+\n+def test_timestamp_conversion(duckdb_cursor):\n+    tzinfo = pandas.Timestamp('2024-01-01 00:00:00+0100', tz='Europe/Copenhagen').tzinfo\n+    ts_df = pandas.DataFrame(\n+        {\n+            \"ts\": [\n+                pandas.Timestamp('2024-01-01 00:00:00+0100', tz=tzinfo),\n+                pandas.Timestamp('2024-01-02 00:00:00+0100', tz=tzinfo),\n+            ]\n+        }\n+    )\n+\n+    query = \"\"\"\n+        select\n+            *\n+        from ts_df\n+        where ts = $notationtime\n+    \"\"\"\n+    params_zoneinfo = {\"notationtime\": datetime(2024, 1, 1, tzinfo=tzinfo)}\n+    duckdb_cursor.execute(\"set TimeZone = 'Europe/Copenhagen'\")\n+    rel = duckdb_cursor.execute(query, parameters=params_zoneinfo)\n+    res = rel.fetchall()\n+    assert res[0][0] == datetime(2024, 1, 1, tzinfo=tzinfo)\n",
  "problem_statement": "Conversion Error: Overflow exception in date/time -> timestamp conversion\n### What happens?\n\nWhen I try to query with `params` that are `datetime` with `tzinfo` I get `Conversion Error: Overflow exception in date/time -> timestamp conversion`.\r\n\r\nMaybe this is a bug. Maybe its just not very clear from the documentation how to use datetime `params` with time zones.\r\n\r\nI've tried searching the documentation and doing google search without luck.\n\n### To Reproduce\n\nRun\r\n\r\n```python\r\nfrom datetime import datetime\r\n\r\nimport duckdb\r\nimport pandas as pd\r\nfrom pytz import timezone\r\n\r\nts_df = pd.DataFrame({ \"ts\": [pd.Timestamp('2024-01-01 00:00:00+0100', tz='Europe/Copenhagen'), pd.Timestamp('2024-01-02 00:00:00+0100', tz='Europe/Copenhagen')] })\r\n\r\nquery = \"select * from ts_df where ts = $notationtime\"\r\nparams = {\"notationtime\": datetime(2024, 1, 1),}\r\nparams_zoneinfo = {\"notationtime\": datetime(2024, 1, 1, tzinfo=timezone(\"Europe/Copenhagen\")),}\r\n\r\nwith duckdb.connect() as conn:\r\n    conn.sql(\"set TimeZone = 'Europe/Copenhagen'\")\r\n    \r\n    print(conn.sql(query, params=params).df())\r\n    print(conn.sql(query, params=params_zoneinfo).df())\r\n```\r\n\r\nand see\r\n\r\n```bash\r\n$ python script.py\r\n                         ts\r\n0 2024-01-01 00:00:00+01:00\r\nTraceback (most recent call last):\r\n  File \"/home/jovyan/repos/mt-pm-reporting/script.py\", line 13, in <module>\r\n    with duckdb.connect() as conn:\r\n  File \"/home/jovyan/repos/mt-pm-reporting/script.py\", line 17, in <module>\r\n    print(conn.sql(query, params=params_zoneinfo).df())\r\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nduckdb.duckdb.ConversionException: Conversion Error: Overflow exception in date/time -> timestamp conversion\r\n```\n\n### OS:\n\nlinux\n\n### DuckDB Version:\n\n1.0.0\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nMarc Skov Madsen\n\n### Affiliation:\n\nOrsted\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have not tested with any build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "Hi @MarcSkovMadsen, thanks for opening this issue.\r\n\r\nI'm unable to reproduce it: when I run the script, I get the following output and a zero exit code:\r\n\r\n```text\r\n                         ts\r\n0 2024-01-01 00:00:00+01:00\r\nEmpty DataFrame\r\nColumns: [ts]\r\nIndex: []\r\n```\r\n\nThanks. Let me try once again tomorrow in a totally fresh environment and then share all dependencies.\nEven though it does not error for you, I'm still confused about why the params without timezone gives the result Im after.\nI've recreated my environment and installed.\r\n\r\n```bash\r\nuv venv\r\nuv pip install duckdb pandas pytz\r\n```\r\n\r\nIts still errors. My environment is\r\n\r\nI'm running on linux with Python 3.11.6 and\r\n\r\n```bash\r\n$ uv pip freeze\r\nduckdb==1.0.0\r\nnumpy==2.0.0\r\npandas==2.2.2\r\npython-dateutil==2.9.0.post0\r\npytz==2024.1\r\nsix==1.16.0\r\ntzdata==2024.1\r\n```\nI tried downgrading numpy (`uv pip install 'numpy<2.0'`) to `1.26.4` but it still errors.\nHi @MarcSkovMadsen, I replicated your environment but it still doesn't reproduce. I tried both Python 3.11 and 3.12.\r\n\r\nI'll let someone else from the team also take a look.\r\n\r\n```text\r\n$ uv pip freeze\r\nduckdb==1.0.0\r\nnumpy==2.0.0\r\npandas==2.2.2\r\npython-dateutil==2.9.0.post0\r\npytz==2024.1\r\nsix==1.16.0\r\ntzdata==2024.1\r\n\r\n$ .venv/bin/python script.py\r\n                         ts\r\n0 2024-01-01 00:00:00+01:00\r\nEmpty DataFrame\r\nColumns: [ts]\r\nIndex: []\r\n\r\n$ .venv/bin/python --version\r\nPython 3.12.4\r\n```",
  "created_at": "2024-06-28T11:44:26Z"
}