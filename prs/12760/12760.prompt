You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Conversion Error: Overflow exception in date/time -> timestamp conversion
### What happens?

When I try to query with `params` that are `datetime` with `tzinfo` I get `Conversion Error: Overflow exception in date/time -> timestamp conversion`.

Maybe this is a bug. Maybe its just not very clear from the documentation how to use datetime `params` with time zones.

I've tried searching the documentation and doing google search without luck.

### To Reproduce

Run

```python
from datetime import datetime

import duckdb
import pandas as pd
from pytz import timezone

ts_df = pd.DataFrame({ "ts": [pd.Timestamp('2024-01-01 00:00:00+0100', tz='Europe/Copenhagen'), pd.Timestamp('2024-01-02 00:00:00+0100', tz='Europe/Copenhagen')] })

query = "select * from ts_df where ts = $notationtime"
params = {"notationtime": datetime(2024, 1, 1),}
params_zoneinfo = {"notationtime": datetime(2024, 1, 1, tzinfo=timezone("Europe/Copenhagen")),}

with duckdb.connect() as conn:
    conn.sql("set TimeZone = 'Europe/Copenhagen'")
    
    print(conn.sql(query, params=params).df())
    print(conn.sql(query, params=params_zoneinfo).df())
```

and see

```bash
$ python script.py
                         ts
0 2024-01-01 00:00:00+01:00
Traceback (most recent call last):
  File "/home/jovyan/repos/mt-pm-reporting/script.py", line 13, in <module>
    with duckdb.connect() as conn:
  File "/home/jovyan/repos/mt-pm-reporting/script.py", line 17, in <module>
    print(conn.sql(query, params=params_zoneinfo).df())
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
duckdb.duckdb.ConversionException: Conversion Error: Overflow exception in date/time -> timestamp conversion
```

### OS:

linux

### DuckDB Version:

1.0.0

### DuckDB Client:

Python

### Full Name:

Marc Skov Madsen

### Affiliation:

Orsted

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of tools/pythonpkg/src/include/duckdb_python/python_objects.hpp]
1: #pragma once
2: 
3: #include "duckdb_python/pybind11/pybind_wrapper.hpp"
4: #include "duckdb_python/pyutil.hpp"
5: #include "duckdb/common/types/time.hpp"
6: #include "duckdb/common/types/date.hpp"
7: #include "duckdb/common/types/timestamp.hpp"
8: #include "duckdb/common/types/interval.hpp"
9: #include "duckdb/common/types/value.hpp"
10: #include "duckdb/common/types/cast_helpers.hpp"
11: #include "duckdb/main/client_properties.hpp"
12: 
13: #include "datetime.h" //from python
14: 
15: /* Backport for Python < 3.10 */
16: #if PY_VERSION_HEX < 0x030a00a1
17: #ifndef PyDateTime_TIME_GET_TZINFO
18: #define PyDateTime_TIME_GET_TZINFO(o) ((((PyDateTime_Time *)o)->hastzinfo) ? ((PyDateTime_Time *)o)->tzinfo : Py_None)
19: #endif
20: #ifndef PyDateTime_DATE_GET_TZINFO
21: #define PyDateTime_DATE_GET_TZINFO(o)                                                                                  \
22: 	((((PyDateTime_DateTime *)o)->hastzinfo) ? ((PyDateTime_DateTime *)o)->tzinfo : Py_None)
23: #endif
24: #endif
25: 
26: #define PyDateTime_TIMEDELTA_GET_DAYS(o)         (((PyDateTime_Delta *)(o))->days)
27: #define PyDateTime_TIMEDELTA_GET_SECONDS(o)      (((PyDateTime_Delta *)(o))->seconds)
28: #define PyDateTime_TIMEDELTA_GET_MICROSECONDS(o) (((PyDateTime_Delta *)(o))->microseconds)
29: 
30: namespace duckdb {
31: 
32: struct PyDictionary {
33: public:
34: 	PyDictionary(py::object dict);
35: 	// These are cached so we don't have to create new objects all the time
36: 	// The CPython API offers PyDict_Keys but that creates a new reference every time, same for values
37: 	py::object keys;
38: 	py::object values;
39: 	idx_t len;
40: 
41: public:
42: 	py::handle operator[](const py::object &obj) const {
43: 		return PyDict_GetItem(dict.ptr(), obj.ptr());
44: 	}
45: 
46: public:
47: 	string ToString() const {
48: 		return string(py::str(dict));
49: 	}
50: 
51: private:
52: 	py::object dict;
53: };
54: 
55: enum class PyDecimalExponentType {
56: 	EXPONENT_SCALE,    //! Amount of digits after the decimal point
57: 	EXPONENT_POWER,    //! How many zeros behind the decimal point
58: 	EXPONENT_INFINITY, //! Decimal is INFINITY
59: 	EXPONENT_NAN       //! Decimal is NAN
60: };
61: 
62: struct PyDecimal {
63: 
64: 	struct PyDecimalScaleConverter {
65: 		template <typename T, typename = std::enable_if<std::numeric_limits<T>::is_integer, T>>
66: 		static Value Operation(bool signed_value, vector<uint8_t> &digits, uint8_t width, uint8_t scale) {
67: 			T value = 0;
68: 			for (auto it = digits.begin(); it != digits.end(); it++) {
69: 				value = value * 10 + *it;
70: 			}
71: 			if (signed_value) {
72: 				value = -value;
73: 			}
74: 			return Value::DECIMAL(value, width, scale);
75: 		}
76: 	};
77: 
78: 	struct PyDecimalPowerConverter {
79: 		template <typename T, typename = std::enable_if<std::numeric_limits<T>::is_integer, T>>
80: 		static Value Operation(bool signed_value, vector<uint8_t> &digits, uint8_t width, uint8_t scale) {
81: 			T value = 0;
82: 			for (auto &digit : digits) {
83: 				value = value * 10 + digit;
84: 			}
85: 			D_ASSERT(scale >= 0);
86: 			int64_t multiplier =
87: 			    NumericHelper::POWERS_OF_TEN[MinValue<uint8_t>(scale, NumericHelper::CACHED_POWERS_OF_TEN - 1)];
88: 			for (auto power = scale; power > NumericHelper::CACHED_POWERS_OF_TEN; power--) {
89: 				multiplier *= 10;
90: 			}
91: 			value *= multiplier;
92: 			if (signed_value) {
93: 				value = -value;
94: 			}
95: 			return Value::DECIMAL(value, width, scale);
96: 		}
97: 	};
98: 
99: public:
100: 	PyDecimal(py::handle &obj);
101: 	vector<uint8_t> digits;
102: 	bool signed_value = false;
103: 
104: 	PyDecimalExponentType exponent_type;
105: 	int32_t exponent_value;
106: 
107: public:
108: 	bool TryGetType(LogicalType &type);
109: 	Value ToDuckValue();
110: 
111: private:
112: 	void SetExponent(py::handle &exponent);
113: 	py::handle &obj;
114: };
115: 
116: struct PyTimeDelta {
117: public:
118: 	PyTimeDelta(py::handle &obj);
119: 	int32_t days;
120: 	int32_t seconds;
121: 	int64_t microseconds;
122: 
123: public:
124: 	interval_t ToInterval();
125: 
126: private:
127: 	static int64_t GetDays(py::handle &obj);
128: 	static int64_t GetSeconds(py::handle &obj);
129: 	static int64_t GetMicros(py::handle &obj);
130: };
131: 
132: struct PyTime {
133: public:
134: 	PyTime(py::handle &obj);
135: 	py::handle &obj;
136: 	int32_t hour;
137: 	int32_t minute;
138: 	int32_t second;
139: 	int32_t microsecond;
140: 	py::object timezone_obj;
141: 
142: public:
143: 	dtime_t ToDuckTime();
144: 	Value ToDuckValue();
145: 
146: private:
147: 	static int32_t GetHours(py::handle &obj);
148: 	static int32_t GetMinutes(py::handle &obj);
149: 	static int32_t GetSeconds(py::handle &obj);
150: 	static int32_t GetMicros(py::handle &obj);
151: 	static py::object GetTZInfo(py::handle &obj);
152: };
153: 
154: struct PyDateTime {
155: public:
156: 	PyDateTime(py::handle &obj);
157: 	py::handle &obj;
158: 	int32_t year;
159: 	int32_t month;
160: 	int32_t day;
161: 	int32_t hour;
162: 	int32_t minute;
163: 	int32_t second;
164: 	int32_t micros;
165: 	py::object tzone_obj;
166: 
167: public:
168: 	timestamp_t ToTimestamp();
169: 	date_t ToDate();
170: 	dtime_t ToDuckTime();
171: 	Value ToDuckValue(const LogicalType &target_type);
172: 
173: public:
174: 	static int32_t GetYears(py::handle &obj);
175: 	static int32_t GetMonths(py::handle &obj);
176: 	static int32_t GetDays(py::handle &obj);
177: 	static int32_t GetHours(py::handle &obj);
178: 	static int32_t GetMinutes(py::handle &obj);
179: 	static int32_t GetSeconds(py::handle &obj);
180: 	static int32_t GetMicros(py::handle &obj);
181: 	static py::object GetTZInfo(py::handle &obj);
182: };
183: 
184: struct PyDate {
185: public:
186: 	PyDate(py::handle &ele);
187: 	int32_t year;
188: 	int32_t month;
189: 	int32_t day;
190: 
191: public:
192: 	Value ToDuckValue();
193: };
194: 
195: struct PyTimezone {
196: public:
197: 	PyTimezone() = delete;
198: 
199: public:
200: 	DUCKDB_API static int32_t GetUTCOffsetSeconds(py::handle &tzone_obj);
201: 	DUCKDB_API static interval_t GetUTCOffset(py::handle &tzone_obj);
202: };
203: 
204: struct PythonObject {
205: 	static void Initialize();
206: 	static py::object FromStruct(const Value &value, const LogicalType &id, const ClientProperties &client_properties);
207: 	static py::object FromValue(const Value &value, const LogicalType &id, const ClientProperties &client_properties);
208: };
209: 
210: template <class T>
211: class Optional : public py::object {
212: public:
213: 	Optional(const py::object &o) : py::object(o, borrowed_t {}) {
214: 	}
215: 	using py::object::object;
216: 
217: public:
218: 	static bool check_(const py::handle &object) {
219: 		return object.is_none() || py::isinstance<T>(object);
220: 	}
221: };
222: 
223: class FileLikeObject : public py::object {
224: public:
225: 	FileLikeObject(const py::object &o) : py::object(o, borrowed_t {}) {
226: 	}
227: 	using py::object::object;
228: 
229: public:
230: 	static bool check_(const py::handle &object) {
231: 		return py::isinstance(object, py::module::import("io").attr("IOBase"));
232: 	}
233: };
234: 
235: } // namespace duckdb
236: 
237: namespace pybind11 {
238: namespace detail {
239: template <typename T>
240: struct handle_type_name<duckdb::Optional<T>> {
241: 	static constexpr auto name = const_name("typing.Optional[") + concat(make_caster<T>::name) + const_name("]");
242: };
243: } // namespace detail
244: } // namespace pybind11
[end of tools/pythonpkg/src/include/duckdb_python/python_objects.hpp]
[start of tools/pythonpkg/src/native/python_objects.cpp]
1: #include "duckdb_python/python_objects.hpp"
2: #include "duckdb/common/types.hpp"
3: #include "duckdb/common/types/uuid.hpp"
4: #include "duckdb/common/types/value.hpp"
5: #include "duckdb/common/types/decimal.hpp"
6: #include "duckdb/common/types/bit.hpp"
7: #include "duckdb/common/types/cast_helpers.hpp"
8: #include "duckdb/common/operator/cast_operators.hpp"
9: #include "duckdb_python/pyconnection/pyconnection.hpp"
10: #include "duckdb/common/operator/add.hpp"
11: #include "duckdb/core_functions/to_interval.hpp"
12: 
13: #include "datetime.h" // Python datetime initialize #1
14: 
15: namespace duckdb {
16: 
17: PyDictionary::PyDictionary(py::object dict) {
18: 	keys = py::list(dict.attr("keys")());
19: 	values = py::list(dict.attr("values")());
20: 	len = py::len(keys);
21: 	this->dict = std::move(dict);
22: }
23: 
24: PyTimeDelta::PyTimeDelta(py::handle &obj) {
25: 	days = PyTimeDelta::GetDays(obj);
26: 	seconds = PyTimeDelta::GetSeconds(obj);
27: 	microseconds = PyTimeDelta::GetMicros(obj);
28: }
29: 
30: interval_t PyTimeDelta::ToInterval() {
31: 	interval_t result;
32: 
33: 	auto micros_interval = Interval::FromMicro(microseconds);
34: 	auto days_interval = interval_t {/*months = */ 0,
35: 	                                 /*days = */ days,
36: 	                                 /*micros = */ 0};
37: 	auto seconds_interval = ToSecondsOperator::Operation<int64_t, interval_t>(seconds);
38: 
39: 	result = AddOperator::Operation<interval_t, interval_t, interval_t>(micros_interval, days_interval);
40: 	result = AddOperator::Operation<interval_t, interval_t, interval_t>(result, seconds_interval);
41: 	return result;
42: }
43: 
44: int64_t PyTimeDelta::GetDays(py::handle &obj) {
45: 	return PyDateTime_TIMEDELTA_GET_DAYS(obj.ptr()); // NOLINT
46: }
47: 
48: int64_t PyTimeDelta::GetSeconds(py::handle &obj) {
49: 	return PyDateTime_TIMEDELTA_GET_SECONDS(obj.ptr()); // NOLINT
50: }
51: 
52: int64_t PyTimeDelta::GetMicros(py::handle &obj) {
53: 	return PyDateTime_TIMEDELTA_GET_MICROSECONDS(obj.ptr()); // NOLINT
54: }
55: 
56: PyDecimal::PyDecimal(py::handle &obj) : obj(obj) {
57: 	auto as_tuple = obj.attr("as_tuple")();
58: 
59: 	py::object exponent = as_tuple.attr("exponent");
60: 	SetExponent(exponent);
61: 
62: 	auto sign = py::cast<int8_t>(as_tuple.attr("sign"));
63: 	signed_value = sign != 0;
64: 
65: 	auto decimal_digits = as_tuple.attr("digits");
66: 	auto width = py::len(decimal_digits);
67: 	digits.reserve(width);
68: 	for (auto digit : decimal_digits) {
69: 		digits.push_back(py::cast<uint8_t>(digit));
70: 	}
71: }
72: 
73: bool PyDecimal::TryGetType(LogicalType &type) {
74: 	int32_t width = digits.size();
75: 
76: 	switch (exponent_type) {
77: 	case PyDecimalExponentType::EXPONENT_SCALE: {
78: 	case PyDecimalExponentType::EXPONENT_POWER: {
79: 		auto scale = exponent_value;
80: 		if (exponent_type == PyDecimalExponentType::EXPONENT_POWER) {
81: 			width += scale;
82: 		}
83: 		if (scale > width) {
84: 			// The value starts with 1 or more zeros, which are optimized out of the 'digits' array
85: 			// 0.001; width=1, exponent=-3
86: 			width = scale + 1; // DECIMAL(4,3) - add 1 for the non-decimal values
87: 		}
88: 		if (width > Decimal::MAX_WIDTH_INT128) {
89: 			type = LogicalType::DOUBLE;
90: 			return true;
91: 		}
92: 		type = LogicalType::DECIMAL(width, scale);
93: 		return true;
94: 	}
95: 	case PyDecimalExponentType::EXPONENT_INFINITY: {
96: 		type = LogicalType::FLOAT;
97: 		return true;
98: 	}
99: 	case PyDecimalExponentType::EXPONENT_NAN: {
100: 		type = LogicalType::FLOAT;
101: 		return true;
102: 	}
103: 	default: // LCOV_EXCL_START
104: 		throw NotImplementedException("case not implemented for type PyDecimalExponentType");
105: 	} // LCOV_EXCL_STOP
106: 	}
107: 	return true;
108: }
109: // LCOV_EXCL_START
110: static void ExponentNotRecognized() {
111: 	throw NotImplementedException("Failed to convert decimal.Decimal value, exponent type is unknown");
112: }
113: // LCOV_EXCL_STOP
114: 
115: void PyDecimal::SetExponent(py::handle &exponent) {
116: 	if (py::isinstance<py::int_>(exponent)) {
117: 		this->exponent_value = py::cast<int32_t>(exponent);
118: 		if (this->exponent_value >= 0) {
119: 			exponent_type = PyDecimalExponentType::EXPONENT_POWER;
120: 			return;
121: 		}
122: 		exponent_value *= -1;
123: 		exponent_type = PyDecimalExponentType::EXPONENT_SCALE;
124: 		return;
125: 	}
126: 	if (py::isinstance<py::str>(exponent)) {
127: 		string exponent_string = py::str(exponent);
128: 		if (exponent_string == "n") {
129: 			exponent_type = PyDecimalExponentType::EXPONENT_NAN;
130: 			return;
131: 		}
132: 		if (exponent_string == "F") {
133: 			exponent_type = PyDecimalExponentType::EXPONENT_INFINITY;
134: 			return;
135: 		}
136: 	}
137: 	// LCOV_EXCL_START
138: 	ExponentNotRecognized();
139: 	// LCOV_EXCL_STOP
140: }
141: 
142: static bool WidthFitsInDecimal(int32_t width) {
143: 	return width >= 0 && width <= Decimal::MAX_WIDTH_DECIMAL;
144: }
145: 
146: template <class OP>
147: Value PyDecimalCastSwitch(PyDecimal &decimal, uint8_t width, uint8_t scale) {
148: 	if (width > DecimalWidth<int64_t>::max) {
149: 		return OP::template Operation<hugeint_t>(decimal.signed_value, decimal.digits, width, scale);
150: 	}
151: 	if (width > DecimalWidth<int32_t>::max) {
152: 		return OP::template Operation<int64_t>(decimal.signed_value, decimal.digits, width, scale);
153: 	}
154: 	if (width > DecimalWidth<int16_t>::max) {
155: 		return OP::template Operation<int32_t>(decimal.signed_value, decimal.digits, width, scale);
156: 	}
157: 	return OP::template Operation<int16_t>(decimal.signed_value, decimal.digits, width, scale);
158: }
159: 
160: // Wont fit in a DECIMAL, fall back to DOUBLE
161: static Value CastToDouble(py::handle &obj) {
162: 	string converted = py::str(obj);
163: 	string_t decimal_string(converted);
164: 	double double_val;
165: 	bool try_cast = TryCast::Operation<string_t, double>(decimal_string, double_val, true);
166: 	(void)try_cast;
167: 	D_ASSERT(try_cast);
168: 	return Value::DOUBLE(double_val);
169: }
170: 
171: Value PyDecimal::ToDuckValue() {
172: 	int32_t width = digits.size();
173: 	if (!WidthFitsInDecimal(width)) {
174: 		return CastToDouble(obj);
175: 	}
176: 	switch (exponent_type) {
177: 	case PyDecimalExponentType::EXPONENT_SCALE: {
178: 		uint8_t scale = exponent_value;
179: 		D_ASSERT(WidthFitsInDecimal(width));
180: 		if (scale > width) {
181: 			// Values like '0.001'
182: 			width = scale + 1; // leave 1 room for the non-decimal value
183: 		}
184: 		if (!WidthFitsInDecimal(width)) {
185: 			return CastToDouble(obj);
186: 		}
187: 		return PyDecimalCastSwitch<PyDecimalScaleConverter>(*this, width, scale);
188: 	}
189: 	case PyDecimalExponentType::EXPONENT_POWER: {
190: 		uint8_t scale = exponent_value;
191: 		width += scale;
192: 		if (!WidthFitsInDecimal(width)) {
193: 			return CastToDouble(obj);
194: 		}
195: 		return PyDecimalCastSwitch<PyDecimalPowerConverter>(*this, width, scale);
196: 	}
197: 	case PyDecimalExponentType::EXPONENT_NAN: {
198: 		return Value::FLOAT(NAN);
199: 	}
200: 	case PyDecimalExponentType::EXPONENT_INFINITY: {
201: 		return Value::FLOAT(INFINITY);
202: 	}
203: 	// LCOV_EXCL_START
204: 	default: {
205: 		throw NotImplementedException("case not implemented for type PyDecimalExponentType");
206: 	} // LCOV_EXCL_STOP
207: 	}
208: }
209: 
210: PyTime::PyTime(py::handle &obj) : obj(obj) {
211: 	hour = PyTime::GetHours(obj);          // NOLINT
212: 	minute = PyTime::GetMinutes(obj);      // NOLINT
213: 	second = PyTime::GetSeconds(obj);      // NOLINT
214: 	microsecond = PyTime::GetMicros(obj);  // NOLINT
215: 	timezone_obj = PyTime::GetTZInfo(obj); // NOLINT
216: }
217: dtime_t PyTime::ToDuckTime() {
218: 	return Time::FromTime(hour, minute, second, microsecond);
219: }
220: 
221: Value PyTime::ToDuckValue() {
222: 	auto duckdb_time = this->ToDuckTime();
223: 	if (!py::none().is(this->timezone_obj)) {
224: 		auto seconds = PyTimezone::GetUTCOffsetSeconds(this->timezone_obj);
225: 		return Value::TIMETZ(dtime_tz_t(duckdb_time, seconds));
226: 	}
227: 	return Value::TIME(duckdb_time);
228: }
229: 
230: int32_t PyTime::GetHours(py::handle &obj) {
231: 	return PyDateTime_TIME_GET_HOUR(obj.ptr()); // NOLINT
232: }
233: 
234: int32_t PyTime::GetMinutes(py::handle &obj) {
235: 	return PyDateTime_TIME_GET_MINUTE(obj.ptr()); // NOLINT
236: }
237: 
238: int32_t PyTime::GetSeconds(py::handle &obj) {
239: 	return PyDateTime_TIME_GET_SECOND(obj.ptr()); // NOLINT
240: }
241: 
242: int32_t PyTime::GetMicros(py::handle &obj) {
243: 	return PyDateTime_TIME_GET_MICROSECOND(obj.ptr()); // NOLINT
244: }
245: 
246: py::object PyTime::GetTZInfo(py::handle &obj) {
247: 	// The object returned is borrowed, there is no reference to steal
248: 	return py::reinterpret_borrow<py::object>(PyDateTime_TIME_GET_TZINFO(obj.ptr())); // NOLINT
249: }
250: 
251: interval_t PyTimezone::GetUTCOffset(py::handle &tzone_obj) {
252: 	auto res = tzone_obj.attr("utcoffset")(py::none());
253: 	auto timedelta = PyTimeDelta(res);
254: 	return timedelta.ToInterval();
255: }
256: 
257: int32_t PyTimezone::GetUTCOffsetSeconds(py::handle &tzone_obj) {
258: 	auto res = tzone_obj.attr("utcoffset")(py::none());
259: 	auto timedelta = PyTimeDelta(res);
260: 	if (timedelta.days != 0) {
261: 		throw InvalidInputException(
262: 		    "Failed to convert 'tzinfo' object, utcoffset returned an invalid timedelta (days)");
263: 	}
264: 	if (timedelta.microseconds != 0) {
265: 		throw InvalidInputException(
266: 		    "Failed to convert 'tzinfo' object, utcoffset returned an invalid timedelta (microseconds)");
267: 	}
268: 	return timedelta.seconds;
269: }
270: 
271: PyDateTime::PyDateTime(py::handle &obj) : obj(obj) {
272: 	year = PyDateTime::GetYears(obj);
273: 	month = PyDateTime::GetMonths(obj);
274: 	day = PyDateTime::GetDays(obj);
275: 	hour = PyDateTime::GetHours(obj);
276: 	minute = PyDateTime::GetMinutes(obj);
277: 	second = PyDateTime::GetSeconds(obj);
278: 	micros = PyDateTime::GetMicros(obj);
279: 	tzone_obj = PyDateTime::GetTZInfo(obj);
280: }
281: 
282: timestamp_t PyDateTime::ToTimestamp() {
283: 	auto date = ToDate();
284: 	auto time = ToDuckTime();
285: 	return Timestamp::FromDatetime(date, time);
286: }
287: 
288: Value PyDateTime::ToDuckValue(const LogicalType &target_type) {
289: 	auto timestamp = ToTimestamp();
290: 	if (!py::none().is(tzone_obj)) {
291: 		auto utc_offset = PyTimezone::GetUTCOffset(tzone_obj);
292: 		// Need to subtract the UTC offset, so we invert the interval
293: 		utc_offset = Interval::Invert(utc_offset);
294: 		timestamp = Interval::Add(timestamp, utc_offset);
295: 		return Value::TIMESTAMPTZ(timestamp);
296: 	}
297: 	switch (target_type.id()) {
298: 	case LogicalTypeId::UNKNOWN:
299: 	case LogicalTypeId::TIMESTAMP: {
300: 		return Value::TIMESTAMP(timestamp);
301: 	}
302: 	case LogicalTypeId::TIMESTAMP_SEC:
303: 	case LogicalTypeId::TIMESTAMP_MS:
304: 	case LogicalTypeId::TIMESTAMP_NS:
305: 		// Because the 'Time::FromTime' method constructs a regular (usecond) timestamp, this is not compatible with
306: 		// creating sec/ms/ns timestamps
307: 		throw NotImplementedException("Conversion from 'datetime' to type %s is not implemented yet",
308: 		                              target_type.ToString());
309: 	default:
310: 		throw ConversionException("Could not convert 'datetime' to type %s", target_type.ToString());
311: 	}
312: }
313: 
314: date_t PyDateTime::ToDate() {
315: 	return Date::FromDate(year, month, day);
316: }
317: dtime_t PyDateTime::ToDuckTime() {
318: 	return Time::FromTime(hour, minute, second, micros);
319: }
320: 
321: int32_t PyDateTime::GetYears(py::handle &obj) {
322: 	return PyDateTime_GET_YEAR(obj.ptr()); // NOLINT
323: }
324: 
325: int32_t PyDateTime::GetMonths(py::handle &obj) {
326: 	return PyDateTime_GET_MONTH(obj.ptr()); // NOLINT
327: }
328: 
329: int32_t PyDateTime::GetDays(py::handle &obj) {
330: 	return PyDateTime_GET_DAY(obj.ptr()); // NOLINT
331: }
332: 
333: int32_t PyDateTime::GetHours(py::handle &obj) {
334: 	return PyDateTime_DATE_GET_HOUR(obj.ptr()); // NOLINT
335: }
336: 
337: int32_t PyDateTime::GetMinutes(py::handle &obj) {
338: 	return PyDateTime_DATE_GET_MINUTE(obj.ptr()); // NOLINT
339: }
340: 
341: int32_t PyDateTime::GetSeconds(py::handle &obj) {
342: 	return PyDateTime_DATE_GET_SECOND(obj.ptr()); // NOLINT
343: }
344: 
345: int32_t PyDateTime::GetMicros(py::handle &obj) {
346: 	return PyDateTime_DATE_GET_MICROSECOND(obj.ptr()); // NOLINT
347: }
348: 
349: py::object PyDateTime::GetTZInfo(py::handle &obj) {
350: 	// The object returned is borrowed, there is no reference to steal
351: 	return py::reinterpret_borrow<py::object>(PyDateTime_DATE_GET_TZINFO(obj.ptr())); // NOLINT
352: }
353: 
354: PyDate::PyDate(py::handle &ele) {
355: 	year = PyDateTime::GetYears(ele);
356: 	month = PyDateTime::GetMonths(ele);
357: 	day = PyDateTime::GetDays(ele);
358: }
359: 
360: Value PyDate::ToDuckValue() {
361: 	auto value = Value::DATE(year, month, day);
362: 	return value;
363: }
364: 
365: void PythonObject::Initialize() {
366: 	PyDateTime_IMPORT; // NOLINT: Python datetime initialize #2
367: }
368: 
369: enum class InfinityType : uint8_t { NONE, POSITIVE, NEGATIVE };
370: 
371: InfinityType GetTimestampInfinityType(timestamp_t &timestamp) {
372: 	if (timestamp == timestamp_t::infinity()) {
373: 		return InfinityType::POSITIVE;
374: 	}
375: 	if (timestamp == timestamp_t::ninfinity()) {
376: 		return InfinityType::NEGATIVE;
377: 	}
378: 	return InfinityType::NONE;
379: }
380: 
381: py::object PythonObject::FromStruct(const Value &val, const LogicalType &type,
382:                                     const ClientProperties &client_properties) {
383: 	auto &struct_values = StructValue::GetChildren(val);
384: 
385: 	auto &child_types = StructType::GetChildTypes(type);
386: 	if (StructType::IsUnnamed(type)) {
387: 		py::tuple py_tuple(struct_values.size());
388: 		for (idx_t i = 0; i < struct_values.size(); i++) {
389: 			auto &child_entry = child_types[i];
390: 			D_ASSERT(child_entry.first.empty());
391: 			auto &child_type = child_entry.second;
392: 			py_tuple[i] = FromValue(struct_values[i], child_type, client_properties);
393: 		}
394: 		return std::move(py_tuple);
395: 	} else {
396: 		py::dict py_struct;
397: 		for (idx_t i = 0; i < struct_values.size(); i++) {
398: 			auto &child_entry = child_types[i];
399: 			auto &child_name = child_entry.first;
400: 			auto &child_type = child_entry.second;
401: 			py_struct[child_name.c_str()] = FromValue(struct_values[i], child_type, client_properties);
402: 		}
403: 		return std::move(py_struct);
404: 	}
405: }
406: 
407: py::object PythonObject::FromValue(const Value &val, const LogicalType &type,
408:                                    const ClientProperties &client_properties) {
409: 	auto &import_cache = *DuckDBPyConnection::ImportCache();
410: 	if (val.IsNull()) {
411: 		return py::none();
412: 	}
413: 	switch (type.id()) {
414: 	case LogicalTypeId::BOOLEAN:
415: 		return py::cast(val.GetValue<bool>());
416: 	case LogicalTypeId::TINYINT:
417: 		return py::cast(val.GetValue<int8_t>());
418: 	case LogicalTypeId::SMALLINT:
419: 		return py::cast(val.GetValue<int16_t>());
420: 	case LogicalTypeId::INTEGER:
421: 		return py::cast(val.GetValue<int32_t>());
422: 	case LogicalTypeId::BIGINT:
423: 		return py::cast(val.GetValue<int64_t>());
424: 	case LogicalTypeId::UTINYINT:
425: 		return py::cast(val.GetValue<uint8_t>());
426: 	case LogicalTypeId::USMALLINT:
427: 		return py::cast(val.GetValue<uint16_t>());
428: 	case LogicalTypeId::UINTEGER:
429: 		return py::cast(val.GetValue<uint32_t>());
430: 	case LogicalTypeId::UBIGINT:
431: 		return py::cast(val.GetValue<uint64_t>());
432: 	case LogicalTypeId::HUGEINT:
433: 		return py::reinterpret_steal<py::object>(PyLong_FromString(val.GetValue<string>().c_str(), nullptr, 10));
434: 	case LogicalTypeId::UHUGEINT:
435: 		return py::reinterpret_steal<py::object>(PyLong_FromString(val.GetValue<string>().c_str(), nullptr, 10));
436: 	case LogicalTypeId::FLOAT:
437: 		return py::cast(val.GetValue<float>());
438: 	case LogicalTypeId::DOUBLE:
439: 		return py::cast(val.GetValue<double>());
440: 	case LogicalTypeId::DECIMAL: {
441: 		return import_cache.decimal.Decimal()(val.ToString());
442: 	}
443: 	case LogicalTypeId::ENUM:
444: 		return py::cast(EnumType::GetValue(val));
445: 	case LogicalTypeId::UNION: {
446: 		return PythonObject::FromValue(UnionValue::GetValue(val), UnionValue::GetType(val), client_properties);
447: 	}
448: 	case LogicalTypeId::VARCHAR:
449: 		return py::cast(StringValue::Get(val));
450: 	case LogicalTypeId::BLOB:
451: 		return py::bytes(StringValue::Get(val));
452: 	case LogicalTypeId::BIT:
453: 		return py::cast(Bit::ToString(StringValue::Get(val)));
454: 	case LogicalTypeId::TIMESTAMP:
455: 	case LogicalTypeId::TIMESTAMP_MS:
456: 	case LogicalTypeId::TIMESTAMP_NS:
457: 	case LogicalTypeId::TIMESTAMP_SEC:
458: 	case LogicalTypeId::TIMESTAMP_TZ: {
459: 		D_ASSERT(type.InternalType() == PhysicalType::INT64);
460: 		auto timestamp = val.GetValueUnsafe<timestamp_t>();
461: 
462: 		InfinityType infinity = GetTimestampInfinityType(timestamp);
463: 		if (infinity == InfinityType::POSITIVE) {
464: 			return py::reinterpret_borrow<py::object>(import_cache.datetime.datetime.max());
465: 		}
466: 		if (infinity == InfinityType::NEGATIVE) {
467: 			return py::reinterpret_borrow<py::object>(import_cache.datetime.datetime.min());
468: 		}
469: 
470: 		if (type.id() == LogicalTypeId::TIMESTAMP_MS) {
471: 			timestamp = Timestamp::FromEpochMs(timestamp.value);
472: 		} else if (type.id() == LogicalTypeId::TIMESTAMP_NS) {
473: 			timestamp = Timestamp::FromEpochNanoSeconds(timestamp.value);
474: 		} else if (type.id() == LogicalTypeId::TIMESTAMP_SEC) {
475: 			timestamp = Timestamp::FromEpochSeconds(timestamp.value);
476: 		}
477: 
478: 		int32_t year, month, day, hour, min, sec, micros;
479: 		date_t date;
480: 		dtime_t time;
481: 		Timestamp::Convert(timestamp, date, time);
482: 		Date::Convert(date, year, month, day);
483: 		Time::Convert(time, hour, min, sec, micros);
484: 		py::object py_timestamp;
485: 		try {
486: 			auto python_conversion = PyDateTime_FromDateAndTime(year, month, day, hour, min, sec, micros);
487: 			if (!python_conversion) {
488: 				throw py::error_already_set();
489: 			}
490: 			py_timestamp = py::reinterpret_steal<py::object>(python_conversion);
491: 		} catch (py::error_already_set &e) {
492: 			// Failed to convert, fall back to str
493: 			return py::str(val.ToString());
494: 		}
495: 		if (type.id() == LogicalTypeId::TIMESTAMP_TZ) {
496: 			// We have to add the timezone info
497: 			auto tz_utc = import_cache.pytz.timezone()("UTC");
498: 			auto timestamp_utc = tz_utc.attr("localize")(py_timestamp);
499: 			auto tz_info = import_cache.pytz.timezone()(client_properties.time_zone);
500: 			return timestamp_utc.attr("astimezone")(tz_info);
501: 		}
502: 		return py_timestamp;
503: 	}
504: 	case LogicalTypeId::TIME_TZ: {
505: 		D_ASSERT(type.InternalType() == PhysicalType::INT64);
506: 		int32_t hour, min, sec, microsec;
507: 		auto time_tz = val.GetValueUnsafe<dtime_tz_t>();
508: 		auto time = time_tz.time();
509: 		auto offset = time_tz.offset();
510: 		duckdb::Time::Convert(time, hour, min, sec, microsec);
511: 		py::object py_time;
512: 		try {
513: 			auto python_conversion = PyTime_FromTime(hour, min, sec, microsec);
514: 			if (!python_conversion) {
515: 				throw py::error_already_set();
516: 			}
517: 			py_time = py::reinterpret_steal<py::object>(python_conversion);
518: 		} catch (py::error_already_set &e) {
519: 			// Failed to convert, fall back to str
520: 			return py::str(val.ToString());
521: 		}
522: 		// We have to add the timezone info
523: 		auto timedelta = import_cache.datetime.timedelta()(py::arg("seconds") = offset);
524: 		auto timezone_offset = import_cache.datetime.timezone()(timedelta);
525: 		auto tmp_datetime = import_cache.datetime.datetime.min();
526: 		auto tmp_datetime_with_tz = import_cache.datetime.datetime.combine()(tmp_datetime, py_time, timezone_offset);
527: 		return tmp_datetime_with_tz.attr("timetz")();
528: 	}
529: 	case LogicalTypeId::TIME: {
530: 		D_ASSERT(type.InternalType() == PhysicalType::INT64);
531: 		int32_t hour, min, sec, microsec;
532: 		auto time = val.GetValueUnsafe<dtime_t>();
533: 		duckdb::Time::Convert(time, hour, min, sec, microsec);
534: 		try {
535: 			auto pytime = PyTime_FromTime(hour, min, sec, microsec);
536: 			if (!pytime) {
537: 				throw py::error_already_set();
538: 			}
539: 			return py::reinterpret_steal<py::object>(pytime);
540: 		} catch (py::error_already_set &e) {
541: 			return py::str(val.ToString());
542: 		}
543: 	}
544: 	case LogicalTypeId::DATE: {
545: 		D_ASSERT(type.InternalType() == PhysicalType::INT32);
546: 		auto date = val.GetValueUnsafe<date_t>();
547: 		int32_t year, month, day;
548: 		if (!duckdb::Date::IsFinite(date)) {
549: 			if (date == date_t::infinity()) {
550: 				return py::reinterpret_borrow<py::object>(import_cache.datetime.date.max());
551: 			}
552: 			return py::reinterpret_borrow<py::object>(import_cache.datetime.date.min());
553: 		}
554: 		duckdb::Date::Convert(date, year, month, day);
555: 		try {
556: 			auto pydate = PyDate_FromDate(year, month, day);
557: 			if (!pydate) {
558: 				throw py::error_already_set();
559: 			}
560: 			return py::reinterpret_steal<py::object>(pydate);
561: 		} catch (py::error_already_set &e) {
562: 			return py::str(val.ToString());
563: 		}
564: 	}
565: 	case LogicalTypeId::LIST: {
566: 		auto &list_values = ListValue::GetChildren(val);
567: 
568: 		py::list list;
569: 		for (auto &list_elem : list_values) {
570: 			list.append(FromValue(list_elem, ListType::GetChildType(type), client_properties));
571: 		}
572: 		return std::move(list);
573: 	}
574: 	case LogicalTypeId::ARRAY: {
575: 		auto &array_values = ArrayValue::GetChildren(val);
576: 		auto array_size = ArrayType::GetSize(type);
577: 		auto &child_type = ArrayType::GetChildType(type);
578: 
579: 		// do not remove the static cast here, it's required for building
580: 		// duckdb-python with Emscripten.
581: 		//
582: 		// without this cast, a static_assert fails in pybind11
583: 		// because the return type of ArrayType::GetSize is idx_t,
584: 		// which is typedef'd to uint64_t and ssize_t is 4 bytes with Emscripten
585: 		// and pybind11 requires that the input be castable to ssize_t
586: 		py::tuple arr(static_cast<py::ssize_t>(array_size));
587: 
588: 		for (idx_t elem_idx = 0; elem_idx < array_size; elem_idx++) {
589: 			arr[elem_idx] = FromValue(array_values[elem_idx], child_type, client_properties);
590: 		}
591: 		return std::move(arr);
592: 	}
593: 	case LogicalTypeId::MAP: {
594: 		auto &list_values = ListValue::GetChildren(val);
595: 
596: 		auto &key_type = MapType::KeyType(type);
597: 		auto &val_type = MapType::ValueType(type);
598: 
599: 		py::list keys;
600: 		py::list values;
601: 		for (auto &list_elem : list_values) {
602: 			auto &struct_children = StructValue::GetChildren(list_elem);
603: 			keys.append(PythonObject::FromValue(struct_children[0], key_type, client_properties));
604: 			values.append(PythonObject::FromValue(struct_children[1], val_type, client_properties));
605: 		}
606: 		py::dict py_struct;
607: 		py_struct["key"] = std::move(keys);
608: 		py_struct["value"] = std::move(values);
609: 		return std::move(py_struct);
610: 	}
611: 	case LogicalTypeId::STRUCT: {
612: 		return FromStruct(val, type, client_properties);
613: 	}
614: 	case LogicalTypeId::UUID: {
615: 		auto uuid_value = val.GetValueUnsafe<hugeint_t>();
616: 		return import_cache.uuid.UUID()(UUID::ToString(uuid_value));
617: 	}
618: 	case LogicalTypeId::INTERVAL: {
619: 		auto interval_value = val.GetValueUnsafe<interval_t>();
620: 		int64_t days = duckdb::Interval::DAYS_PER_MONTH * interval_value.months + interval_value.days;
621: 		return import_cache.datetime.timedelta()(py::arg("days") = days,
622: 		                                         py::arg("microseconds") = interval_value.micros);
623: 	}
624: 
625: 	default:
626: 		throw NotImplementedException("Unsupported type: \"%s\"", type.ToString());
627: 	}
628: }
629: 
630: } // namespace duckdb
[end of tools/pythonpkg/src/native/python_objects.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: