{
  "repo": "duckdb/duckdb",
  "pull_number": 12356,
  "instance_id": "duckdb__duckdb-12356",
  "issue_numbers": [
    "12330"
  ],
  "base_commit": "e92b3b13a1cf3aea9962453d155c188bdf11ed25",
  "patch": "diff --git a/extension/fts/fts_indexing.cpp b/extension/fts/fts_indexing.cpp\nindex 0673dcef0bda..c098f194901c 100644\n--- a/extension/fts/fts_indexing.cpp\n+++ b/extension/fts/fts_indexing.cpp\n@@ -191,7 +191,7 @@ static string IndexingScript(ClientContext &context, QualifiedName &qname, const\n                        term_tf.termid,\n                        tf,\n                        df,\n-                       (log(((SELECT num_docs FROM %fts_schema%.stats) - df + 0.5) / (df + 0.5))* ((tf * (k + 1)/(tf + k * (1 - b + b * (len / (SELECT avgdl FROM %fts_schema%.stats))))))) AS subscore\n+                       (log(((SELECT num_docs FROM %fts_schema%.stats) - df + 0.5) / (df + 0.5) + 1) * ((tf * (k + 1)/(tf + k * (1 - b + b * (len / (SELECT avgdl FROM %fts_schema%.stats))))))) AS subscore\n                 FROM term_tf,\n \t\t\t\t\t cdocs,\n \t\t\t\t\t %fts_schema%.docs AS docs,\n",
  "test_patch": "diff --git a/test/sql/fts/issue_12330.test b/test/sql/fts/issue_12330.test\nnew file mode 100644\nindex 000000000000..60433e1bc943\n--- /dev/null\n+++ b/test/sql/fts/issue_12330.test\n@@ -0,0 +1,34 @@\n+# name: test/sql/fts/issue_12330.test\n+# description: Issue 12330: BM25 matching scores seems to be invalid\n+# group: [fts]\n+\n+# issue #7384 and #8141\n+\n+require fts\n+\n+statement ok\n+CREATE OR REPLACE TABLE documents (\n+    id VARCHAR,\n+    content VARCHAR\n+);\n+\n+statement ok\n+INSERT INTO documents VALUES\n+    ('doc1', 'DuckDB database lorem'),\n+    ('doc2', 'DuckDB database ipsum'),\n+    ('doc3', 'DuckDB database ipsum dolor');\n+\n+statement ok\n+PRAGMA create_fts_index('documents', 'id', 'content');\n+\n+query I\n+SELECT\n+    id\n+FROM\n+    documents\n+ORDER BY\n+    fts_main_documents.match_bm25(id, 'DuckDB database ipsum') DESC;\n+----\n+doc2\n+doc3\n+doc1\ndiff --git a/test/sql/fts/test_indexing.test_slow b/test/sql/fts/test_indexing.test_slow\nindex bc99f0e02983..7ff6928d1a93 100644\n--- a/test/sql/fts/test_indexing.test_slow\n+++ b/test/sql/fts/test_indexing.test_slow\n@@ -135,8 +135,8 @@ doc1\t0.36835264087244074\n query III\n SELECT score, id, body FROM (SELECT *, fts_main_documents.match_bm25(id, 'quacked barked') AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n ----\n-0.37543634550460314\tdoc2\t B\u00c1RKING+B\u00c1RKING+B\u00c1RKING+B\u00c1RKING\n-0.3683526408724408\tdoc1\t QU\u00c1CKING+QU\u00c1CKING+QU\u00c1CKING\n+0.7208701623069375\tdoc2\t B\u00c1RKING+B\u00c1RKING+B\u00c1RKING+B\u00c1RKING\n+0.7072688384898254\tdoc1\t QU\u00c1CKING+QU\u00c1CKING+QU\u00c1CKING\n \n # drop and re-create, but index both the 'body' and 'author' column this time\n statement ok\ndiff --git a/test/sql/fts/test_issue_10254.test b/test/sql/fts/test_issue_10254.test\nindex 0d5cd0cef1b1..fd149745a10a 100644\n--- a/test/sql/fts/test_issue_10254.test\n+++ b/test/sql/fts/test_issue_10254.test\n@@ -21,5 +21,5 @@ PRAGMA create_fts_index('data', 'id', 'context', 'question', stemmer='russian',\n query I\n SELECT id FROM (SELECT *, fts_main_data.match_bm25(id, '\u041a\u0430\u043a\u0438\u0435') AS score FROM data) sq WHERE score IS NOT NULL ORDER BY score DESC;\n ----\n-1\n 0\n+1\n",
  "problem_statement": "BM25 matching scores seems to be invalid\n### What happens?\r\n\r\nResult table ordering based on BM25 scores seems to be incorrect. Scores can be even negative if search query contains terms that are very common among searched documents.\r\n\r\n### To Reproduce\r\n\r\n```\r\nINSTALL fts;\r\nLOAD fts;\r\n\r\nCREATE OR REPLACE TABLE documents (\r\n    id VARCHAR,\r\n    content VARCHAR\r\n);\r\n\r\nINSERT INTO documents VALUES \r\n    ('doc1', 'DuckDB database lorem'), \r\n    ('doc2', 'DuckDB database ipsum'), \r\n    ('doc3', 'DuckDB database ipsum');\r\n\r\nPRAGMA create_fts_index('documents', 'id', 'content');\r\n\r\nSELECT \r\n    id,\r\n    fts_main_documents.match_bm25(id, 'DuckDB') score_DuckDB,\r\n    fts_main_documents.match_bm25(id, 'DuckDB database') score_DuckDB_Database,\r\n    fts_main_documents.match_bm25(id, 'DuckDB database lorem') score_DuckDB_Database_lorem,\r\n    fts_main_documents.match_bm25(id, 'lorem') score_lorem,\r\n    fts_main_documents.match_bm25(id, 'DuckDB database ipsum') score_DuckDB_Database_ipsum,\r\nFROM \r\n    documents;\r\n```\r\nGives following result table:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   id    \u2502    score_DuckDB     \u2502 score_DuckDB_Database \u2502 score_DuckDB_Database_lorem \u2502     score_lorem     \u2502 score_DuckDB_Database_ipsum \u2502\r\n\u2502 varchar \u2502       double        \u2502        double         \u2502           double            \u2502       double        \u2502           double            \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 doc1    \u2502 -0.8450980400142569 \u2502   -1.6901960800285138 \u2502         -1.4683473304121575 \u2502 0.22184874961635637 \u2502         -1.6901960800285138 \u2502\r\n\u2502 doc2    \u2502 -0.8450980400142569 \u2502   -1.6901960800285138 \u2502         -1.6901960800285138 \u2502                     \u2502         -1.9120448296448702 \u2502\r\n\u2502 doc3    \u2502 -0.8450980400142569 \u2502   -1.6901960800285138 \u2502         -1.6901960800285138 \u2502                     \u2502         -1.9120448296448702 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\nHigher score means better match. You can notice that scores are counter intuitive. E.g. \r\n1. (Edit, Improved example): Query 'DuckDB database ipsum' (score_DuckDB_Database_ipsum) matches perfectly with documents doc2 and doc3, but clearly worse doc1 gets better score\r\n2. (older, more unclear example) search query 'DuckDB database lorem' is equal to doc1 content, but it gets lower score (score_DuckDB_Database_lorem: -0.8450980400142569) than only partially matching query 'lorem' (score_lorem: 0.22184874961635637).\r\n\r\nI've identified a potential issue in the formula used to calculate the BM25 scores, specifically in the IDF component. It appears that there is a critical omission in the logarithmic term of the IDF calculation. According to the [BM25 formula referenced on Wikipedia](https://en.wikipedia.org/wiki/Okapi_BM25), the logarithmic function should include an increment by 1 to prevent values below 1 inside the logarithm.\r\n\r\nThe issue occurs in[ line 194 of the code](https://github.com/duckdb/duckdb/blob/d4a8e042dfbe152fc9e22b351373c5f8b681a152/extension/fts/fts_indexing.cpp#L152C9-L215C6), where the IDF part of the formula is calculated as follows:\r\n```sql\r\nlog(((SELECT num_docs FROM %fts_schema%.stats) - df + 0.5) / (df + 0.5))\r\n```\r\nTo align with the standard BM25 formula and ensure the log function operates within a valid range, the formula should be modified to:\r\n```sql\r\nlog(((SELECT num_docs FROM %fts_schema%.stats) - df + 0.5) / (df + 0.5) + 1)\r\n```\r\nWithout this adjustment, the log input can fall within the range [0,1], where the logarithm would yield negative values, potentially leading to incorrect scoring results.\r\n\r\nI was working with PR, but I'm not sure which implementation of BM25 is wanted. There are at least two ways to fix IDF part:\r\n1. Use \"Wikipedia\" version of IDF as described above or\r\n2. Extend current version with special cases to avoid negative IDF. See [page 4 from Arxiv paper](https://arxiv.org/pdf/1602.03606). Paper gives formula: \r\n![image](https://github.com/duckdb/duckdb/assets/24547559/72ed008c-ddcf-46ad-8e2c-8fd4aa194289)\r\n\r\nI haven't checked very carefully if these are valid fixes to issue, but testing with fix 1 seems to give improved ordering:\r\n```\r\nINSTALL fts;\r\nLOAD fts;\r\n\r\nCREATE OR REPLACE TABLE documents (\r\n    id VARCHAR,\r\n    content VARCHAR\r\n);\r\n\r\nINSERT INTO documents VALUES \r\n    ('doc1', 'DuckDB database lorem'), \r\n    ('doc2', 'DuckDB database ipsum'), \r\n    ('doc3', 'DuckDB database ipsum');\r\n\r\nPRAGMA create_fts_index('documents', 'id', 'content');\r\n\r\n--PATCH: assuming that adding +1 to log(((SELECT num_docs FROM fts_main_documents.stats) - df + 0.5) / (df + 0.5) + 1) is the fix\r\n--                                                                                                                ---\r\nCREATE OR REPLACE MACRO fts_main_documents.match_bm25(docname, query_string, fields := NULL, k := 1.2, b := 0.75, conjunctive := 0) AS (\r\n            WITH tokens AS (\r\n                SELECT DISTINCT stem(unnest(fts_main_documents.tokenize(query_string)), 'english') AS t\r\n            ),\r\n            fieldids AS (\r\n                SELECT fieldid\r\n                FROM fts_main_documents.fields\r\n                WHERE CASE WHEN fields IS NULL THEN 1 ELSE field IN (SELECT * FROM (SELECT UNNEST(string_split(fields, ','))) AS fsq) END\r\n            ),\r\n            qtermids AS (\r\n                SELECT termid\r\n                FROM fts_main_documents.dict AS dict,\r\n                     tokens\r\n                WHERE dict.term = tokens.t\r\n            ),\r\n            qterms AS (\r\n                SELECT termid,\r\n                       docid\r\n                FROM fts_main_documents.terms AS terms\r\n                WHERE CASE WHEN fields IS NULL THEN 1 ELSE fieldid IN (SELECT * FROM fieldids) END\r\n                  AND termid IN (SELECT qtermids.termid FROM qtermids)\r\n            ),\r\n\t\t\tterm_tf AS (\r\n\t\t\t\tSELECT termid,\r\n\t\t\t\t   \t   docid,\r\n                       COUNT(*) AS tf\r\n\t\t\t\tFROM qterms\r\n\t\t\t\tGROUP BY docid,\r\n\t\t\t\t\t\t termid\r\n\t\t\t),\r\n\t\t\tcdocs AS (\r\n\t\t\t\tSELECT docid\r\n\t\t\t\tFROM qterms\r\n\t\t\t\tGROUP BY docid\r\n\t\t\t\tHAVING CASE WHEN conjunctive THEN COUNT(DISTINCT termid) = (SELECT COUNT(*) FROM tokens) ELSE 1 END\r\n\t\t\t),\r\n            subscores AS (\r\n                SELECT docs.docid,\r\n                       len,\r\n                       term_tf.termid,\r\n                       tf,\r\n                       df,\r\n                       (log(((SELECT num_docs FROM fts_main_documents.stats) - df + 0.5) / (df + 0.5) + 1)* ((tf * (k + 1)/(tf + k * (1 - b + b * (len / (SELECT avgdl FROM fts_main_documents.stats))))))) AS subscore\r\n                FROM term_tf,\r\n\t\t\t\t\t cdocs,\r\n\t\t\t\t\t fts_main_documents.docs AS docs,\r\n\t\t\t\t\t fts_main_documents.dict AS dict\r\n\t\t\t\tWHERE term_tf.docid = cdocs.docid\r\n\t\t\t\t  AND term_tf.docid = docs.docid\r\n                  AND term_tf.termid = dict.termid\r\n            ),\r\n\t\t\tscores AS (\r\n\t\t\t\tSELECT docid,\r\n\t\t\t\t\t   sum(subscore) AS score\r\n\t\t\t\tFROM subscores\r\n\t\t\t\tGROUP BY docid\r\n\t\t\t)\r\n            SELECT score\r\n            FROM scores,\r\n\t\t\t\t fts_main_documents.docs AS docs\r\n            WHERE scores.docid = docs.docid\r\n              AND docs.name = docname\r\n        );\r\n\r\nSELECT \r\n    id,\r\n    fts_main_documents.match_bm25(id, 'DuckDB') score_DuckDB,\r\n    fts_main_documents.match_bm25(id, 'DuckDB database') score_DuckDB_Database,\r\n    fts_main_documents.match_bm25(id, 'DuckDB database lorem') score_DuckDB_Database_lorem,\r\n    fts_main_documents.match_bm25(id, 'lorem') score_lorem,\r\n    fts_main_documents.match_bm25(id, 'DuckDB database ipsum') score_DuckDB_Database_ipsum,\r\nFROM \r\n    documents;\r\n```\r\nGives following result table:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   id    \u2502    score_DuckDB     \u2502 score_DuckDB_Database \u2502 score_DuckDB_Database_lorem \u2502     score_lorem     \u2502 score_DuckDB_Database_ipsum \u2502\r\n\u2502 varchar \u2502       double        \u2502        double         \u2502           double            \u2502       double        \u2502           double            \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 doc1    \u2502 0.05799194697768673 \u2502   0.11598389395537347 \u2502          0.5419526262276546 \u2502 0.42596873227228116 \u2502         0.11598389395537347 \u2502\r\n\u2502 doc2    \u2502 0.05799194697768673 \u2502   0.11598389395537347 \u2502         0.11598389395537347 \u2502                     \u2502          0.3201038766112983 \u2502\r\n\u2502 doc3    \u2502 0.05799194697768673 \u2502   0.11598389395537347 \u2502         0.11598389395537347 \u2502                     \u2502          0.3201038766112983 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nAnalysing result table after patch:\r\n1. (Edit, Improved example): Query 'DuckDB database ipsum' (score_DuckDB_Database_ipsum) matches perfectly with documents doc2 and doc3 and scores are better for these documents than doc1\r\n2. (older, more unclear example) Now search query 'DuckDB database lorem' is equal to doc1 content, and gets higher score (score_DuckDB_Database_lorem:0.5419526262276546) than only partially matching query 'lorem' (score_lorem: 0.42596873227228116). \r\n3. Also all scores are positive.\r\n\r\nPlease let me know if further details are needed or if I can assist in any other way.\r\n\r\n### OS:\r\n\r\nUbuntu\r\n\r\n### DuckDB Version:\r\n\r\n0.10.3\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nJaakko Routamaa\r\n\r\n### Affiliation:\r\n\r\n-\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a nightly build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [ ] Yes, I have\n",
  "hints_text": "I added improved example of buggy behavior. Now consequences of incorrect score formula should be more apparent: documents are in wrong order.",
  "created_at": "2024-06-03T07:36:53Z"
}