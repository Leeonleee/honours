{
  "repo": "duckdb/duckdb",
  "pull_number": 12367,
  "instance_id": "duckdb__duckdb-12367",
  "issue_numbers": [
    "12293"
  ],
  "base_commit": "0a542716d9da018b230e91ba55fb15b710a1639b",
  "patch": "diff --git a/src/function/table/range.cpp b/src/function/table/range.cpp\nindex ebc1f0bc204c..e55676c6d22a 100644\n--- a/src/function/table/range.cpp\n+++ b/src/function/table/range.cpp\n@@ -157,44 +157,54 @@ static unique_ptr<FunctionData> RangeDateTimeBind(ClientContext &context, TableF\n \tauto result = make_uniq<RangeDateTimeBindData>();\n \tauto &inputs = input.inputs;\n \tD_ASSERT(inputs.size() == 3);\n+\tbool input_is_null = false;\n \tfor (idx_t i = 0; i < inputs.size(); ++i) {\n \t\tif (inputs[i].IsNull()) {\n-\t\t\tthrow BinderException(\"RANGE with NULL argument is not supported\");\n+\t\t\tinput_is_null = true;\n+\t\t\tbreak;\n \t\t}\n \t}\n-\tresult->start = inputs[0].GetValue<timestamp_t>();\n-\tresult->end = inputs[1].GetValue<timestamp_t>();\n-\tresult->increment = inputs[2].GetValue<interval_t>();\n-\n-\t// Infinities either cause errors or infinite loops, so just ban them\n-\tif (!Timestamp::IsFinite(result->start) || !Timestamp::IsFinite(result->end)) {\n-\t\tthrow BinderException(\"RANGE with infinite bounds is not supported\");\n-\t}\n+\tif (input_is_null) {\n+\t\t// if any inputs are NULL we return the empty set\n+\t\tresult->start = 0;\n+\t\tresult->end = 0;\n+\t\tresult->increment = interval_t();\n+\t\tresult->inclusive_bound = false;\n+\t} else {\n+\t\tresult->start = inputs[0].GetValue<timestamp_t>();\n+\t\tresult->end = inputs[1].GetValue<timestamp_t>();\n+\t\tresult->increment = inputs[2].GetValue<interval_t>();\n \n-\tif (result->increment.months == 0 && result->increment.days == 0 && result->increment.micros == 0) {\n-\t\tthrow BinderException(\"interval cannot be 0!\");\n-\t}\n-\t// all elements should point in the same direction\n-\tif (result->increment.months > 0 || result->increment.days > 0 || result->increment.micros > 0) {\n-\t\tif (result->increment.months < 0 || result->increment.days < 0 || result->increment.micros < 0) {\n-\t\t\tthrow BinderException(\"RANGE with composite interval that has mixed signs is not supported\");\n+\t\t// Infinities either cause errors or infinite loops, so just ban them\n+\t\tif (!Timestamp::IsFinite(result->start) || !Timestamp::IsFinite(result->end)) {\n+\t\t\tthrow BinderException(\"RANGE with infinite bounds is not supported\");\n \t\t}\n-\t\tresult->greater_than_check = true;\n-\t\tif (result->start > result->end) {\n-\t\t\tthrow BinderException(\n-\t\t\t    \"start is bigger than end, but increment is positive: cannot generate infinite series\");\n+\n+\t\tif (result->increment.months == 0 && result->increment.days == 0 && result->increment.micros == 0) {\n+\t\t\tthrow BinderException(\"interval cannot be 0!\");\n \t\t}\n-\t} else {\n-\t\tresult->greater_than_check = false;\n-\t\tif (result->start < result->end) {\n-\t\t\tthrow BinderException(\n-\t\t\t    \"start is smaller than end, but increment is negative: cannot generate infinite series\");\n+\t\t// all elements should point in the same direction\n+\t\tif (result->increment.months > 0 || result->increment.days > 0 || result->increment.micros > 0) {\n+\t\t\tif (result->increment.months < 0 || result->increment.days < 0 || result->increment.micros < 0) {\n+\t\t\t\tthrow BinderException(\"RANGE with composite interval that has mixed signs is not supported\");\n+\t\t\t}\n+\t\t\tresult->greater_than_check = true;\n+\t\t\tif (result->start > result->end) {\n+\t\t\t\tthrow BinderException(\n+\t\t\t\t    \"start is bigger than end, but increment is positive: cannot generate infinite series\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\tresult->greater_than_check = false;\n+\t\t\tif (result->start < result->end) {\n+\t\t\t\tthrow BinderException(\n+\t\t\t\t    \"start is smaller than end, but increment is negative: cannot generate infinite series\");\n+\t\t\t}\n \t\t}\n \t}\n \treturn_types.push_back(inputs[0].type());\n \tif (GENERATE_SERIES) {\n \t\t// generate_series has inclusive bounds on the RHS\n-\t\tresult->inclusive_bound = true;\n+\t\tresult->inclusive_bound = !input_is_null;\n \t\tnames.emplace_back(\"generate_series\");\n \t} else {\n \t\tresult->inclusive_bound = false;\n",
  "test_patch": "diff --git a/test/api/test_get_table_names.cpp b/test/api/test_get_table_names.cpp\nindex 9abe4b890752..59a73dd64759 100644\n--- a/test/api/test_get_table_names.cpp\n+++ b/test/api/test_get_table_names.cpp\n@@ -90,6 +90,11 @@ TEST_CASE(\"Test GetTableNames\", \"[api]\") {\n \tREQUIRE(table_names.size() == 1);\n \tREQUIRE(table_names.count(\"df\"));\n \n+\t// generate_series\n+\ttable_names = con.GetTableNames(\"with series_generator as (select * from generate_series(TIMESTAMP '2001-04-10', \"\n+\t                                \"TIMESTAMP '2001-04-11', INTERVAL 1 HOUR)) select * from series_generator\");\n+\tREQUIRE(table_names.empty());\n+\n \tif (!db.ExtensionIsLoaded(\"tpch\")) {\n \t\treturn;\n \t}\ndiff --git a/test/fuzzer/duckfuzz/generate_null_timestamp.test b/test/fuzzer/duckfuzz/generate_null_timestamp.test\nindex d3546fe5311d..d2b7125dad4f 100644\n--- a/test/fuzzer/duckfuzz/generate_null_timestamp.test\n+++ b/test/fuzzer/duckfuzz/generate_null_timestamp.test\n@@ -5,8 +5,7 @@\n statement ok\n PRAGMA enable_verification\n \n-statement error\n+query I\n SELECT NULL \n FROM generate_series(CAST('294247-01-10 04:00:54.775806' AS TIMESTAMP), NULL, NULL) AS t3(c1, c2)\n ----\n-RANGE with NULL argument is not supported\ndiff --git a/test/sql/table_function/range_timestamp.test b/test/sql/table_function/range_timestamp.test\nindex 5bdcfb19bf04..103b97e7aeec 100644\n--- a/test/sql/table_function/range_timestamp.test\n+++ b/test/sql/table_function/range_timestamp.test\n@@ -115,6 +115,17 @@ SELECT COUNT(*) FROM generate_series(TIMESTAMP '1992-01-01 00:00:00', TIMESTAMP\n ----\n 10228\n \n+# null values result in no rows\n+query I\n+SELECT COUNT(*) FROM range(NULL, TIMESTAMP '1992-12-31 12:00:00', INTERVAL '1 MONTH') tbl(d)\n+----\n+0\n+\n+query I\n+SELECT COUNT(*) FROM generate_series(NULL, TIMESTAMP '1992-12-31 12:00:00', INTERVAL '1 MONTH') tbl(d)\n+----\n+0\n+\n # zero interval not supported\n statement error\n SELECT d FROM range(TIMESTAMP '1992-01-01 00:00:00', TIMESTAMP '1992-12-31 12:00:00', INTERVAL '0 MONTH') tbl(d)\n",
  "problem_statement": "`get_table_names` erroring on query using `generate_series` in CTE, but executes it without issue\n### What happens?\r\n\r\nI've encountered a relatively simple query which uses `generate_series` in a CTE which can be executed just fine, but trying to call `get_table_names` on it yields the error:\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/Users/dscott/Hex/duckdb-repro/repro.py\", line 13, in <module>\r\n    print(conn.get_table_names(query))\r\n  File \"/Users/dscott/Hex/duckdb-repro/repro.py\", line 13, in <module>\r\n    print(conn.get_table_names(query))\r\nduckdb.duckdb.BinderException: Binder Error: RANGE with NULL argument is not supported\r\n```\r\n\r\nOn older versions (0.8.1) the error is slightly different, and more fatal as subsequent queries against the same connection error and report \"The database must be restarted prior to being used again.\"\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/Users/dscott/Hex/duckdb-repro/repro.py\", line 13, in <module>\r\n    print(conn.get_table_names(query))\r\n  File \"/Users/dscott/Hex/duckdb-repro/repro.py\", line 13, in <module>\r\n    print(conn.get_table_names(query))\r\nduckdb.InternalException: INTERNAL Error: Calling GetValueInternal on a value that is NULL\r\n```\r\n\r\n### To Reproduce\r\n\r\nHere's a minimal reproduction:\r\n\r\n```python\r\nimport duckdb\r\n\r\nquery = \"\"\"\r\nwith series_generator as (\r\n   select * from generate_series(TIMESTAMP '2001-04-10', TIMESTAMP '2001-04-11', INTERVAL 1 HOUR)\r\n)\r\nselect * from series_generator\r\n\"\"\"\r\n\r\nwith duckdb.execute(query) as conn:\r\n    print(conn.fetchdf())\r\n\r\n    print(conn.get_table_names(query))\r\n```\r\n\r\n### OS:\r\n\r\nmacOS Sonoma aarch64, Linux x86_64\r\n\r\n### DuckDB Version:\r\n\r\n0.8.1, 0.10.3, 0.10.4.dev72\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nDylan Scott\r\n\r\n### Affiliation:\r\n\r\nHex Technologies\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a nightly build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-06-04T08:37:38Z"
}