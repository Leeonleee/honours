{
  "repo": "duckdb/duckdb",
  "pull_number": 7876,
  "instance_id": "duckdb__duckdb-7876",
  "issue_numbers": [
    "7773"
  ],
  "base_commit": "f198a863cacc778d9c3bacd2cdaac0acda31d173",
  "patch": "diff --git a/tools/pythonpkg/duckdb-stubs/__init__.pyi b/tools/pythonpkg/duckdb-stubs/__init__.pyi\nindex 892c2d3d2de1..46d0328e0a4c 100644\n--- a/tools/pythonpkg/duckdb-stubs/__init__.pyi\n+++ b/tools/pythonpkg/duckdb-stubs/__init__.pyi\n@@ -187,7 +187,8 @@ class DuckDBPyConnection:\n         return_type: Optional[DuckDBPyType],\n         vectorized: Optional[bool] = False,\n         null_handling: Optional[FunctionNullHandling] = FunctionNullHandling.DEFAULT,\n-        exception_handling: Optional[PythonExceptionHandling] = PythonExceptionHandling.DEFAULT) -> DuckDBPyConnection: ...\n+        exception_handling: Optional[PythonExceptionHandling] = PythonExceptionHandling.DEFAULT,\n+        side_effects: Optional[bool] = False)  -> DuckDBPyConnection: ...\n     def register_filesystem(self, filesystem: fsspec.AbstractFileSystem) -> None: ...\n     def rollback(self) -> DuckDBPyConnection: ...\n     def sql(self, query: str, alias: str = ...) -> DuckDBPyRelation: ...\n@@ -538,6 +539,7 @@ def create_function(\n     vectorized: Optional[bool] = False,\n     null_handling: Optional[FunctionNullHandling] = FunctionNullHandling.DEFAULT,\n     exception_handling: Optional[PythonExceptionHandling] = PythonExceptionHandling.DEFAULT,\n+    side_effects: Optional[bool] = False,\n     connection: DuckDBPyConnection = ...) -> DuckDBPyConnection: ...\n def register_filesystem(filesystem: fsspec.AbstractFileSystem, connection: DuckDBPyConnection = ...) -> None: ...\n def rollback(connection: DuckDBPyConnection = ...) -> DuckDBPyConnection: ...\ndiff --git a/tools/pythonpkg/duckdb_python.cpp b/tools/pythonpkg/duckdb_python.cpp\nindex afd8e441bbca..505fd890a9b8 100644\n--- a/tools/pythonpkg/duckdb_python.cpp\n+++ b/tools/pythonpkg/duckdb_python.cpp\n@@ -76,7 +76,7 @@ static void InitializeConnectionMethods(py::module_ &m) {\n \t      \"Create a DuckDB function out of the passing in python function so it can be used in queries\",\n \t      py::arg(\"name\"), py::arg(\"function\"), py::arg(\"return_type\") = py::none(), py::arg(\"parameters\") = py::none(),\n \t      py::kw_only(), py::arg(\"type\") = PythonUDFType::NATIVE, py::arg(\"null_handling\") = 0,\n-\t      py::arg(\"exception_handling\") = 0, py::arg(\"connection\") = py::none());\n+\t      py::arg(\"exception_handling\") = 0, py::arg(\"side_effects\") = false, py::arg(\"connection\") = py::none());\n \n \tm.def(\"remove_function\", &PyConnectionWrapper::UnregisterUDF, \"Remove a previously created function\",\n \t      py::arg(\"name\"), py::arg(\"connection\") = py::none());\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp b/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\nindex 288a7dc5eb6a..43f1ea410494 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\n@@ -35,7 +35,7 @@ class PyConnectionWrapper {\n \t                  const shared_ptr<DuckDBPyType> &return_type = nullptr, PythonUDFType type = PythonUDFType::NATIVE,\n \t                  FunctionNullHandling null_handling = FunctionNullHandling::DEFAULT_NULL_HANDLING,\n \t                  PythonExceptionHandling exception_handling = PythonExceptionHandling::FORWARD_ERROR,\n-\t                  shared_ptr<DuckDBPyConnection> conn = nullptr);\n+\t                  bool side_effects = false, shared_ptr<DuckDBPyConnection> conn = nullptr);\n \n \tstatic shared_ptr<DuckDBPyConnection> UnregisterUDF(const string &name,\n \t                                                    shared_ptr<DuckDBPyConnection> conn = nullptr);\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\nindex 6fedab943a76..b6c2533a934f 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n@@ -100,7 +100,8 @@ struct DuckDBPyConnection : public std::enable_shared_from_this<DuckDBPyConnecti\n \tRegisterScalarUDF(const string &name, const py::function &udf, const py::object &arguments = py::none(),\n \t                  const shared_ptr<DuckDBPyType> &return_type = nullptr, PythonUDFType type = PythonUDFType::NATIVE,\n \t                  FunctionNullHandling null_handling = FunctionNullHandling::DEFAULT_NULL_HANDLING,\n-\t                  PythonExceptionHandling exception_handling = PythonExceptionHandling::FORWARD_ERROR);\n+\t                  PythonExceptionHandling exception_handling = PythonExceptionHandling::FORWARD_ERROR,\n+\t                  bool side_effects = false);\n \n \tshared_ptr<DuckDBPyConnection> UnregisterUDF(const string &name);\n \n@@ -214,7 +215,8 @@ struct DuckDBPyConnection : public std::enable_shared_from_this<DuckDBPyConnecti\n \tunique_lock<std::mutex> AcquireConnectionLock();\n \tScalarFunction CreateScalarUDF(const string &name, const py::function &udf, const py::object &parameters,\n \t                               const shared_ptr<DuckDBPyType> &return_type, bool vectorized,\n-\t                               FunctionNullHandling null_handling, PythonExceptionHandling exception_handling);\n+\t                               FunctionNullHandling null_handling, PythonExceptionHandling exception_handling,\n+\t                               bool side_effects);\n \tvoid RegisterArrowObject(const py::object &arrow_object, const string &name);\n \n \tstatic PythonEnvironmentType environment;\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 97c107717ef7..ba12876e6961 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -122,7 +122,7 @@ static void InitializeConnectionMethods(py::class_<DuckDBPyConnection, shared_pt\n \t      \"Create a DuckDB function out of the passing in python function so it can be used in queries\",\n \t      py::arg(\"name\"), py::arg(\"function\"), py::arg(\"return_type\") = py::none(), py::arg(\"parameters\") = py::none(),\n \t      py::kw_only(), py::arg(\"type\") = PythonUDFType::NATIVE, py::arg(\"null_handling\") = 0,\n-\t      py::arg(\"exception_handling\") = 0);\n+\t      py::arg(\"exception_handling\") = 0, py::arg(\"side_effects\") = false);\n \n \tm.def(\"remove_function\", &DuckDBPyConnection::UnregisterUDF, \"Remove a previously created function\",\n \t      py::arg(\"name\"));\n@@ -327,7 +327,8 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::UnregisterUDF(const string &n\n shared_ptr<DuckDBPyConnection>\n DuckDBPyConnection::RegisterScalarUDF(const string &name, const py::function &udf, const py::object &parameters_p,\n                                       const shared_ptr<DuckDBPyType> &return_type_p, PythonUDFType type,\n-                                      FunctionNullHandling null_handling, PythonExceptionHandling exception_handling) {\n+                                      FunctionNullHandling null_handling, PythonExceptionHandling exception_handling,\n+                                      bool side_effects) {\n \tif (!connection) {\n \t\tthrow ConnectionException(\"Connection already closed!\");\n \t}\n@@ -339,7 +340,7 @@ DuckDBPyConnection::RegisterScalarUDF(const string &name, const py::function &ud\n \t\t                              name);\n \t}\n \tauto scalar_function = CreateScalarUDF(name, udf, parameters_p, return_type_p, type == PythonUDFType::ARROW,\n-\t                                       null_handling, exception_handling);\n+\t                                       null_handling, exception_handling, side_effects);\n \tCreateScalarFunctionInfo info(scalar_function);\n \n \tcontext.RegisterFunction(info);\ndiff --git a/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp b/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\nindex 4ddef4c77342..6e645b4225d4 100644\n--- a/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\n+++ b/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\n@@ -106,8 +106,9 @@ shared_ptr<DuckDBPyConnection>\n PyConnectionWrapper::RegisterScalarUDF(const string &name, const py::function &udf, const py::object &parameters_p,\n                                        const shared_ptr<DuckDBPyType> &return_type_p, PythonUDFType type,\n                                        FunctionNullHandling null_handling, PythonExceptionHandling exception_handling,\n-                                       shared_ptr<DuckDBPyConnection> conn) {\n-\treturn conn->RegisterScalarUDF(name, udf, parameters_p, return_type_p, type, null_handling, exception_handling);\n+                                       bool side_effects, shared_ptr<DuckDBPyConnection> conn) {\n+\treturn conn->RegisterScalarUDF(name, udf, parameters_p, return_type_p, type, null_handling, exception_handling,\n+\t                               side_effects);\n }\n \n shared_ptr<DuckDBPyConnection> PyConnectionWrapper::Append(const string &name, PandasDataFrame value, bool by_name,\ndiff --git a/tools/pythonpkg/src/python_udf.cpp b/tools/pythonpkg/src/python_udf.cpp\nindex b5039946b9c2..0d3734ec807a 100644\n--- a/tools/pythonpkg/src/python_udf.cpp\n+++ b/tools/pythonpkg/src/python_udf.cpp\n@@ -197,7 +197,7 @@ static scalar_function_t CreateNativeFunction(PyObject *function, PythonExceptio\n \t\t// Cast the resulting native python to DuckDB, using the return type\n \t\t// result.Resize(input.size());\n \t\tNumpyScan::ScanObjectColumn(python_results.data(), input.size(), 0, result);\n-\t\tif (input.AllConstant()) {\n+\t\tif (input.size() == 1) {\n \t\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n \t\t}\n \t};\n@@ -312,15 +312,17 @@ struct PythonUDFData {\n \t\t}\n \t}\n \n-\tScalarFunction GetFunction(const py::function &udf, PythonExceptionHandling exception_handling) {\n+\tScalarFunction GetFunction(const py::function &udf, PythonExceptionHandling exception_handling, bool side_effects) {\n \t\tscalar_function_t func;\n \t\tif (vectorized) {\n \t\t\tfunc = CreateVectorizedFunction(udf.ptr(), exception_handling);\n \t\t} else {\n \t\t\tfunc = CreateNativeFunction(udf.ptr(), exception_handling);\n \t\t}\n+\t\tFunctionSideEffects function_side_effects =\n+\t\t    side_effects ? FunctionSideEffects::HAS_SIDE_EFFECTS : FunctionSideEffects::NO_SIDE_EFFECTS;\n \t\tScalarFunction scalar_function(name, std::move(parameters), return_type, func, nullptr, nullptr, nullptr,\n-\t\t                               nullptr, varargs, FunctionSideEffects::NO_SIDE_EFFECTS, null_handling);\n+\t\t                               nullptr, varargs, function_side_effects, null_handling);\n \t\treturn scalar_function;\n \t}\n };\n@@ -331,7 +333,7 @@ ScalarFunction DuckDBPyConnection::CreateScalarUDF(const string &name, const py:\n                                                    const py::object &parameters,\n                                                    const shared_ptr<DuckDBPyType> &return_type, bool vectorized,\n                                                    FunctionNullHandling null_handling,\n-                                                   PythonExceptionHandling exception_handling) {\n+                                                   PythonExceptionHandling exception_handling, bool side_effects) {\n \tPythonUDFData data(name, vectorized, null_handling);\n \n \tdata.AnalyzeSignature(udf);\n@@ -339,7 +341,7 @@ ScalarFunction DuckDBPyConnection::CreateScalarUDF(const string &name, const py:\n \tdata.OverrideReturnType(return_type);\n \tdata.Verify();\n \n-\treturn data.GetFunction(udf, exception_handling);\n+\treturn data.GetFunction(udf, exception_handling, side_effects);\n }\n \n } // namespace duckdb\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/udf/test_scalar.py b/tools/pythonpkg/tests/fast/udf/test_scalar.py\nindex 504ecca9ab62..6259182e1c96 100644\n--- a/tools/pythonpkg/tests/fast/udf/test_scalar.py\n+++ b/tools/pythonpkg/tests/fast/udf/test_scalar.py\n@@ -182,6 +182,24 @@ def return_pd_nan():\n         res = con.sql('select return_pd_nan()').fetchall()\n         assert res[0][0] == None\n \n+    def test_side_effects(self):\n+        def count() -> int:\n+            old = count.counter;\n+            count.counter += 1\n+            return old\n+        count.counter = 0\n+\n+        con = duckdb.connect()\n+        con.create_function('my_counter', count, side_effects=False)\n+        res = con.sql('select my_counter() from range(10)').fetchall()\n+        assert res == [(0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,)]\n+\n+        count.counter = 0\n+        con.remove_function('my_counter')\n+        con.create_function('my_counter', count, side_effects=True)\n+        res = con.sql('select my_counter() from range(10)').fetchall()\n+        assert res == [(0,), (1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,)]\n+\n     @pytest.mark.parametrize('udf_type', [\n         'arrow',\n         'native'\n",
  "problem_statement": "Scalar UDFs assume Idempotency?\n### What happens?\n\nWhen using the Scalar Functions [PR7171](https://github.com/duckdb/duckdb/pull/7171), the same values are returned for the same inputs. \r\n\r\nIf by design, then this should be clearly documented, but it seems more like a bug or unintended consequence of another optimization. \n\n### To Reproduce\n\n```\r\nimport duckdb\r\nfrom duckdb.typing import *\r\nfrom faker import Faker\r\ndef random_date():\r\n\tfake = Faker()\r\n\treturn fake.date_between()\r\nduckdb.create_function('random_date', random_date, [], DATE)\r\nres = duckdb.sql('select random_date() from range(10)').fetchall()\r\nprint(res)\r\n```\r\nreturns the same date, repeated 10 times: \r\n> [(datetime.date(2012, 7, 10),), (datetime.date(2012, 7, 10),), (datetime.date(2012, 7, 10),), (datetime.date(2012, 7, 10),), (datetime.date(2012, 7, 10),), (datetime.date(2012, 7, 10),), (datetime.date(2012, 7, 10),), (datetime.date(2012, 7, 10),), (datetime.date(2012, 7, 10),), (datetime.date(2012, 7, 10),)]\r\n\r\n#### Using a parameter to ensure different results for each pass:\r\n\r\nModifying the function to take an incrementing int returns the expected result:\r\n```\r\nimport duckdb\r\nfrom duckdb.typing import *\r\nfrom faker import Faker\r\ndef random_date(x):\r\n\tfake = Faker()\r\n\treturn fake.date_between()\r\nduckdb.create_function('random_date2', random_date, [BIGINT], DATE)\r\nres = duckdb.sql('select random_date2(x) from range(10) t(x)').fetchall()\r\nprint(res)\r\n```\r\n> [(datetime.date(2012, 3, 21),), (datetime.date(2009, 2, 28),), (datetime.date(2021, 11, 16),), (datetime.date(2008, 12, 17),), (datetime.date(2011, 11, 26),), (datetime.date(2017, 7, 24),), (datetime.date(2014, 12, 7),), (datetime.date(1994, 2, 8),), (datetime.date(2014, 1, 17),), (datetime.date(1999, 6, 23),)]\r\n\n\n### OS:\n\nWindows\n\n### DuckDB Version:\n\n0.8.1-dev194\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nP Timmins\n\n### Affiliation:\n\nIqmo\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Yea I also ran into this, it's because of constant folding.\n\nWe likely need another option to indicate side-effects for the function so it doesn't get optimized into a single constant\nI looked into it a little bit, but even with FunctionSideEffects::HAS_SIDE_EFFECTS and disable_optimizer it still gets folded somehow.\r\nSo this requires some fixing in core\nFYI, for what other dbs do:\n\nMySQL uses Deterministic/Not Deterministic flags in their declarations: https://dev.mysql.com/doc/refman/8.0/en/create-procedure.html\n\nPostgres uses volatile: https://www.postgresql.org/docs/current/xfunc-volatility.html",
  "created_at": "2023-06-08T11:03:18Z"
}