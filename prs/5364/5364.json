{
  "repo": "duckdb/duckdb",
  "pull_number": 5364,
  "instance_id": "duckdb__duckdb-5364",
  "issue_numbers": [
    "5312"
  ],
  "base_commit": "3ffcbaf5a501593c96a9bc1e19c3aecb794f4b79",
  "patch": "diff --git a/src/common/types/hugeint.cpp b/src/common/types/hugeint.cpp\nindex 64f85e86b56b..c7b99a6c2d8c 100644\n--- a/src/common/types/hugeint.cpp\n+++ b/src/common/types/hugeint.cpp\n@@ -4,6 +4,7 @@\n #include \"duckdb/common/limits.hpp\"\n #include \"duckdb/common/windows_undefs.hpp\"\n #include \"duckdb/common/types/value.hpp\"\n+#include \"duckdb/common/operator/cast_operators.hpp\"\n \n #include <cmath>\n #include <limits>\n@@ -499,6 +500,13 @@ bool Hugeint::TryConvert(int8_t value, hugeint_t &result) {\n \treturn true;\n }\n \n+template <>\n+bool Hugeint::TryConvert(const char *value, hugeint_t &result) {\n+\tauto len = strlen(value);\n+\tstring_t string_val(value, len);\n+\treturn TryCast::Operation<string_t, hugeint_t>(string_val, result, true);\n+}\n+\n template <>\n bool Hugeint::TryConvert(int16_t value, hugeint_t &result) {\n \tresult = HugeintConvertInteger<int16_t>(value);\ndiff --git a/src/include/duckdb/common/types/hugeint.hpp b/src/include/duckdb/common/types/hugeint.hpp\nindex c7a5f2cabc76..590b8516d82a 100644\n--- a/src/include/duckdb/common/types/hugeint.hpp\n+++ b/src/include/duckdb/common/types/hugeint.hpp\n@@ -157,5 +157,7 @@ template <>\n bool Hugeint::TryConvert(double value, hugeint_t &result);\n template <>\n bool Hugeint::TryConvert(long double value, hugeint_t &result);\n+template <>\n+bool Hugeint::TryConvert(const char *value, hugeint_t &result);\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/main/appender.hpp b/src/include/duckdb/main/appender.hpp\nindex f38ee51684ff..48f77e5b922f 100644\n--- a/src/include/duckdb/main/appender.hpp\n+++ b/src/include/duckdb/main/appender.hpp\n@@ -20,6 +20,11 @@ class DuckDB;\n class TableCatalogEntry;\n class Connection;\n \n+enum class AppenderType : uint8_t {\n+\tLOGICAL, // Cast input -> LogicalType\n+\tPHYSICAL // Cast input -> PhysicalType\n+};\n+\n //! The Appender class can be used to append elements to a table.\n class BaseAppender {\n protected:\n@@ -35,10 +40,14 @@ class BaseAppender {\n \tDataChunk chunk;\n \t//! The current column to append to\n \tidx_t column = 0;\n+\t//! The type of the appender\n+\tAppenderType appender_type;\n+\n+protected:\n+\tDUCKDB_API BaseAppender(Allocator &allocator, AppenderType type);\n+\tDUCKDB_API BaseAppender(Allocator &allocator, vector<LogicalType> types, AppenderType type);\n \n public:\n-\tDUCKDB_API BaseAppender(Allocator &allocator);\n-\tDUCKDB_API BaseAppender(Allocator &allocator, vector<LogicalType> types);\n \tDUCKDB_API virtual ~BaseAppender();\n \n \t//! Begins a new row append, after calling this the other AppendX() functions\n@@ -86,6 +95,8 @@ class BaseAppender {\n \tvoid AppendValueInternal(T value);\n \ttemplate <class SRC, class DST>\n \tvoid AppendValueInternal(Vector &vector, SRC input);\n+\ttemplate <class SRC, class DST>\n+\tvoid AppendDecimalValueInternal(Vector &vector, SRC input);\n \n \tvoid AppendRowRecursive() {\n \t\tEndRow();\ndiff --git a/src/main/appender.cpp b/src/main/appender.cpp\nindex 26693ec654a4..207bcbd45f8b 100644\n--- a/src/main/appender.cpp\n+++ b/src/main/appender.cpp\n@@ -10,15 +10,17 @@\n #include \"duckdb/common/operator/cast_operators.hpp\"\n #include \"duckdb/common/operator/string_cast.hpp\"\n #include \"duckdb/common/types/column_data_collection.hpp\"\n+#include \"duckdb/common/operator/decimal_cast_operators.hpp\"\n \n namespace duckdb {\n \n-BaseAppender::BaseAppender(Allocator &allocator) : allocator(allocator), column(0) {\n+BaseAppender::BaseAppender(Allocator &allocator, AppenderType type_p)\n+    : allocator(allocator), column(0), appender_type(type_p) {\n }\n \n-BaseAppender::BaseAppender(Allocator &allocator_p, vector<LogicalType> types_p)\n+BaseAppender::BaseAppender(Allocator &allocator_p, vector<LogicalType> types_p, AppenderType type_p)\n     : allocator(allocator_p), types(move(types_p)), collection(make_unique<ColumnDataCollection>(allocator, types)),\n-      column(0) {\n+      column(0), appender_type(type_p) {\n \tInitializeChunk();\n }\n \n@@ -38,7 +40,8 @@ void BaseAppender::Destructor() {\n }\n \n InternalAppender::InternalAppender(ClientContext &context_p, TableCatalogEntry &table_p)\n-    : BaseAppender(Allocator::DefaultAllocator(), table_p.GetTypes()), context(context_p), table(table_p) {\n+    : BaseAppender(Allocator::DefaultAllocator(), table_p.GetTypes(), AppenderType::PHYSICAL), context(context_p),\n+      table(table_p) {\n }\n \n InternalAppender::~InternalAppender() {\n@@ -46,7 +49,7 @@ InternalAppender::~InternalAppender() {\n }\n \n Appender::Appender(Connection &con, const string &schema_name, const string &table_name)\n-    : BaseAppender(Allocator::DefaultAllocator()), context(con.context) {\n+    : BaseAppender(Allocator::DefaultAllocator(), AppenderType::LOGICAL), context(con.context) {\n \tdescription = con.TableInfo(schema_name, table_name);\n \tif (!description) {\n \t\t// table could not be found\n@@ -90,6 +93,27 @@ void BaseAppender::AppendValueInternal(Vector &col, SRC input) {\n \tFlatVector::GetData<DST>(col)[chunk.size()] = Cast::Operation<SRC, DST>(input);\n }\n \n+template <class SRC, class DST>\n+void BaseAppender::AppendDecimalValueInternal(Vector &col, SRC input) {\n+\tswitch (appender_type) {\n+\tcase AppenderType::LOGICAL: {\n+\t\tauto &type = col.GetType();\n+\t\tD_ASSERT(type.id() == LogicalTypeId::DECIMAL);\n+\t\tauto width = DecimalType::GetWidth(type);\n+\t\tauto scale = DecimalType::GetScale(type);\n+\t\tTryCastToDecimal::Operation<SRC, DST>(input, FlatVector::GetData<DST>(col)[chunk.size()], nullptr, width,\n+\t\t                                      scale);\n+\t\treturn;\n+\t}\n+\tcase AppenderType::PHYSICAL: {\n+\t\tAppendValueInternal<SRC, DST>(col, input);\n+\t\treturn;\n+\t}\n+\tdefault:\n+\t\tthrow InternalException(\"Type not implemented for AppenderType\");\n+\t}\n+}\n+\n template <class T>\n void BaseAppender::AppendValueInternal(T input) {\n \tif (column >= types.size()) {\n@@ -135,18 +159,20 @@ void BaseAppender::AppendValueInternal(T input) {\n \t\tbreak;\n \tcase LogicalTypeId::DECIMAL:\n \t\tswitch (col.GetType().InternalType()) {\n-\t\tcase PhysicalType::INT8:\n-\t\t\tAppendValueInternal<T, int8_t>(col, input);\n-\t\t\tbreak;\n \t\tcase PhysicalType::INT16:\n-\t\t\tAppendValueInternal<T, int16_t>(col, input);\n+\t\t\tAppendDecimalValueInternal<T, int16_t>(col, input);\n \t\t\tbreak;\n \t\tcase PhysicalType::INT32:\n-\t\t\tAppendValueInternal<T, int32_t>(col, input);\n+\t\t\tAppendDecimalValueInternal<T, int32_t>(col, input);\n \t\t\tbreak;\n-\t\tdefault:\n-\t\t\tAppendValueInternal<T, int64_t>(col, input);\n+\t\tcase PhysicalType::INT64:\n+\t\t\tAppendDecimalValueInternal<T, int64_t>(col, input);\n+\t\t\tbreak;\n+\t\tcase PhysicalType::INT128:\n+\t\t\tAppendDecimalValueInternal<T, hugeint_t>(col, input);\n \t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow InternalException(\"Internal type not recognized for Decimal\");\n \t\t}\n \t\tbreak;\n \tcase LogicalTypeId::DATE:\n",
  "test_patch": "diff --git a/test/api/capi/test_capi_appender.cpp b/test/api/capi/test_capi_appender.cpp\nindex 23eab8d02b61..a91af16bc7f0 100644\n--- a/test/api/capi/test_capi_appender.cpp\n+++ b/test/api/capi/test_capi_appender.cpp\n@@ -4,6 +4,90 @@\n using namespace duckdb;\n using namespace std;\n \n+void AssertDecimalValueMatches(unique_ptr<CAPIResult> &result, duckdb_decimal expected) {\n+\tduckdb_decimal actual;\n+\n+\tactual = result->Fetch<duckdb_decimal>(0, 0);\n+\tREQUIRE(actual.scale == expected.scale);\n+\tREQUIRE(actual.width == expected.width);\n+\tREQUIRE(actual.value.lower == expected.value.lower);\n+\tREQUIRE(actual.value.upper == expected.value.upper);\n+}\n+\n+template <class TYPE, duckdb_state APPEND_FUNC(duckdb_appender, TYPE)>\n+void TestAppendingSingleDecimalValue(TYPE value, duckdb_decimal expected, uint8_t width, uint8_t scale) {\n+\t// Set the width and scale of the expected value\n+\texpected.width = width;\n+\texpected.scale = scale;\n+\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\tduckdb_state status;\n+\n+\t// open the database in in-memory mode\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\n+\ttester.Query(StringUtil::Format(\"CREATE TABLE decimals(i DECIMAL(%d,%d))\", width, scale));\n+\n+\tduckdb_appender appender;\n+\tstatus = duckdb_appender_create(tester.connection, nullptr, \"decimals\", &appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_begin_row(appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = APPEND_FUNC(appender, value);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_end_row(appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_appender_flush(appender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tresult = tester.Query(\"SELECT * FROM decimals\");\n+\tAssertDecimalValueMatches(result, expected);\n+\n+\tduckdb_appender_close(appender);\n+\tduckdb_appender_destroy(&appender);\n+}\n+\n+TEST_CASE(\"Test appending into DECIMAL in C API\", \"[capi]\") {\n+\tduckdb_decimal expected;\n+\n+\texpected.value.lower = 1000;\n+\texpected.value.upper = 0;\n+\tTestAppendingSingleDecimalValue<int32_t, &duckdb_append_int32>(1, expected, 4, 3);\n+\texpected.value.lower = (uint64_t)18446744073709541617UL;\n+\texpected.value.upper = -1;\n+\tTestAppendingSingleDecimalValue<int16_t, &duckdb_append_int16>(-9999, expected, 4, 0);\n+\texpected.value.lower = 9999;\n+\texpected.value.upper = 0;\n+\tTestAppendingSingleDecimalValue<int16_t, &duckdb_append_int16>(9999, expected, 4, 0);\n+\texpected.value.lower = 99999999;\n+\texpected.value.upper = 0;\n+\tTestAppendingSingleDecimalValue<int32_t, &duckdb_append_int32>(99999999, expected, 8, 0);\n+\texpected.value.lower = 1234;\n+\texpected.value.upper = 0;\n+\tTestAppendingSingleDecimalValue<const char *, &duckdb_append_varchar>(\"1.234\", expected, 4, 3);\n+\tTestAppendingSingleDecimalValue<const char *, &duckdb_append_varchar>(\"123.4\", expected, 4, 1);\n+\n+\texpected.value.lower = 3245234123123;\n+\texpected.value.upper = 0;\n+\tTestAppendingSingleDecimalValue<const char *, &duckdb_append_varchar>(\"3245234.123123\", expected, 19, 6);\n+\tTestAppendingSingleDecimalValue<const char *, &duckdb_append_varchar>(\"3245234.123123\", expected, 13, 6);\n+\t// Precision loss\n+\texpected.value.lower = 123124320;\n+\texpected.value.upper = 0;\n+\tTestAppendingSingleDecimalValue<float, &duckdb_append_float>(12.3124324f, expected, 9, 7);\n+\n+\t// Precision loss\n+\texpected.value.lower = 123452342343;\n+\texpected.value.upper = 0;\n+\tTestAppendingSingleDecimalValue<double, &duckdb_append_double>(12345234234.31243244234324, expected, 26, 1);\n+}\n+\n TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n \tCAPITester tester;\n \tunique_ptr<CAPIResult> result;\ndiff --git a/test/api/test_appender_api.cpp b/test/api/test_appender_api.cpp\nindex d49304f3b6b3..9d5fcccbc44c 100644\n--- a/test/api/test_appender_api.cpp\n+++ b/test/api/test_appender_api.cpp\n@@ -1,10 +1,54 @@\n #include \"catch.hpp\"\n #include \"test_helpers.hpp\"\n #include \"duckdb/main/appender.hpp\"\n+#include \"duckdb/common/types/hugeint.hpp\"\n \n using namespace duckdb;\n using namespace std;\n \n+template <class SRC>\n+void TestAppendingSingleDecimalValue(SRC value, Value expected_result, uint8_t width, uint8_t scale) {\n+\tauto db = make_unique<DuckDB>(nullptr);\n+\tauto conn = make_unique<Connection>(*db);\n+\tunique_ptr<Appender> appender;\n+\tunique_ptr<QueryResult> result;\n+\tREQUIRE_NO_FAIL(conn->Query(StringUtil::Format(\"CREATE TABLE decimals(i DECIMAL(%d,%d))\", width, scale)));\n+\tappender = make_unique<Appender>(*conn, \"decimals\");\n+\n+\tappender->BeginRow();\n+\tappender->Append<SRC>(value);\n+\tappender->EndRow();\n+\n+\tappender->Flush();\n+\n+\tresult = conn->Query(\"SELECT * FROM decimals\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {expected_result}));\n+}\n+\n+TEST_CASE(\"Test appending to a decimal column\", \"[api]\") {\n+\tTestAppendingSingleDecimalValue<int32_t>(1, Value::DECIMAL(1000, 4, 3), 4, 3);\n+\tTestAppendingSingleDecimalValue<int16_t>(-9999, Value::DECIMAL(-9999, 4, 0), 4, 0);\n+\tTestAppendingSingleDecimalValue<int16_t>(9999, Value::DECIMAL(9999, 4, 0), 4, 0);\n+\tTestAppendingSingleDecimalValue<int32_t>(99999999, Value::DECIMAL(99999999, 8, 0), 8, 0);\n+\tTestAppendingSingleDecimalValue<const char *>(\"1.234\", Value::DECIMAL(1234, 4, 3), 4, 3);\n+\tTestAppendingSingleDecimalValue<const char *>(\"123.4\", Value::DECIMAL(1234, 4, 1), 4, 1);\n+\thugeint_t hugeint_value;\n+\tbool result;\n+\tresult = Hugeint::TryConvert<const char *>(\"3245234123123\", hugeint_value);\n+\tREQUIRE(result);\n+\tTestAppendingSingleDecimalValue<const char *>(\"3245234.123123\", Value::DECIMAL(hugeint_value, 19, 6), 19, 6);\n+\tint64_t bigint_reference_value = 3245234123123;\n+\tTestAppendingSingleDecimalValue<const char *>(\"3245234.123123\", Value::DECIMAL(bigint_reference_value, 13, 6), 13,\n+\t                                              6);\n+\t// Precision loss\n+\tTestAppendingSingleDecimalValue<float>(12.3124324f, Value::DECIMAL(123124320, 9, 7), 9, 7);\n+\n+\t// Precision loss\n+\tresult = Hugeint::TryConvert<const char *>(\"12345234234312432287744000\", hugeint_value);\n+\tREQUIRE(result);\n+\tTestAppendingSingleDecimalValue<double>(12345234234.31243244234324, Value::DECIMAL(hugeint_value, 26, 15), 26, 15);\n+}\n+\n TEST_CASE(\"Test using appender after connection is gone\", \"[api]\") {\n \tauto db = make_unique<DuckDB>(nullptr);\n \tauto conn = make_unique<Connection>(*db);\n",
  "problem_statement": "[C-API] Appending decimal values doesn't work as expected\n### What happens?\r\n\r\nWhile extending my Common Lisp bindings for DuckDB with support for appenders I've [noticed](https://github.com/ak-coram/cl-duckdb/pull/7) that appending decimal values works differently from binding them as parameter values for a statement.\r\n\r\nNone of the append functions (varchar, floating point, integer) seem to fully work for decimals as expected, but appending as varchar seems to be in the worst shape as it appends garbage values which can be different even for the same input.\r\n\r\n### To Reproduce\r\n\r\n``` C\r\n#include <stdio.h>\r\n#include <duckdb.h>\r\n\r\nint main () {\r\n\r\n  duckdb_database db;\r\n  duckdb_connection con;\r\n\r\n  duckdb_open(\"/home/ak/bug.ddb\", &db);\r\n  duckdb_connect(db, &con);\r\n\r\n  duckdb_query(con, \"DROP TABLE IF EXISTS bug\", NULL);\r\n  duckdb_query(con, \"CREATE TABLE bug(i INTEGER, x DECIMAL(38,38), y DECIMAL(10,5))\", NULL);\r\n  \r\n  duckdb_appender appender;\r\n  duckdb_appender_create(con, NULL, \"bug\", &appender);\r\n\r\n  // Append decimal as varchar\r\n  duckdb_append_int32(appender, 1);\r\n  duckdb_append_varchar(appender, \"0.33333333333333333333333333333333333333\");\r\n  duckdb_append_null(appender);\r\n  duckdb_appender_end_row(appender);\r\n\r\n  // Append decimal as float\r\n  duckdb_append_int32(appender, 2);\r\n  duckdb_append_null(appender);\r\n  duckdb_append_float(appender, 123.123);\r\n  duckdb_appender_end_row(appender);\r\n\r\n  // Append decimal as double\r\n  duckdb_append_int32(appender, 3);\r\n  duckdb_append_null(appender);\r\n  duckdb_append_double(appender, 123.123);\r\n  duckdb_appender_end_row(appender);\r\n\r\n  // Append decimal as integer\r\n  duckdb_append_int32(appender, 3);\r\n  duckdb_append_null(appender);\r\n  duckdb_append_uint64(appender, 12345);\r\n  duckdb_appender_end_row(appender);\r\n\r\n  duckdb_appender_destroy(&appender);\r\n\r\n  duckdb_disconnect(&con);\r\n  duckdb_close(&db);\r\n}\r\n```\r\n\r\nAdjust the database path in the above source, save as bug.c & compile and run via:\r\n```\r\ngcc -o bug -lduckdb bug.c\r\n./bug\r\n```\r\n\r\nCheck the results via the DuckDB CLI:\r\n```\r\n$ duckdb ~/bug.ddb                                                                 \r\nv0.5.1 7c111322de\r\nEnter \".help\" for usage hints.\r\nD SELECT * FROM bug;\r\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 i \u2502                    x                    \u2502    y    \u2502\r\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 1 \u2502 .00001743639545229628325703332847943680 \u2502         \u2502\r\n\u2502 2 \u2502                                         \u2502 0.00123 \u2502\r\n\u2502 3 \u2502                                         \u2502 0.00123 \u2502\r\n\u2502 3 \u2502                                         \u2502 0.12345 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n0.5.1 (also tested with current master)\r\n\r\n### DuckDB Client:\r\n\r\nC API / Common Lisp\r\n\r\n### Full Name:\r\n\r\n\u00c1kos Kiss\r\n\r\n### Affiliation:\r\n\r\nThird-party DuckDB binding maintainer (Common Lisp)\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "Thanks for the very extensive reproducable test! \ud83d\udc4d \r\n\r\nI'll look into fixing this soon :)\nIt's not C-API specific I think, it's related to the CPP-API",
  "created_at": "2022-11-15T14:35:36Z"
}