You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Named windows don't work inside WITH clauses
Consider this simple window function query:

```sql
select i, lag(i) over named_window
from (values (1), (2), (3)) as t (i)
window named_window as (order by i);
```

which produces this output:

```
i           WINDOW    
----------  ----------
1                     
2           1         
3           2   
```

Now suppose I put it inside a `with` clause:

```sql
with subquery as (
    select i, lag(i) over named_window
    from (values (1), (2), (3)) as t (i)
    window named_window as (order by i)
)
select * from subquery;
```

Now it produces an error:

```
Error: Could not find named window specification
```

Bizarrely, if you move the window frame to the parent, it works:

```sql
with subquery as (
    select i, lag(i) over named_window
    from (values (1), (2), (3)) as t (i)
)
select * from subquery
window named_window as (order by i);
```

I'm pretty sure this is a bug.
Query with SIMILAR TO results in "Assertion `strlen(dataptr) == length' failed"
Consider the following statements:
```sql
CREATE TABLE t0(c0 INT);
INSERT INTO t0 VALUES (0);
SELECT * FROM t0 WHERE t0.c0 SIMILAR TO '.'; -- Assertion `strlen(dataptr) == length' failed
```
Using the debug build, the `SELECT` fails with the following message:
```
/duckdb/src/common/types/string_type.cpp:24: void duckdb::string_t::Verify(): Assertion `strlen(dataptr) == length' failed.
``` 
I found this based on commit f3c7d397a3c5ebfa72b64d04559644efee7bbe2e.

</issue>
<code>
[start of README.md]
1: <img align="left" src="logo/duckdb-logo.png" height="120">
2: 
3: # DuckDB, the SQLite for Analytics
4: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
5: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
6: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
7: 
8: <br>
9: 
10: 
11: # Requirements
12: DuckDB requires [CMake](https://cmake.org) to be installed and a `C++11` compliant compiler. GCC 4.9 and newer, Clang 3.9 and newer and VisualStudio 2017 are tested on each revision.
13: 
14: ## Compiling
15: Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You may run `make unit` and `make allunit` to verify that your version works properly after making changes.
16: 
17: # Usage
18: A command line utility based on `sqlite3` can be found in either `build/release/duckdb_cli` (release, the default) or `build/debug/duckdb_cli` (debug).
19: 
20: # Embedding
21: As DuckDB is an embedded database, there is no database server to launch or client to connect to a running server. However, the database server can be embedded directly into an application using the C or C++ bindings. The main build process creates the shared library `build/release/src/libduckdb.[so|dylib|dll]` that can be linked against. A static library is built as well.
22: 
23: For examples on how to embed DuckDB into your application, see the [examples](https://github.com/cwida/duckdb/tree/master/examples) folder.
24: 
25: ## Benchmarks
26: After compiling, benchmarks can be executed from the root directory by executing `./build/release/benchmark/benchmark_runner`.
27: 
28: ## Standing on the Shoulders of Giants
29: DuckDB is implemented in C++ 11, should compile with GCC and clang, uses CMake to build and [Catch2](https://github.com/catchorg/Catch2) for testing. DuckDB uses some components from various Open-Source databases and draws inspiration from scientific publications. Here is an overview:
30: 
31: * Parser: We use the PostgreSQL parser that was [repackaged as a stand-alone library](https://github.com/lfittl/libpg_query). The translation to our own parse tree is inspired by [Peloton](https://pelotondb.io).
32: * Shell: We have adapted the [SQLite shell](https://sqlite.org/cli.html) to work with DuckDB.
33: * Tests: We use the [SQL Logic Tests from SQLite](https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki) to test DuckDB.
34: * Query fuzzing: We use [SQLsmith](https://github.com/anse1/sqlsmith) to generate random queries for additional testing.
35: * Date Math: We use the date math component from [MonetDB](https://www.monetdb.org).
36: * SQL Window Functions: DuckDB's window functions implementation uses Segment Tree Aggregation as described in the paper "Efficient Processing of Window Functions in Analytical SQL Queries" by Viktor Leis, Kan Kundhikanjana, Alfons Kemper and Thomas Neumann.
37: * Execution engine: The vectorized execution engine is inspired by the paper "MonetDB/X100: Hyper-Pipelining Query Execution" by Peter Boncz, Marcin Zukowski and Niels Nes.
38: * Optimizer: DuckDB's optimizer draws inspiration from the papers "Dynamic programming strikes back" by Guido Moerkotte and Thomas Neumman as well as "Unnesting Arbitrary Queries" by Thomas Neumann and Alfons Kemper.
39: * Concurrency control: Our MVCC implementation is inspired by the paper "Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems" by Thomas Neumann, Tobias Mühlbauer and Alfons Kemper.
40: * Regular Expression: DuckDB uses Google's [RE2](https://github.com/google/re2) regular expression engine.
41: 
42: ## Other pages
43: * [Continuous Benchmarking (CB™)](https://www.duckdb.org/benchmarks/index.html), runs TPC-H, TPC-DS and some microbenchmarks on every commit
[end of README.md]
[start of src/function/scalar/string/regexp.cpp]
1: #include "duckdb/function/scalar/string_functions.hpp"
2: #include "duckdb/common/exception.hpp"
3: #include "duckdb/common/vector_operations/vector_operations.hpp"
4: #include "duckdb/execution/expression_executor.hpp"
5: #include "duckdb/planner/expression/bound_function_expression.hpp"
6: #include "duckdb/common/vector_operations/unary_executor.hpp"
7: #include "duckdb/common/vector_operations/binary_executor.hpp"
8: #include "duckdb/common/vector_operations/ternary_executor.hpp"
9: #include "utf8proc_wrapper.hpp"
10: 
11: #include "re2/re2.h"
12: 
13: using namespace std;
14: 
15: namespace duckdb {
16: 
17: RegexpMatchesBindData::RegexpMatchesBindData(unique_ptr<RE2> constant_pattern, string range_min, string range_max,
18:                                              bool range_success)
19:     : constant_pattern(std::move(constant_pattern)), range_min(range_min), range_max(range_max),
20:       range_success(range_success) {
21: }
22: 
23: RegexpMatchesBindData::~RegexpMatchesBindData() {
24: }
25: 
26: unique_ptr<FunctionData> RegexpMatchesBindData::Copy() {
27: 	return make_unique<RegexpMatchesBindData>(move(constant_pattern), range_min, range_max, range_success);
28: }
29: 
30: static inline re2::StringPiece CreateStringPiece(string_t &input) {
31: 	return re2::StringPiece(input.GetData(), input.GetSize());
32: }
33: 
34: struct RegexPartialMatch {
35: 	static inline bool Operation(const re2::StringPiece &input, RE2 &re) {
36: 		return RE2::PartialMatch(input, re);
37: 	}
38: };
39: 
40: struct RegexFullMatch {
41: 	static inline bool Operation(const re2::StringPiece &input, RE2 &re) {
42: 		return RE2::FullMatch(input, re);
43: 	}
44: };
45: 
46: template<class OP>
47: static void regexp_matches_function(DataChunk &args, ExpressionState &state, Vector &result) {
48: 	auto &strings = args.data[0];
49: 	auto &patterns = args.data[1];
50: 
51: 	auto &func_expr = (BoundFunctionExpression &)state.expr;
52: 	auto &info = (RegexpMatchesBindData &)*func_expr.bind_info;
53: 
54: 	RE2::Options options;
55: 	options.set_log_errors(false);
56: 
57: 	if (info.constant_pattern) {
58: 		// FIXME: this should be a unary loop
59: 		UnaryExecutor::Execute<string_t, bool, true>(strings, result, args.size(), [&](string_t input) {
60: 			return OP::Operation(CreateStringPiece(input), *info.constant_pattern);
61: 		});
62: 	} else {
63: 		BinaryExecutor::Execute<string_t, string_t, bool, true>(
64: 		    strings, patterns, result, args.size(), [&](string_t input, string_t pattern) {
65: 			    RE2 re(CreateStringPiece(pattern), options);
66: 			    if (!re.ok()) {
67: 				    throw Exception(re.error());
68: 			    }
69: 			    return OP::Operation(CreateStringPiece(input), re);
70: 		    });
71: 	}
72: }
73: 
74: static unique_ptr<FunctionData> regexp_matches_get_bind_function(BoundFunctionExpression &expr,
75:                                                                  ClientContext &context) {
76: 	// pattern is the second argument. If its constant, we can already prepare the pattern and store it for later.
77: 	assert(expr.children.size() == 2);
78: 	if (expr.children[1]->IsScalar()) {
79: 		Value pattern_str = ExpressionExecutor::EvaluateScalar(*expr.children[1]);
80: 		if (!pattern_str.is_null && pattern_str.type == TypeId::VARCHAR) {
81: 			RE2::Options options;
82: 			options.set_log_errors(false);
83: 			auto re = make_unique<RE2>(pattern_str.str_value, options);
84: 			if (!re->ok()) {
85: 				throw Exception(re->error());
86: 			}
87: 
88: 			string range_min, range_max;
89: 			auto range_success = re->PossibleMatchRange(&range_min, &range_max, 1000);
90: 			// range_min and range_max might produce non-valid UTF8 strings, e.g. in the case of 'a.*'
91: 			// in this case we don't push a range filter
92: 			if (range_success && (Utf8Proc::Analyze(range_min) == UnicodeType::INVALID ||
93: 			                      Utf8Proc::Analyze(range_max) == UnicodeType::INVALID)) {
94: 				range_success = false;
95: 			}
96: 
97: 			return make_unique<RegexpMatchesBindData>(move(re), range_min, range_max, range_success);
98: 		}
99: 	}
100: 	return make_unique<RegexpMatchesBindData>(nullptr, "", "", false);
101: }
102: 
103: static void regexp_replace_function(DataChunk &args, ExpressionState &state, Vector &result) {
104: 	auto &strings = args.data[0];
105: 	auto &patterns = args.data[1];
106: 	auto &replaces = args.data[2];
107: 
108: 	RE2::Options options;
109: 	options.set_log_errors(false);
110: 
111: 	TernaryExecutor::Execute<string_t, string_t, string_t, string_t>(
112: 	    strings, patterns, replaces, result, args.size(), [&](string_t input, string_t pattern, string_t replace) {
113: 		    RE2 re(CreateStringPiece(pattern), options);
114: 		    std::string sstring(input.GetData(), input.GetSize());
115: 		    RE2::Replace(&sstring, re, CreateStringPiece(replace));
116: 		    return StringVector::AddString(result, sstring);
117: 	    });
118: }
119: 
120: void RegexpFun::RegisterFunction(BuiltinFunctions &set) {
121: 	set.AddFunction(ScalarFunction("regexp_full_match", {SQLType::VARCHAR, SQLType::VARCHAR}, SQLType::BOOLEAN,
122: 	                               regexp_matches_function<RegexFullMatch>, false, regexp_matches_get_bind_function));
123: 	set.AddFunction(ScalarFunction("regexp_matches", {SQLType::VARCHAR, SQLType::VARCHAR}, SQLType::BOOLEAN,
124: 	                               regexp_matches_function<RegexPartialMatch>, false, regexp_matches_get_bind_function));
125: 	set.AddFunction(ScalarFunction("regexp_replace", {SQLType::VARCHAR, SQLType::VARCHAR, SQLType::VARCHAR},
126: 	                               SQLType::VARCHAR, regexp_replace_function));
127: }
128: 
129: } // namespace duckdb
[end of src/function/scalar/string/regexp.cpp]
[start of src/include/duckdb/parser/transformer.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parser/transformer.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/constants.hpp"
12: #include "duckdb/common/enums/expression_type.hpp"
13: #include "duckdb/common/types.hpp"
14: #include "duckdb/common/unordered_map.hpp"
15: #include "duckdb/parser/tokens.hpp"
16: 
17: #include "pg_definitions.hpp"
18: #include "nodes/parsenodes.hpp"
19: 
20: namespace duckdb {
21: 
22: class ColumnDefinition;
23: struct OrderByNode;
24: 
25: //! The transformer class is responsible for transforming the internal Postgres
26: //! parser representation into the DuckDB representation
27: class Transformer {
28: public:
29: 	//! Transforms a Postgres parse tree into a set of SQL Statements
30: 	bool TransformParseTree(PGList *tree, vector<unique_ptr<SQLStatement>> &statements);
31: 	string NodetypeToString(PGNodeTag type);
32: 
33: 	idx_t prepared_statement_parameter_index = 0;
34: 
35: private:
36: 	//! Transforms a Postgres statement into a single SQL statement
37: 	unique_ptr<SQLStatement> TransformStatement(PGNode *stmt);
38: 	//===--------------------------------------------------------------------===//
39: 	// Statement transformation
40: 	//===--------------------------------------------------------------------===//
41: 	//! Transform a Postgres T_PGSelectStmt node into a SelectStatement
42: 	unique_ptr<SelectStatement> TransformSelect(PGNode *node);
43: 	//! Transform a Postgres T_AlterStmt node into a AlterTableStatement
44: 	unique_ptr<AlterTableStatement> TransformAlter(PGNode *node);
45: 	//! Transform a Postgres T_PGRenameStmt node into a RenameStatement
46: 	unique_ptr<AlterTableStatement> TransformRename(PGNode *node);
47: 	//! Transform a Postgres T_PGCreateStmt node into a CreateStatement
48: 	unique_ptr<CreateStatement> TransformCreateTable(PGNode *node);
49: 	//! Transform a Postgres T_PGCreateStmt node into a CreateStatement
50: 	unique_ptr<CreateStatement> TransformCreateTableAs(PGNode *node);
51: 	//! Transform a Postgres node into a CreateStatement
52: 	unique_ptr<CreateStatement> TransformCreateSchema(PGNode *node);
53: 	//! Transform a Postgres T_PGCreateSeqStmt node into a CreateStatement
54: 	unique_ptr<CreateStatement> TransformCreateSequence(PGNode *node);
55: 	//! Transform a Postgres T_PGViewStmt node into a CreateStatement
56: 	unique_ptr<CreateStatement> TransformCreateView(PGNode *node);
57: 	//! Transform a Postgres T_PGIndexStmt node into CreateStatement
58: 	unique_ptr<CreateStatement> TransformCreateIndex(PGNode *node);
59: 	//! Transform a Postgres T_PGDropStmt node into a Drop[Table,Schema]Statement
60: 	unique_ptr<SQLStatement> TransformDrop(PGNode *node);
61: 	//! Transform a Postgres T_PGInsertStmt node into a InsertStatement
62: 	unique_ptr<InsertStatement> TransformInsert(PGNode *node);
63: 	//! Transform a Postgres T_PGCopyStmt node into a CopyStatement
64: 	unique_ptr<CopyStatement> TransformCopy(PGNode *node);
65: 	//! Transform a Postgres T_PGTransactionStmt node into a TransactionStatement
66: 	unique_ptr<TransactionStatement> TransformTransaction(PGNode *node);
67: 	//! Transform a Postgres T_DeleteStatement node into a DeleteStatement
68: 	unique_ptr<DeleteStatement> TransformDelete(PGNode *node);
69: 	//! Transform a Postgres T_PGUpdateStmt node into a UpdateStatement
70: 	unique_ptr<UpdateStatement> TransformUpdate(PGNode *node);
71: 	//! Transform a Postgres T_PGPragmaStmt node into a PragmaStatement
72: 	unique_ptr<PragmaStatement> TransformPragma(PGNode *node);
73: 	unique_ptr<ExplainStatement> TransformExplain(PGNode *node);
74: 	unique_ptr<VacuumStatement> TransformVacuum(PGNode *node);
75: 	unique_ptr<PragmaStatement> TransformShow(PGNode *node);
76: 
77: 	unique_ptr<PrepareStatement> TransformPrepare(PGNode *node);
78: 	unique_ptr<ExecuteStatement> TransformExecute(PGNode *node);
79: 	unique_ptr<DropStatement> TransformDeallocate(PGNode *node);
80: 
81: 	//===--------------------------------------------------------------------===//
82: 	// Query Node Transform
83: 	//===--------------------------------------------------------------------===//
84: 	//! Transform a Postgres T_PGSelectStmt node into a QueryNode
85: 	unique_ptr<QueryNode> TransformSelectNode(PGSelectStmt *node);
86: 
87: 	//===--------------------------------------------------------------------===//
88: 	// Expression Transform
89: 	//===--------------------------------------------------------------------===//
90: 	//! Transform a Postgres boolean expression into an Expression
91: 	unique_ptr<ParsedExpression> TransformBoolExpr(PGBoolExpr *root);
92: 	//! Transform a Postgres case expression into an Expression
93: 	unique_ptr<ParsedExpression> TransformCase(PGCaseExpr *root);
94: 	//! Transform a Postgres type cast into an Expression
95: 	unique_ptr<ParsedExpression> TransformTypeCast(PGTypeCast *root);
96: 	//! Transform a Postgres coalesce into an Expression
97: 	unique_ptr<ParsedExpression> TransformCoalesce(PGAExpr *root);
98: 	//! Transform a Postgres column reference into an Expression
99: 	unique_ptr<ParsedExpression> TransformColumnRef(PGColumnRef *root);
100: 	//! Transform a Postgres constant value into an Expression
101: 	unique_ptr<ParsedExpression> TransformValue(PGValue val);
102: 	//! Transform a Postgres operator into an Expression
103: 	unique_ptr<ParsedExpression> TransformAExpr(PGAExpr *root);
104: 	//! Transform a Postgres abstract expression into an Expression
105: 	unique_ptr<ParsedExpression> TransformExpression(PGNode *node);
106: 	//! Transform a Postgres function call into an Expression
107: 	unique_ptr<ParsedExpression> TransformFuncCall(PGFuncCall *root);
108: 
109: 	//! Transform a Postgres constant value into an Expression
110: 	unique_ptr<ParsedExpression> TransformConstant(PGAConst *c);
111: 
112: 	unique_ptr<ParsedExpression> TransformResTarget(PGResTarget *root);
113: 	unique_ptr<ParsedExpression> TransformNullTest(PGNullTest *root);
114: 	unique_ptr<ParsedExpression> TransformParamRef(PGParamRef *node);
115: 	unique_ptr<ParsedExpression> TransformNamedArg(PGNamedArgExpr *root);
116: 
117: 	unique_ptr<ParsedExpression> TransformSQLValueFunction(PGSQLValueFunction *node);
118: 
119: 	unique_ptr<ParsedExpression> TransformSubquery(PGSubLink *root);
120: 	//===--------------------------------------------------------------------===//
121: 	// Constraints transform
122: 	//===--------------------------------------------------------------------===//
123: 	unique_ptr<Constraint> TransformConstraint(PGListCell *cell);
124: 
125: 	unique_ptr<Constraint> TransformConstraint(PGListCell *cell, ColumnDefinition &column, idx_t index);
126: 
127: 	//===--------------------------------------------------------------------===//
128: 	// Helpers
129: 	//===--------------------------------------------------------------------===//
130: 	string TransformAlias(PGAlias *root);
131: 	void TransformCTE(PGWithClause *de_with_clause, SelectStatement &select);
132: 	unique_ptr<QueryNode> TransformRecursiveCTE(PGCommonTableExpr *node);
133: 	// Operator String to ExpressionType (e.g. + => OPERATOR_ADD)
134: 	ExpressionType OperatorToExpressionType(string &op);
135: 
136: 	unique_ptr<ParsedExpression> TransformUnaryOperator(string op, unique_ptr<ParsedExpression> child);
137: 	unique_ptr<ParsedExpression> TransformBinaryOperator(string op, unique_ptr<ParsedExpression> left,
138: 	                                                     unique_ptr<ParsedExpression> right);
139: 	//===--------------------------------------------------------------------===//
140: 	// TableRef transform
141: 	//===--------------------------------------------------------------------===//
142: 	//! Transform a Postgres node into a TableRef
143: 	unique_ptr<TableRef> TransformTableRefNode(PGNode *node);
144: 	//! Transform a Postgres FROM clause into a TableRef
145: 	unique_ptr<TableRef> TransformFrom(PGList *root);
146: 	//! Transform a Postgres table reference into a TableRef
147: 	unique_ptr<TableRef> TransformRangeVar(PGRangeVar *root);
148: 	//! Transform a Postgres table-producing function into a TableRef
149: 	unique_ptr<TableRef> TransformRangeFunction(PGRangeFunction *root);
150: 	//! Transform a Postgres join node into a TableRef
151: 	unique_ptr<TableRef> TransformJoin(PGJoinExpr *root);
152: 	//! Transform a table producing subquery into a TableRef
153: 	unique_ptr<TableRef> TransformRangeSubselect(PGRangeSubselect *root);
154: 	//! Transform a VALUES list into a set of expressions
155: 	unique_ptr<TableRef> TransformValuesList(PGList *list);
156: 
157: 	//! Transform a Postgres TypeName string into a SQLType
158: 	SQLType TransformTypeName(PGTypeName *name);
159: 
160: 	//! Transform a Postgres GROUP BY expression into a list of Expression
161: 	bool TransformGroupBy(PGList *group, vector<unique_ptr<ParsedExpression>> &result);
162: 	//! Transform a Postgres ORDER BY expression into an OrderByDescription
163: 	bool TransformOrderBy(PGList *order, vector<OrderByNode> &result);
164: 
165: 	//! Transform a Postgres SELECT clause into a list of Expressions
166: 	bool TransformExpressionList(PGList *list, vector<unique_ptr<ParsedExpression>> &result);
167: 
168: 	void TransformWindowDef(PGWindowDef *window_spec, WindowExpression *expr);
169: 
170: 	//! Holds window expressions defined by name. We need those when transforming the expressions referring to them.
171: 	unordered_map<string, PGWindowDef *> window_clauses;
172: };
173: 
174: } // namespace duckdb
[end of src/include/duckdb/parser/transformer.hpp]
[start of src/parser/parser.cpp]
1: #include "duckdb/parser/parser.hpp"
2: 
3: #include "duckdb/parser/transformer.hpp"
4: #include "duckdb/parser/parsed_data/create_table_info.hpp"
5: #include "duckdb/parser/statement/create_statement.hpp"
6: #include "duckdb/parser/statement/select_statement.hpp"
7: #include "duckdb/parser/statement/update_statement.hpp"
8: #include "duckdb/parser/query_node/select_node.hpp"
9: #include "duckdb/parser/tableref/expressionlistref.hpp"
10: #include "postgres_parser.hpp"
11: 
12: #include "parser/parser.hpp"
13: 
14: using namespace duckdb;
15: using namespace std;
16: 
17: Parser::Parser() {
18: }
19: 
20: void Parser::ParseQuery(string query) {
21: 	PostgresParser parser;
22: 	parser.Parse(query);
23: 
24: 	if (!parser.success) {
25: 		throw ParserException("%s [%d]", parser.error_message.c_str(), parser.error_location);
26: 	}
27: 
28: 	if (!parser.parse_tree) {
29: 		// empty statement
30: 		return;
31: 	}
32: 
33: 	// if it succeeded, we transform the Postgres parse tree into a list of
34: 	// SQLStatements
35: 	Transformer transformer;
36: 	transformer.TransformParseTree(parser.parse_tree, statements);
37: 	n_prepared_parameters = transformer.prepared_statement_parameter_index;
38: 
39: 	if (statements.size() > 0) {
40: 		auto &last_statement = statements.back();
41: 		last_statement->stmt_length = query.size() - last_statement->stmt_location;
42: 	}
43: }
44: 
45: vector<unique_ptr<ParsedExpression>> Parser::ParseExpressionList(string select_list) {
46: 	// construct a mock query prefixed with SELECT
47: 	string mock_query = "SELECT " + select_list;
48: 	// parse the query
49: 	Parser parser;
50: 	parser.ParseQuery(mock_query);
51: 	// check the statements
52: 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT) {
53: 		throw ParserException("Expected a single SELECT statement");
54: 	}
55: 	auto &select = (SelectStatement &)*parser.statements[0];
56: 	if (select.node->type != QueryNodeType::SELECT_NODE) {
57: 		throw ParserException("Expected a single SELECT node");
58: 	}
59: 	auto &select_node = (SelectNode &)*select.node;
60: 	return move(select_node.select_list);
61: }
62: 
63: vector<OrderByNode> Parser::ParseOrderList(string select_list) {
64: 	// construct a mock query
65: 	string mock_query = "SELECT * FROM tbl ORDER BY " + select_list;
66: 	// parse the query
67: 	Parser parser;
68: 	parser.ParseQuery(mock_query);
69: 	// check the statements
70: 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT) {
71: 		throw ParserException("Expected a single SELECT statement");
72: 	}
73: 	auto &select = (SelectStatement &)*parser.statements[0];
74: 	if (select.node->type != QueryNodeType::SELECT_NODE) {
75: 		throw ParserException("Expected a single SELECT node");
76: 	}
77: 	auto &select_node = (SelectNode &)*select.node;
78: 	if (select_node.modifiers.size() == 0 || select_node.modifiers[0]->type != ResultModifierType::ORDER_MODIFIER) {
79: 		throw ParserException("Expected a single ORDER clause");
80: 	}
81: 	auto &order = (OrderModifier &)*select_node.modifiers[0];
82: 	return move(order.orders);
83: }
84: 
85: void Parser::ParseUpdateList(string update_list, vector<string> &update_columns,
86:                              vector<unique_ptr<ParsedExpression>> &expressions) {
87: 	// construct a mock query
88: 	string mock_query = "UPDATE tbl SET " + update_list;
89: 	// parse the query
90: 	Parser parser;
91: 	parser.ParseQuery(mock_query);
92: 	// check the statements
93: 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::UPDATE) {
94: 		throw ParserException("Expected a single UPDATE statement");
95: 	}
96: 	auto &update = (UpdateStatement &)*parser.statements[0];
97: 	update_columns = move(update.columns);
98: 	expressions = move(update.expressions);
99: }
100: 
101: vector<vector<unique_ptr<ParsedExpression>>> Parser::ParseValuesList(string value_list) {
102: 	// construct a mock query
103: 	string mock_query = "VALUES " + value_list;
104: 	// parse the query
105: 	Parser parser;
106: 	parser.ParseQuery(mock_query);
107: 	// check the statements
108: 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT) {
109: 		throw ParserException("Expected a single SELECT statement");
110: 	}
111: 	auto &select = (SelectStatement &)*parser.statements[0];
112: 	if (select.node->type != QueryNodeType::SELECT_NODE) {
113: 		throw ParserException("Expected a single SELECT node");
114: 	}
115: 	auto &select_node = (SelectNode &)*select.node;
116: 	if (!select_node.from_table || select_node.from_table->type != TableReferenceType::EXPRESSION_LIST) {
117: 		throw ParserException("Expected a single VALUES statement");
118: 	}
119: 	auto &values_list = (ExpressionListRef &)*select_node.from_table;
120: 	return move(values_list.values);
121: }
122: 
123: vector<ColumnDefinition> Parser::ParseColumnList(string column_list) {
124: 	string mock_query = "CREATE TABLE blabla (" + column_list + ")";
125: 	Parser parser;
126: 	parser.ParseQuery(mock_query);
127: 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::CREATE) {
128: 		throw ParserException("Expected a single CREATE statement");
129: 	}
130: 	auto &create = (CreateStatement &)*parser.statements[0];
131: 	if (create.info->type != CatalogType::TABLE) {
132: 		throw ParserException("Expected a single CREATE TABLE statement");
133: 	}
134: 	auto &info = ((CreateTableInfo &)*create.info);
135: 	return move(info.columns);
136: }
[end of src/parser/parser.cpp]
[start of src/parser/transform/expression/transform_function.cpp]
1: #include "duckdb/parser/expression/cast_expression.hpp"
2: #include "duckdb/parser/expression/function_expression.hpp"
3: #include "duckdb/parser/expression/operator_expression.hpp"
4: #include "duckdb/parser/expression/star_expression.hpp"
5: #include "duckdb/parser/expression/window_expression.hpp"
6: #include "duckdb/parser/transformer.hpp"
7: #include "duckdb/common/string_util.hpp"
8: 
9: using namespace duckdb;
10: using namespace std;
11: 
12: static ExpressionType WindowToExpressionType(string &fun_name) {
13: 	if (fun_name == "rank") {
14: 		return ExpressionType::WINDOW_RANK;
15: 	} else if (fun_name == "rank_dense" || fun_name == "dense_rank") {
16: 		return ExpressionType::WINDOW_RANK_DENSE;
17: 	} else if (fun_name == "percent_rank") {
18: 		return ExpressionType::WINDOW_PERCENT_RANK;
19: 	} else if (fun_name == "row_number") {
20: 		return ExpressionType::WINDOW_ROW_NUMBER;
21: 	} else if (fun_name == "first_value" || fun_name == "first") {
22: 		return ExpressionType::WINDOW_FIRST_VALUE;
23: 	} else if (fun_name == "last_value" || fun_name == "last") {
24: 		return ExpressionType::WINDOW_LAST_VALUE;
25: 	} else if (fun_name == "cume_dist") {
26: 		return ExpressionType::WINDOW_CUME_DIST;
27: 	} else if (fun_name == "lead") {
28: 		return ExpressionType::WINDOW_LEAD;
29: 	} else if (fun_name == "lag") {
30: 		return ExpressionType::WINDOW_LAG;
31: 	} else if (fun_name == "ntile") {
32: 		return ExpressionType::WINDOW_NTILE;
33: 	}
34: 
35: 	return ExpressionType::WINDOW_AGGREGATE;
36: }
37: 
38: void Transformer::TransformWindowDef(PGWindowDef *window_spec, WindowExpression *expr) {
39: 	assert(window_spec);
40: 	assert(expr);
41: 
42: 	// next: partitioning/ordering expressions
43: 	TransformExpressionList(window_spec->partitionClause, expr->partitions);
44: 	TransformOrderBy(window_spec->orderClause, expr->orders);
45: 
46: 	// finally: specifics of bounds
47: 	expr->start_expr = TransformExpression(window_spec->startOffset);
48: 	expr->end_expr = TransformExpression(window_spec->endOffset);
49: 
50: 	if ((window_spec->frameOptions & FRAMEOPTION_END_UNBOUNDED_PRECEDING) ||
51: 	    (window_spec->frameOptions & FRAMEOPTION_START_UNBOUNDED_FOLLOWING)) {
52: 		throw Exception(
53: 		    "Window frames starting with unbounded following or ending in unbounded preceding make no sense");
54: 	}
55: 
56: 	if (window_spec->frameOptions & FRAMEOPTION_START_UNBOUNDED_PRECEDING) {
57: 		expr->start = WindowBoundary::UNBOUNDED_PRECEDING;
58: 	} else if (window_spec->frameOptions & FRAMEOPTION_START_UNBOUNDED_FOLLOWING) {
59: 		expr->start = WindowBoundary::UNBOUNDED_FOLLOWING;
60: 	} else if (window_spec->frameOptions & FRAMEOPTION_START_VALUE_PRECEDING) {
61: 		expr->start = WindowBoundary::EXPR_PRECEDING;
62: 	} else if (window_spec->frameOptions & FRAMEOPTION_START_VALUE_FOLLOWING) {
63: 		expr->start = WindowBoundary::EXPR_FOLLOWING;
64: 	} else if (window_spec->frameOptions & (FRAMEOPTION_START_CURRENT_ROW | FRAMEOPTION_RANGE)) {
65: 		expr->start = WindowBoundary::CURRENT_ROW_RANGE;
66: 	} else if (window_spec->frameOptions & (FRAMEOPTION_START_CURRENT_ROW | FRAMEOPTION_ROWS)) {
67: 		expr->start = WindowBoundary::CURRENT_ROW_ROWS;
68: 	}
69: 
70: 	if (window_spec->frameOptions & FRAMEOPTION_END_UNBOUNDED_PRECEDING) {
71: 		expr->end = WindowBoundary::UNBOUNDED_PRECEDING;
72: 	} else if (window_spec->frameOptions & FRAMEOPTION_END_UNBOUNDED_FOLLOWING) {
73: 		expr->end = WindowBoundary::UNBOUNDED_FOLLOWING;
74: 	} else if (window_spec->frameOptions & FRAMEOPTION_END_VALUE_PRECEDING) {
75: 		expr->end = WindowBoundary::EXPR_PRECEDING;
76: 	} else if (window_spec->frameOptions & FRAMEOPTION_END_VALUE_FOLLOWING) {
77: 		expr->end = WindowBoundary::EXPR_FOLLOWING;
78: 	} else if (window_spec->frameOptions & (FRAMEOPTION_END_CURRENT_ROW | FRAMEOPTION_RANGE)) {
79: 		expr->end = WindowBoundary::CURRENT_ROW_RANGE;
80: 	} else if (window_spec->frameOptions & (FRAMEOPTION_END_CURRENT_ROW | FRAMEOPTION_ROWS)) {
81: 		expr->end = WindowBoundary::CURRENT_ROW_ROWS;
82: 	}
83: 
84: 	assert(expr->start != WindowBoundary::INVALID && expr->end != WindowBoundary::INVALID);
85: 	if (((expr->start == WindowBoundary::EXPR_PRECEDING || expr->start == WindowBoundary::EXPR_PRECEDING) &&
86: 	     !expr->start_expr) ||
87: 	    ((expr->end == WindowBoundary::EXPR_PRECEDING || expr->end == WindowBoundary::EXPR_PRECEDING) &&
88: 	     !expr->end_expr)) {
89: 		throw Exception("Failed to transform window boundary expression");
90: 	}
91: }
92: 
93: unique_ptr<ParsedExpression> Transformer::TransformFuncCall(PGFuncCall *root) {
94: 	auto name = root->funcname;
95: 	string schema, function_name;
96: 	if (name->length == 2) {
97: 		// schema + name
98: 		schema = reinterpret_cast<PGValue *>(name->head->data.ptr_value)->val.str;
99: 		function_name = reinterpret_cast<PGValue *>(name->head->next->data.ptr_value)->val.str;
100: 	} else {
101: 		// unqualified name
102: 		schema = DEFAULT_SCHEMA;
103: 		function_name = reinterpret_cast<PGValue *>(name->head->data.ptr_value)->val.str;
104: 	}
105: 
106: 	auto lowercase_name = StringUtil::Lower(function_name);
107: 
108: 	if (root->agg_filter) {
109: 		throw ParserException("FILTER is not implemented for aggregates");
110: 	}
111: 	if (root->agg_order) {
112: 		throw ParserException("ORDER BY is not implemented for aggregates");
113: 	}
114: 
115: 	if (root->over) {
116: 		if (root->agg_distinct) {
117: 			throw ParserException("DISTINCT is not implemented for window functions!");
118: 		}
119: 
120: 		auto win_fun_type = WindowToExpressionType(lowercase_name);
121: 		if (win_fun_type == ExpressionType::INVALID) {
122: 			throw Exception("Unknown/unsupported window function");
123: 		}
124: 
125: 		auto expr = make_unique<WindowExpression>(win_fun_type, schema, lowercase_name);
126: 
127: 		if (root->args) {
128: 			vector<unique_ptr<ParsedExpression>> function_list;
129: 			auto res = TransformExpressionList(root->args, function_list);
130: 			if (!res) {
131: 				throw Exception("Failed to transform window function children");
132: 			}
133: 			if (win_fun_type == ExpressionType::WINDOW_AGGREGATE) {
134: 				for (auto &child : function_list) {
135: 					expr->children.push_back(move(child));
136: 				}
137: 			} else {
138: 				if (function_list.size() > 0) {
139: 					expr->children.push_back(move(function_list[0]));
140: 				}
141: 				if (function_list.size() > 1) {
142: 					assert(win_fun_type == ExpressionType::WINDOW_LEAD || win_fun_type == ExpressionType::WINDOW_LAG);
143: 					expr->offset_expr = move(function_list[1]);
144: 				}
145: 				if (function_list.size() > 2) {
146: 					assert(win_fun_type == ExpressionType::WINDOW_LEAD || win_fun_type == ExpressionType::WINDOW_LAG);
147: 					expr->default_expr = move(function_list[2]);
148: 				}
149: 				assert(function_list.size() <= 3);
150: 			}
151: 		}
152: 		auto window_spec = reinterpret_cast<PGWindowDef *>(root->over);
153: 		if (window_spec->name) {
154: 			auto it = window_clauses.find(StringUtil::Lower(string(window_spec->name)));
155: 			if (it == window_clauses.end()) {
156: 				throw Exception("Could not find named window specification");
157: 			}
158: 			window_spec = it->second;
159: 			assert(window_spec);
160: 		}
161: 		TransformWindowDef(window_spec, expr.get());
162: 
163: 		return move(expr);
164: 	}
165: 
166: 	vector<unique_ptr<ParsedExpression>> children;
167: 	if (root->args != nullptr) {
168: 		for (auto node = root->args->head; node != nullptr; node = node->next) {
169: 			auto child_expr = TransformExpression((PGNode *)node->data.ptr_value);
170: 			children.push_back(move(child_expr));
171: 		}
172: 	}
173: 
174: 	return make_unique<FunctionExpression>(schema, lowercase_name.c_str(), children, root->agg_distinct);
175: }
176: 
177: static string SQLValueOpToString(PGSQLValueFunctionOp op) {
178: 	switch (op) {
179: 	case PG_SVFOP_CURRENT_DATE:
180: 		return "current_date";
181: 	case PG_SVFOP_CURRENT_TIME:
182: 		return "current_time";
183: 	case PG_SVFOP_CURRENT_TIME_N:
184: 		return "current_time_n";
185: 	case PG_SVFOP_CURRENT_TIMESTAMP:
186: 		return "current_timestamp";
187: 	case PG_SVFOP_CURRENT_TIMESTAMP_N:
188: 		return "current_timestamp_n";
189: 	case PG_SVFOP_LOCALTIME:
190: 		return "current_localtime";
191: 	case PG_SVFOP_LOCALTIME_N:
192: 		return "current_localtime_n";
193: 	case PG_SVFOP_LOCALTIMESTAMP:
194: 		return "current_localtimestamp";
195: 	case PG_SVFOP_LOCALTIMESTAMP_N:
196: 		return "current_localtimestamp_n";
197: 	case PG_SVFOP_CURRENT_ROLE:
198: 		return "current_role";
199: 	case PG_SVFOP_CURRENT_USER:
200: 		return "current_user";
201: 	case PG_SVFOP_USER:
202: 		return "user";
203: 	case PG_SVFOP_SESSION_USER:
204: 		return "session_user";
205: 	case PG_SVFOP_CURRENT_CATALOG:
206: 		return "current_catalog";
207: 	case PG_SVFOP_CURRENT_SCHEMA:
208: 		return "current_schema";
209: 	default:
210: 		throw Exception("Could not find named SQL value function specification " + to_string((int)op));
211: 	}
212: }
213: 
214: unique_ptr<ParsedExpression> Transformer::TransformSQLValueFunction(PGSQLValueFunction *node) {
215: 	if (!node) {
216: 		return nullptr;
217: 	}
218: 	vector<unique_ptr<ParsedExpression>> children;
219: 	auto fname = SQLValueOpToString(node->op);
220: 	return make_unique<FunctionExpression>(DEFAULT_SCHEMA, fname, children);
221: }
[end of src/parser/transform/expression/transform_function.cpp]
[start of src/parser/transform/expression/transform_param_ref.cpp]
1: #include "duckdb/parser/expression/parameter_expression.hpp"
2: #include "duckdb/parser/transformer.hpp"
3: 
4: using namespace duckdb;
5: using namespace std;
6: 
7: unique_ptr<ParsedExpression> Transformer::TransformParamRef(PGParamRef *node) {
8: 	if (!node) {
9: 		return nullptr;
10: 	}
11: 	auto expr = make_unique<ParameterExpression>();
12: 	if (node->number == 0) {
13: 		expr->parameter_nr = prepared_statement_parameter_index + 1;
14: 	} else {
15: 		expr->parameter_nr = node->number;
16: 	}
17: 	prepared_statement_parameter_index = max(prepared_statement_parameter_index, expr->parameter_nr);
18: 	return move(expr);
19: }
[end of src/parser/transform/expression/transform_param_ref.cpp]
[start of src/parser/transform/statement/transform_prepare.cpp]
1: #include "duckdb/parser/statement/drop_statement.hpp"
2: #include "duckdb/parser/statement/execute_statement.hpp"
3: #include "duckdb/parser/statement/prepare_statement.hpp"
4: #include "duckdb/parser/transformer.hpp"
5: 
6: using namespace duckdb;
7: using namespace std;
8: 
9: unique_ptr<PrepareStatement> Transformer::TransformPrepare(PGNode *node) {
10: 	auto stmt = reinterpret_cast<PGPrepareStmt *>(node);
11: 	assert(stmt);
12: 
13: 	if (stmt->argtypes && stmt->argtypes->length > 0) {
14: 		throw NotImplementedException("Prepared statement argument types are not supported, use CAST");
15: 	}
16: 
17: 	auto result = make_unique<PrepareStatement>();
18: 	result->name = string(stmt->name);
19: 	result->statement = TransformStatement(stmt->query);
20: 	prepared_statement_parameter_index = 0;
21: 
22: 	return result;
23: }
24: 
25: unique_ptr<ExecuteStatement> Transformer::TransformExecute(PGNode *node) {
26: 	auto stmt = reinterpret_cast<PGExecuteStmt *>(node);
27: 	assert(stmt);
28: 
29: 	auto result = make_unique<ExecuteStatement>();
30: 	result->name = string(stmt->name);
31: 
32: 	TransformExpressionList(stmt->params, result->values);
33: 	for (auto &expr : result->values) {
34: 		if (!expr->IsScalar()) {
35: 			throw Exception("Only scalar parameters or NULL supported for EXECUTE");
36: 		}
37: 	}
38: 	return result;
39: }
40: 
41: unique_ptr<DropStatement> Transformer::TransformDeallocate(PGNode *node) {
42: 	auto stmt = reinterpret_cast<PGDeallocateStmt *>(node);
43: 	assert(stmt);
44: 
45: 	auto result = make_unique<DropStatement>();
46: 	result->info->type = CatalogType::PREPARED_STATEMENT;
47: 	result->info->name = string(stmt->name);
48: 	return result;
49: }
[end of src/parser/transform/statement/transform_prepare.cpp]
[start of src/parser/transform/statement/transform_select.cpp]
1: #include "duckdb/parser/statement/select_statement.hpp"
2: #include "duckdb/parser/transformer.hpp"
3: #include "duckdb/common/string_util.hpp"
4: 
5: using namespace duckdb;
6: using namespace std;
7: 
8: unique_ptr<SelectStatement> Transformer::TransformSelect(PGNode *node) {
9: 	auto stmt = reinterpret_cast<PGSelectStmt *>(node);
10: 	auto result = make_unique<SelectStatement>();
11: 
12: 	if (stmt->windowClause) {
13: 		for (auto window_ele = stmt->windowClause->head; window_ele != NULL; window_ele = window_ele->next) {
14: 			auto window_def = reinterpret_cast<PGWindowDef *>(window_ele->data.ptr_value);
15: 			assert(window_def);
16: 			assert(window_def->name);
17: 			auto window_name = StringUtil::Lower(string(window_def->name));
18: 
19: 			auto it = window_clauses.find(window_name);
20: 			if (it != window_clauses.end()) {
21: 				throw Exception("A window specification needs an unique name");
22: 			}
23: 			window_clauses[window_name] = window_def;
24: 		}
25: 	}
26: 
27: 	// may contain windows so second
28: 	if (stmt->withClause) {
29: 		TransformCTE(reinterpret_cast<PGWithClause *>(stmt->withClause), *result);
30: 	}
31: 
32: 	result->node = TransformSelectNode(stmt);
33: 	return result;
34: }
[end of src/parser/transform/statement/transform_select.cpp]
[start of src/parser/transform/statement/transform_select_node.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/parser/query_node/select_node.hpp"
3: #include "duckdb/parser/query_node/set_operation_node.hpp"
4: #include "duckdb/parser/statement/select_statement.hpp"
5: #include "duckdb/parser/transformer.hpp"
6: #include "duckdb/parser/expression/star_expression.hpp"
7: 
8: using namespace duckdb;
9: using namespace std;
10: 
11: unique_ptr<QueryNode> Transformer::TransformSelectNode(PGSelectStmt *stmt) {
12: 	unique_ptr<QueryNode> node;
13: 	switch (stmt->op) {
14: 	case PG_SETOP_NONE: {
15: 		node = make_unique<SelectNode>();
16: 		auto result = (SelectNode *)node.get();
17: 		// do this early so the value lists also have a `FROM`
18: 		if (stmt->valuesLists) {
19: 			// VALUES list, create an ExpressionList
20: 			assert(!stmt->fromClause);
21: 			result->from_table = TransformValuesList(stmt->valuesLists);
22: 			result->select_list.push_back(make_unique<StarExpression>());
23: 		} else {
24: 			result->from_table = TransformFrom(stmt->fromClause);
25: 			if (!stmt->targetList) {
26: 				throw ParserException("SELECT clause without selection list");
27: 			}
28: 			// select list
29: 			if (!TransformExpressionList(stmt->targetList, result->select_list)) {
30: 				throw Exception("Failed to transform expression list.");
31: 			}
32: 		}
33: 		// checks distinct clause
34: 		if (stmt->distinctClause != NULL) {
35: 			auto modifier = make_unique<DistinctModifier>();
36: 			// checks distinct on clause
37: 			auto target = reinterpret_cast<PGNode *>(stmt->distinctClause->head->data.ptr_value);
38: 			if (target) {
39: 				//  add the columns defined in the ON clause to the select list
40: 				if (!TransformExpressionList(stmt->distinctClause, modifier->distinct_on_targets)) {
41: 					throw Exception("Failed to transform expression list from DISTINCT ON.");
42: 				}
43: 			}
44: 			result->modifiers.push_back(move(modifier));
45: 		}
46: 		// from table
47: 		// group by
48: 		TransformGroupBy(stmt->groupClause, result->groups);
49: 		result->having = TransformExpression(stmt->havingClause);
50: 		// where
51: 		result->where_clause = TransformExpression(stmt->whereClause);
52: 		break;
53: 	}
54: 	case PG_SETOP_UNION:
55: 	case PG_SETOP_EXCEPT:
56: 	case PG_SETOP_INTERSECT: {
57: 		node = make_unique<SetOperationNode>();
58: 		auto result = (SetOperationNode *)node.get();
59: 		result->left = TransformSelectNode(stmt->larg);
60: 		result->right = TransformSelectNode(stmt->rarg);
61: 		if (!result->left || !result->right) {
62: 			throw Exception("Failed to transform setop children.");
63: 		}
64: 
65: 		bool select_distinct = true;
66: 		switch (stmt->op) {
67: 		case PG_SETOP_UNION:
68: 			select_distinct = !stmt->all;
69: 			result->setop_type = SetOperationType::UNION;
70: 			break;
71: 		case PG_SETOP_EXCEPT:
72: 			result->setop_type = SetOperationType::EXCEPT;
73: 			break;
74: 		case PG_SETOP_INTERSECT:
75: 			result->setop_type = SetOperationType::INTERSECT;
76: 			break;
77: 		default:
78: 			throw Exception("Unexpected setop type");
79: 		}
80: 		if (select_distinct) {
81: 			result->modifiers.push_back(make_unique<DistinctModifier>());
82: 		}
83: 		break;
84: 	}
85: 	default:
86: 		throw NotImplementedException("Statement type %d not implemented!", stmt->op);
87: 	}
88: 	// transform the common properties
89: 	// both the set operations and the regular select can have an ORDER BY/LIMIT attached to them
90: 	vector<OrderByNode> orders;
91: 	TransformOrderBy(stmt->sortClause, orders);
92: 	if (orders.size() > 0) {
93: 		auto order_modifier = make_unique<OrderModifier>();
94: 		order_modifier->orders = move(orders);
95: 		node->modifiers.push_back(move(order_modifier));
96: 	}
97: 	if (stmt->limitCount || stmt->limitOffset) {
98: 		auto limit_modifier = make_unique<LimitModifier>();
99: 		if (stmt->limitCount) {
100: 			limit_modifier->limit = TransformExpression(stmt->limitCount);
101: 		}
102: 		if (stmt->limitOffset) {
103: 			limit_modifier->offset = TransformExpression(stmt->limitOffset);
104: 		}
105: 		node->modifiers.push_back(move(limit_modifier));
106: 	}
107: 	return node;
108: }
[end of src/parser/transform/statement/transform_select_node.cpp]
[start of src/parser/transform/tableref/transform_subquery.cpp]
1: #include "duckdb/parser/tableref/subqueryref.hpp"
2: #include "duckdb/parser/transformer.hpp"
3: 
4: using namespace duckdb;
5: using namespace std;
6: 
7: unique_ptr<TableRef> Transformer::TransformRangeSubselect(PGRangeSubselect *root) {
8: 	auto subquery = TransformSelectNode((PGSelectStmt *)root->subquery);
9: 	if (!subquery) {
10: 		return nullptr;
11: 	}
12: 	auto alias = TransformAlias(root->alias);
13: 	auto result = make_unique<SubqueryRef>(move(subquery), alias);
14: 	if (root->alias->colnames) {
15: 		for (auto node = root->alias->colnames->head; node != nullptr; node = node->next) {
16: 			result->column_name_alias.push_back(reinterpret_cast<PGValue *>(node->data.ptr_value)->val.str);
17: 		}
18: 	}
19: 	return move(result);
20: }
[end of src/parser/transform/tableref/transform_subquery.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: