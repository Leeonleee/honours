{
  "repo": "duckdb/duckdb",
  "pull_number": 548,
  "instance_id": "duckdb__duckdb-548",
  "issue_numbers": [
    "546",
    "547"
  ],
  "base_commit": "f3c7d397a3c5ebfa72b64d04559644efee7bbe2e",
  "patch": "diff --git a/src/function/scalar/string/regexp.cpp b/src/function/scalar/string/regexp.cpp\nindex 08de684c36fc..0a690c4c0bce 100644\n--- a/src/function/scalar/string/regexp.cpp\n+++ b/src/function/scalar/string/regexp.cpp\n@@ -87,11 +87,18 @@ static unique_ptr<FunctionData> regexp_matches_get_bind_function(BoundFunctionEx\n \n \t\t\tstring range_min, range_max;\n \t\t\tauto range_success = re->PossibleMatchRange(&range_min, &range_max, 1000);\n-\t\t\t// range_min and range_max might produce non-valid UTF8 strings, e.g. in the case of 'a.*'\n-\t\t\t// in this case we don't push a range filter\n-\t\t\tif (range_success && (Utf8Proc::Analyze(range_min) == UnicodeType::INVALID ||\n-\t\t\t                      Utf8Proc::Analyze(range_max) == UnicodeType::INVALID)) {\n-\t\t\t\trange_success = false;\n+\t\t\tif (range_success) {\n+\t\t\t\t// there can be null terminators in the produced range value: remove them\n+\t\t\t\trange_min = string(range_min.c_str());\n+\t\t\t\trange_max = string(range_max.c_str());\n+\t\t\t\tif (range_min.size() == 0 || range_max.size() == 0) {\n+\t\t\t\t\trange_success = false;\n+\t\t\t\t}\n+\t\t\t\t// range_min and range_max might produce non-valid UTF8 strings, e.g. in the case of 'a.*'\n+\t\t\t\t// in this case we don't push a range filter\n+\t\t\t\tif (Utf8Proc::Analyze(range_min) == UnicodeType::INVALID || Utf8Proc::Analyze(range_max) == UnicodeType::INVALID) {\n+\t\t\t\t\trange_success = false;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\treturn make_unique<RegexpMatchesBindData>(move(re), range_min, range_max, range_success);\ndiff --git a/src/include/duckdb/parser/transformer.hpp b/src/include/duckdb/parser/transformer.hpp\nindex 53471ab60d6a..ff518d904ad9 100644\n--- a/src/include/duckdb/parser/transformer.hpp\n+++ b/src/include/duckdb/parser/transformer.hpp\n@@ -26,11 +26,30 @@ struct OrderByNode;\n //! parser representation into the DuckDB representation\n class Transformer {\n public:\n+\tTransformer(Transformer *parent = nullptr) : parent(parent) {}\n+\n \t//! Transforms a Postgres parse tree into a set of SQL Statements\n \tbool TransformParseTree(PGList *tree, vector<unique_ptr<SQLStatement>> &statements);\n \tstring NodetypeToString(PGNodeTag type);\n \n+\tidx_t ParamCount() {\n+\t\treturn parent ? parent->ParamCount() : prepared_statement_parameter_index;\n+\t}\n+\n+private:\n+\tTransformer *parent;\n+\t//! The current prepared statement parameter index\n \tidx_t prepared_statement_parameter_index = 0;\n+\t//! Holds window expressions defined by name. We need those when transforming the expressions referring to them.\n+\tunordered_map<string, PGWindowDef *> window_clauses;\n+\n+\tvoid SetParamCount(idx_t new_count) {\n+\t\tif (parent) {\n+\t\t\tparent->SetParamCount(new_count);\n+\t\t} else {\n+\t\t\tthis->prepared_statement_parameter_index = new_count;\n+\t\t}\n+\t}\n \n private:\n \t//! Transforms a Postgres statement into a single SQL statement\n@@ -166,9 +185,6 @@ class Transformer {\n \tbool TransformExpressionList(PGList *list, vector<unique_ptr<ParsedExpression>> &result);\n \n \tvoid TransformWindowDef(PGWindowDef *window_spec, WindowExpression *expr);\n-\n-\t//! Holds window expressions defined by name. We need those when transforming the expressions referring to them.\n-\tunordered_map<string, PGWindowDef *> window_clauses;\n };\n \n } // namespace duckdb\ndiff --git a/src/parser/parser.cpp b/src/parser/parser.cpp\nindex 9451d2c3af8b..d6d328eb100d 100644\n--- a/src/parser/parser.cpp\n+++ b/src/parser/parser.cpp\n@@ -34,7 +34,7 @@ void Parser::ParseQuery(string query) {\n \t// SQLStatements\n \tTransformer transformer;\n \ttransformer.TransformParseTree(parser.parse_tree, statements);\n-\tn_prepared_parameters = transformer.prepared_statement_parameter_index;\n+\tn_prepared_parameters = transformer.ParamCount();\n \n \tif (statements.size() > 0) {\n \t\tauto &last_statement = statements.back();\ndiff --git a/src/parser/transform/expression/transform_function.cpp b/src/parser/transform/expression/transform_function.cpp\nindex 87ed8b9fe1c4..b3364b1f2ea1 100644\n--- a/src/parser/transform/expression/transform_function.cpp\n+++ b/src/parser/transform/expression/transform_function.cpp\n@@ -153,7 +153,7 @@ unique_ptr<ParsedExpression> Transformer::TransformFuncCall(PGFuncCall *root) {\n \t\tif (window_spec->name) {\n \t\t\tauto it = window_clauses.find(StringUtil::Lower(string(window_spec->name)));\n \t\t\tif (it == window_clauses.end()) {\n-\t\t\t\tthrow Exception(\"Could not find named window specification\");\n+\t\t\t\tthrow ParserException(\"window \\\"%s\\\" does not exist\", window_spec->name);\n \t\t\t}\n \t\t\twindow_spec = it->second;\n \t\t\tassert(window_spec);\ndiff --git a/src/parser/transform/expression/transform_param_ref.cpp b/src/parser/transform/expression/transform_param_ref.cpp\nindex 6aeb3442985d..d26a069dd4e5 100644\n--- a/src/parser/transform/expression/transform_param_ref.cpp\n+++ b/src/parser/transform/expression/transform_param_ref.cpp\n@@ -10,10 +10,10 @@ unique_ptr<ParsedExpression> Transformer::TransformParamRef(PGParamRef *node) {\n \t}\n \tauto expr = make_unique<ParameterExpression>();\n \tif (node->number == 0) {\n-\t\texpr->parameter_nr = prepared_statement_parameter_index + 1;\n+\t\texpr->parameter_nr = ParamCount() + 1;\n \t} else {\n \t\texpr->parameter_nr = node->number;\n \t}\n-\tprepared_statement_parameter_index = max(prepared_statement_parameter_index, expr->parameter_nr);\n+\tSetParamCount(max(ParamCount(), expr->parameter_nr));\n \treturn move(expr);\n }\ndiff --git a/src/parser/transform/statement/transform_prepare.cpp b/src/parser/transform/statement/transform_prepare.cpp\nindex fedf4ad9d8ca..cb9702f43b50 100644\n--- a/src/parser/transform/statement/transform_prepare.cpp\n+++ b/src/parser/transform/statement/transform_prepare.cpp\n@@ -17,7 +17,7 @@ unique_ptr<PrepareStatement> Transformer::TransformPrepare(PGNode *node) {\n \tauto result = make_unique<PrepareStatement>();\n \tresult->name = string(stmt->name);\n \tresult->statement = TransformStatement(stmt->query);\n-\tprepared_statement_parameter_index = 0;\n+\tSetParamCount(0);\n \n \treturn result;\n }\ndiff --git a/src/parser/transform/statement/transform_select.cpp b/src/parser/transform/statement/transform_select.cpp\nindex 05664aba739d..2ce8a7919308 100644\n--- a/src/parser/transform/statement/transform_select.cpp\n+++ b/src/parser/transform/statement/transform_select.cpp\n@@ -9,21 +9,6 @@ unique_ptr<SelectStatement> Transformer::TransformSelect(PGNode *node) {\n \tauto stmt = reinterpret_cast<PGSelectStmt *>(node);\n \tauto result = make_unique<SelectStatement>();\n \n-\tif (stmt->windowClause) {\n-\t\tfor (auto window_ele = stmt->windowClause->head; window_ele != NULL; window_ele = window_ele->next) {\n-\t\t\tauto window_def = reinterpret_cast<PGWindowDef *>(window_ele->data.ptr_value);\n-\t\t\tassert(window_def);\n-\t\t\tassert(window_def->name);\n-\t\t\tauto window_name = StringUtil::Lower(string(window_def->name));\n-\n-\t\t\tauto it = window_clauses.find(window_name);\n-\t\t\tif (it != window_clauses.end()) {\n-\t\t\t\tthrow Exception(\"A window specification needs an unique name\");\n-\t\t\t}\n-\t\t\twindow_clauses[window_name] = window_def;\n-\t\t}\n-\t}\n-\n \t// may contain windows so second\n \tif (stmt->withClause) {\n \t\tTransformCTE(reinterpret_cast<PGWithClause *>(stmt->withClause), *result);\ndiff --git a/src/parser/transform/statement/transform_select_node.cpp b/src/parser/transform/statement/transform_select_node.cpp\nindex a3a860a4e38c..eff37b11e574 100644\n--- a/src/parser/transform/statement/transform_select_node.cpp\n+++ b/src/parser/transform/statement/transform_select_node.cpp\n@@ -4,16 +4,34 @@\n #include \"duckdb/parser/statement/select_statement.hpp\"\n #include \"duckdb/parser/transformer.hpp\"\n #include \"duckdb/parser/expression/star_expression.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n \n using namespace duckdb;\n using namespace std;\n \n unique_ptr<QueryNode> Transformer::TransformSelectNode(PGSelectStmt *stmt) {\n \tunique_ptr<QueryNode> node;\n+\n \tswitch (stmt->op) {\n \tcase PG_SETOP_NONE: {\n \t\tnode = make_unique<SelectNode>();\n \t\tauto result = (SelectNode *)node.get();\n+\n+\t\tif (stmt->windowClause) {\n+\t\t\tfor (auto window_ele = stmt->windowClause->head; window_ele != NULL; window_ele = window_ele->next) {\n+\t\t\t\tauto window_def = reinterpret_cast<PGWindowDef *>(window_ele->data.ptr_value);\n+\t\t\t\tassert(window_def);\n+\t\t\t\tassert(window_def->name);\n+\t\t\t\tauto window_name = StringUtil::Lower(string(window_def->name));\n+\n+\t\t\t\tauto it = window_clauses.find(window_name);\n+\t\t\t\tif (it != window_clauses.end()) {\n+\t\t\t\t\tthrow ParserException(\"window \\\"%s\\\" is already defined\", window_name.c_str());\n+\t\t\t\t}\n+\t\t\t\twindow_clauses[window_name] = window_def;\n+\t\t\t}\n+\t\t}\n+\n \t\t// do this early so the value lists also have a `FROM`\n \t\tif (stmt->valuesLists) {\n \t\t\t// VALUES list, create an ExpressionList\ndiff --git a/src/parser/transform/tableref/transform_subquery.cpp b/src/parser/transform/tableref/transform_subquery.cpp\nindex 1db8f8ff52dc..ac99679d5274 100644\n--- a/src/parser/transform/tableref/transform_subquery.cpp\n+++ b/src/parser/transform/tableref/transform_subquery.cpp\n@@ -5,7 +5,8 @@ using namespace duckdb;\n using namespace std;\n \n unique_ptr<TableRef> Transformer::TransformRangeSubselect(PGRangeSubselect *root) {\n-\tauto subquery = TransformSelectNode((PGSelectStmt *)root->subquery);\n+\tTransformer subquery_transformer(this);\n+\tauto subquery = subquery_transformer.TransformSelectNode((PGSelectStmt *)root->subquery);\n \tif (!subquery) {\n \t\treturn nullptr;\n \t}\n",
  "test_patch": "diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp\nindex a95057a43cb8..fdac2cb3a464 100644\n--- a/test/rigger/test_rigger.cpp\n+++ b/test/rigger/test_rigger.cpp\n@@ -478,4 +478,11 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tresult = con.Query(\"SELECT * FROM v0 ORDER BY 'a';\");\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {1}));\n \t}\n+\tSECTION(\"547\") {\n+\t\t// Query with SIMILAR TO results in \"Assertion `strlen(dataptr) == length' failed\"\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 SIMILAR TO '.';\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"0\"}));\n+\t}\n }\ndiff --git a/test/sql/simple/test_window.cpp b/test/sql/simple/test_window.cpp\nindex 3954ae62040d..daac17d0d028 100644\n--- a/test/sql/simple/test_window.cpp\n+++ b/test/sql/simple/test_window.cpp\n@@ -554,3 +554,44 @@ TEST_CASE(\"Test errors in binding window functions\", \"[window]\") {\n \tresult = con.Query(\"SELECT MIN(i) OVER (PARTITION BY i ORDER BY i) FROM integers\");\n \tREQUIRE(CHECK_COLUMN(result, 0, {}));\n }\n+\n+TEST_CASE(\"Test binding of named window functions in CTEs\", \"[window]\") {\n+\tunique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\tcon.EnableQueryVerification();\n+\n+\t// named window clause\n+\tresult = con.Query(\"select i, lag(i) over named_window from (values (1), (2), (3)) as t (i) window named_window as (order by i);\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value(), 1, 2}));\n+\n+\t// named window clause in CTE\n+\tresult = con.Query(\"with subquery as (select i, lag(i) over named_window from (values (1), (2), (3)) as t (i) window named_window as (order by i)) select * from subquery;\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value(), 1, 2}));\n+\n+\t// named window clause in subquery\n+\tresult = con.Query(\"select * from (select i, lag(i) over named_window from (values (1), (2), (3)) as t (i) window named_window as (order by i)) t1;\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value(), 1, 2}));\n+\n+\t// named window clause in view\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE VIEW v1 AS select i, lag(i) over named_window from (values (1), (2), (3)) as t (i) window named_window as (order by i);\"));\n+\n+\tresult = con.Query(\"select * from v1;\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value(), 1, 2}));\n+\n+\t// same window clause name multiple times but in different subqueries\n+\tresult = con.Query(\"SELECT * FROM (SELECT i, lag(i) OVER named_window FROM ( VALUES (1), (2), (3)) AS t (i) window named_window AS ( ORDER BY i)) t1, (SELECT i, lag(i) OVER named_window FROM ( VALUES (1), (2), (3)) AS t (i) window named_window AS ( ORDER BY i)) t2 ORDER BY 1, 2, 3, 4;\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 1, 1, 2, 2, 2, 3, 3, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value(), Value(), Value(), 1, 1, 1, 2, 2, 2}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {1, 2, 3, 1, 2, 3, 1, 2, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {Value(), 1, 2, Value(), 1, 2, Value(), 1, 2}));\n+\n+\t// we cannot use named window specifications of the main query inside CTEs\n+\tREQUIRE_FAIL(con.Query(\"WITH subquery AS (SELECT i, lag(i) OVER named_window FROM ( VALUES (1), (2), (3)) AS t (i)) SELECT * FROM subquery window named_window AS ( ORDER BY i);\"));\n+\t// duplicate window clause name\n+\tREQUIRE_FAIL(con.Query(\"select i, lag(i) over named_window from (values (1), (2), (3)) as t (i) window named_window as (order by i), named_window as (order by j);\"));\n+}\n",
  "problem_statement": "Named windows don't work inside WITH clauses\nConsider this simple window function query:\r\n\r\n```sql\r\nselect i, lag(i) over named_window\r\nfrom (values (1), (2), (3)) as t (i)\r\nwindow named_window as (order by i);\r\n```\r\n\r\nwhich produces this output:\r\n\r\n```\r\ni           WINDOW    \r\n----------  ----------\r\n1                     \r\n2           1         \r\n3           2   \r\n```\r\n\r\nNow suppose I put it inside a `with` clause:\r\n\r\n```sql\r\nwith subquery as (\r\n    select i, lag(i) over named_window\r\n    from (values (1), (2), (3)) as t (i)\r\n    window named_window as (order by i)\r\n)\r\nselect * from subquery;\r\n```\r\n\r\nNow it produces an error:\r\n\r\n```\r\nError: Could not find named window specification\r\n```\r\n\r\nBizarrely, if you move the window frame to the parent, it works:\r\n\r\n```sql\r\nwith subquery as (\r\n    select i, lag(i) over named_window\r\n    from (values (1), (2), (3)) as t (i)\r\n)\r\nselect * from subquery\r\nwindow named_window as (order by i);\r\n```\r\n\r\nI'm pretty sure this is a bug.\nQuery with SIMILAR TO results in \"Assertion `strlen(dataptr) == length' failed\"\nConsider the following statements:\r\n```sql\r\nCREATE TABLE t0(c0 INT);\r\nINSERT INTO t0 VALUES (0);\r\nSELECT * FROM t0 WHERE t0.c0 SIMILAR TO '.'; -- Assertion `strlen(dataptr) == length' failed\r\n```\r\nUsing the debug build, the `SELECT` fails with the following message:\r\n```\r\n/duckdb/src/common/types/string_type.cpp:24: void duckdb::string_t::Verify(): Assertion `strlen(dataptr) == length' failed.\r\n``` \r\nI found this based on commit f3c7d397a3c5ebfa72b64d04559644efee7bbe2e.\n",
  "hints_text": "Indeed, this looks like a bug! Thanks for the report. At a first glance it seems like named windows are query wide, rather than restricted to the select node as they should be. \n",
  "created_at": "2020-04-13T20:30:41Z"
}