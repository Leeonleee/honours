{
  "repo": "duckdb/duckdb",
  "pull_number": 9626,
  "instance_id": "duckdb__duckdb-9626",
  "issue_numbers": [
    "9548",
    "9548"
  ],
  "base_commit": "19862840b8901083edbda1ddd21c79e7209a0e7f",
  "patch": "diff --git a/src/include/duckdb/parser/transformer.hpp b/src/include/duckdb/parser/transformer.hpp\nindex d16dfb8c4ffb..8371796c0c62 100644\n--- a/src/include/duckdb/parser/transformer.hpp\n+++ b/src/include/duckdb/parser/transformer.hpp\n@@ -48,6 +48,7 @@ class Transformer {\n \t\tunique_ptr<SelectNode> base;\n \t\tunique_ptr<ParsedExpression> column;\n \t\tunique_ptr<QueryNode> subquery;\n+\t\tbool has_parameters;\n \t};\n \n public:\n@@ -90,7 +91,7 @@ class Transformer {\n \tbool GetParam(const string &name, idx_t &index, PreparedParamType type);\n \n \tvoid AddPivotEntry(string enum_name, unique_ptr<SelectNode> source, unique_ptr<ParsedExpression> column,\n-\t                   unique_ptr<QueryNode> subquery);\n+\t                   unique_ptr<QueryNode> subquery, bool has_parameters);\n \tunique_ptr<SQLStatement> GenerateCreateEnumStmt(unique_ptr<CreatePivotEntry> entry);\n \tbool HasPivotEntries();\n \tidx_t PivotEntryCount();\ndiff --git a/src/parser/transform/statement/transform_pivot_stmt.cpp b/src/parser/transform/statement/transform_pivot_stmt.cpp\nindex 849af1a34ff1..a554b2a6a114 100644\n--- a/src/parser/transform/statement/transform_pivot_stmt.cpp\n+++ b/src/parser/transform/statement/transform_pivot_stmt.cpp\n@@ -19,9 +19,10 @@\n namespace duckdb {\n \n void Transformer::AddPivotEntry(string enum_name, unique_ptr<SelectNode> base, unique_ptr<ParsedExpression> column,\n-                                unique_ptr<QueryNode> subquery) {\n+                                unique_ptr<QueryNode> subquery, bool has_parameters) {\n \tif (parent) {\n-\t\tparent->AddPivotEntry(std::move(enum_name), std::move(base), std::move(column), std::move(subquery));\n+\t\tparent->AddPivotEntry(std::move(enum_name), std::move(base), std::move(column), std::move(subquery),\n+\t\t                      has_parameters);\n \t\treturn;\n \t}\n \tauto result = make_uniq<CreatePivotEntry>();\n@@ -29,6 +30,7 @@ void Transformer::AddPivotEntry(string enum_name, unique_ptr<SelectNode> base, u\n \tresult->base = std::move(base);\n \tresult->column = std::move(column);\n \tresult->subquery = std::move(subquery);\n+\tresult->has_parameters = has_parameters;\n \n \tpivot_entries.push_back(std::move(result));\n }\n@@ -113,6 +115,13 @@ unique_ptr<SQLStatement> Transformer::GenerateCreateEnumStmt(unique_ptr<CreatePi\n unique_ptr<SQLStatement> Transformer::CreatePivotStatement(unique_ptr<SQLStatement> statement) {\n \tauto result = make_uniq<MultiStatement>();\n \tfor (auto &pivot : pivot_entries) {\n+\t\tif (pivot->has_parameters) {\n+\t\t\tthrow ParserException(\n+\t\t\t    \"PIVOT statements with pivot elements extracted from the data cannot have parameters in their source.\\n\"\n+\t\t\t    \"In order to use parameters the PIVOT values must be manually specified, e.g.:\\n\"\n+\t\t\t    \"PIVOT ... ON %s IN (val1, val2, ...)\",\n+\t\t\t    pivot->column->ToString());\n+\t\t}\n \t\tresult->statements.push_back(GenerateCreateEnumStmt(std::move(pivot)));\n \t}\n \tresult->statements.push_back(std::move(statement));\n@@ -125,7 +134,10 @@ unique_ptr<SQLStatement> Transformer::CreatePivotStatement(unique_ptr<SQLStateme\n \n unique_ptr<QueryNode> Transformer::TransformPivotStatement(duckdb_libpgquery::PGSelectStmt &select) {\n \tauto pivot = select.pivot;\n+\tauto current_param_count = ParamCount();\n \tauto source = TransformTableRefNode(*pivot->source);\n+\tauto next_param_count = ParamCount();\n+\tbool has_parameters = next_param_count > current_param_count;\n \n \tauto select_node = make_uniq<SelectNode>();\n \tvector<unique_ptr<CTENode>> materialized_ctes;\n@@ -171,7 +183,8 @@ unique_ptr<QueryNode> Transformer::TransformPivotStatement(duckdb_libpgquery::PG\n \t\tauto new_select = make_uniq<SelectNode>();\n \t\tExtractCTEsRecursive(new_select->cte_map);\n \t\tnew_select->from_table = source->Copy();\n-\t\tAddPivotEntry(enum_name, std::move(new_select), col.pivot_expressions[0]->Copy(), std::move(col.subquery));\n+\t\tAddPivotEntry(enum_name, std::move(new_select), col.pivot_expressions[0]->Copy(), std::move(col.subquery),\n+\t\t              has_parameters);\n \t\tcol.pivot_enum = enum_name;\n \t}\n \n",
  "test_patch": "diff --git a/test/sql/pivot/pivot_prepare.test b/test/sql/pivot/pivot_prepare.test\nindex ac460511bb50..ecfc34d75a7b 100644\n--- a/test/sql/pivot/pivot_prepare.test\n+++ b/test/sql/pivot/pivot_prepare.test\n@@ -7,27 +7,27 @@ CREATE OR REPLACE TABLE monthly_sales(empid INT, amount INT, month TEXT);\n \n statement ok\n INSERT INTO monthly_sales VALUES\n-    (1, 10000, 'JAN'),\n-    (1, 400, 'JAN'),\n-    (2, 4500, 'JAN'),\n-    (2, 35000, 'JAN'),\n-    (1, 5000, 'FEB'),\n-    (1, 3000, 'FEB'),\n-    (2, 200, 'FEB'),\n-    (2, 90500, 'FEB'),\n-    (1, 6000, 'MAR'),\n-    (1, 5000, 'MAR'),\n-    (2, 2500, 'MAR'),\n-    (2, 9500, 'MAR'),\n-    (1, 8000, 'APR'),\n-    (1, 10000, 'APR'),\n-    (2, 800, 'APR'),\n-    (2, 4500, 'APR');\n+    (1, 10000, '1-JAN'),\n+    (1, 400, '1-JAN'),\n+    (2, 4500, '1-JAN'),\n+    (2, 35000, '1-JAN'),\n+    (1, 5000, '2-FEB'),\n+    (1, 3000, '2-FEB'),\n+    (2, 200, '2-FEB'),\n+    (2, 90500, '2-FEB'),\n+    (1, 6000, '3-MAR'),\n+    (1, 5000, '3-MAR'),\n+    (2, 2500, '3-MAR'),\n+    (2, 9500, '3-MAR'),\n+    (1, 8000, '4-APR'),\n+    (1, 10000, '4-APR'),\n+    (2, 800, '4-APR'),\n+    (2, 4500, '4-APR');\n \n statement ok\n PREPARE v1 AS SELECT *\n   FROM monthly_sales\n-    PIVOT(SUM(amount + ?) FOR MONTH IN ('JAN', 'FEB', 'MAR', 'APR'))\n+    PIVOT(SUM(amount + ?) FOR MONTH IN ('1-JAN', '2-FEB', '3-MAR', '4-APR'))\n       AS p\n   ORDER BY EMPID;\n \n@@ -43,3 +43,21 @@ EXECUTE v1(1)\n ----\n 1\t10402\t8002\t11002\t18002\n 2\t39502\t90702\t12002\t5302\n+\n+# prepare top-level pivot stmt\n+statement ok\n+PREPARE v2 AS\n+   PIVOT monthly_sales ON MONTH USING SUM(AMOUNT + ?)\n+\n+query IIIII rowsort\n+EXECUTE v2(1)\n+----\n+1\t10402\t8002\t11002\t18002\n+2\t39502\t90702\t12002\t5302\n+\n+# parameters within subquery of top-level pivot statement not supported\n+statement error\n+PREPARE v3 AS\n+   PIVOT (SELECT empid, amount + ? AS amount, month FROM monthly_sales) ON MONTH USING SUM(AMOUNT)\n+----\n+cannot have parameters in their source\n",
  "problem_statement": "PIVOT subquery parameter doesn't work\n### What happens?\n\nI see a strange error when I try to use a parameter in a PIVOT subquery clause, ie \r\n```\r\nrows, err = db.Query(\"PIVOT (select * from users where 1=1 and user in (?)) t ON year using sum(clicks) group by name\", \"u1\")\r\n```\r\nI get `panic: Binder Error: Could not find parameter with identifier 1`\r\n\r\nAs I understand the error is thrown by the DuckDB:\r\n![image](https://github.com/duckdb/duckdb/assets/14215045/8b397678-e2c5-42fd-80d6-b238b95736e3)\r\n\r\nI used the Go client with the version:\r\n![image](https://github.com/duckdb/duckdb/assets/14215045/6de0ba80-d449-4452-b94a-066acaffaf1c)\r\n\r\n\n\n### To Reproduce\n\nThis Go code reproduces the bug:\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"database/sql\"\r\n    \"fmt\"\r\n    _ \"github.com/marcboeker/go-duckdb\"\r\n)\r\n\r\nfunc main() {\r\n    db, err := sql.Open(\"duckdb\", \"\")\r\n    if err != nil {\r\n        fmt.Println(err)\r\n        return\r\n    }\r\n\r\n    stmt, err := db.Prepare(\"CREATE TABLE users (name varchar, clicks integer, year integer)\")\r\n    if err != nil {\r\n        fmt.Println(err)\r\n        return\r\n    }\r\n    defer stmt.Close()\r\n\r\n    _, err = stmt.Exec()\r\n    if err != nil {\r\n        fmt.Println(err)\r\n        return\r\n    }\r\n\r\n    stmt, err = db.Prepare(`INSERT INTO users (name, clicks, year) VALUES ('u1', 1, 1), ('u1', 2, 2)`)\r\n    if err != nil {\r\n        fmt.Println(err)\r\n        return\r\n    }\r\n    defer stmt.Close()\r\n\r\n    _, err = stmt.Exec()\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n\r\n    rows, err := db.Query(\"select * from users where 1=1 and user in (?)\", \"u1\")\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n    defer rows.Close()\r\n\r\n    rows, err = db.Query(\"PIVOT (select * from users where 1=1 and user in ('u1')) t ON year using sum(clicks) group by name limit ?\", 10)\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n    defer rows.Close()\r\n\r\n    rows, err = db.Query(\"PIVOT (select * from users where 1=1 and user in ('u1')) t ON year using sum(clicks) group by name \")\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n    defer rows.Close()\r\n\r\n    rows, err = db.Query(\"PIVOT (select * from users where 1=1 and user in (?)) t ON year using sum(clicks) group by name\", \"u1\")\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n    defer rows.Close()\r\n}\r\n```\n\n### OS:\n\nmacOS\n\n### DuckDB Version:\n\n0.9.1\n\n### DuckDB Client:\n\nGo\n\n### Full Name:\n\nEgor Ryashin\n\n### Affiliation:\n\nRilldata\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a release build (and could not test with a main build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\nPIVOT subquery parameter doesn't work\n### What happens?\n\nI see a strange error when I try to use a parameter in a PIVOT subquery clause, ie \r\n```\r\nrows, err = db.Query(\"PIVOT (select * from users where 1=1 and user in (?)) t ON year using sum(clicks) group by name\", \"u1\")\r\n```\r\nI get `panic: Binder Error: Could not find parameter with identifier 1`\r\n\r\nAs I understand the error is thrown by the DuckDB:\r\n![image](https://github.com/duckdb/duckdb/assets/14215045/8b397678-e2c5-42fd-80d6-b238b95736e3)\r\n\r\nI used the Go client with the version:\r\n![image](https://github.com/duckdb/duckdb/assets/14215045/6de0ba80-d449-4452-b94a-066acaffaf1c)\r\n\r\n\n\n### To Reproduce\n\nThis Go code reproduces the bug:\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"database/sql\"\r\n    \"fmt\"\r\n    _ \"github.com/marcboeker/go-duckdb\"\r\n)\r\n\r\nfunc main() {\r\n    db, err := sql.Open(\"duckdb\", \"\")\r\n    if err != nil {\r\n        fmt.Println(err)\r\n        return\r\n    }\r\n\r\n    stmt, err := db.Prepare(\"CREATE TABLE users (name varchar, clicks integer, year integer)\")\r\n    if err != nil {\r\n        fmt.Println(err)\r\n        return\r\n    }\r\n    defer stmt.Close()\r\n\r\n    _, err = stmt.Exec()\r\n    if err != nil {\r\n        fmt.Println(err)\r\n        return\r\n    }\r\n\r\n    stmt, err = db.Prepare(`INSERT INTO users (name, clicks, year) VALUES ('u1', 1, 1), ('u1', 2, 2)`)\r\n    if err != nil {\r\n        fmt.Println(err)\r\n        return\r\n    }\r\n    defer stmt.Close()\r\n\r\n    _, err = stmt.Exec()\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n\r\n    rows, err := db.Query(\"select * from users where 1=1 and user in (?)\", \"u1\")\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n    defer rows.Close()\r\n\r\n    rows, err = db.Query(\"PIVOT (select * from users where 1=1 and user in ('u1')) t ON year using sum(clicks) group by name limit ?\", 10)\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n    defer rows.Close()\r\n\r\n    rows, err = db.Query(\"PIVOT (select * from users where 1=1 and user in ('u1')) t ON year using sum(clicks) group by name \")\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n    defer rows.Close()\r\n\r\n    rows, err = db.Query(\"PIVOT (select * from users where 1=1 and user in (?)) t ON year using sum(clicks) group by name\", \"u1\")\r\n    if err != nil {\r\n        panic(err)\r\n    }\r\n    defer rows.Close()\r\n}\r\n```\n\n### OS:\n\nmacOS\n\n### DuckDB Version:\n\n0.9.1\n\n### DuckDB Client:\n\nGo\n\n### Full Name:\n\nEgor Ryashin\n\n### Affiliation:\n\nRilldata\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a release build (and could not test with a main build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "`WITH t AS (select * from users where 1=1 and user in (?)) PIVOT t ON year using sum(clicks) group by name` doesn't work too.\n`WITH t AS (select * from users where 1=1 and user in (?)) PIVOT t ON year using sum(clicks) group by name` doesn't work too.",
  "created_at": "2023-11-09T15:46:31Z"
}