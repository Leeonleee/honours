You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
add support for `INTERVAL` in node.js bindings
#### What happens?

While calculation some durations between timestamps in node.js, I had an error thrown `[Error: Data type is not supported INTERVAL]`.  Which makes sense: there is no `INTERVAL` case in [`statement.cpp`](https://github.com/duckdb/duckdb/blob/master/tools/nodejs/src/statement.cpp#L146).

Seems like a pretty easy thing to add. I would be happy to submit a PR that adds it, but figured I'd ask: what would be the right translation between duckdb and napi here? A single number in micros (or milis), or something else?

#### To Reproduce

```javascript
import duckdb from 'duckdb';

const db = new duckdb.Database(':memory:');
var con = db.connect();
con
  .prepare(" SELECT TIMESTAMP '1992-09-20 11:30:00' - TIMESTAMP '1992-09-20 14:30:00';")
  .all(console.log);
```


#### Environment (please complete the following information):
 - OS: Mac OS X Catalina
 - DuckDB Version: 0.3.1
 - DuckDB Client: Node.js

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of tools/nodejs/src/statement.cpp]
1: #include "duckdb_node.hpp"
2: 
3: namespace node_duckdb {
4: 
5: Napi::FunctionReference Statement::constructor;
6: 
7: Napi::Object Statement::Init(Napi::Env env, Napi::Object exports) {
8: 	Napi::HandleScope scope(env);
9: 
10: 	Napi::Function t =
11: 	    DefineClass(env, "Statement",
12: 	                {InstanceMethod("run", &Statement::Run), InstanceMethod("all", &Statement::All),
13: 	                 InstanceMethod("each", &Statement::Each), InstanceMethod("finalize", &Statement::Finalize_)});
14: 
15: 	constructor = Napi::Persistent(t);
16: 	constructor.SuppressDestruct();
17: 
18: 	exports.Set("Statement", t);
19: 	return exports;
20: }
21: 
22: struct PrepareTask : public Task {
23: 	PrepareTask(Statement &statement_, Napi::Function callback_) : Task(statement_, callback_) {
24: 	}
25: 
26: 	void DoWork() override {
27: 		auto &statement = Get<Statement>();
28: 		statement.statement = statement.connection_ref->connection->Prepare(statement.sql);
29: 	}
30: 
31: 	void Callback() override {
32: 		auto &statement = Get<Statement>();
33: 		auto env = statement.Env();
34: 		Napi::HandleScope scope(env);
35: 
36: 		auto cb = callback.Value();
37: 		if (!statement.statement->success) {
38: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, statement.statement->error)});
39: 			return;
40: 		}
41: 		cb.MakeCallback(statement.Value(), {env.Null(), statement.Value()});
42: 	}
43: };
44: 
45: Statement::Statement(const Napi::CallbackInfo &info) : Napi::ObjectWrap<Statement>(info) {
46: 
47: 	Napi::Env env = info.Env();
48: 	int length = info.Length();
49: 
50: 	if (length <= 0 || !Connection::HasInstance(info[0])) {
51: 		Napi::TypeError::New(env, "Connection object expected").ThrowAsJavaScriptException();
52: 		return;
53: 	} else if (length <= 1 || !info[1].IsString()) {
54: 		Napi::TypeError::New(env, "SQL query expected").ThrowAsJavaScriptException();
55: 		return;
56: 	}
57: 
58: 	connection_ref = Napi::ObjectWrap<Connection>::Unwrap(info[0].As<Napi::Object>());
59: 	connection_ref->Ref();
60: 
61: 	sql = info[1].As<Napi::String>();
62: 
63: 	Napi::Function callback;
64: 	if (info.Length() > 1 && info[2].IsFunction()) {
65: 		callback = info[2].As<Napi::Function>();
66: 	}
67: 
68: 	// TODO we can have parameters here as well. Forward if that is the case.
69: 	Value().As<Napi::Object>().DefineProperty(
70: 	    Napi::PropertyDescriptor::Value("sql", info[1].As<Napi::String>(), napi_default));
71: 	connection_ref->database_ref->Schedule(env, duckdb::make_unique<PrepareTask>(*this, callback));
72: }
73: 
74: Statement::~Statement() {
75: 	connection_ref->Unref();
76: 	connection_ref = nullptr;
77: }
78: 
79: // A Napi InstanceOf for Javascript Objects "Date" and "RegExp"
80: static bool other_instance_of(Napi::Object source, const char *object_type) {
81: 	if (strcmp(object_type, "Date") == 0) {
82: 		return source.InstanceOf(source.Env().Global().Get(object_type).As<Napi::Function>());
83: 	} else if (strcmp(object_type, "RegExp") == 0) {
84: 		return source.InstanceOf(source.Env().Global().Get(object_type).As<Napi::Function>());
85: 	}
86: 
87: 	return false;
88: }
89: 
90: static duckdb::Value bind_parameter(const Napi::Value source) {
91: 	if (source.IsString()) {
92: 		return duckdb::Value(source.As<Napi::String>().Utf8Value());
93: 	} else if (other_instance_of(source.As<Napi::Object>(), "RegExp")) {
94: 		return duckdb::Value(source.ToString().Utf8Value());
95: 	} else if (source.IsNumber()) {
96: 		if (Utils::OtherIsInt(source.As<Napi::Number>())) {
97: 			return duckdb::Value::INTEGER(source.As<Napi::Number>().Int32Value());
98: 		} else {
99: 			return duckdb::Value::DOUBLE(source.As<Napi::Number>().DoubleValue());
100: 		}
101: 	} else if (source.IsBoolean()) {
102: 		return duckdb::Value::BOOLEAN(source.As<Napi::Boolean>().Value());
103: 	} else if (source.IsNull()) {
104: 		return duckdb::Value();
105: 	} else if (source.IsBuffer()) {
106: 		Napi::Buffer<char> buffer = source.As<Napi::Buffer<char>>();
107: 		return duckdb::Value::BLOB(std::string(buffer.Data(), buffer.Length()));
108: #if (NAPI_VERSION > 4)
109: 	} else if (source.IsDate()) {
110: 		const auto micros = int64_t(source.As<Napi::Date>().ValueOf()) * duckdb::Interval::MICROS_PER_MSEC;
111: 		if (micros % duckdb::Interval::MICROS_PER_DAY) {
112: 			return duckdb::Value::TIMESTAMP(duckdb::timestamp_t(micros));
113: 		} else {
114: 			const auto days = int32_t(micros / duckdb::Interval::MICROS_PER_DAY);
115: 			return duckdb::Value::DATE(duckdb::date_t(days));
116: 		}
117: #endif
118: 	} else if (source.IsObject()) {
119: 		return duckdb::Value(source.ToString().Utf8Value());
120: 	}
121: 	return duckdb::Value();
122: }
123: 
124: static Napi::Value convert_chunk(Napi::Env &env, std::vector<std::string> names, duckdb::DataChunk &chunk) {
125: 	Napi::EscapableHandleScope scope(env);
126: 	std::vector<Napi::String> node_names;
127: 	assert(names.size() == chunk.ColumnCount());
128: 	for (auto &name : names) {
129: 		node_names.push_back(Napi::String::New(env, name));
130: 	}
131: 	Napi::Array result(Napi::Array::New(env, chunk.size()));
132: 
133: 	for (duckdb::idx_t row_idx = 0; row_idx < chunk.size(); row_idx++) {
134: 		Napi::Object row_result = Napi::Object::New(env);
135: 
136: 		for (duckdb::idx_t col_idx = 0; col_idx < chunk.ColumnCount(); col_idx++) {
137: 			Napi::Value value;
138: 
139: 			auto dval = chunk.GetValue(col_idx, row_idx);
140: 			if (dval.is_null) {
141: 				row_result.Set(node_names[col_idx], env.Null());
142: 				continue;
143: 			}
144: 
145: 			// TODO templateroo here
146: 			switch (chunk.data[col_idx].GetType().id()) {
147: 			case duckdb::LogicalTypeId::INTEGER: {
148: 				value = Napi::Number::New(env, dval.value_.integer);
149: 			} break;
150: 			case duckdb::LogicalTypeId::FLOAT: {
151: 				value = Napi::Number::New(env, dval.value_.float_);
152: 			} break;
153: 			case duckdb::LogicalTypeId::DOUBLE: {
154: 				value = Napi::Number::New(env, dval.value_.double_);
155: 			} break;
156: 			case duckdb::LogicalTypeId::BIGINT: {
157: 				value = Napi::Number::New(env, dval.value_.bigint);
158: 			} break;
159: 			case duckdb::LogicalTypeId::HUGEINT: {
160: 				value = Napi::Number::New(env, dval.GetValue<double>());
161: 			} break;
162: #if (NAPI_VERSION > 4)
163: 			case duckdb::LogicalTypeId::DATE: {
164: 				const auto scale = duckdb::Interval::SECS_PER_DAY * duckdb::Interval::MSECS_PER_SEC;
165: 				value = Napi::Date::New(env, double(dval.GetValue<int32_t>() * scale));
166: 			} break;
167: 			case duckdb::LogicalTypeId::TIMESTAMP: {
168: 				value = Napi::Date::New(env, double(dval.GetValue<int64_t>() / duckdb::Interval::MICROS_PER_MSEC));
169: 			} break;
170: #endif
171: 			case duckdb::LogicalTypeId::VARCHAR: {
172: 				value = Napi::String::New(env, dval.str_value);
173: 			} break;
174: 			case duckdb::LogicalTypeId::BOOLEAN: {
175: 				value = Napi::Boolean::New(env, dval.value_.boolean);
176: 			} break;
177: 			case duckdb::LogicalTypeId::BLOB: {
178: 				value = Napi::Buffer<char>::Copy(env, dval.str_value.c_str(), dval.str_value.length());
179: 			} break;
180: 			case duckdb::LogicalTypeId::SQLNULL: {
181: 				value = env.Null();
182: 			} break;
183: 			default:
184: 				Napi::Error::New(env, "Data type is not supported " + dval.type().ToString())
185: 				    .ThrowAsJavaScriptException();
186: 				return env.Null();
187: 			}
188: 			row_result.Set(node_names[col_idx], value);
189: 		}
190: 		result.Set(row_idx, row_result);
191: 	}
192: 
193: 	return scope.Escape(result);
194: }
195: 
196: enum RunType { RUN, EACH, ALL };
197: 
198: struct StatementParam {
199: 	std::vector<duckdb::Value> params;
200: 	Napi::Function callback;
201: 	Napi::Function complete;
202: };
203: 
204: struct RunPreparedTask : public Task {
205: 	RunPreparedTask(Statement &statement_, duckdb::unique_ptr<StatementParam> params_, RunType run_type_)
206: 	    : Task(statement_, params_->callback), params(move(params_)), run_type(run_type_) {
207: 	}
208: 
209: 	void DoWork() override {
210: 		auto &statement = Get<Statement>();
211: 		// ignorant folk arrive here without caring about the prepare callback error
212: 		if (!statement.statement || !statement.statement->success) {
213: 			return;
214: 		}
215: 
216: 		result = statement.statement->Execute(params->params, run_type != RunType::ALL);
217: 	}
218: 
219: 	void Callback() override {
220: 		auto &statement = Get<Statement>();
221: 		Napi::Env env = statement.Env();
222: 		Napi::HandleScope scope(env);
223: 
224: 		auto cb = callback.Value();
225: 		// if there was an error we need to say so
226: 		if (!statement.statement) {
227: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, "statement was finalized")});
228: 			return;
229: 		}
230: 		if (!statement.statement->success) {
231: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, statement.statement->error)});
232: 			return;
233: 		}
234: 		if (!statement.statement->success) {
235: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, statement.statement->error)});
236: 			return;
237: 		}
238: 		if (!result->success) {
239: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, result->error)});
240: 			return;
241: 		}
242: 
243: 		switch (run_type) {
244: 		case RunType::RUN:
245: 			cb.MakeCallback(statement.Value(), {env.Null()});
246: 			break;
247: 		case RunType::EACH: {
248: 			duckdb::idx_t count = 0;
249: 			while (true) {
250: 				auto chunk = result->Fetch();
251: 				if (!chunk || chunk->size() == 0) {
252: 					break;
253: 				}
254: 
255: 				auto chunk_converted = convert_chunk(env, result->names, *chunk).ToObject();
256: 				if (!chunk_converted.IsArray()) {
257: 					// error was set before
258: 					return;
259: 				}
260: 				for (duckdb::idx_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
261: 					cb.MakeCallback(statement.Value(), {env.Null(), chunk_converted.Get(row_idx)});
262: 					count++;
263: 				}
264: 			}
265: 			if (!params->complete.IsUndefined() && params->complete.IsFunction()) {
266: 				params->complete.MakeCallback(statement.Value(), {env.Null(), Napi::Number::New(env, count)});
267: 			}
268: 			break;
269: 		}
270: 		case RunType::ALL: {
271: 			auto materialized_result = (duckdb::MaterializedQueryResult *)result.get();
272: 			Napi::Array result_arr(Napi::Array::New(env, materialized_result->collection.Count()));
273: 
274: 			duckdb::idx_t out_idx = 0;
275: 			while (true) {
276: 				auto chunk = result->Fetch();
277: 				if (!chunk || chunk->size() == 0) {
278: 					break;
279: 				}
280: 				// ToObject has to happen here otherwise the converted chunk gets garbage collected for some reason
281: 				auto chunk_converted = convert_chunk(env, result->names, *chunk).ToObject();
282: 				if (!chunk_converted.IsArray()) {
283: 					// error was set before
284: 					return;
285: 				}
286: 				for (duckdb::idx_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
287: 					result_arr.Set(out_idx++, chunk_converted.Get(row_idx));
288: 				}
289: 			}
290: 
291: 			cb.MakeCallback(statement.Value(), {env.Null(), result_arr});
292: 		} break;
293: 		}
294: 	}
295: 	std::unique_ptr<duckdb::QueryResult> result;
296: 	duckdb::unique_ptr<StatementParam> params;
297: 	RunType run_type;
298: };
299: 
300: duckdb::unique_ptr<StatementParam> Statement::HandleArgs(const Napi::CallbackInfo &info) {
301: 	size_t start_idx = ignore_first_param ? 1 : 0;
302: 	auto params = duckdb::make_unique<StatementParam>();
303: 
304: 	for (auto i = start_idx; i < info.Length(); i++) {
305: 		auto &p = info[i];
306: 		if (p.IsFunction()) {
307: 			if (!params->callback.IsUndefined()) { // we already saw a callback, so this is the finalizer
308: 				params->complete = p.As<Napi::Function>();
309: 			} else {
310: 				params->callback = p.As<Napi::Function>();
311: 			}
312: 			continue;
313: 		}
314: 		if (p.IsUndefined()) {
315: 			continue;
316: 		}
317: 		params->params.push_back(bind_parameter(p));
318: 	}
319: 	return params;
320: }
321: 
322: Napi::Value Statement::All(const Napi::CallbackInfo &info) {
323: 	connection_ref->database_ref->Schedule(info.Env(),
324: 	                                       duckdb::make_unique<RunPreparedTask>(*this, HandleArgs(info), RunType::ALL));
325: 	return info.This();
326: }
327: 
328: Napi::Value Statement::Run(const Napi::CallbackInfo &info) {
329: 	auto params = HandleArgs(info);
330: 	connection_ref->database_ref->Schedule(info.Env(),
331: 	                                       duckdb::make_unique<RunPreparedTask>(*this, HandleArgs(info), RunType::RUN));
332: 	return info.This();
333: }
334: 
335: Napi::Value Statement::Each(const Napi::CallbackInfo &info) {
336: 	auto params = HandleArgs(info);
337: 	connection_ref->database_ref->Schedule(
338: 	    info.Env(), duckdb::make_unique<RunPreparedTask>(*this, HandleArgs(info), RunType::EACH));
339: 	return info.This();
340: }
341: 
342: struct FinalizeTask : public Task {
343: 	FinalizeTask(Statement &statement_, Napi::Function callback_) : Task(statement_, callback_) {
344: 	}
345: 
346: 	void DoWork() override {
347: 		// TODO why does this break stuff?
348: 		// Get<Statement>().statement.reset();
349: 	}
350: };
351: 
352: Napi::Value Statement::Finalize_(const Napi::CallbackInfo &info) {
353: 	Napi::Env env = info.Env();
354: 	Napi::HandleScope scope(env);
355: 
356: 	Napi::Function callback;
357: 
358: 	if (info.Length() > 0 && info[0].IsFunction()) {
359: 		callback = info[0].As<Napi::Function>();
360: 	}
361: 
362: 	connection_ref->database_ref->Schedule(env, duckdb::make_unique<FinalizeTask>(*this, callback));
363: 	return env.Null();
364: }
365: 
366: } // namespace node_duckdb
[end of tools/nodejs/src/statement.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: