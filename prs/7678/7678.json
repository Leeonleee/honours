{
  "repo": "duckdb/duckdb",
  "pull_number": 7678,
  "instance_id": "duckdb__duckdb-7678",
  "issue_numbers": [
    "7567",
    "7567"
  ],
  "base_commit": "aac029220ae28679b98bfbb68cdee5572ecfcccf",
  "patch": "diff --git a/src/catalog/catalog_search_path.cpp b/src/catalog/catalog_search_path.cpp\nindex b7c6a882e3df..f02a07390955 100644\n--- a/src/catalog/catalog_search_path.cpp\n+++ b/src/catalog/catalog_search_path.cpp\n@@ -126,37 +126,57 @@ void CatalogSearchPath::Reset() {\n \tSetPaths(empty);\n }\n \n-void CatalogSearchPath::Set(vector<CatalogSearchEntry> new_paths, bool is_set_schema) {\n-\tif (is_set_schema && new_paths.size() != 1) {\n-\t\tthrow CatalogException(\"SET schema can set only 1 schema. This has %d\", new_paths.size());\n+string CatalogSearchPath::GetSetName(CatalogSetPathType set_type) {\n+\tswitch (set_type) {\n+\tcase CatalogSetPathType::SET_SCHEMA:\n+\t\treturn \"SET schema\";\n+\tcase CatalogSetPathType::SET_SCHEMAS:\n+\t\treturn \"SET search_path\";\n+\tdefault:\n+\t\tthrow InternalException(\"Unrecognized CatalogSetPathType\");\n+\t}\n+}\n+\n+void CatalogSearchPath::Set(vector<CatalogSearchEntry> new_paths, CatalogSetPathType set_type) {\n+\tif (set_type != CatalogSetPathType::SET_SCHEMAS && new_paths.size() != 1) {\n+\t\tthrow CatalogException(\"%s can set only 1 schema. This has %d\", GetSetName(set_type), new_paths.size());\n \t}\n \tfor (auto &path : new_paths) {\n-\t\tif (!Catalog::GetSchema(context, path.catalog, path.schema, OnEntryNotFound::RETURN_NULL)) {\n+\t\tauto schema_entry = Catalog::GetSchema(context, path.catalog, path.schema, OnEntryNotFound::RETURN_NULL);\n+\t\tif (schema_entry) {\n+\t\t\t// we are setting a schema - update the catalog and schema\n \t\t\tif (path.catalog.empty()) {\n-\t\t\t\t// only schema supplied - check if this is a database instead\n-\t\t\t\tauto schema = Catalog::GetSchema(context, path.schema, DEFAULT_SCHEMA, OnEntryNotFound::RETURN_NULL);\n+\t\t\t\tpath.catalog = GetDefault().catalog;\n+\t\t\t}\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// only schema supplied - check if this is a catalog instead\n+\t\tif (path.catalog.empty()) {\n+\t\t\tauto catalog = Catalog::GetCatalogEntry(context, path.schema);\n+\t\t\tif (catalog) {\n+\t\t\t\tauto schema = catalog->GetSchema(context, DEFAULT_SCHEMA, OnEntryNotFound::RETURN_NULL);\n \t\t\t\tif (schema) {\n \t\t\t\t\tpath.catalog = std::move(path.schema);\n \t\t\t\t\tpath.schema = schema->name;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tthrow CatalogException(\"SET %s: No catalog + schema named %s found.\",\n-\t\t\t                       is_set_schema ? \"schema\" : \"search_path\", path.ToString());\n \t\t}\n+\t\tthrow CatalogException(\"%s: No catalog + schema named \\\"%s\\\" found.\", GetSetName(set_type), path.ToString());\n \t}\n-\tif (is_set_schema) {\n+\tif (set_type == CatalogSetPathType::SET_SCHEMA) {\n \t\tif (new_paths[0].catalog == TEMP_CATALOG || new_paths[0].catalog == SYSTEM_CATALOG) {\n-\t\t\tthrow CatalogException(\"SET schema cannot be set to internal schema \\\"%s\\\"\", new_paths[0].catalog);\n+\t\t\tthrow CatalogException(\"%s cannot be set to internal schema \\\"%s\\\"\", GetSetName(set_type),\n+\t\t\t                       new_paths[0].catalog);\n \t\t}\n \t}\n \tthis->set_paths = std::move(new_paths);\n \tSetPaths(set_paths);\n }\n \n-void CatalogSearchPath::Set(CatalogSearchEntry new_value, bool is_set_schema) {\n+void CatalogSearchPath::Set(CatalogSearchEntry new_value, CatalogSetPathType set_type) {\n \tvector<CatalogSearchEntry> new_paths {std::move(new_value)};\n-\tSet(std::move(new_paths), is_set_schema);\n+\tSet(std::move(new_paths), set_type);\n }\n \n const vector<CatalogSearchEntry> &CatalogSearchPath::Get() {\ndiff --git a/src/include/duckdb/catalog/catalog_search_path.hpp b/src/include/duckdb/catalog/catalog_search_path.hpp\nindex 9d27f01eda8c..e3a2cf2029e7 100644\n--- a/src/include/duckdb/catalog/catalog_search_path.hpp\n+++ b/src/include/duckdb/catalog/catalog_search_path.hpp\n@@ -35,14 +35,16 @@ struct CatalogSearchEntry {\n \tstatic string WriteOptionallyQuoted(const string &input);\n };\n \n+enum class CatalogSetPathType { SET_SCHEMA, SET_SCHEMAS };\n+\n //! The schema search path, in order by which entries are searched if no schema entry is provided\n class CatalogSearchPath {\n public:\n \tDUCKDB_API explicit CatalogSearchPath(ClientContext &client_p);\n \tCatalogSearchPath(const CatalogSearchPath &other) = delete;\n \n-\tDUCKDB_API void Set(CatalogSearchEntry new_value, bool is_set_schema);\n-\tDUCKDB_API void Set(vector<CatalogSearchEntry> new_paths, bool is_set_schema = false);\n+\tDUCKDB_API void Set(CatalogSearchEntry new_value, CatalogSetPathType set_type);\n+\tDUCKDB_API void Set(vector<CatalogSearchEntry> new_paths, CatalogSetPathType set_type);\n \tDUCKDB_API void Reset();\n \n \tDUCKDB_API const vector<CatalogSearchEntry> &Get();\n@@ -59,6 +61,8 @@ class CatalogSearchPath {\n private:\n \tvoid SetPaths(vector<CatalogSearchEntry> new_paths);\n \n+\tstring GetSetName(CatalogSetPathType set_type);\n+\n private:\n \tClientContext &context;\n \tvector<CatalogSearchEntry> paths;\ndiff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp\nindex 52e093ac2350..c9de04480177 100644\n--- a/src/main/settings/settings.cpp\n+++ b/src/main/settings/settings.cpp\n@@ -988,7 +988,7 @@ void SchemaSetting::ResetLocal(ClientContext &context) {\n void SchemaSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto parameter = input.ToString();\n \tauto &client_data = ClientData::Get(context);\n-\tclient_data.catalog_search_path->Set(CatalogSearchEntry::Parse(parameter), true);\n+\tclient_data.catalog_search_path->Set(CatalogSearchEntry::Parse(parameter), CatalogSetPathType::SET_SCHEMA);\n }\n \n Value SchemaSetting::GetSetting(ClientContext &context) {\n@@ -1008,7 +1008,7 @@ void SearchPathSetting::ResetLocal(ClientContext &context) {\n void SearchPathSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto parameter = input.ToString();\n \tauto &client_data = ClientData::Get(context);\n-\tclient_data.catalog_search_path->Set(CatalogSearchEntry::ParseList(parameter), false);\n+\tclient_data.catalog_search_path->Set(CatalogSearchEntry::ParseList(parameter), CatalogSetPathType::SET_SCHEMAS);\n }\n \n Value SearchPathSetting::GetSetting(ClientContext &context) {\ndiff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp\nindex fa6256175c0b..af0594947ce7 100644\n--- a/tools/jdbc/src/jni/duckdb_java.cpp\n+++ b/tools/jdbc/src/jni/duckdb_java.cpp\n@@ -361,16 +361,16 @@ JNIEXPORT jstring JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1get_1schema\n \treturn env->NewStringUTF(entry.schema.c_str());\n }\n \n-static void set_catalog_search_path(JNIEnv *env, jobject conn_ref_buf, CatalogSearchEntry search_entry,\n-                                    bool is_set_schema) {\n+static void set_catalog_search_path(JNIEnv *env, jobject conn_ref_buf, CatalogSearchEntry search_entry) {\n \tauto conn_ref = get_connection(env, conn_ref_buf);\n \tif (!conn_ref) {\n \t\treturn;\n \t}\n \n \ttry {\n-\t\tconn_ref->context->RunFunctionInTransaction(\n-\t\t    [&]() { ClientData::Get(*conn_ref->context).catalog_search_path->Set(search_entry, is_set_schema); });\n+\t\tconn_ref->context->RunFunctionInTransaction([&]() {\n+\t\t\tClientData::Get(*conn_ref->context).catalog_search_path->Set(search_entry, CatalogSetPathType::SET_SCHEMA);\n+\t\t});\n \t} catch (const exception &e) {\n \t\tenv->ThrowNew(J_SQLException, e.what());\n \t}\n@@ -378,14 +378,12 @@ static void set_catalog_search_path(JNIEnv *env, jobject conn_ref_buf, CatalogSe\n \n JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1set_1schema(JNIEnv *env, jclass, jobject conn_ref_buf,\n                                                                               jstring schema) {\n-\tset_catalog_search_path(env, conn_ref_buf, CatalogSearchEntry(INVALID_CATALOG, jstring_to_string(env, schema)),\n-\t                        true);\n+\tset_catalog_search_path(env, conn_ref_buf, CatalogSearchEntry(INVALID_CATALOG, jstring_to_string(env, schema)));\n }\n \n JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1set_1catalog(JNIEnv *env, jclass,\n                                                                                jobject conn_ref_buf, jstring catalog) {\n-\tset_catalog_search_path(env, conn_ref_buf, CatalogSearchEntry(jstring_to_string(env, catalog), DEFAULT_SCHEMA),\n-\t                        false);\n+\tset_catalog_search_path(env, conn_ref_buf, CatalogSearchEntry(jstring_to_string(env, catalog), DEFAULT_SCHEMA));\n }\n \n JNIEXPORT jstring JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1get_1catalog(JNIEnv *env, jclass,\n",
  "test_patch": "diff --git a/test/sql/attach/attach_issue7567.test b/test/sql/attach/attach_issue7567.test\nnew file mode 100644\nindex 000000000000..5411e757bfca\n--- /dev/null\n+++ b/test/sql/attach/attach_issue7567.test\n@@ -0,0 +1,28 @@\n+# name: test/sql/attach/attach_issue7567.test\n+# description: Issue #7567 - Setting the current schema should not change the current database\n+# group: [attach]\n+\n+require noforcestorage\n+\n+statement ok\n+attach ':memory:' as test;\n+\n+statement ok\n+use test;\n+\n+statement ok\n+create schema schema1;\n+\n+statement ok\n+create table schema1.table1 as select 1 as a;\n+\n+statement error\n+set schema='schema2';\n+----\n+No catalog + schema named \"schema2\" found\n+\n+statement ok\n+set schema='schema1';\n+\n+statement ok\n+select * from table1;\ndiff --git a/test/sql/attach/show_databases.test b/test/sql/attach/show_databases.test\nindex b46fe5ded031..00da9fab864d 100644\n--- a/test/sql/attach/show_databases.test\n+++ b/test/sql/attach/show_databases.test\n@@ -37,4 +37,4 @@ SELECT * FROM new_database.tbl\n statement error\n USE blablabla\n ----\n-does not exist\n+No catalog + schema named \"blablabla\" found\ndiff --git a/test/sqlite/sqllogic_command.cpp b/test/sqlite/sqllogic_command.cpp\nindex d18352bcad8b..6dbfd2860e07 100644\n--- a/test/sqlite/sqllogic_command.cpp\n+++ b/test/sqlite/sqllogic_command.cpp\n@@ -269,7 +269,7 @@ void RestartCommand::ExecuteInternal(ExecuteContext &context) const {\n \trunner.con->context->config = client_config;\n \n \trunner.con->BeginTransaction();\n-\trunner.con->context->client_data->catalog_search_path->Set(catalog_search_paths);\n+\trunner.con->context->client_data->catalog_search_path->Set(catalog_search_paths, CatalogSetPathType::SET_SCHEMAS);\n \trunner.con->Commit();\n \tif (!low_query_writer_path.empty()) {\n \t\trunner.con->context->client_data->log_query_writer = make_uniq<BufferedFileWriter>(\n",
  "problem_statement": "Setting the current schema should not change the current database (or should it?)\n### What happens?\n\nIn the current multi-attach world, a user can set the database they want to default to when not specifying the database they mean (`USE def_catalog`). Similarly, users could change the default schema by using `set schema=def_schema`. Sadly, this updates the search path with `\"\",\"def_schema\"` and overrides the catalog part. I would expect `\"def_catalog\",\"def_schema\"` to be added.\r\n\r\nFinally enough, the code for validating the input of the set schema command does resolve using the current default database (which is how it finds the schema) but then it \"forgets\". \n\n### To Reproduce\n\n```\r\n~/src/md/duckdb (master) \u00bb ./build/debug/duckdb                                                                                                                                     boaz@boaz-air\r\nv0.7.2-dev3786 6e908cfc55\r\nEnter \".help\" for usage hints.\r\nConnected to a transient in-memory database.\r\nUse \".open FILENAME\" to reopen on a persistent database.\r\nD attach ':memory:' as test;\r\nD use test;\r\nD create schema schema1;\r\nD create table schema1.table1 as select 1 as a;\r\nD set schema='schema1';\r\nD select * from table1;\r\nError: Catalog Error: Table with name table1 does not exist!\r\nDid you mean \"test.schema1.table1\"?\r\nLINE 1: select * from table1;\r\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\nmaster\n\n### DuckDB Client:\n\ncli\n\n### Full Name:\n\nBoaz Leskes\n\n### Affiliation:\n\nMotherDuck\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nSetting the current schema should not change the current database (or should it?)\n### What happens?\n\nIn the current multi-attach world, a user can set the database they want to default to when not specifying the database they mean (`USE def_catalog`). Similarly, users could change the default schema by using `set schema=def_schema`. Sadly, this updates the search path with `\"\",\"def_schema\"` and overrides the catalog part. I would expect `\"def_catalog\",\"def_schema\"` to be added.\r\n\r\nFinally enough, the code for validating the input of the set schema command does resolve using the current default database (which is how it finds the schema) but then it \"forgets\". \n\n### To Reproduce\n\n```\r\n~/src/md/duckdb (master) \u00bb ./build/debug/duckdb                                                                                                                                     boaz@boaz-air\r\nv0.7.2-dev3786 6e908cfc55\r\nEnter \".help\" for usage hints.\r\nConnected to a transient in-memory database.\r\nUse \".open FILENAME\" to reopen on a persistent database.\r\nD attach ':memory:' as test;\r\nD use test;\r\nD create schema schema1;\r\nD create table schema1.table1 as select 1 as a;\r\nD set schema='schema1';\r\nD select * from table1;\r\nError: Catalog Error: Table with name table1 does not exist!\r\nDid you mean \"test.schema1.table1\"?\r\nLINE 1: select * from table1;\r\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\nmaster\n\n### DuckDB Client:\n\ncli\n\n### Full Name:\n\nBoaz Leskes\n\n### Affiliation:\n\nMotherDuck\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "\n",
  "created_at": "2023-05-25T12:21:58Z"
}