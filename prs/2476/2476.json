{
  "repo": "duckdb/duckdb",
  "pull_number": 2476,
  "instance_id": "duckdb__duckdb-2476",
  "issue_numbers": [
    "2467"
  ],
  "base_commit": "e85da326d988cba5b291170a45595ddaad5ed53a",
  "patch": "diff --git a/tools/pythonpkg/src/vector_conversion.cpp b/tools/pythonpkg/src/vector_conversion.cpp\nindex 7e6d0f29aeea..f60a5be65185 100644\n--- a/tools/pythonpkg/src/vector_conversion.cpp\n+++ b/tools/pythonpkg/src/vector_conversion.cpp\n@@ -88,6 +88,11 @@ void ScanPandasFpColumn(T *src_ptr, idx_t count, idx_t offset, Vector &out) {\n \t}\n }\n \n+struct PyStringGIL {\n+\tpy::gil_scoped_acquire acquire;\n+\tpy::str str_val;\n+};\n+\n template <class T>\n static string_t DecodePythonUnicode(T *codepoints, idx_t codepoint_count, Vector &out) {\n \t// first figure out how many bytes to allocate\n@@ -192,8 +197,8 @@ void VectorConversion::NumpyToDuckDB(PandasColumnBindData &bind_data, py::array\n \t\tauto tgt_ptr = FlatVector::GetData<string_t>(out);\n \t\tauto &out_mask = FlatVector::Validity(out);\n \t\tfor (idx_t row = 0; row < count; row++) {\n+\t\t\tunique_ptr<PyStringGIL> py_str;\n \t\t\tauto source_idx = offset + row;\n-\t\t\tpy::str str_val;\n \t\t\tPyObject *val = src_ptr[source_idx];\n \t\t\tif (bind_data.pandas_type == PandasType::OBJECT && !PyUnicode_CheckExact(val)) {\n \t\t\t\tif (val == Py_None) {\n@@ -205,10 +210,10 @@ void VectorConversion::NumpyToDuckDB(PandasColumnBindData &bind_data, py::array\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tif (!py::isinstance<py::str>(val)) {\n-\t\t\t\t\tpy::gil_scoped_acquire acquire;\n+\t\t\t\t\tpy_str = make_unique<PyStringGIL>();\n \t\t\t\t\tpy::handle object_handle = val;\n-\t\t\t\t\tstr_val = py::str(object_handle);\n-\t\t\t\t\tval = str_val.ptr();\n+\t\t\t\t\tpy_str->str_val = py::str(object_handle);\n+\t\t\t\t\tval = py_str->str_val.ptr();\n \t\t\t\t}\n \t\t\t}\n \t\t\t// Python 3 string representation:\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/pandas/test_pandas_string.py b/tools/pythonpkg/tests/fast/pandas/test_pandas_string.py\nindex 017dbee22f62..8097c38a0ccb 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_pandas_string.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_pandas_string.py\n@@ -19,3 +19,18 @@ def test_pandas_string(self, duckdb_cursor):\n         assert numpy.all(df_out['object'] == strings)\n         if hasattr(pd, 'StringDtype'):\n             assert numpy.all(df_out['string'] == strings)\n+\n+    def test_bug_2467(self, duckdb_cursor):\n+        N = 1_000_000\n+        # Create DataFrame with string attribute\n+        df = pd.DataFrame({\"city\": [\"Amsterdam\", \"New York\", \"London\"] * N})\n+        # Copy Dataframe to DuckDB\n+        con = duckdb.connect()\n+        con.register(\"df\", df)\n+        con.execute(f\"\"\"\n+            CREATE TABLE t1 AS SELECT * FROM df\n+        \"\"\"\n+        )\n+        assert con.execute(f\"\"\"\n+            SELECT count(*) from t1\n+        \"\"\").fetchall() == [(3000000,)]\n\\ No newline at end of file\n",
  "problem_statement": "Segfault when importing data from DataFrame\n#### What happens?\r\nWhen copying a DataFrame with string attributes I get a segmentation fault error.\r\nIf I transform the string attribute into a category then the program works fine. \r\n\r\n#### To Reproduce\r\nResults in a segmentation fault:\r\n```Python3\r\nimport duckdb\r\nimport pandas as pd\r\n\r\nN = 1_000_000\r\n\r\n# Create DataFrame without category attribute\r\ndf = pd.DataFrame({\"city\": [\"Amsterdam\", \"New York\", \"London\"] * N})\r\n# Copy Dataframe to DuckDB\r\ncon = duckdb.connect()\r\ncon.register(\"df\", df)\r\ncon.execute(f\"\"\"\r\n    CREATE TABLE t1 AS SELECT * FROM df\r\n\"\"\"\r\n)\r\n```\r\n\r\n```sh\r\n[1]    2369 segmentation fault  python3 segfault.py\r\n```\r\n\r\nWorks perfectly fine:\r\n```Python3\r\nimport duckdb\r\nimport pandas as pd\r\n\r\nN = 1_000_000\r\n\r\n# Create DataFrame without category attribute\r\ndf = pd.DataFrame({\"city\": [\"Amsterdam\", \"New York\", \"London\"] * N})\r\ndf['city'] = df['city'].astype('category') # This is the only change\r\n# Copy Dataframe to DuckDB\r\ncon = duckdb.connect()\r\ncon.register(\"df\", df)\r\ncon.execute(f\"\"\"\r\n    CREATE TABLE t1 AS SELECT * FROM df\r\n\"\"\"\r\n)\r\n```\r\n\r\n\r\n#### Environment:\r\n- OS: Mac BigSur 11.4\r\n- DuckDB Version: '0.3.1-dev287'\r\n- DuckDB Client: Python3\n",
  "hints_text": "Hi @Manerone , can you try this with the latest duckdb version. It seems to work for me.\r\n```  pip install duckdb --pre ```\nHi @pdet, I tried again and got the same error. If it helps this are the packages I have installed:\r\n```\r\nduckdb==0.3.1.dev353\r\nnumpy==1.21.3\r\npandas==1.3.4\r\npython-dateutil==2.8.2\r\npytz==2021.3\r\nsix==1.16.0\r\n```\r\n\r\nIt looks like DuckdDB version changed since I created the issue, but I still get the error.\r\nIf it is of any help, this is a part of the stack trace:\r\n```\r\nThread 0:: Dispatch queue: com.apple.main-thread\r\n0   org.python.python             \t0x000000010bc62114 delitem_common + 221\r\n1   org.python.python             \t0x000000010bc61c8b _PyDict_DelItem_KnownHash + 171\r\n2   org.python.python             \t0x000000010bca3174 unicode_dealloc + 48\r\n3   duckdb.cpython-39-darwin.so   \t0x00000001169ce133 duckdb::VectorConversion::NumpyToDuckDB(duckdb::PandasColumnBindData&, pybind11::array&, unsigned long long, unsigned long long, duckdb::Vector&) + 707\r\n4   duckdb.cpython-39-darwin.so   \t0x00000001169a970b duckdb::PandasScanFunction::PandasScanFuncParallel(duckdb::ClientContext&, duckdb::FunctionData const*, duckdb::FunctionOperatorData*, duckdb::DataChunk*, duckdb::DataChunk&, duckdb::ParallelState*) + 155\r\n5   duckdb.cpython-39-darwin.so   \t0x0000000115dd7dd5 duckdb::PhysicalTableScan::GetData(duckdb::ExecutionContext&, duckdb::DataChunk&, duckdb::GlobalSourceState&, duckdb::LocalSourceState&) const + 85\r\n6   duckdb.cpython-39-darwin.so   \t0x000000011631f01d duckdb::PipelineExecutor::FetchFromSource(duckdb::DataChunk&) + 77\r\n7   duckdb.cpython-39-darwin.so   \t0x00000001163661a9 duckdb::PipelineTask::ExecuteTask() + 121\r\n8   duckdb.cpython-39-darwin.so   \t0x000000011631cb0a duckdb::ExecutorTask::Execute() + 26\r\n9   duckdb.cpython-39-darwin.so   \t0x0000000116318863 duckdb::Executor::Initialize(duckdb::PhysicalOperator*) + 787\r\n10  duckdb.cpython-39-darwin.so   \t0x0000000116273b1f duckdb::ClientContext::ExecutePreparedStatement(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::shared_ptr<duckdb::PreparedStatementData>, std::__1::vector<duckdb::Value, std::__1::allocator<duckdb::Value> >, bool) + 255\r\n11  duckdb.cpython-39-darwin.so   \t0x0000000116276230 duckdb::ClientContext::RunStatementOrPreparedStatement(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >, std::__1::shared_ptr<duckdb::PreparedStatementData>&, std::__1::vector<duckdb::Value, std::__1::allocator<duckdb::Value> >*, bool) + 1312\r\n12  duckdb.cpython-39-darwin.so   \t0x00000001162759f8 duckdb::ClientContext::Execute(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::shared_ptr<duckdb::PreparedStatementData>&, std::__1::vector<duckdb::Value, std::__1::allocator<duckdb::Value> >&, bool) + 232\r\n13  duckdb.cpython-39-darwin.so   \t0x0000000116268ab7 duckdb::PreparedStatement::Execute(std::__1::vector<duckdb::Value, std::__1::allocator<duckdb::Value> >&, bool) + 71\r\n14  duckdb.cpython-39-darwin.so   \t0x00000001169ac004 duckdb::DuckDBPyConnection::Execute(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, pybind11::object, bool) + 1428\r\n15  duckdb.cpython-39-darwin.so   \t0x00000001169b7686 duckdb::DuckDBPyConnection* \r\n```\nmaybe try \r\n``` pip install duckdb --pre --upgrade ```\r\n\r\nor be sure to have a clean install by deleting all previous duckdb installs\nI confirm the same issue with Duckdb version 0.3.0 and 0.2.9. \r\nWhen downgraded to 0.2.8 the same script works without crashing.",
  "created_at": "2021-10-23T07:49:14Z"
}