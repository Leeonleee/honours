You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Invalid json output for cli -json
### What happens?

Example cli output:

```
┌──────────────────────┬───────────────┐
│          a           │       b       │
│        double        │ decimal(38,2) │
├──────────────────────┼───────────────┤
│ 0.013835631366566025 │     -29641.68 │
│ 0.014779952408172961 │     -10296.42 │
│ 0.003024374814074319 │      -5077.02 │
│ 0.010121712177079566 │      -2664.09 │
│ 0.034948037785923564 │       -795.75 │
│                  0.0 │       -531.77 │
│                  0.0 │       -437.56 │
│                  0.0 │        -75.62 │
│                 -nan │          0.00 │
│                 -nan │          0.00 │
├──────────────────────┴───────────────┤
│ 10 rows                    2 columns │
└──────────────────────────────────────┘

```
becomes with -json

```json
[{"a":0.013835631366566025,"b":-29641.68},
{"a":0.014779952408172961,"b":-10296.42},
{"a":0.003024374814074319,"b":-5077.02},
{"a":0.010121712177079566,"b":-2664.09},
{"a":0.034948037785923564,"b":-795.75},
{"a":0.0,"b":-531.77},
{"a":0.0,"b":-437.56},
{"a":0.0,"b":-75.62},
{"a":-nan,"b":0.00},
{"a":-nan,"b":0.00}]
```

E.g. php json parser does not accept "-nan" as a number.

https://datatracker.ietf.org/doc/html/rfc8259 says: Numeric values that cannot be represented in the grammar below (such
   as Infinity and NaN) are not permitted.

### To Reproduce

```bash
duckdb :memory: "select 0.0 / 0.0" -json
```

```text
[{"(0.0 / 0.0)":-nan}]
```

### OS:

Ubuntu

### DuckDB Version:

1.1.3

### DuckDB Client:

cli

### Hardware:

_No response_

### Full Name:

Thomas Bley

### Affiliation:

myself

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [ ] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of tools/shell/shell.cpp]
1: /* DO NOT EDIT!
2: ** This file is automatically generated by the script in the canonical
3: ** SQLite source tree at tool/mkshellc.tcl.  That script combines source
4: ** code from various constituent source files of SQLite into this single
5: ** "shell.c" file used to implement the SQLite command-line shell.
6: **
7: ** Most of the code found below comes from the "src/shell.c.in" file in
8: ** the canonical SQLite source tree.  That main file contains "INCLUDE"
9: ** lines that specify other files in the canonical source tree that are
10: ** inserted to getnerate this complete program source file.
11: **
12: ** The code from multiple files is combined into this single "shell.c"
13: ** source file to help make the command-line program easier to compile.
14: **
15: ** To modify this program, get a copy of the canonical SQLite source tree,
16: ** edit the src/shell.c.in" and/or some of the other files that are included
17: ** by "src/shell.c.in", then rerun the tool/mkshellc.tcl script.
18: */
19: /*
20: ** 2001 September 15
21: **
22: ** The author disclaims copyright to this source code.  In place of
23: ** a legal notice, here is a blessing:
24: **
25: **    May you do good and not evil.
26: **    May you find forgiveness for yourself and forgive others.
27: **    May you share freely, never taking more than you give.
28: **
29: *************************************************************************
30: ** This file contains code to implement the "sqlite" command line
31: ** utility for accessing SQLite databases.
32: */
33: #if (defined(_WIN32) || defined(WIN32)) && !defined(_CRT_SECURE_NO_WARNINGS)
34: /* This needs to come before any includes for MSVC compiler */
35: #define _CRT_SECURE_NO_WARNINGS
36: #endif
37: 
38: /*
39: ** Determine if we are dealing with WinRT, which provides only a subset of
40: ** the full Win32 API.
41: */
42: #if !defined(SQLITE_OS_WINRT)
43: #define SQLITE_OS_WINRT 0
44: #endif
45: 
46: /*
47: ** Warning pragmas copied from msvc.h in the core.
48: */
49: #if defined(_MSC_VER)
50: #pragma warning(disable : 4054)
51: #pragma warning(disable : 4055)
52: #pragma warning(disable : 4100)
53: #pragma warning(disable : 4127)
54: #pragma warning(disable : 4130)
55: #pragma warning(disable : 4152)
56: #pragma warning(disable : 4189)
57: #pragma warning(disable : 4206)
58: #pragma warning(disable : 4210)
59: #pragma warning(disable : 4232)
60: #pragma warning(disable : 4244)
61: #pragma warning(disable : 4305)
62: #pragma warning(disable : 4306)
63: #pragma warning(disable : 4702)
64: #pragma warning(disable : 4706)
65: #endif /* defined(_MSC_VER) */
66: 
67: /*
68: ** Enable large-file support for fopen() and friends on unix.
69: */
70: #ifndef SQLITE_DISABLE_LFS
71: #define _LARGE_FILE 1
72: #ifndef _FILE_OFFSET_BITS
73: #define _FILE_OFFSET_BITS 64
74: #endif
75: #define _LARGEFILE_SOURCE 1
76: #endif
77: 
78: #include <stdlib.h>
79: #include <string.h>
80: #include <stdio.h>
81: #include <assert.h>
82: #include "duckdb_shell_wrapper.h"
83: #include "duckdb/common/box_renderer.hpp"
84: #include "sqlite3.h"
85: typedef sqlite3_int64 i64;
86: typedef sqlite3_uint64 u64;
87: typedef unsigned char u8;
88: #include <ctype.h>
89: 
90: #if !defined(_WIN32) && !defined(WIN32)
91: #include <signal.h>
92: #if !defined(__RTP__) && !defined(_WRS_KERNEL)
93: #include <pwd.h>
94: #endif
95: #endif
96: #if (!defined(_WIN32) && !defined(WIN32)) || defined(__MINGW32__)
97: #include <unistd.h>
98: #include <dirent.h>
99: #endif
100: #if defined(__MINGW32__)
101: #define DIRENT dirent
102: #ifndef S_ISLNK
103: #define S_ISLNK(mode) (0)
104: #endif
105: #endif
106: #include <sys/types.h>
107: #include <sys/stat.h>
108: 
109: #if HAVE_READLINE
110: #include <readline/readline.h>
111: #include <readline/history.h>
112: #endif
113: 
114: #if HAVE_EDITLINE
115: #include <editline/readline.h>
116: #endif
117: 
118: #if HAVE_EDITLINE || HAVE_READLINE
119: 
120: #define shell_add_history(X)    add_history(X)
121: #define shell_read_history(X)   read_history(X)
122: #define shell_write_history(X)  write_history(X)
123: #define shell_stifle_history(X) stifle_history(X)
124: #define shell_readline(X)       readline(X)
125: 
126: #elif HAVE_LINENOISE
127: 
128: #include "linenoise.h"
129: #define shell_add_history(X)    linenoiseHistoryAdd(X)
130: #define shell_read_history(X)   linenoiseHistoryLoad(X)
131: #define shell_write_history(X)  linenoiseHistorySave(X)
132: #define shell_stifle_history(X) linenoiseHistorySetMaxLen(X)
133: #define shell_readline(X)       linenoise(X)
134: 
135: #else
136: 
137: #define shell_read_history(X)
138: #define shell_write_history(X)
139: #define shell_stifle_history(X)
140: 
141: #define SHELL_USE_LOCAL_GETLINE 1
142: #endif
143: 
144: #include "shell_renderer.hpp"
145: #include "shell_highlight.hpp"
146: #include "shell_state.hpp"
147: 
148: using namespace duckdb_shell;
149: 
150: #if defined(_WIN32) || defined(WIN32)
151: #if SQLITE_OS_WINRT
152: #define SQLITE_OMIT_POPEN 1
153: #else
154: #include <io.h>
155: #include <fcntl.h>
156: #define isatty(h) _isatty(h)
157: #ifndef access
158: #define access(f, m) _access((f), (m))
159: #endif
160: #ifndef unlink
161: #define unlink _unlink
162: #endif
163: #ifndef strdup
164: #define strdup _strdup
165: #endif
166: #undef popen
167: #define popen _popen
168: #undef pclose
169: #define pclose _pclose
170: #endif
171: #else
172: /* Make sure isatty() has a prototype. */
173: extern int isatty(int);
174: 
175: #if !defined(__RTP__) && !defined(_WRS_KERNEL)
176: /* popen and pclose are not C89 functions and so are
177: ** sometimes omitted from the <stdio.h> header */
178: extern FILE *popen(const char *, const char *);
179: extern int pclose(FILE *);
180: #else
181: #define SQLITE_OMIT_POPEN 1
182: #endif
183: #endif
184: 
185: #if defined(_WIN32_WCE)
186: /* Windows CE (arm-wince-mingw32ce-gcc) does not provide isatty()
187:  * thus we always assume that we have a console. That can be
188:  * overridden with the -batch command line option.
189:  */
190: #define isatty(x) 1
191: #endif
192: 
193: #if defined(_WIN32) || defined(WIN32)
194: #if SQLITE_OS_WINRT
195: #include <intrin.h>
196: #endif
197: #include <windows.h>
198: 
199: /* string conversion routines only needed on Win32 */
200: extern char *sqlite3_win32_unicode_to_utf8(LPCWSTR);
201: extern char *sqlite3_win32_mbcs_to_utf8_v2(const char *, int);
202: extern char *sqlite3_win32_utf8_to_mbcs_v2(const char *, int);
203: extern LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText);
204: #endif
205: 
206: /* On Windows, we normally run with output mode of TEXT so that \n characters
207: ** are automatically translated into \r\n.  However, this behavior needs
208: ** to be disabled in some cases (ex: when generating CSV output and when
209: ** rendering quoted strings that contain \n characters).  The following
210: ** routines take care of that.
211: */
212: #if (defined(_WIN32) || defined(WIN32)) && !SQLITE_OS_WINRT
213: static void setBinaryMode(FILE *file, int isOutput) {
214: 	if (isOutput)
215: 		fflush(file);
216: 	_setmode(_fileno(file), _O_BINARY);
217: }
218: static void setTextMode(FILE *file, int isOutput) {
219: 	if (isOutput)
220: 		fflush(file);
221: 	_setmode(_fileno(file), _O_TEXT);
222: }
223: #else
224: #define setBinaryMode(X, Y)
225: #define setTextMode(X, Y)
226: #endif
227: 
228: /* True if the timer is enabled */
229: static bool enableTimer = false;
230: 
231: /* Return the current wall-clock time */
232: static sqlite3_int64 timeOfDay(void) {
233: 	static sqlite3_vfs *clockVfs = nullptr;
234: 	sqlite3_int64 t;
235: 	if (!clockVfs) {
236: 		clockVfs = sqlite3_vfs_find(0);
237: 	}
238: 	if (clockVfs->iVersion >= 2 && clockVfs->xCurrentTimeInt64 != 0) {
239: 		clockVfs->xCurrentTimeInt64(clockVfs, &t);
240: 	} else {
241: 		double r;
242: 		clockVfs->xCurrentTime(clockVfs, &r);
243: 		t = (sqlite3_int64)(r * 86400000.0);
244: 	}
245: 	return t;
246: }
247: 
248: #if !defined(_WIN32) && !defined(WIN32) && !defined(__minux)
249: #include <sys/time.h>
250: #include <sys/resource.h>
251: 
252: /* VxWorks does not support getrusage() as far as we can determine */
253: #if defined(_WRS_KERNEL) || defined(__RTP__)
254: struct rusage {
255: 	struct timeval ru_utime; /* user CPU time used */
256: 	struct timeval ru_stime; /* system CPU time used */
257: };
258: #define getrusage(A, B) memset(B, 0, sizeof(*B))
259: #endif
260: 
261: /* Saved resource information for the beginning of an operation */
262: static struct rusage sBegin; /* CPU time at start */
263: static sqlite3_int64 iBegin; /* Wall-clock time at start */
264: 
265: /*
266: ** Begin timing an operation
267: */
268: static void beginTimer(void) {
269: 	if (enableTimer) {
270: 		getrusage(RUSAGE_SELF, &sBegin);
271: 		iBegin = timeOfDay();
272: 	}
273: }
274: 
275: /* Return the difference of two time_structs in seconds */
276: static double timeDiff(struct timeval *pStart, struct timeval *pEnd) {
277: 	return (pEnd->tv_usec - pStart->tv_usec) * 0.000001 + (double)(pEnd->tv_sec - pStart->tv_sec);
278: }
279: 
280: /*
281: ** Print the timing results.
282: */
283: static void endTimer(void) {
284: 	if (enableTimer) {
285: 		sqlite3_int64 iEnd = timeOfDay();
286: 		struct rusage sEnd;
287: 		getrusage(RUSAGE_SELF, &sEnd);
288: 		printf("Run Time (s): real %.3f user %f sys %f\n", (iEnd - iBegin) * 0.001,
289: 		       timeDiff(&sBegin.ru_utime, &sEnd.ru_utime), timeDiff(&sBegin.ru_stime, &sEnd.ru_stime));
290: 	}
291: }
292: 
293: #define BEGIN_TIMER beginTimer()
294: #define END_TIMER   endTimer()
295: #define HAS_TIMER   1
296: 
297: #elif (defined(_WIN32) || defined(WIN32))
298: 
299: /* Saved resource information for the beginning of an operation */
300: static HANDLE hProcess;
301: static FILETIME ftKernelBegin;
302: static FILETIME ftUserBegin;
303: static sqlite3_int64 ftWallBegin;
304: typedef BOOL(WINAPI *GETPROCTIMES)(HANDLE, LPFILETIME, LPFILETIME, LPFILETIME, LPFILETIME);
305: static GETPROCTIMES getProcessTimesAddr = NULL;
306: 
307: /*
308: ** Check to see if we have timer support.  Return 1 if necessary
309: ** support found (or found previously).
310: */
311: static int hasTimer(void) {
312: 	if (getProcessTimesAddr) {
313: 		return 1;
314: 	} else {
315: #if !SQLITE_OS_WINRT
316: 		/* GetProcessTimes() isn't supported in WIN95 and some other Windows
317: 		** versions. See if the version we are running on has it, and if it
318: 		** does, save off a pointer to it and the current process handle.
319: 		*/
320: 		hProcess = GetCurrentProcess();
321: 		if (hProcess) {
322: 			HINSTANCE hinstLib = LoadLibrary(TEXT("Kernel32.dll"));
323: 			if (NULL != hinstLib) {
324: 				getProcessTimesAddr = (GETPROCTIMES)GetProcAddress(hinstLib, "GetProcessTimes");
325: 				if (NULL != getProcessTimesAddr) {
326: 					return 1;
327: 				}
328: 				FreeLibrary(hinstLib);
329: 			}
330: 		}
331: #endif
332: 	}
333: 	return 0;
334: }
335: 
336: /*
337: ** Begin timing an operation
338: */
339: static void beginTimer(void) {
340: 	if (enableTimer && getProcessTimesAddr) {
341: 		FILETIME ftCreation, ftExit;
342: 		getProcessTimesAddr(hProcess, &ftCreation, &ftExit, &ftKernelBegin, &ftUserBegin);
343: 		ftWallBegin = timeOfDay();
344: 	}
345: }
346: 
347: /* Return the difference of two FILETIME structs in seconds */
348: static double timeDiff(FILETIME *pStart, FILETIME *pEnd) {
349: 	sqlite_int64 i64Start = *((sqlite_int64 *)pStart);
350: 	sqlite_int64 i64End = *((sqlite_int64 *)pEnd);
351: 	return (double)((i64End - i64Start) / 10000000.0);
352: }
353: 
354: /*
355: ** Print the timing results.
356: */
357: static void endTimer(void) {
358: 	if (enableTimer && getProcessTimesAddr) {
359: 		FILETIME ftCreation, ftExit, ftKernelEnd, ftUserEnd;
360: 		sqlite3_int64 ftWallEnd = timeOfDay();
361: 		getProcessTimesAddr(hProcess, &ftCreation, &ftExit, &ftKernelEnd, &ftUserEnd);
362: 		printf("Run Time (s): real %.3f user %f sys %f\n", (ftWallEnd - ftWallBegin) * 0.001,
363: 		       timeDiff(&ftUserBegin, &ftUserEnd), timeDiff(&ftKernelBegin, &ftKernelEnd));
364: 	}
365: }
366: 
367: #define BEGIN_TIMER beginTimer()
368: #define END_TIMER   endTimer()
369: #define HAS_TIMER   hasTimer()
370: 
371: #else
372: #define BEGIN_TIMER
373: #define END_TIMER
374: #define HAS_TIMER 0
375: #endif
376: 
377: /*
378: ** Used to prevent warnings about unused parameters
379: */
380: #define UNUSED_PARAMETER(x) (void)(x)
381: 
382: /*
383: ** Number of elements in an array
384: */
385: #define ArraySize(X) (int)(sizeof(X) / sizeof(X[0]))
386: 
387: /*
388: ** If the following flag is set, then command execution stops
389: ** at an error if we are not interactive.
390: */
391: static bool bail_on_error = false;
392: 
393: /*
394: ** Treat stdin as an interactive input if the following variable
395: ** is true.  Otherwise, assume stdin is connected to a file or pipe.
396: */
397: static bool stdin_is_interactive = true;
398: 
399: /*
400: ** On Windows systems we have to know if standard output is a console
401: ** in order to translate UTF-8 into MBCS.  The following variable is
402: ** true if translation is required.
403: */
404: static bool stdout_is_console = true;
405: static bool stderr_is_console = true;
406: 
407: /*
408: ** The following is the open SQLite database.  We make a pointer
409: ** to this database a static variable so that it can be accessed
410: ** by the SIGINT handler to interrupt database processing.
411: */
412: static sqlite3 *globalDb = nullptr;
413: 
414: /*
415: ** True if an interrupt (Control-C) has been received.
416: */
417: static volatile int seenInterrupt = 0;
418: 
419: /*
420: ** This is the name of our program. It is set in main(), used
421: ** in a number of other places, mostly for error messages.
422: */
423: static const char *program_name;
424: 
425: enum class OptionType { DEFAULT, ON, OFF };
426: 
427: /*
428: ** Whether or not we are running in safe mode
429: */
430: static bool safe_mode = false;
431: 
432: /*
433: ** Whether or not we are highlighting errors
434: */
435: static OptionType highlight_errors = OptionType::DEFAULT;
436: 
437: static bool HighlightErrors() {
438: 	if (highlight_errors == OptionType::DEFAULT) {
439: 		return stderr_is_console;
440: 	}
441: 	return highlight_errors == OptionType::ON;
442: }
443: 
444: /*
445: ** Whether or not we are highlighting results
446: */
447: static OptionType highlight_results = OptionType::DEFAULT;
448: 
449: static bool HighlightResults() {
450: 	if (highlight_results == OptionType::DEFAULT) {
451: 		return stdout_is_console;
452: 	}
453: 	return highlight_results == OptionType::ON;
454: }
455: 
456: /*
457: ** Prompt strings. Initialized in main. Settable with
458: **   .prompt main continue
459: */
460: static char mainPrompt[20];             /* First line prompt. default: "D "*/
461: static char continuePrompt[20];         /* Continuation prompt. default: "   ...> " */
462: static char continuePromptSelected[20]; /* Selected continuation prompt. default: "   ...> " */
463: 
464: /*
465: ** Render output like fprintf().  Except, if the output is going to the
466: ** console and if this is running on a Windows machine, translate the
467: ** output from UTF-8 into MBCS.
468: */
469: #if defined(_WIN32) || defined(WIN32)
470: static int win_utf8_mode = 0;
471: 
472: void utf8_printf(FILE *out, const char *zFormat, ...) {
473: 	va_list ap;
474: 	va_start(ap, zFormat);
475: 	if (stdout_is_console && (out == stdout || out == stderr)) {
476: 		char *z1 = sqlite3_vmprintf(zFormat, ap);
477: 		if (win_utf8_mode && SetConsoleOutputCP(CP_UTF8)) {
478: 			// we can write UTF8 directly
479: 			fputs(z1, out);
480: 		} else {
481: 			// fallback to writing old style windows unicode
482: 			char *z2 = sqlite3_win32_utf8_to_mbcs_v2(z1, 0);
483: 			fputs(z2, out);
484: 			sqlite3_free(z2);
485: 		}
486: 		sqlite3_free(z1);
487: 	} else {
488: 		vfprintf(out, zFormat, ap);
489: 	}
490: 	va_end(ap);
491: }
492: #elif !defined(utf8_printf)
493: #define utf8_printf fprintf
494: #endif
495: 
496: /*
497: ** Render output like fprintf().  This should not be used on anything that
498: ** includes string formatting (e.g. "%s").
499: */
500: #if !defined(raw_printf)
501: #define raw_printf fprintf
502: #endif
503: 
504: /* Indicate out-of-memory and exit. */
505: static void shell_out_of_memory(void) {
506: 	raw_printf(stderr, "Error: out of memory\n");
507: 	exit(1);
508: }
509: 
510: ShellState::ShellState() {
511: 	nullValue = "NULL";
512: }
513: 
514: void ShellState::Print(PrintOutput output, const char *str) {
515: 	utf8_printf(output == PrintOutput::STDOUT ? out : stderr, "%s", str);
516: }
517: 
518: void ShellState::Print(PrintOutput output, const string &str) {
519: 	Print(output, str.c_str());
520: }
521: 
522: void ShellState::Print(const char *str) {
523: 	Print(PrintOutput::STDOUT, str);
524: }
525: 
526: void ShellState::Print(const string &str) {
527: 	Print(PrintOutput::STDOUT, str.c_str());
528: }
529: 
530: void ShellState::PrintValue(const char *str) {
531: 	Print(str ? str : nullValue.c_str());
532: }
533: 
534: void ShellState::PrintPadded(const char *str, idx_t len) {
535: 	utf8_printf(out, "%*s", int(len), str);
536: }
537: 
538: /*
539: ** Output string zUtf to stream pOut as w characters.  If w is negative,
540: ** then right-justify the text.  W is the width in UTF-8 characters, not
541: ** in bytes.  This is different from the %*.*s specification in printf
542: ** since with %*.*s the width is measured in bytes, not characters.
543: */
544: void ShellState::UTF8WidthPrint(FILE *pOut, idx_t w, const string &str, bool right_align) {
545: 	auto zUtf = str.c_str();
546: 	int i;
547: 	int n;
548: 	int aw = w < 0 ? -w : w;
549: 	char zBuf[1000];
550: 	if (aw > (int)sizeof(zBuf) / 3)
551: 		aw = (int)sizeof(zBuf) / 3;
552: #ifdef HAVE_LINENOISE
553: 	i = linenoiseGetRenderPosition(zUtf, strlen(zUtf), aw, &n);
554: 	if (i < 0)
555: #endif
556: 		for (i = n = 0; zUtf[i]; i++) {
557: 			if ((zUtf[i] & 0xc0) != 0x80) {
558: 				n++;
559: 				if (n == aw) {
560: 					do {
561: 						i++;
562: 					} while ((zUtf[i] & 0xc0) == 0x80);
563: 					break;
564: 				}
565: 			}
566: 		}
567: 	if (n >= aw) {
568: 		utf8_printf(pOut, "%.*s", i, zUtf);
569: 	} else if (right_align) {
570: 		utf8_printf(pOut, "%*s%s", aw - n, "", zUtf);
571: 	} else {
572: 		utf8_printf(pOut, "%s%*s", zUtf, aw - n, "");
573: 	}
574: }
575: 
576: /*
577: ** Determines if a string is a number of not.
578: */
579: bool ShellState::IsNumber(const char *z, int *realnum) {
580: 	if (*z == '-' || *z == '+')
581: 		z++;
582: 	if (!IsDigit(*z)) {
583: 		return false;
584: 	}
585: 	z++;
586: 	if (realnum)
587: 		*realnum = 0;
588: 	while (IsDigit(*z)) {
589: 		z++;
590: 	}
591: 	if (*z == '.') {
592: 		z++;
593: 		if (!IsDigit(*z))
594: 			return false;
595: 		while (IsDigit(*z)) {
596: 			z++;
597: 		}
598: 		if (realnum)
599: 			*realnum = 1;
600: 	}
601: 	if (*z == 'e' || *z == 'E') {
602: 		z++;
603: 		if (*z == '+' || *z == '-')
604: 			z++;
605: 		if (!IsDigit(*z))
606: 			return false;
607: 		while (IsDigit(*z)) {
608: 			z++;
609: 		}
610: 		if (realnum)
611: 			*realnum = 1;
612: 	}
613: 	return *z == 0;
614: }
615: 
616: /*
617: ** Compute a string length that is limited to what can be stored in
618: ** lower 30 bits of a 32-bit signed integer.
619: */
620: idx_t ShellState::StringLength(const char *z) {
621: 	return strlen(z);
622: }
623: 
624: /*
625: ** Return the length of a string in characters.
626: */
627: idx_t ShellState::RenderLength(const char *z) {
628: #ifdef HAVE_LINENOISE
629: 	return linenoiseComputeRenderWidth(z, strlen(z));
630: #else
631: 	int n = 0;
632: 	while (*z) {
633: 		if ((0xc0 & *(z++)) != 0x80)
634: 			n++;
635: 	}
636: 	return n;
637: #endif
638: }
639: 
640: idx_t ShellState::RenderLength(const string &str) {
641: 	return RenderLength(str.c_str());
642: }
643: 
644: /*
645: ** Return true if zFile does not exist or if it is not an ordinary file.
646: */
647: #ifdef _WIN32
648: #define notNormalFile(X) 0
649: #else
650: static int notNormalFile(const char *zFile) {
651: 	struct stat x;
652: 	int rc;
653: 	memset(&x, 0, sizeof(x));
654: 	rc = stat(zFile, &x);
655: 	return rc || !S_ISREG(x.st_mode);
656: }
657: #endif
658: 
659: /*
660: ** This routine reads a line of text from FILE in, stores
661: ** the text in memory obtained from malloc() and returns a pointer
662: ** to the text.  NULL is returned at end of file, or if malloc()
663: ** fails.
664: **
665: ** If zLine is not NULL then it is a malloced buffer returned from
666: ** a previous call to this routine that may be reused.
667: */
668: static char *local_getline(char *zLine, FILE *in) {
669: 	idx_t nLine = zLine == 0 ? 0 : 100;
670: 	idx_t n = 0;
671: 
672: #if defined(_WIN32) || defined(WIN32)
673: 	int is_stdin = stdin_is_interactive && in == stdin;
674: 	int is_utf8 = 0;
675: 	if (is_stdin && win_utf8_mode) {
676: 		if (SetConsoleCP(CP_UTF8)) {
677: 			is_utf8 = 1;
678: 		}
679: 	}
680: #endif
681: 	while (1) {
682: 		if (n + 100 > nLine) {
683: 			nLine = nLine * 2 + 100;
684: 			zLine = (char *)realloc(zLine, nLine);
685: 			if (zLine == 0)
686: 				shell_out_of_memory();
687: 		}
688: 		if (fgets(&zLine[n], nLine - n, in) == 0) {
689: 			if (n == 0) {
690: 				free(zLine);
691: 				return 0;
692: 			}
693: 			zLine[n] = 0;
694: 			break;
695: 		}
696: 		while (zLine[n])
697: 			n++;
698: 		if (n > 0 && zLine[n - 1] == '\n') {
699: 			n--;
700: 			if (n > 0 && zLine[n - 1] == '\r')
701: 				n--;
702: 			zLine[n] = 0;
703: 			break;
704: 		}
705: 	}
706: #if defined(_WIN32) || defined(WIN32)
707: 	/* For interactive input on Windows systems, translate the
708: 	** multi-byte characterset characters into UTF-8. */
709: 	if (is_stdin && !is_utf8) {
710: 		char *zTrans = sqlite3_win32_mbcs_to_utf8_v2(zLine, 0);
711: 		if (zTrans) {
712: 			idx_t nTrans = ShellState::StringLength(zTrans) + 1;
713: 			if (nTrans > nLine) {
714: 				zLine = (char *)realloc(zLine, nTrans);
715: 				if (zLine == 0)
716: 					shell_out_of_memory();
717: 			}
718: 			memcpy(zLine, zTrans, nTrans);
719: 			sqlite3_free(zTrans);
720: 		}
721: 	}
722: #endif /* defined(_WIN32) || defined(WIN32) */
723: 	return zLine;
724: }
725: 
726: /*
727: ** Retrieve a single line of input text.
728: **
729: ** If in==0 then read from standard input and prompt before each line.
730: ** If isContinuation is true, then a continuation prompt is appropriate.
731: ** If isContinuation is zero, then the main prompt should be used.
732: **
733: ** If zPrior is not NULL then it is a buffer from a prior call to this
734: ** routine that can be reused.
735: **
736: ** The result is stored in space obtained from malloc() and must either
737: ** be freed by the caller or else passed back into this routine via the
738: ** zPrior argument for reuse.
739: */
740: static char *one_input_line(FILE *in, char *zPrior, int isContinuation) {
741: 	char *zPrompt;
742: 	char *zResult;
743: 	if (in != 0) {
744: 		zResult = local_getline(zPrior, in);
745: 	} else {
746: 		zPrompt = isContinuation ? continuePrompt : mainPrompt;
747: #if SHELL_USE_LOCAL_GETLINE
748: 		printf("%s", zPrompt);
749: 		fflush(stdout);
750: 		zResult = local_getline(zPrior, stdin);
751: #else
752: 		free(zPrior);
753: 		zResult = shell_readline(zPrompt);
754: #endif
755: 	}
756: 	return zResult;
757: }
758: 
759: /*
760: ** Return the value of a hexadecimal digit.  Return -1 if the input
761: ** is not a hex digit.
762: */
763: static int hexDigitValue(char c) {
764: 	if (c >= '0' && c <= '9')
765: 		return c - '0';
766: 	if (c >= 'a' && c <= 'f')
767: 		return c - 'a' + 10;
768: 	if (c >= 'A' && c <= 'F')
769: 		return c - 'A' + 10;
770: 	return -1;
771: }
772: 
773: /*
774: ** Interpret zArg as an integer value, possibly with suffixes.
775: */
776: static sqlite3_int64 integerValue(const char *zArg) {
777: 	sqlite3_int64 v = 0;
778: 	static const struct {
779: 		const char *zSuffix;
780: 		int iMult;
781: 	} aMult[] = {
782: 	    {"KiB", 1024}, {"MiB", 1024 * 1024}, {"GiB", 1024 * 1024 * 1024},
783: 	    {"KB", 1000},  {"MB", 1000000},      {"GB", 1000000000},
784: 	    {"K", 1000},   {"M", 1000000},       {"G", 1000000000},
785: 	};
786: 	int i;
787: 	int isNeg = 0;
788: 	if (zArg[0] == '-') {
789: 		isNeg = 1;
790: 		zArg++;
791: 	} else if (zArg[0] == '+') {
792: 		zArg++;
793: 	}
794: 	if (zArg[0] == '0' && zArg[1] == 'x') {
795: 		int x;
796: 		zArg += 2;
797: 		while ((x = hexDigitValue(zArg[0])) >= 0) {
798: 			v = (v << 4) + x;
799: 			zArg++;
800: 		}
801: 	} else {
802: 		while (IsDigit(zArg[0])) {
803: 			v = v * 10 + zArg[0] - '0';
804: 			zArg++;
805: 		}
806: 	}
807: 	for (i = 0; i < ArraySize(aMult); i++) {
808: 		if (sqlite3_stricmp(aMult[i].zSuffix, zArg) == 0) {
809: 			v *= aMult[i].iMult;
810: 			break;
811: 		}
812: 	}
813: 	return isNeg ? -v : v;
814: }
815: 
816: /* zIn is either a pointer to a NULL-terminated string in memory obtained
817: ** from malloc(), or a NULL pointer. The string pointed to by zAppend is
818: ** added to zIn, and the result returned in memory obtained from malloc().
819: ** zIn, if it was not NULL, is freed.
820: **
821: ** If the third argument, quote, is not '\0', then it is used as a
822: ** quote character for zAppend.
823: */
824: static void appendText(string &text, char const *zAppend, char quote) {
825: 	if (!quote) {
826: 		text += zAppend;
827: 		return;
828: 	}
829: 	text += quote;
830: 	for (const char *c = zAppend; *c; c++) {
831: 		text += *c;
832: 		if (*c == quote) {
833: 			text += quote;
834: 		}
835: 	}
836: 	text += quote;
837: }
838: 
839: /*
840: ** Attempt to determine if identifier zName needs to be quoted, either
841: ** because it contains non-alphanumeric characters, or because it is an
842: ** SQLite keyword.  Be conservative in this estimate:  When in doubt assume
843: ** that quoting is required.
844: **
845: ** Return '"' if quoting is required.  Return 0 if no quoting is required.
846: */
847: static char quoteChar(const char *zName) {
848: 	int i;
849: 	if (!isalpha((unsigned char)zName[0]) && zName[0] != '_')
850: 		return '"';
851: 	for (i = 0; zName[i]; i++) {
852: 		if (!isalnum((unsigned char)zName[i]) && zName[i] != '_')
853: 			return '"';
854: 	}
855: 	return sqlite3_keyword_check(zName, i) ? '"' : 0;
856: }
857: 
858: /* Allowed values for ShellState.openMode
859:  */
860: #define SHELL_OPEN_UNSPEC      0 /* No open-mode specified */
861: #define SHELL_OPEN_NORMAL      1 /* Normal database file */
862: #define SHELL_OPEN_APPENDVFS   2 /* Use appendvfs */
863: #define SHELL_OPEN_ZIPFILE     3 /* Use the zipfile virtual table */
864: #define SHELL_OPEN_READONLY    4 /* Open a normal database read-only */
865: #define SHELL_OPEN_DESERIALIZE 5 /* Open using sqlite3_deserialize() */
866: #define SHELL_OPEN_HEXDB       6 /* Use "dbtotxt" output as data source */
867: 
868: static const char *modeDescr[] = {"line",     "column", "list",    "semi",  "html",        "insert",    "quote",
869:                                   "tcl",      "csv",    "explain", "ascii", "prettyprint", "eqp",       "json",
870:                                   "markdown", "table",  "box",     "latex", "trash",       "jsonlines", "duckbox"};
871: 
872: /*
873: ** These are the column/row/line separators used by the various
874: ** import/export modes.
875: */
876: #define SEP_Column "|"
877: #define SEP_Row    "\n"
878: #define SEP_Tab    "\t"
879: #define SEP_Space  " "
880: #define SEP_Comma  ","
881: #define SEP_CrLf   "\r\n"
882: #define SEP_Unit   "\x1F"
883: #define SEP_Record "\x1E"
884: 
885: /*
886: ** A callback for the sqlite3_log() interface.
887: */
888: static void shellLog(void *pArg, int iErrCode, const char *zMsg) {
889: 	ShellState *p = (ShellState *)pArg;
890: 	if (p->pLog == 0)
891: 		return;
892: 	utf8_printf(p->pLog, "(%d) %s\n", iErrCode, zMsg);
893: 	fflush(p->pLog);
894: }
895: 
896: /*
897: ** Save or restore the current output mode
898: */
899: void ShellState::PushOutputMode() {
900: 	modePrior = mode;
901: 	priorShFlgs = shellFlgs;
902: 	colSepPrior = colSeparator;
903: 	rowSepPrior = rowSeparator;
904: }
905: 
906: void ShellState::PopOutputMode() {
907: 	mode = modePrior;
908: 	shellFlgs = priorShFlgs;
909: 	colSeparator = colSepPrior;
910: 	rowSeparator = rowSepPrior;
911: }
912: 
913: /*
914: ** Output the given string as a hex-encoded blob (eg. X'1234' )
915: */
916: void ShellState::OutputHexBlob(const void *pBlob, int nBlob) {
917: 	int i;
918: 	char *zBlob = (char *)pBlob;
919: 	raw_printf(out, "X'");
920: 	for (i = 0; i < nBlob; i++) {
921: 		raw_printf(out, "%02x", zBlob[i] & 0xff);
922: 	}
923: 	raw_printf(out, "'");
924: }
925: 
926: /*
927: ** Find a string that is not found anywhere in z[].  Return a pointer
928: ** to that string.
929: **
930: ** Try to use zA and zB first.  If both of those are already found in z[]
931: ** then make up some string and store it in the buffer zBuf.
932: */
933: static const char *unused_string(const char *z,                  /* Result must not appear anywhere in z */
934:                                  const char *zA, const char *zB, /* Try these first */
935:                                  char *zBuf                      /* Space to store a generated string */
936: ) {
937: 	unsigned i = 0;
938: 	if (strstr(z, zA) == 0)
939: 		return zA;
940: 	if (strstr(z, zB) == 0)
941: 		return zB;
942: 	do {
943: 		sqlite3_snprintf(20, zBuf, "(%s%u)", zA, i++);
944: 	} while (strstr(z, zBuf) != 0);
945: 	return zBuf;
946: }
947: 
948: /*
949: ** Output the given string as a quoted string using SQL quoting conventions.
950: **
951: ** See also: output_quoted_escaped_string()
952: */
953: void ShellState::OutputQuotedString(const char *z) {
954: 	int i;
955: 	char c;
956: 	SetBinaryMode();
957: 	for (i = 0; (c = z[i]) != 0 && c != '\''; i++) {
958: 	}
959: 	if (c == 0) {
960: 		utf8_printf(out, "'%s'", z);
961: 	} else {
962: 		raw_printf(out, "'");
963: 		while (*z) {
964: 			for (i = 0; (c = z[i]) != 0 && c != '\''; i++) {
965: 			}
966: 			if (c == '\'')
967: 				i++;
968: 			if (i) {
969: 				utf8_printf(out, "%.*s", i, z);
970: 				z += i;
971: 			}
972: 			if (c == '\'') {
973: 				raw_printf(out, "'");
974: 				continue;
975: 			}
976: 			if (c == 0) {
977: 				break;
978: 			}
979: 			z++;
980: 		}
981: 		raw_printf(out, "'");
982: 	}
983: 	SetTextMode();
984: }
985: 
986: /*
987: ** Output the given string as a quoted string using SQL quoting conventions.
988: ** Additionallly , escape the "\n" and "\r" characters so that they do not
989: ** get corrupted by end-of-line translation facilities in some operating
990: ** systems.
991: **
992: ** This is like output_quoted_string() but with the addition of the \r\n
993: ** escape mechanism.
994: */
995: void ShellState::OutputQuotedEscapedString(const char *z) {
996: 	int i;
997: 	char c;
998: 	setBinaryMode(out, 1);
999: 	for (i = 0; (c = z[i]) != 0 && c != '\'' && c != '\n' && c != '\r'; i++) {
1000: 	}
1001: 	if (c == 0) {
1002: 		utf8_printf(out, "'%s'", z);
1003: 	} else {
1004: 		const char *zNL = 0;
1005: 		const char *zCR = 0;
1006: 		int nNL = 0;
1007: 		int nCR = 0;
1008: 		char zBuf1[20], zBuf2[20];
1009: 		for (i = 0; z[i]; i++) {
1010: 			if (z[i] == '\n')
1011: 				nNL++;
1012: 			if (z[i] == '\r')
1013: 				nCR++;
1014: 		}
1015: 		if (nNL) {
1016: 			raw_printf(out, "replace(");
1017: 			zNL = unused_string(z, "\\n", "\\012", zBuf1);
1018: 		}
1019: 		if (nCR) {
1020: 			raw_printf(out, "replace(");
1021: 			zCR = unused_string(z, "\\r", "\\015", zBuf2);
1022: 		}
1023: 		raw_printf(out, "'");
1024: 		while (*z) {
1025: 			for (i = 0; (c = z[i]) != 0 && c != '\n' && c != '\r' && c != '\''; i++) {
1026: 			}
1027: 			if (c == '\'')
1028: 				i++;
1029: 			if (i) {
1030: 				utf8_printf(out, "%.*s", i, z);
1031: 				z += i;
1032: 			}
1033: 			if (c == '\'') {
1034: 				raw_printf(out, "'");
1035: 				continue;
1036: 			}
1037: 			if (c == 0) {
1038: 				break;
1039: 			}
1040: 			z++;
1041: 			if (c == '\n') {
1042: 				raw_printf(out, "%s", zNL);
1043: 				continue;
1044: 			}
1045: 			raw_printf(out, "%s", zCR);
1046: 		}
1047: 		raw_printf(out, "'");
1048: 		if (nCR) {
1049: 			raw_printf(out, ",'%s',char(13))", zCR);
1050: 		}
1051: 		if (nNL) {
1052: 			raw_printf(out, ",'%s',char(10))", zNL);
1053: 		}
1054: 	}
1055: 	setTextMode(out, 1);
1056: }
1057: 
1058: /*
1059: ** Output the given string as a quoted according to C or TCL quoting rules.
1060: */
1061: void ShellState::OutputCString(const char *z) {
1062: 	unsigned int c;
1063: 	fputc('"', out);
1064: 	while ((c = *(z++)) != 0) {
1065: 		if (c == '\\') {
1066: 			fputc(c, out);
1067: 			fputc(c, out);
1068: 		} else if (c == '"') {
1069: 			fputc('\\', out);
1070: 			fputc('"', out);
1071: 		} else if (c == '\t') {
1072: 			fputc('\\', out);
1073: 			fputc('t', out);
1074: 		} else if (c == '\n') {
1075: 			fputc('\\', out);
1076: 			fputc('n', out);
1077: 		} else if (c == '\r') {
1078: 			fputc('\\', out);
1079: 			fputc('r', out);
1080: 		} else if (!isprint(c & 0xff)) {
1081: 			raw_printf(out, "\\%03o", c & 0xff);
1082: 		} else {
1083: 			fputc(c, out);
1084: 		}
1085: 	}
1086: 	fputc('"', out);
1087: }
1088: 
1089: /*
1090: ** Output the given string as a quoted according to JSON quoting rules.
1091: */
1092: void ShellState::OutputJSONString(const char *z, int n) {
1093: 	unsigned int c;
1094: 	if (n < 0)
1095: 		n = (int)strlen(z);
1096: 	fputc('"', out);
1097: 	while (n--) {
1098: 		c = *(z++);
1099: 		if (c == '\\' || c == '"') {
1100: 			fputc('\\', out);
1101: 			fputc(c, out);
1102: 		} else if (c <= 0x1f) {
1103: 			fputc('\\', out);
1104: 			if (c == '\b') {
1105: 				fputc('b', out);
1106: 			} else if (c == '\f') {
1107: 				fputc('f', out);
1108: 			} else if (c == '\n') {
1109: 				fputc('n', out);
1110: 			} else if (c == '\r') {
1111: 				fputc('r', out);
1112: 			} else if (c == '\t') {
1113: 				fputc('t', out);
1114: 			} else {
1115: 				raw_printf(out, "u%04x", c);
1116: 			}
1117: 		} else {
1118: 			fputc(c, out);
1119: 		}
1120: 	}
1121: 	fputc('"', out);
1122: }
1123: 
1124: /*
1125: ** If a field contains any character identified by a 1 in the following
1126: ** array, then the string must be quoted for CSV.
1127: */
1128: static const char needCsvQuote[] = {
1129:     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0,
1130:     0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1131:     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1132:     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1133:     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1134:     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1135:     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1136: };
1137: 
1138: void ShellState::PrintOptionallyQuotedIdentifier(const char *input) {
1139: 	if (quoteChar(input)) {
1140: 		char *quoted = sqlite3_mprintf("\"%w\"", input);
1141: 		Print(quoted);
1142: 		sqlite3_free(quoted);
1143: 	} else {
1144: 		Print(input);
1145: 	}
1146: }
1147: 
1148: /*
1149: ** Output a single term of CSV.  Actually, p->colSeparator is used for
1150: ** the separator, which may or may not be a comma.  p->nullValue is
1151: ** the null value.  Strings are quoted if necessary.  The separator
1152: ** is only issued if bSep is true.
1153: */
1154: void ShellState::OutputCSV(const char *z, int bSep) {
1155: 	if (!z) {
1156: 		Print(nullValue);
1157: 	} else {
1158: 		int i;
1159: 		int nSep = colSeparator.size();
1160: 		for (i = 0; z[i]; i++) {
1161: 			if (needCsvQuote[((unsigned char *)z)[i]] ||
1162: 			    (z[i] == colSeparator[0] && (nSep == 1 || memcmp(z, colSeparator.c_str(), nSep) == 0))) {
1163: 				i = 0;
1164: 				break;
1165: 			}
1166: 		}
1167: 		if (i == 0) {
1168: 			char *zQuoted = sqlite3_mprintf("\"%w\"", z);
1169: 			Print(zQuoted);
1170: 			sqlite3_free(zQuoted);
1171: 		} else {
1172: 			Print(z);
1173: 		}
1174: 	}
1175: 	if (bSep) {
1176: 		Print(colSeparator);
1177: 	}
1178: }
1179: 
1180: /*
1181: ** This routine runs when the user presses Ctrl-C
1182: */
1183: static void interrupt_handler(int NotUsed) {
1184: 	UNUSED_PARAMETER(NotUsed);
1185: 	seenInterrupt++;
1186: 	if (seenInterrupt > 2) {
1187: 		exit(1);
1188: 	}
1189: 	if (globalDb) {
1190: 		sqlite3_interrupt(globalDb);
1191: 	}
1192: }
1193: 
1194: #if (defined(_WIN32) || defined(WIN32)) && !defined(_WIN32_WCE)
1195: /*
1196: ** This routine runs for console events (e.g. Ctrl-C) on Win32
1197: */
1198: static BOOL WINAPI ConsoleCtrlHandler(DWORD dwCtrlType /* One of the CTRL_*_EVENT constants */
1199: ) {
1200: 	if (dwCtrlType == CTRL_C_EVENT) {
1201: 		interrupt_handler(0);
1202: 		return TRUE;
1203: 	}
1204: 	return FALSE;
1205: }
1206: #endif
1207: 
1208: /*
1209: ** Print a schema statement.  Part of RenderMode::Semi and RenderMode::Pretty output.
1210: **
1211: ** This routine converts some CREATE TABLE statements for shadow tables
1212: ** in FTS3/4/5 into CREATE TABLE IF NOT EXISTS statements.
1213: */
1214: void ShellState::PrintSchemaLine(const char *z, const char *zTail) {
1215: 	if (!z || !zTail) {
1216: 		return;
1217: 	}
1218: 	if (sqlite3_strglob("CREATE TABLE ['\"]*", z) == 0) {
1219: 		utf8_printf(out, "CREATE TABLE IF NOT EXISTS %s%s", z + 13, zTail);
1220: 	} else {
1221: 		utf8_printf(out, "%s%s", z, zTail);
1222: 	}
1223: }
1224: void ShellState::PrintSchemaLineN(char *z, int n, const char *zTail) {
1225: 	char c = z[n];
1226: 	z[n] = 0;
1227: 	PrintSchemaLine(z, zTail);
1228: 	z[n] = c;
1229: }
1230: 
1231: /*
1232: ** Print N dashes
1233: */
1234: void ShellState::PrintDashes(idx_t N) {
1235: 	const char zDash[] = "--------------------------------------------------";
1236: 	const idx_t nDash = sizeof(zDash) - 1;
1237: 	while (N > nDash) {
1238: 		fputs(zDash, out);
1239: 		N -= nDash;
1240: 	}
1241: 	raw_printf(out, "%.*s", static_cast<int>(N), zDash);
1242: }
1243: 
1244: /*
1245: ** Print a markdown or table-style row separator using ascii-art
1246: */
1247: void ShellState::PrintRowSeparator(idx_t nArg, const char *zSep, const vector<idx_t> &actualWidth) {
1248: 	if (nArg > 0) {
1249: 		fputs(zSep, out);
1250: 		PrintDashes(actualWidth[0] + 2);
1251: 		for (idx_t i = 1; i < nArg; i++) {
1252: 			fputs(zSep, out);
1253: 			PrintDashes(actualWidth[i] + 2);
1254: 		}
1255: 		fputs(zSep, out);
1256: 	}
1257: 	fputs("\n", out);
1258: }
1259: 
1260: void ShellState::PrintMarkdownSeparator(idx_t nArg, const char *zSep, const vector<int> &colTypes,
1261:                                         const vector<idx_t> &actualWidth) {
1262: 	if (nArg > 0) {
1263: 		for (idx_t i = 0; i < nArg; i++) {
1264: 			Print(zSep);
1265: 			if (colTypes[i] == SQLITE_INTEGER || colTypes[i] == SQLITE_FLOAT) {
1266: 				// right-align numerics in tables
1267: 				PrintDashes(actualWidth[i] + 1);
1268: 				Print(":");
1269: 			} else {
1270: 				PrintDashes(actualWidth[i] + 2);
1271: 			}
1272: 		}
1273: 		Print(zSep);
1274: 	}
1275: 	Print("\n");
1276: }
1277: 
1278: void ShellState::SetBinaryMode() {
1279: 	setBinaryMode(out, 1);
1280: }
1281: 
1282: void ShellState::SetTextMode() {
1283: 	setTextMode(out, 1);
1284: }
1285: /*
1286: ** This is the callback routine that the shell
1287: ** invokes for each row of a query result.
1288: */
1289: int ShellState::RenderRow(RowRenderer &renderer, RowResult &result) {
1290: 	auto &data = result.data;
1291: 	if (data.empty()) {
1292: 		return 0;
1293: 	}
1294: 	renderer.Render(result);
1295: 	return 0;
1296: }
1297: 
1298: /*
1299: ** This is the callback routine that the SQLite library
1300: ** invokes for each row of a query result.
1301: */
1302: static int callback(void *pArg, int nArg, char **azArg, char **azCol) {
1303: 	/* since we don't have type info, call the shell_callback with a NULL value */
1304: 	auto renderer = (RowRenderer *)pArg;
1305: 	RowResult result;
1306: 	for (int i = 0; i < nArg; i++) {
1307: 		result.column_names.push_back(azCol[i]);
1308: 		result.data.push_back(azArg[i]);
1309: 	}
1310: 	return renderer->state.RenderRow(*renderer, result);
1311: }
1312: 
1313: /*
1314: ** Set the destination table field of the ShellState structure to
1315: ** the name of the table given.  Escape any quote characters in the
1316: ** table name.
1317: */
1318: void ShellState::SetTableName(const char *zName) {
1319: 	if (zDestTable) {
1320: 		free(zDestTable);
1321: 		zDestTable = nullptr;
1322: 	}
1323: 	if (!zName) {
1324: 		return;
1325: 	}
1326: 	auto cQuote = quoteChar(zName);
1327: 	idx_t n = StringLength(zName);
1328: 	if (cQuote) {
1329: 		n += n + 2;
1330: 	}
1331: 	auto z = zDestTable = (char *)malloc(n + 1);
1332: 	if (!z) {
1333: 		shell_out_of_memory();
1334: 	}
1335: 	n = 0;
1336: 	if (cQuote) {
1337: 		z[n++] = cQuote;
1338: 	}
1339: 	for (idx_t i = 0; zName[i]; i++) {
1340: 		z[n++] = zName[i];
1341: 		if (zName[i] == cQuote) {
1342: 			z[n++] = cQuote;
1343: 		}
1344: 	}
1345: 	if (cQuote) {
1346: 		z[n++] = cQuote;
1347: 	}
1348: 	z[n] = 0;
1349: }
1350: 
1351: /*
1352: ** Execute a query statement that will generate SQL output.  Print
1353: ** the result columns, comma-separated, on a line and then add a
1354: ** semicolon terminator to the end of that line.
1355: **
1356: ** If the number of columns is 1 and that column contains text "--"
1357: ** then write the semicolon on a separate line.  That way, if a
1358: ** "--" comment occurs at the end of the statement, the comment
1359: ** won't consume the semicolon terminator.
1360: */
1361: int ShellState::RunTableDumpQuery(const char *zSelect /* SELECT statement to extract content */
1362: ) {
1363: 	sqlite3_stmt *pSelect;
1364: 	const char *z;
1365: 	int rc = sqlite3_prepare_v2(db, zSelect, -1, &pSelect, 0);
1366: 	if (rc != SQLITE_OK || !pSelect) {
1367: 		utf8_printf(out, "/**** ERROR: (%d) %s *****/\n", rc, sqlite3_errmsg(db));
1368: 		if ((rc & 0xff) != SQLITE_CORRUPT) {
1369: 			nErr++;
1370: 		}
1371: 		return rc;
1372: 	}
1373: 	rc = sqlite3_step(pSelect);
1374: 	idx_t nResult = sqlite3_column_count(pSelect);
1375: 	while (rc == SQLITE_ROW) {
1376: 		z = (const char *)sqlite3_column_text(pSelect, 0);
1377: 		Print(z);
1378: 		for (idx_t i = 1; i < nResult; i++) {
1379: 			Print((const char *)sqlite3_column_text(pSelect, static_cast<int>(i)));
1380: 		}
1381: 		if (!z) {
1382: 			z = "";
1383: 		}
1384: 		while (z[0] && (z[0] != '-' || z[1] != '-')) {
1385: 			z++;
1386: 		}
1387: 		if (z[0]) {
1388: 			raw_printf(out, "\n;\n");
1389: 		} else {
1390: 			raw_printf(out, ";\n");
1391: 		}
1392: 		rc = sqlite3_step(pSelect);
1393: 	}
1394: 	rc = sqlite3_finalize(pSelect);
1395: 	if (rc != SQLITE_OK) {
1396: 		utf8_printf(out, "/**** ERROR: (%d) %s *****/\n", rc, sqlite3_errmsg(db));
1397: 		if ((rc & 0xff) != SQLITE_CORRUPT) {
1398: 			nErr++;
1399: 		}
1400: 	}
1401: 	return rc;
1402: }
1403: 
1404: /*
1405: ** Allocate space and save off current error string.
1406: */
1407: static char *SaveErrorMessage(sqlite3 *db) {
1408: 	idx_t nErrMsg = 1 + ShellState::StringLength(sqlite3_errmsg(db));
1409: 	auto zErrMsg = (char *)sqlite3_malloc64(nErrMsg);
1410: 	if (zErrMsg) {
1411: 		memcpy(zErrMsg, sqlite3_errmsg(db), nErrMsg);
1412: 	}
1413: 	return zErrMsg;
1414: }
1415: 
1416: string ShellState::strdup_handle_newline(const char *z) {
1417: 	static constexpr idx_t MAX_SIZE = 80;
1418: 	if (!z) {
1419: 		return nullValue;
1420: 	}
1421: 	if (cMode != RenderMode::BOX) {
1422: 		return z;
1423: 	}
1424: 	string result;
1425: 	idx_t count = 0;
1426: 	bool interrupted = false;
1427: 	for (const char *s = z; *s; s++) {
1428: 		if (*s == '\n') {
1429: 			result += "\\";
1430: 			result += "n";
1431: 		} else {
1432: 			result += *s;
1433: 		}
1434: 		count++;
1435: 		if (count >= MAX_SIZE && ((*s & 0xc0) != 0x80)) {
1436: 			interrupted = true;
1437: 			break;
1438: 		}
1439: 	}
1440: 	if (interrupted) {
1441: 		result += "...";
1442: 	}
1443: 	return result;
1444: }
1445: 
1446: bool ShellState::ColumnTypeIsInteger(const char *type) {
1447: 	if (!type) {
1448: 		return false;
1449: 	}
1450: 	if (strcmp(type, "TINYINT") == 0) {
1451: 		return true;
1452: 	}
1453: 	if (strcmp(type, "SMALLINT") == 0) {
1454: 		return true;
1455: 	}
1456: 	if (strcmp(type, "INTEGER") == 0) {
1457: 		return true;
1458: 	}
1459: 	if (strcmp(type, "BIGINT") == 0) {
1460: 		return true;
1461: 	}
1462: 	if (strcmp(type, "FLOAT") == 0) {
1463: 		return true;
1464: 	}
1465: 	if (strcmp(type, "DOUBLE") == 0) {
1466: 		return true;
1467: 	}
1468: 	if (strcmp(type, "DECIMAL") == 0) {
1469: 		return true;
1470: 	}
1471: 	return false;
1472: }
1473: 
1474: ColumnarResult ShellState::ExecuteColumnar(sqlite3_stmt *pStmt) {
1475: 	ColumnarResult result;
1476: 
1477: 	int rc = sqlite3_step(pStmt);
1478: 	if (rc != SQLITE_ROW) {
1479: 		return result;
1480: 	}
1481: 	// fetch the column count, column names and types
1482: 	result.column_count = sqlite3_column_count(pStmt);
1483: 	result.data.reserve(result.column_count * 4);
1484: 	for (idx_t i = 0; i < result.column_count; i++) {
1485: 		result.data.push_back(strdup_handle_newline(sqlite3_column_name(pStmt, i)));
1486: 		result.types.push_back(sqlite3_column_type(pStmt, i));
1487: 		result.type_names.push_back(sqlite3_column_decltype(pStmt, i));
1488: 	}
1489: 
1490: 	// execute the query and fetch the entire result set
1491: 	do {
1492: 		for (idx_t i = 0; i < result.column_count; i++) {
1493: 			auto z = (const char *)sqlite3_column_text(pStmt, i);
1494: 			result.data.push_back(strdup_handle_newline(z));
1495: 		}
1496: 	} while ((rc = sqlite3_step(pStmt)) == SQLITE_ROW);
1497: 
1498: 	// compute the column widths
1499: 	for (idx_t i = 0; i < result.column_count; i++) {
1500: 		int w = i < colWidth.size() ? colWidth[i] : 0;
1501: 		if (w < 0) {
1502: 			result.right_align.push_back(true);
1503: 			w = -w;
1504: 		} else {
1505: 			result.right_align.push_back(false);
1506: 		}
1507: 		result.column_width.push_back(static_cast<idx_t>(w));
1508: 	}
1509: 	for (idx_t i = 0; i < result.data.size(); i++) {
1510: 		idx_t width = RenderLength(result.data[i]);
1511: 		idx_t column_idx = i % result.column_count;
1512: 		if (width > result.column_width[column_idx]) {
1513: 			result.column_width[column_idx] = width;
1514: 		}
1515: 	}
1516: 	return result;
1517: }
1518: 
1519: /*
1520: ** Run a prepared statement and output the result in one of the
1521: ** table-oriented formats: RenderMode::Column, RenderMode::Markdown, RenderMode::Table,
1522: ** RenderMode::Box or RenderMode::DuckBox
1523: **
1524: ** This is different from ordinary exec_prepared_stmt() in that
1525: ** it has to run the entire query and gather the results into memory
1526: ** first, in order to determine column widths, before providing
1527: ** any output.
1528: */
1529: void ShellState::ExecutePreparedStatementColumnar(sqlite3_stmt *pStmt) {
1530: 	auto result = ExecuteColumnar(pStmt);
1531: 	if (seenInterrupt) {
1532: 		utf8_printf(out, "Interrupt\n");
1533: 		return;
1534: 	}
1535: 	if (result.data.empty()) {
1536: 		// nothing to render
1537: 		return;
1538: 	}
1539: 
1540: 	auto column_renderer = GetColumnRenderer();
1541: 	column_renderer->RenderHeader(result);
1542: 	auto colSep = column_renderer->GetColumnSeparator();
1543: 	auto rowSep = column_renderer->GetRowSeparator();
1544: 	auto row_start = column_renderer->GetRowStart();
1545: 
1546: 	for (idx_t i = result.column_count, j = 0; i < result.data.size(); i++, j++) {
1547: 		if (j == 0 && row_start) {
1548: 			Print(row_start);
1549: 		}
1550: 		idx_t w = result.column_width[j];
1551: 		bool right_align = result.right_align[j];
1552: 		UTF8WidthPrint(out, w, result.data[i], right_align);
1553: 		if (j == result.column_count - 1) {
1554: 			Print(rowSep);
1555: 			j = -1;
1556: 			if (seenInterrupt)
1557: 				goto columnar_end;
1558: 		} else {
1559: 			Print(colSep);
1560: 		}
1561: 	}
1562: 	column_renderer->RenderFooter(result);
1563: columnar_end:
1564: 	if (seenInterrupt) {
1565: 		utf8_printf(out, "Interrupt\n");
1566: 	}
1567: }
1568: 
1569: extern "C" {
1570: extern void sqlite3_print_duckbox(sqlite3_stmt *pStmt, size_t max_rows, size_t max_width, const char *null_value,
1571:                                   int columns, char thousands, char decimal, duckdb::BaseResultRenderer *renderer);
1572: }
1573: 
1574: class DuckBoxRenderer : public duckdb::BaseResultRenderer {
1575: public:
1576: 	DuckBoxRenderer(ShellState &state, bool highlight)
1577: 	    : shell_highlight(state), output(PrintOutput::STDOUT), highlight(highlight) {
1578: 	}
1579: 
1580: 	void RenderLayout(const string &text) override {
1581: 		PrintText(text, HighlightElementType::LAYOUT);
1582: 	}
1583: 
1584: 	void RenderColumnName(const string &text) override {
1585: 		PrintText(text, HighlightElementType::COLUMN_NAME);
1586: 	}
1587: 
1588: 	void RenderType(const string &text) override {
1589: 		PrintText(text, HighlightElementType::COLUMN_TYPE);
1590: 	}
1591: 
1592: 	void RenderValue(const string &text, const duckdb::LogicalType &type) override {
1593: 		if (type.IsNumeric()) {
1594: 			PrintText(text, HighlightElementType::NUMERIC_VALUE);
1595: 		} else if (type.IsTemporal()) {
1596: 			PrintText(text, HighlightElementType::TEMPORAL_VALUE);
1597: 		} else {
1598: 			PrintText(text, HighlightElementType::STRING_VALUE);
1599: 		}
1600: 	}
1601: 
1602: 	void RenderNull(const string &text, const duckdb::LogicalType &type) override {
1603: 		PrintText(text, HighlightElementType::NULL_VALUE);
1604: 	}
1605: 
1606: 	void RenderFooter(const string &text) override {
1607: 		PrintText(text, HighlightElementType::FOOTER);
1608: 	}
1609: 
1610: 	void PrintText(const string &text, HighlightElementType element_type) {
1611: 		if (highlight) {
1612: 			shell_highlight.PrintText(text, output, element_type);
1613: 		} else {
1614: 			utf8_printf(shell_highlight.state.out, "%s", text.c_str());
1615: 		}
1616: 	}
1617: 
1618: private:
1619: 	ShellHighlight shell_highlight;
1620: 	PrintOutput output;
1621: 	bool highlight = true;
1622: };
1623: 
1624: /*
1625: ** Run a prepared statement
1626: */
1627: void ShellState::ExecutePreparedStatement(sqlite3_stmt *pStmt /* Statment to run */
1628: ) {
1629: 	if (cMode == RenderMode::DUCKBOX) {
1630: 		size_t max_rows = outfile.empty() || outfile[0] == '|' ? this->max_rows : (size_t)-1;
1631: 		size_t max_width = outfile.empty() || outfile[0] == '|' ? this->max_width : (size_t)-1;
1632: 		DuckBoxRenderer renderer(*this, HighlightResults());
1633: 		sqlite3_print_duckbox(pStmt, max_rows, max_width, nullValue.c_str(), columns, thousand_separator,
1634: 		                      decimal_separator, &renderer);
1635: 		return;
1636: 	}
1637: 
1638: 	if (ShellRenderer::IsColumnar(cMode)) {
1639: 		ExecutePreparedStatementColumnar(pStmt);
1640: 		return;
1641: 	}
1642: 
1643: 	/* perform the first step.  this will tell us if we
1644: 	** have a result set or not and how wide it is.
1645: 	*/
1646: 	int rc = sqlite3_step(pStmt);
1647: 	/* if we have a result set... */
1648: 	if (SQLITE_ROW != rc) {
1649: 		return;
1650: 	}
1651: 	RowResult result;
1652: 	// initialize the result and the column names
1653: 	int nCol = sqlite3_column_count(pStmt);
1654: 	result.column_names.reserve(nCol);
1655: 	result.data.resize(nCol);
1656: 	result.types.resize(nCol);
1657: 	for (int i = 0; i < nCol; i++) {
1658: 		result.column_names.push_back(sqlite3_column_name(pStmt, i));
1659: 	}
1660: 	result.pStmt = pStmt;
1661: 
1662: 	auto renderer = GetRowRenderer();
1663: 
1664: 	// iterate over the rows
1665: 	do {
1666: 		if (renderer) {
1667: 			/* extract the data and data types */
1668: 			for (int i = 0; i < nCol; i++) {
1669: 				result.types[i] = sqlite3_column_type(pStmt, i);
1670: 				if (result.types[i] == SQLITE_BLOB && cMode == RenderMode::INSERT) {
1671: 					result.data[i] = "";
1672: 				} else {
1673: 					result.data[i] = (const char *)sqlite3_column_text(pStmt, i);
1674: 				}
1675: 				if (!result.data[i] && result.types[i] != SQLITE_NULL) {
1676: 					// OOM
1677: 					rc = SQLITE_NOMEM;
1678: 					break;
1679: 				}
1680: 			}
1681: 		}
1682: 
1683: 		/* if data and types extracted successfully... */
1684: 		if (SQLITE_ROW == rc) {
1685: 			/* call the supplied callback with the result row data */
1686: 			if (renderer && RenderRow(*renderer, result)) {
1687: 				rc = SQLITE_ABORT;
1688: 			} else {
1689: 				rc = sqlite3_step(pStmt);
1690: 			}
1691: 		}
1692: 	} while (SQLITE_ROW == rc);
1693: 
1694: 	if (renderer) {
1695: 		renderer->RenderFooter(result);
1696: 	}
1697: }
1698: 
1699: /*
1700: ** Execute a statement or set of statements.  Print
1701: ** any result rows/columns depending on the current mode
1702: ** set via the supplied callback.
1703: **
1704: ** This is very similar to SQLite's built-in sqlite3_exec()
1705: ** function except it takes a slightly different callback
1706: ** and callback data argument.
1707: */
1708: int ShellState::ExecuteSQL(const char *zSql, /* SQL to be evaluated */
1709:                            char **pzErrMsg   /* Error msg written here */
1710: ) {
1711: 	sqlite3_stmt *pStmt = NULL; /* Statement to execute. */
1712: 	int rc = SQLITE_OK;         /* Return Code */
1713: 	int rc2;
1714: 	const char *zLeftover; /* Tail of unprocessed SQL */
1715: 
1716: 	if (pzErrMsg) {
1717: 		*pzErrMsg = NULL;
1718: 	}
1719: 
1720: 	while (zSql[0] && (SQLITE_OK == rc)) {
1721: 		static const char *zStmtSql;
1722: 		rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
1723: 		if (SQLITE_OK != rc) {
1724: 			if (pzErrMsg) {
1725: 				*pzErrMsg = SaveErrorMessage(db);
1726: 			}
1727: 		} else {
1728: 			if (!pStmt) {
1729: 				/* this happens for a comment or white-space */
1730: 				zSql = zLeftover;
1731: 				while (IsSpace(zSql[0]))
1732: 					zSql++;
1733: 				continue;
1734: 			}
1735: 			zStmtSql = sqlite3_sql(pStmt);
1736: 			if (zStmtSql == 0)
1737: 				zStmtSql = "";
1738: 			while (IsSpace(zStmtSql[0]))
1739: 				zStmtSql++;
1740: 
1741: 			/* save off the prepared statment handle and reset row count */
1742: 			this->pStmt = pStmt;
1743: 
1744: 			/* echo the sql statement if echo on */
1745: 			if (ShellHasFlag(SHFLG_Echo)) {
1746: 				utf8_printf(out, "%s\n", zStmtSql ? zStmtSql : zSql);
1747: 			}
1748: 
1749: 			cMode = mode;
1750: 			if (sqlite3_stmt_isexplain(pStmt) == 1) {
1751: 				cMode = RenderMode::EXPLAIN;
1752: 			}
1753: 
1754: 			ExecutePreparedStatement(pStmt);
1755: 
1756: 			/* Finalize the statement just executed. If this fails, save a
1757: 			** copy of the error message. Otherwise, set zSql to point to the
1758: 			** next statement to execute. */
1759: 			rc2 = sqlite3_finalize(pStmt);
1760: 			if (rc != SQLITE_NOMEM)
1761: 				rc = rc2;
1762: 			if (rc == SQLITE_OK) {
1763: 				zSql = zLeftover;
1764: 				while (IsSpace(zSql[0]))
1765: 					zSql++;
1766: 			} else if (pzErrMsg) {
1767: 				*pzErrMsg = SaveErrorMessage(db);
1768: 			}
1769: 
1770: 			/* clear saved stmt handle */
1771: 			pStmt = NULL;
1772: 		}
1773: 	} /* end while */
1774: 
1775: 	return rc;
1776: }
1777: 
1778: /*
1779: ** Release memory previously allocated by tableColumnList().
1780: */
1781: static void freeColumnList(char **azCol) {
1782: 	for (idx_t i = 1; azCol[i]; i++) {
1783: 		sqlite3_free(azCol[i]);
1784: 	}
1785: 	/* azCol[0] is a static string */
1786: 	sqlite3_free(azCol);
1787: }
1788: 
1789: /*
1790: ** Return a list of pointers to strings which are the names of all
1791: ** columns in table zTab.   The memory to hold the names is dynamically
1792: ** allocated and must be released by the caller using a subsequent call
1793: ** to freeColumnList().
1794: **
1795: ** The azCol[0] entry is usually NULL.  However, if zTab contains a rowid
1796: ** value that needs to be preserved, then azCol[0] is filled in with the
1797: ** name of the rowid column.
1798: **
1799: ** The first regular column in the table is azCol[1].  The list is terminated
1800: ** by an entry with azCol[i]==0.
1801: */
1802: char **ShellState::TableColumnList(const char *zTab) {
1803: 	char **azCol = 0;
1804: 	sqlite3_stmt *pStmt;
1805: 	char *zSql;
1806: 	int nCol = 0;
1807: 	int nAlloc = 0;
1808: 	int nPK = 0;   /* Number of PRIMARY KEY columns seen */
1809: 	int isIPK = 0; /* True if one PRIMARY KEY column of type INTEGER */
1810: 	int preserveRowid = ShellHasFlag(SHFLG_PreserveRowid);
1811: 	int rc;
1812: 
1813: 	zSql = sqlite3_mprintf("PRAGMA table_info=%Q", zTab);
1814: 	rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
1815: 	sqlite3_free(zSql);
1816: 	if (rc)
1817: 		return 0;
1818: 	while (sqlite3_step(pStmt) == SQLITE_ROW) {
1819: 		if (nCol >= nAlloc - 2) {
1820: 			nAlloc = nAlloc * 2 + nCol + 10;
1821: 			azCol = (char **)sqlite3_realloc(azCol, nAlloc * sizeof(azCol[0]));
1822: 			if (azCol == 0)
1823: 				shell_out_of_memory();
1824: 		}
1825: 		azCol[++nCol] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 1));
1826: 		if (sqlite3_column_int(pStmt, 5)) {
1827: 			nPK++;
1828: 			if (nPK == 1 && sqlite3_stricmp((const char *)sqlite3_column_text(pStmt, 2), "INTEGER") == 0) {
1829: 				isIPK = 1;
1830: 			} else {
1831: 				isIPK = 0;
1832: 			}
1833: 		}
1834: 	}
1835: 	sqlite3_finalize(pStmt);
1836: 	if (azCol == 0)
1837: 		return 0;
1838: 	azCol[0] = 0;
1839: 	azCol[nCol + 1] = 0;
1840: 
1841: 	/* The decision of whether or not a rowid really needs to be preserved
1842: 	** is tricky.  We never need to preserve a rowid for a WITHOUT ROWID table
1843: 	** or a table with an INTEGER PRIMARY KEY.  We are unable to preserve
1844: 	** rowids on tables where the rowid is inaccessible because there are other
1845: 	** columns in the table named "rowid", "_rowid_", and "oid".
1846: 	*/
1847: 	if (preserveRowid && isIPK) {
1848: 		/* If a single PRIMARY KEY column with type INTEGER was seen, then it
1849: 		** might be an alise for the ROWID.  But it might also be a WITHOUT ROWID
1850: 		** table or a INTEGER PRIMARY KEY DESC column, neither of which are
1851: 		** ROWID aliases.  To distinguish these cases, check to see if
1852: 		** there is a "pk" entry in "PRAGMA index_list".  There will be
1853: 		** no "pk" index if the PRIMARY KEY really is an alias for the ROWID.
1854: 		*/
1855: 		zSql = sqlite3_mprintf("SELECT 1 FROM pragma_index_list(%Q)"
1856: 		                       " WHERE origin='pk'",
1857: 		                       zTab);
1858: 		rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
1859: 		sqlite3_free(zSql);
1860: 		if (rc) {
1861: 			freeColumnList(azCol);
1862: 			return 0;
1863: 		}
1864: 		rc = sqlite3_step(pStmt);
1865: 		sqlite3_finalize(pStmt);
1866: 		preserveRowid = rc == SQLITE_ROW;
1867: 	}
1868: 	if (preserveRowid) {
1869: 		/* Only preserve the rowid if we can find a name to use for the
1870: 		** rowid */
1871: 		static const char *azRowid[] = {"rowid", "_rowid_", "oid"};
1872: 		int i, j;
1873: 		for (j = 0; j < 3; j++) {
1874: 			for (i = 1; i <= nCol; i++) {
1875: 				if (sqlite3_stricmp(azRowid[j], azCol[i]) == 0)
1876: 					break;
1877: 			}
1878: 			if (i > nCol) {
1879: 				/* At this point, we know that azRowid[j] is not the name of any
1880: 				** ordinary column in the table.  Verify that azRowid[j] is a valid
1881: 				** name for the rowid before adding it to azCol[0].  WITHOUT ROWID
1882: 				** tables will fail this last check */
1883: 				rc = sqlite3_table_column_metadata(db, 0, zTab, azRowid[j], 0, 0, 0, 0, 0);
1884: 				if (rc == SQLITE_OK)
1885: 					azCol[0] = (char *)azRowid[j];
1886: 				break;
1887: 			}
1888: 		}
1889: 	}
1890: 	return azCol;
1891: }
1892: 
1893: /*
1894: ** Toggle the reverse_unordered_selects setting.
1895: */
1896: static void toggleSelectOrder(sqlite3 *db) {
1897: 	sqlite3_stmt *pStmt = 0;
1898: 	int iSetting = 0;
1899: 	char zStmt[100];
1900: 	sqlite3_prepare_v2(db, "PRAGMA reverse_unordered_selects", -1, &pStmt, 0);
1901: 	if (sqlite3_step(pStmt) == SQLITE_ROW) {
1902: 		iSetting = sqlite3_column_int(pStmt, 0);
1903: 	}
1904: 	sqlite3_finalize(pStmt);
1905: 	sqlite3_snprintf(sizeof(zStmt), zStmt, "PRAGMA reverse_unordered_selects(%d)", !iSetting);
1906: 	sqlite3_exec(db, zStmt, 0, 0, 0);
1907: }
1908: 
1909: /*
1910: ** This is a different callback routine used for dumping the database.
1911: ** Each row received by this callback consists of a table name,
1912: ** the table type ("index" or "table") and SQL to create the table.
1913: ** This routine should print text sufficient to recreate the table.
1914: */
1915: static int dump_callback(void *pArg, int nArg, char **azArg, char **azNotUsed) {
1916: 	int rc;
1917: 	const char *zTable;
1918: 	const char *zType;
1919: 	const char *zSql;
1920: 	ShellState *p = (ShellState *)pArg;
1921: 
1922: 	UNUSED_PARAMETER(azNotUsed);
1923: 	if (nArg != 3 || azArg == 0)
1924: 		return 0;
1925: 	zTable = azArg[0];
1926: 	zType = azArg[1];
1927: 	zSql = azArg[2];
1928: 
1929: 	if (strcmp(zTable, "sqlite_sequence") == 0) {
1930: 		raw_printf(p->out, "DELETE FROM sqlite_sequence;\n");
1931: 	} else if (sqlite3_strglob("sqlite_stat?", zTable) == 0) {
1932: 		raw_printf(p->out, "ANALYZE sqlite_schema;\n");
1933: 	} else if (strncmp(zTable, "sqlite_", 7) == 0) {
1934: 		return 0;
1935: 	} else if (strncmp(zSql, "CREATE VIRTUAL TABLE", 20) == 0) {
1936: 		char *zIns;
1937: 		zIns = sqlite3_mprintf("INSERT INTO sqlite_schema(type,name,tbl_name,rootpage,sql)"
1938: 		                       "VALUES('table','%q','%q',0,'%q');",
1939: 		                       zTable, zTable, zSql);
1940: 		utf8_printf(p->out, "%s\n", zIns);
1941: 		sqlite3_free(zIns);
1942: 		return 0;
1943: 	} else {
1944: 		p->PrintSchemaLine(zSql, ";\n");
1945: 	}
1946: 
1947: 	if (strcmp(zType, "table") == 0) {
1948: 		string sSelect;
1949: 		string sTable;
1950: 		char **azCol;
1951: 		int i;
1952: 		char *savedDestTable;
1953: 		RenderMode savedMode;
1954: 
1955: 		azCol = p->TableColumnList(zTable);
1956: 		if (azCol == 0) {
1957: 			p->nErr++;
1958: 			return 0;
1959: 		}
1960: 
1961: 		/* Always quote the table name, even if it appears to be pure ascii,
1962: 		** in case it is a keyword. Ex:  INSERT INTO "table" ... */
1963: 		appendText(sTable, zTable, quoteChar(zTable));
1964: 		/* If preserving the rowid, add a column list after the table name.
1965: 		** In other words:  "INSERT INTO tab(rowid,a,b,c,...) VALUES(...)"
1966: 		** instead of the usual "INSERT INTO tab VALUES(...)".
1967: 		*/
1968: 		if (azCol[0]) {
1969: 			appendText(sTable, "(", 0);
1970: 			appendText(sTable, azCol[0], 0);
1971: 			for (i = 1; azCol[i]; i++) {
1972: 				appendText(sTable, ",", 0);
1973: 				appendText(sTable, azCol[i], quoteChar(azCol[i]));
1974: 			}
1975: 			appendText(sTable, ")", 0);
1976: 		}
1977: 
1978: 		/* Build an appropriate SELECT statement */
1979: 		appendText(sSelect, "SELECT ", 0);
1980: 		if (azCol[0]) {
1981: 			appendText(sSelect, azCol[0], 0);
1982: 			appendText(sSelect, ",", 0);
1983: 		}
1984: 		for (i = 1; azCol[i]; i++) {
1985: 			appendText(sSelect, azCol[i], quoteChar(azCol[i]));
1986: 			if (azCol[i + 1]) {
1987: 				appendText(sSelect, ",", 0);
1988: 			}
1989: 		}
1990: 		freeColumnList(azCol);
1991: 		appendText(sSelect, " FROM ", 0);
1992: 		appendText(sSelect, zTable, quoteChar(zTable));
1993: 
1994: 		savedDestTable = p->zDestTable;
1995: 		savedMode = p->mode;
1996: 		p->zDestTable = (char *)sTable.c_str();
1997: 		p->mode = p->cMode = RenderMode::INSERT;
1998: 		rc = p->ExecuteSQL(sSelect.c_str(), 0);
1999: 		if ((rc & 0xff) == SQLITE_CORRUPT) {
2000: 			raw_printf(p->out, "/****** CORRUPTION ERROR *******/\n");
2001: 			toggleSelectOrder(p->db);
2002: 			p->ExecuteSQL(sSelect.c_str(), 0);
2003: 			toggleSelectOrder(p->db);
2004: 		}
2005: 		p->zDestTable = savedDestTable;
2006: 		p->mode = savedMode;
2007: 		if (rc)
2008: 			p->nErr++;
2009: 	}
2010: 	return 0;
2011: }
2012: 
2013: /*
2014: ** Run zQuery.  Use dump_callback() as the callback routine so that
2015: ** the contents of the query are output as SQL statements.
2016: **
2017: ** If we get a SQLITE_CORRUPT error, rerun the query after appending
2018: ** "ORDER BY rowid DESC" to the end.
2019: */
2020: int ShellState::RunSchemaDumpQuery(const char *zQuery) {
2021: 	int rc;
2022: 	char *zErr = 0;
2023: 	rc = sqlite3_exec(db, zQuery, dump_callback, this, &zErr);
2024: 	if (rc == SQLITE_CORRUPT) {
2025: 		char *zQ2;
2026: 		int len = StringLength(zQuery);
2027: 		raw_printf(out, "/****** CORRUPTION ERROR *******/\n");
2028: 		if (zErr) {
2029: 			utf8_printf(out, "/****** %s ******/\n", zErr);
2030: 			sqlite3_free(zErr);
2031: 			zErr = 0;
2032: 		}
2033: 		zQ2 = (char *)malloc(len + 100);
2034: 		if (zQ2 == 0)
2035: 			return rc;
2036: 		sqlite3_snprintf(len + 100, zQ2, "%s ORDER BY rowid DESC", zQuery);
2037: 		rc = sqlite3_exec(db, zQ2, dump_callback, this, &zErr);
2038: 		if (rc) {
2039: 			utf8_printf(out, "/****** ERROR: %s ******/\n", zErr);
2040: 		} else {
2041: 			rc = SQLITE_CORRUPT;
2042: 		}
2043: 		sqlite3_free(zErr);
2044: 		free(zQ2);
2045: 	} else if (zErr) {
2046: 		sqlite3_free(zErr);
2047: 		zErr = 0;
2048: 	}
2049: 	return rc;
2050: }
2051: 
2052: /*
2053: ** Text of help messages.
2054: **
2055: ** The help text for each individual command begins with a line that starts
2056: ** with ".".  Subsequent lines are supplimental information.
2057: **
2058: ** There must be two or more spaces between the end of the command and the
2059: ** start of the description of what that command does.
2060: */
2061: static const char *azHelp[] = {
2062:     ".bail on|off             Stop after hitting an error.  Default OFF",
2063:     ".binary on|off           Turn binary output on or off.  Default OFF",
2064:     ".cd DIRECTORY            Change the working directory to DIRECTORY",
2065:     ".changes on|off          Show number of rows changed by SQL",
2066:     ".check GLOB              Fail if output since .testcase does not match",
2067:     ".columns                 Column-wise rendering of query results",
2068: #ifdef HAVE_LINENOISE
2069:     ".constant ?COLOR?        Sets the syntax highlighting color used for constant values",
2070:     "   COLOR is one of:",
2071:     "     red|green|yellow|blue|magenta|cyan|white|brightblack|brightred|brightgreen",
2072:     "     brightyellow|brightblue|brightmagenta|brightcyan|brightwhite",
2073:     ".constantcode ?CODE?     Sets the syntax highlighting terminal code used for constant values",
2074: #endif
2075:     ".databases               List names and files of attached databases",
2076:     ".decimal_sep SEP         Sets the decimal separator used when rendering numbers. Only for duckbox mode.",
2077:     ".dump ?TABLE?            Render database content as SQL",
2078:     "   Options:",
2079:     "     --preserve-rowids      Include ROWID values in the output",
2080:     "     --newlines             Allow unescaped newline characters in output",
2081:     "   TABLE is a LIKE pattern for the tables to dump",
2082:     "   Additional LIKE patterns can be given in subsequent arguments",
2083:     ".echo on|off             Turn command echo on or off",
2084:     ".excel                   Display the output of next command in spreadsheet",
2085:     "   --bom                   Put a UTF8 byte-order mark on intermediate file",
2086: #ifdef HAVE_LINENOISE
2087:     ".edit                    Opens an external text editor to edit a query.",
2088:     "   Notes:",
2089:     "     *  The editor is read from the environment variables",
2090:     "        DUCKDB_EDITOR, EDITOR, VISUAL in-order",
2091:     "     * If none of these are set, the default editor is vi",
2092:     "   * \\e can be used as an alias for .edit",
2093: #endif
2094:     ".exit ?CODE?             Exit this program with return-code CODE",
2095:     ".explain ?on|off|auto?   Change the EXPLAIN formatting mode.  Default: auto",
2096:     ".fullschema ?--indent?   Show schema and the content of sqlite_stat tables",
2097:     ".headers on|off          Turn display of headers on or off",
2098:     ".help ?-all? ?PATTERN?   Show help text for PATTERN",
2099: #ifdef HAVE_LINENOISE
2100:     ".highlight [on|off]      Toggle syntax highlighting in the shell on/off",
2101: #endif
2102:     ".highlight_colors [element] [color]  ([bold])? Configure highlighting colors",
2103:     ".highlight_errors [on|off] Toggle highlighting of errors in the shell on/off",
2104:     ".highlight_results [on|off] Toggle highlighting of results in the shell on/off",
2105:     ".import FILE TABLE       Import data from FILE into TABLE",
2106:     "   Options:",
2107:     "     --ascii               Use \\037 and \\036 as column and row separators",
2108:     "     --csv                 Use , and \\n as column and row separators",
2109:     "     --skip N              Skip the first N rows of input",
2110:     "     -v                    \"Verbose\" - increase auxiliary output",
2111:     "   Notes:",
2112:     "     *  If TABLE does not exist, it is created.  The first row of input",
2113:     "        determines the column names.",
2114:     "     *  If neither --csv or --ascii are used, the input mode is derived",
2115:     "        from the \".mode\" output mode",
2116:     "     *  If FILE begins with \"|\" then it is a command that generates the",
2117:     "        input text.",
2118:     ".indexes ?TABLE?         Show names of indexes",
2119:     "                           If TABLE is specified, only show indexes for",
2120:     "                           tables matching TABLE using the LIKE operator.",
2121: #ifdef HAVE_LINENOISE
2122:     ".keyword ?COLOR?         Sets the syntax highlighting color used for keywords",
2123:     "   COLOR is one of:",
2124:     "     red|green|yellow|blue|magenta|cyan|white|brightblack|brightred|brightgreen",
2125:     "     brightyellow|brightblue|brightmagenta|brightcyan|brightwhite",
2126:     ".keywordcode ?CODE?      Sets the syntax highlighting terminal code used for keywords",
2127: #endif
2128:     ".log FILE|off            Turn logging on or off.  FILE can be stderr/stdout",
2129:     ".maxrows COUNT           Sets the maximum number of rows for display (default: 40). Only for duckbox mode.",
2130:     ".maxwidth COUNT          Sets the maximum width in characters. 0 defaults to terminal width. Only for duckbox "
2131:     "mode.",
2132:     ".mode MODE ?TABLE?       Set output mode",
2133:     "   MODE is one of:",
2134:     "     ascii     Columns/rows delimited by 0x1F and 0x1E",
2135:     "     box       Tables using unicode box-drawing characters",
2136:     "     csv       Comma-separated values",
2137:     "     column    Output in columns.  (See .width)",
2138:     "     duckbox   Tables with extensive features",
2139:     "     html      HTML <table> code",
2140:     "     insert    SQL insert statements for TABLE",
2141:     "     json      Results in a JSON array",
2142:     "     jsonlines Results in a NDJSON",
2143:     "     latex     LaTeX tabular environment code",
2144:     "     line      One value per line",
2145:     "     list      Values delimited by \"|\"",
2146:     "     markdown  Markdown table format",
2147:     "     quote     Escape answers as for SQL",
2148:     "     table     ASCII-art table",
2149:     "     tabs      Tab-separated values",
2150:     "     tcl       TCL list elements",
2151:     "     trash     No output",
2152:     ".nullvalue STRING        Use STRING in place of NULL values",
2153:     ".once ?OPTIONS? ?FILE?   Output for the next SQL command only to FILE",
2154:     "     If FILE begins with '|' then open as a pipe",
2155:     "       --bom  Put a UTF8 byte-order mark at the beginning",
2156:     "       -e     Send output to the system text editor",
2157:     "       -x     Send output as CSV to a spreadsheet (same as \".excel\")",
2158:     ".open ?OPTIONS? ?FILE?   Close existing database and reopen FILE",
2159:     "     Options:",
2160:     "        --new           Initialize FILE to an empty database",
2161:     "        --nofollow      Do not follow symbolic links",
2162:     "        --readonly      Open FILE readonly",
2163:     ".output ?FILE?           Send output to FILE or stdout if FILE is omitted",
2164:     "   If FILE begins with '|' then open it as a pipe.",
2165:     "   Options:",
2166:     "     --bom                 Prefix output with a UTF8 byte-order mark",
2167:     "     -e                    Send output to the system text editor",
2168:     "     -x                    Send output as CSV to a spreadsheet",
2169:     ".print STRING...         Print literal STRING",
2170:     ".prompt MAIN CONTINUE    Replace the standard prompts",
2171:     ".quit                    Exit this program",
2172:     ".read FILE               Read input from FILE",
2173:     ".rows                    Row-wise rendering of query results (default)",
2174:     ".schema ?PATTERN?        Show the CREATE statements matching PATTERN",
2175:     "     Options:",
2176:     "         --indent            Try to pretty-print the schema",
2177:     ".separator COL ?ROW?     Change the column and row separators",
2178: #ifndef SQLITE_NOHAVE_SYSTEM
2179:     ".shell CMD ARGS...       Run CMD ARGS... in a system shell",
2180: #endif
2181:     ".show                    Show the current values for various settings",
2182: #ifndef SQLITE_NOHAVE_SYSTEM
2183:     ".system CMD ARGS...      Run CMD ARGS... in a system shell",
2184: #endif
2185:     ".tables ?TABLE?          List names of tables matching LIKE pattern TABLE",
2186:     ".testcase NAME           Begin redirecting output to 'testcase-out.txt'",
2187:     ".thousand_sep SEP        Sets the thousand separator used when rendering numbers. Only for duckbox mode.",
2188:     ".timer on|off            Turn SQL timer on or off",
2189:     ".width NUM1 NUM2 ...     Set minimum column widths for columnar output",
2190:     "     Negative values right-justify",
2191: #if defined(_WIN32) || defined(WIN32)
2192:     ".utf8                    Enable experimental UTF-8 console output mode"
2193: #endif
2194: };
2195: 
2196: /*
2197: ** Output help text.
2198: **
2199: ** zPattern describes the set of commands for which help text is provided.
2200: ** If zPattern is NULL, then show all commands, but only give a one-line
2201: ** description of each.
2202: **
2203: ** Return the number of matches.
2204: */
2205: static int showHelp(FILE *out, const char *zPattern) {
2206: 	int i = 0;
2207: 	int j = 0;
2208: 	int n = 0;
2209: 	char *zPat;
2210: 	if (zPattern == 0 || zPattern[0] == '0' || strcmp(zPattern, "-a") == 0 || strcmp(zPattern, "-all") == 0 ||
2211: 	    strcmp(zPattern, "--all") == 0) {
2212: 		/* Show all commands, but only one line per command */
2213: 		if (zPattern == 0)
2214: 			zPattern = "";
2215: 		for (i = 0; i < ArraySize(azHelp); i++) {
2216: 			if (azHelp[i][0] == '.' || zPattern[0]) {
2217: 				utf8_printf(out, "%s\n", azHelp[i]);
2218: 				n++;
2219: 			}
2220: 		}
2221: 	} else {
2222: 		/* Look for commands that for which zPattern is an exact prefix */
2223: 		zPat = sqlite3_mprintf(".%s*", zPattern);
2224: 		for (i = 0; i < ArraySize(azHelp); i++) {
2225: 			if (sqlite3_strglob(zPat, azHelp[i]) == 0) {
2226: 				utf8_printf(out, "%s\n", azHelp[i]);
2227: 				j = i + 1;
2228: 				n++;
2229: 			}
2230: 		}
2231: 		sqlite3_free(zPat);
2232: 		if (n) {
2233: 			if (n == 1) {
2234: 				/* when zPattern is a prefix of exactly one command, then include the
2235: 				** details of that command, which should begin at offset j */
2236: 				while (j < ArraySize(azHelp) - 1 && azHelp[j][0] != '.') {
2237: 					utf8_printf(out, "%s\n", azHelp[j]);
2238: 					j++;
2239: 				}
2240: 			}
2241: 			return n;
2242: 		}
2243: 		/* Look for commands that contain zPattern anywhere.  Show the complete
2244: 		** text of all commands that match. */
2245: 		zPat = sqlite3_mprintf("%%%s%%", zPattern);
2246: 		for (i = 0; i < ArraySize(azHelp); i++) {
2247: 			if (azHelp[i][0] == '.')
2248: 				j = i;
2249: 			if (sqlite3_strlike(zPat, azHelp[i], 0) == 0) {
2250: 				utf8_printf(out, "%s\n", azHelp[j]);
2251: 				while (j < ArraySize(azHelp) - 1 && azHelp[j + 1][0] != '.') {
2252: 					j++;
2253: 					utf8_printf(out, "%s\n", azHelp[j]);
2254: 				}
2255: 				i = j;
2256: 				n++;
2257: 			}
2258: 		}
2259: 		sqlite3_free(zPat);
2260: 	}
2261: 	return n;
2262: }
2263: 
2264: /*
2265: ** Try to deduce the type of file for zName based on its content.  Return
2266: ** one of the SHELL_OPEN_* constants.
2267: **
2268: ** If the file does not exist or is empty but its name looks like a ZIP
2269: ** archive and the dfltZip flag is true, then assume it is a ZIP archive.
2270: ** Otherwise, assume an ordinary database regardless of the filename if
2271: ** the type cannot be determined from content.
2272: */
2273: int deduceDatabaseType(const char *zName, int dfltZip) {
2274: 	return SHELL_OPEN_NORMAL;
2275: }
2276: 
2277: /* Flags for open_db().
2278: **
2279: ** The default behavior of open_db() is to exit(1) if the database fails to
2280: ** open.  The OPEN_DB_KEEPALIVE flag changes that so that it prints an error
2281: ** but still returns without calling exit.
2282: **
2283: ** The OPEN_DB_ZIPFILE flag causes open_db() to prefer to open files as a
2284: ** ZIP archive if the file does not exist or is empty and its name matches
2285: ** the *.zip pattern.
2286: */
2287: #define OPEN_DB_KEEPALIVE 0x001 /* Return after error if true */
2288: #define OPEN_DB_ZIPFILE   0x002 /* Open as ZIP if name matches *.zip */
2289: /*
2290: ** Make sure the database is open.  If it is not, then open it.  If
2291: ** the database fails to open, print an error message and exit.
2292: */
2293: void ShellState::OpenDB(int flags) {
2294: 	if (db == 0) {
2295: 		if (openMode == SHELL_OPEN_UNSPEC) {
2296: 			if (zDbFilename.empty()) {
2297: 				openMode = SHELL_OPEN_NORMAL;
2298: 			} else {
2299: 				openMode = (u8)deduceDatabaseType(zDbFilename.c_str(), (flags & OPEN_DB_ZIPFILE) != 0);
2300: 			}
2301: 		}
2302: 		switch (openMode) {
2303: 		case SHELL_OPEN_APPENDVFS: {
2304: 			sqlite3_open_v2(zDbFilename.c_str(), &db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | openFlags,
2305: 			                "apndvfs");
2306: 			break;
2307: 		}
2308: 		case SHELL_OPEN_HEXDB:
2309: 		case SHELL_OPEN_DESERIALIZE: {
2310: 			sqlite3_open(0, &db);
2311: 			break;
2312: 		}
2313: 		case SHELL_OPEN_ZIPFILE: {
2314: 			sqlite3_open(":memory:", &db);
2315: 			break;
2316: 		}
2317: 		case SHELL_OPEN_READONLY: {
2318: 			sqlite3_open_v2(zDbFilename.c_str(), &db, SQLITE_OPEN_READONLY | openFlags, 0);
2319: 			break;
2320: 		}
2321: 		case SHELL_OPEN_UNSPEC:
2322: 		case SHELL_OPEN_NORMAL: {
2323: 			sqlite3_open_v2(zDbFilename.c_str(), &db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | openFlags, 0);
2324: 			break;
2325: 		}
2326: 		}
2327: 		globalDb = db;
2328: 		if (db == 0 || SQLITE_OK != sqlite3_errcode(db)) {
2329: 			utf8_printf(stderr, "Error: unable to open database \"%s\": %s\n", zDbFilename.c_str(), sqlite3_errmsg(db));
2330: 			if (flags & OPEN_DB_KEEPALIVE) {
2331: 				sqlite3_open(":memory:", &db);
2332: 				return;
2333: 			}
2334: 			exit(1);
2335: 		}
2336: 		if (safe_mode) {
2337: 			sqlite3_exec(db, "SET enable_external_access=false", NULL, NULL, NULL);
2338: 		}
2339: 		if (stdout_is_console) {
2340: 			sqlite3_exec(db, "PRAGMA enable_progress_bar", NULL, NULL, NULL);
2341: 			sqlite3_exec(db, "PRAGMA enable_print_progress_bar", NULL, NULL, NULL);
2342: 		}
2343: 	}
2344: }
2345: 
2346: /*
2347: ** Attempt to close the databaes connection.  Report errors.
2348: */
2349: void close_db(sqlite3 *db) {
2350: 	int rc = sqlite3_close(db);
2351: 	if (rc) {
2352: 		utf8_printf(stderr, "Error: sqlite3_close() returns %d: %s\n", rc, sqlite3_errmsg(db));
2353: 	}
2354: }
2355: 
2356: #if HAVE_READLINE || HAVE_EDITLINE
2357: /*
2358: ** Readline completion callbacks
2359: */
2360: static char *readline_completion_generator(const char *text, int state) {
2361: 	static sqlite3_stmt *pStmt = 0;
2362: 	char *zRet;
2363: 	if (state == 0) {
2364: 		char *zSql;
2365: 		sqlite3_finalize(pStmt);
2366: 		zSql = sqlite3_mprintf("SELECT DISTINCT candidate COLLATE nocase"
2367: 		                       "  FROM completion(%Q) ORDER BY 1",
2368: 		                       text);
2369: 		sqlite3_prepare_v2(globalDb, zSql, -1, &pStmt, 0);
2370: 		sqlite3_free(zSql);
2371: 	}
2372: 	if (sqlite3_step(pStmt) == SQLITE_ROW) {
2373: 		zRet = strdup((const char *)sqlite3_column_text(pStmt, 0));
2374: 	} else {
2375: 		sqlite3_finalize(pStmt);
2376: 		pStmt = 0;
2377: 		zRet = 0;
2378: 	}
2379: 	return zRet;
2380: }
2381: static char **readline_completion(const char *zText, int iStart, int iEnd) {
2382: 	rl_attempted_completion_over = 1;
2383: 	return rl_completion_matches(zText, readline_completion_generator);
2384: }
2385: 
2386: #elif HAVE_LINENOISE
2387: /*
2388: ** Linenoise completion callback
2389: */
2390: static void linenoise_completion(const char *zLine, linenoiseCompletions *lc) {
2391: 	idx_t nLine = ShellState::StringLength(zLine);
2392: 	int copiedSuggestion = 0;
2393: 	sqlite3_stmt *pStmt = 0;
2394: 	char *zSql;
2395: 	char zBuf[1000];
2396: 
2397: 	if (nLine > sizeof(zBuf) - 30) {
2398: 		return;
2399: 	}
2400: 	if (zLine[0] == '.') {
2401: 		// auto-complete dot command
2402: 		// look for all completions in the help file
2403: 		size_t line_idx;
2404: 		for (line_idx = 0; line_idx < ArraySize(azHelp); line_idx++) {
2405: 			const char *line = azHelp[line_idx];
2406: 			if (line[0] != '.') {
2407: 				continue;
2408: 			}
2409: 			int found_match = 1;
2410: 			size_t line_pos;
2411: 			for (line_pos = 0; !IsSpace(line[line_pos]) && line[line_pos] && line_pos + 1 < sizeof(zBuf); line_pos++) {
2412: 				zBuf[line_pos] = line[line_pos];
2413: 				if (line_pos < nLine && line[line_pos] != zLine[line_pos]) {
2414: 					// only match prefixes for auto-completion, i.e. ".sh" matches ".shell"
2415: 					found_match = 0;
2416: 					break;
2417: 				}
2418: 			}
2419: 			zBuf[line_pos] = '\0';
2420: 			if (found_match && line_pos >= nLine) {
2421: 				linenoiseAddCompletion(lc, zBuf);
2422: 			}
2423: 		}
2424: 		return;
2425: 	}
2426: 	if (zLine[0] == '#') {
2427: 		return;
2428: 	}
2429: 	//  if( i==nLine-1 ) return;
2430: 	zSql = sqlite3_mprintf("CALL sql_auto_complete(%Q)", zLine);
2431: 	sqlite3 *localDb = NULL;
2432: 	if (!globalDb) {
2433: 		sqlite3_open(":memory:", &localDb);
2434: 		sqlite3_prepare_v2(localDb, zSql, -1, &pStmt, 0);
2435: 	} else {
2436: 		sqlite3_prepare_v2(globalDb, zSql, -1, &pStmt, 0);
2437: 	}
2438: 	sqlite3_free(zSql);
2439: 	while (sqlite3_step(pStmt) == SQLITE_ROW) {
2440: 		const char *zCompletion = (const char *)sqlite3_column_text(pStmt, 0);
2441: 		int nCompletion = sqlite3_column_bytes(pStmt, 0);
2442: 		int iStart = sqlite3_column_int(pStmt, 1);
2443: 		if (iStart + nCompletion < int(sizeof(zBuf) - 1)) {
2444: 			if (!copiedSuggestion) {
2445: 				memcpy(zBuf, zLine, iStart);
2446: 				copiedSuggestion = 1;
2447: 			}
2448: 			memcpy(zBuf + iStart, zCompletion, nCompletion + 1);
2449: 			linenoiseAddCompletion(lc, zBuf);
2450: 		}
2451: 	}
2452: 	sqlite3_finalize(pStmt);
2453: 	if (localDb) {
2454: 		sqlite3_close(localDb);
2455: 	}
2456: }
2457: #endif
2458: 
2459: /*
2460: ** Do C-language style dequoting.
2461: **
2462: **    \a    -> alarm
2463: **    \b    -> backspace
2464: **    \t    -> tab
2465: **    \n    -> newline
2466: **    \v    -> vertical tab
2467: **    \f    -> form feed
2468: **    \r    -> carriage return
2469: **    \s    -> space
2470: **    \"    -> "
2471: **    \'    -> '
2472: **    \\    -> backslash
2473: **    \NNN  -> ascii character NNN in octal
2474: */
2475: static void resolve_backslashes(char *z) {
2476: 	int i, j;
2477: 	char c;
2478: 	while (*z && *z != '\\')
2479: 		z++;
2480: 	for (i = j = 0; (c = z[i]) != 0; i++, j++) {
2481: 		if (c == '\\' && z[i + 1] != 0) {
2482: 			c = z[++i];
2483: 			if (c == 'a') {
2484: 				c = '\a';
2485: 			} else if (c == 'b') {
2486: 				c = '\b';
2487: 			} else if (c == 't') {
2488: 				c = '\t';
2489: 			} else if (c == 'n') {
2490: 				c = '\n';
2491: 			} else if (c == 'v') {
2492: 				c = '\v';
2493: 			} else if (c == 'f') {
2494: 				c = '\f';
2495: 			} else if (c == 'r') {
2496: 				c = '\r';
2497: 			} else if (c == '"') {
2498: 				c = '"';
2499: 			} else if (c == '\'') {
2500: 				c = '\'';
2501: 			} else if (c == '\\') {
2502: 				c = '\\';
2503: 			} else if (c >= '0' && c <= '7') {
2504: 				c -= '0';
2505: 				if (z[i + 1] >= '0' && z[i + 1] <= '7') {
2506: 					i++;
2507: 					c = (c << 3) + z[i] - '0';
2508: 					if (z[i + 1] >= '0' && z[i + 1] <= '7') {
2509: 						i++;
2510: 						c = (c << 3) + z[i] - '0';
2511: 					}
2512: 				}
2513: 			}
2514: 		}
2515: 		z[j] = c;
2516: 	}
2517: 	if (j < i)
2518: 		z[j] = 0;
2519: }
2520: 
2521: /*
2522: ** Interpret zArg as either an integer or a boolean value.  Return 1 or 0
2523: ** for TRUE and FALSE.  Return the integer value if appropriate.
2524: */
2525: static bool booleanValue(const char *zArg) {
2526: 	idx_t i;
2527: 	if (zArg[0] == '0' && zArg[1] == 'x') {
2528: 		for (i = 2; hexDigitValue(zArg[i]) >= 0; i++) {
2529: 		}
2530: 	} else {
2531: 		for (i = 0; zArg[i] >= '0' && zArg[i] <= '9'; i++) {
2532: 		}
2533: 	}
2534: 	if (i > 0 && zArg[i] == 0)
2535: 		return bool(integerValue(zArg) & 0xffffffff);
2536: 	if (sqlite3_stricmp(zArg, "on") == 0 || sqlite3_stricmp(zArg, "yes") == 0) {
2537: 		return true;
2538: 	}
2539: 	if (sqlite3_stricmp(zArg, "off") == 0 || sqlite3_stricmp(zArg, "no") == 0) {
2540: 		return false;
2541: 	}
2542: 	utf8_printf(stderr, "ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n", zArg);
2543: 	return false;
2544: }
2545: 
2546: /*
2547: ** Set or clear a shell flag according to a boolean value.
2548: */
2549: void ShellState::SetOrClearFlag(unsigned mFlag, const char *zArg) {
2550: 	if (booleanValue(zArg)) {
2551: 		ShellSetFlag(mFlag);
2552: 	} else {
2553: 		ShellClearFlag(mFlag);
2554: 	}
2555: }
2556: 
2557: /*
2558: ** Close an output file, assuming it is not stderr or stdout
2559: */
2560: static void output_file_close(FILE *f) {
2561: 	if (f && f != stdout && f != stderr)
2562: 		fclose(f);
2563: }
2564: 
2565: /*
2566: ** Try to open an output file.   The names "stdout" and "stderr" are
2567: ** recognized and do the right thing.  NULL is returned if the output
2568: ** filename is "off".
2569: */
2570: static FILE *output_file_open(const char *zFile, int bTextMode) {
2571: 	FILE *f;
2572: 	if (strcmp(zFile, "stdout") == 0) {
2573: 		f = stdout;
2574: 	} else if (strcmp(zFile, "stderr") == 0) {
2575: 		f = stderr;
2576: 	} else if (strcmp(zFile, "off") == 0) {
2577: 		f = 0;
2578: 	} else {
2579: 		f = fopen(zFile, bTextMode ? "w" : "wb");
2580: 		if (f == 0) {
2581: 			utf8_printf(stderr, "Error: cannot open \"%s\"\n", zFile);
2582: 		}
2583: 	}
2584: 	return f;
2585: }
2586: 
2587: /*
2588: ** An object used to read a CSV and other files for import.
2589: */
2590: typedef struct ImportCtx ImportCtx;
2591: struct ImportCtx {
2592: 	const char *zFile;                  /* Name of the input file */
2593: 	FILE *in;                           /* Read the CSV text from this input stream */
2594: 	int(SQLITE_CDECL *xCloser)(FILE *); /* Func to close in */
2595: 	char *z;                            /* Accumulated text for a field */
2596: 	int n;                              /* Number of bytes in z */
2597: 	int nAlloc;                         /* Space allocated for z[] */
2598: 	int nLine;                          /* Current line number */
2599: 	int nRow;                           /* Number of rows imported */
2600: 	int nErr;                           /* Number of errors encountered */
2601: 	int bNotFirst;                      /* True if one or more bytes already read */
2602: 	int cTerm;                          /* Character that terminated the most recent field */
2603: 	int cColSep;                        /* The column separator character.  (Usually ",") */
2604: 	int cRowSep;                        /* The row separator character.  (Usually "\n") */
2605: };
2606: 
2607: /* Clean up resourced used by an ImportCtx */
2608: static void import_cleanup(ImportCtx *p) {
2609: 	if (p->in != 0 && p->xCloser != 0) {
2610: 		p->xCloser(p->in);
2611: 		p->in = 0;
2612: 	}
2613: 	sqlite3_free(p->z);
2614: 	p->z = 0;
2615: }
2616: 
2617: /* Append a single byte to z[] */
2618: static void import_append_char(ImportCtx *p, int c) {
2619: 	if (p->n + 1 >= p->nAlloc) {
2620: 		p->nAlloc += p->nAlloc + 100;
2621: 		p->z = (char *)sqlite3_realloc64(p->z, p->nAlloc);
2622: 		if (p->z == 0)
2623: 			shell_out_of_memory();
2624: 	}
2625: 	p->z[p->n++] = (char)c;
2626: }
2627: 
2628: /* Read a single field of CSV text.  Compatible with rfc4180 and extended
2629: ** with the option of having a separator other than ",".
2630: **
2631: **   +  Input comes from p->in.
2632: **   +  Store results in p->z of length p->n.  Space to hold p->z comes
2633: **      from sqlite3_malloc64().
2634: **   +  Use p->cSep as the column separator.  The default is ",".
2635: **   +  Use p->rSep as the row separator.  The default is "\n".
2636: **   +  Keep track of the line number in p->nLine.
2637: **   +  Store the character that terminates the field in p->cTerm.  Store
2638: **      EOF on end-of-file.
2639: **   +  Report syntax errors on stderr
2640: */
2641: static char *SQLITE_CDECL csv_read_one_field(ImportCtx *p) {
2642: 	int c;
2643: 	int cSep = p->cColSep;
2644: 	int rSep = p->cRowSep;
2645: 	p->n = 0;
2646: 	c = fgetc(p->in);
2647: 	if (c == EOF || seenInterrupt) {
2648: 		p->cTerm = EOF;
2649: 		return 0;
2650: 	}
2651: 	if (c == '"') {
2652: 		int pc, ppc;
2653: 		int startLine = p->nLine;
2654: 		int cQuote = c;
2655: 		pc = ppc = 0;
2656: 		while (1) {
2657: 			c = fgetc(p->in);
2658: 			if (c == rSep)
2659: 				p->nLine++;
2660: 			if (c == cQuote) {
2661: 				if (pc == cQuote) {
2662: 					pc = 0;
2663: 					continue;
2664: 				}
2665: 			}
2666: 			if ((c == cSep && pc == cQuote) || (c == rSep && pc == cQuote) ||
2667: 			    (c == rSep && pc == '\r' && ppc == cQuote) || (c == EOF && pc == cQuote)) {
2668: 				do {
2669: 					p->n--;
2670: 				} while (p->z[p->n] != cQuote);
2671: 				p->cTerm = c;
2672: 				break;
2673: 			}
2674: 			if (pc == cQuote && c != '\r') {
2675: 				utf8_printf(stderr, "%s:%d: unescaped %c character\n", p->zFile, p->nLine, cQuote);
2676: 			}
2677: 			if (c == EOF) {
2678: 				utf8_printf(stderr, "%s:%d: unterminated %c-quoted field\n", p->zFile, startLine, cQuote);
2679: 				p->cTerm = c;
2680: 				break;
2681: 			}
2682: 			import_append_char(p, c);
2683: 			ppc = pc;
2684: 			pc = c;
2685: 		}
2686: 	} else {
2687: 		/* If this is the first field being parsed and it begins with the
2688: 		** UTF-8 BOM  (0xEF BB BF) then skip the BOM */
2689: 		if ((c & 0xff) == 0xef && p->bNotFirst == 0) {
2690: 			import_append_char(p, c);
2691: 			c = fgetc(p->in);
2692: 			if ((c & 0xff) == 0xbb) {
2693: 				import_append_char(p, c);
2694: 				c = fgetc(p->in);
2695: 				if ((c & 0xff) == 0xbf) {
2696: 					p->bNotFirst = 1;
2697: 					p->n = 0;
2698: 					return csv_read_one_field(p);
2699: 				}
2700: 			}
2701: 		}
2702: 		while (c != EOF && c != cSep && c != rSep) {
2703: 			import_append_char(p, c);
2704: 			c = fgetc(p->in);
2705: 		}
2706: 		if (c == rSep) {
2707: 			p->nLine++;
2708: 			if (p->n > 0 && p->z[p->n - 1] == '\r')
2709: 				p->n--;
2710: 		}
2711: 		p->cTerm = c;
2712: 	}
2713: 	if (p->z)
2714: 		p->z[p->n] = 0;
2715: 	p->bNotFirst = 1;
2716: 	return p->z;
2717: }
2718: 
2719: /* Read a single field of ASCII delimited text.
2720: **
2721: **   +  Input comes from p->in.
2722: **   +  Store results in p->z of length p->n.  Space to hold p->z comes
2723: **      from sqlite3_malloc64().
2724: **   +  Use p->cSep as the column separator.  The default is "\x1F".
2725: **   +  Use p->rSep as the row separator.  The default is "\x1E".
2726: **   +  Keep track of the row number in p->nLine.
2727: **   +  Store the character that terminates the field in p->cTerm.  Store
2728: **      EOF on end-of-file.
2729: **   +  Report syntax errors on stderr
2730: */
2731: static char *SQLITE_CDECL ascii_read_one_field(ImportCtx *p) {
2732: 	int c;
2733: 	int cSep = p->cColSep;
2734: 	int rSep = p->cRowSep;
2735: 	p->n = 0;
2736: 	c = fgetc(p->in);
2737: 	if (c == EOF || seenInterrupt) {
2738: 		p->cTerm = EOF;
2739: 		return 0;
2740: 	}
2741: 	while (c != EOF && c != cSep && c != rSep) {
2742: 		import_append_char(p, c);
2743: 		c = fgetc(p->in);
2744: 	}
2745: 	if (c == rSep) {
2746: 		p->nLine++;
2747: 	}
2748: 	p->cTerm = c;
2749: 	if (p->z)
2750: 		p->z[p->n] = 0;
2751: 	return p->z;
2752: }
2753: 
2754: /*
2755: ** Change the output file back to stdout.
2756: **
2757: ** If the p->doXdgOpen flag is set, that means the output was being
2758: ** redirected to a temporary file named by p->zTempFile.  In that case,
2759: ** launch start/open/xdg-open on that temporary file.
2760: */
2761: void ShellState::ResetOutput() {
2762: 	if (outfile.size() > 1 && outfile[0] == '|') {
2763: #ifndef SQLITE_OMIT_POPEN
2764: 		pclose(out);
2765: #endif
2766: 	} else {
2767: 		output_file_close(out);
2768: #ifndef SQLITE_NOHAVE_SYSTEM
2769: 		if (doXdgOpen) {
2770: 			const char *zXdgOpenCmd =
2771: #if defined(_WIN32)
2772: 			    "start";
2773: #elif defined(__APPLE__)
2774: 			    "open";
2775: #else
2776: 			    "xdg-open";
2777: #endif
2778: 			char *zCmd;
2779: 			zCmd = sqlite3_mprintf("%s %s", zXdgOpenCmd, zTempFile);
2780: 			if (system(zCmd)) {
2781: 				utf8_printf(stderr, "Failed: [%s]\n", zCmd);
2782: 			} else {
2783: 				/* Give the start/open/xdg-open command some time to get
2784: 				** going before we continue, and potential delete the
2785: 				** zTempFile data file out from under it */
2786: 				sqlite3_sleep(2000);
2787: 			}
2788: 			sqlite3_free(zCmd);
2789: 			PopOutputMode();
2790: 			doXdgOpen = 0;
2791: 		}
2792: #endif /* !defined(SQLITE_NOHAVE_SYSTEM) */
2793: 	}
2794: 	outfile = string();
2795: 	out = stdout;
2796: 	stdout_is_console = true;
2797: }
2798: 
2799: void ShellState::PrintDatabaseError(const char *zErr) {
2800: 	if (!HighlightErrors()) {
2801: 		utf8_printf(stderr, "%s\n", zErr);
2802: 		return;
2803: 	}
2804: 	ShellHighlight shell_highlight(*this);
2805: 	shell_highlight.PrintError(zErr);
2806: }
2807: 
2808: /*
2809: ** Print the current sqlite3_errmsg() value to stderr and return 1.
2810: */
2811: int ShellState::ShellDatabaseError(sqlite3 *db) {
2812: 	const char *zErr = sqlite3_errmsg(db);
2813: 	PrintDatabaseError(zErr);
2814: 	return 1;
2815: }
2816: 
2817: /*
2818: ** Compare the string as a command-line option with either one or two
2819: ** initial "-" characters.
2820: */
2821: static int optionMatch(const char *zStr, const char *zOpt) {
2822: 	if (zStr[0] != '-')
2823: 		return 0;
2824: 	zStr++;
2825: 	if (zStr[0] == '-')
2826: 		zStr++;
2827: 	return strcmp(zStr, zOpt) == 0;
2828: }
2829: 
2830: /*
2831: ** Delete a file.
2832: */
2833: int shellDeleteFile(const char *zFilename) {
2834: 	int rc;
2835: #ifdef _WIN32
2836: 	wchar_t *z = sqlite3_win32_utf8_to_unicode(zFilename);
2837: 	rc = _wunlink(z);
2838: 	sqlite3_free(z);
2839: #else
2840: 	rc = unlink(zFilename);
2841: #endif
2842: 	return rc;
2843: }
2844: 
2845: /*
2846: ** Try to delete the temporary file (if there is one) and free the
2847: ** memory used to hold the name of the temp file.
2848: */
2849: void ShellState::ClearTempFile() {
2850: 	if (zTempFile == 0)
2851: 		return;
2852: 	if (doXdgOpen)
2853: 		return;
2854: 	if (shellDeleteFile(zTempFile))
2855: 		return;
2856: 	sqlite3_free(zTempFile);
2857: 	zTempFile = 0;
2858: }
2859: 
2860: /*
2861: ** Create a new temp file name with the given suffix.
2862: */
2863: void ShellState::NewTempFile(const char *zSuffix) {
2864: 	ClearTempFile();
2865: 	sqlite3_free(zTempFile);
2866: 	zTempFile = 0;
2867: 	if (db) {
2868: 		sqlite3_file_control(db, 0, SQLITE_FCNTL_TEMPFILENAME, &zTempFile);
2869: 	}
2870: 	if (zTempFile == 0) {
2871: 		/* If db is an in-memory database then the TEMPFILENAME file-control
2872: 		** will not work and we will need to fallback to guessing */
2873: 		const char *zTemp;
2874: 		sqlite3_uint64 r;
2875: 		sqlite3_randomness(sizeof(r), &r);
2876: 		zTemp = getenv("TEMP");
2877: 		if (zTemp == 0)
2878: 			zTemp = getenv("TMP");
2879: 		if (zTemp == 0) {
2880: #ifdef _WIN32
2881: 			zTemp = "\\tmp";
2882: #else
2883: 			zTemp = "/tmp";
2884: #endif
2885: 		}
2886: 		zTempFile = sqlite3_mprintf("%s/temp%llx.%s", zTemp, r, zSuffix);
2887: 	} else {
2888: 		zTempFile = sqlite3_mprintf("%z.%s", zTempFile, zSuffix);
2889: 	}
2890: 	if (zTempFile == 0) {
2891: 		raw_printf(stderr, "out of memory\n");
2892: 		exit(1);
2893: 	}
2894: }
2895: 
2896: enum class MetadataResult : uint8_t { SUCCESS = 0, FAIL = 1, EXIT = 2, PRINT_USAGE = 3 };
2897: 
2898: typedef MetadataResult (*metadata_command_t)(ShellState &state, const char **azArg, idx_t nArg);
2899: 
2900: struct MetadataCommand {
2901: 	const char *command;
2902: 	idx_t argument_count;
2903: 	metadata_command_t callback;
2904: 	const char *usage;
2905: 	const char *description;
2906: 	idx_t match_size;
2907: };
2908: 
2909: MetadataResult ToggleBail(ShellState &state, const char **azArg, idx_t nArg) {
2910: 	bail_on_error = booleanValue(azArg[1]);
2911: 	return MetadataResult::SUCCESS;
2912: }
2913: 
2914: MetadataResult ToggleBinary(ShellState &state, const char **azArg, idx_t nArg) {
2915: 	if (booleanValue(azArg[1])) {
2916: 		state.SetBinaryMode();
2917: 	} else {
2918: 		state.SetTextMode();
2919: 	}
2920: 	return MetadataResult::SUCCESS;
2921: }
2922: 
2923: MetadataResult ChangeDirectory(ShellState &state, const char **azArg, idx_t nArg) {
2924: 	if (safe_mode) {
2925: 		utf8_printf(stderr, ".cd cannot be used in -safe mode\n");
2926: 		return MetadataResult::FAIL;
2927: 	}
2928: 	int rc;
2929: #if defined(_WIN32) || defined(WIN32)
2930: 	wchar_t *z = sqlite3_win32_utf8_to_unicode(azArg[1]);
2931: 	rc = !SetCurrentDirectoryW(z);
2932: 	sqlite3_free(z);
2933: #else
2934: 	rc = chdir(azArg[1]);
2935: #endif
2936: 	if (rc) {
2937: 		utf8_printf(stderr, "Cannot change to directory \"%s\"\n", azArg[1]);
2938: 		return MetadataResult::FAIL;
2939: 	}
2940: 	return MetadataResult::SUCCESS;
2941: }
2942: 
2943: MetadataResult ToggleChanges(ShellState &state, const char **azArg, idx_t nArg) {
2944: 	state.SetOrClearFlag(SHFLG_CountChanges, azArg[1]);
2945: 	return MetadataResult::SUCCESS;
2946: }
2947: 
2948: MetadataResult ShowDatabases(ShellState &state, const char **azArg, idx_t nArg) {
2949: 	char *zErrMsg = 0;
2950: 	state.OpenDB(0);
2951: 
2952: 	auto renderer = state.GetRowRenderer(RenderMode::LIST);
2953: 	renderer->show_header = false;
2954: 	renderer->col_sep = ": ";
2955: 	sqlite3_exec(state.db, "SELECT name, file FROM pragma_database_list", callback, renderer.get(), &zErrMsg);
2956: 	if (zErrMsg) {
2957: 		state.PrintDatabaseError(zErrMsg);
2958: 		sqlite3_free(zErrMsg);
2959: 		return MetadataResult::FAIL;
2960: 	}
2961: 	return MetadataResult::SUCCESS;
2962: }
2963: 
2964: MetadataResult SetSeparator(ShellState &state, const char **azArg, idx_t nArg, const char *separator_name,
2965:                             char &separator) {
2966: 	if (nArg == 1) {
2967: 		raw_printf(state.out, "current %s separator: %c\n", separator_name, separator);
2968: 	} else if (nArg != 2) {
2969: 		return MetadataResult::PRINT_USAGE;
2970: 	} else if (strcmp(azArg[1], "space") == 0) {
2971: 		separator = ' ';
2972: 	} else if (strcmp(azArg[1], "none") == 0) {
2973: 		separator = '\0';
2974: 	} else if (strlen(azArg[1]) != 1) {
2975: 		raw_printf(stderr, ".%s_sep SEP must be one byte, \"space\" or \"none\"\n", separator_name);
2976: 		return MetadataResult::FAIL;
2977: 	} else {
2978: 		separator = azArg[1][0];
2979: 	}
2980: 	return MetadataResult::SUCCESS;
2981: }
2982: 
2983: MetadataResult SetDecimalSep(ShellState &state, const char **azArg, idx_t nArg) {
2984: 	return SetSeparator(state, azArg, nArg, "decimal", state.decimal_separator);
2985: }
2986: 
2987: MetadataResult SetThousandSep(ShellState &state, const char **azArg, idx_t nArg) {
2988: 	return SetSeparator(state, azArg, nArg, "thousand", state.thousand_separator);
2989: }
2990: 
2991: MetadataResult DumpTable(ShellState &state, const char **azArg, idx_t nArg) {
2992: 	char *zLike = 0;
2993: 	char *zSql;
2994: 	bool savedShowHeader = state.showHeader;
2995: 	int savedShellFlags = state.shellFlgs;
2996: 	state.ShellClearFlag(SHFLG_PreserveRowid | SHFLG_Newlines | SHFLG_Echo);
2997: 	for (idx_t i = 1; i < nArg; i++) {
2998: 		if (azArg[i][0] == '-') {
2999: 			const char *z = azArg[i] + 1;
3000: 			if (z[0] == '-')
3001: 				z++;
3002: 			if (strcmp(z, "newlines") == 0) {
3003: 				state.ShellSetFlag(SHFLG_Newlines);
3004: 			} else {
3005: 				raw_printf(stderr, "Unknown option \"%s\" on \".dump\"\n", azArg[i]);
3006: 				sqlite3_free(zLike);
3007: 				return MetadataResult::FAIL;
3008: 			}
3009: 		} else if (zLike) {
3010: 			zLike = sqlite3_mprintf("%z OR name LIKE %Q ESCAPE '\\'", zLike, azArg[i]);
3011: 		} else {
3012: 			zLike = sqlite3_mprintf("name LIKE %Q ESCAPE '\\'", azArg[i]);
3013: 		}
3014: 	}
3015: 
3016: 	state.OpenDB(0);
3017: 
3018: 	/* When playing back a "dump", the content might appear in an order
3019: 	** which causes immediate foreign key constraints to be violated.
3020: 	** So disable foreign-key constraint enforcement to prevent problems. */
3021: 	raw_printf(state.out, "BEGIN TRANSACTION;\n");
3022: 	state.showHeader = 0;
3023: 	state.nErr = 0;
3024: 	if (zLike == 0)
3025: 		zLike = sqlite3_mprintf("true");
3026: 	zSql = sqlite3_mprintf("SELECT name, type, sql FROM sqlite_schema "
3027: 	                       "WHERE (%s) AND type=='table'"
3028: 	                       "  AND sql NOT NULL"
3029: 	                       " ORDER BY tbl_name='sqlite_sequence'",
3030: 	                       zLike);
3031: 	state.RunSchemaDumpQuery(zSql);
3032: 	sqlite3_free(zSql);
3033: 	zSql = sqlite3_mprintf("SELECT sql FROM sqlite_schema "
3034: 	                       "WHERE (%s) AND sql NOT NULL"
3035: 	                       "  AND type IN ('index','trigger','view')",
3036: 	                       zLike);
3037: 	state.RunTableDumpQuery(zSql);
3038: 	sqlite3_free(zSql);
3039: 	sqlite3_free(zLike);
3040: 	raw_printf(state.out, state.nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");
3041: 	state.showHeader = savedShowHeader;
3042: 	state.shellFlgs = savedShellFlags;
3043: 	return MetadataResult::SUCCESS;
3044: }
3045: 
3046: MetadataResult ToggleEcho(ShellState &state, const char **azArg, idx_t nArg) {
3047: 	state.SetOrClearFlag(SHFLG_Echo, azArg[1]);
3048: 	return MetadataResult::SUCCESS;
3049: }
3050: 
3051: MetadataResult ExitProcess(ShellState &state, const char **azArg, idx_t nArg) {
3052: 	if (nArg >= 2) {
3053: 		return MetadataResult::PRINT_USAGE;
3054: 	}
3055: 	int rc = 0;
3056: 	if (nArg > 1 && (rc = (int)integerValue(azArg[1])) != 0) {
3057: 		// exit immediately if a custom error code is provided
3058: 		exit(rc);
3059: 	}
3060: 	return MetadataResult::EXIT;
3061: }
3062: 
3063: MetadataResult ToggleHeaders(ShellState &state, const char **azArg, idx_t nArg) {
3064: 	state.showHeader = booleanValue(azArg[1]);
3065: 	state.shellFlgs |= SHFLG_HeaderSet;
3066: 	return MetadataResult::SUCCESS;
3067: }
3068: 
3069: MetadataResult SetHighlightColors(ShellState &state, const char **azArg, idx_t nArg) {
3070: 	if (nArg < 3 || nArg > 4) {
3071: 		return MetadataResult::PRINT_USAGE;
3072: 	}
3073: 	ShellHighlight highlighter(state);
3074: 	if (!highlighter.SetColor(azArg[1], azArg[2], nArg == 3 ? nullptr : azArg[3])) {
3075: 		return MetadataResult::FAIL;
3076: 	}
3077: 	return MetadataResult::SUCCESS;
3078: }
3079: 
3080: MetadataResult ToggleHighlighErrors(ShellState &state, const char **azArg, idx_t nArg) {
3081: 	highlight_errors = booleanValue(azArg[1]) ? OptionType::ON : OptionType::OFF;
3082: 	return MetadataResult::SUCCESS;
3083: }
3084: 
3085: MetadataResult ToggleHighlightResult(ShellState &state, const char **azArg, idx_t nArg) {
3086: 	highlight_results = booleanValue(azArg[1]) ? OptionType::ON : OptionType::OFF;
3087: 	return MetadataResult::SUCCESS;
3088: }
3089: 
3090: MetadataResult ShowHelp(ShellState &state, const char **azArg, idx_t nArg) {
3091: 	if (nArg >= 2) {
3092: 		int n = showHelp(state.out, azArg[1]);
3093: 		if (n == 0) {
3094: 			utf8_printf(state.out, "Nothing matches '%s'\n", azArg[1]);
3095: 		}
3096: 	} else {
3097: 		showHelp(state.out, 0);
3098: 	}
3099: 	return MetadataResult::SUCCESS;
3100: }
3101: 
3102: MetadataResult ToggleLog(ShellState &state, const char **azArg, idx_t nArg) {
3103: 	if (safe_mode) {
3104: 		utf8_printf(stderr, ".log cannot be used in -safe mode\n");
3105: 		return MetadataResult::FAIL;
3106: 	}
3107: 	const char *zFile = azArg[1];
3108: 	output_file_close(state.pLog);
3109: 	state.pLog = output_file_open(zFile, 0);
3110: 	return MetadataResult::SUCCESS;
3111: }
3112: 
3113: MetadataResult SetMaxRows(ShellState &state, const char **azArg, idx_t nArg) {
3114: 	if (nArg > 2) {
3115: 		return MetadataResult::PRINT_USAGE;
3116: 	}
3117: 	if (nArg == 1) {
3118: 		raw_printf(state.out, "current max rows: %zu\n", state.max_rows);
3119: 	} else {
3120: 		state.max_rows = (size_t)integerValue(azArg[1]);
3121: 	}
3122: 	return MetadataResult::SUCCESS;
3123: }
3124: 
3125: MetadataResult SetMaxWidth(ShellState &state, const char **azArg, idx_t nArg) {
3126: 	if (nArg > 2) {
3127: 		return MetadataResult::PRINT_USAGE;
3128: 	}
3129: 	if (nArg == 1) {
3130: 		raw_printf(state.out, "current max rows: %zu\n", state.max_width);
3131: 	} else {
3132: 		state.max_width = (size_t)integerValue(azArg[1]);
3133: 	}
3134: 	return MetadataResult::SUCCESS;
3135: }
3136: 
3137: MetadataResult SetColumnRendering(ShellState &state, const char **azArg, idx_t nArg) {
3138: 	state.columns = 1;
3139: 	return MetadataResult::SUCCESS;
3140: }
3141: 
3142: MetadataResult SetRowRendering(ShellState &state, const char **azArg, idx_t nArg) {
3143: 	state.columns = 1;
3144: 	return MetadataResult::SUCCESS;
3145: }
3146: 
3147: bool ShellState::SetOutputMode(const char *mode_str, const char *tbl_name) {
3148: 	idx_t n2 = StringLength(mode_str);
3149: 	char c2 = mode_str[0];
3150: 	if (c2 == 'l' && n2 > 2 && strncmp(mode_str, "lines", n2) == 0) {
3151: 		mode = RenderMode::LINE;
3152: 		rowSeparator = SEP_Row;
3153: 	} else if (c2 == 'c' && strncmp(mode_str, "columns", n2) == 0) {
3154: 		mode = RenderMode::COLUMN;
3155: 		if ((shellFlgs & SHFLG_HeaderSet) == 0) {
3156: 			showHeader = true;
3157: 		}
3158: 		rowSeparator = SEP_Row;
3159: 	} else if (c2 == 'l' && n2 > 2 && strncmp(mode_str, "list", n2) == 0) {
3160: 		mode = RenderMode::LIST;
3161: 		colSeparator = SEP_Column;
3162: 		rowSeparator = SEP_Row;
3163: 	} else if (c2 == 'h' && strncmp(mode_str, "html", n2) == 0) {
3164: 		mode = RenderMode::HTML;
3165: 	} else if (c2 == 't' && strncmp(mode_str, "tcl", n2) == 0) {
3166: 		mode = RenderMode::TCL;
3167: 		colSeparator = SEP_Space;
3168: 		rowSeparator = SEP_Row;
3169: 	} else if (c2 == 'c' && strncmp(mode_str, "csv", n2) == 0) {
3170: 		mode = RenderMode::CSV;
3171: 		colSeparator = SEP_Comma;
3172: 		rowSeparator = SEP_CrLf;
3173: 	} else if (c2 == 't' && strncmp(mode_str, "tabs", n2) == 0) {
3174: 		mode = RenderMode::LIST;
3175: 		colSeparator = SEP_Tab;
3176: 	} else if (c2 == 'i' && strncmp(mode_str, "insert", n2) == 0) {
3177: 		mode = RenderMode::INSERT;
3178: 		SetTableName(tbl_name ? tbl_name : "table");
3179: 	} else if (c2 == 'q' && strncmp(mode_str, "quote", n2) == 0) {
3180: 		mode = RenderMode::QUOTE;
3181: 		colSeparator = SEP_Comma;
3182: 		rowSeparator = SEP_Row;
3183: 	} else if (c2 == 'a' && strncmp(mode_str, "ascii", n2) == 0) {
3184: 		mode = RenderMode::ASCII;
3185: 		colSeparator = SEP_Unit;
3186: 		rowSeparator = SEP_Record;
3187: 	} else if (c2 == 'm' && strncmp(mode_str, "markdown", n2) == 0) {
3188: 		mode = RenderMode::MARKDOWN;
3189: 	} else if (c2 == 't' && strncmp(mode_str, "table", n2) == 0) {
3190: 		mode = RenderMode::TABLE;
3191: 	} else if (c2 == 'b' && strncmp(mode_str, "box", n2) == 0) {
3192: 		mode = RenderMode::BOX;
3193: 	} else if (c2 == 'd' && strncmp(mode_str, "duckbox", n2) == 0) {
3194: 		mode = RenderMode::DUCKBOX;
3195: 	} else if (c2 == 'j' && strncmp(mode_str, "json", n2) == 0) {
3196: 		mode = RenderMode::JSON;
3197: 	} else if (c2 == 'l' && strncmp(mode_str, "latex", n2) == 0) {
3198: 		mode = RenderMode::LATEX;
3199: 	} else if (c2 == 't' && strncmp(mode_str, "trash", n2) == 0) {
3200: 		mode = RenderMode::TRASH;
3201: 	} else if (c2 == 'j' && strncmp(mode_str, "jsonlines", n2) == 0) {
3202: 		mode = RenderMode::JSONLINES;
3203: 	} else {
3204: 		raw_printf(stderr, "Error: mode should be one of: "
3205: 		                   "ascii box column csv duckbox html insert json jsonlines latex line "
3206: 		                   "list markdown quote table tabs tcl trash \n");
3207: 		return false;
3208: 	}
3209: 	cMode = mode;
3210: 	return true;
3211: }
3212: 
3213: MetadataResult SetOutputMode(ShellState &state, const char **azArg, idx_t nArg) {
3214: 	if (nArg > 3) {
3215: 		return MetadataResult::PRINT_USAGE;
3216: 	}
3217: 	if (nArg == 1) {
3218: 		raw_printf(state.out, "current output mode: %s\n", modeDescr[int(state.mode)]);
3219: 	} else {
3220: 		if (!state.SetOutputMode(azArg[1], nArg > 2 ? azArg[2] : nullptr)) {
3221: 			return MetadataResult::FAIL;
3222: 		}
3223: 	}
3224: 	return MetadataResult::SUCCESS;
3225: }
3226: 
3227: MetadataResult SetNullValue(ShellState &state, const char **azArg, idx_t nArg) {
3228: 	state.nullValue = azArg[1];
3229: 	return MetadataResult::SUCCESS;
3230: }
3231: 
3232: bool ShellState::ImportData(const char **azArg, idx_t nArg) {
3233: 	if (safe_mode) {
3234: 		utf8_printf(stderr, ".import cannot be used in -safe mode\n");
3235: 		return false;
3236: 	}
3237: 	int rc;
3238: 	const char *zTable = nullptr;              /* Insert data into this table */
3239: 	const char *zFile = nullptr;               /* Name of file to extra content from */
3240: 	sqlite3_stmt *pStmt = nullptr;             /* A statement */
3241: 	int nCol;                                  /* Number of columns in the table */
3242: 	int nByte;                                 /* Number of bytes in an SQL string */
3243: 	int j;                                     /* Loop counters */
3244: 	int needCommit;                            /* True to COMMIT or ROLLBACK at end */
3245: 	char *zSql;                                /* An SQL statement */
3246: 	ImportCtx sCtx;                            /* Reader context */
3247: 	char *(SQLITE_CDECL * xRead)(ImportCtx *); /* Func to read one value */
3248: 	int eVerbose = 0;                          /* Larger for more console output */
3249: 	int nSkip = 0;                             /* Initial lines to skip */
3250: 	int useOutputMode = 1;                     /* Use output mode to determine separators */
3251: 
3252: 	memset(&sCtx, 0, sizeof(sCtx));
3253: 	if (mode == RenderMode::ASCII) {
3254: 		xRead = ascii_read_one_field;
3255: 	} else {
3256: 		xRead = csv_read_one_field;
3257: 	}
3258: 	for (idx_t i = 1; i < nArg; i++) {
3259: 		auto z = azArg[i];
3260: 		if (z[0] == '-' && z[1] == '-')
3261: 			z++;
3262: 		if (z[0] != '-') {
3263: 			if (zFile == 0) {
3264: 				zFile = z;
3265: 			} else if (zTable == 0) {
3266: 				zTable = z;
3267: 			} else {
3268: 				utf8_printf(out, "ERROR: extra argument: \"%s\".  Usage:\n", z);
3269: 				showHelp(out, "import");
3270: 				return false;
3271: 			}
3272: 		} else if (strcmp(z, "-v") == 0) {
3273: 			eVerbose++;
3274: 		} else if (strcmp(z, "-skip") == 0 && i < nArg - 1) {
3275: 			nSkip = (int)integerValue(azArg[++i]);
3276: 		} else if (strcmp(z, "-ascii") == 0) {
3277: 			sCtx.cColSep = SEP_Unit[0];
3278: 			sCtx.cRowSep = SEP_Record[0];
3279: 			xRead = ascii_read_one_field;
3280: 			useOutputMode = 0;
3281: 		} else if (strcmp(z, "-csv") == 0) {
3282: 			sCtx.cColSep = ',';
3283: 			sCtx.cRowSep = '\n';
3284: 			xRead = csv_read_one_field;
3285: 			useOutputMode = 0;
3286: 		} else {
3287: 			utf8_printf(out, "ERROR: unknown option: \"%s\".  Usage:\n", z);
3288: 			showHelp(out, "import");
3289: 			return false;
3290: 		}
3291: 	}
3292: 	if (zTable == 0) {
3293: 		utf8_printf(out, "ERROR: missing %s argument. Usage:\n", zFile == 0 ? "FILE" : "TABLE");
3294: 		showHelp(out, "import");
3295: 		return false;
3296: 	}
3297: 	seenInterrupt = 0;
3298: 	OpenDB(0);
3299: 	if (useOutputMode) {
3300: 		/* If neither the --csv or --ascii options are specified, then set
3301: 		** the column and row separator characters from the output mode. */
3302: 		int nSep = colSeparator.size();
3303: 		if (nSep == 0) {
3304: 			raw_printf(stderr, "Error: non-null column separator required for import\n");
3305: 			return false;
3306: 		}
3307: 		if (nSep > 1) {
3308: 			raw_printf(stderr, "Error: multi-character column separators not allowed"
3309: 			                   " for import\n");
3310: 			return false;
3311: 		}
3312: 		nSep = rowSeparator.size();
3313: 		if (nSep == 0) {
3314: 			raw_printf(stderr, "Error: non-null row separator required for import\n");
3315: 			return false;
3316: 		}
3317: 		if (nSep == 2 && mode == RenderMode::CSV && rowSeparator == SEP_CrLf) {
3318: 			/* When importing CSV (only), if the row separator is set to the
3319: 			** default output row separator, change it to the default input
3320: 			** row separator.  This avoids having to maintain different input
3321: 			** and output row separators. */
3322: 			rowSeparator = SEP_Row;
3323: 			nSep = rowSeparator.size();
3324: 		}
3325: 		if (nSep > 1) {
3326: 			raw_printf(stderr, "Error: multi-character row separators not allowed"
3327: 			                   " for import\n");
3328: 			return false;
3329: 		}
3330: 		sCtx.cColSep = colSeparator[0];
3331: 		sCtx.cRowSep = rowSeparator[0];
3332: 	}
3333: 	sCtx.zFile = zFile;
3334: 	sCtx.nLine = 1;
3335: 	if (sCtx.zFile[0] == '|') {
3336: #ifdef SQLITE_OMIT_POPEN
3337: 		raw_printf(stderr, "Error: pipes are not supported in this OS\n");
3338: 		rc = 1;
3339: 		goto meta_command_exit;
3340: #else
3341: 		sCtx.in = popen(sCtx.zFile + 1, "r");
3342: 		sCtx.zFile = "<pipe>";
3343: 		sCtx.xCloser = pclose;
3344: #endif
3345: 	} else {
3346: 		sCtx.in = fopen(sCtx.zFile, "rb");
3347: 		sCtx.xCloser = fclose;
3348: 	}
3349: 	if (sCtx.in == 0) {
3350: 		utf8_printf(stderr, "Error: cannot open \"%s\"\n", zFile);
3351: 		return false;
3352: 	}
3353: 	if (eVerbose >= 2 || (eVerbose >= 1 && useOutputMode)) {
3354: 		char zSep[2];
3355: 		zSep[1] = 0;
3356: 		zSep[0] = sCtx.cColSep;
3357: 		utf8_printf(out, "Column separator ");
3358: 		OutputCString(zSep);
3359: 		utf8_printf(out, ", row separator ");
3360: 		zSep[0] = sCtx.cRowSep;
3361: 		OutputCString(zSep);
3362: 		utf8_printf(out, "\n");
3363: 	}
3364: 	while ((nSkip--) > 0) {
3365: 		while (xRead(&sCtx) && sCtx.cTerm == sCtx.cColSep) {
3366: 		}
3367: 	}
3368: 	zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);
3369: 	if (zSql == 0) {
3370: 		import_cleanup(&sCtx);
3371: 		shell_out_of_memory();
3372: 	}
3373: 	nByte = StringLength(zSql);
3374: 	rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
3375: 	import_append_char(&sCtx, 0); /* To ensure sCtx.z is allocated */
3376: 	if (rc && sqlite3_strglob("Catalog Error: Table with name *", sqlite3_errmsg(db)) == 0) {
3377: 		char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);
3378: 		char cSep = '(';
3379: 		while (xRead(&sCtx)) {
3380: 			zCreate = sqlite3_mprintf("%z%c\n  \"%w\" TEXT", zCreate, cSep, sCtx.z);
3381: 			cSep = ',';
3382: 			if (sCtx.cTerm != sCtx.cColSep)
3383: 				break;
3384: 		}
3385: 		if (cSep == '(') {
3386: 			sqlite3_free(zCreate);
3387: 			import_cleanup(&sCtx);
3388: 			utf8_printf(stderr, "%s: empty file\n", sCtx.zFile);
3389: 			return false;
3390: 		}
3391: 		zCreate = sqlite3_mprintf("%z\n)", zCreate);
3392: 		if (eVerbose >= 1) {
3393: 			utf8_printf(out, "%s\n", zCreate);
3394: 		}
3395: 		rc = sqlite3_exec(db, zCreate, 0, 0, 0);
3396: 		sqlite3_free(zCreate);
3397: 		if (rc) {
3398: 			utf8_printf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable, sqlite3_errmsg(db));
3399: 			import_cleanup(&sCtx);
3400: 			return false;
3401: 		}
3402: 		rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
3403: 	}
3404: 	sqlite3_free(zSql);
3405: 	if (rc) {
3406: 		if (pStmt)
3407: 			sqlite3_finalize(pStmt);
3408: 		ShellDatabaseError(db);
3409: 		import_cleanup(&sCtx);
3410: 		return false;
3411: 	}
3412: 	nCol = sqlite3_column_count(pStmt);
3413: 	sqlite3_finalize(pStmt);
3414: 	pStmt = 0;
3415: 	if (nCol == 0)
3416: 		return 0; /* no columns, no error */
3417: 	zSql = (char *)sqlite3_malloc64(nByte * 2 + 20 + nCol * 2);
3418: 	if (zSql == 0) {
3419: 		import_cleanup(&sCtx);
3420: 		shell_out_of_memory();
3421: 	}
3422: 	sqlite3_snprintf(nByte + 20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);
3423: 	j = StringLength(zSql);
3424: 	for (int i = 1; i < nCol; i++) {
3425: 		zSql[j++] = ',';
3426: 		zSql[j++] = '?';
3427: 	}
3428: 	zSql[j++] = ')';
3429: 	zSql[j] = 0;
3430: 	if (eVerbose >= 2) {
3431: 		utf8_printf(out, "Insert using: %s\n", zSql);
3432: 	}
3433: 	rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
3434: 	sqlite3_free(zSql);
3435: 	if (rc) {
3436: 		ShellDatabaseError(db);
3437: 		if (pStmt)
3438: 			sqlite3_finalize(pStmt);
3439: 		import_cleanup(&sCtx);
3440: 		return false;
3441: 	}
3442: 	needCommit = sqlite3_get_autocommit(db);
3443: 	if (needCommit)
3444: 		sqlite3_exec(db, "BEGIN", 0, 0, 0);
3445: 	do {
3446: 		int startLine = sCtx.nLine;
3447: 		int i;
3448: 		for (i = 0; i < nCol; i++) {
3449: 			char *z = xRead(&sCtx);
3450: 			/*
3451: 			** Did we reach end-of-file before finding any columns?
3452: 			** If so, stop instead of NULL filling the remaining columns.
3453: 			*/
3454: 			if (z == 0 && i == 0)
3455: 				break;
3456: 			/*
3457: 			** Did we reach end-of-file OR end-of-line before finding any
3458: 			** columns in ASCII mode?  If so, stop instead of NULL filling
3459: 			** the remaining columns.
3460: 			*/
3461: 			if (mode == RenderMode::ASCII && (z == 0 || z[0] == 0) && i == 0)
3462: 				break;
3463: 			sqlite3_bind_text(pStmt, i + 1, z, -1, SQLITE_TRANSIENT);
3464: 			if (i < nCol - 1 && sCtx.cTerm != sCtx.cColSep) {
3465: 				utf8_printf(stderr,
3466: 				            "%s:%d: expected %d columns but found %d - "
3467: 				            "filling the rest with NULL\n",
3468: 				            sCtx.zFile, startLine, nCol, i + 1);
3469: 				i += 2;
3470: 				while (i <= nCol) {
3471: 					sqlite3_bind_null(pStmt, i);
3472: 					i++;
3473: 				}
3474: 			}
3475: 		}
3476: 		if (sCtx.cTerm == sCtx.cColSep) {
3477: 			do {
3478: 				xRead(&sCtx);
3479: 				i++;
3480: 			} while (sCtx.cTerm == sCtx.cColSep);
3481: 			utf8_printf(stderr,
3482: 			            "%s:%d: expected %d columns but found %d - "
3483: 			            "extras ignored\n",
3484: 			            sCtx.zFile, startLine, nCol, i);
3485: 		}
3486: 		if (i >= nCol) {
3487: 			sqlite3_step(pStmt);
3488: 			rc = sqlite3_reset(pStmt);
3489: 			if (rc != SQLITE_OK) {
3490: 				utf8_printf(stderr, "%s:%d: INSERT failed: %s\n", sCtx.zFile, startLine, sqlite3_errmsg(db));
3491: 				sCtx.nErr++;
3492: 			} else {
3493: 				sCtx.nRow++;
3494: 			}
3495: 		}
3496: 	} while (sCtx.cTerm != EOF);
3497: 
3498: 	import_cleanup(&sCtx);
3499: 	sqlite3_finalize(pStmt);
3500: 	if (needCommit)
3501: 		sqlite3_exec(db, "COMMIT", 0, 0, 0);
3502: 	if (eVerbose > 0) {
3503: 		utf8_printf(out, "Added %d rows with %d errors using %d lines of input\n", sCtx.nRow, sCtx.nErr,
3504: 		            sCtx.nLine - 1);
3505: 	}
3506: 	return true;
3507: }
3508: 
3509: MetadataResult ImportData(ShellState &state, const char **azArg, idx_t nArg) {
3510: 	if (!state.ImportData(azArg, nArg)) {
3511: 		return MetadataResult::FAIL;
3512: 	}
3513: 	return MetadataResult::SUCCESS;
3514: }
3515: 
3516: bool ShellState::OpenDatabase(const char **azArg, idx_t nArg) {
3517: 	if (safe_mode) {
3518: 		utf8_printf(stderr, ".open cannot be used in -safe mode\n");
3519: 		return false;
3520: 	}
3521: 	char *zNewFilename;   /* Name of the database file to open */
3522: 	idx_t iName = 1;      /* Index in azArg[] of the filename */
3523: 	bool newFlag = false; /* True to delete file before opening */
3524: 	/* Close the existing database */
3525: 	close_db(db);
3526: 	db = nullptr;
3527: 	globalDb = nullptr;
3528: 	zDbFilename = string();
3529: 	openMode = SHELL_OPEN_UNSPEC;
3530: 	openFlags = openFlags & ~(SQLITE_OPEN_NOFOLLOW); // don't overwrite settings loaded in the command line
3531: 	szMax = 0;
3532: 	/* Check for command-line arguments */
3533: 	for (idx_t iName = 1; iName < nArg && azArg[iName][0] == '-'; iName++) {
3534: 		const char *z = azArg[iName];
3535: 		if (optionMatch(z, "new")) {
3536: 			newFlag = true;
3537: 		} else if (optionMatch(z, "readonly")) {
3538: 			openMode = SHELL_OPEN_READONLY;
3539: 		} else if (optionMatch(z, "nofollow")) {
3540: 			openFlags |= SQLITE_OPEN_NOFOLLOW;
3541: 		} else if (z[0] == '-') {
3542: 			utf8_printf(stderr, "unknown option: %s\n", z);
3543: 			return false;
3544: 		}
3545: 	}
3546: 	/* If a filename is specified, try to open it first */
3547: 	zNewFilename = nArg > iName ? sqlite3_mprintf("%s", azArg[iName]) : 0;
3548: 	if (zNewFilename || openMode == SHELL_OPEN_HEXDB) {
3549: 		if (newFlag) {
3550: 			shellDeleteFile(zNewFilename);
3551: 		}
3552: 		zDbFilename = zNewFilename;
3553: 		sqlite3_free(zNewFilename);
3554: 		OpenDB(OPEN_DB_KEEPALIVE);
3555: 		if (!db) {
3556: 			utf8_printf(stderr, "Error: cannot open '%s'\n", zNewFilename);
3557: 		}
3558: 	}
3559: 	if (!db) {
3560: 		/* As a fall-back open a TEMP database */
3561: 		zDbFilename = string();
3562: 		OpenDB(0);
3563: 	}
3564: 	return true;
3565: }
3566: 
3567: MetadataResult OpenDatabase(ShellState &state, const char **azArg, idx_t nArg) {
3568: 	if (!state.OpenDatabase(azArg, nArg)) {
3569: 		return MetadataResult::FAIL;
3570: 	}
3571: 	return MetadataResult::SUCCESS;
3572: }
3573: 
3574: MetadataResult PrintArguments(ShellState &state, const char **azArg, idx_t nArg) {
3575: 	for (idx_t i = 1; i < nArg; i++) {
3576: 		if (i > 1) {
3577: 			raw_printf(state.out, " ");
3578: 		}
3579: 		utf8_printf(state.out, "%s", azArg[i]);
3580: 	}
3581: 	raw_printf(state.out, "\n");
3582: 	return MetadataResult::SUCCESS;
3583: }
3584: 
3585: MetadataResult SetPrompt(ShellState &, const char **azArg, idx_t nArg) {
3586: 	if (nArg >= 2) {
3587: 		strncpy(mainPrompt, azArg[1], (int)ArraySize(mainPrompt) - 1);
3588: 	}
3589: 	if (nArg >= 3) {
3590: 		strncpy(continuePrompt, azArg[2], (int)ArraySize(continuePrompt) - 1);
3591: 	}
3592: 	if (nArg >= 4) {
3593: 		strncpy(continuePromptSelected, azArg[3], (int)ArraySize(continuePromptSelected) - 1);
3594: 	}
3595: 	return MetadataResult::SUCCESS;
3596: }
3597: 
3598: MetadataResult SetSeparator(ShellState &state, const char **azArg, idx_t nArg) {
3599: 	if (nArg < 2 || nArg > 3) {
3600: 		return MetadataResult::PRINT_USAGE;
3601: 	}
3602: 	state.colSeparator = azArg[1];
3603: 	if (nArg >= 3) {
3604: 		state.rowSeparator = azArg[2];
3605: 	}
3606: 	return MetadataResult::SUCCESS;
3607: }
3608: 
3609: MetadataResult QuitProcess(ShellState &, const char **azArg, idx_t nArg) {
3610: 	return MetadataResult::EXIT;
3611: }
3612: 
3613: bool ShellState::SetOutputFile(const char **azArg, idx_t nArg, char output_mode) {
3614: 	if (safe_mode) {
3615: 		utf8_printf(stderr, ".output/.once/.excel cannot be used in -safe mode\n");
3616: 		return false;
3617: 	}
3618: 	const char *zFile = nullptr;
3619: 	int bTxtMode = 0;
3620: 	int eMode = 0;
3621: 	bool bBOM = false;
3622: 	int bOnce = 0; /* 0: .output, 1: .once, 2: .excel */
3623: 
3624: 	if (output_mode == 'e') {
3625: 		// .excel
3626: 		eMode = 'x';
3627: 		bOnce = 2;
3628: 	} else if (output_mode == 'o') {
3629: 		// .once
3630: 		bOnce = 1;
3631: 	}
3632: 	for (idx_t i = 1; i < nArg; i++) {
3633: 		const char *z = azArg[i];
3634: 		if (z[0] == '-') {
3635: 			if (z[1] == '-') {
3636: 				z++;
3637: 			}
3638: 			if (strcmp(z, "-bom") == 0) {
3639: 				bBOM = true;
3640: 			} else if (output_mode != 'e' && strcmp(z, "-x") == 0) {
3641: 				eMode = 'x'; /* spreadsheet */
3642: 			} else if (output_mode != 'e' && strcmp(z, "-e") == 0) {
3643: 				eMode = 'e'; /* text editor */
3644: 			} else {
3645: 				utf8_printf(out, "ERROR: unknown option: \"%s\".  Usage:\n", azArg[i]);
3646: 				showHelp(out, azArg[0]);
3647: 				return false;
3648: 			}
3649: 		} else if (!zFile) {
3650: 			zFile = z;
3651: 		} else {
3652: 			utf8_printf(out, "ERROR: extra parameter: \"%s\".  Usage:\n", azArg[i]);
3653: 			showHelp(out, azArg[0]);
3654: 			return false;
3655: 		}
3656: 	}
3657: 	if (!zFile) {
3658: 		zFile = "stdout";
3659: 	}
3660: 	if (bOnce) {
3661: 		outCount = 2;
3662: 	} else {
3663: 		outCount = 0;
3664: 	}
3665: 	ResetOutput();
3666: #ifndef SQLITE_NOHAVE_SYSTEM
3667: 	if (eMode == 'e' || eMode == 'x') {
3668: 		doXdgOpen = 1;
3669: 		PushOutputMode();
3670: 		if (eMode == 'x') {
3671: 			/* spreadsheet mode.  Output as CSV. */
3672: 			NewTempFile("csv");
3673: 			ShellClearFlag(SHFLG_Echo);
3674: 			mode = RenderMode::CSV;
3675: 			colSeparator = SEP_Comma;
3676: 			rowSeparator = SEP_CrLf;
3677: 		} else {
3678: 			/* text editor mode */
3679: 			NewTempFile("txt");
3680: 			bTxtMode = 1;
3681: 		}
3682: 		zFile = zTempFile;
3683: 	}
3684: #endif /* SQLITE_NOHAVE_SYSTEM */
3685: 	if (zFile[0] == '|') {
3686: #ifdef SQLITE_OMIT_POPEN
3687: 		raw_printf(stderr, "Error: pipes are not supported in this OS\n");
3688: 		out = stdout;
3689: 		return false;
3690: #else
3691: 		out = popen(zFile + 1, "w");
3692: 		if (out == 0) {
3693: 			utf8_printf(stderr, "Error: cannot open pipe \"%s\"\n", zFile + 1);
3694: 			out = stdout;
3695: 			return false;
3696: 		} else {
3697: 			if (bBOM) {
3698: 				fprintf(out, "\357\273\277");
3699: 			}
3700: 			outfile = zFile;
3701: 		}
3702: #endif
3703: 	} else {
3704: 		out = output_file_open(zFile, bTxtMode);
3705: 		if (!out) {
3706: 			if (strcmp(zFile, "off") != 0) {
3707: 				utf8_printf(stderr, "Error: cannot write to \"%s\"\n", zFile);
3708: 			}
3709: 			out = stdout;
3710: 			return false;
3711: 		} else {
3712: 			if (bBOM) {
3713: 				fprintf(out, "\357\273\277");
3714: 			}
3715: 			outfile = zFile;
3716: 		}
3717: 	}
3718: 	stdout_is_console = false;
3719: 	return true;
3720: }
3721: 
3722: MetadataResult SetOutput(ShellState &state, const char **azArg, idx_t nArg) {
3723: 	if (!state.SetOutputFile(azArg, nArg, '\0')) {
3724: 		return MetadataResult::FAIL;
3725: 	}
3726: 	return MetadataResult::SUCCESS;
3727: }
3728: 
3729: MetadataResult SetOutputOnce(ShellState &state, const char **azArg, idx_t nArg) {
3730: 	if (!state.SetOutputFile(azArg, nArg, 'o')) {
3731: 		return MetadataResult::FAIL;
3732: 	}
3733: 	return MetadataResult::SUCCESS;
3734: }
3735: 
3736: MetadataResult SetOutputExcel(ShellState &state, const char **azArg, idx_t nArg) {
3737: 	if (!state.SetOutputFile(azArg, nArg, 'e')) {
3738: 		return MetadataResult::FAIL;
3739: 	}
3740: 	return MetadataResult::SUCCESS;
3741: }
3742: 
3743: bool ShellState::ReadFromFile(const string &file) {
3744: 	if (safe_mode) {
3745: 		utf8_printf(stderr, ".read cannot be used in -safe mode\n");
3746: 		return false;
3747: 	}
3748: 	FILE *inSaved = in;
3749: 	int savedLineno = lineno;
3750: 	int rc;
3751: 	if (notNormalFile(file.c_str()) || (in = fopen(file.c_str(), "rb")) == 0) {
3752: 		utf8_printf(stderr, "Error: cannot open \"%s\"\n", file.c_str());
3753: 		rc = 1;
3754: 	} else {
3755: 		rc = ProcessInput();
3756: 		fclose(in);
3757: 	}
3758: 	in = inSaved;
3759: 	lineno = savedLineno;
3760: 	return rc == 0;
3761: }
3762: 
3763: MetadataResult ReadFromFile(ShellState &state, const char **azArg, idx_t nArg) {
3764: 	if (!state.ReadFromFile(azArg[1])) {
3765: 		return MetadataResult::FAIL;
3766: 	}
3767: 	return MetadataResult::SUCCESS;
3768: }
3769: 
3770: bool ShellState::DisplaySchemas(const char **azArg, idx_t nArg) {
3771: 	string sSelect;
3772: 	char *zErrMsg = 0;
3773: 	const char *zDiv = "(";
3774: 	const char *zName = 0;
3775: 	int bDebug = 0;
3776: 	int rc;
3777: 
3778: 	OpenDB(0);
3779: 
3780: 	RenderMode mode = RenderMode::SEMI;
3781: 	for (idx_t ii = 1; ii < nArg; ii++) {
3782: 		if (optionMatch(azArg[ii], "indent")) {
3783: 			mode = RenderMode::PRETTY;
3784: 		} else if (optionMatch(azArg[ii], "debug")) {
3785: 			bDebug = 1;
3786: 		} else if (zName == 0) {
3787: 			zName = azArg[ii];
3788: 		} else {
3789: 			raw_printf(stderr, "Usage: .schema ?--indent? ?LIKE-PATTERN?\n");
3790: 			return false;
3791: 		}
3792: 	}
3793: 	auto renderer = GetRowRenderer(mode);
3794: 	renderer->show_header = false;
3795: 	if (zDiv) {
3796: 		appendText(sSelect, "SELECT sql FROM sqlite_master WHERE ", 0);
3797: 		if (zName) {
3798: 			char *zQarg = sqlite3_mprintf("%Q", zName);
3799: 			int bGlob = strchr(zName, '*') != 0 || strchr(zName, '?') != 0 || strchr(zName, '[') != 0;
3800: 			if (strchr(zName, '.')) {
3801: 				appendText(sSelect, "lower(printf('%s.%s',sname,tbl_name))", 0);
3802: 			} else {
3803: 				appendText(sSelect, "lower(tbl_name)", 0);
3804: 			}
3805: 			appendText(sSelect, bGlob ? " GLOB " : " LIKE ", 0);
3806: 			appendText(sSelect, zQarg, 0);
3807: 			if (!bGlob) {
3808: 				appendText(sSelect, " ESCAPE '\\' ", 0);
3809: 			}
3810: 			appendText(sSelect, " AND ", 0);
3811: 			sqlite3_free(zQarg);
3812: 		}
3813: 		appendText(sSelect,
3814: 		           "type!='meta' AND sql IS NOT NULL"
3815: 		           " ORDER BY name",
3816: 		           0);
3817: 		if (bDebug) {
3818: 			utf8_printf(out, "SQL: %s;\n", sSelect.c_str());
3819: 		} else {
3820: 			rc = sqlite3_exec(db, sSelect.c_str(), callback, renderer.get(), &zErrMsg);
3821: 		}
3822: 	}
3823: 	if (zErrMsg) {
3824: 		PrintDatabaseError(zErrMsg);
3825: 		sqlite3_free(zErrMsg);
3826: 		return false;
3827: 	} else if (rc != SQLITE_OK) {
3828: 		raw_printf(stderr, "Error: querying schema information\n");
3829: 		return false;
3830: 	} else {
3831: 		return true;
3832: 	}
3833: }
3834: 
3835: MetadataResult DisplaySchemas(ShellState &state, const char **azArg, idx_t nArg) {
3836: 	if (!state.DisplaySchemas(azArg, nArg)) {
3837: 		return MetadataResult::FAIL;
3838: 	}
3839: 	return MetadataResult::SUCCESS;
3840: }
3841: 
3842: MetadataResult RunShellCommand(ShellState &state, const char **azArg, idx_t nArg) {
3843: 	if (safe_mode) {
3844: 		utf8_printf(stderr, ".sh/.system cannot be used in -safe mode\n");
3845: 		return MetadataResult::FAIL;
3846: 	}
3847: 	char *zCmd;
3848: 	int x;
3849: 	if (nArg < 2) {
3850: 		return MetadataResult::PRINT_USAGE;
3851: 	}
3852: 	zCmd = sqlite3_mprintf(strchr(azArg[1], ' ') == 0 ? "%s" : "\"%s\"", azArg[1]);
3853: 	for (idx_t i = 2; i < nArg; i++) {
3854: 		zCmd = sqlite3_mprintf(strchr(azArg[i], ' ') == 0 ? "%z %s" : "%z \"%s\"", zCmd, azArg[i]);
3855: 	}
3856: 	x = system(zCmd);
3857: 	sqlite3_free(zCmd);
3858: 	if (x) {
3859: 		raw_printf(stderr, "System command returns %d\n", x);
3860: 	}
3861: 	return MetadataResult::SUCCESS;
3862: }
3863: 
3864: void ShellState::ShowConfiguration() {
3865: 	utf8_printf(out, "%12.12s: %s\n", "echo", ShellHasFlag(SHFLG_Echo) ? "on" : "off");
3866: 	utf8_printf(out, "%12.12s: %s\n", "headers", showHeader ? "on" : "off");
3867: 	utf8_printf(out, "%12.12s: %s\n", "mode", modeDescr[int(mode)]);
3868: 	utf8_printf(out, "%12.12s: ", "nullvalue");
3869: 	OutputCString(nullValue.c_str());
3870: 	raw_printf(out, "\n");
3871: 	utf8_printf(out, "%12.12s: %s\n", "output", !outfile.empty() ? outfile.c_str() : "stdout");
3872: 	utf8_printf(out, "%12.12s: ", "colseparator");
3873: 	OutputCString(colSeparator.c_str());
3874: 	raw_printf(out, "\n");
3875: 	utf8_printf(out, "%12.12s: ", "rowseparator");
3876: 	OutputCString(rowSeparator.c_str());
3877: 	raw_printf(out, "\n");
3878: 	utf8_printf(out, "%12.12s: ", "width");
3879: 	for (auto w : colWidth) {
3880: 		raw_printf(out, "%d ", w);
3881: 	}
3882: 	raw_printf(out, "\n");
3883: 	utf8_printf(out, "%12.12s: %s\n", "filename", zDbFilename.c_str());
3884: }
3885: 
3886: MetadataResult ShowConfiguration(ShellState &state, const char **azArg, idx_t nArg) {
3887: 	state.ShowConfiguration();
3888: 	return MetadataResult::SUCCESS;
3889: }
3890: 
3891: MetadataResult ToggleTimer(ShellState &state, const char **azArg, idx_t nArg) {
3892: 	enableTimer = booleanValue(azArg[1]);
3893: 	if (enableTimer && !HAS_TIMER) {
3894: 		raw_printf(stderr, "Error: timer not available on this system.\n");
3895: 		enableTimer = false;
3896: 	}
3897: 	return MetadataResult::SUCCESS;
3898: }
3899: 
3900: MetadataResult ShowVersion(ShellState &state, const char **azArg, idx_t nArg) {
3901: 	utf8_printf(state.out, "SQLite %s %s\n" /*extra-version-info*/, sqlite3_libversion(), sqlite3_sourceid());
3902: #define CTIMEOPT_VAL_(opt) #opt
3903: #define CTIMEOPT_VAL(opt)  CTIMEOPT_VAL_(opt)
3904: #if defined(__clang__) && defined(__clang_major__)
3905: 	utf8_printf(state.out, "clang-" CTIMEOPT_VAL(__clang_major__) "." CTIMEOPT_VAL(__clang_minor__) "." CTIMEOPT_VAL(
3906: 	                           __clang_patchlevel__) "\n");
3907: #elif defined(_MSC_VER)
3908: 	utf8_printf(state.out, "msvc-" CTIMEOPT_VAL(_MSC_VER) "\n");
3909: #elif defined(__GNUC__) && defined(__VERSION__)
3910: 	utf8_printf(state.out, "gcc-" __VERSION__ "\n");
3911: #endif
3912: 	return MetadataResult::SUCCESS;
3913: }
3914: 
3915: MetadataResult SetWidths(ShellState &state, const char **azArg, idx_t nArg) {
3916: 	state.colWidth.clear();
3917: 	for (idx_t j = 1; j < nArg; j++) {
3918: 		state.colWidth.push_back((int)integerValue(azArg[j]));
3919: 	}
3920: 	return MetadataResult::SUCCESS;
3921: }
3922: 
3923: MetadataResult ShellState::DisplayEntries(const char **azArg, idx_t nArg, char type) {
3924: 	sqlite3_stmt *pStmt;
3925: 	char **azResult;
3926: 	int nRow, nAlloc;
3927: 	int ii;
3928: 	string s;
3929: 	OpenDB(0);
3930: 	//    rc = sqlite3_prepare_v2(db, "PRAGMA database_list", -1, &pStmt, 0);
3931: 	//    if( rc ){
3932: 	//      sqlite3_finalize(pStmt);
3933: 	//      return shellDatabaseError(db);
3934: 	//    }
3935: 
3936: 	if (nArg > 2) {
3937: 		return MetadataResult::PRINT_USAGE;
3938: 	}
3939: 	//    for(ii=0; sqlite3_step(pStmt)==SQLITE_ROW; ii++){
3940: 	//      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);
3941: 	//      if( zDbName==0 ) continue;
3942: 	//      if( s.z && s.z[0] ) appendText(&s, " UNION ALL ", 0);
3943: 	appendText(s, "SELECT name FROM ", 0);
3944: 	//      appendText(&s, zDbName, '"');
3945: 	appendText(s, "sqlite_schema ", 0);
3946: 	if (type == 't') {
3947: 		appendText(s,
3948: 		           " WHERE type IN ('table','view')"
3949: 		           "   AND name NOT LIKE 'sqlite_%'"
3950: 		           "   AND name LIKE ?1",
3951: 		           0);
3952: 	} else {
3953: 		appendText(s,
3954: 		           " WHERE type='index'"
3955: 		           "   AND tbl_name LIKE ?1",
3956: 		           0);
3957: 	}
3958: 	//    }
3959: 	//    rc = sqlite3_finalize(pStmt);
3960: 	appendText(s, " ORDER BY 1", 0);
3961: 	int rc = sqlite3_prepare_v2(db, s.c_str(), -1, &pStmt, 0);
3962: 	if (rc) {
3963: 		return MetadataResult::FAIL;
3964: 	}
3965: 
3966: 	/* Run the SQL statement prepared by the above block. Store the results
3967: 	** as an array of nul-terminated strings in azResult[].  */
3968: 	nRow = nAlloc = 0;
3969: 	azResult = nullptr;
3970: 	if (nArg > 1) {
3971: 		sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);
3972: 	} else {
3973: 		sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);
3974: 	}
3975: 	while (sqlite3_step(pStmt) == SQLITE_ROW) {
3976: 		if (nRow >= nAlloc) {
3977: 			char **azNew;
3978: 			int n2 = nAlloc * 2 + 10;
3979: 			azNew = (char **)sqlite3_realloc64(azResult, sizeof(azResult[0]) * n2);
3980: 			if (azNew == 0)
3981: 				shell_out_of_memory();
3982: 			nAlloc = n2;
3983: 			azResult = azNew;
3984: 		}
3985: 		azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));
3986: 		if (0 == azResult[nRow])
3987: 			shell_out_of_memory();
3988: 		nRow++;
3989: 	}
3990: 	if (sqlite3_finalize(pStmt) != SQLITE_OK) {
3991: 		rc = ShellDatabaseError(db);
3992: 	}
3993: 
3994: 	/* Pretty-print the contents of array azResult[] to the output */
3995: 	if (rc == 0 && nRow > 0) {
3996: 		int len, maxlen = 0;
3997: 		int i, j;
3998: 		int nPrintCol, nPrintRow;
3999: 		for (i = 0; i < nRow; i++) {
4000: 			len = StringLength(azResult[i]);
4001: 			if (len > maxlen)
4002: 				maxlen = len;
4003: 		}
4004: 		nPrintCol = 80 / (maxlen + 2);
4005: 		if (nPrintCol < 1)
4006: 			nPrintCol = 1;
4007: 		nPrintRow = (nRow + nPrintCol - 1) / nPrintCol;
4008: 		for (i = 0; i < nPrintRow; i++) {
4009: 			for (j = i; j < nRow; j += nPrintRow) {
4010: 				const char *zSp = j < nPrintRow ? "" : "  ";
4011: 				utf8_printf(out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");
4012: 			}
4013: 			raw_printf(out, "\n");
4014: 		}
4015: 	}
4016: 
4017: 	for (ii = 0; ii < nRow; ii++) {
4018: 		sqlite3_free(azResult[ii]);
4019: 	}
4020: 	sqlite3_free(azResult);
4021: 	return rc == 0 ? MetadataResult::SUCCESS : MetadataResult::FAIL;
4022: }
4023: 
4024: MetadataResult ShowIndexes(ShellState &state, const char **azArg, idx_t nArg) {
4025: 	return state.DisplayEntries(azArg, nArg, 'i');
4026: }
4027: 
4028: MetadataResult ShowTables(ShellState &state, const char **azArg, idx_t nArg) {
4029: 	return state.DisplayEntries(azArg, nArg, 't');
4030: }
4031: 
4032: #if defined(_WIN32) || defined(WIN32)
4033: MetadataResult SetUTF8Mode(ShellState &state, const char **azArg, idx_t nArg) {
4034: 	win_utf8_mode = 1;
4035: 	return MetadataResult::SUCCESS;
4036: }
4037: #endif
4038: 
4039: static const MetadataCommand metadata_commands[] = {
4040:     {"backup", 0, nullptr, "?DB? FILE", "Backup DB (default \"main\") to FILE", 3},
4041:     {"bail", 2, ToggleBail, "on|off", "Stop after hitting an error.  Default OFF", 3},
4042:     {"binary", 2, ToggleBinary, "on|off", "Turn binary output on or off.  Default OFF", 3},
4043:     {"cd", 2, ChangeDirectory, "DIRECTORY", "Change the working directory to DIRECTORY", 0},
4044:     {"changes", 2, ToggleChanges, "on|off", "Show number of rows changed by SQL", 3},
4045:     {"columns", 1, SetColumnRendering, "", "Column-wise rendering of query results", 0},
4046: 
4047:     {"decimal_sep", 0, SetDecimalSep, "SEP",
4048:      "Sets the decimal separator used when rendering numbers. Only for duckbox mode.", 3},
4049:     {"databases", 1, ShowDatabases, "", "List names and files of attached databases", 2},
4050:     {"dump", 0, DumpTable, "?TABLE?",
4051:      "Render database content as SQL\n   Options:\n     --newlines             Allow unescaped newline characters in "
4052:      "output\n   TABLE is a LIKE pattern for the tables to dump\n   Additional LIKE patterns can be given in "
4053:      "subsequent arguments",
4054:      0},
4055:     {"echo", 2, ToggleEcho, "on|off", "Turn command echo on or off", 3},
4056:     {"excel", 0, SetOutputExcel, "", "Display the output of next command in spreadsheet", 0},
4057:     {"exit", 0, ExitProcess, "?CODE?", "Exit this program with return-code CODE", 0},
4058:     {"fullschema", 0, nullptr, "", "", 0},
4059:     {"headers", 2, ToggleHeaders, "on|off", "Turn display of headers on or off", 0},
4060:     {"help", 0, ShowHelp, "?-all? ?PATTERN?", "Show help text for PATTERN", 0},
4061:     {"highlight_colors", 0, SetHighlightColors, "[element] [color] ([bold])?", "Configure highlighting colors", 0},
4062:     {"highlight_errors", 2, ToggleHighlighErrors, "on|off", "Turn highlighting of errors on or off", 0},
4063:     {"highlight_results", 2, ToggleHighlightResult, "on|off", "Turn highlighting of results on or off", 0},
4064:     {"import", 0, ImportData, "FILE TABLE", "Import data from FILE into TABLE", 0},
4065: 
4066:     {"indexes", 0, ShowIndexes, "?TABLE?", "Show names of indexes", 0},
4067:     {"indices", 0, ShowIndexes, "?TABLE?", "Show names of indexes", 0},
4068:     {"log", 2, ToggleLog, "FILE|off", "Turn logging on or off.  FILE can be stderr/stdout", 0},
4069:     {"maxrows", 0, SetMaxRows, "COUNT",
4070:      "Sets the maximum number of rows for display (default: 40). Only for duckbox mode.", 0},
4071:     {"maxwidth", 0, SetMaxWidth, "COUNT",
4072:      "Sets the maximum width in characters. 0 defaults to terminal width. Only for duckbox mode.", 0},
4073:     {"mode", 0, SetOutputMode, "MODE ?TABLE?", "Set output mode", 0},
4074:     {"nullvalue", 2, SetNullValue, "STRING", "Use STRING in place of NULL values", 0},
4075: 
4076:     {"open", 0, OpenDatabase, "?OPTIONS? ?FILE?", "Close existing database and reopen FILE", 2},
4077:     {"once", 0, SetOutputOnce, "?FILE?", "Output for the next SQL command only to FILE", 0},
4078:     {"output", 0, SetOutput, "?FILE?", "Send output to FILE or stdout if FILE is omitted", 0},
4079:     {"print", 0, PrintArguments, "STRING...", "Print literal STRING", 3},
4080:     {"prompt", 0, SetPrompt, "MAIN CONTINUE", "Replace the standard prompts", 0},
4081: 
4082:     {"quit", 0, QuitProcess, "", "Exit this program", 0},
4083:     {"read", 2, ReadFromFile, "FILE", "Read input from FILE", 3},
4084:     {"rows", 1, SetRowRendering, "", "Row-wise rendering of query results (default)", 0},
4085:     {"restore", 0, nullptr, "", "", 3},
4086:     {"save", 0, nullptr, "?DB? FILE", "Backup DB (default \"main\") to FILE", 3},
4087:     {"separator", 0, SetSeparator, "COL ?ROW?", "Change the column and row separators", 0},
4088:     {"schema", 0, DisplaySchemas, "?PATTERN?", "Show the CREATE statements matching PATTERN", 0},
4089:     {"shell", 0, RunShellCommand, "CMD ARGS...", "Run CMD ARGS... in a system shell", 0},
4090:     {"show", 1, ShowConfiguration, "", "Show the current values for various settings", 0},
4091:     {"system", 0, RunShellCommand, "CMD ARGS...", "Run CMD ARGS... in a system shell", 0},
4092:     {"tables", 0, ShowTables, "?TABLE?", "List names of tables matching LIKE pattern TABLE", 2},
4093:     {"thousand_sep", 0, SetThousandSep, "SEP",
4094:      "Sets the thousand separator used when rendering numbers. Only for duckbox mode.", 4},
4095:     {"timeout", 0, nullptr, "", "", 5},
4096:     {"timer", 2, ToggleTimer, "on|off", "Turn SQL timer on or off", 0},
4097:     {"version", 1, ShowVersion, "", "Show the version", 0},
4098:     {"width", 0, SetWidths, "NUM1 NUM2 ...", "Set minimum column widths for columnar output", 0},
4099: #if defined(_WIN32) || defined(WIN32)
4100:     {"utf8", 1, SetUTF8Mode, "", "Enable experimental UTF-8 console output mode", 0},
4101: #endif
4102: 
4103:     {nullptr, 0, nullptr}};
4104: 
4105: /*
4106: ** If an input line begins with "." then invoke this routine to
4107: ** process that line.
4108: **
4109: ** Return 1 on error, 2 to exit, and 0 otherwise.
4110: */
4111: int ShellState::DoMetaCommand(char *zLine) {
4112: 	int h = 1;
4113: 	int nArg = 0;
4114: 	int n, c;
4115: 	int rc = 0;
4116: 	char *azArg[52];
4117: 
4118: 	/* Parse the input line into tokens.
4119: 	 */
4120: 	while (zLine[h] && nArg < ArraySize(azArg) - 1) {
4121: 		while (IsSpace(zLine[h])) {
4122: 			h++;
4123: 		}
4124: 		if (zLine[h] == 0)
4125: 			break;
4126: 		if (zLine[h] == '\'' || zLine[h] == '"') {
4127: 			int delim = zLine[h++];
4128: 			azArg[nArg++] = &zLine[h];
4129: 			while (zLine[h] && zLine[h] != delim) {
4130: 				if (zLine[h] == '\\' && delim == '"' && zLine[h + 1] != 0)
4131: 					h++;
4132: 				h++;
4133: 			}
4134: 			if (zLine[h] == delim) {
4135: 				zLine[h++] = 0;
4136: 			}
4137: 			if (delim == '"')
4138: 				resolve_backslashes(azArg[nArg - 1]);
4139: 		} else {
4140: 			azArg[nArg++] = &zLine[h];
4141: 			while (zLine[h] && !IsSpace(zLine[h])) {
4142: 				h++;
4143: 			}
4144: 			if (zLine[h])
4145: 				zLine[h++] = 0;
4146: 			resolve_backslashes(azArg[nArg - 1]);
4147: 		}
4148: 	}
4149: 	azArg[nArg] = 0;
4150: 
4151: 	/* Process the input line.
4152: 	 */
4153: 	if (nArg == 0) {
4154: 		return 0; /* no tokens, no error */
4155: 	}
4156: 	n = StringLength(azArg[0]);
4157: 	c = azArg[0][0];
4158: 	ClearTempFile();
4159: 
4160: 	bool found_argument = false;
4161: 	for (idx_t command_idx = 0; metadata_commands[command_idx].command; command_idx++) {
4162: 		auto &command = metadata_commands[command_idx];
4163: 		idx_t match_size = command.match_size ? command.match_size : n;
4164: 		if (n < int(match_size) || c != *command.command || strncmp(azArg[0], command.command, n) != 0) {
4165: 			continue;
4166: 		}
4167: 		found_argument = true;
4168: 		MetadataResult result = MetadataResult::PRINT_USAGE;
4169: 		if (!command.callback) {
4170: 			raw_printf(stderr, "Command \"%s\" is unsupported in the current version of the CLI\n", command.command);
4171: 			result = MetadataResult::FAIL;
4172: 		} else if (command.argument_count == 0 || int(command.argument_count) == nArg) {
4173: 			result = command.callback(*this, (const char **)azArg, nArg);
4174: 		}
4175: 		if (result == MetadataResult::PRINT_USAGE) {
4176: 			raw_printf(stderr, "Usage: .%s %s\n", command.command, command.usage);
4177: 			result = MetadataResult::FAIL;
4178: 		}
4179: 		rc = int(result);
4180: 		break;
4181: 	}
4182: 	if (found_argument) {
4183: 	} else {
4184: #ifdef HAVE_LINENOISE
4185: 		const char *error = NULL;
4186: 		if (linenoiseParseOption((const char **)azArg, nArg, &error)) {
4187: 			if (error) {
4188: 				PrintDatabaseError(error);
4189: 				rc = 1;
4190: 			}
4191: 		} else {
4192: #endif
4193: 			utf8_printf(stderr,
4194: 			            "Error: unknown command or invalid arguments: "
4195: 			            " \"%s\". Enter \".help\" for help\n",
4196: 			            azArg[0]);
4197: 			rc = 1;
4198: #ifdef HAVE_LINENOISE
4199: 		}
4200: #endif
4201: 	}
4202: 
4203: 	if (outCount) {
4204: 		outCount--;
4205: 		if (outCount == 0)
4206: 			ResetOutput();
4207: 	}
4208: 	return rc;
4209: }
4210: 
4211: /*
4212: ** Return TRUE if a semicolon occurs anywhere in the first N characters
4213: ** of string z[].
4214: */
4215: static bool line_contains_semicolon(const char *z, idx_t N) {
4216: 	for (idx_t i = 0; i < N; i++) {
4217: 		if (z[i] == ';') {
4218: 			return true;
4219: 		}
4220: 	}
4221: 	return false;
4222: }
4223: 
4224: /*
4225: ** Test to see if a line consists entirely of whitespace.
4226: */
4227: static bool _all_whitespace(const char *z) {
4228: 	for (; *z; z++) {
4229: 		if (IsSpace(z[0])) {
4230: 			continue;
4231: 		}
4232: 		if (*z == '/' && z[1] == '*') {
4233: 			z += 2;
4234: 			while (*z && (*z != '*' || z[1] != '/')) {
4235: 				z++;
4236: 			}
4237: 			if (*z == 0) {
4238: 				return false;
4239: 			}
4240: 			z++;
4241: 			continue;
4242: 		}
4243: 		if (*z == '-' && z[1] == '-') {
4244: 			z += 2;
4245: 			while (*z && *z != '\n') {
4246: 				z++;
4247: 			}
4248: 			if (*z == 0)
4249: 				return true;
4250: 			continue;
4251: 		}
4252: 		return false;
4253: 	}
4254: 	return true;
4255: }
4256: 
4257: /*
4258: ** We need a default sqlite3_complete() implementation to use in case
4259: ** the shell is compiled with SQLITE_OMIT_COMPLETE.  The default assumes
4260: ** any arbitrary text is a complete SQL statement.  This is not very
4261: ** user-friendly, but it does seem to work.
4262: */
4263: #ifdef SQLITE_OMIT_COMPLETE
4264: #define sqlite3_complete(x) 1
4265: #endif
4266: 
4267: /*
4268: ** Run a single line of SQL.  Return the number of errors.
4269: */
4270: int ShellState::RunOneSqlLine(char *zSql) {
4271: 	int rc;
4272: 	char *zErrMsg = nullptr;
4273: 
4274: 	OpenDB(0);
4275: 	if (ShellHasFlag(SHFLG_Backslash)) {
4276: 		resolve_backslashes(zSql);
4277: 	}
4278: #ifndef SHELL_USE_LOCAL_GETLINE
4279: 	if (zSql && *zSql && *zSql != '\3') {
4280: 		shell_add_history(zSql);
4281: 	}
4282: #endif
4283: 	BEGIN_TIMER;
4284: 	rc = ExecuteSQL(zSql, &zErrMsg);
4285: 	END_TIMER;
4286: 	if (rc || zErrMsg) {
4287: 		if (zErrMsg != 0) {
4288: 			PrintDatabaseError(zErrMsg);
4289: 			sqlite3_free(zErrMsg);
4290: 			zErrMsg = 0;
4291: 		} else {
4292: 			ShellDatabaseError(db);
4293: 		}
4294: 		return 1;
4295: 	} else if (ShellHasFlag(SHFLG_CountChanges)) {
4296: 		raw_printf(out, "changes: %3lld   total_changes: %lld\n", sqlite3_changes64(db), sqlite3_total_changes64(db));
4297: 	}
4298: 	return 0;
4299: }
4300: 
4301: /*
4302: ** Read input from *in and process it.  If *in==0 then input
4303: ** is interactive - the user is typing it it.  Otherwise, input
4304: ** is coming from a file or device.  A prompt is issued and history
4305: ** is saved only if input is interactive.  An interrupt signal will
4306: ** cause this routine to exit immediately, unless input is interactive.
4307: **
4308: ** Return the number of errors.
4309: */
4310: int ShellState::ProcessInput() {
4311: 	char *zLine = nullptr; /* A single input line */
4312: 	char *zSql = nullptr;  /* Accumulated SQL text */
4313: 	idx_t nLine;           /* Length of current line */
4314: 	idx_t nSql = 0;        /* Bytes of zSql[] used */
4315: 	idx_t nAlloc = 0;      /* Allocated zSql[] space */
4316: 	idx_t nSqlPrior = 0;   /* Bytes of zSql[] used by prior line */
4317: 	int rc;                /* Error code */
4318: 	idx_t errCnt = 0;      /* Number of errors seen */
4319: 	idx_t numCtrlC = 0;
4320: 	lineno = 0;
4321: 	while (errCnt == 0 || !bail_on_error || (!in && stdin_is_interactive)) {
4322: 		fflush(out);
4323: 		zLine = one_input_line(in, zLine, nSql > 0);
4324: 		if (!zLine) {
4325: 			/* End of input */
4326: 			if (!in && stdin_is_interactive) {
4327: 				printf("\n");
4328: 			}
4329: 			break;
4330: 		}
4331: 		if (*zLine == '\3') {
4332: 			// ctrl c: reset sql statement
4333: 			if (nSql == 0 && zLine[1] == '\0' && stdin_is_interactive) {
4334: 				// if in interactive mode and we press ctrl c twice
4335: 				// on an empty line, we exit
4336: 				numCtrlC++;
4337: 				if (numCtrlC >= 2) {
4338: 					break;
4339: 				}
4340: 			}
4341: 			nSql = 0;
4342: 			continue;
4343: 		} else {
4344: 			numCtrlC = 0;
4345: 		}
4346: 		if (seenInterrupt) {
4347: 			if (in) {
4348: 				break;
4349: 			}
4350: 			seenInterrupt = 0;
4351: 		}
4352: 		lineno++;
4353: 		if (nSql == 0 && _all_whitespace(zLine)) {
4354: 			if (ShellHasFlag(SHFLG_Echo)) {
4355: 				printf("%s\n", zLine);
4356: 			}
4357: 			continue;
4358: 		}
4359: 		if (zLine && (zLine[0] == '.' || zLine[0] == '#') && nSql == 0) {
4360: 			if (ShellHasFlag(SHFLG_Echo)) {
4361: 				printf("%s\n", zLine);
4362: 			}
4363: 			if (zLine[0] == '.') {
4364: #ifndef SHELL_USE_LOCAL_GETLINE
4365: 				if (zLine && *zLine && *zLine != '\3')
4366: 					shell_add_history(zLine);
4367: #endif
4368: 				rc = DoMetaCommand(zLine);
4369: 				if (rc == 2) { /* exit requested */
4370: 					break;
4371: 				} else if (rc) {
4372: 					errCnt++;
4373: 				}
4374: 			}
4375: 			continue;
4376: 		}
4377: 		nLine = StringLength(zLine);
4378: 		if (nSql + nLine + 2 >= nAlloc) {
4379: 			nAlloc = nSql + nLine + 100;
4380: 			zSql = (char *)realloc(zSql, nAlloc);
4381: 			if (!zSql) {
4382: 				shell_out_of_memory();
4383: 			}
4384: 		}
4385: 		nSqlPrior = nSql;
4386: 		if (nSql == 0) {
4387: 			int i;
4388: 			for (i = 0; zLine[i] && IsSpace(zLine[i]); i++) {
4389: 			}
4390: 			assert(nAlloc > 0 && zSql);
4391: 			memcpy(zSql, zLine + i, nLine + 1 - i);
4392: 			nSql = nLine - i;
4393: 		} else {
4394: 			zSql[nSql++] = '\n';
4395: 			memcpy(zSql + nSql, zLine, nLine + 1);
4396: 			nSql += nLine;
4397: 		}
4398: 		if (nSql && line_contains_semicolon(&zSql[nSqlPrior], nSql - nSqlPrior) && sqlite3_complete(zSql)) {
4399: 			errCnt += RunOneSqlLine(zSql);
4400: 			nSql = 0;
4401: 			if (outCount) {
4402: 				ResetOutput();
4403: 				outCount = 0;
4404: 			} else {
4405: 				ClearTempFile();
4406: 			}
4407: 		} else if (nSql && _all_whitespace(zSql)) {
4408: 			if (ShellHasFlag(SHFLG_Echo)) {
4409: 				printf("%s\n", zSql);
4410: 			}
4411: 			nSql = 0;
4412: 		}
4413: 	}
4414: 	if (nSql && !_all_whitespace(zSql)) {
4415: 		errCnt += RunOneSqlLine(zSql);
4416: 	}
4417: 	free(zSql);
4418: 	free(zLine);
4419: 	return errCnt > 0;
4420: }
4421: 
4422: /*
4423: ** Return a pathname which is the user's home directory.  A
4424: ** 0 return indicates an error of some kind.
4425: */
4426: static char *find_home_dir(int clearFlag) {
4427: 	static char *home_dir = nullptr;
4428: 	if (clearFlag) {
4429: 		free(home_dir);
4430: 		home_dir = nullptr;
4431: 		return nullptr;
4432: 	}
4433: 	if (home_dir) {
4434: 		return home_dir;
4435: 	}
4436: 
4437: #if !defined(_WIN32) && !defined(WIN32) && !defined(_WIN32_WCE) && !defined(__RTP__) && !defined(_WRS_KERNEL)
4438: 	{
4439: 		struct passwd *pwent;
4440: 		uid_t uid = getuid();
4441: 		if ((pwent = getpwuid(uid)) != NULL) {
4442: 			home_dir = pwent->pw_dir;
4443: 		}
4444: 	}
4445: #endif
4446: 
4447: #if defined(_WIN32_WCE)
4448: 	/* Windows CE (arm-wince-mingw32ce-gcc) does not provide getenv()
4449: 	 */
4450: 	home_dir = "/";
4451: #else
4452: 
4453: #if defined(_WIN32) || defined(WIN32)
4454: 	if (!home_dir) {
4455: 		home_dir = getenv("USERPROFILE");
4456: 	}
4457: #endif
4458: 
4459: 	if (!home_dir) {
4460: 		home_dir = getenv("HOME");
4461: 	}
4462: 
4463: #if defined(_WIN32) || defined(WIN32)
4464: 	if (!home_dir) {
4465: 		char *zDrive, *zPath;
4466: 		idx_t n;
4467: 		zDrive = getenv("HOMEDRIVE");
4468: 		zPath = getenv("HOMEPATH");
4469: 		if (zDrive && zPath) {
4470: 			n = ShellState::StringLength(zDrive) + ShellState::StringLength(zPath) + 1;
4471: 			home_dir = (char *)malloc(n);
4472: 			if (home_dir == 0)
4473: 				return 0;
4474: 			sqlite3_snprintf(n, home_dir, "%s%s", zDrive, zPath);
4475: 			return home_dir;
4476: 		}
4477: 		home_dir = "c:\\";
4478: 	}
4479: #endif
4480: 
4481: #endif /* !_WIN32_WCE */
4482: 
4483: 	if (home_dir) {
4484: 		int n = ShellState::StringLength(home_dir) + 1;
4485: 		char *z = (char *)malloc(n);
4486: 		if (z) {
4487: 			memcpy(z, home_dir, n);
4488: 		}
4489: 		home_dir = z;
4490: 	}
4491: 
4492: 	return home_dir;
4493: }
4494: 
4495: /*
4496: ** Read input from the file given by sqliterc_override.  Or if that
4497: ** parameter is NULL, take input from ~/.duckdbrc
4498: **
4499: ** Returns the number of errors.
4500: */
4501: void ShellState::ProcessDuckDBRC(const char *sqliterc_override) {
4502: 	const char *sqliterc = sqliterc_override;
4503: 	char *zBuf = nullptr;
4504: 	FILE *inSaved = in;
4505: 	int savedLineno = lineno;
4506: 
4507: 	if (!sqliterc) {
4508: 		auto home_dir = find_home_dir(0);
4509: 		if (!home_dir) {
4510: 			raw_printf(stderr, "-- warning: cannot find home directory;"
4511: 			                   " cannot read ~/.duckdbrc\n");
4512: 			return;
4513: 		}
4514: 		zBuf = sqlite3_mprintf("%s/.duckdbrc", home_dir);
4515: 		sqliterc = zBuf;
4516: 	}
4517: 	in = fopen(sqliterc, "rb");
4518: 	if (in) {
4519: 		if (stdin_is_interactive) {
4520: 			utf8_printf(stderr, "-- Loading resources from %s\n", sqliterc);
4521: 		}
4522: 		ProcessInput();
4523: 		fclose(in);
4524: 	}
4525: 	in = inSaved;
4526: 	lineno = savedLineno;
4527: 	sqlite3_free(zBuf);
4528: }
4529: 
4530: /*
4531: ** Show available command line options
4532: */
4533: static const char zOptions[] = "   -ascii               set output mode to 'ascii'\n"
4534:                                "   -bail                stop after hitting an error\n"
4535:                                "   -batch               force batch I/O\n"
4536:                                "   -box                 set output mode to 'box'\n"
4537:                                "   -column              set output mode to 'column'\n"
4538:                                "   -cmd COMMAND         run \"COMMAND\" before reading stdin\n"
4539:                                "   -c COMMAND           run \"COMMAND\" and exit\n"
4540:                                "   -csv                 set output mode to 'csv'\n"
4541:                                "   -echo                print commands before execution\n"
4542:                                "   -init FILENAME       read/process named file\n"
4543:                                "   -[no]header          turn headers on or off\n"
4544:                                "   -help                show this message\n"
4545:                                "   -html                set output mode to HTML\n"
4546:                                "   -interactive         force interactive I/O\n"
4547:                                "   -json                set output mode to 'json'\n"
4548:                                "   -line                set output mode to 'line'\n"
4549:                                "   -list                set output mode to 'list'\n"
4550:                                "   -markdown            set output mode to 'markdown'\n"
4551:                                "   -newline SEP         set output row separator. Default: '\\n'\n"
4552:                                "   -no-stdin            exit after processing options instead of reading stdin\n"
4553:                                "   -nullvalue TEXT      set text string for NULL values. Default ''\n"
4554:                                "   -quote               set output mode to 'quote'\n"
4555:                                "   -readonly            open the database read-only\n"
4556:                                "   -s COMMAND           run \"COMMAND\" and exit\n"
4557:                                "   -safe                enable safe-mode\n"
4558:                                "   -separator SEP       set output column separator. Default: '|'\n"
4559:                                "   -table               set output mode to 'table'\n"
4560:                                "   -unredacted          allow printing unredacted secrets\n"
4561:                                "   -unsigned            allow loading of unsigned extensions\n"
4562:                                "   -version             show DuckDB version\n";
4563: static void usage(int showDetail) {
4564: 	utf8_printf(stderr,
4565: 	            "Usage: %s [OPTIONS] FILENAME [SQL]\n"
4566: 	            "FILENAME is the name of an DuckDB database. A new database is created\n"
4567: 	            "if the file does not previously exist.\n",
4568: 	            program_name);
4569: 	if (showDetail) {
4570: 		utf8_printf(stderr, "OPTIONS include:\n%s", zOptions);
4571: 	} else {
4572: 		raw_printf(stderr, "Use the -help option for additional information\n");
4573: 	}
4574: 	exit(1);
4575: }
4576: 
4577: /*
4578: ** Internal check:  Verify that the SQLite is uninitialized.  Print a
4579: ** error message if it is initialized.
4580: */
4581: static void verify_uninitialized(void) {
4582: 	if (sqlite3_config(-1) == SQLITE_MISUSE) {
4583: 		utf8_printf(stdout, "WARNING: attempt to configure SQLite after"
4584: 		                    " initialization.\n");
4585: 	}
4586: }
4587: 
4588: /*
4589: ** Initialize the state information in data
4590: */
4591: static void main_init(ShellState *data) {
4592: 	data->normalMode = data->cMode = data->mode = RenderMode::DUCKBOX;
4593: 	data->max_rows = 40;
4594: 	data->colSeparator = SEP_Column;
4595: 	data->rowSeparator = SEP_Row;
4596: 	data->showHeader = true;
4597: 	data->shellFlgs = SHFLG_Lookaside;
4598: 	verify_uninitialized();
4599: 	sqlite3_config(SQLITE_CONFIG_URI, 1);
4600: 	sqlite3_config(SQLITE_CONFIG_LOG, shellLog, data);
4601: 	sqlite3_config(SQLITE_CONFIG_MULTITHREAD);
4602: 	sqlite3_snprintf(sizeof(mainPrompt), mainPrompt, "D ");
4603: 	sqlite3_snprintf(sizeof(continuePrompt), continuePrompt, "· ");
4604: 	sqlite3_snprintf(sizeof(continuePromptSelected), continuePromptSelected, "‣ ");
4605: #ifdef HAVE_LINENOISE
4606: 	linenoiseSetPrompt(continuePrompt, continuePromptSelected);
4607: #endif
4608: }
4609: 
4610: /*
4611: ** Get the argument to an --option.  Throw an error and die if no argument
4612: ** is available.
4613: */
4614: static char *cmdline_option_value(int argc, char **argv, int i) {
4615: 	if (i == argc) {
4616: 		utf8_printf(stderr, "%s: Error: missing argument to %s\n", argv[0], argv[argc - 1]);
4617: 		exit(1);
4618: 	}
4619: 	return argv[i];
4620: }
4621: 
4622: #ifndef SQLITE_SHELL_IS_UTF8
4623: #if (defined(_WIN32) || defined(WIN32)) && defined(_MSC_VER)
4624: #define SQLITE_SHELL_IS_UTF8 (0)
4625: #else
4626: #define SQLITE_SHELL_IS_UTF8 (1)
4627: #endif
4628: #endif
4629: 
4630: #if SQLITE_SHELL_IS_UTF8
4631: int SQLITE_CDECL main(int argc, char **argv) {
4632: #else
4633: int SQLITE_CDECL wmain(int argc, wchar_t **wargv) {
4634: 	char **argv;
4635: #endif
4636: 	char *zErrMsg = nullptr;
4637: 	ShellState data;
4638: 	const char *zInitFile = nullptr;
4639: 	int i;
4640: 	int rc = 0;
4641: 	bool warnInmemoryDb = false;
4642: 	bool readStdin = true;
4643: 	int nCmd = 0;
4644: 	char **azCmd = nullptr;
4645: #if !SQLITE_SHELL_IS_UTF8
4646: 	char **argvToFree = 0;
4647: 	int argcToFree = 0;
4648: #endif
4649: 
4650: 	setBinaryMode(stdin, 0);
4651: 	setvbuf(stderr, 0, _IONBF, 0); /* Make sure stderr is unbuffered */
4652: 	stdin_is_interactive = isatty(0);
4653: 	stdout_is_console = isatty(1);
4654: 	stderr_is_console = isatty(2);
4655: 
4656: #if USE_SYSTEM_SQLITE + 0 != 1
4657: 	if (strncmp(sqlite3_sourceid(), SQLITE_SOURCE_ID, 60) != 0) {
4658: 		utf8_printf(stderr, "SQLite header and source version mismatch\n%s\n%s\n", sqlite3_sourceid(),
4659: 		            SQLITE_SOURCE_ID);
4660: 		exit(1);
4661: 	}
4662: #endif
4663: 	main_init(&data);
4664: 
4665: 	/* On Windows, we must translate command-line arguments into UTF-8.
4666: 	** The SQLite memory allocator subsystem has to be enabled in order to
4667: 	** do this.  But we want to run an sqlite3_shutdown() afterwards so that
4668: 	** subsequent sqlite3_config() calls will work.  So copy all results into
4669: 	** memory that does not come from the SQLite memory allocator.
4670: 	*/
4671: #if !SQLITE_SHELL_IS_UTF8
4672: 	sqlite3_initialize();
4673: 	argvToFree = (char **)malloc(sizeof(argv[0]) * argc * 2);
4674: 	argcToFree = argc;
4675: 	argv = argvToFree + argc;
4676: 	if (argv == 0)
4677: 		shell_out_of_memory();
4678: 	for (i = 0; i < argc; i++) {
4679: 		char *z = sqlite3_win32_unicode_to_utf8(wargv[i]);
4680: 		int n;
4681: 		if (z == 0)
4682: 			shell_out_of_memory();
4683: 		n = (int)strlen(z);
4684: 		argv[i] = (char *)malloc(n + 1);
4685: 		if (argv[i] == 0)
4686: 			shell_out_of_memory();
4687: 		memcpy(argv[i], z, n + 1);
4688: 		argvToFree[i] = argv[i];
4689: 		sqlite3_free(z);
4690: 	}
4691: 	sqlite3_shutdown();
4692: #endif
4693: 
4694: 	assert(argc >= 1 && argv && argv[0]);
4695: 	program_name = argv[0];
4696: 
4697: 	/* Make sure we have a valid signal handler early, before anything
4698: 	** else is done.
4699: 	*/
4700: #ifdef SIGINT
4701: 	signal(SIGINT, interrupt_handler);
4702: #elif (defined(_WIN32) || defined(WIN32)) && !defined(_WIN32_WCE)
4703: 	SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);
4704: #endif
4705: 
4706: #ifdef SQLITE_SHELL_DBNAME_PROC
4707: 	{
4708: 		/* If the SQLITE_SHELL_DBNAME_PROC macro is defined, then it is the name
4709: 		** of a C-function that will provide the name of the database file.  Use
4710: 		** this compile-time option to embed this shell program in larger
4711: 		** applications. */
4712: 		extern void SQLITE_SHELL_DBNAME_PROC(const char **);
4713: 		SQLITE_SHELL_DBNAME_PROC(&data.zDbFilename);
4714: 		warnInmemoryDb = false;
4715: 	}
4716: #endif
4717: 
4718: 	/* Do an initial pass through the command-line argument to locate
4719: 	** the name of the database file, the name of the initialization file,
4720: 	** the size of the alternative malloc heap,
4721: 	** and the first command to execute.
4722: 	*/
4723: 	verify_uninitialized();
4724: 	for (i = 1; i < argc; i++) {
4725: 		char *z;
4726: 		z = argv[i];
4727: 		if (z[0] != '-') {
4728: 			if (data.zDbFilename.empty()) {
4729: 				data.zDbFilename = z;
4730: 			} else {
4731: 				/* Excesss arguments are interpreted as SQL (or dot-commands) and
4732: 				** mean that nothing is read from stdin */
4733: 				readStdin = false;
4734: 				nCmd++;
4735: 				azCmd = (char **)realloc(azCmd, sizeof(azCmd[0]) * nCmd);
4736: 				if (azCmd == 0) {
4737: 					shell_out_of_memory();
4738: 				}
4739: 				azCmd[nCmd - 1] = z;
4740: 			}
4741: 		}
4742: 		if (z[1] == '-')
4743: 			z++;
4744: 		if (strcmp(z, "-separator") == 0 || strcmp(z, "-nullvalue") == 0 || strcmp(z, "-newline") == 0 ||
4745: 		    strcmp(z, "-cmd") == 0 || strcmp(z, "-c") == 0 || strcmp(z, "-s") == 0) {
4746: 			(void)cmdline_option_value(argc, argv, ++i);
4747: 		} else if (strcmp(z, "-init") == 0) {
4748: 			zInitFile = cmdline_option_value(argc, argv, ++i);
4749: 		} else if (strcmp(z, "-batch") == 0) {
4750: 			/* Need to check for batch mode here to so we can avoid printing
4751: 			** informational messages (like from process_sqliterc) before
4752: 			** we do the actual processing of arguments later in a second pass.
4753: 			*/
4754: 			stdin_is_interactive = false;
4755: 		} else if (strcmp(z, "-readonly") == 0) {
4756: 			data.openMode = SHELL_OPEN_READONLY;
4757: 		} else if (strcmp(z, "-unredacted") == 0) {
4758: 			data.openFlags |= DUCKDB_UNREDACTED_SECRETS;
4759: 		} else if (strcmp(z, "-unsigned") == 0) {
4760: 			data.openFlags |= DUCKDB_UNSIGNED_EXTENSIONS;
4761: 		} else if (strcmp(z, "-safe") == 0) {
4762: 			safe_mode = true;
4763: 		}
4764: 	}
4765: 	verify_uninitialized();
4766: 
4767: #ifdef SQLITE_SHELL_INIT_PROC
4768: 	{
4769: 		/* If the SQLITE_SHELL_INIT_PROC macro is defined, then it is the name
4770: 		** of a C-function that will perform initialization actions on SQLite that
4771: 		** occur just before or after sqlite3_initialize(). Use this compile-time
4772: 		** option to embed this shell program in larger applications. */
4773: 		extern void SQLITE_SHELL_INIT_PROC(void);
4774: 		SQLITE_SHELL_INIT_PROC();
4775: 	}
4776: #else
4777: 	/* All the sqlite3_config() calls have now been made. So it is safe
4778: 	** to call sqlite3_initialize() and process any command line -vfs option. */
4779: 	sqlite3_initialize();
4780: #endif
4781: 
4782: 	if (data.zDbFilename.empty()) {
4783: #ifndef SQLITE_OMIT_MEMORYDB
4784: 		data.zDbFilename = ":memory:";
4785: 		warnInmemoryDb = argc == 1;
4786: #else
4787: 		utf8_printf(stderr, "%s: Error: no database filename specified\n", program_name);
4788: 		return 1;
4789: #endif
4790: 	}
4791: 	data.out = stdout;
4792: 
4793: 	/* Go ahead and open the database file if it already exists.  If the
4794: 	** file does not exist, delay opening it.  This prevents empty database
4795: 	** files from being created if a user mistypes the database name argument
4796: 	** to the sqlite command-line tool.
4797: 	*/
4798: 	if (access(data.zDbFilename.c_str(), 0) == 0) {
4799: 		data.OpenDB(0);
4800: 	}
4801: 
4802: 	/* Process the initialization file if there is one.  If no -init option
4803: 	** is given on the command line, look for a file named ~/.sqliterc and
4804: 	** try to process it.
4805: 	*/
4806: 	data.ProcessDuckDBRC(zInitFile);
4807: 
4808: 	/* Make a second pass through the command-line argument and set
4809: 	** options.  This second pass is delayed until after the initialization
4810: 	** file is processed so that the command-line arguments will override
4811: 	** settings in the initialization file.
4812: 	*/
4813: 	for (i = 1; i < argc; i++) {
4814: 		char *z = argv[i];
4815: 		if (z[0] != '-') {
4816: 			continue;
4817: 		}
4818: 		if (z[1] == '-') {
4819: 			z++;
4820: 		}
4821: 		if (strcmp(z, "-init") == 0) {
4822: 			i++;
4823: 		} else if (strcmp(z, "-html") == 0) {
4824: 			data.mode = RenderMode::HTML;
4825: 		} else if (strcmp(z, "-list") == 0) {
4826: 			data.mode = RenderMode::LIST;
4827: 		} else if (strcmp(z, "-quote") == 0) {
4828: 			data.mode = RenderMode::QUOTE;
4829: 		} else if (strcmp(z, "-line") == 0) {
4830: 			data.mode = RenderMode::LINE;
4831: 		} else if (strcmp(z, "-column") == 0) {
4832: 			data.mode = RenderMode::COLUMN;
4833: 		} else if (strcmp(z, "-json") == 0) {
4834: 			data.mode = RenderMode::JSON;
4835: 		} else if (strcmp(z, "-jsonlines") == 0) {
4836: 			data.mode = RenderMode::JSONLINES;
4837: 		} else if (strcmp(z, "-markdown") == 0) {
4838: 			data.mode = RenderMode::MARKDOWN;
4839: 		} else if (strcmp(z, "-table") == 0) {
4840: 			data.mode = RenderMode::TABLE;
4841: 		} else if (strcmp(z, "-box") == 0) {
4842: 			data.mode = RenderMode::BOX;
4843: 		} else if (strcmp(z, "-latex") == 0) {
4844: 			data.mode = RenderMode::LATEX;
4845: 		} else if (strcmp(z, "-csv") == 0) {
4846: 			data.mode = RenderMode::CSV;
4847: 			data.colSeparator = ",";
4848: 		} else if (strcmp(z, "-readonly") == 0) {
4849: 			data.openMode = SHELL_OPEN_READONLY;
4850: 		} else if (strcmp(z, "-ascii") == 0) {
4851: 			data.mode = RenderMode::ASCII;
4852: 			data.colSeparator = SEP_Unit;
4853: 			data.rowSeparator = SEP_Record;
4854: 		} else if (strcmp(z, "-separator") == 0) {
4855: 			data.colSeparator = cmdline_option_value(argc, argv, ++i);
4856: 		} else if (strcmp(z, "-newline") == 0) {
4857: 			data.rowSeparator = cmdline_option_value(argc, argv, ++i);
4858: 		} else if (strcmp(z, "-nullvalue") == 0) {
4859: 			data.nullValue = cmdline_option_value(argc, argv, ++i);
4860: 		} else if (strcmp(z, "-header") == 0) {
4861: 			data.showHeader = 1;
4862: 		} else if (strcmp(z, "-noheader") == 0) {
4863: 			data.showHeader = 0;
4864: 		} else if (strcmp(z, "-echo") == 0) {
4865: 			data.ShellSetFlag(SHFLG_Echo);
4866: 		} else if (strcmp(z, "-unsigned") == 0) {
4867: 			data.openFlags |= DUCKDB_UNSIGNED_EXTENSIONS;
4868: 		} else if (strcmp(z, "-unredacted") == 0) {
4869: 			data.openFlags |= DUCKDB_UNREDACTED_SECRETS;
4870: 		} else if (strcmp(z, "-bail") == 0) {
4871: 			bail_on_error = true;
4872: 		} else if (strcmp(z, "-version") == 0) {
4873: 			printf("%s %s\n", sqlite3_libversion(), sqlite3_sourceid());
4874: 			free(azCmd);
4875: 			return 0;
4876: 		} else if (strcmp(z, "-interactive") == 0) {
4877: 			stdin_is_interactive = true;
4878: 		} else if (strcmp(z, "-batch") == 0) {
4879: 			stdin_is_interactive = false;
4880: 		} else if (strcmp(z, "-help") == 0) {
4881: 			usage(1);
4882: 		} else if (strcmp(z, "-no-stdin") == 0) {
4883: 			readStdin = false;
4884: 		} else if (strcmp(z, "-cmd") == 0 || strcmp(z, "-c") == 0 || strcmp(z, "-s") == 0) {
4885: 			if (strcmp(z, "-c") == 0 || strcmp(z, "-s") == 0) {
4886: 				readStdin = false;
4887: 			}
4888: 			/* Run commands that follow -cmd first and separately from commands
4889: 			** that simply appear on the command-line.  This seems goofy.  It would
4890: 			** be better if all commands ran in the order that they appear.  But
4891: 			** we retain the goofy behavior for historical compatibility. */
4892: 			if (i == argc - 1)
4893: 				break;
4894: 			z = cmdline_option_value(argc, argv, ++i);
4895: 			if (z[0] == '.') {
4896: 				rc = data.DoMetaCommand(z);
4897: 				if (rc && bail_on_error) {
4898: 					free(azCmd);
4899: 					return rc == 2 ? 0 : rc;
4900: 				}
4901: 			} else {
4902: 				data.OpenDB(0);
4903: 				rc = data.ExecuteSQL(z, &zErrMsg);
4904: 				if (zErrMsg != 0) {
4905: 					data.PrintDatabaseError(zErrMsg);
4906: 					sqlite3_free(zErrMsg);
4907: 					if (bail_on_error) {
4908: 						free(azCmd);
4909: 						return rc != 0 ? rc : 1;
4910: 					}
4911: 				} else if (rc != 0) {
4912: 					utf8_printf(stderr, "Error: unable to process SQL \"%s\"\n", z);
4913: 					if (bail_on_error) {
4914: 						free(azCmd);
4915: 						return rc;
4916: 					}
4917: 				}
4918: 			}
4919: 		} else if (strcmp(z, "-safe") == 0) {
4920: 			// safe mode has been set before
4921: 		} else {
4922: 			utf8_printf(stderr, "%s: Error: unknown option: %s\n", program_name, z);
4923: 			raw_printf(stderr, "Use -help for a list of options.\n");
4924: 			free(azCmd);
4925: 			return 1;
4926: 		}
4927: 		data.cMode = data.mode;
4928: 	}
4929: 
4930: 	if (!readStdin) {
4931: 		/* Run all arguments that do not begin with '-' as if they were separate
4932: 		** command-line inputs, except for the argToSkip argument which contains
4933: 		** the database filename.
4934: 		*/
4935: 		for (i = 0; i < nCmd; i++) {
4936: 			if (azCmd[i][0] == '.') {
4937: 				rc = data.DoMetaCommand(azCmd[i]);
4938: 				if (rc) {
4939: 					free(azCmd);
4940: 					return rc == 2 ? 0 : rc;
4941: 				}
4942: 			} else {
4943: 				data.OpenDB(0);
4944: 				rc = data.ExecuteSQL(azCmd[i], &zErrMsg);
4945: 				if (zErrMsg != 0) {
4946: 					data.PrintDatabaseError(zErrMsg);
4947: 					sqlite3_free(zErrMsg);
4948: 					free(azCmd);
4949: 					return rc != 0 ? rc : 1;
4950: 				} else if (rc != 0) {
4951: 					utf8_printf(stderr, "Error: unable to process SQL: %s\n", azCmd[i]);
4952: 					free(azCmd);
4953: 					return rc;
4954: 				}
4955: 			}
4956: 		}
4957: 		free(azCmd);
4958: 	} else {
4959: 		/* Run commands received from standard input
4960: 		 */
4961: 		if (stdin_is_interactive) {
4962: 			char *zHome;
4963: 			char *zHistory;
4964: 			int nHistory;
4965: 			printf("%s %.19s\n" /*extra-version-info*/
4966: 			       "Enter \".help\" for usage hints.\n",
4967: 			       sqlite3_libversion(), sqlite3_sourceid());
4968: 			if (warnInmemoryDb) {
4969: 				printf("Connected to a ");
4970: 				ShellHighlight highlighter(data);
4971: 				highlighter.PrintText("transient in-memory database", PrintOutput::STDOUT, PrintColor::STANDARD,
4972: 				                      PrintIntensity::BOLD);
4973: 				printf(".\nUse \".open FILENAME\" to reopen on a "
4974: 				       "persistent database.\n");
4975: 			}
4976: 			zHistory = getenv("DUCKDB_HISTORY");
4977: 			if (zHistory) {
4978: 				zHistory = strdup(zHistory);
4979: 			} else if ((zHome = find_home_dir(0)) != 0) {
4980: 				nHistory = ShellState::StringLength(zHome) + 20;
4981: 				if ((zHistory = (char *)malloc(nHistory)) != 0) {
4982: 					sqlite3_snprintf(nHistory, zHistory, "%s/.duckdb_history", zHome);
4983: 				}
4984: 			}
4985: 			if (zHistory) {
4986: 				shell_read_history(zHistory);
4987: 			}
4988: #if HAVE_READLINE || HAVE_EDITLINE
4989: 			rl_attempted_completion_function = readline_completion;
4990: #elif HAVE_LINENOISE
4991: 			linenoiseSetCompletionCallback(linenoise_completion);
4992: #endif
4993: 			data.in = 0;
4994: 			rc = data.ProcessInput();
4995: 			if (zHistory) {
4996: 				shell_stifle_history(2000);
4997: 				shell_write_history(zHistory);
4998: 				free(zHistory);
4999: 			}
5000: 		} else {
5001: 			data.in = stdin;
5002: 			rc = data.ProcessInput();
5003: 		}
5004: 	}
5005: 	data.SetTableName(0);
5006: 	if (data.db) {
5007: 		close_db(data.db);
5008: 	}
5009: 	find_home_dir(1);
5010: 	data.ResetOutput();
5011: 	data.doXdgOpen = 0;
5012: 	data.ClearTempFile();
5013: #if !SQLITE_SHELL_IS_UTF8
5014: 	for (i = 0; i < argcToFree; i++)
5015: 		free(argvToFree[i]);
5016: 	free(argvToFree);
5017: #endif
5018: 	return rc;
5019: }
[end of tools/shell/shell.cpp]
[start of tools/shell/shell_highlight.cpp]
1: #include "shell_highlight.hpp"
2: #include "shell_state.hpp"
3: #include "duckdb/parser/parser.hpp"
4: 
5: #if defined(_WIN32) || defined(WIN32)
6: #include <windows.h>
7: #endif
8: 
9: namespace duckdb_shell {
10: 
11: struct HighlightElement {
12: 	const char *name;
13: 	PrintColor color;
14: 	PrintIntensity intensity;
15: };
16: 
17: static HighlightElement highlight_elements[] = {{"error", PrintColor::RED, PrintIntensity::BOLD},
18:                                                 {"keyword", PrintColor::GREEN, PrintIntensity::STANDARD},
19:                                                 {"numeric_constant", PrintColor::YELLOW, PrintIntensity::STANDARD},
20:                                                 {"string_constant", PrintColor::YELLOW, PrintIntensity::STANDARD},
21:                                                 {"line_indicator", PrintColor::STANDARD, PrintIntensity::BOLD},
22:                                                 {"column_name", PrintColor::STANDARD, PrintIntensity::BOLD},
23:                                                 {"column_type", PrintColor::STANDARD, PrintIntensity::STANDARD},
24:                                                 {"numeric_value", PrintColor::STANDARD, PrintIntensity::STANDARD},
25:                                                 {"string_value", PrintColor::STANDARD, PrintIntensity::STANDARD},
26:                                                 {"temporal_value", PrintColor::STANDARD, PrintIntensity::STANDARD},
27:                                                 {"null_value", PrintColor::GRAY, PrintIntensity::STANDARD},
28:                                                 {"footer", PrintColor::STANDARD, PrintIntensity::STANDARD},
29:                                                 {"layout", PrintColor::GRAY, PrintIntensity::STANDARD},
30:                                                 {"none", PrintColor::STANDARD, PrintIntensity::STANDARD},
31:                                                 {nullptr, PrintColor::STANDARD, PrintIntensity::STANDARD}};
32: 
33: struct HighlightColors {
34: 	const char *name;
35: 	PrintColor color;
36: };
37: 
38: static const HighlightColors highlight_colors[] = {{"standard", PrintColor::STANDARD}, {"red", PrintColor::RED},
39:                                                    {"yellow", PrintColor::YELLOW},     {"green", PrintColor::GREEN},
40:                                                    {"gray", PrintColor::GRAY},         {"blue", PrintColor::BLUE},
41:                                                    {"magenta", PrintColor::MAGENTA},   {"cyan", PrintColor::CYAN},
42:                                                    {"white", PrintColor::WHITE},       {nullptr, PrintColor::STANDARD}};
43: 
44: ShellHighlight::ShellHighlight(ShellState &state) : state(state) {
45: }
46: 
47: /*
48: ** Output text to the console in a font that attracts extra attention.
49: */
50: #ifdef _WIN32
51: void ShellHighlight::PrintText(const string &text, PrintOutput output, PrintColor color, PrintIntensity intensity) {
52: 	HANDLE out = GetStdHandle(output == PrintOutput::STDOUT ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE);
53: 	CONSOLE_SCREEN_BUFFER_INFO defaultScreenInfo;
54: 	GetConsoleScreenBufferInfo(out, &defaultScreenInfo);
55: 	WORD wAttributes = 0;
56: 
57: 	switch (intensity) {
58: 	case PrintIntensity::BOLD:
59: 	case PrintIntensity::BOLD_UNDERLINE:
60: 		wAttributes |= FOREGROUND_INTENSITY;
61: 		break;
62: 	default:
63: 		break;
64: 	}
65: 	switch (color) {
66: 	case PrintColor::RED:
67: 		wAttributes |= FOREGROUND_RED;
68: 		break;
69: 	case PrintColor::GREEN:
70: 		wAttributes |= FOREGROUND_GREEN;
71: 		break;
72: 	case PrintColor::BLUE:
73: 		wAttributes |= FOREGROUND_BLUE;
74: 		break;
75: 	case PrintColor::YELLOW:
76: 		wAttributes |= FOREGROUND_RED | FOREGROUND_GREEN;
77: 		break;
78: 	case PrintColor::GRAY:
79: 		wAttributes |= FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
80: 		break;
81: 	case PrintColor::MAGENTA:
82: 		wAttributes |= FOREGROUND_BLUE | FOREGROUND_RED;
83: 		break;
84: 	case PrintColor::CYAN:
85: 		wAttributes |= FOREGROUND_BLUE | FOREGROUND_GREEN;
86: 		break;
87: 	case PrintColor::WHITE:
88: 		wAttributes |= FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED;
89: 		break;
90: 	default:
91: 		break;
92: 	}
93: 	if (wAttributes != 0) {
94: 		SetConsoleTextAttribute(out, wAttributes);
95: 	}
96: 
97: 	state.Print(output, text);
98: 
99: 	SetConsoleTextAttribute(out, defaultScreenInfo.wAttributes);
100: }
101: #else
102: void ShellHighlight::PrintText(const string &text, PrintOutput output, PrintColor color, PrintIntensity intensity) {
103: 	const char *bold_prefix = "";
104: 	const char *color_prefix = "";
105: 	const char *suffix = "";
106: 	switch (intensity) {
107: 	case PrintIntensity::BOLD:
108: 		bold_prefix = "\033[1m";
109: 		break;
110: 	case PrintIntensity::UNDERLINE:
111: 		bold_prefix = "\033[4m";
112: 		break;
113: 	case PrintIntensity::BOLD_UNDERLINE:
114: 		bold_prefix = "\033[1m\033[4m";
115: 		break;
116: 	default:
117: 		break;
118: 	}
119: 	switch (color) {
120: 	case PrintColor::RED:
121: 		color_prefix = "\033[31m";
122: 		break;
123: 	case PrintColor::GREEN:
124: 		color_prefix = "\033[32m";
125: 		break;
126: 	case PrintColor::YELLOW:
127: 		color_prefix = "\033[33m";
128: 		break;
129: 	case PrintColor::GRAY:
130: 		color_prefix = "\033[90m";
131: 		break;
132: 	case PrintColor::BLUE:
133: 		color_prefix = "\033[34m";
134: 		break;
135: 	case PrintColor::MAGENTA:
136: 		color_prefix = "\033[35m";
137: 		break;
138: 	case PrintColor::CYAN:
139: 		color_prefix = "\033[36m";
140: 		break;
141: 	case PrintColor::WHITE:
142: 		color_prefix = "\033[37m";
143: 		break;
144: 	default:
145: 		break;
146: 	}
147: 	if (*color_prefix || *bold_prefix) {
148: 		suffix = "\033[0m";
149: 	}
150: 	fprintf(output == PrintOutput::STDOUT ? state.out : stderr, "%s%s%s%s", bold_prefix, color_prefix, text.c_str(),
151: 	        suffix);
152: }
153: #endif
154: 
155: void ShellHighlight::PrintText(const string &text, PrintOutput output, HighlightElementType type) {
156: 	auto index = static_cast<uint32_t>(type);
157: 	auto max_index = static_cast<uint32_t>(HighlightElementType::NONE);
158: 	if (index > max_index) {
159: 		index = max_index;
160: 	}
161: 	auto highlight_info = highlight_elements[index];
162: 	PrintText(text, output, highlight_info.color, highlight_info.intensity);
163: }
164: 
165: void ShellHighlight::PrintError(string error_msg) {
166: 	if (error_msg.empty()) {
167: 		return;
168: 	}
169: 	vector<duckdb::SimplifiedToken> tokens;
170: 	string error_type;
171: 	auto error_location = duckdb::StringUtil::Find(error_msg, "Error: ");
172: 	if (error_location.IsValid()) {
173: 		error_type = error_msg.substr(0, error_location.GetIndex() + 6);
174: 		error_msg = error_msg.substr(error_location.GetIndex() + 7);
175: 	}
176: 	try {
177: 		tokens = duckdb::Parser::TokenizeError(error_msg);
178: 	} catch (...) {
179: 		// fallback
180: 		state.Print(PrintOutput::STDERR, error_msg.c_str());
181: 		state.Print(PrintOutput::STDERR, "\n");
182: 		return;
183: 	}
184: 	if (!tokens.empty() && tokens[0].start > 0) {
185: 		duckdb::SimplifiedToken new_token;
186: 		new_token.type = duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER;
187: 		new_token.start = 0;
188: 		tokens.insert(tokens.begin(), new_token);
189: 	}
190: 	if (tokens.empty() && !error_msg.empty()) {
191: 		duckdb::SimplifiedToken new_token;
192: 		new_token.type = duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER;
193: 		new_token.start = 0;
194: 		tokens.push_back(new_token);
195: 	}
196: 	if (!error_type.empty()) {
197: 		PrintText(error_type + "\n", PrintOutput::STDERR, HighlightElementType::ERROR_TOKEN);
198: 	}
199: 	for (idx_t i = 0; i < tokens.size(); i++) {
200: 		HighlightElementType element_type = HighlightElementType::NONE;
201: 		switch (tokens[i].type) {
202: 		case duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER:
203: 			break;
204: 		case duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_ERROR:
205: 			element_type = HighlightElementType::ERROR_TOKEN;
206: 			break;
207: 		case duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_NUMERIC_CONSTANT:
208: 			element_type = HighlightElementType::NUMERIC_CONSTANT;
209: 			break;
210: 		case duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_STRING_CONSTANT:
211: 			element_type = HighlightElementType::STRING_CONSTANT;
212: 			break;
213: 		case duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_OPERATOR:
214: 			break;
215: 		case duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_KEYWORD:
216: 			element_type = HighlightElementType::KEYWORD;
217: 			break;
218: 		case duckdb::SimplifiedTokenType::SIMPLIFIED_TOKEN_COMMENT:
219: 			element_type = HighlightElementType::LINE_INDICATOR;
220: 			break;
221: 		}
222: 		idx_t start = tokens[i].start;
223: 		idx_t end = i + 1 == tokens.size() ? error_msg.size() : tokens[i + 1].start;
224: 		if (end - start > 0) {
225: 			string error_print = error_msg.substr(tokens[i].start, end - start);
226: 			PrintText(error_print, PrintOutput::STDERR, element_type);
227: 		}
228: 	}
229: 	PrintText("\n", PrintOutput::STDERR, PrintColor::STANDARD, PrintIntensity::STANDARD);
230: }
231: 
232: bool ShellHighlight::SetColor(const char *element_type, const char *color, const char *intensity) {
233: 	idx_t i;
234: 	for (i = 0; highlight_elements[i].name; i++) {
235: 		if (duckdb::StringUtil::CIEquals(element_type, highlight_elements[i].name)) {
236: 			break;
237: 		}
238: 	}
239: 	if (!highlight_elements[i].name) {
240: 		// element not found
241: 		string supported_options;
242: 		for (i = 0; highlight_elements[i].name; i++) {
243: 			if (!supported_options.empty()) {
244: 				supported_options += ", ";
245: 			}
246: 			supported_options += highlight_elements[i].name;
247: 		}
248: 		state.Print(PrintOutput::STDERR, duckdb::StringUtil::Format("Unknown element '%s', supported options: %s\n",
249: 		                                                            element_type, supported_options.c_str()));
250: 		return false;
251: 	}
252: 
253: 	// found the element - parse the color
254: 	idx_t c;
255: 	for (c = 0; highlight_colors[c].name; c++) {
256: 		if (duckdb::StringUtil::CIEquals(color, highlight_colors[c].name)) {
257: 			break;
258: 		}
259: 	}
260: 	if (!highlight_colors[c].name) {
261: 		// color not found
262: 		string supported_options;
263: 		for (c = 0; highlight_colors[c].name; c++) {
264: 			if (!supported_options.empty()) {
265: 				supported_options += ", ";
266: 			}
267: 			supported_options += highlight_colors[c].name;
268: 		}
269: 		state.Print(PrintOutput::STDERR, duckdb::StringUtil::Format("Unknown color '%s', supported options: %s\n",
270: 		                                                            color, supported_options.c_str()));
271: 		return false;
272: 	}
273: 	highlight_elements[i].color = highlight_colors[c].color;
274: 	highlight_elements[i].intensity = PrintIntensity::STANDARD;
275: 	if (intensity) {
276: 		if (duckdb::StringUtil::CIEquals(intensity, "standard")) {
277: 			highlight_elements[i].intensity = PrintIntensity::STANDARD;
278: 		} else if (duckdb::StringUtil::CIEquals(intensity, "bold")) {
279: 			highlight_elements[i].intensity = PrintIntensity::BOLD;
280: 		} else if (duckdb::StringUtil::CIEquals(intensity, "underline")) {
281: 			highlight_elements[i].intensity = PrintIntensity::UNDERLINE;
282: 		} else if (duckdb::StringUtil::CIEquals(intensity, "bold_underline")) {
283: 			highlight_elements[i].intensity = PrintIntensity::BOLD_UNDERLINE;
284: 		} else {
285: 			state.Print(PrintOutput::STDERR,
286: 			            duckdb::StringUtil::Format(
287: 			                "Unknown intensity '%s', supported options: standard, bold, underline\n", intensity));
288: 			return false;
289: 		}
290: 	}
291: 	return true;
292: }
293: 
294: } // namespace duckdb_shell
[end of tools/shell/shell_highlight.cpp]
[start of tools/shell/shell_renderer.cpp]
1: #include "shell_renderer.hpp"
2: 
3: #include "shell_state.hpp"
4: #include "duckdb_shell_wrapper.h"
5: #include "sqlite3.h"
6: #include <stdexcept>
7: #include <cstring>
8: 
9: namespace duckdb_shell {
10: 
11: bool ShellRenderer::IsColumnar(RenderMode mode) {
12: 	switch (mode) {
13: 	case RenderMode::COLUMN:
14: 	case RenderMode::TABLE:
15: 	case RenderMode::BOX:
16: 	case RenderMode::MARKDOWN:
17: 	case RenderMode::LATEX:
18: 		return true;
19: 	default:
20: 		return false;
21: 	}
22: }
23: 
24: ShellRenderer::ShellRenderer(ShellState &state)
25:     : state(state), show_header(state.showHeader), col_sep(state.colSeparator), row_sep(state.rowSeparator) {
26: }
27: 
28: //===--------------------------------------------------------------------===//
29: // Column Renderers
30: //===--------------------------------------------------------------------===//
31: ColumnRenderer::ColumnRenderer(ShellState &state) : ShellRenderer(state) {
32: }
33: 
34: void ColumnRenderer::RenderFooter(ColumnarResult &result) {
35: }
36: 
37: void ColumnRenderer::RenderAlignedValue(ColumnarResult &result, idx_t i) {
38: 	idx_t w = result.column_width[i];
39: 	idx_t n = state.RenderLength(result.data[i]);
40: 	state.PrintPadded("", (w - n) / 2);
41: 	state.Print(result.data[i]);
42: 	state.PrintPadded("", (w - n + 1) / 2);
43: }
44: 
45: class ModeColumnRenderer : public ColumnRenderer {
46: public:
47: 	explicit ModeColumnRenderer(ShellState &state) : ColumnRenderer(state) {
48: 	}
49: 
50: 	void RenderHeader(ColumnarResult &result) override {
51: 		if (!show_header) {
52: 			return;
53: 		}
54: 		for (idx_t i = 0; i < result.column_count; i++) {
55: 			state.UTF8WidthPrint(state.out, result.column_width[i], result.data[i], result.right_align[i]);
56: 			state.Print(i == result.column_count - 1 ? "\n" : "  ");
57: 		}
58: 		for (idx_t i = 0; i < result.column_count; i++) {
59: 			state.PrintDashes(result.column_width[i]);
60: 			state.Print(i == result.column_count - 1 ? "\n" : "  ");
61: 		}
62: 	}
63: 
64: 	const char *GetColumnSeparator() override {
65: 		return "  ";
66: 	}
67: 	const char *GetRowSeparator() override {
68: 		return "\n";
69: 	}
70: };
71: 
72: class ModeTableRenderer : public ColumnRenderer {
73: public:
74: 	explicit ModeTableRenderer(ShellState &state) : ColumnRenderer(state) {
75: 	}
76: 
77: 	void RenderHeader(ColumnarResult &result) override {
78: 		state.PrintRowSeparator(result.column_count, "+", result.column_width);
79: 		state.Print("| ");
80: 		for (idx_t i = 0; i < result.column_count; i++) {
81: 			RenderAlignedValue(result, i);
82: 			state.Print(i == result.column_count - 1 ? " |\n" : " | ");
83: 		}
84: 		state.PrintRowSeparator(result.column_count, "+", result.column_width);
85: 	}
86: 
87: 	void RenderFooter(ColumnarResult &result) override {
88: 		state.PrintRowSeparator(result.column_count, "+", result.column_width);
89: 	}
90: 
91: 	const char *GetColumnSeparator() override {
92: 		return " | ";
93: 	}
94: 	const char *GetRowSeparator() override {
95: 		return " |\n";
96: 	}
97: 	const char *GetRowStart() override {
98: 		return "| ";
99: 	}
100: };
101: 
102: class ModeMarkdownRenderer : public ColumnRenderer {
103: public:
104: 	explicit ModeMarkdownRenderer(ShellState &state) : ColumnRenderer(state) {
105: 	}
106: 
107: 	void RenderHeader(ColumnarResult &result) override {
108: 		state.Print(GetRowStart());
109: 		for (idx_t i = 0; i < result.column_count; i++) {
110: 			if (i > 0) {
111: 				state.Print(GetColumnSeparator());
112: 			}
113: 			RenderAlignedValue(result, i);
114: 		}
115: 		state.Print(GetRowSeparator());
116: 		state.PrintMarkdownSeparator(result.column_count, "|", result.types, result.column_width);
117: 	}
118: 
119: 	const char *GetColumnSeparator() override {
120: 		return " | ";
121: 	}
122: 	const char *GetRowSeparator() override {
123: 		return " |\n";
124: 	}
125: 	const char *GetRowStart() override {
126: 		return "| ";
127: 	}
128: };
129: 
130: /*
131: ** UTF8 box-drawing characters.  Imagine box lines like this:
132: **
133: **           1
134: **           |
135: **       4 --+-- 2
136: **           |
137: **           3
138: **
139: ** Each box characters has between 2 and 4 of the lines leading from
140: ** the center.  The characters are here identified by the numbers of
141: ** their corresponding lines.
142: */
143: #define BOX_24   "\342\224\200" /* U+2500 --- */
144: #define BOX_13   "\342\224\202" /* U+2502  |  */
145: #define BOX_23   "\342\224\214" /* U+250c  ,- */
146: #define BOX_34   "\342\224\220" /* U+2510 -,  */
147: #define BOX_12   "\342\224\224" /* U+2514  '- */
148: #define BOX_14   "\342\224\230" /* U+2518 -'  */
149: #define BOX_123  "\342\224\234" /* U+251c  |- */
150: #define BOX_134  "\342\224\244" /* U+2524 -|  */
151: #define BOX_234  "\342\224\254" /* U+252c -,- */
152: #define BOX_124  "\342\224\264" /* U+2534 -'- */
153: #define BOX_1234 "\342\224\274" /* U+253c -|- */
154: 
155: class ModeBoxRenderer : public ColumnRenderer {
156: public:
157: 	explicit ModeBoxRenderer(ShellState &state) : ColumnRenderer(state) {
158: 	}
159: 
160: 	void RenderHeader(ColumnarResult &result) override {
161: 		print_box_row_separator(result.column_count, BOX_23, BOX_234, BOX_34, result.column_width);
162: 		state.Print(BOX_13 " ");
163: 		for (idx_t i = 0; i < result.column_count; i++) {
164: 			RenderAlignedValue(result, i);
165: 			state.Print(i == result.column_count - 1 ? " " BOX_13 "\n" : " " BOX_13 " ");
166: 		}
167: 		print_box_row_separator(result.column_count, BOX_123, BOX_1234, BOX_134, result.column_width);
168: 	}
169: 
170: 	void RenderFooter(ColumnarResult &result) override {
171: 		print_box_row_separator(result.column_count, BOX_12, BOX_124, BOX_14, result.column_width);
172: 	}
173: 
174: 	const char *GetColumnSeparator() override {
175: 		return " " BOX_13 " ";
176: 	}
177: 	const char *GetRowSeparator() override {
178: 		return " " BOX_13 "\n";
179: 	}
180: 	const char *GetRowStart() override {
181: 		return BOX_13 " ";
182: 	}
183: 
184: private:
185: 	/* Draw horizontal line N characters long using unicode box
186: 	** characters
187: 	*/
188: 	void print_box_line(idx_t N) {
189: 		string box_line;
190: 		for (idx_t i = 0; i < N; i++) {
191: 			box_line += BOX_24;
192: 		}
193: 		state.Print(box_line);
194: 	}
195: 
196: 	/*
197: 	** Draw a horizontal separator for a RenderMode::Box table.
198: 	*/
199: 	void print_box_row_separator(int nArg, const char *zSep1, const char *zSep2, const char *zSep3,
200: 	                             const vector<idx_t> &actualWidth) {
201: 		int i;
202: 		if (nArg > 0) {
203: 			state.Print(zSep1);
204: 			print_box_line(actualWidth[0] + 2);
205: 			for (i = 1; i < nArg; i++) {
206: 				state.Print(zSep2);
207: 				print_box_line(actualWidth[i] + 2);
208: 			}
209: 			state.Print(zSep3);
210: 		}
211: 		state.Print("\n");
212: 	}
213: };
214: 
215: class ModeLatexRenderer : public ColumnRenderer {
216: public:
217: 	explicit ModeLatexRenderer(ShellState &state) : ColumnRenderer(state) {
218: 	}
219: 
220: 	void RenderHeader(ColumnarResult &result) override {
221: 		state.Print("\\begin{tabular}{|");
222: 		for (idx_t i = 0; i < result.column_count; i++) {
223: 			if (state.ColumnTypeIsInteger(result.type_names[i])) {
224: 				state.Print("r");
225: 			} else {
226: 				state.Print("l");
227: 			}
228: 		}
229: 		state.Print("|}\n");
230: 		state.Print("\\hline\n");
231: 		for (idx_t i = 0; i < result.column_count; i++) {
232: 			RenderAlignedValue(result, i);
233: 			state.Print(i == result.column_count - 1 ? GetRowSeparator() : GetColumnSeparator());
234: 		}
235: 		state.Print("\\hline\n");
236: 	}
237: 
238: 	void RenderFooter(ColumnarResult &) override {
239: 		state.Print("\\hline\n");
240: 		state.Print("\\end{tabular}\n");
241: 	}
242: 
243: 	const char *GetColumnSeparator() override {
244: 		return " & ";
245: 	}
246: 	const char *GetRowSeparator() override {
247: 		return " \\\\\n";
248: 	}
249: };
250: 
251: unique_ptr<ColumnRenderer> ShellState::GetColumnRenderer() {
252: 	switch (cMode) {
253: 	case RenderMode::COLUMN:
254: 		return unique_ptr<ColumnRenderer>(new ModeColumnRenderer(*this));
255: 	case RenderMode::TABLE:
256: 		return unique_ptr<ColumnRenderer>(new ModeTableRenderer(*this));
257: 	case RenderMode::MARKDOWN:
258: 		return unique_ptr<ColumnRenderer>(new ModeMarkdownRenderer(*this));
259: 	case RenderMode::BOX:
260: 		return unique_ptr<ColumnRenderer>(new ModeBoxRenderer(*this));
261: 	case RenderMode::LATEX:
262: 		return unique_ptr<ColumnRenderer>(new ModeLatexRenderer(*this));
263: 	default:
264: 		throw std::runtime_error("Unsupported mode for GetColumnRenderer");
265: 	}
266: }
267: 
268: //===--------------------------------------------------------------------===//
269: // Row Renderers
270: //===--------------------------------------------------------------------===//
271: RowRenderer::RowRenderer(ShellState &state) : ShellRenderer(state) {
272: }
273: 
274: void RowRenderer::Render(RowResult &result) {
275: 	if (first_row) {
276: 		RenderHeader(result);
277: 		first_row = false;
278: 	}
279: 	RenderRow(result);
280: }
281: 
282: void RowRenderer::RenderHeader(RowResult &result) {
283: }
284: 
285: void RowRenderer::RenderFooter(RowResult &result) {
286: }
287: 
288: class ModeLineRenderer : public RowRenderer {
289: public:
290: 	explicit ModeLineRenderer(ShellState &state) : RowRenderer(state) {
291: 	}
292: 
293: 	void Render(RowResult &result) override {
294: 		if (first_row) {
295: 			auto &col_names = result.column_names;
296: 			// determine the render width by going over the column names
297: 			header_width = 5;
298: 			for (idx_t i = 0; i < col_names.size(); i++) {
299: 				auto len = ShellState::StringLength(col_names[i] ? col_names[i] : "");
300: 				if (len > header_width) {
301: 					header_width = len;
302: 				}
303: 			}
304: 			first_row = false;
305: 		} else {
306: 			state.Print(state.rowSeparator);
307: 		}
308: 		// render the row
309: 		RenderRow(result);
310: 	}
311: 
312: 	void RenderRow(RowResult &result) override {
313: 		auto &data = result.data;
314: 		auto &col_names = result.column_names;
315: 		for (idx_t i = 0; i < data.size(); i++) {
316: 			state.PrintPadded(col_names[i], header_width);
317: 			state.Print(" = ");
318: 			state.PrintValue(data[i]);
319: 			state.Print(state.rowSeparator);
320: 		}
321: 	}
322: 
323: 	idx_t header_width = 0;
324: };
325: 
326: class ModeExplainRenderer : public RowRenderer {
327: public:
328: 	explicit ModeExplainRenderer(ShellState &state) : RowRenderer(state) {
329: 	}
330: 
331: 	void RenderRow(RowResult &result) override {
332: 		auto &data = result.data;
333: 		if (data.size() != 2) {
334: 			throw std::runtime_error("Invalid usage of explain renderer - must have two data points per row");
335: 		}
336: 		if (strcmp(data[0], "logical_plan") == 0 || strcmp(data[0], "logical_opt") == 0 ||
337: 		    strcmp(data[0], "physical_plan") == 0) {
338: 			state.Print("\n┌─────────────────────────────┐\n");
339: 			state.Print("│┌───────────────────────────┐│\n");
340: 			if (strcmp(data[0], "logical_plan") == 0) {
341: 				state.Print("││ Unoptimized Logical Plan  ││\n");
342: 			} else if (strcmp(data[0], "logical_opt") == 0) {
343: 				state.Print("││  Optimized Logical Plan   ││\n");
344: 			} else if (strcmp(data[0], "physical_plan") == 0) {
345: 				state.Print("││       Physical Plan       ││\n");
346: 			}
347: 			state.Print("│└───────────────────────────┘│\n");
348: 			state.Print("└─────────────────────────────┘\n");
349: 		}
350: 		state.Print(data[1]);
351: 	}
352: };
353: 
354: class ModeListRenderer : public RowRenderer {
355: public:
356: 	explicit ModeListRenderer(ShellState &state) : RowRenderer(state) {
357: 	}
358: 
359: 	void RenderHeader(RowResult &result) override {
360: 		if (!show_header) {
361: 			return;
362: 		}
363: 		auto &col_names = result.column_names;
364: 		for (idx_t i = 0; i < col_names.size(); i++) {
365: 			if (i > 0) {
366: 				state.Print(col_sep);
367: 			}
368: 			state.Print(col_names[i]);
369: 		}
370: 		state.Print(row_sep);
371: 	}
372: 
373: 	void RenderRow(RowResult &result) override {
374: 		auto &data = result.data;
375: 		for (idx_t i = 0; i < data.size(); i++) {
376: 			if (i > 0) {
377: 				state.Print(col_sep);
378: 			}
379: 			state.PrintValue(data[i]);
380: 		}
381: 		state.Print(row_sep);
382: 	}
383: };
384: 
385: class ModeHtmlRenderer : public RowRenderer {
386: public:
387: 	explicit ModeHtmlRenderer(ShellState &state) : RowRenderer(state) {
388: 	}
389: 
390: 	void RenderHeader(RowResult &result) override {
391: 		if (!show_header) {
392: 			return;
393: 		}
394: 		auto &col_names = result.column_names;
395: 		state.Print("<tr>");
396: 		for (idx_t i = 0; i < col_names.size(); i++) {
397: 			state.Print("<th>");
398: 			output_html_string(col_names[i]);
399: 			state.Print("</th>\n");
400: 		}
401: 		state.Print("</tr>\n");
402: 	}
403: 
404: 	void RenderRow(RowResult &result) override {
405: 		auto &data = result.data;
406: 		state.Print("<tr>");
407: 		for (idx_t i = 0; i < data.size(); i++) {
408: 			state.Print("<td>");
409: 			output_html_string(data[i] ? data[i] : state.nullValue.c_str());
410: 			state.Print("</td>\n");
411: 		}
412: 		state.Print("</tr>\n");
413: 	}
414: 
415: 	/*
416: 	** Output the given string with characters that are special to
417: 	** HTML escaped.
418: 	*/
419: 	void output_html_string(const char *z) {
420: 		if (z == 0)
421: 			z = "";
422: 		string escaped;
423: 		for (; *z; z++) {
424: 			switch (*z) {
425: 			case '<':
426: 				escaped += "&lt;";
427: 				break;
428: 			case '&':
429: 				escaped += "&amp;";
430: 				break;
431: 			case '>':
432: 				escaped += "&gt;";
433: 				break;
434: 			case '\"':
435: 				escaped += "&quot;";
436: 				break;
437: 			case '\'':
438: 				escaped += "&#39;";
439: 				break;
440: 			default:
441: 				escaped += *z;
442: 			}
443: 		}
444: 		state.Print(escaped);
445: 	}
446: };
447: 
448: class ModeTclRenderer : public RowRenderer {
449: public:
450: 	explicit ModeTclRenderer(ShellState &state) : RowRenderer(state) {
451: 	}
452: 
453: 	void RenderHeader(RowResult &result) override {
454: 		if (!show_header) {
455: 			return;
456: 		}
457: 		auto &col_names = result.column_names;
458: 		for (idx_t i = 0; i < col_names.size(); i++) {
459: 			if (i > 0) {
460: 				state.Print(col_sep);
461: 			}
462: 			state.OutputCString(col_names[i] ? col_names[i] : "");
463: 		}
464: 		state.Print(row_sep);
465: 	}
466: 
467: 	void RenderRow(RowResult &result) override {
468: 		auto &data = result.data;
469: 		for (idx_t i = 0; i < data.size(); i++) {
470: 			if (i > 0) {
471: 				state.Print(col_sep);
472: 			}
473: 			state.OutputCString(data[i] ? data[i] : state.nullValue.c_str());
474: 		}
475: 		state.Print(row_sep);
476: 	}
477: };
478: 
479: class ModeCsvRenderer : public RowRenderer {
480: public:
481: 	explicit ModeCsvRenderer(ShellState &state) : RowRenderer(state) {
482: 	}
483: 
484: 	void Render(RowResult &result) override {
485: 		state.SetBinaryMode();
486: 		RowRenderer::Render(result);
487: 		state.SetTextMode();
488: 	}
489: 	void RenderHeader(RowResult &result) override {
490: 		if (!show_header) {
491: 			return;
492: 		}
493: 		auto &col_names = result.column_names;
494: 		for (idx_t i = 0; i < col_names.size(); i++) {
495: 			state.OutputCSV(col_names[i] ? col_names[i] : "", i < col_names.size() - 1);
496: 		}
497: 		state.Print(row_sep);
498: 	}
499: 
500: 	void RenderRow(RowResult &result) override {
501: 		auto &data = result.data;
502: 		for (idx_t i = 0; i < data.size(); i++) {
503: 			state.OutputCSV(data[i], i < data.size() - 1);
504: 		}
505: 		state.Print(row_sep);
506: 	}
507: };
508: 
509: class ModeAsciiRenderer : public RowRenderer {
510: public:
511: 	explicit ModeAsciiRenderer(ShellState &state) : RowRenderer(state) {
512: 	}
513: 
514: 	void RenderHeader(RowResult &result) override {
515: 		if (!show_header) {
516: 			return;
517: 		}
518: 		auto &col_names = result.column_names;
519: 		for (idx_t i = 0; i < col_names.size(); i++) {
520: 			if (i > 0) {
521: 				state.Print(col_sep);
522: 			}
523: 			state.Print(col_names[i] ? col_names[i] : "");
524: 		}
525: 		state.Print(row_sep);
526: 	}
527: 
528: 	void RenderRow(RowResult &result) override {
529: 		auto &data = result.data;
530: 		for (idx_t i = 0; i < data.size(); i++) {
531: 			if (i > 0) {
532: 				state.Print(col_sep);
533: 			}
534: 			state.PrintValue(data[i]);
535: 		}
536: 		state.Print(row_sep);
537: 	}
538: };
539: 
540: class ModeQuoteRenderer : public RowRenderer {
541: public:
542: 	explicit ModeQuoteRenderer(ShellState &state) : RowRenderer(state) {
543: 	}
544: 
545: 	void RenderHeader(RowResult &result) override {
546: 		if (!show_header) {
547: 			return;
548: 		}
549: 		auto &col_names = result.column_names;
550: 		for (idx_t i = 0; i < col_names.size(); i++) {
551: 			if (i > 0) {
552: 				state.Print(col_sep);
553: 			}
554: 			state.OutputQuotedString(col_names[i]);
555: 		}
556: 		state.Print(row_sep);
557: 	}
558: 
559: 	void RenderRow(RowResult &result) override {
560: 		auto &data = result.data;
561: 		auto &types = result.types;
562: 		for (idx_t i = 0; i < data.size(); i++) {
563: 			if (i > 0)
564: 				state.Print(col_sep);
565: 			if ((data[i] == 0) || (!types.empty() && types[i] == SQLITE_NULL)) {
566: 				state.Print("NULL");
567: 			} else if (!types.empty() && (types[i] == SQLITE_TEXT || types[i] == SQLITE_BLOB)) {
568: 				state.OutputQuotedString(data[i]);
569: 			} else if (!types.empty() && (types[i] == SQLITE_INTEGER || types[i] == SQLITE_FLOAT)) {
570: 				state.Print(data[i]);
571: 			} else if (state.IsNumber(data[i], 0)) {
572: 				state.Print(data[i]);
573: 			} else {
574: 				state.OutputQuotedString(data[i]);
575: 			}
576: 		}
577: 		state.Print(row_sep);
578: 	}
579: };
580: 
581: class ModeJsonRenderer : public RowRenderer {
582: public:
583: 	explicit ModeJsonRenderer(ShellState &state, bool json_array) : RowRenderer(state), json_array(json_array) {
584: 	}
585: 
586: 	void Render(RowResult &result) override {
587: 		if (first_row) {
588: 			if (json_array) {
589: 				// wrap all JSON objects in an array
590: 				state.Print("[");
591: 			}
592: 			state.Print("{");
593: 			first_row = false;
594: 		} else {
595: 			if (json_array) {
596: 				// wrap all JSON objects in an array
597: 				state.Print(",");
598: 			}
599: 			state.Print("\n{");
600: 		}
601: 		RenderRow(result);
602: 	}
603: 
604: 	void RenderRow(RowResult &result) override {
605: 		auto &data = result.data;
606: 		auto &types = result.types;
607: 		auto &col_names = result.column_names;
608: 		for (idx_t i = 0; i < col_names.size(); i++) {
609: 			if (i > 0) {
610: 				state.Print(",");
611: 			}
612: 			state.OutputJSONString(col_names[i], -1);
613: 			state.Print(":");
614: 			if ((data[i] == 0) || (!types.empty() && types[i] == SQLITE_NULL)) {
615: 				state.Print("null");
616: 			} else if (!types.empty() && types[i] == SQLITE_FLOAT) {
617: 				if (strcmp(data[i], "inf") == 0) {
618: 					state.Print("1e999");
619: 				} else if (strcmp(data[i], "-inf") == 0) {
620: 					state.Print("-1e999");
621: 				} else {
622: 					state.Print(data[i]);
623: 				}
624: 			} else if (!types.empty() && types[i] == SQLITE_BLOB && result.pStmt) {
625: 				const void *pBlob = sqlite3_column_blob(result.pStmt, i);
626: 				int nBlob = sqlite3_column_bytes(result.pStmt, i);
627: 				state.OutputJSONString((const char *)pBlob, nBlob);
628: 			} else if (!types.empty() && types[i] == SQLITE_TEXT) {
629: 				state.OutputJSONString(data[i], -1);
630: 			} else {
631: 				state.Print(data[i]);
632: 			}
633: 		}
634: 		state.Print("}");
635: 	}
636: 
637: 	void RenderFooter(RowResult &result) override {
638: 		if (json_array) {
639: 			state.Print("]\n");
640: 		} else {
641: 			state.Print("\n");
642: 		}
643: 	}
644: 
645: 	bool json_array;
646: };
647: 
648: class ModeInsertRenderer : public RowRenderer {
649: public:
650: 	explicit ModeInsertRenderer(ShellState &state) : RowRenderer(state) {
651: 	}
652: 
653: 	void RenderRow(RowResult &result) override {
654: 		auto &data = result.data;
655: 		auto &types = result.types;
656: 		auto &col_names = result.column_names;
657: 
658: 		state.Print("INSERT INTO ");
659: 		state.Print(state.zDestTable);
660: 		if (show_header) {
661: 			state.Print("(");
662: 			for (idx_t i = 0; i < col_names.size(); i++) {
663: 				if (i > 0) {
664: 					state.Print(",");
665: 				}
666: 				state.PrintOptionallyQuotedIdentifier(col_names[i]);
667: 			}
668: 			state.Print(")");
669: 		}
670: 		for (idx_t i = 0; i < data.size(); i++) {
671: 			state.Print(i > 0 ? "," : " VALUES(");
672: 			if ((data[i] == 0) || (!types.empty() && types[i] == SQLITE_NULL)) {
673: 				state.Print("NULL");
674: 			} else if (state.IsNumber(data[i], nullptr)) {
675: 				state.Print(data[i]);
676: 			} else if (state.ShellHasFlag(SHFLG_Newlines)) {
677: 				state.OutputQuotedString(data[i]);
678: 			} else {
679: 				state.OutputQuotedEscapedString(data[i]);
680: 			}
681: 		}
682: 		state.Print(");\n");
683: 	}
684: };
685: 
686: class ModeSemiRenderer : public RowRenderer {
687: public:
688: 	explicit ModeSemiRenderer(ShellState &state) : RowRenderer(state) {
689: 	}
690: 
691: 	void RenderRow(RowResult &result) override {
692: 		/* .schema and .fullschema output */
693: 		state.PrintSchemaLine(result.data[0], "\n");
694: 	}
695: };
696: 
697: class ModePrettyRenderer : public RowRenderer {
698: public:
699: 	explicit ModePrettyRenderer(ShellState &state) : RowRenderer(state) {
700: 	}
701: 
702: 	void RenderRow(RowResult &result) override {
703: 		auto &data = result.data;
704: 		/* .schema and .fullschema with --indent */
705: 		if (data.size() != 1) {
706: 			throw std::runtime_error("row must have exactly one value for pretty rendering");
707: 		}
708: 		char *z;
709: 		int j;
710: 		int nParen = 0;
711: 		char cEnd = 0;
712: 		char c;
713: 		int nLine = 0;
714: 		if (!data[0]) {
715: 			return;
716: 		}
717: 		if (sqlite3_strlike("CREATE VIEW%", data[0], 0) == 0 || sqlite3_strlike("CREATE TRIG%", data[0], 0) == 0) {
718: 			state.Print(data[0]);
719: 			state.Print(";\n");
720: 			return;
721: 		}
722: 		z = sqlite3_mprintf("%s", data[0]);
723: 		j = 0;
724: 		idx_t i;
725: 		for (i = 0; IsSpace(z[i]); i++) {
726: 		}
727: 		for (; (c = z[i]) != 0; i++) {
728: 			if (IsSpace(c)) {
729: 				if (z[j - 1] == '\r')
730: 					z[j - 1] = '\n';
731: 				if (IsSpace(z[j - 1]) || z[j - 1] == '(')
732: 					continue;
733: 			} else if ((c == '(' || c == ')') && j > 0 && IsSpace(z[j - 1])) {
734: 				j--;
735: 			}
736: 			z[j++] = c;
737: 		}
738: 		while (j > 0 && IsSpace(z[j - 1])) {
739: 			j--;
740: 		}
741: 		z[j] = 0;
742: 		if (state.StringLength(z) >= 79) {
743: 			for (i = j = 0; (c = z[i]) != 0; i++) { /* Copy from z[i] back to z[j] */
744: 				if (c == cEnd) {
745: 					cEnd = 0;
746: 				} else if (c == '"' || c == '\'' || c == '`') {
747: 					cEnd = c;
748: 				} else if (c == '[') {
749: 					cEnd = ']';
750: 				} else if (c == '-' && z[i + 1] == '-') {
751: 					cEnd = '\n';
752: 				} else if (c == '(') {
753: 					nParen++;
754: 				} else if (c == ')') {
755: 					nParen--;
756: 					if (nLine > 0 && nParen == 0 && j > 0) {
757: 						state.PrintSchemaLineN(z, j, "\n");
758: 						j = 0;
759: 					}
760: 				}
761: 				z[j++] = c;
762: 				if (nParen == 1 && cEnd == 0 && (c == '(' || c == '\n' || (c == ',' && !wsToEol(z + i + 1)))) {
763: 					if (c == '\n')
764: 						j--;
765: 					state.PrintSchemaLineN(z, j, "\n  ");
766: 					j = 0;
767: 					nLine++;
768: 					while (IsSpace(z[i + 1])) {
769: 						i++;
770: 					}
771: 				}
772: 			}
773: 			z[j] = 0;
774: 		}
775: 		state.PrintSchemaLine(z, ";\n");
776: 		sqlite3_free(z);
777: 	}
778: 
779: 	/*
780: 	** Return true if string z[] has nothing but whitespace and comments to the
781: 	** end of the first line.
782: 	*/
783: 	static bool wsToEol(const char *z) {
784: 		int i;
785: 		for (i = 0; z[i]; i++) {
786: 			if (z[i] == '\n') {
787: 				return true;
788: 			}
789: 			if (IsSpace(z[i])) {
790: 				continue;
791: 			}
792: 			if (z[i] == '-' && z[i + 1] == '-') {
793: 				return true;
794: 			}
795: 			return false;
796: 		}
797: 		return true;
798: 	}
799: };
800: 
801: unique_ptr<RowRenderer> ShellState::GetRowRenderer() {
802: 	return GetRowRenderer(cMode);
803: }
804: 
805: unique_ptr<RowRenderer> ShellState::GetRowRenderer(RenderMode mode) {
806: 	switch (mode) {
807: 	case RenderMode::LINE:
808: 		return unique_ptr<RowRenderer>(new ModeLineRenderer(*this));
809: 	case RenderMode::EXPLAIN:
810: 		return unique_ptr<RowRenderer>(new ModeExplainRenderer(*this));
811: 	case RenderMode::LIST:
812: 		return unique_ptr<RowRenderer>(new ModeListRenderer(*this));
813: 	case RenderMode::HTML:
814: 		return unique_ptr<RowRenderer>(new ModeHtmlRenderer(*this));
815: 	case RenderMode::TCL:
816: 		return unique_ptr<RowRenderer>(new ModeTclRenderer(*this));
817: 	case RenderMode::CSV:
818: 		return unique_ptr<RowRenderer>(new ModeCsvRenderer(*this));
819: 	case RenderMode::ASCII:
820: 		return unique_ptr<RowRenderer>(new ModeAsciiRenderer(*this));
821: 	case RenderMode::QUOTE:
822: 		return unique_ptr<RowRenderer>(new ModeQuoteRenderer(*this));
823: 	case RenderMode::JSON:
824: 		return unique_ptr<RowRenderer>(new ModeJsonRenderer(*this, true));
825: 	case RenderMode::JSONLINES:
826: 		return unique_ptr<RowRenderer>(new ModeJsonRenderer(*this, false));
827: 	case RenderMode::INSERT:
828: 		return unique_ptr<RowRenderer>(new ModeInsertRenderer(*this));
829: 	case RenderMode::SEMI:
830: 		return unique_ptr<RowRenderer>(new ModeSemiRenderer(*this));
831: 	case RenderMode::PRETTY:
832: 		return unique_ptr<RowRenderer>(new ModePrettyRenderer(*this));
833: 	case RenderMode::TRASH:
834: 		// no renderer
835: 		return nullptr;
836: 	default:
837: 		throw std::runtime_error("Unsupported mode for GetRowRenderer");
838: 	}
839: }
840: 
841: } // namespace duckdb_shell
[end of tools/shell/shell_renderer.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: