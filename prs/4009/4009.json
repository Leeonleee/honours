{
  "repo": "duckdb/duckdb",
  "pull_number": 4009,
  "instance_id": "duckdb__duckdb-4009",
  "issue_numbers": [
    "3094"
  ],
  "base_commit": "4d39f040c115177d7d00b5dd26b3306193f90149",
  "patch": "diff --git a/benchmark/include/duckdb_benchmark.hpp b/benchmark/include/duckdb_benchmark.hpp\nindex 1c614d7bc7df..982a2e9bdb3f 100644\n--- a/benchmark/include/duckdb_benchmark.hpp\n+++ b/benchmark/include/duckdb_benchmark.hpp\n@@ -25,10 +25,27 @@ struct DuckDBBenchmarkState : public BenchmarkState {\n \tunique_ptr<QueryResult> result;\n \n \tDuckDBBenchmarkState(string path) : db(path.empty() ? nullptr : path.c_str()), conn(db) {\n-\t\tconn.EnableProfiling();\n \t\tauto &instance = BenchmarkRunner::GetInstance();\n \t\tauto res = conn.Query(\"PRAGMA threads=\" + to_string(instance.threads));\n \t\tD_ASSERT(res->success);\n+\t\tstring profiling_mode;\n+\t\tswitch (instance.configuration.profile_info) {\n+\t\tcase BenchmarkProfileInfo::NONE:\n+\t\t\tprofiling_mode = \"\";\n+\t\t\tbreak;\n+\t\tcase BenchmarkProfileInfo::NORMAL:\n+\t\t\tprofiling_mode = \"standard\";\n+\t\t\tbreak;\n+\t\tcase BenchmarkProfileInfo::DETAILED:\n+\t\t\tprofiling_mode = \"detailed\";\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow InternalException(\"Unknown profiling option \\\"%s\\\"\", instance.configuration.profile_info);\n+\t\t}\n+\t\tif (!profiling_mode.empty()) {\n+\t\t\tres = conn.Query(\"PRAGMA profiling_mode=\" + profiling_mode);\n+\t\t\tD_ASSERT(res->success);\n+\t\t}\n \t}\n \tvirtual ~DuckDBBenchmarkState() {\n \t}\ndiff --git a/benchmark/interpreted_benchmark.cpp b/benchmark/interpreted_benchmark.cpp\nindex 3447f6188a65..a326896ee538 100644\n--- a/benchmark/interpreted_benchmark.cpp\n+++ b/benchmark/interpreted_benchmark.cpp\n@@ -42,7 +42,6 @@ struct InterpretedBenchmarkState : public BenchmarkState {\n \texplicit InterpretedBenchmarkState(string path)\n \t    : benchmark_config(GetBenchmarkConfig()), db(path.empty() ? nullptr : path.c_str(), benchmark_config.get()),\n \t      con(db) {\n-\t\tcon.EnableProfiling();\n \t\tauto &instance = BenchmarkRunner::GetInstance();\n \t\tauto res = con.Query(\"PRAGMA threads=\" + to_string(instance.threads));\n \t\tD_ASSERT(res->success);\ndiff --git a/src/function/pragma/pragma_functions.cpp b/src/function/pragma/pragma_functions.cpp\nindex 11c5ec4959ce..9cdf059b895a 100644\n--- a/src/function/pragma/pragma_functions.cpp\n+++ b/src/function/pragma/pragma_functions.cpp\n@@ -16,8 +16,8 @@ namespace duckdb {\n \n static void PragmaEnableProfilingStatement(ClientContext &context, const FunctionParameters &parameters) {\n \tauto &config = ClientConfig::GetConfig(context);\n-\tconfig.profiler_print_format = ProfilerPrintFormat::QUERY_TREE;\n \tconfig.enable_profiler = true;\n+\tconfig.emit_profiler_output = true;\n }\n \n void RegisterEnableProfiling(BuiltinFunctions &set) {\n@@ -31,7 +31,6 @@ void RegisterEnableProfiling(BuiltinFunctions &set) {\n static void PragmaDisableProfiling(ClientContext &context, const FunctionParameters &parameters) {\n \tauto &config = ClientConfig::GetConfig(context);\n \tconfig.enable_profiler = false;\n-\tconfig.profiler_print_format = ProfilerPrintFormat::NONE;\n }\n \n static void PragmaEnableProgressBar(ClientContext &context, const FunctionParameters &parameters) {\ndiff --git a/src/include/duckdb/common/enums/profiler_format.hpp b/src/include/duckdb/common/enums/profiler_format.hpp\nindex 2ab375e76f14..2e4e2b0520fe 100644\n--- a/src/include/duckdb/common/enums/profiler_format.hpp\n+++ b/src/include/duckdb/common/enums/profiler_format.hpp\n@@ -12,6 +12,6 @@\n \n namespace duckdb {\n \n-enum class ProfilerPrintFormat : uint8_t { NONE, QUERY_TREE, JSON, QUERY_TREE_OPTIMIZER };\n+enum class ProfilerPrintFormat : uint8_t { QUERY_TREE, JSON, QUERY_TREE_OPTIMIZER };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/main/client_config.hpp b/src/include/duckdb/main/client_config.hpp\nindex 351cc9dc29e1..4683cdda68e7 100644\n--- a/src/include/duckdb/main/client_config.hpp\n+++ b/src/include/duckdb/main/client_config.hpp\n@@ -27,12 +27,16 @@ struct ClientConfig {\n \tbool enable_profiler = false;\n \t//! If detailed query profiling is enabled\n \tbool enable_detailed_profiling = false;\n-\t//! The format to automatically print query profiling information in (default: disabled)\n-\tProfilerPrintFormat profiler_print_format = ProfilerPrintFormat::NONE;\n+\t//! The format to print query profiling information in (default: query_tree), if enabled.\n+\tProfilerPrintFormat profiler_print_format = ProfilerPrintFormat::QUERY_TREE;\n \t//! The file to save query profiling information to, instead of printing it to the console\n \t//! (empty = print to console)\n \tstring profiler_save_location;\n \n+\t//! Allows suppressing profiler output, even if enabled. We turn on the profiler on all test runs but don't want\n+\t//! to output anything\n+\tbool emit_profiler_output = true;\n+\n \t//! If the progress bar is enabled or not.\n \tbool enable_progress_bar = false;\n \t//! If the print of the progress bar is enabled\ndiff --git a/src/include/duckdb/main/query_profiler.hpp b/src/include/duckdb/main/query_profiler.hpp\nindex e109a43c5d49..d675391b4fae 100644\n--- a/src/include/duckdb/main/query_profiler.hpp\n+++ b/src/include/duckdb/main/query_profiler.hpp\n@@ -166,10 +166,14 @@ class QueryProfiler {\n \n \tDUCKDB_API void Initialize(PhysicalOperator *root);\n \n-\tDUCKDB_API string ToString(bool print_optimizer_output = false) const;\n-\tDUCKDB_API void ToStream(std::ostream &str, bool print_optimizer_output = false) const;\n+\tDUCKDB_API string QueryTreeToString(bool print_optimizer_output = false) const;\n+\tDUCKDB_API void QueryTreeToStream(std::ostream &str, bool print_optimizer_output = false) const;\n \tDUCKDB_API void Print();\n \n+\t//! return the printed as a string. Unlike ToString, which is always formatted as a string,\n+\t//! the return value is formatted based on the current print format (see GetPrintFormat()).\n+\tDUCKDB_API string ToString() const;\n+\n \tDUCKDB_API string ToJSON() const;\n \tDUCKDB_API void WriteToFile(const char *path, string &info) const;\n \ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex 497fb3415386..f5aa6e71ffb8 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -772,6 +772,7 @@ void ClientContext::EnableProfiling() {\n \tauto lock = LockContext();\n \tauto &config = ClientConfig::GetConfig(*this);\n \tconfig.enable_profiler = true;\n+\tconfig.emit_profiler_output = true;\n }\n \n void ClientContext::DisableProfiling() {\ndiff --git a/src/main/connection.cpp b/src/main/connection.cpp\nindex 23819f9c404b..d084c62c45f7 100644\n--- a/src/main/connection.cpp\n+++ b/src/main/connection.cpp\n@@ -20,6 +20,7 @@ Connection::Connection(DatabaseInstance &database) : context(make_shared<ClientC\n \tConnectionManager::Get(database).AddConnection(*context);\n #ifdef DEBUG\n \tEnableProfiling();\n+\tcontext->config.emit_profiler_output = false;\n #endif\n }\n \n@@ -35,7 +36,7 @@ string Connection::GetProfilingInformation(ProfilerPrintFormat format) {\n \tif (format == ProfilerPrintFormat::JSON) {\n \t\treturn profiler.ToJSON();\n \t} else {\n-\t\treturn profiler.ToString();\n+\t\treturn profiler.QueryTreeToString();\n \t}\n }\n \ndiff --git a/src/main/query_profiler.cpp b/src/main/query_profiler.cpp\nindex 65f5c1a03f2d..6c9eb0e468ad 100644\n--- a/src/main/query_profiler.cpp\n+++ b/src/main/query_profiler.cpp\n@@ -31,7 +31,7 @@ bool QueryProfiler::IsDetailedEnabled() const {\n }\n \n ProfilerPrintFormat QueryProfiler::GetPrintFormat() const {\n-\treturn is_explain_analyze ? ProfilerPrintFormat::NONE : ClientConfig::GetConfig(context).profiler_print_format;\n+\treturn ClientConfig::GetConfig(context).profiler_print_format;\n }\n \n string QueryProfiler::GetSaveLocation() const {\n@@ -119,20 +119,14 @@ void QueryProfiler::EndQuery() {\n \t\tFinalize(*root);\n \t}\n \tthis->running = false;\n-\tauto automatic_print_format = GetPrintFormat();\n-\t// print or output the query profiling after termination, if this is enabled\n-\tif (automatic_print_format != ProfilerPrintFormat::NONE) {\n-\t\t// check if this query should be output based on the operator types\n-\t\tstring query_info;\n-\t\tif (automatic_print_format == ProfilerPrintFormat::JSON) {\n-\t\t\tquery_info = ToJSON();\n-\t\t} else if (automatic_print_format == ProfilerPrintFormat::QUERY_TREE) {\n-\t\t\tquery_info = ToString();\n-\t\t} else if (automatic_print_format == ProfilerPrintFormat::QUERY_TREE_OPTIMIZER) {\n-\t\t\tquery_info = ToString(true);\n-\t\t}\n+\t// print or output the query profiling after termination\n+\t// EXPLAIN ANALYSE should not be outputted by the profiler\n+\tif (IsEnabled() && !is_explain_analyze) {\n+\t\tstring query_info = ToString();\n \t\tauto save_location = GetSaveLocation();\n-\t\tif (save_location.empty()) {\n+\t\tif (!ClientConfig::GetConfig(context).emit_profiler_output) {\n+\t\t\t// disable output\n+\t\t} else if (save_location.empty()) {\n \t\t\tPrinter::Print(query_info);\n \t\t\tPrinter::Print(\"\\n\");\n \t\t} else {\n@@ -141,6 +135,19 @@ void QueryProfiler::EndQuery() {\n \t}\n \tthis->is_explain_analyze = false;\n }\n+string QueryProfiler::ToString() const {\n+\tconst auto format = GetPrintFormat();\n+\tswitch (format) {\n+\tcase ProfilerPrintFormat::QUERY_TREE:\n+\t\treturn QueryTreeToString();\n+\tcase ProfilerPrintFormat::JSON:\n+\t\treturn ToJSON();\n+\tcase ProfilerPrintFormat::QUERY_TREE_OPTIMIZER:\n+\t\treturn QueryTreeToString(true);\n+\tdefault:\n+\t\tthrow InternalException(\"Unknown ProfilerPrintFormat \\\"%s\\\"\", format);\n+\t}\n+}\n \n void QueryProfiler::StartPhase(string new_phase) {\n \tif (!IsEnabled() || !running) {\n@@ -332,13 +339,13 @@ static string RenderTiming(double timing) {\n \treturn timing_s + \"s\";\n }\n \n-string QueryProfiler::ToString(bool print_optimizer_output) const {\n+string QueryProfiler::QueryTreeToString(bool print_optimizer_output) const {\n \tstd::stringstream str;\n-\tToStream(str, print_optimizer_output);\n+\tQueryTreeToStream(str, print_optimizer_output);\n \treturn str.str();\n }\n \n-void QueryProfiler::ToStream(std::ostream &ss, bool print_optimizer_output) const {\n+void QueryProfiler::QueryTreeToStream(std::ostream &ss, bool print_optimizer_output) const {\n \tif (!IsEnabled()) {\n \t\tss << \"Query profiling is disabled. Call \"\n \t\t      \"Connection::EnableProfiling() to enable profiling!\";\n@@ -589,7 +596,7 @@ void QueryProfiler::Render(const QueryProfiler::TreeNode &node, std::ostream &ss\n }\n \n void QueryProfiler::Print() {\n-\tPrinter::Print(ToString());\n+\tPrinter::Print(QueryTreeToString());\n }\n \n vector<QueryProfiler::PhaseTimingItem> QueryProfiler::GetOrderedPhaseTimings() const {\ndiff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp\nindex 97b3bd07379d..868e5df8e221 100644\n--- a/src/main/settings/settings.cpp\n+++ b/src/main/settings/settings.cpp\n@@ -288,6 +288,7 @@ void EnableProfilingSetting::SetLocal(ClientContext &context, const Value &input\n \t\t    \"Unrecognized print format %s, supported formats: [json, query_tree, query_tree_optimizer]\", parameter);\n \t}\n \tconfig.enable_profiler = true;\n+\tconfig.emit_profiler_output = true;\n }\n \n Value EnableProfilingSetting::GetSetting(ClientContext &context) {\n@@ -296,8 +297,6 @@ Value EnableProfilingSetting::GetSetting(ClientContext &context) {\n \t\treturn Value();\n \t}\n \tswitch (config.profiler_print_format) {\n-\tcase ProfilerPrintFormat::NONE:\n-\t\treturn Value(\"none\");\n \tcase ProfilerPrintFormat::JSON:\n \t\treturn Value(\"json\");\n \tcase ProfilerPrintFormat::QUERY_TREE:\n@@ -521,9 +520,11 @@ void ProfilingModeSetting::SetLocal(ClientContext &context, const Value &input)\n \tif (parameter == \"standard\") {\n \t\tconfig.enable_profiler = true;\n \t\tconfig.enable_detailed_profiling = false;\n+\t\tconfig.emit_profiler_output = true;\n \t} else if (parameter == \"detailed\") {\n \t\tconfig.enable_profiler = true;\n \t\tconfig.enable_detailed_profiling = true;\n+\t\tconfig.emit_profiler_output = true;\n \t} else {\n \t\tthrow ParserException(\"Unrecognized profiling mode \\\"%s\\\", supported formats: [standard, detailed]\", parameter);\n \t}\n",
  "test_patch": "diff --git a/test/sql/explain/test_explain_analyze.test b/test/sql/explain/test_explain_analyze.test\nindex e5be671b06e3..203af6b6e4c2 100644\n--- a/test/sql/explain/test_explain_analyze.test\n+++ b/test/sql/explain/test_explain_analyze.test\n@@ -56,7 +56,7 @@ PRAGMA enable_profiling='json'\n query II\n EXPLAIN ANALYZE SELECT SUM(i) FROM integers\n ----\n-analyzed_plan\t<REGEX>:.*integers.*\n+analyzed_plan\t<REGEX>:.*integers.*\"timings\":.*\n \n statement ok\n PRAGMA disable_profiling\n",
  "problem_statement": "Feature Request: way for `EXPLAIN ANALYZE` to return a JSON string instead of the ascii representation as a result set\n# Problem Statement\r\n\r\nCurrently, `EXPLAIN ANALYZE` returns an ascii representation of the plan.\r\n\r\nThis is the perfect representation when someone is using duckdb in an _interactive environment_ such as a jupyter notebook. Usually the output you'd want from this kind of query is a flexible text-based representation that enables the data analyst to understand what the query is doing.\r\n\r\nBut for _programmatic_ use-cases, the ascii representation does not work. Instead of having a human in the loop analyzing the query, it's the _computer_ that needs an easy way to understand the query so that it can do things with the plan \u2013 for instance, do further analysis on the sources, analyze the scans and projections in different ways. Which likely means a JSON string is more appropriate.\r\n\r\nThere is a work-around we can employ. Setting these pragmas\r\n\r\n```\r\nPRAGMA enable_profiling=json;\r\nPRAGMA profiling_output='./profile.json';\r\n```\r\n\r\n... and then reading back `profile.json` into one's application. But this is quite limited. Some of the assumptions of the work-around break down when my build target uses `duckdb-wasm` instead of the node client.\r\n\r\n# Proposed Solution\r\n\r\nA way to tell any client (WASM, Node, Python, R, etc.) that the output of an `EXPLAIN ANALYZE` query should return the same JSON returned by the `enable_profiling` pragma would be ideal. Defaulting to ascii seems like a great option to uphold the current expectation for interactive users.\r\n\r\nA pragma-based approach would likely give maximum flexibility to users for myriad use-cases, including in the CLI. But I'm open to any solution that enables the computer to parse the JSON representation. It seems that `PRAGMA enable_profiling=json` could also apply to `EXPLAIN ANALYZE` but perhaps this breaks a mental model of interactive vs. programmatic in some way I haven't thought of.\n",
  "hints_text": "Maybe a `JSON`-option` also for query plans?",
  "created_at": "2022-06-30T13:12:34Z"
}