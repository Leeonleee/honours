diff --git a/src/include/duckdb/storage/block_manager.hpp b/src/include/duckdb/storage/block_manager.hpp
index 738d9defd357..214b410ca102 100644
--- a/src/include/duckdb/storage/block_manager.hpp
+++ b/src/include/duckdb/storage/block_manager.hpp
@@ -39,6 +39,7 @@ class BlockManager {
 	virtual unique_ptr<Block> CreateBlock(block_id_t block_id, FileBuffer *source_buffer) = 0;
 	//! Return the next free block id
 	virtual block_id_t GetFreeBlockId() = 0;
+	virtual block_id_t PeekFreeBlockId() = 0;
 	//! Returns whether or not a specified block is the root block
 	virtual bool IsRootBlock(MetaBlockPointer root) = 0;
 	//! Mark a block as "free"; free blocks are immediately added to the free list and can be immediately overwritten
diff --git a/src/include/duckdb/storage/in_memory_block_manager.hpp b/src/include/duckdb/storage/in_memory_block_manager.hpp
index 0f3985cb91f6..61707cb91ad9 100644
--- a/src/include/duckdb/storage/in_memory_block_manager.hpp
+++ b/src/include/duckdb/storage/in_memory_block_manager.hpp
@@ -29,6 +29,9 @@ class InMemoryBlockManager : public BlockManager {
 	block_id_t GetFreeBlockId() override {
 		throw InternalException("Cannot perform IO in in-memory database - GetFreeBlockId!");
 	}
+	block_id_t PeekFreeBlockId() override {
+		throw InternalException("Cannot perform IO in in-memory database - PeekFreeBlockId!");
+	}
 	bool IsRootBlock(MetaBlockPointer root) override {
 		throw InternalException("Cannot perform IO in in-memory database - IsRootBlock!");
 	}
diff --git a/src/include/duckdb/storage/metadata/metadata_manager.hpp b/src/include/duckdb/storage/metadata/metadata_manager.hpp
index 900dde009700..58df31b11c72 100644
--- a/src/include/duckdb/storage/metadata/metadata_manager.hpp
+++ b/src/include/duckdb/storage/metadata/metadata_manager.hpp
@@ -81,6 +81,7 @@ class MetadataManager {
 
 protected:
 	block_id_t AllocateNewBlock();
+	block_id_t PeekNextBlockId();
 	block_id_t GetNextBlockId();
 
 	void AddBlock(MetadataBlock new_block, bool if_exists = false);
diff --git a/src/include/duckdb/storage/single_file_block_manager.hpp b/src/include/duckdb/storage/single_file_block_manager.hpp
index bdf2e2dbff84..fbdea181049f 100644
--- a/src/include/duckdb/storage/single_file_block_manager.hpp
+++ b/src/include/duckdb/storage/single_file_block_manager.hpp
@@ -49,6 +49,8 @@ class SingleFileBlockManager : public BlockManager {
 	unique_ptr<Block> CreateBlock(block_id_t block_id, FileBuffer *source_buffer) override;
 	//! Return the next free block id
 	block_id_t GetFreeBlockId() override;
+	//! Check the next free block id - but do not assign or allocate it
+	block_id_t PeekFreeBlockId() override;
 	//! Returns whether or not a specified block is the root block
 	bool IsRootBlock(MetaBlockPointer root) override;
 	//! Mark a block as free (immediately re-writeable)
diff --git a/src/storage/metadata/metadata_manager.cpp b/src/storage/metadata/metadata_manager.cpp
index 2fba4fc1bbc7..5e8c7c5f246a 100644
--- a/src/storage/metadata/metadata_manager.cpp
+++ b/src/storage/metadata/metadata_manager.cpp
@@ -26,7 +26,7 @@ MetadataHandle MetadataManager::AllocateHandle() {
 			break;
 		}
 	}
-	if (free_block == INVALID_BLOCK) {
+	if (free_block == INVALID_BLOCK || free_block > PeekNextBlockId()) {
 		free_block = AllocateNewBlock();
 	}
 	D_ASSERT(free_block != INVALID_BLOCK);
@@ -315,6 +315,10 @@ vector<MetadataBlockInfo> MetadataManager::GetMetadataInfo() const {
 	return result;
 }
 
+block_id_t MetadataManager::PeekNextBlockId() {
+	return block_manager.PeekFreeBlockId();
+}
+
 block_id_t MetadataManager::GetNextBlockId() {
 	return block_manager.GetFreeBlockId();
 }
diff --git a/src/storage/single_file_block_manager.cpp b/src/storage/single_file_block_manager.cpp
index 1b182f2b8878..222d9908c0aa 100644
--- a/src/storage/single_file_block_manager.cpp
+++ b/src/storage/single_file_block_manager.cpp
@@ -348,6 +348,15 @@ block_id_t SingleFileBlockManager::GetFreeBlockId() {
 	return block;
 }
 
+block_id_t SingleFileBlockManager::PeekFreeBlockId() {
+	lock_guard<mutex> lock(block_lock);
+	if (!free_list.empty()) {
+		return *free_list.begin();
+	} else {
+		return max_block;
+	}
+}
+
 void SingleFileBlockManager::MarkBlockAsFree(block_id_t block_id) {
 	lock_guard<mutex> lock(block_lock);
 	D_ASSERT(block_id >= 0);
