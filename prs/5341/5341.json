{
  "repo": "duckdb/duckdb",
  "pull_number": 5341,
  "instance_id": "duckdb__duckdb-5341",
  "issue_numbers": [
    "5314"
  ],
  "base_commit": "ee2329be9ccde1d9e9c88edef79e1045bf621f3b",
  "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\nindex 349af6acf7b4..16a843bc0369 100644\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -96,6 +96,26 @@ if(FORCE_32_BIT)\n   set(M32_FLAG \" -m32 \")\n endif()\n \n+set(OS_NAME \"unknown\")\n+set(OS_ARCH \"amd64\")\n+\n+string(REGEX MATCH \"(arm64|aarch64)\" IS_ARM \"${CMAKE_SYSTEM_PROCESSOR}\")\n+if(IS_ARM)\n+  set(OS_ARCH \"arm64\")\n+elseif(FORCE_32_BIT)\n+  set(OS_ARCH \"i386\")\n+endif()\n+\n+if(APPLE)\n+  set(OS_NAME \"osx\")\n+endif()\n+if(WIN32)\n+  set(OS_NAME \"windows\")\n+endif()\n+if(UNIX AND NOT APPLE)\n+  set(OS_NAME \"linux\") # sorry BSD\n+endif()\n+\n option(FORCE_WARN_UNUSED \"Unused code objects lead to compiler warnings.\" FALSE)\n \n option(ENABLE_SANITIZER \"Enable address sanitizer.\" TRUE)\n@@ -256,6 +276,13 @@ option(EXTENSION_STATIC_BUILD\n         \"Extension build linking statically with DuckDB. Required for building linux loadable extensions.\"\n         FALSE)\n \n+\n+set(JEMALLOC_DEFAULT_BUILD FALSE)\n+if(NOT CLANG_TIDY AND OS_NAME STREQUAL \"linux\")\n+  # build jemalloc by default for linux\n+  set(JEMALLOC_DEFAULT_BUILD TRUE)\n+endif()\n+\n option(BUILD_ICU_EXTENSION \"Build the ICU extension.\" FALSE)\n option(BUILD_PARQUET_EXTENSION \"Build the Parquet extension.\" FALSE)\n option(BUILD_TPCH_EXTENSION \"Build the TPC-H extension.\" FALSE)\n@@ -264,7 +291,7 @@ option(BUILD_FTS_EXTENSION \"Build the FTS extension.\" FALSE)\n option(BUILD_HTTPFS_EXTENSION \"Build the HTTP File System extension.\" FALSE)\n option(BUILD_VISUALIZER_EXTENSION \"Build the profiler-output visualizer extension.\" FALSE)\n option(BUILD_JSON_EXTENSION \"Build the JSON extension.\" FALSE)\n-option(BUILD_JEMALLOC_EXTENSION \"Build the JEMalloc extension.\" FALSE)\n+option(BUILD_JEMALLOC_EXTENSION \"Build the JEMalloc extension.\" ${JEMALLOC_DEFAULT_BUILD})\n option(BUILD_EXCEL_EXTENSION \"Build the excel extension.\" FALSE)\n option(BUILD_INET_EXTENSION \"Build the inet extension.\" FALSE)\n option(BUILD_BENCHMARKS \"Enable building of the benchmark suite.\" FALSE)\n@@ -403,31 +430,7 @@ if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n       CACHE STRING \"Choose the type of build.\" FORCE)\n endif()\n \n-\n-set(OS_NAME \"unknown\")\n-set(OS_ARCH \"amd64\")\n-\n-string(REGEX MATCH \"(arm64|aarch64)\" IS_ARM \"${CMAKE_SYSTEM_PROCESSOR}\")\n-if(IS_ARM)\n-  set(OS_ARCH \"arm64\")\n-elseif(FORCE_32_BIT)\n-  set(OS_ARCH \"i386\")\n-endif()\n-\n-if(APPLE)\n-  set(OS_NAME \"osx\")\n-endif()\n-if(WIN32)\n-  set(OS_NAME \"windows\")\n-endif()\n-if(UNIX AND NOT APPLE)\n-  set(OS_NAME \"linux\") # sorry BSD\n-endif()\n-\n-if(NOT CLANG_TIDY AND OS_NAME STREQUAL \"linux\")\n-  # always build jemalloc for linux\n-  set(BUILD_JEMALLOC_EXTENSION 1)\n-elseif(OS_NAME STREQUAL \"windows\")\n+if(OS_NAME STREQUAL \"windows\")\n   if(BUILD_JEMALLOC_EXTENSION EQUAL 1)\n     # have to throw an error because this will crash at runtime\n     message(FATAL_ERROR \"The jemalloc extension is not supported on Windows\")\ndiff --git a/extension/icu/CMakeLists.txt b/extension/icu/CMakeLists.txt\nindex a35662b0a396..d58cd9e823e0 100644\n--- a/extension/icu/CMakeLists.txt\n+++ b/extension/icu/CMakeLists.txt\n@@ -17,7 +17,8 @@ set(ICU_EXTENSION_FILES\n     icu-datesub.cpp\n     icu-datetrunc.cpp\n     icu-makedate.cpp\n-    icu-strptime.cpp)\n+    icu-strptime.cpp\n+    icu-timezone.cpp)\n \n add_library(icu_extension STATIC ${ICU_EXTENSION_FILES})\n link_threads(icu_extension)\ndiff --git a/extension/icu/icu-datepart.cpp b/extension/icu/icu-datepart.cpp\nindex 9b85d128ab31..4931ebac6af8 100644\n--- a/extension/icu/icu-datepart.cpp\n+++ b/extension/icu/icu-datepart.cpp\n@@ -329,24 +329,24 @@ struct ICUDatePart : public ICUDateFunc {\n \t\t\tfor (idx_t i = 0; i < count; ++i) {\n \t\t\t\tconst auto idx = rdata.sel->get_index(i);\n \t\t\t\tif (arg_valid.RowIsValid(idx)) {\n-\t\t\t\t\tres_valid.SetValid(idx);\n+\t\t\t\t\tres_valid.SetValid(i);\n \t\t\t\t\tauto micros = SetTime(calendar, tdata[idx]);\n \t\t\t\t\tconst auto is_finite = Timestamp::IsFinite(tdata[idx]);\n \t\t\t\t\tfor (size_t col = 0; col < child_entries.size(); ++col) {\n \t\t\t\t\t\tauto &child_entry = child_entries[col];\n \t\t\t\t\t\tif (is_finite) {\n-\t\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetValid(idx);\n+\t\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetValid(i);\n \t\t\t\t\t\t\tauto pdata = FlatVector::GetData<int64_t>(*child_entry);\n \t\t\t\t\t\t\tauto adapter = info.adapters[col];\n-\t\t\t\t\t\t\tpdata[idx] = adapter(calendar, micros);\n+\t\t\t\t\t\t\tpdata[i] = adapter(calendar, micros);\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetInvalid(idx);\n+\t\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetInvalid(i);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tres_valid.SetInvalid(idx);\n+\t\t\t\t\tres_valid.SetInvalid(i);\n \t\t\t\t\tfor (auto &child_entry : child_entries) {\n-\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetInvalid(idx);\n+\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetInvalid(i);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\ndiff --git a/extension/icu/icu-extension.cpp b/extension/icu/icu-extension.cpp\nindex 7a0d9dc3f816..987803a05370 100644\n--- a/extension/icu/icu-extension.cpp\n+++ b/extension/icu/icu-extension.cpp\n@@ -14,6 +14,7 @@\n #include \"include/icu-datetrunc.hpp\"\n #include \"include/icu-makedate.hpp\"\n #include \"include/icu-strptime.hpp\"\n+#include \"include/icu-timezone.hpp\"\n \n #include \"duckdb/main/database.hpp\"\n #include \"duckdb/main/connection.hpp\"\n@@ -162,83 +163,6 @@ static void SetICUTimeZone(ClientContext &context, SetScope scope, Value &parame\n \t}\n }\n \n-struct ICUTimeZoneData : public GlobalTableFunctionState {\n-\tICUTimeZoneData() : tzs(icu::TimeZone::createEnumeration()) {\n-\t\tUErrorCode status = U_ZERO_ERROR;\n-\t\tstd::unique_ptr<icu::Calendar> calendar(icu::Calendar::createInstance(status));\n-\t\tnow = calendar->getNow();\n-\t}\n-\n-\tstd::unique_ptr<icu::StringEnumeration> tzs;\n-\tUDate now;\n-};\n-\n-static unique_ptr<FunctionData> ICUTimeZoneBind(ClientContext &context, TableFunctionBindInput &input,\n-                                                vector<LogicalType> &return_types, vector<string> &names) {\n-\tnames.emplace_back(\"name\");\n-\treturn_types.emplace_back(LogicalType::VARCHAR);\n-\tnames.emplace_back(\"abbrev\");\n-\treturn_types.emplace_back(LogicalType::VARCHAR);\n-\tnames.emplace_back(\"utc_offset\");\n-\treturn_types.emplace_back(LogicalType::INTERVAL);\n-\tnames.emplace_back(\"is_dst\");\n-\treturn_types.emplace_back(LogicalType::BOOLEAN);\n-\n-\treturn nullptr;\n-}\n-\n-static unique_ptr<GlobalTableFunctionState> ICUTimeZoneInit(ClientContext &context, TableFunctionInitInput &input) {\n-\treturn make_unique<ICUTimeZoneData>();\n-}\n-\n-static void ICUTimeZoneFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {\n-\tauto &data = (ICUTimeZoneData &)*data_p.global_state;\n-\tidx_t index = 0;\n-\twhile (index < STANDARD_VECTOR_SIZE) {\n-\t\tUErrorCode status = U_ZERO_ERROR;\n-\t\tauto long_id = data.tzs->snext(status);\n-\t\tif (U_FAILURE(status) || !long_id) {\n-\t\t\tbreak;\n-\t\t}\n-\n-\t\t//\tThe LONG name is the one we looked up\n-\t\tstd::string utf8;\n-\t\tlong_id->toUTF8String(utf8);\n-\t\toutput.SetValue(0, index, Value(utf8));\n-\n-\t\t//\tWe don't have the zone tree for determining abbreviated names,\n-\t\t//\tso the SHORT name is the shortest, lexicographically first equivalent TZ without a slash.\n-\t\tstd::string short_id;\n-\t\tlong_id->toUTF8String(short_id);\n-\t\tconst auto nIDs = icu::TimeZone::countEquivalentIDs(*long_id);\n-\t\tfor (int32_t idx = 0; idx < nIDs; ++idx) {\n-\t\t\tconst auto eid = icu::TimeZone::getEquivalentID(*long_id, idx);\n-\t\t\tif (eid.indexOf(char16_t('/')) >= 0) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tutf8.clear();\n-\t\t\teid.toUTF8String(utf8);\n-\t\t\tif (utf8.size() < short_id.size() || (utf8.size() == short_id.size() && utf8 < short_id)) {\n-\t\t\t\tshort_id = utf8;\n-\t\t\t}\n-\t\t}\n-\t\toutput.SetValue(1, index, Value(short_id));\n-\n-\t\tstd::unique_ptr<icu::TimeZone> tz(icu::TimeZone::createTimeZone(*long_id));\n-\t\tint32_t raw_offset_ms;\n-\t\tint32_t dst_offset_ms;\n-\t\ttz->getOffset(data.now, false, raw_offset_ms, dst_offset_ms, status);\n-\t\tif (U_FAILURE(status)) {\n-\t\t\tbreak;\n-\t\t}\n-\n-\t\toutput.SetValue(2, index, Value::INTERVAL(Interval::FromMicro(raw_offset_ms * Interval::MICROS_PER_MSEC)));\n-\t\toutput.SetValue(3, index, Value(dst_offset_ms != 0));\n-\t\t++index;\n-\t}\n-\toutput.SetCardinality(index);\n-}\n-\n struct ICUCalendarData : public GlobalTableFunctionState {\n \tICUCalendarData() {\n \t\t// All calendars are available in all locales\n@@ -336,16 +260,13 @@ void ICUExtension::Load(DuckDB &db) {\n \ttz->getID(tz_id).toUTF8String(tz_string);\n \tconfig.options.set_variables[\"TimeZone\"] = Value(tz_string);\n \n-\tTableFunction tz_names(\"pg_timezone_names\", {}, ICUTimeZoneFunction, ICUTimeZoneBind, ICUTimeZoneInit);\n-\tCreateTableFunctionInfo tz_names_info(move(tz_names));\n-\tcatalog.CreateTableFunction(*con.context, &tz_names_info);\n-\n \tRegisterICUDateAddFunctions(*con.context);\n \tRegisterICUDatePartFunctions(*con.context);\n \tRegisterICUDateSubFunctions(*con.context);\n \tRegisterICUDateTruncFunctions(*con.context);\n \tRegisterICUMakeDateFunctions(*con.context);\n \tRegisterICUStrptimeFunctions(*con.context);\n+\tRegisterICUTimeZoneFunctions(*con.context);\n \n \t// Calendars\n \tconfig.AddExtensionOption(\"Calendar\", \"The current calendar\", LogicalType::VARCHAR, SetICUCalendar);\ndiff --git a/extension/icu/icu-timezone.cpp b/extension/icu/icu-timezone.cpp\nnew file mode 100644\nindex 000000000000..da4903f56f54\n--- /dev/null\n+++ b/extension/icu/icu-timezone.cpp\n@@ -0,0 +1,211 @@\n+#include \"duckdb/common/types/date.hpp\"\n+#include \"duckdb/common/types/time.hpp\"\n+#include \"duckdb/common/types/timestamp.hpp\"\n+#include \"duckdb/parser/parsed_data/create_scalar_function_info.hpp\"\n+#include \"duckdb/parser/parsed_data/create_table_function_info.hpp\"\n+#include \"include/icu-datefunc.hpp\"\n+\n+namespace duckdb {\n+\n+struct ICUTimeZoneData : public GlobalTableFunctionState {\n+\tICUTimeZoneData() : tzs(icu::TimeZone::createEnumeration()) {\n+\t\tUErrorCode status = U_ZERO_ERROR;\n+\t\tstd::unique_ptr<icu::Calendar> calendar(icu::Calendar::createInstance(status));\n+\t\tnow = calendar->getNow();\n+\t}\n+\n+\tstd::unique_ptr<icu::StringEnumeration> tzs;\n+\tUDate now;\n+};\n+\n+static unique_ptr<FunctionData> ICUTimeZoneBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                vector<LogicalType> &return_types, vector<string> &names) {\n+\tnames.emplace_back(\"name\");\n+\treturn_types.emplace_back(LogicalType::VARCHAR);\n+\tnames.emplace_back(\"abbrev\");\n+\treturn_types.emplace_back(LogicalType::VARCHAR);\n+\tnames.emplace_back(\"utc_offset\");\n+\treturn_types.emplace_back(LogicalType::INTERVAL);\n+\tnames.emplace_back(\"is_dst\");\n+\treturn_types.emplace_back(LogicalType::BOOLEAN);\n+\n+\treturn nullptr;\n+}\n+\n+static unique_ptr<GlobalTableFunctionState> ICUTimeZoneInit(ClientContext &context, TableFunctionInitInput &input) {\n+\treturn make_unique<ICUTimeZoneData>();\n+}\n+\n+static void ICUTimeZoneFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {\n+\tauto &data = (ICUTimeZoneData &)*data_p.global_state;\n+\tidx_t index = 0;\n+\twhile (index < STANDARD_VECTOR_SIZE) {\n+\t\tUErrorCode status = U_ZERO_ERROR;\n+\t\tauto long_id = data.tzs->snext(status);\n+\t\tif (U_FAILURE(status) || !long_id) {\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t//\tThe LONG name is the one we looked up\n+\t\tstd::string utf8;\n+\t\tlong_id->toUTF8String(utf8);\n+\t\toutput.SetValue(0, index, Value(utf8));\n+\n+\t\t//\tWe don't have the zone tree for determining abbreviated names,\n+\t\t//\tso the SHORT name is the shortest, lexicographically first equivalent TZ without a slash.\n+\t\tstd::string short_id;\n+\t\tlong_id->toUTF8String(short_id);\n+\t\tconst auto nIDs = icu::TimeZone::countEquivalentIDs(*long_id);\n+\t\tfor (int32_t idx = 0; idx < nIDs; ++idx) {\n+\t\t\tconst auto eid = icu::TimeZone::getEquivalentID(*long_id, idx);\n+\t\t\tif (eid.indexOf(char16_t('/')) >= 0) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tutf8.clear();\n+\t\t\teid.toUTF8String(utf8);\n+\t\t\tif (utf8.size() < short_id.size() || (utf8.size() == short_id.size() && utf8 < short_id)) {\n+\t\t\t\tshort_id = utf8;\n+\t\t\t}\n+\t\t}\n+\t\toutput.SetValue(1, index, Value(short_id));\n+\n+\t\tstd::unique_ptr<icu::TimeZone> tz(icu::TimeZone::createTimeZone(*long_id));\n+\t\tint32_t raw_offset_ms;\n+\t\tint32_t dst_offset_ms;\n+\t\ttz->getOffset(data.now, false, raw_offset_ms, dst_offset_ms, status);\n+\t\tif (U_FAILURE(status)) {\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\toutput.SetValue(2, index, Value::INTERVAL(Interval::FromMicro(raw_offset_ms * Interval::MICROS_PER_MSEC)));\n+\t\toutput.SetValue(3, index, Value(dst_offset_ms != 0));\n+\t\t++index;\n+\t}\n+\toutput.SetCardinality(index);\n+}\n+\n+struct ICUFromLocalTime : public ICUDateFunc {\n+\tstatic inline timestamp_t Operation(icu::Calendar *calendar, timestamp_t local) {\n+\t\t// Extract the parts from the \"instant\"\n+\t\tdate_t local_date;\n+\t\tdtime_t local_time;\n+\t\tTimestamp::Convert(local, local_date, local_time);\n+\n+\t\tint32_t year;\n+\t\tint32_t mm;\n+\t\tint32_t dd;\n+\t\tDate::Convert(local_date, year, mm, dd);\n+\n+\t\tint32_t hr;\n+\t\tint32_t mn;\n+\t\tint32_t secs;\n+\t\tint32_t frac;\n+\t\tTime::Convert(local_time, hr, mn, secs, frac);\n+\t\tint32_t millis = frac / Interval::MICROS_PER_MSEC;\n+\t\tuint64_t micros = frac % Interval::MICROS_PER_MSEC;\n+\n+\t\t// Use them to set the time in the time zone\n+\t\tcalendar->set(UCAL_YEAR, year);\n+\t\tcalendar->set(UCAL_MONTH, int32_t(mm - 1));\n+\t\tcalendar->set(UCAL_DATE, dd);\n+\t\tcalendar->set(UCAL_HOUR_OF_DAY, hr);\n+\t\tcalendar->set(UCAL_MINUTE, mn);\n+\t\tcalendar->set(UCAL_SECOND, secs);\n+\t\tcalendar->set(UCAL_MILLISECOND, millis);\n+\n+\t\treturn GetTime(calendar, micros);\n+\t}\n+};\n+\n+struct ICUToLocalTime : public ICUDateFunc {\n+\tstatic inline timestamp_t Operation(icu::Calendar *calendar, timestamp_t instant) {\n+\t\t// Extract the time zone parts\n+\t\tauto micros = SetTime(calendar, instant);\n+\t\tconst auto year = ExtractField(calendar, UCAL_YEAR);\n+\t\tconst auto mm = ExtractField(calendar, UCAL_MONTH) + 1;\n+\t\tconst auto dd = ExtractField(calendar, UCAL_DATE);\n+\n+\t\tdate_t local_date;\n+\t\tif (!Date::TryFromDate(year, mm, dd, local_date)) {\n+\t\t\tthrow ConversionException(\"Unable to create local date in TIMEZONE function\");\n+\t\t}\n+\n+\t\tconst auto hr = ExtractField(calendar, UCAL_HOUR_OF_DAY);\n+\t\tconst auto mn = ExtractField(calendar, UCAL_MINUTE);\n+\t\tconst auto secs = ExtractField(calendar, UCAL_SECOND);\n+\t\tconst auto millis = ExtractField(calendar, UCAL_MILLISECOND);\n+\n+\t\tmicros += millis * Interval::MICROS_PER_MSEC;\n+\t\tdtime_t local_time = Time::FromTime(hr, mn, secs, micros);\n+\n+\t\ttimestamp_t result;\n+\t\tif (!Timestamp::TryFromDatetime(local_date, local_time, result)) {\n+\t\t\tthrow ConversionException(\"Unable to create local timestamp in TIMEZONE function\");\n+\t\t}\n+\n+\t\treturn result;\n+\t}\n+};\n+\n+struct ICUTimeZoneFunc : public ICUDateFunc {\n+\ttemplate <typename OP>\n+\tstatic void Execute(DataChunk &input, ExpressionState &state, Vector &result) {\n+\t\tauto &func_expr = (BoundFunctionExpression &)state.expr;\n+\t\tauto &info = (BindData &)*func_expr.bind_info;\n+\t\tCalendarPtr calendar_ptr(info.calendar->clone());\n+\t\tauto calendar = calendar_ptr.get();\n+\n+\t\t// Two cases: constant TZ, variable TZ\n+\t\tD_ASSERT(input.ColumnCount() == 2);\n+\t\tauto &tz_vec = input.data[0];\n+\t\tauto &ts_vec = input.data[1];\n+\t\tif (tz_vec.GetVectorType() == VectorType::CONSTANT_VECTOR) {\n+\t\t\tif (ConstantVector::IsNull(tz_vec)) {\n+\t\t\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\t\t\t\tConstantVector::SetNull(result, true);\n+\t\t\t} else {\n+\t\t\t\tSetTimeZone(calendar, *ConstantVector::GetData<string_t>(tz_vec));\n+\t\t\t\tUnaryExecutor::Execute<timestamp_t, timestamp_t>(ts_vec, result, input.size(), [&](timestamp_t ts) {\n+\t\t\t\t\tif (Timestamp::IsFinite(ts)) {\n+\t\t\t\t\t\treturn OP::Operation(calendar, ts);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn ts;\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t\t}\n+\t\t} else {\n+\t\t\tBinaryExecutor::Execute<string_t, timestamp_t, timestamp_t>(tz_vec, ts_vec, result, input.size(),\n+\t\t\t                                                            [&](string_t tz_id, timestamp_t ts) {\n+\t\t\t\t                                                            if (Timestamp::IsFinite(ts)) {\n+\t\t\t\t\t                                                            SetTimeZone(calendar, tz_id);\n+\t\t\t\t\t                                                            return OP::Operation(calendar, ts);\n+\t\t\t\t                                                            } else {\n+\t\t\t\t\t                                                            return ts;\n+\t\t\t\t                                                            }\n+\t\t\t                                                            });\n+\t\t}\n+\t}\n+\n+\tstatic void AddFunction(const string &name, ClientContext &context) {\n+\t\tScalarFunctionSet set(name);\n+\t\tset.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::TIMESTAMP}, LogicalType::TIMESTAMP_TZ,\n+\t\t                               Execute<ICUFromLocalTime>, Bind));\n+\t\tset.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::TIMESTAMP_TZ}, LogicalType::TIMESTAMP,\n+\t\t                               Execute<ICUToLocalTime>, Bind));\n+\n+\t\tCreateScalarFunctionInfo func_info(set);\n+\t\tauto &catalog = Catalog::GetCatalog(context);\n+\t\tcatalog.AddFunction(context, &func_info);\n+\t}\n+};\n+\n+void RegisterICUTimeZoneFunctions(ClientContext &context) {\n+\tauto &catalog = Catalog::GetCatalog(context);\n+\tTableFunction tz_names(\"pg_timezone_names\", {}, ICUTimeZoneFunction, ICUTimeZoneBind, ICUTimeZoneInit);\n+\tCreateTableFunctionInfo tz_names_info(move(tz_names));\n+\tcatalog.CreateTableFunction(context, &tz_names_info);\n+\n+\tICUTimeZoneFunc::AddFunction(\"timezone\", context);\n+}\n+\n+} // namespace duckdb\ndiff --git a/extension/icu/include/icu-timezone.hpp b/extension/icu/include/icu-timezone.hpp\nnew file mode 100644\nindex 000000000000..fa7312d73bfd\n--- /dev/null\n+++ b/extension/icu/include/icu-timezone.hpp\n@@ -0,0 +1,17 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// icu-makedate.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb.hpp\"\n+\n+namespace duckdb {\n+\n+void RegisterICUTimeZoneFunctions(ClientContext &context);\n+\n+} // namespace duckdb\ndiff --git a/src/function/scalar/date/date_part.cpp b/src/function/scalar/date/date_part.cpp\nindex c400fc72f863..4f5fd859679c 100644\n--- a/src/function/scalar/date/date_part.cpp\n+++ b/src/function/scalar/date/date_part.cpp\n@@ -1420,16 +1420,16 @@ struct StructDatePart {\n \t\t\t\tconst auto idx = rdata.sel->get_index(i);\n \t\t\t\tif (arg_valid.RowIsValid(idx)) {\n \t\t\t\t\tif (Value::IsFinite(tdata[idx])) {\n-\t\t\t\t\t\tDatePart::StructOperator::Operation(part_values.data(), tdata[idx], idx, part_mask);\n+\t\t\t\t\t\tDatePart::StructOperator::Operation(part_values.data(), tdata[idx], i, part_mask);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tfor (auto &child_entry : child_entries) {\n-\t\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetInvalid(idx);\n+\t\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetInvalid(i);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tres_valid.SetInvalid(idx);\n+\t\t\t\t\tres_valid.SetInvalid(i);\n \t\t\t\t\tfor (auto &child_entry : child_entries) {\n-\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetInvalid(idx);\n+\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetInvalid(i);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\ndiff --git a/tools/juliapkg/Project.toml b/tools/juliapkg/Project.toml\nindex d0fe36198e91..ff3ec40f1620 100644\n--- a/tools/juliapkg/Project.toml\n+++ b/tools/juliapkg/Project.toml\n@@ -1,7 +1,7 @@\n name = \"DuckDB\"\n uuid = \"d2f5444f-75bc-4fdf-ac35-56f514c445e1\"\n authors = [\"Mark Raasveldt <mark@duckdblabs.com\", \"Hannes M\u00fchleisen <hannes@duckdblabs.com>\"]\n-version = \"0.5.1\"\n+version = \"0.6.0\"\n \n [deps]\n DBInterface = \"a10d1c49-ce27-4219-8d33-6db1a4562965\"\n@@ -16,7 +16,7 @@ WeakRefStrings = \"ea10d353-3f73-51f8-a26c-33c1cb351aa5\"\n [compat]\n DBInterface = \"2.5\"\n DataFrames = \"1.3\"\n-DuckDB_jll = \"0.5.1\"\n+DuckDB_jll = \"0.6.0\"\n FixedPointDecimals = \"0.4\"\n julia = \"1.6\"\n Tables = \"1.7\"\ndiff --git a/tools/juliapkg/src/old_interface.jl b/tools/juliapkg/src/old_interface.jl\nindex 18cd8661ed91..a11a88609b91 100644\n--- a/tools/juliapkg/src/old_interface.jl\n+++ b/tools/juliapkg/src/old_interface.jl\n@@ -21,11 +21,11 @@ appendDataFrame(input_df::DataFrame, db::DB, table::AbstractString, schema::Stri\n     appendDataFrame(input_df, db.main_connection, table, schema)\n \n \"\"\"\n-    DuckDB.load!(input_df::DataFrame, con, table)\n+    DuckDB.load!(con, input_df, table)\n \n-Load an input DataFrame `input_df` into a DuckDB table that will be named `table`.\n+Load an input DataFrame `input_df` into a new DuckDB table that will be named `table`.\n \"\"\"\n-function load!(con::Connection, input_df::DataFrame, table::AbstractString, schema::String = \"main\")\n+function load!(con, input_df::DataFrame, table::AbstractString, schema::String = \"main\")\n     register_data_frame(con, input_df, \"__append_df\")\n     DBInterface.execute(con, \"CREATE TABLE \\\"$schema\\\".\\\"$table\\\" AS SELECT * FROM __append_df\")\n     unregister_data_frame(con, \"__append_df\")\n",
  "test_patch": "diff --git a/test/sql/copy/csv/auto/test_csv_auto.test b/test/sql/copy/csv/auto/test_csv_auto.test\nindex 21618919091c..ba6e19e7ff42 100644\n--- a/test/sql/copy/csv/auto/test_csv_auto.test\n+++ b/test/sql/copy/csv/auto/test_csv_auto.test\n@@ -6,7 +6,7 @@ require vector_size 512\n \n \n statement ok\n-SET experimental_parallel_csv=true;\n+SET experimental_parallel_csv=false;\n \n \n # CSV file with RFC-conform dialect\n@@ -230,4 +230,4 @@ SELECT a, b FROM test;\n 1\t2\n \n statement ok\n-DROP TABLE test;\n\\ No newline at end of file\n+DROP TABLE test;\ndiff --git a/test/sql/function/date/test_date_part.test b/test/sql/function/date/test_date_part.test\nindex d35b7b62d019..7f8f90af1890 100644\n--- a/test/sql/function/date/test_date_part.test\n+++ b/test/sql/function/date/test_date_part.test\n@@ -455,6 +455,15 @@ NULL\tNULL\n 2022-01-01\t{'isoyear': 2021, 'week': 52, 'yearweek': 202152}\n infinity\t{'isoyear': NULL, 'week': NULL, 'yearweek': NULL}\n \n+# Selective filtering (Issue #5342)\n+query II\n+SELECT d, DATE_PART(['year', 'month', 'day'], d) AS parts\n+FROM dates\n+WHERE s = 'day'\n+ORDER BY 1;\n+----\n+1992-05-05\t{'year': 1992, 'month': 5, 'day': 5}\n+\n # Invalid parts\n \n foreach hour minute second millisecond microsecond timezone timezone_hour timezone_minute\ndiff --git a/test/sql/function/timestamp/test_icu_datepart.test b/test/sql/function/timestamp/test_icu_datepart.test\nindex 71fce4c4281c..aa34c7e6b961 100644\n--- a/test/sql/function/timestamp/test_icu_datepart.test\n+++ b/test/sql/function/timestamp/test_icu_datepart.test\n@@ -628,6 +628,15 @@ WHERE p IS DISTINCT FROM s['${partcode}'];\n \n endloop\n \n+# Selective filtering (Issue #5342)\n+query II\n+SELECT ts, DATE_PART(['year', 'month', 'day'], ts) AS parts\n+FROM timestamps\n+WHERE part = 'day'\n+ORDER BY 1;\n+----\n+2021-12-24 14:00:00-08\t{'year': 2021, 'month': 12, 'day': 24}\n+\n # Invalid parts\n statement error\n SELECT DATE_PART(['duck', 'minute', 'microsecond', 'timezone'], ts), ts\ndiff --git a/test/sql/timezone/test_icu_timezone.test b/test/sql/timezone/test_icu_timezone.test\nindex 2886fd574a41..4864e77e65de 100644\n--- a/test/sql/timezone/test_icu_timezone.test\n+++ b/test/sql/timezone/test_icu_timezone.test\n@@ -7,6 +7,9 @@ require icu\n statement ok\n SET Calendar = 'gregorian';\n \n+statement error\n+SET TimeZone = 'Europe/Duck';\n+\n statement ok\n SET TimeZone = 'America/Los_Angeles';\n \n@@ -15,9 +18,137 @@ SELECT * FROM duckdb_settings() WHERE name = 'TimeZone';\n ----\n TimeZone\tAmerica/Los_Angeles\tThe current time zone\tVARCHAR\n \n-statement error\n-SET TimeZone = 'fnord';\n+#\n+# AT TIME ZONE\n+#\n+\n+# Single row\n+query I\n+SELECT  '2001-02-16 20:38:40'::TIMESTAMP AT TIME ZONE 'America/Denver';\n+----\n+2001-02-16 19:38:40-08\n+\n+query I\n+SELECT '2001-02-16 20:38:40-05'::TIMESTAMPTZ AT TIME ZONE 'America/Denver';\n+----\n+2001-02-16 18:38:40\n+\n+# Invalid time zone\n+# (ICU treats thesed as UTC.)\n+query I\n+SELECT  '2001-02-16 20:38:40'::TIMESTAMP AT TIME ZONE 'Europe/Duck';\n+----\n+2001-02-16 12:38:40-08\n+\n+query I\n+SELECT '2001-02-16 20:38:40-05'::TIMESTAMPTZ AT TIME ZONE 'Europe/Duck';\n+----\n+2001-02-17 01:38:40\n+\n+# Infinities\n+foreach datatype TIMESTAMP TIMESTAMPTZ\n+\n+query I\n+SELECT 'infinity'::${datatype} AT TIME ZONE 'America/Denver';\n+----\n+infinity\n+\n+query I\n+SELECT '-infinity'::${datatype} AT TIME ZONE 'America/Denver';\n+----\n+-infinity\n+\n+query I\n+SELECT 'infinity'::${datatype} AT TIME ZONE 'Europe/Duck';\n+----\n+infinity\n \n+query I\n+SELECT '-infinity'::${datatype} AT TIME ZONE 'Europe/Duck';\n+----\n+-infinity\n+\n+endloop\n+\n+# NULLs\n+query I\n+SELECT  NULL::TIMESTAMP AT TIME ZONE 'America/Denver';\n+----\n+NULL\n+\n+query I\n+SELECT NULL::TIMESTAMPTZ AT TIME ZONE 'America/Denver';\n+----\n+NULL\n+\n+query I\n+SELECT  '2001-02-16 20:38:40'::TIMESTAMP AT TIME ZONE NULL;\n+----\n+NULL\n+\n+query I\n+SELECT '2001-02-16 20:38:40-05'::TIMESTAMPTZ AT TIME ZONE NULL;\n+----\n+NULL\n+\n+# Table\n+statement ok\n+CREATE TABLE attimezone (ts TIMESTAMP, tstz TIMESTAMPTZ, tz VARCHAR);\n+\n+statement ok\n+INSERT INTO attimezone (VALUES\n+\t('2001-02-16 20:38:40', '2001-02-16 19:38:40-08', 'America/Denver'),\n+\t('2001-02-16 18:38:40', '2001-02-16 20:38:40-05', 'America/Denver'),\n+\t('infinity', 'infinity', 'America/Denver'),\n+\t('-infinity', '-infinity', 'America/Denver'),\n+\t(NULL, NULL, 'America/Denver'),\n+\t('2001-02-16 20:38:40', '2001-02-16 19:38:40-08', 'Europe/Duck'),\n+\t('2001-02-16 18:38:40', '2001-02-16 20:38:40-05', 'Europe/Duck'),\n+\t('infinity', 'infinity', 'Europe/Duck'),\n+\t('-infinity', '-infinity', 'Europe/Duck'),\n+\t(NULL, NULL, 'Europe/Duck'),\n+\t('2001-02-16 20:38:40', '2001-02-16 19:38:40-08', NULL),\n+\t('2001-02-16 18:38:40', '2001-02-16 20:38:40-05', NULL),\n+\t('infinity', 'infinity', NULL),\n+\t('-infinity', '-infinity', NULL),\n+);\n+\n+# By Row\n+query II\n+SELECT ts AT TIME ZONE tz, tstz AT TIME ZONE tz\n+FROM attimezone\n+----\n+2001-02-16 19:38:40-08\t2001-02-16 20:38:40\n+2001-02-16 17:38:40-08\t2001-02-16 18:38:40\n+infinity\tinfinity\n+-infinity\t-infinity\n+NULL\tNULL\n+2001-02-16 12:38:40-08\t2001-02-17 03:38:40\n+2001-02-16 10:38:40-08\t2001-02-17 01:38:40\n+infinity\tinfinity\n+-infinity\t-infinity\n+NULL\tNULL\n+NULL\tNULL\n+NULL\tNULL\n+NULL\tNULL\n+NULL\tNULL\n+\n+# Filtered\n+query II\n+SELECT ts AT TIME ZONE tz, tstz AT TIME ZONE tz\n+FROM attimezone\n+WHERE ts > '2001-02-16 18:38:40'::TIMESTAMP\n+----\n+2001-02-16 19:38:40-08\t2001-02-16 20:38:40\n+infinity\tinfinity\n+2001-02-16 12:38:40-08\t2001-02-17 03:38:40\n+infinity\tinfinity\n+NULL\tNULL\n+NULL\tNULL\n+\n+#\n+# ICU time zone list\n+#\n query III\n SELECT name, abbrev, utc_offset FROM pg_timezone_names() ORDER BY name;\n ----\n@@ -658,6 +789,12 @@ W-SU\tW-SU\t03:00:00\n WET\tWET\t00:00:00\n Zulu\tUCT\t00:00:00\n \n+#\n+# Time Zone Rule updates\n+#\n+# These are conventionally named YYYYx, where x is a lower case letter.\n+#\n+\n # 2022e\n # Jordan and Syria are abandoning the DST regime and are changing to\n # permanent +03, so they will not fall back from +03 to +02 on\n",
  "problem_statement": "Implement the Postgres timezone function\nThe [timezone function](https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT) is what the syntactic sugar of `AT TIME ZONE` translates to but we have not implemented it:\r\n\r\n```sql\r\nselect now() at time zone 'europe/london' as start_time;\r\nError: Binder Error: No function matches the given name and argument types 'timezone(VARCHAR, TIMESTAMP)'. You might need to add explicit type casts.\r\n    Candidate functions:\r\n    timezone(TIMESTAMP WITH TIME ZONE) -> BIGINT\r\n    timezone(DATE) -> BIGINT\r\n    timezone(TIMESTAMP) -> BIGINT\r\n    timezone(INTERVAL) -> BIGINT\r\n```\r\n\r\nWhat it seems to do is either a) reinterpret a `TIMESTAMP`'s (UTC) bin values as values in the given zone and use them to produce a `TIMESTAMPTZ` or b) produce a TIMESTAMP whose (UTC) bin values are the same as the bin values of the `TIMESTAMPTZ`'s in the given zone.\r\n\r\nBasically, it is a mechanism for encoding local time into instants. Which is sketchy but not hard to implement in ICU.\r\n\n",
  "hints_text": "I just noticed that we have this function, but it takes one argument and extracts the time zone value (like `year`). the PG API is a two argument function, starting with a `VARCHAR`.",
  "created_at": "2022-11-14T19:17:48Z"
}