{
  "repo": "duckdb/duckdb",
  "pull_number": 15226,
  "instance_id": "duckdb__duckdb-15226",
  "issue_numbers": [
    "15198",
    "15198"
  ],
  "base_commit": "7d7b085126df360f6595667f792df5a9f9b21c5e",
  "patch": "diff --git a/src/execution/expression_executor/execute_cast.cpp b/src/execution/expression_executor/execute_cast.cpp\nindex c0cca5889084..eb3a93fc4bce 100644\n--- a/src/execution/expression_executor/execute_cast.cpp\n+++ b/src/execution/expression_executor/execute_cast.cpp\n@@ -12,7 +12,8 @@ unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const BoundCastE\n \tresult->Finalize();\n \n \tif (expr.bound_cast.init_local_state) {\n-\t\tCastLocalStateParameters parameters(root.executor->GetContext(), expr.bound_cast.cast_data);\n+\t\tauto context_ptr = root.executor->HasContext() ? &root.executor->GetContext() : nullptr;\n+\t\tCastLocalStateParameters parameters(context_ptr, expr.bound_cast.cast_data);\n \t\tresult->local_state = expr.bound_cast.init_local_state(parameters);\n \t}\n \treturn std::move(result);\ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 7da3b6c5d87f..0cd7c0e6a803 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -213,6 +213,8 @@ class Binder : public enable_shared_from_this<Binder> {\n \tCatalogEntryRetriever &EntryRetriever() {\n \t\treturn entry_retriever;\n \t}\n+\t//! Returns a ColumnRefExpression after it was resolved (i.e. past the STAR expression/USING clauses)\n+\tstatic optional_ptr<ParsedExpression> GetResolvedColumnExpression(ParsedExpression &root_expr);\n \n \tvoid SetCanContainNulls(bool can_contain_nulls);\n \tvoid SetAlwaysRequireRebind();\ndiff --git a/src/planner/bind_context.cpp b/src/planner/bind_context.cpp\nindex 5b4c3a10907c..bb7786f9360c 100644\n--- a/src/planner/bind_context.cpp\n+++ b/src/planner/bind_context.cpp\n@@ -718,6 +718,25 @@ vector<BindingAlias> BindContext::GetBindingAliases() {\n \n void BindContext::RemoveContext(const vector<BindingAlias> &aliases) {\n \tfor (auto &alias : aliases) {\n+\t\t// remove the binding from any USING columns\n+\t\tfor (auto &using_sets : using_columns) {\n+\t\t\tfor (auto &using_set_ref : using_sets.second) {\n+\t\t\t\tauto &using_set = using_set_ref.get();\n+\t\t\t\tauto it = std::remove_if(using_set.bindings.begin(), using_set.bindings.end(),\n+\t\t\t\t                         [&](const BindingAlias &using_alias) { return using_alias == alias; });\n+\t\t\t\tusing_set.bindings.erase(it, using_set.bindings.end());\n+\t\t\t\tif (using_set.bindings.empty()) {\n+\t\t\t\t\tthrow InternalException(\n+\t\t\t\t\t    \"BindContext::RemoveContext - no more tables that refer to this using binding\");\n+\t\t\t\t}\n+\t\t\t\tif (using_set.primary_binding == alias) {\n+\t\t\t\t\tthrow InternalException(\n+\t\t\t\t\t    \"BindContext::RemoveContext - cannot remove primary binding from using binding\");\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// remove the binding from the list of bindings\n \t\tauto it = std::remove_if(bindings_list.begin(), bindings_list.end(),\n \t\t                         [&](unique_ptr<Binding> &x) { return x->alias == alias; });\n \t\tbindings_list.erase(it, bindings_list.end());\ndiff --git a/src/planner/binder/expression/bind_star_expression.cpp b/src/planner/binder/expression/bind_star_expression.cpp\nindex ddf7dd5baae6..2a15d0c8d4ad 100644\n--- a/src/planner/binder/expression/bind_star_expression.cpp\n+++ b/src/planner/binder/expression/bind_star_expression.cpp\n@@ -185,6 +185,22 @@ void TryTransformStarLike(unique_ptr<ParsedExpression> &root) {\n \troot = std::move(columns_expr);\n }\n \n+optional_ptr<ParsedExpression> Binder::GetResolvedColumnExpression(ParsedExpression &root_expr) {\n+\toptional_ptr<ParsedExpression> expr = &root_expr;\n+\twhile (expr) {\n+\t\tif (expr->type == ExpressionType::COLUMN_REF) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tif (expr->type == ExpressionType::OPERATOR_COALESCE) {\n+\t\t\texpr = expr->Cast<OperatorExpression>().children[0].get();\n+\t\t} else {\n+\t\t\t// unknown expression\n+\t\t\treturn nullptr;\n+\t\t}\n+\t}\n+\treturn expr;\n+}\n+\n void Binder::ExpandStarExpression(unique_ptr<ParsedExpression> expr,\n                                   vector<unique_ptr<ParsedExpression>> &new_select_list) {\n \tTryTransformStarLike(expr);\n@@ -232,7 +248,11 @@ void Binder::ExpandStarExpression(unique_ptr<ParsedExpression> expr,\n \t\t\t}\n \t\t\tvector<unique_ptr<ParsedExpression>> new_list;\n \t\t\tfor (idx_t i = 0; i < star_list.size(); i++) {\n-\t\t\t\tauto &colref = star_list[i]->Cast<ColumnRefExpression>();\n+\t\t\t\tauto child_expr = GetResolvedColumnExpression(*star_list[i]);\n+\t\t\t\tif (!child_expr) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tauto &colref = child_expr->Cast<ColumnRefExpression>();\n \t\t\t\tif (!RE2::PartialMatch(colref.GetColumnName(), *regex)) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n@@ -297,18 +317,7 @@ void Binder::ExpandStarExpression(unique_ptr<ParsedExpression> expr,\n \t\tauto new_expr = expr->Copy();\n \t\tReplaceStarExpression(new_expr, star_list[i]);\n \t\tif (StarExpression::IsColumns(*star)) {\n-\t\t\toptional_ptr<ParsedExpression> expr = star_list[i].get();\n-\t\t\twhile (expr) {\n-\t\t\t\tif (expr->type == ExpressionType::COLUMN_REF) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (expr->type == ExpressionType::OPERATOR_COALESCE) {\n-\t\t\t\t\texpr = expr->Cast<OperatorExpression>().children[0].get();\n-\t\t\t\t} else {\n-\t\t\t\t\t// unknown expression\n-\t\t\t\t\texpr = nullptr;\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tauto expr = GetResolvedColumnExpression(*star_list[i]);\n \t\t\tif (expr) {\n \t\t\t\tauto &colref = expr->Cast<ColumnRefExpression>();\n \t\t\t\tif (new_expr->alias.empty()) {\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex ea16c02045ac..590da7ae4ba9 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -310,7 +310,6 @@ void Binder::BindModifiers(BoundQueryNode &result, idx_t table_index, const vect\n \t\tswitch (bound_mod->type) {\n \t\tcase ResultModifierType::DISTINCT_MODIFIER: {\n \t\t\tauto &distinct = bound_mod->Cast<BoundDistinctModifier>();\n-\t\t\tD_ASSERT(!distinct.target_distincts.empty());\n \t\t\t// set types of distinct targets\n \t\t\tfor (auto &expr : distinct.target_distincts) {\n \t\t\t\texpr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);\ndiff --git a/src/planner/binder/query_node/plan_query_node.cpp b/src/planner/binder/query_node/plan_query_node.cpp\nindex 97678d2271e0..c448f2f111a9 100644\n--- a/src/planner/binder/query_node/plan_query_node.cpp\n+++ b/src/planner/binder/query_node/plan_query_node.cpp\n@@ -13,6 +13,9 @@ unique_ptr<LogicalOperator> Binder::VisitQueryNode(BoundQueryNode &node, unique_\n \t\tswitch (mod->type) {\n \t\tcase ResultModifierType::DISTINCT_MODIFIER: {\n \t\t\tauto &bound = mod->Cast<BoundDistinctModifier>();\n+\t\t\tif (bound.target_distincts.empty()) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\tauto distinct = make_uniq<LogicalDistinct>(std::move(bound.target_distincts), bound.distinct_type);\n \t\t\tdistinct->AddChild(std::move(root));\n \t\t\troot = std::move(distinct);\ndiff --git a/src/planner/binder/statement/bind_insert.cpp b/src/planner/binder/statement/bind_insert.cpp\nindex 509b3d2a26c0..5e3903049414 100644\n--- a/src/planner/binder/statement/bind_insert.cpp\n+++ b/src/planner/binder/statement/bind_insert.cpp\n@@ -148,7 +148,6 @@ void ReplaceColumnBindings(Expression &expr, idx_t source, idx_t dest) {\n void Binder::BindDoUpdateSetExpressions(const string &table_alias, LogicalInsert &insert, UpdateSetInfo &set_info,\n                                         TableCatalogEntry &table, TableStorageInfo &storage_info) {\n \tD_ASSERT(insert.children.size() == 1);\n-\tD_ASSERT(insert.children[0]->type == LogicalOperatorType::LOGICAL_PROJECTION);\n \n \tvector<column_t> logical_column_ids;\n \tvector<string> column_names;\n@@ -495,6 +494,9 @@ BoundStatement Binder::Bind(InsertStatement &stmt) {\n \t\tif (values_list) {\n \t\t\tthrow BinderException(\"INSERT BY NAME can only be used when inserting from a SELECT statement\");\n \t\t}\n+\t\tif (stmt.default_values) {\n+\t\t\tthrow BinderException(\"INSERT BY NAME cannot be combined with with DEFAULT VALUES\");\n+\t\t}\n \t\tif (!stmt.columns.empty()) {\n \t\t\tthrow BinderException(\"INSERT BY NAME cannot be combined with an explicit column list\");\n \t\t}\ndiff --git a/src/planner/binder/tableref/bind_pivot.cpp b/src/planner/binder/tableref/bind_pivot.cpp\nindex e673c6011bbd..a1b9789adf26 100644\n--- a/src/planner/binder/tableref/bind_pivot.cpp\n+++ b/src/planner/binder/tableref/bind_pivot.cpp\n@@ -97,10 +97,11 @@ static unique_ptr<SelectNode> ConstructInitialGrouping(PivotRef &ref, vector<uni\n \tif (ref.groups.empty()) {\n \t\t// if rows are not specified any columns that are not pivoted/aggregated on are added to the GROUP BY clause\n \t\tfor (auto &entry : all_columns) {\n-\t\t\tif (entry->type != ExpressionType::COLUMN_REF) {\n+\t\t\tauto column_entry = Binder::GetResolvedColumnExpression(*entry);\n+\t\t\tif (!column_entry) {\n \t\t\t\tthrow InternalException(\"Unexpected child of pivot source - not a ColumnRef\");\n \t\t\t}\n-\t\t\tauto &columnref = entry->Cast<ColumnRefExpression>();\n+\t\t\tauto &columnref = column_entry->Cast<ColumnRefExpression>();\n \t\t\tif (handled_columns.find(columnref.GetColumnName()) == handled_columns.end()) {\n \t\t\t\t// not handled - add to grouping set\n \t\t\t\tsubquery->groups.group_expressions.push_back(make_uniq<ConstantExpression>(\ndiff --git a/src/planner/subquery/flatten_dependent_join.cpp b/src/planner/subquery/flatten_dependent_join.cpp\nindex bbd98b2cf71a..d6070a6e93e4 100644\n--- a/src/planner/subquery/flatten_dependent_join.cpp\n+++ b/src/planner/subquery/flatten_dependent_join.cpp\n@@ -750,6 +750,8 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t}\n \tcase LogicalOperatorType::LOGICAL_SAMPLE:\n \t\tthrow BinderException(\"Sampling in correlated subqueries is not (yet) supported\");\n+\tcase LogicalOperatorType::LOGICAL_POSITIONAL_JOIN:\n+\t\tthrow BinderException(\"Positional join in correlated subqueries is not (yet) supported\");\n \tdefault:\n \t\tthrow InternalException(\"Logical operator type \\\"%s\\\" for dependent join\", LogicalOperatorToString(plan->type));\n \t}\n",
  "test_patch": "diff --git a/test/fuzzer/public/cast_index_expression.test b/test/fuzzer/public/cast_index_expression.test\nnew file mode 100644\nindex 000000000000..f707d71bf1a1\n--- /dev/null\n+++ b/test/fuzzer/public/cast_index_expression.test\n@@ -0,0 +1,14 @@\n+# name: test/fuzzer/public/cast_index_expression.test\n+# description: Test CREATE INDEX using an index expression that triggers a cast\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE v00 (c01 INT, c02 STRING);\n+\n+statement error\n+CREATE INDEX i_index ON v00 USING ART ( NULLIF ( v00, 'string' ) );\n+----\n+Invalid type for index key\ndiff --git a/test/fuzzer/public/columns_using.test b/test/fuzzer/public/columns_using.test\nnew file mode 100644\nindex 000000000000..7cb4bbb570a0\n--- /dev/null\n+++ b/test/fuzzer/public/columns_using.test\n@@ -0,0 +1,20 @@\n+# name: test/fuzzer/public/columns_using.test\n+# description: Test COLUMNS regex in combination with the USING clause for a FULL join\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE v00 (c01 INT);\n+\n+statement error\n+SELECT COLUMNS('v00')\n+FROM v00 AS t1 FULL JOIN v00 AS t2 USING (c01) ;\n+----\n+No matching columns found\n+\n+query I\n+SELECT COLUMNS('c01')\n+FROM v00 AS t1 FULL JOIN v00 AS t2 USING (c01) ;\n+----\ndiff --git a/test/fuzzer/public/distinct_on_non_integer_literal.test b/test/fuzzer/public/distinct_on_non_integer_literal.test\nnew file mode 100644\nindex 000000000000..2d82b0305452\n--- /dev/null\n+++ b/test/fuzzer/public/distinct_on_non_integer_literal.test\n@@ -0,0 +1,14 @@\n+# name: test/fuzzer/public/distinct_on_non_integer_literal.test\n+# description: Test DISTINCT ON non-integer literal\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+SET order_by_non_integer_literal=true;\n+\n+query I\n+SELECT DISTINCT ON ('string') 'x' AS c02;\n+----\n+x\ndiff --git a/test/fuzzer/public/insert_by_name_default.test b/test/fuzzer/public/insert_by_name_default.test\nnew file mode 100644\nindex 000000000000..4c16987f45d9\n--- /dev/null\n+++ b/test/fuzzer/public/insert_by_name_default.test\n@@ -0,0 +1,14 @@\n+# name: test/fuzzer/public/insert_by_name_default.test\n+# description: Insert by name + default values\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE t0(i INT)\n+\n+statement error\n+INSERT INTO t0 BY NAME DEFAULT VALUES;\n+----\n+INSERT BY NAME cannot be combined with with DEFAULT VALUES\ndiff --git a/test/fuzzer/public/insert_or_replace_default_values.test b/test/fuzzer/public/insert_or_replace_default_values.test\nnew file mode 100644\nindex 000000000000..0d0febe535b3\n--- /dev/null\n+++ b/test/fuzzer/public/insert_or_replace_default_values.test\n@@ -0,0 +1,41 @@\n+# name: test/fuzzer/public/insert_or_replace_default_values.test\n+# description: Test INSERT OR REPLACE with DEFAULT VALUES\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE SEQUENCE seq\n+\n+statement ok\n+CREATE TABLE tbl(id INTEGER PRIMARY KEY DEFAULT 1, payload INTEGER DEFAULT nextval('seq'));\n+\n+statement ok\n+INSERT OR REPLACE INTO tbl DEFAULT VALUES;\n+\n+query II\n+FROM tbl\n+----\n+1\t1\n+\n+statement ok\n+INSERT OR REPLACE INTO tbl DEFAULT VALUES;\n+\n+query II\n+FROM tbl\n+----\n+1\t2\n+\n+statement ok\n+INSERT OR IGNORE INTO tbl DEFAULT VALUES;\n+\n+query II\n+FROM tbl\n+----\n+1\t2\n+\n+statement error\n+INSERT INTO tbl DEFAULT VALUES;\n+----\n+constraint\ndiff --git a/test/fuzzer/public/pivot_full_join_using.test b/test/fuzzer/public/pivot_full_join_using.test\nnew file mode 100644\nindex 000000000000..4c0764f4b500\n--- /dev/null\n+++ b/test/fuzzer/public/pivot_full_join_using.test\n@@ -0,0 +1,16 @@\n+# name: test/fuzzer/public/pivot_full_join_using.test\n+# description: Test pivoting on a USING column that comes from a FULL JOIN\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE t1 (c01 INT, c02 INT);\n+\n+statement ok\n+CREATE TABLE t2 (c01 INT, c03 INT);\n+\n+query II\n+PIVOT t1 FULL JOIN t2 USING ( c01 ) ON c01;\n+----\ndiff --git a/test/fuzzer/public/positional_join_correlated_subquery.test b/test/fuzzer/public/positional_join_correlated_subquery.test\nnew file mode 100644\nindex 000000000000..82e93fe8aaa9\n--- /dev/null\n+++ b/test/fuzzer/public/positional_join_correlated_subquery.test\n@@ -0,0 +1,15 @@\n+# name: test/fuzzer/public/positional_join_correlated_subquery.test\n+# description: Test positional join in correlated subqueries\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE v00 (c01 INT, c02 STRING);\n+\n+statement error\n+SELECT (SELECT 42 FROM (SELECT c01) POSITIONAL JOIN (SELECT c02))\n+FROM v00;\n+----\n+not (yet) supported\ndiff --git a/test/fuzzer/public/semi_join_using.test b/test/fuzzer/public/semi_join_using.test\nnew file mode 100644\nindex 000000000000..2f91c6a7448d\n--- /dev/null\n+++ b/test/fuzzer/public/semi_join_using.test\n@@ -0,0 +1,33 @@\n+# name: test/fuzzer/public/semi_join_using.test\n+# description: Test SEMI JOIN with USING clause\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE v00 (c01 INT, c02 STRING);\n+\n+statement error\n+SELECT c02\n+FROM (\n+\tv00 AS t1\n+\tNATURAL JOIN\n+\tv00 AS t2 ),\n+\t( v00 AS ta04\n+\tSEMI JOIN v00 AS ta05\n+\tUSING ( c02 ) ) ;\n+----\n+Ambiguous column reference\n+\n+\n+query III\n+SELECT t1.c02, t2.c02, ta04.c02\n+FROM (\n+\tv00 AS t1\n+\tNATURAL JOIN\n+\tv00 AS t2 ),\n+\t( v00 AS ta04\n+\tSEMI JOIN v00 AS ta05\n+\tUSING ( c02 ) ) ;\n+----\n",
  "problem_statement": "DuckDB Internal Error: Unexpected child of pivot source - not a ColumnRef\n### What happens?\n\nThe latest version of the DuckDB (latest main: v1.1.4-dev3057 1db3def66e and released version: v1.1.3 19864453f7) triggers Internal Error when running the following SQL statement: \r\n\r\n```sql\r\nCREATE TABLE v00 (c01 INT);\r\nPIVOT v00 AS ta01 FULL JOIN v00 AS ta02 USING ( c01 ) ON c01;\r\n```\r\n\r\nStacktrace from the latest main (1db3def66e):\r\n\r\n```\r\n#0  duckdb::InternalException::InternalException (this=0x41084b00, Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nmsg=) at /home/duckdb/duckdb/src/common/exception.cpp:333\r\n#1  0x00000000027ef8d4 in duckdb::ConstructInitialGrouping (ref=..., all_columns=..., handled_columns=std::unordered_set with 1 element = {...})\r\n    at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:101\r\n#2  0x00000000027a2f2c in duckdb::PivotFilteredAggregate (context=..., ref=..., all_columns=..., handled_columns=std::unordered_set with 1 element = {...},\r\n    pivot_values=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:126\r\n#3  duckdb::Binder::BindPivot (this=0x41082930, ref=..., all_columns=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:484\r\n#4  0x00000000027beec0 in duckdb::Binder::Bind (this=<optimized out>, ref=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:723\r\n#5  0x00000000028f71c8 in duckdb::Binder::Bind (this=0x41082930, ref=...) at /home/duckdb/duckdb/src/planner/binder.cpp:416\r\n#6  0x0000000004b14db0 in duckdb::Binder::BindNode (this=0x41082930, statement=...)\r\n    at /home/duckdb/duckdb/src/planner/binder/query_node/bind_select_node.cpp:372\r\n#7  0x00000000028f4d0c in duckdb::Binder::BindNode (this=0x41082930, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:328\r\n#8  0x00000000028f5698 in duckdb::Binder::Bind (this=0x41082930, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:365\r\n#9  0x00000000028eff68 in duckdb::Binder::Bind (this=0x41082930, statement=...) at /home/duckdb/duckdb/src/planner/binder.cpp:150\r\n#10 0x00000000029203c0 in duckdb::Planner::CreatePlan (this=0xffffe5e73c50, statement=...) at /home/duckdb/duckdb/src/planner/planner.cpp:43\r\n#11 0x0000000001890fc8 in duckdb::ClientContext::CreatePreparedStatementInternal (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., values=...)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:340\r\n#12 0x0000000001895214 in duckdb::ClientContext::CreatePreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., values=...,\r\n    mode=duckdb::PreparedStatementMode::PREPARE_AND_EXECUTE) at /home/duckdb/duckdb/src/main/client_context.cpp:426\r\n#13 0x00000000018ab804 in duckdb::ClientContext::PendingStatementInternal (this=0x40ee7710, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., parameters=...)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:745\r\n#14 0x00000000018b50d0 in duckdb::ClientContext::PendingStatementOrPreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., prepared=...,\r\n    parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:863\r\n#15 0x00000000018a93d4 in duckdb::ClientContext::PendingStatementOrPreparedStatementInternal (this=0x40ee7710, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=...,\r\n    prepared=..., parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:837\r\n#16 0x00000000018adc34 in duckdb::ClientContext::PendingQueryInternal (this=0x40ee7710, lock=..., statement=..., parameters=..., verify=<optimized out>)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:1054\r\n#17 0x00000000018be110 in duckdb::ClientContext::PendingQuery (this=0x40ee7710, statement=..., values=std::unordered_map with 0 elements,\r\n    allow_stream_result=<optimized out>) at /home/duckdb/duckdb/src/main/client_context.cpp:1041\r\n#18 0x00000000018b7dfc in duckdb::ClientContext::PendingQuery (this=0x2ad8, statement=..., allow_stream_result=false)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:1001\r\n#19 0x00000000018ec7d4 in duckdb::Connection::PendingQuery (this=<optimized out>, statement=..., allow_stream_result=false)\r\n    at /home/duckdb/duckdb/src/main/connection.cpp:140\r\n#20 0x00000000004b40f0 in duckdb_shell_sqlite3_prepare_v2 (db=0x40e45b90, zSql=<optimized out>, nByte=<optimized out>, ppStmt=<optimized out>,\r\n    pzTail=<optimized out>) at ../../tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:224\r\n#21 0x000000000046f9dc in duckdb_shell::ShellState::ExecuteSQL (this=<optimized out>,\r\n    zSql=0x40e20830 \"PIVOT v00 AS ta66500 FULL JOIN v00 AS ta01 USING ( c01 ) ON c01;\", pzErrMsg=<optimized out>) at ../../tools/shell/shell.cpp:1762\r\n#22 0x0000000000485b74 in duckdb_shell::ShellState::RunOneSqlLine (this=0xffffe5e74f08,\r\n    zSql=0x40e20830 \"PIVOT v00 AS ta66500 FULL JOIN v00 AS ta01 USING ( c01 ) ON c01;\") at ../../tools/shell/shell.cpp:4353\r\n#23 0x0000000000480480 in duckdb_shell::ShellState::ProcessInput (this=<optimized out>) at ../../tools/shell/shell.cpp:4468\r\n#24 0x0000000000489dac in main (argc=1, argv=0xffffe5e75258) at ../../tools/shell/shell.cpp:5076\r\n```\n\n### To Reproduce\n\n1. Clone the DuckDB Git from the official repo.\r\n2. Checkout to the latest main (1db3def66e).\r\n3. Compile the DuckDB binary by using `make relassert`.\r\n4. Run the compiled DuckDB and input the following SQL:\r\n\r\n```sql\r\nCREATE TABLE v00 (c01 INT);\r\nPIVOT v00 AS ta01 FULL JOIN v00 AS ta02 USING ( c01 ) ON c01;\r\n```\n\n### OS:\n\nUbuntu 24.04 LTS\n\n### DuckDB Version:\n\n1.1.3 and latest main: 1db3def\n\n### DuckDB Client:\n\ncli\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nYu Liang\n\n### Affiliation:\n\nThe Pennsylvania State University\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\nDuckDB Internal Error: Unexpected child of pivot source - not a ColumnRef\n### What happens?\n\nThe latest version of the DuckDB (latest main: v1.1.4-dev3057 1db3def66e and released version: v1.1.3 19864453f7) triggers Internal Error when running the following SQL statement: \r\n\r\n```sql\r\nCREATE TABLE v00 (c01 INT);\r\nPIVOT v00 AS ta01 FULL JOIN v00 AS ta02 USING ( c01 ) ON c01;\r\n```\r\n\r\nStacktrace from the latest main (1db3def66e):\r\n\r\n```\r\n#0  duckdb::InternalException::InternalException (this=0x41084b00, Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nmsg=) at /home/duckdb/duckdb/src/common/exception.cpp:333\r\n#1  0x00000000027ef8d4 in duckdb::ConstructInitialGrouping (ref=..., all_columns=..., handled_columns=std::unordered_set with 1 element = {...})\r\n    at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:101\r\n#2  0x00000000027a2f2c in duckdb::PivotFilteredAggregate (context=..., ref=..., all_columns=..., handled_columns=std::unordered_set with 1 element = {...},\r\n    pivot_values=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:126\r\n#3  duckdb::Binder::BindPivot (this=0x41082930, ref=..., all_columns=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:484\r\n#4  0x00000000027beec0 in duckdb::Binder::Bind (this=<optimized out>, ref=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:723\r\n#5  0x00000000028f71c8 in duckdb::Binder::Bind (this=0x41082930, ref=...) at /home/duckdb/duckdb/src/planner/binder.cpp:416\r\n#6  0x0000000004b14db0 in duckdb::Binder::BindNode (this=0x41082930, statement=...)\r\n    at /home/duckdb/duckdb/src/planner/binder/query_node/bind_select_node.cpp:372\r\n#7  0x00000000028f4d0c in duckdb::Binder::BindNode (this=0x41082930, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:328\r\n#8  0x00000000028f5698 in duckdb::Binder::Bind (this=0x41082930, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:365\r\n#9  0x00000000028eff68 in duckdb::Binder::Bind (this=0x41082930, statement=...) at /home/duckdb/duckdb/src/planner/binder.cpp:150\r\n#10 0x00000000029203c0 in duckdb::Planner::CreatePlan (this=0xffffe5e73c50, statement=...) at /home/duckdb/duckdb/src/planner/planner.cpp:43\r\n#11 0x0000000001890fc8 in duckdb::ClientContext::CreatePreparedStatementInternal (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., values=...)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:340\r\n#12 0x0000000001895214 in duckdb::ClientContext::CreatePreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., values=...,\r\n    mode=duckdb::PreparedStatementMode::PREPARE_AND_EXECUTE) at /home/duckdb/duckdb/src/main/client_context.cpp:426\r\n#13 0x00000000018ab804 in duckdb::ClientContext::PendingStatementInternal (this=0x40ee7710, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., parameters=...)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:745\r\n#14 0x00000000018b50d0 in duckdb::ClientContext::PendingStatementOrPreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=..., prepared=...,\r\n    parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:863\r\n#15 0x00000000018a93d4 in duckdb::ClientContext::PendingStatementOrPreparedStatementInternal (this=0x40ee7710, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:\r\nquery=, statement=...,\r\n    prepared=..., parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:837\r\n#16 0x00000000018adc34 in duckdb::ClientContext::PendingQueryInternal (this=0x40ee7710, lock=..., statement=..., parameters=..., verify=<optimized out>)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:1054\r\n#17 0x00000000018be110 in duckdb::ClientContext::PendingQuery (this=0x40ee7710, statement=..., values=std::unordered_map with 0 elements,\r\n    allow_stream_result=<optimized out>) at /home/duckdb/duckdb/src/main/client_context.cpp:1041\r\n#18 0x00000000018b7dfc in duckdb::ClientContext::PendingQuery (this=0x2ad8, statement=..., allow_stream_result=false)\r\n    at /home/duckdb/duckdb/src/main/client_context.cpp:1001\r\n#19 0x00000000018ec7d4 in duckdb::Connection::PendingQuery (this=<optimized out>, statement=..., allow_stream_result=false)\r\n    at /home/duckdb/duckdb/src/main/connection.cpp:140\r\n#20 0x00000000004b40f0 in duckdb_shell_sqlite3_prepare_v2 (db=0x40e45b90, zSql=<optimized out>, nByte=<optimized out>, ppStmt=<optimized out>,\r\n    pzTail=<optimized out>) at ../../tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:224\r\n#21 0x000000000046f9dc in duckdb_shell::ShellState::ExecuteSQL (this=<optimized out>,\r\n    zSql=0x40e20830 \"PIVOT v00 AS ta66500 FULL JOIN v00 AS ta01 USING ( c01 ) ON c01;\", pzErrMsg=<optimized out>) at ../../tools/shell/shell.cpp:1762\r\n#22 0x0000000000485b74 in duckdb_shell::ShellState::RunOneSqlLine (this=0xffffe5e74f08,\r\n    zSql=0x40e20830 \"PIVOT v00 AS ta66500 FULL JOIN v00 AS ta01 USING ( c01 ) ON c01;\") at ../../tools/shell/shell.cpp:4353\r\n#23 0x0000000000480480 in duckdb_shell::ShellState::ProcessInput (this=<optimized out>) at ../../tools/shell/shell.cpp:4468\r\n#24 0x0000000000489dac in main (argc=1, argv=0xffffe5e75258) at ../../tools/shell/shell.cpp:5076\r\n```\n\n### To Reproduce\n\n1. Clone the DuckDB Git from the official repo.\r\n2. Checkout to the latest main (1db3def66e).\r\n3. Compile the DuckDB binary by using `make relassert`.\r\n4. Run the compiled DuckDB and input the following SQL:\r\n\r\n```sql\r\nCREATE TABLE v00 (c01 INT);\r\nPIVOT v00 AS ta01 FULL JOIN v00 AS ta02 USING ( c01 ) ON c01;\r\n```\n\n### OS:\n\nUbuntu 24.04 LTS\n\n### DuckDB Version:\n\n1.1.3 and latest main: 1db3def\n\n### DuckDB Client:\n\ncli\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nYu Liang\n\n### Affiliation:\n\nThe Pennsylvania State University\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2024-12-09T13:27:33Z"
}