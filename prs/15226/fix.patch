diff --git a/src/execution/expression_executor/execute_cast.cpp b/src/execution/expression_executor/execute_cast.cpp
index c0cca5889084..eb3a93fc4bce 100644
--- a/src/execution/expression_executor/execute_cast.cpp
+++ b/src/execution/expression_executor/execute_cast.cpp
@@ -12,7 +12,8 @@ unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const BoundCastE
 	result->Finalize();
 
 	if (expr.bound_cast.init_local_state) {
-		CastLocalStateParameters parameters(root.executor->GetContext(), expr.bound_cast.cast_data);
+		auto context_ptr = root.executor->HasContext() ? &root.executor->GetContext() : nullptr;
+		CastLocalStateParameters parameters(context_ptr, expr.bound_cast.cast_data);
 		result->local_state = expr.bound_cast.init_local_state(parameters);
 	}
 	return std::move(result);
diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp
index 7da3b6c5d87f..0cd7c0e6a803 100644
--- a/src/include/duckdb/planner/binder.hpp
+++ b/src/include/duckdb/planner/binder.hpp
@@ -213,6 +213,8 @@ class Binder : public enable_shared_from_this<Binder> {
 	CatalogEntryRetriever &EntryRetriever() {
 		return entry_retriever;
 	}
+	//! Returns a ColumnRefExpression after it was resolved (i.e. past the STAR expression/USING clauses)
+	static optional_ptr<ParsedExpression> GetResolvedColumnExpression(ParsedExpression &root_expr);
 
 	void SetCanContainNulls(bool can_contain_nulls);
 	void SetAlwaysRequireRebind();
diff --git a/src/planner/bind_context.cpp b/src/planner/bind_context.cpp
index 5b4c3a10907c..bb7786f9360c 100644
--- a/src/planner/bind_context.cpp
+++ b/src/planner/bind_context.cpp
@@ -718,6 +718,25 @@ vector<BindingAlias> BindContext::GetBindingAliases() {
 
 void BindContext::RemoveContext(const vector<BindingAlias> &aliases) {
 	for (auto &alias : aliases) {
+		// remove the binding from any USING columns
+		for (auto &using_sets : using_columns) {
+			for (auto &using_set_ref : using_sets.second) {
+				auto &using_set = using_set_ref.get();
+				auto it = std::remove_if(using_set.bindings.begin(), using_set.bindings.end(),
+				                         [&](const BindingAlias &using_alias) { return using_alias == alias; });
+				using_set.bindings.erase(it, using_set.bindings.end());
+				if (using_set.bindings.empty()) {
+					throw InternalException(
+					    "BindContext::RemoveContext - no more tables that refer to this using binding");
+				}
+				if (using_set.primary_binding == alias) {
+					throw InternalException(
+					    "BindContext::RemoveContext - cannot remove primary binding from using binding");
+				}
+			}
+		}
+
+		// remove the binding from the list of bindings
 		auto it = std::remove_if(bindings_list.begin(), bindings_list.end(),
 		                         [&](unique_ptr<Binding> &x) { return x->alias == alias; });
 		bindings_list.erase(it, bindings_list.end());
diff --git a/src/planner/binder/expression/bind_star_expression.cpp b/src/planner/binder/expression/bind_star_expression.cpp
index ddf7dd5baae6..2a15d0c8d4ad 100644
--- a/src/planner/binder/expression/bind_star_expression.cpp
+++ b/src/planner/binder/expression/bind_star_expression.cpp
@@ -185,6 +185,22 @@ void TryTransformStarLike(unique_ptr<ParsedExpression> &root) {
 	root = std::move(columns_expr);
 }
 
+optional_ptr<ParsedExpression> Binder::GetResolvedColumnExpression(ParsedExpression &root_expr) {
+	optional_ptr<ParsedExpression> expr = &root_expr;
+	while (expr) {
+		if (expr->type == ExpressionType::COLUMN_REF) {
+			break;
+		}
+		if (expr->type == ExpressionType::OPERATOR_COALESCE) {
+			expr = expr->Cast<OperatorExpression>().children[0].get();
+		} else {
+			// unknown expression
+			return nullptr;
+		}
+	}
+	return expr;
+}
+
 void Binder::ExpandStarExpression(unique_ptr<ParsedExpression> expr,
                                   vector<unique_ptr<ParsedExpression>> &new_select_list) {
 	TryTransformStarLike(expr);
@@ -232,7 +248,11 @@ void Binder::ExpandStarExpression(unique_ptr<ParsedExpression> expr,
 			}
 			vector<unique_ptr<ParsedExpression>> new_list;
 			for (idx_t i = 0; i < star_list.size(); i++) {
-				auto &colref = star_list[i]->Cast<ColumnRefExpression>();
+				auto child_expr = GetResolvedColumnExpression(*star_list[i]);
+				if (!child_expr) {
+					continue;
+				}
+				auto &colref = child_expr->Cast<ColumnRefExpression>();
 				if (!RE2::PartialMatch(colref.GetColumnName(), *regex)) {
 					continue;
 				}
@@ -297,18 +317,7 @@ void Binder::ExpandStarExpression(unique_ptr<ParsedExpression> expr,
 		auto new_expr = expr->Copy();
 		ReplaceStarExpression(new_expr, star_list[i]);
 		if (StarExpression::IsColumns(*star)) {
-			optional_ptr<ParsedExpression> expr = star_list[i].get();
-			while (expr) {
-				if (expr->type == ExpressionType::COLUMN_REF) {
-					break;
-				}
-				if (expr->type == ExpressionType::OPERATOR_COALESCE) {
-					expr = expr->Cast<OperatorExpression>().children[0].get();
-				} else {
-					// unknown expression
-					expr = nullptr;
-				}
-			}
+			auto expr = GetResolvedColumnExpression(*star_list[i]);
 			if (expr) {
 				auto &colref = expr->Cast<ColumnRefExpression>();
 				if (new_expr->alias.empty()) {
diff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp
index ea16c02045ac..590da7ae4ba9 100644
--- a/src/planner/binder/query_node/bind_select_node.cpp
+++ b/src/planner/binder/query_node/bind_select_node.cpp
@@ -310,7 +310,6 @@ void Binder::BindModifiers(BoundQueryNode &result, idx_t table_index, const vect
 		switch (bound_mod->type) {
 		case ResultModifierType::DISTINCT_MODIFIER: {
 			auto &distinct = bound_mod->Cast<BoundDistinctModifier>();
-			D_ASSERT(!distinct.target_distincts.empty());
 			// set types of distinct targets
 			for (auto &expr : distinct.target_distincts) {
 				expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
diff --git a/src/planner/binder/query_node/plan_query_node.cpp b/src/planner/binder/query_node/plan_query_node.cpp
index 97678d2271e0..c448f2f111a9 100644
--- a/src/planner/binder/query_node/plan_query_node.cpp
+++ b/src/planner/binder/query_node/plan_query_node.cpp
@@ -13,6 +13,9 @@ unique_ptr<LogicalOperator> Binder::VisitQueryNode(BoundQueryNode &node, unique_
 		switch (mod->type) {
 		case ResultModifierType::DISTINCT_MODIFIER: {
 			auto &bound = mod->Cast<BoundDistinctModifier>();
+			if (bound.target_distincts.empty()) {
+				break;
+			}
 			auto distinct = make_uniq<LogicalDistinct>(std::move(bound.target_distincts), bound.distinct_type);
 			distinct->AddChild(std::move(root));
 			root = std::move(distinct);
diff --git a/src/planner/binder/statement/bind_insert.cpp b/src/planner/binder/statement/bind_insert.cpp
index 509b3d2a26c0..5e3903049414 100644
--- a/src/planner/binder/statement/bind_insert.cpp
+++ b/src/planner/binder/statement/bind_insert.cpp
@@ -148,7 +148,6 @@ void ReplaceColumnBindings(Expression &expr, idx_t source, idx_t dest) {
 void Binder::BindDoUpdateSetExpressions(const string &table_alias, LogicalInsert &insert, UpdateSetInfo &set_info,
                                         TableCatalogEntry &table, TableStorageInfo &storage_info) {
 	D_ASSERT(insert.children.size() == 1);
-	D_ASSERT(insert.children[0]->type == LogicalOperatorType::LOGICAL_PROJECTION);
 
 	vector<column_t> logical_column_ids;
 	vector<string> column_names;
@@ -495,6 +494,9 @@ BoundStatement Binder::Bind(InsertStatement &stmt) {
 		if (values_list) {
 			throw BinderException("INSERT BY NAME can only be used when inserting from a SELECT statement");
 		}
+		if (stmt.default_values) {
+			throw BinderException("INSERT BY NAME cannot be combined with with DEFAULT VALUES");
+		}
 		if (!stmt.columns.empty()) {
 			throw BinderException("INSERT BY NAME cannot be combined with an explicit column list");
 		}
diff --git a/src/planner/binder/tableref/bind_pivot.cpp b/src/planner/binder/tableref/bind_pivot.cpp
index e673c6011bbd..a1b9789adf26 100644
--- a/src/planner/binder/tableref/bind_pivot.cpp
+++ b/src/planner/binder/tableref/bind_pivot.cpp
@@ -97,10 +97,11 @@ static unique_ptr<SelectNode> ConstructInitialGrouping(PivotRef &ref, vector<uni
 	if (ref.groups.empty()) {
 		// if rows are not specified any columns that are not pivoted/aggregated on are added to the GROUP BY clause
 		for (auto &entry : all_columns) {
-			if (entry->type != ExpressionType::COLUMN_REF) {
+			auto column_entry = Binder::GetResolvedColumnExpression(*entry);
+			if (!column_entry) {
 				throw InternalException("Unexpected child of pivot source - not a ColumnRef");
 			}
-			auto &columnref = entry->Cast<ColumnRefExpression>();
+			auto &columnref = column_entry->Cast<ColumnRefExpression>();
 			if (handled_columns.find(columnref.GetColumnName()) == handled_columns.end()) {
 				// not handled - add to grouping set
 				subquery->groups.group_expressions.push_back(make_uniq<ConstantExpression>(
diff --git a/src/planner/subquery/flatten_dependent_join.cpp b/src/planner/subquery/flatten_dependent_join.cpp
index bbd98b2cf71a..d6070a6e93e4 100644
--- a/src/planner/subquery/flatten_dependent_join.cpp
+++ b/src/planner/subquery/flatten_dependent_join.cpp
@@ -750,6 +750,8 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal
 	}
 	case LogicalOperatorType::LOGICAL_SAMPLE:
 		throw BinderException("Sampling in correlated subqueries is not (yet) supported");
+	case LogicalOperatorType::LOGICAL_POSITIONAL_JOIN:
+		throw BinderException("Positional join in correlated subqueries is not (yet) supported");
 	default:
 		throw InternalException("Logical operator type \"%s\" for dependent join", LogicalOperatorToString(plan->type));
 	}
