You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
DuckDB Internal Error: Unexpected child of pivot source - not a ColumnRef
### What happens?

The latest version of the DuckDB (latest main: v1.1.4-dev3057 1db3def66e and released version: v1.1.3 19864453f7) triggers Internal Error when running the following SQL statement: 

```sql
CREATE TABLE v00 (c01 INT);
PIVOT v00 AS ta01 FULL JOIN v00 AS ta02 USING ( c01 ) ON c01;
```

Stacktrace from the latest main (1db3def66e):

```
#0  duckdb::InternalException::InternalException (this=0x41084b00, Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
msg=) at /home/duckdb/duckdb/src/common/exception.cpp:333
#1  0x00000000027ef8d4 in duckdb::ConstructInitialGrouping (ref=..., all_columns=..., handled_columns=std::unordered_set with 1 element = {...})
    at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:101
#2  0x00000000027a2f2c in duckdb::PivotFilteredAggregate (context=..., ref=..., all_columns=..., handled_columns=std::unordered_set with 1 element = {...},
    pivot_values=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:126
#3  duckdb::Binder::BindPivot (this=0x41082930, ref=..., all_columns=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:484
#4  0x00000000027beec0 in duckdb::Binder::Bind (this=<optimized out>, ref=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:723
#5  0x00000000028f71c8 in duckdb::Binder::Bind (this=0x41082930, ref=...) at /home/duckdb/duckdb/src/planner/binder.cpp:416
#6  0x0000000004b14db0 in duckdb::Binder::BindNode (this=0x41082930, statement=...)
    at /home/duckdb/duckdb/src/planner/binder/query_node/bind_select_node.cpp:372
#7  0x00000000028f4d0c in duckdb::Binder::BindNode (this=0x41082930, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:328
#8  0x00000000028f5698 in duckdb::Binder::Bind (this=0x41082930, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:365
#9  0x00000000028eff68 in duckdb::Binder::Bind (this=0x41082930, statement=...) at /home/duckdb/duckdb/src/planner/binder.cpp:150
#10 0x00000000029203c0 in duckdb::Planner::CreatePlan (this=0xffffe5e73c50, statement=...) at /home/duckdb/duckdb/src/planner/planner.cpp:43
#11 0x0000000001890fc8 in duckdb::ClientContext::CreatePreparedStatementInternal (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
query=, statement=..., values=...)
    at /home/duckdb/duckdb/src/main/client_context.cpp:340
#12 0x0000000001895214 in duckdb::ClientContext::CreatePreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
query=, statement=..., values=...,
    mode=duckdb::PreparedStatementMode::PREPARE_AND_EXECUTE) at /home/duckdb/duckdb/src/main/client_context.cpp:426
#13 0x00000000018ab804 in duckdb::ClientContext::PendingStatementInternal (this=0x40ee7710, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
query=, statement=..., parameters=...)
    at /home/duckdb/duckdb/src/main/client_context.cpp:745
#14 0x00000000018b50d0 in duckdb::ClientContext::PendingStatementOrPreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
query=, statement=..., prepared=...,
    parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:863
#15 0x00000000018a93d4 in duckdb::ClientContext::PendingStatementOrPreparedStatementInternal (this=0x40ee7710, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
query=, statement=...,
    prepared=..., parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:837
#16 0x00000000018adc34 in duckdb::ClientContext::PendingQueryInternal (this=0x40ee7710, lock=..., statement=..., parameters=..., verify=<optimized out>)
    at /home/duckdb/duckdb/src/main/client_context.cpp:1054
#17 0x00000000018be110 in duckdb::ClientContext::PendingQuery (this=0x40ee7710, statement=..., values=std::unordered_map with 0 elements,
    allow_stream_result=<optimized out>) at /home/duckdb/duckdb/src/main/client_context.cpp:1041
#18 0x00000000018b7dfc in duckdb::ClientContext::PendingQuery (this=0x2ad8, statement=..., allow_stream_result=false)
    at /home/duckdb/duckdb/src/main/client_context.cpp:1001
#19 0x00000000018ec7d4 in duckdb::Connection::PendingQuery (this=<optimized out>, statement=..., allow_stream_result=false)
    at /home/duckdb/duckdb/src/main/connection.cpp:140
#20 0x00000000004b40f0 in duckdb_shell_sqlite3_prepare_v2 (db=0x40e45b90, zSql=<optimized out>, nByte=<optimized out>, ppStmt=<optimized out>,
    pzTail=<optimized out>) at ../../tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:224
#21 0x000000000046f9dc in duckdb_shell::ShellState::ExecuteSQL (this=<optimized out>,
    zSql=0x40e20830 "PIVOT v00 AS ta66500 FULL JOIN v00 AS ta01 USING ( c01 ) ON c01;", pzErrMsg=<optimized out>) at ../../tools/shell/shell.cpp:1762
#22 0x0000000000485b74 in duckdb_shell::ShellState::RunOneSqlLine (this=0xffffe5e74f08,
    zSql=0x40e20830 "PIVOT v00 AS ta66500 FULL JOIN v00 AS ta01 USING ( c01 ) ON c01;") at ../../tools/shell/shell.cpp:4353
#23 0x0000000000480480 in duckdb_shell::ShellState::ProcessInput (this=<optimized out>) at ../../tools/shell/shell.cpp:4468
#24 0x0000000000489dac in main (argc=1, argv=0xffffe5e75258) at ../../tools/shell/shell.cpp:5076
```

### To Reproduce

1. Clone the DuckDB Git from the official repo.
2. Checkout to the latest main (1db3def66e).
3. Compile the DuckDB binary by using `make relassert`.
4. Run the compiled DuckDB and input the following SQL:

```sql
CREATE TABLE v00 (c01 INT);
PIVOT v00 AS ta01 FULL JOIN v00 AS ta02 USING ( c01 ) ON c01;
```

### OS:

Ubuntu 24.04 LTS

### DuckDB Version:

1.1.3 and latest main: 1db3def

### DuckDB Client:

cli

### Hardware:

_No response_

### Full Name:

Yu Liang

### Affiliation:

The Pennsylvania State University

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
DuckDB Internal Error: Unexpected child of pivot source - not a ColumnRef
### What happens?

The latest version of the DuckDB (latest main: v1.1.4-dev3057 1db3def66e and released version: v1.1.3 19864453f7) triggers Internal Error when running the following SQL statement: 

```sql
CREATE TABLE v00 (c01 INT);
PIVOT v00 AS ta01 FULL JOIN v00 AS ta02 USING ( c01 ) ON c01;
```

Stacktrace from the latest main (1db3def66e):

```
#0  duckdb::InternalException::InternalException (this=0x41084b00, Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
msg=) at /home/duckdb/duckdb/src/common/exception.cpp:333
#1  0x00000000027ef8d4 in duckdb::ConstructInitialGrouping (ref=..., all_columns=..., handled_columns=std::unordered_set with 1 element = {...})
    at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:101
#2  0x00000000027a2f2c in duckdb::PivotFilteredAggregate (context=..., ref=..., all_columns=..., handled_columns=std::unordered_set with 1 element = {...},
    pivot_values=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:126
#3  duckdb::Binder::BindPivot (this=0x41082930, ref=..., all_columns=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:484
#4  0x00000000027beec0 in duckdb::Binder::Bind (this=<optimized out>, ref=...) at /home/duckdb/duckdb/src/planner/binder/tableref/bind_pivot.cpp:723
#5  0x00000000028f71c8 in duckdb::Binder::Bind (this=0x41082930, ref=...) at /home/duckdb/duckdb/src/planner/binder.cpp:416
#6  0x0000000004b14db0 in duckdb::Binder::BindNode (this=0x41082930, statement=...)
    at /home/duckdb/duckdb/src/planner/binder/query_node/bind_select_node.cpp:372
#7  0x00000000028f4d0c in duckdb::Binder::BindNode (this=0x41082930, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:328
#8  0x00000000028f5698 in duckdb::Binder::Bind (this=0x41082930, node=...) at /home/duckdb/duckdb/src/planner/binder.cpp:365
#9  0x00000000028eff68 in duckdb::Binder::Bind (this=0x41082930, statement=...) at /home/duckdb/duckdb/src/planner/binder.cpp:150
#10 0x00000000029203c0 in duckdb::Planner::CreatePlan (this=0xffffe5e73c50, statement=...) at /home/duckdb/duckdb/src/planner/planner.cpp:43
#11 0x0000000001890fc8 in duckdb::ClientContext::CreatePreparedStatementInternal (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
query=, statement=..., values=...)
    at /home/duckdb/duckdb/src/main/client_context.cpp:340
#12 0x0000000001895214 in duckdb::ClientContext::CreatePreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
query=, statement=..., values=...,
    mode=duckdb::PreparedStatementMode::PREPARE_AND_EXECUTE) at /home/duckdb/duckdb/src/main/client_context.cpp:426
#13 0x00000000018ab804 in duckdb::ClientContext::PendingStatementInternal (this=0x40ee7710, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
query=, statement=..., parameters=...)
    at /home/duckdb/duckdb/src/main/client_context.cpp:745
#14 0x00000000018b50d0 in duckdb::ClientContext::PendingStatementOrPreparedStatement (this=<optimized out>, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
query=, statement=..., prepared=...,
    parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:863
#15 0x00000000018a93d4 in duckdb::ClientContext::PendingStatementOrPreparedStatementInternal (this=0x40ee7710, lock=..., Python Exception <class 'gdb.error'> There is no member named _M_dataplus.:
query=, statement=...,
    prepared=..., parameters=...) at /home/duckdb/duckdb/src/main/client_context.cpp:837
#16 0x00000000018adc34 in duckdb::ClientContext::PendingQueryInternal (this=0x40ee7710, lock=..., statement=..., parameters=..., verify=<optimized out>)
    at /home/duckdb/duckdb/src/main/client_context.cpp:1054
#17 0x00000000018be110 in duckdb::ClientContext::PendingQuery (this=0x40ee7710, statement=..., values=std::unordered_map with 0 elements,
    allow_stream_result=<optimized out>) at /home/duckdb/duckdb/src/main/client_context.cpp:1041
#18 0x00000000018b7dfc in duckdb::ClientContext::PendingQuery (this=0x2ad8, statement=..., allow_stream_result=false)
    at /home/duckdb/duckdb/src/main/client_context.cpp:1001
#19 0x00000000018ec7d4 in duckdb::Connection::PendingQuery (this=<optimized out>, statement=..., allow_stream_result=false)
    at /home/duckdb/duckdb/src/main/connection.cpp:140
#20 0x00000000004b40f0 in duckdb_shell_sqlite3_prepare_v2 (db=0x40e45b90, zSql=<optimized out>, nByte=<optimized out>, ppStmt=<optimized out>,
    pzTail=<optimized out>) at ../../tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:224
#21 0x000000000046f9dc in duckdb_shell::ShellState::ExecuteSQL (this=<optimized out>,
    zSql=0x40e20830 "PIVOT v00 AS ta66500 FULL JOIN v00 AS ta01 USING ( c01 ) ON c01;", pzErrMsg=<optimized out>) at ../../tools/shell/shell.cpp:1762
#22 0x0000000000485b74 in duckdb_shell::ShellState::RunOneSqlLine (this=0xffffe5e74f08,
    zSql=0x40e20830 "PIVOT v00 AS ta66500 FULL JOIN v00 AS ta01 USING ( c01 ) ON c01;") at ../../tools/shell/shell.cpp:4353
#23 0x0000000000480480 in duckdb_shell::ShellState::ProcessInput (this=<optimized out>) at ../../tools/shell/shell.cpp:4468
#24 0x0000000000489dac in main (argc=1, argv=0xffffe5e75258) at ../../tools/shell/shell.cpp:5076
```

### To Reproduce

1. Clone the DuckDB Git from the official repo.
2. Checkout to the latest main (1db3def66e).
3. Compile the DuckDB binary by using `make relassert`.
4. Run the compiled DuckDB and input the following SQL:

```sql
CREATE TABLE v00 (c01 INT);
PIVOT v00 AS ta01 FULL JOIN v00 AS ta02 USING ( c01 ) ON c01;
```

### OS:

Ubuntu 24.04 LTS

### DuckDB Version:

1.1.3 and latest main: 1db3def

### DuckDB Client:

cli

### Hardware:

_No response_

### Full Name:

Yu Liang

### Affiliation:

The Pennsylvania State University

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/execution/expression_executor/execute_cast.cpp]
1: #include "duckdb/common/vector_operations/vector_operations.hpp"
2: #include "duckdb/execution/expression_executor.hpp"
3: #include "duckdb/function/scalar_function.hpp"
4: #include "duckdb/planner/expression/bound_cast_expression.hpp"
5: 
6: namespace duckdb {
7: 
8: unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const BoundCastExpression &expr,
9:                                                                 ExpressionExecutorState &root) {
10: 	auto result = make_uniq<ExecuteFunctionState>(expr, root);
11: 	result->AddChild(*expr.child);
12: 	result->Finalize();
13: 
14: 	if (expr.bound_cast.init_local_state) {
15: 		CastLocalStateParameters parameters(root.executor->GetContext(), expr.bound_cast.cast_data);
16: 		result->local_state = expr.bound_cast.init_local_state(parameters);
17: 	}
18: 	return std::move(result);
19: }
20: 
21: void ExpressionExecutor::Execute(const BoundCastExpression &expr, ExpressionState *state, const SelectionVector *sel,
22:                                  idx_t count, Vector &result) {
23: 	auto lstate = ExecuteFunctionState::GetFunctionState(*state);
24: 
25: 	// resolve the child
26: 	state->intermediate_chunk.Reset();
27: 
28: 	auto &child = state->intermediate_chunk.data[0];
29: 	auto child_state = state->child_states[0].get();
30: 
31: 	Execute(*expr.child, child_state, sel, count, child);
32: 	if (expr.try_cast) {
33: 		string error_message;
34: 		CastParameters parameters(expr.bound_cast.cast_data.get(), false, &error_message, lstate);
35: 		parameters.query_location = expr.query_location;
36: 		expr.bound_cast.function(child, result, count, parameters);
37: 	} else {
38: 		// cast it to the type specified by the cast expression
39: 		D_ASSERT(result.GetType() == expr.return_type);
40: 		CastParameters parameters(expr.bound_cast.cast_data.get(), false, nullptr, lstate);
41: 		parameters.query_location = expr.query_location;
42: 		expr.bound_cast.function(child, result, count, parameters);
43: 	}
44: }
45: 
46: } // namespace duckdb
[end of src/execution/expression_executor/execute_cast.cpp]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/case_insensitive_map.hpp"
12: #include "duckdb/common/enums/join_type.hpp"
13: #include "duckdb/common/enums/statement_type.hpp"
14: #include "duckdb/common/exception/binder_exception.hpp"
15: #include "duckdb/common/reference_map.hpp"
16: #include "duckdb/common/unordered_map.hpp"
17: #include "duckdb/parser/column_definition.hpp"
18: #include "duckdb/parser/query_node.hpp"
19: #include "duckdb/parser/result_modifier.hpp"
20: #include "duckdb/parser/tableref/delimgetref.hpp"
21: #include "duckdb/parser/tokens.hpp"
22: #include "duckdb/planner/bind_context.hpp"
23: #include "duckdb/planner/bound_statement.hpp"
24: #include "duckdb/planner/bound_tokens.hpp"
25: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
26: #include "duckdb/planner/joinside.hpp"
27: #include "duckdb/planner/bound_constraint.hpp"
28: #include "duckdb/planner/logical_operator.hpp"
29: #include "duckdb/planner/tableref/bound_delimgetref.hpp"
30: 
31: namespace duckdb {
32: class BoundResultModifier;
33: class BoundSelectNode;
34: class ClientContext;
35: class ExpressionBinder;
36: class LimitModifier;
37: class OrderBinder;
38: class TableCatalogEntry;
39: class ViewCatalogEntry;
40: class TableMacroCatalogEntry;
41: class UpdateSetInfo;
42: class LogicalProjection;
43: class LogicalVacuum;
44: 
45: class ColumnList;
46: class ExternalDependency;
47: class TableFunction;
48: class TableStorageInfo;
49: class BoundConstraint;
50: 
51: struct CreateInfo;
52: struct BoundCreateTableInfo;
53: struct CommonTableExpressionInfo;
54: struct BoundParameterMap;
55: struct BoundPragmaInfo;
56: struct BoundLimitNode;
57: struct PivotColumnEntry;
58: struct UnpivotEntry;
59: 
60: enum class BindingMode : uint8_t { STANDARD_BINDING, EXTRACT_NAMES, EXTRACT_REPLACEMENT_SCANS };
61: enum class BinderType : uint8_t { REGULAR_BINDER, VIEW_BINDER };
62: 
63: struct CorrelatedColumnInfo {
64: 	ColumnBinding binding;
65: 	LogicalType type;
66: 	string name;
67: 	idx_t depth;
68: 
69: 	// NOLINTNEXTLINE - work-around bug in clang-tidy
70: 	CorrelatedColumnInfo(ColumnBinding binding, LogicalType type_p, string name_p, idx_t depth)
71: 	    : binding(binding), type(std::move(type_p)), name(std::move(name_p)), depth(depth) {
72: 	}
73: 	explicit CorrelatedColumnInfo(BoundColumnRefExpression &expr)
74: 	    : CorrelatedColumnInfo(expr.binding, expr.return_type, expr.GetName(), expr.depth) {
75: 	}
76: 
77: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
78: 		return binding == rhs.binding;
79: 	}
80: };
81: 
82: //! Bind the parsed query tree to the actual columns present in the catalog.
83: /*!
84:   The binder is responsible for binding tables and columns to actual physical
85:   tables and columns in the catalog. In the process, it also resolves types of
86:   all expressions.
87: */
88: class Binder : public enable_shared_from_this<Binder> {
89: 	friend class ExpressionBinder;
90: 	friend class RecursiveDependentJoinPlanner;
91: 
92: public:
93: 	DUCKDB_API static shared_ptr<Binder> CreateBinder(ClientContext &context, optional_ptr<Binder> parent = nullptr,
94: 	                                                  BinderType binder_type = BinderType::REGULAR_BINDER);
95: 
96: 	//! The client context
97: 	ClientContext &context;
98: 	//! A mapping of names to common table expressions
99: 	case_insensitive_map_t<reference<CommonTableExpressionInfo>> CTE_bindings; // NOLINT
100: 	//! The CTEs that have already been bound
101: 	reference_set_t<CommonTableExpressionInfo> bound_ctes;
102: 	//! The bind context
103: 	BindContext bind_context;
104: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
105: 	//! vector)
106: 	vector<CorrelatedColumnInfo> correlated_columns;
107: 	//! The set of parameter expressions bound by this binder
108: 	optional_ptr<BoundParameterMap> parameters;
109: 	//! The alias for the currently processing subquery, if it exists
110: 	string alias;
111: 	//! Macro parameter bindings (if any)
112: 	optional_ptr<DummyBinding> macro_binding;
113: 	//! The intermediate lambda bindings to bind nested lambdas (if any)
114: 	optional_ptr<vector<DummyBinding>> lambda_bindings;
115: 
116: 	unordered_map<idx_t, LogicalOperator *> recursive_ctes;
117: 
118: public:
119: 	DUCKDB_API BoundStatement Bind(SQLStatement &statement);
120: 	DUCKDB_API BoundStatement Bind(QueryNode &node);
121: 
122: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
123: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info, SchemaCatalogEntry &schema);
124: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info, SchemaCatalogEntry &schema,
125: 	                                                     vector<unique_ptr<Expression>> &bound_defaults);
126: 	static unique_ptr<BoundCreateTableInfo> BindCreateTableCheckpoint(unique_ptr<CreateInfo> info,
127: 	                                                                  SchemaCatalogEntry &schema);
128: 
129: 	static vector<unique_ptr<BoundConstraint>> BindConstraints(ClientContext &context,
130: 	                                                           const vector<unique_ptr<Constraint>> &constraints,
131: 	                                                           const string &table_name, const ColumnList &columns);
132: 	vector<unique_ptr<BoundConstraint>> BindConstraints(const vector<unique_ptr<Constraint>> &constraints,
133: 	                                                    const string &table_name, const ColumnList &columns);
134: 	vector<unique_ptr<BoundConstraint>> BindConstraints(const TableCatalogEntry &table);
135: 	vector<unique_ptr<BoundConstraint>> BindNewConstraints(vector<unique_ptr<Constraint>> &constraints,
136: 	                                                       const string &table_name, const ColumnList &columns);
137: 	unique_ptr<BoundConstraint> BindConstraint(Constraint &constraint, const string &table, const ColumnList &columns);
138: 	unique_ptr<BoundConstraint> BindUniqueConstraint(Constraint &constraint, const string &table,
139: 	                                                 const ColumnList &columns);
140: 
141: 	BoundStatement BindAlterAddIndex(BoundStatement &result, CatalogEntry &entry, unique_ptr<AlterInfo> alter_info);
142: 
143: 	void SetCatalogLookupCallback(catalog_entry_callback_t callback);
144: 	void BindCreateViewInfo(CreateViewInfo &base);
145: 	SchemaCatalogEntry &BindSchema(CreateInfo &info);
146: 	SchemaCatalogEntry &BindCreateFunctionInfo(CreateInfo &info);
147: 
148: 	//! Check usage, and cast named parameters to their types
149: 	static void BindNamedParameters(named_parameter_type_map_t &types, named_parameter_map_t &values,
150: 	                                QueryErrorContext &error_context, string &func_name);
151: 	unique_ptr<BoundPragmaInfo> BindPragma(PragmaInfo &info, QueryErrorContext error_context);
152: 
153: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
154: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
155: 
156: 	//! Generates an unused index for a table
157: 	idx_t GenerateTableIndex();
158: 
159: 	optional_ptr<CatalogEntry> GetCatalogEntry(CatalogType type, const string &catalog, const string &schema,
160: 	                                           const string &name, OnEntryNotFound on_entry_not_found,
161: 	                                           QueryErrorContext &error_context);
162: 
163: 	//! Add a common table expression to the binder
164: 	void AddCTE(const string &name, CommonTableExpressionInfo &cte);
165: 	//! Find all candidate common table expression by name; returns empty vector if none exists
166: 	vector<reference<CommonTableExpressionInfo>> FindCTE(const string &name, bool skip = false);
167: 
168: 	bool CTEIsAlreadyBound(CommonTableExpressionInfo &cte);
169: 
170: 	//! Add the view to the set of currently bound views - used for detecting recursive view definitions
171: 	void AddBoundView(ViewCatalogEntry &view);
172: 
173: 	void PushExpressionBinder(ExpressionBinder &binder);
174: 	void PopExpressionBinder();
175: 	void SetActiveBinder(ExpressionBinder &binder);
176: 	ExpressionBinder &GetActiveBinder();
177: 	bool HasActiveBinder();
178: 
179: 	vector<reference<ExpressionBinder>> &GetActiveBinders();
180: 
181: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
182: 	//! Add a correlated column to this binder (if it does not exist)
183: 	void AddCorrelatedColumn(const CorrelatedColumnInfo &info);
184: 
185: 	unique_ptr<LogicalOperator> BindUpdateSet(LogicalOperator &op, unique_ptr<LogicalOperator> root,
186: 	                                          UpdateSetInfo &set_info, TableCatalogEntry &table,
187: 	                                          vector<PhysicalIndex> &columns);
188: 	void BindDoUpdateSetExpressions(const string &table_alias, LogicalInsert &insert, UpdateSetInfo &set_info,
189: 	                                TableCatalogEntry &table, TableStorageInfo &storage_info);
190: 	void BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &table, InsertStatement &stmt);
191: 
192: 	void BindVacuumTable(LogicalVacuum &vacuum, unique_ptr<LogicalOperator> &root);
193: 
194: 	static void BindSchemaOrCatalog(ClientContext &context, string &catalog, string &schema);
195: 	void BindLogicalType(LogicalType &type, optional_ptr<Catalog> catalog = nullptr,
196: 	                     const string &schema = INVALID_SCHEMA);
197: 
198: 	optional_ptr<Binding> GetMatchingBinding(const string &table_name, const string &column_name, ErrorData &error);
199: 	optional_ptr<Binding> GetMatchingBinding(const string &schema_name, const string &table_name,
200: 	                                         const string &column_name, ErrorData &error);
201: 	optional_ptr<Binding> GetMatchingBinding(const string &catalog_name, const string &schema_name,
202: 	                                         const string &table_name, const string &column_name, ErrorData &error);
203: 
204: 	void SetBindingMode(BindingMode mode);
205: 	BindingMode GetBindingMode();
206: 	void AddTableName(string table_name);
207: 	void AddReplacementScan(const string &table_name, unique_ptr<TableRef> replacement);
208: 	const unordered_set<string> &GetTableNames();
209: 	case_insensitive_map_t<unique_ptr<TableRef>> &GetReplacementScans();
210: 	optional_ptr<SQLStatement> GetRootStatement() {
211: 		return root_statement;
212: 	}
213: 	CatalogEntryRetriever &EntryRetriever() {
214: 		return entry_retriever;
215: 	}
216: 
217: 	void SetCanContainNulls(bool can_contain_nulls);
218: 	void SetAlwaysRequireRebind();
219: 
220: 	StatementProperties &GetStatementProperties();
221: 
222: private:
223: 	//! The parent binder (if any)
224: 	shared_ptr<Binder> parent;
225: 	//! The vector of active binders
226: 	vector<reference<ExpressionBinder>> active_binders;
227: 	//! The count of bound_tables
228: 	idx_t bound_tables;
229: 	//! Whether or not the binder has any unplanned dependent joins that still need to be planned/flattened
230: 	bool has_unplanned_dependent_joins = false;
231: 	//! Whether or not outside dependent joins have been planned and flattened
232: 	bool is_outside_flattened = true;
233: 	//! What kind of node we are binding using this binder
234: 	BinderType binder_type = BinderType::REGULAR_BINDER;
235: 	//! Whether or not the binder can contain NULLs as the root of expressions
236: 	bool can_contain_nulls = false;
237: 	//! The root statement of the query that is currently being parsed
238: 	optional_ptr<SQLStatement> root_statement;
239: 	//! Binding mode
240: 	BindingMode mode = BindingMode::STANDARD_BINDING;
241: 	//! Table names extracted for BindingMode::EXTRACT_NAMES
242: 	unordered_set<string> table_names;
243: 	//! Replacement Scans extracted for BindingMode::EXTRACT_REPLACEMENT_SCANS
244: 	case_insensitive_map_t<unique_ptr<TableRef>> replacement_scans;
245: 	//! The set of bound views
246: 	reference_set_t<ViewCatalogEntry> bound_views;
247: 	//! Used to retrieve CatalogEntry's
248: 	CatalogEntryRetriever entry_retriever;
249: 	//! Unnamed subquery index
250: 	idx_t unnamed_subquery_index = 1;
251: 	//! Statement properties
252: 	StatementProperties prop;
253: 
254: private:
255: 	//! Get the root binder (binder with no parent)
256: 	Binder &GetRootBinder();
257: 	//! Determine the depth of the binder
258: 	idx_t GetBinderDepth() const;
259: 	//! Bind the expressions of generated columns to check for errors
260: 	void BindGeneratedColumns(BoundCreateTableInfo &info);
261: 	//! Bind the default values of the columns of a table
262: 	void BindDefaultValues(const ColumnList &columns, vector<unique_ptr<Expression>> &bound_defaults,
263: 	                       const string &catalog = "", const string &schema = "");
264: 	//! Bind a limit value (LIMIT or OFFSET)
265: 	BoundLimitNode BindLimitValue(OrderBinder &order_binder, unique_ptr<ParsedExpression> limit_val, bool is_percentage,
266: 	                              bool is_offset);
267: 
268: 	//! Move correlated expressions from the child binder to this binder
269: 	void MoveCorrelatedExpressions(Binder &other);
270: 
271: 	//! Tries to bind the table name with replacement scans
272: 	unique_ptr<BoundTableRef> BindWithReplacementScan(ClientContext &context, BaseTableRef &ref);
273: 
274: 	template <class T>
275: 	BoundStatement BindWithCTE(T &statement);
276: 	BoundStatement Bind(SelectStatement &stmt);
277: 	BoundStatement Bind(InsertStatement &stmt);
278: 	BoundStatement Bind(CopyStatement &stmt, CopyToType copy_to_type);
279: 	BoundStatement Bind(DeleteStatement &stmt);
280: 	BoundStatement Bind(UpdateStatement &stmt);
281: 	BoundStatement Bind(CreateStatement &stmt);
282: 	BoundStatement Bind(DropStatement &stmt);
283: 	BoundStatement Bind(AlterStatement &stmt);
284: 	BoundStatement Bind(PrepareStatement &stmt);
285: 	BoundStatement Bind(ExecuteStatement &stmt);
286: 	BoundStatement Bind(TransactionStatement &stmt);
287: 	BoundStatement Bind(PragmaStatement &stmt);
288: 	BoundStatement Bind(ExplainStatement &stmt);
289: 	BoundStatement Bind(VacuumStatement &stmt);
290: 	BoundStatement Bind(RelationStatement &stmt);
291: 	BoundStatement Bind(CallStatement &stmt);
292: 	BoundStatement Bind(ExportStatement &stmt);
293: 	BoundStatement Bind(ExtensionStatement &stmt);
294: 	BoundStatement Bind(SetStatement &stmt);
295: 	BoundStatement Bind(SetVariableStatement &stmt);
296: 	BoundStatement Bind(ResetVariableStatement &stmt);
297: 	BoundStatement Bind(LoadStatement &stmt);
298: 	BoundStatement Bind(LogicalPlanStatement &stmt);
299: 	BoundStatement Bind(AttachStatement &stmt);
300: 	BoundStatement Bind(DetachStatement &stmt);
301: 	BoundStatement Bind(CopyDatabaseStatement &stmt);
302: 	BoundStatement Bind(UpdateExtensionsStatement &stmt);
303: 
304: 	BoundStatement BindReturning(vector<unique_ptr<ParsedExpression>> returning_list, TableCatalogEntry &table,
305: 	                             const string &alias, idx_t update_table_index,
306: 	                             unique_ptr<LogicalOperator> child_operator, BoundStatement result);
307: 
308: 	unique_ptr<QueryNode> BindTableMacro(FunctionExpression &function, TableMacroCatalogEntry &macro_func, idx_t depth);
309: 
310: 	unique_ptr<BoundCTENode> BindMaterializedCTE(CommonTableExpressionMap &cte_map);
311: 	unique_ptr<BoundCTENode> BindCTE(CTENode &statement);
312: 	//! Materializes CTEs if this is expected to improve performance
313: 	bool OptimizeCTEs(QueryNode &node);
314: 
315: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
316: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
317: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
318: 	unique_ptr<BoundQueryNode> BindNode(CTENode &node);
319: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
320: 
321: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
322: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
323: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTENode &node);
324: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTENode &node, unique_ptr<LogicalOperator> base);
325: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
326: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
327: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
328: 
329: 	unique_ptr<BoundTableRef> BindJoin(Binder &parent, TableRef &ref);
330: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
331: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
332: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref, optional_ptr<CommonTableExpressionInfo> cte = nullptr);
333: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
334: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
335: 	unique_ptr<BoundTableRef> Bind(DelimGetRef &ref);
336: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
337: 	unique_ptr<BoundTableRef> Bind(ColumnDataRef &ref);
338: 	unique_ptr<BoundTableRef> Bind(PivotRef &expr);
339: 	unique_ptr<BoundTableRef> Bind(ShowRef &ref);
340: 
341: 	unique_ptr<SelectNode> BindPivot(PivotRef &expr, vector<unique_ptr<ParsedExpression>> all_columns);
342: 	unique_ptr<SelectNode> BindUnpivot(Binder &child_binder, PivotRef &expr,
343: 	                                   vector<unique_ptr<ParsedExpression>> all_columns,
344: 	                                   unique_ptr<ParsedExpression> &where_clause);
345: 	unique_ptr<BoundTableRef> BindBoundPivot(PivotRef &expr);
346: 	void ExtractUnpivotEntries(Binder &child_binder, PivotColumnEntry &entry, vector<UnpivotEntry> &unpivot_entries);
347: 	void ExtractUnpivotColumnName(ParsedExpression &expr, vector<string> &result);
348: 
349: 	bool BindTableFunctionParameters(TableFunctionCatalogEntry &table_function,
350: 	                                 vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
351: 	                                 vector<Value> &parameters, named_parameter_map_t &named_parameters,
352: 	                                 unique_ptr<BoundSubqueryRef> &subquery, ErrorData &error);
353: 	void BindTableInTableOutFunction(vector<unique_ptr<ParsedExpression>> &expressions,
354: 	                                 unique_ptr<BoundSubqueryRef> &subquery);
355: 	unique_ptr<LogicalOperator> BindTableFunction(TableFunction &function, vector<Value> parameters);
356: 	unique_ptr<LogicalOperator> BindTableFunctionInternal(TableFunction &table_function, const TableFunctionRef &ref,
357: 	                                                      vector<Value> parameters,
358: 	                                                      named_parameter_map_t named_parameters,
359: 	                                                      vector<LogicalType> input_table_types,
360: 	                                                      vector<string> input_table_names);
361: 
362: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
363: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
364: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
365: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
366: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
367: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
368: 	unique_ptr<LogicalOperator> CreatePlan(BoundColumnDataRef &ref);
369: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
370: 	unique_ptr<LogicalOperator> CreatePlan(BoundPivotRef &ref);
371: 	unique_ptr<LogicalOperator> CreatePlan(BoundDelimGetRef &ref);
372: 
373: 	BoundStatement BindCopyTo(CopyStatement &stmt, CopyToType copy_to_type);
374: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
375: 
376: 	void PrepareModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
377: 	void BindModifiers(BoundQueryNode &result, idx_t table_index, const vector<string> &names,
378: 	                   const vector<LogicalType> &sql_types, const SelectBindState &bind_state);
379: 
380: 	unique_ptr<BoundResultModifier> BindLimit(OrderBinder &order_binder, LimitModifier &limit_mod);
381: 	unique_ptr<BoundResultModifier> BindLimitPercent(OrderBinder &order_binder, LimitPercentModifier &limit_mod);
382: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
383: 
384: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
385: 
386: 	void PlanSubqueries(unique_ptr<Expression> &expr, unique_ptr<LogicalOperator> &root);
387: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
388: 	unique_ptr<LogicalOperator> PlanLateralJoin(unique_ptr<LogicalOperator> left, unique_ptr<LogicalOperator> right,
389: 	                                            vector<CorrelatedColumnInfo> &correlated_columns,
390: 	                                            JoinType join_type = JoinType::INNER,
391: 	                                            unique_ptr<Expression> condition = nullptr);
392: 
393: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,
394: 	                                                       vector<LogicalType> &target_types,
395: 	                                                       unique_ptr<LogicalOperator> op);
396: 
397: 	BindingAlias FindBinding(const string &using_column, const string &join_side);
398: 	bool TryFindBinding(const string &using_column, const string &join_side, BindingAlias &result);
399: 
400: 	void AddUsingBindingSet(unique_ptr<UsingColumnSet> set);
401: 	BindingAlias RetrieveUsingBinding(Binder &current_binder, optional_ptr<UsingColumnSet> current_set,
402: 	                                  const string &column_name, const string &join_side);
403: 
404: 	void AddCTEMap(CommonTableExpressionMap &cte_map);
405: 
406: 	void ExpandStarExpressions(vector<unique_ptr<ParsedExpression>> &select_list,
407: 	                           vector<unique_ptr<ParsedExpression>> &new_select_list);
408: 	void ExpandStarExpression(unique_ptr<ParsedExpression> expr, vector<unique_ptr<ParsedExpression>> &new_select_list);
409: 	bool FindStarExpression(unique_ptr<ParsedExpression> &expr, StarExpression **star, bool is_root, bool in_columns);
410: 	void ReplaceUnpackedStarExpression(unique_ptr<ParsedExpression> &expr,
411: 	                                   vector<unique_ptr<ParsedExpression>> &replacements);
412: 	void ReplaceStarExpression(unique_ptr<ParsedExpression> &expr, unique_ptr<ParsedExpression> &replacement);
413: 	void BindWhereStarExpression(unique_ptr<ParsedExpression> &expr);
414: 
415: 	//! If only a schema name is provided (e.g. "a.b") then figure out if "a" is a schema or a catalog name
416: 	void BindSchemaOrCatalog(string &catalog_name, string &schema_name);
417: 	const string BindCatalog(string &catalog_name);
418: 	SchemaCatalogEntry &BindCreateSchema(CreateInfo &info);
419: 
420: 	unique_ptr<BoundQueryNode> BindSelectNode(SelectNode &statement, unique_ptr<BoundTableRef> from_table);
421: 
422: 	unique_ptr<LogicalOperator> BindCopyDatabaseSchema(Catalog &source_catalog, const string &target_database_name);
423: 	unique_ptr<LogicalOperator> BindCopyDatabaseData(Catalog &source_catalog, const string &target_database_name);
424: 
425: 	unique_ptr<BoundTableRef> BindShowQuery(ShowRef &ref);
426: 	unique_ptr<BoundTableRef> BindShowTable(ShowRef &ref);
427: 	unique_ptr<BoundTableRef> BindSummarize(ShowRef &ref);
428: 
429: 	unique_ptr<LogicalOperator> UnionOperators(vector<unique_ptr<LogicalOperator>> nodes);
430: 
431: private:
432: 	Binder(ClientContext &context, shared_ptr<Binder> parent, BinderType binder_type);
433: };
434: 
435: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/planner/bind_context.cpp]
1: #include "duckdb/planner/bind_context.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_column_type.hpp"
4: #include "duckdb/catalog/standard_entry.hpp"
5: #include "duckdb/common/pair.hpp"
6: #include "duckdb/common/string_util.hpp"
7: #include "duckdb/parser/expression/columnref_expression.hpp"
8: #include "duckdb/parser/expression/operator_expression.hpp"
9: #include "duckdb/parser/expression/positional_reference_expression.hpp"
10: #include "duckdb/parser/expression/star_expression.hpp"
11: #include "duckdb/parser/tableref/subqueryref.hpp"
12: #include "duckdb/parser/tableref/table_function_ref.hpp"
13: #include "duckdb/planner/bound_query_node.hpp"
14: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
15: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
16: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
17: #include "duckdb/planner/expression_binder/constant_binder.hpp"
18: #include "duckdb/planner/binder.hpp"
19: 
20: #include <algorithm>
21: 
22: namespace duckdb {
23: 
24: BindContext::BindContext(Binder &binder) : binder(binder) {
25: }
26: 
27: string MinimumUniqueAlias(const BindingAlias &alias, const BindingAlias &other) {
28: 	if (!StringUtil::CIEquals(alias.GetAlias(), other.GetAlias())) {
29: 		return alias.GetAlias();
30: 	}
31: 	if (!StringUtil::CIEquals(alias.GetSchema(), other.GetSchema())) {
32: 		return alias.GetSchema() + "." + alias.GetAlias();
33: 	}
34: 	return alias.ToString();
35: }
36: 
37: optional_ptr<Binding> BindContext::GetMatchingBinding(const string &column_name) {
38: 	optional_ptr<Binding> result;
39: 	for (auto &binding_ptr : bindings_list) {
40: 		auto &binding = *binding_ptr;
41: 		auto is_using_binding = GetUsingBinding(column_name, binding.alias);
42: 		if (is_using_binding) {
43: 			continue;
44: 		}
45: 		if (binding.HasMatchingBinding(column_name)) {
46: 			if (result || is_using_binding) {
47: 				throw BinderException("Ambiguous reference to column name \"%s\" (use: \"%s.%s\" "
48: 				                      "or \"%s.%s\")",
49: 				                      column_name, MinimumUniqueAlias(result->alias, binding.alias), column_name,
50: 				                      MinimumUniqueAlias(binding.alias, result->alias), column_name);
51: 			}
52: 			result = &binding;
53: 		}
54: 	}
55: 	return result;
56: }
57: 
58: vector<string> BindContext::GetSimilarBindings(const string &column_name) {
59: 	vector<pair<string, double>> scores;
60: 	for (auto &binding_ptr : bindings_list) {
61: 		auto binding = *binding_ptr;
62: 		for (auto &name : binding.names) {
63: 			double distance = StringUtil::SimilarityRating(name, column_name);
64: 			// check if we need to qualify the column
65: 			auto matching_bindings = GetMatchingBindings(name);
66: 			if (matching_bindings.size() > 1) {
67: 				scores.emplace_back(binding.GetAlias() + "." + name, distance);
68: 			} else {
69: 				scores.emplace_back(name, distance);
70: 			}
71: 		}
72: 	}
73: 	return StringUtil::TopNStrings(scores);
74: }
75: 
76: void BindContext::AddUsingBinding(const string &column_name, UsingColumnSet &set) {
77: 	using_columns[column_name].insert(set);
78: }
79: 
80: void BindContext::AddUsingBindingSet(unique_ptr<UsingColumnSet> set) {
81: 	using_column_sets.push_back(std::move(set));
82: }
83: 
84: optional_ptr<UsingColumnSet> BindContext::GetUsingBinding(const string &column_name) {
85: 	auto entry = using_columns.find(column_name);
86: 	if (entry == using_columns.end()) {
87: 		return nullptr;
88: 	}
89: 	auto &using_bindings = entry->second;
90: 	if (using_bindings.size() > 1) {
91: 		string error = "Ambiguous column reference: column \"" + column_name + "\" can refer to either:\n";
92: 		for (auto &using_set_ref : using_bindings) {
93: 			auto &using_set = using_set_ref.get();
94: 			string result_bindings;
95: 			for (auto &binding : using_set.bindings) {
96: 				if (result_bindings.empty()) {
97: 					result_bindings = "[";
98: 				} else {
99: 					result_bindings += ", ";
100: 				}
101: 				result_bindings += binding.GetAlias();
102: 				result_bindings += ".";
103: 				result_bindings += GetActualColumnName(binding, column_name);
104: 			}
105: 			error += result_bindings + "]";
106: 		}
107: 		throw BinderException(error);
108: 	}
109: 	for (auto &using_set : using_bindings) {
110: 		return &using_set.get();
111: 	}
112: 	throw InternalException("Using binding found but no entries");
113: }
114: 
115: optional_ptr<UsingColumnSet> BindContext::GetUsingBinding(const string &column_name, const BindingAlias &binding) {
116: 	if (!binding.IsSet()) {
117: 		throw InternalException("GetUsingBinding: expected non-empty binding_name");
118: 	}
119: 	auto entry = using_columns.find(column_name);
120: 	if (entry == using_columns.end()) {
121: 		return nullptr;
122: 	}
123: 	auto &using_bindings = entry->second;
124: 	for (auto &using_set_ref : using_bindings) {
125: 		auto &using_set = using_set_ref.get();
126: 		auto &bindings = using_set.bindings;
127: 		for (auto &using_binding : bindings) {
128: 			if (using_binding == binding) {
129: 				return &using_set;
130: 			}
131: 		}
132: 	}
133: 	return nullptr;
134: }
135: 
136: void BindContext::RemoveUsingBinding(const string &column_name, UsingColumnSet &set) {
137: 	auto entry = using_columns.find(column_name);
138: 	if (entry == using_columns.end()) {
139: 		throw InternalException("Attempting to remove using binding that is not there");
140: 	}
141: 	auto &bindings = entry->second;
142: 	if (bindings.find(set) != bindings.end()) {
143: 		bindings.erase(set);
144: 	}
145: 	if (bindings.empty()) {
146: 		using_columns.erase(column_name);
147: 	}
148: }
149: 
150: void BindContext::TransferUsingBinding(BindContext &current_context, optional_ptr<UsingColumnSet> current_set,
151:                                        UsingColumnSet &new_set, const string &using_column) {
152: 	AddUsingBinding(using_column, new_set);
153: 	if (current_set) {
154: 		current_context.RemoveUsingBinding(using_column, *current_set);
155: 	}
156: }
157: 
158: string BindContext::GetActualColumnName(Binding &binding, const string &column_name) {
159: 	column_t binding_index;
160: 	if (!binding.TryGetBindingIndex(column_name, binding_index)) { // LCOV_EXCL_START
161: 		throw InternalException("Binding with name \"%s\" does not have a column named \"%s\"", binding.GetAlias(),
162: 		                        column_name);
163: 	} // LCOV_EXCL_STOP
164: 	return binding.names[binding_index];
165: }
166: 
167: string BindContext::GetActualColumnName(const BindingAlias &binding_alias, const string &column_name) {
168: 	ErrorData error;
169: 	auto binding = GetBinding(binding_alias, error);
170: 	if (!binding) {
171: 		throw InternalException("No binding with name \"%s\": %s", binding_alias.GetAlias(), error.RawMessage());
172: 	}
173: 	return GetActualColumnName(*binding, column_name);
174: }
175: 
176: vector<reference<Binding>> BindContext::GetMatchingBindings(const string &column_name) {
177: 	vector<reference<Binding>> result;
178: 	for (auto &binding_ptr : bindings_list) {
179: 		auto &binding = *binding_ptr;
180: 		if (binding.HasMatchingBinding(column_name)) {
181: 			result.push_back(binding);
182: 		}
183: 	}
184: 	return result;
185: }
186: 
187: unique_ptr<ParsedExpression> BindContext::ExpandGeneratedColumn(TableBinding &table_binding,
188:                                                                 const string &column_name) {
189: 	auto result = table_binding.ExpandGeneratedColumn(column_name);
190: 	result->alias = column_name;
191: 	return result;
192: }
193: 
194: unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const BindingAlias &table_alias,
195:                                                                 const string &column_name, ColumnBindType bind_type) {
196: 	return CreateColumnReference(table_alias.GetCatalog(), table_alias.GetSchema(), table_alias.GetAlias(), column_name,
197: 	                             bind_type);
198: }
199: 
200: unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const string &table_name, const string &column_name,
201:                                                                 ColumnBindType bind_type) {
202: 	string schema_name;
203: 	return CreateColumnReference(schema_name, table_name, column_name, bind_type);
204: }
205: 
206: static bool ColumnIsGenerated(Binding &binding, column_t index) {
207: 	if (binding.binding_type != BindingType::TABLE) {
208: 		return false;
209: 	}
210: 	auto &table_binding = binding.Cast<TableBinding>();
211: 	auto catalog_entry = table_binding.GetStandardEntry();
212: 	if (!catalog_entry) {
213: 		return false;
214: 	}
215: 	if (index == COLUMN_IDENTIFIER_ROW_ID) {
216: 		return false;
217: 	}
218: 	D_ASSERT(catalog_entry->type == CatalogType::TABLE_ENTRY);
219: 	auto &table_entry = catalog_entry->Cast<TableCatalogEntry>();
220: 	return table_entry.GetColumn(LogicalIndex(index)).Generated();
221: }
222: 
223: unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const string &catalog_name, const string &schema_name,
224:                                                                 const string &table_name, const string &column_name,
225:                                                                 ColumnBindType bind_type) {
226: 	ErrorData error;
227: 	vector<string> names;
228: 	if (!catalog_name.empty()) {
229: 		names.push_back(catalog_name);
230: 	}
231: 	if (!schema_name.empty()) {
232: 		names.push_back(schema_name);
233: 	}
234: 	names.push_back(table_name);
235: 	names.push_back(column_name);
236: 
237: 	BindingAlias alias(catalog_name, schema_name, table_name);
238: 	auto result = make_uniq<ColumnRefExpression>(std::move(names));
239: 	auto binding = GetBinding(alias, column_name, error);
240: 	if (!binding) {
241: 		return std::move(result);
242: 	}
243: 	auto column_index = binding->GetBindingIndex(column_name);
244: 	if (bind_type == ColumnBindType::EXPAND_GENERATED_COLUMNS && ColumnIsGenerated(*binding, column_index)) {
245: 		return ExpandGeneratedColumn(binding->Cast<TableBinding>(), column_name);
246: 	} else if (column_index < binding->names.size() && binding->names[column_index] != column_name) {
247: 		// because of case insensitivity in the binder we rename the column to the original name
248: 		// as it appears in the binding itself
249: 		result->alias = binding->names[column_index];
250: 	}
251: 	return std::move(result);
252: }
253: 
254: unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const string &schema_name, const string &table_name,
255:                                                                 const string &column_name, ColumnBindType bind_type) {
256: 	string catalog_name;
257: 	return CreateColumnReference(catalog_name, schema_name, table_name, column_name, bind_type);
258: }
259: 
260: optional_ptr<Binding> BindContext::GetCTEBinding(const string &ctename) {
261: 	auto match = cte_bindings.find(ctename);
262: 	if (match == cte_bindings.end()) {
263: 		return nullptr;
264: 	}
265: 	return match->second.get();
266: }
267: 
268: vector<reference<Binding>> BindContext::GetBindings(const BindingAlias &alias, ErrorData &out_error) {
269: 	if (!alias.IsSet()) {
270: 		throw InternalException("BindingAlias is not set");
271: 	}
272: 	vector<reference<Binding>> matching_bindings;
273: 	for (auto &binding : bindings_list) {
274: 		if (binding->alias.Matches(alias)) {
275: 			matching_bindings.push_back(*binding);
276: 		}
277: 	}
278: 	if (matching_bindings.empty()) {
279: 		// alias not found in this BindContext
280: 		vector<string> candidates;
281: 		for (auto &binding : bindings_list) {
282: 			candidates.push_back(binding->alias.GetAlias());
283: 		}
284: 		string candidate_str = StringUtil::CandidatesMessage(StringUtil::TopNJaroWinkler(candidates, alias.GetAlias()),
285: 		                                                     "Candidate tables");
286: 		out_error = ErrorData(ExceptionType::BINDER, StringUtil::Format("Referenced table \"%s\" not found!%s",
287: 		                                                                alias.GetAlias(), candidate_str));
288: 	}
289: 	return matching_bindings;
290: }
291: 
292: string BindContext::AmbiguityException(const BindingAlias &alias, const vector<reference<Binding>> &bindings) {
293: 	D_ASSERT(bindings.size() > 1);
294: 	// found multiple matching aliases
295: 	string result = "(use: ";
296: 	for (idx_t i = 0; i < bindings.size(); i++) {
297: 		if (i > 0) {
298: 			if (i + 1 == bindings.size()) {
299: 				result += " or ";
300: 			} else {
301: 				result += ", ";
302: 			}
303: 		}
304: 		// find the minimum alias that uniquely describes this table reference
305: 		auto &current_alias = bindings[i].get().alias;
306: 		string minimum_alias;
307: 		bool duplicate_alias = false;
308: 		for (idx_t k = 0; k < bindings.size(); k++) {
309: 			if (k == i) {
310: 				continue;
311: 			}
312: 			auto &other_alias = bindings[k].get().alias;
313: 			if (current_alias == other_alias) {
314: 				duplicate_alias = true;
315: 			}
316: 			string new_minimum_alias = MinimumUniqueAlias(current_alias, other_alias);
317: 			if (new_minimum_alias.size() > minimum_alias.size()) {
318: 				minimum_alias = std::move(new_minimum_alias);
319: 			}
320: 		}
321: 		if (duplicate_alias) {
322: 			result = "(duplicate alias \"" + alias.ToString() +
323: 			         "\", explicitly alias one of the tables using \"AS my_alias\"";
324: 		} else {
325: 			result += minimum_alias;
326: 		}
327: 	}
328: 	result += ")";
329: 	return result;
330: }
331: 
332: optional_ptr<Binding> BindContext::GetBinding(const BindingAlias &alias, const string &column_name,
333:                                               ErrorData &out_error) {
334: 	auto matching_bindings = GetBindings(alias, out_error);
335: 	if (matching_bindings.empty()) {
336: 		// no bindings found
337: 		return nullptr;
338: 	}
339: 
340: 	optional_ptr<Binding> result;
341: 	// find the binding that this column name belongs to
342: 	for (auto &binding_ref : matching_bindings) {
343: 		auto &binding = binding_ref.get();
344: 		if (!binding.HasMatchingBinding(column_name)) {
345: 			continue;
346: 		}
347: 		if (result) {
348: 			// we found multiple bindings that this column name belongs to - ambiguity
349: 			string helper_message = AmbiguityException(alias, matching_bindings);
350: 			throw BinderException("Ambiguous reference to table \"%s\" %s", alias.ToString(), helper_message);
351: 		} else {
352: 			result = &binding;
353: 		}
354: 	}
355: 	if (!result) {
356: 		// found the table binding - but could not find the column
357: 		out_error = matching_bindings[0].get().ColumnNotFoundError(column_name);
358: 	}
359: 	return result;
360: }
361: 
362: optional_ptr<Binding> BindContext::GetBinding(const BindingAlias &alias, ErrorData &out_error) {
363: 	auto matching_bindings = GetBindings(alias, out_error);
364: 	if (matching_bindings.empty()) {
365: 		return nullptr;
366: 	}
367: 	if (matching_bindings.size() > 1) {
368: 		string helper_message = AmbiguityException(alias, matching_bindings);
369: 		throw BinderException("Ambiguous reference to table \"%s\" %s", alias.ToString(), helper_message);
370: 	}
371: 	// found a single matching alias
372: 	return &matching_bindings[0].get();
373: }
374: 
375: optional_ptr<Binding> BindContext::GetBinding(const string &name, ErrorData &out_error) {
376: 	return GetBinding(BindingAlias(name), out_error);
377: }
378: 
379: BindingAlias GetBindingAlias(ColumnRefExpression &colref) {
380: 	if (colref.column_names.size() <= 1 || colref.column_names.size() > 4) {
381: 		throw InternalException("Cannot get binding alias from column ref unless it has 2..4 entries");
382: 	}
383: 	if (colref.column_names.size() >= 4) {
384: 		return BindingAlias(colref.column_names[0], colref.column_names[1], colref.column_names[2]);
385: 	}
386: 	if (colref.column_names.size() == 3) {
387: 		return BindingAlias(colref.column_names[0], colref.column_names[1]);
388: 	}
389: 	return BindingAlias(colref.column_names[0]);
390: }
391: 
392: BindResult BindContext::BindColumn(ColumnRefExpression &colref, idx_t depth) {
393: 	if (!colref.IsQualified()) {
394: 		throw InternalException("Could not bind alias \"%s\"!", colref.GetColumnName());
395: 	}
396: 
397: 	ErrorData error;
398: 	BindingAlias alias;
399: 	auto binding = GetBinding(GetBindingAlias(colref), colref.GetColumnName(), error);
400: 	if (!binding) {
401: 		return BindResult(std::move(error));
402: 	}
403: 	return binding->Bind(colref, depth);
404: }
405: 
406: string BindContext::BindColumn(PositionalReferenceExpression &ref, string &table_name, string &column_name) {
407: 	idx_t total_columns = 0;
408: 	idx_t current_position = ref.index - 1;
409: 	for (auto &entry : bindings_list) {
410: 		auto &binding = *entry;
411: 		idx_t entry_column_count = binding.names.size();
412: 		if (ref.index == 0) {
413: 			// this is a row id
414: 			table_name = binding.alias.GetAlias();
415: 			column_name = "rowid";
416: 			return string();
417: 		}
418: 		if (current_position < entry_column_count) {
419: 			table_name = binding.alias.GetAlias();
420: 			column_name = binding.names[current_position];
421: 			return string();
422: 		} else {
423: 			total_columns += entry_column_count;
424: 			current_position -= entry_column_count;
425: 		}
426: 	}
427: 	return StringUtil::Format("Positional reference %d out of range (total %d columns)", ref.index, total_columns);
428: }
429: 
430: unique_ptr<ColumnRefExpression> BindContext::PositionToColumn(PositionalReferenceExpression &ref) {
431: 	string table_name, column_name;
432: 
433: 	string error = BindColumn(ref, table_name, column_name);
434: 	if (!error.empty()) {
435: 		throw BinderException(error);
436: 	}
437: 	return make_uniq<ColumnRefExpression>(column_name, table_name);
438: }
439: 
440: struct ExclusionListInfo {
441: 	explicit ExclusionListInfo(vector<unique_ptr<ParsedExpression>> &new_select_list)
442: 	    : new_select_list(new_select_list) {
443: 	}
444: 
445: 	vector<unique_ptr<ParsedExpression>> &new_select_list;
446: 	case_insensitive_set_t excluded_columns;
447: 	qualified_column_set_t excluded_qualified_columns;
448: };
449: 
450: bool CheckExclusionList(StarExpression &expr, const QualifiedColumnName &qualified_name, ExclusionListInfo &info) {
451: 	if (expr.exclude_list.find(qualified_name) != expr.exclude_list.end()) {
452: 		info.excluded_qualified_columns.insert(qualified_name);
453: 		return true;
454: 	}
455: 	auto entry = expr.replace_list.find(qualified_name.column);
456: 	if (entry != expr.replace_list.end()) {
457: 		auto new_entry = entry->second->Copy();
458: 		new_entry->alias = entry->first;
459: 		info.excluded_columns.insert(entry->first);
460: 		info.new_select_list.push_back(std::move(new_entry));
461: 		return true;
462: 	}
463: 	return false;
464: }
465: 
466: void HandleRename(StarExpression &expr, const QualifiedColumnName &qualified_name, ParsedExpression &new_expr) {
467: 	auto rename_entry = expr.rename_list.find(qualified_name);
468: 	if (rename_entry != expr.rename_list.end()) {
469: 		new_expr.alias = rename_entry->second;
470: 	}
471: }
472: 
473: void BindContext::GenerateAllColumnExpressions(StarExpression &expr,
474:                                                vector<unique_ptr<ParsedExpression>> &new_select_list) {
475: 	if (bindings_list.empty()) {
476: 		throw BinderException("* expression without FROM clause!");
477: 	}
478: 	ExclusionListInfo exclusion_info(new_select_list);
479: 	if (expr.relation_name.empty()) {
480: 		// SELECT * case
481: 		// bind all expressions of each table in-order
482: 		reference_set_t<UsingColumnSet> handled_using_columns;
483: 		for (auto &entry : bindings_list) {
484: 			auto &binding = *entry;
485: 			for (auto &column_name : binding.names) {
486: 				QualifiedColumnName qualified_column(binding.alias, column_name);
487: 				if (CheckExclusionList(expr, qualified_column, exclusion_info)) {
488: 					continue;
489: 				}
490: 				// check if this column is a USING column
491: 				auto using_binding_ptr = GetUsingBinding(column_name, binding.alias);
492: 				if (using_binding_ptr) {
493: 					auto &using_binding = *using_binding_ptr;
494: 					// it is!
495: 					// check if we have already emitted the using column
496: 					if (handled_using_columns.find(using_binding) != handled_using_columns.end()) {
497: 						// we have! bail out
498: 						continue;
499: 					}
500: 					// we have not! output the using column
501: 					if (!using_binding.primary_binding.IsSet()) {
502: 						// no primary binding: output a coalesce
503: 						auto coalesce = make_uniq<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
504: 						for (auto &child_binding : using_binding.bindings) {
505: 							coalesce->children.push_back(make_uniq<ColumnRefExpression>(column_name, child_binding));
506: 						}
507: 						coalesce->alias = column_name;
508: 						HandleRename(expr, qualified_column, *coalesce);
509: 						new_select_list.push_back(std::move(coalesce));
510: 					} else {
511: 						// primary binding: output the qualified column ref
512: 						auto new_expr = make_uniq<ColumnRefExpression>(column_name, using_binding.primary_binding);
513: 						HandleRename(expr, qualified_column, *new_expr);
514: 						new_select_list.push_back(std::move(new_expr));
515: 					}
516: 					handled_using_columns.insert(using_binding);
517: 					continue;
518: 				}
519: 				auto new_expr =
520: 				    CreateColumnReference(binding.alias, column_name, ColumnBindType::DO_NOT_EXPAND_GENERATED_COLUMNS);
521: 				HandleRename(expr, qualified_column, *new_expr);
522: 				new_select_list.push_back(std::move(new_expr));
523: 			}
524: 		}
525: 	} else {
526: 		// SELECT tbl.* case
527: 		// SELECT struct.* case
528: 		ErrorData error;
529: 		auto binding = GetBinding(expr.relation_name, error);
530: 		bool is_struct_ref = false;
531: 		if (!binding) {
532: 			binding = GetMatchingBinding(expr.relation_name);
533: 			if (!binding) {
534: 				error.Throw();
535: 			}
536: 			is_struct_ref = true;
537: 		}
538: 
539: 		if (is_struct_ref) {
540: 			auto col_idx = binding->GetBindingIndex(expr.relation_name);
541: 			auto col_type = binding->types[col_idx];
542: 			if (col_type.id() != LogicalTypeId::STRUCT) {
543: 				throw BinderException(StringUtil::Format(
544: 				    "Cannot extract field from expression \"%s\" because it is not a struct", expr.ToString()));
545: 			}
546: 			auto &struct_children = StructType::GetChildTypes(col_type);
547: 			vector<string> column_names(3);
548: 			column_names[0] = binding->alias.GetAlias();
549: 			column_names[1] = expr.relation_name;
550: 			for (auto &child : struct_children) {
551: 				QualifiedColumnName qualified_name(child.first);
552: 				if (CheckExclusionList(expr, qualified_name, exclusion_info)) {
553: 					continue;
554: 				}
555: 				column_names[2] = child.first;
556: 				auto new_expr = make_uniq<ColumnRefExpression>(column_names);
557: 				HandleRename(expr, qualified_name, *new_expr);
558: 				new_select_list.push_back(std::move(new_expr));
559: 			}
560: 		} else {
561: 			for (auto &column_name : binding->names) {
562: 				QualifiedColumnName qualified_name(binding->alias, column_name);
563: 				if (CheckExclusionList(expr, qualified_name, exclusion_info)) {
564: 					continue;
565: 				}
566: 				auto new_expr =
567: 				    CreateColumnReference(binding->alias, column_name, ColumnBindType::DO_NOT_EXPAND_GENERATED_COLUMNS);
568: 				HandleRename(expr, qualified_name, *new_expr);
569: 				new_select_list.push_back(std::move(new_expr));
570: 			}
571: 		}
572: 	}
573: 	if (binder.GetBindingMode() == BindingMode::EXTRACT_NAMES) {
574: 		expr.exclude_list.clear();
575: 		expr.replace_list.clear();
576: 	}
577: 	for (auto &excluded : expr.exclude_list) {
578: 		if (exclusion_info.excluded_qualified_columns.find(excluded) ==
579: 		    exclusion_info.excluded_qualified_columns.end()) {
580: 			throw BinderException("Column \"%s\" in EXCLUDE list not found in %s", excluded.ToString(),
581: 			                      expr.relation_name.empty() ? "FROM clause" : expr.relation_name.c_str());
582: 		}
583: 	}
584: 	for (auto &entry : expr.replace_list) {
585: 		if (exclusion_info.excluded_columns.find(entry.first) == exclusion_info.excluded_columns.end()) {
586: 			throw BinderException("Column \"%s\" in REPLACE list not found in %s", entry.first,
587: 			                      expr.relation_name.empty() ? "FROM clause" : expr.relation_name.c_str());
588: 		}
589: 	}
590: }
591: 
592: void BindContext::GetTypesAndNames(vector<string> &result_names, vector<LogicalType> &result_types) {
593: 	for (auto &binding_entry : bindings_list) {
594: 		auto &binding = *binding_entry;
595: 		D_ASSERT(binding.names.size() == binding.types.size());
596: 		for (idx_t i = 0; i < binding.names.size(); i++) {
597: 			result_names.push_back(binding.names[i]);
598: 			result_types.push_back(binding.types[i]);
599: 		}
600: 	}
601: }
602: 
603: void BindContext::AddBinding(unique_ptr<Binding> binding) {
604: 	bindings_list.push_back(std::move(binding));
605: }
606: 
607: void BindContext::AddBaseTable(idx_t index, const string &alias, const vector<string> &names,
608:                                const vector<LogicalType> &types, vector<ColumnIndex> &bound_column_ids,
609:                                StandardEntry &entry, bool add_row_id) {
610: 	AddBinding(make_uniq<TableBinding>(alias, types, names, bound_column_ids, &entry, index, add_row_id));
611: }
612: 
613: void BindContext::AddBaseTable(idx_t index, const string &alias, const vector<string> &names,
614:                                const vector<LogicalType> &types, vector<ColumnIndex> &bound_column_ids,
615:                                const string &table_name) {
616: 	AddBinding(make_uniq<TableBinding>(alias.empty() ? table_name : alias, types, names, bound_column_ids, nullptr,
617: 	                                   index, true));
618: }
619: 
620: void BindContext::AddTableFunction(idx_t index, const string &alias, const vector<string> &names,
621:                                    const vector<LogicalType> &types, vector<ColumnIndex> &bound_column_ids,
622:                                    optional_ptr<StandardEntry> entry) {
623: 	AddBinding(make_uniq<TableBinding>(alias, types, names, bound_column_ids, entry, index));
624: }
625: 
626: static string AddColumnNameToBinding(const string &base_name, case_insensitive_set_t &current_names) {
627: 	idx_t index = 1;
628: 	string name = base_name;
629: 	while (current_names.find(name) != current_names.end()) {
630: 		name = base_name + "_" + std::to_string(index++);
631: 	}
632: 	current_names.insert(name);
633: 	return name;
634: }
635: 
636: vector<string> BindContext::AliasColumnNames(const string &table_name, const vector<string> &names,
637:                                              const vector<string> &column_aliases) {
638: 	vector<string> result;
639: 	if (column_aliases.size() > names.size()) {
640: 		throw BinderException("table \"%s\" has %lld columns available but %lld columns specified", table_name,
641: 		                      names.size(), column_aliases.size());
642: 	}
643: 	case_insensitive_set_t current_names;
644: 	// use any provided column aliases first
645: 	for (idx_t i = 0; i < column_aliases.size(); i++) {
646: 		result.push_back(AddColumnNameToBinding(column_aliases[i], current_names));
647: 	}
648: 	// if not enough aliases were provided, use the default names for remaining columns
649: 	for (idx_t i = column_aliases.size(); i < names.size(); i++) {
650: 		result.push_back(AddColumnNameToBinding(names[i], current_names));
651: 	}
652: 	return result;
653: }
654: 
655: void BindContext::AddSubquery(idx_t index, const string &alias, SubqueryRef &ref, BoundQueryNode &subquery) {
656: 	auto names = AliasColumnNames(alias, subquery.names, ref.column_name_alias);
657: 	AddGenericBinding(index, alias, names, subquery.types);
658: }
659: 
660: void BindContext::AddEntryBinding(idx_t index, const string &alias, const vector<string> &names,
661:                                   const vector<LogicalType> &types, StandardEntry &entry) {
662: 	AddBinding(make_uniq<EntryBinding>(alias, types, names, index, entry));
663: }
664: 
665: void BindContext::AddView(idx_t index, const string &alias, SubqueryRef &ref, BoundQueryNode &subquery,
666:                           ViewCatalogEntry &view) {
667: 	auto names = AliasColumnNames(alias, subquery.names, ref.column_name_alias);
668: 	AddEntryBinding(index, alias, names, subquery.types, view.Cast<StandardEntry>());
669: }
670: 
671: void BindContext::AddSubquery(idx_t index, const string &alias, TableFunctionRef &ref, BoundQueryNode &subquery) {
672: 	auto names = AliasColumnNames(alias, subquery.names, ref.column_name_alias);
673: 	AddGenericBinding(index, alias, names, subquery.types);
674: }
675: 
676: void BindContext::AddGenericBinding(idx_t index, const string &alias, const vector<string> &names,
677:                                     const vector<LogicalType> &types) {
678: 	AddBinding(make_uniq<Binding>(BindingType::BASE, BindingAlias(alias), types, names, index));
679: }
680: 
681: void BindContext::AddCTEBinding(idx_t index, const string &alias, const vector<string> &names,
682:                                 const vector<LogicalType> &types) {
683: 	auto binding = make_shared_ptr<Binding>(BindingType::BASE, BindingAlias(alias), types, names, index);
684: 
685: 	if (cte_bindings.find(alias) != cte_bindings.end()) {
686: 		throw BinderException("Duplicate CTE binding \"%s\" in query!", alias);
687: 	}
688: 	cte_bindings[alias] = std::move(binding);
689: 	cte_references[alias] = make_shared_ptr<idx_t>(0);
690: }
691: 
692: void BindContext::AddContext(BindContext other) {
693: 	for (auto &binding : other.bindings_list) {
694: 		AddBinding(std::move(binding));
695: 	}
696: 	for (auto &entry : other.using_columns) {
697: 		for (auto &alias : entry.second) {
698: #ifdef DEBUG
699: 			for (auto &other_alias : using_columns[entry.first]) {
700: 				for (auto &col : alias.get().bindings) {
701: 					D_ASSERT(std::find(other_alias.get().bindings.begin(), other_alias.get().bindings.end(), col) ==
702: 					         other_alias.get().bindings.end());
703: 				}
704: 			}
705: #endif
706: 			using_columns[entry.first].insert(alias);
707: 		}
708: 	}
709: }
710: 
711: vector<BindingAlias> BindContext::GetBindingAliases() {
712: 	vector<BindingAlias> result;
713: 	for (auto &binding : bindings_list) {
714: 		result.push_back(BindingAlias(binding->alias));
715: 	}
716: 	return result;
717: }
718: 
719: void BindContext::RemoveContext(const vector<BindingAlias> &aliases) {
720: 	for (auto &alias : aliases) {
721: 		auto it = std::remove_if(bindings_list.begin(), bindings_list.end(),
722: 		                         [&](unique_ptr<Binding> &x) { return x->alias == alias; });
723: 		bindings_list.erase(it, bindings_list.end());
724: 	}
725: }
726: 
727: } // namespace duckdb
[end of src/planner/bind_context.cpp]
[start of src/planner/binder/expression/bind_star_expression.cpp]
1: #include "duckdb/planner/binder.hpp"
2: #include "duckdb/parser/expression/star_expression.hpp"
3: #include "duckdb/parser/expression/constant_expression.hpp"
4: #include "duckdb/parser/expression/columnref_expression.hpp"
5: #include "duckdb/parser/expression/operator_expression.hpp"
6: #include "duckdb/planner/expression_binder/table_function_binder.hpp"
7: #include "duckdb/parser/parsed_expression_iterator.hpp"
8: #include "duckdb/execution/expression_executor.hpp"
9: #include "duckdb/function/scalar/regexp.hpp"
10: #include "duckdb/parser/expression/function_expression.hpp"
11: 
12: namespace duckdb {
13: 
14: string GetColumnsStringValue(ParsedExpression &expr) {
15: 	if (expr.type == ExpressionType::COLUMN_REF) {
16: 		auto &colref = expr.Cast<ColumnRefExpression>();
17: 		return colref.GetColumnName();
18: 	} else {
19: 		return expr.ToString();
20: 	}
21: }
22: 
23: bool Binder::FindStarExpression(unique_ptr<ParsedExpression> &expr, StarExpression **star, bool is_root,
24:                                 bool in_columns) {
25: 	bool has_star = false;
26: 	if (expr->GetExpressionClass() == ExpressionClass::STAR) {
27: 		auto &current_star = expr->Cast<StarExpression>();
28: 		if (StarExpression::IsStar(*expr)) {
29: 			if (is_root) {
30: 				D_ASSERT(!in_columns);
31: 				// At the root level
32: 				*star = &current_star;
33: 				return true;
34: 			}
35: 
36: 			if (!in_columns) {
37: 				// '*' can only appear inside COLUMNS or at the root level
38: 				throw BinderException(
39: 				    "STAR expression is only allowed as the root element of an expression. Use COLUMNS(*) instead.");
40: 			}
41: 
42: 			if (!current_star.replace_list.empty()) {
43: 				// '*' inside COLUMNS can not have a REPLACE list
44: 				throw BinderException(
45: 				    "STAR expression with REPLACE list is only allowed as the root element of COLUMNS");
46: 			}
47: 
48: 			// '*' expression inside a COLUMNS - convert to a constant list of strings (column names)
49: 			vector<unique_ptr<ParsedExpression>> star_list;
50: 			bind_context.GenerateAllColumnExpressions(current_star, star_list);
51: 
52: 			vector<Value> values;
53: 			values.reserve(star_list.size());
54: 			for (auto &element : star_list) {
55: 				values.emplace_back(GetColumnsStringValue(*element));
56: 			}
57: 			D_ASSERT(!values.empty());
58: 			expr = make_uniq<ConstantExpression>(Value::LIST(LogicalType::VARCHAR, values));
59: 			return true;
60: 		}
61: 		if (in_columns) {
62: 			throw BinderException("COLUMNS expression is not allowed inside another COLUMNS expression");
63: 		}
64: 		in_columns = true;
65: 
66: 		if (*star) {
67: 			// we can have multiple
68: 			if (!(*star)->Equals(current_star)) {
69: 				throw BinderException(*expr,
70: 				                      "Multiple different STAR/COLUMNS in the same expression are not supported");
71: 			}
72: 			return true;
73: 		}
74: 		*star = &current_star;
75: 		has_star = true;
76: 	}
77: 	ParsedExpressionIterator::EnumerateChildren(*expr, [&](unique_ptr<ParsedExpression> &child_expr) {
78: 		if (FindStarExpression(child_expr, star, false, in_columns)) {
79: 			has_star = true;
80: 		}
81: 	});
82: 	return has_star;
83: }
84: 
85: void Binder::ReplaceStarExpression(unique_ptr<ParsedExpression> &expr, unique_ptr<ParsedExpression> &replacement) {
86: 	D_ASSERT(expr);
87: 	if (StarExpression::IsColumns(*expr) || StarExpression::IsStar(*expr)) {
88: 		D_ASSERT(replacement);
89: 		auto alias = expr->alias;
90: 		expr = replacement->Copy();
91: 		if (!alias.empty()) {
92: 			expr->alias = std::move(alias);
93: 		}
94: 		return;
95: 	}
96: 	ParsedExpressionIterator::EnumerateChildren(
97: 	    *expr, [&](unique_ptr<ParsedExpression> &child_expr) { ReplaceStarExpression(child_expr, replacement); });
98: }
99: 
100: static string ReplaceColumnsAlias(const string &alias, const string &column_name, optional_ptr<duckdb_re2::RE2> regex) {
101: 	string result;
102: 	result.reserve(alias.size());
103: 	for (idx_t c = 0; c < alias.size(); c++) {
104: 		if (alias[c] == '\\') {
105: 			c++;
106: 			if (c >= alias.size()) {
107: 				throw BinderException("Unterminated backslash in COLUMNS(*) \"%s\" alias. Backslashes must either be "
108: 				                      "escaped or followed by a number",
109: 				                      alias);
110: 			}
111: 			if (alias[c] == '\\') {
112: 				result += "\\";
113: 				continue;
114: 			}
115: 			if (alias[c] < '0' || alias[c] > '9') {
116: 				throw BinderException("Invalid backslash code in COLUMNS(*) \"%s\" alias. Backslashes must either be "
117: 				                      "escaped or followed by a number",
118: 				                      alias);
119: 			}
120: 			if (alias[c] == '0') {
121: 				result += column_name;
122: 			} else if (!regex) {
123: 				throw BinderException(
124: 				    "Only the backslash escape code \\0 can be used when no regex is supplied to COLUMNS(*)");
125: 			} else {
126: 				string extracted;
127: 				RE2::Extract(column_name, *regex, "\\" + alias.substr(c, 1), &extracted);
128: 				result += extracted;
129: 			}
130: 		} else {
131: 			result += alias[c];
132: 		}
133: 	}
134: 	return result;
135: }
136: 
137: void TryTransformStarLike(unique_ptr<ParsedExpression> &root) {
138: 	// detect "* LIKE [literal]" and similar expressions
139: 	if (root->expression_class != ExpressionClass::FUNCTION) {
140: 		return;
141: 	}
142: 	auto &function = root->Cast<FunctionExpression>();
143: 	if (function.children.size() != 2) {
144: 		return;
145: 	}
146: 	auto &left = function.children[0];
147: 	// expression must have a star on the LHS, and a literal on the RHS
148: 	if (left->expression_class != ExpressionClass::STAR) {
149: 		return;
150: 	}
151: 	auto &star = left->Cast<StarExpression>();
152: 	if (star.columns) {
153: 		// COLUMNS(*) has different semantics
154: 		return;
155: 	}
156: 	unordered_set<string> supported_ops {"~~", "!~~", "~~~", "!~~~", "~~*", "!~~*", "regexp_full_match"};
157: 	if (supported_ops.count(function.function_name) == 0) {
158: 		// unsupported op for * expression
159: 		throw BinderException(*root, "Function \"%s\" cannot be applied to a star expression", function.function_name);
160: 	}
161: 	auto &right = function.children[1];
162: 	if (right->expression_class != ExpressionClass::CONSTANT) {
163: 		throw BinderException(*root, "Pattern applied to a star expression must be a constant");
164: 	}
165: 	if (!star.replace_list.empty()) {
166: 		throw BinderException(*root, "Replace list cannot be combined with a filtering operation");
167: 	}
168: 	// generate a columns expression
169: 	// "* LIKE '%literal%'
170: 	// -> COLUMNS(list_filter(*, x -> x LIKE '%literal%'))
171: 	auto star_expr = std::move(left);
172: 
173: 	auto lhs = make_uniq<ColumnRefExpression>("__lambda_col");
174: 	function.children[0] = lhs->Copy();
175: 
176: 	auto lambda = make_uniq<LambdaExpression>(std::move(lhs), std::move(root));
177: 	vector<unique_ptr<ParsedExpression>> filter_children;
178: 	filter_children.push_back(std::move(star_expr));
179: 	filter_children.push_back(std::move(lambda));
180: 	auto list_filter = make_uniq<FunctionExpression>("list_filter", std::move(filter_children));
181: 
182: 	auto columns_expr = make_uniq<StarExpression>();
183: 	columns_expr->columns = true;
184: 	columns_expr->expr = std::move(list_filter);
185: 	root = std::move(columns_expr);
186: }
187: 
188: void Binder::ExpandStarExpression(unique_ptr<ParsedExpression> expr,
189:                                   vector<unique_ptr<ParsedExpression>> &new_select_list) {
190: 	TryTransformStarLike(expr);
191: 
192: 	StarExpression *star = nullptr;
193: 	if (!FindStarExpression(expr, &star, true, false)) {
194: 		// no star expression: add it as-is
195: 		D_ASSERT(!star);
196: 		new_select_list.push_back(std::move(expr));
197: 		return;
198: 	}
199: 	D_ASSERT(star);
200: 	vector<unique_ptr<ParsedExpression>> star_list;
201: 	// we have star expressions! expand the list of star expressions
202: 	bind_context.GenerateAllColumnExpressions(*star, star_list);
203: 
204: 	unique_ptr<duckdb_re2::RE2> regex;
205: 	if (star->expr) {
206: 		// COLUMNS with an expression
207: 		// two options:
208: 		// VARCHAR parameter <- this is a regular expression
209: 		// LIST of VARCHAR parameters <- this is a set of columns
210: 		TableFunctionBinder binder(*this, context);
211: 		auto child = star->expr->Copy();
212: 		auto result = binder.Bind(child);
213: 		if (!result->IsFoldable()) {
214: 			// cannot resolve parameters here
215: 			if (star->expr->HasParameter()) {
216: 				throw ParameterNotResolvedException();
217: 			} else {
218: 				throw BinderException("Unsupported expression in COLUMNS");
219: 			}
220: 		}
221: 		auto val = ExpressionExecutor::EvaluateScalar(context, *result);
222: 		if (val.type().id() == LogicalTypeId::VARCHAR) {
223: 			// regex
224: 			if (val.IsNull()) {
225: 				throw BinderException("COLUMNS does not support NULL as regex argument");
226: 			}
227: 			auto &regex_str = StringValue::Get(val);
228: 			regex = make_uniq<duckdb_re2::RE2>(regex_str);
229: 			if (!regex->error().empty()) {
230: 				auto err = StringUtil::Format("Failed to compile regex \"%s\": %s", regex_str, regex->error());
231: 				throw BinderException(*star, err);
232: 			}
233: 			vector<unique_ptr<ParsedExpression>> new_list;
234: 			for (idx_t i = 0; i < star_list.size(); i++) {
235: 				auto &colref = star_list[i]->Cast<ColumnRefExpression>();
236: 				if (!RE2::PartialMatch(colref.GetColumnName(), *regex)) {
237: 					continue;
238: 				}
239: 				new_list.push_back(std::move(star_list[i]));
240: 			}
241: 			if (new_list.empty()) {
242: 				auto err = StringUtil::Format("No matching columns found that match regex \"%s\"", regex_str);
243: 				throw BinderException(*star, err);
244: 			}
245: 			star_list = std::move(new_list);
246: 		} else if (val.type().id() == LogicalTypeId::LIST &&
247: 		           ListType::GetChildType(val.type()).id() == LogicalTypeId::VARCHAR) {
248: 			// list of varchar columns
249: 			if (val.IsNull() || ListValue::GetChildren(val).empty()) {
250: 				auto err =
251: 				    StringUtil::Format("Star expression \"%s\" resulted in an empty set of columns", star->ToString());
252: 				throw BinderException(*star, err);
253: 			}
254: 			auto &children = ListValue::GetChildren(val);
255: 			vector<unique_ptr<ParsedExpression>> new_list;
256: 			// scan the list for all selected columns and construct a lookup table
257: 			case_insensitive_map_t<bool> selected_set;
258: 			for (auto &child : children) {
259: 				if (child.IsNull()) {
260: 					throw BinderException(*star, "Columns expression does not support NULL input parameters");
261: 				}
262: 				selected_set.insert(make_pair(StringValue::Get(child), false));
263: 			}
264: 			// now check the list of all possible expressions and select which ones make it in
265: 			for (auto &expr : star_list) {
266: 				auto str = GetColumnsStringValue(*expr);
267: 				auto entry = selected_set.find(str);
268: 				if (entry != selected_set.end()) {
269: 					new_list.push_back(std::move(expr));
270: 					entry->second = true;
271: 				}
272: 			}
273: 			// check if all expressions found a match
274: 			for (auto &entry : selected_set) {
275: 				if (!entry.second) {
276: 					throw BinderException("Column \"%s\" was selected but was not found in the FROM clause",
277: 					                      entry.first);
278: 				}
279: 			}
280: 			star_list = std::move(new_list);
281: 		} else {
282: 			throw BinderException(
283: 			    *star, "COLUMNS expects either a VARCHAR argument (regex) or a LIST of VARCHAR (list of columns)");
284: 		}
285: 	}
286: 
287: 	// now perform the replacement
288: 	if (StarExpression::IsColumnsUnpacked(*star)) {
289: 		if (StarExpression::IsColumnsUnpacked(*expr)) {
290: 			throw BinderException("*COLUMNS not allowed at the root level, use COLUMNS instead");
291: 		}
292: 		ReplaceUnpackedStarExpression(expr, star_list);
293: 		new_select_list.push_back(std::move(expr));
294: 		return;
295: 	}
296: 	for (idx_t i = 0; i < star_list.size(); i++) {
297: 		auto new_expr = expr->Copy();
298: 		ReplaceStarExpression(new_expr, star_list[i]);
299: 		if (StarExpression::IsColumns(*star)) {
300: 			optional_ptr<ParsedExpression> expr = star_list[i].get();
301: 			while (expr) {
302: 				if (expr->type == ExpressionType::COLUMN_REF) {
303: 					break;
304: 				}
305: 				if (expr->type == ExpressionType::OPERATOR_COALESCE) {
306: 					expr = expr->Cast<OperatorExpression>().children[0].get();
307: 				} else {
308: 					// unknown expression
309: 					expr = nullptr;
310: 				}
311: 			}
312: 			if (expr) {
313: 				auto &colref = expr->Cast<ColumnRefExpression>();
314: 				if (new_expr->alias.empty()) {
315: 					new_expr->alias = colref.GetColumnName();
316: 				} else {
317: 					new_expr->alias = ReplaceColumnsAlias(new_expr->alias, colref.GetColumnName(), regex.get());
318: 				}
319: 			}
320: 		}
321: 		new_select_list.push_back(std::move(new_expr));
322: 	}
323: }
324: 
325: void Binder::ExpandStarExpressions(vector<unique_ptr<ParsedExpression>> &select_list,
326:                                    vector<unique_ptr<ParsedExpression>> &new_select_list) {
327: 	for (auto &select_element : select_list) {
328: 		ExpandStarExpression(std::move(select_element), new_select_list);
329: 	}
330: }
331: 
332: } // namespace duckdb
[end of src/planner/binder/expression/bind_star_expression.cpp]
[start of src/planner/binder/query_node/bind_select_node.cpp]
1: #include "duckdb/common/limits.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/function/aggregate/distributive_function_utils.hpp"
5: #include "duckdb/function/function_binder.hpp"
6: #include "duckdb/main/config.hpp"
7: #include "duckdb/parser/expression/columnref_expression.hpp"
8: #include "duckdb/parser/expression/comparison_expression.hpp"
9: #include "duckdb/parser/expression/conjunction_expression.hpp"
10: #include "duckdb/parser/expression/constant_expression.hpp"
11: #include "duckdb/parser/expression/function_expression.hpp"
12: #include "duckdb/parser/expression/star_expression.hpp"
13: #include "duckdb/parser/expression/subquery_expression.hpp"
14: #include "duckdb/parser/parsed_expression_iterator.hpp"
15: #include "duckdb/parser/query_node/select_node.hpp"
16: #include "duckdb/parser/tableref/basetableref.hpp"
17: #include "duckdb/parser/tableref/joinref.hpp"
18: #include "duckdb/planner/binder.hpp"
19: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
20: #include "duckdb/planner/expression/bound_constant_expression.hpp"
21: #include "duckdb/planner/expression/bound_expanded_expression.hpp"
22: #include "duckdb/planner/expression_binder/column_alias_binder.hpp"
23: #include "duckdb/planner/expression_binder/constant_binder.hpp"
24: #include "duckdb/planner/expression_binder/group_binder.hpp"
25: #include "duckdb/planner/expression_binder/having_binder.hpp"
26: #include "duckdb/planner/expression_binder/order_binder.hpp"
27: #include "duckdb/planner/expression_binder/qualify_binder.hpp"
28: #include "duckdb/planner/expression_binder/select_bind_state.hpp"
29: #include "duckdb/planner/expression_binder/select_binder.hpp"
30: #include "duckdb/planner/expression_binder/where_binder.hpp"
31: #include "duckdb/planner/query_node/bound_select_node.hpp"
32: 
33: namespace duckdb {
34: 
35: unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {
36: 	// we treat the distinct list as an ORDER BY
37: 	auto bound_expr = order_binder.Bind(std::move(expr));
38: 	if (!bound_expr) {
39: 		// DISTINCT ON non-integer constant
40: 		// remove the expression from the DISTINCT ON list
41: 		return nullptr;
42: 	}
43: 	D_ASSERT(bound_expr->type == ExpressionType::VALUE_CONSTANT);
44: 	return bound_expr;
45: }
46: 
47: BoundLimitNode Binder::BindLimitValue(OrderBinder &order_binder, unique_ptr<ParsedExpression> limit_val,
48:                                       bool is_percentage, bool is_offset) {
49: 	auto new_binder = Binder::CreateBinder(context, this);
50: 	ExpressionBinder expr_binder(*new_binder, context);
51: 	auto target_type = is_percentage ? LogicalType::DOUBLE : LogicalType::BIGINT;
52: 	expr_binder.target_type = target_type;
53: 	auto original_limit = limit_val->Copy();
54: 	auto expr = expr_binder.Bind(limit_val);
55: 	if (expr->HasSubquery()) {
56: 		if (!order_binder.HasExtraList()) {
57: 			throw BinderException("Subquery in LIMIT/OFFSET not supported in set operation");
58: 		}
59: 		auto bound_limit = order_binder.CreateExtraReference(std::move(original_limit));
60: 		if (is_percentage) {
61: 			return BoundLimitNode::ExpressionPercentage(std::move(bound_limit));
62: 		} else {
63: 			return BoundLimitNode::ExpressionValue(std::move(bound_limit));
64: 		}
65: 	}
66: 	if (expr->IsFoldable()) {
67: 		//! this is a constant
68: 		auto val = ExpressionExecutor::EvaluateScalar(context, *expr).CastAs(context, target_type);
69: 		if (is_percentage) {
70: 			D_ASSERT(!is_offset);
71: 			double percentage_val;
72: 			if (val.IsNull()) {
73: 				percentage_val = 100.0;
74: 			} else {
75: 				percentage_val = val.GetValue<double>();
76: 			}
77: 			if (Value::IsNan(percentage_val) || percentage_val < 0 || percentage_val > 100) {
78: 				throw OutOfRangeException("Limit percent out of range, should be between 0% and 100%");
79: 			}
80: 			return BoundLimitNode::ConstantPercentage(percentage_val);
81: 		} else {
82: 			int64_t constant_val;
83: 			if (val.IsNull()) {
84: 				constant_val = is_offset ? 0 : NumericLimits<int64_t>::Maximum();
85: 			} else {
86: 				constant_val = val.GetValue<int64_t>();
87: 			}
88: 			if (constant_val < 0) {
89: 				throw BinderException(expr->query_location, "LIMIT/OFFSET cannot be negative");
90: 			}
91: 			return BoundLimitNode::ConstantValue(constant_val);
92: 		}
93: 	}
94: 	if (!new_binder->correlated_columns.empty()) {
95: 		throw BinderException("Correlated columns not supported in LIMIT/OFFSET");
96: 	}
97: 	// move any correlated columns to this binder
98: 	MoveCorrelatedExpressions(*new_binder);
99: 	if (is_percentage) {
100: 		return BoundLimitNode::ExpressionPercentage(std::move(expr));
101: 	} else {
102: 		return BoundLimitNode::ExpressionValue(std::move(expr));
103: 	}
104: }
105: 
106: duckdb::unique_ptr<BoundResultModifier> Binder::BindLimit(OrderBinder &order_binder, LimitModifier &limit_mod) {
107: 	auto result = make_uniq<BoundLimitModifier>();
108: 	if (limit_mod.limit) {
109: 		result->limit_val = BindLimitValue(order_binder, std::move(limit_mod.limit), false, false);
110: 	}
111: 	if (limit_mod.offset) {
112: 		result->offset_val = BindLimitValue(order_binder, std::move(limit_mod.offset), false, true);
113: 	}
114: 	return std::move(result);
115: }
116: 
117: unique_ptr<BoundResultModifier> Binder::BindLimitPercent(OrderBinder &order_binder, LimitPercentModifier &limit_mod) {
118: 	auto result = make_uniq<BoundLimitModifier>();
119: 	if (limit_mod.limit) {
120: 		result->limit_val = BindLimitValue(order_binder, std::move(limit_mod.limit), true, false);
121: 	}
122: 	if (limit_mod.offset) {
123: 		result->offset_val = BindLimitValue(order_binder, std::move(limit_mod.offset), false, true);
124: 	}
125: 	return std::move(result);
126: }
127: 
128: void Binder::PrepareModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result) {
129: 	for (auto &mod : statement.modifiers) {
130: 		unique_ptr<BoundResultModifier> bound_modifier;
131: 		switch (mod->type) {
132: 		case ResultModifierType::DISTINCT_MODIFIER: {
133: 			auto &distinct = mod->Cast<DistinctModifier>();
134: 			auto bound_distinct = make_uniq<BoundDistinctModifier>();
135: 			bound_distinct->distinct_type =
136: 			    distinct.distinct_on_targets.empty() ? DistinctType::DISTINCT : DistinctType::DISTINCT_ON;
137: 			if (distinct.distinct_on_targets.empty()) {
138: 				for (idx_t i = 0; i < result.names.size(); i++) {
139: 					distinct.distinct_on_targets.push_back(
140: 					    make_uniq<ConstantExpression>(Value::INTEGER(UnsafeNumericCast<int32_t>(1 + i))));
141: 				}
142: 			}
143: 			order_binder.SetQueryComponent("DISTINCT ON");
144: 			for (auto &distinct_on_target : distinct.distinct_on_targets) {
145: 				auto expr = BindOrderExpression(order_binder, std::move(distinct_on_target));
146: 				if (!expr) {
147: 					continue;
148: 				}
149: 				bound_distinct->target_distincts.push_back(std::move(expr));
150: 			}
151: 			order_binder.SetQueryComponent();
152: 
153: 			bound_modifier = std::move(bound_distinct);
154: 			break;
155: 		}
156: 		case ResultModifierType::ORDER_MODIFIER: {
157: 
158: 			auto &order = mod->Cast<OrderModifier>();
159: 			auto bound_order = make_uniq<BoundOrderModifier>();
160: 			auto &config = DBConfig::GetConfig(context);
161: 			D_ASSERT(!order.orders.empty());
162: 			auto &order_binders = order_binder.GetBinders();
163: 			if (order.orders.size() == 1 && order.orders[0].expression->type == ExpressionType::STAR) {
164: 				auto &star = order.orders[0].expression->Cast<StarExpression>();
165: 				if (star.exclude_list.empty() && star.replace_list.empty() && !star.expr) {
166: 					// ORDER BY ALL
167: 					// replace the order list with the all elements in the SELECT list
168: 					auto order_type = config.ResolveOrder(order.orders[0].type);
169: 					auto null_order = config.ResolveNullOrder(order_type, order.orders[0].null_order);
170: 					auto constant_expr = make_uniq<BoundConstantExpression>(Value("ALL"));
171: 					bound_order->orders.emplace_back(order_type, null_order, std::move(constant_expr));
172: 					bound_modifier = std::move(bound_order);
173: 					break;
174: 				}
175: 			}
176: #if 0
177: 			// When this verification is enabled, replace ORDER BY x, y with ORDER BY create_sort_key(x, y)
178: 			// note that we don't enable this during actual verification since it doesn't always work
179: 			// e.g. it breaks EXPLAIN output on queries
180: 			bool can_replace = true;
181: 			for (auto &order_node : order.orders) {
182: 				if (order_node.expression->type == ExpressionType::VALUE_CONSTANT) {
183: 					// we cannot replace the sort key when we order by literals (e.g. ORDER BY 1, 2`
184: 					can_replace = false;
185: 					break;
186: 				}
187: 			}
188: 			if (!order_binder.HasExtraList()) {
189: 				// we can only do the replacement when we can order by elements that are not in the selection list
190: 				can_replace = false;
191: 			}
192: 			if (can_replace) {
193: 				vector<unique_ptr<ParsedExpression>> sort_key_parameters;
194: 				for (auto &order_node : order.orders) {
195: 					sort_key_parameters.push_back(std::move(order_node.expression));
196: 					auto type = config.ResolveOrder(order_node.type);
197: 					auto null_order = config.ResolveNullOrder(type, order_node.null_order);
198: 					string sort_param = EnumUtil::ToString(type) + " " + EnumUtil::ToString(null_order);
199: 					sort_key_parameters.push_back(make_uniq<ConstantExpression>(Value(sort_param)));
200: 				}
201: 				order.orders.clear();
202: 				auto create_sort_key = make_uniq<FunctionExpression>("create_sort_key", std::move(sort_key_parameters));
203: 				order.orders.emplace_back(OrderType::ASCENDING, OrderByNullType::NULLS_LAST, std::move(create_sort_key));
204: 			}
205: #endif
206: 			for (auto &order_node : order.orders) {
207: 				vector<unique_ptr<ParsedExpression>> order_list;
208: 				order_binders[0].get().ExpandStarExpression(std::move(order_node.expression), order_list);
209: 
210: 				auto type = config.ResolveOrder(order_node.type);
211: 				auto null_order = config.ResolveNullOrder(type, order_node.null_order);
212: 				for (auto &order_expr : order_list) {
213: 					auto bound_expr = BindOrderExpression(order_binder, std::move(order_expr));
214: 					if (!bound_expr) {
215: 						continue;
216: 					}
217: 					bound_order->orders.emplace_back(type, null_order, std::move(bound_expr));
218: 				}
219: 			}
220: 			if (!bound_order->orders.empty()) {
221: 				bound_modifier = std::move(bound_order);
222: 			}
223: 			break;
224: 		}
225: 		case ResultModifierType::LIMIT_MODIFIER:
226: 			bound_modifier = BindLimit(order_binder, mod->Cast<LimitModifier>());
227: 			break;
228: 		case ResultModifierType::LIMIT_PERCENT_MODIFIER:
229: 			bound_modifier = BindLimitPercent(order_binder, mod->Cast<LimitPercentModifier>());
230: 			break;
231: 		default:
232: 			throw InternalException("Unsupported result modifier");
233: 		}
234: 		if (bound_modifier) {
235: 			result.modifiers.push_back(std::move(bound_modifier));
236: 		}
237: 	}
238: }
239: 
240: unique_ptr<Expression> CreateOrderExpression(unique_ptr<Expression> expr, const vector<string> &names,
241:                                              const vector<LogicalType> &sql_types, idx_t table_index, idx_t index) {
242: 	if (index >= sql_types.size()) {
243: 		throw BinderException(*expr, "ORDER term out of range - should be between 1 and %lld", sql_types.size());
244: 	}
245: 	auto result = make_uniq<BoundColumnRefExpression>(std::move(expr->alias), sql_types[index],
246: 	                                                  ColumnBinding(table_index, index));
247: 	if (result->alias.empty() && index < names.size()) {
248: 		result->alias = names[index];
249: 	}
250: 	return std::move(result);
251: }
252: 
253: unique_ptr<Expression> FinalizeBindOrderExpression(unique_ptr<Expression> expr, idx_t table_index,
254:                                                    const vector<string> &names, const vector<LogicalType> &sql_types,
255:                                                    const SelectBindState &bind_state) {
256: 	auto &constant = expr->Cast<BoundConstantExpression>();
257: 	switch (constant.value.type().id()) {
258: 	case LogicalTypeId::UBIGINT: {
259: 		// index
260: 		auto index = UBigIntValue::Get(constant.value);
261: 		return CreateOrderExpression(std::move(expr), names, sql_types, table_index, bind_state.GetFinalIndex(index));
262: 	}
263: 	case LogicalTypeId::VARCHAR: {
264: 		// ORDER BY ALL
265: 		return nullptr;
266: 	}
267: 	case LogicalTypeId::STRUCT: {
268: 		// collation
269: 		auto &struct_values = StructValue::GetChildren(constant.value);
270: 		if (struct_values.size() > 2) {
271: 			throw InternalException("Expected one or two children: index and optional collation");
272: 		}
273: 		auto index = UBigIntValue::Get(struct_values[0]);
274: 		string collation;
275: 		if (struct_values.size() == 2) {
276: 			collation = StringValue::Get(struct_values[1]);
277: 		}
278: 		auto result = CreateOrderExpression(std::move(expr), names, sql_types, table_index, index);
279: 		if (!collation.empty()) {
280: 			if (sql_types[index].id() != LogicalTypeId::VARCHAR) {
281: 				throw BinderException(*result, "COLLATE can only be applied to varchar columns");
282: 			}
283: 			result->return_type = LogicalType::VARCHAR_COLLATION(std::move(collation));
284: 		}
285: 		return result;
286: 	}
287: 	default:
288: 		throw InternalException("Unknown type in FinalizeBindOrderExpression");
289: 	}
290: }
291: 
292: static void AssignReturnType(unique_ptr<Expression> &expr, idx_t table_index, const vector<string> &names,
293:                              const vector<LogicalType> &sql_types, const SelectBindState &bind_state) {
294: 	if (!expr) {
295: 		return;
296: 	}
297: 	if (expr->type == ExpressionType::VALUE_CONSTANT) {
298: 		expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
299: 	}
300: 	if (expr->type != ExpressionType::BOUND_COLUMN_REF) {
301: 		return;
302: 	}
303: 	auto &bound_colref = expr->Cast<BoundColumnRefExpression>();
304: 	bound_colref.return_type = sql_types[bound_colref.binding.column_index];
305: }
306: 
307: void Binder::BindModifiers(BoundQueryNode &result, idx_t table_index, const vector<string> &names,
308:                            const vector<LogicalType> &sql_types, const SelectBindState &bind_state) {
309: 	for (auto &bound_mod : result.modifiers) {
310: 		switch (bound_mod->type) {
311: 		case ResultModifierType::DISTINCT_MODIFIER: {
312: 			auto &distinct = bound_mod->Cast<BoundDistinctModifier>();
313: 			D_ASSERT(!distinct.target_distincts.empty());
314: 			// set types of distinct targets
315: 			for (auto &expr : distinct.target_distincts) {
316: 				expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
317: 				if (!expr) {
318: 					throw InternalException("DISTINCT ON ORDER BY ALL not supported");
319: 				}
320: 			}
321: 			for (auto &expr : distinct.target_distincts) {
322: 				ExpressionBinder::PushCollation(context, expr, expr->return_type);
323: 			}
324: 			break;
325: 		}
326: 		case ResultModifierType::LIMIT_MODIFIER: {
327: 			auto &limit = bound_mod->Cast<BoundLimitModifier>();
328: 			AssignReturnType(limit.limit_val.GetExpression(), table_index, names, sql_types, bind_state);
329: 			AssignReturnType(limit.offset_val.GetExpression(), table_index, names, sql_types, bind_state);
330: 			break;
331: 		}
332: 		case ResultModifierType::ORDER_MODIFIER: {
333: 			auto &order = bound_mod->Cast<BoundOrderModifier>();
334: 			bool order_by_all = false;
335: 			for (auto &order_node : order.orders) {
336: 				auto &expr = order_node.expression;
337: 				expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
338: 				if (!expr) {
339: 					order_by_all = true;
340: 				}
341: 			}
342: 			if (order_by_all) {
343: 				D_ASSERT(order.orders.size() == 1);
344: 				auto order_type = order.orders[0].type;
345: 				auto null_order = order.orders[0].null_order;
346: 				order.orders.clear();
347: 				for (idx_t i = 0; i < sql_types.size(); i++) {
348: 					auto expr = make_uniq<BoundColumnRefExpression>(sql_types[i], ColumnBinding(table_index, i));
349: 					if (i < names.size()) {
350: 						expr->alias = names[i];
351: 					}
352: 					order.orders.emplace_back(order_type, null_order, std::move(expr));
353: 				}
354: 			}
355: 			for (auto &order_node : order.orders) {
356: 				auto &expr = order_node.expression;
357: 				ExpressionBinder::PushCollation(context, order_node.expression, expr->return_type);
358: 			}
359: 			break;
360: 		}
361: 		default:
362: 			break;
363: 		}
364: 	}
365: }
366: 
367: unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
368: 	D_ASSERT(statement.from_table);
369: 
370: 	// first bind the FROM table statement
371: 	auto from = std::move(statement.from_table);
372: 	auto from_table = Bind(*from);
373: 	return BindSelectNode(statement, std::move(from_table));
374: }
375: 
376: void Binder::BindWhereStarExpression(unique_ptr<ParsedExpression> &expr) {
377: 	// expand any expressions in the upper AND recursively
378: 	if (expr->type == ExpressionType::CONJUNCTION_AND) {
379: 		auto &conj = expr->Cast<ConjunctionExpression>();
380: 		for (auto &child : conj.children) {
381: 			BindWhereStarExpression(child);
382: 		}
383: 		return;
384: 	}
385: 	if (expr->type == ExpressionType::STAR) {
386: 		auto &star = expr->Cast<StarExpression>();
387: 		if (!star.columns) {
388: 			throw ParserException("STAR expression is not allowed in the WHERE clause. Use COLUMNS(*) instead.");
389: 		}
390: 	}
391: 	// expand the stars for this expression
392: 	vector<unique_ptr<ParsedExpression>> new_conditions;
393: 	ExpandStarExpression(std::move(expr), new_conditions);
394: 	if (new_conditions.empty()) {
395: 		throw ParserException("COLUMNS expansion resulted in empty set of columns");
396: 	}
397: 
398: 	// set up an AND conjunction between the expanded conditions
399: 	expr = std::move(new_conditions[0]);
400: 	for (idx_t i = 1; i < new_conditions.size(); i++) {
401: 		auto and_conj = make_uniq<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, std::move(expr),
402: 		                                                 std::move(new_conditions[i]));
403: 		expr = std::move(and_conj);
404: 	}
405: }
406: 
407: unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_ptr<BoundTableRef> from_table) {
408: 	D_ASSERT(from_table);
409: 	D_ASSERT(!statement.from_table);
410: 	auto result = make_uniq<BoundSelectNode>();
411: 	result->projection_index = GenerateTableIndex();
412: 	result->group_index = GenerateTableIndex();
413: 	result->aggregate_index = GenerateTableIndex();
414: 	result->groupings_index = GenerateTableIndex();
415: 	result->window_index = GenerateTableIndex();
416: 	result->prune_index = GenerateTableIndex();
417: 
418: 	result->from_table = std::move(from_table);
419: 	// bind the sample clause
420: 	if (statement.sample) {
421: 		result->sample_options = std::move(statement.sample);
422: 	}
423: 
424: 	// visit the select list and expand any "*" statements
425: 	vector<unique_ptr<ParsedExpression>> new_select_list;
426: 	ExpandStarExpressions(statement.select_list, new_select_list);
427: 
428: 	if (new_select_list.empty()) {
429: 		throw BinderException("SELECT list is empty after resolving * expressions!");
430: 	}
431: 	statement.select_list = std::move(new_select_list);
432: 
433: 	auto &bind_state = result->bind_state;
434: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
435: 		auto &expr = statement.select_list[i];
436: 		result->names.push_back(expr->GetName());
437: 		ExpressionBinder::QualifyColumnNames(*this, expr);
438: 		if (!expr->alias.empty()) {
439: 			bind_state.alias_map[expr->alias] = i;
440: 			result->names[i] = expr->alias;
441: 		}
442: 		bind_state.projection_map[*expr] = i;
443: 		bind_state.original_expressions.push_back(expr->Copy());
444: 	}
445: 	result->column_count = statement.select_list.size();
446: 
447: 	// first visit the WHERE clause
448: 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
449: 	if (statement.where_clause) {
450: 		// bind any star expressions in the WHERE clause
451: 		BindWhereStarExpression(statement.where_clause);
452: 
453: 		ColumnAliasBinder alias_binder(bind_state);
454: 		WhereBinder where_binder(*this, context, &alias_binder);
455: 		unique_ptr<ParsedExpression> condition = std::move(statement.where_clause);
456: 		result->where_clause = where_binder.Bind(condition);
457: 	}
458: 
459: 	// now bind all the result modifiers; including DISTINCT and ORDER BY targets
460: 	OrderBinder order_binder({*this}, statement, bind_state);
461: 	PrepareModifiers(order_binder, statement, *result);
462: 
463: 	vector<unique_ptr<ParsedExpression>> unbound_groups;
464: 	BoundGroupInformation info;
465: 	auto &group_expressions = statement.groups.group_expressions;
466: 	if (!group_expressions.empty()) {
467: 		// the statement has a GROUP BY clause, bind it
468: 		unbound_groups.resize(group_expressions.size());
469: 		GroupBinder group_binder(*this, context, statement, result->group_index, bind_state, info.alias_map);
470: 		for (idx_t i = 0; i < group_expressions.size(); i++) {
471: 
472: 			// we keep a copy of the unbound expression;
473: 			// we keep the unbound copy around to check for group references in the SELECT and HAVING clause
474: 			// the reason we want the unbound copy is because we want to figure out whether an expression
475: 			// is a group reference BEFORE binding in the SELECT/HAVING binder
476: 			group_binder.unbound_expression = group_expressions[i]->Copy();
477: 			group_binder.bind_index = i;
478: 
479: 			// bind the groups
480: 			LogicalType group_type;
481: 			auto bound_expr = group_binder.Bind(group_expressions[i], &group_type);
482: 			D_ASSERT(bound_expr->return_type.id() != LogicalTypeId::INVALID);
483: 
484: 			// find out whether the expression contains a subquery, it can't be copied if so
485: 			auto &bound_expr_ref = *bound_expr;
486: 			bool contains_subquery = bound_expr_ref.HasSubquery();
487: 
488: 			// push a potential collation, if necessary
489: 			bool requires_collation = ExpressionBinder::PushCollation(context, bound_expr, group_type);
490: 			if (!contains_subquery && requires_collation) {
491: 				// if there is a collation on a group x, we should group by the collated expr,
492: 				// but also push a first(x) aggregate in case x is selected (uncollated)
493: 				info.collated_groups[i] = result->aggregates.size();
494: 
495: 				auto first_fun = FirstFunctionGetter::GetFunction(bound_expr_ref.return_type);
496: 				vector<unique_ptr<Expression>> first_children;
497: 				// FIXME: would be better to just refer to this expression, but for now we copy
498: 				first_children.push_back(bound_expr_ref.Copy());
499: 
500: 				FunctionBinder function_binder(*this);
501: 				auto function = function_binder.BindAggregateFunction(first_fun, std::move(first_children));
502: 				function->alias = "__collated_group";
503: 				result->aggregates.push_back(std::move(function));
504: 			}
505: 			result->groups.group_expressions.push_back(std::move(bound_expr));
506: 
507: 			// in the unbound expression we DO bind the table names of any ColumnRefs
508: 			// we do this to make sure that "table.a" and "a" are treated the same
509: 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
510: 			// hence we convert "a" -> "test.a" in the unbound expression
511: 			unbound_groups[i] = std::move(group_binder.unbound_expression);
512: 			ExpressionBinder::QualifyColumnNames(*this, unbound_groups[i]);
513: 			info.map[*unbound_groups[i]] = i;
514: 		}
515: 	}
516: 	result->groups.grouping_sets = std::move(statement.groups.grouping_sets);
517: 
518: 	// bind the HAVING clause, if any
519: 	if (statement.having) {
520: 		HavingBinder having_binder(*this, context, *result, info, statement.aggregate_handling);
521: 		ExpressionBinder::QualifyColumnNames(having_binder, statement.having);
522: 		result->having = having_binder.Bind(statement.having);
523: 	}
524: 
525: 	// bind the QUALIFY clause, if any
526: 	vector<BoundColumnReferenceInfo> bound_qualify_columns;
527: 	if (statement.qualify) {
528: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
529: 			throw BinderException("Combining QUALIFY with GROUP BY ALL is not supported yet");
530: 		}
531: 		QualifyBinder qualify_binder(*this, context, *result, info);
532: 		ExpressionBinder::QualifyColumnNames(*this, statement.qualify);
533: 		result->qualify = qualify_binder.Bind(statement.qualify);
534: 		if (qualify_binder.HasBoundColumns()) {
535: 			if (qualify_binder.BoundAggregates()) {
536: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
537: 			}
538: 			bound_qualify_columns = qualify_binder.GetBoundColumns();
539: 		}
540: 	}
541: 
542: 	// after that, we bind to the SELECT list
543: 	SelectBinder select_binder(*this, context, *result, info);
544: 
545: 	// if we expand select-list expressions, e.g., via UNNEST, then we need to possibly
546: 	// adjust the column index of the already bound ORDER BY modifiers, and not only set their types
547: 	vector<idx_t> group_by_all_indexes;
548: 	vector<string> new_names;
549: 	vector<LogicalType> internal_sql_types;
550: 
551: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
552: 		bool is_window = statement.select_list[i]->IsWindow();
553: 		idx_t unnest_count = result->unnests.size();
554: 		LogicalType result_type;
555: 		auto expr = select_binder.Bind(statement.select_list[i], &result_type, true);
556: 		bool is_original_column = i < result->column_count;
557: 		bool can_group_by_all =
558: 		    statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES && is_original_column;
559: 		result->bound_column_count++;
560: 
561: 		if (expr->type == ExpressionType::BOUND_EXPANDED) {
562: 			if (!is_original_column) {
563: 				throw BinderException("UNNEST of struct cannot be used in ORDER BY/DISTINCT ON clause");
564: 			}
565: 			if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
566: 				throw BinderException("UNNEST of struct cannot be combined with GROUP BY ALL");
567: 			}
568: 
569: 			auto &expanded = expr->Cast<BoundExpandedExpression>();
570: 			auto &struct_expressions = expanded.expanded_expressions;
571: 			D_ASSERT(!struct_expressions.empty());
572: 
573: 			for (auto &struct_expr : struct_expressions) {
574: 				new_names.push_back(struct_expr->GetName());
575: 				result->types.push_back(struct_expr->return_type);
576: 				internal_sql_types.push_back(struct_expr->return_type);
577: 				result->select_list.push_back(std::move(struct_expr));
578: 			}
579: 			bind_state.AddExpandedColumn(struct_expressions.size());
580: 			continue;
581: 		}
582: 
583: 		if (expr->IsVolatile()) {
584: 			bind_state.SetExpressionIsVolatile(i);
585: 		}
586: 		if (expr->HasSubquery()) {
587: 			bind_state.SetExpressionHasSubquery(i);
588: 		}
589: 		bind_state.AddRegularColumn();
590: 
591: 		if (can_group_by_all && select_binder.HasBoundColumns()) {
592: 			if (select_binder.BoundAggregates()) {
593: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
594: 			}
595: 			if (is_window) {
596: 				throw BinderException("Cannot group on a window clause");
597: 			}
598: 			if (result->unnests.size() > unnest_count) {
599: 				throw BinderException("Cannot group on an UNNEST or UNLIST clause");
600: 			}
601: 			// we are forcing aggregates, and the node has columns bound
602: 			// this entry becomes a group
603: 			group_by_all_indexes.push_back(i);
604: 		}
605: 
606: 		result->select_list.push_back(std::move(expr));
607: 		if (is_original_column) {
608: 			new_names.push_back(std::move(result->names[i]));
609: 			result->types.push_back(result_type);
610: 		}
611: 		internal_sql_types.push_back(result_type);
612: 
613: 		if (can_group_by_all) {
614: 			select_binder.ResetBindings();
615: 		}
616: 	}
617: 
618: 	// push the GROUP BY ALL expressions into the group set
619: 
620: 	for (auto &group_by_all_index : group_by_all_indexes) {
621: 		auto &expr = result->select_list[group_by_all_index];
622: 		auto group_ref = make_uniq<BoundColumnRefExpression>(
623: 		    expr->return_type, ColumnBinding(result->group_index, result->groups.group_expressions.size()));
624: 		result->groups.group_expressions.push_back(std::move(expr));
625: 		expr = std::move(group_ref);
626: 	}
627: 	set<idx_t> group_by_all_indexes_set;
628: 	if (!group_by_all_indexes.empty()) {
629: 		idx_t num_set_indexes = result->groups.group_expressions.size();
630: 		for (idx_t i = 0; i < num_set_indexes; i++) {
631: 			group_by_all_indexes_set.insert(i);
632: 		}
633: 		D_ASSERT(result->groups.grouping_sets.empty());
634: 		result->groups.grouping_sets.push_back(group_by_all_indexes_set);
635: 	}
636: 	result->column_count = new_names.size();
637: 	result->names = std::move(new_names);
638: 	result->need_prune = result->select_list.size() > result->column_count;
639: 
640: 	// in the normal select binder, we bind columns as if there is no aggregation
641: 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
642: 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
643: 	// we choose the former one [CONTROVERSIAL: this is the PostgreSQL behavior]
644: 	if (!result->groups.group_expressions.empty() || !result->aggregates.empty() || statement.having ||
645: 	    !result->groups.grouping_sets.empty()) {
646: 		if (statement.aggregate_handling == AggregateHandling::NO_AGGREGATES_ALLOWED) {
647: 			throw BinderException("Aggregates cannot be present in a Project relation!");
648: 		} else {
649: 			vector<BoundColumnReferenceInfo> bound_columns;
650: 			if (select_binder.HasBoundColumns()) {
651: 				bound_columns = select_binder.GetBoundColumns();
652: 			}
653: 			for (auto &bound_qualify_col : bound_qualify_columns) {
654: 				bound_columns.push_back(bound_qualify_col);
655: 			}
656: 			if (!bound_columns.empty()) {
657: 				string error;
658: 				error = "column \"%s\" must appear in the GROUP BY clause or must be part of an aggregate function.";
659: 				if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
660: 					error += "\nGROUP BY ALL will only group entries in the SELECT list. Add it to the SELECT list or "
661: 					         "GROUP BY this entry explicitly.";
662: 					throw BinderException(bound_columns[0].query_location, error, bound_columns[0].name);
663: 				} else {
664: 					error +=
665: 					    "\nEither add it to the GROUP BY list, or use \"ANY_VALUE(%s)\" if the exact value of \"%s\" "
666: 					    "is not important.";
667: 					throw BinderException(bound_columns[0].query_location, error, bound_columns[0].name,
668: 					                      bound_columns[0].name, bound_columns[0].name);
669: 				}
670: 			}
671: 		}
672: 	}
673: 
674: 	// QUALIFY clause requires at least one window function to be specified in at least one of the SELECT column list or
675: 	// the filter predicate of the QUALIFY clause
676: 	if (statement.qualify && result->windows.empty()) {
677: 		throw BinderException("at least one window function must appear in the SELECT column or QUALIFY clause");
678: 	}
679: 
680: 	// now that the SELECT list is bound, we set the types of DISTINCT/ORDER BY expressions
681: 	BindModifiers(*result, result->projection_index, result->names, internal_sql_types, bind_state);
682: 	return std::move(result);
683: }
684: 
685: } // namespace duckdb
[end of src/planner/binder/query_node/bind_select_node.cpp]
[start of src/planner/binder/query_node/plan_query_node.cpp]
1: #include "duckdb/parser/query_node.hpp"
2: #include "duckdb/planner/binder.hpp"
3: #include "duckdb/planner/operator/logical_distinct.hpp"
4: #include "duckdb/planner/operator/logical_limit.hpp"
5: #include "duckdb/planner/operator/logical_order.hpp"
6: #include "duckdb/planner/bound_result_modifier.hpp"
7: 
8: namespace duckdb {
9: 
10: unique_ptr<LogicalOperator> Binder::VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root) {
11: 	D_ASSERT(root);
12: 	for (auto &mod : node.modifiers) {
13: 		switch (mod->type) {
14: 		case ResultModifierType::DISTINCT_MODIFIER: {
15: 			auto &bound = mod->Cast<BoundDistinctModifier>();
16: 			auto distinct = make_uniq<LogicalDistinct>(std::move(bound.target_distincts), bound.distinct_type);
17: 			distinct->AddChild(std::move(root));
18: 			root = std::move(distinct);
19: 			break;
20: 		}
21: 		case ResultModifierType::ORDER_MODIFIER: {
22: 			auto &bound = mod->Cast<BoundOrderModifier>();
23: 			if (root->type == LogicalOperatorType::LOGICAL_DISTINCT) {
24: 				auto &distinct = root->Cast<LogicalDistinct>();
25: 				if (distinct.distinct_type == DistinctType::DISTINCT_ON) {
26: 					auto order_by = make_uniq<BoundOrderModifier>();
27: 					for (auto &order_node : bound.orders) {
28: 						order_by->orders.push_back(order_node.Copy());
29: 					}
30: 					distinct.order_by = std::move(order_by);
31: 				}
32: 			}
33: 			auto order = make_uniq<LogicalOrder>(std::move(bound.orders));
34: 			order->AddChild(std::move(root));
35: 			root = std::move(order);
36: 			break;
37: 		}
38: 		case ResultModifierType::LIMIT_MODIFIER: {
39: 			auto &bound = mod->Cast<BoundLimitModifier>();
40: 			auto limit = make_uniq<LogicalLimit>(std::move(bound.limit_val), std::move(bound.offset_val));
41: 			limit->AddChild(std::move(root));
42: 			root = std::move(limit);
43: 			break;
44: 		}
45: 		default:
46: 			throw BinderException("Unimplemented modifier type!");
47: 		}
48: 	}
49: 	return root;
50: }
51: 
52: } // namespace duckdb
[end of src/planner/binder/query_node/plan_query_node.cpp]
[start of src/planner/binder/statement/bind_insert.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/parser/expression/constant_expression.hpp"
3: #include "duckdb/parser/expression/function_expression.hpp"
4: #include "duckdb/parser/statement/insert_statement.hpp"
5: #include "duckdb/parser/query_node/select_node.hpp"
6: #include "duckdb/parser/tableref/expressionlistref.hpp"
7: #include "duckdb/planner/binder.hpp"
8: #include "duckdb/planner/expression_binder/insert_binder.hpp"
9: #include "duckdb/planner/operator/logical_insert.hpp"
10: #include "duckdb/planner/operator/logical_get.hpp"
11: #include "duckdb/common/string_util.hpp"
12: #include "duckdb/function/table/table_scan.hpp"
13: #include "duckdb/planner/operator/logical_dummy_scan.hpp"
14: #include "duckdb/planner/operator/logical_projection.hpp"
15: #include "duckdb/planner/expression_iterator.hpp"
16: #include "duckdb/planner/expression_binder/where_binder.hpp"
17: #include "duckdb/planner/expression_binder/update_binder.hpp"
18: #include "duckdb/parser/statement/update_statement.hpp"
19: #include "duckdb/planner/expression/bound_default_expression.hpp"
20: #include "duckdb/catalog/catalog_entry/index_catalog_entry.hpp"
21: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
22: #include "duckdb/planner/bound_tableref.hpp"
23: #include "duckdb/planner/tableref/bound_basetableref.hpp"
24: #include "duckdb/planner/tableref/bound_dummytableref.hpp"
25: #include "duckdb/parser/parsed_expression_iterator.hpp"
26: #include "duckdb/storage/table_storage_info.hpp"
27: #include "duckdb/parser/tableref/basetableref.hpp"
28: 
29: namespace duckdb {
30: 
31: static void CheckInsertColumnCountMismatch(idx_t expected_columns, idx_t result_columns, bool columns_provided,
32:                                            const char *tname) {
33: 	if (result_columns != expected_columns) {
34: 		string msg = StringUtil::Format(!columns_provided ? "table %s has %lld columns but %lld values were supplied"
35: 		                                                  : "Column name/value mismatch for insert on %s: "
36: 		                                                    "expected %lld columns but %lld values were supplied",
37: 		                                tname, expected_columns, result_columns);
38: 		throw BinderException(msg);
39: 	}
40: }
41: 
42: unique_ptr<ParsedExpression> ExpandDefaultExpression(const ColumnDefinition &column) {
43: 	if (column.HasDefaultValue()) {
44: 		return column.DefaultValue().Copy();
45: 	} else {
46: 		return make_uniq<ConstantExpression>(Value(column.Type()));
47: 	}
48: }
49: 
50: void ReplaceDefaultExpression(unique_ptr<ParsedExpression> &expr, const ColumnDefinition &column) {
51: 	D_ASSERT(expr->type == ExpressionType::VALUE_DEFAULT);
52: 	expr = ExpandDefaultExpression(column);
53: }
54: 
55: void ExpressionBinder::DoUpdateSetQualifyInLambda(FunctionExpression &function, const string &table_name,
56:                                                   vector<unordered_set<string>> &lambda_params) {
57: 
58: 	for (auto &child : function.children) {
59: 		if (child->expression_class != ExpressionClass::LAMBDA) {
60: 			DoUpdateSetQualify(child, table_name, lambda_params);
61: 			continue;
62: 		}
63: 
64: 		// Special-handling for LHS lambda parameters.
65: 		// We do not qualify them, and we add them to the lambda_params vector.
66: 		auto &lambda_expr = child->Cast<LambdaExpression>();
67: 		string error_message;
68: 		auto column_ref_expressions = lambda_expr.ExtractColumnRefExpressions(error_message);
69: 
70: 		if (!error_message.empty()) {
71: 			// Possibly a JSON function, qualify both LHS and RHS.
72: 			ParsedExpressionIterator::EnumerateChildren(*lambda_expr.lhs, [&](unique_ptr<ParsedExpression> &child) {
73: 				DoUpdateSetQualify(child, table_name, lambda_params);
74: 			});
75: 			ParsedExpressionIterator::EnumerateChildren(*lambda_expr.expr, [&](unique_ptr<ParsedExpression> &child) {
76: 				DoUpdateSetQualify(child, table_name, lambda_params);
77: 			});
78: 			continue;
79: 		}
80: 
81: 		// Push the lambda parameter names of this level.
82: 		lambda_params.emplace_back();
83: 		for (const auto &column_ref_expr : column_ref_expressions) {
84: 			const auto &column_ref = column_ref_expr.get().Cast<ColumnRefExpression>();
85: 			lambda_params.back().emplace(column_ref.GetName());
86: 		}
87: 
88: 		// Only qualify in the RHS of the expression.
89: 		ParsedExpressionIterator::EnumerateChildren(*lambda_expr.expr, [&](unique_ptr<ParsedExpression> &child) {
90: 			DoUpdateSetQualify(child, table_name, lambda_params);
91: 		});
92: 
93: 		lambda_params.pop_back();
94: 	}
95: }
96: 
97: void ExpressionBinder::DoUpdateSetQualify(unique_ptr<ParsedExpression> &expr, const string &table_name,
98:                                           vector<unordered_set<string>> &lambda_params) {
99: 
100: 	// We avoid ambiguity with EXCLUDED columns by qualifying all column references.
101: 	switch (expr->GetExpressionClass()) {
102: 	case ExpressionClass::COLUMN_REF: {
103: 		auto &col_ref = expr->Cast<ColumnRefExpression>();
104: 		if (col_ref.IsQualified()) {
105: 			return;
106: 		}
107: 
108: 		// Don't qualify lambda parameters.
109: 		if (LambdaExpression::IsLambdaParameter(lambda_params, col_ref.GetName())) {
110: 			return;
111: 		}
112: 
113: 		// Qualify the column reference.
114: 		expr = make_uniq<ColumnRefExpression>(col_ref.GetColumnName(), table_name);
115: 		return;
116: 	}
117: 	case ExpressionClass::FUNCTION: {
118: 		// Special-handling for lambdas, which are inside function expressions.
119: 		auto &function = expr->Cast<FunctionExpression>();
120: 		if (function.IsLambdaFunction()) {
121: 			return DoUpdateSetQualifyInLambda(function, table_name, lambda_params);
122: 		}
123: 		break;
124: 	}
125: 	case ExpressionClass::SUBQUERY: {
126: 		throw BinderException("DO UPDATE SET clause cannot contain a subquery");
127: 	}
128: 	default:
129: 		break;
130: 	}
131: 
132: 	ParsedExpressionIterator::EnumerateChildren(
133: 	    *expr, [&](unique_ptr<ParsedExpression> &child) { DoUpdateSetQualify(child, table_name, lambda_params); });
134: }
135: 
136: // Replace binding.table_index with 'dest' if it's 'source'
137: void ReplaceColumnBindings(Expression &expr, idx_t source, idx_t dest) {
138: 	if (expr.type == ExpressionType::BOUND_COLUMN_REF) {
139: 		auto &bound_columnref = expr.Cast<BoundColumnRefExpression>();
140: 		if (bound_columnref.binding.table_index == source) {
141: 			bound_columnref.binding.table_index = dest;
142: 		}
143: 	}
144: 	ExpressionIterator::EnumerateChildren(
145: 	    expr, [&](unique_ptr<Expression> &child) { ReplaceColumnBindings(*child, source, dest); });
146: }
147: 
148: void Binder::BindDoUpdateSetExpressions(const string &table_alias, LogicalInsert &insert, UpdateSetInfo &set_info,
149:                                         TableCatalogEntry &table, TableStorageInfo &storage_info) {
150: 	D_ASSERT(insert.children.size() == 1);
151: 	D_ASSERT(insert.children[0]->type == LogicalOperatorType::LOGICAL_PROJECTION);
152: 
153: 	vector<column_t> logical_column_ids;
154: 	vector<string> column_names;
155: 	D_ASSERT(set_info.columns.size() == set_info.expressions.size());
156: 
157: 	for (idx_t i = 0; i < set_info.columns.size(); i++) {
158: 		auto &colname = set_info.columns[i];
159: 		auto &expr = set_info.expressions[i];
160: 		if (!table.ColumnExists(colname)) {
161: 			throw BinderException("Referenced update column %s not found in table!", colname);
162: 		}
163: 		auto &column = table.GetColumn(colname);
164: 		if (column.Generated()) {
165: 			throw BinderException("Cant update column \"%s\" because it is a generated column!", column.Name());
166: 		}
167: 		if (std::find(insert.set_columns.begin(), insert.set_columns.end(), column.Physical()) !=
168: 		    insert.set_columns.end()) {
169: 			throw BinderException("Multiple assignments to same column \"%s\"", colname);
170: 		}
171: 		insert.set_columns.push_back(column.Physical());
172: 		logical_column_ids.push_back(column.Oid());
173: 		insert.set_types.push_back(column.Type());
174: 		column_names.push_back(colname);
175: 		if (expr->type == ExpressionType::VALUE_DEFAULT) {
176: 			expr = ExpandDefaultExpression(column);
177: 		}
178: 
179: 		// Qualify and bind the ON CONFLICT DO UPDATE SET expression.
180: 		UpdateBinder update_binder(*this, context);
181: 		update_binder.target_type = column.Type();
182: 
183: 		// Avoid ambiguity between existing table columns and EXCLUDED columns.
184: 		vector<unordered_set<string>> lambda_params;
185: 		update_binder.DoUpdateSetQualify(expr, table_alias, lambda_params);
186: 
187: 		auto bound_expr = update_binder.Bind(expr);
188: 		D_ASSERT(bound_expr);
189: 		insert.expressions.push_back(std::move(bound_expr));
190: 	}
191: 
192: 	// Figure out which columns are indexed on
193: 	unordered_set<column_t> indexed_columns;
194: 	for (auto &index : storage_info.index_info) {
195: 		for (auto &column_id : index.column_set) {
196: 			indexed_columns.insert(column_id);
197: 		}
198: 	}
199: 
200: 	// Verify that none of the columns that are targeted with a SET expression are indexed on
201: 	for (idx_t i = 0; i < logical_column_ids.size(); i++) {
202: 		auto &column = logical_column_ids[i];
203: 		if (indexed_columns.count(column)) {
204: 			throw BinderException("Can not assign to column '%s' because it has a UNIQUE/PRIMARY KEY constraint or is "
205: 			                      "referenced by an INDEX",
206: 			                      column_names[i]);
207: 		}
208: 	}
209: }
210: 
211: unique_ptr<UpdateSetInfo> CreateSetInfoForReplace(TableCatalogEntry &table, InsertStatement &insert,
212:                                                   TableStorageInfo &storage_info) {
213: 	auto set_info = make_uniq<UpdateSetInfo>();
214: 
215: 	auto &columns = set_info->columns;
216: 	// Figure out which columns are indexed on
217: 
218: 	unordered_set<column_t> indexed_columns;
219: 	for (auto &index : storage_info.index_info) {
220: 		for (auto &column_id : index.column_set) {
221: 			indexed_columns.insert(column_id);
222: 		}
223: 	}
224: 
225: 	auto &column_list = table.GetColumns();
226: 	if (insert.columns.empty()) {
227: 		for (auto &column : column_list.Physical()) {
228: 			auto &name = column.Name();
229: 			// FIXME: can these column names be aliased somehow?
230: 			if (indexed_columns.count(column.Oid())) {
231: 				continue;
232: 			}
233: 			columns.push_back(name);
234: 		}
235: 	} else {
236: 		// a list of columns was explicitly supplied, only update those
237: 		for (auto &name : insert.columns) {
238: 			auto &column = column_list.GetColumn(name);
239: 			if (indexed_columns.count(column.Oid())) {
240: 				continue;
241: 			}
242: 			columns.push_back(name);
243: 		}
244: 	}
245: 
246: 	// Create 'excluded' qualified column references of these columns
247: 	for (auto &column : columns) {
248: 		set_info->expressions.push_back(make_uniq<ColumnRefExpression>(column, "excluded"));
249: 	}
250: 
251: 	return set_info;
252: }
253: 
254: vector<column_t> GetColumnsToFetch(const TableBinding &binding) {
255: 	auto &bound_columns = binding.GetBoundColumnIds();
256: 	vector<column_t> result;
257: 	for (auto &col : bound_columns) {
258: 		result.push_back(col.GetPrimaryIndex());
259: 	}
260: 	return result;
261: }
262: 
263: void Binder::BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &table, InsertStatement &stmt) {
264: 	if (!stmt.on_conflict_info) {
265: 		insert.action_type = OnConflictAction::THROW;
266: 		return;
267: 	}
268: 	D_ASSERT(stmt.table_ref->type == TableReferenceType::BASE_TABLE);
269: 
270: 	// visit the table reference
271: 	auto bound_table = Bind(*stmt.table_ref);
272: 	if (bound_table->type != TableReferenceType::BASE_TABLE) {
273: 		throw BinderException("Can only update base table!");
274: 	}
275: 
276: 	auto &table_ref = stmt.table_ref->Cast<BaseTableRef>();
277: 	const string &table_alias = !table_ref.alias.empty() ? table_ref.alias : table_ref.table_name;
278: 
279: 	auto &on_conflict = *stmt.on_conflict_info;
280: 	D_ASSERT(on_conflict.action_type != OnConflictAction::THROW);
281: 	insert.action_type = on_conflict.action_type;
282: 
283: 	// obtain the table storage info
284: 	auto storage_info = table.GetStorageInfo(context);
285: 
286: 	auto &columns = table.GetColumns();
287: 	if (!on_conflict.indexed_columns.empty()) {
288: 		// Bind the ON CONFLICT (<columns>)
289: 
290: 		// create a mapping of (list index) -> (column index)
291: 		case_insensitive_map_t<idx_t> specified_columns;
292: 		for (idx_t i = 0; i < on_conflict.indexed_columns.size(); i++) {
293: 			specified_columns[on_conflict.indexed_columns[i]] = i;
294: 			auto column_index = table.GetColumnIndex(on_conflict.indexed_columns[i]);
295: 			if (column_index.index == COLUMN_IDENTIFIER_ROW_ID) {
296: 				throw BinderException("Cannot specify ROWID as ON CONFLICT target");
297: 			}
298: 			auto &col = columns.GetColumn(column_index);
299: 			if (col.Generated()) {
300: 				throw BinderException("Cannot specify a generated column as ON CONFLICT target");
301: 			}
302: 		}
303: 		for (auto &col : columns.Physical()) {
304: 			auto entry = specified_columns.find(col.Name());
305: 			if (entry != specified_columns.end()) {
306: 				// column was specified, set to the index
307: 				insert.on_conflict_filter.insert(col.Physical().index);
308: 			}
309: 		}
310: 		bool index_references_columns = false;
311: 		for (auto &index : storage_info.index_info) {
312: 			if (!index.is_unique) {
313: 				continue;
314: 			}
315: 			bool index_matches = insert.on_conflict_filter == index.column_set;
316: 			if (index_matches) {
317: 				index_references_columns = true;
318: 				break;
319: 			}
320: 		}
321: 		if (!index_references_columns) {
322: 			// Same as before, this is essentially a no-op, turning this into a DO THROW instead
323: 			// But since this makes no logical sense, it's probably better to throw an error
324: 			throw BinderException("The specified columns as conflict target are not referenced by a UNIQUE/PRIMARY KEY "
325: 			                      "CONSTRAINT or INDEX");
326: 		}
327: 	} else {
328: 		// When omitting the conflict target, the ON CONFLICT applies to every UNIQUE/PRIMARY KEY on the table
329: 
330: 		// We check if there are any constraints on the table, if there aren't we throw an error.
331: 		idx_t found_matching_indexes = 0;
332: 		for (auto &index : storage_info.index_info) {
333: 			if (!index.is_unique) {
334: 				continue;
335: 			}
336: 			auto &indexed_columns = index.column_set;
337: 			bool matches = false;
338: 			for (auto &column : table.GetColumns().Physical()) {
339: 				if (indexed_columns.count(column.Physical().index)) {
340: 					matches = true;
341: 					break;
342: 				}
343: 			}
344: 			found_matching_indexes += matches;
345: 		}
346: 
347: 		if (!found_matching_indexes) {
348: 			throw BinderException(
349: 			    "There are no UNIQUE/PRIMARY KEY Indexes that refer to this table, ON CONFLICT is a no-op");
350: 		} else if (found_matching_indexes != 1) {
351: 			if (insert.action_type != OnConflictAction::NOTHING) {
352: 				// When no conflict target is provided, and the action type is UPDATE,
353: 				// we only allow the operation when only a single Index exists
354: 				throw BinderException("Conflict target has to be provided for a DO UPDATE operation when the table has "
355: 				                      "multiple UNIQUE/PRIMARY KEY constraints");
356: 			}
357: 		}
358: 	}
359: 
360: 	// add the 'excluded' dummy table binding
361: 	AddTableName("excluded");
362: 	// add a bind context entry for it
363: 	auto excluded_index = GenerateTableIndex();
364: 	insert.excluded_table_index = excluded_index;
365: 	vector<string> table_column_names;
366: 	vector<LogicalType> table_column_types;
367: 	for (auto &col : columns.Physical()) {
368: 		table_column_names.push_back(col.Name());
369: 		table_column_types.push_back(col.Type());
370: 	}
371: 	bind_context.AddGenericBinding(excluded_index, "excluded", table_column_names, table_column_types);
372: 
373: 	if (on_conflict.condition) {
374: 		WhereBinder where_binder(*this, context);
375: 
376: 		// Avoid ambiguity between existing table columns and EXCLUDED columns.
377: 		vector<unordered_set<string>> lambda_params;
378: 		where_binder.DoUpdateSetQualify(on_conflict.condition, table_alias, lambda_params);
379: 
380: 		// Bind the ON CONFLICT ... WHERE clause.
381: 		auto condition = where_binder.Bind(on_conflict.condition);
382: 		insert.on_conflict_condition = std::move(condition);
383: 	}
384: 
385: 	optional_idx projection_index;
386: 	reference<vector<unique_ptr<LogicalOperator>>> insert_child_operators = insert.children;
387: 	while (!projection_index.IsValid()) {
388: 		if (insert_child_operators.get().empty()) {
389: 			// No further children to visit
390: 			break;
391: 		}
392: 		auto &current_child = insert_child_operators.get()[0];
393: 		auto table_indices = current_child->GetTableIndex();
394: 		if (table_indices.empty()) {
395: 			// This operator does not have a table index to refer to, we have to visit its children
396: 			insert_child_operators = current_child->children;
397: 			continue;
398: 		}
399: 		projection_index = table_indices[0];
400: 	}
401: 	if (!projection_index.IsValid()) {
402: 		throw InternalException("Could not locate a table_index from the children of the insert");
403: 	}
404: 
405: 	ErrorData unused;
406: 	auto original_binding = bind_context.GetBinding(table_alias, unused);
407: 	D_ASSERT(original_binding && !unused.HasError());
408: 
409: 	auto table_index = original_binding->index;
410: 
411: 	// Replace any column bindings to refer to the projection table_index, rather than the source table
412: 	if (insert.on_conflict_condition) {
413: 		ReplaceColumnBindings(*insert.on_conflict_condition, table_index, projection_index.GetIndex());
414: 	}
415: 
416: 	if (insert.action_type == OnConflictAction::REPLACE) {
417: 		D_ASSERT(on_conflict.set_info == nullptr);
418: 		on_conflict.set_info = CreateSetInfoForReplace(table, stmt, storage_info);
419: 		insert.action_type = OnConflictAction::UPDATE;
420: 	}
421: 	if (on_conflict.set_info && on_conflict.set_info->columns.empty()) {
422: 		// if we are doing INSERT OR REPLACE on a table with no columns outside of the primary key column
423: 		// convert to INSERT OR IGNORE
424: 		insert.action_type = OnConflictAction::NOTHING;
425: 	}
426: 	if (insert.action_type == OnConflictAction::NOTHING) {
427: 		if (!insert.on_conflict_condition) {
428: 			return;
429: 		}
430: 		// Get the column_ids we need to fetch later on from the conflicting tuples
431: 		// of the original table, to execute the expressions
432: 		D_ASSERT(original_binding->binding_type == BindingType::TABLE);
433: 		auto &table_binding = original_binding->Cast<TableBinding>();
434: 		insert.columns_to_fetch = GetColumnsToFetch(table_binding);
435: 		return;
436: 	}
437: 
438: 	D_ASSERT(on_conflict.set_info);
439: 	auto &set_info = *on_conflict.set_info;
440: 	D_ASSERT(set_info.columns.size() == set_info.expressions.size());
441: 
442: 	if (set_info.condition) {
443: 		WhereBinder where_binder(*this, context);
444: 
445: 		// Avoid ambiguity between existing table columns and EXCLUDED columns.
446: 		vector<unordered_set<string>> lambda_params;
447: 		where_binder.DoUpdateSetQualify(set_info.condition, table_alias, lambda_params);
448: 
449: 		// Bind the SET ... WHERE clause.
450: 		auto condition = where_binder.Bind(set_info.condition);
451: 		insert.do_update_condition = std::move(condition);
452: 	}
453: 
454: 	BindDoUpdateSetExpressions(table_alias, insert, set_info, table, storage_info);
455: 
456: 	// Get the column_ids we need to fetch later on from the conflicting tuples
457: 	// of the original table, to execute the expressions
458: 	D_ASSERT(original_binding->binding_type == BindingType::TABLE);
459: 	auto &table_binding = original_binding->Cast<TableBinding>();
460: 	insert.columns_to_fetch = GetColumnsToFetch(table_binding);
461: 
462: 	// Replace the column bindings to refer to the child operator
463: 	for (auto &expr : insert.expressions) {
464: 		// Change the non-excluded column references to refer to the projection index
465: 		ReplaceColumnBindings(*expr, table_index, projection_index.GetIndex());
466: 	}
467: 	// Do the same for the (optional) DO UPDATE condition
468: 	if (insert.do_update_condition) {
469: 		ReplaceColumnBindings(*insert.do_update_condition, table_index, projection_index.GetIndex());
470: 	}
471: }
472: 
473: BoundStatement Binder::Bind(InsertStatement &stmt) {
474: 	BoundStatement result;
475: 	result.names = {"Count"};
476: 	result.types = {LogicalType::BIGINT};
477: 
478: 	BindSchemaOrCatalog(stmt.catalog, stmt.schema);
479: 	auto &table = Catalog::GetEntry<TableCatalogEntry>(context, stmt.catalog, stmt.schema, stmt.table);
480: 	if (!table.temporary) {
481: 		// inserting into a non-temporary table: alters underlying database
482: 		auto &properties = GetStatementProperties();
483: 		properties.RegisterDBModify(table.catalog, context);
484: 	}
485: 
486: 	auto insert = make_uniq<LogicalInsert>(table, GenerateTableIndex());
487: 	// Add CTEs as bindable
488: 	AddCTEMap(stmt.cte_map);
489: 
490: 	auto values_list = stmt.GetValuesList();
491: 
492: 	// bind the root select node (if any)
493: 	BoundStatement root_select;
494: 	if (stmt.column_order == InsertColumnOrder::INSERT_BY_NAME) {
495: 		if (values_list) {
496: 			throw BinderException("INSERT BY NAME can only be used when inserting from a SELECT statement");
497: 		}
498: 		if (!stmt.columns.empty()) {
499: 			throw BinderException("INSERT BY NAME cannot be combined with an explicit column list");
500: 		}
501: 		D_ASSERT(stmt.select_statement);
502: 		// INSERT BY NAME - generate the columns from the names of the SELECT statement
503: 		auto select_binder = Binder::CreateBinder(context, this);
504: 		root_select = select_binder->Bind(*stmt.select_statement);
505: 		MoveCorrelatedExpressions(*select_binder);
506: 
507: 		stmt.columns = root_select.names;
508: 	}
509: 
510: 	vector<LogicalIndex> named_column_map;
511: 	if (!stmt.columns.empty() || stmt.default_values) {
512: 		// insertion statement specifies column list
513: 
514: 		// create a mapping of (list index) -> (column index)
515: 		case_insensitive_map_t<idx_t> column_name_map;
516: 		for (idx_t i = 0; i < stmt.columns.size(); i++) {
517: 			auto entry = column_name_map.insert(make_pair(stmt.columns[i], i));
518: 			if (!entry.second) {
519: 				throw BinderException("Duplicate column name \"%s\" in INSERT", stmt.columns[i]);
520: 			}
521: 			auto column_index = table.GetColumnIndex(stmt.columns[i]);
522: 			if (column_index.index == COLUMN_IDENTIFIER_ROW_ID) {
523: 				throw BinderException("Cannot explicitly insert values into rowid column");
524: 			}
525: 			auto &col = table.GetColumn(column_index);
526: 			if (col.Generated()) {
527: 				throw BinderException("Cannot insert into a generated column");
528: 			}
529: 			insert->expected_types.push_back(col.Type());
530: 			named_column_map.push_back(column_index);
531: 		}
532: 		for (auto &col : table.GetColumns().Physical()) {
533: 			auto entry = column_name_map.find(col.Name());
534: 			if (entry == column_name_map.end()) {
535: 				// column not specified, set index to DConstants::INVALID_INDEX
536: 				insert->column_index_map.push_back(DConstants::INVALID_INDEX);
537: 			} else {
538: 				// column was specified, set to the index
539: 				insert->column_index_map.push_back(entry->second);
540: 			}
541: 		}
542: 	} else {
543: 		// insert by position and no columns specified - insertion into all columns of the table
544: 		// intentionally don't populate 'column_index_map' as an indication of this
545: 		for (auto &col : table.GetColumns().Physical()) {
546: 			named_column_map.push_back(col.Logical());
547: 			insert->expected_types.push_back(col.Type());
548: 		}
549: 	}
550: 
551: 	// bind the default values
552: 	auto &catalog_name = table.ParentCatalog().GetName();
553: 	auto &schema_name = table.ParentSchema().name;
554: 	BindDefaultValues(table.GetColumns(), insert->bound_defaults, catalog_name, schema_name);
555: 	insert->bound_constraints = BindConstraints(table);
556: 	if (!stmt.select_statement && !stmt.default_values) {
557: 		result.plan = std::move(insert);
558: 		return result;
559: 	}
560: 	// Exclude the generated columns from this amount
561: 	idx_t expected_columns = stmt.columns.empty() ? table.GetColumns().PhysicalColumnCount() : stmt.columns.size();
562: 
563: 	// special case: check if we are inserting from a VALUES statement
564: 	if (values_list) {
565: 		auto &expr_list = values_list->Cast<ExpressionListRef>();
566: 		expr_list.expected_types.resize(expected_columns);
567: 		expr_list.expected_names.resize(expected_columns);
568: 
569: 		D_ASSERT(!expr_list.values.empty());
570: 		CheckInsertColumnCountMismatch(expected_columns, expr_list.values[0].size(), !stmt.columns.empty(),
571: 		                               table.name.c_str());
572: 
573: 		// VALUES list!
574: 		for (idx_t col_idx = 0; col_idx < expected_columns; col_idx++) {
575: 			D_ASSERT(named_column_map.size() >= col_idx);
576: 			auto &table_col_idx = named_column_map[col_idx];
577: 
578: 			// set the expected types as the types for the INSERT statement
579: 			auto &column = table.GetColumn(table_col_idx);
580: 			expr_list.expected_types[col_idx] = column.Type();
581: 			expr_list.expected_names[col_idx] = column.Name();
582: 
583: 			// now replace any DEFAULT values with the corresponding default expression
584: 			for (idx_t list_idx = 0; list_idx < expr_list.values.size(); list_idx++) {
585: 				if (expr_list.values[list_idx][col_idx]->type == ExpressionType::VALUE_DEFAULT) {
586: 					// DEFAULT value! replace the entry
587: 					ReplaceDefaultExpression(expr_list.values[list_idx][col_idx], column);
588: 				}
589: 			}
590: 		}
591: 	}
592: 
593: 	// parse select statement and add to logical plan
594: 	unique_ptr<LogicalOperator> root;
595: 	if (stmt.select_statement) {
596: 		if (stmt.column_order == InsertColumnOrder::INSERT_BY_POSITION) {
597: 			auto select_binder = Binder::CreateBinder(context, this);
598: 			root_select = select_binder->Bind(*stmt.select_statement);
599: 			MoveCorrelatedExpressions(*select_binder);
600: 		}
601: 		// inserting from a select - check if the column count matches
602: 		CheckInsertColumnCountMismatch(expected_columns, root_select.types.size(), !stmt.columns.empty(),
603: 		                               table.name.c_str());
604: 
605: 		root = CastLogicalOperatorToTypes(root_select.types, insert->expected_types, std::move(root_select.plan));
606: 	} else {
607: 		root = make_uniq<LogicalDummyScan>(GenerateTableIndex());
608: 	}
609: 	insert->AddChild(std::move(root));
610: 
611: 	BindOnConflictClause(*insert, table, stmt);
612: 
613: 	if (!stmt.returning_list.empty()) {
614: 		insert->return_chunk = true;
615: 		result.types.clear();
616: 		result.names.clear();
617: 		auto insert_table_index = GenerateTableIndex();
618: 		insert->table_index = insert_table_index;
619: 		unique_ptr<LogicalOperator> index_as_logicaloperator = std::move(insert);
620: 
621: 		return BindReturning(std::move(stmt.returning_list), table, stmt.table_ref ? stmt.table_ref->alias : string(),
622: 		                     insert_table_index, std::move(index_as_logicaloperator), std::move(result));
623: 	}
624: 
625: 	D_ASSERT(result.types.size() == result.names.size());
626: 	result.plan = std::move(insert);
627: 
628: 	auto &properties = GetStatementProperties();
629: 	properties.allow_stream_result = false;
630: 	properties.return_type = StatementReturnType::CHANGED_ROWS;
631: 	return result;
632: }
633: 
634: } // namespace duckdb
[end of src/planner/binder/statement/bind_insert.cpp]
[start of src/planner/binder/tableref/bind_pivot.cpp]
1: #include "duckdb/planner/binder.hpp"
2: #include "duckdb/parser/tableref/pivotref.hpp"
3: #include "duckdb/parser/tableref/subqueryref.hpp"
4: #include "duckdb/parser/query_node/select_node.hpp"
5: #include "duckdb/parser/expression/case_expression.hpp"
6: #include "duckdb/parser/expression/cast_expression.hpp"
7: #include "duckdb/parser/expression/columnref_expression.hpp"
8: #include "duckdb/parser/expression/comparison_expression.hpp"
9: #include "duckdb/parser/expression/conjunction_expression.hpp"
10: #include "duckdb/parser/expression/constant_expression.hpp"
11: #include "duckdb/parser/expression/function_expression.hpp"
12: #include "duckdb/planner/query_node/bound_select_node.hpp"
13: #include "duckdb/parser/expression/star_expression.hpp"
14: #include "duckdb/common/types/value_map.hpp"
15: #include "duckdb/parser/parsed_expression_iterator.hpp"
16: #include "duckdb/parser/expression/operator_expression.hpp"
17: #include "duckdb/planner/tableref/bound_subqueryref.hpp"
18: #include "duckdb/planner/tableref/bound_pivotref.hpp"
19: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
20: #include "duckdb/main/client_config.hpp"
21: #include "duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp"
22: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
23: #include "duckdb/main/query_result.hpp"
24: 
25: namespace duckdb {
26: 
27: static void ConstructPivots(PivotRef &ref, vector<PivotValueElement> &pivot_values, idx_t pivot_idx = 0,
28:                             const PivotValueElement &current_value = PivotValueElement()) {
29: 	auto &pivot = ref.pivots[pivot_idx];
30: 	bool last_pivot = pivot_idx + 1 == ref.pivots.size();
31: 	for (auto &entry : pivot.entries) {
32: 		PivotValueElement new_value = current_value;
33: 		string name = entry.alias;
34: 		D_ASSERT(entry.values.size() == pivot.pivot_expressions.size());
35: 		for (idx_t v = 0; v < entry.values.size(); v++) {
36: 			auto &value = entry.values[v];
37: 			new_value.values.push_back(value);
38: 			if (entry.alias.empty()) {
39: 				if (name.empty()) {
40: 					name = value.ToString();
41: 				} else {
42: 					name += "_" + value.ToString();
43: 				}
44: 			}
45: 		}
46: 		if (!current_value.name.empty()) {
47: 			new_value.name = current_value.name + "_" + name;
48: 		} else {
49: 			new_value.name = std::move(name);
50: 		}
51: 		if (last_pivot) {
52: 			pivot_values.push_back(std::move(new_value));
53: 		} else {
54: 			// need to recurse
55: 			ConstructPivots(ref, pivot_values, pivot_idx + 1, new_value);
56: 		}
57: 	}
58: }
59: 
60: static void ExtractPivotExpressions(ParsedExpression &expr, case_insensitive_set_t &handled_columns) {
61: 	if (expr.type == ExpressionType::COLUMN_REF) {
62: 		auto &child_colref = expr.Cast<ColumnRefExpression>();
63: 		if (child_colref.IsQualified()) {
64: 			throw BinderException("PIVOT expression cannot contain qualified columns");
65: 		}
66: 		handled_columns.insert(child_colref.GetColumnName());
67: 	}
68: 	ParsedExpressionIterator::EnumerateChildren(
69: 	    expr, [&](ParsedExpression &child) { ExtractPivotExpressions(child, handled_columns); });
70: }
71: 
72: void ExtractPivotAggregateExpression(ClientContext &context, ParsedExpression &expr,
73:                                      vector<reference<FunctionExpression>> &aggregates) {
74: 	if (expr.type == ExpressionType::FUNCTION) {
75: 		auto &aggr_function = expr.Cast<FunctionExpression>();
76: 
77: 		// check if this is an aggregate to ensure it is an aggregate and not a scalar function
78: 		auto &entry = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, aggr_function.catalog,
79: 		                                aggr_function.schema, aggr_function.function_name);
80: 		if (entry.type == CatalogType::AGGREGATE_FUNCTION_ENTRY) {
81: 			// aggregate
82: 			aggregates.push_back(aggr_function);
83: 			return;
84: 		}
85: 	}
86: 	if (expr.type == ExpressionType::COLUMN_REF) {
87: 		throw BinderException(expr, "Columns can only be referenced within the aggregate of a PIVOT expression");
88: 	}
89: 	ParsedExpressionIterator::EnumerateChildren(
90: 	    expr, [&](ParsedExpression &child) { ExtractPivotAggregateExpression(context, child, aggregates); });
91: }
92: 
93: static unique_ptr<SelectNode> ConstructInitialGrouping(PivotRef &ref, vector<unique_ptr<ParsedExpression>> all_columns,
94:                                                        const case_insensitive_set_t &handled_columns) {
95: 	auto subquery = make_uniq<SelectNode>();
96: 	subquery->from_table = std::move(ref.source);
97: 	if (ref.groups.empty()) {
98: 		// if rows are not specified any columns that are not pivoted/aggregated on are added to the GROUP BY clause
99: 		for (auto &entry : all_columns) {
100: 			if (entry->type != ExpressionType::COLUMN_REF) {
101: 				throw InternalException("Unexpected child of pivot source - not a ColumnRef");
102: 			}
103: 			auto &columnref = entry->Cast<ColumnRefExpression>();
104: 			if (handled_columns.find(columnref.GetColumnName()) == handled_columns.end()) {
105: 				// not handled - add to grouping set
106: 				subquery->groups.group_expressions.push_back(make_uniq<ConstantExpression>(
107: 				    Value::INTEGER(UnsafeNumericCast<int32_t>(subquery->select_list.size() + 1))));
108: 				subquery->select_list.push_back(make_uniq<ColumnRefExpression>(columnref.GetColumnName()));
109: 			}
110: 		}
111: 	} else {
112: 		// if rows are specified only the columns mentioned in rows are added as groups
113: 		for (auto &row : ref.groups) {
114: 			subquery->groups.group_expressions.push_back(make_uniq<ConstantExpression>(
115: 			    Value::INTEGER(UnsafeNumericCast<int32_t>(subquery->select_list.size() + 1))));
116: 			subquery->select_list.push_back(make_uniq<ColumnRefExpression>(row));
117: 		}
118: 	}
119: 	return subquery;
120: }
121: 
122: static unique_ptr<SelectNode> PivotFilteredAggregate(ClientContext &context, PivotRef &ref,
123:                                                      vector<unique_ptr<ParsedExpression>> all_columns,
124:                                                      const case_insensitive_set_t &handled_columns,
125:                                                      vector<PivotValueElement> pivot_values) {
126: 	auto subquery = ConstructInitialGrouping(ref, std::move(all_columns), handled_columns);
127: 
128: 	// push the filtered aggregates
129: 	for (auto &pivot_value : pivot_values) {
130: 		unique_ptr<ParsedExpression> filter;
131: 		idx_t pivot_value_idx = 0;
132: 		for (auto &pivot_column : ref.pivots) {
133: 			for (auto &pivot_expr : pivot_column.pivot_expressions) {
134: 				auto column_ref = make_uniq<CastExpression>(LogicalType::VARCHAR, pivot_expr->Copy());
135: 				auto constant_value = make_uniq<ConstantExpression>(
136: 				    pivot_value.values[pivot_value_idx++].DefaultCastAs(LogicalType::VARCHAR));
137: 				auto comp_expr = make_uniq<ComparisonExpression>(ExpressionType::COMPARE_NOT_DISTINCT_FROM,
138: 				                                                 std::move(column_ref), std::move(constant_value));
139: 				if (filter) {
140: 					filter = make_uniq<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, std::move(filter),
141: 					                                          std::move(comp_expr));
142: 				} else {
143: 					filter = std::move(comp_expr);
144: 				}
145: 			}
146: 		}
147: 		for (auto &aggregate : ref.aggregates) {
148: 			auto copied_aggr = aggregate->Copy();
149: 
150: 			vector<reference<FunctionExpression>> aggregates;
151: 			ExtractPivotAggregateExpression(context, *copied_aggr, aggregates);
152: 			D_ASSERT(aggregates.size() == 1);
153: 
154: 			auto &aggr = aggregates[0].get().Cast<FunctionExpression>();
155: 			aggr.filter = filter->Copy();
156: 			auto &aggr_name = aggregate->alias;
157: 			auto name = pivot_value.name;
158: 			if (ref.aggregates.size() > 1 || !aggr_name.empty()) {
159: 				// if there are multiple aggregates specified we add the name of the aggregate as well
160: 				name += "_" + (aggr_name.empty() ? aggregate->GetName() : aggr_name);
161: 			}
162: 			copied_aggr->alias = name;
163: 			subquery->select_list.push_back(std::move(copied_aggr));
164: 		}
165: 	}
166: 	return subquery;
167: }
168: 
169: struct PivotBindState {
170: 	vector<string> internal_group_names;
171: 	vector<string> group_names;
172: 	vector<string> aggregate_names;
173: 	vector<string> internal_aggregate_names;
174: };
175: 
176: static unique_ptr<SelectNode> PivotInitialAggregate(PivotBindState &bind_state, PivotRef &ref,
177:                                                     vector<unique_ptr<ParsedExpression>> all_columns,
178:                                                     const case_insensitive_set_t &handled_columns) {
179: 	auto subquery_stage1 = ConstructInitialGrouping(ref, std::move(all_columns), handled_columns);
180: 
181: 	idx_t group_count = 0;
182: 	for (auto &expr : subquery_stage1->select_list) {
183: 		bind_state.group_names.push_back(expr->GetName());
184: 		if (expr->alias.empty()) {
185: 			expr->alias = "__internal_pivot_group" + std::to_string(++group_count);
186: 		}
187: 		bind_state.internal_group_names.push_back(expr->alias);
188: 	}
189: 	// group by all of the pivot values
190: 	idx_t pivot_count = 0;
191: 	for (auto &pivot_column : ref.pivots) {
192: 		for (auto &pivot_expr : pivot_column.pivot_expressions) {
193: 			if (pivot_expr->alias.empty()) {
194: 				pivot_expr->alias = "__internal_pivot_ref" + std::to_string(++pivot_count);
195: 			}
196: 			auto pivot_alias = pivot_expr->alias;
197: 			subquery_stage1->groups.group_expressions.push_back(make_uniq<ConstantExpression>(
198: 			    Value::INTEGER(UnsafeNumericCast<int32_t>(subquery_stage1->select_list.size() + 1))));
199: 			subquery_stage1->select_list.push_back(std::move(pivot_expr));
200: 			pivot_expr = make_uniq<ColumnRefExpression>(std::move(pivot_alias));
201: 		}
202: 	}
203: 	idx_t aggregate_count = 0;
204: 	// finally add the aggregates
205: 	for (auto &aggregate : ref.aggregates) {
206: 		auto aggregate_alias = "__internal_pivot_aggregate" + std::to_string(++aggregate_count);
207: 		bind_state.aggregate_names.push_back(aggregate->alias);
208: 		bind_state.internal_aggregate_names.push_back(aggregate_alias);
209: 		aggregate->alias = std::move(aggregate_alias);
210: 		subquery_stage1->select_list.push_back(std::move(aggregate));
211: 	}
212: 	return subquery_stage1;
213: }
214: 
215: unique_ptr<ParsedExpression> ConstructPivotExpression(unique_ptr<ParsedExpression> pivot_expr) {
216: 	auto cast = make_uniq<CastExpression>(LogicalType::VARCHAR, std::move(pivot_expr));
217: 	vector<unique_ptr<ParsedExpression>> coalesce_children;
218: 	coalesce_children.push_back(std::move(cast));
219: 	coalesce_children.push_back(make_uniq<ConstantExpression>(Value("NULL")));
220: 	auto coalesce = make_uniq<OperatorExpression>(ExpressionType::OPERATOR_COALESCE, std::move(coalesce_children));
221: 	return std::move(coalesce);
222: }
223: 
224: static unique_ptr<SelectNode> PivotListAggregate(PivotBindState &bind_state, PivotRef &ref,
225:                                                  unique_ptr<SelectNode> subquery_stage1) {
226: 	auto subquery_stage2 = make_uniq<SelectNode>();
227: 	// wrap the subquery of stage 1
228: 	auto subquery_select = make_uniq<SelectStatement>();
229: 	subquery_select->node = std::move(subquery_stage1);
230: 	auto subquery_ref = make_uniq<SubqueryRef>(std::move(subquery_select));
231: 
232: 	// add all of the groups
233: 	for (idx_t gr = 0; gr < bind_state.internal_group_names.size(); gr++) {
234: 		subquery_stage2->groups.group_expressions.push_back(make_uniq<ConstantExpression>(
235: 		    Value::INTEGER(UnsafeNumericCast<int32_t>(subquery_stage2->select_list.size() + 1))));
236: 		auto group_reference = make_uniq<ColumnRefExpression>(bind_state.internal_group_names[gr]);
237: 		group_reference->alias = bind_state.internal_group_names[gr];
238: 		subquery_stage2->select_list.push_back(std::move(group_reference));
239: 	}
240: 
241: 	// construct the list aggregates
242: 	for (idx_t aggr = 0; aggr < bind_state.internal_aggregate_names.size(); aggr++) {
243: 		auto colref = make_uniq<ColumnRefExpression>(bind_state.internal_aggregate_names[aggr]);
244: 		vector<unique_ptr<ParsedExpression>> list_children;
245: 		list_children.push_back(std::move(colref));
246: 		auto aggregate = make_uniq<FunctionExpression>("list", std::move(list_children));
247: 		aggregate->alias = bind_state.internal_aggregate_names[aggr];
248: 		subquery_stage2->select_list.push_back(std::move(aggregate));
249: 	}
250: 	// construct the pivot list
251: 	auto pivot_name = "__internal_pivot_name";
252: 	unique_ptr<ParsedExpression> expr;
253: 	for (auto &pivot : ref.pivots) {
254: 		for (auto &pivot_expr : pivot.pivot_expressions) {
255: 			// coalesce(pivot::VARCHAR, 'NULL')
256: 			auto coalesce = ConstructPivotExpression(std::move(pivot_expr));
257: 			if (!expr) {
258: 				expr = std::move(coalesce);
259: 			} else {
260: 				// string concat
261: 				vector<unique_ptr<ParsedExpression>> concat_children;
262: 				concat_children.push_back(std::move(expr));
263: 				concat_children.push_back(make_uniq<ConstantExpression>(Value("_")));
264: 				concat_children.push_back(std::move(coalesce));
265: 				auto concat = make_uniq<FunctionExpression>("concat", std::move(concat_children));
266: 				expr = std::move(concat);
267: 			}
268: 		}
269: 	}
270: 	// list(coalesce)
271: 	vector<unique_ptr<ParsedExpression>> list_children;
272: 	list_children.push_back(std::move(expr));
273: 	auto aggregate = make_uniq<FunctionExpression>("list", std::move(list_children));
274: 
275: 	aggregate->alias = pivot_name;
276: 	subquery_stage2->select_list.push_back(std::move(aggregate));
277: 
278: 	subquery_stage2->from_table = std::move(subquery_ref);
279: 	return subquery_stage2;
280: }
281: 
282: static unique_ptr<SelectNode> PivotFinalOperator(PivotBindState &bind_state, PivotRef &ref,
283:                                                  unique_ptr<SelectNode> subquery,
284:                                                  vector<PivotValueElement> pivot_values) {
285: 	auto final_pivot_operator = make_uniq<SelectNode>();
286: 	// wrap the subquery of stage 1
287: 	auto subquery_select = make_uniq<SelectStatement>();
288: 	subquery_select->node = std::move(subquery);
289: 	auto subquery_ref = make_uniq<SubqueryRef>(std::move(subquery_select));
290: 
291: 	auto bound_pivot = make_uniq<PivotRef>();
292: 	bound_pivot->bound_pivot_values = std::move(pivot_values);
293: 	bound_pivot->bound_group_names = std::move(bind_state.group_names);
294: 	bound_pivot->bound_aggregate_names = std::move(bind_state.aggregate_names);
295: 	bound_pivot->source = std::move(subquery_ref);
296: 
297: 	final_pivot_operator->select_list.push_back(make_uniq<StarExpression>());
298: 	final_pivot_operator->from_table = std::move(bound_pivot);
299: 	return final_pivot_operator;
300: }
301: 
302: void ExtractPivotAggregates(BoundTableRef &node, vector<unique_ptr<Expression>> &aggregates) {
303: 	if (node.type != TableReferenceType::SUBQUERY) {
304: 		throw InternalException("Pivot - Expected a subquery");
305: 	}
306: 	auto &subq = node.Cast<BoundSubqueryRef>();
307: 	if (subq.subquery->type != QueryNodeType::SELECT_NODE) {
308: 		throw InternalException("Pivot - Expected a select node");
309: 	}
310: 	auto &select = subq.subquery->Cast<BoundSelectNode>();
311: 	if (select.from_table->type != TableReferenceType::SUBQUERY) {
312: 		throw InternalException("Pivot - Expected another subquery");
313: 	}
314: 	auto &subq2 = select.from_table->Cast<BoundSubqueryRef>();
315: 	if (subq2.subquery->type != QueryNodeType::SELECT_NODE) {
316: 		throw InternalException("Pivot - Expected another select node");
317: 	}
318: 	auto &select2 = subq2.subquery->Cast<BoundSelectNode>();
319: 	for (auto &aggr : select2.aggregates) {
320: 		if (aggr->alias == "__collated_group") {
321: 			continue;
322: 		}
323: 		aggregates.push_back(aggr->Copy());
324: 	}
325: }
326: 
327: unique_ptr<BoundTableRef> Binder::BindBoundPivot(PivotRef &ref) {
328: 	// bind the child table in a child binder
329: 	auto result = make_uniq<BoundPivotRef>();
330: 	result->bind_index = GenerateTableIndex();
331: 	result->child_binder = Binder::CreateBinder(context, this);
332: 	result->child = result->child_binder->Bind(*ref.source);
333: 
334: 	auto &aggregates = result->bound_pivot.aggregates;
335: 	ExtractPivotAggregates(*result->child, aggregates);
336: 	if (aggregates.size() != ref.bound_aggregate_names.size()) {
337: 		throw InternalException("Pivot aggregate count mismatch (expected %llu, found %llu)",
338: 		                        ref.bound_aggregate_names.size(), aggregates.size());
339: 	}
340: 
341: 	vector<string> child_names;
342: 	vector<LogicalType> child_types;
343: 	result->child_binder->bind_context.GetTypesAndNames(child_names, child_types);
344: 
345: 	vector<string> names;
346: 	vector<LogicalType> types;
347: 	// emit the groups
348: 	for (idx_t i = 0; i < ref.bound_group_names.size(); i++) {
349: 		names.push_back(ref.bound_group_names[i]);
350: 		types.push_back(child_types[i]);
351: 	}
352: 	// emit the pivot columns
353: 	for (auto &pivot_value : ref.bound_pivot_values) {
354: 		for (idx_t aggr_idx = 0; aggr_idx < ref.bound_aggregate_names.size(); aggr_idx++) {
355: 			auto &aggr = aggregates[aggr_idx];
356: 			auto &aggr_name = ref.bound_aggregate_names[aggr_idx];
357: 			auto name = pivot_value.name;
358: 			if (aggregates.size() > 1 || !aggr_name.empty()) {
359: 				// if there are multiple aggregates specified we add the name of the aggregate as well
360: 				name += "_" + (aggr_name.empty() ? aggr->GetName() : aggr_name);
361: 			}
362: 			string pivot_str;
363: 			for (auto &value : pivot_value.values) {
364: 				auto str = value.ToString();
365: 				if (pivot_str.empty()) {
366: 					pivot_str = std::move(str);
367: 				} else {
368: 					pivot_str += "_" + str;
369: 				}
370: 			}
371: 			result->bound_pivot.pivot_values.push_back(std::move(pivot_str));
372: 			names.push_back(std::move(name));
373: 			types.push_back(aggr->return_type);
374: 		}
375: 	}
376: 	result->bound_pivot.group_count = ref.bound_group_names.size();
377: 	result->bound_pivot.types = types;
378: 	auto subquery_alias = ref.alias.empty() ? "__unnamed_pivot" : ref.alias;
379: 	QueryResult::DeduplicateColumns(names);
380: 	bind_context.AddGenericBinding(result->bind_index, subquery_alias, names, types);
381: 
382: 	MoveCorrelatedExpressions(*result->child_binder);
383: 	return std::move(result);
384: }
385: 
386: unique_ptr<SelectNode> Binder::BindPivot(PivotRef &ref, vector<unique_ptr<ParsedExpression>> all_columns) {
387: 	// keep track of the columns by which we pivot/aggregate
388: 	// any columns which are not pivoted/aggregated on are added to the GROUP BY clause
389: 	case_insensitive_set_t handled_columns;
390: 
391: 	vector<reference<FunctionExpression>> pivot_aggregates;
392: 	// parse the aggregate, and extract the referenced columns from the aggregate
393: 	for (auto &aggr : ref.aggregates) {
394: 		if (aggr->HasSubquery()) {
395: 			throw BinderException(*aggr, "Pivot expression cannot contain subqueries");
396: 		}
397: 		if (aggr->IsWindow()) {
398: 			throw BinderException(*aggr, "Pivot expression cannot contain window functions");
399: 		}
400: 		idx_t aggregate_count = pivot_aggregates.size();
401: 		ExtractPivotAggregateExpression(context, *aggr, pivot_aggregates);
402: 		if (pivot_aggregates.size() != aggregate_count + 1) {
403: 			string error_str = pivot_aggregates.size() == aggregate_count
404: 			                       ? "but no aggregates were found"
405: 			                       : "but " + to_string(pivot_aggregates.size() - aggregate_count) + " were found";
406: 			throw BinderException(*aggr, "Pivot expression must contain exactly one aggregate, %s", error_str);
407: 		}
408: 	}
409: 	for (auto &aggr : pivot_aggregates) {
410: 		ExtractPivotExpressions(aggr.get(), handled_columns);
411: 	}
412: 
413: 	// first add all pivots to the set of handled columns, and check for duplicates
414: 	idx_t total_pivots = 1;
415: 	for (auto &pivot : ref.pivots) {
416: 		if (!pivot.pivot_enum.empty()) {
417: 			auto &type_entry =
418: 			    Catalog::GetEntry<TypeCatalogEntry>(context, INVALID_CATALOG, INVALID_SCHEMA, pivot.pivot_enum);
419: 			auto type = type_entry.user_type;
420: 			if (type.id() != LogicalTypeId::ENUM) {
421: 				throw BinderException(ref, "Pivot must reference an ENUM type: \"%s\" is of type \"%s\"",
422: 				                      pivot.pivot_enum, type.ToString());
423: 			}
424: 			auto enum_size = EnumType::GetSize(type);
425: 			for (idx_t i = 0; i < enum_size; i++) {
426: 				auto enum_value = EnumType::GetValue(Value::ENUM(i, type));
427: 				PivotColumnEntry entry;
428: 				entry.values.emplace_back(enum_value);
429: 				entry.alias = std::move(enum_value);
430: 				pivot.entries.push_back(std::move(entry));
431: 			}
432: 		}
433: 		total_pivots *= pivot.entries.size();
434: 		// add the pivoted column to the columns that have been handled
435: 		for (auto &pivot_name : pivot.pivot_expressions) {
436: 			ExtractPivotExpressions(*pivot_name, handled_columns);
437: 		}
438: 		value_set_t pivots;
439: 		for (auto &entry : pivot.entries) {
440: 			D_ASSERT(!entry.expr);
441: 			Value val;
442: 			if (entry.values.size() == 1) {
443: 				val = entry.values[0];
444: 			} else {
445: 				val = Value::LIST(LogicalType::VARCHAR, entry.values);
446: 			}
447: 			if (pivots.find(val) != pivots.end()) {
448: 				throw BinderException(ref, "The value \"%s\" was specified multiple times in the IN clause",
449: 				                      val.ToString());
450: 			}
451: 			if (entry.values.size() != pivot.pivot_expressions.size()) {
452: 				throw BinderException(ref, "PIVOT IN list - inconsistent amount of rows - expected %d but got %d",
453: 				                      pivot.pivot_expressions.size(), entry.values.size());
454: 			}
455: 			pivots.insert(val);
456: 		}
457: 	}
458: 	auto &client_config = ClientConfig::GetConfig(context);
459: 	auto pivot_limit = client_config.pivot_limit;
460: 	if (total_pivots >= pivot_limit) {
461: 		throw BinderException(ref, "Pivot column limit of %llu exceeded. Use SET pivot_limit=X to increase the limit.",
462: 		                      client_config.pivot_limit);
463: 	}
464: 
465: 	// construct the required pivot values recursively
466: 	vector<PivotValueElement> pivot_values;
467: 	ConstructPivots(ref, pivot_values);
468: 
469: 	unique_ptr<SelectNode> pivot_node;
470: 	// pivots have three components
471: 	// - the pivots (i.e. future column names)
472: 	// - the groups (i.e. the future row names
473: 	// - the aggregates (i.e. the values of the pivot columns)
474: 
475: 	// we have two ways of executing a pivot statement
476: 	// (1) the straightforward manner of filtered aggregates SUM(..) FILTER (pivot_value=X)
477: 	// (2) computing the aggregates once, then using LIST to group the aggregates together with the PIVOT operator
478: 	// -> filtered aggregates are faster when there are FEW pivot values
479: 	// -> LIST is faster when there are MANY pivot values
480: 	// we switch dynamically based on the number of pivots to compute
481: 	if (pivot_values.size() <= client_config.pivot_filter_threshold) {
482: 		// use a set of filtered aggregates
483: 		pivot_node =
484: 		    PivotFilteredAggregate(context, ref, std::move(all_columns), handled_columns, std::move(pivot_values));
485: 	} else {
486: 		// executing a pivot statement happens in three stages
487: 		// 1) execute the query "SELECT {groups}, {pivots}, {aggregates} FROM {from_clause} GROUP BY {groups}, {pivots}
488: 		// this computes all values that are required in the final result, but not yet in the correct orientation
489: 		// 2) execute the query "SELECT {groups}, LIST({pivots}), LIST({aggregates}) FROM [Q1] GROUP BY {groups}
490: 		// this pushes all pivots and aggregates that belong to a specific group together in an aligned manner
491: 		// 3) push a PIVOT operator, that performs the actual pivoting of the values into the different columns
492: 
493: 		PivotBindState bind_state;
494: 		// Pivot Stage 1
495: 		// SELECT {groups}, {pivots}, {aggregates} FROM {from_clause} GROUP BY {groups}, {pivots}
496: 		auto subquery_stage1 = PivotInitialAggregate(bind_state, ref, std::move(all_columns), handled_columns);
497: 
498: 		// Pivot stage 2
499: 		// SELECT {groups}, LIST({pivots}), LIST({aggregates}) FROM [Q1] GROUP BY {groups}
500: 		auto subquery_stage2 = PivotListAggregate(bind_state, ref, std::move(subquery_stage1));
501: 
502: 		// Pivot stage 3
503: 		// construct the final pivot operator
504: 		pivot_node = PivotFinalOperator(bind_state, ref, std::move(subquery_stage2), std::move(pivot_values));
505: 	}
506: 	return pivot_node;
507: }
508: 
509: struct UnpivotEntry {
510: 	string alias;
511: 	vector<string> column_names;
512: 	vector<unique_ptr<ParsedExpression>> expressions;
513: };
514: 
515: void Binder::ExtractUnpivotEntries(Binder &child_binder, PivotColumnEntry &entry,
516:                                    vector<UnpivotEntry> &unpivot_entries) {
517: 	if (!entry.expr) {
518: 		// pivot entry without an expression - generate one
519: 		UnpivotEntry unpivot_entry;
520: 		unpivot_entry.alias = entry.alias;
521: 		for (auto &val : entry.values) {
522: 			auto column_name = val.ToString();
523: 			if (column_name.empty()) {
524: 				throw BinderException("UNPIVOT - empty column name not supported");
525: 			}
526: 			unpivot_entry.expressions.push_back(make_uniq<ColumnRefExpression>(column_name));
527: 		}
528: 		unpivot_entries.push_back(std::move(unpivot_entry));
529: 		return;
530: 	}
531: 	D_ASSERT(entry.values.empty());
532: 	// expand star expressions (if any)
533: 	vector<unique_ptr<ParsedExpression>> star_columns;
534: 	child_binder.ExpandStarExpression(std::move(entry.expr), star_columns);
535: 
536: 	for (auto &expr : star_columns) {
537: 		// create one pivot entry per result column
538: 		UnpivotEntry unpivot_entry;
539: 		if (!expr->alias.empty()) {
540: 			unpivot_entry.alias = std::move(expr->alias);
541: 		}
542: 		unpivot_entry.expressions.push_back(std::move(expr));
543: 		unpivot_entries.push_back(std::move(unpivot_entry));
544: 	}
545: }
546: 
547: void Binder::ExtractUnpivotColumnName(ParsedExpression &expr, vector<string> &result) {
548: 	if (expr.type == ExpressionType::COLUMN_REF) {
549: 		auto &colref = expr.Cast<ColumnRefExpression>();
550: 		result.push_back(colref.GetColumnName());
551: 		return;
552: 	}
553: 	if (expr.type == ExpressionType::SUBQUERY) {
554: 		throw BinderException(expr, "UNPIVOT list cannot contain subqueries");
555: 	}
556: 	ParsedExpressionIterator::EnumerateChildren(
557: 	    expr, [&](ParsedExpression &child) { ExtractUnpivotColumnName(child, result); });
558: }
559: 
560: unique_ptr<SelectNode> Binder::BindUnpivot(Binder &child_binder, PivotRef &ref,
561:                                            vector<unique_ptr<ParsedExpression>> all_columns,
562:                                            unique_ptr<ParsedExpression> &where_clause) {
563: 	D_ASSERT(ref.groups.empty());
564: 	D_ASSERT(ref.pivots.size() == 1);
565: 
566: 	auto select_node = make_uniq<SelectNode>();
567: 	select_node->from_table = std::move(ref.source);
568: 
569: 	// handle the pivot
570: 	auto &unpivot = ref.pivots[0];
571: 
572: 	// handle star expressions in any entries
573: 	vector<UnpivotEntry> unpivot_entries;
574: 	for (auto &entry : unpivot.entries) {
575: 		ExtractUnpivotEntries(child_binder, entry, unpivot_entries);
576: 	}
577: 	if (unpivot_entries.empty()) {
578: 		throw BinderException(ref, "UNPIVOT clause must unpivot on at least one column - zero were provided");
579: 	}
580: 
581: 	case_insensitive_set_t handled_columns;
582: 	case_insensitive_map_t<string> name_map;
583: 	for (auto &entry : unpivot_entries) {
584: 		for (auto &unpivot_expr : entry.expressions) {
585: 			vector<string> result;
586: 			ExtractUnpivotColumnName(*unpivot_expr, result);
587: 			if (result.empty()) {
588: 
589: 				throw BinderException(
590: 				    *unpivot_expr,
591: 				    "UNPIVOT clause must contain exactly one column - expression \"%s\" does not contain any",
592: 				    unpivot_expr->ToString());
593: 			}
594: 			if (result.size() > 1) {
595: 				throw BinderException(
596: 				    *unpivot_expr,
597: 				    "UNPIVOT clause must contain exactly one column - expression \"%s\" contains multiple (%s)",
598: 				    unpivot_expr->ToString(), StringUtil::Join(result, ", "));
599: 			}
600: 			handled_columns.insert(result[0]);
601: 			entry.column_names.push_back(std::move(result[0]));
602: 		}
603: 	}
604: 
605: 	for (auto &col_expr : all_columns) {
606: 		if (col_expr->type != ExpressionType::COLUMN_REF) {
607: 			throw InternalException("Unexpected child of pivot source - not a ColumnRef");
608: 		}
609: 		auto &columnref = col_expr->Cast<ColumnRefExpression>();
610: 		auto &column_name = columnref.GetColumnName();
611: 		auto entry = handled_columns.find(column_name);
612: 		if (entry == handled_columns.end()) {
613: 			// not handled - add to the set of regularly selected columns
614: 			select_node->select_list.push_back(std::move(col_expr));
615: 		} else {
616: 			name_map[column_name] = column_name;
617: 			handled_columns.erase(entry);
618: 		}
619: 	}
620: 	if (!handled_columns.empty()) {
621: 		for (auto &entry : handled_columns) {
622: 			throw BinderException(
623: 			    ref, "Column \"%s\" referenced in UNPIVOT but no matching entry was found in the table", entry);
624: 		}
625: 	}
626: 	vector<Value> unpivot_names;
627: 	for (auto &entry : unpivot_entries) {
628: 		string generated_name;
629: 		D_ASSERT(entry.expressions.size() == entry.column_names.size());
630: 		for (idx_t c = 0; c < entry.expressions.size(); c++) {
631: 			auto name_entry = name_map.find(entry.column_names[c]);
632: 			if (name_entry == name_map.end()) {
633: 				throw InternalException("Unpivot - could not find column name in name map");
634: 			}
635: 			if (!generated_name.empty()) {
636: 				generated_name += "_";
637: 			}
638: 			generated_name += name_entry->second;
639: 		}
640: 		unpivot_names.emplace_back(!entry.alias.empty() ? entry.alias : generated_name);
641: 	}
642: 	vector<vector<unique_ptr<ParsedExpression>>> unpivot_expressions;
643: 	for (idx_t v_idx = 1; v_idx < unpivot_entries.size(); v_idx++) {
644: 		if (unpivot_entries[v_idx].expressions.size() != unpivot_entries[0].expressions.size()) {
645: 			throw BinderException(
646: 			    ref,
647: 			    "UNPIVOT value count mismatch - entry has %llu values, but expected all entries to have %llu values",
648: 			    unpivot_entries[v_idx].expressions.size(), unpivot_entries[0].expressions.size());
649: 		}
650: 	}
651: 
652: 	for (idx_t v_idx = 0; v_idx < unpivot_entries[0].expressions.size(); v_idx++) {
653: 		vector<unique_ptr<ParsedExpression>> expressions;
654: 		expressions.reserve(unpivot_entries.size());
655: 		for (auto &entry : unpivot_entries) {
656: 			expressions.push_back(std::move(entry.expressions[v_idx]));
657: 		}
658: 		unpivot_expressions.push_back(std::move(expressions));
659: 	}
660: 
661: 	// construct the UNNEST expression for the set of names (constant)
662: 	auto unpivot_list = Value::LIST(LogicalType::VARCHAR, std::move(unpivot_names));
663: 	auto unpivot_name_expr = make_uniq<ConstantExpression>(std::move(unpivot_list));
664: 	vector<unique_ptr<ParsedExpression>> unnest_name_children;
665: 	unnest_name_children.push_back(std::move(unpivot_name_expr));
666: 	auto unnest_name_expr = make_uniq<FunctionExpression>("unnest", std::move(unnest_name_children));
667: 	unnest_name_expr->alias = unpivot.unpivot_names[0];
668: 	select_node->select_list.push_back(std::move(unnest_name_expr));
669: 
670: 	// construct the UNNEST expression for the set of unpivoted columns
671: 	if (ref.unpivot_names.size() != unpivot_expressions.size()) {
672: 		throw BinderException(ref, "UNPIVOT name count mismatch - got %d names but %d expressions",
673: 		                      ref.unpivot_names.size(), unpivot_expressions.size());
674: 	}
675: 	for (idx_t i = 0; i < unpivot_expressions.size(); i++) {
676: 		auto list_expr = make_uniq<FunctionExpression>("unpivot_list", std::move(unpivot_expressions[i]));
677: 		vector<unique_ptr<ParsedExpression>> unnest_val_children;
678: 		unnest_val_children.push_back(std::move(list_expr));
679: 		auto unnest_val_expr = make_uniq<FunctionExpression>("unnest", std::move(unnest_val_children));
680: 		auto unnest_name = i < ref.column_name_alias.size() ? ref.column_name_alias[i] : ref.unpivot_names[i];
681: 		unnest_val_expr->alias = unnest_name;
682: 		select_node->select_list.push_back(std::move(unnest_val_expr));
683: 		if (!ref.include_nulls) {
684: 			// if we are running with EXCLUDE NULLS we need to add an IS NOT NULL filter
685: 			auto colref = make_uniq<ColumnRefExpression>(unnest_name);
686: 			auto filter = make_uniq<OperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, std::move(colref));
687: 			if (where_clause) {
688: 				where_clause = make_uniq<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND,
689: 				                                                std::move(where_clause), std::move(filter));
690: 			} else {
691: 				where_clause = std::move(filter);
692: 			}
693: 		}
694: 	}
695: 	return select_node;
696: }
697: 
698: unique_ptr<BoundTableRef> Binder::Bind(PivotRef &ref) {
699: 	if (!ref.source) {
700: 		throw InternalException("Pivot without a source!?");
701: 	}
702: 	if (!ref.bound_pivot_values.empty() || !ref.bound_group_names.empty() || !ref.bound_aggregate_names.empty()) {
703: 		// bound pivot
704: 		return BindBoundPivot(ref);
705: 	}
706: 
707: 	// bind the source of the pivot
708: 	// we need to do this to be able to expand star expressions
709: 	if (ref.source->type == TableReferenceType::SUBQUERY && ref.source->alias.empty()) {
710: 		ref.source->alias = "__internal_pivot_alias_" + to_string(GenerateTableIndex());
711: 	}
712: 	auto copied_source = ref.source->Copy();
713: 	auto star_binder = Binder::CreateBinder(context, this);
714: 	star_binder->Bind(*copied_source);
715: 
716: 	// figure out the set of column names that are in the source of the pivot
717: 	vector<unique_ptr<ParsedExpression>> all_columns;
718: 	star_binder->ExpandStarExpression(make_uniq<StarExpression>(), all_columns);
719: 
720: 	unique_ptr<SelectNode> select_node;
721: 	unique_ptr<ParsedExpression> where_clause;
722: 	if (!ref.aggregates.empty()) {
723: 		select_node = BindPivot(ref, std::move(all_columns));
724: 	} else {
725: 		select_node = BindUnpivot(*star_binder, ref, std::move(all_columns), where_clause);
726: 	}
727: 	// bind the generated select node
728: 	auto child_binder = Binder::CreateBinder(context, this);
729: 	auto bound_select_node = child_binder->BindNode(*select_node);
730: 	auto root_index = bound_select_node->GetRootIndex();
731: 	BoundQueryNode *bound_select_ptr = bound_select_node.get();
732: 
733: 	unique_ptr<BoundTableRef> result;
734: 	MoveCorrelatedExpressions(*child_binder);
735: 	result = make_uniq<BoundSubqueryRef>(std::move(child_binder), std::move(bound_select_node));
736: 	auto subquery_alias = ref.alias.empty() ? "__unnamed_pivot" : ref.alias;
737: 	SubqueryRef subquery_ref(nullptr, subquery_alias);
738: 	subquery_ref.column_name_alias = std::move(ref.column_name_alias);
739: 	if (where_clause) {
740: 		// if a WHERE clause was provided - bind a subquery holding the WHERE clause
741: 		// we need to bind a new subquery here because the WHERE clause has to be applied AFTER the unnest
742: 		child_binder = Binder::CreateBinder(context, this);
743: 		child_binder->bind_context.AddSubquery(root_index, subquery_ref.alias, subquery_ref, *bound_select_ptr);
744: 		auto where_query = make_uniq<SelectNode>();
745: 		where_query->select_list.push_back(make_uniq<StarExpression>());
746: 		where_query->where_clause = std::move(where_clause);
747: 		bound_select_node = child_binder->BindSelectNode(*where_query, std::move(result));
748: 		bound_select_ptr = bound_select_node.get();
749: 		root_index = bound_select_node->GetRootIndex();
750: 		result = make_uniq<BoundSubqueryRef>(std::move(child_binder), std::move(bound_select_node));
751: 	}
752: 	bind_context.AddSubquery(root_index, subquery_ref.alias, subquery_ref, *bound_select_ptr);
753: 	return result;
754: }
755: 
756: } // namespace duckdb
[end of src/planner/binder/tableref/bind_pivot.cpp]
[start of src/planner/subquery/flatten_dependent_join.cpp]
1: #include "duckdb/planner/subquery/flatten_dependent_join.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp"
4: #include "duckdb/common/operator/add.hpp"
5: #include "duckdb/function/aggregate/distributive_functions.hpp"
6: #include "duckdb/function/aggregate/distributive_function_utils.hpp"
7: #include "duckdb/planner/binder.hpp"
8: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
9: #include "duckdb/planner/expression/list.hpp"
10: #include "duckdb/planner/logical_operator_visitor.hpp"
11: #include "duckdb/planner/operator/list.hpp"
12: #include "duckdb/planner/subquery/has_correlated_expressions.hpp"
13: #include "duckdb/planner/subquery/rewrite_correlated_expressions.hpp"
14: #include "duckdb/planner/subquery/rewrite_cte_scan.hpp"
15: #include "duckdb/planner/operator/logical_dependent_join.hpp"
16: #include "duckdb/execution/column_binding_resolver.hpp"
17: 
18: namespace duckdb {
19: 
20: FlattenDependentJoins::FlattenDependentJoins(Binder &binder, const vector<CorrelatedColumnInfo> &correlated,
21:                                              bool perform_delim, bool any_join)
22:     : binder(binder), delim_offset(DConstants::INVALID_INDEX), correlated_columns(correlated),
23:       perform_delim(perform_delim), any_join(any_join) {
24: 	for (idx_t i = 0; i < correlated_columns.size(); i++) {
25: 		auto &col = correlated_columns[i];
26: 		correlated_map[col.binding] = i;
27: 		delim_types.push_back(col.type);
28: 	}
29: }
30: 
31: bool FlattenDependentJoins::DetectCorrelatedExpressions(LogicalOperator &op, bool lateral, idx_t lateral_depth) {
32: 
33: 	bool is_lateral_join = false;
34: 
35: 	// check if this entry has correlated expressions
36: 	if (op.type == LogicalOperatorType::LOGICAL_DEPENDENT_JOIN) {
37: 		is_lateral_join = true;
38: 	}
39: 	HasCorrelatedExpressions visitor(correlated_columns, lateral, lateral_depth);
40: 	visitor.VisitOperator(op);
41: 	bool has_correlation = visitor.has_correlated_expressions;
42: 	int child_idx = 0;
43: 	// now visit the children of this entry and check if they have correlated expressions
44: 	for (auto &child : op.children) {
45: 		auto new_lateral_depth = lateral_depth;
46: 		if (is_lateral_join && child_idx == 1) {
47: 			new_lateral_depth = lateral_depth + 1;
48: 		}
49: 		// we OR the property with its children such that has_correlation is true if either
50: 		// (1) this node has a correlated expression or
51: 		// (2) one of its children has a correlated expression
52: 		if (DetectCorrelatedExpressions(*child, lateral, new_lateral_depth)) {
53: 			has_correlation = true;
54: 		}
55: 		child_idx++;
56: 	}
57: 	// set the entry in the map
58: 	has_correlated_expressions[op] = has_correlation;
59: 
60: 	// If we detect correlation in a materialized or recursive CTE, the entire right side of the operator
61: 	// needs to be marked as correlated. Otherwise, function PushDownDependentJoinInternal does not do the
62: 	// right thing.
63: 	if (op.type == LogicalOperatorType::LOGICAL_MATERIALIZED_CTE ||
64: 	    op.type == LogicalOperatorType::LOGICAL_RECURSIVE_CTE) {
65: 		if (has_correlation) {
66: 			MarkSubtreeCorrelated(*op.children[1].get());
67: 		}
68: 	}
69: 	return has_correlation;
70: }
71: 
72: bool FlattenDependentJoins::MarkSubtreeCorrelated(LogicalOperator &op) {
73: 	// Do not mark base table scans as correlated
74: 	auto entry = has_correlated_expressions.find(op);
75: 	D_ASSERT(entry != has_correlated_expressions.end());
76: 	bool has_correlation = entry->second;
77: 	for (auto &child : op.children) {
78: 		has_correlation |= MarkSubtreeCorrelated(*child.get());
79: 	}
80: 	if (op.type != LogicalOperatorType::LOGICAL_GET || op.children.size() == 1) {
81: 		if (op.type == LogicalOperatorType::LOGICAL_CTE_REF) {
82: 			has_correlated_expressions[op] = true;
83: 			return true;
84: 		} else {
85: 			has_correlated_expressions[op] = has_correlation;
86: 		}
87: 	}
88: 	return has_correlation;
89: }
90: 
91: unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoin(unique_ptr<LogicalOperator> plan,
92:                                                                          bool propagate_null_values) {
93: 	auto result = PushDownDependentJoinInternal(std::move(plan), propagate_null_values, 0);
94: 	if (!replacement_map.empty()) {
95: 		// check if we have to replace any COUNT aggregates into "CASE WHEN X IS NULL THEN 0 ELSE COUNT END"
96: 		RewriteCountAggregates aggr(replacement_map);
97: 		aggr.VisitOperator(*result);
98: 	}
99: 	return result;
100: }
101: 
102: bool SubqueryDependentFilter(Expression &expr) {
103: 	if (expr.expression_class == ExpressionClass::BOUND_CONJUNCTION &&
104: 	    expr.GetExpressionType() == ExpressionType::CONJUNCTION_AND) {
105: 		auto &bound_conjunction = expr.Cast<BoundConjunctionExpression>();
106: 		for (auto &child : bound_conjunction.children) {
107: 			if (SubqueryDependentFilter(*child)) {
108: 				return true;
109: 			}
110: 		}
111: 	}
112: 	if (expr.expression_class == ExpressionClass::BOUND_SUBQUERY) {
113: 		return true;
114: 	}
115: 	return false;
116: }
117: 
118: unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal(unique_ptr<LogicalOperator> plan,
119:                                                                                  bool &parent_propagate_null_values,
120:                                                                                  idx_t lateral_depth) {
121: 	// first check if the logical operator has correlated expressions
122: 	auto entry = has_correlated_expressions.find(*plan);
123: 	bool exit_projection = false;
124: 	unique_ptr<LogicalDelimGet> delim_scan;
125: 	D_ASSERT(entry != has_correlated_expressions.end());
126: 	if (!entry->second) {
127: 		// we reached a node without correlated expressions
128: 		// we can eliminate the dependent join now and create a simple cross product
129: 		// now create the duplicate eliminated scan for this node
130: 		if (plan->type == LogicalOperatorType::LOGICAL_CTE_REF) {
131: 			auto &op = plan->Cast<LogicalCTERef>();
132: 
133: 			auto rec_cte = binder.recursive_ctes.find(op.cte_index);
134: 			if (rec_cte != binder.recursive_ctes.end()) {
135: 				D_ASSERT(rec_cte->second->type == LogicalOperatorType::LOGICAL_RECURSIVE_CTE);
136: 				auto &rec_cte_op = rec_cte->second->Cast<LogicalRecursiveCTE>();
137: 				RewriteCTEScan cte_rewriter(op.cte_index, rec_cte_op.correlated_columns);
138: 				cte_rewriter.VisitOperator(*plan);
139: 			}
140: 		}
141: 
142: 		// create cross product with Delim Join
143: 		auto delim_index = binder.GenerateTableIndex();
144: 		base_binding = ColumnBinding(delim_index, 0);
145: 
146: 		auto left_columns = plan->GetColumnBindings().size();
147: 		delim_offset = left_columns;
148: 		data_offset = 0;
149: 		delim_scan = make_uniq<LogicalDelimGet>(delim_index, delim_types);
150: 		if (plan->type == LogicalOperatorType::LOGICAL_PROJECTION) {
151: 			// we want to keep the logical projection for positionality.
152: 			exit_projection = true;
153: 		} else {
154: 			auto cross_product = LogicalCrossProduct::Create(std::move(plan), std::move(delim_scan));
155: 			return cross_product;
156: 		}
157: 	}
158: 	switch (plan->type) {
159: 	case LogicalOperatorType::LOGICAL_UNNEST:
160: 	case LogicalOperatorType::LOGICAL_FILTER: {
161: 		// filter
162: 		// first we flatten the dependent join in the child of the filter
163: 		for (auto &expr : plan->expressions) {
164: 			any_join |= SubqueryDependentFilter(*expr);
165: 		}
166: 		plan->children[0] =
167: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
168: 
169: 		// then we replace any correlated expressions with the corresponding entry in the correlated_map
170: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
171: 		rewriter.VisitOperator(*plan);
172: 		return plan;
173: 	}
174: 	case LogicalOperatorType::LOGICAL_PROJECTION: {
175: 		// projection
176: 		// first we flatten the dependent join in the child of the projection
177: 		for (auto &expr : plan->expressions) {
178: 			parent_propagate_null_values &= expr->PropagatesNullValues();
179: 		}
180: 
181: 		// if the node has no correlated expressions,
182: 		// push the cross product with the delim get only below the projection.
183: 		// This will preserve positionality of the columns and prevent errors when reordering of
184: 		// delim gets is enabled.
185: 		if (exit_projection) {
186: 			auto cross_product = LogicalCrossProduct::Create(std::move(plan->children[0]), std::move(delim_scan));
187: 			plan->children[0] = std::move(cross_product);
188: 		} else {
189: 			plan->children[0] = PushDownDependentJoinInternal(std::move(plan->children[0]),
190: 			                                                  parent_propagate_null_values, lateral_depth);
191: 		}
192: 
193: 		// then we replace any correlated expressions with the corresponding entry in the correlated_map
194: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
195: 		rewriter.VisitOperator(*plan);
196: 		// now we add all the columns of the delim_scan to the projection list
197: 		auto &proj = plan->Cast<LogicalProjection>();
198: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
199: 			auto &col = correlated_columns[i];
200: 			auto colref = make_uniq<BoundColumnRefExpression>(
201: 			    col.name, col.type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
202: 			plan->expressions.push_back(std::move(colref));
203: 		}
204: 
205: 		base_binding.table_index = proj.table_index;
206: 		this->delim_offset = base_binding.column_index = plan->expressions.size() - correlated_columns.size();
207: 		this->data_offset = 0;
208: 		return plan;
209: 	}
210: 	case LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY: {
211: 		auto &aggr = plan->Cast<LogicalAggregate>();
212: 		// aggregate and group by
213: 		// first we flatten the dependent join in the child of the projection
214: 		for (auto &expr : plan->expressions) {
215: 			parent_propagate_null_values &= expr->PropagatesNullValues();
216: 		}
217: 		plan->children[0] =
218: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
219: 		// then we replace any correlated expressions with the corresponding entry in the correlated_map
220: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
221: 		rewriter.VisitOperator(*plan);
222: 		// now we add all the columns of the delim_scan to the grouping operators AND the projection list
223: 		idx_t delim_table_index;
224: 		idx_t delim_column_offset;
225: 		idx_t delim_data_offset;
226: 		auto new_group_count = perform_delim ? correlated_columns.size() : 1;
227: 		for (idx_t i = 0; i < new_group_count; i++) {
228: 			auto &col = correlated_columns[i];
229: 			auto colref = make_uniq<BoundColumnRefExpression>(
230: 			    col.name, col.type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
231: 			for (auto &set : aggr.grouping_sets) {
232: 				set.insert(aggr.groups.size());
233: 			}
234: 			aggr.groups.push_back(std::move(colref));
235: 		}
236: 		if (!perform_delim) {
237: 			// if we are not performing the duplicate elimination, we have only added the row_id column to the grouping
238: 			// operators in this case, we push a FIRST aggregate for each of the remaining expressions
239: 			delim_table_index = aggr.aggregate_index;
240: 			delim_column_offset = aggr.expressions.size();
241: 			delim_data_offset = aggr.groups.size();
242: 			for (idx_t i = 0; i < correlated_columns.size(); i++) {
243: 				auto &col = correlated_columns[i];
244: 				auto first_aggregate = FirstFunctionGetter::GetFunction(col.type);
245: 				auto colref = make_uniq<BoundColumnRefExpression>(
246: 				    col.name, col.type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
247: 				vector<unique_ptr<Expression>> aggr_children;
248: 				aggr_children.push_back(std::move(colref));
249: 				auto first_fun =
250: 				    make_uniq<BoundAggregateExpression>(std::move(first_aggregate), std::move(aggr_children), nullptr,
251: 				                                        nullptr, AggregateType::NON_DISTINCT);
252: 				aggr.expressions.push_back(std::move(first_fun));
253: 			}
254: 		} else {
255: 			delim_table_index = aggr.group_index;
256: 			delim_column_offset = aggr.groups.size() - correlated_columns.size();
257: 			delim_data_offset = aggr.groups.size();
258: 		}
259: 		bool ungrouped_join = false;
260: 		if (aggr.grouping_sets.empty()) {
261: 			ungrouped_join = aggr.groups.size() == new_group_count;
262: 		} else {
263: 			for (auto &grouping_set : aggr.grouping_sets) {
264: 				if (grouping_set.size() == new_group_count) {
265: 					ungrouped_join = true;
266: 				}
267: 			}
268: 		}
269: 		if (ungrouped_join) {
270: 			// we have to perform an INNER or LEFT OUTER JOIN between the result of this aggregate and the delim scan
271: 			// this does not always have to be a LEFT OUTER JOIN, depending on whether aggr.expressions return
272: 			// NULL or a value
273: 			JoinType join_type = JoinType::INNER;
274: 			if (any_join || !parent_propagate_null_values) {
275: 				join_type = JoinType::LEFT;
276: 			}
277: 			for (auto &aggr_exp : aggr.expressions) {
278: 				auto &b_aggr_exp = aggr_exp->Cast<BoundAggregateExpression>();
279: 				if (!b_aggr_exp.PropagatesNullValues()) {
280: 					join_type = JoinType::LEFT;
281: 					break;
282: 				}
283: 			}
284: 			unique_ptr<LogicalComparisonJoin> join = make_uniq<LogicalComparisonJoin>(join_type);
285: 			auto left_index = binder.GenerateTableIndex();
286: 			delim_scan = make_uniq<LogicalDelimGet>(left_index, delim_types);
287: 			join->children.push_back(std::move(delim_scan));
288: 			join->children.push_back(std::move(plan));
289: 			for (idx_t i = 0; i < new_group_count; i++) {
290: 				auto &col = correlated_columns[i];
291: 				JoinCondition cond;
292: 				cond.left = make_uniq<BoundColumnRefExpression>(col.name, col.type, ColumnBinding(left_index, i));
293: 				cond.right = make_uniq<BoundColumnRefExpression>(
294: 				    correlated_columns[i].type, ColumnBinding(delim_table_index, delim_column_offset + i));
295: 				cond.comparison = ExpressionType::COMPARE_NOT_DISTINCT_FROM;
296: 				join->conditions.push_back(std::move(cond));
297: 			}
298: 			// for any COUNT aggregate we replace references to the column with: CASE WHEN COUNT(*) IS NULL THEN 0
299: 			// ELSE COUNT(*) END
300: 			for (idx_t i = 0; i < aggr.expressions.size(); i++) {
301: 				D_ASSERT(aggr.expressions[i]->GetExpressionClass() == ExpressionClass::BOUND_AGGREGATE);
302: 				auto &bound = aggr.expressions[i]->Cast<BoundAggregateExpression>();
303: 				vector<LogicalType> arguments;
304: 				if (bound.function == CountFunctionBase::GetFunction() ||
305: 				    bound.function == CountStarFun::GetFunction()) {
306: 					// have to replace this ColumnBinding with the CASE expression
307: 					replacement_map[ColumnBinding(aggr.aggregate_index, i)] = i;
308: 				}
309: 			}
310: 			// now we update the delim_index
311: 			base_binding.table_index = left_index;
312: 			this->delim_offset = base_binding.column_index = 0;
313: 			this->data_offset = 0;
314: 			return std::move(join);
315: 		} else {
316: 			// update the delim_index
317: 			base_binding.table_index = delim_table_index;
318: 			this->delim_offset = base_binding.column_index = delim_column_offset;
319: 			this->data_offset = delim_data_offset;
320: 			return plan;
321: 		}
322: 	}
323: 	case LogicalOperatorType::LOGICAL_CROSS_PRODUCT: {
324: 		// cross product
325: 		// push into both sides of the plan
326: 		bool left_has_correlation = has_correlated_expressions.find(*plan->children[0])->second;
327: 		bool right_has_correlation = has_correlated_expressions.find(*plan->children[1])->second;
328: 		if (!right_has_correlation) {
329: 			// only left has correlation: push into left
330: 			plan->children[0] = PushDownDependentJoinInternal(std::move(plan->children[0]),
331: 			                                                  parent_propagate_null_values, lateral_depth);
332: 			return plan;
333: 		}
334: 		if (!left_has_correlation) {
335: 			// only right has correlation: push into right
336: 			plan->children[1] = PushDownDependentJoinInternal(std::move(plan->children[1]),
337: 			                                                  parent_propagate_null_values, lateral_depth);
338: 			return plan;
339: 		}
340: 		// both sides have correlation
341: 		// turn into an inner join
342: 		auto join = make_uniq<LogicalComparisonJoin>(JoinType::INNER);
343: 		plan->children[0] =
344: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
345: 		auto left_binding = this->base_binding;
346: 		plan->children[1] =
347: 		    PushDownDependentJoinInternal(std::move(plan->children[1]), parent_propagate_null_values, lateral_depth);
348: 		// add the correlated columns to the join conditions
349: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
350: 			JoinCondition cond;
351: 			cond.left = make_uniq<BoundColumnRefExpression>(
352: 			    correlated_columns[i].type, ColumnBinding(left_binding.table_index, left_binding.column_index + i));
353: 			cond.right = make_uniq<BoundColumnRefExpression>(
354: 			    correlated_columns[i].type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
355: 			cond.comparison = ExpressionType::COMPARE_NOT_DISTINCT_FROM;
356: 			join->conditions.push_back(std::move(cond));
357: 		}
358: 		join->children.push_back(std::move(plan->children[0]));
359: 		join->children.push_back(std::move(plan->children[1]));
360: 		return std::move(join);
361: 	}
362: 	case LogicalOperatorType::LOGICAL_DEPENDENT_JOIN: {
363: 		auto &dependent_join = plan->Cast<LogicalJoin>();
364: 		if (!((dependent_join.join_type == JoinType::INNER) || (dependent_join.join_type == JoinType::LEFT))) {
365: 			throw NotImplementedException("Dependent join can only be INNER or LEFT type");
366: 		}
367: 		D_ASSERT(plan->children.size() == 2);
368: 		// Push all the bindings down to the left side so the right side knows where to refer DELIM_GET from
369: 		plan->children[0] =
370: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
371: 
372: 		// Normal rewriter like in other joins
373: 		RewriteCorrelatedExpressions rewriter(this->base_binding, correlated_map, lateral_depth);
374: 		rewriter.VisitOperator(*plan);
375: 
376: 		// Recursive rewriter to visit right side of lateral join and update bindings from left
377: 		RewriteCorrelatedExpressions recursive_rewriter(this->base_binding, correlated_map, lateral_depth + 1, true);
378: 		recursive_rewriter.VisitOperator(*plan->children[1]);
379: 
380: 		return plan;
381: 	}
382: 	case LogicalOperatorType::LOGICAL_ANY_JOIN:
383: 	case LogicalOperatorType::LOGICAL_ASOF_JOIN:
384: 	case LogicalOperatorType::LOGICAL_COMPARISON_JOIN: {
385: 		auto &join = plan->Cast<LogicalJoin>();
386: 		D_ASSERT(plan->children.size() == 2);
387: 		// check the correlated expressions in the children of the join
388: 		bool left_has_correlation = has_correlated_expressions.find(*plan->children[0])->second;
389: 		bool right_has_correlation = has_correlated_expressions.find(*plan->children[1])->second;
390: 
391: 		if (join.join_type == JoinType::INNER) {
392: 			// inner join
393: 			if (!right_has_correlation) {
394: 				// only left has correlation: push into left
395: 				plan->children[0] = PushDownDependentJoinInternal(std::move(plan->children[0]),
396: 				                                                  parent_propagate_null_values, lateral_depth);
397: 				// Remove the correlated columns coming from outside for current join node
398: 				return plan;
399: 			}
400: 			if (!left_has_correlation) {
401: 				// only right has correlation: push into right
402: 				plan->children[1] = PushDownDependentJoinInternal(std::move(plan->children[1]),
403: 				                                                  parent_propagate_null_values, lateral_depth);
404: 				// Remove the correlated columns coming from outside for current join node
405: 				return plan;
406: 			}
407: 		} else if (join.join_type == JoinType::LEFT) {
408: 			// left outer join
409: 			if (!right_has_correlation) {
410: 				// only left has correlation: push into left
411: 				plan->children[0] = PushDownDependentJoinInternal(std::move(plan->children[0]),
412: 				                                                  parent_propagate_null_values, lateral_depth);
413: 				// Remove the correlated columns coming from outside for current join node
414: 				return plan;
415: 			}
416: 		} else if (join.join_type == JoinType::RIGHT) {
417: 			// left outer join
418: 			if (!left_has_correlation) {
419: 				// only right has correlation: push into right
420: 				plan->children[1] = PushDownDependentJoinInternal(std::move(plan->children[1]),
421: 				                                                  parent_propagate_null_values, lateral_depth);
422: 				return plan;
423: 			}
424: 		} else if (join.join_type == JoinType::MARK) {
425: 			if (right_has_correlation) {
426: 				throw NotImplementedException("MARK join with correlation in RHS not supported");
427: 			}
428: 			// push the child into the LHS
429: 			plan->children[0] = PushDownDependentJoinInternal(std::move(plan->children[0]),
430: 			                                                  parent_propagate_null_values, lateral_depth);
431: 			// rewrite expressions in the join conditions
432: 			RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
433: 			rewriter.VisitOperator(*plan);
434: 			return plan;
435: 		} else {
436: 			throw NotImplementedException("Unsupported join type for flattening correlated subquery");
437: 		}
438: 		// both sides have correlation
439: 		// push into both sides
440: 		plan->children[0] =
441: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
442: 		auto left_binding = this->base_binding;
443: 		plan->children[1] =
444: 		    PushDownDependentJoinInternal(std::move(plan->children[1]), parent_propagate_null_values, lateral_depth);
445: 		auto right_binding = this->base_binding;
446: 		// NOTE: for OUTER JOINS it matters what the BASE BINDING is after the join
447: 		// for the LEFT OUTER JOIN, we want the LEFT side to be the base binding after we push
448: 		// because the RIGHT binding might contain NULL values
449: 		if (join.join_type == JoinType::LEFT) {
450: 			this->base_binding = left_binding;
451: 		} else if (join.join_type == JoinType::RIGHT) {
452: 			this->base_binding = right_binding;
453: 		}
454: 		// add the correlated columns to the join conditions
455: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
456: 			auto left = make_uniq<BoundColumnRefExpression>(
457: 			    correlated_columns[i].type, ColumnBinding(left_binding.table_index, left_binding.column_index + i));
458: 			auto right = make_uniq<BoundColumnRefExpression>(
459: 			    correlated_columns[i].type, ColumnBinding(right_binding.table_index, right_binding.column_index + i));
460: 
461: 			if (join.type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN ||
462: 			    join.type == LogicalOperatorType::LOGICAL_ASOF_JOIN) {
463: 				JoinCondition cond;
464: 				cond.left = std::move(left);
465: 				cond.right = std::move(right);
466: 				cond.comparison = ExpressionType::COMPARE_NOT_DISTINCT_FROM;
467: 
468: 				auto &comparison_join = join.Cast<LogicalComparisonJoin>();
469: 				comparison_join.conditions.push_back(std::move(cond));
470: 			} else {
471: 				auto &logical_any_join = join.Cast<LogicalAnyJoin>();
472: 				auto comparison = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_NOT_DISTINCT_FROM,
473: 				                                                       std::move(left), std::move(right));
474: 				auto conjunction = make_uniq<BoundConjunctionExpression>(
475: 				    ExpressionType::CONJUNCTION_AND, std::move(comparison), std::move(logical_any_join.condition));
476: 				logical_any_join.condition = std::move(conjunction);
477: 			}
478: 		}
479: 		// then we replace any correlated expressions with the corresponding entry in the correlated_map
480: 		RewriteCorrelatedExpressions rewriter(right_binding, correlated_map, lateral_depth);
481: 		rewriter.VisitOperator(*plan);
482: 		return plan;
483: 	}
484: 	case LogicalOperatorType::LOGICAL_LIMIT: {
485: 		auto &limit = plan->Cast<LogicalLimit>();
486: 		switch (limit.limit_val.Type()) {
487: 		case LimitNodeType::CONSTANT_PERCENTAGE:
488: 		case LimitNodeType::EXPRESSION_PERCENTAGE:
489: 			// NOTE: limit percent could be supported in a manner similar to the LIMIT above
490: 			// but instead of filtering by an exact number of rows, the limit should be expressed as
491: 			// COUNT computed over the partition multiplied by the percentage
492: 			throw ParserException("Limit percent operator not supported in correlated subquery");
493: 		case LimitNodeType::EXPRESSION_VALUE:
494: 			throw ParserException("Non-constant limit not supported in correlated subquery");
495: 		default:
496: 			break;
497: 		}
498: 		switch (limit.offset_val.Type()) {
499: 		case LimitNodeType::EXPRESSION_VALUE:
500: 			throw ParserException("Non-constant offset not supported in correlated subquery");
501: 		case LimitNodeType::CONSTANT_PERCENTAGE:
502: 		case LimitNodeType::EXPRESSION_PERCENTAGE:
503: 			throw InternalException("Percentage offset in FlattenDependentJoin");
504: 		default:
505: 			break;
506: 		}
507: 		auto rownum_alias = "limit_rownum";
508: 		unique_ptr<LogicalOperator> child;
509: 		unique_ptr<LogicalOrder> order_by;
510: 
511: 		// check if the direct child of this LIMIT node is an ORDER BY node, if so, keep it separate
512: 		// this is done for an optimization to avoid having to compute the total order
513: 		if (plan->children[0]->type == LogicalOperatorType::LOGICAL_ORDER_BY) {
514: 			order_by = unique_ptr_cast<LogicalOperator, LogicalOrder>(std::move(plan->children[0]));
515: 			child = PushDownDependentJoinInternal(std::move(order_by->children[0]), parent_propagate_null_values,
516: 			                                      lateral_depth);
517: 		} else {
518: 			child = PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values,
519: 			                                      lateral_depth);
520: 		}
521: 		auto child_column_count = child->GetColumnBindings().size();
522: 		// we push a row_number() OVER (PARTITION BY [correlated columns])
523: 		auto window_index = binder.GenerateTableIndex();
524: 		auto window = make_uniq<LogicalWindow>(window_index);
525: 		auto row_number =
526: 		    make_uniq<BoundWindowExpression>(ExpressionType::WINDOW_ROW_NUMBER, LogicalType::BIGINT, nullptr, nullptr);
527: 		auto partition_count = perform_delim ? correlated_columns.size() : 1;
528: 		for (idx_t i = 0; i < partition_count; i++) {
529: 			auto &col = correlated_columns[i];
530: 			auto colref = make_uniq<BoundColumnRefExpression>(
531: 			    col.name, col.type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
532: 			row_number->partitions.push_back(std::move(colref));
533: 		}
534: 		if (order_by) {
535: 			// optimization: if there is an ORDER BY node followed by a LIMIT
536: 			// rather than computing the entire order, we push the ORDER BY expressions into the row_num computation
537: 			// this way, the order only needs to be computed per partition
538: 			row_number->orders = std::move(order_by->orders);
539: 		}
540: 		row_number->start = WindowBoundary::UNBOUNDED_PRECEDING;
541: 		row_number->end = WindowBoundary::CURRENT_ROW_ROWS;
542: 		window->expressions.push_back(std::move(row_number));
543: 		window->children.push_back(std::move(child));
544: 
545: 		// add a filter based on the row_number
546: 		// the filter we add is "row_number > offset AND row_number <= offset + limit"
547: 		auto filter = make_uniq<LogicalFilter>();
548: 		unique_ptr<Expression> condition;
549: 		auto row_num_ref =
550: 		    make_uniq<BoundColumnRefExpression>(rownum_alias, LogicalType::BIGINT, ColumnBinding(window_index, 0));
551: 
552: 		if (limit.limit_val.Type() == LimitNodeType::CONSTANT_VALUE) {
553: 			auto upper_bound_limit = NumericLimits<int64_t>::Maximum();
554: 			auto limit_val = int64_t(limit.limit_val.GetConstantValue());
555: 			if (limit.offset_val.Type() == LimitNodeType::CONSTANT_VALUE) {
556: 				// both offset and limit specified - upper bound is offset + limit
557: 				auto offset_val = int64_t(limit.offset_val.GetConstantValue());
558: 				TryAddOperator::Operation(limit_val, offset_val, upper_bound_limit);
559: 			} else {
560: 				// no offset - upper bound is only the limit
561: 				upper_bound_limit = limit_val;
562: 			}
563: 			auto upper_bound = make_uniq<BoundConstantExpression>(Value::BIGINT(upper_bound_limit));
564: 			condition = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_LESSTHANOREQUALTO,
565: 			                                                 row_num_ref->Copy(), std::move(upper_bound));
566: 		}
567: 		// we only need to add "row_number >= offset + 1" if offset is bigger than 0
568: 		if (limit.offset_val.Type() == LimitNodeType::CONSTANT_VALUE) {
569: 			auto offset_val = int64_t(limit.offset_val.GetConstantValue());
570: 			auto lower_bound = make_uniq<BoundConstantExpression>(Value::BIGINT(offset_val));
571: 			auto lower_comp = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_GREATERTHAN,
572: 			                                                       row_num_ref->Copy(), std::move(lower_bound));
573: 			if (condition) {
574: 				auto conj = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND,
575: 				                                                  std::move(lower_comp), std::move(condition));
576: 				condition = std::move(conj);
577: 			} else {
578: 				condition = std::move(lower_comp);
579: 			}
580: 		}
581: 		filter->expressions.push_back(std::move(condition));
582: 		filter->children.push_back(std::move(window));
583: 		// we prune away the row_number after the filter clause using the projection map
584: 		for (idx_t i = 0; i < child_column_count; i++) {
585: 			filter->projection_map.push_back(i);
586: 		}
587: 		return std::move(filter);
588: 	}
589: 	case LogicalOperatorType::LOGICAL_WINDOW: {
590: 		auto &window = plan->Cast<LogicalWindow>();
591: 		// push into children
592: 		plan->children[0] =
593: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
594: 
595: 		// we replace any correlated expressions with the corresponding entry in the correlated_map
596: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
597: 		rewriter.VisitOperator(*plan);
598: 
599: 		// add the correlated columns to the PARTITION BY clauses in the Window
600: 		for (auto &expr : window.expressions) {
601: 			D_ASSERT(expr->GetExpressionClass() == ExpressionClass::BOUND_WINDOW);
602: 			auto &w = expr->Cast<BoundWindowExpression>();
603: 			for (idx_t i = 0; i < correlated_columns.size(); i++) {
604: 				w.partitions.push_back(make_uniq<BoundColumnRefExpression>(
605: 				    correlated_columns[i].type,
606: 				    ColumnBinding(base_binding.table_index, base_binding.column_index + i)));
607: 			}
608: 		}
609: 		return plan;
610: 	}
611: 	case LogicalOperatorType::LOGICAL_EXCEPT:
612: 	case LogicalOperatorType::LOGICAL_INTERSECT:
613: 	case LogicalOperatorType::LOGICAL_UNION: {
614: 		auto &setop = plan->Cast<LogicalSetOperation>();
615: 		// set operator, push into both children
616: #ifdef DEBUG
617: 		plan->children[0]->ResolveOperatorTypes();
618: 		plan->children[1]->ResolveOperatorTypes();
619: 		D_ASSERT(plan->children[0]->types == plan->children[1]->types);
620: #endif
621: 		plan->children[0] = PushDownDependentJoin(std::move(plan->children[0]));
622: 		plan->children[1] = PushDownDependentJoin(std::move(plan->children[1]));
623: #ifdef DEBUG
624: 		D_ASSERT(plan->children[0]->GetColumnBindings().size() == plan->children[1]->GetColumnBindings().size());
625: 		plan->children[0]->ResolveOperatorTypes();
626: 		plan->children[1]->ResolveOperatorTypes();
627: 		D_ASSERT(plan->children[0]->types == plan->children[1]->types);
628: #endif
629: 		// we have to refer to the setop index now
630: 		base_binding.table_index = setop.table_index;
631: 		base_binding.column_index = setop.column_count;
632: 		setop.column_count += correlated_columns.size();
633: 		return plan;
634: 	}
635: 	case LogicalOperatorType::LOGICAL_DISTINCT: {
636: 		auto &distinct = plan->Cast<LogicalDistinct>();
637: 		// push down into child
638: 		distinct.children[0] = PushDownDependentJoin(std::move(distinct.children[0]));
639: 		// add all correlated columns to the distinct targets
640: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
641: 			distinct.distinct_targets.push_back(make_uniq<BoundColumnRefExpression>(
642: 			    correlated_columns[i].type, ColumnBinding(base_binding.table_index, base_binding.column_index + i)));
643: 		}
644: 		return plan;
645: 	}
646: 	case LogicalOperatorType::LOGICAL_EXPRESSION_GET: {
647: 		// expression get
648: 		// first we flatten the dependent join in the child
649: 		plan->children[0] =
650: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
651: 		// then we replace any correlated expressions with the corresponding entry in the correlated_map
652: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
653: 		rewriter.VisitOperator(*plan);
654: 		// now we add all the correlated columns to each of the expressions of the expression scan
655: 		auto &expr_get = plan->Cast<LogicalExpressionGet>();
656: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
657: 			for (auto &expr_list : expr_get.expressions) {
658: 				auto colref = make_uniq<BoundColumnRefExpression>(
659: 				    correlated_columns[i].type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
660: 				expr_list.push_back(std::move(colref));
661: 			}
662: 			expr_get.expr_types.push_back(correlated_columns[i].type);
663: 		}
664: 
665: 		base_binding.table_index = expr_get.table_index;
666: 		this->delim_offset = base_binding.column_index = expr_get.expr_types.size() - correlated_columns.size();
667: 		this->data_offset = 0;
668: 		return plan;
669: 	}
670: 	case LogicalOperatorType::LOGICAL_PIVOT:
671: 		throw BinderException("PIVOT is not supported in correlated subqueries yet");
672: 	case LogicalOperatorType::LOGICAL_ORDER_BY:
673: 		plan->children[0] = PushDownDependentJoin(std::move(plan->children[0]));
674: 		return plan;
675: 	case LogicalOperatorType::LOGICAL_GET: {
676: 		auto &get = plan->Cast<LogicalGet>();
677: 		if (get.children.size() != 1) {
678: 			throw InternalException("Flatten dependent joins - logical get encountered without children");
679: 		}
680: 		plan->children[0] = PushDownDependentJoin(std::move(plan->children[0]));
681: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
682: 			get.projected_input.push_back(this->delim_offset + i);
683: 		}
684: 		this->delim_offset = get.returned_types.size();
685: 		this->data_offset = 0;
686: 
687: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
688: 		rewriter.VisitOperator(*plan);
689: 		return plan;
690: 	}
691: 	case LogicalOperatorType::LOGICAL_MATERIALIZED_CTE:
692: 	case LogicalOperatorType::LOGICAL_RECURSIVE_CTE: {
693: 
694: #ifdef DEBUG
695: 		plan->children[0]->ResolveOperatorTypes();
696: 		plan->children[1]->ResolveOperatorTypes();
697: #endif
698: 		idx_t table_index = 0;
699: 		plan->children[0] =
700: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
701: 		if (plan->type == LogicalOperatorType::LOGICAL_RECURSIVE_CTE) {
702: 			auto &setop = plan->Cast<LogicalRecursiveCTE>();
703: 			base_binding.table_index = setop.table_index;
704: 			base_binding.column_index = setop.column_count;
705: 			table_index = setop.table_index;
706: 			setop.correlated_columns = correlated_columns;
707: 		} else if (plan->type == LogicalOperatorType::LOGICAL_MATERIALIZED_CTE) {
708: 			auto &setop = plan->Cast<LogicalMaterializedCTE>();
709: 			base_binding.table_index = setop.table_index;
710: 			base_binding.column_index = setop.column_count;
711: 			table_index = setop.table_index;
712: 		}
713: 
714: 		RewriteCTEScan cte_rewriter(table_index, correlated_columns);
715: 		cte_rewriter.VisitOperator(*plan->children[1]);
716: 
717: 		parent_propagate_null_values = false;
718: 		plan->children[1] =
719: 		    PushDownDependentJoinInternal(std::move(plan->children[1]), parent_propagate_null_values, lateral_depth);
720: 		RewriteCorrelatedExpressions rewriter(this->base_binding, correlated_map, lateral_depth);
721: 		rewriter.VisitOperator(*plan);
722: 
723: 		RewriteCorrelatedExpressions recursive_rewriter(this->base_binding, correlated_map, lateral_depth, true);
724: 		recursive_rewriter.VisitOperator(*plan->children[0]);
725: 		recursive_rewriter.VisitOperator(*plan->children[1]);
726: 
727: #ifdef DEBUG
728: 		plan->children[0]->ResolveOperatorTypes();
729: 		plan->children[1]->ResolveOperatorTypes();
730: #endif
731: 		if (plan->type == LogicalOperatorType::LOGICAL_RECURSIVE_CTE) {
732: 			// we have to refer to the recursive CTE index now
733: 			auto &setop = plan->Cast<LogicalRecursiveCTE>();
734: 			base_binding.table_index = setop.table_index;
735: 			base_binding.column_index = setop.column_count;
736: 			setop.column_count += correlated_columns.size();
737: 		}
738: 
739: 		return plan;
740: 	}
741: 	case LogicalOperatorType::LOGICAL_CTE_REF: {
742: 		auto &cteref = plan->Cast<LogicalCTERef>();
743: 		// Read correlated columns from CTE_SCAN instead of from DELIM_SCAN
744: 		base_binding.table_index = cteref.table_index;
745: 		base_binding.column_index = cteref.chunk_types.size() - cteref.correlated_columns;
746: 		return plan;
747: 	}
748: 	case LogicalOperatorType::LOGICAL_DELIM_JOIN: {
749: 		throw BinderException("Nested lateral joins or lateral joins in correlated subqueries are not (yet) supported");
750: 	}
751: 	case LogicalOperatorType::LOGICAL_SAMPLE:
752: 		throw BinderException("Sampling in correlated subqueries is not (yet) supported");
753: 	default:
754: 		throw InternalException("Logical operator type \"%s\" for dependent join", LogicalOperatorToString(plan->type));
755: 	}
756: }
757: 
758: } // namespace duckdb
[end of src/planner/subquery/flatten_dependent_join.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: