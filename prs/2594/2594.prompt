You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Incorrect result with date conversion
#### What happens?
Timestamp field casted to date and varchar constant casted to date not equal in where clause.

#### To Reproduce
create table test as
select '2021-02-04 19:30:00'::timestamp t;

This query returns no result:
select *
from test
where (t::date) = '2021-02-04'::date;

But this one returns correct result:
select *
from test
where (t::date) = '2021-02-04';

#### Environment (please complete the following information):
 - Ubuntu 20.04.3 WSL 2
 - DuckDB Version: 0.3.1-dev623 source_id: cece36693
 - DuckDB Client: Python

#### Before Submitting

- [X] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [X] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/optimizer/statistics/operator/propagate_filter.cpp]
1: #include "duckdb/function/scalar/generic_functions.hpp"
2: #include "duckdb/optimizer/statistics_propagator.hpp"
3: #include "duckdb/planner/expression/bound_between_expression.hpp"
4: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
5: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
6: #include "duckdb/planner/expression/bound_constant_expression.hpp"
7: #include "duckdb/planner/operator/logical_filter.hpp"
8: #include "duckdb/storage/statistics/numeric_statistics.hpp"
9: 
10: namespace duckdb {
11: 
12: bool StatisticsPropagator::ExpressionIsConstant(Expression &expr, const Value &val) {
13: 	if (expr.GetExpressionClass() != ExpressionClass::BOUND_CONSTANT) {
14: 		return false;
15: 	}
16: 	auto &bound_constant = (BoundConstantExpression &)expr;
17: 	D_ASSERT(bound_constant.value.type() == val.type());
18: 	return bound_constant.value == val;
19: }
20: 
21: bool StatisticsPropagator::ExpressionIsConstantOrNull(Expression &expr, const Value &val) {
22: 	if (expr.GetExpressionClass() != ExpressionClass::BOUND_FUNCTION) {
23: 		return false;
24: 	}
25: 	auto &bound_function = (BoundFunctionExpression &)expr;
26: 	return ConstantOrNull::IsConstantOrNull(bound_function, val);
27: }
28: 
29: void StatisticsPropagator::SetStatisticsNotNull(ColumnBinding binding) {
30: 	auto entry = statistics_map.find(binding);
31: 	if (entry == statistics_map.end()) {
32: 		return;
33: 	}
34: 	entry->second->validity_stats = make_unique<ValidityStatistics>(false);
35: }
36: 
37: void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &stats, ExpressionType comparison_type,
38:                                                   const Value &constant) {
39: 	// any comparison filter removes all null values
40: 	stats.validity_stats = make_unique<ValidityStatistics>(false);
41: 	if (!stats.type.IsNumeric()) {
42: 		// don't handle non-numeric columns here (yet)
43: 		return;
44: 	}
45: 	auto &numeric_stats = (NumericStatistics &)stats;
46: 	if (numeric_stats.min.is_null || numeric_stats.max.is_null) {
47: 		// no stats available: skip this
48: 		return;
49: 	}
50: 	switch (comparison_type) {
51: 	case ExpressionType::COMPARE_LESSTHAN:
52: 	case ExpressionType::COMPARE_LESSTHANOREQUALTO:
53: 		// X < constant OR X <= constant
54: 		// max becomes the constant
55: 		numeric_stats.max = constant;
56: 		break;
57: 	case ExpressionType::COMPARE_GREATERTHAN:
58: 	case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
59: 		// X > constant OR X >= constant
60: 		// min becomes the constant
61: 		numeric_stats.min = constant;
62: 		break;
63: 	case ExpressionType::COMPARE_EQUAL:
64: 		// X = constant
65: 		// both min and max become the constant
66: 		numeric_stats.min = constant;
67: 		numeric_stats.max = constant;
68: 		break;
69: 	default:
70: 		break;
71: 	}
72: }
73: 
74: void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &lstats, BaseStatistics &rstats,
75:                                                   ExpressionType comparison_type) {
76: 	// any comparison filter removes all null values
77: 	lstats.validity_stats = make_unique<ValidityStatistics>(false);
78: 	rstats.validity_stats = make_unique<ValidityStatistics>(false);
79: 	D_ASSERT(lstats.type == rstats.type);
80: 	if (!lstats.type.IsNumeric()) {
81: 		// don't handle non-numeric columns here (yet)
82: 		return;
83: 	}
84: 	auto &left_stats = (NumericStatistics &)lstats;
85: 	auto &right_stats = (NumericStatistics &)rstats;
86: 	if (left_stats.min.is_null || left_stats.max.is_null || right_stats.min.is_null || right_stats.max.is_null) {
87: 		// no stats available: skip this
88: 		return;
89: 	}
90: 	switch (comparison_type) {
91: 	case ExpressionType::COMPARE_LESSTHAN:
92: 	case ExpressionType::COMPARE_LESSTHANOREQUALTO:
93: 		// LEFT < RIGHT OR LEFT <= RIGHT
94: 		// we know that every value of left is smaller (or equal to) every value in right
95: 		// i.e. if we have left = [-50, 250] and right = [-100, 100]
96: 
97: 		// we know that left.max is AT MOST equal to right.max
98: 		// because any value in left that is BIGGER than right.max will not pass the filter
99: 		if (left_stats.max > right_stats.max) {
100: 			left_stats.max = right_stats.max;
101: 		}
102: 
103: 		// we also know that right.min is AT MOST equal to left.min
104: 		// because any value in right that is SMALLER than left.min will not pass the filter
105: 		if (right_stats.min < left_stats.min) {
106: 			right_stats.min = left_stats.min;
107: 		}
108: 		// so in our example, the bounds get updated as follows:
109: 		// left: [-50, 100], right: [-50, 100]
110: 		break;
111: 	case ExpressionType::COMPARE_GREATERTHAN:
112: 	case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
113: 		// LEFT > RIGHT OR LEFT >= RIGHT
114: 		// we know that every value of left is bigger (or equal to) every value in right
115: 		// this is essentially the inverse of the less than (or equal to) scenario
116: 		if (right_stats.max > left_stats.max) {
117: 			right_stats.max = left_stats.max;
118: 		}
119: 		if (left_stats.min < right_stats.min) {
120: 			left_stats.min = right_stats.min;
121: 		}
122: 		break;
123: 	case ExpressionType::COMPARE_EQUAL:
124: 		// LEFT = RIGHT
125: 		// only the tightest bounds pass
126: 		// so if we have e.g. left = [-50, 250] and right = [-100, 100]
127: 		// the tighest bounds are [-50, 100]
128: 		// select the highest min
129: 		if (left_stats.min > right_stats.min) {
130: 			right_stats.min = left_stats.min;
131: 		} else {
132: 			left_stats.min = right_stats.min;
133: 		}
134: 		// select the lowest max
135: 		if (left_stats.max < right_stats.max) {
136: 			right_stats.max = left_stats.max;
137: 		} else {
138: 			left_stats.max = right_stats.max;
139: 		}
140: 		break;
141: 	default:
142: 		break;
143: 	}
144: }
145: 
146: void StatisticsPropagator::UpdateFilterStatistics(Expression &left, Expression &right, ExpressionType comparison_type) {
147: 	// first check if either side is a bound column ref
148: 	// any column ref involved in a comparison will not be null after the comparison
149: 	if (left.type == ExpressionType::BOUND_COLUMN_REF) {
150: 		SetStatisticsNotNull(((BoundColumnRefExpression &)left).binding);
151: 	}
152: 	if (right.type == ExpressionType::BOUND_COLUMN_REF) {
153: 		SetStatisticsNotNull(((BoundColumnRefExpression &)right).binding);
154: 	}
155: 	// check if this is a comparison between a constant and a column ref
156: 	BoundConstantExpression *constant = nullptr;
157: 	BoundColumnRefExpression *columnref = nullptr;
158: 	if (left.type == ExpressionType::VALUE_CONSTANT && right.type == ExpressionType::BOUND_COLUMN_REF) {
159: 		constant = (BoundConstantExpression *)&left;
160: 		columnref = (BoundColumnRefExpression *)&right;
161: 		comparison_type = FlipComparisionExpression(comparison_type);
162: 	} else if (left.type == ExpressionType::BOUND_COLUMN_REF && right.type == ExpressionType::VALUE_CONSTANT) {
163: 		columnref = (BoundColumnRefExpression *)&left;
164: 		constant = (BoundConstantExpression *)&right;
165: 	} else if (left.type == ExpressionType::BOUND_COLUMN_REF && right.type == ExpressionType::BOUND_COLUMN_REF) {
166: 		// comparison between two column refs
167: 		auto &left_column_ref = (BoundColumnRefExpression &)left;
168: 		auto &right_column_ref = (BoundColumnRefExpression &)right;
169: 		auto lentry = statistics_map.find(left_column_ref.binding);
170: 		auto rentry = statistics_map.find(right_column_ref.binding);
171: 		if (lentry == statistics_map.end() || rentry == statistics_map.end()) {
172: 			return;
173: 		}
174: 		UpdateFilterStatistics(*lentry->second, *rentry->second, comparison_type);
175: 	} else {
176: 		// unsupported filter
177: 		return;
178: 	}
179: 	if (constant && columnref) {
180: 		// comparison between columnref
181: 		auto entry = statistics_map.find(columnref->binding);
182: 		if (entry == statistics_map.end()) {
183: 			return;
184: 		}
185: 		UpdateFilterStatistics(*entry->second, comparison_type, constant->value);
186: 	}
187: }
188: 
189: void StatisticsPropagator::UpdateFilterStatistics(Expression &condition) {
190: 	// in filters, we check for constant comparisons with bound columns
191: 	// if we find a comparison in the form of e.g. "i=3", we can update our statistics for that column
192: 	switch (condition.GetExpressionClass()) {
193: 	case ExpressionClass::BOUND_BETWEEN: {
194: 		auto &between = (BoundBetweenExpression &)condition;
195: 		UpdateFilterStatistics(*between.input, *between.lower, between.LowerComparisonType());
196: 		UpdateFilterStatistics(*between.input, *between.upper, between.UpperComparisonType());
197: 		break;
198: 	}
199: 	case ExpressionClass::BOUND_COMPARISON: {
200: 		auto &comparison = (BoundComparisonExpression &)condition;
201: 		UpdateFilterStatistics(*comparison.left, *comparison.right, comparison.type);
202: 		break;
203: 	}
204: 	default:
205: 		break;
206: 	}
207: }
208: 
209: unique_ptr<NodeStatistics> StatisticsPropagator::PropagateStatistics(LogicalFilter &filter,
210:                                                                      unique_ptr<LogicalOperator> *node_ptr) {
211: 	// first propagate to the child
212: 	node_stats = PropagateStatistics(filter.children[0]);
213: 
214: 	// then propagate to each of the expressions
215: 	for (idx_t i = 0; i < filter.expressions.size(); i++) {
216: 		auto &condition = filter.expressions[i];
217: 		PropagateExpression(condition);
218: 
219: 		if (ExpressionIsConstant(*condition, Value::BOOLEAN(true))) {
220: 			// filter is always true; it is useless to execute it
221: 			// erase this condition
222: 			filter.expressions.erase(filter.expressions.begin() + i);
223: 			i--;
224: 			if (filter.expressions.empty()) {
225: 				// all conditions have been erased: remove the entire filter
226: 				*node_ptr = move(filter.children[0]);
227: 				break;
228: 			}
229: 		} else if (ExpressionIsConstant(*condition, Value::BOOLEAN(false)) ||
230: 		           ExpressionIsConstantOrNull(*condition, Value::BOOLEAN(false))) {
231: 			// filter is always false or null; this entire filter should be replaced by an empty result block
232: 			ReplaceWithEmptyResult(*node_ptr);
233: 			return make_unique<NodeStatistics>(0, 0);
234: 		} else {
235: 			// cannot prune this filter: propagate statistics from the filter
236: 			UpdateFilterStatistics(*condition);
237: 		}
238: 	}
239: 	// the max cardinality of a filter is the cardinality of the input (i.e. no tuples get filtered)
240: 	return move(node_stats);
241: }
242: 
243: } // namespace duckdb
[end of src/optimizer/statistics/operator/propagate_filter.cpp]
[start of src/planner/expression/bound_cast_expression.cpp]
1: #include "duckdb/planner/expression/bound_cast_expression.hpp"
2: #include "duckdb/planner/expression/bound_default_expression.hpp"
3: #include "duckdb/planner/expression/bound_parameter_expression.hpp"
4: 
5: namespace duckdb {
6: 
7: BoundCastExpression::BoundCastExpression(unique_ptr<Expression> child_p, LogicalType target_type_p, bool try_cast_p)
8:     : Expression(ExpressionType::OPERATOR_CAST, ExpressionClass::BOUND_CAST, move(target_type_p)), child(move(child_p)),
9:       try_cast(try_cast_p) {
10: }
11: 
12: unique_ptr<Expression> BoundCastExpression::AddCastToType(unique_ptr<Expression> expr, const LogicalType &target_type) {
13: 	D_ASSERT(expr);
14: 	if (expr->expression_class == ExpressionClass::BOUND_PARAMETER) {
15: 		auto &parameter = (BoundParameterExpression &)*expr;
16: 		parameter.return_type = target_type;
17: 	} else if (expr->expression_class == ExpressionClass::BOUND_DEFAULT) {
18: 		auto &def = (BoundDefaultExpression &)*expr;
19: 		def.return_type = target_type;
20: 	} else if (expr->return_type != target_type) {
21: 		auto &expr_type = expr->return_type;
22: 		if (target_type.id() == LogicalTypeId::LIST && expr_type.id() == LogicalTypeId::LIST) {
23: 			auto &target_list = ListType::GetChildType(target_type);
24: 			auto &expr_list = ListType::GetChildType(expr_type);
25: 			if (target_list.id() == LogicalTypeId::ANY || expr_list == target_list) {
26: 				return expr;
27: 			}
28: 		}
29: 		return make_unique<BoundCastExpression>(move(expr), target_type);
30: 	}
31: 	return expr;
32: }
33: 
34: bool BoundCastExpression::CastIsInvertible(const LogicalType &source_type, const LogicalType &target_type) {
35: 	if (source_type.id() == LogicalTypeId::BOOLEAN || target_type.id() == LogicalTypeId::BOOLEAN) {
36: 		return false;
37: 	}
38: 	if (source_type.id() == LogicalTypeId::FLOAT || target_type.id() == LogicalTypeId::FLOAT) {
39: 		return false;
40: 	}
41: 	if (source_type.id() == LogicalTypeId::DOUBLE || target_type.id() == LogicalTypeId::DOUBLE) {
42: 		return false;
43: 	}
44: 	if (source_type.id() == LogicalTypeId::DECIMAL || target_type.id() == LogicalTypeId::DECIMAL) {
45: 		uint8_t source_width, target_width;
46: 		uint8_t source_scale, target_scale;
47: 		// cast to or from decimal
48: 		// cast is only invertible if the cast is strictly widening
49: 		if (!source_type.GetDecimalProperties(source_width, source_scale)) {
50: 			return false;
51: 		}
52: 		if (!target_type.GetDecimalProperties(target_width, target_scale)) {
53: 			return false;
54: 		}
55: 		if (target_scale < source_scale) {
56: 			return false;
57: 		}
58: 		return true;
59: 	}
60: 	if (source_type.id() == LogicalTypeId::VARCHAR) {
61: 		return target_type.id() == LogicalTypeId::DATE || target_type.id() == LogicalTypeId::TIME ||
62: 		       target_type.id() == LogicalTypeId::TIMESTAMP || target_type.id() == LogicalTypeId::TIMESTAMP_NS ||
63: 		       target_type.id() == LogicalTypeId::TIMESTAMP_MS || target_type.id() == LogicalTypeId::TIMESTAMP_SEC;
64: 	}
65: 	if (target_type.id() == LogicalTypeId::VARCHAR) {
66: 		return source_type.id() == LogicalTypeId::DATE || source_type.id() == LogicalTypeId::TIME ||
67: 		       source_type.id() == LogicalTypeId::TIMESTAMP || source_type.id() == LogicalTypeId::TIMESTAMP_NS ||
68: 		       source_type.id() == LogicalTypeId::TIMESTAMP_MS || source_type.id() == LogicalTypeId::TIMESTAMP_SEC;
69: 	}
70: 	return true;
71: }
72: 
73: string BoundCastExpression::ToString() const {
74: 	return (try_cast ? "TRY_CAST(" : "CAST(") + child->GetName() + " AS " + return_type.ToString() + ")";
75: }
76: 
77: bool BoundCastExpression::Equals(const BaseExpression *other_p) const {
78: 	if (!Expression::Equals(other_p)) {
79: 		return false;
80: 	}
81: 	auto other = (BoundCastExpression *)other_p;
82: 	if (!Expression::Equals(child.get(), other->child.get())) {
83: 		return false;
84: 	}
85: 	if (try_cast != other->try_cast) {
86: 		return false;
87: 	}
88: 	return true;
89: }
90: 
91: unique_ptr<Expression> BoundCastExpression::Copy() {
92: 	auto copy = make_unique<BoundCastExpression>(child->Copy(), return_type, try_cast);
93: 	copy->CopyProperties(*this);
94: 	return move(copy);
95: }
96: 
97: } // namespace duckdb
[end of src/planner/expression/bound_cast_expression.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: