{
  "repo": "duckdb/duckdb",
  "pull_number": 7967,
  "instance_id": "duckdb__duckdb-7967",
  "issue_numbers": [
    "7700"
  ],
  "base_commit": "ec0fe43ebf88146f63286aa5c6da3d97cf858926",
  "patch": "diff --git a/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp b/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\nindex 247dcfe50472..3ed573aad44a 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\n@@ -60,6 +60,9 @@ struct DuckDBPyRelation {\n \n \tpy::str GetAlias();\n \n+\tstatic unique_ptr<DuckDBPyRelation> EmptyResult(const std::shared_ptr<ClientContext> &context,\n+\t                                                const vector<LogicalType> &types, vector<string> names);\n+\n \tunique_ptr<DuckDBPyRelation> SetAlias(const string &expr);\n \n \tunique_ptr<DuckDBPyRelation> ProjectFromExpression(const string &expr);\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex ba12876e6961..fe47bea63fe0 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -953,7 +953,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::RunQuery(const string &query, c\n \t\t\t}\n \t\t}\n \t\tif (values.empty()) {\n-\t\t\treturn nullptr;\n+\t\t\treturn DuckDBPyRelation::EmptyResult(connection->context, res->types, res->names);\n \t\t}\n \t}\n \treturn make_uniq<DuckDBPyRelation>(make_uniq<ValueRelation>(connection->context, values, names));\ndiff --git a/tools/pythonpkg/src/pyrelation.cpp b/tools/pythonpkg/src/pyrelation.cpp\nindex 1b094ba9bb11..514d77f814a7 100644\n--- a/tools/pythonpkg/src/pyrelation.cpp\n+++ b/tools/pythonpkg/src/pyrelation.cpp\n@@ -15,6 +15,8 @@\n #include \"duckdb/main/materialized_query_result.hpp\"\n #include \"duckdb/parser/statement/explain_statement.hpp\"\n #include \"duckdb/catalog/default/default_types.hpp\"\n+#include \"duckdb/main/relation/value_relation.hpp\"\n+#include \"duckdb/main/relation/filter_relation.hpp\"\n \n namespace duckdb {\n \n@@ -100,6 +102,22 @@ unique_ptr<DuckDBPyRelation> DuckDBPyRelation::ProjectFromTypes(const py::object\n \treturn ProjectFromExpression(projection);\n }\n \n+unique_ptr<DuckDBPyRelation> DuckDBPyRelation::EmptyResult(const std::shared_ptr<ClientContext> &context,\n+                                                           const vector<LogicalType> &types, vector<string> names) {\n+\tvector<Value> dummy_values;\n+\tD_ASSERT(types.size() == names.size());\n+\tdummy_values.reserve(types.size());\n+\tD_ASSERT(!types.empty());\n+\tfor (auto &type : types) {\n+\t\tdummy_values.emplace_back(type);\n+\t}\n+\tvector<vector<Value>> single_row(1, dummy_values);\n+\tauto values_relation =\n+\t    make_uniq<DuckDBPyRelation>(make_shared<ValueRelation>(context, single_row, std::move(names)));\n+\t// Add a filter on an impossible condition\n+\treturn values_relation->Filter(\"true = false\");\n+}\n+\n unique_ptr<DuckDBPyRelation> DuckDBPyRelation::SetAlias(const string &expr) {\n \treturn make_uniq<DuckDBPyRelation>(rel->Alias(expr));\n }\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_duckdb_query.py b/tools/pythonpkg/tests/fast/api/test_duckdb_query.py\nindex 63b59ad268be..f420f9e5be93 100644\n--- a/tools/pythonpkg/tests/fast/api/test_duckdb_query.py\n+++ b/tools/pythonpkg/tests/fast/api/test_duckdb_query.py\n@@ -32,6 +32,12 @@ def test_duckdb_from_query_multiple_statements(self, pandas):\n         ''').fetchall()\n         assert res == [(1,), (23,), (3,), (5,), (1,), (23,), (3,), (5,)]\n \n+    def test_duckdb_query_empty_result(self):\n+        con = duckdb.connect()\n+        # show tables on empty connection does not produce any tuples\n+        res = con.query('show tables').fetchall()\n+        assert res == []\n+\n     def test_duckdb_from_query(self, duckdb_cursor):\n         # duckdb.from_query cannot be used to run arbitrary queries\n         with pytest.raises(duckdb.ParserException, match='duckdb.from_query cannot be used to run arbitrary SQL queries'):\n",
  "problem_statement": "[Python] `show tables` returns `None` type on empty result\n### What happens?\n\nIn the R interface of DuckDB, if I issue `show tables` and do not have any tables, the result will be a `data.frame` object with zero rows:\r\n```r\r\nlibrary(DBI)\r\nlibrary(duckdb)\r\nconn = dbConnect(duckdb::duckdb(), dbdir=\":memory:\", read_only=FALSE)\r\ndbGetQuery(conn, \"show tables\")\r\n```\r\n```\r\n[1] name\r\n<0 rows> (or 0-length row.names)\r\n```\r\n\r\nBut in the Python interface, the same query return a python `None` when there aren't any tables, or a duckdb result object when there is at least one. Would be better if the result was still a table with zero rows when there aren't any tables returned by the query.\n\n### To Reproduce\n\n```python\r\nimport duckdb\r\nout = duckdb.query(\"show tables\")\r\nout.__class__\r\n```\r\n```\r\nNoneType\r\n```\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n0.8.1.dev96\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nDavid Cortes\n\n### Affiliation:\n\nNone\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-06-16T13:43:38Z"
}