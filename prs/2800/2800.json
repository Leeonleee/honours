{
  "repo": "duckdb/duckdb",
  "pull_number": 2800,
  "instance_id": "duckdb__duckdb-2800",
  "issue_numbers": [
    "2749",
    "2749"
  ],
  "base_commit": "dd2f405ae3a74f317e10f0a32254ba2d5e2d8c41",
  "patch": "diff --git a/src/planner/binder/expression/bind_between_expression.cpp b/src/planner/binder/expression/bind_between_expression.cpp\nindex 9049b692de1a..3a4206cf84e3 100644\n--- a/src/planner/binder/expression/bind_between_expression.cpp\n+++ b/src/planner/binder/expression/bind_between_expression.cpp\n@@ -40,8 +40,10 @@ BindResult ExpressionBinder::BindExpression(BetweenExpression &expr, idx_t depth\n \t\tlower.expr = PushCollation(context, move(lower.expr), collation, false);\n \t\tupper.expr = PushCollation(context, move(upper.expr), collation, false);\n \t}\n-\tif (!input.expr->HasSideEffects() && !input.expr->HasParameter()) {\n-\t\t// the expression does not have side effects: create two comparisons\n+\tif (!input.expr->HasSideEffects() && !input.expr->HasParameter() && !input.expr->HasSubquery()) {\n+\t\t// the expression does not have side effects and can be copied: create two comparisons\n+\t\t// the reason we do this is that individual comparisons are easier to handle in optimizers\n+\t\t// if both comparisons remain they will be folded together again into a single BETWEEN in the optimizer\n \t\tauto left_compare = make_unique<BoundComparisonExpression>(ExpressionType::COMPARE_GREATERTHANOREQUALTO,\n \t\t                                                           input.expr->Copy(), move(lower.expr));\n \t\tauto right_compare = make_unique<BoundComparisonExpression>(ExpressionType::COMPARE_LESSTHANOREQUALTO,\n",
  "test_patch": "diff --git a/test/sql/subquery/any_all/subquery_in.test b/test/sql/subquery/any_all/subquery_in.test\nnew file mode 100644\nindex 000000000000..167c78a195eb\n--- /dev/null\n+++ b/test/sql/subquery/any_all/subquery_in.test\n@@ -0,0 +1,20 @@\n+# name: test/sql/subquery/any_all/subquery_in.test\n+# description: Test subquery in IN clause\n+# group: [any_all]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t0 (c0 TIME,c1 DOUBLE PRECISION);\n+\n+statement ok\n+CREATE TABLE t1 (c0 INT);\n+\n+statement ok\n+INSERT INTO t1 VALUES (1),(10),(7),(9),(NULL),(1),(7),(7),(0),(8),(0),(9),(NULL),(5),(3),(8),(0);\n+\n+query I\n+SELECT (FALSE) IN (TRUE, (SELECT TIME '13:35:07' FROM t1) BETWEEN t0.c0 AND t0.c0) FROM t0;\n+----\n+\n",
  "problem_statement": "Subquery inside IN value list error\n#### What happens?\r\nI keep posting the issues I find :)\r\nA subquery inside an IN value list gives the error: 'Serialization Error: Cannot copy BoundSubqueryExpression' I guess this is a bug?\r\n\r\n#### To Reproduce\r\n`CREATE TABLE t0 (c0 TIME,c1 DOUBLE PRECISION);`\r\n`CREATE TABLE t1 (c0 INT);`\r\n`INSERT INTO t1 VALUES (1),(10),(7),(9),(NULL),(1),(7),(7),(0),(8),(0),(9),(NULL),(5),(3),(8),(0);`\r\n`SELECT (FALSE) IN (TRUE, (SELECT TIME '13:35:07' FROM t1) BETWEEN t0.c0 AND t0.c0) FROM t0;`\r\n\r\nThe expected output for the SELECT query is an empty result.\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: Compiled from tip of master branch.\r\n - DuckDB Client: DuckDB shell\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nSubquery inside IN value list error\n#### What happens?\r\nI keep posting the issues I find :)\r\nA subquery inside an IN value list gives the error: 'Serialization Error: Cannot copy BoundSubqueryExpression' I guess this is a bug?\r\n\r\n#### To Reproduce\r\n`CREATE TABLE t0 (c0 TIME,c1 DOUBLE PRECISION);`\r\n`CREATE TABLE t1 (c0 INT);`\r\n`INSERT INTO t1 VALUES (1),(10),(7),(9),(NULL),(1),(7),(7),(0),(8),(0),(9),(NULL),(5),(3),(8),(0);`\r\n`SELECT (FALSE) IN (TRUE, (SELECT TIME '13:35:07' FROM t1) BETWEEN t0.c0 AND t0.c0) FROM t0;`\r\n\r\nThe expected output for the SELECT query is an empty result.\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: Compiled from tip of master branch.\r\n - DuckDB Client: DuckDB shell\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "Thanks for the report! This is indeed a bug. I will have a look sometime this week.\nThanks for the report! This is indeed a bug. I will have a look sometime this week.",
  "created_at": "2021-12-15T15:47:24Z"
}