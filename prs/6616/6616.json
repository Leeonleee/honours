{
  "repo": "duckdb/duckdb",
  "pull_number": 6616,
  "instance_id": "duckdb__duckdb-6616",
  "issue_numbers": [
    "2041",
    "6524"
  ],
  "base_commit": "33cb4bf11ed50a0b94d53f8cd4cae015de2e43ab",
  "patch": "diff --git a/src/execution/physical_plan/plan_aggregate.cpp b/src/execution/physical_plan/plan_aggregate.cpp\nindex 3dd7fd7a09ae..7fdc7b098dc0 100644\n--- a/src/execution/physical_plan/plan_aggregate.cpp\n+++ b/src/execution/physical_plan/plan_aggregate.cpp\n@@ -9,6 +9,7 @@\n #include \"duckdb/parser/expression/comparison_expression.hpp\"\n #include \"duckdb/planner/expression/bound_aggregate_expression.hpp\"\n #include \"duckdb/planner/operator/logical_aggregate.hpp\"\n+#include \"duckdb/function/function_binder.hpp\"\n \n namespace duckdb {\n \n@@ -169,13 +170,20 @@ PhysicalPlanGenerator::ExtractAggregateExpressions(unique_ptr<PhysicalOperator>\n \tvector<unique_ptr<Expression>> expressions;\n \tvector<LogicalType> types;\n \n+\t// bind sorted aggregates\n+\tfor (auto &aggr : aggregates) {\n+\t\tauto &bound_aggr = (BoundAggregateExpression &)*aggr;\n+\t\tif (bound_aggr.order_bys) {\n+\t\t\t// sorted aggregate!\n+\t\t\tFunctionBinder::BindSortedAggregate(context, bound_aggr, groups);\n+\t\t}\n+\t}\n \tfor (auto &group : groups) {\n \t\tauto ref = make_unique<BoundReferenceExpression>(group->return_type, expressions.size());\n \t\ttypes.push_back(group->return_type);\n \t\texpressions.push_back(std::move(group));\n \t\tgroup = std::move(ref);\n \t}\n-\n \tfor (auto &aggr : aggregates) {\n \t\tauto &bound_aggr = (BoundAggregateExpression &)*aggr;\n \t\tfor (auto &child : bound_aggr.children) {\ndiff --git a/src/execution/physical_plan/plan_distinct.cpp b/src/execution/physical_plan/plan_distinct.cpp\nindex 03434f11a9d4..e88277ed6c6e 100644\n--- a/src/execution/physical_plan/plan_distinct.cpp\n+++ b/src/execution/physical_plan/plan_distinct.cpp\n@@ -9,8 +9,10 @@\n \n namespace duckdb {\n \n-unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreateDistinctOn(unique_ptr<PhysicalOperator> child,\n-                                                                     vector<unique_ptr<Expression>> distinct_targets) {\n+unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalDistinct &op) {\n+\tD_ASSERT(op.children.size() == 1);\n+\tauto child = CreatePlan(*op.children[0]);\n+\tauto &distinct_targets = op.distinct_targets;\n \tD_ASSERT(child);\n \tD_ASSERT(!distinct_targets.empty());\n \n@@ -55,6 +57,7 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreateDistinctOn(unique_ptr<\n \t\t\tFunctionBinder function_binder(context);\n \t\t\tauto first_aggregate = function_binder.BindAggregateFunction(\n \t\t\t    FirstFun::GetFunction(logical_type), std::move(first_children), nullptr, AggregateType::NON_DISTINCT);\n+\t\t\tfirst_aggregate->order_bys = op.order_by ? op.order_by->Copy() : nullptr;\n \t\t\t// add the projection\n \t\t\tprojections.push_back(make_unique<BoundReferenceExpression>(logical_type, group_count + aggregates.size()));\n \t\t\t// push it to the list of aggregates\n@@ -81,10 +84,4 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreateDistinctOn(unique_ptr<\n \treturn std::move(aggr_projection);\n }\n \n-unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalDistinct &op) {\n-\tD_ASSERT(op.children.size() == 1);\n-\tauto plan = CreatePlan(*op.children[0]);\n-\treturn CreateDistinctOn(std::move(plan), std::move(op.distinct_targets));\n-}\n-\n } // namespace duckdb\ndiff --git a/src/function/aggregate/distributive/bool.cpp b/src/function/aggregate/distributive/bool.cpp\nindex 2e7dbfe16a33..28fe2b932399 100644\n--- a/src/function/aggregate/distributive/bool.cpp\n+++ b/src/function/aggregate/distributive/bool.cpp\n@@ -95,6 +95,7 @@ AggregateFunction BoolOrFun::GetFunction() {\n \tauto fun = AggregateFunction::UnaryAggregate<BoolState, bool, bool, BoolOrFunFunction>(\n \t    LogicalType(LogicalTypeId::BOOLEAN), LogicalType::BOOLEAN);\n \tfun.name = \"bool_or\";\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn fun;\n }\n \n@@ -102,6 +103,7 @@ AggregateFunction BoolAndFun::GetFunction() {\n \tauto fun = AggregateFunction::UnaryAggregate<BoolState, bool, bool, BoolAndFunFunction>(\n \t    LogicalType(LogicalTypeId::BOOLEAN), LogicalType::BOOLEAN);\n \tfun.name = \"bool_and\";\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn fun;\n }\n \ndiff --git a/src/function/aggregate/distributive/count.cpp b/src/function/aggregate/distributive/count.cpp\nindex 783d3287810d..2da9f276bb48 100644\n--- a/src/function/aggregate/distributive/count.cpp\n+++ b/src/function/aggregate/distributive/count.cpp\n@@ -76,6 +76,7 @@ AggregateFunction CountFun::GetFunction() {\n \t    LogicalType(LogicalTypeId::ANY), LogicalType::BIGINT);\n \tfun.name = \"count\";\n \tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn fun;\n }\n \ndiff --git a/src/function/aggregate/distributive/minmax.cpp b/src/function/aggregate/distributive/minmax.cpp\nindex e701fa9a842a..b929d49db5f6 100644\n--- a/src/function/aggregate/distributive/minmax.cpp\n+++ b/src/function/aggregate/distributive/minmax.cpp\n@@ -514,6 +514,7 @@ unique_ptr<FunctionData> BindDecimalMinMax(ClientContext &context, AggregateFunc\n \tfunction.name = std::move(name);\n \tfunction.arguments[0] = decimal_type;\n \tfunction.return_type = decimal_type;\n+\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn nullptr;\n }\n \n@@ -545,6 +546,7 @@ unique_ptr<FunctionData> BindMinMax(ClientContext &context, AggregateFunction &f\n \tauto name = std::move(function.name);\n \tfunction = GetMinMaxOperator<OP, OP_STRING, OP_VECTOR>(input_type);\n \tfunction.name = std::move(name);\n+\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \tif (function.bind) {\n \t\treturn function.bind(context, function, arguments);\n \t} else {\ndiff --git a/src/function/aggregate/distributive/sum.cpp b/src/function/aggregate/distributive/sum.cpp\nindex 5fdab2abd36f..6bf8fa45092a 100644\n--- a/src/function/aggregate/distributive/sum.cpp\n+++ b/src/function/aggregate/distributive/sum.cpp\n@@ -110,6 +110,7 @@ AggregateFunction SumFun::GetSumAggregate(PhysicalType type) {\n \tcase PhysicalType::INT16: {\n \t\tauto function = AggregateFunction::UnaryAggregate<SumState<int64_t>, int16_t, hugeint_t, IntegerSumOperation>(\n \t\t    LogicalType::SMALLINT, LogicalType::HUGEINT);\n+\t\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \t\treturn function;\n \t}\n \n@@ -118,6 +119,7 @@ AggregateFunction SumFun::GetSumAggregate(PhysicalType type) {\n \t\t    AggregateFunction::UnaryAggregate<SumState<hugeint_t>, int32_t, hugeint_t, SumToHugeintOperation>(\n \t\t        LogicalType::INTEGER, LogicalType::HUGEINT);\n \t\tfunction.statistics = SumPropagateStats;\n+\t\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \t\treturn function;\n \t}\n \tcase PhysicalType::INT64: {\n@@ -125,12 +127,14 @@ AggregateFunction SumFun::GetSumAggregate(PhysicalType type) {\n \t\t    AggregateFunction::UnaryAggregate<SumState<hugeint_t>, int64_t, hugeint_t, SumToHugeintOperation>(\n \t\t        LogicalType::BIGINT, LogicalType::HUGEINT);\n \t\tfunction.statistics = SumPropagateStats;\n+\t\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \t\treturn function;\n \t}\n \tcase PhysicalType::INT128: {\n \t\tauto function =\n \t\t    AggregateFunction::UnaryAggregate<SumState<hugeint_t>, hugeint_t, hugeint_t, HugeintSumOperation>(\n \t\t        LogicalType::HUGEINT, LogicalType::HUGEINT);\n+\t\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \t\treturn function;\n \t}\n \tdefault:\n@@ -144,12 +148,14 @@ AggregateFunction SumFun::GetSumAggregateNoOverflow(PhysicalType type) {\n \t\tauto function = AggregateFunction::UnaryAggregate<SumState<int64_t>, int32_t, hugeint_t, IntegerSumOperation>(\n \t\t    LogicalType::INTEGER, LogicalType::HUGEINT);\n \t\tfunction.name = \"sum_no_overflow\";\n+\t\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \t\treturn function;\n \t}\n \tcase PhysicalType::INT64: {\n \t\tauto function = AggregateFunction::UnaryAggregate<SumState<int64_t>, int64_t, hugeint_t, IntegerSumOperation>(\n \t\t    LogicalType::BIGINT, LogicalType::HUGEINT);\n \t\tfunction.name = \"sum_no_overflow\";\n+\t\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \t\treturn function;\n \t}\n \tdefault:\n@@ -164,6 +170,7 @@ unique_ptr<FunctionData> BindDecimalSum(ClientContext &context, AggregateFunctio\n \tfunction.name = \"sum\";\n \tfunction.arguments[0] = decimal_type;\n \tfunction.return_type = LogicalType::DECIMAL(Decimal::MAX_WIDTH_DECIMAL, DecimalType::GetScale(decimal_type));\n+\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn nullptr;\n }\n \n@@ -174,6 +181,7 @@ unique_ptr<FunctionData> BindDecimalSumNoOverflow(ClientContext &context, Aggreg\n \tfunction.name = \"sum_no_overflow\";\n \tfunction.arguments[0] = decimal_type;\n \tfunction.return_type = LogicalType::DECIMAL(Decimal::MAX_WIDTH_DECIMAL, DecimalType::GetScale(decimal_type));\n+\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn nullptr;\n }\n \ndiff --git a/src/function/aggregate/holistic/quantile.cpp b/src/function/aggregate/holistic/quantile.cpp\nindex 476c2f8881f3..71a62e966e28 100644\n--- a/src/function/aggregate/holistic/quantile.cpp\n+++ b/src/function/aggregate/holistic/quantile.cpp\n@@ -795,6 +795,7 @@ AggregateFunction GetTypedDiscreteQuantileListAggregateFunction(const LogicalTyp\n \tusing STATE = QuantileState<SAVE_TYPE>;\n \tusing OP = QuantileListOperation<INPUT_TYPE, true>;\n \tauto fun = QuantileListAggregate<STATE, INPUT_TYPE, list_entry_t, OP>(type, type);\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \tfun.window = AggregateFunction::UnaryWindow<STATE, INPUT_TYPE, list_entry_t, OP>;\n \treturn fun;\n }\n@@ -851,6 +852,7 @@ AggregateFunction GetTypedContinuousQuantileAggregateFunction(const LogicalType\n \tusing STATE = QuantileState<INPUT_TYPE>;\n \tusing OP = QuantileScalarOperation<false>;\n \tauto fun = AggregateFunction::UnaryAggregateDestructor<STATE, INPUT_TYPE, TARGET_TYPE, OP>(input_type, target_type);\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \tfun.window = AggregateFunction::UnaryWindow<STATE, INPUT_TYPE, TARGET_TYPE, OP>;\n \treturn fun;\n }\n@@ -904,6 +906,7 @@ AggregateFunction GetTypedContinuousQuantileListAggregateFunction(const LogicalT\n \tusing STATE = QuantileState<INPUT_TYPE>;\n \tusing OP = QuantileListOperation<CHILD_TYPE, false>;\n \tauto fun = QuantileListAggregate<STATE, INPUT_TYPE, list_entry_t, OP>(input_type, result_type);\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \tfun.window = AggregateFunction::UnaryWindow<STATE, INPUT_TYPE, list_entry_t, OP>;\n \treturn fun;\n }\n@@ -1129,6 +1132,7 @@ AggregateFunction GetTypedMedianAbsoluteDeviationAggregateFunction(const Logical\n \tusing STATE = QuantileState<INPUT_TYPE>;\n \tusing OP = MedianAbsoluteDeviationOperation<MEDIAN_TYPE>;\n \tauto fun = AggregateFunction::UnaryAggregateDestructor<STATE, INPUT_TYPE, TARGET_TYPE, OP>(input_type, target_type);\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \tfun.window = AggregateFunction::UnaryWindow<STATE, INPUT_TYPE, TARGET_TYPE, OP>;\n \treturn fun;\n }\n@@ -1198,6 +1202,7 @@ unique_ptr<FunctionData> BindMedianDecimal(ClientContext &context, AggregateFunc\n \tfunction.name = \"median\";\n \tfunction.serialize = QuantileSerialize;\n \tfunction.deserialize = QuantileDeserialize;\n+\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn bind_data;\n }\n \n@@ -1205,6 +1210,7 @@ unique_ptr<FunctionData> BindMedianAbsoluteDeviationDecimal(ClientContext &conte\n                                                             vector<unique_ptr<Expression>> &arguments) {\n \tfunction = GetMedianAbsoluteDeviationAggregateFunction(arguments[0]->return_type);\n \tfunction.name = \"mad\";\n+\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn nullptr;\n }\n \n@@ -1257,6 +1263,7 @@ unique_ptr<FunctionData> BindDiscreteQuantileDecimal(ClientContext &context, Agg\n \tfunction.name = \"quantile_disc\";\n \tfunction.serialize = QuantileDecimalSerialize;\n \tfunction.deserialize = QuantileDeserialize;\n+\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn bind_data;\n }\n \n@@ -1267,6 +1274,7 @@ unique_ptr<FunctionData> BindDiscreteQuantileDecimalList(ClientContext &context,\n \tfunction.name = \"quantile_disc\";\n \tfunction.serialize = QuantileDecimalSerialize;\n \tfunction.deserialize = QuantileDeserialize;\n+\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn bind_data;\n }\n \n@@ -1277,6 +1285,7 @@ unique_ptr<FunctionData> BindContinuousQuantileDecimal(ClientContext &context, A\n \tfunction.name = \"quantile_cont\";\n \tfunction.serialize = QuantileDecimalSerialize;\n \tfunction.deserialize = QuantileDeserialize;\n+\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn bind_data;\n }\n \n@@ -1287,6 +1296,7 @@ unique_ptr<FunctionData> BindContinuousQuantileDecimalList(ClientContext &contex\n \tfunction.name = \"quantile_cont\";\n \tfunction.serialize = QuantileDecimalSerialize;\n \tfunction.deserialize = QuantileDeserialize;\n+\tfunction.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn bind_data;\n }\n \n@@ -1316,6 +1326,7 @@ AggregateFunction GetDiscreteQuantileAggregate(const LogicalType &type) {\n \tfun.deserialize = QuantileDeserialize;\n \t// temporarily push an argument so we can bind the actual quantile\n \tfun.arguments.emplace_back(LogicalType::DOUBLE);\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn fun;\n }\n \n@@ -1327,6 +1338,7 @@ AggregateFunction GetDiscreteQuantileListAggregate(const LogicalType &type) {\n \t// temporarily push an argument so we can bind the actual quantile\n \tauto list_of_double = LogicalType::LIST(LogicalType::DOUBLE);\n \tfun.arguments.push_back(list_of_double);\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn fun;\n }\n \n@@ -1337,6 +1349,7 @@ AggregateFunction GetContinuousQuantileAggregate(const LogicalType &type) {\n \tfun.deserialize = QuantileDeserialize;\n \t// temporarily push an argument so we can bind the actual quantile\n \tfun.arguments.emplace_back(LogicalType::DOUBLE);\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn fun;\n }\n \n@@ -1348,6 +1361,7 @@ AggregateFunction GetContinuousQuantileListAggregate(const LogicalType &type) {\n \t// temporarily push an argument so we can bind the actual quantile\n \tauto list_of_double = LogicalType::LIST(LogicalType::DOUBLE);\n \tfun.arguments.push_back(list_of_double);\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn fun;\n }\n \n@@ -1357,6 +1371,7 @@ AggregateFunction GetQuantileDecimalAggregate(const vector<LogicalType> &argumen\n \tfun.bind = bind;\n \tfun.serialize = QuantileSerialize;\n \tfun.deserialize = QuantileDeserialize;\n+\tfun.order_dependent = AggregateOrderDependent::NOT_ORDER_DEPENDENT;\n \treturn fun;\n }\n \ndiff --git a/src/function/aggregate/sorted_aggregate_function.cpp b/src/function/aggregate/sorted_aggregate_function.cpp\nindex dfc32ce30204..506aa0586226 100644\n--- a/src/function/aggregate/sorted_aggregate_function.cpp\n+++ b/src/function/aggregate/sorted_aggregate_function.cpp\n@@ -3,6 +3,9 @@\n #include \"duckdb/common/types/column_data_collection.hpp\"\n #include \"duckdb/function/function_binder.hpp\"\n #include \"duckdb/storage/buffer_manager.hpp\"\n+#include \"duckdb/planner/expression/bound_aggregate_expression.hpp\"\n+#include \"duckdb/parser/expression_map.hpp\"\n+#include \"duckdb/function/aggregate/distributive_functions.hpp\"\n \n namespace duckdb {\n \n@@ -363,16 +366,44 @@ struct SortedAggregateFunction {\n \t}\n };\n \n-unique_ptr<FunctionData> FunctionBinder::BindSortedAggregate(AggregateFunction &bound_function,\n-                                                             vector<unique_ptr<Expression>> &children,\n-                                                             unique_ptr<FunctionData> bind_info,\n-                                                             unique_ptr<BoundOrderModifier> order_bys) {\n-\n-\tauto sorted_bind =\n-\t    make_unique<SortedAggregateBindData>(context, bound_function, children, std::move(bind_info), *order_bys);\n+void FunctionBinder::BindSortedAggregate(ClientContext &context, BoundAggregateExpression &expr,\n+                                         const vector<unique_ptr<Expression>> &groups) {\n+\tif (!expr.order_bys || expr.order_bys->orders.empty() || expr.children.empty()) {\n+\t\t// not a sorted aggregate: return\n+\t\treturn;\n+\t}\n+\tif (context.config.enable_optimizer) {\n+\t\t// for each ORDER BY - check if it is actually necessary\n+\t\t// expressions that are in the groups do not need to be ORDERED BY\n+\t\t// `ORDER BY` on a group has no effect, because for each aggregate, the group is unique\n+\t\t// similarly, we only need to ORDER BY each aggregate once\n+\t\texpression_set_t seen_expressions;\n+\t\tfor (auto &target : groups) {\n+\t\t\tseen_expressions.insert(target.get());\n+\t\t}\n+\t\tvector<BoundOrderByNode> new_order_nodes;\n+\t\tfor (auto &order_node : expr.order_bys->orders) {\n+\t\t\tif (seen_expressions.find(order_node.expression.get()) != seen_expressions.end()) {\n+\t\t\t\t// we do not need to order by this node\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tseen_expressions.insert(order_node.expression.get());\n+\t\t\tnew_order_nodes.push_back(std::move(order_node));\n+\t\t}\n+\t\tif (new_order_nodes.empty()) {\n+\t\t\texpr.order_bys.reset();\n+\t\t\treturn;\n+\t\t}\n+\t\texpr.order_bys->orders = std::move(new_order_nodes);\n+\t}\n+\tauto &bound_function = expr.function;\n+\tauto &children = expr.children;\n+\tauto &order_bys = *expr.order_bys;\n+\tauto sorted_bind = make_unique<SortedAggregateBindData>(context, bound_function, expr.children,\n+\t                                                        std::move(expr.bind_info), order_bys);\n \n \t// The arguments are the children plus the sort columns.\n-\tfor (auto &order : order_bys->orders) {\n+\tfor (auto &order : order_bys.orders) {\n \t\tchildren.emplace_back(std::move(order.expression));\n \t}\n \n@@ -392,9 +423,9 @@ unique_ptr<FunctionData> FunctionBinder::BindSortedAggregate(AggregateFunction &\n \t    AggregateFunction::StateDestroy<SortedAggregateState, SortedAggregateFunction>, nullptr,\n \t    SortedAggregateFunction::Window, SortedAggregateFunction::Serialize, SortedAggregateFunction::Deserialize);\n \n-\tbound_function = std::move(ordered_aggregate);\n-\n-\treturn std::move(sorted_bind);\n+\texpr.function = std::move(ordered_aggregate);\n+\texpr.bind_info = std::move(sorted_bind);\n+\texpr.order_bys.reset();\n }\n \n } // namespace duckdb\ndiff --git a/src/function/function_binder.cpp b/src/function/function_binder.cpp\nindex 47bbab7e3a56..d72ae0d921fc 100644\n--- a/src/function/function_binder.cpp\n+++ b/src/function/function_binder.cpp\n@@ -294,8 +294,7 @@ unique_ptr<BoundFunctionExpression> FunctionBinder::BindScalarFunction(ScalarFun\n unique_ptr<BoundAggregateExpression> FunctionBinder::BindAggregateFunction(AggregateFunction bound_function,\n                                                                            vector<unique_ptr<Expression>> children,\n                                                                            unique_ptr<Expression> filter,\n-                                                                           AggregateType aggr_type,\n-                                                                           unique_ptr<BoundOrderModifier> order_bys) {\n+                                                                           AggregateType aggr_type) {\n \tunique_ptr<FunctionData> bind_info;\n \tif (bound_function.bind) {\n \t\tbind_info = bound_function.bind(context, bound_function, children);\n@@ -306,12 +305,6 @@ unique_ptr<BoundAggregateExpression> FunctionBinder::BindAggregateFunction(Aggre\n \t// check if we need to add casts to the children\n \tCastToFunctionArguments(bound_function, children);\n \n-\t// Special case: for ORDER BY aggregates, we wrap the aggregate function in a SortedAggregateFunction\n-\t// The children are the sort clauses and the binding contains the ordering data.\n-\tif (order_bys && !order_bys->orders.empty()) {\n-\t\tbind_info = BindSortedAggregate(bound_function, children, std::move(bind_info), std::move(order_bys));\n-\t}\n-\n \treturn make_unique<BoundAggregateExpression>(std::move(bound_function), std::move(children), std::move(filter),\n \t                                             std::move(bind_info), aggr_type);\n }\ndiff --git a/src/function/scalar/date/current.cpp b/src/function/scalar/date/current.cpp\nindex a370a7a9d1c4..37abe59cefc0 100644\n--- a/src/function/scalar/date/current.cpp\n+++ b/src/function/scalar/date/current.cpp\n@@ -35,14 +35,12 @@ static void CurrentTimestampFunction(DataChunk &input, ExpressionState &state, V\n \n void CurrentTimeFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunction current_time(\"get_current_time\", {}, LogicalType::TIME, CurrentTimeFunction);\n-\t;\n \tcurrent_time.side_effects = FunctionSideEffects::HAS_SIDE_EFFECTS;\n \tset.AddFunction(current_time);\n }\n \n void CurrentDateFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunction current_date({}, LogicalType::DATE, CurrentDateFunction);\n-\t;\n \tcurrent_date.side_effects = FunctionSideEffects::HAS_SIDE_EFFECTS;\n \tset.AddFunction({\"today\", \"current_date\"}, current_date);\n }\ndiff --git a/src/include/duckdb/execution/physical_plan_generator.hpp b/src/include/duckdb/execution/physical_plan_generator.hpp\nindex 123fd95e2774..554699068dea 100644\n--- a/src/include/duckdb/execution/physical_plan_generator.hpp\n+++ b/src/include/duckdb/execution/physical_plan_generator.hpp\n@@ -88,9 +88,6 @@ class PhysicalPlanGenerator {\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalRecursiveCTE &op);\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalCTERef &op);\n \n-\tunique_ptr<PhysicalOperator> CreateDistinctOn(unique_ptr<PhysicalOperator> child,\n-\t                                              vector<unique_ptr<Expression>> distinct_targets);\n-\n \tunique_ptr<PhysicalOperator> ExtractAggregateExpressions(unique_ptr<PhysicalOperator> child,\n \t                                                         vector<unique_ptr<Expression>> &expressions,\n \t                                                         vector<unique_ptr<Expression>> &groups);\ndiff --git a/src/include/duckdb/function/aggregate_function.hpp b/src/include/duckdb/function/aggregate_function.hpp\nindex bca69ec498a6..bd7ee3f6d74f 100644\n--- a/src/include/duckdb/function/aggregate_function.hpp\n+++ b/src/include/duckdb/function/aggregate_function.hpp\n@@ -17,8 +17,9 @@\n \n namespace duckdb {\n \n-//! This allows us to use the & operator to check if the type is contained in the set\n enum class AggregateType : uint8_t { NON_DISTINCT = 1, DISTINCT = 2 };\n+//! Whether or not the input order influences the result of the aggregate\n+enum class AggregateOrderDependent : uint8_t { ORDER_DEPENDENT = 1, NOT_ORDER_DEPENDENT = 2 };\n \n class BoundAggregateExpression;\n \n@@ -92,7 +93,7 @@ class AggregateFunction : public BaseScalarFunction {\n \t                         LogicalType(LogicalTypeId::INVALID), null_handling),\n \t      state_size(state_size), initialize(initialize), update(update), combine(combine), finalize(finalize),\n \t      simple_update(simple_update), window(window), bind(bind), destructor(destructor), statistics(statistics),\n-\t      serialize(serialize), deserialize(deserialize) {\n+\t      serialize(serialize), deserialize(deserialize), order_dependent(AggregateOrderDependent::ORDER_DEPENDENT) {\n \t}\n \n \tDUCKDB_API\n@@ -107,7 +108,7 @@ class AggregateFunction : public BaseScalarFunction {\n \t                         LogicalType(LogicalTypeId::INVALID)),\n \t      state_size(state_size), initialize(initialize), update(update), combine(combine), finalize(finalize),\n \t      simple_update(simple_update), window(window), bind(bind), destructor(destructor), statistics(statistics),\n-\t      serialize(serialize), deserialize(deserialize) {\n+\t      serialize(serialize), deserialize(deserialize), order_dependent(AggregateOrderDependent::ORDER_DEPENDENT) {\n \t}\n \n \tDUCKDB_API AggregateFunction(const vector<LogicalType> &arguments, const LogicalType &return_type,\n@@ -160,6 +161,8 @@ class AggregateFunction : public BaseScalarFunction {\n \n \taggregate_serialize_t serialize;\n \taggregate_deserialize_t deserialize;\n+\t//! Whether or not the aggregate is order dependent\n+\tAggregateOrderDependent order_dependent;\n \n \tDUCKDB_API bool operator==(const AggregateFunction &rhs) const {\n \t\treturn state_size == rhs.state_size && initialize == rhs.initialize && update == rhs.update &&\ndiff --git a/src/include/duckdb/function/function_binder.hpp b/src/include/duckdb/function/function_binder.hpp\nindex d41a7bb118ef..2d02b7eebcd8 100644\n--- a/src/include/duckdb/function/function_binder.hpp\n+++ b/src/include/duckdb/function/function_binder.hpp\n@@ -59,13 +59,10 @@ class FunctionBinder {\n \tDUCKDB_API unique_ptr<BoundAggregateExpression>\n \tBindAggregateFunction(AggregateFunction bound_function, vector<unique_ptr<Expression>> children,\n \t                      unique_ptr<Expression> filter = nullptr,\n-\t                      AggregateType aggr_type = AggregateType::NON_DISTINCT,\n-\t                      unique_ptr<BoundOrderModifier> order_bys = nullptr);\n+\t                      AggregateType aggr_type = AggregateType::NON_DISTINCT);\n \n-\tDUCKDB_API unique_ptr<FunctionData> BindSortedAggregate(AggregateFunction &bound_function,\n-\t                                                        vector<unique_ptr<Expression>> &children,\n-\t                                                        unique_ptr<FunctionData> bind_info,\n-\t                                                        unique_ptr<BoundOrderModifier> order_bys);\n+\tDUCKDB_API static void BindSortedAggregate(ClientContext &context, BoundAggregateExpression &expr,\n+\t                                           const vector<unique_ptr<Expression>> &groups);\n \n private:\n \t//! Cast a set of expressions to the arguments of this function\ndiff --git a/src/include/duckdb/optimizer/rule/list.hpp b/src/include/duckdb/optimizer/rule/list.hpp\nindex f4cf156730d8..e10f27273b51 100644\n--- a/src/include/duckdb/optimizer/rule/list.hpp\n+++ b/src/include/duckdb/optimizer/rule/list.hpp\n@@ -10,3 +10,4 @@\n #include \"duckdb/optimizer/rule/move_constants.hpp\"\n #include \"duckdb/optimizer/rule/enum_comparison.hpp\"\n #include \"duckdb/optimizer/rule/regex_optimizations.hpp\"\n+#include \"duckdb/optimizer/rule/ordered_aggregate_optimizer.hpp\"\ndiff --git a/src/include/duckdb/optimizer/rule/ordered_aggregate_optimizer.hpp b/src/include/duckdb/optimizer/rule/ordered_aggregate_optimizer.hpp\nnew file mode 100644\nindex 000000000000..78045c71d854\n--- /dev/null\n+++ b/src/include/duckdb/optimizer/rule/ordered_aggregate_optimizer.hpp\n@@ -0,0 +1,24 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/optimizer/rule/ordered_aggregate_optimizer.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/optimizer/rule.hpp\"\n+#include \"duckdb/parser/expression_map.hpp\"\n+\n+namespace duckdb {\n+\n+class OrderedAggregateOptimizer : public Rule {\n+public:\n+\texplicit OrderedAggregateOptimizer(ExpressionRewriter &rewriter);\n+\n+\tunique_ptr<Expression> Apply(LogicalOperator &op, vector<Expression *> &bindings, bool &changes_made,\n+\t                             bool is_root) override;\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/parser/expression/function_expression.hpp b/src/include/duckdb/parser/expression/function_expression.hpp\nindex b6d53baee7a2..b8e004b14520 100644\n--- a/src/include/duckdb/parser/expression/function_expression.hpp\n+++ b/src/include/duckdb/parser/expression/function_expression.hpp\n@@ -59,9 +59,9 @@ class FunctionExpression : public ParsedExpression {\n \tvoid Verify() const override;\n \n public:\n-\ttemplate <class T, class BASE>\n+\ttemplate <class T, class BASE, class ORDER_MODIFIER = OrderModifier>\n \tstatic string ToString(const T &entry, const string &schema, const string &function_name, bool is_operator = false,\n-\t                       bool distinct = false, BASE *filter = nullptr, OrderModifier *order_bys = nullptr,\n+\t                       bool distinct = false, BASE *filter = nullptr, ORDER_MODIFIER *order_bys = nullptr,\n \t                       bool export_state = false, bool add_alias = false) {\n \t\tif (is_operator) {\n \t\t\t// built-in operator\ndiff --git a/src/include/duckdb/planner/bound_result_modifier.hpp b/src/include/duckdb/planner/bound_result_modifier.hpp\nindex 37903ee13a37..7e9e8941a153 100644\n--- a/src/include/duckdb/planner/bound_result_modifier.hpp\n+++ b/src/include/duckdb/planner/bound_result_modifier.hpp\n@@ -65,6 +65,9 @@ class BoundOrderModifier : public BoundResultModifier {\n \n \t//! List of order nodes\n \tvector<BoundOrderByNode> orders;\n+\n+\tunique_ptr<BoundOrderModifier> Copy() const;\n+\tstatic bool Equals(const BoundOrderModifier *left, const BoundOrderModifier *right);\n };\n \n class BoundDistinctModifier : public BoundResultModifier {\ndiff --git a/src/include/duckdb/planner/expression/bound_aggregate_expression.hpp b/src/include/duckdb/planner/expression/bound_aggregate_expression.hpp\nindex 5632119e9256..d9b31a02991c 100644\n--- a/src/include/duckdb/planner/expression/bound_aggregate_expression.hpp\n+++ b/src/include/duckdb/planner/expression/bound_aggregate_expression.hpp\n@@ -25,10 +25,13 @@ class BoundAggregateExpression : public Expression {\n \tvector<unique_ptr<Expression>> children;\n \t//! The bound function data (if any)\n \tunique_ptr<FunctionData> bind_info;\n+\t//! The aggregate type (distinct or non-distinct)\n \tAggregateType aggr_type;\n \n \t//! Filter for this aggregate\n \tunique_ptr<Expression> filter;\n+\t//! The order by expression for this aggregate - if any\n+\tunique_ptr<BoundOrderModifier> order_bys;\n \n public:\n \tbool IsDistinct() const {\ndiff --git a/src/include/duckdb/planner/operator/logical_distinct.hpp b/src/include/duckdb/planner/operator/logical_distinct.hpp\nindex 6d2b18262abe..d374d6564b1e 100644\n--- a/src/include/duckdb/planner/operator/logical_distinct.hpp\n+++ b/src/include/duckdb/planner/operator/logical_distinct.hpp\n@@ -9,6 +9,7 @@\n #pragma once\n \n #include \"duckdb/planner/logical_operator.hpp\"\n+#include \"duckdb/planner/bound_result_modifier.hpp\"\n \n namespace duckdb {\n \n@@ -22,6 +23,8 @@ class LogicalDistinct : public LogicalOperator {\n \t}\n \t//! The set of distinct targets (optional).\n \tvector<unique_ptr<Expression>> distinct_targets;\n+\t//! The order by modifier (optional, only for distinct on)\n+\tunique_ptr<BoundOrderModifier> order_by;\n \n public:\n \tstring ParamsToString() const override;\ndiff --git a/src/optimizer/optimizer.cpp b/src/optimizer/optimizer.cpp\nindex 84ed235b2f39..66b7b5e7c484 100644\n--- a/src/optimizer/optimizer.cpp\n+++ b/src/optimizer/optimizer.cpp\n@@ -39,6 +39,7 @@ Optimizer::Optimizer(Binder &binder, ClientContext &context) : context(context),\n \trewriter.rules.push_back(make_unique<EqualOrNullSimplification>(rewriter));\n \trewriter.rules.push_back(make_unique<MoveConstantsRule>(rewriter));\n \trewriter.rules.push_back(make_unique<LikeOptimizationRule>(rewriter));\n+\trewriter.rules.push_back(make_unique<OrderedAggregateOptimizer>(rewriter));\n \trewriter.rules.push_back(make_unique<RegexOptimizationRule>(rewriter));\n \trewriter.rules.push_back(make_unique<EmptyNeedleRemovalRule>(rewriter));\n \trewriter.rules.push_back(make_unique<EnumComparisonRule>(rewriter));\ndiff --git a/src/optimizer/rule/CMakeLists.txt b/src/optimizer/rule/CMakeLists.txt\nindex 5c37c6301bc7..f6e957fcad07 100644\n--- a/src/optimizer/rule/CMakeLists.txt\n+++ b/src/optimizer/rule/CMakeLists.txt\n@@ -14,6 +14,7 @@ add_library_unity(\n   move_constants.cpp\n   like_optimizations.cpp\n   in_clause_simplification_rule.cpp\n+  ordered_aggregate_optimizer.cpp\n   regex_optimizations.cpp)\n set(ALL_OBJECT_FILES\n     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_optimizer_rules>\ndiff --git a/src/optimizer/rule/ordered_aggregate_optimizer.cpp b/src/optimizer/rule/ordered_aggregate_optimizer.cpp\nnew file mode 100644\nindex 000000000000..69f8e9cdf153\n--- /dev/null\n+++ b/src/optimizer/rule/ordered_aggregate_optimizer.cpp\n@@ -0,0 +1,30 @@\n+#include \"duckdb/optimizer/rule/ordered_aggregate_optimizer.hpp\"\n+\n+#include \"duckdb/optimizer/matcher/expression_matcher.hpp\"\n+#include \"duckdb/planner/expression/bound_aggregate_expression.hpp\"\n+\n+namespace duckdb {\n+\n+OrderedAggregateOptimizer::OrderedAggregateOptimizer(ExpressionRewriter &rewriter) : Rule(rewriter) {\n+\t// we match on an OR expression within a LogicalFilter node\n+\troot = make_unique<ExpressionMatcher>();\n+\troot->expr_class = ExpressionClass::BOUND_AGGREGATE;\n+}\n+\n+unique_ptr<Expression> OrderedAggregateOptimizer::Apply(LogicalOperator &op, vector<Expression *> &bindings,\n+                                                        bool &changes_made, bool is_root) {\n+\tauto aggr = (BoundAggregateExpression *)bindings[0];\n+\tif (!aggr->order_bys) {\n+\t\t// no ORDER BYs defined\n+\t\treturn nullptr;\n+\t}\n+\tif (aggr->function.order_dependent == AggregateOrderDependent::NOT_ORDER_DEPENDENT) {\n+\t\t// not an order dependent aggregate but we have an ORDER BY clause - remove it\n+\t\taggr->order_bys.reset();\n+\t\tchanges_made = true;\n+\t\treturn nullptr;\n+\t}\n+\treturn nullptr;\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/planner/binder/expression/bind_aggregate_expression.cpp b/src/planner/binder/expression/bind_aggregate_expression.cpp\nindex f95798cda0fb..e99b1e94fa3b 100644\n--- a/src/planner/binder/expression/bind_aggregate_expression.cpp\n+++ b/src/planner/binder/expression/bind_aggregate_expression.cpp\n@@ -208,8 +208,9 @@ BindResult SelectBinder::BindAggregate(FunctionExpression &aggr, AggregateFuncti\n \tauto bound_function = func->functions.GetFunctionByOffset(best_function);\n \n \t// Bind any sort columns, unless the aggregate is order-insensitive\n-\tauto order_bys = make_unique<BoundOrderModifier>();\n+\tunique_ptr<BoundOrderModifier> order_bys;\n \tif (!aggr.order_bys->orders.empty()) {\n+\t\torder_bys = make_unique<BoundOrderModifier>();\n \t\tauto &config = DBConfig::GetConfig(context);\n \t\tfor (auto &order : aggr.order_bys->orders) {\n \t\t\tauto &order_expr = (BoundExpression &)*order.expression;\n@@ -222,12 +223,13 @@ BindResult SelectBinder::BindAggregate(FunctionExpression &aggr, AggregateFuncti\n \t\t}\n \t}\n \n-\tauto aggregate = function_binder.BindAggregateFunction(\n-\t    bound_function, std::move(children), std::move(bound_filter),\n-\t    aggr.distinct ? AggregateType::DISTINCT : AggregateType::NON_DISTINCT, std::move(order_bys));\n+\tauto aggregate =\n+\t    function_binder.BindAggregateFunction(bound_function, std::move(children), std::move(bound_filter),\n+\t                                          aggr.distinct ? AggregateType::DISTINCT : AggregateType::NON_DISTINCT);\n \tif (aggr.export_state) {\n \t\taggregate = ExportAggregateFunction::Bind(std::move(aggregate));\n \t}\n+\taggregate->order_bys = std::move(order_bys);\n \n \t// check for all the aggregates if this aggregate already exists\n \tidx_t aggr_index;\ndiff --git a/src/planner/binder/query_node/plan_query_node.cpp b/src/planner/binder/query_node/plan_query_node.cpp\nindex c81e931a2a32..de5cbf581597 100644\n--- a/src/planner/binder/query_node/plan_query_node.cpp\n+++ b/src/planner/binder/query_node/plan_query_node.cpp\n@@ -4,6 +4,7 @@\n #include \"duckdb/planner/operator/logical_limit.hpp\"\n #include \"duckdb/planner/operator/logical_limit_percent.hpp\"\n #include \"duckdb/planner/operator/logical_order.hpp\"\n+#include \"duckdb/planner/bound_result_modifier.hpp\"\n \n namespace duckdb {\n \n@@ -20,6 +21,16 @@ unique_ptr<LogicalOperator> Binder::VisitQueryNode(BoundQueryNode &node, unique_\n \t\t}\n \t\tcase ResultModifierType::ORDER_MODIFIER: {\n \t\t\tauto &bound = (BoundOrderModifier &)*mod;\n+\t\t\tif (root->type == LogicalOperatorType::LOGICAL_DISTINCT) {\n+\t\t\t\tauto &distinct = (LogicalDistinct &)*root;\n+\t\t\t\tif (!distinct.distinct_targets.empty()) {\n+\t\t\t\t\tauto order_by = make_unique<BoundOrderModifier>();\n+\t\t\t\t\tfor (auto &order_node : bound.orders) {\n+\t\t\t\t\t\torder_by->orders.push_back(order_node.Copy());\n+\t\t\t\t\t}\n+\t\t\t\t\tdistinct.order_by = std::move(order_by);\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tauto order = make_unique<LogicalOrder>(std::move(bound.orders));\n \t\t\torder->AddChild(std::move(root));\n \t\t\troot = std::move(order);\ndiff --git a/src/planner/bound_result_modifier.cpp b/src/planner/bound_result_modifier.cpp\nindex 9e59cef417a0..8e99b45888cb 100644\n--- a/src/planner/bound_result_modifier.cpp\n+++ b/src/planner/bound_result_modifier.cpp\n@@ -80,6 +80,32 @@ BoundOrderByNode BoundOrderByNode::Deserialize(Deserializer &source, PlanDeseria\n \treturn BoundOrderByNode(type, null_order, std::move(expression));\n }\n \n+unique_ptr<BoundOrderModifier> BoundOrderModifier::Copy() const {\n+\tauto result = make_unique<BoundOrderModifier>();\n+\tfor (auto &order : orders) {\n+\t\tresult->orders.push_back(order.Copy());\n+\t}\n+\treturn result;\n+}\n+\n+bool BoundOrderModifier::Equals(const BoundOrderModifier *left, const BoundOrderModifier *right) {\n+\tif (left == right) {\n+\t\treturn true;\n+\t}\n+\tif (!left || !right) {\n+\t\treturn false;\n+\t}\n+\tif (left->orders.size() != right->orders.size()) {\n+\t\treturn false;\n+\t}\n+\tfor (idx_t i = 0; i < left->orders.size(); i++) {\n+\t\tif (!left->orders[i].Equals(right->orders[i])) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\treturn true;\n+}\n+\n BoundLimitModifier::BoundLimitModifier() : BoundResultModifier(ResultModifierType::LIMIT_MODIFIER) {\n }\n \ndiff --git a/src/planner/expression/bound_aggregate_expression.cpp b/src/planner/expression/bound_aggregate_expression.cpp\nindex 16bdfd8b8e0a..6d998510055b 100644\n--- a/src/planner/expression/bound_aggregate_expression.cpp\n+++ b/src/planner/expression/bound_aggregate_expression.cpp\n@@ -19,8 +19,8 @@ BoundAggregateExpression::BoundAggregateExpression(AggregateFunction function, v\n }\n \n string BoundAggregateExpression::ToString() const {\n-\treturn FunctionExpression::ToString<BoundAggregateExpression, Expression>(*this, string(), function.name, false,\n-\t                                                                          IsDistinct(), filter.get());\n+\treturn FunctionExpression::ToString<BoundAggregateExpression, Expression, BoundOrderModifier>(\n+\t    *this, string(), function.name, false, IsDistinct(), filter.get(), order_bys.get());\n }\n \n hash_t BoundAggregateExpression::Hash() const {\n@@ -55,6 +55,9 @@ bool BoundAggregateExpression::Equals(const BaseExpression *other_p) const {\n \tif (!FunctionData::Equals(bind_info.get(), other->bind_info.get())) {\n \t\treturn false;\n \t}\n+\tif (!BoundOrderModifier::Equals(order_bys.get(), other->order_bys.get())) {\n+\t\treturn false;\n+\t}\n \treturn true;\n }\n \n@@ -74,12 +77,16 @@ unique_ptr<Expression> BoundAggregateExpression::Copy() {\n \tauto copy = make_unique<BoundAggregateExpression>(function, std::move(new_children), std::move(new_filter),\n \t                                                  std::move(new_bind_info), aggr_type);\n \tcopy->CopyProperties(*this);\n+\tcopy->order_bys = order_bys ? order_bys->Copy() : nullptr;\n \treturn std::move(copy);\n }\n \n void BoundAggregateExpression::Serialize(FieldWriter &writer) const {\n \twriter.WriteField(IsDistinct());\n \twriter.WriteOptional(filter);\n+\tif (order_bys) {\n+\t\tthrow NotImplementedException(\"Serialization of ORDER BY aggregate not yet supported\");\n+\t}\n \tFunctionSerializer::Serialize<AggregateFunction>(writer, function, return_type, children, bind_info.get());\n }\n \ndiff --git a/src/planner/expression_iterator.cpp b/src/planner/expression_iterator.cpp\nindex c125d8e31cb7..2ba8d9394112 100644\n--- a/src/planner/expression_iterator.cpp\n+++ b/src/planner/expression_iterator.cpp\n@@ -29,6 +29,11 @@ void ExpressionIterator::EnumerateChildren(Expression &expr,\n \t\tif (aggr_expr.filter) {\n \t\t\tcallback(aggr_expr.filter);\n \t\t}\n+\t\tif (aggr_expr.order_bys) {\n+\t\t\tfor (auto &order : aggr_expr.order_bys->orders) {\n+\t\t\t\tcallback(order.expression);\n+\t\t\t}\n+\t\t}\n \t\tbreak;\n \t}\n \tcase ExpressionClass::BOUND_BETWEEN: {\ndiff --git a/src/planner/logical_operator_visitor.cpp b/src/planner/logical_operator_visitor.cpp\nindex a24a5faecbce..2082b442eb74 100644\n--- a/src/planner/logical_operator_visitor.cpp\n+++ b/src/planner/logical_operator_visitor.cpp\n@@ -48,6 +48,11 @@ void LogicalOperatorVisitor::EnumerateExpressions(LogicalOperator &op,\n \t\tfor (auto &target : distinct.distinct_targets) {\n \t\t\tcallback(&target);\n \t\t}\n+\t\tif (distinct.order_by) {\n+\t\t\tfor (auto &order : distinct.order_by->orders) {\n+\t\t\t\tcallback(&order.expression);\n+\t\t\t}\n+\t\t}\n \t\tbreak;\n \t}\n \tcase LogicalOperatorType::LOGICAL_INSERT: {\ndiff --git a/src/planner/operator/logical_distinct.cpp b/src/planner/operator/logical_distinct.cpp\nindex 3d38d400f894..98e7a25f4de5 100644\n--- a/src/planner/operator/logical_distinct.cpp\n+++ b/src/planner/operator/logical_distinct.cpp\n@@ -15,6 +15,9 @@ string LogicalDistinct::ParamsToString() const {\n }\n void LogicalDistinct::Serialize(FieldWriter &writer) const {\n \twriter.WriteSerializableList(distinct_targets);\n+\tif (order_by) {\n+\t\tthrow NotImplementedException(\"Serializing ORDER BY not yet supported\");\n+\t}\n }\n \n unique_ptr<LogicalOperator> LogicalDistinct::Deserialize(LogicalDeserializationState &state, FieldReader &reader) {\n",
  "test_patch": "diff --git a/test/optimizer/ordered_aggregate.test b/test/optimizer/ordered_aggregate.test\nnew file mode 100644\nindex 000000000000..be5a38da4bb7\n--- /dev/null\n+++ b/test/optimizer/ordered_aggregate.test\n@@ -0,0 +1,84 @@\n+# name: test/optimizer/ordered_aggregate.test\n+# description: Test ORDER BY in AGGREGATE clause optimizations\n+# group: [optimizer]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE integers(grp INTEGER, i INTEGER);\n+\n+statement ok\n+INSERT INTO integers VALUES (1, 10), (2, 15), (1, 30), (2, 20)\n+\n+# duplicate expressions are removed\n+query I nosort order_by_agg\n+EXPLAIN SELECT FIRST(i ORDER BY i) FROM integers\n+----\n+\n+query I nosort order_by_agg\n+EXPLAIN SELECT FIRST(i ORDER BY i, i, i) FROM integers\n+----\n+\n+query I nosort order_by_agg\n+EXPLAIN SELECT FIRST(i ORDER BY i, i DESC, i DESC NULLS FIRST) FROM integers\n+----\n+\n+# groups are removed\n+query I nosort order_by_agg_grp\n+EXPLAIN SELECT grp, FIRST(i ORDER BY i) FROM integers GROUP BY grp ORDER BY grp\n+----\n+\n+query I nosort order_by_agg_grp\n+EXPLAIN SELECT grp, FIRST(i ORDER BY grp, i) FROM integers GROUP BY grp ORDER BY grp\n+----\n+\n+query I nosort order_by_agg_grp\n+EXPLAIN SELECT grp, FIRST(i ORDER BY grp, i, grp DESC, i DESC) FROM integers GROUP BY grp ORDER BY grp\n+----\n+\n+# now with no remaining aggregates\n+query I nosort order_by_none\n+EXPLAIN SELECT grp, FIRST(i) FROM integers GROUP BY grp ORDER BY grp\n+----\n+\n+query I nosort order_by_none\n+EXPLAIN SELECT grp, FIRST(i ORDER BY grp) FROM integers GROUP BY grp ORDER BY grp\n+----\n+\n+query I nosort order_by_none\n+EXPLAIN SELECT grp, FIRST(i ORDER BY grp, grp DESC, grp DESC NULLS FIRST) FROM integers GROUP BY grp ORDER BY grp\n+----\n+\n+# ORDER BY is removed from aggregates for which it has no effect\n+query I nosort order_by_min\n+EXPLAIN SELECT MIN(i) FROM integers\n+----\n+\n+query I nosort order_by_min\n+EXPLAIN SELECT MIN(i ORDER BY i) FROM integers\n+----\n+\n+query I nosort order_by_max\n+EXPLAIN SELECT MAX(i) FROM integers\n+----\n+\n+query I nosort order_by_max\n+EXPLAIN SELECT MAX(i ORDER BY i) FROM integers\n+----\n+\n+query I nosort order_by_median\n+EXPLAIN SELECT MEDIAN(i) FROM integers\n+----\n+\n+query I nosort order_by_median\n+EXPLAIN SELECT MEDIAN(i ORDER BY i) FROM integers\n+----\n+\n+query I nosort order_by_sum\n+EXPLAIN SELECT SUM(i) FROM integers\n+----\n+\n+query I nosort order_by_sum\n+EXPLAIN SELECT SUM(i ORDER BY i) FROM integers\n+----\ndiff --git a/test/sql/aggregate/aggregates/test_first_last_any_ordered.test b/test/sql/aggregate/aggregates/test_first_last_any_ordered.test\nnew file mode 100644\nindex 000000000000..92833a3d57dc\n--- /dev/null\n+++ b/test/sql/aggregate/aggregates/test_first_last_any_ordered.test\n@@ -0,0 +1,77 @@\n+# name: test/sql/aggregate/aggregates/test_first_last_any_ordered.test\n+# description: Test first/last/any_value and ordered aggregates\n+# group: [aggregates]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE integers(i INTEGER, grp INTEGER);\n+\n+statement ok\n+INSERT INTO integers VALUES (1, NULL), (2, 3), (3, 2), (NULL, 1);\n+\n+query I\n+SELECT FIRST(i ORDER BY grp NULLS LAST) FROM integers\n+----\n+NULL\n+\n+query I\n+SELECT FIRST(i ORDER BY grp NULLS FIRST) FROM integers\n+----\n+1\n+\n+query I\n+SELECT ANY_VALUE(i ORDER BY grp NULLS FIRST) FROM integers\n+----\n+1\n+\n+query I\n+SELECT ANY_VALUE(i ORDER BY grp NULLS LAST) FROM integers\n+----\n+3\n+\n+query I\n+SELECT ARG_MIN(i, grp) FROM integers\n+----\n+3\n+\n+query I\n+SELECT FIRST(i ORDER BY grp DESC NULLS LAST) FROM integers\n+----\n+2\n+\n+query I\n+SELECT ANY_VALUE(i ORDER BY grp DESC NULLS FIRST) FROM integers\n+----\n+1\n+\n+query I\n+SELECT ANY_VALUE(i ORDER BY grp DESC NULLS LAST) FROM integers\n+----\n+2\n+\n+query I\n+SELECT ARG_MAX(i, grp) FROM integers\n+----\n+2\n+\n+query I\n+SELECT LAST(i ORDER BY grp NULLS FIRST) FROM integers\n+----\n+2\n+\n+query I\n+SELECT ARG_MAX(i, grp) FROM integers\n+----\n+2\n+\n+query I\n+SELECT LAST(i ORDER BY grp DESC NULLS FIRST) FROM integers\n+----\n+NULL\n+\n+query I\n+SELECT ARG_MIN(i, grp) FROM integers\n+----\n+3\ndiff --git a/test/sql/aggregate/aggregates/test_order_by_aggregate.test b/test/sql/aggregate/aggregates/test_order_by_aggregate.test\nnew file mode 100644\nindex 000000000000..9518645dcc8c\n--- /dev/null\n+++ b/test/sql/aggregate/aggregates/test_order_by_aggregate.test\n@@ -0,0 +1,63 @@\n+# name: test/sql/aggregate/aggregates/test_order_by_aggregate.test\n+# description: Test ORDER BY in AGGREGATE clause\n+# group: [aggregates]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE integers(grp INTEGER, i INTEGER);\n+\n+statement ok\n+INSERT INTO integers VALUES (1, 10), (2, 15), (1, 30), (2, 20)\n+\n+query I\n+SELECT FIRST(i ORDER BY i) FROM integers\n+----\n+10\n+\n+# ordering by the same aggregate multiple times has no effect\n+query I\n+SELECT FIRST(i ORDER BY i, i, i) FROM integers\n+----\n+10\n+\n+query I\n+SELECT FIRST(i ORDER BY i, i DESC, i) FROM integers\n+----\n+10\n+\n+query I\n+SELECT FIRST(i ORDER BY i DESC) FROM integers\n+----\n+30\n+\n+query I\n+SELECT FIRST(i ORDER BY i DESC, i ASC) FROM integers\n+----\n+30\n+\n+query II\n+SELECT FIRST(i ORDER BY i), FIRST(i ORDER BY i DESC) FROM integers\n+----\n+10\t30\n+\n+query II\n+SELECT grp, FIRST(i ORDER BY i) FROM integers GROUP BY grp ORDER BY ALL\n+----\n+1\t10\n+2\t15\n+\n+# ordering by the group has no effect\n+query II\n+SELECT grp, FIRST(i ORDER BY grp, i, grp DESC, i DESC) FROM integers GROUP BY grp ORDER BY ALL\n+----\n+1\t10\n+2\t15\n+\n+query II\n+SELECT grp, FIRST(i ORDER BY i DESC) FROM integers GROUP BY grp ORDER BY ALL\n+----\n+1\t30\n+2\t20\n+\ndiff --git a/test/sql/aggregate/distinct/distinct_on_order_by.test b/test/sql/aggregate/distinct/distinct_on_order_by.test\nnew file mode 100644\nindex 000000000000..266690b5c0f3\n--- /dev/null\n+++ b/test/sql/aggregate/distinct/distinct_on_order_by.test\n@@ -0,0 +1,161 @@\n+# name: test/sql/aggregate/distinct/distinct_on_order_by.test\n+# description: Test DISTINCT ON ORDER BY\n+# group: [distinct]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE integers(i INTEGER, j INTEGER, k INTEGER);\n+\n+statement ok\n+INSERT INTO integers VALUES (2, 3, 5), (4, 5, 6), (2, 7, 6);\n+\n+query II\n+SELECT DISTINCT ON (i) i, j FROM integers ORDER BY i, j DESC;\n+----\n+2\t7\n+4\t5\n+\n+query II\n+SELECT DISTINCT ON (i) i, j FROM integers ORDER BY i, j;\n+----\n+2\t3\n+4\t5\n+\n+# we don't need to ORDER BY i\n+query II\n+SELECT DISTINCT ON (i) i, j FROM integers ORDER BY j DESC;\n+----\n+2\t7\n+4\t5\n+\n+query II\n+SELECT DISTINCT ON (i) i, j FROM integers ORDER BY j;\n+----\n+2\t3\n+4\t5\n+\n+# DISTINCT ON in correlated subqueries\n+query III\n+SELECT i, j, (SELECT DISTINCT ON(i) j) AS k FROM integers ORDER BY i, j;\n+----\n+2\t3\t3\n+2\t7\t7\n+4\t5\t5\n+\n+query III\n+SELECT i, j, (SELECT DISTINCT ON(i) j ORDER BY i, j DESC) AS k FROM integers ORDER BY i, j;\n+----\n+2\t3\t3\n+2\t7\t7\n+4\t5\t5\n+\n+query III\n+SELECT i, j, (SELECT DISTINCT ON(i) j ORDER BY i, k) AS k FROM integers ORDER BY i, j;\n+----\n+2\t3\t3\n+2\t7\t7\n+4\t5\t5\n+\n+# DISTINCT ON with multiple parameters\n+statement ok\n+INSERT INTO integers VALUES (2, 3, 7), (4, 5, 11);\n+\n+query III\n+SELECT DISTINCT ON(i) i, j, k FROM integers ORDER BY i, j ASC, k ASC\n+----\n+2\t3\t5\n+4\t5\t6\n+\n+query III\n+SELECT DISTINCT ON(i) i, j, k FROM integers ORDER BY i, j ASC, k DESC\n+----\n+2\t3\t7\n+4\t5\t11\n+\n+# DISTINCT ON with NULL values\n+statement ok\n+INSERT INTO integers VALUES (2, NULL, 27), (4, 88, NULL);\n+\n+query III\n+SELECT DISTINCT ON(i) i, j, k FROM integers ORDER BY i, j NULLS FIRST, k DESC NULLS LAST;\n+----\n+2\tNULL\t27\n+4\t5\t11\n+\n+query III\n+SELECT DISTINCT ON(i) i, j, k FROM integers ORDER BY i, j NULLS FIRST, k NULLS FIRST;\n+----\n+2\tNULL\t27\n+4\t5\t6\n+\n+query III\n+SELECT DISTINCT ON(i) i, j, k FROM integers ORDER BY i, k NULLS FIRST, j NULLS FIRST;\n+----\n+2\t3\t5\n+4\t88\tNULL\n+\n+# examples from the original issue\n+statement ok\n+create table foo(a real, b real);\n+\n+statement ok\n+insert into foo values (1, 69), (1, 420), (2, 69), (2, 420);\n+\n+query II\n+select distinct on(a) a, b from foo order by b asc;\n+----\n+1\t69\n+2\t69\n+\n+query II\n+select distinct on(a) a, b from foo order by b desc;\n+----\n+1\t420\n+2\t420\n+\n+statement ok\n+CREATE TABLE example (\n+    id               INT,\n+    person_id        INT,\n+    address_id       INT,\n+    effective_date   DATE\n+);\n+\n+statement ok\n+INSERT INTO\n+    example (id, person_id, address_id, effective_date)\n+VALUES\n+    (1, 2, 1, '2000-01-01'),  -- Moved to first house\n+    (5, 2, 2, '2004-08-19'),  -- Went to uni\n+    (9, 2, 1, '2007-06-12'),  -- Moved back home\n+    (2, 4, 3, '2007-05-18'),  -- Moved to first house\n+    (3, 4, 4, '2016-02-09')   -- Moved to new house\n+;\n+\n+query IIII\n+SELECT DISTINCT ON (person_id)\n+    *\n+FROM\n+    example\n+ORDER BY\n+    person_id,\n+    effective_date ASC\n+;\n+----\n+1\t2\t1\t2000-01-01\n+2\t4\t3\t2007-05-18\n+\n+query IIII\n+SELECT DISTINCT ON (person_id)\n+    *\n+FROM\n+    example\n+ORDER BY\n+    person_id,\n+    effective_date DESC\n+;\n+----\n+9\t2\t1\t2007-06-12\n+3\t4\t4\t2016-02-09\n",
  "problem_statement": "SELECT DISTINCT ON does not return the right rows\nDuckDB 0.2.7 on Windows 10\r\n\r\nBased on [https://stackoverflow.com/a/46567397](https://stackoverflow.com/a/46567397)\r\n\r\nThe DISTINCT ON clause should be executed after the ORDER BY clause.\r\n\r\nSorry, I'm having trouble properly formatting the SQL from the StackOverflow page.\r\n\nSELECT DISTINCT ON does not respect ORDER BY\n### What happens?\r\n\r\nWhen running a `SELECT DISTINCT ON ... ORDER BY ...` query, I expect DuckDB to return the first row\u2014as defined by the query's `ORDER BY` clause\u2014for each unique DISTINCT ON. Instead, DuckDB picks a random row.\r\n\r\n[Postgres docs](https://www.postgresql.org/docs/current/sql-select.html#SQL-DISTINCT) for the behavior I expect.\r\n\r\n### To Reproduce\r\n\r\nExtracted from a production use case:\r\n\r\n```\r\nCREATE TABLE fuzzy_data AS (SELECT * FROM VALUES (1, 2, 'a'), (1, null, 'b'), (2, null, 'c'), (null, 4, 'd') t(a, b, foo));\r\n\r\nSELECT DISTINCT ON (t.a)\r\n\"__join1\".\"a\" IS NULL as j1a,\r\n\"__join1\".\"b\" IS NULL as j1b,\r\n\"__join2\".\"a\" IS NULL as j2a,\r\n\"__join2\".\"b\" IS NULL as j2b,\r\nFROM VALUES (1) t(a)\r\nLEFT JOIN \"fuzzy_data\" AS \"__join1\" ON (\"__join1\".\"a\" IS NOT DISTINCT FROM 1 OR \"__join1\".\"a\" IS NULL) AND (\"__join1\".\"b\" IS NOT DISTINCT FROM 2 OR \"__join1\".\"b\" IS NULL)\r\nLEFT JOIN \"fuzzy_data\" AS \"__join2\" ON (\"__join2\".\"a\" IS NOT DISTINCT FROM 1 OR \"__join2\".\"a\" IS NULL) AND (\"__join2\".\"b\" IS NOT DISTINCT FROM 3 OR \"__join2\".\"b\" IS NULL)\r\nORDER BY t.a, \"__join1\".\"a\" IS NULL, \"__join1\".\"b\" IS NULL, \"__join2\".\"a\" IS NULL, \"__join2\".\"b\" IS NULL;\r\n```\r\n\r\nHere's the result of running a few variants of that query in a duckdb 0.7.1 shell:\r\n1. The query above\r\n2. The query minus the `DISTINCT ON (t.a)` part\r\n3. `EXPLAIN` of that query\r\n\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   j1a   \u2502   j1b   \u2502   j2a   \u2502   j2b   \u2502\r\n\u2502 boolean \u2502 boolean \u2502 boolean \u2502 boolean \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 false   \u2502 true    \u2502 false   \u2502 true    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   j1a   \u2502   j1b   \u2502   j2a   \u2502   j2b   \u2502\r\n\u2502 boolean \u2502 boolean \u2502 boolean \u2502 boolean \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 false   \u2502 false   \u2502 false   \u2502 true    \u2502\r\n\u2502 false   \u2502 true    \u2502 false   \u2502 true    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\r\n\u2502\u2502       Physical Plan       \u2502\u2502\r\n\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502          ORDER_BY         \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502          ORDERS:          \u2502\r\n\u2502           #5 ASC          \u2502\r\n\u2502  (__join1.a IS NULL) ASC  \u2502\r\n\u2502  (__join1.b IS NULL) ASC  \u2502\r\n\u2502  (__join2.a IS NULL) ASC  \u2502\r\n\u2502  (__join2.b IS NULL) ASC  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         PROJECTION        \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502             #1            \u2502\r\n\u2502             #2            \u2502\r\n\u2502             #3            \u2502\r\n\u2502             #4            \u2502\r\n\u2502             #0            \u2502\r\n\u2502             #5            \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502       HASH_GROUP_BY       \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502             #0            \u2502\r\n\u2502         first(#1)         \u2502\r\n\u2502         first(#2)         \u2502\r\n\u2502         first(#3)         \u2502\r\n\u2502         first(#4)         \u2502\r\n\u2502         first(#5)         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         PROJECTION        \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502             #4            \u2502\r\n\u2502             #0            \u2502\r\n\u2502             #1            \u2502\r\n\u2502             #2            \u2502\r\n\u2502             #3            \u2502\r\n\u2502             #5            \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         PROJECTION        \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502            j1a            \u2502\r\n\u2502            j1b            \u2502\r\n\u2502            j2a            \u2502\r\n\u2502            j2b            \u2502\r\n\u2502             a             \u2502\r\n\u2502             a             \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502     BLOCKWISE_NL_JOIN     \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502            LEFT           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502            true           \u2502                                           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                           \u2502\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502     BLOCKWISE_NL_JOIN     \u2502                             \u2502           FILTER          \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502            LEFT           \u2502                             \u2502 (((a IS NULL) OR (a IS NOT\u2502\r\n\u2502            true           \u2502                             \u2502  DISTINCT FROM 1)) AND ((b\u2502\r\n\u2502                           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502    IS NULL) OR (b IS NOT  \u2502\r\n\u2502                           \u2502              \u2502              \u2502     DISTINCT FROM 3)))    \u2502\r\n\u2502                           \u2502              \u2502              \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502                           \u2502              \u2502              \u2502           EC: 0           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502      COLUMN_DATA_SCAN     \u2502\u2502           FILTER          \u2502\u2502          SEQ_SCAN         \u2502\r\n\u2502                           \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502                           \u2502\u2502 (((a IS NULL) OR (a IS NOT\u2502\u2502         fuzzy_data        \u2502\r\n\u2502                           \u2502\u2502  DISTINCT FROM 1)) AND ((b\u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502                           \u2502\u2502    IS NULL) OR (b IS NOT  \u2502\u2502             a             \u2502\r\n\u2502                           \u2502\u2502     DISTINCT FROM 2)))    \u2502\u2502             b             \u2502\r\n\u2502                           \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502                           \u2502\u2502           EC: 0           \u2502\u2502           EC: 0           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n                             \u2502          SEQ_SCAN         \u2502\r\n                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n                             \u2502         fuzzy_data        \u2502\r\n                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n                             \u2502             a             \u2502\r\n                             \u2502             b             \u2502\r\n                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n                             \u2502           EC: 0           \u2502\r\n                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nFrom the query plan it's pretty clear the `ORDER_BY` block is on the wrong side of the `HASH_GROUP_BY` block\r\n\r\n### OS:\r\n\r\nOSX, M1\r\n\r\n### DuckDB Version:\r\n\r\n0.7.1\r\n\r\n### DuckDB Client:\r\n\r\nshell\r\n\r\n### Full Name:\r\n\r\nCarl Jackson\r\n\r\n### Affiliation:\r\n\r\nWatershed\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "just hit this too, workaround is to do the ordering in a subquery, note in my case the ordering column is double not int which might be relevant\nCan you try to make a reproducible example following the issue template please?\n@hannes reprex below plz lmk if bug or expected behavior\r\n```\r\ncreate table foo(a real, b real);\r\ninsert into foo values (1, 69), (1, 420), (2, 69), (2, 420);\r\nselect distinct on(a) a, b from foo;\r\nselect distinct on(a) a, b from foo order by b desc; -- this gives the same result\r\n```\nI see. What makes you think the `DISTINCT ON` should be evaluated *after* the `ORDER BY`? Is this somewhere in the SQL standard? The link you sent appears to indicate Postgres does this, but the example you gave produces an error in Postgres: ` SELECT DISTINCT ON expressions must match initial ORDER BY expressions`\nre: the postgres error perhaps the correct syntax is\r\n```\r\nselect distinct on(a) a, b from foo order by a, b desc;\r\n```\r\nwhich should yield the same result... but i don't have access to a shell right now\r\n\r\nthe reasoning for the proposed evaluation order is that currently `DISTINCT ON` yields random results, which renders it useless in many real life use cases -- the SO link provides one, another common scenario is selecting the desired row for each range in a range join\r\n\r\nalso since the behavior hasn't been deterministic up until this point, enforcing this evaluation order wouldn't be breaking\nfrom a bit of googling i can't find any other sql impl that has `DISTINCT ON`, so i'm guessing we got the inspiration from postgres and it would make sense to follow the behavior there... (documentation reproduced here https://www.postgresql.org/docs/9.0/sql-select.html#SQL-DISTINCT)\n@hannes checking in to see if any other info would help w/ further discussion here thanks\n> What makes you think the `DISTINCT ON` should be evaluated _after_ the `ORDER BY`?\r\n\r\nFor me, the whole point of `distinct on` is syntatic sugar to filter a table for the max/min element of a group. Without `distinct on` you have to resort to joining on a subquery. The `distinct on` syntax is more concise, clearer, and IMHO more beautiful.\r\n\r\nIf `distinct on` simply returns a random value from the group it's not useful for this use-case. Maybe there other use-cases for it IDK, but by applying the `DISTINCT ON` *after* the `ORDER BY` it allows it to be used for filtering on the latest/max/min per group which makes it much more useful/powerful.\r\n\r\nAs @kevinykuo points out, the current implementation returns a random match (the first value in the set of matches) so changing it to return the first value after the `ORDER BY` clause has been applied is backward-compatible (modulo [`#1172`](https://xkcd.com/1172/))\r\n\r\n----\r\n\r\nExample showing that, as implemented, `DISTINCT ON` just returns the first value of a random set of matches rather than either the smallest or largest value (of `b`)\r\n\r\n![image](https://user-images.githubusercontent.com/881019/216973928-8c87933c-fa06-41db-b009-602699410bf5.png)\r\n\r\n\nWhat you have to do without `DISTINCT ON` to get the max/min `b` per group (`a`):\r\n\r\n![image](https://user-images.githubusercontent.com/881019/216977015-8d4fbaf9-d213-452d-898d-09a7fa4ce5be.png)\r\n\nI don't quite understand why the regular `min` and `max` aggregates would not work in your example? Finding the minimum value of `b` for a group `a` is exactly what `GROUP BY` does, no?\r\n\r\n```sql\r\nD select a, max(b) from foo group by a;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   a   \u2502 max(b) \u2502\r\n\u2502 float \u2502 float  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502   1.0 \u2502  420.0 \u2502\r\n\u2502   2.0 \u2502  420.0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD select a, min(b) from foo group by a;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   a   \u2502 min(b) \u2502\r\n\u2502 float \u2502 float  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502   1.0 \u2502   53.0 \u2502\r\n\u2502   2.0 \u2502   53.0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nSorry, bad example. I think you can't use `max` where you want to get the value of other columns, not in the `GROUP BY`? I think it might also not work for duplicate max values (neither does the join above). e.g.\r\n```\r\ncreate table foo(a real, b real, c real);\r\ninsert into foo values (1, 69, 1), (1, 53, 2), (1, 420, 3), (1, 420, 4), (2, 55, 1), (2, 69, 2), (2,53, 3), (2, 420, 4);\r\n```\r\n```\r\nwith T1 as (\r\n    select *\r\n    from foo\r\n    order by b desc\r\n)\r\nselect distinct on(a) a, b, c from T1\r\n```\r\n<table>\r\n<tr>\r\n<td>\r\n\r\n![image](https://user-images.githubusercontent.com/881019/216998647-a3ea50a9-ba1d-4857-aff3-58f7b0668a0b.png)\r\n</td>\r\n<td>\r\n\r\n![image](https://user-images.githubusercontent.com/881019/216999406-1e376ff9-8222-4bc2-9b08-990ef3ae8a9b.png)\r\n</td>\r\n</tr>\r\n</table>\r\n\r\n----\r\n\r\n***Edit:***\r\nMaybe that's what `ANY_VALUE` is for - I'm not familiar with that:\r\n\r\n```\r\ncon.execute(\"select a, max(b), c from foo group by a;\").arrow().to_pandas()\r\n```\r\n> `BinderException: Binder Error: column \"c\" must appear in the GROUP BY clause or must be part of an aggregate function.\r\nEither add it to the GROUP BY list, or use \"ANY_VALUE(c)\" if the exact value of \"c\" is not important.\r\nLINE 1: select a, max(b), c from foo group by a;`\nYou can use `max_by` or `min_by` for that, e.g.:\r\n\r\n```sql\r\nselect a, max(b), max_by(c, b), min_by(c, b) from foo group by a;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   a   \u2502 max(b) \u2502 max_by(c, b) \u2502 min_by(c, b) \u2502\r\n\u2502 float \u2502 float  \u2502    float     \u2502    float     \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502   1.0 \u2502  420.0 \u2502          3.0 \u2502          2.0 \u2502\r\n\u2502   2.0 \u2502  420.0 \u2502          4.0 \u2502          3.0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nAs a side-note, instead of using `.arrow().to_pandas()` it should be faster to use `.df()` directly.\nThanks, that's good to know! I'm just getting started out with `duckdb` so I'm still figuring things out.\r\n\r\nThat's in fact how I ended up here - I was looking to see if `duckdb` supported postgres' `DISTINCT ON` command. I'm glad I found this issue as if I had of used it as I would have in postgres I would have gotten silently incorrect results which might have been quite tricky to track down.\r\n\r\nAll other things being equal, I thing it would be good to align with the postgres implementation, if only to prevent users familiar with that from shooting themselves in the foot.\nDuplicate of #2041. As explained there moving the `ORDER BY` below the `HASH AGGREGATE` is not a sufficient solution in a multi-threaded system - that only works in a single-threaded execution model. Instead what you want to do is push the `ORDER BY` into the `FIRST` aggregates, so that they become e.g. `FIRST(b ORDER BY a)`. If the order clause is simple enough the system could also translate it into a `MAX_BY`/`MIN_BY` to improve execution speed. ",
  "created_at": "2023-03-07T16:43:04Z"
}