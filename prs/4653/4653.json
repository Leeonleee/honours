{
  "repo": "duckdb/duckdb",
  "pull_number": 4653,
  "instance_id": "duckdb__duckdb-4653",
  "issue_numbers": [
    "4625"
  ],
  "base_commit": "70b2c7359ae7dfeb32d0780affe5e935f1aeb7e2",
  "patch": "diff --git a/src/common/sort/sort_state.cpp b/src/common/sort/sort_state.cpp\nindex e7ef941e10b6..071a71b0d26c 100644\n--- a/src/common/sort/sort_state.cpp\n+++ b/src/common/sort/sort_state.cpp\n@@ -123,6 +123,32 @@ SortLayout::SortLayout(const vector<BoundOrderByNode> &orders)\n \tblob_layout.Initialize(blob_layout_types);\n }\n \n+SortLayout SortLayout::GetPrefixComparisonLayout(idx_t num_prefix_cols) const {\n+\tSortLayout result;\n+\tresult.column_count = num_prefix_cols;\n+\tresult.all_constant = true;\n+\tresult.comparison_size = 0;\n+\tfor (idx_t col_idx = 0; col_idx < num_prefix_cols; col_idx++) {\n+\t\tresult.order_types.push_back(order_types[col_idx]);\n+\t\tresult.order_by_null_types.push_back(order_by_null_types[col_idx]);\n+\t\tresult.logical_types.push_back(logical_types[col_idx]);\n+\n+\t\tresult.all_constant = result.all_constant && constant_size[col_idx];\n+\t\tresult.constant_size.push_back(constant_size[col_idx]);\n+\n+\t\tresult.comparison_size += column_sizes[col_idx];\n+\t\tresult.column_sizes.push_back(column_sizes[col_idx]);\n+\n+\t\tresult.prefix_lengths.push_back(prefix_lengths[col_idx]);\n+\t\tresult.stats.push_back(stats[col_idx]);\n+\t\tresult.has_null.push_back(has_null[col_idx]);\n+\t}\n+\tresult.entry_size = entry_size;\n+\tresult.blob_layout = blob_layout;\n+\tresult.sorting_to_blob_col = sorting_to_blob_col;\n+\treturn result;\n+}\n+\n LocalSortState::LocalSortState() : initialized(false) {\n }\n \ndiff --git a/src/execution/operator/aggregate/physical_window.cpp b/src/execution/operator/aggregate/physical_window.cpp\nindex 6269b3a905e1..318b8e43e632 100644\n--- a/src/execution/operator/aggregate/physical_window.cpp\n+++ b/src/execution/operator/aggregate/physical_window.cpp\n@@ -34,12 +34,14 @@ class WindowGlobalHashGroup {\n \n \tWindowGlobalHashGroup(BufferManager &buffer_manager, const Orders &partitions, const Orders &orders,\n \t                      const Types &payload_types, idx_t max_mem, bool external)\n-\t    : memory_per_thread(max_mem), count(0), partition_layout(partitions) {\n+\t    : memory_per_thread(max_mem), count(0) {\n \n \t\tRowLayout payload_layout;\n \t\tpayload_layout.Initialize(payload_types);\n \t\tglobal_sort = make_unique<GlobalSortState>(buffer_manager, orders, payload_layout);\n \t\tglobal_sort->external = external;\n+\n+\t\tpartition_layout = global_sort->sort_layout.GetPrefixComparisonLayout(partitions.size());\n \t}\n \n \tvoid Combine(LocalSortState &local_sort) {\ndiff --git a/src/include/duckdb/common/sort/sort.hpp b/src/include/duckdb/common/sort/sort.hpp\nindex b7e40437e62f..4a938e0d56ca 100644\n--- a/src/include/duckdb/common/sort/sort.hpp\n+++ b/src/include/duckdb/common/sort/sort.hpp\n@@ -26,7 +26,10 @@ struct SortConstants {\n \n struct SortLayout {\n public:\n+\tSortLayout() {\n+\t}\n \texplicit SortLayout(const vector<BoundOrderByNode> &orders);\n+\tSortLayout GetPrefixComparisonLayout(idx_t num_prefix_cols) const;\n \n public:\n \tidx_t column_count;\n",
  "test_patch": "diff --git a/test/issues/general/test_4625.test b/test/issues/general/test_4625.test\nnew file mode 100644\nindex 000000000000..187d32342bb0\n--- /dev/null\n+++ b/test/issues/general/test_4625.test\n@@ -0,0 +1,25 @@\n+# name: test/issues/general/test_4625.test\n+# description: Issue 4625: Address boundary error when using PARTITION BY\n+# group: [general]\n+\n+require vector_size 512\n+\n+statement ok\n+CREATE TABLE \"crash\"\n+(\"amount\" \"FLOAT\",\n+ \"account\" \"TEXT\");\n+\n+statement ok\n+INSERT INTO \"crash\"\n+VALUES\n+ (1000, '123456789012'),\n+ (1000, '1234567890123');\n+\n+query T\n+SELECT SUM(\"amount\") OVER (PARTITION BY \"account\"\n+                           ORDER BY \"account\" ASC\n+                           ROWS CURRENT ROW)\n+FROM \"crash\";\n+----\n+1000.0\n+1000.0\n",
  "problem_statement": "Address boundary error when using PARTITION BY\n### What happens?\n\n`PARTITION BY` a \"TEXT\" key might crash duckdb under certain conditions.\n\n### To Reproduce\n\n```sql\r\nCREATE TABLE \"crash\"\r\n(\"amount\" \"FLOAT\", \r\n \"account\" \"TEXT\");\r\n\r\nINSERT INTO \"crash\"\r\nVALUES\r\n (1000, '123456789012'),\r\n (1000, '1234567890123');\r\n\r\nSELECT SUM(\"amount\") OVER (PARTITION BY \"account\"\r\n                           ORDER BY \"account\" ASC\r\n                           ROWS CURRENT ROW)\r\nFROM \"crash\";\r\n```\r\nHowever, duckdb runs just fine if we change `1234567890123` to `123456789012` (or a shorter value).\r\n\n\n### OS:\n\nMacOSX (M1)\n\n### DuckDB Version:\n\n0.5.0, v0.5.1-dev7\n\n### DuckDB Client:\n\ncli & jdbc\n\n### Full Name:\n\nBenjamin Wang\n\n### Affiliation:\n\nN/A\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "We're aware of this issue, it was brought up a few days ago by Pedro Tadim.\r\nAny string larger than 12 characters causes this problem, it's probably a bug in constant handling. (12 is string_t::INLINE_LENGTH, exceeding that makes the size no longer constant)\nThe problem is that the partition and ordering layouts do not have matching constant states. Which is very strange because the partition layout is a prefix of the ordering layout. So how can the partition be not constant when the ordering is constant?\nI looked into this and it seems like the left and right `SortedBlock` have the same `SortLayout` when being compared, but a different `SortLayout` is being passed into the comparison function at `physical_window.cpp:80`, causing the crash.\r\n\r\nI'll look into a fix today.\nI think I've found the problem. I have an optimization in `SortLayout`, that treats `VARCHAR` key columns as constant if we can derive from the statistics that their size is less or equal to 12 chars.\r\n\r\nThe problem here is that when we use a different `SortLayout` for the same data. For the partitions, we sort only by a single string, which has a max size of 13, and we get an entry size of 16 for the `SortLayout` (prefix 12 chars + 32bit int for row id, and it always rounds to multiples of 8). This makes the string just slightly too long to be compared with just the constant comparison.\r\n\r\nWhen we sort by two strings, both 13 chars, we get 12 + 12 + 4 = 28 for our entry size. This is not a multiple of 8, we have 4 bytes to spare for 32 bytes. So, we encode the full 13 bytes of both strings, for 13 + 13 + 4 = 30, and 2 bytes of padding, making the comparison constant.\r\n\r\nSo, we have a non-constant `SortLayout` for the partitions, and a constant `SortLayout` for the partition + order. What we should do here is create a `GetPrefixComparisonLayout(idx_t num_cols)` to `SortLayout`, and use that for the partitions.",
  "created_at": "2022-09-08T11:06:39Z"
}