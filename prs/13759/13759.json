{
  "repo": "duckdb/duckdb",
  "pull_number": 13759,
  "instance_id": "duckdb__duckdb-13759",
  "issue_numbers": [
    "13471"
  ],
  "base_commit": "a6e32b115826ba543e32a733cb92f68fd0549186",
  "patch": "diff --git a/src/planner/binder/statement/bind_insert.cpp b/src/planner/binder/statement/bind_insert.cpp\nindex ac430edee321..f02be80009d1 100644\n--- a/src/planner/binder/statement/bind_insert.cpp\n+++ b/src/planner/binder/statement/bind_insert.cpp\n@@ -295,7 +295,7 @@ void Binder::BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &tabl\n \t\t\tauto entry = specified_columns.find(col.Name());\n \t\t\tif (entry != specified_columns.end()) {\n \t\t\t\t// column was specified, set to the index\n-\t\t\t\tinsert.on_conflict_filter.insert(col.Oid());\n+\t\t\t\tinsert.on_conflict_filter.insert(col.Physical().index);\n \t\t\t}\n \t\t}\n \t\tbool index_references_columns = false;\n@@ -353,8 +353,12 @@ void Binder::BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &tabl\n \t// add a bind context entry for it\n \tauto excluded_index = GenerateTableIndex();\n \tinsert.excluded_table_index = excluded_index;\n-\tauto table_column_names = columns.GetColumnNames();\n-\tauto table_column_types = columns.GetColumnTypes();\n+\tvector<string> table_column_names;\n+\tvector<LogicalType> table_column_types;\n+\tfor (auto &col : columns.Physical()) {\n+\t\ttable_column_names.push_back(col.Name());\n+\t\ttable_column_types.push_back(col.Type());\n+\t}\n \tbind_context.AddGenericBinding(excluded_index, \"excluded\", table_column_names, table_column_types);\n \n \tif (on_conflict.condition) {\n",
  "test_patch": "diff --git a/test/sql/upsert/test_generated_column.test b/test/sql/upsert/test_generated_column.test\nnew file mode 100644\nindex 000000000000..00281a2d2a28\n--- /dev/null\n+++ b/test/sql/upsert/test_generated_column.test\n@@ -0,0 +1,48 @@\n+# name: test/sql/upsert/test_generated_column.test\n+# group: [upsert]\n+\n+# SET expression targets b (located after the virtual column)\n+\n+statement ok\n+CREATE TABLE t1 (\n+\ta CHAR NOT NULL,\n+\tc CHAR GENERATED ALWAYS AS (a) VIRTUAL,\n+\tb INT,\n+);\n+\n+statement ok\n+CREATE UNIQUE INDEX t1_idx ON t1 (a);\n+\n+statement ok\n+INSERT INTO t1 VALUES ('a', 1) ON CONFLICT(a) DO UPDATE SET b = excluded.b;\n+\n+statement ok\n+INSERT INTO t1 VALUES ('a', 1) ON CONFLICT(a) DO UPDATE SET b = excluded.b;\n+\n+query III\n+select * from t1;\n+----\n+a\ta\t1\n+\n+# The ON CONFLICT (a) is logically located after the virtual column\n+\n+statement ok\n+CREATE TABLE t2 (\n+\tb INT,\n+\tc CHAR GENERATED ALWAYS AS (a) VIRTUAL,\n+\ta CHAR NOT NULL,\n+);\n+\n+statement ok\n+CREATE UNIQUE INDEX t2_idx ON t2 (a);\n+\n+statement ok\n+INSERT INTO t2 VALUES (1, 'a') ON CONFLICT(a) DO UPDATE SET b = excluded.b;\n+\n+statement ok\n+INSERT INTO t2 VALUES (1, 'a') ON CONFLICT(a) DO UPDATE SET b = excluded.b;\n+\n+query III\n+select * from t1;\n+----\n+a\ta\t1\n",
  "problem_statement": "\"Failed to bind column reference\" when inserting into a table with a virtual column\n### What happens?\r\n\r\nWhen inserting into a table with a virtual column duckdb throws error and blocks further interactions with the table\r\n\r\n![Screenshot from 2024-08-19 18-51-34](https://github.com/user-attachments/assets/01ef18cc-bb9f-4190-8133-434c420f0432)\r\n\r\n\r\n### To Reproduce\r\n\r\n### How to reproduce in cli\r\n\r\n```sql\r\nCREATE TABLE t1 (a CHAR NOT NULL, c CHAR GENERATED ALWAYS AS (a) VIRTUAL, b INT);\r\nCREATE UNIQUE INDEX t1_idx ON t1 (a);\r\nINSERT OR REPLACE INTO t1 (a, b) VALUES ('a', 1);\r\n```\r\n\r\nThe output after executing last line from the above:\r\n```\r\nINTERNAL Error: Failed to bind column reference \"b\" [10.2] (bindings: {#[10.0], #[10.1], #[2.0], #[2.1]})\r\nThis error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.\r\nFor more information, see https://duckdb.org/docs/dev/internal_errors\r\n```\r\n\r\n### Observations\r\n#### There is no issue if virtual column is last in table so below runs without issue\r\n``` \r\nCREATE TABLE t1 (a CHAR NOT NULL, b INT, c CHAR GENERATED ALWAYS AS (a) VIRTUAL);\r\nCREATE UNIQUE INDEX t1_idx ON t1 (a);\r\nINSERT OR REPLACE INTO t1 (a, b) VALUES ('a', 1);\r\n```\r\n#### There is no issue if index is not created so below runs ok\r\n```\r\nCREATE TABLE t1 (a CHAR NOT NULL, b INT, c CHAR GENERATED ALWAYS AS (a) VIRTUAL);\r\nINSERT INTO t1 (a, b) VALUES ('a', 1);\r\n```\r\n#### Issue is also reproduced when inserting BY NAME\r\n```\r\nCREATE TABLE t1 (a CHAR NOT NULL, c CHAR GENERATED ALWAYS AS (a) VIRTUAL, b INT);\r\nCREATE UNIQUE INDEX t1_idx ON t1 (a);\r\nINSERT OR REPLACE INTO t1 BY NAME (SELECT 'a' as a, 1 as b);\r\n```\r\n\r\n### OS:\r\n\r\nLinux, x86_64\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0 and also nightly build e1568a2\r\n\r\n### DuckDB Client:\r\n\r\ncli\r\n\r\n### Full Name:\r\n\r\nBoris Urman\r\n\r\n### Affiliation:\r\n\r\nLogility\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a nightly build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Thanks, I could reproduce this. This error should not occur - we'll take a look.\nI have tried to fix the issue.\r\nbefore:\r\n```shell\r\nD select * from t1;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    a    \u2502    c    \u2502   b   \u2502\r\n\u2502 varchar \u2502 varchar \u2502 int32 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502          0 rows           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD INSERT OR REPLACE INTO t1 (a, b) VALUES ('a', 1);\r\nINTERNAL Error: Failed to bind column reference \"b\" [10.2] (bindings: {#[10.0], #[10.1], #[2.0], #[2.1]})\r\nThis error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.\r\nFor more information, see https://duckdb.org/docs/dev/internal_errors\r\nD \r\n\r\n```\r\n\r\nand after:\r\n```shell\r\nEnter \".help\" for usage hints.\r\nD INSERT OR REPLACE INTO t1 (a, b) VALUES ('a', 1);\r\nD select * from t1;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    a    \u2502    c    \u2502   b   \u2502\r\n\u2502 varchar \u2502 varchar \u2502 int32 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 a       \u2502 a       \u2502     1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD \r\n```",
  "created_at": "2024-09-05T08:07:45Z"
}