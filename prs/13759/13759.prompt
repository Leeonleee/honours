You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
"Failed to bind column reference" when inserting into a table with a virtual column
### What happens?

When inserting into a table with a virtual column duckdb throws error and blocks further interactions with the table

![Screenshot from 2024-08-19 18-51-34](https://github.com/user-attachments/assets/01ef18cc-bb9f-4190-8133-434c420f0432)


### To Reproduce

### How to reproduce in cli

```sql
CREATE TABLE t1 (a CHAR NOT NULL, c CHAR GENERATED ALWAYS AS (a) VIRTUAL, b INT);
CREATE UNIQUE INDEX t1_idx ON t1 (a);
INSERT OR REPLACE INTO t1 (a, b) VALUES ('a', 1);
```

The output after executing last line from the above:
```
INTERNAL Error: Failed to bind column reference "b" [10.2] (bindings: {#[10.0], #[10.1], #[2.0], #[2.1]})
This error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.
For more information, see https://duckdb.org/docs/dev/internal_errors
```

### Observations
#### There is no issue if virtual column is last in table so below runs without issue
``` 
CREATE TABLE t1 (a CHAR NOT NULL, b INT, c CHAR GENERATED ALWAYS AS (a) VIRTUAL);
CREATE UNIQUE INDEX t1_idx ON t1 (a);
INSERT OR REPLACE INTO t1 (a, b) VALUES ('a', 1);
```
#### There is no issue if index is not created so below runs ok
```
CREATE TABLE t1 (a CHAR NOT NULL, b INT, c CHAR GENERATED ALWAYS AS (a) VIRTUAL);
INSERT INTO t1 (a, b) VALUES ('a', 1);
```
#### Issue is also reproduced when inserting BY NAME
```
CREATE TABLE t1 (a CHAR NOT NULL, c CHAR GENERATED ALWAYS AS (a) VIRTUAL, b INT);
CREATE UNIQUE INDEX t1_idx ON t1 (a);
INSERT OR REPLACE INTO t1 BY NAME (SELECT 'a' as a, 1 as b);
```

### OS:

Linux, x86_64

### DuckDB Version:

1.0.0 and also nightly build e1568a2

### DuckDB Client:

cli

### Full Name:

Boris Urman

### Affiliation:

Logility

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a nightly build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/planner/binder/statement/bind_insert.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/parser/expression/constant_expression.hpp"
3: #include "duckdb/parser/expression/function_expression.hpp"
4: #include "duckdb/parser/statement/insert_statement.hpp"
5: #include "duckdb/parser/query_node/select_node.hpp"
6: #include "duckdb/parser/tableref/expressionlistref.hpp"
7: #include "duckdb/planner/binder.hpp"
8: #include "duckdb/planner/expression_binder/insert_binder.hpp"
9: #include "duckdb/planner/operator/logical_insert.hpp"
10: #include "duckdb/planner/operator/logical_get.hpp"
11: #include "duckdb/common/string_util.hpp"
12: #include "duckdb/function/table/table_scan.hpp"
13: #include "duckdb/planner/operator/logical_dummy_scan.hpp"
14: #include "duckdb/planner/operator/logical_projection.hpp"
15: #include "duckdb/planner/expression_iterator.hpp"
16: #include "duckdb/planner/expression_binder/where_binder.hpp"
17: #include "duckdb/planner/expression_binder/update_binder.hpp"
18: #include "duckdb/parser/statement/update_statement.hpp"
19: #include "duckdb/planner/expression/bound_default_expression.hpp"
20: #include "duckdb/catalog/catalog_entry/index_catalog_entry.hpp"
21: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
22: #include "duckdb/planner/bound_tableref.hpp"
23: #include "duckdb/planner/tableref/bound_basetableref.hpp"
24: #include "duckdb/planner/tableref/bound_dummytableref.hpp"
25: #include "duckdb/parser/parsed_expression_iterator.hpp"
26: #include "duckdb/storage/table_storage_info.hpp"
27: #include "duckdb/parser/tableref/basetableref.hpp"
28: 
29: namespace duckdb {
30: 
31: static void CheckInsertColumnCountMismatch(idx_t expected_columns, idx_t result_columns, bool columns_provided,
32:                                            const char *tname) {
33: 	if (result_columns != expected_columns) {
34: 		string msg = StringUtil::Format(!columns_provided ? "table %s has %lld columns but %lld values were supplied"
35: 		                                                  : "Column name/value mismatch for insert on %s: "
36: 		                                                    "expected %lld columns but %lld values were supplied",
37: 		                                tname, expected_columns, result_columns);
38: 		throw BinderException(msg);
39: 	}
40: }
41: 
42: unique_ptr<ParsedExpression> ExpandDefaultExpression(const ColumnDefinition &column) {
43: 	if (column.HasDefaultValue()) {
44: 		return column.DefaultValue().Copy();
45: 	} else {
46: 		return make_uniq<ConstantExpression>(Value(column.Type()));
47: 	}
48: }
49: 
50: void ReplaceDefaultExpression(unique_ptr<ParsedExpression> &expr, const ColumnDefinition &column) {
51: 	D_ASSERT(expr->type == ExpressionType::VALUE_DEFAULT);
52: 	expr = ExpandDefaultExpression(column);
53: }
54: 
55: void ExpressionBinder::DoUpdateSetQualifyInLambda(FunctionExpression &function, const string &table_name,
56:                                                   vector<unordered_set<string>> &lambda_params) {
57: 
58: 	for (auto &child : function.children) {
59: 		if (child->expression_class != ExpressionClass::LAMBDA) {
60: 			DoUpdateSetQualify(child, table_name, lambda_params);
61: 			continue;
62: 		}
63: 
64: 		// Special-handling for LHS lambda parameters.
65: 		// We do not qualify them, and we add them to the lambda_params vector.
66: 		auto &lambda_expr = child->Cast<LambdaExpression>();
67: 		string error_message;
68: 		auto column_ref_expressions = lambda_expr.ExtractColumnRefExpressions(error_message);
69: 
70: 		if (!error_message.empty()) {
71: 			// Possibly a JSON function, qualify both LHS and RHS.
72: 			ParsedExpressionIterator::EnumerateChildren(*lambda_expr.lhs, [&](unique_ptr<ParsedExpression> &child) {
73: 				DoUpdateSetQualify(child, table_name, lambda_params);
74: 			});
75: 			ParsedExpressionIterator::EnumerateChildren(*lambda_expr.expr, [&](unique_ptr<ParsedExpression> &child) {
76: 				DoUpdateSetQualify(child, table_name, lambda_params);
77: 			});
78: 			continue;
79: 		}
80: 
81: 		// Push the lambda parameter names of this level.
82: 		lambda_params.emplace_back();
83: 		for (const auto &column_ref_expr : column_ref_expressions) {
84: 			const auto &column_ref = column_ref_expr.get().Cast<ColumnRefExpression>();
85: 			lambda_params.back().emplace(column_ref.GetName());
86: 		}
87: 
88: 		// Only qualify in the RHS of the expression.
89: 		ParsedExpressionIterator::EnumerateChildren(*lambda_expr.expr, [&](unique_ptr<ParsedExpression> &child) {
90: 			DoUpdateSetQualify(child, table_name, lambda_params);
91: 		});
92: 
93: 		lambda_params.pop_back();
94: 	}
95: }
96: 
97: void ExpressionBinder::DoUpdateSetQualify(unique_ptr<ParsedExpression> &expr, const string &table_name,
98:                                           vector<unordered_set<string>> &lambda_params) {
99: 
100: 	// We avoid ambiguity with EXCLUDED columns by qualifying all column references.
101: 	switch (expr->GetExpressionClass()) {
102: 	case ExpressionClass::COLUMN_REF: {
103: 		auto &col_ref = expr->Cast<ColumnRefExpression>();
104: 		if (col_ref.IsQualified()) {
105: 			return;
106: 		}
107: 
108: 		// Don't qualify lambda parameters.
109: 		if (LambdaExpression::IsLambdaParameter(lambda_params, col_ref.GetName())) {
110: 			return;
111: 		}
112: 
113: 		// Qualify the column reference.
114: 		expr = make_uniq<ColumnRefExpression>(col_ref.GetColumnName(), table_name);
115: 		return;
116: 	}
117: 	case ExpressionClass::FUNCTION: {
118: 		// Special-handling for lambdas, which are inside function expressions.
119: 		auto &function = expr->Cast<FunctionExpression>();
120: 		if (function.IsLambdaFunction()) {
121: 			return DoUpdateSetQualifyInLambda(function, table_name, lambda_params);
122: 		}
123: 		break;
124: 	}
125: 	case ExpressionClass::SUBQUERY: {
126: 		throw BinderException("DO UPDATE SET clause cannot contain a subquery");
127: 	}
128: 	default:
129: 		break;
130: 	}
131: 
132: 	ParsedExpressionIterator::EnumerateChildren(
133: 	    *expr, [&](unique_ptr<ParsedExpression> &child) { DoUpdateSetQualify(child, table_name, lambda_params); });
134: }
135: 
136: // Replace binding.table_index with 'dest' if it's 'source'
137: void ReplaceColumnBindings(Expression &expr, idx_t source, idx_t dest) {
138: 	if (expr.type == ExpressionType::BOUND_COLUMN_REF) {
139: 		auto &bound_columnref = expr.Cast<BoundColumnRefExpression>();
140: 		if (bound_columnref.binding.table_index == source) {
141: 			bound_columnref.binding.table_index = dest;
142: 		}
143: 	}
144: 	ExpressionIterator::EnumerateChildren(
145: 	    expr, [&](unique_ptr<Expression> &child) { ReplaceColumnBindings(*child, source, dest); });
146: }
147: 
148: void Binder::BindDoUpdateSetExpressions(const string &table_alias, LogicalInsert &insert, UpdateSetInfo &set_info,
149:                                         TableCatalogEntry &table, TableStorageInfo &storage_info) {
150: 	D_ASSERT(insert.children.size() == 1);
151: 	D_ASSERT(insert.children[0]->type == LogicalOperatorType::LOGICAL_PROJECTION);
152: 
153: 	vector<column_t> logical_column_ids;
154: 	vector<string> column_names;
155: 	D_ASSERT(set_info.columns.size() == set_info.expressions.size());
156: 
157: 	for (idx_t i = 0; i < set_info.columns.size(); i++) {
158: 		auto &colname = set_info.columns[i];
159: 		auto &expr = set_info.expressions[i];
160: 		if (!table.ColumnExists(colname)) {
161: 			throw BinderException("Referenced update column %s not found in table!", colname);
162: 		}
163: 		auto &column = table.GetColumn(colname);
164: 		if (column.Generated()) {
165: 			throw BinderException("Cant update column \"%s\" because it is a generated column!", column.Name());
166: 		}
167: 		if (std::find(insert.set_columns.begin(), insert.set_columns.end(), column.Physical()) !=
168: 		    insert.set_columns.end()) {
169: 			throw BinderException("Multiple assignments to same column \"%s\"", colname);
170: 		}
171: 		insert.set_columns.push_back(column.Physical());
172: 		logical_column_ids.push_back(column.Oid());
173: 		insert.set_types.push_back(column.Type());
174: 		column_names.push_back(colname);
175: 		if (expr->type == ExpressionType::VALUE_DEFAULT) {
176: 			expr = ExpandDefaultExpression(column);
177: 		}
178: 
179: 		// Qualify and bind the ON CONFLICT DO UPDATE SET expression.
180: 		UpdateBinder update_binder(*this, context);
181: 		update_binder.target_type = column.Type();
182: 
183: 		// Avoid ambiguity between existing table columns and EXCLUDED columns.
184: 		vector<unordered_set<string>> lambda_params;
185: 		update_binder.DoUpdateSetQualify(expr, table_alias, lambda_params);
186: 
187: 		auto bound_expr = update_binder.Bind(expr);
188: 		D_ASSERT(bound_expr);
189: 		insert.expressions.push_back(std::move(bound_expr));
190: 	}
191: 
192: 	// Figure out which columns are indexed on
193: 	unordered_set<column_t> indexed_columns;
194: 	for (auto &index : storage_info.index_info) {
195: 		for (auto &column_id : index.column_set) {
196: 			indexed_columns.insert(column_id);
197: 		}
198: 	}
199: 
200: 	// Verify that none of the columns that are targeted with a SET expression are indexed on
201: 	for (idx_t i = 0; i < logical_column_ids.size(); i++) {
202: 		auto &column = logical_column_ids[i];
203: 		if (indexed_columns.count(column)) {
204: 			throw BinderException("Can not assign to column '%s' because it has a UNIQUE/PRIMARY KEY constraint or is "
205: 			                      "referenced by an INDEX",
206: 			                      column_names[i]);
207: 		}
208: 	}
209: }
210: 
211: unique_ptr<UpdateSetInfo> CreateSetInfoForReplace(TableCatalogEntry &table, InsertStatement &insert,
212:                                                   TableStorageInfo &storage_info) {
213: 	auto set_info = make_uniq<UpdateSetInfo>();
214: 
215: 	auto &columns = set_info->columns;
216: 	// Figure out which columns are indexed on
217: 
218: 	unordered_set<column_t> indexed_columns;
219: 	for (auto &index : storage_info.index_info) {
220: 		for (auto &column_id : index.column_set) {
221: 			indexed_columns.insert(column_id);
222: 		}
223: 	}
224: 
225: 	auto &column_list = table.GetColumns();
226: 	if (insert.columns.empty()) {
227: 		for (auto &column : column_list.Physical()) {
228: 			auto &name = column.Name();
229: 			// FIXME: can these column names be aliased somehow?
230: 			if (indexed_columns.count(column.Oid())) {
231: 				continue;
232: 			}
233: 			columns.push_back(name);
234: 		}
235: 	} else {
236: 		// a list of columns was explicitly supplied, only update those
237: 		for (auto &name : insert.columns) {
238: 			auto &column = column_list.GetColumn(name);
239: 			if (indexed_columns.count(column.Oid())) {
240: 				continue;
241: 			}
242: 			columns.push_back(name);
243: 		}
244: 	}
245: 
246: 	// Create 'excluded' qualified column references of these columns
247: 	for (auto &column : columns) {
248: 		set_info->expressions.push_back(make_uniq<ColumnRefExpression>(column, "excluded"));
249: 	}
250: 
251: 	return set_info;
252: }
253: 
254: void Binder::BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &table, InsertStatement &stmt) {
255: 	if (!stmt.on_conflict_info) {
256: 		insert.action_type = OnConflictAction::THROW;
257: 		return;
258: 	}
259: 	D_ASSERT(stmt.table_ref->type == TableReferenceType::BASE_TABLE);
260: 
261: 	// visit the table reference
262: 	auto bound_table = Bind(*stmt.table_ref);
263: 	if (bound_table->type != TableReferenceType::BASE_TABLE) {
264: 		throw BinderException("Can only update base table!");
265: 	}
266: 
267: 	auto &table_ref = stmt.table_ref->Cast<BaseTableRef>();
268: 	const string &table_alias = !table_ref.alias.empty() ? table_ref.alias : table_ref.table_name;
269: 
270: 	auto &on_conflict = *stmt.on_conflict_info;
271: 	D_ASSERT(on_conflict.action_type != OnConflictAction::THROW);
272: 	insert.action_type = on_conflict.action_type;
273: 
274: 	// obtain the table storage info
275: 	auto storage_info = table.GetStorageInfo(context);
276: 
277: 	auto &columns = table.GetColumns();
278: 	if (!on_conflict.indexed_columns.empty()) {
279: 		// Bind the ON CONFLICT (<columns>)
280: 
281: 		// create a mapping of (list index) -> (column index)
282: 		case_insensitive_map_t<idx_t> specified_columns;
283: 		for (idx_t i = 0; i < on_conflict.indexed_columns.size(); i++) {
284: 			specified_columns[on_conflict.indexed_columns[i]] = i;
285: 			auto column_index = table.GetColumnIndex(on_conflict.indexed_columns[i]);
286: 			if (column_index.index == COLUMN_IDENTIFIER_ROW_ID) {
287: 				throw BinderException("Cannot specify ROWID as ON CONFLICT target");
288: 			}
289: 			auto &col = columns.GetColumn(column_index);
290: 			if (col.Generated()) {
291: 				throw BinderException("Cannot specify a generated column as ON CONFLICT target");
292: 			}
293: 		}
294: 		for (auto &col : columns.Physical()) {
295: 			auto entry = specified_columns.find(col.Name());
296: 			if (entry != specified_columns.end()) {
297: 				// column was specified, set to the index
298: 				insert.on_conflict_filter.insert(col.Oid());
299: 			}
300: 		}
301: 		bool index_references_columns = false;
302: 		for (auto &index : storage_info.index_info) {
303: 			if (!index.is_unique) {
304: 				continue;
305: 			}
306: 			bool index_matches = insert.on_conflict_filter == index.column_set;
307: 			if (index_matches) {
308: 				index_references_columns = true;
309: 				break;
310: 			}
311: 		}
312: 		if (!index_references_columns) {
313: 			// Same as before, this is essentially a no-op, turning this into a DO THROW instead
314: 			// But since this makes no logical sense, it's probably better to throw an error
315: 			throw BinderException("The specified columns as conflict target are not referenced by a UNIQUE/PRIMARY KEY "
316: 			                      "CONSTRAINT or INDEX");
317: 		}
318: 	} else {
319: 		// When omitting the conflict target, the ON CONFLICT applies to every UNIQUE/PRIMARY KEY on the table
320: 
321: 		// We check if there are any constraints on the table, if there aren't we throw an error.
322: 		idx_t found_matching_indexes = 0;
323: 		for (auto &index : storage_info.index_info) {
324: 			if (!index.is_unique) {
325: 				continue;
326: 			}
327: 			auto &indexed_columns = index.column_set;
328: 			bool matches = false;
329: 			for (auto &column : table.GetColumns().Physical()) {
330: 				if (indexed_columns.count(column.Physical().index)) {
331: 					matches = true;
332: 					break;
333: 				}
334: 			}
335: 			found_matching_indexes += matches;
336: 		}
337: 
338: 		if (!found_matching_indexes) {
339: 			throw BinderException(
340: 			    "There are no UNIQUE/PRIMARY KEY Indexes that refer to this table, ON CONFLICT is a no-op");
341: 		} else if (found_matching_indexes != 1) {
342: 			if (insert.action_type != OnConflictAction::NOTHING) {
343: 				// When no conflict target is provided, and the action type is UPDATE,
344: 				// we only allow the operation when only a single Index exists
345: 				throw BinderException("Conflict target has to be provided for a DO UPDATE operation when the table has "
346: 				                      "multiple UNIQUE/PRIMARY KEY constraints");
347: 			}
348: 		}
349: 	}
350: 
351: 	// add the 'excluded' dummy table binding
352: 	AddTableName("excluded");
353: 	// add a bind context entry for it
354: 	auto excluded_index = GenerateTableIndex();
355: 	insert.excluded_table_index = excluded_index;
356: 	auto table_column_names = columns.GetColumnNames();
357: 	auto table_column_types = columns.GetColumnTypes();
358: 	bind_context.AddGenericBinding(excluded_index, "excluded", table_column_names, table_column_types);
359: 
360: 	if (on_conflict.condition) {
361: 		WhereBinder where_binder(*this, context);
362: 
363: 		// Avoid ambiguity between existing table columns and EXCLUDED columns.
364: 		vector<unordered_set<string>> lambda_params;
365: 		where_binder.DoUpdateSetQualify(on_conflict.condition, table_alias, lambda_params);
366: 
367: 		// Bind the ON CONFLICT ... WHERE clause.
368: 		auto condition = where_binder.Bind(on_conflict.condition);
369: 		insert.on_conflict_condition = std::move(condition);
370: 	}
371: 
372: 	optional_idx projection_index;
373: 	reference<vector<unique_ptr<LogicalOperator>>> insert_child_operators = insert.children;
374: 	while (!projection_index.IsValid()) {
375: 		if (insert_child_operators.get().empty()) {
376: 			// No further children to visit
377: 			break;
378: 		}
379: 		auto &current_child = insert_child_operators.get()[0];
380: 		auto table_indices = current_child->GetTableIndex();
381: 		if (table_indices.empty()) {
382: 			// This operator does not have a table index to refer to, we have to visit its children
383: 			insert_child_operators = current_child->children;
384: 			continue;
385: 		}
386: 		projection_index = table_indices[0];
387: 	}
388: 	if (!projection_index.IsValid()) {
389: 		throw InternalException("Could not locate a table_index from the children of the insert");
390: 	}
391: 
392: 	ErrorData unused;
393: 	auto original_binding = bind_context.GetBinding(table_alias, unused);
394: 	D_ASSERT(original_binding && !unused.HasError());
395: 
396: 	auto table_index = original_binding->index;
397: 
398: 	// Replace any column bindings to refer to the projection table_index, rather than the source table
399: 	if (insert.on_conflict_condition) {
400: 		ReplaceColumnBindings(*insert.on_conflict_condition, table_index, projection_index.GetIndex());
401: 	}
402: 
403: 	if (insert.action_type == OnConflictAction::REPLACE) {
404: 		D_ASSERT(on_conflict.set_info == nullptr);
405: 		on_conflict.set_info = CreateSetInfoForReplace(table, stmt, storage_info);
406: 		insert.action_type = OnConflictAction::UPDATE;
407: 	}
408: 	if (on_conflict.set_info && on_conflict.set_info->columns.empty()) {
409: 		// if we are doing INSERT OR REPLACE on a table with no columns outside of the primary key column
410: 		// convert to INSERT OR IGNORE
411: 		insert.action_type = OnConflictAction::NOTHING;
412: 	}
413: 	if (insert.action_type == OnConflictAction::NOTHING) {
414: 		if (!insert.on_conflict_condition) {
415: 			return;
416: 		}
417: 		// Get the column_ids we need to fetch later on from the conflicting tuples
418: 		// of the original table, to execute the expressions
419: 		D_ASSERT(original_binding->binding_type == BindingType::TABLE);
420: 		auto &table_binding = original_binding->Cast<TableBinding>();
421: 		insert.columns_to_fetch = table_binding.GetBoundColumnIds();
422: 		return;
423: 	}
424: 
425: 	D_ASSERT(on_conflict.set_info);
426: 	auto &set_info = *on_conflict.set_info;
427: 	D_ASSERT(set_info.columns.size() == set_info.expressions.size());
428: 
429: 	if (set_info.condition) {
430: 		WhereBinder where_binder(*this, context);
431: 
432: 		// Avoid ambiguity between existing table columns and EXCLUDED columns.
433: 		vector<unordered_set<string>> lambda_params;
434: 		where_binder.DoUpdateSetQualify(set_info.condition, table_alias, lambda_params);
435: 
436: 		// Bind the SET ... WHERE clause.
437: 		auto condition = where_binder.Bind(set_info.condition);
438: 		insert.do_update_condition = std::move(condition);
439: 	}
440: 
441: 	BindDoUpdateSetExpressions(table_alias, insert, set_info, table, storage_info);
442: 
443: 	// Get the column_ids we need to fetch later on from the conflicting tuples
444: 	// of the original table, to execute the expressions
445: 	D_ASSERT(original_binding->binding_type == BindingType::TABLE);
446: 	auto &table_binding = original_binding->Cast<TableBinding>();
447: 	insert.columns_to_fetch = table_binding.GetBoundColumnIds();
448: 
449: 	// Replace the column bindings to refer to the child operator
450: 	for (auto &expr : insert.expressions) {
451: 		// Change the non-excluded column references to refer to the projection index
452: 		ReplaceColumnBindings(*expr, table_index, projection_index.GetIndex());
453: 	}
454: 	// Do the same for the (optional) DO UPDATE condition
455: 	if (insert.do_update_condition) {
456: 		ReplaceColumnBindings(*insert.do_update_condition, table_index, projection_index.GetIndex());
457: 	}
458: }
459: 
460: BoundStatement Binder::Bind(InsertStatement &stmt) {
461: 	BoundStatement result;
462: 	result.names = {"Count"};
463: 	result.types = {LogicalType::BIGINT};
464: 
465: 	BindSchemaOrCatalog(stmt.catalog, stmt.schema);
466: 	auto &table = Catalog::GetEntry<TableCatalogEntry>(context, stmt.catalog, stmt.schema, stmt.table);
467: 	if (!table.temporary) {
468: 		// inserting into a non-temporary table: alters underlying database
469: 		auto &properties = GetStatementProperties();
470: 		properties.RegisterDBModify(table.catalog, context);
471: 	}
472: 
473: 	auto insert = make_uniq<LogicalInsert>(table, GenerateTableIndex());
474: 	// Add CTEs as bindable
475: 	AddCTEMap(stmt.cte_map);
476: 
477: 	auto values_list = stmt.GetValuesList();
478: 
479: 	// bind the root select node (if any)
480: 	BoundStatement root_select;
481: 	if (stmt.column_order == InsertColumnOrder::INSERT_BY_NAME) {
482: 		if (values_list) {
483: 			throw BinderException("INSERT BY NAME can only be used when inserting from a SELECT statement");
484: 		}
485: 		if (!stmt.columns.empty()) {
486: 			throw BinderException("INSERT BY NAME cannot be combined with an explicit column list");
487: 		}
488: 		D_ASSERT(stmt.select_statement);
489: 		// INSERT BY NAME - generate the columns from the names of the SELECT statement
490: 		auto select_binder = Binder::CreateBinder(context, this);
491: 		root_select = select_binder->Bind(*stmt.select_statement);
492: 		MoveCorrelatedExpressions(*select_binder);
493: 
494: 		stmt.columns = root_select.names;
495: 	}
496: 
497: 	vector<LogicalIndex> named_column_map;
498: 	if (!stmt.columns.empty() || stmt.default_values) {
499: 		// insertion statement specifies column list
500: 
501: 		// create a mapping of (list index) -> (column index)
502: 		case_insensitive_map_t<idx_t> column_name_map;
503: 		for (idx_t i = 0; i < stmt.columns.size(); i++) {
504: 			auto entry = column_name_map.insert(make_pair(stmt.columns[i], i));
505: 			if (!entry.second) {
506: 				throw BinderException("Duplicate column name \"%s\" in INSERT", stmt.columns[i]);
507: 			}
508: 			auto column_index = table.GetColumnIndex(stmt.columns[i]);
509: 			if (column_index.index == COLUMN_IDENTIFIER_ROW_ID) {
510: 				throw BinderException("Cannot explicitly insert values into rowid column");
511: 			}
512: 			auto &col = table.GetColumn(column_index);
513: 			if (col.Generated()) {
514: 				throw BinderException("Cannot insert into a generated column");
515: 			}
516: 			insert->expected_types.push_back(col.Type());
517: 			named_column_map.push_back(column_index);
518: 		}
519: 		for (auto &col : table.GetColumns().Physical()) {
520: 			auto entry = column_name_map.find(col.Name());
521: 			if (entry == column_name_map.end()) {
522: 				// column not specified, set index to DConstants::INVALID_INDEX
523: 				insert->column_index_map.push_back(DConstants::INVALID_INDEX);
524: 			} else {
525: 				// column was specified, set to the index
526: 				insert->column_index_map.push_back(entry->second);
527: 			}
528: 		}
529: 	} else {
530: 		// insert by position and no columns specified - insertion into all columns of the table
531: 		// intentionally don't populate 'column_index_map' as an indication of this
532: 		for (auto &col : table.GetColumns().Physical()) {
533: 			named_column_map.push_back(col.Logical());
534: 			insert->expected_types.push_back(col.Type());
535: 		}
536: 	}
537: 
538: 	// bind the default values
539: 	BindDefaultValues(table.GetColumns(), insert->bound_defaults);
540: 	insert->bound_constraints = BindConstraints(table);
541: 	if (!stmt.select_statement && !stmt.default_values) {
542: 		result.plan = std::move(insert);
543: 		return result;
544: 	}
545: 	// Exclude the generated columns from this amount
546: 	idx_t expected_columns = stmt.columns.empty() ? table.GetColumns().PhysicalColumnCount() : stmt.columns.size();
547: 
548: 	// special case: check if we are inserting from a VALUES statement
549: 	if (values_list) {
550: 		auto &expr_list = values_list->Cast<ExpressionListRef>();
551: 		expr_list.expected_types.resize(expected_columns);
552: 		expr_list.expected_names.resize(expected_columns);
553: 
554: 		D_ASSERT(!expr_list.values.empty());
555: 		CheckInsertColumnCountMismatch(expected_columns, expr_list.values[0].size(), !stmt.columns.empty(),
556: 		                               table.name.c_str());
557: 
558: 		// VALUES list!
559: 		for (idx_t col_idx = 0; col_idx < expected_columns; col_idx++) {
560: 			D_ASSERT(named_column_map.size() >= col_idx);
561: 			auto &table_col_idx = named_column_map[col_idx];
562: 
563: 			// set the expected types as the types for the INSERT statement
564: 			auto &column = table.GetColumn(table_col_idx);
565: 			expr_list.expected_types[col_idx] = column.Type();
566: 			expr_list.expected_names[col_idx] = column.Name();
567: 
568: 			// now replace any DEFAULT values with the corresponding default expression
569: 			for (idx_t list_idx = 0; list_idx < expr_list.values.size(); list_idx++) {
570: 				if (expr_list.values[list_idx][col_idx]->type == ExpressionType::VALUE_DEFAULT) {
571: 					// DEFAULT value! replace the entry
572: 					ReplaceDefaultExpression(expr_list.values[list_idx][col_idx], column);
573: 				}
574: 			}
575: 		}
576: 	}
577: 
578: 	// parse select statement and add to logical plan
579: 	unique_ptr<LogicalOperator> root;
580: 	if (stmt.select_statement) {
581: 		if (stmt.column_order == InsertColumnOrder::INSERT_BY_POSITION) {
582: 			auto select_binder = Binder::CreateBinder(context, this);
583: 			root_select = select_binder->Bind(*stmt.select_statement);
584: 			MoveCorrelatedExpressions(*select_binder);
585: 		}
586: 		// inserting from a select - check if the column count matches
587: 		CheckInsertColumnCountMismatch(expected_columns, root_select.types.size(), !stmt.columns.empty(),
588: 		                               table.name.c_str());
589: 
590: 		root = CastLogicalOperatorToTypes(root_select.types, insert->expected_types, std::move(root_select.plan));
591: 	} else {
592: 		root = make_uniq<LogicalDummyScan>(GenerateTableIndex());
593: 	}
594: 	insert->AddChild(std::move(root));
595: 
596: 	BindOnConflictClause(*insert, table, stmt);
597: 
598: 	if (!stmt.returning_list.empty()) {
599: 		insert->return_chunk = true;
600: 		result.types.clear();
601: 		result.names.clear();
602: 		auto insert_table_index = GenerateTableIndex();
603: 		insert->table_index = insert_table_index;
604: 		unique_ptr<LogicalOperator> index_as_logicaloperator = std::move(insert);
605: 
606: 		return BindReturning(std::move(stmt.returning_list), table, stmt.table_ref ? stmt.table_ref->alias : string(),
607: 		                     insert_table_index, std::move(index_as_logicaloperator), std::move(result));
608: 	}
609: 
610: 	D_ASSERT(result.types.size() == result.names.size());
611: 	result.plan = std::move(insert);
612: 
613: 	auto &properties = GetStatementProperties();
614: 	properties.allow_stream_result = false;
615: 	properties.return_type = StatementReturnType::CHANGED_ROWS;
616: 	return result;
617: }
618: 
619: } // namespace duckdb
[end of src/planner/binder/statement/bind_insert.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: