{
  "repo": "duckdb/duckdb",
  "pull_number": 5517,
  "instance_id": "duckdb__duckdb-5517",
  "issue_numbers": [
    "5443"
  ],
  "base_commit": "eb911a5525b844aee75a3ea90de4201b2dfae259",
  "patch": "diff --git a/tools/pythonpkg/src/python_conversion.cpp b/tools/pythonpkg/src/python_conversion.cpp\nindex 3c4a1efe39e7..41152045e55e 100644\n--- a/tools/pythonpkg/src/python_conversion.cpp\n+++ b/tools/pythonpkg/src/python_conversion.cpp\n@@ -298,8 +298,9 @@ Value TransformPythonValue(py::handle ele, const LogicalType &target_type, bool\n \t\treturn ele.cast<string>();\n \tcase PythonObjectType::ByteArray: {\n \t\tauto byte_array = ele.ptr();\n-\t\tauto bytes = PyByteArray_AsString(byte_array);\n-\t\treturn Value::BLOB_RAW(bytes);\n+\t\tconst_data_ptr_t bytes = (const_data_ptr_t)PyByteArray_AsString(byte_array);\n+\t\tidx_t byte_length = PyByteArray_GET_SIZE(byte_array);\n+\t\treturn Value::BLOB(bytes, byte_length);\n \t}\n \tcase PythonObjectType::MemoryView: {\n \t\tpy::memoryview py_view = ele.cast<py::memoryview>();\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_all_types.py b/tools/pythonpkg/tests/fast/test_all_types.py\nindex 2e3f87a4215b..2a4e7c3b1347 100644\n--- a/tools/pythonpkg/tests/fast/test_all_types.py\n+++ b/tools/pythonpkg/tests/fast/test_all_types.py\n@@ -86,6 +86,18 @@ def test_fetchall(self, duckdb_cursor):\n             correct_result = correct_answer_map[cur_type]\n             assert recursive_equality(result, correct_result)\n \n+    def test_bytearray_with_nulls(self):\n+        con = duckdb.connect(database=':memory:')\n+        con.execute(\"CREATE TABLE test (content BLOB)\")\n+        want = bytearray([1, 2, 0, 3, 4])\n+        con.execute(\"INSERT INTO test VALUES (?)\", [want])\n+\n+        con.execute(\"SELECT * from test\")\n+        got = bytearray(con.fetchall()[0][0])\n+        # Don't truncate the array on the nullbyte\n+        assert want == bytearray(got)\n+\n+\n     def test_fetchnumpy(self, duckdb_cursor):\n         conn = duckdb.connect()\n \n",
  "problem_statement": "Null bytes cause string termination for python bytearray\n### What happens?\n\nWhen inserting a python `bytearray` that contains null bytes, the value is truncated to the first null byte. Note that this does not happen for the python `bytes` type. \n\n### To Reproduce\n\n```python\r\nimport duckdb\r\n\r\ncon = duckdb.connect(database=':memory:')\r\ncon.execute(\"CREATE TABLE test (content BLOB)\")\r\nwant = bytearray([1, 2, 0, 3, 4])\r\ncon.execute(\"INSERT INTO test VALUES (?)\", [want])\r\ncon.execute(\"SELECT * from test\")\r\ngot = bytearray(con.fetchall()[0][0])\r\nprint(want, got) # bytearray(b'\\x01\\x02\\x00\\x03\\x04') bytearray(b'\\x01\\x02')\r\nassert want == bytearray(got)\r\n```\n\n### OS:\n\nMacOS Ventura, arm64\n\n### DuckDB Version:\n\nv0.6.0\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nCamden Cheek\n\n### Affiliation:\n\nSourcegraph\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Ah I see the issue\r\n```c++\r\n\tcase PythonObjectType::ByteArray: {\r\n\t\tauto byte_array = ele.ptr();\r\n\t\tauto bytes = PyByteArray_AsString(byte_array);\r\n\t\treturn Value::BLOB_RAW(bytes);\r\n\t}\r\n```\r\nwe get the byte array as a string, but the BLOB_RAW(const char*) constructor checks for a nullbyte, we need to get the length and then use a different constructor that takes a length \ud83d\udc4d ",
  "created_at": "2022-11-28T12:25:48Z"
}