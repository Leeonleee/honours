diff --git a/.github/workflows/Main.yml b/.github/workflows/Main.yml
index c76ce0c08f23..f0f060e35ac8 100644
--- a/.github/workflows/Main.yml
+++ b/.github/workflows/Main.yml
@@ -441,7 +441,7 @@ jobs:
     - name: Install psqlodbc
       run: |
         git clone https://github.com/Mytherin/psqlodbc.git
-        (cd psqlodbc && git checkout f11663bb9d1e6c0bbad8d4df919da1edc3c5338c && make debug)
+        (cd psqlodbc && git checkout 9863221be0aa6e921c25818509b0402ebda1e561 && make debug)
 
     - name: Build
       run: DISABLE_SANITIZER=1 make debug
diff --git a/.github/workflows/Windows.yml b/.github/workflows/Windows.yml
index 8bc7cd540b7b..614972d1ec6b 100644
--- a/.github/workflows/Windows.yml
+++ b/.github/workflows/Windows.yml
@@ -177,7 +177,7 @@ jobs:
     - name: Install psqlodbc
       run: |
         git clone https://github.com/Mytherin/psqlodbc.git
-        (cd psqlodbc && git checkout f11663bb9d1e6c0bbad8d4df919da1edc3c5338c && make release)
+        (cd psqlodbc && git checkout 9863221be0aa6e921c25818509b0402ebda1e561 && make release)
 
     - name: Test psqlodbc
       run: |
diff --git a/extension/tpch/tpch-extension.cpp b/extension/tpch/tpch-extension.cpp
index 732f2e870a4a..adc482992aa9 100644
--- a/extension/tpch/tpch-extension.cpp
+++ b/extension/tpch/tpch-extension.cpp
@@ -9,6 +9,7 @@
 #include "duckdb/parser/parser.hpp"
 #include "duckdb/parser/statement/select_statement.hpp"
 #include "duckdb/parser/parsed_data/create_pragma_function_info.hpp"
+#include "duckdb/main/client_context.hpp"
 #endif
 
 #include "dbgen/dbgen.hpp"
diff --git a/src/catalog/default/default_functions.cpp b/src/catalog/default/default_functions.cpp
index d52edfce8018..a1a2777b420b 100644
--- a/src/catalog/default/default_functions.cpp
+++ b/src/catalog/default/default_functions.cpp
@@ -90,6 +90,10 @@ static DefaultMacro internal_macros[] = {
 	{DEFAULT_SCHEMA, "array_append", {"arr", "el", nullptr}, "list_append(arr, el)"},
 	{DEFAULT_SCHEMA, "list_prepend", {"e", "l", nullptr}, "list_concat(list_value(e), l)"},
 	{DEFAULT_SCHEMA, "array_prepend", {"el", "arr", nullptr}, "list_prepend(el, arr)"},
+	{DEFAULT_SCHEMA, "array_pop_back", {"arr", nullptr}, "arr[:LEN(arr)-1]"},
+	{DEFAULT_SCHEMA, "array_pop_front", {"arr", nullptr}, "arr[1:]"},
+	{DEFAULT_SCHEMA, "array_push_back", {"arr", "e", nullptr}, "list_concat(arr, list_value(e))"},
+	{DEFAULT_SCHEMA, "array_push_front", {"arr", "e", nullptr}, "list_concat(list_value(e), arr)"},
 	{DEFAULT_SCHEMA, "generate_subscripts", {"arr", "dim", nullptr}, "unnest(generate_series(1, array_length(arr, dim)))"},
 	{DEFAULT_SCHEMA, "fdiv", {"x", "y", nullptr}, "floor(x/y)"},
 	{DEFAULT_SCHEMA, "fmod", {"x", "y", nullptr}, "(x-y*floor(x/y))"},
diff --git a/src/execution/operator/projection/physical_unnest.cpp b/src/execution/operator/projection/physical_unnest.cpp
index a3ad774095a2..19bd9cf6bb77 100644
--- a/src/execution/operator/projection/physical_unnest.cpp
+++ b/src/execution/operator/projection/physical_unnest.cpp
@@ -179,9 +179,15 @@ OperatorResultType PhysicalUnnest::Execute(ExecutionContext &context, DataChunk
 				auto &list_vector = state.list_data.data[col_idx];
 				list_vector.Orrify(state.list_data.size(), state.list_vector_data[col_idx]);
 
-				auto &child_vector = ListVector::GetEntry(list_vector);
-				auto list_size = ListVector::GetListSize(list_vector);
-				child_vector.Orrify(list_size, state.list_child_data[col_idx]);
+				if (list_vector.GetType() == LogicalType::SQLNULL) {
+					// UNNEST(NULL)
+					auto &child_vector = list_vector;
+					child_vector.Orrify(0, state.list_child_data[col_idx]);
+				} else {
+					auto list_size = ListVector::GetListSize(list_vector);
+					auto &child_vector = ListVector::GetEntry(list_vector);
+					child_vector.Orrify(list_size, state.list_child_data[col_idx]);
+				}
 			}
 			state.first_fetch = false;
 		}
@@ -230,34 +236,40 @@ OperatorResultType PhysicalUnnest::Execute(ExecutionContext &context, DataChunk
 		for (idx_t col_idx = 0; col_idx < state.list_data.ColumnCount(); col_idx++) {
 			auto &result_vector = chunk.data[col_idx + input.ColumnCount()];
 
-			auto &vdata = state.list_vector_data[col_idx];
-			auto &child_data = state.list_child_data[col_idx];
-			auto current_idx = vdata.sel->get_index(state.parent_position);
-
-			auto list_data = (list_entry_t *)vdata.data;
-			auto list_entry = list_data[current_idx];
-
-			idx_t list_count;
-			if (state.list_position >= list_entry.length) {
-				list_count = 0;
+			if (state.list_data.data[col_idx].GetType() == LogicalType::SQLNULL) {
+				// UNNEST(NULL)
+				chunk.SetCardinality(0);
 			} else {
-				list_count = MinValue<idx_t>(this_chunk_len, list_entry.length - state.list_position);
-			}
+				auto &vdata = state.list_vector_data[col_idx];
+				auto &child_data = state.list_child_data[col_idx];
+				auto current_idx = vdata.sel->get_index(state.parent_position);
 
-			if (list_entry.length > state.list_position) {
-				if (!vdata.validity.RowIsValid(current_idx)) {
-					UnnestNull(0, list_count, result_vector);
+				auto list_data = (list_entry_t *)vdata.data;
+				auto list_entry = list_data[current_idx];
+
+				idx_t list_count;
+				if (state.list_position >= list_entry.length) {
+					list_count = 0;
 				} else {
-					auto &list_vector = state.list_data.data[col_idx];
-					auto &child_vector = ListVector::GetEntry(list_vector);
-					auto list_size = ListVector::GetListSize(list_vector);
+					list_count = MinValue<idx_t>(this_chunk_len, list_entry.length - state.list_position);
+				}
 
-					auto base_offset = list_entry.offset + state.list_position;
-					UnnestVector(child_data, child_vector, list_size, base_offset, base_offset + list_count,
-					             result_vector);
+				if (list_entry.length > state.list_position) {
+					if (!vdata.validity.RowIsValid(current_idx)) {
+						UnnestNull(0, list_count, result_vector);
+					} else {
+						auto &list_vector = state.list_data.data[col_idx];
+						auto &child_vector = ListVector::GetEntry(list_vector);
+						auto list_size = ListVector::GetListSize(list_vector);
+
+						auto base_offset = list_entry.offset + state.list_position;
+						UnnestVector(child_data, child_vector, list_size, base_offset, base_offset + list_count,
+						             result_vector);
+					}
 				}
+
+				UnnestNull(list_count, this_chunk_len, result_vector);
 			}
-			UnnestNull(list_count, this_chunk_len, result_vector);
 		}
 
 		state.list_position += this_chunk_len;
diff --git a/src/function/pragma/pragma_queries.cpp b/src/function/pragma/pragma_queries.cpp
index 26b693d53702..193bc2f9ca32 100644
--- a/src/function/pragma/pragma_queries.cpp
+++ b/src/function/pragma/pragma_queries.cpp
@@ -13,6 +13,21 @@ string PragmaShowTables(ClientContext &context, const FunctionParameters &parame
 	return "SELECT name FROM sqlite_master ORDER BY name";
 }
 
+string PragmaShowTablesExpanded(ClientContext &context, const FunctionParameters &parameters) {
+	return R"(
+			SELECT
+				t.table_name,
+				LIST(c.column_name order by c.column_name) AS column_names,
+				LIST(c.data_type order by c.column_name) AS column_types,
+				FIRST(t.temporary) AS temporary
+			FROM duckdb_tables t
+			JOIN duckdb_columns c
+			USING (table_oid)
+			GROUP BY t.table_name
+			ORDER BY t.table_name;
+	)";
+}
+
 string PragmaAllProfiling(ClientContext &context, const FunctionParameters &parameters) {
 	return "SELECT * FROM pragma_last_profiling_output() JOIN pragma_detailed_profiling_output() ON "
 	       "(pragma_last_profiling_output.operator_id);";
@@ -78,6 +93,7 @@ void PragmaQueries::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(PragmaFunction::PragmaCall("table_info", PragmaTableInfo, {LogicalType::VARCHAR}));
 	set.AddFunction(PragmaFunction::PragmaCall("storage_info", PragmaStorageInfo, {LogicalType::VARCHAR}));
 	set.AddFunction(PragmaFunction::PragmaStatement("show_tables", PragmaShowTables));
+	set.AddFunction(PragmaFunction::PragmaStatement("show_tables_expanded", PragmaShowTablesExpanded));
 	set.AddFunction(PragmaFunction::PragmaStatement("database_list", PragmaDatabaseList));
 	set.AddFunction(PragmaFunction::PragmaStatement("collations", PragmaCollations));
 	set.AddFunction(PragmaFunction::PragmaCall("show", PragmaShow, {LogicalType::VARCHAR}));
diff --git a/src/function/scalar/list/CMakeLists.txt b/src/function/scalar/list/CMakeLists.txt
index 0d7d3306788f..f241d91ba852 100644
--- a/src/function/scalar/list/CMakeLists.txt
+++ b/src/function/scalar/list/CMakeLists.txt
@@ -2,11 +2,12 @@ add_library_unity(
   duckdb_func_list
   OBJECT
   list_concat.cpp
-  list_contains.cpp
+  contains_or_position.cpp
   array_slice.cpp
   list_extract.cpp
   list_value.cpp
-  range.cpp)
+  range.cpp
+  flatten.cpp)
 set(ALL_OBJECT_FILES
     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_func_list>
     PARENT_SCOPE)
diff --git a/src/function/scalar/list/list_contains.cpp b/src/function/scalar/list/contains_or_position.cpp
similarity index 50%
rename from src/function/scalar/list/list_contains.cpp
rename to src/function/scalar/list/contains_or_position.cpp
index 6c0c5fddbed5..48045ec57602 100644
--- a/src/function/scalar/list/list_contains.cpp
+++ b/src/function/scalar/list/contains_or_position.cpp
@@ -5,86 +5,44 @@
 namespace duckdb {
 
 template <class T>
-static inline bool ValueCompare(const T &left, const T &right) {
+static inline bool ValueEqualsOrNot(const T &left, const T &right) {
 	return left == right;
 }
 
 template <>
-inline bool ValueCompare(const string_t &left, const string_t &right) {
+inline bool ValueEqualsOrNot(const string_t &left, const string_t &right) {
 	return StringComparisonOperators::EqualsOrNot<false>(left, right);
 }
 
-template <>
-inline bool ValueCompare(const Value &left, const Value &right) {
-	return left == right;
-}
-
-template <class T>
-static void TemplatedListContainsFunction(DataChunk &args, ExpressionState &state, Vector &result) {
-	D_ASSERT(args.ColumnCount() == 2);
-	auto count = args.size();
-	Vector &list = args.data[0];
-	Vector &value_vector = args.data[1];
-
-	result.SetVectorType(VectorType::FLAT_VECTOR);
-	auto result_entries = FlatVector::GetData<bool>(result); // Create a vector of bool
-	auto &result_validity = FlatVector::Validity(result);
-
-	if (list.GetType().id() == LogicalTypeId::SQLNULL) {
-		result_validity.SetInvalid(0);
-		return;
+struct ContainsFunctor {
+	static inline bool Initialize() {
+		return false;
 	}
+	static inline bool UpdateResultEntries(idx_t child_idx) {
+		return true;
+	}
+};
 
-	auto list_size = ListVector::GetListSize(list);
-	auto &child_vector = ListVector::GetEntry(list);
-
-	VectorData child_data;
-	child_vector.Orrify(list_size, child_data);
-
-	VectorData list_data;
-	list.Orrify(count, list_data);
-	auto list_entries = (list_entry_t *)list_data.data;
-
-	VectorData value_data;
-	value_vector.Orrify(count, value_data);
-
-	for (idx_t i = 0; i < count; i++) {
-		auto list_index = list_data.sel->get_index(i);
-		auto value_index = value_data.sel->get_index(i);
-
-		if (!list_data.validity.RowIsValid(list_index) || !value_data.validity.RowIsValid(value_index)) {
-			result_validity.SetInvalid(i);
-			continue;
-		}
-
-		const auto &list_entry = list_entries[list_index];
-		auto source_idx = child_data.sel->get_index(list_entry.offset);
-		auto child_value = FlatVector::GetData<T>(child_vector);
-
-		auto values = FlatVector::GetData<T>(value_vector);
-		result_entries[list_index] = false;
-		for (idx_t child_idx = 0; child_idx < list_entry.length; child_idx++) {
-			auto child_value_idx = source_idx + child_idx;
-
-			if (!child_data.validity.RowIsValid(child_value_idx)) {
-				continue;
-			}
-			if (ValueCompare<T>(child_value[child_value_idx], values[value_index])) {
-				result_entries[list_index] = true;
-				break; // Found value in list, no need to look further
-			}
-		}
+struct PositionFunctor {
+	static inline int32_t Initialize() {
+		return 0;
 	}
-}
+	static inline int32_t UpdateResultEntries(idx_t child_idx) {
+		return child_idx + 1;
+	}
+};
 
-static void NestedListContainsFunction(DataChunk &args, ExpressionState &state, Vector &result) {
+template <class CHILD_TYPE, class RETURN_TYPE, class OP>
+static void TemplatedContainsOrPosition(DataChunk &args, ExpressionState &state, Vector &result,
+                                        bool is_nested = false) {
 	D_ASSERT(args.ColumnCount() == 2);
 	auto count = args.size();
 	Vector &list = args.data[0];
 	Vector &value_vector = args.data[1];
 
+	// Create a result vector of type RETURN_TYPE
 	result.SetVectorType(VectorType::FLAT_VECTOR);
-	auto result_entries = FlatVector::GetData<bool>(result); // Create a vector of bool
+	auto result_entries = FlatVector::GetData<RETURN_TYPE>(result);
 	auto &result_validity = FlatVector::Validity(result);
 
 	if (list.GetType().id() == LogicalTypeId::SQLNULL) {
@@ -117,71 +75,97 @@ static void NestedListContainsFunction(DataChunk &args, ExpressionState &state,
 		const auto &list_entry = list_entries[list_index];
 		auto source_idx = child_data.sel->get_index(list_entry.offset);
 
-		result_entries[list_index] = false;
+		// not required for a comparison of nested types
+		auto child_value = FlatVector::GetData<CHILD_TYPE>(child_vector);
+		auto values = FlatVector::GetData<CHILD_TYPE>(value_vector);
+
+		result_entries[list_index] = OP::Initialize();
 		for (idx_t child_idx = 0; child_idx < list_entry.length; child_idx++) {
 			auto child_value_idx = source_idx + child_idx;
+
 			if (!child_data.validity.RowIsValid(child_value_idx)) {
 				continue;
 			}
-			if (ValueCompare<Value>(child_vector.GetValue(child_value_idx), value_vector.GetValue(value_index))) {
-				result_entries[list_index] = true;
-				break; // Found value in list, no need to look further
+
+			if (!is_nested) {
+				if (ValueEqualsOrNot<CHILD_TYPE>(child_value[child_value_idx], values[value_index])) {
+					result_entries[list_index] = OP::UpdateResultEntries(child_idx);
+					break; // Found value in list, no need to look further
+				}
+			} else {
+				// FIXME: using Value is less efficient than modifying the vector comparison code
+				// to more efficiently compare nested types
+				if (ValueEqualsOrNot<Value>(child_vector.GetValue(child_value_idx),
+				                            value_vector.GetValue(value_index))) {
+					result_entries[list_index] = OP::UpdateResultEntries(child_idx);
+					break; // Found value in list, no need to look further
+				}
 			}
 		}
 	}
 }
 
-static void ListContainsFunction(DataChunk &args, ExpressionState &state, Vector &result) {
+template <class T, class OP>
+static void ListContainsOrPosition(DataChunk &args, ExpressionState &state, Vector &result) {
 	switch (args.data[1].GetType().InternalType()) {
 	case PhysicalType::BOOL:
 	case PhysicalType::INT8:
-		TemplatedListContainsFunction<int8_t>(args, state, result);
+		TemplatedContainsOrPosition<int8_t, T, OP>(args, state, result);
 		break;
 	case PhysicalType::INT16:
-		TemplatedListContainsFunction<int16_t>(args, state, result);
+		TemplatedContainsOrPosition<int16_t, T, OP>(args, state, result);
 		break;
 	case PhysicalType::INT32:
-		TemplatedListContainsFunction<int32_t>(args, state, result);
+		TemplatedContainsOrPosition<int32_t, T, OP>(args, state, result);
 		break;
 	case PhysicalType::INT64:
-		TemplatedListContainsFunction<int64_t>(args, state, result);
+		TemplatedContainsOrPosition<int64_t, T, OP>(args, state, result);
 		break;
 	case PhysicalType::INT128:
-		TemplatedListContainsFunction<hugeint_t>(args, state, result);
+		TemplatedContainsOrPosition<hugeint_t, T, OP>(args, state, result);
 		break;
 	case PhysicalType::UINT8:
-		TemplatedListContainsFunction<uint8_t>(args, state, result);
+		TemplatedContainsOrPosition<uint8_t, T, OP>(args, state, result);
 		break;
 	case PhysicalType::UINT16:
-		TemplatedListContainsFunction<uint16_t>(args, state, result);
+		TemplatedContainsOrPosition<uint16_t, T, OP>(args, state, result);
 		break;
 	case PhysicalType::UINT32:
-		TemplatedListContainsFunction<uint32_t>(args, state, result);
+		TemplatedContainsOrPosition<uint32_t, T, OP>(args, state, result);
 		break;
 	case PhysicalType::UINT64:
-		TemplatedListContainsFunction<uint64_t>(args, state, result);
+		TemplatedContainsOrPosition<uint64_t, T, OP>(args, state, result);
 		break;
 	case PhysicalType::FLOAT:
-		TemplatedListContainsFunction<float>(args, state, result);
+		TemplatedContainsOrPosition<float, T, OP>(args, state, result);
 		break;
 	case PhysicalType::DOUBLE:
-		TemplatedListContainsFunction<double>(args, state, result);
+		TemplatedContainsOrPosition<double, T, OP>(args, state, result);
 		break;
 	case PhysicalType::VARCHAR:
-		TemplatedListContainsFunction<string_t>(args, state, result);
+		TemplatedContainsOrPosition<string_t, T, OP>(args, state, result);
 		break;
 	case PhysicalType::MAP:
 	case PhysicalType::STRUCT:
 	case PhysicalType::LIST:
-		NestedListContainsFunction(args, state, result);
+		TemplatedContainsOrPosition<int8_t, T, OP>(args, state, result, true);
 		break;
 	default:
 		throw NotImplementedException("This function has not been implemented for this type");
 	}
 }
 
-static unique_ptr<FunctionData> ListContainsBind(ClientContext &context, ScalarFunction &bound_function,
-                                                 vector<unique_ptr<Expression>> &arguments) {
+static void ListContainsFunction(DataChunk &args, ExpressionState &state, Vector &result) {
+	return ListContainsOrPosition<bool, ContainsFunctor>(args, state, result);
+}
+
+static void ListPositionFunction(DataChunk &args, ExpressionState &state, Vector &result) {
+	return ListContainsOrPosition<int32_t, PositionFunctor>(args, state, result);
+}
+
+template <LogicalTypeId RETURN_TYPE>
+static unique_ptr<FunctionData> ListContainsOrPositionBind(ClientContext &context, ScalarFunction &bound_function,
+                                                           vector<unique_ptr<Expression>> &arguments) {
 	D_ASSERT(bound_function.arguments.size() == 2);
 
 	const auto &list = arguments[0]->return_type; // change to list
@@ -204,18 +188,40 @@ static unique_ptr<FunctionData> ListContainsBind(ClientContext &context, ScalarF
 
 		bound_function.arguments[0] = list_type;
 		bound_function.arguments[1] = value == max_child_type ? value : max_child_type;
-		bound_function.return_type = LogicalType::BOOLEAN;
+
+		// list_contains and list_position only differ in their return type
+		bound_function.return_type = RETURN_TYPE;
 	}
 	return make_unique<VariableReturnBindData>(bound_function.return_type);
 }
 
+static unique_ptr<FunctionData> ListContainsBind(ClientContext &context, ScalarFunction &bound_function,
+                                                 vector<unique_ptr<Expression>> &arguments) {
+	return ListContainsOrPositionBind<LogicalType::BOOLEAN>(context, bound_function, arguments);
+}
+
+static unique_ptr<FunctionData> ListPositionBind(ClientContext &context, ScalarFunction &bound_function,
+                                                 vector<unique_ptr<Expression>> &arguments) {
+	return ListContainsOrPositionBind<LogicalType::INTEGER>(context, bound_function, arguments);
+}
+
 ScalarFunction ListContainsFun::GetFunction() {
 	return ScalarFunction({LogicalType::LIST(LogicalType::ANY), LogicalType::ANY}, // argument list
 	                      LogicalType::BOOLEAN,                                    // return type
 	                      ListContainsFunction, false, ListContainsBind, nullptr);
 }
 
+ScalarFunction ListPositionFun::GetFunction() {
+	return ScalarFunction({LogicalType::LIST(LogicalType::ANY), LogicalType::ANY}, // argument list
+	                      LogicalType::INTEGER,                                    // return type
+	                      ListPositionFunction, false, ListPositionBind, nullptr);
+}
+
 void ListContainsFun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction({"list_contains", "array_contains", "list_has", "array_has"}, GetFunction());
 }
+
+void ListPositionFun::RegisterFunction(BuiltinFunctions &set) {
+	set.AddFunction({"list_position", "list_indexof", "array_position", "array_indexof"}, GetFunction());
+}
 } // namespace duckdb
\ No newline at end of file
diff --git a/src/function/scalar/list/flatten.cpp b/src/function/scalar/list/flatten.cpp
new file mode 100644
index 000000000000..9c93fcad1c4d
--- /dev/null
+++ b/src/function/scalar/list/flatten.cpp
@@ -0,0 +1,135 @@
+#include "duckdb/common/types/data_chunk.hpp"
+#include "duckdb/function/scalar/nested_functions.hpp"
+#include "duckdb/planner/expression/bound_function_expression.hpp"
+#include "duckdb/storage/statistics/list_statistics.hpp"
+
+namespace duckdb {
+
+void ListFlattenFunction(DataChunk &args, ExpressionState &state, Vector &result) {
+	D_ASSERT(args.ColumnCount() == 1);
+
+	Vector &input = args.data[0];
+	if (input.GetType().id() == LogicalTypeId::SQLNULL) {
+		result.Reference(input);
+		return;
+	}
+
+	idx_t count = args.size();
+
+	VectorData list_data;
+	input.Orrify(count, list_data);
+	auto list_entries = (list_entry_t *)list_data.data;
+
+	auto &child_vector = ListVector::GetEntry(input);
+
+	result.SetVectorType(VectorType::FLAT_VECTOR);
+	auto result_entries = FlatVector::GetData<list_entry_t>(result);
+	auto &result_validity = FlatVector::Validity(result);
+
+	if (child_vector.GetType().id() == LogicalTypeId::SQLNULL) {
+		auto result_entries = FlatVector::GetData<list_entry_t>(result);
+		for (idx_t i = 0; i < count; i++) {
+			auto list_index = list_data.sel->get_index(i);
+			if (!list_data.validity.RowIsValid(list_index)) {
+				result_validity.SetInvalid(i);
+				continue;
+			}
+			result_entries[i].offset = 0;
+			result_entries[i].length = 0;
+		}
+		return;
+	}
+
+	auto child_size = ListVector::GetListSize(input);
+	VectorData child_data;
+	child_vector.Orrify(child_size, child_data);
+	auto child_entries = (list_entry_t *)child_data.data;
+	auto &data_vector = ListVector::GetEntry(child_vector);
+
+	idx_t offset = 0;
+	for (idx_t i = 0; i < count; i++) {
+		auto list_index = list_data.sel->get_index(i);
+		if (!list_data.validity.RowIsValid(list_index)) {
+			result_validity.SetInvalid(i);
+			continue;
+		}
+		auto list_entry = list_entries[list_index];
+
+		idx_t source_offset = 0;
+		// Find first valid child list entry to get offset
+		for (idx_t j = 0; j < list_entry.length; j++) {
+			auto child_list_index = child_data.sel->get_index(list_entry.offset + j);
+			if (child_data.validity.RowIsValid(child_list_index)) {
+				source_offset = child_entries[child_list_index].offset;
+				break;
+			}
+		}
+
+		idx_t length = 0;
+		// Find last valid child list entry to get length
+		for (idx_t j = list_entry.length - 1; j != (idx_t)-1; j--) {
+			auto child_list_index = child_data.sel->get_index(list_entry.offset + j);
+			if (child_data.validity.RowIsValid(child_list_index)) {
+				auto child_entry = child_entries[child_list_index];
+				length = child_entry.offset + child_entry.length - source_offset;
+				break;
+			}
+		}
+		ListVector::Append(result, data_vector, source_offset + length, source_offset);
+
+		result_entries[i].offset = offset;
+		result_entries[i].length = length;
+		offset += length;
+	}
+
+	if (input.GetVectorType() == VectorType::CONSTANT_VECTOR) {
+		result.SetVectorType(VectorType::CONSTANT_VECTOR);
+	}
+}
+
+static unique_ptr<FunctionData> ListFlattenBind(ClientContext &context, ScalarFunction &bound_function,
+                                                vector<unique_ptr<Expression>> &arguments) {
+	D_ASSERT(bound_function.arguments.size() == 1);
+
+	auto &input_type = arguments[0]->return_type;
+	bound_function.arguments[0] = input_type;
+	if (input_type.id() == LogicalTypeId::SQLNULL) {
+		bound_function.return_type = LogicalType(LogicalTypeId::SQLNULL);
+		return make_unique<VariableReturnBindData>(bound_function.return_type);
+	}
+	D_ASSERT(input_type.id() == LogicalTypeId::LIST);
+
+	auto child_type = ListType::GetChildType(input_type);
+	if (child_type.id() == LogicalType::SQLNULL) {
+		bound_function.return_type = input_type;
+		return make_unique<VariableReturnBindData>(bound_function.return_type);
+	}
+	D_ASSERT(child_type.id() == LogicalTypeId::LIST);
+
+	bound_function.return_type = child_type;
+	return make_unique<VariableReturnBindData>(bound_function.return_type);
+}
+
+static unique_ptr<BaseStatistics> ListFlattenStats(ClientContext &context, BoundFunctionExpression &expr,
+                                                   FunctionData *bind_data,
+                                                   vector<unique_ptr<BaseStatistics>> &child_stats) {
+	if (!child_stats[0]) {
+		return nullptr;
+	}
+	auto &list_stats = (ListStatistics &)*child_stats[0];
+	if (!list_stats.child_stats || list_stats.child_stats->type == LogicalTypeId::SQLNULL) {
+		return nullptr;
+	}
+
+	auto child_copy = list_stats.child_stats->Copy();
+	child_copy->validity_stats = make_unique<ValidityStatistics>(true);
+	return child_copy;
+}
+
+void ListFlattenFun::RegisterFunction(BuiltinFunctions &set) {
+	ScalarFunction fun({LogicalType::LIST(LogicalType::LIST(LogicalType::ANY))}, LogicalType::LIST(LogicalType::ANY),
+	                   ListFlattenFunction, false, ListFlattenBind, nullptr, ListFlattenStats);
+	set.AddFunction({"flatten"}, fun);
+}
+
+} // namespace duckdb
diff --git a/src/function/scalar/nested_functions.cpp b/src/function/scalar/nested_functions.cpp
index e98415508e22..39d1bf3411a1 100644
--- a/src/function/scalar/nested_functions.cpp
+++ b/src/function/scalar/nested_functions.cpp
@@ -8,9 +8,11 @@ void BuiltinFunctions::RegisterNestedFunctions() {
 	Register<StructExtractFun>();
 	Register<ListConcatFun>();
 	Register<ListContainsFun>();
+	Register<ListPositionFun>();
 	Register<ListValueFun>();
 	Register<ListExtractFun>();
 	Register<ListRangeFun>();
+	Register<ListFlattenFun>();
 	Register<MapFun>();
 	Register<MapExtractFun>();
 	Register<CardinalityFun>();
diff --git a/src/function/table/system/pragma_database_size.cpp b/src/function/table/system/pragma_database_size.cpp
index c16bfa2ec1c4..2b314ca0490d 100644
--- a/src/function/table/system/pragma_database_size.cpp
+++ b/src/function/table/system/pragma_database_size.cpp
@@ -70,7 +70,8 @@ void PragmaDatabaseSizeFunction(ClientContext &context, const FunctionData *bind
 		auto free_blocks = block_manager.FreeBlocks();
 		auto used_blocks = total_blocks - free_blocks;
 		auto bytes = (total_blocks * block_size);
-		auto wal_size = storage.GetWriteAheadLog()->GetWALSize();
+		auto wal = storage.GetWriteAheadLog();
+		auto wal_size = wal ? wal->GetWALSize() : 0;
 		output.data[0].SetValue(0, Value(StringUtil::BytesToHumanReadableString(bytes)));
 		output.data[1].SetValue(0, Value::BIGINT(block_size));
 		output.data[2].SetValue(0, Value::BIGINT(total_blocks));
diff --git a/src/include/duckdb/function/scalar/nested_functions.hpp b/src/include/duckdb/function/scalar/nested_functions.hpp
index 3ba716020b74..46251d60cbfe 100644
--- a/src/include/duckdb/function/scalar/nested_functions.hpp
+++ b/src/include/duckdb/function/scalar/nested_functions.hpp
@@ -62,6 +62,16 @@ struct ListContainsFun {
 	static void RegisterFunction(BuiltinFunctions &set);
 };
 
+struct ListFlattenFun {
+	static ScalarFunction GetFunction();
+	static void RegisterFunction(BuiltinFunctions &set);
+};
+
+struct ListPositionFun {
+	static ScalarFunction GetFunction();
+	static void RegisterFunction(BuiltinFunctions &set);
+};
+
 struct CardinalityFun {
 	static void RegisterFunction(BuiltinFunctions &set);
 };
diff --git a/src/include/duckdb/main/client_context.hpp b/src/include/duckdb/main/client_context.hpp
index 09bf8bca26dc..c473c5effb44 100644
--- a/src/include/duckdb/main/client_context.hpp
+++ b/src/include/duckdb/main/client_context.hpp
@@ -261,4 +261,22 @@ class ClientContextLock {
 	lock_guard<mutex> client_guard;
 };
 
+class ClientContextWrapper {
+public:
+	DUCKDB_API explicit ClientContextWrapper(const shared_ptr<ClientContext> &context)
+	    : client_context(context) {
+
+	      };
+	shared_ptr<ClientContext> GetContext() {
+		auto actual_context = client_context.lock();
+		if (!actual_context) {
+			throw std::runtime_error("This connection is closed");
+		}
+		return actual_context;
+	}
+
+private:
+	std::weak_ptr<ClientContext> client_context;
+};
+
 } // namespace duckdb
diff --git a/src/include/duckdb/main/connection.hpp b/src/include/duckdb/main/connection.hpp
index e6e31aec2dd7..84a307f29ab9 100644
--- a/src/include/duckdb/main/connection.hpp
+++ b/src/include/duckdb/main/connection.hpp
@@ -25,6 +25,7 @@ namespace duckdb {
 
 class ChunkCollection;
 class ClientContext;
+
 class DatabaseInstance;
 class DuckDB;
 class LogicalOperator;
@@ -128,10 +129,10 @@ class Connection {
 	DUCKDB_API shared_ptr<Relation> ReadCSV(const string &csv_file);
 	DUCKDB_API shared_ptr<Relation> ReadCSV(const string &csv_file, const vector<string> &columns);
 	//! Returns a relation from a query
-	DUCKDB_API shared_ptr<Relation> RelationFromQuery(const string &query, string alias = "queryrelation",
+	DUCKDB_API shared_ptr<Relation> RelationFromQuery(const string &query, const string &alias = "queryrelation",
 	                                                  const string &error = "Expected a single SELECT statement");
 	DUCKDB_API shared_ptr<Relation> RelationFromQuery(unique_ptr<SelectStatement> select_stmt,
-	                                                  string alias = "queryrelation");
+	                                                  const string &alias = "queryrelation");
 
 	DUCKDB_API void BeginTransaction();
 	DUCKDB_API void Commit();
diff --git a/src/include/duckdb/main/relation.hpp b/src/include/duckdb/main/relation.hpp
index cc0582e59c97..5dfc481239ce 100644
--- a/src/include/duckdb/main/relation.hpp
+++ b/src/include/duckdb/main/relation.hpp
@@ -15,13 +15,14 @@
 #include "duckdb/main/query_result.hpp"
 #include "duckdb/parser/column_definition.hpp"
 #include "duckdb/common/named_parameter_map.hpp"
+#include "duckdb/main/client_context.hpp"
 
 #include <memory>
 
 namespace duckdb {
 struct BoundStatement;
 
-class ClientContext;
+class ClientContextWrapper;
 class Binder;
 class LogicalOperator;
 class QueryNode;
@@ -29,12 +30,16 @@ class TableRef;
 
 class Relation : public std::enable_shared_from_this<Relation> {
 public:
-	DUCKDB_API Relation(ClientContext &context, RelationType type) : context(context), type(type) {
+	DUCKDB_API Relation(const std::shared_ptr<ClientContext> &context, RelationType type)
+	    : context(context), type(type) {
+	}
+	DUCKDB_API Relation(ClientContextWrapper &context, RelationType type) : context(context.GetContext()), type(type) {
 	}
 	DUCKDB_API virtual ~Relation() {
 	}
 
-	ClientContext &context;
+	ClientContextWrapper context;
+
 	RelationType type;
 
 public:
diff --git a/src/include/duckdb/main/relation/delete_relation.hpp b/src/include/duckdb/main/relation/delete_relation.hpp
index 908b7135f551..2e0c6564c1a7 100644
--- a/src/include/duckdb/main/relation/delete_relation.hpp
+++ b/src/include/duckdb/main/relation/delete_relation.hpp
@@ -15,7 +15,7 @@ namespace duckdb {
 
 class DeleteRelation : public Relation {
 public:
-	DeleteRelation(ClientContext &context, unique_ptr<ParsedExpression> condition, string schema_name,
+	DeleteRelation(ClientContextWrapper &context, unique_ptr<ParsedExpression> condition, string schema_name,
 	               string table_name);
 
 	vector<ColumnDefinition> columns;
diff --git a/src/include/duckdb/main/relation/query_relation.hpp b/src/include/duckdb/main/relation/query_relation.hpp
index 3f2038ab2fdb..3a2728bf938f 100644
--- a/src/include/duckdb/main/relation/query_relation.hpp
+++ b/src/include/duckdb/main/relation/query_relation.hpp
@@ -16,7 +16,7 @@ class SelectStatement;
 
 class QueryRelation : public Relation {
 public:
-	QueryRelation(ClientContext &context, unique_ptr<SelectStatement> select_stmt, string alias);
+	QueryRelation(const std::shared_ptr<ClientContext> &context, unique_ptr<SelectStatement> select_stmt, string alias);
 	~QueryRelation();
 
 	unique_ptr<SelectStatement> select_stmt;
diff --git a/src/include/duckdb/main/relation/read_csv_relation.hpp b/src/include/duckdb/main/relation/read_csv_relation.hpp
index 2a036f0265e4..e3cf15fc5e3e 100644
--- a/src/include/duckdb/main/relation/read_csv_relation.hpp
+++ b/src/include/duckdb/main/relation/read_csv_relation.hpp
@@ -14,8 +14,8 @@ namespace duckdb {
 
 class ReadCSVRelation : public Relation {
 public:
-	ReadCSVRelation(ClientContext &context, string csv_file, vector<ColumnDefinition> columns, bool auto_detect = false,
-	                string alias = string());
+	ReadCSVRelation(const std::shared_ptr<ClientContext> &context, string csv_file, vector<ColumnDefinition> columns,
+	                bool auto_detect = false, string alias = string());
 
 	string csv_file;
 	bool auto_detect;
diff --git a/src/include/duckdb/main/relation/table_function_relation.hpp b/src/include/duckdb/main/relation/table_function_relation.hpp
index 08b75de12cc3..e780639b3eee 100644
--- a/src/include/duckdb/main/relation/table_function_relation.hpp
+++ b/src/include/duckdb/main/relation/table_function_relation.hpp
@@ -14,10 +14,10 @@ namespace duckdb {
 
 class TableFunctionRelation : public Relation {
 public:
-	TableFunctionRelation(ClientContext &context, string name, vector<Value> parameters,
+	TableFunctionRelation(const std::shared_ptr<ClientContext> &context, string name, vector<Value> parameters,
 	                      named_parameter_map_t named_parameters, shared_ptr<Relation> input_relation_p = nullptr);
 
-	TableFunctionRelation(ClientContext &context, string name, vector<Value> parameters,
+	TableFunctionRelation(const std::shared_ptr<ClientContext> &context, string name, vector<Value> parameters,
 	                      shared_ptr<Relation> input_relation_p = nullptr);
 
 	string name;
diff --git a/src/include/duckdb/main/relation/table_relation.hpp b/src/include/duckdb/main/relation/table_relation.hpp
index 45ed9bce02d4..77a950cebe89 100644
--- a/src/include/duckdb/main/relation/table_relation.hpp
+++ b/src/include/duckdb/main/relation/table_relation.hpp
@@ -15,7 +15,7 @@ namespace duckdb {
 
 class TableRelation : public Relation {
 public:
-	TableRelation(ClientContext &context, unique_ptr<TableDescription> description);
+	TableRelation(const std::shared_ptr<ClientContext> &context, unique_ptr<TableDescription> description);
 
 	unique_ptr<TableDescription> description;
 
diff --git a/src/include/duckdb/main/relation/update_relation.hpp b/src/include/duckdb/main/relation/update_relation.hpp
index b2d264b69df5..1cb14222218b 100644
--- a/src/include/duckdb/main/relation/update_relation.hpp
+++ b/src/include/duckdb/main/relation/update_relation.hpp
@@ -15,7 +15,7 @@ namespace duckdb {
 
 class UpdateRelation : public Relation {
 public:
-	UpdateRelation(ClientContext &context, unique_ptr<ParsedExpression> condition, string schema_name,
+	UpdateRelation(ClientContextWrapper &context, unique_ptr<ParsedExpression> condition, string schema_name,
 	               string table_name, vector<string> update_columns, vector<unique_ptr<ParsedExpression>> expressions);
 
 	vector<ColumnDefinition> columns;
diff --git a/src/include/duckdb/main/relation/value_relation.hpp b/src/include/duckdb/main/relation/value_relation.hpp
index f0f9d18a9da4..b8aa47c01a48 100644
--- a/src/include/duckdb/main/relation/value_relation.hpp
+++ b/src/include/duckdb/main/relation/value_relation.hpp
@@ -15,9 +15,10 @@ namespace duckdb {
 
 class ValueRelation : public Relation {
 public:
-	ValueRelation(ClientContext &context, const vector<vector<Value>> &values, vector<string> names,
+	ValueRelation(const std::shared_ptr<ClientContext> &context, const vector<vector<Value>> &values,
+	              vector<string> names, string alias = "values");
+	ValueRelation(const std::shared_ptr<ClientContext> &context, const string &values, vector<string> names,
 	              string alias = "values");
-	ValueRelation(ClientContext &context, const string &values, vector<string> names, string alias = "values");
 
 	vector<vector<unique_ptr<ParsedExpression>>> expressions;
 	vector<string> names;
diff --git a/src/include/duckdb/main/relation/view_relation.hpp b/src/include/duckdb/main/relation/view_relation.hpp
index b48faa913f39..8a8afa26071e 100644
--- a/src/include/duckdb/main/relation/view_relation.hpp
+++ b/src/include/duckdb/main/relation/view_relation.hpp
@@ -14,7 +14,7 @@ namespace duckdb {
 
 class ViewRelation : public Relation {
 public:
-	ViewRelation(ClientContext &context, string schema_name, string view_name);
+	ViewRelation(const std::shared_ptr<ClientContext> &context, string schema_name, string view_name);
 
 	string schema_name;
 	string view_name;
diff --git a/src/main/connection.cpp b/src/main/connection.cpp
index b2b1d8248c7b..6aabc2df020e 100644
--- a/src/main/connection.cpp
+++ b/src/main/connection.cpp
@@ -134,7 +134,7 @@ shared_ptr<Relation> Connection::Table(const string &schema_name, const string &
 	if (!table_info) {
 		throw Exception("Table does not exist!");
 	}
-	return make_shared<TableRelation>(*context, move(table_info));
+	return make_shared<TableRelation>(context, move(table_info));
 }
 
 shared_ptr<Relation> Connection::View(const string &tname) {
@@ -142,7 +142,7 @@ shared_ptr<Relation> Connection::View(const string &tname) {
 }
 
 shared_ptr<Relation> Connection::View(const string &schema_name, const string &table_name) {
-	return make_shared<ViewRelation>(*context, schema_name, table_name);
+	return make_shared<ViewRelation>(context, schema_name, table_name);
 }
 
 shared_ptr<Relation> Connection::TableFunction(const string &fname) {
@@ -153,11 +153,11 @@ shared_ptr<Relation> Connection::TableFunction(const string &fname) {
 
 shared_ptr<Relation> Connection::TableFunction(const string &fname, const vector<Value> &values,
                                                const named_parameter_map_t &named_parameters) {
-	return make_shared<TableFunctionRelation>(*context, fname, values, named_parameters);
+	return make_shared<TableFunctionRelation>(context, fname, values, named_parameters);
 }
 
 shared_ptr<Relation> Connection::TableFunction(const string &fname, const vector<Value> &values) {
-	return make_shared<TableFunctionRelation>(*context, fname, values);
+	return make_shared<TableFunctionRelation>(context, fname, values);
 }
 
 shared_ptr<Relation> Connection::Values(const vector<vector<Value>> &values) {
@@ -167,7 +167,7 @@ shared_ptr<Relation> Connection::Values(const vector<vector<Value>> &values) {
 
 shared_ptr<Relation> Connection::Values(const vector<vector<Value>> &values, const vector<string> &column_names,
                                         const string &alias) {
-	return make_shared<ValueRelation>(*context, values, column_names, alias);
+	return make_shared<ValueRelation>(context, values, column_names, alias);
 }
 
 shared_ptr<Relation> Connection::Values(const string &values) {
@@ -176,7 +176,7 @@ shared_ptr<Relation> Connection::Values(const string &values) {
 }
 
 shared_ptr<Relation> Connection::Values(const string &values, const vector<string> &column_names, const string &alias) {
-	return make_shared<ValueRelation>(*context, values, column_names, alias);
+	return make_shared<ValueRelation>(context, values, column_names, alias);
 }
 
 shared_ptr<Relation> Connection::ReadCSV(const string &csv_file) {
@@ -188,7 +188,7 @@ shared_ptr<Relation> Connection::ReadCSV(const string &csv_file) {
 	for (idx_t i = 0; i < reader.sql_types.size(); i++) {
 		column_list.emplace_back(reader.col_names[i], reader.sql_types[i]);
 	}
-	return make_shared<ReadCSVRelation>(*context, csv_file, move(column_list), true);
+	return make_shared<ReadCSVRelation>(context, csv_file, move(column_list), true);
 }
 
 shared_ptr<Relation> Connection::ReadCSV(const string &csv_file, const vector<string> &columns) {
@@ -201,19 +201,19 @@ shared_ptr<Relation> Connection::ReadCSV(const string &csv_file, const vector<st
 		}
 		column_list.push_back(move(col_list[0]));
 	}
-	return make_shared<ReadCSVRelation>(*context, csv_file, move(column_list));
+	return make_shared<ReadCSVRelation>(context, csv_file, move(column_list));
 }
 
 unordered_set<string> Connection::GetTableNames(const string &query) {
 	return context->GetTableNames(query);
 }
 
-shared_ptr<Relation> Connection::RelationFromQuery(const string &query, string alias, const string &error) {
-	return RelationFromQuery(QueryRelation::ParseStatement(*context, query, error), move(alias));
+shared_ptr<Relation> Connection::RelationFromQuery(const string &query, const string &alias, const string &error) {
+	return RelationFromQuery(QueryRelation::ParseStatement(*context, query, error), alias);
 }
 
-shared_ptr<Relation> Connection::RelationFromQuery(unique_ptr<SelectStatement> select_stmt, string alias) {
-	return make_shared<QueryRelation>(*context, move(select_stmt), move(alias));
+shared_ptr<Relation> Connection::RelationFromQuery(unique_ptr<SelectStatement> select_stmt, const string &alias) {
+	return make_shared<QueryRelation>(context, move(select_stmt), alias);
 }
 
 void Connection::BeginTransaction() {
diff --git a/src/main/relation.cpp b/src/main/relation.cpp
index b87263a9337d..0e217cf12ae0 100644
--- a/src/main/relation.cpp
+++ b/src/main/relation.cpp
@@ -36,7 +36,7 @@ shared_ptr<Relation> Relation::Project(const string &expression, const string &a
 }
 
 shared_ptr<Relation> Relation::Project(const string &select_list, const vector<string> &aliases) {
-	auto expressions = Parser::ParseExpressionList(select_list, context.GetParserOptions());
+	auto expressions = Parser::ParseExpressionList(select_list, context.GetContext()->GetParserOptions());
 	return make_shared<ProjectionRelation>(shared_from_this(), move(expressions), aliases);
 }
 
@@ -62,12 +62,12 @@ static vector<unique_ptr<ParsedExpression>> StringListToExpressionList(ClientCon
 }
 
 shared_ptr<Relation> Relation::Project(const vector<string> &expressions, const vector<string> &aliases) {
-	auto result_list = StringListToExpressionList(context, expressions);
+	auto result_list = StringListToExpressionList(*context.GetContext(), expressions);
 	return make_shared<ProjectionRelation>(shared_from_this(), move(result_list), aliases);
 }
 
 shared_ptr<Relation> Relation::Filter(const string &expression) {
-	auto expression_list = Parser::ParseExpressionList(expression, context.GetParserOptions());
+	auto expression_list = Parser::ParseExpressionList(expression, context.GetContext()->GetParserOptions());
 	if (expression_list.size() != 1) {
 		throw ParserException("Expected a single expression as filter condition");
 	}
@@ -76,7 +76,7 @@ shared_ptr<Relation> Relation::Filter(const string &expression) {
 
 shared_ptr<Relation> Relation::Filter(const vector<string> &expressions) {
 	// if there are multiple expressions, we AND them together
-	auto expression_list = StringListToExpressionList(context, expressions);
+	auto expression_list = StringListToExpressionList(*context.GetContext(), expressions);
 	D_ASSERT(!expression_list.empty());
 
 	auto expr = move(expression_list[0]);
@@ -92,7 +92,7 @@ shared_ptr<Relation> Relation::Limit(int64_t limit, int64_t offset) {
 }
 
 shared_ptr<Relation> Relation::Order(const string &expression) {
-	auto order_list = Parser::ParseOrderList(expression, context.GetParserOptions());
+	auto order_list = Parser::ParseOrderList(expression, context.GetContext()->GetParserOptions());
 	return make_shared<OrderRelation>(shared_from_this(), move(order_list));
 }
 
@@ -102,7 +102,7 @@ shared_ptr<Relation> Relation::Order(const vector<string> &expressions) {
 	}
 	vector<OrderByNode> order_list;
 	for (auto &expression : expressions) {
-		auto inner_list = Parser::ParseOrderList(expression, context.GetParserOptions());
+		auto inner_list = Parser::ParseOrderList(expression, context.GetContext()->GetParserOptions());
 		if (inner_list.size() != 1) {
 			throw ParserException("Expected a single ORDER BY expression in the expression list");
 		}
@@ -112,7 +112,7 @@ shared_ptr<Relation> Relation::Order(const vector<string> &expressions) {
 }
 
 shared_ptr<Relation> Relation::Join(const shared_ptr<Relation> &other, const string &condition, JoinType type) {
-	auto expression_list = Parser::ParseExpressionList(condition, context.GetParserOptions());
+	auto expression_list = Parser::ParseExpressionList(condition, context.GetContext()->GetParserOptions());
 	D_ASSERT(!expression_list.empty());
 
 	if (expression_list.size() > 1 || expression_list[0]->type == ExpressionType::COLUMN_REF) {
@@ -160,24 +160,24 @@ shared_ptr<Relation> Relation::Alias(const string &alias) {
 }
 
 shared_ptr<Relation> Relation::Aggregate(const string &aggregate_list) {
-	auto expression_list = Parser::ParseExpressionList(aggregate_list, context.GetParserOptions());
+	auto expression_list = Parser::ParseExpressionList(aggregate_list, context.GetContext()->GetParserOptions());
 	return make_shared<AggregateRelation>(shared_from_this(), move(expression_list));
 }
 
 shared_ptr<Relation> Relation::Aggregate(const string &aggregate_list, const string &group_list) {
-	auto expression_list = Parser::ParseExpressionList(aggregate_list, context.GetParserOptions());
-	auto groups = Parser::ParseExpressionList(group_list, context.GetParserOptions());
+	auto expression_list = Parser::ParseExpressionList(aggregate_list, context.GetContext()->GetParserOptions());
+	auto groups = Parser::ParseExpressionList(group_list, context.GetContext()->GetParserOptions());
 	return make_shared<AggregateRelation>(shared_from_this(), move(expression_list), move(groups));
 }
 
 shared_ptr<Relation> Relation::Aggregate(const vector<string> &aggregates) {
-	auto aggregate_list = StringListToExpressionList(context, aggregates);
+	auto aggregate_list = StringListToExpressionList(*context.GetContext(), aggregates);
 	return make_shared<AggregateRelation>(shared_from_this(), move(aggregate_list));
 }
 
 shared_ptr<Relation> Relation::Aggregate(const vector<string> &aggregates, const vector<string> &groups) {
-	auto aggregate_list = StringListToExpressionList(context, aggregates);
-	auto group_list = StringListToExpressionList(context, groups);
+	auto aggregate_list = StringListToExpressionList(*context.GetContext(), aggregates);
+	auto group_list = StringListToExpressionList(*context.GetContext(), groups);
 	return make_shared<AggregateRelation>(shared_from_this(), move(aggregate_list), move(group_list));
 }
 
@@ -192,7 +192,7 @@ unique_ptr<TableRef> Relation::GetTableRef() {
 }
 
 unique_ptr<QueryResult> Relation::Execute() {
-	return context.Execute(shared_from_this());
+	return context.GetContext()->Execute(shared_from_this());
 }
 
 BoundStatement Relation::Bind(Binder &binder) {
@@ -215,7 +215,7 @@ void Relation::Insert(const string &schema_name, const string &table_name) {
 
 void Relation::Insert(const vector<vector<Value>> &values) {
 	vector<string> column_names;
-	auto rel = make_shared<ValueRelation>(context, values, move(column_names), "values");
+	auto rel = make_shared<ValueRelation>(context.GetContext(), values, move(column_names), "values");
 	rel->Insert(GetAlias());
 }
 
@@ -249,7 +249,7 @@ shared_ptr<Relation> Relation::CreateView(const string &name, bool replace, bool
 }
 
 unique_ptr<QueryResult> Relation::Query(const string &sql) {
-	return context.Query(sql, false);
+	return context.GetContext()->Query(sql, false);
 }
 
 unique_ptr<QueryResult> Relation::Query(const string &name, const string &sql) {
@@ -272,11 +272,12 @@ void Relation::Delete(const string &condition) {
 
 shared_ptr<Relation> Relation::TableFunction(const std::string &fname, const vector<Value> &values,
                                              const named_parameter_map_t &named_parameters) {
-	return make_shared<TableFunctionRelation>(context, fname, values, named_parameters, shared_from_this());
+	return make_shared<TableFunctionRelation>(context.GetContext(), fname, values, named_parameters,
+	                                          shared_from_this());
 }
 
 shared_ptr<Relation> Relation::TableFunction(const std::string &fname, const vector<Value> &values) {
-	return make_shared<TableFunctionRelation>(context, fname, values, shared_from_this());
+	return make_shared<TableFunctionRelation>(context.GetContext(), fname, values, shared_from_this());
 }
 
 string Relation::ToString() {
diff --git a/src/main/relation/aggregate_relation.cpp b/src/main/relation/aggregate_relation.cpp
index e48f9caa3b47..67f989cda5cb 100644
--- a/src/main/relation/aggregate_relation.cpp
+++ b/src/main/relation/aggregate_relation.cpp
@@ -10,7 +10,7 @@ AggregateRelation::AggregateRelation(shared_ptr<Relation> child_p,
     : Relation(child_p->context, RelationType::AGGREGATE_RELATION), expressions(move(parsed_expressions)),
       child(move(child_p)) {
 	// bind the expressions
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 AggregateRelation::AggregateRelation(shared_ptr<Relation> child_p,
@@ -19,7 +19,7 @@ AggregateRelation::AggregateRelation(shared_ptr<Relation> child_p,
     : Relation(child_p->context, RelationType::AGGREGATE_RELATION), expressions(move(parsed_expressions)),
       groups(move(groups_p)), child(move(child_p)) {
 	// bind the expressions
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 unique_ptr<QueryNode> AggregateRelation::GetQueryNode() {
diff --git a/src/main/relation/create_table_relation.cpp b/src/main/relation/create_table_relation.cpp
index 9c4a776264f9..6287ff34501b 100644
--- a/src/main/relation/create_table_relation.cpp
+++ b/src/main/relation/create_table_relation.cpp
@@ -10,7 +10,7 @@ namespace duckdb {
 CreateTableRelation::CreateTableRelation(shared_ptr<Relation> child_p, string schema_name, string table_name)
     : Relation(child_p->context, RelationType::CREATE_TABLE_RELATION), child(move(child_p)),
       schema_name(move(schema_name)), table_name(move(table_name)) {
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 BoundStatement CreateTableRelation::Bind(Binder &binder) {
diff --git a/src/main/relation/create_view_relation.cpp b/src/main/relation/create_view_relation.cpp
index 37fcb7e90d73..8afd8279c96d 100644
--- a/src/main/relation/create_view_relation.cpp
+++ b/src/main/relation/create_view_relation.cpp
@@ -10,7 +10,7 @@ CreateViewRelation::CreateViewRelation(shared_ptr<Relation> child_p, string view
                                        bool temporary_p)
     : Relation(child_p->context, RelationType::CREATE_VIEW_RELATION), child(move(child_p)),
       view_name(move(view_name_p)), replace(replace_p), temporary(temporary_p) {
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 BoundStatement CreateViewRelation::Bind(Binder &binder) {
diff --git a/src/main/relation/cross_product_relation.cpp b/src/main/relation/cross_product_relation.cpp
index 9262f07a13a6..9eb048db1cce 100644
--- a/src/main/relation/cross_product_relation.cpp
+++ b/src/main/relation/cross_product_relation.cpp
@@ -8,10 +8,10 @@ namespace duckdb {
 
 CrossProductRelation::CrossProductRelation(shared_ptr<Relation> left_p, shared_ptr<Relation> right_p)
     : Relation(left_p->context, RelationType::CROSS_PRODUCT_RELATION), left(move(left_p)), right(move(right_p)) {
-	if (&left->context != &right->context) {
+	if (left->context.GetContext() != right->context.GetContext()) {
 		throw Exception("Cannot combine LEFT and RIGHT relations of different connections!");
 	}
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 unique_ptr<QueryNode> CrossProductRelation::GetQueryNode() {
diff --git a/src/main/relation/delete_relation.cpp b/src/main/relation/delete_relation.cpp
index 55616a1e6ee0..98ab1bfb3411 100644
--- a/src/main/relation/delete_relation.cpp
+++ b/src/main/relation/delete_relation.cpp
@@ -6,11 +6,11 @@
 
 namespace duckdb {
 
-DeleteRelation::DeleteRelation(ClientContext &context, unique_ptr<ParsedExpression> condition_p, string schema_name_p,
-                               string table_name_p)
+DeleteRelation::DeleteRelation(ClientContextWrapper &context, unique_ptr<ParsedExpression> condition_p,
+                               string schema_name_p, string table_name_p)
     : Relation(context, RelationType::DELETE_RELATION), condition(move(condition_p)), schema_name(move(schema_name_p)),
       table_name(move(table_name_p)) {
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 BoundStatement DeleteRelation::Bind(Binder &binder) {
diff --git a/src/main/relation/distinct_relation.cpp b/src/main/relation/distinct_relation.cpp
index ce5655365b94..24970e4786f7 100644
--- a/src/main/relation/distinct_relation.cpp
+++ b/src/main/relation/distinct_relation.cpp
@@ -7,7 +7,7 @@ namespace duckdb {
 DistinctRelation::DistinctRelation(shared_ptr<Relation> child_p)
     : Relation(child_p->context, RelationType::DISTINCT_RELATION), child(move(child_p)) {
 	vector<ColumnDefinition> dummy_columns;
-	context.TryBindRelation(*this, dummy_columns);
+	context.GetContext()->TryBindRelation(*this, dummy_columns);
 }
 
 unique_ptr<QueryNode> DistinctRelation::GetQueryNode() {
diff --git a/src/main/relation/explain_relation.cpp b/src/main/relation/explain_relation.cpp
index 137dbeaf73ac..90365d7da314 100644
--- a/src/main/relation/explain_relation.cpp
+++ b/src/main/relation/explain_relation.cpp
@@ -9,7 +9,7 @@ namespace duckdb {
 
 ExplainRelation::ExplainRelation(shared_ptr<Relation> child_p)
     : Relation(child_p->context, RelationType::EXPLAIN_RELATION), child(move(child_p)) {
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 BoundStatement ExplainRelation::Bind(Binder &binder) {
diff --git a/src/main/relation/filter_relation.cpp b/src/main/relation/filter_relation.cpp
index 5beb296709c0..f1c757b5edda 100644
--- a/src/main/relation/filter_relation.cpp
+++ b/src/main/relation/filter_relation.cpp
@@ -10,7 +10,7 @@ namespace duckdb {
 FilterRelation::FilterRelation(shared_ptr<Relation> child_p, unique_ptr<ParsedExpression> condition_p)
     : Relation(child_p->context, RelationType::FILTER_RELATION), condition(move(condition_p)), child(move(child_p)) {
 	vector<ColumnDefinition> dummy_columns;
-	context.TryBindRelation(*this, dummy_columns);
+	context.GetContext()->TryBindRelation(*this, dummy_columns);
 }
 
 unique_ptr<QueryNode> FilterRelation::GetQueryNode() {
diff --git a/src/main/relation/insert_relation.cpp b/src/main/relation/insert_relation.cpp
index a96efef3c036..78d876ea50e1 100644
--- a/src/main/relation/insert_relation.cpp
+++ b/src/main/relation/insert_relation.cpp
@@ -10,7 +10,7 @@ namespace duckdb {
 InsertRelation::InsertRelation(shared_ptr<Relation> child_p, string schema_name, string table_name)
     : Relation(child_p->context, RelationType::INSERT_RELATION), child(move(child_p)), schema_name(move(schema_name)),
       table_name(move(table_name)) {
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 BoundStatement InsertRelation::Bind(Binder &binder) {
diff --git a/src/main/relation/join_relation.cpp b/src/main/relation/join_relation.cpp
index 4d50fa72559a..abc59e8e3f95 100644
--- a/src/main/relation/join_relation.cpp
+++ b/src/main/relation/join_relation.cpp
@@ -10,20 +10,20 @@ JoinRelation::JoinRelation(shared_ptr<Relation> left_p, shared_ptr<Relation> rig
                            unique_ptr<ParsedExpression> condition_p, JoinType type)
     : Relation(left_p->context, RelationType::JOIN_RELATION), left(move(left_p)), right(move(right_p)),
       condition(move(condition_p)), join_type(type) {
-	if (&left->context != &right->context) {
+	if (left->context.GetContext() != right->context.GetContext()) {
 		throw Exception("Cannot combine LEFT and RIGHT relations of different connections!");
 	}
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 JoinRelation::JoinRelation(shared_ptr<Relation> left_p, shared_ptr<Relation> right_p, vector<string> using_columns_p,
                            JoinType type)
     : Relation(left_p->context, RelationType::JOIN_RELATION), left(move(left_p)), right(move(right_p)),
       using_columns(move(using_columns_p)), join_type(type) {
-	if (&left->context != &right->context) {
+	if (left->context.GetContext() != right->context.GetContext()) {
 		throw Exception("Cannot combine LEFT and RIGHT relations of different connections!");
 	}
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 unique_ptr<QueryNode> JoinRelation::GetQueryNode() {
diff --git a/src/main/relation/order_relation.cpp b/src/main/relation/order_relation.cpp
index 884b4ed98e87..19c8697cb84b 100644
--- a/src/main/relation/order_relation.cpp
+++ b/src/main/relation/order_relation.cpp
@@ -8,7 +8,7 @@ OrderRelation::OrderRelation(shared_ptr<Relation> child_p, vector<OrderByNode> o
     : Relation(child_p->context, RelationType::ORDER_RELATION), orders(move(orders)), child(move(child_p)) {
 	// bind the expressions
 	vector<ColumnDefinition> dummy_columns;
-	context.TryBindRelation(*this, dummy_columns);
+	context.GetContext()->TryBindRelation(*this, dummy_columns);
 }
 
 unique_ptr<QueryNode> OrderRelation::GetQueryNode() {
diff --git a/src/main/relation/projection_relation.cpp b/src/main/relation/projection_relation.cpp
index ce4a8bbc3b64..eca2fc308f1e 100644
--- a/src/main/relation/projection_relation.cpp
+++ b/src/main/relation/projection_relation.cpp
@@ -18,7 +18,7 @@ ProjectionRelation::ProjectionRelation(shared_ptr<Relation> child_p,
 		}
 	}
 	// bind the expressions
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 unique_ptr<QueryNode> ProjectionRelation::GetQueryNode() {
diff --git a/src/main/relation/query_relation.cpp b/src/main/relation/query_relation.cpp
index b7065cac3d98..b3b94257c830 100644
--- a/src/main/relation/query_relation.cpp
+++ b/src/main/relation/query_relation.cpp
@@ -6,9 +6,10 @@
 
 namespace duckdb {
 
-QueryRelation::QueryRelation(ClientContext &context, unique_ptr<SelectStatement> select_stmt_p, string alias_p)
+QueryRelation::QueryRelation(const std::shared_ptr<ClientContext> &context, unique_ptr<SelectStatement> select_stmt_p,
+                             string alias_p)
     : Relation(context, RelationType::QUERY_RELATION), select_stmt(move(select_stmt_p)), alias(move(alias_p)) {
-	context.TryBindRelation(*this, this->columns);
+	context->TryBindRelation(*this, this->columns);
 }
 
 QueryRelation::~QueryRelation() {
diff --git a/src/main/relation/read_csv_relation.cpp b/src/main/relation/read_csv_relation.cpp
index 6cbd9a85a0ae..7c2fc2b0c585 100644
--- a/src/main/relation/read_csv_relation.cpp
+++ b/src/main/relation/read_csv_relation.cpp
@@ -11,8 +11,8 @@
 
 namespace duckdb {
 
-ReadCSVRelation::ReadCSVRelation(ClientContext &context, string csv_file_p, vector<ColumnDefinition> columns_p,
-                                 bool auto_detect, string alias_p)
+ReadCSVRelation::ReadCSVRelation(const std::shared_ptr<ClientContext> &context, string csv_file_p,
+                                 vector<ColumnDefinition> columns_p, bool auto_detect, string alias_p)
     : Relation(context, RelationType::READ_CSV_RELATION), csv_file(move(csv_file_p)), auto_detect(auto_detect),
       alias(move(alias_p)), columns(move(columns_p)) {
 	if (alias.empty()) {
diff --git a/src/main/relation/setop_relation.cpp b/src/main/relation/setop_relation.cpp
index a49ebf77c605..1cc228fc2820 100644
--- a/src/main/relation/setop_relation.cpp
+++ b/src/main/relation/setop_relation.cpp
@@ -7,11 +7,11 @@ namespace duckdb {
 SetOpRelation::SetOpRelation(shared_ptr<Relation> left_p, shared_ptr<Relation> right_p, SetOperationType setop_type_p)
     : Relation(left_p->context, RelationType::SET_OPERATION_RELATION), left(move(left_p)), right(move(right_p)),
       setop_type(setop_type_p) {
-	if (&left->context != &right->context) {
+	if (left->context.GetContext() != right->context.GetContext()) {
 		throw Exception("Cannot combine LEFT and RIGHT relations of different connections!");
 	}
 	vector<ColumnDefinition> dummy_columns;
-	context.TryBindRelation(*this, dummy_columns);
+	context.GetContext()->TryBindRelation(*this, dummy_columns);
 }
 
 unique_ptr<QueryNode> SetOpRelation::GetQueryNode() {
diff --git a/src/main/relation/subquery_relation.cpp b/src/main/relation/subquery_relation.cpp
index f5087149883a..7fc0576b199b 100644
--- a/src/main/relation/subquery_relation.cpp
+++ b/src/main/relation/subquery_relation.cpp
@@ -7,7 +7,7 @@ namespace duckdb {
 SubqueryRelation::SubqueryRelation(shared_ptr<Relation> child_p, string alias_p)
     : Relation(child_p->context, RelationType::SUBQUERY_RELATION), child(move(child_p)), alias(move(alias_p)) {
 	vector<ColumnDefinition> dummy_columns;
-	context.TryBindRelation(*this, dummy_columns);
+	context.GetContext()->TryBindRelation(*this, dummy_columns);
 }
 
 unique_ptr<QueryNode> SubqueryRelation::GetQueryNode() {
diff --git a/src/main/relation/table_function_relation.cpp b/src/main/relation/table_function_relation.cpp
index 288ef1b74ac4..17b57a8cfd85 100644
--- a/src/main/relation/table_function_relation.cpp
+++ b/src/main/relation/table_function_relation.cpp
@@ -12,19 +12,20 @@
 
 namespace duckdb {
 
-TableFunctionRelation::TableFunctionRelation(ClientContext &context, string name_p, vector<Value> parameters_p,
-                                             named_parameter_map_t named_parameters,
+TableFunctionRelation::TableFunctionRelation(const std::shared_ptr<ClientContext> &context, string name_p,
+                                             vector<Value> parameters_p, named_parameter_map_t named_parameters,
                                              shared_ptr<Relation> input_relation_p)
     : Relation(context, RelationType::TABLE_FUNCTION_RELATION), name(move(name_p)), parameters(move(parameters_p)),
       named_parameters(move(named_parameters)), input_relation(move(input_relation_p)) {
-	context.TryBindRelation(*this, this->columns);
+	context->TryBindRelation(*this, this->columns);
 }
-TableFunctionRelation::TableFunctionRelation(ClientContext &context, string name_p, vector<Value> parameters_p,
+TableFunctionRelation::TableFunctionRelation(const std::shared_ptr<ClientContext> &context, string name_p,
+                                             vector<Value> parameters_p,
 
                                              shared_ptr<Relation> input_relation_p)
     : Relation(context, RelationType::TABLE_FUNCTION_RELATION), name(move(name_p)), parameters(move(parameters_p)),
       input_relation(move(input_relation_p)) {
-	context.TryBindRelation(*this, this->columns);
+	context->TryBindRelation(*this, this->columns);
 }
 
 unique_ptr<QueryNode> TableFunctionRelation::GetQueryNode() {
diff --git a/src/main/relation/table_relation.cpp b/src/main/relation/table_relation.cpp
index 8a4df5743297..d17e319c1ee8 100644
--- a/src/main/relation/table_relation.cpp
+++ b/src/main/relation/table_relation.cpp
@@ -9,7 +9,7 @@
 
 namespace duckdb {
 
-TableRelation::TableRelation(ClientContext &context, unique_ptr<TableDescription> description)
+TableRelation::TableRelation(const std::shared_ptr<ClientContext> &context, unique_ptr<TableDescription> description)
     : Relation(context, RelationType::TABLE_RELATION), description(move(description)) {
 }
 
@@ -54,15 +54,15 @@ static unique_ptr<ParsedExpression> ParseCondition(ClientContext &context, const
 void TableRelation::Update(const string &update_list, const string &condition) {
 	vector<string> update_columns;
 	vector<unique_ptr<ParsedExpression>> expressions;
-	auto cond = ParseCondition(context, condition);
-	Parser::ParseUpdateList(update_list, update_columns, expressions, context.GetParserOptions());
+	auto cond = ParseCondition(*context.GetContext(), condition);
+	Parser::ParseUpdateList(update_list, update_columns, expressions, context.GetContext()->GetParserOptions());
 	auto update = make_shared<UpdateRelation>(context, move(cond), description->schema, description->table,
 	                                          move(update_columns), move(expressions));
 	update->Execute();
 }
 
 void TableRelation::Delete(const string &condition) {
-	auto cond = ParseCondition(context, condition);
+	auto cond = ParseCondition(*context.GetContext(), condition);
 	auto del = make_shared<DeleteRelation>(context, move(cond), description->schema, description->table);
 	del->Execute();
 }
diff --git a/src/main/relation/update_relation.cpp b/src/main/relation/update_relation.cpp
index cf4abf29caf8..c1ab90154801 100644
--- a/src/main/relation/update_relation.cpp
+++ b/src/main/relation/update_relation.cpp
@@ -6,13 +6,13 @@
 
 namespace duckdb {
 
-UpdateRelation::UpdateRelation(ClientContext &context, unique_ptr<ParsedExpression> condition_p, string schema_name_p,
-                               string table_name_p, vector<string> update_columns_p,
+UpdateRelation::UpdateRelation(ClientContextWrapper &context, unique_ptr<ParsedExpression> condition_p,
+                               string schema_name_p, string table_name_p, vector<string> update_columns_p,
                                vector<unique_ptr<ParsedExpression>> expressions_p)
     : Relation(context, RelationType::UPDATE_RELATION), condition(move(condition_p)), schema_name(move(schema_name_p)),
       table_name(move(table_name_p)), update_columns(move(update_columns_p)), expressions(move(expressions_p)) {
 	D_ASSERT(update_columns.size() == expressions.size());
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 BoundStatement UpdateRelation::Bind(Binder &binder) {
diff --git a/src/main/relation/value_relation.cpp b/src/main/relation/value_relation.cpp
index 138f9bf4438c..71f82055211e 100644
--- a/src/main/relation/value_relation.cpp
+++ b/src/main/relation/value_relation.cpp
@@ -8,8 +8,8 @@
 
 namespace duckdb {
 
-ValueRelation::ValueRelation(ClientContext &context, const vector<vector<Value>> &values, vector<string> names_p,
-                             string alias_p)
+ValueRelation::ValueRelation(const std::shared_ptr<ClientContext> &context, const vector<vector<Value>> &values,
+                             vector<string> names_p, string alias_p)
     : Relation(context, RelationType::VALUE_LIST_RELATION), names(move(names_p)), alias(move(alias_p)) {
 	// create constant expressions for the values
 	for (idx_t row_idx = 0; row_idx < values.size(); row_idx++) {
@@ -20,13 +20,14 @@ ValueRelation::ValueRelation(ClientContext &context, const vector<vector<Value>>
 		}
 		this->expressions.push_back(move(expressions));
 	}
-	context.TryBindRelation(*this, this->columns);
+	context->TryBindRelation(*this, this->columns);
 }
 
-ValueRelation::ValueRelation(ClientContext &context, const string &values_list, vector<string> names_p, string alias_p)
+ValueRelation::ValueRelation(const std::shared_ptr<ClientContext> &context, const string &values_list,
+                             vector<string> names_p, string alias_p)
     : Relation(context, RelationType::VALUE_LIST_RELATION), names(move(names_p)), alias(move(alias_p)) {
-	this->expressions = Parser::ParseValuesList(values_list, context.GetParserOptions());
-	context.TryBindRelation(*this, this->columns);
+	this->expressions = Parser::ParseValuesList(values_list, context->GetParserOptions());
+	context->TryBindRelation(*this, this->columns);
 }
 
 unique_ptr<QueryNode> ValueRelation::GetQueryNode() {
diff --git a/src/main/relation/view_relation.cpp b/src/main/relation/view_relation.cpp
index d25d5e855023..ad4b3d3aa0f5 100644
--- a/src/main/relation/view_relation.cpp
+++ b/src/main/relation/view_relation.cpp
@@ -7,9 +7,9 @@
 
 namespace duckdb {
 
-ViewRelation::ViewRelation(ClientContext &context, string schema_name_p, string view_name_p)
+ViewRelation::ViewRelation(const std::shared_ptr<ClientContext> &context, string schema_name_p, string view_name_p)
     : Relation(context, RelationType::VIEW_RELATION), schema_name(move(schema_name_p)), view_name(move(view_name_p)) {
-	context.TryBindRelation(*this, this->columns);
+	context->TryBindRelation(*this, this->columns);
 }
 
 unique_ptr<QueryNode> ViewRelation::GetQueryNode() {
diff --git a/src/main/relation/write_csv_relation.cpp b/src/main/relation/write_csv_relation.cpp
index c7e56186b956..897c3be4dc0e 100644
--- a/src/main/relation/write_csv_relation.cpp
+++ b/src/main/relation/write_csv_relation.cpp
@@ -8,7 +8,7 @@ namespace duckdb {
 
 WriteCSVRelation::WriteCSVRelation(shared_ptr<Relation> child_p, string csv_file_p)
     : Relation(child_p->context, RelationType::WRITE_CSV_RELATION), child(move(child_p)), csv_file(move(csv_file_p)) {
-	context.TryBindRelation(*this, this->columns);
+	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
 BoundStatement WriteCSVRelation::Bind(Binder &binder) {
diff --git a/src/parser/transform/statement/transform_show.cpp b/src/parser/transform/statement/transform_show.cpp
index bb171d96e229..868dd3499d96 100644
--- a/src/parser/transform/statement/transform_show.cpp
+++ b/src/parser/transform/statement/transform_show.cpp
@@ -29,9 +29,12 @@ unique_ptr<SQLStatement> Transformer::TransformShow(duckdb_libpgquery::PGNode *n
 	auto result = make_unique<PragmaStatement>();
 	auto &info = *result->info;
 
-	if (string(stmt->name) == "tables") {
+	string name = stmt->name;
+	if (name == "tables") {
 		// show all tables
 		info.name = "show_tables";
+	} else if (name == "__show_tables_expanded") {
+		info.name = "show_tables_expanded";
 	} else {
 		// show one specific table
 		info.name = "show";
diff --git a/src/planner/binder/expression/bind_unnest_expression.cpp b/src/planner/binder/expression/bind_unnest_expression.cpp
index bb7a24fd6313..c88f94094add 100644
--- a/src/planner/binder/expression/bind_unnest_expression.cpp
+++ b/src/planner/binder/expression/bind_unnest_expression.cpp
@@ -29,13 +29,19 @@ BindResult SelectBinder::BindUnnest(FunctionExpression &function, idx_t depth) {
 	}
 	auto &child = (BoundExpression &)*function.children[0];
 	auto &child_type = child.expr->return_type;
-	if (child_type.id() != LogicalTypeId::LIST) {
-		return BindResult(binder.FormatError(function, "Unnest() can only be applied to lists"));
+
+	if (child_type.id() != LogicalTypeId::LIST && child_type.id() != LogicalTypeId::SQLNULL) {
+		return BindResult(binder.FormatError(function, "Unnest() can only be applied to lists and NULL"));
 	}
+
 	if (depth > 0) {
 		throw BinderException(binder.FormatError(function, "Unnest() for correlated expressions is not supported yet"));
 	}
-	auto &return_type = ListType::GetChildType(child_type);
+
+	auto return_type = LogicalType(LogicalTypeId::SQLNULL);
+	if (child_type.id() == LogicalTypeId::LIST) {
+		return_type = ListType::GetChildType(child_type);
+	}
 
 	auto result = make_unique<BoundUnnestExpression>(return_type);
 	result->child = move(child.expr);
@@ -49,6 +55,7 @@ BindResult SelectBinder::BindUnnest(FunctionExpression &function, idx_t depth) {
 	auto colref = make_unique<BoundColumnRefExpression>(
 	    function.alias.empty() ? node.unnests[unnest_index]->ToString() : function.alias, return_type,
 	    ColumnBinding(node.unnest_index, unnest_index), depth);
+
 	return BindResult(move(colref));
 }
 
diff --git a/third_party/libpg_query/grammar/statements/variable_show.y b/third_party/libpg_query/grammar/statements/variable_show.y
index 783a4ce5a894..a9899bcb69db 100644
--- a/third_party/libpg_query/grammar/statements/variable_show.y
+++ b/third_party/libpg_query/grammar/statements/variable_show.y
@@ -45,11 +45,17 @@ VariableShowStmt:
 		| show_or_describe ALL
 			{
 				PGVariableShowStmt *n = makeNode(PGVariableShowStmt);
-				n->name = (char*) "all";
+				n->name = (char*) "__show_tables_expanded";
+				n->is_summary = 0;
+				$$ = (PGNode *) n;
+			}
+		| show_or_describe
+			{
+				PGVariableShowStmt *n = makeNode(PGVariableShowStmt);
+				n->name = (char*) "__show_tables_expanded";
 				n->is_summary = 0;
 				$$ = (PGNode *) n;
 			}
-
 		;
 
 show_or_describe: SHOW | DESCRIBE
diff --git a/third_party/libpg_query/include/pg_functions.hpp b/third_party/libpg_query/include/pg_functions.hpp
index 71b6cb5d7ac0..32b97359a046 100644
--- a/third_party/libpg_query/include/pg_functions.hpp
+++ b/third_party/libpg_query/include/pg_functions.hpp
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <stdlib.h>
+#include <string>
 
 #include "pg_definitions.hpp"
 
@@ -13,7 +14,7 @@ typedef struct parse_result_str parse_result;
 struct parse_result_str {
 	bool success;
 	PGList *parse_tree;
-	char *error_message;
+	std::string error_message;
 	int error_location;
 };
 
diff --git a/third_party/libpg_query/pg_functions.cpp b/third_party/libpg_query/pg_functions.cpp
index 7d5392da86fb..15d263acc2ac 100644
--- a/third_party/libpg_query/pg_functions.cpp
+++ b/third_party/libpg_query/pg_functions.cpp
@@ -36,6 +36,7 @@ static void allocate_new(parser_state *state, size_t n) {
 	if (state->malloc_ptr_idx >= state->malloc_ptr_size) {
 		size_t new_size = state->malloc_ptr_size * 2;
 		auto new_malloc_ptrs = (char **) malloc(sizeof(char *) * new_size);
+		memset(new_malloc_ptrs, 0, sizeof(char*) * new_size);
 		memcpy(new_malloc_ptrs, state->malloc_ptrs, state->malloc_ptr_size * sizeof(char*));
 		free(state->malloc_ptrs);
 		state->malloc_ptr_size = new_size;
@@ -77,6 +78,7 @@ void pg_parser_init() {
 
 	pg_parser_state.malloc_ptr_size = 4;
 	pg_parser_state.malloc_ptrs = (char **) malloc(sizeof(char *) * pg_parser_state.malloc_ptr_size);
+	memset(pg_parser_state.malloc_ptrs, 0, sizeof(char*) * pg_parser_state.malloc_ptr_size);
 	pg_parser_state.malloc_ptr_idx = 0;
 	allocate_new(&pg_parser_state, 1);
 }
@@ -88,14 +90,7 @@ void pg_parser_parse(const char *query, parse_result *res) {
 		res->success = pg_parser_state.pg_err_code == PGUNDEFINED;
 	} catch (std::exception &ex) {
 		res->success = false;
-		// copy the error message of the exception
-		auto error_message = ex.what();
-		uint32_t pos = 0;
-		while(pos < 1023 && error_message[pos]) {
-			pg_parser_state.pg_err_msg[pos] = error_message[pos];
-			pos++;
-		}
-		pg_parser_state.pg_err_msg[pos] = '\0';
+		res->error_message = ex.what();
 	}
 	res->error_message = pg_parser_state.pg_err_msg;
 	res->error_location = pg_parser_state.pg_err_pos;
diff --git a/third_party/libpg_query/src_backend_parser_gram.cpp b/third_party/libpg_query/src_backend_parser_gram.cpp
index 53b21d59dde2..9a420592d165 100644
--- a/third_party/libpg_query/src_backend_parser_gram.cpp
+++ b/third_party/libpg_query/src_backend_parser_gram.cpp
@@ -1523,7 +1523,7 @@ union yyalloc
 /* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  395
 /* YYNRULES -- Number of rules.  */
-#define YYNRULES  1833
+#define YYNRULES  1834
 /* YYNRULES -- Number of states.  */
 #define YYNSTATES  3022
 
@@ -1743,8 +1743,8 @@ static const yytype_uint16 yyprhs[] =
     4076,  4078,  4079,  4081,  4085,  4087,  4088,  4096,  4098,  4101,
     4105,  4108,  4109,  4112,  4113,  4116,  4121,  4124,  4126,  4128,
     4130,  4133,  4137,  4140,  4143,  4146,  4149,  4153,  4158,  4161,
-    4163,  4165,  4167,  4171,  4174,  4184,  4196,  4209,  4224,  4228,
-    4233,  4238,  4239,  4247,  4258,  4268,  4271,  4275,  4276,  4281,
+    4163,  4165,  4167,  4169,  4173,  4176,  4186,  4198,  4211,  4226,
+    4230,  4235,  4240,  4241,  4249,  4260,  4270,  4273,  4277,  4278,
     4283,  4285,  4287,  4289,  4291,  4293,  4295,  4297,  4299,  4301,
     4303,  4305,  4307,  4309,  4311,  4313,  4315,  4317,  4319,  4321,
     4323,  4325,  4327,  4329,  4331,  4333,  4335,  4337,  4339,  4341,
@@ -1801,7 +1801,7 @@ static const yytype_uint16 yyprhs[] =
     5343,  5345,  5347,  5349,  5351,  5353,  5355,  5357,  5359,  5361,
     5363,  5365,  5367,  5369,  5371,  5373,  5375,  5377,  5379,  5381,
     5383,  5385,  5387,  5389,  5391,  5393,  5395,  5397,  5399,  5401,
-    5403,  5405,  5407,  5409
+    5403,  5405,  5407,  5409,  5411
 };
 
 /* YYRHS -- A `-1'-separated list of the rules' RHS.  */
@@ -2223,132 +2223,132 @@ static const yytype_int16 yyrhs[] =
      411,   477,    -1,   415,   219,   230,    -1,   884,   633,    -1,
      398,   633,    -1,   398,   885,    -1,   884,   885,    -1,   884,
      411,   477,    -1,   884,   415,   219,   230,    -1,   884,    27,
-      -1,   377,    -1,   125,    -1,   823,    -1,   885,   496,   823,
-      -1,    56,   747,    -1,    93,   603,   449,   814,   592,   845,
-      36,   633,   888,    -1,    93,   289,   341,   603,   449,   814,
-     592,   845,    36,   633,   888,    -1,    93,   603,   331,   449,
-     814,   494,   596,   495,   845,    36,   633,   888,    -1,    93,
-     289,   341,   603,   331,   449,   814,   494,   596,   495,   845,
-      36,   633,   888,    -1,   456,    67,   287,    -1,   456,    59,
-      67,   287,    -1,   456,   235,    67,   287,    -1,    -1,    93,
-     603,   402,   891,    36,   633,   890,    -1,    93,   603,   402,
-     188,   269,   150,   891,    36,   633,   890,    -1,    93,   289,
-     341,   603,   402,   891,    36,   633,   890,    -1,   456,   107,
-      -1,   456,   267,   107,    -1,    -1,   814,   592,   578,   570,
-      -1,    19,    -1,    20,    -1,    21,    -1,    22,    -1,    23,
-      -1,    24,    -1,    25,    -1,    26,    -1,    28,    -1,    29,
-      -1,    30,    -1,    38,    -1,    39,    -1,    41,    -1,    42,
-      -1,    43,    -1,    45,    -1,    46,    -1,    47,    -1,    54,
-      -1,    55,    -1,    56,    -1,    57,    -1,    58,    -1,    59,
-      -1,    62,    -1,    63,    -1,    66,    -1,    68,    -1,    69,
-      -1,    70,    -1,    71,    -1,    76,    -1,    77,    -1,    78,
-      -1,    79,    -1,    80,    -1,    81,    -1,    83,    -1,    84,
-      -1,    85,    -1,    87,    -1,    88,    -1,    89,    -1,    90,
-      -1,    91,    -1,    92,    -1,    95,    -1,    96,    -1,    97,
-      -1,   105,    -1,   106,    -1,   107,    -1,   108,    -1,   109,
-      -1,   110,    -1,   111,    -1,   114,    -1,   116,    -1,   118,
-      -1,   119,    -1,   120,    -1,   121,    -1,   122,    -1,   123,
-      -1,   125,    -1,   126,    -1,   127,    -1,   128,    -1,   129,
-      -1,   132,    -1,   133,    -1,   134,    -1,   135,    -1,   136,
-      -1,   138,    -1,   139,    -1,   140,    -1,   142,    -1,   143,
-      -1,   144,    -1,   146,    -1,   147,    -1,   148,    -1,   149,
-      -1,   151,    -1,   152,    -1,   153,    -1,   154,    -1,   155,
-      -1,   158,    -1,   160,    -1,   161,    -1,   163,    -1,   165,
-      -1,   167,    -1,   171,    -1,   172,    -1,   173,    -1,   175,
-      -1,   177,    -1,   181,    -1,   183,    -1,   184,    -1,   185,
-      -1,   186,    -1,   187,    -1,   188,    -1,   189,    -1,   191,
-      -1,   192,    -1,   193,    -1,   194,    -1,   196,    -1,   197,
-      -1,   198,    -1,   199,    -1,   200,    -1,   201,    -1,   203,
-      -1,   206,    -1,   207,    -1,   208,    -1,   209,    -1,   210,
-      -1,   216,    -1,   219,    -1,   221,    -1,   222,    -1,   223,
-      -1,   224,    -1,   225,    -1,   228,    -1,   230,    -1,   233,
-      -1,   234,    -1,   235,    -1,   238,    -1,   239,    -1,   240,
-      -1,   241,    -1,   242,    -1,   244,    -1,   245,    -1,   246,
-      -1,   247,    -1,   248,    -1,   249,    -1,   250,    -1,   251,
-      -1,   252,    -1,   253,    -1,   254,    -1,   255,    -1,   256,
-      -1,   257,    -1,   258,    -1,   259,    -1,   260,    -1,   261,
-      -1,   265,    -1,   266,    -1,   267,    -1,   270,    -1,   271,
-      -1,   273,    -1,   276,    -1,   278,    -1,   279,    -1,   280,
-      -1,   282,    -1,   283,    -1,   286,    -1,   287,    -1,   288,
-      -1,   291,    -1,   294,    -1,   297,    -1,   298,    -1,   299,
-      -1,   300,    -1,   301,    -1,   302,    -1,   303,    -1,   304,
-      -1,   305,    -1,   306,    -1,   308,    -1,   309,    -1,   311,
-      -1,   312,    -1,   314,    -1,   315,    -1,   316,    -1,   318,
-      -1,   319,    -1,   320,    -1,   321,    -1,   322,    -1,   323,
-      -1,   325,    -1,   326,    -1,   327,    -1,   329,    -1,   330,
-      -1,   331,    -1,   332,    -1,   334,    -1,   335,    -1,   336,
-      -1,   337,    -1,   338,    -1,   339,    -1,   340,    -1,   341,
-      -1,   342,    -1,   343,    -1,   344,    -1,   345,    -1,   346,
-      -1,   348,    -1,   349,    -1,   351,    -1,   352,    -1,   353,
-      -1,   355,    -1,   356,    -1,   357,    -1,   358,    -1,   359,
-      -1,   360,    -1,   361,    -1,   362,    -1,   363,    -1,   364,
-      -1,   365,    -1,   367,    -1,   368,    -1,   369,    -1,   370,
-      -1,   371,    -1,   373,    -1,   375,    -1,   376,    -1,   377,
-      -1,   379,    -1,   380,    -1,   382,    -1,   384,    -1,   385,
-      -1,   386,    -1,   387,    -1,   388,    -1,   389,    -1,   390,
-      -1,   391,    -1,   392,    -1,   393,    -1,   394,    -1,   396,
-      -1,   398,    -1,   400,    -1,   401,    -1,   403,    -1,   405,
-      -1,   406,    -1,   407,    -1,   408,    -1,   409,    -1,   415,
-      -1,   416,    -1,   418,    -1,   421,    -1,   422,    -1,   424,
-      -1,   425,    -1,   426,    -1,   427,    -1,   428,    -1,   431,
-      -1,   432,    -1,   433,    -1,   434,    -1,   435,    -1,   438,
-      -1,   439,    -1,   440,    -1,   441,    -1,   442,    -1,   446,
-      -1,   448,    -1,   449,    -1,   450,    -1,   451,    -1,   454,
-      -1,   457,    -1,   458,    -1,   459,    -1,   460,    -1,   461,
-      -1,   462,    -1,   474,    -1,   475,    -1,   476,    -1,   477,
-      -1,    48,    -1,    49,    -1,    51,    -1,    52,    -1,    64,
-      -1,    65,    -1,    72,    -1,   112,    -1,   113,    -1,   150,
-      -1,   156,    -1,   162,    -1,   179,    -1,   180,    -1,   205,
-      -1,   211,    -1,   212,    -1,   214,    -1,   243,    -1,   262,
-      -1,   264,    -1,   268,    -1,   275,    -1,   277,    -1,   292,
-      -1,   296,    -1,   310,    -1,   313,    -1,   328,    -1,   354,
-      -1,   374,    -1,   381,    -1,   395,    -1,   397,    -1,   411,
-      -1,   412,    -1,   417,    -1,   419,    -1,   423,    -1,   443,
-      -1,   444,    -1,   463,    -1,   464,    -1,   465,    -1,   466,
-      -1,   467,    -1,   468,    -1,   469,    -1,   470,    -1,   471,
-      -1,   472,    -1,   473,    -1,    44,    -1,    50,    -1,    74,
-      -1,    82,    -1,    94,    -1,   101,    -1,   168,    -1,   170,
-      -1,   174,    -1,   190,    -1,   204,    -1,   217,    -1,   218,
-      -1,   220,    -1,   229,    -1,   231,    -1,   243,    -1,   263,
-      -1,   272,    -1,   293,    -1,   295,    -1,   350,    -1,   378,
-      -1,   395,    -1,   404,    -1,   447,    -1,    44,    -1,    50,
+      -1,   884,    -1,   377,    -1,   125,    -1,   823,    -1,   885,
+     496,   823,    -1,    56,   747,    -1,    93,   603,   449,   814,
+     592,   845,    36,   633,   888,    -1,    93,   289,   341,   603,
+     449,   814,   592,   845,    36,   633,   888,    -1,    93,   603,
+     331,   449,   814,   494,   596,   495,   845,    36,   633,   888,
+      -1,    93,   289,   341,   603,   331,   449,   814,   494,   596,
+     495,   845,    36,   633,   888,    -1,   456,    67,   287,    -1,
+     456,    59,    67,   287,    -1,   456,   235,    67,   287,    -1,
+      -1,    93,   603,   402,   891,    36,   633,   890,    -1,    93,
+     603,   402,   188,   269,   150,   891,    36,   633,   890,    -1,
+      93,   289,   341,   603,   402,   891,    36,   633,   890,    -1,
+     456,   107,    -1,   456,   267,   107,    -1,    -1,   814,   592,
+     578,   570,    -1,    19,    -1,    20,    -1,    21,    -1,    22,
+      -1,    23,    -1,    24,    -1,    25,    -1,    26,    -1,    28,
+      -1,    29,    -1,    30,    -1,    38,    -1,    39,    -1,    41,
+      -1,    42,    -1,    43,    -1,    45,    -1,    46,    -1,    47,
+      -1,    54,    -1,    55,    -1,    56,    -1,    57,    -1,    58,
+      -1,    59,    -1,    62,    -1,    63,    -1,    66,    -1,    68,
+      -1,    69,    -1,    70,    -1,    71,    -1,    76,    -1,    77,
+      -1,    78,    -1,    79,    -1,    80,    -1,    81,    -1,    83,
+      -1,    84,    -1,    85,    -1,    87,    -1,    88,    -1,    89,
+      -1,    90,    -1,    91,    -1,    92,    -1,    95,    -1,    96,
+      -1,    97,    -1,   105,    -1,   106,    -1,   107,    -1,   108,
+      -1,   109,    -1,   110,    -1,   111,    -1,   114,    -1,   116,
+      -1,   118,    -1,   119,    -1,   120,    -1,   121,    -1,   122,
+      -1,   123,    -1,   125,    -1,   126,    -1,   127,    -1,   128,
+      -1,   129,    -1,   132,    -1,   133,    -1,   134,    -1,   135,
+      -1,   136,    -1,   138,    -1,   139,    -1,   140,    -1,   142,
+      -1,   143,    -1,   144,    -1,   146,    -1,   147,    -1,   148,
+      -1,   149,    -1,   151,    -1,   152,    -1,   153,    -1,   154,
+      -1,   155,    -1,   158,    -1,   160,    -1,   161,    -1,   163,
+      -1,   165,    -1,   167,    -1,   171,    -1,   172,    -1,   173,
+      -1,   175,    -1,   177,    -1,   181,    -1,   183,    -1,   184,
+      -1,   185,    -1,   186,    -1,   187,    -1,   188,    -1,   189,
+      -1,   191,    -1,   192,    -1,   193,    -1,   194,    -1,   196,
+      -1,   197,    -1,   198,    -1,   199,    -1,   200,    -1,   201,
+      -1,   203,    -1,   206,    -1,   207,    -1,   208,    -1,   209,
+      -1,   210,    -1,   216,    -1,   219,    -1,   221,    -1,   222,
+      -1,   223,    -1,   224,    -1,   225,    -1,   228,    -1,   230,
+      -1,   233,    -1,   234,    -1,   235,    -1,   238,    -1,   239,
+      -1,   240,    -1,   241,    -1,   242,    -1,   244,    -1,   245,
+      -1,   246,    -1,   247,    -1,   248,    -1,   249,    -1,   250,
+      -1,   251,    -1,   252,    -1,   253,    -1,   254,    -1,   255,
+      -1,   256,    -1,   257,    -1,   258,    -1,   259,    -1,   260,
+      -1,   261,    -1,   265,    -1,   266,    -1,   267,    -1,   270,
+      -1,   271,    -1,   273,    -1,   276,    -1,   278,    -1,   279,
+      -1,   280,    -1,   282,    -1,   283,    -1,   286,    -1,   287,
+      -1,   288,    -1,   291,    -1,   294,    -1,   297,    -1,   298,
+      -1,   299,    -1,   300,    -1,   301,    -1,   302,    -1,   303,
+      -1,   304,    -1,   305,    -1,   306,    -1,   308,    -1,   309,
+      -1,   311,    -1,   312,    -1,   314,    -1,   315,    -1,   316,
+      -1,   318,    -1,   319,    -1,   320,    -1,   321,    -1,   322,
+      -1,   323,    -1,   325,    -1,   326,    -1,   327,    -1,   329,
+      -1,   330,    -1,   331,    -1,   332,    -1,   334,    -1,   335,
+      -1,   336,    -1,   337,    -1,   338,    -1,   339,    -1,   340,
+      -1,   341,    -1,   342,    -1,   343,    -1,   344,    -1,   345,
+      -1,   346,    -1,   348,    -1,   349,    -1,   351,    -1,   352,
+      -1,   353,    -1,   355,    -1,   356,    -1,   357,    -1,   358,
+      -1,   359,    -1,   360,    -1,   361,    -1,   362,    -1,   363,
+      -1,   364,    -1,   365,    -1,   367,    -1,   368,    -1,   369,
+      -1,   370,    -1,   371,    -1,   373,    -1,   375,    -1,   376,
+      -1,   377,    -1,   379,    -1,   380,    -1,   382,    -1,   384,
+      -1,   385,    -1,   386,    -1,   387,    -1,   388,    -1,   389,
+      -1,   390,    -1,   391,    -1,   392,    -1,   393,    -1,   394,
+      -1,   396,    -1,   398,    -1,   400,    -1,   401,    -1,   403,
+      -1,   405,    -1,   406,    -1,   407,    -1,   408,    -1,   409,
+      -1,   415,    -1,   416,    -1,   418,    -1,   421,    -1,   422,
+      -1,   424,    -1,   425,    -1,   426,    -1,   427,    -1,   428,
+      -1,   431,    -1,   432,    -1,   433,    -1,   434,    -1,   435,
+      -1,   438,    -1,   439,    -1,   440,    -1,   441,    -1,   442,
+      -1,   446,    -1,   448,    -1,   449,    -1,   450,    -1,   451,
+      -1,   454,    -1,   457,    -1,   458,    -1,   459,    -1,   460,
+      -1,   461,    -1,   462,    -1,   474,    -1,   475,    -1,   476,
+      -1,   477,    -1,    48,    -1,    49,    -1,    51,    -1,    52,
+      -1,    64,    -1,    65,    -1,    72,    -1,   112,    -1,   113,
+      -1,   150,    -1,   156,    -1,   162,    -1,   179,    -1,   180,
+      -1,   205,    -1,   211,    -1,   212,    -1,   214,    -1,   243,
+      -1,   262,    -1,   264,    -1,   268,    -1,   275,    -1,   277,
+      -1,   292,    -1,   296,    -1,   310,    -1,   313,    -1,   328,
+      -1,   354,    -1,   374,    -1,   381,    -1,   395,    -1,   397,
+      -1,   411,    -1,   412,    -1,   417,    -1,   419,    -1,   423,
+      -1,   443,    -1,   444,    -1,   463,    -1,   464,    -1,   465,
+      -1,   466,    -1,   467,    -1,   468,    -1,   469,    -1,   470,
+      -1,   471,    -1,   472,    -1,   473,    -1,    44,    -1,    50,
       -1,    74,    -1,    82,    -1,    94,    -1,   101,    -1,   168,
       -1,   170,    -1,   174,    -1,   190,    -1,   204,    -1,   217,
-      -1,   218,    -1,   220,    -1,   229,    -1,   231,    -1,   263,
-      -1,   272,    -1,   293,    -1,   295,    -1,   350,    -1,   378,
-      -1,   404,    -1,   423,    -1,   447,    -1,    48,    -1,    49,
-      -1,    51,    -1,    52,    -1,    65,    -1,    64,    -1,    72,
-      -1,   112,    -1,   113,    -1,   150,    -1,   156,    -1,   162,
-      -1,   179,    -1,   180,    -1,   205,    -1,   212,    -1,   214,
-      -1,   211,    -1,   243,    -1,   262,    -1,   264,    -1,   268,
-      -1,   275,    -1,   277,    -1,   292,    -1,   296,    -1,   310,
-      -1,   313,    -1,   328,    -1,   354,    -1,   374,    -1,   381,
-      -1,   395,    -1,   397,    -1,   411,    -1,   412,    -1,   417,
-      -1,   419,    -1,   423,    -1,   443,    -1,   444,    -1,   463,
-      -1,   464,    -1,   465,    -1,   466,    -1,   467,    -1,   468,
-      -1,   469,    -1,   470,    -1,   471,    -1,   472,    -1,   473,
-      -1,    44,    -1,    50,    -1,    74,    -1,    82,    -1,    94,
-      -1,   101,    -1,   168,    -1,   170,    -1,   174,    -1,   190,
-      -1,   204,    -1,   217,    -1,   218,    -1,   220,    -1,   229,
-      -1,   231,    -1,   243,    -1,   263,    -1,   272,    -1,   293,
-      -1,   295,    -1,   350,    -1,   378,    -1,   395,    -1,   404,
-      -1,   423,    -1,   447,    -1,    27,    -1,    31,    -1,    32,
-      -1,    33,    -1,    34,    -1,    35,    -1,    36,    -1,    37,
-      -1,    40,    -1,    53,    -1,    60,    -1,    61,    -1,    67,
-      -1,    73,    -1,    75,    -1,    86,    -1,    93,    -1,    98,
-      -1,    99,    -1,   100,    -1,   102,    -1,   103,    -1,   104,
-      -1,   115,    -1,   117,    -1,   124,    -1,   130,    -1,   131,
-      -1,   137,    -1,   141,    -1,   145,    -1,   157,    -1,   159,
-      -1,   164,    -1,   166,    -1,   169,    -1,   176,    -1,   178,
-      -1,   182,    -1,   195,    -1,   202,    -1,   213,    -1,   215,
-      -1,   226,    -1,   227,    -1,   232,    -1,   236,    -1,   237,
-      -1,   269,    -1,   274,    -1,   281,    -1,   284,    -1,   285,
-      -1,   289,    -1,   290,    -1,   307,    -1,   317,    -1,   324,
-      -1,   333,    -1,   347,    -1,   366,    -1,   372,    -1,   383,
-      -1,   399,    -1,   402,    -1,   410,    -1,   413,    -1,   414,
-      -1,   420,    -1,   429,    -1,   430,    -1,   436,    -1,   437,
-      -1,   445,    -1,   452,    -1,   453,    -1,   455,    -1,   456,
-      -1
+      -1,   218,    -1,   220,    -1,   229,    -1,   231,    -1,   243,
+      -1,   263,    -1,   272,    -1,   293,    -1,   295,    -1,   350,
+      -1,   378,    -1,   395,    -1,   404,    -1,   447,    -1,    44,
+      -1,    50,    -1,    74,    -1,    82,    -1,    94,    -1,   101,
+      -1,   168,    -1,   170,    -1,   174,    -1,   190,    -1,   204,
+      -1,   217,    -1,   218,    -1,   220,    -1,   229,    -1,   231,
+      -1,   263,    -1,   272,    -1,   293,    -1,   295,    -1,   350,
+      -1,   378,    -1,   404,    -1,   423,    -1,   447,    -1,    48,
+      -1,    49,    -1,    51,    -1,    52,    -1,    65,    -1,    64,
+      -1,    72,    -1,   112,    -1,   113,    -1,   150,    -1,   156,
+      -1,   162,    -1,   179,    -1,   180,    -1,   205,    -1,   212,
+      -1,   214,    -1,   211,    -1,   243,    -1,   262,    -1,   264,
+      -1,   268,    -1,   275,    -1,   277,    -1,   292,    -1,   296,
+      -1,   310,    -1,   313,    -1,   328,    -1,   354,    -1,   374,
+      -1,   381,    -1,   395,    -1,   397,    -1,   411,    -1,   412,
+      -1,   417,    -1,   419,    -1,   423,    -1,   443,    -1,   444,
+      -1,   463,    -1,   464,    -1,   465,    -1,   466,    -1,   467,
+      -1,   468,    -1,   469,    -1,   470,    -1,   471,    -1,   472,
+      -1,   473,    -1,    44,    -1,    50,    -1,    74,    -1,    82,
+      -1,    94,    -1,   101,    -1,   168,    -1,   170,    -1,   174,
+      -1,   190,    -1,   204,    -1,   217,    -1,   218,    -1,   220,
+      -1,   229,    -1,   231,    -1,   243,    -1,   263,    -1,   272,
+      -1,   293,    -1,   295,    -1,   350,    -1,   378,    -1,   395,
+      -1,   404,    -1,   423,    -1,   447,    -1,    27,    -1,    31,
+      -1,    32,    -1,    33,    -1,    34,    -1,    35,    -1,    36,
+      -1,    37,    -1,    40,    -1,    53,    -1,    60,    -1,    61,
+      -1,    67,    -1,    73,    -1,    75,    -1,    86,    -1,    93,
+      -1,    98,    -1,    99,    -1,   100,    -1,   102,    -1,   103,
+      -1,   104,    -1,   115,    -1,   117,    -1,   124,    -1,   130,
+      -1,   131,    -1,   137,    -1,   141,    -1,   145,    -1,   157,
+      -1,   159,    -1,   164,    -1,   166,    -1,   169,    -1,   176,
+      -1,   178,    -1,   182,    -1,   195,    -1,   202,    -1,   213,
+      -1,   215,    -1,   226,    -1,   227,    -1,   232,    -1,   236,
+      -1,   237,    -1,   269,    -1,   274,    -1,   281,    -1,   284,
+      -1,   285,    -1,   289,    -1,   290,    -1,   307,    -1,   317,
+      -1,   324,    -1,   333,    -1,   347,    -1,   366,    -1,   372,
+      -1,   383,    -1,   399,    -1,   402,    -1,   410,    -1,   413,
+      -1,   414,    -1,   420,    -1,   429,    -1,   430,    -1,   436,
+      -1,   437,    -1,   445,    -1,   452,    -1,   453,    -1,   455,
+      -1,   456,    -1
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
@@ -2478,9 +2478,9 @@ static const yytype_uint16 yyrline[] =
        8,    22,    36,    48,    56,    70,    71,    72,    73,    74,
       87,    88,    93,    94,    98,    99,     7,    21,    25,    32,
       43,    44,    50,    51,     9,    19,     2,     7,    14,    24,
-      25,    32,     3,    10,    17,    24,    31,    38,    45,    55,
-      55,    57,    58,     6,     8,    21,    34,    52,    74,    75,
-      76,    77,    11,    24,    37,    54,    55,    56,    61,    74,
+      25,    32,     3,    10,    17,    24,    31,    38,    45,    52,
+      61,    61,    63,    64,     6,     8,    21,    34,    52,    74,
+      75,    76,    77,    11,    24,    37,    54,    55,    56,    61,
       74,    74,    74,    74,    74,    74,    74,    74,    74,    74,
       74,    74,    74,    74,    74,    74,    74,    74,    74,    74,
       74,    74,    74,    74,    74,    74,    74,    74,    74,    74,
@@ -2511,25 +2511,25 @@ static const yytype_uint16 yyrline[] =
       74,    74,    74,    74,    74,    74,    74,    74,    74,    74,
       74,    74,    74,    74,    74,    74,    74,    74,    74,    74,
       74,    74,    74,    74,    74,    74,    74,    74,    74,    74,
-      74,    74,    74,    74,    75,    75,    75,    75,    75,    75,
+      74,    74,    74,    74,    74,    75,    75,    75,    75,    75,
       75,    75,    75,    75,    75,    75,    75,    75,    75,    75,
       75,    75,    75,    75,    75,    75,    75,    75,    75,    75,
       75,    75,    75,    75,    75,    75,    75,    75,    75,    75,
       75,    75,    75,    75,    75,    75,    75,    75,    75,    75,
-      75,    75,    75,    75,    75,    75,    76,    76,    76,    76,
+      75,    75,    75,    75,    75,    75,    75,    76,    76,    76,
       76,    76,    76,    76,    76,    76,    76,    76,    76,    76,
       76,    76,    76,    76,    76,    76,    76,    76,    76,    76,
-      76,    76,    77,    77,    77,    77,    77,    77,    77,    77,
+      76,    76,    76,    77,    77,    77,    77,    77,    77,    77,
       77,    77,    77,    77,    77,    77,    77,    77,    77,    77,
-      77,    77,    77,    77,    77,    77,    77,    78,    78,    78,
+      77,    77,    77,    77,    77,    77,    77,    77,    78,    78,
+      78,    78,    78,    78,    78,    78,    78,    78,    78,    78,
       78,    78,    78,    78,    78,    78,    78,    78,    78,    78,
       78,    78,    78,    78,    78,    78,    78,    78,    78,    78,
       78,    78,    78,    78,    78,    78,    78,    78,    78,    78,
       78,    78,    78,    78,    78,    78,    78,    78,    78,    78,
-      78,    78,    78,    78,    78,    78,    78,    78,    78,    79,
       79,    79,    79,    79,    79,    79,    79,    79,    79,    79,
       79,    79,    79,    79,    79,    79,    79,    79,    79,    79,
-      79,    79,    79,    79,    79,    79,    80,    80,    80,    80,
+      79,    79,    79,    79,    79,    79,    79,    80,    80,    80,
       80,    80,    80,    80,    80,    80,    80,    80,    80,    80,
       80,    80,    80,    80,    80,    80,    80,    80,    80,    80,
       80,    80,    80,    80,    80,    80,    80,    80,    80,    80,
@@ -2537,7 +2537,7 @@ static const yytype_uint16 yyrline[] =
       80,    80,    80,    80,    80,    80,    80,    80,    80,    80,
       80,    80,    80,    80,    80,    80,    80,    80,    80,    80,
       80,    80,    80,    80,    80,    80,    80,    80,    80,    80,
-      80,    80,    80,    80
+      80,    80,    80,    80,    80
 };
 #endif
 
@@ -2923,9 +2923,9 @@ static const yytype_uint16 yyr1[] =
      870,   870,   870,   870,   870,   871,   871,   871,   871,   871,
      872,   872,   873,   873,   874,   874,   875,   876,   876,   876,
      877,   877,   878,   878,   879,   879,   880,   881,   881,   882,
-     882,   882,   883,   883,   883,   883,   883,   883,   883,   884,
-     884,   885,   885,   886,   887,   887,   887,   887,   888,   888,
-     888,   888,   889,   889,   889,   890,   890,   890,   891,   892,
+     882,   882,   883,   883,   883,   883,   883,   883,   883,   883,
+     884,   884,   885,   885,   886,   887,   887,   887,   887,   888,
+     888,   888,   888,   889,   889,   889,   890,   890,   890,   891,
      892,   892,   892,   892,   892,   892,   892,   892,   892,   892,
      892,   892,   892,   892,   892,   892,   892,   892,   892,   892,
      892,   892,   892,   892,   892,   892,   892,   892,   892,   892,
@@ -2956,25 +2956,25 @@ static const yytype_uint16 yyr1[] =
      892,   892,   892,   892,   892,   892,   892,   892,   892,   892,
      892,   892,   892,   892,   892,   892,   892,   892,   892,   892,
      892,   892,   892,   892,   892,   892,   892,   892,   892,   892,
-     892,   892,   892,   892,   893,   893,   893,   893,   893,   893,
+     892,   892,   892,   892,   892,   893,   893,   893,   893,   893,
      893,   893,   893,   893,   893,   893,   893,   893,   893,   893,
      893,   893,   893,   893,   893,   893,   893,   893,   893,   893,
      893,   893,   893,   893,   893,   893,   893,   893,   893,   893,
      893,   893,   893,   893,   893,   893,   893,   893,   893,   893,
-     893,   893,   893,   893,   893,   893,   894,   894,   894,   894,
+     893,   893,   893,   893,   893,   893,   893,   894,   894,   894,
      894,   894,   894,   894,   894,   894,   894,   894,   894,   894,
      894,   894,   894,   894,   894,   894,   894,   894,   894,   894,
-     894,   894,   895,   895,   895,   895,   895,   895,   895,   895,
+     894,   894,   894,   895,   895,   895,   895,   895,   895,   895,
      895,   895,   895,   895,   895,   895,   895,   895,   895,   895,
-     895,   895,   895,   895,   895,   895,   895,   896,   896,   896,
+     895,   895,   895,   895,   895,   895,   895,   895,   896,   896,
+     896,   896,   896,   896,   896,   896,   896,   896,   896,   896,
      896,   896,   896,   896,   896,   896,   896,   896,   896,   896,
      896,   896,   896,   896,   896,   896,   896,   896,   896,   896,
      896,   896,   896,   896,   896,   896,   896,   896,   896,   896,
      896,   896,   896,   896,   896,   896,   896,   896,   896,   896,
-     896,   896,   896,   896,   896,   896,   896,   896,   896,   897,
      897,   897,   897,   897,   897,   897,   897,   897,   897,   897,
      897,   897,   897,   897,   897,   897,   897,   897,   897,   897,
-     897,   897,   897,   897,   897,   897,   898,   898,   898,   898,
+     897,   897,   897,   897,   897,   897,   897,   898,   898,   898,
      898,   898,   898,   898,   898,   898,   898,   898,   898,   898,
      898,   898,   898,   898,   898,   898,   898,   898,   898,   898,
      898,   898,   898,   898,   898,   898,   898,   898,   898,   898,
@@ -2982,7 +2982,7 @@ static const yytype_uint16 yyr1[] =
      898,   898,   898,   898,   898,   898,   898,   898,   898,   898,
      898,   898,   898,   898,   898,   898,   898,   898,   898,   898,
      898,   898,   898,   898,   898,   898,   898,   898,   898,   898,
-     898,   898,   898,   898
+     898,   898,   898,   898,   898
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
@@ -3113,8 +3113,8 @@ static const yytype_uint8 yyr2[] =
        1,     0,     1,     3,     1,     0,     7,     1,     2,     3,
        2,     0,     2,     0,     2,     4,     2,     1,     1,     1,
        2,     3,     2,     2,     2,     2,     3,     4,     2,     1,
-       1,     1,     3,     2,     9,    11,    12,    14,     3,     4,
-       4,     0,     7,    10,     9,     2,     3,     0,     4,     1,
+       1,     1,     1,     3,     2,     9,    11,    12,    14,     3,
+       4,     4,     0,     7,    10,     9,     2,     3,     0,     4,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
@@ -3171,7 +3171,7 @@ static const yytype_uint8 yyr2[] =
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-       1,     1,     1,     1
+       1,     1,     1,     1,     1
 };
 
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
@@ -3180,93 +3180,93 @@ static const yytype_uint8 yyr2[] =
 static const yytype_uint16 yydefact[] =
 {
      135,   214,     0,  1174,  1173,   214,     0,  1149,   214,   424,
-     348,     0,  1250,     0,   214,     0,   135,     0,     0,     0,
-       0,     0,     0,     0,     0,   214,   491,     0,  1249,   214,
+     348,     0,  1251,     0,   214,     0,   135,     0,     0,     0,
+       0,     0,     0,     0,     0,   214,   491,     0,  1250,   214,
        0,     0,  1221,     0,     0,     0,     0,     0,     2,     4,
        7,    18,    13,    30,    26,     0,    28,    16,    21,     6,
       32,    17,    20,    14,    33,    11,    31,   458,   445,   496,
      457,   134,   597,   461,    29,    15,    25,     5,    10,    23,
       24,    22,  1157,    36,    27,    34,    19,     8,    35,    37,
-       0,     9,    38,    12,   213,   212,   206,     0,     0,     0,
-       0,     0,   207,  1087,  1269,  1270,  1271,  1272,  1273,  1274,
-    1275,  1276,  1277,  1278,  1279,  1280,  1281,  1282,  1283,  1284,
-    1626,  1285,  1286,  1287,  1574,  1575,  1627,  1576,  1577,  1288,
-    1289,  1290,  1291,  1292,  1293,  1294,  1295,  1578,  1579,  1296,
-    1297,  1298,  1299,  1300,  1580,  1628,  1301,  1302,  1303,  1304,
-    1305,  1306,  1629,  1307,  1308,  1309,  1310,  1311,  1312,  1313,
-    1314,  1315,  1630,  1316,  1317,  1318,  1631,  1319,  1320,  1321,
-    1322,  1323,  1324,  1325,  1581,  1582,  1326,  1327,  1328,  1329,
-    1330,  1331,  1332,  1333,  1334,  1335,  1336,  1337,  1338,  1339,
-    1340,  1341,  1342,  1343,  1344,  1345,  1346,  1347,  1348,  1349,
-    1350,  1351,  1352,  1353,  1583,  1354,  1355,  1356,  1357,  1358,
-    1584,  1359,  1360,  1361,  1585,  1362,  1363,  1364,  1632,  1633,
-    1365,  1366,  1367,  1634,  1368,  1369,  1586,  1587,  1370,  1371,
-    1372,  1373,  1374,  1375,  1376,  1377,  1635,  1378,  1379,  1380,
-    1381,  1382,  1383,  1384,  1385,  1386,  1387,  1388,  1636,  1588,
-    1389,  1390,  1391,  1392,  1393,  1589,  1590,  1591,  1394,  1637,
-    1638,  1395,  1639,  1396,  1397,  1398,  1399,  1400,  1401,  1640,
-    1402,  1641,  1403,  1404,  1405,  1406,  1407,  1408,  1409,  1410,
-    1592,  1411,  1412,  1413,  1414,  1415,  1416,  1417,  1418,  1419,
-    1420,  1421,  1422,  1423,  1424,  1425,  1426,  1427,  1428,  1593,
-    1643,  1594,  1429,  1430,  1431,  1595,  1432,  1433,  1644,  1434,
-    1596,  1435,  1597,  1436,  1437,  1438,  1439,  1440,  1441,  1442,
-    1443,  1444,  1598,  1645,  1445,  1646,  1599,  1446,  1447,  1448,
-    1449,  1450,  1451,  1452,  1453,  1454,  1455,  1456,  1457,  1600,
-    1458,  1459,  1601,  1460,  1461,  1462,  1463,  1464,  1465,  1466,
-    1467,  1468,  1469,  1470,  1471,  1602,  1472,  1473,  1474,  1475,
-    1476,  1477,  1478,  1479,  1480,  1481,  1482,  1483,  1484,  1485,
-    1486,  1487,  1488,  1489,  1490,  1647,  1491,  1492,  1493,  1603,
-    1494,  1495,  1496,  1497,  1498,  1499,  1500,  1501,  1502,  1503,
-    1504,  1505,  1506,  1507,  1508,  1509,  1510,  1604,  1511,  1512,
-    1513,  1648,  1514,  1515,  1605,  1516,  1517,  1518,  1519,  1520,
-    1521,  1522,  1523,  1524,  1525,  1526,  1527,  1606,  1528,  1607,
-    1529,  1530,  1531,  1532,  1650,  1533,  1534,  1535,  1536,  1537,
-    1608,  1609,  1538,  1539,  1610,  1540,  1611,  1541,  1542,  1612,
-    1543,  1544,  1545,  1546,  1547,  1548,  1549,  1550,  1551,  1552,
-    1553,  1554,  1555,  1556,  1557,  1613,  1614,  1558,  1651,  1559,
-    1560,  1561,  1562,  1563,  1564,  1565,  1566,  1567,  1568,  1569,
-    1615,  1616,  1617,  1618,  1619,  1620,  1621,  1622,  1623,  1624,
-    1625,  1570,  1571,  1572,  1573,  1253,     0,     0,  1069,  1088,
+    1249,     9,    38,    12,   213,   212,   206,     0,     0,     0,
+       0,     0,   207,  1087,  1270,  1271,  1272,  1273,  1274,  1275,
+    1276,  1277,  1278,  1279,  1280,  1281,  1282,  1283,  1284,  1285,
+    1627,  1286,  1287,  1288,  1575,  1576,  1628,  1577,  1578,  1289,
+    1290,  1291,  1292,  1293,  1294,  1295,  1296,  1579,  1580,  1297,
+    1298,  1299,  1300,  1301,  1581,  1629,  1302,  1303,  1304,  1305,
+    1306,  1307,  1630,  1308,  1309,  1310,  1311,  1312,  1313,  1314,
+    1315,  1316,  1631,  1317,  1318,  1319,  1632,  1320,  1321,  1322,
+    1323,  1324,  1325,  1326,  1582,  1583,  1327,  1328,  1329,  1330,
+    1331,  1332,  1333,  1334,  1335,  1336,  1337,  1338,  1339,  1340,
+    1341,  1342,  1343,  1344,  1345,  1346,  1347,  1348,  1349,  1350,
+    1351,  1352,  1353,  1354,  1584,  1355,  1356,  1357,  1358,  1359,
+    1585,  1360,  1361,  1362,  1586,  1363,  1364,  1365,  1633,  1634,
+    1366,  1367,  1368,  1635,  1369,  1370,  1587,  1588,  1371,  1372,
+    1373,  1374,  1375,  1376,  1377,  1378,  1636,  1379,  1380,  1381,
+    1382,  1383,  1384,  1385,  1386,  1387,  1388,  1389,  1637,  1589,
+    1390,  1391,  1392,  1393,  1394,  1590,  1591,  1592,  1395,  1638,
+    1639,  1396,  1640,  1397,  1398,  1399,  1400,  1401,  1402,  1641,
+    1403,  1642,  1404,  1405,  1406,  1407,  1408,  1409,  1410,  1411,
+    1593,  1412,  1413,  1414,  1415,  1416,  1417,  1418,  1419,  1420,
+    1421,  1422,  1423,  1424,  1425,  1426,  1427,  1428,  1429,  1594,
+    1644,  1595,  1430,  1431,  1432,  1596,  1433,  1434,  1645,  1435,
+    1597,  1436,  1598,  1437,  1438,  1439,  1440,  1441,  1442,  1443,
+    1444,  1445,  1599,  1646,  1446,  1647,  1600,  1447,  1448,  1449,
+    1450,  1451,  1452,  1453,  1454,  1455,  1456,  1457,  1458,  1601,
+    1459,  1460,  1602,  1461,  1462,  1463,  1464,  1465,  1466,  1467,
+    1468,  1469,  1470,  1471,  1472,  1603,  1473,  1474,  1475,  1476,
+    1477,  1478,  1479,  1480,  1481,  1482,  1483,  1484,  1485,  1486,
+    1487,  1488,  1489,  1490,  1491,  1648,  1492,  1493,  1494,  1604,
+    1495,  1496,  1497,  1498,  1499,  1500,  1501,  1502,  1503,  1504,
+    1505,  1506,  1507,  1508,  1509,  1510,  1511,  1605,  1512,  1513,
+    1514,  1649,  1515,  1516,  1606,  1517,  1518,  1519,  1520,  1521,
+    1522,  1523,  1524,  1525,  1526,  1527,  1528,  1607,  1529,  1608,
+    1530,  1531,  1532,  1533,  1651,  1534,  1535,  1536,  1537,  1538,
+    1609,  1610,  1539,  1540,  1611,  1541,  1612,  1542,  1543,  1613,
+    1544,  1545,  1546,  1547,  1548,  1549,  1550,  1551,  1552,  1553,
+    1554,  1555,  1556,  1557,  1558,  1614,  1615,  1559,  1652,  1560,
+    1561,  1562,  1563,  1564,  1565,  1566,  1567,  1568,  1569,  1570,
+    1616,  1617,  1618,  1619,  1620,  1621,  1622,  1623,  1624,  1625,
+    1626,  1571,  1572,  1573,  1574,  1254,     0,     0,  1069,  1088,
     1089,  1097,   209,   423,   135,     0,   392,     0,     0,   393,
        0,     0,   342,   341,     0,  1140,   347,     0,     0,     0,
-    1087,   101,  1592,  1460,  1606,    99,  1067,  1088,     0,   367,
+    1087,   101,  1593,  1461,  1607,    99,  1067,  1088,     0,   367,
      368,     0,   376,     0,   361,   365,   362,     0,   386,   378,
      387,   379,   360,   380,   369,   359,     0,   388,     0,   363,
        0,     0,     0,   210,   175,   348,   135,     0,  1162,  1163,
     1161,  1152,  1157,  1164,  1165,     0,  1148,     0,     0,  1086,
-    1208,  1209,  1206,  1205,   164,  1116,  1238,  1608,  1538,  1251,
-    1239,  1236,  1237,   211,   490,   488,     0,  1037,  1368,  1405,
-    1498,  1509,  1608,  1182,  1186,     0,   208,  1613,  1243,     0,
+    1208,  1209,  1206,  1205,   164,  1116,  1238,  1609,  1539,  1252,
+    1239,  1236,  1237,   211,   490,   488,     0,  1037,  1369,  1406,
+    1499,  1510,  1609,  1182,  1186,     0,   208,  1614,  1243,     0,
     1244,  1091,     0,   462,   637,  1090,  1061,  1220,     0,  1225,
-       0,  1474,   466,   469,  1106,   467,   458,     0,     1,   135,
+       0,  1475,   466,   469,  1106,   467,   458,     0,     1,   135,
        0,     0,     0,   487,   487,     0,   487,     0,   450,   458,
-     453,   457,   598,  1156,  1234,  1248,  1608,  1538,  1242,  1245,
-    1376,     0,     0,  1376,     0,  1376,     0,  1376,     0,     0,
+     453,   457,   598,  1156,  1234,  1248,  1609,  1539,  1242,  1245,
+    1377,     0,     0,  1377,     0,  1377,     0,  1377,     0,     0,
     1029,     0,  1030,  1070,  1118,  1119,  1117,     0,  1120,   313,
-     346,   345,   344,   343,   348,  1376,  1124,  1101,     0,     0,
+     346,   345,   344,   343,   348,  1377,  1124,  1101,     0,     0,
        0,     0,     0,     0,  1135,   102,   100,   374,   375,     0,
-     366,   364,     0,  1098,  1652,   689,  1653,   718,   696,   718,
-     718,  1654,  1655,  1656,  1657,   685,   685,  1341,   698,  1658,
-    1659,  1660,  1376,  1661,  1662,   686,   687,   723,  1663,  1664,
-    1665,  1666,  1667,     0,     0,  1668,   718,  1669,   685,  1670,
-    1671,   690,  1672,   659,     0,  1673,   688,   660,  1674,   726,
-     726,  1675,   713,  1676,   385,     0,   389,   671,   672,   673,
+     366,   364,     0,  1098,  1653,   689,  1654,   718,   696,   718,
+     718,  1655,  1656,  1657,  1658,   685,   685,  1342,   698,  1659,
+    1660,  1661,  1377,  1662,  1663,   686,   687,   723,  1664,  1665,
+    1666,  1667,  1668,     0,     0,  1669,   718,  1670,   685,  1671,
+    1672,   690,  1673,   659,     0,  1674,   688,   660,  1675,   726,
+     726,  1676,   713,  1677,   385,     0,   389,   671,   672,   673,
      674,   699,   700,   675,   705,   706,   710,   676,   758,   685,
-    1099,  1100,  1376,   385,   381,  1376,   385,  1063,  1376,     0,
-       0,   171,     0,     0,  1154,  1166,  1677,  1678,  1679,  1680,
-    1682,  1681,  1683,  1684,  1685,  1686,  1687,  1688,  1689,  1690,
-    1691,  1694,  1692,  1693,  1695,  1696,  1697,  1698,  1699,  1700,
-    1701,  1702,  1703,  1704,  1705,  1706,  1707,  1708,  1709,  1710,
-    1711,  1712,  1713,  1714,  1715,  1716,  1717,  1718,  1719,  1720,
-    1721,  1722,  1723,  1724,  1725,  1726,  1727,  1728,  1180,     0,
+    1099,  1100,  1377,   385,   381,  1377,   385,  1063,  1377,     0,
+       0,   171,     0,     0,  1154,  1166,  1678,  1679,  1680,  1681,
+    1683,  1682,  1684,  1685,  1686,  1687,  1688,  1689,  1690,  1691,
+    1692,  1695,  1693,  1694,  1696,  1697,  1698,  1699,  1700,  1701,
+    1702,  1703,  1704,  1705,  1706,  1707,  1708,  1709,  1710,  1711,
+    1712,  1713,  1714,  1715,  1716,  1717,  1718,  1719,  1720,  1721,
+    1722,  1723,  1724,  1725,  1726,  1727,  1728,  1729,  1180,     0,
     1181,  1171,  1160,  1167,  1168,   135,   422,  1207,  1151,     0,
        0,     0,     0,  1240,     0,     0,     0,  1072,  1074,  1075,
-     958,  1085,  1032,     0,  1575,  1576,  1577,  1022,     0,  1578,
-    1579,  1580,  1628,   888,   875,   884,   889,   876,   878,   885,
-    1581,  1582,   826,  1583,  1584,  1083,  1585,  1586,  1587,  1589,
-    1590,  1591,   880,   882,  1593,  1594,     0,  1084,  1596,  1597,
-    1441,  1599,  1600,  1602,  1603,   886,  1605,  1607,  1608,  1609,
-    1610,  1611,  1082,  1612,   887,  1614,     0,     0,     0,  1050,
+     958,  1085,  1032,     0,  1576,  1577,  1578,  1022,     0,  1579,
+    1580,  1581,  1629,   888,   875,   884,   889,   876,   878,   885,
+    1582,  1583,   826,  1584,  1585,  1083,  1586,  1587,  1588,  1590,
+    1591,  1592,   880,   882,  1594,  1595,     0,  1084,  1597,  1598,
+    1442,  1600,  1601,  1603,  1604,   886,  1606,  1608,  1609,  1610,
+    1611,  1612,  1082,  1613,   887,  1615,     0,     0,     0,  1050,
      977,     0,     0,     0,  1032,   859,     0,     0,   679,   680,
      701,   702,   681,   707,   708,   682,     0,  1044,   759,   904,
     1032,   871,   934,   802,     0,   857,   851,  1040,   473,  1038,
@@ -3280,21 +3280,21 @@ static const yytype_uint16 yydefact[] =
        0,     0,     0,     0,     0,    93,    42,    86,     0,     0,
        0,     0,   189,   202,     0,     0,     0,     0,     0,   199,
        0,     0,   182,    44,   176,   178,     0,   122,     0,    40,
-       0,     0,     0,    46,  1087,     0,  1626,  1627,  1628,  1629,
-    1630,   889,     0,  1632,  1633,  1634,  1635,  1636,  1637,  1638,
-    1639,  1640,  1641,  1592,  1643,  1644,  1645,  1646,  1647,  1648,
-    1606,  1650,  1612,     0,  1651,     0,   863,   980,   496,   978,
-    1107,     0,  1088,  1094,  1028,     0,  1108,  1756,  1757,  1758,
-    1759,  1760,  1761,  1762,  1763,  1764,  1765,  1766,  1767,  1768,
-    1769,  1770,  1771,  1772,  1773,  1774,  1775,  1776,  1777,  1778,
-    1779,  1780,  1781,  1782,  1783,  1784,  1785,  1786,  1787,  1788,
-    1789,  1790,  1791,  1792,  1793,  1794,  1795,  1796,  1797,  1798,
-    1799,  1800,  1801,  1802,  1803,  1804,  1805,  1806,  1807,  1808,
-    1809,  1810,  1811,  1812,  1813,  1814,  1815,  1816,  1817,  1818,
-    1819,  1820,  1821,  1822,  1823,  1824,  1825,  1826,  1827,  1828,
-    1716,  1829,  1830,  1831,  1832,  1833,  1025,  1068,  1110,  1109,
+       0,     0,     0,    46,  1087,     0,  1627,  1628,  1629,  1630,
+    1631,   889,     0,  1633,  1634,  1635,  1636,  1637,  1638,  1639,
+    1640,  1641,  1642,  1593,  1644,  1645,  1646,  1647,  1648,  1649,
+    1607,  1651,  1613,     0,  1652,     0,   863,   980,   496,   978,
+    1107,     0,  1088,  1094,  1028,     0,  1108,  1757,  1758,  1759,
+    1760,  1761,  1762,  1763,  1764,  1765,  1766,  1767,  1768,  1769,
+    1770,  1771,  1772,  1773,  1774,  1775,  1776,  1777,  1778,  1779,
+    1780,  1781,  1782,  1783,  1784,  1785,  1786,  1787,  1788,  1789,
+    1790,  1791,  1792,  1793,  1794,  1795,  1796,  1797,  1798,  1799,
+    1800,  1801,  1802,  1803,  1804,  1805,  1806,  1807,  1808,  1809,
+    1810,  1811,  1812,  1813,  1814,  1815,  1816,  1817,  1818,  1819,
+    1820,  1821,  1822,  1823,  1824,  1825,  1826,  1827,  1828,  1829,
+    1717,  1830,  1831,  1832,  1833,  1834,  1025,  1068,  1110,  1109,
     1111,  1031,     0,     0,   420,     0,     0,  1121,     0,  1102,
-       0,     0,  1376,   170,  1376,   313,     0,   313,     0,     0,
+       0,     0,  1377,   170,  1377,   313,     0,   313,     0,     0,
     1134,  1137,   377,   373,   371,   370,   372,   717,   704,   712,
      711,     0,   694,   693,   692,     0,   691,     0,     0,   718,
      718,   716,   695,   671,     0,     0,     0,   722,     0,   720,
@@ -3305,7 +3305,7 @@ static const yytype_uint16 yydefact[] =
      354,     0,     0,     0,   348,     0,   135,     0,   183,  1176,
     1177,  1175,     0,     0,  1159,   186,   203,  1170,  1179,  1169,
     1178,  1158,  1153,     0,  1150,   411,  1195,  1194,  1203,   165,
-       0,   983,     0,   135,  1241,  1252,     0,   855,   977,  1021,
+       0,   983,     0,   135,  1241,  1253,     0,   855,   977,  1021,
        0,     0,     0,     0,     0,     0,   861,   986,     0,     0,
      782,     0,     0,     0,  1001,     0,  1007,     0,     0,     0,
      783,   763,   764,     0,  1049,  1058,   976,     0,   859,   972,
@@ -3323,7 +3323,7 @@ static const yytype_uint16 yydefact[] =
     1085,   542,   516,   541,     0,     0,   520,     0,   546,   759,
      581,   452,   510,   511,   514,   451,     0,   584,     0,   594,
      582,   515,     0,  1235,  1247,     0,     0,     0,     0,     0,
-    1376,     0,     0,    77,    58,   264,     0,   121,     0,     0,
+    1377,     0,     0,    77,    58,   264,     0,   121,     0,     0,
        0,     0,     0,     0,     0,    85,    82,    83,    84,     0,
        0,     0,     0,   187,   188,   201,     0,   192,   193,   190,
      194,   195,     0,     0,   180,   181,     0,     0,     0,     0,
@@ -3332,10 +3332,10 @@ static const yytype_uint16 yydefact[] =
      410,   321,     0,   311,     0,     0,     0,     0,     0,     0,
      348,  1127,  1125,  1123,  1126,  1128,  1103,     0,     0,     0,
        0,   167,   169,     0,   310,   283,     0,  1139,   394,     0,
-       0,  1376,  1136,   300,     0,     0,     0,     0,   385,     0,
+       0,  1377,  1136,   300,     0,     0,     0,     0,   385,     0,
      715,   714,   666,   662,     0,     0,     0,     0,   390,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,   385,
-     382,   385,  1064,     0,   385,   174,     0,  1376,   313,     0,
+     382,   385,  1064,     0,   385,   174,     0,  1377,   313,     0,
     1155,  1172,   184,   204,   185,   205,   443,     0,   417,   425,
      430,   408,     0,   408,     0,   427,   431,   408,   426,   408,
      421,     0,   166,     0,  1115,     0,  1114,     0,  1033,     0,
@@ -3352,17 +3352,17 @@ static const yytype_uint16 yydefact[] =
      808,   812,   785,   800,     0,   781,     0,  1035,   967,   969,
        0,   965,     0,   771,   772,   773,   765,   766,   767,   768,
      769,   770,   777,   943,   941,   942,     0,     0,     0,   908,
-     805,     0,     0,   807,   806,  1039,  1368,  1405,     0,   484,
+     805,     0,     0,   807,   806,  1039,  1369,  1406,     0,   484,
      484,   484,   472,   482,     0,   651,   496,  1050,   651,     0,
      758,   640,  1106,  1223,  1211,  1212,   973,  1105,   135,     0,
     1231,     0,     0,     0,   141,   124,     0,  1229,     0,   157,
      159,   600,     0,  1032,   504,   505,   509,   509,     0,     0,
-     509,  1603,  1494,     0,     0,     0,     0,   547,   589,     0,
+     509,  1604,  1495,     0,     0,     0,     0,   547,   589,     0,
      580,   544,   545,     0,   543,  1072,   548,  1071,   549,   552,
      553,   521,   590,  1059,   592,     0,   585,   456,   455,   596,
-       0,    43,     0,  1376,    60,     0,     0,     0,     0,     0,
-       0,   218,   255,   218,    98,  1376,   385,  1376,   385,  1273,
-    1342,  1510,     0,    56,    89,     0,   288,   115,     0,   273,
+       0,    43,     0,  1377,    60,     0,     0,     0,     0,     0,
+       0,   218,   255,   218,    98,  1377,   385,  1377,   385,  1274,
+    1343,  1511,     0,    56,    89,     0,   288,   115,     0,   273,
      318,    79,    94,   108,     0,     0,    45,   177,   191,   196,
      111,   200,   197,  1144,   198,   122,     0,    41,     0,   109,
        0,  1142,     0,     0,    47,   113,  1146,   494,   494,   494,
@@ -3370,7 +3370,7 @@ static const yytype_uint16 yydefact[] =
        0,   312,     0,   419,   399,   400,   410,     0,   313,     0,
      313,  1124,     0,     0,  1104,   105,     0,     0,     0,     0,
      303,   301,   334,     0,   308,   302,   311,     0,     0,   259,
-       0,  1267,     0,     0,   395,   391,     0,     0,     0,   684,
+       0,  1268,     0,     0,   395,   391,     0,     0,     0,   684,
      697,   358,   671,     0,   725,   724,   726,   726,   671,     0,
      657,     0,   669,     0,   709,   678,   751,   752,   753,   754,
      755,   756,   757,   351,   353,     0,   355,     0,     0,     0,
@@ -3386,7 +3386,7 @@ static const yytype_uint16 yydefact[] =
        0,     0,     0,     0,   811,   799,     0,   809,   813,     0,
        0,     0,   793,     0,     0,   791,   823,   787,     0,     0,
      824,     0,     0,   907,   916,   484,   484,   484,   484,   481,
-     483,     0,     0,     0,     0,  1494,     0,   623,   603,   599,
+     483,     0,     0,     0,     0,  1495,     0,   623,   603,   599,
      601,   610,   623,   628,   872,   649,   873,  1090,     0,   559,
      494,  1058,   559,     0,  1198,  1214,     0,  1232,     0,   146,
      128,   148,   147,     0,   155,     0,  1032,     0,   146,   130,
@@ -3400,8 +3400,8 @@ static const yytype_uint16 yydefact[] =
        0,     0,     0,     0,     0,   496,   492,   493,   864,  1027,
      441,   442,   182,   440,   322,     0,     0,   310,     0,  1139,
     1122,   348,     0,     0,   104,   106,     0,   170,   313,     0,
-     287,   283,   309,   281,   280,   282,     0,  1268,   175,     0,
-    1262,  1138,     0,     0,  1133,   703,   668,     0,   721,   719,
+     287,   283,   309,   281,   280,   282,     0,  1269,   175,     0,
+    1263,  1138,     0,     0,  1133,   703,   668,     0,   721,   719,
      667,     0,   663,   670,   385,     0,   444,     0,   403,   439,
      428,   433,     0,   437,   435,   434,   429,   432,     0,  1019,
     1015,     0,   874,   985,     0,   971,   999,   998,   829,   841,
@@ -3420,15 +3420,15 @@ static const yytype_uint16 yydefact[] =
      218,     0,     0,    59,     0,   332,   275,   324,   307,   290,
        0,     0,     0,   219,     0,   295,     0,    51,    71,     0,
       67,     0,    96,     0,     0,     0,     0,     0,    54,    66,
-       0,    49,     0,   385,   385,    57,   274,  1098,  1652,  1653,
-    1654,  1655,  1656,  1657,  1658,  1659,  1660,  1661,  1662,  1663,
-    1664,  1665,  1666,  1667,  1745,  1668,   225,  1669,  1441,  1670,
-    1671,  1672,     0,  1673,   660,  1674,  1675,  1676,   946,   947,
+       0,    49,     0,   385,   385,    57,   274,  1098,  1653,  1654,
+    1655,  1656,  1657,  1658,  1659,  1660,  1661,  1662,  1663,  1664,
+    1665,  1666,  1667,  1668,  1746,  1669,   225,  1670,  1442,  1671,
+    1672,  1673,     0,  1674,   660,  1675,  1676,  1677,   946,   947,
      223,   317,   220,   325,   222,   224,     0,  1099,   221,   320,
      112,  1145,     0,   110,     0,  1143,   119,   117,   114,  1147,
-     867,   868,   865,   494,   422,   402,     0,     0,  1267,     0,
-       0,  1376,     0,   103,     0,  1139,   168,   310,     0,   340,
-     259,   335,     0,  1267,  1265,     0,  1261,     0,     0,     0,
+     867,   868,   865,   494,   422,   402,     0,     0,  1268,     0,
+       0,  1377,     0,   103,     0,  1139,   168,   310,     0,   340,
+     259,   335,     0,  1268,  1266,     0,  1262,     0,     0,     0,
      664,   658,   356,     0,   416,     0,   436,  1018,   890,   901,
      997,     0,     0,     0,     0,   896,   891,  1055,  1056,  1051,
      820,   818,   815,     0,   816,   794,     0,     0,   792,   788,
@@ -3442,21 +3442,21 @@ static const yytype_uint16 yydefact[] =
        0,     0,   276,     0,     0,     0,   239,     0,     0,   307,
        0,   314,   235,   236,   349,     0,     0,     0,    63,    53,
       50,    55,    64,     0,     0,    65,    68,   656,    80,    73,
-    1745,  1752,     0,     0,     0,     0,     0,     0,   398,   405,
-     182,     0,     0,   283,  1264,     0,     0,     0,   310,   107,
-       0,     0,     0,  1267,     0,     0,   215,     0,   256,     0,
-     172,  1266,     0,  1254,     0,  1131,  1132,     0,     0,   404,
+    1746,  1753,     0,     0,     0,     0,     0,     0,   398,   405,
+     182,     0,     0,   283,  1265,     0,     0,     0,   310,   107,
+       0,     0,     0,  1268,     0,     0,   215,     0,   256,     0,
+     172,  1267,     0,  1255,     0,  1131,  1132,     0,     0,   404,
      847,     0,     0,     0,  1053,   817,   821,   819,   796,   905,
      921,   918,   644,     0,   647,   611,     0,     0,   526,   533,
        0,   536,   530,     0,   613,     0,     0,   615,   617,     0,
-       0,     0,   652,     0,     0,     0,  1067,   557,  1317,  1586,
-    1493,   558,     0,   562,   556,   560,   565,   567,   566,   568,
+       0,     0,   652,     0,     0,     0,  1067,   557,  1318,  1587,
+    1494,   558,     0,   562,   556,   560,   565,   567,   566,   568,
      564,   575,     0,   578,  1077,   578,     0,     0,     0,     0,
      161,     0,   152,   152,     0,   138,   961,     0,   218,     0,
      306,   329,   254,     0,     0,   237,     0,   244,     0,   278,
      279,   277,   238,   307,   313,   240,     0,   350,     0,    72,
        0,    88,     0,     0,   319,   120,   118,   866,   422,     0,
-    1139,   259,  1261,     0,     0,     0,   283,   175,  1263,   272,
+    1139,   259,  1262,     0,     0,     0,   283,   175,  1264,   272,
      265,   266,   267,   268,   269,   270,   271,   286,   285,   257,
      258,     0,     0,     0,  1133,     0,   848,     0,   849,     0,
      496,   649,     0,     0,   643,     0,   524,   522,   525,   527,
@@ -3465,20 +3465,20 @@ static const yytype_uint16 yydefact[] =
        0,     0,   529,   529,     0,   132,     0,   651,     0,     0,
      154,   154,   140,     0,   313,   331,     0,   298,   305,   297,
        0,     0,   234,     0,   241,   339,   243,   227,   655,     0,
-      75,     0,   326,   397,   401,     0,   217,  1255,   310,     0,
-    1261,   259,  1267,     0,  1258,     0,     0,  1139,   850,     0,
+      75,     0,   326,   397,   401,     0,   217,  1256,   310,     0,
+    1262,   259,  1268,     0,  1259,     0,     0,  1139,   850,     0,
      924,   642,   645,     0,   618,     0,     0,     0,   653,   654,
      626,     0,     0,     0,   561,     0,     0,   577,     0,   460,
      459,   127,   152,   131,   162,   151,   506,   153,   506,     0,
      339,   284,     0,     0,   262,   227,     0,   253,     0,    69,
-      87,   327,     0,   310,  1256,   216,   173,  1259,  1260,     0,
+      87,   327,     0,   310,  1257,   216,   173,  1260,  1261,     0,
      651,   920,     0,     0,     0,     0,   534,     0,   540,   635,
      571,     0,   570,   912,   913,   531,   154,   509,   509,   651,
      253,   299,   304,     0,   242,   245,   336,   337,   338,     0,
-     249,   246,   250,     0,  1261,     0,  1129,  1574,  1318,  1545,
+     249,   246,   250,     0,  1262,     0,  1129,  1575,  1319,  1546,
        0,   922,   925,   923,   917,   646,     0,     0,   532,   572,
      528,   506,   143,   142,   139,   218,   261,     0,     0,     0,
-     251,     0,   252,   226,  1257,  1139,     0,   929,   928,   927,
+     251,     0,   252,   226,  1258,  1139,     0,   929,   928,   927,
      931,   930,   535,     0,   509,   333,   231,     0,   230,     0,
      316,   248,   651,     0,     0,   144,   229,   233,   232,  1130,
      926,   539
@@ -3888,7 +3888,7 @@ static const yytype_int16 yypgoto[] =
    positive, shift that token.  If negative, reduce the rule which
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -1756
+#define YYTABLE_NINF -1757
 static const yytype_int16 yytable[] =
 {
      479,   475,   940,  1004,   804,   728,  1144,    61,   970,  1183,
@@ -3903,10 +3903,10 @@ static const yytype_int16 yytable[] =
      618,  1596,  -726,   610,  2182,  2183,  2184,   821,   611,  1798,
     2086,  -726,  -723,  -446,  2345,  -718,  -723,  1190,  2289,  1190,
      626,   805,  1181,   549, -1070,  2086,   549,   821, -1095, -1095,
-     483,  2839,  -449,  1145,  1686, -1642, -1092, -1092,  1801, -1631,
-    1190, -1642, -1649,  1227, -1754, -1754,  1230, -1734, -1734, -1745,
-   -1745, -1649,  2594, -1096, -1631,   929,  2206,  1516,   922, -1752,
-   -1752, -1096,  1233,  2684,  -685,  -698,  -713,   821,  1419, -1093,
+     483,  2839,  -449,  1145,  1686, -1643, -1092, -1092,  1801, -1632,
+    1190, -1643, -1650,  1227, -1755, -1755,  1230, -1735, -1735, -1746,
+   -1746, -1650,  2594, -1096, -1632,   929,  2206,  1516,   922, -1753,
+   -1753, -1096,  1233,  2684,  -685,  -698,  -713,   821,  1419, -1093,
    -1093,   549,   549,  1748,   963,  1369,  1238,  2779,  2147,    57,
     1316,   821,  1614,     3,     4,   966,   587,  1992,  1366,  1238,
      549,   728,  2656,  -182,   821,    57,  1190,  1447,  -182,  2732,
@@ -3921,7 +3921,7 @@ static const yytype_int16 yytable[] =
     2792,  1181,  2841,   546,   590,  1173,   804,  2732,  2658,  2755,
     2148,  2824,   604,   601,  1456,  2494,  1489,  1774,   728,  2397,
     1367,   959,  1296,  1490,   959,  1463,   960,  1182,  1401,  1164,
-    2908,   564,  2591, -1731, -1731,  1819,  1819,  2654,   719,  2749,
+    2908,   564,  2591, -1732, -1732,  1819,  1819,  2654,   719,  2749,
      930,    84,   931,  1141,  1316,  1961,  1184,  2354,  2386,   487,
     1962,  1439,   953,  1184,  2996,  2257,  1474,  2783,  1224,  1308,
     2551,  2632,  2373,  2763,  2555,   721,  2821,  2932,  1185,  2784,
@@ -3952,13 +3952,13 @@ static const yytype_int16 yytable[] =
     -963,  1186,  1712,  1536,   479,  1442,  2096,  2926,  2194,   932,
     1188,  -723,   612,   933,  -718,  1540,  1541,  2674,  -446,  1787,
     -446,   630,  1311, -1070,  1569,   631,    61, -1095, -1095,    56,
-    2585,   610,    44,   807, -1642,  1289,   611,  -449, -1631,  -449,
-   -1642, -1649,   951,  1052,   479,  1138,    54,    76,  2596,  2865,
-   -1649,  1746, -1096, -1631,  1871,  1474,   942,  2872,  1179,  1180,
+    2585,   610,    44,   807, -1643,  1289,   611,  -449, -1632,  -449,
+   -1643, -1650,   951,  1052,   479,  1138,    54,    76,  2596,  2865,
+   -1650,  1746, -1096, -1632,  1871,  1474,   942,  2872,  1179,  1180,
    -1096,  1932,  2871,  1171,  1175,  -713,  1578,  1242,  1243,  1345,
     1360,  1749,  1598,    57,   728,   728,  2007,  2512,   613,  1475,
     1242,  1243,  2998,  1761,  -182,  -182,  1469,  2582,   809,   728,
-   -1729, -1729,  1456,    83,   719,   719,  2101,   629,  1597,   810,
+   -1730, -1730,  1456,    83,   719,   719,  2101,   629,  1597,   810,
     1296,  1938,  1940,  2170,  1604,  2004,  2005,  2006,  2007,   719,
     2086,   654,  1598,  1141,  2086,  2816,  2171,  1650,   730,   657,
     2637,   721,   721,  1316,   804,    57,   596,  2263,   630,   658,
@@ -3978,38 +3978,38 @@ static const yytype_int16 yytable[] =
      721,  1847,  1645,   536,  1450,  1762,  2264,  1840,  1574,  1456,
      479,   814,    34,   821,  3012,  1480,  2265,  1406,   815,  1695,
     -495,   597,  1689,  1508,  1457,  -495,    31,  1677,  1300,   630,
-     479,   479,   479,  1363,   479,   479,    35,   722,  1811, -1730,
-   -1730,  1506,   487,  1645,  1645,  1404,  1696,  1867,  1868,  1869,
-     537,   961,   820, -1732, -1732,  1992,  2389,  2303,   479,  2086,
-   -1756, -1756, -1756,  1206,  1207,  1846,  1407,    33,  2086,   977,
+     479,   479,   479,  1363,   479,   479,    35,   722,  1811, -1731,
+   -1731,  1506,   487,  1645,  1645,  1404,  1696,  1867,  1868,  1869,
+     537,   961,   820, -1733, -1733,  1992,  2389,  2303,   479,  2086,
+   -1757, -1757, -1757,  1206,  1207,  1846,  1407,    33,  2086,   977,
     1137,  2185,   816,  2086,    26,   978,  2086,   803,   803,   642,
       34,   643,  2115,   728,  1857,  1454,  2121,  2173,    88,  1864,
     2176,  1405,  2177,  -495,  2124,  2086,    89,   921,  1921,   821,
      962,  2687,   488,   719,    35,  1236,  2688,  1918,  1237,   936,
-      31,   479,  2646, -1733, -1733,   479,   479,   724,    36,  1943,
+      31,   479,  2646, -1734, -1734,   479,   479,   724,    36,  1943,
     1379,  1944,   927,  1380,  1946,  1408,   479,  2181,  2845,   951,
      721,    90,  1247,   656,    57,  2214,  1907,  2849,  1908,  1247,
     2221,  2390,  -495,  2382,   730,  2384,    26,  1393,  1394,  1893,
     1400,    33,   611,   611,   943,   611,   742,  1822,  1697,  1508,
      649,  1457,   739,  1698,    34,   944,  1457,   722,  1699,  1052,
-    1849,   946,  1276,  1210,  1211,  1852,  1052,   649,    91, -1735,
-   -1735,   979,    31,  2086, -1736, -1736,  1481,   728,    35,  2002,
+    1849,   946,  1276,  1210,  1211,  1852,  1052,   649,    91, -1736,
+   -1736,   979,    31,  2086, -1737, -1737,  1481,   728,    35,  2002,
     2003,  2004,  2005,  2006,  2007,  1592,   650,  1052,  1593,   949,
     1407,  1457,  1763,   977,   947,   804,  2391,   719,  2392,   978,
     1298,   917,   918,   650,   920,  2086,   950,  1310,   804,    26,
      972,   594,  1454,    33,  2805,   974,  1313,  1454,  2020,   957,
-    2652,   651,   728,  2336,   721,  1960,    34, -1737, -1737,  1964,
+    2652,   651,   728,  2336,   721,  1960,    34, -1738, -1738,  1964,
     1361,  1965,  2805,  2317,  2318,  2319,  2320,  1511,  2202,   988,
     1512,  1371,   719,  1247,  1247,    31,  1514,  2120,  1515,  1408,
       35,  1930,  1454,  2065,  2041,  2066,   630,  2337, -1070,  2561,
-     631,   722,  2564,   492,    36,   493, -1738, -1738,   652,   721,
+     631,   722,  2564,   492,    36,   493, -1739, -1739,   652,   721,
     2903,   975,   977,  2557,   609,   609,  1594,   609,   978,  1595,
      976,  1636,  2339,   724,  1757,   652,    33,  1229,  1881,   989,
      496,  1882,  1138,  1006,  2090,  2019,  1967,  2021,  2022,  1700,
     2523,  1914,  1052,  1010,  1593,   979,   722,   977,  2086,  2408,
-    1701, -1739, -1739,   978,  1300,   479,  2239,  2401, -1740, -1740,
+    1701, -1740, -1740,   978,  1300,   479,  2239,  2401, -1741, -1741,
     1998,   730,   730,  1922,   980,  1142,  1595,  1340,  1341,  1342,
-    1343,  1344,  1345, -1741, -1741,  1928,   730,    36,  1929,  1645,
+    1343,  1344,  1345, -1742, -1742,  1928,   730,    36,  1929,  1645,
     1645,  1645,  1645,  2887,  2086,  1645,  1645,  1645,  1645,  1645,
     1645,  1645,  1645,  1645,  1645,  1143,  2982,  2983,  2383,  2474,
      977,  2043,  1146,  2966,   990,  3005,   978,  2400,  1148,  2409,
@@ -4018,31 +4018,31 @@ static const yytype_int16 yytable[] =
      724,   563,   800,    61,   956,   576,   958,  1138,  1158,  1645,
     1645,  2228,  2229,  2341,  2556,  2365,  2559,  2199,  2168,   983,
      479,  2169,   479,  3015,  1160,   479,   479,  2209,   977,   979,
-      61, -1742, -1742,   636,   978,   479,   634,   479,   479,   479,
+      61, -1743, -1743,   636,   978,   479,   634,   479,   479,   479,
      479,   479,   479,   479,   992,  2086,  1162,    26,  1167,  2670,
      635,   638,  1627,  1628,  1629,  3019,  1630,  1631,  1632,  1633,
     1634,  1635,  1171,   479,  2363,   479,  1175,  2364,   980,  1174,
-     730,   479,   479,   479,   479,  1138, -1743, -1743,  2368,   479,
+     730,   479,   479,   479,   479,  1138, -1744, -1744,  2368,   479,
      479,  2369,   979,    31,   479,  1177,   984,  2485,   479,  1178,
     1882,   479,   479,   479,   479,   479,   479,   479,   479,   479,
     2504,  1194,   479,  2505,  1578,  2524,  2675,   479,  1595,  1595,
      479,   479,  1195,  2742,  1052,  2045,  2743,  1138,  2770,  1007,
-    2046,  1882,  2673,   982,    33, -1756, -1756, -1756,  2335,  2002,
+    2046,  1882,  2673,   982,    33, -1757, -1757, -1757,  2335,  2002,
     2003,  2004,  2005,  2006,  2007,   993,   479,    34,  2798,  2747,
      979,  1595,  2335,   728,  1197,   933,  2801,   980,  2818,  2802,
     2121,  2819,  2822,  1008,  1225,  2819,  1228,   479,  1765,  1735,
     1231,    35,  1232,   719,  2837,    57,  1234,  2838,   479,   479,
-   -1744, -1744,  1235,   594,  2450,    36,  1598,  1253,  2408,   724,
+   -1745, -1745,  1235,   594,  2450,    36,  1598,  1253,  2408,   724,
      804,  2877,   980,  1263,  2838,   994,  2598,  1264,  2878,  1266,
      721,  1595,    57,   995,  2890,  2284,  2911,  2819,  1011,  2912,
      730,  1268,   982,  -689,  2336,   996,  1138,  1619,  1138,  2796,
-    2936,   728,  2586,  2937, -1746, -1746,  2975,  1822,  2336,  2819,
-     984,  2995, -1747, -1747,  2838, -1748, -1748,   722,  -696,   728,
-    2546,   719,  1012,  1810,  2601,   980,   997,   982,  2337, -1749,
-   -1749, -1750, -1750,  2234,  2546, -1751, -1751,  1052,  1271,   719,
+    2936,   728,  2586,  2937, -1747, -1747,  2975,  1822,  2336,  2819,
+     984,  2995, -1748, -1748,  2838, -1749, -1749,   722,  -696,   728,
+    2546,   719,  1012,  1810,  2601,   980,   997,   982,  2337, -1750,
+   -1750, -1751, -1751,  2234,  2546, -1752, -1752,  1052,  1271,   719,
      479,   479,  2337,   479,  2338,   728,  1693,  1273,   721,   977,
-    1598,  2047,   728,  2339,  -686,   978,  1272,   983,  2338, -1753,
-   -1753,  1138,  2048, -1755, -1755,   719,   721,  2339,  1496,  1497,
+    1598,  2047,   728,  2339,  -686,   978,  1272,   983,  2338, -1754,
+   -1754,  1138,  2048, -1756, -1756,   719,   721,  2339,  1496,  1497,
     2797,  1274,   719,   999,   479,  2251,   728,  1799,  1800,   479,
      982,  2350,  2603,   980,  1275,   722,  1911,  2340,    36,   984,
     1750,  1277,   721,  2258,   730,  1000,   719,  -547,  -547,   721,
@@ -4108,12 +4108,12 @@ static const yytype_int16 yytable[] =
     2544,  2550,  2560,  2566,   820,  2565,   492,  1992,   493,   728,
     2567,  2568,  1993,  1994,  1995,  2570,  2581,  2450,   721,  1138,
     2587,  2588,  2589,  1138,  2457,  1138,  2593,  2404,  2617,   719,
-     495,  2618,  2622,   496,  2635,  2634, -1092, -1729,  2645, -1730,
-     728, -1731,   926,   728, -1732,  2453, -1733,  2636,   993, -1734,
-   -1735,   993, -1736,  1587, -1737,   722,   721,  1298,  2880,  2643,
-     719,  1588,  2647,   719, -1738, -1739, -1740, -1741,  2478,  2648,
-   -1742,  2910, -1743, -1744,   973, -1746, -1747, -1748,  2661, -1749,
-   -1750,  2664, -1751, -1752, -1753,   730, -1754,   721,  1298, -1755,
+     495,  2618,  2622,   496,  2635,  2634, -1092, -1730,  2645, -1731,
+     728, -1732,   926,   728, -1733,  2453, -1734,  2636,   993, -1735,
+   -1736,   993, -1737,  1587, -1738,   722,   721,  1298,  2880,  2643,
+     719,  1588,  2647,   719, -1739, -1740, -1741, -1742,  2478,  2648,
+   -1743,  2910, -1744, -1745,   973, -1747, -1748, -1749,  2661, -1750,
+   -1751,  2664, -1752, -1753, -1754,   730, -1755,   721,  1298, -1756,
      721,  2662,  2496,   722, -1093,  2891,  2667,  2893,   994,  2668,
     2671,   994,   479,  2324,  1589,  2327,   995,  2672,  2686,   995,
     1153,  1155,  1157,  2699,  2820,  2726,  2704,  2820,   996,  2722,
@@ -4121,12 +4121,12 @@ static const yytype_int16 yytable[] =
     2739,  2744,  2757,  1999,  2000,  2001,  2756,  2002,  2003,  2004,
     2005,  2006,  2007,  2758,  2759,  2760,  2767,  2769,  2774,   997,
      479,   479,   997,  2775,  2776,   479,   730,  2963,  2858,  1322,
-     479,   585,  2803,   479,   479,  2848, -1756,   646,   479,  2789,
+     479,   585,  2803,   479,   479,  2848, -1757,   646,   479,  2789,
      647,  2790,  2799,  2811,   585,  2812,  2827,  2813,  2815,   506,
     2823,  2825,  2831,  2834,  2839,  2853,  2857,  2859,   479,  2084,
     2868,  1324,   479,  2084,  2862,   724,   999,  2873,  2874,   999,
     2455,  2875,  2879,  1198,  1199,  2883,   647,   506,   506,  2884,
-    2892,  2895,  2896, -1756,   479,  2898,  2909,  2913,  1000,  2752,
+    2892,  2895,  2896, -1757,   479,  2898,  2909,  2913,  1000,  2752,
     2915,  1000,  2916,   551,  2918,  2193,  2921,    57,  2922,  2923,
      476,  2927,  2574,  2576,   476,  2928,  2945,  2905,  1002,  2929,
     2218,  1002,   914,   914,   559,   559,  2938,   559,  1138,  2534,
@@ -4134,12 +4134,12 @@ static const yytype_int16 yytable[] =
     2974,  2040,  2977,   724,   725,  2986,   730,   506,  2979,  2997,
      719,  2989,  2991,  2987,  2988,  3013,  3002,  3003,   585,  1200,
     1201,   724,  1998,  3014,  3016,  3021,  2415,   948,  2411,  1842,
-     585,  2155, -1756,  2370,  2904,  2727,  2457,   721,  2949,  2486,
-    2577,  2625,  2955,  3011,  2852,  2992,  2985,   724, -1756,  2788,
-    1443,  2139,  2162, -1756,   724,  2491,  2951,  2416,  2990,  2135,
+     585,  2155, -1757,  2370,  2904,  2727,  2457,   721,  2949,  2486,
+    2577,  2625,  2955,  3011,  2852,  2992,  2985,   724, -1757,  2788,
+    1443,  2139,  2162, -1757,   724,  2491,  2951,  2416,  2990,  2135,
     2950,  1538,  1559,  2236,  2453,  2195,   585,   585,   585,  2669,
     1384,  1422,  2475,  1808,   722,  1423,  1365,  2119,   724,  2886,
-    2900,  2980,  2129,  1202,  1203,  1204,  1205,  1206,  1207, -1756,
+    2900,  2980,  2129,  1202,  1203,  1204,  1205,  1206,  1207, -1757,
     1785,  1208,  1209,  2356,  2941,  2894,  -458,  2571,  2653,   803,
     2833,  1807,  2097,  2077,  1427,   479,  2329,  2077,   730,  2817,
     -458,   479,  2325,  2542,  2882,  -458,  2558,  2881,  2888,  2725,
@@ -4154,7 +4154,7 @@ static const yytype_int16 yytable[] =
        0,     0,  2379,     0,     0,     0,     0,     0,     0,     0,
     1486,     0,     0,     0,     0,   476,     0,  1999,  2000,  2001,
        0,  2002,  2003,  2004,  2005,  2006,  2007,  2413,  2457,     0,
-       0,  1265,  -458,     0,  1198,  1199, -1756,     0,     0,     0,
+       0,  1265,  -458,     0,  1198,  1199, -1757,     0,     0,     0,
        0,  -458,  2460,  2461,  2462,  2463,  2464,  2465,  2466,  2467,
     2468,  2469,     0,     0,  2649,  2772,     0,    57,     0,     0,
      724,   479,  2084,     0,     0,   479,   730,     0,     0,  1648,
@@ -4163,8 +4163,8 @@ static const yytype_int16 yytable[] =
        0,     0,   597,   479,  2084,     0,     0,   730,  1304,     0,
      730,     0,     0,   476,     0,     0,   479,     0,  1212,  1213,
     1200,  1201,     0,     0,     0,     0,     0,     0,  1322,   727,
-     479,  2077,     0,   479,     0, -1756,  2077,     0,  1214,  2077,
-       0,   724,     0,  1138,     0,   476, -1756,  1138,   479,     0,
+     479,  2077,     0,   479,     0, -1757,  2077,     0,  1214,  2077,
+       0,   724,     0,  1138,     0,   476, -1757,  1138,   479,     0,
     2724,   585,  1246,  1340,  1341,  1342,  1343,  1344,  1345,  1246,
     1324,  1519,     0,     0,     0,     0,  1562,     0,     0,   506,
      506,   820,     0,     0,  1992,   585,   585,  1391,     0,  1993,
@@ -4176,12 +4176,12 @@ static const yytype_int16 yytable[] =
     2050,   479,   585,     0,     0,   479,   585,     0,     0,     0,
        0,     0,   479,  2084,     0,  1568,  1312,    57,   476,     0,
        0,   724,     0,   630,  2901,     0,   946,   631,     0,     0,
-       0, -1756,     0,   479,     0,     0,     0,     0,  1996,     0,
-       0,  1246,     0,  1246,  1246,     0,   725, -1756,  2077,     0,
-       0,   724, -1756,   479,   476,     0,     0,     0,     0,     0,
+       0, -1757,     0,   479,     0,     0,     0,     0,  1996,     0,
+       0,  1246,     0,  1246,  1246,     0,   725, -1757,  2077,     0,
+       0,   724, -1757,   479,   476,     0,     0,     0,     0,     0,
     1997,  1298,     0,     0,     0,     0,   479,     0,  1210,  1211,
        0,     0,     0,     0,     0,   727,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,  1138,  2457, -1756,     0,
+       0,     0,     0,     0,     0,     0,  1138,  2457, -1757,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        0,     0,     0,   479,  2084,     0,   479,   479,     0,     0,
        0,  1246,  2964,     0,  1246,  1246,     0,     0,     0,  2864,
@@ -4196,7 +4196,7 @@ static const yytype_int16 yytable[] =
        0,  1200,  1201,     0,     0,     0,  1648,  1648,  1803,     0,
        0,  1648,     0,     0,     0,     0,     0,     0,     0,  1998,
        0,   647,   647,     0,   506,   506,     0,   506,   647,     0,
-       0,   585,     0,   725,   725, -1756,     0,     0,     0,     0,
+       0,   585,     0,   725,   725, -1757,     0,     0,     0,     0,
        0,     0,     0,   724,     0,     0,     0,     0,   725,     0,
     2746,     0,  1648,  1648,     0,     0,     0,     0,     0,     0,
        0,     0,     0,  2455,     0,  1202,  1203,  1204,  1205,  1206,
@@ -4206,10 +4206,10 @@ static const yytype_int16 yytable[] =
        0,     0,  2777,     0,     0,     0,  1546,     0,  1547,     0,
        0,     0,   724,     0,     0,   724,     0,  1553,     0,     0,
      647,     0,     0,     0,  1999,  2000,  2001,     0,  2002,  2003,
-    2004,  2005,  2006,  2007,  1554, -1756,     0,     0,     0,     0,
+    2004,  2005,  2006,  2007,  1554, -1757,     0,     0,     0,     0,
        0,     0,  1340,  1341,  1342,  1343,  1344,  1345,     0,     0,
        0,     0,     0,   914,   585,     0,     0,     0,     0,     0,
-       0,   727,  1573,  1575,     0,     0,     0,     0, -1534,     0,
+       0,   727,  1573,  1575,     0,     0,     0,     0, -1535,     0,
        0,     0,   725,  1997,     0,   585,     0,   585,  2835,  1210,
     1211,     0,     0,     0,     0,     0,  1767,     0,  1773,     0,
        0,     0,     0,     0,  1606,  1607,     0,     0,  1620,  1621,
@@ -4218,58 +4218,58 @@ static const yytype_int16 yytable[] =
     2004,  2005,  2006,  2007,   585,     0,     0,     0,     0,     0,
        0,     0,     0,  1446,   506,     0,     0,     0,     0,     0,
        0,     0,  1998,     0,   506,  1824,   506,  1828,     0,   506,
-       0,     0, -1536,     0,     0,   506,     0,   506,     0,     0,
-       0, -1534,     0,     0,     0,     0,     0,     0,   647,   506,
+       0,     0, -1537,     0,     0,   506,     0,   506,     0,     0,
+       0, -1535,     0,     0,     0,     0,     0,     0,   647,   506,
        0,     0,     0,   647,   506,     0,     0,     0,   506,   506,
      506,   506,     0,   506,   506,     0,     0,     0,     0,     0,
     1212,  1213,     0,     0,     0,     0,     0,     0,     0,     0,
        0,     0,   725,   585,   585,  1891,     0,     0,     0,     0,
-       0,     0,     0, -1534,     0,     0,     0,     0,  2069,     0,
-    1906,     0,   724,     0,     0,     0,     0, -1534,     0,     0,
-       0,     0, -1534,     0,  1797,  1797,     0, -1534,     0,     0,
-       0,     0,     0,     0,  1315, -1536, -1534,  1316,   727,   727,
-   -1534,     0,  1317,  1318,  1319,     0,     0,     0,  1648,  1648,
+       0,     0,     0, -1535,     0,     0,     0,     0,  2069,     0,
+    1906,     0,   724,     0,     0,     0,     0, -1535,     0,     0,
+       0,     0, -1535,     0,  1797,  1797,     0, -1535,     0,     0,
+       0,     0,     0,     0,  1315, -1537, -1535,  1316,   727,   727,
+   -1535,     0,  1317,  1318,  1319,     0,     0,     0,  1648,  1648,
     1648,  1648,     0,   727,  1648,  1648,  1648,  1648,  1648,  1648,
     1648,  1648,  1648,  1648,     0,     0,     0,  1322,     0,   820,
-       0, -1534,  1992,     0,  1323,     0,  1246,  1993,  1994,  1995,
-       0,     0,     0,     0,     0,     0,  1246, -1536,     0,  1246,
-   -1534,     0,     0,     0,  2526,     0,   725,     0,     0,  1324,
-       0, -1536,     0,     0,     0,     0, -1536,     0,  1648,  1648,
-       0, -1536,     0,     0,     0,     0,     0,     0,     0,     0,
-   -1536,     0,     0,     0, -1536,     0,     0,  1999,  2000,  2001,
-       0,  2002,  2003,  2004,  2005,  2006,  2007,     0,     0, -1534,
-       0,   725, -1534,     0,     0,     0,     0,     0, -1534,   506,
-       0,     0,     0,     0,     0, -1536,  1304,  2196,     0,     0,
+       0, -1535,  1992,     0,  1323,     0,  1246,  1993,  1994,  1995,
+       0,     0,     0,     0,     0,     0,  1246, -1537,     0,  1246,
+   -1535,     0,     0,     0,  2526,     0,   725,     0,     0,  1324,
+       0, -1537,     0,     0,     0,     0, -1537,     0,  1648,  1648,
+       0, -1537,     0,     0,     0,     0,     0,     0,     0,     0,
+   -1537,     0,     0,     0, -1537,     0,     0,  1999,  2000,  2001,
+       0,  2002,  2003,  2004,  2005,  2006,  2007,     0,     0, -1535,
+       0,   725, -1535,     0,     0,     0,     0,     0, -1535,   506,
+       0,     0,     0,     0,     0, -1537,  1304,  2196,     0,     0,
        0,  1931,  1933,     0,     0,     0,     0,  2207,  2208,  2210,
-       0,     0,     0,     0, -1536,     0,     0,   727,     0,     0,
-       0,     0, -1534,     0,     0,     0,     0,  2224,  1246,     0,
+       0,     0,     0,     0, -1537,     0,     0,   727,     0,     0,
+       0,     0, -1535,     0,     0,     0,     0,  2224,  1246,     0,
     1638,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-    1325,  1246,     0,     0,     0, -1534,     0,     0,     0,     0,
+    1325,  1246,     0,     0,     0, -1535,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,  1326,  1568,     0,     0,
-       0,  1327,     0, -1536,   585,     0, -1536,     0,     0,     0,
-    2087,     0, -1536,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0, -1756, -1756,  2087,     0,     0,     0,  2106,
+       0,  1327,     0, -1537,   585,     0, -1537,     0,     0,     0,
+    2087,     0, -1537,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0, -1757, -1757,  2087,     0,     0,     0,  2106,
        0,     0,  2109,     0,  1773,     0,     0,  1330,     0,  1315,
-    2070,     0,  1316,     0,     0,     0, -1536, -1756, -1756, -1756,
+    2070,     0,  1316,     0,     0,     0, -1537, -1757, -1757, -1757,
        0,     0,     0,     0,     0,     0,   820,     0,  1997,  1992,
-       0,     0,     0,     0,  1993,  1994,  1995, -1534,     0, -1536,
-       0,     0,  1322,     0,     0, -1534,     0,     0, -1756,  1323,
+       0,     0,     0,     0,  1993,  1994,  1995, -1535,     0, -1537,
+       0,     0,  1322,     0,     0, -1535,     0,     0, -1757,  1323,
        0,  2527,     0,     0,     0,     0,  1503,   727,     0,     0,
-       0, -1534,  1333, -1534, -1534,     0,     0,     0,     0,     0,
+       0, -1535,  1333, -1535, -1535,     0,     0,     0,     0,     0,
        0,     0,     0,     0,  1324,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        0,  2321,  2322,  2323,  2070,     0,     0,  1998,     0,     0,
-   -1534,     0,     0, -1534, -1534, -1534,     0,     0,     0,  2093,
+   -1535,     0,     0, -1535, -1535, -1535,     0,     0,     0,  2093,
        0,     0,     0,     0,     0,     0,     0,     0,  1503,     0,
-       0, -1536,     0,   585,     0,     0,     0,     0,     0, -1536,
+       0, -1537,     0,   585,     0,     0,     0,     0,     0, -1537,
        0,     0,  1503,   585,   585,   585,     0,     0,     0,     0,
-       0,     0,     0,  2125,  2125, -1536,   506, -1536, -1536,     0,
+       0,     0,     0,  2125,  2125, -1537,   506, -1537, -1537,     0,
     2378,     0,     0,   585,  1335,     0,     0,     0,     0,     0,
        0,   727,     0,     0,     0,  2231,     0,     0,  1315,     0,
        0,  1316,     0,     0,     0,  1325,     0,     0,     0,     0,
-       0,   647,     0,   585, -1536,     0,     0, -1536, -1536, -1536,
+       0,   647,     0,   585, -1537,     0,     0, -1537, -1537, -1537,
        0,  1326,     0,     0,     0,     0,  1327,     0,  1503,  1503,
-       0,  1322,   725,     0,     0,     0,   727,     0, -1756,     0,
+       0,  1322,   725,     0,     0,     0,   727,     0, -1757,     0,
        0,     0,     0,     0,     0,     0,  1315,     0,     0,  1316,
        0,  1638,  2482,     0,  1317,  1318,  1319,     0,     0,     0,
        0,     0,  1330,  1324,     0,  1997,     0,     0,     0,     0,
@@ -4282,13 +4282,13 @@ static const yytype_int16 yytable[] =
     2006,  2007,     0,  2306,  1998,     0,     0,   585,   585,   585,
      477,     0,  2087,  2333,   725,     0,  1648,     0,  2333,  2347,
        0,   725,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0, -1756,     0,     0,  2537,  2538,  2539,
+       0,     0,     0,     0, -1757,     0,     0,  2537,  2538,  2539,
     2540,     0,     0,     0,     0,   725,     0,     0,  1773,     0,
-   -1756,     0,     0,     0,     0, -1756,     0,     0,     0,     0,
+   -1757,     0,     0,     0,     0, -1757,     0,     0,     0,     0,
        0,     0,     0,     0,   897,   897,   585,     0,   506,     0,
        0,     0,  1503,  1446,  1503,     0,  1533,     0,     0,  1335,
        0,     0,  1325,     0,     0,     0,     0,     0,     0,     0,
-       0, -1756,     0,   506,     0,  2414,     0,     0,  1326,     0,
+       0, -1757,     0,   506,     0,  2414,     0,     0,  1326,     0,
        0,     0,     0,  1327,     0,     0,  1648,     0,   506,   506,
      506,   506,   506,   506,   506,   506,   506,   506,     0,     0,
        0,     0,     0,     0,     0,  1328,  1329,  1047,  1054,     0,
@@ -4297,12 +4297,12 @@ static const yytype_int16 yytable[] =
        0,     0,     0,     0,     0,     0,     0,     0,     0,  1533,
        0,     0,     0,     0,     0,     0,   725,     0,     0,     0,
        0,   585,     0,     0,     0,     0,  1648,  1331,  1503,  1336,
-    1332,     0, -1756, -1756, -1756,     0,  1340,  1341,  1342,  1343,
+    1332,     0, -1757, -1757, -1757,     0,  1340,  1341,  1342,  1343,
     1344,  1345,     0,     0,  1333,     0,     0,  1334,     0,  1999,
     2000,  2001,     0,  2002,  2003,  2004,  2005,  2006,  2007,     0,
        0,     0,     0,     0,     0,     0,     0,   727,     0,     0,
        0,     0,   506,     0,     0,     0,     0,   725,  2519,     0,
-    1246,     0,     0,     0,     0,     0,     0,     0, -1756,  1315,
+    1246,     0,     0,     0,     0,     0,     0,     0, -1757,  1315,
        0,     0,  1316,     0,     0,     0,     0,  1317,  1318,  1319,
        0,  2536,     0,   585,   585,   585,   585,     0,     0,     0,
     2333,  2347,     0,  2333,  1320,     0,  2545,     0,     0,     0,
@@ -4312,7 +4312,7 @@ static const yytype_int16 yytable[] =
     2106,   487,     0,   727,  1324,  1773,     0,     0,  1047,     0,
        0,  1638,     0,     0,     0,     0,     0,  1446,     0,     0,
        0,     0,     0,  1503, -1141,  1269,     0,     0,  2754,   727,
-       0,     0,     0,     0,     0,     0,   727,     0, -1756,     0,
+       0,     0,     0,     0,     0,     0,   727,     0, -1757,     0,
        0,     0,     0,  2626,     0,  1340,  1341,  1342,  1343,  1344,
     1345,     0,     0,     0,  1280,     0,     0,     0,     0,     0,
      727,   488,     0,     0,     0,     0,  2773,     0,   489,     0,
@@ -4323,59 +4323,59 @@ static const yytype_int16 yytable[] =
        0,     0,  1503,     0,     0,   490,     0,     0,     0,     0,
        0,  1326,     0,  1906,     0,     0,  1327,     0,     0,     0,
        0,     0,     0,     0,  2665,     0,     0,     0,   725,     0,
-       0,     0,     0,     0,     0,     0,     0, -1550,  1328,  1329,
+       0,     0,     0,     0,     0,     0,     0, -1551,  1328,  1329,
        0,  1315,     0,     0,  1316,  1399,     0,  2844,     0,  1413,
     1418,  1246,  1330,     0,     0,     0,  1246,     0,     0,     0,
     2681,     0,     0,     0,     0,     0,     0,     0,     0,   477,
     2333,   727,     0,  2692,  1322,   491,   506,     0,  2087,     0,
-       0, -1756,     0,  2087,  2869,     0,  2087,     0,  2703,     0,
+       0, -1757,     0,  2087,  2869,     0,  2087,     0,  2703,     0,
     1331,  2706,     0,  1332,     0,     0,     0,     0,  1573,  1575,
      725,     0,     0,  1047,     0,  2733,  1324,  1333,     0,     0,
     1047,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        0,     0,   492,     0,   493,   647,   506,     0,     0,     0,
-   -1550,  1047,   727,     0,   585,     0,     0,     0,     0,     0,
+   -1551,  1047,   727,     0,   585,     0,     0,     0,     0,     0,
      494,     0,     0,     0,  1348,     0,   495,     0,     0,   496,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        0,   506,   506,     0,     0,     0,     0,     0,     0,     0,
        0,     0,   585,     0,  1446,     0,  2309,     0,   506,     0,
-       0,     0, -1550,     0,     0,  1348,     0,     0,     0,     0,
-     585,     0,     0,  2733,     0,     0, -1550,     0,     0,  1335,
-       0, -1550,     0,   727,     0,     0, -1550, -1756,     0,     0,
-       0,     0,   506,     0,     0, -1550,     0,     0,     0, -1550,
-     725,     0,     0, -1756,     0,  2087,     0,     0, -1756,     0,
+       0,     0, -1551,     0,     0,  1348,     0,     0,     0,     0,
+     585,     0,     0,  2733,     0,     0, -1551,     0,     0,  1335,
+       0, -1551,     0,   727,     0,     0, -1551, -1757,     0,     0,
+       0,     0,   506,     0,     0, -1551,     0,     0,     0, -1551,
+     725,     0,     0, -1757,     0,  2087,     0,     0, -1757,     0,
     2706,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,  1047,     0,  2830,     0,
-   -1550,     0,   914,     0,   506,     0,     0,     0,   725,     0,
-       0,     0,     0,   585, -1756,     0,     0,     0,     0, -1550,
+   -1551,     0,   914,     0,   506,     0,     0,     0,   725,     0,
+       0,     0,     0,   585, -1757,     0,     0,     0,     0, -1551,
        0,     0,     0,  1573,  1575,     0,     0,     0,     0,     0,
        0,     0,   506,     0,  1246,     0,   647,     0,     0,   725,
        0,     0,   725,     0,  1348,     0,     0,     0,     0,  1336,
      585,  1348,  1337,  1338,  1339,     0,  1340,  1341,  1342,  1343,
-    1344,  1345,     0,   727,     0,     0,     0,     0, -1550,  1333,
-       0, -1550,     0,     0,     0,     0,     0, -1550,   477,     0,
+    1344,  1345,     0,   727,     0,     0,     0,     0, -1551,  1333,
+       0, -1551,     0,     0,     0,     0,     0, -1551,   477,     0,
     1315,     0,     0,  1316,     0,     0,     0,  2885,     0,     0,
        0,   506,     0,   727,     0,  2703,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,  1603,
-       0, -1550,     0,  1322,  2733,   647,   647,   647,     0,  1622,
-   -1756,  1639,     0,     0,  1651,  1654,  1659,  1662,     0,     0,
-       0,     0,     0,     0, -1550,     0,     0,     0,     0,     0,
+       0, -1551,     0,  1322,  2733,   647,   647,   647,     0,  1622,
+   -1757,  1639,     0,     0,  1651,  1654,  1659,  1662,     0,     0,
+       0,     0,     0,     0, -1551,     0,     0,     0,     0,     0,
        0,     0,     0,     0,  1446,  1324,     0,     0,     0,  1674,
        0,     0,     0,     0,     0,  1678,  1679,  1680,  1681,  2703,
-       0, -1756,     0,  1690,  1691,   727,     0,     0,  1702,     0,
+       0, -1757,     0,  1690,  1691,   727,     0,     0,  1702,     0,
        0,  2830,  1705,     0,     0,  1713,  1714,  1715,  1716,  1717,
     1718,  1719,  1720,  1721,     0,  1773,  1722,     0,     0,  2070,
        0,  1730,     0,     0,  1734,   897,     0,     0,  1047,  1446,
        0,     0,     0,     0,     0,  2733,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,  2310, -1550,     0,     0,     0,
-    1756,  2692,   647,     0, -1550,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,  2310, -1551,     0,     0,     0,
+    1756,  2692,   647,     0, -1551,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,   990,     0,     0,     0,
-   -1550,     0, -1550, -1550,     0,     0, -1756,     0,     0,   725,
+   -1551,     0, -1551, -1551,     0,     0, -1757,     0,     0,   725,
        0,     0,  1291,  1292,     0,   991,     0,     0,     0,     0,
-       0, -1756, -1756,     0,     0,     0,  1348, -1756,  1340,  1341,
-    1342,  1343,  1344,  1345,     0,     0,     0,  1348,     0, -1550,
-       0,  1646, -1550, -1550, -1550,   727,     0,  1348,  1348,  1348,
+       0, -1757, -1757,     0,     0,     0,  1348, -1757,  1340,  1341,
+    1342,  1343,  1344,  1345,     0,     0,     0,  1348,     0, -1551,
+       0,  1646, -1551, -1551, -1551,   727,     0,  1348,  1348,  1348,
        0,     0,     0,     0,     0,     0,  1348,     0,     0,     0,
-       0,     0,     0, -1756,     0,     0,   992,  2402,     0,     0,
+       0,     0,     0, -1757,     0,     0,   992,  2402,     0,     0,
        0,     0,     0,  1246,     0,  2403,     0,     0,     0,     0,
        0,     0,     0,   727,     0,     0,     0,     0,     0,     0,
        0,  1047,     0,     0,  1875,  1876,     0,  1877,     0,     0,
@@ -4390,17 +4390,17 @@ static const yytype_int16 yytable[] =
        3,     4,     0,     0,     0,     0,     0,     0,     0,     0,
        0,  1047,     0,     0,     0,     0,     5,     0,  1970,     0,
        0,     0,     0,  1976,     0,     6,     0,   994,     0,     0,
-   -1756,     0,     0,     0,     0,   995,     0,     7,     0,     0,
+   -1757,     0,     0,     0,     0,   995,     0,     7,     0,     0,
        0,     0,     0,     0,     0,     0,     0,   996,     8,  2405,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        9,  1991,    10,  1315,     0,     0,  1316,     0,     0,     0,
        0,     0,     0,  1659,     0,  1659,  1659,     0,   997,     0,
       11,     0,     0,  2029,     0,     0,     0,  2032,     0,     0,
     2034,     0,     0,     0,    12,     0,  1322,     0,     0,     0,
-       0,     0,     0, -1756,    13,     0,     0,     0,     0,     0,
+       0,     0,     0, -1757,    13,     0,     0,     0,     0,     0,
       14,     0,     0,     0,     0,     0,     0,     0,    15,     0,
       16,    17,     0,     0,  2052,   999,     0,  2055,  1324,  2057,
-   -1756,     0,     0,     0,    18,     0,     0,  1340,  1341,  1342,
+   -1757,     0,     0,     0,    18,     0,     0,  1340,  1341,  1342,
     1343,  1344,  1345,     0,   727,     0,     0,  1000,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        0,     0,     0,    19,     0,     0,     0,  1002,     0,  2406,
@@ -4409,13 +4409,13 @@ static const yytype_int16 yytable[] =
        0,     0,     0,     0,     0,     0,  1399,     0,  2530,  1348,
        0,     0,     0,    21,  1315,     0,     0,  1316,     0,     0,
        0,  1418,  1720,     0,     0,     0,  1348,     0,  1646,  1646,
-       0,  2008,     0,  1646,     0,     0,     0,     0,  1348, -1756,
+       0,  2008,     0,  1646,     0,     0,     0,     0,  1348, -1757,
     2133,  1348,     0,     0,     0,     0,  1348,  1322,     0,  1348,
-       0,     0,     0,     0, -1756, -1756,     0,     0,     0,     0,
-   -1756,  1348,     0,     0,     0,  1348,  1348,  1348,  1348,     0,
+       0,     0,     0,     0, -1757, -1757,     0,     0,     0,     0,
+   -1757,  1348,     0,     0,     0,  1348,  1348,  1348,  1348,     0,
        0,     0,     0,     0,  1646,  1646,     0,  1348,  1348,  1324,
        0,     0,     0,     0,  1454,     0,     0,     0,     0,  1348,
-      22,     0,  1348,    23,     0,     0, -1756,     0,  1047,     0,
+      22,     0,  1348,    23,     0,     0, -1757,     0,  1047,     0,
     1348,  1348,  1348,  1348,  1348,  1348,  1348,  1348,  1348,  1348,
        0,     0,     0,     0,     0,     0,     0,  1348,     0,     0,
        0,  1348,    24,     0,     0,     0,     0,     0,     0,     0,
@@ -4424,13 +4424,13 @@ static const yytype_int16 yytable[] =
        0,  1333,    27,     0,     0,     0,    28,     0,     0,     0,
        0,     0,     0,     0,     0,     0,    29,   991,     0,     0,
        0,     0,     0,     0,     0,     0,     0,    30,     0,     0,
-   -1756,    31,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0, -1756,     0,     0,  2249,
-       0, -1756,     0,     0,     0,     0,     0,     0,  2253,     0,
+   -1757,    31,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0, -1757,     0,     0,  2249,
+       0, -1757,     0,     0,     0,     0,     0,     0,  2253,     0,
        0,  2254,     0,     0,  2256,     0,     0,    32,   992,     0,
        0,     0,    33,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,    34,     0, -1756,     0,     0,
-    2276,  2277,     0, -1756,  1756,     0,     0,   979,     0,     0,
+       0,     0,     0,     0,     0,    34,     0, -1757,     0,     0,
+    2276,  2277,     0, -1757,  1756,     0,     0,   979,     0,     0,
        0,     0,     0,     0,     0,     0,  2288,     0,     0,    35,
        0,     0,  1348,  1348,  1348,  2295,     0,     0,  2298,     0,
     2300,     0,     0,    36,     0,     0,   -39,     0,  2304,     0,
@@ -4440,11 +4440,11 @@ static const yytype_int16 yytable[] =
        0,     0,     0,     0,     0,     0,  2351,     0,     0,     0,
     1320,     0,     0,  1321,     0,     0,  2359,     0,  1322,     0,
        0,     0,     0,     0,     0,  1323,     0,     0,     0,     0,
-       0,     0,  2372, -1756,     0,     0,     0,     0,     0,     0,
+       0,     0,  2372, -1757,     0,     0,     0,     0,     0,     0,
     1340,  1341,  1342,  1343,  1344,  1345,     0,  1348,     0,   994,
     1324,     0,     0,  1348,     0,     0,     0,   995,     0,     0,
        0,     0,     0,     0,     0,     0,  2008,  2008,  1348,   996,
-    1646,  1646,  1646,  1646, -1756,     0,  1646,  1646,  1646,  1646,
+    1646,  1646,  1646,  1646, -1757,     0,  1646,  1646,  1646,  1646,
     1646,  1646,  1646,  1646,  1646,  1646,  2008,     0,     0,     0,
      980,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      997,     0,     0,     0,     0,     0,  1348,     0,     0,  1348,
@@ -4454,7 +4454,7 @@ static const yytype_int16 yytable[] =
        0,   998,     0,     0,     0,   982,     0,   999,     0,     0,
        0,  1325,     0,     0,     0,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,  2507,  1326,     0,  1000,
-       0,     0,  1327,     0, -1756,  1001,     0,     0,     0,     0,
+       0,     0,  1327,     0, -1757,  1001,     0,     0,     0,     0,
        0,  1340,  1341,  1342,  1343,  1344,  1345,     0,     0,  1002,
        0,     0,     0,     0,  1328,  1329,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,  1330,     0,
@@ -5587,7 +5587,7 @@ static const yytype_int16 yytable[] =
      821,   822,     0,     0,     0,     0,     0,     0,     0,     0,
       94,    95,    96,    97,    98,    99,   100,   101,     0,   102,
      103,   104,     0,     0,     0,     0,   823,     0,     0,   105,
-     106,     0,   107,   108,   109,   110,   111,   112,   113, -1756,
+     106,     0,   107,   108,   109,   110,   111,   112,   113, -1757,
      824,   116,   825,   826,     0,   119,   120,   121,   122,   123,
      124,   827,   828,   125,   126,   829,   830,   129,     0,   130,
      131,   132,   133,   831,     0,   832,     0,   136,   137,   138,
@@ -5600,13 +5600,13 @@ static const yytype_int16 yytable[] =
      185,   186,     0,   187,   188,   189,     0,   190,   191,   192,
      193,   843,   195,   196,   197,   198,   199,   844,   845,   201,
        0,   202,   203,   846,   205,     0,   206,     0,   207,   208,
-       0,   209,   210,   211,   212, -1756,   214,     0,   215,     0,
+       0,   209,   210,   211,   212, -1757,   214,     0,   215,     0,
      847,   848,   218,     0,   219,   220,   221,   222,   223,   224,
-     225, -1756,   227,   228,   229,   230,     0,   231,   232,   233,
+     225, -1757,   227,   228,   229,   230,     0,   231,   232,   233,
      234,   235,   236,     0,   237,   238,   239,   240,   241,   242,
      243,   244,   849,   850,     0,   851,     0,   248,     0,     0,
      251,   252,   253,   254,   255,   256,   257,     0,     0,   258,
-     259,   260, -1756,     0,   262,   263,   264,   852,   853,   265,
+     259,   260, -1757,     0,   262,   263,   264,   852,   853,   265,
      266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
      276,   277,   278,   279,   280,   281,   282,   283,   284,   285,
      286,   287,   288,   854,   290,   855,   292,   293,   294,   295,
@@ -5620,7 +5620,7 @@ static const yytype_int16 yytable[] =
      355,   356,   357,   358,   359,   360,   361,   362,     0,   363,
      364,   365,   366,   367,   368,   864,   370,   371,   372,   373,
      374,   375,   376,   377,   378,   379,   380,     0,   381,   382,
-     383,   384,   385,   865,   386,   387,   388,   389,   390, -1756,
+     383,   384,   385,   865,   386,   387,   388,   389,   390, -1757,
      392,   393,   866,   395,     0,   396,   397,   398,   399,   400,
      401,   402,   403,   404,   405,   406,   407,   408,   867,   410,
        0,   411,   412,     0,   413,   414,   415,   416,   417,   418,
@@ -5630,7 +5630,7 @@ static const yytype_int16 yytable[] =
      441,   442,   443,   444,   445,   875,     0,   447,   448,   449,
      450,   451,   452,     0,     0,   453,     0,     0,   454,   455,
      456,   457,   458,   459,   460,   461,   462,   463,   464,   465,
-     466,   467,   468,   469,   470,   471,   472,   473,   474, -1756,
+     466,   467,   468,   469,   470,   471,   472,   473,   474, -1757,
        0,     0,     0,     0,     0,     0,   877,   878,     0,     0,
        0,     0,     0,   880,     0,   881,     0,     0,     0,     0,
      882,     0,   883,   884,    93,   817,   549,   818,   819,   820,
@@ -24791,23 +24791,33 @@ YYLTYPE yylloc;
 #line 46 "third_party/libpg_query/grammar/statements/variable_show.y"
     {
 				PGVariableShowStmt *n = makeNode(PGVariableShowStmt);
-				n->name = (char*) "all";
+				n->name = (char*) "__show_tables_expanded";
 				n->is_summary = 0;
 				(yyval.node) = (PGNode *) n;
 			;}
     break;
 
-  case 1251:
-#line 57 "third_party/libpg_query/grammar/statements/variable_show.y"
-    { (yyval.str) = (yyvsp[(1) - (1)].str); ;}
+  case 1249:
+#line 53 "third_party/libpg_query/grammar/statements/variable_show.y"
+    {
+				PGVariableShowStmt *n = makeNode(PGVariableShowStmt);
+				n->name = (char*) "__show_tables_expanded";
+				n->is_summary = 0;
+				(yyval.node) = (PGNode *) n;
+			;}
     break;
 
   case 1252:
-#line 59 "third_party/libpg_query/grammar/statements/variable_show.y"
-    { (yyval.str) = psprintf("%s.%s", (yyvsp[(1) - (3)].str), (yyvsp[(3) - (3)].str)); ;}
+#line 63 "third_party/libpg_query/grammar/statements/variable_show.y"
+    { (yyval.str) = (yyvsp[(1) - (1)].str); ;}
     break;
 
   case 1253:
+#line 65 "third_party/libpg_query/grammar/statements/variable_show.y"
+    { (yyval.str) = psprintf("%s.%s", (yyvsp[(1) - (3)].str), (yyvsp[(3) - (3)].str)); ;}
+    break;
+
+  case 1254:
 #line 7 "third_party/libpg_query/grammar/statements/call.y"
     {
 					PGCallStmt *n = makeNode(PGCallStmt);
@@ -24816,7 +24826,7 @@ YYLTYPE yylloc;
 				;}
     break;
 
-  case 1254:
+  case 1255:
 #line 10 "third_party/libpg_query/grammar/statements/view.y"
     {
 					PGViewStmt *n = makeNode(PGViewStmt);
@@ -24831,7 +24841,7 @@ YYLTYPE yylloc;
 				;}
     break;
 
-  case 1255:
+  case 1256:
 #line 23 "third_party/libpg_query/grammar/statements/view.y"
     {
 					PGViewStmt *n = makeNode(PGViewStmt);
@@ -24846,7 +24856,7 @@ YYLTYPE yylloc;
 				;}
     break;
 
-  case 1256:
+  case 1257:
 #line 36 "third_party/libpg_query/grammar/statements/view.y"
     {
 					PGViewStmt *n = makeNode(PGViewStmt);
@@ -24866,7 +24876,7 @@ YYLTYPE yylloc;
 				;}
     break;
 
-  case 1257:
+  case 1258:
 #line 54 "third_party/libpg_query/grammar/statements/view.y"
     {
 					PGViewStmt *n = makeNode(PGViewStmt);
@@ -24886,27 +24896,27 @@ YYLTYPE yylloc;
 				;}
     break;
 
-  case 1258:
+  case 1259:
 #line 74 "third_party/libpg_query/grammar/statements/view.y"
     { (yyval.viewcheckoption) = CASCADED_CHECK_OPTION; ;}
     break;
 
-  case 1259:
+  case 1260:
 #line 75 "third_party/libpg_query/grammar/statements/view.y"
     { (yyval.viewcheckoption) = CASCADED_CHECK_OPTION; ;}
     break;
 
-  case 1260:
+  case 1261:
 #line 76 "third_party/libpg_query/grammar/statements/view.y"
     { (yyval.viewcheckoption) = PG_LOCAL_CHECK_OPTION; ;}
     break;
 
-  case 1261:
+  case 1262:
 #line 77 "third_party/libpg_query/grammar/statements/view.y"
     { (yyval.viewcheckoption) = PG_NO_CHECK_OPTION; ;}
     break;
 
-  case 1262:
+  case 1263:
 #line 12 "third_party/libpg_query/grammar/statements/create_as.y"
     {
 					PGCreateTableAsStmt *ctas = makeNode(PGCreateTableAsStmt);
@@ -24922,7 +24932,7 @@ YYLTYPE yylloc;
 				;}
     break;
 
-  case 1263:
+  case 1264:
 #line 25 "third_party/libpg_query/grammar/statements/create_as.y"
     {
 					PGCreateTableAsStmt *ctas = makeNode(PGCreateTableAsStmt);
@@ -24938,7 +24948,7 @@ YYLTYPE yylloc;
 				;}
     break;
 
-  case 1264:
+  case 1265:
 #line 38 "third_party/libpg_query/grammar/statements/create_as.y"
     {
 					PGCreateTableAsStmt *ctas = makeNode(PGCreateTableAsStmt);
@@ -24954,22 +24964,22 @@ YYLTYPE yylloc;
 				;}
     break;
 
-  case 1265:
+  case 1266:
 #line 54 "third_party/libpg_query/grammar/statements/create_as.y"
     { (yyval.boolean) = true; ;}
     break;
 
-  case 1266:
+  case 1267:
 #line 55 "third_party/libpg_query/grammar/statements/create_as.y"
     { (yyval.boolean) = false; ;}
     break;
 
-  case 1267:
+  case 1268:
 #line 56 "third_party/libpg_query/grammar/statements/create_as.y"
     { (yyval.boolean) = true; ;}
     break;
 
-  case 1268:
+  case 1269:
 #line 62 "third_party/libpg_query/grammar/statements/create_as.y"
     {
 					(yyval.into) = makeNode(PGIntoClause);
@@ -24984,7 +24994,7 @@ YYLTYPE yylloc;
 
 
 /* Line 1267 of yacc.c.  */
-#line 24988 "third_party/libpg_query/grammar/grammar_out.cpp"
+#line 24998 "third_party/libpg_query/grammar/grammar_out.cpp"
       default: break;
     }
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
diff --git a/third_party/sqlsmith/duckdb.cc b/third_party/sqlsmith/duckdb.cc
index e1e93a2cda21..86c33309f17f 100644
--- a/third_party/sqlsmith/duckdb.cc
+++ b/third_party/sqlsmith/duckdb.cc
@@ -15,20 +15,20 @@ using namespace std;
 
 static regex e_syntax("syntax error at or near .*");
 
-duckdb_connection::duckdb_connection(string &conninfo) {
+sqlsmith_duckdb_connection::sqlsmith_duckdb_connection(string &conninfo) {
 	// in-memory database
 	database = make_unique<DuckDB>(nullptr);
 	connection = make_unique<Connection>(*database);
 }
 
-void duckdb_connection::q(const char *query) {
+void sqlsmith_duckdb_connection::q(const char *query) {
 	auto result = connection->Query(query);
 	if (!result->success) {
 		throw runtime_error(result->error);
 	}
 }
 
-schema_duckdb::schema_duckdb(std::string &conninfo, bool no_catalog) : duckdb_connection(conninfo) {
+schema_duckdb::schema_duckdb(std::string &conninfo, bool no_catalog) : sqlsmith_duckdb_connection(conninfo) {
 	// generate empty TPC-H schema
 	connection->Query("CALL dbgen(sf=0)");
 
@@ -202,7 +202,7 @@ schema_duckdb::schema_duckdb(std::string &conninfo, bool no_catalog) : duckdb_co
 	generate_indexes();
 }
 
-dut_duckdb::dut_duckdb(std::string &conninfo) : duckdb_connection(conninfo) {
+dut_duckdb::dut_duckdb(std::string &conninfo) : sqlsmith_duckdb_connection(conninfo) {
 	cerr << "Generating TPC-H...";
 	connection->Query("CALL dbgen(sf=0.01)");
 	cerr << "done." << endl;
diff --git a/third_party/sqlsmith/include/duckdb.hh b/third_party/sqlsmith/include/duckdb.hh
index 42be70892207..e535c63bb249 100644
--- a/third_party/sqlsmith/include/duckdb.hh
+++ b/third_party/sqlsmith/include/duckdb.hh
@@ -10,23 +10,23 @@
 #include "relmodel.hh"
 #include "schema.hh"
 
-struct duckdb_connection {
+struct sqlsmith_duckdb_connection {
 	std::unique_ptr<duckdb::DuckDB> database;
 	std::unique_ptr<duckdb::Connection> connection;
 	char *zErrMsg = 0;
 	int rc;
 	void q(const char *query);
-	duckdb_connection(std::string &conninfo);
+	sqlsmith_duckdb_connection(std::string &conninfo);
 };
 
-struct schema_duckdb : schema, duckdb_connection {
+struct schema_duckdb : schema, sqlsmith_duckdb_connection {
 	schema_duckdb(std::string &conninfo, bool no_catalog);
 	virtual std::string quote_name(const std::string &id) {
 		return id;
 	}
 };
 
-struct dut_duckdb : dut_base, duckdb_connection {
+struct dut_duckdb : dut_base, sqlsmith_duckdb_connection {
 	virtual void test(const std::string &stmt);
 	dut_duckdb(std::string &conninfo);
 };
diff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp
index 436bfbfaab55..7b04a884f6a8 100644
--- a/tools/jdbc/src/jni/duckdb_java.cpp
+++ b/tools/jdbc/src/jni/duckdb_java.cpp
@@ -408,6 +408,7 @@ JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(
 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(double));
 			break;
 		case LogicalTypeId::TIMESTAMP:
+		case LogicalTypeId::TIMESTAMP_TZ:
 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(timestamp_t));
 			break;
 		case LogicalTypeId::TIME:
diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java
index 6a48a980688b..b6ed23c00d36 100644
--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java
+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java
@@ -2,5 +2,5 @@
 
 public enum DuckDBColumnType {
 	BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, UTINYINT, USMALLINT, UINTEGER, UBIGINT, HUGEINT, FLOAT, DOUBLE,
-	DECIMAL, VARCHAR, BLOB, TIME, DATE, TIMESTAMP, TIMESTAMP_WITH_TIMEZONE, INTERVAL, LIST, STRUCT
+	DECIMAL, VARCHAR, BLOB, TIME, DATE, TIMESTAMP, TIMESTAMP_WITH_TIME_ZONE, INTERVAL, LIST, STRUCT
 }
diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java
index 17d6e0c5e87e..b353bcd986e1 100644
--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java
+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java
@@ -27,6 +27,7 @@
 import java.sql.Types;
 import java.util.Calendar;
 import java.time.LocalDateTime;
+import java.time.OffsetDateTime;
 
 public class DuckDBPreparedStatement implements PreparedStatement {
 	private DuckDBConnection conn;
@@ -170,6 +171,8 @@ public void setObject(int parameterIndex, Object x) throws SQLException {
 			x = new DuckDBTimestamp((Timestamp)x);
 		} else if (x instanceof LocalDateTime) {
 			x = new DuckDBTimestamp((LocalDateTime) x);
+		} else if (x instanceof OffsetDateTime) {
+			x = new DuckDBTimestamp((OffsetDateTime) x);
 		}
 		params[parameterIndex - 1] = x;
 	}
@@ -614,10 +617,13 @@ public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQ
 			}
 			break;
 		case Types.TIMESTAMP:
+		case Types.TIMESTAMP_WITH_TIMEZONE:
 			if (x instanceof Timestamp) {
 				setObject(parameterIndex, x);
 			} else if (x instanceof LocalDateTime) {
 				setObject(parameterIndex, x);
+			} else if (x instanceof OffsetDateTime) {
+				setObject(parameterIndex, x);
 			} else {
 				throw new SQLException("Can't convert value to timestamp " + x.getClass().toString());
 			}
diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java
index 5852a8c0ad00..317cce7d44f5 100644
--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java
+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java
@@ -155,6 +155,8 @@ public Object getObject(int columnIndex) throws SQLException {
 			return getDate(columnIndex);
 		case TIMESTAMP:
 			return getTimestamp(columnIndex);
+		case TIMESTAMP_WITH_TIME_ZONE:
+			return getOffsetDateTime(columnIndex);
 		case INTERVAL:
 			return getLazyString(columnIndex);
 		default:
@@ -483,6 +485,17 @@ private LocalDateTime getLocalDateTime(int columnIndex) throws SQLException {
 		}
 		return null;
 	}
+
+	private OffsetDateTime getOffsetDateTime(int columnIndex) throws SQLException {
+		if (check_and_null(columnIndex)) {
+			return null;
+		}
+		if (isType(columnIndex, DuckDBColumnType.TIMESTAMP_WITH_TIME_ZONE)) {
+			return DuckDBTimestamp.toOffsetDateTime(getbuf(columnIndex, 8).getLong());
+		}
+		return null;
+	}
+
 	static class DuckDBBlobResult implements Blob {
 
 		static class ByteBufferBackedInputStream extends InputStream {
@@ -1338,9 +1351,8 @@ public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
 				throw new SQLException("Can't convert value to BigInteger " + type.toString());
 			}
 		} else if (type == OffsetDateTime.class) {
-			if (sqlType == DuckDBColumnType.TIMESTAMP_WITH_TIMEZONE) {
-				throw new SQLException("Can't convert value to OffsetDateTime " + type.toString());
-			// return type.cast(getLocalDateTime(columnIndex));
+			if (sqlType == DuckDBColumnType.TIMESTAMP_WITH_TIME_ZONE) {
+				return type.cast(getOffsetDateTime(columnIndex));
 			} else {
 				throw new SQLException("Can't convert value to OffsetDateTime " + type.toString());
 			}
diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java
index e61e4fc2a2e9..855c2e34fe54 100644
--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java
+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java
@@ -43,6 +43,8 @@ public DuckDBResultSetMetaData(int param_count, int column_count, String[] colum
 	public static DuckDBColumnType TypeNameToType(String type_name) {
 		if (type_name.startsWith("DECIMAL")) {
 			return DuckDBColumnType.DECIMAL;
+		} else if (type_name.equals("TIMESTAMP WITH TIME ZONE")) {
+			return DuckDBColumnType.TIMESTAMP_WITH_TIME_ZONE;
 		} else {
 			return DuckDBColumnType.valueOf(type_name);
 		}
diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBTimestamp.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBTimestamp.java
index 36e4b41f904a..1a031443d9dd 100644
--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBTimestamp.java
+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBTimestamp.java
@@ -3,6 +3,7 @@
 import java.sql.Timestamp;
 import java.time.ZoneOffset;
 import java.time.LocalDateTime;
+import java.time.OffsetDateTime;
 import java.time.temporal.ChronoUnit;
 
 public class DuckDBTimestamp {
@@ -22,6 +23,11 @@ public DuckDBTimestamp(LocalDateTime localDateTime) {
 			localDateTime, ChronoUnit.MICROS);
 	}
 
+	public DuckDBTimestamp(OffsetDateTime offsetDateTime) {
+		this.timeMicros = DuckDBTimestamp.RefLocalDateTime.until(
+			offsetDateTime.withOffsetSameInstant(ZoneOffset.UTC), ChronoUnit.MICROS);
+	}
+
 	public DuckDBTimestamp(Timestamp sqlTimestamp) {
 		this.timeMicros = DuckDBTimestamp.RefLocalDateTime.until(
 			sqlTimestamp.toLocalDateTime(), ChronoUnit.MICROS);
@@ -41,6 +47,10 @@ public static LocalDateTime toLocalDateTime(long timeMicros) {
 				, nanosPartMicros(timeMicros), ZoneOffset.UTC);
 	}
 
+	public static OffsetDateTime toOffsetDateTime(long timeMicros) {
+		return OffsetDateTime.of(toLocalDateTime(timeMicros), ZoneOffset.UTC);
+	}
+
 	public Timestamp toSqlTimestamp() {
 		return Timestamp.valueOf(this.toLocalDateTime());
 	}
@@ -50,6 +60,11 @@ public LocalDateTime toLocalDateTime() {
 				, nanosPartMicros(timeMicros), ZoneOffset.UTC);
 	}
 
+	public OffsetDateTime toOffsetDateTime() {
+		return OffsetDateTime.of(toLocalDateTime(this.timeMicros)
+				, ZoneOffset.UTC);
+	}
+
 	public static long getMicroseconds(Timestamp sqlTimestamp) {
 		return DuckDBTimestamp.RefLocalDateTime.until(
 				sqlTimestamp.toLocalDateTime(), ChronoUnit.MICROS);
@@ -64,10 +79,19 @@ public String toString() {
 	}
 
 	private static long micros2seconds(long micros) {
-		return micros / 1000_000L;
+		if ((micros % 1000_000L) >= 0) {
+			return micros / 1000_000L;
+		} else {
+			return (micros / 1000_000L) -1;
+		}
 	}
 
 	private static int nanosPartMicros(long micros) {
-		return (int) ((micros % 1000_000L) * 1000);
+		if ((micros % 1000_000L) >= 0) {
+			return (int) ((micros % 1000_000L) * 1000);
+		}
+		else {
+			return (int) ((1000_000L + (micros % 1000_000L)) * 1000);
+		}
 	}
 }
diff --git a/tools/odbc/CMakeLists.txt b/tools/odbc/CMakeLists.txt
index 9b429af886df..1db13939f07b 100644
--- a/tools/odbc/CMakeLists.txt
+++ b/tools/odbc/CMakeLists.txt
@@ -43,6 +43,8 @@ add_library(
   parameter_descriptor.cpp
   row_descriptor.cpp
   cursor.cpp
+  odbc_diagnostic.cpp
+  odbc_exception.cpp
   duckdb_odbc.def)
 
 set_target_properties(duckdb_odbc PROPERTIES DEFINE_SYMBOL "DUCKDB_ODBC_API")
diff --git a/tools/odbc/connection.cpp b/tools/odbc/connection.cpp
index 565b7ee85724..bb46f6f00b7f 100644
--- a/tools/odbc/connection.cpp
+++ b/tools/odbc/connection.cpp
@@ -1,11 +1,14 @@
 #include "driver.hpp"
 #include "duckdb_odbc.hpp"
 #include "api_info.hpp"
+#include "odbc_diagnostic.hpp"
+#include "odbc_exception.hpp"
 #include "odbc_utils.hpp"
 
 #include "duckdb/common/helper.hpp"
 
 using duckdb::OdbcUtils;
+using duckdb::SQLStateType;
 using std::ptrdiff_t;
 
 SQLRETURN SQL_API SQLGetConnectAttr(SQLHDBC connection_handle, SQLINTEGER attribute, SQLPOINTER value_ptr,
@@ -418,7 +421,8 @@ SQLRETURN SQL_API SQLGetInfo(SQLHDBC connection_handle, SQLUSMALLINT info_type,
 	}
 	case SQL_DATA_SOURCE_NAME: {
 		return duckdb::WithConnection(connection_handle, [&](duckdb::OdbcHandleDbc *dbc) -> SQLRETURN {
-			duckdb::OdbcUtils::WriteString(dbc->dsn, (SQLCHAR *)info_value_ptr, buffer_length, string_length_ptr);
+			duckdb::OdbcUtils::WriteString(dbc->GetDataSourceName(), (SQLCHAR *)info_value_ptr, buffer_length,
+			                               string_length_ptr);
 			return SQL_SUCCESS;
 		});
 	}
@@ -952,8 +956,14 @@ SQLRETURN SQL_API SQLEndTran(SQLSMALLINT handle_type, SQLHANDLE handle, SQLSMALL
 			dbc->conn->Commit();
 			return SQL_SUCCESS;
 		case SQL_ROLLBACK:
-			dbc->conn->Rollback();
-			return SQL_SUCCESS;
+			try {
+				dbc->conn->Rollback();
+				return SQL_SUCCESS;
+			} catch (duckdb::Exception &ex) {
+				duckdb::DiagRecord diag_rec(std::string(ex.what()), SQLStateType::SQLENDTRAN_ASYNC_FUNCT_EXECUTION,
+				                            dbc->GetDataSourceName());
+				throw duckdb::OdbcException("SQLEndTran", SQL_ERROR, diag_rec);
+			}
 		default:
 			return SQL_ERROR;
 		}
diff --git a/tools/odbc/driver.cpp b/tools/odbc/driver.cpp
index fe47ec5eeb80..693f46fe2daa 100644
--- a/tools/odbc/driver.cpp
+++ b/tools/odbc/driver.cpp
@@ -1,5 +1,6 @@
 #include "duckdb_odbc.hpp"
 #include "driver.hpp"
+#include "odbc_diagnostic.hpp"
 #include "odbc_fetch.hpp"
 #include "odbc_utils.hpp"
 
@@ -8,6 +9,7 @@
 #include <odbcinst.h>
 #include <locale>
 
+using duckdb::OdbcDiagnostic;
 using duckdb::OdbcUtils;
 using std::string;
 
@@ -81,49 +83,44 @@ SQLRETURN SQL_API SQLAllocHandle(SQLSMALLINT handle_type, SQLHANDLE input_handle
 
 SQLRETURN SQL_API SQLSetEnvAttr(SQLHENV environment_handle, SQLINTEGER attribute, SQLPOINTER value_ptr,
                                 SQLINTEGER string_length) {
-	if (!environment_handle) {
-		return SQL_ERROR;
-	}
-	auto *env = (duckdb::OdbcHandleEnv *)environment_handle;
-	if (env->type != duckdb::OdbcHandleType::ENV) {
-		return SQL_ERROR;
-	}
-	switch (attribute) {
-	case SQL_ATTR_ODBC_VERSION: {
-		switch ((SQLUINTEGER)(intptr_t)value_ptr) {
-		case SQL_OV_ODBC3:
-			// TODO actually do something with this?
-			// auto version = (SQLINTEGER)(uintptr_t)value_ptr;
-			return SQL_SUCCESS;
-		default:
-			env->error_messages.emplace_back("ODBC version not supported.");
-			return SQL_ERROR;
+	return duckdb::WithEnvironment(environment_handle, [&](duckdb::OdbcHandleEnv *env) {
+		switch (attribute) {
+		case SQL_ATTR_ODBC_VERSION: {
+			switch ((SQLUINTEGER)(intptr_t)value_ptr) {
+			case SQL_OV_ODBC3:
+				// TODO actually do something with this?
+				// auto version = (SQLINTEGER)(uintptr_t)value_ptr;
+				return SQL_SUCCESS;
+			default:
+				env->error_messages.emplace_back("ODBC version not supported.");
+				return SQL_ERROR;
+			}
 		}
-	}
-	case SQL_ATTR_CONNECTION_POOLING:
-		switch ((SQLINTEGER)(intptr_t)value_ptr) {
-		case SQL_CP_OFF:
-		case SQL_CP_ONE_PER_DRIVER:
-		case SQL_CP_ONE_PER_HENV:
-			return SQL_SUCCESS;
-		default:
-			env->error_messages.emplace_back("Connection pool option not supported.");
+		case SQL_ATTR_CONNECTION_POOLING:
+			switch ((SQLINTEGER)(intptr_t)value_ptr) {
+			case SQL_CP_OFF:
+			case SQL_CP_ONE_PER_DRIVER:
+			case SQL_CP_ONE_PER_HENV:
+				return SQL_SUCCESS;
+			default:
+				env->error_messages.emplace_back("Connection pool option not supported.");
+				return SQL_ERROR;
+			}
+		case SQL_ATTR_CP_MATCH:
+			env->error_messages.emplace_back("Optional feature not supported.");
 			return SQL_ERROR;
-		}
-	case SQL_ATTR_CP_MATCH:
-		env->error_messages.emplace_back("Optional feature not supported.");
-		return SQL_ERROR;
-	case SQL_ATTR_OUTPUT_NTS: /* SQLINTEGER */
-		switch (*(SQLINTEGER *)value_ptr) {
-		case SQL_TRUE:
-			return SQL_SUCCESS;
+		case SQL_ATTR_OUTPUT_NTS: /* SQLINTEGER */
+			switch (*(SQLINTEGER *)value_ptr) {
+			case SQL_TRUE:
+				return SQL_SUCCESS;
+			default:
+				env->error_messages.emplace_back("Optional feature not supported.");
+				return SQL_ERROR;
+			}
 		default:
-			env->error_messages.emplace_back("Optional feature not supported.");
 			return SQL_ERROR;
 		}
-	default:
-		return SQL_ERROR;
-	}
+	});
 }
 
 SQLRETURN SQL_API SQLGetEnvAttr(SQLHENV environment_handle, SQLINTEGER attribute, SQLPOINTER value_ptr,
@@ -237,71 +234,223 @@ SQLRETURN SQL_API SQLConnect(SQLHDBC connection_handle, SQLCHAR *server_name, SQ
 SQLRETURN SQL_API SQLGetDiagRec(SQLSMALLINT handle_type, SQLHANDLE handle, SQLSMALLINT rec_number, SQLCHAR *sql_state,
                                 SQLINTEGER *native_error_ptr, SQLCHAR *message_text, SQLSMALLINT buffer_length,
                                 SQLSMALLINT *text_length_ptr) {
-	if (!handle) {
-		std::string msg_str("Handle is NULL.");
-		OdbcUtils::WriteString(msg_str, message_text, buffer_length, text_length_ptr);
-		return SQL_INVALID_HANDLE;
-	}
-	if (rec_number <= 0 || buffer_length < 0) {
-		return SQL_ERROR;
-	}
-	if (message_text) {
-		*message_text = '\0';
-	}
-	if (text_length_ptr) {
-		*text_length_ptr = 0;
-	}
-	if (sql_state) {
-		*sql_state = '\0';
-	}
-	if (native_error_ptr) {
-		*native_error_ptr = 0; // we don't have error codes
-	}
-
-	auto *hdl = (duckdb::OdbcHandle *)handle;
 
 	// lambda function that writes the diagnostic messages
-	std::function<SQLRETURN(duckdb::OdbcHandle *, duckdb::OdbcHandleType)> func_write_diag =
+	std::function<bool(duckdb::OdbcHandle *, duckdb::OdbcHandleType)> is_valid_type_func =
 	    [&](duckdb::OdbcHandle *hdl, duckdb::OdbcHandleType target_type) {
 		    if (hdl->type != target_type) {
 			    std::string msg_str("Handle type " + duckdb::OdbcHandleTypeToString(hdl->type) + " mismatch with " +
 			                        duckdb::OdbcHandleTypeToString(target_type));
 			    OdbcUtils::WriteString(msg_str, message_text, buffer_length, text_length_ptr);
-			    return SQL_SUCCESS;
-		    }
-
-		    // Errors should be placed at the error_messages
-		    if ((size_t)rec_number <= hdl->error_messages.size()) {
-			    OdbcUtils::WriteString(hdl->error_messages[rec_number - 1], message_text, buffer_length,
-			                           text_length_ptr);
-			    return SQL_SUCCESS;
-		    } else {
-			    return SQL_NO_DATA;
+			    return false;
 		    }
+		    return true;
 	    };
 
-	switch (handle_type) {
-	case SQL_HANDLE_ENV: {
-		return func_write_diag(hdl, duckdb::OdbcHandleType::ENV);
-	}
-	case SQL_HANDLE_DBC: {
-		return func_write_diag(hdl, duckdb::OdbcHandleType::DBC);
-	}
-	case SQL_HANDLE_STMT: {
-		return func_write_diag(hdl, duckdb::OdbcHandleType::STMT);
-	}
-	case SQL_HANDLE_DESC: {
-		return func_write_diag(hdl, duckdb::OdbcHandleType::DESC);
-	}
-	default:
-		return SQL_INVALID_HANDLE;
-	}
+	return duckdb::WithHandle(handle, [&](duckdb::OdbcHandle *odbc_handle) {
+		bool is_valid_type;
+		switch (handle_type) {
+		case SQL_HANDLE_ENV: {
+			is_valid_type = is_valid_type_func(odbc_handle, duckdb::OdbcHandleType::ENV);
+			break;
+		}
+		case SQL_HANDLE_DBC: {
+			is_valid_type = is_valid_type_func(odbc_handle, duckdb::OdbcHandleType::DBC);
+			break;
+		}
+		case SQL_HANDLE_STMT: {
+			is_valid_type = is_valid_type_func(odbc_handle, duckdb::OdbcHandleType::STMT);
+			break;
+		}
+		case SQL_HANDLE_DESC: {
+			is_valid_type = is_valid_type_func(odbc_handle, duckdb::OdbcHandleType::DESC);
+			break;
+		}
+		default:
+			return SQL_INVALID_HANDLE;
+		}
+		if (!is_valid_type) {
+			// return SQL_SUCCESS because the error message was written to the message_text
+			return SQL_SUCCESS;
+		}
+
+		if (rec_number <= 0) {
+			OdbcUtils::WriteString("Record number is less than 1", message_text, buffer_length, text_length_ptr);
+			return SQL_SUCCESS;
+		}
+		if (buffer_length < 0) {
+			OdbcUtils::WriteString("Buffer length is negative", message_text, buffer_length, text_length_ptr);
+			return SQL_SUCCESS;
+		}
+		if ((size_t)rec_number > odbc_handle->odbc_diagnostic->GetTotalRecords()) {
+			return SQL_NO_DATA;
+		}
+
+		auto rec_idx = rec_number - 1;
+		auto &diag_record = odbc_handle->odbc_diagnostic->GetDiagRecord(rec_idx);
+
+		if (sql_state && strlen((char *)sql_state) >= 5) {
+			OdbcUtils::WriteString(diag_record.sql_diag_sqlstate, sql_state, 6);
+		}
+		if (native_error_ptr) {
+			duckdb::Store<SQLINTEGER>(diag_record.sql_diag_native, (duckdb::data_ptr_t)native_error_ptr);
+		}
+
+		std::string msg = diag_record.GetMessage(buffer_length);
+		OdbcUtils::WriteString(msg, message_text, buffer_length, text_length_ptr);
+
+		if (text_length_ptr) {
+			SQLSMALLINT remaining_chars = msg.size() - buffer_length;
+			if (remaining_chars > 0) {
+				// TODO needs to split the diagnostic message
+				odbc_handle->odbc_diagnostic->AddNewRecIdx(rec_idx);
+				return SQL_SUCCESS_WITH_INFO;
+			}
+		}
+
+		if (message_text == nullptr) {
+			return SQL_SUCCESS_WITH_INFO;
+		}
+
+		return SQL_SUCCESS;
+	});
 }
 
 SQLRETURN SQL_API SQLGetDiagField(SQLSMALLINT handle_type, SQLHANDLE handle, SQLSMALLINT rec_number,
                                   SQLSMALLINT diag_identifier, SQLPOINTER diag_info_ptr, SQLSMALLINT buffer_length,
                                   SQLSMALLINT *string_length_ptr) {
-	return SQL_ERROR;
+	switch (handle_type) {
+	case SQL_HANDLE_ENV:
+	case SQL_HANDLE_DBC:
+	case SQL_HANDLE_STMT:
+	case SQL_HANDLE_DESC: {
+		return duckdb::WithHandle(handle, [&](duckdb::OdbcHandle *hdl) {
+			// diag header fields
+			switch (diag_identifier) {
+			case SQL_DIAG_CURSOR_ROW_COUNT: {
+				// this field is available only for statement handles
+				if (hdl->type != duckdb::OdbcHandleType::STMT) {
+					return SQL_ERROR;
+				}
+				duckdb::Store<SQLLEN>(hdl->odbc_diagnostic->header.sql_diag_cursor_row_count,
+				                      (duckdb::data_ptr_t)diag_info_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_DYNAMIC_FUNCTION: {
+				// this field is available only for statement handles
+				if (hdl->type != duckdb::OdbcHandleType::STMT) {
+					return SQL_ERROR;
+				}
+				duckdb::OdbcUtils::WriteString(hdl->odbc_diagnostic->GetDiagDynamicFunction(), (SQLCHAR *)diag_info_ptr,
+				                               buffer_length, string_length_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_DYNAMIC_FUNCTION_CODE: {
+				// this field is available only for statement handles
+				if (hdl->type != duckdb::OdbcHandleType::STMT) {
+					return SQL_ERROR;
+				}
+				duckdb::Store<SQLINTEGER>(hdl->odbc_diagnostic->header.sql_diag_dynamic_function_code,
+				                          (duckdb::data_ptr_t)diag_info_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_NUMBER: {
+				duckdb::Store<SQLINTEGER>(hdl->odbc_diagnostic->header.sql_diag_number,
+				                          (duckdb::data_ptr_t)diag_info_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_RETURNCODE: {
+				duckdb::Store<SQLRETURN>(hdl->odbc_diagnostic->header.sql_diag_return_code,
+				                         (duckdb::data_ptr_t)diag_info_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_ROW_COUNT: {
+				// this field is available only for statement handles
+				if (hdl->type != duckdb::OdbcHandleType::STMT) {
+					return SQL_ERROR;
+				}
+				duckdb::Store<SQLLEN>(hdl->odbc_diagnostic->header.sql_diag_return_code,
+				                      (duckdb::data_ptr_t)diag_info_ptr);
+				return SQL_SUCCESS;
+			}
+			default:
+				break;
+			}
+
+			// verify identifier and record index
+			if (!OdbcDiagnostic::IsDiagRecordField(diag_identifier)) {
+				return SQL_ERROR;
+			}
+			if (rec_number <= 0) {
+				return SQL_ERROR;
+			}
+			auto rec_idx = rec_number - 1;
+			if (!hdl->odbc_diagnostic->VerifyRecordIndex(rec_idx)) {
+				return SQL_ERROR;
+			}
+
+			auto diag_record = hdl->odbc_diagnostic->GetDiagRecord(rec_idx);
+
+			// diag record fields
+			switch (diag_identifier) {
+			case SQL_DIAG_CLASS_ORIGIN: {
+				duckdb::OdbcUtils::WriteString(hdl->odbc_diagnostic->GetDiagClassOrigin(rec_idx),
+				                               (SQLCHAR *)diag_info_ptr, buffer_length, string_length_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_COLUMN_NUMBER: {
+				// this field is available only for statement handles
+				if (hdl->type != duckdb::OdbcHandleType::STMT) {
+					return SQL_ERROR;
+				}
+				duckdb::Store<SQLINTEGER>(diag_record.sql_diag_column_number, (duckdb::data_ptr_t)diag_info_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_CONNECTION_NAME: {
+				// we do not support connection names
+				duckdb::OdbcUtils::WriteString("", (SQLCHAR *)diag_info_ptr, buffer_length, string_length_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_MESSAGE_TEXT: {
+				auto msg = diag_record.GetMessage(buffer_length);
+				duckdb::OdbcUtils::WriteString(msg, (SQLCHAR *)diag_info_ptr, buffer_length, string_length_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_NATIVE: {
+				duckdb::Store<SQLINTEGER>(diag_record.sql_diag_native, (duckdb::data_ptr_t)diag_info_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_ROW_NUMBER: {
+				// this field is available only for statement handles
+				if (hdl->type != duckdb::OdbcHandleType::STMT) {
+					return SQL_ERROR;
+				}
+				duckdb::Store<SQLLEN>(diag_record.sql_diag_row_number, (duckdb::data_ptr_t)diag_info_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_SERVER_NAME: {
+				duckdb::OdbcUtils::WriteString(diag_record.sql_diag_server_name, (SQLCHAR *)diag_info_ptr,
+				                               buffer_length, string_length_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_SQLSTATE: {
+				duckdb::OdbcUtils::WriteString(diag_record.sql_diag_sqlstate, (SQLCHAR *)diag_info_ptr, buffer_length,
+				                               string_length_ptr);
+				return SQL_SUCCESS;
+			}
+			case SQL_DIAG_SUBCLASS_ORIGIN: {
+				duckdb::OdbcUtils::WriteString(hdl->odbc_diagnostic->GetDiagSubclassOrigin(rec_idx),
+				                               (SQLCHAR *)diag_info_ptr, buffer_length, string_length_ptr);
+				return SQL_SUCCESS;
+			}
+			default:
+				return SQL_ERROR;
+			}
+		});
+	}
+	default:
+		return SQL_ERROR;
+	}
 }
 
 SQLRETURN SQL_API SQLDataSources(SQLHENV environment_handle, SQLUSMALLINT direction, SQLCHAR *server_name,
diff --git a/tools/odbc/duckdb_odbc.cpp b/tools/odbc/duckdb_odbc.cpp
index 8ea70b36a613..34b8dbbf6a4b 100644
--- a/tools/odbc/duckdb_odbc.cpp
+++ b/tools/odbc/duckdb_odbc.cpp
@@ -5,6 +5,7 @@
 #include "parameter_descriptor.hpp"
 #include "row_descriptor.hpp"
 
+using duckdb::OdbcDiagnostic;
 using duckdb::OdbcHandle;
 using duckdb::OdbcHandleDbc;
 using duckdb::OdbcHandleDesc;
@@ -26,6 +27,10 @@ std::string duckdb::OdbcHandleTypeToString(OdbcHandleType type) {
 }
 
 //! OdbcHandle functions ***************************************************
+OdbcHandle::OdbcHandle(OdbcHandleType type_p) : type(type_p) {
+	odbc_diagnostic = make_unique<OdbcDiagnostic>();
+}
+
 OdbcHandle::OdbcHandle(const OdbcHandle &other) {
 	// calling copy assigment opetator;
 	*this = other;
@@ -84,6 +89,10 @@ std::string OdbcHandleDbc::GetDatabaseName() {
 	return sql_attr_current_catalog;
 }
 
+std::string OdbcHandleDbc::GetDataSourceName() {
+	return dsn;
+}
+
 //! OdbcHandleStmt functions **************************************************
 OdbcHandleStmt::OdbcHandleStmt(OdbcHandleDbc *dbc_p)
     : OdbcHandle(OdbcHandleType::STMT), dbc(dbc_p), rows_fetched_ptr(nullptr) {
diff --git a/tools/odbc/include/duckdb_odbc.hpp b/tools/odbc/include/duckdb_odbc.hpp
index 86c2147061a9..4594a228171a 100644
--- a/tools/odbc/include/duckdb_odbc.hpp
+++ b/tools/odbc/include/duckdb_odbc.hpp
@@ -6,6 +6,8 @@
 
 #include "duckdb/common/windows.hpp"
 #include "descriptor.hpp"
+#include "odbc_diagnostic.hpp"
+#include "odbc_exception.hpp"
 #include "odbc_utils.hpp"
 
 #include <sqltypes.h>
@@ -21,18 +23,21 @@ namespace duckdb {
 class OdbcFetch;
 class ParameterDescriptor;
 class RowDescriptor;
+class OdbcDiagnostic;
 
 enum OdbcHandleType { ENV, DBC, STMT, DESC };
 std::string OdbcHandleTypeToString(OdbcHandleType type);
 
 struct OdbcHandle {
-	explicit OdbcHandle(OdbcHandleType type_p) : type(type_p) {};
+	explicit OdbcHandle(OdbcHandleType type_p);
 	OdbcHandle(const OdbcHandle &other);
 	OdbcHandle &operator=(const OdbcHandle &other);
 
 	OdbcHandleType type;
 	// appending all error messages into it
 	std::vector<std::string> error_messages;
+
+	unique_ptr<OdbcDiagnostic> odbc_diagnostic;
 };
 
 struct OdbcHandleEnv : public OdbcHandle {
@@ -57,6 +62,7 @@ struct OdbcHandleDbc : public OdbcHandle {
 
 	void SetDatabaseName(const string &db_name);
 	std::string GetDatabaseName();
+	std::string GetDataSourceName();
 
 public:
 	OdbcHandleEnv *env;
@@ -163,6 +169,35 @@ struct OdbcHandleDesc : public OdbcHandle {
 	OdbcHandleStmt *stmt;
 };
 
+template <class T>
+SQLRETURN WithHandle(SQLHANDLE &handle, T &&lambda) {
+	if (!handle) {
+		return SQL_INVALID_HANDLE;
+	}
+	auto *hdl = (OdbcHandle *)handle;
+	if (!hdl->odbc_diagnostic) {
+		return SQL_ERROR;
+	}
+
+	return lambda(hdl);
+}
+
+template <class T>
+SQLRETURN WithEnvironment(SQLHANDLE &enviroment_handle, T &&lambda) {
+	if (!enviroment_handle) {
+		return SQL_ERROR;
+	}
+	auto *env = (OdbcHandleEnv *)enviroment_handle;
+	if (env->type != OdbcHandleType::ENV) {
+		return SQL_ERROR;
+	}
+	if (!env->db) {
+		return SQL_ERROR;
+	}
+
+	return lambda(env);
+}
+
 template <class T>
 SQLRETURN WithConnection(SQLHANDLE &connection_handle, T &&lambda) {
 	if (!connection_handle) {
@@ -176,7 +211,19 @@ SQLRETURN WithConnection(SQLHANDLE &connection_handle, T &&lambda) {
 		return SQL_ERROR;
 	}
 
-	return lambda(hdl);
+	// ODBC requires to clean up the diagnostic for every ODBC function call
+	hdl->odbc_diagnostic->Clean();
+
+	try {
+		return lambda(hdl);
+	} catch (OdbcException &ex) {
+		auto diag_record = ex.GetDiagRecord();
+		auto component = ex.GetComponent();
+		auto data_source = hdl->GetDataSourceName();
+		hdl->odbc_diagnostic->FormatDiagnosticMessage(diag_record, data_source, component);
+		hdl->odbc_diagnostic->AddDiagRecord(diag_record);
+		return ex.GetSqlReturn();
+	}
 }
 
 template <class T>
@@ -184,14 +231,27 @@ SQLRETURN WithStatement(SQLHANDLE &statement_handle, T &&lambda) {
 	if (!statement_handle) {
 		return SQL_ERROR;
 	}
-	auto *hdl = (OdbcHandleStmt *)statement_handle;
-	if (hdl->type != OdbcHandleType::STMT) {
+	auto *hdl_stmt = (OdbcHandleStmt *)statement_handle;
+	if (hdl_stmt->type != OdbcHandleType::STMT) {
 		return SQL_ERROR;
 	}
-	if (!hdl->dbc || !hdl->dbc->conn) {
+	if (!hdl_stmt->dbc || !hdl_stmt->dbc->conn) {
 		return SQL_ERROR;
 	}
-	return lambda(hdl);
+
+	// ODBC requires to clean up the diagnostic for every ODBC function call
+	hdl_stmt->odbc_diagnostic->Clean();
+
+	try {
+		return lambda(hdl_stmt);
+	} catch (OdbcException &ex) {
+		auto diag_record = ex.GetDiagRecord();
+		auto component = ex.GetComponent();
+		auto data_source = hdl_stmt->dbc->GetDataSourceName();
+		hdl_stmt->odbc_diagnostic->FormatDiagnosticMessage(diag_record, data_source, component);
+		hdl_stmt->odbc_diagnostic->AddDiagRecord(diag_record);
+		return ex.GetSqlReturn();
+	}
 }
 
 template <class T>
@@ -203,7 +263,11 @@ SQLRETURN WithStatementPrepared(SQLHANDLE &statement_handle, T &&lambda) {
 		if (!stmt->stmt->success) {
 			return SQL_ERROR;
 		}
-		return lambda(stmt);
+		try {
+			return lambda(stmt);
+		} catch (OdbcException &ex) {
+			throw ex;
+		}
 	});
 }
 
@@ -216,7 +280,11 @@ SQLRETURN WithStatementResult(SQLHANDLE &statement_handle, T &&lambda) {
 		if (!stmt->res->success) {
 			return SQL_ERROR;
 		}
-		return lambda(stmt);
+		try {
+			return lambda(stmt);
+		} catch (OdbcException &ex) {
+			throw ex;
+		}
 	});
 }
 
diff --git a/tools/odbc/include/odbc_diagnostic.hpp b/tools/odbc/include/odbc_diagnostic.hpp
new file mode 100644
index 000000000000..5b92d2580d1a
--- /dev/null
+++ b/tools/odbc/include/odbc_diagnostic.hpp
@@ -0,0 +1,230 @@
+#ifndef ODBC_DIAGNOSTIC_HPP
+#define ODBC_DIAGNOSTIC_HPP
+
+#include "duckdb.hpp"
+#include "duckdb/common/windows.hpp"
+
+#include "sqlext.h"
+#include "sqltypes.h"
+
+#include <set>
+#include <stack>
+#include <string>
+#include <vector>
+#include <unordered_map>
+
+namespace duckdb {
+enum class SQLStateType : uint8_t {
+	GENERAL_WARNING = 0,             //    {"01000", "General warning"},
+	CURSOR_CONFLICT = 1,             //    {"01001", "Cursor operation conflict"},
+	DISCONNECT_ERROR = 2,            //    {"01002", "Disconnect error"},
+	NULL_VALUE_ELIM = 3,             //    {"01003", "NULL value eliminated in set function"},
+	STR_RIGHT_TRUNCATE = 4,          //    {"01004", "String data, right truncated"},
+	PRIVILEGE_NOT_REVOKED = 5,       //    {"01006", "Privilege not revoked"},
+	PRIVILEGE_NOT_GRANTED = 6,       //    {"01007", "Privilege not granted"},
+	INVALID_CONNECTION_STR_ATTR = 7, //    {"01S00", "Invalid connection string attribute"},
+	ERROR_ROW = 8,                   //     {"01S01", "Error in row"},
+	OPTION_VALUE_CHANGED = 9,        //    {"01S02", "Option value changed"},
+	FETCH_BEFORE_FIRST_RESULT_SET =
+	    10,                       //    {"01S06", "Attempt to fetch before the result set returned the first rowset"},
+	FRACTIONAL_TRUNCATE = 12,     //    {"01S07", "Fractional truncation"},
+	ERROR_SAVE_DSN_FILE = 13,     //    {"01S08", "Error saving file DSN"},
+	INVALID_KEYWORD = 14,         //    {"01S09", "Invalid keyword"},
+	COUNT_FIELD_INCORRECT = 15,   //    {"07002", "COUNT field incorrect"},
+	PREPARE_STMT_NO_CURSOR = 16,  //    {"07005", "Prepared statement not a cursor-specification"},
+	RESTRICTED_DATA_TYPE = 17,    //    {"07006", "Restricted data type attribute violation"},
+	RETRICT_PARAMETER_VALUE = 18, //    {"07007", "Restricted parameter value violation"},
+	INVALID_DESC_INDEX = 19,      //    {"07009", "Invalid descriptor index"},
+	INVALID_USE_DEFAULT_PARAMETER = 20,     //	{"07S01", "Invalid use of default parameter"},
+	CLIENT_UNABLE_TO_CONNECT = 21,          //	{"08001", "Client unable to establish connection"},
+	CONNECTION_NAME_IN_USE = 22,            //    {"08002", "Connection name in use"},
+	CONNECTION_NOT_OPEN = 23,               //    {"08003", "Connection not open"},
+	SERVER_REJECT_CONNECTION = 24,          //	{"08004", "Server rejected the connection"},
+	CONNECTION_FAIL_TRANSACTION = 25,       //    {"08007", "Connection failure during transaction"},
+	LINK_FAILURE = 26,                      //    {"08S01", "Communication link failure"},
+	FEATURE_NOT_SUPPORTED = 27,             //    {"0A000", "Feature not supported"},
+	LIST_INSERT_MATCH_ERROR = 28,           //    {"21S01", "Insert value list does not match column list"},
+	DERIVED_TABLE_MATCH_ERROR = 29,         //	{"21S02", "Degree of derived table does not match column list"},
+	STR_RIGHT_TRUNCATE2 = 30,               // {"22001", "String data, right truncated"},
+	INDICATOR_VARIABLE_NOT_SUPPLIED = 31,   //    {"22002", "Indicator variable required but not supplied"},
+	NUMERIC_OUT_RANGE = 32,                 //	{"22003", "Numeric value out of range"},
+	INVALID_DATATIME_FORMAT = 33,           //	{"22007", "Invalid datetime format"},
+	DATATIME_OVERVLOW = 34,                 //    {"22008", "Datetime field overflow"},
+	DIVISION_BY_ZERO = 35,                  //    {"22012", "Division by zero"},
+	INTERVAL_OVERFLOW = 36,                 //	{"22015", "Interval field overflow"},
+	INVALID_CAST_CHAR = 37,                 //	{"22018", "Invalid character value for cast specification"},
+	INVALID_ESCAPE_CHAR = 38,               //	{"22019", "Invalid escape character"},
+	INVALID_ESCAPE_SEQ = 39,                //	{"22025", "Invalid escape sequence"},
+	STR_LEN_MISMATCH = 40,                  //	{"22026", "String data, length mismatch"},
+	CONSTRAINT_VIOLATION = 41,              //    {"23000", "Integrity constraint violation"},
+	INVALID_CURSOR_STATE = 42,              //	{"24000", "Invalid cursor state"},
+	INVALID_TRANSACTION_STATE = 43,         //	{"25000", "Invalid transaction state"},
+	TRANSACTION_STATE_UNKNOWN = 44,         //	{"25S01", "Transaction state unknown"},
+	TRANSACTION_STILL_ACTIVE = 45,          //	{"25S02", "Transaction is still active"},
+	TRANSACTION_ROLLED_BACK = 46,           //	{"25S03", "Transaction is rolled back"},
+	INVALID_AUTH = 47,                      //	{"28000", "Invalid authorization specification"},
+	INVALID_CURSOR_NAME = 48,               //	{"34000", "Invalid cursor name"},
+	DUPLICATE_CURSOR_NAME = 49,             //	{"3C000", "Duplicate cursor name"},
+	INVALID_CATALOG_NAME = 50,              //	{"3D000", "Invalid catalog name"},
+	INVALID_SCHEMA_NAME = 51,               //	{"3F000", "Invalid schema name"},
+	SERIALIZATION_FAILURE = 52,             //	{"40001", "Serialization failure"},
+	CONSTRAINT_VIOLATION2 = 53,             // {"40002", "Integrity constraint violation"},
+	STMT_COMPLETION_UNKNOWN = 54,           //	{"40003", "Statement completion unknown"},
+	SYNTAX_ERROR_OR_ACCESS_VIOLATION = 55,  //	{"42000", "Syntax error or access violation"},
+	TABLE_OR_VIEW_ALREADY_EXIST = 56,       // {"42S01", "Base table or view already exists"},
+	TABLE_OR_VIEW_NOT_FOUND = 57,           // {"42S02", "Base table or view not found"},
+	INDEX_ALREADY_EXIST = 58,               // {"42S11", "Index already exists"},
+	INDEX_NOT_FOUND = 59,                   // {"42S12", "Index not found"},
+	COLUMN_ALREADY_EXIST = 60,              // {"42S21", "Column already exists"},
+	COLUMN_NOT_FOUND = 61,                  // {"42S22", "Column not found"},
+	WITH_CHECK_POINT_VIOLARION = 62,        // {"44000", "WITH CHECK OPTION violation"},
+	GENERAL_ERROR = 63,                     // {"HY000", "General error"},
+	MEMORY_ALLOCATION_ERROR = 64,           // {"HY001", "Memory allocation error"},
+	INVALID_APP_BUFFER_TYPE = 65,           // {"HY003", "Invalid application buffer type"},
+	INVALD_SQL_TYPE = 66,                   // {"HY004", "Invalid SQL data type"},
+	STMT_NOT_PREPARED = 67,                 // {"HY007", "Associated statement is not prepared"},
+	OPERATION_CANCELLED = 68,               // {"HY008", "Operation canceled"},
+	INVALIDE_ARGUMENT = 69,                 // {"HY009", "Invalid argument value"},
+	FUNCTION_SEQ_ERROR = 70,                // {"HY010", "Function sequence error"},
+	ATTR_CANNOT_BE_SET_NOW = 71,            // {"HY011", "Attribute cannot be set now"},
+	INVALID_TRANSACTION_OP_CODE = 72,       // {"HY012", "Invalid transaction operation code"},
+	MEMORY_MANAGEMENT_ERROR = 73,           // {"HY013", "Memory management error"},
+	NUMBER_HANDLES_EXCEEDED = 74,           // {"HY014", "Limit on the number of handles exceeded"},
+	NO_CURSOR_NAME_AVAILABLE = 75,          // {"HY015", "No cursor name available"},
+	CANNOT_MODIFY_IRD = 76,                 // {"HY016", "Cannot modify an implementation row descriptor"},
+	INVALID_USE_AUTO_ALLOC_DESCRIPTOR = 77, // {"HY017", "Invalid use of an automatically allocated descriptor handle"},
+	SERVER_DECLINED_CANCEL_REQUEST = 78,    // {"HY018", "Server declined cancel request"},
+	NON_CHAR_BIN_SENT_IN_PIECES = 79,       // {"HY019", "Non-character and non-binary data sent in pieces"},
+	ATTEMPT_CONCAT_NULL_VALUE = 80,         // {"HY020", "Attempt to concatenate a null value"},
+	INCONSISTENT_DESC_INFO = 81,            // {"HY021", "Inconsistent descriptor information"},
+	INVALID_ATTR_VALUE = 82,                // {"HY024", "Invalid attribute value"},
+	INVALID_STR_BUFF_LENGTH = 83,           // {"HY090", "Invalid string or buffer length"},
+	INVALD_DESC_FIELD_ID = 84,              // {"HY091", "Invalid descriptor field identifier"},
+	INVALID_ATTR_OPTION_ID = 85,            // {"HY092", "Invalid attribute/option identifier"},
+	FUNCTION_TYPE_OUT_RANGE = 86,           // {"HY095", "Function type out of range"},
+	INFO_TYPE_OUT_RANGE = 87,               // {"HY096", "Information type out of range"},
+	COLUMN_TYPE_OUT_RANGE = 88,             // {"HY097", "Column type out of range"},
+	SCOPE_TYPE_OUT_RANGE = 89,              // {"HY098", "Scope type out of range"},
+	NULL_TYPE_OUT_RANGE = 90,               // {"HY099", "Nullable type out of range"},
+	UNIQ_OPTION_TYPE_OUT_RANGE = 91,        // {"HY100", "Uniqueness option type out of range"},
+	ACCURARY_OPTION_TYPE_OUT_RANGE = 92,    // {"HY101", "Accuracy option type out of range"},
+	INVALID_RETRIEVAL_CODE = 93,            // {"HY103", "Invalid retrieval code"},
+	INVALID_PREC_SCALE_TYPE = 94,           // {"HY104", "Invalid precision or scale value"},
+	INVALID_PARAMETER_TYPE = 95,            // {"HY105", "Invalid parameter type"},
+	FETCH_TYPE_OUT_RANGE = 96,              // {"HY106", "Fetch type out of range"},
+	ROW_VALUE_OUT_RANGE = 97,               // {"HY107", "Row value out of range"},
+	INVALID_CURSOR_POS = 98,                // {"HY109", "Invalid cursor position"},
+	INVALID_DRIVER_COMPLETION = 99,         // {"HY110", "Invalid driver completion"},
+	INVALID_BOOKMARK_VALUE = 100,           // {"HY111", "Invalid bookmark value"},
+	NOT_SUPPORT_ASYNC_FUNCT_EXECUTION =
+	    101, // {"HY114", "Driver does not support connection-level asynchronous function execution"},
+	SQLENDTRAN_ASYNC_FUNCT_EXECUTION = 102, // {"HY115", "SQLEndTran is not allowed for an environment that contains a
+	                                        // connection with asynchronous function execution enabled"},
+	CONNECTION_UNKNOW_TRANSACTION_STATE = 103, // {"HY117", "Connection is suspended due to unknown transaction state.
+	                                           // Only disconnect and read-only functions are allowed."},
+	CURSOR_DRIVER_POOLING_SAME_TIME =
+	    104, // {"HYHY121", "Cursor Library and Driver-Aware Pooling cannot be enabled at the same time"},
+	OPT_FEATURE_NOT_IMPLEMENTED = 105,       // {"HYC00", "Optional feature not implemented"},
+	TIMEOUT_EXPIRED = 106,                   // {"HYT00", "Timeout expired"},
+	CONNECTION_TIMEOUT_EXPIRED = 107,        // {"HYT01", "Connection timeout expired"},
+	DRIVER_NOT_SUPPORT_FUNCTION = 108,       // {"IM001", "Driver does not support this function"},
+	DSN_NOT_FOUND_NO_DEFAULT = 109,          // {"IM002", "Data source not found and no default driver specified"},
+	DRIVER_COULD_NOT_BE_CONNECTED = 110,     // {"IM003", "Specified driver could not be connected to"},
+	ALLOC_HANDLE_ENV_FAIL = 111,             // {"IM004", "Driver's SQLAllocHandle on SQL_HANDLE_ENV failed"},
+	ALLOC_HANDLE_DBC_FAIL = 112,             // {"IM005", "Driver's SQLAllocHandle on SQL_HANDLE_DBC failed"},
+	SET_CONNECTION_ATTR_FAIL = 113,          // {"IM006", "Driver's SQLSetConnectAttr failed"},
+	NO_DSN_OR_DRIVER = 114,                  // {"IM007", "No data source or driver specified; dialog prohibited"},
+	DIALOG_FAIL = 115,                       // {"IM008", "Dialog failed"},
+	UNABLE_CONNECT_TO_TRANSLATION_DLL = 116, // {"IM009", "Unable to connect to translation DLL"},
+	DSN_TOO_LONG = 117,                      // {"IM010", "Data source name too long"},
+	DRIVER_NAME_TOO_LONG = 118,              // {"IM011", "Driver name too long"},
+	KEYWORD_SYNTAX_ERROR = 119,              // {"IM012", "DRIVER keyword syntax error"},
+	DNS_ARCHITECTURE_MISMATCH =
+	    120, // {"IM014", "The specified DSN contains an architecture mismatch between the Driver and Application"},
+	CONNECT_HANDLE_DBC_INFO_FAIL = 121, // {"IM015", "Driver's SQLConnect on SQL_HANDLE_DBC_INFO_HANDLE failed"},
+	POLLING_DISABLED_ACYNC_NOTIGICATION_MODE =
+	    122,                             // {"IM017", "Polling is disabled in asynchronous notification mode"},
+	SHOULD_CALL_COMPLETE_ASYNC = 123,    // {"IM018", "SQLCompleteAsync has not been called to complete the previous
+	                                     // asynchronous operation on this handle."},
+	NOT_SUPPORT_ASYNC_NOTIFICATION = 124 // {"S1118", "Driver does not support asynchronous notification"};
+};
+
+struct SQLState {
+	std::string code;
+	std::string erro_msg;
+};
+
+struct EnumClassHash {
+	template <typename T>
+	std::size_t operator()(T t) const {
+		return static_cast<std::size_t>(t);
+	}
+};
+
+struct DiagRecord {
+public:
+	explicit DiagRecord(const std::string &msg, const SQLStateType &sqlstate_type, const std::string &server_name = "",
+	                    SQLINTEGER col_number = SQL_NO_COLUMN_NUMBER, SQLINTEGER sql_native = 0,
+	                    SQLLEN row_number = SQL_NO_ROW_NUMBER);
+	DiagRecord(const DiagRecord &other);
+	DiagRecord &operator=(const DiagRecord &other);
+
+	std::string GetOriginalMessage();
+	std::string GetMessage(SQLSMALLINT buff_length);
+	void SetMessage(const std::string &new_msg);
+	void ClearStackMsgOffset();
+
+public:
+	// Some fields were commented out because they can be extract from other fields or internal data structures
+	// std::string sql_diag_class_origin;
+	SQLINTEGER sql_diag_column_number = SQL_NO_COLUMN_NUMBER;
+	// std::string sql_diag_connection_name;
+	SQLINTEGER sql_diag_native = 0;
+	SQLLEN sql_diag_row_number = SQL_NO_ROW_NUMBER;
+	std::string sql_diag_server_name;
+	std::string sql_diag_sqlstate;
+	// std::string sql_diag_subclass_origin;
+	// default id_diag
+	std::string sql_diag_message_text;
+	std::stack<duckdb::idx_t> stack_msg_offset;
+};
+
+struct DiagHeader {
+public:
+	SQLLEN sql_diag_cursor_row_count;
+	// std::string sql_diag_dynamic_function; // this field is extract from map_dynamic_function
+	SQLINTEGER sql_diag_dynamic_function_code = SQL_DIAG_UNKNOWN_STATEMENT;
+	SQLINTEGER sql_diag_number;
+	SQLRETURN sql_diag_return_code;
+	SQLLEN sql_diag_row_count;
+};
+
+class OdbcDiagnostic {
+public:
+	DiagHeader header;
+	std::vector<DiagRecord> diag_records;
+	// vector that mantains the indexes of DiagRecord
+	std::vector<SQLSMALLINT> vec_record_idx;
+	static const std::unordered_map<SQLINTEGER, std::string> MAP_DYNAMIC_FUNCTION;
+	static const std::set<std::string> SET_ODBC3_SUBCLASS_ORIGIN;
+	static const std::unordered_map<SQLStateType, SQLState, EnumClassHash> MAP_ODBC_SQL_STATES;
+
+public:
+	static bool IsDiagRecordField(SQLSMALLINT diag_identifier);
+
+	void FormatDiagnosticMessage(DiagRecord &diag_record, const std::string &data_source, const std::string &component);
+	void AddDiagRecord(DiagRecord &diag_record);
+	void AddNewRecIdx(SQLSMALLINT rec_idx);
+	duckdb::idx_t GetTotalRecords();
+
+	void Clean();
+
+	std::string GetDiagDynamicFunction();
+	bool VerifyRecordIndex(SQLINTEGER rec_idx);
+	DiagRecord &GetDiagRecord(SQLINTEGER rec_idx);
+	std::string GetDiagClassOrigin(SQLINTEGER rec_idx);
+	std::string GetDiagSubclassOrigin(SQLINTEGER rec_idx);
+};
+
+} // namespace duckdb
+#endif
\ No newline at end of file
diff --git a/tools/odbc/include/odbc_exception.hpp b/tools/odbc/include/odbc_exception.hpp
new file mode 100644
index 000000000000..11fb74d015eb
--- /dev/null
+++ b/tools/odbc/include/odbc_exception.hpp
@@ -0,0 +1,27 @@
+#ifndef ODBC_EXCEPTION_HPP
+#define ODBC_EXCEPTION_HPP
+
+#include "odbc_diagnostic.hpp"
+#include "sqlext.h"
+#include "sqltypes.h"
+
+#include <stdexcept>
+#include <string>
+
+namespace duckdb {
+struct OdbcException : public std::exception {
+public:
+	explicit OdbcException(const std::string &comp, SQLRETURN ret, const DiagRecord &diag_rec)
+	    : component(comp), sql_ret(ret), diag_record(diag_rec) {};
+
+	const std::string GetComponent();
+	const SQLRETURN GetSqlReturn();
+	const DiagRecord &GetDiagRecord();
+
+private:
+	std::string component;
+	SQLRETURN sql_ret = SQL_ERROR;
+	duckdb::DiagRecord diag_record;
+};
+} // namespace duckdb
+#endif
\ No newline at end of file
diff --git a/tools/odbc/include/odbc_utils.hpp b/tools/odbc/include/odbc_utils.hpp
index 81fba29779dc..b73e008c6ae0 100644
--- a/tools/odbc/include/odbc_utils.hpp
+++ b/tools/odbc/include/odbc_utils.hpp
@@ -19,14 +19,19 @@ struct OdbcUtils {
 	static std::string ReadString(const SQLPOINTER ptr, const SQLSMALLINT len);
 	// static void WriteString(const std::string &s, SQLCHAR *out_buf, SQLSMALLINT buf_len, SQLSMALLINT *out_len);
 	template <typename INT_TYPE>
-	static void WriteString(const string &s, SQLCHAR *out_buf, SQLSMALLINT buf_len, INT_TYPE *out_len) {
+	static void WriteString(const string &s, SQLCHAR *out_buf, SQLSMALLINT buf_len, INT_TYPE *out_len = nullptr) {
+		INT_TYPE written_chars = 0;
 		if (out_buf) {
-			snprintf((char *)out_buf, buf_len, "%s", s.c_str());
+			written_chars = (INT_TYPE)snprintf((char *)out_buf, buf_len, "%s", s.c_str());
 		}
 		if (out_len) {
-			*out_len = s.size();
+			*out_len = written_chars;
 		}
 	}
+	// template specialization for int to pass a null pointer
+	static void WriteString(const string &s, SQLCHAR *out_buf, SQLSMALLINT buf_len) {
+		WriteString<int>(s, out_buf, buf_len, nullptr);
+	}
 
 	template <typename FIELD_TYPE>
 	SQLRETURN IsValidPtrForSpecificedField(SQLPOINTER value_ptr, FIELD_TYPE target_field,
diff --git a/tools/odbc/odbc_diagnostic.cpp b/tools/odbc/odbc_diagnostic.cpp
new file mode 100644
index 000000000000..1a998a1a1ee3
--- /dev/null
+++ b/tools/odbc/odbc_diagnostic.cpp
@@ -0,0 +1,355 @@
+#include "odbc_diagnostic.hpp"
+
+using duckdb::DiagHeader;
+using duckdb::DiagRecord;
+using duckdb::OdbcDiagnostic;
+using duckdb::SQLState;
+using duckdb::SQLStateType;
+using std::string;
+
+// OdbcDiagnostic static initializations and functions ******************************
+const std::unordered_map<SQLINTEGER, std::string> OdbcDiagnostic::MAP_DYNAMIC_FUNCTION = {
+    {SQL_DIAG_ALTER_DOMAIN, "ALTER DOMAIN"},
+    {SQL_DIAG_ALTER_TABLE, "ALTER TABLE"},
+    {SQL_DIAG_CREATE_ASSERTION, "CREATE ASSERTION"},
+    {SQL_DIAG_CREATE_CHARACTER_SET, "CREATE CHARACTER SET"},
+    {SQL_DIAG_CREATE_COLLATION, "CREATE COLLATION"},
+    {SQL_DIAG_CREATE_DOMAIN, "CREATE DOMAIN"},
+    {SQL_DIAG_CREATE_INDEX, "CREATE INDEX"},
+    {SQL_DIAG_CREATE_TABLE, "CREATE TABLE"},
+    {SQL_DIAG_CREATE_VIEW, "CREATE VIEW"},
+    {SQL_DIAG_SELECT_CURSOR, "SELECT CURSOR"},
+    {SQL_DIAG_DYNAMIC_DELETE_CURSOR, "DYNAMIC DELETE CURSOR"},
+    {SQL_DIAG_DELETE_WHERE, "DELETE WHERE"},
+    {SQL_DIAG_DROP_ASSERTION, "DROP ASSERTION"},
+    {SQL_DIAG_DROP_CHARACTER_SET, "DROP CHARACTER SET"},
+    {SQL_DIAG_DROP_COLLATION, "DROP COLLATION"},
+    {SQL_DIAG_DROP_DOMAIN, "DROP DOMAIN"},
+    {SQL_DIAG_DROP_INDEX, "DROP INDEX"},
+    {SQL_DIAG_DROP_SCHEMA, "DROP SCHEMA"},
+    {SQL_DIAG_DROP_TABLE, "DROP TABLE"},
+    {SQL_DIAG_DROP_TRANSLATION, "DROP TRANSLATION"},
+    {SQL_DIAG_DROP_VIEW, "DROP VIEW"},
+    {SQL_DIAG_GRANT, "GRANT"},
+    {SQL_DIAG_INSERT, "INSERT"},
+    {SQL_DIAG_CALL, "CALL"},
+    {SQL_DIAG_REVOKE, "REVOKE"},
+    {SQL_DIAG_CREATE_SCHEMA, "CREATE SCHEMA"},
+    {SQL_DIAG_CREATE_TRANSLATION, "CREATE TRANSLATION"},
+    {SQL_DIAG_DYNAMIC_UPDATE_CURSOR, "DYNAMIC UPDATE CURSOR"},
+    {SQL_DIAG_UPDATE_WHERE, "UPDATE WHERE"},
+    {SQL_DIAG_UNKNOWN_STATEMENT, ""}};
+
+const std::set<std::string> OdbcDiagnostic::SET_ODBC3_SUBCLASS_ORIGIN = {
+    {"01S00"}, {"01S01"}, {"01S02"}, {"01S06"}, {"01S07"}, {"07S01"}, {"08S01"}, {"21S01"}, {"21S02"},
+    {"25S01"}, {"25S02"}, {"25S03"}, {"42S01"}, {"42S02"}, {"42S11"}, {"42S12"}, {"42S21"}, {"42S22"},
+    {"HY095"}, {"HY097"}, {"HY098"}, {"HY099"}, {"HY100"}, {"HY101"}, {"HY105"}, {"HY107"}, {"HY109"},
+    {"HY110"}, {"HY111"}, {"HYT00"}, {"HYT01"}, {"IM001"}, {"IM002"}, {"IM003"}, {"IM004"}, {"IM005"},
+    {"IM006"}, {"IM007"}, {"IM008"}, {"IM010"}, {"IM011"}, {"IM012"}};
+
+const std::unordered_map<SQLStateType, SQLState, duckdb::EnumClassHash> OdbcDiagnostic::MAP_ODBC_SQL_STATES = {
+    {SQLStateType::GENERAL_WARNING, {"01000", "General warning"}},
+    {SQLStateType::CURSOR_CONFLICT, {"01001", "Cursor operation conflict"}},
+    {SQLStateType::DISCONNECT_ERROR, {"01002", "Disconnect error"}},
+    {SQLStateType::NULL_VALUE_ELIM, {"01003", "NULL value eliminated in set function"}},
+    {SQLStateType::STR_RIGHT_TRUNCATE, {"01004", "String data, right truncated"}},
+    {SQLStateType::PRIVILEGE_NOT_REVOKED, {"01006", "Privilege not revoked"}},
+    {SQLStateType::PRIVILEGE_NOT_GRANTED, {"01007", "Privilege not granted"}},
+    {SQLStateType::INVALID_CONNECTION_STR_ATTR, {"01S00", "Invalid connection string attribute"}},
+    {SQLStateType::ERROR_ROW, {"01S01", "Error in row"}},
+    {SQLStateType::OPTION_VALUE_CHANGED, {"01S02", "Option value changed"}},
+    {SQLStateType::FETCH_BEFORE_FIRST_RESULT_SET,
+     {"01S06", "Attempt to fetch before the result set returned the first rowset"}},
+    {SQLStateType::FRACTIONAL_TRUNCATE, {"01S07", "Fractional truncation"}},
+    {SQLStateType::ERROR_SAVE_DSN_FILE, {"01S08", "Error saving file DSN"}},
+    {SQLStateType::INVALID_KEYWORD, {"01S09", "Invalid keyword"}},
+    {SQLStateType::COUNT_FIELD_INCORRECT, {"07002", "COUNT field incorrect"}},
+    {SQLStateType::PREPARE_STMT_NO_CURSOR, {"07005", "Prepared statement not a cursor-specification"}},
+    {SQLStateType::RESTRICTED_DATA_TYPE, {"07006", "Restricted data type attribute violation"}},
+    {SQLStateType::RETRICT_PARAMETER_VALUE, {"07007", "Restricted parameter value violation"}},
+    {SQLStateType::INVALID_DESC_INDEX, {"07009", "Invalid descriptor index"}},
+    {SQLStateType::INVALID_USE_DEFAULT_PARAMETER, {"07S01", "Invalid use of default parameter"}},
+    {SQLStateType::CLIENT_UNABLE_TO_CONNECT, {"08001", "Client unable to establish connection"}},
+    {SQLStateType::CONNECTION_NAME_IN_USE, {"08002", "Connection name in use"}},
+    {SQLStateType::CONNECTION_NOT_OPEN, {"08003", "Connection not open"}},
+    {SQLStateType::SERVER_REJECT_CONNECTION, {"08004", "Server rejected the connection"}},
+    {SQLStateType::CONNECTION_FAIL_TRANSACTION, {"08007", "Connection failure during transaction"}},
+    {SQLStateType::LINK_FAILURE, {"08S01", "Communication link failure"}},
+    {SQLStateType::FEATURE_NOT_SUPPORTED, {"0A000", "Feature not supported"}},
+    {SQLStateType::LIST_INSERT_MATCH_ERROR, {"21S01", "Insert value list does not match column list"}},
+    {SQLStateType::DERIVED_TABLE_MATCH_ERROR, {"21S02", "Degree of derived table does not match column list"}},
+    {SQLStateType::STR_RIGHT_TRUNCATE2, {"22001", "String data, right truncated"}},
+    {SQLStateType::INDICATOR_VARIABLE_NOT_SUPPLIED, {"22002", "Indicator variable required but not supplied"}},
+    {SQLStateType::NUMERIC_OUT_RANGE, {"22003", "Numeric value out of range"}},
+    {SQLStateType::INVALID_DATATIME_FORMAT, {"22007", "Invalid datetime format"}},
+    {SQLStateType::DATATIME_OVERVLOW, {"22008", "Datetime field overflow"}},
+    {SQLStateType::DIVISION_BY_ZERO, {"22012", "Division by zero"}},
+    {SQLStateType::INTERVAL_OVERFLOW, {"22015", "Interval field overflow"}},
+    {SQLStateType::INVALID_CAST_CHAR, {"22018", "Invalid character value for cast specification"}},
+    {SQLStateType::INVALID_ESCAPE_CHAR, {"22019", "Invalid escape character"}},
+    {SQLStateType::INVALID_ESCAPE_SEQ, {"22025", "Invalid escape sequence"}},
+    {SQLStateType::STR_LEN_MISMATCH, {"22026", "String data, length mismatch"}},
+    {SQLStateType::CONSTRAINT_VIOLATION, {"23000", "Integrity constraint violation"}},
+    {SQLStateType::INVALID_CURSOR_STATE, {"24000", "Invalid cursor state"}},
+    {SQLStateType::INVALID_TRANSACTION_STATE, {"25000", "Invalid transaction state"}},
+    {SQLStateType::TRANSACTION_STATE_UNKNOWN, {"25S01", "Transaction state unknown"}},
+    {SQLStateType::TRANSACTION_STILL_ACTIVE, {"25S02", "Transaction is still active"}},
+    {SQLStateType::TRANSACTION_ROLLED_BACK, {"25S03", "Transaction is rolled back"}},
+    {SQLStateType::INVALID_AUTH, {"28000", "Invalid authorization specification"}},
+    {SQLStateType::INVALID_CURSOR_NAME, {"34000", "Invalid cursor name"}},
+    {SQLStateType::DUPLICATE_CURSOR_NAME, {"3C000", "Duplicate cursor name"}},
+    {SQLStateType::INVALID_CATALOG_NAME, {"3D000", "Invalid catalog name"}},
+    {SQLStateType::INVALID_SCHEMA_NAME, {"3F000", "Invalid schema name"}},
+    {SQLStateType::SERIALIZATION_FAILURE, {"40001", "Serialization failure"}},
+    {SQLStateType::CONSTRAINT_VIOLATION2, {"40002", "Integrity constraint violation"}},
+    {SQLStateType::STMT_COMPLETION_UNKNOWN, {"40003", "Statement completion unknown"}},
+    {SQLStateType::SYNTAX_ERROR_OR_ACCESS_VIOLATION, {"42000", "Syntax error or access violation"}},
+    {SQLStateType::TABLE_OR_VIEW_ALREADY_EXIST, {"42S01", "Base table or view already exists"}},
+    {SQLStateType::TABLE_OR_VIEW_NOT_FOUND, {"42S02", "Base table or view not found"}},
+    {SQLStateType::INDEX_ALREADY_EXIST, {"42S11", "Index already exists"}},
+    {SQLStateType::INDEX_NOT_FOUND, {"42S12", "Index not found"}},
+    {SQLStateType::COLUMN_ALREADY_EXIST, {"42S21", "Column already exists"}},
+    {SQLStateType::COLUMN_NOT_FOUND, {"42S22", "Column not found"}},
+    {SQLStateType::WITH_CHECK_POINT_VIOLARION, {"44000", "WITH CHECK OPTION violation"}},
+    {SQLStateType::GENERAL_ERROR, {"HY000", "General error"}},
+    {SQLStateType::MEMORY_ALLOCATION_ERROR, {"HY001", "Memory allocation error"}},
+    {SQLStateType::INVALID_APP_BUFFER_TYPE, {"HY003", "Invalid application buffer type"}},
+    {SQLStateType::INVALD_SQL_TYPE, {"HY004", "Invalid SQL data type"}},
+    {SQLStateType::STMT_NOT_PREPARED, {"HY007", "Associated statement is not prepared"}},
+    {SQLStateType::OPERATION_CANCELLED, {"HY008", "Operation canceled"}},
+    {SQLStateType::INVALIDE_ARGUMENT, {"HY009", "Invalid argument value"}},
+    {SQLStateType::FUNCTION_SEQ_ERROR, {"HY010", "Function sequence error"}},
+    {SQLStateType::ATTR_CANNOT_BE_SET_NOW, {"HY011", "Attribute cannot be set now"}},
+    {SQLStateType::INVALID_TRANSACTION_OP_CODE, {"HY012", "Invalid transaction operation code"}},
+    {SQLStateType::MEMORY_MANAGEMENT_ERROR, {"HY013", "Memory management error"}},
+    {SQLStateType::NUMBER_HANDLES_EXCEEDED, {"HY014", "Limit on the number of handles exceeded"}},
+    {SQLStateType::NO_CURSOR_NAME_AVAILABLE, {"HY015", "No cursor name available"}},
+    {SQLStateType::CANNOT_MODIFY_IRD, {"HY016", "Cannot modify an implementation row descriptor"}},
+    {SQLStateType::INVALID_USE_AUTO_ALLOC_DESCRIPTOR,
+     {"HY017", "Invalid use of an automatically allocated descriptor handle"}},
+    {SQLStateType::SERVER_DECLINED_CANCEL_REQUEST, {"HY018", "Server declined cancel request"}},
+    {SQLStateType::NON_CHAR_BIN_SENT_IN_PIECES, {"HY019", "Non-character and non-binary data sent in pieces"}},
+    {SQLStateType::ATTEMPT_CONCAT_NULL_VALUE, {"HY020", "Attempt to concatenate a null value"}},
+    {SQLStateType::INCONSISTENT_DESC_INFO, {"HY021", "Inconsistent descriptor information"}},
+    {SQLStateType::INVALID_ATTR_VALUE, {"HY024", "Invalid attribute value"}},
+    {SQLStateType::INVALID_STR_BUFF_LENGTH, {"HY090", "Invalid string or buffer length"}},
+    {SQLStateType::INVALD_DESC_FIELD_ID, {"HY091", "Invalid descriptor field identifier"}},
+    {SQLStateType::INVALID_ATTR_OPTION_ID, {"HY092", "Invalid attribute/option identifier"}},
+    {SQLStateType::FUNCTION_TYPE_OUT_RANGE, {"HY095", "Function type out of range"}},
+    {SQLStateType::INFO_TYPE_OUT_RANGE, {"HY096", "Information type out of range"}},
+    {SQLStateType::COLUMN_TYPE_OUT_RANGE, {"HY097", "Column type out of range"}},
+    {SQLStateType::SCOPE_TYPE_OUT_RANGE, {"HY098", "Scope type out of range"}},
+    {SQLStateType::NULL_TYPE_OUT_RANGE, {"HY099", "Nullable type out of range"}},
+    {SQLStateType::UNIQ_OPTION_TYPE_OUT_RANGE, {"HY100", "Uniqueness option type out of range"}},
+    {SQLStateType::ACCURARY_OPTION_TYPE_OUT_RANGE, {"HY101", "Accuracy option type out of range"}},
+    {SQLStateType::INVALID_RETRIEVAL_CODE, {"HY103", "Invalid retrieval code"}},
+    {SQLStateType::INVALID_PREC_SCALE_TYPE, {"HY104", "Invalid precision or scale value"}},
+    {SQLStateType::INVALID_PARAMETER_TYPE, {"HY105", "Invalid parameter type"}},
+    {SQLStateType::FETCH_TYPE_OUT_RANGE, {"HY106", "Fetch type out of range"}},
+    {SQLStateType::ROW_VALUE_OUT_RANGE, {"HY107", "Row value out of range"}},
+    {SQLStateType::INVALID_CURSOR_POS, {"HY109", "Invalid cursor position"}},
+    {SQLStateType::INVALID_DRIVER_COMPLETION, {"HY110", "Invalid driver completion"}},
+    {SQLStateType::INVALID_BOOKMARK_VALUE, {"HY111", "Invalid bookmark value"}},
+    {SQLStateType::NOT_SUPPORT_ASYNC_FUNCT_EXECUTION,
+     {"HY114", "Driver does not support connection-level asynchronous function execution"}},
+    {SQLStateType::SQLENDTRAN_ASYNC_FUNCT_EXECUTION,
+     {"HY115", "SQLEndTran is not allowed for an environment that contains a connection with asynchronous function "
+               "execution enabled"}},
+    {SQLStateType::CONNECTION_UNKNOW_TRANSACTION_STATE,
+     {"HY117", "Connection is suspended due to unknown transaction state. Only disconnect and read-only functions are "
+               "allowed."}},
+    {SQLStateType::CURSOR_DRIVER_POOLING_SAME_TIME,
+     {"HY121", "Cursor Library and Driver-Aware Pooling cannot be enabled at the same time"}},
+    {SQLStateType::OPT_FEATURE_NOT_IMPLEMENTED, {"HYC00", "Optional feature not implemented"}},
+    {SQLStateType::TIMEOUT_EXPIRED, {"HYT00", "Timeout expired"}},
+    {SQLStateType::CONNECTION_TIMEOUT_EXPIRED, {"HYT01", "Connection timeout expired"}},
+    {SQLStateType::DRIVER_NOT_SUPPORT_FUNCTION, {"IM001", "Driver does not support this function"}},
+    {SQLStateType::DSN_NOT_FOUND_NO_DEFAULT, {"IM002", "Data source not found and no default driver specified"}},
+    {SQLStateType::DRIVER_COULD_NOT_BE_CONNECTED, {"IM003", "Specified driver could not be connected to"}},
+    {SQLStateType::ALLOC_HANDLE_ENV_FAIL, {"IM004", "Driver's SQLAllocHandle on SQL_HANDLE_ENV failed"}},
+    {SQLStateType::ALLOC_HANDLE_DBC_FAIL, {"IM005", "Driver's SQLAllocHandle on SQL_HANDLE_DBC failed"}},
+    {SQLStateType::SET_CONNECTION_ATTR_FAIL, {"IM006", "Driver's SQLSetConnectAttr failed"}},
+    {SQLStateType::NO_DSN_OR_DRIVER, {"IM007", "No data source or driver specified; dialog prohibited"}},
+    {SQLStateType::DIALOG_FAIL, {"IM008", "Dialog failed"}},
+    {SQLStateType::UNABLE_CONNECT_TO_TRANSLATION_DLL, {"IM009", "Unable to connect to translation DLL"}},
+    {SQLStateType::DSN_TOO_LONG, {"IM010", "Data source name too long"}},
+    {SQLStateType::DRIVER_NAME_TOO_LONG, {"IM011", "Driver name too long"}},
+    {SQLStateType::KEYWORD_SYNTAX_ERROR, {"IM012", "DRIVER keyword syntax error"}},
+    {SQLStateType::DNS_ARCHITECTURE_MISMATCH,
+     {"IM014", "The specified DSN contains an architecture mismatch between the Driver and Application"}},
+    {SQLStateType::CONNECT_HANDLE_DBC_INFO_FAIL, {"IM015", "Driver's SQLConnect on SQL_HANDLE_DBC_INFO_HANDLE failed"}},
+    {SQLStateType::POLLING_DISABLED_ACYNC_NOTIGICATION_MODE,
+     {"IM017", "Polling is disabled in asynchronous notification mode"}},
+    {SQLStateType::SHOULD_CALL_COMPLETE_ASYNC,
+     {"IM018", "SQLCompleteAsync has not been called to complete the previous asynchronous operation on this handle."}},
+    {SQLStateType::NOT_SUPPORT_ASYNC_NOTIFICATION, {"S1118", "Driver does not support asynchronous notification"}}};
+
+bool OdbcDiagnostic::IsDiagRecordField(SQLSMALLINT rec_field) {
+	switch (rec_field) {
+	case SQL_DIAG_CLASS_ORIGIN:
+	case SQL_DIAG_COLUMN_NUMBER:
+	case SQL_DIAG_CONNECTION_NAME:
+	case SQL_DIAG_MESSAGE_TEXT:
+	case SQL_DIAG_NATIVE:
+	case SQL_DIAG_ROW_NUMBER:
+	case SQL_DIAG_SERVER_NAME:
+	case SQL_DIAG_SQLSTATE:
+	case SQL_DIAG_SUBCLASS_ORIGIN:
+		return true;
+	default:
+		return false;
+	}
+}
+
+void OdbcDiagnostic::FormatDiagnosticMessage(DiagRecord &diag_record, const std::string &data_source,
+                                             const std::string &component) {
+	// https://docs.microsoft.com/en-us/sql/odbc/reference/develop-app/diagnostic-messages?view=sql-server-ver15
+	// [ vendor-identifier ][ ODBC-component-identifier ][ data-source-identifier ] data-source-supplied-text
+	auto error_msg = diag_record.GetOriginalMessage();
+
+	string msg = "ODBC_DuckDB";
+	if (!data_source.empty()) {
+		msg += "->" + data_source;
+	}
+	if (!component.empty()) {
+		msg += "->" + component;
+	}
+	msg += "
" + error_msg;
+
+	diag_record.SetMessage(msg);
+}
+
+void OdbcDiagnostic::AddDiagRecord(DiagRecord &diag_record) {
+	auto rec_idx = (SQLSMALLINT)diag_records.size();
+	diag_records.emplace_back(diag_record);
+	vec_record_idx.emplace_back(rec_idx);
+}
+
+void OdbcDiagnostic::AddNewRecIdx(SQLSMALLINT rec_idx) {
+	auto origin_idx = vec_record_idx[rec_idx];
+	auto begin = vec_record_idx.begin();
+	vec_record_idx.emplace(std::next(begin, rec_idx + 1), origin_idx);
+}
+
+duckdb::idx_t OdbcDiagnostic::GetTotalRecords() {
+	return vec_record_idx.size();
+}
+
+void OdbcDiagnostic::Clean() {
+	header = DiagHeader();
+	diag_records.clear();
+	vec_record_idx.clear();
+}
+
+string OdbcDiagnostic::GetDiagDynamicFunction() {
+	auto entry = MAP_DYNAMIC_FUNCTION.find(header.sql_diag_dynamic_function_code);
+	if (entry == MAP_DYNAMIC_FUNCTION.end()) {
+		return "";
+	}
+	return entry->second;
+}
+
+bool OdbcDiagnostic::VerifyRecordIndex(SQLINTEGER rec_idx) {
+	return (rec_idx < (SQLINTEGER)diag_records.size() && rec_idx >= 0);
+}
+
+DiagRecord &OdbcDiagnostic::GetDiagRecord(SQLINTEGER rec_idx) {
+	D_ASSERT(rec_idx < (SQLINTEGER)vec_record_idx.size() && rec_idx >= 0);
+	auto origin_idx = vec_record_idx[rec_idx];
+	auto diag_record = &diag_records[origin_idx];
+	// getting first record, clear up vec_record_idx
+	if (rec_idx == 0) {
+		vec_record_idx.clear();
+		for (duckdb::idx_t i = 0; i < diag_records.size(); ++i) {
+			vec_record_idx.emplace_back(i);
+			diag_records[i].ClearStackMsgOffset();
+		}
+	}
+	return *diag_record;
+}
+
+std::string OdbcDiagnostic::GetDiagClassOrigin(SQLINTEGER rec_idx) {
+	D_ASSERT(rec_idx < (SQLINTEGER)diag_records.size() && rec_idx >= 0);
+	auto sqlstate_str = diag_records[rec_idx].sql_diag_sqlstate;
+	if (sqlstate_str.find("IM") != std::string::npos) {
+		return "ODBC 3.0";
+	} else {
+		return "ISO 9075";
+	}
+}
+
+std::string OdbcDiagnostic::GetDiagSubclassOrigin(SQLINTEGER rec_idx) {
+	D_ASSERT(rec_idx < (SQLINTEGER)diag_records.size() && rec_idx >= 0);
+	auto sqlstate_str = diag_records[rec_idx].sql_diag_sqlstate;
+	;
+	if (SET_ODBC3_SUBCLASS_ORIGIN.find(sqlstate_str) != SET_ODBC3_SUBCLASS_ORIGIN.end()) {
+		return "ODBC 3.0";
+	} else {
+		return "ISO 9075";
+	}
+}
+
+// DiagRecord functions ****************************************************************
+DiagRecord::DiagRecord(const std::string &msg, const SQLStateType &sqlstate_type, const std::string &server_name,
+                       SQLINTEGER col_number, SQLINTEGER sql_native, SQLLEN row_number) {
+	D_ASSERT(!msg.empty());
+
+	sql_diag_message_text = msg;
+
+	auto entry = OdbcDiagnostic::MAP_ODBC_SQL_STATES.find(sqlstate_type);
+	if (entry != OdbcDiagnostic::MAP_ODBC_SQL_STATES.end()) {
+		sql_diag_sqlstate = entry->second.code;
+	}
+
+	sql_diag_server_name = server_name;
+	sql_diag_column_number = col_number;
+	sql_diag_native = sql_native;
+	sql_diag_row_number = row_number;
+
+	stack_msg_offset.push(0);
+}
+
+DiagRecord::DiagRecord(const DiagRecord &other) {
+	// calling copy assigment operator
+	*this = other;
+}
+
+DiagRecord &DiagRecord::operator=(const DiagRecord &other) {
+	if (&other != this) {
+		sql_diag_message_text = other.sql_diag_message_text;
+		sql_diag_sqlstate = other.sql_diag_sqlstate;
+		sql_diag_server_name = other.sql_diag_server_name;
+		sql_diag_column_number = other.sql_diag_column_number;
+		sql_diag_native = other.sql_diag_native;
+		sql_diag_row_number = other.sql_diag_row_number;
+		stack_msg_offset = other.stack_msg_offset;
+	}
+	return *this;
+}
+
+std::string DiagRecord::GetOriginalMessage() {
+	return sql_diag_message_text;
+}
+
+std::string DiagRecord::GetMessage(SQLSMALLINT buff_length) {
+	duckdb::idx_t last_offset = stack_msg_offset.top();
+	auto new_offset = last_offset + buff_length;
+	if (new_offset >= sql_diag_message_text.size()) {
+		ClearStackMsgOffset();
+	} else {
+		stack_msg_offset.push(new_offset);
+	}
+	return sql_diag_message_text.substr(last_offset);
+}
+
+void DiagRecord::SetMessage(const std::string &new_msg) {
+	D_ASSERT(!new_msg.empty());
+	sql_diag_message_text = new_msg;
+	ClearStackMsgOffset();
+}
+
+void DiagRecord::ClearStackMsgOffset() {
+	while (!stack_msg_offset.empty() && stack_msg_offset.top() != 0) {
+		stack_msg_offset.pop();
+	}
+}
\ No newline at end of file
diff --git a/tools/odbc/odbc_exception.cpp b/tools/odbc/odbc_exception.cpp
new file mode 100644
index 000000000000..d78d6b88d60c
--- /dev/null
+++ b/tools/odbc/odbc_exception.cpp
@@ -0,0 +1,16 @@
+#include "odbc_exception.hpp"
+
+using duckdb::DiagRecord;
+using duckdb::OdbcException;
+
+const std::string OdbcException::GetComponent() {
+	return component;
+}
+
+const SQLRETURN OdbcException::GetSqlReturn() {
+	return sql_ret;
+}
+
+const DiagRecord &OdbcException::GetDiagRecord() {
+	return diag_record;
+}
\ No newline at end of file
diff --git a/tools/odbc/odbc_interval.cpp b/tools/odbc/odbc_interval.cpp
index 7a8073326966..6c1ab59915a3 100644
--- a/tools/odbc/odbc_interval.cpp
+++ b/tools/odbc/odbc_interval.cpp
@@ -1,10 +1,13 @@
 #include "odbc_interval.hpp"
 #include "duckdb/common/operator/cast_operators.hpp"
+#include "odbc_diagnostic.hpp"
+#include "odbc_exception.hpp"
 #include <sqltypes.h>
 #include <sqlext.h>
 
 using duckdb::interval_t;
 using duckdb::OdbcInterval;
+using duckdb::SQLStateType;
 using duckdb::Value;
 
 bool OdbcInterval::GetInterval(Value &value, interval_t &interval, duckdb::OdbcHandleStmt *stmt) {
@@ -16,10 +19,11 @@ bool OdbcInterval::GetInterval(Value &value, interval_t &interval, duckdb::OdbcH
 		string error_message;
 		auto &val_str = StringValue::Get(value);
 		if (!TryCastErrorMessage::Operation<string_t, interval_t>(string_t(val_str), interval, &error_message)) {
-			if (error_message.empty()) {
-				error_message = CastExceptionText<string_t, interval_t>(string_t(val_str));
-			}
-			stmt->error_messages.emplace_back(error_message);
+			error_message = CastExceptionText<string_t, interval_t>(string_t(val_str));
+			auto data_source = stmt->dbc->GetDataSourceName();
+			duckdb::DiagRecord diag_rec(error_message, SQLStateType::INVALID_DATATIME_FORMAT, data_source);
+			stmt->odbc_diagnostic->FormatDiagnosticMessage(diag_rec, data_source, "OdbcInterval::GetInterval");
+			stmt->odbc_diagnostic->AddDiagRecord(diag_rec);
 			return false;
 		}
 		return true;
diff --git a/tools/odbc/statement_functions.cpp b/tools/odbc/statement_functions.cpp
index d84a781bc106..c16671088197 100644
--- a/tools/odbc/statement_functions.cpp
+++ b/tools/odbc/statement_functions.cpp
@@ -28,8 +28,10 @@ using duckdb::hugeint_t;
 using duckdb::interval_t;
 using duckdb::LogicalType;
 using duckdb::LogicalTypeId;
+using duckdb::OdbcDiagnostic;
 using duckdb::OdbcInterval;
 using duckdb::OdbcUtils;
+using duckdb::SQLStateType;
 using duckdb::Store;
 using duckdb::string_t;
 using duckdb::timestamp_t;
@@ -51,8 +53,9 @@ SQLRETURN duckdb::PrepareStmt(SQLHSTMT statement_handle, SQLCHAR *statement_text
 		auto query = duckdb::OdbcUtils::ReadString(statement_text, text_length);
 		stmt->stmt = stmt->dbc->conn->Prepare(query);
 		if (!stmt->stmt->success) {
-			stmt->error_messages.emplace_back(stmt->stmt->error);
-			return SQL_ERROR;
+			DiagRecord diag_rec(stmt->stmt->error, SQLStateType::SYNTAX_ERROR_OR_ACCESS_VIOLATION,
+			                    stmt->dbc->GetDataSourceName());
+			throw OdbcException("PrepareStmt", SQL_ERROR, diag_rec);
 		}
 		stmt->param_desc->ResetParams(stmt->stmt->n_param);
 
@@ -130,19 +133,22 @@ SQLRETURN duckdb::FetchStmtResult(SQLHSTMT statement_handle, SQLSMALLINT fetch_o
 
 //! Static fuctions used by GetDataStmtResult //
 
-static bool ValidateType(LogicalTypeId input, LogicalTypeId expected, duckdb::OdbcHandleStmt *stmt) {
+static void ValidateType(LogicalTypeId input, LogicalTypeId expected, duckdb::OdbcHandleStmt *stmt) {
 	if (input != expected) {
-		stmt->error_messages.emplace_back("Type mismatch error: received " + LogicalTypeIdToString(input) +
-		                                  ", but expected " + LogicalTypeIdToString(expected));
-		return false;
+		string msg = "Type mismatch error: received " + LogicalTypeIdToString(input) + ", but expected " +
+		             LogicalTypeIdToString(expected);
+		duckdb::DiagRecord diag_rec(msg, SQLStateType::RESTRICTED_DATA_TYPE, stmt->dbc->GetDataSourceName());
+		throw duckdb::OdbcException("ValidateType", SQL_ERROR, diag_rec);
 	}
-	return true;
 }
 
-static void LogInvalidCast(const LogicalType &from_type, const LogicalType &to_type, duckdb::OdbcHandleStmt *stmt) {
+static void ThrowInvalidCast(const string &component, const LogicalType &from_type, const LogicalType &to_type,
+                             duckdb::OdbcHandleStmt *stmt) {
 	string msg = "Not implemented Error: Unimplemented type for cast (" + from_type.ToString() + " -> " +
 	             to_type.ToString() + ")";
-	stmt->error_messages.emplace_back(msg);
+
+	duckdb::DiagRecord diag_rec(msg, SQLStateType::INVALID_DATATIME_FORMAT, stmt->dbc->GetDataSourceName());
+	throw duckdb::OdbcException(component, SQL_ERROR, diag_rec);
 }
 
 template <class SRC, class DEST = SRC>
@@ -158,9 +164,10 @@ static SQLRETURN GetInternalValue(duckdb::OdbcHandleStmt *stmt, const duckdb::Va
 			*str_len_or_ind_ptr = sizeof(casted_value);
 		}
 		return SQL_SUCCESS;
-	} catch (std::exception &ex) {
-		stmt->error_messages.emplace_back(ex.what());
-		return SQL_ERROR;
+	} catch (duckdb::Exception &ex) {
+		duckdb::DiagRecord diag_rec(std::string(ex.what()), SQLStateType::RESTRICTED_DATA_TYPE,
+		                            stmt->dbc->GetDataSourceName());
+		throw duckdb::OdbcException("GetInternalValue", SQL_ERROR, diag_rec);
 	}
 }
 
@@ -172,8 +179,9 @@ static bool CastTimestampValue(duckdb::OdbcHandleStmt *stmt, const duckdb::Value
 		target = CAST_OP::template Operation<timestamp_t, TARGET_TYPE>(timestamp);
 		return true;
 	} catch (duckdb::Exception &ex) {
-		stmt->error_messages.emplace_back(ex.what());
-		return false;
+		duckdb::DiagRecord diag_rec(std::string(ex.what()), SQLStateType::INVALID_DATATIME_FORMAT,
+		                            stmt->dbc->GetDataSourceName());
+		throw duckdb::OdbcException("CastTimestampValue", SQL_ERROR, diag_rec);
 	}
 }
 
@@ -316,9 +324,8 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 			                        str_len_or_ind_ptr);
 		}
 		case SQL_C_NUMERIC: {
-			if (!ValidateType(val.type().id(), LogicalTypeId::DECIMAL, stmt)) {
-				return SQL_ERROR;
-			}
+			ValidateType(val.type().id(), LogicalTypeId::DECIMAL, stmt);
+
 			SQL_NUMERIC_STRUCT *numeric = (SQL_NUMERIC_STRUCT *)target_value_ptr;
 			auto dataptr = (duckdb::data_ptr_t)numeric->val;
 			// reset numeric val to remove some garbage
@@ -410,14 +417,15 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 				string val_str = val.GetValue<string>();
 				auto str_input = string_t(val_str);
 				if (!TryCast::Operation<string_t, date_t>(str_input, date)) {
-					stmt->error_messages.emplace_back(CastExceptionText<string_t, date_t>(str_input));
-					return SQL_ERROR;
+					auto msg = CastExceptionText<string_t, date_t>(str_input);
+					duckdb::DiagRecord diag_rec(msg, SQLStateType::RESTRICTED_DATA_TYPE,
+					                            stmt->dbc->GetDataSourceName());
+					throw duckdb::OdbcException("GetDataStmtResult", SQL_ERROR, diag_rec);
 				}
 				break;
 			}
 			default:
-				LogInvalidCast(val.type(), LogicalType::DATE, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::DATE, stmt);
 			} // end switch "val.type().id()": SQL_C_TYPE_DATE
 
 			SQL_DATE_STRUCT *date_struct = (SQL_DATE_STRUCT *)target_value_ptr;
@@ -467,14 +475,15 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 				string val_str = val.GetValue<string>();
 				auto str_input = string_t(val_str);
 				if (!TryCast::Operation<string_t, dtime_t>(str_input, time)) {
-					stmt->error_messages.emplace_back(CastExceptionText<string_t, dtime_t>(str_input));
-					return SQL_ERROR;
+					auto msg = CastExceptionText<string_t, dtime_t>(str_input);
+					duckdb::DiagRecord diag_rec(msg, SQLStateType::RESTRICTED_DATA_TYPE,
+					                            stmt->dbc->GetDataSourceName());
+					throw duckdb::OdbcException("GetDataStmtResult", SQL_ERROR, diag_rec);
 				}
 				break;
 			}
 			default:
-				LogInvalidCast(val.type(), LogicalType::TIME, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::TIME, stmt);
 			} // end switch "val.type().id()": SQL_C_TYPE_TIME
 
 			SQL_TIME_STRUCT *time_struct = (SQL_TIME_STRUCT *)target_value_ptr;
@@ -507,8 +516,10 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 			case LogicalTypeId::DATE: {
 				auto date_input = val.GetValue<date_t>();
 				if (!TryCast::Operation<date_t, timestamp_t>(date_input, timestamp)) {
-					stmt->error_messages.emplace_back(CastExceptionText<date_t, timestamp_t>(date_input));
-					return SQL_ERROR;
+					auto msg = CastExceptionText<date_t, timestamp_t>(date_input);
+					duckdb::DiagRecord diag_rec(msg, SQLStateType::RESTRICTED_DATA_TYPE,
+					                            stmt->dbc->GetDataSourceName());
+					throw duckdb::OdbcException("GetDataStmtResult", SQL_ERROR, diag_rec);
 				}
 				break;
 			}
@@ -516,14 +527,15 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 				string val_str = val.GetValue<string>();
 				auto str_input = string_t(val_str);
 				if (!TryCast::Operation<string_t, timestamp_t>(str_input, timestamp)) {
-					stmt->error_messages.emplace_back(CastExceptionText<string_t, timestamp_t>(str_input));
-					return SQL_ERROR;
+					auto msg = CastExceptionText<string_t, timestamp_t>(str_input);
+					duckdb::DiagRecord diag_rec(msg, SQLStateType::RESTRICTED_DATA_TYPE,
+					                            stmt->dbc->GetDataSourceName());
+					throw duckdb::OdbcException("GetDataStmtResult", SQL_ERROR, diag_rec);
 				}
 				break;
 			}
 			default:
-				LogInvalidCast(val.type(), LogicalType::TIMESTAMP, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::TIMESTAMP, stmt);
 			} // end switch "val.type().id()"
 
 			SQL_TIMESTAMP_STRUCT *timestamp_struct = (SQL_TIMESTAMP_STRUCT *)target_value_ptr;
@@ -551,8 +563,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_YEAR: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -568,8 +579,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_MONTH: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -585,8 +595,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_DAY: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -602,8 +611,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_HOUR: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -619,8 +627,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_MINUTE: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -636,8 +643,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_SECOND: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -653,8 +659,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_YEAR_TO_MONTH: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -673,8 +678,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_DAY_TO_HOUR: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -690,8 +694,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_DAY_TO_MINUTE: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -707,8 +710,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_DAY_TO_SECOND: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -724,8 +726,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_HOUR_TO_MINUTE: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -741,8 +742,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_HOUR_TO_SECOND: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -758,8 +758,7 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		case SQL_C_INTERVAL_MINUTE_TO_SECOND: {
 			interval_t interval;
 			if (!OdbcInterval::GetInterval(val, interval, stmt)) {
-				LogInvalidCast(val.type(), LogicalType::INTERVAL, stmt);
-				return SQL_ERROR;
+				ThrowInvalidCast("GetDataStmtResult", val.type(), LogicalType::INTERVAL, stmt);
 			}
 
 			SQL_INTERVAL_STRUCT *interval_struct = (SQL_INTERVAL_STRUCT *)target_value_ptr;
@@ -774,9 +773,9 @@ SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_
 		}
 		// TODO other types
 		default:
-			stmt->error_messages.emplace_back("Unsupported type.");
-			return SQL_ERROR;
-
+			duckdb::DiagRecord diag_rec("Unsupported type", SQLStateType::RESTRICTED_DATA_TYPE,
+			                            stmt->dbc->GetDataSourceName());
+			throw duckdb::OdbcException("GetDataStmtResult", SQL_ERROR, diag_rec);
 		} // end switch "(target_type)": SQL_C_TYPE_TIMESTAMP
 	});
 }
diff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp
index c86b351f33b2..274ad051bb96 100644
--- a/tools/pythonpkg/src/pyconnection.cpp
+++ b/tools/pythonpkg/src/pyconnection.cpp
@@ -10,6 +10,7 @@
 #include "duckdb/main/client_context.hpp"
 #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
 #include "duckdb/common/types/vector.hpp"
+#include "duckdb/common/types.hpp"
 #include "duckdb/common/printer.hpp"
 #include "duckdb/main/config.hpp"
 #include "duckdb/parser/expression/constant_expression.hpp"
@@ -540,9 +541,7 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const string &databas
 	return res;
 }
 
-vector<Value> DuckDBPyConnection::TransformPythonParamList(py::handle params) {
-	vector<Value> args;
-
+Value TransformPythonValue(py::handle ele) {
 	auto datetime_mod = py::module::import("datetime");
 	auto datetime_date = datetime_mod.attr("date");
 	auto datetime_datetime = datetime_mod.attr("datetime");
@@ -550,50 +549,75 @@ vector<Value> DuckDBPyConnection::TransformPythonParamList(py::handle params) {
 	auto decimal_mod = py::module::import("decimal");
 	auto decimal_decimal = decimal_mod.attr("Decimal");
 
-	for (pybind11::handle ele : params) {
-		if (ele.is_none()) {
-			args.emplace_back();
-		} else if (py::isinstance<py::bool_>(ele)) {
-			args.push_back(Value::BOOLEAN(ele.cast<bool>()));
-		} else if (py::isinstance<py::int_>(ele)) {
-			args.push_back(Value::BIGINT(ele.cast<int64_t>()));
-		} else if (py::isinstance<py::float_>(ele)) {
-			args.push_back(Value::DOUBLE(ele.cast<double>()));
-		} else if (py::isinstance(ele, decimal_decimal)) {
-			args.emplace_back(py::str(ele).cast<string>());
-		} else if (py::isinstance(ele, datetime_datetime)) {
-			auto year = PyDateTime_GET_YEAR(ele.ptr());
-			auto month = PyDateTime_GET_MONTH(ele.ptr());
-			auto day = PyDateTime_GET_DAY(ele.ptr());
-			auto hour = PyDateTime_DATE_GET_HOUR(ele.ptr());
-			auto minute = PyDateTime_DATE_GET_MINUTE(ele.ptr());
-			auto second = PyDateTime_DATE_GET_SECOND(ele.ptr());
-			auto micros = PyDateTime_DATE_GET_MICROSECOND(ele.ptr());
-			args.push_back(Value::TIMESTAMP(year, month, day, hour, minute, second, micros));
-		} else if (py::isinstance(ele, datetime_time)) {
-			auto hour = PyDateTime_TIME_GET_HOUR(ele.ptr());
-			auto minute = PyDateTime_TIME_GET_MINUTE(ele.ptr());
-			auto second = PyDateTime_TIME_GET_SECOND(ele.ptr());
-			auto micros = PyDateTime_TIME_GET_MICROSECOND(ele.ptr());
-			args.push_back(Value::TIME(hour, minute, second, micros));
-		} else if (py::isinstance(ele, datetime_date)) {
-			auto year = PyDateTime_GET_YEAR(ele.ptr());
-			auto month = PyDateTime_GET_MONTH(ele.ptr());
-			auto day = PyDateTime_GET_DAY(ele.ptr());
-			args.push_back(Value::DATE(year, month, day));
-		} else if (py::isinstance<py::str>(ele)) {
-			args.emplace_back(ele.cast<string>());
-		} else if (py::isinstance<py::memoryview>(ele)) {
-			py::memoryview py_view = ele.cast<py::memoryview>();
-			PyObject *py_view_ptr = py_view.ptr();
-			Py_buffer *py_buf = PyMemoryView_GET_BUFFER(py_view_ptr);
-			args.emplace_back(Value::BLOB(const_data_ptr_t(py_buf->buf), idx_t(py_buf->len)));
-		} else if (py::isinstance<py::bytes>(ele)) {
-			const string &ele_string = ele.cast<string>();
-			args.emplace_back(Value::BLOB(const_data_ptr_t(ele_string.data()), ele_string.size()));
-		} else {
-			throw std::runtime_error("unknown param type " + py::str(ele.get_type()).cast<string>());
+	if (ele.is_none()) {
+		return Value();
+	} else if (py::isinstance<py::bool_>(ele)) {
+		return Value::BOOLEAN(ele.cast<bool>());
+	} else if (py::isinstance<py::int_>(ele)) {
+		return Value::BIGINT(ele.cast<int64_t>());
+	} else if (py::isinstance<py::float_>(ele)) {
+		return Value::DOUBLE(ele.cast<double>());
+	} else if (py::isinstance(ele, decimal_decimal)) {
+		return py::str(ele).cast<string>();
+	} else if (py::isinstance(ele, datetime_datetime)) {
+		auto ptr = ele.ptr();
+		auto year = PyDateTime_GET_YEAR(ptr);
+		auto month = PyDateTime_GET_MONTH(ptr);
+		auto day = PyDateTime_GET_DAY(ptr);
+		auto hour = PyDateTime_DATE_GET_HOUR(ptr);
+		auto minute = PyDateTime_DATE_GET_MINUTE(ptr);
+		auto second = PyDateTime_DATE_GET_SECOND(ptr);
+		auto micros = PyDateTime_DATE_GET_MICROSECOND(ptr);
+		return Value::TIMESTAMP(year, month, day, hour, minute, second, micros);
+	} else if (py::isinstance(ele, datetime_time)) {
+		auto ptr = ele.ptr();
+		auto hour = PyDateTime_TIME_GET_HOUR(ptr);
+		auto minute = PyDateTime_TIME_GET_MINUTE(ptr);
+		auto second = PyDateTime_TIME_GET_SECOND(ptr);
+		auto micros = PyDateTime_TIME_GET_MICROSECOND(ptr);
+		return Value::TIME(hour, minute, second, micros);
+	} else if (py::isinstance(ele, datetime_date)) {
+		auto ptr = ele.ptr();
+		auto year = PyDateTime_GET_YEAR(ptr);
+		auto month = PyDateTime_GET_MONTH(ptr);
+		auto day = PyDateTime_GET_DAY(ptr);
+		return Value::DATE(year, month, day);
+	} else if (py::isinstance<py::str>(ele)) {
+		return ele.cast<string>();
+	} else if (py::isinstance<py::memoryview>(ele)) {
+		py::memoryview py_view = ele.cast<py::memoryview>();
+		PyObject *py_view_ptr = py_view.ptr();
+		Py_buffer *py_buf = PyMemoryView_GET_BUFFER(py_view_ptr);
+		return Value::BLOB(const_data_ptr_t(py_buf->buf), idx_t(py_buf->len));
+	} else if (py::isinstance<py::bytes>(ele)) {
+		const string &ele_string = ele.cast<string>();
+		return Value::BLOB(const_data_ptr_t(ele_string.data()), ele_string.size());
+	} else if (py::isinstance<py::list>(ele)) {
+		auto size = py::len(ele);
+
+		if (size == 0) {
+			return Value::EMPTYLIST(LogicalType::SQLNULL);
 		}
+
+		vector<Value> values;
+		values.reserve(size);
+
+		for (auto py_val : ele) {
+			values.emplace_back(TransformPythonValue(py_val));
+		}
+
+		return Value::LIST(values);
+	} else {
+		throw std::runtime_error("unknown param type " + py::str(ele.get_type()).cast<string>());
+	}
+}
+
+vector<Value> DuckDBPyConnection::TransformPythonParamList(py::handle params) {
+	vector<Value> args;
+	args.reserve(py::len(params));
+
+	for (auto param : params) {
+		args.emplace_back(TransformPythonValue(param));
 	}
 	return args;
 }
diff --git a/tools/pythonpkg/src/pyrelation.cpp b/tools/pythonpkg/src/pyrelation.cpp
index f6ebecd65101..2afe4de63e7d 100644
--- a/tools/pythonpkg/src/pyrelation.cpp
+++ b/tools/pythonpkg/src/pyrelation.cpp
@@ -81,6 +81,8 @@ void DuckDBPyRelation::Initialize(py::handle &m) {
 	    .def("sem", &DuckDBPyRelation::SEM, "Returns the standard error of the mean of the aggregate column.",
 	         py::arg("aggregation_columns"), py::arg("group_columns") = "")
 	    .def("unique", &DuckDBPyRelation::Unique, "Number of distinct values in a column.", py::arg("unique_aggr"))
+	    .def("union", &DuckDBPyRelation::Union, py::arg("union_rel"),
+	         "Create the set union of this relation object with another relation object in other_rel")
 	    .def("cumsum", &DuckDBPyRelation::CumSum, "Returns the cumulative sum of the aggregate column.",
 	         py::arg("aggregation_columns"))
 	    .def("cumprod", &DuckDBPyRelation::CumProd, "Returns the cumulative product of the aggregate column.",
