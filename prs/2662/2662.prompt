You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
DISTINCT + ORDER produces incorrect result
```sql
CREATE TABLE T (t1 int, t2 int);
INSERT INTO t VALUES (1, 1), (1, 2);
SELECT DISTINCT t1
FROM T
ORDER BY t1, t2;

Returns:
┌────┐
│ t1 │
├────┤
│ 1  │
│ 1  │
└────┘
```

The query should fail to compile, e.g. Postgres:

```sql
ERROR:  for SELECT DISTINCT, ORDER BY expressions must appear in select list
LINE 3: ORDER BY t1, t2;
```


DISTINCT + ORDER produces incorrect result
```sql
CREATE TABLE T (t1 int, t2 int);
INSERT INTO t VALUES (1, 1), (1, 2);
SELECT DISTINCT t1
FROM T
ORDER BY t1, t2;

Returns:
┌────┐
│ t1 │
├────┤
│ 1  │
│ 1  │
└────┘
```

The query should fail to compile, e.g. Postgres:

```sql
ERROR:  for SELECT DISTINCT, ORDER BY expressions must appear in select list
LINE 3: ORDER BY t1, t2;
```



</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/planner/binder/query_node/bind_select_node.cpp]
1: #include "duckdb/common/limits.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/main/config.hpp"
5: #include "duckdb/parser/expression/columnref_expression.hpp"
6: #include "duckdb/parser/expression/comparison_expression.hpp"
7: #include "duckdb/parser/expression/constant_expression.hpp"
8: #include "duckdb/parser/expression/subquery_expression.hpp"
9: #include "duckdb/parser/query_node/select_node.hpp"
10: #include "duckdb/parser/tableref/joinref.hpp"
11: #include "duckdb/planner/binder.hpp"
12: #include "duckdb/planner/expression_binder/column_alias_binder.hpp"
13: #include "duckdb/planner/expression_binder/constant_binder.hpp"
14: #include "duckdb/planner/expression_binder/group_binder.hpp"
15: #include "duckdb/planner/expression_binder/having_binder.hpp"
16: #include "duckdb/planner/expression_binder/order_binder.hpp"
17: #include "duckdb/planner/expression_binder/select_binder.hpp"
18: #include "duckdb/planner/expression_binder/where_binder.hpp"
19: #include "duckdb/planner/query_node/bound_select_node.hpp"
20: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
21: 
22: namespace duckdb {
23: 
24: unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {
25: 	// we treat the Distinct list as a order by
26: 	auto bound_expr = order_binder.Bind(move(expr));
27: 	if (!bound_expr) {
28: 		// DISTINCT ON non-integer constant
29: 		// remove the expression from the DISTINCT ON list
30: 		return nullptr;
31: 	}
32: 	D_ASSERT(bound_expr->type == ExpressionType::BOUND_COLUMN_REF);
33: 	return bound_expr;
34: }
35: 
36: unique_ptr<Expression> Binder::BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,
37:                                              int64_t &delimiter_value) {
38: 	auto new_binder = Binder::CreateBinder(context, this, true);
39: 	ExpressionBinder expr_binder(*new_binder, context);
40: 	expr_binder.target_type = LogicalType::UBIGINT;
41: 	auto expr = expr_binder.Bind(delimiter);
42: 	if (expr->IsFoldable()) {
43: 		//! this is a constant
44: 		Value value = ExpressionExecutor::EvaluateScalar(*expr).CastAs(LogicalType::BIGINT);
45: 		delimiter_value = value.GetValue<int64_t>();
46: 		return nullptr;
47: 	}
48: 	return expr;
49: }
50: 
51: unique_ptr<BoundResultModifier> Binder::BindLimit(LimitModifier &limit_mod) {
52: 	auto result = make_unique<BoundLimitModifier>();
53: 	if (limit_mod.limit) {
54: 		result->limit = BindDelimiter(context, move(limit_mod.limit), result->limit_val);
55: 	}
56: 	if (limit_mod.offset) {
57: 		result->offset = BindDelimiter(context, move(limit_mod.offset), result->offset_val);
58: 	}
59: 	return move(result);
60: }
61: 
62: void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result) {
63: 	for (auto &mod : statement.modifiers) {
64: 		unique_ptr<BoundResultModifier> bound_modifier;
65: 		switch (mod->type) {
66: 		case ResultModifierType::DISTINCT_MODIFIER: {
67: 			auto &distinct = (DistinctModifier &)*mod;
68: 			auto bound_distinct = make_unique<BoundDistinctModifier>();
69: 			for (auto &distinct_on_target : distinct.distinct_on_targets) {
70: 				auto expr = BindOrderExpression(order_binder, move(distinct_on_target));
71: 				if (!expr) {
72: 					continue;
73: 				}
74: 				bound_distinct->target_distincts.push_back(move(expr));
75: 			}
76: 			bound_modifier = move(bound_distinct);
77: 			break;
78: 		}
79: 		case ResultModifierType::ORDER_MODIFIER: {
80: 			auto &order = (OrderModifier &)*mod;
81: 			auto bound_order = make_unique<BoundOrderModifier>();
82: 			auto &config = DBConfig::GetConfig(context);
83: 			for (auto &order_node : order.orders) {
84: 				auto order_expression = BindOrderExpression(order_binder, move(order_node.expression));
85: 				if (!order_expression) {
86: 					continue;
87: 				}
88: 				auto type = order_node.type == OrderType::ORDER_DEFAULT ? config.default_order_type : order_node.type;
89: 				auto null_order = order_node.null_order == OrderByNullType::ORDER_DEFAULT ? config.default_null_order
90: 				                                                                          : order_node.null_order;
91: 				bound_order->orders.emplace_back(type, null_order, move(order_expression));
92: 			}
93: 			if (!bound_order->orders.empty()) {
94: 				bound_modifier = move(bound_order);
95: 			}
96: 			break;
97: 		}
98: 		case ResultModifierType::LIMIT_MODIFIER:
99: 			bound_modifier = BindLimit((LimitModifier &)*mod);
100: 			break;
101: 		default:
102: 			throw Exception("Unsupported result modifier");
103: 		}
104: 		if (bound_modifier) {
105: 			result.modifiers.push_back(move(bound_modifier));
106: 		}
107: 	}
108: }
109: 
110: void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index) {
111: 	for (auto &bound_mod : result.modifiers) {
112: 		switch (bound_mod->type) {
113: 		case ResultModifierType::DISTINCT_MODIFIER: {
114: 			auto &distinct = (BoundDistinctModifier &)*bound_mod;
115: 			if (distinct.target_distincts.empty()) {
116: 				// DISTINCT without a target: push references to the standard select list
117: 				for (idx_t i = 0; i < sql_types.size(); i++) {
118: 					distinct.target_distincts.push_back(
119: 					    make_unique<BoundColumnRefExpression>(sql_types[i], ColumnBinding(projection_index, i)));
120: 				}
121: 			} else {
122: 				// DISTINCT with target list: set types
123: 				for (auto &expr : distinct.target_distincts) {
124: 					D_ASSERT(expr->type == ExpressionType::BOUND_COLUMN_REF);
125: 					auto &bound_colref = (BoundColumnRefExpression &)*expr;
126: 					if (bound_colref.binding.column_index == INVALID_INDEX) {
127: 						throw BinderException("Ambiguous name in DISTINCT ON!");
128: 					}
129: 					D_ASSERT(bound_colref.binding.column_index < sql_types.size());
130: 					bound_colref.return_type = sql_types[bound_colref.binding.column_index];
131: 				}
132: 			}
133: 			for (auto &target_distinct : distinct.target_distincts) {
134: 				auto &bound_colref = (BoundColumnRefExpression &)*target_distinct;
135: 				auto sql_type = sql_types[bound_colref.binding.column_index];
136: 				if (sql_type.id() == LogicalTypeId::VARCHAR) {
137: 					target_distinct = ExpressionBinder::PushCollation(context, move(target_distinct),
138: 					                                                  StringType::GetCollation(sql_type), true);
139: 				}
140: 			}
141: 			break;
142: 		}
143: 		case ResultModifierType::ORDER_MODIFIER: {
144: 			auto &order = (BoundOrderModifier &)*bound_mod;
145: 			for (auto &order_node : order.orders) {
146: 				auto &expr = order_node.expression;
147: 				D_ASSERT(expr->type == ExpressionType::BOUND_COLUMN_REF);
148: 				auto &bound_colref = (BoundColumnRefExpression &)*expr;
149: 				if (bound_colref.binding.column_index == INVALID_INDEX) {
150: 					throw BinderException("Ambiguous name in ORDER BY!");
151: 				}
152: 				D_ASSERT(bound_colref.binding.column_index < sql_types.size());
153: 				auto sql_type = sql_types[bound_colref.binding.column_index];
154: 				bound_colref.return_type = sql_types[bound_colref.binding.column_index];
155: 				if (sql_type.id() == LogicalTypeId::VARCHAR) {
156: 					order_node.expression = ExpressionBinder::PushCollation(context, move(order_node.expression),
157: 					                                                        StringType::GetCollation(sql_type));
158: 				}
159: 			}
160: 			break;
161: 		}
162: 		default:
163: 			break;
164: 		}
165: 	}
166: }
167: 
168: unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
169: 	auto result = make_unique<BoundSelectNode>();
170: 	result->projection_index = GenerateTableIndex();
171: 	result->group_index = GenerateTableIndex();
172: 	result->aggregate_index = GenerateTableIndex();
173: 	result->groupings_index = GenerateTableIndex();
174: 	result->window_index = GenerateTableIndex();
175: 	result->unnest_index = GenerateTableIndex();
176: 	result->prune_index = GenerateTableIndex();
177: 
178: 	// first bind the FROM table statement
179: 	result->from_table = Bind(*statement.from_table);
180: 
181: 	// bind the sample clause
182: 	if (statement.sample) {
183: 		result->sample_options = move(statement.sample);
184: 	}
185: 
186: 	// visit the select list and expand any "*" statements
187: 	vector<unique_ptr<ParsedExpression>> new_select_list;
188: 	for (auto &select_element : statement.select_list) {
189: 		if (select_element->GetExpressionType() == ExpressionType::STAR) {
190: 			// * statement, expand to all columns from the FROM clause
191: 			bind_context.GenerateAllColumnExpressions((StarExpression &)*select_element, new_select_list);
192: 		} else {
193: 			// regular statement, add it to the list
194: 			new_select_list.push_back(move(select_element));
195: 		}
196: 	}
197: 	if (new_select_list.empty()) {
198: 		throw BinderException("SELECT list is empty after resolving * expressions!");
199: 	}
200: 	statement.select_list = move(new_select_list);
201: 
202: 	// create a mapping of (alias -> index) and a mapping of (Expression -> index) for the SELECT list
203: 	unordered_map<string, idx_t> alias_map;
204: 	expression_map_t<idx_t> projection_map;
205: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
206: 		auto &expr = statement.select_list[i];
207: 		result->names.push_back(expr->GetName());
208: 		ExpressionBinder::QualifyColumnNames(*this, expr);
209: 		if (!expr->alias.empty()) {
210: 			alias_map[expr->alias] = i;
211: 			result->names[i] = expr->alias;
212: 		}
213: 		projection_map[expr.get()] = i;
214: 		result->original_expressions.push_back(expr->Copy());
215: 	}
216: 	result->column_count = statement.select_list.size();
217: 
218: 	// first visit the WHERE clause
219: 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
220: 	if (statement.where_clause) {
221: 		ColumnAliasBinder alias_binder(*result, alias_map);
222: 		WhereBinder where_binder(*this, context, &alias_binder);
223: 		unique_ptr<ParsedExpression> condition = move(statement.where_clause);
224: 		result->where_clause = where_binder.Bind(condition);
225: 	}
226: 
227: 	// now bind all the result modifiers; including DISTINCT and ORDER BY targets
228: 	OrderBinder order_binder({this}, result->projection_index, statement, alias_map, projection_map);
229: 	BindModifiers(order_binder, statement, *result);
230: 
231: 	vector<unique_ptr<ParsedExpression>> unbound_groups;
232: 	BoundGroupInformation info;
233: 	auto &group_expressions = statement.groups.group_expressions;
234: 	if (!group_expressions.empty()) {
235: 		// the statement has a GROUP BY clause, bind it
236: 		unbound_groups.resize(group_expressions.size());
237: 		GroupBinder group_binder(*this, context, statement, result->group_index, alias_map, info.alias_map);
238: 		for (idx_t i = 0; i < group_expressions.size(); i++) {
239: 
240: 			// we keep a copy of the unbound expression;
241: 			// we keep the unbound copy around to check for group references in the SELECT and HAVING clause
242: 			// the reason we want the unbound copy is because we want to figure out whether an expression
243: 			// is a group reference BEFORE binding in the SELECT/HAVING binder
244: 			group_binder.unbound_expression = group_expressions[i]->Copy();
245: 			group_binder.bind_index = i;
246: 
247: 			// bind the groups
248: 			LogicalType group_type;
249: 			auto bound_expr = group_binder.Bind(group_expressions[i], &group_type);
250: 			D_ASSERT(bound_expr->return_type.id() != LogicalTypeId::INVALID);
251: 
252: 			// push a potential collation, if necessary
253: 			bound_expr =
254: 			    ExpressionBinder::PushCollation(context, move(bound_expr), StringType::GetCollation(group_type), true);
255: 			result->groups.group_expressions.push_back(move(bound_expr));
256: 
257: 			// in the unbound expression we DO bind the table names of any ColumnRefs
258: 			// we do this to make sure that "table.a" and "a" are treated the same
259: 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
260: 			// hence we convert "a" -> "test.a" in the unbound expression
261: 			unbound_groups[i] = move(group_binder.unbound_expression);
262: 			ExpressionBinder::QualifyColumnNames(*this, unbound_groups[i]);
263: 			info.map[unbound_groups[i].get()] = i;
264: 		}
265: 	}
266: 	result->groups.grouping_sets = move(statement.groups.grouping_sets);
267: 
268: 	// bind the HAVING clause, if any
269: 	if (statement.having) {
270: 		HavingBinder having_binder(*this, context, *result, info, alias_map);
271: 		ExpressionBinder::QualifyColumnNames(*this, statement.having);
272: 		result->having = having_binder.Bind(statement.having);
273: 	}
274: 
275: 	// after that, we bind to the SELECT list
276: 	SelectBinder select_binder(*this, context, *result, info);
277: 	vector<LogicalType> internal_sql_types;
278: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
279: 		LogicalType result_type;
280: 		auto expr = select_binder.Bind(statement.select_list[i], &result_type);
281: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES && select_binder.HasBoundColumns()) {
282: 			if (select_binder.BoundAggregates()) {
283: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
284: 			}
285: 			// we are forcing aggregates, and the node has columns bound
286: 			// this entry becomes a group
287: 			auto group_ref = make_unique<BoundColumnRefExpression>(
288: 			    expr->return_type, ColumnBinding(result->group_index, result->groups.group_expressions.size()));
289: 			result->groups.group_expressions.push_back(move(expr));
290: 			expr = move(group_ref);
291: 		}
292: 		result->select_list.push_back(move(expr));
293: 		if (i < result->column_count) {
294: 			result->types.push_back(result_type);
295: 		}
296: 		internal_sql_types.push_back(result_type);
297: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
298: 			select_binder.ResetBindings();
299: 		}
300: 	}
301: 	result->need_prune = result->select_list.size() > result->column_count;
302: 
303: 	// in the normal select binder, we bind columns as if there is no aggregation
304: 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
305: 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
306: 	// we choose the former one [CONTROVERSIAL: this is the PostgreSQL behavior]
307: 	if (!result->groups.group_expressions.empty() || !result->aggregates.empty() || statement.having ||
308: 	    !result->groups.grouping_sets.empty()) {
309: 		if (statement.aggregate_handling == AggregateHandling::NO_AGGREGATES_ALLOWED) {
310: 			throw BinderException("Aggregates cannot be present in a Project relation!");
311: 		} else if (statement.aggregate_handling == AggregateHandling::STANDARD_HANDLING) {
312: 			if (select_binder.HasBoundColumns()) {
313: 				auto &bound_columns = select_binder.GetBoundColumns();
314: 				throw BinderException(
315: 				    FormatError(bound_columns[0].query_location,
316: 				                "column \"%s\" must appear in the GROUP BY clause or be used in an aggregate function",
317: 				                bound_columns[0].name));
318: 			}
319: 		}
320: 	}
321: 
322: 	// now that the SELECT list is bound, we set the types of DISTINCT/ORDER BY expressions
323: 	BindModifierTypes(*result, internal_sql_types, result->projection_index);
324: 	return move(result);
325: }
326: 
327: } // namespace duckdb
[end of src/planner/binder/query_node/bind_select_node.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: