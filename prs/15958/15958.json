{
  "repo": "duckdb/duckdb",
  "pull_number": 15958,
  "instance_id": "duckdb__duckdb-15958",
  "issue_numbers": [
    "15602"
  ],
  "base_commit": "837cbce93f4ac1778b26ca0bd23ed2a1d9b7eff7",
  "patch": "diff --git a/src/optimizer/filter_combiner.cpp b/src/optimizer/filter_combiner.cpp\nindex a72354d7df91..45d7c06a06f2 100644\n--- a/src/optimizer/filter_combiner.cpp\n+++ b/src/optimizer/filter_combiner.cpp\n@@ -78,6 +78,7 @@ FilterResult FilterCombiner::AddConstantComparison(vector<ExpressionValueInforma\n \t\t\treturn FilterResult::SUCCESS;\n \t\tcase ValueComparisonResult::UNSATISFIABLE_CONDITION:\n \t\t\t// combination of filters is unsatisfiable: prune the entire branch\n+\t\t\tinfo_list.push_back(info);\n \t\t\treturn FilterResult::UNSATISFIABLE;\n \t\tdefault:\n \t\t\t// prune nothing, move to the next condition\n@@ -792,11 +793,15 @@ FilterResult FilterCombiner::AddBoundComparisonFilter(Expression &expr) {\n \t\tauto transitive_filter = FindTransitiveFilter(non_scalar);\n \t\tif (transitive_filter != nullptr) {\n \t\t\t// try to add transitive filters\n-\t\t\tif (AddTransitiveFilters(transitive_filter->Cast<BoundComparisonExpression>()) ==\n-\t\t\t    FilterResult::UNSUPPORTED) {\n+\t\t\tauto transitive_result = AddTransitiveFilters(transitive_filter->Cast<BoundComparisonExpression>());\n+\t\t\tif (transitive_result == FilterResult::UNSUPPORTED) {\n \t\t\t\t// in case of unsuccessful re-add filter into remaining ones\n \t\t\t\tremaining_filters.push_back(std::move(transitive_filter));\n \t\t\t}\n+\t\t\tif (transitive_result == FilterResult::UNSATISFIABLE) {\n+\t\t\t\t// in case transitive filter is unsatisfiable - abort filter pushdown\n+\t\t\t\treturn FilterResult::UNSATISFIABLE;\n+\t\t\t}\n \t\t}\n \t\treturn ret;\n \t} else {\n@@ -1067,10 +1072,15 @@ FilterResult FilterCombiner::AddTransitiveFilters(BoundComparisonExpression &com\n \t\t\tif (transitive_filter != nullptr) {\n \t\t\t\t// try to add transitive filters\n \t\t\t\tauto &transitive_cast = transitive_filter->Cast<BoundComparisonExpression>();\n-\t\t\t\tif (AddTransitiveFilters(transitive_cast, false) == FilterResult::UNSUPPORTED) {\n+\t\t\t\tauto transitive_result = AddTransitiveFilters(transitive_cast, false);\n+\t\t\t\tif (transitive_result == FilterResult::UNSUPPORTED) {\n \t\t\t\t\t// in case of unsuccessful re-add filter into remaining ones\n \t\t\t\t\tremaining_filters.push_back(std::move(transitive_filter));\n \t\t\t\t}\n+\t\t\t\tif (transitive_result == FilterResult::UNSATISFIABLE) {\n+\t\t\t\t\t// while adding transitive filters we discovered the filter is unsatisfisable - we can prune\n+\t\t\t\t\treturn FilterResult::UNSATISFIABLE;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn FilterResult::SUCCESS;\n",
  "test_patch": "diff --git a/test/fuzzer/public/unsatisfiable_filter_prune.test b/test/fuzzer/public/unsatisfiable_filter_prune.test\nnew file mode 100644\nindex 000000000000..b1f3e1a67f3e\n--- /dev/null\n+++ b/test/fuzzer/public/unsatisfiable_filter_prune.test\n@@ -0,0 +1,20 @@\n+# name: test/fuzzer/public/unsatisfiable_filter_prune.test\n+# description: Test SEMI JOIN with USING clause\n+# group: [public]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE  t0(c0 INT, c1 INT);\n+\n+statement ok\n+INSERT INTO t0( c0, c1) VALUES ( -1, -1);\n+\n+query I\n+SELECT c0 FROM t0 WHERE (((CASE t0.c0 WHEN t0.c0 THEN t0.c0 END ) BETWEEN 1 AND t0.c0)AND(t0.c0 <= 0)) ;\n+----\n+\n+query II\n+SELECT * FROM t0 WHERE c0 >= 1 AND c0 <= t0.c1 AND t0.c1 <= 0;\n+----\n",
  "problem_statement": "Unexpected result when using `BETWEEN` and `CASE WHEN`\n### What happens?\n\nConsider the following test case. The second query returned `false`, showing that the expression `(((CASE t0.c0 WHEN t0.c0 THEN t0.c0 END ) BETWEEN 1 AND t0.c0)AND(t0.c0 <= 0))` should be evaluated to `false`; however, the third query return `-1`, which is unexpected.\n\n### To Reproduce\n\n```sql\r\nCREATE TABLE  t0(c0 INT);\r\nINSERT INTO t0( c0) VALUES ( -1);\r\n\r\nSELECT * FROM t0; -- -1\r\nSELECT (((CASE t0.c0 WHEN t0.c0 THEN t0.c0 END ) BETWEEN 1 AND t0.c0)AND(t0.c0 <= 0)) FROM t0; -- false\r\nSELECT * FROM t0 WHERE (((CASE t0.c0 WHEN t0.c0 THEN t0.c0 END ) BETWEEN 1 AND t0.c0)AND(t0.c0 <= 0)) ;\r\n-- Expected: empty table\r\n-- Actual: -1\r\n```\n\n### OS:\n\nUbuntu 22.04\n\n### DuckDB Version:\n\nv1.1.4-dev4108 acdbf60889\n\n### DuckDB Client:\n\nCLI\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nSuyang Zhong\n\n### Affiliation:\n\nNUS\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a source build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "Thanks! Indeed, Postgres returns an empty table:\r\n\r\n```\r\npostgres=# CREATE TABLE  t0(c0 INT);\r\nCREATE TABLE\r\npostgres=# INSERT INTO t0( c0) VALUES ( -1);\r\nINSERT 0 1\r\npostgres=#\r\npostgres=# SELECT * FROM t0; -- -1\r\n c0\r\n----\r\n -1\r\n(1 row)\r\n\r\npostgres=# SELECT (((CASE t0.c0 WHEN t0.c0 THEN t0.c0 END ) BETWEEN 1 AND t0.c0)AND(t0.c0 <= 0)) FROM t0; -- false\r\n ?column?\r\n----------\r\n f\r\n(1 row)\r\n\r\npostgres=# SELECT * FROM t0 WHERE (((CASE t0.c0 WHEN t0.c0 THEN t0.c0 END ) BETWEEN 1 AND t0.c0)AND(t0.c0 <= 0)) ;\r\n c0\r\n----\r\n(0 rows)\r\n```",
  "created_at": "2025-01-28T11:35:12Z"
}