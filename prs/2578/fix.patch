diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp
index 130f24db8d27..13e1a9e2581b 100644
--- a/src/catalog/catalog_entry/table_catalog_entry.cpp
+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp
@@ -140,8 +140,8 @@ unique_ptr<CatalogEntry> TableCatalogEntry::AlterEntry(ClientContext &context, A
 static void RenameExpression(ParsedExpression &expr, RenameColumnInfo &info) {
 	if (expr.type == ExpressionType::COLUMN_REF) {
 		auto &colref = (ColumnRefExpression &)expr;
-		if (colref.column_name == info.old_name) {
-			colref.column_name = info.new_name;
+		if (colref.column_names[0] == info.old_name) {
+			colref.column_names[0] = info.new_name;
 		}
 	}
 	ParsedExpressionIterator::EnumerateChildren(
diff --git a/src/execution/expression_executor.cpp b/src/execution/expression_executor.cpp
index 4d3b3630c186..ea83e1b1adf0 100644
--- a/src/execution/expression_executor.cpp
+++ b/src/execution/expression_executor.cpp
@@ -78,6 +78,7 @@ void ExpressionExecutor::ExecuteExpression(idx_t expr_idx, Vector &result) {
 
 Value ExpressionExecutor::EvaluateScalar(const Expression &expr) {
 	D_ASSERT(expr.IsFoldable());
+	D_ASSERT(expr.IsScalar());
 	// use an ExpressionExecutor to execute the expression
 	ExpressionExecutor executor(expr);
 
diff --git a/src/function/macro_function.cpp b/src/function/macro_function.cpp
index 194728ce44a3..ea44237bb84b 100644
--- a/src/function/macro_function.cpp
+++ b/src/function/macro_function.cpp
@@ -41,7 +41,7 @@ string MacroFunction::ValidateArguments(MacroCatalogEntry &macro_func, FunctionE
 		error = StringUtil::Format(
 		    "Macro function '%s(%s)' requires ", macro_func.name,
 		    StringUtil::Join(parameters, parameters.size(), ", ", [](const unique_ptr<ParsedExpression> &p) {
-			    return ((ColumnRefExpression &)*p).column_name;
+			    return ((ColumnRefExpression &)*p).column_names[0];
 		    }));
 		error += parameters.size() == 1 ? "a single positional argument"
 		                                : StringUtil::Format("%i positional arguments", parameters.size());
diff --git a/src/function/table/table_scan.cpp b/src/function/table/table_scan.cpp
index 75ae49f6994b..e1d02e792837 100644
--- a/src/function/table/table_scan.cpp
+++ b/src/function/table/table_scan.cpp
@@ -362,4 +362,12 @@ TableFunction TableScanFunction::GetFunction() {
 	return scan_function;
 }
 
+TableCatalogEntry *TableScanFunction::GetTableEntry(const TableFunction &function, const FunctionData *bind_data_p) {
+	if (function.function != TableScanFunc || !bind_data_p) {
+		return nullptr;
+	}
+	auto &bind_data = (TableScanBindData &)*bind_data_p;
+	return bind_data.table;
+}
+
 } // namespace duckdb
diff --git a/src/include/duckdb/function/table/table_scan.hpp b/src/include/duckdb/function/table/table_scan.hpp
index 5f13bdbaad1c..8fb4fff96515 100644
--- a/src/include/duckdb/function/table/table_scan.hpp
+++ b/src/include/duckdb/function/table/table_scan.hpp
@@ -33,6 +33,7 @@ struct TableScanBindData : public FunctionData {
 //! The table scan function represents a sequential scan over one of DuckDB's base tables.
 struct TableScanFunction {
 	static TableFunction GetFunction();
+	static TableCatalogEntry *GetTableEntry(const TableFunction &function, const FunctionData *bind_data);
 };
 
 } // namespace duckdb
diff --git a/src/include/duckdb/parser/expression/columnref_expression.hpp b/src/include/duckdb/parser/expression/columnref_expression.hpp
index c88d54f98d06..64914a14e966 100644
--- a/src/include/duckdb/parser/expression/columnref_expression.hpp
+++ b/src/include/duckdb/parser/expression/columnref_expression.hpp
@@ -9,6 +9,7 @@
 #pragma once
 
 #include "duckdb/parser/parsed_expression.hpp"
+#include "duckdb/common/vector.hpp"
 
 namespace duckdb {
 
@@ -20,13 +21,16 @@ class ColumnRefExpression : public ParsedExpression {
 	ColumnRefExpression(string column_name, string table_name);
 	//! Only specify the column name, the table name will be derived later
 	explicit ColumnRefExpression(string column_name);
+	//! Specify a set of names
+	explicit ColumnRefExpression(vector<string> column_names);
 
-	//! Column name that is referenced
-	string column_name;
-	//! Table name of the column name that is referenced (optional)
-	string table_name;
+	//! The stack of names in order of which they appear (column_names[0].column_names[1].column_names[2]....)
+	vector<string> column_names;
 
 public:
+	bool IsQualified() const;
+	const string &GetColumnName() const;
+	const string &GetTableName() const;
 	bool IsScalar() const override {
 		return false;
 	}
diff --git a/src/include/duckdb/parser/parsed_expression_iterator.hpp b/src/include/duckdb/parser/parsed_expression_iterator.hpp
index d15b918c5e08..288f9e361979 100644
--- a/src/include/duckdb/parser/parsed_expression_iterator.hpp
+++ b/src/include/duckdb/parser/parsed_expression_iterator.hpp
@@ -9,6 +9,7 @@
 #pragma once
 
 #include "duckdb/parser/parsed_expression.hpp"
+#include "duckdb/parser/tokens.hpp"
 
 #include <functional>
 
@@ -21,6 +22,11 @@ class ParsedExpressionIterator {
 	static void EnumerateChildren(ParsedExpression &expr, const std::function<void(ParsedExpression &child)> &callback);
 	static void EnumerateChildren(ParsedExpression &expr,
 	                              const std::function<void(unique_ptr<ParsedExpression> &child)> &callback);
+
+	static void EnumerateTableRefChildren(TableRef &ref,
+	                                      const std::function<void(unique_ptr<ParsedExpression> &child)> &callback);
+	static void EnumerateQueryNodeChildren(QueryNode &node,
+	                                       const std::function<void(unique_ptr<ParsedExpression> &child)> &callback);
 };
 
 } // namespace duckdb
diff --git a/src/include/duckdb/planner/bind_context.hpp b/src/include/duckdb/planner/bind_context.hpp
index 57b451c47491..231ef10c8182 100644
--- a/src/include/duckdb/planner/bind_context.hpp
+++ b/src/include/duckdb/planner/bind_context.hpp
@@ -58,6 +58,10 @@ class BindContext {
 	string BindColumn(PositionalReferenceExpression &ref, string &table_name, string &column_name);
 	BindResult BindColumn(PositionalReferenceExpression &ref, idx_t depth);
 
+	unique_ptr<ParsedExpression> CreateColumnReference(const string &table_name, const string &column_name);
+	unique_ptr<ParsedExpression> CreateColumnReference(const string &schema_name, const string &table_name,
+	                                                   const string &column_name);
+
 	//! Generate column expressions for all columns that are present in the
 	//! referenced tables. This is used to resolve the * expression in a
 	//! selection list.
@@ -126,12 +130,13 @@ class BindContext {
 	//! Add all the bindings from a BindContext to this BindContext. The other BindContext is destroyed in the process.
 	void AddContext(BindContext other);
 
-private:
-	void AddBinding(const string &alias, unique_ptr<Binding> binding);
 	//! Gets a binding of the specified name. Returns a nullptr and sets the out_error if the binding could not be
 	//! found.
 	Binding *GetBinding(const string &name, string &out_error);
 
+private:
+	void AddBinding(const string &alias, unique_ptr<Binding> binding);
+
 private:
 	//! The set of bindings
 	case_insensitive_map_t<unique_ptr<Binding>> bindings;
diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp
index 4c9dc9f63457..0e69fb54b57e 100644
--- a/src/include/duckdb/planner/binder.hpp
+++ b/src/include/duckdb/planner/binder.hpp
@@ -143,6 +143,10 @@ class Binder : public std::enable_shared_from_this<Binder> {
 
 	static void BindLogicalType(ClientContext &context, LogicalType &type, const string &schema = "");
 
+	bool HasMatchingBinding(const string &table_name, const string &column_name, string &error_message);
+	bool HasMatchingBinding(const string &schema_name, const string &table_name, const string &column_name,
+	                        string &error_message);
+
 private:
 	//! The parent binder (if any)
 	shared_ptr<Binder> parent;
diff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp
index 465325acd982..c4ffcf4d7de6 100644
--- a/src/include/duckdb/planner/expression_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder.hpp
@@ -35,6 +35,8 @@ struct BoundColumnReferenceInfo {
 };
 
 struct BindResult {
+	BindResult() {
+	}
 	explicit BindResult(string error) : error(error) {
 	}
 	explicit BindResult(unique_ptr<Expression> expr) : expression(move(expr)) {
@@ -71,9 +73,16 @@ class ExpressionBinder {
 
 	string Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression = false);
 
+	unique_ptr<ParsedExpression> CreateStructExtract(unique_ptr<ParsedExpression> base, string field_name);
+	BindResult BindQualifiedColumnName(ColumnRefExpression &colref, const string &table_name);
+
+	unique_ptr<ParsedExpression> QualifyColumnName(const string &column_name, string &error_message);
+	unique_ptr<ParsedExpression> QualifyColumnName(ColumnRefExpression &colref, string &error_message);
+
 	// Bind table names to ColumnRefExpressions
-	static void BindTableNames(Binder &binder, ParsedExpression &expr,
-	                           unordered_map<string, idx_t> *alias_map = nullptr);
+	void QualifyColumnNames(unique_ptr<ParsedExpression> &expr);
+	static void QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr);
+
 	static unique_ptr<Expression> PushCollation(ClientContext &context, unique_ptr<Expression> source,
 	                                            const string &collation, bool equality_only = false);
 	static void TestCollation(ClientContext &context, const string &collation);
@@ -121,9 +130,7 @@ class ExpressionBinder {
 	virtual BindResult BindMacro(FunctionExpression &expr, MacroCatalogEntry *macro, idx_t depth,
 	                             unique_ptr<ParsedExpression> *expr_ptr);
 
-	virtual void ReplaceMacroParametersRecursive(unique_ptr<ParsedExpression> &expr);
-	virtual void ReplaceMacroParametersRecursive(ParsedExpression &expr, QueryNode &node);
-	virtual void ReplaceMacroParametersRecursive(ParsedExpression &expr, TableRef &ref);
+	void ReplaceMacroParametersRecursive(unique_ptr<ParsedExpression> &expr);
 
 	virtual string UnsupportedAggregateMessage();
 	virtual string UnsupportedUnnestMessage();
diff --git a/src/include/duckdb/planner/operator/logical_get.hpp b/src/include/duckdb/planner/operator/logical_get.hpp
index 192f6fe2877d..1d7fc4e7aefa 100644
--- a/src/include/duckdb/planner/operator/logical_get.hpp
+++ b/src/include/duckdb/planner/operator/logical_get.hpp
@@ -37,6 +37,8 @@ class LogicalGet : public LogicalOperator {
 
 	string GetName() const override;
 	string ParamsToString() const override;
+	//! Returns the underlying table that is being scanned, or nullptr if there is none
+	TableCatalogEntry *GetTable() const;
 
 public:
 	vector<ColumnBinding> GetColumnBindings() override;
diff --git a/src/include/duckdb/planner/table_binding.hpp b/src/include/duckdb/planner/table_binding.hpp
index 9add00792cd1..1c7e3f7f09c8 100644
--- a/src/include/duckdb/planner/table_binding.hpp
+++ b/src/include/duckdb/planner/table_binding.hpp
@@ -41,8 +41,11 @@ struct Binding {
 
 public:
 	bool TryGetBindingIndex(const string &column_name, column_t &column_index);
+	column_t GetBindingIndex(const string &column_name);
 	bool HasMatchingBinding(const string &column_name);
+	virtual string ColumnNotFoundError(const string &column_name) const;
 	virtual BindResult Bind(ColumnRefExpression &colref, idx_t depth);
+	virtual TableCatalogEntry *GetTableEntry();
 };
 
 //! TableBinding is exactly like the Binding, except it keeps track of which columns were bound in the linked LogicalGet
@@ -56,11 +59,16 @@ struct TableBinding : public Binding {
 
 public:
 	BindResult Bind(ColumnRefExpression &colref, idx_t depth) override;
+	TableCatalogEntry *GetTableEntry() override;
+	string ColumnNotFoundError(const string &column_name) const override;
 };
 
 //! MacroBinding is like the Binding, except the alias and index are set by default. Used for binding Macro
 //! Params/Arguments.
 struct MacroBinding : public Binding {
+	static constexpr const char *MACRO_NAME = "0_macro_parameters";
+
+public:
 	MacroBinding(vector<LogicalType> types_p, vector<string> names_p, string macro_name);
 
 	//! Arguments
diff --git a/src/main/relation.cpp b/src/main/relation.cpp
index 9b459b1d9734..8a335b8d72c5 100644
--- a/src/main/relation.cpp
+++ b/src/main/relation.cpp
@@ -121,10 +121,10 @@ shared_ptr<Relation> Relation::Join(const shared_ptr<Relation> &other, const str
 				throw ParserException("Expected a single expression as join condition");
 			}
 			auto &colref = (ColumnRefExpression &)*expr;
-			if (!colref.table_name.empty()) {
-				throw ParserException("Expected empty table name for column in USING clause");
+			if (colref.IsQualified()) {
+				throw ParserException("Expected unqualified column for column in USING clause");
 			}
-			using_columns.push_back(colref.column_name);
+			using_columns.push_back(colref.column_names[0]);
 		}
 		return make_shared<JoinRelation>(shared_from_this(), other, move(using_columns), type);
 	} else {
diff --git a/src/optimizer/statistics/operator/propagate_projection.cpp b/src/optimizer/statistics/operator/propagate_projection.cpp
index 47801f2dc487..10f998f2fc70 100644
--- a/src/optimizer/statistics/operator/propagate_projection.cpp
+++ b/src/optimizer/statistics/operator/propagate_projection.cpp
@@ -7,6 +7,10 @@ unique_ptr<NodeStatistics> StatisticsPropagator::PropagateStatistics(LogicalProj
                                                                      unique_ptr<LogicalOperator> *node_ptr) {
 	// first propagate to the child
 	node_stats = PropagateStatistics(proj.children[0]);
+	if (proj.children[0]->type == LogicalOperatorType::LOGICAL_EMPTY_RESULT) {
+		ReplaceWithEmptyResult(*node_ptr);
+		return move(node_stats);
+	}
 
 	// then propagate to each of the expressions
 	for (idx_t i = 0; i < proj.expressions.size(); i++) {
diff --git a/src/parser/expression/columnref_expression.cpp b/src/parser/expression/columnref_expression.cpp
index 42d187e50913..897c28e8838c 100644
--- a/src/parser/expression/columnref_expression.cpp
+++ b/src/parser/expression/columnref_expression.cpp
@@ -6,53 +6,85 @@
 
 namespace duckdb {
 
-//! Specify both the column and table name
 ColumnRefExpression::ColumnRefExpression(string column_name, string table_name)
-    : ParsedExpression(ExpressionType::COLUMN_REF, ExpressionClass::COLUMN_REF), column_name(move(column_name)),
-      table_name(move(table_name)) {
+    : ColumnRefExpression(table_name.empty() ? vector<string> {move(column_name)}
+                                             : vector<string> {move(table_name), move(column_name)}) {
 }
 
-ColumnRefExpression::ColumnRefExpression(string column_name) : ColumnRefExpression(move(column_name), string()) {
+ColumnRefExpression::ColumnRefExpression(string column_name) : ColumnRefExpression(vector<string> {move(column_name)}) {
+}
+
+ColumnRefExpression::ColumnRefExpression(vector<string> column_names_p)
+    : ParsedExpression(ExpressionType::COLUMN_REF, ExpressionClass::COLUMN_REF), column_names(move(column_names_p)) {
+#ifdef DEBUG
+	for (auto &col_name : column_names) {
+		D_ASSERT(!col_name.empty());
+	}
+#endif
+}
+
+bool ColumnRefExpression::IsQualified() const {
+	return column_names.size() > 1;
+}
+
+const string &ColumnRefExpression::GetColumnName() const {
+	D_ASSERT(column_names.size() <= 3);
+	return column_names.back();
+}
+
+const string &ColumnRefExpression::GetTableName() const {
+	D_ASSERT(column_names.size() >= 2 && column_names.size() <= 3);
+	return column_names.size() == 3 ? column_names[1] : column_names[0];
 }
 
 string ColumnRefExpression::GetName() const {
-	return !alias.empty() ? alias : column_name;
+	return !alias.empty() ? alias : column_names.back();
 }
 
 string ColumnRefExpression::ToString() const {
-	if (table_name.empty()) {
-		return column_name;
-	} else {
-		return table_name + "." + column_name;
+	string result;
+	for (idx_t i = 0; i < column_names.size(); i++) {
+		if (i > 0) {
+			result += ".";
+		}
+		result += column_names[i];
 	}
+	return result;
 }
 
 bool ColumnRefExpression::Equals(const ColumnRefExpression *a, const ColumnRefExpression *b) {
-	return a->column_name == b->column_name && a->table_name == b->table_name;
+	return a->column_names == b->column_names;
 }
 
 hash_t ColumnRefExpression::Hash() const {
 	hash_t result = ParsedExpression::Hash();
-	result = CombineHash(result, duckdb::Hash<const char *>(column_name.c_str()));
+	for (auto &column_name : column_names) {
+		result = CombineHash(result, duckdb::Hash<const char *>(column_name.c_str()));
+	}
 	return result;
 }
 
 unique_ptr<ParsedExpression> ColumnRefExpression::Copy() const {
-	auto copy = make_unique<ColumnRefExpression>(column_name, table_name);
+	auto copy = make_unique<ColumnRefExpression>(column_names);
 	copy->CopyProperties(*this);
 	return move(copy);
 }
 
 void ColumnRefExpression::Serialize(Serializer &serializer) {
 	ParsedExpression::Serialize(serializer);
-	serializer.WriteString(table_name);
-	serializer.WriteString(column_name);
+	serializer.Write<idx_t>(column_names.size());
+	for (auto &column_name : column_names) {
+		serializer.WriteString(column_name);
+	}
 }
 
 unique_ptr<ParsedExpression> ColumnRefExpression::Deserialize(ExpressionType type, Deserializer &source) {
-	auto table_name = source.Read<string>();
-	auto column_name = source.Read<string>();
-	auto expression = make_unique<ColumnRefExpression>(column_name, table_name);
+	auto column_count = source.Read<idx_t>();
+	vector<string> column_names;
+	for (idx_t i = 0; i < column_count; i++) {
+		column_names.push_back(source.Read<string>());
+	}
+	auto expression = make_unique<ColumnRefExpression>(move(column_names));
 	return move(expression);
 }
 
diff --git a/src/parser/parsed_expression_iterator.cpp b/src/parser/parsed_expression_iterator.cpp
index ebff20ccfdf9..69c79ac041e1 100644
--- a/src/parser/parsed_expression_iterator.cpp
+++ b/src/parser/parsed_expression_iterator.cpp
@@ -1,6 +1,11 @@
 #include "duckdb/parser/parsed_expression_iterator.hpp"
 
 #include "duckdb/parser/expression/list.hpp"
+#include "duckdb/parser/query_node.hpp"
+#include "duckdb/parser/query_node/recursive_cte_node.hpp"
+#include "duckdb/parser/query_node/select_node.hpp"
+#include "duckdb/parser/query_node/set_operation_node.hpp"
+#include "duckdb/parser/tableref/list.hpp"
 
 namespace duckdb {
 
@@ -137,4 +142,89 @@ void ParsedExpressionIterator::EnumerateChildren(
 	}
 }
 
+void ParsedExpressionIterator::EnumerateTableRefChildren(
+    TableRef &ref, const std::function<void(unique_ptr<ParsedExpression> &child)> &callback) {
+	switch (ref.type) {
+	case TableReferenceType::CROSS_PRODUCT: {
+		auto &cp_ref = (CrossProductRef &)ref;
+		EnumerateTableRefChildren(*cp_ref.left, callback);
+		EnumerateTableRefChildren(*cp_ref.right, callback);
+		break;
+	}
+	case TableReferenceType::EXPRESSION_LIST: {
+		auto &el_ref = (ExpressionListRef &)ref;
+		for (idx_t i = 0; i < el_ref.values.size(); i++) {
+			for (idx_t j = 0; j < el_ref.values[i].size(); j++) {
+				callback(el_ref.values[i][j]);
+			}
+		}
+		break;
+	}
+	case TableReferenceType::JOIN: {
+		auto &j_ref = (JoinRef &)ref;
+		EnumerateTableRefChildren(*j_ref.left, callback);
+		EnumerateTableRefChildren(*j_ref.right, callback);
+		callback(j_ref.condition);
+		break;
+	}
+	case TableReferenceType::SUBQUERY: {
+		auto &sq_ref = (SubqueryRef &)ref;
+		EnumerateQueryNodeChildren(*sq_ref.subquery->node, callback);
+		break;
+	}
+	case TableReferenceType::TABLE_FUNCTION: {
+		auto &tf_ref = (TableFunctionRef &)ref;
+		callback(tf_ref.function);
+		break;
+	}
+	case TableReferenceType::BASE_TABLE:
+	case TableReferenceType::EMPTY:
+		// these TableRefs do not need to be unfolded
+		break;
+	default:
+		throw NotImplementedException("TableRef type not implemented for traversal");
+	}
+}
+
+void ParsedExpressionIterator::EnumerateQueryNodeChildren(
+    QueryNode &node, const std::function<void(unique_ptr<ParsedExpression> &child)> &callback) {
+	switch (node.type) {
+	case QueryNodeType::RECURSIVE_CTE_NODE: {
+		auto &rcte_node = (RecursiveCTENode &)node;
+		EnumerateQueryNodeChildren(*rcte_node.left, callback);
+		EnumerateQueryNodeChildren(*rcte_node.right, callback);
+		break;
+	}
+	case QueryNodeType::SELECT_NODE: {
+		auto &sel_node = (SelectNode &)node;
+		for (idx_t i = 0; i < sel_node.select_list.size(); i++) {
+			callback(sel_node.select_list[i]);
+		}
+		for (idx_t i = 0; i < sel_node.groups.group_expressions.size(); i++) {
+			callback(sel_node.groups.group_expressions[i]);
+		}
+		if (sel_node.where_clause) {
+			callback(sel_node.where_clause);
+		}
+		if (sel_node.having) {
+			callback(sel_node.having);
+		}
+
+		EnumerateTableRefChildren(*sel_node.from_table.get(), callback);
+		break;
+	}
+	case QueryNodeType::SET_OPERATION_NODE: {
+		auto &setop_node = (SetOperationNode &)node;
+		EnumerateQueryNodeChildren(*setop_node.left, callback);
+		EnumerateQueryNodeChildren(*setop_node.right, callback);
+		break;
+	}
+	default:
+		throw NotImplementedException("QueryNode type not implemented for traversal");
+	}
+	for (auto &kv : node.cte_map) {
+		EnumerateQueryNodeChildren(*kv.second->query->node, callback);
+	}
+}
+
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_columnref.cpp b/src/parser/transform/expression/transform_columnref.cpp
index 0b42cc54c561..032b74be2fa0 100644
--- a/src/parser/transform/expression/transform_columnref.cpp
+++ b/src/parser/transform/expression/transform_columnref.cpp
@@ -47,28 +47,13 @@ unique_ptr<ParsedExpression> Transformer::TransformColumnRef(duckdb_libpgquery::
 		if (fields->length < 1) {
 			throw InternalException("Unexpected field length");
 		}
-		string column_name, table_name;
-		if (fields->length == 1) {
-			column_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(fields->head->data.ptr_value)->val.str);
-			auto colref = make_unique<ColumnRefExpression>(column_name, table_name);
-			colref->query_location = root->location;
-			return move(colref);
-		} else if (fields->length == 2) {
-			table_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(fields->head->data.ptr_value)->val.str);
-			auto col_node = reinterpret_cast<duckdb_libpgquery::PGNode *>(fields->head->next->data.ptr_value);
-			switch (col_node->type) {
-			case duckdb_libpgquery::T_PGString: {
-				column_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(col_node)->val.str);
-				auto colref = make_unique<ColumnRefExpression>(column_name, table_name);
-				colref->query_location = root->location;
-				return move(colref);
-			}
-			default:
-				throw NotImplementedException("ColumnRef not implemented!");
-			}
-		} else {
-			throw NotImplementedException("ColumnRef not implemented!");
+		vector<string> column_names;
+		for (auto node = fields->head; node; node = node->next) {
+			column_names.emplace_back(reinterpret_cast<duckdb_libpgquery::PGValue *>(node->data.ptr_value)->val.str);
 		}
+		auto colref = make_unique<ColumnRefExpression>(move(column_names));
+		colref->query_location = root->location;
+		return move(colref);
 	}
 	case duckdb_libpgquery::T_PGAStar: {
 		return TransformStarExpression(head_node);
diff --git a/src/parser/transform/expression/transform_lambda.cpp b/src/parser/transform/expression/transform_lambda.cpp
index 3d4b36439cef..6d39bd076ce4 100644
--- a/src/parser/transform/expression/transform_lambda.cpp
+++ b/src/parser/transform/expression/transform_lambda.cpp
@@ -10,10 +10,10 @@ static string ExtractColumnFromLambda(ParsedExpression &expr) {
 		throw ParserException("Lambda parameter must be a column name");
 	}
 	auto &colref = (ColumnRefExpression &)expr;
-	if (!colref.table_name.empty()) {
+	if (colref.IsQualified()) {
 		throw ParserException("Lambda parameter must be an unqualified name (e.g. 'x', not 'a.x')");
 	}
-	return colref.column_name;
+	return colref.column_names[0];
 }
 
 unique_ptr<ParsedExpression> Transformer::TransformLambda(duckdb_libpgquery::PGLambdaFunction *node) {
diff --git a/src/planner/bind_context.cpp b/src/planner/bind_context.cpp
index 2d5458211566..9af1bd5a78ad 100644
--- a/src/planner/bind_context.cpp
+++ b/src/planner/bind_context.cpp
@@ -158,6 +158,34 @@ unordered_set<string> BindContext::GetMatchingBindings(const string &column_name
 	return result;
 }
 
+unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const string &table_name, const string &column_name) {
+	string schema_name;
+	return CreateColumnReference(schema_name, table_name, column_name);
+}
+
+unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const string &schema_name, const string &table_name,
+                                                                const string &column_name) {
+	string error_message;
+	vector<string> names;
+	if (!schema_name.empty()) {
+		names.push_back(schema_name);
+	}
+	names.push_back(table_name);
+	names.push_back(column_name);
+
+	auto result = make_unique<ColumnRefExpression>(move(names));
+	// because of case insensitivity in the binder we rename the column to the original name
+	// as it appears in the binding itself
+	auto binding = GetBinding(table_name, error_message);
+	if (binding) {
+		auto column_index = binding->GetBindingIndex(column_name);
+		if (column_index < binding->names.size() && binding->names[column_index] != column_name) {
+			result->alias = binding->names[column_index];
+		}
+	}
+	return move(result);
+}
+
 Binding *BindContext::GetCTEBinding(const string &ctename) {
 	auto match = cte_bindings.find(ctename);
 	if (match == cte_bindings.end()) {
@@ -183,12 +211,12 @@ Binding *BindContext::GetBinding(const string &name, string &out_error) {
 }
 
 BindResult BindContext::BindColumn(ColumnRefExpression &colref, idx_t depth) {
-	if (colref.table_name.empty()) {
-		return BindResult(StringUtil::Format("Could not bind alias \"%s\"!", colref.column_name));
+	if (!colref.IsQualified()) {
+		throw InternalException("Could not bind alias \"%s\"!", colref.GetColumnName());
 	}
 
 	string error;
-	auto binding = GetBinding(colref.table_name, error);
+	auto binding = GetBinding(colref.GetTableName(), error);
 	if (!binding) {
 		return BindResult(error);
 	}
diff --git a/src/planner/binder.cpp b/src/planner/binder.cpp
index 49e51a0b8fca..e66d2a23a9b7 100644
--- a/src/planner/binder.cpp
+++ b/src/planner/binder.cpp
@@ -6,6 +6,8 @@
 #include "duckdb/planner/bound_tableref.hpp"
 #include "duckdb/planner/expression.hpp"
 #include "duckdb/planner/operator/logical_sample.hpp"
+#include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
+#include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
 
 #include <algorithm>
 
@@ -286,6 +288,38 @@ void Binder::AddCorrelatedColumn(const CorrelatedColumnInfo &info) {
 	}
 }
 
+bool Binder::HasMatchingBinding(const string &table_name, const string &column_name, string &error_message) {
+	string empty_schema;
+	return HasMatchingBinding(empty_schema, table_name, column_name, error_message);
+}
+
+bool Binder::HasMatchingBinding(const string &schema_name, const string &table_name, const string &column_name,
+                                string &error_message) {
+	Binding *binding;
+	if (macro_binding && table_name == macro_binding->alias) {
+		binding = macro_binding;
+	} else {
+		binding = bind_context.GetBinding(table_name, error_message);
+	}
+	if (!binding) {
+		return false;
+	}
+	if (!schema_name.empty()) {
+		auto table_entry = binding->GetTableEntry();
+		if (!table_entry) {
+			return false;
+		}
+		if (table_entry->schema->name != schema_name || table_entry->name != table_name) {
+			return false;
+		}
+	}
+	if (!binding->HasMatchingBinding(column_name)) {
+		error_message = binding->ColumnNotFoundError(column_name);
+		return false;
+	}
+	return true;
+}
+
 string Binder::FormatError(ParsedExpression &expr_context, const string &message) {
 	return FormatError(expr_context.query_location, message);
 }
diff --git a/src/planner/binder/expression/bind_columnref_expression.cpp b/src/planner/binder/expression/bind_columnref_expression.cpp
index 20e74e07064c..618863ff346f 100644
--- a/src/planner/binder/expression/bind_columnref_expression.cpp
+++ b/src/planner/binder/expression/bind_columnref_expression.cpp
@@ -4,58 +4,204 @@
 #include "duckdb/planner/expression_binder.hpp"
 #include "duckdb/parser/expression/operator_expression.hpp"
 #include "duckdb/common/string_util.hpp"
+#include "duckdb/parser/parsed_expression_iterator.hpp"
+#include "duckdb/parser/expression/positional_reference_expression.hpp"
+#include "duckdb/planner/binder.hpp"
+#include "duckdb/planner/expression_binder/where_binder.hpp"
+#include "duckdb/function/scalar/nested_functions.hpp"
+#include "duckdb/parser/expression/constant_expression.hpp"
+#include "duckdb/parser/expression/function_expression.hpp"
+#include "duckdb/parser/expression/subquery_expression.hpp"
 
 namespace duckdb {
 
-BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref, idx_t depth) {
-	D_ASSERT(!colref.column_name.empty());
-	// individual column reference
-	// resolve to either a base table or a subquery expression
-	if (colref.table_name.empty()) {
-		auto using_binding = binder.bind_context.GetUsingBinding(colref.column_name);
-		if (using_binding) {
-			// we are referencing a USING column
-			// check if we can refer to one of the base columns directly
-			unique_ptr<Expression> expression;
-			if (!using_binding->primary_binding.empty()) {
-				// we can! just assign the table name and re-bind
-				colref.table_name = using_binding->primary_binding;
-				return BindExpression(colref, depth);
-			} else {
-				// we cannot! we need to bind this as a coalesce between all the relevant columns
-				auto coalesce = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
-				for (auto &entry : using_binding->bindings) {
-					coalesce->children.push_back(make_unique<ColumnRefExpression>(colref.column_name, entry));
-				}
-				return BindExpression(*coalesce, depth);
+unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(const string &column_name, string &error_message) {
+	auto using_binding = binder.bind_context.GetUsingBinding(column_name);
+	if (using_binding) {
+		// we are referencing a USING column
+		// check if we can refer to one of the base columns directly
+		unique_ptr<Expression> expression;
+		if (!using_binding->primary_binding.empty()) {
+			// we can! just assign the table name and re-bind
+			return make_unique<ColumnRefExpression>(column_name, using_binding->primary_binding);
+		} else {
+			// // we cannot! we need to bind this as a coalesce between all the relevant columns
+			auto coalesce = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
+			for (auto &entry : using_binding->bindings) {
+				coalesce->children.push_back(make_unique<ColumnRefExpression>(column_name, entry));
 			}
+			return move(coalesce);
 		}
-		// no table name: find a binding that contains this
-		if (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {
-			// priority to macro parameter bindings TODO: throw a warning when this name conflicts
-			colref.table_name = binder.macro_binding->alias;
+	}
+	// no table name: find a binding that contains this
+	if (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(column_name)) {
+		// priority to macro parameter bindings TODO: throw a warning when this name conflicts
+		D_ASSERT(!binder.macro_binding->alias.empty());
+		return make_unique<ColumnRefExpression>(column_name, binder.macro_binding->alias);
+	} else {
+		string table_name = binder.bind_context.GetMatchingBinding(column_name);
+		if (table_name.empty()) {
+			auto similar_bindings = binder.bind_context.GetSimilarBindings(column_name);
+			string candidate_str = StringUtil::CandidatesMessage(similar_bindings, "Candidate bindings");
+			error_message =
+			    StringUtil::Format("Referenced column \"%s\" not found in FROM clause!%s", column_name, candidate_str);
+			return nullptr;
+		}
+		return binder.bind_context.CreateColumnReference(table_name, column_name);
+	}
+}
+
+void ExpressionBinder::QualifyColumnNames(unique_ptr<ParsedExpression> &expr) {
+	switch (expr->type) {
+	case ExpressionType::COLUMN_REF: {
+		auto &colref = (ColumnRefExpression &)*expr;
+		string error_message;
+		auto new_expr = QualifyColumnName(colref, error_message);
+		if (new_expr) {
+			if (!expr->alias.empty()) {
+				new_expr->alias = expr->alias;
+			}
+			expr = move(new_expr);
+		}
+		break;
+	}
+	case ExpressionType::POSITIONAL_REFERENCE: {
+		auto &ref = (PositionalReferenceExpression &)*expr;
+		if (ref.alias.empty()) {
+			string table_name, column_name;
+			auto error = binder.bind_context.BindColumn(ref, table_name, column_name);
+			if (error.empty()) {
+				ref.alias = column_name;
+			}
+		}
+		break;
+	}
+	default:
+		break;
+	}
+	ParsedExpressionIterator::EnumerateChildren(
+	    *expr, [&](unique_ptr<ParsedExpression> &child) { QualifyColumnNames(child); });
+}
+
+void ExpressionBinder::QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr) {
+	WhereBinder where_binder(binder, binder.context);
+	where_binder.QualifyColumnNames(expr);
+}
+
+unique_ptr<ParsedExpression> ExpressionBinder::CreateStructExtract(unique_ptr<ParsedExpression> base,
+                                                                   string field_name) {
+	vector<unique_ptr<ParsedExpression>> children;
+	children.push_back(move(base));
+	children.push_back(make_unique_base<ParsedExpression, ConstantExpression>(Value(move(field_name))));
+	auto extract_fun = make_unique<FunctionExpression>("struct_extract", move(children));
+	return move(extract_fun);
+}
+
+unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(ColumnRefExpression &colref, string &error_message) {
+	idx_t column_parts = colref.column_names.size();
+	// column names can have an arbitrary amount of dots
+	// here is how the resolution works:
+	if (column_parts == 1) {
+		// no dots (i.e. "part1")
+		// -> part1 refers to a column
+		// check if we can qualify the column name with the table name
+		return QualifyColumnName(colref.GetColumnName(), error_message);
+	} else if (column_parts == 2) {
+		// one dot (i.e. "part1.part2")
+		// EITHER:
+		// -> part1 is a table, part2 is a column
+		// -> part1 is a column, part2 is a property of that column (i.e. struct_extract)
+
+		// first check if part1 is a table
+		if (binder.HasMatchingBinding(colref.column_names[0], colref.column_names[1], error_message)) {
+			// it is! return the colref directly
+			return binder.bind_context.CreateColumnReference(colref.column_names[0], colref.column_names[1]);
 		} else {
-			colref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);
+			// otherwise check if we can turn this into a struct extract
+			auto new_colref = make_unique<ColumnRefExpression>(colref.column_names[0]);
+			string other_error;
+			auto qualified_colref = QualifyColumnName(colref.column_names[0], other_error);
+			if (!qualified_colref) {
+				// we could not! bail
+				return nullptr;
+			}
+			// we could: create a struct extract
+			return CreateStructExtract(move(qualified_colref), colref.column_names[1]);
 		}
-		if (colref.table_name.empty()) {
-			auto similar_bindings = binder.bind_context.GetSimilarBindings(colref.column_name);
-			string candidate_str = StringUtil::CandidatesMessage(similar_bindings, "Candidate bindings");
-			return BindResult(binder.FormatError(colref.query_location,
-			                                     "Referenced column \"%s\" not found in FROM clause!%s",
-			                                     colref.column_name.c_str(), candidate_str));
+	} else {
+		// two or more dots (i.e. "part1.part2.part3.part4...")
+		// -> part1 is a schema, part2 is a table, part3 is a column name, part4 and beyond are struct fields
+		// -> part1 is a table, part2 is a column name, part3 and beyond are struct fields
+		// -> part1 is a column, part2 and beyond are struct fields
+
+		// we always prefer the most top-level view
+		// i.e. in case of multiple resolution options, we resolve in order:
+		// -> 1. resolve "part1" as a schema
+		// -> 2. resolve "part1" as a table
+		// -> 3. resolve "part1" as a column
+
+		unique_ptr<ParsedExpression> result_expr;
+		idx_t struct_extract_start;
+		// first check if part1 is a schema
+		if (binder.HasMatchingBinding(colref.column_names[0], colref.column_names[1], colref.column_names[2],
+		                              error_message)) {
+			// it is! the column reference is "schema.table.column"
+			// any additional fields are turned into struct_extract calls
+			result_expr = binder.bind_context.CreateColumnReference(colref.column_names[0], colref.column_names[1],
+			                                                        colref.column_names[2]);
+			struct_extract_start = 3;
+		} else if (binder.HasMatchingBinding(colref.column_names[0], colref.column_names[1], error_message)) {
+			// part1 is a table
+			// the column reference is "table.column"
+			// any additional fields are turned into struct_extract calls
+			result_expr = binder.bind_context.CreateColumnReference(colref.column_names[0], colref.column_names[1]);
+			struct_extract_start = 2;
+		} else {
+			// part1 could be a column
+			string col_error;
+			result_expr = QualifyColumnName(colref.column_names[0], col_error);
+			if (!result_expr) {
+				// it is not! return the error
+				return nullptr;
+			}
+			// it is! add the struct extract calls
+			struct_extract_start = 1;
+		}
+		for (idx_t i = struct_extract_start; i < colref.column_names.size(); i++) {
+			result_expr = CreateStructExtract(move(result_expr), colref.column_names[i]);
 		}
+		return result_expr;
+	}
+}
+
+BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref_p, idx_t depth) {
+	string error_message;
+	auto expr = QualifyColumnName(colref_p, error_message);
+	if (!expr) {
+		return BindResult(binder.FormatError(colref_p, error_message));
 	}
+	if (expr->type != ExpressionType::COLUMN_REF) {
+		return BindExpression(&expr, depth);
+	}
+	auto &colref = (ColumnRefExpression &)*expr;
+	D_ASSERT(colref.column_names.size() == 2 || colref.column_names.size() == 3);
+	auto &table_name = colref.column_names.size() == 3 ? colref.column_names[1] : colref.column_names[0];
+	// individual column reference
+	// resolve to either a base table or a subquery expression
 	// if it was a macro parameter, let macro_binding bind it to the argument
-	BindResult result = binder.macro_binding != nullptr && colref.table_name == binder.macro_binding->alias
-	                        ? binder.macro_binding->Bind(colref, depth)
-	                        : binder.bind_context.BindColumn(colref, depth);
+	BindResult result;
+	if (binder.macro_binding && table_name == binder.macro_binding->alias) {
+		result = binder.macro_binding->Bind(colref, depth);
+	} else {
+		result = binder.bind_context.BindColumn(colref, depth);
+	}
 	if (!result.HasError()) {
 		BoundColumnReferenceInfo ref;
-		ref.name = colref.column_name;
+		ref.name = colref.column_names.back();
 		ref.query_location = colref.query_location;
 		bound_columns.push_back(move(ref));
 	} else {
-		result.error = binder.FormatError(colref, result.error);
+		result.error = binder.FormatError(colref_p, result.error);
 	}
 	return result;
 }
diff --git a/src/planner/binder/expression/bind_macro_expression.cpp b/src/planner/binder/expression/bind_macro_expression.cpp
index 1451a08172ba..ac4c09ce4e05 100644
--- a/src/planner/binder/expression/bind_macro_expression.cpp
+++ b/src/planner/binder/expression/bind_macro_expression.cpp
@@ -2,11 +2,6 @@
 #include "duckdb/parser/expression/function_expression.hpp"
 #include "duckdb/parser/expression/subquery_expression.hpp"
 #include "duckdb/parser/parsed_expression_iterator.hpp"
-#include "duckdb/parser/query_node.hpp"
-#include "duckdb/parser/query_node/recursive_cte_node.hpp"
-#include "duckdb/parser/query_node/select_node.hpp"
-#include "duckdb/parser/query_node/set_operation_node.hpp"
-#include "duckdb/parser/tableref/list.hpp"
 #include "duckdb/planner/expression_binder.hpp"
 #include "duckdb/common/string_util.hpp"
 
@@ -17,7 +12,14 @@ void ExpressionBinder::ReplaceMacroParametersRecursive(unique_ptr<ParsedExpressi
 	case ExpressionClass::COLUMN_REF: {
 		// if expr is a parameter, replace it with its argument
 		auto &colref = (ColumnRefExpression &)*expr;
-		if (colref.table_name.empty() && macro_binding->HasMatchingBinding(colref.column_name)) {
+		bool bind_macro_parameter = false;
+		if (colref.IsQualified()) {
+			bind_macro_parameter = colref.GetTableName() == MacroBinding::MACRO_NAME;
+		} else {
+			bind_macro_parameter = macro_binding->HasMatchingBinding(colref.GetColumnName());
+		}
+		if (bind_macro_parameter) {
+			D_ASSERT(macro_binding->HasMatchingBinding(colref.GetColumnName()));
 			expr = macro_binding->ParamToArg(colref);
 		}
 		return;
@@ -25,7 +27,8 @@ void ExpressionBinder::ReplaceMacroParametersRecursive(unique_ptr<ParsedExpressi
 	case ExpressionClass::SUBQUERY: {
 		// replacing parameters within a subquery is slightly different
 		auto &sq = ((SubqueryExpression &)*expr).subquery;
-		ReplaceMacroParametersRecursive(*expr, *sq->node);
+		ParsedExpressionIterator::EnumerateQueryNodeChildren(
+		    *sq->node, [&](unique_ptr<ParsedExpression> &child) { ReplaceMacroParametersRecursive(child); });
 		break;
 	}
 	default: // fall through
@@ -36,89 +39,6 @@ void ExpressionBinder::ReplaceMacroParametersRecursive(unique_ptr<ParsedExpressi
 	    *expr, [&](unique_ptr<ParsedExpression> &child) { ReplaceMacroParametersRecursive(child); });
 }
 
-void ExpressionBinder::ReplaceMacroParametersRecursive(ParsedExpression &expr, TableRef &ref) {
-	switch (ref.type) {
-	case TableReferenceType::CROSS_PRODUCT: {
-		auto &cp_ref = (CrossProductRef &)ref;
-		ReplaceMacroParametersRecursive(expr, *cp_ref.left);
-		ReplaceMacroParametersRecursive(expr, *cp_ref.right);
-		break;
-	}
-	case TableReferenceType::EXPRESSION_LIST: {
-		auto &el_ref = (ExpressionListRef &)ref;
-		for (idx_t i = 0; i < el_ref.values.size(); i++) {
-			for (idx_t j = 0; j < el_ref.values[i].size(); j++) {
-				ReplaceMacroParametersRecursive(el_ref.values[i][j]);
-			}
-		}
-		break;
-	}
-	case TableReferenceType::JOIN: {
-		auto &j_ref = (JoinRef &)ref;
-		ReplaceMacroParametersRecursive(expr, *j_ref.left);
-		ReplaceMacroParametersRecursive(expr, *j_ref.right);
-		ReplaceMacroParametersRecursive(j_ref.condition);
-		break;
-	}
-	case TableReferenceType::SUBQUERY: {
-		auto &sq_ref = (SubqueryRef &)ref;
-		ReplaceMacroParametersRecursive(expr, *sq_ref.subquery->node);
-		break;
-	}
-	case TableReferenceType::TABLE_FUNCTION: {
-		auto &tf_ref = (TableFunctionRef &)ref;
-		ReplaceMacroParametersRecursive(tf_ref.function);
-		break;
-	}
-	case TableReferenceType::BASE_TABLE:
-	case TableReferenceType::EMPTY:
-		// these TableRefs do not need to be unfolded
-		break;
-	default:
-		throw NotImplementedException("TableRef type not implemented for macro's!");
-	}
-}
-
-void ExpressionBinder::ReplaceMacroParametersRecursive(ParsedExpression &expr, QueryNode &node) {
-	switch (node.type) {
-	case QueryNodeType::RECURSIVE_CTE_NODE: {
-		auto &rcte_node = (RecursiveCTENode &)node;
-		ReplaceMacroParametersRecursive(expr, *rcte_node.left);
-		ReplaceMacroParametersRecursive(expr, *rcte_node.right);
-		break;
-	}
-	case QueryNodeType::SELECT_NODE: {
-		auto &sel_node = (SelectNode &)node;
-		for (idx_t i = 0; i < sel_node.select_list.size(); i++) {
-			ReplaceMacroParametersRecursive(sel_node.select_list[i]);
-		}
-		for (idx_t i = 0; i < sel_node.groups.group_expressions.size(); i++) {
-			ReplaceMacroParametersRecursive(sel_node.groups.group_expressions[i]);
-		}
-		if (sel_node.where_clause != nullptr) {
-			ReplaceMacroParametersRecursive(sel_node.where_clause);
-		}
-		if (sel_node.having != nullptr) {
-			ReplaceMacroParametersRecursive(sel_node.having);
-		}
-
-		ReplaceMacroParametersRecursive(expr, *sel_node.from_table.get());
-		break;
-	}
-	case QueryNodeType::SET_OPERATION_NODE: {
-		auto &setop_node = (SetOperationNode &)node;
-		ReplaceMacroParametersRecursive(expr, *setop_node.left);
-		ReplaceMacroParametersRecursive(expr, *setop_node.right);
-		break;
-	}
-	default:
-		throw NotImplementedException("QueryNode type not implemented for macro's!");
-	}
-	for (auto &kv : node.cte_map) {
-		ReplaceMacroParametersRecursive(expr, *kv.second->query->node);
-	}
-}
-
 BindResult ExpressionBinder::BindMacro(FunctionExpression &function, MacroCatalogEntry *macro_func, idx_t depth,
                                        unique_ptr<ParsedExpression> *expr) {
 	auto &macro_def = *macro_func->function;
@@ -137,7 +57,7 @@ BindResult ExpressionBinder::BindMacro(FunctionExpression &function, MacroCatalo
 	for (idx_t i = 0; i < macro_def.parameters.size(); i++) {
 		types.push_back(LogicalType::SQLNULL);
 		auto &param = (ColumnRefExpression &)*macro_def.parameters[i];
-		names.push_back(param.column_name);
+		names.push_back(param.GetColumnName());
 	}
 	// default parameters
 	for (auto it = macro_def.default_parameters.begin(); it != macro_def.default_parameters.end(); it++) {
diff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp
index 8710a34632f0..2ac13c132d89 100644
--- a/src/planner/binder/query_node/bind_select_node.cpp
+++ b/src/planner/binder/query_node/bind_select_node.cpp
@@ -205,7 +205,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
 		auto &expr = statement.select_list[i];
 		result->names.push_back(expr->GetName());
-		ExpressionBinder::BindTableNames(*this, *expr);
+		ExpressionBinder::QualifyColumnNames(*this, expr);
 		if (!expr->alias.empty()) {
 			alias_map[expr->alias] = i;
 			result->names[i] = expr->alias;
@@ -259,7 +259,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
 			// hence we convert "a" -> "test.a" in the unbound expression
 			unbound_groups[i] = move(group_binder.unbound_expression);
-			ExpressionBinder::BindTableNames(*this, *unbound_groups[i]);
+			ExpressionBinder::QualifyColumnNames(*this, unbound_groups[i]);
 			info.map[unbound_groups[i].get()] = i;
 		}
 	}
@@ -268,7 +268,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
 	// bind the HAVING clause, if any
 	if (statement.having) {
 		HavingBinder having_binder(*this, context, *result, info, alias_map);
-		ExpressionBinder::BindTableNames(*this, *statement.having, &alias_map);
+		ExpressionBinder::QualifyColumnNames(*this, statement.having);
 		result->having = having_binder.Bind(statement.having);
 	}
 
diff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp
index b71f7124a69d..c8e0fee5a1f3 100644
--- a/src/planner/binder/statement/bind_create.cpp
+++ b/src/planner/binder/statement/bind_create.cpp
@@ -82,11 +82,11 @@ SchemaCatalogEntry *Binder::BindCreateFunctionInfo(CreateInfo &info) {
 	// positional parameters
 	for (idx_t i = 0; i < base.function->parameters.size(); i++) {
 		auto param = (ColumnRefExpression &)*base.function->parameters[i];
-		if (!param.table_name.empty()) {
-			throw BinderException("Invalid parameter name '%s'", param.ToString());
+		if (param.IsQualified()) {
+			throw BinderException("Invalid parameter name '%s': must be unqualified", param.ToString());
 		}
 		dummy_types.push_back(LogicalType::SQLNULL);
-		dummy_names.push_back(param.column_name);
+		dummy_names.push_back(param.GetColumnName());
 	}
 	// default parameters
 	for (auto it = base.function->default_parameters.begin(); it != base.function->default_parameters.end(); it++) {
@@ -96,6 +96,7 @@ SchemaCatalogEntry *Binder::BindCreateFunctionInfo(CreateInfo &info) {
 	}
 	auto this_macro_binding = make_unique<MacroBinding>(dummy_types, dummy_names, base.name);
 	macro_binding = this_macro_binding.get();
+	ExpressionBinder::QualifyColumnNames(*this, base.function->expression);
 
 	// create a copy of the expression because we do not want to alter the original
 	auto expression = base.function->expression->Copy();
diff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp
index 9bd899c40332..b7e347f3ba8b 100644
--- a/src/planner/binder/tableref/bind_table_function.cpp
+++ b/src/planner/binder/tableref/bind_table_function.cpp
@@ -29,8 +29,8 @@ bool Binder::BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expres
 			auto &comp = (ComparisonExpression &)*child;
 			if (comp.left->type == ExpressionType::COLUMN_REF) {
 				auto &colref = (ColumnRefExpression &)*comp.left;
-				if (colref.table_name.empty()) {
-					parameter_name = colref.column_name;
+				if (!colref.IsQualified()) {
+					parameter_name = colref.GetColumnName();
 					child = move(comp.right);
 				}
 			}
diff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp
index 250f92231979..383bb491b11b 100644
--- a/src/planner/expression_binder.cpp
+++ b/src/planner/expression_binder.cpp
@@ -80,7 +80,7 @@ bool ExpressionBinder::BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr)
 	bool success = false;
 	while (!active_binders.empty()) {
 		auto &next_binder = active_binders.back();
-		ExpressionBinder::BindTableNames(next_binder->binder, *expr);
+		ExpressionBinder::QualifyColumnNames(next_binder->binder, expr);
 		auto bind_result = next_binder->Bind(&expr, depth);
 		if (bind_result.empty()) {
 			success = true;
@@ -241,31 +241,4 @@ string ExpressionBinder::Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, b
 	}
 }
 
-void ExpressionBinder::BindTableNames(Binder &binder, ParsedExpression &expr, unordered_map<string, idx_t> *alias_map) {
-	if (expr.type == ExpressionType::COLUMN_REF) {
-		auto &colref = (ColumnRefExpression &)expr;
-		if (colref.table_name.empty()) {
-			// no table name: find a binding that contains this
-			if (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {
-				// macro parameters get priority
-				colref.table_name = binder.macro_binding->alias;
-			} else {
-				colref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);
-			}
-		}
-		binder.bind_context.BindColumn(colref, 0);
-	} else if (expr.type == ExpressionType::POSITIONAL_REFERENCE) {
-		auto &ref = (PositionalReferenceExpression &)expr;
-		if (ref.alias.empty()) {
-			string table_name, column_name;
-			auto error = binder.bind_context.BindColumn(ref, table_name, column_name);
-			if (error.empty()) {
-				ref.alias = column_name;
-			}
-		}
-	}
-	ParsedExpressionIterator::EnumerateChildren(
-	    expr, [&](const ParsedExpression &child) { BindTableNames(binder, (ParsedExpression &)child, alias_map); });
-}
-
 } // namespace duckdb
diff --git a/src/planner/expression_binder/alter_binder.cpp b/src/planner/expression_binder/alter_binder.cpp
index d8a288a37cd0..d4c320c782f4 100644
--- a/src/planner/expression_binder/alter_binder.cpp
+++ b/src/planner/expression_binder/alter_binder.cpp
@@ -31,13 +31,13 @@ string AlterBinder::UnsupportedAggregateMessage() {
 }
 
 BindResult AlterBinder::BindColumn(ColumnRefExpression &colref) {
-	if (!colref.table_name.empty() && colref.table_name != table.name) {
-		throw BinderException("Cannot reference table %s from within alter statement for table %s!", colref.table_name,
-		                      table.name);
+	if (colref.column_names.size() > 1) {
+		return BindQualifiedColumnName(colref, table.name);
 	}
-	auto idx = table.GetColumnIndex(colref.column_name, true);
+	auto idx = table.GetColumnIndex(colref.column_names[0], true);
 	if (idx == INVALID_INDEX) {
-		throw BinderException("Table does not contain column %s referenced in alter statement!", colref.column_name);
+		throw BinderException("Table does not contain column %s referenced in alter statement!",
+		                      colref.column_names[0]);
 	}
 	bound_columns.push_back(idx);
 	return BindResult(make_unique<BoundReferenceExpression>(table.columns[idx].type, bound_columns.size() - 1));
diff --git a/src/planner/expression_binder/check_binder.cpp b/src/planner/expression_binder/check_binder.cpp
index 8341a56ccd3d..111f8223e1d6 100644
--- a/src/planner/expression_binder/check_binder.cpp
+++ b/src/planner/expression_binder/check_binder.cpp
@@ -5,9 +5,9 @@
 
 namespace duckdb {
 
-CheckBinder::CheckBinder(Binder &binder, ClientContext &context, string table, vector<ColumnDefinition> &columns,
+CheckBinder::CheckBinder(Binder &binder, ClientContext &context, string table_p, vector<ColumnDefinition> &columns,
                          unordered_set<column_t> &bound_columns)
-    : ExpressionBinder(binder, context), table(move(table)), columns(columns), bound_columns(bound_columns) {
+    : ExpressionBinder(binder, context), table(move(table_p)), columns(columns), bound_columns(bound_columns) {
 	target_type = LogicalType::INTEGER;
 }
 
@@ -29,18 +29,29 @@ string CheckBinder::UnsupportedAggregateMessage() {
 	return "aggregate functions are not allowed in check constraints";
 }
 
+BindResult ExpressionBinder::BindQualifiedColumnName(ColumnRefExpression &colref, const string &table_name) {
+	idx_t struct_start = 0;
+	if (colref.column_names[0] == table_name) {
+		struct_start++;
+	}
+	auto result = make_unique_base<ParsedExpression, ColumnRefExpression>(colref.column_names.back());
+	for (idx_t i = struct_start; i + 1 < colref.column_names.size(); i++) {
+		result = CreateStructExtract(move(result), colref.column_names[i]);
+	}
+	return BindExpression(&result, 0);
+}
+
 BindResult CheckBinder::BindCheckColumn(ColumnRefExpression &colref) {
-	if (!colref.table_name.empty() && colref.table_name != table) {
-		throw BinderException("Cannot reference table %s from within check constraint for table %s!", colref.table_name,
-		                      table);
+	if (colref.column_names.size() > 1) {
+		return BindQualifiedColumnName(colref, table);
 	}
 	for (idx_t i = 0; i < columns.size(); i++) {
-		if (colref.column_name == columns[i].name) {
+		if (colref.column_names[0] == columns[i].name) {
 			bound_columns.insert(i);
 			return BindResult(make_unique<BoundReferenceExpression>(columns[i].type, i));
 		}
 	}
-	throw BinderException("Table does not contain column %s referenced in check constraint!", colref.column_name);
+	throw BinderException("Table does not contain column %s referenced in check constraint!", colref.column_names[0]);
 }
 
 } // namespace duckdb
diff --git a/src/planner/expression_binder/column_alias_binder.cpp b/src/planner/expression_binder/column_alias_binder.cpp
index c7da48757e08..31b9c3572f87 100644
--- a/src/planner/expression_binder/column_alias_binder.cpp
+++ b/src/planner/expression_binder/column_alias_binder.cpp
@@ -12,11 +12,11 @@ ColumnAliasBinder::ColumnAliasBinder(BoundSelectNode &node, const unordered_map<
 
 BindResult ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,
                                         bool root_expression) {
-	if (!expr.table_name.empty()) {
+	if (expr.IsQualified()) {
 		return BindResult(StringUtil::Format("Alias %s cannot be qualified.", expr.ToString()));
 	}
 
-	auto alias_entry = alias_map.find(expr.column_name);
+	auto alias_entry = alias_map.find(expr.column_names[0]);
 	if (alias_entry == alias_map.end()) {
 		return BindResult(StringUtil::Format("Alias %s is not found.", expr.ToString()));
 	}
diff --git a/src/planner/expression_binder/group_binder.cpp b/src/planner/expression_binder/group_binder.cpp
index 5e33f1ef07d1..bc0c65049e9c 100644
--- a/src/planner/expression_binder/group_binder.cpp
+++ b/src/planner/expression_binder/group_binder.cpp
@@ -85,13 +85,13 @@ BindResult GroupBinder::BindColumnRef(ColumnRefExpression &colref) {
 	// first try to bind to the base columns (original tables)
 	auto result = ExpressionBinder::BindExpression(colref, 0);
 	if (result.HasError()) {
-		// failed to bind the column and the node is the root expression with depth = 0
-		// check if refers to an alias in the select clause
-		auto alias_name = colref.column_name;
-		if (!colref.table_name.empty()) {
+		if (colref.IsQualified()) {
 			// explicit table name: not an alias reference
 			return result;
 		}
+		// failed to bind the column and the node is the root expression with depth = 0
+		// check if refers to an alias in the select clause
+		auto alias_name = colref.column_names[0];
 		auto entry = alias_map.find(alias_name);
 		if (entry == alias_map.end()) {
 			// no matching alias found
diff --git a/src/planner/expression_binder/order_binder.cpp b/src/planner/expression_binder/order_binder.cpp
index 7e8b3e7f2c76..f0b069c2c759 100644
--- a/src/planner/expression_binder/order_binder.cpp
+++ b/src/planner/expression_binder/order_binder.cpp
@@ -55,11 +55,11 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {
 		// check if we can bind it to an alias in the select list
 		auto &colref = (ColumnRefExpression &)*expr;
 		// if there is an explicit table name we can't bind to an alias
-		if (!colref.table_name.empty()) {
+		if (colref.IsQualified()) {
 			break;
 		}
 		// check the alias list
-		auto entry = alias_map.find(colref.column_name);
+		auto entry = alias_map.find(colref.column_names[0]);
 		if (entry != alias_map.end()) {
 			// it does! point it to that entry
 			return CreateProjectionReference(*expr, entry->second);
@@ -76,7 +76,7 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {
 	// general case
 	// first bind the table names of this entry
 	for (auto &binder : binders) {
-		ExpressionBinder::BindTableNames(*binder, *expr);
+		ExpressionBinder::QualifyColumnNames(*binder, expr);
 	}
 	// first check if the ORDER BY clause already points to an entry in the projection list
 	auto entry = projection_map.find(expr.get());
diff --git a/src/planner/expression_binder/select_binder.cpp b/src/planner/expression_binder/select_binder.cpp
index 93f530784d4b..645887d5192b 100644
--- a/src/planner/expression_binder/select_binder.cpp
+++ b/src/planner/expression_binder/select_binder.cpp
@@ -38,8 +38,8 @@ idx_t SelectBinder::TryBindGroup(ParsedExpression &expr, idx_t depth) {
 	// first check the group alias map, if expr is a ColumnRefExpression
 	if (expr.type == ExpressionType::COLUMN_REF) {
 		auto &colref = (ColumnRefExpression &)expr;
-		if (colref.table_name.empty()) {
-			auto alias_entry = info.alias_map.find(colref.column_name);
+		if (!colref.IsQualified()) {
+			auto alias_entry = info.alias_map.find(colref.column_names[0]);
 			if (alias_entry != info.alias_map.end()) {
 				// found entry!
 				return alias_entry->second;
@@ -74,7 +74,7 @@ BindResult SelectBinder::BindGroupingFunction(OperatorExpression &op, idx_t dept
 	vector<idx_t> group_indexes;
 	group_indexes.reserve(op.children.size());
 	for (auto &child : op.children) {
-		ExpressionBinder::BindTableNames(binder, *child);
+		ExpressionBinder::QualifyColumnNames(binder, child);
 		auto idx = TryBindGroup(*child, depth);
 		if (idx == INVALID_INDEX) {
 			return BindResult(binder.FormatError(
diff --git a/src/planner/operator/logical_get.cpp b/src/planner/operator/logical_get.cpp
index 852ada7d2a92..e055125a56bd 100644
--- a/src/planner/operator/logical_get.cpp
+++ b/src/planner/operator/logical_get.cpp
@@ -4,6 +4,7 @@
 #include "duckdb/storage/data_table.hpp"
 #include "duckdb/planner/operator/logical_get.hpp"
 #include "duckdb/common/string_util.hpp"
+#include "duckdb/function/table/table_scan.hpp"
 
 namespace duckdb {
 
@@ -17,6 +18,10 @@ string LogicalGet::GetName() const {
 	return StringUtil::Upper(function.name);
 }
 
+TableCatalogEntry *LogicalGet::GetTable() const {
+	return TableScanFunction::GetTableEntry(function, bind_data.get());
+}
+
 string LogicalGet::ParamsToString() const {
 	string result;
 	for (auto &kv : table_filters.filters) {
diff --git a/src/planner/table_binding.cpp b/src/planner/table_binding.cpp
index fe30e4772002..a99d66477298 100644
--- a/src/planner/table_binding.cpp
+++ b/src/planner/table_binding.cpp
@@ -34,16 +34,27 @@ bool Binding::TryGetBindingIndex(const string &column_name, column_t &result) {
 	return false;
 }
 
+column_t Binding::GetBindingIndex(const string &column_name) {
+	column_t result;
+	if (!TryGetBindingIndex(column_name, result)) {
+		throw InternalException("Binding index for column \"%s\" not found", column_name);
+	}
+	return result;
+}
+
 bool Binding::HasMatchingBinding(const string &column_name) {
 	column_t result;
 	return TryGetBindingIndex(column_name, result);
 }
 
+string Binding::ColumnNotFoundError(const string &column_name) const {
+	return StringUtil::Format("Values list \"%s\" does not have a column named \"%s\"", alias, column_name);
+}
+
 BindResult Binding::Bind(ColumnRefExpression &colref, idx_t depth) {
 	column_t column_index;
-	if (!TryGetBindingIndex(colref.column_name, column_index)) {
-		return BindResult(StringUtil::Format("Values list \"%s\" does not have a column named \"%s\"", alias.c_str(),
-		                                     colref.column_name.c_str()));
+	if (!TryGetBindingIndex(colref.GetColumnName(), column_index)) {
+		return BindResult(ColumnNotFoundError(colref.GetColumnName()));
 	}
 	ColumnBinding binding;
 	binding.table_index = index;
@@ -55,6 +66,10 @@ BindResult Binding::Bind(ColumnRefExpression &colref, idx_t depth) {
 	return BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), sql_type, binding, depth));
 }
 
+TableCatalogEntry *Binding::GetTableEntry() {
+	return nullptr;
+}
+
 TableBinding::TableBinding(const string &alias, vector<LogicalType> types_p, vector<string> names_p, LogicalGet &get,
                            idx_t index, bool add_row_id)
     : Binding(alias, move(types_p), move(names_p), index), get(get) {
@@ -66,10 +81,10 @@ TableBinding::TableBinding(const string &alias, vector<LogicalType> types_p, vec
 }
 
 BindResult TableBinding::Bind(ColumnRefExpression &colref, idx_t depth) {
+	auto &column_name = colref.GetColumnName();
 	column_t column_index;
-	if (!TryGetBindingIndex(colref.column_name, column_index)) {
-		return BindResult(StringUtil::Format("Table \"%s\" does not have a column named \"%s\"", colref.table_name,
-		                                     colref.column_name));
+	if (!TryGetBindingIndex(column_name, column_index)) {
+		return BindResult(ColumnNotFoundError(column_name));
 	}
 	// fetch the type of the column
 	LogicalType col_type;
@@ -103,15 +118,22 @@ BindResult TableBinding::Bind(ColumnRefExpression &colref, idx_t depth) {
 	return BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), col_type, binding, depth));
 }
 
+TableCatalogEntry *TableBinding::GetTableEntry() {
+	return get.GetTable();
+}
+
+string TableBinding::ColumnNotFoundError(const string &column_name) const {
+	return StringUtil::Format("Table \"%s\" does not have a column named \"%s\"", alias, column_name);
+}
+
 MacroBinding::MacroBinding(vector<LogicalType> types_p, vector<string> names_p, string macro_name_p)
-    : Binding("0_macro_parameters", move(types_p), move(names_p), -1), macro_name(move(macro_name_p)) {
+    : Binding(MacroBinding::MACRO_NAME, move(types_p), move(names_p), -1), macro_name(move(macro_name_p)) {
 }
 
 BindResult MacroBinding::Bind(ColumnRefExpression &colref, idx_t depth) {
 	column_t column_index;
-	if (!TryGetBindingIndex(colref.column_name, column_index)) {
-		return BindResult(
-		    StringUtil::Format("Macro \"%s\" does not have a parameter named \"%s\"", macro_name, colref.column_name));
+	if (!TryGetBindingIndex(colref.GetColumnName(), column_index)) {
+		throw InternalException("Column %s not found in macro", colref.GetColumnName());
 	}
 	ColumnBinding binding;
 	binding.table_index = index;
@@ -123,8 +145,8 @@ BindResult MacroBinding::Bind(ColumnRefExpression &colref, idx_t depth) {
 
 unique_ptr<ParsedExpression> MacroBinding::ParamToArg(ColumnRefExpression &colref) {
 	column_t column_index;
-	if (!TryGetBindingIndex(colref.column_name, column_index)) {
-		throw BinderException("Macro \"%s\" does not have a parameter named \"%s\"", macro_name, colref.column_name);
+	if (!TryGetBindingIndex(colref.GetColumnName(), column_index)) {
+		throw InternalException("Column %s not found in macro", colref.GetColumnName());
 	}
 	auto arg = arguments[column_index]->Copy();
 	arg->alias = colref.alias;
diff --git a/src/storage/storage_info.cpp b/src/storage/storage_info.cpp
index 4b565c28ecbf..58b796ea4332 100644
--- a/src/storage/storage_info.cpp
+++ b/src/storage/storage_info.cpp
@@ -2,6 +2,6 @@
 
 namespace duckdb {
 
-const uint64_t VERSION_NUMBER = 27;
+const uint64_t VERSION_NUMBER = 28;
 
 } // namespace duckdb
