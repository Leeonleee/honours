You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Support for more intuitive nested field access
Hi, thank you for your work!

I have a question/request regarding field access of nested structs. Given a table created such as the following:
```sql
CREATE TABLE x(y ROW(z ROW(w INTEGER)))
```
I found that based on some experimentation, the following queries work:
```sql
[1] SELECT (x.y).z.w FROM x
[2] SELECT (y).z.w FROM x
[3] SELECT x.y['z'].w FROM x
```
While the following do not:
```sql
# Not implemented Error: ColumnRef not implemented!
[4] SELECT x.y.z.w FROM x
[5] SELECT x.y.z FROM x
[6] SELECT (x.y.z).w FROM x
[7] SELECT (x.y.z.w) FROM x
# Binder Error: Referenced table "y" not found!
# Candidate tables: "x"
[8] SELECT y.z FROM x
```
It seems like there are only specific ways of accessing these kinds of nested fields that are supported. From what I can tell, the root-level struct either has to be wrapped in parentheses or the second level field has to be accessed using the subscript operator. Would you be able to provide some background on why the more "intuitive" syntax of `x.y.z.w` is not supported? Are there plans to add support for this syntax in the future?

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/catalog/catalog_entry/table_catalog_entry.cpp]
1: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/common/serializer.hpp"
7: #include "duckdb/main/connection.hpp"
8: #include "duckdb/main/database.hpp"
9: #include "duckdb/parser/constraints/list.hpp"
10: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
11: #include "duckdb/planner/constraints/bound_not_null_constraint.hpp"
12: #include "duckdb/planner/constraints/bound_unique_constraint.hpp"
13: #include "duckdb/planner/constraints/bound_check_constraint.hpp"
14: #include "duckdb/planner/expression/bound_constant_expression.hpp"
15: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
16: #include "duckdb/storage/storage_manager.hpp"
17: #include "duckdb/planner/binder.hpp"
18: 
19: #include "duckdb/execution/index/art/art.hpp"
20: #include "duckdb/parser/expression/columnref_expression.hpp"
21: #include "duckdb/planner/expression/bound_reference_expression.hpp"
22: #include "duckdb/parser/parsed_expression_iterator.hpp"
23: #include "duckdb/planner/expression_binder/alter_binder.hpp"
24: #include "duckdb/parser/keyword_helper.hpp"
25: 
26: #include <algorithm>
27: #include <sstream>
28: 
29: namespace duckdb {
30: 
31: idx_t TableCatalogEntry::GetColumnIndex(string &column_name, bool if_exists) {
32: 	auto entry = name_map.find(column_name);
33: 	if (entry == name_map.end()) {
34: 		// entry not found: try lower-casing the name
35: 		entry = name_map.find(StringUtil::Lower(column_name));
36: 		if (entry == name_map.end()) {
37: 			if (if_exists) {
38: 				return INVALID_INDEX;
39: 			}
40: 			throw BinderException("Table \"%s\" does not have a column with name \"%s\"", name, column_name);
41: 		}
42: 	}
43: 	column_name = columns[entry->second].name;
44: 	return idx_t(entry->second);
45: }
46: 
47: TableCatalogEntry::TableCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schema, BoundCreateTableInfo *info,
48:                                      std::shared_ptr<DataTable> inherited_storage)
49:     : StandardEntry(CatalogType::TABLE_ENTRY, schema, catalog, info->Base().table), storage(move(inherited_storage)),
50:       columns(move(info->Base().columns)), constraints(move(info->Base().constraints)),
51:       bound_constraints(move(info->bound_constraints)) {
52: 	this->temporary = info->Base().temporary;
53: 	// add lower case aliases
54: 	for (idx_t i = 0; i < columns.size(); i++) {
55: 		D_ASSERT(name_map.find(columns[i].name) == name_map.end());
56: 		name_map[columns[i].name] = i;
57: 	}
58: 	// add the "rowid" alias, if there is no rowid column specified in the table
59: 	if (name_map.find("rowid") == name_map.end()) {
60: 		name_map["rowid"] = COLUMN_IDENTIFIER_ROW_ID;
61: 	}
62: 	if (!storage) {
63: 		// create the physical storage
64: 		vector<ColumnDefinition> colum_def_copy;
65: 		for (auto &col_def : columns) {
66: 			colum_def_copy.push_back(col_def.Copy());
67: 		}
68: 		storage = make_shared<DataTable>(catalog->db, schema->name, name, move(colum_def_copy), move(info->data));
69: 
70: 		// create the unique indexes for the UNIQUE and PRIMARY KEY constraints
71: 		for (idx_t i = 0; i < bound_constraints.size(); i++) {
72: 			auto &constraint = bound_constraints[i];
73: 			if (constraint->type == ConstraintType::UNIQUE) {
74: 				// unique constraint: create a unique index
75: 				auto &unique = (BoundUniqueConstraint &)*constraint;
76: 				// fetch types and create expressions for the index from the columns
77: 				vector<column_t> column_ids;
78: 				vector<unique_ptr<Expression>> unbound_expressions;
79: 				vector<unique_ptr<Expression>> bound_expressions;
80: 				idx_t key_nr = 0;
81: 				for (auto &key : unique.keys) {
82: 					D_ASSERT(key < columns.size());
83: 
84: 					unbound_expressions.push_back(make_unique<BoundColumnRefExpression>(
85: 					    columns[key].name, columns[key].type, ColumnBinding(0, column_ids.size())));
86: 
87: 					bound_expressions.push_back(make_unique<BoundReferenceExpression>(columns[key].type, key_nr++));
88: 					column_ids.push_back(key);
89: 				}
90: 				// create an adaptive radix tree around the expressions
91: 				auto art = make_unique<ART>(column_ids, move(unbound_expressions), true, unique.is_primary_key);
92: 				storage->AddIndex(move(art), bound_expressions);
93: 			}
94: 		}
95: 	}
96: }
97: 
98: bool TableCatalogEntry::ColumnExists(const string &name) {
99: 	return name_map.find(name) != name_map.end();
100: }
101: 
102: unique_ptr<CatalogEntry> TableCatalogEntry::AlterEntry(ClientContext &context, AlterInfo *info) {
103: 	D_ASSERT(!internal);
104: 	if (info->type != AlterType::ALTER_TABLE) {
105: 		throw CatalogException("Can only modify table with ALTER TABLE statement");
106: 	}
107: 	auto table_info = (AlterTableInfo *)info;
108: 	switch (table_info->alter_table_type) {
109: 	case AlterTableType::RENAME_COLUMN: {
110: 		auto rename_info = (RenameColumnInfo *)table_info;
111: 		return RenameColumn(context, *rename_info);
112: 	}
113: 	case AlterTableType::RENAME_TABLE: {
114: 		auto rename_info = (RenameTableInfo *)table_info;
115: 		auto copied_table = Copy(context);
116: 		copied_table->name = rename_info->new_table_name;
117: 		return copied_table;
118: 	}
119: 	case AlterTableType::ADD_COLUMN: {
120: 		auto add_info = (AddColumnInfo *)table_info;
121: 		return AddColumn(context, *add_info);
122: 	}
123: 	case AlterTableType::REMOVE_COLUMN: {
124: 		auto remove_info = (RemoveColumnInfo *)table_info;
125: 		return RemoveColumn(context, *remove_info);
126: 	}
127: 	case AlterTableType::SET_DEFAULT: {
128: 		auto set_default_info = (SetDefaultInfo *)table_info;
129: 		return SetDefault(context, *set_default_info);
130: 	}
131: 	case AlterTableType::ALTER_COLUMN_TYPE: {
132: 		auto change_type_info = (ChangeColumnTypeInfo *)table_info;
133: 		return ChangeColumnType(context, *change_type_info);
134: 	}
135: 	default:
136: 		throw InternalException("Unrecognized alter table type!");
137: 	}
138: }
139: 
140: static void RenameExpression(ParsedExpression &expr, RenameColumnInfo &info) {
141: 	if (expr.type == ExpressionType::COLUMN_REF) {
142: 		auto &colref = (ColumnRefExpression &)expr;
143: 		if (colref.column_name == info.old_name) {
144: 			colref.column_name = info.new_name;
145: 		}
146: 	}
147: 	ParsedExpressionIterator::EnumerateChildren(
148: 	    expr, [&](const ParsedExpression &child) { RenameExpression((ParsedExpression &)child, info); });
149: }
150: 
151: unique_ptr<CatalogEntry> TableCatalogEntry::RenameColumn(ClientContext &context, RenameColumnInfo &info) {
152: 	auto create_info = make_unique<CreateTableInfo>(schema->name, name);
153: 	create_info->temporary = temporary;
154: 	idx_t rename_idx = GetColumnIndex(info.old_name);
155: 	for (idx_t i = 0; i < columns.size(); i++) {
156: 		ColumnDefinition copy = columns[i].Copy();
157: 
158: 		create_info->columns.push_back(move(copy));
159: 		if (rename_idx == i) {
160: 			create_info->columns[i].name = info.new_name;
161: 		}
162: 	}
163: 	for (idx_t c_idx = 0; c_idx < constraints.size(); c_idx++) {
164: 		auto copy = constraints[c_idx]->Copy();
165: 		switch (copy->type) {
166: 		case ConstraintType::NOT_NULL:
167: 			// NOT NULL constraint: no adjustments necessary
168: 			break;
169: 		case ConstraintType::CHECK: {
170: 			// CHECK constraint: need to rename column references that refer to the renamed column
171: 			auto &check = (CheckConstraint &)*copy;
172: 			RenameExpression(*check.expression, info);
173: 			break;
174: 		}
175: 		case ConstraintType::UNIQUE: {
176: 			// UNIQUE constraint: possibly need to rename columns
177: 			auto &unique = (UniqueConstraint &)*copy;
178: 			for (idx_t i = 0; i < unique.columns.size(); i++) {
179: 				if (unique.columns[i] == info.old_name) {
180: 					unique.columns[i] = info.new_name;
181: 				}
182: 			}
183: 			break;
184: 		}
185: 		default:
186: 			throw InternalException("Unsupported constraint for entry!");
187: 		}
188: 		create_info->constraints.push_back(move(copy));
189: 	}
190: 	auto binder = Binder::CreateBinder(context);
191: 	auto bound_create_info = binder->BindCreateTableInfo(move(create_info));
192: 	return make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(), storage);
193: }
194: 
195: unique_ptr<CatalogEntry> TableCatalogEntry::AddColumn(ClientContext &context, AddColumnInfo &info) {
196: 	auto create_info = make_unique<CreateTableInfo>(schema->name, name);
197: 	create_info->temporary = temporary;
198: 	for (idx_t i = 0; i < columns.size(); i++) {
199: 		create_info->columns.push_back(columns[i].Copy());
200: 	}
201: 	Binder::BindLogicalType(context, info.new_column.type, schema->name);
202: 	info.new_column.oid = columns.size();
203: 	create_info->columns.push_back(info.new_column.Copy());
204: 
205: 	auto binder = Binder::CreateBinder(context);
206: 	auto bound_create_info = binder->BindCreateTableInfo(move(create_info));
207: 	auto new_storage =
208: 	    make_shared<DataTable>(context, *storage, info.new_column, bound_create_info->bound_defaults.back().get());
209: 	return make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(),
210: 	                                      new_storage);
211: }
212: 
213: unique_ptr<CatalogEntry> TableCatalogEntry::RemoveColumn(ClientContext &context, RemoveColumnInfo &info) {
214: 	auto create_info = make_unique<CreateTableInfo>(schema->name, name);
215: 	create_info->temporary = temporary;
216: 	idx_t removed_index = GetColumnIndex(info.removed_column, info.if_exists);
217: 	if (removed_index == INVALID_INDEX) {
218: 		return nullptr;
219: 	}
220: 	for (idx_t i = 0; i < columns.size(); i++) {
221: 		if (removed_index != i) {
222: 			create_info->columns.push_back(columns[i].Copy());
223: 		}
224: 	}
225: 	if (create_info->columns.empty()) {
226: 		throw CatalogException("Cannot drop column: table only has one column remaining!");
227: 	}
228: 	// handle constraints for the new table
229: 	D_ASSERT(constraints.size() == bound_constraints.size());
230: 	for (idx_t constr_idx = 0; constr_idx < constraints.size(); constr_idx++) {
231: 		auto &constraint = constraints[constr_idx];
232: 		auto &bound_constraint = bound_constraints[constr_idx];
233: 		switch (bound_constraint->type) {
234: 		case ConstraintType::NOT_NULL: {
235: 			auto &not_null_constraint = (BoundNotNullConstraint &)*bound_constraint;
236: 			if (not_null_constraint.index != removed_index) {
237: 				// the constraint is not about this column: we need to copy it
238: 				// we might need to shift the index back by one though, to account for the removed column
239: 				idx_t new_index = not_null_constraint.index;
240: 				if (not_null_constraint.index > removed_index) {
241: 					new_index -= 1;
242: 				}
243: 				create_info->constraints.push_back(make_unique<NotNullConstraint>(new_index));
244: 			}
245: 			break;
246: 		}
247: 		case ConstraintType::CHECK: {
248: 			// CHECK constraint
249: 			auto &bound_check = (BoundCheckConstraint &)*bound_constraint;
250: 			// check if the removed column is part of the check constraint
251: 			if (bound_check.bound_columns.find(removed_index) != bound_check.bound_columns.end()) {
252: 				if (bound_check.bound_columns.size() > 1) {
253: 					// CHECK constraint that concerns mult
254: 					throw CatalogException(
255: 					    "Cannot drop column \"%s\" because there is a CHECK constraint that depends on it",
256: 					    info.removed_column);
257: 				} else {
258: 					// CHECK constraint that ONLY concerns this column, strip the constraint
259: 				}
260: 			} else {
261: 				// check constraint does not concern the removed column: simply re-add it
262: 				create_info->constraints.push_back(constraint->Copy());
263: 			}
264: 			break;
265: 		}
266: 		case ConstraintType::UNIQUE: {
267: 			auto copy = constraint->Copy();
268: 			auto &unique = (UniqueConstraint &)*copy;
269: 			if (unique.index != INVALID_INDEX) {
270: 				if (unique.index == removed_index) {
271: 					throw CatalogException(
272: 					    "Cannot drop column \"%s\" because there is a UNIQUE constraint that depends on it",
273: 					    info.removed_column);
274: 				} else if (unique.index > removed_index) {
275: 					unique.index--;
276: 				}
277: 			}
278: 			create_info->constraints.push_back(move(copy));
279: 			break;
280: 		}
281: 		default:
282: 			throw InternalException("Unsupported constraint for entry!");
283: 		}
284: 	}
285: 
286: 	auto binder = Binder::CreateBinder(context);
287: 	auto bound_create_info = binder->BindCreateTableInfo(move(create_info));
288: 	auto new_storage = make_shared<DataTable>(context, *storage, removed_index);
289: 	return make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(),
290: 	                                      new_storage);
291: }
292: 
293: unique_ptr<CatalogEntry> TableCatalogEntry::SetDefault(ClientContext &context, SetDefaultInfo &info) {
294: 	auto create_info = make_unique<CreateTableInfo>(schema->name, name);
295: 	idx_t default_idx = GetColumnIndex(info.column_name);
296: 	for (idx_t i = 0; i < columns.size(); i++) {
297: 		auto copy = columns[i].Copy();
298: 		if (default_idx == i) {
299: 			// set the default value of this column
300: 			copy.default_value = info.expression ? info.expression->Copy() : nullptr;
301: 		}
302: 		create_info->columns.push_back(move(copy));
303: 	}
304: 
305: 	for (idx_t i = 0; i < constraints.size(); i++) {
306: 		auto constraint = constraints[i]->Copy();
307: 		create_info->constraints.push_back(move(constraint));
308: 	}
309: 
310: 	auto binder = Binder::CreateBinder(context);
311: 	auto bound_create_info = binder->BindCreateTableInfo(move(create_info));
312: 	return make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(), storage);
313: }
314: 
315: unique_ptr<CatalogEntry> TableCatalogEntry::ChangeColumnType(ClientContext &context, ChangeColumnTypeInfo &info) {
316: 	auto create_info = make_unique<CreateTableInfo>(schema->name, name);
317: 	idx_t change_idx = GetColumnIndex(info.column_name);
318: 	for (idx_t i = 0; i < columns.size(); i++) {
319: 		auto copy = columns[i].Copy();
320: 		if (change_idx == i) {
321: 			// set the default value of this column
322: 			copy.type = info.target_type;
323: 		}
324: 		create_info->columns.push_back(move(copy));
325: 	}
326: 
327: 	for (idx_t i = 0; i < constraints.size(); i++) {
328: 		auto constraint = constraints[i]->Copy();
329: 		switch (constraint->type) {
330: 		case ConstraintType::CHECK: {
331: 			auto &bound_check = (BoundCheckConstraint &)*bound_constraints[i];
332: 			if (bound_check.bound_columns.find(change_idx) != bound_check.bound_columns.end()) {
333: 				throw BinderException("Cannot change the type of a column that has a CHECK constraint specified");
334: 			}
335: 			break;
336: 		}
337: 		case ConstraintType::NOT_NULL:
338: 			break;
339: 		case ConstraintType::UNIQUE: {
340: 			auto &bound_unique = (BoundUniqueConstraint &)*bound_constraints[i];
341: 			if (bound_unique.key_set.find(change_idx) != bound_unique.key_set.end()) {
342: 				throw BinderException(
343: 				    "Cannot change the type of a column that has a UNIQUE or PRIMARY KEY constraint specified");
344: 			}
345: 			break;
346: 		}
347: 		default:
348: 			throw InternalException("Unsupported constraint for entry!");
349: 		}
350: 		create_info->constraints.push_back(move(constraint));
351: 	}
352: 
353: 	auto binder = Binder::CreateBinder(context);
354: 	// bind the specified expression
355: 	vector<column_t> bound_columns;
356: 	AlterBinder expr_binder(*binder, context, *this, bound_columns, info.target_type);
357: 	auto expression = info.expression->Copy();
358: 	auto bound_expression = expr_binder.Bind(expression);
359: 	auto bound_create_info = binder->BindCreateTableInfo(move(create_info));
360: 	if (bound_columns.empty()) {
361: 		bound_columns.push_back(COLUMN_IDENTIFIER_ROW_ID);
362: 	}
363: 
364: 	auto new_storage =
365: 	    make_shared<DataTable>(context, *storage, change_idx, info.target_type, move(bound_columns), *bound_expression);
366: 	return make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(),
367: 	                                      new_storage);
368: }
369: 
370: ColumnDefinition &TableCatalogEntry::GetColumn(const string &name) {
371: 	auto entry = name_map.find(name);
372: 	if (entry == name_map.end() || entry->second == COLUMN_IDENTIFIER_ROW_ID) {
373: 		throw CatalogException("Column with name %s does not exist!", name);
374: 	}
375: 	return columns[entry->second];
376: }
377: 
378: vector<LogicalType> TableCatalogEntry::GetTypes() {
379: 	vector<LogicalType> types;
380: 	for (auto &it : columns) {
381: 		types.push_back(it.type);
382: 	}
383: 	return types;
384: }
385: 
386: void TableCatalogEntry::Serialize(Serializer &serializer) {
387: 	D_ASSERT(!internal);
388: 	serializer.WriteString(schema->name);
389: 	serializer.WriteString(name);
390: 	D_ASSERT(columns.size() <= NumericLimits<uint32_t>::Maximum());
391: 	serializer.Write<uint32_t>((uint32_t)columns.size());
392: 	for (auto &column : columns) {
393: 		column.Serialize(serializer);
394: 	}
395: 	D_ASSERT(constraints.size() <= NumericLimits<uint32_t>::Maximum());
396: 	serializer.Write<uint32_t>((uint32_t)constraints.size());
397: 	for (auto &constraint : constraints) {
398: 		constraint->Serialize(serializer);
399: 	}
400: }
401: 
402: string TableCatalogEntry::ToSQL() {
403: 	std::stringstream ss;
404: 
405: 	ss << "CREATE TABLE ";
406: 
407: 	if (schema->name != DEFAULT_SCHEMA) {
408: 		ss << KeywordHelper::WriteOptionallyQuoted(schema->name) << ".";
409: 	}
410: 
411: 	ss << KeywordHelper::WriteOptionallyQuoted(name) << "(";
412: 
413: 	// find all columns that have NOT NULL specified, but are NOT primary key columns
414: 	unordered_set<idx_t> not_null_columns;
415: 	unordered_set<idx_t> unique_columns;
416: 	unordered_set<idx_t> pk_columns;
417: 	unordered_set<string> multi_key_pks;
418: 	vector<string> extra_constraints;
419: 	for (auto &constraint : constraints) {
420: 		if (constraint->type == ConstraintType::NOT_NULL) {
421: 			auto &not_null = (NotNullConstraint &)*constraint;
422: 			not_null_columns.insert(not_null.index);
423: 		} else if (constraint->type == ConstraintType::UNIQUE) {
424: 			auto &pk = (UniqueConstraint &)*constraint;
425: 			vector<string> constraint_columns = pk.columns;
426: 			if (pk.index != INVALID_INDEX) {
427: 				// no columns specified: single column constraint
428: 				if (pk.is_primary_key) {
429: 					pk_columns.insert(pk.index);
430: 				} else {
431: 					unique_columns.insert(pk.index);
432: 				}
433: 			} else {
434: 				// multi-column constraint, this constraint needs to go at the end after all columns
435: 				if (pk.is_primary_key) {
436: 					// multi key pk column: insert set of columns into multi_key_pks
437: 					for (auto &col : pk.columns) {
438: 						multi_key_pks.insert(col);
439: 					}
440: 				}
441: 				extra_constraints.push_back(constraint->ToString());
442: 			}
443: 		} else {
444: 			extra_constraints.push_back(constraint->ToString());
445: 		}
446: 	}
447: 
448: 	for (idx_t i = 0; i < columns.size(); i++) {
449: 		if (i > 0) {
450: 			ss << ", ";
451: 		}
452: 		auto &column = columns[i];
453: 		ss << KeywordHelper::WriteOptionallyQuoted(column.name) << " " << column.type.ToString();
454: 		bool not_null = not_null_columns.find(column.oid) != not_null_columns.end();
455: 		bool is_single_key_pk = pk_columns.find(column.oid) != pk_columns.end();
456: 		bool is_multi_key_pk = multi_key_pks.find(column.name) != multi_key_pks.end();
457: 		bool is_unique = unique_columns.find(column.oid) != unique_columns.end();
458: 		if (not_null && !is_single_key_pk && !is_multi_key_pk) {
459: 			// NOT NULL but not a primary key column
460: 			ss << " NOT NULL";
461: 		}
462: 		if (is_single_key_pk) {
463: 			// single column pk: insert constraint here
464: 			ss << " PRIMARY KEY";
465: 		}
466: 		if (is_unique) {
467: 			// single column unique: insert constraint here
468: 			ss << " UNIQUE";
469: 		}
470: 		if (column.default_value) {
471: 			ss << " DEFAULT(" << column.default_value->ToString() << ")";
472: 		}
473: 	}
474: 	// print any extra constraints that still need to be printed
475: 	for (auto &extra_constraint : extra_constraints) {
476: 		ss << ", ";
477: 		ss << extra_constraint;
478: 	}
479: 
480: 	ss << ");";
481: 	return ss.str();
482: }
483: 
484: unique_ptr<CreateTableInfo> TableCatalogEntry::Deserialize(Deserializer &source) {
485: 	auto info = make_unique<CreateTableInfo>();
486: 
487: 	info->schema = source.Read<string>();
488: 	info->table = source.Read<string>();
489: 	auto column_count = source.Read<uint32_t>();
490: 
491: 	for (uint32_t i = 0; i < column_count; i++) {
492: 		auto column = ColumnDefinition::Deserialize(source);
493: 		info->columns.push_back(move(column));
494: 	}
495: 	auto constraint_count = source.Read<uint32_t>();
496: 
497: 	for (uint32_t i = 0; i < constraint_count; i++) {
498: 		auto constraint = Constraint::Deserialize(source);
499: 		info->constraints.push_back(move(constraint));
500: 	}
501: 	return info;
502: }
503: 
504: unique_ptr<CatalogEntry> TableCatalogEntry::Copy(ClientContext &context) {
505: 	auto create_info = make_unique<CreateTableInfo>(schema->name, name);
506: 	for (idx_t i = 0; i < columns.size(); i++) {
507: 		create_info->columns.push_back(columns[i].Copy());
508: 	}
509: 
510: 	for (idx_t i = 0; i < constraints.size(); i++) {
511: 		auto constraint = constraints[i]->Copy();
512: 		create_info->constraints.push_back(move(constraint));
513: 	}
514: 
515: 	auto binder = Binder::CreateBinder(context);
516: 	auto bound_create_info = binder->BindCreateTableInfo(move(create_info));
517: 	return make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(), storage);
518: }
519: 
520: void TableCatalogEntry::SetAsRoot() {
521: 	storage->SetAsRoot();
522: }
523: 
524: void TableCatalogEntry::CommitAlter(AlterInfo &info) {
525: 	D_ASSERT(info.type == AlterType::ALTER_TABLE);
526: 	auto &alter_table = (AlterTableInfo &)info;
527: 	string column_name;
528: 	switch (alter_table.alter_table_type) {
529: 	case AlterTableType::REMOVE_COLUMN: {
530: 		auto &remove_info = (RemoveColumnInfo &)alter_table;
531: 		column_name = remove_info.removed_column;
532: 		break;
533: 	}
534: 	case AlterTableType::ALTER_COLUMN_TYPE: {
535: 		auto &change_info = (ChangeColumnTypeInfo &)alter_table;
536: 		column_name = change_info.column_name;
537: 		break;
538: 	}
539: 	default:
540: 		break;
541: 	}
542: 	if (column_name.empty()) {
543: 		return;
544: 	}
545: 	idx_t removed_index = INVALID_INDEX;
546: 	for (idx_t i = 0; i < columns.size(); i++) {
547: 		if (columns[i].name == column_name) {
548: 			removed_index = i;
549: 			break;
550: 		}
551: 	}
552: 	D_ASSERT(removed_index != INVALID_INDEX);
553: 	storage->CommitDropColumn(removed_index);
554: }
555: 
556: void TableCatalogEntry::CommitDrop() {
557: 	storage->CommitDropTable();
558: }
559: 
560: } // namespace duckdb
[end of src/catalog/catalog_entry/table_catalog_entry.cpp]
[start of src/execution/expression_executor.cpp]
1: #include "duckdb/execution/expression_executor.hpp"
2: 
3: #include "duckdb/common/vector_operations/vector_operations.hpp"
4: #include "duckdb/execution/execution_context.hpp"
5: #include "duckdb/storage/statistics/base_statistics.hpp"
6: 
7: namespace duckdb {
8: 
9: ExpressionExecutor::ExpressionExecutor() {
10: }
11: 
12: ExpressionExecutor::ExpressionExecutor(const Expression *expression) : ExpressionExecutor() {
13: 	D_ASSERT(expression);
14: 	AddExpression(*expression);
15: }
16: 
17: ExpressionExecutor::ExpressionExecutor(const Expression &expression) : ExpressionExecutor() {
18: 	AddExpression(expression);
19: }
20: 
21: ExpressionExecutor::ExpressionExecutor(const vector<unique_ptr<Expression>> &exprs) : ExpressionExecutor() {
22: 	D_ASSERT(exprs.size() > 0);
23: 	for (auto &expr : exprs) {
24: 		AddExpression(*expr);
25: 	}
26: }
27: 
28: void ExpressionExecutor::AddExpression(const Expression &expr) {
29: 	expressions.push_back(&expr);
30: 	auto state = make_unique<ExpressionExecutorState>(expr.ToString());
31: 	Initialize(expr, *state);
32: 	states.push_back(move(state));
33: }
34: 
35: void ExpressionExecutor::Initialize(const Expression &expression, ExpressionExecutorState &state) {
36: 	state.root_state = InitializeState(expression, state);
37: 	state.executor = this;
38: }
39: 
40: void ExpressionExecutor::Execute(DataChunk *input, DataChunk &result) {
41: 	SetChunk(input);
42: 	D_ASSERT(expressions.size() == result.ColumnCount());
43: 	D_ASSERT(!expressions.empty());
44: 
45: 	for (idx_t i = 0; i < expressions.size(); i++) {
46: 		ExecuteExpression(i, result.data[i]);
47: 	}
48: 	result.SetCardinality(input ? input->size() : 1);
49: 	result.Verify();
50: }
51: 
52: void ExpressionExecutor::ExecuteExpression(DataChunk &input, Vector &result) {
53: 	SetChunk(&input);
54: 	ExecuteExpression(result);
55: }
56: 
57: idx_t ExpressionExecutor::SelectExpression(DataChunk &input, SelectionVector &sel) {
58: 	D_ASSERT(expressions.size() == 1);
59: 	SetChunk(&input);
60: 	states[0]->profiler.BeginSample();
61: 	idx_t selected_tuples = Select(*expressions[0], states[0]->root_state.get(), nullptr, input.size(), &sel, nullptr);
62: 	states[0]->profiler.EndSample(chunk ? chunk->size() : 0);
63: 	return selected_tuples;
64: }
65: 
66: void ExpressionExecutor::ExecuteExpression(Vector &result) {
67: 	D_ASSERT(expressions.size() == 1);
68: 	ExecuteExpression(0, result);
69: }
70: 
71: void ExpressionExecutor::ExecuteExpression(idx_t expr_idx, Vector &result) {
72: 	D_ASSERT(expr_idx < expressions.size());
73: 	D_ASSERT(result.GetType().id() == expressions[expr_idx]->return_type.id());
74: 	states[expr_idx]->profiler.BeginSample();
75: 	Execute(*expressions[expr_idx], states[expr_idx]->root_state.get(), nullptr, chunk ? chunk->size() : 1, result);
76: 	states[expr_idx]->profiler.EndSample(chunk ? chunk->size() : 0);
77: }
78: 
79: Value ExpressionExecutor::EvaluateScalar(const Expression &expr) {
80: 	D_ASSERT(expr.IsFoldable());
81: 	// use an ExpressionExecutor to execute the expression
82: 	ExpressionExecutor executor(expr);
83: 
84: 	Vector result(expr.return_type);
85: 	executor.ExecuteExpression(result);
86: 
87: 	D_ASSERT(result.GetVectorType() == VectorType::CONSTANT_VECTOR);
88: 	auto result_value = result.GetValue(0);
89: 	D_ASSERT(result_value.type().InternalType() == expr.return_type.InternalType());
90: 	return result_value;
91: }
92: 
93: bool ExpressionExecutor::TryEvaluateScalar(const Expression &expr, Value &result) {
94: 	try {
95: 		result = EvaluateScalar(expr);
96: 		return true;
97: 	} catch (...) {
98: 		return false;
99: 	}
100: }
101: 
102: void ExpressionExecutor::Verify(const Expression &expr, Vector &vector, idx_t count) {
103: 	D_ASSERT(expr.return_type.id() == vector.GetType().id());
104: 	vector.Verify(count);
105: 	if (expr.verification_stats) {
106: 		expr.verification_stats->Verify(vector, count);
107: 	}
108: }
109: 
110: unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const Expression &expr,
111:                                                                 ExpressionExecutorState &state) {
112: 	switch (expr.expression_class) {
113: 	case ExpressionClass::BOUND_REF:
114: 		return InitializeState((const BoundReferenceExpression &)expr, state);
115: 	case ExpressionClass::BOUND_BETWEEN:
116: 		return InitializeState((const BoundBetweenExpression &)expr, state);
117: 	case ExpressionClass::BOUND_CASE:
118: 		return InitializeState((const BoundCaseExpression &)expr, state);
119: 	case ExpressionClass::BOUND_CAST:
120: 		return InitializeState((const BoundCastExpression &)expr, state);
121: 	case ExpressionClass::BOUND_COMPARISON:
122: 		return InitializeState((const BoundComparisonExpression &)expr, state);
123: 	case ExpressionClass::BOUND_CONJUNCTION:
124: 		return InitializeState((const BoundConjunctionExpression &)expr, state);
125: 	case ExpressionClass::BOUND_CONSTANT:
126: 		return InitializeState((const BoundConstantExpression &)expr, state);
127: 	case ExpressionClass::BOUND_FUNCTION:
128: 		return InitializeState((const BoundFunctionExpression &)expr, state);
129: 	case ExpressionClass::BOUND_OPERATOR:
130: 		return InitializeState((const BoundOperatorExpression &)expr, state);
131: 	case ExpressionClass::BOUND_PARAMETER:
132: 		return InitializeState((const BoundParameterExpression &)expr, state);
133: 	default:
134: 		throw InternalException("Attempting to initialize state of expression of unknown type!");
135: 	}
136: }
137: 
138: void ExpressionExecutor::Execute(const Expression &expr, ExpressionState *state, const SelectionVector *sel,
139:                                  idx_t count, Vector &result) {
140: #ifdef DEBUG
141: 	if (result.GetVectorType() == VectorType::FLAT_VECTOR) {
142: 		D_ASSERT(FlatVector::Validity(result).CheckAllValid(count));
143: 	}
144: #endif
145: 
146: 	if (count == 0) {
147: 		return;
148: 	}
149: 	switch (expr.expression_class) {
150: 	case ExpressionClass::BOUND_BETWEEN:
151: 		Execute((const BoundBetweenExpression &)expr, state, sel, count, result);
152: 		break;
153: 	case ExpressionClass::BOUND_REF:
154: 		Execute((const BoundReferenceExpression &)expr, state, sel, count, result);
155: 		break;
156: 	case ExpressionClass::BOUND_CASE:
157: 		Execute((const BoundCaseExpression &)expr, state, sel, count, result);
158: 		break;
159: 	case ExpressionClass::BOUND_CAST:
160: 		Execute((const BoundCastExpression &)expr, state, sel, count, result);
161: 		break;
162: 	case ExpressionClass::BOUND_COMPARISON:
163: 		Execute((const BoundComparisonExpression &)expr, state, sel, count, result);
164: 		break;
165: 	case ExpressionClass::BOUND_CONJUNCTION:
166: 		Execute((const BoundConjunctionExpression &)expr, state, sel, count, result);
167: 		break;
168: 	case ExpressionClass::BOUND_CONSTANT:
169: 		Execute((const BoundConstantExpression &)expr, state, sel, count, result);
170: 		break;
171: 	case ExpressionClass::BOUND_FUNCTION:
172: 		Execute((const BoundFunctionExpression &)expr, state, sel, count, result);
173: 		break;
174: 	case ExpressionClass::BOUND_OPERATOR:
175: 		Execute((const BoundOperatorExpression &)expr, state, sel, count, result);
176: 		break;
177: 	case ExpressionClass::BOUND_PARAMETER:
178: 		Execute((const BoundParameterExpression &)expr, state, sel, count, result);
179: 		break;
180: 	default:
181: 		throw InternalException("Attempting to execute expression of unknown type!");
182: 	}
183: 	Verify(expr, result, count);
184: }
185: 
186: idx_t ExpressionExecutor::Select(const Expression &expr, ExpressionState *state, const SelectionVector *sel,
187:                                  idx_t count, SelectionVector *true_sel, SelectionVector *false_sel) {
188: 	if (count == 0) {
189: 		return 0;
190: 	}
191: 	D_ASSERT(true_sel || false_sel);
192: 	D_ASSERT(expr.return_type.id() == LogicalTypeId::BOOLEAN);
193: 	switch (expr.expression_class) {
194: 	case ExpressionClass::BOUND_BETWEEN:
195: 		return Select((BoundBetweenExpression &)expr, state, sel, count, true_sel, false_sel);
196: 	case ExpressionClass::BOUND_COMPARISON:
197: 		return Select((BoundComparisonExpression &)expr, state, sel, count, true_sel, false_sel);
198: 	case ExpressionClass::BOUND_CONJUNCTION:
199: 		return Select((BoundConjunctionExpression &)expr, state, sel, count, true_sel, false_sel);
200: 	default:
201: 		return DefaultSelect(expr, state, sel, count, true_sel, false_sel);
202: 	}
203: }
204: 
205: template <bool NO_NULL, bool HAS_TRUE_SEL, bool HAS_FALSE_SEL>
206: static inline idx_t DefaultSelectLoop(const SelectionVector *bsel, uint8_t *__restrict bdata, ValidityMask &mask,
207:                                       const SelectionVector *sel, idx_t count, SelectionVector *true_sel,
208:                                       SelectionVector *false_sel) {
209: 	idx_t true_count = 0, false_count = 0;
210: 	for (idx_t i = 0; i < count; i++) {
211: 		auto bidx = bsel->get_index(i);
212: 		auto result_idx = sel->get_index(i);
213: 		if (bdata[bidx] > 0 && (NO_NULL || mask.RowIsValid(bidx))) {
214: 			if (HAS_TRUE_SEL) {
215: 				true_sel->set_index(true_count++, result_idx);
216: 			}
217: 		} else {
218: 			if (HAS_FALSE_SEL) {
219: 				false_sel->set_index(false_count++, result_idx);
220: 			}
221: 		}
222: 	}
223: 	if (HAS_TRUE_SEL) {
224: 		return true_count;
225: 	} else {
226: 		return count - false_count;
227: 	}
228: }
229: 
230: template <bool NO_NULL>
231: static inline idx_t DefaultSelectSwitch(VectorData &idata, const SelectionVector *sel, idx_t count,
232:                                         SelectionVector *true_sel, SelectionVector *false_sel) {
233: 	if (true_sel && false_sel) {
234: 		return DefaultSelectLoop<NO_NULL, true, true>(idata.sel, (uint8_t *)idata.data, idata.validity, sel, count,
235: 		                                              true_sel, false_sel);
236: 	} else if (true_sel) {
237: 		return DefaultSelectLoop<NO_NULL, true, false>(idata.sel, (uint8_t *)idata.data, idata.validity, sel, count,
238: 		                                               true_sel, false_sel);
239: 	} else {
240: 		D_ASSERT(false_sel);
241: 		return DefaultSelectLoop<NO_NULL, false, true>(idata.sel, (uint8_t *)idata.data, idata.validity, sel, count,
242: 		                                               true_sel, false_sel);
243: 	}
244: }
245: 
246: idx_t ExpressionExecutor::DefaultSelect(const Expression &expr, ExpressionState *state, const SelectionVector *sel,
247:                                         idx_t count, SelectionVector *true_sel, SelectionVector *false_sel) {
248: 	// generic selection of boolean expression:
249: 	// resolve the true/false expression first
250: 	// then use that to generate the selection vector
251: 	bool intermediate_bools[STANDARD_VECTOR_SIZE];
252: 	Vector intermediate(LogicalType::BOOLEAN, (data_ptr_t)intermediate_bools);
253: 	Execute(expr, state, sel, count, intermediate);
254: 
255: 	VectorData idata;
256: 	intermediate.Orrify(count, idata);
257: 	if (!sel) {
258: 		sel = &FlatVector::INCREMENTAL_SELECTION_VECTOR;
259: 	}
260: 	if (!idata.validity.AllValid()) {
261: 		return DefaultSelectSwitch<false>(idata, sel, count, true_sel, false_sel);
262: 	} else {
263: 		return DefaultSelectSwitch<true>(idata, sel, count, true_sel, false_sel);
264: 	}
265: }
266: 
267: vector<unique_ptr<ExpressionExecutorState>> &ExpressionExecutor::GetStates() {
268: 	return states;
269: }
270: 
271: } // namespace duckdb
[end of src/execution/expression_executor.cpp]
[start of src/function/macro_function.cpp]
1: #include "duckdb/function/macro_function.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/macro_catalog_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
5: #include "duckdb/common/string_util.hpp"
6: #include "duckdb/parser/expression/columnref_expression.hpp"
7: #include "duckdb/parser/expression/comparison_expression.hpp"
8: #include "duckdb/parser/expression/function_expression.hpp"
9: 
10: namespace duckdb {
11: 
12: MacroFunction::MacroFunction(unique_ptr<ParsedExpression> expression) : expression(move(expression)) {
13: }
14: 
15: string MacroFunction::ValidateArguments(MacroCatalogEntry &macro_func, FunctionExpression &function_expr,
16:                                         vector<unique_ptr<ParsedExpression>> &positionals,
17:                                         unordered_map<string, unique_ptr<ParsedExpression>> &defaults) {
18: 	// separate positional and default arguments
19: 	auto &macro_def = *macro_func.function;
20: 	for (auto &arg : function_expr.children) {
21: 		if (arg->type == ExpressionType::VALUE_CONSTANT && !arg->alias.empty()) {
22: 			// default argument
23: 			if (macro_def.default_parameters.find(arg->alias) == macro_def.default_parameters.end()) {
24: 				return StringUtil::Format("Macro %s does not have default parameter %s!", macro_func.name, arg->alias);
25: 			} else if (defaults.find(arg->alias) != defaults.end()) {
26: 				return StringUtil::Format("Duplicate default parameters %s!", arg->alias);
27: 			}
28: 			defaults[arg->alias] = move(arg);
29: 		} else if (!defaults.empty()) {
30: 			return "Positional parameters cannot come after parameters with a default value!";
31: 		} else {
32: 			// positional argument
33: 			positionals.push_back(move(arg));
34: 		}
35: 	}
36: 
37: 	// validate if the right number of arguments was supplied
38: 	string error;
39: 	auto &parameters = macro_func.function->parameters;
40: 	if (parameters.size() != positionals.size()) {
41: 		error = StringUtil::Format(
42: 		    "Macro function '%s(%s)' requires ", macro_func.name,
43: 		    StringUtil::Join(parameters, parameters.size(), ", ", [](const unique_ptr<ParsedExpression> &p) {
44: 			    return ((ColumnRefExpression &)*p).column_name;
45: 		    }));
46: 		error += parameters.size() == 1 ? "a single positional argument"
47: 		                                : StringUtil::Format("%i positional arguments", parameters.size());
48: 		error += ", but ";
49: 		error += positionals.size() == 1 ? "a single positional argument was"
50: 		                                 : StringUtil::Format("%i positional arguments were", positionals.size());
51: 		error += " provided.";
52: 		return error;
53: 	}
54: 
55: 	// fill in default value where this was not supplied
56: 	for (auto it = macro_def.default_parameters.begin(); it != macro_def.default_parameters.end(); it++) {
57: 		if (defaults.find(it->first) == defaults.end()) {
58: 			defaults[it->first] = it->second->Copy();
59: 		}
60: 	}
61: 
62: 	return error;
63: }
64: 
65: unique_ptr<MacroFunction> MacroFunction::Copy() {
66: 	auto result = make_unique<MacroFunction>(expression->Copy());
67: 	for (auto &param : parameters) {
68: 		result->parameters.push_back(param->Copy());
69: 	}
70: 	for (auto &kv : default_parameters) {
71: 		result->default_parameters[kv.first] = kv.second->Copy();
72: 	}
73: 	return result;
74: }
75: 
76: } // namespace duckdb
[end of src/function/macro_function.cpp]
[start of src/function/table/table_scan.cpp]
1: #include "duckdb/function/table/table_scan.hpp"
2: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
3: 
4: #include "duckdb/storage/data_table.hpp"
5: #include "duckdb/transaction/transaction.hpp"
6: #include "duckdb/transaction/local_storage.hpp"
7: 
8: #include "duckdb/optimizer/matcher/expression_matcher.hpp"
9: 
10: #include "duckdb/planner/expression/bound_between_expression.hpp"
11: #include "duckdb/planner/expression_iterator.hpp"
12: #include "duckdb/planner/operator/logical_get.hpp"
13: #include "duckdb/parallel/parallel_state.hpp"
14: 
15: #include "duckdb/common/mutex.hpp"
16: 
17: namespace duckdb {
18: 
19: //===--------------------------------------------------------------------===//
20: // Table Scan
21: //===--------------------------------------------------------------------===//
22: bool TableScanParallelStateNext(ClientContext &context, const FunctionData *bind_data,
23:                                 FunctionOperatorData *operator_state, ParallelState *parallel_state_p);
24: 
25: struct TableScanOperatorData : public FunctionOperatorData {
26: 	//! The current position in the scan
27: 	TableScanState scan_state;
28: 	vector<column_t> column_ids;
29: };
30: 
31: static unique_ptr<FunctionOperatorData> TableScanInit(ClientContext &context, const FunctionData *bind_data_p,
32:                                                       const vector<column_t> &column_ids,
33:                                                       TableFilterCollection *filters) {
34: 	auto result = make_unique<TableScanOperatorData>();
35: 	auto &transaction = Transaction::GetTransaction(context);
36: 	auto &bind_data = (const TableScanBindData &)*bind_data_p;
37: 	result->column_ids = column_ids;
38: 	result->scan_state.table_filters = filters->table_filters;
39: 	bind_data.table->storage->InitializeScan(transaction, result->scan_state, result->column_ids,
40: 	                                         filters->table_filters);
41: 	return move(result);
42: }
43: 
44: static unique_ptr<BaseStatistics> TableScanStatistics(ClientContext &context, const FunctionData *bind_data_p,
45:                                                       column_t column_id) {
46: 	auto &bind_data = (const TableScanBindData &)*bind_data_p;
47: 	auto &transaction = Transaction::GetTransaction(context);
48: 	if (transaction.storage.Find(bind_data.table->storage.get())) {
49: 		// we don't emit any statistics for tables that have outstanding transaction-local data
50: 		return nullptr;
51: 	}
52: 	return bind_data.table->storage->GetStatistics(context, column_id);
53: }
54: 
55: static unique_ptr<FunctionOperatorData> TableScanParallelInit(ClientContext &context, const FunctionData *bind_data_p,
56:                                                               ParallelState *state, const vector<column_t> &column_ids,
57:                                                               TableFilterCollection *filters) {
58: 	auto result = make_unique<TableScanOperatorData>();
59: 	result->column_ids = column_ids;
60: 	result->scan_state.table_filters = filters->table_filters;
61: 	TableScanParallelStateNext(context, bind_data_p, result.get(), state);
62: 	return move(result);
63: }
64: 
65: static void TableScanFunc(ClientContext &context, const FunctionData *bind_data_p, FunctionOperatorData *operator_state,
66:                           DataChunk *, DataChunk &output) {
67: 	D_ASSERT(bind_data_p);
68: 	D_ASSERT(operator_state);
69: 	auto &bind_data = (TableScanBindData &)*bind_data_p;
70: 	auto &state = (TableScanOperatorData &)*operator_state;
71: 	auto &transaction = Transaction::GetTransaction(context);
72: 	bind_data.table->storage->Scan(transaction, output, state.scan_state, state.column_ids);
73: 	bind_data.chunk_count++;
74: }
75: 
76: struct ParallelTableFunctionScanState : public ParallelState {
77: 	ParallelTableScanState state;
78: 	mutex lock;
79: };
80: 
81: idx_t TableScanMaxThreads(ClientContext &context, const FunctionData *bind_data_p) {
82: 	D_ASSERT(bind_data_p);
83: 	auto &bind_data = (const TableScanBindData &)*bind_data_p;
84: 	return bind_data.table->storage->MaxThreads(context);
85: }
86: 
87: unique_ptr<ParallelState> TableScanInitParallelState(ClientContext &context, const FunctionData *bind_data_p,
88:                                                      const vector<column_t> &column_ids,
89:                                                      TableFilterCollection *filters) {
90: 	D_ASSERT(bind_data_p);
91: 	auto &bind_data = (const TableScanBindData &)*bind_data_p;
92: 	auto result = make_unique<ParallelTableFunctionScanState>();
93: 	bind_data.table->storage->InitializeParallelScan(context, result->state);
94: 	return move(result);
95: }
96: 
97: bool TableScanParallelStateNext(ClientContext &context, const FunctionData *bind_data_p,
98:                                 FunctionOperatorData *operator_state, ParallelState *parallel_state_p) {
99: 	D_ASSERT(bind_data_p);
100: 	D_ASSERT(parallel_state_p);
101: 	D_ASSERT(operator_state);
102: 	auto &bind_data = (const TableScanBindData &)*bind_data_p;
103: 	auto &parallel_state = (ParallelTableFunctionScanState &)*parallel_state_p;
104: 	auto &state = (TableScanOperatorData &)*operator_state;
105: 
106: 	lock_guard<mutex> parallel_lock(parallel_state.lock);
107: 	return bind_data.table->storage->NextParallelScan(context, parallel_state.state, state.scan_state,
108: 	                                                  state.column_ids);
109: }
110: 
111: int TableScanProgress(ClientContext &context, const FunctionData *bind_data_p) {
112: 	auto &bind_data = (TableScanBindData &)*bind_data_p;
113: 	idx_t total_rows = bind_data.table->storage->GetTotalRows();
114: 	if (total_rows == 0 || total_rows < STANDARD_VECTOR_SIZE) {
115: 		//! Table is either empty or smaller than a vector size, so it is finished
116: 		return 100;
117: 	}
118: 	auto percentage = (bind_data.chunk_count * STANDARD_VECTOR_SIZE * 100) / total_rows;
119: 	if (percentage > 100) {
120: 		//! In case the last chunk has less elements than STANDARD_VECTOR_SIZE, if our percentage is over 100
121: 		//! It means we finished this table.
122: 		return 100;
123: 	}
124: 	return percentage;
125: }
126: 
127: void TableScanDependency(unordered_set<CatalogEntry *> &entries, const FunctionData *bind_data_p) {
128: 	auto &bind_data = (const TableScanBindData &)*bind_data_p;
129: 	entries.insert(bind_data.table);
130: }
131: 
132: unique_ptr<NodeStatistics> TableScanCardinality(ClientContext &context, const FunctionData *bind_data_p) {
133: 	auto &bind_data = (const TableScanBindData &)*bind_data_p;
134: 	auto &transaction = Transaction::GetTransaction(context);
135: 	idx_t estimated_cardinality =
136: 	    bind_data.table->storage->info->cardinality + transaction.storage.AddedRows(bind_data.table->storage.get());
137: 	return make_unique<NodeStatistics>(bind_data.table->storage->info->cardinality, estimated_cardinality);
138: }
139: 
140: //===--------------------------------------------------------------------===//
141: // Index Scan
142: //===--------------------------------------------------------------------===//
143: struct IndexScanOperatorData : public FunctionOperatorData {
144: 	explicit IndexScanOperatorData(data_ptr_t row_id_data) : row_ids(LOGICAL_ROW_TYPE, row_id_data) {
145: 	}
146: 
147: 	Vector row_ids;
148: 	ColumnFetchState fetch_state;
149: 	LocalScanState local_storage_state;
150: 	vector<column_t> column_ids;
151: 	bool finished;
152: };
153: 
154: static unique_ptr<FunctionOperatorData> IndexScanInit(ClientContext &context, const FunctionData *bind_data_p,
155:                                                       const vector<column_t> &column_ids,
156:                                                       TableFilterCollection *filters) {
157: 	auto &bind_data = (const TableScanBindData &)*bind_data_p;
158: 	data_ptr_t row_id_data = nullptr;
159: 	if (!bind_data.result_ids.empty()) {
160: 		row_id_data = (data_ptr_t)&bind_data.result_ids[0];
161: 	}
162: 	auto result = make_unique<IndexScanOperatorData>(row_id_data);
163: 	auto &transaction = Transaction::GetTransaction(context);
164: 	result->column_ids = column_ids;
165: 	transaction.storage.InitializeScan(bind_data.table->storage.get(), result->local_storage_state,
166: 	                                   filters->table_filters);
167: 
168: 	result->finished = false;
169: 	return move(result);
170: }
171: 
172: static void IndexScanFunction(ClientContext &context, const FunctionData *bind_data_p,
173:                               FunctionOperatorData *operator_state, DataChunk *input, DataChunk &output) {
174: 	auto &bind_data = (const TableScanBindData &)*bind_data_p;
175: 	auto &state = (IndexScanOperatorData &)*operator_state;
176: 	auto &transaction = Transaction::GetTransaction(context);
177: 	if (!state.finished) {
178: 		bind_data.table->storage->Fetch(transaction, output, state.column_ids, state.row_ids,
179: 		                                bind_data.result_ids.size(), state.fetch_state);
180: 		state.finished = true;
181: 	}
182: 	if (output.size() == 0) {
183: 		transaction.storage.Scan(state.local_storage_state, state.column_ids, output);
184: 	}
185: }
186: 
187: static void RewriteIndexExpression(Index &index, LogicalGet &get, Expression &expr, bool &rewrite_possible) {
188: 	if (expr.type == ExpressionType::BOUND_COLUMN_REF) {
189: 		auto &bound_colref = (BoundColumnRefExpression &)expr;
190: 		// bound column ref: rewrite to fit in the current set of bound column ids
191: 		bound_colref.binding.table_index = get.table_index;
192: 		column_t referenced_column = index.column_ids[bound_colref.binding.column_index];
193: 		// search for the referenced column in the set of column_ids
194: 		for (idx_t i = 0; i < get.column_ids.size(); i++) {
195: 			if (get.column_ids[i] == referenced_column) {
196: 				bound_colref.binding.column_index = i;
197: 				return;
198: 			}
199: 		}
200: 		// column id not found in bound columns in the LogicalGet: rewrite not possible
201: 		rewrite_possible = false;
202: 	}
203: 	ExpressionIterator::EnumerateChildren(
204: 	    expr, [&](Expression &child) { RewriteIndexExpression(index, get, child, rewrite_possible); });
205: }
206: 
207: void TableScanPushdownComplexFilter(ClientContext &context, LogicalGet &get, FunctionData *bind_data_p,
208:                                     vector<unique_ptr<Expression>> &filters) {
209: 	auto &bind_data = (TableScanBindData &)*bind_data_p;
210: 	auto table = bind_data.table;
211: 	auto &storage = *table->storage;
212: 
213: 	if (bind_data.is_index_scan) {
214: 		return;
215: 	}
216: 	if (filters.empty()) {
217: 		// no indexes or no filters: skip the pushdown
218: 		return;
219: 	}
220: 	// behold
221: 	storage.info->indexes.Scan([&](Index &index) {
222: 		// first rewrite the index expression so the ColumnBindings align with the column bindings of the current table
223: 		if (index.unbound_expressions.size() > 1) {
224: 			return false;
225: 		}
226: 		auto index_expression = index.unbound_expressions[0]->Copy();
227: 		bool rewrite_possible = true;
228: 		RewriteIndexExpression(index, get, *index_expression, rewrite_possible);
229: 		if (!rewrite_possible) {
230: 			// could not rewrite!
231: 			return false;
232: 		}
233: 
234: 		Value low_value, high_value, equal_value;
235: 		ExpressionType low_comparison_type = ExpressionType::INVALID, high_comparison_type = ExpressionType::INVALID;
236: 		// try to find a matching index for any of the filter expressions
237: 		for (auto &filter : filters) {
238: 			auto expr = filter.get();
239: 
240: 			// create a matcher for a comparison with a constant
241: 			ComparisonExpressionMatcher matcher;
242: 			// match on a comparison type
243: 			matcher.expr_type = make_unique<ComparisonExpressionTypeMatcher>();
244: 			// match on a constant comparison with the indexed expression
245: 			matcher.matchers.push_back(make_unique<ExpressionEqualityMatcher>(index_expression.get()));
246: 			matcher.matchers.push_back(make_unique<ConstantExpressionMatcher>());
247: 
248: 			matcher.policy = SetMatcher::Policy::UNORDERED;
249: 
250: 			vector<Expression *> bindings;
251: 			if (matcher.Match(expr, bindings)) {
252: 				// range or equality comparison with constant value
253: 				// we can use our index here
254: 				// bindings[0] = the expression
255: 				// bindings[1] = the index expression
256: 				// bindings[2] = the constant
257: 				auto comparison = (BoundComparisonExpression *)bindings[0];
258: 				D_ASSERT(bindings[0]->GetExpressionClass() == ExpressionClass::BOUND_COMPARISON);
259: 				D_ASSERT(bindings[2]->type == ExpressionType::VALUE_CONSTANT);
260: 
261: 				auto constant_value = ((BoundConstantExpression *)bindings[2])->value;
262: 				auto comparison_type = comparison->type;
263: 				if (comparison->left->type == ExpressionType::VALUE_CONSTANT) {
264: 					// the expression is on the right side, we flip them around
265: 					comparison_type = FlipComparisionExpression(comparison_type);
266: 				}
267: 				if (comparison_type == ExpressionType::COMPARE_EQUAL) {
268: 					// equality value
269: 					// equality overrides any other bounds so we just break here
270: 					equal_value = constant_value;
271: 					break;
272: 				} else if (comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO ||
273: 				           comparison_type == ExpressionType::COMPARE_GREATERTHAN) {
274: 					// greater than means this is a lower bound
275: 					low_value = constant_value;
276: 					low_comparison_type = comparison_type;
277: 				} else {
278: 					// smaller than means this is an upper bound
279: 					high_value = constant_value;
280: 					high_comparison_type = comparison_type;
281: 				}
282: 			} else if (expr->type == ExpressionType::COMPARE_BETWEEN) {
283: 				// BETWEEN expression
284: 				auto &between = (BoundBetweenExpression &)*expr;
285: 				if (!between.input->Equals(index_expression.get())) {
286: 					// expression doesn't match the current index expression
287: 					continue;
288: 				}
289: 				if (between.lower->type != ExpressionType::VALUE_CONSTANT ||
290: 				    between.upper->type != ExpressionType::VALUE_CONSTANT) {
291: 					// not a constant comparison
292: 					continue;
293: 				}
294: 				low_value = ((BoundConstantExpression &)*between.lower).value;
295: 				low_comparison_type = between.lower_inclusive ? ExpressionType::COMPARE_GREATERTHANOREQUALTO
296: 				                                              : ExpressionType::COMPARE_GREATERTHAN;
297: 				high_value = ((BoundConstantExpression &)*between.upper).value;
298: 				high_comparison_type = between.upper_inclusive ? ExpressionType::COMPARE_LESSTHANOREQUALTO
299: 				                                               : ExpressionType::COMPARE_LESSTHAN;
300: 				break;
301: 			}
302: 		}
303: 		if (!equal_value.is_null || !low_value.is_null || !high_value.is_null) {
304: 			// we can scan this index using this predicate: try a scan
305: 			auto &transaction = Transaction::GetTransaction(context);
306: 			unique_ptr<IndexScanState> index_state;
307: 			if (!equal_value.is_null) {
308: 				// equality predicate
309: 				index_state =
310: 				    index.InitializeScanSinglePredicate(transaction, equal_value, ExpressionType::COMPARE_EQUAL);
311: 			} else if (!low_value.is_null && !high_value.is_null) {
312: 				// two-sided predicate
313: 				index_state = index.InitializeScanTwoPredicates(transaction, low_value, low_comparison_type, high_value,
314: 				                                                high_comparison_type);
315: 			} else if (!low_value.is_null) {
316: 				// less than predicate
317: 				index_state = index.InitializeScanSinglePredicate(transaction, low_value, low_comparison_type);
318: 			} else {
319: 				D_ASSERT(!high_value.is_null);
320: 				index_state = index.InitializeScanSinglePredicate(transaction, high_value, high_comparison_type);
321: 			}
322: 			if (index.Scan(transaction, storage, *index_state, STANDARD_VECTOR_SIZE, bind_data.result_ids)) {
323: 				// use an index scan!
324: 				bind_data.is_index_scan = true;
325: 				get.function.init = IndexScanInit;
326: 				get.function.function = IndexScanFunction;
327: 				get.function.max_threads = nullptr;
328: 				get.function.init_parallel_state = nullptr;
329: 				get.function.parallel_state_next = nullptr;
330: 				get.function.table_scan_progress = nullptr;
331: 				get.function.filter_pushdown = false;
332: 			} else {
333: 				bind_data.result_ids.clear();
334: 			}
335: 			return true;
336: 		}
337: 		return false;
338: 	});
339: }
340: 
341: string TableScanToString(const FunctionData *bind_data_p) {
342: 	auto &bind_data = (const TableScanBindData &)*bind_data_p;
343: 	string result = bind_data.table->name;
344: 	return result;
345: }
346: 
347: TableFunction TableScanFunction::GetFunction() {
348: 	TableFunction scan_function("seq_scan", {}, TableScanFunc);
349: 	scan_function.init = TableScanInit;
350: 	scan_function.statistics = TableScanStatistics;
351: 	scan_function.dependency = TableScanDependency;
352: 	scan_function.cardinality = TableScanCardinality;
353: 	scan_function.pushdown_complex_filter = TableScanPushdownComplexFilter;
354: 	scan_function.to_string = TableScanToString;
355: 	scan_function.max_threads = TableScanMaxThreads;
356: 	scan_function.init_parallel_state = TableScanInitParallelState;
357: 	scan_function.parallel_init = TableScanParallelInit;
358: 	scan_function.parallel_state_next = TableScanParallelStateNext;
359: 	scan_function.table_scan_progress = TableScanProgress;
360: 	scan_function.projection_pushdown = true;
361: 	scan_function.filter_pushdown = true;
362: 	return scan_function;
363: }
364: 
365: } // namespace duckdb
[end of src/function/table/table_scan.cpp]
[start of src/include/duckdb/function/table/table_scan.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/table/table_scan.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/table_function.hpp"
12: #include "duckdb/common/atomic.hpp"
13: 
14: namespace duckdb {
15: class TableCatalogEntry;
16: 
17: struct TableScanBindData : public FunctionData {
18: 	explicit TableScanBindData(TableCatalogEntry *table) : table(table), is_index_scan(false), chunk_count(0) {
19: 	}
20: 
21: 	//! The table to scan
22: 	TableCatalogEntry *table;
23: 
24: 	//! Whether or not the table scan is an index scan
25: 	bool is_index_scan;
26: 	//! The row ids to fetch (in case of an index scan)
27: 	vector<row_t> result_ids;
28: 
29: 	//! How many chunks we already scanned
30: 	atomic<idx_t> chunk_count;
31: };
32: 
33: //! The table scan function represents a sequential scan over one of DuckDB's base tables.
34: struct TableScanFunction {
35: 	static TableFunction GetFunction();
36: };
37: 
38: } // namespace duckdb
[end of src/include/duckdb/function/table/table_scan.hpp]
[start of src/include/duckdb/parser/expression/columnref_expression.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parser/expression/columnref_expression.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/parser/parsed_expression.hpp"
12: 
13: namespace duckdb {
14: 
15: //! Represents a reference to a column from either the FROM clause or from an
16: //! alias
17: class ColumnRefExpression : public ParsedExpression {
18: public:
19: 	//! Specify both the column and table name
20: 	ColumnRefExpression(string column_name, string table_name);
21: 	//! Only specify the column name, the table name will be derived later
22: 	explicit ColumnRefExpression(string column_name);
23: 
24: 	//! Column name that is referenced
25: 	string column_name;
26: 	//! Table name of the column name that is referenced (optional)
27: 	string table_name;
28: 
29: public:
30: 	bool IsScalar() const override {
31: 		return false;
32: 	}
33: 
34: 	string GetName() const override;
35: 	string ToString() const override;
36: 
37: 	static bool Equals(const ColumnRefExpression *a, const ColumnRefExpression *b);
38: 	hash_t Hash() const override;
39: 
40: 	unique_ptr<ParsedExpression> Copy() const override;
41: 
42: 	void Serialize(Serializer &serializer) override;
43: 	static unique_ptr<ParsedExpression> Deserialize(ExpressionType type, Deserializer &source);
44: };
45: } // namespace duckdb
[end of src/include/duckdb/parser/expression/columnref_expression.hpp]
[start of src/include/duckdb/parser/parsed_expression_iterator.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parser/parsed_expression_iterator.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/parser/parsed_expression.hpp"
12: 
13: #include <functional>
14: 
15: namespace duckdb {
16: 
17: class ParsedExpressionIterator {
18: public:
19: 	static void EnumerateChildren(const ParsedExpression &expression,
20: 	                              const std::function<void(const ParsedExpression &child)> &callback);
21: 	static void EnumerateChildren(ParsedExpression &expr, const std::function<void(ParsedExpression &child)> &callback);
22: 	static void EnumerateChildren(ParsedExpression &expr,
23: 	                              const std::function<void(unique_ptr<ParsedExpression> &child)> &callback);
24: };
25: 
26: } // namespace duckdb
[end of src/include/duckdb/parser/parsed_expression_iterator.hpp]
[start of src/include/duckdb/planner/bind_context.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/bind_context.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/catalog.hpp"
12: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
13: #include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
14: #include "duckdb/common/case_insensitive_map.hpp"
15: #include "duckdb/common/unordered_map.hpp"
16: #include "duckdb/common/unordered_set.hpp"
17: #include "duckdb/parser/expression/columnref_expression.hpp"
18: #include "duckdb/parser/parsed_expression.hpp"
19: #include "duckdb/parser/qualified_name_set.hpp"
20: #include "duckdb/planner/expression.hpp"
21: #include "duckdb/planner/expression_binder.hpp"
22: #include "duckdb/planner/table_binding.hpp"
23: 
24: namespace duckdb {
25: class Binder;
26: class LogicalGet;
27: class BoundQueryNode;
28: 
29: class StarExpression;
30: 
31: struct UsingColumnSet {
32: 	string primary_binding;
33: 	unordered_set<string> bindings;
34: };
35: 
36: //! The BindContext object keeps track of all the tables and columns that are
37: //! encountered during the binding process.
38: class BindContext {
39: public:
40: 	//! Keep track of recursive CTE references
41: 	case_insensitive_map_t<std::shared_ptr<idx_t>> cte_references;
42: 
43: public:
44: 	//! Given a column name, find the matching table it belongs to. Throws an
45: 	//! exception if no table has a column of the given name.
46: 	string GetMatchingBinding(const string &column_name);
47: 	//! Like GetMatchingBinding, but instead of throwing an error if multiple tables have the same binding it will
48: 	//! return a list of all the matching ones
49: 	unordered_set<string> GetMatchingBindings(const string &column_name);
50: 	//! Like GetMatchingBindings, but returns the top 3 most similar bindings (in levenshtein distance) instead of the
51: 	//! matching ones
52: 	vector<string> GetSimilarBindings(const string &column_name);
53: 
54: 	Binding *GetCTEBinding(const string &ctename);
55: 	//! Binds a column expression to the base table. Returns the bound expression
56: 	//! or throws an exception if the column could not be bound.
57: 	BindResult BindColumn(ColumnRefExpression &colref, idx_t depth);
58: 	string BindColumn(PositionalReferenceExpression &ref, string &table_name, string &column_name);
59: 	BindResult BindColumn(PositionalReferenceExpression &ref, idx_t depth);
60: 
61: 	//! Generate column expressions for all columns that are present in the
62: 	//! referenced tables. This is used to resolve the * expression in a
63: 	//! selection list.
64: 	void GenerateAllColumnExpressions(StarExpression &expr, vector<unique_ptr<ParsedExpression>> &new_select_list);
65: 	//! Check if the given (binding, column_name) is in the exclusion/replacement lists.
66: 	//! Returns true if it is in one of these lists, and should therefore be skipped.
67: 	bool CheckExclusionList(StarExpression &expr, Binding *binding, const string &column_name,
68: 	                        vector<unique_ptr<ParsedExpression>> &new_select_list,
69: 	                        case_insensitive_set_t &excluded_columns);
70: 
71: 	const vector<std::pair<string, Binding *>> &GetBindingsList() {
72: 		return bindings_list;
73: 	}
74: 
75: 	//! Adds a base table with the given alias to the BindContext.
76: 	void AddBaseTable(idx_t index, const string &alias, const vector<string> &names, const vector<LogicalType> &types,
77: 	                  LogicalGet &get);
78: 	//! Adds a call to a table function with the given alias to the BindContext.
79: 	void AddTableFunction(idx_t index, const string &alias, const vector<string> &names,
80: 	                      const vector<LogicalType> &types, LogicalGet &get);
81: 	//! Adds a subquery with a given alias to the BindContext.
82: 	void AddSubquery(idx_t index, const string &alias, SubqueryRef &ref, BoundQueryNode &subquery);
83: 	//! Adds a base table with the given alias to the BindContext.
84: 	void AddGenericBinding(idx_t index, const string &alias, const vector<string> &names,
85: 	                       const vector<LogicalType> &types);
86: 
87: 	//! Adds a base table with the given alias to the CTE BindContext.
88: 	//! We need this to correctly bind recursive CTEs with multiple references.
89: 	void AddCTEBinding(idx_t index, const string &alias, const vector<string> &names, const vector<LogicalType> &types);
90: 
91: 	//! Add an implicit join condition (e.g. USING (x))
92: 	void AddUsingBinding(const string &column_name, UsingColumnSet *set);
93: 
94: 	void AddUsingBindingSet(unique_ptr<UsingColumnSet> set);
95: 
96: 	//! Returns any using column set for the given column name, or nullptr if there is none. On conflict (multiple using
97: 	//! column sets with the same name) throw an exception.
98: 	UsingColumnSet *GetUsingBinding(const string &column_name);
99: 	//! Returns any using column set for the given column name, or nullptr if there is none
100: 	UsingColumnSet *GetUsingBinding(const string &column_name, const string &binding_name);
101: 	//! Erase a using binding from the set of using bindings
102: 	void RemoveUsingBinding(const string &column_name, UsingColumnSet *set);
103: 	//! Finds the using bindings for a given column. Returns true if any exists, false otherwise.
104: 	bool FindUsingBinding(const string &column_name, unordered_set<UsingColumnSet *> **using_columns);
105: 	//! Transfer a using binding from one bind context to this bind context
106: 	void TransferUsingBinding(BindContext &current_context, UsingColumnSet *current_set, UsingColumnSet *new_set,
107: 	                          const string &binding, const string &using_column);
108: 
109: 	//! Fetch the actual column name from the given binding, or throws if none exists
110: 	//! This can be different from "column_name" because of case insensitivity
111: 	//! (e.g. "column_name" might return "COLUMN_NAME")
112: 	string GetActualColumnName(const string &binding, const string &column_name);
113: 
114: 	case_insensitive_map_t<std::shared_ptr<Binding>> GetCTEBindings() {
115: 		return cte_bindings;
116: 	}
117: 	void SetCTEBindings(case_insensitive_map_t<std::shared_ptr<Binding>> bindings) {
118: 		cte_bindings = bindings;
119: 	}
120: 
121: 	//! Alias a set of column names for the specified table, using the original names if there are not enough aliases
122: 	//! specified.
123: 	static vector<string> AliasColumnNames(const string &table_name, const vector<string> &names,
124: 	                                       const vector<string> &column_aliases);
125: 
126: 	//! Add all the bindings from a BindContext to this BindContext. The other BindContext is destroyed in the process.
127: 	void AddContext(BindContext other);
128: 
129: private:
130: 	void AddBinding(const string &alias, unique_ptr<Binding> binding);
131: 	//! Gets a binding of the specified name. Returns a nullptr and sets the out_error if the binding could not be
132: 	//! found.
133: 	Binding *GetBinding(const string &name, string &out_error);
134: 
135: private:
136: 	//! The set of bindings
137: 	case_insensitive_map_t<unique_ptr<Binding>> bindings;
138: 	//! The list of bindings in insertion order
139: 	vector<std::pair<string, Binding *>> bindings_list;
140: 	//! The set of columns used in USING join conditions
141: 	case_insensitive_map_t<unordered_set<UsingColumnSet *>> using_columns;
142: 	//! Using column sets
143: 	vector<unique_ptr<UsingColumnSet>> using_column_sets;
144: 
145: 	//! The set of CTE bindings
146: 	case_insensitive_map_t<std::shared_ptr<Binding>> cte_bindings;
147: };
148: } // namespace duckdb
[end of src/include/duckdb/planner/bind_context.hpp]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/parser/column_definition.hpp"
13: #include "duckdb/parser/tokens.hpp"
14: #include "duckdb/planner/bind_context.hpp"
15: #include "duckdb/planner/bound_tokens.hpp"
16: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
17: #include "duckdb/planner/logical_operator.hpp"
18: #include "duckdb/planner/bound_statement.hpp"
19: #include "duckdb/common/case_insensitive_map.hpp"
20: 
21: namespace duckdb {
22: class BoundResultModifier;
23: class BoundSelectNode;
24: class ClientContext;
25: class ExpressionBinder;
26: class LimitModifier;
27: class OrderBinder;
28: class TableCatalogEntry;
29: class ViewCatalogEntry;
30: 
31: struct CreateInfo;
32: struct BoundCreateTableInfo;
33: struct BoundCreateFunctionInfo;
34: struct CommonTableExpressionInfo;
35: 
36: struct CorrelatedColumnInfo {
37: 	ColumnBinding binding;
38: 	LogicalType type;
39: 	string name;
40: 	idx_t depth;
41: 
42: 	explicit CorrelatedColumnInfo(BoundColumnRefExpression &expr)
43: 	    : binding(expr.binding), type(expr.return_type), name(expr.GetName()), depth(expr.depth) {
44: 	}
45: 
46: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
47: 		return binding == rhs.binding;
48: 	}
49: };
50: 
51: //! Bind the parsed query tree to the actual columns present in the catalog.
52: /*!
53:   The binder is responsible for binding tables and columns to actual physical
54:   tables and columns in the catalog. In the process, it also resolves types of
55:   all expressions.
56: */
57: class Binder : public std::enable_shared_from_this<Binder> {
58: 	friend class ExpressionBinder;
59: 	friend class SelectBinder;
60: 	friend class RecursiveSubqueryPlanner;
61: 
62: public:
63: 	static shared_ptr<Binder> CreateBinder(ClientContext &context, Binder *parent = nullptr, bool inherit_ctes = true);
64: 
65: 	//! The client context
66: 	ClientContext &context;
67: 	//! A mapping of names to common table expressions
68: 	case_insensitive_map_t<CommonTableExpressionInfo *> CTE_bindings;
69: 	//! The CTEs that have already been bound
70: 	unordered_set<CommonTableExpressionInfo *> bound_ctes;
71: 	//! The bind context
72: 	BindContext bind_context;
73: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
74: 	//! vector)
75: 	vector<CorrelatedColumnInfo> correlated_columns;
76: 	//! The set of parameter expressions bound by this binder
77: 	vector<BoundParameterExpression *> *parameters;
78: 	//! Whether or not the bound statement is read-only
79: 	bool read_only;
80: 	//! Whether or not the statement requires a valid transaction to run
81: 	bool requires_valid_transaction;
82: 	//! Whether or not the statement can be streamed to the client
83: 	bool allow_stream_result;
84: 	//! The alias for the currently processing subquery, if it exists
85: 	string alias;
86: 	//! Macro parameter bindings (if any)
87: 	MacroBinding *macro_binding = nullptr;
88: 
89: public:
90: 	BoundStatement Bind(SQLStatement &statement);
91: 	BoundStatement Bind(QueryNode &node);
92: 
93: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
94: 	void BindCreateViewInfo(CreateViewInfo &base);
95: 	SchemaCatalogEntry *BindSchema(CreateInfo &info);
96: 	SchemaCatalogEntry *BindCreateFunctionInfo(CreateInfo &info);
97: 
98: 	//! Check usage, and cast named parameters to their types
99: 	static void BindNamedParameters(unordered_map<string, LogicalType> &types, unordered_map<string, Value> &values,
100: 	                                QueryErrorContext &error_context, string &func_name);
101: 
102: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
103: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
104: 
105: 	//! Generates an unused index for a table
106: 	idx_t GenerateTableIndex();
107: 
108: 	//! Add a common table expression to the binder
109: 	void AddCTE(const string &name, CommonTableExpressionInfo *cte);
110: 	//! Find a common table expression by name; returns nullptr if none exists
111: 	CommonTableExpressionInfo *FindCTE(const string &name, bool skip = false);
112: 
113: 	bool CTEIsAlreadyBound(CommonTableExpressionInfo *cte);
114: 
115: 	void PushExpressionBinder(ExpressionBinder *binder);
116: 	void PopExpressionBinder();
117: 	void SetActiveBinder(ExpressionBinder *binder);
118: 	ExpressionBinder *GetActiveBinder();
119: 	bool HasActiveBinder();
120: 
121: 	vector<ExpressionBinder *> &GetActiveBinders();
122: 
123: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
124: 	//! Add a correlated column to this binder (if it does not exist)
125: 	void AddCorrelatedColumn(const CorrelatedColumnInfo &info);
126: 
127: 	string FormatError(ParsedExpression &expr_context, const string &message);
128: 	string FormatError(TableRef &ref_context, const string &message);
129: 
130: 	string FormatErrorRecursive(idx_t query_location, const string &message, vector<ExceptionFormatValue> &values);
131: 	template <class T, typename... Args>
132: 	string FormatErrorRecursive(idx_t query_location, const string &msg, vector<ExceptionFormatValue> &values, T param,
133: 	                            Args... params) {
134: 		values.push_back(ExceptionFormatValue::CreateFormatValue<T>(param));
135: 		return FormatErrorRecursive(query_location, msg, values, params...);
136: 	}
137: 
138: 	template <typename... Args>
139: 	string FormatError(idx_t query_location, const string &msg, Args... params) {
140: 		vector<ExceptionFormatValue> values;
141: 		return FormatErrorRecursive(query_location, msg, values, params...);
142: 	}
143: 
144: 	static void BindLogicalType(ClientContext &context, LogicalType &type, const string &schema = "");
145: 
146: private:
147: 	//! The parent binder (if any)
148: 	shared_ptr<Binder> parent;
149: 	//! The vector of active binders
150: 	vector<ExpressionBinder *> active_binders;
151: 	//! The count of bound_tables
152: 	idx_t bound_tables;
153: 	//! Whether or not the binder has any unplanned subqueries that still need to be planned
154: 	bool has_unplanned_subqueries = false;
155: 	//! Whether or not subqueries should be planned already
156: 	bool plan_subquery = true;
157: 	//! Whether CTEs should reference the parent binder (if it exists)
158: 	bool inherit_ctes = true;
159: 	//! Whether or not the binder can contain NULLs as the root of expressions
160: 	bool can_contain_nulls = false;
161: 	//! The root statement of the query that is currently being parsed
162: 	SQLStatement *root_statement = nullptr;
163: 
164: private:
165: 	//! Bind the default values of the columns of a table
166: 	void BindDefaultValues(vector<ColumnDefinition> &columns, vector<unique_ptr<Expression>> &bound_defaults);
167: 	//! Bind a delimiter value (LIMIT or OFFSET)
168: 	unique_ptr<Expression> BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,
169: 	                                     int64_t &delimiter_value);
170: 
171: 	//! Move correlated expressions from the child binder to this binder
172: 	void MoveCorrelatedExpressions(Binder &other);
173: 
174: 	BoundStatement Bind(SelectStatement &stmt);
175: 	BoundStatement Bind(InsertStatement &stmt);
176: 	BoundStatement Bind(CopyStatement &stmt);
177: 	BoundStatement Bind(DeleteStatement &stmt);
178: 	BoundStatement Bind(UpdateStatement &stmt);
179: 	BoundStatement Bind(CreateStatement &stmt);
180: 	BoundStatement Bind(DropStatement &stmt);
181: 	BoundStatement Bind(AlterStatement &stmt);
182: 	BoundStatement Bind(TransactionStatement &stmt);
183: 	BoundStatement Bind(PragmaStatement &stmt);
184: 	BoundStatement Bind(ExplainStatement &stmt);
185: 	BoundStatement Bind(VacuumStatement &stmt);
186: 	BoundStatement Bind(RelationStatement &stmt);
187: 	BoundStatement Bind(ShowStatement &stmt);
188: 	BoundStatement Bind(CallStatement &stmt);
189: 	BoundStatement Bind(ExportStatement &stmt);
190: 	BoundStatement Bind(SetStatement &stmt);
191: 	BoundStatement Bind(LoadStatement &stmt);
192: 
193: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
194: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
195: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
196: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
197: 
198: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
199: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
200: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
201: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
202: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
203: 
204: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
205: 	unique_ptr<BoundTableRef> Bind(CrossProductRef &ref);
206: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
207: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte = nullptr);
208: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
209: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
210: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
211: 
212: 	bool BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
213: 	                            vector<Value> &parameters, unordered_map<string, Value> &named_parameters,
214: 	                            unique_ptr<BoundSubqueryRef> &subquery, string &error);
215: 
216: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
217: 	unique_ptr<LogicalOperator> CreatePlan(BoundCrossProductRef &ref);
218: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
219: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
220: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
221: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
222: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
223: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
224: 
225: 	unique_ptr<LogicalOperator> BindTable(TableCatalogEntry &table, BaseTableRef &ref);
226: 	unique_ptr<LogicalOperator> BindView(ViewCatalogEntry &view, BaseTableRef &ref);
227: 	unique_ptr<LogicalOperator> BindTableOrView(BaseTableRef &ref);
228: 
229: 	BoundStatement BindCopyTo(CopyStatement &stmt);
230: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
231: 
232: 	void BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
233: 	void BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index);
234: 
235: 	BoundStatement BindSummarize(ShowStatement &stmt);
236: 	unique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);
237: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
238: 
239: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
240: 
241: 	void PlanSubqueries(unique_ptr<Expression> *expr, unique_ptr<LogicalOperator> *root);
242: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
243: 
244: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,
245: 	                                                       vector<LogicalType> &target_types,
246: 	                                                       unique_ptr<LogicalOperator> op);
247: 
248: 	string FindBinding(const string &using_column, const string &join_side);
249: 	bool TryFindBinding(const string &using_column, const string &join_side, string &result);
250: 
251: 	void AddUsingBindingSet(unique_ptr<UsingColumnSet> set);
252: 	string RetrieveUsingBinding(Binder &current_binder, UsingColumnSet *current_set, const string &column_name,
253: 	                            const string &join_side, UsingColumnSet *new_set);
254: 
255: public:
256: 	// This should really be a private constructor, but make_shared does not allow it...
257: 	// If you are thinking about calling this, you should probably call Binder::CreateBinder
258: 	Binder(bool I_know_what_I_am_doing, ClientContext &context, shared_ptr<Binder> parent, bool inherit_ctes);
259: };
260: 
261: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/include/duckdb/planner/expression_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/exception.hpp"
12: #include "duckdb/parser/expression/bound_expression.hpp"
13: #include "duckdb/parser/parsed_expression.hpp"
14: #include "duckdb/parser/tokens.hpp"
15: #include "duckdb/planner/expression.hpp"
16: #include "duckdb/common/unordered_map.hpp"
17: 
18: namespace duckdb {
19: 
20: class Binder;
21: class ClientContext;
22: class QueryNode;
23: 
24: class ScalarFunctionCatalogEntry;
25: class AggregateFunctionCatalogEntry;
26: class MacroCatalogEntry;
27: class CatalogEntry;
28: class SimpleFunction;
29: 
30: struct MacroBinding;
31: 
32: struct BoundColumnReferenceInfo {
33: 	string name;
34: 	idx_t query_location;
35: };
36: 
37: struct BindResult {
38: 	explicit BindResult(string error) : error(error) {
39: 	}
40: 	explicit BindResult(unique_ptr<Expression> expr) : expression(move(expr)) {
41: 	}
42: 
43: 	bool HasError() {
44: 		return !error.empty();
45: 	}
46: 
47: 	unique_ptr<Expression> expression;
48: 	string error;
49: };
50: 
51: class ExpressionBinder {
52: public:
53: 	ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder = false);
54: 	virtual ~ExpressionBinder();
55: 
56: 	//! The target type that should result from the binder. If the result is not of this type, a cast to this type will
57: 	//! be added. Defaults to INVALID.
58: 	LogicalType target_type;
59: 
60: public:
61: 	unique_ptr<Expression> Bind(unique_ptr<ParsedExpression> &expr, LogicalType *result_type = nullptr,
62: 	                            bool root_expression = true);
63: 
64: 	//! Returns whether or not any columns have been bound by the expression binder
65: 	bool HasBoundColumns() {
66: 		return !bound_columns.empty();
67: 	}
68: 	const vector<BoundColumnReferenceInfo> &GetBoundColumns() {
69: 		return bound_columns;
70: 	}
71: 
72: 	string Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression = false);
73: 
74: 	// Bind table names to ColumnRefExpressions
75: 	static void BindTableNames(Binder &binder, ParsedExpression &expr,
76: 	                           unordered_map<string, idx_t> *alias_map = nullptr);
77: 	static unique_ptr<Expression> PushCollation(ClientContext &context, unique_ptr<Expression> source,
78: 	                                            const string &collation, bool equality_only = false);
79: 	static void TestCollation(ClientContext &context, const string &collation);
80: 
81: 	bool BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr);
82: 
83: 	void BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, string &error);
84: 	static void ExtractCorrelatedExpressions(Binder &binder, Expression &expr);
85: 
86: 	static bool ContainsNullType(const LogicalType &type);
87: 	static LogicalType ExchangeNullType(const LogicalType &type);
88: 	static bool ContainsType(const LogicalType &type, LogicalTypeId target);
89: 	static LogicalType ExchangeType(const LogicalType &type, LogicalTypeId target, LogicalType new_type);
90: 
91: 	static void ResolveParameterType(LogicalType &type);
92: 	static void ResolveParameterType(unique_ptr<Expression> &expr);
93: 
94: 	//! Bind the given expresion. Unlike Bind(), this does *not* mute the given ParsedExpression.
95: 	//! Exposed to be used from sub-binders that aren't subclasses of ExpressionBinder.
96: 	virtual BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,
97: 	                                  bool root_expression = false);
98: 
99: protected:
100: 	BindResult BindExpression(BetweenExpression &expr, idx_t depth);
101: 	BindResult BindExpression(CaseExpression &expr, idx_t depth);
102: 	BindResult BindExpression(CollateExpression &expr, idx_t depth);
103: 	BindResult BindExpression(CastExpression &expr, idx_t depth);
104: 	BindResult BindExpression(ColumnRefExpression &expr, idx_t depth);
105: 	BindResult BindExpression(ComparisonExpression &expr, idx_t depth);
106: 	BindResult BindExpression(ConjunctionExpression &expr, idx_t depth);
107: 	BindResult BindExpression(ConstantExpression &expr, idx_t depth);
108: 	BindResult BindExpression(FunctionExpression &expr, idx_t depth, unique_ptr<ParsedExpression> *expr_ptr);
109: 	BindResult BindExpression(LambdaExpression &expr, idx_t depth);
110: 	BindResult BindExpression(OperatorExpression &expr, idx_t depth);
111: 	BindResult BindExpression(ParameterExpression &expr, idx_t depth);
112: 	BindResult BindExpression(PositionalReferenceExpression &ref, idx_t depth);
113: 	BindResult BindExpression(StarExpression &expr, idx_t depth);
114: 	BindResult BindExpression(SubqueryExpression &expr, idx_t depth);
115: 
116: protected:
117: 	virtual BindResult BindGroupingFunction(OperatorExpression &op, idx_t depth);
118: 	virtual BindResult BindFunction(FunctionExpression &expr, ScalarFunctionCatalogEntry *function, idx_t depth);
119: 	virtual BindResult BindAggregate(FunctionExpression &expr, AggregateFunctionCatalogEntry *function, idx_t depth);
120: 	virtual BindResult BindUnnest(FunctionExpression &expr, idx_t depth);
121: 	virtual BindResult BindMacro(FunctionExpression &expr, MacroCatalogEntry *macro, idx_t depth,
122: 	                             unique_ptr<ParsedExpression> *expr_ptr);
123: 
124: 	virtual void ReplaceMacroParametersRecursive(unique_ptr<ParsedExpression> &expr);
125: 	virtual void ReplaceMacroParametersRecursive(ParsedExpression &expr, QueryNode &node);
126: 	virtual void ReplaceMacroParametersRecursive(ParsedExpression &expr, TableRef &ref);
127: 
128: 	virtual string UnsupportedAggregateMessage();
129: 	virtual string UnsupportedUnnestMessage();
130: 
131: 	Binder &binder;
132: 	ClientContext &context;
133: 	ExpressionBinder *stored_binder;
134: 	MacroBinding *macro_binding;
135: 	vector<BoundColumnReferenceInfo> bound_columns;
136: };
137: 
138: } // namespace duckdb
[end of src/include/duckdb/planner/expression_binder.hpp]
[start of src/include/duckdb/planner/operator/logical_get.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/operator/logical_get.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/planner/logical_operator.hpp"
12: #include "duckdb/function/table_function.hpp"
13: #include "duckdb/planner/table_filter.hpp"
14: 
15: namespace duckdb {
16: 
17: //! LogicalGet represents a scan operation from a data source
18: class LogicalGet : public LogicalOperator {
19: public:
20: 	LogicalGet(idx_t table_index, TableFunction function, unique_ptr<FunctionData> bind_data,
21: 	           vector<LogicalType> returned_types, vector<string> returned_names);
22: 
23: 	//! The table index in the current bind context
24: 	idx_t table_index;
25: 	//! The function that is called
26: 	TableFunction function;
27: 	//! The bind data of the function
28: 	unique_ptr<FunctionData> bind_data;
29: 	//! The types of ALL columns that can be returned by the table function
30: 	vector<LogicalType> returned_types;
31: 	//! The names of ALL columns that can be returned by the table function
32: 	vector<string> names;
33: 	//! Bound column IDs
34: 	vector<column_t> column_ids;
35: 	//! Filters pushed down for table scan
36: 	TableFilterSet table_filters;
37: 
38: 	string GetName() const override;
39: 	string ParamsToString() const override;
40: 
41: public:
42: 	vector<ColumnBinding> GetColumnBindings() override;
43: 
44: 	idx_t EstimateCardinality(ClientContext &context) override;
45: 
46: protected:
47: 	void ResolveTypes() override;
48: };
49: } // namespace duckdb
[end of src/include/duckdb/planner/operator/logical_get.hpp]
[start of src/include/duckdb/planner/table_binding.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/table_binding.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/case_insensitive_map.hpp"
13: #include "duckdb/parser/column_definition.hpp"
14: #include "duckdb/parser/parsed_expression.hpp"
15: #include "duckdb/planner/expression_binder.hpp"
16: 
17: namespace duckdb {
18: class BindContext;
19: class BoundQueryNode;
20: class ColumnRefExpression;
21: class SubqueryRef;
22: class LogicalGet;
23: class TableCatalogEntry;
24: class TableFunctionCatalogEntry;
25: class BoundTableFunction;
26: 
27: //! A Binding represents a binding to a table, table-producing function or subquery with a specified table index.
28: struct Binding {
29: 	Binding(const string &alias, vector<LogicalType> types, vector<string> names, idx_t index);
30: 	virtual ~Binding() = default;
31: 
32: 	//! The alias of the binding
33: 	string alias;
34: 	//! The table index of the binding
35: 	idx_t index;
36: 	vector<LogicalType> types;
37: 	//! Column names of the subquery
38: 	vector<string> names;
39: 	//! Name -> index for the names
40: 	case_insensitive_map_t<column_t> name_map;
41: 
42: public:
43: 	bool TryGetBindingIndex(const string &column_name, column_t &column_index);
44: 	bool HasMatchingBinding(const string &column_name);
45: 	virtual BindResult Bind(ColumnRefExpression &colref, idx_t depth);
46: };
47: 
48: //! TableBinding is exactly like the Binding, except it keeps track of which columns were bound in the linked LogicalGet
49: //! node for projection pushdown purposes.
50: struct TableBinding : public Binding {
51: 	TableBinding(const string &alias, vector<LogicalType> types, vector<string> names, LogicalGet &get, idx_t index,
52: 	             bool add_row_id = false);
53: 
54: 	//! the underlying LogicalGet
55: 	LogicalGet &get;
56: 
57: public:
58: 	BindResult Bind(ColumnRefExpression &colref, idx_t depth) override;
59: };
60: 
61: //! MacroBinding is like the Binding, except the alias and index are set by default. Used for binding Macro
62: //! Params/Arguments.
63: struct MacroBinding : public Binding {
64: 	MacroBinding(vector<LogicalType> types_p, vector<string> names_p, string macro_name);
65: 
66: 	//! Arguments
67: 	vector<unique_ptr<ParsedExpression>> arguments;
68: 	//! The name of the macro
69: 	string macro_name;
70: 
71: public:
72: 	BindResult Bind(ColumnRefExpression &colref, idx_t depth) override;
73: 
74: 	//! Given the parameter colref, returns a copy of the argument that was supplied for this parameter
75: 	unique_ptr<ParsedExpression> ParamToArg(ColumnRefExpression &colref);
76: };
77: 
78: } // namespace duckdb
[end of src/include/duckdb/planner/table_binding.hpp]
[start of src/main/relation.cpp]
1: #include "duckdb/main/relation.hpp"
2: #include "duckdb/common/printer.hpp"
3: #include "duckdb/parser/parser.hpp"
4: #include "duckdb/main/relation/aggregate_relation.hpp"
5: #include "duckdb/main/relation/distinct_relation.hpp"
6: #include "duckdb/main/relation/explain_relation.hpp"
7: #include "duckdb/main/relation/filter_relation.hpp"
8: #include "duckdb/main/relation/insert_relation.hpp"
9: #include "duckdb/main/relation/limit_relation.hpp"
10: #include "duckdb/main/relation/order_relation.hpp"
11: #include "duckdb/main/relation/projection_relation.hpp"
12: #include "duckdb/main/relation/setop_relation.hpp"
13: #include "duckdb/main/relation/subquery_relation.hpp"
14: #include "duckdb/main/relation/table_function_relation.hpp"
15: #include "duckdb/main/relation/create_table_relation.hpp"
16: #include "duckdb/main/relation/create_view_relation.hpp"
17: #include "duckdb/main/relation/write_csv_relation.hpp"
18: #include "duckdb/main/client_context.hpp"
19: #include "duckdb/planner/binder.hpp"
20: #include "duckdb/parser/tableref/subqueryref.hpp"
21: #include "duckdb/parser/statement/select_statement.hpp"
22: #include "duckdb/parser/expression/conjunction_expression.hpp"
23: #include "duckdb/parser/expression/columnref_expression.hpp"
24: #include "duckdb/main/relation/join_relation.hpp"
25: #include "duckdb/main/relation/value_relation.hpp"
26: 
27: namespace duckdb {
28: 
29: shared_ptr<Relation> Relation::Project(const string &select_list) {
30: 	return Project(select_list, vector<string>());
31: }
32: 
33: shared_ptr<Relation> Relation::Project(const string &expression, const string &alias) {
34: 	return Project(expression, vector<string>({alias}));
35: }
36: 
37: shared_ptr<Relation> Relation::Project(const string &select_list, const vector<string> &aliases) {
38: 	auto expressions = Parser::ParseExpressionList(select_list);
39: 	return make_shared<ProjectionRelation>(shared_from_this(), move(expressions), aliases);
40: }
41: 
42: shared_ptr<Relation> Relation::Project(const vector<string> &expressions) {
43: 	vector<string> aliases;
44: 	return Project(expressions, aliases);
45: }
46: 
47: static vector<unique_ptr<ParsedExpression>> StringListToExpressionList(const vector<string> &expressions) {
48: 	if (expressions.empty()) {
49: 		throw ParserException("Zero expressions provided");
50: 	}
51: 	vector<unique_ptr<ParsedExpression>> result_list;
52: 	for (auto &expr : expressions) {
53: 		auto expression_list = Parser::ParseExpressionList(expr);
54: 		if (expression_list.size() != 1) {
55: 			throw ParserException("Expected a single expression in the expression list");
56: 		}
57: 		result_list.push_back(move(expression_list[0]));
58: 	}
59: 	return result_list;
60: }
61: 
62: shared_ptr<Relation> Relation::Project(const vector<string> &expressions, const vector<string> &aliases) {
63: 	auto result_list = StringListToExpressionList(expressions);
64: 	return make_shared<ProjectionRelation>(shared_from_this(), move(result_list), aliases);
65: }
66: 
67: shared_ptr<Relation> Relation::Filter(const string &expression) {
68: 	auto expression_list = Parser::ParseExpressionList(expression);
69: 	if (expression_list.size() != 1) {
70: 		throw ParserException("Expected a single expression as filter condition");
71: 	}
72: 	return make_shared<FilterRelation>(shared_from_this(), move(expression_list[0]));
73: }
74: 
75: shared_ptr<Relation> Relation::Filter(const vector<string> &expressions) {
76: 	// if there are multiple expressions, we AND them together
77: 	auto expression_list = StringListToExpressionList(expressions);
78: 	D_ASSERT(!expression_list.empty());
79: 
80: 	auto expr = move(expression_list[0]);
81: 	for (idx_t i = 1; i < expression_list.size(); i++) {
82: 		expr =
83: 		    make_unique<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, move(expr), move(expression_list[i]));
84: 	}
85: 	return make_shared<FilterRelation>(shared_from_this(), move(expr));
86: }
87: 
88: shared_ptr<Relation> Relation::Limit(int64_t limit, int64_t offset) {
89: 	return make_shared<LimitRelation>(shared_from_this(), limit, offset);
90: }
91: 
92: shared_ptr<Relation> Relation::Order(const string &expression) {
93: 	auto order_list = Parser::ParseOrderList(expression);
94: 	return make_shared<OrderRelation>(shared_from_this(), move(order_list));
95: }
96: 
97: shared_ptr<Relation> Relation::Order(const vector<string> &expressions) {
98: 	if (expressions.empty()) {
99: 		throw ParserException("Zero ORDER BY expressions provided");
100: 	}
101: 	vector<OrderByNode> order_list;
102: 	for (auto &expression : expressions) {
103: 		auto inner_list = Parser::ParseOrderList(expression);
104: 		if (inner_list.size() != 1) {
105: 			throw ParserException("Expected a single ORDER BY expression in the expression list");
106: 		}
107: 		order_list.push_back(move(inner_list[0]));
108: 	}
109: 	return make_shared<OrderRelation>(shared_from_this(), move(order_list));
110: }
111: 
112: shared_ptr<Relation> Relation::Join(const shared_ptr<Relation> &other, const string &condition, JoinType type) {
113: 	auto expression_list = Parser::ParseExpressionList(condition);
114: 	D_ASSERT(!expression_list.empty());
115: 
116: 	if (expression_list.size() > 1 || expression_list[0]->type == ExpressionType::COLUMN_REF) {
117: 		// multiple columns or single column ref: the condition is a USING list
118: 		vector<string> using_columns;
119: 		for (auto &expr : expression_list) {
120: 			if (expr->type != ExpressionType::COLUMN_REF) {
121: 				throw ParserException("Expected a single expression as join condition");
122: 			}
123: 			auto &colref = (ColumnRefExpression &)*expr;
124: 			if (!colref.table_name.empty()) {
125: 				throw ParserException("Expected empty table name for column in USING clause");
126: 			}
127: 			using_columns.push_back(colref.column_name);
128: 		}
129: 		return make_shared<JoinRelation>(shared_from_this(), other, move(using_columns), type);
130: 	} else {
131: 		// single expression that is not a column reference: use the expression as a join condition
132: 		return make_shared<JoinRelation>(shared_from_this(), other, move(expression_list[0]), type);
133: 	}
134: }
135: 
136: shared_ptr<Relation> Relation::Union(const shared_ptr<Relation> &other) {
137: 	return make_shared<SetOpRelation>(shared_from_this(), other, SetOperationType::UNION);
138: }
139: 
140: shared_ptr<Relation> Relation::Except(const shared_ptr<Relation> &other) {
141: 	return make_shared<SetOpRelation>(shared_from_this(), other, SetOperationType::EXCEPT);
142: }
143: 
144: shared_ptr<Relation> Relation::Intersect(const shared_ptr<Relation> &other) {
145: 	return make_shared<SetOpRelation>(shared_from_this(), other, SetOperationType::INTERSECT);
146: }
147: 
148: shared_ptr<Relation> Relation::Distinct() {
149: 	return make_shared<DistinctRelation>(shared_from_this());
150: }
151: 
152: shared_ptr<Relation> Relation::Alias(const string &alias) {
153: 	return make_shared<SubqueryRelation>(shared_from_this(), alias);
154: }
155: 
156: shared_ptr<Relation> Relation::Aggregate(const string &aggregate_list) {
157: 	auto expression_list = Parser::ParseExpressionList(aggregate_list);
158: 	return make_shared<AggregateRelation>(shared_from_this(), move(expression_list));
159: }
160: 
161: shared_ptr<Relation> Relation::Aggregate(const string &aggregate_list, const string &group_list) {
162: 	auto expression_list = Parser::ParseExpressionList(aggregate_list);
163: 	auto groups = Parser::ParseExpressionList(group_list);
164: 	return make_shared<AggregateRelation>(shared_from_this(), move(expression_list), move(groups));
165: }
166: 
167: shared_ptr<Relation> Relation::Aggregate(const vector<string> &aggregates) {
168: 	auto aggregate_list = StringListToExpressionList(aggregates);
169: 	return make_shared<AggregateRelation>(shared_from_this(), move(aggregate_list));
170: }
171: 
172: shared_ptr<Relation> Relation::Aggregate(const vector<string> &aggregates, const vector<string> &groups) {
173: 	auto aggregate_list = StringListToExpressionList(aggregates);
174: 	auto group_list = StringListToExpressionList(groups);
175: 	return make_shared<AggregateRelation>(shared_from_this(), move(aggregate_list), move(group_list));
176: }
177: 
178: string Relation::GetAlias() {
179: 	return "relation";
180: }
181: 
182: unique_ptr<TableRef> Relation::GetTableRef() {
183: 	auto select = make_unique<SelectStatement>();
184: 	select->node = GetQueryNode();
185: 	return make_unique<SubqueryRef>(move(select), GetAlias());
186: }
187: 
188: unique_ptr<QueryResult> Relation::Execute() {
189: 	return context.Execute(shared_from_this());
190: }
191: 
192: BoundStatement Relation::Bind(Binder &binder) {
193: 	SelectStatement stmt;
194: 	stmt.node = GetQueryNode();
195: 	return binder.Bind((SQLStatement &)stmt);
196: }
197: 
198: void Relation::Insert(const string &table_name) {
199: 	Insert(DEFAULT_SCHEMA, table_name);
200: }
201: 
202: void Relation::Insert(const string &schema_name, const string &table_name) {
203: 	auto insert = make_shared<InsertRelation>(shared_from_this(), schema_name, table_name);
204: 	auto res = insert->Execute();
205: 	if (!res->success) {
206: 		throw Exception("Failed to insert into table '" + table_name + "': " + res->error);
207: 	}
208: }
209: 
210: void Relation::Insert(const vector<vector<Value>> &values) {
211: 	vector<string> column_names;
212: 	auto rel = make_shared<ValueRelation>(context, values, move(column_names), "values");
213: 	rel->Insert(GetAlias());
214: }
215: 
216: void Relation::Create(const string &table_name) {
217: 	Create(DEFAULT_SCHEMA, table_name);
218: }
219: 
220: void Relation::Create(const string &schema_name, const string &table_name) {
221: 	auto create = make_shared<CreateTableRelation>(shared_from_this(), schema_name, table_name);
222: 	auto res = create->Execute();
223: 	if (!res->success) {
224: 		throw Exception("Failed to create table '" + table_name + "': " + res->error);
225: 	}
226: }
227: 
228: void Relation::WriteCSV(const string &csv_file) {
229: 	auto write_csv = make_shared<WriteCSVRelation>(shared_from_this(), csv_file);
230: 	auto res = write_csv->Execute();
231: 	if (!res->success) {
232: 		throw Exception("Failed to write '" + csv_file + "': " + res->error);
233: 	}
234: }
235: 
236: shared_ptr<Relation> Relation::CreateView(const string &name, bool replace, bool temporary) {
237: 	auto view = make_shared<CreateViewRelation>(shared_from_this(), name, replace, temporary);
238: 	auto res = view->Execute();
239: 	if (!res->success) {
240: 		throw Exception("Failed to create view '" + name + "': " + res->error);
241: 	}
242: 	return shared_from_this();
243: }
244: 
245: unique_ptr<QueryResult> Relation::Query(const string &sql) {
246: 	return context.Query(sql, false);
247: }
248: 
249: unique_ptr<QueryResult> Relation::Query(const string &name, const string &sql) {
250: 	CreateView(name);
251: 	return Query(sql);
252: }
253: 
254: unique_ptr<QueryResult> Relation::Explain() {
255: 	auto explain = make_shared<ExplainRelation>(shared_from_this());
256: 	return explain->Execute();
257: }
258: 
259: void Relation::Update(const string &update, const string &condition) {
260: 	throw Exception("UPDATE can only be used on base tables!");
261: }
262: 
263: void Relation::Delete(const string &condition) {
264: 	throw Exception("DELETE can only be used on base tables!");
265: }
266: 
267: shared_ptr<Relation> Relation::TableFunction(const std::string &fname, const vector<Value> &values,
268:                                              const unordered_map<string, Value> &named_parameters) {
269: 	return make_shared<TableFunctionRelation>(context, fname, values, named_parameters, shared_from_this());
270: }
271: 
272: shared_ptr<Relation> Relation::TableFunction(const std::string &fname, const vector<Value> &values) {
273: 	return make_shared<TableFunctionRelation>(context, fname, values, shared_from_this());
274: }
275: 
276: string Relation::ToString() {
277: 	string str;
278: 	str += "---------------------\n";
279: 	str += "-- Expression Tree --\n";
280: 	str += "---------------------\n";
281: 	str += ToString(0);
282: 	str += "\n\n";
283: 	str += "---------------------\n";
284: 	str += "-- Result Columns  --\n";
285: 	str += "---------------------\n";
286: 	auto &cols = Columns();
287: 	for (idx_t i = 0; i < cols.size(); i++) {
288: 		str += "- " + cols[i].name + " (" + cols[i].type.ToString() + ")\n";
289: 	}
290: 	return str;
291: }
292: 
293: // LCOV_EXCL_START
294: unique_ptr<QueryNode> Relation::GetQueryNode() {
295: 	throw InternalException("Cannot create a query node from this node type");
296: }
297: 
298: void Relation::Head(idx_t limit) {
299: 	auto limit_node = Limit(limit);
300: 	limit_node->Execute()->Print();
301: }
302: // LCOV_EXCL_STOP
303: 
304: void Relation::Print() {
305: 	Printer::Print(ToString());
306: }
307: 
308: string Relation::RenderWhitespace(idx_t depth) {
309: 	return string(depth * 2, ' ');
310: }
311: 
312: } // namespace duckdb
[end of src/main/relation.cpp]
[start of src/optimizer/statistics/operator/propagate_projection.cpp]
1: #include "duckdb/optimizer/statistics_propagator.hpp"
2: #include "duckdb/planner/operator/logical_projection.hpp"
3: 
4: namespace duckdb {
5: 
6: unique_ptr<NodeStatistics> StatisticsPropagator::PropagateStatistics(LogicalProjection &proj,
7:                                                                      unique_ptr<LogicalOperator> *node_ptr) {
8: 	// first propagate to the child
9: 	node_stats = PropagateStatistics(proj.children[0]);
10: 
11: 	// then propagate to each of the expressions
12: 	for (idx_t i = 0; i < proj.expressions.size(); i++) {
13: 		auto stats = PropagateExpression(proj.expressions[i]);
14: 		if (stats) {
15: 			ColumnBinding binding(proj.table_index, i);
16: 			statistics_map.insert(make_pair(binding, move(stats)));
17: 		}
18: 	}
19: 	return move(node_stats);
20: }
21: 
22: } // namespace duckdb
[end of src/optimizer/statistics/operator/propagate_projection.cpp]
[start of src/parser/expression/columnref_expression.cpp]
1: #include "duckdb/parser/expression/columnref_expression.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/serializer.hpp"
5: #include "duckdb/common/types/hash.hpp"
6: 
7: namespace duckdb {
8: 
9: //! Specify both the column and table name
10: ColumnRefExpression::ColumnRefExpression(string column_name, string table_name)
11:     : ParsedExpression(ExpressionType::COLUMN_REF, ExpressionClass::COLUMN_REF), column_name(move(column_name)),
12:       table_name(move(table_name)) {
13: }
14: 
15: ColumnRefExpression::ColumnRefExpression(string column_name) : ColumnRefExpression(move(column_name), string()) {
16: }
17: 
18: string ColumnRefExpression::GetName() const {
19: 	return !alias.empty() ? alias : column_name;
20: }
21: 
22: string ColumnRefExpression::ToString() const {
23: 	if (table_name.empty()) {
24: 		return column_name;
25: 	} else {
26: 		return table_name + "." + column_name;
27: 	}
28: }
29: 
30: bool ColumnRefExpression::Equals(const ColumnRefExpression *a, const ColumnRefExpression *b) {
31: 	return a->column_name == b->column_name && a->table_name == b->table_name;
32: }
33: 
34: hash_t ColumnRefExpression::Hash() const {
35: 	hash_t result = ParsedExpression::Hash();
36: 	result = CombineHash(result, duckdb::Hash<const char *>(column_name.c_str()));
37: 	return result;
38: }
39: 
40: unique_ptr<ParsedExpression> ColumnRefExpression::Copy() const {
41: 	auto copy = make_unique<ColumnRefExpression>(column_name, table_name);
42: 	copy->CopyProperties(*this);
43: 	return move(copy);
44: }
45: 
46: void ColumnRefExpression::Serialize(Serializer &serializer) {
47: 	ParsedExpression::Serialize(serializer);
48: 	serializer.WriteString(table_name);
49: 	serializer.WriteString(column_name);
50: }
51: 
52: unique_ptr<ParsedExpression> ColumnRefExpression::Deserialize(ExpressionType type, Deserializer &source) {
53: 	auto table_name = source.Read<string>();
54: 	auto column_name = source.Read<string>();
55: 	auto expression = make_unique<ColumnRefExpression>(column_name, table_name);
56: 	return move(expression);
57: }
58: 
59: } // namespace duckdb
[end of src/parser/expression/columnref_expression.cpp]
[start of src/parser/parsed_expression_iterator.cpp]
1: #include "duckdb/parser/parsed_expression_iterator.hpp"
2: 
3: #include "duckdb/parser/expression/list.hpp"
4: 
5: namespace duckdb {
6: 
7: void ParsedExpressionIterator::EnumerateChildren(const ParsedExpression &expression,
8:                                                  const std::function<void(const ParsedExpression &child)> &callback) {
9: 	EnumerateChildren((ParsedExpression &)expression, [&](unique_ptr<ParsedExpression> &child) {
10: 		D_ASSERT(child);
11: 		callback(*child);
12: 	});
13: }
14: 
15: void ParsedExpressionIterator::EnumerateChildren(ParsedExpression &expr,
16:                                                  const std::function<void(ParsedExpression &child)> &callback) {
17: 	EnumerateChildren(expr, [&](unique_ptr<ParsedExpression> &child) {
18: 		D_ASSERT(child);
19: 		callback(*child);
20: 	});
21: }
22: 
23: void ParsedExpressionIterator::EnumerateChildren(
24:     ParsedExpression &expr, const std::function<void(unique_ptr<ParsedExpression> &child)> &callback) {
25: 	switch (expr.expression_class) {
26: 	case ExpressionClass::BETWEEN: {
27: 		auto &cast_expr = (BetweenExpression &)expr;
28: 		callback(cast_expr.input);
29: 		callback(cast_expr.lower);
30: 		callback(cast_expr.upper);
31: 		break;
32: 	}
33: 	case ExpressionClass::CASE: {
34: 		auto &case_expr = (CaseExpression &)expr;
35: 		for (auto &check : case_expr.case_checks) {
36: 			callback(check.when_expr);
37: 			callback(check.then_expr);
38: 		}
39: 		callback(case_expr.else_expr);
40: 		break;
41: 	}
42: 	case ExpressionClass::CAST: {
43: 		auto &cast_expr = (CastExpression &)expr;
44: 		callback(cast_expr.child);
45: 		break;
46: 	}
47: 	case ExpressionClass::COLLATE: {
48: 		auto &cast_expr = (CollateExpression &)expr;
49: 		callback(cast_expr.child);
50: 		break;
51: 	}
52: 	case ExpressionClass::COMPARISON: {
53: 		auto &comp_expr = (ComparisonExpression &)expr;
54: 		callback(comp_expr.left);
55: 		callback(comp_expr.right);
56: 		break;
57: 	}
58: 	case ExpressionClass::CONJUNCTION: {
59: 		auto &conj_expr = (ConjunctionExpression &)expr;
60: 		for (auto &child : conj_expr.children) {
61: 			callback(child);
62: 		}
63: 		break;
64: 	}
65: 
66: 	case ExpressionClass::FUNCTION: {
67: 		auto &func_expr = (FunctionExpression &)expr;
68: 		for (auto &child : func_expr.children) {
69: 			callback(child);
70: 		}
71: 		if (func_expr.filter) {
72: 			callback(func_expr.filter);
73: 		}
74: 		if (func_expr.order_bys) {
75: 			for (auto &order : func_expr.order_bys->orders) {
76: 				callback(order.expression);
77: 			}
78: 		}
79: 		break;
80: 	}
81: 	case ExpressionClass::LAMBDA: {
82: 		auto &lambda_expr = (LambdaExpression &)expr;
83: 		callback(lambda_expr.expression);
84: 		break;
85: 	}
86: 	case ExpressionClass::OPERATOR: {
87: 		auto &op_expr = (OperatorExpression &)expr;
88: 		for (auto &child : op_expr.children) {
89: 			callback(child);
90: 		}
91: 		break;
92: 	}
93: 	case ExpressionClass::SUBQUERY: {
94: 		auto &subquery_expr = (SubqueryExpression &)expr;
95: 		if (subquery_expr.child) {
96: 			callback(subquery_expr.child);
97: 		}
98: 		break;
99: 	}
100: 	case ExpressionClass::WINDOW: {
101: 		auto &window_expr = (WindowExpression &)expr;
102: 		for (auto &partition : window_expr.partitions) {
103: 			callback(partition);
104: 		}
105: 		for (auto &order : window_expr.orders) {
106: 			callback(order.expression);
107: 		}
108: 		for (auto &child : window_expr.children) {
109: 			callback(child);
110: 		}
111: 		if (window_expr.start_expr) {
112: 			callback(window_expr.start_expr);
113: 		}
114: 		if (window_expr.end_expr) {
115: 			callback(window_expr.end_expr);
116: 		}
117: 		if (window_expr.offset_expr) {
118: 			callback(window_expr.offset_expr);
119: 		}
120: 		if (window_expr.default_expr) {
121: 			callback(window_expr.default_expr);
122: 		}
123: 		break;
124: 	}
125: 	case ExpressionClass::BOUND_EXPRESSION:
126: 	case ExpressionClass::COLUMN_REF:
127: 	case ExpressionClass::CONSTANT:
128: 	case ExpressionClass::DEFAULT:
129: 	case ExpressionClass::STAR:
130: 	case ExpressionClass::PARAMETER:
131: 	case ExpressionClass::POSITIONAL_REFERENCE:
132: 		// these node types have no children
133: 		break;
134: 	default:
135: 		// called on non ParsedExpression type!
136: 		throw NotImplementedException("Unimplemented expression class");
137: 	}
138: }
139: 
140: } // namespace duckdb
[end of src/parser/parsed_expression_iterator.cpp]
[start of src/parser/transform/expression/transform_columnref.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/parser/expression/columnref_expression.hpp"
3: #include "duckdb/parser/expression/star_expression.hpp"
4: #include "duckdb/parser/transformer.hpp"
5: 
6: namespace duckdb {
7: 
8: unique_ptr<ParsedExpression> Transformer::TransformStarExpression(duckdb_libpgquery::PGNode *node) {
9: 	auto star = (duckdb_libpgquery::PGAStar *)node;
10: 	auto result = make_unique<StarExpression>(star->relation ? star->relation : string());
11: 	if (star->except_list) {
12: 		for (auto head = star->except_list->head; head; head = head->next) {
13: 			auto value = (duckdb_libpgquery::PGValue *)head->data.ptr_value;
14: 			D_ASSERT(value->type == duckdb_libpgquery::T_PGString);
15: 			string exclude_entry = value->val.str;
16: 			if (result->exclude_list.find(exclude_entry) != result->exclude_list.end()) {
17: 				throw ParserException("Duplicate entry \"%s\" in EXCLUDE list", exclude_entry);
18: 			}
19: 			result->exclude_list.insert(move(exclude_entry));
20: 		}
21: 	}
22: 	if (star->replace_list) {
23: 		for (auto head = star->replace_list->head; head; head = head->next) {
24: 			auto list = (duckdb_libpgquery::PGList *)head->data.ptr_value;
25: 			D_ASSERT(list->length == 2);
26: 			auto replace_expression = TransformExpression((duckdb_libpgquery::PGNode *)list->head->data.ptr_value);
27: 			auto value = (duckdb_libpgquery::PGValue *)list->tail->data.ptr_value;
28: 			D_ASSERT(value->type == duckdb_libpgquery::T_PGString);
29: 			string exclude_entry = value->val.str;
30: 			if (result->replace_list.find(exclude_entry) != result->replace_list.end()) {
31: 				throw ParserException("Duplicate entry \"%s\" in REPLACE list", exclude_entry);
32: 			}
33: 			if (result->exclude_list.find(exclude_entry) != result->exclude_list.end()) {
34: 				throw ParserException("Column \"%s\" cannot occur in both EXCEPT and REPLACE list", exclude_entry);
35: 			}
36: 			result->replace_list.insert(make_pair(move(exclude_entry), move(replace_expression)));
37: 		}
38: 	}
39: 	return move(result);
40: }
41: 
42: unique_ptr<ParsedExpression> Transformer::TransformColumnRef(duckdb_libpgquery::PGColumnRef *root) {
43: 	auto fields = root->fields;
44: 	auto head_node = (duckdb_libpgquery::PGNode *)fields->head->data.ptr_value;
45: 	switch (head_node->type) {
46: 	case duckdb_libpgquery::T_PGString: {
47: 		if (fields->length < 1) {
48: 			throw InternalException("Unexpected field length");
49: 		}
50: 		string column_name, table_name;
51: 		if (fields->length == 1) {
52: 			column_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(fields->head->data.ptr_value)->val.str);
53: 			auto colref = make_unique<ColumnRefExpression>(column_name, table_name);
54: 			colref->query_location = root->location;
55: 			return move(colref);
56: 		} else if (fields->length == 2) {
57: 			table_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(fields->head->data.ptr_value)->val.str);
58: 			auto col_node = reinterpret_cast<duckdb_libpgquery::PGNode *>(fields->head->next->data.ptr_value);
59: 			switch (col_node->type) {
60: 			case duckdb_libpgquery::T_PGString: {
61: 				column_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(col_node)->val.str);
62: 				auto colref = make_unique<ColumnRefExpression>(column_name, table_name);
63: 				colref->query_location = root->location;
64: 				return move(colref);
65: 			}
66: 			default:
67: 				throw NotImplementedException("ColumnRef not implemented!");
68: 			}
69: 		} else {
70: 			throw NotImplementedException("ColumnRef not implemented!");
71: 		}
72: 	}
73: 	case duckdb_libpgquery::T_PGAStar: {
74: 		return TransformStarExpression(head_node);
75: 	}
76: 	default:
77: 		throw NotImplementedException("ColumnRef not implemented!");
78: 	}
79: }
80: 
81: } // namespace duckdb
[end of src/parser/transform/expression/transform_columnref.cpp]
[start of src/parser/transform/expression/transform_lambda.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/parser/expression/columnref_expression.hpp"
3: #include "duckdb/parser/expression/lambda_expression.hpp"
4: #include "duckdb/parser/transformer.hpp"
5: 
6: namespace duckdb {
7: 
8: static string ExtractColumnFromLambda(ParsedExpression &expr) {
9: 	if (expr.type != ExpressionType::COLUMN_REF) {
10: 		throw ParserException("Lambda parameter must be a column name");
11: 	}
12: 	auto &colref = (ColumnRefExpression &)expr;
13: 	if (!colref.table_name.empty()) {
14: 		throw ParserException("Lambda parameter must be an unqualified name (e.g. 'x', not 'a.x')");
15: 	}
16: 	return colref.column_name;
17: }
18: 
19: unique_ptr<ParsedExpression> Transformer::TransformLambda(duckdb_libpgquery::PGLambdaFunction *node) {
20: 	vector<unique_ptr<ParsedExpression>> parameter_expressions;
21: 	TransformExpressionList(*node->parameters, parameter_expressions);
22: 	vector<string> parameters;
23: 	parameters.reserve(parameter_expressions.size());
24: 	for (auto &expr : parameter_expressions) {
25: 		parameters.push_back(ExtractColumnFromLambda(*expr));
26: 	}
27: 
28: 	auto lambda_function = TransformExpression(node->function);
29: 	return make_unique<LambdaExpression>(move(parameters), move(lambda_function));
30: }
31: 
32: } // namespace duckdb
[end of src/parser/transform/expression/transform_lambda.cpp]
[start of src/planner/bind_context.cpp]
1: #include "duckdb/planner/bind_context.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/expression/positional_reference_expression.hpp"
5: #include "duckdb/parser/tableref/subqueryref.hpp"
6: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
7: #include "duckdb/planner/bound_query_node.hpp"
8: #include "duckdb/parser/expression/operator_expression.hpp"
9: #include "duckdb/parser/expression/star_expression.hpp"
10: 
11: #include "duckdb/common/string_util.hpp"
12: #include "duckdb/common/pair.hpp"
13: 
14: #include <algorithm>
15: 
16: namespace duckdb {
17: 
18: string BindContext::GetMatchingBinding(const string &column_name) {
19: 	string result;
20: 	for (auto &kv : bindings) {
21: 		auto binding = kv.second.get();
22: 		auto is_using_binding = GetUsingBinding(column_name, kv.first);
23: 		if (is_using_binding) {
24: 			continue;
25: 		}
26: 		if (binding->HasMatchingBinding(column_name)) {
27: 			if (!result.empty() || is_using_binding) {
28: 				throw BinderException("Ambiguous reference to column name \"%s\" (use: \"%s.%s\" "
29: 				                      "or \"%s.%s\")",
30: 				                      column_name, result, column_name, kv.first, column_name);
31: 			}
32: 			result = kv.first;
33: 		}
34: 	}
35: 	return result;
36: }
37: 
38: vector<string> BindContext::GetSimilarBindings(const string &column_name) {
39: 	vector<pair<string, idx_t>> scores;
40: 	for (auto &kv : bindings) {
41: 		auto binding = kv.second.get();
42: 		for (auto &name : binding->names) {
43: 			idx_t distance = StringUtil::LevenshteinDistance(name, column_name);
44: 			scores.emplace_back(binding->alias + "." + name, distance);
45: 		}
46: 	}
47: 	return StringUtil::TopNStrings(scores);
48: }
49: 
50: void BindContext::AddUsingBinding(const string &column_name, UsingColumnSet *set) {
51: 	using_columns[column_name].insert(set);
52: }
53: 
54: void BindContext::AddUsingBindingSet(unique_ptr<UsingColumnSet> set) {
55: 	using_column_sets.push_back(move(set));
56: }
57: 
58: bool BindContext::FindUsingBinding(const string &column_name, unordered_set<UsingColumnSet *> **out) {
59: 	auto entry = using_columns.find(column_name);
60: 	if (entry != using_columns.end()) {
61: 		*out = &entry->second;
62: 		return true;
63: 	}
64: 	return false;
65: }
66: 
67: UsingColumnSet *BindContext::GetUsingBinding(const string &column_name) {
68: 	unordered_set<UsingColumnSet *> *using_bindings;
69: 	if (!FindUsingBinding(column_name, &using_bindings)) {
70: 		return nullptr;
71: 	}
72: 	if (using_bindings->size() > 1) {
73: 		string error = "Ambiguous column reference: column \"" + column_name + "\" can refer to either:\n";
74: 		for (auto &using_set : *using_bindings) {
75: 			string result_bindings;
76: 			for (auto &binding : using_set->bindings) {
77: 				if (result_bindings.empty()) {
78: 					result_bindings = "[";
79: 				} else {
80: 					result_bindings += ", ";
81: 				}
82: 				result_bindings += binding;
83: 				result_bindings += ".";
84: 				result_bindings += GetActualColumnName(binding, column_name);
85: 			}
86: 			error += result_bindings + "]";
87: 		}
88: 		throw BinderException(error);
89: 	}
90: 	for (auto &using_set : *using_bindings) {
91: 		return using_set;
92: 	}
93: 	throw InternalException("Using binding found but no entries");
94: }
95: 
96: UsingColumnSet *BindContext::GetUsingBinding(const string &column_name, const string &binding_name) {
97: 	if (binding_name.empty()) {
98: 		throw InternalException("GetUsingBinding: expected non-empty binding_name");
99: 	}
100: 	unordered_set<UsingColumnSet *> *using_bindings;
101: 	if (!FindUsingBinding(column_name, &using_bindings)) {
102: 		return nullptr;
103: 	}
104: 	for (auto &using_set : *using_bindings) {
105: 		auto &bindings = using_set->bindings;
106: 		if (bindings.find(binding_name) != bindings.end()) {
107: 			return using_set;
108: 		}
109: 	}
110: 	return nullptr;
111: }
112: 
113: void BindContext::RemoveUsingBinding(const string &column_name, UsingColumnSet *set) {
114: 	if (!set) {
115: 		return;
116: 	}
117: 	auto entry = using_columns.find(column_name);
118: 	if (entry == using_columns.end()) {
119: 		throw InternalException("Attempting to remove using binding that is not there");
120: 	}
121: 	auto &bindings = entry->second;
122: 	if (bindings.find(set) != bindings.end()) {
123: 		bindings.erase(set);
124: 	}
125: 	if (bindings.empty()) {
126: 		using_columns.erase(column_name);
127: 	}
128: }
129: 
130: void BindContext::TransferUsingBinding(BindContext &current_context, UsingColumnSet *current_set,
131:                                        UsingColumnSet *new_set, const string &binding, const string &using_column) {
132: 	AddUsingBinding(using_column, new_set);
133: 	current_context.RemoveUsingBinding(using_column, current_set);
134: }
135: 
136: string BindContext::GetActualColumnName(const string &binding_name, const string &column_name) {
137: 	string error;
138: 	auto binding = GetBinding(binding_name, error);
139: 	if (!binding) {
140: 		throw InternalException("No binding with name \"%s\"", binding_name);
141: 	}
142: 	idx_t binding_index;
143: 	if (!binding->TryGetBindingIndex(column_name, binding_index)) { // LCOV_EXCL_START
144: 		throw InternalException("Binding with name \"%s\" does not have a column named \"%s\"", binding_name,
145: 		                        column_name);
146: 	} // LCOV_EXCL_STOP
147: 	return binding->names[binding_index];
148: }
149: 
150: unordered_set<string> BindContext::GetMatchingBindings(const string &column_name) {
151: 	unordered_set<string> result;
152: 	for (auto &kv : bindings) {
153: 		auto binding = kv.second.get();
154: 		if (binding->HasMatchingBinding(column_name)) {
155: 			result.insert(kv.first);
156: 		}
157: 	}
158: 	return result;
159: }
160: 
161: Binding *BindContext::GetCTEBinding(const string &ctename) {
162: 	auto match = cte_bindings.find(ctename);
163: 	if (match == cte_bindings.end()) {
164: 		return nullptr;
165: 	}
166: 	return match->second.get();
167: }
168: 
169: Binding *BindContext::GetBinding(const string &name, string &out_error) {
170: 	auto match = bindings.find(name);
171: 	if (match == bindings.end()) {
172: 		// alias not found in this BindContext
173: 		vector<string> candidates;
174: 		for (auto &kv : bindings) {
175: 			candidates.push_back(kv.first);
176: 		}
177: 		string candidate_str =
178: 		    StringUtil::CandidatesMessage(StringUtil::TopNLevenshtein(candidates, name), "Candidate tables");
179: 		out_error = StringUtil::Format("Referenced table \"%s\" not found!%s", name, candidate_str);
180: 		return nullptr;
181: 	}
182: 	return match->second.get();
183: }
184: 
185: BindResult BindContext::BindColumn(ColumnRefExpression &colref, idx_t depth) {
186: 	if (colref.table_name.empty()) {
187: 		return BindResult(StringUtil::Format("Could not bind alias \"%s\"!", colref.column_name));
188: 	}
189: 
190: 	string error;
191: 	auto binding = GetBinding(colref.table_name, error);
192: 	if (!binding) {
193: 		return BindResult(error);
194: 	}
195: 	return binding->Bind(colref, depth);
196: }
197: 
198: string BindContext::BindColumn(PositionalReferenceExpression &ref, string &table_name, string &column_name) {
199: 	idx_t current_position = ref.index - 1;
200: 	idx_t total_columns = 0;
201: 	for (auto &entry : bindings_list) {
202: 		idx_t entry_column_count = entry.second->names.size();
203: 		if (current_position < entry_column_count) {
204: 			table_name = entry.first;
205: 			column_name = entry.second->names[current_position];
206: 			return string();
207: 		} else {
208: 			total_columns += entry_column_count;
209: 			current_position -= entry_column_count;
210: 		}
211: 	}
212: 	return StringUtil::Format("Positional reference %d out of range (total %d columns)", ref.index, total_columns);
213: }
214: 
215: BindResult BindContext::BindColumn(PositionalReferenceExpression &ref, idx_t depth) {
216: 	string table_name, column_name;
217: 
218: 	string error = BindColumn(ref, table_name, column_name);
219: 	if (!error.empty()) {
220: 		return BindResult(error);
221: 	}
222: 	auto column_ref = make_unique<ColumnRefExpression>(column_name, table_name);
223: 	return BindColumn(*column_ref, depth);
224: }
225: 
226: bool BindContext::CheckExclusionList(StarExpression &expr, Binding *binding, const string &column_name,
227:                                      vector<unique_ptr<ParsedExpression>> &new_select_list,
228:                                      case_insensitive_set_t &excluded_columns) {
229: 	if (expr.exclude_list.find(column_name) != expr.exclude_list.end()) {
230: 		excluded_columns.insert(column_name);
231: 		return true;
232: 	}
233: 	auto entry = expr.replace_list.find(column_name);
234: 	if (entry != expr.replace_list.end()) {
235: 		excluded_columns.insert(entry->first);
236: 		new_select_list.push_back(entry->second->Copy());
237: 		return true;
238: 	}
239: 	return false;
240: }
241: 
242: void BindContext::GenerateAllColumnExpressions(StarExpression &expr,
243:                                                vector<unique_ptr<ParsedExpression>> &new_select_list) {
244: 	if (bindings_list.empty()) {
245: 		throw BinderException("SELECT * expression without FROM clause!");
246: 	}
247: 	case_insensitive_set_t excluded_columns;
248: 	if (expr.relation_name.empty()) {
249: 		// SELECT * case
250: 		// bind all expressions of each table in-order
251: 		unordered_set<UsingColumnSet *> handled_using_columns;
252: 		for (auto &entry : bindings_list) {
253: 			auto binding = entry.second;
254: 			for (auto &column_name : binding->names) {
255: 				if (CheckExclusionList(expr, binding, column_name, new_select_list, excluded_columns)) {
256: 					continue;
257: 				}
258: 				// check if this column is a USING column
259: 				auto using_binding = GetUsingBinding(column_name, binding->alias);
260: 				if (using_binding) {
261: 					// it is!
262: 					// check if we have already emitted the using column
263: 					if (handled_using_columns.find(using_binding) != handled_using_columns.end()) {
264: 						// we have! bail out
265: 						continue;
266: 					}
267: 					// we have not! output the using column
268: 					if (using_binding->primary_binding.empty()) {
269: 						// no primary binding: output a coalesce
270: 						auto coalesce = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
271: 						for (auto &child_binding : using_binding->bindings) {
272: 							coalesce->children.push_back(make_unique<ColumnRefExpression>(column_name, child_binding));
273: 						}
274: 						coalesce->alias = column_name;
275: 						new_select_list.push_back(move(coalesce));
276: 					} else {
277: 						// primary binding: output the qualified column ref
278: 						new_select_list.push_back(
279: 						    make_unique<ColumnRefExpression>(column_name, using_binding->primary_binding));
280: 					}
281: 					handled_using_columns.insert(using_binding);
282: 					continue;
283: 				}
284: 				new_select_list.push_back(make_unique<ColumnRefExpression>(column_name, binding->alias));
285: 			}
286: 		}
287: 	} else {
288: 		// SELECT tbl.* case
289: 		string error;
290: 		auto binding = GetBinding(expr.relation_name, error);
291: 		if (!binding) {
292: 			throw BinderException(error);
293: 		}
294: 		for (auto &column_name : binding->names) {
295: 			if (CheckExclusionList(expr, binding, column_name, new_select_list, excluded_columns)) {
296: 				continue;
297: 			}
298: 			new_select_list.push_back(make_unique<ColumnRefExpression>(column_name, binding->alias));
299: 		}
300: 	}
301: 	for (auto &excluded : expr.exclude_list) {
302: 		if (excluded_columns.find(excluded) == excluded_columns.end()) {
303: 			throw BinderException("Column \"%s\" in EXCLUDE list not found in %s", excluded,
304: 			                      expr.relation_name.empty() ? "FROM clause" : expr.relation_name.c_str());
305: 		}
306: 	}
307: 	for (auto &entry : expr.replace_list) {
308: 		if (excluded_columns.find(entry.first) == excluded_columns.end()) {
309: 			throw BinderException("Column \"%s\" in REPLACE list not found in %s", entry.first,
310: 			                      expr.relation_name.empty() ? "FROM clause" : expr.relation_name.c_str());
311: 		}
312: 	}
313: }
314: 
315: void BindContext::AddBinding(const string &alias, unique_ptr<Binding> binding) {
316: 	if (bindings.find(alias) != bindings.end()) {
317: 		throw BinderException("Duplicate alias \"%s\" in query!", alias);
318: 	}
319: 	bindings_list.emplace_back(alias, binding.get());
320: 	bindings[alias] = move(binding);
321: }
322: 
323: void BindContext::AddBaseTable(idx_t index, const string &alias, const vector<string> &names,
324:                                const vector<LogicalType> &types, LogicalGet &get) {
325: 	AddBinding(alias, make_unique<TableBinding>(alias, types, names, get, index, true));
326: }
327: 
328: void BindContext::AddTableFunction(idx_t index, const string &alias, const vector<string> &names,
329:                                    const vector<LogicalType> &types, LogicalGet &get) {
330: 	AddBinding(alias, make_unique<TableBinding>(alias, types, names, get, index));
331: }
332: 
333: static string AddColumnNameToBinding(const string &base_name, case_insensitive_set_t &current_names) {
334: 	idx_t index = 1;
335: 	string name = base_name;
336: 	while (current_names.find(name) != current_names.end()) {
337: 		name = base_name + ":" + to_string(index++);
338: 	}
339: 	current_names.insert(name);
340: 	return name;
341: }
342: 
343: vector<string> BindContext::AliasColumnNames(const string &table_name, const vector<string> &names,
344:                                              const vector<string> &column_aliases) {
345: 	vector<string> result;
346: 	if (column_aliases.size() > names.size()) {
347: 		throw BinderException("table \"%s\" has %lld columns available but %lld columns specified", table_name,
348: 		                      names.size(), column_aliases.size());
349: 	}
350: 	case_insensitive_set_t current_names;
351: 	// use any provided column aliases first
352: 	for (idx_t i = 0; i < column_aliases.size(); i++) {
353: 		result.push_back(AddColumnNameToBinding(column_aliases[i], current_names));
354: 	}
355: 	// if not enough aliases were provided, use the default names for remaining columns
356: 	for (idx_t i = column_aliases.size(); i < names.size(); i++) {
357: 		result.push_back(AddColumnNameToBinding(names[i], current_names));
358: 	}
359: 	return result;
360: }
361: 
362: void BindContext::AddSubquery(idx_t index, const string &alias, SubqueryRef &ref, BoundQueryNode &subquery) {
363: 	auto names = AliasColumnNames(alias, subquery.names, ref.column_name_alias);
364: 	AddGenericBinding(index, alias, names, subquery.types);
365: }
366: 
367: void BindContext::AddGenericBinding(idx_t index, const string &alias, const vector<string> &names,
368:                                     const vector<LogicalType> &types) {
369: 	AddBinding(alias, make_unique<Binding>(alias, types, names, index));
370: }
371: 
372: void BindContext::AddCTEBinding(idx_t index, const string &alias, const vector<string> &names,
373:                                 const vector<LogicalType> &types) {
374: 	auto binding = make_shared<Binding>(alias, types, names, index);
375: 
376: 	if (cte_bindings.find(alias) != cte_bindings.end()) {
377: 		throw BinderException("Duplicate alias \"%s\" in query!", alias);
378: 	}
379: 	cte_bindings[alias] = move(binding);
380: 	cte_references[alias] = std::make_shared<idx_t>(0);
381: }
382: 
383: void BindContext::AddContext(BindContext other) {
384: 	for (auto &binding : other.bindings) {
385: 		if (bindings.find(binding.first) != bindings.end()) {
386: 			throw BinderException("Duplicate alias \"%s\" in query!", binding.first);
387: 		}
388: 		bindings[binding.first] = move(binding.second);
389: 	}
390: 	for (auto &binding : other.bindings_list) {
391: 		bindings_list.push_back(move(binding));
392: 	}
393: 	for (auto &entry : other.using_columns) {
394: 		for (auto &alias : entry.second) {
395: #ifdef DEBUG
396: 			for (auto &other_alias : using_columns[entry.first]) {
397: 				for (auto &col : alias->bindings) {
398: 					D_ASSERT(other_alias->bindings.find(col) == other_alias->bindings.end());
399: 				}
400: 			}
401: #endif
402: 			using_columns[entry.first].insert(alias);
403: 		}
404: 	}
405: }
406: 
407: } // namespace duckdb
[end of src/planner/bind_context.cpp]
[start of src/planner/binder.cpp]
1: #include "duckdb/planner/binder.hpp"
2: 
3: #include "duckdb/parser/statement/list.hpp"
4: #include "duckdb/parser/query_node/select_node.hpp"
5: #include "duckdb/planner/bound_query_node.hpp"
6: #include "duckdb/planner/bound_tableref.hpp"
7: #include "duckdb/planner/expression.hpp"
8: #include "duckdb/planner/operator/logical_sample.hpp"
9: 
10: #include <algorithm>
11: 
12: namespace duckdb {
13: 
14: shared_ptr<Binder> Binder::CreateBinder(ClientContext &context, Binder *parent, bool inherit_ctes) {
15: 	return make_shared<Binder>(true, context, parent ? parent->shared_from_this() : nullptr, inherit_ctes);
16: }
17: 
18: Binder::Binder(bool, ClientContext &context, shared_ptr<Binder> parent_p, bool inherit_ctes_p)
19:     : context(context), read_only(true), requires_valid_transaction(true), allow_stream_result(false),
20:       parent(move(parent_p)), bound_tables(0), inherit_ctes(inherit_ctes_p) {
21: 	parameters = nullptr;
22: 	if (parent) {
23: 		// We have to inherit macro parameter bindings from the parent binder, if there is a parent.
24: 		macro_binding = parent->macro_binding;
25: 		if (inherit_ctes) {
26: 			// We have to inherit CTE bindings from the parent bind_context, if there is a parent.
27: 			bind_context.SetCTEBindings(parent->bind_context.GetCTEBindings());
28: 			bind_context.cte_references = parent->bind_context.cte_references;
29: 			parameters = parent->parameters;
30: 		}
31: 	}
32: }
33: 
34: BoundStatement Binder::Bind(SQLStatement &statement) {
35: 	root_statement = &statement;
36: 	switch (statement.type) {
37: 	case StatementType::SELECT_STATEMENT:
38: 		return Bind((SelectStatement &)statement);
39: 	case StatementType::INSERT_STATEMENT:
40: 		return Bind((InsertStatement &)statement);
41: 	case StatementType::COPY_STATEMENT:
42: 		return Bind((CopyStatement &)statement);
43: 	case StatementType::DELETE_STATEMENT:
44: 		return Bind((DeleteStatement &)statement);
45: 	case StatementType::UPDATE_STATEMENT:
46: 		return Bind((UpdateStatement &)statement);
47: 	case StatementType::RELATION_STATEMENT:
48: 		return Bind((RelationStatement &)statement);
49: 	case StatementType::CREATE_STATEMENT:
50: 		return Bind((CreateStatement &)statement);
51: 	case StatementType::DROP_STATEMENT:
52: 		return Bind((DropStatement &)statement);
53: 	case StatementType::ALTER_STATEMENT:
54: 		return Bind((AlterStatement &)statement);
55: 	case StatementType::TRANSACTION_STATEMENT:
56: 		return Bind((TransactionStatement &)statement);
57: 	case StatementType::PRAGMA_STATEMENT:
58: 		return Bind((PragmaStatement &)statement);
59: 	case StatementType::EXPLAIN_STATEMENT:
60: 		return Bind((ExplainStatement &)statement);
61: 	case StatementType::VACUUM_STATEMENT:
62: 		return Bind((VacuumStatement &)statement);
63: 	case StatementType::SHOW_STATEMENT:
64: 		return Bind((ShowStatement &)statement);
65: 	case StatementType::CALL_STATEMENT:
66: 		return Bind((CallStatement &)statement);
67: 	case StatementType::EXPORT_STATEMENT:
68: 		return Bind((ExportStatement &)statement);
69: 	case StatementType::SET_STATEMENT:
70: 		return Bind((SetStatement &)statement);
71: 	case StatementType::LOAD_STATEMENT:
72: 		return Bind((LoadStatement &)statement);
73: 	default: // LCOV_EXCL_START
74: 		throw NotImplementedException("Unimplemented statement type \"%s\" for Bind",
75: 		                              StatementTypeToString(statement.type));
76: 	} // LCOV_EXCL_STOP
77: }
78: 
79: unique_ptr<BoundQueryNode> Binder::BindNode(QueryNode &node) {
80: 	// first we visit the set of CTEs and add them to the bind context
81: 	for (auto &cte_it : node.cte_map) {
82: 		AddCTE(cte_it.first, cte_it.second.get());
83: 	}
84: 	// now we bind the node
85: 	unique_ptr<BoundQueryNode> result;
86: 	switch (node.type) {
87: 	case QueryNodeType::SELECT_NODE:
88: 		result = BindNode((SelectNode &)node);
89: 		break;
90: 	case QueryNodeType::RECURSIVE_CTE_NODE:
91: 		result = BindNode((RecursiveCTENode &)node);
92: 		break;
93: 	default:
94: 		D_ASSERT(node.type == QueryNodeType::SET_OPERATION_NODE);
95: 		result = BindNode((SetOperationNode &)node);
96: 		break;
97: 	}
98: 	return result;
99: }
100: 
101: BoundStatement Binder::Bind(QueryNode &node) {
102: 	auto bound_node = BindNode(node);
103: 
104: 	BoundStatement result;
105: 	result.names = bound_node->names;
106: 	result.types = bound_node->types;
107: 
108: 	// and plan it
109: 	result.plan = CreatePlan(*bound_node);
110: 	return result;
111: }
112: 
113: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundQueryNode &node) {
114: 	switch (node.type) {
115: 	case QueryNodeType::SELECT_NODE:
116: 		return CreatePlan((BoundSelectNode &)node);
117: 	case QueryNodeType::SET_OPERATION_NODE:
118: 		return CreatePlan((BoundSetOperationNode &)node);
119: 	case QueryNodeType::RECURSIVE_CTE_NODE:
120: 		return CreatePlan((BoundRecursiveCTENode &)node);
121: 	default:
122: 		throw InternalException("Unsupported bound query node type");
123: 	}
124: }
125: 
126: unique_ptr<BoundTableRef> Binder::Bind(TableRef &ref) {
127: 	unique_ptr<BoundTableRef> result;
128: 	switch (ref.type) {
129: 	case TableReferenceType::BASE_TABLE:
130: 		result = Bind((BaseTableRef &)ref);
131: 		break;
132: 	case TableReferenceType::CROSS_PRODUCT:
133: 		result = Bind((CrossProductRef &)ref);
134: 		break;
135: 	case TableReferenceType::JOIN:
136: 		result = Bind((JoinRef &)ref);
137: 		break;
138: 	case TableReferenceType::SUBQUERY:
139: 		result = Bind((SubqueryRef &)ref);
140: 		break;
141: 	case TableReferenceType::EMPTY:
142: 		result = Bind((EmptyTableRef &)ref);
143: 		break;
144: 	case TableReferenceType::TABLE_FUNCTION:
145: 		result = Bind((TableFunctionRef &)ref);
146: 		break;
147: 	case TableReferenceType::EXPRESSION_LIST:
148: 		result = Bind((ExpressionListRef &)ref);
149: 		break;
150: 	default:
151: 		throw InternalException("Unknown table ref type");
152: 	}
153: 	result->sample = move(ref.sample);
154: 	return result;
155: }
156: 
157: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundTableRef &ref) {
158: 	unique_ptr<LogicalOperator> root;
159: 	switch (ref.type) {
160: 	case TableReferenceType::BASE_TABLE:
161: 		root = CreatePlan((BoundBaseTableRef &)ref);
162: 		break;
163: 	case TableReferenceType::SUBQUERY:
164: 		root = CreatePlan((BoundSubqueryRef &)ref);
165: 		break;
166: 	case TableReferenceType::JOIN:
167: 		root = CreatePlan((BoundJoinRef &)ref);
168: 		break;
169: 	case TableReferenceType::CROSS_PRODUCT:
170: 		root = CreatePlan((BoundCrossProductRef &)ref);
171: 		break;
172: 	case TableReferenceType::TABLE_FUNCTION:
173: 		root = CreatePlan((BoundTableFunction &)ref);
174: 		break;
175: 	case TableReferenceType::EMPTY:
176: 		root = CreatePlan((BoundEmptyTableRef &)ref);
177: 		break;
178: 	case TableReferenceType::EXPRESSION_LIST:
179: 		root = CreatePlan((BoundExpressionListRef &)ref);
180: 		break;
181: 	case TableReferenceType::CTE:
182: 		root = CreatePlan((BoundCTERef &)ref);
183: 		break;
184: 	default:
185: 		throw InternalException("Unsupported bound table ref type type");
186: 	}
187: 	// plan the sample clause
188: 	if (ref.sample) {
189: 		root = make_unique<LogicalSample>(move(ref.sample), move(root));
190: 	}
191: 	return root;
192: }
193: 
194: void Binder::AddCTE(const string &name, CommonTableExpressionInfo *info) {
195: 	D_ASSERT(info);
196: 	D_ASSERT(!name.empty());
197: 	auto entry = CTE_bindings.find(name);
198: 	if (entry != CTE_bindings.end()) {
199: 		throw InternalException("Duplicate CTE \"%s\" in query!", name);
200: 	}
201: 	CTE_bindings[name] = info;
202: }
203: 
204: CommonTableExpressionInfo *Binder::FindCTE(const string &name, bool skip) {
205: 	auto entry = CTE_bindings.find(name);
206: 	if (entry != CTE_bindings.end()) {
207: 		if (!skip || entry->second->query->node->type == QueryNodeType::RECURSIVE_CTE_NODE) {
208: 			return entry->second;
209: 		}
210: 	}
211: 	if (parent && inherit_ctes) {
212: 		return parent->FindCTE(name, name == alias);
213: 	}
214: 	return nullptr;
215: }
216: 
217: bool Binder::CTEIsAlreadyBound(CommonTableExpressionInfo *cte) {
218: 	if (bound_ctes.find(cte) != bound_ctes.end()) {
219: 		return true;
220: 	}
221: 	if (parent && inherit_ctes) {
222: 		return parent->CTEIsAlreadyBound(cte);
223: 	}
224: 	return false;
225: }
226: 
227: idx_t Binder::GenerateTableIndex() {
228: 	if (parent) {
229: 		return parent->GenerateTableIndex();
230: 	}
231: 	return bound_tables++;
232: }
233: 
234: void Binder::PushExpressionBinder(ExpressionBinder *binder) {
235: 	GetActiveBinders().push_back(binder);
236: }
237: 
238: void Binder::PopExpressionBinder() {
239: 	D_ASSERT(HasActiveBinder());
240: 	GetActiveBinders().pop_back();
241: }
242: 
243: void Binder::SetActiveBinder(ExpressionBinder *binder) {
244: 	D_ASSERT(HasActiveBinder());
245: 	GetActiveBinders().back() = binder;
246: }
247: 
248: ExpressionBinder *Binder::GetActiveBinder() {
249: 	return GetActiveBinders().back();
250: }
251: 
252: bool Binder::HasActiveBinder() {
253: 	return !GetActiveBinders().empty();
254: }
255: 
256: vector<ExpressionBinder *> &Binder::GetActiveBinders() {
257: 	if (parent) {
258: 		return parent->GetActiveBinders();
259: 	}
260: 	return active_binders;
261: }
262: 
263: void Binder::AddUsingBindingSet(unique_ptr<UsingColumnSet> set) {
264: 	if (parent) {
265: 		parent->AddUsingBindingSet(move(set));
266: 		return;
267: 	}
268: 	bind_context.AddUsingBindingSet(move(set));
269: }
270: 
271: void Binder::MoveCorrelatedExpressions(Binder &other) {
272: 	MergeCorrelatedColumns(other.correlated_columns);
273: 	other.correlated_columns.clear();
274: }
275: 
276: void Binder::MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other) {
277: 	for (idx_t i = 0; i < other.size(); i++) {
278: 		AddCorrelatedColumn(other[i]);
279: 	}
280: }
281: 
282: void Binder::AddCorrelatedColumn(const CorrelatedColumnInfo &info) {
283: 	// we only add correlated columns to the list if they are not already there
284: 	if (std::find(correlated_columns.begin(), correlated_columns.end(), info) == correlated_columns.end()) {
285: 		correlated_columns.push_back(info);
286: 	}
287: }
288: 
289: string Binder::FormatError(ParsedExpression &expr_context, const string &message) {
290: 	return FormatError(expr_context.query_location, message);
291: }
292: 
293: string Binder::FormatError(TableRef &ref_context, const string &message) {
294: 	return FormatError(ref_context.query_location, message);
295: }
296: 
297: string Binder::FormatErrorRecursive(idx_t query_location, const string &message, vector<ExceptionFormatValue> &values) {
298: 	QueryErrorContext context(root_statement, query_location);
299: 	return context.FormatErrorRecursive(message, values);
300: }
301: 
302: } // namespace duckdb
[end of src/planner/binder.cpp]
[start of src/planner/binder/expression/bind_columnref_expression.cpp]
1: #include "duckdb/parser/expression/columnref_expression.hpp"
2: #include "duckdb/planner/binder.hpp"
3: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
4: #include "duckdb/planner/expression_binder.hpp"
5: #include "duckdb/parser/expression/operator_expression.hpp"
6: #include "duckdb/common/string_util.hpp"
7: 
8: namespace duckdb {
9: 
10: BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref, idx_t depth) {
11: 	D_ASSERT(!colref.column_name.empty());
12: 	// individual column reference
13: 	// resolve to either a base table or a subquery expression
14: 	if (colref.table_name.empty()) {
15: 		auto using_binding = binder.bind_context.GetUsingBinding(colref.column_name);
16: 		if (using_binding) {
17: 			// we are referencing a USING column
18: 			// check if we can refer to one of the base columns directly
19: 			unique_ptr<Expression> expression;
20: 			if (!using_binding->primary_binding.empty()) {
21: 				// we can! just assign the table name and re-bind
22: 				colref.table_name = using_binding->primary_binding;
23: 				return BindExpression(colref, depth);
24: 			} else {
25: 				// we cannot! we need to bind this as a coalesce between all the relevant columns
26: 				auto coalesce = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
27: 				for (auto &entry : using_binding->bindings) {
28: 					coalesce->children.push_back(make_unique<ColumnRefExpression>(colref.column_name, entry));
29: 				}
30: 				return BindExpression(*coalesce, depth);
31: 			}
32: 		}
33: 		// no table name: find a binding that contains this
34: 		if (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {
35: 			// priority to macro parameter bindings TODO: throw a warning when this name conflicts
36: 			colref.table_name = binder.macro_binding->alias;
37: 		} else {
38: 			colref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);
39: 		}
40: 		if (colref.table_name.empty()) {
41: 			auto similar_bindings = binder.bind_context.GetSimilarBindings(colref.column_name);
42: 			string candidate_str = StringUtil::CandidatesMessage(similar_bindings, "Candidate bindings");
43: 			return BindResult(binder.FormatError(colref.query_location,
44: 			                                     "Referenced column \"%s\" not found in FROM clause!%s",
45: 			                                     colref.column_name.c_str(), candidate_str));
46: 		}
47: 	}
48: 	// if it was a macro parameter, let macro_binding bind it to the argument
49: 	BindResult result = binder.macro_binding != nullptr && colref.table_name == binder.macro_binding->alias
50: 	                        ? binder.macro_binding->Bind(colref, depth)
51: 	                        : binder.bind_context.BindColumn(colref, depth);
52: 	if (!result.HasError()) {
53: 		BoundColumnReferenceInfo ref;
54: 		ref.name = colref.column_name;
55: 		ref.query_location = colref.query_location;
56: 		bound_columns.push_back(move(ref));
57: 	} else {
58: 		result.error = binder.FormatError(colref, result.error);
59: 	}
60: 	return result;
61: }
62: 
63: } // namespace duckdb
[end of src/planner/binder/expression/bind_columnref_expression.cpp]
[start of src/planner/binder/expression/bind_macro_expression.cpp]
1: #include "duckdb/catalog/catalog_entry/macro_catalog_entry.hpp"
2: #include "duckdb/parser/expression/function_expression.hpp"
3: #include "duckdb/parser/expression/subquery_expression.hpp"
4: #include "duckdb/parser/parsed_expression_iterator.hpp"
5: #include "duckdb/parser/query_node.hpp"
6: #include "duckdb/parser/query_node/recursive_cte_node.hpp"
7: #include "duckdb/parser/query_node/select_node.hpp"
8: #include "duckdb/parser/query_node/set_operation_node.hpp"
9: #include "duckdb/parser/tableref/list.hpp"
10: #include "duckdb/planner/expression_binder.hpp"
11: #include "duckdb/common/string_util.hpp"
12: 
13: namespace duckdb {
14: 
15: void ExpressionBinder::ReplaceMacroParametersRecursive(unique_ptr<ParsedExpression> &expr) {
16: 	switch (expr->GetExpressionClass()) {
17: 	case ExpressionClass::COLUMN_REF: {
18: 		// if expr is a parameter, replace it with its argument
19: 		auto &colref = (ColumnRefExpression &)*expr;
20: 		if (colref.table_name.empty() && macro_binding->HasMatchingBinding(colref.column_name)) {
21: 			expr = macro_binding->ParamToArg(colref);
22: 		}
23: 		return;
24: 	}
25: 	case ExpressionClass::SUBQUERY: {
26: 		// replacing parameters within a subquery is slightly different
27: 		auto &sq = ((SubqueryExpression &)*expr).subquery;
28: 		ReplaceMacroParametersRecursive(*expr, *sq->node);
29: 		break;
30: 	}
31: 	default: // fall through
32: 		break;
33: 	}
34: 	// unfold child expressions
35: 	ParsedExpressionIterator::EnumerateChildren(
36: 	    *expr, [&](unique_ptr<ParsedExpression> &child) { ReplaceMacroParametersRecursive(child); });
37: }
38: 
39: void ExpressionBinder::ReplaceMacroParametersRecursive(ParsedExpression &expr, TableRef &ref) {
40: 	switch (ref.type) {
41: 	case TableReferenceType::CROSS_PRODUCT: {
42: 		auto &cp_ref = (CrossProductRef &)ref;
43: 		ReplaceMacroParametersRecursive(expr, *cp_ref.left);
44: 		ReplaceMacroParametersRecursive(expr, *cp_ref.right);
45: 		break;
46: 	}
47: 	case TableReferenceType::EXPRESSION_LIST: {
48: 		auto &el_ref = (ExpressionListRef &)ref;
49: 		for (idx_t i = 0; i < el_ref.values.size(); i++) {
50: 			for (idx_t j = 0; j < el_ref.values[i].size(); j++) {
51: 				ReplaceMacroParametersRecursive(el_ref.values[i][j]);
52: 			}
53: 		}
54: 		break;
55: 	}
56: 	case TableReferenceType::JOIN: {
57: 		auto &j_ref = (JoinRef &)ref;
58: 		ReplaceMacroParametersRecursive(expr, *j_ref.left);
59: 		ReplaceMacroParametersRecursive(expr, *j_ref.right);
60: 		ReplaceMacroParametersRecursive(j_ref.condition);
61: 		break;
62: 	}
63: 	case TableReferenceType::SUBQUERY: {
64: 		auto &sq_ref = (SubqueryRef &)ref;
65: 		ReplaceMacroParametersRecursive(expr, *sq_ref.subquery->node);
66: 		break;
67: 	}
68: 	case TableReferenceType::TABLE_FUNCTION: {
69: 		auto &tf_ref = (TableFunctionRef &)ref;
70: 		ReplaceMacroParametersRecursive(tf_ref.function);
71: 		break;
72: 	}
73: 	case TableReferenceType::BASE_TABLE:
74: 	case TableReferenceType::EMPTY:
75: 		// these TableRefs do not need to be unfolded
76: 		break;
77: 	default:
78: 		throw NotImplementedException("TableRef type not implemented for macro's!");
79: 	}
80: }
81: 
82: void ExpressionBinder::ReplaceMacroParametersRecursive(ParsedExpression &expr, QueryNode &node) {
83: 	switch (node.type) {
84: 	case QueryNodeType::RECURSIVE_CTE_NODE: {
85: 		auto &rcte_node = (RecursiveCTENode &)node;
86: 		ReplaceMacroParametersRecursive(expr, *rcte_node.left);
87: 		ReplaceMacroParametersRecursive(expr, *rcte_node.right);
88: 		break;
89: 	}
90: 	case QueryNodeType::SELECT_NODE: {
91: 		auto &sel_node = (SelectNode &)node;
92: 		for (idx_t i = 0; i < sel_node.select_list.size(); i++) {
93: 			ReplaceMacroParametersRecursive(sel_node.select_list[i]);
94: 		}
95: 		for (idx_t i = 0; i < sel_node.groups.group_expressions.size(); i++) {
96: 			ReplaceMacroParametersRecursive(sel_node.groups.group_expressions[i]);
97: 		}
98: 		if (sel_node.where_clause != nullptr) {
99: 			ReplaceMacroParametersRecursive(sel_node.where_clause);
100: 		}
101: 		if (sel_node.having != nullptr) {
102: 			ReplaceMacroParametersRecursive(sel_node.having);
103: 		}
104: 
105: 		ReplaceMacroParametersRecursive(expr, *sel_node.from_table.get());
106: 		break;
107: 	}
108: 	case QueryNodeType::SET_OPERATION_NODE: {
109: 		auto &setop_node = (SetOperationNode &)node;
110: 		ReplaceMacroParametersRecursive(expr, *setop_node.left);
111: 		ReplaceMacroParametersRecursive(expr, *setop_node.right);
112: 		break;
113: 	}
114: 	default:
115: 		throw NotImplementedException("QueryNode type not implemented for macro's!");
116: 	}
117: 	for (auto &kv : node.cte_map) {
118: 		ReplaceMacroParametersRecursive(expr, *kv.second->query->node);
119: 	}
120: }
121: 
122: BindResult ExpressionBinder::BindMacro(FunctionExpression &function, MacroCatalogEntry *macro_func, idx_t depth,
123:                                        unique_ptr<ParsedExpression> *expr) {
124: 	auto &macro_def = *macro_func->function;
125: 	// validate the arguments and separate positional and default arguments
126: 	vector<unique_ptr<ParsedExpression>> positionals;
127: 	unordered_map<string, unique_ptr<ParsedExpression>> defaults;
128: 	string error = MacroFunction::ValidateArguments(*macro_func, function, positionals, defaults);
129: 	if (!error.empty()) {
130: 		return BindResult(binder.FormatError(*expr->get(), error));
131: 	}
132: 
133: 	// create a MacroBinding to bind this macro's parameters to its arguments
134: 	vector<LogicalType> types;
135: 	vector<string> names;
136: 	// positional parameters
137: 	for (idx_t i = 0; i < macro_def.parameters.size(); i++) {
138: 		types.push_back(LogicalType::SQLNULL);
139: 		auto &param = (ColumnRefExpression &)*macro_def.parameters[i];
140: 		names.push_back(param.column_name);
141: 	}
142: 	// default parameters
143: 	for (auto it = macro_def.default_parameters.begin(); it != macro_def.default_parameters.end(); it++) {
144: 		types.push_back(LogicalType::SQLNULL);
145: 		names.push_back(it->first);
146: 		// now push the defaults into the positionals
147: 		positionals.push_back(move(defaults[it->first]));
148: 	}
149: 	auto new_macro_binding = make_unique<MacroBinding>(types, names, macro_func->name);
150: 	new_macro_binding->arguments = move(positionals);
151: 	macro_binding = new_macro_binding.get();
152: 
153: 	// replace current expression with stored macro expression, and replace params
154: 	*expr = macro_func->function->expression->Copy();
155: 	ReplaceMacroParametersRecursive(*expr);
156: 
157: 	// bind the unfolded macro
158: 	return BindExpression(expr, depth);
159: }
160: 
161: } // namespace duckdb
[end of src/planner/binder/expression/bind_macro_expression.cpp]
[start of src/planner/binder/query_node/bind_select_node.cpp]
1: #include "duckdb/common/limits.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/main/config.hpp"
5: #include "duckdb/parser/expression/columnref_expression.hpp"
6: #include "duckdb/parser/expression/comparison_expression.hpp"
7: #include "duckdb/parser/expression/constant_expression.hpp"
8: #include "duckdb/parser/expression/subquery_expression.hpp"
9: #include "duckdb/parser/query_node/select_node.hpp"
10: #include "duckdb/parser/tableref/joinref.hpp"
11: #include "duckdb/planner/binder.hpp"
12: #include "duckdb/planner/expression_binder/column_alias_binder.hpp"
13: #include "duckdb/planner/expression_binder/constant_binder.hpp"
14: #include "duckdb/planner/expression_binder/group_binder.hpp"
15: #include "duckdb/planner/expression_binder/having_binder.hpp"
16: #include "duckdb/planner/expression_binder/order_binder.hpp"
17: #include "duckdb/planner/expression_binder/select_binder.hpp"
18: #include "duckdb/planner/expression_binder/where_binder.hpp"
19: #include "duckdb/planner/query_node/bound_select_node.hpp"
20: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
21: 
22: namespace duckdb {
23: 
24: unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {
25: 	// we treat the Distinct list as a order by
26: 	auto bound_expr = order_binder.Bind(move(expr));
27: 	if (!bound_expr) {
28: 		// DISTINCT ON non-integer constant
29: 		// remove the expression from the DISTINCT ON list
30: 		return nullptr;
31: 	}
32: 	D_ASSERT(bound_expr->type == ExpressionType::BOUND_COLUMN_REF);
33: 	return bound_expr;
34: }
35: 
36: unique_ptr<Expression> Binder::BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,
37:                                              int64_t &delimiter_value) {
38: 	auto new_binder = Binder::CreateBinder(context, this, true);
39: 	ExpressionBinder expr_binder(*new_binder, context);
40: 	expr_binder.target_type = LogicalType::UBIGINT;
41: 	auto expr = expr_binder.Bind(delimiter);
42: 	if (expr->IsFoldable()) {
43: 		//! this is a constant
44: 		Value value = ExpressionExecutor::EvaluateScalar(*expr).CastAs(LogicalType::BIGINT);
45: 		delimiter_value = value.GetValue<int64_t>();
46: 		return nullptr;
47: 	}
48: 	return expr;
49: }
50: 
51: unique_ptr<BoundResultModifier> Binder::BindLimit(LimitModifier &limit_mod) {
52: 	auto result = make_unique<BoundLimitModifier>();
53: 	if (limit_mod.limit) {
54: 		result->limit = BindDelimiter(context, move(limit_mod.limit), result->limit_val);
55: 	}
56: 	if (limit_mod.offset) {
57: 		result->offset = BindDelimiter(context, move(limit_mod.offset), result->offset_val);
58: 	}
59: 	return move(result);
60: }
61: 
62: void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result) {
63: 	for (auto &mod : statement.modifiers) {
64: 		unique_ptr<BoundResultModifier> bound_modifier;
65: 		switch (mod->type) {
66: 		case ResultModifierType::DISTINCT_MODIFIER: {
67: 			auto &distinct = (DistinctModifier &)*mod;
68: 			auto bound_distinct = make_unique<BoundDistinctModifier>();
69: 			for (auto &distinct_on_target : distinct.distinct_on_targets) {
70: 				auto expr = BindOrderExpression(order_binder, move(distinct_on_target));
71: 				if (!expr) {
72: 					continue;
73: 				}
74: 				bound_distinct->target_distincts.push_back(move(expr));
75: 			}
76: 			bound_modifier = move(bound_distinct);
77: 			break;
78: 		}
79: 		case ResultModifierType::ORDER_MODIFIER: {
80: 			auto &order = (OrderModifier &)*mod;
81: 			auto bound_order = make_unique<BoundOrderModifier>();
82: 			auto &config = DBConfig::GetConfig(context);
83: 			for (auto &order_node : order.orders) {
84: 				auto order_expression = BindOrderExpression(order_binder, move(order_node.expression));
85: 				if (!order_expression) {
86: 					continue;
87: 				}
88: 				auto type = order_node.type == OrderType::ORDER_DEFAULT ? config.default_order_type : order_node.type;
89: 				auto null_order = order_node.null_order == OrderByNullType::ORDER_DEFAULT ? config.default_null_order
90: 				                                                                          : order_node.null_order;
91: 				bound_order->orders.emplace_back(type, null_order, move(order_expression));
92: 			}
93: 			if (!bound_order->orders.empty()) {
94: 				bound_modifier = move(bound_order);
95: 			}
96: 			break;
97: 		}
98: 		case ResultModifierType::LIMIT_MODIFIER:
99: 			bound_modifier = BindLimit((LimitModifier &)*mod);
100: 			break;
101: 		default:
102: 			throw Exception("Unsupported result modifier");
103: 		}
104: 		if (bound_modifier) {
105: 			result.modifiers.push_back(move(bound_modifier));
106: 		}
107: 	}
108: }
109: 
110: void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index) {
111: 	for (auto &bound_mod : result.modifiers) {
112: 		switch (bound_mod->type) {
113: 		case ResultModifierType::DISTINCT_MODIFIER: {
114: 			auto &distinct = (BoundDistinctModifier &)*bound_mod;
115: 			if (distinct.target_distincts.empty()) {
116: 				// DISTINCT without a target: push references to the standard select list
117: 				for (idx_t i = 0; i < sql_types.size(); i++) {
118: 					distinct.target_distincts.push_back(
119: 					    make_unique<BoundColumnRefExpression>(sql_types[i], ColumnBinding(projection_index, i)));
120: 				}
121: 			} else {
122: 				// DISTINCT with target list: set types
123: 				for (auto &expr : distinct.target_distincts) {
124: 					D_ASSERT(expr->type == ExpressionType::BOUND_COLUMN_REF);
125: 					auto &bound_colref = (BoundColumnRefExpression &)*expr;
126: 					if (bound_colref.binding.column_index == INVALID_INDEX) {
127: 						throw BinderException("Ambiguous name in DISTINCT ON!");
128: 					}
129: 					D_ASSERT(bound_colref.binding.column_index < sql_types.size());
130: 					bound_colref.return_type = sql_types[bound_colref.binding.column_index];
131: 				}
132: 			}
133: 			for (auto &target_distinct : distinct.target_distincts) {
134: 				auto &bound_colref = (BoundColumnRefExpression &)*target_distinct;
135: 				auto sql_type = sql_types[bound_colref.binding.column_index];
136: 				if (sql_type.id() == LogicalTypeId::VARCHAR) {
137: 					target_distinct = ExpressionBinder::PushCollation(context, move(target_distinct),
138: 					                                                  StringType::GetCollation(sql_type), true);
139: 				}
140: 			}
141: 			break;
142: 		}
143: 		case ResultModifierType::ORDER_MODIFIER: {
144: 			auto &order = (BoundOrderModifier &)*bound_mod;
145: 			for (auto &order_node : order.orders) {
146: 				auto &expr = order_node.expression;
147: 				D_ASSERT(expr->type == ExpressionType::BOUND_COLUMN_REF);
148: 				auto &bound_colref = (BoundColumnRefExpression &)*expr;
149: 				if (bound_colref.binding.column_index == INVALID_INDEX) {
150: 					throw BinderException("Ambiguous name in ORDER BY!");
151: 				}
152: 				D_ASSERT(bound_colref.binding.column_index < sql_types.size());
153: 				auto sql_type = sql_types[bound_colref.binding.column_index];
154: 				bound_colref.return_type = sql_types[bound_colref.binding.column_index];
155: 				if (sql_type.id() == LogicalTypeId::VARCHAR) {
156: 					order_node.expression = ExpressionBinder::PushCollation(context, move(order_node.expression),
157: 					                                                        StringType::GetCollation(sql_type));
158: 				}
159: 			}
160: 			break;
161: 		}
162: 		default:
163: 			break;
164: 		}
165: 	}
166: }
167: 
168: unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
169: 	auto result = make_unique<BoundSelectNode>();
170: 	result->projection_index = GenerateTableIndex();
171: 	result->group_index = GenerateTableIndex();
172: 	result->aggregate_index = GenerateTableIndex();
173: 	result->groupings_index = GenerateTableIndex();
174: 	result->window_index = GenerateTableIndex();
175: 	result->unnest_index = GenerateTableIndex();
176: 	result->prune_index = GenerateTableIndex();
177: 
178: 	// first bind the FROM table statement
179: 	result->from_table = Bind(*statement.from_table);
180: 
181: 	// bind the sample clause
182: 	if (statement.sample) {
183: 		result->sample_options = move(statement.sample);
184: 	}
185: 
186: 	// visit the select list and expand any "*" statements
187: 	vector<unique_ptr<ParsedExpression>> new_select_list;
188: 	for (auto &select_element : statement.select_list) {
189: 		if (select_element->GetExpressionType() == ExpressionType::STAR) {
190: 			// * statement, expand to all columns from the FROM clause
191: 			bind_context.GenerateAllColumnExpressions((StarExpression &)*select_element, new_select_list);
192: 		} else {
193: 			// regular statement, add it to the list
194: 			new_select_list.push_back(move(select_element));
195: 		}
196: 	}
197: 	if (new_select_list.empty()) {
198: 		throw BinderException("SELECT list is empty after resolving * expressions!");
199: 	}
200: 	statement.select_list = move(new_select_list);
201: 
202: 	// create a mapping of (alias -> index) and a mapping of (Expression -> index) for the SELECT list
203: 	unordered_map<string, idx_t> alias_map;
204: 	expression_map_t<idx_t> projection_map;
205: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
206: 		auto &expr = statement.select_list[i];
207: 		result->names.push_back(expr->GetName());
208: 		ExpressionBinder::BindTableNames(*this, *expr);
209: 		if (!expr->alias.empty()) {
210: 			alias_map[expr->alias] = i;
211: 			result->names[i] = expr->alias;
212: 		}
213: 		projection_map[expr.get()] = i;
214: 		result->original_expressions.push_back(expr->Copy());
215: 	}
216: 	result->column_count = statement.select_list.size();
217: 
218: 	// first visit the WHERE clause
219: 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
220: 	if (statement.where_clause) {
221: 		ColumnAliasBinder alias_binder(*result, alias_map);
222: 		WhereBinder where_binder(*this, context, &alias_binder);
223: 		unique_ptr<ParsedExpression> condition = move(statement.where_clause);
224: 		result->where_clause = where_binder.Bind(condition);
225: 	}
226: 
227: 	// now bind all the result modifiers; including DISTINCT and ORDER BY targets
228: 	OrderBinder order_binder({this}, result->projection_index, statement, alias_map, projection_map);
229: 	BindModifiers(order_binder, statement, *result);
230: 
231: 	vector<unique_ptr<ParsedExpression>> unbound_groups;
232: 	BoundGroupInformation info;
233: 	auto &group_expressions = statement.groups.group_expressions;
234: 	if (!group_expressions.empty()) {
235: 		// the statement has a GROUP BY clause, bind it
236: 		unbound_groups.resize(group_expressions.size());
237: 		GroupBinder group_binder(*this, context, statement, result->group_index, alias_map, info.alias_map);
238: 		for (idx_t i = 0; i < group_expressions.size(); i++) {
239: 
240: 			// we keep a copy of the unbound expression;
241: 			// we keep the unbound copy around to check for group references in the SELECT and HAVING clause
242: 			// the reason we want the unbound copy is because we want to figure out whether an expression
243: 			// is a group reference BEFORE binding in the SELECT/HAVING binder
244: 			group_binder.unbound_expression = group_expressions[i]->Copy();
245: 			group_binder.bind_index = i;
246: 
247: 			// bind the groups
248: 			LogicalType group_type;
249: 			auto bound_expr = group_binder.Bind(group_expressions[i], &group_type);
250: 			D_ASSERT(bound_expr->return_type.id() != LogicalTypeId::INVALID);
251: 
252: 			// push a potential collation, if necessary
253: 			bound_expr =
254: 			    ExpressionBinder::PushCollation(context, move(bound_expr), StringType::GetCollation(group_type), true);
255: 			result->groups.group_expressions.push_back(move(bound_expr));
256: 
257: 			// in the unbound expression we DO bind the table names of any ColumnRefs
258: 			// we do this to make sure that "table.a" and "a" are treated the same
259: 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
260: 			// hence we convert "a" -> "test.a" in the unbound expression
261: 			unbound_groups[i] = move(group_binder.unbound_expression);
262: 			ExpressionBinder::BindTableNames(*this, *unbound_groups[i]);
263: 			info.map[unbound_groups[i].get()] = i;
264: 		}
265: 	}
266: 	result->groups.grouping_sets = move(statement.groups.grouping_sets);
267: 
268: 	// bind the HAVING clause, if any
269: 	if (statement.having) {
270: 		HavingBinder having_binder(*this, context, *result, info, alias_map);
271: 		ExpressionBinder::BindTableNames(*this, *statement.having, &alias_map);
272: 		result->having = having_binder.Bind(statement.having);
273: 	}
274: 
275: 	// after that, we bind to the SELECT list
276: 	SelectBinder select_binder(*this, context, *result, info);
277: 	vector<LogicalType> internal_sql_types;
278: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
279: 		LogicalType result_type;
280: 		auto expr = select_binder.Bind(statement.select_list[i], &result_type);
281: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES && select_binder.HasBoundColumns()) {
282: 			if (select_binder.BoundAggregates()) {
283: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
284: 			}
285: 			// we are forcing aggregates, and the node has columns bound
286: 			// this entry becomes a group
287: 			auto group_ref = make_unique<BoundColumnRefExpression>(
288: 			    expr->return_type, ColumnBinding(result->group_index, result->groups.group_expressions.size()));
289: 			result->groups.group_expressions.push_back(move(expr));
290: 			expr = move(group_ref);
291: 		}
292: 		result->select_list.push_back(move(expr));
293: 		if (i < result->column_count) {
294: 			result->types.push_back(result_type);
295: 		}
296: 		internal_sql_types.push_back(result_type);
297: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
298: 			select_binder.ResetBindings();
299: 		}
300: 	}
301: 	result->need_prune = result->select_list.size() > result->column_count;
302: 
303: 	// in the normal select binder, we bind columns as if there is no aggregation
304: 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
305: 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
306: 	// we choose the former one [CONTROVERSIAL: this is the PostgreSQL behavior]
307: 	if (!result->groups.group_expressions.empty() || !result->aggregates.empty() || statement.having ||
308: 	    !result->groups.grouping_sets.empty()) {
309: 		if (statement.aggregate_handling == AggregateHandling::NO_AGGREGATES_ALLOWED) {
310: 			throw BinderException("Aggregates cannot be present in a Project relation!");
311: 		} else if (statement.aggregate_handling == AggregateHandling::STANDARD_HANDLING) {
312: 			if (select_binder.HasBoundColumns()) {
313: 				auto &bound_columns = select_binder.GetBoundColumns();
314: 				throw BinderException(
315: 				    FormatError(bound_columns[0].query_location,
316: 				                "column \"%s\" must appear in the GROUP BY clause or be used in an aggregate function",
317: 				                bound_columns[0].name));
318: 			}
319: 		}
320: 	}
321: 
322: 	// now that the SELECT list is bound, we set the types of DISTINCT/ORDER BY expressions
323: 	BindModifierTypes(*result, internal_sql_types, result->projection_index);
324: 	return move(result);
325: }
326: 
327: } // namespace duckdb
[end of src/planner/binder/query_node/bind_select_node.cpp]
[start of src/planner/binder/statement/bind_create.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/catalog/catalog_search_path.hpp"
3: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
5: #include "duckdb/main/client_context.hpp"
6: #include "duckdb/main/database.hpp"
7: #include "duckdb/parser/expression/constant_expression.hpp"
8: #include "duckdb/parser/expression/subquery_expression.hpp"
9: #include "duckdb/parser/parsed_data/create_index_info.hpp"
10: #include "duckdb/parser/parsed_data/create_macro_info.hpp"
11: #include "duckdb/parser/parsed_data/create_view_info.hpp"
12: #include "duckdb/parser/parsed_expression_iterator.hpp"
13: #include "duckdb/parser/statement/create_statement.hpp"
14: #include "duckdb/planner/binder.hpp"
15: #include "duckdb/planner/bound_query_node.hpp"
16: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
17: #include "duckdb/planner/expression_binder/index_binder.hpp"
18: #include "duckdb/planner/expression_binder/select_binder.hpp"
19: #include "duckdb/planner/operator/logical_create.hpp"
20: #include "duckdb/planner/operator/logical_create_index.hpp"
21: #include "duckdb/planner/operator/logical_create_table.hpp"
22: #include "duckdb/planner/operator/logical_get.hpp"
23: #include "duckdb/planner/parsed_data/bound_create_function_info.hpp"
24: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
25: #include "duckdb/planner/query_node/bound_select_node.hpp"
26: #include "duckdb/planner/tableref/bound_basetableref.hpp"
27: 
28: namespace duckdb {
29: 
30: SchemaCatalogEntry *Binder::BindSchema(CreateInfo &info) {
31: 	if (info.schema.empty()) {
32: 		info.schema = info.temporary ? TEMP_SCHEMA : context.catalog_search_path->GetDefault();
33: 	}
34: 
35: 	if (!info.temporary) {
36: 		// non-temporary create: not read only
37: 		if (info.schema == TEMP_SCHEMA) {
38: 			throw ParserException("Only TEMPORARY table names can use the \"temp\" schema");
39: 		}
40: 		this->read_only = false;
41: 	} else {
42: 		if (info.schema != TEMP_SCHEMA) {
43: 			throw ParserException("TEMPORARY table names can *only* use the \"%s\" schema", TEMP_SCHEMA);
44: 		}
45: 	}
46: 	// fetch the schema in which we want to create the object
47: 	auto schema_obj = Catalog::GetCatalog(context).GetSchema(context, info.schema);
48: 	D_ASSERT(schema_obj->type == CatalogType::SCHEMA_ENTRY);
49: 	info.schema = schema_obj->name;
50: 	return schema_obj;
51: }
52: 
53: void Binder::BindCreateViewInfo(CreateViewInfo &base) {
54: 	// bind the view as if it were a query so we can catch errors
55: 	// note that we bind the original, and replace the original with a copy
56: 	// this is because the original has
57: 	this->can_contain_nulls = true;
58: 
59: 	auto copy = base.query->Copy();
60: 	auto query_node = Bind(*base.query);
61: 	base.query = unique_ptr_cast<SQLStatement, SelectStatement>(move(copy));
62: 	if (base.aliases.size() > query_node.names.size()) {
63: 		throw BinderException("More VIEW aliases than columns in query result");
64: 	}
65: 	// fill up the aliases with the remaining names of the bound query
66: 	for (idx_t i = base.aliases.size(); i < query_node.names.size(); i++) {
67: 		base.aliases.push_back(query_node.names[i]);
68: 	}
69: 	base.types = query_node.types;
70: }
71: 
72: SchemaCatalogEntry *Binder::BindCreateFunctionInfo(CreateInfo &info) {
73: 	auto &base = (CreateMacroInfo &)info;
74: 
75: 	if (base.function->expression->HasParameter()) {
76: 		throw BinderException("Parameter expressions within macro's are not supported!");
77: 	}
78: 
79: 	// create macro binding in order to bind the function
80: 	vector<LogicalType> dummy_types;
81: 	vector<string> dummy_names;
82: 	// positional parameters
83: 	for (idx_t i = 0; i < base.function->parameters.size(); i++) {
84: 		auto param = (ColumnRefExpression &)*base.function->parameters[i];
85: 		if (!param.table_name.empty()) {
86: 			throw BinderException("Invalid parameter name '%s'", param.ToString());
87: 		}
88: 		dummy_types.push_back(LogicalType::SQLNULL);
89: 		dummy_names.push_back(param.column_name);
90: 	}
91: 	// default parameters
92: 	for (auto it = base.function->default_parameters.begin(); it != base.function->default_parameters.end(); it++) {
93: 		auto &val = (ConstantExpression &)*it->second;
94: 		dummy_types.push_back(val.value.type());
95: 		dummy_names.push_back(it->first);
96: 	}
97: 	auto this_macro_binding = make_unique<MacroBinding>(dummy_types, dummy_names, base.name);
98: 	macro_binding = this_macro_binding.get();
99: 
100: 	// create a copy of the expression because we do not want to alter the original
101: 	auto expression = base.function->expression->Copy();
102: 
103: 	// bind it to verify the function was defined correctly
104: 	string error;
105: 	auto sel_node = make_unique<BoundSelectNode>();
106: 	auto group_info = make_unique<BoundGroupInformation>();
107: 	SelectBinder binder(*this, context, *sel_node, *group_info);
108: 	error = binder.Bind(&expression, 0, false);
109: 
110: 	if (!error.empty()) {
111: 		throw BinderException(error);
112: 	}
113: 
114: 	return BindSchema(info);
115: }
116: 
117: void Binder::BindLogicalType(ClientContext &context, LogicalType &type, const string &schema) {
118: 	if (type.id() == LogicalTypeId::LIST) {
119: 		auto child_type = ListType::GetChildType(type);
120: 		BindLogicalType(context, child_type, schema);
121: 		type = LogicalType::LIST(child_type);
122: 	} else if (type.id() == LogicalTypeId::STRUCT || type.id() == LogicalTypeId::MAP) {
123: 		auto child_types = StructType::GetChildTypes(type);
124: 		for (auto &child_type : child_types) {
125: 			BindLogicalType(context, child_type.second, schema);
126: 		}
127: 		// Generate new Struct/Map Type
128: 		if (type.id() == LogicalTypeId::STRUCT) {
129: 			type = LogicalType::STRUCT(child_types);
130: 		} else {
131: 			type = LogicalType::MAP(child_types);
132: 		}
133: 	} else if (type.id() == LogicalTypeId::USER) {
134: 		auto &user_type_name = UserType::GetTypeName(type);
135: 		auto user_type_catalog = (TypeCatalogEntry *)context.db->GetCatalog().GetEntry(context, CatalogType::TYPE_ENTRY,
136: 		                                                                               schema, user_type_name, true);
137: 		if (!user_type_catalog) {
138: 			throw NotImplementedException("DataType %s not supported yet...\n", user_type_name);
139: 		}
140: 		type = *user_type_catalog->user_type;
141: 		EnumType::SetCatalog(type, user_type_catalog);
142: 	} else if (type.id() == LogicalTypeId::ENUM) {
143: 		auto &enum_type_name = EnumType::GetTypeName(type);
144: 		auto enum_type_catalog = (TypeCatalogEntry *)context.db->GetCatalog().GetEntry(context, CatalogType::TYPE_ENTRY,
145: 		                                                                               schema, enum_type_name, true);
146: 		EnumType::SetCatalog(type, enum_type_catalog);
147: 	}
148: }
149: 
150: BoundStatement Binder::Bind(CreateStatement &stmt) {
151: 	BoundStatement result;
152: 	result.names = {"Count"};
153: 	result.types = {LogicalType::BIGINT};
154: 
155: 	auto catalog_type = stmt.info->type;
156: 	switch (catalog_type) {
157: 	case CatalogType::SCHEMA_ENTRY:
158: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_SCHEMA, move(stmt.info));
159: 		break;
160: 	case CatalogType::VIEW_ENTRY: {
161: 		auto &base = (CreateViewInfo &)*stmt.info;
162: 		// bind the schema
163: 		auto schema = BindSchema(*stmt.info);
164: 		BindCreateViewInfo(base);
165: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_VIEW, move(stmt.info), schema);
166: 		break;
167: 	}
168: 	case CatalogType::SEQUENCE_ENTRY: {
169: 		auto schema = BindSchema(*stmt.info);
170: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_SEQUENCE, move(stmt.info), schema);
171: 		break;
172: 	}
173: 	case CatalogType::MACRO_ENTRY: {
174: 		auto schema = BindCreateFunctionInfo(*stmt.info);
175: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_MACRO, move(stmt.info), schema);
176: 		break;
177: 	}
178: 	case CatalogType::INDEX_ENTRY: {
179: 		auto &base = (CreateIndexInfo &)*stmt.info;
180: 
181: 		// visit the table reference
182: 		auto bound_table = Bind(*base.table);
183: 		if (bound_table->type != TableReferenceType::BASE_TABLE) {
184: 			throw BinderException("Can only delete from base table!");
185: 		}
186: 		auto &table_binding = (BoundBaseTableRef &)*bound_table;
187: 		auto table = table_binding.table;
188: 		// bind the index expressions
189: 		vector<unique_ptr<Expression>> expressions;
190: 		IndexBinder binder(*this, context);
191: 		for (auto &expr : base.expressions) {
192: 			expressions.push_back(binder.Bind(expr));
193: 		}
194: 
195: 		auto plan = CreatePlan(*bound_table);
196: 		if (plan->type != LogicalOperatorType::LOGICAL_GET) {
197: 			throw BinderException("Cannot create index on a view!");
198: 		}
199: 		auto &get = (LogicalGet &)*plan;
200: 		for (auto &column_id : get.column_ids) {
201: 			if (column_id == COLUMN_IDENTIFIER_ROW_ID) {
202: 				throw BinderException("Cannot create an index on the rowid!");
203: 			}
204: 		}
205: 		// this gives us a logical table scan
206: 		// we take the required columns from here
207: 		// create the logical operator
208: 		result.plan = make_unique<LogicalCreateIndex>(*table, get.column_ids, move(expressions),
209: 		                                              unique_ptr_cast<CreateInfo, CreateIndexInfo>(move(stmt.info)));
210: 		break;
211: 	}
212: 	case CatalogType::TABLE_ENTRY: {
213: 		// We first check if there are any user types, if yes we check to which custom types they refer.
214: 		auto bound_info = BindCreateTableInfo(move(stmt.info));
215: 		auto root = move(bound_info->query);
216: 
217: 		// create the logical operator
218: 		auto &schema = bound_info->schema;
219: 		auto create_table = make_unique<LogicalCreateTable>(schema, move(bound_info));
220: 		if (root) {
221: 			create_table->children.push_back(move(root));
222: 		}
223: 		result.plan = move(create_table);
224: 		break;
225: 	}
226: 	case CatalogType::TYPE_ENTRY: {
227: 		auto schema = BindSchema(*stmt.info);
228: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_TYPE, move(stmt.info), schema);
229: 		break;
230: 	}
231: 	default:
232: 		throw Exception("Unrecognized type!");
233: 	}
234: 	this->allow_stream_result = false;
235: 	return result;
236: }
237: 
238: } // namespace duckdb
[end of src/planner/binder/statement/bind_create.cpp]
[start of src/planner/binder/tableref/bind_table_function.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/parser/expression/function_expression.hpp"
3: #include "duckdb/parser/tableref/table_function_ref.hpp"
4: #include "duckdb/planner/binder.hpp"
5: #include "duckdb/parser/expression/columnref_expression.hpp"
6: #include "duckdb/parser/expression/comparison_expression.hpp"
7: #include "duckdb/planner/expression_binder/constant_binder.hpp"
8: #include "duckdb/planner/expression_binder/select_binder.hpp"
9: #include "duckdb/planner/operator/logical_get.hpp"
10: #include "duckdb/planner/tableref/bound_table_function.hpp"
11: #include "duckdb/planner/tableref/bound_subqueryref.hpp"
12: #include "duckdb/planner/query_node/bound_select_node.hpp"
13: #include "duckdb/execution/expression_executor.hpp"
14: #include "duckdb/common/algorithm.hpp"
15: #include "duckdb/parser/expression/subquery_expression.hpp"
16: 
17: namespace duckdb {
18: 
19: bool Binder::BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
20:                                     vector<Value> &parameters, unordered_map<string, Value> &named_parameters,
21:                                     unique_ptr<BoundSubqueryRef> &subquery, string &error) {
22: 	bool seen_subquery = false;
23: 	for (auto &child : expressions) {
24: 		string parameter_name;
25: 
26: 		// hack to make named parameters work
27: 		if (child->type == ExpressionType::COMPARE_EQUAL) {
28: 			// comparison, check if the LHS is a columnref
29: 			auto &comp = (ComparisonExpression &)*child;
30: 			if (comp.left->type == ExpressionType::COLUMN_REF) {
31: 				auto &colref = (ColumnRefExpression &)*comp.left;
32: 				if (colref.table_name.empty()) {
33: 					parameter_name = colref.column_name;
34: 					child = move(comp.right);
35: 				}
36: 			}
37: 		}
38: 		if (child->type == ExpressionType::SUBQUERY) {
39: 			if (seen_subquery) {
40: 				error = "Table function can have at most one subquery parameter ";
41: 				return false;
42: 			}
43: 			auto binder = Binder::CreateBinder(this->context, this, true);
44: 			auto &se = (SubqueryExpression &)*child;
45: 			auto node = binder->BindNode(*se.subquery->node);
46: 			subquery = make_unique<BoundSubqueryRef>(move(binder), move(node));
47: 			seen_subquery = true;
48: 			arguments.emplace_back(LogicalTypeId::TABLE);
49: 			continue;
50: 		}
51: 		ConstantBinder binder(*this, context, "TABLE FUNCTION parameter");
52: 		LogicalType sql_type;
53: 		auto expr = binder.Bind(child, &sql_type);
54: 		if (!expr->IsFoldable()) {
55: 			error = "Table function requires a constant parameter";
56: 			return false;
57: 		}
58: 		auto constant = ExpressionExecutor::EvaluateScalar(*expr);
59: 		if (parameter_name.empty()) {
60: 			// unnamed parameter
61: 			if (!named_parameters.empty()) {
62: 				error = "Unnamed parameters cannot come after named parameters";
63: 				return false;
64: 			}
65: 			arguments.emplace_back(sql_type);
66: 			parameters.emplace_back(move(constant));
67: 		} else {
68: 			named_parameters[parameter_name] = move(constant);
69: 		}
70: 	}
71: 	return true;
72: }
73: 
74: unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {
75: 	QueryErrorContext error_context(root_statement, ref.query_location);
76: 	auto bind_index = GenerateTableIndex();
77: 
78: 	D_ASSERT(ref.function->type == ExpressionType::FUNCTION);
79: 	auto fexpr = (FunctionExpression *)ref.function.get();
80: 
81: 	// evaluate the input parameters to the function
82: 	vector<LogicalType> arguments;
83: 	vector<Value> parameters;
84: 	unordered_map<string, Value> named_parameters;
85: 	unique_ptr<BoundSubqueryRef> subquery;
86: 	string error;
87: 	if (!BindFunctionParameters(fexpr->children, arguments, parameters, named_parameters, subquery, error)) {
88: 		throw BinderException(FormatError(ref, error));
89: 	}
90: 
91: 	// fetch the function from the catalog
92: 	auto &catalog = Catalog::GetCatalog(context);
93: 	auto function =
94: 	    catalog.GetEntry<TableFunctionCatalogEntry>(context, fexpr->schema, fexpr->function_name, false, error_context);
95: 
96: 	// select the function based on the input parameters
97: 	idx_t best_function_idx = Function::BindFunction(function->name, function->functions, arguments, error);
98: 	if (best_function_idx == INVALID_INDEX) {
99: 		throw BinderException(FormatError(ref, error));
100: 	}
101: 	auto &table_function = function->functions[best_function_idx];
102: 
103: 	// now check the named parameters
104: 	BindNamedParameters(table_function.named_parameters, named_parameters, error_context, table_function.name);
105: 
106: 	// cast the parameters to the type of the function
107: 	for (idx_t i = 0; i < arguments.size(); i++) {
108: 		if (table_function.arguments[i] != LogicalType::ANY && table_function.arguments[i] != LogicalType::TABLE &&
109: 		    table_function.arguments[i] != LogicalType::POINTER &&
110: 		    table_function.arguments[i].id() != LogicalTypeId::LIST) {
111: 			parameters[i] = parameters[i].CastAs(table_function.arguments[i]);
112: 		}
113: 	}
114: 
115: 	vector<LogicalType> input_table_types;
116: 	vector<string> input_table_names;
117: 
118: 	if (subquery) {
119: 		input_table_types = subquery->subquery->types;
120: 		input_table_names = subquery->subquery->names;
121: 	}
122: 
123: 	// perform the binding
124: 	unique_ptr<FunctionData> bind_data;
125: 	vector<LogicalType> return_types;
126: 	vector<string> return_names;
127: 	if (table_function.bind) {
128: 		bind_data = table_function.bind(context, parameters, named_parameters, input_table_types, input_table_names,
129: 		                                return_types, return_names);
130: 	}
131: 	D_ASSERT(return_types.size() == return_names.size());
132: 	D_ASSERT(return_types.size() > 0);
133: 	// overwrite the names with any supplied aliases
134: 	for (idx_t i = 0; i < ref.column_name_alias.size() && i < return_names.size(); i++) {
135: 		return_names[i] = ref.column_name_alias[i];
136: 	}
137: 	for (idx_t i = 0; i < return_names.size(); i++) {
138: 		if (return_names[i].empty()) {
139: 			return_names[i] = "C" + to_string(i);
140: 		}
141: 	}
142: 	auto get = make_unique<LogicalGet>(bind_index, table_function, move(bind_data), return_types, return_names);
143: 	// now add the table function to the bind context so its columns can be bound
144: 	bind_context.AddTableFunction(bind_index, ref.alias.empty() ? fexpr->function_name : ref.alias, return_names,
145: 	                              return_types, *get);
146: 	if (subquery) {
147: 		get->children.push_back(Binder::CreatePlan(*subquery));
148: 	}
149: 
150: 	return make_unique_base<BoundTableRef, BoundTableFunction>(move(get));
151: }
152: 
153: } // namespace duckdb
[end of src/planner/binder/tableref/bind_table_function.cpp]
[start of src/planner/expression_binder.cpp]
1: #include "duckdb/planner/expression_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/expression/positional_reference_expression.hpp"
5: #include "duckdb/parser/expression/subquery_expression.hpp"
6: #include "duckdb/parser/parsed_expression_iterator.hpp"
7: #include "duckdb/planner/binder.hpp"
8: #include "duckdb/planner/expression/bound_cast_expression.hpp"
9: #include "duckdb/planner/expression/bound_default_expression.hpp"
10: #include "duckdb/planner/expression/bound_parameter_expression.hpp"
11: #include "duckdb/planner/expression/bound_subquery_expression.hpp"
12: #include "duckdb/planner/expression_iterator.hpp"
13: 
14: namespace duckdb {
15: 
16: ExpressionBinder::ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder)
17:     : binder(binder), context(context), stored_binder(nullptr) {
18: 	if (replace_binder) {
19: 		stored_binder = binder.GetActiveBinder();
20: 		binder.SetActiveBinder(this);
21: 	} else {
22: 		binder.PushExpressionBinder(this);
23: 	}
24: }
25: 
26: ExpressionBinder::~ExpressionBinder() {
27: 	if (binder.HasActiveBinder()) {
28: 		if (stored_binder) {
29: 			binder.SetActiveBinder(stored_binder);
30: 		} else {
31: 			binder.PopExpressionBinder();
32: 		}
33: 	}
34: }
35: 
36: BindResult ExpressionBinder::BindExpression(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression) {
37: 	auto &expr_ref = **expr;
38: 	switch (expr_ref.expression_class) {
39: 	case ExpressionClass::BETWEEN:
40: 		return BindExpression((BetweenExpression &)expr_ref, depth);
41: 	case ExpressionClass::CASE:
42: 		return BindExpression((CaseExpression &)expr_ref, depth);
43: 	case ExpressionClass::CAST:
44: 		return BindExpression((CastExpression &)expr_ref, depth);
45: 	case ExpressionClass::COLLATE:
46: 		return BindExpression((CollateExpression &)expr_ref, depth);
47: 	case ExpressionClass::COLUMN_REF:
48: 		return BindExpression((ColumnRefExpression &)expr_ref, depth);
49: 	case ExpressionClass::COMPARISON:
50: 		return BindExpression((ComparisonExpression &)expr_ref, depth);
51: 	case ExpressionClass::CONJUNCTION:
52: 		return BindExpression((ConjunctionExpression &)expr_ref, depth);
53: 	case ExpressionClass::CONSTANT:
54: 		return BindExpression((ConstantExpression &)expr_ref, depth);
55: 	case ExpressionClass::FUNCTION:
56: 		// binding function expression has extra parameter needed for macro's
57: 		return BindExpression((FunctionExpression &)expr_ref, depth, expr);
58: 	case ExpressionClass::LAMBDA:
59: 		return BindExpression((LambdaExpression &)expr_ref, depth);
60: 	case ExpressionClass::OPERATOR:
61: 		return BindExpression((OperatorExpression &)expr_ref, depth);
62: 	case ExpressionClass::SUBQUERY:
63: 		return BindExpression((SubqueryExpression &)expr_ref, depth);
64: 	case ExpressionClass::PARAMETER:
65: 		return BindExpression((ParameterExpression &)expr_ref, depth);
66: 	case ExpressionClass::POSITIONAL_REFERENCE:
67: 		return BindExpression((PositionalReferenceExpression &)expr_ref, depth);
68: 	default:
69: 		throw NotImplementedException("Unimplemented expression class");
70: 	}
71: }
72: 
73: bool ExpressionBinder::BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr) {
74: 	// try to bind in one of the outer queries, if the binding error occurred in a subquery
75: 	auto &active_binders = binder.GetActiveBinders();
76: 	// make a copy of the set of binders, so we can restore it later
77: 	auto binders = active_binders;
78: 	active_binders.pop_back();
79: 	idx_t depth = 1;
80: 	bool success = false;
81: 	while (!active_binders.empty()) {
82: 		auto &next_binder = active_binders.back();
83: 		ExpressionBinder::BindTableNames(next_binder->binder, *expr);
84: 		auto bind_result = next_binder->Bind(&expr, depth);
85: 		if (bind_result.empty()) {
86: 			success = true;
87: 			break;
88: 		}
89: 		depth++;
90: 		active_binders.pop_back();
91: 	}
92: 	active_binders = binders;
93: 	return success;
94: }
95: 
96: void ExpressionBinder::BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, string &error) {
97: 	if (expr) {
98: 		string bind_error = Bind(&expr, depth);
99: 		if (error.empty()) {
100: 			error = bind_error;
101: 		}
102: 	}
103: }
104: 
105: void ExpressionBinder::ExtractCorrelatedExpressions(Binder &binder, Expression &expr) {
106: 	if (expr.type == ExpressionType::BOUND_COLUMN_REF) {
107: 		auto &bound_colref = (BoundColumnRefExpression &)expr;
108: 		if (bound_colref.depth > 0) {
109: 			binder.AddCorrelatedColumn(CorrelatedColumnInfo(bound_colref));
110: 		}
111: 	}
112: 	ExpressionIterator::EnumerateChildren(expr,
113: 	                                      [&](Expression &child) { ExtractCorrelatedExpressions(binder, child); });
114: }
115: 
116: bool ExpressionBinder::ContainsType(const LogicalType &type, LogicalTypeId target) {
117: 	if (type.id() == target) {
118: 		return true;
119: 	}
120: 	switch (type.id()) {
121: 	case LogicalTypeId::STRUCT:
122: 	case LogicalTypeId::MAP: {
123: 		auto child_count = StructType::GetChildCount(type);
124: 		for (idx_t i = 0; i < child_count; i++) {
125: 			if (ContainsType(StructType::GetChildType(type, i), target)) {
126: 				return true;
127: 			}
128: 		}
129: 		return false;
130: 	}
131: 	case LogicalTypeId::LIST:
132: 		return ContainsType(ListType::GetChildType(type), target);
133: 	default:
134: 		return false;
135: 	}
136: }
137: 
138: LogicalType ExpressionBinder::ExchangeType(const LogicalType &type, LogicalTypeId target, LogicalType new_type) {
139: 	if (type.id() == target) {
140: 		return new_type;
141: 	}
142: 	switch (type.id()) {
143: 	case LogicalTypeId::STRUCT:
144: 	case LogicalTypeId::MAP: {
145: 		// we make a copy of the child types of the struct here
146: 		auto child_types = StructType::GetChildTypes(type);
147: 		for (auto &child_type : child_types) {
148: 			child_type.second = ExchangeType(child_type.second, target, new_type);
149: 		}
150: 		return type.id() == LogicalTypeId::MAP ? LogicalType::MAP(move(child_types))
151: 		                                       : LogicalType::STRUCT(move(child_types));
152: 	}
153: 	case LogicalTypeId::LIST:
154: 		return LogicalType::LIST(ExchangeType(ListType::GetChildType(type), target, new_type));
155: 	default:
156: 		return type;
157: 	}
158: }
159: 
160: bool ExpressionBinder::ContainsNullType(const LogicalType &type) {
161: 	return ContainsType(type, LogicalTypeId::SQLNULL);
162: }
163: 
164: LogicalType ExpressionBinder::ExchangeNullType(const LogicalType &type) {
165: 	return ExchangeType(type, LogicalTypeId::SQLNULL, LogicalType::INTEGER);
166: }
167: 
168: void ExpressionBinder::ResolveParameterType(LogicalType &type) {
169: 	if (type.id() == LogicalTypeId::UNKNOWN) {
170: 		type = LogicalType::VARCHAR;
171: 	}
172: }
173: 
174: void ExpressionBinder::ResolveParameterType(unique_ptr<Expression> &expr) {
175: 	if (ContainsType(expr->return_type, LogicalTypeId::UNKNOWN)) {
176: 		auto result_type = ExchangeType(expr->return_type, LogicalTypeId::UNKNOWN, LogicalType::VARCHAR);
177: 		expr = BoundCastExpression::AddCastToType(move(expr), result_type);
178: 	}
179: }
180: 
181: unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr, LogicalType *result_type,
182:                                               bool root_expression) {
183: 	// bind the main expression
184: 	auto error_msg = Bind(&expr, 0, root_expression);
185: 	if (!error_msg.empty()) {
186: 		// failed to bind: try to bind correlated columns in the expression (if any)
187: 		bool success = BindCorrelatedColumns(expr);
188: 		if (!success) {
189: 			throw BinderException(error_msg);
190: 		}
191: 		auto bound_expr = (BoundExpression *)expr.get();
192: 		ExtractCorrelatedExpressions(binder, *bound_expr->expr);
193: 	}
194: 	D_ASSERT(expr->expression_class == ExpressionClass::BOUND_EXPRESSION);
195: 	auto bound_expr = (BoundExpression *)expr.get();
196: 	unique_ptr<Expression> result = move(bound_expr->expr);
197: 	if (target_type.id() != LogicalTypeId::INVALID) {
198: 		// the binder has a specific target type: add a cast to that type
199: 		result = BoundCastExpression::AddCastToType(move(result), target_type);
200: 	} else {
201: 		if (!binder.can_contain_nulls) {
202: 			// SQL NULL type is only used internally in the binder
203: 			// cast to INTEGER if we encounter it outside of the binder
204: 			if (ContainsNullType(result->return_type)) {
205: 				auto result_type = ExchangeNullType(result->return_type);
206: 				result = BoundCastExpression::AddCastToType(move(result), result_type);
207: 			}
208: 		}
209: 		// check if we failed to convert any parameters
210: 		// if we did, we push a cast
211: 		ExpressionBinder::ResolveParameterType(result);
212: 	}
213: 	if (result_type) {
214: 		*result_type = result->return_type;
215: 	}
216: 	return result;
217: }
218: 
219: string ExpressionBinder::Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression) {
220: 	// bind the node, but only if it has not been bound yet
221: 	auto &expression = **expr;
222: 	auto alias = expression.alias;
223: 	if (expression.GetExpressionClass() == ExpressionClass::BOUND_EXPRESSION) {
224: 		// already bound, don't bind it again
225: 		return string();
226: 	}
227: 	// bind the expression
228: 	BindResult result = BindExpression(expr, depth, root_expression);
229: 	if (result.HasError()) {
230: 		return result.error;
231: 	} else {
232: 		// successfully bound: replace the node with a BoundExpression
233: 		*expr = make_unique<BoundExpression>(move(result.expression));
234: 		auto be = (BoundExpression *)expr->get();
235: 		D_ASSERT(be);
236: 		be->alias = alias;
237: 		if (!alias.empty()) {
238: 			be->expr->alias = alias;
239: 		}
240: 		return string();
241: 	}
242: }
243: 
244: void ExpressionBinder::BindTableNames(Binder &binder, ParsedExpression &expr, unordered_map<string, idx_t> *alias_map) {
245: 	if (expr.type == ExpressionType::COLUMN_REF) {
246: 		auto &colref = (ColumnRefExpression &)expr;
247: 		if (colref.table_name.empty()) {
248: 			// no table name: find a binding that contains this
249: 			if (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {
250: 				// macro parameters get priority
251: 				colref.table_name = binder.macro_binding->alias;
252: 			} else {
253: 				colref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);
254: 			}
255: 		}
256: 		binder.bind_context.BindColumn(colref, 0);
257: 	} else if (expr.type == ExpressionType::POSITIONAL_REFERENCE) {
258: 		auto &ref = (PositionalReferenceExpression &)expr;
259: 		if (ref.alias.empty()) {
260: 			string table_name, column_name;
261: 			auto error = binder.bind_context.BindColumn(ref, table_name, column_name);
262: 			if (error.empty()) {
263: 				ref.alias = column_name;
264: 			}
265: 		}
266: 	}
267: 	ParsedExpressionIterator::EnumerateChildren(
268: 	    expr, [&](const ParsedExpression &child) { BindTableNames(binder, (ParsedExpression &)child, alias_map); });
269: }
270: 
271: } // namespace duckdb
[end of src/planner/expression_binder.cpp]
[start of src/planner/expression_binder/alter_binder.cpp]
1: #include "duckdb/planner/expression_binder/alter_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/planner/expression/bound_reference_expression.hpp"
5: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
6: 
7: namespace duckdb {
8: 
9: AlterBinder::AlterBinder(Binder &binder, ClientContext &context, TableCatalogEntry &table,
10:                          vector<column_t> &bound_columns, LogicalType target_type)
11:     : ExpressionBinder(binder, context), table(table), bound_columns(bound_columns) {
12: 	this->target_type = move(target_type);
13: }
14: 
15: BindResult AlterBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {
16: 	auto &expr = **expr_ptr;
17: 	switch (expr.GetExpressionClass()) {
18: 	case ExpressionClass::WINDOW:
19: 		return BindResult("window functions are not allowed in alter statement");
20: 	case ExpressionClass::SUBQUERY:
21: 		return BindResult("cannot use subquery in alter statement");
22: 	case ExpressionClass::COLUMN_REF:
23: 		return BindColumn((ColumnRefExpression &)expr);
24: 	default:
25: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
26: 	}
27: }
28: 
29: string AlterBinder::UnsupportedAggregateMessage() {
30: 	return "aggregate functions are not allowed in alter statement";
31: }
32: 
33: BindResult AlterBinder::BindColumn(ColumnRefExpression &colref) {
34: 	if (!colref.table_name.empty() && colref.table_name != table.name) {
35: 		throw BinderException("Cannot reference table %s from within alter statement for table %s!", colref.table_name,
36: 		                      table.name);
37: 	}
38: 	auto idx = table.GetColumnIndex(colref.column_name, true);
39: 	if (idx == INVALID_INDEX) {
40: 		throw BinderException("Table does not contain column %s referenced in alter statement!", colref.column_name);
41: 	}
42: 	bound_columns.push_back(idx);
43: 	return BindResult(make_unique<BoundReferenceExpression>(table.columns[idx].type, bound_columns.size() - 1));
44: }
45: 
46: } // namespace duckdb
[end of src/planner/expression_binder/alter_binder.cpp]
[start of src/planner/expression_binder/check_binder.cpp]
1: #include "duckdb/planner/expression_binder/check_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/planner/expression/bound_reference_expression.hpp"
5: 
6: namespace duckdb {
7: 
8: CheckBinder::CheckBinder(Binder &binder, ClientContext &context, string table, vector<ColumnDefinition> &columns,
9:                          unordered_set<column_t> &bound_columns)
10:     : ExpressionBinder(binder, context), table(move(table)), columns(columns), bound_columns(bound_columns) {
11: 	target_type = LogicalType::INTEGER;
12: }
13: 
14: BindResult CheckBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {
15: 	auto &expr = **expr_ptr;
16: 	switch (expr.GetExpressionClass()) {
17: 	case ExpressionClass::WINDOW:
18: 		return BindResult("window functions are not allowed in check constraints");
19: 	case ExpressionClass::SUBQUERY:
20: 		return BindResult("cannot use subquery in check constraint");
21: 	case ExpressionClass::COLUMN_REF:
22: 		return BindCheckColumn((ColumnRefExpression &)expr);
23: 	default:
24: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
25: 	}
26: }
27: 
28: string CheckBinder::UnsupportedAggregateMessage() {
29: 	return "aggregate functions are not allowed in check constraints";
30: }
31: 
32: BindResult CheckBinder::BindCheckColumn(ColumnRefExpression &colref) {
33: 	if (!colref.table_name.empty() && colref.table_name != table) {
34: 		throw BinderException("Cannot reference table %s from within check constraint for table %s!", colref.table_name,
35: 		                      table);
36: 	}
37: 	for (idx_t i = 0; i < columns.size(); i++) {
38: 		if (colref.column_name == columns[i].name) {
39: 			bound_columns.insert(i);
40: 			return BindResult(make_unique<BoundReferenceExpression>(columns[i].type, i));
41: 		}
42: 	}
43: 	throw BinderException("Table does not contain column %s referenced in check constraint!", colref.column_name);
44: }
45: 
46: } // namespace duckdb
[end of src/planner/expression_binder/check_binder.cpp]
[start of src/planner/expression_binder/column_alias_binder.cpp]
1: #include "duckdb/planner/expression_binder/column_alias_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/planner/query_node/bound_select_node.hpp"
5: #include "duckdb/common/string_util.hpp"
6: 
7: namespace duckdb {
8: 
9: ColumnAliasBinder::ColumnAliasBinder(BoundSelectNode &node, const unordered_map<string, idx_t> &alias_map)
10:     : node(node), alias_map(alias_map), in_alias(false) {
11: }
12: 
13: BindResult ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,
14:                                         bool root_expression) {
15: 	if (!expr.table_name.empty()) {
16: 		return BindResult(StringUtil::Format("Alias %s cannot be qualified.", expr.ToString()));
17: 	}
18: 
19: 	auto alias_entry = alias_map.find(expr.column_name);
20: 	if (alias_entry == alias_map.end()) {
21: 		return BindResult(StringUtil::Format("Alias %s is not found.", expr.ToString()));
22: 	}
23: 
24: 	// found an alias: bind the alias expression
25: 	D_ASSERT(!in_alias);
26: 	auto expression = node.original_expressions[alias_entry->second]->Copy();
27: 	in_alias = true;
28: 	auto result = enclosing_binder.BindExpression(&expression, depth, root_expression);
29: 	in_alias = false;
30: 	return result;
31: }
32: 
33: } // namespace duckdb
[end of src/planner/expression_binder/column_alias_binder.cpp]
[start of src/planner/expression_binder/group_binder.cpp]
1: #include "duckdb/planner/expression_binder/group_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/expression/constant_expression.hpp"
5: #include "duckdb/parser/query_node/select_node.hpp"
6: #include "duckdb/planner/expression/bound_constant_expression.hpp"
7: #include "duckdb/common/to_string.hpp"
8: 
9: namespace duckdb {
10: 
11: GroupBinder::GroupBinder(Binder &binder, ClientContext &context, SelectNode &node, idx_t group_index,
12:                          unordered_map<string, idx_t> &alias_map, unordered_map<string, idx_t> &group_alias_map)
13:     : ExpressionBinder(binder, context), node(node), alias_map(alias_map), group_alias_map(group_alias_map),
14:       group_index(group_index) {
15: }
16: 
17: BindResult GroupBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {
18: 	auto &expr = **expr_ptr;
19: 	if (root_expression && depth == 0) {
20: 		switch (expr.expression_class) {
21: 		case ExpressionClass::COLUMN_REF:
22: 			return BindColumnRef((ColumnRefExpression &)expr);
23: 		case ExpressionClass::CONSTANT:
24: 			return BindConstant((ConstantExpression &)expr);
25: 		default:
26: 			break;
27: 		}
28: 	}
29: 	switch (expr.expression_class) {
30: 	case ExpressionClass::DEFAULT:
31: 		return BindResult("GROUP BY clause cannot contain DEFAULT clause");
32: 	case ExpressionClass::WINDOW:
33: 		return BindResult("GROUP BY clause cannot contain window functions!");
34: 	default:
35: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
36: 	}
37: }
38: 
39: string GroupBinder::UnsupportedAggregateMessage() {
40: 	return "GROUP BY clause cannot contain aggregates!";
41: }
42: 
43: BindResult GroupBinder::BindSelectRef(idx_t entry) {
44: 	if (used_aliases.find(entry) != used_aliases.end()) {
45: 		// the alias has already been bound to before!
46: 		// this happens if we group on the same alias twice
47: 		// e.g. GROUP BY k, k or GROUP BY 1, 1
48: 		// in this case, we can just replace the grouping with a constant since the second grouping has no effect
49: 		// (the constant grouping will be optimized out later)
50: 		return BindResult(make_unique<BoundConstantExpression>(Value::INTEGER(42)));
51: 	}
52: 	if (entry >= node.select_list.size()) {
53: 		throw BinderException("GROUP BY term out of range - should be between 1 and %d", (int)node.select_list.size());
54: 	}
55: 	// we replace the root expression, also replace the unbound expression
56: 	unbound_expression = node.select_list[entry]->Copy();
57: 	// move the expression that this refers to here and bind it
58: 	auto select_entry = move(node.select_list[entry]);
59: 	auto binding = Bind(select_entry, nullptr, false);
60: 	// now replace the original expression in the select list with a reference to this group
61: 	group_alias_map[to_string(entry)] = bind_index;
62: 	node.select_list[entry] = make_unique<ColumnRefExpression>(to_string(entry));
63: 	// insert into the set of used aliases
64: 	used_aliases.insert(entry);
65: 	return BindResult(move(binding));
66: }
67: 
68: BindResult GroupBinder::BindConstant(ConstantExpression &constant) {
69: 	// constant as root expression
70: 	if (!constant.value.type().IsIntegral()) {
71: 		// non-integral expression, we just leave the constant here.
72: 		return ExpressionBinder::BindExpression(constant, 0);
73: 	}
74: 	// INTEGER constant: we use the integer as an index into the select list (e.g. GROUP BY 1)
75: 	auto index = (idx_t)constant.value.GetValue<int64_t>();
76: 	return BindSelectRef(index - 1);
77: }
78: 
79: BindResult GroupBinder::BindColumnRef(ColumnRefExpression &colref) {
80: 	// columns in GROUP BY clauses:
81: 	// FIRST refer to the original tables, and
82: 	// THEN if no match is found refer to aliases in the SELECT list
83: 	// THEN if no match is found, refer to outer queries
84: 
85: 	// first try to bind to the base columns (original tables)
86: 	auto result = ExpressionBinder::BindExpression(colref, 0);
87: 	if (result.HasError()) {
88: 		// failed to bind the column and the node is the root expression with depth = 0
89: 		// check if refers to an alias in the select clause
90: 		auto alias_name = colref.column_name;
91: 		if (!colref.table_name.empty()) {
92: 			// explicit table name: not an alias reference
93: 			return result;
94: 		}
95: 		auto entry = alias_map.find(alias_name);
96: 		if (entry == alias_map.end()) {
97: 			// no matching alias found
98: 			return result;
99: 		}
100: 		result = BindResult(BindSelectRef(entry->second));
101: 		if (!result.HasError()) {
102: 			group_alias_map[alias_name] = bind_index;
103: 		}
104: 	}
105: 	return result;
106: }
107: 
108: } // namespace duckdb
[end of src/planner/expression_binder/group_binder.cpp]
[start of src/planner/expression_binder/order_binder.cpp]
1: #include "duckdb/planner/expression_binder/order_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/expression/positional_reference_expression.hpp"
5: #include "duckdb/parser/expression/constant_expression.hpp"
6: #include "duckdb/parser/query_node/select_node.hpp"
7: #include "duckdb/planner/expression_binder.hpp"
8: 
9: namespace duckdb {
10: 
11: OrderBinder::OrderBinder(vector<Binder *> binders, idx_t projection_index, unordered_map<string, idx_t> &alias_map,
12:                          expression_map_t<idx_t> &projection_map, idx_t max_count)
13:     : binders(move(binders)), projection_index(projection_index), max_count(max_count), extra_list(nullptr),
14:       alias_map(alias_map), projection_map(projection_map) {
15: }
16: OrderBinder::OrderBinder(vector<Binder *> binders, idx_t projection_index, SelectNode &node,
17:                          unordered_map<string, idx_t> &alias_map, expression_map_t<idx_t> &projection_map)
18:     : binders(move(binders)), projection_index(projection_index), alias_map(alias_map), projection_map(projection_map) {
19: 	this->max_count = node.select_list.size();
20: 	this->extra_list = &node.select_list;
21: }
22: 
23: unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &expr, idx_t index) {
24: 	return make_unique<BoundColumnRefExpression>(expr.GetName(), LogicalType::INVALID,
25: 	                                             ColumnBinding(projection_index, index));
26: }
27: 
28: unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {
29: 	// in the ORDER BY clause we do not bind children
30: 	// we bind ONLY to the select list
31: 	// if there is no matching entry in the SELECT list already, we add the expression to the SELECT list and refer the
32: 	// new expression the new entry will then be bound later during the binding of the SELECT list we also don't do type
33: 	// resolution here: this only happens after the SELECT list has been bound
34: 	switch (expr->expression_class) {
35: 	case ExpressionClass::CONSTANT: {
36: 		// ORDER BY constant
37: 		// is the ORDER BY expression a constant integer? (e.g. ORDER BY 1)
38: 		auto &constant = (ConstantExpression &)*expr;
39: 		// ORDER BY a constant
40: 		if (!constant.value.type().IsIntegral()) {
41: 			// non-integral expression, we just leave the constant here.
42: 			// ORDER BY <constant> has no effect
43: 			// CONTROVERSIAL: maybe we should throw an error
44: 			return nullptr;
45: 		}
46: 		// INTEGER constant: we use the integer as an index into the select list (e.g. ORDER BY 1)
47: 		auto index = (idx_t)constant.value.GetValue<int64_t>();
48: 		if (index < 1 || index > max_count) {
49: 			throw BinderException("ORDER term out of range - should be between 1 and %lld", (idx_t)max_count);
50: 		}
51: 		return CreateProjectionReference(*expr, index - 1);
52: 	}
53: 	case ExpressionClass::COLUMN_REF: {
54: 		// COLUMN REF expression
55: 		// check if we can bind it to an alias in the select list
56: 		auto &colref = (ColumnRefExpression &)*expr;
57: 		// if there is an explicit table name we can't bind to an alias
58: 		if (!colref.table_name.empty()) {
59: 			break;
60: 		}
61: 		// check the alias list
62: 		auto entry = alias_map.find(colref.column_name);
63: 		if (entry != alias_map.end()) {
64: 			// it does! point it to that entry
65: 			return CreateProjectionReference(*expr, entry->second);
66: 		}
67: 		break;
68: 	}
69: 	case ExpressionClass::POSITIONAL_REFERENCE: {
70: 		auto &posref = (PositionalReferenceExpression &)*expr;
71: 		return CreateProjectionReference(*expr, posref.index - 1);
72: 	}
73: 	default:
74: 		break;
75: 	}
76: 	// general case
77: 	// first bind the table names of this entry
78: 	for (auto &binder : binders) {
79: 		ExpressionBinder::BindTableNames(*binder, *expr);
80: 	}
81: 	// first check if the ORDER BY clause already points to an entry in the projection list
82: 	auto entry = projection_map.find(expr.get());
83: 	if (entry != projection_map.end()) {
84: 		if (entry->second == INVALID_INDEX) {
85: 			throw BinderException("Ambiguous reference to column");
86: 		}
87: 		// there is a matching entry in the projection list
88: 		// just point to that entry
89: 		return CreateProjectionReference(*expr, entry->second);
90: 	}
91: 	if (!extra_list) {
92: 		// no extra list specified: we cannot push an extra ORDER BY clause
93: 		throw BinderException("Could not ORDER BY column \"%s\": add the expression/function to every SELECT, or move "
94: 		                      "the UNION into a FROM clause.",
95: 		                      expr->ToString());
96: 	}
97: 	// otherwise we need to push the ORDER BY entry into the select list
98: 	auto result = CreateProjectionReference(*expr, extra_list->size());
99: 	extra_list->push_back(move(expr));
100: 	return result;
101: }
102: 
103: } // namespace duckdb
[end of src/planner/expression_binder/order_binder.cpp]
[start of src/planner/expression_binder/select_binder.cpp]
1: #include "duckdb/planner/expression_binder/select_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/expression/window_expression.hpp"
5: #include "duckdb/parser/parsed_expression_iterator.hpp"
6: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
7: #include "duckdb/planner/expression/bound_window_expression.hpp"
8: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
9: #include "duckdb/planner/query_node/bound_select_node.hpp"
10: #include "duckdb/parser/expression/operator_expression.hpp"
11: #include "duckdb/common/string_util.hpp"
12: #include "duckdb/planner/binder.hpp"
13: 
14: namespace duckdb {
15: 
16: SelectBinder::SelectBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info)
17:     : ExpressionBinder(binder, context), inside_window(false), node(node), info(info) {
18: }
19: 
20: BindResult SelectBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {
21: 	auto &expr = **expr_ptr;
22: 	// check if the expression binds to one of the groups
23: 	auto group_index = TryBindGroup(expr, depth);
24: 	if (group_index != INVALID_INDEX) {
25: 		return BindGroup(expr, depth, group_index);
26: 	}
27: 	switch (expr.expression_class) {
28: 	case ExpressionClass::DEFAULT:
29: 		return BindResult("SELECT clause cannot contain DEFAULT clause");
30: 	case ExpressionClass::WINDOW:
31: 		return BindWindow((WindowExpression &)expr, depth);
32: 	default:
33: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
34: 	}
35: }
36: 
37: idx_t SelectBinder::TryBindGroup(ParsedExpression &expr, idx_t depth) {
38: 	// first check the group alias map, if expr is a ColumnRefExpression
39: 	if (expr.type == ExpressionType::COLUMN_REF) {
40: 		auto &colref = (ColumnRefExpression &)expr;
41: 		if (colref.table_name.empty()) {
42: 			auto alias_entry = info.alias_map.find(colref.column_name);
43: 			if (alias_entry != info.alias_map.end()) {
44: 				// found entry!
45: 				return alias_entry->second;
46: 			}
47: 		}
48: 	}
49: 	// no alias reference found
50: 	// check the list of group columns for a match
51: 	auto entry = info.map.find(&expr);
52: 	if (entry != info.map.end()) {
53: 		return entry->second;
54: 	}
55: #ifdef DEBUG
56: 	for (auto entry : info.map) {
57: 		D_ASSERT(!entry.first->Equals(&expr));
58: 		D_ASSERT(!expr.Equals(entry.first));
59: 	}
60: #endif
61: 	return INVALID_INDEX;
62: }
63: 
64: BindResult SelectBinder::BindGroupingFunction(OperatorExpression &op, idx_t depth) {
65: 	if (op.children.empty()) {
66: 		throw InternalException("GROUPING requires at least one child");
67: 	}
68: 	if (node.groups.group_expressions.empty()) {
69: 		return BindResult(binder.FormatError(op, "GROUPING statement cannot be used without groups"));
70: 	}
71: 	if (op.children.size() >= 64) {
72: 		return BindResult(binder.FormatError(op, "GROUPING statement cannot have more than 64 groups"));
73: 	}
74: 	vector<idx_t> group_indexes;
75: 	group_indexes.reserve(op.children.size());
76: 	for (auto &child : op.children) {
77: 		ExpressionBinder::BindTableNames(binder, *child);
78: 		auto idx = TryBindGroup(*child, depth);
79: 		if (idx == INVALID_INDEX) {
80: 			return BindResult(binder.FormatError(
81: 			    op, StringUtil::Format("GROUPING child \"%s\" must be a grouping column", child->GetName())));
82: 		}
83: 		group_indexes.push_back(idx);
84: 	}
85: 	auto col_idx = node.grouping_functions.size();
86: 	node.grouping_functions.push_back(move(group_indexes));
87: 	return BindResult(make_unique<BoundColumnRefExpression>(op.GetName(), LogicalType::BIGINT,
88: 	                                                        ColumnBinding(node.groupings_index, col_idx), depth));
89: }
90: 
91: BindResult SelectBinder::BindGroup(ParsedExpression &expr, idx_t depth, idx_t group_index) {
92: 	auto &group = node.groups.group_expressions[group_index];
93: 	return BindResult(make_unique<BoundColumnRefExpression>(expr.GetName(), group->return_type,
94: 	                                                        ColumnBinding(node.group_index, group_index), depth));
95: }
96: 
97: } // namespace duckdb
[end of src/planner/expression_binder/select_binder.cpp]
[start of src/planner/operator/logical_get.cpp]
1: #include "duckdb/planner/operator/logical_get.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
4: #include "duckdb/storage/data_table.hpp"
5: #include "duckdb/planner/operator/logical_get.hpp"
6: #include "duckdb/common/string_util.hpp"
7: 
8: namespace duckdb {
9: 
10: LogicalGet::LogicalGet(idx_t table_index, TableFunction function, unique_ptr<FunctionData> bind_data,
11:                        vector<LogicalType> returned_types, vector<string> returned_names)
12:     : LogicalOperator(LogicalOperatorType::LOGICAL_GET), table_index(table_index), function(move(function)),
13:       bind_data(move(bind_data)), returned_types(move(returned_types)), names(move(returned_names)) {
14: }
15: 
16: string LogicalGet::GetName() const {
17: 	return StringUtil::Upper(function.name);
18: }
19: 
20: string LogicalGet::ParamsToString() const {
21: 	string result;
22: 	for (auto &kv : table_filters.filters) {
23: 		auto &column_index = kv.first;
24: 		auto &filter = kv.second;
25: 		if (column_index < names.size()) {
26: 			result += filter->ToString(names[column_index]);
27: 		}
28: 		result += "\n";
29: 	}
30: 	if (!function.to_string) {
31: 		return string();
32: 	}
33: 	return function.to_string(bind_data.get());
34: }
35: 
36: vector<ColumnBinding> LogicalGet::GetColumnBindings() {
37: 	if (column_ids.empty()) {
38: 		return {ColumnBinding(table_index, 0)};
39: 	}
40: 	vector<ColumnBinding> result;
41: 	for (idx_t i = 0; i < column_ids.size(); i++) {
42: 		result.emplace_back(table_index, i);
43: 	}
44: 	return result;
45: }
46: 
47: void LogicalGet::ResolveTypes() {
48: 	if (column_ids.empty()) {
49: 		column_ids.push_back(COLUMN_IDENTIFIER_ROW_ID);
50: 	}
51: 	for (auto &index : column_ids) {
52: 		if (index == COLUMN_IDENTIFIER_ROW_ID) {
53: 			types.push_back(LOGICAL_ROW_TYPE);
54: 		} else {
55: 			types.push_back(returned_types[index]);
56: 		}
57: 	}
58: }
59: 
60: idx_t LogicalGet::EstimateCardinality(ClientContext &context) {
61: 	if (function.cardinality) {
62: 		auto node_stats = function.cardinality(context, bind_data.get());
63: 		if (node_stats && node_stats->has_estimated_cardinality) {
64: 			return node_stats->estimated_cardinality;
65: 		}
66: 	}
67: 	return 1;
68: }
69: 
70: } // namespace duckdb
[end of src/planner/operator/logical_get.cpp]
[start of src/planner/table_binding.cpp]
1: #include "duckdb/planner/table_binding.hpp"
2: 
3: #include "duckdb/common/string_util.hpp"
4: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
6: #include "duckdb/parser/expression/columnref_expression.hpp"
7: #include "duckdb/parser/tableref/subqueryref.hpp"
8: #include "duckdb/planner/bind_context.hpp"
9: #include "duckdb/planner/bound_query_node.hpp"
10: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
11: #include "duckdb/planner/operator/logical_get.hpp"
12: 
13: namespace duckdb {
14: 
15: Binding::Binding(const string &alias, vector<LogicalType> coltypes, vector<string> colnames, idx_t index)
16:     : alias(alias), index(index), types(move(coltypes)), names(move(colnames)) {
17: 	D_ASSERT(types.size() == names.size());
18: 	for (idx_t i = 0; i < names.size(); i++) {
19: 		auto &name = names[i];
20: 		D_ASSERT(!name.empty());
21: 		if (name_map.find(name) != name_map.end()) {
22: 			throw BinderException("table \"%s\" has duplicate column name \"%s\"", alias, name);
23: 		}
24: 		name_map[name] = i;
25: 	}
26: }
27: 
28: bool Binding::TryGetBindingIndex(const string &column_name, column_t &result) {
29: 	auto entry = name_map.find(column_name);
30: 	if (entry != name_map.end()) {
31: 		result = entry->second;
32: 		return true;
33: 	}
34: 	return false;
35: }
36: 
37: bool Binding::HasMatchingBinding(const string &column_name) {
38: 	column_t result;
39: 	return TryGetBindingIndex(column_name, result);
40: }
41: 
42: BindResult Binding::Bind(ColumnRefExpression &colref, idx_t depth) {
43: 	column_t column_index;
44: 	if (!TryGetBindingIndex(colref.column_name, column_index)) {
45: 		return BindResult(StringUtil::Format("Values list \"%s\" does not have a column named \"%s\"", alias.c_str(),
46: 		                                     colref.column_name.c_str()));
47: 	}
48: 	ColumnBinding binding;
49: 	binding.table_index = index;
50: 	binding.column_index = column_index;
51: 	LogicalType sql_type = types[column_index];
52: 	if (colref.alias.empty()) {
53: 		colref.alias = names[column_index];
54: 	}
55: 	return BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), sql_type, binding, depth));
56: }
57: 
58: TableBinding::TableBinding(const string &alias, vector<LogicalType> types_p, vector<string> names_p, LogicalGet &get,
59:                            idx_t index, bool add_row_id)
60:     : Binding(alias, move(types_p), move(names_p), index), get(get) {
61: 	if (add_row_id) {
62: 		if (name_map.find("rowid") == name_map.end()) {
63: 			name_map["rowid"] = COLUMN_IDENTIFIER_ROW_ID;
64: 		}
65: 	}
66: }
67: 
68: BindResult TableBinding::Bind(ColumnRefExpression &colref, idx_t depth) {
69: 	column_t column_index;
70: 	if (!TryGetBindingIndex(colref.column_name, column_index)) {
71: 		return BindResult(StringUtil::Format("Table \"%s\" does not have a column named \"%s\"", colref.table_name,
72: 		                                     colref.column_name));
73: 	}
74: 	// fetch the type of the column
75: 	LogicalType col_type;
76: 	if (column_index == COLUMN_IDENTIFIER_ROW_ID) {
77: 		// row id: BIGINT type
78: 		col_type = LogicalType::BIGINT;
79: 	} else {
80: 		// normal column: fetch type from base column
81: 		col_type = types[column_index];
82: 		if (colref.alias.empty()) {
83: 			colref.alias = names[column_index];
84: 		}
85: 	}
86: 
87: 	auto &column_ids = get.column_ids;
88: 	// check if the entry already exists in the column list for the table
89: 	ColumnBinding binding;
90: 
91: 	binding.column_index = column_ids.size();
92: 	for (idx_t i = 0; i < column_ids.size(); i++) {
93: 		if (column_ids[i] == column_index) {
94: 			binding.column_index = i;
95: 			break;
96: 		}
97: 	}
98: 	if (binding.column_index == column_ids.size()) {
99: 		// column binding not found: add it to the list of bindings
100: 		column_ids.push_back(column_index);
101: 	}
102: 	binding.table_index = index;
103: 	return BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), col_type, binding, depth));
104: }
105: 
106: MacroBinding::MacroBinding(vector<LogicalType> types_p, vector<string> names_p, string macro_name_p)
107:     : Binding("0_macro_parameters", move(types_p), move(names_p), -1), macro_name(move(macro_name_p)) {
108: }
109: 
110: BindResult MacroBinding::Bind(ColumnRefExpression &colref, idx_t depth) {
111: 	column_t column_index;
112: 	if (!TryGetBindingIndex(colref.column_name, column_index)) {
113: 		return BindResult(
114: 		    StringUtil::Format("Macro \"%s\" does not have a parameter named \"%s\"", macro_name, colref.column_name));
115: 	}
116: 	ColumnBinding binding;
117: 	binding.table_index = index;
118: 	binding.column_index = column_index;
119: 
120: 	// we are binding a parameter to create the macro, no arguments are supplied
121: 	return BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), types[column_index], binding, depth));
122: }
123: 
124: unique_ptr<ParsedExpression> MacroBinding::ParamToArg(ColumnRefExpression &colref) {
125: 	column_t column_index;
126: 	if (!TryGetBindingIndex(colref.column_name, column_index)) {
127: 		throw BinderException("Macro \"%s\" does not have a parameter named \"%s\"", macro_name, colref.column_name);
128: 	}
129: 	auto arg = arguments[column_index]->Copy();
130: 	arg->alias = colref.alias;
131: 	return arg;
132: }
133: 
134: } // namespace duckdb
[end of src/planner/table_binding.cpp]
[start of src/storage/storage_info.cpp]
1: #include "duckdb/storage/storage_info.hpp"
2: 
3: namespace duckdb {
4: 
5: const uint64_t VERSION_NUMBER = 27;
6: 
7: } // namespace duckdb
[end of src/storage/storage_info.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: