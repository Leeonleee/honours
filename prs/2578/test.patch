diff --git a/test/sql/alter/alter_type/alter_type_struct.test b/test/sql/alter/alter_type/alter_type_struct.test
new file mode 100644
index 000000000000..0657bcde9d2d
--- /dev/null
+++ b/test/sql/alter/alter_type/alter_type_struct.test
@@ -0,0 +1,38 @@
+# name: test/sql/alter/alter_type/alter_type_struct.test
+# description: ALTER TYPE with multi column references
+# group: [alter_type]
+
+statement ok
+CREATE TABLE test AS SELECT {'t': 42} t
+
+query I
+SELECT * FROM test
+----
+{'t': 42}
+
+statement ok
+ALTER TABLE test ALTER t TYPE ROW(t VARCHAR) USING {'t': concat('hello', (test.t.t + 42)::varchar)}
+
+query I
+SELECT * FROM test
+----
+{'t': hello84}
+
+statement ok
+DROP TABLE test;
+
+statement ok
+CREATE TABLE test AS SELECT {'t': 42} t
+
+query I
+SELECT * FROM test
+----
+{'t': 42}
+
+statement ok
+ALTER TABLE test ALTER t TYPE ROW(t VARCHAR) USING {'t': concat('hello', (t.t + 42)::varchar)}
+
+query I
+SELECT * FROM test
+----
+{'t': hello84}
diff --git a/test/sql/catalog/function/struct_extract_macro.test b/test/sql/catalog/function/struct_extract_macro.test
new file mode 100644
index 000000000000..4b42af16e133
--- /dev/null
+++ b/test/sql/catalog/function/struct_extract_macro.test
@@ -0,0 +1,28 @@
+# name: test/sql/catalog/function/struct_extract_macro.test
+# description: Test struct extract on a macro
+# group: [function]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE MACRO my_extract(x) AS x.a.b
+
+query I
+SELECT my_extract({'a': {'b': 42}})
+----
+42
+
+mode skip
+# FIXME: this does not work yet due to the way in which macro functions are bound
+# as it is not trivial to fix, for now we leave it as is
+
+statement ok
+CREATE MACRO my_subquery_extract(x) AS (SELECT x.a.b);
+
+query I
+SELECT my_subquery_extract({'a': {'b': 42}})
+----
+42
+
+mode unskip
diff --git a/test/sql/catalog/function/test_simple_macro.test b/test/sql/catalog/function/test_simple_macro.test
index 8345e5060304..054c223a79a9 100644
--- a/test/sql/catalog/function/test_simple_macro.test
+++ b/test/sql/catalog/function/test_simple_macro.test
@@ -167,11 +167,10 @@ CREATE MACRO IFELSE(a,b) AS a+b
 statement error
 CREATE MACRO ifelse(a,b) AS a+b
 
-# TODO: uncomment when macro parameters are pushed as a projection
-#query T
-#SELECT IFELSE(1, 'random', RANDOM())
-#----
-#random
+query T
+SELECT IFELSE(1, 'random', RANDOM())
+----
+random
 
 # macro in a different schema
 statement ok
@@ -196,20 +195,18 @@ CREATE MACRO myavg(x) AS SUM(x) / COUNT(x)
 statement ok
 INSERT INTO integers VALUES (21), (41);
 
-# TODO: uncomment when macro parameters are pushed as a projection
-#query T
-#SELECT myavg(a) FROM integers
-#----
-#21
+query T
+SELECT myavg(a) FROM integers
+----
+21
 
 statement ok
 CREATE MACRO weird_avg(x) AS (MIN(x) + MAX(x)) / COUNT(x)
 
-# TODO: uncomment when macro parameters are pushed as a projection
-#query T
-#SELECT weird_avg(a) FROM integers
-#----
-#14
+query T
+SELECT weird_avg(a) FROM integers
+----
+14
 
 statement error
 CREATE MACRO star() AS *
@@ -277,3 +274,21 @@ SELECT two_default_params(a := 5, a := 3)
 
 statement error
 SELECT two_default_params(b := 5, b := 3)
+
+statement error
+CREATE MACRO macros.add(a, b) AS a + b
+
+statement error
+CREATE MACRO my_macro(a.b) AS 42;
+
+statement error
+CREATE MACRO my_macro(a.b.c) AS 42;
+
+statement ok
+CREATE MACRO my_macro(a) AS 42;
+
+statement error
+SELECT my_macro(x := 42);
+
+statement error
+SELECT my_macro(a := 42, a := 42);
\ No newline at end of file
diff --git a/test/sql/constraints/check/check_struct.test b/test/sql/constraints/check/check_struct.test
new file mode 100644
index 000000000000..27c46b826c0e
--- /dev/null
+++ b/test/sql/constraints/check/check_struct.test
@@ -0,0 +1,28 @@
+# name: test/sql/constraints/check/check_struct.test
+# description: CHECK constraint on structs
+# group: [check]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE tbl(t ROW(t INTEGER) CHECK(t.t=42));
+
+statement error
+INSERT INTO tbl VALUES ({'t': 43})
+
+statement ok
+INSERT INTO tbl VALUES ({'t': 42})
+
+statement ok
+DROP TABLE tbl;
+
+# we can also do this while referencing the table name
+statement ok
+CREATE TABLE tbl(t ROW(t INTEGER) CHECK(tbl.t.t=42));
+
+statement error
+INSERT INTO tbl VALUES ({'t': 43})
+
+statement ok
+INSERT INTO tbl VALUES ({'t': 42})
diff --git a/test/sql/constraints/test_check.test b/test/sql/constraints/check/test_check.test
similarity index 65%
rename from test/sql/constraints/test_check.test
rename to test/sql/constraints/check/test_check.test
index dc106e22253f..b239755ec919 100644
--- a/test/sql/constraints/test_check.test
+++ b/test/sql/constraints/check/test_check.test
@@ -1,6 +1,6 @@
-# name: test/sql/constraints/test_check.test
+# name: test/sql/constraints/check/test_check.test
 # description: CHECK constraint
-# group: [constraints]
+# group: [check]
 
 statement ok
 CREATE TABLE integers(i INTEGER CHECK(i < 5))
@@ -46,3 +46,14 @@ CREATE TABLE integers2(i INTEGER CHECK(i > (SELECT 42)), j INTEGER)
 statement error
 CREATE TABLE integers2(i INTEGER CHECK(i > SUM(j)), j INTEGER)
 
+statement error
+CREATE TABLE integers3(i INTEGER CHECK(k < 10), j INTEGER)
+
+statement error
+CREATE TABLE integers3(i INTEGER CHECK(integers3.k < 10), j INTEGER)
+
+statement error
+CREATE TABLE integers3(i INTEGER CHECK(integers2.i < 10), j INTEGER)
+
+statement ok
+CREATE TABLE integers4(i INTEGER CHECK(integers4.i < 10), j INTEGER)
diff --git a/test/sql/select/test_multi_column_reference.test b/test/sql/select/test_multi_column_reference.test
new file mode 100644
index 000000000000..0805cd42099e
--- /dev/null
+++ b/test/sql/select/test_multi_column_reference.test
@@ -0,0 +1,164 @@
+# name: test/sql/select/test_multi_column_reference.test
+# description: Test multi column reference
+# group: [select]
+
+statement ok
+PRAGMA enable_verification
+
+# column names can have an arbitrary amount of dots
+# here is how the resolution works:
+# no dots (i.e. "part1")
+# -> part1 refers to a column
+# one dot (i.e. "part1.part2")
+# EITHER:
+# -> part1 is a table, part2 is a column
+# -> part1 is a column, part2 is a property of that column (i.e. struct_extract)
+# two or more dots (i.e. "part1.part2.part3.part4...")
+# -> part1 is a schema, part2 is a table, part3 is a column name, part4 and beyond are struct fields
+# -> part1 is a table, part2 is a column name, part3 and beyond are struct fields
+# -> part1 is a column, part2 and beyond are struct fields
+
+# we always prefer the most top-level view
+# i.e. in case of multiple resolution options, we resolve in order:
+# -> 1. resolve "part1" as a schema
+# -> 2. resolve "part1" as a table
+# -> 3. resolve "part1" as a column
+
+# schema -> table -> column reference
+statement ok
+CREATE SCHEMA test
+
+statement ok
+CREATE TABLE test.tbl(col INTEGER);
+
+statement ok
+INSERT INTO test.tbl VALUES (1), (2), (3);
+
+query I
+SELECT test.tbl.col FROM test.tbl;
+----
+1
+2
+3
+
+# schema name with alias does not work
+statement error
+SELECT test.t.col FROM test.tbl t;
+
+statement error
+SELECT test.tbl.col FROM test.tbl t;
+
+# check how ties are resolved
+# we create a table called "t" in a schema called "t" with a column called "t" that has a field called "t"
+statement ok
+CREATE SCHEMA t
+
+statement ok
+CREATE TABLE t.t(t ROW(t INTEGER));
+
+statement ok
+INSERT INTO t.t VALUES ({'t': 42});
+
+# "t" selects the column
+query I
+SELECT t FROM t.t;
+----
+{'t': 42}
+
+# "t.t" also selects the column
+query I
+SELECT t.t FROM t.t;
+----
+{'t': 42}
+
+# t.t.t also selects the column
+query I
+SELECT t.t.t FROM t.t;
+----
+{'t': 42}
+
+# t.t.t.t selects the field
+query I
+SELECT t.t.t.t FROM t.t;
+----
+42
+
+statement ok
+DROP SCHEMA t CASCADE;
+
+# test long nested struct
+statement ok
+CREATE SCHEMA t
+
+statement ok
+CREATE TABLE t.t AS SELECT {'t': {'t': {'t': {'t': {'t': 42}}}}} t
+
+query I
+SELECT t.t.t.t.t.t.t.t FROM t.t;
+----
+42
+
+query I
+SELECT t.t.t.t.t.t.t FROM t.t;
+----
+{'t': 42}
+
+query I
+SELECT t.t.t.t.t.t FROM t.t;
+----
+{'t': {'t': 42}}
+
+query I
+SELECT t.t.t.t.t FROM t.t;
+----
+{'t': {'t': {'t': 42}}}
+
+query I
+SELECT t.t.t.t FROM t.t;
+----
+{'t': {'t': {'t': {'t': 42}}}}
+
+query I
+SELECT t.t.t FROM t.t;
+----
+{'t': {'t': {'t': {'t': {'t': 42}}}}}
+
+query I
+SELECT t.t FROM t.t;
+----
+{'t': {'t': {'t': {'t': {'t': 42}}}}}
+
+query I
+SELECT t FROM t.t;
+----
+{'t': {'t': {'t': {'t': {'t': 42}}}}}
+
+statement ok
+DROP SCHEMA t CASCADE
+
+# test multiple tables with the same name but a different schema
+# we don't allow this (duplicate alias in query)
+statement ok
+CREATE SCHEMA s1
+
+statement ok
+CREATE SCHEMA s2
+
+statement ok
+CREATE TABLE s1.t1 AS SELECT 42 t
+
+statement ok
+CREATE TABLE s2.t1 AS SELECT 84 t
+
+statement error
+SELECT s1.t1.t FROM s1.t1, s2.t1
+
+# test various failures
+statement error
+SELECT testX.tbl.col FROM test.tbl;
+
+statement error
+SELECT test.tblX.col FROM test.tbl;
+
+statement error
+SELECT test.tbl.colX FROM test.tbl;
diff --git a/test/sql/select/test_projection_names.test b/test/sql/select/test_projection_names.test
new file mode 100644
index 000000000000..783559dd14a5
--- /dev/null
+++ b/test/sql/select/test_projection_names.test
@@ -0,0 +1,61 @@
+# name: test/sql/select/test_projection_names.test
+# description: Test projection lists
+# group: [select]
+
+statement ok
+CREATE TABLE integers("COL1" INTEGER, "COL2" INTEGER)
+
+# *
+statement ok
+CREATE TABLE tbl AS SELECT * FROM integers
+
+query I
+SELECT name FROM pragma_table_info('tbl') ORDER BY name
+----
+COL1
+COL2
+
+statement ok
+DROP TABLE tbl
+
+# col1, col2
+statement ok
+CREATE TABLE tbl AS SELECT COL1, COL2 FROM integers
+
+query I
+SELECT name FROM pragma_table_info('tbl') ORDER BY name
+----
+COL1
+COL2
+
+statement ok
+DROP TABLE tbl
+
+# explicit table reference
+statement ok
+CREATE TABLE tbl AS SELECT integers.COL1, integers.COL2 FROM integers
+
+query I
+SELECT name FROM pragma_table_info('tbl') ORDER BY name
+----
+COL1
+COL2
+
+statement ok
+DROP TABLE tbl
+
+# explicit schema reference
+statement ok
+CREATE SCHEMA s1;
+
+statement ok
+CREATE TABLE s1.integers("COL1" INTEGER, "COL2" INTEGER)
+
+statement ok
+CREATE TABLE tbl AS SELECT s1.integers.COL1, s1.integers.COL2 FROM s1.integers
+
+query I
+SELECT name FROM pragma_table_info('tbl') ORDER BY name
+----
+COL1
+COL2
diff --git a/test/sql/select/test_schema_reference.test b/test/sql/select/test_schema_reference.test
new file mode 100644
index 000000000000..b974b9df4bff
--- /dev/null
+++ b/test/sql/select/test_schema_reference.test
@@ -0,0 +1,24 @@
+# name: test/sql/select/test_schema_reference.test
+# description: Test schema reference in column reference
+# group: [select]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE SCHEMA s1;
+
+statement ok
+CREATE TABLE s1.tbl(i INTEGER)
+
+# standard schema reference
+statement ok
+SELECT s1.tbl.i FROM s1.tbl;
+
+# schema mismatch
+statement error
+SELECT s2.tbl.i FROM s1.tbl;
+
+# no schema present
+statement error
+SELECT a.tbl.i FROM range(10) tbl(i)
\ No newline at end of file
diff --git a/test/sql/storage_version/storage_version.db b/test/sql/storage_version/storage_version.db
index f6cae75bc0ec..243232ee79d5 100644
Binary files a/test/sql/storage_version/storage_version.db and b/test/sql/storage_version/storage_version.db differ
