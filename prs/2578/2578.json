{
  "repo": "duckdb/duckdb",
  "pull_number": 2578,
  "instance_id": "duckdb__duckdb-2578",
  "issue_numbers": [
    "2568"
  ],
  "base_commit": "e92737ebd32d01147d6438d00b6e0e1504e289f9",
  "patch": "diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp\nindex 130f24db8d27..13e1a9e2581b 100644\n--- a/src/catalog/catalog_entry/table_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp\n@@ -140,8 +140,8 @@ unique_ptr<CatalogEntry> TableCatalogEntry::AlterEntry(ClientContext &context, A\n static void RenameExpression(ParsedExpression &expr, RenameColumnInfo &info) {\n \tif (expr.type == ExpressionType::COLUMN_REF) {\n \t\tauto &colref = (ColumnRefExpression &)expr;\n-\t\tif (colref.column_name == info.old_name) {\n-\t\t\tcolref.column_name = info.new_name;\n+\t\tif (colref.column_names[0] == info.old_name) {\n+\t\t\tcolref.column_names[0] = info.new_name;\n \t\t}\n \t}\n \tParsedExpressionIterator::EnumerateChildren(\ndiff --git a/src/execution/expression_executor.cpp b/src/execution/expression_executor.cpp\nindex 4d3b3630c186..ea83e1b1adf0 100644\n--- a/src/execution/expression_executor.cpp\n+++ b/src/execution/expression_executor.cpp\n@@ -78,6 +78,7 @@ void ExpressionExecutor::ExecuteExpression(idx_t expr_idx, Vector &result) {\n \n Value ExpressionExecutor::EvaluateScalar(const Expression &expr) {\n \tD_ASSERT(expr.IsFoldable());\n+\tD_ASSERT(expr.IsScalar());\n \t// use an ExpressionExecutor to execute the expression\n \tExpressionExecutor executor(expr);\n \ndiff --git a/src/function/macro_function.cpp b/src/function/macro_function.cpp\nindex 194728ce44a3..ea44237bb84b 100644\n--- a/src/function/macro_function.cpp\n+++ b/src/function/macro_function.cpp\n@@ -41,7 +41,7 @@ string MacroFunction::ValidateArguments(MacroCatalogEntry &macro_func, FunctionE\n \t\terror = StringUtil::Format(\n \t\t    \"Macro function '%s(%s)' requires \", macro_func.name,\n \t\t    StringUtil::Join(parameters, parameters.size(), \", \", [](const unique_ptr<ParsedExpression> &p) {\n-\t\t\t    return ((ColumnRefExpression &)*p).column_name;\n+\t\t\t    return ((ColumnRefExpression &)*p).column_names[0];\n \t\t    }));\n \t\terror += parameters.size() == 1 ? \"a single positional argument\"\n \t\t                                : StringUtil::Format(\"%i positional arguments\", parameters.size());\ndiff --git a/src/function/table/table_scan.cpp b/src/function/table/table_scan.cpp\nindex 75ae49f6994b..e1d02e792837 100644\n--- a/src/function/table/table_scan.cpp\n+++ b/src/function/table/table_scan.cpp\n@@ -362,4 +362,12 @@ TableFunction TableScanFunction::GetFunction() {\n \treturn scan_function;\n }\n \n+TableCatalogEntry *TableScanFunction::GetTableEntry(const TableFunction &function, const FunctionData *bind_data_p) {\n+\tif (function.function != TableScanFunc || !bind_data_p) {\n+\t\treturn nullptr;\n+\t}\n+\tauto &bind_data = (TableScanBindData &)*bind_data_p;\n+\treturn bind_data.table;\n+}\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/function/table/table_scan.hpp b/src/include/duckdb/function/table/table_scan.hpp\nindex 5f13bdbaad1c..8fb4fff96515 100644\n--- a/src/include/duckdb/function/table/table_scan.hpp\n+++ b/src/include/duckdb/function/table/table_scan.hpp\n@@ -33,6 +33,7 @@ struct TableScanBindData : public FunctionData {\n //! The table scan function represents a sequential scan over one of DuckDB's base tables.\n struct TableScanFunction {\n \tstatic TableFunction GetFunction();\n+\tstatic TableCatalogEntry *GetTableEntry(const TableFunction &function, const FunctionData *bind_data);\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/parser/expression/columnref_expression.hpp b/src/include/duckdb/parser/expression/columnref_expression.hpp\nindex c88d54f98d06..64914a14e966 100644\n--- a/src/include/duckdb/parser/expression/columnref_expression.hpp\n+++ b/src/include/duckdb/parser/expression/columnref_expression.hpp\n@@ -9,6 +9,7 @@\n #pragma once\n \n #include \"duckdb/parser/parsed_expression.hpp\"\n+#include \"duckdb/common/vector.hpp\"\n \n namespace duckdb {\n \n@@ -20,13 +21,16 @@ class ColumnRefExpression : public ParsedExpression {\n \tColumnRefExpression(string column_name, string table_name);\n \t//! Only specify the column name, the table name will be derived later\n \texplicit ColumnRefExpression(string column_name);\n+\t//! Specify a set of names\n+\texplicit ColumnRefExpression(vector<string> column_names);\n \n-\t//! Column name that is referenced\n-\tstring column_name;\n-\t//! Table name of the column name that is referenced (optional)\n-\tstring table_name;\n+\t//! The stack of names in order of which they appear (column_names[0].column_names[1].column_names[2]....)\n+\tvector<string> column_names;\n \n public:\n+\tbool IsQualified() const;\n+\tconst string &GetColumnName() const;\n+\tconst string &GetTableName() const;\n \tbool IsScalar() const override {\n \t\treturn false;\n \t}\ndiff --git a/src/include/duckdb/parser/parsed_expression_iterator.hpp b/src/include/duckdb/parser/parsed_expression_iterator.hpp\nindex d15b918c5e08..288f9e361979 100644\n--- a/src/include/duckdb/parser/parsed_expression_iterator.hpp\n+++ b/src/include/duckdb/parser/parsed_expression_iterator.hpp\n@@ -9,6 +9,7 @@\n #pragma once\n \n #include \"duckdb/parser/parsed_expression.hpp\"\n+#include \"duckdb/parser/tokens.hpp\"\n \n #include <functional>\n \n@@ -21,6 +22,11 @@ class ParsedExpressionIterator {\n \tstatic void EnumerateChildren(ParsedExpression &expr, const std::function<void(ParsedExpression &child)> &callback);\n \tstatic void EnumerateChildren(ParsedExpression &expr,\n \t                              const std::function<void(unique_ptr<ParsedExpression> &child)> &callback);\n+\n+\tstatic void EnumerateTableRefChildren(TableRef &ref,\n+\t                                      const std::function<void(unique_ptr<ParsedExpression> &child)> &callback);\n+\tstatic void EnumerateQueryNodeChildren(QueryNode &node,\n+\t                                       const std::function<void(unique_ptr<ParsedExpression> &child)> &callback);\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/bind_context.hpp b/src/include/duckdb/planner/bind_context.hpp\nindex 57b451c47491..231ef10c8182 100644\n--- a/src/include/duckdb/planner/bind_context.hpp\n+++ b/src/include/duckdb/planner/bind_context.hpp\n@@ -58,6 +58,10 @@ class BindContext {\n \tstring BindColumn(PositionalReferenceExpression &ref, string &table_name, string &column_name);\n \tBindResult BindColumn(PositionalReferenceExpression &ref, idx_t depth);\n \n+\tunique_ptr<ParsedExpression> CreateColumnReference(const string &table_name, const string &column_name);\n+\tunique_ptr<ParsedExpression> CreateColumnReference(const string &schema_name, const string &table_name,\n+\t                                                   const string &column_name);\n+\n \t//! Generate column expressions for all columns that are present in the\n \t//! referenced tables. This is used to resolve the * expression in a\n \t//! selection list.\n@@ -126,12 +130,13 @@ class BindContext {\n \t//! Add all the bindings from a BindContext to this BindContext. The other BindContext is destroyed in the process.\n \tvoid AddContext(BindContext other);\n \n-private:\n-\tvoid AddBinding(const string &alias, unique_ptr<Binding> binding);\n \t//! Gets a binding of the specified name. Returns a nullptr and sets the out_error if the binding could not be\n \t//! found.\n \tBinding *GetBinding(const string &name, string &out_error);\n \n+private:\n+\tvoid AddBinding(const string &alias, unique_ptr<Binding> binding);\n+\n private:\n \t//! The set of bindings\n \tcase_insensitive_map_t<unique_ptr<Binding>> bindings;\ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 4c9dc9f63457..0e69fb54b57e 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -143,6 +143,10 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \n \tstatic void BindLogicalType(ClientContext &context, LogicalType &type, const string &schema = \"\");\n \n+\tbool HasMatchingBinding(const string &table_name, const string &column_name, string &error_message);\n+\tbool HasMatchingBinding(const string &schema_name, const string &table_name, const string &column_name,\n+\t                        string &error_message);\n+\n private:\n \t//! The parent binder (if any)\n \tshared_ptr<Binder> parent;\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 465325acd982..c4ffcf4d7de6 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -35,6 +35,8 @@ struct BoundColumnReferenceInfo {\n };\n \n struct BindResult {\n+\tBindResult() {\n+\t}\n \texplicit BindResult(string error) : error(error) {\n \t}\n \texplicit BindResult(unique_ptr<Expression> expr) : expression(move(expr)) {\n@@ -71,9 +73,16 @@ class ExpressionBinder {\n \n \tstring Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression = false);\n \n+\tunique_ptr<ParsedExpression> CreateStructExtract(unique_ptr<ParsedExpression> base, string field_name);\n+\tBindResult BindQualifiedColumnName(ColumnRefExpression &colref, const string &table_name);\n+\n+\tunique_ptr<ParsedExpression> QualifyColumnName(const string &column_name, string &error_message);\n+\tunique_ptr<ParsedExpression> QualifyColumnName(ColumnRefExpression &colref, string &error_message);\n+\n \t// Bind table names to ColumnRefExpressions\n-\tstatic void BindTableNames(Binder &binder, ParsedExpression &expr,\n-\t                           unordered_map<string, idx_t> *alias_map = nullptr);\n+\tvoid QualifyColumnNames(unique_ptr<ParsedExpression> &expr);\n+\tstatic void QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr);\n+\n \tstatic unique_ptr<Expression> PushCollation(ClientContext &context, unique_ptr<Expression> source,\n \t                                            const string &collation, bool equality_only = false);\n \tstatic void TestCollation(ClientContext &context, const string &collation);\n@@ -121,9 +130,7 @@ class ExpressionBinder {\n \tvirtual BindResult BindMacro(FunctionExpression &expr, MacroCatalogEntry *macro, idx_t depth,\n \t                             unique_ptr<ParsedExpression> *expr_ptr);\n \n-\tvirtual void ReplaceMacroParametersRecursive(unique_ptr<ParsedExpression> &expr);\n-\tvirtual void ReplaceMacroParametersRecursive(ParsedExpression &expr, QueryNode &node);\n-\tvirtual void ReplaceMacroParametersRecursive(ParsedExpression &expr, TableRef &ref);\n+\tvoid ReplaceMacroParametersRecursive(unique_ptr<ParsedExpression> &expr);\n \n \tvirtual string UnsupportedAggregateMessage();\n \tvirtual string UnsupportedUnnestMessage();\ndiff --git a/src/include/duckdb/planner/operator/logical_get.hpp b/src/include/duckdb/planner/operator/logical_get.hpp\nindex 192f6fe2877d..1d7fc4e7aefa 100644\n--- a/src/include/duckdb/planner/operator/logical_get.hpp\n+++ b/src/include/duckdb/planner/operator/logical_get.hpp\n@@ -37,6 +37,8 @@ class LogicalGet : public LogicalOperator {\n \n \tstring GetName() const override;\n \tstring ParamsToString() const override;\n+\t//! Returns the underlying table that is being scanned, or nullptr if there is none\n+\tTableCatalogEntry *GetTable() const;\n \n public:\n \tvector<ColumnBinding> GetColumnBindings() override;\ndiff --git a/src/include/duckdb/planner/table_binding.hpp b/src/include/duckdb/planner/table_binding.hpp\nindex 9add00792cd1..1c7e3f7f09c8 100644\n--- a/src/include/duckdb/planner/table_binding.hpp\n+++ b/src/include/duckdb/planner/table_binding.hpp\n@@ -41,8 +41,11 @@ struct Binding {\n \n public:\n \tbool TryGetBindingIndex(const string &column_name, column_t &column_index);\n+\tcolumn_t GetBindingIndex(const string &column_name);\n \tbool HasMatchingBinding(const string &column_name);\n+\tvirtual string ColumnNotFoundError(const string &column_name) const;\n \tvirtual BindResult Bind(ColumnRefExpression &colref, idx_t depth);\n+\tvirtual TableCatalogEntry *GetTableEntry();\n };\n \n //! TableBinding is exactly like the Binding, except it keeps track of which columns were bound in the linked LogicalGet\n@@ -56,11 +59,16 @@ struct TableBinding : public Binding {\n \n public:\n \tBindResult Bind(ColumnRefExpression &colref, idx_t depth) override;\n+\tTableCatalogEntry *GetTableEntry() override;\n+\tstring ColumnNotFoundError(const string &column_name) const override;\n };\n \n //! MacroBinding is like the Binding, except the alias and index are set by default. Used for binding Macro\n //! Params/Arguments.\n struct MacroBinding : public Binding {\n+\tstatic constexpr const char *MACRO_NAME = \"0_macro_parameters\";\n+\n+public:\n \tMacroBinding(vector<LogicalType> types_p, vector<string> names_p, string macro_name);\n \n \t//! Arguments\ndiff --git a/src/main/relation.cpp b/src/main/relation.cpp\nindex 9b459b1d9734..8a335b8d72c5 100644\n--- a/src/main/relation.cpp\n+++ b/src/main/relation.cpp\n@@ -121,10 +121,10 @@ shared_ptr<Relation> Relation::Join(const shared_ptr<Relation> &other, const str\n \t\t\t\tthrow ParserException(\"Expected a single expression as join condition\");\n \t\t\t}\n \t\t\tauto &colref = (ColumnRefExpression &)*expr;\n-\t\t\tif (!colref.table_name.empty()) {\n-\t\t\t\tthrow ParserException(\"Expected empty table name for column in USING clause\");\n+\t\t\tif (colref.IsQualified()) {\n+\t\t\t\tthrow ParserException(\"Expected unqualified column for column in USING clause\");\n \t\t\t}\n-\t\t\tusing_columns.push_back(colref.column_name);\n+\t\t\tusing_columns.push_back(colref.column_names[0]);\n \t\t}\n \t\treturn make_shared<JoinRelation>(shared_from_this(), other, move(using_columns), type);\n \t} else {\ndiff --git a/src/optimizer/statistics/operator/propagate_projection.cpp b/src/optimizer/statistics/operator/propagate_projection.cpp\nindex 47801f2dc487..10f998f2fc70 100644\n--- a/src/optimizer/statistics/operator/propagate_projection.cpp\n+++ b/src/optimizer/statistics/operator/propagate_projection.cpp\n@@ -7,6 +7,10 @@ unique_ptr<NodeStatistics> StatisticsPropagator::PropagateStatistics(LogicalProj\n                                                                      unique_ptr<LogicalOperator> *node_ptr) {\n \t// first propagate to the child\n \tnode_stats = PropagateStatistics(proj.children[0]);\n+\tif (proj.children[0]->type == LogicalOperatorType::LOGICAL_EMPTY_RESULT) {\n+\t\tReplaceWithEmptyResult(*node_ptr);\n+\t\treturn move(node_stats);\n+\t}\n \n \t// then propagate to each of the expressions\n \tfor (idx_t i = 0; i < proj.expressions.size(); i++) {\ndiff --git a/src/parser/expression/columnref_expression.cpp b/src/parser/expression/columnref_expression.cpp\nindex 42d187e50913..897c28e8838c 100644\n--- a/src/parser/expression/columnref_expression.cpp\n+++ b/src/parser/expression/columnref_expression.cpp\n@@ -6,53 +6,85 @@\n \n namespace duckdb {\n \n-//! Specify both the column and table name\n ColumnRefExpression::ColumnRefExpression(string column_name, string table_name)\n-    : ParsedExpression(ExpressionType::COLUMN_REF, ExpressionClass::COLUMN_REF), column_name(move(column_name)),\n-      table_name(move(table_name)) {\n+    : ColumnRefExpression(table_name.empty() ? vector<string> {move(column_name)}\n+                                             : vector<string> {move(table_name), move(column_name)}) {\n }\n \n-ColumnRefExpression::ColumnRefExpression(string column_name) : ColumnRefExpression(move(column_name), string()) {\n+ColumnRefExpression::ColumnRefExpression(string column_name) : ColumnRefExpression(vector<string> {move(column_name)}) {\n+}\n+\n+ColumnRefExpression::ColumnRefExpression(vector<string> column_names_p)\n+    : ParsedExpression(ExpressionType::COLUMN_REF, ExpressionClass::COLUMN_REF), column_names(move(column_names_p)) {\n+#ifdef DEBUG\n+\tfor (auto &col_name : column_names) {\n+\t\tD_ASSERT(!col_name.empty());\n+\t}\n+#endif\n+}\n+\n+bool ColumnRefExpression::IsQualified() const {\n+\treturn column_names.size() > 1;\n+}\n+\n+const string &ColumnRefExpression::GetColumnName() const {\n+\tD_ASSERT(column_names.size() <= 3);\n+\treturn column_names.back();\n+}\n+\n+const string &ColumnRefExpression::GetTableName() const {\n+\tD_ASSERT(column_names.size() >= 2 && column_names.size() <= 3);\n+\treturn column_names.size() == 3 ? column_names[1] : column_names[0];\n }\n \n string ColumnRefExpression::GetName() const {\n-\treturn !alias.empty() ? alias : column_name;\n+\treturn !alias.empty() ? alias : column_names.back();\n }\n \n string ColumnRefExpression::ToString() const {\n-\tif (table_name.empty()) {\n-\t\treturn column_name;\n-\t} else {\n-\t\treturn table_name + \".\" + column_name;\n+\tstring result;\n+\tfor (idx_t i = 0; i < column_names.size(); i++) {\n+\t\tif (i > 0) {\n+\t\t\tresult += \".\";\n+\t\t}\n+\t\tresult += column_names[i];\n \t}\n+\treturn result;\n }\n \n bool ColumnRefExpression::Equals(const ColumnRefExpression *a, const ColumnRefExpression *b) {\n-\treturn a->column_name == b->column_name && a->table_name == b->table_name;\n+\treturn a->column_names == b->column_names;\n }\n \n hash_t ColumnRefExpression::Hash() const {\n \thash_t result = ParsedExpression::Hash();\n-\tresult = CombineHash(result, duckdb::Hash<const char *>(column_name.c_str()));\n+\tfor (auto &column_name : column_names) {\n+\t\tresult = CombineHash(result, duckdb::Hash<const char *>(column_name.c_str()));\n+\t}\n \treturn result;\n }\n \n unique_ptr<ParsedExpression> ColumnRefExpression::Copy() const {\n-\tauto copy = make_unique<ColumnRefExpression>(column_name, table_name);\n+\tauto copy = make_unique<ColumnRefExpression>(column_names);\n \tcopy->CopyProperties(*this);\n \treturn move(copy);\n }\n \n void ColumnRefExpression::Serialize(Serializer &serializer) {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteString(table_name);\n-\tserializer.WriteString(column_name);\n+\tserializer.Write<idx_t>(column_names.size());\n+\tfor (auto &column_name : column_names) {\n+\t\tserializer.WriteString(column_name);\n+\t}\n }\n \n unique_ptr<ParsedExpression> ColumnRefExpression::Deserialize(ExpressionType type, Deserializer &source) {\n-\tauto table_name = source.Read<string>();\n-\tauto column_name = source.Read<string>();\n-\tauto expression = make_unique<ColumnRefExpression>(column_name, table_name);\n+\tauto column_count = source.Read<idx_t>();\n+\tvector<string> column_names;\n+\tfor (idx_t i = 0; i < column_count; i++) {\n+\t\tcolumn_names.push_back(source.Read<string>());\n+\t}\n+\tauto expression = make_unique<ColumnRefExpression>(move(column_names));\n \treturn move(expression);\n }\n \ndiff --git a/src/parser/parsed_expression_iterator.cpp b/src/parser/parsed_expression_iterator.cpp\nindex ebff20ccfdf9..69c79ac041e1 100644\n--- a/src/parser/parsed_expression_iterator.cpp\n+++ b/src/parser/parsed_expression_iterator.cpp\n@@ -1,6 +1,11 @@\n #include \"duckdb/parser/parsed_expression_iterator.hpp\"\n \n #include \"duckdb/parser/expression/list.hpp\"\n+#include \"duckdb/parser/query_node.hpp\"\n+#include \"duckdb/parser/query_node/recursive_cte_node.hpp\"\n+#include \"duckdb/parser/query_node/select_node.hpp\"\n+#include \"duckdb/parser/query_node/set_operation_node.hpp\"\n+#include \"duckdb/parser/tableref/list.hpp\"\n \n namespace duckdb {\n \n@@ -137,4 +142,89 @@ void ParsedExpressionIterator::EnumerateChildren(\n \t}\n }\n \n+void ParsedExpressionIterator::EnumerateTableRefChildren(\n+    TableRef &ref, const std::function<void(unique_ptr<ParsedExpression> &child)> &callback) {\n+\tswitch (ref.type) {\n+\tcase TableReferenceType::CROSS_PRODUCT: {\n+\t\tauto &cp_ref = (CrossProductRef &)ref;\n+\t\tEnumerateTableRefChildren(*cp_ref.left, callback);\n+\t\tEnumerateTableRefChildren(*cp_ref.right, callback);\n+\t\tbreak;\n+\t}\n+\tcase TableReferenceType::EXPRESSION_LIST: {\n+\t\tauto &el_ref = (ExpressionListRef &)ref;\n+\t\tfor (idx_t i = 0; i < el_ref.values.size(); i++) {\n+\t\t\tfor (idx_t j = 0; j < el_ref.values[i].size(); j++) {\n+\t\t\t\tcallback(el_ref.values[i][j]);\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase TableReferenceType::JOIN: {\n+\t\tauto &j_ref = (JoinRef &)ref;\n+\t\tEnumerateTableRefChildren(*j_ref.left, callback);\n+\t\tEnumerateTableRefChildren(*j_ref.right, callback);\n+\t\tcallback(j_ref.condition);\n+\t\tbreak;\n+\t}\n+\tcase TableReferenceType::SUBQUERY: {\n+\t\tauto &sq_ref = (SubqueryRef &)ref;\n+\t\tEnumerateQueryNodeChildren(*sq_ref.subquery->node, callback);\n+\t\tbreak;\n+\t}\n+\tcase TableReferenceType::TABLE_FUNCTION: {\n+\t\tauto &tf_ref = (TableFunctionRef &)ref;\n+\t\tcallback(tf_ref.function);\n+\t\tbreak;\n+\t}\n+\tcase TableReferenceType::BASE_TABLE:\n+\tcase TableReferenceType::EMPTY:\n+\t\t// these TableRefs do not need to be unfolded\n+\t\tbreak;\n+\tdefault:\n+\t\tthrow NotImplementedException(\"TableRef type not implemented for traversal\");\n+\t}\n+}\n+\n+void ParsedExpressionIterator::EnumerateQueryNodeChildren(\n+    QueryNode &node, const std::function<void(unique_ptr<ParsedExpression> &child)> &callback) {\n+\tswitch (node.type) {\n+\tcase QueryNodeType::RECURSIVE_CTE_NODE: {\n+\t\tauto &rcte_node = (RecursiveCTENode &)node;\n+\t\tEnumerateQueryNodeChildren(*rcte_node.left, callback);\n+\t\tEnumerateQueryNodeChildren(*rcte_node.right, callback);\n+\t\tbreak;\n+\t}\n+\tcase QueryNodeType::SELECT_NODE: {\n+\t\tauto &sel_node = (SelectNode &)node;\n+\t\tfor (idx_t i = 0; i < sel_node.select_list.size(); i++) {\n+\t\t\tcallback(sel_node.select_list[i]);\n+\t\t}\n+\t\tfor (idx_t i = 0; i < sel_node.groups.group_expressions.size(); i++) {\n+\t\t\tcallback(sel_node.groups.group_expressions[i]);\n+\t\t}\n+\t\tif (sel_node.where_clause) {\n+\t\t\tcallback(sel_node.where_clause);\n+\t\t}\n+\t\tif (sel_node.having) {\n+\t\t\tcallback(sel_node.having);\n+\t\t}\n+\n+\t\tEnumerateTableRefChildren(*sel_node.from_table.get(), callback);\n+\t\tbreak;\n+\t}\n+\tcase QueryNodeType::SET_OPERATION_NODE: {\n+\t\tauto &setop_node = (SetOperationNode &)node;\n+\t\tEnumerateQueryNodeChildren(*setop_node.left, callback);\n+\t\tEnumerateQueryNodeChildren(*setop_node.right, callback);\n+\t\tbreak;\n+\t}\n+\tdefault:\n+\t\tthrow NotImplementedException(\"QueryNode type not implemented for traversal\");\n+\t}\n+\tfor (auto &kv : node.cte_map) {\n+\t\tEnumerateQueryNodeChildren(*kv.second->query->node, callback);\n+\t}\n+}\n+\n } // namespace duckdb\ndiff --git a/src/parser/transform/expression/transform_columnref.cpp b/src/parser/transform/expression/transform_columnref.cpp\nindex 0b42cc54c561..032b74be2fa0 100644\n--- a/src/parser/transform/expression/transform_columnref.cpp\n+++ b/src/parser/transform/expression/transform_columnref.cpp\n@@ -47,28 +47,13 @@ unique_ptr<ParsedExpression> Transformer::TransformColumnRef(duckdb_libpgquery::\n \t\tif (fields->length < 1) {\n \t\t\tthrow InternalException(\"Unexpected field length\");\n \t\t}\n-\t\tstring column_name, table_name;\n-\t\tif (fields->length == 1) {\n-\t\t\tcolumn_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(fields->head->data.ptr_value)->val.str);\n-\t\t\tauto colref = make_unique<ColumnRefExpression>(column_name, table_name);\n-\t\t\tcolref->query_location = root->location;\n-\t\t\treturn move(colref);\n-\t\t} else if (fields->length == 2) {\n-\t\t\ttable_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(fields->head->data.ptr_value)->val.str);\n-\t\t\tauto col_node = reinterpret_cast<duckdb_libpgquery::PGNode *>(fields->head->next->data.ptr_value);\n-\t\t\tswitch (col_node->type) {\n-\t\t\tcase duckdb_libpgquery::T_PGString: {\n-\t\t\t\tcolumn_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(col_node)->val.str);\n-\t\t\t\tauto colref = make_unique<ColumnRefExpression>(column_name, table_name);\n-\t\t\t\tcolref->query_location = root->location;\n-\t\t\t\treturn move(colref);\n-\t\t\t}\n-\t\t\tdefault:\n-\t\t\t\tthrow NotImplementedException(\"ColumnRef not implemented!\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tthrow NotImplementedException(\"ColumnRef not implemented!\");\n+\t\tvector<string> column_names;\n+\t\tfor (auto node = fields->head; node; node = node->next) {\n+\t\t\tcolumn_names.emplace_back(reinterpret_cast<duckdb_libpgquery::PGValue *>(node->data.ptr_value)->val.str);\n \t\t}\n+\t\tauto colref = make_unique<ColumnRefExpression>(move(column_names));\n+\t\tcolref->query_location = root->location;\n+\t\treturn move(colref);\n \t}\n \tcase duckdb_libpgquery::T_PGAStar: {\n \t\treturn TransformStarExpression(head_node);\ndiff --git a/src/parser/transform/expression/transform_lambda.cpp b/src/parser/transform/expression/transform_lambda.cpp\nindex 3d4b36439cef..6d39bd076ce4 100644\n--- a/src/parser/transform/expression/transform_lambda.cpp\n+++ b/src/parser/transform/expression/transform_lambda.cpp\n@@ -10,10 +10,10 @@ static string ExtractColumnFromLambda(ParsedExpression &expr) {\n \t\tthrow ParserException(\"Lambda parameter must be a column name\");\n \t}\n \tauto &colref = (ColumnRefExpression &)expr;\n-\tif (!colref.table_name.empty()) {\n+\tif (colref.IsQualified()) {\n \t\tthrow ParserException(\"Lambda parameter must be an unqualified name (e.g. 'x', not 'a.x')\");\n \t}\n-\treturn colref.column_name;\n+\treturn colref.column_names[0];\n }\n \n unique_ptr<ParsedExpression> Transformer::TransformLambda(duckdb_libpgquery::PGLambdaFunction *node) {\ndiff --git a/src/planner/bind_context.cpp b/src/planner/bind_context.cpp\nindex 2d5458211566..9af1bd5a78ad 100644\n--- a/src/planner/bind_context.cpp\n+++ b/src/planner/bind_context.cpp\n@@ -158,6 +158,34 @@ unordered_set<string> BindContext::GetMatchingBindings(const string &column_name\n \treturn result;\n }\n \n+unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const string &table_name, const string &column_name) {\n+\tstring schema_name;\n+\treturn CreateColumnReference(schema_name, table_name, column_name);\n+}\n+\n+unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const string &schema_name, const string &table_name,\n+                                                                const string &column_name) {\n+\tstring error_message;\n+\tvector<string> names;\n+\tif (!schema_name.empty()) {\n+\t\tnames.push_back(schema_name);\n+\t}\n+\tnames.push_back(table_name);\n+\tnames.push_back(column_name);\n+\n+\tauto result = make_unique<ColumnRefExpression>(move(names));\n+\t// because of case insensitivity in the binder we rename the column to the original name\n+\t// as it appears in the binding itself\n+\tauto binding = GetBinding(table_name, error_message);\n+\tif (binding) {\n+\t\tauto column_index = binding->GetBindingIndex(column_name);\n+\t\tif (column_index < binding->names.size() && binding->names[column_index] != column_name) {\n+\t\t\tresult->alias = binding->names[column_index];\n+\t\t}\n+\t}\n+\treturn move(result);\n+}\n+\n Binding *BindContext::GetCTEBinding(const string &ctename) {\n \tauto match = cte_bindings.find(ctename);\n \tif (match == cte_bindings.end()) {\n@@ -183,12 +211,12 @@ Binding *BindContext::GetBinding(const string &name, string &out_error) {\n }\n \n BindResult BindContext::BindColumn(ColumnRefExpression &colref, idx_t depth) {\n-\tif (colref.table_name.empty()) {\n-\t\treturn BindResult(StringUtil::Format(\"Could not bind alias \\\"%s\\\"!\", colref.column_name));\n+\tif (!colref.IsQualified()) {\n+\t\tthrow InternalException(\"Could not bind alias \\\"%s\\\"!\", colref.GetColumnName());\n \t}\n \n \tstring error;\n-\tauto binding = GetBinding(colref.table_name, error);\n+\tauto binding = GetBinding(colref.GetTableName(), error);\n \tif (!binding) {\n \t\treturn BindResult(error);\n \t}\ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex 49e51a0b8fca..e66d2a23a9b7 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -6,6 +6,8 @@\n #include \"duckdb/planner/bound_tableref.hpp\"\n #include \"duckdb/planner/expression.hpp\"\n #include \"duckdb/planner/operator/logical_sample.hpp\"\n+#include \"duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\"\n+#include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n \n #include <algorithm>\n \n@@ -286,6 +288,38 @@ void Binder::AddCorrelatedColumn(const CorrelatedColumnInfo &info) {\n \t}\n }\n \n+bool Binder::HasMatchingBinding(const string &table_name, const string &column_name, string &error_message) {\n+\tstring empty_schema;\n+\treturn HasMatchingBinding(empty_schema, table_name, column_name, error_message);\n+}\n+\n+bool Binder::HasMatchingBinding(const string &schema_name, const string &table_name, const string &column_name,\n+                                string &error_message) {\n+\tBinding *binding;\n+\tif (macro_binding && table_name == macro_binding->alias) {\n+\t\tbinding = macro_binding;\n+\t} else {\n+\t\tbinding = bind_context.GetBinding(table_name, error_message);\n+\t}\n+\tif (!binding) {\n+\t\treturn false;\n+\t}\n+\tif (!schema_name.empty()) {\n+\t\tauto table_entry = binding->GetTableEntry();\n+\t\tif (!table_entry) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (table_entry->schema->name != schema_name || table_entry->name != table_name) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\tif (!binding->HasMatchingBinding(column_name)) {\n+\t\terror_message = binding->ColumnNotFoundError(column_name);\n+\t\treturn false;\n+\t}\n+\treturn true;\n+}\n+\n string Binder::FormatError(ParsedExpression &expr_context, const string &message) {\n \treturn FormatError(expr_context.query_location, message);\n }\ndiff --git a/src/planner/binder/expression/bind_columnref_expression.cpp b/src/planner/binder/expression/bind_columnref_expression.cpp\nindex 20e74e07064c..618863ff346f 100644\n--- a/src/planner/binder/expression/bind_columnref_expression.cpp\n+++ b/src/planner/binder/expression/bind_columnref_expression.cpp\n@@ -4,58 +4,204 @@\n #include \"duckdb/planner/expression_binder.hpp\"\n #include \"duckdb/parser/expression/operator_expression.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/parser/parsed_expression_iterator.hpp\"\n+#include \"duckdb/parser/expression/positional_reference_expression.hpp\"\n+#include \"duckdb/planner/binder.hpp\"\n+#include \"duckdb/planner/expression_binder/where_binder.hpp\"\n+#include \"duckdb/function/scalar/nested_functions.hpp\"\n+#include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/expression/function_expression.hpp\"\n+#include \"duckdb/parser/expression/subquery_expression.hpp\"\n \n namespace duckdb {\n \n-BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref, idx_t depth) {\n-\tD_ASSERT(!colref.column_name.empty());\n-\t// individual column reference\n-\t// resolve to either a base table or a subquery expression\n-\tif (colref.table_name.empty()) {\n-\t\tauto using_binding = binder.bind_context.GetUsingBinding(colref.column_name);\n-\t\tif (using_binding) {\n-\t\t\t// we are referencing a USING column\n-\t\t\t// check if we can refer to one of the base columns directly\n-\t\t\tunique_ptr<Expression> expression;\n-\t\t\tif (!using_binding->primary_binding.empty()) {\n-\t\t\t\t// we can! just assign the table name and re-bind\n-\t\t\t\tcolref.table_name = using_binding->primary_binding;\n-\t\t\t\treturn BindExpression(colref, depth);\n-\t\t\t} else {\n-\t\t\t\t// we cannot! we need to bind this as a coalesce between all the relevant columns\n-\t\t\t\tauto coalesce = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);\n-\t\t\t\tfor (auto &entry : using_binding->bindings) {\n-\t\t\t\t\tcoalesce->children.push_back(make_unique<ColumnRefExpression>(colref.column_name, entry));\n-\t\t\t\t}\n-\t\t\t\treturn BindExpression(*coalesce, depth);\n+unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(const string &column_name, string &error_message) {\n+\tauto using_binding = binder.bind_context.GetUsingBinding(column_name);\n+\tif (using_binding) {\n+\t\t// we are referencing a USING column\n+\t\t// check if we can refer to one of the base columns directly\n+\t\tunique_ptr<Expression> expression;\n+\t\tif (!using_binding->primary_binding.empty()) {\n+\t\t\t// we can! just assign the table name and re-bind\n+\t\t\treturn make_unique<ColumnRefExpression>(column_name, using_binding->primary_binding);\n+\t\t} else {\n+\t\t\t// // we cannot! we need to bind this as a coalesce between all the relevant columns\n+\t\t\tauto coalesce = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);\n+\t\t\tfor (auto &entry : using_binding->bindings) {\n+\t\t\t\tcoalesce->children.push_back(make_unique<ColumnRefExpression>(column_name, entry));\n \t\t\t}\n+\t\t\treturn move(coalesce);\n \t\t}\n-\t\t// no table name: find a binding that contains this\n-\t\tif (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {\n-\t\t\t// priority to macro parameter bindings TODO: throw a warning when this name conflicts\n-\t\t\tcolref.table_name = binder.macro_binding->alias;\n+\t}\n+\t// no table name: find a binding that contains this\n+\tif (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(column_name)) {\n+\t\t// priority to macro parameter bindings TODO: throw a warning when this name conflicts\n+\t\tD_ASSERT(!binder.macro_binding->alias.empty());\n+\t\treturn make_unique<ColumnRefExpression>(column_name, binder.macro_binding->alias);\n+\t} else {\n+\t\tstring table_name = binder.bind_context.GetMatchingBinding(column_name);\n+\t\tif (table_name.empty()) {\n+\t\t\tauto similar_bindings = binder.bind_context.GetSimilarBindings(column_name);\n+\t\t\tstring candidate_str = StringUtil::CandidatesMessage(similar_bindings, \"Candidate bindings\");\n+\t\t\terror_message =\n+\t\t\t    StringUtil::Format(\"Referenced column \\\"%s\\\" not found in FROM clause!%s\", column_name, candidate_str);\n+\t\t\treturn nullptr;\n+\t\t}\n+\t\treturn binder.bind_context.CreateColumnReference(table_name, column_name);\n+\t}\n+}\n+\n+void ExpressionBinder::QualifyColumnNames(unique_ptr<ParsedExpression> &expr) {\n+\tswitch (expr->type) {\n+\tcase ExpressionType::COLUMN_REF: {\n+\t\tauto &colref = (ColumnRefExpression &)*expr;\n+\t\tstring error_message;\n+\t\tauto new_expr = QualifyColumnName(colref, error_message);\n+\t\tif (new_expr) {\n+\t\t\tif (!expr->alias.empty()) {\n+\t\t\t\tnew_expr->alias = expr->alias;\n+\t\t\t}\n+\t\t\texpr = move(new_expr);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase ExpressionType::POSITIONAL_REFERENCE: {\n+\t\tauto &ref = (PositionalReferenceExpression &)*expr;\n+\t\tif (ref.alias.empty()) {\n+\t\t\tstring table_name, column_name;\n+\t\t\tauto error = binder.bind_context.BindColumn(ref, table_name, column_name);\n+\t\t\tif (error.empty()) {\n+\t\t\t\tref.alias = column_name;\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\tParsedExpressionIterator::EnumerateChildren(\n+\t    *expr, [&](unique_ptr<ParsedExpression> &child) { QualifyColumnNames(child); });\n+}\n+\n+void ExpressionBinder::QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr) {\n+\tWhereBinder where_binder(binder, binder.context);\n+\twhere_binder.QualifyColumnNames(expr);\n+}\n+\n+unique_ptr<ParsedExpression> ExpressionBinder::CreateStructExtract(unique_ptr<ParsedExpression> base,\n+                                                                   string field_name) {\n+\tvector<unique_ptr<ParsedExpression>> children;\n+\tchildren.push_back(move(base));\n+\tchildren.push_back(make_unique_base<ParsedExpression, ConstantExpression>(Value(move(field_name))));\n+\tauto extract_fun = make_unique<FunctionExpression>(\"struct_extract\", move(children));\n+\treturn move(extract_fun);\n+}\n+\n+unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(ColumnRefExpression &colref, string &error_message) {\n+\tidx_t column_parts = colref.column_names.size();\n+\t// column names can have an arbitrary amount of dots\n+\t// here is how the resolution works:\n+\tif (column_parts == 1) {\n+\t\t// no dots (i.e. \"part1\")\n+\t\t// -> part1 refers to a column\n+\t\t// check if we can qualify the column name with the table name\n+\t\treturn QualifyColumnName(colref.GetColumnName(), error_message);\n+\t} else if (column_parts == 2) {\n+\t\t// one dot (i.e. \"part1.part2\")\n+\t\t// EITHER:\n+\t\t// -> part1 is a table, part2 is a column\n+\t\t// -> part1 is a column, part2 is a property of that column (i.e. struct_extract)\n+\n+\t\t// first check if part1 is a table\n+\t\tif (binder.HasMatchingBinding(colref.column_names[0], colref.column_names[1], error_message)) {\n+\t\t\t// it is! return the colref directly\n+\t\t\treturn binder.bind_context.CreateColumnReference(colref.column_names[0], colref.column_names[1]);\n \t\t} else {\n-\t\t\tcolref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);\n+\t\t\t// otherwise check if we can turn this into a struct extract\n+\t\t\tauto new_colref = make_unique<ColumnRefExpression>(colref.column_names[0]);\n+\t\t\tstring other_error;\n+\t\t\tauto qualified_colref = QualifyColumnName(colref.column_names[0], other_error);\n+\t\t\tif (!qualified_colref) {\n+\t\t\t\t// we could not! bail\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\t\t\t// we could: create a struct extract\n+\t\t\treturn CreateStructExtract(move(qualified_colref), colref.column_names[1]);\n \t\t}\n-\t\tif (colref.table_name.empty()) {\n-\t\t\tauto similar_bindings = binder.bind_context.GetSimilarBindings(colref.column_name);\n-\t\t\tstring candidate_str = StringUtil::CandidatesMessage(similar_bindings, \"Candidate bindings\");\n-\t\t\treturn BindResult(binder.FormatError(colref.query_location,\n-\t\t\t                                     \"Referenced column \\\"%s\\\" not found in FROM clause!%s\",\n-\t\t\t                                     colref.column_name.c_str(), candidate_str));\n+\t} else {\n+\t\t// two or more dots (i.e. \"part1.part2.part3.part4...\")\n+\t\t// -> part1 is a schema, part2 is a table, part3 is a column name, part4 and beyond are struct fields\n+\t\t// -> part1 is a table, part2 is a column name, part3 and beyond are struct fields\n+\t\t// -> part1 is a column, part2 and beyond are struct fields\n+\n+\t\t// we always prefer the most top-level view\n+\t\t// i.e. in case of multiple resolution options, we resolve in order:\n+\t\t// -> 1. resolve \"part1\" as a schema\n+\t\t// -> 2. resolve \"part1\" as a table\n+\t\t// -> 3. resolve \"part1\" as a column\n+\n+\t\tunique_ptr<ParsedExpression> result_expr;\n+\t\tidx_t struct_extract_start;\n+\t\t// first check if part1 is a schema\n+\t\tif (binder.HasMatchingBinding(colref.column_names[0], colref.column_names[1], colref.column_names[2],\n+\t\t                              error_message)) {\n+\t\t\t// it is! the column reference is \"schema.table.column\"\n+\t\t\t// any additional fields are turned into struct_extract calls\n+\t\t\tresult_expr = binder.bind_context.CreateColumnReference(colref.column_names[0], colref.column_names[1],\n+\t\t\t                                                        colref.column_names[2]);\n+\t\t\tstruct_extract_start = 3;\n+\t\t} else if (binder.HasMatchingBinding(colref.column_names[0], colref.column_names[1], error_message)) {\n+\t\t\t// part1 is a table\n+\t\t\t// the column reference is \"table.column\"\n+\t\t\t// any additional fields are turned into struct_extract calls\n+\t\t\tresult_expr = binder.bind_context.CreateColumnReference(colref.column_names[0], colref.column_names[1]);\n+\t\t\tstruct_extract_start = 2;\n+\t\t} else {\n+\t\t\t// part1 could be a column\n+\t\t\tstring col_error;\n+\t\t\tresult_expr = QualifyColumnName(colref.column_names[0], col_error);\n+\t\t\tif (!result_expr) {\n+\t\t\t\t// it is not! return the error\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\t\t\t// it is! add the struct extract calls\n+\t\t\tstruct_extract_start = 1;\n+\t\t}\n+\t\tfor (idx_t i = struct_extract_start; i < colref.column_names.size(); i++) {\n+\t\t\tresult_expr = CreateStructExtract(move(result_expr), colref.column_names[i]);\n \t\t}\n+\t\treturn result_expr;\n+\t}\n+}\n+\n+BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref_p, idx_t depth) {\n+\tstring error_message;\n+\tauto expr = QualifyColumnName(colref_p, error_message);\n+\tif (!expr) {\n+\t\treturn BindResult(binder.FormatError(colref_p, error_message));\n \t}\n+\tif (expr->type != ExpressionType::COLUMN_REF) {\n+\t\treturn BindExpression(&expr, depth);\n+\t}\n+\tauto &colref = (ColumnRefExpression &)*expr;\n+\tD_ASSERT(colref.column_names.size() == 2 || colref.column_names.size() == 3);\n+\tauto &table_name = colref.column_names.size() == 3 ? colref.column_names[1] : colref.column_names[0];\n+\t// individual column reference\n+\t// resolve to either a base table or a subquery expression\n \t// if it was a macro parameter, let macro_binding bind it to the argument\n-\tBindResult result = binder.macro_binding != nullptr && colref.table_name == binder.macro_binding->alias\n-\t                        ? binder.macro_binding->Bind(colref, depth)\n-\t                        : binder.bind_context.BindColumn(colref, depth);\n+\tBindResult result;\n+\tif (binder.macro_binding && table_name == binder.macro_binding->alias) {\n+\t\tresult = binder.macro_binding->Bind(colref, depth);\n+\t} else {\n+\t\tresult = binder.bind_context.BindColumn(colref, depth);\n+\t}\n \tif (!result.HasError()) {\n \t\tBoundColumnReferenceInfo ref;\n-\t\tref.name = colref.column_name;\n+\t\tref.name = colref.column_names.back();\n \t\tref.query_location = colref.query_location;\n \t\tbound_columns.push_back(move(ref));\n \t} else {\n-\t\tresult.error = binder.FormatError(colref, result.error);\n+\t\tresult.error = binder.FormatError(colref_p, result.error);\n \t}\n \treturn result;\n }\ndiff --git a/src/planner/binder/expression/bind_macro_expression.cpp b/src/planner/binder/expression/bind_macro_expression.cpp\nindex 1451a08172ba..ac4c09ce4e05 100644\n--- a/src/planner/binder/expression/bind_macro_expression.cpp\n+++ b/src/planner/binder/expression/bind_macro_expression.cpp\n@@ -2,11 +2,6 @@\n #include \"duckdb/parser/expression/function_expression.hpp\"\n #include \"duckdb/parser/expression/subquery_expression.hpp\"\n #include \"duckdb/parser/parsed_expression_iterator.hpp\"\n-#include \"duckdb/parser/query_node.hpp\"\n-#include \"duckdb/parser/query_node/recursive_cte_node.hpp\"\n-#include \"duckdb/parser/query_node/select_node.hpp\"\n-#include \"duckdb/parser/query_node/set_operation_node.hpp\"\n-#include \"duckdb/parser/tableref/list.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n \n@@ -17,7 +12,14 @@ void ExpressionBinder::ReplaceMacroParametersRecursive(unique_ptr<ParsedExpressi\n \tcase ExpressionClass::COLUMN_REF: {\n \t\t// if expr is a parameter, replace it with its argument\n \t\tauto &colref = (ColumnRefExpression &)*expr;\n-\t\tif (colref.table_name.empty() && macro_binding->HasMatchingBinding(colref.column_name)) {\n+\t\tbool bind_macro_parameter = false;\n+\t\tif (colref.IsQualified()) {\n+\t\t\tbind_macro_parameter = colref.GetTableName() == MacroBinding::MACRO_NAME;\n+\t\t} else {\n+\t\t\tbind_macro_parameter = macro_binding->HasMatchingBinding(colref.GetColumnName());\n+\t\t}\n+\t\tif (bind_macro_parameter) {\n+\t\t\tD_ASSERT(macro_binding->HasMatchingBinding(colref.GetColumnName()));\n \t\t\texpr = macro_binding->ParamToArg(colref);\n \t\t}\n \t\treturn;\n@@ -25,7 +27,8 @@ void ExpressionBinder::ReplaceMacroParametersRecursive(unique_ptr<ParsedExpressi\n \tcase ExpressionClass::SUBQUERY: {\n \t\t// replacing parameters within a subquery is slightly different\n \t\tauto &sq = ((SubqueryExpression &)*expr).subquery;\n-\t\tReplaceMacroParametersRecursive(*expr, *sq->node);\n+\t\tParsedExpressionIterator::EnumerateQueryNodeChildren(\n+\t\t    *sq->node, [&](unique_ptr<ParsedExpression> &child) { ReplaceMacroParametersRecursive(child); });\n \t\tbreak;\n \t}\n \tdefault: // fall through\n@@ -36,89 +39,6 @@ void ExpressionBinder::ReplaceMacroParametersRecursive(unique_ptr<ParsedExpressi\n \t    *expr, [&](unique_ptr<ParsedExpression> &child) { ReplaceMacroParametersRecursive(child); });\n }\n \n-void ExpressionBinder::ReplaceMacroParametersRecursive(ParsedExpression &expr, TableRef &ref) {\n-\tswitch (ref.type) {\n-\tcase TableReferenceType::CROSS_PRODUCT: {\n-\t\tauto &cp_ref = (CrossProductRef &)ref;\n-\t\tReplaceMacroParametersRecursive(expr, *cp_ref.left);\n-\t\tReplaceMacroParametersRecursive(expr, *cp_ref.right);\n-\t\tbreak;\n-\t}\n-\tcase TableReferenceType::EXPRESSION_LIST: {\n-\t\tauto &el_ref = (ExpressionListRef &)ref;\n-\t\tfor (idx_t i = 0; i < el_ref.values.size(); i++) {\n-\t\t\tfor (idx_t j = 0; j < el_ref.values[i].size(); j++) {\n-\t\t\t\tReplaceMacroParametersRecursive(el_ref.values[i][j]);\n-\t\t\t}\n-\t\t}\n-\t\tbreak;\n-\t}\n-\tcase TableReferenceType::JOIN: {\n-\t\tauto &j_ref = (JoinRef &)ref;\n-\t\tReplaceMacroParametersRecursive(expr, *j_ref.left);\n-\t\tReplaceMacroParametersRecursive(expr, *j_ref.right);\n-\t\tReplaceMacroParametersRecursive(j_ref.condition);\n-\t\tbreak;\n-\t}\n-\tcase TableReferenceType::SUBQUERY: {\n-\t\tauto &sq_ref = (SubqueryRef &)ref;\n-\t\tReplaceMacroParametersRecursive(expr, *sq_ref.subquery->node);\n-\t\tbreak;\n-\t}\n-\tcase TableReferenceType::TABLE_FUNCTION: {\n-\t\tauto &tf_ref = (TableFunctionRef &)ref;\n-\t\tReplaceMacroParametersRecursive(tf_ref.function);\n-\t\tbreak;\n-\t}\n-\tcase TableReferenceType::BASE_TABLE:\n-\tcase TableReferenceType::EMPTY:\n-\t\t// these TableRefs do not need to be unfolded\n-\t\tbreak;\n-\tdefault:\n-\t\tthrow NotImplementedException(\"TableRef type not implemented for macro's!\");\n-\t}\n-}\n-\n-void ExpressionBinder::ReplaceMacroParametersRecursive(ParsedExpression &expr, QueryNode &node) {\n-\tswitch (node.type) {\n-\tcase QueryNodeType::RECURSIVE_CTE_NODE: {\n-\t\tauto &rcte_node = (RecursiveCTENode &)node;\n-\t\tReplaceMacroParametersRecursive(expr, *rcte_node.left);\n-\t\tReplaceMacroParametersRecursive(expr, *rcte_node.right);\n-\t\tbreak;\n-\t}\n-\tcase QueryNodeType::SELECT_NODE: {\n-\t\tauto &sel_node = (SelectNode &)node;\n-\t\tfor (idx_t i = 0; i < sel_node.select_list.size(); i++) {\n-\t\t\tReplaceMacroParametersRecursive(sel_node.select_list[i]);\n-\t\t}\n-\t\tfor (idx_t i = 0; i < sel_node.groups.group_expressions.size(); i++) {\n-\t\t\tReplaceMacroParametersRecursive(sel_node.groups.group_expressions[i]);\n-\t\t}\n-\t\tif (sel_node.where_clause != nullptr) {\n-\t\t\tReplaceMacroParametersRecursive(sel_node.where_clause);\n-\t\t}\n-\t\tif (sel_node.having != nullptr) {\n-\t\t\tReplaceMacroParametersRecursive(sel_node.having);\n-\t\t}\n-\n-\t\tReplaceMacroParametersRecursive(expr, *sel_node.from_table.get());\n-\t\tbreak;\n-\t}\n-\tcase QueryNodeType::SET_OPERATION_NODE: {\n-\t\tauto &setop_node = (SetOperationNode &)node;\n-\t\tReplaceMacroParametersRecursive(expr, *setop_node.left);\n-\t\tReplaceMacroParametersRecursive(expr, *setop_node.right);\n-\t\tbreak;\n-\t}\n-\tdefault:\n-\t\tthrow NotImplementedException(\"QueryNode type not implemented for macro's!\");\n-\t}\n-\tfor (auto &kv : node.cte_map) {\n-\t\tReplaceMacroParametersRecursive(expr, *kv.second->query->node);\n-\t}\n-}\n-\n BindResult ExpressionBinder::BindMacro(FunctionExpression &function, MacroCatalogEntry *macro_func, idx_t depth,\n                                        unique_ptr<ParsedExpression> *expr) {\n \tauto &macro_def = *macro_func->function;\n@@ -137,7 +57,7 @@ BindResult ExpressionBinder::BindMacro(FunctionExpression &function, MacroCatalo\n \tfor (idx_t i = 0; i < macro_def.parameters.size(); i++) {\n \t\ttypes.push_back(LogicalType::SQLNULL);\n \t\tauto &param = (ColumnRefExpression &)*macro_def.parameters[i];\n-\t\tnames.push_back(param.column_name);\n+\t\tnames.push_back(param.GetColumnName());\n \t}\n \t// default parameters\n \tfor (auto it = macro_def.default_parameters.begin(); it != macro_def.default_parameters.end(); it++) {\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 8710a34632f0..2ac13c132d89 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -205,7 +205,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {\n \tfor (idx_t i = 0; i < statement.select_list.size(); i++) {\n \t\tauto &expr = statement.select_list[i];\n \t\tresult->names.push_back(expr->GetName());\n-\t\tExpressionBinder::BindTableNames(*this, *expr);\n+\t\tExpressionBinder::QualifyColumnNames(*this, expr);\n \t\tif (!expr->alias.empty()) {\n \t\t\talias_map[expr->alias] = i;\n \t\t\tresult->names[i] = expr->alias;\n@@ -259,7 +259,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {\n \t\t\t// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because \"test.a\" <> \"a\"\n \t\t\t// hence we convert \"a\" -> \"test.a\" in the unbound expression\n \t\t\tunbound_groups[i] = move(group_binder.unbound_expression);\n-\t\t\tExpressionBinder::BindTableNames(*this, *unbound_groups[i]);\n+\t\t\tExpressionBinder::QualifyColumnNames(*this, unbound_groups[i]);\n \t\t\tinfo.map[unbound_groups[i].get()] = i;\n \t\t}\n \t}\n@@ -268,7 +268,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {\n \t// bind the HAVING clause, if any\n \tif (statement.having) {\n \t\tHavingBinder having_binder(*this, context, *result, info, alias_map);\n-\t\tExpressionBinder::BindTableNames(*this, *statement.having, &alias_map);\n+\t\tExpressionBinder::QualifyColumnNames(*this, statement.having);\n \t\tresult->having = having_binder.Bind(statement.having);\n \t}\n \ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex b71f7124a69d..c8e0fee5a1f3 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -82,11 +82,11 @@ SchemaCatalogEntry *Binder::BindCreateFunctionInfo(CreateInfo &info) {\n \t// positional parameters\n \tfor (idx_t i = 0; i < base.function->parameters.size(); i++) {\n \t\tauto param = (ColumnRefExpression &)*base.function->parameters[i];\n-\t\tif (!param.table_name.empty()) {\n-\t\t\tthrow BinderException(\"Invalid parameter name '%s'\", param.ToString());\n+\t\tif (param.IsQualified()) {\n+\t\t\tthrow BinderException(\"Invalid parameter name '%s': must be unqualified\", param.ToString());\n \t\t}\n \t\tdummy_types.push_back(LogicalType::SQLNULL);\n-\t\tdummy_names.push_back(param.column_name);\n+\t\tdummy_names.push_back(param.GetColumnName());\n \t}\n \t// default parameters\n \tfor (auto it = base.function->default_parameters.begin(); it != base.function->default_parameters.end(); it++) {\n@@ -96,6 +96,7 @@ SchemaCatalogEntry *Binder::BindCreateFunctionInfo(CreateInfo &info) {\n \t}\n \tauto this_macro_binding = make_unique<MacroBinding>(dummy_types, dummy_names, base.name);\n \tmacro_binding = this_macro_binding.get();\n+\tExpressionBinder::QualifyColumnNames(*this, base.function->expression);\n \n \t// create a copy of the expression because we do not want to alter the original\n \tauto expression = base.function->expression->Copy();\ndiff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp\nindex 9bd899c40332..b7e347f3ba8b 100644\n--- a/src/planner/binder/tableref/bind_table_function.cpp\n+++ b/src/planner/binder/tableref/bind_table_function.cpp\n@@ -29,8 +29,8 @@ bool Binder::BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expres\n \t\t\tauto &comp = (ComparisonExpression &)*child;\n \t\t\tif (comp.left->type == ExpressionType::COLUMN_REF) {\n \t\t\t\tauto &colref = (ColumnRefExpression &)*comp.left;\n-\t\t\t\tif (colref.table_name.empty()) {\n-\t\t\t\t\tparameter_name = colref.column_name;\n+\t\t\t\tif (!colref.IsQualified()) {\n+\t\t\t\t\tparameter_name = colref.GetColumnName();\n \t\t\t\t\tchild = move(comp.right);\n \t\t\t\t}\n \t\t\t}\ndiff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp\nindex 250f92231979..383bb491b11b 100644\n--- a/src/planner/expression_binder.cpp\n+++ b/src/planner/expression_binder.cpp\n@@ -80,7 +80,7 @@ bool ExpressionBinder::BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr)\n \tbool success = false;\n \twhile (!active_binders.empty()) {\n \t\tauto &next_binder = active_binders.back();\n-\t\tExpressionBinder::BindTableNames(next_binder->binder, *expr);\n+\t\tExpressionBinder::QualifyColumnNames(next_binder->binder, expr);\n \t\tauto bind_result = next_binder->Bind(&expr, depth);\n \t\tif (bind_result.empty()) {\n \t\t\tsuccess = true;\n@@ -241,31 +241,4 @@ string ExpressionBinder::Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, b\n \t}\n }\n \n-void ExpressionBinder::BindTableNames(Binder &binder, ParsedExpression &expr, unordered_map<string, idx_t> *alias_map) {\n-\tif (expr.type == ExpressionType::COLUMN_REF) {\n-\t\tauto &colref = (ColumnRefExpression &)expr;\n-\t\tif (colref.table_name.empty()) {\n-\t\t\t// no table name: find a binding that contains this\n-\t\t\tif (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {\n-\t\t\t\t// macro parameters get priority\n-\t\t\t\tcolref.table_name = binder.macro_binding->alias;\n-\t\t\t} else {\n-\t\t\t\tcolref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);\n-\t\t\t}\n-\t\t}\n-\t\tbinder.bind_context.BindColumn(colref, 0);\n-\t} else if (expr.type == ExpressionType::POSITIONAL_REFERENCE) {\n-\t\tauto &ref = (PositionalReferenceExpression &)expr;\n-\t\tif (ref.alias.empty()) {\n-\t\t\tstring table_name, column_name;\n-\t\t\tauto error = binder.bind_context.BindColumn(ref, table_name, column_name);\n-\t\t\tif (error.empty()) {\n-\t\t\t\tref.alias = column_name;\n-\t\t\t}\n-\t\t}\n-\t}\n-\tParsedExpressionIterator::EnumerateChildren(\n-\t    expr, [&](const ParsedExpression &child) { BindTableNames(binder, (ParsedExpression &)child, alias_map); });\n-}\n-\n } // namespace duckdb\ndiff --git a/src/planner/expression_binder/alter_binder.cpp b/src/planner/expression_binder/alter_binder.cpp\nindex d8a288a37cd0..d4c320c782f4 100644\n--- a/src/planner/expression_binder/alter_binder.cpp\n+++ b/src/planner/expression_binder/alter_binder.cpp\n@@ -31,13 +31,13 @@ string AlterBinder::UnsupportedAggregateMessage() {\n }\n \n BindResult AlterBinder::BindColumn(ColumnRefExpression &colref) {\n-\tif (!colref.table_name.empty() && colref.table_name != table.name) {\n-\t\tthrow BinderException(\"Cannot reference table %s from within alter statement for table %s!\", colref.table_name,\n-\t\t                      table.name);\n+\tif (colref.column_names.size() > 1) {\n+\t\treturn BindQualifiedColumnName(colref, table.name);\n \t}\n-\tauto idx = table.GetColumnIndex(colref.column_name, true);\n+\tauto idx = table.GetColumnIndex(colref.column_names[0], true);\n \tif (idx == INVALID_INDEX) {\n-\t\tthrow BinderException(\"Table does not contain column %s referenced in alter statement!\", colref.column_name);\n+\t\tthrow BinderException(\"Table does not contain column %s referenced in alter statement!\",\n+\t\t                      colref.column_names[0]);\n \t}\n \tbound_columns.push_back(idx);\n \treturn BindResult(make_unique<BoundReferenceExpression>(table.columns[idx].type, bound_columns.size() - 1));\ndiff --git a/src/planner/expression_binder/check_binder.cpp b/src/planner/expression_binder/check_binder.cpp\nindex 8341a56ccd3d..111f8223e1d6 100644\n--- a/src/planner/expression_binder/check_binder.cpp\n+++ b/src/planner/expression_binder/check_binder.cpp\n@@ -5,9 +5,9 @@\n \n namespace duckdb {\n \n-CheckBinder::CheckBinder(Binder &binder, ClientContext &context, string table, vector<ColumnDefinition> &columns,\n+CheckBinder::CheckBinder(Binder &binder, ClientContext &context, string table_p, vector<ColumnDefinition> &columns,\n                          unordered_set<column_t> &bound_columns)\n-    : ExpressionBinder(binder, context), table(move(table)), columns(columns), bound_columns(bound_columns) {\n+    : ExpressionBinder(binder, context), table(move(table_p)), columns(columns), bound_columns(bound_columns) {\n \ttarget_type = LogicalType::INTEGER;\n }\n \n@@ -29,18 +29,29 @@ string CheckBinder::UnsupportedAggregateMessage() {\n \treturn \"aggregate functions are not allowed in check constraints\";\n }\n \n+BindResult ExpressionBinder::BindQualifiedColumnName(ColumnRefExpression &colref, const string &table_name) {\n+\tidx_t struct_start = 0;\n+\tif (colref.column_names[0] == table_name) {\n+\t\tstruct_start++;\n+\t}\n+\tauto result = make_unique_base<ParsedExpression, ColumnRefExpression>(colref.column_names.back());\n+\tfor (idx_t i = struct_start; i + 1 < colref.column_names.size(); i++) {\n+\t\tresult = CreateStructExtract(move(result), colref.column_names[i]);\n+\t}\n+\treturn BindExpression(&result, 0);\n+}\n+\n BindResult CheckBinder::BindCheckColumn(ColumnRefExpression &colref) {\n-\tif (!colref.table_name.empty() && colref.table_name != table) {\n-\t\tthrow BinderException(\"Cannot reference table %s from within check constraint for table %s!\", colref.table_name,\n-\t\t                      table);\n+\tif (colref.column_names.size() > 1) {\n+\t\treturn BindQualifiedColumnName(colref, table);\n \t}\n \tfor (idx_t i = 0; i < columns.size(); i++) {\n-\t\tif (colref.column_name == columns[i].name) {\n+\t\tif (colref.column_names[0] == columns[i].name) {\n \t\t\tbound_columns.insert(i);\n \t\t\treturn BindResult(make_unique<BoundReferenceExpression>(columns[i].type, i));\n \t\t}\n \t}\n-\tthrow BinderException(\"Table does not contain column %s referenced in check constraint!\", colref.column_name);\n+\tthrow BinderException(\"Table does not contain column %s referenced in check constraint!\", colref.column_names[0]);\n }\n \n } // namespace duckdb\ndiff --git a/src/planner/expression_binder/column_alias_binder.cpp b/src/planner/expression_binder/column_alias_binder.cpp\nindex c7da48757e08..31b9c3572f87 100644\n--- a/src/planner/expression_binder/column_alias_binder.cpp\n+++ b/src/planner/expression_binder/column_alias_binder.cpp\n@@ -12,11 +12,11 @@ ColumnAliasBinder::ColumnAliasBinder(BoundSelectNode &node, const unordered_map<\n \n BindResult ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,\n                                         bool root_expression) {\n-\tif (!expr.table_name.empty()) {\n+\tif (expr.IsQualified()) {\n \t\treturn BindResult(StringUtil::Format(\"Alias %s cannot be qualified.\", expr.ToString()));\n \t}\n \n-\tauto alias_entry = alias_map.find(expr.column_name);\n+\tauto alias_entry = alias_map.find(expr.column_names[0]);\n \tif (alias_entry == alias_map.end()) {\n \t\treturn BindResult(StringUtil::Format(\"Alias %s is not found.\", expr.ToString()));\n \t}\ndiff --git a/src/planner/expression_binder/group_binder.cpp b/src/planner/expression_binder/group_binder.cpp\nindex 5e33f1ef07d1..bc0c65049e9c 100644\n--- a/src/planner/expression_binder/group_binder.cpp\n+++ b/src/planner/expression_binder/group_binder.cpp\n@@ -85,13 +85,13 @@ BindResult GroupBinder::BindColumnRef(ColumnRefExpression &colref) {\n \t// first try to bind to the base columns (original tables)\n \tauto result = ExpressionBinder::BindExpression(colref, 0);\n \tif (result.HasError()) {\n-\t\t// failed to bind the column and the node is the root expression with depth = 0\n-\t\t// check if refers to an alias in the select clause\n-\t\tauto alias_name = colref.column_name;\n-\t\tif (!colref.table_name.empty()) {\n+\t\tif (colref.IsQualified()) {\n \t\t\t// explicit table name: not an alias reference\n \t\t\treturn result;\n \t\t}\n+\t\t// failed to bind the column and the node is the root expression with depth = 0\n+\t\t// check if refers to an alias in the select clause\n+\t\tauto alias_name = colref.column_names[0];\n \t\tauto entry = alias_map.find(alias_name);\n \t\tif (entry == alias_map.end()) {\n \t\t\t// no matching alias found\ndiff --git a/src/planner/expression_binder/order_binder.cpp b/src/planner/expression_binder/order_binder.cpp\nindex 7e8b3e7f2c76..f0b069c2c759 100644\n--- a/src/planner/expression_binder/order_binder.cpp\n+++ b/src/planner/expression_binder/order_binder.cpp\n@@ -55,11 +55,11 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {\n \t\t// check if we can bind it to an alias in the select list\n \t\tauto &colref = (ColumnRefExpression &)*expr;\n \t\t// if there is an explicit table name we can't bind to an alias\n-\t\tif (!colref.table_name.empty()) {\n+\t\tif (colref.IsQualified()) {\n \t\t\tbreak;\n \t\t}\n \t\t// check the alias list\n-\t\tauto entry = alias_map.find(colref.column_name);\n+\t\tauto entry = alias_map.find(colref.column_names[0]);\n \t\tif (entry != alias_map.end()) {\n \t\t\t// it does! point it to that entry\n \t\t\treturn CreateProjectionReference(*expr, entry->second);\n@@ -76,7 +76,7 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {\n \t// general case\n \t// first bind the table names of this entry\n \tfor (auto &binder : binders) {\n-\t\tExpressionBinder::BindTableNames(*binder, *expr);\n+\t\tExpressionBinder::QualifyColumnNames(*binder, expr);\n \t}\n \t// first check if the ORDER BY clause already points to an entry in the projection list\n \tauto entry = projection_map.find(expr.get());\ndiff --git a/src/planner/expression_binder/select_binder.cpp b/src/planner/expression_binder/select_binder.cpp\nindex 93f530784d4b..645887d5192b 100644\n--- a/src/planner/expression_binder/select_binder.cpp\n+++ b/src/planner/expression_binder/select_binder.cpp\n@@ -38,8 +38,8 @@ idx_t SelectBinder::TryBindGroup(ParsedExpression &expr, idx_t depth) {\n \t// first check the group alias map, if expr is a ColumnRefExpression\n \tif (expr.type == ExpressionType::COLUMN_REF) {\n \t\tauto &colref = (ColumnRefExpression &)expr;\n-\t\tif (colref.table_name.empty()) {\n-\t\t\tauto alias_entry = info.alias_map.find(colref.column_name);\n+\t\tif (!colref.IsQualified()) {\n+\t\t\tauto alias_entry = info.alias_map.find(colref.column_names[0]);\n \t\t\tif (alias_entry != info.alias_map.end()) {\n \t\t\t\t// found entry!\n \t\t\t\treturn alias_entry->second;\n@@ -74,7 +74,7 @@ BindResult SelectBinder::BindGroupingFunction(OperatorExpression &op, idx_t dept\n \tvector<idx_t> group_indexes;\n \tgroup_indexes.reserve(op.children.size());\n \tfor (auto &child : op.children) {\n-\t\tExpressionBinder::BindTableNames(binder, *child);\n+\t\tExpressionBinder::QualifyColumnNames(binder, child);\n \t\tauto idx = TryBindGroup(*child, depth);\n \t\tif (idx == INVALID_INDEX) {\n \t\t\treturn BindResult(binder.FormatError(\ndiff --git a/src/planner/operator/logical_get.cpp b/src/planner/operator/logical_get.cpp\nindex 852ada7d2a92..e055125a56bd 100644\n--- a/src/planner/operator/logical_get.cpp\n+++ b/src/planner/operator/logical_get.cpp\n@@ -4,6 +4,7 @@\n #include \"duckdb/storage/data_table.hpp\"\n #include \"duckdb/planner/operator/logical_get.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/function/table/table_scan.hpp\"\n \n namespace duckdb {\n \n@@ -17,6 +18,10 @@ string LogicalGet::GetName() const {\n \treturn StringUtil::Upper(function.name);\n }\n \n+TableCatalogEntry *LogicalGet::GetTable() const {\n+\treturn TableScanFunction::GetTableEntry(function, bind_data.get());\n+}\n+\n string LogicalGet::ParamsToString() const {\n \tstring result;\n \tfor (auto &kv : table_filters.filters) {\ndiff --git a/src/planner/table_binding.cpp b/src/planner/table_binding.cpp\nindex fe30e4772002..a99d66477298 100644\n--- a/src/planner/table_binding.cpp\n+++ b/src/planner/table_binding.cpp\n@@ -34,16 +34,27 @@ bool Binding::TryGetBindingIndex(const string &column_name, column_t &result) {\n \treturn false;\n }\n \n+column_t Binding::GetBindingIndex(const string &column_name) {\n+\tcolumn_t result;\n+\tif (!TryGetBindingIndex(column_name, result)) {\n+\t\tthrow InternalException(\"Binding index for column \\\"%s\\\" not found\", column_name);\n+\t}\n+\treturn result;\n+}\n+\n bool Binding::HasMatchingBinding(const string &column_name) {\n \tcolumn_t result;\n \treturn TryGetBindingIndex(column_name, result);\n }\n \n+string Binding::ColumnNotFoundError(const string &column_name) const {\n+\treturn StringUtil::Format(\"Values list \\\"%s\\\" does not have a column named \\\"%s\\\"\", alias, column_name);\n+}\n+\n BindResult Binding::Bind(ColumnRefExpression &colref, idx_t depth) {\n \tcolumn_t column_index;\n-\tif (!TryGetBindingIndex(colref.column_name, column_index)) {\n-\t\treturn BindResult(StringUtil::Format(\"Values list \\\"%s\\\" does not have a column named \\\"%s\\\"\", alias.c_str(),\n-\t\t                                     colref.column_name.c_str()));\n+\tif (!TryGetBindingIndex(colref.GetColumnName(), column_index)) {\n+\t\treturn BindResult(ColumnNotFoundError(colref.GetColumnName()));\n \t}\n \tColumnBinding binding;\n \tbinding.table_index = index;\n@@ -55,6 +66,10 @@ BindResult Binding::Bind(ColumnRefExpression &colref, idx_t depth) {\n \treturn BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), sql_type, binding, depth));\n }\n \n+TableCatalogEntry *Binding::GetTableEntry() {\n+\treturn nullptr;\n+}\n+\n TableBinding::TableBinding(const string &alias, vector<LogicalType> types_p, vector<string> names_p, LogicalGet &get,\n                            idx_t index, bool add_row_id)\n     : Binding(alias, move(types_p), move(names_p), index), get(get) {\n@@ -66,10 +81,10 @@ TableBinding::TableBinding(const string &alias, vector<LogicalType> types_p, vec\n }\n \n BindResult TableBinding::Bind(ColumnRefExpression &colref, idx_t depth) {\n+\tauto &column_name = colref.GetColumnName();\n \tcolumn_t column_index;\n-\tif (!TryGetBindingIndex(colref.column_name, column_index)) {\n-\t\treturn BindResult(StringUtil::Format(\"Table \\\"%s\\\" does not have a column named \\\"%s\\\"\", colref.table_name,\n-\t\t                                     colref.column_name));\n+\tif (!TryGetBindingIndex(column_name, column_index)) {\n+\t\treturn BindResult(ColumnNotFoundError(column_name));\n \t}\n \t// fetch the type of the column\n \tLogicalType col_type;\n@@ -103,15 +118,22 @@ BindResult TableBinding::Bind(ColumnRefExpression &colref, idx_t depth) {\n \treturn BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), col_type, binding, depth));\n }\n \n+TableCatalogEntry *TableBinding::GetTableEntry() {\n+\treturn get.GetTable();\n+}\n+\n+string TableBinding::ColumnNotFoundError(const string &column_name) const {\n+\treturn StringUtil::Format(\"Table \\\"%s\\\" does not have a column named \\\"%s\\\"\", alias, column_name);\n+}\n+\n MacroBinding::MacroBinding(vector<LogicalType> types_p, vector<string> names_p, string macro_name_p)\n-    : Binding(\"0_macro_parameters\", move(types_p), move(names_p), -1), macro_name(move(macro_name_p)) {\n+    : Binding(MacroBinding::MACRO_NAME, move(types_p), move(names_p), -1), macro_name(move(macro_name_p)) {\n }\n \n BindResult MacroBinding::Bind(ColumnRefExpression &colref, idx_t depth) {\n \tcolumn_t column_index;\n-\tif (!TryGetBindingIndex(colref.column_name, column_index)) {\n-\t\treturn BindResult(\n-\t\t    StringUtil::Format(\"Macro \\\"%s\\\" does not have a parameter named \\\"%s\\\"\", macro_name, colref.column_name));\n+\tif (!TryGetBindingIndex(colref.GetColumnName(), column_index)) {\n+\t\tthrow InternalException(\"Column %s not found in macro\", colref.GetColumnName());\n \t}\n \tColumnBinding binding;\n \tbinding.table_index = index;\n@@ -123,8 +145,8 @@ BindResult MacroBinding::Bind(ColumnRefExpression &colref, idx_t depth) {\n \n unique_ptr<ParsedExpression> MacroBinding::ParamToArg(ColumnRefExpression &colref) {\n \tcolumn_t column_index;\n-\tif (!TryGetBindingIndex(colref.column_name, column_index)) {\n-\t\tthrow BinderException(\"Macro \\\"%s\\\" does not have a parameter named \\\"%s\\\"\", macro_name, colref.column_name);\n+\tif (!TryGetBindingIndex(colref.GetColumnName(), column_index)) {\n+\t\tthrow InternalException(\"Column %s not found in macro\", colref.GetColumnName());\n \t}\n \tauto arg = arguments[column_index]->Copy();\n \targ->alias = colref.alias;\ndiff --git a/src/storage/storage_info.cpp b/src/storage/storage_info.cpp\nindex 4b565c28ecbf..58b796ea4332 100644\n--- a/src/storage/storage_info.cpp\n+++ b/src/storage/storage_info.cpp\n@@ -2,6 +2,6 @@\n \n namespace duckdb {\n \n-const uint64_t VERSION_NUMBER = 27;\n+const uint64_t VERSION_NUMBER = 28;\n \n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/alter/alter_type/alter_type_struct.test b/test/sql/alter/alter_type/alter_type_struct.test\nnew file mode 100644\nindex 000000000000..0657bcde9d2d\n--- /dev/null\n+++ b/test/sql/alter/alter_type/alter_type_struct.test\n@@ -0,0 +1,38 @@\n+# name: test/sql/alter/alter_type/alter_type_struct.test\n+# description: ALTER TYPE with multi column references\n+# group: [alter_type]\n+\n+statement ok\n+CREATE TABLE test AS SELECT {'t': 42} t\n+\n+query I\n+SELECT * FROM test\n+----\n+{'t': 42}\n+\n+statement ok\n+ALTER TABLE test ALTER t TYPE ROW(t VARCHAR) USING {'t': concat('hello', (test.t.t + 42)::varchar)}\n+\n+query I\n+SELECT * FROM test\n+----\n+{'t': hello84}\n+\n+statement ok\n+DROP TABLE test;\n+\n+statement ok\n+CREATE TABLE test AS SELECT {'t': 42} t\n+\n+query I\n+SELECT * FROM test\n+----\n+{'t': 42}\n+\n+statement ok\n+ALTER TABLE test ALTER t TYPE ROW(t VARCHAR) USING {'t': concat('hello', (t.t + 42)::varchar)}\n+\n+query I\n+SELECT * FROM test\n+----\n+{'t': hello84}\ndiff --git a/test/sql/catalog/function/struct_extract_macro.test b/test/sql/catalog/function/struct_extract_macro.test\nnew file mode 100644\nindex 000000000000..4b42af16e133\n--- /dev/null\n+++ b/test/sql/catalog/function/struct_extract_macro.test\n@@ -0,0 +1,28 @@\n+# name: test/sql/catalog/function/struct_extract_macro.test\n+# description: Test struct extract on a macro\n+# group: [function]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE MACRO my_extract(x) AS x.a.b\n+\n+query I\n+SELECT my_extract({'a': {'b': 42}})\n+----\n+42\n+\n+mode skip\n+# FIXME: this does not work yet due to the way in which macro functions are bound\n+# as it is not trivial to fix, for now we leave it as is\n+\n+statement ok\n+CREATE MACRO my_subquery_extract(x) AS (SELECT x.a.b);\n+\n+query I\n+SELECT my_subquery_extract({'a': {'b': 42}})\n+----\n+42\n+\n+mode unskip\ndiff --git a/test/sql/catalog/function/test_simple_macro.test b/test/sql/catalog/function/test_simple_macro.test\nindex 8345e5060304..054c223a79a9 100644\n--- a/test/sql/catalog/function/test_simple_macro.test\n+++ b/test/sql/catalog/function/test_simple_macro.test\n@@ -167,11 +167,10 @@ CREATE MACRO IFELSE(a,b) AS a+b\n statement error\n CREATE MACRO ifelse(a,b) AS a+b\n \n-# TODO: uncomment when macro parameters are pushed as a projection\n-#query T\n-#SELECT IFELSE(1, 'random', RANDOM())\n-#----\n-#random\n+query T\n+SELECT IFELSE(1, 'random', RANDOM())\n+----\n+random\n \n # macro in a different schema\n statement ok\n@@ -196,20 +195,18 @@ CREATE MACRO myavg(x) AS SUM(x) / COUNT(x)\n statement ok\n INSERT INTO integers VALUES (21), (41);\n \n-# TODO: uncomment when macro parameters are pushed as a projection\n-#query T\n-#SELECT myavg(a) FROM integers\n-#----\n-#21\n+query T\n+SELECT myavg(a) FROM integers\n+----\n+21\n \n statement ok\n CREATE MACRO weird_avg(x) AS (MIN(x) + MAX(x)) / COUNT(x)\n \n-# TODO: uncomment when macro parameters are pushed as a projection\n-#query T\n-#SELECT weird_avg(a) FROM integers\n-#----\n-#14\n+query T\n+SELECT weird_avg(a) FROM integers\n+----\n+14\n \n statement error\n CREATE MACRO star() AS *\n@@ -277,3 +274,21 @@ SELECT two_default_params(a := 5, a := 3)\n \n statement error\n SELECT two_default_params(b := 5, b := 3)\n+\n+statement error\n+CREATE MACRO macros.add(a, b) AS a + b\n+\n+statement error\n+CREATE MACRO my_macro(a.b) AS 42;\n+\n+statement error\n+CREATE MACRO my_macro(a.b.c) AS 42;\n+\n+statement ok\n+CREATE MACRO my_macro(a) AS 42;\n+\n+statement error\n+SELECT my_macro(x := 42);\n+\n+statement error\n+SELECT my_macro(a := 42, a := 42);\n\\ No newline at end of file\ndiff --git a/test/sql/constraints/check/check_struct.test b/test/sql/constraints/check/check_struct.test\nnew file mode 100644\nindex 000000000000..27c46b826c0e\n--- /dev/null\n+++ b/test/sql/constraints/check/check_struct.test\n@@ -0,0 +1,28 @@\n+# name: test/sql/constraints/check/check_struct.test\n+# description: CHECK constraint on structs\n+# group: [check]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE tbl(t ROW(t INTEGER) CHECK(t.t=42));\n+\n+statement error\n+INSERT INTO tbl VALUES ({'t': 43})\n+\n+statement ok\n+INSERT INTO tbl VALUES ({'t': 42})\n+\n+statement ok\n+DROP TABLE tbl;\n+\n+# we can also do this while referencing the table name\n+statement ok\n+CREATE TABLE tbl(t ROW(t INTEGER) CHECK(tbl.t.t=42));\n+\n+statement error\n+INSERT INTO tbl VALUES ({'t': 43})\n+\n+statement ok\n+INSERT INTO tbl VALUES ({'t': 42})\ndiff --git a/test/sql/constraints/test_check.test b/test/sql/constraints/check/test_check.test\nsimilarity index 65%\nrename from test/sql/constraints/test_check.test\nrename to test/sql/constraints/check/test_check.test\nindex dc106e22253f..b239755ec919 100644\n--- a/test/sql/constraints/test_check.test\n+++ b/test/sql/constraints/check/test_check.test\n@@ -1,6 +1,6 @@\n-# name: test/sql/constraints/test_check.test\n+# name: test/sql/constraints/check/test_check.test\n # description: CHECK constraint\n-# group: [constraints]\n+# group: [check]\n \n statement ok\n CREATE TABLE integers(i INTEGER CHECK(i < 5))\n@@ -46,3 +46,14 @@ CREATE TABLE integers2(i INTEGER CHECK(i > (SELECT 42)), j INTEGER)\n statement error\n CREATE TABLE integers2(i INTEGER CHECK(i > SUM(j)), j INTEGER)\n \n+statement error\n+CREATE TABLE integers3(i INTEGER CHECK(k < 10), j INTEGER)\n+\n+statement error\n+CREATE TABLE integers3(i INTEGER CHECK(integers3.k < 10), j INTEGER)\n+\n+statement error\n+CREATE TABLE integers3(i INTEGER CHECK(integers2.i < 10), j INTEGER)\n+\n+statement ok\n+CREATE TABLE integers4(i INTEGER CHECK(integers4.i < 10), j INTEGER)\ndiff --git a/test/sql/select/test_multi_column_reference.test b/test/sql/select/test_multi_column_reference.test\nnew file mode 100644\nindex 000000000000..0805cd42099e\n--- /dev/null\n+++ b/test/sql/select/test_multi_column_reference.test\n@@ -0,0 +1,164 @@\n+# name: test/sql/select/test_multi_column_reference.test\n+# description: Test multi column reference\n+# group: [select]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# column names can have an arbitrary amount of dots\n+# here is how the resolution works:\n+# no dots (i.e. \"part1\")\n+# -> part1 refers to a column\n+# one dot (i.e. \"part1.part2\")\n+# EITHER:\n+# -> part1 is a table, part2 is a column\n+# -> part1 is a column, part2 is a property of that column (i.e. struct_extract)\n+# two or more dots (i.e. \"part1.part2.part3.part4...\")\n+# -> part1 is a schema, part2 is a table, part3 is a column name, part4 and beyond are struct fields\n+# -> part1 is a table, part2 is a column name, part3 and beyond are struct fields\n+# -> part1 is a column, part2 and beyond are struct fields\n+\n+# we always prefer the most top-level view\n+# i.e. in case of multiple resolution options, we resolve in order:\n+# -> 1. resolve \"part1\" as a schema\n+# -> 2. resolve \"part1\" as a table\n+# -> 3. resolve \"part1\" as a column\n+\n+# schema -> table -> column reference\n+statement ok\n+CREATE SCHEMA test\n+\n+statement ok\n+CREATE TABLE test.tbl(col INTEGER);\n+\n+statement ok\n+INSERT INTO test.tbl VALUES (1), (2), (3);\n+\n+query I\n+SELECT test.tbl.col FROM test.tbl;\n+----\n+1\n+2\n+3\n+\n+# schema name with alias does not work\n+statement error\n+SELECT test.t.col FROM test.tbl t;\n+\n+statement error\n+SELECT test.tbl.col FROM test.tbl t;\n+\n+# check how ties are resolved\n+# we create a table called \"t\" in a schema called \"t\" with a column called \"t\" that has a field called \"t\"\n+statement ok\n+CREATE SCHEMA t\n+\n+statement ok\n+CREATE TABLE t.t(t ROW(t INTEGER));\n+\n+statement ok\n+INSERT INTO t.t VALUES ({'t': 42});\n+\n+# \"t\" selects the column\n+query I\n+SELECT t FROM t.t;\n+----\n+{'t': 42}\n+\n+# \"t.t\" also selects the column\n+query I\n+SELECT t.t FROM t.t;\n+----\n+{'t': 42}\n+\n+# t.t.t also selects the column\n+query I\n+SELECT t.t.t FROM t.t;\n+----\n+{'t': 42}\n+\n+# t.t.t.t selects the field\n+query I\n+SELECT t.t.t.t FROM t.t;\n+----\n+42\n+\n+statement ok\n+DROP SCHEMA t CASCADE;\n+\n+# test long nested struct\n+statement ok\n+CREATE SCHEMA t\n+\n+statement ok\n+CREATE TABLE t.t AS SELECT {'t': {'t': {'t': {'t': {'t': 42}}}}} t\n+\n+query I\n+SELECT t.t.t.t.t.t.t.t FROM t.t;\n+----\n+42\n+\n+query I\n+SELECT t.t.t.t.t.t.t FROM t.t;\n+----\n+{'t': 42}\n+\n+query I\n+SELECT t.t.t.t.t.t FROM t.t;\n+----\n+{'t': {'t': 42}}\n+\n+query I\n+SELECT t.t.t.t.t FROM t.t;\n+----\n+{'t': {'t': {'t': 42}}}\n+\n+query I\n+SELECT t.t.t.t FROM t.t;\n+----\n+{'t': {'t': {'t': {'t': 42}}}}\n+\n+query I\n+SELECT t.t.t FROM t.t;\n+----\n+{'t': {'t': {'t': {'t': {'t': 42}}}}}\n+\n+query I\n+SELECT t.t FROM t.t;\n+----\n+{'t': {'t': {'t': {'t': {'t': 42}}}}}\n+\n+query I\n+SELECT t FROM t.t;\n+----\n+{'t': {'t': {'t': {'t': {'t': 42}}}}}\n+\n+statement ok\n+DROP SCHEMA t CASCADE\n+\n+# test multiple tables with the same name but a different schema\n+# we don't allow this (duplicate alias in query)\n+statement ok\n+CREATE SCHEMA s1\n+\n+statement ok\n+CREATE SCHEMA s2\n+\n+statement ok\n+CREATE TABLE s1.t1 AS SELECT 42 t\n+\n+statement ok\n+CREATE TABLE s2.t1 AS SELECT 84 t\n+\n+statement error\n+SELECT s1.t1.t FROM s1.t1, s2.t1\n+\n+# test various failures\n+statement error\n+SELECT testX.tbl.col FROM test.tbl;\n+\n+statement error\n+SELECT test.tblX.col FROM test.tbl;\n+\n+statement error\n+SELECT test.tbl.colX FROM test.tbl;\ndiff --git a/test/sql/select/test_projection_names.test b/test/sql/select/test_projection_names.test\nnew file mode 100644\nindex 000000000000..783559dd14a5\n--- /dev/null\n+++ b/test/sql/select/test_projection_names.test\n@@ -0,0 +1,61 @@\n+# name: test/sql/select/test_projection_names.test\n+# description: Test projection lists\n+# group: [select]\n+\n+statement ok\n+CREATE TABLE integers(\"COL1\" INTEGER, \"COL2\" INTEGER)\n+\n+# *\n+statement ok\n+CREATE TABLE tbl AS SELECT * FROM integers\n+\n+query I\n+SELECT name FROM pragma_table_info('tbl') ORDER BY name\n+----\n+COL1\n+COL2\n+\n+statement ok\n+DROP TABLE tbl\n+\n+# col1, col2\n+statement ok\n+CREATE TABLE tbl AS SELECT COL1, COL2 FROM integers\n+\n+query I\n+SELECT name FROM pragma_table_info('tbl') ORDER BY name\n+----\n+COL1\n+COL2\n+\n+statement ok\n+DROP TABLE tbl\n+\n+# explicit table reference\n+statement ok\n+CREATE TABLE tbl AS SELECT integers.COL1, integers.COL2 FROM integers\n+\n+query I\n+SELECT name FROM pragma_table_info('tbl') ORDER BY name\n+----\n+COL1\n+COL2\n+\n+statement ok\n+DROP TABLE tbl\n+\n+# explicit schema reference\n+statement ok\n+CREATE SCHEMA s1;\n+\n+statement ok\n+CREATE TABLE s1.integers(\"COL1\" INTEGER, \"COL2\" INTEGER)\n+\n+statement ok\n+CREATE TABLE tbl AS SELECT s1.integers.COL1, s1.integers.COL2 FROM s1.integers\n+\n+query I\n+SELECT name FROM pragma_table_info('tbl') ORDER BY name\n+----\n+COL1\n+COL2\ndiff --git a/test/sql/select/test_schema_reference.test b/test/sql/select/test_schema_reference.test\nnew file mode 100644\nindex 000000000000..b974b9df4bff\n--- /dev/null\n+++ b/test/sql/select/test_schema_reference.test\n@@ -0,0 +1,24 @@\n+# name: test/sql/select/test_schema_reference.test\n+# description: Test schema reference in column reference\n+# group: [select]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE SCHEMA s1;\n+\n+statement ok\n+CREATE TABLE s1.tbl(i INTEGER)\n+\n+# standard schema reference\n+statement ok\n+SELECT s1.tbl.i FROM s1.tbl;\n+\n+# schema mismatch\n+statement error\n+SELECT s2.tbl.i FROM s1.tbl;\n+\n+# no schema present\n+statement error\n+SELECT a.tbl.i FROM range(10) tbl(i)\n\\ No newline at end of file\ndiff --git a/test/sql/storage_version/storage_version.db b/test/sql/storage_version/storage_version.db\nindex f6cae75bc0ec..243232ee79d5 100644\nBinary files a/test/sql/storage_version/storage_version.db and b/test/sql/storage_version/storage_version.db differ\n",
  "problem_statement": "Support for more intuitive nested field access\nHi, thank you for your work!\r\n\r\nI have a question/request regarding field access of nested structs. Given a table created such as the following:\r\n```sql\r\nCREATE TABLE x(y ROW(z ROW(w INTEGER)))\r\n```\r\nI found that based on some experimentation, the following queries work:\r\n```sql\r\n[1] SELECT (x.y).z.w FROM x\r\n[2] SELECT (y).z.w FROM x\r\n[3] SELECT x.y['z'].w FROM x\r\n```\r\nWhile the following do not:\r\n```sql\r\n# Not implemented Error: ColumnRef not implemented!\r\n[4] SELECT x.y.z.w FROM x\r\n[5] SELECT x.y.z FROM x\r\n[6] SELECT (x.y.z).w FROM x\r\n[7] SELECT (x.y.z.w) FROM x\r\n# Binder Error: Referenced table \"y\" not found!\r\n# Candidate tables: \"x\"\r\n[8] SELECT y.z FROM x\r\n```\r\nIt seems like there are only specific ways of accessing these kinds of nested fields that are supported. From what I can tell, the root-level struct either has to be wrapped in parentheses or the second level field has to be accessed using the subscript operator. Would you be able to provide some background on why the more \"intuitive\" syntax of `x.y.z.w` is not supported? Are there plans to add support for this syntax in the future?\n",
  "hints_text": "",
  "created_at": "2021-11-10T15:55:00Z"
}