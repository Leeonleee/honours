{
  "repo": "duckdb/duckdb",
  "pull_number": 10194,
  "instance_id": "duckdb__duckdb-10194",
  "issue_numbers": [
    "10096",
    "10096"
  ],
  "base_commit": "db09b507fb5af6368495f6323ad2e2eccc444447",
  "patch": "diff --git a/src/common/enum_util.cpp b/src/common/enum_util.cpp\nindex fd275b2d7284..90d1916ae5c2 100644\n--- a/src/common/enum_util.cpp\n+++ b/src/common/enum_util.cpp\n@@ -2175,6 +2175,10 @@ const char* EnumUtil::ToChars<ExtraTypeInfoType>(ExtraTypeInfoType value) {\n \t\treturn \"AGGREGATE_STATE_TYPE_INFO\";\n \tcase ExtraTypeInfoType::ARRAY_TYPE_INFO:\n \t\treturn \"ARRAY_TYPE_INFO\";\n+\tcase ExtraTypeInfoType::ANY_TYPE_INFO:\n+\t\treturn \"ANY_TYPE_INFO\";\n+\tcase ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO:\n+\t\treturn \"INTEGER_LITERAL_TYPE_INFO\";\n \tdefault:\n \t\tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%d' not implemented\", value));\n \t}\n@@ -2212,6 +2216,12 @@ ExtraTypeInfoType EnumUtil::FromString<ExtraTypeInfoType>(const char *value) {\n \tif (StringUtil::Equals(value, \"ARRAY_TYPE_INFO\")) {\n \t\treturn ExtraTypeInfoType::ARRAY_TYPE_INFO;\n \t}\n+\tif (StringUtil::Equals(value, \"ANY_TYPE_INFO\")) {\n+\t\treturn ExtraTypeInfoType::ANY_TYPE_INFO;\n+\t}\n+\tif (StringUtil::Equals(value, \"INTEGER_LITERAL_TYPE_INFO\")) {\n+\t\treturn ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO;\n+\t}\n \tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%s' not implemented\", value));\n }\n \n@@ -3129,6 +3139,8 @@ const char* EnumUtil::ToChars<LogicalTypeId>(LogicalTypeId value) {\n \t\treturn \"BIT\";\n \tcase LogicalTypeId::STRING_LITERAL:\n \t\treturn \"STRING_LITERAL\";\n+\tcase LogicalTypeId::INTEGER_LITERAL:\n+\t\treturn \"INTEGER_LITERAL\";\n \tcase LogicalTypeId::UHUGEINT:\n \t\treturn \"UHUGEINT\";\n \tcase LogicalTypeId::HUGEINT:\n@@ -3257,6 +3269,9 @@ LogicalTypeId EnumUtil::FromString<LogicalTypeId>(const char *value) {\n \tif (StringUtil::Equals(value, \"STRING_LITERAL\")) {\n \t\treturn LogicalTypeId::STRING_LITERAL;\n \t}\n+\tif (StringUtil::Equals(value, \"INTEGER_LITERAL\")) {\n+\t\treturn LogicalTypeId::INTEGER_LITERAL;\n+\t}\n \tif (StringUtil::Equals(value, \"UHUGEINT\")) {\n \t\treturn LogicalTypeId::UHUGEINT;\n \t}\ndiff --git a/src/common/extra_type_info.cpp b/src/common/extra_type_info.cpp\nindex e024131f1e68..1dee1cae0eb7 100644\n--- a/src/common/extra_type_info.cpp\n+++ b/src/common/extra_type_info.cpp\n@@ -330,4 +330,34 @@ bool ArrayTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {\n \treturn child_type == other.child_type && size == other.size;\n }\n \n+//===--------------------------------------------------------------------===//\n+// Any Type Info\n+//===--------------------------------------------------------------------===//\n+AnyTypeInfo::AnyTypeInfo() : ExtraTypeInfo(ExtraTypeInfoType::ANY_TYPE_INFO) {\n+}\n+\n+AnyTypeInfo::AnyTypeInfo(LogicalType target_type_p, idx_t cast_score_p)\n+    : ExtraTypeInfo(ExtraTypeInfoType::ANY_TYPE_INFO), target_type(std::move(target_type_p)), cast_score(cast_score_p) {\n+}\n+\n+bool AnyTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {\n+\tauto &other = other_p->Cast<AnyTypeInfo>();\n+\treturn target_type == other.target_type && cast_score == other.cast_score;\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// Any Type Info\n+//===--------------------------------------------------------------------===//\n+IntegerLiteralTypeInfo::IntegerLiteralTypeInfo() : ExtraTypeInfo(ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO) {\n+}\n+\n+IntegerLiteralTypeInfo::IntegerLiteralTypeInfo(Value constant_value_p)\n+    : ExtraTypeInfo(ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO), constant_value(std::move(constant_value_p)) {\n+}\n+\n+bool IntegerLiteralTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {\n+\tauto &other = other_p->Cast<IntegerLiteralTypeInfo>();\n+\treturn constant_value == other.constant_value;\n+}\n+\n } // namespace duckdb\ndiff --git a/src/common/types.cpp b/src/common/types.cpp\nindex 0274d728ba6b..1b3f7745ea9b 100644\n--- a/src/common/types.cpp\n+++ b/src/common/types.cpp\n@@ -151,6 +151,7 @@ PhysicalType LogicalType::GetInternalType() {\n \tcase LogicalTypeId::INVALID:\n \tcase LogicalTypeId::UNKNOWN:\n \tcase LogicalTypeId::STRING_LITERAL:\n+\tcase LogicalTypeId::INTEGER_LITERAL:\n \t\treturn PhysicalType::INVALID;\n \tcase LogicalTypeId::USER:\n \t\treturn PhysicalType::UNKNOWN;\n@@ -634,6 +635,8 @@ bool LogicalType::GetDecimalProperties(uint8_t &width, uint8_t &scale) const {\n \t\twidth = DecimalType::GetWidth(*this);\n \t\tscale = DecimalType::GetScale(*this);\n \t\tbreak;\n+\tcase LogicalTypeId::INTEGER_LITERAL:\n+\t\treturn IntegerLiteral::GetType(*this).GetDecimalProperties(width, scale);\n \tdefault:\n \t\t// Nonsense values to ensure initialization\n \t\twidth = 255u;\n@@ -708,11 +711,15 @@ static LogicalType CombineNumericTypes(const LogicalType &left, const LogicalTyp\n \tthrow InternalException(\"Cannot combine these numeric types (%s & %s)\", left.ToString(), right.ToString());\n }\n \n-static LogicalType ReturnType(const LogicalType &type) {\n-\tif (type.id() == LogicalTypeId::STRING_LITERAL) {\n+LogicalType LogicalType::NormalizeType(const LogicalType &type) {\n+\tswitch (type.id()) {\n+\tcase LogicalTypeId::STRING_LITERAL:\n \t\treturn LogicalType::VARCHAR;\n+\tcase LogicalTypeId::INTEGER_LITERAL:\n+\t\treturn IntegerLiteral::GetType(type);\n+\tdefault:\n+\t\treturn type;\n \t}\n-\treturn type;\n }\n \n template <class OP>\n@@ -728,10 +735,10 @@ static bool CombineUnequalTypes(const LogicalType &left, const LogicalType &righ\n \tLogicalTypeId other_types[] = {LogicalTypeId::UNKNOWN, LogicalTypeId::SQLNULL, LogicalTypeId::STRING_LITERAL};\n \tfor (auto &other_type : other_types) {\n \t\tif (left.id() == other_type) {\n-\t\t\tresult = ReturnType(right);\n+\t\t\tresult = LogicalType::NormalizeType(right);\n \t\t\treturn true;\n \t\t} else if (right.id() == other_type) {\n-\t\t\tresult = ReturnType(left);\n+\t\t\tresult = LogicalType::NormalizeType(left);\n \t\t\treturn true;\n \t\t}\n \t}\n@@ -759,6 +766,13 @@ static bool CombineUnequalTypes(const LogicalType &left, const LogicalType &righ\n \t\t}\n \t\treturn true;\n \t}\n+\t// for integer literals - rerun the operation with the underlying type\n+\tif (left.id() == LogicalTypeId::INTEGER_LITERAL) {\n+\t\treturn OP::Operation(IntegerLiteral::GetType(left), right, result);\n+\t}\n+\tif (right.id() == LogicalTypeId::INTEGER_LITERAL) {\n+\t\treturn OP::Operation(left, IntegerLiteral::GetType(right), result);\n+\t}\n \t// for unsigned/signed comparisons we have a few fallbacks\n \tif (left.IsNumeric() && right.IsNumeric()) {\n \t\tresult = CombineNumericTypes(left, right);\n@@ -784,6 +798,9 @@ static bool CombineEqualTypes(const LogicalType &left, const LogicalType &right,\n \t\t// two string literals convert to varchar\n \t\tresult = LogicalType::VARCHAR;\n \t\treturn true;\n+\tcase LogicalTypeId::INTEGER_LITERAL:\n+\t\t// for two integer literals we unify the underlying types\n+\t\treturn OP::Operation(IntegerLiteral::GetType(left), IntegerLiteral::GetType(right), result);\n \tcase LogicalTypeId::ENUM:\n \t\t// If both types are different ENUMs we do a string comparison.\n \t\tresult = left == right ? left : LogicalType::VARCHAR;\n@@ -920,13 +937,13 @@ bool LogicalType::TryGetMaxLogicalType(ClientContext &context, const LogicalType\n }\n \n static idx_t GetLogicalTypeScore(const LogicalType &type) {\n-\treturn idx_t(type.id());\n \tswitch (type.id()) {\n \tcase LogicalTypeId::INVALID:\n \tcase LogicalTypeId::SQLNULL:\n \tcase LogicalTypeId::UNKNOWN:\n \tcase LogicalTypeId::ANY:\n \tcase LogicalTypeId::STRING_LITERAL:\n+\tcase LogicalTypeId::INTEGER_LITERAL:\n \t\treturn 0;\n \t// numerics\n \tcase LogicalTypeId::BOOLEAN:\n@@ -1429,6 +1446,67 @@ LogicalType LogicalType::ARRAY(const LogicalType &child) {\n \treturn LogicalType(LogicalTypeId::ARRAY, std::move(info));\n }\n \n+//===--------------------------------------------------------------------===//\n+// Any Type\n+//===--------------------------------------------------------------------===//\n+LogicalType LogicalType::ANY_PARAMS(LogicalType target, idx_t cast_score) { // NOLINT\n+\tauto type_info = make_shared<AnyTypeInfo>(std::move(target), cast_score);\n+\treturn LogicalType(LogicalTypeId::ANY, std::move(type_info));\n+}\n+\n+LogicalType AnyType::GetTargetType(const LogicalType &type) {\n+\tD_ASSERT(type.id() == LogicalTypeId::ANY);\n+\tauto info = type.AuxInfo();\n+\tif (!info) {\n+\t\treturn LogicalType::ANY;\n+\t}\n+\treturn info->Cast<AnyTypeInfo>().target_type;\n+}\n+\n+idx_t AnyType::GetCastScore(const LogicalType &type) {\n+\tD_ASSERT(type.id() == LogicalTypeId::ANY);\n+\tauto info = type.AuxInfo();\n+\tif (!info) {\n+\t\treturn 5;\n+\t}\n+\treturn info->Cast<AnyTypeInfo>().cast_score;\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// Integer Literal Type\n+//===--------------------------------------------------------------------===//\n+LogicalType IntegerLiteral::GetType(const LogicalType &type) {\n+\tD_ASSERT(type.id() == LogicalTypeId::INTEGER_LITERAL);\n+\tauto info = type.AuxInfo();\n+\tD_ASSERT(info && info->type == ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO);\n+\treturn info->Cast<IntegerLiteralTypeInfo>().constant_value.type();\n+}\n+\n+bool IntegerLiteral::FitsInType(const LogicalType &type, const LogicalType &target) {\n+\tD_ASSERT(type.id() == LogicalTypeId::INTEGER_LITERAL);\n+\t// we can always cast integer literals to float and double\n+\tif (target.id() == LogicalTypeId::FLOAT || target.id() == LogicalTypeId::DOUBLE) {\n+\t\treturn true;\n+\t}\n+\tif (!target.IsIntegral()) {\n+\t\treturn false;\n+\t}\n+\t// we can cast to integral types if the constant value fits within that type\n+\tauto info = type.AuxInfo();\n+\tD_ASSERT(info && info->type == ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO);\n+\tauto &literal_info = info->Cast<IntegerLiteralTypeInfo>();\n+\tValue copy = literal_info.constant_value;\n+\treturn copy.DefaultTryCastAs(target);\n+}\n+\n+LogicalType LogicalType::INTEGER_LITERAL(const Value &constant) { // NOLINT\n+\tif (!constant.type().IsIntegral()) {\n+\t\tthrow InternalException(\"INTEGER_LITERAL can only be made from literals of integer types\");\n+\t}\n+\tauto type_info = make_shared<IntegerLiteralTypeInfo>(constant);\n+\treturn LogicalType(LogicalTypeId::INTEGER_LITERAL, std::move(type_info));\n+}\n+\n //===--------------------------------------------------------------------===//\n // Logical Type\n //===--------------------------------------------------------------------===//\ndiff --git a/src/core_functions/aggregate/distributive/approx_count.cpp b/src/core_functions/aggregate/distributive/approx_count.cpp\nindex ec1555c38ca2..844e31acfd9d 100644\n--- a/src/core_functions/aggregate/distributive/approx_count.cpp\n+++ b/src/core_functions/aggregate/distributive/approx_count.cpp\n@@ -110,12 +110,6 @@ static void ApproxCountDistinctUpdateFunction(Vector inputs[], AggregateInputDat\n \tHyperLogLog::AddToLogs(vdata, count, indices, counts, reinterpret_cast<HyperLogLog ***>(states), sdata.sel);\n }\n \n-unique_ptr<FunctionData> ApproxCountDistinctAnyBind(ClientContext &context, AggregateFunction &function,\n-                                                    vector<unique_ptr<Expression>> &arguments) {\n-\tfunction.arguments[0] = LogicalType::VARCHAR;\n-\treturn nullptr;\n-}\n-\n AggregateFunction GetApproxCountDistinctFunction(const LogicalType &input_type) {\n \tauto fun = AggregateFunction(\n \t    {input_type}, LogicalTypeId::BIGINT, AggregateFunction::StateSize<ApproxDistinctCountState>,\n@@ -123,8 +117,7 @@ AggregateFunction GetApproxCountDistinctFunction(const LogicalType &input_type)\n \t    ApproxCountDistinctUpdateFunction,\n \t    AggregateFunction::StateCombine<ApproxDistinctCountState, ApproxCountDistinctFunction>,\n \t    AggregateFunction::StateFinalize<ApproxDistinctCountState, int64_t, ApproxCountDistinctFunction>,\n-\t    ApproxCountDistinctSimpleUpdateFunction,\n-\t    input_type.id() == LogicalTypeId::ANY ? ApproxCountDistinctAnyBind : nullptr,\n+\t    ApproxCountDistinctSimpleUpdateFunction, nullptr,\n \t    AggregateFunction::StateDestroy<ApproxDistinctCountState, ApproxCountDistinctFunction>);\n \tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \treturn fun;\n@@ -146,7 +139,7 @@ AggregateFunctionSet ApproxCountDistinctFun::GetFunctions() {\n \tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::TIMESTAMP));\n \tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::TIMESTAMP_TZ));\n \tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::BLOB));\n-\tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::ANY));\n+\tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::ANY_PARAMS(LogicalType::VARCHAR, 150)));\n \treturn approx_count;\n }\n \ndiff --git a/src/core_functions/aggregate/distributive/entropy.cpp b/src/core_functions/aggregate/distributive/entropy.cpp\nindex 71cd6bf6056a..e66f30783468 100644\n--- a/src/core_functions/aggregate/distributive/entropy.cpp\n+++ b/src/core_functions/aggregate/distributive/entropy.cpp\n@@ -120,12 +120,6 @@ AggregateFunction GetEntropyFunction(const LogicalType &input_type, const Logica\n \treturn fun;\n }\n \n-static unique_ptr<FunctionData> EntropyVarcharBind(ClientContext &context, AggregateFunction &function,\n-                                                   vector<unique_ptr<Expression>> &arguments) {\n-\tfunction.arguments[0] = LogicalType::VARCHAR;\n-\treturn nullptr;\n-}\n-\n AggregateFunction GetEntropyFunctionInternal(PhysicalType type) {\n \tswitch (type) {\n \tcase PhysicalType::UINT16:\n@@ -153,11 +147,9 @@ AggregateFunction GetEntropyFunctionInternal(PhysicalType type) {\n \t\treturn AggregateFunction::UnaryAggregateDestructor<EntropyState<double>, double, double, EntropyFunction>(\n \t\t    LogicalType::DOUBLE, LogicalType::DOUBLE);\n \tcase PhysicalType::VARCHAR: {\n-\t\tAggregateFunction result =\n-\t\t    AggregateFunction::UnaryAggregateDestructor<EntropyState<string>, string_t, double, EntropyFunctionString>(\n-\t\t        LogicalType::ANY, LogicalType::DOUBLE);\n-\t\tresult.bind = EntropyVarcharBind;\n-\t\treturn result;\n+\t\treturn AggregateFunction::UnaryAggregateDestructor<EntropyState<string>, string_t, double,\n+\t\t                                                   EntropyFunctionString>(\n+\t\t    LogicalType::ANY_PARAMS(LogicalType::VARCHAR, 150), LogicalType::DOUBLE);\n \t}\n \n \tdefault:\ndiff --git a/src/core_functions/aggregate/distributive/string_agg.cpp b/src/core_functions/aggregate/distributive/string_agg.cpp\nindex 4c6e2b48a2f5..bd3e95fb6fcd 100644\n--- a/src/core_functions/aggregate/distributive/string_agg.cpp\n+++ b/src/core_functions/aggregate/distributive/string_agg.cpp\n@@ -119,7 +119,6 @@ struct StringAggFunction {\n \n unique_ptr<FunctionData> StringAggBind(ClientContext &context, AggregateFunction &function,\n                                        vector<unique_ptr<Expression>> &arguments) {\n-\tfunction.arguments[0] = LogicalType::VARCHAR;\n \tif (arguments.size() == 1) {\n \t\t// single argument: default to comma\n \t\treturn make_uniq<StringAggBindData>(\",\");\n@@ -156,7 +155,8 @@ unique_ptr<FunctionData> StringAggDeserialize(Deserializer &deserializer, Aggreg\n AggregateFunctionSet StringAggFun::GetFunctions() {\n \tAggregateFunctionSet string_agg;\n \tAggregateFunction string_agg_param(\n-\t    {LogicalType::ANY}, LogicalType::VARCHAR, AggregateFunction::StateSize<StringAggState>,\n+\t    {LogicalType::ANY_PARAMS(LogicalType::VARCHAR)}, LogicalType::VARCHAR,\n+\t    AggregateFunction::StateSize<StringAggState>,\n \t    AggregateFunction::StateInitialize<StringAggState, StringAggFunction>,\n \t    AggregateFunction::UnaryScatterUpdate<StringAggState, string_t, StringAggFunction>,\n \t    AggregateFunction::StateCombine<StringAggState, StringAggFunction>,\ndiff --git a/src/core_functions/aggregate/holistic/mode.cpp b/src/core_functions/aggregate/holistic/mode.cpp\nindex 6ec899bc4cab..ab6a76bce8d8 100644\n--- a/src/core_functions/aggregate/holistic/mode.cpp\n+++ b/src/core_functions/aggregate/holistic/mode.cpp\n@@ -308,21 +308,12 @@ struct ModeFunction {\n \t}\n };\n \n-static unique_ptr<FunctionData> ModeVarcharBind(ClientContext &context, AggregateFunction &function,\n-                                                vector<unique_ptr<Expression>> &arguments) {\n-\tfunction.arguments[0] = LogicalType::VARCHAR;\n-\treturn nullptr;\n-}\n-\n template <typename INPUT_TYPE, typename KEY_TYPE, typename ASSIGN_OP = ModeAssignmentStandard>\n AggregateFunction GetTypedModeFunction(const LogicalType &type) {\n \tusing STATE = ModeState<KEY_TYPE>;\n \tusing OP = ModeFunction<KEY_TYPE, ASSIGN_OP>;\n \tauto return_type = type.id() == LogicalTypeId::ANY ? LogicalType::VARCHAR : type;\n \tauto func = AggregateFunction::UnaryAggregateDestructor<STATE, INPUT_TYPE, INPUT_TYPE, OP>(type, return_type);\n-\tif (type.id() == LogicalTypeId::ANY) {\n-\t\tfunc.bind = ModeVarcharBind;\n-\t}\n \tfunc.window = AggregateFunction::UnaryWindow<STATE, INPUT_TYPE, INPUT_TYPE, OP>;\n \treturn func;\n }\n@@ -359,7 +350,8 @@ AggregateFunction GetModeAggregate(const LogicalType &type) {\n \t\treturn GetTypedModeFunction<interval_t, interval_t>(type);\n \n \tcase PhysicalType::VARCHAR:\n-\t\treturn GetTypedModeFunction<string_t, string, ModeAssignmentString>(LogicalType::ANY);\n+\t\treturn GetTypedModeFunction<string_t, string, ModeAssignmentString>(\n+\t\t    LogicalType::ANY_PARAMS(LogicalType::VARCHAR, 150));\n \n \tdefault:\n \t\tthrow NotImplementedException(\"Unimplemented mode aggregate\");\ndiff --git a/src/core_functions/aggregate/holistic/quantile.cpp b/src/core_functions/aggregate/holistic/quantile.cpp\nindex c8dd699fdb05..a9af11250f44 100644\n--- a/src/core_functions/aggregate/holistic/quantile.cpp\n+++ b/src/core_functions/aggregate/holistic/quantile.cpp\n@@ -1224,7 +1224,6 @@ AggregateFunction GetContinuousQuantileListAggregateFunction(const LogicalType &\n \t\treturn GetTypedContinuousQuantileListAggregateFunction<int64_t, double>(type, LogicalType::DOUBLE);\n \tcase LogicalTypeId::HUGEINT:\n \t\treturn GetTypedContinuousQuantileListAggregateFunction<hugeint_t, double>(type, LogicalType::DOUBLE);\n-\n \tcase LogicalTypeId::FLOAT:\n \t\treturn GetTypedContinuousQuantileListAggregateFunction<float, float>(type, type);\n \tcase LogicalTypeId::DOUBLE:\n@@ -1242,8 +1241,6 @@ AggregateFunction GetContinuousQuantileListAggregateFunction(const LogicalType &\n \t\tdefault:\n \t\t\tthrow NotImplementedException(\"Unimplemented discrete quantile DECIMAL list aggregate\");\n \t\t}\n-\t\tbreak;\n-\n \tcase LogicalTypeId::DATE:\n \t\treturn GetTypedContinuousQuantileListAggregateFunction<date_t, timestamp_t>(type, LogicalType::TIMESTAMP);\n \tcase LogicalTypeId::TIMESTAMP:\n@@ -1252,7 +1249,6 @@ AggregateFunction GetContinuousQuantileListAggregateFunction(const LogicalType &\n \tcase LogicalTypeId::TIME:\n \tcase LogicalTypeId::TIME_TZ:\n \t\treturn GetTypedContinuousQuantileListAggregateFunction<dtime_t, dtime_t>(type, type);\n-\n \tdefault:\n \t\tthrow NotImplementedException(\"Unimplemented discrete quantile list aggregate\");\n \t}\n@@ -1415,9 +1411,6 @@ struct MedianAbsoluteDeviationOperation : public QuantileOperation {\n \n unique_ptr<FunctionData> BindMedian(ClientContext &context, AggregateFunction &function,\n                                     vector<unique_ptr<Expression>> &arguments) {\n-\tif (function.arguments[0].id() == LogicalTypeId::ANY) {\n-\t\tfunction.arguments[0] = LogicalType::VARCHAR;\n-\t}\n \treturn make_uniq<QuantileBindData>(Value::DECIMAL(int16_t(5), 2, 1));\n }\n \n@@ -1662,10 +1655,13 @@ AggregateFunction GetQuantileDecimalAggregate(const vector<LogicalType> &argumen\n }\n \n vector<LogicalType> GetQuantileTypes() {\n-\treturn {LogicalType::TINYINT,   LogicalType::SMALLINT, LogicalType::INTEGER,      LogicalType::BIGINT,\n-\t        LogicalType::HUGEINT,   LogicalType::FLOAT,    LogicalType::DOUBLE,       LogicalType::DATE,\n-\t        LogicalType::TIMESTAMP, LogicalType::TIME,     LogicalType::TIMESTAMP_TZ, LogicalType::TIME_TZ,\n-\t        LogicalType::INTERVAL,  LogicalType::ANY};\n+\treturn {LogicalType::TINYINT,      LogicalType::SMALLINT,\n+\t        LogicalType::INTEGER,      LogicalType::BIGINT,\n+\t        LogicalType::HUGEINT,      LogicalType::FLOAT,\n+\t        LogicalType::DOUBLE,       LogicalType::DATE,\n+\t        LogicalType::TIMESTAMP,    LogicalType::TIME,\n+\t        LogicalType::TIMESTAMP_TZ, LogicalType::TIME_TZ,\n+\t        LogicalType::INTERVAL,     LogicalType::ANY_PARAMS(LogicalType::VARCHAR, 150)};\n }\n \n AggregateFunctionSet MedianFun::GetFunctions() {\ndiff --git a/src/core_functions/aggregate/nested/histogram.cpp b/src/core_functions/aggregate/nested/histogram.cpp\nindex e28093743e45..2f7414340e9c 100644\n--- a/src/core_functions/aggregate/nested/histogram.cpp\n+++ b/src/core_functions/aggregate/nested/histogram.cpp\n@@ -155,12 +155,8 @@ unique_ptr<FunctionData> HistogramBindFunction(ClientContext &context, Aggregate\n \t    arguments[0]->return_type.id() == LogicalTypeId::MAP) {\n \t\tthrow NotImplementedException(\"Unimplemented type for histogram %s\", arguments[0]->return_type.ToString());\n \t}\n-\tif (function.arguments[0].id() == LogicalTypeId::ANY) {\n-\t\t// add varchar cast for ANY\n-\t\tfunction.arguments[0] = LogicalType::VARCHAR;\n-\t}\n-\n-\tauto struct_type = LogicalType::MAP(arguments[0]->return_type, LogicalType::UBIGINT);\n+\tauto child_type = function.arguments[0].id() == LogicalTypeId::ANY ? LogicalType::VARCHAR : function.arguments[0];\n+\tauto struct_type = LogicalType::MAP(child_type, LogicalType::UBIGINT);\n \n \tfunction.return_type = struct_type;\n \treturn make_uniq<VariableReturnBindData>(function.return_type);\n@@ -188,47 +184,46 @@ AggregateFunction GetMapType(const LogicalType &type) {\n \n template <bool IS_ORDERED = true>\n AggregateFunction GetHistogramFunction(const LogicalType &type) {\n-\n \tswitch (type.id()) {\n-\tcase LogicalType::BOOLEAN:\n+\tcase LogicalTypeId::BOOLEAN:\n \t\treturn GetMapType<HistogramFunctor, bool, IS_ORDERED>(type);\n-\tcase LogicalType::UTINYINT:\n+\tcase LogicalTypeId::UTINYINT:\n \t\treturn GetMapType<HistogramFunctor, uint8_t, IS_ORDERED>(type);\n-\tcase LogicalType::USMALLINT:\n+\tcase LogicalTypeId::USMALLINT:\n \t\treturn GetMapType<HistogramFunctor, uint16_t, IS_ORDERED>(type);\n-\tcase LogicalType::UINTEGER:\n+\tcase LogicalTypeId::UINTEGER:\n \t\treturn GetMapType<HistogramFunctor, uint32_t, IS_ORDERED>(type);\n-\tcase LogicalType::UBIGINT:\n+\tcase LogicalTypeId::UBIGINT:\n \t\treturn GetMapType<HistogramFunctor, uint64_t, IS_ORDERED>(type);\n-\tcase LogicalType::TINYINT:\n+\tcase LogicalTypeId::TINYINT:\n \t\treturn GetMapType<HistogramFunctor, int8_t, IS_ORDERED>(type);\n-\tcase LogicalType::SMALLINT:\n+\tcase LogicalTypeId::SMALLINT:\n \t\treturn GetMapType<HistogramFunctor, int16_t, IS_ORDERED>(type);\n-\tcase LogicalType::INTEGER:\n+\tcase LogicalTypeId::INTEGER:\n \t\treturn GetMapType<HistogramFunctor, int32_t, IS_ORDERED>(type);\n-\tcase LogicalType::BIGINT:\n+\tcase LogicalTypeId::BIGINT:\n \t\treturn GetMapType<HistogramFunctor, int64_t, IS_ORDERED>(type);\n-\tcase LogicalType::FLOAT:\n+\tcase LogicalTypeId::FLOAT:\n \t\treturn GetMapType<HistogramFunctor, float, IS_ORDERED>(type);\n-\tcase LogicalType::DOUBLE:\n+\tcase LogicalTypeId::DOUBLE:\n \t\treturn GetMapType<HistogramFunctor, double, IS_ORDERED>(type);\n-\tcase LogicalType::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP:\n \t\treturn GetMapType<HistogramFunctor, timestamp_t, IS_ORDERED>(type);\n-\tcase LogicalType::TIMESTAMP_TZ:\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n \t\treturn GetMapType<HistogramFunctor, timestamp_tz_t, IS_ORDERED>(type);\n-\tcase LogicalType::TIMESTAMP_S:\n+\tcase LogicalTypeId::TIMESTAMP_SEC:\n \t\treturn GetMapType<HistogramFunctor, timestamp_sec_t, IS_ORDERED>(type);\n-\tcase LogicalType::TIMESTAMP_MS:\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n \t\treturn GetMapType<HistogramFunctor, timestamp_ms_t, IS_ORDERED>(type);\n-\tcase LogicalType::TIMESTAMP_NS:\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n \t\treturn GetMapType<HistogramFunctor, timestamp_ns_t, IS_ORDERED>(type);\n-\tcase LogicalType::TIME:\n+\tcase LogicalTypeId::TIME:\n \t\treturn GetMapType<HistogramFunctor, dtime_t, IS_ORDERED>(type);\n-\tcase LogicalType::TIME_TZ:\n+\tcase LogicalTypeId::TIME_TZ:\n \t\treturn GetMapType<HistogramFunctor, dtime_tz_t, IS_ORDERED>(type);\n-\tcase LogicalType::DATE:\n+\tcase LogicalTypeId::DATE:\n \t\treturn GetMapType<HistogramFunctor, date_t, IS_ORDERED>(type);\n-\tcase LogicalType::ANY:\n+\tcase LogicalTypeId::ANY:\n \t\treturn GetMapType<HistogramStringFunctor, string, IS_ORDERED>(type);\n \tdefault:\n \t\tthrow InternalException(\"Unimplemented histogram aggregate\");\n@@ -256,7 +251,7 @@ AggregateFunctionSet HistogramFun::GetFunctions() {\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::TIME));\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::TIME_TZ));\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::DATE));\n-\tfun.AddFunction(GetHistogramFunction<>(LogicalType::ANY));\n+\tfun.AddFunction(GetHistogramFunction<>(LogicalType::ANY_PARAMS(LogicalType::VARCHAR)));\n \treturn fun;\n }\n \ndiff --git a/src/core_functions/scalar/list/list_value.cpp b/src/core_functions/scalar/list/list_value.cpp\nindex 386fbd958438..34674be4d47e 100644\n--- a/src/core_functions/scalar/list/list_value.cpp\n+++ b/src/core_functions/scalar/list/list_value.cpp\n@@ -45,9 +45,7 @@ static unique_ptr<FunctionData> ListValueBind(ClientContext &context, ScalarFunc\n \t\t\t                      child_type.ToString(), arg_type.ToString());\n \t\t}\n \t}\n-\tif (child_type.id() == LogicalTypeId::STRING_LITERAL) {\n-\t\tchild_type = LogicalType::VARCHAR;\n-\t}\n+\tchild_type = LogicalType::NormalizeType(child_type);\n \n \t// this is more for completeness reasons\n \tbound_function.varargs = child_type;\ndiff --git a/src/function/cast_rules.cpp b/src/function/cast_rules.cpp\nindex f1963c192f23..84a4bd03b982 100644\n--- a/src/function/cast_rules.cpp\n+++ b/src/function/cast_rules.cpp\n@@ -5,14 +5,16 @@ namespace duckdb {\n //! The target type determines the preferred implicit casts\n static int64_t TargetTypeCost(const LogicalType &type) {\n \tswitch (type.id()) {\n-\tcase LogicalTypeId::INTEGER:\n-\t\treturn 103;\n \tcase LogicalTypeId::BIGINT:\n \t\treturn 101;\n-\tcase LogicalTypeId::DOUBLE:\n+\tcase LogicalTypeId::INTEGER:\n \t\treturn 102;\n \tcase LogicalTypeId::HUGEINT:\n-\t\treturn 120;\n+\t\treturn 103;\n+\tcase LogicalTypeId::DOUBLE:\n+\t\treturn 104;\n+\tcase LogicalTypeId::DECIMAL:\n+\t\treturn 105;\n \tcase LogicalTypeId::TIMESTAMP_NS:\n \t\treturn 119;\n \tcase LogicalTypeId::TIMESTAMP:\n@@ -23,8 +25,6 @@ static int64_t TargetTypeCost(const LogicalType &type) {\n \t\treturn 122;\n \tcase LogicalTypeId::VARCHAR:\n \t\treturn 149;\n-\tcase LogicalTypeId::DECIMAL:\n-\t\treturn 104;\n \tcase LogicalTypeId::STRUCT:\n \tcase LogicalTypeId::MAP:\n \tcase LogicalTypeId::LIST:\n@@ -32,7 +32,7 @@ static int64_t TargetTypeCost(const LogicalType &type) {\n \tcase LogicalTypeId::ARRAY:\n \t\treturn 160;\n \tcase LogicalTypeId::ANY:\n-\t\treturn 5;\n+\t\treturn int64_t(AnyType::GetCastScore(type));\n \tdefault:\n \t\treturn 110;\n \t}\n@@ -325,19 +325,31 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\t// string literals can be cast to any type for low cost as long as the type is valid\n \t\t// i.e. we cannot cast to LIST(ANY) as we don't know what \"ANY\" should be\n \t\t// we cannot cast to DECIMAL without precision/width specified\n-\t\t// etc...\n-\t\t// the exception is the ANY type - for the ANY type we just cast to VARCHAR\n-\t\t// but we prefer casting to VARCHAR\n-\t\tif (to.id() != LogicalType::ANY) {\n-\t\t\tif (!LogicalTypeIsValid(to)) {\n-\t\t\t\treturn -1;\n-\t\t\t}\n+\t\tif (!LogicalTypeIsValid(to)) {\n+\t\t\treturn -1;\n \t\t}\n \t\tif (to.id() == LogicalTypeId::VARCHAR && to.GetAlias().empty()) {\n \t\t\treturn 1;\n \t\t}\n \t\treturn 20;\n \t}\n+\tif (from.id() == LogicalTypeId::INTEGER_LITERAL) {\n+\t\t// the integer literal has an underlying type - this type always matches\n+\t\tif (IntegerLiteral::GetType(from).id() == to.id()) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\t// integer literals can be cast to any other integer type for a low cost, but only if the literal fits\n+\t\tif (IntegerLiteral::FitsInType(from, to)) {\n+\t\t\t// to avoid ties we prefer BIGINT, INT, ...\n+\t\t\tauto target_cost = TargetTypeCost(to);\n+\t\t\tif (target_cost < 100) {\n+\t\t\t\tthrow InternalException(\"Integer literal implicit cast - TargetTypeCost should be >= 100\");\n+\t\t\t}\n+\t\t\treturn target_cost - 90;\n+\t\t}\n+\t\t// in any other case we use the casting rules of the preferred type of the literal\n+\t\treturn CastRules::ImplicitCast(IntegerLiteral::GetType(from), to);\n+\t}\n \tif (from.GetAlias() != to.GetAlias()) {\n \t\t// if aliases are different, an implicit cast is not possible\n \t\treturn -1;\ndiff --git a/src/function/function_binder.cpp b/src/function/function_binder.cpp\nindex 20ce9c40c90d..b6596c7c059f 100644\n--- a/src/function/function_binder.cpp\n+++ b/src/function/function_binder.cpp\n@@ -238,11 +238,28 @@ LogicalTypeComparisonResult RequiresCast(const LogicalType &source_type, const L\n \treturn LogicalTypeComparisonResult::DIFFERENT_TYPES;\n }\n \n+LogicalType PrepareTypeForCast(const LogicalType &type) {\n+\tif (type.id() == LogicalTypeId::ANY) {\n+\t\treturn AnyType::GetTargetType(type);\n+\t}\n+\tif (type.id() == LogicalTypeId::LIST) {\n+\t\treturn LogicalType::LIST(PrepareTypeForCast(ListType::GetChildType(type)));\n+\t}\n+\treturn type;\n+}\n+\n void FunctionBinder::CastToFunctionArguments(SimpleFunction &function, vector<unique_ptr<Expression>> &children) {\n+\tfor (auto &arg : function.arguments) {\n+\t\targ = PrepareTypeForCast(arg);\n+\t}\n+\tfunction.varargs = PrepareTypeForCast(function.varargs);\n+\n \tfor (idx_t i = 0; i < children.size(); i++) {\n \t\tauto target_type = i < function.arguments.size() ? function.arguments[i] : function.varargs;\n-\t\tif (target_type.id() == LogicalTypeId::STRING_LITERAL) {\n-\t\t\tthrow InternalException(\"Function %s returned a STRING_LITERAL type - use VARCHAR instead\", function.name);\n+\t\tif (target_type.id() == LogicalTypeId::STRING_LITERAL || target_type.id() == LogicalTypeId::INTEGER_LITERAL) {\n+\t\t\tthrow InternalException(\n+\t\t\t    \"Function %s returned a STRING_LITERAL or INTEGER_LITERAL type - return an explicit type instead\",\n+\t\t\t    function.name);\n \t\t}\n \t\ttarget_type.Verify();\n \t\t// don't cast lambda children, they get removed before execution\ndiff --git a/src/include/duckdb/common/extra_type_info.hpp b/src/include/duckdb/common/extra_type_info.hpp\nindex 32ccdd32caea..930c44a33b5d 100644\n--- a/src/include/duckdb/common/extra_type_info.hpp\n+++ b/src/include/duckdb/common/extra_type_info.hpp\n@@ -25,6 +25,8 @@ enum class ExtraTypeInfoType : uint8_t {\n \tUSER_TYPE_INFO = 7,\n \tAGGREGATE_STATE_TYPE_INFO = 8,\n \tARRAY_TYPE_INFO = 9,\n+\tANY_TYPE_INFO = 10,\n+\tINTEGER_LITERAL_TYPE_INFO = 11\n };\n \n struct ExtraTypeInfo {\n@@ -199,4 +201,37 @@ struct ArrayTypeInfo : public ExtraTypeInfo {\n \tbool EqualsInternal(ExtraTypeInfo *other_p) const override;\n };\n \n+struct AnyTypeInfo : public ExtraTypeInfo {\n+\tAnyTypeInfo(LogicalType target_type, idx_t cast_score);\n+\n+\tLogicalType target_type;\n+\tidx_t cast_score;\n+\n+public:\n+\tvoid Serialize(Serializer &serializer) const override;\n+\tstatic shared_ptr<ExtraTypeInfo> Deserialize(Deserializer &source);\n+\n+protected:\n+\tbool EqualsInternal(ExtraTypeInfo *other_p) const override;\n+\n+private:\n+\tAnyTypeInfo();\n+};\n+\n+struct IntegerLiteralTypeInfo : public ExtraTypeInfo {\n+\tIntegerLiteralTypeInfo(Value constant_value);\n+\n+\tValue constant_value;\n+\n+public:\n+\tvoid Serialize(Serializer &serializer) const override;\n+\tstatic shared_ptr<ExtraTypeInfo> Deserialize(Deserializer &source);\n+\n+protected:\n+\tbool EqualsInternal(ExtraTypeInfo *other_p) const override;\n+\n+private:\n+\tIntegerLiteralTypeInfo();\n+};\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/common/types.hpp b/src/include/duckdb/common/types.hpp\nindex 2462892b4a7e..862a7057ff26 100644\n--- a/src/include/duckdb/common/types.hpp\n+++ b/src/include/duckdb/common/types.hpp\n@@ -213,6 +213,7 @@ enum class LogicalTypeId : uint8_t {\n \tTIME_TZ = 34,\n \tBIT = 36,\n \tSTRING_LITERAL = 37, /* string literals, used for constant strings - only exists while binding */\n+\tINTEGER_LITERAL = 38,/* integer literals, used for constant integers - only exists while binding */\n \n \tUHUGEINT = 49,\n \tHUGEINT = 50,\n@@ -307,6 +308,8 @@ struct LogicalType {\n \tDUCKDB_API static bool TryGetMaxLogicalType(ClientContext &context, const LogicalType &left, const LogicalType &right, LogicalType &result);\n \t//! Forcibly returns a maximum logical type - similar to MaxLogicalType but never throws. As a fallback either left or right are returned.\n \tDUCKDB_API static LogicalType ForceMaxLogicalType(const LogicalType &left, const LogicalType &right);\n+\t//! Normalize a type - removing literals\n+\tDUCKDB_API static LogicalType NormalizeType(const LogicalType &type);\n \n \n \t\t//! Gets the decimal properties of a numeric type. Fails if the type is not numeric.\n@@ -374,6 +377,10 @@ struct LogicalType {\n \t// an array of unknown size (only used for binding)\n \tDUCKDB_API static LogicalType ARRAY(const LogicalType &child);        // NOLINT\n \tDUCKDB_API static LogicalType ENUM(Vector &ordered_data, idx_t size); // NOLINT\n+\t// ANY but with special rules (default is LogicalType::ANY, 5)\n+\tDUCKDB_API static LogicalType ANY_PARAMS(LogicalType target, idx_t cast_score = 5); // NOLINT\n+\t//! Integer literal of the specified value\n+\tDUCKDB_API static LogicalType INTEGER_LITERAL(const Value &constant);               // NOLINT\n \t// DEPRECATED - provided for backwards compatibility\n \tDUCKDB_API static LogicalType ENUM(const string &enum_name, Vector &ordered_data, idx_t size); // NOLINT\n \tDUCKDB_API static LogicalType USER(const string &user_type_name);                              // NOLINT\n@@ -456,6 +463,18 @@ struct AggregateStateType {\n \tDUCKDB_API static const aggregate_state_t &GetStateType(const LogicalType &type);\n };\n \n+struct AnyType {\n+\tDUCKDB_API static LogicalType GetTargetType(const LogicalType &type);\n+\tDUCKDB_API static idx_t GetCastScore(const LogicalType &type);\n+};\n+\n+struct IntegerLiteral {\n+\t//! Returns the type that this integer literal \"prefers\"\n+\tDUCKDB_API static LogicalType GetType(const LogicalType &type);\n+\t//! Whether or not the integer literal fits into the target numeric type\n+\tDUCKDB_API static bool FitsInType(const LogicalType &type, const LogicalType &target);\n+};\n+\n // **DEPRECATED**: Use EnumUtil directly instead.\n DUCKDB_API string LogicalTypeIdToString(LogicalTypeId type);\n \ndiff --git a/src/include/duckdb/storage/serialization/types.json b/src/include/duckdb/storage/serialization/types.json\nindex f89234e269dd..dd4cf2b7f147 100644\n--- a/src/include/duckdb/storage/serialization/types.json\n+++ b/src/include/duckdb/storage/serialization/types.json\n@@ -156,5 +156,34 @@\n     \"base\": \"ExtraTypeInfo\",\n     \"enum\": \"GENERIC_TYPE_INFO\",\n     \"custom_switch_code\": \"result = make_shared<ExtraTypeInfo>(type);\\nbreak;\"\n+  },\n+  {\n+    \"class\": \"AnyTypeInfo\",\n+    \"base\": \"ExtraTypeInfo\",\n+    \"enum\": \"ANY_TYPE_INFO\",\n+    \"members\": [\n+      {\n+        \"id\": 200,\n+        \"name\": \"target_type\",\n+        \"type\": \"LogicalType\"\n+      },\n+      {\n+        \"id\": 201,\n+        \"name\": \"cast_score\",\n+        \"type\": \"idx_t\"\n+      }\n+    ]\n+  },\n+  {\n+    \"class\": \"IntegerLiteralTypeInfo\",\n+    \"base\": \"ExtraTypeInfo\",\n+    \"enum\": \"INTEGER_LITERAL_TYPE_INFO\",\n+    \"members\": [\n+      {\n+        \"id\": 200,\n+        \"name\": \"constant_value\",\n+        \"type\": \"Value\"\n+      }\n+    ]\n   }\n ]\ndiff --git a/src/planner/binder/expression/bind_comparison_expression.cpp b/src/planner/binder/expression/bind_comparison_expression.cpp\nindex 89e19c72d37a..c3f6aebffd30 100644\n--- a/src/planner/binder/expression/bind_comparison_expression.cpp\n+++ b/src/planner/binder/expression/bind_comparison_expression.cpp\n@@ -97,6 +97,7 @@ static bool SwitchVarcharComparison(const LogicalType &type) {\n \tcase LogicalTypeId::INTERVAL:\n \tcase LogicalTypeId::TIMESTAMP_TZ:\n \tcase LogicalTypeId::TIME_TZ:\n+\tcase LogicalTypeId::INTEGER_LITERAL:\n \t\treturn true;\n \tdefault:\n \t\treturn false;\n@@ -155,9 +156,9 @@ bool BoundComparisonExpression::TryBindComparison(ClientContext &context, const\n \tcase LogicalTypeId::VARCHAR:\n \t\t// for comparison with strings, we prefer to bind to the numeric types\n \t\tif (left_type.id() != LogicalTypeId::VARCHAR && SwitchVarcharComparison(left_type)) {\n-\t\t\tres = left_type;\n+\t\t\tres = LogicalType::NormalizeType(left_type);\n \t\t} else if (right_type.id() != LogicalTypeId::VARCHAR && SwitchVarcharComparison(right_type)) {\n-\t\t\tres = right_type;\n+\t\t\tres = LogicalType::NormalizeType(right_type);\n \t\t} else {\n \t\t\t// else: check if collations are compatible\n \t\t\tauto left_collation = StringType::GetCollation(left_type);\n@@ -185,9 +186,14 @@ LogicalType BoundComparisonExpression::BindComparison(ClientContext &context, co\n }\n \n LogicalType ExpressionBinder::GetExpressionReturnType(const Expression &expr) {\n-\tif (expr.return_type == LogicalTypeId::VARCHAR && expr.expression_class == ExpressionClass::BOUND_CONSTANT &&\n-\t    StringType::GetCollation(expr.return_type).empty()) {\n-\t\treturn LogicalTypeId::STRING_LITERAL;\n+\tif (expr.expression_class == ExpressionClass::BOUND_CONSTANT) {\n+\t\tif (expr.return_type == LogicalTypeId::VARCHAR && StringType::GetCollation(expr.return_type).empty()) {\n+\t\t\treturn LogicalTypeId::STRING_LITERAL;\n+\t\t}\n+\t\tif (expr.return_type.IsIntegral()) {\n+\t\t\tauto &constant = expr.Cast<BoundConstantExpression>();\n+\t\t\treturn LogicalType::INTEGER_LITERAL(constant.value);\n+\t\t}\n \t}\n \treturn expr.return_type;\n }\ndiff --git a/src/planner/binder/tableref/bind_expressionlistref.cpp b/src/planner/binder/tableref/bind_expressionlistref.cpp\nindex 337458a649a6..5ed88d52e10b 100644\n--- a/src/planner/binder/tableref/bind_expressionlistref.cpp\n+++ b/src/planner/binder/tableref/bind_expressionlistref.cpp\n@@ -50,9 +50,7 @@ unique_ptr<BoundTableRef> Binder::Bind(ExpressionListRef &expr) {\n \t\t\t}\n \t\t}\n \t\tfor (auto &type : result->types) {\n-\t\t\tif (type.id() == LogicalTypeId::STRING_LITERAL) {\n-\t\t\t\ttype = LogicalType::VARCHAR;\n-\t\t\t}\n+\t\t\ttype = LogicalType::NormalizeType(type);\n \t\t}\n \t\t// finally do another loop over the expressions and add casts where required\n \t\tfor (idx_t list_idx = 0; list_idx < result->values.size(); list_idx++) {\ndiff --git a/src/planner/expression/bound_cast_expression.cpp b/src/planner/expression/bound_cast_expression.cpp\nindex ede876e7f981..9699fd706948 100644\n--- a/src/planner/expression/bound_cast_expression.cpp\n+++ b/src/planner/expression/bound_cast_expression.cpp\n@@ -81,12 +81,6 @@ unique_ptr<Expression> AddCastToTypeInternal(unique_ptr<Expression> expr, const\n \t\tauto &def = expr->Cast<BoundDefaultExpression>();\n \t\tdef.return_type = target_type;\n \t}\n-\tif (expr->return_type.id() == LogicalTypeId::STRING_LITERAL) {\n-\t\t// when adding a cast to a string literal we need to transform the constant back into a VARCHAR\n-\t\tauto &constant = expr->Cast<BoundConstantExpression>();\n-\t\tconstant.value = Value(StringValue::Get(constant.value));\n-\t\tconstant.return_type = LogicalType::VARCHAR;\n-\t}\n \tif (!target_type.IsValid()) {\n \t\treturn expr;\n \t}\ndiff --git a/src/storage/serialization/serialize_types.cpp b/src/storage/serialization/serialize_types.cpp\nindex c00c9b62d16b..0b75f518b8eb 100644\n--- a/src/storage/serialization/serialize_types.cpp\n+++ b/src/storage/serialization/serialize_types.cpp\n@@ -22,6 +22,9 @@ shared_ptr<ExtraTypeInfo> ExtraTypeInfo::Deserialize(Deserializer &deserializer)\n \tcase ExtraTypeInfoType::AGGREGATE_STATE_TYPE_INFO:\n \t\tresult = AggregateStateTypeInfo::Deserialize(deserializer);\n \t\tbreak;\n+\tcase ExtraTypeInfoType::ANY_TYPE_INFO:\n+\t\tresult = AnyTypeInfo::Deserialize(deserializer);\n+\t\tbreak;\n \tcase ExtraTypeInfoType::ARRAY_TYPE_INFO:\n \t\tresult = ArrayTypeInfo::Deserialize(deserializer);\n \t\tbreak;\n@@ -34,6 +37,9 @@ shared_ptr<ExtraTypeInfo> ExtraTypeInfo::Deserialize(Deserializer &deserializer)\n \tcase ExtraTypeInfoType::GENERIC_TYPE_INFO:\n \t\tresult = make_shared<ExtraTypeInfo>(type);\n \t\tbreak;\n+\tcase ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO:\n+\t\tresult = IntegerLiteralTypeInfo::Deserialize(deserializer);\n+\t\tbreak;\n \tcase ExtraTypeInfoType::INVALID_TYPE_INFO:\n \t\treturn nullptr;\n \tcase ExtraTypeInfoType::LIST_TYPE_INFO:\n@@ -70,6 +76,19 @@ shared_ptr<ExtraTypeInfo> AggregateStateTypeInfo::Deserialize(Deserializer &dese\n \treturn std::move(result);\n }\n \n+void AnyTypeInfo::Serialize(Serializer &serializer) const {\n+\tExtraTypeInfo::Serialize(serializer);\n+\tserializer.WriteProperty<LogicalType>(200, \"target_type\", target_type);\n+\tserializer.WritePropertyWithDefault<idx_t>(201, \"cast_score\", cast_score);\n+}\n+\n+shared_ptr<ExtraTypeInfo> AnyTypeInfo::Deserialize(Deserializer &deserializer) {\n+\tauto result = duckdb::shared_ptr<AnyTypeInfo>(new AnyTypeInfo());\n+\tdeserializer.ReadProperty<LogicalType>(200, \"target_type\", result->target_type);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(201, \"cast_score\", result->cast_score);\n+\treturn std::move(result);\n+}\n+\n void ArrayTypeInfo::Serialize(Serializer &serializer) const {\n \tExtraTypeInfo::Serialize(serializer);\n \tserializer.WriteProperty<LogicalType>(200, \"child_type\", child_type);\n@@ -96,6 +115,17 @@ shared_ptr<ExtraTypeInfo> DecimalTypeInfo::Deserialize(Deserializer &deserialize\n \treturn std::move(result);\n }\n \n+void IntegerLiteralTypeInfo::Serialize(Serializer &serializer) const {\n+\tExtraTypeInfo::Serialize(serializer);\n+\tserializer.WriteProperty<Value>(200, \"constant_value\", constant_value);\n+}\n+\n+shared_ptr<ExtraTypeInfo> IntegerLiteralTypeInfo::Deserialize(Deserializer &deserializer) {\n+\tauto result = duckdb::shared_ptr<IntegerLiteralTypeInfo>(new IntegerLiteralTypeInfo());\n+\tdeserializer.ReadProperty<Value>(200, \"constant_value\", result->constant_value);\n+\treturn std::move(result);\n+}\n+\n void ListTypeInfo::Serialize(Serializer &serializer) const {\n \tExtraTypeInfo::Serialize(serializer);\n \tserializer.WriteProperty<LogicalType>(200, \"child_type\", child_type);\n",
  "test_patch": "diff --git a/test/sql/aggregate/aggregates/test_quantile_disc_list.test b/test/sql/aggregate/aggregates/test_quantile_disc_list.test\nindex 00794395a4dc..06bb6fd1a1e4 100644\n--- a/test/sql/aggregate/aggregates/test_quantile_disc_list.test\n+++ b/test/sql/aggregate/aggregates/test_quantile_disc_list.test\n@@ -160,6 +160,10 @@ FROM VALUES (0), (1), (2), (10) AS tab(col);\n ----\n [0, 1, 1, 1, 1, 1, 2, 2, 10, 10, 10]\n \n+query I\n+SELECT quantile_disc(42::UTINYINT, 0.5);\n+----\n+42\n \n # Invalid use\n statement error\ndiff --git a/test/sql/binder/integer_literal_binding.test b/test/sql/binder/integer_literal_binding.test\nnew file mode 100644\nindex 000000000000..1302519bcc01\n--- /dev/null\n+++ b/test/sql/binder/integer_literal_binding.test\n@@ -0,0 +1,44 @@\n+# name: test/sql/binder/integer_literal_binding.test\n+# description: Test integer literal binding\n+# group: [binder]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# integer literal binding for arithmetic\n+foreach type UTINYINT USMALLINT UINTEGER UBIGINT TINYINT SMALLINT INTEGER BIGINT\n+\n+query I\n+SELECT typeof(100::${type} + 1) == '${type}';\n+----\n+true\n+\n+\n+query I\n+SELECT typeof(100 + 1::${type}) == '${type}';\n+----\n+true\n+\n+endloop\n+\n+# integer literals out of range for type\n+query I\n+SELECT typeof(1::TINYINT + 100);\n+----\n+TINYINT\n+\n+query I\n+SELECT typeof(1::TINYINT + 10000);\n+----\n+INTEGER\n+\n+# integer literals with decimals\n+query I\n+SELECT typeof(1.05 + 1)\n+----\n+DECIMAL(13,2)\n+\n+query I\n+SELECT typeof(1 + 1);\n+----\n+INTEGER\ndiff --git a/test/sql/binder/string_literal_binding.test b/test/sql/binder/string_literal_binding.test\nindex 71fc22143eb2..26e576e5b51c 100644\n--- a/test/sql/binder/string_literal_binding.test\n+++ b/test/sql/binder/string_literal_binding.test\n@@ -2,6 +2,9 @@\n # description: Test string literal binding\n # group: [binder]\n \n+statement ok\n+PRAGMA enable_verification\n+\n # string literals bind differently from strings\n # they can be auto-cast to everything\n # this is an integer comparison\ndiff --git a/test/sql/collate/test_icu_collate.test b/test/sql/collate/test_icu_collate.test\nindex 2c18478ca985..b9a254f57cb2 100644\n--- a/test/sql/collate/test_icu_collate.test\n+++ b/test/sql/collate/test_icu_collate.test\n@@ -4,6 +4,9 @@\n \n require icu\n \n+statement ok\n+PRAGMA enable_verification\n+\n statement ok\n CREATE TABLE strings(s VARCHAR);\n \n@@ -84,7 +87,6 @@ SELECT icu_sort_key('goose', 'DUCK_DUCK_ENUM');\n ----\n Invalid Input Error\n \n-\n # issue duckdb/duckdb#9692\n query I\n select chr(2*16*256+1*256+2*16+11) collate da  =chr(12*16+5) collate da;\ndiff --git a/test/sql/function/list/aggregates/approx_count_distinct.test b/test/sql/function/list/aggregates/approx_count_distinct.test\nindex 7076ecc89f15..d1258b0c7556 100644\n--- a/test/sql/function/list/aggregates/approx_count_distinct.test\n+++ b/test/sql/function/list/aggregates/approx_count_distinct.test\n@@ -16,7 +16,7 @@ select list_approx_count_distinct([10]), list_approx_count_distinct(['hello']) f\n query II\n select list_approx_count_distinct(l), list_approx_count_distinct(['hello']) from list_ints;\n ----\n-100\t1\n+98\t1\n \n query I\n select list_approx_count_distinct([]) from list_ints;\n@@ -29,7 +29,7 @@ INSERT INTO list_ints VALUES ([]), (NULL), ([NULL]);\n query I\n select list_approx_count_distinct(l) from list_ints;\n ----\n-100\n+98\n 0\n NULL\n 0\n@@ -80,7 +80,7 @@ INSERT INTO list_ints_2 SELECT LIST(a), LIST(mod(a, 10)) FROM range(2000) tbl(a)\n query III\n SELECT list_count(a), list_approx_count_distinct(a), list_approx_count_distinct(b) from list_ints_2\n ----\n-2000\t1951\t10\n+2000\t1991\t10\n \n statement ok\n DELETE FROM list_ints_2\n@@ -94,5 +94,5 @@ INSERT INTO list_ints_2 SELECT LIST(a), NULL FROM range(2000) tbl(a, b) WHERE a\n query I\n SELECT list_approx_count_distinct(a) from list_ints_2;\n ----\n-989\n-1006\n+993\n+986\ndiff --git a/test/sql/function/list/list_distinct.test b/test/sql/function/list/list_distinct.test\nindex b8060d0f6d40..3ab483962288 100644\n--- a/test/sql/function/list/list_distinct.test\n+++ b/test/sql/function/list/list_distinct.test\n@@ -7,7 +7,6 @@\n # different on Windows and other systems\n \n # test null or empty\n-\n query I\n SELECT list_distinct(NULL)\n ----\ndiff --git a/test/sql/function/numeric/test_round_even.test b/test/sql/function/numeric/test_round_even.test\nindex 93ec299c04d3..4ad9ea8ff0fa 100644\n--- a/test/sql/function/numeric/test_round_even.test\n+++ b/test/sql/function/numeric/test_round_even.test\n@@ -5,9 +5,6 @@\n statement ok\n PRAGMA enable_verification\n \n-statement ok\n-PRAGMA disable_optimizer\n-\n query I\n SELECT roundBankers(45, -1)\n ----\ndiff --git a/test/sql/storage/test_large_parquet_storage.test_slow b/test/sql/storage/test_large_parquet_storage.test_slow\nindex 92864b2857cf..50990eed771f 100644\n--- a/test/sql/storage/test_large_parquet_storage.test_slow\n+++ b/test/sql/storage/test_large_parquet_storage.test_slow\n@@ -7,7 +7,7 @@ require parquet\n require 64bit\n \n statement ok\n-COPY (SELECT ((i::UBIGINT*129371982737)%2478526729)::BIGINT a,  ((i::UBIGINT*12937198273679)%2478527)::BIGINT::VARCHAR b FROM range(150000000) t(i)) TO '__TEST_DIR__/big.parquet' (FORMAT PARQUET, COMPRESSION UNCOMPRESSED);\n+COPY (SELECT ((i::DOUBLE*129371982737)%2478526729)::BIGINT a,  ((i::DOUBLE*12937198273679)%2478527)::BIGINT::VARCHAR b FROM range(150000000) t(i)) TO '__TEST_DIR__/big.parquet' (FORMAT PARQUET, COMPRESSION UNCOMPRESSED);\n \n query I\n SELECT COUNT(*) FROM '__TEST_DIR__/big.parquet'\ndiff --git a/test/sql/storage/vacuum/vacuum_partial_deletes_mixed.test_slow b/test/sql/storage/vacuum/vacuum_partial_deletes_mixed.test_slow\nindex 6437544a77e1..bdf03541501e 100644\n--- a/test/sql/storage/vacuum/vacuum_partial_deletes_mixed.test_slow\n+++ b/test/sql/storage/vacuum/vacuum_partial_deletes_mixed.test_slow\n@@ -64,7 +64,7 @@ SELECT COUNT(*), SUM(i), MIN(i), MAX(i) FROM integers\n \n # 732K..910K - delete every 3 entries but based on the hash to make it more random\n query I\n-DELETE FROM integers WHERE hash(i)%3=0 AND i>=721377 AND i<909999\n+DELETE FROM integers WHERE hash(i)::DOUBLE%3=0 AND i>=721377 AND i<909999\n ----\n 62853\n \n@@ -75,7 +75,7 @@ SELECT COUNT(*), SUM(i), MIN(i), MAX(i) FROM integers\n \n # 732K..910K - delete every 2 entries but based on the hash to make it more random\n query I\n-DELETE FROM integers WHERE hash(i)%2=0 AND i>=909999\n+DELETE FROM integers WHERE hash(i)::DOUBLE%2=0 AND i>=909999\n ----\n 89983\n \ndiff --git a/test/sql/storage_version/generate_storage_version.sql b/test/sql/storage_version/generate_storage_version.sql\nindex 174f66a11fd8..46e321448c0a 100644\n--- a/test/sql/storage_version/generate_storage_version.sql\n+++ b/test/sql/storage_version/generate_storage_version.sql\n@@ -82,7 +82,7 @@ FROM\n     integral_values;\n CREATE VIEW test3.v2 AS\n SELECT\n-    (i + 2) * 3\n+    ((i + 2) * 3)::INT\n FROM\n     integral_values;\n -- bigger tables\ndiff --git a/test/sql/storage_version/storage_version.db b/test/sql/storage_version/storage_version.db\nindex 40c75f027754..1d6077c5b886 100644\nBinary files a/test/sql/storage_version/storage_version.db and b/test/sql/storage_version/storage_version.db differ\ndiff --git a/test/sql/types/numeric/ubigint_arithmetic_casting.test b/test/sql/types/numeric/ubigint_arithmetic_casting.test\nnew file mode 100644\nindex 000000000000..4d9f761a60f4\n--- /dev/null\n+++ b/test/sql/types/numeric/ubigint_arithmetic_casting.test\n@@ -0,0 +1,22 @@\n+# name: test/sql/types/numeric/ubigint_arithmetic_casting.test\n+# description: UBIGINT arithmetic\n+# group: [numeric]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# ubigint casts\n+query I\n+SELECT typeof(1::UBIGINT + 1::TINYINT)\n+----\n+HUGEINT\n+\n+query I\n+SELECT typeof(1::UBIGINT + 1)\n+----\n+UBIGINT\n+\n+query I\n+SELECT typeof(1::UBIGINT + 10000)\n+----\n+UBIGINT\ndiff --git a/tools/pythonpkg/tests/fast/arrow/test_integration.py b/tools/pythonpkg/tests/fast/arrow/test_integration.py\nindex badff4ee899f..c7bfc6988933 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_integration.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_integration.py\n@@ -58,7 +58,7 @@ def test_unsigned_roundtrip(self, duckdb_cursor):\n \n         con = duckdb.connect()\n         con.execute(\n-            \"select NULL c_null, (c % 4 = 0)::bool c_bool, (c%128)::tinyint c_tinyint, c::smallint*1000 c_smallint, c::integer*100000 c_integer, c::bigint*1000000000000 c_bigint, c::float c_float, c::double c_double, 'c_' || c::string c_string from (select case when range % 2 == 0 then range else null end as c from range(-10000, 10000)) sq\"\n+            \"select NULL c_null, (c % 4 = 0)::bool c_bool, (c%128)::tinyint c_tinyint, c::smallint*1000::INT c_smallint, c::integer*100000 c_integer, c::bigint*1000000000000 c_bigint, c::float c_float, c::double c_double, 'c_' || c::string c_string from (select case when range % 2 == 0 then range else null end as c from range(-10000, 10000)) sq\"\n         )\n         arrow_result = con.fetch_arrow_table()\n         arrow_result.validate(full=True)\ndiff --git a/tools/pythonpkg/tests/fast/test_expression.py b/tools/pythonpkg/tests/fast/test_expression.py\nindex 9e0e73c2e348..7582697281ce 100644\n--- a/tools/pythonpkg/tests/fast/test_expression.py\n+++ b/tools/pythonpkg/tests/fast/test_expression.py\n@@ -565,11 +565,10 @@ def test_implicit_constant_conversion(self):\n     def test_numeric_overflow(self):\n         con = duckdb.connect()\n         rel = con.sql('select 3000::SHORT salary')\n-        # If 100 is implicitly cast to TINYINT, the execution fails in an OverflowError\n-        expr = ColumnExpression(\"salary\") * 100\n-        rel2 = rel.select(expr)\n-        res = rel2.fetchall()\n-        assert res == [(300_000,)]\n+        with pytest.raises(duckdb.OutOfRangeException, match=\"Overflow in multiplication of INT16\"):\n+            expr = ColumnExpression(\"salary\") * 100\n+            rel2 = rel.select(expr)\n+            res = rel2.fetchall()\n \n         with pytest.raises(duckdb.OutOfRangeException, match=\"Overflow in multiplication of INT16\"):\n             val = duckdb.Value(100, duckdb.typing.TINYINT)\n",
  "problem_statement": "Arithmetic expressions involving ubigint columns and integer literals are implicitly cast 'upwards' to double\n### What happens?\n\nArithmetic expressions on ubigint (== uint64) columns and integers are easily implicitly cast to double which arguably is quite unexpected because that way unsigned values larger than `2**53-1`  are approximated, which violates the expectation that results in the ubigint range (i.e. up to `2**64-1`) are represented exactly.\r\n\r\nThis arguably can be considered as a hidden foot gun (or anit-personal mine) when you are querying ubigint columns that contain large IDs or high-precision timestamps (such as nanoseconds since some epoche), because your query seems to work but a subset of rows might be silently dropped (when such expressions are used in the where or join clause) or some rows might contain approximated and thus erroneous values. \r\n\r\nNB: A similar issue was discussed in https://github.com/duckdb/duckdb/issues/3931#issuecomment-1162317715:\r\n\r\n> In principle this makes sense to me, but perhaps it would make sense to turn constants into the smallest type that can represent them, so the constant 2 should instead be a UTINYINT.\r\n\r\nFWIW, this idea would solve this issue - alternatively, warning about implicit double casting in such expressions or even throwing an error would be a very useful improvement, already, in my opinion.\n\n### To Reproduce\n\nTo reproduce enter a DuckDB shell and enter the following query:\r\n\r\n```\r\nselect x + 1 from (select 9007199254740992::ubigint as x);\r\n```\r\n\r\nActual result:\r\n\r\n```\r\nD select x + 1 from (select 9007199254740992::ubigint as x);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502      (x + 1)       \u2502\r\n\u2502       double       \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 9007199254740992.0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nExpected result:\r\n\r\n```\r\nD select x + 1 from (select 23::ubigint as x);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 (x + CAST(1 AS UTINYINT))\u2502\r\n\u2502          uint64          \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         9007199254740993 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nNB: Of course, if you are very familiar with the current duckdb casting mechanics you can directly work around this by always casting all the integer literals in all you expressions, e.g. like this:\r\n\r\n```\r\nD select x + 1::ubigint from (select 9007199254740992::ubigint as x);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 (x + CAST(1 AS UBIGINT)) \u2502\r\n\u2502          uint64          \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         9007199254740993 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nNB: I also tested it with the latest stable release, i.e. version 0.9.2, same results.\n\n### OS:\n\nFedora 39 x86_64\n\n### DuckDB Version:\n\nv0.9.3-dev1996 dae3b286b0\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nGeorg Sauthoff\n\n### Affiliation:\n\nhttps://gms.tf\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\nArithmetic expressions involving ubigint columns and integer literals are implicitly cast 'upwards' to double\n### What happens?\n\nArithmetic expressions on ubigint (== uint64) columns and integers are easily implicitly cast to double which arguably is quite unexpected because that way unsigned values larger than `2**53-1`  are approximated, which violates the expectation that results in the ubigint range (i.e. up to `2**64-1`) are represented exactly.\r\n\r\nThis arguably can be considered as a hidden foot gun (or anit-personal mine) when you are querying ubigint columns that contain large IDs or high-precision timestamps (such as nanoseconds since some epoche), because your query seems to work but a subset of rows might be silently dropped (when such expressions are used in the where or join clause) or some rows might contain approximated and thus erroneous values. \r\n\r\nNB: A similar issue was discussed in https://github.com/duckdb/duckdb/issues/3931#issuecomment-1162317715:\r\n\r\n> In principle this makes sense to me, but perhaps it would make sense to turn constants into the smallest type that can represent them, so the constant 2 should instead be a UTINYINT.\r\n\r\nFWIW, this idea would solve this issue - alternatively, warning about implicit double casting in such expressions or even throwing an error would be a very useful improvement, already, in my opinion.\n\n### To Reproduce\n\nTo reproduce enter a DuckDB shell and enter the following query:\r\n\r\n```\r\nselect x + 1 from (select 9007199254740992::ubigint as x);\r\n```\r\n\r\nActual result:\r\n\r\n```\r\nD select x + 1 from (select 9007199254740992::ubigint as x);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502      (x + 1)       \u2502\r\n\u2502       double       \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 9007199254740992.0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nExpected result:\r\n\r\n```\r\nD select x + 1 from (select 23::ubigint as x);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 (x + CAST(1 AS UTINYINT))\u2502\r\n\u2502          uint64          \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         9007199254740993 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nNB: Of course, if you are very familiar with the current duckdb casting mechanics you can directly work around this by always casting all the integer literals in all you expressions, e.g. like this:\r\n\r\n```\r\nD select x + 1::ubigint from (select 9007199254740992::ubigint as x);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 (x + CAST(1 AS UBIGINT)) \u2502\r\n\u2502          uint64          \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         9007199254740993 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nNB: I also tested it with the latest stable release, i.e. version 0.9.2, same results.\n\n### OS:\n\nFedora 39 x86_64\n\n### DuckDB Version:\n\nv0.9.3-dev1996 dae3b286b0\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nGeorg Sauthoff\n\n### Affiliation:\n\nhttps://gms.tf\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "FWIW, for comparison, similar expressions in mariadb 10.5.23 aren't implicitly cast to double:\r\n\r\n```\r\ncreate temporary table foo select x + 1 from (select cast(9007199254740992 as unsigned) as x) t;\r\ndesc foo;\r\n+-------+---------------------+------+-----+---------+-------+\r\n| Field | Type                | Null | Key | Default | Extra |\r\n+-------+---------------------+------+-----+---------+-------+\r\n| x + 1 | bigint(21) unsigned | NO   |     | NULL    |       |\r\n+-------+---------------------+------+-----+---------+-------+\r\nselect x + 1 from (select cast(9007199254740992 as unsigned) as x) t;\r\n+------------------+\r\n| x + 1            |\r\n+------------------+\r\n| 9007199254740993 |\r\n+------------------+\r\n```\r\n\nFWIW, for comparison, similar expressions in mariadb 10.5.23 aren't implicitly cast to double:\r\n\r\n```\r\ncreate temporary table foo select x + 1 from (select cast(9007199254740992 as unsigned) as x) t;\r\ndesc foo;\r\n+-------+---------------------+------+-----+---------+-------+\r\n| Field | Type                | Null | Key | Default | Extra |\r\n+-------+---------------------+------+-----+---------+-------+\r\n| x + 1 | bigint(21) unsigned | NO   |     | NULL    |       |\r\n+-------+---------------------+------+-----+---------+-------+\r\nselect x + 1 from (select cast(9007199254740992 as unsigned) as x) t;\r\n+------------------+\r\n| x + 1            |\r\n+------------------+\r\n| 9007199254740993 |\r\n+------------------+\r\n```\r\n",
  "created_at": "2024-01-10T11:41:55Z"
}