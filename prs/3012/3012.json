{
  "repo": "duckdb/duckdb",
  "pull_number": 3012,
  "instance_id": "duckdb__duckdb-3012",
  "issue_numbers": [
    "2999",
    "2999"
  ],
  "base_commit": "506b05a102a566d8e4a2d2376fbffdf90c5fd711",
  "patch": "diff --git a/src/optimizer/statistics/operator/propagate_filter.cpp b/src/optimizer/statistics/operator/propagate_filter.cpp\nindex 3d0196679b6e..fb2de0537395 100644\n--- a/src/optimizer/statistics/operator/propagate_filter.cpp\n+++ b/src/optimizer/statistics/operator/propagate_filter.cpp\n@@ -9,6 +9,10 @@\n \n namespace duckdb {\n \n+static bool IsCompareDistinct(ExpressionType type) {\n+\treturn type == ExpressionType::COMPARE_DISTINCT_FROM || type == ExpressionType::COMPARE_NOT_DISTINCT_FROM;\n+}\n+\n bool StatisticsPropagator::ExpressionIsConstant(Expression &expr, const Value &val) {\n \tif (expr.GetExpressionClass() != ExpressionClass::BOUND_CONSTANT) {\n \t\treturn false;\n@@ -36,8 +40,10 @@ void StatisticsPropagator::SetStatisticsNotNull(ColumnBinding binding) {\n \n void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &stats, ExpressionType comparison_type,\n                                                   const Value &constant) {\n-\t// any comparison filter removes all null values\n-\tstats.validity_stats = make_unique<ValidityStatistics>(false);\n+\t// regular comparisons removes all null values\n+\tif (!IsCompareDistinct(comparison_type)) {\n+\t\tstats.validity_stats = make_unique<ValidityStatistics>(false);\n+\t}\n \tif (!stats.type.IsNumeric()) {\n \t\t// don't handle non-numeric columns here (yet)\n \t\treturn;\n@@ -73,9 +79,11 @@ void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &stats, Express\n \n void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &lstats, BaseStatistics &rstats,\n                                                   ExpressionType comparison_type) {\n-\t// any comparison filter removes all null values\n-\tlstats.validity_stats = make_unique<ValidityStatistics>(false);\n-\trstats.validity_stats = make_unique<ValidityStatistics>(false);\n+\t// regular comparisons removes all null values\n+\tif (!IsCompareDistinct(comparison_type)) {\n+\t\tlstats.validity_stats = make_unique<ValidityStatistics>(false);\n+\t\trstats.validity_stats = make_unique<ValidityStatistics>(false);\n+\t}\n \tD_ASSERT(lstats.type == rstats.type);\n \tif (!lstats.type.IsNumeric()) {\n \t\t// don't handle non-numeric columns here (yet)\n@@ -121,6 +129,7 @@ void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &lstats, BaseSt\n \t\t}\n \t\tbreak;\n \tcase ExpressionType::COMPARE_EQUAL:\n+\tcase ExpressionType::COMPARE_NOT_DISTINCT_FROM:\n \t\t// LEFT = RIGHT\n \t\t// only the tightest bounds pass\n \t\t// so if we have e.g. left = [-50, 250] and right = [-100, 100]\n@@ -146,10 +155,11 @@ void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &lstats, BaseSt\n void StatisticsPropagator::UpdateFilterStatistics(Expression &left, Expression &right, ExpressionType comparison_type) {\n \t// first check if either side is a bound column ref\n \t// any column ref involved in a comparison will not be null after the comparison\n-\tif (left.type == ExpressionType::BOUND_COLUMN_REF) {\n+\tbool compare_distinct = IsCompareDistinct(comparison_type);\n+\tif (!compare_distinct && left.type == ExpressionType::BOUND_COLUMN_REF) {\n \t\tSetStatisticsNotNull(((BoundColumnRefExpression &)left).binding);\n \t}\n-\tif (right.type == ExpressionType::BOUND_COLUMN_REF) {\n+\tif (!compare_distinct && right.type == ExpressionType::BOUND_COLUMN_REF) {\n \t\tSetStatisticsNotNull(((BoundColumnRefExpression &)right).binding);\n \t}\n \t// check if this is a comparison between a constant and a column ref\ndiff --git a/src/planner/subquery/flatten_dependent_join.cpp b/src/planner/subquery/flatten_dependent_join.cpp\nindex eb33bd0995a4..6b3ca1b20a3e 100644\n--- a/src/planner/subquery/flatten_dependent_join.cpp\n+++ b/src/planner/subquery/flatten_dependent_join.cpp\n@@ -197,8 +197,9 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t\tjoin->children.push_back(move(plan->children[1]));\n \t\treturn move(join);\n \t}\n+\tcase LogicalOperatorType::LOGICAL_ANY_JOIN:\n \tcase LogicalOperatorType::LOGICAL_COMPARISON_JOIN: {\n-\t\tauto &join = (LogicalComparisonJoin &)*plan;\n+\t\tauto &join = (LogicalJoin &)*plan;\n \t\tD_ASSERT(plan->children.size() == 2);\n \t\t// check the correlated expressions in the children of the join\n \t\tbool left_has_correlation = has_correlated_expressions.find(plan->children[0].get())->second;\n@@ -223,6 +224,13 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t\t\t\tplan->children[0] = PushDownDependentJoinInternal(move(plan->children[0]));\n \t\t\t\treturn plan;\n \t\t\t}\n+\t\t} else if (join.join_type == JoinType::RIGHT) {\n+\t\t\t// left outer join\n+\t\t\tif (!left_has_correlation) {\n+\t\t\t\t// only right has correlation: push into right\n+\t\t\t\tplan->children[1] = PushDownDependentJoinInternal(move(plan->children[1]));\n+\t\t\t\treturn plan;\n+\t\t\t}\n \t\t} else if (join.join_type == JoinType::MARK) {\n \t\t\tif (right_has_correlation) {\n \t\t\t\tthrow Exception(\"MARK join with correlation in RHS not supported\");\n@@ -238,27 +246,42 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t\t}\n \t\t// both sides have correlation\n \t\t// push into both sides\n-\t\t// NOTE: for OUTER JOINS it matters what the BASE BINDING is after the join\n-\t\t// for the LEFT OUTER JOIN, we want the LEFT side to be the base binding after we push\n-\t\t// because the RIGHT binding might contain NULL values\n \t\tplan->children[0] = PushDownDependentJoinInternal(move(plan->children[0]));\n \t\tauto left_binding = this->base_binding;\n \t\tplan->children[1] = PushDownDependentJoinInternal(move(plan->children[1]));\n \t\tauto right_binding = this->base_binding;\n+\t\t// NOTE: for OUTER JOINS it matters what the BASE BINDING is after the join\n+\t\t// for the LEFT OUTER JOIN, we want the LEFT side to be the base binding after we push\n+\t\t// because the RIGHT binding might contain NULL values\n \t\tif (join.join_type == JoinType::LEFT) {\n \t\t\tthis->base_binding = left_binding;\n+\t\t} else if (join.join_type == JoinType::RIGHT) {\n+\t\t\tthis->base_binding = right_binding;\n \t\t}\n \t\t// add the correlated columns to the join conditions\n \t\tfor (idx_t i = 0; i < correlated_columns.size(); i++) {\n-\t\t\tJoinCondition cond;\n-\n-\t\t\tcond.left = make_unique<BoundColumnRefExpression>(\n+\t\t\tauto left = make_unique<BoundColumnRefExpression>(\n \t\t\t    correlated_columns[i].type, ColumnBinding(left_binding.table_index, left_binding.column_index + i));\n-\t\t\tcond.right = make_unique<BoundColumnRefExpression>(\n+\t\t\tauto right = make_unique<BoundColumnRefExpression>(\n \t\t\t    correlated_columns[i].type, ColumnBinding(right_binding.table_index, right_binding.column_index + i));\n-\t\t\tcond.comparison = ExpressionType::COMPARE_EQUAL;\n-\t\t\tcond.null_values_are_equal = true;\n-\t\t\tjoin.conditions.push_back(move(cond));\n+\n+\t\t\tif (join.type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN) {\n+\t\t\t\tJoinCondition cond;\n+\t\t\t\tcond.left = move(left);\n+\t\t\t\tcond.right = move(right);\n+\t\t\t\tcond.comparison = ExpressionType::COMPARE_EQUAL;\n+\t\t\t\tcond.null_values_are_equal = true;\n+\n+\t\t\t\tauto &comparison_join = (LogicalComparisonJoin &)join;\n+\t\t\t\tcomparison_join.conditions.push_back(move(cond));\n+\t\t\t} else {\n+\t\t\t\tauto &any_join = (LogicalAnyJoin &)join;\n+\t\t\t\tauto comparison = make_unique<BoundComparisonExpression>(ExpressionType::COMPARE_NOT_DISTINCT_FROM,\n+\t\t\t\t                                                         move(left), move(right));\n+\t\t\t\tauto conjunction = make_unique<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND,\n+\t\t\t\t                                                           move(comparison), move(any_join.condition));\n+\t\t\t\tany_join.condition = move(conjunction);\n+\t\t\t}\n \t\t}\n \t\t// then we replace any correlated expressions with the corresponding entry in the correlated_map\n \t\tRewriteCorrelatedExpressions rewriter(right_binding, correlated_map);\n",
  "test_patch": "diff --git a/test/sql/subquery/any_all/issue_2999.test b/test/sql/subquery/any_all/issue_2999.test\nnew file mode 100644\nindex 000000000000..6964febc5349\n--- /dev/null\n+++ b/test/sql/subquery/any_all/issue_2999.test\n@@ -0,0 +1,23 @@\n+# name: test/sql/subquery/any_all/issue_2999.test\n+# description: Issue #2999: Correlated group on ANY subquery\n+# group: [any_all]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t0 (c0 INT);\n+\n+statement ok\n+CREATE TABLE t1 (c0 INT);\n+\n+statement ok\n+INSERT INTO t0 VALUES (1);\n+\n+statement ok\n+INSERT INTO t1 VALUES (1);\n+\n+query I\n+SELECT 1 = ANY(SELECT 1 FROM t1 JOIN (SELECT count(*) GROUP BY t0.c0) AS x(x) ON TRUE) FROM t0;\n+----\n+true\ndiff --git a/test/sql/subquery/scalar/test_subquery_any_join.test b/test/sql/subquery/scalar/test_subquery_any_join.test\nnew file mode 100644\nindex 000000000000..1a80c5f45466\n--- /dev/null\n+++ b/test/sql/subquery/scalar/test_subquery_any_join.test\n@@ -0,0 +1,79 @@\n+# name: test/sql/subquery/scalar/test_subquery_any_join.test\n+# description: Test subqueries on ANY join\n+# group: [scalar]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE integers(i INTEGER);\n+\n+statement ok\n+INSERT INTO integers VALUES (1), (2), (3), (NULL);\n+\n+# correlated expressions in inner/left/right joins\n+query I\n+SELECT i IN (SELECT i1.i FROM (SELECT * FROM integers i1 WHERE i1.i=integers.i) i1 JOIN generate_series(1, 2, 1) tbl(i) ON i1.i=tbl.i) FROM integers ORDER BY i NULLS LAST;\n+----\n+true\n+true\n+false\n+false\n+\n+query I\n+SELECT i IN (SELECT i1.i FROM (SELECT * FROM integers i1 WHERE i1.i=integers.i) i1 LEFT JOIN generate_series(1, 2, 1) tbl(i) ON i1.i=tbl.i) FROM integers ORDER BY i NULLS LAST;\n+----\n+true\n+true\n+true\n+false\n+\n+query I\n+SELECT i IN (SELECT i1.i FROM (SELECT * FROM integers i1 WHERE i1.i=integers.i) i1 RIGHT JOIN generate_series(1, 2, 1) tbl(i) ON i1.i=tbl.i) FROM integers ORDER BY i NULLS LAST;\n+----\n+true\n+true\n+NULL\n+NULL\n+\n+# other way around\n+query I\n+SELECT i IN (SELECT i1.i FROM generate_series(1, 2, 1) tbl(i) LEFT JOIN (SELECT * FROM integers i1 WHERE i1.i=integers.i) i1 ON i1.i=tbl.i) FROM integers ORDER BY i NULLS LAST;\n+----\n+true\n+true\n+NULL\n+NULL\n+\n+query I\n+SELECT i IN (SELECT i1.i FROM generate_series(1, 2, 1) tbl(i) RIGHT JOIN (SELECT * FROM integers i1 WHERE i1.i=integers.i) i1 ON i1.i=tbl.i) FROM integers ORDER BY i NULLS LAST;\n+----\n+true\n+true\n+true\n+false\n+\n+# complex join condition\n+query I\n+SELECT i IN (SELECT i1.i FROM (SELECT * FROM integers i1 WHERE i1.i IS NOT DISTINCT FROM integers.i) i1 JOIN generate_series(1, 2, 1) tbl(i) ON i1.i=tbl.i OR (i1.i IS NULL AND tbl.i IS NULL)) FROM integers ORDER BY i NULLS LAST;\n+----\n+true\n+true\n+false\n+false\n+\n+query I\n+SELECT i IN (SELECT i1.i FROM (SELECT * FROM integers i1 WHERE i1.i IS NOT DISTINCT FROM integers.i) i1 LEFT JOIN generate_series(1, 2, 1) tbl(i) ON i1.i=tbl.i OR (i1.i IS NULL AND tbl.i IS NULL)) FROM integers ORDER BY i NULLS LAST;\n+----\n+true\n+true\n+true\n+NULL\n+\n+query I\n+SELECT i IN (SELECT i1.i FROM (SELECT * FROM integers i1 WHERE i1.i IS NOT DISTINCT FROM integers.i) i1 RIGHT JOIN generate_series(1, 2, 1) tbl(i) ON i1.i=tbl.i OR (i1.i IS NULL AND tbl.i IS NULL)) FROM integers ORDER BY i NULLS LAST;\n+----\n+true\n+true\n+NULL\n+NULL\n",
  "problem_statement": "Correlated group on ANY subquery\n#### What happens?\r\nWhile this subquery crashes on MonetDB, it gives error on DuckDB :) The dependent join unnesting is not available for the ANY operator. If you consider this as a feature, please close the issue.\r\n\r\n#### To Reproduce\r\nCREATE TABLE t0 (c0 INT);\r\nCREATE TABLE t1 (c0 INT);\r\nINSERT INTO t0 VALUES (1);\r\nINSERT INTO t1 VALUES (1);\r\n\r\nSELECT 1 = ANY(SELECT 1 FROM t1 JOIN (SELECT count(*) GROUP BY t0.c0) AS x(x) ON TRUE) FROM t0;\r\nError: INTERNAL Error: Logical operator type \"ANY_JOIN\" for dependent join\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: downloaded and compiled from the tip of master branch\r\n - DuckDB Client: Shell\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nCorrelated group on ANY subquery\n#### What happens?\r\nWhile this subquery crashes on MonetDB, it gives error on DuckDB :) The dependent join unnesting is not available for the ANY operator. If you consider this as a feature, please close the issue.\r\n\r\n#### To Reproduce\r\nCREATE TABLE t0 (c0 INT);\r\nCREATE TABLE t1 (c0 INT);\r\nINSERT INTO t0 VALUES (1);\r\nINSERT INTO t1 VALUES (1);\r\n\r\nSELECT 1 = ANY(SELECT 1 FROM t1 JOIN (SELECT count(*) GROUP BY t0.c0) AS x(x) ON TRUE) FROM t0;\r\nError: INTERNAL Error: Logical operator type \"ANY_JOIN\" for dependent join\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: downloaded and compiled from the tip of master branch\r\n - DuckDB Client: Shell\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "I fixed the crash in MonetDB and now it runs there\ud83d\ude07\nIt should not throw an internal error, so there is probably a bug here. Thanks for reporting.\nI fixed the crash in MonetDB and now it runs there\ud83d\ude07\nIt should not throw an internal error, so there is probably a bug here. Thanks for reporting.",
  "created_at": "2022-01-31T14:26:40Z"
}