diff --git a/src/optimizer/statistics/operator/propagate_filter.cpp b/src/optimizer/statistics/operator/propagate_filter.cpp
index 3d0196679b6e..fb2de0537395 100644
--- a/src/optimizer/statistics/operator/propagate_filter.cpp
+++ b/src/optimizer/statistics/operator/propagate_filter.cpp
@@ -9,6 +9,10 @@
 
 namespace duckdb {
 
+static bool IsCompareDistinct(ExpressionType type) {
+	return type == ExpressionType::COMPARE_DISTINCT_FROM || type == ExpressionType::COMPARE_NOT_DISTINCT_FROM;
+}
+
 bool StatisticsPropagator::ExpressionIsConstant(Expression &expr, const Value &val) {
 	if (expr.GetExpressionClass() != ExpressionClass::BOUND_CONSTANT) {
 		return false;
@@ -36,8 +40,10 @@ void StatisticsPropagator::SetStatisticsNotNull(ColumnBinding binding) {
 
 void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &stats, ExpressionType comparison_type,
                                                   const Value &constant) {
-	// any comparison filter removes all null values
-	stats.validity_stats = make_unique<ValidityStatistics>(false);
+	// regular comparisons removes all null values
+	if (!IsCompareDistinct(comparison_type)) {
+		stats.validity_stats = make_unique<ValidityStatistics>(false);
+	}
 	if (!stats.type.IsNumeric()) {
 		// don't handle non-numeric columns here (yet)
 		return;
@@ -73,9 +79,11 @@ void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &stats, Express
 
 void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &lstats, BaseStatistics &rstats,
                                                   ExpressionType comparison_type) {
-	// any comparison filter removes all null values
-	lstats.validity_stats = make_unique<ValidityStatistics>(false);
-	rstats.validity_stats = make_unique<ValidityStatistics>(false);
+	// regular comparisons removes all null values
+	if (!IsCompareDistinct(comparison_type)) {
+		lstats.validity_stats = make_unique<ValidityStatistics>(false);
+		rstats.validity_stats = make_unique<ValidityStatistics>(false);
+	}
 	D_ASSERT(lstats.type == rstats.type);
 	if (!lstats.type.IsNumeric()) {
 		// don't handle non-numeric columns here (yet)
@@ -121,6 +129,7 @@ void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &lstats, BaseSt
 		}
 		break;
 	case ExpressionType::COMPARE_EQUAL:
+	case ExpressionType::COMPARE_NOT_DISTINCT_FROM:
 		// LEFT = RIGHT
 		// only the tightest bounds pass
 		// so if we have e.g. left = [-50, 250] and right = [-100, 100]
@@ -146,10 +155,11 @@ void StatisticsPropagator::UpdateFilterStatistics(BaseStatistics &lstats, BaseSt
 void StatisticsPropagator::UpdateFilterStatistics(Expression &left, Expression &right, ExpressionType comparison_type) {
 	// first check if either side is a bound column ref
 	// any column ref involved in a comparison will not be null after the comparison
-	if (left.type == ExpressionType::BOUND_COLUMN_REF) {
+	bool compare_distinct = IsCompareDistinct(comparison_type);
+	if (!compare_distinct && left.type == ExpressionType::BOUND_COLUMN_REF) {
 		SetStatisticsNotNull(((BoundColumnRefExpression &)left).binding);
 	}
-	if (right.type == ExpressionType::BOUND_COLUMN_REF) {
+	if (!compare_distinct && right.type == ExpressionType::BOUND_COLUMN_REF) {
 		SetStatisticsNotNull(((BoundColumnRefExpression &)right).binding);
 	}
 	// check if this is a comparison between a constant and a column ref
diff --git a/src/planner/subquery/flatten_dependent_join.cpp b/src/planner/subquery/flatten_dependent_join.cpp
index eb33bd0995a4..6b3ca1b20a3e 100644
--- a/src/planner/subquery/flatten_dependent_join.cpp
+++ b/src/planner/subquery/flatten_dependent_join.cpp
@@ -197,8 +197,9 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal
 		join->children.push_back(move(plan->children[1]));
 		return move(join);
 	}
+	case LogicalOperatorType::LOGICAL_ANY_JOIN:
 	case LogicalOperatorType::LOGICAL_COMPARISON_JOIN: {
-		auto &join = (LogicalComparisonJoin &)*plan;
+		auto &join = (LogicalJoin &)*plan;
 		D_ASSERT(plan->children.size() == 2);
 		// check the correlated expressions in the children of the join
 		bool left_has_correlation = has_correlated_expressions.find(plan->children[0].get())->second;
@@ -223,6 +224,13 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal
 				plan->children[0] = PushDownDependentJoinInternal(move(plan->children[0]));
 				return plan;
 			}
+		} else if (join.join_type == JoinType::RIGHT) {
+			// left outer join
+			if (!left_has_correlation) {
+				// only right has correlation: push into right
+				plan->children[1] = PushDownDependentJoinInternal(move(plan->children[1]));
+				return plan;
+			}
 		} else if (join.join_type == JoinType::MARK) {
 			if (right_has_correlation) {
 				throw Exception("MARK join with correlation in RHS not supported");
@@ -238,27 +246,42 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal
 		}
 		// both sides have correlation
 		// push into both sides
-		// NOTE: for OUTER JOINS it matters what the BASE BINDING is after the join
-		// for the LEFT OUTER JOIN, we want the LEFT side to be the base binding after we push
-		// because the RIGHT binding might contain NULL values
 		plan->children[0] = PushDownDependentJoinInternal(move(plan->children[0]));
 		auto left_binding = this->base_binding;
 		plan->children[1] = PushDownDependentJoinInternal(move(plan->children[1]));
 		auto right_binding = this->base_binding;
+		// NOTE: for OUTER JOINS it matters what the BASE BINDING is after the join
+		// for the LEFT OUTER JOIN, we want the LEFT side to be the base binding after we push
+		// because the RIGHT binding might contain NULL values
 		if (join.join_type == JoinType::LEFT) {
 			this->base_binding = left_binding;
+		} else if (join.join_type == JoinType::RIGHT) {
+			this->base_binding = right_binding;
 		}
 		// add the correlated columns to the join conditions
 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
-			JoinCondition cond;
-
-			cond.left = make_unique<BoundColumnRefExpression>(
+			auto left = make_unique<BoundColumnRefExpression>(
 			    correlated_columns[i].type, ColumnBinding(left_binding.table_index, left_binding.column_index + i));
-			cond.right = make_unique<BoundColumnRefExpression>(
+			auto right = make_unique<BoundColumnRefExpression>(
 			    correlated_columns[i].type, ColumnBinding(right_binding.table_index, right_binding.column_index + i));
-			cond.comparison = ExpressionType::COMPARE_EQUAL;
-			cond.null_values_are_equal = true;
-			join.conditions.push_back(move(cond));
+
+			if (join.type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN) {
+				JoinCondition cond;
+				cond.left = move(left);
+				cond.right = move(right);
+				cond.comparison = ExpressionType::COMPARE_EQUAL;
+				cond.null_values_are_equal = true;
+
+				auto &comparison_join = (LogicalComparisonJoin &)join;
+				comparison_join.conditions.push_back(move(cond));
+			} else {
+				auto &any_join = (LogicalAnyJoin &)join;
+				auto comparison = make_unique<BoundComparisonExpression>(ExpressionType::COMPARE_NOT_DISTINCT_FROM,
+				                                                         move(left), move(right));
+				auto conjunction = make_unique<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND,
+				                                                           move(comparison), move(any_join.condition));
+				any_join.condition = move(conjunction);
+			}
 		}
 		// then we replace any correlated expressions with the corresponding entry in the correlated_map
 		RewriteCorrelatedExpressions rewriter(right_binding, correlated_map);
