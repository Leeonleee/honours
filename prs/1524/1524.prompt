You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
make install installs third-party
Hello and thank you for this wonderful project !

When using `make install` after the build, third-party libraries are installed and this overwrites already existing libraries in the same environment (e.g.: libfmt.a). Could you please investigate on using `add_subdirectory(third_party EXCLUDE_FROM_ALL)` ?



</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of extension/parquet/column_reader.cpp]
1: #include "column_reader.hpp"
2: #include "parquet_timestamp.hpp"
3: #include "utf8proc_wrapper.hpp"
4: 
5: #include "snappy.h"
6: #include "miniz_wrapper.hpp"
7: #include "zstd.h"
8: #include <iostream>
9: 
10: #include "duckdb/common/types/chunk_collection.hpp"
11: 
12: namespace duckdb {
13: 
14: using parquet::format::CompressionCodec;
15: using parquet::format::ConvertedType;
16: using parquet::format::Encoding;
17: using parquet::format::PageType;
18: using parquet::format::Type;
19: 
20: const uint32_t RleBpDecoder::BITPACK_MASKS[] = {
21:     0,       1,       3,        7,        15,       31,        63,        127,       255,        511,       1023,
22:     2047,    4095,    8191,     16383,    32767,    65535,     131071,    262143,    524287,     1048575,   2097151,
23:     4194303, 8388607, 16777215, 33554431, 67108863, 134217727, 268435455, 536870911, 1073741823, 2147483647};
24: 
25: const uint8_t RleBpDecoder::BITPACK_DLEN = 8;
26: 
27: ColumnReader::~ColumnReader() {
28: }
29: 
30: unique_ptr<ColumnReader> ColumnReader::CreateReader(const LogicalType &type_p, const SchemaElement &schema_p,
31:                                                     idx_t file_idx_p, idx_t max_define, idx_t max_repeat) {
32: 	switch (type_p.id()) {
33: 	case LogicalTypeId::BOOLEAN:
34: 		return make_unique<BooleanColumnReader>(type_p, schema_p, file_idx_p, max_define, max_repeat);
35: 	case LogicalTypeId::UTINYINT:
36: 		return make_unique<TemplatedColumnReader<uint8_t, TemplatedParquetValueConversion<uint32_t>>>(
37: 		    type_p, schema_p, file_idx_p, max_define, max_repeat);
38: 	case LogicalTypeId::USMALLINT:
39: 		return make_unique<TemplatedColumnReader<uint16_t, TemplatedParquetValueConversion<uint32_t>>>(
40: 		    type_p, schema_p, file_idx_p, max_define, max_repeat);
41: 	case LogicalTypeId::UINTEGER:
42: 		return make_unique<TemplatedColumnReader<uint32_t, TemplatedParquetValueConversion<uint32_t>>>(
43: 		    type_p, schema_p, file_idx_p, max_define, max_repeat);
44: 	case LogicalTypeId::UBIGINT:
45: 		return make_unique<TemplatedColumnReader<uint64_t, TemplatedParquetValueConversion<uint64_t>>>(
46: 		    type_p, schema_p, file_idx_p, max_define, max_repeat);
47: 	case LogicalTypeId::INTEGER:
48: 		return make_unique<TemplatedColumnReader<int32_t, TemplatedParquetValueConversion<int32_t>>>(
49: 		    type_p, schema_p, file_idx_p, max_define, max_repeat);
50: 	case LogicalTypeId::BIGINT:
51: 		return make_unique<TemplatedColumnReader<int64_t, TemplatedParquetValueConversion<int64_t>>>(
52: 		    type_p, schema_p, file_idx_p, max_define, max_repeat);
53: 	case LogicalTypeId::FLOAT:
54: 		return make_unique<TemplatedColumnReader<float, TemplatedParquetValueConversion<float>>>(
55: 		    type_p, schema_p, file_idx_p, max_define, max_repeat);
56: 	case LogicalTypeId::DOUBLE:
57: 		return make_unique<TemplatedColumnReader<double, TemplatedParquetValueConversion<double>>>(
58: 		    type_p, schema_p, file_idx_p, max_define, max_repeat);
59: 	case LogicalTypeId::TIMESTAMP:
60: 		switch (schema_p.type) {
61: 		case Type::INT96:
62: 			return make_unique<CallbackColumnReader<Int96, timestamp_t, ImpalaTimestampToTimestamp>>(
63: 			    type_p, schema_p, file_idx_p, max_define, max_repeat);
64: 		case Type::INT64:
65: 			switch (schema_p.converted_type) {
66: 			case ConvertedType::TIMESTAMP_MICROS:
67: 				return make_unique<CallbackColumnReader<int64_t, timestamp_t, ParquetTimestampMicrosToTimestamp>>(
68: 				    type_p, schema_p, file_idx_p, max_define, max_repeat);
69: 			case ConvertedType::TIMESTAMP_MILLIS:
70: 				return make_unique<CallbackColumnReader<int64_t, timestamp_t, ParquetTimestampMsToTimestamp>>(
71: 				    type_p, schema_p, file_idx_p, max_define, max_repeat);
72: 			default:
73: 				break;
74: 			}
75: 		default:
76: 			break;
77: 		}
78: 		break;
79: 	case LogicalTypeId::DATE:
80: 		return make_unique<CallbackColumnReader<int32_t, date_t, ParquetIntToDate>>(type_p, schema_p, file_idx_p,
81: 		                                                                            max_define, max_repeat);
82: 	case LogicalTypeId::BLOB:
83: 	case LogicalTypeId::VARCHAR:
84: 		return make_unique<StringColumnReader>(type_p, schema_p, file_idx_p, max_define, max_repeat);
85: 	case LogicalTypeId::DECIMAL:
86: 		// we have to figure out what kind of int we need
87: 		switch (type_p.InternalType()) {
88: 		case PhysicalType::INT16:
89: 			return make_unique<DecimalColumnReader<int16_t>>(type_p, schema_p, file_idx_p, max_define, max_repeat);
90: 		case PhysicalType::INT32:
91: 			return make_unique<DecimalColumnReader<int32_t>>(type_p, schema_p, file_idx_p, max_define, max_repeat);
92: 		case PhysicalType::INT64:
93: 			return make_unique<DecimalColumnReader<int64_t>>(type_p, schema_p, file_idx_p, max_define, max_repeat);
94: 		case PhysicalType::INT128:
95: 			return make_unique<DecimalColumnReader<hugeint_t>>(type_p, schema_p, file_idx_p, max_define, max_repeat);
96: 
97: 		default:
98: 			break;
99: 		}
100: 		break;
101: 	default:
102: 		break;
103: 	}
104: 	throw NotImplementedException(type_p.ToString());
105: }
106: 
107: void ColumnReader::PrepareRead(parquet_filter_t &filter) {
108: 	dict_decoder.reset();
109: 	defined_decoder.reset();
110: 	block.reset();
111: 
112: 	PageHeader page_hdr;
113: 	page_hdr.read(protocol);
114: 
115: 	//	page_hdr.printTo(std::cout);
116: 	//	std::cout << '\n';
117: 
118: 	PreparePage(page_hdr.compressed_page_size, page_hdr.uncompressed_page_size);
119: 
120: 	switch (page_hdr.type) {
121: 	case PageType::DATA_PAGE_V2:
122: 	case PageType::DATA_PAGE:
123: 		PrepareDataPage(page_hdr);
124: 		break;
125: 	case PageType::DICTIONARY_PAGE:
126: 		Dictionary(move(block), page_hdr.dictionary_page_header.num_values);
127: 		break;
128: 	default:
129: 		break; // ignore INDEX page type and any other custom extensions
130: 	}
131: }
132: 
133: void ColumnReader::PreparePage(idx_t compressed_page_size, idx_t uncompressed_page_size) {
134: 	auto trans = (ThriftFileTransport *)protocol->getTransport().get();
135: 
136: 	block = make_shared<ResizeableBuffer>(compressed_page_size + 1);
137: 	trans->read((uint8_t *)block->ptr, compressed_page_size);
138: 
139: 	//			page_hdr.printTo(std::cout);
140: 	//			std::cout << '\n';
141: 
142: 	shared_ptr<ResizeableBuffer> unpacked_block;
143: 	if (chunk->meta_data.codec != CompressionCodec::UNCOMPRESSED) {
144: 		unpacked_block = make_shared<ResizeableBuffer>(uncompressed_page_size + 1);
145: 	}
146: 
147: 	switch (chunk->meta_data.codec) {
148: 	case CompressionCodec::UNCOMPRESSED:
149: 		break;
150: 	case CompressionCodec::GZIP: {
151: 		MiniZStream s;
152: 
153: 		s.Decompress((const char *)block->ptr, compressed_page_size, (char *)unpacked_block->ptr,
154: 		             uncompressed_page_size);
155: 		block = move(unpacked_block);
156: 
157: 		break;
158: 	}
159: 	case CompressionCodec::SNAPPY: {
160: 		auto res = snappy::RawUncompress((const char *)block->ptr, compressed_page_size, (char *)unpacked_block->ptr);
161: 		if (!res) {
162: 			throw std::runtime_error("Decompression failure");
163: 		}
164: 		block = move(unpacked_block);
165: 		break;
166: 	}
167: 	case CompressionCodec::ZSTD: {
168: 		auto res = duckdb_zstd::ZSTD_decompress((char *)unpacked_block->ptr, uncompressed_page_size,
169: 		                                        (const char *)block->ptr, compressed_page_size);
170: 		if (duckdb_zstd::ZSTD_isError(res) || res != (size_t)uncompressed_page_size) {
171: 			throw std::runtime_error("ZSTD Decompression failure");
172: 		}
173: 		block = move(unpacked_block);
174: 		break;
175: 	}
176: 
177: 	default: {
178: 		std::stringstream codec_name;
179: 		codec_name << chunk->meta_data.codec;
180: 		throw std::runtime_error("Unsupported compression codec \"" + codec_name.str() +
181: 		                         "\". Supported options are uncompressed, gzip or snappy");
182: 		break;
183: 	}
184: 	}
185: }
186: 
187: static uint8_t ComputeBitWidth(idx_t val) {
188: 	if (val == 0) {
189: 		return 0;
190: 	}
191: 	uint8_t ret = 1;
192: 	while (((idx_t)(1 << ret) - 1) < val) {
193: 		ret++;
194: 	}
195: 	return ret;
196: }
197: 
198: void ColumnReader::PrepareDataPage(PageHeader &page_hdr) {
199: 	if (page_hdr.type == PageType::DATA_PAGE && !page_hdr.__isset.data_page_header) {
200: 		throw std::runtime_error("Missing data page header from data page");
201: 	}
202: 	if (page_hdr.type == PageType::DATA_PAGE_V2 && !page_hdr.__isset.data_page_header_v2) {
203: 		throw std::runtime_error("Missing data page header from data page v2");
204: 	}
205: 
206: 	page_rows_available = page_hdr.type == PageType::DATA_PAGE ? page_hdr.data_page_header.num_values
207: 	                                                           : page_hdr.data_page_header_v2.num_values;
208: 	auto page_encoding = page_hdr.type == PageType::DATA_PAGE ? page_hdr.data_page_header.encoding
209: 	                                                          : page_hdr.data_page_header_v2.encoding;
210: 
211: 	if (HasRepeats()) {
212: 		// TODO there seems to be some confusion whether this is in the bytes for v2
213: 		uint32_t rep_length = block->read<uint32_t>();
214: 		block->available(rep_length);
215: 		repeated_decoder =
216: 		    make_unique<RleBpDecoder>((const uint8_t *)block->ptr, rep_length, ComputeBitWidth(max_repeat));
217: 		block->inc(rep_length);
218: 	}
219: 
220: 	if (HasDefines()) {
221: 		// TODO there seems to be some confusion whether this is in the bytes for v2
222: 		uint32_t def_length = block->read<uint32_t>();
223: 		block->available(def_length);
224: 		defined_decoder =
225: 		    make_unique<RleBpDecoder>((const uint8_t *)block->ptr, def_length, ComputeBitWidth(max_define));
226: 		block->inc(def_length);
227: 	}
228: 
229: 	switch (page_encoding) {
230: 	case Encoding::RLE_DICTIONARY:
231: 	case Encoding::PLAIN_DICTIONARY: {
232: 		// TODO there seems to be some confusion whether this is in the bytes for v2
233: 		// where is it otherwise??
234: 		auto dict_width = block->read<uint8_t>();
235: 		// TODO somehow dict_width can be 0 ?
236: 		dict_decoder = make_unique<RleBpDecoder>((const uint8_t *)block->ptr, block->len, dict_width);
237: 		block->inc(block->len);
238: 		break;
239: 	}
240: 	case Encoding::PLAIN:
241: 		// nothing to do here, will be read directly below
242: 		break;
243: 
244: 	default:
245: 		throw std::runtime_error("Unsupported page encoding");
246: 	}
247: }
248: 
249: idx_t ColumnReader::Read(uint64_t num_values, parquet_filter_t &filter, uint8_t *define_out, uint8_t *repeat_out,
250:                          Vector &result) {
251: 	// we need to reset the location because multiple column readers share the same protocol
252: 	auto trans = (ThriftFileTransport *)protocol->getTransport().get();
253: 	trans->SetLocation(chunk_read_offset);
254: 
255: 	idx_t result_offset = 0;
256: 	auto to_read = num_values;
257: 
258: 	while (to_read > 0) {
259: 		while (page_rows_available == 0) {
260: 			PrepareRead(filter);
261: 		}
262: 
263: 		D_ASSERT(block);
264: 		auto read_now = MinValue<idx_t>(to_read, page_rows_available);
265: 
266: 		D_ASSERT(read_now <= STANDARD_VECTOR_SIZE);
267: 
268: 		if (HasRepeats()) {
269: 			D_ASSERT(repeated_decoder);
270: 			repeated_decoder->GetBatch<uint8_t>((char *)repeat_out + result_offset, read_now);
271: 		}
272: 
273: 		if (HasDefines()) {
274: 			D_ASSERT(defined_decoder);
275: 			defined_decoder->GetBatch<uint8_t>((char *)define_out + result_offset, read_now);
276: 		}
277: 
278: 		if (dict_decoder) {
279: 			// we need the null count because the offsets and plain values have no entries for nulls
280: 			idx_t null_count = 0;
281: 			if (HasDefines()) {
282: 				for (idx_t i = 0; i < read_now; i++) {
283: 					if (define_out[i + result_offset] != max_define) {
284: 						null_count++;
285: 					}
286: 				}
287: 			}
288: 
289: 			offset_buffer.resize(sizeof(uint32_t) * (read_now - null_count));
290: 			dict_decoder->GetBatch<uint32_t>(offset_buffer.ptr, read_now - null_count);
291: 			DictReference(result);
292: 			Offsets((uint32_t *)offset_buffer.ptr, define_out, read_now, filter, result_offset, result);
293: 		} else {
294: 			PlainReference(block, result);
295: 			Plain(block, define_out, read_now, filter, result_offset, result);
296: 		}
297: 
298: 		result_offset += read_now;
299: 		page_rows_available -= read_now;
300: 		to_read -= read_now;
301: 	}
302: 	group_rows_available -= num_values;
303: 	chunk_read_offset = trans->GetLocation();
304: 
305: 	return num_values;
306: }
307: 
308: void ColumnReader::Skip(idx_t num_values) {
309: 	dummy_define.zero();
310: 	dummy_repeat.zero();
311: 
312: 	// TODO this can be optimized, for example we dont actually have to bitunpack offsets
313: 	auto values_read =
314: 	    Read(num_values, none_filter, (uint8_t *)dummy_define.ptr, (uint8_t *)dummy_repeat.ptr, dummy_result);
315: 	D_ASSERT(values_read == num_values);
316: }
317: 
318: void StringColumnReader::VerifyString(const char *str_data, idx_t str_len) {
319: 	if (Type() != LogicalTypeId::VARCHAR) {
320: 		return;
321: 	}
322: 	// verify if a string is actually UTF8, and if there are no null bytes in the middle of the string
323: 	// technically Parquet should guarantee this, but reality is often disappointing
324: 	auto utf_type = Utf8Proc::Analyze(str_data, str_len);
325: 	if (utf_type == UnicodeType::INVALID) {
326: 		throw InternalException("Invalid string encoding found in Parquet file: value is not valid UTF8!");
327: 	}
328: }
329: 
330: void StringColumnReader::Dictionary(shared_ptr<ByteBuffer> data, idx_t num_entries) {
331: 	dict = move(data);
332: 	dict_strings = unique_ptr<string_t[]>(new string_t[num_entries]);
333: 	for (idx_t dict_idx = 0; dict_idx < num_entries; dict_idx++) {
334: 		uint32_t str_len = dict->read<uint32_t>();
335: 		dict->available(str_len);
336: 
337: 		VerifyString(dict->ptr, str_len);
338: 		dict_strings[dict_idx] = string_t(dict->ptr, str_len);
339: 		dict->inc(str_len);
340: 	}
341: }
342: 
343: class ParquetStringVectorBuffer : public VectorBuffer {
344: public:
345: 	explicit ParquetStringVectorBuffer(shared_ptr<ByteBuffer> buffer_p)
346: 	    : VectorBuffer(VectorBufferType::OPAQUE_BUFFER), buffer(move(buffer_p)) {
347: 	}
348: 
349: private:
350: 	shared_ptr<ByteBuffer> buffer;
351: };
352: 
353: void StringColumnReader::DictReference(Vector &result) {
354: 	StringVector::AddBuffer(result, make_buffer<ParquetStringVectorBuffer>(dict));
355: }
356: void StringColumnReader::PlainReference(shared_ptr<ByteBuffer> plain_data, Vector &result) {
357: 	StringVector::AddBuffer(result, make_buffer<ParquetStringVectorBuffer>(move(plain_data)));
358: }
359: 
360: string_t StringParquetValueConversion::DictRead(ByteBuffer &dict, uint32_t &offset, ColumnReader &reader) {
361: 	auto &dict_strings = ((StringColumnReader &)reader).dict_strings;
362: 	return dict_strings[offset];
363: }
364: 
365: string_t StringParquetValueConversion::PlainRead(ByteBuffer &plain_data, ColumnReader &reader) {
366: 	uint32_t str_len = plain_data.read<uint32_t>();
367: 	plain_data.available(str_len);
368: 	((StringColumnReader &)reader).VerifyString(plain_data.ptr, str_len);
369: 	auto ret_str = string_t(plain_data.ptr, str_len);
370: 	plain_data.inc(str_len);
371: 	return ret_str;
372: }
373: 
374: void StringParquetValueConversion::PlainSkip(ByteBuffer &plain_data, ColumnReader &reader) {
375: 	uint32_t str_len = plain_data.read<uint32_t>();
376: 	plain_data.available(str_len);
377: 	plain_data.inc(str_len);
378: }
379: 
380: idx_t ListColumnReader::Read(uint64_t num_values, parquet_filter_t &filter, uint8_t *define_out, uint8_t *repeat_out,
381:                              Vector &result_out) {
382: 	if (!ListVector::HasEntry(result_out)) {
383: 		auto list_child = make_unique<ChunkCollection>();
384: 		ListVector::SetEntry(result_out, move(list_child));
385: 	}
386: 
387: 	idx_t result_offset = 0;
388: 	auto result_ptr = FlatVector::GetData<list_entry_t>(result_out);
389: 	auto &list_cc = ListVector::GetEntry(result_out);
390: 
391: 	while (result_offset < num_values) {
392: 		auto child_req_num_values = MinValue<idx_t>(STANDARD_VECTOR_SIZE, child_column_reader->GroupRowsAvailable());
393: 
394: 		if (child_req_num_values == 0) {
395: 			break;
396: 		}
397: 
398: 		child_defines.zero();
399: 		child_repeats.zero();
400: 
401: 		idx_t child_actual_num_values = 0;
402: 
403: 		if (overflow_child_count == 0) {
404: 			child_actual_num_values = child_column_reader->Read(child_req_num_values, child_filter, child_defines_ptr,
405: 			                                                    child_repeats_ptr, child_result);
406: 		} else {
407: 			child_actual_num_values = overflow_child_count;
408: 			overflow_child_count = 0;
409: 			child_result.Reference(overflow_child_vector);
410: 		}
411: 
412: 		append_chunk.data[0].Reference(child_result);
413: 		append_chunk.SetCardinality(child_actual_num_values);
414: 		append_chunk.Verify();
415: 
416: 		idx_t current_chunk_offset = list_cc.Count();
417: 		list_cc.Append(append_chunk);
418: 
419: 		// hard-won piece of code this, modify at your own risk
420: 		// the intuition is that we have to only collapse values into lists that are repeated *on this level*
421: 		// the rest is pretty much handed up as-is as a single-valued list or NULL
422: 		idx_t child_idx;
423: 		for (child_idx = 0; child_idx < child_actual_num_values; child_idx++) {
424: 			if (child_repeats_ptr[child_idx] == max_repeat) { // value repeats on this level, append
425: 				D_ASSERT(result_offset > 0);
426: 				result_ptr[result_offset - 1].length++;
427: 				continue;
428: 			}
429: 			if (result_offset >= num_values) { // we ran out of output space
430: 				break;
431: 			}
432: 			if (child_defines_ptr[child_idx] >= max_define) {
433: 				// value has been defined down the stack, hence its NOT NULL
434: 				result_ptr[result_offset].offset = child_idx + current_chunk_offset;
435: 				result_ptr[result_offset].length = 1;
436: 			} else {
437: 				// value is NULL somewhere up the stack
438: 				FlatVector::SetNull(result_out, result_offset, true);
439: 				result_ptr[result_offset].offset = 0;
440: 				result_ptr[result_offset].length = 0;
441: 			}
442: 
443: 			repeat_out[result_offset] = child_repeats_ptr[child_idx];
444: 			define_out[result_offset] = child_defines_ptr[child_idx];
445: 
446: 			result_offset++;
447: 		}
448: 
449: 		// we have read more values from the child reader than we can fit into the result for this read
450: 		// we have to pass everything from child_idx to child_actual_num_values into the next call
451: 		if (child_idx < child_actual_num_values && result_offset == num_values) {
452: 			overflow_child_vector.Slice(child_result, child_idx);
453: 			overflow_child_count = child_actual_num_values - child_idx;
454: 			overflow_child_vector.Verify(overflow_child_count);
455: 
456: 			// move values in the child repeats and defines *backward* by child_idx
457: 			for (idx_t repdef_idx = 0; repdef_idx < overflow_child_count; repdef_idx++) {
458: 				child_defines_ptr[repdef_idx] = child_defines_ptr[child_idx + repdef_idx];
459: 				child_repeats_ptr[repdef_idx] = child_repeats_ptr[child_idx + repdef_idx];
460: 			}
461: 		}
462: 	}
463: 	result_out.Verify(result_offset);
464: 	return result_offset;
465: }
466: 
467: } // namespace duckdb
[end of extension/parquet/column_reader.cpp]
[start of extension/parquet/include/column_reader.hpp]
1: #pragma once
2: 
3: #include "parquet_types.h"
4: #include "thrift_tools.hpp"
5: #include "resizable_buffer.hpp"
6: 
7: #include "parquet_rle_bp_decoder.hpp"
8: #include "parquet_statistics.hpp"
9: 
10: #include "duckdb/storage/statistics/string_statistics.hpp"
11: #include "duckdb/storage/statistics/numeric_statistics.hpp"
12: #include "duckdb/common/types/vector.hpp"
13: #include "duckdb/common/types/string_type.hpp"
14: #include "duckdb/common/types/chunk_collection.hpp"
15: #include "duckdb/common/operator/cast_operators.hpp"
16: 
17: namespace duckdb {
18: 
19: using apache::thrift::protocol::TProtocol;
20: 
21: using parquet::format::ColumnChunk;
22: using parquet::format::FieldRepetitionType;
23: using parquet::format::PageHeader;
24: using parquet::format::SchemaElement;
25: 
26: typedef std::bitset<STANDARD_VECTOR_SIZE> parquet_filter_t;
27: 
28: class ColumnReader {
29: 
30: public:
31: 	static unique_ptr<ColumnReader> CreateReader(const LogicalType &type_p, const SchemaElement &schema_p,
32: 	                                             idx_t schema_idx_p, idx_t max_define, idx_t max_repeat);
33: 
34: 	ColumnReader(LogicalType type_p, const SchemaElement &schema_p, idx_t file_idx_p, idx_t max_define_p,
35: 	             idx_t max_repeat_p)
36: 	    : schema(schema_p), file_idx(file_idx_p), max_define(max_define_p), max_repeat(max_repeat_p), type(type_p),
37: 	      page_rows_available(0) {
38: 
39: 		// dummies for Skip()
40: 		dummy_result.Initialize(Type());
41: 		none_filter.none();
42: 		dummy_define.resize(STANDARD_VECTOR_SIZE);
43: 		dummy_repeat.resize(STANDARD_VECTOR_SIZE);
44: 	};
45: 
46: 	virtual void IntializeRead(const std::vector<ColumnChunk> &columns, TProtocol &protocol_p) {
47: 		D_ASSERT(file_idx < columns.size());
48: 		chunk = &columns[file_idx];
49: 		protocol = &protocol_p;
50: 		D_ASSERT(chunk);
51: 		D_ASSERT(chunk->__isset.meta_data);
52: 
53: 		if (chunk->__isset.file_path) {
54: 			throw std::runtime_error("Only inlined data files are supported (no references)");
55: 		}
56: 
57: 		// ugh. sometimes there is an extra offset for the dict. sometimes it's wrong.
58: 		chunk_read_offset = chunk->meta_data.data_page_offset;
59: 		if (chunk->meta_data.__isset.dictionary_page_offset && chunk->meta_data.dictionary_page_offset >= 4) {
60: 			// this assumes the data pages follow the dict pages directly.
61: 			chunk_read_offset = chunk->meta_data.dictionary_page_offset;
62: 		}
63: 		group_rows_available = chunk->meta_data.num_values;
64: 	}
65: 
66: 	virtual ~ColumnReader();
67: 
68: 	virtual idx_t Read(uint64_t num_values, parquet_filter_t &filter, uint8_t *define_out, uint8_t *repeat_out,
69: 	                   Vector &result_out);
70: 
71: 	virtual void Skip(idx_t num_values);
72: 
73: 	const LogicalType &Type() {
74: 		return type;
75: 	}
76: 
77: 	const SchemaElement &Schema() {
78: 		return schema;
79: 	}
80: 
81: 	virtual idx_t GroupRowsAvailable() {
82: 		return group_rows_available;
83: 	}
84: 
85: 	unique_ptr<BaseStatistics> Stats(const std::vector<ColumnChunk> &columns) {
86: 		if (Type().id() == LogicalTypeId::LIST || Type().id() == LogicalTypeId::STRUCT) {
87: 			return nullptr;
88: 		}
89: 		return ParquetTransformColumnStatistics(Schema(), Type(), columns[file_idx]);
90: 	}
91: 
92: protected:
93: 	// readers that use the default Read() need to implement those
94: 	virtual void Plain(shared_ptr<ByteBuffer> plain_data, uint8_t *defines, idx_t num_values, parquet_filter_t &filter,
95: 	                   idx_t result_offset, Vector &result) {
96: 		throw NotImplementedException("Plain");
97: 	}
98: 
99: 	virtual void Dictionary(shared_ptr<ByteBuffer> dictionary_data, idx_t num_entries) {
100: 		throw NotImplementedException("Dictionary");
101: 	}
102: 
103: 	virtual void Offsets(uint32_t *offsets, uint8_t *defines, idx_t num_values, parquet_filter_t &filter,
104: 	                     idx_t result_offset, Vector &result) {
105: 		throw NotImplementedException("Offsets");
106: 	}
107: 
108: 	// these are nops for most types, but not for strings
109: 	virtual void DictReference(Vector &result) {
110: 	}
111: 	virtual void PlainReference(shared_ptr<ByteBuffer>, Vector &result) {
112: 	}
113: 
114: 	bool HasDefines() {
115: 		return max_define > 0;
116: 	}
117: 
118: 	bool HasRepeats() {
119: 		return max_repeat > 0;
120: 	}
121: 
122: 	const SchemaElement &schema;
123: 
124: 	idx_t file_idx;
125: 	idx_t max_define;
126: 	idx_t max_repeat;
127: 
128: private:
129: 	void PrepareRead(parquet_filter_t &filter);
130: 	void PreparePage(idx_t compressed_page_size, idx_t uncompressed_page_size);
131: 	void PrepareDataPage(PageHeader &page_hdr);
132: 
133: 	LogicalType type;
134: 	const parquet::format::ColumnChunk *chunk;
135: 
136: 	apache::thrift::protocol::TProtocol *protocol;
137: 	idx_t page_rows_available;
138: 	idx_t group_rows_available;
139: 	idx_t chunk_read_offset;
140: 
141: 	shared_ptr<ResizeableBuffer> block;
142: 
143: 	ResizeableBuffer offset_buffer;
144: 
145: 	unique_ptr<RleBpDecoder> dict_decoder;
146: 	unique_ptr<RleBpDecoder> defined_decoder;
147: 	unique_ptr<RleBpDecoder> repeated_decoder;
148: 
149: 	// dummies for Skip()
150: 	Vector dummy_result;
151: 	parquet_filter_t none_filter;
152: 	ResizeableBuffer dummy_define;
153: 	ResizeableBuffer dummy_repeat;
154: };
155: 
156: template <class VALUE_TYPE>
157: struct TemplatedParquetValueConversion {
158: 	static VALUE_TYPE DictRead(ByteBuffer &dict, uint32_t &offset, ColumnReader &reader) {
159: 		D_ASSERT(offset < dict.len / sizeof(VALUE_TYPE));
160: 		return ((VALUE_TYPE *)dict.ptr)[offset];
161: 	}
162: 
163: 	static VALUE_TYPE PlainRead(ByteBuffer &plain_data, ColumnReader &reader) {
164: 		return plain_data.read<VALUE_TYPE>();
165: 	}
166: 
167: 	static void PlainSkip(ByteBuffer &plain_data, ColumnReader &reader) {
168: 		plain_data.inc(sizeof(VALUE_TYPE));
169: 	}
170: };
171: 
172: template <class VALUE_TYPE, class VALUE_CONVERSION>
173: class TemplatedColumnReader : public ColumnReader {
174: 
175: public:
176: 	TemplatedColumnReader(LogicalType type_p, const SchemaElement &schema_p, idx_t schema_idx_p, idx_t max_define_p,
177: 	                      idx_t max_repeat_p)
178: 	    : ColumnReader(type_p, schema_p, schema_idx_p, max_define_p, max_repeat_p) {};
179: 
180: 	void Dictionary(shared_ptr<ByteBuffer> data, idx_t num_entries) override {
181: 		dict = move(data);
182: 	}
183: 
184: 	void Offsets(uint32_t *offsets, uint8_t *defines, uint64_t num_values, parquet_filter_t &filter,
185: 	             idx_t result_offset, Vector &result) override {
186: 		auto result_ptr = FlatVector::GetData<VALUE_TYPE>(result);
187: 
188: 		idx_t offset_idx = 0;
189: 		for (idx_t row_idx = 0; row_idx < num_values; row_idx++) {
190: 			if (HasDefines() && defines[row_idx + result_offset] != max_define) {
191: 				FlatVector::SetNull(result, row_idx + result_offset, true);
192: 				continue;
193: 			}
194: 			if (filter[row_idx + result_offset]) {
195: 				VALUE_TYPE val = VALUE_CONVERSION::DictRead(*dict, offsets[offset_idx++], *this);
196: 				if (!Value::IsValid(val)) {
197: 					FlatVector::SetNull(result, row_idx + result_offset, true);
198: 					continue;
199: 				}
200: 				result_ptr[row_idx + result_offset] = val;
201: 			} else {
202: 				offset_idx++;
203: 			}
204: 		}
205: 	}
206: 
207: 	void Plain(shared_ptr<ByteBuffer> plain_data, uint8_t *defines, uint64_t num_values, parquet_filter_t &filter,
208: 	           idx_t result_offset, Vector &result) override {
209: 		auto result_ptr = FlatVector::GetData<VALUE_TYPE>(result);
210: 		for (idx_t row_idx = 0; row_idx < num_values; row_idx++) {
211: 			if (HasDefines() && defines[row_idx + result_offset] != max_define) {
212: 				FlatVector::SetNull(result, row_idx + result_offset, true);
213: 				continue;
214: 			}
215: 			if (filter[row_idx + result_offset]) {
216: 				VALUE_TYPE val = VALUE_CONVERSION::PlainRead(*plain_data, *this);
217: 				if (!Value::IsValid(val)) {
218: 					FlatVector::SetNull(result, row_idx + result_offset, true);
219: 					continue;
220: 				}
221: 				result_ptr[row_idx + result_offset] = val;
222: 			} else { // there is still some data there that we have to skip over
223: 				VALUE_CONVERSION::PlainSkip(*plain_data, *this);
224: 			}
225: 		}
226: 	}
227: 
228: 	shared_ptr<ByteBuffer> dict;
229: };
230: 
231: struct StringParquetValueConversion {
232: 	static string_t DictRead(ByteBuffer &dict, uint32_t &offset, ColumnReader &reader);
233: 
234: 	static string_t PlainRead(ByteBuffer &plain_data, ColumnReader &reader);
235: 
236: 	static void PlainSkip(ByteBuffer &plain_data, ColumnReader &reader);
237: };
238: 
239: class StringColumnReader : public TemplatedColumnReader<string_t, StringParquetValueConversion> {
240: 
241: public:
242: 	StringColumnReader(LogicalType type_p, const SchemaElement &schema_p, idx_t schema_idx_p, idx_t max_define_p,
243: 	                   idx_t max_repeat_p)
244: 	    : TemplatedColumnReader<string_t, StringParquetValueConversion>(type_p, schema_p, schema_idx_p, max_define_p,
245: 	                                                                    max_repeat_p) {};
246: 
247: 	void Dictionary(shared_ptr<ByteBuffer> dictionary_data, idx_t num_entries) override;
248: 
249: 	unique_ptr<string_t[]> dict_strings;
250: 	void VerifyString(const char *str_data, idx_t str_len);
251: 
252: protected:
253: 	void DictReference(Vector &result) override;
254: 	void PlainReference(shared_ptr<ByteBuffer> plain_data, Vector &result) override;
255: };
256: 
257: template <class DUCKDB_PHYSICAL_TYPE>
258: struct DecimalParquetValueConversion {
259: 
260: 	static DUCKDB_PHYSICAL_TYPE DictRead(ByteBuffer &dict, uint32_t &offset, ColumnReader &reader) {
261: 		auto dict_ptr = (DUCKDB_PHYSICAL_TYPE *)dict.ptr;
262: 		return dict_ptr[offset];
263: 	}
264: 
265: 	static DUCKDB_PHYSICAL_TYPE PlainRead(ByteBuffer &plain_data, ColumnReader &reader) {
266: 		DUCKDB_PHYSICAL_TYPE res = 0;
267: 		auto byte_len = (idx_t)reader.Schema().type_length; /* sure, type length needs to be a signed int */
268: 		D_ASSERT(byte_len <= sizeof(DUCKDB_PHYSICAL_TYPE));
269: 		plain_data.available(byte_len);
270: 		auto res_ptr = (uint8_t *)&res;
271: 
272: 		// numbers are stored as two's complement so some muckery is required
273: 		bool positive = (*plain_data.ptr & 0x80) == 0;
274: 
275: 		for (idx_t i = 0; i < byte_len; i++) {
276: 			auto byte = *(plain_data.ptr + (byte_len - i - 1));
277: 			res_ptr[i] = positive ? byte : byte ^ 0xFF;
278: 		}
279: 		plain_data.inc(byte_len);
280: 		if (!positive) {
281: 			res += 1;
282: 			return -res;
283: 		}
284: 		return res;
285: 	}
286: 
287: 	static void PlainSkip(ByteBuffer &plain_data, ColumnReader &reader) {
288: 		plain_data.inc(reader.Schema().type_length);
289: 	}
290: };
291: 
292: template <class DUCKDB_PHYSICAL_TYPE>
293: class DecimalColumnReader
294:     : public TemplatedColumnReader<DUCKDB_PHYSICAL_TYPE, DecimalParquetValueConversion<DUCKDB_PHYSICAL_TYPE>> {
295: 
296: public:
297: 	DecimalColumnReader(LogicalType type_p, const SchemaElement &schema_p, idx_t file_idx_p, idx_t max_define_p,
298: 	                    idx_t max_repeat_p)
299: 	    : TemplatedColumnReader<DUCKDB_PHYSICAL_TYPE, DecimalParquetValueConversion<DUCKDB_PHYSICAL_TYPE>>(
300: 	          type_p, schema_p, file_idx_p, max_define_p, max_repeat_p) {};
301: 
302: protected:
303: 	void Dictionary(shared_ptr<ByteBuffer> dictionary_data, idx_t num_entries) {
304: 		this->dict = make_shared<ResizeableBuffer>(num_entries * sizeof(DUCKDB_PHYSICAL_TYPE));
305: 		auto dict_ptr = (DUCKDB_PHYSICAL_TYPE *)this->dict->ptr;
306: 		for (idx_t i = 0; i < num_entries; i++) {
307: 			dict_ptr[i] = DecimalParquetValueConversion<DUCKDB_PHYSICAL_TYPE>::PlainRead(*dictionary_data, *this);
308: 		}
309: 	}
310: };
311: 
312: template <class PARQUET_PHYSICAL_TYPE, class DUCKDB_PHYSICAL_TYPE,
313:           DUCKDB_PHYSICAL_TYPE (*FUNC)(const PARQUET_PHYSICAL_TYPE &input)>
314: struct CallbackParquetValueConversion {
315: 	static DUCKDB_PHYSICAL_TYPE DictRead(ByteBuffer &dict, uint32_t &offset, ColumnReader &reader) {
316: 		return TemplatedParquetValueConversion<DUCKDB_PHYSICAL_TYPE>::DictRead(dict, offset, reader);
317: 	}
318: 
319: 	static DUCKDB_PHYSICAL_TYPE PlainRead(ByteBuffer &plain_data, ColumnReader &reader) {
320: 		return FUNC(plain_data.read<PARQUET_PHYSICAL_TYPE>());
321: 	}
322: 
323: 	static void PlainSkip(ByteBuffer &plain_data, ColumnReader &reader) {
324: 		plain_data.inc(sizeof(PARQUET_PHYSICAL_TYPE));
325: 	}
326: };
327: 
328: template <class PARQUET_PHYSICAL_TYPE, class DUCKDB_PHYSICAL_TYPE,
329:           DUCKDB_PHYSICAL_TYPE (*FUNC)(const PARQUET_PHYSICAL_TYPE &input)>
330: class CallbackColumnReader
331:     : public TemplatedColumnReader<DUCKDB_PHYSICAL_TYPE,
332:                                    CallbackParquetValueConversion<PARQUET_PHYSICAL_TYPE, DUCKDB_PHYSICAL_TYPE, FUNC>> {
333: 
334: public:
335: 	CallbackColumnReader(LogicalType type_p, const SchemaElement &schema_p, idx_t file_idx_p, idx_t max_define_p,
336: 	                     idx_t max_repeat_p)
337: 	    : TemplatedColumnReader<DUCKDB_PHYSICAL_TYPE,
338: 	                            CallbackParquetValueConversion<PARQUET_PHYSICAL_TYPE, DUCKDB_PHYSICAL_TYPE, FUNC>>(
339: 	          type_p, schema_p, file_idx_p, max_define_p, max_repeat_p) {};
340: 
341: protected:
342: 	void Dictionary(shared_ptr<ByteBuffer> dictionary_data, idx_t num_entries) {
343: 		this->dict = make_shared<ResizeableBuffer>(num_entries * sizeof(DUCKDB_PHYSICAL_TYPE));
344: 		auto dict_ptr = (DUCKDB_PHYSICAL_TYPE *)this->dict->ptr;
345: 		for (idx_t i = 0; i < num_entries; i++) {
346: 			dict_ptr[i] = FUNC(dictionary_data->read<PARQUET_PHYSICAL_TYPE>());
347: 		}
348: 	}
349: };
350: 
351: struct BooleanParquetValueConversion;
352: 
353: class BooleanColumnReader : public TemplatedColumnReader<bool, BooleanParquetValueConversion> {
354: public:
355: 	BooleanColumnReader(LogicalType type_p, const SchemaElement &schema_p, idx_t schema_idx_p, idx_t max_define_p,
356: 	                    idx_t max_repeat_p)
357: 	    : TemplatedColumnReader<bool, BooleanParquetValueConversion>(type_p, schema_p, schema_idx_p, max_define_p,
358: 	                                                                 max_repeat_p),
359: 	      byte_pos(0) {};
360: 
361: 	uint8_t byte_pos;
362: };
363: 
364: struct BooleanParquetValueConversion {
365: 	static bool DictRead(ByteBuffer &dict, uint32_t &offset, ColumnReader &reader) {
366: 		throw std::runtime_error("Dicts for booleans make no sense");
367: 	}
368: 
369: 	static bool PlainRead(ByteBuffer &plain_data, ColumnReader &reader) {
370: 		plain_data.available(1);
371: 		auto &byte_pos = ((BooleanColumnReader &)reader).byte_pos;
372: 		bool ret = (*plain_data.ptr >> byte_pos) & 1;
373: 		byte_pos++;
374: 		if (byte_pos == 8) {
375: 			byte_pos = 0;
376: 			plain_data.inc(1);
377: 		}
378: 		return ret;
379: 	}
380: 
381: 	static void PlainSkip(ByteBuffer &plain_data, ColumnReader &reader) {
382: 		PlainRead(plain_data, reader);
383: 	}
384: };
385: 
386: class StructColumnReader : public ColumnReader {
387: 
388: public:
389: 	StructColumnReader(LogicalType type_p, const SchemaElement &schema_p, idx_t schema_idx_p, idx_t max_define_p,
390: 	                   idx_t max_repeat_p, vector<unique_ptr<ColumnReader>> child_readers_p)
391: 	    : ColumnReader(type_p, schema_p, schema_idx_p, max_define_p, max_repeat_p),
392: 	      child_readers(move(child_readers_p)) {
393: 		D_ASSERT(type_p.id() == LogicalTypeId::STRUCT);
394: 		D_ASSERT(!type_p.child_types().empty());
395: 	};
396: 
397: 	ColumnReader *GetChildReader(idx_t child_idx) {
398: 		return child_readers[child_idx].get();
399: 	}
400: 
401: 	void IntializeRead(const std::vector<ColumnChunk> &columns, TProtocol &protocol_p) override {
402: 		for (auto &child : child_readers) {
403: 			child->IntializeRead(columns, protocol_p);
404: 		}
405: 	}
406: 
407: 	idx_t Read(uint64_t num_values, parquet_filter_t &filter, uint8_t *define_out, uint8_t *repeat_out,
408: 	           Vector &result) override {
409: 		result.Initialize(Type());
410: 
411: 		for (idx_t i = 0; i < Type().child_types().size(); i++) {
412: 			auto child_read = make_unique<Vector>();
413: 			child_read->Initialize(Type().child_types()[i].second);
414: 			auto child_num_values = child_readers[i]->Read(num_values, filter, define_out, repeat_out, *child_read);
415: 			D_ASSERT(child_num_values == num_values);
416: 			StructVector::AddEntry(result, Type().child_types()[i].first, move(child_read));
417: 		}
418: 
419: 		return num_values;
420: 	}
421: 
422: 	virtual void Skip(idx_t num_values) override {
423: 		D_ASSERT(0);
424: 	}
425: 
426: 	idx_t GroupRowsAvailable() override {
427: 		return child_readers[0]->GroupRowsAvailable();
428: 	}
429: 
430: 	vector<unique_ptr<ColumnReader>> child_readers;
431: };
432: 
433: class ListColumnReader : public ColumnReader {
434: public:
435: 	ListColumnReader(LogicalType type_p, const SchemaElement &schema_p, idx_t schema_idx_p, idx_t max_define_p,
436: 	                 idx_t max_repeat_p, unique_ptr<ColumnReader> child_column_reader_p)
437: 	    : ColumnReader(type_p, schema_p, schema_idx_p, max_define_p, max_repeat_p),
438: 	      child_column_reader(move(child_column_reader_p)), overflow_child_count(0) {
439: 
440: 		child_defines.resize(STANDARD_VECTOR_SIZE);
441: 		child_repeats.resize(STANDARD_VECTOR_SIZE);
442: 		child_defines_ptr = (uint8_t *)child_defines.ptr;
443: 		child_repeats_ptr = (uint8_t *)child_repeats.ptr;
444: 
445: 		auto child_type = Type().child_types()[0].second;
446: 		child_result.Initialize(child_type);
447: 
448: 		vector<LogicalType> append_chunk_types;
449: 		append_chunk_types.push_back(child_type);
450: 		append_chunk.Initialize(append_chunk_types);
451: 
452: 		child_filter.set();
453: 	};
454: 
455: 	idx_t Read(uint64_t num_values, parquet_filter_t &filter, uint8_t *define_out, uint8_t *repeat_out,
456: 	           Vector &result_out) override;
457: 
458: 	virtual void Skip(idx_t num_values) override {
459: 		D_ASSERT(0);
460: 	}
461: 
462: 	void IntializeRead(const std::vector<ColumnChunk> &columns, TProtocol &protocol_p) override {
463: 		child_column_reader->IntializeRead(columns, protocol_p);
464: 	}
465: 
466: 	idx_t GroupRowsAvailable() override {
467: 		return child_column_reader->GroupRowsAvailable();
468: 	}
469: 
470: private:
471: 	unique_ptr<ColumnReader> child_column_reader;
472: 	ResizeableBuffer child_defines;
473: 	ResizeableBuffer child_repeats;
474: 	uint8_t *child_defines_ptr;
475: 	uint8_t *child_repeats_ptr;
476: 
477: 	Vector child_result;
478: 	parquet_filter_t child_filter;
479: 	DataChunk append_chunk;
480: 
481: 	Vector overflow_child_vector;
482: 	idx_t overflow_child_count;
483: };
484: 
485: } // namespace duckdb
[end of extension/parquet/include/column_reader.hpp]
[start of src/include/duckdb/main/relation.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/relation.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/enums/join_type.hpp"
13: #include "duckdb/common/enums/relation_type.hpp"
14: #include "duckdb/common/winapi.hpp"
15: #include "duckdb/main/query_result.hpp"
16: #include "duckdb/parser/column_definition.hpp"
17: 
18: #include <memory>
19: 
20: namespace duckdb {
21: struct BoundStatement;
22: 
23: class ClientContext;
24: class Binder;
25: class LogicalOperator;
26: class QueryNode;
27: class TableRef;
28: 
29: class Relation : public std::enable_shared_from_this<Relation> {
30: public:
31: 	DUCKDB_API Relation(ClientContext &context, RelationType type) : context(context), type(type) {
32: 	}
33: 	DUCKDB_API virtual ~Relation() {
34: 	}
35: 
36: 	ClientContext &context;
37: 	RelationType type;
38: 
39: public:
40: 	DUCKDB_API virtual const vector<ColumnDefinition> &Columns() = 0;
41: 	DUCKDB_API virtual unique_ptr<QueryNode> GetQueryNode() = 0;
42: 	DUCKDB_API virtual BoundStatement Bind(Binder &binder);
43: 	DUCKDB_API virtual string GetAlias();
44: 
45: 	DUCKDB_API unique_ptr<QueryResult> Execute();
46: 	DUCKDB_API string ToString();
47: 	DUCKDB_API virtual string ToString(idx_t depth) = 0;
48: 
49: 	DUCKDB_API void Print();
50: 	DUCKDB_API void Head(idx_t limit = 10);
51: 
52: 	DUCKDB_API shared_ptr<Relation> CreateView(const string &name, bool replace = true);
53: 	DUCKDB_API unique_ptr<QueryResult> Query(const string &sql);
54: 	DUCKDB_API unique_ptr<QueryResult> Query(const string &name, const string &sql);
55: 
56: 	//! Explain the query plan of this relation
57: 	DUCKDB_API unique_ptr<QueryResult> Explain();
58: 
59: 	DUCKDB_API virtual unique_ptr<TableRef> GetTableRef();
60: 	DUCKDB_API virtual bool IsReadOnly() {
61: 		return true;
62: 	}
63: 
64: public:
65: 	// PROJECT
66: 	DUCKDB_API shared_ptr<Relation> Project(const string &select_list);
67: 	DUCKDB_API shared_ptr<Relation> Project(const string &expression, const string &alias);
68: 	DUCKDB_API shared_ptr<Relation> Project(const string &select_list, const vector<string> &aliases);
69: 	DUCKDB_API shared_ptr<Relation> Project(const vector<string> &expressions);
70: 	DUCKDB_API shared_ptr<Relation> Project(const vector<string> &expressions, const vector<string> &aliases);
71: 
72: 	// FILTER
73: 	DUCKDB_API shared_ptr<Relation> Filter(const string &expression);
74: 	DUCKDB_API shared_ptr<Relation> Filter(const vector<string> &expressions);
75: 
76: 	// LIMIT
77: 	DUCKDB_API shared_ptr<Relation> Limit(int64_t n, int64_t offset = 0);
78: 
79: 	// ORDER
80: 	DUCKDB_API shared_ptr<Relation> Order(const string &expression);
81: 	DUCKDB_API shared_ptr<Relation> Order(const vector<string> &expressions);
82: 
83: 	// JOIN operation
84: 	DUCKDB_API shared_ptr<Relation> Join(const shared_ptr<Relation> &other, const string &condition,
85: 	                                     JoinType type = JoinType::INNER);
86: 
87: 	// SET operations
88: 	DUCKDB_API shared_ptr<Relation> Union(const shared_ptr<Relation> &other);
89: 	DUCKDB_API shared_ptr<Relation> Except(const shared_ptr<Relation> &other);
90: 	DUCKDB_API shared_ptr<Relation> Intersect(const shared_ptr<Relation> &other);
91: 
92: 	// DISTINCT operation
93: 	DUCKDB_API shared_ptr<Relation> Distinct();
94: 
95: 	// AGGREGATES
96: 	DUCKDB_API shared_ptr<Relation> Aggregate(const string &aggregate_list);
97: 	DUCKDB_API shared_ptr<Relation> Aggregate(const vector<string> &aggregates);
98: 	DUCKDB_API shared_ptr<Relation> Aggregate(const string &aggregate_list, const string &group_list);
99: 	DUCKDB_API shared_ptr<Relation> Aggregate(const vector<string> &aggregates, const vector<string> &groups);
100: 
101: 	// ALIAS
102: 	DUCKDB_API shared_ptr<Relation> Alias(const string &alias);
103: 
104: 	//! Insert the data from this relation into a table
105: 	DUCKDB_API void Insert(const string &table_name);
106: 	DUCKDB_API void Insert(const string &schema_name, const string &table_name);
107: 	//! Insert a row (i.e.,list of values) into a table
108: 	DUCKDB_API void Insert(const vector<vector<Value>> &values);
109: 	//! Create a table and insert the data from this relation into that table
110: 	DUCKDB_API void Create(const string &table_name);
111: 	DUCKDB_API void Create(const string &schema_name, const string &table_name);
112: 
113: 	//! Write a relation to a CSV file
114: 	DUCKDB_API void WriteCSV(const string &csv_file);
115: 
116: 	//! Update a table, can only be used on a TableRelation
117: 	DUCKDB_API virtual void Update(const string &update, const string &condition = string());
118: 	//! Delete from a table, can only be used on a TableRelation
119: 	DUCKDB_API virtual void Delete(const string &condition = string());
120: 
121: public:
122: 	//! Whether or not the relation inherits column bindings from its child or not, only relevant for binding
123: 	DUCKDB_API virtual bool InheritsColumnBindings() {
124: 		return false;
125: 	}
126: 	DUCKDB_API virtual Relation *ChildRelation() {
127: 		return nullptr;
128: 	}
129: 
130: protected:
131: 	DUCKDB_API string RenderWhitespace(idx_t depth);
132: };
133: 
134: } // namespace duckdb
[end of src/include/duckdb/main/relation.hpp]
[start of src/include/duckdb/main/relation/create_view_relation.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/relation/create_view_relation.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/main/relation.hpp"
12: 
13: namespace duckdb {
14: 
15: class CreateViewRelation : public Relation {
16: public:
17: 	CreateViewRelation(shared_ptr<Relation> child, string view_name, bool replace);
18: 
19: 	shared_ptr<Relation> child;
20: 	string view_name;
21: 	bool replace;
22: 	vector<ColumnDefinition> columns;
23: 
24: public:
25: 	unique_ptr<QueryNode> GetQueryNode() override;
26: 	BoundStatement Bind(Binder &binder) override;
27: 	const vector<ColumnDefinition> &Columns() override;
28: 	string ToString(idx_t depth) override;
29: 	bool IsReadOnly() override {
30: 		return false;
31: 	}
32: };
33: 
34: } // namespace duckdb
[end of src/include/duckdb/main/relation/create_view_relation.hpp]
[start of src/main/relation.cpp]
1: #include "duckdb/main/relation.hpp"
2: #include "duckdb/common/printer.hpp"
3: #include "duckdb/parser/parser.hpp"
4: #include "duckdb/main/relation/aggregate_relation.hpp"
5: #include "duckdb/main/relation/distinct_relation.hpp"
6: #include "duckdb/main/relation/explain_relation.hpp"
7: #include "duckdb/main/relation/filter_relation.hpp"
8: #include "duckdb/main/relation/insert_relation.hpp"
9: #include "duckdb/main/relation/limit_relation.hpp"
10: #include "duckdb/main/relation/order_relation.hpp"
11: #include "duckdb/main/relation/projection_relation.hpp"
12: #include "duckdb/main/relation/setop_relation.hpp"
13: #include "duckdb/main/relation/subquery_relation.hpp"
14: #include "duckdb/main/relation/create_table_relation.hpp"
15: #include "duckdb/main/relation/create_view_relation.hpp"
16: #include "duckdb/main/relation/write_csv_relation.hpp"
17: #include "duckdb/main/client_context.hpp"
18: #include "duckdb/planner/binder.hpp"
19: #include "duckdb/parser/tableref/subqueryref.hpp"
20: #include "duckdb/parser/statement/select_statement.hpp"
21: #include "duckdb/parser/expression/conjunction_expression.hpp"
22: #include "duckdb/parser/expression/columnref_expression.hpp"
23: #include "duckdb/main/relation/join_relation.hpp"
24: #include "duckdb/main/relation/value_relation.hpp"
25: 
26: namespace duckdb {
27: 
28: shared_ptr<Relation> Relation::Project(const string &select_list) {
29: 	return Project(select_list, vector<string>());
30: }
31: 
32: shared_ptr<Relation> Relation::Project(const string &expression, const string &alias) {
33: 	return Project(expression, vector<string>({alias}));
34: }
35: 
36: shared_ptr<Relation> Relation::Project(const string &select_list, const vector<string> &aliases) {
37: 	auto expressions = Parser::ParseExpressionList(select_list);
38: 	return make_shared<ProjectionRelation>(shared_from_this(), move(expressions), aliases);
39: }
40: 
41: shared_ptr<Relation> Relation::Project(const vector<string> &expressions) {
42: 	vector<string> aliases;
43: 	return Project(expressions, aliases);
44: }
45: 
46: static vector<unique_ptr<ParsedExpression>> StringListToExpressionList(const vector<string> &expressions) {
47: 	if (expressions.empty()) {
48: 		throw ParserException("Zero expressions provided");
49: 	}
50: 	vector<unique_ptr<ParsedExpression>> result_list;
51: 	for (auto &expr : expressions) {
52: 		auto expression_list = Parser::ParseExpressionList(expr);
53: 		if (expression_list.size() != 1) {
54: 			throw ParserException("Expected a single expression in the expression list");
55: 		}
56: 		result_list.push_back(move(expression_list[0]));
57: 	}
58: 	return result_list;
59: }
60: 
61: shared_ptr<Relation> Relation::Project(const vector<string> &expressions, const vector<string> &aliases) {
62: 	auto result_list = StringListToExpressionList(expressions);
63: 	return make_shared<ProjectionRelation>(shared_from_this(), move(result_list), aliases);
64: }
65: 
66: shared_ptr<Relation> Relation::Filter(const string &expression) {
67: 	auto expression_list = Parser::ParseExpressionList(expression);
68: 	if (expression_list.size() != 1) {
69: 		throw ParserException("Expected a single expression as filter condition");
70: 	}
71: 	return make_shared<FilterRelation>(shared_from_this(), move(expression_list[0]));
72: }
73: 
74: shared_ptr<Relation> Relation::Filter(const vector<string> &expressions) {
75: 	// if there are multiple expressions, we AND them together
76: 	auto expression_list = StringListToExpressionList(expressions);
77: 	if (expression_list.empty()) {
78: 		throw ParserException("Zero filter conditions provided");
79: 	}
80: 	auto expr = move(expression_list[0]);
81: 	for (idx_t i = 1; i < expression_list.size(); i++) {
82: 		expr =
83: 		    make_unique<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, move(expr), move(expression_list[i]));
84: 	}
85: 	return make_shared<FilterRelation>(shared_from_this(), move(expr));
86: }
87: 
88: shared_ptr<Relation> Relation::Limit(int64_t limit, int64_t offset) {
89: 	return make_shared<LimitRelation>(shared_from_this(), limit, offset);
90: }
91: 
92: shared_ptr<Relation> Relation::Order(const string &expression) {
93: 	auto order_list = Parser::ParseOrderList(expression);
94: 	return make_shared<OrderRelation>(shared_from_this(), move(order_list));
95: }
96: 
97: shared_ptr<Relation> Relation::Order(const vector<string> &expressions) {
98: 	if (expressions.empty()) {
99: 		throw ParserException("Zero ORDER BY expressions provided");
100: 	}
101: 	vector<OrderByNode> order_list;
102: 	for (auto &expression : expressions) {
103: 		auto inner_list = Parser::ParseOrderList(expression);
104: 		if (inner_list.size() != 1) {
105: 			throw ParserException("Expected a single ORDER BY expression in the expression list");
106: 		}
107: 		order_list.push_back(move(inner_list[0]));
108: 	}
109: 	return make_shared<OrderRelation>(shared_from_this(), move(order_list));
110: }
111: 
112: shared_ptr<Relation> Relation::Join(const shared_ptr<Relation> &other, const string &condition, JoinType type) {
113: 	auto expression_list = Parser::ParseExpressionList(condition);
114: 	if (expression_list.empty()) {
115: 		throw ParserException("Expected a single expression as join condition");
116: 	}
117: 	if (expression_list.size() > 1 || expression_list[0]->type == ExpressionType::COLUMN_REF) {
118: 		// multiple columns or single column ref: the condition is a USING list
119: 		vector<string> using_columns;
120: 		for (auto &expr : expression_list) {
121: 			if (expr->type != ExpressionType::COLUMN_REF) {
122: 				throw ParserException("Expected a single expression as join condition");
123: 			}
124: 			auto &colref = (ColumnRefExpression &)*expr;
125: 			if (!colref.table_name.empty()) {
126: 				throw ParserException("Expected empty table name for column in USING clause");
127: 			}
128: 			using_columns.push_back(colref.column_name);
129: 		}
130: 		return make_shared<JoinRelation>(shared_from_this(), other, move(using_columns), type);
131: 	} else {
132: 		// single expression that is not a column reference: use the expression as a join condition
133: 		return make_shared<JoinRelation>(shared_from_this(), other, move(expression_list[0]), type);
134: 	}
135: }
136: 
137: shared_ptr<Relation> Relation::Union(const shared_ptr<Relation> &other) {
138: 	return make_shared<SetOpRelation>(shared_from_this(), other, SetOperationType::UNION);
139: }
140: 
141: shared_ptr<Relation> Relation::Except(const shared_ptr<Relation> &other) {
142: 	return make_shared<SetOpRelation>(shared_from_this(), other, SetOperationType::EXCEPT);
143: }
144: 
145: shared_ptr<Relation> Relation::Intersect(const shared_ptr<Relation> &other) {
146: 	return make_shared<SetOpRelation>(shared_from_this(), other, SetOperationType::INTERSECT);
147: }
148: 
149: shared_ptr<Relation> Relation::Distinct() {
150: 	return make_shared<DistinctRelation>(shared_from_this());
151: }
152: 
153: shared_ptr<Relation> Relation::Alias(const string &alias) {
154: 	return make_shared<SubqueryRelation>(shared_from_this(), alias);
155: }
156: 
157: shared_ptr<Relation> Relation::Aggregate(const string &aggregate_list) {
158: 	auto expression_list = Parser::ParseExpressionList(aggregate_list);
159: 	return make_shared<AggregateRelation>(shared_from_this(), move(expression_list));
160: }
161: 
162: shared_ptr<Relation> Relation::Aggregate(const string &aggregate_list, const string &group_list) {
163: 	auto expression_list = Parser::ParseExpressionList(aggregate_list);
164: 	auto groups = Parser::ParseExpressionList(group_list);
165: 	return make_shared<AggregateRelation>(shared_from_this(), move(expression_list), move(groups));
166: }
167: 
168: shared_ptr<Relation> Relation::Aggregate(const vector<string> &aggregates) {
169: 	auto aggregate_list = StringListToExpressionList(aggregates);
170: 	return make_shared<AggregateRelation>(shared_from_this(), move(aggregate_list));
171: }
172: 
173: shared_ptr<Relation> Relation::Aggregate(const vector<string> &aggregates, const vector<string> &groups) {
174: 	auto aggregate_list = StringListToExpressionList(aggregates);
175: 	auto group_list = StringListToExpressionList(groups);
176: 	return make_shared<AggregateRelation>(shared_from_this(), move(aggregate_list), move(group_list));
177: }
178: 
179: string Relation::GetAlias() {
180: 	return "relation";
181: }
182: 
183: unique_ptr<TableRef> Relation::GetTableRef() {
184: 	auto select = make_unique<SelectStatement>();
185: 	select->node = GetQueryNode();
186: 	return make_unique<SubqueryRef>(move(select), GetAlias());
187: }
188: 
189: unique_ptr<QueryResult> Relation::Execute() {
190: 	return context.Execute(shared_from_this());
191: }
192: 
193: BoundStatement Relation::Bind(Binder &binder) {
194: 	SelectStatement stmt;
195: 	stmt.node = GetQueryNode();
196: 	return binder.Bind((SQLStatement &)stmt);
197: }
198: 
199: void Relation::Insert(const string &table_name) {
200: 	Insert(DEFAULT_SCHEMA, table_name);
201: }
202: 
203: void Relation::Insert(const string &schema_name, const string &table_name) {
204: 	auto insert = make_shared<InsertRelation>(shared_from_this(), schema_name, table_name);
205: 	insert->Execute();
206: }
207: 
208: void Relation::Insert(const vector<vector<Value>> &values) {
209: 	vector<string> column_names;
210: 	auto rel = make_shared<ValueRelation>(context, values, move(column_names), "values");
211: 	rel->Insert(GetAlias());
212: }
213: 
214: void Relation::Create(const string &table_name) {
215: 	Create(DEFAULT_SCHEMA, table_name);
216: }
217: 
218: void Relation::Create(const string &schema_name, const string &table_name) {
219: 	auto create = make_shared<CreateTableRelation>(shared_from_this(), schema_name, table_name);
220: 	create->Execute();
221: }
222: 
223: void Relation::WriteCSV(const string &csv_file) {
224: 	auto write_csv = make_shared<WriteCSVRelation>(shared_from_this(), csv_file);
225: 	write_csv->Execute();
226: }
227: 
228: void Relation::Head(idx_t limit) {
229: 	auto limit_node = Limit(limit);
230: 	limit_node->Execute()->Print();
231: }
232: 
233: shared_ptr<Relation> Relation::CreateView(const string &name, bool replace) {
234: 	auto view = make_shared<CreateViewRelation>(shared_from_this(), name, replace);
235: 	view->Execute();
236: 	return shared_from_this();
237: }
238: 
239: unique_ptr<QueryResult> Relation::Query(const string &sql) {
240: 	return context.Query(sql, false);
241: }
242: 
243: unique_ptr<QueryResult> Relation::Query(const string &name, const string &sql) {
244: 	CreateView(name);
245: 	return Query(sql);
246: }
247: 
248: unique_ptr<QueryResult> Relation::Explain() {
249: 	auto explain = make_shared<ExplainRelation>(shared_from_this());
250: 	return explain->Execute();
251: }
252: 
253: void Relation::Update(const string &update, const string &condition) {
254: 	throw Exception("UPDATE can only be used on base tables!");
255: }
256: 
257: void Relation::Delete(const string &condition) {
258: 	throw Exception("DELETE can only be used on base tables!");
259: }
260: 
261: string Relation::ToString() {
262: 	string str;
263: 	str += "---------------------\n";
264: 	str += "-- Expression Tree --\n";
265: 	str += "---------------------\n";
266: 	str += ToString(0);
267: 	str += "\n\n";
268: 	str += "---------------------\n";
269: 	str += "-- Result Columns  --\n";
270: 	str += "---------------------\n";
271: 	auto &cols = Columns();
272: 	for (idx_t i = 0; i < cols.size(); i++) {
273: 		str += "- " + cols[i].name + " (" + cols[i].type.ToString() + ")\n";
274: 	}
275: 	return str;
276: }
277: 
278: void Relation::Print() {
279: 	Printer::Print(ToString());
280: }
281: 
282: string Relation::RenderWhitespace(idx_t depth) {
283: 	return string(depth * 2, ' ');
284: }
285: 
286: } // namespace duckdb
[end of src/main/relation.cpp]
[start of src/main/relation/create_view_relation.cpp]
1: #include "duckdb/main/relation/create_view_relation.hpp"
2: #include "duckdb/parser/statement/create_statement.hpp"
3: #include "duckdb/parser/parsed_data/create_view_info.hpp"
4: #include "duckdb/planner/binder.hpp"
5: #include "duckdb/main/client_context.hpp"
6: 
7: namespace duckdb {
8: 
9: CreateViewRelation::CreateViewRelation(shared_ptr<Relation> child_p, string view_name, bool replace)
10:     : Relation(child_p->context, RelationType::CREATE_VIEW_RELATION), child(move(child_p)), view_name(move(view_name)),
11:       replace(replace) {
12: 	context.TryBindRelation(*this, this->columns);
13: }
14: 
15: unique_ptr<QueryNode> CreateViewRelation::GetQueryNode() {
16: 	throw InternalException("Cannot create a query node from a CreateViewRelation!");
17: }
18: 
19: BoundStatement CreateViewRelation::Bind(Binder &binder) {
20: 	auto select = make_unique<SelectStatement>();
21: 	select->node = child->GetQueryNode();
22: 
23: 	CreateStatement stmt;
24: 	auto info = make_unique<CreateViewInfo>();
25: 	info->query = move(select);
26: 	info->view_name = view_name;
27: 	info->on_conflict = replace ? OnCreateConflict::REPLACE_ON_CONFLICT : OnCreateConflict::ERROR_ON_CONFLICT;
28: 	stmt.info = move(info);
29: 	return binder.Bind((SQLStatement &)stmt);
30: }
31: 
32: const vector<ColumnDefinition> &CreateViewRelation::Columns() {
33: 	return columns;
34: }
35: 
36: string CreateViewRelation::ToString(idx_t depth) {
37: 	string str = RenderWhitespace(depth) + "Create View\n";
38: 	return str + child->ToString(depth + 1);
39: }
40: 
41: } // namespace duckdb
[end of src/main/relation/create_view_relation.cpp]
[start of tools/rpkg/src/duckdbr.cpp]
1: #include "duckdb/common/types/date.hpp"
2: #include "duckdb/common/types/hugeint.hpp"
3: #include "duckdb/common/types/interval.hpp"
4: #include "duckdb/common/types/timestamp.hpp"
5: #include "duckdb/common/unordered_map.hpp"
6: #include "duckdb.hpp"
7: #include "duckdb/main/client_context.hpp"
8: #include "duckdb/main/stream_query_result.hpp"
9: #include "duckdb/transaction/transaction.hpp"
10: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
11: #include "extension/extension_helper.hpp"
12: 
13: #define R_NO_REMAP
14: 
15: #include <Rdefines.h>
16: #include <R_ext/Altrep.h>
17: 
18: #include <algorithm>
19: 
20: using namespace duckdb;
21: using namespace std;
22: 
23: struct RProtector {
24: 	RProtector() : protect_count(0) {
25: 	}
26: 	~RProtector() {
27: 		if (protect_count > 0) {
28: 			UNPROTECT(protect_count);
29: 		}
30: 	}
31: 
32: 	SEXP Protect(SEXP sexp) {
33: 		protect_count++;
34: 		return PROTECT(sexp);
35: 	}
36: 
37: private:
38: 	int protect_count;
39: };
40: 
41: struct RStrings {
42: 	SEXP secs;
43: 	SEXP mins;
44: 	SEXP hours;
45: 	SEXP days;
46: 	SEXP weeks;
47: 
48: 	static const RStrings &get() {
49: 		// On demand
50: 		static RStrings strings;
51: 		return strings;
52: 	}
53: 
54: private:
55: 	RStrings() {
56: 		// allocate strings once
57: 		RProtector r;
58: 
59: 		SEXP out = r.Protect(Rf_allocVector(STRSXP, 5));
60: 		SET_STRING_ELT(out, 0, secs = Rf_mkChar("secs"));
61: 		SET_STRING_ELT(out, 1, mins = Rf_mkChar("mins"));
62: 		SET_STRING_ELT(out, 2, hours = Rf_mkChar("hours"));
63: 		SET_STRING_ELT(out, 3, days = Rf_mkChar("days"));
64: 		SET_STRING_ELT(out, 4, weeks = Rf_mkChar("weeks"));
65: 		R_PreserveObject(out);
66: 		MARK_NOT_MUTABLE(out);
67: 	}
68: };
69: 
70: struct RStatement {
71: 	unique_ptr<PreparedStatement> stmt;
72: 	vector<Value> parameters;
73: };
74: 
75: // converter for primitive types
76: template <class SRC, class DEST>
77: static void vector_to_r(Vector &src_vec, size_t count, void *dest, uint64_t dest_offset, DEST na_val) {
78: 	auto src_ptr = FlatVector::GetData<SRC>(src_vec);
79: 	auto &mask = FlatVector::Validity(src_vec);
80: 	auto dest_ptr = ((DEST *)dest) + dest_offset;
81: 	for (size_t row_idx = 0; row_idx < count; row_idx++) {
82: 		dest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? na_val : src_ptr[row_idx];
83: 	}
84: }
85: 
86: struct RIntegralType {
87: 	template <class T>
88: 	static double DoubleCast(T val) {
89: 		return double(val);
90: 	}
91: };
92: 
93: template <class T>
94: static void RDecimalCastLoop(Vector &src_vec, size_t count, double *dest_ptr, uint8_t scale) {
95: 	auto src_ptr = FlatVector::GetData<T>(src_vec);
96: 	auto &mask = FlatVector::Validity(src_vec);
97: 	double division = pow(10, scale);
98: 	for (size_t row_idx = 0; row_idx < count; row_idx++) {
99: 		dest_ptr[row_idx] =
100: 		    !mask.RowIsValid(row_idx) ? NA_REAL : RIntegralType::DoubleCast<T>(src_ptr[row_idx]) / division;
101: 	}
102: }
103: 
104: template <>
105: double RIntegralType::DoubleCast<>(hugeint_t val) {
106: 	return Hugeint::Cast<double>(val);
107: }
108: 
109: struct RDoubleType {
110: 	static bool IsNull(double val) {
111: 		return ISNA(val);
112: 	}
113: 
114: 	static double Convert(double val) {
115: 		return val;
116: 	}
117: };
118: 
119: struct RDateType : public RDoubleType {
120: 	static double Convert(double val) {
121: 		return (date_t)val;
122: 	}
123: };
124: 
125: struct RTimestampType : public RDoubleType {
126: 	static timestamp_t Convert(double val) {
127: 		return Timestamp::FromEpochSeconds(val);
128: 	}
129: };
130: 
131: struct RTimeSecondsType : public RDoubleType {
132: 	static timestamp_t Convert(double val) {
133: 		dtime_t time = (dtime_t)(val)*Interval::MICROS_PER_SEC;
134: 		return time;
135: 	}
136: };
137: 
138: struct RTimeMinutesType : public RDoubleType {
139: 	static timestamp_t Convert(double val) {
140: 		dtime_t time = (dtime_t)(val)*Interval::MICROS_PER_MINUTE;
141: 		return time;
142: 	}
143: };
144: 
145: struct RTimeHoursType : public RDoubleType {
146: 	static timestamp_t Convert(double val) {
147: 		dtime_t time = (dtime_t)(val)*Interval::MICROS_PER_HOUR;
148: 		return time;
149: 	}
150: };
151: 
152: struct RTimeDaysType : public RDoubleType {
153: 	static timestamp_t Convert(double val) {
154: 		dtime_t time = (dtime_t)(val)*Interval::MICROS_PER_DAY;
155: 		return time;
156: 	}
157: };
158: 
159: struct RTimeWeeksType : public RDoubleType {
160: 	static timestamp_t Convert(double val) {
161: 		dtime_t time = (dtime_t)(val)*Interval::MICROS_PER_DAY * 7;
162: 		return time;
163: 	}
164: };
165: 
166: struct RIntegerType {
167: 	static bool IsNull(int val) {
168: 		return val == NA_INTEGER;
169: 	}
170: 
171: 	static int Convert(int val) {
172: 		return val;
173: 	}
174: };
175: 
176: struct RBooleanType : public RIntegerType {
177: 	static bool Convert(int val) {
178: 		return val;
179: 	}
180: };
181: 
182: template <class SRC, class DST, class RTYPE>
183: static void AppendColumnSegment(SRC *source_data, Vector &result, idx_t count) {
184: 	auto result_data = FlatVector::GetData<DST>(result);
185: 	auto &result_mask = FlatVector::Validity(result);
186: 	for (idx_t i = 0; i < count; i++) {
187: 		auto val = source_data[i];
188: 		if (RTYPE::IsNull(val)) {
189: 			result_mask.SetInvalid(i);
190: 		} else {
191: 			result_data[i] = RTYPE::Convert(val);
192: 		}
193: 	}
194: }
195: 
196: static void AppendStringSegment(SEXP coldata, Vector &result, idx_t row_idx, idx_t count) {
197: 	auto result_data = FlatVector::GetData<string_t>(result);
198: 	auto &result_mask = FlatVector::Validity(result);
199: 	for (idx_t i = 0; i < count; i++) {
200: 		SEXP val = STRING_ELT(coldata, row_idx + i);
201: 		if (val == NA_STRING) {
202: 			result_mask.SetInvalid(i);
203: 		} else {
204: 			result_data[i] = string_t((char *)CHAR(val));
205: 		}
206: 	}
207: }
208: 
209: static void AppendFactor(SEXP coldata, Vector &result, idx_t row_idx, idx_t count) {
210: 	auto source_data = INTEGER_POINTER(coldata) + row_idx;
211: 	auto result_data = FlatVector::GetData<string_t>(result);
212: 	auto &result_mask = FlatVector::Validity(result);
213: 	SEXP factor_levels = GET_LEVELS(coldata);
214: 	for (idx_t i = 0; i < count; i++) {
215: 		int val = source_data[i];
216: 		if (RIntegerType::IsNull(val)) {
217: 			result_mask.SetInvalid(i);
218: 		} else {
219: 			result_data[i] = string_t(CHAR(STRING_ELT(factor_levels, val - 1)));
220: 		}
221: 	}
222: }
223: 
224: static SEXP cstr_to_charsexp(const char *s) {
225: 	return Rf_mkCharCE(s, CE_UTF8);
226: }
227: 
228: static SEXP cpp_str_to_charsexp(string s) {
229: 	return cstr_to_charsexp(s.c_str());
230: }
231: 
232: static SEXP cpp_str_to_strsexp(vector<string> s) {
233: 	RProtector r;
234: 	SEXP retsexp = r.Protect(NEW_STRING(s.size()));
235: 	for (idx_t i = 0; i < s.size(); i++) {
236: 		SET_STRING_ELT(retsexp, i, cpp_str_to_charsexp(s[i]));
237: 	}
238: 	return retsexp;
239: }
240: 
241: enum class RType {
242: 	UNKNOWN,
243: 	LOGICAL,
244: 	INTEGER,
245: 	NUMERIC,
246: 	STRING,
247: 	FACTOR,
248: 	DATE,
249: 	TIMESTAMP,
250: 	TIME_SECONDS,
251: 	TIME_MINUTES,
252: 	TIME_HOURS,
253: 	TIME_DAYS,
254: 	TIME_WEEKS
255: };
256: 
257: static RType detect_rtype(SEXP v) {
258: 	if (TYPEOF(v) == REALSXP && Rf_inherits(v, "POSIXct")) {
259: 		return RType::TIMESTAMP;
260: 	} else if (TYPEOF(v) == REALSXP && Rf_inherits(v, "Date")) {
261: 		return RType::DATE;
262: 	} else if (TYPEOF(v) == REALSXP && Rf_inherits(v, "difftime")) {
263: 		SEXP units = Rf_getAttrib(v, Rf_install("units"));
264: 		if (TYPEOF(units) != STRSXP) {
265: 			return RType::UNKNOWN;
266: 		}
267: 		SEXP units0 = STRING_ELT(units, 0);
268: 		if (units0 == RStrings::get().secs) {
269: 			return RType::TIME_SECONDS;
270: 		} else if (units0 == RStrings::get().mins) {
271: 			return RType::TIME_MINUTES;
272: 		} else if (units0 == RStrings::get().hours) {
273: 			return RType::TIME_HOURS;
274: 		} else if (units0 == RStrings::get().days) {
275: 			return RType::TIME_DAYS;
276: 		} else if (units0 == RStrings::get().weeks) {
277: 			return RType::TIME_WEEKS;
278: 		} else {
279: 			return RType::UNKNOWN;
280: 		}
281: 	} else if (Rf_isFactor(v) && TYPEOF(v) == INTSXP) {
282: 		return RType::FACTOR;
283: 	} else if (TYPEOF(v) == LGLSXP) {
284: 		return RType::LOGICAL;
285: 	} else if (TYPEOF(v) == INTSXP) {
286: 		return RType::INTEGER;
287: 	} else if (TYPEOF(v) == REALSXP) {
288: 		return RType::NUMERIC;
289: 	} else if (TYPEOF(v) == STRSXP) {
290: 		return RType::STRING;
291: 	}
292: 	return RType::UNKNOWN;
293: }
294: 
295: static R_altrep_class_t duckdb_altrep_string_class;
296: 
297: struct DuckDBAltrepStringWrapper {
298: 	vector<Vector> vectors;
299: 	idx_t length;
300: };
301: 
302: static DuckDBAltrepStringWrapper *duckdb_altrep_wrapper(SEXP x) {
303: 	auto wrapper = (DuckDBAltrepStringWrapper *)R_ExternalPtrAddr(R_altrep_data1(x));
304: 	if (!wrapper) {
305: 		Rf_error("This looks like it has been freed");
306: 	}
307: 	return wrapper;
308: }
309: 
310: static R_xlen_t duckdb_altrep_strings_length(SEXP x) {
311: 	return duckdb_altrep_wrapper(x)->length;
312: }
313: 
314: static Rboolean duckdb_altrep_strings_inspect(SEXP x, int pre, int deep, int pvec,
315:                                               void (*inspect_subtree)(SEXP, int, int, int)) {
316: 	Rprintf("DUCKDB_STRING_COLUMN %llu\n", duckdb_altrep_strings_length(x));
317: 	return TRUE;
318: }
319: 
320: static void *duckdb_altrep_strings_dataptr(SEXP x, Rboolean writeable) {
321: 	auto *wrapper = duckdb_altrep_wrapper(x);
322: 	if (R_altrep_data2(x) == R_NilValue) {
323: 		R_set_altrep_data2(x, NEW_STRING(wrapper->length));
324: 		idx_t dest_offset = 0;
325: 		for (auto &vec : wrapper->vectors) {
326: 			auto src_ptr = FlatVector::GetData<string_t>(vec);
327: 			auto &mask = FlatVector::Validity(vec);
328: 			for (size_t row_idx = 0; row_idx < MinValue<idx_t>(STANDARD_VECTOR_SIZE, wrapper->length - dest_offset);
329: 			     row_idx++) {
330: 				if (!mask.RowIsValid(row_idx)) {
331: 					SET_STRING_ELT(R_altrep_data2(x), dest_offset + row_idx, NA_STRING);
332: 				} else {
333: 					SET_STRING_ELT(
334: 					    R_altrep_data2(x), dest_offset + row_idx,
335: 					    Rf_mkCharLenCE(src_ptr[row_idx].GetDataUnsafe(), src_ptr[row_idx].GetSize(), CE_UTF8));
336: 				}
337: 			}
338: 			dest_offset += STANDARD_VECTOR_SIZE;
339: 		}
340: 	}
341: 	return CHARACTER_POINTER(R_altrep_data2(x));
342: }
343: 
344: static const void *duckdb_altrep_strings_dataptr_or_null(SEXP x) {
345: 	return nullptr;
346: }
347: 
348: static SEXP duckdb_altrep_strings_elt(SEXP x, R_xlen_t i) {
349: 	auto *wrapper = duckdb_altrep_wrapper(x);
350: 	if (R_altrep_data2(x) != R_NilValue) {
351: 		return STRING_ELT(R_altrep_data2(x), i);
352: 	}
353: 	auto &vec = wrapper->vectors[i / STANDARD_VECTOR_SIZE];
354: 	auto src_ptr = FlatVector::GetData<string_t>(vec);
355: 	auto &mask = FlatVector::Validity(vec);
356: 	auto vec_idx = i % STANDARD_VECTOR_SIZE;
357: 	if (!mask.RowIsValid(vec_idx)) {
358: 		return NA_STRING;
359: 	}
360: 	return Rf_mkCharLenCE(src_ptr[vec_idx].GetDataUnsafe(), src_ptr[vec_idx].GetSize(), CE_UTF8);
361: }
362: 
363: static void duckdb_altrep_strings_set_elt(SEXP x, R_xlen_t i, SEXP val) {
364: 	duckdb_altrep_strings_dataptr(x, TRUE);
365: 	SET_STRING_ELT(R_altrep_data2(x), i, val);
366: }
367: 
368: static int duckdb_altrep_strings_is_sorted(SEXP x) {
369: 	// we don't know
370: 	return 0;
371: }
372: 
373: static int duckdb_altrep_strings_no_na(SEXP x) {
374: 	// we kinda know but it matters little
375: 	return 0;
376: }
377: 
378: static void duckdb_altrep_strings_finalizer(SEXP x) {
379: 	auto *wrapper = (DuckDBAltrepStringWrapper *)R_ExternalPtrAddr(x);
380: 	if (wrapper) {
381: 		R_ClearExternalPtr(x);
382: 		delete wrapper;
383: 	}
384: }
385: 
386: extern "C" {
387: 
388: SEXP duckdb_release_R(SEXP stmtsexp) {
389: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
390: 		Rf_error("duckdb_release_R: Need external pointer parameter");
391: 	}
392: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
393: 	if (stmtsexp) {
394: 		R_ClearExternalPtr(stmtsexp);
395: 		delete stmtholder;
396: 	}
397: 	return R_NilValue;
398: }
399: 
400: SEXP duckdb_finalize_statement_R(SEXP stmtsexp) {
401: 	return duckdb_release_R(stmtsexp);
402: }
403: 
404: SEXP duckdb_prepare_R(SEXP connsexp, SEXP querysexp) {
405: 	RProtector r;
406: 	if (TYPEOF(querysexp) != STRSXP || Rf_length(querysexp) != 1) {
407: 		Rf_error("duckdb_prepare_R: Need single string parameter for query");
408: 	}
409: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
410: 		Rf_error("duckdb_prepare_R: Need external pointer parameter for connections");
411: 	}
412: 
413: 	char *query = (char *)CHAR(STRING_ELT(querysexp, 0));
414: 	if (!query) {
415: 		Rf_error("duckdb_prepare_R: No query");
416: 	}
417: 
418: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
419: 	if (!conn) {
420: 		Rf_error("duckdb_prepare_R: Invalid connection");
421: 	}
422: 
423: 	auto stmt = conn->Prepare(query);
424: 	if (!stmt->success) {
425: 		Rf_error("duckdb_prepare_R: Failed to prepare query %s\nError: %s", query, stmt->error.c_str());
426: 	}
427: 
428: 	auto stmtholder = new RStatement();
429: 	stmtholder->stmt = move(stmt);
430: 
431: 	SEXP retlist = r.Protect(NEW_LIST(6));
432: 
433: 	SEXP stmtsexp = r.Protect(R_MakeExternalPtr(stmtholder, R_NilValue, R_NilValue));
434: 	R_RegisterCFinalizer(stmtsexp, (void (*)(SEXP))duckdb_finalize_statement_R);
435: 
436: 	SEXP ret_names = cpp_str_to_strsexp({"str", "ref", "type", "names", "rtypes", "n_param"});
437: 	SET_NAMES(retlist, ret_names);
438: 
439: 	SET_VECTOR_ELT(retlist, 0, querysexp);
440: 	SET_VECTOR_ELT(retlist, 1, stmtsexp);
441: 
442: 	SEXP stmt_type = cpp_str_to_strsexp({StatementTypeToString(stmtholder->stmt->GetStatementType())});
443: 	SET_VECTOR_ELT(retlist, 2, stmt_type);
444: 
445: 	SEXP col_names = cpp_str_to_strsexp(stmtholder->stmt->GetNames());
446: 	SET_VECTOR_ELT(retlist, 3, col_names);
447: 
448: 	vector<string> rtypes;
449: 
450: 	for (auto &stype : stmtholder->stmt->GetTypes()) {
451: 		string rtype = "";
452: 		switch (stype.id()) {
453: 		case LogicalTypeId::BOOLEAN:
454: 			rtype = "logical";
455: 			break;
456: 		case LogicalTypeId::TINYINT:
457: 		case LogicalTypeId::SMALLINT:
458: 		case LogicalTypeId::INTEGER:
459: 			rtype = "integer";
460: 			break;
461: 		case LogicalTypeId::TIMESTAMP:
462: 			rtype = "POSIXct";
463: 			break;
464: 		case LogicalTypeId::DATE:
465: 			rtype = "Date";
466: 			break;
467: 		case LogicalTypeId::TIME:
468: 			rtype = "difftime";
469: 			break;
470: 		case LogicalTypeId::BIGINT:
471: 		case LogicalTypeId::HUGEINT:
472: 		case LogicalTypeId::FLOAT:
473: 		case LogicalTypeId::DOUBLE:
474: 		case LogicalTypeId::DECIMAL:
475: 			rtype = "numeric";
476: 			break;
477: 		case LogicalTypeId::VARCHAR:
478: 			rtype = "character";
479: 			break;
480: 		case LogicalTypeId::BLOB:
481: 			rtype = "raw";
482: 			break;
483: 		default:
484: 			Rf_error("duckdb_prepare_R: Unknown column type for prepare: %s", stype.ToString().c_str());
485: 			break;
486: 		}
487: 		rtypes.push_back(rtype);
488: 	}
489: 
490: 	SEXP rtypessexp = cpp_str_to_strsexp(rtypes);
491: 	SET_VECTOR_ELT(retlist, 4, rtypessexp);
492: 
493: 	SET_VECTOR_ELT(retlist, 5, Rf_ScalarInteger(stmtholder->stmt->n_param));
494: 
495: 	return retlist;
496: }
497: 
498: SEXP duckdb_bind_R(SEXP stmtsexp, SEXP paramsexp) {
499: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
500: 		Rf_error("duckdb_bind_R: Need external pointer parameter");
501: 	}
502: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
503: 	if (!stmtholder || !stmtholder->stmt) {
504: 		Rf_error("duckdb_bind_R: Invalid statement");
505: 	}
506: 
507: 	stmtholder->parameters.clear();
508: 	stmtholder->parameters.resize(stmtholder->stmt->n_param);
509: 
510: 	if (stmtholder->stmt->n_param == 0) {
511: 		Rf_error("duckdb_bind_R: dbBind called but query takes no parameters");
512: 		return R_NilValue;
513: 	}
514: 
515: 	if (TYPEOF(paramsexp) != VECSXP || (idx_t)Rf_length(paramsexp) != stmtholder->stmt->n_param) {
516: 		Rf_error("duckdb_bind_R: bind parameters need to be a list of length %i", stmtholder->stmt->n_param);
517: 	}
518: 
519: 	for (idx_t param_idx = 0; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {
520: 		Value val;
521: 		SEXP valsexp = VECTOR_ELT(paramsexp, param_idx);
522: 		if (Rf_length(valsexp) != 1) {
523: 			Rf_error("duckdb_bind_R: bind parameter values need to have length 1");
524: 		}
525: 		auto rtype = detect_rtype(valsexp);
526: 		switch (rtype) {
527: 		case RType::LOGICAL: {
528: 			auto lgl_val = INTEGER_POINTER(valsexp)[0];
529: 			val = Value::BOOLEAN(lgl_val);
530: 			val.is_null = RBooleanType::IsNull(lgl_val);
531: 			break;
532: 		}
533: 		case RType::INTEGER: {
534: 			auto int_val = INTEGER_POINTER(valsexp)[0];
535: 			val = Value::INTEGER(int_val);
536: 			val.is_null = RIntegerType::IsNull(int_val);
537: 			break;
538: 		}
539: 		case RType::NUMERIC: {
540: 			auto dbl_val = NUMERIC_POINTER(valsexp)[0];
541: 			val = Value::DOUBLE(dbl_val);
542: 			val.is_null = RDoubleType::IsNull(dbl_val);
543: 			break;
544: 		}
545: 		case RType::STRING: {
546: 			auto str_val = STRING_ELT(valsexp, 0);
547: 			val = Value(CHAR(str_val));
548: 			val.is_null = str_val == NA_STRING;
549: 			break;
550: 		}
551: 		case RType::FACTOR: {
552: 			auto int_val = INTEGER_POINTER(valsexp)[0];
553: 			auto levels = GET_LEVELS(valsexp);
554: 			bool is_null = RIntegerType::IsNull(int_val);
555: 			if (!is_null) {
556: 				auto str_val = STRING_ELT(levels, int_val - 1);
557: 				val = Value(CHAR(str_val));
558: 			} else {
559: 				val = Value(LogicalType::VARCHAR);
560: 			}
561: 			break;
562: 		}
563: 		case RType::TIMESTAMP: {
564: 			auto ts_val = NUMERIC_POINTER(valsexp)[0];
565: 			val = Value::TIMESTAMP(RTimestampType::Convert(ts_val));
566: 			val.is_null = RTimestampType::IsNull(ts_val);
567: 			break;
568: 		}
569: 		case RType::DATE: {
570: 			auto d_val = NUMERIC_POINTER(valsexp)[0];
571: 			val = Value::DATE(RDateType::Convert(d_val));
572: 			val.is_null = RDateType::IsNull(d_val);
573: 			break;
574: 		}
575: 		case RType::TIME_SECONDS: {
576: 			auto ts_val = NUMERIC_POINTER(valsexp)[0];
577: 			val = Value::TIME(RTimeSecondsType::Convert(ts_val));
578: 			val.is_null = RTimeSecondsType::IsNull(ts_val);
579: 			break;
580: 		}
581: 		case RType::TIME_MINUTES: {
582: 			auto ts_val = NUMERIC_POINTER(valsexp)[0];
583: 			val = Value::TIME(RTimeMinutesType::Convert(ts_val));
584: 			val.is_null = RTimeMinutesType::IsNull(ts_val);
585: 			break;
586: 		}
587: 		case RType::TIME_HOURS: {
588: 			auto ts_val = NUMERIC_POINTER(valsexp)[0];
589: 			val = Value::TIME(RTimeHoursType::Convert(ts_val));
590: 			val.is_null = RTimeHoursType::IsNull(ts_val);
591: 			break;
592: 		}
593: 		case RType::TIME_DAYS: {
594: 			auto ts_val = NUMERIC_POINTER(valsexp)[0];
595: 			val = Value::TIME(RTimeDaysType::Convert(ts_val));
596: 			val.is_null = RTimeDaysType::IsNull(ts_val);
597: 			break;
598: 		}
599: 		case RType::TIME_WEEKS: {
600: 			auto ts_val = NUMERIC_POINTER(valsexp)[0];
601: 			val = Value::TIME(RTimeWeeksType::Convert(ts_val));
602: 			val.is_null = RTimeWeeksType::IsNull(ts_val);
603: 			break;
604: 		}
605: 		default:
606: 			Rf_error("duckdb_bind_R: Unsupported parameter type");
607: 		}
608: 		stmtholder->parameters[param_idx] = val;
609: 	}
610: 	return R_NilValue;
611: }
612: 
613: SEXP duckdb_execute_R_impl(MaterializedQueryResult *result);
614: 
615: SEXP duckdb_execute_R(SEXP stmtsexp) {
616: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
617: 		Rf_error("duckdb_execute_R: Need external pointer parameter");
618: 	}
619: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
620: 	if (!stmtholder || !stmtholder->stmt) {
621: 		Rf_error("duckdb_execute_R: Invalid statement");
622: 	}
623: 
624: 	RProtector r;
625: 	SEXP out;
626: 
627: 	{
628: 		auto generic_result = stmtholder->stmt->Execute(stmtholder->parameters, false);
629: 
630: 		if (!generic_result->success) {
631: 			Rf_error("duckdb_execute_R: Failed to run query\nError: %s", generic_result->error.c_str());
632: 		}
633: 		D_ASSERT(generic_result->type == QueryResultType::MATERIALIZED_RESULT);
634: 		MaterializedQueryResult *result = (MaterializedQueryResult *)generic_result.get();
635: 
636: 		// Protect during destruction of generic_result
637: 		out = r.Protect(duckdb_execute_R_impl(result));
638: 	}
639: 
640: 	return out;
641: }
642: 
643: SEXP duckdb_execute_R_impl(MaterializedQueryResult *result) {
644: 	RProtector r;
645: 	// step 2: create result data frame and allocate columns
646: 	uint32_t ncols = result->types.size();
647: 	if (ncols == 0) {
648: 		return Rf_ScalarReal(0); // no need for protection because no allocation can happen afterwards
649: 	}
650: 
651: 	uint64_t nrows = result->collection.Count();
652: 	SEXP retlist = r.Protect(NEW_LIST(ncols));
653: 	SET_NAMES(retlist, cpp_str_to_strsexp(result->names));
654: 
655: 	for (size_t col_idx = 0; col_idx < ncols; col_idx++) {
656: 		RProtector r_varvalue;
657: 
658: 		SEXP varvalue = NULL;
659: 		switch (result->types[col_idx].id()) {
660: 		case LogicalTypeId::BOOLEAN:
661: 			varvalue = r_varvalue.Protect(NEW_LOGICAL(nrows));
662: 			break;
663: 		case LogicalTypeId::TINYINT:
664: 		case LogicalTypeId::SMALLINT:
665: 		case LogicalTypeId::INTEGER:
666: 			varvalue = r_varvalue.Protect(NEW_INTEGER(nrows));
667: 			break;
668: 		case LogicalTypeId::BIGINT:
669: 		case LogicalTypeId::HUGEINT:
670: 		case LogicalTypeId::FLOAT:
671: 		case LogicalTypeId::DOUBLE:
672: 		case LogicalTypeId::DECIMAL:
673: 		case LogicalTypeId::TIMESTAMP:
674: 		case LogicalTypeId::DATE:
675: 		case LogicalTypeId::TIME:
676: 			varvalue = r_varvalue.Protect(NEW_NUMERIC(nrows));
677: 			break;
678: 		case LogicalTypeId::VARCHAR: {
679: 			auto wrapper = new DuckDBAltrepStringWrapper();
680: 			wrapper->length = nrows;
681: 			wrapper->vectors.resize(result->collection.Chunks().size());
682: 
683: 			auto ptr = PROTECT(R_MakeExternalPtr((void *)wrapper, R_NilValue, R_NilValue));
684: 			R_RegisterCFinalizer(ptr, duckdb_altrep_strings_finalizer);
685: 			varvalue = r_varvalue.Protect(R_new_altrep(duckdb_altrep_string_class, ptr, R_NilValue));
686: 			UNPROTECT(1);
687: 			break;
688: 		}
689: 
690: 		case LogicalTypeId::BLOB:
691: 			varvalue = r_varvalue.Protect(NEW_LIST(nrows));
692: 			break;
693: 		default:
694: 			Rf_error("duckdb_execute_R: Unknown column type for execute: %s",
695: 			         result->types[col_idx].ToString().c_str());
696: 		}
697: 		if (!varvalue) {
698: 			throw std::bad_alloc();
699: 		}
700: 		SET_VECTOR_ELT(retlist, col_idx, varvalue);
701: 	}
702: 
703: 	// at this point retlist is fully allocated and the only protected SEXP
704: 
705: 	// step 3: set values from chunks
706: 	uint64_t dest_offset = 0;
707: 	idx_t chunk_idx = 0;
708: 	while (true) {
709: 		auto chunk = result->Fetch();
710: 		if (!chunk || chunk->size() == 0) {
711: 			break;
712: 		}
713: 
714: 		D_ASSERT(chunk->ColumnCount() == ncols);
715: 		D_ASSERT(chunk->ColumnCount() == (idx_t)Rf_length(retlist));
716: 		for (size_t col_idx = 0; col_idx < chunk->ColumnCount(); col_idx++) {
717: 			SEXP dest = VECTOR_ELT(retlist, col_idx);
718: 			switch (result->types[col_idx].id()) {
719: 			case LogicalTypeId::BOOLEAN:
720: 				vector_to_r<int8_t, uint32_t>(chunk->data[col_idx], chunk->size(), LOGICAL_POINTER(dest), dest_offset,
721: 				                              NA_LOGICAL);
722: 				break;
723: 			case LogicalTypeId::TINYINT:
724: 				vector_to_r<int8_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest), dest_offset,
725: 				                              NA_INTEGER);
726: 				break;
727: 			case LogicalTypeId::SMALLINT:
728: 				vector_to_r<int16_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest), dest_offset,
729: 				                               NA_INTEGER);
730: 				break;
731: 			case LogicalTypeId::INTEGER:
732: 				vector_to_r<int32_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest), dest_offset,
733: 				                               NA_INTEGER);
734: 				break;
735: 			case LogicalTypeId::TIMESTAMP: {
736: 				auto &src_vec = chunk->data[col_idx];
737: 				auto src_data = FlatVector::GetData<timestamp_t>(src_vec);
738: 				auto &mask = FlatVector::Validity(src_vec);
739: 				double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
740: 				for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
741: 					dest_ptr[row_idx] =
742: 					    !mask.RowIsValid(row_idx) ? NA_REAL : (double)Timestamp::GetEpochSeconds(src_data[row_idx]);
743: 				}
744: 
745: 				// some dresssup for R
746: 				RProtector r_ts;
747: 				SEXP cl = r_ts.Protect(NEW_STRING(2));
748: 				SET_STRING_ELT(cl, 0, r_ts.Protect(Rf_mkChar("POSIXct")));
749: 				SET_STRING_ELT(cl, 1, r_ts.Protect(Rf_mkChar("POSIXt")));
750: 				SET_CLASS(dest, cl);
751: 				Rf_setAttrib(dest, Rf_install("tzone"), r_ts.Protect(Rf_mkString("UTC")));
752: 				break;
753: 			}
754: 			case LogicalTypeId::DATE: {
755: 				auto &src_vec = chunk->data[col_idx];
756: 				auto src_data = FlatVector::GetData<date_t>(src_vec);
757: 				auto &mask = FlatVector::Validity(src_vec);
758: 				double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
759: 				for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
760: 					dest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? NA_REAL : (double)(src_data[row_idx]);
761: 				}
762: 
763: 				// some dresssup for R
764: 				RProtector r_date;
765: 				SET_CLASS(dest, r_date.Protect(Rf_mkString("Date")));
766: 				break;
767: 			}
768: 			case LogicalTypeId::TIME: {
769: 				auto &src_vec = chunk->data[col_idx];
770: 				auto src_data = FlatVector::GetData<dtime_t>(src_vec);
771: 				auto &mask = FlatVector::Validity(src_vec);
772: 				double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
773: 				for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
774: 					if (!mask.RowIsValid(row_idx)) {
775: 						dest_ptr[row_idx] = NA_REAL;
776: 					} else {
777: 						dtime_t n = src_data[row_idx];
778: 						dest_ptr[row_idx] = n / 1000000.0;
779: 					}
780: 				}
781: 
782: 				// some dresssup for R
783: 				RProtector r_time;
784: 				SET_CLASS(dest, r_time.Protect(Rf_mkString("difftime")));
785: 				Rf_setAttrib(dest, Rf_install("units"), r_time.Protect(Rf_mkString("secs")));
786: 				break;
787: 			}
788: 			case LogicalTypeId::BIGINT:
789: 				vector_to_r<int64_t, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
790: 				                             NA_REAL);
791: 				break;
792: 			case LogicalTypeId::HUGEINT: {
793: 				auto &src_vec = chunk->data[col_idx];
794: 				auto src_data = FlatVector::GetData<hugeint_t>(src_vec);
795: 				auto &mask = FlatVector::Validity(src_vec);
796: 				double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
797: 				for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
798: 					if (!mask.RowIsValid(row_idx)) {
799: 						dest_ptr[row_idx] = NA_REAL;
800: 					} else {
801: 						Hugeint::TryCast(src_data[row_idx], dest_ptr[row_idx]);
802: 					}
803: 				}
804: 				break;
805: 			}
806: 			case LogicalTypeId::DECIMAL: {
807: 				auto &src_vec = chunk->data[col_idx];
808: 				auto &decimal_type = result->types[col_idx];
809: 				double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
810: 				auto dec_scale = decimal_type.scale();
811: 				switch (decimal_type.InternalType()) {
812: 				case PhysicalType::INT16:
813: 					RDecimalCastLoop<int16_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
814: 					break;
815: 				case PhysicalType::INT32:
816: 					RDecimalCastLoop<int32_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
817: 					break;
818: 				case PhysicalType::INT64:
819: 					RDecimalCastLoop<int64_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
820: 					break;
821: 				case PhysicalType::INT128:
822: 					RDecimalCastLoop<hugeint_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
823: 					break;
824: 				default:
825: 					throw NotImplementedException("Unimplemented internal type for DECIMAL");
826: 				}
827: 				break;
828: 			}
829: 			case LogicalTypeId::FLOAT:
830: 				vector_to_r<float, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
831: 				                           NA_REAL);
832: 				break;
833: 
834: 			case LogicalTypeId::DOUBLE:
835: 				vector_to_r<double, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
836: 				                            NA_REAL);
837: 				break;
838: 			case LogicalTypeId::VARCHAR: {
839: 				auto wrapper = (DuckDBAltrepStringWrapper *)R_ExternalPtrAddr(R_altrep_data1(dest));
840: 				wrapper->vectors[chunk_idx].Reference(chunk->data[col_idx]);
841: 				break;
842: 			}
843: 			case LogicalTypeId::BLOB: {
844: 				auto src_ptr = FlatVector::GetData<string_t>(chunk->data[col_idx]);
845: 				auto &mask = FlatVector::Validity(chunk->data[col_idx]);
846: 				for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
847: 					if (!mask.RowIsValid(row_idx)) {
848: 						SET_VECTOR_ELT(dest, dest_offset + row_idx, Rf_ScalarLogical(NA_LOGICAL));
849: 					} else {
850: 						SEXP rawval = NEW_RAW(src_ptr[row_idx].GetSize());
851: 						if (!rawval) {
852: 							throw std::bad_alloc();
853: 						}
854: 						memcpy(RAW_POINTER(rawval), src_ptr[row_idx].GetDataUnsafe(), src_ptr[row_idx].GetSize());
855: 						SET_VECTOR_ELT(dest, dest_offset + row_idx, rawval);
856: 					}
857: 				}
858: 				break;
859: 			}
860: 			default:
861: 				Rf_error("duckdb_execute_R: Unknown column type for convert: %s",
862: 				         chunk->GetTypes()[col_idx].ToString().c_str());
863: 				break;
864: 			}
865: 		}
866: 		dest_offset += chunk->size();
867: 		chunk_idx++;
868: 	}
869: 
870: 	D_ASSERT(dest_offset == nrows);
871: 	return retlist;
872: }
873: 
874: static SEXP duckdb_finalize_database_R(SEXP dbsexp) {
875: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
876: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
877: 	}
878: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
879: 	if (dbaddr) {
880: 		Rf_warning("duckdb_finalize_database_R: Database is garbage-collected, use dbDisconnect(con, shutdown=TRUE) or "
881: 		           "duckdb::duckdb_shutdown(drv) to avoid this.");
882: 		R_ClearExternalPtr(dbsexp);
883: 		delete dbaddr;
884: 	}
885: 	return R_NilValue;
886: }
887: 
888: struct DataFrameScanFunctionData : public TableFunctionData {
889: 	DataFrameScanFunctionData(SEXP df, idx_t row_count, vector<RType> rtypes)
890: 	    : df(df), row_count(row_count), rtypes(rtypes) {
891: 	}
892: 	SEXP df;
893: 	idx_t row_count;
894: 	vector<RType> rtypes;
895: };
896: 
897: struct DataFrameScanState : public FunctionOperatorData {
898: 	DataFrameScanState() : position(0) {
899: 	}
900: 
901: 	idx_t position;
902: };
903: 
904: struct DataFrameScanFunction : public TableFunction {
905: 	DataFrameScanFunction()
906: 	    : TableFunction("r_dataframe_scan", {LogicalType::POINTER}, dataframe_scan_function, dataframe_scan_bind,
907: 	                    dataframe_scan_init, nullptr, nullptr, nullptr, dataframe_scan_cardinality) {};
908: 
909: 	static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> &inputs,
910: 	                                                    unordered_map<string, Value> &named_parameters,
911: 	                                                    vector<LogicalType> &return_types, vector<string> &names) {
912: 		RProtector r;
913: 		SEXP df((SEXP)inputs[0].GetValue<uintptr_t>());
914: 
915: 		auto df_names = r.Protect(GET_NAMES(df));
916: 		vector<RType> rtypes;
917: 
918: 		for (idx_t col_idx = 0; col_idx < (idx_t)Rf_length(df); col_idx++) {
919: 			names.push_back(string(CHAR(STRING_ELT(df_names, col_idx))));
920: 			SEXP coldata = VECTOR_ELT(df, col_idx);
921: 			rtypes.push_back(detect_rtype(coldata));
922: 			LogicalType duckdb_col_type;
923: 			switch (rtypes[col_idx]) {
924: 			case RType::LOGICAL:
925: 				duckdb_col_type = LogicalType::BOOLEAN;
926: 				break;
927: 			case RType::INTEGER:
928: 				duckdb_col_type = LogicalType::INTEGER;
929: 				break;
930: 			case RType::NUMERIC:
931: 				duckdb_col_type = LogicalType::DOUBLE;
932: 				break;
933: 			case RType::FACTOR:
934: 			case RType::STRING:
935: 				duckdb_col_type = LogicalType::VARCHAR;
936: 				break;
937: 			case RType::TIMESTAMP:
938: 				duckdb_col_type = LogicalType::TIMESTAMP;
939: 				break;
940: 			case RType::TIME_SECONDS:
941: 			case RType::TIME_MINUTES:
942: 			case RType::TIME_HOURS:
943: 			case RType::TIME_DAYS:
944: 			case RType::TIME_WEEKS:
945: 				duckdb_col_type = LogicalType::TIME;
946: 				break;
947: 			case RType::DATE:
948: 				duckdb_col_type = LogicalType::DATE;
949: 				break;
950: 			default:
951: 				Rf_error("Unsupported column type for scan");
952: 			}
953: 			return_types.push_back(duckdb_col_type);
954: 		}
955: 
956: 		auto row_count = Rf_length(VECTOR_ELT(df, 0));
957: 		return make_unique<DataFrameScanFunctionData>(df, row_count, rtypes);
958: 	}
959: 
960: 	static unique_ptr<FunctionOperatorData> dataframe_scan_init(ClientContext &context, const FunctionData *bind_data,
961: 	                                                            vector<column_t> &column_ids,
962: 	                                                            TableFilterCollection *filters) {
963: 		return make_unique<DataFrameScanState>();
964: 	}
965: 
966: 	static void dataframe_scan_function(ClientContext &context, const FunctionData *bind_data,
967: 	                                    FunctionOperatorData *operator_state, DataChunk &output) {
968: 		auto &data = (DataFrameScanFunctionData &)*bind_data;
969: 		auto &state = (DataFrameScanState &)*operator_state;
970: 		if (state.position >= data.row_count) {
971: 			return;
972: 		}
973: 		idx_t this_count = std::min((idx_t)STANDARD_VECTOR_SIZE, data.row_count - state.position);
974: 
975: 		output.SetCardinality(this_count);
976: 
977: 		// TODO this is quite similar to append, unify!
978: 		for (idx_t col_idx = 0; col_idx < output.ColumnCount(); col_idx++) {
979: 			auto &v = output.data[col_idx];
980: 			SEXP coldata = VECTOR_ELT(data.df, col_idx);
981: 
982: 			switch (data.rtypes[col_idx]) {
983: 			case RType::LOGICAL: {
984: 				auto data_ptr = INTEGER_POINTER(coldata) + state.position;
985: 				AppendColumnSegment<int, bool, RBooleanType>(data_ptr, v, this_count);
986: 				break;
987: 			}
988: 			case RType::INTEGER: {
989: 				auto data_ptr = INTEGER_POINTER(coldata) + state.position;
990: 				AppendColumnSegment<int, int, RIntegerType>(data_ptr, v, this_count);
991: 				break;
992: 			}
993: 			case RType::NUMERIC: {
994: 				auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
995: 				AppendColumnSegment<double, double, RDoubleType>(data_ptr, v, this_count);
996: 				break;
997: 			}
998: 			case RType::STRING:
999: 				AppendStringSegment(coldata, v, state.position, this_count);
1000: 				break;
1001: 			case RType::FACTOR:
1002: 				AppendFactor(coldata, v, state.position, this_count);
1003: 				break;
1004: 			case RType::TIMESTAMP: {
1005: 				auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
1006: 				AppendColumnSegment<double, timestamp_t, RTimestampType>(data_ptr, v, this_count);
1007: 				break;
1008: 			}
1009: 			case RType::TIME_SECONDS: {
1010: 				auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
1011: 				AppendColumnSegment<double, dtime_t, RTimeSecondsType>(data_ptr, v, this_count);
1012: 				break;
1013: 			}
1014: 			case RType::TIME_MINUTES: {
1015: 				auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
1016: 				AppendColumnSegment<double, dtime_t, RTimeMinutesType>(data_ptr, v, this_count);
1017: 				break;
1018: 			}
1019: 			case RType::TIME_HOURS: {
1020: 				auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
1021: 				AppendColumnSegment<double, dtime_t, RTimeHoursType>(data_ptr, v, this_count);
1022: 				break;
1023: 			}
1024: 			case RType::TIME_DAYS: {
1025: 				auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
1026: 				AppendColumnSegment<double, dtime_t, RTimeDaysType>(data_ptr, v, this_count);
1027: 				break;
1028: 			}
1029: 			case RType::TIME_WEEKS: {
1030: 				auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
1031: 				AppendColumnSegment<double, dtime_t, RTimeWeeksType>(data_ptr, v, this_count);
1032: 				break;
1033: 			}
1034: 			case RType::DATE: {
1035: 				auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
1036: 				AppendColumnSegment<double, date_t, RDateType>(data_ptr, v, this_count);
1037: 				break;
1038: 			}
1039: 			default:
1040: 				throw;
1041: 			}
1042: 		}
1043: 
1044: 		state.position += this_count;
1045: 	}
1046: 
1047: 	static unique_ptr<NodeStatistics> dataframe_scan_cardinality(ClientContext &context,
1048: 	                                                             const FunctionData *bind_data) {
1049: 		auto &data = (DataFrameScanFunctionData &)*bind_data;
1050: 		return make_unique<NodeStatistics>(data.row_count, data.row_count);
1051: 	}
1052: };
1053: 
1054: SEXP duckdb_startup_R(SEXP dbdirsexp, SEXP readonlysexp) {
1055: 	if (TYPEOF(dbdirsexp) != STRSXP || Rf_length(dbdirsexp) != 1) {
1056: 		Rf_error("duckdb_startup_R: Need string parameter for dbdir");
1057: 	}
1058: 	char *dbdir = (char *)CHAR(STRING_ELT(dbdirsexp, 0));
1059: 
1060: 	if (TYPEOF(readonlysexp) != LGLSXP || Rf_length(readonlysexp) != 1) {
1061: 		Rf_error("duckdb_startup_R: Need string parameter for read_only");
1062: 	}
1063: 	bool read_only = (bool)LOGICAL_ELT(readonlysexp, 0);
1064: 
1065: 	if (strlen(dbdir) == 0 || strcmp(dbdir, ":memory:") == 0) {
1066: 		dbdir = NULL;
1067: 	}
1068: 
1069: 	DBConfig config;
1070: 	config.access_mode = AccessMode::READ_WRITE;
1071: 	if (read_only) {
1072: 		config.access_mode = AccessMode::READ_ONLY;
1073: 	}
1074: 	DuckDB *dbaddr;
1075: 	try {
1076: 		dbaddr = new DuckDB(dbdir, &config);
1077: 	} catch (exception &e) {
1078: 		Rf_error("duckdb_startup_R: Failed to open database: %s", e.what());
1079: 	}
1080: 	ExtensionHelper::LoadAllExtensions(*dbaddr);
1081: 
1082: 	DataFrameScanFunction scan_fun;
1083: 	CreateTableFunctionInfo info(scan_fun);
1084: 	Connection conn(*dbaddr);
1085: 	auto &context = *conn.context;
1086: 	auto &catalog = Catalog::GetCatalog(context);
1087: 	context.transaction.BeginTransaction();
1088: 	catalog.CreateTableFunction(context, &info);
1089: 	context.transaction.Commit();
1090: 
1091: 	RProtector r;
1092: 
1093: 	SEXP dbsexp = r.Protect(R_MakeExternalPtr(dbaddr, R_NilValue, R_NilValue));
1094: 	R_RegisterCFinalizer(dbsexp, (void (*)(SEXP))duckdb_finalize_database_R);
1095: 	return dbsexp;
1096: }
1097: 
1098: SEXP duckdb_shutdown_R(SEXP dbsexp) {
1099: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
1100: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
1101: 	}
1102: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
1103: 	if (dbaddr) {
1104: 		R_ClearExternalPtr(dbsexp);
1105: 		delete dbaddr;
1106: 	}
1107: 
1108: 	return R_NilValue;
1109: }
1110: 
1111: static SEXP duckdb_finalize_connection_R(SEXP connsexp) {
1112: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
1113: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
1114: 	}
1115: 	Connection *connaddr = (Connection *)R_ExternalPtrAddr(connsexp);
1116: 	if (connaddr) {
1117: 		Rf_warning("duckdb_finalize_connection_R: Connection is garbage-collected, use dbDisconnect() to avoid this.");
1118: 		R_ClearExternalPtr(connsexp);
1119: 		delete connaddr;
1120: 	}
1121: 	return R_NilValue;
1122: }
1123: 
1124: SEXP duckdb_register_R(SEXP connsexp, SEXP namesexp, SEXP valuesexp) {
1125: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
1126: 		Rf_error("duckdb_register_R: Need external pointer parameter for connection");
1127: 	}
1128: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
1129: 	if (!conn) {
1130: 		Rf_error("duckdb_register_R: Invalid connection");
1131: 	}
1132: 	if (TYPEOF(namesexp) != STRSXP || Rf_length(namesexp) != 1) {
1133: 		Rf_error("duckdb_register_R: Need single string parameter for name");
1134: 	}
1135: 	auto name = string(CHAR(STRING_ELT(namesexp, 0)));
1136: 	if (name.empty()) {
1137: 		Rf_error("duckdb_register_R: name parameter cannot be empty");
1138: 	}
1139: 	if (TYPEOF(valuesexp) != VECSXP || Rf_length(valuesexp) < 1 ||
1140: 	    strcmp("data.frame", CHAR(STRING_ELT(GET_CLASS(valuesexp), 0))) != 0) {
1141: 		Rf_error("duckdb_register_R: Need at least one-column data frame parameter for value");
1142: 	}
1143: 	try {
1144: 		conn->TableFunction("r_dataframe_scan", {Value::POINTER((uintptr_t)valuesexp)})->CreateView(name, true);
1145: 		auto key = Rf_install(("_registered_df_" + name).c_str());
1146: 		Rf_setAttrib(connsexp, key, valuesexp);
1147: 	} catch (exception &e) {
1148: 		Rf_error("duckdb_register_R: Failed to register data frame: %s", e.what());
1149: 	}
1150: 	return R_NilValue;
1151: }
1152: 
1153: SEXP duckdb_unregister_R(SEXP connsexp, SEXP namesexp) {
1154: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
1155: 		Rf_error("duckdb_unregister_R: Need external pointer parameter for connection");
1156: 	}
1157: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
1158: 	if (!conn) {
1159: 		Rf_error("duckdb_unregister_R: Invalid connection");
1160: 	}
1161: 	if (TYPEOF(namesexp) != STRSXP || Rf_length(namesexp) != 1) {
1162: 		Rf_error("duckdb_unregister_R: Need single string parameter for name");
1163: 	}
1164: 	auto name = string(CHAR(STRING_ELT(namesexp, 0)));
1165: 	auto key = Rf_install(("_registered_df_" + name).c_str());
1166: 	Rf_setAttrib(connsexp, key, R_NilValue);
1167: 	auto res = conn->Query("DROP VIEW IF EXISTS \"" + name + "\"");
1168: 	if (!res->success) {
1169: 		Rf_error(res->error.c_str());
1170: 	}
1171: 	return R_NilValue;
1172: }
1173: 
1174: SEXP duckdb_connect_R(SEXP dbsexp) {
1175: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
1176: 		Rf_error("duckdb_connect_R: Need external pointer parameter");
1177: 	}
1178: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
1179: 	if (!dbaddr) {
1180: 		Rf_error("duckdb_connect_R: Invalid database reference");
1181: 	}
1182: 
1183: 	RProtector r;
1184: 	SEXP connsexp = r.Protect(R_MakeExternalPtr(new Connection(*dbaddr), R_NilValue, R_NilValue));
1185: 	R_RegisterCFinalizer(connsexp, (void (*)(SEXP))duckdb_finalize_connection_R);
1186: 
1187: 	return connsexp;
1188: }
1189: 
1190: SEXP duckdb_disconnect_R(SEXP connsexp) {
1191: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
1192: 		Rf_error("duckdb_disconnect_R: Need external pointer parameter");
1193: 	}
1194: 	Connection *connaddr = (Connection *)R_ExternalPtrAddr(connsexp);
1195: 	if (connaddr) {
1196: 		R_ClearExternalPtr(connsexp);
1197: 		delete connaddr;
1198: 	}
1199: 	return R_NilValue;
1200: }
1201: 
1202: SEXP duckdb_ptr_to_str(SEXP extptr) {
1203: 	if (TYPEOF(extptr) != EXTPTRSXP) {
1204: 		Rf_error("duckdb_ptr_to_str: Need external pointer parameter");
1205: 	}
1206: 	RProtector r;
1207: 	SEXP ret = r.Protect(NEW_STRING(1));
1208: 	SET_STRING_ELT(ret, 0, NA_STRING);
1209: 	void *ptr = R_ExternalPtrAddr(extptr);
1210: 	if (ptr != NULL) {
1211: 		char buf[100];
1212: 		snprintf(buf, 100, "%p", ptr);
1213: 		SET_STRING_ELT(ret, 0, Rf_mkChar(buf));
1214: 	}
1215: 	return ret;
1216: }
1217: 
1218: // R native routine registration
1219: #define CALLDEF(name, n)                                                                                               \
1220: 	{ #name, (DL_FUNC)&name, n }
1221: static const R_CallMethodDef R_CallDef[] = {CALLDEF(duckdb_startup_R, 2),
1222:                                             CALLDEF(duckdb_connect_R, 1),
1223:                                             CALLDEF(duckdb_prepare_R, 2),
1224:                                             CALLDEF(duckdb_bind_R, 2),
1225:                                             CALLDEF(duckdb_execute_R, 1),
1226:                                             CALLDEF(duckdb_release_R, 1),
1227:                                             CALLDEF(duckdb_register_R, 3),
1228:                                             CALLDEF(duckdb_unregister_R, 2),
1229:                                             CALLDEF(duckdb_disconnect_R, 1),
1230:                                             CALLDEF(duckdb_shutdown_R, 1),
1231:                                             CALLDEF(duckdb_ptr_to_str, 1),
1232: 
1233:                                             {NULL, NULL, 0}};
1234: 
1235: void R_init_duckdb(DllInfo *dll) {
1236: 	R_registerRoutines(dll, NULL, R_CallDef, NULL, NULL);
1237: 	R_useDynamicSymbols(dll, FALSE);
1238: 
1239: 	duckdb_altrep_string_class = R_make_altstring_class("duckdb_strings", "duckdb", dll);
1240: 
1241: 	/* override ALTREP methods */
1242: 	R_set_altrep_Inspect_method(duckdb_altrep_string_class, duckdb_altrep_strings_inspect);
1243: 	R_set_altrep_Length_method(duckdb_altrep_string_class, duckdb_altrep_strings_length);
1244: 
1245: 	/* override ALTVEC methods */
1246: 	R_set_altvec_Dataptr_method(duckdb_altrep_string_class, duckdb_altrep_strings_dataptr);
1247: 	R_set_altvec_Dataptr_or_null_method(duckdb_altrep_string_class, duckdb_altrep_strings_dataptr_or_null);
1248: 
1249: 	/* override ALTSTRING methods */
1250: 	R_set_altstring_Elt_method(duckdb_altrep_string_class, duckdb_altrep_strings_elt);
1251: 	R_set_altstring_Is_sorted_method(duckdb_altrep_string_class, duckdb_altrep_strings_is_sorted);
1252: 	R_set_altstring_No_NA_method(duckdb_altrep_string_class, duckdb_altrep_strings_no_na);
1253: 	R_set_altstring_Set_elt_method(duckdb_altrep_string_class, duckdb_altrep_strings_set_elt);
1254: 
1255: 	// TODO implement SEXP (*R_altvec_Extract_subset_method_t)(SEXP, SEXP, SEXP);
1256: }
1257: }
[end of tools/rpkg/src/duckdbr.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: