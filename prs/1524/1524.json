{
  "repo": "duckdb/duckdb",
  "pull_number": 1524,
  "instance_id": "duckdb__duckdb-1524",
  "issue_numbers": [
    "1503"
  ],
  "base_commit": "7da9ca455dd9468b1e36cddc41e7b69d3553cafa",
  "patch": "diff --git a/extension/parquet/column_reader.cpp b/extension/parquet/column_reader.cpp\nindex d890f34bc382..66390a315b3c 100644\n--- a/extension/parquet/column_reader.cpp\n+++ b/extension/parquet/column_reader.cpp\n@@ -312,7 +312,9 @@ void ColumnReader::Skip(idx_t num_values) {\n \t// TODO this can be optimized, for example we dont actually have to bitunpack offsets\n \tauto values_read =\n \t    Read(num_values, none_filter, (uint8_t *)dummy_define.ptr, (uint8_t *)dummy_repeat.ptr, dummy_result);\n-\tD_ASSERT(values_read == num_values);\n+\tif (values_read != num_values) {\n+\t\tthrow std::runtime_error(\"Row count mismatch when skipping rows\");\n+\t}\n }\n \n void StringColumnReader::VerifyString(const char *str_data, idx_t str_len) {\ndiff --git a/extension/parquet/include/column_reader.hpp b/extension/parquet/include/column_reader.hpp\nindex b50e5298e2cb..842cb95cd0fb 100644\n--- a/extension/parquet/include/column_reader.hpp\n+++ b/extension/parquet/include/column_reader.hpp\n@@ -412,7 +412,9 @@ class StructColumnReader : public ColumnReader {\n \t\t\tauto child_read = make_unique<Vector>();\n \t\t\tchild_read->Initialize(Type().child_types()[i].second);\n \t\t\tauto child_num_values = child_readers[i]->Read(num_values, filter, define_out, repeat_out, *child_read);\n-\t\t\tD_ASSERT(child_num_values == num_values);\n+\t\t\tif (child_num_values != num_values) {\n+\t\t\t\tthrow std::runtime_error(\"Struct child row count mismatch\");\n+\t\t\t}\n \t\t\tStructVector::AddEntry(result, Type().child_types()[i].first, move(child_read));\n \t\t}\n \ndiff --git a/src/include/duckdb/main/relation.hpp b/src/include/duckdb/main/relation.hpp\nindex 0d1912dad244..c3c758377058 100644\n--- a/src/include/duckdb/main/relation.hpp\n+++ b/src/include/duckdb/main/relation.hpp\n@@ -49,7 +49,7 @@ class Relation : public std::enable_shared_from_this<Relation> {\n \tDUCKDB_API void Print();\n \tDUCKDB_API void Head(idx_t limit = 10);\n \n-\tDUCKDB_API shared_ptr<Relation> CreateView(const string &name, bool replace = true);\n+\tDUCKDB_API shared_ptr<Relation> CreateView(const string &name, bool replace = true, bool temporary = false);\n \tDUCKDB_API unique_ptr<QueryResult> Query(const string &sql);\n \tDUCKDB_API unique_ptr<QueryResult> Query(const string &name, const string &sql);\n \ndiff --git a/src/include/duckdb/main/relation/create_view_relation.hpp b/src/include/duckdb/main/relation/create_view_relation.hpp\nindex 255189faf079..77d932fde84c 100644\n--- a/src/include/duckdb/main/relation/create_view_relation.hpp\n+++ b/src/include/duckdb/main/relation/create_view_relation.hpp\n@@ -14,11 +14,12 @@ namespace duckdb {\n \n class CreateViewRelation : public Relation {\n public:\n-\tCreateViewRelation(shared_ptr<Relation> child, string view_name, bool replace);\n+\tCreateViewRelation(shared_ptr<Relation> child, string view_name, bool replace, bool temporary);\n \n \tshared_ptr<Relation> child;\n \tstring view_name;\n \tbool replace;\n+\tbool temporary;\n \tvector<ColumnDefinition> columns;\n \n public:\ndiff --git a/src/main/relation.cpp b/src/main/relation.cpp\nindex d51665747997..48edc9a331ed 100644\n--- a/src/main/relation.cpp\n+++ b/src/main/relation.cpp\n@@ -202,7 +202,10 @@ void Relation::Insert(const string &table_name) {\n \n void Relation::Insert(const string &schema_name, const string &table_name) {\n \tauto insert = make_shared<InsertRelation>(shared_from_this(), schema_name, table_name);\n-\tinsert->Execute();\n+\tauto res = insert->Execute();\n+\tif (!res->success) {\n+\t\tthrow Exception(\"Failed to insert into table '\" + table_name + \"': \" + res->error);\n+\t}\n }\n \n void Relation::Insert(const vector<vector<Value>> &values) {\n@@ -217,12 +220,18 @@ void Relation::Create(const string &table_name) {\n \n void Relation::Create(const string &schema_name, const string &table_name) {\n \tauto create = make_shared<CreateTableRelation>(shared_from_this(), schema_name, table_name);\n-\tcreate->Execute();\n+\tauto res = create->Execute();\n+\tif (!res->success) {\n+\t\tthrow Exception(\"Failed to create table '\" + table_name + \"': \" + res->error);\n+\t}\n }\n \n void Relation::WriteCSV(const string &csv_file) {\n \tauto write_csv = make_shared<WriteCSVRelation>(shared_from_this(), csv_file);\n-\twrite_csv->Execute();\n+\tauto res = write_csv->Execute();\n+\tif (!res->success) {\n+\t\tthrow Exception(\"Failed to write '\" + csv_file + \"': \" + res->error);\n+\t}\n }\n \n void Relation::Head(idx_t limit) {\n@@ -230,9 +239,12 @@ void Relation::Head(idx_t limit) {\n \tlimit_node->Execute()->Print();\n }\n \n-shared_ptr<Relation> Relation::CreateView(const string &name, bool replace) {\n-\tauto view = make_shared<CreateViewRelation>(shared_from_this(), name, replace);\n-\tview->Execute();\n+shared_ptr<Relation> Relation::CreateView(const string &name, bool replace, bool temporary) {\n+\tauto view = make_shared<CreateViewRelation>(shared_from_this(), name, replace, temporary);\n+\tauto res = view->Execute();\n+\tif (!res->success) {\n+\t\tthrow Exception(\"Failed to create view '\" + name + \"': \" + res->error);\n+\t}\n \treturn shared_from_this();\n }\n \ndiff --git a/src/main/relation/create_view_relation.cpp b/src/main/relation/create_view_relation.cpp\nindex 3b2e3bc62106..2b1e62ba9046 100644\n--- a/src/main/relation/create_view_relation.cpp\n+++ b/src/main/relation/create_view_relation.cpp\n@@ -6,9 +6,10 @@\n \n namespace duckdb {\n \n-CreateViewRelation::CreateViewRelation(shared_ptr<Relation> child_p, string view_name, bool replace)\n-    : Relation(child_p->context, RelationType::CREATE_VIEW_RELATION), child(move(child_p)), view_name(move(view_name)),\n-      replace(replace) {\n+CreateViewRelation::CreateViewRelation(shared_ptr<Relation> child_p, string view_name_p, bool replace_p,\n+                                       bool temporary_p)\n+    : Relation(child_p->context, RelationType::CREATE_VIEW_RELATION), child(move(child_p)),\n+      view_name(move(view_name_p)), replace(replace_p), temporary(temporary_p) {\n \tcontext.TryBindRelation(*this, this->columns);\n }\n \n@@ -24,6 +25,8 @@ BoundStatement CreateViewRelation::Bind(Binder &binder) {\n \tauto info = make_unique<CreateViewInfo>();\n \tinfo->query = move(select);\n \tinfo->view_name = view_name;\n+\tinfo->temporary = temporary;\n+\tinfo->schema = \"\";\n \tinfo->on_conflict = replace ? OnCreateConflict::REPLACE_ON_CONFLICT : OnCreateConflict::ERROR_ON_CONFLICT;\n \tstmt.info = move(info);\n \treturn binder.Bind((SQLStatement &)stmt);\ndiff --git a/tools/rpkg/src/duckdbr.cpp b/tools/rpkg/src/duckdbr.cpp\nindex 318bcd0725d0..7c661d475d81 100644\n--- a/tools/rpkg/src/duckdbr.cpp\n+++ b/tools/rpkg/src/duckdbr.cpp\n@@ -337,6 +337,7 @@ static void *duckdb_altrep_strings_dataptr(SEXP x, Rboolean writeable) {\n \t\t\t}\n \t\t\tdest_offset += STANDARD_VECTOR_SIZE;\n \t\t}\n+\t\twrapper->vectors.clear();\n \t}\n \treturn CHARACTER_POINTER(R_altrep_data2(x));\n }\n@@ -1141,7 +1142,7 @@ SEXP duckdb_register_R(SEXP connsexp, SEXP namesexp, SEXP valuesexp) {\n \t\tRf_error(\"duckdb_register_R: Need at least one-column data frame parameter for value\");\n \t}\n \ttry {\n-\t\tconn->TableFunction(\"r_dataframe_scan\", {Value::POINTER((uintptr_t)valuesexp)})->CreateView(name, true);\n+\t\tconn->TableFunction(\"r_dataframe_scan\", {Value::POINTER((uintptr_t)valuesexp)})->CreateView(name, true, true);\n \t\tauto key = Rf_install((\"_registered_df_\" + name).c_str());\n \t\tRf_setAttrib(connsexp, key, valuesexp);\n \t} catch (exception &e) {\n",
  "test_patch": "diff --git a/test/api/test_read_only.cpp b/test/api/test_read_only.cpp\nindex 1dcdd2f7377d..84c73b5ebfa1 100644\n--- a/test/api/test_read_only.cpp\n+++ b/test/api/test_read_only.cpp\n@@ -103,3 +103,27 @@ TEST_CASE(\"Test connection using a read only database\", \"[readonly]\") {\n \t// db2.reset();\n \tDeleteDatabase(dbdir);\n }\n+\n+TEST_CASE(\"Test view creation using a read only database\", \"[readonly]\") {\n+\tauto dbdir = TestCreatePath(\"read_only_view_test\");\n+\tunique_ptr<DuckDB> db;\n+\tunique_ptr<Connection> con;\n+\t// make sure the database does not exist\n+\tDeleteDatabase(dbdir);\n+\n+\tDBConfig readonly_config;\n+\treadonly_config.use_temporary_directory = false;\n+\treadonly_config.access_mode = AccessMode::READ_ONLY;\n+\n+\t// create db in first place\n+\t{ auto db_rw = DuckDB(dbdir); }\n+\tdb = make_unique<DuckDB>(dbdir, &readonly_config);\n+\t// create the database file and initialize it with data\n+\tcon = make_unique<Connection>(*db);\n+\n+\tREQUIRE_NOTHROW(con->TableFunction(\"sqlite_master\")->CreateView(\"boo\", true, true));\n+\tcon.reset();\n+\tdb.reset();\n+\n+\tDeleteDatabase(dbdir);\n+}\ndiff --git a/tools/pythonpkg/tests/test_dbapi12.py b/tools/pythonpkg/tests/test_dbapi12.py\nindex 911926c894c1..bf6200b8d88a 100644\n--- a/tools/pythonpkg/tests/test_dbapi12.py\n+++ b/tools/pythonpkg/tests/test_dbapi12.py\n@@ -24,6 +24,7 @@ def test_rel(rel, duckdb_cursor):\n             cmp_df = pd.DataFrame.from_dict({\"i\":[1, 2, 3], \"cj\":[1, 1, 1]})\n             pd.testing.assert_frame_equal(res2.to_df(), cmp_df)\n \n+            duckdb_cursor.execute('DROP TABLE IF EXISTS a2')\n             rel.create('a2')\n             rel_a2 = duckdb_cursor.table('a2').project('CAST(i as BIGINT) i, j').to_df()\n             pd.testing.assert_frame_equal(rel_a2, test_df)\ndiff --git a/tools/rpkg/tests/testthat/test_register_readonly.R b/tools/rpkg/tests/testthat/test_register_readonly.R\nnew file mode 100644\nindex 000000000000..16d8b77ea8da\n--- /dev/null\n+++ b/tools/rpkg/tests/testthat/test_register_readonly.R\n@@ -0,0 +1,11 @@\n+test_that(\"we can register a data frame on a read only connection\", {\n+  path = tempfile()\n+  # create empty database\n+  con = DBI::dbConnect(duckdb::duckdb(), dbdir = path, read_only = FALSE)\n+  DBI::dbDisconnect(con, shutdown = TRUE)\n+\n+  # reopen database read-only, try to write temp table\n+  con = DBI::dbConnect(duckdb::duckdb(), dbdir = path, read_only = TRUE)\n+  duckdb::duckdb_register(con, \"mtcars\", mtcars)\n+})\n+\n",
  "problem_statement": "make install installs third-party\nHello and thank you for this wonderful project !\r\n\r\nWhen using `make install` after the build, third-party libraries are installed and this overwrites already existing libraries in the same environment (e.g.: libfmt.a). Could you please investigate on using `add_subdirectory(third_party EXCLUDE_FROM_ALL)` ?\r\n\r\n\n",
  "hints_text": "Happy to review a PR that fixes this behavior. Otherwise we will have a look later on. Thanks for opening the issue :)",
  "created_at": "2021-03-22T13:52:15Z"
}