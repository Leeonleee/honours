{
  "repo": "duckdb/duckdb",
  "pull_number": 12028,
  "instance_id": "duckdb__duckdb-12028",
  "issue_numbers": [
    "12017"
  ],
  "base_commit": "fcee4de6bc0c9bfe65471e9f180cd35c76266412",
  "patch": "diff --git a/src/common/error_data.cpp b/src/common/error_data.cpp\nindex a67fd1266118..07457419925c 100644\n--- a/src/common/error_data.cpp\n+++ b/src/common/error_data.cpp\n@@ -25,6 +25,13 @@ ErrorData::ErrorData(const string &message) : initialized(true), type(ExceptionT\n \t// parse the constructed JSON\n \tif (message.empty() || message[0] != '{') {\n \t\t// not JSON! Use the message as a raw Exception message and leave type as uninitialized\n+\n+\t\tif (message == std::bad_alloc().what()) {\n+\t\t\ttype = ExceptionType::OUT_OF_MEMORY;\n+\t\t\traw_message = \"Allocation failure\";\n+\t\t\treturn;\n+\t\t}\n+\n \t\traw_message = message;\n \t\treturn;\n \t} else {\ndiff --git a/src/common/types/string_heap.cpp b/src/common/types/string_heap.cpp\nindex eac0f59e7f5c..be23433dd46c 100644\n--- a/src/common/types/string_heap.cpp\n+++ b/src/common/types/string_heap.cpp\n@@ -51,6 +51,10 @@ string_t StringHeap::AddBlob(const string_t &data) {\n \n string_t StringHeap::EmptyString(idx_t len) {\n \tD_ASSERT(len > string_t::INLINE_LENGTH);\n+\tif (len > string_t::MAX_STRING_SIZE) {\n+\t\tthrow OutOfRangeException(\"Cannot create a string of size: '%d', the maximum supported string size is: '%d'\",\n+\t\t                          len, string_t::MAX_STRING_SIZE);\n+\t}\n \tauto insert_pos = const_char_ptr_cast(allocator.Allocate(len));\n \treturn string_t(insert_pos, UnsafeNumericCast<uint32_t>(len));\n }\ndiff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp\nindex 112dc0de96ab..3458b481d97f 100644\n--- a/src/common/types/vector.cpp\n+++ b/src/common/types/vector.cpp\n@@ -395,10 +395,17 @@ void Vector::Resize(idx_t cur_size, idx_t new_size) {\n \t}\n \tfor (auto &data_to_resize : to_resize) {\n \t\tif (!data_to_resize.is_nested) {\n-\t\t\tauto new_data =\n-\t\t\t    make_unsafe_uniq_array<data_t>(new_size * data_to_resize.type_size * data_to_resize.nested_multiplier);\n-\t\t\tmemcpy(new_data.get(), data_to_resize.data,\n-\t\t\t       cur_size * data_to_resize.type_size * data_to_resize.nested_multiplier * sizeof(data_t));\n+\t\t\tauto old_size = cur_size * data_to_resize.type_size * data_to_resize.nested_multiplier * sizeof(data_t);\n+\t\t\tauto target_size = new_size * data_to_resize.type_size * data_to_resize.nested_multiplier * sizeof(data_t);\n+\n+\t\t\t// We have an upper limit of 4GB for a single vector\n+\t\t\tif (target_size > NumericLimits<uint32_t>::Maximum()) {\n+\t\t\t\tthrow OutOfRangeException(\"Cannot resize vector to %lld bytes: maximum allowed vector size is 4GB\",\n+\t\t\t\t                          target_size);\n+\t\t\t}\n+\n+\t\t\tauto new_data = make_unsafe_uniq_array<data_t>(target_size);\n+\t\t\tmemcpy(new_data.get(), data_to_resize.data, old_size);\n \t\t\tdata_to_resize.buffer->SetData(std::move(new_data));\n \t\t\tdata_to_resize.vec.data = data_to_resize.buffer->GetData();\n \t\t}\ndiff --git a/src/common/types/vector_buffer.cpp b/src/common/types/vector_buffer.cpp\nindex 7a7db5faeaf3..59bc6f9cadf2 100644\n--- a/src/common/types/vector_buffer.cpp\n+++ b/src/common/types/vector_buffer.cpp\n@@ -68,6 +68,10 @@ VectorListBuffer::VectorListBuffer(const LogicalType &list_type, idx_t initial_c\n void VectorListBuffer::Reserve(idx_t to_reserve) {\n \tif (to_reserve > capacity) {\n \t\tidx_t new_capacity = NextPowerOfTwo(to_reserve);\n+\t\tif (new_capacity == 0) {\n+\t\t\t// Overflow: set to_reserve to the maximum value\n+\t\t\tnew_capacity = to_reserve;\n+\t\t}\n \t\tD_ASSERT(new_capacity >= to_reserve);\n \t\tchild->Resize(capacity, new_capacity);\n \t\tcapacity = new_capacity;\ndiff --git a/src/core_functions/scalar/string/repeat.cpp b/src/core_functions/scalar/string/repeat.cpp\nindex afe3269f94b7..b124c65bd345 100644\n--- a/src/core_functions/scalar/string/repeat.cpp\n+++ b/src/core_functions/scalar/string/repeat.cpp\n@@ -1,5 +1,6 @@\n #include \"duckdb/common/vector_operations/binary_executor.hpp\"\n #include \"duckdb/core_functions/scalar/string_functions.hpp\"\n+#include \"duckdb/common/operator/multiply.hpp\"\n \n namespace duckdb {\n \n@@ -11,15 +12,22 @@ static void RepeatFunction(DataChunk &args, ExpressionState &, Vector &result) {\n \t    str_vector, cnt_vector, result, args.size(), [&](string_t str, int64_t cnt) {\n \t\t    auto input_str = str.GetData();\n \t\t    auto size_str = str.GetSize();\n+\t\t    idx_t copy_count = cnt <= 0 || size_str == 0 ? 0 : UnsafeNumericCast<idx_t>(cnt);\n \n-\t\t    idx_t copy_count = cnt <= 0 || size_str == 0 ? 0 : idx_t(cnt);\n-\t\t    auto result_str = StringVector::EmptyString(result, size_str * copy_count);\n-\t\t    auto result_data = result_str.GetDataWriteable();\n-\t\t    for (idx_t i = 0; i < copy_count; i++) {\n-\t\t\t    memcpy(result_data + i * size_str, input_str, size_str);\n+\t\t    idx_t copy_size;\n+\t\t    if (TryMultiplyOperator::Operation(size_str, copy_count, copy_size)) {\n+\t\t\t    auto result_str = StringVector::EmptyString(result, copy_size);\n+\t\t\t    auto result_data = result_str.GetDataWriteable();\n+\t\t\t    for (idx_t i = 0; i < copy_count; i++) {\n+\t\t\t\t    memcpy(result_data + i * size_str, input_str, size_str);\n+\t\t\t    }\n+\t\t\t    result_str.Finalize();\n+\t\t\t    return result_str;\n+\t\t    } else {\n+\t\t\t    throw OutOfRangeException(\n+\t\t\t        \"Cannot create a string of size: '%d' * '%d', the maximum supported string size is: '%d'\", size_str,\n+\t\t\t        copy_count, string_t::MAX_STRING_SIZE);\n \t\t    }\n-\t\t    result_str.Finalize();\n-\t\t    return result_str;\n \t    });\n }\n \ndiff --git a/src/execution/operator/projection/physical_unnest.cpp b/src/execution/operator/projection/physical_unnest.cpp\nindex 356b2272421e..2d5421a723ce 100644\n--- a/src/execution/operator/projection/physical_unnest.cpp\n+++ b/src/execution/operator/projection/physical_unnest.cpp\n@@ -204,6 +204,9 @@ static void UnnestVector(UnifiedVectorFormat &child_vector_data, Vector &child_v\n \t\t}\n \t\tbreak;\n \t}\n+\tcase PhysicalType::ARRAY: {\n+\t\tthrow NotImplementedException(\"ARRAY type not supported for UNNEST.\");\n+\t}\n \tdefault:\n \t\tthrow InternalException(\"Unimplemented type for UNNEST.\");\n \t}\ndiff --git a/src/function/scalar/list/list_resize.cpp b/src/function/scalar/list/list_resize.cpp\nindex 04f494139cd4..792e0f6bce98 100644\n--- a/src/function/scalar/list/list_resize.cpp\n+++ b/src/function/scalar/list/list_resize.cpp\n@@ -28,7 +28,7 @@ void ListResizeFunction(DataChunk &args, ExpressionState &state, Vector &result)\n \n \tUnifiedVectorFormat new_size_data;\n \tnew_sizes.ToUnifiedFormat(count, new_size_data);\n-\tauto new_size_entries = UnifiedVectorFormat::GetData<int64_t>(new_size_data);\n+\tauto new_size_entries = UnifiedVectorFormat::GetData<uint64_t>(new_size_data);\n \n \tUnifiedVectorFormat child_data;\n \tchild.ToUnifiedFormat(count, child_data);\n@@ -38,7 +38,7 @@ void ListResizeFunction(DataChunk &args, ExpressionState &state, Vector &result)\n \tfor (idx_t i = 0; i < count; i++) {\n \t\tauto index = new_size_data.sel->get_index(i);\n \t\tif (new_size_data.validity.RowIsValid(index)) {\n-\t\t\tnew_child_size += UnsafeNumericCast<uint64_t>(new_size_entries[index]);\n+\t\t\tnew_child_size += new_size_entries[index];\n \t\t}\n \t}\n \n@@ -72,7 +72,7 @@ void ListResizeFunction(DataChunk &args, ExpressionState &state, Vector &result)\n \n \t\tidx_t new_size_entry = 0;\n \t\tif (new_size_data.validity.RowIsValid(new_index)) {\n-\t\t\tnew_size_entry = UnsafeNumericCast<uint64_t>(new_size_entries[new_index]);\n+\t\t\tnew_size_entry = new_size_entries[new_index];\n \t\t}\n \n \t\t// find the smallest size between lists and new_sizes\ndiff --git a/src/function/scalar/list/list_select.cpp b/src/function/scalar/list/list_select.cpp\nindex d31e7573a9b2..07413977bfd5 100644\n--- a/src/function/scalar/list/list_select.cpp\n+++ b/src/function/scalar/list/list_select.cpp\n@@ -45,6 +45,12 @@ struct SetSelectionVectorWhere {\n \t\tif (!input_validity.RowIsValid(input_offset + child_idx)) {\n \t\t\tvalidity_mask.SetInvalid(target_offset);\n \t\t}\n+\n+\t\tif (child_idx >= target_length) {\n+\t\t\tselection_vector.set_index(target_offset, 0);\n+\t\t\tvalidity_mask.SetInvalid(target_offset);\n+\t\t}\n+\n \t\ttarget_offset++;\n \t}\n \ndiff --git a/src/include/duckdb/common/types/string_type.hpp b/src/include/duckdb/common/types/string_type.hpp\nindex 1ec8bdc89301..c9155c598cd6 100644\n--- a/src/include/duckdb/common/types/string_type.hpp\n+++ b/src/include/duckdb/common/types/string_type.hpp\n@@ -12,6 +12,7 @@\n #include \"duckdb/common/constants.hpp\"\n #include \"duckdb/common/helper.hpp\"\n #include \"duckdb/common/numeric_utils.hpp\"\n+#include \"duckdb/common/limits.hpp\"\n \n #include <cstring>\n #include <algorithm>\n@@ -26,6 +27,7 @@ struct string_t {\n \tstatic constexpr idx_t PREFIX_BYTES = 4 * sizeof(char);\n \tstatic constexpr idx_t INLINE_BYTES = 12 * sizeof(char);\n \tstatic constexpr idx_t HEADER_SIZE = sizeof(uint32_t) + PREFIX_BYTES;\n+\tstatic constexpr idx_t MAX_STRING_SIZE = NumericLimits<uint32_t>::Maximum();\n #ifndef DUCKDB_DEBUG_NO_INLINE\n \tstatic constexpr idx_t PREFIX_LENGTH = PREFIX_BYTES;\n \tstatic constexpr idx_t INLINE_LENGTH = INLINE_BYTES;\ndiff --git a/src/planner/expression_binder/order_binder.cpp b/src/planner/expression_binder/order_binder.cpp\nindex 2924a3a50170..4a277b3adc50 100644\n--- a/src/planner/expression_binder/order_binder.cpp\n+++ b/src/planner/expression_binder/order_binder.cpp\n@@ -108,6 +108,14 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {\n \t\tauto &collation = expr->Cast<CollateExpression>();\n \t\tif (collation.child->expression_class == ExpressionClass::CONSTANT) {\n \t\t\tauto &constant = collation.child->Cast<ConstantExpression>();\n+\n+\t\t\t// non-integral expression, we just leave the constant here.\n+\t\t\t// ORDER BY <constant> has no effect\n+\t\t\t// CONTROVERSIAL: maybe we should throw an error\n+\t\t\tif (!constant.value.type().IsIntegral()) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n \t\t\tD_ASSERT(constant.value.GetValue<idx_t>() > 0);\n \t\t\tauto index = constant.value.GetValue<idx_t>() - 1;\n \t\t\tchild_list_t<Value> values;\n",
  "test_patch": "diff --git a/test/sql/function/list/list_resize.test b/test/sql/function/list/list_resize.test\nindex ba85805314e4..5f460c537428 100644\n--- a/test/sql/function/list/list_resize.test\n+++ b/test/sql/function/list/list_resize.test\n@@ -297,6 +297,17 @@ execute ${q}([1, 2, 3], 1.4);\n statement ok\n execute ${q}([2], 2::TINYINT);\n \n+\n+statement error\n+execute ${q}([1, 2, 3], -1);\n+----\n+Conversion Error: Type INT32 with value -1 can't be cast because the value is out of range for the destination type UINT64\n+\n+statement error\n+SELECT LIST_RESIZE([1, 2, 3], 9999999999999999999);\n+----\n+Out of Range Error: Cannot resize vector to 3106511852580896764 bytes: maximum allowed vector size is 4GB\n+\n endloop\n \n query I\ndiff --git a/test/sql/function/list/list_select.test b/test/sql/function/list/list_select.test\nindex f43ebda4201d..bea1199b7434 100644\n--- a/test/sql/function/list/list_select.test\n+++ b/test/sql/function/list/list_select.test\n@@ -324,4 +324,9 @@ SELECT list_select(c34, 'enum_0')\n FROM all_types AS t43(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41, c42),\n \tall_types AS t86(c44, c45, c46, c47, c48, c49, c50, c51, c52, c53, c54, c55, c56, c57, c58, c59, c60, c61, c62, c63, c64, c65, c66, c67, c68, c69, c70, c71, c72, c73, c74, c75, c76, c77, c78, c79, c80, c81, c82, c83, c84, c85);\n ----\n-Conversion Error\n\\ No newline at end of file\n+Conversion Error\n+\n+query I\n+SELECT LIST_SELECT(ARRAY_VALUE('1', NULL), [1, 2, 3]);\n+----\n+[1, NULL, NULL]\n\\ No newline at end of file\ndiff --git a/test/sql/function/list/list_where.test b/test/sql/function/list/list_where.test\nindex 67d7d5db07cb..80272c9d6546 100644\n--- a/test/sql/function/list/list_where.test\n+++ b/test/sql/function/list/list_where.test\n@@ -226,4 +226,15 @@ SELECT list_where([{'a': 1}, {'a': 5}, {'a': 3}], [true, true, true])\n query I\n SELECT list_where([1,2,3]::INT[3], [true, false, true]::BOOLEAN[3]);\n ----\n-[1, 3]\n\\ No newline at end of file\n+[1, 3]\n+\n+query I\n+SELECT LIST_WHERE(ARRAY_VALUE('1', NULL), [TRUE, TRUE, TRUE]);\n+----\n+[1, NULL, NULL]\n+\n+\n+query I\n+SELECT LIST_WHERE(ARRAY_VALUE('1', NULL), [TRUE, TRUE, FALSE]);\n+----\n+[1, NULL]\n\\ No newline at end of file\n",
  "problem_statement": "[Fuzzer] DuckDB crashes via the `REPEAT` function with crafted arguments\n### What happens?\n\nDuckDB v0.10.2 (`duckdb_cli-linux-amd64`) crashes via the `REPEAT` function with crafted arguments. It can also be reproduced in the nightly build.\n\n### To Reproduce\n\nPoC:\r\n```sql\r\nSELECT REPEAT(REPEAT('0', 24), 4611686018427387904);\r\n```\r\n\r\nWith different arguments, DuckDB has different behaviors. Maybe an integer overflow happens somewhere:\r\n```sql\r\nSELECT REPEAT(REPEAT('0', 21), 4611686018427387904); -- INTERNAL Error: Requested allocation size of 4611686018427387904 is out of range - maximum allocation size is 281474976710656\r\nSELECT REPEAT(REPEAT('0', 22), 4611686018427387904); -- INTERNAL Error: Requested allocation size of 9223372036854775808 is out of range - maximum allocation size is 281474976710656\r\nSELECT REPEAT(REPEAT('0', 23), 4611686018427387904); -- *hang*\r\nSELECT REPEAT(REPEAT('0', 24), 4611686018427387904); -- *crash*\r\nSELECT REPEAT(REPEAT('0', 25), 4611686018427387904); -- INTERNAL Error: Requested allocation size of 4611686018427387904 is out of range - maximum allocation size is 281474976710656\r\nSELECT REPEAT(REPEAT('0', 26), 4611686018427387904); -- INTERNAL Error: Requested allocation size of 9223372036854775808 is out of range - maximum allocation size is 281474976710656\r\nSELECT REPEAT(REPEAT('0', 27), 4611686018427387904); -- *hang*\r\nSELECT REPEAT(REPEAT('0', 28), 4611686018427387904); -- *crash*\r\n```\n\n### OS:\n\nUbuntu 22.04 x64\n\n### DuckDB Version:\n\nv0.10.2\n\n### DuckDB Client:\n\ncli\n\n### Full Name:\n\nJingzhou Fu\n\n### Affiliation:\n\nWingtecher Lab of Tsinghua University\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a nightly build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-05-13T11:51:17Z"
}