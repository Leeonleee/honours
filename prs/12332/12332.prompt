You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Segmentation fault during PIVOTING table (CLI) using struct field
### What happens?

There is some limitation or bug during pivoting table using struct type field.

I'm using the CLI. I would like to pivot a table, more than 6000 columns to produce.
Here is the result : 

> pivot donnees_csv on variable_id using first(donnee) group by id_niv,codzone;
> 85% ▕███████████████████████████████████████████████████       
> [1]    62343 segmentation fault  duckdb tests.db

The `donnee` field is a struct type.




### To Reproduce

The table donnees_csv was materialized into a database like this :


> `create or replace table donnees_csv as (`
> `select build_variable_id(codind,datefin::string) as variable_id,zonage as id_niv,codzone,valeur,`
> `statut,{v:valeur,s:statut} as donnee ` 
>`from read_csv('variables_donnees.csv', header=true)  order by id_niv,codzone);`

The `build_variable_id` is a simple function : `create or replace function build_variable_id(codind,datefin) as codind||'_'||replace(datefin,'-','_');`


The segmentation fault is coming where pivoting like this :
`pivot donnees_csv on variable_id using first(donnee) group by id_niv,codzone;`

When i limit the size of the `donnees_csv` table, it works fine. With the full size of the table, PIVOT has to produce 6000 columns.

Maybe important thing : it works when pivoting using another field than `donnee`: `donnee` is a struct type field, where using `valeur` field (double type) all is fine.


### OS:

MacOS

### DuckDB Version:

10.0.3

### DuckDB Client:

CLI

### Full Name:

Frank Jardillier

### Affiliation:

compas

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

No - I cannot easily share my data sets due to their large size

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [ ] Yes, I have
Segmentation fault during PIVOTING table (CLI) using struct field
### What happens?

There is some limitation or bug during pivoting table using struct type field.

I'm using the CLI. I would like to pivot a table, more than 6000 columns to produce.
Here is the result : 

> pivot donnees_csv on variable_id using first(donnee) group by id_niv,codzone;
> 85% ▕███████████████████████████████████████████████████       
> [1]    62343 segmentation fault  duckdb tests.db

The `donnee` field is a struct type.




### To Reproduce

The table donnees_csv was materialized into a database like this :


> `create or replace table donnees_csv as (`
> `select build_variable_id(codind,datefin::string) as variable_id,zonage as id_niv,codzone,valeur,`
> `statut,{v:valeur,s:statut} as donnee ` 
>`from read_csv('variables_donnees.csv', header=true)  order by id_niv,codzone);`

The `build_variable_id` is a simple function : `create or replace function build_variable_id(codind,datefin) as codind||'_'||replace(datefin,'-','_');`


The segmentation fault is coming where pivoting like this :
`pivot donnees_csv on variable_id using first(donnee) group by id_niv,codzone;`

When i limit the size of the `donnees_csv` table, it works fine. With the full size of the table, PIVOT has to produce 6000 columns.

Maybe important thing : it works when pivoting using another field than `donnee`: `donnee` is a struct type field, where using `valeur` field (double type) all is fine.


### OS:

MacOS

### DuckDB Version:

10.0.3

### DuckDB Client:

CLI

### Full Name:

Frank Jardillier

### Affiliation:

compas

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

No - I cannot easily share my data sets due to their large size

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [ ] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
18: 
19: ## Installation
20: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
21: 
22: ## Data Import
23: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
24: 
25: ```sql
26: SELECT * FROM 'myfile.csv';
27: SELECT * FROM 'myfile.parquet';
28: ```
29: 
30: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
31: 
32: ## SQL Reference
33: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
34: 
35: ## Development
36: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
37: 
38: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
39: 
40: ## Support
41: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/common/types/vector.cpp]
1: #include "duckdb/common/types/vector.hpp"
2: 
3: #include "duckdb/common/algorithm.hpp"
4: #include "duckdb/common/assert.hpp"
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/common/operator/comparison_operators.hpp"
7: #include "duckdb/common/pair.hpp"
8: #include "duckdb/common/printer.hpp"
9: #include "duckdb/common/types/null_value.hpp"
10: #include "duckdb/common/types/sel_cache.hpp"
11: #include "duckdb/common/types/vector_cache.hpp"
12: #include "duckdb/common/uhugeint.hpp"
13: #include "duckdb/common/vector_operations/vector_operations.hpp"
14: #include "duckdb/storage/buffer/buffer_handle.hpp"
15: #include "duckdb/function/scalar/nested_functions.hpp"
16: #include "duckdb/storage/string_uncompressed.hpp"
17: #include "duckdb/common/types/value.hpp"
18: #include "duckdb/common/fsst.hpp"
19: #include "fsst.h"
20: #include "duckdb/common/types/bit.hpp"
21: #include "duckdb/common/types/value_map.hpp"
22: 
23: #include "duckdb/common/serializer/serializer.hpp"
24: #include "duckdb/common/serializer/deserializer.hpp"
25: 
26: #include <cstring> // strlen() on Solaris
27: 
28: namespace duckdb {
29: 
30: UnifiedVectorFormat::UnifiedVectorFormat() : sel(nullptr), data(nullptr) {
31: }
32: 
33: UnifiedVectorFormat::UnifiedVectorFormat(UnifiedVectorFormat &&other) noexcept {
34: 	bool refers_to_self = other.sel == &other.owned_sel;
35: 	std::swap(sel, other.sel);
36: 	std::swap(data, other.data);
37: 	std::swap(validity, other.validity);
38: 	std::swap(owned_sel, other.owned_sel);
39: 	if (refers_to_self) {
40: 		sel = &owned_sel;
41: 	}
42: }
43: 
44: UnifiedVectorFormat &UnifiedVectorFormat::operator=(UnifiedVectorFormat &&other) noexcept {
45: 	bool refers_to_self = other.sel == &other.owned_sel;
46: 	std::swap(sel, other.sel);
47: 	std::swap(data, other.data);
48: 	std::swap(validity, other.validity);
49: 	std::swap(owned_sel, other.owned_sel);
50: 	if (refers_to_self) {
51: 		sel = &owned_sel;
52: 	}
53: 	return *this;
54: }
55: 
56: Vector::Vector(LogicalType type_p, bool create_data, bool zero_data, idx_t capacity)
57:     : vector_type(VectorType::FLAT_VECTOR), type(std::move(type_p)), data(nullptr), validity(capacity) {
58: 	if (create_data) {
59: 		Initialize(zero_data, capacity);
60: 	}
61: }
62: 
63: Vector::Vector(LogicalType type_p, idx_t capacity) : Vector(std::move(type_p), true, false, capacity) {
64: }
65: 
66: Vector::Vector(LogicalType type_p, data_ptr_t dataptr)
67:     : vector_type(VectorType::FLAT_VECTOR), type(std::move(type_p)), data(dataptr) {
68: 	if (dataptr && !type.IsValid()) {
69: 		throw InternalException("Cannot create a vector of type INVALID!");
70: 	}
71: }
72: 
73: Vector::Vector(const VectorCache &cache) : type(cache.GetType()) {
74: 	ResetFromCache(cache);
75: }
76: 
77: Vector::Vector(Vector &other) : type(other.type) {
78: 	Reference(other);
79: }
80: 
81: Vector::Vector(const Vector &other, const SelectionVector &sel, idx_t count) : type(other.type) {
82: 	Slice(other, sel, count);
83: }
84: 
85: Vector::Vector(const Vector &other, idx_t offset, idx_t end) : type(other.type) {
86: 	Slice(other, offset, end);
87: }
88: 
89: Vector::Vector(const Value &value) : type(value.type()) {
90: 	Reference(value);
91: }
92: 
93: Vector::Vector(Vector &&other) noexcept
94:     : vector_type(other.vector_type), type(std::move(other.type)), data(other.data),
95:       validity(std::move(other.validity)), buffer(std::move(other.buffer)), auxiliary(std::move(other.auxiliary)) {
96: }
97: 
98: void Vector::Reference(const Value &value) {
99: 	D_ASSERT(GetType().id() == value.type().id());
100: 	this->vector_type = VectorType::CONSTANT_VECTOR;
101: 	buffer = VectorBuffer::CreateConstantVector(value.type());
102: 	auto internal_type = value.type().InternalType();
103: 	if (internal_type == PhysicalType::STRUCT) {
104: 		auto struct_buffer = make_uniq<VectorStructBuffer>();
105: 		auto &child_types = StructType::GetChildTypes(value.type());
106: 		auto &child_vectors = struct_buffer->GetChildren();
107: 		for (idx_t i = 0; i < child_types.size(); i++) {
108: 			auto vector =
109: 			    make_uniq<Vector>(value.IsNull() ? Value(child_types[i].second) : StructValue::GetChildren(value)[i]);
110: 			child_vectors.push_back(std::move(vector));
111: 		}
112: 		auxiliary = shared_ptr<VectorBuffer>(struct_buffer.release());
113: 		if (value.IsNull()) {
114: 			SetValue(0, value);
115: 		}
116: 	} else if (internal_type == PhysicalType::LIST) {
117: 		auto list_buffer = make_uniq<VectorListBuffer>(value.type());
118: 		auxiliary = shared_ptr<VectorBuffer>(list_buffer.release());
119: 		data = buffer->GetData();
120: 		SetValue(0, value);
121: 	} else if (internal_type == PhysicalType::ARRAY) {
122: 		auto array_buffer = make_uniq<VectorArrayBuffer>(value.type());
123: 		auxiliary = shared_ptr<VectorBuffer>(array_buffer.release());
124: 		SetValue(0, value);
125: 	} else {
126: 		auxiliary.reset();
127: 		data = buffer->GetData();
128: 		SetValue(0, value);
129: 	}
130: }
131: 
132: void Vector::Reference(const Vector &other) {
133: 	if (other.GetType().id() != GetType().id()) {
134: 		throw InternalException("Vector::Reference used on vector of different type");
135: 	}
136: 	D_ASSERT(other.GetType() == GetType());
137: 	Reinterpret(other);
138: }
139: 
140: void Vector::ReferenceAndSetType(const Vector &other) {
141: 	type = other.GetType();
142: 	Reference(other);
143: }
144: 
145: void Vector::Reinterpret(const Vector &other) {
146: 	vector_type = other.vector_type;
147: #ifdef DEBUG
148: 	auto &this_type = GetType();
149: 	auto &other_type = other.GetType();
150: 
151: 	auto type_is_same = other_type == this_type;
152: 	bool this_is_nested = this_type.IsNested();
153: 	bool other_is_nested = other_type.IsNested();
154: 
155: 	bool not_nested = this_is_nested == false && other_is_nested == false;
156: 	bool type_size_equal = GetTypeIdSize(this_type.InternalType()) == GetTypeIdSize(other_type.InternalType());
157: 	//! Either the types are completely identical, or they are not nested and their physical type size is the same
158: 	//! The reason nested types are not allowed is because copying the auxiliary buffer does not happen recursively
159: 	//! e.g DOUBLE[] to BIGINT[], the type of the LIST would say BIGINT but the child Vector says DOUBLE
160: 	D_ASSERT((not_nested && type_size_equal) || type_is_same);
161: #endif
162: 	AssignSharedPointer(buffer, other.buffer);
163: 	AssignSharedPointer(auxiliary, other.auxiliary);
164: 	data = other.data;
165: 	validity = other.validity;
166: }
167: 
168: void Vector::ResetFromCache(const VectorCache &cache) {
169: 	cache.ResetFromCache(*this);
170: }
171: 
172: void Vector::Slice(const Vector &other, idx_t offset, idx_t end) {
173: 	D_ASSERT(end >= offset);
174: 	if (other.GetVectorType() == VectorType::CONSTANT_VECTOR) {
175: 		Reference(other);
176: 		return;
177: 	}
178: 	if (other.GetVectorType() != VectorType::FLAT_VECTOR) {
179: 		// we can slice the data directly only for flat vectors
180: 		// for non-flat vectors slice using a selection vector instead
181: 		idx_t count = end - offset;
182: 		SelectionVector sel(count);
183: 		for (idx_t i = 0; i < count; i++) {
184: 			sel.set_index(i, offset + i);
185: 		}
186: 		Slice(other, sel, count);
187: 		return;
188: 	}
189: 
190: 	auto internal_type = GetType().InternalType();
191: 	if (internal_type == PhysicalType::STRUCT) {
192: 		Vector new_vector(GetType());
193: 		auto &entries = StructVector::GetEntries(new_vector);
194: 		auto &other_entries = StructVector::GetEntries(other);
195: 		D_ASSERT(entries.size() == other_entries.size());
196: 		for (idx_t i = 0; i < entries.size(); i++) {
197: 			entries[i]->Slice(*other_entries[i], offset, end);
198: 		}
199: 		new_vector.validity.Slice(other.validity, offset, end - offset);
200: 		Reference(new_vector);
201: 	} else if (internal_type == PhysicalType::ARRAY) {
202: 		Vector new_vector(GetType());
203: 		auto &child_vec = ArrayVector::GetEntry(new_vector);
204: 		auto &other_child_vec = ArrayVector::GetEntry(other);
205: 		D_ASSERT(ArrayType::GetSize(GetType()) == ArrayType::GetSize(other.GetType()));
206: 		child_vec.Slice(other_child_vec, offset, end);
207: 		new_vector.validity.Slice(other.validity, offset, end - offset);
208: 		Reference(new_vector);
209: 	} else {
210: 		Reference(other);
211: 		if (offset > 0) {
212: 			data = data + GetTypeIdSize(internal_type) * offset;
213: 			validity.Slice(other.validity, offset, end - offset);
214: 		}
215: 	}
216: }
217: 
218: void Vector::Slice(const Vector &other, const SelectionVector &sel, idx_t count) {
219: 	Reference(other);
220: 	Slice(sel, count);
221: }
222: 
223: void Vector::Slice(const SelectionVector &sel, idx_t count) {
224: 	if (GetVectorType() == VectorType::CONSTANT_VECTOR) {
225: 		// dictionary on a constant is just a constant
226: 		return;
227: 	}
228: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
229: 		// already a dictionary, slice the current dictionary
230: 		auto &current_sel = DictionaryVector::SelVector(*this);
231: 		auto sliced_dictionary = current_sel.Slice(sel, count);
232: 		buffer = make_buffer<DictionaryBuffer>(std::move(sliced_dictionary));
233: 		if (GetType().InternalType() == PhysicalType::STRUCT) {
234: 			auto &child_vector = DictionaryVector::Child(*this);
235: 
236: 			Vector new_child(child_vector);
237: 			new_child.auxiliary = make_buffer<VectorStructBuffer>(new_child, sel, count);
238: 			auxiliary = make_buffer<VectorChildBuffer>(std::move(new_child));
239: 		}
240: 		return;
241: 	}
242: 
243: 	if (GetVectorType() == VectorType::FSST_VECTOR) {
244: 		Flatten(sel, count);
245: 		return;
246: 	}
247: 
248: 	Vector child_vector(*this);
249: 	auto internal_type = GetType().InternalType();
250: 	if (internal_type == PhysicalType::STRUCT) {
251: 		child_vector.auxiliary = make_buffer<VectorStructBuffer>(*this, sel, count);
252: 	}
253: 	auto child_ref = make_buffer<VectorChildBuffer>(std::move(child_vector));
254: 	auto dict_buffer = make_buffer<DictionaryBuffer>(sel);
255: 	vector_type = VectorType::DICTIONARY_VECTOR;
256: 	buffer = std::move(dict_buffer);
257: 	auxiliary = std::move(child_ref);
258: }
259: 
260: void Vector::Slice(const SelectionVector &sel, idx_t count, SelCache &cache) {
261: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR && GetType().InternalType() != PhysicalType::STRUCT) {
262: 		// dictionary vector: need to merge dictionaries
263: 		// check if we have a cached entry
264: 		auto &current_sel = DictionaryVector::SelVector(*this);
265: 		auto target_data = current_sel.data();
266: 		auto entry = cache.cache.find(target_data);
267: 		if (entry != cache.cache.end()) {
268: 			// cached entry exists: use that
269: 			this->buffer = make_buffer<DictionaryBuffer>(entry->second->Cast<DictionaryBuffer>().GetSelVector());
270: 			vector_type = VectorType::DICTIONARY_VECTOR;
271: 		} else {
272: 			Slice(sel, count);
273: 			cache.cache[target_data] = this->buffer;
274: 		}
275: 	} else {
276: 		Slice(sel, count);
277: 	}
278: }
279: 
280: void Vector::Initialize(bool zero_data, idx_t capacity) {
281: 	auxiliary.reset();
282: 	validity.Reset();
283: 	auto &type = GetType();
284: 	auto internal_type = type.InternalType();
285: 	if (internal_type == PhysicalType::STRUCT) {
286: 		auto struct_buffer = make_uniq<VectorStructBuffer>(type, capacity);
287: 		auxiliary = shared_ptr<VectorBuffer>(struct_buffer.release());
288: 	} else if (internal_type == PhysicalType::LIST) {
289: 		auto list_buffer = make_uniq<VectorListBuffer>(type, capacity);
290: 		auxiliary = shared_ptr<VectorBuffer>(list_buffer.release());
291: 	} else if (internal_type == PhysicalType::ARRAY) {
292: 		auto array_buffer = make_uniq<VectorArrayBuffer>(type, capacity);
293: 		auxiliary = shared_ptr<VectorBuffer>(array_buffer.release());
294: 	}
295: 	auto type_size = GetTypeIdSize(internal_type);
296: 	if (type_size > 0) {
297: 		buffer = VectorBuffer::CreateStandardVector(type, capacity);
298: 		data = buffer->GetData();
299: 		if (zero_data) {
300: 			memset(data, 0, capacity * type_size);
301: 		}
302: 	}
303: 
304: 	if (capacity > validity.TargetCount()) {
305: 		validity.Resize(validity.TargetCount(), capacity);
306: 	}
307: }
308: 
309: void Vector::FindResizeInfos(vector<ResizeInfo> &resize_infos, const idx_t multiplier) {
310: 
311: 	ResizeInfo resize_info(*this, data, buffer.get(), multiplier);
312: 	resize_infos.emplace_back(resize_info);
313: 
314: 	// Base case.
315: 	if (data) {
316: 		return;
317: 	}
318: 
319: 	D_ASSERT(auxiliary);
320: 	switch (GetAuxiliary()->GetBufferType()) {
321: 	case VectorBufferType::LIST_BUFFER: {
322: 		auto &vector_list_buffer = auxiliary->Cast<VectorListBuffer>();
323: 		auto &child = vector_list_buffer.GetChild();
324: 		child.FindResizeInfos(resize_infos, multiplier);
325: 		break;
326: 	}
327: 	case VectorBufferType::STRUCT_BUFFER: {
328: 		auto &vector_struct_buffer = auxiliary->Cast<VectorStructBuffer>();
329: 		auto &children = vector_struct_buffer.GetChildren();
330: 		for (auto &child : children) {
331: 			child->FindResizeInfos(resize_infos, multiplier);
332: 		}
333: 		break;
334: 	}
335: 	case VectorBufferType::ARRAY_BUFFER: {
336: 		// We need to multiply the multiplier by the array size because
337: 		// the child vectors of ARRAY types are always child_count * array_size.
338: 		auto &vector_array_buffer = auxiliary->Cast<VectorArrayBuffer>();
339: 		auto new_multiplier = vector_array_buffer.GetArraySize() * multiplier;
340: 		auto &child = vector_array_buffer.GetChild();
341: 		child.FindResizeInfos(resize_infos, new_multiplier);
342: 		break;
343: 	}
344: 	default:
345: 		break;
346: 	}
347: }
348: 
349: void Vector::Resize(idx_t current_size, idx_t new_size) {
350: 	// The vector does not contain any data.
351: 	if (!buffer) {
352: 		buffer = make_buffer<VectorBuffer>(0);
353: 	}
354: 
355: 	// Obtain the resize information for each (nested) vector.
356: 	vector<ResizeInfo> resize_infos;
357: 	FindResizeInfos(resize_infos, 1);
358: 
359: 	for (auto &resize_info_entry : resize_infos) {
360: 		// Resize the validity mask.
361: 		auto new_validity_size = new_size * resize_info_entry.multiplier;
362: 		resize_info_entry.vec.validity.Resize(current_size, new_validity_size);
363: 
364: 		// For nested data types, we only need to resize the validity mask.
365: 		if (!resize_info_entry.data) {
366: 			continue;
367: 		}
368: 
369: 		auto type_size = GetTypeIdSize(resize_info_entry.vec.GetType().InternalType());
370: 		auto old_size = current_size * type_size * resize_info_entry.multiplier * sizeof(data_t);
371: 		auto target_size = new_size * type_size * resize_info_entry.multiplier * sizeof(data_t);
372: 
373: 		// We have an upper limit of 128GB for a single vector.
374: 		if (target_size > DConstants::MAX_VECTOR_SIZE) {
375: 			throw OutOfRangeException("Cannot resize vector to %s: maximum allowed vector size is %s",
376: 			                          StringUtil::BytesToHumanReadableString(target_size),
377: 			                          StringUtil::BytesToHumanReadableString(DConstants::MAX_VECTOR_SIZE));
378: 		}
379: 
380: 		// Copy the data buffer to a resized buffer.
381: 		auto new_data = make_unsafe_uniq_array<data_t>(target_size);
382: 		memcpy(new_data.get(), resize_info_entry.data, old_size);
383: 		resize_info_entry.buffer->SetData(std::move(new_data));
384: 		resize_info_entry.vec.data = resize_info_entry.buffer->GetData();
385: 	}
386: }
387: 
388: void Vector::SetValue(idx_t index, const Value &val) {
389: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
390: 		// dictionary: apply dictionary and forward to child
391: 		auto &sel_vector = DictionaryVector::SelVector(*this);
392: 		auto &child = DictionaryVector::Child(*this);
393: 		return child.SetValue(sel_vector.get_index(index), val);
394: 	}
395: 	if (val.type() != GetType()) {
396: 		SetValue(index, val.DefaultCastAs(GetType()));
397: 		return;
398: 	}
399: 	D_ASSERT(val.type().InternalType() == GetType().InternalType());
400: 
401: 	validity.EnsureWritable();
402: 	validity.Set(index, !val.IsNull());
403: 	auto physical_type = GetType().InternalType();
404: 	if (val.IsNull() && physical_type != PhysicalType::STRUCT && physical_type != PhysicalType::ARRAY) {
405: 		// for structs and arrays we still need to set the child-entries to NULL
406: 		// so we do not bail out yet
407: 		return;
408: 	}
409: 
410: 	switch (physical_type) {
411: 	case PhysicalType::BOOL:
412: 		reinterpret_cast<bool *>(data)[index] = val.GetValueUnsafe<bool>();
413: 		break;
414: 	case PhysicalType::INT8:
415: 		reinterpret_cast<int8_t *>(data)[index] = val.GetValueUnsafe<int8_t>();
416: 		break;
417: 	case PhysicalType::INT16:
418: 		reinterpret_cast<int16_t *>(data)[index] = val.GetValueUnsafe<int16_t>();
419: 		break;
420: 	case PhysicalType::INT32:
421: 		reinterpret_cast<int32_t *>(data)[index] = val.GetValueUnsafe<int32_t>();
422: 		break;
423: 	case PhysicalType::INT64:
424: 		reinterpret_cast<int64_t *>(data)[index] = val.GetValueUnsafe<int64_t>();
425: 		break;
426: 	case PhysicalType::INT128:
427: 		reinterpret_cast<hugeint_t *>(data)[index] = val.GetValueUnsafe<hugeint_t>();
428: 		break;
429: 	case PhysicalType::UINT8:
430: 		reinterpret_cast<uint8_t *>(data)[index] = val.GetValueUnsafe<uint8_t>();
431: 		break;
432: 	case PhysicalType::UINT16:
433: 		reinterpret_cast<uint16_t *>(data)[index] = val.GetValueUnsafe<uint16_t>();
434: 		break;
435: 	case PhysicalType::UINT32:
436: 		reinterpret_cast<uint32_t *>(data)[index] = val.GetValueUnsafe<uint32_t>();
437: 		break;
438: 	case PhysicalType::UINT64:
439: 		reinterpret_cast<uint64_t *>(data)[index] = val.GetValueUnsafe<uint64_t>();
440: 		break;
441: 	case PhysicalType::UINT128:
442: 		reinterpret_cast<uhugeint_t *>(data)[index] = val.GetValueUnsafe<uhugeint_t>();
443: 		break;
444: 	case PhysicalType::FLOAT:
445: 		reinterpret_cast<float *>(data)[index] = val.GetValueUnsafe<float>();
446: 		break;
447: 	case PhysicalType::DOUBLE:
448: 		reinterpret_cast<double *>(data)[index] = val.GetValueUnsafe<double>();
449: 		break;
450: 	case PhysicalType::INTERVAL:
451: 		reinterpret_cast<interval_t *>(data)[index] = val.GetValueUnsafe<interval_t>();
452: 		break;
453: 	case PhysicalType::VARCHAR:
454: 		reinterpret_cast<string_t *>(data)[index] = StringVector::AddStringOrBlob(*this, StringValue::Get(val));
455: 		break;
456: 	case PhysicalType::STRUCT: {
457: 		D_ASSERT(GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR);
458: 
459: 		auto &children = StructVector::GetEntries(*this);
460: 		if (val.IsNull()) {
461: 			for (size_t i = 0; i < children.size(); i++) {
462: 				auto &vec_child = children[i];
463: 				vec_child->SetValue(index, Value());
464: 			}
465: 		} else {
466: 			auto &val_children = StructValue::GetChildren(val);
467: 			D_ASSERT(children.size() == val_children.size());
468: 			for (size_t i = 0; i < children.size(); i++) {
469: 				auto &vec_child = children[i];
470: 				auto &struct_child = val_children[i];
471: 				vec_child->SetValue(index, struct_child);
472: 			}
473: 		}
474: 		break;
475: 	}
476: 	case PhysicalType::LIST: {
477: 		auto offset = ListVector::GetListSize(*this);
478: 		auto &val_children = ListValue::GetChildren(val);
479: 		if (!val_children.empty()) {
480: 			for (idx_t i = 0; i < val_children.size(); i++) {
481: 				ListVector::PushBack(*this, val_children[i]);
482: 			}
483: 		}
484: 		//! now set the pointer
485: 		auto &entry = reinterpret_cast<list_entry_t *>(data)[index];
486: 		entry.length = val_children.size();
487: 		entry.offset = offset;
488: 		break;
489: 	}
490: 	case PhysicalType::ARRAY: {
491: 		auto array_size = ArrayType::GetSize(GetType());
492: 		auto &child = ArrayVector::GetEntry(*this);
493: 		if (val.IsNull()) {
494: 			for (idx_t i = 0; i < array_size; i++) {
495: 				child.SetValue(index * array_size + i, Value());
496: 			}
497: 		} else {
498: 			auto &val_children = ArrayValue::GetChildren(val);
499: 			for (idx_t i = 0; i < array_size; i++) {
500: 				child.SetValue(index * array_size + i, val_children[i]);
501: 			}
502: 		}
503: 		break;
504: 	}
505: 	default:
506: 		throw InternalException("Unimplemented type for Vector::SetValue");
507: 	}
508: }
509: 
510: Value Vector::GetValueInternal(const Vector &v_p, idx_t index_p) {
511: 	const Vector *vector = &v_p;
512: 	idx_t index = index_p;
513: 	bool finished = false;
514: 	while (!finished) {
515: 		switch (vector->GetVectorType()) {
516: 		case VectorType::CONSTANT_VECTOR:
517: 			index = 0;
518: 			finished = true;
519: 			break;
520: 		case VectorType::FLAT_VECTOR:
521: 			finished = true;
522: 			break;
523: 		case VectorType::FSST_VECTOR:
524: 			finished = true;
525: 			break;
526: 		// dictionary: apply dictionary and forward to child
527: 		case VectorType::DICTIONARY_VECTOR: {
528: 			auto &sel_vector = DictionaryVector::SelVector(*vector);
529: 			auto &child = DictionaryVector::Child(*vector);
530: 			vector = &child;
531: 			index = sel_vector.get_index(index);
532: 			break;
533: 		}
534: 		case VectorType::SEQUENCE_VECTOR: {
535: 			int64_t start, increment;
536: 			SequenceVector::GetSequence(*vector, start, increment);
537: 			return Value::Numeric(vector->GetType(), start + increment * NumericCast<int64_t>(index));
538: 		}
539: 		default:
540: 			throw InternalException("Unimplemented vector type for Vector::GetValue");
541: 		}
542: 	}
543: 	auto data = vector->data;
544: 	auto &validity = vector->validity;
545: 	auto &type = vector->GetType();
546: 
547: 	if (!validity.RowIsValid(index)) {
548: 		return Value(vector->GetType());
549: 	}
550: 
551: 	if (vector->GetVectorType() == VectorType::FSST_VECTOR) {
552: 		if (vector->GetType().InternalType() != PhysicalType::VARCHAR) {
553: 			throw InternalException("FSST Vector with non-string datatype found!");
554: 		}
555: 		auto str_compressed = reinterpret_cast<string_t *>(data)[index];
556: 		Value result = FSSTPrimitives::DecompressValue(FSSTVector::GetDecoder(*vector), str_compressed.GetData(),
557: 		                                               str_compressed.GetSize());
558: 		return result;
559: 	}
560: 
561: 	switch (vector->GetType().id()) {
562: 	case LogicalTypeId::BOOLEAN:
563: 		return Value::BOOLEAN(reinterpret_cast<bool *>(data)[index]);
564: 	case LogicalTypeId::TINYINT:
565: 		return Value::TINYINT(reinterpret_cast<int8_t *>(data)[index]);
566: 	case LogicalTypeId::SMALLINT:
567: 		return Value::SMALLINT(reinterpret_cast<int16_t *>(data)[index]);
568: 	case LogicalTypeId::INTEGER:
569: 		return Value::INTEGER(reinterpret_cast<int32_t *>(data)[index]);
570: 	case LogicalTypeId::DATE:
571: 		return Value::DATE(reinterpret_cast<date_t *>(data)[index]);
572: 	case LogicalTypeId::TIME:
573: 		return Value::TIME(reinterpret_cast<dtime_t *>(data)[index]);
574: 	case LogicalTypeId::TIME_TZ:
575: 		return Value::TIMETZ(reinterpret_cast<dtime_tz_t *>(data)[index]);
576: 	case LogicalTypeId::BIGINT:
577: 		return Value::BIGINT(reinterpret_cast<int64_t *>(data)[index]);
578: 	case LogicalTypeId::UTINYINT:
579: 		return Value::UTINYINT(reinterpret_cast<uint8_t *>(data)[index]);
580: 	case LogicalTypeId::USMALLINT:
581: 		return Value::USMALLINT(reinterpret_cast<uint16_t *>(data)[index]);
582: 	case LogicalTypeId::UINTEGER:
583: 		return Value::UINTEGER(reinterpret_cast<uint32_t *>(data)[index]);
584: 	case LogicalTypeId::UBIGINT:
585: 		return Value::UBIGINT(reinterpret_cast<uint64_t *>(data)[index]);
586: 	case LogicalTypeId::TIMESTAMP:
587: 		return Value::TIMESTAMP(reinterpret_cast<timestamp_t *>(data)[index]);
588: 	case LogicalTypeId::TIMESTAMP_NS:
589: 		return Value::TIMESTAMPNS(reinterpret_cast<timestamp_t *>(data)[index]);
590: 	case LogicalTypeId::TIMESTAMP_MS:
591: 		return Value::TIMESTAMPMS(reinterpret_cast<timestamp_t *>(data)[index]);
592: 	case LogicalTypeId::TIMESTAMP_SEC:
593: 		return Value::TIMESTAMPSEC(reinterpret_cast<timestamp_t *>(data)[index]);
594: 	case LogicalTypeId::TIMESTAMP_TZ:
595: 		return Value::TIMESTAMPTZ(reinterpret_cast<timestamp_t *>(data)[index]);
596: 	case LogicalTypeId::HUGEINT:
597: 		return Value::HUGEINT(reinterpret_cast<hugeint_t *>(data)[index]);
598: 	case LogicalTypeId::UHUGEINT:
599: 		return Value::UHUGEINT(reinterpret_cast<uhugeint_t *>(data)[index]);
600: 	case LogicalTypeId::UUID:
601: 		return Value::UUID(reinterpret_cast<hugeint_t *>(data)[index]);
602: 	case LogicalTypeId::DECIMAL: {
603: 		auto width = DecimalType::GetWidth(type);
604: 		auto scale = DecimalType::GetScale(type);
605: 		switch (type.InternalType()) {
606: 		case PhysicalType::INT16:
607: 			return Value::DECIMAL(reinterpret_cast<int16_t *>(data)[index], width, scale);
608: 		case PhysicalType::INT32:
609: 			return Value::DECIMAL(reinterpret_cast<int32_t *>(data)[index], width, scale);
610: 		case PhysicalType::INT64:
611: 			return Value::DECIMAL(reinterpret_cast<int64_t *>(data)[index], width, scale);
612: 		case PhysicalType::INT128:
613: 			return Value::DECIMAL(reinterpret_cast<hugeint_t *>(data)[index], width, scale);
614: 		default:
615: 			throw InternalException("Physical type '%s' has a width bigger than 38, which is not supported",
616: 			                        TypeIdToString(type.InternalType()));
617: 		}
618: 	}
619: 	case LogicalTypeId::ENUM: {
620: 		switch (type.InternalType()) {
621: 		case PhysicalType::UINT8:
622: 			return Value::ENUM(reinterpret_cast<uint8_t *>(data)[index], type);
623: 		case PhysicalType::UINT16:
624: 			return Value::ENUM(reinterpret_cast<uint16_t *>(data)[index], type);
625: 		case PhysicalType::UINT32:
626: 			return Value::ENUM(reinterpret_cast<uint32_t *>(data)[index], type);
627: 		default:
628: 			throw InternalException("ENUM can only have unsigned integers as physical types");
629: 		}
630: 	}
631: 	case LogicalTypeId::POINTER:
632: 		return Value::POINTER(reinterpret_cast<uintptr_t *>(data)[index]);
633: 	case LogicalTypeId::FLOAT:
634: 		return Value::FLOAT(reinterpret_cast<float *>(data)[index]);
635: 	case LogicalTypeId::DOUBLE:
636: 		return Value::DOUBLE(reinterpret_cast<double *>(data)[index]);
637: 	case LogicalTypeId::INTERVAL:
638: 		return Value::INTERVAL(reinterpret_cast<interval_t *>(data)[index]);
639: 	case LogicalTypeId::VARCHAR: {
640: 		auto str = reinterpret_cast<string_t *>(data)[index];
641: 		return Value(str.GetString());
642: 	}
643: 	case LogicalTypeId::BLOB: {
644: 		auto str = reinterpret_cast<string_t *>(data)[index];
645: 		return Value::BLOB(const_data_ptr_cast(str.GetData()), str.GetSize());
646: 	}
647: 	case LogicalTypeId::AGGREGATE_STATE: {
648: 		auto str = reinterpret_cast<string_t *>(data)[index];
649: 		return Value::AGGREGATE_STATE(vector->GetType(), const_data_ptr_cast(str.GetData()), str.GetSize());
650: 	}
651: 	case LogicalTypeId::BIT: {
652: 		auto str = reinterpret_cast<string_t *>(data)[index];
653: 		return Value::BIT(const_data_ptr_cast(str.GetData()), str.GetSize());
654: 	}
655: 	case LogicalTypeId::MAP: {
656: 		auto offlen = reinterpret_cast<list_entry_t *>(data)[index];
657: 		auto &child_vec = ListVector::GetEntry(*vector);
658: 		duckdb::vector<Value> children;
659: 		for (idx_t i = offlen.offset; i < offlen.offset + offlen.length; i++) {
660: 			children.push_back(child_vec.GetValue(i));
661: 		}
662: 		return Value::MAP(ListType::GetChildType(type), std::move(children));
663: 	}
664: 	case LogicalTypeId::UNION: {
665: 		// Remember to pass the original index_p here so we dont slice twice when looking up the tag
666: 		// in case this is a dictionary vector
667: 		union_tag_t tag;
668: 		if (UnionVector::TryGetTag(*vector, index_p, tag)) {
669: 			auto value = UnionVector::GetMember(*vector, tag).GetValue(index_p);
670: 			auto members = UnionType::CopyMemberTypes(type);
671: 			return Value::UNION(members, tag, std::move(value));
672: 		} else {
673: 			return Value(vector->GetType());
674: 		}
675: 	}
676: 	case LogicalTypeId::STRUCT: {
677: 		// we can derive the value schema from the vector schema
678: 		auto &child_entries = StructVector::GetEntries(*vector);
679: 		child_list_t<Value> children;
680: 		for (idx_t child_idx = 0; child_idx < child_entries.size(); child_idx++) {
681: 			auto &struct_child = child_entries[child_idx];
682: 			children.push_back(make_pair(StructType::GetChildName(type, child_idx), struct_child->GetValue(index_p)));
683: 		}
684: 		return Value::STRUCT(std::move(children));
685: 	}
686: 	case LogicalTypeId::LIST: {
687: 		auto offlen = reinterpret_cast<list_entry_t *>(data)[index];
688: 		auto &child_vec = ListVector::GetEntry(*vector);
689: 		duckdb::vector<Value> children;
690: 		for (idx_t i = offlen.offset; i < offlen.offset + offlen.length; i++) {
691: 			children.push_back(child_vec.GetValue(i));
692: 		}
693: 		return Value::LIST(ListType::GetChildType(type), std::move(children));
694: 	}
695: 	case LogicalTypeId::ARRAY: {
696: 		auto stride = ArrayType::GetSize(type);
697: 		auto offset = index * stride;
698: 		auto &child_vec = ArrayVector::GetEntry(*vector);
699: 		duckdb::vector<Value> children;
700: 		for (idx_t i = offset; i < offset + stride; i++) {
701: 			children.push_back(child_vec.GetValue(i));
702: 		}
703: 		return Value::ARRAY(std::move(children));
704: 	}
705: 	default:
706: 		throw InternalException("Unimplemented type for value access");
707: 	}
708: }
709: 
710: Value Vector::GetValue(const Vector &v_p, idx_t index_p) {
711: 	auto value = GetValueInternal(v_p, index_p);
712: 	// set the alias of the type to the correct value, if there is a type alias
713: 	if (v_p.GetType().HasAlias()) {
714: 		value.GetTypeMutable().CopyAuxInfo(v_p.GetType());
715: 	}
716: 	if (v_p.GetType().id() != LogicalTypeId::AGGREGATE_STATE && value.type().id() != LogicalTypeId::AGGREGATE_STATE) {
717: 
718: 		D_ASSERT(v_p.GetType() == value.type());
719: 	}
720: 	return value;
721: }
722: 
723: Value Vector::GetValue(idx_t index) const {
724: 	return GetValue(*this, index);
725: }
726: 
727: // LCOV_EXCL_START
728: string VectorTypeToString(VectorType type) {
729: 	switch (type) {
730: 	case VectorType::FLAT_VECTOR:
731: 		return "FLAT";
732: 	case VectorType::FSST_VECTOR:
733: 		return "FSST";
734: 	case VectorType::SEQUENCE_VECTOR:
735: 		return "SEQUENCE";
736: 	case VectorType::DICTIONARY_VECTOR:
737: 		return "DICTIONARY";
738: 	case VectorType::CONSTANT_VECTOR:
739: 		return "CONSTANT";
740: 	default:
741: 		return "UNKNOWN";
742: 	}
743: }
744: 
745: string Vector::ToString(idx_t count) const {
746: 	string retval =
747: 	    VectorTypeToString(GetVectorType()) + " " + GetType().ToString() + ": " + to_string(count) + " = [ ";
748: 	switch (GetVectorType()) {
749: 	case VectorType::FLAT_VECTOR:
750: 	case VectorType::DICTIONARY_VECTOR:
751: 		for (idx_t i = 0; i < count; i++) {
752: 			retval += GetValue(i).ToString() + (i == count - 1 ? "" : ", ");
753: 		}
754: 		break;
755: 	case VectorType::FSST_VECTOR: {
756: 		for (idx_t i = 0; i < count; i++) {
757: 			string_t compressed_string = reinterpret_cast<string_t *>(data)[i];
758: 			Value val = FSSTPrimitives::DecompressValue(FSSTVector::GetDecoder(*this), compressed_string.GetData(),
759: 			                                            compressed_string.GetSize());
760: 			retval += GetValue(i).ToString() + (i == count - 1 ? "" : ", ");
761: 		}
762: 	} break;
763: 	case VectorType::CONSTANT_VECTOR:
764: 		retval += GetValue(0).ToString();
765: 		break;
766: 	case VectorType::SEQUENCE_VECTOR: {
767: 		int64_t start, increment;
768: 		SequenceVector::GetSequence(*this, start, increment);
769: 		for (idx_t i = 0; i < count; i++) {
770: 			retval += to_string(start + increment * UnsafeNumericCast<int64_t>(i)) + (i == count - 1 ? "" : ", ");
771: 		}
772: 		break;
773: 	}
774: 	default:
775: 		retval += "UNKNOWN VECTOR TYPE";
776: 		break;
777: 	}
778: 	retval += "]";
779: 	return retval;
780: }
781: 
782: void Vector::Print(idx_t count) const {
783: 	Printer::Print(ToString(count));
784: }
785: 
786: string Vector::ToString() const {
787: 	string retval = VectorTypeToString(GetVectorType()) + " " + GetType().ToString() + ": (UNKNOWN COUNT) [ ";
788: 	switch (GetVectorType()) {
789: 	case VectorType::FLAT_VECTOR:
790: 	case VectorType::DICTIONARY_VECTOR:
791: 		break;
792: 	case VectorType::CONSTANT_VECTOR:
793: 		retval += GetValue(0).ToString();
794: 		break;
795: 	case VectorType::SEQUENCE_VECTOR: {
796: 		break;
797: 	}
798: 	default:
799: 		retval += "UNKNOWN VECTOR TYPE";
800: 		break;
801: 	}
802: 	retval += "]";
803: 	return retval;
804: }
805: 
806: void Vector::Print() const {
807: 	Printer::Print(ToString());
808: }
809: // LCOV_EXCL_STOP
810: 
811: template <class T>
812: static void TemplatedFlattenConstantVector(data_ptr_t data, data_ptr_t old_data, idx_t count) {
813: 	auto constant = Load<T>(old_data);
814: 	auto output = (T *)data;
815: 	for (idx_t i = 0; i < count; i++) {
816: 		output[i] = constant;
817: 	}
818: }
819: 
820: void Vector::Flatten(idx_t count) {
821: 	switch (GetVectorType()) {
822: 	case VectorType::FLAT_VECTOR:
823: 		// already a flat vector
824: 		break;
825: 	case VectorType::FSST_VECTOR: {
826: 		// Even though count may only be a part of the vector, we need to flatten the whole thing due to the way
827: 		// ToUnifiedFormat uses flatten
828: 		idx_t total_count = FSSTVector::GetCount(*this);
829: 		// create vector to decompress into
830: 		Vector other(GetType(), total_count);
831: 		// now copy the data of this vector to the other vector, decompressing the strings in the process
832: 		VectorOperations::Copy(*this, other, total_count, 0, 0);
833: 		// create a reference to the data in the other vector
834: 		this->Reference(other);
835: 		break;
836: 	}
837: 	case VectorType::DICTIONARY_VECTOR: {
838: 		// create a new flat vector of this type
839: 		Vector other(GetType(), count);
840: 		// now copy the data of this vector to the other vector, removing the selection vector in the process
841: 		VectorOperations::Copy(*this, other, count, 0, 0);
842: 		// create a reference to the data in the other vector
843: 		this->Reference(other);
844: 		break;
845: 	}
846: 	case VectorType::CONSTANT_VECTOR: {
847: 		bool is_null = ConstantVector::IsNull(*this);
848: 		// allocate a new buffer for the vector
849: 		auto old_buffer = std::move(buffer);
850: 		auto old_data = data;
851: 		buffer = VectorBuffer::CreateStandardVector(type, MaxValue<idx_t>(STANDARD_VECTOR_SIZE, count));
852: 		if (old_buffer) {
853: 			D_ASSERT(buffer->GetAuxiliaryData() == nullptr);
854: 			// The old buffer might be relying on the auxiliary data, keep it alive
855: 			buffer->MoveAuxiliaryData(*old_buffer);
856: 		}
857: 		data = buffer->GetData();
858: 		vector_type = VectorType::FLAT_VECTOR;
859: 		if (is_null && GetType().InternalType() != PhysicalType::ARRAY) {
860: 			// constant NULL, set nullmask
861: 			validity.EnsureWritable();
862: 			validity.SetAllInvalid(count);
863: 			return;
864: 		}
865: 		// non-null constant: have to repeat the constant
866: 		switch (GetType().InternalType()) {
867: 		case PhysicalType::BOOL:
868: 			TemplatedFlattenConstantVector<bool>(data, old_data, count);
869: 			break;
870: 		case PhysicalType::INT8:
871: 			TemplatedFlattenConstantVector<int8_t>(data, old_data, count);
872: 			break;
873: 		case PhysicalType::INT16:
874: 			TemplatedFlattenConstantVector<int16_t>(data, old_data, count);
875: 			break;
876: 		case PhysicalType::INT32:
877: 			TemplatedFlattenConstantVector<int32_t>(data, old_data, count);
878: 			break;
879: 		case PhysicalType::INT64:
880: 			TemplatedFlattenConstantVector<int64_t>(data, old_data, count);
881: 			break;
882: 		case PhysicalType::UINT8:
883: 			TemplatedFlattenConstantVector<uint8_t>(data, old_data, count);
884: 			break;
885: 		case PhysicalType::UINT16:
886: 			TemplatedFlattenConstantVector<uint16_t>(data, old_data, count);
887: 			break;
888: 		case PhysicalType::UINT32:
889: 			TemplatedFlattenConstantVector<uint32_t>(data, old_data, count);
890: 			break;
891: 		case PhysicalType::UINT64:
892: 			TemplatedFlattenConstantVector<uint64_t>(data, old_data, count);
893: 			break;
894: 		case PhysicalType::INT128:
895: 			TemplatedFlattenConstantVector<hugeint_t>(data, old_data, count);
896: 			break;
897: 		case PhysicalType::UINT128:
898: 			TemplatedFlattenConstantVector<uhugeint_t>(data, old_data, count);
899: 			break;
900: 		case PhysicalType::FLOAT:
901: 			TemplatedFlattenConstantVector<float>(data, old_data, count);
902: 			break;
903: 		case PhysicalType::DOUBLE:
904: 			TemplatedFlattenConstantVector<double>(data, old_data, count);
905: 			break;
906: 		case PhysicalType::INTERVAL:
907: 			TemplatedFlattenConstantVector<interval_t>(data, old_data, count);
908: 			break;
909: 		case PhysicalType::VARCHAR:
910: 			TemplatedFlattenConstantVector<string_t>(data, old_data, count);
911: 			break;
912: 		case PhysicalType::LIST: {
913: 			TemplatedFlattenConstantVector<list_entry_t>(data, old_data, count);
914: 			break;
915: 		}
916: 		case PhysicalType::ARRAY: {
917: 			auto &original_child = ArrayVector::GetEntry(*this);
918: 			auto array_size = ArrayType::GetSize(GetType());
919: 			auto flattened_buffer = make_uniq<VectorArrayBuffer>(GetType(), count);
920: 			auto &new_child = flattened_buffer->GetChild();
921: 
922: 			// Fast path: The array is a constant null
923: 			if (is_null) {
924: 				// Invalidate the parent array
925: 				validity.SetAllInvalid(count);
926: 				// Also invalidate the new child array
927: 				new_child.validity.SetAllInvalid(count * array_size);
928: 				// Attach the flattened buffer and return
929: 				auxiliary = shared_ptr<VectorBuffer>(flattened_buffer.release());
930: 				return;
931: 			}
932: 
933: 			// Now we need to "unpack" the child vector.
934: 			// Basically, do this:
935: 			//
936: 			// | a1 | | 1 |      | a1 | | 1 |
937: 			//        | 2 |      | a2 | | 2 |
938: 			//	             =>    ..   | 1 |
939: 			//                          | 2 |
940: 			// 							 ...
941: 
942: 			auto child_vec = make_uniq<Vector>(original_child);
943: 			child_vec->Flatten(count * array_size);
944: 
945: 			// Create a selection vector
946: 			SelectionVector sel(count * array_size);
947: 			for (idx_t array_idx = 0; array_idx < count; array_idx++) {
948: 				for (idx_t elem_idx = 0; elem_idx < array_size; elem_idx++) {
949: 					auto position = array_idx * array_size + elem_idx;
950: 					// Broadcast the validity
951: 					if (FlatVector::IsNull(*child_vec, elem_idx)) {
952: 						FlatVector::SetNull(new_child, position, true);
953: 					}
954: 					sel.set_index(position, elem_idx);
955: 				}
956: 			}
957: 
958: 			// Copy over the data to the new buffer
959: 			VectorOperations::Copy(*child_vec, new_child, sel, count * array_size, 0, 0);
960: 			auxiliary = shared_ptr<VectorBuffer>(flattened_buffer.release());
961: 
962: 		} break;
963: 		case PhysicalType::STRUCT: {
964: 			auto normalified_buffer = make_uniq<VectorStructBuffer>();
965: 
966: 			auto &new_children = normalified_buffer->GetChildren();
967: 
968: 			auto &child_entries = StructVector::GetEntries(*this);
969: 			for (auto &child : child_entries) {
970: 				D_ASSERT(child->GetVectorType() == VectorType::CONSTANT_VECTOR);
971: 				auto vector = make_uniq<Vector>(*child);
972: 				vector->Flatten(count);
973: 				new_children.push_back(std::move(vector));
974: 			}
975: 			auxiliary = shared_ptr<VectorBuffer>(normalified_buffer.release());
976: 		} break;
977: 		default:
978: 			throw InternalException("Unimplemented type for VectorOperations::Flatten");
979: 		}
980: 		break;
981: 	}
982: 	case VectorType::SEQUENCE_VECTOR: {
983: 		int64_t start, increment, sequence_count;
984: 		SequenceVector::GetSequence(*this, start, increment, sequence_count);
985: 
986: 		buffer = VectorBuffer::CreateStandardVector(GetType());
987: 		data = buffer->GetData();
988: 		VectorOperations::GenerateSequence(*this, NumericCast<idx_t>(sequence_count), start, increment);
989: 		break;
990: 	}
991: 	default:
992: 		throw InternalException("Unimplemented type for normalify");
993: 	}
994: }
995: 
996: void Vector::Flatten(const SelectionVector &sel, idx_t count) {
997: 	switch (GetVectorType()) {
998: 	case VectorType::FLAT_VECTOR:
999: 		// already a flat vector
1000: 		break;
1001: 	case VectorType::FSST_VECTOR: {
1002: 		// create a new flat vector of this type
1003: 		Vector other(GetType(), count);
1004: 		// copy the data of this vector to the other vector, removing compression and selection vector in the process
1005: 		VectorOperations::Copy(*this, other, sel, count, 0, 0);
1006: 		// create a reference to the data in the other vector
1007: 		this->Reference(other);
1008: 		break;
1009: 	}
1010: 	case VectorType::SEQUENCE_VECTOR: {
1011: 		int64_t start, increment;
1012: 		SequenceVector::GetSequence(*this, start, increment);
1013: 
1014: 		buffer = VectorBuffer::CreateStandardVector(GetType());
1015: 		data = buffer->GetData();
1016: 		VectorOperations::GenerateSequence(*this, count, sel, start, increment);
1017: 		break;
1018: 	}
1019: 	default:
1020: 		throw InternalException("Unimplemented type for normalify with selection vector");
1021: 	}
1022: }
1023: 
1024: void Vector::ToUnifiedFormat(idx_t count, UnifiedVectorFormat &format) {
1025: 	switch (GetVectorType()) {
1026: 	case VectorType::DICTIONARY_VECTOR: {
1027: 		auto &sel = DictionaryVector::SelVector(*this);
1028: 		format.owned_sel.Initialize(sel);
1029: 		format.sel = &format.owned_sel;
1030: 
1031: 		auto &child = DictionaryVector::Child(*this);
1032: 		if (child.GetVectorType() == VectorType::FLAT_VECTOR) {
1033: 			format.data = FlatVector::GetData(child);
1034: 			format.validity = FlatVector::Validity(child);
1035: 		} else {
1036: 			// dictionary with non-flat child: create a new reference to the child and flatten it
1037: 			Vector child_vector(child);
1038: 			child_vector.Flatten(sel, count);
1039: 			auto new_aux = make_buffer<VectorChildBuffer>(std::move(child_vector));
1040: 
1041: 			format.data = FlatVector::GetData(new_aux->data);
1042: 			format.validity = FlatVector::Validity(new_aux->data);
1043: 			this->auxiliary = std::move(new_aux);
1044: 		}
1045: 		break;
1046: 	}
1047: 	case VectorType::CONSTANT_VECTOR:
1048: 		format.sel = ConstantVector::ZeroSelectionVector(count, format.owned_sel);
1049: 		format.data = ConstantVector::GetData(*this);
1050: 		format.validity = ConstantVector::Validity(*this);
1051: 		break;
1052: 	default:
1053: 		Flatten(count);
1054: 		format.sel = FlatVector::IncrementalSelectionVector();
1055: 		format.data = FlatVector::GetData(*this);
1056: 		format.validity = FlatVector::Validity(*this);
1057: 		break;
1058: 	}
1059: }
1060: 
1061: void Vector::RecursiveToUnifiedFormat(Vector &input, idx_t count, RecursiveUnifiedVectorFormat &data) {
1062: 
1063: 	input.ToUnifiedFormat(count, data.unified);
1064: 	data.logical_type = input.GetType();
1065: 
1066: 	if (input.GetType().InternalType() == PhysicalType::LIST) {
1067: 		auto &child = ListVector::GetEntry(input);
1068: 		auto child_count = ListVector::GetListSize(input);
1069: 		data.children.emplace_back();
1070: 		Vector::RecursiveToUnifiedFormat(child, child_count, data.children.back());
1071: 
1072: 	} else if (input.GetType().InternalType() == PhysicalType::ARRAY) {
1073: 		auto &child = ArrayVector::GetEntry(input);
1074: 		auto array_size = ArrayType::GetSize(input.GetType());
1075: 		auto child_count = count * array_size;
1076: 		data.children.emplace_back();
1077: 		Vector::RecursiveToUnifiedFormat(child, child_count, data.children.back());
1078: 
1079: 	} else if (input.GetType().InternalType() == PhysicalType::STRUCT) {
1080: 		auto &children = StructVector::GetEntries(input);
1081: 		for (idx_t i = 0; i < children.size(); i++) {
1082: 			data.children.emplace_back();
1083: 		}
1084: 		for (idx_t i = 0; i < children.size(); i++) {
1085: 			Vector::RecursiveToUnifiedFormat(*children[i], count, data.children[i]);
1086: 		}
1087: 	}
1088: }
1089: 
1090: void Vector::Sequence(int64_t start, int64_t increment, idx_t count) {
1091: 	this->vector_type = VectorType::SEQUENCE_VECTOR;
1092: 	this->buffer = make_buffer<VectorBuffer>(sizeof(int64_t) * 3);
1093: 	auto data = reinterpret_cast<int64_t *>(buffer->GetData());
1094: 	data[0] = start;
1095: 	data[1] = increment;
1096: 	data[2] = int64_t(count);
1097: 	validity.Reset();
1098: 	auxiliary.reset();
1099: }
1100: 
1101: // FIXME: This should ideally be const
1102: void Vector::Serialize(Serializer &serializer, idx_t count) {
1103: 	auto &logical_type = GetType();
1104: 
1105: 	UnifiedVectorFormat vdata;
1106: 	ToUnifiedFormat(count, vdata);
1107: 
1108: 	const bool all_valid = (count > 0) && !vdata.validity.AllValid();
1109: 	serializer.WriteProperty(100, "all_valid", all_valid);
1110: 	if (all_valid) {
1111: 		ValidityMask flat_mask(count);
1112: 		flat_mask.Initialize();
1113: 		for (idx_t i = 0; i < count; ++i) {
1114: 			auto row_idx = vdata.sel->get_index(i);
1115: 			flat_mask.Set(i, vdata.validity.RowIsValid(row_idx));
1116: 		}
1117: 		serializer.WriteProperty(101, "validity", const_data_ptr_cast(flat_mask.GetData()),
1118: 		                         flat_mask.ValidityMaskSize(count));
1119: 	}
1120: 	if (TypeIsConstantSize(logical_type.InternalType())) {
1121: 		// constant size type: simple copy
1122: 		idx_t write_size = GetTypeIdSize(logical_type.InternalType()) * count;
1123: 		auto ptr = make_unsafe_uniq_array<data_t>(write_size);
1124: 		VectorOperations::WriteToStorage(*this, count, ptr.get());
1125: 		serializer.WriteProperty(102, "data", ptr.get(), write_size);
1126: 	} else {
1127: 		switch (logical_type.InternalType()) {
1128: 		case PhysicalType::VARCHAR: {
1129: 			auto strings = UnifiedVectorFormat::GetData<string_t>(vdata);
1130: 
1131: 			// Serialize data as a list
1132: 			serializer.WriteList(102, "data", count, [&](Serializer::List &list, idx_t i) {
1133: 				auto idx = vdata.sel->get_index(i);
1134: 				auto str = !vdata.validity.RowIsValid(idx) ? NullValue<string_t>() : strings[idx];
1135: 				list.WriteElement(str);
1136: 			});
1137: 			break;
1138: 		}
1139: 		case PhysicalType::STRUCT: {
1140: 			auto &entries = StructVector::GetEntries(*this);
1141: 
1142: 			// Serialize entries as a list
1143: 			serializer.WriteList(103, "children", entries.size(), [&](Serializer::List &list, idx_t i) {
1144: 				list.WriteObject([&](Serializer &object) { entries[i]->Serialize(object, count); });
1145: 			});
1146: 			break;
1147: 		}
1148: 		case PhysicalType::LIST: {
1149: 			auto &child = ListVector::GetEntry(*this);
1150: 			auto list_size = ListVector::GetListSize(*this);
1151: 
1152: 			// serialize the list entries in a flat array
1153: 			auto entries = make_unsafe_uniq_array<list_entry_t>(count);
1154: 			auto source_array = UnifiedVectorFormat::GetData<list_entry_t>(vdata);
1155: 			for (idx_t i = 0; i < count; i++) {
1156: 				auto idx = vdata.sel->get_index(i);
1157: 				auto source = source_array[idx];
1158: 				entries[i].offset = source.offset;
1159: 				entries[i].length = source.length;
1160: 			}
1161: 			serializer.WriteProperty(104, "list_size", list_size);
1162: 			serializer.WriteList(105, "entries", count, [&](Serializer::List &list, idx_t i) {
1163: 				list.WriteObject([&](Serializer &object) {
1164: 					object.WriteProperty(100, "offset", entries[i].offset);
1165: 					object.WriteProperty(101, "length", entries[i].length);
1166: 				});
1167: 			});
1168: 			serializer.WriteObject(106, "child", [&](Serializer &object) { child.Serialize(object, list_size); });
1169: 			break;
1170: 		}
1171: 		case PhysicalType::ARRAY: {
1172: 			Vector serialized_vector(*this);
1173: 			serialized_vector.Flatten(count);
1174: 
1175: 			auto &child = ArrayVector::GetEntry(serialized_vector);
1176: 			auto array_size = ArrayType::GetSize(serialized_vector.GetType());
1177: 			auto child_size = array_size * count;
1178: 			serializer.WriteProperty<uint64_t>(103, "array_size", array_size);
1179: 			serializer.WriteObject(104, "child", [&](Serializer &object) { child.Serialize(object, child_size); });
1180: 			break;
1181: 		}
1182: 		default:
1183: 			throw InternalException("Unimplemented variable width type for Vector::Serialize!");
1184: 		}
1185: 	}
1186: }
1187: 
1188: void Vector::Deserialize(Deserializer &deserializer, idx_t count) {
1189: 	auto &logical_type = GetType();
1190: 
1191: 	auto &validity = FlatVector::Validity(*this);
1192: 	validity.Reset();
1193: 	const auto has_validity = deserializer.ReadProperty<bool>(100, "all_valid");
1194: 	if (has_validity) {
1195: 		validity.Initialize(MaxValue<idx_t>(count, STANDARD_VECTOR_SIZE));
1196: 		deserializer.ReadProperty(101, "validity", data_ptr_cast(validity.GetData()), validity.ValidityMaskSize(count));
1197: 	}
1198: 
1199: 	if (TypeIsConstantSize(logical_type.InternalType())) {
1200: 		// constant size type: read fixed amount of data
1201: 		auto column_size = GetTypeIdSize(logical_type.InternalType()) * count;
1202: 		auto ptr = make_unsafe_uniq_array<data_t>(column_size);
1203: 		deserializer.ReadProperty(102, "data", ptr.get(), column_size);
1204: 
1205: 		VectorOperations::ReadFromStorage(ptr.get(), count, *this);
1206: 	} else {
1207: 		switch (logical_type.InternalType()) {
1208: 		case PhysicalType::VARCHAR: {
1209: 			auto strings = FlatVector::GetData<string_t>(*this);
1210: 			deserializer.ReadList(102, "data", [&](Deserializer::List &list, idx_t i) {
1211: 				auto str = list.ReadElement<string>();
1212: 				if (validity.RowIsValid(i)) {
1213: 					strings[i] = StringVector::AddStringOrBlob(*this, str);
1214: 				}
1215: 			});
1216: 			break;
1217: 		}
1218: 		case PhysicalType::STRUCT: {
1219: 			auto &entries = StructVector::GetEntries(*this);
1220: 			// Deserialize entries as a list
1221: 			deserializer.ReadList(103, "children", [&](Deserializer::List &list, idx_t i) {
1222: 				list.ReadObject([&](Deserializer &obj) { entries[i]->Deserialize(obj, count); });
1223: 			});
1224: 			break;
1225: 		}
1226: 		case PhysicalType::LIST: {
1227: 			// Read the list size
1228: 			auto list_size = deserializer.ReadProperty<uint64_t>(104, "list_size");
1229: 			ListVector::Reserve(*this, list_size);
1230: 			ListVector::SetListSize(*this, list_size);
1231: 
1232: 			// Read the entries
1233: 			auto list_entries = FlatVector::GetData<list_entry_t>(*this);
1234: 			deserializer.ReadList(105, "entries", [&](Deserializer::List &list, idx_t i) {
1235: 				list.ReadObject([&](Deserializer &obj) {
1236: 					list_entries[i].offset = obj.ReadProperty<uint64_t>(100, "offset");
1237: 					list_entries[i].length = obj.ReadProperty<uint64_t>(101, "length");
1238: 				});
1239: 			});
1240: 
1241: 			// Read the child vector
1242: 			deserializer.ReadObject(106, "child", [&](Deserializer &obj) {
1243: 				auto &child = ListVector::GetEntry(*this);
1244: 				child.Deserialize(obj, list_size);
1245: 			});
1246: 			break;
1247: 		}
1248: 		case PhysicalType::ARRAY: {
1249: 			auto array_size = deserializer.ReadProperty<uint64_t>(103, "array_size");
1250: 			deserializer.ReadObject(104, "child", [&](Deserializer &obj) {
1251: 				auto &child = ArrayVector::GetEntry(*this);
1252: 				child.Deserialize(obj, array_size * count);
1253: 			});
1254: 			break;
1255: 		}
1256: 		default:
1257: 			throw InternalException("Unimplemented variable width type for Vector::Deserialize!");
1258: 		}
1259: 	}
1260: }
1261: 
1262: void Vector::SetVectorType(VectorType vector_type_p) {
1263: 	this->vector_type = vector_type_p;
1264: 	auto physical_type = GetType().InternalType();
1265: 	if (TypeIsConstantSize(physical_type) &&
1266: 	    (GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR)) {
1267: 		auxiliary.reset();
1268: 	}
1269: 	if (vector_type == VectorType::CONSTANT_VECTOR && physical_type == PhysicalType::STRUCT) {
1270: 		auto &entries = StructVector::GetEntries(*this);
1271: 		for (auto &entry : entries) {
1272: 			entry->SetVectorType(vector_type);
1273: 		}
1274: 	}
1275: }
1276: 
1277: void Vector::UTFVerify(const SelectionVector &sel, idx_t count) {
1278: #ifdef DEBUG
1279: 	if (count == 0) {
1280: 		return;
1281: 	}
1282: 	if (GetType().InternalType() == PhysicalType::VARCHAR) {
1283: 		// we just touch all the strings and let the sanitizer figure out if any
1284: 		// of them are deallocated/corrupt
1285: 		switch (GetVectorType()) {
1286: 		case VectorType::CONSTANT_VECTOR: {
1287: 			auto string = ConstantVector::GetData<string_t>(*this);
1288: 			if (!ConstantVector::IsNull(*this)) {
1289: 				string->Verify();
1290: 			}
1291: 			break;
1292: 		}
1293: 		case VectorType::FLAT_VECTOR: {
1294: 			auto strings = FlatVector::GetData<string_t>(*this);
1295: 			for (idx_t i = 0; i < count; i++) {
1296: 				auto oidx = sel.get_index(i);
1297: 				if (validity.RowIsValid(oidx)) {
1298: 					strings[oidx].Verify();
1299: 				}
1300: 			}
1301: 			break;
1302: 		}
1303: 		default:
1304: 			break;
1305: 		}
1306: 	}
1307: #endif
1308: }
1309: 
1310: void Vector::UTFVerify(idx_t count) {
1311: 	auto flat_sel = FlatVector::IncrementalSelectionVector();
1312: 
1313: 	UTFVerify(*flat_sel, count);
1314: }
1315: 
1316: void Vector::VerifyMap(Vector &vector_p, const SelectionVector &sel_p, idx_t count) {
1317: #ifdef DEBUG
1318: 	D_ASSERT(vector_p.GetType().id() == LogicalTypeId::MAP);
1319: 	auto &child = ListType::GetChildType(vector_p.GetType());
1320: 	D_ASSERT(StructType::GetChildCount(child) == 2);
1321: 	D_ASSERT(StructType::GetChildName(child, 0) == "key");
1322: 	D_ASSERT(StructType::GetChildName(child, 1) == "value");
1323: 
1324: 	auto valid_check = MapVector::CheckMapValidity(vector_p, count, sel_p);
1325: 	D_ASSERT(valid_check == MapInvalidReason::VALID);
1326: #endif // DEBUG
1327: }
1328: 
1329: void Vector::VerifyUnion(Vector &vector_p, const SelectionVector &sel_p, idx_t count) {
1330: #ifdef DEBUG
1331: 
1332: 	D_ASSERT(vector_p.GetType().id() == LogicalTypeId::UNION);
1333: 	auto valid_check = UnionVector::CheckUnionValidity(vector_p, count, sel_p);
1334: 	if (valid_check != UnionInvalidReason::VALID) {
1335: 		throw InternalException("Union not valid, reason: %s", EnumUtil::ToString(valid_check));
1336: 	}
1337: #endif // DEBUG
1338: }
1339: 
1340: void Vector::Verify(Vector &vector_p, const SelectionVector &sel_p, idx_t count) {
1341: #ifdef DEBUG
1342: 	if (count == 0) {
1343: 		return;
1344: 	}
1345: 	Vector *vector = &vector_p;
1346: 	const SelectionVector *sel = &sel_p;
1347: 	SelectionVector owned_sel;
1348: 	auto &type = vector->GetType();
1349: 	auto vtype = vector->GetVectorType();
1350: 	if (vector->GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1351: 		auto &child = DictionaryVector::Child(*vector);
1352: 		D_ASSERT(child.GetVectorType() != VectorType::DICTIONARY_VECTOR);
1353: 		auto &dict_sel = DictionaryVector::SelVector(*vector);
1354: 		// merge the selection vectors and verify the child
1355: 		auto new_buffer = dict_sel.Slice(*sel, count);
1356: 		owned_sel.Initialize(new_buffer);
1357: 		sel = &owned_sel;
1358: 		vector = &child;
1359: 		vtype = vector->GetVectorType();
1360: 	}
1361: 	if (TypeIsConstantSize(type.InternalType()) &&
1362: 	    (vtype == VectorType::CONSTANT_VECTOR || vtype == VectorType::FLAT_VECTOR)) {
1363: 		D_ASSERT(!vector->auxiliary);
1364: 	}
1365: 	if (type.id() == LogicalTypeId::VARCHAR) {
1366: 		// verify that the string is correct unicode
1367: 		switch (vtype) {
1368: 		case VectorType::FLAT_VECTOR: {
1369: 			auto &validity = FlatVector::Validity(*vector);
1370: 			auto strings = FlatVector::GetData<string_t>(*vector);
1371: 			for (idx_t i = 0; i < count; i++) {
1372: 				auto oidx = sel->get_index(i);
1373: 				if (validity.RowIsValid(oidx)) {
1374: 					strings[oidx].Verify();
1375: 				}
1376: 			}
1377: 			break;
1378: 		}
1379: 		default:
1380: 			break;
1381: 		}
1382: 	}
1383: 
1384: 	if (type.id() == LogicalTypeId::BIT) {
1385: 		switch (vtype) {
1386: 		case VectorType::FLAT_VECTOR: {
1387: 			auto &validity = FlatVector::Validity(*vector);
1388: 			auto strings = FlatVector::GetData<string_t>(*vector);
1389: 			for (idx_t i = 0; i < count; i++) {
1390: 				auto oidx = sel->get_index(i);
1391: 				if (validity.RowIsValid(oidx)) {
1392: 					auto buf = strings[oidx].GetData();
1393: 					D_ASSERT(*buf >= 0 && *buf < 8);
1394: 					Bit::Verify(strings[oidx]);
1395: 				}
1396: 			}
1397: 			break;
1398: 		}
1399: 		default:
1400: 			break;
1401: 		}
1402: 	}
1403: 
1404: 	if (type.InternalType() == PhysicalType::ARRAY) {
1405: 		// Arrays have the following invariants
1406: 		// 1. if the array vector is a CONSTANT_VECTOR
1407: 		//	1.1	The child vector is a FLAT_VECTOR with count = array_size
1408: 		//	1.2 OR The child vector is a CONSTANT_VECTOR and must be NULL
1409: 		//  1.3 OR The child vector is a CONSTANT_VECTOR and array_size = 1
1410: 		// 2. if the array vector is a FLAT_VECTOR, the child vector is a FLAT_VECTOR
1411: 		// 	2.2 the count of the child vector is array_size * (parent)count
1412: 
1413: 		auto &child = ArrayVector::GetEntry(*vector);
1414: 		auto array_size = ArrayType::GetSize(type);
1415: 
1416: 		if (child.GetVectorType() == VectorType::CONSTANT_VECTOR) {
1417: 			D_ASSERT(ConstantVector::IsNull(child));
1418: 		} else {
1419: 			D_ASSERT(child.GetVectorType() == VectorType::FLAT_VECTOR);
1420: 		}
1421: 
1422: 		if (vtype == VectorType::CONSTANT_VECTOR) {
1423: 			if (!ConstantVector::IsNull(*vector)) {
1424: 				child.Verify(array_size);
1425: 			}
1426: 		} else if (vtype == VectorType::FLAT_VECTOR) {
1427: 			// Flat vector case
1428: 			auto &validity = FlatVector::Validity(*vector);
1429: 			idx_t selected_child_count = 0;
1430: 			for (idx_t i = 0; i < count; i++) {
1431: 				auto oidx = sel->get_index(i);
1432: 				if (validity.RowIsValid(oidx)) {
1433: 					selected_child_count += array_size;
1434: 				}
1435: 			}
1436: 
1437: 			SelectionVector child_sel(selected_child_count);
1438: 			idx_t child_count = 0;
1439: 			for (idx_t i = 0; i < count; i++) {
1440: 				auto oidx = sel->get_index(i);
1441: 				if (validity.RowIsValid(oidx)) {
1442: 					for (idx_t j = 0; j < array_size; j++) {
1443: 						child_sel.set_index(child_count++, oidx * array_size + j);
1444: 					}
1445: 				}
1446: 			}
1447: 			Vector::Verify(child, child_sel, child_count);
1448: 		}
1449: 	}
1450: 
1451: 	if (type.InternalType() == PhysicalType::STRUCT) {
1452: 		auto &child_types = StructType::GetChildTypes(type);
1453: 		D_ASSERT(!child_types.empty());
1454: 		// create a selection vector of the non-null entries of the struct vector
1455: 		auto &children = StructVector::GetEntries(*vector);
1456: 		D_ASSERT(child_types.size() == children.size());
1457: 		for (idx_t child_idx = 0; child_idx < children.size(); child_idx++) {
1458: 			D_ASSERT(children[child_idx]->GetType() == child_types[child_idx].second);
1459: 			Vector::Verify(*children[child_idx], sel_p, count);
1460: 			if (vtype == VectorType::CONSTANT_VECTOR) {
1461: 				D_ASSERT(children[child_idx]->GetVectorType() == VectorType::CONSTANT_VECTOR);
1462: 				if (ConstantVector::IsNull(*vector)) {
1463: 					D_ASSERT(ConstantVector::IsNull(*children[child_idx]));
1464: 				}
1465: 			}
1466: 			if (vtype != VectorType::FLAT_VECTOR) {
1467: 				continue;
1468: 			}
1469: 			optional_ptr<ValidityMask> child_validity;
1470: 			SelectionVector owned_child_sel;
1471: 			const SelectionVector *child_sel = &owned_child_sel;
1472: 			if (children[child_idx]->GetVectorType() == VectorType::FLAT_VECTOR) {
1473: 				child_sel = FlatVector::IncrementalSelectionVector();
1474: 				child_validity = &FlatVector::Validity(*children[child_idx]);
1475: 			} else if (children[child_idx]->GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1476: 				auto &child = DictionaryVector::Child(*children[child_idx]);
1477: 				if (child.GetVectorType() != VectorType::FLAT_VECTOR) {
1478: 					continue;
1479: 				}
1480: 				child_validity = &FlatVector::Validity(child);
1481: 				child_sel = &DictionaryVector::SelVector(*children[child_idx]);
1482: 			} else if (children[child_idx]->GetVectorType() == VectorType::CONSTANT_VECTOR) {
1483: 				child_sel = ConstantVector::ZeroSelectionVector(count, owned_child_sel);
1484: 				child_validity = &ConstantVector::Validity(*children[child_idx]);
1485: 			} else {
1486: 				continue;
1487: 			}
1488: 			// for any NULL entry in the struct, the child should be NULL as well
1489: 			auto &validity = FlatVector::Validity(*vector);
1490: 			for (idx_t i = 0; i < count; i++) {
1491: 				auto index = sel->get_index(i);
1492: 				if (!validity.RowIsValid(index)) {
1493: 					auto child_index = child_sel->get_index(sel_p.get_index(i));
1494: 					D_ASSERT(!child_validity->RowIsValid(child_index));
1495: 				}
1496: 			}
1497: 		}
1498: 
1499: 		if (vector->GetType().id() == LogicalTypeId::UNION) {
1500: 			// Pass in raw vector
1501: 			VerifyUnion(vector_p, sel_p, count);
1502: 		}
1503: 	}
1504: 
1505: 	if (type.InternalType() == PhysicalType::LIST) {
1506: 		if (vtype == VectorType::CONSTANT_VECTOR) {
1507: 			if (!ConstantVector::IsNull(*vector)) {
1508: 				auto &child = ListVector::GetEntry(*vector);
1509: 				SelectionVector child_sel(ListVector::GetListSize(*vector));
1510: 				idx_t child_count = 0;
1511: 				auto le = ConstantVector::GetData<list_entry_t>(*vector);
1512: 				D_ASSERT(le->offset + le->length <= ListVector::GetListSize(*vector));
1513: 				for (idx_t k = 0; k < le->length; k++) {
1514: 					child_sel.set_index(child_count++, le->offset + k);
1515: 				}
1516: 				Vector::Verify(child, child_sel, child_count);
1517: 			}
1518: 		} else if (vtype == VectorType::FLAT_VECTOR) {
1519: 			auto &validity = FlatVector::Validity(*vector);
1520: 			auto &child = ListVector::GetEntry(*vector);
1521: 			auto child_size = ListVector::GetListSize(*vector);
1522: 			auto list_data = FlatVector::GetData<list_entry_t>(*vector);
1523: 			idx_t total_size = 0;
1524: 			for (idx_t i = 0; i < count; i++) {
1525: 				auto idx = sel->get_index(i);
1526: 				auto &le = list_data[idx];
1527: 				if (validity.RowIsValid(idx)) {
1528: 					D_ASSERT(le.offset + le.length <= child_size);
1529: 					total_size += le.length;
1530: 				}
1531: 			}
1532: 			SelectionVector child_sel(total_size);
1533: 			idx_t child_count = 0;
1534: 			for (idx_t i = 0; i < count; i++) {
1535: 				auto idx = sel->get_index(i);
1536: 				auto &le = list_data[idx];
1537: 				if (validity.RowIsValid(idx)) {
1538: 					D_ASSERT(le.offset + le.length <= child_size);
1539: 					for (idx_t k = 0; k < le.length; k++) {
1540: 						child_sel.set_index(child_count++, le.offset + k);
1541: 					}
1542: 				}
1543: 			}
1544: 			Vector::Verify(child, child_sel, child_count);
1545: 		}
1546: 
1547: 		if (vector->GetType().id() == LogicalTypeId::MAP) {
1548: 			VerifyMap(*vector, *sel, count);
1549: 		}
1550: 	}
1551: #endif
1552: }
1553: 
1554: void Vector::Verify(idx_t count) {
1555: 	auto flat_sel = FlatVector::IncrementalSelectionVector();
1556: 	Verify(*this, *flat_sel, count);
1557: }
1558: 
1559: void Vector::DebugTransformToDictionary(Vector &vector, idx_t count) {
1560: 	if (vector.GetVectorType() != VectorType::FLAT_VECTOR) {
1561: 		// only supported for flat vectors currently
1562: 		return;
1563: 	}
1564: 	// convert vector to dictionary vector
1565: 	// first create an inverted vector of twice the size with NULL values every other value
1566: 	// i.e. [1, 2, 3] is converted into [NULL, 3, NULL, 2, NULL, 1]
1567: 	idx_t verify_count = count * 2;
1568: 	SelectionVector inverted_sel(verify_count);
1569: 	idx_t offset = 0;
1570: 	for (idx_t i = 0; i < count; i++) {
1571: 		idx_t current_index = count - i - 1;
1572: 		inverted_sel.set_index(offset++, current_index);
1573: 		inverted_sel.set_index(offset++, current_index);
1574: 	}
1575: 	Vector inverted_vector(vector, inverted_sel, verify_count);
1576: 	inverted_vector.Flatten(verify_count);
1577: 	// now insert the NULL values at every other position
1578: 	for (idx_t i = 0; i < count; i++) {
1579: 		FlatVector::SetNull(inverted_vector, i * 2, true);
1580: 	}
1581: 	// construct the selection vector pointing towards the original values
1582: 	// we start at the back, (verify_count - 1) and move backwards
1583: 	SelectionVector original_sel(count);
1584: 	offset = 0;
1585: 	for (idx_t i = 0; i < count; i++) {
1586: 		original_sel.set_index(offset++, verify_count - 1 - i * 2);
1587: 	}
1588: 	// now slice the inverted vector with the inverted selection vector
1589: 	vector.Slice(inverted_vector, original_sel, count);
1590: 	vector.Verify(count);
1591: }
1592: 
1593: void Vector::DebugShuffleNestedVector(Vector &vector, idx_t count) {
1594: 	switch (vector.GetType().id()) {
1595: 	case LogicalTypeId::STRUCT: {
1596: 		auto &entries = StructVector::GetEntries(vector);
1597: 		// recurse into child elements
1598: 		for (auto &entry : entries) {
1599: 			Vector::DebugShuffleNestedVector(*entry, count);
1600: 		}
1601: 		break;
1602: 	}
1603: 	case LogicalTypeId::LIST: {
1604: 		if (vector.GetVectorType() != VectorType::FLAT_VECTOR) {
1605: 			break;
1606: 		}
1607: 		auto list_entries = FlatVector::GetData<list_entry_t>(vector);
1608: 		idx_t child_count = 0;
1609: 		for (idx_t r = 0; r < count; r++) {
1610: 			if (FlatVector::IsNull(vector, r)) {
1611: 				continue;
1612: 			}
1613: 			child_count += list_entries[r].length;
1614: 		}
1615: 		if (child_count == 0) {
1616: 			break;
1617: 		}
1618: 		auto &child_vector = ListVector::GetEntry(vector);
1619: 		// reverse the order of all lists
1620: 		SelectionVector child_sel(child_count);
1621: 		idx_t position = child_count;
1622: 		for (idx_t r = 0; r < count; r++) {
1623: 			if (FlatVector::IsNull(vector, r)) {
1624: 				continue;
1625: 			}
1626: 			// move this list to the back
1627: 			position -= list_entries[r].length;
1628: 			for (idx_t k = 0; k < list_entries[r].length; k++) {
1629: 				child_sel.set_index(position + k, list_entries[r].offset + k);
1630: 			}
1631: 			// adjust the offset to this new position
1632: 			list_entries[r].offset = position;
1633: 		}
1634: 		child_vector.Slice(child_sel, child_count);
1635: 		child_vector.Flatten(child_count);
1636: 		ListVector::SetListSize(vector, child_count);
1637: 
1638: 		// recurse into child elements
1639: 		Vector::DebugShuffleNestedVector(child_vector, child_count);
1640: 		break;
1641: 	}
1642: 	default:
1643: 		break;
1644: 	}
1645: }
1646: 
1647: //===--------------------------------------------------------------------===//
1648: // FlatVector
1649: //===--------------------------------------------------------------------===//
1650: void FlatVector::SetNull(Vector &vector, idx_t idx, bool is_null) {
1651: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR);
1652: 	vector.validity.Set(idx, !is_null);
1653: 	if (is_null) {
1654: 		auto &type = vector.GetType();
1655: 		auto internal_type = type.InternalType();
1656: 		if (internal_type == PhysicalType::STRUCT) {
1657: 			// set all child entries to null as well
1658: 			auto &entries = StructVector::GetEntries(vector);
1659: 			for (auto &entry : entries) {
1660: 				FlatVector::SetNull(*entry, idx, is_null);
1661: 			}
1662: 		} else if (internal_type == PhysicalType::ARRAY) {
1663: 			// set the child element in the array to null as well
1664: 			auto &child = ArrayVector::GetEntry(vector);
1665: 			auto array_size = ArrayType::GetSize(type);
1666: 			auto child_offset = idx * array_size;
1667: 			for (idx_t i = 0; i < array_size; i++) {
1668: 				FlatVector::SetNull(child, child_offset + i, is_null);
1669: 			}
1670: 		}
1671: 	}
1672: }
1673: 
1674: //===--------------------------------------------------------------------===//
1675: // ConstantVector
1676: //===--------------------------------------------------------------------===//
1677: void ConstantVector::SetNull(Vector &vector, bool is_null) {
1678: 	D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1679: 	vector.validity.Set(0, !is_null);
1680: 	if (is_null) {
1681: 		auto &type = vector.GetType();
1682: 		auto internal_type = type.InternalType();
1683: 		if (internal_type == PhysicalType::STRUCT) {
1684: 			// set all child entries to null as well
1685: 			auto &entries = StructVector::GetEntries(vector);
1686: 			for (auto &entry : entries) {
1687: 				entry->SetVectorType(VectorType::CONSTANT_VECTOR);
1688: 				ConstantVector::SetNull(*entry, is_null);
1689: 			}
1690: 		} else if (internal_type == PhysicalType::ARRAY) {
1691: 			auto &child = ArrayVector::GetEntry(vector);
1692: 			D_ASSERT(child.GetVectorType() == VectorType::CONSTANT_VECTOR ||
1693: 			         child.GetVectorType() == VectorType::FLAT_VECTOR);
1694: 			auto array_size = ArrayType::GetSize(type);
1695: 			if (child.GetVectorType() == VectorType::CONSTANT_VECTOR) {
1696: 				D_ASSERT(array_size == 1);
1697: 				ConstantVector::SetNull(child, is_null);
1698: 			} else {
1699: 				for (idx_t i = 0; i < array_size; i++) {
1700: 					FlatVector::SetNull(child, i, is_null);
1701: 				}
1702: 			}
1703: 		}
1704: 	}
1705: }
1706: 
1707: const SelectionVector *ConstantVector::ZeroSelectionVector(idx_t count, SelectionVector &owned_sel) {
1708: 	if (count <= STANDARD_VECTOR_SIZE) {
1709: 		return ConstantVector::ZeroSelectionVector();
1710: 	}
1711: 	owned_sel.Initialize(count);
1712: 	for (idx_t i = 0; i < count; i++) {
1713: 		owned_sel.set_index(i, 0);
1714: 	}
1715: 	return &owned_sel;
1716: }
1717: 
1718: void ConstantVector::Reference(Vector &vector, Vector &source, idx_t position, idx_t count) {
1719: 	auto &source_type = source.GetType();
1720: 	switch (source_type.InternalType()) {
1721: 	case PhysicalType::LIST: {
1722: 		// retrieve the list entry from the source vector
1723: 		UnifiedVectorFormat vdata;
1724: 		source.ToUnifiedFormat(count, vdata);
1725: 
1726: 		auto list_index = vdata.sel->get_index(position);
1727: 		if (!vdata.validity.RowIsValid(list_index)) {
1728: 			// list is null: create null value
1729: 			Value null_value(source_type);
1730: 			vector.Reference(null_value);
1731: 			break;
1732: 		}
1733: 
1734: 		auto list_data = UnifiedVectorFormat::GetData<list_entry_t>(vdata);
1735: 		auto list_entry = list_data[list_index];
1736: 
1737: 		// add the list entry as the first element of "vector"
1738: 		// FIXME: we only need to allocate space for 1 tuple here
1739: 		auto target_data = FlatVector::GetData<list_entry_t>(vector);
1740: 		target_data[0] = list_entry;
1741: 
1742: 		// create a reference to the child list of the source vector
1743: 		auto &child = ListVector::GetEntry(vector);
1744: 		child.Reference(ListVector::GetEntry(source));
1745: 
1746: 		ListVector::SetListSize(vector, ListVector::GetListSize(source));
1747: 		vector.SetVectorType(VectorType::CONSTANT_VECTOR);
1748: 		break;
1749: 	}
1750: 	case PhysicalType::ARRAY: {
1751: 		UnifiedVectorFormat vdata;
1752: 		source.ToUnifiedFormat(count, vdata);
1753: 		auto source_idx = vdata.sel->get_index(position);
1754: 		if (!vdata.validity.RowIsValid(source_idx)) {
1755: 			// list is null: create null value
1756: 			Value null_value(source_type);
1757: 			vector.Reference(null_value);
1758: 			break;
1759: 		}
1760: 
1761: 		// Reference the child vector
1762: 		auto &target_child = ArrayVector::GetEntry(vector);
1763: 		auto &source_child = ArrayVector::GetEntry(source);
1764: 		target_child.Reference(source_child);
1765: 
1766: 		// Only take the element at the given position
1767: 		auto array_size = ArrayType::GetSize(source_type);
1768: 		SelectionVector sel(array_size);
1769: 		for (idx_t i = 0; i < array_size; i++) {
1770: 			sel.set_index(i, array_size * source_idx + i);
1771: 		}
1772: 		target_child.Slice(sel, array_size);
1773: 		target_child.Flatten(array_size); // since its constant we only have to flatten this much
1774: 
1775: 		vector.SetVectorType(VectorType::CONSTANT_VECTOR);
1776: 		vector.validity.Set(0, true);
1777: 		break;
1778: 	}
1779: 	case PhysicalType::STRUCT: {
1780: 		UnifiedVectorFormat vdata;
1781: 		source.ToUnifiedFormat(count, vdata);
1782: 
1783: 		auto struct_index = vdata.sel->get_index(position);
1784: 		if (!vdata.validity.RowIsValid(struct_index)) {
1785: 			// null struct: create null value
1786: 			Value null_value(source_type);
1787: 			vector.Reference(null_value);
1788: 			break;
1789: 		}
1790: 
1791: 		// struct: pass constant reference into child entries
1792: 		auto &source_entries = StructVector::GetEntries(source);
1793: 		auto &target_entries = StructVector::GetEntries(vector);
1794: 		for (idx_t i = 0; i < source_entries.size(); i++) {
1795: 			ConstantVector::Reference(*target_entries[i], *source_entries[i], position, count);
1796: 		}
1797: 		vector.SetVectorType(VectorType::CONSTANT_VECTOR);
1798: 		vector.validity.Set(0, true);
1799: 		break;
1800: 	}
1801: 	default:
1802: 		// default behavior: get a value from the vector and reference it
1803: 		// this is not that expensive for scalar types
1804: 		auto value = source.GetValue(position);
1805: 		vector.Reference(value);
1806: 		D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1807: 		break;
1808: 	}
1809: }
1810: 
1811: //===--------------------------------------------------------------------===//
1812: // StringVector
1813: //===--------------------------------------------------------------------===//
1814: string_t StringVector::AddString(Vector &vector, const char *data, idx_t len) {
1815: 	return StringVector::AddString(vector, string_t(data, UnsafeNumericCast<uint32_t>(len)));
1816: }
1817: 
1818: string_t StringVector::AddStringOrBlob(Vector &vector, const char *data, idx_t len) {
1819: 	return StringVector::AddStringOrBlob(vector, string_t(data, UnsafeNumericCast<uint32_t>(len)));
1820: }
1821: 
1822: string_t StringVector::AddString(Vector &vector, const char *data) {
1823: 	return StringVector::AddString(vector, string_t(data, UnsafeNumericCast<uint32_t>(strlen(data))));
1824: }
1825: 
1826: string_t StringVector::AddString(Vector &vector, const string &data) {
1827: 	return StringVector::AddString(vector, string_t(data.c_str(), UnsafeNumericCast<uint32_t>(data.size())));
1828: }
1829: 
1830: string_t StringVector::AddString(Vector &vector, string_t data) {
1831: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::VARCHAR || vector.GetType().id() == LogicalTypeId::BIT);
1832: 	if (data.IsInlined()) {
1833: 		// string will be inlined: no need to store in string heap
1834: 		return data;
1835: 	}
1836: 	if (!vector.auxiliary) {
1837: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1838: 	}
1839: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1840: 	auto &string_buffer = vector.auxiliary->Cast<VectorStringBuffer>();
1841: 	return string_buffer.AddString(data);
1842: }
1843: 
1844: string_t StringVector::AddStringOrBlob(Vector &vector, string_t data) {
1845: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1846: 	if (data.IsInlined()) {
1847: 		// string will be inlined: no need to store in string heap
1848: 		return data;
1849: 	}
1850: 	if (!vector.auxiliary) {
1851: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1852: 	}
1853: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1854: 	auto &string_buffer = vector.auxiliary->Cast<VectorStringBuffer>();
1855: 	return string_buffer.AddBlob(data);
1856: }
1857: 
1858: string_t StringVector::EmptyString(Vector &vector, idx_t len) {
1859: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1860: 	if (len <= string_t::INLINE_LENGTH) {
1861: 		return string_t(UnsafeNumericCast<uint32_t>(len));
1862: 	}
1863: 	if (!vector.auxiliary) {
1864: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1865: 	}
1866: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1867: 	auto &string_buffer = vector.auxiliary->Cast<VectorStringBuffer>();
1868: 	return string_buffer.EmptyString(len);
1869: }
1870: 
1871: void StringVector::AddHandle(Vector &vector, BufferHandle handle) {
1872: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1873: 	if (!vector.auxiliary) {
1874: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1875: 	}
1876: 	auto &string_buffer = vector.auxiliary->Cast<VectorStringBuffer>();
1877: 	string_buffer.AddHeapReference(make_buffer<ManagedVectorBuffer>(std::move(handle)));
1878: }
1879: 
1880: void StringVector::AddBuffer(Vector &vector, buffer_ptr<VectorBuffer> buffer) {
1881: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1882: 	D_ASSERT(buffer.get() != vector.auxiliary.get());
1883: 	if (!vector.auxiliary) {
1884: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1885: 	}
1886: 	auto &string_buffer = vector.auxiliary->Cast<VectorStringBuffer>();
1887: 	string_buffer.AddHeapReference(std::move(buffer));
1888: }
1889: 
1890: void StringVector::AddHeapReference(Vector &vector, Vector &other) {
1891: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1892: 	D_ASSERT(other.GetType().InternalType() == PhysicalType::VARCHAR);
1893: 
1894: 	if (other.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1895: 		StringVector::AddHeapReference(vector, DictionaryVector::Child(other));
1896: 		return;
1897: 	}
1898: 	if (!other.auxiliary) {
1899: 		return;
1900: 	}
1901: 	StringVector::AddBuffer(vector, other.auxiliary);
1902: }
1903: 
1904: //===--------------------------------------------------------------------===//
1905: // FSSTVector
1906: //===--------------------------------------------------------------------===//
1907: string_t FSSTVector::AddCompressedString(Vector &vector, const char *data, idx_t len) {
1908: 	return FSSTVector::AddCompressedString(vector, string_t(data, UnsafeNumericCast<uint32_t>(len)));
1909: }
1910: 
1911: string_t FSSTVector::AddCompressedString(Vector &vector, string_t data) {
1912: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1913: 	if (data.IsInlined()) {
1914: 		// string will be inlined: no need to store in string heap
1915: 		return data;
1916: 	}
1917: 	if (!vector.auxiliary) {
1918: 		vector.auxiliary = make_buffer<VectorFSSTStringBuffer>();
1919: 	}
1920: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::FSST_BUFFER);
1921: 	auto &fsst_string_buffer = vector.auxiliary->Cast<VectorFSSTStringBuffer>();
1922: 	return fsst_string_buffer.AddBlob(data);
1923: }
1924: 
1925: void *FSSTVector::GetDecoder(const Vector &vector) {
1926: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1927: 	if (!vector.auxiliary) {
1928: 		throw InternalException("GetDecoder called on FSST Vector without registered buffer");
1929: 	}
1930: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::FSST_BUFFER);
1931: 	auto &fsst_string_buffer = vector.auxiliary->Cast<VectorFSSTStringBuffer>();
1932: 	return fsst_string_buffer.GetDecoder();
1933: }
1934: 
1935: void FSSTVector::RegisterDecoder(Vector &vector, buffer_ptr<void> &duckdb_fsst_decoder) {
1936: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1937: 
1938: 	if (!vector.auxiliary) {
1939: 		vector.auxiliary = make_buffer<VectorFSSTStringBuffer>();
1940: 	}
1941: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::FSST_BUFFER);
1942: 
1943: 	auto &fsst_string_buffer = vector.auxiliary->Cast<VectorFSSTStringBuffer>();
1944: 	fsst_string_buffer.AddDecoder(duckdb_fsst_decoder);
1945: }
1946: 
1947: void FSSTVector::SetCount(Vector &vector, idx_t count) {
1948: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1949: 
1950: 	if (!vector.auxiliary) {
1951: 		vector.auxiliary = make_buffer<VectorFSSTStringBuffer>();
1952: 	}
1953: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::FSST_BUFFER);
1954: 
1955: 	auto &fsst_string_buffer = vector.auxiliary->Cast<VectorFSSTStringBuffer>();
1956: 	fsst_string_buffer.SetCount(count);
1957: }
1958: 
1959: idx_t FSSTVector::GetCount(Vector &vector) {
1960: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1961: 
1962: 	if (!vector.auxiliary) {
1963: 		vector.auxiliary = make_buffer<VectorFSSTStringBuffer>();
1964: 	}
1965: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::FSST_BUFFER);
1966: 
1967: 	auto &fsst_string_buffer = vector.auxiliary->Cast<VectorFSSTStringBuffer>();
1968: 	return fsst_string_buffer.GetCount();
1969: }
1970: 
1971: void FSSTVector::DecompressVector(const Vector &src, Vector &dst, idx_t src_offset, idx_t dst_offset, idx_t copy_count,
1972:                                   const SelectionVector *sel) {
1973: 	D_ASSERT(src.GetVectorType() == VectorType::FSST_VECTOR);
1974: 	D_ASSERT(dst.GetVectorType() == VectorType::FLAT_VECTOR);
1975: 	auto dst_mask = FlatVector::Validity(dst);
1976: 	auto ldata = FSSTVector::GetCompressedData<string_t>(src);
1977: 	auto tdata = FlatVector::GetData<string_t>(dst);
1978: 	for (idx_t i = 0; i < copy_count; i++) {
1979: 		auto source_idx = sel->get_index(src_offset + i);
1980: 		auto target_idx = dst_offset + i;
1981: 		string_t compressed_string = ldata[source_idx];
1982: 		if (dst_mask.RowIsValid(target_idx) && compressed_string.GetSize() > 0) {
1983: 			tdata[target_idx] = FSSTPrimitives::DecompressValue(
1984: 			    FSSTVector::GetDecoder(src), dst, compressed_string.GetData(), compressed_string.GetSize());
1985: 		} else {
1986: 			tdata[target_idx] = string_t(nullptr, 0);
1987: 		}
1988: 	}
1989: }
1990: 
1991: //===--------------------------------------------------------------------===//
1992: // MapVector
1993: //===--------------------------------------------------------------------===//
1994: Vector &MapVector::GetKeys(Vector &vector) {
1995: 	auto &entries = StructVector::GetEntries(ListVector::GetEntry(vector));
1996: 	D_ASSERT(entries.size() == 2);
1997: 	return *entries[0];
1998: }
1999: Vector &MapVector::GetValues(Vector &vector) {
2000: 	auto &entries = StructVector::GetEntries(ListVector::GetEntry(vector));
2001: 	D_ASSERT(entries.size() == 2);
2002: 	return *entries[1];
2003: }
2004: 
2005: const Vector &MapVector::GetKeys(const Vector &vector) {
2006: 	return GetKeys((Vector &)vector);
2007: }
2008: const Vector &MapVector::GetValues(const Vector &vector) {
2009: 	return GetValues((Vector &)vector);
2010: }
2011: 
2012: MapInvalidReason MapVector::CheckMapValidity(Vector &map, idx_t count, const SelectionVector &sel) {
2013: 
2014: 	D_ASSERT(map.GetType().id() == LogicalTypeId::MAP);
2015: 
2016: 	// unify the MAP vector, which is a physical LIST vector
2017: 	UnifiedVectorFormat map_data;
2018: 	map.ToUnifiedFormat(count, map_data);
2019: 	auto map_entries = UnifiedVectorFormat::GetDataNoConst<list_entry_t>(map_data);
2020: 	auto maps_length = ListVector::GetListSize(map);
2021: 
2022: 	// unify the child vector containing the keys
2023: 	auto &keys = MapVector::GetKeys(map);
2024: 	UnifiedVectorFormat key_data;
2025: 	keys.ToUnifiedFormat(maps_length, key_data);
2026: 
2027: 	for (idx_t row_idx = 0; row_idx < count; row_idx++) {
2028: 
2029: 		auto mapped_row = sel.get_index(row_idx);
2030: 		auto map_idx = map_data.sel->get_index(mapped_row);
2031: 
2032: 		if (!map_data.validity.RowIsValid(map_idx)) {
2033: 			continue;
2034: 		}
2035: 
2036: 		value_set_t unique_keys;
2037: 		auto length = map_entries[map_idx].length;
2038: 		auto offset = map_entries[map_idx].offset;
2039: 
2040: 		for (idx_t child_idx = 0; child_idx < length; child_idx++) {
2041: 			auto key_idx = key_data.sel->get_index(offset + child_idx);
2042: 
2043: 			if (!key_data.validity.RowIsValid(key_idx)) {
2044: 				return MapInvalidReason::NULL_KEY;
2045: 			}
2046: 
2047: 			auto value = keys.GetValue(key_idx);
2048: 			auto unique = unique_keys.insert(value).second;
2049: 			if (!unique) {
2050: 				return MapInvalidReason::DUPLICATE_KEY;
2051: 			}
2052: 		}
2053: 	}
2054: 
2055: 	return MapInvalidReason::VALID;
2056: }
2057: 
2058: void MapVector::MapConversionVerify(Vector &vector, idx_t count) {
2059: 	auto reason = MapVector::CheckMapValidity(vector, count);
2060: 	EvalMapInvalidReason(reason);
2061: }
2062: 
2063: void MapVector::EvalMapInvalidReason(MapInvalidReason reason) {
2064: 	switch (reason) {
2065: 	case MapInvalidReason::VALID:
2066: 		return;
2067: 	case MapInvalidReason::DUPLICATE_KEY:
2068: 		throw InvalidInputException("Map keys must be unique.");
2069: 	case MapInvalidReason::NULL_KEY:
2070: 		throw InvalidInputException("Map keys can not be NULL.");
2071: 	case MapInvalidReason::NOT_ALIGNED:
2072: 		throw InvalidInputException("The map key list does not align with the map value list.");
2073: 	case MapInvalidReason::INVALID_PARAMS:
2074: 		throw InvalidInputException("Invalid map argument(s). Valid map arguments are a list of key-value pairs (MAP "
2075: 		                            "{'key1': 'val1', ...}), two lists (MAP ([1, 2], [10, 11])), or no arguments.");
2076: 	default:
2077: 		throw InternalException("MapInvalidReason not implemented");
2078: 	}
2079: }
2080: 
2081: //===--------------------------------------------------------------------===//
2082: // StructVector
2083: //===--------------------------------------------------------------------===//
2084: vector<unique_ptr<Vector>> &StructVector::GetEntries(Vector &vector) {
2085: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::STRUCT || vector.GetType().id() == LogicalTypeId::UNION);
2086: 
2087: 	if (vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
2088: 		auto &child = DictionaryVector::Child(vector);
2089: 		return StructVector::GetEntries(child);
2090: 	}
2091: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
2092: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
2093: 	D_ASSERT(vector.auxiliary);
2094: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRUCT_BUFFER);
2095: 	return vector.auxiliary->Cast<VectorStructBuffer>().GetChildren();
2096: }
2097: 
2098: const vector<unique_ptr<Vector>> &StructVector::GetEntries(const Vector &vector) {
2099: 	return GetEntries((Vector &)vector);
2100: }
2101: 
2102: //===--------------------------------------------------------------------===//
2103: // ListVector
2104: //===--------------------------------------------------------------------===//
2105: template <class T>
2106: T &ListVector::GetEntryInternal(T &vector) {
2107: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST || vector.GetType().id() == LogicalTypeId::MAP);
2108: 	if (vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
2109: 		auto &child = DictionaryVector::Child(vector);
2110: 		return ListVector::GetEntry(child);
2111: 	}
2112: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
2113: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
2114: 	D_ASSERT(vector.auxiliary);
2115: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::LIST_BUFFER);
2116: 	return vector.auxiliary->template Cast<VectorListBuffer>().GetChild();
2117: }
2118: 
2119: const Vector &ListVector::GetEntry(const Vector &vector) {
2120: 	return GetEntryInternal<const Vector>(vector);
2121: }
2122: 
2123: Vector &ListVector::GetEntry(Vector &vector) {
2124: 	return GetEntryInternal<Vector>(vector);
2125: }
2126: 
2127: void ListVector::Reserve(Vector &vector, idx_t required_capacity) {
2128: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST || vector.GetType().id() == LogicalTypeId::MAP);
2129: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
2130: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
2131: 	D_ASSERT(vector.auxiliary);
2132: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::LIST_BUFFER);
2133: 	auto &child_buffer = vector.auxiliary->Cast<VectorListBuffer>();
2134: 	child_buffer.Reserve(required_capacity);
2135: }
2136: 
2137: idx_t ListVector::GetListSize(const Vector &vec) {
2138: 	if (vec.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
2139: 		auto &child = DictionaryVector::Child(vec);
2140: 		return ListVector::GetListSize(child);
2141: 	}
2142: 	D_ASSERT(vec.auxiliary);
2143: 	return vec.auxiliary->Cast<VectorListBuffer>().GetSize();
2144: }
2145: 
2146: idx_t ListVector::GetListCapacity(const Vector &vec) {
2147: 	if (vec.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
2148: 		auto &child = DictionaryVector::Child(vec);
2149: 		return ListVector::GetListSize(child);
2150: 	}
2151: 	D_ASSERT(vec.auxiliary);
2152: 	return vec.auxiliary->Cast<VectorListBuffer>().GetCapacity();
2153: }
2154: 
2155: void ListVector::ReferenceEntry(Vector &vector, Vector &other) {
2156: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST);
2157: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
2158: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
2159: 	D_ASSERT(other.GetType().id() == LogicalTypeId::LIST);
2160: 	D_ASSERT(other.GetVectorType() == VectorType::FLAT_VECTOR || other.GetVectorType() == VectorType::CONSTANT_VECTOR);
2161: 	vector.auxiliary = other.auxiliary;
2162: }
2163: 
2164: void ListVector::SetListSize(Vector &vec, idx_t size) {
2165: 	if (vec.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
2166: 		auto &child = DictionaryVector::Child(vec);
2167: 		ListVector::SetListSize(child, size);
2168: 		return;
2169: 	}
2170: 	vec.auxiliary->Cast<VectorListBuffer>().SetSize(size);
2171: }
2172: 
2173: void ListVector::Append(Vector &target, const Vector &source, idx_t source_size, idx_t source_offset) {
2174: 	if (source_size - source_offset == 0) {
2175: 		//! Nothing to add
2176: 		return;
2177: 	}
2178: 	auto &target_buffer = target.auxiliary->Cast<VectorListBuffer>();
2179: 	target_buffer.Append(source, source_size, source_offset);
2180: }
2181: 
2182: void ListVector::Append(Vector &target, const Vector &source, const SelectionVector &sel, idx_t source_size,
2183:                         idx_t source_offset) {
2184: 	if (source_size - source_offset == 0) {
2185: 		//! Nothing to add
2186: 		return;
2187: 	}
2188: 	auto &target_buffer = target.auxiliary->Cast<VectorListBuffer>();
2189: 	target_buffer.Append(source, sel, source_size, source_offset);
2190: }
2191: 
2192: void ListVector::PushBack(Vector &target, const Value &insert) {
2193: 	auto &target_buffer = target.auxiliary->Cast<VectorListBuffer>();
2194: 	target_buffer.PushBack(insert);
2195: }
2196: 
2197: idx_t ListVector::GetConsecutiveChildList(Vector &list, Vector &result, idx_t offset, idx_t count) {
2198: 
2199: 	auto info = ListVector::GetConsecutiveChildListInfo(list, offset, count);
2200: 	if (info.needs_slicing) {
2201: 		SelectionVector sel(info.child_list_info.length);
2202: 		ListVector::GetConsecutiveChildSelVector(list, sel, offset, count);
2203: 
2204: 		result.Slice(sel, info.child_list_info.length);
2205: 		result.Flatten(info.child_list_info.length);
2206: 	}
2207: 	return info.child_list_info.length;
2208: }
2209: 
2210: ConsecutiveChildListInfo ListVector::GetConsecutiveChildListInfo(Vector &list, idx_t offset, idx_t count) {
2211: 
2212: 	ConsecutiveChildListInfo info;
2213: 	UnifiedVectorFormat unified_list_data;
2214: 	list.ToUnifiedFormat(offset + count, unified_list_data);
2215: 	auto list_data = UnifiedVectorFormat::GetData<list_entry_t>(unified_list_data);
2216: 
2217: 	// find the first non-NULL entry
2218: 	idx_t first_length = 0;
2219: 	for (idx_t i = offset; i < offset + count; i++) {
2220: 		auto idx = unified_list_data.sel->get_index(i);
2221: 		if (!unified_list_data.validity.RowIsValid(idx)) {
2222: 			continue;
2223: 		}
2224: 		info.child_list_info.offset = list_data[idx].offset;
2225: 		first_length = list_data[idx].length;
2226: 		break;
2227: 	}
2228: 
2229: 	// small performance improvement for constant vectors
2230: 	// avoids iterating over all their (constant) elements
2231: 	if (list.GetVectorType() == VectorType::CONSTANT_VECTOR) {
2232: 		info.child_list_info.length = first_length;
2233: 		return info;
2234: 	}
2235: 
2236: 	// now get the child count and determine whether the children are stored consecutively
2237: 	// also determine if a flat vector has pseudo constant values (all offsets + length the same)
2238: 	// this can happen e.g. for UNNESTs
2239: 	bool is_consecutive = true;
2240: 	for (idx_t i = offset; i < offset + count; i++) {
2241: 		auto idx = unified_list_data.sel->get_index(i);
2242: 		if (!unified_list_data.validity.RowIsValid(idx)) {
2243: 			continue;
2244: 		}
2245: 		if (list_data[idx].offset != info.child_list_info.offset || list_data[idx].length != first_length) {
2246: 			info.is_constant = false;
2247: 		}
2248: 		if (list_data[idx].offset != info.child_list_info.offset + info.child_list_info.length) {
2249: 			is_consecutive = false;
2250: 		}
2251: 		info.child_list_info.length += list_data[idx].length;
2252: 	}
2253: 
2254: 	if (info.is_constant) {
2255: 		info.child_list_info.length = first_length;
2256: 	}
2257: 	if (!info.is_constant && !is_consecutive) {
2258: 		info.needs_slicing = true;
2259: 	}
2260: 
2261: 	return info;
2262: }
2263: 
2264: void ListVector::GetConsecutiveChildSelVector(Vector &list, SelectionVector &sel, idx_t offset, idx_t count) {
2265: 	UnifiedVectorFormat unified_list_data;
2266: 	list.ToUnifiedFormat(offset + count, unified_list_data);
2267: 	auto list_data = UnifiedVectorFormat::GetData<list_entry_t>(unified_list_data);
2268: 
2269: 	//	SelectionVector child_sel(info.second.length);
2270: 	idx_t entry = 0;
2271: 	for (idx_t i = offset; i < offset + count; i++) {
2272: 		auto idx = unified_list_data.sel->get_index(i);
2273: 		if (!unified_list_data.validity.RowIsValid(idx)) {
2274: 			continue;
2275: 		}
2276: 		for (idx_t k = 0; k < list_data[idx].length; k++) {
2277: 			//			child_sel.set_index(entry++, list_data[idx].offset + k);
2278: 			sel.set_index(entry++, list_data[idx].offset + k);
2279: 		}
2280: 	}
2281: 	//
2282: 	//	result.Slice(child_sel, info.second.length);
2283: 	//	result.Flatten(info.second.length);
2284: 	//	info.second.offset = 0;
2285: }
2286: 
2287: //===--------------------------------------------------------------------===//
2288: // UnionVector
2289: //===--------------------------------------------------------------------===//
2290: const Vector &UnionVector::GetMember(const Vector &vector, idx_t member_index) {
2291: 	D_ASSERT(member_index < UnionType::GetMemberCount(vector.GetType()));
2292: 	auto &entries = StructVector::GetEntries(vector);
2293: 	return *entries[member_index + 1]; // skip the "tag" entry
2294: }
2295: 
2296: Vector &UnionVector::GetMember(Vector &vector, idx_t member_index) {
2297: 	D_ASSERT(member_index < UnionType::GetMemberCount(vector.GetType()));
2298: 	auto &entries = StructVector::GetEntries(vector);
2299: 	return *entries[member_index + 1]; // skip the "tag" entry
2300: }
2301: 
2302: const Vector &UnionVector::GetTags(const Vector &vector) {
2303: 	// the tag vector is always the first struct child.
2304: 	return *StructVector::GetEntries(vector)[0];
2305: }
2306: 
2307: Vector &UnionVector::GetTags(Vector &vector) {
2308: 	// the tag vector is always the first struct child.
2309: 	return *StructVector::GetEntries(vector)[0];
2310: }
2311: 
2312: void UnionVector::SetToMember(Vector &union_vector, union_tag_t tag, Vector &member_vector, idx_t count,
2313:                               bool keep_tags_for_null) {
2314: 	D_ASSERT(union_vector.GetType().id() == LogicalTypeId::UNION);
2315: 	D_ASSERT(tag < UnionType::GetMemberCount(union_vector.GetType()));
2316: 
2317: 	// Set the union member to the specified vector
2318: 	UnionVector::GetMember(union_vector, tag).Reference(member_vector);
2319: 	auto &tag_vector = UnionVector::GetTags(union_vector);
2320: 
2321: 	if (member_vector.GetVectorType() == VectorType::CONSTANT_VECTOR) {
2322: 		// if the member vector is constant, we can set the union to constant as well
2323: 		union_vector.SetVectorType(VectorType::CONSTANT_VECTOR);
2324: 		ConstantVector::GetData<union_tag_t>(tag_vector)[0] = tag;
2325: 		if (keep_tags_for_null) {
2326: 			ConstantVector::SetNull(union_vector, false);
2327: 			ConstantVector::SetNull(tag_vector, false);
2328: 		} else {
2329: 			ConstantVector::SetNull(union_vector, ConstantVector::IsNull(member_vector));
2330: 			ConstantVector::SetNull(tag_vector, ConstantVector::IsNull(member_vector));
2331: 		}
2332: 
2333: 	} else {
2334: 		// otherwise flatten and set to flatvector
2335: 		member_vector.Flatten(count);
2336: 		union_vector.SetVectorType(VectorType::FLAT_VECTOR);
2337: 
2338: 		if (member_vector.validity.AllValid()) {
2339: 			// if the member vector is all valid, we can set the tag to constant
2340: 			tag_vector.SetVectorType(VectorType::CONSTANT_VECTOR);
2341: 			auto tag_data = ConstantVector::GetData<union_tag_t>(tag_vector);
2342: 			*tag_data = tag;
2343: 		} else {
2344: 			tag_vector.SetVectorType(VectorType::FLAT_VECTOR);
2345: 			if (keep_tags_for_null) {
2346: 				FlatVector::Validity(tag_vector).SetAllValid(count);
2347: 				FlatVector::Validity(union_vector).SetAllValid(count);
2348: 			} else {
2349: 				// ensure the tags have the same validity as the member
2350: 				FlatVector::Validity(union_vector) = FlatVector::Validity(member_vector);
2351: 				FlatVector::Validity(tag_vector) = FlatVector::Validity(member_vector);
2352: 			}
2353: 
2354: 			auto tag_data = FlatVector::GetData<union_tag_t>(tag_vector);
2355: 			memset(tag_data, tag, count);
2356: 		}
2357: 	}
2358: 
2359: 	// Set the non-selected members to constant null vectors
2360: 	for (idx_t i = 0; i < UnionType::GetMemberCount(union_vector.GetType()); i++) {
2361: 		if (i != tag) {
2362: 			auto &member = UnionVector::GetMember(union_vector, i);
2363: 			member.SetVectorType(VectorType::CONSTANT_VECTOR);
2364: 			ConstantVector::SetNull(member, true);
2365: 		}
2366: 	}
2367: }
2368: 
2369: bool UnionVector::TryGetTag(const Vector &vector, idx_t index, union_tag_t &result) {
2370: 	// the tag vector is always the first struct child.
2371: 	auto &tag_vector = *StructVector::GetEntries(vector)[0];
2372: 	if (tag_vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
2373: 		auto &child = DictionaryVector::Child(tag_vector);
2374: 		auto &dict_sel = DictionaryVector::SelVector(tag_vector);
2375: 		auto mapped_idx = dict_sel.get_index(index);
2376: 		if (FlatVector::IsNull(child, mapped_idx)) {
2377: 			return false;
2378: 		} else {
2379: 			result = FlatVector::GetData<union_tag_t>(child)[mapped_idx];
2380: 			return true;
2381: 		}
2382: 	}
2383: 	if (tag_vector.GetVectorType() == VectorType::CONSTANT_VECTOR) {
2384: 		if (ConstantVector::IsNull(tag_vector)) {
2385: 			return false;
2386: 		} else {
2387: 			result = ConstantVector::GetData<union_tag_t>(tag_vector)[0];
2388: 			return true;
2389: 		}
2390: 	}
2391: 	if (FlatVector::IsNull(tag_vector, index)) {
2392: 		return false;
2393: 	} else {
2394: 		result = FlatVector::GetData<union_tag_t>(tag_vector)[index];
2395: 		return true;
2396: 	}
2397: }
2398: 
2399: //! Raw selection vector passed in (not merged with any other selection vectors)
2400: UnionInvalidReason UnionVector::CheckUnionValidity(Vector &vector_p, idx_t count, const SelectionVector &sel_p) {
2401: 	D_ASSERT(vector_p.GetType().id() == LogicalTypeId::UNION);
2402: 
2403: 	// Will contain the (possibly) merged selection vector
2404: 	const SelectionVector *sel = &sel_p;
2405: 	SelectionVector owned_sel;
2406: 	Vector *vector = &vector_p;
2407: 	if (vector->GetVectorType() == VectorType::DICTIONARY_VECTOR) {
2408: 		// In the case of a dictionary vector, unwrap the Vector, and merge the selection vectors.
2409: 		auto &child = DictionaryVector::Child(*vector);
2410: 		D_ASSERT(child.GetVectorType() != VectorType::DICTIONARY_VECTOR);
2411: 		auto &dict_sel = DictionaryVector::SelVector(*vector);
2412: 		// merge the selection vectors and verify the child
2413: 		auto new_buffer = dict_sel.Slice(*sel, count);
2414: 		owned_sel.Initialize(new_buffer);
2415: 		sel = &owned_sel;
2416: 		vector = &child;
2417: 	} else if (vector->GetVectorType() == VectorType::CONSTANT_VECTOR) {
2418: 		sel = ConstantVector::ZeroSelectionVector(count, owned_sel);
2419: 	}
2420: 
2421: 	auto member_count = UnionType::GetMemberCount(vector_p.GetType());
2422: 	if (member_count == 0) {
2423: 		return UnionInvalidReason::NO_MEMBERS;
2424: 	}
2425: 
2426: 	UnifiedVectorFormat vector_vdata;
2427: 	vector_p.ToUnifiedFormat(count, vector_vdata);
2428: 
2429: 	auto &entries = StructVector::GetEntries(vector_p);
2430: 	duckdb::vector<UnifiedVectorFormat> child_vdata(entries.size());
2431: 	for (idx_t entry_idx = 0; entry_idx < entries.size(); entry_idx++) {
2432: 		auto &child = *entries[entry_idx];
2433: 		child.ToUnifiedFormat(count, child_vdata[entry_idx]);
2434: 	}
2435: 
2436: 	auto &tag_vdata = child_vdata[0];
2437: 
2438: 	for (idx_t row_idx = 0; row_idx < count; row_idx++) {
2439: 		auto mapped_idx = sel->get_index(row_idx);
2440: 
2441: 		if (!vector_vdata.validity.RowIsValid(mapped_idx)) {
2442: 			continue;
2443: 		}
2444: 
2445: 		auto tag_idx = tag_vdata.sel->get_index(sel_p.get_index(row_idx));
2446: 		if (!tag_vdata.validity.RowIsValid(tag_idx)) {
2447: 			// we can't have NULL tags!
2448: 			return UnionInvalidReason::NULL_TAG;
2449: 		}
2450: 		auto tag = UnifiedVectorFormat::GetData<union_tag_t>(tag_vdata)[tag_idx];
2451: 		if (tag >= member_count) {
2452: 			return UnionInvalidReason::TAG_OUT_OF_RANGE;
2453: 		}
2454: 
2455: 		bool found_valid = false;
2456: 		for (idx_t i = 0; i < member_count; i++) {
2457: 			auto &member_vdata = child_vdata[1 + i]; // skip the tag
2458: 			idx_t member_idx = member_vdata.sel->get_index(sel_p.get_index(row_idx));
2459: 			if (!member_vdata.validity.RowIsValid(member_idx)) {
2460: 				continue;
2461: 			}
2462: 			if (found_valid) {
2463: 				return UnionInvalidReason::VALIDITY_OVERLAP;
2464: 			}
2465: 			found_valid = true;
2466: 			if (tag != static_cast<union_tag_t>(i)) {
2467: 				return UnionInvalidReason::TAG_MISMATCH;
2468: 			}
2469: 		}
2470: 	}
2471: 
2472: 	return UnionInvalidReason::VALID;
2473: }
2474: 
2475: //===--------------------------------------------------------------------===//
2476: // ArrayVector
2477: //===--------------------------------------------------------------------===//
2478: template <class T>
2479: T &ArrayVector::GetEntryInternal(T &vector) {
2480: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::ARRAY);
2481: 	if (vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
2482: 		auto &child = DictionaryVector::Child(vector);
2483: 		return ArrayVector::GetEntry(child);
2484: 	}
2485: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
2486: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
2487: 	D_ASSERT(vector.auxiliary);
2488: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::ARRAY_BUFFER);
2489: 	return vector.auxiliary->template Cast<VectorArrayBuffer>().GetChild();
2490: }
2491: 
2492: const Vector &ArrayVector::GetEntry(const Vector &vector) {
2493: 	return GetEntryInternal<const Vector>(vector);
2494: }
2495: 
2496: Vector &ArrayVector::GetEntry(Vector &vector) {
2497: 	return GetEntryInternal<Vector>(vector);
2498: }
2499: 
2500: idx_t ArrayVector::GetTotalSize(const Vector &vector) {
2501: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::ARRAY);
2502: 	D_ASSERT(vector.auxiliary);
2503: 	if (vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
2504: 		auto &child = DictionaryVector::Child(vector);
2505: 		return ArrayVector::GetTotalSize(child);
2506: 	}
2507: 	return vector.auxiliary->Cast<VectorArrayBuffer>().GetChildSize();
2508: }
2509: 
2510: } // namespace duckdb
[end of src/common/types/vector.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: