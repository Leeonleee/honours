{
  "repo": "duckdb/duckdb",
  "pull_number": 8302,
  "instance_id": "duckdb__duckdb-8302",
  "issue_numbers": [
    "5673"
  ],
  "base_commit": "b8fe1005d546e3f5d06a072c9a65c5210a65aebd",
  "patch": "diff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex 095f67e8ba5c..959f223d754f 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -21,15 +21,25 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \tQueryErrorContext error_context(root_statement, ref.query_location);\n \t// CTEs and views are also referred to using BaseTableRefs, hence need to distinguish here\n \t// check if the table name refers to a CTE\n-\tauto found_cte = FindCTE(ref.table_name, ref.table_name == alias);\n+\n+\t// CTE name should never be qualified (i.e. schema_name should be empty)\n+\toptional_ptr<CommonTableExpressionInfo> found_cte = nullptr;\n+\tif (ref.schema_name.empty()) {\n+\t\tfound_cte = FindCTE(ref.table_name, ref.table_name == alias);\n+\t}\n+\n \tif (found_cte) {\n \t\t// Check if there is a CTE binding in the BindContext\n \t\tauto &cte = *found_cte;\n \t\tauto ctebinding = bind_context.GetCTEBinding(ref.table_name);\n \t\tif (!ctebinding) {\n \t\t\tif (CTEIsAlreadyBound(cte)) {\n-\t\t\t\tthrow BinderException(\"Circular reference to CTE \\\"%s\\\", use WITH RECURSIVE to use recursive CTEs\",\n-\t\t\t\t                      ref.table_name);\n+\t\t\t\tthrow BinderException(\n+\t\t\t\t    \"Circular reference to CTE \\\"%s\\\", There are two possible solutions. \\n1. use WITH RECURSIVE to \"\n+\t\t\t\t    \"use recursive CTEs. \\n2. If \"\n+\t\t\t\t    \"you want to use the TABLE name \\\"%s\\\" the same as the CTE name, please explicitly add \"\n+\t\t\t\t    \"\\\"SCHEMA\\\" before table name. You can try \\\"main.%s\\\" (main is the duckdb default schema)\",\n+\t\t\t\t    ref.table_name, ref.table_name, ref.table_name);\n \t\t\t}\n \t\t\t// Move CTE to subquery and bind recursively\n \t\t\tSubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(cte.query->Copy()));\n",
  "test_patch": "diff --git a/test/sql/cte/test_issue_5673.test b/test/sql/cte/test_issue_5673.test\nnew file mode 100644\nindex 000000000000..9304a783ae20\n--- /dev/null\n+++ b/test/sql/cte/test_issue_5673.test\n@@ -0,0 +1,46 @@\n+# name: test/sql/cte/test_issue_5673.test\n+# description: Issue #5673 and #4987: CTE and Table name are name shadowing\n+# group: [cte]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create or replace table orders(ordered_at int);\n+\n+statement ok\n+create or replace table stg_orders(ordered_at int);\n+\n+statement ok\n+insert into orders values (1);\n+\n+statement ok\n+insert into stg_orders values (1);\n+\n+statement error\n+with\n+orders as (\n+    select * from stg_orders\n+    where ordered_at >= (select max(ordered_at) from orders)\n+),\n+some_more_logic as (\n+    select *\n+    from orders\n+)\n+select * from some_more_logic;\n+----\n+Binder Error: Circular reference to CTE \"orders\", There are two possible solutions.\n+\n+query I\n+with\n+orders as (\n+    select * from main.stg_orders\n+    where ordered_at >= (select max(ordered_at) from main.orders)\n+),\n+some_more_logic as (\n+    select *\n+    from orders\n+)\n+select * from some_more_logic;\n+----\n+1\n",
  "problem_statement": "Referring to an object inside a CTE with the same name mistakenly thinks you're being recursive\n### What happens?\n\n```sql\r\nwith\r\n\r\norders as (\r\n\r\n    select * from analytics.orders\r\n\r\n),\r\n```\r\n\r\nthis will complain to me that i need to use `with recursive`, even though one of these is a database object and the other is a CTE, and it should probably be able to sort out which is which. i could understand if it was purely 'orders' in both places but that's not the case.\n\n### To Reproduce\n\nTry something like the below in a query, substituting orders for anything available, just make sure the CTE name and the db object have the same name.\r\n\r\n```sql\r\nwith\r\n\r\norders as (\r\n\r\n    select * from analytics.orders\r\n\r\n),\r\n```\n\n### OS:\n\nIntel macOS 13\n\n### DuckDB Version:\n\n0.6.1\n\n### DuckDB Client:\n\nSQL via duckdbt adapter\n\n### Full Name:\n\nGwen Windflower\n\n### Affiliation:\n\ndbt Labs\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Thanks for the report!\r\n\r\nUnfortunately I can't seem to reproduce this.\r\n\r\n```sql\r\ncreate schema analytics;\r\ncreate table analytics.orders(i int);\r\n-- works\r\nwith orders as (\r\n    select * from analytics.orders\r\n) select * from orders;\r\nset schema='analytics';\r\n-- also works\r\nwith orders as (\r\n    select * from orders\r\n) select * from orders;\r\n```\r\n\r\nCould you perhaps provide a more complete and reproducible example of what goes wrong?\nwhoops! sorry about that, i made an assumption about what was happening and presented a simpler example based on that, but looks like i was wrong! my apologies!\r\n\r\ni went back and narrowed my specific example down to the least amount of code that triggers the error, i _think_ this will reproduce:\r\n\r\n```\r\nwith\r\n\r\norders as (\r\n\r\n    select * from \"main\".\"main\".\"stg_orders\"\r\n\r\n    where ordered_at >= (select max(ordered_at) from \"main\".\"main\".\"orders\")\r\n    \r\n\r\n),\r\n\r\nsome_more_logic as (\r\n\r\n    select *\r\n\r\n    from orders\r\n\r\n)\r\n\r\nselect * from some_more_logic\r\n```\r\n\r\nMissing pieces from my earlier example: it seems you have to have the subquery and the downstream CTE to get it to throw the error. I won't try to guess what the issue is this time. \ud83d\ude48 \u263a\ufe0f \nThanks! I can confirm this leads to a circular reference error, when it should not:\r\n\r\n```sql\r\ncreate table orders(ordered_at int);\r\ncreate table stg_orders(ordered_at int);\r\nwith\r\norders as (\r\n    select * from main.stg_orders\r\n    where ordered_at >= (select max(ordered_at) from main.orders)\r\n),\r\nsome_more_logic as (\r\n    select *\r\n    from orders\r\n)\r\nselect * from some_more_logic;\r\n```\nSeems to be a dup of #4987.",
  "created_at": "2023-07-18T19:12:40Z"
}