{
  "repo": "duckdb/duckdb",
  "pull_number": 4153,
  "instance_id": "duckdb__duckdb-4153",
  "issue_numbers": [
    "2080"
  ],
  "base_commit": "cafd60e6bd76a8565768461e673988e9b4d4dd2d",
  "patch": "diff --git a/tools/rpkg/DESCRIPTION b/tools/rpkg/DESCRIPTION\nindex 1b87019ec0b1..eb78d13520ed 100644\n--- a/tools/rpkg/DESCRIPTION\n+++ b/tools/rpkg/DESCRIPTION\n@@ -50,6 +50,7 @@ Imports:\n     utils\n Suggests:\n     arrow,\n+    bit64,\n     callr,\n     DBItest,\n     dplyr,\ndiff --git a/tools/rpkg/R/Connection.R b/tools/rpkg/R/Connection.R\nindex 2ea3473ef913..758c983e23a3 100644\n--- a/tools/rpkg/R/Connection.R\n+++ b/tools/rpkg/R/Connection.R\n@@ -5,7 +5,7 @@\n #' @aliases duckdb_driver\n #' @keywords internal\n #' @export\n-setClass(\"duckdb_driver\", contains = \"DBIDriver\", slots = list(database_ref = \"externalptr\", dbdir = \"character\", read_only = \"logical\"))\n+setClass(\"duckdb_driver\", contains = \"DBIDriver\", slots = list(database_ref = \"externalptr\", dbdir = \"character\", read_only = \"logical\", bigint=\"character\"))\n \n #' DuckDB connection class\n #'\ndiff --git a/tools/rpkg/R/Driver.R b/tools/rpkg/R/Driver.R\nindex f6ba493ba388..628cfcceb869 100644\n--- a/tools/rpkg/R/Driver.R\n+++ b/tools/rpkg/R/Driver.R\n@@ -15,7 +15,7 @@ drv_to_string <- function(drv) {\n   if (!is(drv, \"duckdb_driver\")) {\n     stop(\"pass a duckdb_driver object\")\n   }\n-  sprintf(\"<duckdb_driver %s dbdir='%s' read_only=%s>\", extptr_str(drv@database_ref), drv@dbdir, drv@read_only)\n+  sprintf(\"<duckdb_driver %s dbdir='%s' read_only=%s bigint=%s>\", extptr_str(drv@database_ref), drv@dbdir, drv@read_only, drv@bigint)\n }\n \n #' @description\n@@ -25,13 +25,27 @@ drv_to_string <- function(drv) {\n #'\n #' @import methods DBI\n #' @export\n-duckdb <- function(dbdir = DBDIR_MEMORY, read_only = FALSE, config = list()) {\n+duckdb <- function(dbdir = DBDIR_MEMORY, read_only = FALSE, bigint=\"numeric\", config = list()) {\n   check_flag(read_only)\n+\n+  switch(bigint,\n+    numeric = {\n+        # fine\n+    },\n+    integer64 = {\n+      if (!is_installed(\"bit64\")) {\n+        stop(\"bit64 package is required for integer64 support\")\n+      }\n+    },\n+    stop(paste(\"Unsupported bigint configuration\", bigint))\n+  )\n+\n   new(\n     \"duckdb_driver\",\n     database_ref = rapi_startup(dbdir, read_only, config),\n     dbdir = dbdir,\n-    read_only = read_only\n+    read_only = read_only,\n+    bigint = bigint\n   )\n }\n \ndiff --git a/tools/rpkg/R/Result.R b/tools/rpkg/R/Result.R\nindex 02bfb60b876c..c1b53898a7d2 100644\n--- a/tools/rpkg/R/Result.R\n+++ b/tools/rpkg/R/Result.R\n@@ -40,7 +40,7 @@ duckdb_result <- function(connection, stmt_lst, arrow) {\n }\n \n duckdb_execute <- function(res) {\n-  out <- rapi_execute(res@stmt_lst$ref, res@arrow)\n+  out <- rapi_execute(res@stmt_lst$ref, res@arrow, res@connection@driver@bigint == \"integer64\")\n   duckdb_post_execute(res, out)\n }\n \ndiff --git a/tools/rpkg/R/cpp11.R b/tools/rpkg/R/cpp11.R\nindex 074c2d82f4c2..c3c354339c38 100644\n--- a/tools/rpkg/R/cpp11.R\n+++ b/tools/rpkg/R/cpp11.R\n@@ -16,8 +16,8 @@ rapi_shutdown <- function(dbsexp) {\n   invisible(.Call(`_duckdb_rapi_shutdown`, dbsexp))\n }\n \n-rapi_register_df <- function(conn, name, value) {\n-  invisible(.Call(`_duckdb_rapi_register_df`, conn, name, value))\n+rapi_register_df <- function(conn, name, value, integer64) {\n+  invisible(.Call(`_duckdb_rapi_register_df`, conn, name, value, integer64))\n }\n \n rapi_unregister_df <- function(conn, name) {\n@@ -128,8 +128,8 @@ rapi_prepare <- function(conn, query) {\n   .Call(`_duckdb_rapi_prepare`, conn, query)\n }\n \n-rapi_bind <- function(stmt, params, arrow) {\n-  .Call(`_duckdb_rapi_bind`, stmt, params, arrow)\n+rapi_bind <- function(stmt, params, arrow, integer64) {\n+  .Call(`_duckdb_rapi_bind`, stmt, params, arrow, integer64)\n }\n \n rapi_execute_arrow <- function(qry_res, chunk_size) {\n@@ -140,8 +140,8 @@ rapi_record_batch <- function(qry_res, chunk_size) {\n   .Call(`_duckdb_rapi_record_batch`, qry_res, chunk_size)\n }\n \n-rapi_execute <- function(stmt, arrow) {\n-  .Call(`_duckdb_rapi_execute`, stmt, arrow)\n+rapi_execute <- function(stmt, arrow, integer64) {\n+  .Call(`_duckdb_rapi_execute`, stmt, arrow, integer64)\n }\n \n rapi_ptr_to_str <- function(extptr) {\ndiff --git a/tools/rpkg/R/dbBind__duckdb_result.R b/tools/rpkg/R/dbBind__duckdb_result.R\nindex 8f6abe7ef1d6..bb03e177f073 100644\n--- a/tools/rpkg/R/dbBind__duckdb_result.R\n+++ b/tools/rpkg/R/dbBind__duckdb_result.R\n@@ -15,7 +15,7 @@ dbBind__duckdb_result <- function(res, params, ...) {\n \n   params <- encode_values(params)\n \n-  out <- rapi_bind(res@stmt_lst$ref, params, res@arrow)\n+  out <- rapi_bind(res@stmt_lst$ref, params, res@arrow, res@connection@driver@bigint == \"integer64\")\n   if (length(out) == 1) {\n     out <- out[[1]]\n   } else if (length(out) == 0) {\ndiff --git a/tools/rpkg/R/dbConnect__duckdb_driver.R b/tools/rpkg/R/dbConnect__duckdb_driver.R\nindex 53fe68f29f96..220a274ed3e9 100644\n--- a/tools/rpkg/R/dbConnect__duckdb_driver.R\n+++ b/tools/rpkg/R/dbConnect__duckdb_driver.R\n@@ -19,6 +19,7 @@\n #'   If `\"force\"` is chosen, the timestamp will have the same clock\n #'   time as the timestamp in the database, but with the new time zone.\n #' @param config Named list with DuckDB configuration flags\n+#' @param bigint How 64-bit integers should be returned, default is double/numeric. Set to integer64 for bit64 encoding.\n #'\n #' @return `dbConnect()` returns an object of class\n #'   \\linkS4class{duckdb_connection}.\n@@ -42,7 +43,7 @@ dbConnect__duckdb_driver <- function(drv, dbdir = DBDIR_MEMORY, ...,\n                                      debug = getOption(\"duckdb.debug\", FALSE),\n                                      read_only = FALSE,\n                                      timezone_out = \"UTC\",\n-                                     tz_out_convert = c(\"with\", \"force\"), config = list()) {\n+                                     tz_out_convert = c(\"with\", \"force\"), config = list(), bigint=\"numeric\") {\n   check_flag(debug)\n   timezone_out <- check_tz(timezone_out)\n   tz_out_convert <- match.arg(tz_out_convert)\n@@ -53,7 +54,7 @@ dbConnect__duckdb_driver <- function(drv, dbdir = DBDIR_MEMORY, ...,\n   # aha, a late comer. let's make a new instance.\n   if (!missing_dbdir && dbdir != drv@dbdir) {\n     duckdb_shutdown(drv)\n-    drv <- duckdb(dbdir, read_only, config)\n+    drv <- duckdb(dbdir, read_only, bigint, config)\n   }\n \n   conn <- duckdb_connection(drv, debug = debug)\ndiff --git a/tools/rpkg/R/register.R b/tools/rpkg/R/register.R\nindex 66d04e6b9613..bad61d8b3ec9 100644\n--- a/tools/rpkg/R/register.R\n+++ b/tools/rpkg/R/register.R\n@@ -43,7 +43,7 @@ encode_values <- function(value) {\n duckdb_register <- function(conn, name, df) {\n   stopifnot(dbIsValid(conn))\n   df <- encode_values(as.data.frame(df))\n-  rapi_register_df(conn@conn_ref, enc2utf8(as.character(name)), df)\n+  rapi_register_df(conn@conn_ref, enc2utf8(as.character(name)), df, conn@driver@bigint == \"integer64\")\n   invisible(TRUE)\n }\n \ndiff --git a/tools/rpkg/dependencies.R b/tools/rpkg/dependencies.R\nindex fd705865fd81..84493213ac77 100644\n--- a/tools/rpkg/dependencies.R\n+++ b/tools/rpkg/dependencies.R\n@@ -1,5 +1,5 @@\n local({\n-  pkg <- c(\"DBI\", \"callr\", \"DBItest\", \"dbplyr\", \"nycflights13\", \"testthat\", \"bit64\", \"cpp11\", \"arrow\", \"covr\", \"pkgbuild\", \"remotes\")\n+  pkg <- c(\"DBI\", \"callr\", \"DBItest\", \"dbplyr\", \"nycflights13\", \"testthat\", \"bit64\", \"cpp11\", \"arrow\", \"covr\", \"pkgbuild\", \"remotes\", \"bit64\")\n \n   if (.Platform$OS.type == \"unix\") {\n     options(HTTPUserAgent = sprintf(\"R/4.1.0 R (4.1.0 %s)\", paste(R.version$platform, R.version$arch, R.version$os)))\ndiff --git a/tools/rpkg/man/backend-duckdb.Rd b/tools/rpkg/man/backend-duckdb.Rd\nindex de73d2fa6774..96f2380fdd9f 100644\n--- a/tools/rpkg/man/backend-duckdb.Rd\n+++ b/tools/rpkg/man/backend-duckdb.Rd\n@@ -21,12 +21,9 @@ contains more mapped functions.\n library(dplyr, warn.conflicts = FALSE)\n con <- DBI::dbConnect(duckdb::duckdb(), path = \":memory:\")\n \n-x <- tibble(txt = c(\"why\", \"video\", \"cross\", \"extra\", \"deal\", \"authority\"))\n-dbx <- copy_to(con, x, overwrite = TRUE)\n+dbiris <- copy_to(con, iris, overwrite = TRUE)\n \n-# x \\%>\\% mutate(a = stringr::str_pad(txt, 10, side = \"both\", pad = \">\"))\n-dbx \\%>\\% mutate(a = str_pad(txt, 10, side = \"both\", pad = \">\"))\n+dbiris \\%>\\% select(Petal.Length, Petal.Width) \\%>\\% filter(Petal.Length > 1.5) \\%>\\% head(5)\n \n DBI::dbDisconnect(con, shutdown = TRUE)\n-duckdb::duckdb_shutdown(duckdb::duckdb())\n }\ndiff --git a/tools/rpkg/man/duckdb.Rd b/tools/rpkg/man/duckdb.Rd\nindex 0f7f90fa8cf6..95a7aa5bea44 100644\n--- a/tools/rpkg/man/duckdb.Rd\n+++ b/tools/rpkg/man/duckdb.Rd\n@@ -10,7 +10,12 @@\n \\alias{dbDisconnect,duckdb_connection-method}\n \\title{Connect to a DuckDB database instance}\n \\usage{\n-duckdb(dbdir = DBDIR_MEMORY, read_only = FALSE, config = list())\n+duckdb(\n+  dbdir = DBDIR_MEMORY,\n+  read_only = FALSE,\n+  bigint = \"numeric\",\n+  config = list()\n+)\n \n duckdb_shutdown(drv)\n \n@@ -22,7 +27,8 @@ duckdb_shutdown(drv)\n   read_only = FALSE,\n   timezone_out = \"UTC\",\n   tz_out_convert = c(\"with\", \"force\"),\n-  config = list()\n+  config = list(),\n+  bigint = \"numeric\"\n )\n \n \\S4method{dbDisconnect}{duckdb_connection}(conn, ..., shutdown = FALSE)\n@@ -34,6 +40,8 @@ data is kept in RAM}\n \n \\item{read_only}{Set to \\code{TRUE} for read-only operation}\n \n+\\item{bigint}{How 64-bit integers should be returned, default is double/numeric. Set to integer64 for bit64 encoding.}\n+\n \\item{config}{Named list with DuckDB configuration flags}\n \n \\item{drv}{Object returned by \\code{duckdb()}}\ndiff --git a/tools/rpkg/man/duckdb_get_substrait.Rd b/tools/rpkg/man/duckdb_get_substrait.Rd\nindex 555a4e792cdb..183c2e0e3e85 100644\n--- a/tools/rpkg/man/duckdb_get_substrait.Rd\n+++ b/tools/rpkg/man/duckdb_get_substrait.Rd\n@@ -3,7 +3,7 @@\n \\name{duckdb_get_substrait}\n \\alias{duckdb_get_substrait}\n \\title{Get the Substrait plan for a SQL query\n-TODO document this}\n+Transforms a SQL query into a raw vector containing the serialized Substrait query blob}\n \\usage{\n duckdb_get_substrait(conn, query)\n }\n@@ -17,5 +17,5 @@ A raw vector containing the substrait protobuf blob\n }\n \\description{\n Get the Substrait plan for a SQL query\n-TODO document this\n+Transforms a SQL query into a raw vector containing the serialized Substrait query blob\n }\ndiff --git a/tools/rpkg/man/duckdb_prepare_substrait.Rd b/tools/rpkg/man/duckdb_prepare_substrait.Rd\nindex f05777c7e2bb..afcd5941fbdf 100644\n--- a/tools/rpkg/man/duckdb_prepare_substrait.Rd\n+++ b/tools/rpkg/man/duckdb_prepare_substrait.Rd\n@@ -3,7 +3,8 @@\n \\name{duckdb_prepare_substrait}\n \\alias{duckdb_prepare_substrait}\n \\title{Query DuckDB using Substrait\n-TODO document this}\n+Method for interpreting a Substrait BLOB plan as a DuckDB Query Plan\n+It interprets and executes the query.}\n \\usage{\n duckdb_prepare_substrait(conn, query, arrow = FALSE)\n }\n@@ -19,5 +20,6 @@ A DuckDB Query Result\n }\n \\description{\n Query DuckDB using Substrait\n-TODO document this\n+Method for interpreting a Substrait BLOB plan as a DuckDB Query Plan\n+It interprets and executes the query.\n }\ndiff --git a/tools/rpkg/src/cpp11.cpp b/tools/rpkg/src/cpp11.cpp\nindex 32f0cbdbbd8d..c1a6383b9ccb 100644\n--- a/tools/rpkg/src/cpp11.cpp\n+++ b/tools/rpkg/src/cpp11.cpp\n@@ -36,10 +36,10 @@ extern \"C\" SEXP _duckdb_rapi_shutdown(SEXP dbsexp) {\n   END_CPP11\n }\n // register.cpp\n-void rapi_register_df(duckdb::conn_eptr_t conn, std::string name, cpp11::data_frame value);\n-extern \"C\" SEXP _duckdb_rapi_register_df(SEXP conn, SEXP name, SEXP value) {\n+void rapi_register_df(duckdb::conn_eptr_t conn, std::string name, cpp11::data_frame value, bool integer64);\n+extern \"C\" SEXP _duckdb_rapi_register_df(SEXP conn, SEXP name, SEXP value, SEXP integer64) {\n   BEGIN_CPP11\n-    rapi_register_df(cpp11::as_cpp<cpp11::decay_t<duckdb::conn_eptr_t>>(conn), cpp11::as_cpp<cpp11::decay_t<std::string>>(name), cpp11::as_cpp<cpp11::decay_t<cpp11::data_frame>>(value));\n+    rapi_register_df(cpp11::as_cpp<cpp11::decay_t<duckdb::conn_eptr_t>>(conn), cpp11::as_cpp<cpp11::decay_t<std::string>>(name), cpp11::as_cpp<cpp11::decay_t<cpp11::data_frame>>(value), cpp11::as_cpp<cpp11::decay_t<bool>>(integer64));\n     return R_NilValue;\n   END_CPP11\n }\n@@ -238,10 +238,10 @@ extern \"C\" SEXP _duckdb_rapi_prepare(SEXP conn, SEXP query) {\n   END_CPP11\n }\n // statement.cpp\n-cpp11::list rapi_bind(duckdb::stmt_eptr_t stmt, cpp11::list params, bool arrow);\n-extern \"C\" SEXP _duckdb_rapi_bind(SEXP stmt, SEXP params, SEXP arrow) {\n+cpp11::list rapi_bind(duckdb::stmt_eptr_t stmt, cpp11::list params, bool arrow, bool integer64);\n+extern \"C\" SEXP _duckdb_rapi_bind(SEXP stmt, SEXP params, SEXP arrow, SEXP integer64) {\n   BEGIN_CPP11\n-    return cpp11::as_sexp(rapi_bind(cpp11::as_cpp<cpp11::decay_t<duckdb::stmt_eptr_t>>(stmt), cpp11::as_cpp<cpp11::decay_t<cpp11::list>>(params), cpp11::as_cpp<cpp11::decay_t<bool>>(arrow)));\n+    return cpp11::as_sexp(rapi_bind(cpp11::as_cpp<cpp11::decay_t<duckdb::stmt_eptr_t>>(stmt), cpp11::as_cpp<cpp11::decay_t<cpp11::list>>(params), cpp11::as_cpp<cpp11::decay_t<bool>>(arrow), cpp11::as_cpp<cpp11::decay_t<bool>>(integer64)));\n   END_CPP11\n }\n // statement.cpp\n@@ -259,10 +259,10 @@ extern \"C\" SEXP _duckdb_rapi_record_batch(SEXP qry_res, SEXP chunk_size) {\n   END_CPP11\n }\n // statement.cpp\n-SEXP rapi_execute(duckdb::stmt_eptr_t stmt, bool arrow);\n-extern \"C\" SEXP _duckdb_rapi_execute(SEXP stmt, SEXP arrow) {\n+SEXP rapi_execute(duckdb::stmt_eptr_t stmt, bool arrow, bool integer64);\n+extern \"C\" SEXP _duckdb_rapi_execute(SEXP stmt, SEXP arrow, SEXP integer64) {\n   BEGIN_CPP11\n-    return cpp11::as_sexp(rapi_execute(cpp11::as_cpp<cpp11::decay_t<duckdb::stmt_eptr_t>>(stmt), cpp11::as_cpp<cpp11::decay_t<bool>>(arrow)));\n+    return cpp11::as_sexp(rapi_execute(cpp11::as_cpp<cpp11::decay_t<duckdb::stmt_eptr_t>>(stmt), cpp11::as_cpp<cpp11::decay_t<bool>>(arrow), cpp11::as_cpp<cpp11::decay_t<bool>>(integer64)));\n   END_CPP11\n }\n // utils.cpp\n@@ -275,43 +275,43 @@ extern \"C\" SEXP _duckdb_rapi_ptr_to_str(SEXP extptr) {\n \n extern \"C\" {\n static const R_CallMethodDef CallEntries[] = {\n-    {\"_duckdb_rapi_bind\",             (DL_FUNC) &_duckdb_rapi_bind,             3},\n-    {\"_duckdb_rapi_connect\",          (DL_FUNC) &_duckdb_rapi_connect,          1},\n-    {\"_duckdb_rapi_disconnect\",       (DL_FUNC) &_duckdb_rapi_disconnect,       1},\n-    {\"_duckdb_rapi_execute\",          (DL_FUNC) &_duckdb_rapi_execute,          2},\n-    {\"_duckdb_rapi_execute_arrow\",    (DL_FUNC) &_duckdb_rapi_execute_arrow,    2},\n-    {\"_duckdb_rapi_expr_constant\",    (DL_FUNC) &_duckdb_rapi_expr_constant,    1},\n- \t{\"_duckdb_rapi_get_substrait\",     (DL_FUNC) &_duckdb_rapi_get_substrait,     2},\n+    {\"_duckdb_rapi_bind\",              (DL_FUNC) &_duckdb_rapi_bind,              4},\n+    {\"_duckdb_rapi_connect\",           (DL_FUNC) &_duckdb_rapi_connect,           1},\n+    {\"_duckdb_rapi_disconnect\",        (DL_FUNC) &_duckdb_rapi_disconnect,        1},\n+    {\"_duckdb_rapi_execute\",           (DL_FUNC) &_duckdb_rapi_execute,           3},\n+    {\"_duckdb_rapi_execute_arrow\",     (DL_FUNC) &_duckdb_rapi_execute_arrow,     2},\n+    {\"_duckdb_rapi_expr_constant\",     (DL_FUNC) &_duckdb_rapi_expr_constant,     1},\n+    {\"_duckdb_rapi_expr_function\",     (DL_FUNC) &_duckdb_rapi_expr_function,     2},\n+    {\"_duckdb_rapi_expr_reference\",    (DL_FUNC) &_duckdb_rapi_expr_reference,    2},\n+    {\"_duckdb_rapi_expr_set_alias\",    (DL_FUNC) &_duckdb_rapi_expr_set_alias,    2},\n+    {\"_duckdb_rapi_expr_tostring\",     (DL_FUNC) &_duckdb_rapi_expr_tostring,     1},\n+    {\"_duckdb_rapi_get_substrait\",     (DL_FUNC) &_duckdb_rapi_get_substrait,     2},\n+    {\"_duckdb_rapi_prepare\",           (DL_FUNC) &_duckdb_rapi_prepare,           2},\n     {\"_duckdb_rapi_prepare_substrait\", (DL_FUNC) &_duckdb_rapi_prepare_substrait, 2},\n-    {\"_duckdb_rapi_expr_function\",    (DL_FUNC) &_duckdb_rapi_expr_function,    2},\n-    {\"_duckdb_rapi_expr_reference\",   (DL_FUNC) &_duckdb_rapi_expr_reference,   2},\n-    {\"_duckdb_rapi_expr_set_alias\",   (DL_FUNC) &_duckdb_rapi_expr_set_alias,   2},\n-    {\"_duckdb_rapi_expr_tostring\",    (DL_FUNC) &_duckdb_rapi_expr_tostring,    1},\n-    {\"_duckdb_rapi_prepare\",          (DL_FUNC) &_duckdb_rapi_prepare,          2},\n-    {\"_duckdb_rapi_ptr_to_str\",       (DL_FUNC) &_duckdb_rapi_ptr_to_str,       1},\n-    {\"_duckdb_rapi_record_batch\",     (DL_FUNC) &_duckdb_rapi_record_batch,     2},\n-    {\"_duckdb_rapi_register_arrow\",   (DL_FUNC) &_duckdb_rapi_register_arrow,   4},\n-    {\"_duckdb_rapi_register_df\",      (DL_FUNC) &_duckdb_rapi_register_df,      3},\n-    {\"_duckdb_rapi_rel_aggregate\",    (DL_FUNC) &_duckdb_rapi_rel_aggregate,    3},\n-    {\"_duckdb_rapi_rel_alias\",        (DL_FUNC) &_duckdb_rapi_rel_alias,        1},\n-    {\"_duckdb_rapi_rel_distinct\",     (DL_FUNC) &_duckdb_rapi_rel_distinct,     1},\n-    {\"_duckdb_rapi_rel_explain\",      (DL_FUNC) &_duckdb_rapi_rel_explain,      1},\n-    {\"_duckdb_rapi_rel_filter\",       (DL_FUNC) &_duckdb_rapi_rel_filter,       2},\n-    {\"_duckdb_rapi_rel_from_df\",      (DL_FUNC) &_duckdb_rapi_rel_from_df,      2},\n-    {\"_duckdb_rapi_rel_inner_join\",   (DL_FUNC) &_duckdb_rapi_rel_inner_join,   3},\n-    {\"_duckdb_rapi_rel_limit\",        (DL_FUNC) &_duckdb_rapi_rel_limit,        2},\n-    {\"_duckdb_rapi_rel_names\",        (DL_FUNC) &_duckdb_rapi_rel_names,        1},\n-    {\"_duckdb_rapi_rel_order\",        (DL_FUNC) &_duckdb_rapi_rel_order,        2},\n-    {\"_duckdb_rapi_rel_project\",      (DL_FUNC) &_duckdb_rapi_rel_project,      2},\n-    {\"_duckdb_rapi_rel_set_alias\",    (DL_FUNC) &_duckdb_rapi_rel_set_alias,    2},\n-    {\"_duckdb_rapi_rel_sql\",          (DL_FUNC) &_duckdb_rapi_rel_sql,          2},\n-    {\"_duckdb_rapi_rel_to_df\",        (DL_FUNC) &_duckdb_rapi_rel_to_df,        1},\n-    {\"_duckdb_rapi_rel_tostring\",     (DL_FUNC) &_duckdb_rapi_rel_tostring,     1},\n-    {\"_duckdb_rapi_release\",          (DL_FUNC) &_duckdb_rapi_release,          1},\n-    {\"_duckdb_rapi_shutdown\",         (DL_FUNC) &_duckdb_rapi_shutdown,         1},\n-    {\"_duckdb_rapi_startup\",          (DL_FUNC) &_duckdb_rapi_startup,          3},\n-    {\"_duckdb_rapi_unregister_arrow\", (DL_FUNC) &_duckdb_rapi_unregister_arrow, 2},\n-    {\"_duckdb_rapi_unregister_df\",    (DL_FUNC) &_duckdb_rapi_unregister_df,    2},\n+    {\"_duckdb_rapi_ptr_to_str\",        (DL_FUNC) &_duckdb_rapi_ptr_to_str,        1},\n+    {\"_duckdb_rapi_record_batch\",      (DL_FUNC) &_duckdb_rapi_record_batch,      2},\n+    {\"_duckdb_rapi_register_arrow\",    (DL_FUNC) &_duckdb_rapi_register_arrow,    4},\n+    {\"_duckdb_rapi_register_df\",       (DL_FUNC) &_duckdb_rapi_register_df,       4},\n+    {\"_duckdb_rapi_rel_aggregate\",     (DL_FUNC) &_duckdb_rapi_rel_aggregate,     3},\n+    {\"_duckdb_rapi_rel_alias\",         (DL_FUNC) &_duckdb_rapi_rel_alias,         1},\n+    {\"_duckdb_rapi_rel_distinct\",      (DL_FUNC) &_duckdb_rapi_rel_distinct,      1},\n+    {\"_duckdb_rapi_rel_explain\",       (DL_FUNC) &_duckdb_rapi_rel_explain,       1},\n+    {\"_duckdb_rapi_rel_filter\",        (DL_FUNC) &_duckdb_rapi_rel_filter,        2},\n+    {\"_duckdb_rapi_rel_from_df\",       (DL_FUNC) &_duckdb_rapi_rel_from_df,       2},\n+    {\"_duckdb_rapi_rel_inner_join\",    (DL_FUNC) &_duckdb_rapi_rel_inner_join,    3},\n+    {\"_duckdb_rapi_rel_limit\",         (DL_FUNC) &_duckdb_rapi_rel_limit,         2},\n+    {\"_duckdb_rapi_rel_names\",         (DL_FUNC) &_duckdb_rapi_rel_names,         1},\n+    {\"_duckdb_rapi_rel_order\",         (DL_FUNC) &_duckdb_rapi_rel_order,         2},\n+    {\"_duckdb_rapi_rel_project\",       (DL_FUNC) &_duckdb_rapi_rel_project,       2},\n+    {\"_duckdb_rapi_rel_set_alias\",     (DL_FUNC) &_duckdb_rapi_rel_set_alias,     2},\n+    {\"_duckdb_rapi_rel_sql\",           (DL_FUNC) &_duckdb_rapi_rel_sql,           2},\n+    {\"_duckdb_rapi_rel_to_df\",         (DL_FUNC) &_duckdb_rapi_rel_to_df,         1},\n+    {\"_duckdb_rapi_rel_tostring\",      (DL_FUNC) &_duckdb_rapi_rel_tostring,      1},\n+    {\"_duckdb_rapi_release\",           (DL_FUNC) &_duckdb_rapi_release,           1},\n+    {\"_duckdb_rapi_shutdown\",          (DL_FUNC) &_duckdb_rapi_shutdown,          1},\n+    {\"_duckdb_rapi_startup\",           (DL_FUNC) &_duckdb_rapi_startup,           3},\n+    {\"_duckdb_rapi_unregister_arrow\",  (DL_FUNC) &_duckdb_rapi_unregister_arrow,  2},\n+    {\"_duckdb_rapi_unregister_df\",     (DL_FUNC) &_duckdb_rapi_unregister_df,     2},\n     {NULL, NULL, 0}\n };\n }\ndiff --git a/tools/rpkg/src/include/rapi.hpp b/tools/rpkg/src/include/rapi.hpp\nindex a57df5859098..84d8d02d4fac 100644\n--- a/tools/rpkg/src/include/rapi.hpp\n+++ b/tools/rpkg/src/include/rapi.hpp\n@@ -104,6 +104,7 @@ struct RStrings {\n \tSEXP secs_str;\n \tSEXP arrow_str; // StringsToSexp\n \tSEXP POSIXct_POSIXt_str;\n+\tSEXP integer64_str;\n \tSEXP enc2utf8_sym; // Rf_install\n \tSEXP tzone_sym;\n \tSEXP units_sym;\n@@ -123,7 +124,7 @@ struct RStrings {\n \tRStrings();\n };\n \n-SEXP duckdb_execute_R_impl(MaterializedQueryResult *result);\n+SEXP duckdb_execute_R_impl(MaterializedQueryResult *result, bool);\n \n } // namespace duckdb\n \n@@ -141,11 +142,11 @@ cpp11::list rapi_prepare(duckdb::conn_eptr_t, std::string);\n \n cpp11::list rapi_bind(duckdb::stmt_eptr_t, SEXP paramsexp, bool);\n \n-SEXP rapi_execute(duckdb::stmt_eptr_t, bool);\n+SEXP rapi_execute(duckdb::stmt_eptr_t, bool, bool);\n \n void rapi_release(duckdb::stmt_eptr_t);\n \n-void rapi_register_df(duckdb::conn_eptr_t, std::string, cpp11::data_frame);\n+void rapi_register_df(duckdb::conn_eptr_t, std::string, cpp11::data_frame, bool);\n \n void rapi_unregister_df(duckdb::conn_eptr_t, std::string);\n \ndiff --git a/tools/rpkg/src/include/typesr.hpp b/tools/rpkg/src/include/typesr.hpp\nindex cf867f764f66..b7252afd4011 100644\n--- a/tools/rpkg/src/include/typesr.hpp\n+++ b/tools/rpkg/src/include/typesr.hpp\n@@ -34,10 +34,11 @@ enum class RType {\n \tTIME_HOURS_INTEGER,\n \tTIME_DAYS_INTEGER,\n \tTIME_WEEKS_INTEGER,\n+\tINTEGER64,\n };\n \n struct RApiTypes {\n-\tstatic RType DetectRType(SEXP v);\n+\tstatic RType DetectRType(SEXP v, bool integer64);\n \tstatic string DetectLogicalType(const LogicalType &stype, const char *caller);\n \tstatic Value SexpToValue(SEXP valsexp, R_len_t idx);\n \tstatic SEXP ValueToSexp(Value &val, string &timezone_config);\n@@ -102,6 +103,11 @@ struct RIntegerType {\n \tstatic int Convert(int val);\n };\n \n+struct RInteger64Type {\n+\tstatic bool IsNull(int64_t val);\n+\tstatic int64_t Convert(int64_t val);\n+};\n+\n struct RFactorType : public RIntegerType {\n \tstatic int Convert(int val);\n };\ndiff --git a/tools/rpkg/src/register.cpp b/tools/rpkg/src/register.cpp\nindex fb5643f26dd2..e8c7b9e4a456 100644\n--- a/tools/rpkg/src/register.cpp\n+++ b/tools/rpkg/src/register.cpp\n@@ -10,7 +10,8 @@\n \n using namespace duckdb;\n \n-[[cpp11::register]] void rapi_register_df(duckdb::conn_eptr_t conn, std::string name, cpp11::data_frame value) {\n+[[cpp11::register]] void rapi_register_df(duckdb::conn_eptr_t conn, std::string name, cpp11::data_frame value,\n+                                          bool integer64) {\n \tif (!conn || !conn->conn) {\n \t\tcpp11::stop(\"rapi_register_df: Invalid connection\");\n \t}\n@@ -21,7 +22,9 @@ using namespace duckdb;\n \t\tcpp11::stop(\"rapi_register_df: Data frame with at least one column required\");\n \t}\n \ttry {\n-\t\tconn->conn->TableFunction(\"r_dataframe_scan\", {Value::POINTER((uintptr_t)value.data())})\n+\t\tnamed_parameter_map_t parameter_map;\n+\t\tparameter_map[\"integer64\"] = Value::BOOLEAN(integer64);\n+\t\tconn->conn->TableFunction(\"r_dataframe_scan\", {Value::POINTER((uintptr_t)value.data())}, parameter_map)\n \t\t    ->CreateView(name, true, true);\n \t\tstatic_cast<cpp11::sexp>(conn).attr(\"_registered_df_\" + name) = value;\n \t} catch (std::exception &e) {\ndiff --git a/tools/rpkg/src/relational.cpp b/tools/rpkg/src/relational.cpp\nindex 68ade0f6338b..ddf4e2ed7f24 100644\n--- a/tools/rpkg/src/relational.cpp\n+++ b/tools/rpkg/src/relational.cpp\n@@ -215,7 +215,7 @@ static SEXP result_to_df(unique_ptr<QueryResult> res) {\n \tclasses.push_back(\"tbl\");\n \tclasses.push_back(\"data.frame\");\n \n-\tauto df = sexp(duckdb_execute_R_impl(mat_res));\n+\tauto df = sexp(duckdb_execute_R_impl(mat_res, false));\n \tdf.attr(\"class\") = classes;\n \tdf.attr(\"row.names\") = row_names;\n \treturn df;\ndiff --git a/tools/rpkg/src/scan.cpp b/tools/rpkg/src/scan.cpp\nindex 4024eed528f1..b9fa51420b50 100644\n--- a/tools/rpkg/src/scan.cpp\n+++ b/tools/rpkg/src/scan.cpp\n@@ -80,6 +80,7 @@ static unique_ptr<FunctionData> DataFrameScanBind(ClientContext &context, TableF\n                                                   vector<LogicalType> &return_types, vector<string> &names) {\n \tdata_frame df((SEXP)input.inputs[0].GetPointer());\n \n+\tauto integer64 = get_bool_param(input.named_parameters, \"integer64\", false);\n \tauto experimental = get_bool_param(input.named_parameters, \"experimental\", false);\n \n \tauto df_names = df.names();\n@@ -92,7 +93,7 @@ static unique_ptr<FunctionData> DataFrameScanBind(ClientContext &context, TableF\n \t\tdata_ptr_t coldata_ptr = nullptr;\n \n \t\tnames.push_back(df_names[col_idx]);\n-\t\trtypes.push_back(RApiTypes::DetectRType(coldata));\n+\t\trtypes.push_back(RApiTypes::DetectRType(coldata, integer64));\n \n \t\tswitch (rtypes[col_idx]) {\n \t\tcase RType::LOGICAL:\n@@ -107,6 +108,10 @@ static unique_ptr<FunctionData> DataFrameScanBind(ClientContext &context, TableF\n \t\t\tduckdb_col_type = LogicalType::DOUBLE;\n \t\t\tcoldata_ptr = (data_ptr_t)NUMERIC_POINTER(coldata);\n \t\t\tbreak;\n+\t\tcase RType::INTEGER64:\n+\t\t\tduckdb_col_type = LogicalType::BIGINT;\n+\t\t\tcoldata_ptr = (data_ptr_t)NUMERIC_POINTER(coldata);\n+\t\t\tbreak;\n \t\tcase RType::FACTOR: {\n \t\t\t// TODO What about factors that use numeric?\n \t\t\tcoldata_ptr = (data_ptr_t)INTEGER_POINTER(coldata);\n@@ -153,7 +158,7 @@ static unique_ptr<FunctionData> DataFrameScanBind(ClientContext &context, TableF\n \t\t\tduckdb_col_type = LogicalType::DATE;\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\tcpp11::stop(\"rapi_execute: Unsupported column type for scan\");\n+\t\t\tcpp11::stop(\"rapi_execute: Unsupported column type for bind\");\n \t\t}\n \n \t\treturn_types.push_back(duckdb_col_type);\n@@ -263,6 +268,11 @@ static void DataFrameScanFunc(ClientContext &context, TableFunctionInput &data,\n \t\t\tAppendColumnSegment<double, double, RDoubleType>(data_ptr, v, this_count);\n \t\t\tbreak;\n \t\t}\n+\t\tcase RType::INTEGER64: {\n+\t\t\tauto data_ptr = (int64_t *)coldata_ptr + sexp_offset;\n+\t\t\tAppendColumnSegment<int64_t, int64_t, RInteger64Type>(data_ptr, v, this_count);\n+\t\t\tbreak;\n+\t\t}\n \t\tcase RType::STRING: {\n \t\t\tif (bind_data.experimental) {\n \t\t\t\tauto data_ptr = (SEXP *)coldata_ptr + sexp_offset;\n@@ -361,7 +371,7 @@ static void DataFrameScanFunc(ClientContext &context, TableFunctionInput &data,\n \t\t\tbreak;\n \t\t}\n \t\tdefault:\n-\t\t\tthrow;\n+\t\t\tcpp11::stop(\"rapi_execute: Unsupported column type for scan\");\n \t\t}\n \t}\n \n@@ -383,5 +393,6 @@ DataFrameScanFunction::DataFrameScanFunction()\n \tcardinality = DataFrameScanCardinality;\n \tto_string = DataFrameScanToString;\n \tnamed_parameters[\"experimental\"] = LogicalType::BOOLEAN;\n+\tnamed_parameters[\"integer64\"] = LogicalType::BOOLEAN;\n \tprojection_pushdown = true;\n }\ndiff --git a/tools/rpkg/src/statement.cpp b/tools/rpkg/src/statement.cpp\nindex a3d6e4ebfa12..c042b56fad50 100644\n--- a/tools/rpkg/src/statement.cpp\n+++ b/tools/rpkg/src/statement.cpp\n@@ -129,7 +129,7 @@ static cpp11::list construct_retlist(unique_ptr<PreparedStatement> stmt, const s\n \treturn construct_retlist(move(stmt), query, n_param);\n }\n \n-[[cpp11::register]] cpp11::list rapi_bind(duckdb::stmt_eptr_t stmt, cpp11::list params, bool arrow) {\n+[[cpp11::register]] cpp11::list rapi_bind(duckdb::stmt_eptr_t stmt, cpp11::list params, bool arrow, bool integer64) {\n \tif (!stmt || !stmt->stmt) {\n \t\tcpp11::stop(\"rapi_bind: Invalid statement\");\n \t}\n@@ -168,7 +168,7 @@ static cpp11::list construct_retlist(unique_ptr<PreparedStatement> stmt, const s\n \t\t}\n \n \t\t// No protection, assigned immediately\n-\t\tout.push_back(rapi_execute(stmt, arrow));\n+\t\tout.push_back(rapi_execute(stmt, arrow, integer64));\n \t}\n \n \treturn out;\n@@ -302,7 +302,7 @@ void ConvertTimestampVector(Vector &src_vec, size_t count, SEXP &dest, uint64_t\n \n std::once_flag nanosecond_coercion_warning;\n \n-static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n) {\n+static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n, bool integer64) {\n \tswitch (src_vec.GetType().id()) {\n \tcase LogicalTypeId::BOOLEAN:\n \t\tVectorToR<int8_t, uint32_t>(src_vec, n, LOGICAL_POINTER(dest), dest_offset, NA_LOGICAL);\n@@ -373,10 +373,23 @@ static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n) {\n \t\tVectorToR<uint32_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n \t\tbreak;\n \tcase LogicalTypeId::UBIGINT:\n-\t\tVectorToR<uint64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n+\t\tif (integer64) {\n+\t\t\t// this silently loses the high bit\n+\t\t\tVectorToR<uint64_t, int64_t>(src_vec, n, NUMERIC_POINTER(dest), dest_offset,\n+\t\t\t                             NumericLimits<int64_t>::Minimum());\n+\t\t\tRf_setAttrib(dest, R_ClassSymbol, RStrings::get().integer64_str);\n+\t\t} else {\n+\t\t\tVectorToR<uint64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n+\t\t}\n \t\tbreak;\n \tcase LogicalTypeId::BIGINT:\n-\t\tVectorToR<int64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n+\t\tif (integer64) {\n+\t\t\tVectorToR<int64_t, int64_t>(src_vec, n, NUMERIC_POINTER(dest), dest_offset,\n+\t\t\t                            NumericLimits<int64_t>::Minimum());\n+\t\t\tRf_setAttrib(dest, R_ClassSymbol, RStrings::get().integer64_str);\n+\t\t} else {\n+\t\t\tVectorToR<int64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n+\t\t}\n \t\tbreak;\n \tcase LogicalTypeId::HUGEINT: {\n \t\tauto src_data = FlatVector::GetData<hugeint_t>(src_vec);\n@@ -443,7 +456,7 @@ static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n) {\n \t\t\t\t// transform the list child vector to a single R SEXP\n \t\t\t\tauto list_element =\n \t\t\t\t    allocate(ListType::GetChildType(src_vec.GetType()), ele_prot, src_data[row_idx].length);\n-\t\t\t\ttransform(child_vector, list_element, 0, src_data[row_idx].length);\n+\t\t\t\ttransform(child_vector, list_element, 0, src_data[row_idx].length, integer64);\n \n \t\t\t\t// call R's own extract subset method\n \t\t\t\tSET_ELEMENT(dest, dest_offset + row_idx, list_element);\n@@ -457,7 +470,7 @@ static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n) {\n \t\tfor (size_t i = 0; i < children.size(); i++) {\n \t\t\tconst auto &struct_child = children[i];\n \t\t\tSEXP child_dest = VECTOR_ELT(dest, i);\n-\t\t\ttransform(*struct_child, child_dest, dest_offset, n);\n+\t\t\ttransform(*struct_child, child_dest, dest_offset, n, integer64);\n \t\t}\n \n \t\tbreak;\n@@ -540,7 +553,7 @@ static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n) {\n \t}\n }\n \n-SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result) {\n+SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result, bool integer64) {\n \t// step 2: create result data frame and allocate columns\n \tuint32_t ncols = result->types.size();\n \tif (ncols == 0) {\n@@ -579,7 +592,7 @@ SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result) {\n \t\tD_ASSERT(chunk->ColumnCount() == (idx_t)Rf_length(data_frame));\n \t\tfor (size_t col_idx = 0; col_idx < chunk->ColumnCount(); col_idx++) {\n \t\t\tSEXP dest = VECTOR_ELT(data_frame, col_idx);\n-\t\t\ttransform(chunk->data[col_idx], dest, dest_offset, chunk->size());\n+\t\t\ttransform(chunk->data[col_idx], dest, dest_offset, chunk->size(), integer64);\n \t\t}\n \t\tdest_offset += chunk->size();\n \t\tchunk_idx++;\n@@ -681,7 +694,7 @@ bool FetchArrowChunk(QueryResult *result, AppendableRList &batches_list, ArrowAr\n \treturn cpp11::safe[Rf_eval](record_batch_reader, arrow_namespace);\n }\n \n-[[cpp11::register]] SEXP rapi_execute(duckdb::stmt_eptr_t stmt, bool arrow) {\n+[[cpp11::register]] SEXP rapi_execute(duckdb::stmt_eptr_t stmt, bool arrow, bool integer64) {\n \tif (!stmt || !stmt->stmt) {\n \t\tcpp11::stop(\"rapi_execute: Invalid statement\");\n \t}\n@@ -708,6 +721,6 @@ bool FetchArrowChunk(QueryResult *result, AppendableRList &batches_list, ArrowAr\n \t} else {\n \t\tD_ASSERT(generic_result->type == QueryResultType::MATERIALIZED_RESULT);\n \t\tMaterializedQueryResult *result = (MaterializedQueryResult *)generic_result.get();\n-\t\treturn duckdb_execute_R_impl(result);\n+\t\treturn duckdb_execute_R_impl(result, integer64);\n \t}\n }\ndiff --git a/tools/rpkg/src/types.cpp b/tools/rpkg/src/types.cpp\nindex 45f0ec126182..2715f1a8eb4a 100644\n--- a/tools/rpkg/src/types.cpp\n+++ b/tools/rpkg/src/types.cpp\n@@ -8,7 +8,7 @@\n \n using namespace duckdb;\n \n-RType RApiTypes::DetectRType(SEXP v) {\n+RType RApiTypes::DetectRType(SEXP v, bool integer64) {\n \tif (TYPEOF(v) == REALSXP && Rf_inherits(v, \"POSIXct\")) {\n \t\treturn RType::TIMESTAMP;\n \t} else if (TYPEOF(v) == REALSXP && Rf_inherits(v, \"Date\")) {\n@@ -60,6 +60,9 @@ RType RApiTypes::DetectRType(SEXP v) {\n \t} else if (TYPEOF(v) == INTSXP) {\n \t\treturn RType::INTEGER;\n \t} else if (TYPEOF(v) == REALSXP) {\n+\t\tif (integer64 && Rf_inherits(v, \"integer64\")) {\n+\t\t\treturn RType::INTEGER64;\n+\t\t}\n \t\treturn RType::NUMERIC;\n \t} else if (TYPEOF(v) == STRSXP) {\n \t\treturn RType::STRING;\n@@ -158,6 +161,14 @@ int RIntegerType::Convert(int val) {\n \treturn val;\n }\n \n+bool RInteger64Type::IsNull(int64_t val) {\n+\treturn val == NumericLimits<int64_t>::Minimum();\n+}\n+\n+int64_t RInteger64Type::Convert(int64_t val) {\n+\treturn val;\n+}\n+\n int RFactorType::Convert(int val) {\n \treturn val - 1;\n }\ndiff --git a/tools/rpkg/src/utils.cpp b/tools/rpkg/src/utils.cpp\nindex fdcaa1ca69fb..2a522f04abb3 100644\n--- a/tools/rpkg/src/utils.cpp\n+++ b/tools/rpkg/src/utils.cpp\n@@ -54,7 +54,7 @@ RStrings::RStrings() {\n \tR_PreserveObject(strings);\n \tMARK_NOT_MUTABLE(strings);\n \n-\tSEXP chars = r.Protect(Rf_allocVector(VECSXP, 8));\n+\tSEXP chars = r.Protect(Rf_allocVector(VECSXP, 9));\n \tSET_VECTOR_ELT(chars, 0, UTC_str = Rf_mkString(\"UTC\"));\n \tSET_VECTOR_ELT(chars, 1, Date_str = Rf_mkString(\"Date\"));\n \tSET_VECTOR_ELT(chars, 2, difftime_str = Rf_mkString(\"difftime\"));\n@@ -63,6 +63,7 @@ RStrings::RStrings() {\n \tSET_VECTOR_ELT(chars, 5, POSIXct_POSIXt_str = StringsToSexp({\"POSIXct\", \"POSIXt\"}));\n \tSET_VECTOR_ELT(chars, 6, factor_str = Rf_mkString(\"factor\"));\n \tSET_VECTOR_ELT(chars, 7, dataframe_str = Rf_mkString(\"data.frame\"));\n+\tSET_VECTOR_ELT(chars, 8, integer64_str = Rf_mkString(\"integer64\"));\n \n \tR_PreserveObject(chars);\n \tMARK_NOT_MUTABLE(chars);\n@@ -93,7 +94,7 @@ static void AppendColumnSegment(SRC *source_data, Vector &result, idx_t count) {\n }\n \n Value RApiTypes::SexpToValue(SEXP valsexp, R_len_t idx) {\n-\tauto rtype = RApiTypes::DetectRType(valsexp);\n+\tauto rtype = RApiTypes::DetectRType(valsexp, false); // TODO\n \tswitch (rtype) {\n \tcase RType::LOGICAL: {\n \t\tauto lgl_val = INTEGER_POINTER(valsexp)[idx];\n",
  "test_patch": "diff --git a/tools/rpkg/tests/testthat/test_integer64.R b/tools/rpkg/tests/testthat/test_integer64.R\nnew file mode 100644\nindex 000000000000..a8733201cdff\n--- /dev/null\n+++ b/tools/rpkg/tests/testthat/test_integer64.R\n@@ -0,0 +1,18 @@\n+library(\"DBI\")\n+library(\"testthat\")\n+\n+skip_if_not_installed(\"bit64\")\n+\n+library(\"bit64\")\n+\n+# this tests both retrieval and scans\n+test_that(\"we can roundtrip an integer64\", {\n+    con <- dbConnect(duckdb::duckdb(bigint=\"integer64\"))\n+    on.exit(dbDisconnect(con, shutdown = TRUE))\n+    df <- data.frame(a=as.integer64(42), b=as.integer64(-42), c=as.integer64(NA))\n+\n+    duckdb::duckdb_register(con, \"df\", df)\n+\n+    res <- dbReadTable(con, \"df\")\n+    expect_identical(df, res)\n+})\n",
  "problem_statement": "R: Support bigint argument in DBI::dbConnect()?\n**What does happen?**\r\n\r\nThe DBI specs suggest supporting different ways of returning 64-bit integer data.\r\n\r\n**What should happen?**\r\n\r\nAdd `bigint` argument to `dbConnect()` ?\r\n\r\n**To Reproduce**\r\n\r\n``` r\r\nlibrary(DBI)\r\n\r\ncon <- dbConnect(duckdb::duckdb(), bigint = \"integer64\")\r\nclass(dbGetQuery(con, \"SELECT 10000000000 AS a\")$a)\r\n#> [1] \"numeric\"\r\n```\r\n\r\n<sup>Created on 2021-07-30 by the [reprex package](https://reprex.tidyverse.org) (v2.0.0)</sup>\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Ubuntu 20.04\r\n - DuckDB Version R package 0.2.6\r\n\r\n**Before submitting**\r\n- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\n",
  "hints_text": "I'm leaning towards a fully ALTREP based solution, mimicking `AltrepString`.\n@hannes this is the issue that I was talking about, it's blocking some of our R users\n@krlmlr could you perhaps have a look at this issue?\n@ccolgrove what would you like to happen there? returning bit64 instances or something like that?\n@hannes, I think trying to match the R type as closely as possible to the duckDB type would be ideal.\r\n\r\nHowever, My understanding is that R does not natively support 64-bit integers (Source: https://cran.r-project.org/doc/manuals/r-release/R-ints.html#g_t64_002dbit-types). Therefore, a decision would need to be made on how `duckdb` will support returning 64-bit integers. \r\n\r\nIt seems that `bit64` is the standard package for R supporting 64bit integers. `arrow` already supports casting to `bit64` integers: https://arrow.apache.org/docs/r/articles/arrow.html#arrow-to-r.\r\n\r\nTherefore, coping the IntegerType chart from https://duckdb.org/docs/sql/data_types/numeric, I propose this mapping of types:\r\n\r\n| Name      | Aliases           | Min                                       | Max                                     | R Type             |\r\n|-----------|-------------------|-------------------------------------------|-----------------------------------------|--------------------|\r\n| TINYINT   | INT1              | -128                                      | 127                                     | R Standard Integer |\r\n| SMALLINT  | INT2, SHORT       | -32768                                    | 32767                                   | R Standard Integer |\r\n| INTEGER   | INT4, INT, SIGNED | -2147483648                               | 2147483647                              | R Standard Integer |\r\n| BIGINT    | INT8, LONG        | -9223372036854775808                      | 9223372036854775807                     | bit64::integer64   |\r\n| HUGEINT   |                   | -170141183460469231731687303715884105727* | 170141183460469231731687303715884105727 | ?? `gmp::bigz`     |\r\n| UTINYINT  | -                 | 0                                         | 255                                     | R Standard Integer |\r\n| USMALLINT | -                 | 0                                         | 65535                                   | R Standard Integer |\r\n| UINTEGER  | -                 | 0                                         | 4294967295                              | R Standard Integer |\r\n| UBIGINT   | -                 | 0                                         | 18446744073709551615                    | ?? `gmp::bigz`     |\r\n\r\n@krlmlr, I have no experience with ALTREP. Would this be needed in addition to a potential package like `bit64` or as a replacement?\r\n\r\n\r\n\r\n\nI think the bit64 solution is fairly standard in R, we have used it before and I am fine with going this route again. I don't think ALTREP is necessary. \n@krlmlr could you perhaps pick this up?\nPicking this up myself",
  "created_at": "2022-07-18T09:43:21Z"
}