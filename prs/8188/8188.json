{
  "repo": "duckdb/duckdb",
  "pull_number": 8188,
  "instance_id": "duckdb__duckdb-8188",
  "issue_numbers": [
    "8171"
  ],
  "base_commit": "b4c1529172b3d53d932def786df942883128001c",
  "patch": "diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 47744e9eff8c..b64a6c04ef3e 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -218,6 +218,10 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \treference_set_t<ViewCatalogEntry> bound_views;\n \n private:\n+\t//! Get the root binder (binder with no parent)\n+\tBinder *GetRootBinder();\n+\t//! Determine the depth of the binder\n+\tidx_t GetBinderDepth() const;\n \t//! Bind the expressions of generated columns to check for errors\n \tvoid BindGeneratedColumns(BoundCreateTableInfo &info);\n \t//! Bind the default values of the columns of a table\ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex e4d2716f4fda..51d5d8311bda 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -21,7 +21,31 @@\n \n namespace duckdb {\n \n+Binder *Binder::GetRootBinder() {\n+\tBinder *root = this;\n+\twhile (root->parent) {\n+\t\troot = root->parent.get();\n+\t}\n+\treturn root;\n+}\n+\n+idx_t Binder::GetBinderDepth() const {\n+\tconst Binder *root = this;\n+\tidx_t depth = 1;\n+\twhile (root->parent) {\n+\t\tdepth++;\n+\t\troot = root->parent.get();\n+\t}\n+\treturn depth;\n+}\n+\n shared_ptr<Binder> Binder::CreateBinder(ClientContext &context, optional_ptr<Binder> parent, bool inherit_ctes) {\n+\tauto depth = parent ? parent->GetBinderDepth() : 0;\n+\tif (depth > context.config.max_expression_depth) {\n+\t\tthrow BinderException(\"Max expression depth limit of %lld exceeded. Use \\\"SET max_expression_depth TO x\\\" to \"\n+\t\t                      \"increase the maximum expression depth.\",\n+\t\t                      context.config.max_expression_depth);\n+\t}\n \treturn make_shared<Binder>(true, context, parent ? parent->shared_from_this() : nullptr, inherit_ctes);\n }\n \n@@ -271,11 +295,8 @@ void Binder::AddBoundView(ViewCatalogEntry &view) {\n }\n \n idx_t Binder::GenerateTableIndex() {\n-\tD_ASSERT(parent.get() != this);\n-\tif (parent) {\n-\t\treturn parent->GenerateTableIndex();\n-\t}\n-\treturn bound_tables++;\n+\tauto root_binder = GetRootBinder();\n+\treturn root_binder->bound_tables++;\n }\n \n void Binder::PushExpressionBinder(ExpressionBinder &binder) {\n@@ -301,18 +322,13 @@ bool Binder::HasActiveBinder() {\n }\n \n vector<reference<ExpressionBinder>> &Binder::GetActiveBinders() {\n-\tif (parent) {\n-\t\treturn parent->GetActiveBinders();\n-\t}\n-\treturn active_binders;\n+\tauto root_binder = GetRootBinder();\n+\treturn root_binder->active_binders;\n }\n \n void Binder::AddUsingBindingSet(unique_ptr<UsingColumnSet> set) {\n-\tif (parent) {\n-\t\tparent->AddUsingBindingSet(std::move(set));\n-\t\treturn;\n-\t}\n-\tbind_context.AddUsingBindingSet(std::move(set));\n+\tauto root_binder = GetRootBinder();\n+\troot_binder->bind_context.AddUsingBindingSet(std::move(set));\n }\n \n void Binder::MoveCorrelatedExpressions(Binder &other) {\n@@ -381,17 +397,14 @@ bool Binder::HasMatchingBinding(const string &catalog_name, const string &schema\n }\n \n void Binder::SetBindingMode(BindingMode mode) {\n-\tif (parent) {\n-\t\tparent->SetBindingMode(mode);\n-\t}\n-\tthis->mode = mode;\n+\tauto root_binder = GetRootBinder();\n+\t// FIXME: this used to also set the 'mode' for the current binder, was that necessary?\n+\troot_binder->mode = mode;\n }\n \n BindingMode Binder::GetBindingMode() {\n-\tif (parent) {\n-\t\treturn parent->GetBindingMode();\n-\t}\n-\treturn mode;\n+\tauto root_binder = GetRootBinder();\n+\treturn root_binder->mode;\n }\n \n void Binder::SetCanContainNulls(bool can_contain_nulls_p) {\n@@ -399,18 +412,13 @@ void Binder::SetCanContainNulls(bool can_contain_nulls_p) {\n }\n \n void Binder::AddTableName(string table_name) {\n-\tif (parent) {\n-\t\tparent->AddTableName(std::move(table_name));\n-\t\treturn;\n-\t}\n-\ttable_names.insert(std::move(table_name));\n+\tauto root_binder = GetRootBinder();\n+\troot_binder->table_names.insert(std::move(table_name));\n }\n \n const unordered_set<string> &Binder::GetTableNames() {\n-\tif (parent) {\n-\t\treturn parent->GetTableNames();\n-\t}\n-\treturn table_names;\n+\tauto root_binder = GetRootBinder();\n+\treturn root_binder->table_names;\n }\n \n string Binder::FormatError(ParsedExpression &expr_context, const string &message) {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py b/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py\nindex d668e30414c6..02ea1d234663 100644\n--- a/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py\n+++ b/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py\n@@ -116,3 +116,16 @@ def test_query_non_select_result(self):\n \n         res = duckdb.query('drop table tbl_non_select_result')\n         assert res is None\n+\n+    def test_replacement_scan_recursion(self):\n+        con = duckdb.connect()\n+        depth_limit = 1000\n+        import sys\n+        if sys.platform.startswith('win'):\n+            # With the default we reach a stack overflow in the CI\n+            depth_limit = 250\n+        con.execute(f\"SET max_expression_depth TO {depth_limit}\")\n+        rel = con.sql('select 42')\n+        rel = con.sql('select * from rel')\n+        with pytest.raises(duckdb.BinderException, match=f'Max expression depth limit of {depth_limit} exceeded'):\n+            con.sql('select * from rel')\n",
  "problem_statement": "[Python] Stack overflow in nested relation scan\n### What happens?\r\n\r\n```py\r\nimport pandas as pd\r\nimport duckdb\r\n\r\ndf = pd.DataFrame({'a': [42]})\r\n\r\ncon = duckdb.connect()\r\nrel = con.sql('select * from df')\r\nfor _ in range(2):\r\n\trel = con.sql('select a from rel')\r\n```\r\n\r\nThe first iteration is fine, the second one appears to stack-overflow\r\n\r\n\r\n### OS:\r\n\r\nMacOS\r\n\r\n### DuckDB Version:\r\n\r\nmaster\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nThijs Bruineman\r\n\r\n### Affiliation:\r\n\r\nDuckDB Labs\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "I think I found out the cause\r\n```\r\n(lldb) p replacement_function->ToString()\r\n(std::string) $5 = \"(SELECT a) AS rel\"\r\n```\r\nThe replacement function finds the relation, which contains `rel`, which when binding resolves to the same replacement function. <- and this is an endless recursion.",
  "created_at": "2023-07-08T11:28:19Z"
}