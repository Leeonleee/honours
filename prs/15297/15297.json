{
  "repo": "duckdb/duckdb",
  "pull_number": 15297,
  "instance_id": "duckdb__duckdb-15297",
  "issue_numbers": [
    "14938",
    "14938"
  ],
  "base_commit": "4ca094fa6370d5bc7893ca156db422082b9a5528",
  "patch": "diff --git a/src/catalog/catalog.cpp b/src/catalog/catalog.cpp\nindex 6168967d764d..53a31ac389b5 100644\n--- a/src/catalog/catalog.cpp\n+++ b/src/catalog/catalog.cpp\n@@ -862,7 +862,7 @@ CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, Cat\n \t// lookup\n \tif (type == CatalogType::TABLE_ENTRY) {\n \t\tauto lookup_result_default_table =\n-\t\t    TryLookupDefaultTable(retriever, type, catalog, schema, name, if_not_found, error_context);\n+\t\t    TryLookupDefaultTable(retriever, type, catalog, schema, name, OnEntryNotFound::RETURN_NULL, error_context);\n \n \t\tif (lookup_result_default_table.Found() && lookup_result.Found()) {\n \t\t\tThrowDefaultTableAmbiguityException(lookup_result, lookup_result_default_table, name);\ndiff --git a/src/common/types.cpp b/src/common/types.cpp\nindex 7ec718928038..474fc2848cbe 100644\n--- a/src/common/types.cpp\n+++ b/src/common/types.cpp\n@@ -887,14 +887,8 @@ LogicalType LogicalType::NormalizeType(const LogicalType &type) {\n template <class OP>\n static bool CombineUnequalTypes(const LogicalType &left, const LogicalType &right, LogicalType &result) {\n \t// left and right are not equal\n-\t// for enums, match the varchar rules\n-\tif (left.id() == LogicalTypeId::ENUM) {\n-\t\treturn OP::Operation(LogicalType::VARCHAR, right, result);\n-\t} else if (right.id() == LogicalTypeId::ENUM) {\n-\t\treturn OP::Operation(left, LogicalType::VARCHAR, result);\n-\t}\n-\t// NULL/string literals/unknown (parameter) types always take the other type\n-\tLogicalTypeId other_types[] = {LogicalTypeId::SQLNULL, LogicalTypeId::UNKNOWN, LogicalTypeId::STRING_LITERAL};\n+\t// NULL/unknown (parameter) types always take the other type\n+\tLogicalTypeId other_types[] = {LogicalTypeId::SQLNULL, LogicalTypeId::UNKNOWN};\n \tfor (auto &other_type : other_types) {\n \t\tif (left.id() == other_type) {\n \t\t\tresult = LogicalType::NormalizeType(right);\n@@ -905,6 +899,22 @@ static bool CombineUnequalTypes(const LogicalType &left, const LogicalType &righ\n \t\t}\n \t}\n \n+\t// for enums, match the varchar rules\n+\tif (left.id() == LogicalTypeId::ENUM) {\n+\t\treturn OP::Operation(LogicalType::VARCHAR, right, result);\n+\t} else if (right.id() == LogicalTypeId::ENUM) {\n+\t\treturn OP::Operation(left, LogicalType::VARCHAR, result);\n+\t}\n+\n+\t// for everything but enums - string literals also take the other type\n+\tif (left.id() == LogicalTypeId::STRING_LITERAL) {\n+\t\tresult = LogicalType::NormalizeType(right);\n+\t\treturn true;\n+\t} else if (right.id() == LogicalTypeId::STRING_LITERAL) {\n+\t\tresult = LogicalType::NormalizeType(left);\n+\t\treturn true;\n+\t}\n+\n \t// for other types - use implicit cast rules to check if we can combine the types\n \tauto left_to_right_cost = CastRules::ImplicitCast(left, right);\n \tauto right_to_left_cost = CastRules::ImplicitCast(right, left);\n",
  "test_patch": "diff --git a/test/sql/types/enum/test_enum_case.test b/test/sql/types/enum/test_enum_case.test\nnew file mode 100644\nindex 000000000000..8c2da50c08a1\n--- /dev/null\n+++ b/test/sql/types/enum/test_enum_case.test\n@@ -0,0 +1,20 @@\n+# name: test/sql/types/enum/test_enum_case.test\n+# description: Test enum in CASE expressions\n+# group: [enum]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TYPE E1 AS ENUM ('v1', 'v2');\n+\n+statement ok\n+CREATE TABLE t1 (v E1);\n+\n+statement ok\n+INSERT INTO t1 VALUES ('v1');\n+\n+query I\n+SELECT typeof(CASE WHEN 1 THEN v END) FROM t1;\n+----\n+ENUM('v1', 'v2')\n",
  "problem_statement": "Unexpected implicit cast when using CASE WHEN\n### What happens?\r\n\r\nI am observing some unexpected type casting when using CASE WHEN in a query.\r\n\r\nWhen using an ENUM-typed variable inside a CASE WHEN check, the resulting value will be of type VARCHAR instead of ENUM,  which is unnecessary and wrong in my opinion.\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nCREATE TYPE E1 AS ENUM ('v1', 'v2');\r\nCREATE TABLE t1 (v E1);\r\nINSERT INTO t1 VALUES ('v1');\r\nINSERT INTO t1 VALUES ('v1');\r\nINSERT INTO t1 VALUES ('v1');\r\n\r\n-- This returns a result only if all elements in a column are equal (namely this value), otherwise it should return NULL.\r\nDESCRIBE (SELECT CASE WHEN COUNT(DISTINCT v) == 1 THEN FIRST(v) END AS r FROM t1);\r\n```\r\nOutput:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 column_name \u2506 column_type \u2506 null \u2506 key \u2506 default \u2506 extra \u2502\r\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\r\n\u2502 r           \u2506 VARCHAR     \u2506 YES  \u2506     \u2506         \u2506       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nI expect the column type to be of ENUM E1 type, not VARCHAR.\r\n\r\n### OS:\r\n\r\nMS Windows 10, x64\r\n\r\n### DuckDB Version:\r\n\r\n1.1.3\r\n\r\n### DuckDB Client:\r\n\r\nR, WASM\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nLukas Schneiderbauer\r\n\r\n### Affiliation:\r\n\r\nNone\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\nUnexpected implicit cast when using CASE WHEN\n### What happens?\r\n\r\nI am observing some unexpected type casting when using CASE WHEN in a query.\r\n\r\nWhen using an ENUM-typed variable inside a CASE WHEN check, the resulting value will be of type VARCHAR instead of ENUM,  which is unnecessary and wrong in my opinion.\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nCREATE TYPE E1 AS ENUM ('v1', 'v2');\r\nCREATE TABLE t1 (v E1);\r\nINSERT INTO t1 VALUES ('v1');\r\nINSERT INTO t1 VALUES ('v1');\r\nINSERT INTO t1 VALUES ('v1');\r\n\r\n-- This returns a result only if all elements in a column are equal (namely this value), otherwise it should return NULL.\r\nDESCRIBE (SELECT CASE WHEN COUNT(DISTINCT v) == 1 THEN FIRST(v) END AS r FROM t1);\r\n```\r\nOutput:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 column_name \u2506 column_type \u2506 null \u2506 key \u2506 default \u2506 extra \u2502\r\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\r\n\u2502 r           \u2506 VARCHAR     \u2506 YES  \u2506     \u2506         \u2506       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nI expect the column type to be of ENUM E1 type, not VARCHAR.\r\n\r\n### OS:\r\n\r\nMS Windows 10, x64\r\n\r\n### DuckDB Version:\r\n\r\n1.1.3\r\n\r\n### DuckDB Client:\r\n\r\nR, WASM\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nLukas Schneiderbauer\r\n\r\n### Affiliation:\r\n\r\nNone\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "duplicate of https://github.com/duckdb/duckdb/issues/14935\nduplicate of https://github.com/duckdb/duckdb/issues/14935",
  "created_at": "2024-12-12T10:48:24Z"
}