You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
INTERNAL Error caused by INNER JOIN
### What happens?

When I try to perform an inner join on two tables using DuckDB, I encounter an INTERNAL Error.

### To Reproduce

``` sql
CREATE TABLE t1(c0 INT4, c1 VARCHAR);
CREATE TABLE t2(c0 TINYINT, PRIMARY KEY(c0));
INSERT INTO t1(c0) VALUES (14161972);
INSERT INTO t1(c0, c1) VALUES (-1.438515327E9, 4.43806148E8); 
SELECT * FROM t1 INNER JOIN t2 ON t1.c0 = t2.c0;
```
```
INTERNAL Error: Information loss on integer cast: value -255 outside of target range [0, -1]
This error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.
For more information, see https://duckdb.org/docs/dev/internal_errors
```

### OS:

Ubuntu 20.04.6 x64

### DuckDB Version:

v1.0.0 (1f98600)

### DuckDB Client:

Cli

### Full Name:

Personal

### Affiliation:

Personal

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
INTERNAL Error caused by INNER JOIN
### What happens?

When I try to perform an inner join on two tables using DuckDB, I encounter an INTERNAL Error.

### To Reproduce

``` sql
CREATE TABLE t1(c0 INT4, c1 VARCHAR);
CREATE TABLE t2(c0 TINYINT, PRIMARY KEY(c0));
INSERT INTO t1(c0) VALUES (14161972);
INSERT INTO t1(c0, c1) VALUES (-1.438515327E9, 4.43806148E8); 
SELECT * FROM t1 INNER JOIN t2 ON t1.c0 = t2.c0;
```
```
INTERNAL Error: Information loss on integer cast: value -255 outside of target range [0, -1]
This error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.
For more information, see https://duckdb.org/docs/dev/internal_errors
```

### OS:

Ubuntu 20.04.6 x64

### DuckDB Version:

v1.0.0 (1f98600)

### DuckDB Client:

Cli

### Full Name:

Personal

### Affiliation:

Personal

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/execution/physical_plan/plan_comparison_join.cpp]
1: #include "duckdb/execution/operator/join/perfect_hash_join_executor.hpp"
2: #include "duckdb/execution/operator/join/physical_cross_product.hpp"
3: #include "duckdb/execution/operator/join/physical_hash_join.hpp"
4: #include "duckdb/execution/operator/join/physical_iejoin.hpp"
5: #include "duckdb/execution/operator/join/physical_nested_loop_join.hpp"
6: #include "duckdb/execution/operator/join/physical_piecewise_merge_join.hpp"
7: #include "duckdb/execution/operator/scan/physical_table_scan.hpp"
8: #include "duckdb/execution/physical_plan_generator.hpp"
9: #include "duckdb/function/table/table_scan.hpp"
10: #include "duckdb/main/client_context.hpp"
11: #include "duckdb/planner/operator/logical_comparison_join.hpp"
12: #include "duckdb/transaction/duck_transaction.hpp"
13: #include "duckdb/common/operator/subtract.hpp"
14: #include "duckdb/execution/operator/join/physical_blockwise_nl_join.hpp"
15: #include "duckdb/planner/expression/bound_reference_expression.hpp"
16: #include "duckdb/planner/expression_iterator.hpp"
17: #include "duckdb/catalog/catalog_entry/duck_table_entry.hpp"
18: 
19: namespace duckdb {
20: 
21: bool ExtractNumericValue(Value val, int64_t &result) {
22: 	if (!val.type().IsIntegral()) {
23: 		switch (val.type().InternalType()) {
24: 		case PhysicalType::INT16:
25: 			result = val.GetValueUnsafe<int16_t>();
26: 			break;
27: 		case PhysicalType::INT32:
28: 			result = val.GetValueUnsafe<int32_t>();
29: 			break;
30: 		case PhysicalType::INT64:
31: 			result = val.GetValueUnsafe<int64_t>();
32: 			break;
33: 		default:
34: 			return false;
35: 		}
36: 	} else {
37: 		if (!val.DefaultTryCastAs(LogicalType::BIGINT)) {
38: 			return false;
39: 		}
40: 		result = val.GetValue<int64_t>();
41: 	}
42: 	return true;
43: }
44: 
45: void CheckForPerfectJoinOpt(LogicalComparisonJoin &op, PerfectHashJoinStats &join_state) {
46: 	// we only do this optimization for inner joins
47: 	if (op.join_type != JoinType::INNER) {
48: 		return;
49: 	}
50: 	// with one condition
51: 	if (op.conditions.size() != 1) {
52: 		return;
53: 	}
54: 	// with propagated statistics
55: 	if (op.join_stats.empty()) {
56: 		return;
57: 	}
58: 	for (auto &type : op.children[1]->types) {
59: 		switch (type.InternalType()) {
60: 		case PhysicalType::STRUCT:
61: 		case PhysicalType::LIST:
62: 		case PhysicalType::ARRAY:
63: 			return;
64: 		default:
65: 			break;
66: 		}
67: 	}
68: 	// with equality condition and null values not equal
69: 	for (auto &&condition : op.conditions) {
70: 		if (condition.comparison != ExpressionType::COMPARE_EQUAL) {
71: 			return;
72: 		}
73: 	}
74: 	// with integral internal types
75: 	for (auto &&join_stat : op.join_stats) {
76: 		if (!TypeIsInteger(join_stat->GetType().InternalType()) ||
77: 		    join_stat->GetType().InternalType() == PhysicalType::INT128 ||
78: 		    join_stat->GetType().InternalType() == PhysicalType::UINT128) {
79: 			// perfect join not possible for non-integral types or hugeint
80: 			return;
81: 		}
82: 	}
83: 
84: 	// and when the build range is smaller than the threshold
85: 	auto &stats_build = *op.join_stats[1].get(); // rhs stats
86: 	if (!NumericStats::HasMinMax(stats_build)) {
87: 		return;
88: 	}
89: 	int64_t min_value, max_value;
90: 	if (!ExtractNumericValue(NumericStats::Min(stats_build), min_value) ||
91: 	    !ExtractNumericValue(NumericStats::Max(stats_build), max_value)) {
92: 		return;
93: 	}
94: 	int64_t build_range;
95: 	if (!TrySubtractOperator::Operation(max_value, min_value, build_range)) {
96: 		return;
97: 	}
98: 
99: 	// Fill join_stats for invisible join
100: 	auto &stats_probe = *op.join_stats[0].get(); // lhs stats
101: 	if (!NumericStats::HasMinMax(stats_probe)) {
102: 		return;
103: 	}
104: 
105: 	// The max size our build must have to run the perfect HJ
106: 	const idx_t MAX_BUILD_SIZE = 1000000;
107: 	join_state.probe_min = NumericStats::Min(stats_probe);
108: 	join_state.probe_max = NumericStats::Max(stats_probe);
109: 	join_state.build_min = NumericStats::Min(stats_build);
110: 	join_state.build_max = NumericStats::Max(stats_build);
111: 	join_state.estimated_cardinality = op.estimated_cardinality;
112: 	join_state.build_range = NumericCast<idx_t>(build_range);
113: 	if (join_state.build_range > MAX_BUILD_SIZE) {
114: 		return;
115: 	}
116: 	if (NumericStats::Min(stats_build) <= NumericStats::Min(stats_probe) &&
117: 	    NumericStats::Max(stats_probe) <= NumericStats::Max(stats_build)) {
118: 		join_state.is_probe_in_domain = true;
119: 	}
120: 	join_state.is_build_small = true;
121: 	return;
122: }
123: 
124: static void RewriteJoinCondition(Expression &expr, idx_t offset) {
125: 	if (expr.type == ExpressionType::BOUND_REF) {
126: 		auto &ref = expr.Cast<BoundReferenceExpression>();
127: 		ref.index += offset;
128: 	}
129: 	ExpressionIterator::EnumerateChildren(expr, [&](Expression &child) { RewriteJoinCondition(child, offset); });
130: }
131: 
132: bool PhysicalPlanGenerator::HasEquality(vector<JoinCondition> &conds, idx_t &range_count) {
133: 	for (size_t c = 0; c < conds.size(); ++c) {
134: 		auto &cond = conds[c];
135: 		switch (cond.comparison) {
136: 		case ExpressionType::COMPARE_EQUAL:
137: 		case ExpressionType::COMPARE_NOT_DISTINCT_FROM:
138: 			return true;
139: 		case ExpressionType::COMPARE_LESSTHAN:
140: 		case ExpressionType::COMPARE_GREATERTHAN:
141: 		case ExpressionType::COMPARE_LESSTHANOREQUALTO:
142: 		case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
143: 			++range_count;
144: 			break;
145: 		case ExpressionType::COMPARE_NOTEQUAL:
146: 		case ExpressionType::COMPARE_DISTINCT_FROM:
147: 			break;
148: 		default:
149: 			throw NotImplementedException("Unimplemented comparison join");
150: 		}
151: 	}
152: 	return false;
153: }
154: 
155: unique_ptr<PhysicalOperator> PhysicalPlanGenerator::PlanComparisonJoin(LogicalComparisonJoin &op) {
156: 	// now visit the children
157: 	D_ASSERT(op.children.size() == 2);
158: 	idx_t lhs_cardinality = op.children[0]->EstimateCardinality(context);
159: 	idx_t rhs_cardinality = op.children[1]->EstimateCardinality(context);
160: 	auto left = CreatePlan(*op.children[0]);
161: 	auto right = CreatePlan(*op.children[1]);
162: 	left->estimated_cardinality = lhs_cardinality;
163: 	right->estimated_cardinality = rhs_cardinality;
164: 	D_ASSERT(left && right);
165: 
166: 	if (op.conditions.empty()) {
167: 		// no conditions: insert a cross product
168: 		return make_uniq<PhysicalCrossProduct>(op.types, std::move(left), std::move(right), op.estimated_cardinality);
169: 	}
170: 
171: 	idx_t has_range = 0;
172: 	bool has_equality = HasEquality(op.conditions, has_range);
173: 	bool can_merge = has_range > 0;
174: 	bool can_iejoin = has_range >= 2 && recursive_cte_tables.empty();
175: 	switch (op.join_type) {
176: 	case JoinType::SEMI:
177: 	case JoinType::ANTI:
178: 	case JoinType::RIGHT_ANTI:
179: 	case JoinType::RIGHT_SEMI:
180: 	case JoinType::MARK:
181: 		can_merge = can_merge && op.conditions.size() == 1;
182: 		can_iejoin = false;
183: 		break;
184: 	default:
185: 		break;
186: 	}
187: 	auto &client_config = ClientConfig::GetConfig(context);
188: 
189: 	//	TODO: Extend PWMJ to handle all comparisons and projection maps
190: 	const auto prefer_range_joins = client_config.prefer_range_joins && can_iejoin;
191: 
192: 	unique_ptr<PhysicalOperator> plan;
193: 	if (has_equality && !prefer_range_joins) {
194: 		// Equality join with small number of keys : possible perfect join optimization
195: 		PerfectHashJoinStats perfect_join_stats;
196: 		CheckForPerfectJoinOpt(op, perfect_join_stats);
197: 		plan = make_uniq<PhysicalHashJoin>(op, std::move(left), std::move(right), std::move(op.conditions),
198: 		                                   op.join_type, op.left_projection_map, op.right_projection_map,
199: 		                                   std::move(op.mark_types), op.estimated_cardinality, perfect_join_stats);
200: 
201: 	} else {
202: 		if (left->estimated_cardinality <= client_config.nested_loop_join_threshold ||
203: 		    right->estimated_cardinality <= client_config.nested_loop_join_threshold) {
204: 			can_iejoin = false;
205: 			can_merge = false;
206: 		}
207: 		if (can_merge && can_iejoin) {
208: 			if (left->estimated_cardinality <= client_config.merge_join_threshold ||
209: 			    right->estimated_cardinality <= client_config.merge_join_threshold) {
210: 				can_iejoin = false;
211: 			}
212: 		}
213: 		if (can_iejoin) {
214: 			plan = make_uniq<PhysicalIEJoin>(op, std::move(left), std::move(right), std::move(op.conditions),
215: 			                                 op.join_type, op.estimated_cardinality);
216: 		} else if (can_merge) {
217: 			// range join: use piecewise merge join
218: 			plan =
219: 			    make_uniq<PhysicalPiecewiseMergeJoin>(op, std::move(left), std::move(right), std::move(op.conditions),
220: 			                                          op.join_type, op.estimated_cardinality);
221: 		} else if (PhysicalNestedLoopJoin::IsSupported(op.conditions, op.join_type)) {
222: 			// inequality join: use nested loop
223: 			plan = make_uniq<PhysicalNestedLoopJoin>(op, std::move(left), std::move(right), std::move(op.conditions),
224: 			                                         op.join_type, op.estimated_cardinality);
225: 		} else {
226: 			for (auto &cond : op.conditions) {
227: 				RewriteJoinCondition(*cond.right, left->types.size());
228: 			}
229: 			auto condition = JoinCondition::CreateExpression(std::move(op.conditions));
230: 			plan = make_uniq<PhysicalBlockwiseNLJoin>(op, std::move(left), std::move(right), std::move(condition),
231: 			                                          op.join_type, op.estimated_cardinality);
232: 		}
233: 	}
234: 	return plan;
235: }
236: 
237: unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalComparisonJoin &op) {
238: 	switch (op.type) {
239: 	case LogicalOperatorType::LOGICAL_ASOF_JOIN:
240: 		return PlanAsOfJoin(op);
241: 	case LogicalOperatorType::LOGICAL_COMPARISON_JOIN:
242: 		return PlanComparisonJoin(op);
243: 	case LogicalOperatorType::LOGICAL_DELIM_JOIN:
244: 		return PlanDelimJoin(op);
245: 	default:
246: 		throw InternalException("Unrecognized operator type for LogicalComparisonJoin");
247: 	}
248: }
249: 
250: } // namespace duckdb
[end of src/execution/physical_plan/plan_comparison_join.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: