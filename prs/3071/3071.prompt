You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
DuckDB C interface and decimal support
#### What happens?
When querying a table with the `decimal` column, the query fails with `DuckDBError` but without any error message.

#### To Reproduce
Using the C Api run the following statements:

```c
CREATE TABLE test (dec DECIMAL(18, 4) NULL, value FLOAT NULL);

INSERT INTO test (dec, value) SELECT NULL, 10

SELECT * FROM test
```

The last `duckdb_query` returns `DuckDBError` without any error message. The column type for the first column is `DUCKDB_TYPE_INVALID`

#### Environment
 - OS: Windows 10
 - DuckDB Version: 0.3.1
 - DuckDB Client: C Api


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of src/include/duckdb.h]
1: //===----------------------------------------------------------------------===//
2: //
3: //                         DuckDB
4: //
5: // duckdb.h
6: //
7: //
8: //===----------------------------------------------------------------------===//
9: 
10: #pragma once
11: 
12: // duplicate of duckdb/main/winapi.hpp
13: #ifndef DUCKDB_API
14: #ifdef _WIN32
15: #if defined(DUCKDB_BUILD_LIBRARY) && !defined(DUCKDB_BUILD_LOADABLE_EXTENSION)
16: #define DUCKDB_API __declspec(dllexport)
17: #else
18: #define DUCKDB_API __declspec(dllimport)
19: #endif
20: #else
21: #define DUCKDB_API
22: #endif
23: #endif
24: 
25: // duplicate of duckdb/common/constants.hpp
26: #ifndef DUCKDB_API_0_3_1
27: #define DUCKDB_API_0_3_1 1
28: #endif
29: #ifndef DUCKDB_API_0_3_2
30: #define DUCKDB_API_0_3_2 2
31: #endif
32: #ifndef DUCKDB_API_LATEST
33: #define DUCKDB_API_LATEST DUCKDB_API_0_3_2
34: #endif
35: 
36: #ifndef DUCKDB_API_VERSION
37: #define DUCKDB_API_VERSION DUCKDB_API_LATEST
38: #endif
39: 
40: #include <stdbool.h>
41: #include <stdint.h>
42: #include <stdlib.h>
43: 
44: #ifdef __cplusplus
45: extern "C" {
46: #endif
47: 
48: //===--------------------------------------------------------------------===//
49: // Type Information
50: //===--------------------------------------------------------------------===//
51: typedef uint64_t idx_t;
52: 
53: typedef enum DUCKDB_TYPE {
54: 	DUCKDB_TYPE_INVALID = 0,
55: 	// bool
56: 	DUCKDB_TYPE_BOOLEAN,
57: 	// int8_t
58: 	DUCKDB_TYPE_TINYINT,
59: 	// int16_t
60: 	DUCKDB_TYPE_SMALLINT,
61: 	// int32_t
62: 	DUCKDB_TYPE_INTEGER,
63: 	// int64_t
64: 	DUCKDB_TYPE_BIGINT,
65: 	// uint8_t
66: 	DUCKDB_TYPE_UTINYINT,
67: 	// uint16_t
68: 	DUCKDB_TYPE_USMALLINT,
69: 	// uint32_t
70: 	DUCKDB_TYPE_UINTEGER,
71: 	// uint64_t
72: 	DUCKDB_TYPE_UBIGINT,
73: 	// float
74: 	DUCKDB_TYPE_FLOAT,
75: 	// double
76: 	DUCKDB_TYPE_DOUBLE,
77: 	// duckdb_timestamp
78: 	DUCKDB_TYPE_TIMESTAMP,
79: 	// duckdb_date
80: 	DUCKDB_TYPE_DATE,
81: 	// duckdb_time
82: 	DUCKDB_TYPE_TIME,
83: 	// duckdb_interval
84: 	DUCKDB_TYPE_INTERVAL,
85: 	// duckdb_hugeint
86: 	DUCKDB_TYPE_HUGEINT,
87: 	// const char*
88: 	DUCKDB_TYPE_VARCHAR,
89: 	// duckdb_blob
90: 	DUCKDB_TYPE_BLOB
91: } duckdb_type;
92: 
93: //! Days are stored as days since 1970-01-01
94: //! Use the duckdb_from_date/duckdb_to_date function to extract individual information
95: typedef struct {
96: 	int32_t days;
97: } duckdb_date;
98: 
99: typedef struct {
100: 	int32_t year;
101: 	int8_t month;
102: 	int8_t day;
103: } duckdb_date_struct;
104: 
105: //! Time is stored as microseconds since 00:00:00
106: //! Use the duckdb_from_time/duckdb_to_time function to extract individual information
107: typedef struct {
108: 	int64_t micros;
109: } duckdb_time;
110: 
111: typedef struct {
112: 	int8_t hour;
113: 	int8_t min;
114: 	int8_t sec;
115: 	int32_t micros;
116: } duckdb_time_struct;
117: 
118: //! Timestamps are stored as microseconds since 1970-01-01
119: //! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information
120: typedef struct {
121: 	int64_t micros;
122: } duckdb_timestamp;
123: 
124: typedef struct {
125: 	duckdb_date_struct date;
126: 	duckdb_time_struct time;
127: } duckdb_timestamp_struct;
128: 
129: typedef struct {
130: 	int32_t months;
131: 	int32_t days;
132: 	int64_t micros;
133: } duckdb_interval;
134: 
135: //! Hugeints are composed in a (lower, upper) component
136: //! The value of the hugeint is upper * 2^64 + lower
137: //! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended
138: typedef struct {
139: 	uint64_t lower;
140: 	int64_t upper;
141: } duckdb_hugeint;
142: 
143: typedef struct {
144: 	void *data;
145: 	idx_t size;
146: } duckdb_blob;
147: 
148: typedef struct {
149: #if DUCKDB_API_VERSION < DUCKDB_API_0_3_2
150: 	void *data;
151: 	bool *nullmask;
152: 	duckdb_type type;
153: 	char *name;
154: #else
155: 	// deprecated, use duckdb_column_data
156: 	void *__deprecated_data;
157: 	// deprecated, use duckdb_nullmask_data
158: 	bool *__deprecated_nullmask;
159: 	// deprecated, use duckdb_column_type
160: 	duckdb_type __deprecated_type;
161: 	// deprecated, use duckdb_column_name
162: 	char *__deprecated_name;
163: #endif
164: 	void *internal_data;
165: } duckdb_column;
166: 
167: typedef struct {
168: #if DUCKDB_API_VERSION < DUCKDB_API_0_3_2
169: 	idx_t column_count;
170: 	idx_t row_count;
171: 	idx_t rows_changed;
172: 	duckdb_column *columns;
173: 	char *error_message;
174: #else
175: 	// deprecated, use duckdb_column_count
176: 	idx_t __deprecated_column_count;
177: 	// deprecated, use duckdb_row_count
178: 	idx_t __deprecated_row_count;
179: 	// deprecated, use duckdb_rows_changed
180: 	idx_t __deprecated_rows_changed;
181: 	// deprecated, use duckdb_column_ family of functions
182: 	duckdb_column *__deprecated_columns;
183: 	// deprecated, use duckdb_result_error
184: 	char *__deprecated_error_message;
185: #endif
186: 	void *internal_data;
187: } duckdb_result;
188: 
189: typedef void *duckdb_database;
190: typedef void *duckdb_connection;
191: typedef void *duckdb_prepared_statement;
192: typedef void *duckdb_appender;
193: typedef void *duckdb_arrow;
194: typedef void *duckdb_config;
195: typedef void *duckdb_arrow_schema;
196: typedef void *duckdb_arrow_array;
197: 
198: typedef enum { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;
199: 
200: //===--------------------------------------------------------------------===//
201: // Open/Connect
202: //===--------------------------------------------------------------------===//
203: 
204: /*!
205: Creates a new database or opens an existing database file stored at the the given path.
206: If no path is given a new in-memory database is created instead.
207: 
208: * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
209: * out_database: The result database object.
210: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
211: */
212: DUCKDB_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);
213: 
214: /*!
215: Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the the given path.
216: 
217: * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
218: * out_database: The result database object.
219: * config: (Optional) configuration used to start up the database system.
220: * out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.
221: Note that the error must be freed using `duckdb_free`.
222: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
223: */
224: DUCKDB_API duckdb_state duckdb_open_ext(const char *path, duckdb_database *out_database, duckdb_config config,
225:                                         char **out_error);
226: 
227: /*!
228: Closes the specified database and de-allocates all memory allocated for that database.
229: This should be called after you are done with any database allocated through `duckdb_open`.
230: Note that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.
231: Still it is recommended to always correctly close a database object after you are done with it.
232: 
233: * database: The database object to shut down.
234: */
235: DUCKDB_API void duckdb_close(duckdb_database *database);
236: 
237: /*!
238: Opens a connection to a database. Connections are required to query the database, and store transactional state
239: associated with the connection.
240: 
241: * database: The database file to connect to.
242: * out_connection: The result connection object.
243: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
244: */
245: DUCKDB_API duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out_connection);
246: 
247: /*!
248: Closes the specified connection and de-allocates all memory allocated for that connection.
249: 
250: * connection: The connection to close.
251: */
252: DUCKDB_API void duckdb_disconnect(duckdb_connection *connection);
253: 
254: //===--------------------------------------------------------------------===//
255: // Configuration
256: //===--------------------------------------------------------------------===//
257: /*!
258: Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance
259: through `duckdb_open_ext`.
260: 
261: This will always succeed unless there is a malloc failure.
262: 
263: * out_config: The result configuration object.
264: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
265: */
266: DUCKDB_API duckdb_state duckdb_create_config(duckdb_config *out_config);
267: 
268: /*!
269: This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.
270: 
271: This should not be called in a loop as it internally loops over all the options.
272: 
273: * returns: The amount of config options available.
274: */
275: DUCKDB_API size_t duckdb_config_count();
276: 
277: /*!
278: Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.
279: display configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).
280: 
281: The result name or description MUST NOT be freed.
282: 
283: * index: The index of the configuration option (between 0 and `duckdb_config_count`)
284: * out_name: A name of the configuration flag.
285: * out_description: A description of the configuration flag.
286: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
287: */
288: DUCKDB_API duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description);
289: 
290: /*!
291: Sets the specified option for the specified configuration. The configuration option is indicated by name.
292: To obtain a list of config options, see `duckdb_get_config_flag`.
293: 
294: In the source code, configuration options are defined in `config.cpp`.
295: 
296: This can fail if either the name is invalid, or if the value provided for the option is invalid.
297: 
298: * duckdb_config: The configuration object to set the option on.
299: * name: The name of the configuration flag to set.
300: * option: The value to set the configuration flag to.
301: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
302: */
303: DUCKDB_API duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option);
304: 
305: /*!
306: Destroys the specified configuration option and de-allocates all memory allocated for the object.
307: 
308: * config: The configuration object to destroy.
309: */
310: DUCKDB_API void duckdb_destroy_config(duckdb_config *config);
311: 
312: //===--------------------------------------------------------------------===//
313: // Query Execution
314: //===--------------------------------------------------------------------===//
315: /*!
316: Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.
317: If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
318: `duckdb_result_error`.
319: 
320: Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the
321: query fails, otherwise the error stored within the result will not be freed correctly.
322: 
323: * connection: The connection to perform the query in.
324: * query: The SQL query to run.
325: * out_result: The query result.
326: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
327: */
328: DUCKDB_API duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out_result);
329: 
330: /*!
331: Closes the result and de-allocates all memory allocated for that connection.
332: 
333: * result: The result to destroy.
334: */
335: DUCKDB_API void duckdb_destroy_result(duckdb_result *result);
336: 
337: /*!
338: Returns the column name of the specified column. The result should not need be freed; the column names will
339: automatically be destroyed when the result is destroyed.
340: 
341: Returns `NULL` if the column is out of range.
342: 
343: * result: The result object to fetch the column name from.
344: * col: The column index.
345: * returns: The column name of the specified column.
346: */
347: DUCKDB_API const char *duckdb_column_name(duckdb_result *result, idx_t col);
348: 
349: /*!
350: Returns the column type of the specified column.
351: 
352: Returns `DUCKDB_TYPE_INVALID` if the column is out of range.
353: 
354: * result: The result object to fetch the column type from.
355: * col: The column index.
356: * returns: The column type of the specified column.
357: */
358: DUCKDB_API duckdb_type duckdb_column_type(duckdb_result *result, idx_t col);
359: 
360: /*!
361: Returns the number of columns present in a the result object.
362: 
363: * result: The result object.
364: * returns: The number of columns present in the result object.
365: */
366: DUCKDB_API idx_t duckdb_column_count(duckdb_result *result);
367: 
368: /*!
369: Returns the number of rows present in a the result object.
370: 
371: * result: The result object.
372: * returns: The number of rows present in the result object.
373: */
374: DUCKDB_API idx_t duckdb_row_count(duckdb_result *result);
375: 
376: /*!
377: Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE
378: queries. For other queries the rows_changed will be 0.
379: 
380: * result: The result object.
381: * returns: The number of rows changed.
382: */
383: DUCKDB_API idx_t duckdb_rows_changed(duckdb_result *result);
384: 
385: /*!
386: Returns the data of a specific column of a result in columnar format. This is the fastest way of accessing data in a
387: query result, as no conversion or type checking must be performed (outside of the original switch). If performance
388: is a concern, it is recommended to use this API over the `duckdb_value` functions.
389: 
390: The function returns a dense array which contains the result data. The exact type stored in the array depends on the
391: corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
392: accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.
393: 
394: For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:
395: ```c
396: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
397: printf("Data for row %d: %d\n", row, data[row]);
398: ```
399: 
400: * result: The result object to fetch the column data from.
401: * col: The column index.
402: * returns: The column data of the specified column.
403: */
404: DUCKDB_API void *duckdb_column_data(duckdb_result *result, idx_t col);
405: 
406: /*!
407: Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
408: whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
409: by `duckdb_column_data` are undefined.
410: 
411: ```c
412: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
413: bool *nullmask = duckdb_nullmask_data(&result, 0);
414: if (nullmask[row]) {
415:     printf("Data for row %d: NULL\n", row);
416: } else {
417:     printf("Data for row %d: %d\n", row, data[row]);
418: }
419: ```
420: 
421: * result: The result object to fetch the nullmask from.
422: * col: The column index.
423: * returns: The nullmask of the specified column.
424: */
425: DUCKDB_API bool *duckdb_nullmask_data(duckdb_result *result, idx_t col);
426: 
427: /*!
428: Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.
429: 
430: The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.
431: 
432: * result: The result object to fetch the nullmask from.
433: * returns: The error of the result.
434: */
435: DUCKDB_API char *duckdb_result_error(duckdb_result *result);
436: 
437: //===--------------------------------------------------------------------===//
438: // Result Functions
439: //===--------------------------------------------------------------------===//
440: 
441: // Safe fetch functions
442: // These functions will perform conversions if necessary.
443: // On failure (e.g. if conversion cannot be performed or if the value is NULL) a default value is returned.
444: // Note that these functions are slow since they perform bounds checking and conversion
445: // For fast access of values prefer using duckdb_column_data and duckdb_nullmask_data
446: 
447: /*!
448:  * returns: The boolean value at the specified location, or false if the value cannot be converted.
449:  */
450: DUCKDB_API bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row);
451: 
452: /*!
453:  * returns: The int8_t value at the specified location, or 0 if the value cannot be converted.
454:  */
455: DUCKDB_API int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row);
456: 
457: /*!
458:  * returns: The int16_t value at the specified location, or 0 if the value cannot be converted.
459:  */
460: DUCKDB_API int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row);
461: 
462: /*!
463:  * returns: The int32_t value at the specified location, or 0 if the value cannot be converted.
464:  */
465: DUCKDB_API int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row);
466: 
467: /*!
468:  * returns: The int64_t value at the specified location, or 0 if the value cannot be converted.
469:  */
470: DUCKDB_API int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row);
471: 
472: /*!
473:  * returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.
474:  */
475: DUCKDB_API duckdb_hugeint duckdb_value_hugeint(duckdb_result *result, idx_t col, idx_t row);
476: 
477: /*!
478:  * returns: The uint8_t value at the specified location, or 0 if the value cannot be converted.
479:  */
480: DUCKDB_API uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row);
481: 
482: /*!
483:  * returns: The uint16_t value at the specified location, or 0 if the value cannot be converted.
484:  */
485: DUCKDB_API uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row);
486: 
487: /*!
488:  * returns: The uint32_t value at the specified location, or 0 if the value cannot be converted.
489:  */
490: DUCKDB_API uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row);
491: 
492: /*!
493:  * returns: The uint64_t value at the specified location, or 0 if the value cannot be converted.
494:  */
495: DUCKDB_API uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row);
496: 
497: /*!
498:  * returns: The float value at the specified location, or 0 if the value cannot be converted.
499:  */
500: DUCKDB_API float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row);
501: 
502: /*!
503:  * returns: The double value at the specified location, or 0 if the value cannot be converted.
504:  */
505: DUCKDB_API double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row);
506: 
507: /*!
508:  * returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted.
509:  */
510: DUCKDB_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);
511: 
512: /*!
513:  * returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted.
514:  */
515: DUCKDB_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);
516: 
517: /*!
518:  * returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.
519:  */
520: DUCKDB_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);
521: 
522: /*!
523:  * returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted.
524:  */
525: DUCKDB_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);
526: 
527: /*!
528: * returns: The char* value at the specified location, or nullptr if the value cannot be converted.
529: The result must be freed with `duckdb_free`.
530: */
531: DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);
532: 
533: /*!
534: * returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
535: If the column is NOT a VARCHAR column this function will return NULL.
536: 
537: The result must NOT be freed.
538: */
539: DUCKDB_API char *duckdb_value_varchar_internal(duckdb_result *result, idx_t col, idx_t row);
540: 
541: /*!
542: * returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the
543: value cannot be converted. The resulting "blob.data" must be freed with `duckdb_free.`
544: */
545: DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);
546: 
547: /*!
548:  * returns: Returns true if the value at the specified index is NULL, and false otherwise.
549:  */
550: DUCKDB_API bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row);
551: 
552: //===--------------------------------------------------------------------===//
553: // Helpers
554: //===--------------------------------------------------------------------===//
555: /*!
556: Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner
557: should be freed using `duckdb_free`.
558: 
559: * size: The number of bytes to allocate.
560: * returns: A pointer to the allocated memory region.
561: */
562: DUCKDB_API void *duckdb_malloc(size_t size);
563: 
564: /*!
565: Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_value_blob`.
566: 
567: * ptr: The memory region to de-allocate.
568: */
569: DUCKDB_API void duckdb_free(void *ptr);
570: 
571: //===--------------------------------------------------------------------===//
572: // Date/Time/Timestamp Helpers
573: //===--------------------------------------------------------------------===//
574: /*!
575: Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).
576: 
577: * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
578: * returns: The `duckdb_date_struct` with the decomposed elements.
579: */
580: DUCKDB_API duckdb_date_struct duckdb_from_date(duckdb_date date);
581: 
582: /*!
583: Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).
584: 
585: * date: The year, month and date stored in a `duckdb_date_struct`.
586: * returns: The `duckdb_date` element.
587: */
588: DUCKDB_API duckdb_date duckdb_to_date(duckdb_date_struct date);
589: 
590: /*!
591: Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).
592: 
593: * time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.
594: * returns: The `duckdb_time_struct` with the decomposed elements.
595: */
596: DUCKDB_API duckdb_time_struct duckdb_from_time(duckdb_time time);
597: 
598: /*!
599: Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).
600: 
601: * time: The hour, minute, second and microsecond in a `duckdb_time_struct`.
602: * returns: The `duckdb_time` element.
603: */
604: DUCKDB_API duckdb_time duckdb_to_time(duckdb_time_struct time);
605: 
606: /*!
607: Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.
608: 
609: * ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
610: * returns: The `duckdb_timestamp_struct` with the decomposed elements.
611: */
612: DUCKDB_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts);
613: 
614: /*!
615: Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.
616: 
617: * ts: The de-composed elements in a `duckdb_timestamp_struct`.
618: * returns: The `duckdb_timestamp` element.
619: */
620: DUCKDB_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts);
621: 
622: //===--------------------------------------------------------------------===//
623: // Hugeint Helpers
624: //===--------------------------------------------------------------------===//
625: /*!
626: Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.
627: 
628: * val: The hugeint value.
629: * returns: The converted `double` element.
630: */
631: DUCKDB_API double duckdb_hugeint_to_double(duckdb_hugeint val);
632: 
633: /*!
634: Converts a double value to a duckdb_hugeint object.
635: 
636: If the conversion fails because the double value is too big the result will be 0.
637: 
638: * val: The double value.
639: * returns: The converted `duckdb_hugeint` element.
640: */
641: DUCKDB_API duckdb_hugeint duckdb_double_to_hugeint(double val);
642: 
643: //===--------------------------------------------------------------------===//
644: // Prepared Statements
645: //===--------------------------------------------------------------------===//
646: // A prepared statement is a parameterized query that allows you to bind parameters to it.
647: // * This is useful to easily supply parameters to functions and avoid SQL injection attacks.
648: // * This is useful to speed up queries that you will execute several times with different parameters.
649: // Because the query will only be parsed, bound, optimized and planned once during the prepare stage,
650: // rather than once per execution.
651: // For example:
652: //   SELECT * FROM tbl WHERE id=?
653: // Or a query with multiple parameters:
654: //   SELECT * FROM tbl WHERE id=$1 OR name=$2
655: 
656: /*!
657: Create a prepared statement object from a query.
658: 
659: Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using
660: `duckdb_destroy_prepare`, even if the prepare fails.
661: 
662: If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
663: 
664: * connection: The connection object
665: * query: The SQL query to prepare
666: * out_prepared_statement: The resulting prepared statement object
667: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
668: */
669: DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
670:                                        duckdb_prepared_statement *out_prepared_statement);
671: 
672: /*!
673: Closes the prepared statement and de-allocates all memory allocated for that connection.
674: 
675: * prepared_statement: The prepared statement to destroy.
676: */
677: DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);
678: 
679: /*!
680: Returns the error message associated with the given prepared statement.
681: If the prepared statement has no error message, this returns `nullptr` instead.
682: 
683: The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.
684: 
685: * prepared_statement: The prepared statement to obtain the error from.
686: * returns: The error message, or `nullptr` if there is none.
687: */
688: DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);
689: 
690: /*!
691: Returns the number of parameters that can be provided to the given prepared statement.
692: 
693: Returns 0 if the query was not successfully prepared.
694: 
695: * prepared_statement: The prepared statement to obtain the number of parameters for.
696: */
697: DUCKDB_API idx_t duckdb_nparams(duckdb_prepared_statement prepared_statement);
698: 
699: /*!
700: Returns the parameter type for the parameter at the given index.
701: 
702: Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.
703: 
704: * prepared_statement: The prepared statement.
705: * param_idx: The parameter index.
706: * returns: The parameter type
707: */
708: DUCKDB_API duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_t param_idx);
709: 
710: /*!
711: Binds a bool value to the prepared statement at the specified index.
712: */
713: DUCKDB_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);
714: 
715: /*!
716: Binds an int8_t value to the prepared statement at the specified index.
717: */
718: DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
719: 
720: /*!
721: Binds an int16_t value to the prepared statement at the specified index.
722: */
723: DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
724: 
725: /*!
726: Binds an int32_t value to the prepared statement at the specified index.
727: */
728: DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);
729: 
730: /*!
731: Binds an int64_t value to the prepared statement at the specified index.
732: */
733: DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);
734: 
735: /*!
736: Binds an duckdb_hugeint value to the prepared statement at the specified index.
737: */
738: DUCKDB_API duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,
739:                                             duckdb_hugeint val);
740: 
741: /*!
742: Binds an uint8_t value to the prepared statement at the specified index.
743: */
744: DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);
745: 
746: /*!
747: Binds an uint16_t value to the prepared statement at the specified index.
748: */
749: DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val);
750: 
751: /*!
752: Binds an uint32_t value to the prepared statement at the specified index.
753: */
754: DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);
755: 
756: /*!
757: Binds an uint64_t value to the prepared statement at the specified index.
758: */
759: DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);
760: 
761: /*!
762: Binds an float value to the prepared statement at the specified index.
763: */
764: DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);
765: 
766: /*!
767: Binds an double value to the prepared statement at the specified index.
768: */
769: DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);
770: 
771: /*!
772: Binds a duckdb_date value to the prepared statement at the specified index.
773: */
774: DUCKDB_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,
775:                                          duckdb_date val);
776: 
777: /*!
778: Binds a duckdb_time value to the prepared statement at the specified index.
779: */
780: DUCKDB_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,
781:                                          duckdb_time val);
782: 
783: /*!
784: Binds a duckdb_timestamp value to the prepared statement at the specified index.
785: */
786: DUCKDB_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,
787:                                               duckdb_timestamp val);
788: 
789: /*!
790: Binds a duckdb_interval value to the prepared statement at the specified index.
791: */
792: DUCKDB_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,
793:                                              duckdb_interval val);
794: 
795: /*!
796: Binds a null-terminated varchar value to the prepared statement at the specified index.
797: */
798: DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,
799:                                             const char *val);
800: 
801: /*!
802: Binds a varchar value to the prepared statement at the specified index.
803: */
804: DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,
805:                                                    const char *val, idx_t length);
806: 
807: /*!
808: Binds a blob value to the prepared statement at the specified index.
809: */
810: DUCKDB_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,
811:                                          const void *data, idx_t length);
812: 
813: /*!
814: Binds a NULL value to the prepared statement at the specified index.
815: */
816: DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);
817: 
818: /*!
819: Executes the prepared statement with the given bound parameters, and returns a materialized query result.
820: 
821: This method can be called multiple times for each prepared statement, and the parameters can be modified
822: between calls to this function.
823: 
824: * prepared_statement: The prepared statement to execute.
825: * out_result: The query result.
826: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
827: */
828: DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,
829:                                                 duckdb_result *out_result);
830: 
831: /*!
832: Executes the prepared statement with the given bound parameters, and returns an arrow query result.
833: 
834: * prepared_statement: The prepared statement to execute.
835: * out_result: The query result.
836: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
837: */
838: DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,
839:                                                       duckdb_arrow *out_result);
840: 
841: //===--------------------------------------------------------------------===//
842: // Appender
843: //===--------------------------------------------------------------------===//
844: 
845: // Appenders are the most efficient way of loading data into DuckDB from within the C interface, and are recommended for
846: // fast data loading. The appender is much faster than using prepared statements or individual `INSERT INTO` statements.
847: 
848: // Appends are made in row-wise format. For every column, a `duckdb_append_[type]` call should be made, after which
849: // the row should be finished by calling `duckdb_appender_end_row`. After all rows have been appended,
850: // `duckdb_appender_destroy` should be used to finalize the appender and clean up the resulting memory.
851: 
852: // Note that `duckdb_appender_destroy` should always be called on the resulting appender, even if the function returns
853: // `DuckDBError`.
854: 
855: /*!
856: Creates an appender object.
857: 
858: * connection: The connection context to create the appender in.
859: * schema: The schema of the table to append to, or `nullptr` for the default schema.
860: * table: The table name to append to.
861: * out_appender: The resulting appender object.
862: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
863: */
864: DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
865:                                                duckdb_appender *out_appender);
866: 
867: /*!
868: Returns the error message associated with the given appender.
869: If the appender has no error message, this returns `nullptr` instead.
870: 
871: The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.
872: 
873: * appender: The appender to get the error from.
874: * returns: The error message, or `nullptr` if there is none.
875: */
876: DUCKDB_API const char *duckdb_appender_error(duckdb_appender appender);
877: 
878: /*!
879: Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the
880: base table.
881: 
882: This should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you
883: are done with the appender.
884: 
885: * appender: The appender to flush.
886: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
887: */
888: DUCKDB_API duckdb_state duckdb_appender_flush(duckdb_appender appender);
889: 
890: /*!
891: Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.
892: 
893: This is generally not necessary. Call `duckdb_appender_destroy` instead.
894: 
895: * appender: The appender to flush and close.
896: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
897: */
898: DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);
899: 
900: /*!
901: Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating
902: all memory associated with the appender.
903: 
904: * appender: The appender to flush, close and destroy.
905: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
906: */
907: DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);
908: 
909: /*!
910: A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.
911: */
912: DUCKDB_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);
913: 
914: /*!
915: Finish the current row of appends. After end_row is called, the next row can be appended.
916: 
917: * appender: The appender.
918: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
919: */
920: DUCKDB_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);
921: 
922: /*!
923: Append a bool value to the appender.
924: */
925: DUCKDB_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);
926: 
927: /*!
928: Append an int8_t value to the appender.
929: */
930: DUCKDB_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);
931: /*!
932: Append an int16_t value to the appender.
933: */
934: DUCKDB_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);
935: /*!
936: Append an int32_t value to the appender.
937: */
938: DUCKDB_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);
939: /*!
940: Append an int64_t value to the appender.
941: */
942: DUCKDB_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);
943: /*!
944: Append a duckdb_hugeint value to the appender.
945: */
946: DUCKDB_API duckdb_state duckdb_append_hugeint(duckdb_appender appender, duckdb_hugeint value);
947: 
948: /*!
949: Append a uint8_t value to the appender.
950: */
951: DUCKDB_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);
952: /*!
953: Append a uint16_t value to the appender.
954: */
955: DUCKDB_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);
956: /*!
957: Append a uint32_t value to the appender.
958: */
959: DUCKDB_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);
960: /*!
961: Append a uint64_t value to the appender.
962: */
963: DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);
964: 
965: /*!
966: Append a float value to the appender.
967: */
968: DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);
969: /*!
970: Append a double value to the appender.
971: */
972: DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);
973: 
974: /*!
975: Append a duckdb_date value to the appender.
976: */
977: DUCKDB_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);
978: /*!
979: Append a duckdb_time value to the appender.
980: */
981: DUCKDB_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);
982: /*!
983: Append a duckdb_timestamp value to the appender.
984: */
985: DUCKDB_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);
986: /*!
987: Append a duckdb_interval value to the appender.
988: */
989: DUCKDB_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);
990: 
991: /*!
992: Append a varchar value to the appender.
993: */
994: DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);
995: /*!
996: Append a varchar value to the appender.
997: */
998: DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);
999: /*!
1000: Append a blob value to the appender.
1001: */
1002: DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);
1003: /*!
1004: Append a NULL value to the appender (of any type).
1005: */
1006: DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);
1007: 
1008: //===--------------------------------------------------------------------===//
1009: // Arrow Interface
1010: //===--------------------------------------------------------------------===//
1011: /*!
1012: Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.
1013: If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
1014: `duckdb_query_arrow_error`.
1015: 
1016: Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the
1017: query fails, otherwise the error stored within the result will not be freed correctly.
1018: 
1019: * connection: The connection to perform the query in.
1020: * query: The SQL query to run.
1021: * out_result: The query result.
1022: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1023: */
1024: DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);
1025: 
1026: /*!
1027: Fetch the internal arrow schema from the arrow result.
1028: 
1029: * result: The result to fetch the schema from.
1030: * out_schema: The output schema.
1031: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1032: */
1033: DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);
1034: 
1035: /*!
1036: Fetch an internal arrow array from the arrow result.
1037: 
1038: This function can be called multiple time to get next chunks, which will free the previous out_array.
1039: So consume the out_array before calling this function again.
1040: 
1041: * result: The result to fetch the array from.
1042: * out_array: The output array.
1043: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1044: */
1045: DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);
1046: 
1047: /*!
1048: Returns the number of columns present in a the arrow result object.
1049: 
1050: * result: The result object.
1051: * returns: The number of columns present in the result object.
1052: */
1053: DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);
1054: 
1055: /*!
1056: Returns the number of rows present in a the arrow result object.
1057: 
1058: * result: The result object.
1059: * returns: The number of rows present in the result object.
1060: */
1061: DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);
1062: 
1063: /*!
1064: Returns the number of rows changed by the query stored in the arrow result. This is relevant only for
1065: INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.
1066: 
1067: * result: The result object.
1068: * returns: The number of rows changed.
1069: */
1070: DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);
1071: 
1072: /*!
1073: Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns
1074: `DuckDBError`.
1075: 
1076: The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.
1077: 
1078: * result: The result object to fetch the nullmask from.
1079: * returns: The error of the result.
1080: */
1081: DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);
1082: 
1083: /*!
1084: Closes the result and de-allocates all memory allocated for the arrow result.
1085: 
1086: * result: The result to destroy.
1087: */
1088: DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
1089: 
1090: #ifdef __cplusplus
1091: }
1092: #endif
[end of src/include/duckdb.h]
[start of src/include/duckdb/main/capi_internal.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/capi_internal.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb.h"
12: #include "duckdb.hpp"
13: #include "duckdb/common/types/data_chunk.hpp"
14: #include "duckdb/main/appender.hpp"
15: #include <cstring>
16: #include <cassert>
17: 
18: #ifdef _WIN32
19: #ifndef strdup
20: #define strdup _strdup
21: #endif
22: #endif
23: 
24: namespace duckdb {
25: 
26: struct DatabaseData {
27: 	unique_ptr<DuckDB> database;
28: };
29: 
30: struct PreparedStatementWrapper {
31: 	unique_ptr<PreparedStatement> statement;
32: 	vector<Value> values;
33: };
34: 
35: struct ArrowResultWrapper {
36: 	unique_ptr<MaterializedQueryResult> result;
37: 	unique_ptr<DataChunk> current_chunk;
38: };
39: 
40: struct AppenderWrapper {
41: 	unique_ptr<Appender> appender;
42: 	string error;
43: };
44: 
45: duckdb_type ConvertCPPTypeToC(const LogicalType &type);
46: idx_t GetCTypeSize(duckdb_type type);
47: duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out);
48: 
49: } // namespace duckdb
[end of src/include/duckdb/main/capi_internal.hpp]
[start of src/main/capi/helper-c.cpp]
1: #include "duckdb/main/capi_internal.hpp"
2: 
3: namespace duckdb {
4: 
5: duckdb_type ConvertCPPTypeToC(const LogicalType &sql_type) {
6: 	switch (sql_type.id()) {
7: 	case LogicalTypeId::BOOLEAN:
8: 		return DUCKDB_TYPE_BOOLEAN;
9: 	case LogicalTypeId::TINYINT:
10: 		return DUCKDB_TYPE_TINYINT;
11: 	case LogicalTypeId::SMALLINT:
12: 		return DUCKDB_TYPE_SMALLINT;
13: 	case LogicalTypeId::INTEGER:
14: 		return DUCKDB_TYPE_INTEGER;
15: 	case LogicalTypeId::BIGINT:
16: 		return DUCKDB_TYPE_BIGINT;
17: 	case LogicalTypeId::UTINYINT:
18: 		return DUCKDB_TYPE_UTINYINT;
19: 	case LogicalTypeId::USMALLINT:
20: 		return DUCKDB_TYPE_USMALLINT;
21: 	case LogicalTypeId::UINTEGER:
22: 		return DUCKDB_TYPE_UINTEGER;
23: 	case LogicalTypeId::UBIGINT:
24: 		return DUCKDB_TYPE_UBIGINT;
25: 	case LogicalTypeId::HUGEINT:
26: 		return DUCKDB_TYPE_HUGEINT;
27: 	case LogicalTypeId::FLOAT:
28: 		return DUCKDB_TYPE_FLOAT;
29: 	case LogicalTypeId::DOUBLE:
30: 		return DUCKDB_TYPE_DOUBLE;
31: 	case LogicalTypeId::TIMESTAMP:
32: 	case LogicalTypeId::TIMESTAMP_SEC:
33: 	case LogicalTypeId::TIMESTAMP_MS:
34: 	case LogicalTypeId::TIMESTAMP_NS:
35: 	case LogicalTypeId::TIMESTAMP_TZ:
36: 		return DUCKDB_TYPE_TIMESTAMP;
37: 	case LogicalTypeId::DATE:
38: 		return DUCKDB_TYPE_DATE;
39: 	case LogicalTypeId::TIME:
40: 	case LogicalTypeId::TIME_TZ:
41: 		return DUCKDB_TYPE_TIME;
42: 	case LogicalTypeId::VARCHAR:
43: 		return DUCKDB_TYPE_VARCHAR;
44: 	case LogicalTypeId::BLOB:
45: 		return DUCKDB_TYPE_BLOB;
46: 	case LogicalTypeId::INTERVAL:
47: 		return DUCKDB_TYPE_INTERVAL;
48: 	default: // LCOV_EXCL_START
49: 		D_ASSERT(0);
50: 		return DUCKDB_TYPE_INVALID;
51: 	} // LCOV_EXCL_STOP
52: }
53: idx_t GetCTypeSize(duckdb_type type) {
54: 	switch (type) {
55: 	case DUCKDB_TYPE_BOOLEAN:
56: 		return sizeof(bool);
57: 	case DUCKDB_TYPE_TINYINT:
58: 		return sizeof(int8_t);
59: 	case DUCKDB_TYPE_SMALLINT:
60: 		return sizeof(int16_t);
61: 	case DUCKDB_TYPE_INTEGER:
62: 		return sizeof(int32_t);
63: 	case DUCKDB_TYPE_BIGINT:
64: 		return sizeof(int64_t);
65: 	case DUCKDB_TYPE_UTINYINT:
66: 		return sizeof(uint8_t);
67: 	case DUCKDB_TYPE_USMALLINT:
68: 		return sizeof(uint16_t);
69: 	case DUCKDB_TYPE_UINTEGER:
70: 		return sizeof(uint32_t);
71: 	case DUCKDB_TYPE_UBIGINT:
72: 		return sizeof(uint64_t);
73: 	case DUCKDB_TYPE_HUGEINT:
74: 		return sizeof(duckdb_hugeint);
75: 	case DUCKDB_TYPE_FLOAT:
76: 		return sizeof(float);
77: 	case DUCKDB_TYPE_DOUBLE:
78: 		return sizeof(double);
79: 	case DUCKDB_TYPE_DATE:
80: 		return sizeof(duckdb_date);
81: 	case DUCKDB_TYPE_TIME:
82: 		return sizeof(duckdb_time);
83: 	case DUCKDB_TYPE_TIMESTAMP:
84: 		return sizeof(duckdb_timestamp);
85: 	case DUCKDB_TYPE_VARCHAR:
86: 		return sizeof(const char *);
87: 	case DUCKDB_TYPE_BLOB:
88: 		return sizeof(duckdb_blob);
89: 	case DUCKDB_TYPE_INTERVAL:
90: 		return sizeof(duckdb_interval);
91: 	default: // LCOV_EXCL_START
92: 		// unsupported type
93: 		D_ASSERT(0);
94: 		return sizeof(const char *);
95: 	} // LCOV_EXCL_STOP
96: }
97: 
98: } // namespace duckdb
99: 
100: void *duckdb_malloc(size_t size) {
101: 	return malloc(size);
102: }
103: 
104: void duckdb_free(void *ptr) {
105: 	free(ptr);
106: }
[end of src/main/capi/helper-c.cpp]
[start of src/main/capi/hugeint-c.cpp]
1: #include "duckdb/main/capi_internal.hpp"
2: #include "duckdb/common/types/hugeint.hpp"
3: 
4: using duckdb::Hugeint;
5: using duckdb::hugeint_t;
6: using duckdb::Value;
7: 
8: double duckdb_hugeint_to_double(duckdb_hugeint val) {
9: 	hugeint_t internal;
10: 	internal.lower = val.lower;
11: 	internal.upper = val.upper;
12: 	return Hugeint::Cast<double>(internal);
13: }
14: 
15: duckdb_hugeint duckdb_double_to_hugeint(double val) {
16: 	hugeint_t internal_result;
17: 	if (!Value::DoubleIsValid(val) || !Hugeint::TryConvert<double>(val, internal_result)) {
18: 		internal_result.lower = 0;
19: 		internal_result.upper = 0;
20: 	}
21: 
22: 	duckdb_hugeint result;
23: 	result.lower = internal_result.lower;
24: 	result.upper = internal_result.upper;
25: 	return result;
26: }
[end of src/main/capi/hugeint-c.cpp]
[start of src/main/capi/result-c.cpp]
1: #include "duckdb/main/capi_internal.hpp"
2: #include "duckdb/common/types/timestamp.hpp"
3: 
4: namespace duckdb {
5: 
6: template <class T>
7: void WriteData(duckdb_result *out, ChunkCollection &source, idx_t col) {
8: 	idx_t row = 0;
9: 	auto target = (T *)out->__deprecated_columns[col].__deprecated_data;
10: 	for (auto &chunk : source.Chunks()) {
11: 		auto source = FlatVector::GetData<T>(chunk->data[col]);
12: 		auto &mask = FlatVector::Validity(chunk->data[col]);
13: 
14: 		for (idx_t k = 0; k < chunk->size(); k++, row++) {
15: 			if (!mask.RowIsValid(k)) {
16: 				continue;
17: 			}
18: 			target[row] = source[k];
19: 		}
20: 	}
21: }
22: 
23: duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out) {
24: 	D_ASSERT(result);
25: 	if (!out) {
26: 		// no result to write to, only return the status
27: 		return result->success ? DuckDBSuccess : DuckDBError;
28: 	}
29: 	memset(out, 0, sizeof(duckdb_result));
30: 	if (!result->success) {
31: 		// write the error message
32: 		out->__deprecated_error_message = strdup(result->error.c_str());
33: 		return DuckDBError;
34: 	}
35: 	// copy the data
36: 	// first write the meta data
37: 	out->__deprecated_column_count = result->types.size();
38: 	out->__deprecated_row_count = result->collection.Count();
39: 	out->__deprecated_rows_changed = 0;
40: 	if (out->__deprecated_row_count > 0 && StatementTypeReturnChanges(result->statement_type)) {
41: 		// update total changes
42: 		auto row_changes = result->GetValue(0, 0);
43: 		if (!row_changes.IsNull() && row_changes.TryCastAs(LogicalType::BIGINT)) {
44: 			out->__deprecated_rows_changed = row_changes.GetValue<int64_t>();
45: 		}
46: 	}
47: 	out->__deprecated_columns = (duckdb_column *)duckdb_malloc(sizeof(duckdb_column) * out->__deprecated_column_count);
48: 	if (!out->__deprecated_columns) { // LCOV_EXCL_START
49: 		// malloc failure
50: 		return DuckDBError;
51: 	} // LCOV_EXCL_STOP
52: 
53: 	// zero initialize the columns (so we can cleanly delete it in case a malloc fails)
54: 	memset(out->__deprecated_columns, 0, sizeof(duckdb_column) * out->__deprecated_column_count);
55: 	for (idx_t i = 0; i < out->__deprecated_column_count; i++) {
56: 		out->__deprecated_columns[i].__deprecated_type = ConvertCPPTypeToC(result->types[i]);
57: 		out->__deprecated_columns[i].__deprecated_name = strdup(result->names[i].c_str());
58: 		out->__deprecated_columns[i].__deprecated_nullmask =
59: 		    (bool *)duckdb_malloc(sizeof(bool) * out->__deprecated_row_count);
60: 		out->__deprecated_columns[i].__deprecated_data =
61: 		    duckdb_malloc(GetCTypeSize(out->__deprecated_columns[i].__deprecated_type) * out->__deprecated_row_count);
62: 		if (!out->__deprecated_columns[i].__deprecated_nullmask || !out->__deprecated_columns[i].__deprecated_name ||
63: 		    !out->__deprecated_columns[i].__deprecated_data) { // LCOV_EXCL_START
64: 			// malloc failure
65: 			return DuckDBError;
66: 		} // LCOV_EXCL_STOP
67: 	}
68: 	// now write the data
69: 	for (idx_t col = 0; col < out->__deprecated_column_count; col++) {
70: 		// first set the nullmask
71: 		idx_t row = 0;
72: 		for (auto &chunk : result->collection.Chunks()) {
73: 			for (idx_t k = 0; k < chunk->size(); k++) {
74: 				out->__deprecated_columns[col].__deprecated_nullmask[row++] = FlatVector::IsNull(chunk->data[col], k);
75: 			}
76: 		}
77: 		// then write the data
78: 		switch (result->types[col].id()) {
79: 		case LogicalTypeId::BOOLEAN:
80: 			WriteData<bool>(out, result->collection, col);
81: 			break;
82: 		case LogicalTypeId::TINYINT:
83: 			WriteData<int8_t>(out, result->collection, col);
84: 			break;
85: 		case LogicalTypeId::SMALLINT:
86: 			WriteData<int16_t>(out, result->collection, col);
87: 			break;
88: 		case LogicalTypeId::INTEGER:
89: 			WriteData<int32_t>(out, result->collection, col);
90: 			break;
91: 		case LogicalTypeId::BIGINT:
92: 			WriteData<int64_t>(out, result->collection, col);
93: 			break;
94: 		case LogicalTypeId::UTINYINT:
95: 			WriteData<uint8_t>(out, result->collection, col);
96: 			break;
97: 		case LogicalTypeId::USMALLINT:
98: 			WriteData<uint16_t>(out, result->collection, col);
99: 			break;
100: 		case LogicalTypeId::UINTEGER:
101: 			WriteData<uint32_t>(out, result->collection, col);
102: 			break;
103: 		case LogicalTypeId::UBIGINT:
104: 			WriteData<uint64_t>(out, result->collection, col);
105: 			break;
106: 		case LogicalTypeId::FLOAT:
107: 			WriteData<float>(out, result->collection, col);
108: 			break;
109: 		case LogicalTypeId::DOUBLE:
110: 			WriteData<double>(out, result->collection, col);
111: 			break;
112: 		case LogicalTypeId::DATE:
113: 			WriteData<date_t>(out, result->collection, col);
114: 			break;
115: 		case LogicalTypeId::TIME:
116: 		case LogicalTypeId::TIME_TZ:
117: 			WriteData<dtime_t>(out, result->collection, col);
118: 			break;
119: 		case LogicalTypeId::TIMESTAMP:
120: 		case LogicalTypeId::TIMESTAMP_TZ:
121: 			WriteData<timestamp_t>(out, result->collection, col);
122: 			break;
123: 		case LogicalTypeId::VARCHAR: {
124: 			idx_t row = 0;
125: 			auto target = (const char **)out->__deprecated_columns[col].__deprecated_data;
126: 			for (auto &chunk : result->collection.Chunks()) {
127: 				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
128: 				for (idx_t k = 0; k < chunk->size(); k++) {
129: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
130: 						target[row] = (char *)duckdb_malloc(source[k].GetSize() + 1);
131: 						assert(target[row]);
132: 						memcpy((void *)target[row], source[k].GetDataUnsafe(), source[k].GetSize());
133: 						auto write_arr = (char *)target[row];
134: 						write_arr[source[k].GetSize()] = '\0';
135: 					} else {
136: 						target[row] = nullptr;
137: 					}
138: 					row++;
139: 				}
140: 			}
141: 			break;
142: 		}
143: 		case LogicalTypeId::BLOB: {
144: 			idx_t row = 0;
145: 			auto target = (duckdb_blob *)out->__deprecated_columns[col].__deprecated_data;
146: 			for (auto &chunk : result->collection.Chunks()) {
147: 				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
148: 				for (idx_t k = 0; k < chunk->size(); k++) {
149: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
150: 						target[row].data = (char *)duckdb_malloc(source[k].GetSize());
151: 						target[row].size = source[k].GetSize();
152: 						assert(target[row].data);
153: 						memcpy((void *)target[row].data, source[k].GetDataUnsafe(), source[k].GetSize());
154: 					} else {
155: 						target[row].data = nullptr;
156: 						target[row].size = 0;
157: 					}
158: 					row++;
159: 				}
160: 			}
161: 			break;
162: 		}
163: 		case LogicalTypeId::TIMESTAMP_NS:
164: 		case LogicalTypeId::TIMESTAMP_MS:
165: 		case LogicalTypeId::TIMESTAMP_SEC: {
166: 			idx_t row = 0;
167: 			auto target = (timestamp_t *)out->__deprecated_columns[col].__deprecated_data;
168: 			for (auto &chunk : result->collection.Chunks()) {
169: 				auto source = FlatVector::GetData<timestamp_t>(chunk->data[col]);
170: 
171: 				for (idx_t k = 0; k < chunk->size(); k++) {
172: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
173: 						if (result->types[col].id() == LogicalTypeId::TIMESTAMP_NS) {
174: 							target[row] = Timestamp::FromEpochNanoSeconds(source[k].value);
175: 						} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_MS) {
176: 							target[row] = Timestamp::FromEpochMs(source[k].value);
177: 						} else {
178: 							D_ASSERT(result->types[col].id() == LogicalTypeId::TIMESTAMP_SEC);
179: 							target[row] = Timestamp::FromEpochSeconds(source[k].value);
180: 						}
181: 					}
182: 					row++;
183: 				}
184: 			}
185: 			break;
186: 		}
187: 		case LogicalTypeId::HUGEINT: {
188: 			idx_t row = 0;
189: 			auto target = (duckdb_hugeint *)out->__deprecated_columns[col].__deprecated_data;
190: 			for (auto &chunk : result->collection.Chunks()) {
191: 				auto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);
192: 				for (idx_t k = 0; k < chunk->size(); k++) {
193: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
194: 						target[row].lower = source[k].lower;
195: 						target[row].upper = source[k].upper;
196: 					}
197: 					row++;
198: 				}
199: 			}
200: 			break;
201: 		}
202: 		case LogicalTypeId::INTERVAL: {
203: 			idx_t row = 0;
204: 			auto target = (duckdb_interval *)out->__deprecated_columns[col].__deprecated_data;
205: 			for (auto &chunk : result->collection.Chunks()) {
206: 				auto source = FlatVector::GetData<interval_t>(chunk->data[col]);
207: 				for (idx_t k = 0; k < chunk->size(); k++) {
208: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
209: 						target[row].days = source[k].days;
210: 						target[row].months = source[k].months;
211: 						target[row].micros = source[k].micros;
212: 					}
213: 					row++;
214: 				}
215: 			}
216: 			break;
217: 		}
218: 		default: // LCOV_EXCL_START
219: 			// unsupported type for C API
220: 			D_ASSERT(0);
221: 			return DuckDBError;
222: 		} // LCOV_EXCL_STOP
223: 	}
224: 	return DuckDBSuccess;
225: }
226: 
227: } // namespace duckdb
228: 
229: static void DuckdbDestroyColumn(duckdb_column column, idx_t count) {
230: 	if (column.__deprecated_data) {
231: 		if (column.__deprecated_type == DUCKDB_TYPE_VARCHAR) {
232: 			// varchar, delete individual strings
233: 			auto data = (char **)column.__deprecated_data;
234: 			for (idx_t i = 0; i < count; i++) {
235: 				if (data[i]) {
236: 					duckdb_free(data[i]);
237: 				}
238: 			}
239: 		} else if (column.__deprecated_type == DUCKDB_TYPE_BLOB) {
240: 			// blob, delete individual blobs
241: 			auto data = (duckdb_blob *)column.__deprecated_data;
242: 			for (idx_t i = 0; i < count; i++) {
243: 				if (data[i].data) {
244: 					duckdb_free((void *)data[i].data);
245: 				}
246: 			}
247: 		}
248: 		duckdb_free(column.__deprecated_data);
249: 	}
250: 	if (column.__deprecated_nullmask) {
251: 		duckdb_free(column.__deprecated_nullmask);
252: 	}
253: 	if (column.__deprecated_name) {
254: 		duckdb_free(column.__deprecated_name);
255: 	}
256: }
257: 
258: void duckdb_destroy_result(duckdb_result *result) {
259: 	if (result->__deprecated_error_message) {
260: 		duckdb_free(result->__deprecated_error_message);
261: 	}
262: 	if (result->__deprecated_columns) {
263: 		for (idx_t i = 0; i < result->__deprecated_column_count; i++) {
264: 			DuckdbDestroyColumn(result->__deprecated_columns[i], result->__deprecated_row_count);
265: 		}
266: 		duckdb_free(result->__deprecated_columns);
267: 	}
268: 	memset(result, 0, sizeof(duckdb_result));
269: }
270: 
271: const char *duckdb_column_name(duckdb_result *result, idx_t col) {
272: 	if (!result || col >= result->__deprecated_column_count) {
273: 		return nullptr;
274: 	}
275: 	return result->__deprecated_columns[col].__deprecated_name;
276: }
277: 
278: duckdb_type duckdb_column_type(duckdb_result *result, idx_t col) {
279: 	if (!result || col >= result->__deprecated_column_count) {
280: 		return DUCKDB_TYPE_INVALID;
281: 	}
282: 	return result->__deprecated_columns[col].__deprecated_type;
283: }
284: 
285: idx_t duckdb_column_count(duckdb_result *result) {
286: 	if (!result) {
287: 		return 0;
288: 	}
289: 	return result->__deprecated_column_count;
290: }
291: 
292: idx_t duckdb_row_count(duckdb_result *result) {
293: 	if (!result) {
294: 		return 0;
295: 	}
296: 	return result->__deprecated_row_count;
297: }
298: 
299: idx_t duckdb_rows_changed(duckdb_result *result) {
300: 	if (!result) {
301: 		return 0;
302: 	}
303: 	return result->__deprecated_rows_changed;
304: }
305: 
306: void *duckdb_column_data(duckdb_result *result, idx_t col) {
307: 	if (!result || col >= result->__deprecated_column_count) {
308: 		return nullptr;
309: 	}
310: 	return result->__deprecated_columns[col].__deprecated_data;
311: }
312: 
313: bool *duckdb_nullmask_data(duckdb_result *result, idx_t col) {
314: 	if (!result || col >= result->__deprecated_column_count) {
315: 		return nullptr;
316: 	}
317: 	return result->__deprecated_columns[col].__deprecated_nullmask;
318: }
319: 
320: char *duckdb_result_error(duckdb_result *result) {
321: 	if (!result) {
322: 		return nullptr;
323: 	}
324: 	return result->__deprecated_error_message;
325: }
[end of src/main/capi/result-c.cpp]
[start of src/main/capi/value-c.cpp]
1: #include "duckdb/main/capi_internal.hpp"
2: #include "duckdb/common/types/date.hpp"
3: #include "duckdb/common/types/time.hpp"
4: #include "duckdb/common/types/timestamp.hpp"
5: #include "duckdb/common/operator/cast_operators.hpp"
6: #include "duckdb/common/operator/string_cast.hpp"
7: 
8: using duckdb::const_data_ptr_t;
9: using duckdb::Date;
10: using duckdb::date_t;
11: using duckdb::dtime_t;
12: using duckdb::hugeint_t;
13: using duckdb::interval_t;
14: using duckdb::LogicalType;
15: using duckdb::string;
16: using duckdb::string_t;
17: using duckdb::Time;
18: using duckdb::Timestamp;
19: using duckdb::timestamp_t;
20: using duckdb::Value;
21: using duckdb::Vector;
22: 
23: namespace duckdb {
24: 
25: //===--------------------------------------------------------------------===//
26: // Unsafe Fetch (for internal use only)
27: //===--------------------------------------------------------------------===//
28: template <class T>
29: T UnsafeFetch(duckdb_result *result, idx_t col, idx_t row) {
30: 	D_ASSERT(row < result->__deprecated_row_count);
31: 	return ((T *)result->__deprecated_columns[col].__deprecated_data)[row];
32: }
33: 
34: //===--------------------------------------------------------------------===//
35: // Fetch Default Value
36: //===--------------------------------------------------------------------===//
37: struct FetchDefaultValue {
38: 	template <class T>
39: 	static T Operation() {
40: 		return 0;
41: 	}
42: };
43: 
44: template <>
45: date_t FetchDefaultValue::Operation() {
46: 	date_t result;
47: 	result.days = 0;
48: 	return result;
49: }
50: 
51: template <>
52: dtime_t FetchDefaultValue::Operation() {
53: 	dtime_t result;
54: 	result.micros = 0;
55: 	return result;
56: }
57: 
58: template <>
59: timestamp_t FetchDefaultValue::Operation() {
60: 	timestamp_t result;
61: 	result.value = 0;
62: 	return result;
63: }
64: 
65: template <>
66: interval_t FetchDefaultValue::Operation() {
67: 	interval_t result;
68: 	result.months = 0;
69: 	result.days = 0;
70: 	result.micros = 0;
71: 	return result;
72: }
73: 
74: template <>
75: char *FetchDefaultValue::Operation() {
76: 	return nullptr;
77: }
78: 
79: template <>
80: duckdb_blob FetchDefaultValue::Operation() {
81: 	duckdb_blob result;
82: 	result.data = nullptr;
83: 	result.size = 0;
84: 	return result;
85: }
86: 
87: //===--------------------------------------------------------------------===//
88: // String Casts
89: //===--------------------------------------------------------------------===//
90: template <class OP>
91: struct FromCStringCastWrapper {
92: 	template <class SOURCE_TYPE, class RESULT_TYPE>
93: 	static bool Operation(SOURCE_TYPE input_str, RESULT_TYPE &result) {
94: 		string_t input(input_str);
95: 		return OP::template Operation<string_t, RESULT_TYPE>(input, result);
96: 	}
97: };
98: 
99: template <class OP>
100: struct ToCStringCastWrapper {
101: 	template <class SOURCE_TYPE, class RESULT_TYPE>
102: 	static bool Operation(SOURCE_TYPE input, RESULT_TYPE &result) {
103: 		Vector result_vector(LogicalType::VARCHAR, nullptr);
104: 		auto result_string = OP::template Operation<SOURCE_TYPE>(input, result_vector);
105: 		auto result_size = result_string.GetSize();
106: 		auto result_data = result_string.GetDataUnsafe();
107: 
108: 		result = (char *)duckdb_malloc(result_size + 1);
109: 		memcpy(result, result_data, result_size);
110: 		result[result_size] = '\0';
111: 		return true;
112: 	}
113: };
114: 
115: //===--------------------------------------------------------------------===//
116: // Blob Casts
117: //===--------------------------------------------------------------------===//
118: struct FromCBlobCastWrapper {
119: 	template <class SOURCE_TYPE, class RESULT_TYPE>
120: 	static bool Operation(SOURCE_TYPE input_str, RESULT_TYPE &result) {
121: 		return false;
122: 	}
123: };
124: 
125: template <>
126: bool FromCBlobCastWrapper::Operation(duckdb_blob input, char *&result) {
127: 	string_t input_str((const char *)input.data, input.size);
128: 	return ToCStringCastWrapper<duckdb::CastFromBlob>::template Operation<string_t, char *>(input_str, result);
129: }
130: 
131: } // namespace duckdb
132: 
133: using duckdb::FetchDefaultValue;
134: using duckdb::FromCBlobCastWrapper;
135: using duckdb::FromCStringCastWrapper;
136: using duckdb::ToCStringCastWrapper;
137: using duckdb::UnsafeFetch;
138: 
139: //===--------------------------------------------------------------------===//
140: // Templated Casts
141: //===--------------------------------------------------------------------===//
142: template <class SOURCE_TYPE, class RESULT_TYPE, class OP>
143: RESULT_TYPE TryCastCInternal(duckdb_result *result, idx_t col, idx_t row) {
144: 	RESULT_TYPE result_value;
145: 	if (!OP::template Operation<SOURCE_TYPE, RESULT_TYPE>(UnsafeFetch<SOURCE_TYPE>(result, col, row), result_value)) {
146: 		return FetchDefaultValue::Operation<RESULT_TYPE>();
147: 	}
148: 	return result_value;
149: }
150: 
151: static bool CanFetchValue(duckdb_result *result, idx_t col, idx_t row) {
152: 	if (!result || col >= result->__deprecated_column_count || row >= result->__deprecated_row_count) {
153: 		return false;
154: 	}
155: 	if (result->__deprecated_columns[col].__deprecated_nullmask[row]) {
156: 		return false;
157: 	}
158: 	return true;
159: }
160: 
161: template <class RESULT_TYPE, class OP = duckdb::TryCast>
162: static RESULT_TYPE GetInternalCValue(duckdb_result *result, idx_t col, idx_t row) {
163: 	if (!CanFetchValue(result, col, row)) {
164: 		return FetchDefaultValue::Operation<RESULT_TYPE>();
165: 	}
166: 	switch (result->__deprecated_columns[col].__deprecated_type) {
167: 	case DUCKDB_TYPE_BOOLEAN:
168: 		return TryCastCInternal<bool, RESULT_TYPE, OP>(result, col, row);
169: 	case DUCKDB_TYPE_TINYINT:
170: 		return TryCastCInternal<int8_t, RESULT_TYPE, OP>(result, col, row);
171: 	case DUCKDB_TYPE_SMALLINT:
172: 		return TryCastCInternal<int16_t, RESULT_TYPE, OP>(result, col, row);
173: 	case DUCKDB_TYPE_INTEGER:
174: 		return TryCastCInternal<int32_t, RESULT_TYPE, OP>(result, col, row);
175: 	case DUCKDB_TYPE_BIGINT:
176: 		return TryCastCInternal<int64_t, RESULT_TYPE, OP>(result, col, row);
177: 	case DUCKDB_TYPE_UTINYINT:
178: 		return TryCastCInternal<uint8_t, RESULT_TYPE, OP>(result, col, row);
179: 	case DUCKDB_TYPE_USMALLINT:
180: 		return TryCastCInternal<uint16_t, RESULT_TYPE, OP>(result, col, row);
181: 	case DUCKDB_TYPE_UINTEGER:
182: 		return TryCastCInternal<uint32_t, RESULT_TYPE, OP>(result, col, row);
183: 	case DUCKDB_TYPE_UBIGINT:
184: 		return TryCastCInternal<uint64_t, RESULT_TYPE, OP>(result, col, row);
185: 	case DUCKDB_TYPE_FLOAT:
186: 		return TryCastCInternal<float, RESULT_TYPE, OP>(result, col, row);
187: 	case DUCKDB_TYPE_DOUBLE:
188: 		return TryCastCInternal<double, RESULT_TYPE, OP>(result, col, row);
189: 	case DUCKDB_TYPE_DATE:
190: 		return TryCastCInternal<date_t, RESULT_TYPE, OP>(result, col, row);
191: 	case DUCKDB_TYPE_TIME:
192: 		return TryCastCInternal<dtime_t, RESULT_TYPE, OP>(result, col, row);
193: 	case DUCKDB_TYPE_TIMESTAMP:
194: 		return TryCastCInternal<timestamp_t, RESULT_TYPE, OP>(result, col, row);
195: 	case DUCKDB_TYPE_HUGEINT:
196: 		return TryCastCInternal<hugeint_t, RESULT_TYPE, OP>(result, col, row);
197: 	case DUCKDB_TYPE_INTERVAL:
198: 		return TryCastCInternal<interval_t, RESULT_TYPE, OP>(result, col, row);
199: 	case DUCKDB_TYPE_VARCHAR:
200: 		return TryCastCInternal<char *, RESULT_TYPE, FromCStringCastWrapper<OP>>(result, col, row);
201: 	case DUCKDB_TYPE_BLOB:
202: 		return TryCastCInternal<duckdb_blob, RESULT_TYPE, FromCBlobCastWrapper>(result, col, row);
203: 	default: // LCOV_EXCL_START
204: 		// invalid type for C to C++ conversion
205: 		D_ASSERT(0);
206: 		return FetchDefaultValue::Operation<RESULT_TYPE>();
207: 	} // LCOV_EXCL_STOP
208: }
209: 
210: //===--------------------------------------------------------------------===//
211: // duckdb_value_ functions
212: //===--------------------------------------------------------------------===//
213: bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row) {
214: 	return GetInternalCValue<bool>(result, col, row);
215: }
216: 
217: int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row) {
218: 	return GetInternalCValue<int8_t>(result, col, row);
219: }
220: 
221: int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row) {
222: 	return GetInternalCValue<int16_t>(result, col, row);
223: }
224: 
225: int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row) {
226: 	return GetInternalCValue<int32_t>(result, col, row);
227: }
228: 
229: int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row) {
230: 	return GetInternalCValue<int64_t>(result, col, row);
231: }
232: 
233: duckdb_hugeint duckdb_value_hugeint(duckdb_result *result, idx_t col, idx_t row) {
234: 	duckdb_hugeint result_value;
235: 	auto internal_value = GetInternalCValue<hugeint_t>(result, col, row);
236: 	result_value.lower = internal_value.lower;
237: 	result_value.upper = internal_value.upper;
238: 	return result_value;
239: }
240: 
241: uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row) {
242: 	return GetInternalCValue<uint8_t>(result, col, row);
243: }
244: 
245: uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row) {
246: 	return GetInternalCValue<uint16_t>(result, col, row);
247: }
248: 
249: uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row) {
250: 	return GetInternalCValue<uint32_t>(result, col, row);
251: }
252: 
253: uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row) {
254: 	return GetInternalCValue<uint64_t>(result, col, row);
255: }
256: 
257: float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row) {
258: 	return GetInternalCValue<float>(result, col, row);
259: }
260: 
261: double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row) {
262: 	return GetInternalCValue<double>(result, col, row);
263: }
264: 
265: duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row) {
266: 	duckdb_date result_value;
267: 	result_value.days = GetInternalCValue<date_t>(result, col, row).days;
268: 	return result_value;
269: }
270: 
271: duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row) {
272: 	duckdb_time result_value;
273: 	result_value.micros = GetInternalCValue<dtime_t>(result, col, row).micros;
274: 	return result_value;
275: }
276: 
277: duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row) {
278: 	duckdb_timestamp result_value;
279: 	result_value.micros = GetInternalCValue<timestamp_t>(result, col, row).value;
280: 	return result_value;
281: }
282: 
283: duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row) {
284: 	duckdb_interval result_value;
285: 	auto ival = GetInternalCValue<interval_t>(result, col, row);
286: 	result_value.months = ival.months;
287: 	result_value.days = ival.days;
288: 	result_value.micros = ival.micros;
289: 	return result_value;
290: }
291: 
292: char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row) {
293: 	return GetInternalCValue<char *, ToCStringCastWrapper<duckdb::StringCast>>(result, col, row);
294: }
295: 
296: char *duckdb_value_varchar_internal(duckdb_result *result, idx_t col, idx_t row) {
297: 	if (!CanFetchValue(result, col, row)) {
298: 		return nullptr;
299: 	}
300: 	if (duckdb_column_type(result, col) != DUCKDB_TYPE_VARCHAR) {
301: 		return nullptr;
302: 	}
303: 	return UnsafeFetch<char *>(result, col, row);
304: }
305: 
306: duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row) {
307: 	if (CanFetchValue(result, col, row) && result->__deprecated_columns[col].__deprecated_type == DUCKDB_TYPE_BLOB) {
308: 		auto internal_result = UnsafeFetch<duckdb_blob>(result, col, row);
309: 
310: 		duckdb_blob result_blob;
311: 		result_blob.data = malloc(internal_result.size);
312: 		result_blob.size = internal_result.size;
313: 		memcpy(result_blob.data, internal_result.data, internal_result.size);
314: 		return result_blob;
315: 	}
316: 	return FetchDefaultValue::Operation<duckdb_blob>();
317: }
318: 
319: bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row) {
320: 	if (!result || col >= result->__deprecated_column_count || row >= result->__deprecated_row_count) {
321: 		return false;
322: 	}
323: 	return result->__deprecated_columns[col].__deprecated_nullmask[row];
324: }
[end of src/main/capi/value-c.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: