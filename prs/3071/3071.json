{
  "repo": "duckdb/duckdb",
  "pull_number": 3071,
  "instance_id": "duckdb__duckdb-3071",
  "issue_numbers": [
    "2858"
  ],
  "base_commit": "452c18973be5298325ad92156f5901874cde09a8",
  "patch": "diff --git a/src/include/duckdb.h b/src/include/duckdb.h\nindex e07095a33b34..0bf2334c6c47 100644\n--- a/src/include/duckdb.h\n+++ b/src/include/duckdb.h\n@@ -87,7 +87,9 @@ typedef enum DUCKDB_TYPE {\n \t// const char*\n \tDUCKDB_TYPE_VARCHAR,\n \t// duckdb_blob\n-\tDUCKDB_TYPE_BLOB\n+\tDUCKDB_TYPE_BLOB,\n+\t// decimal\n+\tDUCKDB_TYPE_DECIMAL\n } duckdb_type;\n \n //! Days are stored as days since 1970-01-01\n@@ -140,6 +142,13 @@ typedef struct {\n \tint64_t upper;\n } duckdb_hugeint;\n \n+typedef struct {\n+\tuint8_t width;\n+\tuint8_t scale;\n+\n+\tduckdb_hugeint value;\n+} duckdb_decimal;\n+\n typedef struct {\n \tvoid *data;\n \tidx_t size;\n@@ -474,6 +483,11 @@ DUCKDB_API int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t ro\n  */\n DUCKDB_API duckdb_hugeint duckdb_value_hugeint(duckdb_result *result, idx_t col, idx_t row);\n \n+/*!\n+ * returns: The duckdb_decimal value at the specified location, or 0 if the value cannot be converted.\n+ */\n+DUCKDB_API duckdb_decimal duckdb_value_decimal(duckdb_result *result, idx_t col, idx_t row);\n+\n /*!\n  * returns: The uint8_t value at the specified location, or 0 if the value cannot be converted.\n  */\n@@ -640,6 +654,17 @@ If the conversion fails because the double value is too big the result will be 0\n */\n DUCKDB_API duckdb_hugeint duckdb_double_to_hugeint(double val);\n \n+//===--------------------------------------------------------------------===//\n+// Decimal Helpers\n+//===--------------------------------------------------------------------===//\n+/*!\n+Converts a duckdb_decimal object (as obtained from a `DUCKDB_TYPE_DECIMAL` column) into a double.\n+\n+* val: The decimal value.\n+* returns: The converted `double` element.\n+*/\n+DUCKDB_API double duckdb_decimal_to_double(duckdb_decimal val);\n+\n //===--------------------------------------------------------------------===//\n // Prepared Statements\n //===--------------------------------------------------------------------===//\ndiff --git a/src/include/duckdb/main/capi_internal.hpp b/src/include/duckdb/main/capi_internal.hpp\nindex 65810f7b5bd2..a70767b911ea 100644\n--- a/src/include/duckdb/main/capi_internal.hpp\n+++ b/src/include/duckdb/main/capi_internal.hpp\n@@ -10,6 +10,7 @@\n \n #include \"duckdb.h\"\n #include \"duckdb.hpp\"\n+#include \"duckdb/common/types.hpp\"\n #include \"duckdb/common/types/data_chunk.hpp\"\n #include \"duckdb/main/appender.hpp\"\n #include <cstring>\n@@ -46,4 +47,8 @@ duckdb_type ConvertCPPTypeToC(const LogicalType &type);\n idx_t GetCTypeSize(duckdb_type type);\n duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out);\n \n+struct DuckDBColumnData {\n+\tLogicalType type;\n+};\n+\n } // namespace duckdb\ndiff --git a/src/main/capi/helper-c.cpp b/src/main/capi/helper-c.cpp\nindex 09104feed9ed..c754432fb5f1 100644\n--- a/src/main/capi/helper-c.cpp\n+++ b/src/main/capi/helper-c.cpp\n@@ -45,6 +45,8 @@ duckdb_type ConvertCPPTypeToC(const LogicalType &sql_type) {\n \t\treturn DUCKDB_TYPE_BLOB;\n \tcase LogicalTypeId::INTERVAL:\n \t\treturn DUCKDB_TYPE_INTERVAL;\n+\tcase LogicalTypeId::DECIMAL:\n+\t\treturn DUCKDB_TYPE_DECIMAL;\n \tdefault: // LCOV_EXCL_START\n \t\tD_ASSERT(0);\n \t\treturn DUCKDB_TYPE_INVALID;\n@@ -88,6 +90,8 @@ idx_t GetCTypeSize(duckdb_type type) {\n \t\treturn sizeof(duckdb_blob);\n \tcase DUCKDB_TYPE_INTERVAL:\n \t\treturn sizeof(duckdb_interval);\n+\tcase DUCKDB_TYPE_DECIMAL:\n+\t\treturn sizeof(duckdb_hugeint);\n \tdefault: // LCOV_EXCL_START\n \t\t// unsupported type\n \t\tD_ASSERT(0);\ndiff --git a/src/main/capi/hugeint-c.cpp b/src/main/capi/hugeint-c.cpp\nindex cc3baac650d2..fc3d0b249291 100644\n--- a/src/main/capi/hugeint-c.cpp\n+++ b/src/main/capi/hugeint-c.cpp\n@@ -1,5 +1,7 @@\n #include \"duckdb/main/capi_internal.hpp\"\n #include \"duckdb/common/types/hugeint.hpp\"\n+#include \"duckdb/common/types/decimal.hpp\"\n+#include \"duckdb/common/operator/decimal_cast_operators.hpp\"\n \n using duckdb::Hugeint;\n using duckdb::hugeint_t;\n@@ -24,3 +26,12 @@ duckdb_hugeint duckdb_double_to_hugeint(double val) {\n \tresult.upper = internal_result.upper;\n \treturn result;\n }\n+\n+double duckdb_decimal_to_double(duckdb_decimal val) {\n+\tdouble result;\n+\thugeint_t value;\n+\tvalue.lower = val.value.lower;\n+\tvalue.upper = val.value.upper;\n+\tduckdb::TryCastFromDecimal::Operation<hugeint_t, double>(value, result, nullptr, val.width, val.scale);\n+\treturn result;\n+}\ndiff --git a/src/main/capi/result-c.cpp b/src/main/capi/result-c.cpp\nindex 6c07ba558d81..25d31f9d39a7 100644\n--- a/src/main/capi/result-c.cpp\n+++ b/src/main/capi/result-c.cpp\n@@ -53,6 +53,9 @@ duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_res\n \t// zero initialize the columns (so we can cleanly delete it in case a malloc fails)\n \tmemset(out->__deprecated_columns, 0, sizeof(duckdb_column) * out->__deprecated_column_count);\n \tfor (idx_t i = 0; i < out->__deprecated_column_count; i++) {\n+\t\tauto column_data = new DuckDBColumnData();\n+\t\tcolumn_data->type = result->types[i];\n+\t\tout->__deprecated_columns[i].internal_data = column_data;\n \t\tout->__deprecated_columns[i].__deprecated_type = ConvertCPPTypeToC(result->types[i]);\n \t\tout->__deprecated_columns[i].__deprecated_name = strdup(result->names[i].c_str());\n \t\tout->__deprecated_columns[i].__deprecated_nullmask =\n@@ -215,9 +218,72 @@ duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_res\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n+\t\tcase LogicalTypeId::DECIMAL: {\n+\t\t\t// get data\n+\t\t\tidx_t row = 0;\n+\t\t\tauto target = (hugeint_t *)out->__deprecated_columns[col].__deprecated_data;\n+\t\t\tswitch (result->types[col].InternalType()) {\n+\t\t\tcase PhysicalType::INT16: {\n+\t\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n+\t\t\t\t\tauto source = FlatVector::GetData<int16_t>(chunk->data[col]);\n+\t\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\t\t\ttarget[row].lower = source[k];\n+\t\t\t\t\t\t\ttarget[row].upper = 0;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\trow++;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tcase PhysicalType::INT32: {\n+\t\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n+\t\t\t\t\tauto source = FlatVector::GetData<int32_t>(chunk->data[col]);\n+\t\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\t\t\ttarget[row].lower = source[k];\n+\t\t\t\t\t\t\ttarget[row].upper = 0;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\trow++;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tcase PhysicalType::INT64: {\n+\t\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n+\t\t\t\t\tauto source = FlatVector::GetData<int64_t>(chunk->data[col]);\n+\t\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\t\t\ttarget[row].lower = source[k];\n+\t\t\t\t\t\t\ttarget[row].upper = 0;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\trow++;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tcase PhysicalType::INT128: {\n+\t\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n+\t\t\t\t\tauto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);\n+\t\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\t\t\ttarget[row].lower = source[k].lower;\n+\t\t\t\t\t\t\ttarget[row].upper = source[k].upper;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\trow++;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tthrow std::runtime_error(\"Unsupported physical type for Decimal\" +\n+\t\t\t\t                         TypeIdToString(result->types[col].InternalType()));\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n \t\tdefault: // LCOV_EXCL_START\n-\t\t\t// unsupported type for C API\n-\t\t\tD_ASSERT(0);\n+\t\t\tstd::string err_msg = \"Unsupported type for C API: \" + result->types[col].ToString();\n+\t\t\tout->__deprecated_error_message = strdup(err_msg.c_str());\n \t\t\treturn DuckDBError;\n \t\t} // LCOV_EXCL_STOP\n \t}\n@@ -253,6 +319,10 @@ static void DuckdbDestroyColumn(duckdb_column column, idx_t count) {\n \tif (column.__deprecated_name) {\n \t\tduckdb_free(column.__deprecated_name);\n \t}\n+\tif (column.internal_data) {\n+\t\tauto column_data = (duckdb::DuckDBColumnData *)column.internal_data;\n+\t\tdelete column_data;\n+\t}\n }\n \n void duckdb_destroy_result(duckdb_result *result) {\ndiff --git a/src/main/capi/value-c.cpp b/src/main/capi/value-c.cpp\nindex 464de9d6a629..284aaa2b38fa 100644\n--- a/src/main/capi/value-c.cpp\n+++ b/src/main/capi/value-c.cpp\n@@ -142,7 +142,12 @@ using duckdb::UnsafeFetch;\n template <class SOURCE_TYPE, class RESULT_TYPE, class OP>\n RESULT_TYPE TryCastCInternal(duckdb_result *result, idx_t col, idx_t row) {\n \tRESULT_TYPE result_value;\n-\tif (!OP::template Operation<SOURCE_TYPE, RESULT_TYPE>(UnsafeFetch<SOURCE_TYPE>(result, col, row), result_value)) {\n+\ttry {\n+\t\tif (!OP::template Operation<SOURCE_TYPE, RESULT_TYPE>(UnsafeFetch<SOURCE_TYPE>(result, col, row),\n+\t\t                                                      result_value)) {\n+\t\t\treturn FetchDefaultValue::Operation<RESULT_TYPE>();\n+\t\t}\n+\t} catch (...) {\n \t\treturn FetchDefaultValue::Operation<RESULT_TYPE>();\n \t}\n \treturn result_value;\n@@ -194,6 +199,8 @@ static RESULT_TYPE GetInternalCValue(duckdb_result *result, idx_t col, idx_t row\n \t\treturn TryCastCInternal<timestamp_t, RESULT_TYPE, OP>(result, col, row);\n \tcase DUCKDB_TYPE_HUGEINT:\n \t\treturn TryCastCInternal<hugeint_t, RESULT_TYPE, OP>(result, col, row);\n+\tcase DUCKDB_TYPE_DECIMAL:\n+\t\treturn TryCastCInternal<hugeint_t, RESULT_TYPE, OP>(result, col, row);\n \tcase DUCKDB_TYPE_INTERVAL:\n \t\treturn TryCastCInternal<interval_t, RESULT_TYPE, OP>(result, col, row);\n \tcase DUCKDB_TYPE_VARCHAR:\n@@ -230,6 +237,18 @@ int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row) {\n \treturn GetInternalCValue<int64_t>(result, col, row);\n }\n \n+duckdb_decimal duckdb_value_decimal(duckdb_result *result, idx_t col, idx_t row) {\n+\tduckdb_decimal result_value;\n+\n+\tauto column_data = (duckdb::DuckDBColumnData *)result->__deprecated_columns[col].internal_data;\n+\tcolumn_data->type.GetDecimalProperties(result_value.width, result_value.scale);\n+\n+\tauto internal_value = GetInternalCValue<hugeint_t>(result, col, row);\n+\tresult_value.value.lower = internal_value.lower;\n+\tresult_value.value.upper = internal_value.upper;\n+\treturn result_value;\n+}\n+\n duckdb_hugeint duckdb_value_hugeint(duckdb_result *result, idx_t col, idx_t row) {\n \tduckdb_hugeint result_value;\n \tauto internal_value = GetInternalCValue<hugeint_t>(result, col, row);\n@@ -321,4 +340,4 @@ bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row) {\n \t\treturn false;\n \t}\n \treturn result->__deprecated_columns[col].__deprecated_nullmask[row];\n-}\n\\ No newline at end of file\n+}\n",
  "test_patch": "diff --git a/test/api/capi/test_capi.cpp b/test/api/capi/test_capi.cpp\nindex 016961285fe6..49bf7c4b4478 100644\n--- a/test/api/capi/test_capi.cpp\n+++ b/test/api/capi/test_capi.cpp\n@@ -134,6 +134,11 @@ double CAPIResult::Fetch(idx_t col, idx_t row) {\n \treturn duckdb_value_double(&result, col, row);\n }\n \n+template <>\n+duckdb_decimal CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_decimal(&result, col, row);\n+}\n+\n template <>\n duckdb_date CAPIResult::Fetch(idx_t col, idx_t row) {\n \tauto data = (duckdb_date *)duckdb_column_data(&result, col);\n@@ -500,6 +505,25 @@ TEST_CASE(\"Test different types of C API\", \"[capi]\") {\n \tREQUIRE(!result->Fetch<bool>(0, 1));\n \tREQUIRE(result->Fetch<bool>(0, 2));\n \tREQUIRE(result->Fetch<string>(0, 2) == \"true\");\n+\n+\t// decimal columns\n+\tREQUIRE_NO_FAIL(tester.Query(\"CREATE TABLE decimals(dec DECIMAL(18, 4) NULL)\"));\n+\tREQUIRE_NO_FAIL(tester.Query(\"INSERT INTO decimals VALUES (NULL), (12.3)\"));\n+\n+\tresult = tester.Query(\"SELECT * FROM decimals ORDER BY dec\");\n+\tREQUIRE_NO_FAIL(*result);\n+\tREQUIRE(result->IsNull(0, 0));\n+\tduckdb_decimal decimal = result->Fetch<duckdb_decimal>(0, 1);\n+\tREQUIRE(duckdb_decimal_to_double(decimal) == 12.3);\n+\t// test more decimal physical types\n+\tresult = tester.Query(\"SELECT 1.2::DECIMAL(4,1), 100.3::DECIMAL(9,1), 320938.4298::DECIMAL(18,4), \"\n+\t                      \"49082094824.904820482094::DECIMAL(30,12), NULL::DECIMAL\");\n+\tREQUIRE_NO_FAIL(*result);\n+\tREQUIRE(duckdb_decimal_to_double(result->Fetch<duckdb_decimal>(0, 0)) == 1.2);\n+\tREQUIRE(duckdb_decimal_to_double(result->Fetch<duckdb_decimal>(1, 0)) == 100.3);\n+\tREQUIRE(duckdb_decimal_to_double(result->Fetch<duckdb_decimal>(2, 0)) == 320938.4298);\n+\tREQUIRE(duckdb_decimal_to_double(result->Fetch<duckdb_decimal>(3, 0)) == 49082094824.904820482094);\n+\tREQUIRE(result->IsNull(4, 0));\n }\n \n TEST_CASE(\"Test errors in C API\", \"[capi]\") {\n@@ -541,6 +565,22 @@ TEST_CASE(\"Test errors in C API\", \"[capi]\") {\n \t// various edge cases/nullptrs\n \tREQUIRE(duckdb_query_arrow_schema(out_arrow, nullptr) == DuckDBSuccess);\n \tREQUIRE(duckdb_query_arrow_array(out_arrow, nullptr) == DuckDBSuccess);\n+\n+\t// default duckdb_value_date on invalid date\n+\tresult = tester.Query(\"SELECT 1, true, 'a'\");\n+\tREQUIRE_NO_FAIL(*result);\n+\tduckdb_date_struct d = result->Fetch<duckdb_date_struct>(0, 0);\n+\tREQUIRE(d.year == 1970);\n+\tREQUIRE(d.month == 1);\n+\tREQUIRE(d.day == 1);\n+\td = result->Fetch<duckdb_date_struct>(1, 0);\n+\tREQUIRE(d.year == 1970);\n+\tREQUIRE(d.month == 1);\n+\tREQUIRE(d.day == 1);\n+\td = result->Fetch<duckdb_date_struct>(2, 0);\n+\tREQUIRE(d.year == 1970);\n+\tREQUIRE(d.month == 1);\n+\tREQUIRE(d.day == 1);\n }\n \n TEST_CASE(\"Test prepared statements in C API\", \"[capi]\") {\n",
  "problem_statement": "DuckDB C interface and decimal support\n#### What happens?\r\nWhen querying a table with the `decimal` column, the query fails with `DuckDBError` but without any error message.\r\n\r\n#### To Reproduce\r\nUsing the C Api run the following statements:\r\n\r\n```c\r\nCREATE TABLE test (dec DECIMAL(18, 4) NULL, value FLOAT NULL);\r\n\r\nINSERT INTO test (dec, value) SELECT NULL, 10\r\n\r\nSELECT * FROM test\r\n```\r\n\r\nThe last `duckdb_query` returns `DuckDBError` without any error message. The column type for the first column is `DUCKDB_TYPE_INVALID`\r\n\r\n#### Environment\r\n - OS: Windows 10\r\n - DuckDB Version: 0.3.1\r\n - DuckDB Client: C Api\r\n\n",
  "hints_text": "@Mytherin I'd like to work on this issue\nI believe the \"NUMERIC\" column type (not documented) is also a DECIMAL type?\r\nGot a similar error with the C Api and a NUMERIC column.\n`NUMERIC` is an alias for `DECIMAL(18,3)`, indeed.\nWould casting to double be an temp workaround? ",
  "created_at": "2022-02-11T16:36:21Z"
}