diff --git a/src/include/duckdb.h b/src/include/duckdb.h
index be5ca9d46930..be1aa93a1e3f 100644
--- a/src/include/duckdb.h
+++ b/src/include/duckdb.h
@@ -132,9 +132,28 @@ typedef void *duckdb_database;
 typedef void *duckdb_connection;
 typedef void *duckdb_prepared_statement;
 typedef void *duckdb_appender;
+typedef void *duckdb_arrow;
+// we don't need to spell out the schema/array in here
+// because it's a common interface, users can consume
+// the data in their own logic.
+typedef void *duckdb_arrow_schema;
+typedef void *duckdb_arrow_array;
 
 typedef enum { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;
 
+//! query duckdb result as arrow data structure
+DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);
+//! get arrow schema
+DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);
+//! get arrow data array
+//! This function can be called multiple time to get next chunks, which will free the previous out_array.
+//! So consume the out_array before call this function again
+DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);
+//! get arrow error message
+DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);
+//! Destroys the arrow result
+DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
+
 //! Opens a database file at the given path (nullptr for in-memory). Returns DuckDBSuccess on success, or DuckDBError on
 //! failure. [OUT: database]
 DUCKDB_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);
@@ -200,6 +219,7 @@ DUCKDB_API void duckdb_free(void *ptr);
 DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
                                        duckdb_prepared_statement *out_prepared_statement);
 
+DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);
 DUCKDB_API duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out);
 
 //! binds parameters to prepared statement
@@ -226,6 +246,10 @@ DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_stat
 DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,
                                                 duckdb_result *out_result);
 
+//! Executes the prepared statements with currently bound parameters and return arrow result
+DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,
+                                                      duckdb_arrow *out_result);
+
 //! Destroys the specified prepared statement descriptor
 DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);
 
diff --git a/src/main/duckdb-c.cpp b/src/main/duckdb-c.cpp
index 1d5acb631a0c..186a9516c9e0 100644
--- a/src/main/duckdb-c.cpp
+++ b/src/main/duckdb-c.cpp
@@ -1,6 +1,7 @@
 #include "duckdb/common/types/date.hpp"
 #include "duckdb/common/types/time.hpp"
 #include "duckdb/common/types/timestamp.hpp"
+#include "duckdb/common/arrow.hpp"
 #include "duckdb/common/vector_operations/vector_operations.hpp"
 #include "duckdb/main/appender.hpp"
 
@@ -328,6 +329,63 @@ duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckd
 	return duckdb_translate_result(result.get(), out);
 }
 
+namespace duckdb {
+struct ArrowResultWrapper {
+	ArrowResultWrapper() : result(nullptr), current_chunk(nullptr) {
+	}
+	~ArrowResultWrapper() {
+	}
+	unique_ptr<MaterializedQueryResult> result;
+	unique_ptr<DataChunk> current_chunk;
+};
+} // namespace duckdb
+
+duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result) {
+	Connection *conn = (Connection *)connection;
+	auto wrapper = new ArrowResultWrapper();
+	wrapper->result = conn->Query(query);
+	*out_result = (duckdb_arrow)wrapper;
+	return wrapper->result->success ? DuckDBSuccess : DuckDBError;
+}
+
+duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema) {
+	if (!out_schema) {
+		return DuckDBSuccess;
+	}
+	auto wrapper = (ArrowResultWrapper *)result;
+	wrapper->result->ToArrowSchema((ArrowSchema *)*out_schema);
+	return DuckDBSuccess;
+}
+
+duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array) {
+	if (!out_array) {
+		return DuckDBSuccess;
+	}
+	auto wrapper = (ArrowResultWrapper *)result;
+	auto success = wrapper->result->TryFetch(wrapper->current_chunk, wrapper->result->error);
+	if (!success) {
+		return DuckDBError;
+	}
+	if (!wrapper->current_chunk || wrapper->current_chunk->size() == 0) {
+		return DuckDBSuccess;
+	}
+	wrapper->current_chunk->ToArrowArray((ArrowArray *)*out_array);
+	return DuckDBSuccess;
+}
+
+const char *duckdb_query_arrow_error(duckdb_arrow result) {
+	auto wrapper = (ArrowResultWrapper *)result;
+	return wrapper->result->error.c_str();
+}
+
+void duckdb_destroy_arrow(duckdb_arrow *result) {
+	if (*result) {
+		auto wrapper = (ArrowResultWrapper *)*result;
+		delete wrapper;
+		*result = nullptr;
+	}
+}
+
 static void duckdb_destroy_column(duckdb_column column, idx_t count) {
 	if (column.data) {
 		if (column.type == DUCKDB_TYPE_VARCHAR) {
@@ -391,6 +449,14 @@ duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
 	return wrapper->statement->success ? DuckDBSuccess : DuckDBError;
 }
 
+const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement) {
+	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
+	if (!wrapper || !wrapper->statement || wrapper->statement->success) {
+		return nullptr;
+	}
+	return wrapper->statement->error.c_str();
+}
+
 duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out) {
 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
@@ -488,6 +554,20 @@ duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statemen
 	return duckdb_translate_result(mat_res, out_result);
 }
 
+duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement, duckdb_arrow *out_result) {
+	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
+	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
+		return DuckDBError;
+	}
+	auto arrow_wrapper = new ArrowResultWrapper();
+	auto result = wrapper->statement->Execute(wrapper->values, false);
+	D_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);
+	arrow_wrapper->result =
+	    unique_ptr<MaterializedQueryResult>(static_cast<MaterializedQueryResult *>(result.release()));
+	*out_result = (duckdb_arrow)arrow_wrapper;
+	return arrow_wrapper->result->success ? DuckDBSuccess : DuckDBError;
+}
+
 void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement) {
 	if (!prepared_statement) {
 		return;
