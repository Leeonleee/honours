diff --git a/test/api/capi/test_capi.cpp b/test/api/capi/test_capi.cpp
index 33173616caa9..75d7ef0f920f 100644
--- a/test/api/capi/test_capi.cpp
+++ b/test/api/capi/test_capi.cpp
@@ -1,6 +1,7 @@
 #include "catch.hpp"
 #include "duckdb.h"
 #include "test_helpers.hpp"
+#include "duckdb/common/arrow.hpp"
 #include "duckdb/common/exception.hpp"
 
 using namespace duckdb;
@@ -395,9 +396,22 @@ TEST_CASE("Test errors in C API", "[capi]") {
 	// fail prepare API calls
 	REQUIRE(duckdb_prepare(NULL, "SELECT 42", &stmt) == DuckDBError);
 	REQUIRE(duckdb_prepare(tester.connection, NULL, &stmt) == DuckDBError);
+	REQUIRE(stmt == nullptr);
+
+	REQUIRE(duckdb_prepare(tester.connection, "SELECT * from INVALID_TABLE", &stmt) == DuckDBError);
+	REQUIRE(stmt != nullptr);
+	REQUIRE(duckdb_prepare_error(stmt) != nullptr);
+	duckdb_destroy_prepare(&stmt);
+
 	REQUIRE(duckdb_bind_boolean(NULL, 0, true) == DuckDBError);
 	REQUIRE(duckdb_execute_prepared(NULL, &res) == DuckDBError);
 	duckdb_destroy_prepare(NULL);
+
+	// fail to query arrow
+	duckdb_arrow out_arrow;
+	REQUIRE(duckdb_query_arrow(tester.connection, "SELECT * from INVALID_TABLE", &out_arrow) == DuckDBError);
+	REQUIRE(duckdb_query_arrow_error(out_arrow) != nullptr);
+	duckdb_destroy_arrow(&out_arrow);
 }
 
 TEST_CASE("Test prepared statements in C API", "[capi][.]") {
@@ -645,3 +659,101 @@ TEST_CASE("Test appender statements in C API", "[capi][.]") {
 	status = duckdb_appender_destroy(nullptr);
 	REQUIRE(status == DuckDBError);
 }
+
+TEST_CASE("Test arrow in C API", "[capi]") {
+	CAPITester tester;
+	unique_ptr<CAPIResult> result;
+	duckdb_prepared_statement stmt = nullptr;
+	duckdb_arrow arrow_result;
+
+	// open the database in in-memory mode
+	REQUIRE(tester.OpenDatabase(nullptr));
+
+	// test query arrow
+	{
+		REQUIRE(duckdb_query_arrow(tester.connection, "SELECT 42 AS VALUE", &arrow_result) == DuckDBSuccess);
+
+		// query schema
+		ArrowSchema *arrow_schema = new ArrowSchema();
+		REQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);
+		REQUIRE(string(arrow_schema->name) == "duckdb_query_result");
+		// User need to release the data themselves
+		arrow_schema->release(arrow_schema);
+		delete arrow_schema;
+
+		// query array data
+		ArrowArray *arrow_array = new ArrowArray();
+		REQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);
+		REQUIRE(arrow_array->length == 1);
+		arrow_array->release(arrow_array);
+		delete arrow_array;
+
+		duckdb_arrow_array null_array = nullptr;
+		REQUIRE(duckdb_query_arrow_array(arrow_result, &null_array) == DuckDBSuccess);
+		REQUIRE(null_array == nullptr);
+
+		// destroy result
+		duckdb_destroy_arrow(&arrow_result);
+	}
+
+	// test multiple chunks
+	{
+		// create table that consists of multiple chunks
+		REQUIRE_NO_FAIL(tester.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(tester.Query("CREATE TABLE test(a INTEGER)"));
+		for (size_t i = 0; i < 500; i++) {
+			REQUIRE_NO_FAIL(
+			    tester.Query("INSERT INTO test VALUES (1); INSERT INTO test VALUES (2); INSERT INTO test VALUES "
+			                 "(3); INSERT INTO test VALUES (4); INSERT INTO test VALUES (5);"));
+		}
+		REQUIRE_NO_FAIL(tester.Query("COMMIT"));
+
+		REQUIRE(duckdb_query_arrow(tester.connection, "SELECT CAST(a AS INTEGER) AS a FROM test ORDER BY a",
+		                           &arrow_result) == DuckDBSuccess);
+
+		ArrowSchema *arrow_schema = new ArrowSchema();
+		REQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);
+		REQUIRE(arrow_schema->release != nullptr);
+		arrow_schema->release(arrow_schema);
+		delete arrow_schema;
+
+		int total_count = 0;
+		while (true) {
+			ArrowArray *arrow_array = new ArrowArray();
+			REQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);
+			if (arrow_array->length == 0) {
+				delete arrow_array;
+				REQUIRE(total_count == 2500);
+				break;
+			}
+			REQUIRE(arrow_array->length > 0);
+			total_count += arrow_array->length;
+			arrow_array->release(arrow_array);
+			delete arrow_array;
+		}
+		duckdb_destroy_arrow(&arrow_result);
+	}
+
+	// test prepare query arrow
+	{
+		REQUIRE(duckdb_prepare(tester.connection, "SELECT CAST($1 AS BIGINT)", &stmt) == DuckDBSuccess);
+		REQUIRE(stmt != nullptr);
+		REQUIRE(duckdb_bind_int64(stmt, 1, 42) == DuckDBSuccess);
+		REQUIRE(duckdb_execute_prepared_arrow(stmt, &arrow_result) == DuckDBSuccess);
+
+		ArrowSchema *arrow_schema = new ArrowSchema();
+		REQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);
+		REQUIRE(string(arrow_schema->format) == "+s");
+		arrow_schema->release(arrow_schema);
+		delete arrow_schema;
+
+		ArrowArray *arrow_array = new ArrowArray();
+		REQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);
+		REQUIRE(arrow_array->length == 1);
+		arrow_array->release(arrow_array);
+		delete arrow_array;
+
+		duckdb_destroy_arrow(&arrow_result);
+		duckdb_destroy_prepare(&stmt);
+	}
+}
