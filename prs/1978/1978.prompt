You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Define duckdb_prepared_statement as struct so we can add error_message into it
Currently we don't the reason if duckdb_prepare failed

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![codecov](https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN)](https://codecov.io/gh/duckdb/duckdb)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/include/duckdb.h]
1: //===----------------------------------------------------------------------===//
2: //
3: //                         DuckDB
4: //
5: // duckdb.h
6: //
7: // Author: Mark Raasveldt
8: //
9: //===----------------------------------------------------------------------===//
10: 
11: #pragma once
12: 
13: #ifdef _WIN32
14: #ifdef DUCKDB_BUILD_LIBRARY
15: #define DUCKDB_API __declspec(dllexport)
16: #else
17: #define DUCKDB_API __declspec(dllimport)
18: #endif
19: #else
20: #define DUCKDB_API
21: #endif
22: 
23: #include <stdbool.h>
24: #include <stdint.h>
25: #include <stdlib.h>
26: 
27: #ifdef __cplusplus
28: extern "C" {
29: #endif
30: 
31: typedef uint64_t idx_t;
32: 
33: typedef enum DUCKDB_TYPE {
34: 	DUCKDB_TYPE_INVALID = 0,
35: 	// bool
36: 	DUCKDB_TYPE_BOOLEAN,
37: 	// int8_t
38: 	DUCKDB_TYPE_TINYINT,
39: 	// int16_t
40: 	DUCKDB_TYPE_SMALLINT,
41: 	// int32_t
42: 	DUCKDB_TYPE_INTEGER,
43: 	// int64_t
44: 	DUCKDB_TYPE_BIGINT,
45: 	// float
46: 	DUCKDB_TYPE_FLOAT,
47: 	// double
48: 	DUCKDB_TYPE_DOUBLE,
49: 	// duckdb_timestamp (us)
50: 	DUCKDB_TYPE_TIMESTAMP,
51: 	// duckdb_timestamp (s)
52: 	DUCKDB_TYPE_TIMESTAMP_S,
53: 	// duckdb_timestamp (ns)
54: 	DUCKDB_TYPE_TIMESTAMP_NS,
55: 	// duckdb_timestamp (ms)
56: 	DUCKDB_TYPE_TIMESTAMP_MS,
57: 	// duckdb_date
58: 	DUCKDB_TYPE_DATE,
59: 	// duckdb_time
60: 	DUCKDB_TYPE_TIME,
61: 	// duckdb_interval
62: 	DUCKDB_TYPE_INTERVAL,
63: 	// duckdb_hugeint
64: 	DUCKDB_TYPE_HUGEINT,
65: 	// const char*
66: 	DUCKDB_TYPE_VARCHAR,
67: 	// duckdb_blob
68: 	DUCKDB_TYPE_BLOB
69: } duckdb_type;
70: 
71: typedef struct {
72: 	int32_t year;
73: 	int8_t month;
74: 	int8_t day;
75: } duckdb_date;
76: 
77: typedef struct {
78: 	int8_t hour;
79: 	int8_t min;
80: 	int8_t sec;
81: 	int16_t micros;
82: } duckdb_time;
83: 
84: typedef struct {
85: 	duckdb_date date;
86: 	duckdb_time time;
87: } duckdb_timestamp;
88: 
89: typedef struct {
90: 	int32_t months;
91: 	int32_t days;
92: 	int64_t micros;
93: } duckdb_interval;
94: 
95: typedef struct {
96: 	uint64_t lower;
97: 	int64_t upper;
98: } duckdb_hugeint;
99: 
100: typedef struct {
101: 	void *data;
102: 	idx_t size;
103: } duckdb_blob;
104: 
105: typedef struct {
106: 	void *data;
107: 	bool *nullmask;
108: 	duckdb_type type;
109: 	char *name;
110: } duckdb_column;
111: 
112: typedef struct {
113: 	idx_t column_count;
114: 	idx_t row_count;
115: 	idx_t rows_changed;
116: 	duckdb_column *columns;
117: 	char *error_message;
118: } duckdb_result;
119: 
120: // typedef struct {
121: // 	void *data;
122: // 	bool *nullmask;
123: // } duckdb_column_data;
124: 
125: // typedef struct {
126: // 	int column_count;
127: // 	int count;
128: // 	duckdb_column_data *columns;
129: // } duckdb_chunk;
130: 
131: typedef void *duckdb_database;
132: typedef void *duckdb_connection;
133: typedef void *duckdb_prepared_statement;
134: typedef void *duckdb_appender;
135: 
136: typedef enum { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;
137: 
138: //! Opens a database file at the given path (nullptr for in-memory). Returns DuckDBSuccess on success, or DuckDBError on
139: //! failure. [OUT: database]
140: DUCKDB_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);
141: //! Closes the database.
142: DUCKDB_API void duckdb_close(duckdb_database *database);
143: 
144: //! Creates a connection to the specified database. [OUT: connection]
145: DUCKDB_API duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out_connection);
146: //! Closes the specified connection handle
147: DUCKDB_API void duckdb_disconnect(duckdb_connection *connection);
148: 
149: //! Executes the specified SQL query in the specified connection handle. [OUT: result descriptor]
150: DUCKDB_API duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out_result);
151: //! Destroys the specified result
152: DUCKDB_API void duckdb_destroy_result(duckdb_result *result);
153: 
154: //! Returns the column name of the specified column. The result does not need to be freed;
155: //! the column names will automatically be destroyed when the result is destroyed.
156: DUCKDB_API const char *duckdb_column_name(duckdb_result *result, idx_t col);
157: 
158: // SAFE fetch functions
159: // These functions will perform conversions if necessary. On failure (e.g. if conversion cannot be performed) a special
160: // value is returned.
161: 
162: //! Converts the specified value to a bool. Returns false on failure or NULL.
163: DUCKDB_API bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row);
164: //! Converts the specified value to an int8_t. Returns 0 on failure or NULL.
165: DUCKDB_API int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row);
166: //! Converts the specified value to an int16_t. Returns 0 on failure or NULL.
167: DUCKDB_API int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row);
168: //! Converts the specified value to an int64_t. Returns 0 on failure or NULL.
169: DUCKDB_API int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row);
170: //! Converts the specified value to an int64_t. Returns 0 on failure or NULL.
171: DUCKDB_API int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row);
172: //! Converts the specified value to an uint8_t. Returns 0 on failure or NULL.
173: DUCKDB_API uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row);
174: //! Converts the specified value to an uint16_t. Returns 0 on failure or NULL.
175: DUCKDB_API uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row);
176: //! Converts the specified value to an uint64_t. Returns 0 on failure or NULL.
177: DUCKDB_API uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row);
178: //! Converts the specified value to an uint64_t. Returns 0 on failure or NULL.
179: DUCKDB_API uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row);
180: //! Converts the specified value to a float. Returns 0.0 on failure or NULL.
181: DUCKDB_API float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row);
182: //! Converts the specified value to a double. Returns 0.0 on failure or NULL.
183: DUCKDB_API double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row);
184: //! Converts the specified value to a string. Returns nullptr on failure or NULL. The result must be freed with
185: //! duckdb_free.
186: DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);
187: //! Fetches a blob from a result set column. Returns a blob with blob.data set to nullptr on failure or NULL. The
188: //! resulting "blob.data" must be freed with duckdb_free.
189: DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);
190: 
191: //! Allocate [size] amounts of memory using the duckdb internal malloc function. Any memory allocated in this manner
192: //! should be freed using duckdb_free
193: DUCKDB_API void *duckdb_malloc(size_t size);
194: //! Free a value returned from duckdb_malloc, duckdb_value_varchar or duckdb_value_blob
195: DUCKDB_API void duckdb_free(void *ptr);
196: 
197: // Prepared Statements
198: 
199: //! prepares the specified SQL query in the specified connection handle. [OUT: prepared statement descriptor]
200: DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
201:                                        duckdb_prepared_statement *out_prepared_statement);
202: 
203: DUCKDB_API duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out);
204: 
205: //! binds parameters to prepared statement
206: DUCKDB_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);
207: DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
208: DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
209: DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);
210: DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);
211: DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
212: DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
213: DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);
214: DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);
215: DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);
216: DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);
217: DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,
218:                                             const char *val);
219: DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,
220:                                                    const char *val, idx_t length);
221: DUCKDB_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,
222:                                          const void *data, idx_t length);
223: DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);
224: 
225: //! Executes the prepared statements with currently bound parameters
226: DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,
227:                                                 duckdb_result *out_result);
228: 
229: //! Destroys the specified prepared statement descriptor
230: DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);
231: 
232: DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
233:                                                duckdb_appender *out_appender);
234: 
235: DUCKDB_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);
236: DUCKDB_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);
237: 
238: DUCKDB_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);
239: 
240: DUCKDB_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);
241: DUCKDB_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);
242: DUCKDB_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);
243: DUCKDB_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);
244: 
245: DUCKDB_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);
246: DUCKDB_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);
247: DUCKDB_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);
248: DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);
249: 
250: DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);
251: DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);
252: 
253: DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);
254: DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);
255: DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);
256: DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);
257: 
258: DUCKDB_API duckdb_state duckdb_appender_flush(duckdb_appender appender);
259: DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);
260: 
261: DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);
262: 
263: #ifdef __cplusplus
264: }
265: #endif
[end of src/include/duckdb.h]
[start of src/main/duckdb-c.cpp]
1: #include "duckdb/common/types/date.hpp"
2: #include "duckdb/common/types/time.hpp"
3: #include "duckdb/common/types/timestamp.hpp"
4: #include "duckdb/common/vector_operations/vector_operations.hpp"
5: #include "duckdb/main/appender.hpp"
6: 
7: #include "duckdb.h"
8: #include "duckdb.hpp"
9: 
10: #include <cstring>
11: #include <cassert>
12: 
13: #ifdef _WIN32
14: #define strdup _strdup
15: #endif
16: 
17: #ifdef GetCValue
18: #undef GetCValue
19: #endif
20: 
21: using namespace duckdb;
22: 
23: static duckdb_type ConvertCPPTypeToC(LogicalType type);
24: static idx_t GetCTypeSize(duckdb_type type);
25: namespace duckdb {
26: struct DatabaseData {
27: 	DatabaseData() : database(nullptr) {
28: 	}
29: 	~DatabaseData() {
30: 		if (database) {
31: 			delete database;
32: 		}
33: 	}
34: 
35: 	DuckDB *database;
36: };
37: } // namespace duckdb
38: duckdb_state duckdb_open(const char *path, duckdb_database *out) {
39: 	auto wrapper = new DatabaseData();
40: 	try {
41: 		wrapper->database = new DuckDB(path);
42: 	} catch (...) {
43: 		delete wrapper;
44: 		return DuckDBError;
45: 	}
46: 	*out = (duckdb_database)wrapper;
47: 	return DuckDBSuccess;
48: }
49: 
50: void duckdb_close(duckdb_database *database) {
51: 	if (*database) {
52: 		auto wrapper = (DatabaseData *)*database;
53: 		delete wrapper;
54: 		*database = nullptr;
55: 	}
56: }
57: 
58: duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out) {
59: 	auto wrapper = (DatabaseData *)database;
60: 	Connection *connection;
61: 	try {
62: 		connection = new Connection(*wrapper->database);
63: 	} catch (...) {
64: 		return DuckDBError;
65: 	}
66: 	*out = (duckdb_connection)connection;
67: 	return DuckDBSuccess;
68: }
69: 
70: void duckdb_disconnect(duckdb_connection *connection) {
71: 	if (*connection) {
72: 		Connection *conn = (Connection *)*connection;
73: 		delete conn;
74: 		*connection = nullptr;
75: 	}
76: }
77: 
78: template <class T>
79: void WriteData(duckdb_result *out, ChunkCollection &source, idx_t col) {
80: 	idx_t row = 0;
81: 	auto target = (T *)out->columns[col].data;
82: 	for (auto &chunk : source.Chunks()) {
83: 		auto source = FlatVector::GetData<T>(chunk->data[col]);
84: 		auto &mask = FlatVector::Validity(chunk->data[col]);
85: 
86: 		for (idx_t k = 0; k < chunk->size(); k++, row++) {
87: 			if (!mask.RowIsValid(k)) {
88: 				continue;
89: 			}
90: 			target[row] = source[k];
91: 		}
92: 	}
93: }
94: 
95: static duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out) {
96: 	D_ASSERT(result);
97: 	if (!out) {
98: 		// no result to write to, only return the status
99: 		return result->success ? DuckDBSuccess : DuckDBError;
100: 	}
101: 	out->error_message = nullptr;
102: 	if (!result->success) {
103: 		// write the error message
104: 		out->error_message = strdup(result->error.c_str());
105: 		return DuckDBError;
106: 	}
107: 	// copy the data
108: 	// first write the meta data
109: 	out->column_count = result->types.size();
110: 	out->row_count = result->collection.Count();
111: 	out->rows_changed = 0;
112: 	if (out->row_count > 0 && StatementTypeReturnChanges(result->statement_type)) {
113: 		// update total changes
114: 		auto row_changes = result->GetValue(0, 0);
115: 		if (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {
116: 			out->rows_changed = row_changes.GetValue<int64_t>();
117: 		}
118: 	}
119: 	out->columns = (duckdb_column *)malloc(sizeof(duckdb_column) * out->column_count);
120: 	if (!out->columns) {
121: 		return DuckDBError;
122: 	}
123: 	// zero initialize the columns (so we can cleanly delete it in case a malloc fails)
124: 	memset(out->columns, 0, sizeof(duckdb_column) * out->column_count);
125: 	for (idx_t i = 0; i < out->column_count; i++) {
126: 		out->columns[i].type = ConvertCPPTypeToC(result->types[i]);
127: 		out->columns[i].name = strdup(result->names[i].c_str());
128: 		out->columns[i].nullmask = (bool *)malloc(sizeof(bool) * out->row_count);
129: 		out->columns[i].data = malloc(GetCTypeSize(out->columns[i].type) * out->row_count);
130: 		if (!out->columns[i].nullmask || !out->columns[i].name || !out->columns[i].data) {
131: 			// malloc failure
132: 			return DuckDBError;
133: 		}
134: 		// memset data to 0 for VARCHAR columns for safe deletion later
135: 		if (result->types[i].InternalType() == PhysicalType::VARCHAR) {
136: 			memset(out->columns[i].data, 0, GetCTypeSize(out->columns[i].type) * out->row_count);
137: 		}
138: 	}
139: 	// now write the data
140: 	for (idx_t col = 0; col < out->column_count; col++) {
141: 		// first set the nullmask
142: 		idx_t row = 0;
143: 		for (auto &chunk : result->collection.Chunks()) {
144: 			for (idx_t k = 0; k < chunk->size(); k++) {
145: 				out->columns[col].nullmask[row++] = FlatVector::IsNull(chunk->data[col], k);
146: 			}
147: 		}
148: 		// then write the data
149: 		switch (result->types[col].id()) {
150: 		case LogicalTypeId::BOOLEAN:
151: 			WriteData<bool>(out, result->collection, col);
152: 			break;
153: 		case LogicalTypeId::TINYINT:
154: 			WriteData<int8_t>(out, result->collection, col);
155: 			break;
156: 		case LogicalTypeId::SMALLINT:
157: 			WriteData<int16_t>(out, result->collection, col);
158: 			break;
159: 		case LogicalTypeId::INTEGER:
160: 			WriteData<int32_t>(out, result->collection, col);
161: 			break;
162: 		case LogicalTypeId::BIGINT:
163: 			WriteData<int64_t>(out, result->collection, col);
164: 			break;
165: 		case LogicalTypeId::FLOAT:
166: 			WriteData<float>(out, result->collection, col);
167: 			break;
168: 		case LogicalTypeId::DOUBLE:
169: 			WriteData<double>(out, result->collection, col);
170: 			break;
171: 		case LogicalTypeId::VARCHAR: {
172: 			idx_t row = 0;
173: 			auto target = (const char **)out->columns[col].data;
174: 			for (auto &chunk : result->collection.Chunks()) {
175: 				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
176: 				for (idx_t k = 0; k < chunk->size(); k++) {
177: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
178: 						target[row] = (char *)malloc(source[k].GetSize() + 1);
179: 						assert(target[row]);
180: 						memcpy((void *)target[row], source[k].GetDataUnsafe(), source[k].GetSize());
181: 						auto write_arr = (char *)target[row];
182: 						write_arr[source[k].GetSize()] = '\0';
183: 					}
184: 					row++;
185: 				}
186: 			}
187: 			break;
188: 		}
189: 		case LogicalTypeId::BLOB: {
190: 			idx_t row = 0;
191: 			auto target = (duckdb_blob *)out->columns[col].data;
192: 			for (auto &chunk : result->collection.Chunks()) {
193: 				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
194: 				for (idx_t k = 0; k < chunk->size(); k++) {
195: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
196: 						target[row].data = (char *)malloc(source[k].GetSize());
197: 						target[row].size = source[k].GetSize();
198: 						assert(target[row].data);
199: 						memcpy((void *)target[row].data, source[k].GetDataUnsafe(), source[k].GetSize());
200: 					}
201: 					row++;
202: 				}
203: 			}
204: 			break;
205: 		}
206: 		case LogicalTypeId::DATE: {
207: 			idx_t row = 0;
208: 			auto target = (duckdb_date *)out->columns[col].data;
209: 			for (auto &chunk : result->collection.Chunks()) {
210: 				auto source = FlatVector::GetData<date_t>(chunk->data[col]);
211: 				for (idx_t k = 0; k < chunk->size(); k++) {
212: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
213: 						int32_t year, month, day;
214: 						Date::Convert(source[k], year, month, day);
215: 						target[row].year = year;
216: 						target[row].month = month;
217: 						target[row].day = day;
218: 					}
219: 					row++;
220: 				}
221: 			}
222: 			break;
223: 		}
224: 		case LogicalTypeId::TIME: {
225: 			idx_t row = 0;
226: 			auto target = (duckdb_time *)out->columns[col].data;
227: 			for (auto &chunk : result->collection.Chunks()) {
228: 				auto source = FlatVector::GetData<dtime_t>(chunk->data[col]);
229: 				for (idx_t k = 0; k < chunk->size(); k++) {
230: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
231: 						int32_t hour, min, sec, micros;
232: 						Time::Convert(source[k], hour, min, sec, micros);
233: 						target[row].hour = hour;
234: 						target[row].min = min;
235: 						target[row].sec = sec;
236: 						target[row].micros = micros;
237: 					}
238: 					row++;
239: 				}
240: 			}
241: 			break;
242: 		}
243: 		case LogicalTypeId::TIMESTAMP:
244: 		case LogicalTypeId::TIMESTAMP_NS:
245: 		case LogicalTypeId::TIMESTAMP_MS:
246: 		case LogicalTypeId::TIMESTAMP_SEC: {
247: 			idx_t row = 0;
248: 			auto target = (duckdb_timestamp *)out->columns[col].data;
249: 			for (auto &chunk : result->collection.Chunks()) {
250: 				auto source = FlatVector::GetData<timestamp_t>(chunk->data[col]);
251: 
252: 				for (idx_t k = 0; k < chunk->size(); k++) {
253: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
254: 						date_t date;
255: 						dtime_t time;
256: 						auto source_value = source[k];
257: 						if (result->types[col].id() == LogicalTypeId::TIMESTAMP_NS) {
258: 							source_value = Timestamp::FromEpochNanoSeconds(source[k].value);
259: 						} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_MS) {
260: 							source_value = Timestamp::FromEpochMs(source[k].value);
261: 						} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_SEC) {
262: 							source_value = Timestamp::FromEpochSeconds(source[k].value);
263: 						}
264: 						Timestamp::Convert(source_value, date, time);
265: 
266: 						int32_t year, month, day;
267: 						Date::Convert(date, year, month, day);
268: 
269: 						int32_t hour, min, sec, micros;
270: 						Time::Convert(time, hour, min, sec, micros);
271: 
272: 						target[row].date.year = year;
273: 						target[row].date.month = month;
274: 						target[row].date.day = day;
275: 						target[row].time.hour = hour;
276: 						target[row].time.min = min;
277: 						target[row].time.sec = sec;
278: 						target[row].time.micros = micros;
279: 					}
280: 					row++;
281: 				}
282: 			}
283: 			break;
284: 		}
285: 		case LogicalTypeId::HUGEINT: {
286: 			idx_t row = 0;
287: 			auto target = (duckdb_hugeint *)out->columns[col].data;
288: 			for (auto &chunk : result->collection.Chunks()) {
289: 				auto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);
290: 				for (idx_t k = 0; k < chunk->size(); k++) {
291: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
292: 						target[row].lower = source[k].lower;
293: 						target[row].upper = source[k].upper;
294: 					}
295: 					row++;
296: 				}
297: 			}
298: 			break;
299: 		}
300: 		case LogicalTypeId::INTERVAL: {
301: 			idx_t row = 0;
302: 			auto target = (duckdb_interval *)out->columns[col].data;
303: 			for (auto &chunk : result->collection.Chunks()) {
304: 				auto source = FlatVector::GetData<interval_t>(chunk->data[col]);
305: 				for (idx_t k = 0; k < chunk->size(); k++) {
306: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
307: 						target[row].days = source[k].days;
308: 						target[row].months = source[k].months;
309: 						target[row].micros = source[k].micros;
310: 					}
311: 					row++;
312: 				}
313: 			}
314: 			break;
315: 		}
316: 		default:
317: 			// unsupported type for C API
318: 			D_ASSERT(0);
319: 			return DuckDBError;
320: 		}
321: 	}
322: 	return DuckDBSuccess;
323: }
324: 
325: duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out) {
326: 	Connection *conn = (Connection *)connection;
327: 	auto result = conn->Query(query);
328: 	return duckdb_translate_result(result.get(), out);
329: }
330: 
331: static void duckdb_destroy_column(duckdb_column column, idx_t count) {
332: 	if (column.data) {
333: 		if (column.type == DUCKDB_TYPE_VARCHAR) {
334: 			// varchar, delete individual strings
335: 			auto data = (char **)column.data;
336: 			for (idx_t i = 0; i < count; i++) {
337: 				if (data[i]) {
338: 					free(data[i]);
339: 				}
340: 			}
341: 		} else if (column.type == DUCKDB_TYPE_BLOB) {
342: 			// blob, delete individual blobs
343: 			auto data = (duckdb_blob *)column.data;
344: 			for (idx_t i = 0; i < count; i++) {
345: 				if (data[i].data) {
346: 					free((void *)data[i].data);
347: 				}
348: 			}
349: 		}
350: 		free(column.data);
351: 	}
352: 	if (column.nullmask) {
353: 		free(column.nullmask);
354: 	}
355: 	if (column.name) {
356: 		free(column.name);
357: 	}
358: }
359: 
360: void duckdb_destroy_result(duckdb_result *result) {
361: 	if (result->error_message) {
362: 		free(result->error_message);
363: 	}
364: 	if (result->columns) {
365: 		for (idx_t i = 0; i < result->column_count; i++) {
366: 			duckdb_destroy_column(result->columns[i], result->row_count);
367: 		}
368: 		free(result->columns);
369: 	}
370: 	memset(result, 0, sizeof(duckdb_result));
371: }
372: namespace duckdb {
373: struct PreparedStatementWrapper {
374: 	PreparedStatementWrapper() : statement(nullptr) {
375: 	}
376: 	~PreparedStatementWrapper() {
377: 	}
378: 	unique_ptr<PreparedStatement> statement;
379: 	vector<Value> values;
380: };
381: } // namespace duckdb
382: duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
383:                             duckdb_prepared_statement *out_prepared_statement) {
384: 	if (!connection || !query) {
385: 		return DuckDBError;
386: 	}
387: 	auto wrapper = new PreparedStatementWrapper();
388: 	Connection *conn = (Connection *)connection;
389: 	wrapper->statement = conn->Prepare(query);
390: 	*out_prepared_statement = (duckdb_prepared_statement)wrapper;
391: 	return wrapper->statement->success ? DuckDBSuccess : DuckDBError;
392: }
393: 
394: duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out) {
395: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
396: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
397: 		return DuckDBError;
398: 	}
399: 	*nparams_out = wrapper->statement->n_param;
400: 	return DuckDBSuccess;
401: }
402: 
403: static duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_statement, idx_t param_idx, Value val) {
404: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
405: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
406: 		return DuckDBError;
407: 	}
408: 	if (param_idx > wrapper->statement->n_param) {
409: 		return DuckDBError;
410: 	}
411: 	if (param_idx > wrapper->values.size()) {
412: 		wrapper->values.resize(param_idx);
413: 	}
414: 	wrapper->values[param_idx - 1] = val;
415: 	return DuckDBSuccess;
416: }
417: 
418: duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val) {
419: 	return duckdb_bind_value(prepared_statement, param_idx, Value::BOOLEAN(val));
420: }
421: 
422: duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val) {
423: 	return duckdb_bind_value(prepared_statement, param_idx, Value::TINYINT(val));
424: }
425: 
426: duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val) {
427: 	return duckdb_bind_value(prepared_statement, param_idx, Value::SMALLINT(val));
428: }
429: 
430: duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val) {
431: 	return duckdb_bind_value(prepared_statement, param_idx, Value::INTEGER(val));
432: }
433: 
434: duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val) {
435: 	return duckdb_bind_value(prepared_statement, param_idx, Value::BIGINT(val));
436: }
437: 
438: duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val) {
439: 	return duckdb_bind_value(prepared_statement, param_idx, Value::UTINYINT(val));
440: }
441: 
442: duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val) {
443: 	return duckdb_bind_value(prepared_statement, param_idx, Value::USMALLINT(val));
444: }
445: 
446: duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val) {
447: 	return duckdb_bind_value(prepared_statement, param_idx, Value::UINTEGER(val));
448: }
449: 
450: duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val) {
451: 	return duckdb_bind_value(prepared_statement, param_idx, Value::UBIGINT(val));
452: }
453: 
454: duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val) {
455: 	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
456: }
457: 
458: duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val) {
459: 	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
460: }
461: 
462: duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val) {
463: 	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
464: }
465: 
466: duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val,
467:                                         idx_t length) {
468: 	return duckdb_bind_value(prepared_statement, param_idx, Value(string(val, length)));
469: }
470: 
471: duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx, const void *data,
472:                               idx_t length) {
473: 	return duckdb_bind_value(prepared_statement, param_idx, Value::BLOB((const_data_ptr_t)data, length));
474: }
475: 
476: duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx) {
477: 	return duckdb_bind_value(prepared_statement, param_idx, Value());
478: }
479: 
480: duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement, duckdb_result *out_result) {
481: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
482: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
483: 		return DuckDBError;
484: 	}
485: 	auto result = wrapper->statement->Execute(wrapper->values, false);
486: 	D_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);
487: 	auto mat_res = (MaterializedQueryResult *)result.get();
488: 	return duckdb_translate_result(mat_res, out_result);
489: }
490: 
491: void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement) {
492: 	if (!prepared_statement) {
493: 		return;
494: 	}
495: 	auto wrapper = (PreparedStatementWrapper *)*prepared_statement;
496: 	if (wrapper) {
497: 		delete wrapper;
498: 	}
499: 	*prepared_statement = nullptr;
500: }
501: 
502: duckdb_type ConvertCPPTypeToC(LogicalType sql_type) {
503: 	switch (sql_type.id()) {
504: 	case LogicalTypeId::BOOLEAN:
505: 		return DUCKDB_TYPE_BOOLEAN;
506: 	case LogicalTypeId::TINYINT:
507: 		return DUCKDB_TYPE_TINYINT;
508: 	case LogicalTypeId::SMALLINT:
509: 		return DUCKDB_TYPE_SMALLINT;
510: 	case LogicalTypeId::INTEGER:
511: 		return DUCKDB_TYPE_INTEGER;
512: 	case LogicalTypeId::BIGINT:
513: 		return DUCKDB_TYPE_BIGINT;
514: 	case LogicalTypeId::HUGEINT:
515: 		return DUCKDB_TYPE_HUGEINT;
516: 	case LogicalTypeId::FLOAT:
517: 		return DUCKDB_TYPE_FLOAT;
518: 	case LogicalTypeId::DOUBLE:
519: 		return DUCKDB_TYPE_DOUBLE;
520: 	case LogicalTypeId::TIMESTAMP:
521: 		return DUCKDB_TYPE_TIMESTAMP;
522: 	case LogicalTypeId::TIMESTAMP_SEC:
523: 		return DUCKDB_TYPE_TIMESTAMP_S;
524: 	case LogicalTypeId::TIMESTAMP_MS:
525: 		return DUCKDB_TYPE_TIMESTAMP_MS;
526: 	case LogicalTypeId::TIMESTAMP_NS:
527: 		return DUCKDB_TYPE_TIMESTAMP_NS;
528: 
529: 	case LogicalTypeId::DATE:
530: 		return DUCKDB_TYPE_DATE;
531: 	case LogicalTypeId::TIME:
532: 		return DUCKDB_TYPE_TIME;
533: 	case LogicalTypeId::VARCHAR:
534: 		return DUCKDB_TYPE_VARCHAR;
535: 	case LogicalTypeId::BLOB:
536: 		return DUCKDB_TYPE_BLOB;
537: 	case LogicalTypeId::INTERVAL:
538: 		return DUCKDB_TYPE_INTERVAL;
539: 	default:
540: 		return DUCKDB_TYPE_INVALID;
541: 	}
542: }
543: 
544: idx_t GetCTypeSize(duckdb_type type) {
545: 	switch (type) {
546: 	case DUCKDB_TYPE_BOOLEAN:
547: 		return sizeof(bool);
548: 	case DUCKDB_TYPE_TINYINT:
549: 		return sizeof(int8_t);
550: 	case DUCKDB_TYPE_SMALLINT:
551: 		return sizeof(int16_t);
552: 	case DUCKDB_TYPE_INTEGER:
553: 		return sizeof(int32_t);
554: 	case DUCKDB_TYPE_BIGINT:
555: 		return sizeof(int64_t);
556: 	case DUCKDB_TYPE_HUGEINT:
557: 		return sizeof(duckdb_hugeint);
558: 	case DUCKDB_TYPE_FLOAT:
559: 		return sizeof(float);
560: 	case DUCKDB_TYPE_DOUBLE:
561: 		return sizeof(double);
562: 	case DUCKDB_TYPE_DATE:
563: 		return sizeof(duckdb_date);
564: 	case DUCKDB_TYPE_TIME:
565: 		return sizeof(duckdb_time);
566: 	case DUCKDB_TYPE_TIMESTAMP:
567: 	case DUCKDB_TYPE_TIMESTAMP_NS:
568: 	case DUCKDB_TYPE_TIMESTAMP_MS:
569: 	case DUCKDB_TYPE_TIMESTAMP_S:
570: 		return sizeof(duckdb_timestamp);
571: 	case DUCKDB_TYPE_VARCHAR:
572: 		return sizeof(const char *);
573: 	case DUCKDB_TYPE_BLOB:
574: 		return sizeof(duckdb_blob);
575: 	case DUCKDB_TYPE_INTERVAL:
576: 		return sizeof(duckdb_interval);
577: 	default:
578: 		// unsupported type
579: 		D_ASSERT(0);
580: 		return sizeof(const char *);
581: 	}
582: }
583: 
584: template <class T>
585: T UnsafeFetch(duckdb_result *result, idx_t col, idx_t row) {
586: 	D_ASSERT(row < result->row_count);
587: 	return ((T *)result->columns[col].data)[row];
588: }
589: 
590: static Value GetCValue(duckdb_result *result, idx_t col, idx_t row) {
591: 	if (col >= result->column_count) {
592: 		return Value();
593: 	}
594: 	if (row >= result->row_count) {
595: 		return Value();
596: 	}
597: 	if (result->columns[col].nullmask[row]) {
598: 		return Value();
599: 	}
600: 	switch (result->columns[col].type) {
601: 	case DUCKDB_TYPE_BOOLEAN:
602: 		return Value::BOOLEAN(UnsafeFetch<bool>(result, col, row));
603: 	case DUCKDB_TYPE_TINYINT:
604: 		return Value::TINYINT(UnsafeFetch<int8_t>(result, col, row));
605: 	case DUCKDB_TYPE_SMALLINT:
606: 		return Value::SMALLINT(UnsafeFetch<int16_t>(result, col, row));
607: 	case DUCKDB_TYPE_INTEGER:
608: 		return Value::INTEGER(UnsafeFetch<int32_t>(result, col, row));
609: 	case DUCKDB_TYPE_BIGINT:
610: 		return Value::BIGINT(UnsafeFetch<int64_t>(result, col, row));
611: 	case DUCKDB_TYPE_FLOAT:
612: 		return Value(UnsafeFetch<float>(result, col, row));
613: 	case DUCKDB_TYPE_DOUBLE:
614: 		return Value(UnsafeFetch<double>(result, col, row));
615: 	case DUCKDB_TYPE_DATE: {
616: 		auto date = UnsafeFetch<duckdb_date>(result, col, row);
617: 		return Value::DATE(date.year, date.month, date.day);
618: 	}
619: 	case DUCKDB_TYPE_TIME: {
620: 		auto time = UnsafeFetch<duckdb_time>(result, col, row);
621: 		return Value::TIME(time.hour, time.min, time.sec, time.micros);
622: 	}
623: 	case DUCKDB_TYPE_TIMESTAMP_NS:
624: 	case DUCKDB_TYPE_TIMESTAMP_MS:
625: 	case DUCKDB_TYPE_TIMESTAMP_S:
626: 	case DUCKDB_TYPE_TIMESTAMP: {
627: 		auto timestamp = UnsafeFetch<duckdb_timestamp>(result, col, row);
628: 		return Value::TIMESTAMP(timestamp.date.year, timestamp.date.month, timestamp.date.day, timestamp.time.hour,
629: 		                        timestamp.time.min, timestamp.time.sec, timestamp.time.micros);
630: 	}
631: 	case DUCKDB_TYPE_HUGEINT: {
632: 		hugeint_t val;
633: 		auto hugeint = UnsafeFetch<duckdb_hugeint>(result, col, row);
634: 		val.lower = hugeint.lower;
635: 		val.upper = hugeint.upper;
636: 		return Value::HUGEINT(val);
637: 	}
638: 	case DUCKDB_TYPE_INTERVAL: {
639: 		interval_t val;
640: 		auto interval = UnsafeFetch<duckdb_interval>(result, col, row);
641: 		val.days = interval.days;
642: 		val.months = interval.months;
643: 		val.micros = interval.micros;
644: 		return Value::INTERVAL(val);
645: 	}
646: 	case DUCKDB_TYPE_VARCHAR:
647: 		return Value(string(UnsafeFetch<const char *>(result, col, row)));
648: 	case DUCKDB_TYPE_BLOB: {
649: 		auto blob = UnsafeFetch<duckdb_blob>(result, col, row);
650: 		return Value::BLOB((const_data_ptr_t)blob.data, blob.size);
651: 	}
652: 	default:
653: 		// invalid type for C to C++ conversion
654: 		D_ASSERT(0);
655: 		return Value();
656: 	}
657: }
658: 
659: const char *duckdb_column_name(duckdb_result *result, idx_t col) {
660: 	if (!result || col >= result->column_count) {
661: 		return nullptr;
662: 	}
663: 	return result->columns[col].name;
664: }
665: 
666: bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row) {
667: 	Value val = GetCValue(result, col, row);
668: 	if (val.is_null) {
669: 		return false;
670: 	} else {
671: 		return val.GetValue<bool>();
672: 	}
673: }
674: 
675: int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row) {
676: 	Value val = GetCValue(result, col, row);
677: 	if (val.is_null) {
678: 		return 0;
679: 	} else {
680: 		return val.GetValue<int8_t>();
681: 	}
682: }
683: 
684: int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row) {
685: 	Value val = GetCValue(result, col, row);
686: 	if (val.is_null) {
687: 		return 0;
688: 	} else {
689: 		return val.GetValue<int16_t>();
690: 	}
691: }
692: 
693: int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row) {
694: 	Value val = GetCValue(result, col, row);
695: 	if (val.is_null) {
696: 		return 0;
697: 	} else {
698: 		return val.GetValue<int32_t>();
699: 	}
700: }
701: 
702: int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row) {
703: 	Value val = GetCValue(result, col, row);
704: 	if (val.is_null) {
705: 		return 0;
706: 	} else {
707: 		return val.GetValue<int64_t>();
708: 	}
709: }
710: 
711: uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row) {
712: 	Value val = GetCValue(result, col, row);
713: 	if (val.is_null) {
714: 		return 0;
715: 	} else {
716: 		return val.GetValue<uint8_t>();
717: 	}
718: }
719: 
720: uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row) {
721: 	Value val = GetCValue(result, col, row);
722: 	if (val.is_null) {
723: 		return 0;
724: 	} else {
725: 		return val.GetValue<uint16_t>();
726: 	}
727: }
728: 
729: uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row) {
730: 	Value val = GetCValue(result, col, row);
731: 	if (val.is_null) {
732: 		return 0;
733: 	} else {
734: 		return val.GetValue<uint32_t>();
735: 	}
736: }
737: 
738: uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row) {
739: 	Value val = GetCValue(result, col, row);
740: 	if (val.is_null) {
741: 		return 0;
742: 	} else {
743: 		return val.GetValue<uint64_t>();
744: 	}
745: }
746: 
747: float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row) {
748: 	Value val = GetCValue(result, col, row);
749: 	if (val.is_null) {
750: 		return 0.0;
751: 	} else {
752: 		return val.GetValue<float>();
753: 	}
754: }
755: 
756: double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row) {
757: 	Value val = GetCValue(result, col, row);
758: 	if (val.is_null) {
759: 		return 0.0;
760: 	} else {
761: 		return val.GetValue<double>();
762: 	}
763: }
764: 
765: char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row) {
766: 	Value val = GetCValue(result, col, row);
767: 	return strdup(val.ToString().c_str());
768: }
769: 
770: duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row) {
771: 	duckdb_blob blob;
772: 	Value val = GetCValue(result, col, row).CastAs(LogicalType::BLOB);
773: 	if (val.is_null) {
774: 		blob.data = nullptr;
775: 		blob.size = 0;
776: 	} else {
777: 		blob.data = malloc(val.str_value.size());
778: 		memcpy((void *)blob.data, val.str_value.c_str(), val.str_value.size());
779: 		blob.size = val.str_value.size();
780: 	}
781: 	return blob;
782: }
783: 
784: void *duckdb_malloc(size_t size) {
785: 	return malloc(size);
786: }
787: 
788: void duckdb_free(void *ptr) {
789: 	free(ptr);
790: }
791: 
792: duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
793:                                     duckdb_appender *out_appender) {
794: 	Connection *conn = (Connection *)connection;
795: 
796: 	if (!connection || !table || !out_appender) {
797: 		return DuckDBError;
798: 	}
799: 	if (schema == nullptr) {
800: 
801: 		schema = DEFAULT_SCHEMA;
802: 	}
803: 	try {
804: 		auto *appender = new Appender(*conn, schema, table);
805: 		*out_appender = appender;
806: 	} catch (...) {
807: 		return DuckDBError;
808: 	}
809: 	return DuckDBSuccess;
810: }
811: 
812: duckdb_state duckdb_appender_destroy(duckdb_appender *appender) {
813: 	if (!appender || !*appender) {
814: 		return DuckDBError;
815: 	}
816: 	auto *appender_instance = *((Appender **)appender);
817: 	delete appender_instance;
818: 	*appender = nullptr;
819: 	return DuckDBSuccess;
820: }
821: 
822: #define APPENDER_CALL(FUN)                                                                                             \
823: 	if (!appender) {                                                                                                   \
824: 		return DuckDBError;                                                                                            \
825: 	}                                                                                                                  \
826: 	auto *appender_instance = (Appender *)appender;                                                                    \
827: 	try {                                                                                                              \
828: 		appender_instance->FUN();                                                                                      \
829: 	} catch (...) {                                                                                                    \
830: 		return DuckDBError;                                                                                            \
831: 	}                                                                                                                  \
832: 	return DuckDBSuccess;
833: 
834: #define APPENDER_CALL_PARAM(FUN, PARAM)                                                                                \
835: 	if (!appender) {                                                                                                   \
836: 		return DuckDBError;                                                                                            \
837: 	}                                                                                                                  \
838: 	auto *appender_instance = (Appender *)appender;                                                                    \
839: 	try {                                                                                                              \
840: 		appender_instance->FUN(PARAM);                                                                                 \
841: 	} catch (...) {                                                                                                    \
842: 		return DuckDBError;                                                                                            \
843: 	}                                                                                                                  \
844: 	return DuckDBSuccess;
845: 
846: duckdb_state duckdb_appender_begin_row(duckdb_appender appender) {
847: 	APPENDER_CALL(BeginRow);
848: }
849: 
850: duckdb_state duckdb_appender_end_row(duckdb_appender appender) {
851: 	APPENDER_CALL(EndRow);
852: }
853: 
854: duckdb_state duckdb_append_bool(duckdb_appender appender, bool value) {
855: 	APPENDER_CALL_PARAM(Append<bool>, value);
856: }
857: 
858: duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value) {
859: 	APPENDER_CALL_PARAM(Append<int8_t>, value);
860: }
861: 
862: duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value) {
863: 	APPENDER_CALL_PARAM(Append<int16_t>, value);
864: }
865: 
866: duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value) {
867: 	APPENDER_CALL_PARAM(Append<int32_t>, value);
868: }
869: 
870: duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value) {
871: 	APPENDER_CALL_PARAM(Append<int64_t>, value);
872: }
873: 
874: duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value) {
875: 	APPENDER_CALL_PARAM(Append<uint8_t>, value);
876: }
877: 
878: duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value) {
879: 	APPENDER_CALL_PARAM(Append<uint16_t>, value);
880: }
881: 
882: duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value) {
883: 	APPENDER_CALL_PARAM(Append<uint32_t>, value);
884: }
885: 
886: duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value) {
887: 	APPENDER_CALL_PARAM(Append<uint64_t>, value);
888: }
889: 
890: duckdb_state duckdb_append_float(duckdb_appender appender, float value) {
891: 	APPENDER_CALL_PARAM(Append<float>, value);
892: }
893: 
894: duckdb_state duckdb_append_double(duckdb_appender appender, double value) {
895: 	APPENDER_CALL_PARAM(Append<double>, value);
896: }
897: 
898: duckdb_state duckdb_append_null(duckdb_appender appender) {
899: 	APPENDER_CALL_PARAM(Append<std::nullptr_t>, nullptr);
900: }
901: 
902: duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val) {
903: 	auto string_val = Value(val);
904: 	APPENDER_CALL_PARAM(Append<Value>, string_val);
905: }
906: 
907: duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length) {
908: 	auto string_val = Value(string(val, length)); // TODO this copies orr
909: 	APPENDER_CALL_PARAM(Append<Value>, string_val);
910: }
911: duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length) {
912: 	auto blob_val = Value::BLOB((const_data_ptr_t)data, length);
913: 	APPENDER_CALL_PARAM(Append<Value>, blob_val);
914: }
915: 
916: duckdb_state duckdb_appender_flush(duckdb_appender appender) {
917: 	APPENDER_CALL(Flush);
918: }
919: 
920: duckdb_state duckdb_appender_close(duckdb_appender appender) {
921: 	APPENDER_CALL(Close);
922: }
[end of src/main/duckdb-c.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: