{
  "repo": "duckdb/duckdb",
  "pull_number": 1978,
  "instance_id": "duckdb__duckdb-1978",
  "issue_numbers": [
    "1921"
  ],
  "base_commit": "7697a08531afa375086827c72ea55673438faaa7",
  "patch": "diff --git a/src/include/duckdb.h b/src/include/duckdb.h\nindex be5ca9d46930..be1aa93a1e3f 100644\n--- a/src/include/duckdb.h\n+++ b/src/include/duckdb.h\n@@ -132,9 +132,28 @@ typedef void *duckdb_database;\n typedef void *duckdb_connection;\n typedef void *duckdb_prepared_statement;\n typedef void *duckdb_appender;\n+typedef void *duckdb_arrow;\n+// we don't need to spell out the schema/array in here\n+// because it's a common interface, users can consume\n+// the data in their own logic.\n+typedef void *duckdb_arrow_schema;\n+typedef void *duckdb_arrow_array;\n \n typedef enum { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;\n \n+//! query duckdb result as arrow data structure\n+DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);\n+//! get arrow schema\n+DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);\n+//! get arrow data array\n+//! This function can be called multiple time to get next chunks, which will free the previous out_array.\n+//! So consume the out_array before call this function again\n+DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);\n+//! get arrow error message\n+DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);\n+//! Destroys the arrow result\n+DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);\n+\n //! Opens a database file at the given path (nullptr for in-memory). Returns DuckDBSuccess on success, or DuckDBError on\n //! failure. [OUT: database]\n DUCKDB_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);\n@@ -200,6 +219,7 @@ DUCKDB_API void duckdb_free(void *ptr);\n DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,\n                                        duckdb_prepared_statement *out_prepared_statement);\n \n+DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);\n DUCKDB_API duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out);\n \n //! binds parameters to prepared statement\n@@ -226,6 +246,10 @@ DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_stat\n DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,\n                                                 duckdb_result *out_result);\n \n+//! Executes the prepared statements with currently bound parameters and return arrow result\n+DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,\n+                                                      duckdb_arrow *out_result);\n+\n //! Destroys the specified prepared statement descriptor\n DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);\n \ndiff --git a/src/main/duckdb-c.cpp b/src/main/duckdb-c.cpp\nindex 1d5acb631a0c..186a9516c9e0 100644\n--- a/src/main/duckdb-c.cpp\n+++ b/src/main/duckdb-c.cpp\n@@ -1,6 +1,7 @@\n #include \"duckdb/common/types/date.hpp\"\n #include \"duckdb/common/types/time.hpp\"\n #include \"duckdb/common/types/timestamp.hpp\"\n+#include \"duckdb/common/arrow.hpp\"\n #include \"duckdb/common/vector_operations/vector_operations.hpp\"\n #include \"duckdb/main/appender.hpp\"\n \n@@ -328,6 +329,63 @@ duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckd\n \treturn duckdb_translate_result(result.get(), out);\n }\n \n+namespace duckdb {\n+struct ArrowResultWrapper {\n+\tArrowResultWrapper() : result(nullptr), current_chunk(nullptr) {\n+\t}\n+\t~ArrowResultWrapper() {\n+\t}\n+\tunique_ptr<MaterializedQueryResult> result;\n+\tunique_ptr<DataChunk> current_chunk;\n+};\n+} // namespace duckdb\n+\n+duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result) {\n+\tConnection *conn = (Connection *)connection;\n+\tauto wrapper = new ArrowResultWrapper();\n+\twrapper->result = conn->Query(query);\n+\t*out_result = (duckdb_arrow)wrapper;\n+\treturn wrapper->result->success ? DuckDBSuccess : DuckDBError;\n+}\n+\n+duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema) {\n+\tif (!out_schema) {\n+\t\treturn DuckDBSuccess;\n+\t}\n+\tauto wrapper = (ArrowResultWrapper *)result;\n+\twrapper->result->ToArrowSchema((ArrowSchema *)*out_schema);\n+\treturn DuckDBSuccess;\n+}\n+\n+duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array) {\n+\tif (!out_array) {\n+\t\treturn DuckDBSuccess;\n+\t}\n+\tauto wrapper = (ArrowResultWrapper *)result;\n+\tauto success = wrapper->result->TryFetch(wrapper->current_chunk, wrapper->result->error);\n+\tif (!success) {\n+\t\treturn DuckDBError;\n+\t}\n+\tif (!wrapper->current_chunk || wrapper->current_chunk->size() == 0) {\n+\t\treturn DuckDBSuccess;\n+\t}\n+\twrapper->current_chunk->ToArrowArray((ArrowArray *)*out_array);\n+\treturn DuckDBSuccess;\n+}\n+\n+const char *duckdb_query_arrow_error(duckdb_arrow result) {\n+\tauto wrapper = (ArrowResultWrapper *)result;\n+\treturn wrapper->result->error.c_str();\n+}\n+\n+void duckdb_destroy_arrow(duckdb_arrow *result) {\n+\tif (*result) {\n+\t\tauto wrapper = (ArrowResultWrapper *)*result;\n+\t\tdelete wrapper;\n+\t\t*result = nullptr;\n+\t}\n+}\n+\n static void duckdb_destroy_column(duckdb_column column, idx_t count) {\n \tif (column.data) {\n \t\tif (column.type == DUCKDB_TYPE_VARCHAR) {\n@@ -391,6 +449,14 @@ duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,\n \treturn wrapper->statement->success ? DuckDBSuccess : DuckDBError;\n }\n \n+const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement) {\n+\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n+\tif (!wrapper || !wrapper->statement || wrapper->statement->success) {\n+\t\treturn nullptr;\n+\t}\n+\treturn wrapper->statement->error.c_str();\n+}\n+\n duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out) {\n \tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n \tif (!wrapper || !wrapper->statement || !wrapper->statement->success) {\n@@ -488,6 +554,20 @@ duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statemen\n \treturn duckdb_translate_result(mat_res, out_result);\n }\n \n+duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement, duckdb_arrow *out_result) {\n+\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n+\tif (!wrapper || !wrapper->statement || !wrapper->statement->success) {\n+\t\treturn DuckDBError;\n+\t}\n+\tauto arrow_wrapper = new ArrowResultWrapper();\n+\tauto result = wrapper->statement->Execute(wrapper->values, false);\n+\tD_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);\n+\tarrow_wrapper->result =\n+\t    unique_ptr<MaterializedQueryResult>(static_cast<MaterializedQueryResult *>(result.release()));\n+\t*out_result = (duckdb_arrow)arrow_wrapper;\n+\treturn arrow_wrapper->result->success ? DuckDBSuccess : DuckDBError;\n+}\n+\n void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement) {\n \tif (!prepared_statement) {\n \t\treturn;\n",
  "test_patch": "diff --git a/test/api/capi/test_capi.cpp b/test/api/capi/test_capi.cpp\nindex 33173616caa9..75d7ef0f920f 100644\n--- a/test/api/capi/test_capi.cpp\n+++ b/test/api/capi/test_capi.cpp\n@@ -1,6 +1,7 @@\n #include \"catch.hpp\"\n #include \"duckdb.h\"\n #include \"test_helpers.hpp\"\n+#include \"duckdb/common/arrow.hpp\"\n #include \"duckdb/common/exception.hpp\"\n \n using namespace duckdb;\n@@ -395,9 +396,22 @@ TEST_CASE(\"Test errors in C API\", \"[capi]\") {\n \t// fail prepare API calls\n \tREQUIRE(duckdb_prepare(NULL, \"SELECT 42\", &stmt) == DuckDBError);\n \tREQUIRE(duckdb_prepare(tester.connection, NULL, &stmt) == DuckDBError);\n+\tREQUIRE(stmt == nullptr);\n+\n+\tREQUIRE(duckdb_prepare(tester.connection, \"SELECT * from INVALID_TABLE\", &stmt) == DuckDBError);\n+\tREQUIRE(stmt != nullptr);\n+\tREQUIRE(duckdb_prepare_error(stmt) != nullptr);\n+\tduckdb_destroy_prepare(&stmt);\n+\n \tREQUIRE(duckdb_bind_boolean(NULL, 0, true) == DuckDBError);\n \tREQUIRE(duckdb_execute_prepared(NULL, &res) == DuckDBError);\n \tduckdb_destroy_prepare(NULL);\n+\n+\t// fail to query arrow\n+\tduckdb_arrow out_arrow;\n+\tREQUIRE(duckdb_query_arrow(tester.connection, \"SELECT * from INVALID_TABLE\", &out_arrow) == DuckDBError);\n+\tREQUIRE(duckdb_query_arrow_error(out_arrow) != nullptr);\n+\tduckdb_destroy_arrow(&out_arrow);\n }\n \n TEST_CASE(\"Test prepared statements in C API\", \"[capi][.]\") {\n@@ -645,3 +659,101 @@ TEST_CASE(\"Test appender statements in C API\", \"[capi][.]\") {\n \tstatus = duckdb_appender_destroy(nullptr);\n \tREQUIRE(status == DuckDBError);\n }\n+\n+TEST_CASE(\"Test arrow in C API\", \"[capi]\") {\n+\tCAPITester tester;\n+\tunique_ptr<CAPIResult> result;\n+\tduckdb_prepared_statement stmt = nullptr;\n+\tduckdb_arrow arrow_result;\n+\n+\t// open the database in in-memory mode\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\n+\t// test query arrow\n+\t{\n+\t\tREQUIRE(duckdb_query_arrow(tester.connection, \"SELECT 42 AS VALUE\", &arrow_result) == DuckDBSuccess);\n+\n+\t\t// query schema\n+\t\tArrowSchema *arrow_schema = new ArrowSchema();\n+\t\tREQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);\n+\t\tREQUIRE(string(arrow_schema->name) == \"duckdb_query_result\");\n+\t\t// User need to release the data themselves\n+\t\tarrow_schema->release(arrow_schema);\n+\t\tdelete arrow_schema;\n+\n+\t\t// query array data\n+\t\tArrowArray *arrow_array = new ArrowArray();\n+\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);\n+\t\tREQUIRE(arrow_array->length == 1);\n+\t\tarrow_array->release(arrow_array);\n+\t\tdelete arrow_array;\n+\n+\t\tduckdb_arrow_array null_array = nullptr;\n+\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, &null_array) == DuckDBSuccess);\n+\t\tREQUIRE(null_array == nullptr);\n+\n+\t\t// destroy result\n+\t\tduckdb_destroy_arrow(&arrow_result);\n+\t}\n+\n+\t// test multiple chunks\n+\t{\n+\t\t// create table that consists of multiple chunks\n+\t\tREQUIRE_NO_FAIL(tester.Query(\"BEGIN TRANSACTION\"));\n+\t\tREQUIRE_NO_FAIL(tester.Query(\"CREATE TABLE test(a INTEGER)\"));\n+\t\tfor (size_t i = 0; i < 500; i++) {\n+\t\t\tREQUIRE_NO_FAIL(\n+\t\t\t    tester.Query(\"INSERT INTO test VALUES (1); INSERT INTO test VALUES (2); INSERT INTO test VALUES \"\n+\t\t\t                 \"(3); INSERT INTO test VALUES (4); INSERT INTO test VALUES (5);\"));\n+\t\t}\n+\t\tREQUIRE_NO_FAIL(tester.Query(\"COMMIT\"));\n+\n+\t\tREQUIRE(duckdb_query_arrow(tester.connection, \"SELECT CAST(a AS INTEGER) AS a FROM test ORDER BY a\",\n+\t\t                           &arrow_result) == DuckDBSuccess);\n+\n+\t\tArrowSchema *arrow_schema = new ArrowSchema();\n+\t\tREQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);\n+\t\tREQUIRE(arrow_schema->release != nullptr);\n+\t\tarrow_schema->release(arrow_schema);\n+\t\tdelete arrow_schema;\n+\n+\t\tint total_count = 0;\n+\t\twhile (true) {\n+\t\t\tArrowArray *arrow_array = new ArrowArray();\n+\t\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);\n+\t\t\tif (arrow_array->length == 0) {\n+\t\t\t\tdelete arrow_array;\n+\t\t\t\tREQUIRE(total_count == 2500);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tREQUIRE(arrow_array->length > 0);\n+\t\t\ttotal_count += arrow_array->length;\n+\t\t\tarrow_array->release(arrow_array);\n+\t\t\tdelete arrow_array;\n+\t\t}\n+\t\tduckdb_destroy_arrow(&arrow_result);\n+\t}\n+\n+\t// test prepare query arrow\n+\t{\n+\t\tREQUIRE(duckdb_prepare(tester.connection, \"SELECT CAST($1 AS BIGINT)\", &stmt) == DuckDBSuccess);\n+\t\tREQUIRE(stmt != nullptr);\n+\t\tREQUIRE(duckdb_bind_int64(stmt, 1, 42) == DuckDBSuccess);\n+\t\tREQUIRE(duckdb_execute_prepared_arrow(stmt, &arrow_result) == DuckDBSuccess);\n+\n+\t\tArrowSchema *arrow_schema = new ArrowSchema();\n+\t\tREQUIRE(duckdb_query_arrow_schema(arrow_result, (duckdb_arrow_schema *)&arrow_schema) == DuckDBSuccess);\n+\t\tREQUIRE(string(arrow_schema->format) == \"+s\");\n+\t\tarrow_schema->release(arrow_schema);\n+\t\tdelete arrow_schema;\n+\n+\t\tArrowArray *arrow_array = new ArrowArray();\n+\t\tREQUIRE(duckdb_query_arrow_array(arrow_result, (duckdb_arrow_array *)&arrow_array) == DuckDBSuccess);\n+\t\tREQUIRE(arrow_array->length == 1);\n+\t\tarrow_array->release(arrow_array);\n+\t\tdelete arrow_array;\n+\n+\t\tduckdb_destroy_arrow(&arrow_result);\n+\t\tduckdb_destroy_prepare(&stmt);\n+\t}\n+}\n",
  "problem_statement": "Define duckdb_prepared_statement as struct so we can add error_message into it\nCurrently we don't the reason if duckdb_prepare failed\n",
  "hints_text": "",
  "created_at": "2021-07-10T12:03:49Z"
}