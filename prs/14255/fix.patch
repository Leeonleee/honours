diff --git a/src/include/duckdb/planner/expression_binder/order_binder.hpp b/src/include/duckdb/planner/expression_binder/order_binder.hpp
index df8365cc7001..b2838c19100e 100644
--- a/src/include/duckdb/planner/expression_binder/order_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder/order_binder.hpp
@@ -37,6 +37,9 @@ class OrderBinder {
 
 	unique_ptr<Expression> CreateExtraReference(unique_ptr<ParsedExpression> expr);
 
+	//! Sets the query component, for error messages
+	void SetQueryComponent(string component = string());
+
 private:
 	unique_ptr<Expression> CreateProjectionReference(ParsedExpression &expr, const idx_t index);
 	unique_ptr<Expression> BindConstant(ParsedExpression &expr);
@@ -46,6 +49,7 @@ class OrderBinder {
 	vector<reference<Binder>> binders;
 	optional_ptr<vector<unique_ptr<ParsedExpression>>> extra_list;
 	SelectBindState &bind_state;
+	string query_component = "ORDER BY";
 };
 
 } // namespace duckdb
diff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp
index f1bad4c335da..d58b3868efbe 100644
--- a/src/planner/binder/query_node/bind_select_node.cpp
+++ b/src/planner/binder/query_node/bind_select_node.cpp
@@ -140,6 +140,7 @@ void Binder::PrepareModifiers(OrderBinder &order_binder, QueryNode &statement, B
 					    make_uniq<ConstantExpression>(Value::INTEGER(UnsafeNumericCast<int32_t>(1 + i))));
 				}
 			}
+			order_binder.SetQueryComponent("DISTINCT ON");
 			for (auto &distinct_on_target : distinct.distinct_on_targets) {
 				auto expr = BindOrderExpression(order_binder, std::move(distinct_on_target));
 				if (!expr) {
@@ -147,10 +148,13 @@ void Binder::PrepareModifiers(OrderBinder &order_binder, QueryNode &statement, B
 				}
 				bound_distinct->target_distincts.push_back(std::move(expr));
 			}
+			order_binder.SetQueryComponent();
+
 			bound_modifier = std::move(bound_distinct);
 			break;
 		}
 		case ResultModifierType::ORDER_MODIFIER: {
+
 			auto &order = mod->Cast<OrderModifier>();
 			auto bound_order = make_uniq<BoundOrderModifier>();
 			auto &config = DBConfig::GetConfig(context);
diff --git a/src/planner/expression_binder/order_binder.cpp b/src/planner/expression_binder/order_binder.cpp
index 4516df444475..ff864bbbd269 100644
--- a/src/planner/expression_binder/order_binder.cpp
+++ b/src/planner/expression_binder/order_binder.cpp
@@ -61,8 +61,10 @@ optional_idx OrderBinder::TryGetProjectionReference(ParsedExpression &expr) cons
 			// this is disabled by default (matching Postgres) - but we can control this with a setting
 			auto &config = ClientConfig::GetConfig(binders[0].get().context);
 			if (!config.order_by_non_integer_literal) {
-				throw BinderException(expr, "ORDER BY non-integer literal has no effect.
* SET "
-				                            "order_by_non_integer_literal=true to allow this behavior.");
+				throw BinderException(expr,
+				                      "%s non-integer literal has no effect.
* SET "
+				                      "order_by_non_integer_literal=true to allow this behavior.",
+				                      query_component);
 			}
 			break;
 		}
@@ -94,6 +96,14 @@ optional_idx OrderBinder::TryGetProjectionReference(ParsedExpression &expr) cons
 	return optional_idx();
 }
 
+void OrderBinder::SetQueryComponent(string component) {
+	if (component.empty()) {
+		query_component = "ORDER BY";
+	} else {
+		query_component = std::move(component);
+	}
+}
+
 unique_ptr<Expression> OrderBinder::BindConstant(ParsedExpression &expr) {
 	auto index = TryGetProjectionReference(expr);
 	if (!index.IsValid()) {
@@ -130,7 +140,7 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {
 		break;
 	}
 	case ExpressionClass::PARAMETER: {
-		throw ParameterNotAllowedException("Parameter not supported in ORDER BY clause");
+		throw ParameterNotAllowedException("Parameter not supported in %s clause", query_component);
 	}
 	case ExpressionClass::COLLATE: {
 		auto &collation = expr->Cast<CollateExpression>();
