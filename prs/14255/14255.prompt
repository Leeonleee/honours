You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Literal in SELECT DISTINCT ON clause raises ORDER BY non-integer literal has no effect.
### What happens?

After upgrading to DuckDB 1.1.1, I encountered an issue where DuckDB raises `Binder Error: ORDER BY non-integer literal has no effect` when having literal in `SELECT DISTINCT ON (..)` clause.

Turning order_by_non_integer_literal=true resolves the issue, allowing literal in DISTINCT ON.

The error message is really confusing as the initial cause does not come from the ORDER BY clause.

I would rather accept literal in SELECT DISTINCT clause by default or rework the error message to point out the correct SQL clause. 

### To Reproduce

```
con = duckdb.connect(":memory:")
con.execute('CREATE TABLE my_table AS SELECT 42 AS "column_name";')
con.execute("SET order_by_non_integer_literal = true;")
con.execute(
    "SELECT DISTINCT ON (my_table.column_name, 'co2') my_table.column_name FROM my_table"
).fetchone()

```

### OS:

iOS/Linux

### DuckDB Version:

1.1.1

### DuckDB Client:

Python

### Hardware:

_No response_

### Full Name:

Jonathan Wadin

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [ ] Yes, I have
Literal in SELECT DISTINCT ON clause raises ORDER BY non-integer literal has no effect.
### What happens?

After upgrading to DuckDB 1.1.1, I encountered an issue where DuckDB raises `Binder Error: ORDER BY non-integer literal has no effect` when having literal in `SELECT DISTINCT ON (..)` clause.

Turning order_by_non_integer_literal=true resolves the issue, allowing literal in DISTINCT ON.

The error message is really confusing as the initial cause does not come from the ORDER BY clause.

I would rather accept literal in SELECT DISTINCT clause by default or rework the error message to point out the correct SQL clause. 

### To Reproduce

```
con = duckdb.connect(":memory:")
con.execute('CREATE TABLE my_table AS SELECT 42 AS "column_name";')
con.execute("SET order_by_non_integer_literal = true;")
con.execute(
    "SELECT DISTINCT ON (my_table.column_name, 'co2') my_table.column_name FROM my_table"
).fetchone()

```

### OS:

iOS/Linux

### DuckDB Version:

1.1.1

### DuckDB Client:

Python

### Hardware:

_No response_

### Full Name:

Jonathan Wadin

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [ ] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/include/duckdb/planner/expression_binder/order_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression_binder/order_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/case_insensitive_map.hpp"
12: #include "duckdb/parser/expression_map.hpp"
13: #include "duckdb/parser/parsed_expression.hpp"
14: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
15: 
16: namespace duckdb {
17: class Binder;
18: class Expression;
19: class SelectNode;
20: struct SelectBindState;
21: 
22: //! The ORDER binder is responsible for binding an expression within the ORDER BY clause of a SQL statement
23: class OrderBinder {
24: public:
25: 	OrderBinder(vector<reference<Binder>> binders, SelectBindState &bind_state);
26: 	OrderBinder(vector<reference<Binder>> binders, SelectNode &node, SelectBindState &bind_state);
27: 
28: public:
29: 	unique_ptr<Expression> Bind(unique_ptr<ParsedExpression> expr);
30: 
31: 	bool HasExtraList() const {
32: 		return extra_list;
33: 	}
34: 	const vector<reference<Binder>> &GetBinders() const {
35: 		return binders;
36: 	}
37: 
38: 	unique_ptr<Expression> CreateExtraReference(unique_ptr<ParsedExpression> expr);
39: 
40: private:
41: 	unique_ptr<Expression> CreateProjectionReference(ParsedExpression &expr, const idx_t index);
42: 	unique_ptr<Expression> BindConstant(ParsedExpression &expr);
43: 	optional_idx TryGetProjectionReference(ParsedExpression &expr) const;
44: 
45: private:
46: 	vector<reference<Binder>> binders;
47: 	optional_ptr<vector<unique_ptr<ParsedExpression>>> extra_list;
48: 	SelectBindState &bind_state;
49: };
50: 
51: } // namespace duckdb
[end of src/include/duckdb/planner/expression_binder/order_binder.hpp]
[start of src/planner/binder/query_node/bind_select_node.cpp]
1: #include "duckdb/common/limits.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/function/aggregate/distributive_functions.hpp"
5: #include "duckdb/function/function_binder.hpp"
6: #include "duckdb/main/config.hpp"
7: #include "duckdb/parser/expression/columnref_expression.hpp"
8: #include "duckdb/parser/expression/comparison_expression.hpp"
9: #include "duckdb/parser/expression/conjunction_expression.hpp"
10: #include "duckdb/parser/expression/constant_expression.hpp"
11: #include "duckdb/parser/expression/function_expression.hpp"
12: #include "duckdb/parser/expression/star_expression.hpp"
13: #include "duckdb/parser/expression/subquery_expression.hpp"
14: #include "duckdb/parser/parsed_expression_iterator.hpp"
15: #include "duckdb/parser/query_node/select_node.hpp"
16: #include "duckdb/parser/tableref/basetableref.hpp"
17: #include "duckdb/parser/tableref/joinref.hpp"
18: #include "duckdb/planner/binder.hpp"
19: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
20: #include "duckdb/planner/expression/bound_constant_expression.hpp"
21: #include "duckdb/planner/expression/bound_expanded_expression.hpp"
22: #include "duckdb/planner/expression_binder/column_alias_binder.hpp"
23: #include "duckdb/planner/expression_binder/constant_binder.hpp"
24: #include "duckdb/planner/expression_binder/group_binder.hpp"
25: #include "duckdb/planner/expression_binder/having_binder.hpp"
26: #include "duckdb/planner/expression_binder/order_binder.hpp"
27: #include "duckdb/planner/expression_binder/qualify_binder.hpp"
28: #include "duckdb/planner/expression_binder/select_bind_state.hpp"
29: #include "duckdb/planner/expression_binder/select_binder.hpp"
30: #include "duckdb/planner/expression_binder/where_binder.hpp"
31: #include "duckdb/planner/query_node/bound_select_node.hpp"
32: 
33: namespace duckdb {
34: 
35: unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {
36: 	// we treat the distinct list as an ORDER BY
37: 	auto bound_expr = order_binder.Bind(std::move(expr));
38: 	if (!bound_expr) {
39: 		// DISTINCT ON non-integer constant
40: 		// remove the expression from the DISTINCT ON list
41: 		return nullptr;
42: 	}
43: 	D_ASSERT(bound_expr->type == ExpressionType::VALUE_CONSTANT);
44: 	return bound_expr;
45: }
46: 
47: BoundLimitNode Binder::BindLimitValue(OrderBinder &order_binder, unique_ptr<ParsedExpression> limit_val,
48:                                       bool is_percentage, bool is_offset) {
49: 	auto new_binder = Binder::CreateBinder(context, this);
50: 	ExpressionBinder expr_binder(*new_binder, context);
51: 	auto target_type = is_percentage ? LogicalType::DOUBLE : LogicalType::BIGINT;
52: 	expr_binder.target_type = target_type;
53: 	auto original_limit = limit_val->Copy();
54: 	auto expr = expr_binder.Bind(limit_val);
55: 	if (expr->HasSubquery()) {
56: 		if (!order_binder.HasExtraList()) {
57: 			throw BinderException("Subquery in LIMIT/OFFSET not supported in set operation");
58: 		}
59: 		auto bound_limit = order_binder.CreateExtraReference(std::move(original_limit));
60: 		if (is_percentage) {
61: 			return BoundLimitNode::ExpressionPercentage(std::move(bound_limit));
62: 		} else {
63: 			return BoundLimitNode::ExpressionValue(std::move(bound_limit));
64: 		}
65: 	}
66: 	if (expr->IsFoldable()) {
67: 		//! this is a constant
68: 		auto val = ExpressionExecutor::EvaluateScalar(context, *expr).CastAs(context, target_type);
69: 		if (is_percentage) {
70: 			D_ASSERT(!is_offset);
71: 			double percentage_val;
72: 			if (val.IsNull()) {
73: 				percentage_val = 100.0;
74: 			} else {
75: 				percentage_val = val.GetValue<double>();
76: 			}
77: 			if (Value::IsNan(percentage_val) || percentage_val < 0 || percentage_val > 100) {
78: 				throw OutOfRangeException("Limit percent out of range, should be between 0% and 100%");
79: 			}
80: 			return BoundLimitNode::ConstantPercentage(percentage_val);
81: 		} else {
82: 			int64_t constant_val;
83: 			if (val.IsNull()) {
84: 				constant_val = is_offset ? 0 : NumericLimits<int64_t>::Maximum();
85: 			} else {
86: 				constant_val = val.GetValue<int64_t>();
87: 			}
88: 			if (constant_val < 0) {
89: 				throw BinderException(expr->query_location, "LIMIT/OFFSET cannot be negative");
90: 			}
91: 			return BoundLimitNode::ConstantValue(constant_val);
92: 		}
93: 	}
94: 	if (!new_binder->correlated_columns.empty()) {
95: 		throw BinderException("Correlated columns not supported in LIMIT/OFFSET");
96: 	}
97: 	// move any correlated columns to this binder
98: 	MoveCorrelatedExpressions(*new_binder);
99: 	if (is_percentage) {
100: 		return BoundLimitNode::ExpressionPercentage(std::move(expr));
101: 	} else {
102: 		return BoundLimitNode::ExpressionValue(std::move(expr));
103: 	}
104: }
105: 
106: duckdb::unique_ptr<BoundResultModifier> Binder::BindLimit(OrderBinder &order_binder, LimitModifier &limit_mod) {
107: 	auto result = make_uniq<BoundLimitModifier>();
108: 	if (limit_mod.limit) {
109: 		result->limit_val = BindLimitValue(order_binder, std::move(limit_mod.limit), false, false);
110: 	}
111: 	if (limit_mod.offset) {
112: 		result->offset_val = BindLimitValue(order_binder, std::move(limit_mod.offset), false, true);
113: 	}
114: 	return std::move(result);
115: }
116: 
117: unique_ptr<BoundResultModifier> Binder::BindLimitPercent(OrderBinder &order_binder, LimitPercentModifier &limit_mod) {
118: 	auto result = make_uniq<BoundLimitModifier>();
119: 	if (limit_mod.limit) {
120: 		result->limit_val = BindLimitValue(order_binder, std::move(limit_mod.limit), true, false);
121: 	}
122: 	if (limit_mod.offset) {
123: 		result->offset_val = BindLimitValue(order_binder, std::move(limit_mod.offset), false, true);
124: 	}
125: 	return std::move(result);
126: }
127: 
128: void Binder::PrepareModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result) {
129: 	for (auto &mod : statement.modifiers) {
130: 		unique_ptr<BoundResultModifier> bound_modifier;
131: 		switch (mod->type) {
132: 		case ResultModifierType::DISTINCT_MODIFIER: {
133: 			auto &distinct = mod->Cast<DistinctModifier>();
134: 			auto bound_distinct = make_uniq<BoundDistinctModifier>();
135: 			bound_distinct->distinct_type =
136: 			    distinct.distinct_on_targets.empty() ? DistinctType::DISTINCT : DistinctType::DISTINCT_ON;
137: 			if (distinct.distinct_on_targets.empty()) {
138: 				for (idx_t i = 0; i < result.names.size(); i++) {
139: 					distinct.distinct_on_targets.push_back(
140: 					    make_uniq<ConstantExpression>(Value::INTEGER(UnsafeNumericCast<int32_t>(1 + i))));
141: 				}
142: 			}
143: 			for (auto &distinct_on_target : distinct.distinct_on_targets) {
144: 				auto expr = BindOrderExpression(order_binder, std::move(distinct_on_target));
145: 				if (!expr) {
146: 					continue;
147: 				}
148: 				bound_distinct->target_distincts.push_back(std::move(expr));
149: 			}
150: 			bound_modifier = std::move(bound_distinct);
151: 			break;
152: 		}
153: 		case ResultModifierType::ORDER_MODIFIER: {
154: 			auto &order = mod->Cast<OrderModifier>();
155: 			auto bound_order = make_uniq<BoundOrderModifier>();
156: 			auto &config = DBConfig::GetConfig(context);
157: 			D_ASSERT(!order.orders.empty());
158: 			auto &order_binders = order_binder.GetBinders();
159: 			if (order.orders.size() == 1 && order.orders[0].expression->type == ExpressionType::STAR) {
160: 				auto &star = order.orders[0].expression->Cast<StarExpression>();
161: 				if (star.exclude_list.empty() && star.replace_list.empty() && !star.expr) {
162: 					// ORDER BY ALL
163: 					// replace the order list with the all elements in the SELECT list
164: 					auto order_type = config.ResolveOrder(order.orders[0].type);
165: 					auto null_order = config.ResolveNullOrder(order_type, order.orders[0].null_order);
166: 					auto constant_expr = make_uniq<BoundConstantExpression>(Value("ALL"));
167: 					bound_order->orders.emplace_back(order_type, null_order, std::move(constant_expr));
168: 					bound_modifier = std::move(bound_order);
169: 					break;
170: 				}
171: 			}
172: #if 0
173: 			// When this verification is enabled, replace ORDER BY x, y with ORDER BY create_sort_key(x, y)
174: 			// note that we don't enable this during actual verification since it doesn't always work
175: 			// e.g. it breaks EXPLAIN output on queries
176: 			bool can_replace = true;
177: 			for (auto &order_node : order.orders) {
178: 				if (order_node.expression->type == ExpressionType::VALUE_CONSTANT) {
179: 					// we cannot replace the sort key when we order by literals (e.g. ORDER BY 1, 2`
180: 					can_replace = false;
181: 					break;
182: 				}
183: 			}
184: 			if (!order_binder.HasExtraList()) {
185: 				// we can only do the replacement when we can order by elements that are not in the selection list
186: 				can_replace = false;
187: 			}
188: 			if (can_replace) {
189: 				vector<unique_ptr<ParsedExpression>> sort_key_parameters;
190: 				for (auto &order_node : order.orders) {
191: 					sort_key_parameters.push_back(std::move(order_node.expression));
192: 					auto type = config.ResolveOrder(order_node.type);
193: 					auto null_order = config.ResolveNullOrder(type, order_node.null_order);
194: 					string sort_param = EnumUtil::ToString(type) + " " + EnumUtil::ToString(null_order);
195: 					sort_key_parameters.push_back(make_uniq<ConstantExpression>(Value(sort_param)));
196: 				}
197: 				order.orders.clear();
198: 				auto create_sort_key = make_uniq<FunctionExpression>("create_sort_key", std::move(sort_key_parameters));
199: 				order.orders.emplace_back(OrderType::ASCENDING, OrderByNullType::NULLS_LAST, std::move(create_sort_key));
200: 			}
201: #endif
202: 			for (auto &order_node : order.orders) {
203: 				vector<unique_ptr<ParsedExpression>> order_list;
204: 				order_binders[0].get().ExpandStarExpression(std::move(order_node.expression), order_list);
205: 
206: 				auto type = config.ResolveOrder(order_node.type);
207: 				auto null_order = config.ResolveNullOrder(type, order_node.null_order);
208: 				for (auto &order_expr : order_list) {
209: 					auto bound_expr = BindOrderExpression(order_binder, std::move(order_expr));
210: 					if (!bound_expr) {
211: 						continue;
212: 					}
213: 					bound_order->orders.emplace_back(type, null_order, std::move(bound_expr));
214: 				}
215: 			}
216: 			if (!bound_order->orders.empty()) {
217: 				bound_modifier = std::move(bound_order);
218: 			}
219: 			break;
220: 		}
221: 		case ResultModifierType::LIMIT_MODIFIER:
222: 			bound_modifier = BindLimit(order_binder, mod->Cast<LimitModifier>());
223: 			break;
224: 		case ResultModifierType::LIMIT_PERCENT_MODIFIER:
225: 			bound_modifier = BindLimitPercent(order_binder, mod->Cast<LimitPercentModifier>());
226: 			break;
227: 		default:
228: 			throw InternalException("Unsupported result modifier");
229: 		}
230: 		if (bound_modifier) {
231: 			result.modifiers.push_back(std::move(bound_modifier));
232: 		}
233: 	}
234: }
235: 
236: unique_ptr<Expression> CreateOrderExpression(unique_ptr<Expression> expr, const vector<string> &names,
237:                                              const vector<LogicalType> &sql_types, idx_t table_index, idx_t index) {
238: 	if (index >= sql_types.size()) {
239: 		throw BinderException(*expr, "ORDER term out of range - should be between 1 and %lld", sql_types.size());
240: 	}
241: 	auto result = make_uniq<BoundColumnRefExpression>(std::move(expr->alias), sql_types[index],
242: 	                                                  ColumnBinding(table_index, index));
243: 	if (result->alias.empty() && index < names.size()) {
244: 		result->alias = names[index];
245: 	}
246: 	return std::move(result);
247: }
248: 
249: unique_ptr<Expression> FinalizeBindOrderExpression(unique_ptr<Expression> expr, idx_t table_index,
250:                                                    const vector<string> &names, const vector<LogicalType> &sql_types,
251:                                                    const SelectBindState &bind_state) {
252: 	auto &constant = expr->Cast<BoundConstantExpression>();
253: 	switch (constant.value.type().id()) {
254: 	case LogicalTypeId::UBIGINT: {
255: 		// index
256: 		auto index = UBigIntValue::Get(constant.value);
257: 		return CreateOrderExpression(std::move(expr), names, sql_types, table_index, bind_state.GetFinalIndex(index));
258: 	}
259: 	case LogicalTypeId::VARCHAR: {
260: 		// ORDER BY ALL
261: 		return nullptr;
262: 	}
263: 	case LogicalTypeId::STRUCT: {
264: 		// collation
265: 		auto &struct_values = StructValue::GetChildren(constant.value);
266: 		if (struct_values.size() > 2) {
267: 			throw InternalException("Expected one or two children: index and optional collation");
268: 		}
269: 		auto index = UBigIntValue::Get(struct_values[0]);
270: 		string collation;
271: 		if (struct_values.size() == 2) {
272: 			collation = StringValue::Get(struct_values[1]);
273: 		}
274: 		auto result = CreateOrderExpression(std::move(expr), names, sql_types, table_index, index);
275: 		if (!collation.empty()) {
276: 			if (sql_types[index].id() != LogicalTypeId::VARCHAR) {
277: 				throw BinderException(*result, "COLLATE can only be applied to varchar columns");
278: 			}
279: 			result->return_type = LogicalType::VARCHAR_COLLATION(std::move(collation));
280: 		}
281: 		return result;
282: 	}
283: 	default:
284: 		throw InternalException("Unknown type in FinalizeBindOrderExpression");
285: 	}
286: }
287: 
288: static void AssignReturnType(unique_ptr<Expression> &expr, idx_t table_index, const vector<string> &names,
289:                              const vector<LogicalType> &sql_types, const SelectBindState &bind_state) {
290: 	if (!expr) {
291: 		return;
292: 	}
293: 	if (expr->type == ExpressionType::VALUE_CONSTANT) {
294: 		expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
295: 	}
296: 	if (expr->type != ExpressionType::BOUND_COLUMN_REF) {
297: 		return;
298: 	}
299: 	auto &bound_colref = expr->Cast<BoundColumnRefExpression>();
300: 	bound_colref.return_type = sql_types[bound_colref.binding.column_index];
301: }
302: 
303: void Binder::BindModifiers(BoundQueryNode &result, idx_t table_index, const vector<string> &names,
304:                            const vector<LogicalType> &sql_types, const SelectBindState &bind_state) {
305: 	for (auto &bound_mod : result.modifiers) {
306: 		switch (bound_mod->type) {
307: 		case ResultModifierType::DISTINCT_MODIFIER: {
308: 			auto &distinct = bound_mod->Cast<BoundDistinctModifier>();
309: 			D_ASSERT(!distinct.target_distincts.empty());
310: 			// set types of distinct targets
311: 			for (auto &expr : distinct.target_distincts) {
312: 				expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
313: 				if (!expr) {
314: 					throw InternalException("DISTINCT ON ORDER BY ALL not supported");
315: 				}
316: 			}
317: 			for (auto &expr : distinct.target_distincts) {
318: 				ExpressionBinder::PushCollation(context, expr, expr->return_type);
319: 			}
320: 			break;
321: 		}
322: 		case ResultModifierType::LIMIT_MODIFIER: {
323: 			auto &limit = bound_mod->Cast<BoundLimitModifier>();
324: 			AssignReturnType(limit.limit_val.GetExpression(), table_index, names, sql_types, bind_state);
325: 			AssignReturnType(limit.offset_val.GetExpression(), table_index, names, sql_types, bind_state);
326: 			break;
327: 		}
328: 		case ResultModifierType::ORDER_MODIFIER: {
329: 			auto &order = bound_mod->Cast<BoundOrderModifier>();
330: 			bool order_by_all = false;
331: 			for (auto &order_node : order.orders) {
332: 				auto &expr = order_node.expression;
333: 				expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
334: 				if (!expr) {
335: 					order_by_all = true;
336: 				}
337: 			}
338: 			if (order_by_all) {
339: 				D_ASSERT(order.orders.size() == 1);
340: 				auto order_type = order.orders[0].type;
341: 				auto null_order = order.orders[0].null_order;
342: 				order.orders.clear();
343: 				for (idx_t i = 0; i < sql_types.size(); i++) {
344: 					auto expr = make_uniq<BoundColumnRefExpression>(sql_types[i], ColumnBinding(table_index, i));
345: 					if (i < names.size()) {
346: 						expr->alias = names[i];
347: 					}
348: 					order.orders.emplace_back(order_type, null_order, std::move(expr));
349: 				}
350: 			}
351: 			for (auto &order_node : order.orders) {
352: 				auto &expr = order_node.expression;
353: 				ExpressionBinder::PushCollation(context, order_node.expression, expr->return_type);
354: 			}
355: 			break;
356: 		}
357: 		default:
358: 			break;
359: 		}
360: 	}
361: }
362: 
363: unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
364: 	D_ASSERT(statement.from_table);
365: 
366: 	// first bind the FROM table statement
367: 	auto from = std::move(statement.from_table);
368: 	auto from_table = Bind(*from);
369: 	return BindSelectNode(statement, std::move(from_table));
370: }
371: 
372: void Binder::BindWhereStarExpression(unique_ptr<ParsedExpression> &expr) {
373: 	// expand any expressions in the upper AND recursively
374: 	if (expr->type == ExpressionType::CONJUNCTION_AND) {
375: 		auto &conj = expr->Cast<ConjunctionExpression>();
376: 		for (auto &child : conj.children) {
377: 			BindWhereStarExpression(child);
378: 		}
379: 		return;
380: 	}
381: 	if (expr->type == ExpressionType::STAR) {
382: 		auto &star = expr->Cast<StarExpression>();
383: 		if (!star.columns) {
384: 			throw ParserException("STAR expression is not allowed in the WHERE clause. Use COLUMNS(*) instead.");
385: 		}
386: 	}
387: 	// expand the stars for this expression
388: 	vector<unique_ptr<ParsedExpression>> new_conditions;
389: 	ExpandStarExpression(std::move(expr), new_conditions);
390: 	if (new_conditions.empty()) {
391: 		throw ParserException("COLUMNS expansion resulted in empty set of columns");
392: 	}
393: 
394: 	// set up an AND conjunction between the expanded conditions
395: 	expr = std::move(new_conditions[0]);
396: 	for (idx_t i = 1; i < new_conditions.size(); i++) {
397: 		auto and_conj = make_uniq<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, std::move(expr),
398: 		                                                 std::move(new_conditions[i]));
399: 		expr = std::move(and_conj);
400: 	}
401: }
402: 
403: unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_ptr<BoundTableRef> from_table) {
404: 	D_ASSERT(from_table);
405: 	D_ASSERT(!statement.from_table);
406: 	auto result = make_uniq<BoundSelectNode>();
407: 	result->projection_index = GenerateTableIndex();
408: 	result->group_index = GenerateTableIndex();
409: 	result->aggregate_index = GenerateTableIndex();
410: 	result->groupings_index = GenerateTableIndex();
411: 	result->window_index = GenerateTableIndex();
412: 	result->prune_index = GenerateTableIndex();
413: 
414: 	result->from_table = std::move(from_table);
415: 	// bind the sample clause
416: 	if (statement.sample) {
417: 		result->sample_options = std::move(statement.sample);
418: 	}
419: 
420: 	// visit the select list and expand any "*" statements
421: 	vector<unique_ptr<ParsedExpression>> new_select_list;
422: 	ExpandStarExpressions(statement.select_list, new_select_list);
423: 
424: 	if (new_select_list.empty()) {
425: 		throw BinderException("SELECT list is empty after resolving * expressions!");
426: 	}
427: 	statement.select_list = std::move(new_select_list);
428: 
429: 	auto &bind_state = result->bind_state;
430: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
431: 		auto &expr = statement.select_list[i];
432: 		result->names.push_back(expr->GetName());
433: 		ExpressionBinder::QualifyColumnNames(*this, expr);
434: 		if (!expr->alias.empty()) {
435: 			bind_state.alias_map[expr->alias] = i;
436: 			result->names[i] = expr->alias;
437: 		}
438: 		bind_state.projection_map[*expr] = i;
439: 		bind_state.original_expressions.push_back(expr->Copy());
440: 	}
441: 	result->column_count = statement.select_list.size();
442: 
443: 	// first visit the WHERE clause
444: 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
445: 	if (statement.where_clause) {
446: 		// bind any star expressions in the WHERE clause
447: 		BindWhereStarExpression(statement.where_clause);
448: 
449: 		ColumnAliasBinder alias_binder(bind_state);
450: 		WhereBinder where_binder(*this, context, &alias_binder);
451: 		unique_ptr<ParsedExpression> condition = std::move(statement.where_clause);
452: 		result->where_clause = where_binder.Bind(condition);
453: 	}
454: 
455: 	// now bind all the result modifiers; including DISTINCT and ORDER BY targets
456: 	OrderBinder order_binder({*this}, statement, bind_state);
457: 	PrepareModifiers(order_binder, statement, *result);
458: 
459: 	vector<unique_ptr<ParsedExpression>> unbound_groups;
460: 	BoundGroupInformation info;
461: 	auto &group_expressions = statement.groups.group_expressions;
462: 	if (!group_expressions.empty()) {
463: 		// the statement has a GROUP BY clause, bind it
464: 		unbound_groups.resize(group_expressions.size());
465: 		GroupBinder group_binder(*this, context, statement, result->group_index, bind_state, info.alias_map);
466: 		for (idx_t i = 0; i < group_expressions.size(); i++) {
467: 
468: 			// we keep a copy of the unbound expression;
469: 			// we keep the unbound copy around to check for group references in the SELECT and HAVING clause
470: 			// the reason we want the unbound copy is because we want to figure out whether an expression
471: 			// is a group reference BEFORE binding in the SELECT/HAVING binder
472: 			group_binder.unbound_expression = group_expressions[i]->Copy();
473: 			group_binder.bind_index = i;
474: 
475: 			// bind the groups
476: 			LogicalType group_type;
477: 			auto bound_expr = group_binder.Bind(group_expressions[i], &group_type);
478: 			D_ASSERT(bound_expr->return_type.id() != LogicalTypeId::INVALID);
479: 
480: 			// find out whether the expression contains a subquery, it can't be copied if so
481: 			auto &bound_expr_ref = *bound_expr;
482: 			bool contains_subquery = bound_expr_ref.HasSubquery();
483: 
484: 			// push a potential collation, if necessary
485: 			bool requires_collation = ExpressionBinder::PushCollation(context, bound_expr, group_type);
486: 			if (!contains_subquery && requires_collation) {
487: 				// if there is a collation on a group x, we should group by the collated expr,
488: 				// but also push a first(x) aggregate in case x is selected (uncollated)
489: 				info.collated_groups[i] = result->aggregates.size();
490: 
491: 				auto first_fun = FirstFun::GetFunction(bound_expr_ref.return_type);
492: 				vector<unique_ptr<Expression>> first_children;
493: 				// FIXME: would be better to just refer to this expression, but for now we copy
494: 				first_children.push_back(bound_expr_ref.Copy());
495: 
496: 				FunctionBinder function_binder(context);
497: 				auto function = function_binder.BindAggregateFunction(first_fun, std::move(first_children));
498: 				function->alias = "__collated_group";
499: 				result->aggregates.push_back(std::move(function));
500: 			}
501: 			result->groups.group_expressions.push_back(std::move(bound_expr));
502: 
503: 			// in the unbound expression we DO bind the table names of any ColumnRefs
504: 			// we do this to make sure that "table.a" and "a" are treated the same
505: 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
506: 			// hence we convert "a" -> "test.a" in the unbound expression
507: 			unbound_groups[i] = std::move(group_binder.unbound_expression);
508: 			ExpressionBinder::QualifyColumnNames(*this, unbound_groups[i]);
509: 			info.map[*unbound_groups[i]] = i;
510: 		}
511: 	}
512: 	result->groups.grouping_sets = std::move(statement.groups.grouping_sets);
513: 
514: 	// bind the HAVING clause, if any
515: 	if (statement.having) {
516: 		HavingBinder having_binder(*this, context, *result, info, statement.aggregate_handling);
517: 		ExpressionBinder::QualifyColumnNames(*this, statement.having);
518: 		result->having = having_binder.Bind(statement.having);
519: 	}
520: 
521: 	// bind the QUALIFY clause, if any
522: 	vector<BoundColumnReferenceInfo> bound_qualify_columns;
523: 	if (statement.qualify) {
524: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
525: 			throw BinderException("Combining QUALIFY with GROUP BY ALL is not supported yet");
526: 		}
527: 		QualifyBinder qualify_binder(*this, context, *result, info);
528: 		ExpressionBinder::QualifyColumnNames(*this, statement.qualify);
529: 		result->qualify = qualify_binder.Bind(statement.qualify);
530: 		if (qualify_binder.HasBoundColumns()) {
531: 			if (qualify_binder.BoundAggregates()) {
532: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
533: 			}
534: 			bound_qualify_columns = qualify_binder.GetBoundColumns();
535: 		}
536: 	}
537: 
538: 	// after that, we bind to the SELECT list
539: 	SelectBinder select_binder(*this, context, *result, info);
540: 
541: 	// if we expand select-list expressions, e.g., via UNNEST, then we need to possibly
542: 	// adjust the column index of the already bound ORDER BY modifiers, and not only set their types
543: 	vector<idx_t> group_by_all_indexes;
544: 	vector<string> new_names;
545: 	vector<LogicalType> internal_sql_types;
546: 
547: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
548: 		bool is_window = statement.select_list[i]->IsWindow();
549: 		idx_t unnest_count = result->unnests.size();
550: 		LogicalType result_type;
551: 		auto expr = select_binder.Bind(statement.select_list[i], &result_type, true);
552: 		bool is_original_column = i < result->column_count;
553: 		bool can_group_by_all =
554: 		    statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES && is_original_column;
555: 		result->bound_column_count++;
556: 
557: 		if (expr->type == ExpressionType::BOUND_EXPANDED) {
558: 			if (!is_original_column) {
559: 				throw BinderException("UNNEST of struct cannot be used in ORDER BY/DISTINCT ON clause");
560: 			}
561: 			if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
562: 				throw BinderException("UNNEST of struct cannot be combined with GROUP BY ALL");
563: 			}
564: 
565: 			auto &expanded = expr->Cast<BoundExpandedExpression>();
566: 			auto &struct_expressions = expanded.expanded_expressions;
567: 			D_ASSERT(!struct_expressions.empty());
568: 
569: 			for (auto &struct_expr : struct_expressions) {
570: 				new_names.push_back(struct_expr->GetName());
571: 				result->types.push_back(struct_expr->return_type);
572: 				internal_sql_types.push_back(struct_expr->return_type);
573: 				result->select_list.push_back(std::move(struct_expr));
574: 			}
575: 			bind_state.AddExpandedColumn(struct_expressions.size());
576: 			continue;
577: 		}
578: 
579: 		if (expr->IsVolatile()) {
580: 			bind_state.SetExpressionIsVolatile(i);
581: 		}
582: 		if (expr->HasSubquery()) {
583: 			bind_state.SetExpressionHasSubquery(i);
584: 		}
585: 		bind_state.AddRegularColumn();
586: 
587: 		if (can_group_by_all && select_binder.HasBoundColumns()) {
588: 			if (select_binder.BoundAggregates()) {
589: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
590: 			}
591: 			if (is_window) {
592: 				throw BinderException("Cannot group on a window clause");
593: 			}
594: 			if (result->unnests.size() > unnest_count) {
595: 				throw BinderException("Cannot group on an UNNEST or UNLIST clause");
596: 			}
597: 			// we are forcing aggregates, and the node has columns bound
598: 			// this entry becomes a group
599: 			group_by_all_indexes.push_back(i);
600: 		}
601: 
602: 		result->select_list.push_back(std::move(expr));
603: 		if (is_original_column) {
604: 			new_names.push_back(std::move(result->names[i]));
605: 			result->types.push_back(result_type);
606: 		}
607: 		internal_sql_types.push_back(result_type);
608: 
609: 		if (can_group_by_all) {
610: 			select_binder.ResetBindings();
611: 		}
612: 	}
613: 
614: 	// push the GROUP BY ALL expressions into the group set
615: 	for (auto &group_by_all_index : group_by_all_indexes) {
616: 		auto &expr = result->select_list[group_by_all_index];
617: 		auto group_ref = make_uniq<BoundColumnRefExpression>(
618: 		    expr->return_type, ColumnBinding(result->group_index, result->groups.group_expressions.size()));
619: 		result->groups.group_expressions.push_back(std::move(expr));
620: 		expr = std::move(group_ref);
621: 	}
622: 	result->column_count = new_names.size();
623: 	result->names = std::move(new_names);
624: 	result->need_prune = result->select_list.size() > result->column_count;
625: 
626: 	// in the normal select binder, we bind columns as if there is no aggregation
627: 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
628: 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
629: 	// we choose the former one [CONTROVERSIAL: this is the PostgreSQL behavior]
630: 	if (!result->groups.group_expressions.empty() || !result->aggregates.empty() || statement.having ||
631: 	    !result->groups.grouping_sets.empty()) {
632: 		if (statement.aggregate_handling == AggregateHandling::NO_AGGREGATES_ALLOWED) {
633: 			throw BinderException("Aggregates cannot be present in a Project relation!");
634: 		} else {
635: 			vector<BoundColumnReferenceInfo> bound_columns;
636: 			if (select_binder.HasBoundColumns()) {
637: 				bound_columns = select_binder.GetBoundColumns();
638: 			}
639: 			for (auto &bound_qualify_col : bound_qualify_columns) {
640: 				bound_columns.push_back(bound_qualify_col);
641: 			}
642: 			if (!bound_columns.empty()) {
643: 				string error;
644: 				error = "column \"%s\" must appear in the GROUP BY clause or must be part of an aggregate function.";
645: 				if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
646: 					error += "\nGROUP BY ALL will only group entries in the SELECT list. Add it to the SELECT list or "
647: 					         "GROUP BY this entry explicitly.";
648: 					throw BinderException(bound_columns[0].query_location, error, bound_columns[0].name);
649: 				} else {
650: 					error +=
651: 					    "\nEither add it to the GROUP BY list, or use \"ANY_VALUE(%s)\" if the exact value of \"%s\" "
652: 					    "is not important.";
653: 					throw BinderException(bound_columns[0].query_location, error, bound_columns[0].name,
654: 					                      bound_columns[0].name, bound_columns[0].name);
655: 				}
656: 			}
657: 		}
658: 	}
659: 
660: 	// QUALIFY clause requires at least one window function to be specified in at least one of the SELECT column list or
661: 	// the filter predicate of the QUALIFY clause
662: 	if (statement.qualify && result->windows.empty()) {
663: 		throw BinderException("at least one window function must appear in the SELECT column or QUALIFY clause");
664: 	}
665: 
666: 	// now that the SELECT list is bound, we set the types of DISTINCT/ORDER BY expressions
667: 	BindModifiers(*result, result->projection_index, result->names, internal_sql_types, bind_state);
668: 	return std::move(result);
669: }
670: 
671: } // namespace duckdb
[end of src/planner/binder/query_node/bind_select_node.cpp]
[start of src/planner/expression_binder/order_binder.cpp]
1: #include "duckdb/planner/expression_binder/order_binder.hpp"
2: 
3: #include "duckdb/parser/expression/collate_expression.hpp"
4: #include "duckdb/parser/expression/columnref_expression.hpp"
5: #include "duckdb/parser/expression/constant_expression.hpp"
6: #include "duckdb/parser/expression/parameter_expression.hpp"
7: #include "duckdb/parser/expression/positional_reference_expression.hpp"
8: #include "duckdb/parser/expression/star_expression.hpp"
9: #include "duckdb/parser/query_node/select_node.hpp"
10: #include "duckdb/planner/binder.hpp"
11: #include "duckdb/planner/expression/bound_constant_expression.hpp"
12: #include "duckdb/planner/expression/bound_parameter_expression.hpp"
13: #include "duckdb/planner/expression_binder.hpp"
14: #include "duckdb/planner/expression_binder/select_bind_state.hpp"
15: #include "duckdb/main/client_config.hpp"
16: #include "duckdb/common/pair.hpp"
17: 
18: namespace duckdb {
19: 
20: OrderBinder::OrderBinder(vector<reference<Binder>> binders, SelectBindState &bind_state)
21:     : binders(std::move(binders)), extra_list(nullptr), bind_state(bind_state) {
22: }
23: OrderBinder::OrderBinder(vector<reference<Binder>> binders, SelectNode &node, SelectBindState &bind_state)
24:     : binders(std::move(binders)), bind_state(bind_state) {
25: 	this->extra_list = &node.select_list;
26: }
27: 
28: unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &expr, const idx_t index) {
29: 	string alias;
30: 	if (extra_list && index < extra_list->size()) {
31: 		alias = extra_list->at(index)->ToString();
32: 	} else {
33: 		if (!expr.alias.empty()) {
34: 			alias = expr.alias;
35: 		}
36: 	}
37: 	auto result = make_uniq<BoundConstantExpression>(Value::UBIGINT(index));
38: 	result->alias = std::move(alias);
39: 	result->query_location = expr.query_location;
40: 	return std::move(result);
41: }
42: 
43: unique_ptr<Expression> OrderBinder::CreateExtraReference(unique_ptr<ParsedExpression> expr) {
44: 	if (!extra_list) {
45: 		throw InternalException("CreateExtraReference called without extra_list");
46: 	}
47: 	bind_state.projection_map[*expr] = extra_list->size();
48: 	auto result = CreateProjectionReference(*expr, extra_list->size());
49: 	extra_list->push_back(std::move(expr));
50: 	return result;
51: }
52: 
53: optional_idx OrderBinder::TryGetProjectionReference(ParsedExpression &expr) const {
54: 	switch (expr.expression_class) {
55: 	case ExpressionClass::CONSTANT: {
56: 		auto &constant = expr.Cast<ConstantExpression>();
57: 		// ORDER BY a constant
58: 		if (!constant.value.type().IsIntegral()) {
59: 			// non-integral expression
60: 			// ORDER BY <constant> has no effect
61: 			// this is disabled by default (matching Postgres) - but we can control this with a setting
62: 			auto &config = ClientConfig::GetConfig(binders[0].get().context);
63: 			if (!config.order_by_non_integer_literal) {
64: 				throw BinderException(expr, "ORDER BY non-integer literal has no effect.\n* SET "
65: 				                            "order_by_non_integer_literal=true to allow this behavior.");
66: 			}
67: 			break;
68: 		}
69: 		// INTEGER constant: we use the integer as an index into the select list (e.g. ORDER BY 1)
70: 		auto order_value = constant.value.GetValue<int64_t>();
71: 		return static_cast<idx_t>(order_value <= 0 ? NumericLimits<int64_t>::Maximum() : order_value - 1);
72: 	}
73: 	case ExpressionClass::COLUMN_REF: {
74: 		auto &colref = expr.Cast<ColumnRefExpression>();
75: 		// if there is an explicit table name we can't bind to an alias
76: 		if (colref.IsQualified()) {
77: 			break;
78: 		}
79: 		// check the alias list
80: 		auto entry = bind_state.alias_map.find(colref.column_names[0]);
81: 		if (entry == bind_state.alias_map.end()) {
82: 			break;
83: 		}
84: 		// this is an alias - return the index
85: 		return entry->second;
86: 	}
87: 	case ExpressionClass::POSITIONAL_REFERENCE: {
88: 		auto &posref = expr.Cast<PositionalReferenceExpression>();
89: 		return posref.index - 1;
90: 	}
91: 	default:
92: 		break;
93: 	}
94: 	return optional_idx();
95: }
96: 
97: unique_ptr<Expression> OrderBinder::BindConstant(ParsedExpression &expr) {
98: 	auto index = TryGetProjectionReference(expr);
99: 	if (!index.IsValid()) {
100: 		return nullptr;
101: 	}
102: 	child_list_t<Value> values;
103: 	values.push_back(make_pair("index", Value::UBIGINT(index.GetIndex())));
104: 	auto result = make_uniq<BoundConstantExpression>(Value::STRUCT(std::move(values)));
105: 	result->alias = std::move(expr.alias);
106: 	result->query_location = expr.query_location;
107: 	return std::move(result);
108: }
109: 
110: unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {
111: 	// in the ORDER BY clause we do not bind children
112: 	// we bind ONLY to the select list
113: 	// if there is no matching entry in the SELECT list already, we add the expression to the SELECT list and refer the
114: 	// new expression the new entry will then be bound later during the binding of the SELECT list we also don't do type
115: 	// resolution here: this only happens after the SELECT list has been bound
116: 	switch (expr->expression_class) {
117: 	case ExpressionClass::CONSTANT: {
118: 		// ORDER BY constant
119: 		// is the ORDER BY expression a constant integer? (e.g. ORDER BY 1)
120: 		return BindConstant(*expr);
121: 	}
122: 	case ExpressionClass::COLUMN_REF:
123: 	case ExpressionClass::POSITIONAL_REFERENCE: {
124: 		// COLUMN REF expression
125: 		// check if we can bind it to an alias in the select list
126: 		auto index = TryGetProjectionReference(*expr);
127: 		if (index.IsValid()) {
128: 			return CreateProjectionReference(*expr, index.GetIndex());
129: 		}
130: 		break;
131: 	}
132: 	case ExpressionClass::PARAMETER: {
133: 		throw ParameterNotAllowedException("Parameter not supported in ORDER BY clause");
134: 	}
135: 	case ExpressionClass::COLLATE: {
136: 		auto &collation = expr->Cast<CollateExpression>();
137: 		auto collation_index = TryGetProjectionReference(*collation.child);
138: 		if (collation_index.IsValid()) {
139: 			child_list_t<Value> values;
140: 			values.push_back(make_pair("index", Value::UBIGINT(collation_index.GetIndex())));
141: 			values.push_back(make_pair("collation", Value(std::move(collation.collation))));
142: 			return make_uniq<BoundConstantExpression>(Value::STRUCT(std::move(values)));
143: 		}
144: 		break;
145: 	}
146: 	default:
147: 		break;
148: 	}
149: 	// general case
150: 	// first bind the table names of this entry
151: 	for (auto &binder : binders) {
152: 		ExpressionBinder::QualifyColumnNames(binder.get(), expr);
153: 	}
154: 	// first check if the ORDER BY clause already points to an entry in the projection list
155: 	auto entry = bind_state.projection_map.find(*expr);
156: 	if (entry != bind_state.projection_map.end()) {
157: 		if (entry->second == DConstants::INVALID_INDEX) {
158: 			throw BinderException("Ambiguous reference to column");
159: 		}
160: 		// there is a matching entry in the projection list
161: 		// just point to that entry
162: 		return CreateProjectionReference(*expr, entry->second);
163: 	}
164: 	if (!extra_list) {
165: 		// no extra list specified: we cannot push an extra ORDER BY clause
166: 		throw BinderException("Could not ORDER BY column \"%s\": add the expression/function to every SELECT, or move "
167: 		                      "the UNION into a FROM clause.",
168: 		                      expr->ToString());
169: 	}
170: 	// otherwise we need to push the ORDER BY entry into the select list
171: 	return CreateExtraReference(std::move(expr));
172: }
173: 
174: } // namespace duckdb
[end of src/planner/expression_binder/order_binder.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: