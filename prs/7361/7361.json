{
  "repo": "duckdb/duckdb",
  "pull_number": 7361,
  "instance_id": "duckdb__duckdb-7361",
  "issue_numbers": [
    "7260",
    "7260"
  ],
  "base_commit": "229e3231edeb83e178af2e2dca867114376efd79",
  "patch": "diff --git a/tools/juliapkg/src/data_chunk.jl b/tools/juliapkg/src/data_chunk.jl\nindex 7ed25de45349..34506a678522 100644\n--- a/tools/juliapkg/src/data_chunk.jl\n+++ b/tools/juliapkg/src/data_chunk.jl\n@@ -60,3 +60,7 @@ function _destroy_data_chunk(chunk::DataChunk)\n     end\n     return chunk.handle = C_NULL\n end\n+\n+function destroy_data_chunk(chunk::DataChunk)\n+    return _destroy_data_chunk(chunk)\n+end\ndiff --git a/tools/juliapkg/src/result.jl b/tools/juliapkg/src/result.jl\nindex 43c8eec46a54..20187abe167f 100644\n--- a/tools/juliapkg/src/result.jl\n+++ b/tools/juliapkg/src/result.jl\n@@ -816,6 +816,8 @@ A `DuckDB.Stmt` object can be closed (resources freed) using `DBInterface.close!\n DBInterface.prepare(con::Connection, sql::AbstractString, result_type::Type) = Stmt(con, sql, result_type)\n DBInterface.prepare(con::Connection, sql::AbstractString) = DBInterface.prepare(con, sql, MaterializedResult)\n DBInterface.prepare(db::DB, sql::AbstractString) = DBInterface.prepare(db.main_connection, sql)\n+DBInterface.prepare(db::DB, sql::AbstractString, result_type::Type) =\n+    DBInterface.prepare(db.main_connection, sql, result_type)\n \n \"\"\"\n     DBInterface.execute(db::DuckDB.DB, sql::String, [params])\n",
  "test_patch": "diff --git a/tools/juliapkg/test/resources/types_list.parquet b/tools/juliapkg/test/resources/types_list.parquet\nnew file mode 100644\nindex 000000000000..4a7fc4b632b5\nBinary files /dev/null and b/tools/juliapkg/test/resources/types_list.parquet differ\ndiff --git a/tools/juliapkg/test/resources/types_map.parquet b/tools/juliapkg/test/resources/types_map.parquet\nnew file mode 100644\nindex 000000000000..102404c68aff\nBinary files /dev/null and b/tools/juliapkg/test/resources/types_map.parquet differ\ndiff --git a/tools/juliapkg/test/resources/types_nested.parquet b/tools/juliapkg/test/resources/types_nested.parquet\nnew file mode 100644\nindex 000000000000..3e74db2f0be9\nBinary files /dev/null and b/tools/juliapkg/test/resources/types_nested.parquet differ\ndiff --git a/tools/juliapkg/test/test_stream_data_chunk.jl b/tools/juliapkg/test/test_stream_data_chunk.jl\nindex 534d4419a8bf..f08530ebb6a5 100644\n--- a/tools/juliapkg/test/test_stream_data_chunk.jl\n+++ b/tools/juliapkg/test/test_stream_data_chunk.jl\n@@ -30,10 +30,12 @@\n                 sum += data[i]\n             end\n             total_count += count\n+            DuckDB.destroy_data_chunk(chunk)\n         end\n         @test sum == 49995000\n         @test total_count == 10000\n     end\n+    GC.gc(true)\n end\n \n @testset \"Test giant streaming result\" begin\n@@ -48,7 +50,47 @@ end\n     for i in 1:3\n         chunk = DuckDB.nextDataChunk(res)\n         @test chunk !== missing\n+        DuckDB.destroy_data_chunk(chunk)\n     end\n     DBInterface.close!(res)\n     DBInterface.close!(con)\n+    GC.gc(true)\n+end\n+\n+@testset \"Test streaming data chunk destruction\" begin\n+    paths = [\"types_map.parquet\", \"types_list.parquet\", \"types_nested.parquet\"]\n+    for path in paths\n+        # DuckDB \"in memory database\"\n+        connection = DBInterface.connect(DuckDB.DB)\n+        statement = DuckDB.Stmt(connection, \"SELECT * FROM read_parquet(?, file_row_number=1)\", DuckDB.StreamResult)\n+        result = DBInterface.execute(statement, [joinpath(\"test\", \"resources\", path)])\n+        num_columns = length(result.types)\n+\n+        while true\n+            chunk = DuckDB.nextDataChunk(result)\n+            chunk === missing && break # are we done?\n+\n+            num_rows = DuckDB.get_size(chunk) # number of rows in the retrieved chunk\n+\n+            row_ids = DuckDB.get_array(chunk, num_columns, Int64)\n+            # move over each column, last column are the row_ids\n+            for column_idx in 1:(num_columns - 1)\n+                column_name::Symbol = result.names[column_idx]\n+\n+                # Convert from the DuckDB internal types into Julia types\n+                duckdb_logical_type = DuckDB.LogicalType(DuckDB.duckdb_column_logical_type(result.handle, column_idx))\n+                duckdb_conversion_state = DuckDB.ColumnConversionData([chunk], column_idx, duckdb_logical_type, nothing)\n+                duckdb_data = DuckDB.convert_column(duckdb_conversion_state)\n+\n+                for i in 1:num_rows\n+                    row_id = row_ids[i] + 1 # julia indices start at 1\n+                    value = duckdb_data[i]\n+                    @test value !== missing\n+                end\n+            end\n+            DuckDB.destroy_data_chunk(chunk)\n+        end\n+        close(connection)\n+    end\n+    GC.gc(true)\n end\n",
  "problem_statement": "[julia] compile error when using DBInterface.prepare with StreamResult\n### What happens?\n\nThere is a small compile error in the Julia package when trying to pass StreamResult to DBInterface.prepare, e.g. \r\n\r\n```\r\nconnection = DBInterface.connect(DuckDB.DB)\r\nstatement = DBInterface.prepare(connection, \"SELECT 1\" ) # this works\r\nstatement = DBInterface.prepare(connection, \"SELECT 1\", DuckDB.StreamResult) # error\r\n\r\nERROR: MethodError: no method matching prepare(::DuckDB.DB, ::String, ::Type{DuckDB.StreamResult})\r\nClosest candidates are:\r\n  prepare(::DuckDB.DB, ::AbstractString) at ~/.julia/packages/DuckDB/PMwHV/src/result.jl:818\r\n  prepare(::DuckDB.Connection, ::AbstractString, ::Type) at ~/.julia/packages/DuckDB/PMwHV/src/result.jl:816\r\n  prepare(::Function, ::AbstractString) at ~/.julia/packages/DBInterface/1Gmxx/src/DBInterface.jl:60\r\n  ...\r\n\r\n\r\n# This works as well\r\nstatement = DuckDB.Stmt(connection, \"SELECT 1\", DuckDB.StreamResult)\r\n\r\n``` \r\n\r\nAdmittedly I haven't validated the latest master for the julia package, the issue is present in v0.7.1\n\n### To Reproduce\n\nSee description above\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n0.7.1\n\n### DuckDB Client:\n\nJulia \n\n### Full Name:\n\nDean De Leo\n\n### Affiliation:\n\nRelationalAI\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n[julia] compile error when using DBInterface.prepare with StreamResult\n### What happens?\n\nThere is a small compile error in the Julia package when trying to pass StreamResult to DBInterface.prepare, e.g. \r\n\r\n```\r\nconnection = DBInterface.connect(DuckDB.DB)\r\nstatement = DBInterface.prepare(connection, \"SELECT 1\" ) # this works\r\nstatement = DBInterface.prepare(connection, \"SELECT 1\", DuckDB.StreamResult) # error\r\n\r\nERROR: MethodError: no method matching prepare(::DuckDB.DB, ::String, ::Type{DuckDB.StreamResult})\r\nClosest candidates are:\r\n  prepare(::DuckDB.DB, ::AbstractString) at ~/.julia/packages/DuckDB/PMwHV/src/result.jl:818\r\n  prepare(::DuckDB.Connection, ::AbstractString, ::Type) at ~/.julia/packages/DuckDB/PMwHV/src/result.jl:816\r\n  prepare(::Function, ::AbstractString) at ~/.julia/packages/DBInterface/1Gmxx/src/DBInterface.jl:60\r\n  ...\r\n\r\n\r\n# This works as well\r\nstatement = DuckDB.Stmt(connection, \"SELECT 1\", DuckDB.StreamResult)\r\n\r\n``` \r\n\r\nAdmittedly I haven't validated the latest master for the julia package, the issue is present in v0.7.1\n\n### To Reproduce\n\nSee description above\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n0.7.1\n\n### DuckDB Client:\n\nJulia \n\n### Full Name:\n\nDean De Leo\n\n### Affiliation:\n\nRelationalAI\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Thanks for the report! It seems like an overload is indeed missing. Does this work?\r\n\r\n```julia\r\nstatement = DBInterface.prepare(connection.main_connection, \"SELECT 1\", DuckDB.StreamResult)\r\n```\nyes, that works! thx for the quick reply!\nThanks for the report! It seems like an overload is indeed missing. Does this work?\r\n\r\n```julia\r\nstatement = DBInterface.prepare(connection.main_connection, \"SELECT 1\", DuckDB.StreamResult)\r\n```\nyes, that works! thx for the quick reply!",
  "created_at": "2023-05-04T09:04:36Z"
}