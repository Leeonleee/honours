{
  "repo": "duckdb/duckdb",
  "pull_number": 13896,
  "instance_id": "duckdb__duckdb-13896",
  "issue_numbers": [
    "13836"
  ],
  "base_commit": "bc7683e100867fae06c1f65e055df403c2ee25cf",
  "patch": "diff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 9f3c92a0f91c..74b22e699856 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -1945,6 +1945,10 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const py::object &dat\n \tconfig.AddExtensionOption(\"python_enable_replacements\",\n \t                          \"Whether variables visible to the current stack should be used for replacement scans.\",\n \t                          LogicalType::BOOLEAN, Value::BOOLEAN(true));\n+\tconfig.AddExtensionOption(\n+\t    \"python_scan_all_frames\",\n+\t    \"If set, restores the old behavior of scanning all preceding frames to locate the referenced variable.\",\n+\t    LogicalType::BOOLEAN, Value::BOOLEAN(false));\n \tif (!DuckDBPyConnection::IsJupyter()) {\n \t\tconfig_dict[\"duckdb_api\"] = Value(\"python\");\n \t} else {\ndiff --git a/tools/pythonpkg/src/python_replacement_scan.cpp b/tools/pythonpkg/src/python_replacement_scan.cpp\nindex bc52bd4f4809..8d1610534789 100644\n--- a/tools/pythonpkg/src/python_replacement_scan.cpp\n+++ b/tools/pythonpkg/src/python_replacement_scan.cpp\n@@ -194,25 +194,38 @@ static unique_ptr<TableRef> ReplaceInternal(ClientContext &context, const string\n \t\treturn nullptr;\n \t}\n \n+\tlookup_result = context.TryGetCurrentSetting(\"python_scan_all_frames\", result);\n+\tD_ASSERT((bool)lookup_result);\n+\tauto scan_all_frames = result.GetValue<bool>();\n+\n \tpy::gil_scoped_acquire acquire;\n-\tauto current_frame = py::module::import(\"inspect\").attr(\"currentframe\")();\n-\n-\tauto local_dict = py::cast<py::dict>(current_frame.attr(\"f_locals\"));\n-\t// search local dictionary\n-\tif (local_dict) {\n-\t\tauto result = TryReplacement(local_dict, table_name, context, current_frame);\n-\t\tif (result) {\n-\t\t\treturn result;\n+\tpy::object current_frame = py::module::import(\"inspect\").attr(\"currentframe\")();\n+\n+\tbool has_locals = false;\n+\tbool has_globals = false;\n+\tdo {\n+\t\tpy::object local_dict_p = current_frame.attr(\"f_locals\");\n+\t\thas_locals = !py::none().is(local_dict_p);\n+\t\tif (has_locals) {\n+\t\t\t// search local dictionary\n+\t\t\tauto local_dict = py::cast<py::dict>(local_dict_p);\n+\t\t\tauto result = TryReplacement(local_dict, table_name, context, current_frame);\n+\t\t\tif (result) {\n+\t\t\t\treturn result;\n+\t\t\t}\n \t\t}\n-\t}\n-\t// search global dictionary\n-\tauto global_dict = py::cast<py::dict>(current_frame.attr(\"f_globals\"));\n-\tif (global_dict) {\n-\t\tauto result = TryReplacement(global_dict, table_name, context, current_frame);\n-\t\tif (result) {\n-\t\t\treturn result;\n+\t\tpy::object global_dict_p = current_frame.attr(\"f_globals\");\n+\t\thas_globals = !py::none().is(global_dict_p);\n+\t\tif (has_globals) {\n+\t\t\tauto global_dict = py::cast<py::dict>(global_dict_p);\n+\t\t\t// search global dictionary\n+\t\t\tauto result = TryReplacement(global_dict, table_name, context, current_frame);\n+\t\t\tif (result) {\n+\t\t\t\treturn result;\n+\t\t\t}\n \t\t}\n-\t}\n+\t\tcurrent_frame = current_frame.attr(\"f_back\");\n+\t} while (scan_all_frames && (has_locals || has_globals));\n \treturn nullptr;\n }\n \n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_replacement_scan.py b/tools/pythonpkg/tests/fast/test_replacement_scan.py\nindex 6a837b363e90..5255c8cac902 100644\n--- a/tools/pythonpkg/tests/fast/test_replacement_scan.py\n+++ b/tools/pythonpkg/tests/fast/test_replacement_scan.py\n@@ -121,10 +121,6 @@ def inner_func(duckdb_cursor):\n                 # We set the depth to look for local variables to 0 so it's never found\n                 duckdb_cursor.sql(\"select * from df\")\n             duckdb_cursor.execute(\"set python_enable_replacements=true\")\n-            with pytest.raises(duckdb.CatalogException, match='Table with name df does not exist'):\n-                # We set the depth to look for local variables to 1 so it's still not found because it wasn't defined in this function\n-                duckdb_cursor.sql(\"select * from df\")\n-            duckdb_cursor.execute(\"set python_enable_replacements=true\")\n             with pytest.raises(duckdb.CatalogException, match='Table with name df does not exist'):\n                 # Here it's still not found, because it's not visible to this frame\n                 duckdb_cursor.sql(\"select * from df\")\n@@ -138,6 +134,23 @@ def inner_func(duckdb_cursor):\n \n         inner_func(duckdb_cursor)\n \n+    def test_scan_local_unlimited(self, duckdb_cursor):\n+        df = pd.DataFrame({'a': [1, 2, 3]})\n+\n+        def inner_func(duckdb_cursor):\n+            duckdb_cursor.execute(\"set python_enable_replacements=true\")\n+            with pytest.raises(duckdb.CatalogException, match='Table with name df does not exist'):\n+                # We set the depth to look for local variables to 1 so it's still not found because it wasn't defined in this function\n+                duckdb_cursor.sql(\"select * from df\")\n+            duckdb_cursor.execute(\"set python_scan_all_frames=true\")\n+            # Now we can find 'df' because we also scan the previous frame(s)\n+            rel = duckdb_cursor.sql(\"select * from df\")\n+\n+            res = rel.fetchall()\n+            assert res == [(1,), (2,), (3,)]\n+\n+        inner_func(duckdb_cursor)\n+\n     def test_replacement_scan_relapi(self):\n         con = duckdb.connect()\n         pyrel1 = con.query('from (values (42), (84), (120)) t(i)')\n",
  "problem_statement": "Eatoni v1.1.0 does not work with pandas API as it did earlier\n### What happens?\r\n\r\nDuckdb v1.1.0 introduces a new error:\r\n```\r\nCatalogException: Catalog Error: Table with name df does not exist!\r\n```\r\n\r\n### To Reproduce\r\n\r\nWe have a `utils.duckdb.py` the contents of which are:\r\n```python\r\nimport duckdb\r\nimport time\r\nimport pandas\r\n\r\nimport logging, os\r\n_logs = logging.getLogger(os.path.relpath(__file__, start=os.getcwd()))\r\n\r\nwith duckdb.connect(database=':memory:') as con:\r\n    output = con.sql(\r\n        f\"\"\"\r\n        INSTALL httpfs;\r\n        LOAD httpfs;\r\n        CREATE PERSISTENT SECRET IF NOT EXISTS (\r\n            TYPE S3,\r\n            PROVIDER CREDENTIAL_CHAIN\r\n        );\r\n    \"\"\").fetchall()\r\n    _logs.info(f'Loaded extensions and secrets {output}')\r\n\r\n\r\ndef connect_db(\r\n    db: str=':memory:',\r\n    max_retries: int=20,\r\n    max_retry_duration: int=300,\r\n    start_retry_time: int=10,\r\n    read_only: bool=False,\r\n    temp_directory: str='./'\r\n) -> duckdb.DuckDBPyConnection:\r\n    \"\"\"\r\n    Connects to a duckDB database and returns the connection object.\r\n\r\n    Args:\r\n        db (str, optional): The path to the database file. Defaults to ':memory:', in-memory database.\r\n        max_retries (int, optional): The maximum number of connection retries. Defaults to 20.\r\n        max_retry_duration (int, optional): The maximum duration (in seconds) for connection retries. Defaults to 300.\r\n        start_retry_time (int, optional): The initial wait time (in seconds) between connection retries. Defaults to 10.\r\n        read_only (bool, optional): Specifies if the connection should be read-only. Defaults to `False`\r\n        temp_directory (str, optional): The temporary directory path. Defaults to './', the current directory\r\n\r\n    Returns:\r\n        duckdb.Connection: The connection object to the duckDB database.\r\n\r\n    Raises:\r\n        Exception: If an error occurs during the connection process.\r\n\r\n    NOTE:\r\n        If connection fails, ensure that we have permission to rwx on the db file using: sudo chmod -R a+rwx ~/db_folder\r\n\r\n    Example:\r\n        ```python\r\n        with connect_db(db=':memory:', read_only=False) as con:\r\n            con.execute(\"CREATE TABLE test (a INTEGER)\")\r\n        ```\r\n    \"\"\"\r\n    con = None\r\n    retries = 0\r\n    successful = False\r\n\r\n    if db == ':memory:':\r\n        read_only = False\r\n\r\n    while not successful and retries <= max_retries:\r\n        try:\r\n            con = duckdb.connect(database=db, read_only=read_only)\r\n            con.execute(\r\n                f\"\"\"\r\n                SET old_implicit_casting=true;\r\n                SET http_keep_alive=false;\r\n                SET temp_directory = \"{temp_directory}\";\"\"\"\r\n            )\r\n            successful = True\r\n            _logs.info(f'duckDB connection successful with {db}, read_only={read_only}')\r\n        except Exception as e:\r\n            if isinstance(e, duckdb.IOException):\r\n                _logs.warning(f\"Database is busy. We'll wait {db}: {e}\")\r\n                time.sleep(min(start_retry_time * retries, max_retry_duration))\r\n            else:\r\n                # Raise the original exception\r\n                raise e\r\n        finally:\r\n            retries += 1\r\n    if con is None:\r\n        _logs.error(f'Failed to establish connection with {db}')\r\n    return con\r\n\r\n\r\ndef fetch_query(\r\n    query: str,\r\n    db: str=':memory:',\r\n    read_only: bool=True,\r\n    temp_directory: str='./'\r\n) -> pandas.DataFrame:\r\n    \"\"\"Executes the given query on the specified DuckDB database and returns the result as a pandas DataFrame.\r\n\r\n    Uses [connect_db][utils.duckdb.connect_db] for connection\r\n\r\n    Parameters:\r\n        query (str): The SQL query to execute.\r\n        db (str, optional): The path to the DuckDB database file. Defaults to ':memory:'.\r\n        read_only (bool, optional): Specifies whether the database should be opened in read-only mode. Defaults to `True` except when `db = ':memory:'`\r\n        temp_directory (str, optional): The path to the directory where temporary files will be stored. Defaults to './'.\r\n\r\n    Returns:\r\n        pandas.DataFrame: The result of the query as a pandas DataFrame.\r\n\r\n    Example:\r\n        ```python\r\n        df = fetch_query(\r\n            query = \"SELECT * FROM test\",\r\n            db = ':memory:',\r\n            read_only = False\r\n        )\r\n        ```\r\n    \"\"\"\r\n    with connect_db(\r\n        db = db,\r\n        read_only = read_only,\r\n        temp_directory = temp_directory\r\n    ) as con:\r\n        return con.execute(query).fetchdf()\r\n```\r\n\r\n\r\nThis works for all duckdb >= 0:\r\n```python\r\nimport duckdb\r\nimport pandas\r\nprint(duckdb.sql(\"SELECT version()\").df())\r\ndf = pandas.DataFrame.from_dict({'a': [42]})\r\nresults = duckdb.sql(\"SELECT * FROM df\").df()\r\nprint(results)\r\n```\r\n\r\nThis works for all duckdb v<=1.0.0 but not for v==1.1.0:\r\n```python\r\nfrom utils.duckdb import *\r\nimport pandas\r\nprint(duckdb.sql(\"SELECT version()\").df())\r\ndf = pandas.DataFrame.from_dict({'a': [42]})\r\nresults = fetch_query(\"SELECT * FROM df\")\r\nprint(results)\r\n```\r\nThe error thrown in v1.1.0 is:\r\n```console\r\n---------------------------------------------------------------------------\r\nCatalogException                          Traceback (most recent call last)\r\nCell In[8], line 12\r\n      8 df = pandas.DataFrame.from_dict({'a': [42]})\r\n     10 # query the Pandas DataFrame \"df\"\r\n     11 # Note: duckdb.sql connects to the default in-memory database connection\r\n---> 12 results = fetch_query(\"SELECT * FROM df\")\r\n     13 print(results)\r\n\r\nFile ~/utils/duckdb.py:138, in fetch_query(query, db, read_only, temp_directory)\r\n    110 def fetch_query(\r\n    111     query: str,\r\n    112     db: str=':memory:',\r\n    113     read_only: bool=True,\r\n    114     temp_directory: str='./'\r\n    115 ) -> pandas.DataFrame:\r\n    116     \"\"\"Executes the given query on the specified DuckDB database and returns the result as a pandas DataFrame.\r\n    117 \r\n    118     Uses [connect_db][utils.duckdb.connect_db] for connection\r\n   (...)\r\n    136         ```\r\n    137     \"\"\"\r\n--> 138     with connect_db(\r\n    139         db = db,\r\n    140         read_only = read_only,\r\n...\r\n\r\nCatalogException: Catalog Error: Table with name df does not exist!\r\nDid you mean \"pg_depend\"?\r\nLINE 1: SELECT * FROM df\r\n                      ^\r\n```\r\n\r\nHowever it works if I replace the line:\r\n```python\r\nfrom utils.duckdb import *\r\n```\r\nwith the functions definitions in `utils.duckdb.py`. Why does this happen in the new version?\r\n\r\n### OS:\r\n\r\nx86\r\n\r\n### DuckDB Version:\r\n\r\n1.1.0\r\n\r\n### DuckDB Client:\r\n\r\nPython 3.12\r\n\r\n### Full Name:\r\n\r\nRajiv Patki\r\n\r\n### Affiliation:\r\n\r\nJodaro\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [x] Yes, I have\n",
  "hints_text": "This is expected, we used to scan the entire frame lineage for the `df` variable, but we switched it to behave like Python itself and only scan the current frame.\r\n\r\nYou would need to either provide the `df` to the `fetch_query` scope or register `df` to the duckdb connection before querying\r\n\r\nSee: <https://github.com/duckdb/duckdb/pull/12425>\nApologies but this does not work. Method 1 below works but Method 2 still throws error even if the dataframe is passed as an argument to the function:\r\n```console\r\nCatalogException: Catalog Error: Table with name df does not exist!\r\n```\r\nin \r\n```python\r\nfrom utils.duckdb import *\r\nimport pandas\r\nprint(duckdb.sql(\"SELECT version() as duckdb_version\"))\r\ndf = pandas.DataFrame.from_dict({'a': [42]})\r\n\r\n# Method 1\r\nwith connect_db() as con:\r\n    print(con.sql(\"SELECT * FROM df\").df())\r\n\r\n# Method 2\r\nprint(fetch_query(\"SELECT * FROM df\", pandas_df = [df], read_only = False))\r\n```\nyou are using `select * from df`, it's not called `df`, it's called `pandas_df`",
  "created_at": "2024-09-12T09:29:43Z"
}