{
  "repo": "duckdb/duckdb",
  "pull_number": 15277,
  "instance_id": "duckdb__duckdb-15277",
  "issue_numbers": [
    "15267"
  ],
  "base_commit": "9489881191eba8af452b94120d542c09b3ffd0c1",
  "patch": "diff --git a/tools/pythonpkg/src/include/duckdb_python/expression/pyexpression.hpp b/tools/pythonpkg/src/include/duckdb_python/expression/pyexpression.hpp\nindex c7b9387e96a8..b89578af25bc 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/expression/pyexpression.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/expression/pyexpression.hpp\n@@ -1,7 +1,7 @@\n //===----------------------------------------------------------------------===//\n //                         DuckDB\n //\n-// duckdb_python/pyrelation.hpp\n+// duckdb_python/expression/pyexpression.hpp\n //\n //\n //===----------------------------------------------------------------------===//\ndiff --git a/tools/pythonpkg/src/pyrelation.cpp b/tools/pythonpkg/src/pyrelation.cpp\nindex 723d6a9274ae..cb4b8032e02d 100644\n--- a/tools/pythonpkg/src/pyrelation.cpp\n+++ b/tools/pythonpkg/src/pyrelation.cpp\n@@ -1023,13 +1023,27 @@ unique_ptr<DuckDBPyRelation> DuckDBPyRelation::GetAttribute(const string &name)\n \t\tthrow py::attribute_error(\n \t\t    StringUtil::Format(\"This relation does not contain a column by the name of '%s'\", name));\n \t}\n+\tvector<string> column_names;\n \tif (names.size() == 1 && ContainsStructFieldByName(types[0], name)) {\n-\t\treturn make_uniq<DuckDBPyRelation>(rel->Project({StringUtil::Format(\"%s.%s\", names[0], name)}));\n+\t\t// e.g 'rel['my_struct']['my_field']:\n+\t\t// first 'my_struct' is selected by the bottom condition\n+\t\t// then 'my_field' is accessed on the result of this\n+\t\tcolumn_names.push_back(names[0]);\n+\t\tcolumn_names.push_back(name);\n+\t} else if (ContainsColumnByName(name)) {\n+\t\tcolumn_names.push_back(name);\n \t}\n-\tif (ContainsColumnByName(name)) {\n-\t\treturn make_uniq<DuckDBPyRelation>(rel->Project({StringUtil::Format(\"\\\"%s\\\"\", name)}));\n+\n+\tif (column_names.empty()) {\n+\t\tthrow py::attribute_error(\n+\t\t    StringUtil::Format(\"This relation does not contain a column by the name of '%s'\", name));\n \t}\n-\tthrow py::attribute_error(StringUtil::Format(\"This relation does not contain a column by the name of '%s'\", name));\n+\n+\tvector<unique_ptr<ParsedExpression>> expressions;\n+\texpressions.push_back(std::move(make_uniq<ColumnRefExpression>(column_names)));\n+\tvector<string> aliases;\n+\taliases.push_back(name);\n+\treturn make_uniq<DuckDBPyRelation>(rel->Project(std::move(expressions), aliases));\n }\n \n unique_ptr<DuckDBPyRelation> DuckDBPyRelation::Union(DuckDBPyRelation *other) {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_attribute_getter.py b/tools/pythonpkg/tests/fast/api/test_attribute_getter.py\nindex 795e26e9c834..958e8892c512 100644\n--- a/tools/pythonpkg/tests/fast/api/test_attribute_getter.py\n+++ b/tools/pythonpkg/tests/fast/api/test_attribute_getter.py\n@@ -57,3 +57,7 @@ def test_getattr_struct(self, duckdb_cursor):\n     def test_getattr_spaces(self, duckdb_cursor):\n         rel = duckdb_cursor.sql('select 42 as \"hello world\"')\n         assert rel['hello world'].fetchall()[0][0] == 42\n+\n+    def test_getattr_doublequotes(self, duckdb_cursor):\n+        rel = duckdb_cursor.sql('select 1 as \"tricky\"\", \"\"quotes\", 2 as tricky, 3 as quotes')\n+        assert rel[rel.columns[0]].fetchone() == (1,)\n",
  "problem_statement": "unescaped double-quote in column lookup in Python relational API\n### What happens?\r\n\r\nWhen using the python relational API, column names with `\"` in them don't seem to be escaped properly.\r\n\r\n### To Reproduce\r\n\r\npython code:\r\n\r\n```\r\nimport duckdb\r\nc = duckdb.connect()\r\nt = c.sql('select 1 as \"tricky\"\", \"\"quotes\", 2 as tricky, 3 as quotes')\r\n\r\nprint(\"t:\")\r\nprint(t)\r\n\r\nprint(\"t[t.columns[0]]:\")\r\nprint(t[t.columns[0]])\r\n```\r\n\r\noutput:\r\n\r\n```\r\nt:\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 tricky\", \"quotes \u2502 tricky \u2502 quotes \u2502\r\n\u2502      int32       \u2502 int32  \u2502 int32  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                1 \u2502      2 \u2502      3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nt[t.columns[0]]:\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 tricky \u2502 quotes \u2502\r\n\u2502 int32  \u2502 int32  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502      2 \u2502      3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nIt looks like internally it's translating that lookup to `SELECT \"tricky\", \"quotes\"` instead of the correct `SELECT \"tricky\"\", \"\"quotes\"`\r\n\r\n### OS:\r\n\r\nLinux 6.8.0-49-generic x86_64\r\n\r\n### DuckDB Version:\r\n\r\n1.1.3 \r\n\r\nUPDATE: Also 1.1.4-dev3247\r\n\r\n### DuckDB Client:\r\n\r\nPython, on Python 3.12.3\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nNick Moore\r\n\r\n### Affiliation:\r\n\r\nMnemote Pty Ltd\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\nUPDATE: Also 1.1.4-dev3247\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [x] Yes, I have\n",
  "hints_text": "The python client is not doing anything special here, this is the same result you'd get with the CLI for this query.\r\n\r\nAs seen by your result, every quote you intend to escape should be doubled\nYep, and in SQL / the CLI that makes sense.  But the within the Python API, the `[]` operator should be doing the quoting for you, and `t[t.columns[0]]` should always get the first column!\r\n\r\nAs it is, it does do *some* quoting when constructing the query, it seems to be inserting `\"` before and after the identifier, just not escaping `\"` to `\"\"` within the identifier.\r\n\r\n```\r\n>>> t['\"foo\"']\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nduckdb.duckdb.ParserException: Parser Error: zero-length delimited identifier at or near \"\"\"\"\r\n```\r\n\nHi @nickzoic thanks for opening this. I could reproduce it as follows:\r\n\r\n```python\r\nimport duckdb\r\nt=  duckdb.sql('select 1 as \"hello \"\"quoted\"\" world\", 2 as asd, 3 as qwe;')\r\nprint(t[t.columns[0]])\r\n```\r\n\r\n```console\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nduckdb.duckdb.ParserException: Parser Error: syntax error at or near \"\" world\"\"\r\n```",
  "created_at": "2024-12-11T09:52:18Z"
}