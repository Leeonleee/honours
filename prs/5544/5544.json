{
  "repo": "duckdb/duckdb",
  "pull_number": 5544,
  "instance_id": "duckdb__duckdb-5544",
  "issue_numbers": [
    "5960"
  ],
  "base_commit": "a27022be675e9ee4c593028c10c7bed39d19e68c",
  "patch": "diff --git a/.github/workflows/Java.yml b/.github/workflows/Java.yml\nindex b0db340bc211..d44ef0eef85f 100644\n--- a/.github/workflows/Java.yml\n+++ b/.github/workflows/Java.yml\n@@ -27,6 +27,7 @@ jobs:\n       GEN: ninja\n       BUILD_JDBC: 1\n       BUILD_JEMALLOC: 1\n+      BUILD_JSON: 1\n       TREAT_WARNINGS_AS_ERRORS: 1\n       FORCE_WARN_UNUSED: 1\n       STATIC_LIBCPP: 1\n@@ -120,10 +121,10 @@ jobs:\n         run: >\n           python scripts/windows_ci.py\n \n-          cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_GENERATOR_PLATFORM=x64 -DJDBC_DRIVER=1\n+          cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_GENERATOR_PLATFORM=x64 -DJDBC_DRIVER=1 -DBUILD_JSON_EXTENSION=1\n \n           cmake --build . --config Release\n-      - name: Java Test\n+      - name: Java Tests\n         shell: bash\n         run: |\n           java -cp tools/jdbc/duckdb_jdbc.jar org.duckdb.test.TestDuckDBJDBC\n@@ -145,6 +146,7 @@ jobs:\n     needs: java-linux-amd64\n     env:\n       BUILD_JDBC: 1\n+      BUILD_JSON: 1\n       OSX_BUILD_UNIVERSAL: 1\n     steps:\n       - uses: actions/checkout@v3\ndiff --git a/data/json/duplicate_key.ndjson b/data/json/duplicate_key.ndjson\nnew file mode 100644\nindex 000000000000..aea1a18d1bcd\n--- /dev/null\n+++ b/data/json/duplicate_key.ndjson\n@@ -0,0 +1,5 @@\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"id\":42,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\ndiff --git a/data/json/empty.ndjson b/data/json/empty.ndjson\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/data/json/example.ndjson b/data/json/example_n.ndjson\nsimilarity index 100%\nrename from data/json/example.ndjson\nrename to data/json/example_n.ndjson\ndiff --git a/data/json/example_r.ndjson b/data/json/example_r.ndjson\nnew file mode 100644\nindex 000000000000..651936b972c9\n--- /dev/null\n+++ b/data/json/example_r.ndjson\n@@ -0,0 +1,1 @@\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\r{\"id\":2,\"name\":\"Home for the Holidays\"}\r{\"id\":3,\"name\":\"The Firm\"}\r{\"id\":4,\"name\":\"Broadcast News\"}\r{\"id\":5,\"name\":\"Raising Arizona\"}\n\\ No newline at end of file\ndiff --git a/data/json/example_rn.ndjson b/data/json/example_rn.ndjson\nnew file mode 100644\nindex 000000000000..a3e009943bb7\n--- /dev/null\n+++ b/data/json/example_rn.ndjson\n@@ -0,0 +1,5 @@\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\r\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\r\n+{\"id\":3,\"name\":\"The Firm\"}\r\n+{\"id\":4,\"name\":\"Broadcast News\"}\r\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n\\ No newline at end of file\ndiff --git a/data/json/example_rn.ndjson.gz b/data/json/example_rn.ndjson.gz\nnew file mode 100644\nindex 000000000000..bdbd4edd8982\nBinary files /dev/null and b/data/json/example_rn.ndjson.gz differ\ndiff --git a/data/json/multiple_objects_per_line.ndjson b/data/json/multiple_objects_per_line.ndjson\nnew file mode 100644\nindex 000000000000..5925a27bea0f\n--- /dev/null\n+++ b/data/json/multiple_objects_per_line.ndjson\n@@ -0,0 +1,1 @@\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}{\"id\":2,\"name\":\"Home for the Holidays\"}{\"id\":3,\"name\":\"The Firm\"}{\"id\":4,\"name\":\"Broadcast News\"}{\"id\":5,\"name\":\"Raising Arizona\"}\ndiff --git a/data/json/unterminated_quotes.ndjson b/data/json/unterminated_quotes.ndjson\nnew file mode 100644\nindex 000000000000..24ac4e04289a\n--- /dev/null\n+++ b/data/json/unterminated_quotes.ndjson\n@@ -0,0 +1,5 @@\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\ndiff --git a/extension/jemalloc/jemalloc/include/jemalloc/internal/jemalloc_preamble.h b/extension/jemalloc/jemalloc/include/jemalloc/internal/jemalloc_preamble.h\nindex 47455cb16bd9..cfd73bc93da8 100644\n--- a/extension/jemalloc/jemalloc/include/jemalloc/internal/jemalloc_preamble.h\n+++ b/extension/jemalloc/jemalloc/include/jemalloc/internal/jemalloc_preamble.h\n@@ -4,6 +4,7 @@\n #include <cstdint>\n #include <cstdarg>\n #include <cstdbool>\n+#include <cstdlib>\n \n #include \"jemalloc/internal/jemalloc_internal_defs.h\"\n #include \"jemalloc/internal/jemalloc_internal_decls.h\"\ndiff --git a/extension/json/CMakeLists.txt b/extension/json/CMakeLists.txt\nindex 60d6c8e4604c..b920272906fa 100644\n--- a/extension/json/CMakeLists.txt\n+++ b/extension/json/CMakeLists.txt\n@@ -8,8 +8,11 @@ add_subdirectory(yyjson)\n add_subdirectory(json_functions)\n \n set(JSON_EXTENSION_FILES\n+    buffered_json_reader.cpp\n     json-extension.cpp\n     json_common.cpp\n+    json_functions.cpp\n+    json_scan.cpp\n     json_functions/json_array_length.cpp\n     json_functions/json_contains.cpp\n     json_functions/json_extract.cpp\n@@ -19,6 +22,7 @@ set(JSON_EXTENSION_FILES\n     json_functions/json_create.cpp\n     json_functions/json_type.cpp\n     json_functions/json_valid.cpp\n+    json_functions/read_json_objects.cpp\n     ${YYJSON_OBJECT_FILES})\n \n add_library(json_extension STATIC ${JSON_EXTENSION_FILES})\ndiff --git a/extension/json/buffered_json_reader.cpp b/extension/json/buffered_json_reader.cpp\nnew file mode 100644\nindex 000000000000..75048599cfcc\n--- /dev/null\n+++ b/extension/json/buffered_json_reader.cpp\n@@ -0,0 +1,127 @@\n+#include \"buffered_json_reader.hpp\"\n+\n+#include \"duckdb/common/field_writer.hpp\"\n+#include \"duckdb/common/file_opener.hpp\"\n+#include \"duckdb/common/file_system.hpp\"\n+#include \"duckdb/common/printer.hpp\"\n+\n+namespace duckdb {\n+\n+void BufferedJSONReaderOptions::Serialize(FieldWriter &writer) {\n+\twriter.WriteString(file_path);\n+\twriter.WriteField<JSONFormat>(format);\n+\twriter.WriteField<FileCompressionType>(compression);\n+}\n+\n+void BufferedJSONReaderOptions::Deserialize(FieldReader &reader) {\n+\tfile_path = reader.ReadRequired<string>();\n+\tformat = reader.ReadRequired<JSONFormat>();\n+\tcompression = reader.ReadRequired<FileCompressionType>();\n+}\n+\n+JSONBufferHandle::JSONBufferHandle(idx_t buffer_index_p, idx_t readers_p, AllocatedData &&buffer_p, idx_t buffer_size_p)\n+    : buffer_index(buffer_index_p), readers(readers_p), buffer(move(buffer_p)), buffer_size(buffer_size_p) {\n+}\n+\n+JSONFileHandle::JSONFileHandle(unique_ptr<FileHandle> file_handle_p)\n+    : file_handle(move(file_handle_p)), can_seek(file_handle->CanSeek()),\n+      plain_file_source(file_handle->OnDiskFile() && can_seek), file_size(file_handle->GetFileSize()),\n+      read_position(0) {\n+}\n+\n+idx_t JSONFileHandle::FileSize() const {\n+\treturn file_size;\n+}\n+\n+idx_t JSONFileHandle::Remaining() const {\n+\treturn file_size - read_position;\n+}\n+\n+bool JSONFileHandle::CanSeek() const {\n+\treturn can_seek;\n+}\n+\n+bool JSONFileHandle::PlainFileSource() const {\n+\treturn plain_file_source;\n+}\n+\n+idx_t JSONFileHandle::GetPositionAndSize(idx_t &position, idx_t requested_size) {\n+\tD_ASSERT(requested_size != 0);\n+\tposition = read_position;\n+\tauto actual_size = MinValue<idx_t>(requested_size, Remaining());\n+\tread_position += actual_size;\n+\treturn actual_size;\n+}\n+\n+void JSONFileHandle::ReadAtPosition(const char *pointer, idx_t size, idx_t position) {\n+\tD_ASSERT(size != 0);\n+\tfile_handle->Read((void *)pointer, size, position);\n+}\n+\n+idx_t JSONFileHandle::Read(const char *pointer, idx_t requested_size) {\n+\tD_ASSERT(requested_size != 0);\n+\tauto actual_size = file_handle->Read((void *)pointer, requested_size);\n+\tread_position += actual_size;\n+\treturn actual_size;\n+}\n+\n+BufferedJSONReader::BufferedJSONReader(ClientContext &context, BufferedJSONReaderOptions options_p, idx_t file_index_p,\n+                                       string file_path_p)\n+    : file_index(file_index_p), file_path(std::move(file_path_p)), context(context), options(std::move(options_p)),\n+      buffer_index(0) {\n+}\n+\n+void BufferedJSONReader::OpenJSONFile() {\n+\tlock_guard<mutex> guard(lock);\n+\tauto &file_system = FileSystem::GetFileSystem(context);\n+\tauto file_opener = FileOpener::Get(context);\n+\tauto regular_file_handle = file_system.OpenFile(file_path.c_str(), FileFlags::FILE_FLAGS_READ,\n+\t                                                FileLockType::NO_LOCK, options.compression, file_opener);\n+\tfile_handle = make_unique<JSONFileHandle>(std::move(regular_file_handle));\n+}\n+\n+bool BufferedJSONReader::IsOpen() {\n+\treturn file_handle != nullptr;\n+}\n+\n+BufferedJSONReaderOptions &BufferedJSONReader::GetOptions() {\n+\treturn options;\n+}\n+\n+JSONFileHandle &BufferedJSONReader::GetFileHandle() const {\n+\treturn *file_handle;\n+}\n+\n+void BufferedJSONReader::InsertBuffer(idx_t buffer_idx, unique_ptr<JSONBufferHandle> &&buffer) {\n+\tlock_guard<mutex> guard(lock);\n+\tbuffer_map.insert(make_pair(buffer_idx, std::move(buffer)));\n+}\n+\n+JSONBufferHandle *BufferedJSONReader::GetBuffer(idx_t buffer_idx) {\n+\tlock_guard<mutex> guard(lock);\n+\tauto it = buffer_map.find(buffer_idx);\n+\treturn it == buffer_map.end() ? nullptr : it->second.get();\n+}\n+\n+AllocatedData BufferedJSONReader::RemoveBuffer(idx_t buffer_idx) {\n+\tlock_guard<mutex> guard(lock);\n+\tauto it = buffer_map.find(buffer_idx);\n+\tD_ASSERT(it != buffer_map.end());\n+\tauto result = std::move(it->second->buffer);\n+\tbuffer_map.erase(it);\n+\treturn result;\n+}\n+\n+idx_t BufferedJSONReader::GetBufferIndex() {\n+\treturn buffer_index++;\n+}\n+\n+double BufferedJSONReader::GetProgress() const {\n+\tif (file_handle) {\n+\t\treturn 100.0 * double(file_handle->Remaining()) / double(file_handle->FileSize());\n+\t} else {\n+\t\treturn 0;\n+\t}\n+}\n+\n+} // namespace duckdb\ndiff --git a/extension/json/include/buffered_json_reader.hpp b/extension/json/include/buffered_json_reader.hpp\nnew file mode 100644\nindex 000000000000..364c036bb18a\n--- /dev/null\n+++ b/extension/json/include/buffered_json_reader.hpp\n@@ -0,0 +1,123 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// buffered_json_reader.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/atomic.hpp\"\n+#include \"duckdb/common/enums/file_compression_type.hpp\"\n+#include \"duckdb/common/mutex.hpp\"\n+#include \"json_common.hpp\"\n+\n+namespace duckdb {\n+\n+struct FileHandle;\n+\n+enum class JSONFormat : uint8_t {\n+\t//! Auto-detect format (UNSTRUCTURED / NEWLINE_DELIMITED)\n+\tAUTO_DETECT = 0,\n+\t//! One object after another, newlines can be anywhere\n+\tUNSTRUCTURED = 1,\n+\t//! Objects are separated by newlines, newlines do not occur within objects (NDJSON)\n+\tNEWLINE_DELIMITED = 2,\n+};\n+\n+struct BufferedJSONReaderOptions {\n+public:\n+\t//! The file path of the JSON file to read\n+\tstring file_path;\n+\t//! The format of the JSON\n+\tJSONFormat format = JSONFormat::AUTO_DETECT;\n+\t//! Whether file is compressed or not, and if so which compression type\n+\tFileCompressionType compression = FileCompressionType::AUTO_DETECT;\n+\n+public:\n+\tvoid Serialize(FieldWriter &writer);\n+\tvoid Deserialize(FieldReader &reader);\n+};\n+\n+struct JSONBufferHandle {\n+public:\n+\tJSONBufferHandle(idx_t buffer_index, idx_t readers, AllocatedData &&buffer, idx_t buffer_size);\n+\n+public:\n+\t//! Buffer index (within same file)\n+\tconst idx_t buffer_index;\n+\n+\t//! Number of readers for this buffer\n+\tatomic<idx_t> readers;\n+\t//! The buffer\n+\tAllocatedData buffer;\n+\t//! The size of the data in the buffer (can be less than buffer.GetSize())\n+\tconst idx_t buffer_size;\n+};\n+\n+struct JSONFileHandle {\n+public:\n+\texplicit JSONFileHandle(unique_ptr<FileHandle> file_handle);\n+\n+\tidx_t FileSize() const;\n+\tidx_t Remaining() const;\n+\n+\tbool CanSeek() const;\n+\tbool PlainFileSource() const;\n+\n+\tidx_t GetPositionAndSize(idx_t &position, idx_t requested_size);\n+\tvoid ReadAtPosition(const char *pointer, idx_t size, idx_t position);\n+\tidx_t Read(const char *pointer, idx_t requested_size);\n+\n+private:\n+\t//! The JSON file handle\n+\tunique_ptr<FileHandle> file_handle;\n+\n+\t//! File properties\n+\tconst bool can_seek;\n+\tconst bool plain_file_source;\n+\tconst idx_t file_size;\n+\n+\t//! Read properties\n+\tidx_t read_position;\n+};\n+\n+class BufferedJSONReader {\n+public:\n+\tBufferedJSONReader(ClientContext &context, BufferedJSONReaderOptions options, idx_t file_index, string file_path);\n+\n+\tvoid OpenJSONFile();\n+\tbool IsOpen();\n+\n+\tBufferedJSONReaderOptions &GetOptions();\n+\tJSONFileHandle &GetFileHandle() const;\n+\n+\tvoid InsertBuffer(idx_t buffer_idx, unique_ptr<JSONBufferHandle> &&buffer);\n+\tJSONBufferHandle *GetBuffer(idx_t buffer_idx);\n+\tAllocatedData RemoveBuffer(idx_t buffer_idx);\n+\tidx_t GetBufferIndex();\n+\n+\tdouble GetProgress() const;\n+\n+public:\n+\tmutex lock;\n+\n+\t//! File index / path\n+\tconst idx_t file_index;\n+\tconst string file_path;\n+\n+private:\n+\tClientContext &context;\n+\tBufferedJSONReaderOptions options;\n+\n+\t//! File handle\n+\tunique_ptr<JSONFileHandle> file_handle;\n+\n+\t//! Next buffer index within the file\n+\tidx_t buffer_index;\n+\t//! Mapping from batch index to currently held buffers\n+\tunordered_map<idx_t, unique_ptr<JSONBufferHandle>> buffer_map;\n+};\n+\n+} // namespace duckdb\ndiff --git a/extension/json/include/json_common.hpp b/extension/json/include/json_common.hpp\nindex f8030e5a7c14..8b628ece33d9 100644\n--- a/extension/json/include/json_common.hpp\n+++ b/extension/json/include/json_common.hpp\n@@ -11,112 +11,75 @@\n #include \"duckdb/common/operator/cast_operators.hpp\"\n #include \"duckdb/common/operator/decimal_cast_operators.hpp\"\n #include \"duckdb/common/operator/string_cast.hpp\"\n-#include \"duckdb/execution/expression_executor.hpp\"\n #include \"duckdb/planner/expression/bound_function_expression.hpp\"\n #include \"yyjson.hpp\"\n \n namespace duckdb {\n \n-struct JSONReadFunctionData : public FunctionData {\n+class JSONAllocator {\n public:\n-\tJSONReadFunctionData(bool constant, string path_p, idx_t len);\n-\tunique_ptr<FunctionData> Copy() const override;\n-\tbool Equals(const FunctionData &other_p) const override;\n-\tstatic unique_ptr<FunctionData> Bind(ClientContext &context, ScalarFunction &bound_function,\n-\t                                     vector<unique_ptr<Expression>> &arguments);\n-\n-public:\n-\tconst bool constant;\n-\tconst string path;\n-\tconst char *ptr;\n-\tconst size_t len;\n-};\n-\n-struct JSONReadManyFunctionData : public FunctionData {\n-public:\n-\tJSONReadManyFunctionData(vector<string> paths_p, vector<size_t> lens_p);\n-\tunique_ptr<FunctionData> Copy() const override;\n-\tbool Equals(const FunctionData &other_p) const override;\n-\tstatic unique_ptr<FunctionData> Bind(ClientContext &context, ScalarFunction &bound_function,\n-\t                                     vector<unique_ptr<Expression>> &arguments);\n-\n-public:\n-\tconst vector<string> paths;\n-\tvector<const char *> ptrs;\n-\tconst vector<size_t> lens;\n-};\n-\n-template <class YYJSON_DOC_T>\n-static inline void CleanupDoc(YYJSON_DOC_T *doc) {\n-\tthrow InternalException(\"Unknown yyjson document type\");\n-}\n+\texplicit JSONAllocator(Allocator &allocator)\n+\t    : arena_allocator(allocator), yyjson_allocator({Allocate, Reallocate, Free, &arena_allocator}) {\n+\t}\n \n-template <>\n-inline void CleanupDoc(yyjson_doc *doc) {\n-\tyyjson_doc_free(doc);\n-}\n+\tinline yyjson_alc *GetYYJSONAllocator() {\n+\t\treturn &yyjson_allocator;\n+\t}\n \n-template <>\n-inline void CleanupDoc(yyjson_mut_doc *doc) {\n-\tyyjson_mut_doc_free(doc);\n-}\n+\tvoid Reset() {\n+\t\tarena_allocator.Reset();\n+\t}\n \n-template <class YYJSON_DOC_T>\n-class DocPointer {\n private:\n-\tYYJSON_DOC_T *doc;\n-\n-public:\n-\texplicit DocPointer(YYJSON_DOC_T *doc) : doc(doc) {\n+\tstatic inline void *Allocate(void *ctx, size_t size) {\n+\t\tauto alloc = (ArenaAllocator *)ctx;\n+\t\treturn alloc->AllocateAligned(size);\n \t}\n \n-\tDocPointer(const DocPointer &obj) = delete;\n-\tDocPointer &operator=(const DocPointer &obj) = delete;\n-\n-\tDocPointer(DocPointer &&other) noexcept {\n-\t\tthis->doc = other.doc;\n-\t\tother.doc = nullptr;\n+\tstatic inline void *Reallocate(void *ctx, void *ptr, size_t old_size, size_t size) {\n+\t\tauto alloc = (ArenaAllocator *)ctx;\n+\t\treturn alloc->ReallocateAligned((data_ptr_t)ptr, old_size, size);\n \t}\n \n-\tvoid operator=(DocPointer &&other) noexcept {\n-\t\tCleanupDoc<YYJSON_DOC_T>(doc);\n-\t\tthis->ptr = other.ptr;\n-\t\tother.ptr = nullptr;\n+\tstatic inline void Free(void *ctx, void *ptr) {\n+\t\t// NOP because ArenaAllocator can't free\n \t}\n \n-\tinline YYJSON_DOC_T *operator*() const {\n-\t\treturn doc;\n-\t}\n+private:\n+\tArenaAllocator arena_allocator;\n+\tyyjson_alc yyjson_allocator;\n+};\n \n-\tinline YYJSON_DOC_T *operator->() const {\n-\t\treturn doc;\n-\t}\n+struct JSONCommon {\n+public:\n+\tstatic constexpr auto JSON_TYPE_NAME = \"JSON\";\n \n-\tinline bool IsNull() const {\n-\t\treturn doc == nullptr;\n+\tstatic const LogicalType JSONType() {\n+\t\tauto json_type = LogicalType(LogicalTypeId::VARCHAR);\n+\t\tjson_type.SetAlias(JSON_TYPE_NAME);\n+\t\treturn json_type;\n \t}\n \n-\t~DocPointer() {\n-\t\tCleanupDoc<YYJSON_DOC_T>(doc);\n+\tstatic bool LogicalTypeIsJSON(const LogicalType &type) {\n+\t\treturn type.id() == LogicalTypeId::VARCHAR && type.HasAlias() && type.GetAlias() == JSON_TYPE_NAME;\n \t}\n-};\n \n-struct JSONCommon {\n-private:\n-\t//! Read/Write flag that make sense for us\n+public:\n+\t//! Read/Write flags\n \tstatic constexpr auto READ_FLAG = YYJSON_READ_ALLOW_INF_AND_NAN | YYJSON_READ_ALLOW_TRAILING_COMMAS;\n+\tstatic constexpr auto STOP_READ_FLAG = READ_FLAG | YYJSON_READ_STOP_WHEN_DONE | YYJSON_READ_INSITU;\n \tstatic constexpr auto WRITE_FLAG = YYJSON_WRITE_ALLOW_INF_AND_NAN;\n \n public:\n \t//! Constant JSON type strings\n-\tstatic constexpr auto TYPE_STRING_NULL = \"NULL\";\n-\tstatic constexpr auto TYPE_STRING_BOOLEAN = \"BOOLEAN\";\n-\tstatic constexpr auto TYPE_STRING_BIGINT = \"BIGINT\";\n-\tstatic constexpr auto TYPE_STRING_UBIGINT = \"UBIGINT\";\n-\tstatic constexpr auto TYPE_STRING_DOUBLE = \"DOUBLE\";\n-\tstatic constexpr auto TYPE_STRING_VARCHAR = \"VARCHAR\";\n-\tstatic constexpr auto TYPE_STRING_ARRAY = \"ARRAY\";\n-\tstatic constexpr auto TYPE_STRING_OBJECT = \"OBJECT\";\n+\tstatic constexpr char const *TYPE_STRING_NULL = \"NULL\";\n+\tstatic constexpr char const *TYPE_STRING_BOOLEAN = \"BOOLEAN\";\n+\tstatic constexpr char const *TYPE_STRING_BIGINT = \"BIGINT\";\n+\tstatic constexpr char const *TYPE_STRING_UBIGINT = \"UBIGINT\";\n+\tstatic constexpr char const *TYPE_STRING_DOUBLE = \"DOUBLE\";\n+\tstatic constexpr char const *TYPE_STRING_VARCHAR = \"VARCHAR\";\n+\tstatic constexpr char const *TYPE_STRING_ARRAY = \"ARRAY\";\n+\tstatic constexpr char const *TYPE_STRING_OBJECT = \"OBJECT\";\n \n \ttemplate <class YYJSON_VAL_T>\n \tstatic inline const char *const ValTypeToString(YYJSON_VAL_T *val) {\n@@ -143,59 +106,62 @@ struct JSONCommon {\n \t\t}\n \t}\n \n-public:\n-\tstatic inline DocPointer<yyjson_mut_doc> CreateDocument() {\n-\t\treturn DocPointer<yyjson_mut_doc>(yyjson_mut_doc_new(nullptr));\n+\ttemplate <class YYJSON_VAL_T>\n+\tstatic inline constexpr string_t ValTypeToStringT(YYJSON_VAL_T *val) {\n+\t\treturn string_t(ValTypeToString<YYJSON_VAL_T>(val));\n \t}\n \n-\t//! Read JSON document (returns nullptr if invalid JSON)\n-\tstatic inline DocPointer<yyjson_doc> ReadDocumentUnsafe(const string_t &input) {\n-\t\treturn DocPointer<yyjson_doc>(yyjson_read(input.GetDataUnsafe(), input.GetSize(), READ_FLAG));\n-\t}\n-\t//! Read JSON document (throws error if malformed JSON)\n-\tstatic inline DocPointer<yyjson_doc> ReadDocument(const string_t &input) {\n-\t\tauto result = ReadDocumentUnsafe(input);\n-\t\tif (result.IsNull()) {\n-\t\t\tthrow InvalidInputException(\"malformed JSON\");\n+public:\n+\tstatic inline yyjson_mut_doc *CreateDocument(yyjson_alc *alc) {\n+\t\tD_ASSERT(alc);\n+\t\treturn yyjson_mut_doc_new(alc);\n+\t}\n+\tstatic inline yyjson_doc *ReadDocumentUnsafe(char *data, idx_t size, const yyjson_read_flag flg, yyjson_alc *alc,\n+\t                                             yyjson_read_err *err = nullptr) {\n+\t\tD_ASSERT(alc);\n+\t\treturn yyjson_read_opts(data, size, flg, alc, err);\n+\t}\n+\tstatic inline yyjson_doc *ReadDocumentUnsafe(const string_t &input, const yyjson_read_flag flg, yyjson_alc *alc,\n+\t                                             yyjson_read_err *err = nullptr) {\n+\t\treturn ReadDocumentUnsafe(input.GetDataWriteable(), input.GetSize(), flg, alc, err);\n+\t}\n+\tstatic inline yyjson_doc *ReadDocument(char *data, idx_t size, const yyjson_read_flag flg, yyjson_alc *alc) {\n+\t\tyyjson_read_err error;\n+\t\tauto result = ReadDocumentUnsafe(data, size, flg, alc, &error);\n+\t\tif (error.code != YYJSON_READ_SUCCESS) {\n+\t\t\tThrowParseError(data, size, error);\n \t\t}\n \t\treturn result;\n \t}\n-\t//! Some wrappers around writes so we don't have to free the malloc'ed char[]\n-\tstatic inline unique_ptr<char, void (*)(void *)> WriteVal(yyjson_val *val, idx_t &len) {\n-\t\treturn unique_ptr<char, decltype(free) *>(\n-\t\t    reinterpret_cast<char *>(yyjson_val_write(val, WRITE_FLAG, (size_t *)&len)), free);\n-\t}\n-\tstatic inline unique_ptr<char, void (*)(void *)> WriteVal(yyjson_mut_val *val, idx_t &len) {\n-\t\treturn unique_ptr<char, decltype(free) *>(\n-\t\t    reinterpret_cast<char *>(yyjson_mut_val_write(val, WRITE_FLAG, (size_t *)&len)), free);\n+\tstatic inline yyjson_doc *ReadDocument(const string_t &input, const yyjson_read_flag flg, yyjson_alc *alc) {\n+\t\treturn ReadDocument(input.GetDataWriteable(), input.GetSize(), flg, alc);\n \t}\n-\tstatic unique_ptr<char, void (*)(void *)> WriteMutDoc(yyjson_mut_doc *doc, idx_t &len) {\n-\t\treturn unique_ptr<char, decltype(free) *>(\n-\t\t    reinterpret_cast<char *>(yyjson_mut_write(doc, WRITE_FLAG, (size_t *)&len)), free);\n+\tstatic string FormatParseError(const char *data, idx_t length, yyjson_read_err &error, const string &extra = \"\") {\n+\t\tD_ASSERT(error.code != YYJSON_READ_SUCCESS);\n+\t\t// Truncate, so we don't print megabytes worth of JSON\n+\t\tstring input = length > 50 ? string(data, 47) + \"...\" : string(data, length);\n+\t\t// Have to replace \\r, otherwise output is unreadable\n+\t\tinput = StringUtil::Replace(input, \"\\r\", \"\\\\r\");\n+\t\treturn StringUtil::Format(\"Malformed JSON at byte %lld of input: %s. %s Input: %s\", error.pos, error.msg, extra,\n+\t\t                          input);\n \t}\n-\t//! Vector writes\n-\tstatic inline string_t WriteVal(yyjson_val *val, Vector &vector) {\n-\t\tidx_t len;\n-\t\tauto data = WriteVal(val, len);\n-\t\treturn StringVector::AddString(vector, data.get(), len);\n+\tstatic void ThrowParseError(const char *data, idx_t length, yyjson_read_err &error, const string &extra = \"\") {\n+\t\tthrow InvalidInputException(FormatParseError(data, length, error, extra));\n \t}\n-\tstatic inline string_t WriteVal(yyjson_mut_val *val, Vector &vector) {\n-\t\tidx_t len;\n-\t\tauto data = WriteVal(val, len);\n-\t\treturn StringVector::AddString(vector, data.get(), len);\n+\n+\ttemplate <class YYJSON_VAL_T>\n+\tstatic inline char *WriteVal(YYJSON_VAL_T *val, yyjson_alc *alc, idx_t &len) {\n+\t\tthrow InternalException(\"Unknown yyjson val type\");\n \t}\n-\tstatic inline string_t WriteDoc(yyjson_mut_doc *doc, Vector &vector) {\n+\ttemplate <class YYJSON_VAL_T>\n+\tstatic inline string_t WriteVal(YYJSON_VAL_T *val, yyjson_alc *alc) {\n+\t\tD_ASSERT(alc);\n \t\tidx_t len;\n-\t\tauto data = WriteMutDoc(doc, len);\n-\t\treturn StringVector::AddString(vector, data.get(), len);\n+\t\tauto data = WriteVal<YYJSON_VAL_T>(val, alc, len);\n+\t\treturn string_t(data, len);\n \t}\n \t//! Throw an error with the printed yyjson_val\n-\tstatic void ThrowValFormatError(string error_string, yyjson_val *val) {\n-\t\tidx_t len;\n-\t\tauto data = WriteVal(val, len);\n-\t\terror_string = StringUtil::Format(error_string, string(data.get(), len));\n-\t\tthrow InvalidInputException(error_string);\n-\t}\n+\tstatic void ThrowValFormatError(string error_string, yyjson_val *val);\n \n public:\n \t//! Validate path with $ syntax\n@@ -241,116 +207,6 @@ struct JSONCommon {\n \t\t}\n \t}\n \n-public:\n-\t//! Single-argument JSON read function, i.e. json_type('[1, 2, 3]')\n-\ttemplate <class T>\n-\tstatic void UnaryExecute(DataChunk &args, ExpressionState &state, Vector &result,\n-\t                         std::function<T(yyjson_val *, Vector &)> fun) {\n-\t\tauto &inputs = args.data[0];\n-\t\tUnaryExecutor::Execute<string_t, T>(inputs, result, args.size(), [&](string_t input) {\n-\t\t\tauto doc = JSONCommon::ReadDocument(input);\n-\t\t\treturn fun(doc->root, result);\n-\t\t});\n-\t}\n-\n-\t//! Two-argument JSON read function (with path query), i.e. json_type('[1, 2, 3]', '$[0]')\n-\ttemplate <class T>\n-\tstatic void BinaryExecute(DataChunk &args, ExpressionState &state, Vector &result,\n-\t                          std::function<T(yyjson_val *, Vector &)> fun) {\n-\t\tauto &func_expr = (BoundFunctionExpression &)state.expr;\n-\t\tconst auto &info = (JSONReadFunctionData &)*func_expr.bind_info;\n-\n-\t\tauto &inputs = args.data[0];\n-\t\tif (info.constant) {\n-\t\t\t// Constant path\n-\t\t\tconst char *ptr = info.ptr;\n-\t\t\tconst idx_t &len = info.len;\n-\t\t\tUnaryExecutor::ExecuteWithNulls<string_t, T>(\n-\t\t\t    inputs, result, args.size(), [&](string_t input, ValidityMask &mask, idx_t idx) {\n-\t\t\t\t    auto doc = ReadDocument(input);\n-\t\t\t\t    yyjson_val *val;\n-\t\t\t\t    if (!(val = GetPointerUnsafe<yyjson_val>(doc->root, ptr, len))) {\n-\t\t\t\t\t    mask.SetInvalid(idx);\n-\t\t\t\t\t    return T {};\n-\t\t\t\t    } else {\n-\t\t\t\t\t    return fun(val, result);\n-\t\t\t\t    }\n-\t\t\t    });\n-\t\t} else {\n-\t\t\t// Columnref path\n-\t\t\tauto &paths = args.data[1];\n-\t\t\tBinaryExecutor::ExecuteWithNulls<string_t, string_t, T>(\n-\t\t\t    inputs, paths, result, args.size(), [&](string_t input, string_t path, ValidityMask &mask, idx_t idx) {\n-\t\t\t\t    auto doc = ReadDocument(input);\n-\t\t\t\t    yyjson_val *val;\n-\t\t\t\t    if (!(val = GetPointer<yyjson_val>(doc->root, path))) {\n-\t\t\t\t\t    mask.SetInvalid(idx);\n-\t\t\t\t\t    return T {};\n-\t\t\t\t    } else {\n-\t\t\t\t\t    return fun(val, result);\n-\t\t\t\t    }\n-\t\t\t    });\n-\t\t}\n-\t\tif (args.AllConstant()) {\n-\t\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n-\t\t}\n-\t}\n-\n-\t//! JSON read function with list of path queries, i.e. json_type('[1, 2, 3]', ['$[0]', '$[1]'])\n-\ttemplate <class T>\n-\tstatic void ExecuteMany(DataChunk &args, ExpressionState &state, Vector &result,\n-\t                        std::function<T(yyjson_val *, Vector &)> fun) {\n-\t\tauto &func_expr = (BoundFunctionExpression &)state.expr;\n-\t\tconst auto &info = (JSONReadManyFunctionData &)*func_expr.bind_info;\n-\t\tD_ASSERT(info.ptrs.size() == info.lens.size());\n-\n-\t\tconst auto count = args.size();\n-\t\tconst idx_t num_paths = info.ptrs.size();\n-\t\tconst idx_t list_size = count * num_paths;\n-\n-\t\tUnifiedVectorFormat input_data;\n-\t\tauto &input_vector = args.data[0];\n-\t\tinput_vector.ToUnifiedFormat(count, input_data);\n-\t\tauto inputs = (string_t *)input_data.data;\n-\n-\t\tListVector::Reserve(result, list_size);\n-\t\tauto list_entries = FlatVector::GetData<list_entry_t>(result);\n-\t\tauto &list_validity = FlatVector::Validity(result);\n-\n-\t\tauto &child = ListVector::GetEntry(result);\n-\t\tauto child_data = FlatVector::GetData<T>(child);\n-\t\tauto &child_validity = FlatVector::Validity(child);\n-\n-\t\tidx_t offset = 0;\n-\t\tyyjson_val *val;\n-\t\tfor (idx_t i = 0; i < count; i++) {\n-\t\t\tauto idx = input_data.sel->get_index(i);\n-\t\t\tif (!input_data.validity.RowIsValid(idx)) {\n-\t\t\t\tlist_validity.SetInvalid(i);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tauto doc = ReadDocument(inputs[idx]);\n-\t\t\tfor (idx_t path_i = 0; path_i < num_paths; path_i++) {\n-\t\t\t\tauto child_idx = offset + path_i;\n-\t\t\t\tif (!(val = GetPointerUnsafe<yyjson_val>(doc->root, info.ptrs[path_i], info.lens[path_i]))) {\n-\t\t\t\t\tchild_validity.SetInvalid(child_idx);\n-\t\t\t\t} else {\n-\t\t\t\t\tchild_data[child_idx] = fun(val, child);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tlist_entries[i].offset = offset;\n-\t\t\tlist_entries[i].length = num_paths;\n-\t\t\toffset += num_paths;\n-\t\t}\n-\t\tListVector::SetListSize(result, offset);\n-\n-\t\tif (args.AllConstant()) {\n-\t\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n-\t\t}\n-\t}\n-\n private:\n \t//! Get JSON pointer using /field/index/... notation\n \ttemplate <class YYJSON_VAL_T>\n@@ -502,6 +358,15 @@ struct JSONCommon {\n \t}\n };\n \n+template <>\n+inline char *JSONCommon::WriteVal(yyjson_val *val, yyjson_alc *alc, idx_t &len) {\n+\treturn yyjson_val_write_opts(val, JSONCommon::WRITE_FLAG, alc, (size_t *)&len, nullptr);\n+}\n+template <>\n+inline char *JSONCommon::WriteVal(yyjson_mut_val *val, yyjson_alc *alc, idx_t &len) {\n+\treturn yyjson_mut_val_write_opts(val, JSONCommon::WRITE_FLAG, alc, (size_t *)&len, nullptr);\n+}\n+\n template <>\n inline yyjson_val *JSONCommon::TemplatedGetPointer(yyjson_val *root, const char *ptr, const idx_t &len) {\n \treturn len == 1 ? root : unsafe_yyjson_get_pointer(root, ptr, len);\ndiff --git a/extension/json/include/json_executors.hpp b/extension/json/include/json_executors.hpp\nnew file mode 100644\nindex 000000000000..6a1b69a71205\n--- /dev/null\n+++ b/extension/json/include/json_executors.hpp\n@@ -0,0 +1,139 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// json_executors.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/execution/expression_executor.hpp\"\n+#include \"json_functions.hpp\"\n+\n+namespace duckdb {\n+\n+struct JSONExecutors {\n+public:\n+\t//! Single-argument JSON read function, i.e. json_type('[1, 2, 3]')\n+\ttemplate <class T>\n+\tstatic void UnaryExecute(DataChunk &args, ExpressionState &state, Vector &result,\n+\t                         std::function<T(yyjson_val *, yyjson_alc *, Vector &)> fun) {\n+\t\tauto &lstate = JSONFunctionLocalState::ResetAndGet(state);\n+\t\tauto alc = lstate.json_allocator.GetYYJSONAllocator();\n+\n+\t\tauto &inputs = args.data[0];\n+\t\tUnaryExecutor::Execute<string_t, T>(inputs, result, args.size(), [&](string_t input) {\n+\t\t\tauto doc = JSONCommon::ReadDocument(input, JSONCommon::READ_FLAG, alc);\n+\t\t\treturn fun(doc->root, alc, result);\n+\t\t});\n+\t}\n+\n+\t//! Two-argument JSON read function (with path query), i.e. json_type('[1, 2, 3]', '$[0]')\n+\ttemplate <class T>\n+\tstatic void BinaryExecute(DataChunk &args, ExpressionState &state, Vector &result,\n+\t                          std::function<T(yyjson_val *, yyjson_alc *, Vector &)> fun) {\n+\t\tauto &func_expr = (BoundFunctionExpression &)state.expr;\n+\t\tconst auto &info = (JSONReadFunctionData &)*func_expr.bind_info;\n+\t\tauto &lstate = JSONFunctionLocalState::ResetAndGet(state);\n+\t\tauto alc = lstate.json_allocator.GetYYJSONAllocator();\n+\n+\t\tauto &inputs = args.data[0];\n+\t\tif (info.constant) {\n+\t\t\t// Constant path\n+\t\t\tconst char *ptr = info.ptr;\n+\t\t\tconst idx_t &len = info.len;\n+\t\t\tUnaryExecutor::ExecuteWithNulls<string_t, T>(\n+\t\t\t    inputs, result, args.size(), [&](string_t input, ValidityMask &mask, idx_t idx) {\n+\t\t\t\t    auto doc = JSONCommon::ReadDocument(input, JSONCommon::READ_FLAG,\n+\t\t\t\t                                        lstate.json_allocator.GetYYJSONAllocator());\n+\t\t\t\t    auto val = JSONCommon::GetPointerUnsafe<yyjson_val>(doc->root, ptr, len);\n+\t\t\t\t    if (!val) {\n+\t\t\t\t\t    mask.SetInvalid(idx);\n+\t\t\t\t\t    return T {};\n+\t\t\t\t    } else {\n+\t\t\t\t\t    return fun(val, alc, result);\n+\t\t\t\t    }\n+\t\t\t    });\n+\t\t} else {\n+\t\t\t// Columnref path\n+\t\t\tauto &paths = args.data[1];\n+\t\t\tBinaryExecutor::ExecuteWithNulls<string_t, string_t, T>(\n+\t\t\t    inputs, paths, result, args.size(), [&](string_t input, string_t path, ValidityMask &mask, idx_t idx) {\n+\t\t\t\t    auto doc = JSONCommon::ReadDocument(input, JSONCommon::READ_FLAG,\n+\t\t\t\t                                        lstate.json_allocator.GetYYJSONAllocator());\n+\t\t\t\t    auto val = JSONCommon::GetPointer<yyjson_val>(doc->root, path);\n+\t\t\t\t    if (!val) {\n+\t\t\t\t\t    mask.SetInvalid(idx);\n+\t\t\t\t\t    return T {};\n+\t\t\t\t    } else {\n+\t\t\t\t\t    return fun(val, alc, result);\n+\t\t\t\t    }\n+\t\t\t    });\n+\t\t}\n+\t\tif (args.AllConstant()) {\n+\t\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\t\t}\n+\t}\n+\n+\t//! JSON read function with list of path queries, i.e. json_type('[1, 2, 3]', ['$[0]', '$[1]'])\n+\ttemplate <class T>\n+\tstatic void ExecuteMany(DataChunk &args, ExpressionState &state, Vector &result,\n+\t                        std::function<T(yyjson_val *, yyjson_alc *, Vector &)> fun) {\n+\t\tauto &func_expr = (BoundFunctionExpression &)state.expr;\n+\t\tconst auto &info = (JSONReadManyFunctionData &)*func_expr.bind_info;\n+\t\tauto &lstate = JSONFunctionLocalState::ResetAndGet(state);\n+\t\tauto alc = lstate.json_allocator.GetYYJSONAllocator();\n+\t\tD_ASSERT(info.ptrs.size() == info.lens.size());\n+\n+\t\tconst auto count = args.size();\n+\t\tconst idx_t num_paths = info.ptrs.size();\n+\t\tconst idx_t list_size = count * num_paths;\n+\n+\t\tUnifiedVectorFormat input_data;\n+\t\tauto &input_vector = args.data[0];\n+\t\tinput_vector.ToUnifiedFormat(count, input_data);\n+\t\tauto inputs = (string_t *)input_data.data;\n+\n+\t\tListVector::Reserve(result, list_size);\n+\t\tauto list_entries = FlatVector::GetData<list_entry_t>(result);\n+\t\tauto &list_validity = FlatVector::Validity(result);\n+\n+\t\tauto &child = ListVector::GetEntry(result);\n+\t\tauto child_data = FlatVector::GetData<T>(child);\n+\t\tauto &child_validity = FlatVector::Validity(child);\n+\n+\t\tidx_t offset = 0;\n+\t\tyyjson_val *val;\n+\t\tfor (idx_t i = 0; i < count; i++) {\n+\t\t\tauto idx = input_data.sel->get_index(i);\n+\t\t\tif (!input_data.validity.RowIsValid(idx)) {\n+\t\t\t\tlist_validity.SetInvalid(i);\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tauto doc = JSONCommon::ReadDocument(inputs[idx], JSONCommon::READ_FLAG,\n+\t\t\t                                    lstate.json_allocator.GetYYJSONAllocator());\n+\t\t\tfor (idx_t path_i = 0; path_i < num_paths; path_i++) {\n+\t\t\t\tauto child_idx = offset + path_i;\n+\t\t\t\tval = JSONCommon::GetPointerUnsafe<yyjson_val>(doc->root, info.ptrs[path_i], info.lens[path_i]);\n+\t\t\t\tif (!val) {\n+\t\t\t\t\tchild_validity.SetInvalid(child_idx);\n+\t\t\t\t} else {\n+\t\t\t\t\tchild_data[child_idx] = fun(val, alc, child);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tlist_entries[i].offset = offset;\n+\t\t\tlist_entries[i].length = num_paths;\n+\t\t\toffset += num_paths;\n+\t\t}\n+\t\tListVector::SetListSize(result, offset);\n+\n+\t\tif (args.AllConstant()) {\n+\t\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\t\t}\n+\t}\n+};\n+\n+} // namespace duckdb\ndiff --git a/extension/json/include/json_functions.hpp b/extension/json/include/json_functions.hpp\nindex 4907e54b3e44..922143b6e00a 100644\n--- a/extension/json/include/json_functions.hpp\n+++ b/extension/json/include/json_functions.hpp\n@@ -9,41 +9,63 @@\n #pragma once\n \n #include \"duckdb/parser/parsed_data/create_scalar_function_info.hpp\"\n+#include \"duckdb/parser/parsed_data/create_table_function_info.hpp\"\n+#include \"json_common.hpp\"\n \n namespace duckdb {\n \n+class CastFunctionSet;\n+struct CastParameters;\n+\n+// Scalar function stuff\n+struct JSONReadFunctionData : public FunctionData {\n+public:\n+\tJSONReadFunctionData(bool constant, string path_p, idx_t len);\n+\tunique_ptr<FunctionData> Copy() const override;\n+\tbool Equals(const FunctionData &other_p) const override;\n+\tstatic unique_ptr<FunctionData> Bind(ClientContext &context, ScalarFunction &bound_function,\n+\t                                     vector<unique_ptr<Expression>> &arguments);\n+\n+public:\n+\tconst bool constant;\n+\tconst string path;\n+\tconst char *ptr;\n+\tconst size_t len;\n+};\n+\n+struct JSONReadManyFunctionData : public FunctionData {\n+public:\n+\tJSONReadManyFunctionData(vector<string> paths_p, vector<size_t> lens_p);\n+\tunique_ptr<FunctionData> Copy() const override;\n+\tbool Equals(const FunctionData &other_p) const override;\n+\tstatic unique_ptr<FunctionData> Bind(ClientContext &context, ScalarFunction &bound_function,\n+\t                                     vector<unique_ptr<Expression>> &arguments);\n+\n+public:\n+\tconst vector<string> paths;\n+\tvector<const char *> ptrs;\n+\tconst vector<size_t> lens;\n+};\n+\n+struct JSONFunctionLocalState : public FunctionLocalState {\n+public:\n+\texplicit JSONFunctionLocalState(ClientContext &context);\n+\tstatic unique_ptr<FunctionLocalState> Init(ExpressionState &state, const BoundFunctionExpression &expr,\n+\t                                           FunctionData *bind_data);\n+\tstatic JSONFunctionLocalState &ResetAndGet(ExpressionState &state);\n+\n+public:\n+\tJSONAllocator json_allocator;\n+};\n+\n class JSONFunctions {\n public:\n-\tstatic vector<CreateScalarFunctionInfo> GetFunctions() {\n-\t\tvector<CreateScalarFunctionInfo> functions;\n-\n-\t\t// Extract functions\n-\t\tAddAliases({\"json_extract\", \"json_extract_path\"}, GetExtractFunction(), functions);\n-\t\tAddAliases({\"json_extract_string\", \"json_extract_path_text\", \"->>\"}, GetExtractStringFunction(), functions);\n-\n-\t\t// Create functions\n-\t\tfunctions.push_back(GetArrayFunction());\n-\t\tfunctions.push_back(GetObjectFunction());\n-\t\tAddAliases({\"to_json\", \"json_quote\"}, GetToJSONFunction(), functions);\n-\t\tfunctions.push_back(GetArrayToJSONFunction());\n-\t\tfunctions.push_back(GetRowToJSONFunction());\n-\t\tfunctions.push_back(GetMergePatchFunction());\n-\n-\t\t// Structure/Transform\n-\t\tfunctions.push_back(GetStructureFunction());\n-\t\tAddAliases({\"json_transform\", \"from_json\"}, GetTransformFunction(), functions);\n-\t\tAddAliases({\"json_transform_strict\", \"from_json_strict\"}, GetTransformStrictFunction(), functions);\n-\n-\t\t// Other\n-\t\tfunctions.push_back(GetArrayLengthFunction());\n-\t\tfunctions.push_back(GetContainsFunction());\n-\t\tfunctions.push_back(GetTypeFunction());\n-\t\tfunctions.push_back(GetValidFunction());\n-\n-\t\treturn functions;\n-\t}\n+\tstatic vector<CreateScalarFunctionInfo> GetScalarFunctions();\n+\tstatic vector<CreateTableFunctionInfo> GetTableFunctions();\n+\tstatic void RegisterCastFunctions(CastFunctionSet &casts);\n \n private:\n+\t// Scalar functions\n \tstatic CreateScalarFunctionInfo GetExtractFunction();\n \tstatic CreateScalarFunctionInfo GetExtractStringFunction();\n \n@@ -63,13 +85,18 @@ class JSONFunctions {\n \tstatic CreateScalarFunctionInfo GetTypeFunction();\n \tstatic CreateScalarFunctionInfo GetValidFunction();\n \n-\tstatic void AddAliases(vector<string> names, CreateScalarFunctionInfo fun,\n-\t                       vector<CreateScalarFunctionInfo> &functions) {\n+\ttemplate <class FUNCTION_INFO>\n+\tstatic void AddAliases(vector<string> names, FUNCTION_INFO fun, vector<FUNCTION_INFO> &functions) {\n \t\tfor (auto &name : names) {\n \t\t\tfun.name = name;\n \t\t\tfunctions.push_back(fun);\n \t\t}\n \t}\n+\n+private:\n+\t// Table functions\n+\tstatic CreateTableFunctionInfo GetReadJSONObjectsFunction();\n+\tstatic CreateTableFunctionInfo GetReadNDJSONObjectsFunction();\n };\n \n } // namespace duckdb\ndiff --git a/extension/json/include/json_scan.hpp b/extension/json/include/json_scan.hpp\nnew file mode 100644\nindex 000000000000..c11d31ba60c6\n--- /dev/null\n+++ b/extension/json/include/json_scan.hpp\n@@ -0,0 +1,196 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// json_scan.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"buffered_json_reader.hpp\"\n+#include \"duckdb/common/mutex.hpp\"\n+#include \"duckdb/function/table_function.hpp\"\n+\n+namespace duckdb {\n+\n+struct JSONScanLocalState;\n+\n+struct JSONScanData : public TableFunctionData {\n+public:\n+\tJSONScanData();\n+\n+\tstatic unique_ptr<FunctionData> Bind(ClientContext &context, TableFunctionBindInput &input);\n+\tstatic void InitializeFilePaths(ClientContext &context, const vector<string> &patterns, vector<string> &file_paths);\n+\n+\tvoid Serialize(FieldWriter &writer);\n+\tvoid Deserialize(FieldReader &reader);\n+\n+public:\n+\t//! File-specific options\n+\tBufferedJSONReaderOptions options;\n+\t//! The files we're reading\n+\tvector<string> file_paths;\n+\n+\t//! Whether or not we should ignore malformed JSON (default to NULL)\n+\tbool ignore_errors = false;\n+\t//! Maximum JSON object size (defaults to 1MB)\n+\tidx_t maximum_object_size = 1048576;\n+\t//! Whether we return JSON strings (if not, we return YYJSON documents)\n+\tbool return_json_strings = true;\n+};\n+\n+struct JSONScanInfo : public TableFunctionInfo {\n+public:\n+\texplicit JSONScanInfo(JSONFormat forced_format_p, bool return_strings)\n+\t    : forced_format(forced_format_p), return_json_strings(return_strings) {\n+\t}\n+\n+\tJSONFormat forced_format;\n+\tbool return_json_strings;\n+};\n+\n+struct JSONScanGlobalState : public GlobalTableFunctionState {\n+public:\n+\tJSONScanGlobalState(ClientContext &context, JSONScanData &bind_data);\n+\tstatic unique_ptr<GlobalTableFunctionState> Init(ClientContext &context, TableFunctionInitInput &input);\n+\tidx_t MaxThreads() const override;\n+\n+public:\n+\t//! Bound data\n+\tJSONScanData &bind_data;\n+\n+\t//! Buffer manager allocator\n+\tAllocator &allocator;\n+\t//! The current buffer capacity\n+\tidx_t buffer_capacity;\n+\n+\tmutex lock;\n+\t//! One JSON reader per file\n+\tvector<unique_ptr<BufferedJSONReader>> json_readers;\n+\t//! Current file/batch index\n+\tidx_t file_index;\n+\tidx_t batch_index;\n+\n+\t//! Current number of threads active\n+\tidx_t system_threads;\n+};\n+\n+struct JSONLine {\n+public:\n+\tJSONLine() {\n+\t}\n+\tJSONLine(const char *pointer_p, idx_t size_p) : pointer(pointer_p), size(size_p) {\n+\t}\n+\n+\tconst char *pointer;\n+\tidx_t size;\n+\n+public:\n+\tstring ToString() {\n+\t\treturn string(pointer, size);\n+\t}\n+\n+\tconst char &operator[](size_t i) const {\n+\t\treturn pointer[i];\n+\t}\n+};\n+\n+struct JSONScanLocalState : public LocalTableFunctionState {\n+public:\n+\tJSONScanLocalState(ClientContext &context, JSONScanGlobalState &gstate);\n+\tstatic unique_ptr<LocalTableFunctionState> Init(ExecutionContext &context, TableFunctionInitInput &input,\n+\t                                                GlobalTableFunctionState *global_state);\n+\tidx_t ReadNext(JSONScanGlobalState &gstate);\n+\tidx_t GetBatchIndex() const;\n+\n+\tJSONLine lines[STANDARD_VECTOR_SIZE];\n+\tyyjson_doc *objects[STANDARD_VECTOR_SIZE];\n+\n+\tidx_t batch_index;\n+\n+private:\n+\tyyjson_doc *ParseLine(char *line_start, idx_t line_size, JSONLine &line, const bool &ignore_errors);\n+\n+private:\n+\t//! Thread-local allocator\n+\tJSONAllocator json_allocator;\n+\n+\t//! Current reader and buffer handle\n+\tBufferedJSONReader *current_reader;\n+\tJSONBufferHandle *current_buffer_handle;\n+\t//! Whether this is the last batch of the file\n+\tbool is_last;\n+\n+\t//! Current buffer read info\n+\tconst char *buffer_ptr;\n+\tidx_t buffer_size;\n+\tidx_t buffer_offset;\n+\tidx_t prev_buffer_remainder;\n+\n+\t//! Buffer to reconstruct split objects\n+\tAllocatedData reconstruct_buffer;\n+\t//! Copy of current buffer for YYJSON_READ_INSITU\n+\tAllocatedData current_buffer_copy;\n+\tconst char *buffer_copy_ptr;\n+\n+private:\n+\tbool ReadNextBuffer(JSONScanGlobalState &gstate, bool &first_read);\n+\tvoid ReadNextBufferSeek(JSONScanGlobalState &gstate, bool &first_read, idx_t &buffer_index);\n+\tvoid ReadNextBufferNoSeek(JSONScanGlobalState &gstate, bool &first_read, idx_t &buffer_index);\n+\n+\tvoid ReconstructFirstObject(JSONScanGlobalState &gstate);\n+\n+\tvoid ReadUnstructured(idx_t &count);\n+\tvoid ReadNewlineDelimited(idx_t &count, const bool &ignore_errors);\n+};\n+\n+struct JSONScan {\n+public:\n+\tstatic double JSONScanProgress(ClientContext &context, const FunctionData *bind_data_p,\n+\t                               const GlobalTableFunctionState *global_state) {\n+\t\tauto &gstate = (JSONScanGlobalState &)*global_state;\n+\t\tdouble progress = 0;\n+\t\tfor (auto &reader : gstate.json_readers) {\n+\t\t\tprogress += reader->GetProgress();\n+\t\t}\n+\t\treturn progress / double(gstate.json_readers.size());\n+\t}\n+\n+\tstatic idx_t JSONScanGetBatchIndex(ClientContext &context, const FunctionData *bind_data_p,\n+\t                                   LocalTableFunctionState *local_state, GlobalTableFunctionState *global_state) {\n+\t\tauto &lstate = (JSONScanLocalState &)*local_state;\n+\t\treturn lstate.GetBatchIndex();\n+\t}\n+\n+\tstatic void JSONScanSerialize(FieldWriter &writer, const FunctionData *bind_data_p, const TableFunction &function) {\n+\t\tauto &bind_data = (JSONScanData &)*bind_data_p;\n+\t\tbind_data.Serialize(writer);\n+\t\tbind_data.options.Serialize(writer);\n+\t}\n+\n+\tstatic unique_ptr<FunctionData> JSONScanDeserialize(ClientContext &context, FieldReader &reader,\n+\t                                                    TableFunction &function) {\n+\t\tauto result = make_unique<JSONScanData>();\n+\t\tresult->Deserialize(reader);\n+\t\treturn std::move(result);\n+\t}\n+\n+\tstatic void TableFunctionDefaults(TableFunction &table_function) {\n+\t\ttable_function.named_parameters[\"maximum_object_size\"] = LogicalType::UINTEGER;\n+\t\ttable_function.named_parameters[\"ignore_errors\"] = LogicalType::BOOLEAN;\n+\t\ttable_function.named_parameters[\"format\"] = LogicalType::VARCHAR;\n+\n+\t\ttable_function.table_scan_progress = JSONScanProgress;\n+\t\ttable_function.get_batch_index = JSONScanGetBatchIndex;\n+\n+\t\ttable_function.serialize = JSONScanSerialize;\n+\t\ttable_function.deserialize = JSONScanDeserialize;\n+\n+\t\ttable_function.projection_pushdown = false;\n+\t\ttable_function.filter_pushdown = false;\n+\t\ttable_function.filter_prune = false;\n+\t}\n+};\n+\n+} // namespace duckdb\ndiff --git a/extension/json/json-extension.cpp b/extension/json/json-extension.cpp\nindex 240a8df787fd..71d34f5a81e9 100644\n--- a/extension/json/json-extension.cpp\n+++ b/extension/json/json-extension.cpp\n@@ -3,10 +3,13 @@\n \n #include \"duckdb/catalog/catalog_entry/macro_catalog_entry.hpp\"\n #include \"duckdb/catalog/default/default_functions.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/function/cast/cast_function_set.hpp\"\n #include \"duckdb/parser/expression/constant_expression.hpp\"\n #include \"duckdb/parser/expression/function_expression.hpp\"\n+#include \"duckdb/parser/parsed_data/create_type_info.hpp\"\n #include \"duckdb/parser/tableref/table_function_ref.hpp\"\n-#include \"duckdb/common/string_util.hpp\"\n+#include \"json_common.hpp\"\n #include \"json_functions.hpp\"\n \n namespace duckdb {\n@@ -18,31 +21,37 @@ static DefaultMacro json_macros[] = {\n     {DEFAULT_SCHEMA, \"json\", {\"x\", nullptr}, \"json_extract(x, '$')\"},\n     {nullptr, nullptr, {nullptr}, nullptr}};\n \n-static DefaultMacro table_macros[] = {\n-    {DEFAULT_SCHEMA,\n-     \"read_json_objects\",\n-     {\"json_file\", nullptr},\n-     \"SELECT * FROM read_csv(json_file, columns={'json': 'JSON'}, delim=NULL, header=0, quote=NULL, escape=NULL)\"},\n-    {DEFAULT_SCHEMA, \"read_ndjson_objects\", {\"json_file\", nullptr}, \"SELECT * FROM read_json_objects(json_file)\"},\n-    {nullptr, nullptr, {nullptr}, nullptr}};\n-\n void JSONExtension::Load(DuckDB &db) {\n \tConnection con(db);\n \tcon.BeginTransaction();\n-\n \tauto &catalog = Catalog::GetSystemCatalog(*con.context);\n-\tfor (auto &fun : JSONFunctions::GetFunctions()) {\n+\n+\t// JSON type\n+\tauto json_type = JSONCommon::JSONType();\n+\tCreateTypeInfo type_info(JSONCommon::JSON_TYPE_NAME, json_type);\n+\ttype_info.temporary = true;\n+\ttype_info.internal = true;\n+\tcatalog.CreateType(*con.context, &type_info);\n+\n+\t// JSON casts\n+\tJSONFunctions::RegisterCastFunctions(DBConfig::GetConfig(*con.context).GetCastFunctions());\n+\n+\t// JSON scalar functions\n+\tfor (auto &fun : JSONFunctions::GetScalarFunctions()) {\n \t\tcatalog.CreateFunction(*con.context, &fun);\n \t}\n \n+\t// JSON table functions\n+\tfor (auto &fun : JSONFunctions::GetTableFunctions()) {\n+\t\tcatalog.CreateTableFunction(*con.context, &fun);\n+\t}\n+\n+\t// JSON macro's\n \tfor (idx_t index = 0; json_macros[index].name != nullptr; index++) {\n \t\tauto info = DefaultFunctionGenerator::CreateInternalMacroInfo(json_macros[index]);\n \t\tcatalog.CreateFunction(*con.context, info.get());\n \t}\n-\tfor (idx_t index = 0; table_macros[index].name != nullptr; index++) {\n-\t\tauto info = DefaultFunctionGenerator::CreateInternalTableMacroInfo(table_macros[index]);\n-\t\tcatalog.CreateFunction(*con.context, info.get());\n-\t}\n+\n \tcon.Commit();\n }\n \ndiff --git a/extension/json/json_common.cpp b/extension/json/json_common.cpp\nindex 62964f6c639c..bb49c6fc82dd 100644\n--- a/extension/json/json_common.cpp\n+++ b/extension/json/json_common.cpp\n@@ -2,97 +2,12 @@\n \n namespace duckdb {\n \n-static void CheckPath(const Value &path_val, string &path, size_t &len) {\n-\tstring error;\n-\tValue path_str_val;\n-\tif (!path_val.DefaultTryCastAs(LogicalType::VARCHAR, path_str_val, &error)) {\n-\t\tthrow InvalidInputException(error);\n-\t}\n-\tauto path_str = path_str_val.GetValueUnsafe<string_t>();\n-\tlen = path_str.GetSize();\n-\tauto ptr = path_str.GetDataUnsafe();\n-\t// Empty strings and invalid $ paths yield an error\n-\tif (len == 0) {\n-\t\tthrow InvalidInputException(\"Empty JSON path\");\n-\t}\n-\tif (*ptr == '$') {\n-\t\tJSONCommon::ValidatePathDollar(ptr, len);\n-\t}\n-\t// Copy over string to the bind data\n-\tif (*ptr == '/' || *ptr == '$') {\n-\t\tpath = string(ptr, len);\n-\t} else {\n-\t\tpath = \"/\" + string(ptr, len);\n-\t\tlen++;\n-\t}\n-}\n-\n-JSONReadFunctionData::JSONReadFunctionData(bool constant, string path_p, idx_t len)\n-    : constant(constant), path(std::move(path_p)), ptr(path.c_str()), len(len) {\n-}\n-\n-unique_ptr<FunctionData> JSONReadFunctionData::Copy() const {\n-\treturn make_unique<JSONReadFunctionData>(constant, path, len);\n-}\n-\n-bool JSONReadFunctionData::Equals(const FunctionData &other_p) const {\n-\tauto &other = (const JSONReadFunctionData &)other_p;\n-\treturn constant == other.constant && path == other.path && len == other.len;\n-}\n-\n-unique_ptr<FunctionData> JSONReadFunctionData::Bind(ClientContext &context, ScalarFunction &bound_function,\n-                                                    vector<unique_ptr<Expression>> &arguments) {\n-\tD_ASSERT(bound_function.arguments.size() == 2);\n-\tbool constant = false;\n-\tstring path = \"\";\n-\tsize_t len = 0;\n-\tif (arguments[1]->return_type.id() != LogicalTypeId::SQLNULL && arguments[1]->IsFoldable()) {\n-\t\tconstant = true;\n-\t\tconst auto path_val = ExpressionExecutor::EvaluateScalar(context, *arguments[1]);\n-\t\tCheckPath(path_val, path, len);\n-\t}\n-\treturn make_unique<JSONReadFunctionData>(constant, std::move(path), len);\n-}\n-\n-JSONReadManyFunctionData::JSONReadManyFunctionData(vector<string> paths_p, vector<size_t> lens_p)\n-    : paths(std::move(paths_p)), lens(std::move(lens_p)) {\n-\tfor (const auto &path : paths) {\n-\t\tptrs.push_back(path.c_str());\n-\t}\n-}\n-\n-unique_ptr<FunctionData> JSONReadManyFunctionData::Copy() const {\n-\treturn make_unique<JSONReadManyFunctionData>(paths, lens);\n-}\n-\n-bool JSONReadManyFunctionData::Equals(const FunctionData &other_p) const {\n-\tauto &other = (const JSONReadManyFunctionData &)other_p;\n-\treturn paths == other.paths && lens == other.lens;\n-}\n-\n-unique_ptr<FunctionData> JSONReadManyFunctionData::Bind(ClientContext &context, ScalarFunction &bound_function,\n-                                                        vector<unique_ptr<Expression>> &arguments) {\n-\tD_ASSERT(bound_function.arguments.size() == 2);\n-\tif (arguments[1]->HasParameter()) {\n-\t\tthrow ParameterNotResolvedException();\n-\t}\n-\tif (!arguments[1]->IsFoldable()) {\n-\t\tthrow InvalidInputException(\"List of paths must be constant\");\n-\t}\n-\tif (arguments[1]->return_type.id() == LogicalTypeId::SQLNULL) {\n-\t\treturn make_unique<JSONReadManyFunctionData>(vector<string>(), vector<size_t>());\n-\t}\n-\n-\tvector<string> paths;\n-\tvector<size_t> lens;\n-\tauto paths_val = ExpressionExecutor::EvaluateScalar(context, *arguments[1]);\n-\tfor (auto &path_val : ListValue::GetChildren(paths_val)) {\n-\t\tpaths.emplace_back(\"\");\n-\t\tlens.push_back(0);\n-\t\tCheckPath(path_val, paths.back(), lens.back());\n-\t}\n-\n-\treturn make_unique<JSONReadManyFunctionData>(std::move(paths), std::move(lens));\n+void JSONCommon::ThrowValFormatError(string error_string, yyjson_val *val) {\n+\tJSONAllocator json_allocator(Allocator::DefaultAllocator());\n+\tidx_t len;\n+\tauto data = JSONCommon::WriteVal<yyjson_val>(val, json_allocator.GetYYJSONAllocator(), len);\n+\terror_string = StringUtil::Format(error_string, string(data, len));\n+\tthrow InvalidInputException(error_string);\n }\n \n string ThrowPathError(const char *ptr, const char *end) {\ndiff --git a/extension/json/json_config.py b/extension/json/json_config.py\nindex 787f19c62ebb..11811ed66915 100644\n--- a/extension/json/json_config.py\n+++ b/extension/json/json_config.py\n@@ -2,4 +2,4 @@\n # list all include directories\n include_directories = [os.path.sep.join(x.split('/')) for x in ['extension/json/include', 'extension/json/yyjson/include']]\n # source files\n-source_files = [os.path.sep.join(x.split('/')) for x in ['extension/json/json-extension.cpp', 'extension/json/json_common.cpp', 'extension/json/json_functions/json_array_length.cpp', 'extension/json/json_functions/json_contains.cpp', 'extension/json/json_functions/json_extract.cpp', 'extension/json/json_functions/json_merge_patch.cpp', 'extension/json/json_functions/json_structure.cpp', 'extension/json/json_functions/json_transform.cpp', 'extension/json/json_functions/json_create.cpp', 'extension/json/json_functions/json_type.cpp', 'extension/json/json_functions/json_valid.cpp', 'extension/json/yyjson/yyjson.cpp']]\n+source_files = [os.path.sep.join(x.split('/')) for x in ['extension/json/buffered_json_reader.cpp', 'extension/json/json-extension.cpp', 'extension/json/json_common.cpp', 'extension/json/json_functions.cpp', 'extension/json/json_scan.cpp', 'extension/json/json_functions/json_array_length.cpp', 'extension/json/json_functions/json_contains.cpp', 'extension/json/json_functions/json_extract.cpp', 'extension/json/json_functions/json_merge_patch.cpp', 'extension/json/json_functions/json_structure.cpp', 'extension/json/json_functions/json_transform.cpp', 'extension/json/json_functions/json_create.cpp', 'extension/json/json_functions/json_type.cpp', 'extension/json/json_functions/json_valid.cpp', 'extension/json/json_functions/read_json_objects.cpp', 'extension/json/yyjson/yyjson.cpp']]\ndiff --git a/extension/json/json_functions.cpp b/extension/json/json_functions.cpp\nnew file mode 100644\nindex 000000000000..0b055e0b5f10\n--- /dev/null\n+++ b/extension/json/json_functions.cpp\n@@ -0,0 +1,200 @@\n+#include \"json_functions.hpp\"\n+\n+#include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/function/cast/cast_function_set.hpp\"\n+#include \"duckdb/function/cast/default_casts.hpp\"\n+\n+namespace duckdb {\n+\n+static void CheckPath(const Value &path_val, string &path, size_t &len) {\n+\tstring error;\n+\tValue path_str_val;\n+\tif (!path_val.DefaultTryCastAs(LogicalType::VARCHAR, path_str_val, &error)) {\n+\t\tthrow InvalidInputException(error);\n+\t}\n+\tauto path_str = path_str_val.GetValueUnsafe<string_t>();\n+\tlen = path_str.GetSize();\n+\tauto ptr = path_str.GetDataUnsafe();\n+\t// Empty strings and invalid $ paths yield an error\n+\tif (len == 0) {\n+\t\tthrow InvalidInputException(\"Empty JSON path\");\n+\t}\n+\tif (*ptr == '$') {\n+\t\tJSONCommon::ValidatePathDollar(ptr, len);\n+\t}\n+\t// Copy over string to the bind data\n+\tif (*ptr == '/' || *ptr == '$') {\n+\t\tpath = string(ptr, len);\n+\t} else {\n+\t\tpath = \"/\" + string(ptr, len);\n+\t\tlen++;\n+\t}\n+}\n+\n+JSONReadFunctionData::JSONReadFunctionData(bool constant, string path_p, idx_t len)\n+    : constant(constant), path(std::move(path_p)), ptr(path.c_str()), len(len) {\n+}\n+\n+unique_ptr<FunctionData> JSONReadFunctionData::Copy() const {\n+\treturn make_unique<JSONReadFunctionData>(constant, path, len);\n+}\n+\n+bool JSONReadFunctionData::Equals(const FunctionData &other_p) const {\n+\tauto &other = (const JSONReadFunctionData &)other_p;\n+\treturn constant == other.constant && path == other.path && len == other.len;\n+}\n+\n+unique_ptr<FunctionData> JSONReadFunctionData::Bind(ClientContext &context, ScalarFunction &bound_function,\n+                                                    vector<unique_ptr<Expression>> &arguments) {\n+\tD_ASSERT(bound_function.arguments.size() == 2);\n+\tbool constant = false;\n+\tstring path = \"\";\n+\tsize_t len = 0;\n+\tif (arguments[1]->return_type.id() != LogicalTypeId::SQLNULL && arguments[1]->IsFoldable()) {\n+\t\tconstant = true;\n+\t\tconst auto path_val = ExpressionExecutor::EvaluateScalar(context, *arguments[1]);\n+\t\tCheckPath(path_val, path, len);\n+\t}\n+\treturn make_unique<JSONReadFunctionData>(constant, std::move(path), len);\n+}\n+\n+JSONReadManyFunctionData::JSONReadManyFunctionData(vector<string> paths_p, vector<size_t> lens_p)\n+    : paths(std::move(paths_p)), lens(std::move(lens_p)) {\n+\tfor (const auto &path : paths) {\n+\t\tptrs.push_back(path.c_str());\n+\t}\n+}\n+\n+unique_ptr<FunctionData> JSONReadManyFunctionData::Copy() const {\n+\treturn make_unique<JSONReadManyFunctionData>(paths, lens);\n+}\n+\n+bool JSONReadManyFunctionData::Equals(const FunctionData &other_p) const {\n+\tauto &other = (const JSONReadManyFunctionData &)other_p;\n+\treturn paths == other.paths && lens == other.lens;\n+}\n+\n+unique_ptr<FunctionData> JSONReadManyFunctionData::Bind(ClientContext &context, ScalarFunction &bound_function,\n+                                                        vector<unique_ptr<Expression>> &arguments) {\n+\tD_ASSERT(bound_function.arguments.size() == 2);\n+\tif (arguments[1]->HasParameter()) {\n+\t\tthrow ParameterNotResolvedException();\n+\t}\n+\tif (!arguments[1]->IsFoldable()) {\n+\t\tthrow InvalidInputException(\"List of paths must be constant\");\n+\t}\n+\tif (arguments[1]->return_type.id() == LogicalTypeId::SQLNULL) {\n+\t\treturn make_unique<JSONReadManyFunctionData>(vector<string>(), vector<size_t>());\n+\t}\n+\n+\tvector<string> paths;\n+\tvector<size_t> lens;\n+\tauto paths_val = ExpressionExecutor::EvaluateScalar(context, *arguments[1]);\n+\tfor (auto &path_val : ListValue::GetChildren(paths_val)) {\n+\t\tpaths.emplace_back(\"\");\n+\t\tlens.push_back(0);\n+\t\tCheckPath(path_val, paths.back(), lens.back());\n+\t}\n+\n+\treturn make_unique<JSONReadManyFunctionData>(std::move(paths), std::move(lens));\n+}\n+\n+JSONFunctionLocalState::JSONFunctionLocalState(ClientContext &context) : json_allocator(BufferAllocator::Get(context)) {\n+}\n+\n+unique_ptr<FunctionLocalState> JSONFunctionLocalState::Init(ExpressionState &state, const BoundFunctionExpression &expr,\n+                                                            FunctionData *bind_data) {\n+\treturn make_unique<JSONFunctionLocalState>(state.GetContext());\n+}\n+\n+JSONFunctionLocalState &JSONFunctionLocalState::ResetAndGet(ExpressionState &state) {\n+\tauto &lstate = (JSONFunctionLocalState &)*ExecuteFunctionState::GetFunctionState(state);\n+\tlstate.json_allocator.Reset();\n+\treturn lstate;\n+}\n+\n+vector<CreateScalarFunctionInfo> JSONFunctions::GetScalarFunctions() {\n+\tvector<CreateScalarFunctionInfo> functions;\n+\n+\t// Extract functions\n+\tAddAliases({\"json_extract\", \"json_extract_path\"}, GetExtractFunction(), functions);\n+\tAddAliases({\"json_extract_string\", \"json_extract_path_text\", \"->>\"}, GetExtractStringFunction(), functions);\n+\n+\t// Create functions\n+\tfunctions.push_back(GetArrayFunction());\n+\tfunctions.push_back(GetObjectFunction());\n+\tAddAliases({\"to_json\", \"json_quote\"}, GetToJSONFunction(), functions);\n+\tfunctions.push_back(GetArrayToJSONFunction());\n+\tfunctions.push_back(GetRowToJSONFunction());\n+\tfunctions.push_back(GetMergePatchFunction());\n+\n+\t// Structure/Transform\n+\tfunctions.push_back(GetStructureFunction());\n+\tAddAliases({\"json_transform\", \"from_json\"}, GetTransformFunction(), functions);\n+\tAddAliases({\"json_transform_strict\", \"from_json_strict\"}, GetTransformStrictFunction(), functions);\n+\n+\t// Other\n+\tfunctions.push_back(GetArrayLengthFunction());\n+\tfunctions.push_back(GetContainsFunction());\n+\tfunctions.push_back(GetTypeFunction());\n+\tfunctions.push_back(GetValidFunction());\n+\n+\treturn functions;\n+}\n+\n+vector<CreateTableFunctionInfo> JSONFunctions::GetTableFunctions() {\n+\tvector<CreateTableFunctionInfo> functions;\n+\n+\t// Reads JSON as string\n+\tfunctions.push_back(GetReadJSONObjectsFunction());\n+\tfunctions.push_back(GetReadNDJSONObjectsFunction());\n+\n+\treturn functions;\n+}\n+\n+static unique_ptr<FunctionLocalState> InitJSONCastLocalState(ClientContext &context) {\n+\treturn make_unique<JSONFunctionLocalState>(context);\n+}\n+\n+static bool CastVarcharToJSON(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {\n+\tauto &lstate = (JSONFunctionLocalState &)*parameters.local_state;\n+\tlstate.json_allocator.Reset();\n+\tauto alc = lstate.json_allocator.GetYYJSONAllocator();\n+\n+\tbool success = true;\n+\tUnaryExecutor::ExecuteWithNulls<string_t, string_t>(\n+\t    source, result, count, [&](string_t input, ValidityMask &mask, idx_t idx) {\n+\t\t    auto data = (char *)(input.GetDataUnsafe());\n+\t\t    auto length = input.GetSize();\n+\t\t    yyjson_read_err error;\n+\n+\t\t    auto doc = JSONCommon::ReadDocumentUnsafe(data, length, JSONCommon::READ_FLAG, alc, &error);\n+\n+\t\t    if (!doc) {\n+\t\t\t    HandleCastError::AssignError(JSONCommon::FormatParseError(data, length, error),\n+\t\t\t                                 parameters.error_message);\n+\t\t\t    mask.SetInvalid(idx);\n+\t\t\t    success = false;\n+\t\t    }\n+\n+\t\t    return input;\n+\t    });\n+\treturn success;\n+}\n+\n+void JSONFunctions::RegisterCastFunctions(CastFunctionSet &casts) {\n+\t// JSON to VARCHAR is basically free\n+\tcasts.RegisterCastFunction(JSONCommon::JSONType(), LogicalType::VARCHAR, DefaultCasts::ReinterpretCast, 1);\n+\n+\t// VARCHAR to JSON requires a parse so it's not free. Let's make it 1 more than a cast to STRUCT\n+\tauto varchar_to_json_cost = casts.ImplicitCastCost(LogicalType::SQLNULL, LogicalTypeId::STRUCT) + 1;\n+\tBoundCastInfo info(CastVarcharToJSON, nullptr, InitJSONCastLocalState);\n+\tcasts.RegisterCastFunction(LogicalType::VARCHAR, JSONCommon::JSONType(), std::move(info), varchar_to_json_cost);\n+\n+\t// Register NULL to JSON with a different cost than NULL to VARCHAR so the binder can disambiguate functions\n+\tauto null_to_json_cost = casts.ImplicitCastCost(LogicalType::SQLNULL, LogicalTypeId::VARCHAR) + 1;\n+\tcasts.RegisterCastFunction(LogicalType::SQLNULL, JSONCommon::JSONType(), DefaultCasts::ReinterpretCast,\n+\t                           null_to_json_cost);\n+}\n+\n+} // namespace duckdb\ndiff --git a/extension/json/json_functions/CMakeLists.txt b/extension/json/json_functions/CMakeLists.txt\nindex 26e00f6af361..293fd9419ca3 100644\n--- a/extension/json/json_functions/CMakeLists.txt\n+++ b/extension/json/json_functions/CMakeLists.txt\n@@ -9,7 +9,8 @@ add_library_unity(\n   json_transform.cpp\n   json_create.cpp\n   json_type.cpp\n-  json_valid.cpp)\n+  json_valid.cpp\n+  read_json_objects.cpp)\n set(ALL_OBJECT_FILES\n     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_json_functions>\n     PARENT_SCOPE)\ndiff --git a/extension/json/json_functions/json_array_length.cpp b/extension/json/json_functions/json_array_length.cpp\nindex e1a695b7a652..5fb92ff3749d 100644\n--- a/extension/json/json_functions/json_array_length.cpp\n+++ b/extension/json/json_functions/json_array_length.cpp\n@@ -1,32 +1,37 @@\n-#include \"json_common.hpp\"\n-#include \"json_functions.hpp\"\n+#include \"json_executors.hpp\"\n \n namespace duckdb {\n \n-static inline uint64_t GetArrayLength(yyjson_val *val, Vector &result) {\n+static inline uint64_t GetArrayLength(yyjson_val *val, yyjson_alc *alc, Vector &result) {\n \treturn yyjson_arr_size(val);\n }\n \n static void UnaryArrayLengthFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONCommon::UnaryExecute<uint64_t>(args, state, result, GetArrayLength);\n+\tJSONExecutors::UnaryExecute<uint64_t>(args, state, result, GetArrayLength);\n }\n \n static void BinaryArrayLengthFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONCommon::BinaryExecute<uint64_t>(args, state, result, GetArrayLength);\n+\tJSONExecutors::BinaryExecute<uint64_t>(args, state, result, GetArrayLength);\n }\n \n static void ManyArrayLengthFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONCommon::ExecuteMany<uint64_t>(args, state, result, GetArrayLength);\n+\tJSONExecutors::ExecuteMany<uint64_t>(args, state, result, GetArrayLength);\n+}\n+\n+static void GetArrayLengthFunctionsInternal(ScalarFunctionSet &set, const LogicalType &input_type) {\n+\tset.AddFunction(ScalarFunction({input_type}, LogicalType::UBIGINT, UnaryArrayLengthFunction, nullptr, nullptr,\n+\t                               nullptr, JSONFunctionLocalState::Init));\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::VARCHAR}, LogicalType::UBIGINT, BinaryArrayLengthFunction,\n+\t                               JSONReadFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::LIST(LogicalType::VARCHAR)},\n+\t                               LogicalType::LIST(LogicalType::UBIGINT), ManyArrayLengthFunction,\n+\t                               JSONReadManyFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetArrayLengthFunction() {\n \tScalarFunctionSet set(\"json_array_length\");\n-\tset.AddFunction(ScalarFunction({LogicalType::JSON}, LogicalType::UBIGINT, UnaryArrayLengthFunction));\n-\tset.AddFunction(ScalarFunction({LogicalType::JSON, LogicalType::VARCHAR}, LogicalType::UBIGINT,\n-\t                               BinaryArrayLengthFunction, JSONReadFunctionData::Bind));\n-\tset.AddFunction(ScalarFunction({LogicalType::JSON, LogicalType::LIST(LogicalType::VARCHAR)},\n-\t                               LogicalType::LIST(LogicalType::UBIGINT), ManyArrayLengthFunction,\n-\t                               JSONReadManyFunctionData::Bind));\n+\tGetArrayLengthFunctionsInternal(set, LogicalType::VARCHAR);\n+\tGetArrayLengthFunctionsInternal(set, JSONCommon::JSONType());\n \n \treturn CreateScalarFunctionInfo(std::move(set));\n }\ndiff --git a/extension/json/json_functions/json_contains.cpp b/extension/json/json_functions/json_contains.cpp\nindex e2ea3ab3adbd..c2c5f6e64cf5 100644\n--- a/extension/json/json_functions/json_contains.cpp\n+++ b/extension/json/json_functions/json_contains.cpp\n@@ -1,99 +1,150 @@\n-#include \"json_common.hpp\"\n-#include \"json_functions.hpp\"\n+#include \"json_executors.hpp\"\n \n namespace duckdb {\n \n-static inline bool JSONContainsRecursive(yyjson_val *haystack, yyjson_val *needle);\n+static inline bool JSONContains(yyjson_val *haystack, yyjson_val *needle);\n+static inline bool JSONFuzzyEquals(yyjson_val *haystack, yyjson_val *needle);\n \n-static inline bool JSONArrayContains(yyjson_val *haystack, yyjson_val *needle) {\n-\tsize_t idx, max;\n-\tyyjson_val *needle_child;\n-\tyyjson_arr_foreach(needle, idx, max, needle_child) {\n-\t\tif (!JSONContainsRecursive(haystack, needle_child)) {\n+static inline bool JSONArrayFuzzyEquals(yyjson_val *haystack, yyjson_val *needle) {\n+\tD_ASSERT(yyjson_get_tag(haystack) == (YYJSON_TYPE_ARR | YYJSON_SUBTYPE_NONE) &&\n+\t         yyjson_get_tag(needle) == (YYJSON_TYPE_ARR | YYJSON_SUBTYPE_NONE));\n+\n+\tsize_t needle_idx, needle_max, haystack_idx, haystack_max;\n+\tyyjson_val *needle_child, *haystack_child;\n+\tyyjson_arr_foreach(needle, needle_idx, needle_max, needle_child) {\n+\t\tbool found = false;\n+\t\tyyjson_arr_foreach(haystack, haystack_idx, haystack_max, haystack_child) {\n+\t\t\tif (JSONFuzzyEquals(haystack_child, needle_child)) {\n+\t\t\t\tfound = true;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tif (!found) {\n \t\t\treturn false;\n \t\t}\n \t}\n \treturn true;\n }\n \n-static inline bool JSONObjectContains(yyjson_val *haystack, yyjson_val *needle) {\n+static inline bool JSONObjectFuzzyEquals(yyjson_val *haystack, yyjson_val *needle) {\n+\tD_ASSERT(yyjson_get_tag(haystack) == (YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE) &&\n+\t         yyjson_get_tag(needle) == (YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE));\n+\n \tsize_t idx, max;\n \tyyjson_val *key, *needle_child;\n \tyyjson_obj_foreach(needle, idx, max, key, needle_child) {\n-\t\tif (!JSONContainsRecursive(haystack, needle_child)) {\n+\t\tauto haystack_child = yyjson_obj_get(haystack, yyjson_get_str(key));\n+\t\tif (!haystack_child || !JSONFuzzyEquals(haystack_child, needle_child)) {\n \t\t\treturn false;\n \t\t}\n \t}\n \treturn true;\n }\n \n-static inline bool JSONContainsRecursive(yyjson_val *haystack, yyjson_val *needle) {\n-\tif (yyjson_equals(haystack, needle)) {\n+static inline bool JSONFuzzyEquals(yyjson_val *haystack, yyjson_val *needle) {\n+\tD_ASSERT(haystack && needle);\n+\n+\t// Strict equality\n+\tif (unsafe_yyjson_equals(haystack, needle)) {\n \t\treturn true;\n \t}\n \n-\tswitch (yyjson_get_tag(haystack)) {\n-\tcase YYJSON_TYPE_ARR | YYJSON_SUBTYPE_NONE: {\n-\t\tif (yyjson_get_tag(needle) == (YYJSON_TYPE_ARR | YYJSON_SUBTYPE_NONE) && JSONArrayContains(haystack, needle)) {\n+\tauto haystack_tag = yyjson_get_tag(needle);\n+\tif (haystack_tag != yyjson_get_tag(haystack)) {\n+\t\treturn false;\n+\t}\n+\n+\t// Fuzzy equality (contained in)\n+\tswitch (haystack_tag) {\n+\tcase YYJSON_TYPE_ARR | YYJSON_SUBTYPE_NONE:\n+\t\treturn JSONArrayFuzzyEquals(haystack, needle);\n+\tcase YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE:\n+\t\treturn JSONObjectFuzzyEquals(haystack, needle);\n+\tdefault:\n+\t\treturn false;\n+\t}\n+}\n+\n+static inline bool JSONArrayContains(yyjson_val *haystack_array, yyjson_val *needle) {\n+\tD_ASSERT(yyjson_get_tag(haystack_array) == (YYJSON_TYPE_ARR | YYJSON_SUBTYPE_NONE));\n+\n+\tsize_t idx, max;\n+\tyyjson_val *child_haystack;\n+\tyyjson_arr_foreach(haystack_array, idx, max, child_haystack) {\n+\t\tif (JSONContains(child_haystack, needle)) {\n \t\t\treturn true;\n \t\t}\n-\t\tsize_t idx, max;\n-\t\tyyjson_val *child_haystack;\n-\t\tyyjson_arr_foreach(haystack, idx, max, child_haystack) {\n-\t\t\tif (JSONContainsRecursive(child_haystack, needle)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\tbreak;\n \t}\n-\tcase YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE: {\n-\t\tif (yyjson_get_tag(needle) == (YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE) && JSONObjectContains(haystack, needle)) {\n+\treturn false;\n+}\n+\n+static inline bool JSONObjectContains(yyjson_val *haystack_object, yyjson_val *needle) {\n+\tD_ASSERT(yyjson_get_tag(haystack_object) == (YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE));\n+\n+\tsize_t idx, max;\n+\tyyjson_val *key, *child_haystack;\n+\tyyjson_obj_foreach(haystack_object, idx, max, key, child_haystack) {\n+\t\tif (JSONContains(child_haystack, needle)) {\n \t\t\treturn true;\n \t\t}\n-\t\tsize_t idx, max;\n-\t\tyyjson_val *key, *child_haystack;\n-\t\tyyjson_obj_foreach(haystack, idx, max, key, child_haystack) {\n-\t\t\tif (JSONContainsRecursive(child_haystack, needle)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\tbreak;\n-\t}\n-\tdefault:\n-\t\tbreak;\n \t}\n \treturn false;\n }\n \n static inline bool JSONContains(yyjson_val *haystack, yyjson_val *needle) {\n-\treturn JSONContainsRecursive(haystack, needle);\n+\tif (JSONFuzzyEquals(haystack, needle)) {\n+\t\treturn true;\n+\t}\n+\n+\tswitch (yyjson_get_tag(haystack)) {\n+\tcase YYJSON_TYPE_ARR | YYJSON_SUBTYPE_NONE:\n+\t\treturn JSONArrayContains(haystack, needle);\n+\tcase YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE:\n+\t\treturn JSONObjectContains(haystack, needle);\n+\tdefault:\n+\t\treturn false;\n+\t}\n }\n \n static void JSONContainsFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tD_ASSERT(args.data.size() == 2);\n+\tauto &lstate = JSONFunctionLocalState::ResetAndGet(state);\n+\n \tauto &haystacks = args.data[0];\n \tauto &needles = args.data[1];\n \n \tif (needles.GetVectorType() == VectorType::CONSTANT_VECTOR) {\n \t\tauto &needle_str = *ConstantVector::GetData<string_t>(needles);\n-\t\tauto needle_doc = JSONCommon::ReadDocument(needle_str);\n+\t\tauto needle_doc =\n+\t\t    JSONCommon::ReadDocument(needle_str, JSONCommon::READ_FLAG, lstate.json_allocator.GetYYJSONAllocator());\n \t\tUnaryExecutor::Execute<string_t, bool>(haystacks, result, args.size(), [&](string_t haystack_str) {\n-\t\t\tauto haystack_doc = JSONCommon::ReadDocument(haystack_str);\n+\t\t\tauto haystack_doc = JSONCommon::ReadDocument(haystack_str, JSONCommon::READ_FLAG,\n+\t\t\t                                             lstate.json_allocator.GetYYJSONAllocator());\n \t\t\treturn JSONContains(haystack_doc->root, needle_doc->root);\n \t\t});\n \t} else {\n \t\tBinaryExecutor::Execute<string_t, string_t, bool>(\n-\t\t    haystacks, needles, result, args.size(), [](string_t haystack_str, string_t needle_str) {\n-\t\t\t    auto haystack_doc = JSONCommon::ReadDocument(haystack_str);\n-\t\t\t    auto needle_doc = JSONCommon::ReadDocument(needle_str);\n+\t\t    haystacks, needles, result, args.size(), [&](string_t haystack_str, string_t needle_str) {\n+\t\t\t    auto needle_doc = JSONCommon::ReadDocument(needle_str, JSONCommon::READ_FLAG,\n+\t\t\t                                               lstate.json_allocator.GetYYJSONAllocator());\n+\t\t\t    auto haystack_doc = JSONCommon::ReadDocument(haystack_str, JSONCommon::READ_FLAG,\n+\t\t\t                                                 lstate.json_allocator.GetYYJSONAllocator());\n \t\t\t    return JSONContains(haystack_doc->root, needle_doc->root);\n \t\t    });\n \t}\n }\n \n+static void GetContainsFunctionInternal(ScalarFunctionSet &set, const LogicalType &lhs, const LogicalType &rhs) {\n+\tset.AddFunction(ScalarFunction({lhs, rhs}, LogicalType::BOOLEAN, JSONContainsFunction, nullptr, nullptr, nullptr,\n+\t                               JSONFunctionLocalState::Init));\n+}\n+\n CreateScalarFunctionInfo JSONFunctions::GetContainsFunction() {\n \tScalarFunctionSet set(\"json_contains\");\n-\tset.AddFunction(ScalarFunction({LogicalType::JSON, LogicalType::JSON}, LogicalType::BOOLEAN, JSONContainsFunction));\n+\tGetContainsFunctionInternal(set, LogicalType::VARCHAR, LogicalType::VARCHAR);\n+\tGetContainsFunctionInternal(set, LogicalType::VARCHAR, JSONCommon::JSONType());\n+\tGetContainsFunctionInternal(set, JSONCommon::JSONType(), LogicalType::VARCHAR);\n+\tGetContainsFunctionInternal(set, JSONCommon::JSONType(), JSONCommon::JSONType());\n \t// TODO: implement json_contains that accepts path argument as well\n \n \treturn CreateScalarFunctionInfo(std::move(set));\ndiff --git a/extension/json/json_functions/json_create.cpp b/extension/json/json_functions/json_create.cpp\nindex 702d3cd496a0..2b044a0cdfcc 100644\n--- a/extension/json/json_functions/json_create.cpp\n+++ b/extension/json/json_functions/json_create.cpp\n@@ -1,6 +1,6 @@\n+#include \"duckdb/planner/expression/bound_parameter_expression.hpp\"\n #include \"json_common.hpp\"\n #include \"json_functions.hpp\"\n-#include \"duckdb/planner/expression/bound_parameter_expression.hpp\"\n \n namespace duckdb {\n \n@@ -28,10 +28,13 @@ struct JSONCreateFunctionData : public FunctionData {\n };\n \n static LogicalType GetJSONType(unordered_map<string, unique_ptr<Vector>> &const_struct_names, const LogicalType &type) {\n+\tif (JSONCommon::LogicalTypeIsJSON(type)) {\n+\t\treturn type;\n+\t}\n+\n \tswitch (type.id()) {\n \t// These types can go directly into JSON\n \tcase LogicalTypeId::SQLNULL:\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::BOOLEAN:\n \tcase LogicalTypeId::BIGINT:\n \tcase LogicalTypeId::UBIGINT:\n@@ -185,7 +188,7 @@ inline yyjson_mut_val *CreateJSONValue(yyjson_mut_doc *doc, const string_t &valu\n }\n \n inline yyjson_mut_val *CreateJSONValueFromJSON(yyjson_mut_doc *doc, const string_t &value) {\n-\tauto value_doc = JSONCommon::ReadDocument(value);\n+\tauto value_doc = JSONCommon::ReadDocument(value, JSONCommon::READ_FLAG, &doc->alc);\n \tauto result = yyjson_val_mut_copy(doc, value_doc->root);\n \treturn result;\n }\n@@ -228,12 +231,12 @@ static void TemplatedCreateValues(yyjson_mut_doc *doc, yyjson_mut_val *vals[], V\n \tvalue_v.ToUnifiedFormat(count, value_data);\n \tauto values = (T *)value_data.data;\n \n-\tconst auto value_type = value_v.GetType().id();\n+\tconst auto type_is_json = JSONCommon::LogicalTypeIsJSON(value_v.GetType());\n \tfor (idx_t i = 0; i < count; i++) {\n \t\tidx_t val_idx = value_data.sel->get_index(i);\n \t\tif (!value_data.validity.RowIsValid(val_idx)) {\n \t\t\tvals[i] = yyjson_mut_null(doc);\n-\t\t} else if (value_type == LogicalTypeId::JSON) {\n+\t\t} else if (type_is_json) {\n \t\t\tvals[i] = CreateJSONValueFromJSON(doc, (string_t &)values[val_idx]);\n \t\t} else {\n \t\t\tvals[i] = CreateJSONValue<T>(doc, values[val_idx]);\n@@ -401,7 +404,6 @@ static void CreateValues(const JSONCreateFunctionData &info, yyjson_mut_doc *doc\n \t\tTemplatedCreateValues<double>(doc, vals, value_v, count);\n \t\tbreak;\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\tTemplatedCreateValues<string_t>(doc, vals, value_v, count);\n \t\tbreak;\n \tcase LogicalTypeId::STRUCT:\n@@ -424,12 +426,15 @@ static void CreateValues(const JSONCreateFunctionData &info, yyjson_mut_doc *doc\n static void ObjectFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tauto &func_expr = (BoundFunctionExpression &)state.expr;\n \tconst auto &info = (JSONCreateFunctionData &)*func_expr.bind_info;\n+\tauto &lstate = JSONFunctionLocalState::ResetAndGet(state);\n+\tauto alc = lstate.json_allocator.GetYYJSONAllocator();\n+\n \t// Initialize objects\n \tconst idx_t count = args.size();\n-\tauto doc = JSONCommon::CreateDocument();\n+\tauto doc = JSONCommon::CreateDocument(alc);\n \tyyjson_mut_val *objs[STANDARD_VECTOR_SIZE];\n \tfor (idx_t i = 0; i < count; i++) {\n-\t\tobjs[i] = yyjson_mut_obj(*doc);\n+\t\tobjs[i] = yyjson_mut_obj(doc);\n \t}\n \t// Initialize a re-usable value array\n \tyyjson_mut_val *vals[STANDARD_VECTOR_SIZE];\n@@ -437,13 +442,12 @@ static void ObjectFunction(DataChunk &args, ExpressionState &state, Vector &resu\n \tfor (idx_t pair_idx = 0; pair_idx < args.data.size() / 2; pair_idx++) {\n \t\tVector &key_v = args.data[pair_idx * 2];\n \t\tVector &value_v = args.data[pair_idx * 2 + 1];\n-\t\tCreateKeyValuePairs(info, *doc, objs, vals, key_v, value_v, count);\n+\t\tCreateKeyValuePairs(info, doc, objs, vals, key_v, value_v, count);\n \t}\n \t// Write JSON objects to string\n \tauto objects = FlatVector::GetData<string_t>(result);\n \tfor (idx_t i = 0; i < count; i++) {\n-\t\tyyjson_mut_doc_set_root(*doc, objs[i]);\n-\t\tobjects[i] = JSONCommon::WriteDoc(*doc, result);\n+\t\tobjects[i] = JSONCommon::WriteVal<yyjson_mut_val>(objs[i], alc);\n \t}\n \n \tif (args.AllConstant()) {\n@@ -454,18 +458,21 @@ static void ObjectFunction(DataChunk &args, ExpressionState &state, Vector &resu\n static void ArrayFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tauto &func_expr = (BoundFunctionExpression &)state.expr;\n \tconst auto &info = (JSONCreateFunctionData &)*func_expr.bind_info;\n+\tauto &lstate = JSONFunctionLocalState::ResetAndGet(state);\n+\tauto alc = lstate.json_allocator.GetYYJSONAllocator();\n+\n \t// Initialize arrays\n \tconst idx_t count = args.size();\n-\tauto doc = JSONCommon::CreateDocument();\n+\tauto doc = JSONCommon::CreateDocument(alc);\n \tyyjson_mut_val *arrs[STANDARD_VECTOR_SIZE];\n \tfor (idx_t i = 0; i < count; i++) {\n-\t\tarrs[i] = yyjson_mut_arr(*doc);\n+\t\tarrs[i] = yyjson_mut_arr(doc);\n \t}\n \t// Initialize a re-usable value array\n \tyyjson_mut_val *vals[STANDARD_VECTOR_SIZE];\n \t// Loop through args\n \tfor (auto &v : args.data) {\n-\t\tCreateValues(info, *doc, vals, v, count);\n+\t\tCreateValues(info, doc, vals, v, count);\n \t\tfor (idx_t i = 0; i < count; i++) {\n \t\t\tyyjson_mut_arr_append(arrs[i], vals[i]);\n \t\t}\n@@ -473,8 +480,7 @@ static void ArrayFunction(DataChunk &args, ExpressionState &state, Vector &resul\n \t// Write JSON arrays to string\n \tauto objects = FlatVector::GetData<string_t>(result);\n \tfor (idx_t i = 0; i < count; i++) {\n-\t\tyyjson_mut_doc_set_root(*doc, arrs[i]);\n-\t\tobjects[i] = JSONCommon::WriteDoc(*doc, result);\n+\t\tobjects[i] = JSONCommon::WriteVal<yyjson_mut_val>(arrs[i], alc);\n \t}\n \n \tif (args.AllConstant()) {\n@@ -485,11 +491,14 @@ static void ArrayFunction(DataChunk &args, ExpressionState &state, Vector &resul\n static void ToJSONFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tauto &func_expr = (BoundFunctionExpression &)state.expr;\n \tconst auto &info = (JSONCreateFunctionData &)*func_expr.bind_info;\n+\tauto &lstate = JSONFunctionLocalState::ResetAndGet(state);\n+\tauto alc = lstate.json_allocator.GetYYJSONAllocator();\n+\n \t// Initialize array for values\n \tconst idx_t count = args.size();\n-\tauto doc = JSONCommon::CreateDocument();\n+\tauto doc = JSONCommon::CreateDocument(alc);\n \tyyjson_mut_val *vals[STANDARD_VECTOR_SIZE];\n-\tCreateValues(info, *doc, vals, args.data[0], count);\n+\tCreateValues(info, doc, vals, args.data[0], count);\n \t// Write JSON values to string\n \tauto objects = FlatVector::GetData<string_t>(result);\n \tauto &result_validity = FlatVector::Validity(result);\n@@ -498,8 +507,7 @@ static void ToJSONFunction(DataChunk &args, ExpressionState &state, Vector &resu\n \tfor (idx_t i = 0; i < count; i++) {\n \t\tidx_t idx = input_data.sel->get_index(i);\n \t\tif (input_data.validity.RowIsValid(idx)) {\n-\t\t\tyyjson_mut_doc_set_root(*doc, vals[i]);\n-\t\t\tobjects[i] = JSONCommon::WriteDoc(*doc, result);\n+\t\t\tobjects[i] = JSONCommon::WriteVal<yyjson_mut_val>(vals[i], alc);\n \t\t} else {\n \t\t\tresult_validity.SetInvalid(i);\n \t\t}\n@@ -511,33 +519,38 @@ static void ToJSONFunction(DataChunk &args, ExpressionState &state, Vector &resu\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetObjectFunction() {\n-\tauto fun = ScalarFunction(\"json_object\", {}, LogicalType::JSON, ObjectFunction, JSONObjectBind);\n+\tauto fun = ScalarFunction(\"json_object\", {}, JSONCommon::JSONType(), ObjectFunction, JSONObjectBind, nullptr,\n+\t                          nullptr, JSONFunctionLocalState::Init);\n \tfun.varargs = LogicalType::ANY;\n \tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \treturn CreateScalarFunctionInfo(fun);\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetArrayFunction() {\n-\tauto fun = ScalarFunction(\"json_array\", {}, LogicalType::JSON, ArrayFunction, JSONArrayBind);\n+\tauto fun = ScalarFunction(\"json_array\", {}, JSONCommon::JSONType(), ArrayFunction, JSONArrayBind, nullptr, nullptr,\n+\t                          JSONFunctionLocalState::Init);\n \tfun.varargs = LogicalType::ANY;\n \tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \treturn CreateScalarFunctionInfo(fun);\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetToJSONFunction() {\n-\tauto fun = ScalarFunction(\"to_json\", {}, LogicalType::JSON, ToJSONFunction, ToJSONBind);\n+\tauto fun = ScalarFunction(\"to_json\", {}, JSONCommon::JSONType(), ToJSONFunction, ToJSONBind, nullptr, nullptr,\n+\t                          JSONFunctionLocalState::Init);\n \tfun.varargs = LogicalType::ANY;\n \treturn CreateScalarFunctionInfo(fun);\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetArrayToJSONFunction() {\n-\tauto fun = ScalarFunction(\"array_to_json\", {}, LogicalType::JSON, ToJSONFunction, ArrayToJSONBind);\n+\tauto fun = ScalarFunction(\"array_to_json\", {}, JSONCommon::JSONType(), ToJSONFunction, ArrayToJSONBind, nullptr,\n+\t                          nullptr, JSONFunctionLocalState::Init);\n \tfun.varargs = LogicalType::ANY;\n \treturn CreateScalarFunctionInfo(fun);\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetRowToJSONFunction() {\n-\tauto fun = ScalarFunction(\"row_to_json\", {}, LogicalType::JSON, ToJSONFunction, RowToJSONBind);\n+\tauto fun = ScalarFunction(\"row_to_json\", {}, JSONCommon::JSONType(), ToJSONFunction, RowToJSONBind, nullptr,\n+\t                          nullptr, JSONFunctionLocalState::Init);\n \tfun.varargs = LogicalType::ANY;\n \treturn CreateScalarFunctionInfo(fun);\n }\ndiff --git a/extension/json/json_functions/json_extract.cpp b/extension/json/json_functions/json_extract.cpp\nindex 3da83f78ea90..e7e5ff42d3a1 100644\n--- a/extension/json/json_functions/json_extract.cpp\n+++ b/extension/json/json_functions/json_extract.cpp\n@@ -1,53 +1,62 @@\n-#include \"json_common.hpp\"\n-#include \"json_functions.hpp\"\n+#include \"json_executors.hpp\"\n \n namespace duckdb {\n \n-static inline string_t ExtractFromVal(yyjson_val *val, Vector &result) {\n-\treturn JSONCommon::WriteVal(val, result);\n+static inline string_t ExtractFromVal(yyjson_val *val, yyjson_alc *alc, Vector &result) {\n+\treturn JSONCommon::WriteVal<yyjson_val>(val, alc);\n }\n \n-static inline string_t ExtractStringFromVal(yyjson_val *val, Vector &result) {\n+static inline string_t ExtractStringFromVal(yyjson_val *val, yyjson_alc *alc, Vector &result) {\n \treturn yyjson_is_str(val) ? StringVector::AddString(result, unsafe_yyjson_get_str(val), unsafe_yyjson_get_len(val))\n-\t                          : JSONCommon::WriteVal(val, result);\n+\t                          : JSONCommon::WriteVal<yyjson_val>(val, alc);\n }\n \n static void ExtractFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONCommon::BinaryExecute<string_t>(args, state, result, ExtractFromVal);\n+\tJSONExecutors::BinaryExecute<string_t>(args, state, result, ExtractFromVal);\n }\n \n static void ExtractManyFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONCommon::ExecuteMany<string_t>(args, state, result, ExtractFromVal);\n+\tJSONExecutors::ExecuteMany<string_t>(args, state, result, ExtractFromVal);\n }\n \n static void ExtractStringFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONCommon::BinaryExecute<string_t>(args, state, result, ExtractStringFromVal);\n+\tJSONExecutors::BinaryExecute<string_t>(args, state, result, ExtractStringFromVal);\n }\n \n static void ExtractStringManyFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONCommon::ExecuteMany<string_t>(args, state, result, ExtractStringFromVal);\n+\tJSONExecutors::ExecuteMany<string_t>(args, state, result, ExtractStringFromVal);\n+}\n+\n+static void GetExtractFunctionsInternal(ScalarFunctionSet &set, const LogicalType &input_type) {\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::VARCHAR}, JSONCommon::JSONType(), ExtractFunction,\n+\t                               JSONReadFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::LIST(LogicalType::VARCHAR)},\n+\t                               LogicalType::LIST(JSONCommon::JSONType()), ExtractManyFunction,\n+\t                               JSONReadManyFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetExtractFunction() {\n \t// Generic extract function\n \tScalarFunctionSet set(\"json_extract\");\n-\tset.AddFunction(ScalarFunction({LogicalType::JSON, LogicalType::VARCHAR}, LogicalType::JSON, ExtractFunction,\n-\t                               JSONReadFunctionData::Bind));\n-\tset.AddFunction(ScalarFunction({LogicalType::JSON, LogicalType::LIST(LogicalType::VARCHAR)},\n-\t                               LogicalType::LIST(LogicalType::JSON), ExtractManyFunction,\n-\t                               JSONReadManyFunctionData::Bind));\n+\tGetExtractFunctionsInternal(set, LogicalType::VARCHAR);\n+\tGetExtractFunctionsInternal(set, JSONCommon::JSONType());\n \n \treturn CreateScalarFunctionInfo(set);\n }\n \n+static void GetExtractStringFunctionsInternal(ScalarFunctionSet &set, const LogicalType &input_type) {\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::VARCHAR}, LogicalType::VARCHAR, ExtractStringFunction,\n+\t                               JSONReadFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::LIST(LogicalType::VARCHAR)},\n+\t                               LogicalType::LIST(LogicalType::VARCHAR), ExtractStringManyFunction,\n+\t                               JSONReadManyFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n+}\n+\n CreateScalarFunctionInfo JSONFunctions::GetExtractStringFunction() {\n \t// String extract function\n \tScalarFunctionSet set(\"json_extract_string\");\n-\tset.AddFunction(ScalarFunction({LogicalType::JSON, LogicalType::VARCHAR}, LogicalType::VARCHAR,\n-\t                               ExtractStringFunction, JSONReadFunctionData::Bind));\n-\tset.AddFunction(ScalarFunction({LogicalType::JSON, LogicalType::LIST(LogicalType::VARCHAR)},\n-\t                               LogicalType::LIST(LogicalType::VARCHAR), ExtractStringManyFunction,\n-\t                               JSONReadManyFunctionData::Bind));\n+\tGetExtractStringFunctionsInternal(set, LogicalType::VARCHAR);\n+\tGetExtractStringFunctionsInternal(set, JSONCommon::JSONType());\n \n \treturn CreateScalarFunctionInfo(set);\n }\ndiff --git a/extension/json/json_functions/json_merge_patch.cpp b/extension/json/json_functions/json_merge_patch.cpp\nindex d6a6701fd454..84da2ca23c6c 100644\n--- a/extension/json/json_functions/json_merge_patch.cpp\n+++ b/extension/json/json_functions/json_merge_patch.cpp\n@@ -3,6 +3,24 @@\n \n namespace duckdb {\n \n+static unique_ptr<FunctionData> JSONMergePatchBind(ClientContext &context, ScalarFunction &bound_function,\n+                                                   vector<unique_ptr<Expression>> &arguments) {\n+\tif (arguments.size() < 2) {\n+\t\tthrow InvalidInputException(\"json_merge_patch requires at least two parameters\");\n+\t}\n+\tbound_function.arguments.reserve(arguments.size());\n+\tfor (auto &arg : arguments) {\n+\t\tconst auto &arg_type = arg->return_type;\n+\t\tif (arg_type == LogicalTypeId::SQLNULL || arg_type == LogicalType::VARCHAR ||\n+\t\t    JSONCommon::LogicalTypeIsJSON(arg_type)) {\n+\t\t\tbound_function.arguments.push_back(arg_type);\n+\t\t} else {\n+\t\t\tthrow InvalidInputException(\"Arguments to json_merge_patch must be of type VARCHAR or JSON\");\n+\t\t}\n+\t}\n+\treturn nullptr;\n+}\n+\n static inline yyjson_mut_val *MergePatch(yyjson_mut_doc *doc, yyjson_mut_val *orig, yyjson_mut_val *patch) {\n \tif ((yyjson_mut_get_tag(orig) != (YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE)) ||\n \t    (yyjson_mut_get_tag(patch) != (YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE))) {\n@@ -26,24 +44,28 @@ static inline void ReadObjects(yyjson_mut_doc *doc, Vector &input, yyjson_mut_va\n \t\tif (!input_data.validity.RowIsValid(idx)) {\n \t\t\tobjs[i] = nullptr;\n \t\t} else {\n-\t\t\tobjs[i] = yyjson_val_mut_copy(doc, JSONCommon::ReadDocument(inputs[idx])->root);\n+\t\t\tobjs[i] =\n+\t\t\t    yyjson_val_mut_copy(doc, JSONCommon::ReadDocument(inputs[idx], JSONCommon::READ_FLAG, &doc->alc)->root);\n \t\t}\n \t}\n }\n \n //! Follows MySQL behaviour\n static void MergePatchFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tauto doc = JSONCommon::CreateDocument();\n+\tauto &lstate = JSONFunctionLocalState::ResetAndGet(state);\n+\tauto alc = lstate.json_allocator.GetYYJSONAllocator();\n+\n+\tauto doc = JSONCommon::CreateDocument(lstate.json_allocator.GetYYJSONAllocator());\n \tconst auto count = args.size();\n \n \t// Read the first json arg\n \tyyjson_mut_val *origs[STANDARD_VECTOR_SIZE];\n-\tReadObjects(*doc, args.data[0], origs, count);\n+\tReadObjects(doc, args.data[0], origs, count);\n \n \t// Read the next json args one by one and merge them into the first json arg\n \tyyjson_mut_val *patches[STANDARD_VECTOR_SIZE];\n \tfor (idx_t arg_idx = 1; arg_idx < args.data.size(); arg_idx++) {\n-\t\tReadObjects(*doc, args.data[arg_idx], patches, count);\n+\t\tReadObjects(doc, args.data[arg_idx], patches, count);\n \t\tfor (idx_t i = 0; i < count; i++) {\n \t\t\tif (patches[i] == nullptr) {\n \t\t\t\t// Next json arg is NULL, obj becomes NULL\n@@ -53,7 +75,7 @@ static void MergePatchFunction(DataChunk &args, ExpressionState &state, Vector &\n \t\t\t\torigs[i] = patches[i];\n \t\t\t} else {\n \t\t\t\t// Neither is NULL, merge them\n-\t\t\t\torigs[i] = MergePatch(*doc, origs[i], patches[i]);\n+\t\t\t\torigs[i] = MergePatch(doc, origs[i], patches[i]);\n \t\t\t}\n \t\t}\n \t}\n@@ -65,7 +87,7 @@ static void MergePatchFunction(DataChunk &args, ExpressionState &state, Vector &\n \t\tif (origs[i] == nullptr) {\n \t\t\tresult_validity.SetInvalid(i);\n \t\t} else {\n-\t\t\tresult_data[i] = JSONCommon::WriteVal(origs[i], result);\n+\t\t\tresult_data[i] = JSONCommon::WriteVal<yyjson_mut_val>(origs[i], alc);\n \t\t}\n \t}\n \n@@ -75,12 +97,12 @@ static void MergePatchFunction(DataChunk &args, ExpressionState &state, Vector &\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetMergePatchFunction() {\n-\t// Needs at least two json inputs, but supports merging vararg json inputs\n-\tScalarFunction fun(\"json_merge_patch\", {LogicalType::JSON, LogicalType::JSON}, LogicalType::JSON,\n-\t                   MergePatchFunction);\n-\tfun.varargs = LogicalType::JSON;\n+\tScalarFunction fun(\"json_merge_patch\", {}, JSONCommon::JSONType(), MergePatchFunction, JSONMergePatchBind, nullptr,\n+\t                   nullptr, JSONFunctionLocalState::Init);\n+\tfun.varargs = LogicalType::ANY;\n \tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n-\treturn CreateScalarFunctionInfo(std::move(fun));\n+\n+\treturn CreateScalarFunctionInfo(fun);\n }\n \n } // namespace duckdb\ndiff --git a/extension/json/json_functions/json_structure.cpp b/extension/json/json_functions/json_structure.cpp\nindex e33f4bee8287..72a44cb7c46c 100644\n--- a/extension/json/json_functions/json_structure.cpp\n+++ b/extension/json/json_functions/json_structure.cpp\n@@ -1,5 +1,4 @@\n-#include \"json_common.hpp\"\n-#include \"json_functions.hpp\"\n+#include \"json_executors.hpp\"\n \n namespace duckdb {\n \n@@ -42,7 +41,7 @@ static inline yyjson_mut_val *GetConsistentArrayStructureObject(const vector<yyj\n \n \tauto result = yyjson_mut_obj(structure_doc);\n \tfor (const auto &key_string : key_insert_order) {\n-\t\tkey = yyjson_mut_strcpy(structure_doc, key_string.c_str());\n+\t\tkey = yyjson_mut_strncpy(structure_doc, key_string.c_str(), key_string.length());\n \t\tval = GetConsistentArrayStructure(key_values.at(key_string), structure_doc);\n \t\tyyjson_mut_obj_add(result, key, val);\n \t}\n@@ -196,21 +195,27 @@ static inline yyjson_mut_val *ConvertStructure(yyjson_mut_val *val, yyjson_mut_d\n \t}\n }\n \n-static inline string_t Structure(yyjson_val *val, Vector &result) {\n-\tauto structure_doc = JSONCommon::CreateDocument();\n-\tauto structure = ConvertStructure(BuildStructure(val, *structure_doc), *structure_doc);\n+static inline string_t Structure(yyjson_val *val, yyjson_alc *alc, Vector &result) {\n+\tauto structure_doc = JSONCommon::CreateDocument(alc);\n+\tauto structure = ConvertStructure(BuildStructure(val, structure_doc), structure_doc);\n \tD_ASSERT(structure);\n-\tyyjson_mut_doc_set_root(*structure_doc, structure);\n-\treturn JSONCommon::WriteDoc(*structure_doc, result);\n+\treturn JSONCommon::WriteVal<yyjson_mut_val>(structure, alc);\n }\n \n static void StructureFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONCommon::UnaryExecute<string_t>(args, state, result, Structure);\n+\tJSONExecutors::UnaryExecute<string_t>(args, state, result, Structure);\n+}\n+\n+static void GetStructureFunctionInternal(ScalarFunctionSet &set, const LogicalType &input_type) {\n+\tset.AddFunction(ScalarFunction({input_type}, JSONCommon::JSONType(), StructureFunction, nullptr, nullptr, nullptr,\n+\t                               JSONFunctionLocalState::Init));\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetStructureFunction() {\n-\treturn CreateScalarFunctionInfo(\n-\t    ScalarFunction(\"json_structure\", {LogicalType::JSON}, LogicalType::JSON, StructureFunction));\n+\tScalarFunctionSet set(\"json_structure\");\n+\tGetStructureFunctionInternal(set, LogicalType::VARCHAR);\n+\tGetStructureFunctionInternal(set, JSONCommon::JSONType());\n+\treturn CreateScalarFunctionInfo(set);\n }\n \n } // namespace duckdb\ndiff --git a/extension/json/json_functions/json_transform.cpp b/extension/json/json_functions/json_transform.cpp\nindex 206263a0accf..c7b30890c9cd 100644\n--- a/extension/json/json_functions/json_transform.cpp\n+++ b/extension/json/json_functions/json_transform.cpp\n@@ -1,4 +1,5 @@\n #include \"duckdb/common/types.hpp\"\n+#include \"duckdb/execution/expression_executor.hpp\"\n #include \"duckdb/function/scalar/nested_functions.hpp\"\n #include \"json_common.hpp\"\n #include \"json_functions.hpp\"\n@@ -6,16 +7,16 @@\n namespace duckdb {\n \n //! Forward declaration for recursion\n-static LogicalType StructureToType(yyjson_val *val);\n+static LogicalType StructureToType(yyjson_val *val, ClientContext &context);\n \n-static LogicalType StructureToTypeArray(yyjson_val *arr) {\n+static LogicalType StructureToTypeArray(yyjson_val *arr, ClientContext &context) {\n \tif (yyjson_arr_size(arr) != 1) {\n \t\tthrow InvalidInputException(\"Too many values in array of JSON structure\");\n \t}\n-\treturn LogicalType::LIST(StructureToType(yyjson_arr_get_first(arr)));\n+\treturn LogicalType::LIST(StructureToType(yyjson_arr_get_first(arr), context));\n }\n \n-static LogicalType StructureToTypeObject(yyjson_val *obj) {\n+static LogicalType StructureToTypeObject(yyjson_val *obj, ClientContext &context) {\n \tunordered_set<string> names;\n \tchild_list_t<LogicalType> child_types;\n \tsize_t idx, max;\n@@ -27,20 +28,20 @@ static LogicalType StructureToTypeObject(yyjson_val *obj) {\n \t\t\tJSONCommon::ThrowValFormatError(\"Duplicate keys in object in JSON structure: %s\", val);\n \t\t}\n \t\tnames.insert(key_str);\n-\t\tchild_types.emplace_back(key_str, StructureToType(val));\n+\t\tchild_types.emplace_back(key_str, StructureToType(val, context));\n \t}\n \tD_ASSERT(yyjson_obj_size(obj) == names.size());\n \treturn LogicalType::STRUCT(child_types);\n }\n \n-static LogicalType StructureToType(yyjson_val *val) {\n+static LogicalType StructureToType(yyjson_val *val, ClientContext &context) {\n \tswitch (yyjson_get_tag(val)) {\n \tcase YYJSON_TYPE_ARR | YYJSON_SUBTYPE_NONE:\n-\t\treturn StructureToTypeArray(val);\n+\t\treturn StructureToTypeArray(val, context);\n \tcase YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE:\n-\t\treturn StructureToTypeObject(val);\n+\t\treturn StructureToTypeObject(val, context);\n \tcase YYJSON_TYPE_STR | YYJSON_SUBTYPE_NONE:\n-\t\treturn TransformStringToLogicalType(yyjson_get_str(val));\n+\t\treturn TransformStringToLogicalType(yyjson_get_str(val), context);\n \tdefault:\n \t\tthrow InvalidInputException(\"invalid JSON structure\");\n \t}\n@@ -58,15 +59,18 @@ static unique_ptr<FunctionData> JSONTransformBind(ClientContext &context, Scalar\n \t\tthrow InvalidInputException(\"JSON structure must be a constant!\");\n \t} else {\n \t\tauto structure_val = ExpressionExecutor::EvaluateScalar(context, *arguments[1]);\n-\t\tif (!structure_val.DefaultTryCastAs(LogicalType::JSON)) {\n+\t\tif (!structure_val.DefaultTryCastAs(JSONCommon::JSONType())) {\n \t\t\tthrow InvalidInputException(\"cannot cast JSON structure to string\");\n \t\t}\n \t\tauto structure_string = structure_val.GetValueUnsafe<string_t>();\n-\t\tauto doc = JSONCommon::ReadDocumentUnsafe(structure_string);\n-\t\tif (doc.IsNull()) {\n-\t\t\tthrow InvalidInputException(\"malformed JSON structure\");\n+\t\tJSONAllocator json_allocator(Allocator::DefaultAllocator());\n+\t\tyyjson_read_err err;\n+\t\tauto doc = JSONCommon::ReadDocumentUnsafe(structure_string, JSONCommon::READ_FLAG,\n+\t\t                                          json_allocator.GetYYJSONAllocator(), &err);\n+\t\tif (err.code != YYJSON_READ_SUCCESS) {\n+\t\t\tJSONCommon::ThrowParseError(structure_string.GetDataUnsafe(), structure_string.GetSize(), err);\n \t\t}\n-\t\tbound_function.return_type = StructureToType(doc->root);\n+\t\tbound_function.return_type = StructureToType(doc->root, context);\n \t}\n \treturn make_unique<VariableReturnBindData>(bound_function.return_type);\n }\n@@ -146,7 +150,7 @@ static inline bool GetValueDecimal(yyjson_val *val, T &result, uint8_t w, uint8_\n \treturn success;\n }\n \n-static inline bool GetValueString(yyjson_val *val, string_t &result, Vector &vector) {\n+static inline bool GetValueString(yyjson_val *val, yyjson_alc *alc, string_t &result, Vector &vector) {\n \tswitch (yyjson_get_tag(val)) {\n \tcase YYJSON_TYPE_NULL | YYJSON_SUBTYPE_NONE:\n \t\treturn false;\n@@ -155,7 +159,7 @@ static inline bool GetValueString(yyjson_val *val, string_t &result, Vector &vec\n \t\treturn true;\n \tcase YYJSON_TYPE_ARR | YYJSON_SUBTYPE_NONE:\n \tcase YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE:\n-\t\tresult = JSONCommon::WriteVal(val, vector);\n+\t\tresult = JSONCommon::WriteVal<yyjson_val>(val, alc);\n \t\treturn true;\n \tcase YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_TRUE:\n \tcase YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_FALSE:\n@@ -176,7 +180,7 @@ static inline bool GetValueString(yyjson_val *val, string_t &result, Vector &vec\n }\n \n //! Forward declaration for recursion\n-static void Transform(yyjson_val *vals[], Vector &result, const idx_t count, bool strict);\n+static void Transform(yyjson_val *vals[], yyjson_alc *alc, Vector &result, const idx_t count, bool strict);\n \n template <class T>\n static void TransformNumerical(yyjson_val *vals[], Vector &result, const idx_t count, const bool strict) {\n@@ -216,7 +220,7 @@ static void TransformFromString(yyjson_val *vals[], Vector &result, const idx_t\n \t\t} else if (strict && !yyjson_is_str(val)) {\n \t\t\tJSONCommon::ThrowValFormatError(\"Unable to cast '%s' to \" + LogicalTypeIdToString(target.id()), val);\n \t\t} else {\n-\t\t\tdata[i] = StringVector::AddString(string_vector, yyjson_get_str(val), yyjson_get_len(val));\n+\t\t\tdata[i] = GetString(val);\n \t\t}\n \t}\n \n@@ -226,19 +230,19 @@ static void TransformFromString(yyjson_val *vals[], Vector &result, const idx_t\n \t}\n }\n \n-static void TransformToString(yyjson_val *vals[], Vector &result, const idx_t count) {\n+static void TransformToString(yyjson_val *vals[], yyjson_alc *alc, Vector &result, const idx_t count) {\n \tauto data = (string_t *)FlatVector::GetData(result);\n \tauto &validity = FlatVector::Validity(result);\n \tfor (idx_t i = 0; i < count; i++) {\n \t\tconst auto &val = vals[i];\n-\t\tif (!val || !GetValueString(val, data[i], result)) {\n+\t\tif (!val || !GetValueString(val, alc, data[i], result)) {\n \t\t\tvalidity.SetInvalid(i);\n \t\t}\n \t}\n }\n \n-static void TransformObject(yyjson_val *vals[], Vector &result, const idx_t count, const LogicalType &type,\n-                            bool strict) {\n+static void TransformObject(yyjson_val *vals[], yyjson_alc *alc, Vector &result, const idx_t count,\n+                            const LogicalType &type, bool strict) {\n \t// Initialize array for the nested values\n \tauto nested_vals_ptr = unique_ptr<yyjson_val *[]>(new yyjson_val *[count]);\n \tauto nested_vals = nested_vals_ptr.get();\n@@ -252,11 +256,11 @@ static void TransformObject(yyjson_val *vals[], Vector &result, const idx_t coun\n \t\t\tnested_vals[i] = yyjson_obj_getn(vals[i], name_ptr, name_len);\n \t\t}\n \t\t// Transform child values\n-\t\tTransform(nested_vals, *child_vs[child_i], count, strict);\n+\t\tTransform(nested_vals, alc, *child_vs[child_i], count, strict);\n \t}\n }\n \n-static void TransformArray(yyjson_val *vals[], Vector &result, const idx_t count, bool strict) {\n+static void TransformArray(yyjson_val *vals[], yyjson_alc *alc, Vector &result, const idx_t count, bool strict) {\n \t// Initialize list vector\n \tauto list_entries = FlatVector::GetData<list_entry_t>(result);\n \tauto &list_validity = FlatVector::Validity(result);\n@@ -291,10 +295,10 @@ static void TransformArray(yyjson_val *vals[], Vector &result, const idx_t count\n \t}\n \tD_ASSERT(list_i == offset);\n \t// Transform array values\n-\tTransform(nested_vals, ListVector::GetEntry(result), offset, strict);\n+\tTransform(nested_vals, alc, ListVector::GetEntry(result), offset, strict);\n }\n \n-static void Transform(yyjson_val *vals[], Vector &result, const idx_t count, bool strict) {\n+static void Transform(yyjson_val *vals[], yyjson_alc *alc, Vector &result, const idx_t count, bool strict) {\n \tauto result_type = result.GetType();\n \tswitch (result_type.id()) {\n \tcase LogicalTypeId::SQLNULL:\n@@ -352,58 +356,73 @@ static void Transform(yyjson_val *vals[], Vector &result, const idx_t count, boo\n \tcase LogicalTypeId::TIMESTAMP_SEC:\n \tcase LogicalTypeId::UUID:\n \t\treturn TransformFromString(vals, result, count, result_type, strict);\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR:\n \tcase LogicalTypeId::BLOB:\n-\t\treturn TransformToString(vals, result, count);\n+\t\treturn TransformToString(vals, alc, result, count);\n \tcase LogicalTypeId::STRUCT:\n-\t\treturn TransformObject(vals, result, count, result_type, strict);\n+\t\treturn TransformObject(vals, alc, result, count, result_type, strict);\n \tcase LogicalTypeId::LIST:\n-\t\treturn TransformArray(vals, result, count, strict);\n+\t\treturn TransformArray(vals, alc, result, count, strict);\n \tdefault:\n-\t\tthrow InternalException(\"Unexpected type at JSON Transform %s\", LogicalTypeIdToString(result_type.id()));\n+\t\tthrow InternalException(\"Unexpected type at JSON Transform %s\", result_type.ToString());\n \t}\n }\n \n template <bool strict>\n static void TransformFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tauto &lstate = JSONFunctionLocalState::ResetAndGet(state);\n+\tauto alc = lstate.json_allocator.GetYYJSONAllocator();\n+\n \tconst auto count = args.size();\n \tauto &input = args.data[0];\n \tUnifiedVectorFormat input_data;\n \tinput.ToUnifiedFormat(count, input_data);\n \tauto inputs = (string_t *)input_data.data;\n \t// Read documents\n-\tvector<DocPointer<yyjson_doc>> docs;\n-\tdocs.reserve(count);\n+\tyyjson_doc *docs[STANDARD_VECTOR_SIZE];\n \tyyjson_val *vals[STANDARD_VECTOR_SIZE];\n \tauto &result_validity = FlatVector::Validity(result);\n \tfor (idx_t i = 0; i < count; i++) {\n \t\tauto idx = input_data.sel->get_index(i);\n \t\tif (!input_data.validity.RowIsValid(idx)) {\n-\t\t\tdocs.emplace_back(nullptr);\n+\t\t\tdocs[i] = nullptr;\n \t\t\tvals[i] = nullptr;\n \t\t\tresult_validity.SetInvalid(i);\n \t\t} else {\n-\t\t\tdocs.emplace_back(JSONCommon::ReadDocument(inputs[idx]));\n-\t\t\tvals[i] = docs.back()->root;\n+\t\t\tdocs[i] = JSONCommon::ReadDocument(inputs[idx], JSONCommon::READ_FLAG, alc);\n+\t\t\tvals[i] = docs[i]->root;\n \t\t}\n \t}\n \t// Transform\n-\tTransform(vals, result, count, strict);\n+\tTransform(vals, alc, result, count, strict);\n \n \tif (args.AllConstant()) {\n \t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n \t}\n }\n \n+static void GetTransformFunctionInternal(ScalarFunctionSet &set, const LogicalType &input_type) {\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::VARCHAR}, LogicalType::ANY, TransformFunction<false>,\n+\t                               JSONTransformBind, nullptr, nullptr, JSONFunctionLocalState::Init));\n+}\n+\n CreateScalarFunctionInfo JSONFunctions::GetTransformFunction() {\n-\treturn CreateScalarFunctionInfo(ScalarFunction(\"json_transform\", {LogicalType::JSON, LogicalType::JSON},\n-\t                                               LogicalType::ANY, TransformFunction<false>, JSONTransformBind));\n+\tScalarFunctionSet set(\"json_transform\");\n+\tGetTransformFunctionInternal(set, LogicalType::VARCHAR);\n+\tGetTransformFunctionInternal(set, JSONCommon::JSONType());\n+\treturn CreateScalarFunctionInfo(set);\n+}\n+\n+static void GetTransformStrictFunctionInternal(ScalarFunctionSet &set, const LogicalType &input_type) {\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::VARCHAR}, LogicalType::ANY, TransformFunction<true>,\n+\t                               JSONTransformBind, nullptr, nullptr, JSONFunctionLocalState::Init));\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetTransformStrictFunction() {\n-\treturn CreateScalarFunctionInfo(ScalarFunction(\"json_transform_strict\", {LogicalType::JSON, LogicalType::JSON},\n-\t                                               LogicalType::ANY, TransformFunction<true>, JSONTransformBind));\n+\tScalarFunctionSet set(\"json_transform_strict\");\n+\tGetTransformStrictFunctionInternal(set, LogicalType::VARCHAR);\n+\tGetTransformStrictFunctionInternal(set, JSONCommon::JSONType());\n+\treturn CreateScalarFunctionInfo(set);\n }\n \n } // namespace duckdb\ndiff --git a/extension/json/json_functions/json_type.cpp b/extension/json/json_functions/json_type.cpp\nindex 1d6522f69d37..ca8bdb65efff 100644\n--- a/extension/json/json_functions/json_type.cpp\n+++ b/extension/json/json_functions/json_type.cpp\n@@ -1,32 +1,37 @@\n-#include \"json_common.hpp\"\n-#include \"json_functions.hpp\"\n+#include \"json_executors.hpp\"\n \n namespace duckdb {\n \n-static inline string_t GetType(yyjson_val *val, Vector &result) {\n-\treturn StringVector::AddString(result, JSONCommon::ValTypeToString(val));\n+static inline string_t GetType(yyjson_val *val, yyjson_alc *alc, Vector &result) {\n+\treturn JSONCommon::ValTypeToStringT<yyjson_val>(val);\n }\n \n static void UnaryTypeFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONCommon::UnaryExecute<string_t>(args, state, result, GetType);\n+\tJSONExecutors::UnaryExecute<string_t>(args, state, result, GetType);\n }\n \n static void BinaryTypeFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONCommon::BinaryExecute<string_t>(args, state, result, GetType);\n+\tJSONExecutors::BinaryExecute<string_t>(args, state, result, GetType);\n }\n \n static void ManyTypeFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONCommon::ExecuteMany<string_t>(args, state, result, GetType);\n+\tJSONExecutors::ExecuteMany<string_t>(args, state, result, GetType);\n+}\n+\n+static void GetTypeFunctionsInternal(ScalarFunctionSet &set, const LogicalType &input_type) {\n+\tset.AddFunction(ScalarFunction({input_type}, LogicalType::VARCHAR, UnaryTypeFunction, nullptr, nullptr, nullptr,\n+\t                               JSONFunctionLocalState::Init));\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::VARCHAR}, LogicalType::VARCHAR, BinaryTypeFunction,\n+\t                               JSONReadFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::LIST(LogicalType::VARCHAR)},\n+\t                               LogicalType::LIST(LogicalType::VARCHAR), ManyTypeFunction,\n+\t                               JSONReadManyFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetTypeFunction() {\n \tScalarFunctionSet set(\"json_type\");\n-\tset.AddFunction(ScalarFunction({LogicalType::JSON}, LogicalType::VARCHAR, UnaryTypeFunction));\n-\tset.AddFunction(ScalarFunction({LogicalType::JSON, LogicalType::VARCHAR}, LogicalType::VARCHAR, BinaryTypeFunction,\n-\t                               JSONReadFunctionData::Bind));\n-\tset.AddFunction(ScalarFunction({LogicalType::JSON, LogicalType::LIST(LogicalType::VARCHAR)},\n-\t                               LogicalType::LIST(LogicalType::VARCHAR), ManyTypeFunction,\n-\t                               JSONReadManyFunctionData::Bind));\n+\tGetTypeFunctionsInternal(set, LogicalType::VARCHAR);\n+\tGetTypeFunctionsInternal(set, JSONCommon::JSONType());\n \n \treturn CreateScalarFunctionInfo(std::move(set));\n }\ndiff --git a/extension/json/json_functions/json_valid.cpp b/extension/json/json_functions/json_valid.cpp\nindex 71933ba850c7..9df77e8862ef 100644\n--- a/extension/json/json_functions/json_valid.cpp\n+++ b/extension/json/json_functions/json_valid.cpp\n@@ -1,17 +1,27 @@\n-#include \"json_common.hpp\"\n-#include \"json_functions.hpp\"\n+#include \"json_executors.hpp\"\n \n namespace duckdb {\n \n static void ValidFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tauto &lstate = JSONFunctionLocalState::ResetAndGet(state);\n+\tauto alc = lstate.json_allocator.GetYYJSONAllocator();\n \tauto &inputs = args.data[0];\n-\tUnaryExecutor::Execute<string_t, bool>(\n-\t    inputs, result, args.size(), [&](string_t input) { return !JSONCommon::ReadDocumentUnsafe(input).IsNull(); });\n+\tUnaryExecutor::Execute<string_t, bool>(inputs, result, args.size(), [&](string_t input) {\n+\t\treturn JSONCommon::ReadDocumentUnsafe(input, JSONCommon::READ_FLAG, alc);\n+\t});\n+}\n+\n+static void GetValidFunctionInternal(ScalarFunctionSet &set, const LogicalType &input_type) {\n+\tset.AddFunction(ScalarFunction(\"json_valid\", {input_type}, LogicalType::BOOLEAN, ValidFunction, nullptr, nullptr,\n+\t                               nullptr, JSONFunctionLocalState::Init));\n }\n \n CreateScalarFunctionInfo JSONFunctions::GetValidFunction() {\n-\treturn CreateScalarFunctionInfo(\n-\t    ScalarFunction(\"json_valid\", {LogicalType::JSON}, LogicalType::BOOLEAN, ValidFunction));\n+\tScalarFunctionSet set(\"json_valid\");\n+\tGetValidFunctionInternal(set, LogicalType::VARCHAR);\n+\tGetValidFunctionInternal(set, JSONCommon::JSONType());\n+\n+\treturn CreateScalarFunctionInfo(set);\n }\n \n } // namespace duckdb\ndiff --git a/extension/json/json_functions/read_json_objects.cpp b/extension/json/json_functions/read_json_objects.cpp\nnew file mode 100644\nindex 000000000000..dc073574185d\n--- /dev/null\n+++ b/extension/json/json_functions/read_json_objects.cpp\n@@ -0,0 +1,65 @@\n+#include \"json_common.hpp\"\n+#include \"json_functions.hpp\"\n+#include \"json_scan.hpp\"\n+\n+namespace duckdb {\n+\n+unique_ptr<FunctionData> ReadJSONObjectsBind(ClientContext &context, TableFunctionBindInput &input,\n+                                             vector<LogicalType> &return_types, vector<string> &names) {\n+\treturn_types.push_back(JSONCommon::JSONType());\n+\tnames.emplace_back(\"json\");\n+\treturn JSONScanData::Bind(context, input);\n+}\n+\n+static void ReadJSONObjectsFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {\n+\tD_ASSERT(output.ColumnCount() == 1);\n+\tD_ASSERT(JSONCommon::LogicalTypeIsJSON(output.data[0].GetType()));\n+\tauto &gstate = (JSONScanGlobalState &)*data_p.global_state;\n+\tauto &lstate = (JSONScanLocalState &)*data_p.local_state;\n+\n+\t// Fetch next lines\n+\tconst auto count = lstate.ReadNext(gstate);\n+\tconst auto lines = lstate.lines;\n+\tconst auto objects = lstate.objects;\n+\n+\t// Create the strings without copying them\n+\tauto strings = FlatVector::GetData<string_t>(output.data[0]);\n+\tauto &validity = FlatVector::Validity(output.data[0]);\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tif (objects[i]) {\n+\t\t\tstrings[i] = string_t(lines[i].pointer, lines[i].size);\n+\t\t} else {\n+\t\t\tvalidity.SetInvalid(i);\n+\t\t}\n+\t}\n+\n+\toutput.SetCardinality(count);\n+}\n+\n+TableFunction GetReadJSONObjectsTableFunction(bool list_parameter, shared_ptr<JSONScanInfo> function_info) {\n+\tauto parameter = list_parameter ? LogicalType::LIST(LogicalType::VARCHAR) : LogicalType::VARCHAR;\n+\tTableFunction table_function({parameter}, ReadJSONObjectsFunction, ReadJSONObjectsBind, JSONScanGlobalState::Init,\n+\t                             JSONScanLocalState::Init);\n+\tJSONScan::TableFunctionDefaults(table_function);\n+\ttable_function.function_info = std::move(function_info);\n+\n+\treturn table_function;\n+}\n+\n+CreateTableFunctionInfo JSONFunctions::GetReadJSONObjectsFunction() {\n+\tTableFunctionSet function_set(\"read_json_objects\");\n+\tauto function_info = make_shared<JSONScanInfo>(JSONFormat::UNSTRUCTURED, true);\n+\tfunction_set.AddFunction(GetReadJSONObjectsTableFunction(false, function_info));\n+\tfunction_set.AddFunction(GetReadJSONObjectsTableFunction(true, function_info));\n+\treturn CreateTableFunctionInfo(function_set);\n+}\n+\n+CreateTableFunctionInfo JSONFunctions::GetReadNDJSONObjectsFunction() {\n+\tTableFunctionSet function_set(\"read_ndjson_objects\");\n+\tauto function_info = make_shared<JSONScanInfo>(JSONFormat::NEWLINE_DELIMITED, true);\n+\tfunction_set.AddFunction(GetReadJSONObjectsTableFunction(false, function_info));\n+\tfunction_set.AddFunction(GetReadJSONObjectsTableFunction(true, function_info));\n+\treturn CreateTableFunctionInfo(function_set);\n+}\n+\n+} // namespace duckdb\ndiff --git a/extension/json/json_scan.cpp b/extension/json/json_scan.cpp\nnew file mode 100644\nindex 000000000000..d0cec01d908a\n--- /dev/null\n+++ b/extension/json/json_scan.cpp\n@@ -0,0 +1,501 @@\n+#include \"json_scan.hpp\"\n+\n+#include \"duckdb/main/database.hpp\"\n+#include \"duckdb/parallel/task_scheduler.hpp\"\n+#include \"duckdb/storage/buffer_manager.hpp\"\n+\n+namespace duckdb {\n+\n+JSONScanData::JSONScanData() {\n+}\n+\n+unique_ptr<FunctionData> JSONScanData::Bind(ClientContext &context, TableFunctionBindInput &input) {\n+\tauto &config = DBConfig::GetConfig(context);\n+\tif (!config.options.enable_external_access) {\n+\t\tthrow PermissionException(\"Scanning JSON files is disabled through configuration\");\n+\t}\n+\n+\tauto result = make_unique<JSONScanData>();\n+\tauto &options = result->options;\n+\n+\tauto &info = (JSONScanInfo &)*input.info;\n+\tif (info.forced_format == JSONFormat::AUTO_DETECT) {\n+\t\tthrow NotImplementedException(\"Auto-detection of JSON format\");\n+\t}\n+\toptions.format = info.forced_format;\n+\tresult->return_json_strings = info.return_json_strings;\n+\n+\tvector<string> patterns;\n+\tif (input.inputs[0].type().id() == LogicalTypeId::LIST) { // list of globs\n+\t\tfor (auto &val : ListValue::GetChildren(input.inputs[0])) {\n+\t\t\tpatterns.push_back(StringValue::Get(val));\n+\t\t}\n+\t} else { // single glob pattern\n+\t\tpatterns.push_back(StringValue::Get(input.inputs[0]));\n+\t}\n+\tInitializeFilePaths(context, patterns, result->file_paths);\n+\n+\tfor (auto &kv : input.named_parameters) {\n+\t\tauto loption = StringUtil::Lower(kv.first);\n+\t\tif (loption == \"ignore_errors\") {\n+\t\t\tresult->ignore_errors = BooleanValue::Get(kv.second);\n+\t\t} else if (loption == \"maximum_object_size\") {\n+\t\t\tresult->maximum_object_size = MaxValue<idx_t>(UIntegerValue::Get(kv.second), result->maximum_object_size);\n+\t\t} else if (loption == \"format\") {\n+\t\t\tauto format = StringUtil::Lower(StringValue::Get(kv.second));\n+\t\t\tif (format == \"auto\") {\n+\t\t\t\toptions.format = JSONFormat::AUTO_DETECT;\n+\t\t\t} else if (format == \"unstructured\") {\n+\t\t\t\toptions.format = JSONFormat::UNSTRUCTURED;\n+\t\t\t} else if (format == \"newline_delimited\") {\n+\t\t\t\toptions.format = JSONFormat::NEWLINE_DELIMITED;\n+\t\t\t} else {\n+\t\t\t\tthrow InvalidInputException(\"format must be one of ['auto', 'unstructured', 'newline_delimited']\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (result->ignore_errors && options.format == JSONFormat::UNSTRUCTURED) {\n+\t\tthrow InvalidInputException(\"Cannot ignore errors with unstructured format\");\n+\t}\n+\n+\treturn std::move(result);\n+}\n+\n+void JSONScanData::InitializeFilePaths(ClientContext &context, const vector<string> &patterns,\n+                                       vector<string> &file_paths) {\n+\tauto &fs = FileSystem::GetFileSystem(context);\n+\tfor (auto &file_pattern : patterns) {\n+\t\tauto found_files = fs.Glob(file_pattern, context);\n+\t\tif (found_files.empty()) {\n+\t\t\tthrow IOException(\"No files found that match the pattern \\\"%s\\\"\", file_pattern);\n+\t\t}\n+\t\tfile_paths.insert(file_paths.end(), found_files.begin(), found_files.end());\n+\t}\n+}\n+\n+void JSONScanData::Serialize(FieldWriter &writer) {\n+\toptions.Serialize(writer);\n+\twriter.WriteList<string>(file_paths);\n+\twriter.WriteField<bool>(ignore_errors);\n+\twriter.WriteField<idx_t>(maximum_object_size);\n+\twriter.WriteField<bool>(return_json_strings);\n+}\n+\n+void JSONScanData::Deserialize(FieldReader &reader) {\n+\toptions.Deserialize(reader);\n+\tfile_paths = reader.ReadRequiredList<string>();\n+\tignore_errors = reader.ReadRequired<bool>();\n+\tmaximum_object_size = reader.ReadRequired<idx_t>();\n+\treturn_json_strings = reader.ReadRequired<bool>();\n+}\n+\n+JSONScanGlobalState::JSONScanGlobalState(ClientContext &context, JSONScanData &bind_data_p)\n+    : bind_data(bind_data_p), allocator(BufferManager::GetBufferManager(context).GetBufferAllocator()),\n+      buffer_capacity(bind_data.maximum_object_size * 2), file_index(0), batch_index(0),\n+      system_threads(TaskScheduler::GetScheduler(context).NumberOfThreads()) {\n+\tjson_readers.reserve(bind_data.file_paths.size());\n+\tfor (idx_t i = 0; i < bind_data_p.file_paths.size(); i++) {\n+\t\tjson_readers.push_back(make_unique<BufferedJSONReader>(context, bind_data.options, i, bind_data.file_paths[i]));\n+\t}\n+}\n+\n+unique_ptr<GlobalTableFunctionState> JSONScanGlobalState::Init(ClientContext &context, TableFunctionInitInput &input) {\n+\tauto &bind_data = (JSONScanData &)*input.bind_data;\n+\treturn make_unique<JSONScanGlobalState>(context, bind_data);\n+}\n+\n+idx_t JSONScanGlobalState::MaxThreads() const {\n+\treturn system_threads;\n+}\n+\n+JSONScanLocalState::JSONScanLocalState(ClientContext &context, JSONScanGlobalState &gstate)\n+    : batch_index(DConstants::INVALID_INDEX), json_allocator(BufferAllocator::Get(context)), current_reader(nullptr),\n+      current_buffer_handle(nullptr), buffer_size(0), buffer_offset(0), prev_buffer_remainder(0) {\n+\n+\t// Buffer to reconstruct JSON objects when they cross a buffer boundary\n+\treconstruct_buffer = gstate.allocator.Allocate(gstate.bind_data.maximum_object_size);\n+\n+\t// This is needed for JSONFormat::UNSTRUCTURED, to make use of YYJSON_READ_INSITU\n+\tcurrent_buffer_copy = gstate.allocator.Allocate(gstate.buffer_capacity);\n+\tbuffer_copy_ptr = (const char *)current_buffer_copy.get();\n+}\n+\n+unique_ptr<LocalTableFunctionState> JSONScanLocalState::Init(ExecutionContext &context, TableFunctionInitInput &input,\n+                                                             GlobalTableFunctionState *global_state) {\n+\tauto &gstate = (JSONScanGlobalState &)*global_state;\n+\treturn make_unique<JSONScanLocalState>(context.client, gstate);\n+}\n+\n+static inline void SkipWhitespace(const char *buffer_ptr, idx_t &buffer_offset, idx_t &buffer_size) {\n+\tfor (; buffer_offset != buffer_size; buffer_offset++) {\n+\t\tif (!StringUtil::CharacterIsSpace(buffer_ptr[buffer_offset])) {\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+}\n+\n+idx_t JSONScanLocalState::ReadNext(JSONScanGlobalState &gstate) {\n+\tjson_allocator.Reset();\n+\n+\tidx_t count = 0;\n+\tif (buffer_offset == buffer_size) {\n+\t\tbool first_read;\n+\t\tif (!ReadNextBuffer(gstate, first_read)) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tif (!first_read && current_reader->GetOptions().format == JSONFormat::NEWLINE_DELIMITED) {\n+\t\t\tReconstructFirstObject(gstate);\n+\t\t\tcount++;\n+\t\t}\n+\t}\n+\n+\tauto &options = current_reader->GetOptions();\n+\tswitch (options.format) {\n+\tcase JSONFormat::UNSTRUCTURED:\n+\t\tReadUnstructured(count);\n+\t\tbreak;\n+\tcase JSONFormat::NEWLINE_DELIMITED:\n+\t\tReadNewlineDelimited(count, gstate.bind_data.ignore_errors);\n+\t\tbreak;\n+\tdefault:\n+\t\tthrow InternalException(\"Unknown JSON format\");\n+\t}\n+\n+\t// Skip over any remaining whitespace for the next scan\n+\tSkipWhitespace(buffer_ptr, buffer_offset, buffer_size);\n+\n+\treturn count;\n+}\n+\n+static inline const char *NextNewline(const char *ptr, idx_t size) {\n+\treturn (const char *)memchr(ptr, '\\n', size);\n+}\n+\n+static inline const char *PreviousNewline(const char *ptr) {\n+\tfor (ptr--; true; ptr--) {\n+\t\tconst auto &c = *ptr;\n+\t\tif (c == '\\n') {\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\treturn ptr;\n+}\n+\n+static inline void TrimWhitespace(JSONLine &line) {\n+\twhile (line.size != 0 && StringUtil::CharacterIsSpace(line[0])) {\n+\t\tline.pointer++;\n+\t\tline.size--;\n+\t}\n+\twhile (line.size != 0 && StringUtil::CharacterIsSpace(line[line.size - 1])) {\n+\t\tline.size--;\n+\t}\n+}\n+\n+yyjson_doc *JSONScanLocalState::ParseLine(char *line_start, idx_t line_size, JSONLine &line,\n+                                          const bool &ignore_errors) {\n+\t// Parse to validate TODO: This is the only place we can maybe parse INSITU (if not returning strings)\n+\tyyjson_doc *result;\n+\tif (ignore_errors) {\n+\t\tresult = JSONCommon::ReadDocumentUnsafe(line_start, line_size, JSONCommon::READ_FLAG,\n+\t\t                                        json_allocator.GetYYJSONAllocator());\n+\t} else {\n+\t\tresult =\n+\t\t    JSONCommon::ReadDocument(line_start, line_size, JSONCommon::READ_FLAG, json_allocator.GetYYJSONAllocator());\n+\t}\n+\n+\tif (result) {\n+\t\t// Set the JSONLine and trim\n+\t\tline = JSONLine(line_start, line_size);\n+\t\tTrimWhitespace(line);\n+\t}\n+\n+\treturn result;\n+}\n+\n+bool JSONScanLocalState::ReadNextBuffer(JSONScanGlobalState &gstate, bool &first_read) {\n+\tAllocatedData buffer;\n+\tif (current_buffer_handle && --current_buffer_handle->readers == 0) {\n+\t\tD_ASSERT(current_reader);\n+\t\t// Take ownership of the last buffer this thread used and remove entry from map\n+\t\tbuffer = current_reader->RemoveBuffer(current_buffer_handle->buffer_index);\n+\t} else {\n+\t\t// Allocate a new buffer\n+\t\tbuffer = gstate.allocator.Allocate(gstate.buffer_capacity);\n+\t}\n+\tbuffer_ptr = (const char *)buffer.get();\n+\n+\tif (current_reader && current_reader->GetOptions().format == JSONFormat::UNSTRUCTURED) {\n+\t\t// Copy last bit of previous buffer\n+\t\tmemcpy(buffer.get(), reconstruct_buffer.get(), prev_buffer_remainder);\n+\t}\n+\n+\tidx_t buffer_index;\n+\twhile (true) {\n+\t\tif (current_reader) {\n+\t\t\tif (current_reader->GetFileHandle().CanSeek()) {\n+\t\t\t\tReadNextBufferSeek(gstate, first_read, buffer_index);\n+\t\t\t} else {\n+\t\t\t\tReadNextBufferNoSeek(gstate, first_read, buffer_index);\n+\t\t\t}\n+\t\t\tif (buffer_size != 0) {\n+\t\t\t\tif (current_reader->GetOptions().format == JSONFormat::NEWLINE_DELIMITED) {\n+\t\t\t\t\tlock_guard<mutex> guard(gstate.lock);\n+\t\t\t\t\tbatch_index = gstate.batch_index++;\n+\t\t\t\t}\n+\t\t\t\tbreak; // We read something!\n+\t\t\t}\n+\t\t}\n+\n+\t\t// No reader, or exhausted current reader\n+\t\tlock_guard<mutex> guard(gstate.lock);\n+\t\tD_ASSERT(gstate.file_index <= gstate.json_readers.size());\n+\t\tif (gstate.file_index == gstate.json_readers.size()) {\n+\t\t\treturn false; // No more files left\n+\t\t}\n+\t\tif (current_reader && current_reader == gstate.json_readers[gstate.file_index].get() &&\n+\t\t    current_reader->GetOptions().format == JSONFormat::NEWLINE_DELIMITED) {\n+\t\t\t// We had a reader, but we didn't read anything, move to the next file\n+\t\t\tgstate.file_index++;\n+\t\t}\n+\t\t// Check again since we may have just updated\n+\t\tif (gstate.file_index == gstate.json_readers.size()) {\n+\t\t\treturn false; // No more files left\n+\t\t}\n+\n+\t\t// Try the next reader\n+\t\tcurrent_reader = gstate.json_readers[gstate.file_index].get();\n+\t\tif (current_reader->IsOpen()) {\n+\t\t\tcontinue; // It's open, this thread joins the scan\n+\t\t}\n+\n+\t\t// Unopened file\n+\t\tauto &options = current_reader->GetOptions();\n+\t\tcurrent_reader->OpenJSONFile();\n+\t\tbatch_index = gstate.batch_index++;\n+\t\tif (options.format == JSONFormat::UNSTRUCTURED) {\n+\t\t\tgstate.file_index++; // UNSTRUCTURED necessitates single-threaded read\n+\t\t}\n+\t\tif (options.format != JSONFormat::AUTO_DETECT) {\n+\t\t\tcontinue; // Re-enter loop to proceed reading\n+\t\t}\n+\n+\t\t// We have to detect whether it's UNSTRUCTURED/NEWLINE_DELIMITED - hold the gstate lock while we do this\n+\t\tif (current_reader->GetFileHandle().CanSeek()) {\n+\t\t\tReadNextBufferSeek(gstate, first_read, buffer_index);\n+\t\t} else {\n+\t\t\tReadNextBufferNoSeek(gstate, first_read, buffer_index);\n+\t\t}\n+\n+\t\tif (buffer_size == 0) {\n+\t\t\tgstate.file_index++; // Empty file, move to the next one\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tauto line_end = NextNewline(buffer_ptr, buffer_size);\n+\t\tif (line_end == nullptr) {\n+\t\t\toptions.format = JSONFormat::UNSTRUCTURED; // No newlines in buffer at all\n+\t\t\tgstate.file_index++;                       // UNSTRUCTURED necessitates single-threaded read\n+\t\t\tbreak;\n+\t\t}\n+\t\tidx_t line_size = line_end - buffer_ptr;\n+\n+\t\tyyjson_read_err error;\n+\t\tJSONCommon::ReadDocumentUnsafe((char *)buffer_ptr, line_size, JSONCommon::READ_FLAG,\n+\t\t                               json_allocator.GetYYJSONAllocator(), &error);\n+\t\t// Detected format depends on whether we can successfully read the first line\n+\t\tif (error.code == YYJSON_READ_SUCCESS) {\n+\t\t\toptions.format = JSONFormat::NEWLINE_DELIMITED;\n+\t\t} else {\n+\t\t\toptions.format = JSONFormat::UNSTRUCTURED;\n+\t\t\tgstate.file_index++; // UNSTRUCTURED necessitates single-threaded read\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tD_ASSERT(buffer_size != 0); // We should have read something if we got here\n+\n+\tidx_t readers;\n+\tif (current_reader->GetOptions().format == JSONFormat::UNSTRUCTURED) {\n+\t\treaders = 1;\n+\t} else {\n+\t\treaders = is_last ? 1 : 2;\n+\t}\n+\n+\t// Create an entry and insert it into the map\n+\tauto json_buffer_handle = make_unique<JSONBufferHandle>(buffer_index, readers, move(buffer), buffer_size);\n+\tcurrent_buffer_handle = json_buffer_handle.get();\n+\tcurrent_reader->InsertBuffer(buffer_index, std::move(json_buffer_handle));\n+\n+\tbuffer_offset = 0;\n+\tprev_buffer_remainder = 0;\n+\n+\tif (current_reader->GetOptions().format == JSONFormat::UNSTRUCTURED) {\n+\t\tmemset((void *)(buffer_ptr + buffer_size), 0, YYJSON_PADDING_SIZE);\n+\t\tmemcpy((void *)buffer_copy_ptr, buffer_ptr, buffer_size + YYJSON_PADDING_SIZE);\n+\t}\n+\n+\treturn true;\n+}\n+\n+void JSONScanLocalState::ReadNextBufferSeek(JSONScanGlobalState &gstate, bool &first_read, idx_t &buffer_index) {\n+\tauto &file_handle = current_reader->GetFileHandle();\n+\n+\tidx_t request_size = gstate.buffer_capacity - prev_buffer_remainder - YYJSON_PADDING_SIZE;\n+\tidx_t read_position;\n+\tidx_t read_size;\n+\n+\t{\n+\t\tlock_guard<mutex> guard(current_reader->lock);\n+\t\tbuffer_index = current_reader->GetBufferIndex();\n+\n+\t\tread_size = file_handle.GetPositionAndSize(read_position, request_size);\n+\t\tfirst_read = read_position == 0;\n+\t\tis_last = file_handle.Remaining() == 0;\n+\n+\t\tif (!gstate.bind_data.ignore_errors && read_size == 0 && prev_buffer_remainder != 0) {\n+\t\t\tthrow InvalidInputException(\"Invalid JSON detected at the end of file %s\", current_reader->file_path);\n+\t\t}\n+\t}\n+\tbuffer_size = prev_buffer_remainder + read_size;\n+\tif (buffer_size == 0) {\n+\t\treturn;\n+\t}\n+\n+\t// Now read the file lock-free!\n+\tfile_handle.ReadAtPosition(buffer_ptr + prev_buffer_remainder, read_size, read_position);\n+}\n+\n+void JSONScanLocalState::ReadNextBufferNoSeek(JSONScanGlobalState &gstate, bool &first_read, idx_t &buffer_index) {\n+\tauto &file_handle = current_reader->GetFileHandle();\n+\n+\tidx_t request_size = gstate.buffer_capacity - prev_buffer_remainder - YYJSON_PADDING_SIZE;\n+\tidx_t read_size;\n+\t{\n+\t\tlock_guard<mutex> guard(gstate.lock);\n+\t\tbuffer_index = current_reader->GetBufferIndex();\n+\n+\t\tfirst_read = file_handle.Remaining() == file_handle.FileSize();\n+\t\tread_size = file_handle.Read(buffer_ptr + prev_buffer_remainder, request_size);\n+\t\tis_last = read_size < request_size;\n+\n+\t\tif (!gstate.bind_data.ignore_errors && read_size == 0 && prev_buffer_remainder != 0) {\n+\t\t\tthrow InvalidInputException(\"Invalid JSON detected at the end of file %s\", current_reader->file_path);\n+\t\t}\n+\t}\n+\tbuffer_size = prev_buffer_remainder + read_size;\n+}\n+\n+void JSONScanLocalState::ReconstructFirstObject(JSONScanGlobalState &gstate) {\n+\tD_ASSERT(current_buffer_handle->buffer_index != 0);\n+\tD_ASSERT(current_reader->GetOptions().format == JSONFormat::NEWLINE_DELIMITED);\n+\n+\t// Spinlock until the previous batch index has also read its buffer\n+\tJSONBufferHandle *previous_buffer_handle = nullptr;\n+\twhile (!previous_buffer_handle) {\n+\t\tprevious_buffer_handle = current_reader->GetBuffer(current_buffer_handle->buffer_index - 1);\n+\t}\n+\n+\t// First we find the newline in the previous block\n+\tauto prev_buffer_ptr = (const char *)previous_buffer_handle->buffer.get() + previous_buffer_handle->buffer_size;\n+\tauto part1_ptr = PreviousNewline(prev_buffer_ptr);\n+\tauto part1_size = prev_buffer_ptr - part1_ptr;\n+\n+\t// Now copy the data to our reconstruct buffer\n+\tconst auto reconstruct_ptr = reconstruct_buffer.get();\n+\tmemcpy(reconstruct_ptr, part1_ptr, part1_size);\n+\t// Now find the newline in the current block\n+\tauto line_end = NextNewline(buffer_ptr, buffer_size);\n+\tif (line_end == nullptr) { // TODO I don't think we can ignore this even with ignore_errors ...\n+\t\tthrow InvalidInputException(\"maximum_object_size of %llu bytes exceeded (>%llu bytes), is the JSON valid?\",\n+\t\t                            gstate.bind_data.maximum_object_size, buffer_size - buffer_offset);\n+\t} else {\n+\t\tline_end++;\n+\t}\n+\tidx_t part2_size = line_end - buffer_ptr;\n+\n+\t// And copy the remainder of the line to the reconstruct buffer\n+\tmemcpy(reconstruct_ptr + part1_size, buffer_ptr, part2_size);\n+\tbuffer_offset += part2_size;\n+\n+\t// We copied the object, so we are no longer reading the previous buffer\n+\tif (--previous_buffer_handle->readers == 0) {\n+\t\tcurrent_reader->RemoveBuffer(current_buffer_handle->buffer_index - 1);\n+\t}\n+\n+\tobjects[0] = ParseLine((char *)reconstruct_ptr, part1_size + part2_size, lines[0], gstate.bind_data.ignore_errors);\n+}\n+\n+void JSONScanLocalState::ReadUnstructured(idx_t &count) {\n+\tconst auto max_obj_size = reconstruct_buffer.GetSize();\n+\tyyjson_read_err error;\n+\tfor (; count < STANDARD_VECTOR_SIZE; count++) {\n+\t\tconst auto obj_start = buffer_ptr + buffer_offset;\n+\t\tconst auto obj_copy_start = buffer_copy_ptr + buffer_offset;\n+\n+\t\tidx_t remaining = buffer_size - buffer_offset;\n+\t\tif (remaining == 0) {\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t// Read next JSON doc\n+\t\tauto read_doc = JSONCommon::ReadDocumentUnsafe((char *)obj_start, remaining, JSONCommon::STOP_READ_FLAG,\n+\t\t                                               json_allocator.GetYYJSONAllocator(), &error);\n+\t\tif (error.code == YYJSON_READ_SUCCESS) {\n+\t\t\tidx_t line_size = yyjson_doc_get_read_size(read_doc);\n+\t\t\tlines[count] = JSONLine(obj_copy_start, line_size);\n+\t\t\tTrimWhitespace(lines[count]);\n+\n+\t\t\tbuffer_offset += line_size;\n+\t\t\tSkipWhitespace(buffer_ptr, buffer_offset, buffer_size);\n+\t\t} else if (error.pos > max_obj_size) {\n+\t\t\tJSONCommon::ThrowParseError(obj_copy_start, remaining, error,\n+\t\t\t                            \"Have you tried increasing maximum_object_size?\");\n+\t\t} else if (error.code == YYJSON_READ_ERROR_UNEXPECTED_END && !is_last) {\n+\t\t\t// Copy remaining to reconstruct_buffer\n+\t\t\tconst auto reconstruct_ptr = reconstruct_buffer.get();\n+\t\t\tmemcpy(reconstruct_ptr, obj_copy_start, remaining);\n+\t\t\tprev_buffer_remainder = remaining;\n+\t\t\tbuffer_offset = buffer_size;\n+\t\t\tbreak;\n+\t\t} else {\n+\t\t\tJSONCommon::ThrowParseError(obj_copy_start, remaining, error);\n+\t\t}\n+\t\tobjects[count] = read_doc;\n+\t}\n+}\n+\n+void JSONScanLocalState::ReadNewlineDelimited(idx_t &count, const bool &ignore_errors) {\n+\tfor (; count < STANDARD_VECTOR_SIZE; count++) {\n+\t\tauto line_start = buffer_ptr + buffer_offset;\n+\t\tidx_t remaining = buffer_size - buffer_offset;\n+\t\tif (remaining == 0) {\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t// Search for newline\n+\t\tauto line_end = NextNewline(line_start, remaining);\n+\n+\t\tif (line_end == nullptr) {\n+\t\t\t// We reached the end of the buffer\n+\t\t\tif (!is_last) {\n+\t\t\t\t// Last bit of data belongs to the next batch\n+\t\t\t\tbuffer_offset = buffer_size;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tline_end = line_start + remaining;\n+\t\t}\n+\t\tidx_t line_size = line_end - line_start;\n+\n+\t\tobjects[count] = ParseLine((char *)line_start, line_size, lines[count], ignore_errors);\n+\n+\t\tbuffer_offset += line_size;\n+\t\tSkipWhitespace(buffer_ptr, buffer_offset, buffer_size);\n+\t}\n+}\n+\n+idx_t JSONScanLocalState::GetBatchIndex() const {\n+\treturn batch_index;\n+}\n+\n+} // namespace duckdb\ndiff --git a/extension/json/yyjson/include/yyjson.hpp b/extension/json/yyjson/include/yyjson.hpp\nindex 9cb8f54ebb61..e3edb7036261 100644\n--- a/extension/json/yyjson/include/yyjson.hpp\n+++ b/extension/json/yyjson/include/yyjson.hpp\n@@ -1,10 +1,10 @@\n /*==============================================================================\n-* Created by Yaoyuan on 2019/3/9.\n-* Copyright (C) 2019 Yaoyuan <ibireme@gmail.com>.\n-*\n-* Released under the MIT License:\n-* https://github.com/ibireme/yyjson/blob/master/LICENSE\n-*============================================================================*/\n+ * Created by Yaoyuan on 2019/3/9.\n+ * Copyright (C) 2019 Yaoyuan <ibireme@gmail.com>.\n+ *\n+ * Released under the MIT License:\n+ * https://github.com/ibireme/yyjson/blob/master/LICENSE\n+ *============================================================================*/\n \n /** @file yyjson.h */\n \n@@ -14,8 +14,8 @@\n \n \n /*==============================================================================\n-* Header Files\n-*============================================================================*/\n+ * Header Files\n+ *============================================================================*/\n \n #include <stdlib.h>\n #include <stddef.h>\n@@ -27,82 +27,85 @@\n \n \n /*==============================================================================\n-* Compile-time Options\n-*============================================================================*/\n+ * Compile-time Options\n+ *============================================================================*/\n \n /*\n-Define as 1 to disable JSON reader if you don't need to parse JSON.\n-\n-This will disable these functions at compile-time:\n-   - yyjson_read_opts()\n-   - yyjson_read_file()\n-   - yyjson_read()\n-\n-This will reduce the binary size by about 60%.\n-*/\n+ Define as 1 to disable JSON reader if you don't need to parse JSON.\n+ \n+ This will disable these functions at compile-time:\n+    - yyjson_read_opts()\n+    - yyjson_read_file()\n+    - yyjson_read()\n+    - yyjson_read_number()\n+    - yyjson_mut_read_number()\n+ \n+ This will reduce the binary size by about 60%.\n+ */\n #ifndef YYJSON_DISABLE_READER\n #endif\n \n /*\n-Define as 1 to disable JSON writer if you don't need to serialize JSON.\n-\n-This will disable these functions at compile-time:\n-   - yyjson_write()\n-   - yyjson_write_file()\n-   - yyjson_write_opts()\n-   - yyjson_val_write()\n-   - yyjson_val_write_file()\n-   - yyjson_val_write_opts()\n-   - yyjson_mut_write()\n-   - yyjson_mut_write_file()\n-   - yyjson_mut_write_opts()\n-   - yyjson_mut_val_write()\n-   - yyjson_mut_val_write_file()\n-   - yyjson_mut_val_write_opts()\n-\n-This will reduce the binary size by about 30%.\n-*/\n+ Define as 1 to disable JSON writer if you don't need to serialize JSON.\n+ \n+ This will disable these functions at compile-time:\n+    - yyjson_write()\n+    - yyjson_write_file()\n+    - yyjson_write_opts()\n+    - yyjson_val_write()\n+    - yyjson_val_write_file()\n+    - yyjson_val_write_opts()\n+    - yyjson_mut_write()\n+    - yyjson_mut_write_file()\n+    - yyjson_mut_write_opts()\n+    - yyjson_mut_val_write()\n+    - yyjson_mut_val_write_file()\n+    - yyjson_mut_val_write_opts()\n+ \n+ This will reduce the binary size by about 30%.\n+ */\n #ifndef YYJSON_DISABLE_WRITER\n #endif\n \n /*\n-Define as 1 to disable the fast floating-point number conversion in yyjson,\n-and use libc's `strtod/snprintf` instead.\n-\n-This will reduce binary size by about 30%, but significantly slow down\n-floating-point reading and writing speed.\n-*/\n+ Define as 1 to disable the fast floating-point number conversion in yyjson,\n+ and use libc's `strtod/snprintf` instead.\n+ \n+ This will reduce the binary size by about 30%, but significantly slow down the\n+ floating-point read/write speed.\n+ */\n #ifndef YYJSON_DISABLE_FAST_FP_CONV\n #endif\n \n /*\n-Define as 1 to disable non-standard JSON support at compile-time:\n-   - Reading and writing inf/nan literal, such as 'NaN', '-Infinity'.\n-   - Single line and multiple line comments.\n-   - Single trailing comma at the end of an object or array.\n-   - Invalid unicode in string value.\n-\n-This will also invalidate these run-time options:\n-   - YYJSON_READ_ALLOW_INF_AND_NAN\n-   - YYJSON_READ_ALLOW_COMMENTS\n-   - YYJSON_READ_ALLOW_TRAILING_COMMAS\n-   - YYJSON_READ_ALLOW_INVALID_UNICODE\n-   - YYJSON_WRITE_ALLOW_INF_AND_NAN\n-   - YYJSON_WRITE_ALLOW_INVALID_UNICODE\n-\n-This will reduce binary size by about 10%, and increase performance slightly.\n-*/\n+ Define as 1 to disable non-standard JSON support at compile-time:\n+    - Reading and writing inf/nan literal, such as `NaN`, `-Infinity`.\n+    - Single line and multiple line comments.\n+    - Single trailing comma at the end of an object or array.\n+    - Invalid unicode in string value.\n+ \n+ This will also invalidate these run-time options:\n+    - YYJSON_READ_ALLOW_INF_AND_NAN\n+    - YYJSON_READ_ALLOW_COMMENTS\n+    - YYJSON_READ_ALLOW_TRAILING_COMMAS\n+    - YYJSON_READ_ALLOW_INVALID_UNICODE\n+    - YYJSON_WRITE_ALLOW_INF_AND_NAN\n+    - YYJSON_WRITE_ALLOW_INVALID_UNICODE\n+ \n+ This will reduce the binary size by about 10%, and slightly improve the JSON\n+ read/write speed.\n+ */\n #ifndef YYJSON_DISABLE_NON_STANDARD\n #endif\n \n /*\n-Define as 1 to disable unaligned memory access if target architecture does not\n-support unaligned memory access (such as some embedded processors).\n-\n-If this value is not defined, yyjson will perform some automatic detection.\n-The wrong definition of this option may cause some performance degradation,\n-but will not cause run-time errors.\n-*/\n+ Define as 1 to disable unaligned memory access if target architecture does not\n+ support unaligned memory access (such as some embedded processors).\n+ \n+ If this value is not defined, yyjson will perform some automatic detection.\n+ The wrong definition of this option may cause some performance degradation,\n+ but will not cause any run-time errors.\n+ */\n #ifndef YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n #endif\n \n@@ -125,8 +128,8 @@ but will not cause run-time errors.\n \n \n /*==============================================================================\n-* Compiler Macros\n-*============================================================================*/\n+ * Compiler Macros\n+ *============================================================================*/\n \n /** compiler version (MSVC) */\n #ifdef _MSC_VER\n@@ -226,7 +229,7 @@ but will not cause run-time errors.\n \n /** likely for compiler */\n #ifndef yyjson_likely\n-#   if yyjson_has_builtin(__builtin_expect) || YYJSON_GCC_VER >= 4\n+#   if yyjson_has_builtin(__builtin_expect) || (YYJSON_GCC_VER >= 4 && YYJSON_GCC_VER != 5)\n #       define yyjson_likely(expr) __builtin_expect(!!(expr), 1)\n #   else\n #       define yyjson_likely(expr) (expr)\n@@ -235,7 +238,7 @@ but will not cause run-time errors.\n \n /** unlikely for compiler */\n #ifndef yyjson_unlikely\n-#   if yyjson_has_builtin(__builtin_expect) || YYJSON_GCC_VER >= 4\n+#   if yyjson_has_builtin(__builtin_expect) || (YYJSON_GCC_VER >= 4 && YYJSON_GCC_VER != 5)\n #       define yyjson_unlikely(expr) __builtin_expect(!!(expr), 0)\n #   else\n #       define yyjson_unlikely(expr) (expr)\n@@ -266,75 +269,75 @@ but will not cause run-time errors.\n \n /** stdint (C89 compatible) */\n #if (defined(YYJSON_HAS_STDINT_H) && YYJSON_HAS_STDINT_H) || \\\n-   YYJSON_MSC_VER >= 1600 || YYJSON_STDC_VER >= 199901L || \\\n-   defined(_STDINT_H) || defined(_STDINT_H_) || \\\n-   defined(__CLANG_STDINT_H) || defined(_STDINT_H_INCLUDED) || \\\n-   yyjson_has_include(<stdint.h>)\n+    YYJSON_MSC_VER >= 1600 || YYJSON_STDC_VER >= 199901L || \\\n+    defined(_STDINT_H) || defined(_STDINT_H_) || \\\n+    defined(__CLANG_STDINT_H) || defined(_STDINT_H_INCLUDED) || \\\n+    yyjson_has_include(<stdint.h>)\n #   include <stdint.h>\n #elif defined(_MSC_VER)\n #   if _MSC_VER < 1300\n-typedef signed char         int8_t;\n-typedef signed short        int16_t;\n-typedef signed int          int32_t;\n-typedef unsigned char       uint8_t;\n-typedef unsigned short      uint16_t;\n-typedef unsigned int        uint32_t;\n-typedef signed __int64      int64_t;\n-typedef unsigned __int64    uint64_t;\n+        typedef signed char         int8_t;\n+        typedef signed short        int16_t;\n+        typedef signed int          int32_t;\n+        typedef unsigned char       uint8_t;\n+        typedef unsigned short      uint16_t;\n+        typedef unsigned int        uint32_t;\n+        typedef signed __int64      int64_t;\n+        typedef unsigned __int64    uint64_t;\n #   else\n-typedef signed __int8       int8_t;\n-typedef signed __int16      int16_t;\n-typedef signed __int32      int32_t;\n-typedef unsigned __int8     uint8_t;\n-typedef unsigned __int16    uint16_t;\n-typedef unsigned __int32    uint32_t;\n-typedef signed __int64      int64_t;\n-typedef unsigned __int64    uint64_t;\n+        typedef signed __int8       int8_t;\n+        typedef signed __int16      int16_t;\n+        typedef signed __int32      int32_t;\n+        typedef unsigned __int8     uint8_t;\n+        typedef unsigned __int16    uint16_t;\n+        typedef unsigned __int32    uint32_t;\n+        typedef signed __int64      int64_t;\n+        typedef unsigned __int64    uint64_t;\n #   endif\n #else\n #   if UCHAR_MAX == 0xFFU\n-typedef signed char     int8_t;\n-typedef unsigned char   uint8_t;\n+        typedef signed char     int8_t;\n+        typedef unsigned char   uint8_t;\n #   else\n #       error cannot find 8-bit integer type\n #   endif\n #   if USHRT_MAX == 0xFFFFU\n-typedef unsigned short  uint16_t;\n-typedef signed short    int16_t;\n+        typedef unsigned short  uint16_t;\n+        typedef signed short    int16_t;\n #   elif UINT_MAX == 0xFFFFU\n-typedef unsigned int    uint16_t;\n-typedef signed int      int16_t;\n+        typedef unsigned int    uint16_t;\n+        typedef signed int      int16_t;\n #   else\n #       error cannot find 16-bit integer type\n #   endif\n #   if UINT_MAX == 0xFFFFFFFFUL\n-typedef unsigned int    uint32_t;\n-typedef signed int      int32_t;\n+        typedef unsigned int    uint32_t;\n+        typedef signed int      int32_t;\n #   elif ULONG_MAX == 0xFFFFFFFFUL\n-typedef unsigned long   uint32_t;\n-typedef signed long     int32_t;\n+        typedef unsigned long   uint32_t;\n+        typedef signed long     int32_t;\n #   elif USHRT_MAX == 0xFFFFFFFFUL\n-typedef unsigned short  uint32_t;\n-typedef signed short    int32_t;\n+        typedef unsigned short  uint32_t;\n+        typedef signed short    int32_t;\n #   else\n #       error cannot find 32-bit integer type\n #   endif\n #   if defined(__INT64_TYPE__) && defined(__UINT64_TYPE__)\n-typedef __INT64_TYPE__  int64_t;\n-typedef __UINT64_TYPE__ uint64_t;\n+        typedef __INT64_TYPE__  int64_t;\n+        typedef __UINT64_TYPE__ uint64_t;\n #   elif defined(__GNUC__) || defined(__clang__)\n #       if !defined(_SYS_TYPES_H) && !defined(__int8_t_defined)\n-__extension__ typedef long long             int64_t;\n+        __extension__ typedef long long             int64_t;\n #       endif\n-__extension__ typedef unsigned long long    uint64_t;\n+        __extension__ typedef unsigned long long    uint64_t;\n #   elif defined(_LONG_LONG) || defined(__MWERKS__) || defined(_CRAYC) || \\\n-\t   defined(__SUNPRO_C) || defined(__SUNPRO_CC)\n-typedef long long           int64_t;\n-typedef unsigned long long  uint64_t;\n+        defined(__SUNPRO_C) || defined(__SUNPRO_CC)\n+        typedef long long           int64_t;\n+        typedef unsigned long long  uint64_t;\n #   elif (defined(__BORLANDC__) && __BORLANDC__ > 0x460) || \\\n-\t   defined(__WATCOM_INT64__) || defined (__alpha) || defined (__DECC)\n-typedef __int64             int64_t;\n-typedef unsigned __int64    uint64_t;\n+        defined(__WATCOM_INT64__) || defined (__alpha) || defined (__DECC)\n+        typedef __int64             int64_t;\n+        typedef unsigned __int64    uint64_t;\n #   else\n #       error cannot find 64-bit integer type\n #   endif\n@@ -342,8 +345,8 @@ typedef unsigned __int64    uint64_t;\n \n /** stdbool (C89 compatible) */\n #if (defined(YYJSON_HAS_STDBOOL_H) && YYJSON_HAS_STDBOOL_H) || \\\n-   (yyjson_has_include(<stdbool.h>) && !defined(__STRICT_ANSI__)) || \\\n-   YYJSON_MSC_VER >= 1800 || YYJSON_STDC_VER >= 199901L\n+    (yyjson_has_include(<stdbool.h>) && !defined(__STRICT_ANSI__)) || \\\n+    YYJSON_MSC_VER >= 1800 || YYJSON_STDC_VER >= 199901L\n #   include <stdbool.h>\n #elif !defined(__bool_true_false_are_defined)\n #   define __bool_true_false_are_defined 1\n@@ -373,8 +376,8 @@ typedef unsigned __int64    uint64_t;\n \n \n /*==============================================================================\n-* Compile Hint Begin\n-*============================================================================*/\n+ * Compile Hint Begin\n+ *============================================================================*/\n \n /* extern \"C\" begin */\n #ifdef __cplusplus\n@@ -400,23 +403,23 @@ extern \"C\" {\n \n \n /*==============================================================================\n-* Version\n-*============================================================================*/\n+ * Version\n+ *============================================================================*/\n \n /** The major version of yyjson. */\n #define YYJSON_VERSION_MAJOR  0\n \n /** The minor version of yyjson. */\n-#define YYJSON_VERSION_MINOR  5\n+#define YYJSON_VERSION_MINOR  6\n \n /** The patch version of yyjson. */\n-#define YYJSON_VERSION_PATCH  1\n+#define YYJSON_VERSION_PATCH  0\n \n-/** The version of yyjson in hex: (major << 16) | (minor << 8) | (patch). */\n-#define YYJSON_VERSION_HEX    0x000501\n+/** The version of yyjson in hex: `(major << 16) | (minor << 8) | (patch)`. */\n+#define YYJSON_VERSION_HEX    0x000600\n \n /** The version string of yyjson. */\n-#define YYJSON_VERSION_STRING \"0.5.1\"\n+#define YYJSON_VERSION_STRING \"0.6.0\"\n \n /** The version of yyjson in hex, same as `YYJSON_VERSION_HEX`. */\n yyjson_api uint32_t yyjson_version(void);\n@@ -424,8 +427,8 @@ yyjson_api uint32_t yyjson_version(void);\n \n \n /*==============================================================================\n-* JSON Types\n-*============================================================================*/\n+ * JSON Types\n+ *============================================================================*/\n \n /** Type of JSON value (3 bit). */\n typedef uint8_t yyjson_type;\n@@ -447,7 +450,7 @@ typedef uint8_t yyjson_subtype;\n #define YYJSON_SUBTYPE_SINT     ((uint8_t)(1 << 3)) /* ___01___ */\n #define YYJSON_SUBTYPE_REAL     ((uint8_t)(2 << 3)) /* ___10___ */\n \n-/** Mask and bits of JSON value. */\n+/** Mask and bits of JSON value tag. */\n #define YYJSON_TYPE_MASK        ((uint8_t)0x07)     /* _____111 */\n #define YYJSON_TYPE_BIT         ((uint8_t)3)\n #define YYJSON_SUBTYPE_MASK     ((uint8_t)0x18)     /* ___11___ */\n@@ -463,150 +466,150 @@ typedef uint8_t yyjson_subtype;\n \n \n /*==============================================================================\n-* Allocator\n-*============================================================================*/\n+ * Allocator\n+ *============================================================================*/\n \n /**\n-A memory allocator.\n-\n-Typically you don't need to use it, unless you want to customize your own\n-memory allocator.\n-*/\n+ A memory allocator.\n+ \n+ Typically you don't need to use it, unless you want to customize your own\n+ memory allocator.\n+ */\n typedef struct yyjson_alc {\n-   /** Same as libc's malloc(), should not be NULL. */\n-   void *(*malloc)(void *ctx, size_t size);\n-   /** Same as libc's realloc(), should not be NULL. */\n-   void *(*realloc)(void *ctx, void *ptr, size_t size);\n-   /** Same as libc's free(), should not be NULL. */\n-   void (*free)(void *ctx, void *ptr);\n-   /** A context for malloc/realloc/free, can be NULL. */\n-   void *ctx;\n+    /** Same as libc's malloc(size), should not be NULL. */\n+    void *(*malloc)(void *ctx, size_t size);\n+    /** Same as libc's realloc(ptr, size), should not be NULL. */\n+    void *(*realloc)(void *ctx, void *ptr, size_t old_size, size_t size);\n+    /** Same as libc's free(ptr), should not be NULL. */\n+    void (*free)(void *ctx, void *ptr);\n+    /** A context for malloc/realloc/free, can be NULL. */\n+    void *ctx;\n } yyjson_alc;\n \n /**\n-A pool allocator uses fixed length pre-allocated memory.\n-\n-This allocator may used to avoid malloc()/memmove() calls. The pre-allocated\n-memory should be held by the caller. The upper limit of memory required to\n-read JSON can be calculated using the yyjson_read_max_memory_usage() function,\n-but the memory required to write JSON cannot be calculated directly.\n-\n-This is not a general-purpose allocator, and should only be used to read or\n-write single JSON document.\n-\n-@param alc The allocator to be initialized.\n-   If this parameter is NULL, the function will fail and return false.\n-   If `buf` or `size` is invalid, this parameter is left unmodified.\n-@param buf The buffer memory for this allocator.\n-   If this parameter is NULL, the function will fail and return false.\n-@param size The size of `buf`, in bytes.\n-   If this parameter is less than 8 words (32/64 bytes on 32/64-bit OS), the\n-   function will fail and return false.\n-@return true if the `alc` has been successfully initialized.\n-\n-@par Example\n-@code\n-   // parse JSON with stack memory\n-   char buf[1024];\n-   yyjson_alc alc;\n-   yyjson_alc_pool_init(&alc, buf, 1024);\n-\n-   const char *json = \"{\\\"name\\\":\\\"Helvetica\\\",\\\"size\\\":16}\"\n-   yyjson_doc *doc = yyjson_read_opts(json, strlen(json), 0, &alc, NULL);\n-   // the memory of `doc` is on the stack\n-@endcode\n-*/\n+ A pool allocator uses fixed length pre-allocated memory.\n+ \n+ This allocator may used to avoid malloc/realloc calls. The pre-allocated memory\n+ should be held by the caller. The maximum amount of memory required to read a\n+ JSON can be calculated using the `yyjson_read_max_memory_usage()` function, but\n+ the amount of memory required to write a JSON cannot be directly calculated.\n+ \n+ This is not a general-purpose allocator, and should only be used to read or\n+ write single JSON document.\n+ \n+ @param alc The allocator to be initialized.\n+    If this parameter is NULL, the function will fail and return false.\n+    If `buf` or `size` is invalid, this will be set to an empty allocator.\n+ @param buf The buffer memory for this allocator.\n+    If this parameter is NULL, the function will fail and return false.\n+ @param size The size of `buf`, in bytes.\n+    If this parameter is less than 8 words (32/64 bytes on 32/64-bit OS), the\n+    function will fail and return false.\n+ @return true if the `alc` has been successfully initialized.\n+ \n+ @par Example\n+ @code\n+    // parse JSON with stack memory\n+    char buf[1024];\n+    yyjson_alc alc;\n+    yyjson_alc_pool_init(&alc, buf, 1024);\n+    \n+    const char *json = \"{\\\"name\\\":\\\"Helvetica\\\",\\\"size\\\":16}\"\n+    yyjson_doc *doc = yyjson_read_opts(json, strlen(json), 0, &alc, NULL);\n+    // the memory of `doc` is on the stack\n+ @endcode\n+ */\n yyjson_api bool yyjson_alc_pool_init(yyjson_alc *alc, void *buf, size_t size);\n \n \n \n /*==============================================================================\n-* JSON Structure\n-*============================================================================*/\n+ * JSON Structure\n+ *============================================================================*/\n \n /**\n-An immutable document for reading JSON.\n-This document holds memory for all its JSON values and strings. When it is no\n-longer used, the user should call yyjson_doc_free() to free its memory.\n-*/\n+ An immutable document for reading JSON.\n+ This document holds memory for all its JSON values and strings. When it is no\n+ longer used, the user should call `yyjson_doc_free()` to free its memory.\n+ */\n typedef struct yyjson_doc yyjson_doc;\n \n /**\n-An immutable value for reading JSON.\n-A JSON Value has the same lifetime as its document. The memory is held by its\n-document and and cannot be freed alone.\n-*/\n+ An immutable value for reading JSON.\n+ A JSON Value has the same lifetime as its document. The memory is held by its\n+ document and and cannot be freed alone.\n+ */\n typedef struct yyjson_val yyjson_val;\n \n /**\n-A mutable document for building JSON.\n-This document holds memory for all its JSON values and strings. When it is no\n-longer used, the user should call yyjson_mut_doc_free() to free its memory.\n-*/\n+ A mutable document for building JSON.\n+ This document holds memory for all its JSON values and strings. When it is no\n+ longer used, the user should call `yyjson_mut_doc_free()` to free its memory.\n+ */\n typedef struct yyjson_mut_doc yyjson_mut_doc;\n \n /**\n-A mutable value for building JSON.\n-A JSON Value has the same lifetime as its document. The memory is held by its\n-document and and cannot be freed alone.\n-*/\n+ A mutable value for building JSON.\n+ A JSON Value has the same lifetime as its document. The memory is held by its\n+ document and and cannot be freed alone.\n+ */\n typedef struct yyjson_mut_val yyjson_mut_val;\n \n \n \n /*==============================================================================\n-* JSON Reader API\n-*============================================================================*/\n+ * JSON Reader API\n+ *============================================================================*/\n \n /** Run-time options for JSON reader. */\n typedef uint32_t yyjson_read_flag;\n \n /** Default option (RFC 8259 compliant):\n-   - Read positive integer as uint64_t.\n-   - Read negative integer as int64_t.\n-   - Read floating-point number as double with round-to-nearest mode.\n-   - Read integer which cannot fit in uint64_t or int64_t as double.\n-   - Report error if real number is infinity.\n-   - Report error if string contains invalid UTF-8 character or BOM.\n-   - Report error on trailing commas, comments, inf and nan literals. */\n+    - Read positive integer as uint64_t.\n+    - Read negative integer as int64_t.\n+    - Read floating-point number as double with round-to-nearest mode.\n+    - Read integer which cannot fit in uint64_t or int64_t as double.\n+    - Report error if real number is infinity.\n+    - Report error if string contains invalid UTF-8 character or BOM.\n+    - Report error on trailing commas, comments, inf and nan literals. */\n static const yyjson_read_flag YYJSON_READ_NOFLAG                = 0 << 0;\n \n /** Read the input data in-situ.\n-   This option allows the reader to modify and use input data to store string\n-   values, which can increase reading speed slightly.\n-   The caller should hold the input data before free the document.\n-   The input data must be padded by at least `YYJSON_PADDING_SIZE` bytes.\n-   For example: \"[1,2]\" should be \"[1,2]\\0\\0\\0\\0\", length should be 5. */\n+    This option allows the reader to modify and use input data to store string\n+    values, which can increase reading speed slightly.\n+    The caller should hold the input data before free the document.\n+    The input data must be padded by at least `YYJSON_PADDING_SIZE` bytes.\n+    For example: `[1,2]` should be `[1,2]\\0\\0\\0\\0`, input length should be 5. */\n static const yyjson_read_flag YYJSON_READ_INSITU                = 1 << 0;\n \n /** Stop when done instead of issuing an error if there's additional content\n-   after a JSON document. This option may be used to parse small pieces of JSON\n-   in larger data, such as `NDJSON`. */\n+    after a JSON document. This option may be used to parse small pieces of JSON\n+    in larger data, such as `NDJSON`. */\n static const yyjson_read_flag YYJSON_READ_STOP_WHEN_DONE        = 1 << 1;\n \n /** Allow single trailing comma at the end of an object or array,\n-   such as [1,2,3,] {\"a\":1,\"b\":2,} (non-standard). */\n+    such as `[1,2,3,]`, `{\"a\":1,\"b\":2,}` (non-standard). */\n static const yyjson_read_flag YYJSON_READ_ALLOW_TRAILING_COMMAS = 1 << 2;\n \n /** Allow C-style single line and multiple line comments (non-standard). */\n static const yyjson_read_flag YYJSON_READ_ALLOW_COMMENTS        = 1 << 3;\n \n /** Allow inf/nan number and literal, case-insensitive,\n-   such as 1e999, NaN, inf, -Infinity (non-standard). */\n+    such as 1e999, NaN, inf, -Infinity (non-standard). */\n static const yyjson_read_flag YYJSON_READ_ALLOW_INF_AND_NAN     = 1 << 4;\n \n-/** Read number as raw string (value with YYJSON_TYPE_RAW type),\n-   inf/nan literal is also read as raw with `ALLOW_INF_AND_NAN` flag. */\n+/** Read number as raw string (value with `YYJSON_TYPE_RAW` type),\n+    inf/nan literal is also read as raw with `ALLOW_INF_AND_NAN` flag. */\n static const yyjson_read_flag YYJSON_READ_NUMBER_AS_RAW         = 1 << 5;\n \n /** Allow reading invalid unicode when parsing string values (non-standard).\n-   Invalid characters will be allowed to appear in the string values, but\n-   invalid escape sequences will still be reported as errors.\n-   This flag does not affect the performance of correctly encoded strings.\n-\n-   @warning Strings in JSON values may contain incorrect encoding when this\n-   option is used, you need to handle these strings carefully to avoid security\n-   risks. */\n+    Invalid characters will be allowed to appear in the string values, but\n+    invalid escape sequences will still be reported as errors.\n+    This flag does not affect the performance of correctly encoded strings.\n+    \n+    @warning Strings in JSON values may contain incorrect encoding when this\n+    option is used, you need to handle these strings carefully to avoid security\n+    risks. */\n static const yyjson_read_flag YYJSON_READ_ALLOW_INVALID_UNICODE = 1 << 6;\n \n \n@@ -626,28 +629,28 @@ static const yyjson_read_code YYJSON_READ_ERROR_MEMORY_ALLOCATION       = 2;\n /** Input JSON string is empty. */\n static const yyjson_read_code YYJSON_READ_ERROR_EMPTY_CONTENT           = 3;\n \n-/** Unexpected content after document, such as \"[1]#\". */\n+/** Unexpected content after document, such as `[1]abc`. */\n static const yyjson_read_code YYJSON_READ_ERROR_UNEXPECTED_CONTENT      = 4;\n \n-/** Unexpected ending, such as \"[123\". */\n+/** Unexpected ending, such as `[123`. */\n static const yyjson_read_code YYJSON_READ_ERROR_UNEXPECTED_END          = 5;\n \n-/** Unexpected character inside the document, such as \"[#]\". */\n+/** Unexpected character inside the document, such as `[abc]`. */\n static const yyjson_read_code YYJSON_READ_ERROR_UNEXPECTED_CHARACTER    = 6;\n \n-/** Invalid JSON structure, such as \"[1,]\". */\n+/** Invalid JSON structure, such as `[1,]`. */\n static const yyjson_read_code YYJSON_READ_ERROR_JSON_STRUCTURE          = 7;\n \n /** Invalid comment, such as unclosed multi-line comment. */\n static const yyjson_read_code YYJSON_READ_ERROR_INVALID_COMMENT         = 8;\n \n-/** Invalid number, such as \"123.e12\", \"000\". */\n+/** Invalid number, such as `123.e12`, `000`. */\n static const yyjson_read_code YYJSON_READ_ERROR_INVALID_NUMBER          = 9;\n \n /** Invalid string, such as invalid escaped character inside a string. */\n static const yyjson_read_code YYJSON_READ_ERROR_INVALID_STRING          = 10;\n \n-/** Invalid JSON literal, such as \"truu\". */\n+/** Invalid JSON literal, such as `truu`. */\n static const yyjson_read_code YYJSON_READ_ERROR_LITERAL                 = 11;\n \n /** Failed to open a file. */\n@@ -658,162 +661,209 @@ static const yyjson_read_code YYJSON_READ_ERROR_FILE_READ               = 13;\n \n /** Error information for JSON reader. */\n typedef struct yyjson_read_err {\n-   /** Error code, see `yyjson_read_code` for all possible values. */\n-   yyjson_read_code code;\n-   /** Error message, constant, no need to free (NULL if success). */\n-   const char *msg;\n-   /** Error byte position for input data (0 if success). */\n-   size_t pos;\n+    /** Error code, see `yyjson_read_code` for all possible values. */\n+    yyjson_read_code code;\n+    /** Error message, constant, no need to free (NULL if success). */\n+    const char *msg;\n+    /** Error byte position for input data (0 if success). */\n+    size_t pos;\n } yyjson_read_err;\n \n \n \n /**\n-Read JSON with options.\n-\n-This function is thread-safe when:\n-1. The `dat` is not modified by other threads.\n-2. The `alc` is thread-safe or NULL.\n-\n-@param dat The JSON data (UTF-8 without BOM), null-terminator is not required.\n-   If this parameter is NULL, the function will fail and return NULL.\n-   The `dat` will not be modified without the flag `YYJSON_READ_INSITU`, so you\n-   can pass a `const char *` string and case it to `char *` if you don't use\n-   the `YYJSON_READ_INSITU` flag.\n-@param len The length of JSON data in bytes.\n-   If this parameter is 0, the function will fail and return NULL.\n-@param flg The JSON read options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param alc The memory allocator used by JSON reader.\n-   Pass NULL to use the libc's default allocator.\n-@param err A pointer to receive error information.\n-   Pass NULL if you don't need error information.\n-@return A new JSON document, or NULL if an error occurs.\n-   When it's no longer needed, it should be freed with yyjson_doc_free().\n-*/\n+ Read JSON with options.\n+ \n+ This function is thread-safe when:\n+ 1. The `dat` is not modified by other threads.\n+ 2. The `alc` is thread-safe or NULL.\n+ \n+ @param dat The JSON data (UTF-8 without BOM), null-terminator is not required.\n+    If this parameter is NULL, the function will fail and return NULL.\n+    The `dat` will not be modified without the flag `YYJSON_READ_INSITU`, so you\n+    can pass a `const char *` string and case it to `char *` if you don't use\n+    the `YYJSON_READ_INSITU` flag.\n+ @param len The length of JSON data in bytes.\n+    If this parameter is 0, the function will fail and return NULL.\n+ @param flg The JSON read options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param alc The memory allocator used by JSON reader.\n+    Pass NULL to use the libc's default allocator.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return A new JSON document, or NULL if an error occurs.\n+    When it's no longer needed, it should be freed with `yyjson_doc_free()`.\n+ */\n yyjson_api yyjson_doc *yyjson_read_opts(char *dat,\n-\t\t\t\t\t\t\t\t\t   size_t len,\n-\t\t\t\t\t\t\t\t\t   yyjson_read_flag flg,\n-\t\t\t\t\t\t\t\t\t   const yyjson_alc *alc,\n-\t\t\t\t\t\t\t\t\t   yyjson_read_err *err);\n+                                        size_t len,\n+                                        yyjson_read_flag flg,\n+                                        const yyjson_alc *alc,\n+                                        yyjson_read_err *err);\n \n /**\n-Read a JSON file.\n-\n-This function is thread-safe when:\n-1. The file is not modified by other threads.\n-2. The `alc` is thread-safe or NULL.\n-\n-@param path The JSON file's path.\n-   If this path is NULL or invalid, the function will fail and return NULL.\n-@param flg The JSON read options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param alc The memory allocator used by JSON reader.\n-   Pass NULL to use the libc's default allocator.\n-@param err A pointer to receive error information.\n-   Pass NULL if you don't need error information.\n-@return A new JSON document, or NULL if an error occurs.\n-   When it's no longer needed, it should be freed with yyjson_doc_free().\n-\n-@warning On 32-bit operating system, files larger than 2GB may fail to read.\n-*/\n+ Read a JSON file.\n+ \n+ This function is thread-safe when:\n+ 1. The file is not modified by other threads.\n+ 2. The `alc` is thread-safe or NULL.\n+ \n+ @param path The JSON file's path.\n+    If this path is NULL or invalid, the function will fail and return NULL.\n+ @param flg The JSON read options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param alc The memory allocator used by JSON reader.\n+    Pass NULL to use the libc's default allocator.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return A new JSON document, or NULL if an error occurs.\n+    When it's no longer needed, it should be freed with `yyjson_doc_free()`.\n+ \n+ @warning On 32-bit operating system, files larger than 2GB may fail to read.\n+ */\n yyjson_api yyjson_doc *yyjson_read_file(const char *path,\n-\t\t\t\t\t\t\t\t\t   yyjson_read_flag flg,\n-\t\t\t\t\t\t\t\t\t   const yyjson_alc *alc,\n-\t\t\t\t\t\t\t\t\t   yyjson_read_err *err);\n+                                        yyjson_read_flag flg,\n+                                        const yyjson_alc *alc,\n+                                        yyjson_read_err *err);\n \n /**\n-Read a JSON string.\n-\n-This function is thread-safe.\n-\n-@param dat The JSON data (UTF-8 without BOM), null-terminator is not required.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param len The length of JSON data in bytes.\n-   If this parameter is 0, the function will fail and return NULL.\n-@param flg The JSON read options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@return A new JSON document, or NULL if an error occurs.\n-   When it's no longer needed, it should be freed with yyjson_doc_free().\n-*/\n+ Read a JSON string.\n+ \n+ This function is thread-safe.\n+ \n+ @param dat The JSON data (UTF-8 without BOM), null-terminator is not required.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param len The length of JSON data in bytes.\n+    If this parameter is 0, the function will fail and return NULL.\n+ @param flg The JSON read options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @return A new JSON document, or NULL if an error occurs.\n+    When it's no longer needed, it should be freed with `yyjson_doc_free()`.\n+ */\n yyjson_api_inline yyjson_doc *yyjson_read(const char *dat,\n-\t\t\t\t\t\t\t\t\t\t size_t len,\n-\t\t\t\t\t\t\t\t\t\t yyjson_read_flag flg) {\n-   flg &= ~YYJSON_READ_INSITU; /* const string cannot be modified */\n-   return yyjson_read_opts((char *)dat, len, flg, NULL, NULL);\n+                                          size_t len,\n+                                          yyjson_read_flag flg) {\n+    flg &= ~YYJSON_READ_INSITU; /* const string cannot be modified */\n+    return yyjson_read_opts((char *)dat, len, flg, NULL, NULL);\n }\n \n /**\n-Returns the size of maximum memory usage to read a JSON data.\n-\n-You may use this value to avoid malloc() or calloc() call inside the reader\n-to get better performance, or read multiple JSON with one piece of memory.\n-\n-@param len The length of JSON data in bytes.\n-@param flg The JSON read options.\n-@return The maximum memory size to read this JSON, or 0 if overflow.\n-\n-@par Example\n-@code\n-   // read multiple JSON with same pre-allocated memory\n-\n-   char *dat1, *dat2, *dat3; // JSON data\n-   size_t len1, len2, len3; // JSON length\n-   size_t max_len = MAX(len1, MAX(len2, len3));\n-   yyjson_doc *doc;\n-\n-   // use one allocator for multiple JSON\n-   size_t size = yyjson_read_max_memory_usage(max_len, 0);\n-   void *buf = malloc(size);\n-   yyjson_alc alc;\n-   yyjson_alc_pool_init(&alc, buf, size);\n-\n-   // no more alloc() or realloc() call during reading\n-   doc = yyjson_read_opts(dat1, len1, 0, &alc, NULL);\n-   yyjson_doc_free(doc);\n-   doc = yyjson_read_opts(dat2, len2, 0, &alc, NULL);\n-   yyjson_doc_free(doc);\n-   doc = yyjson_read_opts(dat3, len3, 0, &alc, NULL);\n-   yyjson_doc_free(doc);\n-\n-   free(buf);\n-@endcode\n-@see yyjson_alc_pool_init()\n-*/\n+ Returns the size of maximum memory usage to read a JSON data.\n+ \n+ You may use this value to avoid malloc() or calloc() call inside the reader\n+ to get better performance, or read multiple JSON with one piece of memory.\n+ \n+ @param len The length of JSON data in bytes.\n+ @param flg The JSON read options.\n+ @return The maximum memory size to read this JSON, or 0 if overflow.\n+ \n+ @par Example\n+ @code\n+    // read multiple JSON with same pre-allocated memory\n+    \n+    char *dat1, *dat2, *dat3; // JSON data\n+    size_t len1, len2, len3; // JSON length\n+    size_t max_len = MAX(len1, MAX(len2, len3));\n+    yyjson_doc *doc;\n+    \n+    // use one allocator for multiple JSON\n+    size_t size = yyjson_read_max_memory_usage(max_len, 0);\n+    void *buf = malloc(size);\n+    yyjson_alc alc;\n+    yyjson_alc_pool_init(&alc, buf, size);\n+    \n+    // no more alloc() or realloc() call during reading\n+    doc = yyjson_read_opts(dat1, len1, 0, &alc, NULL);\n+    yyjson_doc_free(doc);\n+    doc = yyjson_read_opts(dat2, len2, 0, &alc, NULL);\n+    yyjson_doc_free(doc);\n+    doc = yyjson_read_opts(dat3, len3, 0, &alc, NULL);\n+    yyjson_doc_free(doc);\n+    \n+    free(buf);\n+ @endcode\n+ @see yyjson_alc_pool_init()\n+ */\n yyjson_api_inline size_t yyjson_read_max_memory_usage(size_t len,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t yyjson_read_flag flg) {\n-   /*\n-\t1. The max value count is (json_size / 2 + 1),\n-\t   for example: \"[1,2,3,4]\" size is 9, value count is 5.\n-\t2. Some broken JSON may cost more memory during reading, but fail at end,\n-\t   for example: \"[[[[[[[[\".\n-\t3. yyjson use 16 bytes per value, see struct yyjson_val.\n-\t4. yyjson use dynamic memory with a growth factor of 1.5.\n-\n-\tThe max memory size is (json_size / 2 * 16 * 1.5 + padding).\n-\t*/\n-   size_t mul = (size_t)12 + !(flg & YYJSON_READ_INSITU);\n-   size_t pad = 256;\n-   size_t max = (size_t)(~(size_t)0);\n-   if (flg & YYJSON_READ_STOP_WHEN_DONE) len = len < 256 ? 256 : len;\n-   if (len >= (max - pad - mul) / mul) return 0;\n-   return len * mul + pad;\n+                                                      yyjson_read_flag flg) {\n+    /*\n+     1. The max value count is (json_size / 2 + 1),\n+        for example: \"[1,2,3,4]\" size is 9, value count is 5.\n+     2. Some broken JSON may cost more memory during reading, but fail at end,\n+        for example: \"[[[[[[[[\".\n+     3. yyjson use 16 bytes per value, see struct yyjson_val.\n+     4. yyjson use dynamic memory with a growth factor of 1.5.\n+     \n+     The max memory size is (json_size / 2 * 16 * 1.5 + padding).\n+     */\n+    size_t mul = (size_t)12 + !(flg & YYJSON_READ_INSITU);\n+    size_t pad = 256;\n+    size_t max = (size_t)(~(size_t)0);\n+    if (flg & YYJSON_READ_STOP_WHEN_DONE) len = len < 256 ? 256 : len;\n+    if (len >= (max - pad - mul) / mul) return 0;\n+    return len * mul + pad;\n }\n \n+/**\n+ Read a JSON number.\n+\n+ This function is thread-safe when data is not modified by other threads.\n+\n+ @param dat The JSON data (UTF-8 without BOM), null-terminator is required.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param val The output value where result is stored.\n+    If this parameter is NULL, the function will fail and return NULL.\n+    The value will hold either UINT or SINT or REAL number;\n+ @param flg The JSON read options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+    Suppors `YYJSON_READ_NUMBER_AS_RAW` and `YYJSON_READ_ALLOW_INF_AND_NAN`.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return If successful, a pointer to the character after the last character\n+    used in the conversion, NULL if an error occurs.\n+ */\n+yyjson_api const char *yyjson_read_number(const char *dat,\n+                                          yyjson_val *val,\n+                                          yyjson_read_flag flg,\n+                                          yyjson_read_err *err);\n+\n+/**\n+ Read a JSON number.\n+\n+ This function is thread-safe when data is not modified by other threads.\n+\n+ @param dat The JSON data (UTF-8 without BOM), null-terminator is required.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param val The output value where result is stored.\n+    If this parameter is NULL, the function will fail and return NULL.\n+    The value will hold either UINT or SINT or REAL number;\n+ @param flg The JSON read options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+    Suppors `YYJSON_READ_NUMBER_AS_RAW` and `YYJSON_READ_ALLOW_INF_AND_NAN`.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return If successful, a pointer to the character after the last character\n+    used in the conversion, NULL if an error occurs.\n+ */\n+yyjson_api_inline const char *yyjson_mut_read_number(const char *dat,\n+                                                     yyjson_mut_val *val,\n+                                                     yyjson_read_flag flg,\n+                                                     yyjson_read_err *err) {\n+    return yyjson_read_number(dat, (yyjson_val *)val, flg, err);\n+}\n \n \n /*==============================================================================\n-* JSON Writer API\n-*============================================================================*/\n+ * JSON Writer API\n+ *============================================================================*/\n \n /** Run-time options for JSON writer. */\n typedef uint32_t yyjson_write_flag;\n \n /** Default option:\n-   - Write JSON minify.\n-   - Report error on inf or nan number.\n-   - Report error on invalid UTF-8 string.\n-   - Do not escape unicode or slash. */\n+    - Write JSON minify.\n+    - Report error on inf or nan number.\n+    - Report error on invalid UTF-8 string.\n+    - Do not escape unicode or slash. */\n static const yyjson_write_flag YYJSON_WRITE_NOFLAG                  = 0 << 0;\n \n /** Write JSON pretty with 4 space indent. */\n@@ -829,15 +879,19 @@ static const yyjson_write_flag YYJSON_WRITE_ESCAPE_SLASHES          = 1 << 2;\n static const yyjson_write_flag YYJSON_WRITE_ALLOW_INF_AND_NAN       = 1 << 3;\n \n /** Write inf and nan number as null literal.\n-   This flag will override `YYJSON_WRITE_ALLOW_INF_AND_NAN` flag. */\n+    This flag will override `YYJSON_WRITE_ALLOW_INF_AND_NAN` flag. */\n static const yyjson_write_flag YYJSON_WRITE_INF_AND_NAN_AS_NULL     = 1 << 4;\n \n /** Allow invalid unicode when encoding string values (non-standard).\n-   Invalid characters in string value will be copied byte by byte.\n-   If `YYJSON_WRITE_ESCAPE_UNICODE` flag is also set, invalid character will be\n-   escaped as `U+FFFD` (replacement character).\n-   This flag does not affect the performance of correctly encoded strings. */\n-static const yyjson_read_flag YYJSON_WRITE_ALLOW_INVALID_UNICODE    = 1 << 5;\n+    Invalid characters in string value will be copied byte by byte.\n+    If `YYJSON_WRITE_ESCAPE_UNICODE` flag is also set, invalid character will be\n+    escaped as `U+FFFD` (replacement character).\n+    This flag does not affect the performance of correctly encoded strings. */\n+static const yyjson_write_flag YYJSON_WRITE_ALLOW_INVALID_UNICODE   = 1 << 5;\n+\n+/** Write JSON pretty with 2 space indent.\n+    This flag will override `YYJSON_WRITE_PRETTY` flag. */\n+static const yyjson_write_flag YYJSON_WRITE_PRETTY_TWO_SPACES       = 1 << 6;\n \n \n \n@@ -870,964 +924,1089 @@ static const yyjson_write_code YYJSON_WRITE_ERROR_INVALID_STRING        = 7;\n \n /** Error information for JSON writer. */\n typedef struct yyjson_write_err {\n-   /** Error code, see `yyjson_write_code` for all possible values. */\n-   yyjson_write_code code;\n-   /** Error message, constant, no need to free (NULL if success). */\n-   const char *msg;\n+    /** Error code, see `yyjson_write_code` for all possible values. */\n+    yyjson_write_code code;\n+    /** Error message, constant, no need to free (NULL if success). */\n+    const char *msg;\n } yyjson_write_err;\n \n \n \n /*==============================================================================\n-* JSON Document Writer API\n-*============================================================================*/\n+ * JSON Document Writer API\n+ *============================================================================*/\n \n /**\n-Write a document to JSON string with options.\n-\n-This function is thread-safe when:\n-The `alc` is thread-safe or NULL.\n-\n-@param doc The JSON document.\n-   If this doc is NULL or has no root, the function will fail and return false.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param alc The memory allocator used by JSON writer.\n-   Pass NULL to use the libc's default allocator.\n-@param len A pointer to receive output length in bytes.\n-   Pass NULL if you don't need length information.\n-@param err A pointer to receive error information.\n-   Pass NULL if you don't need error information.\n-@return A new JSON string, or NULL if an error occurs.\n-   This string is encoded as UTF-8 with a null-terminator.\n-   When it's no longer needed, it should be freed with free() or alc->free().\n-*/\n+ Write a document to JSON string with options.\n+ \n+ This function is thread-safe when:\n+ The `alc` is thread-safe or NULL.\n+ \n+ @param doc The JSON document.\n+    If this doc is NULL or has no root, the function will fail and return false.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param alc The memory allocator used by JSON writer.\n+    Pass NULL to use the libc's default allocator.\n+ @param len A pointer to receive output length in bytes.\n+    Pass NULL if you don't need length information.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return A new JSON string, or NULL if an error occurs.\n+    This string is encoded as UTF-8 with a null-terminator.\n+    When it's no longer needed, it should be freed with free() or alc->free().\n+ */\n yyjson_api char *yyjson_write_opts(const yyjson_doc *doc,\n-\t\t\t\t\t\t\t\t  yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t  const yyjson_alc *alc,\n-\t\t\t\t\t\t\t\t  size_t *len,\n-\t\t\t\t\t\t\t\t  yyjson_write_err *err);\n+                                   yyjson_write_flag flg,\n+                                   const yyjson_alc *alc,\n+                                   size_t *len,\n+                                   yyjson_write_err *err);\n \n /**\n-Write a document to JSON file with options.\n-\n-This function is thread-safe when:\n-1. The file is not accessed by other threads.\n-2. The `alc` is thread-safe or NULL.\n-\n-@param path The JSON file's path.\n-   If this path is NULL or invalid, the function will fail and return false.\n-   If this file is not empty, the content will be discarded.\n-@param doc The JSON document.\n-   If this doc is NULL or has no root, the function will fail and return false.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param alc The memory allocator used by JSON writer.\n-   Pass NULL to use the libc's default allocator.\n-@param err A pointer to receive error information.\n-   Pass NULL if you don't need error information.\n-@return true if successful, false if an error occurs.\n-\n-@warning On 32-bit operating system, files larger than 2GB may fail to write.\n-*/\n+ Write a document to JSON file with options.\n+ \n+ This function is thread-safe when:\n+ 1. The file is not accessed by other threads.\n+ 2. The `alc` is thread-safe or NULL.\n+\n+ @param path The JSON file's path.\n+    If this path is NULL or invalid, the function will fail and return false.\n+    If this file is not empty, the content will be discarded.\n+ @param doc The JSON document.\n+    If this doc is NULL or has no root, the function will fail and return false.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param alc The memory allocator used by JSON writer.\n+    Pass NULL to use the libc's default allocator.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return true if successful, false if an error occurs.\n+ \n+ @warning On 32-bit operating system, files larger than 2GB may fail to write.\n+ */\n yyjson_api bool yyjson_write_file(const char *path,\n-\t\t\t\t\t\t\t\t const yyjson_doc *doc,\n-\t\t\t\t\t\t\t\t yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t const yyjson_alc *alc,\n-\t\t\t\t\t\t\t\t yyjson_write_err *err);\n+                                  const yyjson_doc *doc,\n+                                  yyjson_write_flag flg,\n+                                  const yyjson_alc *alc,\n+                                  yyjson_write_err *err);\n \n /**\n-Write a document to JSON string.\n-\n-This function is thread-safe.\n-\n-@param doc The JSON document.\n-   If this doc is NULL or has no root, the function will fail and return false.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param len A pointer to receive output length in bytes.\n-   Pass NULL if you don't need length information.\n-@return A new JSON string, or NULL if an error occurs.\n-   This string is encoded as UTF-8 with a null-terminator.\n-   When it's no longer needed, it should be freed with free().\n-*/\n+ Write a document to JSON string.\n+ \n+ This function is thread-safe.\n+ \n+ @param doc The JSON document.\n+    If this doc is NULL or has no root, the function will fail and return false.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param len A pointer to receive output length in bytes.\n+    Pass NULL if you don't need length information.\n+ @return A new JSON string, or NULL if an error occurs.\n+    This string is encoded as UTF-8 with a null-terminator.\n+    When it's no longer needed, it should be freed with free().\n+ */\n yyjson_api_inline char *yyjson_write(const yyjson_doc *doc,\n-\t\t\t\t\t\t\t\t\tyyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\tsize_t *len) {\n-   return yyjson_write_opts(doc, flg, NULL, len, NULL);\n+                                     yyjson_write_flag flg,\n+                                     size_t *len) {\n+    return yyjson_write_opts(doc, flg, NULL, len, NULL);\n }\n \n \n \n /**\n-Write a document to JSON string with options.\n-\n-This function is thread-safe when:\n-1. The `doc` is not modified by other threads.\n-2. The `alc` is thread-safe or NULL.\n-\n-@param doc The mutable JSON document.\n-   If this doc is NULL or has no root, the function will fail and return false.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param alc The memory allocator used by JSON writer.\n-   Pass NULL to use the libc's default allocator.\n-@param len A pointer to receive output length in bytes.\n-   Pass NULL if you don't need length information.\n-@param err A pointer to receive error information.\n-   Pass NULL if you don't need error information.\n-@return A new JSON string, or NULL if an error occurs.\n-   This string is encoded as UTF-8 with a null-terminator.\n-   When it's no longer needed, it should be freed with free() or alc->free().\n-*/\n+ Write a document to JSON string with options.\n+ \n+ This function is thread-safe when:\n+ 1. The `doc` is not modified by other threads.\n+ 2. The `alc` is thread-safe or NULL.\n+\n+ @param doc The mutable JSON document.\n+    If this doc is NULL or has no root, the function will fail and return false.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param alc The memory allocator used by JSON writer.\n+    Pass NULL to use the libc's default allocator.\n+ @param len A pointer to receive output length in bytes.\n+    Pass NULL if you don't need length information.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return A new JSON string, or NULL if an error occurs.\n+    This string is encoded as UTF-8 with a null-terminator.\n+    When it's no longer needed, it should be freed with free() or alc->free().\n+ */\n yyjson_api char *yyjson_mut_write_opts(const yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t  yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t  const yyjson_alc *alc,\n-\t\t\t\t\t\t\t\t\t  size_t *len,\n-\t\t\t\t\t\t\t\t\t  yyjson_write_err *err);\n+                                       yyjson_write_flag flg,\n+                                       const yyjson_alc *alc,\n+                                       size_t *len,\n+                                       yyjson_write_err *err);\n \n /**\n-Write a document to JSON file with options.\n-\n-This function is thread-safe when:\n-1. The file is not accessed by other threads.\n-2. The `doc` is not modified by other threads.\n-3. The `alc` is thread-safe or NULL.\n-\n-@param path The JSON file's path.\n-   If this path is NULL or invalid, the function will fail and return false.\n-   If this file is not empty, the content will be discarded.\n-@param doc The mutable JSON document.\n-   If this doc is NULL or has no root, the function will fail and return false.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param alc The memory allocator used by JSON writer.\n-   Pass NULL to use the libc's default allocator.\n-@param err A pointer to receive error information.\n-   Pass NULL if you don't need error information.\n-@return true if successful, false if an error occurs.\n-\n-@warning On 32-bit operating system, files larger than 2GB may fail to write.\n-*/\n+ Write a document to JSON file with options.\n+ \n+ This function is thread-safe when:\n+ 1. The file is not accessed by other threads.\n+ 2. The `doc` is not modified by other threads.\n+ 3. The `alc` is thread-safe or NULL.\n+ \n+ @param path The JSON file's path.\n+    If this path is NULL or invalid, the function will fail and return false.\n+    If this file is not empty, the content will be discarded.\n+ @param doc The mutable JSON document.\n+    If this doc is NULL or has no root, the function will fail and return false.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param alc The memory allocator used by JSON writer.\n+    Pass NULL to use the libc's default allocator.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return true if successful, false if an error occurs.\n+ \n+ @warning On 32-bit operating system, files larger than 2GB may fail to write.\n+ */\n yyjson_api bool yyjson_mut_write_file(const char *path,\n-\t\t\t\t\t\t\t\t\t const yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t const yyjson_alc *alc,\n-\t\t\t\t\t\t\t\t\t yyjson_write_err *err);\n+                                      const yyjson_mut_doc *doc,\n+                                      yyjson_write_flag flg,\n+                                      const yyjson_alc *alc,\n+                                      yyjson_write_err *err);\n \n /**\n-Write a document to JSON string.\n-\n-This function is thread-safe when:\n-The `doc` is not is not modified by other threads.\n-\n-@param doc The JSON document.\n-   If this doc is NULL or has no root, the function will fail and return false.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param len A pointer to receive output length in bytes.\n-   Pass NULL if you don't need length information.\n-@return A new JSON string, or NULL if an error occurs.\n-   This string is encoded as UTF-8 with a null-terminator.\n-   When it's no longer needed, it should be freed with free().\n-*/\n+ Write a document to JSON string.\n+ \n+ This function is thread-safe when:\n+ The `doc` is not modified by other threads.\n+ \n+ @param doc The JSON document.\n+    If this doc is NULL or has no root, the function will fail and return false.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param len A pointer to receive output length in bytes.\n+    Pass NULL if you don't need length information.\n+ @return A new JSON string, or NULL if an error occurs.\n+    This string is encoded as UTF-8 with a null-terminator.\n+    When it's no longer needed, it should be freed with free().\n+ */\n yyjson_api_inline char *yyjson_mut_write(const yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\tyyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t\tsize_t *len) {\n-   return yyjson_mut_write_opts(doc, flg, NULL, len, NULL);\n+                                         yyjson_write_flag flg,\n+                                         size_t *len) {\n+    return yyjson_mut_write_opts(doc, flg, NULL, len, NULL);\n }\n \n \n \n /*==============================================================================\n-* JSON Value Writer API\n-*============================================================================*/\n+ * JSON Value Writer API\n+ *============================================================================*/\n \n /**\n-Write a value to JSON string with options.\n-\n-This function is thread-safe when:\n-The `alc` is thread-safe or NULL.\n-\n-@param val The JSON root value.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param alc The memory allocator used by JSON writer.\n-   Pass NULL to use the libc's default allocator.\n-@param len A pointer to receive output length in bytes.\n-   Pass NULL if you don't need length information.\n-@param err A pointer to receive error information.\n-   Pass NULL if you don't need error information.\n-@return A new JSON string, or NULL if an error occurs.\n-   This string is encoded as UTF-8 with a null-terminator.\n-   When it's no longer needed, it should be freed with free() or alc->free().\n-*/\n+ Write a value to JSON string with options.\n+ \n+ This function is thread-safe when:\n+ The `alc` is thread-safe or NULL.\n+ \n+ @param val The JSON root value.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param alc The memory allocator used by JSON writer.\n+    Pass NULL to use the libc's default allocator.\n+ @param len A pointer to receive output length in bytes.\n+    Pass NULL if you don't need length information.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return A new JSON string, or NULL if an error occurs.\n+    This string is encoded as UTF-8 with a null-terminator.\n+    When it's no longer needed, it should be freed with free() or alc->free().\n+ */\n yyjson_api char *yyjson_val_write_opts(const yyjson_val *val,\n-\t\t\t\t\t\t\t\t\t  yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t  const yyjson_alc *alc,\n-\t\t\t\t\t\t\t\t\t  size_t *len,\n-\t\t\t\t\t\t\t\t\t  yyjson_write_err *err);\n+                                       yyjson_write_flag flg,\n+                                       const yyjson_alc *alc,\n+                                       size_t *len,\n+                                       yyjson_write_err *err);\n \n /**\n-Write a value to JSON file with options.\n-\n-This function is thread-safe when:\n-1. The file is not accessed by other threads.\n-2. The `alc` is thread-safe or NULL.\n-\n-@param path The JSON file's path.\n-   If this path is NULL or invalid, the function will fail and return false.\n-   If this file is not empty, the content will be discarded.\n-@param val The JSON root value.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param alc The memory allocator used by JSON writer.\n-   Pass NULL to use the libc's default allocator.\n-@param err A pointer to receive error information.\n-   Pass NULL if you don't need error information.\n-@return true if successful, false if an error occurs.\n-\n-@warning On 32-bit operating system, files larger than 2GB may fail to write.\n-*/\n+ Write a value to JSON file with options.\n+ \n+ This function is thread-safe when:\n+ 1. The file is not accessed by other threads.\n+ 2. The `alc` is thread-safe or NULL.\n+ \n+ @param path The JSON file's path.\n+    If this path is NULL or invalid, the function will fail and return false.\n+    If this file is not empty, the content will be discarded.\n+ @param val The JSON root value.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param alc The memory allocator used by JSON writer.\n+    Pass NULL to use the libc's default allocator.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return true if successful, false if an error occurs.\n+ \n+ @warning On 32-bit operating system, files larger than 2GB may fail to write.\n+ */\n yyjson_api bool yyjson_val_write_file(const char *path,\n-\t\t\t\t\t\t\t\t\t const yyjson_val *val,\n-\t\t\t\t\t\t\t\t\t yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t const yyjson_alc *alc,\n-\t\t\t\t\t\t\t\t\t yyjson_write_err *err);\n+                                      const yyjson_val *val,\n+                                      yyjson_write_flag flg,\n+                                      const yyjson_alc *alc,\n+                                      yyjson_write_err *err);\n \n /**\n-Write a value to JSON string.\n-\n-This function is thread-safe.\n-\n-@param val The JSON root value.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param len A pointer to receive output length in bytes.\n-   Pass NULL if you don't need length information.\n-@return A new JSON string, or NULL if an error occurs.\n-   This string is encoded as UTF-8 with a null-terminator.\n-   When it's no longer needed, it should be freed with free().\n-*/\n+ Write a value to JSON string.\n+ \n+ This function is thread-safe.\n+ \n+ @param val The JSON root value.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param len A pointer to receive output length in bytes.\n+    Pass NULL if you don't need length information.\n+ @return A new JSON string, or NULL if an error occurs.\n+    This string is encoded as UTF-8 with a null-terminator.\n+    When it's no longer needed, it should be freed with free().\n+ */\n yyjson_api_inline char *yyjson_val_write(const yyjson_val *val,\n-\t\t\t\t\t\t\t\t\t\tyyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t\tsize_t *len) {\n-   return yyjson_val_write_opts(val, flg, NULL, len, NULL);\n+                                         yyjson_write_flag flg,\n+                                         size_t *len) {\n+    return yyjson_val_write_opts(val, flg, NULL, len, NULL);\n }\n \n /**\n-Write a value to JSON string with options.\n-\n-This function is thread-safe when:\n-1. The `val` is not modified by other threads.\n-2. The `alc` is thread-safe or NULL.\n-\n-@param val The mutable JSON root value.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param alc The memory allocator used by JSON writer.\n-   Pass NULL to use the libc's default allocator.\n-@param len A pointer to receive output length in bytes.\n-   Pass NULL if you don't need length information.\n-@param err A pointer to receive error information.\n-   Pass NULL if you don't need error information.\n-@return  A new JSON string, or NULL if an error occurs.\n-   This string is encoded as UTF-8 with a null-terminator.\n-   When it's no longer needed, it should be freed with free() or alc->free().\n-*/\n+ Write a value to JSON string with options.\n+ \n+ This function is thread-safe when:\n+ 1. The `val` is not modified by other threads.\n+ 2. The `alc` is thread-safe or NULL.\n+ \n+ @param val The mutable JSON root value.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param alc The memory allocator used by JSON writer.\n+    Pass NULL to use the libc's default allocator.\n+ @param len A pointer to receive output length in bytes.\n+    Pass NULL if you don't need length information.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return  A new JSON string, or NULL if an error occurs.\n+    This string is encoded as UTF-8 with a null-terminator.\n+    When it's no longer needed, it should be freed with free() or alc->free().\n+ */\n yyjson_api char *yyjson_mut_val_write_opts(const yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t  yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t\t  const yyjson_alc *alc,\n-\t\t\t\t\t\t\t\t\t\t  size_t *len,\n-\t\t\t\t\t\t\t\t\t\t  yyjson_write_err *err);\n+                                           yyjson_write_flag flg,\n+                                           const yyjson_alc *alc,\n+                                           size_t *len,\n+                                           yyjson_write_err *err);\n \n /**\n-Write a value to JSON file with options.\n-\n-This function is thread-safe when:\n-1. The file is not accessed by other threads.\n-2. The `val` is not modified by other threads.\n-3. The `alc` is thread-safe or NULL.\n-\n-@param path The JSON file's path.\n-   If this path is NULL or invalid, the function will fail and return false.\n-   If this file is not empty, the content will be discarded.\n-@param val The mutable JSON root value.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param alc The memory allocator used by JSON writer.\n-   Pass NULL to use the libc's default allocator.\n-@param err A pointer to receive error information.\n-   Pass NULL if you don't need error information.\n-@return true if successful, false if an error occurs.\n-\n-@warning On 32-bit operating system, files larger than 2GB may fail to write.\n-*/\n+ Write a value to JSON file with options.\n+ \n+ This function is thread-safe when:\n+ 1. The file is not accessed by other threads.\n+ 2. The `val` is not modified by other threads.\n+ 3. The `alc` is thread-safe or NULL.\n+ \n+ @param path The JSON file's path.\n+    If this path is NULL or invalid, the function will fail and return false.\n+    If this file is not empty, the content will be discarded.\n+ @param val The mutable JSON root value.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param alc The memory allocator used by JSON writer.\n+    Pass NULL to use the libc's default allocator.\n+ @param err A pointer to receive error information.\n+    Pass NULL if you don't need error information.\n+ @return true if successful, false if an error occurs.\n+ \n+ @warning On 32-bit operating system, files larger than 2GB may fail to write.\n+ */\n yyjson_api bool yyjson_mut_val_write_file(const char *path,\n-\t\t\t\t\t\t\t\t\t\t const yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t\t const yyjson_alc *alc,\n-\t\t\t\t\t\t\t\t\t\t yyjson_write_err *err);\n+                                          const yyjson_mut_val *val,\n+                                          yyjson_write_flag flg,\n+                                          const yyjson_alc *alc,\n+                                          yyjson_write_err *err);\n \n /**\n-Write a value to JSON string.\n-\n-This function is thread-safe when:\n-The `val` is not is not modified by other threads.\n-\n-@param val The JSON root value.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param flg The JSON write options.\n-   Multiple options can be combined with `|` operator. 0 means no options.\n-@param len A pointer to receive output length in bytes.\n-   Pass NULL if you don't need length information.\n-@return A new JSON string, or NULL if an error occurs.\n-   This string is encoded as UTF-8 with a null-terminator.\n-   When it's no longer needed, it should be freed with free().\n-*/\n+ Write a value to JSON string.\n+ \n+ This function is thread-safe when:\n+ The `val` is not modified by other threads.\n+ \n+ @param val The JSON root value.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param flg The JSON write options.\n+    Multiple options can be combined with `|` operator. 0 means no options.\n+ @param len A pointer to receive output length in bytes.\n+    Pass NULL if you don't need length information.\n+ @return A new JSON string, or NULL if an error occurs.\n+    This string is encoded as UTF-8 with a null-terminator.\n+    When it's no longer needed, it should be freed with free().\n+ */\n yyjson_api_inline char *yyjson_mut_val_write(const yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t\t\tsize_t *len) {\n-   return yyjson_mut_val_write_opts(val, flg, NULL, len, NULL);\n+                                             yyjson_write_flag flg,\n+                                             size_t *len) {\n+    return yyjson_mut_val_write_opts(val, flg, NULL, len, NULL);\n }\n \n \n \n /*==============================================================================\n-* JSON Document API\n-*============================================================================*/\n+ * JSON Document API\n+ *============================================================================*/\n \n /** Returns the root value of this JSON document.\n-   Returns NULL if `doc` is NULL. */\n+    Returns NULL if `doc` is NULL. */\n yyjson_api_inline yyjson_val *yyjson_doc_get_root(yyjson_doc *doc);\n \n /** Returns read size of input JSON data.\n-   Returns 0 if `doc` is NULL.\n-   For example: the read size of \"[1,2,3]\" is 7 bytes.  */\n+    Returns 0 if `doc` is NULL.\n+    For example: the read size of `[1,2,3]` is 7 bytes.  */\n yyjson_api_inline size_t yyjson_doc_get_read_size(yyjson_doc *doc);\n \n /** Returns total value count in this JSON document.\n-   Returns 0 if `doc` is NULL.\n-   For example: the value count of \"[1,2,3]\" is 4. */\n+    Returns 0 if `doc` is NULL.\n+    For example: the value count of `[1,2,3]` is 4. */\n yyjson_api_inline size_t yyjson_doc_get_val_count(yyjson_doc *doc);\n \n /** Release the JSON document and free the memory.\n-   After calling this function, the `doc` and all values from the `doc` are no\n-   longer available. This function will do nothing if the `doc` is NULL. */\n+    After calling this function, the `doc` and all values from the `doc` are no\n+    longer available. This function will do nothing if the `doc` is NULL. */\n yyjson_api_inline void yyjson_doc_free(yyjson_doc *doc);\n \n \n \n /*==============================================================================\n-* JSON Value Type API\n-*============================================================================*/\n+ * JSON Value Type API\n+ *============================================================================*/\n \n /** Returns whether the JSON value is raw.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_raw(yyjson_val *val);\n \n /** Returns whether the JSON value is `null`.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_null(yyjson_val *val);\n \n /** Returns whether the JSON value is `true`.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_true(yyjson_val *val);\n \n /** Returns whether the JSON value is `false`.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_false(yyjson_val *val);\n \n /** Returns whether the JSON value is bool (true/false).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_bool(yyjson_val *val);\n \n /** Returns whether the JSON value is unsigned integer (uint64_t).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_uint(yyjson_val *val);\n \n /** Returns whether the JSON value is signed integer (int64_t).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_sint(yyjson_val *val);\n \n /** Returns whether the JSON value is integer (uint64_t/int64_t).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_int(yyjson_val *val);\n \n /** Returns whether the JSON value is real number (double).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_real(yyjson_val *val);\n \n /** Returns whether the JSON value is number (uint64_t/int64_t/double).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_num(yyjson_val *val);\n \n /** Returns whether the JSON value is string.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_str(yyjson_val *val);\n \n /** Returns whether the JSON value is array.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_arr(yyjson_val *val);\n \n /** Returns whether the JSON value is object.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_obj(yyjson_val *val);\n \n /** Returns whether the JSON value is container (array/object).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_is_ctn(yyjson_val *val);\n \n \n \n /*==============================================================================\n-* JSON Value Content API\n-*============================================================================*/\n+ * JSON Value Content API\n+ *============================================================================*/\n \n /** Returns the JSON value's type.\n-   Returns YYJSON_TYPE_NONE if `val` is NULL. */\n+    Returns YYJSON_TYPE_NONE if `val` is NULL. */\n yyjson_api_inline yyjson_type yyjson_get_type(yyjson_val *val);\n \n /** Returns the JSON value's subtype.\n-   Returns YYJSON_SUBTYPE_NONE if `val` is NULL. */\n+    Returns YYJSON_SUBTYPE_NONE if `val` is NULL. */\n yyjson_api_inline yyjson_subtype yyjson_get_subtype(yyjson_val *val);\n \n /** Returns the JSON value's tag.\n-   Returns 0 if `val` is NULL. */\n+    Returns 0 if `val` is NULL. */\n yyjson_api_inline uint8_t yyjson_get_tag(yyjson_val *val);\n \n /** Returns the JSON value's type description.\n-   The return value should be one of these strings: \"raw\", \"null\", \"string\",\n-   \"array\", \"object\", \"true\", \"false\", \"uint\", \"sint\", \"real\", \"unknown\". */\n+    The return value should be one of these strings: \"raw\", \"null\", \"string\",\n+    \"array\", \"object\", \"true\", \"false\", \"uint\", \"sint\", \"real\", \"unknown\". */\n yyjson_api_inline const char *yyjson_get_type_desc(yyjson_val *val);\n \n /** Returns the content if the value is raw.\n-   Returns NULL if `val` is NULL or type is not raw. */\n+    Returns NULL if `val` is NULL or type is not raw. */\n yyjson_api_inline const char *yyjson_get_raw(yyjson_val *val);\n \n /** Returns the content if the value is bool.\n-   Returns NULL if `val` is NULL or type is not bool. */\n+    Returns NULL if `val` is NULL or type is not bool. */\n yyjson_api_inline bool yyjson_get_bool(yyjson_val *val);\n \n /** Returns the content and cast to uint64_t.\n-   Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n+    Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n yyjson_api_inline uint64_t yyjson_get_uint(yyjson_val *val);\n \n /** Returns the content and cast to int64_t.\n-   Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n+    Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n yyjson_api_inline int64_t yyjson_get_sint(yyjson_val *val);\n \n /** Returns the content and cast to int.\n-   Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n+    Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n yyjson_api_inline int yyjson_get_int(yyjson_val *val);\n \n /** Returns the content if the value is real number, or 0.0 on error.\n-   Returns 0.0 if `val` is NULL or type is not real(double). */\n+    Returns 0.0 if `val` is NULL or type is not real(double). */\n yyjson_api_inline double yyjson_get_real(yyjson_val *val);\n \n /** Returns the content if the value is string.\n-   Returns NULL if `val` is NULL or type is not string. */\n+    Returns NULL if `val` is NULL or type is not string. */\n yyjson_api_inline const char *yyjson_get_str(yyjson_val *val);\n \n /** Returns the content length (string length, array size, object size.\n-   Returns 0 if `val` is NULL or type is not string/array/object. */\n+    Returns 0 if `val` is NULL or type is not string/array/object. */\n yyjson_api_inline size_t yyjson_get_len(yyjson_val *val);\n \n /** Returns whether the JSON value is equals to a string.\n-   Returns false if input is NULL or type is not string. */\n+    Returns false if input is NULL or type is not string. */\n yyjson_api_inline bool yyjson_equals_str(yyjson_val *val, const char *str);\n \n /** Returns whether the JSON value is equals to a string.\n-   The `str` should be a UTF-8 string, null-terminator is not required.\n-   Returns false if input is NULL or type is not string. */\n+    The `str` should be a UTF-8 string, null-terminator is not required.\n+    Returns false if input is NULL or type is not string. */\n yyjson_api_inline bool yyjson_equals_strn(yyjson_val *val, const char *str,\n-\t\t\t\t\t\t\t\t\t\t size_t len);\n+                                          size_t len);\n \n /** Returns whether two JSON values are equal (deep compare).\n-   Returns false if input is NULL. */\n+    Returns false if input is NULL. */\n yyjson_api_inline bool yyjson_equals(yyjson_val *lhs, yyjson_val *rhs);\n \n+/** Set the value to raw.\n+    Returns false if input is NULL or `val` is object or array.\n+    @warning This will modify the `immutable` value, use with caution. */\n+yyjson_api_inline bool yyjson_set_raw(yyjson_val *val,\n+                                      const char *raw, size_t len);\n+\n+/** Set the value to null.\n+    Returns false if input is NULL or `val` is object or array.\n+    @warning This will modify the `immutable` value, use with caution. */\n+yyjson_api_inline bool yyjson_set_null(yyjson_val *val);\n+\n+/** Set the value to bool.\n+    Returns false if input is NULL or `val` is object or array.\n+    @warning This will modify the `immutable` value, use with caution. */\n+yyjson_api_inline bool yyjson_set_bool(yyjson_val *val, bool num);\n+\n+/** Set the value to uint.\n+    Returns false if input is NULL or `val` is object or array.\n+    @warning This will modify the `immutable` value, use with caution. */\n+yyjson_api_inline bool yyjson_set_uint(yyjson_val *val, uint64_t num);\n+\n+/** Set the value to sint.\n+    Returns false if input is NULL or `val` is object or array.\n+    @warning This will modify the `immutable` value, use with caution. */\n+yyjson_api_inline bool yyjson_set_sint(yyjson_val *val, int64_t num);\n+\n+/** Set the value to int.\n+    Returns false if input is NULL or `val` is object or array.\n+    @warning This will modify the `immutable` value, use with caution. */\n+yyjson_api_inline bool yyjson_set_int(yyjson_val *val, int num);\n+\n+/** Set the value to real.\n+    Returns false if input is NULL or `val` is object or array.\n+    @warning This will modify the `immutable` value, use with caution. */\n+yyjson_api_inline bool yyjson_set_real(yyjson_val *val, double num);\n+\n+/** Set the value to string (null-terminated).\n+    Returns false if input is NULL or `val` is object or array.\n+    @warning This will modify the `immutable` value, use with caution. */\n+yyjson_api_inline bool yyjson_set_str(yyjson_val *val, const char *str);\n+\n+/** Set the value to string (with length).\n+    Returns false if input is NULL or `val` is object or array.\n+    @warning This will modify the `immutable` value, use with caution. */\n+yyjson_api_inline bool yyjson_set_strn(yyjson_val *val,\n+                                       const char *str, size_t len);\n+\n \n \n /*==============================================================================\n-* JSON Array API\n-*============================================================================*/\n+ * JSON Array API\n+ *============================================================================*/\n \n /** Returns the number of elements in this array.\n-   Returns 0 if `arr` is NULL or type is not array. */\n+    Returns 0 if `arr` is NULL or type is not array. */\n yyjson_api_inline size_t yyjson_arr_size(yyjson_val *arr);\n \n /** Returns the element at the specified position in this array.\n-   Returns NULL if array is NULL/empty or the index is out of bounds.\n-   @warning This function takes a linear search time if array is not flat.\n-\t   For example: [1,{},3] is flat, [1,[2],3] is not flat. */\n+    Returns NULL if array is NULL/empty or the index is out of bounds.\n+    @warning This function takes a linear search time if array is not flat.\n+        For example: `[1,{},3]` is flat, `[1,[2],3]` is not flat. */\n yyjson_api_inline yyjson_val *yyjson_arr_get(yyjson_val *arr, size_t idx);\n \n /** Returns the first element of this array.\n-   Returns NULL if `arr` is NULL/empty or type is not array. */\n+    Returns NULL if `arr` is NULL/empty or type is not array. */\n yyjson_api_inline yyjson_val *yyjson_arr_get_first(yyjson_val *arr);\n \n /** Returns the last element of this array.\n-   Returns NULL if `arr` is NULL/empty or type is not array.\n-   @warning This function takes a linear search time if array is not flat.\n-\t   For example: [1,{},3] is flat, [1,[2],3] is not flat.*/\n+    Returns NULL if `arr` is NULL/empty or type is not array.\n+    @warning This function takes a linear search time if array is not flat.\n+        For example: `[1,{},3]` is flat, `[1,[2],3]` is not flat.*/\n yyjson_api_inline yyjson_val *yyjson_arr_get_last(yyjson_val *arr);\n \n \n \n /*==============================================================================\n-* JSON Array Iterator API\n-*============================================================================*/\n+ * JSON Array Iterator API\n+ *============================================================================*/\n \n /**\n-A JSON array iterator.\n-\n-@par Example\n-@code\n-   yyjson_val *val;\n-   yyjson_arr_iter iter;\n-   yyjson_arr_iter_init(arr, &iter);\n-   while ((val = yyjson_arr_iter_next(&iter))) {\n-\t   your_func(val);\n-   }\n-@endcode\n-*/\n+ A JSON array iterator.\n+ \n+ @par Example\n+ @code\n+    yyjson_val *val;\n+    yyjson_arr_iter iter;\n+    yyjson_arr_iter_init(arr, &iter);\n+    while ((val = yyjson_arr_iter_next(&iter))) {\n+        your_func(val);\n+    }\n+ @endcode\n+ */\n typedef struct yyjson_arr_iter yyjson_arr_iter;\n \n /**\n-Initialize an iterator for this array.\n-\n-@param arr The array to be iterated over.\n-   If this parameter is NULL or not an array, `iter` will be set to empty.\n-@param iter The iterator to be initialized.\n-   If this parameter is NULL, the function will fail and return false.\n-@return true if the `iter` has been successfully initialized.\n-\n-@note The iterator does not need to be destroyed.\n-*/\n+ Initialize an iterator for this array.\n+ \n+ @param arr The array to be iterated over.\n+    If this parameter is NULL or not an array, `iter` will be set to empty.\n+ @param iter The iterator to be initialized.\n+    If this parameter is NULL, the function will fail and return false.\n+ @return true if the `iter` has been successfully initialized.\n+ \n+ @note The iterator does not need to be destroyed.\n+ */\n yyjson_api_inline bool yyjson_arr_iter_init(yyjson_val *arr,\n-\t\t\t\t\t\t\t\t\t\t   yyjson_arr_iter *iter);\n+                                            yyjson_arr_iter *iter);\n \n /**\n-Returns whether the iteration has more elements.\n-If `iter` is NULL, this function will return false.\n-*/\n+ Returns whether the iteration has more elements.\n+ If `iter` is NULL, this function will return false.\n+ */\n yyjson_api_inline bool yyjson_arr_iter_has_next(yyjson_arr_iter *iter);\n \n /**\n-Returns the next element in the iteration, or NULL on end.\n-If `iter` is NULL, this function will return NULL.\n-*/\n+ Returns the next element in the iteration, or NULL on end.\n+ If `iter` is NULL, this function will return NULL.\n+ */\n yyjson_api_inline yyjson_val *yyjson_arr_iter_next(yyjson_arr_iter *iter);\n \n /**\n-Macro for iterating over an array.\n-It works like iterator, but with a more intuitive API.\n-\n-@par Example\n-@code\n-   size_t idx, max;\n-   yyjson_val *val;\n-   yyjson_arr_foreach(arr, idx, max, val) {\n-\t   your_func(idx, val);\n-   }\n-@endcode\n-*/\n+ Macro for iterating over an array.\n+ It works like iterator, but with a more intuitive API.\n+ \n+ @par Example\n+ @code\n+    size_t idx, max;\n+    yyjson_val *val;\n+    yyjson_arr_foreach(arr, idx, max, val) {\n+        your_func(idx, val);\n+    }\n+ @endcode\n+ */\n #define yyjson_arr_foreach(arr, idx, max, val) \\\n-   for ((idx) = 0, \\\n-\t   (max) = yyjson_arr_size(arr), \\\n-\t   (val) = yyjson_arr_get_first(arr); \\\n-\t   (idx) < (max); \\\n-\t   (idx)++, \\\n-\t   (val) = unsafe_yyjson_get_next(val))\n+    for ((idx) = 0, \\\n+        (max) = yyjson_arr_size(arr), \\\n+        (val) = yyjson_arr_get_first(arr); \\\n+        (idx) < (max); \\\n+        (idx)++, \\\n+        (val) = unsafe_yyjson_get_next(val))\n \n \n \n /*==============================================================================\n-* JSON Object API\n-*============================================================================*/\n+ * JSON Object API\n+ *============================================================================*/\n \n /** Returns the number of key-value pairs in this object.\n-   Returns 0 if `obj` is NULL or type is not object. */\n+    Returns 0 if `obj` is NULL or type is not object. */\n yyjson_api_inline size_t yyjson_obj_size(yyjson_val *obj);\n \n /** Returns the value to which the specified key is mapped.\n-   Returns NULL if this object contains no mapping for the key.\n-   Returns NULL if `obj/key` is NULL, or type is not object.\n-\n-   The `key` should be a null-terminated UTF-8 string.\n-\n-   @warning This function takes a linear search time. */\n+    Returns NULL if this object contains no mapping for the key.\n+    Returns NULL if `obj/key` is NULL, or type is not object.\n+    \n+    The `key` should be a null-terminated UTF-8 string.\n+    \n+    @warning This function takes a linear search time. */\n yyjson_api_inline yyjson_val *yyjson_obj_get(yyjson_val *obj, const char *key);\n \n /** Returns the value to which the specified key is mapped.\n-   Returns NULL if this object contains no mapping for the key.\n-   Returns NULL if `obj/key` is NULL, or type is not object.\n-\n-   The `key` should be a UTF-8 string, null-terminator is not required.\n-   The `key_len` should be the length of the key, in bytes.\n-\n-   @warning This function takes a linear search time. */\n+    Returns NULL if this object contains no mapping for the key.\n+    Returns NULL if `obj/key` is NULL, or type is not object.\n+    \n+    The `key` should be a UTF-8 string, null-terminator is not required.\n+    The `key_len` should be the length of the key, in bytes.\n+    \n+    @warning This function takes a linear search time. */\n yyjson_api_inline yyjson_val *yyjson_obj_getn(yyjson_val *obj, const char *key,\n-\t\t\t\t\t\t\t\t\t\t\t size_t key_len);\n+                                              size_t key_len);\n \n \n \n /*==============================================================================\n-* JSON Object Iterator API\n-*============================================================================*/\n+ * JSON Object Iterator API\n+ *============================================================================*/\n \n /**\n-A JSON object iterator.\n-\n-@par Example\n-@code\n-   yyjson_val *key, *val;\n-   yyjson_obj_iter iter;\n-   yyjson_obj_iter_init(obj, &iter);\n-   while ((key = yyjson_obj_iter_next(&iter))) {\n-\t   val = yyjson_obj_iter_get_val(key);\n-\t   your_func(key, val);\n-   }\n-@endcode\n-\n-If the ordering of the keys is known at compile-time, you can use this method\n-to speed up value lookups:\n-@code\n-   // {\"k1\":1, \"k2\": 3, \"k3\": 3}\n-   yyjson_val *key, *val;\n-   yyjson_obj_iter iter;\n-   yyjson_obj_iter_init(obj, &iter);\n-   yyjson_val *v1 = yyjson_obj_iter_get(&iter, \"k1\");\n-   yyjson_val *v3 = yyjson_obj_iter_get(&iter, \"k3\");\n-@endcode\n-@see yyjson_obj_iter_get() and yyjson_obj_iter_getn()\n-*/\n+ A JSON object iterator.\n+ \n+ @par Example\n+ @code\n+    yyjson_val *key, *val;\n+    yyjson_obj_iter iter;\n+    yyjson_obj_iter_init(obj, &iter);\n+    while ((key = yyjson_obj_iter_next(&iter))) {\n+        val = yyjson_obj_iter_get_val(key);\n+        your_func(key, val);\n+    }\n+ @endcode\n+ \n+ If the ordering of the keys is known at compile-time, you can use this method\n+ to speed up value lookups:\n+ @code\n+    // {\"k1\":1, \"k2\": 3, \"k3\": 3}\n+    yyjson_val *key, *val;\n+    yyjson_obj_iter iter;\n+    yyjson_obj_iter_init(obj, &iter);\n+    yyjson_val *v1 = yyjson_obj_iter_get(&iter, \"k1\");\n+    yyjson_val *v3 = yyjson_obj_iter_get(&iter, \"k3\");\n+ @endcode\n+ @see yyjson_obj_iter_get() and yyjson_obj_iter_getn()\n+ */\n typedef struct yyjson_obj_iter yyjson_obj_iter;\n \n /**\n-Initialize an iterator for this object.\n-\n-@param obj The object to be iterated over.\n-   If this parameter is NULL or not an object, `iter` will be set to empty.\n-@param iter The iterator to be initialized.\n-   If this parameter is NULL, the function will fail and return false.\n-@return true if the `iter` has been successfully initialized.\n-\n-@note The iterator does not need to be destroyed.\n-*/\n+ Initialize an iterator for this object.\n+ \n+ @param obj The object to be iterated over.\n+    If this parameter is NULL or not an object, `iter` will be set to empty.\n+ @param iter The iterator to be initialized.\n+    If this parameter is NULL, the function will fail and return false.\n+ @return true if the `iter` has been successfully initialized.\n+ \n+ @note The iterator does not need to be destroyed.\n+ */\n yyjson_api_inline bool yyjson_obj_iter_init(yyjson_val *obj,\n-\t\t\t\t\t\t\t\t\t\t   yyjson_obj_iter *iter);\n+                                            yyjson_obj_iter *iter);\n \n /**\n-Returns whether the iteration has more elements.\n-If `iter` is NULL, this function will return false.\n-*/\n+ Returns whether the iteration has more elements.\n+ If `iter` is NULL, this function will return false.\n+ */\n yyjson_api_inline bool yyjson_obj_iter_has_next(yyjson_obj_iter *iter);\n \n /**\n-Returns the next key in the iteration, or NULL on end.\n-If `iter` is NULL, this function will return NULL.\n-*/\n+ Returns the next key in the iteration, or NULL on end.\n+ If `iter` is NULL, this function will return NULL.\n+ */\n yyjson_api_inline yyjson_val *yyjson_obj_iter_next(yyjson_obj_iter *iter);\n \n /**\n-Returns the value for key inside the iteration.\n-If `iter` is NULL, this function will return NULL.\n-*/\n+ Returns the value for key inside the iteration.\n+ If `iter` is NULL, this function will return NULL.\n+ */\n yyjson_api_inline yyjson_val *yyjson_obj_iter_get_val(yyjson_val *key);\n \n /**\n-Iterates to a specified key and returns the value.\n-\n-This function does the same thing as yyjson_obj_get(), but is much faster\n-if the ordering of the keys is known at compile-time and you are using the same\n-order to look up the values. If the key exists in this object, then the\n-iterator will stop at the next key, otherwise the iterator will not change and\n-NULL is returned.\n-\n-@param iter The object iterator, should not be NULL.\n-@param key The key, should be a UTF-8 string with null-terminator.\n-@return The value to which the specified key is mapped.\n-   NULL if this object contains no mapping for the key or input is invalid.\n-\n-@warning This function takes a linear search time if the key is not nearby.\n-*/\n+ Iterates to a specified key and returns the value.\n+ \n+ This function does the same thing as `yyjson_obj_get()`, but is much faster\n+ if the ordering of the keys is known at compile-time and you are using the same\n+ order to look up the values. If the key exists in this object, then the\n+ iterator will stop at the next key, otherwise the iterator will not change and\n+ NULL is returned.\n+ \n+ @param iter The object iterator, should not be NULL.\n+ @param key The key, should be a UTF-8 string with null-terminator.\n+ @return The value to which the specified key is mapped.\n+    NULL if this object contains no mapping for the key or input is invalid.\n+ \n+ @warning This function takes a linear search time if the key is not nearby.\n+ */\n yyjson_api_inline yyjson_val *yyjson_obj_iter_get(yyjson_obj_iter *iter,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *key);\n+                                                  const char *key);\n \n /**\n-Iterates to a specified key and returns the value.\n-\n-This function does the same thing as yyjson_obj_getn(), but is much faster\n-if the ordering of the keys is known at compile-time and you are using the same\n-order to look up the values. If the key exists in this object, then the\n-iterator will stop at the next key, otherwise the iterator will not change and\n-NULL is returned.\n-\n-@param iter The object iterator, should not be NULL.\n-@param key The key, should be a UTF-8 string, null-terminator is not required.\n-@param key_len The the length of `key`, in bytes.\n-@return The value to which the specified key is mapped.\n-   NULL if this object contains no mapping for the key or input is invalid.\n-\n-@warning This function takes a linear search time if the key is not nearby.\n-*/\n+ Iterates to a specified key and returns the value.\n+\n+ This function does the same thing as `yyjson_obj_getn()`, but is much faster\n+ if the ordering of the keys is known at compile-time and you are using the same\n+ order to look up the values. If the key exists in this object, then the\n+ iterator will stop at the next key, otherwise the iterator will not change and\n+ NULL is returned.\n+ \n+ @param iter The object iterator, should not be NULL.\n+ @param key The key, should be a UTF-8 string, null-terminator is not required.\n+ @param key_len The the length of `key`, in bytes.\n+ @return The value to which the specified key is mapped.\n+    NULL if this object contains no mapping for the key or input is invalid.\n+ \n+ @warning This function takes a linear search time if the key is not nearby.\n+ */\n yyjson_api_inline yyjson_val *yyjson_obj_iter_getn(yyjson_obj_iter *iter,\n-\t\t\t\t\t\t\t\t\t\t\t\t  const char *key,\n-\t\t\t\t\t\t\t\t\t\t\t\t  size_t key_len);\n+                                                   const char *key,\n+                                                   size_t key_len);\n \n /**\n-Macro for iterating over an object.\n-It works like iterator, but with a more intuitive API.\n-\n-@par Example\n-@code\n-   size_t idx, max;\n-   yyjson_val *key, *val;\n-   yyjson_obj_foreach(obj, idx, max, key, val) {\n-\t   your_func(key, val);\n-   }\n-@endcode\n-*/\n+ Macro for iterating over an object.\n+ It works like iterator, but with a more intuitive API.\n+ \n+ @par Example\n+ @code\n+    size_t idx, max;\n+    yyjson_val *key, *val;\n+    yyjson_obj_foreach(obj, idx, max, key, val) {\n+        your_func(key, val);\n+    }\n+ @endcode\n+ */\n #define yyjson_obj_foreach(obj, idx, max, key, val) \\\n-   for ((idx) = 0, \\\n-\t   (max) = yyjson_obj_size(obj), \\\n-\t   (key) = (obj) ? unsafe_yyjson_get_first(obj) : NULL, \\\n-\t   (val) = (key) + 1; \\\n-\t   (idx) < (max); \\\n-\t   (idx)++, \\\n-\t   (key) = unsafe_yyjson_get_next(val), \\\n-\t   (val) = (key) + 1)\n+    for ((idx) = 0, \\\n+        (max) = yyjson_obj_size(obj), \\\n+        (key) = (obj) ? unsafe_yyjson_get_first(obj) : NULL, \\\n+        (val) = (key) + 1; \\\n+        (idx) < (max); \\\n+        (idx)++, \\\n+        (key) = unsafe_yyjson_get_next(val), \\\n+        (val) = (key) + 1)\n \n \n \n /*==============================================================================\n-* Mutable JSON Document API\n-*============================================================================*/\n+ * Mutable JSON Document API\n+ *============================================================================*/\n \n /** Returns the root value of this JSON document.\n-   Returns NULL if `doc` is NULL. */\n+    Returns NULL if `doc` is NULL. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_doc_get_root(yyjson_mut_doc *doc);\n \n /** Sets the root value of this JSON document.\n-   Pass NULL to clear root value of the document. */\n+    Pass NULL to clear root value of the document. */\n yyjson_api_inline void yyjson_mut_doc_set_root(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *root);\n+                                               yyjson_mut_val *root);\n \n /** Release the JSON document and free the memory.\n-   After calling this function, the `doc` and all values from the `doc` are no\n-   longer available. This function will do nothing if the `doc` is NULL.  */\n+    After calling this function, the `doc` and all values from the `doc` are no\n+    longer available. This function will do nothing if the `doc` is NULL.  */\n yyjson_api void yyjson_mut_doc_free(yyjson_mut_doc *doc);\n \n /** Creates and returns a new mutable JSON document, returns NULL on error.\n-   If allocator is NULL, the default allocator will be used. */\n+    If allocator is NULL, the default allocator will be used. */\n yyjson_api yyjson_mut_doc *yyjson_mut_doc_new(const yyjson_alc *alc);\n \n /** Copies and returns a new mutable document from input, returns NULL on error.\n-   This makes a `deep-copy` on the immutable document.\n-   If allocator is NULL, the default allocator will be used. */\n+    This makes a `deep-copy` on the immutable document.\n+    If allocator is NULL, the default allocator will be used.\n+    @note `imut_doc` -> `mut_doc`. */\n yyjson_api yyjson_mut_doc *yyjson_doc_mut_copy(yyjson_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  const yyjson_alc *alc);\n+                                               const yyjson_alc *alc);\n \n /** Copies and returns a new mutable document from input, returns NULL on error.\n-   This makes a `deep-copy` on the mutable document.\n-   If allocator is NULL, the default allocator will be used. */\n+    This makes a `deep-copy` on the mutable document.\n+    If allocator is NULL, the default allocator will be used.\n+    @note `mut_doc` -> `mut_doc`. */\n yyjson_api yyjson_mut_doc *yyjson_mut_doc_mut_copy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t  const yyjson_alc *alc);\n+                                                   const yyjson_alc *alc);\n \n /** Copies and returns a new mutable value from input, returns NULL on error.\n-   This makes a `deep-copy` on the immutable value.\n-   The memory was managed by mutable document. */\n+    This makes a `deep-copy` on the immutable value.\n+    The memory was managed by mutable document.\n+    @note `imut_val` -> `mut_val`. */\n yyjson_api yyjson_mut_val *yyjson_val_mut_copy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_val *val);\n-\n-/** Copies and return a new mutable value from input, returns NULL on error,\n-   This makes a `deep-copy` on the mutable value.\n-   The memory was managed by mutable document.\n+                                               yyjson_val *val);\n \n-   @warning This function is recursive and may cause a stack overflow\n-\t   if the object level is too deep. */\n+/** Copies and returns a new mutable value from input, returns NULL on error.\n+    This makes a `deep-copy` on the mutable value.\n+    The memory was managed by mutable document.\n+    @note `mut_val` -> `mut_val`.\n+    @warning This function is recursive and may cause a stack overflow\n+        if the object level is too deep. */\n yyjson_api yyjson_mut_val *yyjson_mut_val_mut_copy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *val);\n+                                                   yyjson_mut_val *val);\n+\n+/** Copies and returns a new immutable document from input,\n+    returns NULL on error. This makes a `deep-copy` on the mutable document.\n+    The returned document should be freed with `yyjson_doc_free()`.\n+    @note `mut_doc` -> `imut_doc`.\n+    @warning This function is recursive and may cause a stack overflow\n+        if the object level is too deep. */\n+yyjson_api yyjson_doc *yyjson_mut_doc_imut_copy(yyjson_mut_doc *doc,\n+                                                const yyjson_alc *alc);\n+\n+/** Copies and returns a new immutable document from input,\n+    returns NULL on error. This makes a `deep-copy` on the mutable value.\n+    The returned document should be freed with `yyjson_doc_free()`.\n+    @note `mut_val` -> `imut_doc`.\n+    @warning This function is recursive and may cause a stack overflow\n+        if the object level is too deep. */\n+yyjson_api yyjson_doc *yyjson_mut_val_imut_copy(yyjson_mut_val *val,\n+                                                const yyjson_alc *alc);\n \n \n \n /*==============================================================================\n-* Mutable JSON Value Type API\n-*============================================================================*/\n+ * Mutable JSON Value Type API\n+ *============================================================================*/\n \n /** Returns whether the JSON value is raw.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_raw(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is `null`.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_null(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is `true`.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_true(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is `false`.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_false(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is bool (true/false).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_bool(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is unsigned integer (uint64_t).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_uint(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is signed integer (int64_t).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_sint(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is integer (uint64_t/int64_t).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_int(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is real number (double).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_real(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is number (uint/sint/real).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_num(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is string.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_str(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is array.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_arr(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is object.\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_obj(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is container (array/object).\n-   Returns false if `val` is NULL. */\n+    Returns false if `val` is NULL. */\n yyjson_api_inline bool yyjson_mut_is_ctn(yyjson_mut_val *val);\n \n \n \n /*==============================================================================\n-* Mutable JSON Value Content API\n-*============================================================================*/\n+ * Mutable JSON Value Content API\n+ *============================================================================*/\n \n /** Returns the JSON value's type.\n-   Returns YYJSON_TYPE_NONE if `val` is NULL. */\n+    Returns `YYJSON_TYPE_NONE` if `val` is NULL. */\n yyjson_api_inline yyjson_type yyjson_mut_get_type(yyjson_mut_val *val);\n \n /** Returns the JSON value's subtype.\n-   Returns YYJSON_SUBTYPE_NONE if `val` is NULL. */\n+    Returns `YYJSON_SUBTYPE_NONE` if `val` is NULL. */\n yyjson_api_inline yyjson_subtype yyjson_mut_get_subtype(yyjson_mut_val *val);\n \n /** Returns the JSON value's tag.\n-   Returns 0 if `val` is NULL. */\n+    Returns 0 if `val` is NULL. */\n yyjson_api_inline uint8_t yyjson_mut_get_tag(yyjson_mut_val *val);\n \n /** Returns the JSON value's type description.\n-   The return value should be one of these strings: \"raw\", \"null\", \"string\",\n-   \"array\", \"object\", \"true\", \"false\", \"uint\", \"sint\", \"real\", \"unknown\". */\n+    The return value should be one of these strings: \"raw\", \"null\", \"string\",\n+    \"array\", \"object\", \"true\", \"false\", \"uint\", \"sint\", \"real\", \"unknown\". */\n yyjson_api_inline const char *yyjson_mut_get_type_desc(yyjson_mut_val *val);\n \n /** Returns the content if the value is raw.\n-   Returns NULL if `val` is NULL or type is not raw. */\n+    Returns NULL if `val` is NULL or type is not raw. */\n yyjson_api_inline const char *yyjson_mut_get_raw(yyjson_mut_val *val);\n \n /** Returns the content if the value is bool.\n-   Returns NULL if `val` is NULL or type is not bool. */\n+    Returns NULL if `val` is NULL or type is not bool. */\n yyjson_api_inline bool yyjson_mut_get_bool(yyjson_mut_val *val);\n \n /** Returns the content and cast to uint64_t.\n-   Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n+    Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n yyjson_api_inline uint64_t yyjson_mut_get_uint(yyjson_mut_val *val);\n \n /** Returns the content and cast to int64_t.\n-   Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n+    Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n yyjson_api_inline int64_t yyjson_mut_get_sint(yyjson_mut_val *val);\n \n /** Returns the content and cast to int.\n-   Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n+    Returns 0 if `val` is NULL or type is not integer(sint/uint). */\n yyjson_api_inline int yyjson_mut_get_int(yyjson_mut_val *val);\n \n /** Returns the content if the value is real number.\n-   Returns 0.0 if `val` is NULL or type is not real(double). */\n+    Returns 0.0 if `val` is NULL or type is not real(double). */\n yyjson_api_inline double yyjson_mut_get_real(yyjson_mut_val *val);\n \n /** Returns the content if the value is string.\n-   Returns NULL if `val` is NULL or type is not string. */\n+    Returns NULL if `val` is NULL or type is not string. */\n yyjson_api_inline const char *yyjson_mut_get_str(yyjson_mut_val *val);\n \n /** Returns the content length (string length, array size, object size.\n-   Returns 0 if `val` is NULL or type is not string/array/object. */\n+    Returns 0 if `val` is NULL or type is not string/array/object. */\n yyjson_api_inline size_t yyjson_mut_get_len(yyjson_mut_val *val);\n \n /** Returns whether the JSON value is equals to a string.\n-   The `str` should be a null-terminated UTF-8 string.\n-   Returns false if input is NULL or type is not string. */\n+    The `str` should be a null-terminated UTF-8 string.\n+    Returns false if input is NULL or type is not string. */\n yyjson_api_inline bool yyjson_mut_equals_str(yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\tconst char *str);\n+                                             const char *str);\n \n /** Returns whether the JSON value is equals to a string.\n-   The `str` should be a UTF-8 string, null-terminator is not required.\n-   Returns false if input is NULL or type is not string. */\n+    The `str` should be a UTF-8 string, null-terminator is not required.\n+    Returns false if input is NULL or type is not string. */\n yyjson_api_inline bool yyjson_mut_equals_strn(yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t const char *str, size_t len);\n+                                              const char *str, size_t len);\n \n /** Returns whether two JSON values are equal (deep compare).\n-   Returns false if input is NULL.\n-\n-   @warning This function is recursive and may cause a stack overflow\n-\t   if the object level is too deep. */\n+    Returns false if input is NULL.\n+    \n+    @warning This function is recursive and may cause a stack overflow\n+        if the object level is too deep. */\n yyjson_api_inline bool yyjson_mut_equals(yyjson_mut_val *lhs,\n-\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *rhs);\n+                                         yyjson_mut_val *rhs);\n+\n+/** Set the value to raw.\n+    Returns false if input is NULL.\n+    @warning This function should not be used on an existing object or array. */\n+yyjson_api_inline bool yyjson_mut_set_raw(yyjson_mut_val *val,\n+                                          const char *raw, size_t len);\n+\n+/** Set the value to null.\n+    Returns false if input is NULL.\n+    @warning This function should not be used on an existing object or array. */\n+yyjson_api_inline bool yyjson_mut_set_null(yyjson_mut_val *val);\n+\n+/** Set the value to bool.\n+    Returns false if input is NULL.\n+    @warning This function should not be used on an existing object or array. */\n+yyjson_api_inline bool yyjson_mut_set_bool(yyjson_mut_val *val, bool num);\n+\n+/** Set the value to uint.\n+    Returns false if input is NULL.\n+    @warning This function should not be used on an existing object or array. */\n+yyjson_api_inline bool yyjson_mut_set_uint(yyjson_mut_val *val, uint64_t num);\n+\n+/** Set the value to sint.\n+    Returns false if input is NULL.\n+    @warning This function should not be used on an existing object or array. */\n+yyjson_api_inline bool yyjson_mut_set_sint(yyjson_mut_val *val, int64_t num);\n+\n+/** Set the value to int.\n+    Returns false if input is NULL.\n+    @warning This function should not be used on an existing object or array. */\n+yyjson_api_inline bool yyjson_mut_set_int(yyjson_mut_val *val, int num);\n+\n+/** Set the value to real.\n+    Returns false if input is NULL.\n+    @warning This function should not be used on an existing object or array. */\n+yyjson_api_inline bool yyjson_mut_set_real(yyjson_mut_val *val, double num);\n+\n+/** Set the value to string (null-terminated).\n+    Returns false if input is NULL.\n+    @warning This function should not be used on an existing object or array. */\n+yyjson_api_inline bool yyjson_mut_set_str(yyjson_mut_val *val, const char *str);\n+\n+/** Set the value to string (with length).\n+    Returns false if input is NULL.\n+    @warning This function should not be used on an existing object or array. */\n+yyjson_api_inline bool yyjson_mut_set_strn(yyjson_mut_val *val,\n+                                           const char *str, size_t len);\n+\n+/** Set the value to array.\n+    Returns false if input is NULL.\n+    @warning This function should not be used on an existing object or array. */\n+yyjson_api_inline bool yyjson_mut_set_arr(yyjson_mut_val *val);\n+\n+/** Set the value to array.\n+    Returns false if input is NULL.\n+    @warning This function should not be used on an existing object or array. */\n+yyjson_api_inline bool yyjson_mut_set_obj(yyjson_mut_val *val);\n \n \n \n /*==============================================================================\n-* Mutable JSON Value Creation API\n-*============================================================================*/\n+ * Mutable JSON Value Creation API\n+ *============================================================================*/\n \n /** Creates and returns a raw value, returns NULL on error.\n-   The `str` should be a null-terminated UTF-8 string.\n-\n-   @warning The input string is not copied, you should keep this string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `str` should be a null-terminated UTF-8 string.\n+    \n+    @warning The input string is not copied, you should keep this string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_raw(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *str);\n+                                                 const char *str);\n \n /** Creates and returns a raw value, returns NULL on error.\n-   The `str` should be a UTF-8 string, null-terminator is not required.\n-\n-   @warning The input string is not copied, you should keep this string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `str` should be a UTF-8 string, null-terminator is not required.\n+    \n+    @warning The input string is not copied, you should keep this string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_rawn(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *str,\n-\t\t\t\t\t\t\t\t\t\t\t\t size_t len);\n+                                                  const char *str,\n+                                                  size_t len);\n \n /** Creates and returns a raw value, returns NULL on error.\n-   The `str` should be a null-terminated UTF-8 string.\n-   The input string is copied and held by the document. */\n+    The `str` should be a null-terminated UTF-8 string.\n+    The input string is copied and held by the document. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_rawcpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t   const char *str);\n+                                                    const char *str);\n \n /** Creates and returns a raw value, returns NULL on error.\n-   The `str` should be a UTF-8 string, null-terminator is not required.\n-   The input string is copied and held by the document. */\n+    The `str` should be a UTF-8 string, null-terminator is not required.\n+    The input string is copied and held by the document. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_rawncpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *str,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tsize_t len);\n+                                                     const char *str,\n+                                                     size_t len);\n \n /** Creates and returns a null value, returns NULL on error. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_null(yyjson_mut_doc *doc);\n@@ -1840,2698 +2019,2927 @@ yyjson_api_inline yyjson_mut_val *yyjson_mut_false(yyjson_mut_doc *doc);\n \n /** Creates and returns a bool value, returns NULL on error. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_bool(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t bool val);\n+                                                  bool val);\n \n /** Creates and returns an unsigned integer value, returns NULL on error. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_uint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t uint64_t num);\n+                                                  uint64_t num);\n \n /** Creates and returns a signed integer value, returns NULL on error. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_sint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t int64_t num);\n+                                                  int64_t num);\n \n /** Creates and returns a signed integer value, returns NULL on error. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_int(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\tint64_t num);\n+                                                 int64_t num);\n \n /** Creates and returns an real number value, returns NULL on error. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_real(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t double num);\n+                                                  double num);\n \n /** Creates and returns a string value, returns NULL on error.\n-   The `str` should be a null-terminated UTF-8 string.\n-   @warning The input string is not copied, you should keep this string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `str` should be a null-terminated UTF-8 string.\n+    @warning The input string is not copied, you should keep this string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_str(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *str);\n+                                                 const char *str);\n \n /** Creates and returns a string value, returns NULL on error.\n-   The `str` should be a UTF-8 string, null-terminator is not required.\n-   @warning The input string is not copied, you should keep this string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `str` should be a UTF-8 string, null-terminator is not required.\n+    @warning The input string is not copied, you should keep this string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_strn(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *str,\n-\t\t\t\t\t\t\t\t\t\t\t\t size_t len);\n+                                                  const char *str,\n+                                                  size_t len);\n \n /** Creates and returns a string value, returns NULL on error.\n-   The `str` should be a null-terminated UTF-8 string.\n-   The input string is copied and held by the document. */\n+    The `str` should be a null-terminated UTF-8 string.\n+    The input string is copied and held by the document. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_strcpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t   const char *str);\n+                                                    const char *str);\n \n /** Creates and returns a string value, returns NULL on error.\n-   The `str` should be a UTF-8 string, null-terminator is not required.\n-   The input string is copied and held by the document. */\n+    The `str` should be a UTF-8 string, null-terminator is not required.\n+    The input string is copied and held by the document. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_strncpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *str,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tsize_t len);\n+                                                     const char *str,\n+                                                     size_t len);\n \n \n \n /*==============================================================================\n-* Mutable JSON Array API\n-*============================================================================*/\n+ * Mutable JSON Array API\n+ *============================================================================*/\n \n /** Returns the number of elements in this array.\n-   Returns 0 if `arr` is NULL or type is not array. */\n+    Returns 0 if `arr` is NULL or type is not array. */\n yyjson_api_inline size_t yyjson_mut_arr_size(yyjson_mut_val *arr);\n \n /** Returns the element at the specified position in this array.\n-   Returns NULL if array is NULL/empty or the index is out of bounds.\n-   @warning This function takes a linear search time. */\n+    Returns NULL if array is NULL/empty or the index is out of bounds.\n+    @warning This function takes a linear search time. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_get(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tsize_t idx);\n+                                                     size_t idx);\n \n /** Returns the first element of this array.\n-   Returns NULL if `arr` is NULL/empty or type is not array. */\n+    Returns NULL if `arr` is NULL/empty or type is not array. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_get_first(yyjson_mut_val *arr);\n \n /** Returns the last element of this array.\n-   Returns NULL if `arr` is NULL/empty or type is not array. */\n+    Returns NULL if `arr` is NULL/empty or type is not array. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_get_last(yyjson_mut_val *arr);\n \n \n \n /*==============================================================================\n-* Mutable JSON Array Iterator API\n-*============================================================================*/\n+ * Mutable JSON Array Iterator API\n+ *============================================================================*/\n \n /**\n-A mutable JSON array iterator.\n-\n-@warning You should not modify the array while iterating over it, but you can\n-   use yyjson_mut_arr_iter_remove() to remove current value.\n-\n-@par Example\n-@code\n-   yyjson_mut_val *val;\n-   yyjson_mut_arr_iter iter;\n-   yyjson_mut_arr_iter_init(arr, &iter);\n-   while ((val = yyjson_mut_arr_iter_next(&iter))) {\n-\t   your_func(val);\n-\t   if (your_val_is_unused(val)) {\n-\t\t   yyjson_mut_arr_iter_remove(&iter);\n-\t   }\n-   }\n-@endcode\n-*/\n+ A mutable JSON array iterator.\n+ \n+ @warning You should not modify the array while iterating over it, but you can\n+    use `yyjson_mut_arr_iter_remove()` to remove current value.\n+ \n+ @par Example\n+ @code\n+    yyjson_mut_val *val;\n+    yyjson_mut_arr_iter iter;\n+    yyjson_mut_arr_iter_init(arr, &iter);\n+    while ((val = yyjson_mut_arr_iter_next(&iter))) {\n+        your_func(val);\n+        if (your_val_is_unused(val)) {\n+            yyjson_mut_arr_iter_remove(&iter);\n+        }\n+    }\n+ @endcode\n+ */\n typedef struct yyjson_mut_arr_iter yyjson_mut_arr_iter;\n \n /**\n-Initialize an iterator for this array.\n-\n-@param arr The array to be iterated over.\n-   If this parameter is NULL or not an array, `iter` will be set to empty.\n-@param iter The iterator to be initialized.\n-   If this parameter is NULL, the function will fail and return false.\n-@return true if the `iter` has been successfully initialized.\n-\n-@note The iterator does not need to be destroyed.\n-*/\n+ Initialize an iterator for this array.\n+ \n+ @param arr The array to be iterated over.\n+    If this parameter is NULL or not an array, `iter` will be set to empty.\n+ @param iter The iterator to be initialized.\n+    If this parameter is NULL, the function will fail and return false.\n+ @return true if the `iter` has been successfully initialized.\n+ \n+ @note The iterator does not need to be destroyed.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_iter_init(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t   yyjson_mut_arr_iter *iter);\n+    yyjson_mut_arr_iter *iter);\n \n /**\n-Returns whether the iteration has more elements.\n-If `iter` is NULL, this function will return false.\n-*/\n+ Returns whether the iteration has more elements.\n+ If `iter` is NULL, this function will return false.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_iter_has_next(\n-   yyjson_mut_arr_iter *iter);\n+    yyjson_mut_arr_iter *iter);\n \n /**\n-Returns the next element in the iteration, or NULL on end.\n-If `iter` is NULL, this function will return NULL.\n-*/\n+ Returns the next element in the iteration, or NULL on end.\n+ If `iter` is NULL, this function will return NULL.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_iter_next(\n-   yyjson_mut_arr_iter *iter);\n+    yyjson_mut_arr_iter *iter);\n \n /**\n-Removes and returns current element in the iteration.\n-If `iter` is NULL, this function will return NULL.\n-*/\n+ Removes and returns current element in the iteration.\n+ If `iter` is NULL, this function will return NULL.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_iter_remove(\n-   yyjson_mut_arr_iter *iter);\n+    yyjson_mut_arr_iter *iter);\n \n /**\n-Macro for iterating over an array.\n-It works like iterator, but with a more intuitive API.\n-\n-@warning You should not modify the array while iterating over it.\n-\n-@par Example\n-@code\n-   size_t idx, max;\n-   yyjson_mut_val *val;\n-   yyjson_mut_arr_foreach(arr, idx, max, val) {\n-\t   your_func(idx, val);\n-   }\n-@endcode\n-*/\n+ Macro for iterating over an array.\n+ It works like iterator, but with a more intuitive API.\n+ \n+ @warning You should not modify the array while iterating over it.\n+ \n+ @par Example\n+ @code\n+    size_t idx, max;\n+    yyjson_mut_val *val;\n+    yyjson_mut_arr_foreach(arr, idx, max, val) {\n+        your_func(idx, val);\n+    }\n+ @endcode\n+ */\n #define yyjson_mut_arr_foreach(arr, idx, max, val) \\\n-   for ((idx) = 0, \\\n-\t   (max) = yyjson_mut_arr_size(arr), \\\n-\t   (val) = yyjson_mut_arr_get_first(arr); \\\n-\t   (idx) < (max); \\\n-\t   (idx)++, \\\n-\t   (val) = (val)->next)\n+    for ((idx) = 0, \\\n+        (max) = yyjson_mut_arr_size(arr), \\\n+        (val) = yyjson_mut_arr_get_first(arr); \\\n+        (idx) < (max); \\\n+        (idx)++, \\\n+        (val) = (val)->next)\n \n \n \n /*==============================================================================\n-* Mutable JSON Array Creation API\n-*============================================================================*/\n+ * Mutable JSON Array Creation API\n+ *============================================================================*/\n \n /**\n-Creates and returns an empty mutable array.\n-@param doc A mutable document, used for memory allocation only.\n-@return The new array. NULL if input is NULL or memory allocation failed.\n-*/\n+ Creates and returns an empty mutable array.\n+ @param doc A mutable document, used for memory allocation only.\n+ @return The new array. NULL if input is NULL or memory allocation failed.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr(yyjson_mut_doc *doc);\n \n /**\n-Creates and returns a new mutable array with the given boolean values.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of boolean values.\n-@param count The value count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const bool vals[3] = { true, false, true };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_bool(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given boolean values.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of boolean values.\n+ @param count The value count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const bool vals[3] = { true, false, true };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_bool(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_bool(\n-   yyjson_mut_doc *doc, const bool *vals, size_t count);\n+    yyjson_mut_doc *doc, const bool *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given sint numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of sint numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const int64_t vals[3] = { -1, 0, 1 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_sint64(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given sint numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of sint numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const int64_t vals[3] = { -1, 0, 1 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_sint64(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_sint(\n-   yyjson_mut_doc *doc, const int64_t *vals, size_t count);\n+    yyjson_mut_doc *doc, const int64_t *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given uint numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of uint numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const uint64_t vals[3] = { 0, 1, 0 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_uint(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given uint numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of uint numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const uint64_t vals[3] = { 0, 1, 0 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_uint(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_uint(\n-   yyjson_mut_doc *doc, const uint64_t *vals, size_t count);\n+    yyjson_mut_doc *doc, const uint64_t *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given real numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of real numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const double vals[3] = { 0.1, 0.2, 0.3 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_real(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given real numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of real numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const double vals[3] = { 0.1, 0.2, 0.3 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_real(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_real(\n-   yyjson_mut_doc *doc, const double *vals, size_t count);\n+    yyjson_mut_doc *doc, const double *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given int8 numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of int8 numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const int8_t vals[3] = { -1, 0, 1 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_sint8(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given int8 numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of int8 numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const int8_t vals[3] = { -1, 0, 1 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_sint8(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_sint8(\n-   yyjson_mut_doc *doc, const int8_t *vals, size_t count);\n+    yyjson_mut_doc *doc, const int8_t *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given int16 numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of int16 numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const int16_t vals[3] = { -1, 0, 1 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_sint16(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given int16 numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of int16 numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const int16_t vals[3] = { -1, 0, 1 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_sint16(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_sint16(\n-   yyjson_mut_doc *doc, const int16_t *vals, size_t count);\n+    yyjson_mut_doc *doc, const int16_t *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given int32 numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of int32 numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const int32_t vals[3] = { -1, 0, 1 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_sint32(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given int32 numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of int32 numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const int32_t vals[3] = { -1, 0, 1 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_sint32(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_sint32(\n-   yyjson_mut_doc *doc, const int32_t *vals, size_t count);\n+    yyjson_mut_doc *doc, const int32_t *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given int64 numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of int64 numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const int64_t vals[3] = { -1, 0, 1 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_sint64(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given int64 numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of int64 numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const int64_t vals[3] = { -1, 0, 1 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_sint64(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_sint64(\n-   yyjson_mut_doc *doc, const int64_t *vals, size_t count);\n+    yyjson_mut_doc *doc, const int64_t *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given uint8 numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of uint8 numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const uint8_t vals[3] = { 0, 1, 0 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_uint8(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given uint8 numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of uint8 numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const uint8_t vals[3] = { 0, 1, 0 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_uint8(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_uint8(\n-   yyjson_mut_doc *doc, const uint8_t *vals, size_t count);\n+    yyjson_mut_doc *doc, const uint8_t *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given uint16 numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of uint16 numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const uint16_t vals[3] = { 0, 1, 0 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_uint16(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given uint16 numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of uint16 numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const uint16_t vals[3] = { 0, 1, 0 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_uint16(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_uint16(\n-   yyjson_mut_doc *doc, const uint16_t *vals, size_t count);\n+    yyjson_mut_doc *doc, const uint16_t *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given uint32 numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of uint32 numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const uint32_t vals[3] = { 0, 1, 0 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_uint32(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given uint32 numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of uint32 numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const uint32_t vals[3] = { 0, 1, 0 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_uint32(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_uint32(\n-   yyjson_mut_doc *doc, const uint32_t *vals, size_t count);\n+    yyjson_mut_doc *doc, const uint32_t *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given uint64 numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of uint64 numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-\tconst uint64_t vals[3] = { 0, 1, 0 };\n-\tyyjson_mut_val *arr = yyjson_mut_arr_with_uint64(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given uint64 numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of uint64 numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+     const uint64_t vals[3] = { 0, 1, 0 };\n+     yyjson_mut_val *arr = yyjson_mut_arr_with_uint64(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_uint64(\n-   yyjson_mut_doc *doc, const uint64_t *vals, size_t count);\n+    yyjson_mut_doc *doc, const uint64_t *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given float numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of float numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const float vals[3] = { -1.0f, 0.0f, 1.0f };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_float(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given float numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of float numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const float vals[3] = { -1.0f, 0.0f, 1.0f };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_float(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_float(\n-   yyjson_mut_doc *doc, const float *vals, size_t count);\n+    yyjson_mut_doc *doc, const float *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given double numbers.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of double numbers.\n-@param count The number count. If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const double vals[3] = { -1.0, 0.0, 1.0 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_double(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given double numbers.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of double numbers.\n+ @param count The number count. If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const double vals[3] = { -1.0, 0.0, 1.0 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_double(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_double(\n-   yyjson_mut_doc *doc, const double *vals, size_t count);\n+    yyjson_mut_doc *doc, const double *vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given strings, these strings\n-will not be copied.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of UTF-8 null-terminator strings.\n-   If this array contains NULL, the function will fail and return NULL.\n-@param count The number of values in `vals`.\n-   If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@warning The input strings are not copied, you should keep these strings\n-   unmodified for the lifetime of this JSON document. If these strings will be\n-   modified, you should use yyjson_mut_arr_with_strcpy() instead.\n-\n-@par Example\n-@code\n-   const char *vals[3] = { \"a\", \"b\", \"c\" };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_str(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given strings, these strings\n+ will not be copied.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of UTF-8 null-terminator strings.\n+    If this array contains NULL, the function will fail and return NULL.\n+ @param count The number of values in `vals`.\n+    If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @warning The input strings are not copied, you should keep these strings\n+    unmodified for the lifetime of this JSON document. If these strings will be\n+    modified, you should use `yyjson_mut_arr_with_strcpy()` instead.\n+ \n+ @par Example\n+ @code\n+    const char *vals[3] = { \"a\", \"b\", \"c\" };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_str(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_str(\n-   yyjson_mut_doc *doc, const char **vals, size_t count);\n+    yyjson_mut_doc *doc, const char **vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given strings and string\n-lengths, these strings will not be copied.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of UTF-8 strings, null-terminator is not required.\n-   If this array contains NULL, the function will fail and return NULL.\n-@param lens A C array of string lengths, in bytes.\n-@param count The number of strings in `vals`.\n-   If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@warning The input strings are not copied, you should keep these strings\n-   unmodified for the lifetime of this JSON document. If these strings will be\n-   modified, you should use yyjson_mut_arr_with_strncpy() instead.\n-\n-@par Example\n-@code\n-   const char *vals[3] = { \"a\", \"bb\", \"c\" };\n-   const size_t lens[3] = { 1, 2, 1 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_strn(doc, vals, lens, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given strings and string\n+ lengths, these strings will not be copied.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of UTF-8 strings, null-terminator is not required.\n+    If this array contains NULL, the function will fail and return NULL.\n+ @param lens A C array of string lengths, in bytes.\n+ @param count The number of strings in `vals`.\n+    If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @warning The input strings are not copied, you should keep these strings\n+    unmodified for the lifetime of this JSON document. If these strings will be\n+    modified, you should use `yyjson_mut_arr_with_strncpy()` instead.\n+ \n+ @par Example\n+ @code\n+    const char *vals[3] = { \"a\", \"bb\", \"c\" };\n+    const size_t lens[3] = { 1, 2, 1 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_strn(doc, vals, lens, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_strn(\n-   yyjson_mut_doc *doc, const char **vals, const size_t *lens, size_t count);\n+    yyjson_mut_doc *doc, const char **vals, const size_t *lens, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given strings, these strings\n-will be copied.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of UTF-8 null-terminator strings.\n-   If this array contains NULL, the function will fail and return NULL.\n-@param count The number of values in `vals`.\n-   If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const char *vals[3] = { \"a\", \"b\", \"c\" };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_strcpy(doc, vals, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given strings, these strings\n+ will be copied.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of UTF-8 null-terminator strings.\n+    If this array contains NULL, the function will fail and return NULL.\n+ @param count The number of values in `vals`.\n+    If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const char *vals[3] = { \"a\", \"b\", \"c\" };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_strcpy(doc, vals, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_strcpy(\n-   yyjson_mut_doc *doc, const char **vals, size_t count);\n+    yyjson_mut_doc *doc, const char **vals, size_t count);\n \n /**\n-Creates and returns a new mutable array with the given strings and string\n-lengths, these strings will be copied.\n-\n-@param doc A mutable document, used for memory allocation only.\n-   If this parameter is NULL, the function will fail and return NULL.\n-@param vals A C array of UTF-8 strings, null-terminator is not required.\n-   If this array contains NULL, the function will fail and return NULL.\n-@param lens A C array of string lengths, in bytes.\n-@param count The number of strings in `vals`.\n-   If this value is 0, an empty array will return.\n-@return The new array. NULL if input is invalid or memory allocation failed.\n-\n-@par Example\n-@code\n-   const char *vals[3] = { \"a\", \"bb\", \"c\" };\n-   const size_t lens[3] = { 1, 2, 1 };\n-   yyjson_mut_val *arr = yyjson_mut_arr_with_strn(doc, vals, lens, 3);\n-@endcode\n-*/\n+ Creates and returns a new mutable array with the given strings and string\n+ lengths, these strings will be copied.\n+ \n+ @param doc A mutable document, used for memory allocation only.\n+    If this parameter is NULL, the function will fail and return NULL.\n+ @param vals A C array of UTF-8 strings, null-terminator is not required.\n+    If this array contains NULL, the function will fail and return NULL.\n+ @param lens A C array of string lengths, in bytes.\n+ @param count The number of strings in `vals`.\n+    If this value is 0, an empty array will return.\n+ @return The new array. NULL if input is invalid or memory allocation failed.\n+ \n+ @par Example\n+ @code\n+    const char *vals[3] = { \"a\", \"bb\", \"c\" };\n+    const size_t lens[3] = { 1, 2, 1 };\n+    yyjson_mut_val *arr = yyjson_mut_arr_with_strn(doc, vals, lens, 3);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_strncpy(\n-   yyjson_mut_doc *doc, const char **vals, const size_t *lens, size_t count);\n+    yyjson_mut_doc *doc, const char **vals, const size_t *lens, size_t count);\n \n \n \n /*==============================================================================\n-* Mutable JSON Array Modification API\n-*============================================================================*/\n+ * Mutable JSON Array Modification API\n+ *============================================================================*/\n \n /**\n-Inserts a value into an array at a given index.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param val The value to be inserted. Returns false if it is NULL.\n-@param idx The index to which to insert the new value.\n-   Returns false if the index is out of range.\n-@return Whether successful.\n-@warning This function takes a linear search time.\n-*/\n+ Inserts a value into an array at a given index.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param val The value to be inserted. Returns false if it is NULL.\n+ @param idx The index to which to insert the new value.\n+    Returns false if the index is out of range.\n+ @return Whether successful.\n+ @warning This function takes a linear search time.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_insert(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *val, size_t idx);\n+                                             yyjson_mut_val *val, size_t idx);\n \n /**\n-Inserts a value at the end of the array.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param val The value to be inserted. Returns false if it is NULL.\n-@return Whether successful.\n-*/\n+ Inserts a value at the end of the array.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param val The value to be inserted. Returns false if it is NULL.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_append(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *val);\n+                                             yyjson_mut_val *val);\n \n /**\n-Inserts a value at the head of the array.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param val The value to be inserted. Returns false if it is NULL.\n-@return    Whether successful.\n-*/\n+ Inserts a value at the head of the array.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param val The value to be inserted. Returns false if it is NULL.\n+ @return    Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_prepend(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *val);\n+                                              yyjson_mut_val *val);\n \n /**\n-Replaces a value at index and returns old value.\n-@param arr The array to which the value is to be replaced.\n-   Returns false if it is NULL or not an array.\n-@param idx The index to which to replace the value.\n-   Returns false if the index is out of range.\n-@param val The new value to replace. Returns false if it is NULL.\n-@return Old value, or NULL on error.\n-@warning This function takes a linear search time.\n-*/\n+ Replaces a value at index and returns old value.\n+ @param arr The array to which the value is to be replaced.\n+    Returns false if it is NULL or not an array.\n+ @param idx The index to which to replace the value.\n+    Returns false if the index is out of range.\n+ @param val The new value to replace. Returns false if it is NULL.\n+ @return Old value, or NULL on error.\n+ @warning This function takes a linear search time.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_replace(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize_t idx,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *val);\n+                                                         size_t idx,\n+                                                         yyjson_mut_val *val);\n \n /**\n-Removes and returns a value at index.\n-@param arr The array from which the value is to be removed.\n-   Returns false if it is NULL or not an array.\n-@param idx The index from which to remove the value.\n-   Returns false if the index is out of range.\n-@return Old value, or NULL on error.\n-@warning This function takes a linear search time.\n-*/\n+ Removes and returns a value at index.\n+ @param arr The array from which the value is to be removed.\n+    Returns false if it is NULL or not an array.\n+ @param idx The index from which to remove the value.\n+    Returns false if the index is out of range.\n+ @return Old value, or NULL on error.\n+ @warning This function takes a linear search time.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_remove(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t   size_t idx);\n+                                                        size_t idx);\n \n /**\n-Removes and returns the first value in this array.\n-@param arr The array from which the value is to be removed.\n-   Returns false if it is NULL or not an array.\n-@return The first value, or NULL on error.\n-*/\n+ Removes and returns the first value in this array.\n+ @param arr The array from which the value is to be removed.\n+    Returns false if it is NULL or not an array.\n+ @return The first value, or NULL on error.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_remove_first(\n-   yyjson_mut_val *arr);\n+    yyjson_mut_val *arr);\n \n /**\n-Removes and returns the last value in this array.\n-@param arr The array from which the value is to be removed.\n-   Returns false if it is NULL or not an array.\n-@return The last value, or NULL on error.\n-*/\n+ Removes and returns the last value in this array.\n+ @param arr The array from which the value is to be removed.\n+    Returns false if it is NULL or not an array.\n+ @return The last value, or NULL on error.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_remove_last(\n-   yyjson_mut_val *arr);\n+    yyjson_mut_val *arr);\n \n /**\n-Removes all values within a specified range in the array.\n-@param arr The array from which the value is to be removed.\n-   Returns false if it is NULL or not an array.\n-@param idx The start index of the range (0 is the first).\n-@param len The number of items in the range (can be 0).\n-@return Whether successful.\n-@warning This function takes a linear search time.\n-*/\n+ Removes all values within a specified range in the array.\n+ @param arr The array from which the value is to be removed.\n+    Returns false if it is NULL or not an array.\n+ @param idx The start index of the range (0 is the first).\n+ @param len The number of items in the range (can be 0).\n+ @return Whether successful.\n+ @warning This function takes a linear search time.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_remove_range(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\t  size_t idx, size_t len);\n+                                                   size_t idx, size_t len);\n \n /**\n-Removes all values in this array.\n-@param arr The array from which all of the values are to be removed.\n-   Returns false if it is NULL or not an array.\n-@return Whether successful.\n-*/\n+ Removes all values in this array.\n+ @param arr The array from which all of the values are to be removed.\n+    Returns false if it is NULL or not an array.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_clear(yyjson_mut_val *arr);\n \n /**\n-Rotates values in this array for the given number of times.\n-For example: [1,2,3,4,5] rotate 2 is [3,4,5,1,2].\n-@param arr The array to be rotated.\n-@param idx Index (or times) to rotate.\n-@warning This function takes a linear search time.\n-*/\n+ Rotates values in this array for the given number of times.\n+ For example: `[1,2,3,4,5]` rotate 2 is `[3,4,5,1,2]`.\n+ @param arr The array to be rotated.\n+ @param idx Index (or times) to rotate.\n+ @warning This function takes a linear search time.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_rotate(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\tsize_t idx);\n+                                             size_t idx);\n \n \n \n /*==============================================================================\n-* Mutable JSON Array Modification Convenience API\n-*============================================================================*/\n+ * Mutable JSON Array Modification Convenience API\n+ *============================================================================*/\n \n /**\n-Adds a value at the end of the array.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param val The value to be inserted. Returns false if it is NULL.\n-@return Whether successful.\n-*/\n+ Adds a value at the end of the array.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param val The value to be inserted. Returns false if it is NULL.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_val(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *val);\n+                                              yyjson_mut_val *val);\n \n /**\n-Adds a `null` value at the end of the array.\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@return Whether successful.\n-*/\n+ Adds a `null` value at the end of the array.\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_null(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr);\n+                                               yyjson_mut_val *arr);\n \n /**\n-Adds a `true` value at the end of the array.\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@return Whether successful.\n-*/\n+ Adds a `true` value at the end of the array.\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_true(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr);\n+                                               yyjson_mut_val *arr);\n \n /**\n-Adds a `false` value at the end of the array.\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@return Whether successful.\n-*/\n+ Adds a `false` value at the end of the array.\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_false(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t   yyjson_mut_val *arr);\n+                                                yyjson_mut_val *arr);\n \n /**\n-Adds a bool value at the end of the array.\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param val The bool value to be added.\n-@return Whether successful.\n-*/\n+ Adds a bool value at the end of the array.\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param val The bool value to be added.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_bool(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t  bool val);\n+                                               yyjson_mut_val *arr,\n+                                               bool val);\n \n /**\n-Adds an unsigned integer value at the end of the array.\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param num The number to be added.\n-@return Whether successful.\n-*/\n+ Adds an unsigned integer value at the end of the array.\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param num The number to be added.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_uint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t  uint64_t num);\n+                                               yyjson_mut_val *arr,\n+                                               uint64_t num);\n \n /**\n-Adds a signed integer value at the end of the array.\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param num The number to be added.\n-@return Whether successful.\n-*/\n+ Adds a signed integer value at the end of the array.\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param num The number to be added.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_sint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t  int64_t num);\n+                                               yyjson_mut_val *arr,\n+                                               int64_t num);\n \n /**\n-Adds a integer value at the end of the array.\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param num The number to be added.\n-@return Whether successful.\n-*/\n+ Adds a integer value at the end of the array.\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param num The number to be added.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_int(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t int64_t num);\n+                                              yyjson_mut_val *arr,\n+                                              int64_t num);\n \n /**\n-Adds a double value at the end of the array.\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param num The number to be added.\n-@return Whether successful.\n-*/\n+ Adds a double value at the end of the array.\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param num The number to be added.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_real(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t  double num);\n+                                               yyjson_mut_val *arr,\n+                                               double num);\n \n /**\n-Adds a string value at the end of the array (no copy).\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param str A null-terminated UTF-8 string.\n-@return Whether successful.\n-@warning The input string is not copied, you should keep this string unmodified\n-   for the lifetime of this JSON document.\n-*/\n+ Adds a string value at the end of the array (no copy).\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param str A null-terminated UTF-8 string.\n+ @return Whether successful.\n+ @warning The input string is not copied, you should keep this string unmodified\n+    for the lifetime of this JSON document.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_str(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t const char *str);\n+                                              yyjson_mut_val *arr,\n+                                              const char *str);\n \n /**\n-Adds a string value at the end of the array (no copy).\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param str A UTF-8 string, null-terminator is not required.\n-@param len The length of the string, in bytes.\n-@return Whether successful.\n-@warning The input string is not copied, you should keep this string unmodified\n-   for the lifetime of this JSON document.\n-*/\n+ Adds a string value at the end of the array (no copy).\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param str A UTF-8 string, null-terminator is not required.\n+ @param len The length of the string, in bytes.\n+ @return Whether successful.\n+ @warning The input string is not copied, you should keep this string unmodified\n+    for the lifetime of this JSON document.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_strn(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *str,\n-\t\t\t\t\t\t\t\t\t\t\t  size_t len);\n+                                               yyjson_mut_val *arr,\n+                                               const char *str,\n+                                               size_t len);\n \n /**\n-Adds a string value at the end of the array (copied).\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param str A null-terminated UTF-8 string.\n-@return Whether successful.\n-*/\n+ Adds a string value at the end of the array (copied).\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param str A null-terminated UTF-8 string.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_strcpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *str);\n+                                                 yyjson_mut_val *arr,\n+                                                 const char *str);\n \n /**\n-Adds a string value at the end of the array (copied).\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@param str A UTF-8 string, null-terminator is not required.\n-@param len The length of the string, in bytes.\n-@return Whether successful.\n-*/\n+ Adds a string value at the end of the array (copied).\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @param str A UTF-8 string, null-terminator is not required.\n+ @param len The length of the string, in bytes.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_arr_add_strncpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *str,\n-\t\t\t\t\t\t\t\t\t\t\t\t size_t len);\n+                                                  yyjson_mut_val *arr,\n+                                                  const char *str,\n+                                                  size_t len);\n \n /**\n-Creates and adds a new array at the end of the array.\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@return The new array, or NULL on error.\n-*/\n+ Creates and adds a new array at the end of the array.\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @return The new array, or NULL on error.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_add_arr(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *arr);\n+                                                         yyjson_mut_val *arr);\n \n /**\n-Creates and adds a new object at the end of the array.\n-@param doc The `doc` is only used for memory allocation.\n-@param arr The array to which the value is to be inserted.\n-   Returns false if it is NULL or not an array.\n-@return The new object, or NULL on error.\n-*/\n+ Creates and adds a new object at the end of the array.\n+ @param doc The `doc` is only used for memory allocation.\n+ @param arr The array to which the value is to be inserted.\n+    Returns false if it is NULL or not an array.\n+ @return The new object, or NULL on error.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_add_obj(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *arr);\n+                                                         yyjson_mut_val *arr);\n \n \n \n /*==============================================================================\n-* Mutable JSON Object API\n-*============================================================================*/\n+ * Mutable JSON Object API\n+ *============================================================================*/\n \n /** Returns the number of key-value pairs in this object.\n-   Returns 0 if `obj` is NULL or type is not object. */\n+    Returns 0 if `obj` is NULL or type is not object. */\n yyjson_api_inline size_t yyjson_mut_obj_size(yyjson_mut_val *obj);\n \n /** Returns the value to which the specified key is mapped.\n-   Returns NULL if this object contains no mapping for the key.\n-   Returns NULL if `obj/key` is NULL, or type is not object.\n-\n-   The `key` should be a null-terminated UTF-8 string.\n-\n-   @warning This function takes a linear search time. */\n+    Returns NULL if this object contains no mapping for the key.\n+    Returns NULL if `obj/key` is NULL, or type is not object.\n+    \n+    The `key` should be a null-terminated UTF-8 string.\n+    \n+    @warning This function takes a linear search time. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_get(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *key);\n+                                                     const char *key);\n \n /** Returns the value to which the specified key is mapped.\n-   Returns NULL if this object contains no mapping for the key.\n-   Returns NULL if `obj/key` is NULL, or type is not object.\n-\n-   The `key` should be a UTF-8 string, null-terminator is not required.\n-   The `key_len` should be the length of the key, in bytes.\n-\n-   @warning This function takes a linear search time. */\n+    Returns NULL if this object contains no mapping for the key.\n+    Returns NULL if `obj/key` is NULL, or type is not object.\n+    \n+    The `key` should be a UTF-8 string, null-terminator is not required.\n+    The `key_len` should be the length of the key, in bytes.\n+    \n+    @warning This function takes a linear search time. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_getn(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t const char *key,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t size_t key_len);\n+                                                      const char *key,\n+                                                      size_t key_len);\n \n \n \n /*==============================================================================\n-* Mutable JSON Object Iterator API\n-*============================================================================*/\n+ * Mutable JSON Object Iterator API\n+ *============================================================================*/\n \n /**\n-A mutable JSON object iterator.\n-\n-@warning You should not modify the object while iterating over it, but you can\n-   use yyjson_mut_obj_iter_remove() to remove current value.\n-\n-@par Example\n-@code\n-   yyjson_mut_val *key, *val;\n-   yyjson_mut_obj_iter iter;\n-   yyjson_mut_obj_iter_init(obj, &iter);\n-   while ((key = yyjson_mut_obj_iter_next(&iter))) {\n-\t   val = yyjson_mut_obj_iter_get_val(key);\n-\t   your_func(key, val);\n-\t   if (your_val_is_unused(key, val)) {\n-\t\t   yyjson_mut_obj_iter_remove(&iter);\n-\t   }\n-   }\n-@endcode\n-\n-If the ordering of the keys is known at compile-time, you can use this method\n-to speed up value lookups:\n-@code\n-   // {\"k1\":1, \"k2\": 3, \"k3\": 3}\n-   yyjson_mut_val *key, *val;\n-   yyjson_mut_obj_iter iter;\n-   yyjson_mut_obj_iter_init(obj, &iter);\n-   yyjson_mut_val *v1 = yyjson_mut_obj_iter_get(&iter, \"k1\");\n-   yyjson_mut_val *v3 = yyjson_mut_obj_iter_get(&iter, \"k3\");\n-@endcode\n-@see yyjson_mut_obj_iter_get() and yyjson_mut_obj_iter_getn()\n-*/\n+ A mutable JSON object iterator.\n+ \n+ @warning You should not modify the object while iterating over it, but you can\n+    use `yyjson_mut_obj_iter_remove()` to remove current value.\n+ \n+ @par Example\n+ @code\n+    yyjson_mut_val *key, *val;\n+    yyjson_mut_obj_iter iter;\n+    yyjson_mut_obj_iter_init(obj, &iter);\n+    while ((key = yyjson_mut_obj_iter_next(&iter))) {\n+        val = yyjson_mut_obj_iter_get_val(key);\n+        your_func(key, val);\n+        if (your_val_is_unused(key, val)) {\n+            yyjson_mut_obj_iter_remove(&iter);\n+        }\n+    }\n+ @endcode\n+ \n+ If the ordering of the keys is known at compile-time, you can use this method\n+ to speed up value lookups:\n+ @code\n+    // {\"k1\":1, \"k2\": 3, \"k3\": 3}\n+    yyjson_mut_val *key, *val;\n+    yyjson_mut_obj_iter iter;\n+    yyjson_mut_obj_iter_init(obj, &iter);\n+    yyjson_mut_val *v1 = yyjson_mut_obj_iter_get(&iter, \"k1\");\n+    yyjson_mut_val *v3 = yyjson_mut_obj_iter_get(&iter, \"k3\");\n+ @endcode\n+ @see `yyjson_mut_obj_iter_get()` and `yyjson_mut_obj_iter_getn()`\n+ */\n typedef struct yyjson_mut_obj_iter yyjson_mut_obj_iter;\n \n /**\n-Initialize an iterator for this object.\n-\n-@param obj The object to be iterated over.\n-   If this parameter is NULL or not an array, `iter` will be set to empty.\n-@param iter The iterator to be initialized.\n-   If this parameter is NULL, the function will fail and return false.\n-@return true if the `iter` has been successfully initialized.\n-\n-@note The iterator does not need to be destroyed.\n-*/\n+ Initialize an iterator for this object.\n+ \n+ @param obj The object to be iterated over.\n+    If this parameter is NULL or not an array, `iter` will be set to empty.\n+ @param iter The iterator to be initialized.\n+    If this parameter is NULL, the function will fail and return false.\n+ @return true if the `iter` has been successfully initialized.\n+ \n+ @note The iterator does not need to be destroyed.\n+ */\n yyjson_api_inline bool yyjson_mut_obj_iter_init(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t   yyjson_mut_obj_iter *iter);\n+    yyjson_mut_obj_iter *iter);\n \n /**\n-Returns whether the iteration has more elements.\n-If `iter` is NULL, this function will return false.\n-*/\n+ Returns whether the iteration has more elements.\n+ If `iter` is NULL, this function will return false.\n+ */\n yyjson_api_inline bool yyjson_mut_obj_iter_has_next(\n-   yyjson_mut_obj_iter *iter);\n+    yyjson_mut_obj_iter *iter);\n \n /**\n-Returns the next key in the iteration, or NULL on end.\n-If `iter` is NULL, this function will return NULL.\n-*/\n+ Returns the next key in the iteration, or NULL on end.\n+ If `iter` is NULL, this function will return NULL.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_iter_next(\n-   yyjson_mut_obj_iter *iter);\n+    yyjson_mut_obj_iter *iter);\n \n /**\n-Returns the value for key inside the iteration.\n-If `iter` is NULL, this function will return NULL.\n-*/\n+ Returns the value for key inside the iteration.\n+ If `iter` is NULL, this function will return NULL.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_iter_get_val(\n-   yyjson_mut_val *key);\n+    yyjson_mut_val *key);\n \n /**\n-Removes and returns current key-value pair in the iteration.\n-If `iter` is NULL, this function will return NULL.\n-*/\n+ Removes and returns current key-value pair in the iteration.\n+ If `iter` is NULL, this function will return NULL.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_iter_remove(\n-   yyjson_mut_obj_iter *iter);\n+    yyjson_mut_obj_iter *iter);\n \n /**\n-Iterates to a specified key and returns the value.\n-\n-This function does the same thing as yyjson_mut_obj_get(), but is much faster\n-if the ordering of the keys is known at compile-time and you are using the same\n-order to look up the values. If the key exists in this object, then the\n-iterator will stop at the next key, otherwise the iterator will not change and\n-NULL is returned.\n-\n-@param iter The object iterator, should not be NULL.\n-@param key The key, should be a UTF-8 string with null-terminator.\n-@return The value to which the specified key is mapped.\n-   NULL if this object contains no mapping for the key or input is invalid.\n-\n-@warning This function takes a linear search time if the key is not nearby.\n-*/\n+ Iterates to a specified key and returns the value.\n+ \n+ This function does the same thing as `yyjson_mut_obj_get()`, but is much faster\n+ if the ordering of the keys is known at compile-time and you are using the same\n+ order to look up the values. If the key exists in this object, then the\n+ iterator will stop at the next key, otherwise the iterator will not change and\n+ NULL is returned.\n+ \n+ @param iter The object iterator, should not be NULL.\n+ @param key The key, should be a UTF-8 string with null-terminator.\n+ @return The value to which the specified key is mapped.\n+    NULL if this object contains no mapping for the key or input is invalid.\n+ \n+ @warning This function takes a linear search time if the key is not nearby.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_iter_get(\n-   yyjson_mut_obj_iter *iter, const char *key);\n+    yyjson_mut_obj_iter *iter, const char *key);\n \n /**\n-Iterates to a specified key and returns the value.\n-\n-This function does the same thing as yyjson_mut_obj_getn(), but is much faster\n-if the ordering of the keys is known at compile-time and you are using the same\n-order to look up the values. If the key exists in this object, then the\n-iterator will stop at the next key, otherwise the iterator will not change and\n-NULL is returned.\n-\n-@param iter The object iterator, should not be NULL.\n-@param key The key, should be a UTF-8 string, null-terminator is not required.\n-@param key_len The the length of `key`, in bytes.\n-@return The value to which the specified key is mapped.\n-   NULL if this object contains no mapping for the key or input is invalid.\n-\n-@warning This function takes a linear search time if the key is not nearby.\n-*/\n+ Iterates to a specified key and returns the value.\n+ \n+ This function does the same thing as `yyjson_mut_obj_getn()` but is much faster\n+ if the ordering of the keys is known at compile-time and you are using the same\n+ order to look up the values. If the key exists in this object, then the\n+ iterator will stop at the next key, otherwise the iterator will not change and\n+ NULL is returned.\n+ \n+ @param iter The object iterator, should not be NULL.\n+ @param key The key, should be a UTF-8 string, null-terminator is not required.\n+ @param key_len The the length of `key`, in bytes.\n+ @return The value to which the specified key is mapped.\n+    NULL if this object contains no mapping for the key or input is invalid.\n+ \n+ @warning This function takes a linear search time if the key is not nearby.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_iter_getn(\n-   yyjson_mut_obj_iter *iter, const char *key, size_t key_len);\n+    yyjson_mut_obj_iter *iter, const char *key, size_t key_len);\n \n /**\n-Macro for iterating over an object.\n-It works like iterator, but with a more intuitive API.\n-\n-@warning You should not modify the object while iterating over it.\n-\n-@par Example\n-@code\n-   size_t idx, max;\n-   yyjson_val *key, *val;\n-   yyjson_obj_foreach(obj, idx, max, key, val) {\n-\t   your_func(key, val);\n-   }\n-@endcode\n-*/\n+ Macro for iterating over an object.\n+ It works like iterator, but with a more intuitive API.\n+ \n+ @warning You should not modify the object while iterating over it.\n+ \n+ @par Example\n+ @code\n+    size_t idx, max;\n+    yyjson_val *key, *val;\n+    yyjson_obj_foreach(obj, idx, max, key, val) {\n+        your_func(key, val);\n+    }\n+ @endcode\n+ */\n #define yyjson_mut_obj_foreach(obj, idx, max, key, val) \\\n-   for ((idx) = 0, \\\n-\t   (max) = yyjson_mut_obj_size(obj), \\\n-\t   (key) = (max) ? ((yyjson_mut_val *)(obj)->uni.ptr)->next->next : NULL, \\\n-\t   (val) = (key) ? (key)->next : NULL; \\\n-\t   (idx) < (max); \\\n-\t   (idx)++, \\\n-\t   (key) = (val)->next, \\\n-\t   (val) = (key)->next)\n+    for ((idx) = 0, \\\n+        (max) = yyjson_mut_obj_size(obj), \\\n+        (key) = (max) ? ((yyjson_mut_val *)(obj)->uni.ptr)->next->next : NULL, \\\n+        (val) = (key) ? (key)->next : NULL; \\\n+        (idx) < (max); \\\n+        (idx)++, \\\n+        (key) = (val)->next, \\\n+        (val) = (key)->next)\n \n \n \n /*==============================================================================\n-* Mutable JSON Object Creation API\n-*============================================================================*/\n+ * Mutable JSON Object Creation API\n+ *============================================================================*/\n \n /** Creates and returns a mutable object, returns NULL on error. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj(yyjson_mut_doc *doc);\n \n /**\n-Creates and returns a mutable object with keys and values, returns NULL on\n-error. The keys and values are not copied. The strings should be a\n-null-terminated UTF-8 string.\n-\n-@warning The input string is not copied, you should keep this string\n-   unmodified for the lifetime of this JSON document.\n-\n-@par Example\n-@code\n-   const char *keys[2] = { \"id\", \"name\" };\n-   const char *vals[2] = { \"01\", \"Harry\" };\n-   yyjson_mut_val *obj = yyjson_mut_obj_with_str(doc, keys, vals, 2);\n-@endcode\n-*/\n+ Creates and returns a mutable object with keys and values, returns NULL on\n+ error. The keys and values are not copied. The strings should be a\n+ null-terminated UTF-8 string.\n+ \n+ @warning The input string is not copied, you should keep this string\n+    unmodified for the lifetime of this JSON document.\n+ \n+ @par Example\n+ @code\n+    const char *keys[2] = { \"id\", \"name\" };\n+    const char *vals[2] = { \"01\", \"Harry\" };\n+    yyjson_mut_val *obj = yyjson_mut_obj_with_str(doc, keys, vals, 2);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_with_str(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t const char **keys,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t const char **vals,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t size_t count);\n+                                                          const char **keys,\n+                                                          const char **vals,\n+                                                          size_t count);\n \n /**\n-Creates and returns a mutable object with key-value pairs and pair count,\n-returns NULL on error. The keys and values are not copied. The strings should\n-be a null-terminated UTF-8 string.\n-\n-@warning The input string is not copied, you should keep this string\n-   unmodified for the lifetime of this JSON document.\n-\n-@par Example\n-@code\n-   const char *kv_pairs[4] = { \"id\", \"01\", \"name\", \"Harry\" };\n-   yyjson_mut_val *obj = yyjson_mut_obj_with_kv(doc, kv_pairs, 2);\n-@endcode\n-*/\n+ Creates and returns a mutable object with key-value pairs and pair count,\n+ returns NULL on error. The keys and values are not copied. The strings should\n+ be a null-terminated UTF-8 string.\n+ \n+ @warning The input string is not copied, you should keep this string\n+    unmodified for the lifetime of this JSON document.\n+ \n+ @par Example\n+ @code\n+    const char *kv_pairs[4] = { \"id\", \"01\", \"name\", \"Harry\" };\n+    yyjson_mut_val *obj = yyjson_mut_obj_with_kv(doc, kv_pairs, 2);\n+ @endcode\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_with_kv(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst char **kv_pairs,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize_t pair_count);\n+                                                         const char **kv_pairs,\n+                                                         size_t pair_count);\n \n \n \n /*==============================================================================\n-* Mutable JSON Object Modification API\n-*============================================================================*/\n+ * Mutable JSON Object Modification API\n+ *============================================================================*/\n \n /**\n-Adds a key-value pair at the end of the object.\n-This function allows duplicated key in one object.\n-@param obj The object to which the new key-value pair is to be added.\n-@param key The key, should be a string which is created by yyjson_mut_str(),\n-   yyjson_mut_strn(), yyjson_mut_strcpy() or yyjson_mut_strncpy().\n-@param val The value to add to the object.\n-@return Whether successful.\n-*/\n+ Adds a key-value pair at the end of the object.\n+ This function allows duplicated key in one object.\n+ @param obj The object to which the new key-value pair is to be added.\n+ @param key The key, should be a string which is created by `yyjson_mut_str()`,\n+    `yyjson_mut_strn()`, `yyjson_mut_strcpy()` or `yyjson_mut_strncpy()`.\n+ @param val The value to add to the object.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_obj_add(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *key,\n-\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *val);\n+                                          yyjson_mut_val *key,\n+                                          yyjson_mut_val *val);\n /**\n-Sets a key-value pair at the end of the object.\n-This function may remove all key-value pairs for the given key before add.\n-@param obj The object to which the new key-value pair is to be added.\n-@param key The key, should be a string which is created by yyjson_mut_str(),\n-   yyjson_mut_strn(), yyjson_mut_strcpy() or yyjson_mut_strncpy().\n-@param val The value to add to the object. If this value is null, the behavior\n-   is same as yyjson_mut_obj_remove().\n-@return Whether successful.\n-*/\n+ Sets a key-value pair at the end of the object.\n+ This function may remove all key-value pairs for the given key before add.\n+ @param obj The object to which the new key-value pair is to be added.\n+ @param key The key, should be a string which is created by `yyjson_mut_str()`,\n+    `yyjson_mut_strn()`, `yyjson_mut_strcpy()` or `yyjson_mut_strncpy()`.\n+ @param val The value to add to the object. If this value is null, the behavior\n+    is same as `yyjson_mut_obj_remove()`.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_obj_put(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *key,\n-\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *val);\n+                                          yyjson_mut_val *key,\n+                                          yyjson_mut_val *val);\n \n /**\n-Inserts a key-value pair to the object at the given position.\n-This function allows duplicated key in one object.\n-@param obj The object to which the new key-value pair is to be added.\n-@param key The key, should be a string which is created by yyjson_mut_str(),\n-   yyjson_mut_strn(), yyjson_mut_strcpy() or yyjson_mut_strncpy().\n-@param val The value to add to the object.\n-@param idx The index to which to insert the new pair.\n-@return Whether successful.\n-*/\n+ Inserts a key-value pair to the object at the given position.\n+ This function allows duplicated key in one object.\n+ @param obj The object to which the new key-value pair is to be added.\n+ @param key The key, should be a string which is created by `yyjson_mut_str()`,\n+    `yyjson_mut_strn()`, `yyjson_mut_strcpy()` or `yyjson_mut_strncpy()`.\n+ @param val The value to add to the object.\n+ @param idx The index to which to insert the new pair.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_obj_insert(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *key,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\tsize_t idx);\n+                                             yyjson_mut_val *key,\n+                                             yyjson_mut_val *val,\n+                                             size_t idx);\n \n /**\n-Removes all key-value pair from the object with given key.\n-@param obj The object from which the key-value pair is to be removed.\n-@param key The key, should be a string value.\n-@return The first matched value, or NULL if no matched value.\n-@warning This function takes a linear search time.\n-*/\n+ Removes all key-value pair from the object with given key.\n+ @param obj The object from which the key-value pair is to be removed.\n+ @param key The key, should be a string value.\n+ @return The first matched value, or NULL if no matched value.\n+ @warning This function takes a linear search time.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_remove(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t   yyjson_mut_val *key);\n+                                                        yyjson_mut_val *key);\n \n /**\n-Removes all key-value pair from the object with given key.\n-@param obj The object from which the key-value pair is to be removed.\n-@param key The key, should be a UTF-8 string with null-terminator.\n-@return The first matched value, or NULL if no matched value.\n-@warning This function takes a linear search time.\n-*/\n+ Removes all key-value pair from the object with given key.\n+ @param obj The object from which the key-value pair is to be removed.\n+ @param key The key, should be a UTF-8 string with null-terminator.\n+ @return The first matched value, or NULL if no matched value.\n+ @warning This function takes a linear search time.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_remove_key(\n-   yyjson_mut_val *obj, const char *key);\n+    yyjson_mut_val *obj, const char *key);\n \n /**\n-Removes all key-value pair from the object with given key.\n-@param obj The object from which the key-value pair is to be removed.\n-@param key The key, should be a UTF-8 string, null-terminator is not required.\n-@param key_len The length of the key.\n-@return The first matched value, or NULL if no matched value.\n-@warning This function takes a linear search time.\n-*/\n+ Removes all key-value pair from the object with given key.\n+ @param obj The object from which the key-value pair is to be removed.\n+ @param key The key, should be a UTF-8 string, null-terminator is not required.\n+ @param key_len The length of the key.\n+ @return The first matched value, or NULL if no matched value.\n+ @warning This function takes a linear search time.\n+ */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_remove_keyn(\n-   yyjson_mut_val *obj, const char *key, size_t key_len);\n+    yyjson_mut_val *obj, const char *key, size_t key_len);\n \n /**\n-Removes all key-value pairs in this object.\n-@param obj The object from which all of the values are to be removed.\n-@return Whether successful.\n-*/\n+ Removes all key-value pairs in this object.\n+ @param obj The object from which all of the values are to be removed.\n+ @return Whether successful.\n+ */\n yyjson_api_inline bool yyjson_mut_obj_clear(yyjson_mut_val *obj);\n \n /**\n-Replaces value from the object with given key.\n-If the key is not exist, or the value is NULL, it will fail.\n-@param obj The object to which the value is to be replaced.\n-@param key The key, should be a string value.\n-@param val The value to replace into the object.\n-@return Whether successful.\n-@warning This function takes a linear search time.\n-*/\n+ Replaces value from the object with given key.\n+ If the key is not exist, or the value is NULL, it will fail.\n+ @param obj The object to which the value is to be replaced.\n+ @param key The key, should be a string value.\n+ @param val The value to replace into the object.\n+ @return Whether successful.\n+ @warning This function takes a linear search time.\n+ */\n yyjson_api_inline bool yyjson_mut_obj_replace(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *key,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *val);\n+                                              yyjson_mut_val *key,\n+                                              yyjson_mut_val *val);\n \n /**\n-Rotates key-value pairs in the object for the given number of times.\n-For example: {\"a\":1,\"b\":2,\"c\":3,\"d\":4} rotate 1 is {\"b\":2,\"c\":3,\"d\":4,\"a\":1}.\n-@param obj The object to be rotated.\n-@param idx Index (or times) to rotate.\n-@return Whether successful.\n-@warning This function takes a linear search time.\n-*/\n+ Rotates key-value pairs in the object for the given number of times.\n+ For example: `{\"a\":1,\"b\":2,\"c\":3,\"d\":4}` rotate 1 is\n+ `{\"b\":2,\"c\":3,\"d\":4,\"a\":1}`.\n+ @param obj The object to be rotated.\n+ @param idx Index (or times) to rotate.\n+ @return Whether successful.\n+ @warning This function takes a linear search time.\n+ */\n yyjson_api_inline bool yyjson_mut_obj_rotate(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\tsize_t idx);\n+                                             size_t idx);\n \n \n \n /*==============================================================================\n-* Mutable JSON Object Modification Convenience API\n-*============================================================================*/\n+ * Mutable JSON Object Modification Convenience API\n+ *============================================================================*/\n \n /** Adds a `null` value at the end of the object.\n-   The `key` should be a null-terminated UTF-8 string.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key string are not copied, you should keep the string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` should be a null-terminated UTF-8 string.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key string are not copied, you should keep the string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_null(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *key);\n+                                               yyjson_mut_val *obj,\n+                                               const char *key);\n \n /** Adds a `true` value at the end of the object.\n-   The `key` should be a null-terminated UTF-8 string.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key string are not copied, you should keep the string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` should be a null-terminated UTF-8 string.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key string are not copied, you should keep the string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_true(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *key);\n+                                               yyjson_mut_val *obj,\n+                                               const char *key);\n \n /** Adds a `false` value at the end of the object.\n-   The `key` should be a null-terminated UTF-8 string.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key string are not copied, you should keep the string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` should be a null-terminated UTF-8 string.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key string are not copied, you should keep the string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_false(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t   yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t   const char *key);\n+                                                yyjson_mut_val *obj,\n+                                                const char *key);\n \n /** Adds a bool value at the end of the object.\n-   The `key` should be a null-terminated UTF-8 string.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key string are not copied, you should keep the string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` should be a null-terminated UTF-8 string.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key string are not copied, you should keep the string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_bool(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *key, bool val);\n+                                               yyjson_mut_val *obj,\n+                                               const char *key, bool val);\n \n /** Adds an unsigned integer value at the end of the object.\n-   The `key` should be a null-terminated UTF-8 string.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key string are not copied, you should keep the string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` should be a null-terminated UTF-8 string.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key string are not copied, you should keep the string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_uint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *key, uint64_t val);\n+                                               yyjson_mut_val *obj,\n+                                               const char *key, uint64_t val);\n \n /** Adds a signed integer value at the end of the object.\n-   The `key` should be a null-terminated UTF-8 string.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key string are not copied, you should keep the string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` should be a null-terminated UTF-8 string.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key string are not copied, you should keep the string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_sint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *key, int64_t val);\n+                                               yyjson_mut_val *obj,\n+                                               const char *key, int64_t val);\n \n /** Adds an int value at the end of the object.\n-   The `key` should be a null-terminated UTF-8 string.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key string are not copied, you should keep the string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` should be a null-terminated UTF-8 string.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key string are not copied, you should keep the string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_int(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t const char *key, int64_t val);\n+                                              yyjson_mut_val *obj,\n+                                              const char *key, int64_t val);\n \n /** Adds a double value at the end of the object.\n-   The `key` should be a null-terminated UTF-8 string.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key string are not copied, you should keep the string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` should be a null-terminated UTF-8 string.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key string are not copied, you should keep the string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_real(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *key, double val);\n+                                               yyjson_mut_val *obj,\n+                                               const char *key, double val);\n \n /** Adds a string value at the end of the object.\n-   The `key` and `val` should be null-terminated UTF-8 strings.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key/value string are not copied, you should keep these strings\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` and `val` should be null-terminated UTF-8 strings.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key/value string are not copied, you should keep these strings\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_str(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t const char *key, const char *val);\n+                                              yyjson_mut_val *obj,\n+                                              const char *key, const char *val);\n \n /** Adds a string value at the end of the object.\n-   The `key` should be a null-terminated UTF-8 string.\n-   The `val` should be a UTF-8 string, null-terminator is not required.\n-   The `len` should be the length of the `val`, in bytes.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key/value string are not copied, you should keep these strings\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` should be a null-terminated UTF-8 string.\n+    The `val` should be a UTF-8 string, null-terminator is not required.\n+    The `len` should be the length of the `val`, in bytes.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key/value string are not copied, you should keep these strings\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_strn(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *key,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *val, size_t len);\n+                                               yyjson_mut_val *obj,\n+                                               const char *key,\n+                                               const char *val, size_t len);\n \n /** Adds a string value at the end of the object.\n-   The `key` and `val` should be null-terminated UTF-8 strings.\n-   The value string is copied.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key string are not copied, you should keep the string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` and `val` should be null-terminated UTF-8 strings.\n+    The value string is copied.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key string are not copied, you should keep the string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_strcpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *key,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *val);\n+                                                 yyjson_mut_val *obj,\n+                                                 const char *key,\n+                                                 const char *val);\n \n /** Adds a string value at the end of the object.\n-   The `key` should be a null-terminated UTF-8 string.\n-   The `val` should be a UTF-8 string, null-terminator is not required.\n-   The `len` should be the length of the `val`, in bytes.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key/value string are not copied, you should keep these strings\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` should be a null-terminated UTF-8 string.\n+    The `val` should be a UTF-8 string, null-terminator is not required.\n+    The `len` should be the length of the `val`, in bytes.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key/value string are not copied, you should keep these strings\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_strncpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *key,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *val, size_t len);\n+                                                  yyjson_mut_val *obj,\n+                                                  const char *key,\n+                                                  const char *val, size_t len);\n \n /** Adds a JSON value at the end of the object.\n-   The `key` should be a null-terminated UTF-8 string.\n-   This function allows duplicated key in one object.\n-\n-   @warning The key string are not copied, you should keep the string\n-\t   unmodified for the lifetime of this JSON document. */\n+    The `key` should be a null-terminated UTF-8 string.\n+    This function allows duplicated key in one object.\n+    \n+    @warning The key string are not copied, you should keep the string\n+        unmodified for the lifetime of this JSON document. */\n yyjson_api_inline bool yyjson_mut_obj_add_val(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t const char *key,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *val);\n+                                              yyjson_mut_val *obj,\n+                                              const char *key,\n+                                              yyjson_mut_val *val);\n \n /** Removes all key-value pairs for the given key.\n-   Returns the first value to which the specified key is mapped or NULL if this\n-   object contains no mapping for the key.\n-   The `key` should be a null-terminated UTF-8 string.\n-\n-   @warning This function takes a linear search time. */\n+    Returns the first value to which the specified key is mapped or NULL if this\n+    object contains no mapping for the key.\n+    The `key` should be a null-terminated UTF-8 string.\n+    \n+    @warning This function takes a linear search time. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_remove_str(\n-   yyjson_mut_val *obj, const char *key);\n+    yyjson_mut_val *obj, const char *key);\n \n /** Removes all key-value pairs for the given key.\n-   Returns the first value to which the specified key is mapped or NULL if this\n-   object contains no mapping for the key.\n-   The `key` should be a UTF-8 string, null-terminator is not required.\n-   The `len` should be the length of the key, in bytes.\n-\n-   @warning This function takes a linear search time. */\n+    Returns the first value to which the specified key is mapped or NULL if this\n+    object contains no mapping for the key.\n+    The `key` should be a UTF-8 string, null-terminator is not required.\n+    The `len` should be the length of the key, in bytes.\n+    \n+    @warning This function takes a linear search time. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_remove_strn(\n-   yyjson_mut_val *obj, const char *key, size_t len);\n+    yyjson_mut_val *obj, const char *key, size_t len);\n+\n+/** Replaces all matching keys with the new key.\n+    Returns true if at least one key was renamed.\n+    The `key` and `new_key` should be a null-terminated UTF-8 string.\n+    The `new_key` is copied and held by doc.\n+    \n+    @warning This function takes a linear search time.\n+    If `new_key` already exists, it will cause duplicate keys.\n+ */\n+yyjson_api_inline bool yyjson_mut_obj_rename_key(yyjson_mut_doc *doc,\n+                                                 yyjson_mut_val *obj,\n+                                                 const char *key,\n+                                                 const char *new_key);\n+\n+/** Replaces all matching keys with the new key.\n+    Returns true if at least one key was renamed.\n+    The `key` and `new_key` should be a UTF-8 string,\n+    null-terminator is not required. The `new_key` is copied and held by doc.\n+    \n+    @warning This function takes a linear search time.\n+    If `new_key` already exists, it will cause duplicate keys.\n+ */\n+yyjson_api_inline bool yyjson_mut_obj_rename_keyn(yyjson_mut_doc *doc,\n+                                                  yyjson_mut_val *obj,\n+                                                  const char *key,\n+                                                  size_t len,\n+                                                  const char *new_key,\n+                                                  size_t new_len);\n \n \n \n /*==============================================================================\n-* JSON Pointer API\n-* https://tools.ietf.org/html/rfc6901\n-*============================================================================*/\n+ * JSON Pointer API\n+ * https://tools.ietf.org/html/rfc6901\n+ *============================================================================*/\n \n /** Get a JSON value with JSON Pointer (RFC 6901).\n-   The `ptr` should be a null-terminated UTF-8 string.\n-\n-   Returns NULL if there's no matched value.\n-   Returns NULL if `val/ptr` is NULL or `val` is not object. */\n+    The `ptr` should be a null-terminated UTF-8 string.\n+    \n+    Returns NULL if there's no matched value.\n+    Returns NULL if `val/ptr` is NULL or `val` is not object. */\n yyjson_api_inline yyjson_val *yyjson_get_pointer(yyjson_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *ptr);\n+                                                 const char *ptr);\n \n /** Get a JSON value with JSON Pointer (RFC 6901).\n-   The `ptr` should be a UTF-8 string, null-terminator is not required.\n-   The `len` should be the length of the `ptr`, in bytes.\n-\n-   Returns NULL if there's no matched value.\n-   Returns NULL if `val/ptr` is NULL or `val` is not object. */\n+    The `ptr` should be a UTF-8 string, null-terminator is not required.\n+    The `len` should be the length of the `ptr`, in bytes.\n+    \n+    Returns NULL if there's no matched value.\n+    Returns NULL if `val/ptr` is NULL or `val` is not object. */\n yyjson_api_inline yyjson_val *yyjson_get_pointern(yyjson_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *ptr,\n-\t\t\t\t\t\t\t\t\t\t\t\t size_t len);\n+                                                  const char *ptr,\n+                                                  size_t len);\n \n /** Get a JSON value with JSON Pointer (RFC 6901).\n-   The `ptr` should be a null-terminated UTF-8 string.\n-\n-   Returns NULL if there's no matched value. */\n+    The `ptr` should be a null-terminated UTF-8 string.\n+    \n+    Returns NULL if there's no matched value. */\n yyjson_api_inline yyjson_val *yyjson_doc_get_pointer(yyjson_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *ptr);\n+                                                     const char *ptr);\n \n /** Get a JSON value with JSON Pointer (RFC 6901).\n-   The `ptr` should be a UTF-8 string, null-terminator is not required.\n-   The `len` should be the length of the `ptr`, in bytes.\n-\n-   Returns NULL if there's no matched value. */\n+    The `ptr` should be a UTF-8 string, null-terminator is not required.\n+    The `len` should be the length of the `ptr`, in bytes.\n+ \n+    Returns NULL if there's no matched value. */\n yyjson_api_inline yyjson_val *yyjson_doc_get_pointern(yyjson_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t const char *ptr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t size_t len);\n+                                                     const char *ptr,\n+                                                      size_t len);\n \n /** Get a JSON value with JSON Pointer (RFC 6901).\n-   The `ptr` should be a null-terminated UTF-8 string.\n-\n-   Returns NULL if there's no matched value. */\n+    The `ptr` should be a null-terminated UTF-8 string.\n+    \n+    Returns NULL if there's no matched value. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_get_pointer(yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *ptr);\n+                                                         const char *ptr);\n \n /** Get a JSON value with JSON Pointer (RFC 6901).\n-   The `ptr` should be a UTF-8 string, null-terminator is not required.\n-   The `len` should be the length of the `ptr`, in bytes.\n-\n-   Returns NULL if there's no matched value. */\n+    The `ptr` should be a UTF-8 string, null-terminator is not required.\n+    The `len` should be the length of the `ptr`, in bytes.\n+    \n+    Returns NULL if there's no matched value. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_get_pointern(yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t const char *ptr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t size_t len);\n+                                                          const char *ptr,\n+                                                          size_t len);\n \n /** Get a JSON value with JSON Pointer (RFC 6901).\n-   The `ptr` should be a null-terminated UTF-8 string.\n-\n-   Returns NULL if there's no matched value. */\n+    The `ptr` should be a null-terminated UTF-8 string.\n+    \n+    Returns NULL if there's no matched value. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_doc_get_pointer(\n-   yyjson_mut_doc *doc, const char *ptr);\n+    yyjson_mut_doc *doc, const char *ptr);\n \n /** Get a JSON value with JSON Pointer (RFC 6901).\n-   The `ptr` should be a UTF-8 string, null-terminator is not required.\n-   The `len` should be the length of the `ptr`, in bytes.\n-\n-   Returns NULL if there's no matched value. */\n+    The `ptr` should be a UTF-8 string, null-terminator is not required.\n+    The `len` should be the length of the `ptr`, in bytes.\n+    \n+    Returns NULL if there's no matched value. */\n yyjson_api_inline yyjson_mut_val *yyjson_mut_doc_get_pointern(\n-   yyjson_mut_doc *doc, const char *ptr, size_t len);\n+    yyjson_mut_doc *doc, const char *ptr, size_t len);\n \n \n \n /*==============================================================================\n-* JSON Merge-Patch API\n-* https://tools.ietf.org/html/rfc7386\n-*============================================================================*/\n+ * JSON Merge-Patch API\n+ * https://tools.ietf.org/html/rfc7386\n+ *============================================================================*/\n \n /** Creates and returns a merge-patched JSON value (RFC 7386).\n-   The memory of the returned value is allocated by the `doc`.\n-   Returns NULL if the patch could not be applied.\n-\n-   @warning This function is recursive and may cause a stack overflow if the\n-\t   object level is too deep. */\n+    The memory of the returned value is allocated by the `doc`.\n+    Returns NULL if the patch could not be applied.\n+    \n+    @warning This function is recursive and may cause a stack overflow if the\n+        object level is too deep. */\n yyjson_api yyjson_mut_val *yyjson_merge_patch(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_val *orig,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_val *patch);\n+                                              yyjson_val *orig,\n+                                              yyjson_val *patch);\n \n /** Creates and returns a merge-patched JSON value (RFC 7386).\n-   The memory of the returned value is allocated by the `doc`.\n-   Returns NULL if the patch could not be applied.\n-\n-   @warning This function is recursive and may cause a stack overflow if the\n-\t   object level is too deep. */\n+    The memory of the returned value is allocated by the `doc`.\n+    Returns NULL if the patch could not be applied.\n+    \n+    @warning This function is recursive and may cause a stack overflow if the\n+        object level is too deep. */\n yyjson_api yyjson_mut_val *yyjson_mut_merge_patch(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *orig,\n-\t\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *patch);\n+                                                  yyjson_mut_val *orig,\n+                                                  yyjson_mut_val *patch);\n \n \n \n /*==============================================================================\n-* JSON Structure (Implementation)\n-*============================================================================*/\n+ * JSON Structure (Implementation)\n+ *============================================================================*/\n \n /** Payload of a JSON value (8 bytes). */\n typedef union yyjson_val_uni {\n-   uint64_t    u64;\n-   int64_t     i64;\n-   double      f64;\n-   const char *str;\n-   void       *ptr;\n-   size_t      ofs;\n+    uint64_t    u64;\n+    int64_t     i64;\n+    double      f64;\n+    const char *str;\n+    void       *ptr;\n+    size_t      ofs;\n } yyjson_val_uni;\n \n /**\n-Immutable JSON value, 16 bytes.\n-*/\n+ Immutable JSON value, 16 bytes.\n+ */\n struct yyjson_val {\n-   uint64_t tag; /**< type, subtype and length */\n-   yyjson_val_uni uni; /**< payload */\n+    uint64_t tag; /**< type, subtype and length */\n+    yyjson_val_uni uni; /**< payload */\n };\n \n struct yyjson_doc {\n-   /** Root value of the document (nonnull). */\n-   yyjson_val *root;\n-   /** Allocator used by document (nonnull). */\n-   yyjson_alc alc;\n-   /** The total number of bytes read when parsing JSON (nonzero). */\n-   size_t dat_read;\n-   /** The total number of value read when parsing JSON (nonzero). */\n-   size_t val_read;\n-   /** The string pool used by JSON values (nullable). */\n-   char *str_pool;\n+    /** Root value of the document (nonnull). */\n+    yyjson_val *root;\n+    /** Allocator used by document (nonnull). */\n+    yyjson_alc alc;\n+    /** The total number of bytes read when parsing JSON (nonzero). */\n+    size_t dat_read;\n+    /** The total number of value read when parsing JSON (nonzero). */\n+    size_t val_read;\n+    /** The string pool used by JSON values (nullable). */\n+    char *str_pool;\n };\n \n \n \n /*==============================================================================\n-* Unsafe JSON Value API (Implementation)\n-*============================================================================*/\n+ * Unsafe JSON Value API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline yyjson_type unsafe_yyjson_get_type(void *val) {\n-   uint8_t tag = (uint8_t)((yyjson_val *)val)->tag;\n-   return (yyjson_type)(tag & YYJSON_TYPE_MASK);\n+    uint8_t tag = (uint8_t)((yyjson_val *)val)->tag;\n+    return (yyjson_type)(tag & YYJSON_TYPE_MASK);\n }\n \n yyjson_api_inline yyjson_subtype unsafe_yyjson_get_subtype(void *val) {\n-   uint8_t tag = (uint8_t)((yyjson_val *)val)->tag;\n-   return (yyjson_subtype)(tag & YYJSON_SUBTYPE_MASK);\n+    uint8_t tag = (uint8_t)((yyjson_val *)val)->tag;\n+    return (yyjson_subtype)(tag & YYJSON_SUBTYPE_MASK);\n }\n \n yyjson_api_inline uint8_t unsafe_yyjson_get_tag(void *val) {\n-   uint8_t tag = (uint8_t)((yyjson_val *)val)->tag;\n-   return (uint8_t)(tag & YYJSON_TAG_MASK);\n+    uint8_t tag = (uint8_t)((yyjson_val *)val)->tag;\n+    return (uint8_t)(tag & YYJSON_TAG_MASK);\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_raw(void *val) {\n-   return unsafe_yyjson_get_type(val) == YYJSON_TYPE_RAW;\n+    return unsafe_yyjson_get_type(val) == YYJSON_TYPE_RAW;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_null(void *val) {\n-   return unsafe_yyjson_get_type(val) == YYJSON_TYPE_NULL;\n+    return unsafe_yyjson_get_type(val) == YYJSON_TYPE_NULL;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_bool(void *val) {\n-   return unsafe_yyjson_get_type(val) == YYJSON_TYPE_BOOL;\n+    return unsafe_yyjson_get_type(val) == YYJSON_TYPE_BOOL;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_num(void *val) {\n-   return unsafe_yyjson_get_type(val) == YYJSON_TYPE_NUM;\n+    return unsafe_yyjson_get_type(val) == YYJSON_TYPE_NUM;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_str(void *val) {\n-   return unsafe_yyjson_get_type(val) == YYJSON_TYPE_STR;\n+    return unsafe_yyjson_get_type(val) == YYJSON_TYPE_STR;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_arr(void *val) {\n-   return unsafe_yyjson_get_type(val) == YYJSON_TYPE_ARR;\n+    return unsafe_yyjson_get_type(val) == YYJSON_TYPE_ARR;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_obj(void *val) {\n-   return unsafe_yyjson_get_type(val) == YYJSON_TYPE_OBJ;\n+    return unsafe_yyjson_get_type(val) == YYJSON_TYPE_OBJ;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_ctn(void *val) {\n-   uint8_t mask = YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ;\n-   return (unsafe_yyjson_get_tag(val) & mask) == mask;\n+    uint8_t mask = YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ;\n+    return (unsafe_yyjson_get_tag(val) & mask) == mask;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_uint(void *val) {\n-   const uint8_t patt = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n-   return unsafe_yyjson_get_tag(val) == patt;\n+    const uint8_t patt = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n+    return unsafe_yyjson_get_tag(val) == patt;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_sint(void *val) {\n-   const uint8_t patt = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n-   return unsafe_yyjson_get_tag(val) == patt;\n+    const uint8_t patt = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n+    return unsafe_yyjson_get_tag(val) == patt;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_int(void *val) {\n-   const uint8_t mask = YYJSON_TAG_MASK & (~YYJSON_SUBTYPE_SINT);\n-   const uint8_t patt = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n-   return (unsafe_yyjson_get_tag(val) & mask) == patt;\n+    const uint8_t mask = YYJSON_TAG_MASK & (~YYJSON_SUBTYPE_SINT);\n+    const uint8_t patt = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n+    return (unsafe_yyjson_get_tag(val) & mask) == patt;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_real(void *val) {\n-   const uint8_t patt = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n-   return unsafe_yyjson_get_tag(val) == patt;\n+    const uint8_t patt = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n+    return unsafe_yyjson_get_tag(val) == patt;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_true(void *val) {\n-   const uint8_t patt = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_TRUE;\n-   return unsafe_yyjson_get_tag(val) == patt;\n+    const uint8_t patt = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_TRUE;\n+    return unsafe_yyjson_get_tag(val) == patt;\n }\n \n yyjson_api_inline bool unsafe_yyjson_is_false(void *val) {\n-   const uint8_t patt = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_FALSE;\n-   return unsafe_yyjson_get_tag(val) == patt;\n+    const uint8_t patt = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_FALSE;\n+    return unsafe_yyjson_get_tag(val) == patt;\n }\n \n yyjson_api_inline bool unsafe_yyjson_arr_is_flat(yyjson_val *val) {\n-   size_t ofs = val->uni.ofs;\n-   size_t len = (size_t)(val->tag >> YYJSON_TAG_BIT);\n-   return len * sizeof(yyjson_val) + sizeof(yyjson_val) == ofs;\n+    size_t ofs = val->uni.ofs;\n+    size_t len = (size_t)(val->tag >> YYJSON_TAG_BIT);\n+    return len * sizeof(yyjson_val) + sizeof(yyjson_val) == ofs;\n }\n \n yyjson_api_inline const char *unsafe_yyjson_get_raw(void *val) {\n-   return ((yyjson_val *)val)->uni.str;\n+    return ((yyjson_val *)val)->uni.str;\n }\n \n yyjson_api_inline bool unsafe_yyjson_get_bool(void *val) {\n-   uint8_t tag = unsafe_yyjson_get_tag(val);\n-   return (bool)((tag & YYJSON_SUBTYPE_MASK) >> YYJSON_TYPE_BIT);\n+    uint8_t tag = unsafe_yyjson_get_tag(val);\n+    return (bool)((tag & YYJSON_SUBTYPE_MASK) >> YYJSON_TYPE_BIT);\n }\n \n yyjson_api_inline uint64_t unsafe_yyjson_get_uint(void *val) {\n-   return ((yyjson_val *)val)->uni.u64;\n+    return ((yyjson_val *)val)->uni.u64;\n }\n \n yyjson_api_inline int64_t unsafe_yyjson_get_sint(void *val) {\n-   return ((yyjson_val *)val)->uni.i64;\n+    return ((yyjson_val *)val)->uni.i64;\n }\n \n yyjson_api_inline int unsafe_yyjson_get_int(void *val) {\n-   return (int)((yyjson_val *)val)->uni.i64;\n+    return (int)((yyjson_val *)val)->uni.i64;\n }\n \n yyjson_api_inline double unsafe_yyjson_get_real(void *val) {\n-   return ((yyjson_val *)val)->uni.f64;\n+    return ((yyjson_val *)val)->uni.f64;\n }\n \n yyjson_api_inline const char *unsafe_yyjson_get_str(void *val) {\n-   return ((yyjson_val *)val)->uni.str;\n+    return ((yyjson_val *)val)->uni.str;\n }\n \n yyjson_api_inline size_t unsafe_yyjson_get_len(void *val) {\n-   return (size_t)(((yyjson_val *)val)->tag >> YYJSON_TAG_BIT);\n-}\n-\n-yyjson_api_inline void unsafe_yyjson_set_len(void *val, size_t len) {\n-   uint64_t tag = ((yyjson_val *)val)->tag & YYJSON_TAG_MASK;\n-   tag |= (uint64_t)len << YYJSON_TAG_BIT;\n-   ((yyjson_val *)val)->tag = tag;\n+    return (size_t)(((yyjson_val *)val)->tag >> YYJSON_TAG_BIT);\n }\n \n yyjson_api_inline yyjson_val *unsafe_yyjson_get_first(yyjson_val *ctn) {\n-   return ctn + 1;\n+    return ctn + 1;\n }\n \n yyjson_api_inline yyjson_val *unsafe_yyjson_get_next(yyjson_val *val) {\n-   bool is_ctn = unsafe_yyjson_is_ctn(val);\n-   size_t ctn_ofs = val->uni.ofs;\n-   size_t ofs = (is_ctn ? ctn_ofs : sizeof(yyjson_val));\n-   return (yyjson_val *)(void *)((uint8_t *)val + ofs);\n+    bool is_ctn = unsafe_yyjson_is_ctn(val);\n+    size_t ctn_ofs = val->uni.ofs;\n+    size_t ofs = (is_ctn ? ctn_ofs : sizeof(yyjson_val));\n+    return (yyjson_val *)(void *)((uint8_t *)val + ofs);\n }\n \n yyjson_api_inline bool unsafe_yyjson_equals_strn(void *val, const char *str,\n-\t\t\t\t\t\t\t\t\t\t\t\tsize_t len) {\n-   uint64_t tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-   return ((yyjson_val *)val)->tag == tag &&\n-\t\t  duckdb::FastMemcmp(((yyjson_val *)val)->uni.str, str, len) == 0;\n+                                                 size_t len) {\n+    uint64_t tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+    return ((yyjson_val *)val)->tag == tag &&\n+    duckdb::FastMemcmp(((yyjson_val *)val)->uni.str, str, len) == 0;\n }\n \n yyjson_api_inline bool unsafe_yyjson_equals_str(void *val, const char *str) {\n-   return unsafe_yyjson_equals_strn(val, str, strlen(str));\n+    return unsafe_yyjson_equals_strn(val, str, strlen(str));\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_type(void *val, yyjson_type type,\n+                                              yyjson_subtype subtype) {\n+    uint8_t tag = (type | subtype);\n+    uint64_t new_tag = ((yyjson_val *)val)->tag;\n+    new_tag = (new_tag & (~(uint64_t)YYJSON_TAG_MASK)) | (uint64_t)tag;\n+    ((yyjson_val *)val)->tag = new_tag;\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_tag(void *val, uint8_t tag) {\n+    uint64_t new_tag = ((yyjson_val *)val)->tag;\n+    new_tag = (new_tag & (~(uint64_t)YYJSON_TAG_MASK)) | (uint64_t)tag;\n+    ((yyjson_val *)val)->tag = new_tag;\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_len(void *val, size_t len) {\n+    uint64_t tag = ((yyjson_val *)val)->tag & YYJSON_TAG_MASK;\n+    tag |= (uint64_t)len << YYJSON_TAG_BIT;\n+    ((yyjson_val *)val)->tag = tag;\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_raw(void *val, const char *raw,\n+                                             size_t len) {\n+    unsafe_yyjson_set_type(val, YYJSON_TYPE_RAW, YYJSON_SUBTYPE_NONE);\n+    unsafe_yyjson_set_len(val, len);\n+    ((yyjson_val *)val)->uni.str = raw;\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_null(void *val) {\n+    unsafe_yyjson_set_type(val, YYJSON_TYPE_NULL, YYJSON_SUBTYPE_NONE);\n+    unsafe_yyjson_set_len(val, 0);\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_bool(void *val, bool num) {\n+    yyjson_subtype subtype = num ? YYJSON_SUBTYPE_TRUE : YYJSON_SUBTYPE_FALSE;\n+    unsafe_yyjson_set_type(val, YYJSON_TYPE_BOOL, subtype);\n+    unsafe_yyjson_set_len(val, 0);\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_uint(void *val, uint64_t num) {\n+    unsafe_yyjson_set_type(val, YYJSON_TYPE_NUM, YYJSON_SUBTYPE_UINT);\n+    unsafe_yyjson_set_len(val, 0);\n+    ((yyjson_val *)val)->uni.u64 = num;\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_sint(void *val, int64_t num) {\n+    unsafe_yyjson_set_type(val, YYJSON_TYPE_NUM, YYJSON_SUBTYPE_SINT);\n+    unsafe_yyjson_set_len(val, 0);\n+    ((yyjson_val *)val)->uni.i64 = num;\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_real(void *val, double num) {\n+    unsafe_yyjson_set_type(val, YYJSON_TYPE_NUM, YYJSON_SUBTYPE_REAL);\n+    unsafe_yyjson_set_len(val, 0);\n+    ((yyjson_val *)val)->uni.f64 = num;\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_str(void *val, const char *str) {\n+    unsafe_yyjson_set_type(val, YYJSON_TYPE_STR, YYJSON_SUBTYPE_NONE);\n+    unsafe_yyjson_set_len(val, strlen(str));\n+    ((yyjson_val *)val)->uni.str = str;\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_strn(void *val, const char *str,\n+                                             size_t len) {\n+    unsafe_yyjson_set_type(val, YYJSON_TYPE_STR, YYJSON_SUBTYPE_NONE);\n+    unsafe_yyjson_set_len(val, len);\n+    ((yyjson_val *)val)->uni.str = str;\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_arr(void *val, size_t size) {\n+    unsafe_yyjson_set_type(val, YYJSON_TYPE_ARR, YYJSON_SUBTYPE_NONE);\n+    unsafe_yyjson_set_len(val, size);\n+}\n+\n+yyjson_api_inline void unsafe_yyjson_set_obj(void *val, size_t size) {\n+    unsafe_yyjson_set_type(val, YYJSON_TYPE_OBJ, YYJSON_SUBTYPE_NONE);\n+    unsafe_yyjson_set_len(val, size);\n }\n \n \n \n /*==============================================================================\n-* JSON Document API (Implementation)\n-*============================================================================*/\n+ * JSON Document API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline yyjson_val *yyjson_doc_get_root(yyjson_doc *doc) {\n-   return doc ? doc->root : NULL;\n+    return doc ? doc->root : NULL;\n }\n \n yyjson_api_inline size_t yyjson_doc_get_read_size(yyjson_doc *doc) {\n-   return doc ? doc->dat_read : 0;\n+    return doc ? doc->dat_read : 0;\n }\n \n yyjson_api_inline size_t yyjson_doc_get_val_count(yyjson_doc *doc) {\n-   return doc ? doc->val_read : 0;\n+    return doc ? doc->val_read : 0;\n }\n \n yyjson_api_inline void yyjson_doc_free(yyjson_doc *doc) {\n-   if (doc) {\n-\t   yyjson_alc alc = doc->alc;\n-\t   if (doc->str_pool) alc.free(alc.ctx, doc->str_pool);\n-\t   alc.free(alc.ctx, doc);\n-   }\n+    if (doc) {\n+        yyjson_alc alc = doc->alc;\n+        if (doc->str_pool) alc.free(alc.ctx, doc->str_pool);\n+        alc.free(alc.ctx, doc);\n+    }\n }\n \n \n \n /*==============================================================================\n-* JSON Value Type API (Implementation)\n-*============================================================================*/\n+ * JSON Value Type API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline bool yyjson_is_raw(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_raw(val) : false;\n+    return val ? unsafe_yyjson_is_raw(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_null(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_null(val) : false;\n+    return val ? unsafe_yyjson_is_null(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_true(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_true(val) : false;\n+    return val ? unsafe_yyjson_is_true(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_false(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_false(val) : false;\n+    return val ? unsafe_yyjson_is_false(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_bool(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_bool(val) : false;\n+    return val ? unsafe_yyjson_is_bool(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_uint(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_uint(val) : false;\n+    return val ? unsafe_yyjson_is_uint(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_sint(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_sint(val) : false;\n+    return val ? unsafe_yyjson_is_sint(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_int(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_int(val) : false;\n+    return val ? unsafe_yyjson_is_int(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_real(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_real(val) : false;\n+    return val ? unsafe_yyjson_is_real(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_num(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_num(val) : false;\n+    return val ? unsafe_yyjson_is_num(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_str(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_str(val) : false;\n+    return val ? unsafe_yyjson_is_str(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_arr(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_arr(val) : false;\n+    return val ? unsafe_yyjson_is_arr(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_obj(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_obj(val) : false;\n+    return val ? unsafe_yyjson_is_obj(val) : false;\n }\n \n yyjson_api_inline bool yyjson_is_ctn(yyjson_val *val) {\n-   return val ? unsafe_yyjson_is_ctn(val) : false;\n+    return val ? unsafe_yyjson_is_ctn(val) : false;\n }\n \n \n \n /*==============================================================================\n-* JSON Value Content API (Implementation)\n-*============================================================================*/\n+ * JSON Value Content API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline yyjson_type yyjson_get_type(yyjson_val *val) {\n-   return val ? unsafe_yyjson_get_type(val) : YYJSON_TYPE_NONE;\n+    return val ? unsafe_yyjson_get_type(val) : YYJSON_TYPE_NONE;\n }\n \n yyjson_api_inline yyjson_subtype yyjson_get_subtype(yyjson_val *val) {\n-   return val ? unsafe_yyjson_get_subtype(val) : YYJSON_SUBTYPE_NONE;\n+    return val ? unsafe_yyjson_get_subtype(val) : YYJSON_SUBTYPE_NONE;\n }\n \n yyjson_api_inline uint8_t yyjson_get_tag(yyjson_val *val) {\n-   return val ? unsafe_yyjson_get_tag(val) : 0;\n+    return val ? unsafe_yyjson_get_tag(val) : 0;\n }\n \n yyjson_api_inline const char *yyjson_get_type_desc(yyjson_val *val) {\n-   switch (yyjson_get_tag(val)) {\n-   case YYJSON_TYPE_RAW  | YYJSON_SUBTYPE_NONE:  return \"raw\";\n-   case YYJSON_TYPE_NULL | YYJSON_SUBTYPE_NONE:  return \"null\";\n-   case YYJSON_TYPE_STR  | YYJSON_SUBTYPE_NONE:  return \"string\";\n-   case YYJSON_TYPE_ARR  | YYJSON_SUBTYPE_NONE:  return \"array\";\n-   case YYJSON_TYPE_OBJ  | YYJSON_SUBTYPE_NONE:  return \"object\";\n-   case YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_TRUE:  return \"true\";\n-   case YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_FALSE: return \"false\";\n-   case YYJSON_TYPE_NUM  | YYJSON_SUBTYPE_UINT:  return \"uint\";\n-   case YYJSON_TYPE_NUM  | YYJSON_SUBTYPE_SINT:  return \"sint\";\n-   case YYJSON_TYPE_NUM  | YYJSON_SUBTYPE_REAL:  return \"real\";\n-   default:                                      return \"unknown\";\n-   }\n+    switch (yyjson_get_tag(val)) {\n+        case YYJSON_TYPE_RAW  | YYJSON_SUBTYPE_NONE:  return \"raw\";\n+        case YYJSON_TYPE_NULL | YYJSON_SUBTYPE_NONE:  return \"null\";\n+        case YYJSON_TYPE_STR  | YYJSON_SUBTYPE_NONE:  return \"string\";\n+        case YYJSON_TYPE_ARR  | YYJSON_SUBTYPE_NONE:  return \"array\";\n+        case YYJSON_TYPE_OBJ  | YYJSON_SUBTYPE_NONE:  return \"object\";\n+        case YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_TRUE:  return \"true\";\n+        case YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_FALSE: return \"false\";\n+        case YYJSON_TYPE_NUM  | YYJSON_SUBTYPE_UINT:  return \"uint\";\n+        case YYJSON_TYPE_NUM  | YYJSON_SUBTYPE_SINT:  return \"sint\";\n+        case YYJSON_TYPE_NUM  | YYJSON_SUBTYPE_REAL:  return \"real\";\n+        default:                                      return \"unknown\";\n+    }\n }\n \n yyjson_api_inline const char *yyjson_get_raw(yyjson_val *val) {\n-   return yyjson_is_raw(val) ? unsafe_yyjson_get_raw(val) : NULL;\n+    return yyjson_is_raw(val) ? unsafe_yyjson_get_raw(val) : NULL;\n }\n \n yyjson_api_inline bool yyjson_get_bool(yyjson_val *val) {\n-   return yyjson_is_bool(val) ? unsafe_yyjson_get_bool(val) : false;\n+    return yyjson_is_bool(val) ? unsafe_yyjson_get_bool(val) : false;\n }\n \n yyjson_api_inline uint64_t yyjson_get_uint(yyjson_val *val) {\n-   return yyjson_is_int(val) ? unsafe_yyjson_get_uint(val) : 0;\n+    return yyjson_is_int(val) ? unsafe_yyjson_get_uint(val) : 0;\n }\n \n yyjson_api_inline int64_t yyjson_get_sint(yyjson_val *val) {\n-   return yyjson_is_int(val) ? unsafe_yyjson_get_sint(val) : 0;\n+    return yyjson_is_int(val) ? unsafe_yyjson_get_sint(val) : 0;\n }\n \n yyjson_api_inline int yyjson_get_int(yyjson_val *val) {\n-   return yyjson_is_int(val) ? unsafe_yyjson_get_int(val) : 0;\n+    return yyjson_is_int(val) ? unsafe_yyjson_get_int(val) : 0;\n }\n \n yyjson_api_inline double yyjson_get_real(yyjson_val *val) {\n-   return yyjson_is_real(val) ? unsafe_yyjson_get_real(val) : 0.0;\n+    return yyjson_is_real(val) ? unsafe_yyjson_get_real(val) : 0.0;\n }\n \n yyjson_api_inline const char *yyjson_get_str(yyjson_val *val) {\n-   return yyjson_is_str(val) ? unsafe_yyjson_get_str(val) : NULL;\n+    return yyjson_is_str(val) ? unsafe_yyjson_get_str(val) : NULL;\n }\n \n yyjson_api_inline size_t yyjson_get_len(yyjson_val *val) {\n-   return val ? unsafe_yyjson_get_len(val) : 0;\n+    return val ? unsafe_yyjson_get_len(val) : 0;\n }\n \n yyjson_api_inline bool yyjson_equals_str(yyjson_val *val, const char *str) {\n-   if (yyjson_likely(val && str)) {\n-\t   return unsafe_yyjson_equals_str(val, str);\n-   }\n-   return false;\n+    if (yyjson_likely(val && str)) {\n+        return unsafe_yyjson_equals_str(val, str);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_equals_strn(yyjson_val *val, const char *str,\n-\t\t\t\t\t\t\t\t\t\t size_t len) {\n-   if (yyjson_likely(val && str)) {\n-\t   return unsafe_yyjson_equals_strn(val, str, len);\n-   }\n-   return false;\n+                                          size_t len) {\n+    if (yyjson_likely(val && str)) {\n+        return unsafe_yyjson_equals_strn(val, str, len);\n+    }\n+    return false;\n }\n \n yyjson_api bool unsafe_yyjson_equals(yyjson_val *lhs, yyjson_val *rhs);\n \n yyjson_api_inline bool yyjson_equals(yyjson_val *lhs, yyjson_val *rhs) {\n-   if (yyjson_unlikely(!lhs || !rhs))\n-\t   return false;\n+    if (yyjson_unlikely(!lhs || !rhs)) return false;\n+    return unsafe_yyjson_equals(lhs, rhs);\n+}\n \n-   return unsafe_yyjson_equals(lhs, rhs);\n+yyjson_api_inline bool yyjson_set_raw(yyjson_val *val,\n+                                      const char *raw, size_t len) {\n+    if (yyjson_unlikely(!val || unsafe_yyjson_is_ctn(val))) return false;\n+    unsafe_yyjson_set_raw(val, raw, len);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_set_null(yyjson_val *val) {\n+    if (yyjson_unlikely(!val || unsafe_yyjson_is_ctn(val))) return false;\n+    unsafe_yyjson_set_null(val);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_set_bool(yyjson_val *val, bool num) {\n+    if (yyjson_unlikely(!val || unsafe_yyjson_is_ctn(val))) return false;\n+    unsafe_yyjson_set_bool(val, num);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_set_uint(yyjson_val *val, uint64_t num) {\n+    if (yyjson_unlikely(!val || unsafe_yyjson_is_ctn(val))) return false;\n+    unsafe_yyjson_set_uint(val, num);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_set_sint(yyjson_val *val, int64_t num) {\n+    if (yyjson_unlikely(!val || unsafe_yyjson_is_ctn(val))) return false;\n+    unsafe_yyjson_set_sint(val, num);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_set_int(yyjson_val *val, int num) {\n+    if (yyjson_unlikely(!val || unsafe_yyjson_is_ctn(val))) return false;\n+    unsafe_yyjson_set_sint(val, (int64_t)num);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_set_real(yyjson_val *val, double num) {\n+    if (yyjson_unlikely(!val || unsafe_yyjson_is_ctn(val))) return false;\n+    unsafe_yyjson_set_real(val, num);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_set_str(yyjson_val *val, const char *str) {\n+    if (yyjson_unlikely(!val || unsafe_yyjson_is_ctn(val))) return false;\n+    if (yyjson_unlikely(!str)) return false;\n+    unsafe_yyjson_set_str(val, str);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_set_strn(yyjson_val *val,\n+                                       const char *str, size_t len) {\n+    if (yyjson_unlikely(!val || unsafe_yyjson_is_ctn(val))) return false;\n+    if (yyjson_unlikely(!str)) return false;\n+    unsafe_yyjson_set_strn(val, str, len);\n+    return true;\n }\n \n \n \n /*==============================================================================\n-* JSON Array API (Implementation)\n-*============================================================================*/\n+ * JSON Array API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline size_t yyjson_arr_size(yyjson_val *arr) {\n-   return yyjson_is_arr(arr) ? unsafe_yyjson_get_len(arr) : 0;\n+    return yyjson_is_arr(arr) ? unsafe_yyjson_get_len(arr) : 0;\n }\n \n yyjson_api_inline yyjson_val *yyjson_arr_get(yyjson_val *arr, size_t idx) {\n-   if (yyjson_likely(yyjson_is_arr(arr))) {\n-\t   if (yyjson_likely(unsafe_yyjson_get_len(arr) > idx)) {\n-\t\t   yyjson_val *val = unsafe_yyjson_get_first(arr);\n-\t\t   if (unsafe_yyjson_arr_is_flat(arr)) {\n-\t\t\t   return val + idx;\n-\t\t   } else {\n-\t\t\t   while (idx-- > 0) val = unsafe_yyjson_get_next(val);\n-\t\t\t   return val;\n-\t\t   }\n-\t   }\n-   }\n-   return NULL;\n+    if (yyjson_likely(yyjson_is_arr(arr))) {\n+        if (yyjson_likely(unsafe_yyjson_get_len(arr) > idx)) {\n+            yyjson_val *val = unsafe_yyjson_get_first(arr);\n+            if (unsafe_yyjson_arr_is_flat(arr)) {\n+                return val + idx;\n+            } else {\n+                while (idx-- > 0) val = unsafe_yyjson_get_next(val);\n+                return val;\n+            }\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_val *yyjson_arr_get_first(yyjson_val *arr) {\n-   if (yyjson_likely(yyjson_is_arr(arr))) {\n-\t   if (yyjson_likely(unsafe_yyjson_get_len(arr) > 0)) {\n-\t\t   return unsafe_yyjson_get_first(arr);\n-\t   }\n-   }\n-   return NULL;\n+    if (yyjson_likely(yyjson_is_arr(arr))) {\n+        if (yyjson_likely(unsafe_yyjson_get_len(arr) > 0)) {\n+            return unsafe_yyjson_get_first(arr);\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_val *yyjson_arr_get_last(yyjson_val *arr) {\n-   if (yyjson_likely(yyjson_is_arr(arr))) {\n-\t   size_t len = unsafe_yyjson_get_len(arr);\n-\t   if (yyjson_likely(len > 0)) {\n-\t\t   yyjson_val *val = unsafe_yyjson_get_first(arr);\n-\t\t   if (unsafe_yyjson_arr_is_flat(arr)) {\n-\t\t\t   return val + (len - 1);\n-\t\t   } else {\n-\t\t\t   while (len-- > 1) val = unsafe_yyjson_get_next(val);\n-\t\t\t   return val;\n-\t\t   }\n-\t   }\n-   }\n-   return NULL;\n+    if (yyjson_likely(yyjson_is_arr(arr))) {\n+        size_t len = unsafe_yyjson_get_len(arr);\n+        if (yyjson_likely(len > 0)) {\n+            yyjson_val *val = unsafe_yyjson_get_first(arr);\n+            if (unsafe_yyjson_arr_is_flat(arr)) {\n+                return val + (len - 1);\n+            } else {\n+                while (len-- > 1) val = unsafe_yyjson_get_next(val);\n+                return val;\n+            }\n+        }\n+    }\n+    return NULL;\n }\n \n \n \n /*==============================================================================\n-* JSON Array Iterator API (Implementation)\n-*============================================================================*/\n+ * JSON Array Iterator API (Implementation)\n+ *============================================================================*/\n \n struct yyjson_arr_iter {\n-   size_t idx; /**< current index, from 0 */\n-   size_t max; /**< maximum index, idx < max */\n-   yyjson_val *cur; /**< current value */\n+    size_t idx; /**< current index, from 0 */\n+    size_t max; /**< maximum index, idx < max */\n+    yyjson_val *cur; /**< current value */\n };\n \n yyjson_api_inline bool yyjson_arr_iter_init(yyjson_val *arr,\n-\t\t\t\t\t\t\t\t\t\t   yyjson_arr_iter *iter) {\n-   if (yyjson_likely(yyjson_is_arr(arr) && iter)) {\n-\t   iter->idx = 0;\n-\t   iter->max = unsafe_yyjson_get_len(arr);\n-\t   iter->cur = unsafe_yyjson_get_first(arr);\n-\t   return true;\n-   }\n-   if (iter) memset(iter, 0, sizeof(yyjson_arr_iter));\n-   return false;\n+                                            yyjson_arr_iter *iter) {\n+    if (yyjson_likely(yyjson_is_arr(arr) && iter)) {\n+        iter->idx = 0;\n+        iter->max = unsafe_yyjson_get_len(arr);\n+        iter->cur = unsafe_yyjson_get_first(arr);\n+        return true;\n+    }\n+    if (iter) memset(iter, 0, sizeof(yyjson_arr_iter));\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_arr_iter_has_next(yyjson_arr_iter *iter) {\n-   return iter ? iter->idx < iter->max : false;\n+    return iter ? iter->idx < iter->max : false;\n }\n \n yyjson_api_inline yyjson_val *yyjson_arr_iter_next(yyjson_arr_iter *iter) {\n-   yyjson_val *val;\n-   if (iter && iter->idx < iter->max) {\n-\t   val = iter->cur;\n-\t   iter->cur = unsafe_yyjson_get_next(val);\n-\t   iter->idx++;\n-\t   return val;\n-   }\n-   return NULL;\n+    yyjson_val *val;\n+    if (iter && iter->idx < iter->max) {\n+        val = iter->cur;\n+        iter->cur = unsafe_yyjson_get_next(val);\n+        iter->idx++;\n+        return val;\n+    }\n+    return NULL;\n }\n \n \n \n /*==============================================================================\n-* JSON Object API (Implementation)\n-*============================================================================*/\n+ * JSON Object API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline size_t yyjson_obj_size(yyjson_val *obj) {\n-   return yyjson_is_obj(obj) ? unsafe_yyjson_get_len(obj) : 0;\n+    return yyjson_is_obj(obj) ? unsafe_yyjson_get_len(obj) : 0;\n }\n \n yyjson_api_inline yyjson_val *yyjson_obj_get(yyjson_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\tconst char *key) {\n-   return yyjson_obj_getn(obj, key, key ? strlen(key) : 0);\n+                                             const char *key) {\n+    return yyjson_obj_getn(obj, key, key ? strlen(key) : 0);\n }\n \n yyjson_api_inline yyjson_val *yyjson_obj_getn(yyjson_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t const char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t size_t key_len) {\n-   uint64_t tag = (((uint64_t)key_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-   if (yyjson_likely(yyjson_is_obj(obj) && _key)) {\n-\t   size_t len = unsafe_yyjson_get_len(obj);\n-\t   yyjson_val *key = unsafe_yyjson_get_first(obj);\n-\t   while (len-- > 0) {\n-\t\t   if (key->tag == tag &&\n-\t\t\t   duckdb::FastMemcmp(key->uni.ptr, _key, key_len) == 0) {\n-\t\t\t   return key + 1;\n-\t\t   }\n-\t\t   key = unsafe_yyjson_get_next(key + 1);\n-\t   }\n-   }\n-   return NULL;\n+                                              const char *_key,\n+                                              size_t key_len) {\n+    uint64_t tag = (((uint64_t)key_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+    if (yyjson_likely(yyjson_is_obj(obj) && _key)) {\n+        size_t len = unsafe_yyjson_get_len(obj);\n+        yyjson_val *key = unsafe_yyjson_get_first(obj);\n+        while (len-- > 0) {\n+            if (key->tag == tag &&\n+                duckdb::FastMemcmp(key->uni.ptr, _key, key_len) == 0) {\n+                return key + 1;\n+            }\n+            key = unsafe_yyjson_get_next(key + 1);\n+        }\n+    }\n+    return NULL;\n }\n \n \n \n /*==============================================================================\n-* JSON Object Iterator API (Implementation)\n-*============================================================================*/\n+ * JSON Object Iterator API (Implementation)\n+ *============================================================================*/\n \n struct yyjson_obj_iter {\n-   size_t idx; /**< current key index, from 0 */\n-   size_t max; /**< maximum key index, idx < max */\n-   yyjson_val *cur; /**< current key */\n-   yyjson_val *obj; /**< the object being iterated */\n+    size_t idx; /**< current key index, from 0 */\n+    size_t max; /**< maximum key index, idx < max */\n+    yyjson_val *cur; /**< current key */\n+    yyjson_val *obj; /**< the object being iterated */\n };\n \n yyjson_api_inline bool yyjson_obj_iter_init(yyjson_val *obj,\n-\t\t\t\t\t\t\t\t\t\t   yyjson_obj_iter *iter) {\n-   if (yyjson_likely(yyjson_is_obj(obj) && iter)) {\n-\t   iter->idx = 0;\n-\t   iter->max = unsafe_yyjson_get_len(obj);\n-\t   iter->cur = unsafe_yyjson_get_first(obj);\n-\t   iter->obj = obj;\n-\t   return true;\n-   }\n-   if (iter) memset(iter, 0, sizeof(yyjson_obj_iter));\n-   return false;\n+                                            yyjson_obj_iter *iter) {\n+    if (yyjson_likely(yyjson_is_obj(obj) && iter)) {\n+        iter->idx = 0;\n+        iter->max = unsafe_yyjson_get_len(obj);\n+        iter->cur = unsafe_yyjson_get_first(obj);\n+        iter->obj = obj;\n+        return true;\n+    }\n+    if (iter) memset(iter, 0, sizeof(yyjson_obj_iter));\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_obj_iter_has_next(yyjson_obj_iter *iter) {\n-   return iter ? iter->idx < iter->max : false;\n+    return iter ? iter->idx < iter->max : false;\n }\n \n yyjson_api_inline yyjson_val *yyjson_obj_iter_next(yyjson_obj_iter *iter) {\n-   if (iter && iter->idx < iter->max) {\n-\t   yyjson_val *key = iter->cur;\n-\t   iter->idx++;\n-\t   iter->cur = unsafe_yyjson_get_next(key + 1);\n-\t   return key;\n-   }\n-   return NULL;\n+    if (iter && iter->idx < iter->max) {\n+        yyjson_val *key = iter->cur;\n+        iter->idx++;\n+        iter->cur = unsafe_yyjson_get_next(key + 1);\n+        return key;\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_val *yyjson_obj_iter_get_val(yyjson_val *key) {\n-   return key ? key + 1 : NULL;\n+    return key ? key + 1 : NULL;\n }\n \n yyjson_api_inline yyjson_val *yyjson_obj_iter_get(yyjson_obj_iter *iter,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *key) {\n-   return yyjson_obj_iter_getn(iter, key, key ? strlen(key) : 0);\n+                                                  const char *key) {\n+    return yyjson_obj_iter_getn(iter, key, key ? strlen(key) : 0);\n }\n \n yyjson_api_inline yyjson_val *yyjson_obj_iter_getn(yyjson_obj_iter *iter,\n-\t\t\t\t\t\t\t\t\t\t\t\t  const char *key,\n-\t\t\t\t\t\t\t\t\t\t\t\t  size_t key_len) {\n-   if (iter && key) {\n-\t   size_t idx = iter->idx;\n-\t   size_t max = iter->max;\n-\t   yyjson_val *cur = iter->cur;\n-\t   if (yyjson_unlikely(idx == max)) {\n-\t\t   idx = 0;\n-\t\t   cur = unsafe_yyjson_get_first(iter->obj);\n-\t   }\n-\t   while (idx++ < max) {\n-\t\t   yyjson_val *next = unsafe_yyjson_get_next(cur + 1);\n-\t\t   if (unsafe_yyjson_get_len(cur) == key_len &&\n-\t\t\t   duckdb::FastMemcmp(cur->uni.str, key, key_len) == 0) {\n-\t\t\t   iter->idx = idx;\n-\t\t\t   iter->cur = next;\n-\t\t\t   return cur + 1;\n-\t\t   }\n-\t\t   cur = next;\n-\t\t   if (idx == iter->max && iter->idx < iter->max) {\n-\t\t\t   idx = 0;\n-\t\t\t   max = iter->idx;\n-\t\t\t   cur = unsafe_yyjson_get_first(iter->obj);\n-\t\t   }\n-\t   }\n-   }\n-   return NULL;\n+                                                   const char *key,\n+                                                   size_t key_len) {\n+    if (iter && key) {\n+        size_t idx = iter->idx;\n+        size_t max = iter->max;\n+        yyjson_val *cur = iter->cur;\n+        if (yyjson_unlikely(idx == max)) {\n+            idx = 0;\n+            cur = unsafe_yyjson_get_first(iter->obj);\n+        }\n+        while (idx++ < max) {\n+            yyjson_val *next = unsafe_yyjson_get_next(cur + 1);\n+            if (unsafe_yyjson_get_len(cur) == key_len &&\n+                duckdb::FastMemcmp(cur->uni.str, key, key_len) == 0) {\n+                iter->idx = idx;\n+                iter->cur = next;\n+                return cur + 1;\n+            }\n+            cur = next;\n+            if (idx == iter->max && iter->idx < iter->max) {\n+                idx = 0;\n+                max = iter->idx;\n+                cur = unsafe_yyjson_get_first(iter->obj);\n+            }\n+        }\n+    }\n+    return NULL;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Structure (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Structure (Implementation)\n+ *============================================================================*/\n \n /**\n-Mutable JSON value, 24 bytes.\n-The 'tag' and 'uni' field is same as immutable value.\n-The 'next' field links all elements inside the container to be a cycle.\n-*/\n+ Mutable JSON value, 24 bytes.\n+ The 'tag' and 'uni' field is same as immutable value.\n+ The 'next' field links all elements inside the container to be a cycle.\n+ */\n struct yyjson_mut_val {\n-   uint64_t tag; /**< type, subtype and length */\n-   yyjson_val_uni uni; /**< payload */\n-   yyjson_mut_val *next; /**< the next value in circular linked list */\n+    uint64_t tag; /**< type, subtype and length */\n+    yyjson_val_uni uni; /**< payload */\n+    yyjson_mut_val *next; /**< the next value in circular linked list */\n };\n \n /**\n-A memory chunk in string memory pool.\n-*/\n+ A memory chunk in string memory pool.\n+ */\n typedef struct yyjson_str_chunk {\n-   struct yyjson_str_chunk *next;\n-   /* flexible array member here */\n+    struct yyjson_str_chunk *next;\n+    /* flexible array member here */\n } yyjson_str_chunk;\n \n /**\n-A memory pool to hold all strings in a mutable document.\n-*/\n+ A memory pool to hold all strings in a mutable document.\n+ */\n typedef struct yyjson_str_pool {\n-   char *cur; /* cursor inside current chunk */\n-   char *end; /* the end of current chunk */\n-   size_t chunk_size; /* chunk size in bytes while creating new chunk */\n-   size_t chunk_size_max; /* maximum chunk size in bytes */\n-   yyjson_str_chunk *chunks; /* a linked list of chunks, nullable */\n+    char *cur; /* cursor inside current chunk */\n+    char *end; /* the end of current chunk */\n+    size_t chunk_size; /* chunk size in bytes while creating new chunk */\n+    size_t chunk_size_max; /* maximum chunk size in bytes */\n+    yyjson_str_chunk *chunks; /* a linked list of chunks, nullable */\n } yyjson_str_pool;\n \n /**\n-A memory chunk in value memory pool.\n-*/\n+ A memory chunk in value memory pool.\n+ */\n typedef struct yyjson_val_chunk {\n-   struct yyjson_val_chunk *next;\n-   /* flexible array member here */\n+    struct yyjson_val_chunk *next;\n+    /* flexible array member here */\n } yyjson_val_chunk;\n \n /**\n-A memory pool to hold all values in a mutable document.\n-*/\n+ A memory pool to hold all values in a mutable document.\n+ */\n typedef struct yyjson_val_pool {\n-   yyjson_mut_val *cur; /* cursor inside current chunk */\n-   yyjson_mut_val *end; /* the end of current chunk */\n-   size_t chunk_size; /* chunk size in bytes while creating new chunk */\n-   size_t chunk_size_max; /* maximum chunk size in bytes */\n-   yyjson_val_chunk *chunks; /* a linked list of chunks, nullable */\n+    yyjson_mut_val *cur; /* cursor inside current chunk */\n+    yyjson_mut_val *end; /* the end of current chunk */\n+    size_t chunk_size; /* chunk size in bytes while creating new chunk */\n+    size_t chunk_size_max; /* maximum chunk size in bytes */\n+    yyjson_val_chunk *chunks; /* a linked list of chunks, nullable */\n } yyjson_val_pool;\n \n struct yyjson_mut_doc {\n-   yyjson_mut_val *root; /**< root value of the JSON document, nullable */\n-   yyjson_alc alc; /**< a valid allocator, nonnull */\n-   yyjson_str_pool str_pool; /**< string memory pool */\n-   yyjson_val_pool val_pool; /**< value memory pool */\n+    yyjson_mut_val *root; /**< root value of the JSON document, nullable */\n+    yyjson_alc alc; /**< a valid allocator, nonnull */\n+    yyjson_str_pool str_pool; /**< string memory pool */\n+    yyjson_val_pool val_pool; /**< value memory pool */\n };\n \n /* Ensures the capacity to at least equal to the specified byte length. */\n yyjson_api bool unsafe_yyjson_str_pool_grow(yyjson_str_pool *pool,\n-\t\t\t\t\t\t\t\t\t\t   yyjson_alc *alc, size_t len);\n+                                            const yyjson_alc *alc,\n+                                            size_t len);\n \n /* Ensures the capacity to at least equal to the specified value count. */\n yyjson_api bool unsafe_yyjson_val_pool_grow(yyjson_val_pool *pool,\n-\t\t\t\t\t\t\t\t\t\t   yyjson_alc *alc, size_t count);\n+                                            const yyjson_alc *alc,\n+                                            size_t count);\n \n yyjson_api_inline char *unsafe_yyjson_mut_strncpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *str, size_t len) {\n-   char *mem;\n-   yyjson_alc *alc = &doc->alc;\n-   yyjson_str_pool *pool = &doc->str_pool;\n-\n-   if (!str) return NULL;\n-   if (yyjson_unlikely((size_t)(pool->end - pool->cur) <= len)) {\n-\t   if (yyjson_unlikely(!unsafe_yyjson_str_pool_grow(pool, alc, len + 1))) {\n-\t\t   return NULL;\n-\t   }\n-   }\n-\n-   mem = pool->cur;\n-   pool->cur = mem + len + 1;\n-   duckdb::FastMemcpy((void *)mem, (const void *)str, len);\n-   mem[len] = '\\0';\n-   return mem;\n+                                                  const char *str, size_t len) {\n+    char *mem;\n+    const yyjson_alc *alc = &doc->alc;\n+    yyjson_str_pool *pool = &doc->str_pool;\n+    \n+    if (!str) return NULL;\n+    if (yyjson_unlikely((size_t)(pool->end - pool->cur) <= len)) {\n+        if (yyjson_unlikely(!unsafe_yyjson_str_pool_grow(pool, alc, len + 1))) {\n+            return NULL;\n+        }\n+    }\n+    \n+    mem = pool->cur;\n+    pool->cur = mem + len + 1;\n+    memcpy((void *)mem, (const void *)str, len);\n+    mem[len] = '\\0';\n+    return mem;\n }\n \n yyjson_api_inline yyjson_mut_val *unsafe_yyjson_mut_val(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t   size_t count) {\n-   yyjson_mut_val *val;\n-   yyjson_alc *alc = &doc->alc;\n-   yyjson_val_pool *pool = &doc->val_pool;\n-   if (yyjson_unlikely((size_t)(pool->end - pool->cur) < count)) {\n-\t   if (yyjson_unlikely(!unsafe_yyjson_val_pool_grow(pool, alc, count))) {\n-\t\t   return NULL;\n-\t   }\n-   }\n-\n-   val = pool->cur;\n-   pool->cur += count;\n-   return val;\n+                                                        size_t count) {\n+    yyjson_mut_val *val;\n+    yyjson_alc *alc = &doc->alc;\n+    yyjson_val_pool *pool = &doc->val_pool;\n+    if (yyjson_unlikely((size_t)(pool->end - pool->cur) < count)) {\n+        if (yyjson_unlikely(!unsafe_yyjson_val_pool_grow(pool, alc, count))) {\n+            return NULL;\n+        }\n+    }\n+    \n+    val = pool->cur;\n+    pool->cur += count;\n+    return val;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Document API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Document API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_doc_get_root(yyjson_mut_doc *doc) {\n-   return doc ? doc->root : NULL;\n+    return doc ? doc->root : NULL;\n }\n \n yyjson_api_inline void yyjson_mut_doc_set_root(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *root) {\n-   if (doc) doc->root = root;\n+                                               yyjson_mut_val *root) {\n+    if (doc) doc->root = root;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Value Type API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Value Type API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline bool yyjson_mut_is_raw(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_raw(val) : false;\n+    return val ? unsafe_yyjson_is_raw(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_null(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_null(val) : false;\n+    return val ? unsafe_yyjson_is_null(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_true(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_true(val) : false;\n+    return val ? unsafe_yyjson_is_true(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_false(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_false(val) : false;\n+    return val ? unsafe_yyjson_is_false(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_bool(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_bool(val) : false;\n+    return val ? unsafe_yyjson_is_bool(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_uint(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_uint(val) : false;\n+    return val ? unsafe_yyjson_is_uint(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_sint(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_sint(val) : false;\n+    return val ? unsafe_yyjson_is_sint(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_int(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_int(val) : false;\n+    return val ? unsafe_yyjson_is_int(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_real(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_real(val) : false;\n+    return val ? unsafe_yyjson_is_real(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_num(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_num(val) : false;\n+    return val ? unsafe_yyjson_is_num(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_str(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_str(val) : false;\n+    return val ? unsafe_yyjson_is_str(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_arr(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_arr(val) : false;\n+    return val ? unsafe_yyjson_is_arr(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_obj(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_obj(val) : false;\n+    return val ? unsafe_yyjson_is_obj(val) : false;\n }\n \n yyjson_api_inline bool yyjson_mut_is_ctn(yyjson_mut_val *val) {\n-   return val ? unsafe_yyjson_is_ctn(val) : false;\n+    return val ? unsafe_yyjson_is_ctn(val) : false;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Value Content API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Value Content API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline yyjson_type yyjson_mut_get_type(yyjson_mut_val *val) {\n-   return yyjson_get_type((yyjson_val *)val);\n+    return yyjson_get_type((yyjson_val *)val);\n }\n \n yyjson_api_inline yyjson_subtype yyjson_mut_get_subtype(yyjson_mut_val *val) {\n-   return yyjson_get_subtype((yyjson_val *)val);\n+    return yyjson_get_subtype((yyjson_val *)val);\n }\n \n yyjson_api_inline uint8_t yyjson_mut_get_tag(yyjson_mut_val *val) {\n-   return yyjson_get_tag((yyjson_val *)val);\n+    return yyjson_get_tag((yyjson_val *)val);\n }\n \n yyjson_api_inline const char *yyjson_mut_get_type_desc(yyjson_mut_val *val) {\n-   return yyjson_get_type_desc((yyjson_val *)val);\n+    return yyjson_get_type_desc((yyjson_val *)val);\n }\n \n yyjson_api_inline const char *yyjson_mut_get_raw(yyjson_mut_val *val) {\n-   return yyjson_get_raw((yyjson_val *)val);\n+    return yyjson_get_raw((yyjson_val *)val);\n }\n \n yyjson_api_inline bool yyjson_mut_get_bool(yyjson_mut_val *val) {\n-   return yyjson_get_bool((yyjson_val *)val);\n+    return yyjson_get_bool((yyjson_val *)val);\n }\n \n yyjson_api_inline uint64_t yyjson_mut_get_uint(yyjson_mut_val *val) {\n-   return yyjson_get_uint((yyjson_val *)val);\n+    return yyjson_get_uint((yyjson_val *)val);\n }\n \n yyjson_api_inline int64_t yyjson_mut_get_sint(yyjson_mut_val *val) {\n-   return yyjson_get_sint((yyjson_val *)val);\n+    return yyjson_get_sint((yyjson_val *)val);\n }\n \n yyjson_api_inline int yyjson_mut_get_int(yyjson_mut_val *val) {\n-   return yyjson_get_int((yyjson_val *)val);\n+    return yyjson_get_int((yyjson_val *)val);\n }\n \n yyjson_api_inline double yyjson_mut_get_real(yyjson_mut_val *val) {\n-   return yyjson_get_real((yyjson_val *)val);\n+    return yyjson_get_real((yyjson_val *)val);\n }\n \n yyjson_api_inline const char *yyjson_mut_get_str(yyjson_mut_val *val) {\n-   return yyjson_get_str((yyjson_val *)val);\n+    return yyjson_get_str((yyjson_val *)val);\n }\n \n yyjson_api_inline size_t yyjson_mut_get_len(yyjson_mut_val *val) {\n-   return yyjson_get_len((yyjson_val *)val);\n+    return yyjson_get_len((yyjson_val *)val);\n }\n \n yyjson_api_inline bool yyjson_mut_equals_str(yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\tconst char *str) {\n-   return yyjson_equals_str((yyjson_val *)val, str);\n+                                             const char *str) {\n+    return yyjson_equals_str((yyjson_val *)val, str);\n }\n \n yyjson_api_inline bool yyjson_mut_equals_strn(yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t const char *str, size_t len) {\n-   return yyjson_equals_strn((yyjson_val *)val, str, len);\n+                                              const char *str, size_t len) {\n+    return yyjson_equals_strn((yyjson_val *)val, str, len);\n }\n \n yyjson_api bool unsafe_yyjson_mut_equals(yyjson_mut_val *lhs,\n-\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *rhs);\n+                                         yyjson_mut_val *rhs);\n \n yyjson_api_inline bool yyjson_mut_equals(yyjson_mut_val *lhs,\n-\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *rhs) {\n-   if (yyjson_unlikely(!lhs || !rhs)) return false;\n-   return unsafe_yyjson_mut_equals(lhs, rhs);\n+                                         yyjson_mut_val *rhs) {\n+    if (yyjson_unlikely(!lhs || !rhs)) return false;\n+    return unsafe_yyjson_mut_equals(lhs, rhs);\n+}\n+\n+yyjson_api_inline bool yyjson_mut_set_raw(yyjson_mut_val *val,\n+                                          const char *raw, size_t len) {\n+    if (yyjson_unlikely(!val || !raw)) return false;\n+    unsafe_yyjson_set_raw(val, raw, len);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_mut_set_null(yyjson_mut_val *val) {\n+    if (yyjson_unlikely(!val)) return false;\n+    unsafe_yyjson_set_null(val);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_mut_set_bool(yyjson_mut_val *val, bool num) {\n+    if (yyjson_unlikely(!val)) return false;\n+    unsafe_yyjson_set_bool(val, num);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_mut_set_uint(yyjson_mut_val *val, uint64_t num) {\n+    if (yyjson_unlikely(!val)) return false;\n+    unsafe_yyjson_set_uint(val, num);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_mut_set_sint(yyjson_mut_val *val, int64_t num) {\n+    if (yyjson_unlikely(!val)) return false;\n+    unsafe_yyjson_set_sint(val, num);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_mut_set_int(yyjson_mut_val *val, int num) {\n+    if (yyjson_unlikely(!val)) return false;\n+    unsafe_yyjson_set_sint(val, (int64_t)num);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_mut_set_real(yyjson_mut_val *val, double num) {\n+    if (yyjson_unlikely(!val)) return false;\n+    unsafe_yyjson_set_real(val, num);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_mut_set_str(yyjson_mut_val *val,\n+                                          const char *str) {\n+    if (yyjson_unlikely(!val || !str)) return false;\n+    unsafe_yyjson_set_str(val, str);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_mut_set_strn(yyjson_mut_val *val,\n+                                           const char *str, size_t len) {\n+    if (yyjson_unlikely(!val || !str)) return false;\n+    unsafe_yyjson_set_strn(val, str, len);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_mut_set_arr(yyjson_mut_val *val) {\n+    if (yyjson_unlikely(!val)) return false;\n+    unsafe_yyjson_set_arr(val, 0);\n+    return true;\n+}\n+\n+yyjson_api_inline bool yyjson_mut_set_obj(yyjson_mut_val *val) {\n+    if (yyjson_unlikely(!val)) return false;\n+    unsafe_yyjson_set_obj(val, 0);\n+    return true;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Value Creation API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Value Creation API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_raw(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *str) {\n-   if (yyjson_likely(str)) return yyjson_mut_rawn(doc, str, strlen(str));\n-   return NULL;\n+                                                 const char *str) {\n+    if (yyjson_likely(str)) return yyjson_mut_rawn(doc, str, strlen(str));\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_rawn(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *str,\n-\t\t\t\t\t\t\t\t\t\t\t\t size_t len) {\n-   if (yyjson_likely(doc && str)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   if (yyjson_likely(val)) {\n-\t\t   val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_RAW;\n-\t\t   val->uni.str = str;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+                                                  const char *str,\n+                                                  size_t len) {\n+    if (yyjson_likely(doc && str)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        if (yyjson_likely(val)) {\n+            val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_RAW;\n+            val->uni.str = str;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_rawcpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t   const char *str) {\n-   if (yyjson_likely(str)) return yyjson_mut_rawncpy(doc, str, strlen(str));\n-   return NULL;\n+                                                    const char *str) {\n+    if (yyjson_likely(str)) return yyjson_mut_rawncpy(doc, str, strlen(str));\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_rawncpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *str,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tsize_t len) {\n-   if (yyjson_likely(doc && str)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   char *new_str = unsafe_yyjson_mut_strncpy(doc, str, len);\n-\t   if (yyjson_likely(val && new_str)) {\n-\t\t   val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_RAW;\n-\t\t   val->uni.str = new_str;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+                                                     const char *str,\n+                                                     size_t len) {\n+    if (yyjson_likely(doc && str)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        char *new_str = unsafe_yyjson_mut_strncpy(doc, str, len);\n+        if (yyjson_likely(val && new_str)) {\n+            val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_RAW;\n+            val->uni.str = new_str;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_null(yyjson_mut_doc *doc) {\n-   if (yyjson_likely(doc)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   if (yyjson_likely(val)) {\n-\t\t   val->tag = YYJSON_TYPE_NULL | YYJSON_SUBTYPE_NONE;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+    if (yyjson_likely(doc)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        if (yyjson_likely(val)) {\n+            val->tag = YYJSON_TYPE_NULL | YYJSON_SUBTYPE_NONE;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_true(yyjson_mut_doc *doc) {\n-   if (yyjson_likely(doc)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   if (yyjson_likely(val)) {\n-\t\t   val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_TRUE;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+    if (yyjson_likely(doc)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        if (yyjson_likely(val)) {\n+            val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_TRUE;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_false(yyjson_mut_doc *doc) {\n-   if (yyjson_likely(doc)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   if (yyjson_likely(val)) {\n-\t\t   val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_FALSE;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+    if (yyjson_likely(doc)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        if (yyjson_likely(val)) {\n+            val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_FALSE;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_bool(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t bool _val) {\n-   if (yyjson_likely(doc)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   if (yyjson_likely(val)) {\n-\t\t   val->tag = YYJSON_TYPE_BOOL | (uint8_t)((uint8_t)_val << 3);\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+                                                  bool _val) {\n+    if (yyjson_likely(doc)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        if (yyjson_likely(val)) {\n+            val->tag = YYJSON_TYPE_BOOL | (uint8_t)((uint8_t)_val << 3);\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_uint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t uint64_t num) {\n-   if (yyjson_likely(doc)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   if (yyjson_likely(val)) {\n-\t\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n-\t\t   val->uni.u64 = num;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+                                                  uint64_t num) {\n+    if (yyjson_likely(doc)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        if (yyjson_likely(val)) {\n+            val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n+            val->uni.u64 = num;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_sint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t int64_t num) {\n-   if (yyjson_likely(doc)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   if (yyjson_likely(val)) {\n-\t\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n-\t\t   val->uni.i64 = num;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+                                                  int64_t num) {\n+    if (yyjson_likely(doc)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        if (yyjson_likely(val)) {\n+            val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n+            val->uni.i64 = num;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_int(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\tint64_t num) {\n-   return yyjson_mut_sint(doc, num);\n+                                                 int64_t num) {\n+    return yyjson_mut_sint(doc, num);\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_real(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t double num) {\n-   if (yyjson_likely(doc)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   if (yyjson_likely(val)) {\n-\t\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n-\t\t   val->uni.f64 = num;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+                                                  double num) {\n+    if (yyjson_likely(doc)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        if (yyjson_likely(val)) {\n+            val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n+            val->uni.f64 = num;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_str(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *str) {\n-   if (yyjson_likely(str)) return yyjson_mut_strn(doc, str, strlen(str));\n-   return NULL;\n+                                                 const char *str) {\n+    if (yyjson_likely(str)) return yyjson_mut_strn(doc, str, strlen(str));\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_strn(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *str,\n-\t\t\t\t\t\t\t\t\t\t\t\t size_t len) {\n-   if (yyjson_likely(doc && str)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   if (yyjson_likely(val)) {\n-\t\t   val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t\t   val->uni.str = str;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+                                                  const char *str,\n+                                                  size_t len) {\n+    if (yyjson_likely(doc && str)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        if (yyjson_likely(val)) {\n+            val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+            val->uni.str = str;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_strcpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t   const char *str) {\n-   if (yyjson_likely(str)) return yyjson_mut_strncpy(doc, str, strlen(str));\n-   return NULL;\n+                                                    const char *str) {\n+    if (yyjson_likely(str)) return yyjson_mut_strncpy(doc, str, strlen(str));\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_strncpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *str,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tsize_t len) {\n-   if (yyjson_likely(doc && str)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   char *new_str = unsafe_yyjson_mut_strncpy(doc, str, len);\n-\t   if (yyjson_likely(val && new_str)) {\n-\t\t   val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t\t   val->uni.str = new_str;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+                                                     const char *str,\n+                                                     size_t len) {\n+    if (yyjson_likely(doc && str)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        char *new_str = unsafe_yyjson_mut_strncpy(doc, str, len);\n+        if (yyjson_likely(val && new_str)) {\n+            val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+            val->uni.str = new_str;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Array API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Array API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline size_t yyjson_mut_arr_size(yyjson_mut_val *arr) {\n-   return yyjson_mut_is_arr(arr) ? unsafe_yyjson_get_len(arr) : 0;\n+    return yyjson_mut_is_arr(arr) ? unsafe_yyjson_get_len(arr) : 0;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_get(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tsize_t idx) {\n-   if (yyjson_likely(idx < yyjson_mut_arr_size(arr))) {\n-\t   yyjson_mut_val *val = (yyjson_mut_val *)arr->uni.ptr;\n-\t   while (idx-- > 0) val = val->next;\n-\t   return val->next;\n-   }\n-   return NULL;\n+                                                     size_t idx) {\n+    if (yyjson_likely(idx < yyjson_mut_arr_size(arr))) {\n+        yyjson_mut_val *val = (yyjson_mut_val *)arr->uni.ptr;\n+        while (idx-- > 0) val = val->next;\n+        return val->next;\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_get_first(\n-   yyjson_mut_val *arr) {\n-   if (yyjson_likely(yyjson_mut_arr_size(arr) > 0)) {\n-\t   return ((yyjson_mut_val *)arr->uni.ptr)->next;\n-   }\n-   return NULL;\n+    yyjson_mut_val *arr) {\n+    if (yyjson_likely(yyjson_mut_arr_size(arr) > 0)) {\n+        return ((yyjson_mut_val *)arr->uni.ptr)->next;\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_get_last(\n-   yyjson_mut_val *arr) {\n-   if (yyjson_likely(yyjson_mut_arr_size(arr) > 0)) {\n-\t   return ((yyjson_mut_val *)arr->uni.ptr);\n-   }\n-   return NULL;\n+    yyjson_mut_val *arr) {\n+    if (yyjson_likely(yyjson_mut_arr_size(arr) > 0)) {\n+        return ((yyjson_mut_val *)arr->uni.ptr);\n+    }\n+    return NULL;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Array Iterator API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Array Iterator API (Implementation)\n+ *============================================================================*/\n \n struct yyjson_mut_arr_iter {\n-   size_t idx; /**< current index, from 0 */\n-   size_t max; /**< maximum index, idx < max */\n-   yyjson_mut_val *cur; /**< current value */\n-   yyjson_mut_val *pre; /**< previous value */\n-   yyjson_mut_val *arr; /**< the array being iterated */\n+    size_t idx; /**< current index, from 0 */\n+    size_t max; /**< maximum index, idx < max */\n+    yyjson_mut_val *cur; /**< current value */\n+    yyjson_mut_val *pre; /**< previous value */\n+    yyjson_mut_val *arr; /**< the array being iterated */\n };\n \n yyjson_api_inline bool yyjson_mut_arr_iter_init(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t   yyjson_mut_arr_iter *iter) {\n-   if (yyjson_likely(yyjson_mut_is_arr(arr) && iter)) {\n-\t   iter->idx = 0;\n-\t   iter->max = unsafe_yyjson_get_len(arr);\n-\t   iter->cur = iter->max ? (yyjson_mut_val *)arr->uni.ptr : NULL;\n-\t   iter->pre = NULL;\n-\t   iter->arr = arr;\n-\t   return true;\n-   }\n-   if (iter) memset(iter, 0, sizeof(yyjson_mut_arr_iter));\n-   return false;\n+                                                yyjson_mut_arr_iter *iter) {\n+    if (yyjson_likely(yyjson_mut_is_arr(arr) && iter)) {\n+        iter->idx = 0;\n+        iter->max = unsafe_yyjson_get_len(arr);\n+        iter->cur = iter->max ? (yyjson_mut_val *)arr->uni.ptr : NULL;\n+        iter->pre = NULL;\n+        iter->arr = arr;\n+        return true;\n+    }\n+    if (iter) memset(iter, 0, sizeof(yyjson_mut_arr_iter));\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_iter_has_next(yyjson_mut_arr_iter *iter) {\n-   return iter ? iter->idx < iter->max : false;\n+    return iter ? iter->idx < iter->max : false;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_iter_next(\n-   yyjson_mut_arr_iter *iter) {\n-   if (iter && iter->idx < iter->max) {\n-\t   yyjson_mut_val *val = iter->cur;\n-\t   iter->pre = val;\n-\t   iter->cur = val->next;\n-\t   iter->idx++;\n-\t   return iter->cur;\n-   }\n-   return NULL;\n+    yyjson_mut_arr_iter *iter) {\n+    if (iter && iter->idx < iter->max) {\n+        yyjson_mut_val *val = iter->cur;\n+        iter->pre = val;\n+        iter->cur = val->next;\n+        iter->idx++;\n+        return iter->cur;\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_iter_remove(\n-   yyjson_mut_arr_iter *iter) {\n-   if (yyjson_likely(iter && 0 < iter->idx && iter->idx <= iter->max)) {\n-\t   yyjson_mut_val *prev = iter->pre;\n-\t   yyjson_mut_val *cur = iter->cur;\n-\t   yyjson_mut_val *next = cur->next;\n-\t   if (yyjson_unlikely(iter->idx == iter->max)) iter->arr->uni.ptr = prev;\n-\t   iter->idx--;\n-\t   iter->max--;\n-\t   unsafe_yyjson_set_len(iter->arr, iter->max);\n-\t   prev->next = next;\n-\t   iter->cur = next;\n-\t   return cur;\n-   }\n-   return NULL;\n+    yyjson_mut_arr_iter *iter) {\n+    if (yyjson_likely(iter && 0 < iter->idx && iter->idx <= iter->max)) {\n+        yyjson_mut_val *prev = iter->pre;\n+        yyjson_mut_val *cur = iter->cur;\n+        yyjson_mut_val *next = cur->next;\n+        if (yyjson_unlikely(iter->idx == iter->max)) iter->arr->uni.ptr = prev;\n+        iter->idx--;\n+        iter->max--;\n+        unsafe_yyjson_set_len(iter->arr, iter->max);\n+        prev->next = next;\n+        iter->cur = next;\n+        return cur;\n+    }\n+    return NULL;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Array Creation API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Array Creation API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr(yyjson_mut_doc *doc) {\n-   if (yyjson_likely(doc)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   if (yyjson_likely(val)) {\n-\t\t   val->tag = YYJSON_TYPE_ARR | YYJSON_SUBTYPE_NONE;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+    if (yyjson_likely(doc)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        if (yyjson_likely(val)) {\n+            val->tag = YYJSON_TYPE_ARR | YYJSON_SUBTYPE_NONE;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n #define yyjson_mut_arr_with_func(func) \\\n-   if (yyjson_likely(doc && ((0 < count && count < \\\n-\t   (~(size_t)0) / sizeof(yyjson_mut_val) && vals) || count == 0))) { \\\n-\t   yyjson_mut_val *arr = unsafe_yyjson_mut_val(doc, 1 + count); \\\n-\t   if (yyjson_likely(arr)) { \\\n-\t\t   arr->tag = ((uint64_t)count << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR; \\\n-\t\t   if (count > 0) { \\\n-\t\t\t   size_t i; \\\n-\t\t\t   for (i = 0; i < count; i++) { \\\n-\t\t\t\t   yyjson_mut_val *val = arr + i + 1; \\\n-\t\t\t\t   func \\\n-\t\t\t\t   val->next = val + 1; \\\n-\t\t\t   } \\\n-\t\t\t   arr[count].next = arr + 1; \\\n-\t\t\t   arr->uni.ptr = arr + count; \\\n-\t\t   } \\\n-\t\t   return arr; \\\n-\t   } \\\n-   } \\\n-   return NULL\n+    if (yyjson_likely(doc && ((0 < count && count < \\\n+        (~(size_t)0) / sizeof(yyjson_mut_val) && vals) || count == 0))) { \\\n+        yyjson_mut_val *arr = unsafe_yyjson_mut_val(doc, 1 + count); \\\n+        if (yyjson_likely(arr)) { \\\n+            arr->tag = ((uint64_t)count << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR; \\\n+            if (count > 0) { \\\n+                size_t i; \\\n+                for (i = 0; i < count; i++) { \\\n+                    yyjson_mut_val *val = arr + i + 1; \\\n+                    func \\\n+                    val->next = val + 1; \\\n+                } \\\n+                arr[count].next = arr + 1; \\\n+                arr->uni.ptr = arr + count; \\\n+            } \\\n+            return arr; \\\n+        } \\\n+    } \\\n+    return NULL\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_bool(\n-   yyjson_mut_doc *doc, const bool *vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = YYJSON_TYPE_BOOL | (uint8_t)((uint8_t)vals[i] << 3);\n-   });\n+    yyjson_mut_doc *doc, const bool *vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        val->tag = YYJSON_TYPE_BOOL | (uint8_t)((uint8_t)vals[i] << 3);\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_sint(\n-   yyjson_mut_doc *doc, const int64_t *vals, size_t count) {\n-   return yyjson_mut_arr_with_sint64(doc, vals, count);\n+    yyjson_mut_doc *doc, const int64_t *vals, size_t count) {\n+    return yyjson_mut_arr_with_sint64(doc, vals, count);\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_uint(\n-   yyjson_mut_doc *doc, const uint64_t *vals, size_t count) {\n-   return yyjson_mut_arr_with_uint64(doc, vals, count);\n+    yyjson_mut_doc *doc, const uint64_t *vals, size_t count) {\n+    return yyjson_mut_arr_with_uint64(doc, vals, count);\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_real(\n-   yyjson_mut_doc *doc, const double *vals, size_t count) {\n-   return yyjson_mut_arr_with_double(doc, vals, count);\n+    yyjson_mut_doc *doc, const double *vals, size_t count) {\n+    return yyjson_mut_arr_with_double(doc, vals, count);\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_sint8(\n-   yyjson_mut_doc *doc, const int8_t *vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n-\t   val->uni.i64 = (int64_t)vals[i];\n-   });\n+    yyjson_mut_doc *doc, const int8_t *vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n+        val->uni.i64 = (int64_t)vals[i];\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_sint16(\n-   yyjson_mut_doc *doc, const int16_t *vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n-\t   val->uni.i64 = vals[i];\n-   });\n+    yyjson_mut_doc *doc, const int16_t *vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n+        val->uni.i64 = vals[i];\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_sint32(\n-   yyjson_mut_doc *doc, const int32_t *vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n-\t   val->uni.i64 = vals[i];\n-   });\n+    yyjson_mut_doc *doc, const int32_t *vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n+        val->uni.i64 = vals[i];\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_sint64(\n-   yyjson_mut_doc *doc, const int64_t *vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n-\t   val->uni.i64 = vals[i];\n-   });\n+    yyjson_mut_doc *doc, const int64_t *vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n+        val->uni.i64 = vals[i];\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_uint8(\n-   yyjson_mut_doc *doc, const uint8_t *vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n-\t   val->uni.u64 = vals[i];\n-   });\n+    yyjson_mut_doc *doc, const uint8_t *vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n+        val->uni.u64 = vals[i];\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_uint16(\n-   yyjson_mut_doc *doc, const uint16_t *vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n-\t   val->uni.u64 = vals[i];\n-   });\n+    yyjson_mut_doc *doc, const uint16_t *vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n+        val->uni.u64 = vals[i];\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_uint32(\n-   yyjson_mut_doc *doc, const uint32_t *vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n-\t   val->uni.u64 = vals[i];\n-   });\n+    yyjson_mut_doc *doc, const uint32_t *vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n+        val->uni.u64 = vals[i];\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_uint64(\n-   yyjson_mut_doc *doc, const uint64_t *vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n-\t   val->uni.u64 = vals[i];\n-   });\n+    yyjson_mut_doc *doc, const uint64_t *vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n+        val->uni.u64 = vals[i];\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_float(\n-   yyjson_mut_doc *doc, const float *vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n-\t   val->uni.f64 = (double)vals[i];\n-   });\n+    yyjson_mut_doc *doc, const float *vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n+        val->uni.f64 = (double)vals[i];\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_double(\n-   yyjson_mut_doc *doc, const double *vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n-\t   val->uni.f64 = vals[i];\n-   });\n+    yyjson_mut_doc *doc, const double *vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n+        val->uni.f64 = vals[i];\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_str(\n-   yyjson_mut_doc *doc, const char **vals, size_t count) {\n-   yyjson_mut_arr_with_func({\n-\t   uint64_t len = (uint64_t)strlen(vals[i]);\n-\t   val->tag = (len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t   val->uni.str = vals[i];\n-\t   if (yyjson_unlikely(!val->uni.str)) return NULL;\n-   });\n+    yyjson_mut_doc *doc, const char **vals, size_t count) {\n+    yyjson_mut_arr_with_func({\n+        uint64_t len = (uint64_t)strlen(vals[i]);\n+        val->tag = (len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+        val->uni.str = vals[i];\n+        if (yyjson_unlikely(!val->uni.str)) return NULL;\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_strn(\n-   yyjson_mut_doc *doc, const char **vals, const size_t *lens, size_t count) {\n-   if (yyjson_unlikely(count > 0 && !lens)) return NULL;\n-   yyjson_mut_arr_with_func({\n-\t   val->tag = ((uint64_t)lens[i] << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t   val->uni.str = vals[i];\n-\t   if (yyjson_unlikely(!val->uni.str)) return NULL;\n-   });\n+    yyjson_mut_doc *doc, const char **vals, const size_t *lens, size_t count) {\n+    if (yyjson_unlikely(count > 0 && !lens)) return NULL;\n+    yyjson_mut_arr_with_func({\n+        val->tag = ((uint64_t)lens[i] << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+        val->uni.str = vals[i];\n+        if (yyjson_unlikely(!val->uni.str)) return NULL;\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_strcpy(\n-   yyjson_mut_doc *doc, const char **vals, size_t count) {\n-   size_t len;\n-   const char *str;\n-   yyjson_mut_arr_with_func({\n-\t   str = vals[i];\n-\t   if (!str) return NULL;\n-\t   len = strlen(str);\n-\t   val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t   val->uni.str = unsafe_yyjson_mut_strncpy(doc, str, len);\n-\t   if (yyjson_unlikely(!val->uni.str)) return NULL;\n-   });\n+    yyjson_mut_doc *doc, const char **vals, size_t count) {\n+    size_t len;\n+    const char *str;\n+    yyjson_mut_arr_with_func({\n+        str = vals[i];\n+        if (!str) return NULL;\n+        len = strlen(str);\n+        val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+        val->uni.str = unsafe_yyjson_mut_strncpy(doc, str, len);\n+        if (yyjson_unlikely(!val->uni.str)) return NULL;\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_strncpy(\n-   yyjson_mut_doc *doc, const char **vals, const size_t *lens, size_t count) {\n-   size_t len;\n-   const char *str;\n-   if (yyjson_unlikely(count > 0 && !lens)) return NULL;\n-   yyjson_mut_arr_with_func({\n-\t   str = vals[i];\n-\t   len = lens[i];\n-\t   val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t   val->uni.str = unsafe_yyjson_mut_strncpy(doc, str, len);\n-\t   if (yyjson_unlikely(!val->uni.str)) return NULL;\n-   });\n+    yyjson_mut_doc *doc, const char **vals, const size_t *lens, size_t count) {\n+    size_t len;\n+    const char *str;\n+    if (yyjson_unlikely(count > 0 && !lens)) return NULL;\n+    yyjson_mut_arr_with_func({\n+        str = vals[i];\n+        len = lens[i];\n+        val->tag = ((uint64_t)len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+        val->uni.str = unsafe_yyjson_mut_strncpy(doc, str, len);\n+        if (yyjson_unlikely(!val->uni.str)) return NULL;\n+    });\n }\n \n #undef yyjson_mut_arr_with_func\n@@ -4539,1003 +4947,1035 @@ yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_with_strncpy(\n \n \n /*==============================================================================\n-* Mutable JSON Array Modification API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Array Modification API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline bool yyjson_mut_arr_insert(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *val, size_t idx) {\n-   if (yyjson_likely(yyjson_mut_is_arr(arr) && val)) {\n-\t   size_t len = unsafe_yyjson_get_len(arr);\n-\t   if (yyjson_likely(idx <= len)) {\n-\t\t   unsafe_yyjson_set_len(arr, len + 1);\n-\t\t   if (len == 0) {\n-\t\t\t   val->next = val;\n-\t\t\t   arr->uni.ptr = val;\n-\t\t   } else {\n-\t\t\t   yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n-\t\t\t   yyjson_mut_val *next = prev->next;\n-\t\t\t   if (idx == len) {\n-\t\t\t\t   prev->next = val;\n-\t\t\t\t   val->next = next;\n-\t\t\t\t   arr->uni.ptr = val;\n-\t\t\t   } else {\n-\t\t\t\t   while (idx-- > 0) {\n-\t\t\t\t\t   prev = next;\n-\t\t\t\t\t   next = next->next;\n-\t\t\t\t   }\n-\t\t\t\t   prev->next = val;\n-\t\t\t\t   val->next = next;\n-\t\t\t   }\n-\t\t   }\n-\t\t   return true;\n-\t   }\n-   }\n-   return false;\n+                                             yyjson_mut_val *val, size_t idx) {\n+    if (yyjson_likely(yyjson_mut_is_arr(arr) && val)) {\n+        size_t len = unsafe_yyjson_get_len(arr);\n+        if (yyjson_likely(idx <= len)) {\n+            unsafe_yyjson_set_len(arr, len + 1);\n+            if (len == 0) {\n+                val->next = val;\n+                arr->uni.ptr = val;\n+            } else {\n+                yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n+                yyjson_mut_val *next = prev->next;\n+                if (idx == len) {\n+                    prev->next = val;\n+                    val->next = next;\n+                    arr->uni.ptr = val;\n+                } else {\n+                    while (idx-- > 0) {\n+                        prev = next;\n+                        next = next->next;\n+                    }\n+                    prev->next = val;\n+                    val->next = next;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_append(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *val) {\n-   if (yyjson_likely(yyjson_mut_is_arr(arr) && val)) {\n-\t   size_t len = unsafe_yyjson_get_len(arr);\n-\t   unsafe_yyjson_set_len(arr, len + 1);\n-\t   if (len == 0) {\n-\t\t   val->next = val;\n-\t   } else {\n-\t\t   yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n-\t\t   yyjson_mut_val *next = prev->next;\n-\t\t   prev->next = val;\n-\t\t   val->next = next;\n-\t   }\n-\t   arr->uni.ptr = val;\n-\t   return true;\n-   }\n-   return false;\n+                                             yyjson_mut_val *val) {\n+    if (yyjson_likely(yyjson_mut_is_arr(arr) && val)) {\n+        size_t len = unsafe_yyjson_get_len(arr);\n+        unsafe_yyjson_set_len(arr, len + 1);\n+        if (len == 0) {\n+            val->next = val;\n+        } else {\n+            yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n+            yyjson_mut_val *next = prev->next;\n+            prev->next = val;\n+            val->next = next;\n+        }\n+        arr->uni.ptr = val;\n+        return true;\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_prepend(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *val) {\n-   if (yyjson_likely(yyjson_mut_is_arr(arr) && val)) {\n-\t   size_t len = unsafe_yyjson_get_len(arr);\n-\t   unsafe_yyjson_set_len(arr, len + 1);\n-\t   if (len == 0) {\n-\t\t   val->next = val;\n-\t\t   arr->uni.ptr = val;\n-\t   } else {\n-\t\t   yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n-\t\t   yyjson_mut_val *next = prev->next;\n-\t\t   prev->next = val;\n-\t\t   val->next = next;\n-\t   }\n-\t   return true;\n-   }\n-   return false;\n+                                              yyjson_mut_val *val) {\n+    if (yyjson_likely(yyjson_mut_is_arr(arr) && val)) {\n+        size_t len = unsafe_yyjson_get_len(arr);\n+        unsafe_yyjson_set_len(arr, len + 1);\n+        if (len == 0) {\n+            val->next = val;\n+            arr->uni.ptr = val;\n+        } else {\n+            yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n+            yyjson_mut_val *next = prev->next;\n+            prev->next = val;\n+            val->next = next;\n+        }\n+        return true;\n+    }\n+    return false;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_replace(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize_t idx,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *val) {\n-   if (yyjson_likely(yyjson_mut_is_arr(arr) && val)) {\n-\t   size_t len = unsafe_yyjson_get_len(arr);\n-\t   if (yyjson_likely(idx < len)) {\n-\t\t   if (yyjson_likely(len > 1)) {\n-\t\t\t   yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n-\t\t\t   yyjson_mut_val *next = prev->next;\n-\t\t\t   while (idx-- > 0) {\n-\t\t\t\t   prev = next;\n-\t\t\t\t   next = next->next;\n-\t\t\t   }\n-\t\t\t   prev->next = val;\n-\t\t\t   val->next = next->next;\n-\t\t\t   if ((void *)next == arr->uni.ptr) arr->uni.ptr = val;\n-\t\t\t   return next;\n-\t\t   } else {\n-\t\t\t   yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n-\t\t\t   val->next = val;\n-\t\t\t   arr->uni.ptr = val;\n-\t\t\t   return prev;\n-\t\t   }\n-\t   }\n-   }\n-   return NULL;\n+                                                         size_t idx,\n+                                                         yyjson_mut_val *val) {\n+    if (yyjson_likely(yyjson_mut_is_arr(arr) && val)) {\n+        size_t len = unsafe_yyjson_get_len(arr);\n+        if (yyjson_likely(idx < len)) {\n+            if (yyjson_likely(len > 1)) {\n+                yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n+                yyjson_mut_val *next = prev->next;\n+                while (idx-- > 0) {\n+                    prev = next;\n+                    next = next->next;\n+                }\n+                prev->next = val;\n+                val->next = next->next;\n+                if ((void *)next == arr->uni.ptr) arr->uni.ptr = val;\n+                return next;\n+            } else {\n+                yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n+                val->next = val;\n+                arr->uni.ptr = val;\n+                return prev;\n+            }\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_remove(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t   size_t idx) {\n-   if (yyjson_likely(yyjson_mut_is_arr(arr))) {\n-\t   size_t len = unsafe_yyjson_get_len(arr);\n-\t   if (yyjson_likely(idx < len)) {\n-\t\t   unsafe_yyjson_set_len(arr, len - 1);\n-\t\t   if (yyjson_likely(len > 1)) {\n-\t\t\t   yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n-\t\t\t   yyjson_mut_val *next = prev->next;\n-\t\t\t   while (idx-- > 0) {\n-\t\t\t\t   prev = next;\n-\t\t\t\t   next = next->next;\n-\t\t\t   }\n-\t\t\t   prev->next = next->next;\n-\t\t\t   if ((void *)next == arr->uni.ptr) arr->uni.ptr = prev;\n-\t\t\t   return next;\n-\t\t   } else {\n-\t\t\t   return ((yyjson_mut_val *)arr->uni.ptr);\n-\t\t   }\n-\t   }\n-   }\n-   return NULL;\n+                                                        size_t idx) {\n+    if (yyjson_likely(yyjson_mut_is_arr(arr))) {\n+        size_t len = unsafe_yyjson_get_len(arr);\n+        if (yyjson_likely(idx < len)) {\n+            unsafe_yyjson_set_len(arr, len - 1);\n+            if (yyjson_likely(len > 1)) {\n+                yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n+                yyjson_mut_val *next = prev->next;\n+                while (idx-- > 0) {\n+                    prev = next;\n+                    next = next->next;\n+                }\n+                prev->next = next->next;\n+                if ((void *)next == arr->uni.ptr) arr->uni.ptr = prev;\n+                return next;\n+            } else {\n+                return ((yyjson_mut_val *)arr->uni.ptr);\n+            }\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_remove_first(\n-   yyjson_mut_val *arr) {\n-   if (yyjson_likely(yyjson_mut_is_arr(arr))) {\n-\t   size_t len = unsafe_yyjson_get_len(arr);\n-\t   if (len > 1) {\n-\t\t   yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n-\t\t   yyjson_mut_val *next = prev->next;\n-\t\t   prev->next = next->next;\n-\t\t   unsafe_yyjson_set_len(arr, len - 1);\n-\t\t   return next;\n-\t   } else if (len == 1) {\n-\t\t   yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n-\t\t   unsafe_yyjson_set_len(arr, 0);\n-\t\t   return prev;\n-\t   }\n-   }\n-   return NULL;\n+    yyjson_mut_val *arr) {\n+    if (yyjson_likely(yyjson_mut_is_arr(arr))) {\n+        size_t len = unsafe_yyjson_get_len(arr);\n+        if (len > 1) {\n+            yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n+            yyjson_mut_val *next = prev->next;\n+            prev->next = next->next;\n+            unsafe_yyjson_set_len(arr, len - 1);\n+            return next;\n+        } else if (len == 1) {\n+            yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n+            unsafe_yyjson_set_len(arr, 0);\n+            return prev;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_remove_last(\n-   yyjson_mut_val *arr) {\n-   if (yyjson_likely(yyjson_mut_is_arr(arr))) {\n-\t   size_t len = unsafe_yyjson_get_len(arr);\n-\t   if (yyjson_likely(len > 1)) {\n-\t\t   yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n-\t\t   yyjson_mut_val *next = prev->next;\n-\t\t   unsafe_yyjson_set_len(arr, len - 1);\n-\t\t   while (--len > 0) prev = prev->next;\n-\t\t   prev->next = next;\n-\t\t   next = (yyjson_mut_val *)arr->uni.ptr;\n-\t\t   arr->uni.ptr = prev;\n-\t\t   return next;\n-\t   } else if (len == 1) {\n-\t\t   yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n-\t\t   unsafe_yyjson_set_len(arr, 0);\n-\t\t   return prev;\n-\t   }\n-   }\n-   return NULL;\n+    yyjson_mut_val *arr) {\n+    if (yyjson_likely(yyjson_mut_is_arr(arr))) {\n+        size_t len = unsafe_yyjson_get_len(arr);\n+        if (yyjson_likely(len > 1)) {\n+            yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n+            yyjson_mut_val *next = prev->next;\n+            unsafe_yyjson_set_len(arr, len - 1);\n+            while (--len > 0) prev = prev->next;\n+            prev->next = next;\n+            next = (yyjson_mut_val *)arr->uni.ptr;\n+            arr->uni.ptr = prev;\n+            return next;\n+        } else if (len == 1) {\n+            yyjson_mut_val *prev = ((yyjson_mut_val *)arr->uni.ptr);\n+            unsafe_yyjson_set_len(arr, 0);\n+            return prev;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_remove_range(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\t  size_t _idx, size_t _len) {\n-   if (yyjson_likely(yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *prev, *next;\n-\t   bool tail_removed;\n-\t   size_t len = unsafe_yyjson_get_len(arr);\n-\t   if (yyjson_unlikely(_idx + _len > len)) return false;\n-\t   if (yyjson_unlikely(_len == 0)) return true;\n-\t   unsafe_yyjson_set_len(arr, len - _len);\n-\t   if (yyjson_unlikely(len == _len)) return true;\n-\t   tail_removed = (_idx + _len == len);\n-\t   prev = ((yyjson_mut_val *)arr->uni.ptr);\n-\t   while (_idx-- > 0) prev = prev->next;\n-\t   next = prev->next;\n-\t   while (_len-- > 0) next = next->next;\n-\t   prev->next = next;\n-\t   if (yyjson_unlikely(tail_removed)) arr->uni.ptr = prev;\n-\t   return true;\n-   }\n-   return false;\n+                                                   size_t _idx, size_t _len) {\n+    if (yyjson_likely(yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *prev, *next;\n+        bool tail_removed;\n+        size_t len = unsafe_yyjson_get_len(arr);\n+        if (yyjson_unlikely(_idx + _len > len)) return false;\n+        if (yyjson_unlikely(_len == 0)) return true;\n+        unsafe_yyjson_set_len(arr, len - _len);\n+        if (yyjson_unlikely(len == _len)) return true;\n+        tail_removed = (_idx + _len == len);\n+        prev = ((yyjson_mut_val *)arr->uni.ptr);\n+        while (_idx-- > 0) prev = prev->next;\n+        next = prev->next;\n+        while (_len-- > 0) next = next->next;\n+        prev->next = next;\n+        if (yyjson_unlikely(tail_removed)) arr->uni.ptr = prev;\n+        return true;\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_clear(yyjson_mut_val *arr) {\n-   if (yyjson_likely(yyjson_mut_is_arr(arr))) {\n-\t   unsafe_yyjson_set_len(arr, 0);\n-\t   return true;\n-   }\n-   return false;\n+    if (yyjson_likely(yyjson_mut_is_arr(arr))) {\n+        unsafe_yyjson_set_len(arr, 0);\n+        return true;\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_rotate(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\tsize_t idx) {\n-   if (yyjson_likely(yyjson_mut_is_arr(arr) &&\n-\t\t\t\t\t unsafe_yyjson_get_len(arr) > idx)) {\n-\t   yyjson_mut_val *val = (yyjson_mut_val *)arr->uni.ptr;\n-\t   while (idx-- > 0) val = val->next;\n-\t   arr->uni.ptr = (void *)val;\n-\t   return true;\n-   }\n-   return false;\n+                                             size_t idx) {\n+    if (yyjson_likely(yyjson_mut_is_arr(arr) &&\n+                      unsafe_yyjson_get_len(arr) > idx)) {\n+        yyjson_mut_val *val = (yyjson_mut_val *)arr->uni.ptr;\n+        while (idx-- > 0) val = val->next;\n+        arr->uni.ptr = (void *)val;\n+        return true;\n+    }\n+    return false;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Array Modification Convenience API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Array Modification Convenience API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline bool yyjson_mut_arr_add_val(yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *val) {\n-   return yyjson_mut_arr_append(arr, val);\n+                                              yyjson_mut_val *val) {\n+    return yyjson_mut_arr_append(arr, val);\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_null(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_null(doc);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                               yyjson_mut_val *arr) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_null(doc);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_true(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_true(doc);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                               yyjson_mut_val *arr) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_true(doc);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_false(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t   yyjson_mut_val *arr) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_false(doc);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                                yyjson_mut_val *arr) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_false(doc);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_bool(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t  bool _val) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_bool(doc, _val);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                               yyjson_mut_val *arr,\n+                                               bool _val) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_bool(doc, _val);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_uint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t  uint64_t num) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_uint(doc, num);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                               yyjson_mut_val *arr,\n+                                               uint64_t num) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_uint(doc, num);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_sint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t  int64_t num) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_sint(doc, num);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                               yyjson_mut_val *arr,\n+                                               int64_t num) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_sint(doc, num);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_int(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t int64_t num) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_sint(doc, num);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                              yyjson_mut_val *arr,\n+                                              int64_t num) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_sint(doc, num);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_real(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t  double num) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_real(doc, num);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                               yyjson_mut_val *arr,\n+                                               double num) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_real(doc, num);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_str(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t const char *str) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_str(doc, str);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                              yyjson_mut_val *arr,\n+                                              const char *str) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_str(doc, str);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_strn(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *str, size_t len) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_strn(doc, str, len);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                               yyjson_mut_val *arr,\n+                                               const char *str, size_t len) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_strn(doc, str, len);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_strcpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *str) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_strcpy(doc, str);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                                 yyjson_mut_val *arr,\n+                                                 const char *str) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_strcpy(doc, str);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_arr_add_strncpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *arr,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *str, size_t len) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_strncpy(doc, str, len);\n-\t   return yyjson_mut_arr_append(arr, val);\n-   }\n-   return false;\n+                                                  yyjson_mut_val *arr,\n+                                                  const char *str, size_t len) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_strncpy(doc, str, len);\n+        return yyjson_mut_arr_append(arr, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_add_arr(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *arr) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_arr(doc);\n-\t   return yyjson_mut_arr_append(arr, val) ? val : NULL;\n-   }\n-   return NULL;\n+                                                         yyjson_mut_val *arr) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_arr(doc);\n+        return yyjson_mut_arr_append(arr, val) ? val : NULL;\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_arr_add_obj(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *arr) {\n-   if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n-\t   yyjson_mut_val *val = yyjson_mut_obj(doc);\n-\t   return yyjson_mut_arr_append(arr, val) ? val : NULL;\n-   }\n-   return NULL;\n+                                                         yyjson_mut_val *arr) {\n+    if (yyjson_likely(doc && yyjson_mut_is_arr(arr))) {\n+        yyjson_mut_val *val = yyjson_mut_obj(doc);\n+        return yyjson_mut_arr_append(arr, val) ? val : NULL;\n+    }\n+    return NULL;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Object API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Object API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline size_t yyjson_mut_obj_size(yyjson_mut_val *obj) {\n-   return yyjson_mut_is_obj(obj) ? unsafe_yyjson_get_len(obj) : 0;\n+    return yyjson_mut_is_obj(obj) ? unsafe_yyjson_get_len(obj) : 0;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_get(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *key) {\n-   return yyjson_mut_obj_getn(obj, key, key ? strlen(key) : 0);\n+                                                     const char *key) {\n+    return yyjson_mut_obj_getn(obj, key, key ? strlen(key) : 0);\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_getn(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t const char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t size_t key_len) {\n-   uint64_t tag = (((uint64_t)key_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-   size_t len = yyjson_mut_obj_size(obj);\n-   if (yyjson_likely(len && _key)) {\n-\t   yyjson_mut_val *key = ((yyjson_mut_val *)obj->uni.ptr)->next->next;\n-\t   while (len-- > 0) {\n-\t\t   if (key->tag == tag &&\n-\t\t\t   duckdb::FastMemcmp(key->uni.ptr, _key, key_len) == 0) {\n-\t\t\t   return key->next;\n-\t\t   }\n-\t\t   key = key->next->next;\n-\t   }\n-   }\n-   return NULL;\n+                                                      const char *_key,\n+                                                      size_t key_len) {\n+    uint64_t tag = (((uint64_t)key_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+    size_t len = yyjson_mut_obj_size(obj);\n+    if (yyjson_likely(len && _key)) {\n+        yyjson_mut_val *key = ((yyjson_mut_val *)obj->uni.ptr)->next->next;\n+        while (len-- > 0) {\n+            if (key->tag == tag &&\n+                duckdb::FastMemcmp(key->uni.ptr, _key, key_len) == 0) {\n+                return key->next;\n+            }\n+            key = key->next->next;\n+        }\n+    }\n+    return NULL;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Object Iterator API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Object Iterator API (Implementation)\n+ *============================================================================*/\n \n struct yyjson_mut_obj_iter {\n-   size_t idx; /**< current key index, from 0 */\n-   size_t max; /**< maximum key index, idx < max */\n-   yyjson_mut_val *cur; /**< current key */\n-   yyjson_mut_val *pre; /**< previous key */\n-   yyjson_mut_val *obj; /**< the object being iterated */\n+    size_t idx; /**< current key index, from 0 */\n+    size_t max; /**< maximum key index, idx < max */\n+    yyjson_mut_val *cur; /**< current key */\n+    yyjson_mut_val *pre; /**< previous key */\n+    yyjson_mut_val *obj; /**< the object being iterated */\n };\n \n yyjson_api_inline bool yyjson_mut_obj_iter_init(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t   yyjson_mut_obj_iter *iter) {\n-   if (yyjson_likely(yyjson_mut_is_obj(obj) && iter)) {\n-\t   iter->idx = 0;\n-\t   iter->max = unsafe_yyjson_get_len(obj);\n-\t   iter->cur = iter->max ? (yyjson_mut_val *)obj->uni.ptr : NULL;\n-\t   iter->pre = NULL;\n-\t   iter->obj = obj;\n-\t   return true;\n-   }\n-   if (iter) memset(iter, 0, sizeof(yyjson_mut_obj_iter));\n-   return false;\n+                                                yyjson_mut_obj_iter *iter) {\n+    if (yyjson_likely(yyjson_mut_is_obj(obj) && iter)) {\n+        iter->idx = 0;\n+        iter->max = unsafe_yyjson_get_len(obj);\n+        iter->cur = iter->max ? (yyjson_mut_val *)obj->uni.ptr : NULL;\n+        iter->pre = NULL;\n+        iter->obj = obj;\n+        return true;\n+    }\n+    if (iter) memset(iter, 0, sizeof(yyjson_mut_obj_iter));\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_obj_iter_has_next(yyjson_mut_obj_iter *iter) {\n-   return iter ? iter->idx < iter->max : false;\n+    return iter ? iter->idx < iter->max : false;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_iter_next(\n-   yyjson_mut_obj_iter *iter) {\n-   if (iter && iter->idx < iter->max) {\n-\t   yyjson_mut_val *key = iter->cur;\n-\t   iter->pre = key;\n-\t   iter->cur = key->next->next;\n-\t   iter->idx++;\n-\t   return iter->cur;\n-   }\n-   return NULL;\n+    yyjson_mut_obj_iter *iter) {\n+    if (iter && iter->idx < iter->max) {\n+        yyjson_mut_val *key = iter->cur;\n+        iter->pre = key;\n+        iter->cur = key->next->next;\n+        iter->idx++;\n+        return iter->cur;\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_iter_get_val(\n-   yyjson_mut_val *key) {\n-   return key ? key->next : NULL;\n+    yyjson_mut_val *key) {\n+    return key ? key->next : NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_iter_remove(\n-   yyjson_mut_obj_iter *iter) {\n-   if (yyjson_likely(iter && 0 < iter->idx && iter->idx <= iter->max)) {\n-\t   yyjson_mut_val *prev = iter->pre;\n-\t   yyjson_mut_val *cur = iter->cur;\n-\t   yyjson_mut_val *next = cur->next->next;\n-\t   if (yyjson_unlikely(iter->idx == iter->max)) iter->obj->uni.ptr = prev;\n-\t   iter->idx--;\n-\t   iter->max--;\n-\t   unsafe_yyjson_set_len(iter->obj, iter->max);\n-\t   prev->next->next = next;\n-\t   iter->cur = next;\n-\t   return cur;\n-   }\n-   return NULL;\n+    yyjson_mut_obj_iter *iter) {\n+    if (yyjson_likely(iter && 0 < iter->idx && iter->idx <= iter->max)) {\n+        yyjson_mut_val *prev = iter->pre;\n+        yyjson_mut_val *cur = iter->cur;\n+        yyjson_mut_val *next = cur->next->next;\n+        if (yyjson_unlikely(iter->idx == iter->max)) iter->obj->uni.ptr = prev;\n+        iter->idx--;\n+        iter->max--;\n+        unsafe_yyjson_set_len(iter->obj, iter->max);\n+        prev->next->next = next;\n+        iter->cur = next;\n+        return cur;\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_iter_get(\n-   yyjson_mut_obj_iter *iter, const char *key) {\n-   return yyjson_mut_obj_iter_getn(iter, key, key ? strlen(key) : 0);\n+    yyjson_mut_obj_iter *iter, const char *key) {\n+    return yyjson_mut_obj_iter_getn(iter, key, key ? strlen(key) : 0);\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_iter_getn(\n-   yyjson_mut_obj_iter *iter, const char *key, size_t key_len) {\n-   if (iter && key) {\n-\t   size_t idx = 0;\n-\t   size_t max = iter->max;\n-\t   yyjson_mut_val *pre, *cur = iter->cur;\n-\t   while (idx++ < max) {\n-\t\t   pre = cur;\n-\t\t   cur = cur->next->next;\n-\t\t   if (unsafe_yyjson_get_len(cur) == key_len &&\n-\t\t\t   duckdb::FastMemcmp(cur->uni.str, key, key_len) == 0) {\n-\t\t\t   iter->idx += idx;\n-\t\t\t   if (iter->idx > max) iter->idx -= max + 1;\n-\t\t\t   iter->pre = pre;\n-\t\t\t   iter->cur = cur;\n-\t\t\t   return cur->next;\n-\t\t   }\n-\t   }\n-   }\n-   return NULL;\n+    yyjson_mut_obj_iter *iter, const char *key, size_t key_len) {\n+    if (iter && key) {\n+        size_t idx = 0;\n+        size_t max = iter->max;\n+        yyjson_mut_val *pre, *cur = iter->cur;\n+        while (idx++ < max) {\n+            pre = cur;\n+            cur = cur->next->next;\n+            if (unsafe_yyjson_get_len(cur) == key_len &&\n+                duckdb::FastMemcmp(cur->uni.str, key, key_len) == 0) {\n+                iter->idx += idx;\n+                if (iter->idx > max) iter->idx -= max + 1;\n+                iter->pre = pre;\n+                iter->cur = cur;\n+                return cur->next;\n+            }\n+        }\n+    }\n+    return NULL;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Object Creation API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Object Creation API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj(yyjson_mut_doc *doc) {\n-   if (yyjson_likely(doc)) {\n-\t   yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n-\t   if (yyjson_likely(val)) {\n-\t\t   val->tag = YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE;\n-\t\t   return val;\n-\t   }\n-   }\n-   return NULL;\n+    if (yyjson_likely(doc)) {\n+        yyjson_mut_val *val = unsafe_yyjson_mut_val(doc, 1);\n+        if (yyjson_likely(val)) {\n+            val->tag = YYJSON_TYPE_OBJ | YYJSON_SUBTYPE_NONE;\n+            return val;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_with_str(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t const char **keys,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t const char **vals,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t size_t count) {\n-   if (yyjson_likely(doc && ((count > 0 && keys && vals) || (count == 0)))) {\n-\t   yyjson_mut_val *obj = unsafe_yyjson_mut_val(doc, 1 + count * 2);\n-\t   if (yyjson_likely(obj)) {\n-\t\t   obj->tag = ((uint64_t)count << YYJSON_TAG_BIT) | YYJSON_TYPE_OBJ;\n-\t\t   if (count > 0) {\n-\t\t\t   size_t i;\n-\t\t\t   for (i = 0; i < count; i++) {\n-\t\t\t\t   yyjson_mut_val *key = obj + (i * 2 + 1);\n-\t\t\t\t   yyjson_mut_val *val = obj + (i * 2 + 2);\n-\t\t\t\t   uint64_t key_len = (uint64_t)strlen(keys[i]);\n-\t\t\t\t   uint64_t val_len = (uint64_t)strlen(vals[i]);\n-\t\t\t\t   key->tag = (key_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t\t\t\t   val->tag = (val_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t\t\t\t   key->uni.str = keys[i];\n-\t\t\t\t   val->uni.str = vals[i];\n-\t\t\t\t   key->next = val;\n-\t\t\t\t   val->next = val + 1;\n-\t\t\t   }\n-\t\t\t   obj[count * 2].next = obj + 1;\n-\t\t\t   obj->uni.ptr = obj + (count * 2 - 1);\n-\t\t   }\n-\t\t   return obj;\n-\t   }\n-   }\n-   return NULL;\n+                                                          const char **keys,\n+                                                          const char **vals,\n+                                                          size_t count) {\n+    if (yyjson_likely(doc && ((count > 0 && keys && vals) || (count == 0)))) {\n+        yyjson_mut_val *obj = unsafe_yyjson_mut_val(doc, 1 + count * 2);\n+        if (yyjson_likely(obj)) {\n+            obj->tag = ((uint64_t)count << YYJSON_TAG_BIT) | YYJSON_TYPE_OBJ;\n+            if (count > 0) {\n+                size_t i;\n+                for (i = 0; i < count; i++) {\n+                    yyjson_mut_val *key = obj + (i * 2 + 1);\n+                    yyjson_mut_val *val = obj + (i * 2 + 2);\n+                    uint64_t key_len = (uint64_t)strlen(keys[i]);\n+                    uint64_t val_len = (uint64_t)strlen(vals[i]);\n+                    key->tag = (key_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+                    val->tag = (val_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+                    key->uni.str = keys[i];\n+                    val->uni.str = vals[i];\n+                    key->next = val;\n+                    val->next = val + 1;\n+                }\n+                obj[count * 2].next = obj + 1;\n+                obj->uni.ptr = obj + (count * 2 - 1);\n+            }\n+            return obj;\n+        }\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_with_kv(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst char **pairs,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize_t count) {\n-   if (yyjson_likely(doc && ((count > 0 && pairs) || (count == 0)))) {\n-\t   yyjson_mut_val *obj = unsafe_yyjson_mut_val(doc, 1 + count * 2);\n-\t   if (yyjson_likely(obj)) {\n-\t\t   obj->tag = ((uint64_t)count << YYJSON_TAG_BIT) | YYJSON_TYPE_OBJ;\n-\t\t   if (count > 0) {\n-\t\t\t   size_t i;\n-\t\t\t   for (i = 0; i < count; i++) {\n-\t\t\t\t   yyjson_mut_val *key = obj + (i * 2 + 1);\n-\t\t\t\t   yyjson_mut_val *val = obj + (i * 2 + 2);\n-\t\t\t\t   const char *key_str = pairs[i * 2 + 0];\n-\t\t\t\t   const char *val_str = pairs[i * 2 + 1];\n-\t\t\t\t   uint64_t key_len = (uint64_t)strlen(key_str);\n-\t\t\t\t   uint64_t val_len = (uint64_t)strlen(val_str);\n-\t\t\t\t   key->tag = (key_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t\t\t\t   val->tag = (val_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t\t\t\t   key->uni.str = key_str;\n-\t\t\t\t   val->uni.str = val_str;\n-\t\t\t\t   key->next = val;\n-\t\t\t\t   val->next = val + 1;\n-\t\t\t   }\n-\t\t\t   obj[count * 2].next = obj + 1;\n-\t\t\t   obj->uni.ptr = obj + (count * 2 - 1);\n-\t\t   }\n-\t\t   return obj;\n-\t   }\n-   }\n-   return NULL;\n+                                                         const char **pairs,\n+                                                         size_t count) {\n+    if (yyjson_likely(doc && ((count > 0 && pairs) || (count == 0)))) {\n+        yyjson_mut_val *obj = unsafe_yyjson_mut_val(doc, 1 + count * 2);\n+        if (yyjson_likely(obj)) {\n+            obj->tag = ((uint64_t)count << YYJSON_TAG_BIT) | YYJSON_TYPE_OBJ;\n+            if (count > 0) {\n+                size_t i;\n+                for (i = 0; i < count; i++) {\n+                    yyjson_mut_val *key = obj + (i * 2 + 1);\n+                    yyjson_mut_val *val = obj + (i * 2 + 2);\n+                    const char *key_str = pairs[i * 2 + 0];\n+                    const char *val_str = pairs[i * 2 + 1];\n+                    uint64_t key_len = (uint64_t)strlen(key_str);\n+                    uint64_t val_len = (uint64_t)strlen(val_str);\n+                    key->tag = (key_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+                    val->tag = (val_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+                    key->uni.str = key_str;\n+                    val->uni.str = val_str;\n+                    key->next = val;\n+                    val->next = val + 1;\n+                }\n+                obj[count * 2].next = obj + 1;\n+                obj->uni.ptr = obj + (count * 2 - 1);\n+            }\n+            return obj;\n+        }\n+    }\n+    return NULL;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Object Modification API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Object Modification API (Implementation)\n+ *============================================================================*/\n \n yyjson_api_inline void unsafe_yyjson_mut_obj_add(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *key,\n-\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\tsize_t len) {\n-   if (yyjson_likely(len)) {\n-\t   yyjson_mut_val *prev_val = ((yyjson_mut_val *)obj->uni.ptr)->next;\n-\t   yyjson_mut_val *next_key = prev_val->next;\n-\t   prev_val->next = key;\n-\t   val->next = next_key;\n-   } else {\n-\t   val->next = key;\n-   }\n-   key->next = val;\n-   obj->uni.ptr = (void *)key;\n-   unsafe_yyjson_set_len(obj, len + 1);\n+                                                 yyjson_mut_val *key,\n+                                                 yyjson_mut_val *val,\n+                                                 size_t len) {\n+    if (yyjson_likely(len)) {\n+        yyjson_mut_val *prev_val = ((yyjson_mut_val *)obj->uni.ptr)->next;\n+        yyjson_mut_val *next_key = prev_val->next;\n+        prev_val->next = key;\n+        val->next = next_key;\n+    } else {\n+        val->next = key;\n+    }\n+    key->next = val;\n+    obj->uni.ptr = (void *)key;\n+    unsafe_yyjson_set_len(obj, len + 1);\n }\n \n yyjson_api_inline yyjson_mut_val *unsafe_yyjson_mut_obj_remove(\n-   yyjson_mut_val *obj, const char *key, size_t key_len, uint64_t key_tag) {\n-   size_t obj_len = unsafe_yyjson_get_len(obj);\n-   if (obj_len) {\n-\t   yyjson_mut_val *pre_key = (yyjson_mut_val *)obj->uni.ptr;\n-\t   yyjson_mut_val *cur_key = pre_key->next->next;\n-\t   yyjson_mut_val *removed_item = NULL;\n-\t   size_t i;\n-\t   for (i = 0; i < obj_len; i++) {\n-\t\t   if (key_tag == cur_key->tag &&\n-\t\t\t   duckdb::FastMemcmp(key, cur_key->uni.ptr, key_len) == 0) {\n-\t\t\t   if (!removed_item) removed_item = cur_key->next;\n-\t\t\t   cur_key = cur_key->next->next;\n-\t\t\t   pre_key->next->next = cur_key;\n-\t\t\t   if (i + 1 == obj_len) obj->uni.ptr = pre_key;\n-\t\t\t   i--;\n-\t\t\t   obj_len--;\n-\t\t   } else {\n-\t\t\t   pre_key = cur_key;\n-\t\t\t   cur_key = cur_key->next->next;\n-\t\t   }\n-\t   }\n-\t   unsafe_yyjson_set_len(obj, obj_len);\n-\t   return removed_item;\n-   } else {\n-\t   return NULL;\n-   }\n+    yyjson_mut_val *obj, const char *key, size_t key_len, uint64_t key_tag) {\n+    size_t obj_len = unsafe_yyjson_get_len(obj);\n+    if (obj_len) {\n+        yyjson_mut_val *pre_key = (yyjson_mut_val *)obj->uni.ptr;\n+        yyjson_mut_val *cur_key = pre_key->next->next;\n+        yyjson_mut_val *removed_item = NULL;\n+        size_t i;\n+        for (i = 0; i < obj_len; i++) {\n+            if (key_tag == cur_key->tag &&\n+                duckdb::FastMemcmp(key, cur_key->uni.ptr, key_len) == 0) {\n+                if (!removed_item) removed_item = cur_key->next;\n+                cur_key = cur_key->next->next;\n+                pre_key->next->next = cur_key;\n+                if (i + 1 == obj_len) obj->uni.ptr = pre_key;\n+                i--;\n+                obj_len--;\n+            } else {\n+                pre_key = cur_key;\n+                cur_key = cur_key->next->next;\n+            }\n+        }\n+        unsafe_yyjson_set_len(obj, obj_len);\n+        return removed_item;\n+    } else {\n+        return NULL;\n+    }\n }\n \n yyjson_api_inline bool unsafe_yyjson_mut_obj_replace(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *key,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *val) {\n-   size_t key_len = unsafe_yyjson_get_len(key);\n-   size_t obj_len = unsafe_yyjson_get_len(obj);\n-   if (obj_len) {\n-\t   yyjson_mut_val *pre_key = (yyjson_mut_val *)obj->uni.ptr;\n-\t   yyjson_mut_val *cur_key = pre_key->next->next;\n-\t   size_t i;\n-\t   for (i = 0; i < obj_len; i++) {\n-\t\t   if (key->tag == cur_key->tag &&\n-\t\t\t   duckdb::FastMemcmp(key->uni.str, cur_key->uni.ptr, key_len) == 0) {\n-\t\t\t   cur_key->next->tag = val->tag;\n-\t\t\t   cur_key->next->uni.u64 = val->uni.u64;\n-\t\t\t   return true;\n-\t\t   } else {\n-\t\t\t   cur_key = cur_key->next->next;\n-\t\t   }\n-\t   }\n-   }\n-   return false;\n+                                                     yyjson_mut_val *key,\n+                                                     yyjson_mut_val *val) {\n+    size_t key_len = unsafe_yyjson_get_len(key);\n+    size_t obj_len = unsafe_yyjson_get_len(obj);\n+    if (obj_len) {\n+        yyjson_mut_val *pre_key = (yyjson_mut_val *)obj->uni.ptr;\n+        yyjson_mut_val *cur_key = pre_key->next->next;\n+        size_t i;\n+        for (i = 0; i < obj_len; i++) {\n+            if (key->tag == cur_key->tag &&\n+                duckdb::FastMemcmp(key->uni.str, cur_key->uni.ptr, key_len) == 0) {\n+                cur_key->next->tag = val->tag;\n+                cur_key->next->uni.u64 = val->uni.u64;\n+                return true;\n+            } else {\n+                cur_key = cur_key->next->next;\n+            }\n+        }\n+    }\n+    return false;\n }\n \n yyjson_api_inline void unsafe_yyjson_mut_obj_rotate(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\t   size_t idx) {\n-   yyjson_mut_val *key = (yyjson_mut_val *)obj->uni.ptr;\n-   while (idx-- > 0) key = key->next->next;\n-   obj->uni.ptr = (void *)key;\n+                                                    size_t idx) {\n+    yyjson_mut_val *key = (yyjson_mut_val *)obj->uni.ptr;\n+    while (idx-- > 0) key = key->next->next;\n+    obj->uni.ptr = (void *)key;\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *key,\n-\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *val) {\n-   if (yyjson_likely(yyjson_mut_is_obj(obj) &&\n-\t\t\t\t\t yyjson_mut_is_str(key) && val)) {\n-\t   unsafe_yyjson_mut_obj_add(obj, key, val, unsafe_yyjson_get_len(obj));\n-\t   return true;\n-   }\n-   return false;\n+                                          yyjson_mut_val *key,\n+                                          yyjson_mut_val *val) {\n+    if (yyjson_likely(yyjson_mut_is_obj(obj) &&\n+                      yyjson_mut_is_str(key) && val)) {\n+        unsafe_yyjson_mut_obj_add(obj, key, val, unsafe_yyjson_get_len(obj));\n+        return true;\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_obj_put(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *key,\n-\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *val) {\n-   if (yyjson_likely(yyjson_mut_is_obj(obj) &&\n-\t\t\t\t\t yyjson_mut_is_str(key))) {\n-\t   unsafe_yyjson_mut_obj_remove(obj, key->uni.str,\n-\t\t\t\t\t\t\t\t\tunsafe_yyjson_get_len(key), key->tag);\n-\t   if (yyjson_likely(val)) {\n-\t\t   unsafe_yyjson_mut_obj_add(obj, key, val,\n-\t\t\t\t\t\t\t\t\t unsafe_yyjson_get_len(obj));\n-\t   }\n-\t   return true;\n-   }\n-   return false;\n+                                          yyjson_mut_val *key,\n+                                          yyjson_mut_val *val) {\n+    if (yyjson_likely(yyjson_mut_is_obj(obj) &&\n+                      yyjson_mut_is_str(key))) {\n+        unsafe_yyjson_mut_obj_remove(obj, key->uni.str,\n+                                     unsafe_yyjson_get_len(key), key->tag);\n+        if (yyjson_likely(val)) {\n+            unsafe_yyjson_mut_obj_add(obj, key, val,\n+                                      unsafe_yyjson_get_len(obj));\n+        }\n+        return true;\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_obj_insert(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *key,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\tsize_t idx) {\n-   if (yyjson_likely(yyjson_mut_is_obj(obj) &&\n-\t\t\t\t\t yyjson_mut_is_str(key) && val)) {\n-\t   size_t len = unsafe_yyjson_get_len(obj);\n-\t   if (yyjson_likely(len >= idx)) {\n-\t\t   if (len > idx) {\n-\t\t\t   void *ptr = obj->uni.ptr;\n-\t\t\t   unsafe_yyjson_mut_obj_rotate(obj, idx);\n-\t\t\t   unsafe_yyjson_mut_obj_add(obj, key, val, len);\n-\t\t\t   obj->uni.ptr = ptr;\n-\t\t   } else {\n-\t\t\t   unsafe_yyjson_mut_obj_add(obj, key, val, len);\n-\t\t   }\n-\t\t   return true;\n-\t   }\n-   }\n-   return false;\n+                                             yyjson_mut_val *key,\n+                                             yyjson_mut_val *val,\n+                                             size_t idx) {\n+    if (yyjson_likely(yyjson_mut_is_obj(obj) &&\n+                      yyjson_mut_is_str(key) && val)) {\n+        size_t len = unsafe_yyjson_get_len(obj);\n+        if (yyjson_likely(len >= idx)) {\n+            if (len > idx) {\n+                void *ptr = obj->uni.ptr;\n+                unsafe_yyjson_mut_obj_rotate(obj, idx);\n+                unsafe_yyjson_mut_obj_add(obj, key, val, len);\n+                obj->uni.ptr = ptr;\n+            } else {\n+                unsafe_yyjson_mut_obj_add(obj, key, val, len);\n+            }\n+            return true;\n+        }\n+    }\n+    return false;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_remove(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t   yyjson_mut_val *key) {\n-   if (yyjson_likely(yyjson_mut_is_obj(obj) && yyjson_mut_is_str(key))) {\n-\t   return unsafe_yyjson_mut_obj_remove(obj, key->uni.str,\n-\t\t\t\t\t\t\t\t\t\t   unsafe_yyjson_get_len(key),\n-\t\t\t\t\t\t\t\t\t\t   key->tag);\n-   }\n-   return NULL;\n+    yyjson_mut_val *key) {\n+    if (yyjson_likely(yyjson_mut_is_obj(obj) && yyjson_mut_is_str(key))) {\n+        return unsafe_yyjson_mut_obj_remove(obj, key->uni.str,\n+                                            unsafe_yyjson_get_len(key),\n+                                            key->tag);\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_remove_key(\n-   yyjson_mut_val *obj, const char *key) {\n-   if (yyjson_likely(yyjson_mut_is_obj(obj) && key)) {\n-\t   size_t key_len = strlen(key);\n-\t   uint64_t tag = ((uint64_t)key_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t   return unsafe_yyjson_mut_obj_remove(obj, key, key_len, tag);\n-   }\n-   return NULL;\n+    yyjson_mut_val *obj, const char *key) {\n+    if (yyjson_likely(yyjson_mut_is_obj(obj) && key)) {\n+        size_t key_len = strlen(key);\n+        uint64_t tag = ((uint64_t)key_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+        return unsafe_yyjson_mut_obj_remove(obj, key, key_len, tag);\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_remove_keyn(\n-   yyjson_mut_val *obj, const char *key, size_t key_len) {\n-   if (yyjson_likely(yyjson_mut_is_obj(obj) && key)) {\n-\t   uint64_t tag = ((uint64_t)key_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t   return unsafe_yyjson_mut_obj_remove(obj, key, key_len, tag);\n-   }\n-   return NULL;\n+    yyjson_mut_val *obj, const char *key, size_t key_len) {\n+    if (yyjson_likely(yyjson_mut_is_obj(obj) && key)) {\n+        uint64_t tag = ((uint64_t)key_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+        return unsafe_yyjson_mut_obj_remove(obj, key, key_len, tag);\n+    }\n+    return NULL;\n }\n \n yyjson_api_inline bool yyjson_mut_obj_clear(yyjson_mut_val *obj) {\n-   if (yyjson_likely(yyjson_mut_is_obj(obj))) {\n-\t   unsafe_yyjson_set_len(obj, 0);\n-\t   return true;\n-   }\n-   return false;\n+    if (yyjson_likely(yyjson_mut_is_obj(obj))) {\n+        unsafe_yyjson_set_len(obj, 0);\n+        return true;\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_obj_replace(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *key,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *val) {\n-   if (yyjson_likely(yyjson_mut_is_obj(obj) &&\n-\t\t\t\t\t yyjson_mut_is_str(key) && val)) {\n-\t   return unsafe_yyjson_mut_obj_replace(obj, key, val);\n-   }\n-   return false;\n+                                              yyjson_mut_val *key,\n+                                              yyjson_mut_val *val) {\n+    if (yyjson_likely(yyjson_mut_is_obj(obj) &&\n+                      yyjson_mut_is_str(key) && val)) {\n+        return unsafe_yyjson_mut_obj_replace(obj, key, val);\n+    }\n+    return false;\n }\n \n yyjson_api_inline bool yyjson_mut_obj_rotate(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\tsize_t idx) {\n-   if (yyjson_likely(yyjson_mut_is_obj(obj) &&\n-\t\t\t\t\t unsafe_yyjson_get_len(obj) > idx)) {\n-\t   unsafe_yyjson_mut_obj_rotate(obj, idx);\n-\t   return true;\n-   }\n-   return false;\n+                                             size_t idx) {\n+    if (yyjson_likely(yyjson_mut_is_obj(obj) &&\n+                      unsafe_yyjson_get_len(obj) > idx)) {\n+        unsafe_yyjson_mut_obj_rotate(obj, idx);\n+        return true;\n+    }\n+    return false;\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Object Modification Convenience API (Implementation)\n-*============================================================================*/\n+ * Mutable JSON Object Modification Convenience API (Implementation)\n+ *============================================================================*/\n \n #define yyjson_mut_obj_add_func(func) \\\n-   if (yyjson_likely(doc && yyjson_mut_is_obj(obj) && _key)) { \\\n-\t   yyjson_mut_val *key = unsafe_yyjson_mut_val(doc, 2); \\\n-\t   if (yyjson_likely(key)) { \\\n-\t\t   size_t len = unsafe_yyjson_get_len(obj); \\\n-\t\t   yyjson_mut_val *val = key + 1; \\\n-\t\t   key->tag = YYJSON_TYPE_STR | YYJSON_SUBTYPE_NONE; \\\n-\t\t   key->tag |= (uint64_t)strlen(_key) << YYJSON_TAG_BIT; \\\n-\t\t   key->uni.str = _key; \\\n-\t\t   func \\\n-\t\t   unsafe_yyjson_mut_obj_add(obj, key, val, len); \\\n-\t\t   return true; \\\n-\t   } \\\n-   } \\\n-   return false\n+    if (yyjson_likely(doc && yyjson_mut_is_obj(obj) && _key)) { \\\n+        yyjson_mut_val *key = unsafe_yyjson_mut_val(doc, 2); \\\n+        if (yyjson_likely(key)) { \\\n+            size_t len = unsafe_yyjson_get_len(obj); \\\n+            yyjson_mut_val *val = key + 1; \\\n+            key->tag = YYJSON_TYPE_STR | YYJSON_SUBTYPE_NONE; \\\n+            key->tag |= (uint64_t)strlen(_key) << YYJSON_TAG_BIT; \\\n+            key->uni.str = _key; \\\n+            func \\\n+            unsafe_yyjson_mut_obj_add(obj, key, val, len); \\\n+            return true; \\\n+        } \\\n+    } \\\n+    return false\n \n yyjson_api_inline bool yyjson_mut_obj_add_null(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *_key) {\n-   yyjson_mut_obj_add_func({\n-\t   val->tag = YYJSON_TYPE_NULL | YYJSON_SUBTYPE_NONE;\n-   });\n+                                               yyjson_mut_val *obj,\n+                                               const char *_key) {\n+    yyjson_mut_obj_add_func({\n+        val->tag = YYJSON_TYPE_NULL | YYJSON_SUBTYPE_NONE;\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_true(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *_key) {\n-   yyjson_mut_obj_add_func({\n-\t   val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_TRUE;\n-   });\n+                                               yyjson_mut_val *obj,\n+                                               const char *_key) {\n+    yyjson_mut_obj_add_func({\n+        val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_TRUE;\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_false(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t   yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t   const char *_key) {\n-   yyjson_mut_obj_add_func({\n-\t   val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_FALSE;\n-   });\n+                                                yyjson_mut_val *obj,\n+                                                const char *_key) {\n+    yyjson_mut_obj_add_func({\n+        val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_FALSE;\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_bool(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t  bool _val) {\n-   yyjson_mut_obj_add_func({\n-\t   val->tag = YYJSON_TYPE_BOOL | (uint8_t)((uint8_t)(_val) << 3);\n-   });\n+                                               yyjson_mut_val *obj,\n+                                               const char *_key,\n+                                               bool _val) {\n+    yyjson_mut_obj_add_func({\n+        val->tag = YYJSON_TYPE_BOOL | (uint8_t)((uint8_t)(_val) << 3);\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_uint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t  uint64_t _val) {\n-   yyjson_mut_obj_add_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n-\t   val->uni.u64 = _val;\n-   });\n+                                               yyjson_mut_val *obj,\n+                                               const char *_key,\n+                                               uint64_t _val) {\n+    yyjson_mut_obj_add_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_UINT;\n+        val->uni.u64 = _val;\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_sint(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t  int64_t _val) {\n-   yyjson_mut_obj_add_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n-\t   val->uni.i64 = _val;\n-   });\n+                                               yyjson_mut_val *obj,\n+                                               const char *_key,\n+                                               int64_t _val) {\n+    yyjson_mut_obj_add_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n+        val->uni.i64 = _val;\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_int(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t const char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t int64_t _val) {\n-   yyjson_mut_obj_add_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n-\t   val->uni.i64 = _val;\n-   });\n+                                              yyjson_mut_val *obj,\n+                                              const char *_key,\n+                                              int64_t _val) {\n+    yyjson_mut_obj_add_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_SINT;\n+        val->uni.i64 = _val;\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_real(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t  double _val) {\n-   yyjson_mut_obj_add_func({\n-\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n-\t   val->uni.f64 = _val;\n-   });\n+                                               yyjson_mut_val *obj,\n+                                               const char *_key,\n+                                               double _val) {\n+    yyjson_mut_obj_add_func({\n+        val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n+        val->uni.f64 = _val;\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_str(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t const char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t const char *_val) {\n-   if (yyjson_unlikely(!_val)) return false;\n-   yyjson_mut_obj_add_func({\n-\t   val->tag = ((uint64_t)strlen(_val) << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t   val->uni.str = _val;\n-   });\n+                                              yyjson_mut_val *obj,\n+                                              const char *_key,\n+                                              const char *_val) {\n+    if (yyjson_unlikely(!_val)) return false;\n+    yyjson_mut_obj_add_func({\n+        val->tag = ((uint64_t)strlen(_val) << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+        val->uni.str = _val;\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_strn(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t  const char *_val,\n-\t\t\t\t\t\t\t\t\t\t\t  size_t _len) {\n-   if (yyjson_unlikely(!_val)) return false;\n-   yyjson_mut_obj_add_func({\n-\t   val->tag = ((uint64_t)_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t   val->uni.str = _val;\n-   });\n+                                               yyjson_mut_val *obj,\n+                                               const char *_key,\n+                                               const char *_val,\n+                                               size_t _len) {\n+    if (yyjson_unlikely(!_val)) return false;\n+    yyjson_mut_obj_add_func({\n+        val->tag = ((uint64_t)_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+        val->uni.str = _val;\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_strcpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\tyyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *_val) {\n-   if (yyjson_unlikely(!_val)) return false;\n-   yyjson_mut_obj_add_func({\n-\t   size_t _len = strlen(_val);\n-\t   val->uni.str = unsafe_yyjson_mut_strncpy(doc, _val, _len);\n-\t   if (yyjson_unlikely(!val->uni.str)) return false;\n-\t   val->tag = ((uint64_t)_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-   });\n+                                                 yyjson_mut_val *obj,\n+                                                 const char *_key,\n+                                                 const char *_val) {\n+    if (yyjson_unlikely(!_val)) return false;\n+    yyjson_mut_obj_add_func({\n+        size_t _len = strlen(_val);\n+        val->uni.str = unsafe_yyjson_mut_strncpy(doc, _val, _len);\n+        if (yyjson_unlikely(!val->uni.str)) return false;\n+        val->tag = ((uint64_t)_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_strncpy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *_val,\n-\t\t\t\t\t\t\t\t\t\t\t\t size_t _len) {\n-   if (yyjson_unlikely(!_val)) return false;\n-   yyjson_mut_obj_add_func({\n-\t   val->uni.str = unsafe_yyjson_mut_strncpy(doc, _val, _len);\n-\t   if (yyjson_unlikely(!val->uni.str)) return false;\n-\t   val->tag = ((uint64_t)_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-   });\n+                                                  yyjson_mut_val *obj,\n+                                                  const char *_key,\n+                                                  const char *_val,\n+                                                  size_t _len) {\n+    if (yyjson_unlikely(!_val)) return false;\n+    yyjson_mut_obj_add_func({\n+        val->uni.str = unsafe_yyjson_mut_strncpy(doc, _val, _len);\n+        if (yyjson_unlikely(!val->uni.str)) return false;\n+        val->tag = ((uint64_t)_len << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+    });\n }\n \n yyjson_api_inline bool yyjson_mut_obj_add_val(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t const char *_key,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *_val) {\n-   if (yyjson_unlikely(!_val)) return false;\n-   yyjson_mut_obj_add_func({\n-\t   val = _val;\n-   });\n+                                              yyjson_mut_val *obj,\n+                                              const char *_key,\n+                                              yyjson_mut_val *_val) {\n+    if (yyjson_unlikely(!_val)) return false;\n+    yyjson_mut_obj_add_func({\n+        val = _val;\n+    });\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_remove_str(yyjson_mut_val *obj,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t   const char *key) {\n-   return yyjson_mut_obj_remove_strn(obj, key, key ? strlen(key) : 0);\n+                                                            const char *key) {\n+    return yyjson_mut_obj_remove_strn(obj, key, key ? strlen(key) : 0);\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_obj_remove_strn(\n-   yyjson_mut_val *obj, const char *_key, size_t _len) {\n-   if (yyjson_likely(yyjson_mut_is_obj(obj) && _key)) {\n-\t   yyjson_mut_val *key;\n-\t   yyjson_mut_obj_iter iter;\n-\t   yyjson_mut_val *val_removed = NULL;\n-\t   yyjson_mut_obj_iter_init(obj, &iter);\n-\t   while ((key = yyjson_mut_obj_iter_next(&iter)) != NULL) {\n-\t\t   if (unsafe_yyjson_get_len(key) == _len &&\n-\t\t\t   duckdb::FastMemcmp(key->uni.str, _key, _len) == 0) {\n-\t\t\t   if (!val_removed) val_removed = key->next;\n-\t\t\t   yyjson_mut_obj_iter_remove(&iter);\n-\t\t   }\n-\t   }\n-\t   return val_removed;\n-   }\n-   return NULL;\n+    yyjson_mut_val *obj, const char *_key, size_t _len) {\n+    if (yyjson_likely(yyjson_mut_is_obj(obj) && _key)) {\n+        yyjson_mut_val *key;\n+        yyjson_mut_obj_iter iter;\n+        yyjson_mut_val *val_removed = NULL;\n+        yyjson_mut_obj_iter_init(obj, &iter);\n+        while ((key = yyjson_mut_obj_iter_next(&iter)) != NULL) {\n+            if (unsafe_yyjson_get_len(key) == _len &&\n+                duckdb::FastMemcmp(key->uni.str, _key, _len) == 0) {\n+                if (!val_removed) val_removed = key->next;\n+                yyjson_mut_obj_iter_remove(&iter);\n+            }\n+        }\n+        return val_removed;\n+    }\n+    return NULL;\n+}\n+\n+yyjson_api_inline bool yyjson_mut_obj_rename_key(yyjson_mut_doc *doc,\n+                                                 yyjson_mut_val *obj,\n+                                                 const char *key,\n+                                                 const char *new_key) {\n+    if (!key || !new_key) return false;\n+    return yyjson_mut_obj_rename_keyn(doc, obj, key, strlen(key),\n+                                      new_key, strlen(new_key));\n+}\n+\n+yyjson_api_inline bool yyjson_mut_obj_rename_keyn(yyjson_mut_doc *doc,\n+                                                  yyjson_mut_val *obj,\n+                                                  const char *key,\n+                                                  size_t len,\n+                                                  const char *new_key,\n+                                                  size_t new_len) {\n+    char *cpy_key = NULL;\n+    yyjson_mut_val *old_key;\n+    yyjson_mut_obj_iter iter;\n+    if (!doc || !obj || !key || !new_key) return false;\n+    yyjson_mut_obj_iter_init(obj, &iter);\n+    while ((old_key = yyjson_mut_obj_iter_next(&iter))) {\n+        if (unsafe_yyjson_equals_strn((void *)old_key, key, len)) {\n+            if (!cpy_key) {\n+                cpy_key = unsafe_yyjson_mut_strncpy(doc, new_key, new_len);\n+                if (!cpy_key) return false;\n+            }\n+            yyjson_mut_set_strn(old_key, cpy_key, new_len);\n+        }\n+    }\n+    return cpy_key != NULL;\n }\n \n \n \n /*==============================================================================\n-* JSON Pointer API (Implementation)\n-*============================================================================*/\n+ * JSON Pointer API (Implementation)\n+ *============================================================================*/\n \n /* `val` not null, `ptr` start with '/', `len` > 0. */\n yyjson_api yyjson_val *unsafe_yyjson_get_pointer(yyjson_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *ptr,\n-\t\t\t\t\t\t\t\t\t\t\t\tsize_t len);\n+                                                 const char *ptr,\n+                                                 size_t len);\n \n /* `val` not null, `ptr` start with '/', `len` > 0. */\n yyjson_api yyjson_mut_val *unsafe_yyjson_mut_get_pointer(yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *ptr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize_t len);\n+                                                         const char *ptr,\n+                                                         size_t len);\n \n yyjson_api_inline yyjson_val *yyjson_get_pointern(yyjson_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char *ptr,\n-\t\t\t\t\t\t\t\t\t\t\t\t size_t len) {\n-   if (!val || !ptr) return NULL;\n-   if (len == 0) return val;\n-   if (*ptr != '/') return NULL;\n-   return unsafe_yyjson_get_pointer(val, ptr, len);\n+                                                  const char *ptr,\n+                                                  size_t len) {\n+    if (!val || !ptr) return NULL;\n+    if (len == 0) return val;\n+    if (*ptr != '/') return NULL;\n+    return unsafe_yyjson_get_pointer(val, ptr, len);\n }\n \n yyjson_api_inline yyjson_val *yyjson_get_pointer(yyjson_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *ptr) {\n-   if (!val || !ptr) return NULL;\n-   return yyjson_get_pointern(val, ptr, strlen(ptr));\n+                                                 const char *ptr) {\n+    if (!val || !ptr) return NULL;\n+    return yyjson_get_pointern(val, ptr, strlen(ptr));\n }\n \n yyjson_api_inline yyjson_val *yyjson_doc_get_pointern(yyjson_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t const char *ptr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t size_t len) {\n-   return yyjson_get_pointern(doc ? doc->root : NULL, ptr, len);\n+                                                      const char *ptr,\n+                                                      size_t len) {\n+    return yyjson_get_pointern(doc ? doc->root : NULL, ptr, len);\n }\n \n yyjson_api_inline yyjson_val *yyjson_doc_get_pointer(yyjson_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *ptr) {\n-   return yyjson_get_pointer(doc ? doc->root : NULL, ptr);\n+                                                     const char *ptr) {\n+    return yyjson_get_pointer(doc ? doc->root : NULL, ptr);\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_get_pointern(yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t const char *ptr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t size_t len) {\n-   if (!val || !ptr) return NULL;\n-   if (len == 0) return val;\n-   if (*ptr != '/') return NULL;\n-   return unsafe_yyjson_mut_get_pointer(val, ptr, len);\n+                                                          const char *ptr,\n+                                                          size_t len) {\n+    if (!val || !ptr) return NULL;\n+    if (len == 0) return val;\n+    if (*ptr != '/') return NULL;\n+    return unsafe_yyjson_mut_get_pointer(val, ptr, len);\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_get_pointer(yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *ptr) {\n-   if (!val || !ptr) return NULL;\n-   return yyjson_mut_get_pointern(val, ptr, strlen(ptr));\n+                                                         const char *ptr) {\n+    if (!val || !ptr) return NULL;\n+    return yyjson_mut_get_pointern(val, ptr, strlen(ptr));\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_doc_get_pointern(\n-   yyjson_mut_doc *doc, const char *ptr, size_t len) {\n-   return yyjson_mut_get_pointern(doc ? doc->root : NULL, ptr, len);\n+    yyjson_mut_doc *doc, const char *ptr, size_t len) {\n+    return yyjson_mut_get_pointern(doc ? doc->root : NULL, ptr, len);\n }\n \n yyjson_api_inline yyjson_mut_val *yyjson_mut_doc_get_pointer(\n-   yyjson_mut_doc *doc, const char *ptr) {\n-   return yyjson_mut_get_pointer(doc ? doc->root : NULL, ptr);\n+    yyjson_mut_doc *doc, const char *ptr) {\n+    return yyjson_mut_get_pointer(doc ? doc->root : NULL, ptr);\n }\n \n \n \n /*==============================================================================\n-* Compiler Hint End\n-*============================================================================*/\n+ * Compiler Hint End\n+ *============================================================================*/\n \n #if defined(__clang__)\n #   pragma clang diagnostic pop\ndiff --git a/extension/json/yyjson/yyjson.cpp b/extension/json/yyjson/yyjson.cpp\nindex 381ff1f5029c..95825ac3eac6 100644\n--- a/extension/json/yyjson/yyjson.cpp\n+++ b/extension/json/yyjson/yyjson.cpp\n@@ -1,10 +1,10 @@\n /*==============================================================================\n-* Created by Yaoyuan on 2019/3/9.\n-* Copyright (C) 2019 Yaoyuan <ibireme@gmail.com>.\n-*\n-* Released under the MIT License:\n-* https://github.com/ibireme/yyjson/blob/master/LICENSE\n-*============================================================================*/\n+ * Created by Yaoyuan on 2019/3/9.\n+ * Copyright (C) 2019 Yaoyuan <ibireme@gmail.com>.\n+ *\n+ * Released under the MIT License:\n+ * https://github.com/ibireme/yyjson/blob/master/LICENSE\n+ *============================================================================*/\n \n #include \"yyjson.hpp\"\n #include <stdio.h>\n@@ -13,8 +13,8 @@\n \n \n /*==============================================================================\n-* Compile Hint Begin\n-*============================================================================*/\n+ * Compile Hint Begin\n+ *============================================================================*/\n \n /* warning suppress begin */\n #if defined(__clang__)\n@@ -42,32 +42,32 @@\n \n \n /*==============================================================================\n-* Version\n-*============================================================================*/\n+ * Version\n+ *============================================================================*/\n \n yyjson_api uint32_t yyjson_version(void) {\n-   return YYJSON_VERSION_HEX;\n+    return YYJSON_VERSION_HEX;\n }\n \n \n \n /*==============================================================================\n-* Flags\n-*============================================================================*/\n+ * Flags\n+ *============================================================================*/\n \n /* gcc version check */\n #if defined(__GNUC__)\n #   if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)\n #       define yyjson_gcc_available(major, minor, patch) \\\n-\t\t   ((__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) \\\n-\t\t   >= (major * 10000 + minor * 100 + patch))\n+            ((__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) \\\n+            >= (major * 10000 + minor * 100 + patch))\n #   elif defined(__GNUC_MINOR__)\n #       define yyjson_gcc_available(major, minor, patch) \\\n-\t\t   ((__GNUC__ * 10000 + __GNUC_MINOR__ * 100) \\\n-\t\t   >= (major * 10000 + minor * 100 + patch))\n+            ((__GNUC__ * 10000 + __GNUC_MINOR__ * 100) \\\n+            >= (major * 10000 + minor * 100 + patch))\n #   else\n #       define yyjson_gcc_available(major, minor, patch) \\\n-\t\t   ((__GNUC__ * 10000) >= (major * 10000 + minor * 100 + patch))\n+            ((__GNUC__ * 10000) >= (major * 10000 + minor * 100 + patch))\n #   endif\n #else\n #       define yyjson_gcc_available(major, minor, patch) 0\n@@ -75,7 +75,7 @@ yyjson_api uint32_t yyjson_version(void) {\n \n /* real gcc check */\n #if !defined(__clang__) && !defined(__INTEL_COMPILER) && !defined(__ICC) && \\\n-   defined(__GNUC__) && defined(__GNUC_MINOR__)\n+    defined(__GNUC__) && defined(__GNUC_MINOR__)\n #   define YYJSON_IS_REAL_GCC 1\n #else\n #   define YYJSON_IS_REAL_GCC 0\n@@ -92,7 +92,7 @@ yyjson_api uint32_t yyjson_version(void) {\n #       define MSC_HAS_BIT_SCAN_64 0\n #   endif\n #   if defined(_M_AMD64) || defined(_M_ARM64) || \\\n-\t   defined(_M_IX86) || defined(_M_ARM)\n+        defined(_M_IX86) || defined(_M_ARM)\n #       define MSC_HAS_BIT_SCAN 1\n #       pragma intrinsic(_BitScanForward)\n #       pragma intrinsic(_BitScanReverse)\n@@ -126,7 +126,7 @@ yyjson_api uint32_t yyjson_version(void) {\n \n /* int128 type */\n #if defined(__SIZEOF_INT128__) && (__SIZEOF_INT128__ == 16) && \\\n-   (defined(__GNUC__) || defined(__clang__) || defined(__INTEL_COMPILER))\n+    (defined(__GNUC__) || defined(__clang__) || defined(__INTEL_COMPILER))\n #    define YYJSON_HAS_INT128 1\n #else\n #    define YYJSON_HAS_INT128 0\n@@ -136,46 +136,46 @@ yyjson_api uint32_t yyjson_version(void) {\n #if defined(__STDC_IEC_559__) || defined(__STDC_IEC_60559_BFP__)\n #   define YYJSON_HAS_IEEE_754 1\n #elif (FLT_RADIX == 2) && (DBL_MANT_DIG == 53) && (DBL_DIG == 15) && \\\n-\t(DBL_MIN_EXP == -1021) && (DBL_MAX_EXP == 1024) && \\\n-\t(DBL_MIN_10_EXP == -307) && (DBL_MAX_10_EXP == 308)\n+     (DBL_MIN_EXP == -1021) && (DBL_MAX_EXP == 1024) && \\\n+     (DBL_MIN_10_EXP == -307) && (DBL_MAX_10_EXP == 308)\n #   define YYJSON_HAS_IEEE_754 1\n #else\n #   define YYJSON_HAS_IEEE_754 0\n #endif\n \n /*\n-Correct rounding in double number computations.\n-\n-On the x86 architecture, some compilers may use x87 FPU instructions for\n-floating-point arithmetic. The x87 FPU loads all floating point number as\n-80-bit double-extended precision internally, then rounds the result to original\n-precision, which may produce inaccurate results. For a more detailed\n-explanation, see the paper: https://arxiv.org/abs/cs/0701192\n-\n-Here are some examples of double precision calculation error:\n-\n-\t2877.0 / 1e6   == 0.002877,  but x87 returns 0.0028770000000000002\n-\t43683.0 * 1e21 == 4.3683e25, but x87 returns 4.3683000000000004e25\n-\n-Here are some examples of compiler flags to generate x87 instructions on x86:\n-\n-\tclang -m32 -mno-sse\n-\tgcc/icc -m32 -mfpmath=387\n-\tmsvc /arch:SSE or /arch:IA32\n-\n-If we are sure that there's no similar error described above, we can define the\n-YYJSON_DOUBLE_MATH_CORRECT as 1 to enable the fast path calculation. This is\n-not an accurate detection, it's just try to avoid the error at compile-time.\n-An accurate detection can be done at run-time:\n-\n-\tbool is_double_math_correct(void) {\n-\t\tvolatile double r = 43683.0;\n-\t\tr *= 1e21;\n-\t\treturn r == 4.3683e25;\n-\t}\n-\n-See also: utils.h in https://github.com/google/double-conversion/\n-*/\n+ Correct rounding in double number computations.\n+ \n+ On the x86 architecture, some compilers may use x87 FPU instructions for\n+ floating-point arithmetic. The x87 FPU loads all floating point number as\n+ 80-bit double-extended precision internally, then rounds the result to original\n+ precision, which may produce inaccurate results. For a more detailed\n+ explanation, see the paper: https://arxiv.org/abs/cs/0701192\n+ \n+ Here are some examples of double precision calculation error:\n+ \n+     2877.0 / 1e6   == 0.002877,  but x87 returns 0.0028770000000000002\n+     43683.0 * 1e21 == 4.3683e25, but x87 returns 4.3683000000000004e25\n+ \n+ Here are some examples of compiler flags to generate x87 instructions on x86:\n+ \n+     clang -m32 -mno-sse\n+     gcc/icc -m32 -mfpmath=387\n+     msvc /arch:SSE or /arch:IA32\n+ \n+ If we are sure that there's no similar error described above, we can define the\n+ YYJSON_DOUBLE_MATH_CORRECT as 1 to enable the fast path calculation. This is\n+ not an accurate detection, it's just try to avoid the error at compile-time.\n+ An accurate detection can be done at run-time:\n+ \n+     bool is_double_math_correct(void) {\n+         volatile double r = 43683.0;\n+         r *= 1e21;\n+         return r == 4.3683e25;\n+     }\n+ \n+ See also: utils.h in https://github.com/google/double-conversion/\n+ */\n #if !defined(FLT_EVAL_METHOD) && defined(__FLT_EVAL_METHOD__)\n #    define FLT_EVAL_METHOD __FLT_EVAL_METHOD__\n #endif\n@@ -183,49 +183,24 @@ See also: utils.h in https://github.com/google/double-conversion/\n #if defined(FLT_EVAL_METHOD) && FLT_EVAL_METHOD != 0 && FLT_EVAL_METHOD != 1\n #    define YYJSON_DOUBLE_MATH_CORRECT 0\n #elif defined(i386) || defined(__i386) || defined(__i386__) || \\\n-   defined(_X86_) || defined(__X86__) || defined(_M_IX86) || \\\n-   defined(__I86__) || defined(__IA32__) || defined(__THW_INTEL)\n+    defined(_X86_) || defined(__X86__) || defined(_M_IX86) || \\\n+    defined(__I86__) || defined(__IA32__) || defined(__THW_INTEL)\n #   if (defined(_MSC_VER) && defined(_M_IX86_FP) && _M_IX86_FP == 2) || \\\n-\t   (defined(__SSE2_MATH__) && __SSE2_MATH__)\n+        (defined(__SSE2_MATH__) && __SSE2_MATH__)\n #       define YYJSON_DOUBLE_MATH_CORRECT 1\n #   else\n #       define YYJSON_DOUBLE_MATH_CORRECT 0\n #   endif\n-#elif defined(__x86_64) || defined(__x86_64__) || \\\n-   defined(__amd64) || defined(__amd64__) || \\\n-   defined(_M_AMD64) || defined(_M_X64) || \\\n-   defined(__ia64) || defined(_IA64) || defined(__IA64__) ||  \\\n-   defined(__ia64__) || defined(_M_IA64) || defined(__itanium__) || \\\n-   defined(__arm64) || defined(__arm64__) || \\\n-   defined(__aarch64__) || defined(_M_ARM64) || \\\n-   defined(__arm) || defined(__arm__) || defined(_ARM_) || \\\n-   defined(_ARM) || defined(_M_ARM) || defined(__TARGET_ARCH_ARM) || \\\n-   defined(mips) || defined(__mips) || defined(__mips__) || \\\n-   defined(MIPS) || defined(_MIPS_) || defined(__MIPS__) || \\\n-   defined(_ARCH_PPC64) || defined(__PPC64__) || \\\n-   defined(__ppc64__) || defined(__powerpc64__) || \\\n-   defined(__powerpc) || defined(__powerpc__) || defined(__POWERPC__) || \\\n-   defined(__ppc__) || defined(__ppc) || defined(__PPC__) || \\\n-   defined(__sparcv9) || defined(__sparc_v9__) || \\\n-   defined(__sparc) || defined(__sparc__) || defined(__sparc64__) || \\\n-   defined(__alpha) || defined(__alpha__) || defined(_M_ALPHA) || \\\n-   defined(__or1k__) || defined(__OR1K__) || defined(OR1K) || \\\n-   defined(__hppa) || defined(__hppa__) || defined(__HPPA__) || \\\n-   defined(__riscv) || defined(__riscv__) || \\\n-   defined(__s390__) || defined(__avr32__) || defined(__SH4__) || \\\n-   defined(__e2k__) || defined(__arc__) || defined(__ARC64__) || \\\n-   defined(__loongarch__) || defined(__nios2__) || defined(__ghs) || \\\n-   defined(__microblaze__) || defined(__XTENSA__) || \\\n-   defined(__EMSCRIPTEN__) || defined(__wasm__)\n-#   define YYJSON_DOUBLE_MATH_CORRECT 1\n+#elif defined(__mc68000__) || defined(__pnacl__) || defined(__native_client__)\n+#   define YYJSON_DOUBLE_MATH_CORRECT 0\n #else\n-#   define YYJSON_DOUBLE_MATH_CORRECT 0 /* unknown, disable fast path */\n+#   define YYJSON_DOUBLE_MATH_CORRECT 1\n #endif\n \n /*\n-Microsoft Visual C++ 6.0 doesn't support converting number from u64 to f64:\n-error C2520: conversion from unsigned __int64 to double not implemented.\n-*/\n+ Microsoft Visual C++ 6.0 doesn't support converting number from u64 to f64:\n+ error C2520: conversion from unsigned __int64 to double not implemented.\n+ */\n #ifndef YYJSON_U64_TO_F64_NO_IMPL\n #   if (0 < YYJSON_MSC_VER) && (YYJSON_MSC_VER <= 1200)\n #       define YYJSON_U64_TO_F64_NO_IMPL 1\n@@ -272,28 +247,28 @@ error C2520: conversion from unsigned __int64 to double not implemented.\n #   endif\n \n #elif (defined(__LITTLE_ENDIAN__) && __LITTLE_ENDIAN__ == 1) || \\\n-   defined(__i386) || defined(__i386__) || \\\n-   defined(_X86_) || defined(__X86__) || \\\n-   defined(_M_IX86) || defined(__THW_INTEL__) || \\\n-   defined(__x86_64) || defined(__x86_64__) || \\\n-   defined(__amd64) || defined(__amd64__) || \\\n-   defined(_M_AMD64) || defined(_M_X64) || \\\n-   defined(__ia64) || defined(_IA64) || defined(__IA64__) ||  \\\n-   defined(__ia64__) || defined(_M_IA64) || defined(__itanium__) || \\\n-   defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || \\\n-   defined(__alpha) || defined(__alpha__) || defined(_M_ALPHA) || \\\n-   defined(__riscv) || defined(__riscv__) || \\\n-   defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || \\\n-   defined(__EMSCRIPTEN__) || defined(__wasm__)\n+    defined(__i386) || defined(__i386__) || \\\n+    defined(_X86_) || defined(__X86__) || \\\n+    defined(_M_IX86) || defined(__THW_INTEL__) || \\\n+    defined(__x86_64) || defined(__x86_64__) || \\\n+    defined(__amd64) || defined(__amd64__) || \\\n+    defined(_M_AMD64) || defined(_M_X64) || \\\n+    defined(__ia64) || defined(_IA64) || defined(__IA64__) ||  \\\n+    defined(__ia64__) || defined(_M_IA64) || defined(__itanium__) || \\\n+    defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || \\\n+    defined(__alpha) || defined(__alpha__) || defined(_M_ALPHA) || \\\n+    defined(__riscv) || defined(__riscv__) || \\\n+    defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || \\\n+    defined(__EMSCRIPTEN__) || defined(__wasm__)\n #   define YYJSON_ENDIAN YYJSON_LITTLE_ENDIAN\n \n #elif (defined(__BIG_ENDIAN__) && __BIG_ENDIAN__ == 1) || \\\n-   defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || \\\n-   defined(_MIPSEB) || defined(__MIPSEB) || defined(__MIPSEB__) || \\\n-   defined(_ARCH_PPC) || defined(_ARCH_PPC64) || \\\n-   defined(__ppc) || defined(__ppc__) || \\\n-   defined(__sparc) || defined(__sparc__) || defined(__sparc64__) || \\\n-   defined(__or1k__) || defined(__OR1K__)\n+    defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || \\\n+    defined(_MIPSEB) || defined(__MIPSEB) || defined(__MIPSEB__) || \\\n+    defined(_ARCH_PPC) || defined(_ARCH_PPC64) || \\\n+    defined(__ppc) || defined(__ppc__) || \\\n+    defined(__sparc) || defined(__sparc__) || defined(__sparc64__) || \\\n+    defined(__or1k__) || defined(__OR1K__)\n #   define YYJSON_ENDIAN YYJSON_BIG_ENDIAN\n \n #else\n@@ -301,55 +276,55 @@ error C2520: conversion from unsigned __int64 to double not implemented.\n #endif\n \n /*\n-Unaligned memory access detection.\n-\n-Some architectures cannot perform unaligned memory accesse, or unaligned memory\n-accesses can have a large performance penalty. Modern compilers can make some\n-optimizations for unaligned access. For example: https://godbolt.org/z/Ejo3Pa\n-\n-   typedef struct { char c[2] } vec2;\n-   void copy_vec2(vec2 *dst, vec2 *src) {\n-\t   *dst = *src;\n-   }\n-\n-Compiler may generate `load/store` or `move` instruction if target architecture\n-supports unaligned access, otherwise it may generate `call memcpy` instruction.\n-\n-We want to avoid `memcpy` calls, so we should disable unaligned access by\n-define `YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS` as 1 on these architectures.\n-*/\n+ Unaligned memory access detection.\n+ \n+ Some architectures cannot perform unaligned memory access, or unaligned memory\n+ accesses can have a large performance penalty. Modern compilers can make some\n+ optimizations for unaligned access. For example: https://godbolt.org/z/Ejo3Pa\n+ \n+    typedef struct { char c[2] } vec2;\n+    void copy_vec2(vec2 *dst, vec2 *src) {\n+        *dst = *src;\n+    }\n+ \n+ Compiler may generate `load/store` or `move` instruction if target architecture\n+ supports unaligned access, otherwise it may generate `call memcpy` instruction.\n+ \n+ We want to avoid `memcpy` calls, so we should disable unaligned access by\n+ define `YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS` as 1 on these architectures.\n+ */\n #ifndef YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n #   if defined(i386) || defined(__i386) || defined(__i386__) || \\\n-\t   defined(__i486__) || defined(__i586__) || defined(__i686__) || \\\n-\t   defined(_X86_) || defined(__X86__) || defined(_M_IX86) || \\\n-\t   defined(__I86__) || defined(__IA32__) || \\\n-\t   defined(__THW_INTEL) || defined(__THW_INTEL__) || \\\n-\t   defined(__x86_64) || defined(__x86_64__) || \\\n-\t   defined(__amd64) || defined(__amd64__) || \\\n-\t   defined(_M_AMD64) || defined(_M_X64)\n+        defined(__i486__) || defined(__i586__) || defined(__i686__) || \\\n+        defined(_X86_) || defined(__X86__) || defined(_M_IX86) || \\\n+        defined(__I86__) || defined(__IA32__) || \\\n+        defined(__THW_INTEL) || defined(__THW_INTEL__) || \\\n+        defined(__x86_64) || defined(__x86_64__) || \\\n+        defined(__amd64) || defined(__amd64__) || \\\n+        defined(_M_AMD64) || defined(_M_X64)\n #       define YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS 0 /* x86 */\n \n #   elif defined(__ia64) || defined(_IA64) || defined(__IA64__) ||  \\\n-\t   defined(__ia64__) || defined(_M_IA64) || defined(__itanium__)\n+        defined(__ia64__) || defined(_M_IA64) || defined(__itanium__)\n #       define YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS 1 /* Itanium */\n \n #   elif defined(__arm64) || defined(__arm64__) || \\\n-\t   defined(__AARCH64EL__) || defined(__AARCH64EB__) || \\\n-\t   defined(__aarch64__) || defined(_M_ARM64)\n+        defined(__AARCH64EL__) || defined(__AARCH64EB__) || \\\n+        defined(__aarch64__) || defined(_M_ARM64)\n #       define YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS 0 /* ARM64 */\n \n #   elif defined(__ARM_ARCH_4__) || defined(__ARM_ARCH_4T__) || \\\n-\t   defined(__ARM_ARCH_5TEJ__) || defined(__ARM_ARCH_5TE__) || \\\n-\t   defined(__ARM_ARCH_6T2__) || defined(__ARM_ARCH_6KZ__) || \\\n-\t   defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6K__)\n+        defined(__ARM_ARCH_5TEJ__) || defined(__ARM_ARCH_5TE__) || \\\n+        defined(__ARM_ARCH_6T2__) || defined(__ARM_ARCH_6KZ__) || \\\n+        defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6K__)\n #       define YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS 1 /* ARM */\n \n #   elif defined(__ppc64__) || defined(__PPC64__) || \\\n-\t   defined(__powerpc64__) || defined(_ARCH_PPC64) || \\\n-\t   defined(__ppc) || defined(__ppc__) || defined(__PPC__) || \\\n-\t   defined(__powerpc) || defined(__powerpc__) || defined(__POWERPC__) || \\\n-\t   defined(_ARCH_PPC) || defined(_M_PPC) || \\\n-\t   defined(__PPCGECKO__) || defined(__PPCBROADWAY__) || defined(_XENON)\n+        defined(__powerpc64__) || defined(_ARCH_PPC64) || \\\n+        defined(__ppc) || defined(__ppc__) || defined(__PPC__) || \\\n+        defined(__powerpc) || defined(__powerpc__) || defined(__POWERPC__) || \\\n+        defined(_ARCH_PPC) || defined(_M_PPC) || \\\n+        defined(__PPCGECKO__) || defined(__PPCBROADWAY__) || defined(_XENON)\n #       define YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS 0 /* PowerPC */\n \n #   else\n@@ -359,21 +334,21 @@ define `YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS` as 1 on these architectures.\n #endif\n \n /*\n-Estimated initial ratio of the JSON data (data_size / value_count).\n-For example:\n-\n-   data:        {\"id\":12345678,\"name\":\"Harry\"}\n-   data_size:   30\n-   value_count: 5\n-   ratio:       6\n-\n-yyjson uses dynamic memory with a growth factor of 1.5 when reading and writing\n-JSON, the ratios below are used to determine the initial memory size.\n-\n-A too large ratio will waste memory, and a too small ratio will cause multiple\n-memory growths and degrade performance. Currently these ratios are generated\n-with some commonly used JSON datasets.\n-*/\n+ Estimated initial ratio of the JSON data (data_size / value_count).\n+ For example:\n+    \n+    data:        {\"id\":12345678,\"name\":\"Harry\"}\n+    data_size:   30\n+    value_count: 5\n+    ratio:       6\n+    \n+ yyjson uses dynamic memory with a growth factor of 1.5 when reading and writing\n+ JSON, the ratios below are used to determine the initial memory size.\n+ \n+ A too large ratio will waste memory, and a too small ratio will cause multiple\n+ memory growths and degrade performance. Currently, these ratios are generated\n+ with some commonly used JSON datasets.\n+ */\n #define YYJSON_READER_ESTIMATED_PRETTY_RATIO 16\n #define YYJSON_READER_ESTIMATED_MINIFY_RATIO 6\n #define YYJSON_WRITER_ESTIMATED_PRETTY_RATIO 32\n@@ -396,8 +371,8 @@ with some commonly used JSON datasets.\n \n \n /*==============================================================================\n-* Macros\n-*============================================================================*/\n+ * Macros\n+ *============================================================================*/\n \n /* Macros used for loop unrolling and other purpose. */\n #define repeat2(x)  { x x }\n@@ -410,10 +385,10 @@ with some commonly used JSON datasets.\n #define repeat4_incr(x)  { x(0) x(1) x(2) x(3) }\n #define repeat8_incr(x)  { x(0) x(1) x(2) x(3) x(4) x(5) x(6) x(7) }\n #define repeat16_incr(x) { x(0) x(1) x(2) x(3) x(4) x(5) x(6) x(7) \\\n-\t\t\t\t\t\t  x(8) x(9) x(10) x(11) x(12) x(13) x(14) x(15) }\n+                           x(8) x(9) x(10) x(11) x(12) x(13) x(14) x(15) }\n #define repeat_in_1_18(x) { x(1) x(2) x(3) x(4) x(5) x(6) x(7) \\\n-\t\t\t\t\t\t   x(8) x(9) x(10) x(11) x(12) x(13) x(14) x(15) \\\n-\t\t\t\t\t\t   x(16) x(17) x(18) }\n+                            x(8) x(9) x(10) x(11) x(12) x(13) x(14) x(15) \\\n+                            x(16) x(17) x(18) }\n \n /* Macros used to provide branch prediction information for compiler. */\n #undef  likely\n@@ -440,8 +415,8 @@ with some commonly used JSON datasets.\n \n \n /*==============================================================================\n-* Integer Constants\n-*============================================================================*/\n+ * Integer Constants\n+ *============================================================================*/\n \n /* U64 constant values */\n #undef  U64_MAX\n@@ -458,14 +433,18 @@ with some commonly used JSON datasets.\n \n \n /*==============================================================================\n-* IEEE-754 Double Number Constants\n-*============================================================================*/\n+ * IEEE-754 Double Number Constants\n+ *============================================================================*/\n \n /* Inf raw value (positive) */\n #define F64_RAW_INF U64(0x7FF00000, 0x00000000)\n \n-/* NaN raw value (positive, without payload) */\n+/* NaN raw value (quiet NaN, no payload, no sign) */\n+#if defined(__hppa__) || (defined(__mips__) && !defined(__mips_nan2008))\n+#define F64_RAW_NAN U64(0x7FF7FFFF, 0xFFFFFFFF)\n+#else\n #define F64_RAW_NAN U64(0x7FF80000, 0x00000000)\n+#endif\n \n /* double number bits */\n #define F64_BITS 64\n@@ -509,8 +488,8 @@ with some commonly used JSON datasets.\n \n \n /*==============================================================================\n-* Types\n-*============================================================================*/\n+ * Types\n+ *============================================================================*/\n \n /** Type define for primitive types. */\n typedef float       f32;\n@@ -544,121 +523,121 @@ typedef union v64_uni { v64 v; u64 u; } v64_uni;\n \n \n /*==============================================================================\n-* Load/Store Utils\n-*============================================================================*/\n+ * Load/Store Utils\n+ *============================================================================*/\n \n #define byte_move_idx(x) ((u8 *)dst)[x] = ((u8 *)src)[x];\n \n static_inline void byte_move_2(void *dst, const void *src) {\n #if YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n-   repeat2_incr(byte_move_idx);\n+    repeat2_incr(byte_move_idx);\n #else\n-   memmove(dst, src, 2);\n+    memmove(dst, src, 2);\n #endif\n }\n \n static_inline void byte_move_4(void *dst, const void *src) {\n #if YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n-   repeat4_incr(byte_move_idx);\n+    repeat4_incr(byte_move_idx);\n #else\n-   memmove(dst, src, 4);\n+    memmove(dst, src, 4);\n #endif\n }\n \n static_inline void byte_move_8(void *dst, const void *src) {\n #if YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n-   repeat8_incr(byte_move_idx);\n+    repeat8_incr(byte_move_idx);\n #else\n-   memmove(dst, src, 8);\n+    memmove(dst, src, 8);\n #endif\n }\n \n static_inline void byte_move_16(void *dst, const void *src) {\n #if YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n-   repeat16_incr(byte_move_idx);\n+    repeat16_incr(byte_move_idx);\n #else\n-   memmove(dst, src, 16);\n+    memmove(dst, src, 16);\n #endif\n }\n \n static_inline void byte_copy_2(void *dst, const void *src) {\n #if YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n-   repeat2_incr(byte_move_idx);\n+    repeat2_incr(byte_move_idx);\n #else\n-   memcpy(dst, src, 2);\n+    memcpy(dst, src, 2);\n #endif\n }\n \n static_inline void byte_copy_4(void *dst, const void *src) {\n #if YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n-   repeat4_incr(byte_move_idx);\n+    repeat4_incr(byte_move_idx);\n #else\n-   memcpy(dst, src, 4);\n+    memcpy(dst, src, 4);\n #endif\n }\n \n static_inline void byte_copy_8(void *dst, const void *src) {\n #if YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n-   repeat8_incr(byte_move_idx);\n+    repeat8_incr(byte_move_idx);\n #else\n-   memcpy(dst, src, 8);\n+    memcpy(dst, src, 8);\n #endif\n }\n \n static_inline void byte_copy_16(void *dst, const void *src) {\n #if YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n-   repeat16_incr(byte_move_idx);\n+    repeat16_incr(byte_move_idx);\n #else\n-   memcpy(dst, src, 16);\n+    memcpy(dst, src, 16);\n #endif\n }\n \n static_inline bool byte_match_2(void *buf, const char *pat) {\n #if YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n-   return\n-\t   ((u8 *)buf)[0] == ((const u8 *)pat)[0] &&\n-\t   ((u8 *)buf)[1] == ((const u8 *)pat)[1];\n+    return\n+    ((u8 *)buf)[0] == ((const u8 *)pat)[0] &&\n+    ((u8 *)buf)[1] == ((const u8 *)pat)[1];\n #else\n-   v16_uni u1, u2;\n-   u1.v = *(const v16 *)pat;\n-   u2.v = *(const v16 *)buf;\n-   return u1.u == u2.u;\n+    v16_uni u1, u2;\n+    u1.v = *(const v16 *)pat;\n+    u2.v = *(const v16 *)buf;\n+    return u1.u == u2.u;\n #endif\n }\n \n static_inline bool byte_match_4(void *buf, const char *pat) {\n #if YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS\n-   return\n-\t   ((u8 *)buf)[0] == ((const u8 *)pat)[0] &&\n-\t   ((u8 *)buf)[1] == ((const u8 *)pat)[1] &&\n-\t   ((u8 *)buf)[2] == ((const u8 *)pat)[2] &&\n-\t   ((u8 *)buf)[3] == ((const u8 *)pat)[3];\n+    return\n+    ((u8 *)buf)[0] == ((const u8 *)pat)[0] &&\n+    ((u8 *)buf)[1] == ((const u8 *)pat)[1] &&\n+    ((u8 *)buf)[2] == ((const u8 *)pat)[2] &&\n+    ((u8 *)buf)[3] == ((const u8 *)pat)[3];\n #else\n-   v32_uni u1, u2;\n-   u1.v = *(const v32 *)pat;\n-   u2.v = *(const v32 *)buf;\n-   return u1.u == u2.u;\n+    v32_uni u1, u2;\n+    u1.v = *(const v32 *)pat;\n+    u2.v = *(const v32 *)buf;\n+    return u1.u == u2.u;\n #endif\n }\n \n static_inline u16 byte_load_2(const void *src) {\n-   v16_uni uni;\n-   uni.v = *(v16 *)src;\n-   return uni.u;\n+    v16_uni uni;\n+    uni.v = *(v16 *)src;\n+    return uni.u;\n }\n \n static_inline u32 byte_load_3(const void *src) {\n-   v32_uni uni;\n-   ((v16_uni *)&uni)->v = *(v16 *)src;\n-   uni.v.c3 = ((char *)src)[2];\n-   uni.v.c4 = 0;\n-   return uni.u;\n+    v32_uni uni;\n+    ((v16_uni *)&uni)->v = *(v16 *)src;\n+    uni.v.c3 = ((char *)src)[2];\n+    uni.v.c4 = 0;\n+    return uni.u;\n }\n \n static_inline u32 byte_load_4(const void *src) {\n-   v32_uni uni;\n-   uni.v = *(v32 *)src;\n-   return uni.u;\n+    v32_uni uni;\n+    uni.v = *(v32 *)src;\n+    return uni.u;\n }\n \n #undef byte_move_expr\n@@ -666,259 +645,259 @@ static_inline u32 byte_load_4(const void *src) {\n \n \n /*==============================================================================\n-* Number Utils\n-* These functions are used to detect and convert NaN and Inf numbers.\n-*============================================================================*/\n+ * Number Utils\n+ * These functions are used to detect and convert NaN and Inf numbers.\n+ *============================================================================*/\n \n /**\n-This union is used to avoid violating the strict aliasing rule in C.\n-`memcpy` can be used in both C and C++, but it may reduce performance without\n-compiler optimization.\n-*/\n+ This union is used to avoid violating the strict aliasing rule in C.\n+ `memcpy` can be used in both C and C++, but it may reduce performance without\n+ compiler optimization.\n+ */\n typedef union { u64 u; f64 f; } f64_uni;\n \n /** Convert raw binary to double. */\n static_inline f64 f64_from_raw(u64 u) {\n #ifndef __cplusplus\n-   f64_uni uni;\n-   uni.u = u;\n-   return uni.f;\n+    f64_uni uni;\n+    uni.u = u;\n+    return uni.f;\n #else\n-   f64 f;\n-   memcpy(&f, &u, 8);\n-   return f;\n+    f64 f;\n+    memcpy(&f, &u, 8);\n+    return f;\n #endif\n }\n \n /** Convert double to raw binary. */\n static_inline u64 f64_to_raw(f64 f) {\n #ifndef __cplusplus\n-   f64_uni uni;\n-   uni.f = f;\n-   return uni.u;\n+    f64_uni uni;\n+    uni.f = f;\n+    return uni.u;\n #else\n-   u64 u;\n-   memcpy(&u, &f, 8);\n-   return u;\n+    u64 u;\n+    memcpy(&u, &f, 8);\n+    return u;\n #endif\n }\n \n /** Get raw 'infinity' with sign. */\n static_inline u64 f64_raw_get_inf(bool sign) {\n #if YYJSON_HAS_IEEE_754\n-   return F64_RAW_INF | ((u64)sign << 63);\n+    return F64_RAW_INF | ((u64)sign << 63);\n #elif defined(INFINITY)\n-   return f64_to_raw(sign ? -INFINITY : INFINITY);\n+    return f64_to_raw(sign ? -INFINITY : INFINITY);\n #else\n-   return f64_to_raw(sign ? -HUGE_VAL : HUGE_VAL);\n+    return f64_to_raw(sign ? -HUGE_VAL : HUGE_VAL);\n #endif\n }\n \n /** Get raw 'nan' with sign. */\n static_inline u64 f64_raw_get_nan(bool sign) {\n #if YYJSON_HAS_IEEE_754\n-   return F64_RAW_NAN | ((u64)sign << 63);\n+    return F64_RAW_NAN | ((u64)sign << 63);\n #elif defined(NAN)\n-   return f64_to_raw(sign ? (f64)-NAN : (f64)NAN);\n+    return f64_to_raw(sign ? (f64)-NAN : (f64)NAN);\n #else\n-   return f64_to_raw((sign ? -0.0 : 0.0) / 0.0);\n+    return f64_to_raw((sign ? -0.0 : 0.0) / 0.0);\n #endif\n }\n \n /**\n-Convert normalized u64 (highest bit is 1) to f64.\n-\n-Some compiler (such as Microsoft Visual C++ 6.0) do not support converting\n-number from u64 to f64. This function will first convert u64 to i64 and then\n-to f64, with `to nearest` rounding mode.\n-*/\n+ Convert normalized u64 (highest bit is 1) to f64.\n+ \n+ Some compiler (such as Microsoft Visual C++ 6.0) do not support converting\n+ number from u64 to f64. This function will first convert u64 to i64 and then\n+ to f64, with `to nearest` rounding mode.\n+ */\n static_inline f64 normalized_u64_to_f64(u64 val) {\n #if YYJSON_U64_TO_F64_NO_IMPL\n-   i64 sig = (i64)((val >> 1) | (val & 1));\n-   return ((f64)sig) * (f64)2.0;\n+    i64 sig = (i64)((val >> 1) | (val & 1));\n+    return ((f64)sig) * (f64)2.0;\n #else\n-   return (f64)val;\n+    return (f64)val;\n #endif\n }\n \n \n \n /*==============================================================================\n-* Size Utils\n-* These functions are used for memory allocation.\n-*============================================================================*/\n+ * Size Utils\n+ * These functions are used for memory allocation.\n+ *============================================================================*/\n \n /** Returns whether the size is overflow after increment. */\n static_inline bool size_add_is_overflow(usize size, usize add) {\n-   usize val = size + add;\n-   return (val < size) | (val < add);\n+    usize val = size + add;\n+    return (val < size) | (val < add);\n }\n \n /** Returns whether the size is power of 2 (size should not be 0). */\n static_inline bool size_is_pow2(usize size) {\n-   return (size & (size - 1)) == 0;\n+    return (size & (size - 1)) == 0;\n }\n \n /** Align size upwards (may overflow). */\n static_inline usize size_align_up(usize size, usize align) {\n-   if (size_is_pow2(align)) {\n-\t   return (size + (align - 1)) & ~(align - 1);\n-   } else {\n-\t   return size + align - (size + align - 1) % align - 1;\n-   }\n+    if (size_is_pow2(align)) {\n+        return (size + (align - 1)) & ~(align - 1);\n+    } else {\n+        return size + align - (size + align - 1) % align - 1;\n+    }\n }\n \n /** Align size downwards. */\n static_inline usize size_align_down(usize size, usize align) {\n-   if (size_is_pow2(align)) {\n-\t   return size & ~(align - 1);\n-   } else {\n-\t   return size - (size % align);\n-   }\n+    if (size_is_pow2(align)) {\n+        return size & ~(align - 1);\n+    } else {\n+        return size - (size % align);\n+    }\n }\n \n /** Align address upwards (may overflow). */\n static_inline void *mem_align_up(void *mem, usize align) {\n-   usize size;\n-   memcpy(&size, &mem, sizeof(usize));\n-   size = size_align_up(size, align);\n-   memcpy(&mem, &size, sizeof(usize));\n-   return mem;\n+    usize size;\n+    memcpy(&size, &mem, sizeof(usize));\n+    size = size_align_up(size, align);\n+    memcpy(&mem, &size, sizeof(usize));\n+    return mem;\n }\n \n /** Align address downwards. */\n static_inline void *mem_align_down(void *mem, usize align) {\n-   usize size;\n-   memcpy(&size, &mem, sizeof(usize));\n-   size = size_align_down(size, align);\n-   memcpy(&mem, &size, sizeof(usize));\n-   return mem;\n+    usize size;\n+    memcpy(&size, &mem, sizeof(usize));\n+    size = size_align_down(size, align);\n+    memcpy(&mem, &size, sizeof(usize));\n+    return mem;\n }\n \n \n \n /*==============================================================================\n-* Bits Utils\n-* These functions are used by the floating-point number reader and writer.\n-*============================================================================*/\n+ * Bits Utils\n+ * These functions are used by the floating-point number reader and writer.\n+ *============================================================================*/\n \n /** Returns the number of leading 0-bits in value (input should not be 0). */\n static_inline u32 u64_lz_bits(u64 v) {\n #if GCC_HAS_CLZLL\n-   return (u32)__builtin_clzll(v);\n+    return (u32)__builtin_clzll(v);\n #elif MSC_HAS_BIT_SCAN_64\n-   unsigned long r;\n-   _BitScanReverse64(&r, v);\n-   return (u32)63 - (u32)r;\n+    unsigned long r;\n+    _BitScanReverse64(&r, v);\n+    return (u32)63 - (u32)r;\n #elif MSC_HAS_BIT_SCAN\n-   unsigned long hi, lo;\n-   bool hi_set = _BitScanReverse(&hi, (u32)(v >> 32)) != 0;\n-   _BitScanReverse(&lo, (u32)v);\n-   hi |= 32;\n-   return (u32)63 - (u32)(hi_set ? hi : lo);\n+    unsigned long hi, lo;\n+    bool hi_set = _BitScanReverse(&hi, (u32)(v >> 32)) != 0;\n+    _BitScanReverse(&lo, (u32)v);\n+    hi |= 32;\n+    return (u32)63 - (u32)(hi_set ? hi : lo);\n #else\n-   /*\n-\tbranchless, use de Bruijn sequences\n-\tsee: https://www.chessprogramming.org/BitScan\n-\t*/\n-   const u8 table[64] = {\n-\t   63, 16, 62,  7, 15, 36, 61,  3,  6, 14, 22, 26, 35, 47, 60,  2,\n-\t   9,  5, 28, 11, 13, 21, 42, 19, 25, 31, 34, 40, 46, 52, 59,  1,\n-\t   17,  8, 37,  4, 23, 27, 48, 10, 29, 12, 43, 20, 32, 41, 53, 18,\n-\t   38, 24, 49, 30, 44, 33, 54, 39, 50, 45, 55, 51, 56, 57, 58,  0\n-   };\n-   v |= v >> 1;\n-   v |= v >> 2;\n-   v |= v >> 4;\n-   v |= v >> 8;\n-   v |= v >> 16;\n-   v |= v >> 32;\n-   return table[(v * U64(0x03F79D71, 0xB4CB0A89)) >> 58];\n+    /*\n+     branchless, use de Bruijn sequences\n+     see: https://www.chessprogramming.org/BitScan\n+     */\n+    const u8 table[64] = {\n+        63, 16, 62,  7, 15, 36, 61,  3,  6, 14, 22, 26, 35, 47, 60,  2,\n+         9,  5, 28, 11, 13, 21, 42, 19, 25, 31, 34, 40, 46, 52, 59,  1,\n+        17,  8, 37,  4, 23, 27, 48, 10, 29, 12, 43, 20, 32, 41, 53, 18,\n+        38, 24, 49, 30, 44, 33, 54, 39, 50, 45, 55, 51, 56, 57, 58,  0\n+    };\n+    v |= v >> 1;\n+    v |= v >> 2;\n+    v |= v >> 4;\n+    v |= v >> 8;\n+    v |= v >> 16;\n+    v |= v >> 32;\n+    return table[(v * U64(0x03F79D71, 0xB4CB0A89)) >> 58];\n #endif\n }\n \n /** Returns the number of trailing 0-bits in value (input should not be 0). */\n static_inline u32 u64_tz_bits(u64 v) {\n #if GCC_HAS_CTZLL\n-   return (u32)__builtin_ctzll(v);\n+    return (u32)__builtin_ctzll(v);\n #elif MSC_HAS_BIT_SCAN_64\n-   unsigned long r;\n-   _BitScanForward64(&r, v);\n-   return (u32)r;\n+    unsigned long r;\n+    _BitScanForward64(&r, v);\n+    return (u32)r;\n #elif MSC_HAS_BIT_SCAN\n-   unsigned long lo, hi;\n-   bool lo_set = _BitScanForward(&lo, (u32)(v)) != 0;\n-   _BitScanForward(&hi, (u32)(v >> 32));\n-   hi += 32;\n-   return lo_set ? lo : hi;\n+    unsigned long lo, hi;\n+    bool lo_set = _BitScanForward(&lo, (u32)(v)) != 0;\n+    _BitScanForward(&hi, (u32)(v >> 32));\n+    hi += 32;\n+    return lo_set ? lo : hi;\n #else\n-   /*\n-\tbranchless, use de Bruijn sequences\n-\tsee: https://www.chessprogramming.org/BitScan\n-\t*/\n-   const u8 table[64] = {\n-\t   0,  1,  2, 53,  3,  7, 54, 27,  4, 38, 41,  8, 34, 55, 48, 28,\n-\t   62,  5, 39, 46, 44, 42, 22,  9, 24, 35, 59, 56, 49, 18, 29, 11,\n-\t   63, 52,  6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,\n-\t   51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12\n-   };\n-   return table[((v & (~v + 1)) * U64(0x022FDD63, 0xCC95386D)) >> 58];\n+    /*\n+     branchless, use de Bruijn sequences\n+     see: https://www.chessprogramming.org/BitScan\n+     */\n+    const u8 table[64] = {\n+         0,  1,  2, 53,  3,  7, 54, 27,  4, 38, 41,  8, 34, 55, 48, 28,\n+        62,  5, 39, 46, 44, 42, 22,  9, 24, 35, 59, 56, 49, 18, 29, 11,\n+        63, 52,  6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,\n+        51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12\n+    };\n+    return table[((v & (~v + 1)) * U64(0x022FDD63, 0xCC95386D)) >> 58];\n #endif\n }\n \n \n \n /*==============================================================================\n-* 128-bit Integer Utils\n-* These functions are used by the floating-point number reader and writer.\n-*============================================================================*/\n+ * 128-bit Integer Utils\n+ * These functions are used by the floating-point number reader and writer.\n+ *============================================================================*/\n \n /** Multiplies two 64-bit unsigned integers (a * b),\n-   returns the 128-bit result as 'hi' and 'lo'. */\n+    returns the 128-bit result as 'hi' and 'lo'. */\n static_inline void u128_mul(u64 a, u64 b, u64 *hi, u64 *lo) {\n #if YYJSON_HAS_INT128\n-   u128 m = (u128)a * b;\n-   *hi = (u64)(m >> 64);\n-   *lo = (u64)(m);\n+    u128 m = (u128)a * b;\n+    *hi = (u64)(m >> 64);\n+    *lo = (u64)(m);\n #elif MSC_HAS_UMUL128\n-   *lo = _umul128(a, b, hi);\n+    *lo = _umul128(a, b, hi);\n #else\n-   u32 a0 = (u32)(a), a1 = (u32)(a >> 32);\n-   u32 b0 = (u32)(b), b1 = (u32)(b >> 32);\n-   u64 p00 = (u64)a0 * b0, p01 = (u64)a0 * b1;\n-   u64 p10 = (u64)a1 * b0, p11 = (u64)a1 * b1;\n-   u64 m0 = p01 + (p00 >> 32);\n-   u32 m00 = (u32)(m0), m01 = (u32)(m0 >> 32);\n-   u64 m1 = p10 + m00;\n-   u32 m10 = (u32)(m1), m11 = (u32)(m1 >> 32);\n-   *hi = p11 + m01 + m11;\n-   *lo = ((u64)m10 << 32) | (u32)p00;\n+    u32 a0 = (u32)(a), a1 = (u32)(a >> 32);\n+    u32 b0 = (u32)(b), b1 = (u32)(b >> 32);\n+    u64 p00 = (u64)a0 * b0, p01 = (u64)a0 * b1;\n+    u64 p10 = (u64)a1 * b0, p11 = (u64)a1 * b1;\n+    u64 m0 = p01 + (p00 >> 32);\n+    u32 m00 = (u32)(m0), m01 = (u32)(m0 >> 32);\n+    u64 m1 = p10 + m00;\n+    u32 m10 = (u32)(m1), m11 = (u32)(m1 >> 32);\n+    *hi = p11 + m01 + m11;\n+    *lo = ((u64)m10 << 32) | (u32)p00;\n #endif\n }\n \n /** Multiplies two 64-bit unsigned integers and add a value (a * b + c),\n-   returns the 128-bit result as 'hi' and 'lo'. */\n+    returns the 128-bit result as 'hi' and 'lo'. */\n static_inline void u128_mul_add(u64 a, u64 b, u64 c, u64 *hi, u64 *lo) {\n #if YYJSON_HAS_INT128\n-   u128 m = (u128)a * b + c;\n-   *hi = (u64)(m >> 64);\n-   *lo = (u64)(m);\n+    u128 m = (u128)a * b + c;\n+    *hi = (u64)(m >> 64);\n+    *lo = (u64)(m);\n #else\n-   u64 h, l, t;\n-   u128_mul(a, b, &h, &l);\n-   t = l + c;\n-   h += (u64)(((t < l) | (t < c)));\n-   *hi = h;\n-   *lo = t;\n+    u64 h, l, t;\n+    u128_mul(a, b, &h, &l);\n+    t = l + c;\n+    h += (u64)(((t < l) | (t < c)));\n+    *hi = h;\n+    *lo = t;\n #endif\n }\n \n \n \n /*==============================================================================\n-* File Utils\n-* These functions are used to read and write JSON files.\n-*============================================================================*/\n+ * File Utils\n+ * These functions are used to read and write JSON files.\n+ *============================================================================*/\n \n #define YYJSON_FOPEN_EXT\n #if !defined(_MSC_VER) && defined(__GLIBC__) && defined(__GLIBC_PREREQ)\n@@ -930,727 +909,862 @@ static_inline void u128_mul_add(u64 a, u64 b, u64 c, u64 *hi, u64 *lo) {\n \n static_inline FILE *fopen_safe(const char *path, const char *mode) {\n #if YYJSON_MSC_VER >= 1400\n-   FILE *file = NULL;\n-   if (fopen_s(&file, path, mode) != 0) return NULL;\n-   return file;\n+    FILE *file = NULL;\n+    if (fopen_s(&file, path, mode) != 0) return NULL;\n+    return file;\n #else\n-   return fopen(path, mode);\n+    return fopen(path, mode);\n #endif\n }\n \n static_inline FILE *fopen_readonly(const char *path) {\n-   return fopen_safe(path, \"rb\" YYJSON_FOPEN_EXT);\n+    return fopen_safe(path, \"rb\" YYJSON_FOPEN_EXT);\n }\n \n static_inline FILE *fopen_writeonly(const char *path) {\n-   return fopen_safe(path, \"wb\" YYJSON_FOPEN_EXT);\n+    return fopen_safe(path, \"wb\" YYJSON_FOPEN_EXT);\n }\n \n static_inline usize fread_safe(void *buf, usize size, FILE *file) {\n #if YYJSON_MSC_VER >= 1400\n-   return fread_s(buf, size, 1, size, file);\n+    return fread_s(buf, size, 1, size, file);\n #else\n-   return fread(buf, 1, size, file);\n+    return fread(buf, 1, size, file);\n #endif\n }\n \n \n \n /*==============================================================================\n-* Default Memory Allocator\n-* This is a simple libc memory allocator wrapper.\n-*============================================================================*/\n+ * Default Memory Allocator\n+ * This is a simple libc memory allocator wrapper.\n+ *============================================================================*/\n \n static void *default_malloc(void *ctx, usize size) {\n-   return malloc(size);\n+    return malloc(size);\n }\n \n-static void *default_realloc(void *ctx, void *ptr, usize size) {\n-   return realloc(ptr, size);\n+static void *default_realloc(void *ctx, void *ptr, usize old_size, usize size) {\n+    return realloc(ptr, size);\n }\n \n static void default_free(void *ctx, void *ptr) {\n-   free(ptr);\n+    free(ptr);\n }\n \n static const yyjson_alc YYJSON_DEFAULT_ALC = {\n-   default_malloc,\n-   default_realloc,\n-   default_free,\n-   NULL\n+    default_malloc,\n+    default_realloc,\n+    default_free,\n+    NULL\n+};\n+\n+static void *null_malloc(void *ctx, usize size) {\n+    return NULL;\n+}\n+\n+static void *null_realloc(void *ctx, void *ptr, usize old_size, usize size) {\n+    return NULL;\n+}\n+\n+static void null_free(void *ctx, void *ptr) {\n+    return;\n+}\n+\n+static const yyjson_alc YYJSON_NULL_ALC = {\n+    null_malloc,\n+    null_realloc,\n+    null_free,\n+    NULL\n };\n \n \n \n /*==============================================================================\n-* Pool Memory Allocator\n-* This is a simple memory allocator that uses linked list memory chunk.\n-* The following code will be executed only when the library user creates\n-* this allocator manually.\n-*============================================================================*/\n+ * Pool Memory Allocator\n+ * This is a simple memory allocator that uses linked list memory chunk.\n+ * The following code will be executed only when the library user creates\n+ * this allocator manually.\n+ *============================================================================*/\n \n /** chunk header */\n typedef struct pool_chunk {\n-   usize size; /* chunk memory size (include chunk header) */\n-   struct pool_chunk *next;\n+    usize size; /* chunk memory size (include chunk header) */\n+    struct pool_chunk *next;\n } pool_chunk;\n \n /** ctx header */\n typedef struct pool_ctx {\n-   usize size; /* total memory size (include ctx header) */\n-   pool_chunk *free_list;\n+    usize size; /* total memory size (include ctx header) */\n+    pool_chunk *free_list;\n } pool_ctx;\n \n static void *pool_malloc(void *ctx_ptr, usize size) {\n-   pool_ctx *ctx = (pool_ctx *)ctx_ptr;\n-   pool_chunk *next, *prev = NULL, *cur = ctx->free_list;\n-\n-   if (unlikely(size == 0 || size >= ctx->size)) return NULL;\n-   size = size_align_up(size, sizeof(pool_chunk)) + sizeof(pool_chunk);\n-\n-   while (cur) {\n-\t   if (cur->size < size) {\n-\t\t   /* not enough space, try next chunk */\n-\t\t   prev = cur;\n-\t\t   cur = cur->next;\n-\t\t   continue;\n-\t   }\n-\t   if (cur->size >= size + sizeof(pool_chunk) * 2) {\n-\t\t   /* too much space, split this chunk */\n-\t\t   next = (pool_chunk *)(void *)((u8 *)cur + size);\n-\t\t   next->size = cur->size - size;\n-\t\t   next->next = cur->next;\n-\t\t   cur->size = size;\n-\t   } else {\n-\t\t   /* just enough space, use whole chunk */\n-\t\t   next = cur->next;\n-\t   }\n-\t   if (prev) prev->next = next;\n-\t   else ctx->free_list = next;\n-\t   return (void *)(cur + 1);\n-   }\n-   return NULL;\n+    pool_ctx *ctx = (pool_ctx *)ctx_ptr;\n+    pool_chunk *next, *prev = NULL, *cur = ctx->free_list;\n+    \n+    if (unlikely(size == 0 || size >= ctx->size)) return NULL;\n+    size = size_align_up(size, sizeof(pool_chunk)) + sizeof(pool_chunk);\n+    \n+    while (cur) {\n+        if (cur->size < size) {\n+            /* not enough space, try next chunk */\n+            prev = cur;\n+            cur = cur->next;\n+            continue;\n+        }\n+        if (cur->size >= size + sizeof(pool_chunk) * 2) {\n+            /* too much space, split this chunk */\n+            next = (pool_chunk *)(void *)((u8 *)cur + size);\n+            next->size = cur->size - size;\n+            next->next = cur->next;\n+            cur->size = size;\n+        } else {\n+            /* just enough space, use whole chunk */\n+            next = cur->next;\n+        }\n+        if (prev) prev->next = next;\n+        else ctx->free_list = next;\n+        return (void *)(cur + 1);\n+    }\n+    return NULL;\n }\n \n static void pool_free(void *ctx_ptr, void *ptr) {\n-   pool_ctx *ctx = (pool_ctx *)ctx_ptr;\n-   pool_chunk *cur = ((pool_chunk *)ptr) - 1;\n-   pool_chunk *prev = NULL, *next = ctx->free_list;\n-\n-   while (next && next < cur) {\n-\t   prev = next;\n-\t   next = next->next;\n-   }\n-   if (prev) prev->next = cur;\n-   else ctx->free_list = cur;\n-   cur->next = next;\n-\n-   if (next && ((u8 *)cur + cur->size) == (u8 *)next) {\n-\t   /* merge cur to higher chunk */\n-\t   cur->size += next->size;\n-\t   cur->next = next->next;\n-   }\n-   if (prev && ((u8 *)prev + prev->size) == (u8 *)cur) {\n-\t   /* merge cur to lower chunk */\n-\t   prev->size += cur->size;\n-\t   prev->next = cur->next;\n-   }\n-}\n-\n-static void *pool_realloc(void *ctx_ptr, void *ptr, usize size) {\n-   pool_ctx *ctx = (pool_ctx *)ctx_ptr;\n-   pool_chunk *cur = ((pool_chunk *)ptr) - 1, *prev, *next, *tmp;\n-   usize free_size;\n-   void *new_ptr;\n-\n-   if (unlikely(size == 0 || size >= ctx->size)) return NULL;\n-   size = size_align_up(size, sizeof(pool_chunk)) + sizeof(pool_chunk);\n-\n-   /* reduce size */\n-   if (unlikely(size <= cur->size)) {\n-\t   free_size = cur->size - size;\n-\t   if (free_size >= sizeof(pool_chunk) * 2) {\n-\t\t   tmp = (pool_chunk *)(void *)((u8 *)cur + cur->size - free_size);\n-\t\t   tmp->size = free_size;\n-\t\t   pool_free(ctx_ptr, (void *)(tmp + 1));\n-\t\t   cur->size -= free_size;\n-\t   }\n-\t   return ptr;\n-   }\n-\n-   /* find next and prev chunk */\n-   prev = NULL;\n-   next = ctx->free_list;\n-   while (next && next < cur) {\n-\t   prev = next;\n-\t   next = next->next;\n-   }\n-\n-   /* merge to higher chunk if they are contiguous */\n-   if ((u8 *)cur + cur->size == (u8 *)next &&\n-\t   cur->size + next->size >= size) {\n-\t   free_size = cur->size + next->size - size;\n-\t   if (free_size > sizeof(pool_chunk) * 2) {\n-\t\t   tmp = (pool_chunk *)(void *)((u8 *)cur + size);\n-\t\t   if (prev) prev->next = tmp;\n-\t\t   else ctx->free_list = tmp;\n-\t\t   tmp->next = next->next;\n-\t\t   tmp->size = free_size;\n-\t\t   cur->size = size;\n-\t   } else {\n-\t\t   if (prev) prev->next = next->next;\n-\t\t   else ctx->free_list = next->next;\n-\t\t   cur->size += next->size;\n-\t   }\n-\t   return ptr;\n-   }\n-\n-   /* fallback to malloc and memcpy */\n-   new_ptr = pool_malloc(ctx_ptr, size - sizeof(pool_chunk));\n-   if (new_ptr) {\n-\t   memcpy(new_ptr, ptr, cur->size - sizeof(pool_chunk));\n-\t   pool_free(ctx_ptr, ptr);\n-   }\n-   return new_ptr;\n+    pool_ctx *ctx = (pool_ctx *)ctx_ptr;\n+    pool_chunk *cur = ((pool_chunk *)ptr) - 1;\n+    pool_chunk *prev = NULL, *next = ctx->free_list;\n+    \n+    while (next && next < cur) {\n+        prev = next;\n+        next = next->next;\n+    }\n+    if (prev) prev->next = cur;\n+    else ctx->free_list = cur;\n+    cur->next = next;\n+    \n+    if (next && ((u8 *)cur + cur->size) == (u8 *)next) {\n+        /* merge cur to higher chunk */\n+        cur->size += next->size;\n+        cur->next = next->next;\n+    }\n+    if (prev && ((u8 *)prev + prev->size) == (u8 *)cur) {\n+        /* merge cur to lower chunk */\n+        prev->size += cur->size;\n+        prev->next = cur->next;\n+    }\n+}\n+\n+static void *pool_realloc(void *ctx_ptr, void *ptr,\n+                          usize old_size, usize size) {\n+    pool_ctx *ctx = (pool_ctx *)ctx_ptr;\n+    pool_chunk *cur = ((pool_chunk *)ptr) - 1, *prev, *next, *tmp;\n+    usize free_size;\n+    void *new_ptr;\n+    \n+    if (unlikely(size == 0 || size >= ctx->size)) return NULL;\n+    size = size_align_up(size, sizeof(pool_chunk)) + sizeof(pool_chunk);\n+    \n+    /* reduce size */\n+    if (unlikely(size <= cur->size)) {\n+        free_size = cur->size - size;\n+        if (free_size >= sizeof(pool_chunk) * 2) {\n+            tmp = (pool_chunk *)(void *)((u8 *)cur + cur->size - free_size);\n+            tmp->size = free_size;\n+            pool_free(ctx_ptr, (void *)(tmp + 1));\n+            cur->size -= free_size;\n+        }\n+        return ptr;\n+    }\n+    \n+    /* find next and prev chunk */\n+    prev = NULL;\n+    next = ctx->free_list;\n+    while (next && next < cur) {\n+        prev = next;\n+        next = next->next;\n+    }\n+    \n+    /* merge to higher chunk if they are contiguous */\n+    if ((u8 *)cur + cur->size == (u8 *)next &&\n+        cur->size + next->size >= size) {\n+        free_size = cur->size + next->size - size;\n+        if (free_size > sizeof(pool_chunk) * 2) {\n+            tmp = (pool_chunk *)(void *)((u8 *)cur + size);\n+            if (prev) prev->next = tmp;\n+            else ctx->free_list = tmp;\n+            tmp->next = next->next;\n+            tmp->size = free_size;\n+            cur->size = size;\n+        } else {\n+            if (prev) prev->next = next->next;\n+            else ctx->free_list = next->next;\n+            cur->size += next->size;\n+        }\n+        return ptr;\n+    }\n+    \n+    /* fallback to malloc and memcpy */\n+    new_ptr = pool_malloc(ctx_ptr, size - sizeof(pool_chunk));\n+    if (new_ptr) {\n+        memcpy(new_ptr, ptr, cur->size - sizeof(pool_chunk));\n+        pool_free(ctx_ptr, ptr);\n+    }\n+    return new_ptr;\n }\n \n bool yyjson_alc_pool_init(yyjson_alc *alc, void *buf, usize size) {\n-   pool_chunk *chunk;\n-   pool_ctx *ctx;\n-\n-   if (unlikely(!alc || size < sizeof(pool_ctx) * 4)) return false;\n-   ctx = (pool_ctx *)mem_align_up(buf, sizeof(pool_ctx));\n-   if (unlikely(!ctx)) return false;\n-   size -= (usize)((u8 *)ctx - (u8 *)buf);\n-   size = size_align_down(size, sizeof(pool_ctx));\n-\n-   chunk = (pool_chunk *)(ctx + 1);\n-   chunk->size = size - sizeof(pool_ctx);\n-   chunk->next = NULL;\n-   ctx->size = size;\n-   ctx->free_list = chunk;\n-\n-   alc->malloc = pool_malloc;\n-   alc->realloc = pool_realloc;\n-   alc->free = pool_free;\n-   alc->ctx = (void *)ctx;\n-   return true;\n+    pool_chunk *chunk;\n+    pool_ctx *ctx;\n+    \n+    if (unlikely(!alc)) return false;\n+    *alc = YYJSON_NULL_ALC;\n+    if (size < sizeof(pool_ctx) * 4) return false;\n+    ctx = (pool_ctx *)mem_align_up(buf, sizeof(pool_ctx));\n+    if (unlikely(!ctx)) return false;\n+    size -= (usize)((u8 *)ctx - (u8 *)buf);\n+    size = size_align_down(size, sizeof(pool_ctx));\n+    \n+    chunk = (pool_chunk *)(ctx + 1);\n+    chunk->size = size - sizeof(pool_ctx);\n+    chunk->next = NULL;\n+    ctx->size = size;\n+    ctx->free_list = chunk;\n+    \n+    alc->malloc = pool_malloc;\n+    alc->realloc = pool_realloc;\n+    alc->free = pool_free;\n+    alc->ctx = (void *)ctx;\n+    return true;\n }\n \n \n \n /*==============================================================================\n-* JSON document and value\n-*============================================================================*/\n+ * JSON document and value\n+ *============================================================================*/\n \n static_inline void unsafe_yyjson_str_pool_release(yyjson_str_pool *pool,\n-\t\t\t\t\t\t\t\t\t\t\t\t yyjson_alc *alc) {\n-   yyjson_str_chunk *chunk = pool->chunks, *next;\n-   while (chunk) {\n-\t   next = chunk->next;\n-\t   alc->free(alc->ctx, chunk);\n-\t   chunk = next;\n-   }\n+                                                  yyjson_alc *alc) {\n+    yyjson_str_chunk *chunk = pool->chunks, *next;\n+    while (chunk) {\n+        next = chunk->next;\n+        alc->free(alc->ctx, chunk);\n+        chunk = next;\n+    }\n }\n \n static_inline void unsafe_yyjson_val_pool_release(yyjson_val_pool *pool,\n-\t\t\t\t\t\t\t\t\t\t\t\t yyjson_alc *alc) {\n-   yyjson_val_chunk *chunk = pool->chunks, *next;\n-   while (chunk) {\n-\t   next = chunk->next;\n-\t   alc->free(alc->ctx, chunk);\n-\t   chunk = next;\n-   }\n+                                                  yyjson_alc *alc) {\n+    yyjson_val_chunk *chunk = pool->chunks, *next;\n+    while (chunk) {\n+        next = chunk->next;\n+        alc->free(alc->ctx, chunk);\n+        chunk = next;\n+    }\n }\n \n bool unsafe_yyjson_str_pool_grow(yyjson_str_pool *pool,\n-\t\t\t\t\t\t\t\tyyjson_alc *alc, usize len) {\n-   yyjson_str_chunk *chunk;\n-   usize size = len + sizeof(yyjson_str_chunk);\n-   size = yyjson_max(pool->chunk_size, size);\n-   chunk = (yyjson_str_chunk *)alc->malloc(alc->ctx, size);\n-   if (yyjson_unlikely(!chunk)) return false;\n-\n-   chunk->next = pool->chunks;\n-   pool->chunks = chunk;\n-   pool->cur = (char *)chunk + sizeof(yyjson_str_chunk);\n-   pool->end = (char *)chunk + size;\n-\n-   size = yyjson_min(pool->chunk_size * 2, pool->chunk_size_max);\n-   pool->chunk_size = size;\n-   return true;\n+                                 const yyjson_alc *alc, usize len) {\n+    yyjson_str_chunk *chunk;\n+    usize size = len + sizeof(yyjson_str_chunk);\n+    size = yyjson_max(pool->chunk_size, size);\n+    chunk = (yyjson_str_chunk *)alc->malloc(alc->ctx, size);\n+    if (yyjson_unlikely(!chunk)) return false;\n+    \n+    chunk->next = pool->chunks;\n+    pool->chunks = chunk;\n+    pool->cur = (char *)chunk + sizeof(yyjson_str_chunk);\n+    pool->end = (char *)chunk + size;\n+    \n+    size = yyjson_min(pool->chunk_size * 2, pool->chunk_size_max);\n+    pool->chunk_size = size;\n+    return true;\n }\n \n bool unsafe_yyjson_val_pool_grow(yyjson_val_pool *pool,\n-\t\t\t\t\t\t\t\tyyjson_alc *alc, usize count) {\n-   yyjson_val_chunk *chunk;\n-   usize size;\n-\n-   if (count >= USIZE_MAX / sizeof(yyjson_mut_val) - 16) return false;\n-   size = (count + 1) * sizeof(yyjson_mut_val);\n-   size = yyjson_max(pool->chunk_size, size);\n-   chunk = (yyjson_val_chunk *)alc->malloc(alc->ctx, size);\n-   if (yyjson_unlikely(!chunk)) return false;\n-\n-   chunk->next = pool->chunks;\n-   pool->chunks = chunk;\n-   pool->cur = (yyjson_mut_val *)(void *)((u8 *)chunk\n-\t\t\t\t\t\t\t\t\t\t  + sizeof(yyjson_mut_val));\n-   pool->end = (yyjson_mut_val *)(void *)((u8 *)chunk + size);\n-\n-   size = yyjson_min(pool->chunk_size * 2, pool->chunk_size_max);\n-   pool->chunk_size = size;\n-   return true;\n+                                 const yyjson_alc *alc, usize count) {\n+    yyjson_val_chunk *chunk;\n+    usize size;\n+    \n+    if (count >= USIZE_MAX / sizeof(yyjson_mut_val) - 16) return false;\n+    size = (count + 1) * sizeof(yyjson_mut_val);\n+    size = yyjson_max(pool->chunk_size, size);\n+    chunk = (yyjson_val_chunk *)alc->malloc(alc->ctx, size);\n+    if (yyjson_unlikely(!chunk)) return false;\n+    \n+    chunk->next = pool->chunks;\n+    pool->chunks = chunk;\n+    pool->cur = (yyjson_mut_val *)(void *)((u8 *)chunk\n+                                           + sizeof(yyjson_mut_val));\n+    pool->end = (yyjson_mut_val *)(void *)((u8 *)chunk + size);\n+    \n+    size = yyjson_min(pool->chunk_size * 2, pool->chunk_size_max);\n+    pool->chunk_size = size;\n+    return true;\n }\n \n void yyjson_mut_doc_free(yyjson_mut_doc *doc) {\n-   if (doc) {\n-\t   yyjson_alc alc = doc->alc;\n-\t   unsafe_yyjson_str_pool_release(&doc->str_pool, &alc);\n-\t   unsafe_yyjson_val_pool_release(&doc->val_pool, &alc);\n-\t   alc.free(alc.ctx, doc);\n-   }\n+    if (doc) {\n+        yyjson_alc alc = doc->alc;\n+        unsafe_yyjson_str_pool_release(&doc->str_pool, &alc);\n+        unsafe_yyjson_val_pool_release(&doc->val_pool, &alc);\n+        alc.free(alc.ctx, doc);\n+    }\n }\n \n yyjson_mut_doc *yyjson_mut_doc_new(const yyjson_alc *alc) {\n-   yyjson_mut_doc *doc;\n-   if (!alc) alc = &YYJSON_DEFAULT_ALC;\n-   doc = (yyjson_mut_doc *)alc->malloc(alc->ctx, sizeof(yyjson_mut_doc));\n-   if (!doc) return NULL;\n-   memset(doc, 0, sizeof(yyjson_mut_doc));\n-\n-   doc->alc = *alc;\n-   doc->str_pool.chunk_size = 0x100;\n-   doc->str_pool.chunk_size_max = 0x10000000;\n-   doc->val_pool.chunk_size = 0x10 * sizeof(yyjson_mut_val);\n-   doc->val_pool.chunk_size_max = 0x1000000 * sizeof(yyjson_mut_val);\n-   return doc;\n+    yyjson_mut_doc *doc;\n+    if (!alc) alc = &YYJSON_DEFAULT_ALC;\n+    doc = (yyjson_mut_doc *)alc->malloc(alc->ctx, sizeof(yyjson_mut_doc));\n+    if (!doc) return NULL;\n+    memset(doc, 0, sizeof(yyjson_mut_doc));\n+    \n+    doc->alc = *alc;\n+    doc->str_pool.chunk_size = 0x100;\n+    doc->str_pool.chunk_size_max = 0x10000000;\n+    doc->val_pool.chunk_size = 0x10 * sizeof(yyjson_mut_val);\n+    doc->val_pool.chunk_size_max = 0x1000000 * sizeof(yyjson_mut_val);\n+    return doc;\n }\n \n yyjson_api yyjson_mut_doc *yyjson_doc_mut_copy(yyjson_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t  const yyjson_alc *alc) {\n-   yyjson_mut_doc *m_doc;\n-   yyjson_mut_val *m_val;\n-\n-   if (!doc || !doc->root) return NULL;\n-   m_doc = yyjson_mut_doc_new(alc);\n-   if (!m_doc) return NULL;\n-   m_val = yyjson_val_mut_copy(m_doc, doc->root);\n-   if (!m_val) {\n-\t   yyjson_mut_doc_free(m_doc);\n-\t   return NULL;\n-   }\n-   yyjson_mut_doc_set_root(m_doc, m_val);\n-   return m_doc;\n+                                               const yyjson_alc *alc) {\n+    yyjson_mut_doc *m_doc;\n+    yyjson_mut_val *m_val;\n+    \n+    if (!doc || !doc->root) return NULL;\n+    m_doc = yyjson_mut_doc_new(alc);\n+    if (!m_doc) return NULL;\n+    m_val = yyjson_val_mut_copy(m_doc, doc->root);\n+    if (!m_val) {\n+        yyjson_mut_doc_free(m_doc);\n+        return NULL;\n+    }\n+    yyjson_mut_doc_set_root(m_doc, m_val);\n+    return m_doc;\n }\n \n yyjson_api yyjson_mut_doc *yyjson_mut_doc_mut_copy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t  const yyjson_alc *alc) {\n-   yyjson_mut_doc *m_doc;\n-   yyjson_mut_val *m_val;\n-\n-   if (!doc || !doc->root) return NULL;\n-   m_doc = yyjson_mut_doc_new(alc);\n-   if (!m_doc) return NULL;\n-   m_val = yyjson_mut_val_mut_copy(m_doc, doc->root);\n-   if (!m_val) {\n-\t   yyjson_mut_doc_free(m_doc);\n-\t   return NULL;\n-   }\n-   yyjson_mut_doc_set_root(m_doc, m_val);\n-   return m_doc;\n+                                                   const yyjson_alc *alc) {\n+    yyjson_mut_doc *m_doc;\n+    yyjson_mut_val *m_val;\n+    \n+    if (!doc || !doc->root) return NULL;\n+    m_doc = yyjson_mut_doc_new(alc);\n+    if (!m_doc) return NULL;\n+    m_val = yyjson_mut_val_mut_copy(m_doc, doc->root);\n+    if (!m_val) {\n+        yyjson_mut_doc_free(m_doc);\n+        return NULL;\n+    }\n+    yyjson_mut_doc_set_root(m_doc, m_val);\n+    return m_doc;\n }\n \n yyjson_api yyjson_mut_val *yyjson_val_mut_copy(yyjson_mut_doc *m_doc,\n-\t\t\t\t\t\t\t\t\t\t\t  yyjson_val *i_vals) {\n-   /*\n-\tThe immutable object or array stores all sub-values in a contiguous memory,\n-\tWe copy them to another contiguous memory as mutable values,\n-\tthen reconnect the mutable values with the original relationship.\n-\t*/\n-\n-   usize i_vals_len;\n-   yyjson_mut_val *m_vals, *m_val;\n-   yyjson_val *i_val, *i_end;\n-\n-   if (!m_doc || !i_vals) return NULL;\n-   i_end = unsafe_yyjson_get_next(i_vals);\n-   i_vals_len = (usize)(unsafe_yyjson_get_next(i_vals) - i_vals);\n-   m_vals = unsafe_yyjson_mut_val(m_doc, i_vals_len);\n-   if (!m_vals) return NULL;\n-   i_val = i_vals;\n-   m_val = m_vals;\n-\n-   for (; i_val < i_end; i_val++, m_val++) {\n-\t   yyjson_type type = unsafe_yyjson_get_type(i_val);\n-\t   m_val->tag = i_val->tag;\n-\t   m_val->uni.u64 = i_val->uni.u64;\n-\t   if (type == YYJSON_TYPE_STR || type == YYJSON_TYPE_RAW) {\n-\t\t   const char *str = i_val->uni.str;\n-\t\t   usize str_len = unsafe_yyjson_get_len(i_val);\n-\t\t   m_val->uni.str = unsafe_yyjson_mut_strncpy(m_doc, str, str_len);\n-\t\t   if (!m_val->uni.str) return NULL;\n-\t   } else if (type == YYJSON_TYPE_ARR) {\n-\t\t   usize len = unsafe_yyjson_get_len(i_val);\n-\t\t   if (len > 0) {\n-\t\t\t   yyjson_val *ii_val = i_val + 1, *ii_next;\n-\t\t\t   yyjson_mut_val *mm_val = m_val + 1, *mm_ctn = m_val, *mm_next;\n-\t\t\t   while (len-- > 1) {\n-\t\t\t\t   ii_next = unsafe_yyjson_get_next(ii_val);\n-\t\t\t\t   mm_next = mm_val + (ii_next - ii_val);\n-\t\t\t\t   mm_val->next = mm_next;\n-\t\t\t\t   ii_val = ii_next;\n-\t\t\t\t   mm_val = mm_next;\n-\t\t\t   }\n-\t\t\t   mm_val->next = mm_ctn + 1;\n-\t\t\t   mm_ctn->uni.ptr = mm_val;\n-\t\t   }\n-\t   } else if (type == YYJSON_TYPE_OBJ) {\n-\t\t   usize len = unsafe_yyjson_get_len(i_val);\n-\t\t   if (len > 0) {\n-\t\t\t   yyjson_val *ii_key = i_val + 1, *ii_nextkey;\n-\t\t\t   yyjson_mut_val *mm_key = m_val + 1, *mm_ctn = m_val;\n-\t\t\t   yyjson_mut_val *mm_nextkey;\n-\t\t\t   while (len-- > 1) {\n-\t\t\t\t   ii_nextkey = unsafe_yyjson_get_next(ii_key + 1);\n-\t\t\t\t   mm_nextkey = mm_key + (ii_nextkey - ii_key);\n-\t\t\t\t   mm_key->next = mm_key + 1;\n-\t\t\t\t   mm_key->next->next = mm_nextkey;\n-\t\t\t\t   ii_key = ii_nextkey;\n-\t\t\t\t   mm_key = mm_nextkey;\n-\t\t\t   }\n-\t\t\t   mm_key->next = mm_key + 1;\n-\t\t\t   mm_key->next->next = mm_ctn + 1;\n-\t\t\t   mm_ctn->uni.ptr = mm_key;\n-\t\t   }\n-\t   }\n-   }\n-\n-   return m_vals;\n+                                               yyjson_val *i_vals) {\n+    /*\n+     The immutable object or array stores all sub-values in a contiguous memory,\n+     We copy them to another contiguous memory as mutable values,\n+     then reconnect the mutable values with the original relationship.\n+     */\n+    \n+    usize i_vals_len;\n+    yyjson_mut_val *m_vals, *m_val;\n+    yyjson_val *i_val, *i_end;\n+    \n+    if (!m_doc || !i_vals) return NULL;\n+    i_end = unsafe_yyjson_get_next(i_vals);\n+    i_vals_len = (usize)(unsafe_yyjson_get_next(i_vals) - i_vals);\n+    m_vals = unsafe_yyjson_mut_val(m_doc, i_vals_len);\n+    if (!m_vals) return NULL;\n+    i_val = i_vals;\n+    m_val = m_vals;\n+    \n+    for (; i_val < i_end; i_val++, m_val++) {\n+        yyjson_type type = unsafe_yyjson_get_type(i_val);\n+        m_val->tag = i_val->tag;\n+        m_val->uni.u64 = i_val->uni.u64;\n+        if (type == YYJSON_TYPE_STR || type == YYJSON_TYPE_RAW) {\n+            const char *str = i_val->uni.str;\n+            usize str_len = unsafe_yyjson_get_len(i_val);\n+            m_val->uni.str = unsafe_yyjson_mut_strncpy(m_doc, str, str_len);\n+            if (!m_val->uni.str) return NULL;\n+        } else if (type == YYJSON_TYPE_ARR) {\n+            usize len = unsafe_yyjson_get_len(i_val);\n+            if (len > 0) {\n+                yyjson_val *ii_val = i_val + 1, *ii_next;\n+                yyjson_mut_val *mm_val = m_val + 1, *mm_ctn = m_val, *mm_next;\n+                while (len-- > 1) {\n+                    ii_next = unsafe_yyjson_get_next(ii_val);\n+                    mm_next = mm_val + (ii_next - ii_val);\n+                    mm_val->next = mm_next;\n+                    ii_val = ii_next;\n+                    mm_val = mm_next;\n+                }\n+                mm_val->next = mm_ctn + 1;\n+                mm_ctn->uni.ptr = mm_val;\n+            }\n+        } else if (type == YYJSON_TYPE_OBJ) {\n+            usize len = unsafe_yyjson_get_len(i_val);\n+            if (len > 0) {\n+                yyjson_val *ii_key = i_val + 1, *ii_nextkey;\n+                yyjson_mut_val *mm_key = m_val + 1, *mm_ctn = m_val;\n+                yyjson_mut_val *mm_nextkey;\n+                while (len-- > 1) {\n+                    ii_nextkey = unsafe_yyjson_get_next(ii_key + 1);\n+                    mm_nextkey = mm_key + (ii_nextkey - ii_key);\n+                    mm_key->next = mm_key + 1;\n+                    mm_key->next->next = mm_nextkey;\n+                    ii_key = ii_nextkey;\n+                    mm_key = mm_nextkey;\n+                }\n+                mm_key->next = mm_key + 1;\n+                mm_key->next->next = mm_ctn + 1;\n+                mm_ctn->uni.ptr = mm_key;\n+            }\n+        }\n+    }\n+    \n+    return m_vals;\n }\n \n static yyjson_mut_val *unsafe_yyjson_mut_val_mut_copy(yyjson_mut_doc *m_doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *m_vals) {\n-   /*\n-\tThe mutable object or array stores all sub-values in a circular linked\n-\tlist, so we can traverse them in the same loop. The traversal starts from\n-\tthe last item, continues with the first item in a list, and ends with the\n-\tsecond to last item, which needs to be linked to the last item to close the\n-\tcircle.\n-\t*/\n-\n-   yyjson_mut_val *m_val = unsafe_yyjson_mut_val(m_doc, 1);\n-   if (unlikely(!m_val)) return NULL;\n-   m_val->tag = m_vals->tag;\n-\n-   switch (unsafe_yyjson_get_type(m_vals)) {\n-   case YYJSON_TYPE_OBJ:\n-   case YYJSON_TYPE_ARR:\n-\t   if (unsafe_yyjson_get_len(m_vals) > 0) {\n-\t\t   yyjson_mut_val *last = (yyjson_mut_val *)m_vals->uni.ptr;\n-\t\t   yyjson_mut_val *next = last->next, *prev;\n-\t\t   prev = unsafe_yyjson_mut_val_mut_copy(m_doc, last);\n-\t\t   if (!prev) return NULL;\n-\t\t   m_val->uni.ptr = (void *)prev;\n-\t\t   while (next != last) {\n-\t\t\t   prev->next = unsafe_yyjson_mut_val_mut_copy(m_doc, next);\n-\t\t\t   if (!prev->next) return NULL;\n-\t\t\t   prev = prev->next;\n-\t\t\t   next = next->next;\n-\t\t   }\n-\t\t   prev->next = (yyjson_mut_val *)m_val->uni.ptr;\n-\t   }\n-\t   break;\n-\n-   case YYJSON_TYPE_RAW:\n-   case YYJSON_TYPE_STR: {\n-\t   const char *str = m_vals->uni.str;\n-\t   usize str_len = unsafe_yyjson_get_len(m_vals);\n-\t   m_val->uni.str = unsafe_yyjson_mut_strncpy(m_doc, str, str_len);\n-\t   if (!m_val->uni.str) return NULL;\n-\t   break;\n-   }\n-\n-   default:\n-\t   m_val->uni = m_vals->uni;\n-\t   break;\n-   }\n-\n-   return m_val;\n+                                                      yyjson_mut_val *m_vals) {\n+    /*\n+     The mutable object or array stores all sub-values in a circular linked\n+     list, so we can traverse them in the same loop. The traversal starts from\n+     the last item, continues with the first item in a list, and ends with the\n+     second to last item, which needs to be linked to the last item to close the\n+     circle.\n+     */\n+    \n+    yyjson_mut_val *m_val = unsafe_yyjson_mut_val(m_doc, 1);\n+    if (unlikely(!m_val)) return NULL;\n+    m_val->tag = m_vals->tag;\n+    \n+    switch (unsafe_yyjson_get_type(m_vals)) {\n+        case YYJSON_TYPE_OBJ:\n+        case YYJSON_TYPE_ARR:\n+            if (unsafe_yyjson_get_len(m_vals) > 0) {\n+                yyjson_mut_val *last = (yyjson_mut_val *)m_vals->uni.ptr;\n+                yyjson_mut_val *next = last->next, *prev;\n+                prev = unsafe_yyjson_mut_val_mut_copy(m_doc, last);\n+                if (!prev) return NULL;\n+                m_val->uni.ptr = (void *)prev;\n+                while (next != last) {\n+                    prev->next = unsafe_yyjson_mut_val_mut_copy(m_doc, next);\n+                    if (!prev->next) return NULL;\n+                    prev = prev->next;\n+                    next = next->next;\n+                }\n+                prev->next = (yyjson_mut_val *)m_val->uni.ptr;\n+            }\n+            break;\n+        \n+        case YYJSON_TYPE_RAW:\n+        case YYJSON_TYPE_STR: {\n+            const char *str = m_vals->uni.str;\n+            usize str_len = unsafe_yyjson_get_len(m_vals);\n+            m_val->uni.str = unsafe_yyjson_mut_strncpy(m_doc, str, str_len);\n+            if (!m_val->uni.str) return NULL;\n+            break;\n+        }\n+        \n+        default:\n+            m_val->uni = m_vals->uni;\n+            break;\n+    }\n+    \n+    return m_val;\n }\n \n yyjson_api yyjson_mut_val *yyjson_mut_val_mut_copy(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t  yyjson_mut_val *val) {\n-   if (doc && val) return unsafe_yyjson_mut_val_mut_copy(doc, val);\n-   return NULL;\n+                                                   yyjson_mut_val *val) {\n+    if (doc && val) return unsafe_yyjson_mut_val_mut_copy(doc, val);\n+    return NULL;\n+}\n+\n+/* Count the number of values and the total length of the strings. */\n+static void yyjson_mut_stat(yyjson_mut_val *val,\n+                            usize *val_sum, usize *str_sum) {\n+    yyjson_type type = unsafe_yyjson_get_type(val);\n+    *val_sum += 1;\n+    if (type == YYJSON_TYPE_ARR || type == YYJSON_TYPE_OBJ) {\n+        yyjson_mut_val *child = (yyjson_mut_val *)val->uni.ptr;\n+        usize len = unsafe_yyjson_get_len(val), i;\n+        len <<= (u8)(type == YYJSON_TYPE_OBJ);\n+        *val_sum += len;\n+        for (i = 0; i < len; i++) {\n+            yyjson_type stype = unsafe_yyjson_get_type(child);\n+            if (stype == YYJSON_TYPE_STR || stype == YYJSON_TYPE_RAW) {\n+                *str_sum += unsafe_yyjson_get_len(child) + 1;\n+            } else if (stype == YYJSON_TYPE_ARR || stype == YYJSON_TYPE_OBJ) {\n+                yyjson_mut_stat(child, val_sum, str_sum);\n+                *val_sum -= 1;\n+            }\n+            child = child->next;\n+        }\n+    } else if (type == YYJSON_TYPE_STR || type == YYJSON_TYPE_RAW) {\n+        *str_sum += unsafe_yyjson_get_len(val) + 1;\n+    }\n+}\n+\n+/* Copy mutable values to immutable value pool. */\n+static usize yyjson_imut_copy(yyjson_val **val_ptr, char **buf_ptr,\n+                              yyjson_mut_val *mval) {\n+    yyjson_val *val = *val_ptr;\n+    yyjson_type type = unsafe_yyjson_get_type(mval);\n+    if (type == YYJSON_TYPE_ARR || type == YYJSON_TYPE_OBJ) {\n+        yyjson_mut_val *child = (yyjson_mut_val *)mval->uni.ptr;\n+        usize len = unsafe_yyjson_get_len(mval), i;\n+        usize val_sum = 1;\n+        if (type == YYJSON_TYPE_OBJ) {\n+            if (len) child = child->next->next;\n+            len <<= 1;\n+        } else {\n+            if (len) child = child->next;\n+        }\n+        *val_ptr = val + 1;\n+        for (i = 0; i < len; i++) {\n+            val_sum += yyjson_imut_copy(val_ptr, buf_ptr, child);\n+            child = child->next;\n+        }\n+        val->tag = mval->tag;\n+        val->uni.ofs = val_sum * sizeof(yyjson_val);\n+        return val_sum;\n+    } else if (type == YYJSON_TYPE_STR || type == YYJSON_TYPE_RAW) {\n+        char *buf = *buf_ptr;\n+        usize len = unsafe_yyjson_get_len(mval);\n+        memcpy((void *)buf, (void *)mval->uni.str, len);\n+        buf[len] = '\\0';\n+        val->tag = mval->tag;\n+        val->uni.str = buf;\n+        *val_ptr = val + 1;\n+        *buf_ptr = buf + len + 1;\n+        return 1;\n+    } else {\n+        val->tag = mval->tag;\n+        val->uni = mval->uni;\n+        *val_ptr = val + 1;\n+        return 1;\n+    }\n+}\n+\n+yyjson_api yyjson_doc *yyjson_mut_doc_imut_copy(yyjson_mut_doc *mdoc,\n+                                                const yyjson_alc *alc) {\n+    if (!mdoc) return NULL;\n+    return yyjson_mut_val_imut_copy(mdoc->root, alc);\n+}\n+\n+yyjson_api yyjson_doc *yyjson_mut_val_imut_copy(yyjson_mut_val *mval,\n+                                                const yyjson_alc *alc) {\n+    usize val_num = 0, str_sum = 0, hdr_size, buf_size;\n+    yyjson_doc *doc = NULL;\n+    yyjson_val *val_hdr = NULL;\n+    \n+    /* This value should be NULL here. Setting a non-null value suppresses\n+       warning from the clang analyzer. */\n+    char *str_hdr = (char *)(void *)&str_sum;\n+    if (!mval) return NULL;\n+    if (!alc) alc = &YYJSON_DEFAULT_ALC;\n+    \n+    /* traverse the input value to get pool size */\n+    yyjson_mut_stat(mval, &val_num, &str_sum);\n+    \n+    /* create doc and val pool */\n+    hdr_size = size_align_up(sizeof(yyjson_doc), sizeof(yyjson_val));\n+    buf_size = hdr_size + val_num * sizeof(yyjson_val);\n+    doc = (yyjson_doc *)alc->malloc(alc->ctx, buf_size);\n+    if (!doc) return NULL;\n+    memset(doc, 0, sizeof(yyjson_doc));\n+    val_hdr = (yyjson_val *)((char *)(void *)doc + hdr_size);\n+    doc->root = val_hdr;\n+    doc->alc = *alc;\n+    \n+    /* create str pool */\n+    if (str_sum > 0) {\n+        str_hdr = (char *)alc->malloc(alc->ctx, str_sum);\n+        doc->str_pool = str_hdr;\n+        if (!str_hdr) {\n+            alc->free(alc->ctx, (void *)doc);\n+            return NULL;\n+        }\n+    }\n+    \n+    /* copy vals and strs */\n+    doc->val_read = yyjson_imut_copy(&val_hdr, &str_hdr, mval);\n+    doc->dat_read = str_sum + 1;\n+    return doc;\n }\n \n static_inline bool unsafe_yyjson_num_equals(void *lhs, void *rhs) {\n-   yyjson_val_uni *luni = &((yyjson_val *)lhs)->uni;\n-   yyjson_val_uni *runi = &((yyjson_val *)rhs)->uni;\n-   yyjson_subtype lt = unsafe_yyjson_get_subtype(lhs);\n-   yyjson_subtype rt = unsafe_yyjson_get_subtype(rhs);\n-   if (lt == rt)\n-\t   return luni->u64 == runi->u64;\n-   if (lt == YYJSON_SUBTYPE_SINT && rt == YYJSON_SUBTYPE_UINT)\n-\t   return luni->i64 >= 0 && luni->u64 == runi->u64;\n-   if (lt == YYJSON_SUBTYPE_UINT && rt == YYJSON_SUBTYPE_SINT)\n-\t   return runi->i64 >= 0 && luni->u64 == runi->u64;\n-   return false;\n+    yyjson_val_uni *luni = &((yyjson_val *)lhs)->uni;\n+    yyjson_val_uni *runi = &((yyjson_val *)rhs)->uni;\n+    yyjson_subtype lt = unsafe_yyjson_get_subtype(lhs);\n+    yyjson_subtype rt = unsafe_yyjson_get_subtype(rhs);\n+    if (lt == rt)\n+        return luni->u64 == runi->u64;\n+    if (lt == YYJSON_SUBTYPE_SINT && rt == YYJSON_SUBTYPE_UINT)\n+        return luni->i64 >= 0 && luni->u64 == runi->u64;\n+    if (lt == YYJSON_SUBTYPE_UINT && rt == YYJSON_SUBTYPE_SINT)\n+        return runi->i64 >= 0 && luni->u64 == runi->u64;\n+    return false;\n }\n \n static_inline bool unsafe_yyjson_str_equals(void *lhs, void *rhs) {\n-   usize len = unsafe_yyjson_get_len(lhs);\n-   if (len != unsafe_yyjson_get_len(rhs)) return false;\n-   return 0 == len ||\n-\t\t  0 == memcmp(unsafe_yyjson_get_str(lhs),\n-\t\t\t\t\t  unsafe_yyjson_get_str(rhs), len);\n+    usize len = unsafe_yyjson_get_len(lhs);\n+    if (len != unsafe_yyjson_get_len(rhs)) return false;\n+    return 0 == len ||\n+           0 == memcmp(unsafe_yyjson_get_str(lhs),\n+                       unsafe_yyjson_get_str(rhs), len);\n }\n \n yyjson_api bool unsafe_yyjson_equals(yyjson_val *lhs, yyjson_val *rhs) {\n-   yyjson_type type = unsafe_yyjson_get_type(lhs);\n-   if (type != unsafe_yyjson_get_type(rhs)) return false;\n-\n-   switch (type) {\n-   case YYJSON_TYPE_OBJ: {\n-\t   usize len = unsafe_yyjson_get_len(lhs);\n-\t   if (len != unsafe_yyjson_get_len(rhs)) return false;\n-\t   if (len > 0) {\n-\t\t   yyjson_obj_iter iter;\n-\t\t   yyjson_obj_iter_init(rhs, &iter);\n-\t\t   lhs = unsafe_yyjson_get_first(lhs);\n-\t\t   while (len-- > 0) {\n-\t\t\t   rhs = yyjson_obj_iter_getn(&iter, lhs->uni.str,\n-\t\t\t\t\t\t\t\t\t\t  unsafe_yyjson_get_len(lhs));\n-\t\t\t   if (!rhs || !unsafe_yyjson_equals(lhs + 1, rhs))\n-\t\t\t\t   return false;\n-\t\t\t   lhs = unsafe_yyjson_get_next(lhs + 1);\n-\t\t   }\n-\t   }\n-\t   /* yyjson allows duplicate keys, so the check may be inaccurate */\n-\t   return true;\n-   }\n-\n-   case YYJSON_TYPE_ARR: {\n-\t   usize len = unsafe_yyjson_get_len(lhs);\n-\t   if (len != unsafe_yyjson_get_len(rhs)) return false;\n-\t   if (len > 0) {\n-\t\t   lhs = unsafe_yyjson_get_first(lhs);\n-\t\t   rhs = unsafe_yyjson_get_first(rhs);\n-\t\t   while (len-- > 0) {\n-\t\t\t   if (!unsafe_yyjson_equals(lhs, rhs))\n-\t\t\t\t   return false;\n-\t\t\t   lhs = unsafe_yyjson_get_next(lhs);\n-\t\t\t   rhs = unsafe_yyjson_get_next(rhs);\n-\t\t   }\n-\t   }\n-\t   return true;\n-   }\n-\n-   case YYJSON_TYPE_NUM:\n-\t   return unsafe_yyjson_num_equals(lhs, rhs);\n-\n-   case YYJSON_TYPE_RAW:\n-   case YYJSON_TYPE_STR:\n-\t   return unsafe_yyjson_str_equals(lhs, rhs);\n-\n-   case YYJSON_TYPE_NULL:\n-   case YYJSON_TYPE_BOOL:\n-\t   return lhs->tag == rhs->tag;\n-\n-   default:\n-\t   return false;\n-   }\n+    yyjson_type type = unsafe_yyjson_get_type(lhs);\n+    if (type != unsafe_yyjson_get_type(rhs)) return false;\n+    \n+    switch (type) {\n+        case YYJSON_TYPE_OBJ: {\n+            usize len = unsafe_yyjson_get_len(lhs);\n+            if (len != unsafe_yyjson_get_len(rhs)) return false;\n+            if (len > 0) {\n+                yyjson_obj_iter iter;\n+                yyjson_obj_iter_init(rhs, &iter);\n+                lhs = unsafe_yyjson_get_first(lhs);\n+                while (len-- > 0) {\n+                    rhs = yyjson_obj_iter_getn(&iter, lhs->uni.str,\n+                                               unsafe_yyjson_get_len(lhs));\n+                    if (!rhs || !unsafe_yyjson_equals(lhs + 1, rhs))\n+                        return false;\n+                    lhs = unsafe_yyjson_get_next(lhs + 1);\n+                }\n+            }\n+            /* yyjson allows duplicate keys, so the check may be inaccurate */\n+            return true;\n+        }\n+        \n+        case YYJSON_TYPE_ARR: {\n+            usize len = unsafe_yyjson_get_len(lhs);\n+            if (len != unsafe_yyjson_get_len(rhs)) return false;\n+            if (len > 0) {\n+                lhs = unsafe_yyjson_get_first(lhs);\n+                rhs = unsafe_yyjson_get_first(rhs);\n+                while (len-- > 0) {\n+                    if (!unsafe_yyjson_equals(lhs, rhs))\n+                        return false;\n+                    lhs = unsafe_yyjson_get_next(lhs);\n+                    rhs = unsafe_yyjson_get_next(rhs);\n+                }\n+            }\n+            return true;\n+        }\n+        \n+        case YYJSON_TYPE_NUM:\n+            return unsafe_yyjson_num_equals(lhs, rhs);\n+        \n+        case YYJSON_TYPE_RAW:\n+        case YYJSON_TYPE_STR:\n+            return unsafe_yyjson_str_equals(lhs, rhs);\n+        \n+        case YYJSON_TYPE_NULL:\n+        case YYJSON_TYPE_BOOL:\n+            return lhs->tag == rhs->tag;\n+        \n+        default:\n+            return false;\n+    }\n }\n \n bool unsafe_yyjson_mut_equals(yyjson_mut_val *lhs, yyjson_mut_val *rhs) {\n-   yyjson_type type = unsafe_yyjson_get_type(lhs);\n-   if (type != unsafe_yyjson_get_type(rhs)) return false;\n-\n-   switch (type) {\n-   case YYJSON_TYPE_OBJ: {\n-\t   usize len = unsafe_yyjson_get_len(lhs);\n-\t   if (len != unsafe_yyjson_get_len(rhs)) return false;\n-\t   if (len > 0) {\n-\t\t   yyjson_mut_obj_iter iter;\n-\t\t   yyjson_mut_obj_iter_init(rhs, &iter);\n-\t\t   lhs = (yyjson_mut_val *)lhs->uni.ptr;\n-\t\t   while (len-- > 0) {\n-\t\t\t   rhs = yyjson_mut_obj_iter_getn(&iter, lhs->uni.str,\n-\t\t\t\t\t\t\t\t\t\t\t  unsafe_yyjson_get_len(lhs));\n-\t\t\t   if (!rhs || !unsafe_yyjson_mut_equals(lhs->next, rhs))\n-\t\t\t\t   return false;\n-\t\t\t   lhs = lhs->next->next;\n-\t\t   }\n-\t   }\n-\t   /* yyjson allows duplicate keys, so the check may be inaccurate */\n-\t   return true;\n-   }\n-\n-   case YYJSON_TYPE_ARR: {\n-\t   usize len = unsafe_yyjson_get_len(lhs);\n-\t   if (len != unsafe_yyjson_get_len(rhs)) return false;\n-\t   if (len > 0) {\n-\t\t   lhs = (yyjson_mut_val *)lhs->uni.ptr;\n-\t\t   rhs = (yyjson_mut_val *)rhs->uni.ptr;\n-\t\t   while (len-- > 0) {\n-\t\t\t   if (!unsafe_yyjson_mut_equals(lhs, rhs))\n-\t\t\t\t   return false;\n-\t\t\t   lhs = lhs->next;\n-\t\t\t   rhs = rhs->next;\n-\t\t   }\n-\t   }\n-\t   return true;\n-   }\n-\n-   case YYJSON_TYPE_NUM:\n-\t   return unsafe_yyjson_num_equals(lhs, rhs);\n-\n-   case YYJSON_TYPE_RAW:\n-   case YYJSON_TYPE_STR:\n-\t   return unsafe_yyjson_str_equals(lhs, rhs);\n-\n-   case YYJSON_TYPE_NULL:\n-   case YYJSON_TYPE_BOOL:\n-\t   return lhs->tag == rhs->tag;\n-\n-   default:\n-\t   return false;\n-   }\n+    yyjson_type type = unsafe_yyjson_get_type(lhs);\n+    if (type != unsafe_yyjson_get_type(rhs)) return false;\n+    \n+    switch (type) {\n+        case YYJSON_TYPE_OBJ: {\n+            usize len = unsafe_yyjson_get_len(lhs);\n+            if (len != unsafe_yyjson_get_len(rhs)) return false;\n+            if (len > 0) {\n+                yyjson_mut_obj_iter iter;\n+                yyjson_mut_obj_iter_init(rhs, &iter);\n+                lhs = (yyjson_mut_val *)lhs->uni.ptr;\n+                while (len-- > 0) {\n+                    rhs = yyjson_mut_obj_iter_getn(&iter, lhs->uni.str,\n+                                                   unsafe_yyjson_get_len(lhs));\n+                    if (!rhs || !unsafe_yyjson_mut_equals(lhs->next, rhs))\n+                        return false;\n+                    lhs = lhs->next->next;\n+                }\n+            }\n+            /* yyjson allows duplicate keys, so the check may be inaccurate */\n+            return true;\n+        }\n+        \n+        case YYJSON_TYPE_ARR: {\n+            usize len = unsafe_yyjson_get_len(lhs);\n+            if (len != unsafe_yyjson_get_len(rhs)) return false;\n+            if (len > 0) {\n+                lhs = (yyjson_mut_val *)lhs->uni.ptr;\n+                rhs = (yyjson_mut_val *)rhs->uni.ptr;\n+                while (len-- > 0) {\n+                    if (!unsafe_yyjson_mut_equals(lhs, rhs))\n+                        return false;\n+                    lhs = lhs->next;\n+                    rhs = rhs->next;\n+                }\n+            }\n+            return true;\n+        }\n+        \n+        case YYJSON_TYPE_NUM:\n+            return unsafe_yyjson_num_equals(lhs, rhs);\n+        \n+        case YYJSON_TYPE_RAW:\n+        case YYJSON_TYPE_STR:\n+            return unsafe_yyjson_str_equals(lhs, rhs);\n+        \n+        case YYJSON_TYPE_NULL:\n+        case YYJSON_TYPE_BOOL:\n+            return lhs->tag == rhs->tag;\n+        \n+        default:\n+            return false;\n+    }\n }\n \n \n \n /*==============================================================================\n-* JSON Pointer\n-*============================================================================*/\n+ * JSON Pointer\n+ *============================================================================*/\n \n /**\n-Get value from JSON array with a path segment (array index).\n-@param ptr Input the segment after `/`, output the end of segment.\n-@param end The end of entire JSON pointer.\n-@param arr JSON array (yyjson_val/yyjson_mut_val, based on `mut`).\n-@param mut Whether `arr` is mutable.\n-@return The matched value, or NULL if not matched.\n-*/\n+ Get value from JSON array with a path segment (array index).\n+ @param ptr Input the segment after `/`, output the end of segment.\n+ @param end The end of entire JSON pointer.\n+ @param arr JSON array (yyjson_val/yyjson_mut_val, based on `mut`).\n+ @param mut Whether `arr` is mutable.\n+ @return The matched value, or NULL if not matched.\n+ */\n static_inline void *pointer_read_arr(const char **ptr,\n-\t\t\t\t\t\t\t\t\tconst char *end,\n-\t\t\t\t\t\t\t\t\tvoid *arr,\n-\t\t\t\t\t\t\t\t\tbool mut) {\n-   const char *hdr = *ptr;\n-   const char *cur = hdr;\n-   yyjson_val *i_arr = (yyjson_val *)arr;\n-   yyjson_mut_val *m_arr = (yyjson_mut_val *)arr;\n-   u64 idx = 0;\n-   u8 add;\n-\n-   /* start with 0 */\n-   if (cur < end && *cur == '0') {\n-\t   *ptr = cur + 1;\n-\t   return mut\n-\t\t\t\t  ? (void *)yyjson_mut_arr_get_first(m_arr)\n-\t\t\t\t  : (void *)yyjson_arr_get_first(i_arr);\n-   }\n-\n-   /* read whole number */\n-   if (cur + U64_SAFE_DIG < end) end = cur + U64_SAFE_DIG;\n-   while (cur < end && (add = (u8)((u8)*cur - (u8)'0')) <= 9) {\n-\t   cur++;\n-\t   idx = idx * 10 + add;\n-   }\n-   if (cur == hdr || idx >= (u64)USIZE_MAX) return NULL;\n-   *ptr = cur;\n-   return mut\n-\t\t\t  ? (void *)yyjson_mut_arr_get(m_arr, (usize)idx)\n-\t\t\t  : (void *)yyjson_arr_get(i_arr, (usize)idx);\n+                                     const char *end,\n+                                     void *arr,\n+                                     bool mut) {\n+    const char *hdr = *ptr;\n+    const char *cur = hdr;\n+    yyjson_val *i_arr = (yyjson_val *)arr;\n+    yyjson_mut_val *m_arr = (yyjson_mut_val *)arr;\n+    u64 idx = 0;\n+    u8 add;\n+    \n+    /* start with 0 */\n+    if (cur < end && *cur == '0') {\n+        *ptr = cur + 1;\n+        return mut\n+            ? (void *)yyjson_mut_arr_get_first(m_arr)\n+            : (void *)yyjson_arr_get_first(i_arr);\n+    }\n+    \n+    /* read whole number */\n+    if (cur + U64_SAFE_DIG < end) end = cur + U64_SAFE_DIG;\n+    while (cur < end && (add = (u8)((u8)*cur - (u8)'0')) <= 9) {\n+        cur++;\n+        idx = idx * 10 + add;\n+    }\n+    if (cur == hdr || idx >= (u64)USIZE_MAX) return NULL;\n+    *ptr = cur;\n+    return mut\n+        ? (void *)yyjson_mut_arr_get(m_arr, (usize)idx)\n+        : (void *)yyjson_arr_get(i_arr, (usize)idx);\n }\n \n /**\n-Get value from JSON object with a path segment (object key).\n-@param ptr Input the segment after `/`, output the end of segment.\n-@param end The end of entire JSON pointer.\n-@param obj JSON object (yyjson_val/yyjson_mut_val, based on `mut`).\n-@param mut `obj` is mutable.\n-@return The matched value, or NULL if not matched.\n-*/\n+ Get value from JSON object with a path segment (object key).\n+ @param ptr Input the segment after `/`, output the end of segment.\n+ @param end The end of entire JSON pointer.\n+ @param obj JSON object (yyjson_val/yyjson_mut_val, based on `mut`).\n+ @param mut `obj` is mutable.\n+ @return The matched value, or NULL if not matched.\n+ */\n static_inline void *pointer_read_obj(const char **ptr,\n-\t\t\t\t\t\t\t\t\tconst char *end,\n-\t\t\t\t\t\t\t\t\tvoid *obj,\n-\t\t\t\t\t\t\t\t\tbool mut) {\n+                                     const char *end,\n+                                     void *obj,\n+                                     bool mut) {\n #define BUF_SIZE 512\n #define is_escaped(cur) ((cur) < end && (*(cur) == '0' || *(cur) == '1'))\n #define is_unescaped(cur) ((cur) < end && *(cur) != '/' && *(cur) != '~')\n #define is_completed(cur) ((cur) == end || *(cur) == '/')\n-\n-   const char *hdr = *ptr;\n-   const char *cur = hdr;\n-   yyjson_val *i_obj = (yyjson_val *)obj;\n-   yyjson_mut_val *m_obj = (yyjson_mut_val *)obj;\n-   yyjson_obj_iter i_iter;\n-   yyjson_mut_obj_iter m_iter;\n-   void *key;\n-\n-   /* skip unescaped characters */\n-   while (is_unescaped(cur)) cur++;\n-   if (likely(is_completed(cur))) {\n-\t   usize len = (usize)(cur - hdr);\n-\t   *ptr = cur;\n-\t   return mut\n-\t\t\t\t  ? (void *)yyjson_mut_obj_getn(m_obj, hdr, len)\n-\t\t\t\t  : (void *)yyjson_obj_getn(i_obj, hdr, len);\n-   }\n-\n-   /* copy escaped characters to buffer */\n-   if (likely(end - hdr <= BUF_SIZE)) {\n-\t   char buf[BUF_SIZE];\n-\t   char *dst = buf + (usize)(cur - hdr);\n-\t   memcpy(buf, hdr, (usize)(cur - hdr));\n-\t   while (true) {\n-\t\t   if (is_unescaped(cur)) {\n-\t\t\t   *dst++ = *cur++;\n-\t\t   } else if (is_completed(cur)) {\n-\t\t\t   usize len = (usize)(dst - buf);\n-\t\t\t   *ptr = cur;\n-\t\t\t   return mut\n-\t\t\t\t\t\t  ? (void *)yyjson_mut_obj_getn(m_obj, buf, len)\n-\t\t\t\t\t\t  : (void *)yyjson_obj_getn(i_obj, buf, len);\n-\t\t   } else {\n-\t\t\t   cur++; /* skip '~' */\n-\t\t\t   if (unlikely(!is_escaped(cur))) return NULL;\n-\t\t\t   *dst++ = (char)(*cur++ == '0' ? '~' : '/');\n-\t\t   }\n-\t   }\n-   }\n-\n-   /* compare byte by byte */\n-   cur = hdr;\n-   if (!mut) yyjson_obj_iter_init(i_obj, &i_iter);\n-   else yyjson_mut_obj_iter_init(m_obj, &m_iter);\n-   while ((key = mut ? (void *)yyjson_mut_obj_iter_next(&m_iter)\n-\t\t\t\t\t : (void *)yyjson_obj_iter_next(&i_iter))) {\n-\t   const char *k_str = unsafe_yyjson_get_str(key);\n-\t   const char *k_end = k_str + unsafe_yyjson_get_len(key);\n-\t   while (k_str < k_end) {\n-\t\t   if (is_unescaped(cur) && *k_str == *cur) {\n-\t\t\t   k_str += 1;\n-\t\t\t   cur += 1;\n-\t\t   } else if (cur < end && *cur == '~' && is_escaped(cur + 1) &&\n-\t\t\t\t\t  *k_str == (*(cur + 1) == '0' ? '~' : '/')) {\n-\t\t\t   k_str += 1;\n-\t\t\t   cur += 2;\n-\t\t   } else {\n-\t\t\t   break;\n-\t\t   }\n-\t   }\n-\t   if (k_str == k_end && is_completed(cur)) {\n-\t\t   *ptr = cur;\n-\t\t   return mut\n-\t\t\t\t\t  ? (void *)yyjson_mut_obj_iter_get_val((yyjson_mut_val *)key)\n-\t\t\t\t\t  : (void *)yyjson_obj_iter_get_val((yyjson_val *)key);\n-\t   }\n-   }\n-   return NULL;\n-\n+    \n+    const char *hdr = *ptr;\n+    const char *cur = hdr;\n+    yyjson_val *i_obj = (yyjson_val *)obj;\n+    yyjson_mut_val *m_obj = (yyjson_mut_val *)obj;\n+    yyjson_obj_iter i_iter;\n+    yyjson_mut_obj_iter m_iter;\n+    void *key;\n+    \n+    /* skip unescaped characters */\n+    while (is_unescaped(cur)) cur++;\n+    if (likely(is_completed(cur))) {\n+        usize len = (usize)(cur - hdr);\n+        *ptr = cur;\n+        return mut\n+            ? (void *)yyjson_mut_obj_getn(m_obj, hdr, len)\n+            : (void *)yyjson_obj_getn(i_obj, hdr, len);\n+    }\n+    \n+    /* copy escaped characters to buffer */\n+    if (likely(end - hdr <= BUF_SIZE)) {\n+        char buf[BUF_SIZE];\n+        char *dst = buf + (usize)(cur - hdr);\n+        memcpy(buf, hdr, (usize)(cur - hdr));\n+        while (true) {\n+            if (is_unescaped(cur)) {\n+                *dst++ = *cur++;\n+            } else if (is_completed(cur)) {\n+                usize len = (usize)(dst - buf);\n+                *ptr = cur;\n+                return mut\n+                    ? (void *)yyjson_mut_obj_getn(m_obj, buf, len)\n+                    : (void *)yyjson_obj_getn(i_obj, buf, len);\n+            } else {\n+                cur++; /* skip '~' */\n+                if (unlikely(!is_escaped(cur))) return NULL;\n+                *dst++ = (char)(*cur++ == '0' ? '~' : '/');\n+            }\n+        }\n+    }\n+    \n+    /* compare byte by byte */\n+    cur = hdr;\n+    if (!mut) yyjson_obj_iter_init(i_obj, &i_iter);\n+    else yyjson_mut_obj_iter_init(m_obj, &m_iter);\n+    while ((key = mut ? (void *)yyjson_mut_obj_iter_next(&m_iter)\n+                      : (void *)yyjson_obj_iter_next(&i_iter))) {\n+        const char *k_str = unsafe_yyjson_get_str(key);\n+        const char *k_end = k_str + unsafe_yyjson_get_len(key);\n+        while (k_str < k_end) {\n+            if (is_unescaped(cur) && *k_str == *cur) {\n+                k_str += 1;\n+                cur += 1;\n+            } else if (cur < end && *cur == '~' && is_escaped(cur + 1) &&\n+                       *k_str == (*(cur + 1) == '0' ? '~' : '/')) {\n+                k_str += 1;\n+                cur += 2;\n+            } else {\n+                break;\n+            }\n+        }\n+        if (k_str == k_end && is_completed(cur)) {\n+            *ptr = cur;\n+            return mut\n+                ? (void *)yyjson_mut_obj_iter_get_val((yyjson_mut_val *)key)\n+                : (void *)yyjson_obj_iter_get_val((yyjson_val *)key);\n+        }\n+    }\n+    return NULL;\n+    \n #undef BUF_SIZE\n #undef is_escaped\n #undef is_unescaped\n@@ -1658,164 +1772,164 @@ static_inline void *pointer_read_obj(const char **ptr,\n }\n \n yyjson_api yyjson_val *unsafe_yyjson_get_pointer(yyjson_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\tconst char *ptr,\n-\t\t\t\t\t\t\t\t\t\t\t\tusize len) {\n-   const char *end = ptr + len;\n-   ptr++; /* skip '/' */\n-   while (true) {\n-\t   if (yyjson_is_obj(val)) {\n-\t\t   val = (yyjson_val *)pointer_read_obj(&ptr, end, val, false);\n-\t   } else if (yyjson_is_arr(val)) {\n-\t\t   val = (yyjson_val *)pointer_read_arr(&ptr, end, val, false);\n-\t   } else {\n-\t\t   val = NULL;\n-\t   }\n-\t   if (!val || ptr == end) return val;\n-\t   if (*ptr++ != '/') return NULL;\n-   }\n+                                                 const char *ptr,\n+                                                 usize len) {\n+    const char *end = ptr + len;\n+    ptr++; /* skip '/' */\n+    while (true) {\n+        if (yyjson_is_obj(val)) {\n+            val = (yyjson_val *)pointer_read_obj(&ptr, end, val, false);\n+        } else if (yyjson_is_arr(val)) {\n+            val = (yyjson_val *)pointer_read_arr(&ptr, end, val, false);\n+        } else {\n+            val = NULL;\n+        }\n+        if (!val || ptr == end) return val;\n+        if (*ptr++ != '/') return NULL;\n+    }\n }\n \n yyjson_api yyjson_mut_val *unsafe_yyjson_mut_get_pointer(yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *ptr,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tusize len) {\n-   const char *end = ptr + len;\n-   ptr++; /* skip '/' */\n-   while (true) {\n-\t   if (yyjson_mut_is_obj(val)) {\n-\t\t   val = (yyjson_mut_val *)pointer_read_obj(&ptr, end, val, true);\n-\t   } else if (yyjson_mut_is_arr(val)) {\n-\t\t   val = (yyjson_mut_val *)pointer_read_arr(&ptr, end, val, true);\n-\t   } else {\n-\t\t   val = NULL;\n-\t   }\n-\t   if (!val || ptr == end) return val;\n-\t   if (*ptr++ != '/') return NULL;\n-   }\n+                                                         const char *ptr,\n+                                                         usize len) {\n+    const char *end = ptr + len;\n+    ptr++; /* skip '/' */\n+    while (true) {\n+        if (yyjson_mut_is_obj(val)) {\n+            val = (yyjson_mut_val *)pointer_read_obj(&ptr, end, val, true);\n+        } else if (yyjson_mut_is_arr(val)) {\n+            val = (yyjson_mut_val *)pointer_read_arr(&ptr, end, val, true);\n+        } else {\n+            val = NULL;\n+        }\n+        if (!val || ptr == end) return val;\n+        if (*ptr++ != '/') return NULL;\n+    }\n }\n \n \n \n /*==============================================================================\n-* JSON Merge-Patch\n-*============================================================================*/\n+ * JSON Merge-Patch\n+ *============================================================================*/\n \n yyjson_api yyjson_mut_val *yyjson_merge_patch(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_val *orig,\n-\t\t\t\t\t\t\t\t\t\t\t yyjson_val *patch) {\n-   usize idx, max;\n-   yyjson_val *key, *orig_val, *patch_val, local_orig;\n-   yyjson_mut_val *builder, *mut_key, *mut_val, *merged_val;\n-\n-   if (unlikely(!yyjson_is_obj(patch))) {\n-\t   return yyjson_val_mut_copy(doc, patch);\n-   }\n-\n-   builder = yyjson_mut_obj(doc);\n-   if (unlikely(!builder)) return NULL;\n-\n-   if (!yyjson_is_obj(orig)) {\n-\t   orig = &local_orig;\n-\t   orig->tag = builder->tag;\n-\t   orig->uni = builder->uni;\n-   }\n-\n-   /* Merge items modified by the patch. */\n-   yyjson_obj_foreach(patch, idx, max, key, patch_val) {\n-\t   /* null indicates the field is removed. */\n-\t   if (unsafe_yyjson_is_null(patch_val)) {\n-\t\t   continue;\n-\t   }\n-\t   mut_key = yyjson_val_mut_copy(doc, key);\n-\t   orig_val = yyjson_obj_getn(orig,\n-\t\t\t\t\t\t\t\t  unsafe_yyjson_get_str(key),\n-\t\t\t\t\t\t\t\t  unsafe_yyjson_get_len(key));\n-\t   merged_val = yyjson_merge_patch(doc, orig_val, patch_val);\n-\t   if (!yyjson_mut_obj_add(builder, mut_key, merged_val)) return NULL;\n-   }\n-\n-   /* Exit early, if orig is not contributing to the final result. */\n-   if (orig == &local_orig) {\n-\t   return builder;\n-   }\n-\n-   /* Copy over any items that weren't modified by the patch. */\n-   yyjson_obj_foreach(orig, idx, max, key, orig_val) {\n-\t   patch_val = yyjson_obj_getn(patch,\n-\t\t\t\t\t\t\t\t   unsafe_yyjson_get_str(key),\n-\t\t\t\t\t\t\t\t   unsafe_yyjson_get_len(key));\n-\t   if (!patch_val) {\n-\t\t   mut_key = yyjson_val_mut_copy(doc, key);\n-\t\t   mut_val = yyjson_val_mut_copy(doc, orig_val);\n-\t\t   if (!yyjson_mut_obj_add(builder, mut_key, mut_val)) return NULL;\n-\t   }\n-   }\n-\n-   return builder;\n+                                              yyjson_val *orig,\n+                                              yyjson_val *patch) {\n+    usize idx, max;\n+    yyjson_val *key, *orig_val, *patch_val, local_orig;\n+    yyjson_mut_val *builder, *mut_key, *mut_val, *merged_val;\n+    \n+    if (unlikely(!yyjson_is_obj(patch))) {\n+        return yyjson_val_mut_copy(doc, patch);\n+    }\n+    \n+    builder = yyjson_mut_obj(doc);\n+    if (unlikely(!builder)) return NULL;\n+    \n+    if (!yyjson_is_obj(orig)) {\n+        orig = &local_orig;\n+        orig->tag = builder->tag;\n+        orig->uni = builder->uni;\n+    }\n+    \n+    /* Merge items modified by the patch. */\n+    yyjson_obj_foreach(patch, idx, max, key, patch_val) {\n+        /* null indicates the field is removed. */\n+        if (unsafe_yyjson_is_null(patch_val)) {\n+            continue;\n+        }\n+        mut_key = yyjson_val_mut_copy(doc, key);\n+        orig_val = yyjson_obj_getn(orig,\n+                                   unsafe_yyjson_get_str(key),\n+                                   unsafe_yyjson_get_len(key));\n+        merged_val = yyjson_merge_patch(doc, orig_val, patch_val);\n+        if (!yyjson_mut_obj_add(builder, mut_key, merged_val)) return NULL;\n+    }\n+    \n+    /* Exit early, if orig is not contributing to the final result. */\n+    if (orig == &local_orig) {\n+        return builder;\n+    }\n+    \n+    /* Copy over any items that weren't modified by the patch. */\n+    yyjson_obj_foreach(orig, idx, max, key, orig_val) {\n+        patch_val = yyjson_obj_getn(patch,\n+                                    unsafe_yyjson_get_str(key),\n+                                    unsafe_yyjson_get_len(key));\n+        if (!patch_val) {\n+            mut_key = yyjson_val_mut_copy(doc, key);\n+            mut_val = yyjson_val_mut_copy(doc, orig_val);\n+            if (!yyjson_mut_obj_add(builder, mut_key, mut_val)) return NULL;\n+        }\n+    }\n+    \n+    return builder;\n }\n \n yyjson_api yyjson_mut_val *yyjson_mut_merge_patch(yyjson_mut_doc *doc,\n-\t\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *orig,\n-\t\t\t\t\t\t\t\t\t\t\t\t yyjson_mut_val *patch) {\n-   usize idx, max;\n-   yyjson_mut_val *key, *orig_val, *patch_val, local_orig;\n-   yyjson_mut_val *builder, *mut_key, *mut_val, *merged_val;\n-\n-   if (unlikely(!yyjson_mut_is_obj(patch))) {\n-\t   return yyjson_mut_val_mut_copy(doc, patch);\n-   }\n-\n-   builder = yyjson_mut_obj(doc);\n-   if (unlikely(!builder)) return NULL;\n-\n-   if (!yyjson_mut_is_obj(orig)) {\n-\t   orig = &local_orig;\n-\t   orig->tag = builder->tag;\n-\t   orig->uni = builder->uni;\n-   }\n-\n-   /* Merge items modified by the patch. */\n-   yyjson_mut_obj_foreach(patch, idx, max, key, patch_val) {\n-\t   /* null indicates the field is removed. */\n-\t   if (unsafe_yyjson_is_null(patch_val)) {\n-\t\t   continue;\n-\t   }\n-\t   mut_key = yyjson_mut_val_mut_copy(doc, key);\n-\t   orig_val = yyjson_mut_obj_getn(orig,\n-\t\t\t\t\t\t\t\t\t  unsafe_yyjson_get_str(key),\n-\t\t\t\t\t\t\t\t\t  unsafe_yyjson_get_len(key));\n-\t   merged_val = yyjson_mut_merge_patch(doc, orig_val, patch_val);\n-\t   if (!yyjson_mut_obj_add(builder, mut_key, merged_val)) return NULL;\n-   }\n-\n-   /* Exit early, if orig is not contributing to the final result. */\n-   if (orig == &local_orig) {\n-\t   return builder;\n-   }\n-\n-   /* Copy over any items that weren't modified by the patch. */\n-   yyjson_mut_obj_foreach(orig, idx, max, key, orig_val) {\n-\t   patch_val = yyjson_mut_obj_getn(patch,\n-\t\t\t\t\t\t\t\t\t   unsafe_yyjson_get_str(key),\n-\t\t\t\t\t\t\t\t\t   unsafe_yyjson_get_len(key));\n-\t   if (!patch_val) {\n-\t\t   mut_key = yyjson_mut_val_mut_copy(doc, key);\n-\t\t   mut_val = yyjson_mut_val_mut_copy(doc, orig_val);\n-\t\t   if (!yyjson_mut_obj_add(builder, mut_key, mut_val)) return NULL;\n-\t   }\n-   }\n-\n-   return builder;\n+                                                  yyjson_mut_val *orig,\n+                                                  yyjson_mut_val *patch) {\n+    usize idx, max;\n+    yyjson_mut_val *key, *orig_val, *patch_val, local_orig;\n+    yyjson_mut_val *builder, *mut_key, *mut_val, *merged_val;\n+    \n+    if (unlikely(!yyjson_mut_is_obj(patch))) {\n+        return yyjson_mut_val_mut_copy(doc, patch);\n+    }\n+    \n+    builder = yyjson_mut_obj(doc);\n+    if (unlikely(!builder)) return NULL;\n+    \n+    if (!yyjson_mut_is_obj(orig)) {\n+        orig = &local_orig;\n+        orig->tag = builder->tag;\n+        orig->uni = builder->uni;\n+    }\n+    \n+    /* Merge items modified by the patch. */\n+    yyjson_mut_obj_foreach(patch, idx, max, key, patch_val) {\n+        /* null indicates the field is removed. */\n+        if (unsafe_yyjson_is_null(patch_val)) {\n+            continue;\n+        }\n+        mut_key = yyjson_mut_val_mut_copy(doc, key);\n+        orig_val = yyjson_mut_obj_getn(orig,\n+                                       unsafe_yyjson_get_str(key),\n+                                       unsafe_yyjson_get_len(key));\n+        merged_val = yyjson_mut_merge_patch(doc, orig_val, patch_val);\n+        if (!yyjson_mut_obj_add(builder, mut_key, merged_val)) return NULL;\n+    }\n+    \n+    /* Exit early, if orig is not contributing to the final result. */\n+    if (orig == &local_orig) {\n+        return builder;\n+    }\n+    \n+    /* Copy over any items that weren't modified by the patch. */\n+    yyjson_mut_obj_foreach(orig, idx, max, key, orig_val) {\n+        patch_val = yyjson_mut_obj_getn(patch,\n+                                        unsafe_yyjson_get_str(key),\n+                                        unsafe_yyjson_get_len(key));\n+        if (!patch_val) {\n+            mut_key = yyjson_mut_val_mut_copy(doc, key);\n+            mut_val = yyjson_mut_val_mut_copy(doc, orig_val);\n+            if (!yyjson_mut_obj_add(builder, mut_key, mut_val)) return NULL;\n+        }\n+    }\n+    \n+    return builder;\n }\n \n \n \n /*==============================================================================\n-* Power10 Lookup Table\n-* These data are used by the floating-point number reader and writer.\n-*============================================================================*/\n+ * Power10 Lookup Table\n+ * These data are used by the floating-point number reader and writer.\n+ *============================================================================*/\n \n #if (!YYJSON_DISABLE_READER || !YYJSON_DISABLE_WRITER) && \\\n-   (!YYJSON_DISABLE_FAST_FP_CONV)\n+    (!YYJSON_DISABLE_FAST_FP_CONV)\n \n /** Minimum decimal exponent in pow10_sig_table. */\n #define POW10_SIG_TABLE_MIN_EXP -343\n@@ -1830,699 +1944,699 @@ yyjson_api yyjson_mut_val *yyjson_mut_merge_patch(yyjson_mut_doc *doc,\n #define POW10_SIG_TABLE_MAX_EXACT_EXP 55\n \n /** Normalized significant 128 bits of pow10, no rounded up (size: 10.4KB).\n-   This lookup table is used by both the double number reader and writer.\n-   (generate with misc/make_tables.c) */\n+    This lookup table is used by both the double number reader and writer.\n+    (generate with misc/make_tables.c) */\n static const u64 pow10_sig_table[] = {\n-   U64(0xBF29DCAB, 0xA82FDEAE), U64(0x7432EE87, 0x3880FC33), /* ~= 10^-343 */\n-   U64(0xEEF453D6, 0x923BD65A), U64(0x113FAA29, 0x06A13B3F), /* ~= 10^-342 */\n-   U64(0x9558B466, 0x1B6565F8), U64(0x4AC7CA59, 0xA424C507), /* ~= 10^-341 */\n-   U64(0xBAAEE17F, 0xA23EBF76), U64(0x5D79BCF0, 0x0D2DF649), /* ~= 10^-340 */\n-   U64(0xE95A99DF, 0x8ACE6F53), U64(0xF4D82C2C, 0x107973DC), /* ~= 10^-339 */\n-   U64(0x91D8A02B, 0xB6C10594), U64(0x79071B9B, 0x8A4BE869), /* ~= 10^-338 */\n-   U64(0xB64EC836, 0xA47146F9), U64(0x9748E282, 0x6CDEE284), /* ~= 10^-337 */\n-   U64(0xE3E27A44, 0x4D8D98B7), U64(0xFD1B1B23, 0x08169B25), /* ~= 10^-336 */\n-   U64(0x8E6D8C6A, 0xB0787F72), U64(0xFE30F0F5, 0xE50E20F7), /* ~= 10^-335 */\n-   U64(0xB208EF85, 0x5C969F4F), U64(0xBDBD2D33, 0x5E51A935), /* ~= 10^-334 */\n-   U64(0xDE8B2B66, 0xB3BC4723), U64(0xAD2C7880, 0x35E61382), /* ~= 10^-333 */\n-   U64(0x8B16FB20, 0x3055AC76), U64(0x4C3BCB50, 0x21AFCC31), /* ~= 10^-332 */\n-   U64(0xADDCB9E8, 0x3C6B1793), U64(0xDF4ABE24, 0x2A1BBF3D), /* ~= 10^-331 */\n-   U64(0xD953E862, 0x4B85DD78), U64(0xD71D6DAD, 0x34A2AF0D), /* ~= 10^-330 */\n-   U64(0x87D4713D, 0x6F33AA6B), U64(0x8672648C, 0x40E5AD68), /* ~= 10^-329 */\n-   U64(0xA9C98D8C, 0xCB009506), U64(0x680EFDAF, 0x511F18C2), /* ~= 10^-328 */\n-   U64(0xD43BF0EF, 0xFDC0BA48), U64(0x0212BD1B, 0x2566DEF2), /* ~= 10^-327 */\n-   U64(0x84A57695, 0xFE98746D), U64(0x014BB630, 0xF7604B57), /* ~= 10^-326 */\n-   U64(0xA5CED43B, 0x7E3E9188), U64(0x419EA3BD, 0x35385E2D), /* ~= 10^-325 */\n-   U64(0xCF42894A, 0x5DCE35EA), U64(0x52064CAC, 0x828675B9), /* ~= 10^-324 */\n-   U64(0x818995CE, 0x7AA0E1B2), U64(0x7343EFEB, 0xD1940993), /* ~= 10^-323 */\n-   U64(0xA1EBFB42, 0x19491A1F), U64(0x1014EBE6, 0xC5F90BF8), /* ~= 10^-322 */\n-   U64(0xCA66FA12, 0x9F9B60A6), U64(0xD41A26E0, 0x77774EF6), /* ~= 10^-321 */\n-   U64(0xFD00B897, 0x478238D0), U64(0x8920B098, 0x955522B4), /* ~= 10^-320 */\n-   U64(0x9E20735E, 0x8CB16382), U64(0x55B46E5F, 0x5D5535B0), /* ~= 10^-319 */\n-   U64(0xC5A89036, 0x2FDDBC62), U64(0xEB2189F7, 0x34AA831D), /* ~= 10^-318 */\n-   U64(0xF712B443, 0xBBD52B7B), U64(0xA5E9EC75, 0x01D523E4), /* ~= 10^-317 */\n-   U64(0x9A6BB0AA, 0x55653B2D), U64(0x47B233C9, 0x2125366E), /* ~= 10^-316 */\n-   U64(0xC1069CD4, 0xEABE89F8), U64(0x999EC0BB, 0x696E840A), /* ~= 10^-315 */\n-   U64(0xF148440A, 0x256E2C76), U64(0xC00670EA, 0x43CA250D), /* ~= 10^-314 */\n-   U64(0x96CD2A86, 0x5764DBCA), U64(0x38040692, 0x6A5E5728), /* ~= 10^-313 */\n-   U64(0xBC807527, 0xED3E12BC), U64(0xC6050837, 0x04F5ECF2), /* ~= 10^-312 */\n-   U64(0xEBA09271, 0xE88D976B), U64(0xF7864A44, 0xC633682E), /* ~= 10^-311 */\n-   U64(0x93445B87, 0x31587EA3), U64(0x7AB3EE6A, 0xFBE0211D), /* ~= 10^-310 */\n-   U64(0xB8157268, 0xFDAE9E4C), U64(0x5960EA05, 0xBAD82964), /* ~= 10^-309 */\n-   U64(0xE61ACF03, 0x3D1A45DF), U64(0x6FB92487, 0x298E33BD), /* ~= 10^-308 */\n-   U64(0x8FD0C162, 0x06306BAB), U64(0xA5D3B6D4, 0x79F8E056), /* ~= 10^-307 */\n-   U64(0xB3C4F1BA, 0x87BC8696), U64(0x8F48A489, 0x9877186C), /* ~= 10^-306 */\n-   U64(0xE0B62E29, 0x29ABA83C), U64(0x331ACDAB, 0xFE94DE87), /* ~= 10^-305 */\n-   U64(0x8C71DCD9, 0xBA0B4925), U64(0x9FF0C08B, 0x7F1D0B14), /* ~= 10^-304 */\n-   U64(0xAF8E5410, 0x288E1B6F), U64(0x07ECF0AE, 0x5EE44DD9), /* ~= 10^-303 */\n-   U64(0xDB71E914, 0x32B1A24A), U64(0xC9E82CD9, 0xF69D6150), /* ~= 10^-302 */\n-   U64(0x892731AC, 0x9FAF056E), U64(0xBE311C08, 0x3A225CD2), /* ~= 10^-301 */\n-   U64(0xAB70FE17, 0xC79AC6CA), U64(0x6DBD630A, 0x48AAF406), /* ~= 10^-300 */\n-   U64(0xD64D3D9D, 0xB981787D), U64(0x092CBBCC, 0xDAD5B108), /* ~= 10^-299 */\n-   U64(0x85F04682, 0x93F0EB4E), U64(0x25BBF560, 0x08C58EA5), /* ~= 10^-298 */\n-   U64(0xA76C5823, 0x38ED2621), U64(0xAF2AF2B8, 0x0AF6F24E), /* ~= 10^-297 */\n-   U64(0xD1476E2C, 0x07286FAA), U64(0x1AF5AF66, 0x0DB4AEE1), /* ~= 10^-296 */\n-   U64(0x82CCA4DB, 0x847945CA), U64(0x50D98D9F, 0xC890ED4D), /* ~= 10^-295 */\n-   U64(0xA37FCE12, 0x6597973C), U64(0xE50FF107, 0xBAB528A0), /* ~= 10^-294 */\n-   U64(0xCC5FC196, 0xFEFD7D0C), U64(0x1E53ED49, 0xA96272C8), /* ~= 10^-293 */\n-   U64(0xFF77B1FC, 0xBEBCDC4F), U64(0x25E8E89C, 0x13BB0F7A), /* ~= 10^-292 */\n-   U64(0x9FAACF3D, 0xF73609B1), U64(0x77B19161, 0x8C54E9AC), /* ~= 10^-291 */\n-   U64(0xC795830D, 0x75038C1D), U64(0xD59DF5B9, 0xEF6A2417), /* ~= 10^-290 */\n-   U64(0xF97AE3D0, 0xD2446F25), U64(0x4B057328, 0x6B44AD1D), /* ~= 10^-289 */\n-   U64(0x9BECCE62, 0x836AC577), U64(0x4EE367F9, 0x430AEC32), /* ~= 10^-288 */\n-   U64(0xC2E801FB, 0x244576D5), U64(0x229C41F7, 0x93CDA73F), /* ~= 10^-287 */\n-   U64(0xF3A20279, 0xED56D48A), U64(0x6B435275, 0x78C1110F), /* ~= 10^-286 */\n-   U64(0x9845418C, 0x345644D6), U64(0x830A1389, 0x6B78AAA9), /* ~= 10^-285 */\n-   U64(0xBE5691EF, 0x416BD60C), U64(0x23CC986B, 0xC656D553), /* ~= 10^-284 */\n-   U64(0xEDEC366B, 0x11C6CB8F), U64(0x2CBFBE86, 0xB7EC8AA8), /* ~= 10^-283 */\n-   U64(0x94B3A202, 0xEB1C3F39), U64(0x7BF7D714, 0x32F3D6A9), /* ~= 10^-282 */\n-   U64(0xB9E08A83, 0xA5E34F07), U64(0xDAF5CCD9, 0x3FB0CC53), /* ~= 10^-281 */\n-   U64(0xE858AD24, 0x8F5C22C9), U64(0xD1B3400F, 0x8F9CFF68), /* ~= 10^-280 */\n-   U64(0x91376C36, 0xD99995BE), U64(0x23100809, 0xB9C21FA1), /* ~= 10^-279 */\n-   U64(0xB5854744, 0x8FFFFB2D), U64(0xABD40A0C, 0x2832A78A), /* ~= 10^-278 */\n-   U64(0xE2E69915, 0xB3FFF9F9), U64(0x16C90C8F, 0x323F516C), /* ~= 10^-277 */\n-   U64(0x8DD01FAD, 0x907FFC3B), U64(0xAE3DA7D9, 0x7F6792E3), /* ~= 10^-276 */\n-   U64(0xB1442798, 0xF49FFB4A), U64(0x99CD11CF, 0xDF41779C), /* ~= 10^-275 */\n-   U64(0xDD95317F, 0x31C7FA1D), U64(0x40405643, 0xD711D583), /* ~= 10^-274 */\n-   U64(0x8A7D3EEF, 0x7F1CFC52), U64(0x482835EA, 0x666B2572), /* ~= 10^-273 */\n-   U64(0xAD1C8EAB, 0x5EE43B66), U64(0xDA324365, 0x0005EECF), /* ~= 10^-272 */\n-   U64(0xD863B256, 0x369D4A40), U64(0x90BED43E, 0x40076A82), /* ~= 10^-271 */\n-   U64(0x873E4F75, 0xE2224E68), U64(0x5A7744A6, 0xE804A291), /* ~= 10^-270 */\n-   U64(0xA90DE353, 0x5AAAE202), U64(0x711515D0, 0xA205CB36), /* ~= 10^-269 */\n-   U64(0xD3515C28, 0x31559A83), U64(0x0D5A5B44, 0xCA873E03), /* ~= 10^-268 */\n-   U64(0x8412D999, 0x1ED58091), U64(0xE858790A, 0xFE9486C2), /* ~= 10^-267 */\n-   U64(0xA5178FFF, 0x668AE0B6), U64(0x626E974D, 0xBE39A872), /* ~= 10^-266 */\n-   U64(0xCE5D73FF, 0x402D98E3), U64(0xFB0A3D21, 0x2DC8128F), /* ~= 10^-265 */\n-   U64(0x80FA687F, 0x881C7F8E), U64(0x7CE66634, 0xBC9D0B99), /* ~= 10^-264 */\n-   U64(0xA139029F, 0x6A239F72), U64(0x1C1FFFC1, 0xEBC44E80), /* ~= 10^-263 */\n-   U64(0xC9874347, 0x44AC874E), U64(0xA327FFB2, 0x66B56220), /* ~= 10^-262 */\n-   U64(0xFBE91419, 0x15D7A922), U64(0x4BF1FF9F, 0x0062BAA8), /* ~= 10^-261 */\n-   U64(0x9D71AC8F, 0xADA6C9B5), U64(0x6F773FC3, 0x603DB4A9), /* ~= 10^-260 */\n-   U64(0xC4CE17B3, 0x99107C22), U64(0xCB550FB4, 0x384D21D3), /* ~= 10^-259 */\n-   U64(0xF6019DA0, 0x7F549B2B), U64(0x7E2A53A1, 0x46606A48), /* ~= 10^-258 */\n-   U64(0x99C10284, 0x4F94E0FB), U64(0x2EDA7444, 0xCBFC426D), /* ~= 10^-257 */\n-   U64(0xC0314325, 0x637A1939), U64(0xFA911155, 0xFEFB5308), /* ~= 10^-256 */\n-   U64(0xF03D93EE, 0xBC589F88), U64(0x793555AB, 0x7EBA27CA), /* ~= 10^-255 */\n-   U64(0x96267C75, 0x35B763B5), U64(0x4BC1558B, 0x2F3458DE), /* ~= 10^-254 */\n-   U64(0xBBB01B92, 0x83253CA2), U64(0x9EB1AAED, 0xFB016F16), /* ~= 10^-253 */\n-   U64(0xEA9C2277, 0x23EE8BCB), U64(0x465E15A9, 0x79C1CADC), /* ~= 10^-252 */\n-   U64(0x92A1958A, 0x7675175F), U64(0x0BFACD89, 0xEC191EC9), /* ~= 10^-251 */\n-   U64(0xB749FAED, 0x14125D36), U64(0xCEF980EC, 0x671F667B), /* ~= 10^-250 */\n-   U64(0xE51C79A8, 0x5916F484), U64(0x82B7E127, 0x80E7401A), /* ~= 10^-249 */\n-   U64(0x8F31CC09, 0x37AE58D2), U64(0xD1B2ECB8, 0xB0908810), /* ~= 10^-248 */\n-   U64(0xB2FE3F0B, 0x8599EF07), U64(0x861FA7E6, 0xDCB4AA15), /* ~= 10^-247 */\n-   U64(0xDFBDCECE, 0x67006AC9), U64(0x67A791E0, 0x93E1D49A), /* ~= 10^-246 */\n-   U64(0x8BD6A141, 0x006042BD), U64(0xE0C8BB2C, 0x5C6D24E0), /* ~= 10^-245 */\n-   U64(0xAECC4991, 0x4078536D), U64(0x58FAE9F7, 0x73886E18), /* ~= 10^-244 */\n-   U64(0xDA7F5BF5, 0x90966848), U64(0xAF39A475, 0x506A899E), /* ~= 10^-243 */\n-   U64(0x888F9979, 0x7A5E012D), U64(0x6D8406C9, 0x52429603), /* ~= 10^-242 */\n-   U64(0xAAB37FD7, 0xD8F58178), U64(0xC8E5087B, 0xA6D33B83), /* ~= 10^-241 */\n-   U64(0xD5605FCD, 0xCF32E1D6), U64(0xFB1E4A9A, 0x90880A64), /* ~= 10^-240 */\n-   U64(0x855C3BE0, 0xA17FCD26), U64(0x5CF2EEA0, 0x9A55067F), /* ~= 10^-239 */\n-   U64(0xA6B34AD8, 0xC9DFC06F), U64(0xF42FAA48, 0xC0EA481E), /* ~= 10^-238 */\n-   U64(0xD0601D8E, 0xFC57B08B), U64(0xF13B94DA, 0xF124DA26), /* ~= 10^-237 */\n-   U64(0x823C1279, 0x5DB6CE57), U64(0x76C53D08, 0xD6B70858), /* ~= 10^-236 */\n-   U64(0xA2CB1717, 0xB52481ED), U64(0x54768C4B, 0x0C64CA6E), /* ~= 10^-235 */\n-   U64(0xCB7DDCDD, 0xA26DA268), U64(0xA9942F5D, 0xCF7DFD09), /* ~= 10^-234 */\n-   U64(0xFE5D5415, 0x0B090B02), U64(0xD3F93B35, 0x435D7C4C), /* ~= 10^-233 */\n-   U64(0x9EFA548D, 0x26E5A6E1), U64(0xC47BC501, 0x4A1A6DAF), /* ~= 10^-232 */\n-   U64(0xC6B8E9B0, 0x709F109A), U64(0x359AB641, 0x9CA1091B), /* ~= 10^-231 */\n-   U64(0xF867241C, 0x8CC6D4C0), U64(0xC30163D2, 0x03C94B62), /* ~= 10^-230 */\n-   U64(0x9B407691, 0xD7FC44F8), U64(0x79E0DE63, 0x425DCF1D), /* ~= 10^-229 */\n-   U64(0xC2109436, 0x4DFB5636), U64(0x985915FC, 0x12F542E4), /* ~= 10^-228 */\n-   U64(0xF294B943, 0xE17A2BC4), U64(0x3E6F5B7B, 0x17B2939D), /* ~= 10^-227 */\n-   U64(0x979CF3CA, 0x6CEC5B5A), U64(0xA705992C, 0xEECF9C42), /* ~= 10^-226 */\n-   U64(0xBD8430BD, 0x08277231), U64(0x50C6FF78, 0x2A838353), /* ~= 10^-225 */\n-   U64(0xECE53CEC, 0x4A314EBD), U64(0xA4F8BF56, 0x35246428), /* ~= 10^-224 */\n-   U64(0x940F4613, 0xAE5ED136), U64(0x871B7795, 0xE136BE99), /* ~= 10^-223 */\n-   U64(0xB9131798, 0x99F68584), U64(0x28E2557B, 0x59846E3F), /* ~= 10^-222 */\n-   U64(0xE757DD7E, 0xC07426E5), U64(0x331AEADA, 0x2FE589CF), /* ~= 10^-221 */\n-   U64(0x9096EA6F, 0x3848984F), U64(0x3FF0D2C8, 0x5DEF7621), /* ~= 10^-220 */\n-   U64(0xB4BCA50B, 0x065ABE63), U64(0x0FED077A, 0x756B53A9), /* ~= 10^-219 */\n-   U64(0xE1EBCE4D, 0xC7F16DFB), U64(0xD3E84959, 0x12C62894), /* ~= 10^-218 */\n-   U64(0x8D3360F0, 0x9CF6E4BD), U64(0x64712DD7, 0xABBBD95C), /* ~= 10^-217 */\n-   U64(0xB080392C, 0xC4349DEC), U64(0xBD8D794D, 0x96AACFB3), /* ~= 10^-216 */\n-   U64(0xDCA04777, 0xF541C567), U64(0xECF0D7A0, 0xFC5583A0), /* ~= 10^-215 */\n-   U64(0x89E42CAA, 0xF9491B60), U64(0xF41686C4, 0x9DB57244), /* ~= 10^-214 */\n-   U64(0xAC5D37D5, 0xB79B6239), U64(0x311C2875, 0xC522CED5), /* ~= 10^-213 */\n-   U64(0xD77485CB, 0x25823AC7), U64(0x7D633293, 0x366B828B), /* ~= 10^-212 */\n-   U64(0x86A8D39E, 0xF77164BC), U64(0xAE5DFF9C, 0x02033197), /* ~= 10^-211 */\n-   U64(0xA8530886, 0xB54DBDEB), U64(0xD9F57F83, 0x0283FDFC), /* ~= 10^-210 */\n-   U64(0xD267CAA8, 0x62A12D66), U64(0xD072DF63, 0xC324FD7B), /* ~= 10^-209 */\n-   U64(0x8380DEA9, 0x3DA4BC60), U64(0x4247CB9E, 0x59F71E6D), /* ~= 10^-208 */\n-   U64(0xA4611653, 0x8D0DEB78), U64(0x52D9BE85, 0xF074E608), /* ~= 10^-207 */\n-   U64(0xCD795BE8, 0x70516656), U64(0x67902E27, 0x6C921F8B), /* ~= 10^-206 */\n-   U64(0x806BD971, 0x4632DFF6), U64(0x00BA1CD8, 0xA3DB53B6), /* ~= 10^-205 */\n-   U64(0xA086CFCD, 0x97BF97F3), U64(0x80E8A40E, 0xCCD228A4), /* ~= 10^-204 */\n-   U64(0xC8A883C0, 0xFDAF7DF0), U64(0x6122CD12, 0x8006B2CD), /* ~= 10^-203 */\n-   U64(0xFAD2A4B1, 0x3D1B5D6C), U64(0x796B8057, 0x20085F81), /* ~= 10^-202 */\n-   U64(0x9CC3A6EE, 0xC6311A63), U64(0xCBE33036, 0x74053BB0), /* ~= 10^-201 */\n-   U64(0xC3F490AA, 0x77BD60FC), U64(0xBEDBFC44, 0x11068A9C), /* ~= 10^-200 */\n-   U64(0xF4F1B4D5, 0x15ACB93B), U64(0xEE92FB55, 0x15482D44), /* ~= 10^-199 */\n-   U64(0x99171105, 0x2D8BF3C5), U64(0x751BDD15, 0x2D4D1C4A), /* ~= 10^-198 */\n-   U64(0xBF5CD546, 0x78EEF0B6), U64(0xD262D45A, 0x78A0635D), /* ~= 10^-197 */\n-   U64(0xEF340A98, 0x172AACE4), U64(0x86FB8971, 0x16C87C34), /* ~= 10^-196 */\n-   U64(0x9580869F, 0x0E7AAC0E), U64(0xD45D35E6, 0xAE3D4DA0), /* ~= 10^-195 */\n-   U64(0xBAE0A846, 0xD2195712), U64(0x89748360, 0x59CCA109), /* ~= 10^-194 */\n-   U64(0xE998D258, 0x869FACD7), U64(0x2BD1A438, 0x703FC94B), /* ~= 10^-193 */\n-   U64(0x91FF8377, 0x5423CC06), U64(0x7B6306A3, 0x4627DDCF), /* ~= 10^-192 */\n-   U64(0xB67F6455, 0x292CBF08), U64(0x1A3BC84C, 0x17B1D542), /* ~= 10^-191 */\n-   U64(0xE41F3D6A, 0x7377EECA), U64(0x20CABA5F, 0x1D9E4A93), /* ~= 10^-190 */\n-   U64(0x8E938662, 0x882AF53E), U64(0x547EB47B, 0x7282EE9C), /* ~= 10^-189 */\n-   U64(0xB23867FB, 0x2A35B28D), U64(0xE99E619A, 0x4F23AA43), /* ~= 10^-188 */\n-   U64(0xDEC681F9, 0xF4C31F31), U64(0x6405FA00, 0xE2EC94D4), /* ~= 10^-187 */\n-   U64(0x8B3C113C, 0x38F9F37E), U64(0xDE83BC40, 0x8DD3DD04), /* ~= 10^-186 */\n-   U64(0xAE0B158B, 0x4738705E), U64(0x9624AB50, 0xB148D445), /* ~= 10^-185 */\n-   U64(0xD98DDAEE, 0x19068C76), U64(0x3BADD624, 0xDD9B0957), /* ~= 10^-184 */\n-   U64(0x87F8A8D4, 0xCFA417C9), U64(0xE54CA5D7, 0x0A80E5D6), /* ~= 10^-183 */\n-   U64(0xA9F6D30A, 0x038D1DBC), U64(0x5E9FCF4C, 0xCD211F4C), /* ~= 10^-182 */\n-   U64(0xD47487CC, 0x8470652B), U64(0x7647C320, 0x0069671F), /* ~= 10^-181 */\n-   U64(0x84C8D4DF, 0xD2C63F3B), U64(0x29ECD9F4, 0x0041E073), /* ~= 10^-180 */\n-   U64(0xA5FB0A17, 0xC777CF09), U64(0xF4681071, 0x00525890), /* ~= 10^-179 */\n-   U64(0xCF79CC9D, 0xB955C2CC), U64(0x7182148D, 0x4066EEB4), /* ~= 10^-178 */\n-   U64(0x81AC1FE2, 0x93D599BF), U64(0xC6F14CD8, 0x48405530), /* ~= 10^-177 */\n-   U64(0xA21727DB, 0x38CB002F), U64(0xB8ADA00E, 0x5A506A7C), /* ~= 10^-176 */\n-   U64(0xCA9CF1D2, 0x06FDC03B), U64(0xA6D90811, 0xF0E4851C), /* ~= 10^-175 */\n-   U64(0xFD442E46, 0x88BD304A), U64(0x908F4A16, 0x6D1DA663), /* ~= 10^-174 */\n-   U64(0x9E4A9CEC, 0x15763E2E), U64(0x9A598E4E, 0x043287FE), /* ~= 10^-173 */\n-   U64(0xC5DD4427, 0x1AD3CDBA), U64(0x40EFF1E1, 0x853F29FD), /* ~= 10^-172 */\n-   U64(0xF7549530, 0xE188C128), U64(0xD12BEE59, 0xE68EF47C), /* ~= 10^-171 */\n-   U64(0x9A94DD3E, 0x8CF578B9), U64(0x82BB74F8, 0x301958CE), /* ~= 10^-170 */\n-   U64(0xC13A148E, 0x3032D6E7), U64(0xE36A5236, 0x3C1FAF01), /* ~= 10^-169 */\n-   U64(0xF18899B1, 0xBC3F8CA1), U64(0xDC44E6C3, 0xCB279AC1), /* ~= 10^-168 */\n-   U64(0x96F5600F, 0x15A7B7E5), U64(0x29AB103A, 0x5EF8C0B9), /* ~= 10^-167 */\n-   U64(0xBCB2B812, 0xDB11A5DE), U64(0x7415D448, 0xF6B6F0E7), /* ~= 10^-166 */\n-   U64(0xEBDF6617, 0x91D60F56), U64(0x111B495B, 0x3464AD21), /* ~= 10^-165 */\n-   U64(0x936B9FCE, 0xBB25C995), U64(0xCAB10DD9, 0x00BEEC34), /* ~= 10^-164 */\n-   U64(0xB84687C2, 0x69EF3BFB), U64(0x3D5D514F, 0x40EEA742), /* ~= 10^-163 */\n-   U64(0xE65829B3, 0x046B0AFA), U64(0x0CB4A5A3, 0x112A5112), /* ~= 10^-162 */\n-   U64(0x8FF71A0F, 0xE2C2E6DC), U64(0x47F0E785, 0xEABA72AB), /* ~= 10^-161 */\n-   U64(0xB3F4E093, 0xDB73A093), U64(0x59ED2167, 0x65690F56), /* ~= 10^-160 */\n-   U64(0xE0F218B8, 0xD25088B8), U64(0x306869C1, 0x3EC3532C), /* ~= 10^-159 */\n-   U64(0x8C974F73, 0x83725573), U64(0x1E414218, 0xC73A13FB), /* ~= 10^-158 */\n-   U64(0xAFBD2350, 0x644EEACF), U64(0xE5D1929E, 0xF90898FA), /* ~= 10^-157 */\n-   U64(0xDBAC6C24, 0x7D62A583), U64(0xDF45F746, 0xB74ABF39), /* ~= 10^-156 */\n-   U64(0x894BC396, 0xCE5DA772), U64(0x6B8BBA8C, 0x328EB783), /* ~= 10^-155 */\n-   U64(0xAB9EB47C, 0x81F5114F), U64(0x066EA92F, 0x3F326564), /* ~= 10^-154 */\n-   U64(0xD686619B, 0xA27255A2), U64(0xC80A537B, 0x0EFEFEBD), /* ~= 10^-153 */\n-   U64(0x8613FD01, 0x45877585), U64(0xBD06742C, 0xE95F5F36), /* ~= 10^-152 */\n-   U64(0xA798FC41, 0x96E952E7), U64(0x2C481138, 0x23B73704), /* ~= 10^-151 */\n-   U64(0xD17F3B51, 0xFCA3A7A0), U64(0xF75A1586, 0x2CA504C5), /* ~= 10^-150 */\n-   U64(0x82EF8513, 0x3DE648C4), U64(0x9A984D73, 0xDBE722FB), /* ~= 10^-149 */\n-   U64(0xA3AB6658, 0x0D5FDAF5), U64(0xC13E60D0, 0xD2E0EBBA), /* ~= 10^-148 */\n-   U64(0xCC963FEE, 0x10B7D1B3), U64(0x318DF905, 0x079926A8), /* ~= 10^-147 */\n-   U64(0xFFBBCFE9, 0x94E5C61F), U64(0xFDF17746, 0x497F7052), /* ~= 10^-146 */\n-   U64(0x9FD561F1, 0xFD0F9BD3), U64(0xFEB6EA8B, 0xEDEFA633), /* ~= 10^-145 */\n-   U64(0xC7CABA6E, 0x7C5382C8), U64(0xFE64A52E, 0xE96B8FC0), /* ~= 10^-144 */\n-   U64(0xF9BD690A, 0x1B68637B), U64(0x3DFDCE7A, 0xA3C673B0), /* ~= 10^-143 */\n-   U64(0x9C1661A6, 0x51213E2D), U64(0x06BEA10C, 0xA65C084E), /* ~= 10^-142 */\n-   U64(0xC31BFA0F, 0xE5698DB8), U64(0x486E494F, 0xCFF30A62), /* ~= 10^-141 */\n-   U64(0xF3E2F893, 0xDEC3F126), U64(0x5A89DBA3, 0xC3EFCCFA), /* ~= 10^-140 */\n-   U64(0x986DDB5C, 0x6B3A76B7), U64(0xF8962946, 0x5A75E01C), /* ~= 10^-139 */\n-   U64(0xBE895233, 0x86091465), U64(0xF6BBB397, 0xF1135823), /* ~= 10^-138 */\n-   U64(0xEE2BA6C0, 0x678B597F), U64(0x746AA07D, 0xED582E2C), /* ~= 10^-137 */\n-   U64(0x94DB4838, 0x40B717EF), U64(0xA8C2A44E, 0xB4571CDC), /* ~= 10^-136 */\n-   U64(0xBA121A46, 0x50E4DDEB), U64(0x92F34D62, 0x616CE413), /* ~= 10^-135 */\n-   U64(0xE896A0D7, 0xE51E1566), U64(0x77B020BA, 0xF9C81D17), /* ~= 10^-134 */\n-   U64(0x915E2486, 0xEF32CD60), U64(0x0ACE1474, 0xDC1D122E), /* ~= 10^-133 */\n-   U64(0xB5B5ADA8, 0xAAFF80B8), U64(0x0D819992, 0x132456BA), /* ~= 10^-132 */\n-   U64(0xE3231912, 0xD5BF60E6), U64(0x10E1FFF6, 0x97ED6C69), /* ~= 10^-131 */\n-   U64(0x8DF5EFAB, 0xC5979C8F), U64(0xCA8D3FFA, 0x1EF463C1), /* ~= 10^-130 */\n-   U64(0xB1736B96, 0xB6FD83B3), U64(0xBD308FF8, 0xA6B17CB2), /* ~= 10^-129 */\n-   U64(0xDDD0467C, 0x64BCE4A0), U64(0xAC7CB3F6, 0xD05DDBDE), /* ~= 10^-128 */\n-   U64(0x8AA22C0D, 0xBEF60EE4), U64(0x6BCDF07A, 0x423AA96B), /* ~= 10^-127 */\n-   U64(0xAD4AB711, 0x2EB3929D), U64(0x86C16C98, 0xD2C953C6), /* ~= 10^-126 */\n-   U64(0xD89D64D5, 0x7A607744), U64(0xE871C7BF, 0x077BA8B7), /* ~= 10^-125 */\n-   U64(0x87625F05, 0x6C7C4A8B), U64(0x11471CD7, 0x64AD4972), /* ~= 10^-124 */\n-   U64(0xA93AF6C6, 0xC79B5D2D), U64(0xD598E40D, 0x3DD89BCF), /* ~= 10^-123 */\n-   U64(0xD389B478, 0x79823479), U64(0x4AFF1D10, 0x8D4EC2C3), /* ~= 10^-122 */\n-   U64(0x843610CB, 0x4BF160CB), U64(0xCEDF722A, 0x585139BA), /* ~= 10^-121 */\n-   U64(0xA54394FE, 0x1EEDB8FE), U64(0xC2974EB4, 0xEE658828), /* ~= 10^-120 */\n-   U64(0xCE947A3D, 0xA6A9273E), U64(0x733D2262, 0x29FEEA32), /* ~= 10^-119 */\n-   U64(0x811CCC66, 0x8829B887), U64(0x0806357D, 0x5A3F525F), /* ~= 10^-118 */\n-   U64(0xA163FF80, 0x2A3426A8), U64(0xCA07C2DC, 0xB0CF26F7), /* ~= 10^-117 */\n-   U64(0xC9BCFF60, 0x34C13052), U64(0xFC89B393, 0xDD02F0B5), /* ~= 10^-116 */\n-   U64(0xFC2C3F38, 0x41F17C67), U64(0xBBAC2078, 0xD443ACE2), /* ~= 10^-115 */\n-   U64(0x9D9BA783, 0x2936EDC0), U64(0xD54B944B, 0x84AA4C0D), /* ~= 10^-114 */\n-   U64(0xC5029163, 0xF384A931), U64(0x0A9E795E, 0x65D4DF11), /* ~= 10^-113 */\n-   U64(0xF64335BC, 0xF065D37D), U64(0x4D4617B5, 0xFF4A16D5), /* ~= 10^-112 */\n-   U64(0x99EA0196, 0x163FA42E), U64(0x504BCED1, 0xBF8E4E45), /* ~= 10^-111 */\n-   U64(0xC06481FB, 0x9BCF8D39), U64(0xE45EC286, 0x2F71E1D6), /* ~= 10^-110 */\n-   U64(0xF07DA27A, 0x82C37088), U64(0x5D767327, 0xBB4E5A4C), /* ~= 10^-109 */\n-   U64(0x964E858C, 0x91BA2655), U64(0x3A6A07F8, 0xD510F86F), /* ~= 10^-108 */\n-   U64(0xBBE226EF, 0xB628AFEA), U64(0x890489F7, 0x0A55368B), /* ~= 10^-107 */\n-   U64(0xEADAB0AB, 0xA3B2DBE5), U64(0x2B45AC74, 0xCCEA842E), /* ~= 10^-106 */\n-   U64(0x92C8AE6B, 0x464FC96F), U64(0x3B0B8BC9, 0x0012929D), /* ~= 10^-105 */\n-   U64(0xB77ADA06, 0x17E3BBCB), U64(0x09CE6EBB, 0x40173744), /* ~= 10^-104 */\n-   U64(0xE5599087, 0x9DDCAABD), U64(0xCC420A6A, 0x101D0515), /* ~= 10^-103 */\n-   U64(0x8F57FA54, 0xC2A9EAB6), U64(0x9FA94682, 0x4A12232D), /* ~= 10^-102 */\n-   U64(0xB32DF8E9, 0xF3546564), U64(0x47939822, 0xDC96ABF9), /* ~= 10^-101 */\n-   U64(0xDFF97724, 0x70297EBD), U64(0x59787E2B, 0x93BC56F7), /* ~= 10^-100 */\n-   U64(0x8BFBEA76, 0xC619EF36), U64(0x57EB4EDB, 0x3C55B65A), /* ~= 10^-99 */\n-   U64(0xAEFAE514, 0x77A06B03), U64(0xEDE62292, 0x0B6B23F1), /* ~= 10^-98 */\n-   U64(0xDAB99E59, 0x958885C4), U64(0xE95FAB36, 0x8E45ECED), /* ~= 10^-97 */\n-   U64(0x88B402F7, 0xFD75539B), U64(0x11DBCB02, 0x18EBB414), /* ~= 10^-96 */\n-   U64(0xAAE103B5, 0xFCD2A881), U64(0xD652BDC2, 0x9F26A119), /* ~= 10^-95 */\n-   U64(0xD59944A3, 0x7C0752A2), U64(0x4BE76D33, 0x46F0495F), /* ~= 10^-94 */\n-   U64(0x857FCAE6, 0x2D8493A5), U64(0x6F70A440, 0x0C562DDB), /* ~= 10^-93 */\n-   U64(0xA6DFBD9F, 0xB8E5B88E), U64(0xCB4CCD50, 0x0F6BB952), /* ~= 10^-92 */\n-   U64(0xD097AD07, 0xA71F26B2), U64(0x7E2000A4, 0x1346A7A7), /* ~= 10^-91 */\n-   U64(0x825ECC24, 0xC873782F), U64(0x8ED40066, 0x8C0C28C8), /* ~= 10^-90 */\n-   U64(0xA2F67F2D, 0xFA90563B), U64(0x72890080, 0x2F0F32FA), /* ~= 10^-89 */\n-   U64(0xCBB41EF9, 0x79346BCA), U64(0x4F2B40A0, 0x3AD2FFB9), /* ~= 10^-88 */\n-   U64(0xFEA126B7, 0xD78186BC), U64(0xE2F610C8, 0x4987BFA8), /* ~= 10^-87 */\n-   U64(0x9F24B832, 0xE6B0F436), U64(0x0DD9CA7D, 0x2DF4D7C9), /* ~= 10^-86 */\n-   U64(0xC6EDE63F, 0xA05D3143), U64(0x91503D1C, 0x79720DBB), /* ~= 10^-85 */\n-   U64(0xF8A95FCF, 0x88747D94), U64(0x75A44C63, 0x97CE912A), /* ~= 10^-84 */\n-   U64(0x9B69DBE1, 0xB548CE7C), U64(0xC986AFBE, 0x3EE11ABA), /* ~= 10^-83 */\n-   U64(0xC24452DA, 0x229B021B), U64(0xFBE85BAD, 0xCE996168), /* ~= 10^-82 */\n-   U64(0xF2D56790, 0xAB41C2A2), U64(0xFAE27299, 0x423FB9C3), /* ~= 10^-81 */\n-   U64(0x97C560BA, 0x6B0919A5), U64(0xDCCD879F, 0xC967D41A), /* ~= 10^-80 */\n-   U64(0xBDB6B8E9, 0x05CB600F), U64(0x5400E987, 0xBBC1C920), /* ~= 10^-79 */\n-   U64(0xED246723, 0x473E3813), U64(0x290123E9, 0xAAB23B68), /* ~= 10^-78 */\n-   U64(0x9436C076, 0x0C86E30B), U64(0xF9A0B672, 0x0AAF6521), /* ~= 10^-77 */\n-   U64(0xB9447093, 0x8FA89BCE), U64(0xF808E40E, 0x8D5B3E69), /* ~= 10^-76 */\n-   U64(0xE7958CB8, 0x7392C2C2), U64(0xB60B1D12, 0x30B20E04), /* ~= 10^-75 */\n-   U64(0x90BD77F3, 0x483BB9B9), U64(0xB1C6F22B, 0x5E6F48C2), /* ~= 10^-74 */\n-   U64(0xB4ECD5F0, 0x1A4AA828), U64(0x1E38AEB6, 0x360B1AF3), /* ~= 10^-73 */\n-   U64(0xE2280B6C, 0x20DD5232), U64(0x25C6DA63, 0xC38DE1B0), /* ~= 10^-72 */\n-   U64(0x8D590723, 0x948A535F), U64(0x579C487E, 0x5A38AD0E), /* ~= 10^-71 */\n-   U64(0xB0AF48EC, 0x79ACE837), U64(0x2D835A9D, 0xF0C6D851), /* ~= 10^-70 */\n-   U64(0xDCDB1B27, 0x98182244), U64(0xF8E43145, 0x6CF88E65), /* ~= 10^-69 */\n-   U64(0x8A08F0F8, 0xBF0F156B), U64(0x1B8E9ECB, 0x641B58FF), /* ~= 10^-68 */\n-   U64(0xAC8B2D36, 0xEED2DAC5), U64(0xE272467E, 0x3D222F3F), /* ~= 10^-67 */\n-   U64(0xD7ADF884, 0xAA879177), U64(0x5B0ED81D, 0xCC6ABB0F), /* ~= 10^-66 */\n-   U64(0x86CCBB52, 0xEA94BAEA), U64(0x98E94712, 0x9FC2B4E9), /* ~= 10^-65 */\n-   U64(0xA87FEA27, 0xA539E9A5), U64(0x3F2398D7, 0x47B36224), /* ~= 10^-64 */\n-   U64(0xD29FE4B1, 0x8E88640E), U64(0x8EEC7F0D, 0x19A03AAD), /* ~= 10^-63 */\n-   U64(0x83A3EEEE, 0xF9153E89), U64(0x1953CF68, 0x300424AC), /* ~= 10^-62 */\n-   U64(0xA48CEAAA, 0xB75A8E2B), U64(0x5FA8C342, 0x3C052DD7), /* ~= 10^-61 */\n-   U64(0xCDB02555, 0x653131B6), U64(0x3792F412, 0xCB06794D), /* ~= 10^-60 */\n-   U64(0x808E1755, 0x5F3EBF11), U64(0xE2BBD88B, 0xBEE40BD0), /* ~= 10^-59 */\n-   U64(0xA0B19D2A, 0xB70E6ED6), U64(0x5B6ACEAE, 0xAE9D0EC4), /* ~= 10^-58 */\n-   U64(0xC8DE0475, 0x64D20A8B), U64(0xF245825A, 0x5A445275), /* ~= 10^-57 */\n-   U64(0xFB158592, 0xBE068D2E), U64(0xEED6E2F0, 0xF0D56712), /* ~= 10^-56 */\n-   U64(0x9CED737B, 0xB6C4183D), U64(0x55464DD6, 0x9685606B), /* ~= 10^-55 */\n-   U64(0xC428D05A, 0xA4751E4C), U64(0xAA97E14C, 0x3C26B886), /* ~= 10^-54 */\n-   U64(0xF5330471, 0x4D9265DF), U64(0xD53DD99F, 0x4B3066A8), /* ~= 10^-53 */\n-   U64(0x993FE2C6, 0xD07B7FAB), U64(0xE546A803, 0x8EFE4029), /* ~= 10^-52 */\n-   U64(0xBF8FDB78, 0x849A5F96), U64(0xDE985204, 0x72BDD033), /* ~= 10^-51 */\n-   U64(0xEF73D256, 0xA5C0F77C), U64(0x963E6685, 0x8F6D4440), /* ~= 10^-50 */\n-   U64(0x95A86376, 0x27989AAD), U64(0xDDE70013, 0x79A44AA8), /* ~= 10^-49 */\n-   U64(0xBB127C53, 0xB17EC159), U64(0x5560C018, 0x580D5D52), /* ~= 10^-48 */\n-   U64(0xE9D71B68, 0x9DDE71AF), U64(0xAAB8F01E, 0x6E10B4A6), /* ~= 10^-47 */\n-   U64(0x92267121, 0x62AB070D), U64(0xCAB39613, 0x04CA70E8), /* ~= 10^-46 */\n-   U64(0xB6B00D69, 0xBB55C8D1), U64(0x3D607B97, 0xC5FD0D22), /* ~= 10^-45 */\n-   U64(0xE45C10C4, 0x2A2B3B05), U64(0x8CB89A7D, 0xB77C506A), /* ~= 10^-44 */\n-   U64(0x8EB98A7A, 0x9A5B04E3), U64(0x77F3608E, 0x92ADB242), /* ~= 10^-43 */\n-   U64(0xB267ED19, 0x40F1C61C), U64(0x55F038B2, 0x37591ED3), /* ~= 10^-42 */\n-   U64(0xDF01E85F, 0x912E37A3), U64(0x6B6C46DE, 0xC52F6688), /* ~= 10^-41 */\n-   U64(0x8B61313B, 0xBABCE2C6), U64(0x2323AC4B, 0x3B3DA015), /* ~= 10^-40 */\n-   U64(0xAE397D8A, 0xA96C1B77), U64(0xABEC975E, 0x0A0D081A), /* ~= 10^-39 */\n-   U64(0xD9C7DCED, 0x53C72255), U64(0x96E7BD35, 0x8C904A21), /* ~= 10^-38 */\n-   U64(0x881CEA14, 0x545C7575), U64(0x7E50D641, 0x77DA2E54), /* ~= 10^-37 */\n-   U64(0xAA242499, 0x697392D2), U64(0xDDE50BD1, 0xD5D0B9E9), /* ~= 10^-36 */\n-   U64(0xD4AD2DBF, 0xC3D07787), U64(0x955E4EC6, 0x4B44E864), /* ~= 10^-35 */\n-   U64(0x84EC3C97, 0xDA624AB4), U64(0xBD5AF13B, 0xEF0B113E), /* ~= 10^-34 */\n-   U64(0xA6274BBD, 0xD0FADD61), U64(0xECB1AD8A, 0xEACDD58E), /* ~= 10^-33 */\n-   U64(0xCFB11EAD, 0x453994BA), U64(0x67DE18ED, 0xA5814AF2), /* ~= 10^-32 */\n-   U64(0x81CEB32C, 0x4B43FCF4), U64(0x80EACF94, 0x8770CED7), /* ~= 10^-31 */\n-   U64(0xA2425FF7, 0x5E14FC31), U64(0xA1258379, 0xA94D028D), /* ~= 10^-30 */\n-   U64(0xCAD2F7F5, 0x359A3B3E), U64(0x096EE458, 0x13A04330), /* ~= 10^-29 */\n-   U64(0xFD87B5F2, 0x8300CA0D), U64(0x8BCA9D6E, 0x188853FC), /* ~= 10^-28 */\n-   U64(0x9E74D1B7, 0x91E07E48), U64(0x775EA264, 0xCF55347D), /* ~= 10^-27 */\n-   U64(0xC6120625, 0x76589DDA), U64(0x95364AFE, 0x032A819D), /* ~= 10^-26 */\n-   U64(0xF79687AE, 0xD3EEC551), U64(0x3A83DDBD, 0x83F52204), /* ~= 10^-25 */\n-   U64(0x9ABE14CD, 0x44753B52), U64(0xC4926A96, 0x72793542), /* ~= 10^-24 */\n-   U64(0xC16D9A00, 0x95928A27), U64(0x75B7053C, 0x0F178293), /* ~= 10^-23 */\n-   U64(0xF1C90080, 0xBAF72CB1), U64(0x5324C68B, 0x12DD6338), /* ~= 10^-22 */\n-   U64(0x971DA050, 0x74DA7BEE), U64(0xD3F6FC16, 0xEBCA5E03), /* ~= 10^-21 */\n-   U64(0xBCE50864, 0x92111AEA), U64(0x88F4BB1C, 0xA6BCF584), /* ~= 10^-20 */\n-   U64(0xEC1E4A7D, 0xB69561A5), U64(0x2B31E9E3, 0xD06C32E5), /* ~= 10^-19 */\n-   U64(0x9392EE8E, 0x921D5D07), U64(0x3AFF322E, 0x62439FCF), /* ~= 10^-18 */\n-   U64(0xB877AA32, 0x36A4B449), U64(0x09BEFEB9, 0xFAD487C2), /* ~= 10^-17 */\n-   U64(0xE69594BE, 0xC44DE15B), U64(0x4C2EBE68, 0x7989A9B3), /* ~= 10^-16 */\n-   U64(0x901D7CF7, 0x3AB0ACD9), U64(0x0F9D3701, 0x4BF60A10), /* ~= 10^-15 */\n-   U64(0xB424DC35, 0x095CD80F), U64(0x538484C1, 0x9EF38C94), /* ~= 10^-14 */\n-   U64(0xE12E1342, 0x4BB40E13), U64(0x2865A5F2, 0x06B06FB9), /* ~= 10^-13 */\n-   U64(0x8CBCCC09, 0x6F5088CB), U64(0xF93F87B7, 0x442E45D3), /* ~= 10^-12 */\n-   U64(0xAFEBFF0B, 0xCB24AAFE), U64(0xF78F69A5, 0x1539D748), /* ~= 10^-11 */\n-   U64(0xDBE6FECE, 0xBDEDD5BE), U64(0xB573440E, 0x5A884D1B), /* ~= 10^-10 */\n-   U64(0x89705F41, 0x36B4A597), U64(0x31680A88, 0xF8953030), /* ~= 10^-9 */\n-   U64(0xABCC7711, 0x8461CEFC), U64(0xFDC20D2B, 0x36BA7C3D), /* ~= 10^-8 */\n-   U64(0xD6BF94D5, 0xE57A42BC), U64(0x3D329076, 0x04691B4C), /* ~= 10^-7 */\n-   U64(0x8637BD05, 0xAF6C69B5), U64(0xA63F9A49, 0xC2C1B10F), /* ~= 10^-6 */\n-   U64(0xA7C5AC47, 0x1B478423), U64(0x0FCF80DC, 0x33721D53), /* ~= 10^-5 */\n-   U64(0xD1B71758, 0xE219652B), U64(0xD3C36113, 0x404EA4A8), /* ~= 10^-4 */\n-   U64(0x83126E97, 0x8D4FDF3B), U64(0x645A1CAC, 0x083126E9), /* ~= 10^-3 */\n-   U64(0xA3D70A3D, 0x70A3D70A), U64(0x3D70A3D7, 0x0A3D70A3), /* ~= 10^-2 */\n-   U64(0xCCCCCCCC, 0xCCCCCCCC), U64(0xCCCCCCCC, 0xCCCCCCCC), /* ~= 10^-1 */\n-   U64(0x80000000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^0 */\n-   U64(0xA0000000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^1 */\n-   U64(0xC8000000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^2 */\n-   U64(0xFA000000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^3 */\n-   U64(0x9C400000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^4 */\n-   U64(0xC3500000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^5 */\n-   U64(0xF4240000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^6 */\n-   U64(0x98968000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^7 */\n-   U64(0xBEBC2000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^8 */\n-   U64(0xEE6B2800, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^9 */\n-   U64(0x9502F900, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^10 */\n-   U64(0xBA43B740, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^11 */\n-   U64(0xE8D4A510, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^12 */\n-   U64(0x9184E72A, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^13 */\n-   U64(0xB5E620F4, 0x80000000), U64(0x00000000, 0x00000000), /* == 10^14 */\n-   U64(0xE35FA931, 0xA0000000), U64(0x00000000, 0x00000000), /* == 10^15 */\n-   U64(0x8E1BC9BF, 0x04000000), U64(0x00000000, 0x00000000), /* == 10^16 */\n-   U64(0xB1A2BC2E, 0xC5000000), U64(0x00000000, 0x00000000), /* == 10^17 */\n-   U64(0xDE0B6B3A, 0x76400000), U64(0x00000000, 0x00000000), /* == 10^18 */\n-   U64(0x8AC72304, 0x89E80000), U64(0x00000000, 0x00000000), /* == 10^19 */\n-   U64(0xAD78EBC5, 0xAC620000), U64(0x00000000, 0x00000000), /* == 10^20 */\n-   U64(0xD8D726B7, 0x177A8000), U64(0x00000000, 0x00000000), /* == 10^21 */\n-   U64(0x87867832, 0x6EAC9000), U64(0x00000000, 0x00000000), /* == 10^22 */\n-   U64(0xA968163F, 0x0A57B400), U64(0x00000000, 0x00000000), /* == 10^23 */\n-   U64(0xD3C21BCE, 0xCCEDA100), U64(0x00000000, 0x00000000), /* == 10^24 */\n-   U64(0x84595161, 0x401484A0), U64(0x00000000, 0x00000000), /* == 10^25 */\n-   U64(0xA56FA5B9, 0x9019A5C8), U64(0x00000000, 0x00000000), /* == 10^26 */\n-   U64(0xCECB8F27, 0xF4200F3A), U64(0x00000000, 0x00000000), /* == 10^27 */\n-   U64(0x813F3978, 0xF8940984), U64(0x40000000, 0x00000000), /* == 10^28 */\n-   U64(0xA18F07D7, 0x36B90BE5), U64(0x50000000, 0x00000000), /* == 10^29 */\n-   U64(0xC9F2C9CD, 0x04674EDE), U64(0xA4000000, 0x00000000), /* == 10^30 */\n-   U64(0xFC6F7C40, 0x45812296), U64(0x4D000000, 0x00000000), /* == 10^31 */\n-   U64(0x9DC5ADA8, 0x2B70B59D), U64(0xF0200000, 0x00000000), /* == 10^32 */\n-   U64(0xC5371912, 0x364CE305), U64(0x6C280000, 0x00000000), /* == 10^33 */\n-   U64(0xF684DF56, 0xC3E01BC6), U64(0xC7320000, 0x00000000), /* == 10^34 */\n-   U64(0x9A130B96, 0x3A6C115C), U64(0x3C7F4000, 0x00000000), /* == 10^35 */\n-   U64(0xC097CE7B, 0xC90715B3), U64(0x4B9F1000, 0x00000000), /* == 10^36 */\n-   U64(0xF0BDC21A, 0xBB48DB20), U64(0x1E86D400, 0x00000000), /* == 10^37 */\n-   U64(0x96769950, 0xB50D88F4), U64(0x13144480, 0x00000000), /* == 10^38 */\n-   U64(0xBC143FA4, 0xE250EB31), U64(0x17D955A0, 0x00000000), /* == 10^39 */\n-   U64(0xEB194F8E, 0x1AE525FD), U64(0x5DCFAB08, 0x00000000), /* == 10^40 */\n-   U64(0x92EFD1B8, 0xD0CF37BE), U64(0x5AA1CAE5, 0x00000000), /* == 10^41 */\n-   U64(0xB7ABC627, 0x050305AD), U64(0xF14A3D9E, 0x40000000), /* == 10^42 */\n-   U64(0xE596B7B0, 0xC643C719), U64(0x6D9CCD05, 0xD0000000), /* == 10^43 */\n-   U64(0x8F7E32CE, 0x7BEA5C6F), U64(0xE4820023, 0xA2000000), /* == 10^44 */\n-   U64(0xB35DBF82, 0x1AE4F38B), U64(0xDDA2802C, 0x8A800000), /* == 10^45 */\n-   U64(0xE0352F62, 0xA19E306E), U64(0xD50B2037, 0xAD200000), /* == 10^46 */\n-   U64(0x8C213D9D, 0xA502DE45), U64(0x4526F422, 0xCC340000), /* == 10^47 */\n-   U64(0xAF298D05, 0x0E4395D6), U64(0x9670B12B, 0x7F410000), /* == 10^48 */\n-   U64(0xDAF3F046, 0x51D47B4C), U64(0x3C0CDD76, 0x5F114000), /* == 10^49 */\n-   U64(0x88D8762B, 0xF324CD0F), U64(0xA5880A69, 0xFB6AC800), /* == 10^50 */\n-   U64(0xAB0E93B6, 0xEFEE0053), U64(0x8EEA0D04, 0x7A457A00), /* == 10^51 */\n-   U64(0xD5D238A4, 0xABE98068), U64(0x72A49045, 0x98D6D880), /* == 10^52 */\n-   U64(0x85A36366, 0xEB71F041), U64(0x47A6DA2B, 0x7F864750), /* == 10^53 */\n-   U64(0xA70C3C40, 0xA64E6C51), U64(0x999090B6, 0x5F67D924), /* == 10^54 */\n-   U64(0xD0CF4B50, 0xCFE20765), U64(0xFFF4B4E3, 0xF741CF6D), /* == 10^55 */\n-   U64(0x82818F12, 0x81ED449F), U64(0xBFF8F10E, 0x7A8921A4), /* ~= 10^56 */\n-   U64(0xA321F2D7, 0x226895C7), U64(0xAFF72D52, 0x192B6A0D), /* ~= 10^57 */\n-   U64(0xCBEA6F8C, 0xEB02BB39), U64(0x9BF4F8A6, 0x9F764490), /* ~= 10^58 */\n-   U64(0xFEE50B70, 0x25C36A08), U64(0x02F236D0, 0x4753D5B4), /* ~= 10^59 */\n-   U64(0x9F4F2726, 0x179A2245), U64(0x01D76242, 0x2C946590), /* ~= 10^60 */\n-   U64(0xC722F0EF, 0x9D80AAD6), U64(0x424D3AD2, 0xB7B97EF5), /* ~= 10^61 */\n-   U64(0xF8EBAD2B, 0x84E0D58B), U64(0xD2E08987, 0x65A7DEB2), /* ~= 10^62 */\n-   U64(0x9B934C3B, 0x330C8577), U64(0x63CC55F4, 0x9F88EB2F), /* ~= 10^63 */\n-   U64(0xC2781F49, 0xFFCFA6D5), U64(0x3CBF6B71, 0xC76B25FB), /* ~= 10^64 */\n-   U64(0xF316271C, 0x7FC3908A), U64(0x8BEF464E, 0x3945EF7A), /* ~= 10^65 */\n-   U64(0x97EDD871, 0xCFDA3A56), U64(0x97758BF0, 0xE3CBB5AC), /* ~= 10^66 */\n-   U64(0xBDE94E8E, 0x43D0C8EC), U64(0x3D52EEED, 0x1CBEA317), /* ~= 10^67 */\n-   U64(0xED63A231, 0xD4C4FB27), U64(0x4CA7AAA8, 0x63EE4BDD), /* ~= 10^68 */\n-   U64(0x945E455F, 0x24FB1CF8), U64(0x8FE8CAA9, 0x3E74EF6A), /* ~= 10^69 */\n-   U64(0xB975D6B6, 0xEE39E436), U64(0xB3E2FD53, 0x8E122B44), /* ~= 10^70 */\n-   U64(0xE7D34C64, 0xA9C85D44), U64(0x60DBBCA8, 0x7196B616), /* ~= 10^71 */\n-   U64(0x90E40FBE, 0xEA1D3A4A), U64(0xBC8955E9, 0x46FE31CD), /* ~= 10^72 */\n-   U64(0xB51D13AE, 0xA4A488DD), U64(0x6BABAB63, 0x98BDBE41), /* ~= 10^73 */\n-   U64(0xE264589A, 0x4DCDAB14), U64(0xC696963C, 0x7EED2DD1), /* ~= 10^74 */\n-   U64(0x8D7EB760, 0x70A08AEC), U64(0xFC1E1DE5, 0xCF543CA2), /* ~= 10^75 */\n-   U64(0xB0DE6538, 0x8CC8ADA8), U64(0x3B25A55F, 0x43294BCB), /* ~= 10^76 */\n-   U64(0xDD15FE86, 0xAFFAD912), U64(0x49EF0EB7, 0x13F39EBE), /* ~= 10^77 */\n-   U64(0x8A2DBF14, 0x2DFCC7AB), U64(0x6E356932, 0x6C784337), /* ~= 10^78 */\n-   U64(0xACB92ED9, 0x397BF996), U64(0x49C2C37F, 0x07965404), /* ~= 10^79 */\n-   U64(0xD7E77A8F, 0x87DAF7FB), U64(0xDC33745E, 0xC97BE906), /* ~= 10^80 */\n-   U64(0x86F0AC99, 0xB4E8DAFD), U64(0x69A028BB, 0x3DED71A3), /* ~= 10^81 */\n-   U64(0xA8ACD7C0, 0x222311BC), U64(0xC40832EA, 0x0D68CE0C), /* ~= 10^82 */\n-   U64(0xD2D80DB0, 0x2AABD62B), U64(0xF50A3FA4, 0x90C30190), /* ~= 10^83 */\n-   U64(0x83C7088E, 0x1AAB65DB), U64(0x792667C6, 0xDA79E0FA), /* ~= 10^84 */\n-   U64(0xA4B8CAB1, 0xA1563F52), U64(0x577001B8, 0x91185938), /* ~= 10^85 */\n-   U64(0xCDE6FD5E, 0x09ABCF26), U64(0xED4C0226, 0xB55E6F86), /* ~= 10^86 */\n-   U64(0x80B05E5A, 0xC60B6178), U64(0x544F8158, 0x315B05B4), /* ~= 10^87 */\n-   U64(0xA0DC75F1, 0x778E39D6), U64(0x696361AE, 0x3DB1C721), /* ~= 10^88 */\n-   U64(0xC913936D, 0xD571C84C), U64(0x03BC3A19, 0xCD1E38E9), /* ~= 10^89 */\n-   U64(0xFB587849, 0x4ACE3A5F), U64(0x04AB48A0, 0x4065C723), /* ~= 10^90 */\n-   U64(0x9D174B2D, 0xCEC0E47B), U64(0x62EB0D64, 0x283F9C76), /* ~= 10^91 */\n-   U64(0xC45D1DF9, 0x42711D9A), U64(0x3BA5D0BD, 0x324F8394), /* ~= 10^92 */\n-   U64(0xF5746577, 0x930D6500), U64(0xCA8F44EC, 0x7EE36479), /* ~= 10^93 */\n-   U64(0x9968BF6A, 0xBBE85F20), U64(0x7E998B13, 0xCF4E1ECB), /* ~= 10^94 */\n-   U64(0xBFC2EF45, 0x6AE276E8), U64(0x9E3FEDD8, 0xC321A67E), /* ~= 10^95 */\n-   U64(0xEFB3AB16, 0xC59B14A2), U64(0xC5CFE94E, 0xF3EA101E), /* ~= 10^96 */\n-   U64(0x95D04AEE, 0x3B80ECE5), U64(0xBBA1F1D1, 0x58724A12), /* ~= 10^97 */\n-   U64(0xBB445DA9, 0xCA61281F), U64(0x2A8A6E45, 0xAE8EDC97), /* ~= 10^98 */\n-   U64(0xEA157514, 0x3CF97226), U64(0xF52D09D7, 0x1A3293BD), /* ~= 10^99 */\n-   U64(0x924D692C, 0xA61BE758), U64(0x593C2626, 0x705F9C56), /* ~= 10^100 */\n-   U64(0xB6E0C377, 0xCFA2E12E), U64(0x6F8B2FB0, 0x0C77836C), /* ~= 10^101 */\n-   U64(0xE498F455, 0xC38B997A), U64(0x0B6DFB9C, 0x0F956447), /* ~= 10^102 */\n-   U64(0x8EDF98B5, 0x9A373FEC), U64(0x4724BD41, 0x89BD5EAC), /* ~= 10^103 */\n-   U64(0xB2977EE3, 0x00C50FE7), U64(0x58EDEC91, 0xEC2CB657), /* ~= 10^104 */\n-   U64(0xDF3D5E9B, 0xC0F653E1), U64(0x2F2967B6, 0x6737E3ED), /* ~= 10^105 */\n-   U64(0x8B865B21, 0x5899F46C), U64(0xBD79E0D2, 0x0082EE74), /* ~= 10^106 */\n-   U64(0xAE67F1E9, 0xAEC07187), U64(0xECD85906, 0x80A3AA11), /* ~= 10^107 */\n-   U64(0xDA01EE64, 0x1A708DE9), U64(0xE80E6F48, 0x20CC9495), /* ~= 10^108 */\n-   U64(0x884134FE, 0x908658B2), U64(0x3109058D, 0x147FDCDD), /* ~= 10^109 */\n-   U64(0xAA51823E, 0x34A7EEDE), U64(0xBD4B46F0, 0x599FD415), /* ~= 10^110 */\n-   U64(0xD4E5E2CD, 0xC1D1EA96), U64(0x6C9E18AC, 0x7007C91A), /* ~= 10^111 */\n-   U64(0x850FADC0, 0x9923329E), U64(0x03E2CF6B, 0xC604DDB0), /* ~= 10^112 */\n-   U64(0xA6539930, 0xBF6BFF45), U64(0x84DB8346, 0xB786151C), /* ~= 10^113 */\n-   U64(0xCFE87F7C, 0xEF46FF16), U64(0xE6126418, 0x65679A63), /* ~= 10^114 */\n-   U64(0x81F14FAE, 0x158C5F6E), U64(0x4FCB7E8F, 0x3F60C07E), /* ~= 10^115 */\n-   U64(0xA26DA399, 0x9AEF7749), U64(0xE3BE5E33, 0x0F38F09D), /* ~= 10^116 */\n-   U64(0xCB090C80, 0x01AB551C), U64(0x5CADF5BF, 0xD3072CC5), /* ~= 10^117 */\n-   U64(0xFDCB4FA0, 0x02162A63), U64(0x73D9732F, 0xC7C8F7F6), /* ~= 10^118 */\n-   U64(0x9E9F11C4, 0x014DDA7E), U64(0x2867E7FD, 0xDCDD9AFA), /* ~= 10^119 */\n-   U64(0xC646D635, 0x01A1511D), U64(0xB281E1FD, 0x541501B8), /* ~= 10^120 */\n-   U64(0xF7D88BC2, 0x4209A565), U64(0x1F225A7C, 0xA91A4226), /* ~= 10^121 */\n-   U64(0x9AE75759, 0x6946075F), U64(0x3375788D, 0xE9B06958), /* ~= 10^122 */\n-   U64(0xC1A12D2F, 0xC3978937), U64(0x0052D6B1, 0x641C83AE), /* ~= 10^123 */\n-   U64(0xF209787B, 0xB47D6B84), U64(0xC0678C5D, 0xBD23A49A), /* ~= 10^124 */\n-   U64(0x9745EB4D, 0x50CE6332), U64(0xF840B7BA, 0x963646E0), /* ~= 10^125 */\n-   U64(0xBD176620, 0xA501FBFF), U64(0xB650E5A9, 0x3BC3D898), /* ~= 10^126 */\n-   U64(0xEC5D3FA8, 0xCE427AFF), U64(0xA3E51F13, 0x8AB4CEBE), /* ~= 10^127 */\n-   U64(0x93BA47C9, 0x80E98CDF), U64(0xC66F336C, 0x36B10137), /* ~= 10^128 */\n-   U64(0xB8A8D9BB, 0xE123F017), U64(0xB80B0047, 0x445D4184), /* ~= 10^129 */\n-   U64(0xE6D3102A, 0xD96CEC1D), U64(0xA60DC059, 0x157491E5), /* ~= 10^130 */\n-   U64(0x9043EA1A, 0xC7E41392), U64(0x87C89837, 0xAD68DB2F), /* ~= 10^131 */\n-   U64(0xB454E4A1, 0x79DD1877), U64(0x29BABE45, 0x98C311FB), /* ~= 10^132 */\n-   U64(0xE16A1DC9, 0xD8545E94), U64(0xF4296DD6, 0xFEF3D67A), /* ~= 10^133 */\n-   U64(0x8CE2529E, 0x2734BB1D), U64(0x1899E4A6, 0x5F58660C), /* ~= 10^134 */\n-   U64(0xB01AE745, 0xB101E9E4), U64(0x5EC05DCF, 0xF72E7F8F), /* ~= 10^135 */\n-   U64(0xDC21A117, 0x1D42645D), U64(0x76707543, 0xF4FA1F73), /* ~= 10^136 */\n-   U64(0x899504AE, 0x72497EBA), U64(0x6A06494A, 0x791C53A8), /* ~= 10^137 */\n-   U64(0xABFA45DA, 0x0EDBDE69), U64(0x0487DB9D, 0x17636892), /* ~= 10^138 */\n-   U64(0xD6F8D750, 0x9292D603), U64(0x45A9D284, 0x5D3C42B6), /* ~= 10^139 */\n-   U64(0x865B8692, 0x5B9BC5C2), U64(0x0B8A2392, 0xBA45A9B2), /* ~= 10^140 */\n-   U64(0xA7F26836, 0xF282B732), U64(0x8E6CAC77, 0x68D7141E), /* ~= 10^141 */\n-   U64(0xD1EF0244, 0xAF2364FF), U64(0x3207D795, 0x430CD926), /* ~= 10^142 */\n-   U64(0x8335616A, 0xED761F1F), U64(0x7F44E6BD, 0x49E807B8), /* ~= 10^143 */\n-   U64(0xA402B9C5, 0xA8D3A6E7), U64(0x5F16206C, 0x9C6209A6), /* ~= 10^144 */\n-   U64(0xCD036837, 0x130890A1), U64(0x36DBA887, 0xC37A8C0F), /* ~= 10^145 */\n-   U64(0x80222122, 0x6BE55A64), U64(0xC2494954, 0xDA2C9789), /* ~= 10^146 */\n-   U64(0xA02AA96B, 0x06DEB0FD), U64(0xF2DB9BAA, 0x10B7BD6C), /* ~= 10^147 */\n-   U64(0xC83553C5, 0xC8965D3D), U64(0x6F928294, 0x94E5ACC7), /* ~= 10^148 */\n-   U64(0xFA42A8B7, 0x3ABBF48C), U64(0xCB772339, 0xBA1F17F9), /* ~= 10^149 */\n-   U64(0x9C69A972, 0x84B578D7), U64(0xFF2A7604, 0x14536EFB), /* ~= 10^150 */\n-   U64(0xC38413CF, 0x25E2D70D), U64(0xFEF51385, 0x19684ABA), /* ~= 10^151 */\n-   U64(0xF46518C2, 0xEF5B8CD1), U64(0x7EB25866, 0x5FC25D69), /* ~= 10^152 */\n-   U64(0x98BF2F79, 0xD5993802), U64(0xEF2F773F, 0xFBD97A61), /* ~= 10^153 */\n-   U64(0xBEEEFB58, 0x4AFF8603), U64(0xAAFB550F, 0xFACFD8FA), /* ~= 10^154 */\n-   U64(0xEEAABA2E, 0x5DBF6784), U64(0x95BA2A53, 0xF983CF38), /* ~= 10^155 */\n-   U64(0x952AB45C, 0xFA97A0B2), U64(0xDD945A74, 0x7BF26183), /* ~= 10^156 */\n-   U64(0xBA756174, 0x393D88DF), U64(0x94F97111, 0x9AEEF9E4), /* ~= 10^157 */\n-   U64(0xE912B9D1, 0x478CEB17), U64(0x7A37CD56, 0x01AAB85D), /* ~= 10^158 */\n-   U64(0x91ABB422, 0xCCB812EE), U64(0xAC62E055, 0xC10AB33A), /* ~= 10^159 */\n-   U64(0xB616A12B, 0x7FE617AA), U64(0x577B986B, 0x314D6009), /* ~= 10^160 */\n-   U64(0xE39C4976, 0x5FDF9D94), U64(0xED5A7E85, 0xFDA0B80B), /* ~= 10^161 */\n-   U64(0x8E41ADE9, 0xFBEBC27D), U64(0x14588F13, 0xBE847307), /* ~= 10^162 */\n-   U64(0xB1D21964, 0x7AE6B31C), U64(0x596EB2D8, 0xAE258FC8), /* ~= 10^163 */\n-   U64(0xDE469FBD, 0x99A05FE3), U64(0x6FCA5F8E, 0xD9AEF3BB), /* ~= 10^164 */\n-   U64(0x8AEC23D6, 0x80043BEE), U64(0x25DE7BB9, 0x480D5854), /* ~= 10^165 */\n-   U64(0xADA72CCC, 0x20054AE9), U64(0xAF561AA7, 0x9A10AE6A), /* ~= 10^166 */\n-   U64(0xD910F7FF, 0x28069DA4), U64(0x1B2BA151, 0x8094DA04), /* ~= 10^167 */\n-   U64(0x87AA9AFF, 0x79042286), U64(0x90FB44D2, 0xF05D0842), /* ~= 10^168 */\n-   U64(0xA99541BF, 0x57452B28), U64(0x353A1607, 0xAC744A53), /* ~= 10^169 */\n-   U64(0xD3FA922F, 0x2D1675F2), U64(0x42889B89, 0x97915CE8), /* ~= 10^170 */\n-   U64(0x847C9B5D, 0x7C2E09B7), U64(0x69956135, 0xFEBADA11), /* ~= 10^171 */\n-   U64(0xA59BC234, 0xDB398C25), U64(0x43FAB983, 0x7E699095), /* ~= 10^172 */\n-   U64(0xCF02B2C2, 0x1207EF2E), U64(0x94F967E4, 0x5E03F4BB), /* ~= 10^173 */\n-   U64(0x8161AFB9, 0x4B44F57D), U64(0x1D1BE0EE, 0xBAC278F5), /* ~= 10^174 */\n-   U64(0xA1BA1BA7, 0x9E1632DC), U64(0x6462D92A, 0x69731732), /* ~= 10^175 */\n-   U64(0xCA28A291, 0x859BBF93), U64(0x7D7B8F75, 0x03CFDCFE), /* ~= 10^176 */\n-   U64(0xFCB2CB35, 0xE702AF78), U64(0x5CDA7352, 0x44C3D43E), /* ~= 10^177 */\n-   U64(0x9DEFBF01, 0xB061ADAB), U64(0x3A088813, 0x6AFA64A7), /* ~= 10^178 */\n-   U64(0xC56BAEC2, 0x1C7A1916), U64(0x088AAA18, 0x45B8FDD0), /* ~= 10^179 */\n-   U64(0xF6C69A72, 0xA3989F5B), U64(0x8AAD549E, 0x57273D45), /* ~= 10^180 */\n-   U64(0x9A3C2087, 0xA63F6399), U64(0x36AC54E2, 0xF678864B), /* ~= 10^181 */\n-   U64(0xC0CB28A9, 0x8FCF3C7F), U64(0x84576A1B, 0xB416A7DD), /* ~= 10^182 */\n-   U64(0xF0FDF2D3, 0xF3C30B9F), U64(0x656D44A2, 0xA11C51D5), /* ~= 10^183 */\n-   U64(0x969EB7C4, 0x7859E743), U64(0x9F644AE5, 0xA4B1B325), /* ~= 10^184 */\n-   U64(0xBC4665B5, 0x96706114), U64(0x873D5D9F, 0x0DDE1FEE), /* ~= 10^185 */\n-   U64(0xEB57FF22, 0xFC0C7959), U64(0xA90CB506, 0xD155A7EA), /* ~= 10^186 */\n-   U64(0x9316FF75, 0xDD87CBD8), U64(0x09A7F124, 0x42D588F2), /* ~= 10^187 */\n-   U64(0xB7DCBF53, 0x54E9BECE), U64(0x0C11ED6D, 0x538AEB2F), /* ~= 10^188 */\n-   U64(0xE5D3EF28, 0x2A242E81), U64(0x8F1668C8, 0xA86DA5FA), /* ~= 10^189 */\n-   U64(0x8FA47579, 0x1A569D10), U64(0xF96E017D, 0x694487BC), /* ~= 10^190 */\n-   U64(0xB38D92D7, 0x60EC4455), U64(0x37C981DC, 0xC395A9AC), /* ~= 10^191 */\n-   U64(0xE070F78D, 0x3927556A), U64(0x85BBE253, 0xF47B1417), /* ~= 10^192 */\n-   U64(0x8C469AB8, 0x43B89562), U64(0x93956D74, 0x78CCEC8E), /* ~= 10^193 */\n-   U64(0xAF584166, 0x54A6BABB), U64(0x387AC8D1, 0x970027B2), /* ~= 10^194 */\n-   U64(0xDB2E51BF, 0xE9D0696A), U64(0x06997B05, 0xFCC0319E), /* ~= 10^195 */\n-   U64(0x88FCF317, 0xF22241E2), U64(0x441FECE3, 0xBDF81F03), /* ~= 10^196 */\n-   U64(0xAB3C2FDD, 0xEEAAD25A), U64(0xD527E81C, 0xAD7626C3), /* ~= 10^197 */\n-   U64(0xD60B3BD5, 0x6A5586F1), U64(0x8A71E223, 0xD8D3B074), /* ~= 10^198 */\n-   U64(0x85C70565, 0x62757456), U64(0xF6872D56, 0x67844E49), /* ~= 10^199 */\n-   U64(0xA738C6BE, 0xBB12D16C), U64(0xB428F8AC, 0x016561DB), /* ~= 10^200 */\n-   U64(0xD106F86E, 0x69D785C7), U64(0xE13336D7, 0x01BEBA52), /* ~= 10^201 */\n-   U64(0x82A45B45, 0x0226B39C), U64(0xECC00246, 0x61173473), /* ~= 10^202 */\n-   U64(0xA34D7216, 0x42B06084), U64(0x27F002D7, 0xF95D0190), /* ~= 10^203 */\n-   U64(0xCC20CE9B, 0xD35C78A5), U64(0x31EC038D, 0xF7B441F4), /* ~= 10^204 */\n-   U64(0xFF290242, 0xC83396CE), U64(0x7E670471, 0x75A15271), /* ~= 10^205 */\n-   U64(0x9F79A169, 0xBD203E41), U64(0x0F0062C6, 0xE984D386), /* ~= 10^206 */\n-   U64(0xC75809C4, 0x2C684DD1), U64(0x52C07B78, 0xA3E60868), /* ~= 10^207 */\n-   U64(0xF92E0C35, 0x37826145), U64(0xA7709A56, 0xCCDF8A82), /* ~= 10^208 */\n-   U64(0x9BBCC7A1, 0x42B17CCB), U64(0x88A66076, 0x400BB691), /* ~= 10^209 */\n-   U64(0xC2ABF989, 0x935DDBFE), U64(0x6ACFF893, 0xD00EA435), /* ~= 10^210 */\n-   U64(0xF356F7EB, 0xF83552FE), U64(0x0583F6B8, 0xC4124D43), /* ~= 10^211 */\n-   U64(0x98165AF3, 0x7B2153DE), U64(0xC3727A33, 0x7A8B704A), /* ~= 10^212 */\n-   U64(0xBE1BF1B0, 0x59E9A8D6), U64(0x744F18C0, 0x592E4C5C), /* ~= 10^213 */\n-   U64(0xEDA2EE1C, 0x7064130C), U64(0x1162DEF0, 0x6F79DF73), /* ~= 10^214 */\n-   U64(0x9485D4D1, 0xC63E8BE7), U64(0x8ADDCB56, 0x45AC2BA8), /* ~= 10^215 */\n-   U64(0xB9A74A06, 0x37CE2EE1), U64(0x6D953E2B, 0xD7173692), /* ~= 10^216 */\n-   U64(0xE8111C87, 0xC5C1BA99), U64(0xC8FA8DB6, 0xCCDD0437), /* ~= 10^217 */\n-   U64(0x910AB1D4, 0xDB9914A0), U64(0x1D9C9892, 0x400A22A2), /* ~= 10^218 */\n-   U64(0xB54D5E4A, 0x127F59C8), U64(0x2503BEB6, 0xD00CAB4B), /* ~= 10^219 */\n-   U64(0xE2A0B5DC, 0x971F303A), U64(0x2E44AE64, 0x840FD61D), /* ~= 10^220 */\n-   U64(0x8DA471A9, 0xDE737E24), U64(0x5CEAECFE, 0xD289E5D2), /* ~= 10^221 */\n-   U64(0xB10D8E14, 0x56105DAD), U64(0x7425A83E, 0x872C5F47), /* ~= 10^222 */\n-   U64(0xDD50F199, 0x6B947518), U64(0xD12F124E, 0x28F77719), /* ~= 10^223 */\n-   U64(0x8A5296FF, 0xE33CC92F), U64(0x82BD6B70, 0xD99AAA6F), /* ~= 10^224 */\n-   U64(0xACE73CBF, 0xDC0BFB7B), U64(0x636CC64D, 0x1001550B), /* ~= 10^225 */\n-   U64(0xD8210BEF, 0xD30EFA5A), U64(0x3C47F7E0, 0x5401AA4E), /* ~= 10^226 */\n-   U64(0x8714A775, 0xE3E95C78), U64(0x65ACFAEC, 0x34810A71), /* ~= 10^227 */\n-   U64(0xA8D9D153, 0x5CE3B396), U64(0x7F1839A7, 0x41A14D0D), /* ~= 10^228 */\n-   U64(0xD31045A8, 0x341CA07C), U64(0x1EDE4811, 0x1209A050), /* ~= 10^229 */\n-   U64(0x83EA2B89, 0x2091E44D), U64(0x934AED0A, 0xAB460432), /* ~= 10^230 */\n-   U64(0xA4E4B66B, 0x68B65D60), U64(0xF81DA84D, 0x5617853F), /* ~= 10^231 */\n-   U64(0xCE1DE406, 0x42E3F4B9), U64(0x36251260, 0xAB9D668E), /* ~= 10^232 */\n-   U64(0x80D2AE83, 0xE9CE78F3), U64(0xC1D72B7C, 0x6B426019), /* ~= 10^233 */\n-   U64(0xA1075A24, 0xE4421730), U64(0xB24CF65B, 0x8612F81F), /* ~= 10^234 */\n-   U64(0xC94930AE, 0x1D529CFC), U64(0xDEE033F2, 0x6797B627), /* ~= 10^235 */\n-   U64(0xFB9B7CD9, 0xA4A7443C), U64(0x169840EF, 0x017DA3B1), /* ~= 10^236 */\n-   U64(0x9D412E08, 0x06E88AA5), U64(0x8E1F2895, 0x60EE864E), /* ~= 10^237 */\n-   U64(0xC491798A, 0x08A2AD4E), U64(0xF1A6F2BA, 0xB92A27E2), /* ~= 10^238 */\n-   U64(0xF5B5D7EC, 0x8ACB58A2), U64(0xAE10AF69, 0x6774B1DB), /* ~= 10^239 */\n-   U64(0x9991A6F3, 0xD6BF1765), U64(0xACCA6DA1, 0xE0A8EF29), /* ~= 10^240 */\n-   U64(0xBFF610B0, 0xCC6EDD3F), U64(0x17FD090A, 0x58D32AF3), /* ~= 10^241 */\n-   U64(0xEFF394DC, 0xFF8A948E), U64(0xDDFC4B4C, 0xEF07F5B0), /* ~= 10^242 */\n-   U64(0x95F83D0A, 0x1FB69CD9), U64(0x4ABDAF10, 0x1564F98E), /* ~= 10^243 */\n-   U64(0xBB764C4C, 0xA7A4440F), U64(0x9D6D1AD4, 0x1ABE37F1), /* ~= 10^244 */\n-   U64(0xEA53DF5F, 0xD18D5513), U64(0x84C86189, 0x216DC5ED), /* ~= 10^245 */\n-   U64(0x92746B9B, 0xE2F8552C), U64(0x32FD3CF5, 0xB4E49BB4), /* ~= 10^246 */\n-   U64(0xB7118682, 0xDBB66A77), U64(0x3FBC8C33, 0x221DC2A1), /* ~= 10^247 */\n-   U64(0xE4D5E823, 0x92A40515), U64(0x0FABAF3F, 0xEAA5334A), /* ~= 10^248 */\n-   U64(0x8F05B116, 0x3BA6832D), U64(0x29CB4D87, 0xF2A7400E), /* ~= 10^249 */\n-   U64(0xB2C71D5B, 0xCA9023F8), U64(0x743E20E9, 0xEF511012), /* ~= 10^250 */\n-   U64(0xDF78E4B2, 0xBD342CF6), U64(0x914DA924, 0x6B255416), /* ~= 10^251 */\n-   U64(0x8BAB8EEF, 0xB6409C1A), U64(0x1AD089B6, 0xC2F7548E), /* ~= 10^252 */\n-   U64(0xAE9672AB, 0xA3D0C320), U64(0xA184AC24, 0x73B529B1), /* ~= 10^253 */\n-   U64(0xDA3C0F56, 0x8CC4F3E8), U64(0xC9E5D72D, 0x90A2741E), /* ~= 10^254 */\n-   U64(0x88658996, 0x17FB1871), U64(0x7E2FA67C, 0x7A658892), /* ~= 10^255 */\n-   U64(0xAA7EEBFB, 0x9DF9DE8D), U64(0xDDBB901B, 0x98FEEAB7), /* ~= 10^256 */\n-   U64(0xD51EA6FA, 0x85785631), U64(0x552A7422, 0x7F3EA565), /* ~= 10^257 */\n-   U64(0x8533285C, 0x936B35DE), U64(0xD53A8895, 0x8F87275F), /* ~= 10^258 */\n-   U64(0xA67FF273, 0xB8460356), U64(0x8A892ABA, 0xF368F137), /* ~= 10^259 */\n-   U64(0xD01FEF10, 0xA657842C), U64(0x2D2B7569, 0xB0432D85), /* ~= 10^260 */\n-   U64(0x8213F56A, 0x67F6B29B), U64(0x9C3B2962, 0x0E29FC73), /* ~= 10^261 */\n-   U64(0xA298F2C5, 0x01F45F42), U64(0x8349F3BA, 0x91B47B8F), /* ~= 10^262 */\n-   U64(0xCB3F2F76, 0x42717713), U64(0x241C70A9, 0x36219A73), /* ~= 10^263 */\n-   U64(0xFE0EFB53, 0xD30DD4D7), U64(0xED238CD3, 0x83AA0110), /* ~= 10^264 */\n-   U64(0x9EC95D14, 0x63E8A506), U64(0xF4363804, 0x324A40AA), /* ~= 10^265 */\n-   U64(0xC67BB459, 0x7CE2CE48), U64(0xB143C605, 0x3EDCD0D5), /* ~= 10^266 */\n-   U64(0xF81AA16F, 0xDC1B81DA), U64(0xDD94B786, 0x8E94050A), /* ~= 10^267 */\n-   U64(0x9B10A4E5, 0xE9913128), U64(0xCA7CF2B4, 0x191C8326), /* ~= 10^268 */\n-   U64(0xC1D4CE1F, 0x63F57D72), U64(0xFD1C2F61, 0x1F63A3F0), /* ~= 10^269 */\n-   U64(0xF24A01A7, 0x3CF2DCCF), U64(0xBC633B39, 0x673C8CEC), /* ~= 10^270 */\n-   U64(0x976E4108, 0x8617CA01), U64(0xD5BE0503, 0xE085D813), /* ~= 10^271 */\n-   U64(0xBD49D14A, 0xA79DBC82), U64(0x4B2D8644, 0xD8A74E18), /* ~= 10^272 */\n-   U64(0xEC9C459D, 0x51852BA2), U64(0xDDF8E7D6, 0x0ED1219E), /* ~= 10^273 */\n-   U64(0x93E1AB82, 0x52F33B45), U64(0xCABB90E5, 0xC942B503), /* ~= 10^274 */\n-   U64(0xB8DA1662, 0xE7B00A17), U64(0x3D6A751F, 0x3B936243), /* ~= 10^275 */\n-   U64(0xE7109BFB, 0xA19C0C9D), U64(0x0CC51267, 0x0A783AD4), /* ~= 10^276 */\n-   U64(0x906A617D, 0x450187E2), U64(0x27FB2B80, 0x668B24C5), /* ~= 10^277 */\n-   U64(0xB484F9DC, 0x9641E9DA), U64(0xB1F9F660, 0x802DEDF6), /* ~= 10^278 */\n-   U64(0xE1A63853, 0xBBD26451), U64(0x5E7873F8, 0xA0396973), /* ~= 10^279 */\n-   U64(0x8D07E334, 0x55637EB2), U64(0xDB0B487B, 0x6423E1E8), /* ~= 10^280 */\n-   U64(0xB049DC01, 0x6ABC5E5F), U64(0x91CE1A9A, 0x3D2CDA62), /* ~= 10^281 */\n-   U64(0xDC5C5301, 0xC56B75F7), U64(0x7641A140, 0xCC7810FB), /* ~= 10^282 */\n-   U64(0x89B9B3E1, 0x1B6329BA), U64(0xA9E904C8, 0x7FCB0A9D), /* ~= 10^283 */\n-   U64(0xAC2820D9, 0x623BF429), U64(0x546345FA, 0x9FBDCD44), /* ~= 10^284 */\n-   U64(0xD732290F, 0xBACAF133), U64(0xA97C1779, 0x47AD4095), /* ~= 10^285 */\n-   U64(0x867F59A9, 0xD4BED6C0), U64(0x49ED8EAB, 0xCCCC485D), /* ~= 10^286 */\n-   U64(0xA81F3014, 0x49EE8C70), U64(0x5C68F256, 0xBFFF5A74), /* ~= 10^287 */\n-   U64(0xD226FC19, 0x5C6A2F8C), U64(0x73832EEC, 0x6FFF3111), /* ~= 10^288 */\n-   U64(0x83585D8F, 0xD9C25DB7), U64(0xC831FD53, 0xC5FF7EAB), /* ~= 10^289 */\n-   U64(0xA42E74F3, 0xD032F525), U64(0xBA3E7CA8, 0xB77F5E55), /* ~= 10^290 */\n-   U64(0xCD3A1230, 0xC43FB26F), U64(0x28CE1BD2, 0xE55F35EB), /* ~= 10^291 */\n-   U64(0x80444B5E, 0x7AA7CF85), U64(0x7980D163, 0xCF5B81B3), /* ~= 10^292 */\n-   U64(0xA0555E36, 0x1951C366), U64(0xD7E105BC, 0xC332621F), /* ~= 10^293 */\n-   U64(0xC86AB5C3, 0x9FA63440), U64(0x8DD9472B, 0xF3FEFAA7), /* ~= 10^294 */\n-   U64(0xFA856334, 0x878FC150), U64(0xB14F98F6, 0xF0FEB951), /* ~= 10^295 */\n-   U64(0x9C935E00, 0xD4B9D8D2), U64(0x6ED1BF9A, 0x569F33D3), /* ~= 10^296 */\n-   U64(0xC3B83581, 0x09E84F07), U64(0x0A862F80, 0xEC4700C8), /* ~= 10^297 */\n-   U64(0xF4A642E1, 0x4C6262C8), U64(0xCD27BB61, 0x2758C0FA), /* ~= 10^298 */\n-   U64(0x98E7E9CC, 0xCFBD7DBD), U64(0x8038D51C, 0xB897789C), /* ~= 10^299 */\n-   U64(0xBF21E440, 0x03ACDD2C), U64(0xE0470A63, 0xE6BD56C3), /* ~= 10^300 */\n-   U64(0xEEEA5D50, 0x04981478), U64(0x1858CCFC, 0xE06CAC74), /* ~= 10^301 */\n-   U64(0x95527A52, 0x02DF0CCB), U64(0x0F37801E, 0x0C43EBC8), /* ~= 10^302 */\n-   U64(0xBAA718E6, 0x8396CFFD), U64(0xD3056025, 0x8F54E6BA), /* ~= 10^303 */\n-   U64(0xE950DF20, 0x247C83FD), U64(0x47C6B82E, 0xF32A2069), /* ~= 10^304 */\n-   U64(0x91D28B74, 0x16CDD27E), U64(0x4CDC331D, 0x57FA5441), /* ~= 10^305 */\n-   U64(0xB6472E51, 0x1C81471D), U64(0xE0133FE4, 0xADF8E952), /* ~= 10^306 */\n-   U64(0xE3D8F9E5, 0x63A198E5), U64(0x58180FDD, 0xD97723A6), /* ~= 10^307 */\n-   U64(0x8E679C2F, 0x5E44FF8F), U64(0x570F09EA, 0xA7EA7648), /* ~= 10^308 */\n-   U64(0xB201833B, 0x35D63F73), U64(0x2CD2CC65, 0x51E513DA), /* ~= 10^309 */\n-   U64(0xDE81E40A, 0x034BCF4F), U64(0xF8077F7E, 0xA65E58D1), /* ~= 10^310 */\n-   U64(0x8B112E86, 0x420F6191), U64(0xFB04AFAF, 0x27FAF782), /* ~= 10^311 */\n-   U64(0xADD57A27, 0xD29339F6), U64(0x79C5DB9A, 0xF1F9B563), /* ~= 10^312 */\n-   U64(0xD94AD8B1, 0xC7380874), U64(0x18375281, 0xAE7822BC), /* ~= 10^313 */\n-   U64(0x87CEC76F, 0x1C830548), U64(0x8F229391, 0x0D0B15B5), /* ~= 10^314 */\n-   U64(0xA9C2794A, 0xE3A3C69A), U64(0xB2EB3875, 0x504DDB22), /* ~= 10^315 */\n-   U64(0xD433179D, 0x9C8CB841), U64(0x5FA60692, 0xA46151EB), /* ~= 10^316 */\n-   U64(0x849FEEC2, 0x81D7F328), U64(0xDBC7C41B, 0xA6BCD333), /* ~= 10^317 */\n-   U64(0xA5C7EA73, 0x224DEFF3), U64(0x12B9B522, 0x906C0800), /* ~= 10^318 */\n-   U64(0xCF39E50F, 0xEAE16BEF), U64(0xD768226B, 0x34870A00), /* ~= 10^319 */\n-   U64(0x81842F29, 0xF2CCE375), U64(0xE6A11583, 0x00D46640), /* ~= 10^320 */\n-   U64(0xA1E53AF4, 0x6F801C53), U64(0x60495AE3, 0xC1097FD0), /* ~= 10^321 */\n-   U64(0xCA5E89B1, 0x8B602368), U64(0x385BB19C, 0xB14BDFC4), /* ~= 10^322 */\n-   U64(0xFCF62C1D, 0xEE382C42), U64(0x46729E03, 0xDD9ED7B5), /* ~= 10^323 */\n-   U64(0x9E19DB92, 0xB4E31BA9), U64(0x6C07A2C2, 0x6A8346D1)  /* ~= 10^324 */\n+    U64(0xBF29DCAB, 0xA82FDEAE), U64(0x7432EE87, 0x3880FC33), /* ~= 10^-343 */\n+    U64(0xEEF453D6, 0x923BD65A), U64(0x113FAA29, 0x06A13B3F), /* ~= 10^-342 */\n+    U64(0x9558B466, 0x1B6565F8), U64(0x4AC7CA59, 0xA424C507), /* ~= 10^-341 */\n+    U64(0xBAAEE17F, 0xA23EBF76), U64(0x5D79BCF0, 0x0D2DF649), /* ~= 10^-340 */\n+    U64(0xE95A99DF, 0x8ACE6F53), U64(0xF4D82C2C, 0x107973DC), /* ~= 10^-339 */\n+    U64(0x91D8A02B, 0xB6C10594), U64(0x79071B9B, 0x8A4BE869), /* ~= 10^-338 */\n+    U64(0xB64EC836, 0xA47146F9), U64(0x9748E282, 0x6CDEE284), /* ~= 10^-337 */\n+    U64(0xE3E27A44, 0x4D8D98B7), U64(0xFD1B1B23, 0x08169B25), /* ~= 10^-336 */\n+    U64(0x8E6D8C6A, 0xB0787F72), U64(0xFE30F0F5, 0xE50E20F7), /* ~= 10^-335 */\n+    U64(0xB208EF85, 0x5C969F4F), U64(0xBDBD2D33, 0x5E51A935), /* ~= 10^-334 */\n+    U64(0xDE8B2B66, 0xB3BC4723), U64(0xAD2C7880, 0x35E61382), /* ~= 10^-333 */\n+    U64(0x8B16FB20, 0x3055AC76), U64(0x4C3BCB50, 0x21AFCC31), /* ~= 10^-332 */\n+    U64(0xADDCB9E8, 0x3C6B1793), U64(0xDF4ABE24, 0x2A1BBF3D), /* ~= 10^-331 */\n+    U64(0xD953E862, 0x4B85DD78), U64(0xD71D6DAD, 0x34A2AF0D), /* ~= 10^-330 */\n+    U64(0x87D4713D, 0x6F33AA6B), U64(0x8672648C, 0x40E5AD68), /* ~= 10^-329 */\n+    U64(0xA9C98D8C, 0xCB009506), U64(0x680EFDAF, 0x511F18C2), /* ~= 10^-328 */\n+    U64(0xD43BF0EF, 0xFDC0BA48), U64(0x0212BD1B, 0x2566DEF2), /* ~= 10^-327 */\n+    U64(0x84A57695, 0xFE98746D), U64(0x014BB630, 0xF7604B57), /* ~= 10^-326 */\n+    U64(0xA5CED43B, 0x7E3E9188), U64(0x419EA3BD, 0x35385E2D), /* ~= 10^-325 */\n+    U64(0xCF42894A, 0x5DCE35EA), U64(0x52064CAC, 0x828675B9), /* ~= 10^-324 */\n+    U64(0x818995CE, 0x7AA0E1B2), U64(0x7343EFEB, 0xD1940993), /* ~= 10^-323 */\n+    U64(0xA1EBFB42, 0x19491A1F), U64(0x1014EBE6, 0xC5F90BF8), /* ~= 10^-322 */\n+    U64(0xCA66FA12, 0x9F9B60A6), U64(0xD41A26E0, 0x77774EF6), /* ~= 10^-321 */\n+    U64(0xFD00B897, 0x478238D0), U64(0x8920B098, 0x955522B4), /* ~= 10^-320 */\n+    U64(0x9E20735E, 0x8CB16382), U64(0x55B46E5F, 0x5D5535B0), /* ~= 10^-319 */\n+    U64(0xC5A89036, 0x2FDDBC62), U64(0xEB2189F7, 0x34AA831D), /* ~= 10^-318 */\n+    U64(0xF712B443, 0xBBD52B7B), U64(0xA5E9EC75, 0x01D523E4), /* ~= 10^-317 */\n+    U64(0x9A6BB0AA, 0x55653B2D), U64(0x47B233C9, 0x2125366E), /* ~= 10^-316 */\n+    U64(0xC1069CD4, 0xEABE89F8), U64(0x999EC0BB, 0x696E840A), /* ~= 10^-315 */\n+    U64(0xF148440A, 0x256E2C76), U64(0xC00670EA, 0x43CA250D), /* ~= 10^-314 */\n+    U64(0x96CD2A86, 0x5764DBCA), U64(0x38040692, 0x6A5E5728), /* ~= 10^-313 */\n+    U64(0xBC807527, 0xED3E12BC), U64(0xC6050837, 0x04F5ECF2), /* ~= 10^-312 */\n+    U64(0xEBA09271, 0xE88D976B), U64(0xF7864A44, 0xC633682E), /* ~= 10^-311 */\n+    U64(0x93445B87, 0x31587EA3), U64(0x7AB3EE6A, 0xFBE0211D), /* ~= 10^-310 */\n+    U64(0xB8157268, 0xFDAE9E4C), U64(0x5960EA05, 0xBAD82964), /* ~= 10^-309 */\n+    U64(0xE61ACF03, 0x3D1A45DF), U64(0x6FB92487, 0x298E33BD), /* ~= 10^-308 */\n+    U64(0x8FD0C162, 0x06306BAB), U64(0xA5D3B6D4, 0x79F8E056), /* ~= 10^-307 */\n+    U64(0xB3C4F1BA, 0x87BC8696), U64(0x8F48A489, 0x9877186C), /* ~= 10^-306 */\n+    U64(0xE0B62E29, 0x29ABA83C), U64(0x331ACDAB, 0xFE94DE87), /* ~= 10^-305 */\n+    U64(0x8C71DCD9, 0xBA0B4925), U64(0x9FF0C08B, 0x7F1D0B14), /* ~= 10^-304 */\n+    U64(0xAF8E5410, 0x288E1B6F), U64(0x07ECF0AE, 0x5EE44DD9), /* ~= 10^-303 */\n+    U64(0xDB71E914, 0x32B1A24A), U64(0xC9E82CD9, 0xF69D6150), /* ~= 10^-302 */\n+    U64(0x892731AC, 0x9FAF056E), U64(0xBE311C08, 0x3A225CD2), /* ~= 10^-301 */\n+    U64(0xAB70FE17, 0xC79AC6CA), U64(0x6DBD630A, 0x48AAF406), /* ~= 10^-300 */\n+    U64(0xD64D3D9D, 0xB981787D), U64(0x092CBBCC, 0xDAD5B108), /* ~= 10^-299 */\n+    U64(0x85F04682, 0x93F0EB4E), U64(0x25BBF560, 0x08C58EA5), /* ~= 10^-298 */\n+    U64(0xA76C5823, 0x38ED2621), U64(0xAF2AF2B8, 0x0AF6F24E), /* ~= 10^-297 */\n+    U64(0xD1476E2C, 0x07286FAA), U64(0x1AF5AF66, 0x0DB4AEE1), /* ~= 10^-296 */\n+    U64(0x82CCA4DB, 0x847945CA), U64(0x50D98D9F, 0xC890ED4D), /* ~= 10^-295 */\n+    U64(0xA37FCE12, 0x6597973C), U64(0xE50FF107, 0xBAB528A0), /* ~= 10^-294 */\n+    U64(0xCC5FC196, 0xFEFD7D0C), U64(0x1E53ED49, 0xA96272C8), /* ~= 10^-293 */\n+    U64(0xFF77B1FC, 0xBEBCDC4F), U64(0x25E8E89C, 0x13BB0F7A), /* ~= 10^-292 */\n+    U64(0x9FAACF3D, 0xF73609B1), U64(0x77B19161, 0x8C54E9AC), /* ~= 10^-291 */\n+    U64(0xC795830D, 0x75038C1D), U64(0xD59DF5B9, 0xEF6A2417), /* ~= 10^-290 */\n+    U64(0xF97AE3D0, 0xD2446F25), U64(0x4B057328, 0x6B44AD1D), /* ~= 10^-289 */\n+    U64(0x9BECCE62, 0x836AC577), U64(0x4EE367F9, 0x430AEC32), /* ~= 10^-288 */\n+    U64(0xC2E801FB, 0x244576D5), U64(0x229C41F7, 0x93CDA73F), /* ~= 10^-287 */\n+    U64(0xF3A20279, 0xED56D48A), U64(0x6B435275, 0x78C1110F), /* ~= 10^-286 */\n+    U64(0x9845418C, 0x345644D6), U64(0x830A1389, 0x6B78AAA9), /* ~= 10^-285 */\n+    U64(0xBE5691EF, 0x416BD60C), U64(0x23CC986B, 0xC656D553), /* ~= 10^-284 */\n+    U64(0xEDEC366B, 0x11C6CB8F), U64(0x2CBFBE86, 0xB7EC8AA8), /* ~= 10^-283 */\n+    U64(0x94B3A202, 0xEB1C3F39), U64(0x7BF7D714, 0x32F3D6A9), /* ~= 10^-282 */\n+    U64(0xB9E08A83, 0xA5E34F07), U64(0xDAF5CCD9, 0x3FB0CC53), /* ~= 10^-281 */\n+    U64(0xE858AD24, 0x8F5C22C9), U64(0xD1B3400F, 0x8F9CFF68), /* ~= 10^-280 */\n+    U64(0x91376C36, 0xD99995BE), U64(0x23100809, 0xB9C21FA1), /* ~= 10^-279 */\n+    U64(0xB5854744, 0x8FFFFB2D), U64(0xABD40A0C, 0x2832A78A), /* ~= 10^-278 */\n+    U64(0xE2E69915, 0xB3FFF9F9), U64(0x16C90C8F, 0x323F516C), /* ~= 10^-277 */\n+    U64(0x8DD01FAD, 0x907FFC3B), U64(0xAE3DA7D9, 0x7F6792E3), /* ~= 10^-276 */\n+    U64(0xB1442798, 0xF49FFB4A), U64(0x99CD11CF, 0xDF41779C), /* ~= 10^-275 */\n+    U64(0xDD95317F, 0x31C7FA1D), U64(0x40405643, 0xD711D583), /* ~= 10^-274 */\n+    U64(0x8A7D3EEF, 0x7F1CFC52), U64(0x482835EA, 0x666B2572), /* ~= 10^-273 */\n+    U64(0xAD1C8EAB, 0x5EE43B66), U64(0xDA324365, 0x0005EECF), /* ~= 10^-272 */\n+    U64(0xD863B256, 0x369D4A40), U64(0x90BED43E, 0x40076A82), /* ~= 10^-271 */\n+    U64(0x873E4F75, 0xE2224E68), U64(0x5A7744A6, 0xE804A291), /* ~= 10^-270 */\n+    U64(0xA90DE353, 0x5AAAE202), U64(0x711515D0, 0xA205CB36), /* ~= 10^-269 */\n+    U64(0xD3515C28, 0x31559A83), U64(0x0D5A5B44, 0xCA873E03), /* ~= 10^-268 */\n+    U64(0x8412D999, 0x1ED58091), U64(0xE858790A, 0xFE9486C2), /* ~= 10^-267 */\n+    U64(0xA5178FFF, 0x668AE0B6), U64(0x626E974D, 0xBE39A872), /* ~= 10^-266 */\n+    U64(0xCE5D73FF, 0x402D98E3), U64(0xFB0A3D21, 0x2DC8128F), /* ~= 10^-265 */\n+    U64(0x80FA687F, 0x881C7F8E), U64(0x7CE66634, 0xBC9D0B99), /* ~= 10^-264 */\n+    U64(0xA139029F, 0x6A239F72), U64(0x1C1FFFC1, 0xEBC44E80), /* ~= 10^-263 */\n+    U64(0xC9874347, 0x44AC874E), U64(0xA327FFB2, 0x66B56220), /* ~= 10^-262 */\n+    U64(0xFBE91419, 0x15D7A922), U64(0x4BF1FF9F, 0x0062BAA8), /* ~= 10^-261 */\n+    U64(0x9D71AC8F, 0xADA6C9B5), U64(0x6F773FC3, 0x603DB4A9), /* ~= 10^-260 */\n+    U64(0xC4CE17B3, 0x99107C22), U64(0xCB550FB4, 0x384D21D3), /* ~= 10^-259 */\n+    U64(0xF6019DA0, 0x7F549B2B), U64(0x7E2A53A1, 0x46606A48), /* ~= 10^-258 */\n+    U64(0x99C10284, 0x4F94E0FB), U64(0x2EDA7444, 0xCBFC426D), /* ~= 10^-257 */\n+    U64(0xC0314325, 0x637A1939), U64(0xFA911155, 0xFEFB5308), /* ~= 10^-256 */\n+    U64(0xF03D93EE, 0xBC589F88), U64(0x793555AB, 0x7EBA27CA), /* ~= 10^-255 */\n+    U64(0x96267C75, 0x35B763B5), U64(0x4BC1558B, 0x2F3458DE), /* ~= 10^-254 */\n+    U64(0xBBB01B92, 0x83253CA2), U64(0x9EB1AAED, 0xFB016F16), /* ~= 10^-253 */\n+    U64(0xEA9C2277, 0x23EE8BCB), U64(0x465E15A9, 0x79C1CADC), /* ~= 10^-252 */\n+    U64(0x92A1958A, 0x7675175F), U64(0x0BFACD89, 0xEC191EC9), /* ~= 10^-251 */\n+    U64(0xB749FAED, 0x14125D36), U64(0xCEF980EC, 0x671F667B), /* ~= 10^-250 */\n+    U64(0xE51C79A8, 0x5916F484), U64(0x82B7E127, 0x80E7401A), /* ~= 10^-249 */\n+    U64(0x8F31CC09, 0x37AE58D2), U64(0xD1B2ECB8, 0xB0908810), /* ~= 10^-248 */\n+    U64(0xB2FE3F0B, 0x8599EF07), U64(0x861FA7E6, 0xDCB4AA15), /* ~= 10^-247 */\n+    U64(0xDFBDCECE, 0x67006AC9), U64(0x67A791E0, 0x93E1D49A), /* ~= 10^-246 */\n+    U64(0x8BD6A141, 0x006042BD), U64(0xE0C8BB2C, 0x5C6D24E0), /* ~= 10^-245 */\n+    U64(0xAECC4991, 0x4078536D), U64(0x58FAE9F7, 0x73886E18), /* ~= 10^-244 */\n+    U64(0xDA7F5BF5, 0x90966848), U64(0xAF39A475, 0x506A899E), /* ~= 10^-243 */\n+    U64(0x888F9979, 0x7A5E012D), U64(0x6D8406C9, 0x52429603), /* ~= 10^-242 */\n+    U64(0xAAB37FD7, 0xD8F58178), U64(0xC8E5087B, 0xA6D33B83), /* ~= 10^-241 */\n+    U64(0xD5605FCD, 0xCF32E1D6), U64(0xFB1E4A9A, 0x90880A64), /* ~= 10^-240 */\n+    U64(0x855C3BE0, 0xA17FCD26), U64(0x5CF2EEA0, 0x9A55067F), /* ~= 10^-239 */\n+    U64(0xA6B34AD8, 0xC9DFC06F), U64(0xF42FAA48, 0xC0EA481E), /* ~= 10^-238 */\n+    U64(0xD0601D8E, 0xFC57B08B), U64(0xF13B94DA, 0xF124DA26), /* ~= 10^-237 */\n+    U64(0x823C1279, 0x5DB6CE57), U64(0x76C53D08, 0xD6B70858), /* ~= 10^-236 */\n+    U64(0xA2CB1717, 0xB52481ED), U64(0x54768C4B, 0x0C64CA6E), /* ~= 10^-235 */\n+    U64(0xCB7DDCDD, 0xA26DA268), U64(0xA9942F5D, 0xCF7DFD09), /* ~= 10^-234 */\n+    U64(0xFE5D5415, 0x0B090B02), U64(0xD3F93B35, 0x435D7C4C), /* ~= 10^-233 */\n+    U64(0x9EFA548D, 0x26E5A6E1), U64(0xC47BC501, 0x4A1A6DAF), /* ~= 10^-232 */\n+    U64(0xC6B8E9B0, 0x709F109A), U64(0x359AB641, 0x9CA1091B), /* ~= 10^-231 */\n+    U64(0xF867241C, 0x8CC6D4C0), U64(0xC30163D2, 0x03C94B62), /* ~= 10^-230 */\n+    U64(0x9B407691, 0xD7FC44F8), U64(0x79E0DE63, 0x425DCF1D), /* ~= 10^-229 */\n+    U64(0xC2109436, 0x4DFB5636), U64(0x985915FC, 0x12F542E4), /* ~= 10^-228 */\n+    U64(0xF294B943, 0xE17A2BC4), U64(0x3E6F5B7B, 0x17B2939D), /* ~= 10^-227 */\n+    U64(0x979CF3CA, 0x6CEC5B5A), U64(0xA705992C, 0xEECF9C42), /* ~= 10^-226 */\n+    U64(0xBD8430BD, 0x08277231), U64(0x50C6FF78, 0x2A838353), /* ~= 10^-225 */\n+    U64(0xECE53CEC, 0x4A314EBD), U64(0xA4F8BF56, 0x35246428), /* ~= 10^-224 */\n+    U64(0x940F4613, 0xAE5ED136), U64(0x871B7795, 0xE136BE99), /* ~= 10^-223 */\n+    U64(0xB9131798, 0x99F68584), U64(0x28E2557B, 0x59846E3F), /* ~= 10^-222 */\n+    U64(0xE757DD7E, 0xC07426E5), U64(0x331AEADA, 0x2FE589CF), /* ~= 10^-221 */\n+    U64(0x9096EA6F, 0x3848984F), U64(0x3FF0D2C8, 0x5DEF7621), /* ~= 10^-220 */\n+    U64(0xB4BCA50B, 0x065ABE63), U64(0x0FED077A, 0x756B53A9), /* ~= 10^-219 */\n+    U64(0xE1EBCE4D, 0xC7F16DFB), U64(0xD3E84959, 0x12C62894), /* ~= 10^-218 */\n+    U64(0x8D3360F0, 0x9CF6E4BD), U64(0x64712DD7, 0xABBBD95C), /* ~= 10^-217 */\n+    U64(0xB080392C, 0xC4349DEC), U64(0xBD8D794D, 0x96AACFB3), /* ~= 10^-216 */\n+    U64(0xDCA04777, 0xF541C567), U64(0xECF0D7A0, 0xFC5583A0), /* ~= 10^-215 */\n+    U64(0x89E42CAA, 0xF9491B60), U64(0xF41686C4, 0x9DB57244), /* ~= 10^-214 */\n+    U64(0xAC5D37D5, 0xB79B6239), U64(0x311C2875, 0xC522CED5), /* ~= 10^-213 */\n+    U64(0xD77485CB, 0x25823AC7), U64(0x7D633293, 0x366B828B), /* ~= 10^-212 */\n+    U64(0x86A8D39E, 0xF77164BC), U64(0xAE5DFF9C, 0x02033197), /* ~= 10^-211 */\n+    U64(0xA8530886, 0xB54DBDEB), U64(0xD9F57F83, 0x0283FDFC), /* ~= 10^-210 */\n+    U64(0xD267CAA8, 0x62A12D66), U64(0xD072DF63, 0xC324FD7B), /* ~= 10^-209 */\n+    U64(0x8380DEA9, 0x3DA4BC60), U64(0x4247CB9E, 0x59F71E6D), /* ~= 10^-208 */\n+    U64(0xA4611653, 0x8D0DEB78), U64(0x52D9BE85, 0xF074E608), /* ~= 10^-207 */\n+    U64(0xCD795BE8, 0x70516656), U64(0x67902E27, 0x6C921F8B), /* ~= 10^-206 */\n+    U64(0x806BD971, 0x4632DFF6), U64(0x00BA1CD8, 0xA3DB53B6), /* ~= 10^-205 */\n+    U64(0xA086CFCD, 0x97BF97F3), U64(0x80E8A40E, 0xCCD228A4), /* ~= 10^-204 */\n+    U64(0xC8A883C0, 0xFDAF7DF0), U64(0x6122CD12, 0x8006B2CD), /* ~= 10^-203 */\n+    U64(0xFAD2A4B1, 0x3D1B5D6C), U64(0x796B8057, 0x20085F81), /* ~= 10^-202 */\n+    U64(0x9CC3A6EE, 0xC6311A63), U64(0xCBE33036, 0x74053BB0), /* ~= 10^-201 */\n+    U64(0xC3F490AA, 0x77BD60FC), U64(0xBEDBFC44, 0x11068A9C), /* ~= 10^-200 */\n+    U64(0xF4F1B4D5, 0x15ACB93B), U64(0xEE92FB55, 0x15482D44), /* ~= 10^-199 */\n+    U64(0x99171105, 0x2D8BF3C5), U64(0x751BDD15, 0x2D4D1C4A), /* ~= 10^-198 */\n+    U64(0xBF5CD546, 0x78EEF0B6), U64(0xD262D45A, 0x78A0635D), /* ~= 10^-197 */\n+    U64(0xEF340A98, 0x172AACE4), U64(0x86FB8971, 0x16C87C34), /* ~= 10^-196 */\n+    U64(0x9580869F, 0x0E7AAC0E), U64(0xD45D35E6, 0xAE3D4DA0), /* ~= 10^-195 */\n+    U64(0xBAE0A846, 0xD2195712), U64(0x89748360, 0x59CCA109), /* ~= 10^-194 */\n+    U64(0xE998D258, 0x869FACD7), U64(0x2BD1A438, 0x703FC94B), /* ~= 10^-193 */\n+    U64(0x91FF8377, 0x5423CC06), U64(0x7B6306A3, 0x4627DDCF), /* ~= 10^-192 */\n+    U64(0xB67F6455, 0x292CBF08), U64(0x1A3BC84C, 0x17B1D542), /* ~= 10^-191 */\n+    U64(0xE41F3D6A, 0x7377EECA), U64(0x20CABA5F, 0x1D9E4A93), /* ~= 10^-190 */\n+    U64(0x8E938662, 0x882AF53E), U64(0x547EB47B, 0x7282EE9C), /* ~= 10^-189 */\n+    U64(0xB23867FB, 0x2A35B28D), U64(0xE99E619A, 0x4F23AA43), /* ~= 10^-188 */\n+    U64(0xDEC681F9, 0xF4C31F31), U64(0x6405FA00, 0xE2EC94D4), /* ~= 10^-187 */\n+    U64(0x8B3C113C, 0x38F9F37E), U64(0xDE83BC40, 0x8DD3DD04), /* ~= 10^-186 */\n+    U64(0xAE0B158B, 0x4738705E), U64(0x9624AB50, 0xB148D445), /* ~= 10^-185 */\n+    U64(0xD98DDAEE, 0x19068C76), U64(0x3BADD624, 0xDD9B0957), /* ~= 10^-184 */\n+    U64(0x87F8A8D4, 0xCFA417C9), U64(0xE54CA5D7, 0x0A80E5D6), /* ~= 10^-183 */\n+    U64(0xA9F6D30A, 0x038D1DBC), U64(0x5E9FCF4C, 0xCD211F4C), /* ~= 10^-182 */\n+    U64(0xD47487CC, 0x8470652B), U64(0x7647C320, 0x0069671F), /* ~= 10^-181 */\n+    U64(0x84C8D4DF, 0xD2C63F3B), U64(0x29ECD9F4, 0x0041E073), /* ~= 10^-180 */\n+    U64(0xA5FB0A17, 0xC777CF09), U64(0xF4681071, 0x00525890), /* ~= 10^-179 */\n+    U64(0xCF79CC9D, 0xB955C2CC), U64(0x7182148D, 0x4066EEB4), /* ~= 10^-178 */\n+    U64(0x81AC1FE2, 0x93D599BF), U64(0xC6F14CD8, 0x48405530), /* ~= 10^-177 */\n+    U64(0xA21727DB, 0x38CB002F), U64(0xB8ADA00E, 0x5A506A7C), /* ~= 10^-176 */\n+    U64(0xCA9CF1D2, 0x06FDC03B), U64(0xA6D90811, 0xF0E4851C), /* ~= 10^-175 */\n+    U64(0xFD442E46, 0x88BD304A), U64(0x908F4A16, 0x6D1DA663), /* ~= 10^-174 */\n+    U64(0x9E4A9CEC, 0x15763E2E), U64(0x9A598E4E, 0x043287FE), /* ~= 10^-173 */\n+    U64(0xC5DD4427, 0x1AD3CDBA), U64(0x40EFF1E1, 0x853F29FD), /* ~= 10^-172 */\n+    U64(0xF7549530, 0xE188C128), U64(0xD12BEE59, 0xE68EF47C), /* ~= 10^-171 */\n+    U64(0x9A94DD3E, 0x8CF578B9), U64(0x82BB74F8, 0x301958CE), /* ~= 10^-170 */\n+    U64(0xC13A148E, 0x3032D6E7), U64(0xE36A5236, 0x3C1FAF01), /* ~= 10^-169 */\n+    U64(0xF18899B1, 0xBC3F8CA1), U64(0xDC44E6C3, 0xCB279AC1), /* ~= 10^-168 */\n+    U64(0x96F5600F, 0x15A7B7E5), U64(0x29AB103A, 0x5EF8C0B9), /* ~= 10^-167 */\n+    U64(0xBCB2B812, 0xDB11A5DE), U64(0x7415D448, 0xF6B6F0E7), /* ~= 10^-166 */\n+    U64(0xEBDF6617, 0x91D60F56), U64(0x111B495B, 0x3464AD21), /* ~= 10^-165 */\n+    U64(0x936B9FCE, 0xBB25C995), U64(0xCAB10DD9, 0x00BEEC34), /* ~= 10^-164 */\n+    U64(0xB84687C2, 0x69EF3BFB), U64(0x3D5D514F, 0x40EEA742), /* ~= 10^-163 */\n+    U64(0xE65829B3, 0x046B0AFA), U64(0x0CB4A5A3, 0x112A5112), /* ~= 10^-162 */\n+    U64(0x8FF71A0F, 0xE2C2E6DC), U64(0x47F0E785, 0xEABA72AB), /* ~= 10^-161 */\n+    U64(0xB3F4E093, 0xDB73A093), U64(0x59ED2167, 0x65690F56), /* ~= 10^-160 */\n+    U64(0xE0F218B8, 0xD25088B8), U64(0x306869C1, 0x3EC3532C), /* ~= 10^-159 */\n+    U64(0x8C974F73, 0x83725573), U64(0x1E414218, 0xC73A13FB), /* ~= 10^-158 */\n+    U64(0xAFBD2350, 0x644EEACF), U64(0xE5D1929E, 0xF90898FA), /* ~= 10^-157 */\n+    U64(0xDBAC6C24, 0x7D62A583), U64(0xDF45F746, 0xB74ABF39), /* ~= 10^-156 */\n+    U64(0x894BC396, 0xCE5DA772), U64(0x6B8BBA8C, 0x328EB783), /* ~= 10^-155 */\n+    U64(0xAB9EB47C, 0x81F5114F), U64(0x066EA92F, 0x3F326564), /* ~= 10^-154 */\n+    U64(0xD686619B, 0xA27255A2), U64(0xC80A537B, 0x0EFEFEBD), /* ~= 10^-153 */\n+    U64(0x8613FD01, 0x45877585), U64(0xBD06742C, 0xE95F5F36), /* ~= 10^-152 */\n+    U64(0xA798FC41, 0x96E952E7), U64(0x2C481138, 0x23B73704), /* ~= 10^-151 */\n+    U64(0xD17F3B51, 0xFCA3A7A0), U64(0xF75A1586, 0x2CA504C5), /* ~= 10^-150 */\n+    U64(0x82EF8513, 0x3DE648C4), U64(0x9A984D73, 0xDBE722FB), /* ~= 10^-149 */\n+    U64(0xA3AB6658, 0x0D5FDAF5), U64(0xC13E60D0, 0xD2E0EBBA), /* ~= 10^-148 */\n+    U64(0xCC963FEE, 0x10B7D1B3), U64(0x318DF905, 0x079926A8), /* ~= 10^-147 */\n+    U64(0xFFBBCFE9, 0x94E5C61F), U64(0xFDF17746, 0x497F7052), /* ~= 10^-146 */\n+    U64(0x9FD561F1, 0xFD0F9BD3), U64(0xFEB6EA8B, 0xEDEFA633), /* ~= 10^-145 */\n+    U64(0xC7CABA6E, 0x7C5382C8), U64(0xFE64A52E, 0xE96B8FC0), /* ~= 10^-144 */\n+    U64(0xF9BD690A, 0x1B68637B), U64(0x3DFDCE7A, 0xA3C673B0), /* ~= 10^-143 */\n+    U64(0x9C1661A6, 0x51213E2D), U64(0x06BEA10C, 0xA65C084E), /* ~= 10^-142 */\n+    U64(0xC31BFA0F, 0xE5698DB8), U64(0x486E494F, 0xCFF30A62), /* ~= 10^-141 */\n+    U64(0xF3E2F893, 0xDEC3F126), U64(0x5A89DBA3, 0xC3EFCCFA), /* ~= 10^-140 */\n+    U64(0x986DDB5C, 0x6B3A76B7), U64(0xF8962946, 0x5A75E01C), /* ~= 10^-139 */\n+    U64(0xBE895233, 0x86091465), U64(0xF6BBB397, 0xF1135823), /* ~= 10^-138 */\n+    U64(0xEE2BA6C0, 0x678B597F), U64(0x746AA07D, 0xED582E2C), /* ~= 10^-137 */\n+    U64(0x94DB4838, 0x40B717EF), U64(0xA8C2A44E, 0xB4571CDC), /* ~= 10^-136 */\n+    U64(0xBA121A46, 0x50E4DDEB), U64(0x92F34D62, 0x616CE413), /* ~= 10^-135 */\n+    U64(0xE896A0D7, 0xE51E1566), U64(0x77B020BA, 0xF9C81D17), /* ~= 10^-134 */\n+    U64(0x915E2486, 0xEF32CD60), U64(0x0ACE1474, 0xDC1D122E), /* ~= 10^-133 */\n+    U64(0xB5B5ADA8, 0xAAFF80B8), U64(0x0D819992, 0x132456BA), /* ~= 10^-132 */\n+    U64(0xE3231912, 0xD5BF60E6), U64(0x10E1FFF6, 0x97ED6C69), /* ~= 10^-131 */\n+    U64(0x8DF5EFAB, 0xC5979C8F), U64(0xCA8D3FFA, 0x1EF463C1), /* ~= 10^-130 */\n+    U64(0xB1736B96, 0xB6FD83B3), U64(0xBD308FF8, 0xA6B17CB2), /* ~= 10^-129 */\n+    U64(0xDDD0467C, 0x64BCE4A0), U64(0xAC7CB3F6, 0xD05DDBDE), /* ~= 10^-128 */\n+    U64(0x8AA22C0D, 0xBEF60EE4), U64(0x6BCDF07A, 0x423AA96B), /* ~= 10^-127 */\n+    U64(0xAD4AB711, 0x2EB3929D), U64(0x86C16C98, 0xD2C953C6), /* ~= 10^-126 */\n+    U64(0xD89D64D5, 0x7A607744), U64(0xE871C7BF, 0x077BA8B7), /* ~= 10^-125 */\n+    U64(0x87625F05, 0x6C7C4A8B), U64(0x11471CD7, 0x64AD4972), /* ~= 10^-124 */\n+    U64(0xA93AF6C6, 0xC79B5D2D), U64(0xD598E40D, 0x3DD89BCF), /* ~= 10^-123 */\n+    U64(0xD389B478, 0x79823479), U64(0x4AFF1D10, 0x8D4EC2C3), /* ~= 10^-122 */\n+    U64(0x843610CB, 0x4BF160CB), U64(0xCEDF722A, 0x585139BA), /* ~= 10^-121 */\n+    U64(0xA54394FE, 0x1EEDB8FE), U64(0xC2974EB4, 0xEE658828), /* ~= 10^-120 */\n+    U64(0xCE947A3D, 0xA6A9273E), U64(0x733D2262, 0x29FEEA32), /* ~= 10^-119 */\n+    U64(0x811CCC66, 0x8829B887), U64(0x0806357D, 0x5A3F525F), /* ~= 10^-118 */\n+    U64(0xA163FF80, 0x2A3426A8), U64(0xCA07C2DC, 0xB0CF26F7), /* ~= 10^-117 */\n+    U64(0xC9BCFF60, 0x34C13052), U64(0xFC89B393, 0xDD02F0B5), /* ~= 10^-116 */\n+    U64(0xFC2C3F38, 0x41F17C67), U64(0xBBAC2078, 0xD443ACE2), /* ~= 10^-115 */\n+    U64(0x9D9BA783, 0x2936EDC0), U64(0xD54B944B, 0x84AA4C0D), /* ~= 10^-114 */\n+    U64(0xC5029163, 0xF384A931), U64(0x0A9E795E, 0x65D4DF11), /* ~= 10^-113 */\n+    U64(0xF64335BC, 0xF065D37D), U64(0x4D4617B5, 0xFF4A16D5), /* ~= 10^-112 */\n+    U64(0x99EA0196, 0x163FA42E), U64(0x504BCED1, 0xBF8E4E45), /* ~= 10^-111 */\n+    U64(0xC06481FB, 0x9BCF8D39), U64(0xE45EC286, 0x2F71E1D6), /* ~= 10^-110 */\n+    U64(0xF07DA27A, 0x82C37088), U64(0x5D767327, 0xBB4E5A4C), /* ~= 10^-109 */\n+    U64(0x964E858C, 0x91BA2655), U64(0x3A6A07F8, 0xD510F86F), /* ~= 10^-108 */\n+    U64(0xBBE226EF, 0xB628AFEA), U64(0x890489F7, 0x0A55368B), /* ~= 10^-107 */\n+    U64(0xEADAB0AB, 0xA3B2DBE5), U64(0x2B45AC74, 0xCCEA842E), /* ~= 10^-106 */\n+    U64(0x92C8AE6B, 0x464FC96F), U64(0x3B0B8BC9, 0x0012929D), /* ~= 10^-105 */\n+    U64(0xB77ADA06, 0x17E3BBCB), U64(0x09CE6EBB, 0x40173744), /* ~= 10^-104 */\n+    U64(0xE5599087, 0x9DDCAABD), U64(0xCC420A6A, 0x101D0515), /* ~= 10^-103 */\n+    U64(0x8F57FA54, 0xC2A9EAB6), U64(0x9FA94682, 0x4A12232D), /* ~= 10^-102 */\n+    U64(0xB32DF8E9, 0xF3546564), U64(0x47939822, 0xDC96ABF9), /* ~= 10^-101 */\n+    U64(0xDFF97724, 0x70297EBD), U64(0x59787E2B, 0x93BC56F7), /* ~= 10^-100 */\n+    U64(0x8BFBEA76, 0xC619EF36), U64(0x57EB4EDB, 0x3C55B65A), /* ~= 10^-99 */\n+    U64(0xAEFAE514, 0x77A06B03), U64(0xEDE62292, 0x0B6B23F1), /* ~= 10^-98 */\n+    U64(0xDAB99E59, 0x958885C4), U64(0xE95FAB36, 0x8E45ECED), /* ~= 10^-97 */\n+    U64(0x88B402F7, 0xFD75539B), U64(0x11DBCB02, 0x18EBB414), /* ~= 10^-96 */\n+    U64(0xAAE103B5, 0xFCD2A881), U64(0xD652BDC2, 0x9F26A119), /* ~= 10^-95 */\n+    U64(0xD59944A3, 0x7C0752A2), U64(0x4BE76D33, 0x46F0495F), /* ~= 10^-94 */\n+    U64(0x857FCAE6, 0x2D8493A5), U64(0x6F70A440, 0x0C562DDB), /* ~= 10^-93 */\n+    U64(0xA6DFBD9F, 0xB8E5B88E), U64(0xCB4CCD50, 0x0F6BB952), /* ~= 10^-92 */\n+    U64(0xD097AD07, 0xA71F26B2), U64(0x7E2000A4, 0x1346A7A7), /* ~= 10^-91 */\n+    U64(0x825ECC24, 0xC873782F), U64(0x8ED40066, 0x8C0C28C8), /* ~= 10^-90 */\n+    U64(0xA2F67F2D, 0xFA90563B), U64(0x72890080, 0x2F0F32FA), /* ~= 10^-89 */\n+    U64(0xCBB41EF9, 0x79346BCA), U64(0x4F2B40A0, 0x3AD2FFB9), /* ~= 10^-88 */\n+    U64(0xFEA126B7, 0xD78186BC), U64(0xE2F610C8, 0x4987BFA8), /* ~= 10^-87 */\n+    U64(0x9F24B832, 0xE6B0F436), U64(0x0DD9CA7D, 0x2DF4D7C9), /* ~= 10^-86 */\n+    U64(0xC6EDE63F, 0xA05D3143), U64(0x91503D1C, 0x79720DBB), /* ~= 10^-85 */\n+    U64(0xF8A95FCF, 0x88747D94), U64(0x75A44C63, 0x97CE912A), /* ~= 10^-84 */\n+    U64(0x9B69DBE1, 0xB548CE7C), U64(0xC986AFBE, 0x3EE11ABA), /* ~= 10^-83 */\n+    U64(0xC24452DA, 0x229B021B), U64(0xFBE85BAD, 0xCE996168), /* ~= 10^-82 */\n+    U64(0xF2D56790, 0xAB41C2A2), U64(0xFAE27299, 0x423FB9C3), /* ~= 10^-81 */\n+    U64(0x97C560BA, 0x6B0919A5), U64(0xDCCD879F, 0xC967D41A), /* ~= 10^-80 */\n+    U64(0xBDB6B8E9, 0x05CB600F), U64(0x5400E987, 0xBBC1C920), /* ~= 10^-79 */\n+    U64(0xED246723, 0x473E3813), U64(0x290123E9, 0xAAB23B68), /* ~= 10^-78 */\n+    U64(0x9436C076, 0x0C86E30B), U64(0xF9A0B672, 0x0AAF6521), /* ~= 10^-77 */\n+    U64(0xB9447093, 0x8FA89BCE), U64(0xF808E40E, 0x8D5B3E69), /* ~= 10^-76 */\n+    U64(0xE7958CB8, 0x7392C2C2), U64(0xB60B1D12, 0x30B20E04), /* ~= 10^-75 */\n+    U64(0x90BD77F3, 0x483BB9B9), U64(0xB1C6F22B, 0x5E6F48C2), /* ~= 10^-74 */\n+    U64(0xB4ECD5F0, 0x1A4AA828), U64(0x1E38AEB6, 0x360B1AF3), /* ~= 10^-73 */\n+    U64(0xE2280B6C, 0x20DD5232), U64(0x25C6DA63, 0xC38DE1B0), /* ~= 10^-72 */\n+    U64(0x8D590723, 0x948A535F), U64(0x579C487E, 0x5A38AD0E), /* ~= 10^-71 */\n+    U64(0xB0AF48EC, 0x79ACE837), U64(0x2D835A9D, 0xF0C6D851), /* ~= 10^-70 */\n+    U64(0xDCDB1B27, 0x98182244), U64(0xF8E43145, 0x6CF88E65), /* ~= 10^-69 */\n+    U64(0x8A08F0F8, 0xBF0F156B), U64(0x1B8E9ECB, 0x641B58FF), /* ~= 10^-68 */\n+    U64(0xAC8B2D36, 0xEED2DAC5), U64(0xE272467E, 0x3D222F3F), /* ~= 10^-67 */\n+    U64(0xD7ADF884, 0xAA879177), U64(0x5B0ED81D, 0xCC6ABB0F), /* ~= 10^-66 */\n+    U64(0x86CCBB52, 0xEA94BAEA), U64(0x98E94712, 0x9FC2B4E9), /* ~= 10^-65 */\n+    U64(0xA87FEA27, 0xA539E9A5), U64(0x3F2398D7, 0x47B36224), /* ~= 10^-64 */\n+    U64(0xD29FE4B1, 0x8E88640E), U64(0x8EEC7F0D, 0x19A03AAD), /* ~= 10^-63 */\n+    U64(0x83A3EEEE, 0xF9153E89), U64(0x1953CF68, 0x300424AC), /* ~= 10^-62 */\n+    U64(0xA48CEAAA, 0xB75A8E2B), U64(0x5FA8C342, 0x3C052DD7), /* ~= 10^-61 */\n+    U64(0xCDB02555, 0x653131B6), U64(0x3792F412, 0xCB06794D), /* ~= 10^-60 */\n+    U64(0x808E1755, 0x5F3EBF11), U64(0xE2BBD88B, 0xBEE40BD0), /* ~= 10^-59 */\n+    U64(0xA0B19D2A, 0xB70E6ED6), U64(0x5B6ACEAE, 0xAE9D0EC4), /* ~= 10^-58 */\n+    U64(0xC8DE0475, 0x64D20A8B), U64(0xF245825A, 0x5A445275), /* ~= 10^-57 */\n+    U64(0xFB158592, 0xBE068D2E), U64(0xEED6E2F0, 0xF0D56712), /* ~= 10^-56 */\n+    U64(0x9CED737B, 0xB6C4183D), U64(0x55464DD6, 0x9685606B), /* ~= 10^-55 */\n+    U64(0xC428D05A, 0xA4751E4C), U64(0xAA97E14C, 0x3C26B886), /* ~= 10^-54 */\n+    U64(0xF5330471, 0x4D9265DF), U64(0xD53DD99F, 0x4B3066A8), /* ~= 10^-53 */\n+    U64(0x993FE2C6, 0xD07B7FAB), U64(0xE546A803, 0x8EFE4029), /* ~= 10^-52 */\n+    U64(0xBF8FDB78, 0x849A5F96), U64(0xDE985204, 0x72BDD033), /* ~= 10^-51 */\n+    U64(0xEF73D256, 0xA5C0F77C), U64(0x963E6685, 0x8F6D4440), /* ~= 10^-50 */\n+    U64(0x95A86376, 0x27989AAD), U64(0xDDE70013, 0x79A44AA8), /* ~= 10^-49 */\n+    U64(0xBB127C53, 0xB17EC159), U64(0x5560C018, 0x580D5D52), /* ~= 10^-48 */\n+    U64(0xE9D71B68, 0x9DDE71AF), U64(0xAAB8F01E, 0x6E10B4A6), /* ~= 10^-47 */\n+    U64(0x92267121, 0x62AB070D), U64(0xCAB39613, 0x04CA70E8), /* ~= 10^-46 */\n+    U64(0xB6B00D69, 0xBB55C8D1), U64(0x3D607B97, 0xC5FD0D22), /* ~= 10^-45 */\n+    U64(0xE45C10C4, 0x2A2B3B05), U64(0x8CB89A7D, 0xB77C506A), /* ~= 10^-44 */\n+    U64(0x8EB98A7A, 0x9A5B04E3), U64(0x77F3608E, 0x92ADB242), /* ~= 10^-43 */\n+    U64(0xB267ED19, 0x40F1C61C), U64(0x55F038B2, 0x37591ED3), /* ~= 10^-42 */\n+    U64(0xDF01E85F, 0x912E37A3), U64(0x6B6C46DE, 0xC52F6688), /* ~= 10^-41 */\n+    U64(0x8B61313B, 0xBABCE2C6), U64(0x2323AC4B, 0x3B3DA015), /* ~= 10^-40 */\n+    U64(0xAE397D8A, 0xA96C1B77), U64(0xABEC975E, 0x0A0D081A), /* ~= 10^-39 */\n+    U64(0xD9C7DCED, 0x53C72255), U64(0x96E7BD35, 0x8C904A21), /* ~= 10^-38 */\n+    U64(0x881CEA14, 0x545C7575), U64(0x7E50D641, 0x77DA2E54), /* ~= 10^-37 */\n+    U64(0xAA242499, 0x697392D2), U64(0xDDE50BD1, 0xD5D0B9E9), /* ~= 10^-36 */\n+    U64(0xD4AD2DBF, 0xC3D07787), U64(0x955E4EC6, 0x4B44E864), /* ~= 10^-35 */\n+    U64(0x84EC3C97, 0xDA624AB4), U64(0xBD5AF13B, 0xEF0B113E), /* ~= 10^-34 */\n+    U64(0xA6274BBD, 0xD0FADD61), U64(0xECB1AD8A, 0xEACDD58E), /* ~= 10^-33 */\n+    U64(0xCFB11EAD, 0x453994BA), U64(0x67DE18ED, 0xA5814AF2), /* ~= 10^-32 */\n+    U64(0x81CEB32C, 0x4B43FCF4), U64(0x80EACF94, 0x8770CED7), /* ~= 10^-31 */\n+    U64(0xA2425FF7, 0x5E14FC31), U64(0xA1258379, 0xA94D028D), /* ~= 10^-30 */\n+    U64(0xCAD2F7F5, 0x359A3B3E), U64(0x096EE458, 0x13A04330), /* ~= 10^-29 */\n+    U64(0xFD87B5F2, 0x8300CA0D), U64(0x8BCA9D6E, 0x188853FC), /* ~= 10^-28 */\n+    U64(0x9E74D1B7, 0x91E07E48), U64(0x775EA264, 0xCF55347D), /* ~= 10^-27 */\n+    U64(0xC6120625, 0x76589DDA), U64(0x95364AFE, 0x032A819D), /* ~= 10^-26 */\n+    U64(0xF79687AE, 0xD3EEC551), U64(0x3A83DDBD, 0x83F52204), /* ~= 10^-25 */\n+    U64(0x9ABE14CD, 0x44753B52), U64(0xC4926A96, 0x72793542), /* ~= 10^-24 */\n+    U64(0xC16D9A00, 0x95928A27), U64(0x75B7053C, 0x0F178293), /* ~= 10^-23 */\n+    U64(0xF1C90080, 0xBAF72CB1), U64(0x5324C68B, 0x12DD6338), /* ~= 10^-22 */\n+    U64(0x971DA050, 0x74DA7BEE), U64(0xD3F6FC16, 0xEBCA5E03), /* ~= 10^-21 */\n+    U64(0xBCE50864, 0x92111AEA), U64(0x88F4BB1C, 0xA6BCF584), /* ~= 10^-20 */\n+    U64(0xEC1E4A7D, 0xB69561A5), U64(0x2B31E9E3, 0xD06C32E5), /* ~= 10^-19 */\n+    U64(0x9392EE8E, 0x921D5D07), U64(0x3AFF322E, 0x62439FCF), /* ~= 10^-18 */\n+    U64(0xB877AA32, 0x36A4B449), U64(0x09BEFEB9, 0xFAD487C2), /* ~= 10^-17 */\n+    U64(0xE69594BE, 0xC44DE15B), U64(0x4C2EBE68, 0x7989A9B3), /* ~= 10^-16 */\n+    U64(0x901D7CF7, 0x3AB0ACD9), U64(0x0F9D3701, 0x4BF60A10), /* ~= 10^-15 */\n+    U64(0xB424DC35, 0x095CD80F), U64(0x538484C1, 0x9EF38C94), /* ~= 10^-14 */\n+    U64(0xE12E1342, 0x4BB40E13), U64(0x2865A5F2, 0x06B06FB9), /* ~= 10^-13 */\n+    U64(0x8CBCCC09, 0x6F5088CB), U64(0xF93F87B7, 0x442E45D3), /* ~= 10^-12 */\n+    U64(0xAFEBFF0B, 0xCB24AAFE), U64(0xF78F69A5, 0x1539D748), /* ~= 10^-11 */\n+    U64(0xDBE6FECE, 0xBDEDD5BE), U64(0xB573440E, 0x5A884D1B), /* ~= 10^-10 */\n+    U64(0x89705F41, 0x36B4A597), U64(0x31680A88, 0xF8953030), /* ~= 10^-9 */\n+    U64(0xABCC7711, 0x8461CEFC), U64(0xFDC20D2B, 0x36BA7C3D), /* ~= 10^-8 */\n+    U64(0xD6BF94D5, 0xE57A42BC), U64(0x3D329076, 0x04691B4C), /* ~= 10^-7 */\n+    U64(0x8637BD05, 0xAF6C69B5), U64(0xA63F9A49, 0xC2C1B10F), /* ~= 10^-6 */\n+    U64(0xA7C5AC47, 0x1B478423), U64(0x0FCF80DC, 0x33721D53), /* ~= 10^-5 */\n+    U64(0xD1B71758, 0xE219652B), U64(0xD3C36113, 0x404EA4A8), /* ~= 10^-4 */\n+    U64(0x83126E97, 0x8D4FDF3B), U64(0x645A1CAC, 0x083126E9), /* ~= 10^-3 */\n+    U64(0xA3D70A3D, 0x70A3D70A), U64(0x3D70A3D7, 0x0A3D70A3), /* ~= 10^-2 */\n+    U64(0xCCCCCCCC, 0xCCCCCCCC), U64(0xCCCCCCCC, 0xCCCCCCCC), /* ~= 10^-1 */\n+    U64(0x80000000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^0 */\n+    U64(0xA0000000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^1 */\n+    U64(0xC8000000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^2 */\n+    U64(0xFA000000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^3 */\n+    U64(0x9C400000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^4 */\n+    U64(0xC3500000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^5 */\n+    U64(0xF4240000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^6 */\n+    U64(0x98968000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^7 */\n+    U64(0xBEBC2000, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^8 */\n+    U64(0xEE6B2800, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^9 */\n+    U64(0x9502F900, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^10 */\n+    U64(0xBA43B740, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^11 */\n+    U64(0xE8D4A510, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^12 */\n+    U64(0x9184E72A, 0x00000000), U64(0x00000000, 0x00000000), /* == 10^13 */\n+    U64(0xB5E620F4, 0x80000000), U64(0x00000000, 0x00000000), /* == 10^14 */\n+    U64(0xE35FA931, 0xA0000000), U64(0x00000000, 0x00000000), /* == 10^15 */\n+    U64(0x8E1BC9BF, 0x04000000), U64(0x00000000, 0x00000000), /* == 10^16 */\n+    U64(0xB1A2BC2E, 0xC5000000), U64(0x00000000, 0x00000000), /* == 10^17 */\n+    U64(0xDE0B6B3A, 0x76400000), U64(0x00000000, 0x00000000), /* == 10^18 */\n+    U64(0x8AC72304, 0x89E80000), U64(0x00000000, 0x00000000), /* == 10^19 */\n+    U64(0xAD78EBC5, 0xAC620000), U64(0x00000000, 0x00000000), /* == 10^20 */\n+    U64(0xD8D726B7, 0x177A8000), U64(0x00000000, 0x00000000), /* == 10^21 */\n+    U64(0x87867832, 0x6EAC9000), U64(0x00000000, 0x00000000), /* == 10^22 */\n+    U64(0xA968163F, 0x0A57B400), U64(0x00000000, 0x00000000), /* == 10^23 */\n+    U64(0xD3C21BCE, 0xCCEDA100), U64(0x00000000, 0x00000000), /* == 10^24 */\n+    U64(0x84595161, 0x401484A0), U64(0x00000000, 0x00000000), /* == 10^25 */\n+    U64(0xA56FA5B9, 0x9019A5C8), U64(0x00000000, 0x00000000), /* == 10^26 */\n+    U64(0xCECB8F27, 0xF4200F3A), U64(0x00000000, 0x00000000), /* == 10^27 */\n+    U64(0x813F3978, 0xF8940984), U64(0x40000000, 0x00000000), /* == 10^28 */\n+    U64(0xA18F07D7, 0x36B90BE5), U64(0x50000000, 0x00000000), /* == 10^29 */\n+    U64(0xC9F2C9CD, 0x04674EDE), U64(0xA4000000, 0x00000000), /* == 10^30 */\n+    U64(0xFC6F7C40, 0x45812296), U64(0x4D000000, 0x00000000), /* == 10^31 */\n+    U64(0x9DC5ADA8, 0x2B70B59D), U64(0xF0200000, 0x00000000), /* == 10^32 */\n+    U64(0xC5371912, 0x364CE305), U64(0x6C280000, 0x00000000), /* == 10^33 */\n+    U64(0xF684DF56, 0xC3E01BC6), U64(0xC7320000, 0x00000000), /* == 10^34 */\n+    U64(0x9A130B96, 0x3A6C115C), U64(0x3C7F4000, 0x00000000), /* == 10^35 */\n+    U64(0xC097CE7B, 0xC90715B3), U64(0x4B9F1000, 0x00000000), /* == 10^36 */\n+    U64(0xF0BDC21A, 0xBB48DB20), U64(0x1E86D400, 0x00000000), /* == 10^37 */\n+    U64(0x96769950, 0xB50D88F4), U64(0x13144480, 0x00000000), /* == 10^38 */\n+    U64(0xBC143FA4, 0xE250EB31), U64(0x17D955A0, 0x00000000), /* == 10^39 */\n+    U64(0xEB194F8E, 0x1AE525FD), U64(0x5DCFAB08, 0x00000000), /* == 10^40 */\n+    U64(0x92EFD1B8, 0xD0CF37BE), U64(0x5AA1CAE5, 0x00000000), /* == 10^41 */\n+    U64(0xB7ABC627, 0x050305AD), U64(0xF14A3D9E, 0x40000000), /* == 10^42 */\n+    U64(0xE596B7B0, 0xC643C719), U64(0x6D9CCD05, 0xD0000000), /* == 10^43 */\n+    U64(0x8F7E32CE, 0x7BEA5C6F), U64(0xE4820023, 0xA2000000), /* == 10^44 */\n+    U64(0xB35DBF82, 0x1AE4F38B), U64(0xDDA2802C, 0x8A800000), /* == 10^45 */\n+    U64(0xE0352F62, 0xA19E306E), U64(0xD50B2037, 0xAD200000), /* == 10^46 */\n+    U64(0x8C213D9D, 0xA502DE45), U64(0x4526F422, 0xCC340000), /* == 10^47 */\n+    U64(0xAF298D05, 0x0E4395D6), U64(0x9670B12B, 0x7F410000), /* == 10^48 */\n+    U64(0xDAF3F046, 0x51D47B4C), U64(0x3C0CDD76, 0x5F114000), /* == 10^49 */\n+    U64(0x88D8762B, 0xF324CD0F), U64(0xA5880A69, 0xFB6AC800), /* == 10^50 */\n+    U64(0xAB0E93B6, 0xEFEE0053), U64(0x8EEA0D04, 0x7A457A00), /* == 10^51 */\n+    U64(0xD5D238A4, 0xABE98068), U64(0x72A49045, 0x98D6D880), /* == 10^52 */\n+    U64(0x85A36366, 0xEB71F041), U64(0x47A6DA2B, 0x7F864750), /* == 10^53 */\n+    U64(0xA70C3C40, 0xA64E6C51), U64(0x999090B6, 0x5F67D924), /* == 10^54 */\n+    U64(0xD0CF4B50, 0xCFE20765), U64(0xFFF4B4E3, 0xF741CF6D), /* == 10^55 */\n+    U64(0x82818F12, 0x81ED449F), U64(0xBFF8F10E, 0x7A8921A4), /* ~= 10^56 */\n+    U64(0xA321F2D7, 0x226895C7), U64(0xAFF72D52, 0x192B6A0D), /* ~= 10^57 */\n+    U64(0xCBEA6F8C, 0xEB02BB39), U64(0x9BF4F8A6, 0x9F764490), /* ~= 10^58 */\n+    U64(0xFEE50B70, 0x25C36A08), U64(0x02F236D0, 0x4753D5B4), /* ~= 10^59 */\n+    U64(0x9F4F2726, 0x179A2245), U64(0x01D76242, 0x2C946590), /* ~= 10^60 */\n+    U64(0xC722F0EF, 0x9D80AAD6), U64(0x424D3AD2, 0xB7B97EF5), /* ~= 10^61 */\n+    U64(0xF8EBAD2B, 0x84E0D58B), U64(0xD2E08987, 0x65A7DEB2), /* ~= 10^62 */\n+    U64(0x9B934C3B, 0x330C8577), U64(0x63CC55F4, 0x9F88EB2F), /* ~= 10^63 */\n+    U64(0xC2781F49, 0xFFCFA6D5), U64(0x3CBF6B71, 0xC76B25FB), /* ~= 10^64 */\n+    U64(0xF316271C, 0x7FC3908A), U64(0x8BEF464E, 0x3945EF7A), /* ~= 10^65 */\n+    U64(0x97EDD871, 0xCFDA3A56), U64(0x97758BF0, 0xE3CBB5AC), /* ~= 10^66 */\n+    U64(0xBDE94E8E, 0x43D0C8EC), U64(0x3D52EEED, 0x1CBEA317), /* ~= 10^67 */\n+    U64(0xED63A231, 0xD4C4FB27), U64(0x4CA7AAA8, 0x63EE4BDD), /* ~= 10^68 */\n+    U64(0x945E455F, 0x24FB1CF8), U64(0x8FE8CAA9, 0x3E74EF6A), /* ~= 10^69 */\n+    U64(0xB975D6B6, 0xEE39E436), U64(0xB3E2FD53, 0x8E122B44), /* ~= 10^70 */\n+    U64(0xE7D34C64, 0xA9C85D44), U64(0x60DBBCA8, 0x7196B616), /* ~= 10^71 */\n+    U64(0x90E40FBE, 0xEA1D3A4A), U64(0xBC8955E9, 0x46FE31CD), /* ~= 10^72 */\n+    U64(0xB51D13AE, 0xA4A488DD), U64(0x6BABAB63, 0x98BDBE41), /* ~= 10^73 */\n+    U64(0xE264589A, 0x4DCDAB14), U64(0xC696963C, 0x7EED2DD1), /* ~= 10^74 */\n+    U64(0x8D7EB760, 0x70A08AEC), U64(0xFC1E1DE5, 0xCF543CA2), /* ~= 10^75 */\n+    U64(0xB0DE6538, 0x8CC8ADA8), U64(0x3B25A55F, 0x43294BCB), /* ~= 10^76 */\n+    U64(0xDD15FE86, 0xAFFAD912), U64(0x49EF0EB7, 0x13F39EBE), /* ~= 10^77 */\n+    U64(0x8A2DBF14, 0x2DFCC7AB), U64(0x6E356932, 0x6C784337), /* ~= 10^78 */\n+    U64(0xACB92ED9, 0x397BF996), U64(0x49C2C37F, 0x07965404), /* ~= 10^79 */\n+    U64(0xD7E77A8F, 0x87DAF7FB), U64(0xDC33745E, 0xC97BE906), /* ~= 10^80 */\n+    U64(0x86F0AC99, 0xB4E8DAFD), U64(0x69A028BB, 0x3DED71A3), /* ~= 10^81 */\n+    U64(0xA8ACD7C0, 0x222311BC), U64(0xC40832EA, 0x0D68CE0C), /* ~= 10^82 */\n+    U64(0xD2D80DB0, 0x2AABD62B), U64(0xF50A3FA4, 0x90C30190), /* ~= 10^83 */\n+    U64(0x83C7088E, 0x1AAB65DB), U64(0x792667C6, 0xDA79E0FA), /* ~= 10^84 */\n+    U64(0xA4B8CAB1, 0xA1563F52), U64(0x577001B8, 0x91185938), /* ~= 10^85 */\n+    U64(0xCDE6FD5E, 0x09ABCF26), U64(0xED4C0226, 0xB55E6F86), /* ~= 10^86 */\n+    U64(0x80B05E5A, 0xC60B6178), U64(0x544F8158, 0x315B05B4), /* ~= 10^87 */\n+    U64(0xA0DC75F1, 0x778E39D6), U64(0x696361AE, 0x3DB1C721), /* ~= 10^88 */\n+    U64(0xC913936D, 0xD571C84C), U64(0x03BC3A19, 0xCD1E38E9), /* ~= 10^89 */\n+    U64(0xFB587849, 0x4ACE3A5F), U64(0x04AB48A0, 0x4065C723), /* ~= 10^90 */\n+    U64(0x9D174B2D, 0xCEC0E47B), U64(0x62EB0D64, 0x283F9C76), /* ~= 10^91 */\n+    U64(0xC45D1DF9, 0x42711D9A), U64(0x3BA5D0BD, 0x324F8394), /* ~= 10^92 */\n+    U64(0xF5746577, 0x930D6500), U64(0xCA8F44EC, 0x7EE36479), /* ~= 10^93 */\n+    U64(0x9968BF6A, 0xBBE85F20), U64(0x7E998B13, 0xCF4E1ECB), /* ~= 10^94 */\n+    U64(0xBFC2EF45, 0x6AE276E8), U64(0x9E3FEDD8, 0xC321A67E), /* ~= 10^95 */\n+    U64(0xEFB3AB16, 0xC59B14A2), U64(0xC5CFE94E, 0xF3EA101E), /* ~= 10^96 */\n+    U64(0x95D04AEE, 0x3B80ECE5), U64(0xBBA1F1D1, 0x58724A12), /* ~= 10^97 */\n+    U64(0xBB445DA9, 0xCA61281F), U64(0x2A8A6E45, 0xAE8EDC97), /* ~= 10^98 */\n+    U64(0xEA157514, 0x3CF97226), U64(0xF52D09D7, 0x1A3293BD), /* ~= 10^99 */\n+    U64(0x924D692C, 0xA61BE758), U64(0x593C2626, 0x705F9C56), /* ~= 10^100 */\n+    U64(0xB6E0C377, 0xCFA2E12E), U64(0x6F8B2FB0, 0x0C77836C), /* ~= 10^101 */\n+    U64(0xE498F455, 0xC38B997A), U64(0x0B6DFB9C, 0x0F956447), /* ~= 10^102 */\n+    U64(0x8EDF98B5, 0x9A373FEC), U64(0x4724BD41, 0x89BD5EAC), /* ~= 10^103 */\n+    U64(0xB2977EE3, 0x00C50FE7), U64(0x58EDEC91, 0xEC2CB657), /* ~= 10^104 */\n+    U64(0xDF3D5E9B, 0xC0F653E1), U64(0x2F2967B6, 0x6737E3ED), /* ~= 10^105 */\n+    U64(0x8B865B21, 0x5899F46C), U64(0xBD79E0D2, 0x0082EE74), /* ~= 10^106 */\n+    U64(0xAE67F1E9, 0xAEC07187), U64(0xECD85906, 0x80A3AA11), /* ~= 10^107 */\n+    U64(0xDA01EE64, 0x1A708DE9), U64(0xE80E6F48, 0x20CC9495), /* ~= 10^108 */\n+    U64(0x884134FE, 0x908658B2), U64(0x3109058D, 0x147FDCDD), /* ~= 10^109 */\n+    U64(0xAA51823E, 0x34A7EEDE), U64(0xBD4B46F0, 0x599FD415), /* ~= 10^110 */\n+    U64(0xD4E5E2CD, 0xC1D1EA96), U64(0x6C9E18AC, 0x7007C91A), /* ~= 10^111 */\n+    U64(0x850FADC0, 0x9923329E), U64(0x03E2CF6B, 0xC604DDB0), /* ~= 10^112 */\n+    U64(0xA6539930, 0xBF6BFF45), U64(0x84DB8346, 0xB786151C), /* ~= 10^113 */\n+    U64(0xCFE87F7C, 0xEF46FF16), U64(0xE6126418, 0x65679A63), /* ~= 10^114 */\n+    U64(0x81F14FAE, 0x158C5F6E), U64(0x4FCB7E8F, 0x3F60C07E), /* ~= 10^115 */\n+    U64(0xA26DA399, 0x9AEF7749), U64(0xE3BE5E33, 0x0F38F09D), /* ~= 10^116 */\n+    U64(0xCB090C80, 0x01AB551C), U64(0x5CADF5BF, 0xD3072CC5), /* ~= 10^117 */\n+    U64(0xFDCB4FA0, 0x02162A63), U64(0x73D9732F, 0xC7C8F7F6), /* ~= 10^118 */\n+    U64(0x9E9F11C4, 0x014DDA7E), U64(0x2867E7FD, 0xDCDD9AFA), /* ~= 10^119 */\n+    U64(0xC646D635, 0x01A1511D), U64(0xB281E1FD, 0x541501B8), /* ~= 10^120 */\n+    U64(0xF7D88BC2, 0x4209A565), U64(0x1F225A7C, 0xA91A4226), /* ~= 10^121 */\n+    U64(0x9AE75759, 0x6946075F), U64(0x3375788D, 0xE9B06958), /* ~= 10^122 */\n+    U64(0xC1A12D2F, 0xC3978937), U64(0x0052D6B1, 0x641C83AE), /* ~= 10^123 */\n+    U64(0xF209787B, 0xB47D6B84), U64(0xC0678C5D, 0xBD23A49A), /* ~= 10^124 */\n+    U64(0x9745EB4D, 0x50CE6332), U64(0xF840B7BA, 0x963646E0), /* ~= 10^125 */\n+    U64(0xBD176620, 0xA501FBFF), U64(0xB650E5A9, 0x3BC3D898), /* ~= 10^126 */\n+    U64(0xEC5D3FA8, 0xCE427AFF), U64(0xA3E51F13, 0x8AB4CEBE), /* ~= 10^127 */\n+    U64(0x93BA47C9, 0x80E98CDF), U64(0xC66F336C, 0x36B10137), /* ~= 10^128 */\n+    U64(0xB8A8D9BB, 0xE123F017), U64(0xB80B0047, 0x445D4184), /* ~= 10^129 */\n+    U64(0xE6D3102A, 0xD96CEC1D), U64(0xA60DC059, 0x157491E5), /* ~= 10^130 */\n+    U64(0x9043EA1A, 0xC7E41392), U64(0x87C89837, 0xAD68DB2F), /* ~= 10^131 */\n+    U64(0xB454E4A1, 0x79DD1877), U64(0x29BABE45, 0x98C311FB), /* ~= 10^132 */\n+    U64(0xE16A1DC9, 0xD8545E94), U64(0xF4296DD6, 0xFEF3D67A), /* ~= 10^133 */\n+    U64(0x8CE2529E, 0x2734BB1D), U64(0x1899E4A6, 0x5F58660C), /* ~= 10^134 */\n+    U64(0xB01AE745, 0xB101E9E4), U64(0x5EC05DCF, 0xF72E7F8F), /* ~= 10^135 */\n+    U64(0xDC21A117, 0x1D42645D), U64(0x76707543, 0xF4FA1F73), /* ~= 10^136 */\n+    U64(0x899504AE, 0x72497EBA), U64(0x6A06494A, 0x791C53A8), /* ~= 10^137 */\n+    U64(0xABFA45DA, 0x0EDBDE69), U64(0x0487DB9D, 0x17636892), /* ~= 10^138 */\n+    U64(0xD6F8D750, 0x9292D603), U64(0x45A9D284, 0x5D3C42B6), /* ~= 10^139 */\n+    U64(0x865B8692, 0x5B9BC5C2), U64(0x0B8A2392, 0xBA45A9B2), /* ~= 10^140 */\n+    U64(0xA7F26836, 0xF282B732), U64(0x8E6CAC77, 0x68D7141E), /* ~= 10^141 */\n+    U64(0xD1EF0244, 0xAF2364FF), U64(0x3207D795, 0x430CD926), /* ~= 10^142 */\n+    U64(0x8335616A, 0xED761F1F), U64(0x7F44E6BD, 0x49E807B8), /* ~= 10^143 */\n+    U64(0xA402B9C5, 0xA8D3A6E7), U64(0x5F16206C, 0x9C6209A6), /* ~= 10^144 */\n+    U64(0xCD036837, 0x130890A1), U64(0x36DBA887, 0xC37A8C0F), /* ~= 10^145 */\n+    U64(0x80222122, 0x6BE55A64), U64(0xC2494954, 0xDA2C9789), /* ~= 10^146 */\n+    U64(0xA02AA96B, 0x06DEB0FD), U64(0xF2DB9BAA, 0x10B7BD6C), /* ~= 10^147 */\n+    U64(0xC83553C5, 0xC8965D3D), U64(0x6F928294, 0x94E5ACC7), /* ~= 10^148 */\n+    U64(0xFA42A8B7, 0x3ABBF48C), U64(0xCB772339, 0xBA1F17F9), /* ~= 10^149 */\n+    U64(0x9C69A972, 0x84B578D7), U64(0xFF2A7604, 0x14536EFB), /* ~= 10^150 */\n+    U64(0xC38413CF, 0x25E2D70D), U64(0xFEF51385, 0x19684ABA), /* ~= 10^151 */\n+    U64(0xF46518C2, 0xEF5B8CD1), U64(0x7EB25866, 0x5FC25D69), /* ~= 10^152 */\n+    U64(0x98BF2F79, 0xD5993802), U64(0xEF2F773F, 0xFBD97A61), /* ~= 10^153 */\n+    U64(0xBEEEFB58, 0x4AFF8603), U64(0xAAFB550F, 0xFACFD8FA), /* ~= 10^154 */\n+    U64(0xEEAABA2E, 0x5DBF6784), U64(0x95BA2A53, 0xF983CF38), /* ~= 10^155 */\n+    U64(0x952AB45C, 0xFA97A0B2), U64(0xDD945A74, 0x7BF26183), /* ~= 10^156 */\n+    U64(0xBA756174, 0x393D88DF), U64(0x94F97111, 0x9AEEF9E4), /* ~= 10^157 */\n+    U64(0xE912B9D1, 0x478CEB17), U64(0x7A37CD56, 0x01AAB85D), /* ~= 10^158 */\n+    U64(0x91ABB422, 0xCCB812EE), U64(0xAC62E055, 0xC10AB33A), /* ~= 10^159 */\n+    U64(0xB616A12B, 0x7FE617AA), U64(0x577B986B, 0x314D6009), /* ~= 10^160 */\n+    U64(0xE39C4976, 0x5FDF9D94), U64(0xED5A7E85, 0xFDA0B80B), /* ~= 10^161 */\n+    U64(0x8E41ADE9, 0xFBEBC27D), U64(0x14588F13, 0xBE847307), /* ~= 10^162 */\n+    U64(0xB1D21964, 0x7AE6B31C), U64(0x596EB2D8, 0xAE258FC8), /* ~= 10^163 */\n+    U64(0xDE469FBD, 0x99A05FE3), U64(0x6FCA5F8E, 0xD9AEF3BB), /* ~= 10^164 */\n+    U64(0x8AEC23D6, 0x80043BEE), U64(0x25DE7BB9, 0x480D5854), /* ~= 10^165 */\n+    U64(0xADA72CCC, 0x20054AE9), U64(0xAF561AA7, 0x9A10AE6A), /* ~= 10^166 */\n+    U64(0xD910F7FF, 0x28069DA4), U64(0x1B2BA151, 0x8094DA04), /* ~= 10^167 */\n+    U64(0x87AA9AFF, 0x79042286), U64(0x90FB44D2, 0xF05D0842), /* ~= 10^168 */\n+    U64(0xA99541BF, 0x57452B28), U64(0x353A1607, 0xAC744A53), /* ~= 10^169 */\n+    U64(0xD3FA922F, 0x2D1675F2), U64(0x42889B89, 0x97915CE8), /* ~= 10^170 */\n+    U64(0x847C9B5D, 0x7C2E09B7), U64(0x69956135, 0xFEBADA11), /* ~= 10^171 */\n+    U64(0xA59BC234, 0xDB398C25), U64(0x43FAB983, 0x7E699095), /* ~= 10^172 */\n+    U64(0xCF02B2C2, 0x1207EF2E), U64(0x94F967E4, 0x5E03F4BB), /* ~= 10^173 */\n+    U64(0x8161AFB9, 0x4B44F57D), U64(0x1D1BE0EE, 0xBAC278F5), /* ~= 10^174 */\n+    U64(0xA1BA1BA7, 0x9E1632DC), U64(0x6462D92A, 0x69731732), /* ~= 10^175 */\n+    U64(0xCA28A291, 0x859BBF93), U64(0x7D7B8F75, 0x03CFDCFE), /* ~= 10^176 */\n+    U64(0xFCB2CB35, 0xE702AF78), U64(0x5CDA7352, 0x44C3D43E), /* ~= 10^177 */\n+    U64(0x9DEFBF01, 0xB061ADAB), U64(0x3A088813, 0x6AFA64A7), /* ~= 10^178 */\n+    U64(0xC56BAEC2, 0x1C7A1916), U64(0x088AAA18, 0x45B8FDD0), /* ~= 10^179 */\n+    U64(0xF6C69A72, 0xA3989F5B), U64(0x8AAD549E, 0x57273D45), /* ~= 10^180 */\n+    U64(0x9A3C2087, 0xA63F6399), U64(0x36AC54E2, 0xF678864B), /* ~= 10^181 */\n+    U64(0xC0CB28A9, 0x8FCF3C7F), U64(0x84576A1B, 0xB416A7DD), /* ~= 10^182 */\n+    U64(0xF0FDF2D3, 0xF3C30B9F), U64(0x656D44A2, 0xA11C51D5), /* ~= 10^183 */\n+    U64(0x969EB7C4, 0x7859E743), U64(0x9F644AE5, 0xA4B1B325), /* ~= 10^184 */\n+    U64(0xBC4665B5, 0x96706114), U64(0x873D5D9F, 0x0DDE1FEE), /* ~= 10^185 */\n+    U64(0xEB57FF22, 0xFC0C7959), U64(0xA90CB506, 0xD155A7EA), /* ~= 10^186 */\n+    U64(0x9316FF75, 0xDD87CBD8), U64(0x09A7F124, 0x42D588F2), /* ~= 10^187 */\n+    U64(0xB7DCBF53, 0x54E9BECE), U64(0x0C11ED6D, 0x538AEB2F), /* ~= 10^188 */\n+    U64(0xE5D3EF28, 0x2A242E81), U64(0x8F1668C8, 0xA86DA5FA), /* ~= 10^189 */\n+    U64(0x8FA47579, 0x1A569D10), U64(0xF96E017D, 0x694487BC), /* ~= 10^190 */\n+    U64(0xB38D92D7, 0x60EC4455), U64(0x37C981DC, 0xC395A9AC), /* ~= 10^191 */\n+    U64(0xE070F78D, 0x3927556A), U64(0x85BBE253, 0xF47B1417), /* ~= 10^192 */\n+    U64(0x8C469AB8, 0x43B89562), U64(0x93956D74, 0x78CCEC8E), /* ~= 10^193 */\n+    U64(0xAF584166, 0x54A6BABB), U64(0x387AC8D1, 0x970027B2), /* ~= 10^194 */\n+    U64(0xDB2E51BF, 0xE9D0696A), U64(0x06997B05, 0xFCC0319E), /* ~= 10^195 */\n+    U64(0x88FCF317, 0xF22241E2), U64(0x441FECE3, 0xBDF81F03), /* ~= 10^196 */\n+    U64(0xAB3C2FDD, 0xEEAAD25A), U64(0xD527E81C, 0xAD7626C3), /* ~= 10^197 */\n+    U64(0xD60B3BD5, 0x6A5586F1), U64(0x8A71E223, 0xD8D3B074), /* ~= 10^198 */\n+    U64(0x85C70565, 0x62757456), U64(0xF6872D56, 0x67844E49), /* ~= 10^199 */\n+    U64(0xA738C6BE, 0xBB12D16C), U64(0xB428F8AC, 0x016561DB), /* ~= 10^200 */\n+    U64(0xD106F86E, 0x69D785C7), U64(0xE13336D7, 0x01BEBA52), /* ~= 10^201 */\n+    U64(0x82A45B45, 0x0226B39C), U64(0xECC00246, 0x61173473), /* ~= 10^202 */\n+    U64(0xA34D7216, 0x42B06084), U64(0x27F002D7, 0xF95D0190), /* ~= 10^203 */\n+    U64(0xCC20CE9B, 0xD35C78A5), U64(0x31EC038D, 0xF7B441F4), /* ~= 10^204 */\n+    U64(0xFF290242, 0xC83396CE), U64(0x7E670471, 0x75A15271), /* ~= 10^205 */\n+    U64(0x9F79A169, 0xBD203E41), U64(0x0F0062C6, 0xE984D386), /* ~= 10^206 */\n+    U64(0xC75809C4, 0x2C684DD1), U64(0x52C07B78, 0xA3E60868), /* ~= 10^207 */\n+    U64(0xF92E0C35, 0x37826145), U64(0xA7709A56, 0xCCDF8A82), /* ~= 10^208 */\n+    U64(0x9BBCC7A1, 0x42B17CCB), U64(0x88A66076, 0x400BB691), /* ~= 10^209 */\n+    U64(0xC2ABF989, 0x935DDBFE), U64(0x6ACFF893, 0xD00EA435), /* ~= 10^210 */\n+    U64(0xF356F7EB, 0xF83552FE), U64(0x0583F6B8, 0xC4124D43), /* ~= 10^211 */\n+    U64(0x98165AF3, 0x7B2153DE), U64(0xC3727A33, 0x7A8B704A), /* ~= 10^212 */\n+    U64(0xBE1BF1B0, 0x59E9A8D6), U64(0x744F18C0, 0x592E4C5C), /* ~= 10^213 */\n+    U64(0xEDA2EE1C, 0x7064130C), U64(0x1162DEF0, 0x6F79DF73), /* ~= 10^214 */\n+    U64(0x9485D4D1, 0xC63E8BE7), U64(0x8ADDCB56, 0x45AC2BA8), /* ~= 10^215 */\n+    U64(0xB9A74A06, 0x37CE2EE1), U64(0x6D953E2B, 0xD7173692), /* ~= 10^216 */\n+    U64(0xE8111C87, 0xC5C1BA99), U64(0xC8FA8DB6, 0xCCDD0437), /* ~= 10^217 */\n+    U64(0x910AB1D4, 0xDB9914A0), U64(0x1D9C9892, 0x400A22A2), /* ~= 10^218 */\n+    U64(0xB54D5E4A, 0x127F59C8), U64(0x2503BEB6, 0xD00CAB4B), /* ~= 10^219 */\n+    U64(0xE2A0B5DC, 0x971F303A), U64(0x2E44AE64, 0x840FD61D), /* ~= 10^220 */\n+    U64(0x8DA471A9, 0xDE737E24), U64(0x5CEAECFE, 0xD289E5D2), /* ~= 10^221 */\n+    U64(0xB10D8E14, 0x56105DAD), U64(0x7425A83E, 0x872C5F47), /* ~= 10^222 */\n+    U64(0xDD50F199, 0x6B947518), U64(0xD12F124E, 0x28F77719), /* ~= 10^223 */\n+    U64(0x8A5296FF, 0xE33CC92F), U64(0x82BD6B70, 0xD99AAA6F), /* ~= 10^224 */\n+    U64(0xACE73CBF, 0xDC0BFB7B), U64(0x636CC64D, 0x1001550B), /* ~= 10^225 */\n+    U64(0xD8210BEF, 0xD30EFA5A), U64(0x3C47F7E0, 0x5401AA4E), /* ~= 10^226 */\n+    U64(0x8714A775, 0xE3E95C78), U64(0x65ACFAEC, 0x34810A71), /* ~= 10^227 */\n+    U64(0xA8D9D153, 0x5CE3B396), U64(0x7F1839A7, 0x41A14D0D), /* ~= 10^228 */\n+    U64(0xD31045A8, 0x341CA07C), U64(0x1EDE4811, 0x1209A050), /* ~= 10^229 */\n+    U64(0x83EA2B89, 0x2091E44D), U64(0x934AED0A, 0xAB460432), /* ~= 10^230 */\n+    U64(0xA4E4B66B, 0x68B65D60), U64(0xF81DA84D, 0x5617853F), /* ~= 10^231 */\n+    U64(0xCE1DE406, 0x42E3F4B9), U64(0x36251260, 0xAB9D668E), /* ~= 10^232 */\n+    U64(0x80D2AE83, 0xE9CE78F3), U64(0xC1D72B7C, 0x6B426019), /* ~= 10^233 */\n+    U64(0xA1075A24, 0xE4421730), U64(0xB24CF65B, 0x8612F81F), /* ~= 10^234 */\n+    U64(0xC94930AE, 0x1D529CFC), U64(0xDEE033F2, 0x6797B627), /* ~= 10^235 */\n+    U64(0xFB9B7CD9, 0xA4A7443C), U64(0x169840EF, 0x017DA3B1), /* ~= 10^236 */\n+    U64(0x9D412E08, 0x06E88AA5), U64(0x8E1F2895, 0x60EE864E), /* ~= 10^237 */\n+    U64(0xC491798A, 0x08A2AD4E), U64(0xF1A6F2BA, 0xB92A27E2), /* ~= 10^238 */\n+    U64(0xF5B5D7EC, 0x8ACB58A2), U64(0xAE10AF69, 0x6774B1DB), /* ~= 10^239 */\n+    U64(0x9991A6F3, 0xD6BF1765), U64(0xACCA6DA1, 0xE0A8EF29), /* ~= 10^240 */\n+    U64(0xBFF610B0, 0xCC6EDD3F), U64(0x17FD090A, 0x58D32AF3), /* ~= 10^241 */\n+    U64(0xEFF394DC, 0xFF8A948E), U64(0xDDFC4B4C, 0xEF07F5B0), /* ~= 10^242 */\n+    U64(0x95F83D0A, 0x1FB69CD9), U64(0x4ABDAF10, 0x1564F98E), /* ~= 10^243 */\n+    U64(0xBB764C4C, 0xA7A4440F), U64(0x9D6D1AD4, 0x1ABE37F1), /* ~= 10^244 */\n+    U64(0xEA53DF5F, 0xD18D5513), U64(0x84C86189, 0x216DC5ED), /* ~= 10^245 */\n+    U64(0x92746B9B, 0xE2F8552C), U64(0x32FD3CF5, 0xB4E49BB4), /* ~= 10^246 */\n+    U64(0xB7118682, 0xDBB66A77), U64(0x3FBC8C33, 0x221DC2A1), /* ~= 10^247 */\n+    U64(0xE4D5E823, 0x92A40515), U64(0x0FABAF3F, 0xEAA5334A), /* ~= 10^248 */\n+    U64(0x8F05B116, 0x3BA6832D), U64(0x29CB4D87, 0xF2A7400E), /* ~= 10^249 */\n+    U64(0xB2C71D5B, 0xCA9023F8), U64(0x743E20E9, 0xEF511012), /* ~= 10^250 */\n+    U64(0xDF78E4B2, 0xBD342CF6), U64(0x914DA924, 0x6B255416), /* ~= 10^251 */\n+    U64(0x8BAB8EEF, 0xB6409C1A), U64(0x1AD089B6, 0xC2F7548E), /* ~= 10^252 */\n+    U64(0xAE9672AB, 0xA3D0C320), U64(0xA184AC24, 0x73B529B1), /* ~= 10^253 */\n+    U64(0xDA3C0F56, 0x8CC4F3E8), U64(0xC9E5D72D, 0x90A2741E), /* ~= 10^254 */\n+    U64(0x88658996, 0x17FB1871), U64(0x7E2FA67C, 0x7A658892), /* ~= 10^255 */\n+    U64(0xAA7EEBFB, 0x9DF9DE8D), U64(0xDDBB901B, 0x98FEEAB7), /* ~= 10^256 */\n+    U64(0xD51EA6FA, 0x85785631), U64(0x552A7422, 0x7F3EA565), /* ~= 10^257 */\n+    U64(0x8533285C, 0x936B35DE), U64(0xD53A8895, 0x8F87275F), /* ~= 10^258 */\n+    U64(0xA67FF273, 0xB8460356), U64(0x8A892ABA, 0xF368F137), /* ~= 10^259 */\n+    U64(0xD01FEF10, 0xA657842C), U64(0x2D2B7569, 0xB0432D85), /* ~= 10^260 */\n+    U64(0x8213F56A, 0x67F6B29B), U64(0x9C3B2962, 0x0E29FC73), /* ~= 10^261 */\n+    U64(0xA298F2C5, 0x01F45F42), U64(0x8349F3BA, 0x91B47B8F), /* ~= 10^262 */\n+    U64(0xCB3F2F76, 0x42717713), U64(0x241C70A9, 0x36219A73), /* ~= 10^263 */\n+    U64(0xFE0EFB53, 0xD30DD4D7), U64(0xED238CD3, 0x83AA0110), /* ~= 10^264 */\n+    U64(0x9EC95D14, 0x63E8A506), U64(0xF4363804, 0x324A40AA), /* ~= 10^265 */\n+    U64(0xC67BB459, 0x7CE2CE48), U64(0xB143C605, 0x3EDCD0D5), /* ~= 10^266 */\n+    U64(0xF81AA16F, 0xDC1B81DA), U64(0xDD94B786, 0x8E94050A), /* ~= 10^267 */\n+    U64(0x9B10A4E5, 0xE9913128), U64(0xCA7CF2B4, 0x191C8326), /* ~= 10^268 */\n+    U64(0xC1D4CE1F, 0x63F57D72), U64(0xFD1C2F61, 0x1F63A3F0), /* ~= 10^269 */\n+    U64(0xF24A01A7, 0x3CF2DCCF), U64(0xBC633B39, 0x673C8CEC), /* ~= 10^270 */\n+    U64(0x976E4108, 0x8617CA01), U64(0xD5BE0503, 0xE085D813), /* ~= 10^271 */\n+    U64(0xBD49D14A, 0xA79DBC82), U64(0x4B2D8644, 0xD8A74E18), /* ~= 10^272 */\n+    U64(0xEC9C459D, 0x51852BA2), U64(0xDDF8E7D6, 0x0ED1219E), /* ~= 10^273 */\n+    U64(0x93E1AB82, 0x52F33B45), U64(0xCABB90E5, 0xC942B503), /* ~= 10^274 */\n+    U64(0xB8DA1662, 0xE7B00A17), U64(0x3D6A751F, 0x3B936243), /* ~= 10^275 */\n+    U64(0xE7109BFB, 0xA19C0C9D), U64(0x0CC51267, 0x0A783AD4), /* ~= 10^276 */\n+    U64(0x906A617D, 0x450187E2), U64(0x27FB2B80, 0x668B24C5), /* ~= 10^277 */\n+    U64(0xB484F9DC, 0x9641E9DA), U64(0xB1F9F660, 0x802DEDF6), /* ~= 10^278 */\n+    U64(0xE1A63853, 0xBBD26451), U64(0x5E7873F8, 0xA0396973), /* ~= 10^279 */\n+    U64(0x8D07E334, 0x55637EB2), U64(0xDB0B487B, 0x6423E1E8), /* ~= 10^280 */\n+    U64(0xB049DC01, 0x6ABC5E5F), U64(0x91CE1A9A, 0x3D2CDA62), /* ~= 10^281 */\n+    U64(0xDC5C5301, 0xC56B75F7), U64(0x7641A140, 0xCC7810FB), /* ~= 10^282 */\n+    U64(0x89B9B3E1, 0x1B6329BA), U64(0xA9E904C8, 0x7FCB0A9D), /* ~= 10^283 */\n+    U64(0xAC2820D9, 0x623BF429), U64(0x546345FA, 0x9FBDCD44), /* ~= 10^284 */\n+    U64(0xD732290F, 0xBACAF133), U64(0xA97C1779, 0x47AD4095), /* ~= 10^285 */\n+    U64(0x867F59A9, 0xD4BED6C0), U64(0x49ED8EAB, 0xCCCC485D), /* ~= 10^286 */\n+    U64(0xA81F3014, 0x49EE8C70), U64(0x5C68F256, 0xBFFF5A74), /* ~= 10^287 */\n+    U64(0xD226FC19, 0x5C6A2F8C), U64(0x73832EEC, 0x6FFF3111), /* ~= 10^288 */\n+    U64(0x83585D8F, 0xD9C25DB7), U64(0xC831FD53, 0xC5FF7EAB), /* ~= 10^289 */\n+    U64(0xA42E74F3, 0xD032F525), U64(0xBA3E7CA8, 0xB77F5E55), /* ~= 10^290 */\n+    U64(0xCD3A1230, 0xC43FB26F), U64(0x28CE1BD2, 0xE55F35EB), /* ~= 10^291 */\n+    U64(0x80444B5E, 0x7AA7CF85), U64(0x7980D163, 0xCF5B81B3), /* ~= 10^292 */\n+    U64(0xA0555E36, 0x1951C366), U64(0xD7E105BC, 0xC332621F), /* ~= 10^293 */\n+    U64(0xC86AB5C3, 0x9FA63440), U64(0x8DD9472B, 0xF3FEFAA7), /* ~= 10^294 */\n+    U64(0xFA856334, 0x878FC150), U64(0xB14F98F6, 0xF0FEB951), /* ~= 10^295 */\n+    U64(0x9C935E00, 0xD4B9D8D2), U64(0x6ED1BF9A, 0x569F33D3), /* ~= 10^296 */\n+    U64(0xC3B83581, 0x09E84F07), U64(0x0A862F80, 0xEC4700C8), /* ~= 10^297 */\n+    U64(0xF4A642E1, 0x4C6262C8), U64(0xCD27BB61, 0x2758C0FA), /* ~= 10^298 */\n+    U64(0x98E7E9CC, 0xCFBD7DBD), U64(0x8038D51C, 0xB897789C), /* ~= 10^299 */\n+    U64(0xBF21E440, 0x03ACDD2C), U64(0xE0470A63, 0xE6BD56C3), /* ~= 10^300 */\n+    U64(0xEEEA5D50, 0x04981478), U64(0x1858CCFC, 0xE06CAC74), /* ~= 10^301 */\n+    U64(0x95527A52, 0x02DF0CCB), U64(0x0F37801E, 0x0C43EBC8), /* ~= 10^302 */\n+    U64(0xBAA718E6, 0x8396CFFD), U64(0xD3056025, 0x8F54E6BA), /* ~= 10^303 */\n+    U64(0xE950DF20, 0x247C83FD), U64(0x47C6B82E, 0xF32A2069), /* ~= 10^304 */\n+    U64(0x91D28B74, 0x16CDD27E), U64(0x4CDC331D, 0x57FA5441), /* ~= 10^305 */\n+    U64(0xB6472E51, 0x1C81471D), U64(0xE0133FE4, 0xADF8E952), /* ~= 10^306 */\n+    U64(0xE3D8F9E5, 0x63A198E5), U64(0x58180FDD, 0xD97723A6), /* ~= 10^307 */\n+    U64(0x8E679C2F, 0x5E44FF8F), U64(0x570F09EA, 0xA7EA7648), /* ~= 10^308 */\n+    U64(0xB201833B, 0x35D63F73), U64(0x2CD2CC65, 0x51E513DA), /* ~= 10^309 */\n+    U64(0xDE81E40A, 0x034BCF4F), U64(0xF8077F7E, 0xA65E58D1), /* ~= 10^310 */\n+    U64(0x8B112E86, 0x420F6191), U64(0xFB04AFAF, 0x27FAF782), /* ~= 10^311 */\n+    U64(0xADD57A27, 0xD29339F6), U64(0x79C5DB9A, 0xF1F9B563), /* ~= 10^312 */\n+    U64(0xD94AD8B1, 0xC7380874), U64(0x18375281, 0xAE7822BC), /* ~= 10^313 */\n+    U64(0x87CEC76F, 0x1C830548), U64(0x8F229391, 0x0D0B15B5), /* ~= 10^314 */\n+    U64(0xA9C2794A, 0xE3A3C69A), U64(0xB2EB3875, 0x504DDB22), /* ~= 10^315 */\n+    U64(0xD433179D, 0x9C8CB841), U64(0x5FA60692, 0xA46151EB), /* ~= 10^316 */\n+    U64(0x849FEEC2, 0x81D7F328), U64(0xDBC7C41B, 0xA6BCD333), /* ~= 10^317 */\n+    U64(0xA5C7EA73, 0x224DEFF3), U64(0x12B9B522, 0x906C0800), /* ~= 10^318 */\n+    U64(0xCF39E50F, 0xEAE16BEF), U64(0xD768226B, 0x34870A00), /* ~= 10^319 */\n+    U64(0x81842F29, 0xF2CCE375), U64(0xE6A11583, 0x00D46640), /* ~= 10^320 */\n+    U64(0xA1E53AF4, 0x6F801C53), U64(0x60495AE3, 0xC1097FD0), /* ~= 10^321 */\n+    U64(0xCA5E89B1, 0x8B602368), U64(0x385BB19C, 0xB14BDFC4), /* ~= 10^322 */\n+    U64(0xFCF62C1D, 0xEE382C42), U64(0x46729E03, 0xDD9ED7B5), /* ~= 10^323 */\n+    U64(0x9E19DB92, 0xB4E31BA9), U64(0x6C07A2C2, 0x6A8346D1)  /* ~= 10^324 */\n };\n \n /**\n-Get the cached pow10 value from pow10_sig_table.\n-@param exp10 The exponent of pow(10, e). This value must in range\n-\t\t\t POW10_SIG_TABLE_MIN_EXP to POW10_SIG_TABLE_MAX_EXP.\n-@param hi    The highest 64 bits of pow(10, e).\n-@param lo    The lower 64 bits after `hi`.\n-*/\n+ Get the cached pow10 value from pow10_sig_table.\n+ @param exp10 The exponent of pow(10, e). This value must in range\n+              POW10_SIG_TABLE_MIN_EXP to POW10_SIG_TABLE_MAX_EXP.\n+ @param hi    The highest 64 bits of pow(10, e).\n+ @param lo    The lower 64 bits after `hi`.\n+ */\n static_inline void pow10_table_get_sig(i32 exp10, u64 *hi, u64 *lo) {\n-   i32 idx = exp10 - (POW10_SIG_TABLE_MIN_EXP);\n-   *hi = pow10_sig_table[idx * 2];\n-   *lo = pow10_sig_table[idx * 2 + 1];\n+    i32 idx = exp10 - (POW10_SIG_TABLE_MIN_EXP);\n+    *hi = pow10_sig_table[idx * 2];\n+    *lo = pow10_sig_table[idx * 2 + 1];\n }\n \n /**\n-Get the exponent (base 2) for highest 64 bits significand in pow10_sig_table.\n-*/\n+ Get the exponent (base 2) for highest 64 bits significand in pow10_sig_table.\n+ */\n static_inline void pow10_table_get_exp(i32 exp10, i32 *exp2) {\n-   /* e2 = floor(log2(pow(10, e))) - 64 + 1 */\n-   /*    = floor(e * log2(10) - 63)         */\n-   *exp2 = (exp10 * 217706 - 4128768) >> 16;\n+    /* e2 = floor(log2(pow(10, e))) - 64 + 1 */\n+    /*    = floor(e * log2(10) - 63)         */\n+    *exp2 = (exp10 * 217706 - 4128768) >> 16;\n }\n \n #endif\n@@ -2532,8 +2646,8 @@ static_inline void pow10_table_get_exp(i32 exp10, i32 *exp2) {\n #if !YYJSON_DISABLE_READER\n \n /*==============================================================================\n-* JSON Character Matcher\n-*============================================================================*/\n+ * JSON Character Matcher\n+ *============================================================================*/\n \n /** Character type */\n typedef u8 char_type;\n@@ -2561,81 +2675,81 @@ static const char_type CHAR_TYPE_LINE_END   = 1 << 6;\n \n /** Character type table (generate with misc/make_tables.c) */\n static const char_type char_table[256] = {\n-   0x44, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n-   0x04, 0x05, 0x45, 0x04, 0x04, 0x45, 0x04, 0x04,\n-   0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n-   0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n-   0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x20,\n-   0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\n-   0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x10, 0x04, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n-   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08\n+    0x44, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n+    0x04, 0x05, 0x45, 0x04, 0x04, 0x45, 0x04, 0x04,\n+    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n+    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n+    0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x20,\n+    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\n+    0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x10, 0x04, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n+    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08\n };\n \n /** Match a character with specified type. */\n static_inline bool char_is_type(u8 c, char_type type) {\n-   return (char_table[c] & type) != 0;\n+    return (char_table[c] & type) != 0;\n }\n \n /** Match a whitespace: ' ', '\\\\t', '\\\\n', '\\\\r'. */\n static_inline bool char_is_space(u8 c) {\n-   return char_is_type(c, (char_type)CHAR_TYPE_SPACE);\n+    return char_is_type(c, (char_type)CHAR_TYPE_SPACE);\n }\n \n /** Match a whitespace or comment: ' ', '\\\\t', '\\\\n', '\\\\r', '/'. */\n static_inline bool char_is_space_or_comment(u8 c) {\n-   return char_is_type(c, (char_type)(CHAR_TYPE_SPACE | CHAR_TYPE_COMMENT));\n+    return char_is_type(c, (char_type)(CHAR_TYPE_SPACE | CHAR_TYPE_COMMENT));\n }\n \n /** Match a JSON number: '-', [0-9]. */\n static_inline bool char_is_number(u8 c) {\n-   return char_is_type(c, (char_type)CHAR_TYPE_NUMBER);\n+    return char_is_type(c, (char_type)CHAR_TYPE_NUMBER);\n }\n \n /** Match a JSON container: '{', '['. */\n static_inline bool char_is_container(u8 c) {\n-   return char_is_type(c, (char_type)CHAR_TYPE_CONTAINER);\n+    return char_is_type(c, (char_type)CHAR_TYPE_CONTAINER);\n }\n \n /** Match a stop character in ASCII string: '\"', '\\', [0x00-0x1F], [0x80-0xFF]*/\n static_inline bool char_is_ascii_stop(u8 c) {\n-   return char_is_type(c, (char_type)(CHAR_TYPE_ESC_ASCII |\n-\t\t\t\t\t\t\t\t\t  CHAR_TYPE_NON_ASCII));\n+    return char_is_type(c, (char_type)(CHAR_TYPE_ESC_ASCII |\n+                                       CHAR_TYPE_NON_ASCII));\n }\n \n /** Match a line end character: '\\\\n', '\\\\r', '\\0'*/\n static_inline bool char_is_line_end(u8 c) {\n-   return char_is_type(c, (char_type)CHAR_TYPE_LINE_END);\n+    return char_is_type(c, (char_type)CHAR_TYPE_LINE_END);\n }\n \n \n \n /*==============================================================================\n-* Digit Character Matcher\n-*============================================================================*/\n+ * Digit Character Matcher\n+ *============================================================================*/\n \n /** Digit type */\n typedef u8 digi_type;\n@@ -2660,355 +2774,355 @@ static const digi_type DIGI_TYPE_EXP        = 1 << 5;\n \n /** Digit type table (generate with misc/make_tables.c) */\n static const digi_type digi_table[256] = {\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x10, 0x00,\n-   0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\n-   0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x10, 0x00,\n+    0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\n+    0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n };\n \n /** Match a character with specified type. */\n static_inline bool digi_is_type(u8 d, digi_type type) {\n-   return (digi_table[d] & type) != 0;\n+    return (digi_table[d] & type) != 0;\n }\n \n /** Match a sign: '+', '-' */\n static_inline bool digi_is_sign(u8 d) {\n-   return digi_is_type(d, (digi_type)(DIGI_TYPE_POS | DIGI_TYPE_NEG));\n+    return digi_is_type(d, (digi_type)(DIGI_TYPE_POS | DIGI_TYPE_NEG));\n }\n \n /** Match a none zero digit: [1-9] */\n static_inline bool digi_is_nonzero(u8 d) {\n-   return digi_is_type(d, (digi_type)DIGI_TYPE_NONZERO);\n+    return digi_is_type(d, (digi_type)DIGI_TYPE_NONZERO);\n }\n \n /** Match a digit: [0-9] */\n static_inline bool digi_is_digit(u8 d) {\n-   return digi_is_type(d, (digi_type)(DIGI_TYPE_ZERO | DIGI_TYPE_NONZERO));\n+    return digi_is_type(d, (digi_type)(DIGI_TYPE_ZERO | DIGI_TYPE_NONZERO));\n }\n \n /** Match an exponent sign: 'e', 'E'. */\n static_inline bool digi_is_exp(u8 d) {\n-   return digi_is_type(d, (digi_type)DIGI_TYPE_EXP);\n+    return digi_is_type(d, (digi_type)DIGI_TYPE_EXP);\n }\n \n /** Match a floating point indicator: '.', 'e', 'E'. */\n static_inline bool digi_is_fp(u8 d) {\n-   return digi_is_type(d, (digi_type)(DIGI_TYPE_DOT | DIGI_TYPE_EXP));\n+    return digi_is_type(d, (digi_type)(DIGI_TYPE_DOT | DIGI_TYPE_EXP));\n }\n \n /** Match a digit or floating point indicator: [0-9], '.', 'e', 'E'. */\n static_inline bool digi_is_digit_or_fp(u8 d) {\n-   return digi_is_type(d, (digi_type)(DIGI_TYPE_ZERO | DIGI_TYPE_NONZERO |\n-\t\t\t\t\t\t\t\t\t  DIGI_TYPE_DOT | DIGI_TYPE_EXP));\n+    return digi_is_type(d, (digi_type)(DIGI_TYPE_ZERO | DIGI_TYPE_NONZERO |\n+                                       DIGI_TYPE_DOT | DIGI_TYPE_EXP));\n }\n \n \n \n /*==============================================================================\n-* Hex Character Reader\n-* This function is used by JSON reader to read escaped characters.\n-*============================================================================*/\n+ * Hex Character Reader\n+ * This function is used by JSON reader to read escaped characters.\n+ *============================================================================*/\n \n /**\n-This table is used to convert 4 hex character sequence to a number.\n-A valid hex character [0-9A-Fa-f] will mapped to it's raw number [0x00, 0x0F],\n-an invalid hex character will mapped to [0xF0].\n-(generate with misc/make_tables.c)\n-*/\n+ This table is used to convert 4 hex character sequence to a number.\n+ A valid hex character [0-9A-Fa-f] will mapped to it's raw number [0x00, 0x0F],\n+ an invalid hex character will mapped to [0xF0].\n+ (generate with misc/make_tables.c)\n+ */\n static const u8 hex_conv_table[256] = {\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n-   0x08, 0x09, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n-   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0\n };\n \n /**\n-Scans an escaped character sequence as a UTF-16 code unit (branchless).\n-e.g. \"\\\\u005C\" should pass \"005C\" as `cur`.\n-\n-This requires the string has 4-byte zero padding.\n-*/\n+ Scans an escaped character sequence as a UTF-16 code unit (branchless).\n+ e.g. \"\\\\u005C\" should pass \"005C\" as `cur`.\n+ \n+ This requires the string has 4-byte zero padding.\n+ */\n static_inline bool read_hex_u16(const u8 *cur, u16 *val) {\n-   u16 c0, c1, c2, c3, t0, t1;\n-   c0 = hex_conv_table[cur[0]];\n-   c1 = hex_conv_table[cur[1]];\n-   c2 = hex_conv_table[cur[2]];\n-   c3 = hex_conv_table[cur[3]];\n-   t0 = (u16)((c0 << 8) | c2);\n-   t1 = (u16)((c1 << 8) | c3);\n-   *val = (u16)((t0 << 4) | t1);\n-   return ((t0 | t1) & (u16)0xF0F0) == 0;\n+    u16 c0, c1, c2, c3, t0, t1;\n+    c0 = hex_conv_table[cur[0]];\n+    c1 = hex_conv_table[cur[1]];\n+    c2 = hex_conv_table[cur[2]];\n+    c3 = hex_conv_table[cur[3]];\n+    t0 = (u16)((c0 << 8) | c2);\n+    t1 = (u16)((c1 << 8) | c3);\n+    *val = (u16)((t0 << 4) | t1);\n+    return ((t0 | t1) & (u16)0xF0F0) == 0;\n }\n \n \n \n /*==============================================================================\n-* JSON Reader Utils\n-* These functions are used by JSON reader to read literals and comments.\n-*============================================================================*/\n+ * JSON Reader Utils\n+ * These functions are used by JSON reader to read literals and comments.\n+ *============================================================================*/\n \n /** Read 'true' literal, '*cur' should be 't'. */\n static_inline bool read_true(u8 **ptr, yyjson_val *val) {\n-   u8 *cur = *ptr;\n-   u8 **end = ptr;\n-   if (likely(byte_match_4(cur, \"true\"))) {\n-\t   val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_TRUE;\n-\t   *end = cur + 4;\n-\t   return true;\n-   }\n-   return false;\n+    u8 *cur = *ptr;\n+    u8 **end = ptr;\n+    if (likely(byte_match_4(cur, \"true\"))) {\n+        val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_TRUE;\n+        *end = cur + 4;\n+        return true;\n+    }\n+    return false;\n }\n \n /** Read 'false' literal, '*cur' should be 'f'. */\n static_inline bool read_false(u8 **ptr, yyjson_val *val) {\n-   u8 *cur = *ptr;\n-   u8 **end = ptr;\n-   if (likely(byte_match_4(cur + 1, \"alse\"))) {\n-\t   val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_FALSE;\n-\t   *end = cur + 5;\n-\t   return true;\n-   }\n-   return false;\n+    u8 *cur = *ptr;\n+    u8 **end = ptr;\n+    if (likely(byte_match_4(cur + 1, \"alse\"))) {\n+        val->tag = YYJSON_TYPE_BOOL | YYJSON_SUBTYPE_FALSE;\n+        *end = cur + 5;\n+        return true;\n+    }\n+    return false;\n }\n \n /** Read 'null' literal, '*cur' should be 'n'. */\n static_inline bool read_null(u8 **ptr, yyjson_val *val) {\n-   u8 *cur = *ptr;\n-   u8 **end = ptr;\n-   if (likely(byte_match_4(cur, \"null\"))) {\n-\t   val->tag = YYJSON_TYPE_NULL;\n-\t   *end = cur + 4;\n-\t   return true;\n-   }\n-   return false;\n+    u8 *cur = *ptr;\n+    u8 **end = ptr;\n+    if (likely(byte_match_4(cur, \"null\"))) {\n+        val->tag = YYJSON_TYPE_NULL;\n+        *end = cur + 4;\n+        return true;\n+    }\n+    return false;\n }\n \n /** Read 'Inf' or 'Infinity' literal (ignoring case). */\n static_inline bool read_inf(bool sign, u8 **ptr, u8 **pre, yyjson_val *val) {\n #if !YYJSON_DISABLE_NON_STANDARD\n-   u8 *hdr = *ptr - sign;\n-   u8 *cur = *ptr;\n-   u8 **end = ptr;\n-   if ((cur[0] == 'I' || cur[0] == 'i') &&\n-\t   (cur[1] == 'N' || cur[1] == 'n') &&\n-\t   (cur[2] == 'F' || cur[2] == 'f')) {\n-\t   if ((cur[3] == 'I' || cur[3] == 'i') &&\n-\t\t   (cur[4] == 'N' || cur[4] == 'n') &&\n-\t\t   (cur[5] == 'I' || cur[5] == 'i') &&\n-\t\t   (cur[6] == 'T' || cur[6] == 't') &&\n-\t\t   (cur[7] == 'Y' || cur[7] == 'y')) {\n-\t\t   cur += 8;\n-\t   } else {\n-\t\t   cur += 3;\n-\t   }\n-\t   *end = cur;\n-\t   if (pre) {\n-\t\t   /* add null-terminator for previous raw string */\n-\t\t   if (*pre) **pre = '\\0';\n-\t\t   *pre = cur;\n-\t\t   val->tag = ((u64)(cur - hdr) << YYJSON_TAG_BIT) | YYJSON_TYPE_RAW;\n-\t\t   val->uni.str = (const char *)hdr;\n-\t   } else {\n-\t\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n-\t\t   val->uni.u64 = f64_raw_get_inf(sign);\n-\t   }\n-\t   return true;\n-   }\n+    u8 *hdr = *ptr - sign;\n+    u8 *cur = *ptr;\n+    u8 **end = ptr;\n+    if ((cur[0] == 'I' || cur[0] == 'i') &&\n+        (cur[1] == 'N' || cur[1] == 'n') &&\n+        (cur[2] == 'F' || cur[2] == 'f')) {\n+        if ((cur[3] == 'I' || cur[3] == 'i') &&\n+            (cur[4] == 'N' || cur[4] == 'n') &&\n+            (cur[5] == 'I' || cur[5] == 'i') &&\n+            (cur[6] == 'T' || cur[6] == 't') &&\n+            (cur[7] == 'Y' || cur[7] == 'y')) {\n+            cur += 8;\n+        } else {\n+            cur += 3;\n+        }\n+        *end = cur;\n+        if (pre) {\n+            /* add null-terminator for previous raw string */\n+            if (*pre) **pre = '\\0';\n+            *pre = cur;\n+            val->tag = ((u64)(cur - hdr) << YYJSON_TAG_BIT) | YYJSON_TYPE_RAW;\n+            val->uni.str = (const char *)hdr;\n+        } else {\n+            val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n+            val->uni.u64 = f64_raw_get_inf(sign);\n+        }\n+        return true;\n+    }\n #endif\n-   return false;\n+    return false;\n }\n \n /** Read 'NaN' literal (ignoring case). */\n static_inline bool read_nan(bool sign, u8 **ptr, u8 **pre, yyjson_val *val) {\n #if !YYJSON_DISABLE_NON_STANDARD\n-   u8 *hdr = *ptr - sign;\n-   u8 *cur = *ptr;\n-   u8 **end = ptr;\n-   if ((cur[0] == 'N' || cur[0] == 'n') &&\n-\t   (cur[1] == 'A' || cur[1] == 'a') &&\n-\t   (cur[2] == 'N' || cur[2] == 'n')) {\n-\t   cur += 3;\n-\t   *end = cur;\n-\t   if (pre) {\n-\t\t   /* add null-terminator for previous raw string */\n-\t\t   if (*pre) **pre = '\\0';\n-\t\t   *pre = cur;\n-\t\t   val->tag = ((u64)(cur - hdr) << YYJSON_TAG_BIT) | YYJSON_TYPE_RAW;\n-\t\t   val->uni.str = (const char *)hdr;\n-\t   } else {\n-\t\t   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n-\t\t   val->uni.u64 = f64_raw_get_nan(sign);\n-\t   }\n-\t   return true;\n-   }\n+    u8 *hdr = *ptr - sign;\n+    u8 *cur = *ptr;\n+    u8 **end = ptr;\n+    if ((cur[0] == 'N' || cur[0] == 'n') &&\n+        (cur[1] == 'A' || cur[1] == 'a') &&\n+        (cur[2] == 'N' || cur[2] == 'n')) {\n+        cur += 3;\n+        *end = cur;\n+        if (pre) {\n+            /* add null-terminator for previous raw string */\n+            if (*pre) **pre = '\\0';\n+            *pre = cur;\n+            val->tag = ((u64)(cur - hdr) << YYJSON_TAG_BIT) | YYJSON_TYPE_RAW;\n+            val->uni.str = (const char *)hdr;\n+        } else {\n+            val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n+            val->uni.u64 = f64_raw_get_nan(sign);\n+        }\n+        return true;\n+    }\n #endif\n-   return false;\n+    return false;\n }\n \n /** Read 'Inf', 'Infinity' or 'NaN' literal (ignoring case). */\n static_inline bool read_inf_or_nan(bool sign, u8 **ptr, u8 **pre,\n-\t\t\t\t\t\t\t\t  yyjson_val *val) {\n-   if (read_inf(sign, ptr, pre, val)) return true;\n-   if (read_nan(sign, ptr, pre, val)) return true;\n-   return false;\n+                                   yyjson_val *val) {\n+    if (read_inf(sign, ptr, pre, val)) return true;\n+    if (read_nan(sign, ptr, pre, val)) return true;\n+    return false;\n }\n \n /** Read a JSON number as raw string. */\n static_noinline bool read_number_raw(u8 **ptr,\n-\t\t\t\t\t\t\t\t\tu8 **pre,\n-\t\t\t\t\t\t\t\t\tbool ext,\n-\t\t\t\t\t\t\t\t\tyyjson_val *val,\n-\t\t\t\t\t\t\t\t\tconst char **msg) {\n-\n+                                     u8 **pre,\n+                                     bool ext,\n+                                     yyjson_val *val,\n+                                     const char **msg) {\n+    \n #define return_err(_pos, _msg) do { \\\n-   *msg = _msg; \\\n-   *end = _pos; \\\n-   return false; \\\n+    *msg = _msg; \\\n+    *end = _pos; \\\n+    return false; \\\n } while (false)\n-\n+    \n #define return_raw() do { \\\n-   val->tag = ((u64)(cur - hdr) << YYJSON_TAG_BIT) | YYJSON_TYPE_RAW; \\\n-   val->uni.str = (const char *)hdr; \\\n-   *pre = cur; *end = cur; return true; \\\n+    val->tag = ((u64)(cur - hdr) << YYJSON_TAG_BIT) | YYJSON_TYPE_RAW; \\\n+    val->uni.str = (const char *)hdr; \\\n+    *pre = cur; *end = cur; return true; \\\n } while (false)\n-\n-   u8 *hdr = *ptr;\n-   u8 *cur = *ptr;\n-   u8 **end = ptr;\n-\n-   /* add null-terminator for previous raw string */\n-   if (*pre) **pre = '\\0';\n-\n-   /* skip sign */\n-   cur += (*cur == '-');\n-\n-   /* read first digit, check leading zero */\n-   if (unlikely(!digi_is_digit(*cur))) {\n-\t   if (unlikely(ext)) {\n-\t\t   if (read_inf_or_nan(*hdr == '-', &cur, pre, val)) return_raw();\n-\t   }\n-\t   return_err(cur - 1, \"no digit after minus sign\");\n-   }\n-\n-   /* read integral part */\n-   if (*cur == '0') {\n-\t   cur++;\n-\t   if (unlikely(digi_is_digit(*cur))) {\n-\t\t   return_err(cur - 1, \"number with leading zero is not allowed\");\n-\t   }\n-\t   if (!digi_is_fp(*cur)) return_raw();\n-   } else {\n-\t   while (digi_is_digit(*cur)) cur++;\n-\t   if (!digi_is_fp(*cur)) return_raw();\n-   }\n-\n-   /* read fraction part */\n-   if (*cur == '.') {\n-\t   cur++;\n-\t   if (!digi_is_digit(*cur++)) {\n-\t\t   return_err(cur - 1, \"no digit after decimal point\");\n-\t   }\n-\t   while (digi_is_digit(*cur)) cur++;\n-   }\n-\n-   /* read exponent part */\n-   if (digi_is_exp(*cur)) {\n-\t   cur += 1 + digi_is_sign(cur[1]);\n-\t   if (!digi_is_digit(*cur++)) {\n-\t\t   return_err(cur - 1, \"no digit after exponent sign\");\n-\t   }\n-\t   while (digi_is_digit(*cur)) cur++;\n-   }\n-\n-   return_raw();\n-\n+    \n+    u8 *hdr = *ptr;\n+    u8 *cur = *ptr;\n+    u8 **end = ptr;\n+    \n+    /* add null-terminator for previous raw string */\n+    if (*pre) **pre = '\\0';\n+    \n+    /* skip sign */\n+    cur += (*cur == '-');\n+    \n+    /* read first digit, check leading zero */\n+    if (unlikely(!digi_is_digit(*cur))) {\n+        if (unlikely(ext)) {\n+            if (read_inf_or_nan(*hdr == '-', &cur, pre, val)) return_raw();\n+        }\n+        return_err(cur - 1, \"no digit after minus sign\");\n+    }\n+    \n+    /* read integral part */\n+    if (*cur == '0') {\n+        cur++;\n+        if (unlikely(digi_is_digit(*cur))) {\n+            return_err(cur - 1, \"number with leading zero is not allowed\");\n+        }\n+        if (!digi_is_fp(*cur)) return_raw();\n+    } else {\n+        while (digi_is_digit(*cur)) cur++;\n+        if (!digi_is_fp(*cur)) return_raw();\n+    }\n+    \n+    /* read fraction part */\n+    if (*cur == '.') {\n+        cur++;\n+        if (!digi_is_digit(*cur++)) {\n+            return_err(cur, \"no digit after decimal point\");\n+        }\n+        while (digi_is_digit(*cur)) cur++;\n+    }\n+    \n+    /* read exponent part */\n+    if (digi_is_exp(*cur)) {\n+        cur += 1 + digi_is_sign(cur[1]);\n+        if (!digi_is_digit(*cur++)) {\n+            return_err(cur - 1, \"no digit after exponent sign\");\n+        }\n+        while (digi_is_digit(*cur)) cur++;\n+    }\n+    \n+    return_raw();\n+    \n #undef return_err\n #undef return_raw\n }\n \n /**\n-Skips spaces and comments as many as possible.\n-\n-It will return false in these cases:\n-   1. No character is skipped. The 'end' pointer is set as input cursor.\n-   2. A multiline comment is not closed. The 'end' pointer is set as the head\n-\t  of this comment block.\n-*/\n+ Skips spaces and comments as many as possible.\n+ \n+ It will return false in these cases:\n+    1. No character is skipped. The 'end' pointer is set as input cursor.\n+    2. A multiline comment is not closed. The 'end' pointer is set as the head\n+       of this comment block.\n+ */\n static_noinline bool skip_spaces_and_comments(u8 **ptr) {\n-   u8 *hdr = *ptr;\n-   u8 *cur = *ptr;\n-   u8 **end = ptr;\n-   while (true) {\n-\t   if (byte_match_2(cur, \"/*\")) {\n-\t\t   hdr = cur;\n-\t\t   cur += 2;\n-\t\t   while (true) {\n-\t\t\t   if (byte_match_2(cur, \"*/\")) {\n-\t\t\t\t   cur += 2;\n-\t\t\t\t   break;\n-\t\t\t   }\n-\t\t\t   if (*cur == 0) {\n-\t\t\t\t   *end = hdr;\n-\t\t\t\t   return false;\n-\t\t\t   }\n-\t\t\t   cur++;\n-\t\t   }\n-\t\t   continue;\n-\t   }\n-\t   if (byte_match_2(cur, \"//\")) {\n-\t\t   cur += 2;\n-\t\t   while (!char_is_line_end(*cur)) cur++;\n-\t\t   continue;\n-\t   }\n-\t   if (char_is_space(*cur)) {\n-\t\t   cur += 1;\n-\t\t   while (char_is_space(*cur)) cur++;\n-\t\t   continue;\n-\t   }\n-\t   break;\n-   }\n-   *end = cur;\n-   return hdr != cur;\n+    u8 *hdr = *ptr;\n+    u8 *cur = *ptr;\n+    u8 **end = ptr;\n+    while (true) {\n+        if (byte_match_2(cur, \"/*\")) {\n+            hdr = cur;\n+            cur += 2;\n+            while (true) {\n+                if (byte_match_2(cur, \"*/\")) {\n+                    cur += 2;\n+                    break;\n+                }\n+                if (*cur == 0) {\n+                    *end = hdr;\n+                    return false;\n+                }\n+                cur++;\n+            }\n+            continue;\n+        }\n+        if (byte_match_2(cur, \"//\")) {\n+            cur += 2;\n+            while (!char_is_line_end(*cur)) cur++;\n+            continue;\n+        }\n+        if (char_is_space(*cur)) {\n+            cur += 1;\n+            while (char_is_space(*cur)) cur++;\n+            continue;\n+        }\n+        break;\n+    }\n+    *end = cur;\n+    return hdr != cur;\n }\n \n \n@@ -3016,28 +3130,28 @@ static_noinline bool skip_spaces_and_comments(u8 **ptr) {\n #if YYJSON_HAS_IEEE_754 && !YYJSON_DISABLE_FAST_FP_CONV /* FP_READER */\n \n /*==============================================================================\n-* BigInt For Floating Point Number Reader\n-*\n-* The bigint algorithm is used by floating-point number reader to get correctly\n-* rounded result for numbers with lots of digits. This part of code is rarely\n-* used for common numbers.\n-*============================================================================*/\n+ * BigInt For Floating Point Number Reader\n+ *\n+ * The bigint algorithm is used by floating-point number reader to get correctly\n+ * rounded result for numbers with lots of digits. This part of code is rarely\n+ * used for common numbers.\n+ *============================================================================*/\n \n /** Maximum exponent of exact pow10 */\n #define U64_POW10_MAX_EXP 19\n \n /** Table: [ 10^0, ..., 10^19 ] (generate with misc/make_tables.c) */\n static const u64 u64_pow10_table[U64_POW10_MAX_EXP + 1] = {\n-   U64(0x00000000, 0x00000001), U64(0x00000000, 0x0000000A),\n-   U64(0x00000000, 0x00000064), U64(0x00000000, 0x000003E8),\n-   U64(0x00000000, 0x00002710), U64(0x00000000, 0x000186A0),\n-   U64(0x00000000, 0x000F4240), U64(0x00000000, 0x00989680),\n-   U64(0x00000000, 0x05F5E100), U64(0x00000000, 0x3B9ACA00),\n-   U64(0x00000002, 0x540BE400), U64(0x00000017, 0x4876E800),\n-   U64(0x000000E8, 0xD4A51000), U64(0x00000918, 0x4E72A000),\n-   U64(0x00005AF3, 0x107A4000), U64(0x00038D7E, 0xA4C68000),\n-   U64(0x002386F2, 0x6FC10000), U64(0x01634578, 0x5D8A0000),\n-   U64(0x0DE0B6B3, 0xA7640000), U64(0x8AC72304, 0x89E80000)\n+    U64(0x00000000, 0x00000001), U64(0x00000000, 0x0000000A),\n+    U64(0x00000000, 0x00000064), U64(0x00000000, 0x000003E8),\n+    U64(0x00000000, 0x00002710), U64(0x00000000, 0x000186A0),\n+    U64(0x00000000, 0x000F4240), U64(0x00000000, 0x00989680),\n+    U64(0x00000000, 0x05F5E100), U64(0x00000000, 0x3B9ACA00),\n+    U64(0x00000002, 0x540BE400), U64(0x00000017, 0x4876E800),\n+    U64(0x000000E8, 0xD4A51000), U64(0x00000918, 0x4E72A000),\n+    U64(0x00005AF3, 0x107A4000), U64(0x00038D7E, 0xA4C68000),\n+    U64(0x002386F2, 0x6FC10000), U64(0x01634578, 0x5D8A0000),\n+    U64(0x0DE0B6B3, 0xA7640000), U64(0x8AC72304, 0x89E80000)\n };\n \n /** Maximum numbers of chunks used by a bigint (58 is enough here). */\n@@ -3045,831 +3159,831 @@ static const u64 u64_pow10_table[U64_POW10_MAX_EXP + 1] = {\n \n /** Unsigned arbitrarily large integer */\n typedef struct bigint {\n-   u32 used; /* used chunks count, should not be 0 */\n-   u64 bits[BIGINT_MAX_CHUNKS]; /* chunks */\n+    u32 used; /* used chunks count, should not be 0 */\n+    u64 bits[BIGINT_MAX_CHUNKS]; /* chunks */\n } bigint;\n \n /**\n-Evaluate 'big += val'.\n-@param big A big number (can be 0).\n-@param val An unsigned integer (can be 0).\n-*/\n+ Evaluate 'big += val'.\n+ @param big A big number (can be 0).\n+ @param val An unsigned integer (can be 0).\n+ */\n static_inline void bigint_add_u64(bigint *big, u64 val) {\n-   u32 idx, max;\n-   u64 num = big->bits[0];\n-   u64 add = num + val;\n-   big->bits[0] = add;\n-   if (likely((add >= num) || (add >= val))) return;\n-   for ((void)(idx = 1), max = big->used; idx < max; idx++) {\n-\t   if (likely(big->bits[idx] != U64_MAX)) {\n-\t\t   big->bits[idx] += 1;\n-\t\t   return;\n-\t   }\n-\t   big->bits[idx] = 0;\n-   }\n-   big->bits[big->used++] = 1;\n+    u32 idx, max;\n+    u64 num = big->bits[0];\n+    u64 add = num + val;\n+    big->bits[0] = add;\n+    if (likely((add >= num) || (add >= val))) return;\n+    for ((void)(idx = 1), max = big->used; idx < max; idx++) {\n+        if (likely(big->bits[idx] != U64_MAX)) {\n+            big->bits[idx] += 1;\n+            return;\n+        }\n+        big->bits[idx] = 0;\n+    }\n+    big->bits[big->used++] = 1;\n }\n \n /**\n-Evaluate 'big *= val'.\n-@param big A big number (can be 0).\n-@param val An unsigned integer (cannot be 0).\n-*/\n+ Evaluate 'big *= val'.\n+ @param big A big number (can be 0).\n+ @param val An unsigned integer (cannot be 0).\n+ */\n static_inline void bigint_mul_u64(bigint *big, u64 val) {\n-   u32 idx = 0, max = big->used;\n-   u64 hi, lo, carry = 0;\n-   for (; idx < max; idx++) {\n-\t   if (big->bits[idx]) break;\n-   }\n-   for (; idx < max; idx++) {\n-\t   u128_mul_add(big->bits[idx], val, carry, &hi, &lo);\n-\t   big->bits[idx] = lo;\n-\t   carry = hi;\n-   }\n-   if (carry) big->bits[big->used++] = carry;\n+    u32 idx = 0, max = big->used;\n+    u64 hi, lo, carry = 0;\n+    for (; idx < max; idx++) {\n+        if (big->bits[idx]) break;\n+    }\n+    for (; idx < max; idx++) {\n+        u128_mul_add(big->bits[idx], val, carry, &hi, &lo);\n+        big->bits[idx] = lo;\n+        carry = hi;\n+    }\n+    if (carry) big->bits[big->used++] = carry;\n }\n \n /**\n-Evaluate 'big *= 2^exp'.\n-@param big A big number (can be 0).\n-@param exp An exponent integer (can be 0).\n-*/\n+ Evaluate 'big *= 2^exp'.\n+ @param big A big number (can be 0).\n+ @param exp An exponent integer (can be 0).\n+ */\n static_inline void bigint_mul_pow2(bigint *big, u32 exp) {\n-   u32 shft = exp % 64;\n-   u32 move = exp / 64;\n-   u32 idx = big->used;\n-   if (unlikely(shft == 0)) {\n-\t   for (; idx > 0; idx--) {\n-\t\t   big->bits[idx + move - 1] = big->bits[idx - 1];\n-\t   }\n-\t   big->used += move;\n-\t   while (move) big->bits[--move] = 0;\n-   } else {\n-\t   big->bits[idx] = 0;\n-\t   for (; idx > 0; idx--) {\n-\t\t   u64 num = big->bits[idx] << shft;\n-\t\t   num |= big->bits[idx - 1] >> (64 - shft);\n-\t\t   big->bits[idx + move] = num;\n-\t   }\n-\t   big->bits[move] = big->bits[0] << shft;\n-\t   big->used += move + (big->bits[big->used + move] > 0);\n-\t   while (move) big->bits[--move] = 0;\n-   }\n+    u32 shft = exp % 64;\n+    u32 move = exp / 64;\n+    u32 idx = big->used;\n+    if (unlikely(shft == 0)) {\n+        for (; idx > 0; idx--) {\n+            big->bits[idx + move - 1] = big->bits[idx - 1];\n+        }\n+        big->used += move;\n+        while (move) big->bits[--move] = 0;\n+    } else {\n+        big->bits[idx] = 0;\n+        for (; idx > 0; idx--) {\n+            u64 num = big->bits[idx] << shft;\n+            num |= big->bits[idx - 1] >> (64 - shft);\n+            big->bits[idx + move] = num;\n+        }\n+        big->bits[move] = big->bits[0] << shft;\n+        big->used += move + (big->bits[big->used + move] > 0);\n+        while (move) big->bits[--move] = 0;\n+    }\n }\n \n /**\n-Evaluate 'big *= 10^exp'.\n-@param big A big number (can be 0).\n-@param exp An exponent integer (cannot be 0).\n-*/\n+ Evaluate 'big *= 10^exp'.\n+ @param big A big number (can be 0).\n+ @param exp An exponent integer (cannot be 0).\n+ */\n static_inline void bigint_mul_pow10(bigint *big, i32 exp) {\n-   for (; exp >= U64_POW10_MAX_EXP; exp -= U64_POW10_MAX_EXP) {\n-\t   bigint_mul_u64(big, u64_pow10_table[U64_POW10_MAX_EXP]);\n-   }\n-   if (exp) {\n-\t   bigint_mul_u64(big, u64_pow10_table[exp]);\n-   }\n+    for (; exp >= U64_POW10_MAX_EXP; exp -= U64_POW10_MAX_EXP) {\n+        bigint_mul_u64(big, u64_pow10_table[U64_POW10_MAX_EXP]);\n+    }\n+    if (exp) {\n+        bigint_mul_u64(big, u64_pow10_table[exp]);\n+    }\n }\n \n /**\n-Compare two bigint.\n-@return -1 if 'a < b', +1 if 'a > b', 0 if 'a == b'.\n-*/\n+ Compare two bigint.\n+ @return -1 if 'a < b', +1 if 'a > b', 0 if 'a == b'.\n+ */\n static_inline i32 bigint_cmp(bigint *a, bigint *b) {\n-   u32 idx = a->used;\n-   if (a->used < b->used) return -1;\n-   if (a->used > b->used) return +1;\n-   while (idx-- > 0) {\n-\t   u64 av = a->bits[idx];\n-\t   u64 bv = b->bits[idx];\n-\t   if (av < bv) return -1;\n-\t   if (av > bv) return +1;\n-   }\n-   return 0;\n+    u32 idx = a->used;\n+    if (a->used < b->used) return -1;\n+    if (a->used > b->used) return +1;\n+    while (idx-- > 0) {\n+        u64 av = a->bits[idx];\n+        u64 bv = b->bits[idx];\n+        if (av < bv) return -1;\n+        if (av > bv) return +1;\n+    }\n+    return 0;\n }\n \n /**\n-Evaluate 'big = val'.\n-@param big A big number (can be 0).\n-@param val An unsigned integer (can be 0).\n-*/\n+ Evaluate 'big = val'.\n+ @param big A big number (can be 0).\n+ @param val An unsigned integer (can be 0).\n+ */\n static_inline void bigint_set_u64(bigint *big, u64 val) {\n-   big->used = 1;\n-   big->bits[0] = val;\n+    big->used = 1;\n+    big->bits[0] = val;\n }\n \n /** Set a bigint with floating point number string. */\n static_noinline void bigint_set_buf(bigint *big, u64 sig, i32 *exp,\n-\t\t\t\t\t\t\t\t   u8 *sig_cut, u8 *sig_end, u8 *dot_pos) {\n-\n-   if (unlikely(!sig_cut)) {\n-\t   /* no digit cut, set significant part only */\n-\t   bigint_set_u64(big, sig);\n-\t   return;\n-\n-   } else {\n-\t   /* some digits were cut, read them from 'sig_cut' to 'sig_end' */\n-\t   u8 *hdr = sig_cut;\n-\t   u8 *cur = hdr;\n-\t   u32 len = 0;\n-\t   u64 val = 0;\n-\t   bool dig_big_cut = false;\n-\t   bool has_dot = (hdr < dot_pos) & (dot_pos < sig_end);\n-\t   u32 dig_len_total = U64_SAFE_DIG + (u32)(sig_end - hdr) - has_dot;\n-\n-\t   sig -= (*sig_cut >= '5'); /* sig was rounded before */\n-\t   if (dig_len_total > F64_MAX_DEC_DIG) {\n-\t\t   dig_big_cut = true;\n-\t\t   sig_end -= dig_len_total - (F64_MAX_DEC_DIG + 1);\n-\t\t   sig_end -= (dot_pos + 1 == sig_end);\n-\t\t   dig_len_total = (F64_MAX_DEC_DIG + 1);\n-\t   }\n-\t   *exp -= (i32)dig_len_total - U64_SAFE_DIG;\n-\n-\t   big->used = 1;\n-\t   big->bits[0] = sig;\n-\t   while (cur < sig_end) {\n-\t\t   if (likely(cur != dot_pos)) {\n-\t\t\t   val = val * 10 + (u8)(*cur++ - '0');\n-\t\t\t   len++;\n-\t\t\t   if (unlikely(cur == sig_end && dig_big_cut)) {\n-\t\t\t\t   /* The last digit must be non-zero,    */\n-\t\t\t\t   /* set it to '1' for correct rounding. */\n-\t\t\t\t   val = val - (val % 10) + 1;\n-\t\t\t   }\n-\t\t\t   if (len == U64_SAFE_DIG || cur == sig_end) {\n-\t\t\t\t   bigint_mul_pow10(big, (i32)len);\n-\t\t\t\t   bigint_add_u64(big, val);\n-\t\t\t\t   val = 0;\n-\t\t\t\t   len = 0;\n-\t\t\t   }\n-\t\t   } else {\n-\t\t\t   cur++;\n-\t\t   }\n-\t   }\n-   }\n+                                    u8 *sig_cut, u8 *sig_end, u8 *dot_pos) {\n+    \n+    if (unlikely(!sig_cut)) {\n+        /* no digit cut, set significant part only */\n+        bigint_set_u64(big, sig);\n+        return;\n+        \n+    } else {\n+        /* some digits were cut, read them from 'sig_cut' to 'sig_end' */\n+        u8 *hdr = sig_cut;\n+        u8 *cur = hdr;\n+        u32 len = 0;\n+        u64 val = 0;\n+        bool dig_big_cut = false;\n+        bool has_dot = (hdr < dot_pos) & (dot_pos < sig_end);\n+        u32 dig_len_total = U64_SAFE_DIG + (u32)(sig_end - hdr) - has_dot;\n+        \n+        sig -= (*sig_cut >= '5'); /* sig was rounded before */\n+        if (dig_len_total > F64_MAX_DEC_DIG) {\n+            dig_big_cut = true;\n+            sig_end -= dig_len_total - (F64_MAX_DEC_DIG + 1);\n+            sig_end -= (dot_pos + 1 == sig_end);\n+            dig_len_total = (F64_MAX_DEC_DIG + 1);\n+        }\n+        *exp -= (i32)dig_len_total - U64_SAFE_DIG;\n+        \n+        big->used = 1;\n+        big->bits[0] = sig;\n+        while (cur < sig_end) {\n+            if (likely(cur != dot_pos)) {\n+                val = val * 10 + (u8)(*cur++ - '0');\n+                len++;\n+                if (unlikely(cur == sig_end && dig_big_cut)) {\n+                    /* The last digit must be non-zero,    */\n+                    /* set it to '1' for correct rounding. */\n+                    val = val - (val % 10) + 1;\n+                }\n+                if (len == U64_SAFE_DIG || cur == sig_end) {\n+                    bigint_mul_pow10(big, (i32)len);\n+                    bigint_add_u64(big, val);\n+                    val = 0;\n+                    len = 0;\n+                }\n+            } else {\n+                cur++;\n+            }\n+        }\n+    }\n }\n \n \n \n /*==============================================================================\n-* Diy Floating Point\n-*============================================================================*/\n+ * Diy Floating Point\n+ *============================================================================*/\n \n /** \"Do It Yourself Floating Point\" struct. */\n typedef struct diy_fp {\n-   u64 sig; /* significand */\n-   i32 exp; /* exponent, base 2 */\n-   i32 pad; /* padding, useless */\n+    u64 sig; /* significand */\n+    i32 exp; /* exponent, base 2 */\n+    i32 pad; /* padding, useless */\n } diy_fp;\n \n /** Get cached rounded diy_fp with pow(10, e) The input value must in range\n-   [POW10_SIG_TABLE_MIN_EXP, POW10_SIG_TABLE_MAX_EXP]. */\n+    [POW10_SIG_TABLE_MIN_EXP, POW10_SIG_TABLE_MAX_EXP]. */\n static_inline diy_fp diy_fp_get_cached_pow10(i32 exp10) {\n-   diy_fp fp;\n-   u64 sig_ext;\n-   pow10_table_get_sig(exp10, &fp.sig, &sig_ext);\n-   pow10_table_get_exp(exp10, &fp.exp);\n-   fp.sig += (sig_ext >> 63);\n-   return fp;\n+    diy_fp fp;\n+    u64 sig_ext;\n+    pow10_table_get_sig(exp10, &fp.sig, &sig_ext);\n+    pow10_table_get_exp(exp10, &fp.exp);\n+    fp.sig += (sig_ext >> 63);\n+    return fp;\n }\n \n /** Returns fp * fp2. */\n static_inline diy_fp diy_fp_mul(diy_fp fp, diy_fp fp2) {\n-   u64 hi, lo;\n-   u128_mul(fp.sig, fp2.sig, &hi, &lo);\n-   fp.sig = hi + (lo >> 63);\n-   fp.exp += fp2.exp + 64;\n-   return fp;\n+    u64 hi, lo;\n+    u128_mul(fp.sig, fp2.sig, &hi, &lo);\n+    fp.sig = hi + (lo >> 63);\n+    fp.exp += fp2.exp + 64;\n+    return fp;\n }\n \n /** Convert diy_fp to IEEE-754 raw value. */\n static_inline u64 diy_fp_to_ieee_raw(diy_fp fp) {\n-   u64 sig = fp.sig;\n-   i32 exp = fp.exp;\n-   u32 lz_bits;\n-   if (unlikely(fp.sig == 0)) return 0;\n-\n-   lz_bits = u64_lz_bits(sig);\n-   sig <<= lz_bits;\n-   sig >>= F64_BITS - F64_SIG_FULL_BITS;\n-   exp -= (i32)lz_bits;\n-   exp += F64_BITS - F64_SIG_FULL_BITS;\n-   exp += F64_SIG_BITS;\n-\n-   if (unlikely(exp >= F64_MAX_BIN_EXP)) {\n-\t   /* overflow */\n-\t   return F64_RAW_INF;\n-   } else if (likely(exp >= F64_MIN_BIN_EXP - 1)) {\n-\t   /* normal */\n-\t   exp += F64_EXP_BIAS;\n-\t   return ((u64)exp << F64_SIG_BITS) | (sig & F64_SIG_MASK);\n-   } else if (likely(exp >= F64_MIN_BIN_EXP - F64_SIG_FULL_BITS)) {\n-\t   /* subnormal */\n-\t   return sig >> (F64_MIN_BIN_EXP - exp - 1);\n-   } else {\n-\t   /* underflow */\n-\t   return 0;\n-   }\n+    u64 sig = fp.sig;\n+    i32 exp = fp.exp;\n+    u32 lz_bits;\n+    if (unlikely(fp.sig == 0)) return 0;\n+    \n+    lz_bits = u64_lz_bits(sig);\n+    sig <<= lz_bits;\n+    sig >>= F64_BITS - F64_SIG_FULL_BITS;\n+    exp -= (i32)lz_bits;\n+    exp += F64_BITS - F64_SIG_FULL_BITS;\n+    exp += F64_SIG_BITS;\n+    \n+    if (unlikely(exp >= F64_MAX_BIN_EXP)) {\n+        /* overflow */\n+        return F64_RAW_INF;\n+    } else if (likely(exp >= F64_MIN_BIN_EXP - 1)) {\n+        /* normal */\n+        exp += F64_EXP_BIAS;\n+        return ((u64)exp << F64_SIG_BITS) | (sig & F64_SIG_MASK);\n+    } else if (likely(exp >= F64_MIN_BIN_EXP - F64_SIG_FULL_BITS)) {\n+        /* subnormal */\n+        return sig >> (F64_MIN_BIN_EXP - exp - 1);\n+    } else {\n+        /* underflow */\n+        return 0;\n+    }\n }\n \n \n \n /*==============================================================================\n-* JSON Number Reader (IEEE-754)\n-*============================================================================*/\n+ * JSON Number Reader (IEEE-754)\n+ *============================================================================*/\n \n /** Maximum exact pow10 exponent for double value. */\n #define F64_POW10_EXP_MAX_EXACT 22\n \n /** Cached pow10 table. */\n static const f64 f64_pow10_table[] = {\n-   1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12,\n-   1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19, 1e20, 1e21, 1e22\n+    1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12,\n+    1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19, 1e20, 1e21, 1e22\n };\n \n /**\n-Read a JSON number.\n-\n-1. This function assume that the floating-point number is in IEEE-754 format.\n-2. This function support uint64/int64/double number. If an integer number\n-   cannot fit in uint64/int64, it will returns as a double number. If a double\n-   number is infinite, the return value is based on flag.\n-3. This function (with inline attribute) may generate a lot of instructions.\n-*/\n+ Read a JSON number.\n+ \n+ 1. This function assume that the floating-point number is in IEEE-754 format.\n+ 2. This function support uint64/int64/double number. If an integer number\n+    cannot fit in uint64/int64, it will returns as a double number. If a double\n+    number is infinite, the return value is based on flag.\n+ 3. This function (with inline attribute) may generate a lot of instructions.\n+ */\n static_inline bool read_number(u8 **ptr,\n-\t\t\t\t\t\t\t  u8 **pre,\n-\t\t\t\t\t\t\t  bool ext,\n-\t\t\t\t\t\t\t  yyjson_val *val,\n-\t\t\t\t\t\t\t  const char **msg) {\n-\n+                               u8 **pre,\n+                               bool ext,\n+                               yyjson_val *val,\n+                               const char **msg) {\n+    \n #define return_err(_pos, _msg) do { \\\n-   *msg = _msg; \\\n-   *end = _pos; \\\n-   return false; \\\n+    *msg = _msg; \\\n+    *end = _pos; \\\n+    return false; \\\n } while (false)\n-\n+    \n #define return_i64(_v) do { \\\n-   val->tag = YYJSON_TYPE_NUM | (u8)((u8)sign << 3); \\\n-   val->uni.u64 = (u64)(sign ? (u64)(~(_v) + 1) : (u64)(_v)); \\\n-   *end = cur; return true; \\\n+    val->tag = YYJSON_TYPE_NUM | (u8)((u8)sign << 3); \\\n+    val->uni.u64 = (u64)(sign ? (u64)(~(_v) + 1) : (u64)(_v)); \\\n+    *end = cur; return true; \\\n } while (false)\n-\n+    \n #define return_f64(_v) do { \\\n-   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL; \\\n-   val->uni.f64 = sign ? -(f64)(_v) : (f64)(_v); \\\n-   *end = cur; return true; \\\n+    val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL; \\\n+    val->uni.f64 = sign ? -(f64)(_v) : (f64)(_v); \\\n+    *end = cur; return true; \\\n } while (false)\n-\n+    \n #define return_f64_raw(_v) do { \\\n-   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL; \\\n-   val->uni.u64 = ((u64)sign << 63) | (u64)(_v); \\\n-   *end = cur; return true; \\\n+    val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL; \\\n+    val->uni.u64 = ((u64)sign << 63) | (u64)(_v); \\\n+    *end = cur; return true; \\\n } while (false)\n-\n+    \n #define return_inf() do { \\\n-   if (unlikely(ext)) return_f64_raw(F64_RAW_INF); \\\n-   else return_err(hdr, \"number is infinity when parsed as double\"); \\\n+    if (unlikely(ext)) return_f64_raw(F64_RAW_INF); \\\n+    else return_err(hdr, \"number is infinity when parsed as double\"); \\\n } while (false)\n-\n-   u8 *sig_cut = NULL; /* significant part cutting position for long number */\n-   u8 *sig_end = NULL; /* significant part ending position */\n-   u8 *dot_pos = NULL; /* decimal point position */\n-\n-   u64 sig = 0; /* significant part of the number */\n-   i32 exp = 0; /* exponent part of the number */\n-\n-   bool exp_sign; /* temporary exponent sign from literal part */\n-   i64 exp_sig = 0; /* temporary exponent number from significant part */\n-   i64 exp_lit = 0; /* temporary exponent number from exponent literal part */\n-   u64 num; /* temporary number for reading */\n-   u8 *tmp; /* temporary cursor for reading */\n-\n-   u8 *hdr = *ptr;\n-   u8 *cur = *ptr;\n-   u8 **end = ptr;\n-   bool sign;\n-\n-   /* read number as raw string if has flag */\n-   if (unlikely(pre)) {\n-\t   return read_number_raw(ptr, pre, ext, val, msg);\n-   }\n-\n-   sign = (*hdr == '-');\n-   cur += sign;\n-\n-   /* begin with a leading zero or non-digit */\n-   if (unlikely(!digi_is_nonzero(*cur))) { /* 0 or non-digit char */\n-\t   if (unlikely(*cur != '0')) { /* non-digit char */\n-\t\t   if (unlikely(ext)) {\n-\t\t\t   if (read_inf_or_nan(sign, &cur, pre, val)) {\n-\t\t\t\t   *end = cur;\n-\t\t\t\t   return true;\n-\t\t\t   }\n-\t\t   }\n-\t\t   return_err(cur - 1, \"no digit after minus sign\");\n-\t   }\n-\t   /* begin with 0 */\n-\t   if (likely(!digi_is_digit_or_fp(*++cur))) return_i64(0);\n-\t   if (likely(*cur == '.')) {\n-\t\t   dot_pos = cur++;\n-\t\t   if (unlikely(!digi_is_digit(*cur))) {\n-\t\t\t   return_err(cur - 1, \"no digit after decimal point\");\n-\t\t   }\n-\t\t   while (unlikely(*cur == '0')) cur++;\n-\t\t   if (likely(digi_is_digit(*cur))) {\n-\t\t\t   /* first non-zero digit after decimal point */\n-\t\t\t   sig = (u64)(*cur - '0'); /* read first digit */\n-\t\t\t   cur--;\n-\t\t\t   goto digi_frac_1; /* continue read fraction part */\n-\t\t   }\n-\t   }\n-\t   if (unlikely(digi_is_digit(*cur))) {\n-\t\t   return_err(cur - 1, \"number with leading zero is not allowed\");\n-\t   }\n-\t   if (unlikely(digi_is_exp(*cur))) { /* 0 with any exponent is still 0 */\n-\t\t   cur += (usize)1 + digi_is_sign(cur[1]);\n-\t\t   if (unlikely(!digi_is_digit(*cur))) {\n-\t\t\t   return_err(cur - 1, \"no digit after exponent sign\");\n-\t\t   }\n-\t\t   while (digi_is_digit(*++cur));\n-\t   }\n-\t   return_f64_raw(0);\n-   }\n-\n-   /* begin with non-zero digit */\n-   sig = (u64)(*cur - '0');\n-\n-   /*\n-\tRead integral part, same as the following code.\n-\n-\t\tfor (int i = 1; i <= 18; i++) {\n-\t\t   num = cur[i] - '0';\n-\t\t   if (num <= 9) sig = num + sig * 10;\n-\t\t   else goto digi_sepr_i;\n-\t\t}\n-\t*/\n+    \n+    u8 *sig_cut = NULL; /* significant part cutting position for long number */\n+    u8 *sig_end = NULL; /* significant part ending position */\n+    u8 *dot_pos = NULL; /* decimal point position */\n+    \n+    u64 sig = 0; /* significant part of the number */\n+    i32 exp = 0; /* exponent part of the number */\n+    \n+    bool exp_sign; /* temporary exponent sign from literal part */\n+    i64 exp_sig = 0; /* temporary exponent number from significant part */\n+    i64 exp_lit = 0; /* temporary exponent number from exponent literal part */\n+    u64 num; /* temporary number for reading */\n+    u8 *tmp; /* temporary cursor for reading */\n+    \n+    u8 *hdr = *ptr;\n+    u8 *cur = *ptr;\n+    u8 **end = ptr;\n+    bool sign;\n+    \n+    /* read number as raw string if has flag */\n+    if (unlikely(pre)) {\n+        return read_number_raw(ptr, pre, ext, val, msg);\n+    }\n+    \n+    sign = (*hdr == '-');\n+    cur += sign;\n+    \n+    /* begin with a leading zero or non-digit */\n+    if (unlikely(!digi_is_nonzero(*cur))) { /* 0 or non-digit char */\n+        if (unlikely(*cur != '0')) { /* non-digit char */\n+            if (unlikely(ext)) {\n+                if (read_inf_or_nan(sign, &cur, pre, val)) {\n+                    *end = cur;\n+                    return true;\n+                }\n+            }\n+            return_err(cur - 1, \"no digit after minus sign\");\n+        }\n+        /* begin with 0 */\n+        if (likely(!digi_is_digit_or_fp(*++cur))) return_i64(0);\n+        if (likely(*cur == '.')) {\n+            dot_pos = cur++;\n+            if (unlikely(!digi_is_digit(*cur))) {\n+                return_err(cur, \"no digit after decimal point\");\n+            }\n+            while (unlikely(*cur == '0')) cur++;\n+            if (likely(digi_is_digit(*cur))) {\n+                /* first non-zero digit after decimal point */\n+                sig = (u64)(*cur - '0'); /* read first digit */\n+                cur--;\n+                goto digi_frac_1; /* continue read fraction part */\n+            }\n+        }\n+        if (unlikely(digi_is_digit(*cur))) {\n+            return_err(cur - 1, \"number with leading zero is not allowed\");\n+        }\n+        if (unlikely(digi_is_exp(*cur))) { /* 0 with any exponent is still 0 */\n+            cur += (usize)1 + digi_is_sign(cur[1]);\n+            if (unlikely(!digi_is_digit(*cur))) {\n+                return_err(cur - 1, \"no digit after exponent sign\");\n+            }\n+            while (digi_is_digit(*++cur));\n+        }\n+        return_f64_raw(0);\n+    }\n+    \n+    /* begin with non-zero digit */\n+    sig = (u64)(*cur - '0');\n+    \n+    /*\n+     Read integral part, same as the following code.\n+     \n+         for (int i = 1; i <= 18; i++) {\n+            num = cur[i] - '0';\n+            if (num <= 9) sig = num + sig * 10;\n+            else goto digi_sepr_i;\n+         }\n+     */\n #define expr_intg(i) \\\n-   if (likely((num = (u64)(cur[i] - (u8)'0')) <= 9)) sig = num + sig * 10; \\\n-   else { goto digi_sepr_##i; }\n-   repeat_in_1_18(expr_intg);\n+    if (likely((num = (u64)(cur[i] - (u8)'0')) <= 9)) sig = num + sig * 10; \\\n+    else { goto digi_sepr_##i; }\n+    repeat_in_1_18(expr_intg);\n #undef expr_intg\n-\n-\n-   cur += 19; /* skip continuous 19 digits */\n-   if (!digi_is_digit_or_fp(*cur)) {\n-\t   /* this number is an integer consisting of 19 digits */\n-\t   if (sign && (sig > ((u64)1 << 63))) { /* overflow */\n-\t\t   return_f64(normalized_u64_to_f64(sig));\n-\t   }\n-\t   return_i64(sig);\n-   }\n-   goto digi_intg_more; /* read more digits in integral part */\n-\n-\n-   /* process first non-digit character */\n+    \n+    \n+    cur += 19; /* skip continuous 19 digits */\n+    if (!digi_is_digit_or_fp(*cur)) {\n+        /* this number is an integer consisting of 19 digits */\n+        if (sign && (sig > ((u64)1 << 63))) { /* overflow */\n+            return_f64(normalized_u64_to_f64(sig));\n+        }\n+        return_i64(sig);\n+    }\n+    goto digi_intg_more; /* read more digits in integral part */\n+    \n+    \n+    /* process first non-digit character */\n #define expr_sepr(i) \\\n-   digi_sepr_##i: \\\n-   if (likely(!digi_is_fp(cur[i]))) { cur += i; return_i64(sig); } \\\n-   dot_pos = cur + i; \\\n-   if (likely(cur[i] == '.')) goto digi_frac_##i; \\\n-   cur += i; sig_end = cur; goto digi_exp_more;\n-   repeat_in_1_18(expr_sepr)\n+    digi_sepr_##i: \\\n+    if (likely(!digi_is_fp(cur[i]))) { cur += i; return_i64(sig); } \\\n+    dot_pos = cur + i; \\\n+    if (likely(cur[i] == '.')) goto digi_frac_##i; \\\n+    cur += i; sig_end = cur; goto digi_exp_more;\n+    repeat_in_1_18(expr_sepr)\n #undef expr_sepr\n-\n-\n-   /* read fraction part */\n+    \n+    \n+    /* read fraction part */\n #define expr_frac(i) \\\n-   digi_frac_##i: \\\n-   if (likely((num = (u64)(cur[i + 1] - (u8)'0')) <= 9)) \\\n-\t   sig = num + sig * 10; \\\n-   else { goto digi_stop_##i; }\n-\t   repeat_in_1_18(expr_frac)\n+    digi_frac_##i: \\\n+    if (likely((num = (u64)(cur[i + 1] - (u8)'0')) <= 9)) \\\n+        sig = num + sig * 10; \\\n+    else { goto digi_stop_##i; }\n+    repeat_in_1_18(expr_frac)\n #undef expr_frac\n-\n-\t\t   cur += 20; /* skip 19 digits and 1 decimal point */\n-   if (!digi_is_digit(*cur)) goto digi_frac_end; /* fraction part end */\n-   goto digi_frac_more; /* read more digits in fraction part */\n-\n-\n-   /* significant part end */\n+    \n+    cur += 20; /* skip 19 digits and 1 decimal point */\n+    if (!digi_is_digit(*cur)) goto digi_frac_end; /* fraction part end */\n+    goto digi_frac_more; /* read more digits in fraction part */\n+    \n+    \n+    /* significant part end */\n #define expr_stop(i) \\\n-   digi_stop_##i: \\\n-   cur += i + 1; \\\n-   goto digi_frac_end;\n-   repeat_in_1_18(expr_stop)\n+    digi_stop_##i: \\\n+    cur += i + 1; \\\n+    goto digi_frac_end;\n+    repeat_in_1_18(expr_stop)\n #undef expr_stop\n-\n-\n-\t   /* read more digits in integral part */\n-\t   digi_intg_more:\n-\t   if (digi_is_digit(*cur)) {\n-\t   if (!digi_is_digit_or_fp(cur[1])) {\n-\t\t   /* this number is an integer consisting of 20 digits */\n-\t\t   num = (u64)(*cur - '0');\n-\t\t   if ((sig < (U64_MAX / 10)) ||\n-\t\t\t   (sig == (U64_MAX / 10) && num <= (U64_MAX % 10))) {\n-\t\t\t   sig = num + sig * 10;\n-\t\t\t   cur++;\n-\t\t\t   /* convert to double if overflow */\n-\t\t\t   if (sign) return_f64(normalized_u64_to_f64(sig));\n-\t\t\t   return_i64(sig);\n-\t\t   }\n-\t   }\n-   }\n-\n-   if (digi_is_exp(*cur)) {\n-\t   dot_pos = cur;\n-\t   goto digi_exp_more;\n-   }\n-\n-   if (*cur == '.') {\n-\t   dot_pos = cur++;\n-\t   if (!digi_is_digit(*cur)) {\n-\t\t   return_err(cur, \"no digit after decimal point\");\n-\t   }\n-   }\n-\n-\n-   /* read more digits in fraction part */\n+    \n+    \n+    /* read more digits in integral part */\n+digi_intg_more:\n+    if (digi_is_digit(*cur)) {\n+        if (!digi_is_digit_or_fp(cur[1])) {\n+            /* this number is an integer consisting of 20 digits */\n+            num = (u64)(*cur - '0');\n+            if ((sig < (U64_MAX / 10)) ||\n+                (sig == (U64_MAX / 10) && num <= (U64_MAX % 10))) {\n+                sig = num + sig * 10;\n+                cur++;\n+                /* convert to double if overflow */\n+                if (sign) return_f64(normalized_u64_to_f64(sig));\n+                return_i64(sig);\n+            }\n+        }\n+    }\n+    \n+    if (digi_is_exp(*cur)) {\n+        dot_pos = cur;\n+        goto digi_exp_more;\n+    }\n+    \n+    if (*cur == '.') {\n+        dot_pos = cur++;\n+        if (!digi_is_digit(*cur)) {\n+            return_err(cur, \"no digit after decimal point\");\n+        }\n+    }\n+    \n+    \n+    /* read more digits in fraction part */\n digi_frac_more:\n-   sig_cut = cur; /* too large to fit in u64, excess digits need to be cut */\n-   sig += (*cur >= '5'); /* round */\n-   while (digi_is_digit(*++cur));\n-   if (!dot_pos) {\n-\t   dot_pos = cur;\n-\t   if (*cur == '.') {\n-\t\t   if (!digi_is_digit(*++cur)) {\n-\t\t\t   return_err(cur, \"no digit after decimal point\");\n-\t\t   }\n-\t\t   while (digi_is_digit(*cur)) cur++;\n-\t   }\n-   }\n-   exp_sig = (i64)(dot_pos - sig_cut);\n-   exp_sig += (dot_pos < sig_cut);\n-\n-   /* ignore trailing zeros */\n-   tmp = cur - 1;\n-   while (*tmp == '0' || *tmp == '.') tmp--;\n-   if (tmp < sig_cut) {\n-\t   sig_cut = NULL;\n-   } else {\n-\t   sig_end = cur;\n-   }\n-\n-   if (digi_is_exp(*cur)) goto digi_exp_more;\n-   goto digi_exp_finish;\n-\n-\n-   /* fraction part end */\n+    sig_cut = cur; /* too large to fit in u64, excess digits need to be cut */\n+    sig += (*cur >= '5'); /* round */\n+    while (digi_is_digit(*++cur));\n+    if (!dot_pos) {\n+        dot_pos = cur;\n+        if (*cur == '.') {\n+            if (!digi_is_digit(*++cur)) {\n+                return_err(cur, \"no digit after decimal point\");\n+            }\n+            while (digi_is_digit(*cur)) cur++;\n+        }\n+    }\n+    exp_sig = (i64)(dot_pos - sig_cut);\n+    exp_sig += (dot_pos < sig_cut);\n+    \n+    /* ignore trailing zeros */\n+    tmp = cur - 1;\n+    while (*tmp == '0' || *tmp == '.') tmp--;\n+    if (tmp < sig_cut) {\n+        sig_cut = NULL;\n+    } else {\n+        sig_end = cur;\n+    }\n+    \n+    if (digi_is_exp(*cur)) goto digi_exp_more;\n+    goto digi_exp_finish;\n+    \n+    \n+    /* fraction part end */\n digi_frac_end:\n-   if (unlikely(dot_pos + 1 == cur)) {\n-\t   return_err(cur - 1, \"no digit after decimal point\");\n-   }\n-   sig_end = cur;\n-   exp_sig = -(i64)((u64)(cur - dot_pos) - 1);\n-   if (likely(!digi_is_exp(*cur))) {\n-\t   if (unlikely(exp_sig < F64_MIN_DEC_EXP - 19)) {\n-\t\t   return_f64_raw(0); /* underflow */\n-\t   }\n-\t   exp = (i32)exp_sig;\n-\t   goto digi_finish;\n-   } else {\n-\t   goto digi_exp_more;\n-   }\n-\n-\n-   /* read exponent part */\n+    if (unlikely(dot_pos + 1 == cur)) {\n+        return_err(cur, \"no digit after decimal point\");\n+    }\n+    sig_end = cur;\n+    exp_sig = -(i64)((u64)(cur - dot_pos) - 1);\n+    if (likely(!digi_is_exp(*cur))) {\n+        if (unlikely(exp_sig < F64_MIN_DEC_EXP - 19)) {\n+            return_f64_raw(0); /* underflow */\n+        }\n+        exp = (i32)exp_sig;\n+        goto digi_finish;\n+    } else {\n+        goto digi_exp_more;\n+    }\n+    \n+    \n+    /* read exponent part */\n digi_exp_more:\n-   exp_sign = (*++cur == '-');\n-   cur += digi_is_sign(*cur);\n-   if (unlikely(!digi_is_digit(*cur))) {\n-\t   return_err(cur - 1, \"no digit after exponent sign\");\n-   }\n-   while (*cur == '0') cur++;\n-\n-   /* read exponent literal */\n-   tmp = cur;\n-   while (digi_is_digit(*cur)) {\n-\t   exp_lit = (i64)((u8)(*cur++ - '0') + (u64)exp_lit * 10);\n-   }\n-   if (unlikely(cur - tmp >= U64_SAFE_DIG)) {\n-\t   if (exp_sign) {\n-\t\t   return_f64_raw(0); /* underflow */\n-\t   } else {\n-\t\t   return_inf(); /* overflow */\n-\t   }\n-   }\n-   exp_sig += exp_sign ? -exp_lit : exp_lit;\n-\n-\n-   /* validate exponent value */\n+    exp_sign = (*++cur == '-');\n+    cur += digi_is_sign(*cur);\n+    if (unlikely(!digi_is_digit(*cur))) {\n+        return_err(cur - 1, \"no digit after exponent sign\");\n+    }\n+    while (*cur == '0') cur++;\n+    \n+    /* read exponent literal */\n+    tmp = cur;\n+    while (digi_is_digit(*cur)) {\n+        exp_lit = (i64)((u8)(*cur++ - '0') + (u64)exp_lit * 10);\n+    }\n+    if (unlikely(cur - tmp >= U64_SAFE_DIG)) {\n+        if (exp_sign) {\n+            return_f64_raw(0); /* underflow */\n+        } else {\n+            return_inf(); /* overflow */\n+        }\n+    }\n+    exp_sig += exp_sign ? -exp_lit : exp_lit;\n+    \n+    \n+    /* validate exponent value */\n digi_exp_finish:\n-   if (unlikely(exp_sig < F64_MIN_DEC_EXP - 19)) {\n-\t   return_f64_raw(0); /* underflow */\n-   }\n-   if (unlikely(exp_sig > F64_MAX_DEC_EXP)) {\n-\t   return_inf(); /* overflow */\n-   }\n-   exp = (i32)exp_sig;\n-\n-\n-   /* all digit read finished */\n+    if (unlikely(exp_sig < F64_MIN_DEC_EXP - 19)) {\n+        return_f64_raw(0); /* underflow */\n+    }\n+    if (unlikely(exp_sig > F64_MAX_DEC_EXP)) {\n+        return_inf(); /* overflow */\n+    }\n+    exp = (i32)exp_sig;\n+    \n+    \n+    /* all digit read finished */\n digi_finish:\n-\n-   /*\n-\tFast path 1:\n-\n-\t1. The floating-point number calculation should be accurate, see the\n-\t   comments of macro `YYJSON_DOUBLE_MATH_CORRECT`.\n-\t2. Correct rounding should be performed (fegetround() == FE_TONEAREST).\n-\t3. The input of floating point number calculation does not lose precision,\n-\t   which means: 64 - leading_zero(input) - trailing_zero(input) < 53.\n-\n-\tWe don't check all available inputs here, because that would make the code\n-\tmore complicated, and not friendly to branch predictor.\n-\t*/\n+    \n+    /*\n+     Fast path 1:\n+     \n+     1. The floating-point number calculation should be accurate, see the\n+        comments of macro `YYJSON_DOUBLE_MATH_CORRECT`.\n+     2. Correct rounding should be performed (fegetround() == FE_TONEAREST).\n+     3. The input of floating point number calculation does not lose precision,\n+        which means: 64 - leading_zero(input) - trailing_zero(input) < 53.\n+    \n+     We don't check all available inputs here, because that would make the code\n+     more complicated, and not friendly to branch predictor.\n+     */\n #if YYJSON_DOUBLE_MATH_CORRECT\n-   if (sig < ((u64)1 << 53) &&\n-\t   exp >= -F64_POW10_EXP_MAX_EXACT &&\n-\t   exp <= +F64_POW10_EXP_MAX_EXACT) {\n-\t   f64 dbl = (f64)sig;\n-\t   if (exp < 0) {\n-\t\t   dbl /= f64_pow10_table[-exp];\n-\t   } else {\n-\t\t   dbl *= f64_pow10_table[+exp];\n-\t   }\n-\t   return_f64(dbl);\n-   }\n+    if (sig < ((u64)1 << 53) &&\n+        exp >= -F64_POW10_EXP_MAX_EXACT &&\n+        exp <= +F64_POW10_EXP_MAX_EXACT) {\n+        f64 dbl = (f64)sig;\n+        if (exp < 0) {\n+            dbl /= f64_pow10_table[-exp];\n+        } else {\n+            dbl *= f64_pow10_table[+exp];\n+        }\n+        return_f64(dbl);\n+    }\n #endif\n-\n-   /*\n-\tFast path 2:\n-\n-\tTo keep it simple, we only accept normal number here,\n-\tlet the slow path to handle subnormal and infinity number.\n-\t*/\n-   if (likely(!sig_cut &&\n-\t\t\t  exp > -F64_MAX_DEC_EXP + 1 &&\n-\t\t\t  exp < +F64_MAX_DEC_EXP - 20)) {\n-\t   /*\n-\t\tThe result value is exactly equal to (sig * 10^exp),\n-\t\tthe exponent part (10^exp) can be converted to (sig2 * 2^exp2).\n-\n-\t\tThe sig2 can be an infinite length number, only the highest 128 bits\n-\t\tis cached in the pow10_sig_table.\n-\n-\t\tNow we have these bits:\n-\t\tsig1 (normalized 64bit)        : aaaaaaaa\n-\t\tsig2 (higher 64bit)            : bbbbbbbb\n-\t\tsig2_ext (lower 64bit)         : cccccccc\n-\t\tsig2_cut (extra unknown bits)  : dddddddddddd....\n-\n-\t\tAnd the calculation process is:\n-\t\t----------------------------------------\n-\t\t\t\taaaaaaaa *\n-\t\t\t\tbbbbbbbbccccccccdddddddddddd....\n-\t\t----------------------------------------\n-\t\tabababababababab +\n-\t\t\t\tacacacacacacacac +\n-\t\t\t\t\t\tadadadadadadadadadad....\n-\t\t----------------------------------------\n-\t\t[hi____][lo____] +\n-\t\t\t\t[hi2___][lo2___] +\n-\t\t\t\t\t\t[unknown___________....]\n-\t\t----------------------------------------\n-\n-\t\tThe addition with carry may affect higher bits, but if there is a 0\n-\t\tin higher bits, the bits higher than 0 will not be affected.\n-\n-\t\t`lo2` + `unknown` may get a carry bit and may affect `hi2`, the max\n-\t\tvalue of `hi2` is 0xFFFFFFFFFFFFFFFE, so `hi2` will not overflow.\n-\n-\t\t`lo` + `hi2` may also get a carry bit and may affect `hi`, but only\n-\t\tthe highest significant 53 bits of `hi` is needed. If there is a 0\n-\t\tin the lower bits of `hi`, then all the following bits can be dropped.\n-\n-\t\tTo convert the result to IEEE-754 double number, we need to perform\n-\t\tcorrect rounding:\n-\t\t1. if bit 54 is 0, round down,\n-\t\t2. if bit 54 is 1 and any bit beyond bit 54 is 1, round up,\n-\t\t3. if bit 54 is 1 and all bits beyond bit 54 are 0, round to even,\n-\t\t   as the extra bits is unknown, this case will not be handled here.\n-\t\t*/\n-\n-\t   u64 raw;\n-\t   u64 sig1, sig2, sig2_ext, hi, lo, hi2, lo2, add, bits;\n-\t   i32 exp2;\n-\t   u32 lz;\n-\t   bool exact = false, carry, round_up;\n-\n-\t   /* convert (10^exp) to (sig2 * 2^exp2) */\n-\t   pow10_table_get_sig(exp, &sig2, &sig2_ext);\n-\t   pow10_table_get_exp(exp, &exp2);\n-\n-\t   /* normalize and multiply */\n-\t   lz = u64_lz_bits(sig);\n-\t   sig1 = sig << lz;\n-\t   exp2 -= (i32)lz;\n-\t   u128_mul(sig1, sig2, &hi, &lo);\n-\n-\t   /*\n-\t\tThe `hi` is in range [0x4000000000000000, 0xFFFFFFFFFFFFFFFE],\n-\t\tTo get normalized value, `hi` should be shifted to the left by 0 or 1.\n-\n-\t\tThe highest significant 53 bits is used by IEEE-754 double number,\n-\t\tand the bit 54 is used to detect rounding direction.\n-\n-\t\tThe lowest (64 - 54 - 1) bits is used to check whether it contains 0.\n-\t\t*/\n-\t   bits = hi & (((u64)1 << (64 - 54 - 1)) - 1);\n-\t   if (bits - 1 < (((u64)1 << (64 - 54 - 1)) - 2)) {\n-\t\t   /*\n-\t\t\t(bits != 0 && bits != 0x1FF) => (bits - 1 < 0x1FF - 1)\n-\t\t\tThe `bits` is not zero, so we don't need to check `round to even`\n-\t\t\tcase. The `bits` contains bit `0`, so we can drop the extra bits\n-\t\t\tafter `0`.\n-\t\t\t*/\n-\t\t   exact = true;\n-\n-\t   } else {\n-\t\t   /*\n-\t\t\t(bits == 0 || bits == 0x1FF)\n-\t\t\tThe `bits` is filled with all `0` or all `1`, so we need to check\n-\t\t\tlower bits with another 64-bit multiplication.\n-\t\t\t*/\n-\t\t   u128_mul(sig1, sig2_ext, &hi2, &lo2);\n-\n-\t\t   add = lo + hi2;\n-\t\t   if (add + 1 > (u64)1) {\n-\t\t\t   /*\n-\t\t\t\t(add != 0 && add != U64_MAX) => (add + 1 > 1)\n-\t\t\t\tThe `add` is not zero, so we don't need to check `round to\n-\t\t\t\teven` case. The `add` contains bit `0`, so we can drop the\n-\t\t\t\textra bits after `0`. The `hi` cannot be U64_MAX, so it will\n-\t\t\t\tnot overflow.\n-\t\t\t\t*/\n-\t\t\t   carry = add < lo || add < hi2;\n-\t\t\t   hi += carry;\n-\t\t\t   exact = true;\n-\t\t   }\n-\t   }\n-\n-\t   if (exact) {\n-\t\t   /* normalize */\n-\t\t   lz = hi < ((u64)1 << 63);\n-\t\t   hi <<= lz;\n-\t\t   exp2 -= (i32)lz;\n-\t\t   exp2 += 64;\n-\n-\t\t   /* test the bit 54 and get rounding direction */\n-\t\t   round_up = (hi & ((u64)1 << (64 - 54))) > (u64)0;\n-\t\t   hi += (round_up ? ((u64)1 << (64 - 54)) : (u64)0);\n-\n-\t\t   /* test overflow */\n-\t\t   if (hi < ((u64)1 << (64 - 54))) {\n-\t\t\t   hi = ((u64)1 << 63);\n-\t\t\t   exp2 += 1;\n-\t\t   }\n-\n-\t\t   /* This is a normal number, convert it to IEEE-754 format. */\n-\t\t   hi >>= F64_BITS - F64_SIG_FULL_BITS;\n-\t\t   exp2 += F64_BITS - F64_SIG_FULL_BITS + F64_SIG_BITS;\n-\t\t   exp2 += F64_EXP_BIAS;\n-\t\t   raw = ((u64)exp2 << F64_SIG_BITS) | (hi & F64_SIG_MASK);\n-\t\t   return_f64_raw(raw);\n-\t   }\n-   }\n-\n-   /*\n-\tSlow path: read double number exactly with diyfp.\n-\t1. Use cached diyfp to get an approximation value.\n-\t2. Use bigcomp to check the approximation value if needed.\n-\n-\tThis algorithm refers to google's double-conversion project:\n-\thttps://github.com/google/double-conversion\n-\t*/\n-   {\n-\t   const i32 ERR_ULP_LOG = 3;\n-\t   const i32 ERR_ULP = 1 << ERR_ULP_LOG;\n-\t   const i32 ERR_CACHED_POW = ERR_ULP / 2;\n-\t   const i32 ERR_MUL_FIXED = ERR_ULP / 2;\n-\t   const i32 DIY_SIG_BITS = 64;\n-\t   const i32 EXP_BIAS = F64_EXP_BIAS + F64_SIG_BITS;\n-\t   const i32 EXP_SUBNORMAL = -EXP_BIAS + 1;\n-\n-\t   u64 fp_err;\n-\t   u32 bits;\n-\t   i32 order_of_magnitude;\n-\t   i32 effective_significand_size;\n-\t   i32 precision_digits_count;\n-\t   u64 precision_bits;\n-\t   u64 half_way;\n-\n-\t   u64 raw;\n-\t   diy_fp fp, fp_upper;\n-\t   bigint big_full, big_comp;\n-\t   i32 cmp;\n-\n-\t   fp.sig = sig;\n-\t   fp.exp = 0;\n-\t   fp_err = sig_cut ? (u64)(ERR_ULP / 2) : (u64)0;\n-\n-\t   /* normalize */\n-\t   bits = u64_lz_bits(fp.sig);\n-\t   fp.sig <<= bits;\n-\t   fp.exp -= (i32)bits;\n-\t   fp_err <<= bits;\n-\n-\t   /* multiply and add error */\n-\t   fp = diy_fp_mul(fp, diy_fp_get_cached_pow10(exp));\n-\t   fp_err += (u64)ERR_CACHED_POW + (fp_err != 0) + (u64)ERR_MUL_FIXED;\n-\n-\t   /* normalize */\n-\t   bits = u64_lz_bits(fp.sig);\n-\t   fp.sig <<= bits;\n-\t   fp.exp -= (i32)bits;\n-\t   fp_err <<= bits;\n-\n-\t   /* effective significand */\n-\t   order_of_magnitude = DIY_SIG_BITS + fp.exp;\n-\t   if (likely(order_of_magnitude >= EXP_SUBNORMAL + F64_SIG_FULL_BITS)) {\n-\t\t   effective_significand_size = F64_SIG_FULL_BITS;\n-\t   } else if (order_of_magnitude <= EXP_SUBNORMAL) {\n-\t\t   effective_significand_size = 0;\n-\t   } else {\n-\t\t   effective_significand_size = order_of_magnitude - EXP_SUBNORMAL;\n-\t   }\n-\n-\t   /* precision digits count */\n-\t   precision_digits_count = DIY_SIG_BITS - effective_significand_size;\n-\t   if (unlikely(precision_digits_count + ERR_ULP_LOG >= DIY_SIG_BITS)) {\n-\t\t   i32 shr = (precision_digits_count + ERR_ULP_LOG) - DIY_SIG_BITS + 1;\n-\t\t   fp.sig >>= shr;\n-\t\t   fp.exp += shr;\n-\t\t   fp_err = (fp_err >> shr) + 1 + (u32)ERR_ULP;\n-\t\t   precision_digits_count -= shr;\n-\t   }\n-\n-\t   /* half way */\n-\t   precision_bits = fp.sig & (((u64)1 << precision_digits_count) - 1);\n-\t   precision_bits *= (u32)ERR_ULP;\n-\t   half_way = (u64)1 << (precision_digits_count - 1);\n-\t   half_way *= (u32)ERR_ULP;\n-\n-\t   /* rounding */\n-\t   fp.sig >>= precision_digits_count;\n-\t   fp.sig += (precision_bits >= half_way + fp_err);\n-\t   fp.exp += precision_digits_count;\n-\n-\t   /* get IEEE double raw value */\n-\t   raw = diy_fp_to_ieee_raw(fp);\n-\t   if (unlikely(raw == F64_RAW_INF)) return_inf();\n-\t   if (likely(precision_bits <= half_way - fp_err ||\n-\t\t\t\t  precision_bits >= half_way + fp_err)) {\n-\t\t   return_f64_raw(raw); /* number is accurate */\n-\t   }\n-\t   /* now the number is the correct value, or the next lower value */\n-\n-\t   /* upper boundary */\n-\t   if (raw & F64_EXP_MASK) {\n-\t\t   fp_upper.sig = (raw & F64_SIG_MASK) + ((u64)1 << F64_SIG_BITS);\n-\t\t   fp_upper.exp = (i32)((raw & F64_EXP_MASK) >> F64_SIG_BITS);\n-\t   } else {\n-\t\t   fp_upper.sig = (raw & F64_SIG_MASK);\n-\t\t   fp_upper.exp = 1;\n-\t   }\n-\t   fp_upper.exp -= F64_EXP_BIAS + F64_SIG_BITS;\n-\t   fp_upper.sig <<= 1;\n-\t   fp_upper.exp -= 1;\n-\t   fp_upper.sig += 1; /* add half ulp */\n-\n-\t   /* compare with bigint */\n-\t   bigint_set_buf(&big_full, sig, &exp, sig_cut, sig_end, dot_pos);\n-\t   bigint_set_u64(&big_comp, fp_upper.sig);\n-\t   if (exp >= 0) {\n-\t\t   bigint_mul_pow10(&big_full, +exp);\n-\t   } else {\n-\t\t   bigint_mul_pow10(&big_comp, -exp);\n-\t   }\n-\t   if (fp_upper.exp > 0) {\n-\t\t   bigint_mul_pow2(&big_comp, (u32)+fp_upper.exp);\n-\t   } else {\n-\t\t   bigint_mul_pow2(&big_full, (u32)-fp_upper.exp);\n-\t   }\n-\t   cmp = bigint_cmp(&big_full, &big_comp);\n-\t   if (likely(cmp != 0)) {\n-\t\t   /* round down or round up */\n-\t\t   raw += (cmp > 0);\n-\t   } else {\n-\t\t   /* falls midway, round to even */\n-\t\t   raw += (raw & 1);\n-\t   }\n-\n-\t   if (unlikely(raw == F64_RAW_INF)) return_inf();\n-\t   return_f64_raw(raw);\n-   }\n-\n+    \n+    /*\n+     Fast path 2:\n+     \n+     To keep it simple, we only accept normal number here,\n+     let the slow path to handle subnormal and infinity number.\n+     */\n+    if (likely(!sig_cut &&\n+               exp > -F64_MAX_DEC_EXP + 1 &&\n+               exp < +F64_MAX_DEC_EXP - 20)) {\n+        /*\n+         The result value is exactly equal to (sig * 10^exp),\n+         the exponent part (10^exp) can be converted to (sig2 * 2^exp2).\n+         \n+         The sig2 can be an infinite length number, only the highest 128 bits\n+         is cached in the pow10_sig_table.\n+         \n+         Now we have these bits:\n+         sig1 (normalized 64bit)        : aaaaaaaa\n+         sig2 (higher 64bit)            : bbbbbbbb\n+         sig2_ext (lower 64bit)         : cccccccc\n+         sig2_cut (extra unknown bits)  : dddddddddddd....\n+         \n+         And the calculation process is:\n+         ----------------------------------------\n+                 aaaaaaaa *\n+                 bbbbbbbbccccccccdddddddddddd....\n+         ----------------------------------------\n+         abababababababab +\n+                 acacacacacacacac +\n+                         adadadadadadadadadad....\n+         ----------------------------------------\n+         [hi____][lo____] +\n+                 [hi2___][lo2___] +\n+                         [unknown___________....]\n+         ----------------------------------------\n+         \n+         The addition with carry may affect higher bits, but if there is a 0\n+         in higher bits, the bits higher than 0 will not be affected.\n+         \n+         `lo2` + `unknown` may get a carry bit and may affect `hi2`, the max\n+         value of `hi2` is 0xFFFFFFFFFFFFFFFE, so `hi2` will not overflow.\n+         \n+         `lo` + `hi2` may also get a carry bit and may affect `hi`, but only\n+         the highest significant 53 bits of `hi` is needed. If there is a 0\n+         in the lower bits of `hi`, then all the following bits can be dropped.\n+         \n+         To convert the result to IEEE-754 double number, we need to perform\n+         correct rounding:\n+         1. if bit 54 is 0, round down,\n+         2. if bit 54 is 1 and any bit beyond bit 54 is 1, round up,\n+         3. if bit 54 is 1 and all bits beyond bit 54 are 0, round to even,\n+            as the extra bits is unknown, this case will not be handled here.\n+         */\n+        \n+        u64 raw;\n+        u64 sig1, sig2, sig2_ext, hi, lo, hi2, lo2, add, bits;\n+        i32 exp2;\n+        u32 lz;\n+        bool exact = false, carry, round_up;\n+        \n+        /* convert (10^exp) to (sig2 * 2^exp2) */\n+        pow10_table_get_sig(exp, &sig2, &sig2_ext);\n+        pow10_table_get_exp(exp, &exp2);\n+        \n+        /* normalize and multiply */\n+        lz = u64_lz_bits(sig);\n+        sig1 = sig << lz;\n+        exp2 -= (i32)lz;\n+        u128_mul(sig1, sig2, &hi, &lo);\n+        \n+        /*\n+         The `hi` is in range [0x4000000000000000, 0xFFFFFFFFFFFFFFFE],\n+         To get normalized value, `hi` should be shifted to the left by 0 or 1.\n+         \n+         The highest significant 53 bits is used by IEEE-754 double number,\n+         and the bit 54 is used to detect rounding direction.\n+         \n+         The lowest (64 - 54 - 1) bits is used to check whether it contains 0.\n+         */\n+        bits = hi & (((u64)1 << (64 - 54 - 1)) - 1);\n+        if (bits - 1 < (((u64)1 << (64 - 54 - 1)) - 2)) {\n+            /*\n+             (bits != 0 && bits != 0x1FF) => (bits - 1 < 0x1FF - 1)\n+             The `bits` is not zero, so we don't need to check `round to even`\n+             case. The `bits` contains bit `0`, so we can drop the extra bits\n+             after `0`.\n+             */\n+            exact = true;\n+            \n+        } else {\n+            /*\n+             (bits == 0 || bits == 0x1FF)\n+             The `bits` is filled with all `0` or all `1`, so we need to check\n+             lower bits with another 64-bit multiplication.\n+             */\n+            u128_mul(sig1, sig2_ext, &hi2, &lo2);\n+            \n+            add = lo + hi2;\n+            if (add + 1 > (u64)1) {\n+                /*\n+                 (add != 0 && add != U64_MAX) => (add + 1 > 1)\n+                 The `add` is not zero, so we don't need to check `round to\n+                 even` case. The `add` contains bit `0`, so we can drop the\n+                 extra bits after `0`. The `hi` cannot be U64_MAX, so it will\n+                 not overflow.\n+                 */\n+                carry = add < lo || add < hi2;\n+                hi += carry;\n+                exact = true;\n+            }\n+        }\n+        \n+        if (exact) {\n+            /* normalize */\n+            lz = hi < ((u64)1 << 63);\n+            hi <<= lz;\n+            exp2 -= (i32)lz;\n+            exp2 += 64;\n+            \n+            /* test the bit 54 and get rounding direction */\n+            round_up = (hi & ((u64)1 << (64 - 54))) > (u64)0;\n+            hi += (round_up ? ((u64)1 << (64 - 54)) : (u64)0);\n+            \n+            /* test overflow */\n+            if (hi < ((u64)1 << (64 - 54))) {\n+                hi = ((u64)1 << 63);\n+                exp2 += 1;\n+            }\n+            \n+            /* This is a normal number, convert it to IEEE-754 format. */\n+            hi >>= F64_BITS - F64_SIG_FULL_BITS;\n+            exp2 += F64_BITS - F64_SIG_FULL_BITS + F64_SIG_BITS;\n+            exp2 += F64_EXP_BIAS;\n+            raw = ((u64)exp2 << F64_SIG_BITS) | (hi & F64_SIG_MASK);\n+            return_f64_raw(raw);\n+        }\n+    }\n+    \n+    /*\n+     Slow path: read double number exactly with diyfp.\n+     1. Use cached diyfp to get an approximation value.\n+     2. Use bigcomp to check the approximation value if needed.\n+     \n+     This algorithm refers to google's double-conversion project:\n+     https://github.com/google/double-conversion\n+     */\n+    {\n+        const i32 ERR_ULP_LOG = 3;\n+        const i32 ERR_ULP = 1 << ERR_ULP_LOG;\n+        const i32 ERR_CACHED_POW = ERR_ULP / 2;\n+        const i32 ERR_MUL_FIXED = ERR_ULP / 2;\n+        const i32 DIY_SIG_BITS = 64;\n+        const i32 EXP_BIAS = F64_EXP_BIAS + F64_SIG_BITS;\n+        const i32 EXP_SUBNORMAL = -EXP_BIAS + 1;\n+        \n+        u64 fp_err;\n+        u32 bits;\n+        i32 order_of_magnitude;\n+        i32 effective_significand_size;\n+        i32 precision_digits_count;\n+        u64 precision_bits;\n+        u64 half_way;\n+        \n+        u64 raw;\n+        diy_fp fp, fp_upper;\n+        bigint big_full, big_comp;\n+        i32 cmp;\n+        \n+        fp.sig = sig;\n+        fp.exp = 0;\n+        fp_err = sig_cut ? (u64)(ERR_ULP / 2) : (u64)0;\n+        \n+        /* normalize */\n+        bits = u64_lz_bits(fp.sig);\n+        fp.sig <<= bits;\n+        fp.exp -= (i32)bits;\n+        fp_err <<= bits;\n+        \n+        /* multiply and add error */\n+        fp = diy_fp_mul(fp, diy_fp_get_cached_pow10(exp));\n+        fp_err += (u64)ERR_CACHED_POW + (fp_err != 0) + (u64)ERR_MUL_FIXED;\n+        \n+        /* normalize */\n+        bits = u64_lz_bits(fp.sig);\n+        fp.sig <<= bits;\n+        fp.exp -= (i32)bits;\n+        fp_err <<= bits;\n+        \n+        /* effective significand */\n+        order_of_magnitude = DIY_SIG_BITS + fp.exp;\n+        if (likely(order_of_magnitude >= EXP_SUBNORMAL + F64_SIG_FULL_BITS)) {\n+            effective_significand_size = F64_SIG_FULL_BITS;\n+        } else if (order_of_magnitude <= EXP_SUBNORMAL) {\n+            effective_significand_size = 0;\n+        } else {\n+            effective_significand_size = order_of_magnitude - EXP_SUBNORMAL;\n+        }\n+        \n+        /* precision digits count */\n+        precision_digits_count = DIY_SIG_BITS - effective_significand_size;\n+        if (unlikely(precision_digits_count + ERR_ULP_LOG >= DIY_SIG_BITS)) {\n+            i32 shr = (precision_digits_count + ERR_ULP_LOG) - DIY_SIG_BITS + 1;\n+            fp.sig >>= shr;\n+            fp.exp += shr;\n+            fp_err = (fp_err >> shr) + 1 + (u32)ERR_ULP;\n+            precision_digits_count -= shr;\n+        }\n+        \n+        /* half way */\n+        precision_bits = fp.sig & (((u64)1 << precision_digits_count) - 1);\n+        precision_bits *= (u32)ERR_ULP;\n+        half_way = (u64)1 << (precision_digits_count - 1);\n+        half_way *= (u32)ERR_ULP;\n+        \n+        /* rounding */\n+        fp.sig >>= precision_digits_count;\n+        fp.sig += (precision_bits >= half_way + fp_err);\n+        fp.exp += precision_digits_count;\n+        \n+        /* get IEEE double raw value */\n+        raw = diy_fp_to_ieee_raw(fp);\n+        if (unlikely(raw == F64_RAW_INF)) return_inf();\n+        if (likely(precision_bits <= half_way - fp_err ||\n+                   precision_bits >= half_way + fp_err)) {\n+            return_f64_raw(raw); /* number is accurate */\n+        }\n+        /* now the number is the correct value, or the next lower value */\n+        \n+        /* upper boundary */\n+        if (raw & F64_EXP_MASK) {\n+            fp_upper.sig = (raw & F64_SIG_MASK) + ((u64)1 << F64_SIG_BITS);\n+            fp_upper.exp = (i32)((raw & F64_EXP_MASK) >> F64_SIG_BITS);\n+        } else {\n+            fp_upper.sig = (raw & F64_SIG_MASK);\n+            fp_upper.exp = 1;\n+        }\n+        fp_upper.exp -= F64_EXP_BIAS + F64_SIG_BITS;\n+        fp_upper.sig <<= 1;\n+        fp_upper.exp -= 1;\n+        fp_upper.sig += 1; /* add half ulp */\n+        \n+        /* compare with bigint */\n+        bigint_set_buf(&big_full, sig, &exp, sig_cut, sig_end, dot_pos);\n+        bigint_set_u64(&big_comp, fp_upper.sig);\n+        if (exp >= 0) {\n+            bigint_mul_pow10(&big_full, +exp);\n+        } else {\n+            bigint_mul_pow10(&big_comp, -exp);\n+        }\n+        if (fp_upper.exp > 0) {\n+            bigint_mul_pow2(&big_comp, (u32)+fp_upper.exp);\n+        } else {\n+            bigint_mul_pow2(&big_full, (u32)-fp_upper.exp);\n+        }\n+        cmp = bigint_cmp(&big_full, &big_comp);\n+        if (likely(cmp != 0)) {\n+            /* round down or round up */\n+            raw += (cmp > 0);\n+        } else {\n+            /* falls midway, round to even */\n+            raw += (raw & 1);\n+        }\n+        \n+        if (unlikely(raw == F64_RAW_INF)) return_inf();\n+        return_f64_raw(raw);\n+    }\n+    \n #undef has_flag\n #undef return_err\n #undef return_inf\n@@ -3883,160 +3997,160 @@ static_inline bool read_number(u8 **ptr,\n #else /* FP_READER */\n \n /**\n-Read a JSON number.\n-This is a fallback function if the custom number reader is disabled.\n-This function use libc's strtod() to read floating-point number.\n-*/\n+ Read a JSON number.\n+ This is a fallback function if the custom number reader is disabled.\n+ This function use libc's strtod() to read floating-point number.\n+ */\n static_noinline bool read_number(u8 **ptr,\n-\t\t\t\t\t\t\t\tu8 **pre,\n-\t\t\t\t\t\t\t\tbool ext,\n-\t\t\t\t\t\t\t\tyyjson_val *val,\n-\t\t\t\t\t\t\t\tconst char **msg) {\n-\n+                                 u8 **pre,\n+                                 bool ext,\n+                                 yyjson_val *val,\n+                                 const char **msg) {\n+    \n #define return_err(_pos, _msg) do { \\\n-   *msg = _msg; \\\n-   *end = _pos; \\\n-   return false; \\\n+    *msg = _msg; \\\n+    *end = _pos; \\\n+    return false; \\\n } while (false)\n-\n+    \n #define return_i64(_v) do { \\\n-   val->tag = YYJSON_TYPE_NUM | (u64)((u8)sign << 3); \\\n-   val->uni.u64 = (u64)(sign ? (u64)(~(_v) + 1) : (u64)(_v)); \\\n-   *end = cur; return true; \\\n+    val->tag = YYJSON_TYPE_NUM | (u64)((u8)sign << 3); \\\n+    val->uni.u64 = (u64)(sign ? (u64)(~(_v) + 1) : (u64)(_v)); \\\n+    *end = cur; return true; \\\n } while (false)\n-\n+    \n #define return_f64(_v) do { \\\n-   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL; \\\n-   val->uni.f64 = sign ? -(f64)(_v) : (f64)(_v); \\\n-   *end = cur; return true; \\\n+    val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL; \\\n+    val->uni.f64 = sign ? -(f64)(_v) : (f64)(_v); \\\n+    *end = cur; return true; \\\n } while (false)\n-\n+    \n #define return_f64_raw(_v) do { \\\n-   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL; \\\n-   val->uni.u64 = ((u64)sign << 63) | (u64)(_v); \\\n-   *end = cur; return true; \\\n+    val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL; \\\n+    val->uni.u64 = ((u64)sign << 63) | (u64)(_v); \\\n+    *end = cur; return true; \\\n } while (false)\n-\n-   u64 sig, num;\n-   u8 *hdr = *ptr;\n-   u8 *cur = *ptr;\n-   u8 **end = ptr;\n-   u8 *dot = NULL;\n-   u8 *f64_end = NULL;\n-   bool sign;\n-\n-   /* read number as raw string if has flag */\n-   if (unlikely(pre)) {\n-\t   return read_number_raw(ptr, pre, ext, val, msg);\n-   }\n-\n-   sign = (*hdr == '-');\n-   cur += sign;\n-   sig = (u8)(*cur - '0');\n-\n-   /* read first digit, check leading zero */\n-   if (unlikely(!digi_is_digit(*cur))) {\n-\t   if (unlikely(ext)) {\n-\t\t   if (read_inf_or_nan(sign, &cur, pre, val)) {\n-\t\t\t   *end = cur;\n-\t\t\t   return true;\n-\t\t   }\n-\t   }\n-\t   return_err(cur - 1, \"no digit after minus sign\");\n-   }\n-   if (*cur == '0') {\n-\t   cur++;\n-\t   if (unlikely(digi_is_digit(*cur))) {\n-\t\t   return_err(cur - 1, \"number with leading zero is not allowed\");\n-\t   }\n-\t   if (!digi_is_fp(*cur)) return_i64(0);\n-\t   goto read_double;\n-   }\n-\n-   /* read continuous digits, up to 19 characters */\n+    \n+    u64 sig, num;\n+    u8 *hdr = *ptr;\n+    u8 *cur = *ptr;\n+    u8 **end = ptr;\n+    u8 *dot = NULL;\n+    u8 *f64_end = NULL;\n+    bool sign;\n+    \n+    /* read number as raw string if has flag */\n+    if (unlikely(pre)) {\n+        return read_number_raw(ptr, pre, ext, val, msg);\n+    }\n+    \n+    sign = (*hdr == '-');\n+    cur += sign;\n+    sig = (u8)(*cur - '0');\n+    \n+    /* read first digit, check leading zero */\n+    if (unlikely(!digi_is_digit(*cur))) {\n+        if (unlikely(ext)) {\n+            if (read_inf_or_nan(sign, &cur, pre, val)) {\n+                *end = cur;\n+                return true;\n+            }\n+        }\n+        return_err(cur - 1, \"no digit after minus sign\");\n+    }\n+    if (*cur == '0') {\n+        cur++;\n+        if (unlikely(digi_is_digit(*cur))) {\n+            return_err(cur - 1, \"number with leading zero is not allowed\");\n+        }\n+        if (!digi_is_fp(*cur)) return_i64(0);\n+        goto read_double;\n+    }\n+    \n+    /* read continuous digits, up to 19 characters */\n #define expr_intg(i) \\\n-   if (likely((num = (u64)(cur[i] - (u8)'0')) <= 9)) sig = num + sig * 10; \\\n-   else { cur += i; goto intg_end; }\n-   repeat_in_1_18(expr_intg);\n+    if (likely((num = (u64)(cur[i] - (u8)'0')) <= 9)) sig = num + sig * 10; \\\n+    else { cur += i; goto intg_end; }\n+    repeat_in_1_18(expr_intg);\n #undef expr_intg\n-\n-   /* here are 19 continuous digits, skip them */\n-   cur += 19;\n-   if (digi_is_digit(cur[0]) && !digi_is_digit_or_fp(cur[1])) {\n-\t   /* this number is an integer consisting of 20 digits */\n-\t   num = (u8)(*cur - '0');\n-\t   if ((sig < (U64_MAX / 10)) ||\n-\t\t   (sig == (U64_MAX / 10) && num <= (U64_MAX % 10))) {\n-\t\t   sig = num + sig * 10;\n-\t\t   cur++;\n-\t\t   if (sign) return_f64(normalized_u64_to_f64(sig));\n-\t\t   return_i64(sig);\n-\t   }\n-   }\n-\n+    \n+    /* here are 19 continuous digits, skip them */\n+    cur += 19;\n+    if (digi_is_digit(cur[0]) && !digi_is_digit_or_fp(cur[1])) {\n+        /* this number is an integer consisting of 20 digits */\n+        num = (u8)(*cur - '0');\n+        if ((sig < (U64_MAX / 10)) ||\n+            (sig == (U64_MAX / 10) && num <= (U64_MAX % 10))) {\n+            sig = num + sig * 10;\n+            cur++;\n+            if (sign) return_f64(normalized_u64_to_f64(sig));\n+            return_i64(sig);\n+        }\n+    }\n+    \n intg_end:\n-   /* continuous digits ended */\n-   if (!digi_is_digit_or_fp(*cur)) {\n-\t   /* this number is an integer consisting of 1 to 19 digits */\n-\t   if (sign && (sig > ((u64)1 << 63))) {\n-\t\t   return_f64(normalized_u64_to_f64(sig));\n-\t   }\n-\t   return_i64(sig);\n-   }\n-\n+    /* continuous digits ended */\n+    if (!digi_is_digit_or_fp(*cur)) {\n+        /* this number is an integer consisting of 1 to 19 digits */\n+        if (sign && (sig > ((u64)1 << 63))) {\n+            return_f64(normalized_u64_to_f64(sig));\n+        }\n+        return_i64(sig);\n+    }\n+    \n read_double:\n-   /* this number should be read as double */\n-   while (digi_is_digit(*cur)) cur++;\n-   if (*cur == '.') {\n-\t   /* skip fraction part */\n-\t   dot = cur;\n-\t   cur++;\n-\t   if (!digi_is_digit(*cur++)) {\n-\t\t   return_err(cur - 1, \"no digit after decimal point\");\n-\t   }\n-\t   while (digi_is_digit(*cur)) cur++;\n-   }\n-   if (digi_is_exp(*cur)) {\n-\t   /* skip exponent part */\n-\t   cur += 1 + digi_is_sign(cur[1]);\n-\t   if (!digi_is_digit(*cur++)) {\n-\t\t   return_err(cur - 1, \"no digit after exponent sign\");\n-\t   }\n-\t   while (digi_is_digit(*cur)) cur++;\n-   }\n-\n-   /*\n-\tlibc's strtod() is used to parse the floating-point number.\n-\n-\tNote that the decimal point character used by strtod() is locale-dependent,\n-\tand the rounding direction may affected by fesetround().\n-\n-\tFor currently known locales, (en, zh, ja, ko, am, he, hi) use '.' as the\n-\tdecimal point, while other locales use ',' as the decimal point.\n-\n-\tHere strtod() is called twice for different locales, but if another thread\n-\thappens calls setlocale() between two strtod(), parsing may still fail.\n-\t*/\n-   val->uni.f64 = strtod((const char *)hdr, (char **)&f64_end);\n-   if (unlikely(f64_end != cur)) {\n-\t   bool cut = (*cur == ',');\n-\t   if (dot) *dot = ',';\n-\t   if (cut) *cur = ' ';\n-\t   val->uni.f64 = strtod((const char *)hdr, (char **)&f64_end);\n-\t   if (cut) *cur = ',';\n-\t   if (unlikely(f64_end != cur)) {\n-\t\t   return_err(hdr, \"strtod() failed to parse the number\");\n-\t   }\n-   }\n-   if (unlikely(val->uni.f64 == HUGE_VAL || val->uni.f64 == -HUGE_VAL)) {\n-\t   if (!ext) {\n-\t\t   return_err(hdr, \"number is infinity when parsed as double\");\n-\t   }\n-   }\n-   val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n-   *end = cur;\n-   return true;\n-\n+    /* this number should be read as double */\n+    while (digi_is_digit(*cur)) cur++;\n+    if (*cur == '.') {\n+        /* skip fraction part */\n+        dot = cur;\n+        cur++;\n+        if (!digi_is_digit(*cur++)) {\n+            return_err(cur - 1, \"no digit after decimal point\");\n+        }\n+        while (digi_is_digit(*cur)) cur++;\n+    }\n+    if (digi_is_exp(*cur)) {\n+        /* skip exponent part */\n+        cur += 1 + digi_is_sign(cur[1]);\n+        if (!digi_is_digit(*cur++)) {\n+            return_err(cur - 1, \"no digit after exponent sign\");\n+        }\n+        while (digi_is_digit(*cur)) cur++;\n+    }\n+    \n+    /*\n+     libc's strtod() is used to parse the floating-point number.\n+     \n+     Note that the decimal point character used by strtod() is locale-dependent,\n+     and the rounding direction may affected by fesetround().\n+     \n+     For currently known locales, (en, zh, ja, ko, am, he, hi) use '.' as the\n+     decimal point, while other locales use ',' as the decimal point.\n+     \n+     Here strtod() is called twice for different locales, but if another thread\n+     happens calls setlocale() between two strtod(), parsing may still fail.\n+     */\n+    val->uni.f64 = strtod((const char *)hdr, (char **)&f64_end);\n+    if (unlikely(f64_end != cur)) {\n+        bool cut = (*cur == ',');\n+        if (dot) *dot = ',';\n+        if (cut) *cur = ' ';\n+        val->uni.f64 = strtod((const char *)hdr, (char **)&f64_end);\n+        if (cut) *cur = ',';\n+        if (unlikely(f64_end != cur)) {\n+            return_err(hdr, \"strtod() failed to parse the number\");\n+        }\n+    }\n+    if (unlikely(val->uni.f64 == HUGE_VAL || val->uni.f64 == -HUGE_VAL)) {\n+        if (!ext) {\n+            return_err(hdr, \"number is infinity when parsed as double\");\n+        }\n+    }\n+    val->tag = YYJSON_TYPE_NUM | YYJSON_SUBTYPE_REAL;\n+    *end = cur;\n+    return true;\n+    \n #undef has_flag\n #undef return_err\n #undef return_i64\n@@ -4048,454 +4162,454 @@ static_noinline bool read_number(u8 **ptr,\n \n \n /*==============================================================================\n-* JSON String Reader\n-*============================================================================*/\n+ * JSON String Reader\n+ *============================================================================*/\n \n /**\n-Read a JSON string.\n-@param ptr The head pointer of string before '\"' prefix (inout).\n-@param lst JSON last position.\n-@param inv Allow invalid unicode.\n-@param val The string value to be written.\n-@param msg The error message pointer.\n-@return Whether success.\n-*/\n+ Read a JSON string.\n+ @param ptr The head pointer of string before '\"' prefix (inout).\n+ @param lst JSON last position.\n+ @param inv Allow invalid unicode.\n+ @param val The string value to be written.\n+ @param msg The error message pointer.\n+ @return Whether success.\n+ */\n static_inline bool read_string(u8 **ptr,\n-\t\t\t\t\t\t\t  u8 *lst,\n-\t\t\t\t\t\t\t  bool inv,\n-\t\t\t\t\t\t\t  yyjson_val *val,\n-\t\t\t\t\t\t\t  const char **msg) {\n-   /*\n-\tEach unicode code point is encoded as 1 to 4 bytes in UTF-8 encoding,\n-\twe use 4-byte mask and pattern value to validate UTF-8 byte sequence,\n-\tthis requires the input data to have 4-byte zero padding.\n-\t---------------------------------------------------\n-\t1 byte\n-\tunicode range [U+0000, U+007F]\n-\tunicode min   [.......0]\n-\tunicode max   [.1111111]\n-\tbit pattern   [0.......]\n-\t---------------------------------------------------\n-\t2 byte\n-\tunicode range [U+0080, U+07FF]\n-\tunicode min   [......10 ..000000]\n-\tunicode max   [...11111 ..111111]\n-\tbit require   [...xxxx. ........] (1E 00)\n-\tbit mask      [xxx..... xx......] (E0 C0)\n-\tbit pattern   [110..... 10......] (C0 80)\n-\t---------------------------------------------------\n-\t3 byte\n-\tunicode range [U+0800, U+FFFF]\n-\tunicode min   [........ ..100000 ..000000]\n-\tunicode max   [....1111 ..111111 ..111111]\n-\tbit require   [....xxxx ..x..... ........] (0F 20 00)\n-\tbit mask      [xxxx.... xx...... xx......] (F0 C0 C0)\n-\tbit pattern   [1110.... 10...... 10......] (E0 80 80)\n-\t---------------------------------------------------\n-\t3 byte invalid (reserved for surrogate halves)\n-\tunicode range [U+D800, U+DFFF]\n-\tunicode min   [....1101 ..100000 ..000000]\n-\tunicode max   [....1101 ..111111 ..111111]\n-\tbit mask      [....xxxx ..x..... ........] (0F 20 00)\n-\tbit pattern   [....1101 ..1..... ........] (0D 20 00)\n-\t---------------------------------------------------\n-\t4 byte\n-\tunicode range [U+10000, U+10FFFF]\n-\tunicode min   [........ ...10000 ..000000 ..000000]\n-\tunicode max   [.....100 ..001111 ..111111 ..111111]\n-\tbit require   [.....xxx ..xx.... ........ ........] (07 30 00 00)\n-\tbit mask      [xxxxx... xx...... xx...... xx......] (F8 C0 C0 C0)\n-\tbit pattern   [11110... 10...... 10...... 10......] (F0 80 80 80)\n-\t---------------------------------------------------\n-\t*/\n+                               u8 *lst,\n+                               bool inv,\n+                               yyjson_val *val,\n+                               const char **msg) {\n+    /*\n+     Each unicode code point is encoded as 1 to 4 bytes in UTF-8 encoding,\n+     we use 4-byte mask and pattern value to validate UTF-8 byte sequence,\n+     this requires the input data to have 4-byte zero padding.\n+     ---------------------------------------------------\n+     1 byte\n+     unicode range [U+0000, U+007F]\n+     unicode min   [.......0]\n+     unicode max   [.1111111]\n+     bit pattern   [0.......]\n+     ---------------------------------------------------\n+     2 byte\n+     unicode range [U+0080, U+07FF]\n+     unicode min   [......10 ..000000]\n+     unicode max   [...11111 ..111111]\n+     bit require   [...xxxx. ........] (1E 00)\n+     bit mask      [xxx..... xx......] (E0 C0)\n+     bit pattern   [110..... 10......] (C0 80)\n+     ---------------------------------------------------\n+     3 byte\n+     unicode range [U+0800, U+FFFF]\n+     unicode min   [........ ..100000 ..000000]\n+     unicode max   [....1111 ..111111 ..111111]\n+     bit require   [....xxxx ..x..... ........] (0F 20 00)\n+     bit mask      [xxxx.... xx...... xx......] (F0 C0 C0)\n+     bit pattern   [1110.... 10...... 10......] (E0 80 80)\n+     ---------------------------------------------------\n+     3 byte invalid (reserved for surrogate halves)\n+     unicode range [U+D800, U+DFFF]\n+     unicode min   [....1101 ..100000 ..000000]\n+     unicode max   [....1101 ..111111 ..111111]\n+     bit mask      [....xxxx ..x..... ........] (0F 20 00)\n+     bit pattern   [....1101 ..1..... ........] (0D 20 00)\n+     ---------------------------------------------------\n+     4 byte\n+     unicode range [U+10000, U+10FFFF]\n+     unicode min   [........ ...10000 ..000000 ..000000]\n+     unicode max   [.....100 ..001111 ..111111 ..111111]\n+     bit require   [.....xxx ..xx.... ........ ........] (07 30 00 00)\n+     bit mask      [xxxxx... xx...... xx...... xx......] (F8 C0 C0 C0)\n+     bit pattern   [11110... 10...... 10...... 10......] (F0 80 80 80)\n+     ---------------------------------------------------\n+     */\n #if YYJSON_ENDIAN == YYJSON_BIG_ENDIAN\n-   const u32 b1_mask = 0x80000000UL;\n-   const u32 b1_patt = 0x00000000UL;\n-   const u32 b2_mask = 0xE0C00000UL;\n-   const u32 b2_patt = 0xC0800000UL;\n-   const u32 b2_requ = 0x1E000000UL;\n-   const u32 b3_mask = 0xF0C0C000UL;\n-   const u32 b3_patt = 0xE0808000UL;\n-   const u32 b3_requ = 0x0F200000UL;\n-   const u32 b3_erro = 0x0D200000UL;\n-   const u32 b4_mask = 0xF8C0C0C0UL;\n-   const u32 b4_patt = 0xF0808080UL;\n-   const u32 b4_requ = 0x07300000UL;\n-   const u32 b4_err0 = 0x04000000UL;\n-   const u32 b4_err1 = 0x03300000UL;\n+    const u32 b1_mask = 0x80000000UL;\n+    const u32 b1_patt = 0x00000000UL;\n+    const u32 b2_mask = 0xE0C00000UL;\n+    const u32 b2_patt = 0xC0800000UL;\n+    const u32 b2_requ = 0x1E000000UL;\n+    const u32 b3_mask = 0xF0C0C000UL;\n+    const u32 b3_patt = 0xE0808000UL;\n+    const u32 b3_requ = 0x0F200000UL;\n+    const u32 b3_erro = 0x0D200000UL;\n+    const u32 b4_mask = 0xF8C0C0C0UL;\n+    const u32 b4_patt = 0xF0808080UL;\n+    const u32 b4_requ = 0x07300000UL;\n+    const u32 b4_err0 = 0x04000000UL;\n+    const u32 b4_err1 = 0x03300000UL;\n #elif YYJSON_ENDIAN == YYJSON_LITTLE_ENDIAN\n-   const u32 b1_mask = 0x00000080UL;\n-   const u32 b1_patt = 0x00000000UL;\n-   const u32 b2_mask = 0x0000C0E0UL;\n-   const u32 b2_patt = 0x000080C0UL;\n-   const u32 b2_requ = 0x0000001EUL;\n-   const u32 b3_mask = 0x00C0C0F0UL;\n-   const u32 b3_patt = 0x008080E0UL;\n-   const u32 b3_requ = 0x0000200FUL;\n-   const u32 b3_erro = 0x0000200DUL;\n-   const u32 b4_mask = 0xC0C0C0F8UL;\n-   const u32 b4_patt = 0x808080F0UL;\n-   const u32 b4_requ = 0x00003007UL;\n-   const u32 b4_err0 = 0x00000004UL;\n-   const u32 b4_err1 = 0x00003003UL;\n+    const u32 b1_mask = 0x00000080UL;\n+    const u32 b1_patt = 0x00000000UL;\n+    const u32 b2_mask = 0x0000C0E0UL;\n+    const u32 b2_patt = 0x000080C0UL;\n+    const u32 b2_requ = 0x0000001EUL;\n+    const u32 b3_mask = 0x00C0C0F0UL;\n+    const u32 b3_patt = 0x008080E0UL;\n+    const u32 b3_requ = 0x0000200FUL;\n+    const u32 b3_erro = 0x0000200DUL;\n+    const u32 b4_mask = 0xC0C0C0F8UL;\n+    const u32 b4_patt = 0x808080F0UL;\n+    const u32 b4_requ = 0x00003007UL;\n+    const u32 b4_err0 = 0x00000004UL;\n+    const u32 b4_err1 = 0x00003003UL;\n #else\n-   v32_uni b1_mask_uni = {{ 0x80, 0x00, 0x00, 0x00 }};\n-   v32_uni b1_patt_uni = {{ 0x00, 0x00, 0x00, 0x00 }};\n-   v32_uni b2_mask_uni = {{ 0xE0, 0xC0, 0x00, 0x00 }};\n-   v32_uni b2_patt_uni = {{ 0xC0, 0x80, 0x00, 0x00 }};\n-   v32_uni b2_requ_uni = {{ 0x1E, 0x00, 0x00, 0x00 }};\n-   v32_uni b3_mask_uni = {{ 0xF0, 0xC0, 0xC0, 0x00 }};\n-   v32_uni b3_patt_uni = {{ 0xE0, 0x80, 0x80, 0x00 }};\n-   v32_uni b3_requ_uni = {{ 0x0F, 0x20, 0x00, 0x00 }};\n-   v32_uni b3_erro_uni = {{ 0x0D, 0x20, 0x00, 0x00 }};\n-   v32_uni b4_mask_uni = {{ 0xF8, 0xC0, 0xC0, 0xC0 }};\n-   v32_uni b4_patt_uni = {{ 0xF0, 0x80, 0x80, 0x80 }};\n-   v32_uni b4_requ_uni = {{ 0x07, 0x30, 0x00, 0x00 }};\n-   v32_uni b4_err0_uni = {{ 0x04, 0x00, 0x00, 0x00 }};\n-   v32_uni b4_err1_uni = {{ 0x03, 0x30, 0x00, 0x00 }};\n-   u32 b1_mask = b1_mask_uni.u;\n-   u32 b1_patt = b1_patt_uni.u;\n-   u32 b2_mask = b2_mask_uni.u;\n-   u32 b2_patt = b2_patt_uni.u;\n-   u32 b2_requ = b2_requ_uni.u;\n-   u32 b3_mask = b3_mask_uni.u;\n-   u32 b3_patt = b3_patt_uni.u;\n-   u32 b3_requ = b3_requ_uni.u;\n-   u32 b3_erro = b3_erro_uni.u;\n-   u32 b4_mask = b4_mask_uni.u;\n-   u32 b4_patt = b4_patt_uni.u;\n-   u32 b4_requ = b4_requ_uni.u;\n-   u32 b4_err0 = b4_err0_uni.u;\n-   u32 b4_err1 = b4_err1_uni.u;\n+    v32_uni b1_mask_uni = {{ 0x80, 0x00, 0x00, 0x00 }};\n+    v32_uni b1_patt_uni = {{ 0x00, 0x00, 0x00, 0x00 }};\n+    v32_uni b2_mask_uni = {{ 0xE0, 0xC0, 0x00, 0x00 }};\n+    v32_uni b2_patt_uni = {{ 0xC0, 0x80, 0x00, 0x00 }};\n+    v32_uni b2_requ_uni = {{ 0x1E, 0x00, 0x00, 0x00 }};\n+    v32_uni b3_mask_uni = {{ 0xF0, 0xC0, 0xC0, 0x00 }};\n+    v32_uni b3_patt_uni = {{ 0xE0, 0x80, 0x80, 0x00 }};\n+    v32_uni b3_requ_uni = {{ 0x0F, 0x20, 0x00, 0x00 }};\n+    v32_uni b3_erro_uni = {{ 0x0D, 0x20, 0x00, 0x00 }};\n+    v32_uni b4_mask_uni = {{ 0xF8, 0xC0, 0xC0, 0xC0 }};\n+    v32_uni b4_patt_uni = {{ 0xF0, 0x80, 0x80, 0x80 }};\n+    v32_uni b4_requ_uni = {{ 0x07, 0x30, 0x00, 0x00 }};\n+    v32_uni b4_err0_uni = {{ 0x04, 0x00, 0x00, 0x00 }};\n+    v32_uni b4_err1_uni = {{ 0x03, 0x30, 0x00, 0x00 }};\n+    u32 b1_mask = b1_mask_uni.u;\n+    u32 b1_patt = b1_patt_uni.u;\n+    u32 b2_mask = b2_mask_uni.u;\n+    u32 b2_patt = b2_patt_uni.u;\n+    u32 b2_requ = b2_requ_uni.u;\n+    u32 b3_mask = b3_mask_uni.u;\n+    u32 b3_patt = b3_patt_uni.u;\n+    u32 b3_requ = b3_requ_uni.u;\n+    u32 b3_erro = b3_erro_uni.u;\n+    u32 b4_mask = b4_mask_uni.u;\n+    u32 b4_patt = b4_patt_uni.u;\n+    u32 b4_requ = b4_requ_uni.u;\n+    u32 b4_err0 = b4_err0_uni.u;\n+    u32 b4_err1 = b4_err1_uni.u;\n #endif\n-\n+    \n #define is_valid_seq_1(uni) ( \\\n-   ((uni & b1_mask) == b1_patt) \\\n+    ((uni & b1_mask) == b1_patt) \\\n )\n \n #define is_valid_seq_2(uni) ( \\\n-   ((uni & b2_mask) == b2_patt) && \\\n-   ((uni & b2_requ)) \\\n+    ((uni & b2_mask) == b2_patt) && \\\n+    ((uni & b2_requ)) \\\n )\n-\n+    \n #define is_valid_seq_3(uni) ( \\\n-   ((uni & b3_mask) == b3_patt) && \\\n-   ((tmp = (uni & b3_requ))) && \\\n-   ((tmp != b3_erro)) \\\n+    ((uni & b3_mask) == b3_patt) && \\\n+    ((tmp = (uni & b3_requ))) && \\\n+    ((tmp != b3_erro)) \\\n )\n-\n+    \n #define is_valid_seq_4(uni) ( \\\n-   ((uni & b4_mask) == b4_patt) && \\\n-   ((tmp = (uni & b4_requ))) && \\\n-   ((tmp & b4_err0) == 0 || (tmp & b4_err1) == 0) \\\n+    ((uni & b4_mask) == b4_patt) && \\\n+    ((tmp = (uni & b4_requ))) && \\\n+    ((tmp & b4_err0) == 0 || (tmp & b4_err1) == 0) \\\n )\n-\n+    \n #define return_err(_end, _msg) do { \\\n-   *msg = _msg; \\\n-   *end = _end; \\\n-   return false; \\\n+    *msg = _msg; \\\n+    *end = _end; \\\n+    return false; \\\n } while (false)\n-\n-   u8 *cur = *ptr;\n-   u8 **end = ptr;\n-   u8 *src = ++cur, *dst, *pos;\n-   u16 hi, lo;\n-   u32 uni, tmp;\n-\n+    \n+    u8 *cur = *ptr;\n+    u8 **end = ptr;\n+    u8 *src = ++cur, *dst, *pos;\n+    u16 hi, lo;\n+    u32 uni, tmp;\n+    \n skip_ascii:\n-   /* Most strings have no escaped characters, so we can jump them quickly. */\n-\n+    /* Most strings have no escaped characters, so we can jump them quickly. */\n+    \n skip_ascii_begin:\n-   /*\n-\tWe want to make loop unrolling, as shown in the following code. Some\n-\tcompiler may not generate instructions as expected, so we rewrite it with\n-\texplicit goto statements. We hope the compiler can generate instructions\n-\tlike this: https://godbolt.org/z/8vjsYq\n-\n-\t\twhile (true) repeat16({\n-\t\t   if (likely(!(char_is_ascii_stop(*src)))) src++;\n-\t\t   else break;\n-\t\t});\n-\t*/\n+    /*\n+     We want to make loop unrolling, as shown in the following code. Some\n+     compiler may not generate instructions as expected, so we rewrite it with\n+     explicit goto statements. We hope the compiler can generate instructions\n+     like this: https://godbolt.org/z/8vjsYq\n+     \n+         while (true) repeat16({\n+            if (likely(!(char_is_ascii_stop(*src)))) src++;\n+            else break;\n+         });\n+     */\n #define expr_jump(i) \\\n-   if (likely(!char_is_ascii_stop(src[i]))) {} \\\n-   else goto skip_ascii_stop##i;\n-\n+    if (likely(!char_is_ascii_stop(src[i]))) {} \\\n+    else goto skip_ascii_stop##i;\n+    \n #define expr_stop(i) \\\n-   skip_ascii_stop##i: \\\n-   src += i; \\\n-   goto skip_ascii_end;\n-\n-   repeat16_incr(expr_jump);\n-   src += 16;\n-   goto skip_ascii_begin;\n-   repeat16_incr(expr_stop);\n-\n+    skip_ascii_stop##i: \\\n+    src += i; \\\n+    goto skip_ascii_end;\n+    \n+    repeat16_incr(expr_jump);\n+    src += 16;\n+    goto skip_ascii_begin;\n+    repeat16_incr(expr_stop);\n+    \n #undef expr_jump\n #undef expr_stop\n-\n+    \n skip_ascii_end:\n-\n-   /*\n-\tGCC may store src[i] in a register at each line of expr_jump(i) above.\n-\tThese instructions are useless and will degrade performance.\n-\tThis inline asm is a hint for gcc: \"the memory has been modified,\n-\tdo not cache it\".\n-\n-\tMSVC, Clang, ICC can generate expected instructions without this hint.\n-\t*/\n+    \n+    /*\n+     GCC may store src[i] in a register at each line of expr_jump(i) above.\n+     These instructions are useless and will degrade performance.\n+     This inline asm is a hint for gcc: \"the memory has been modified,\n+     do not cache it\".\n+     \n+     MSVC, Clang, ICC can generate expected instructions without this hint.\n+     */\n #if YYJSON_IS_REAL_GCC\n-   __asm volatile(\"\":\"=m\"(*src)::);\n+    __asm__ volatile(\"\":\"=m\"(*src));\n #endif\n-   if (likely(*src == '\"')) {\n-\t   val->tag = ((u64)(src - cur) << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t   val->uni.str = (const char *)cur;\n-\t   *src = '\\0';\n-\t   *end = src + 1;\n-\t   return true;\n-   }\n-\n+    if (likely(*src == '\"')) {\n+        val->tag = ((u64)(src - cur) << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+        val->uni.str = (const char *)cur;\n+        *src = '\\0';\n+        *end = src + 1;\n+        return true;\n+    }\n+    \n skip_utf8:\n-   if (*src & 0x80) { /* non-ASCII character */\n-\t   /*\n-\t\tNon-ASCII character appears here, which means that the text is likely\n-\t\tto be written in non-English or emoticons. According to some common\n-\t\tdata set statistics, byte sequences of the same length may appear\n-\t\tconsecutively. We process the byte sequences of the same length in each\n-\t\tloop, which is more friendly to branch prediction.\n-\t\t*/\n-\t   pos = src;\n-\t   uni = byte_load_4(src);\n-\t   while (is_valid_seq_3(uni)) {\n-\t\t   src += 3;\n-\t\t   uni = byte_load_4(src);\n-\t   }\n-\t   if (is_valid_seq_1(uni)) goto skip_ascii;\n-\t   while (is_valid_seq_2(uni)) {\n-\t\t   src += 2;\n-\t\t   uni = byte_load_4(src);\n-\t   }\n-\t   while (is_valid_seq_4(uni)) {\n-\t\t   src += 4;\n-\t\t   uni = byte_load_4(src);\n-\t   }\n-\t   if (unlikely(pos == src)) {\n-\t\t   if (!inv) return_err(src, \"invalid UTF-8 encoding in string\");\n-\t\t   ++src;\n-\t   }\n-\t   goto skip_ascii;\n-   }\n-\n-   /* The escape character appears, we need to copy it. */\n-   dst = src;\n+    if (*src & 0x80) { /* non-ASCII character */\n+        /*\n+         Non-ASCII character appears here, which means that the text is likely\n+         to be written in non-English or emoticons. According to some common\n+         data set statistics, byte sequences of the same length may appear\n+         consecutively. We process the byte sequences of the same length in each\n+         loop, which is more friendly to branch prediction.\n+         */\n+        pos = src;\n+        uni = byte_load_4(src);\n+        while (is_valid_seq_3(uni)) {\n+            src += 3;\n+            uni = byte_load_4(src);\n+        }\n+        if (is_valid_seq_1(uni)) goto skip_ascii;\n+        while (is_valid_seq_2(uni)) {\n+            src += 2;\n+            uni = byte_load_4(src);\n+        }\n+        while (is_valid_seq_4(uni)) {\n+            src += 4;\n+            uni = byte_load_4(src);\n+        }\n+        if (unlikely(pos == src)) {\n+            if (!inv) return_err(src, \"invalid UTF-8 encoding in string\");\n+            ++src;\n+        }\n+        goto skip_ascii;\n+    }\n+    \n+    /* The escape character appears, we need to copy it. */\n+    dst = src;\n copy_escape:\n-   if (likely(*src == '\\\\')) {\n-\t   switch (*++src) {\n-\t   case '\"':  *dst++ = '\"';  src++; break;\n-\t   case '\\\\': *dst++ = '\\\\'; src++; break;\n-\t   case '/':  *dst++ = '/';  src++; break;\n-\t   case 'b':  *dst++ = '\\b'; src++; break;\n-\t   case 'f':  *dst++ = '\\f'; src++; break;\n-\t   case 'n':  *dst++ = '\\n'; src++; break;\n-\t   case 'r':  *dst++ = '\\r'; src++; break;\n-\t   case 't':  *dst++ = '\\t'; src++; break;\n-\t   case 'u':\n-\t\t   if (unlikely(!read_hex_u16(++src, &hi))) {\n-\t\t\t   return_err(src - 2, \"invalid escaped unicode in string\");\n-\t\t   }\n-\t\t   src += 4;\n-\t\t   if (likely((hi & 0xF800) != 0xD800)) {\n-\t\t\t   /* a BMP character */\n-\t\t\t   if (hi >= 0x800) {\n-\t\t\t\t   *dst++ = (u8)(0xE0 | (hi >> 12));\n-\t\t\t\t   *dst++ = (u8)(0x80 | ((hi >> 6) & 0x3F));\n-\t\t\t\t   *dst++ = (u8)(0x80 | (hi & 0x3F));\n-\t\t\t   } else if (hi >= 0x80) {\n-\t\t\t\t   *dst++ = (u8)(0xC0 | (hi >> 6));\n-\t\t\t\t   *dst++ = (u8)(0x80 | (hi & 0x3F));\n-\t\t\t   } else {\n-\t\t\t\t   *dst++ = (u8)hi;\n-\t\t\t   }\n-\t\t   } else {\n-\t\t\t   /* a non-BMP character, represented as a surrogate pair */\n-\t\t\t   if (unlikely((hi & 0xFC00) != 0xD800)) {\n-\t\t\t\t   return_err(src - 6, \"invalid high surrogate in string\");\n-\t\t\t   }\n-\t\t\t   if (unlikely(!byte_match_2(src, \"\\\\u\")) ||\n-\t\t\t\t   unlikely(!read_hex_u16(src + 2, &lo))) {\n-\t\t\t\t   return_err(src, \"no matched low surrogate in string\");\n-\t\t\t   }\n-\t\t\t   if (unlikely((lo & 0xFC00) != 0xDC00)) {\n-\t\t\t\t   return_err(src, \"invalid low surrogate in string\");\n-\t\t\t   }\n-\t\t\t   uni = ((((u32)hi - 0xD800) << 10) |\n-\t\t\t\t\t  ((u32)lo - 0xDC00)) + 0x10000;\n-\t\t\t   *dst++ = (u8)(0xF0 | (uni >> 18));\n-\t\t\t   *dst++ = (u8)(0x80 | ((uni >> 12) & 0x3F));\n-\t\t\t   *dst++ = (u8)(0x80 | ((uni >> 6) & 0x3F));\n-\t\t\t   *dst++ = (u8)(0x80 | (uni & 0x3F));\n-\t\t\t   src += 6;\n-\t\t   }\n-\t\t   break;\n-\t   default: return_err(src, \"invalid escaped character in string\");\n-\t   }\n-   } else if (likely(*src == '\"')) {\n-\t   val->tag = ((u64)(dst - cur) << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n-\t   val->uni.str = (const char *)cur;\n-\t   *dst = '\\0';\n-\t   *end = src + 1;\n-\t   return true;\n-   } else {\n-\t   if (!inv) return_err(src, \"unexpected control character in string\");\n-\t   if (src >= lst) return_err(src, \"unclosed string\");\n-\t   *dst++ = *src++;\n-   }\n-\n+    if (likely(*src == '\\\\')) {\n+        switch (*++src) {\n+            case '\"':  *dst++ = '\"';  src++; break;\n+            case '\\\\': *dst++ = '\\\\'; src++; break;\n+            case '/':  *dst++ = '/';  src++; break;\n+            case 'b':  *dst++ = '\\b'; src++; break;\n+            case 'f':  *dst++ = '\\f'; src++; break;\n+            case 'n':  *dst++ = '\\n'; src++; break;\n+            case 'r':  *dst++ = '\\r'; src++; break;\n+            case 't':  *dst++ = '\\t'; src++; break;\n+            case 'u':\n+                if (unlikely(!read_hex_u16(++src, &hi))) {\n+                    return_err(src - 2, \"invalid escaped unicode in string\");\n+                }\n+                src += 4;\n+                if (likely((hi & 0xF800) != 0xD800)) {\n+                    /* a BMP character */\n+                    if (hi >= 0x800) {\n+                        *dst++ = (u8)(0xE0 | (hi >> 12));\n+                        *dst++ = (u8)(0x80 | ((hi >> 6) & 0x3F));\n+                        *dst++ = (u8)(0x80 | (hi & 0x3F));\n+                    } else if (hi >= 0x80) {\n+                        *dst++ = (u8)(0xC0 | (hi >> 6));\n+                        *dst++ = (u8)(0x80 | (hi & 0x3F));\n+                    } else {\n+                        *dst++ = (u8)hi;\n+                    }\n+                } else {\n+                    /* a non-BMP character, represented as a surrogate pair */\n+                    if (unlikely((hi & 0xFC00) != 0xD800)) {\n+                        return_err(src - 6, \"invalid high surrogate in string\");\n+                    }\n+                    if (unlikely(!byte_match_2(src, \"\\\\u\")) ||\n+                        unlikely(!read_hex_u16(src + 2, &lo))) {\n+                        return_err(src, \"no matched low surrogate in string\");\n+                    }\n+                    if (unlikely((lo & 0xFC00) != 0xDC00)) {\n+                        return_err(src, \"invalid low surrogate in string\");\n+                    }\n+                    uni = ((((u32)hi - 0xD800) << 10) |\n+                            ((u32)lo - 0xDC00)) + 0x10000;\n+                    *dst++ = (u8)(0xF0 | (uni >> 18));\n+                    *dst++ = (u8)(0x80 | ((uni >> 12) & 0x3F));\n+                    *dst++ = (u8)(0x80 | ((uni >> 6) & 0x3F));\n+                    *dst++ = (u8)(0x80 | (uni & 0x3F));\n+                    src += 6;\n+                }\n+                break;\n+            default: return_err(src, \"invalid escaped character in string\");\n+        }\n+    } else if (likely(*src == '\"')) {\n+        val->tag = ((u64)(dst - cur) << YYJSON_TAG_BIT) | YYJSON_TYPE_STR;\n+        val->uni.str = (const char *)cur;\n+        *dst = '\\0';\n+        *end = src + 1;\n+        return true;\n+    } else {\n+        if (!inv) return_err(src, \"unexpected control character in string\");\n+        if (src >= lst) return_err(src, \"unclosed string\");\n+        *dst++ = *src++;\n+    }\n+    \n copy_ascii:\n-   /*\n-\tCopy continuous ASCII, loop unrolling, same as the following code:\n-\n-\t\twhile (true) repeat16({\n-\t\t   if (unlikely(char_is_ascii_stop(*src))) break;\n-\t\t   *dst++ = *src++;\n-\t\t});\n-\t*/\n+    /*\n+     Copy continuous ASCII, loop unrolling, same as the following code:\n+     \n+         while (true) repeat16({\n+            if (unlikely(char_is_ascii_stop(*src))) break;\n+            *dst++ = *src++;\n+         });\n+     */\n #if YYJSON_IS_REAL_GCC\n #   define expr_jump(i) \\\n-   if (likely(!(char_is_ascii_stop(src[i])))) {} \\\n-   else { __asm volatile(\"\":\"=m\"(src[i])::); goto copy_ascii_stop_##i; }\n+    if (likely(!(char_is_ascii_stop(src[i])))) {} \\\n+    else { __asm__ volatile(\"\":\"=m\"(src[i])); goto copy_ascii_stop_##i; }\n #else\n #   define expr_jump(i) \\\n-   if (likely(!(char_is_ascii_stop(src[i])))) {} \\\n-   else { goto copy_ascii_stop_##i; }\n+    if (likely(!(char_is_ascii_stop(src[i])))) {} \\\n+    else { goto copy_ascii_stop_##i; }\n #endif\n-   repeat16_incr(expr_jump);\n+    repeat16_incr(expr_jump);\n #undef expr_jump\n-\n-   byte_move_16(dst, src);\n-   src += 16;\n-   dst += 16;\n-   goto copy_ascii;\n-\n+    \n+    byte_move_16(dst, src);\n+    src += 16;\n+    dst += 16;\n+    goto copy_ascii;\n+    \n copy_ascii_stop_0:\n-   goto copy_utf8;\n+    goto copy_utf8;\n copy_ascii_stop_1:\n-   byte_move_2(dst, src);\n-   src += 1;\n-   dst += 1;\n-   goto copy_utf8;\n+    byte_move_2(dst, src);\n+    src += 1;\n+    dst += 1;\n+    goto copy_utf8;\n copy_ascii_stop_2:\n-   byte_move_2(dst, src);\n-   src += 2;\n-   dst += 2;\n-   goto copy_utf8;\n+    byte_move_2(dst, src);\n+    src += 2;\n+    dst += 2;\n+    goto copy_utf8;\n copy_ascii_stop_3:\n-   byte_move_4(dst, src);\n-   src += 3;\n-   dst += 3;\n-   goto copy_utf8;\n+    byte_move_4(dst, src);\n+    src += 3;\n+    dst += 3;\n+    goto copy_utf8;\n copy_ascii_stop_4:\n-   byte_move_4(dst, src);\n-   src += 4;\n-   dst += 4;\n-   goto copy_utf8;\n+    byte_move_4(dst, src);\n+    src += 4;\n+    dst += 4;\n+    goto copy_utf8;\n copy_ascii_stop_5:\n-   byte_move_4(dst, src);\n-   byte_move_2(dst + 4, src + 4);\n-   src += 5;\n-   dst += 5;\n-   goto copy_utf8;\n+    byte_move_4(dst, src);\n+    byte_move_2(dst + 4, src + 4);\n+    src += 5;\n+    dst += 5;\n+    goto copy_utf8;\n copy_ascii_stop_6:\n-   byte_move_4(dst, src);\n-   byte_move_2(dst + 4, src + 4);\n-   src += 6;\n-   dst += 6;\n-   goto copy_utf8;\n+    byte_move_4(dst, src);\n+    byte_move_2(dst + 4, src + 4);\n+    src += 6;\n+    dst += 6;\n+    goto copy_utf8;\n copy_ascii_stop_7:\n-   byte_move_8(dst, src);\n-   src += 7;\n-   dst += 7;\n-   goto copy_utf8;\n+    byte_move_8(dst, src);\n+    src += 7;\n+    dst += 7;\n+    goto copy_utf8;\n copy_ascii_stop_8:\n-   byte_move_8(dst, src);\n-   src += 8;\n-   dst += 8;\n-   goto copy_utf8;\n+    byte_move_8(dst, src);\n+    src += 8;\n+    dst += 8;\n+    goto copy_utf8;\n copy_ascii_stop_9:\n-   byte_move_8(dst, src);\n-   byte_move_2(dst + 8, src + 8);\n-   src += 9;\n-   dst += 9;\n-   goto copy_utf8;\n+    byte_move_8(dst, src);\n+    byte_move_2(dst + 8, src + 8);\n+    src += 9;\n+    dst += 9;\n+    goto copy_utf8;\n copy_ascii_stop_10:\n-   byte_move_8(dst, src);\n-   byte_move_2(dst + 8, src + 8);\n-   src += 10;\n-   dst += 10;\n-   goto copy_utf8;\n+    byte_move_8(dst, src);\n+    byte_move_2(dst + 8, src + 8);\n+    src += 10;\n+    dst += 10;\n+    goto copy_utf8;\n copy_ascii_stop_11:\n-   byte_move_8(dst, src);\n-   byte_move_4(dst + 8, src + 8);\n-   src += 11;\n-   dst += 11;\n-   goto copy_utf8;\n+    byte_move_8(dst, src);\n+    byte_move_4(dst + 8, src + 8);\n+    src += 11;\n+    dst += 11;\n+    goto copy_utf8;\n copy_ascii_stop_12:\n-   byte_move_8(dst, src);\n-   byte_move_4(dst + 8, src + 8);\n-   src += 12;\n-   dst += 12;\n-   goto copy_utf8;\n+    byte_move_8(dst, src);\n+    byte_move_4(dst + 8, src + 8);\n+    src += 12;\n+    dst += 12;\n+    goto copy_utf8;\n copy_ascii_stop_13:\n-   byte_move_8(dst, src);\n-   byte_move_4(dst + 8, src + 8);\n-   byte_move_2(dst + 12, src + 12);\n-   src += 13;\n-   dst += 13;\n-   goto copy_utf8;\n+    byte_move_8(dst, src);\n+    byte_move_4(dst + 8, src + 8);\n+    byte_move_2(dst + 12, src + 12);\n+    src += 13;\n+    dst += 13;\n+    goto copy_utf8;\n copy_ascii_stop_14:\n-   byte_move_8(dst, src);\n-   byte_move_4(dst + 8, src + 8);\n-   byte_move_2(dst + 12, src + 12);\n-   src += 14;\n-   dst += 14;\n-   goto copy_utf8;\n+    byte_move_8(dst, src);\n+    byte_move_4(dst + 8, src + 8);\n+    byte_move_2(dst + 12, src + 12);\n+    src += 14;\n+    dst += 14;\n+    goto copy_utf8;\n copy_ascii_stop_15:\n-   byte_move_16(dst, src);\n-   src += 15;\n-   dst += 15;\n-   goto copy_utf8;\n-\n+    byte_move_16(dst, src);\n+    src += 15;\n+    dst += 15;\n+    goto copy_utf8;\n+    \n copy_utf8:\n-   if (*src & 0x80) { /* non-ASCII character */\n-\t   pos = src;\n-\t   uni = byte_load_4(src);\n-\t   while (is_valid_seq_3(uni)) {\n-\t\t   byte_move_4(dst, &uni);\n-\t\t   dst += 3;\n-\t\t   src += 3;\n-\t\t   uni = byte_load_4(src);\n-\t   }\n-\t   if (is_valid_seq_1(uni)) goto copy_ascii;\n-\t   while (is_valid_seq_2(uni)) {\n-\t\t   byte_move_2(dst, &uni);\n-\t\t   dst += 2;\n-\t\t   src += 2;\n-\t\t   uni = byte_load_4(src);\n-\t   }\n-\t   while (is_valid_seq_4(uni)) {\n-\t\t   byte_move_4(dst, &uni);\n-\t\t   dst += 4;\n-\t\t   src += 4;\n-\t\t   uni = byte_load_4(src);\n-\t   }\n-\t   if (unlikely(pos == src)) {\n-\t\t   if (!inv) return_err(src, \"invalid UTF-8 encoding in string\");\n-\t\t   goto copy_ascii_stop_1;\n-\t   }\n-\t   goto copy_ascii;\n-   }\n-   goto copy_escape;\n-\n+    if (*src & 0x80) { /* non-ASCII character */\n+        pos = src;\n+        uni = byte_load_4(src);\n+        while (is_valid_seq_3(uni)) {\n+            byte_move_4(dst, &uni);\n+            dst += 3;\n+            src += 3;\n+            uni = byte_load_4(src);\n+        }\n+        if (is_valid_seq_1(uni)) goto copy_ascii;\n+        while (is_valid_seq_2(uni)) {\n+            byte_move_2(dst, &uni);\n+            dst += 2;\n+            src += 2;\n+            uni = byte_load_4(src);\n+        }\n+        while (is_valid_seq_4(uni)) {\n+            byte_move_4(dst, &uni);\n+            dst += 4;\n+            src += 4;\n+            uni = byte_load_4(src);\n+        }\n+        if (unlikely(pos == src)) {\n+            if (!inv) return_err(src, \"invalid UTF-8 encoding in string\");\n+            goto copy_ascii_stop_1;\n+        }\n+        goto copy_ascii;\n+    }\n+    goto copy_escape;\n+    \n #undef return_err\n #undef is_valid_seq_1\n #undef is_valid_seq_2\n@@ -4506,510 +4620,512 @@ static_inline bool read_string(u8 **ptr,\n \n \n /*==============================================================================\n-* JSON Reader Implementation\n-*\n-* We use goto statements to build the finite state machine (FSM).\n-* The FSM's state was held by program counter (PC) and the 'goto' make the\n-* state transitions.\n-*============================================================================*/\n+ * JSON Reader Implementation\n+ *\n+ * We use goto statements to build the finite state machine (FSM).\n+ * The FSM's state was held by program counter (PC) and the 'goto' make the\n+ * state transitions.\n+ *============================================================================*/\n \n /** Read single value JSON document. */\n static_noinline yyjson_doc *read_root_single(u8 *hdr,\n-\t\t\t\t\t\t\t\t\t\t\tu8 *cur,\n-\t\t\t\t\t\t\t\t\t\t\tu8 *end,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_alc alc,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_read_flag flg,\n-\t\t\t\t\t\t\t\t\t\t\tyyjson_read_err *err) {\n-\n+                                             u8 *cur,\n+                                             u8 *end,\n+                                             yyjson_alc alc,\n+                                             yyjson_read_flag flg,\n+                                             yyjson_read_err *err) {\n+    \n #define has_flag(_flag) unlikely((flg & YYJSON_READ_##_flag) != 0)\n-\n+    \n #define return_err(_pos, _code, _msg) do { \\\n-   if (_pos >= end) { \\\n-\t   err->pos = (usize)(end - hdr); \\\n-\t   err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \\\n-\t   err->msg = \"unexpected end of data\"; \\\n-   } else { \\\n-\t   err->pos = (usize)(_pos - hdr); \\\n-\t   err->code = YYJSON_READ_ERROR_##_code; \\\n-\t   err->msg = _msg; \\\n-   } \\\n-   if (val_hdr) alc.free(alc.ctx, (void *)val_hdr); \\\n-   return NULL; \\\n+    if (_pos >= end) { \\\n+        err->pos = (usize)(end - hdr); \\\n+        err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \\\n+        err->msg = \"unexpected end of data\"; \\\n+    } else { \\\n+        err->pos = (usize)(_pos - hdr); \\\n+        err->code = YYJSON_READ_ERROR_##_code; \\\n+        err->msg = _msg; \\\n+    } \\\n+    if (val_hdr) alc.free(alc.ctx, (void *)val_hdr); \\\n+    return NULL; \\\n } while (false)\n-\n-   usize hdr_len; /* value count used by doc */\n-   usize alc_num; /* value count capacity */\n-   yyjson_val *val_hdr; /* the head of allocated values */\n-   yyjson_val *val; /* current value */\n-   yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n-   const char *msg; /* error message */\n-\n-   bool raw; /* read number as raw */\n-   bool ext; /* allow inf and nan */\n-   bool inv; /* allow invalid unicode */\n-   u8 *raw_end; /* raw end for null-terminator */\n-   u8 **pre; /* previous raw end pointer */\n-\n-   hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);\n-   hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n-   alc_num = hdr_len + 1; /* single value */\n-\n-   val_hdr = (yyjson_val *)alc.malloc(alc.ctx, alc_num * sizeof(yyjson_val));\n-   if (unlikely(!val_hdr)) goto fail_alloc;\n-   val = val_hdr + hdr_len;\n-   raw = (flg & YYJSON_READ_NUMBER_AS_RAW) != 0;\n-   ext = (flg & YYJSON_READ_ALLOW_INF_AND_NAN) != 0;\n-   inv = (flg & YYJSON_READ_ALLOW_INVALID_UNICODE) != 0;\n-   raw_end = NULL;\n-   pre = raw ? &raw_end : NULL;\n-\n-   if (char_is_number(*cur)) {\n-\t   if (likely(read_number(&cur, pre, ext, val, &msg))) goto doc_end;\n-\t   goto fail_number;\n-   }\n-   if (*cur == '\"') {\n-\t   if (likely(read_string(&cur, end, inv, val, &msg))) goto doc_end;\n-\t   goto fail_string;\n-   }\n-   if (*cur == 't') {\n-\t   if (likely(read_true(&cur, val))) goto doc_end;\n-\t   goto fail_literal;\n-   }\n-   if (*cur == 'f') {\n-\t   if (likely(read_false(&cur, val))) goto doc_end;\n-\t   goto fail_literal;\n-   }\n-   if (*cur == 'n') {\n-\t   if (likely(read_null(&cur, val))) goto doc_end;\n-\t   if (unlikely(ext)) {\n-\t\t   if (read_nan(false, &cur, pre, val)) goto doc_end;\n-\t   }\n-\t   goto fail_literal;\n-   }\n-   if (unlikely(ext)) {\n-\t   if (read_inf_or_nan(false, &cur, pre, val)) goto doc_end;\n-   }\n-   goto fail_character;\n-\n+    \n+    usize hdr_len; /* value count used by doc */\n+    usize alc_num; /* value count capacity */\n+    yyjson_val *val_hdr; /* the head of allocated values */\n+    yyjson_val *val; /* current value */\n+    yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n+    const char *msg; /* error message */\n+    \n+    bool raw; /* read number as raw */\n+    bool ext; /* allow inf and nan */\n+    bool inv; /* allow invalid unicode */\n+    u8 *raw_end; /* raw end for null-terminator */\n+    u8 **pre; /* previous raw end pointer */\n+    \n+    hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);\n+    hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n+    alc_num = hdr_len + 1; /* single value */\n+    \n+    val_hdr = (yyjson_val *)alc.malloc(alc.ctx, alc_num * sizeof(yyjson_val));\n+    if (unlikely(!val_hdr)) goto fail_alloc;\n+    val = val_hdr + hdr_len;\n+    raw = (flg & YYJSON_READ_NUMBER_AS_RAW) != 0;\n+    ext = (flg & YYJSON_READ_ALLOW_INF_AND_NAN) != 0;\n+    inv = (flg & YYJSON_READ_ALLOW_INVALID_UNICODE) != 0;\n+    raw_end = NULL;\n+    pre = raw ? &raw_end : NULL;\n+    \n+    if (char_is_number(*cur)) {\n+        if (likely(read_number(&cur, pre, ext, val, &msg))) goto doc_end;\n+        goto fail_number;\n+    }\n+    if (*cur == '\"') {\n+        if (likely(read_string(&cur, end, inv, val, &msg))) goto doc_end;\n+        goto fail_string;\n+    }\n+    if (*cur == 't') {\n+        if (likely(read_true(&cur, val))) goto doc_end;\n+        goto fail_literal;\n+    }\n+    if (*cur == 'f') {\n+        if (likely(read_false(&cur, val))) goto doc_end;\n+        goto fail_literal;\n+    }\n+    if (*cur == 'n') {\n+        if (likely(read_null(&cur, val))) goto doc_end;\n+        if (unlikely(ext)) {\n+            if (read_nan(false, &cur, pre, val)) goto doc_end;\n+        }\n+        goto fail_literal;\n+    }\n+    if (unlikely(ext)) {\n+        if (read_inf_or_nan(false, &cur, pre, val)) goto doc_end;\n+    }\n+    goto fail_character;\n+    \n doc_end:\n-   /* check invalid contents after json document */\n-   if (unlikely(cur < end) && !has_flag(STOP_WHEN_DONE)) {\n-\t   if (has_flag(ALLOW_COMMENTS)) {\n-\t\t   if (!skip_spaces_and_comments(&cur)) {\n-\t\t\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-\t\t   }\n-\t   } else {\n-\t\t   while (char_is_space(*cur)) cur++;\n-\t   }\n-\t   if (unlikely(cur < end)) goto fail_garbage;\n-   }\n-\n-   if (pre && *pre) **pre = '\\0';\n-   doc = (yyjson_doc *)val_hdr;\n-   doc->root = val_hdr + hdr_len;\n-   doc->alc = alc;\n-   doc->dat_read = (usize)(cur - hdr);\n-   doc->val_read = 1;\n-   doc->str_pool = has_flag(INSITU) ? NULL : (char *)hdr;\n-   return doc;\n-\n+    /* check invalid contents after json document */\n+    if (unlikely(cur < end) && !has_flag(STOP_WHEN_DONE)) {\n+        if (has_flag(ALLOW_COMMENTS)) {\n+            if (!skip_spaces_and_comments(&cur)) {\n+                if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+            }\n+        } else {\n+            while (char_is_space(*cur)) cur++;\n+        }\n+        if (unlikely(cur < end)) goto fail_garbage;\n+    }\n+    \n+    if (pre && *pre) **pre = '\\0';\n+    doc = (yyjson_doc *)val_hdr;\n+    doc->root = val_hdr + hdr_len;\n+    doc->alc = alc;\n+    doc->dat_read = (usize)(cur - hdr);\n+    doc->val_read = 1;\n+    doc->str_pool = has_flag(INSITU) ? NULL : (char *)hdr;\n+    return doc;\n+    \n fail_string:\n-   return_err(cur, INVALID_STRING, msg);\n+    return_err(cur, INVALID_STRING, msg);\n fail_number:\n-   return_err(cur, INVALID_NUMBER, msg);\n+    return_err(cur, INVALID_NUMBER, msg);\n fail_alloc:\n-   return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");\n+    return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");\n fail_literal:\n-   return_err(cur, LITERAL, \"invalid literal\");\n+    return_err(cur, LITERAL, \"invalid literal\");\n fail_comment:\n-   return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\n+    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\n fail_character:\n-   return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\n+    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\n fail_garbage:\n-   return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\n-\n+    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\n+    \n #undef has_flag\n #undef return_err\n }\n \n /** Read JSON document (accept all style, but optimized for minify). */\n static_inline yyjson_doc *read_root_minify(u8 *hdr,\n-\t\t\t\t\t\t\t\t\t\t  u8 *cur,\n-\t\t\t\t\t\t\t\t\t\t  u8 *end,\n-\t\t\t\t\t\t\t\t\t\t  yyjson_alc alc,\n-\t\t\t\t\t\t\t\t\t\t  yyjson_read_flag flg,\n-\t\t\t\t\t\t\t\t\t\t  yyjson_read_err *err) {\n-\n+                                           u8 *cur,\n+                                           u8 *end,\n+                                           yyjson_alc alc,\n+                                           yyjson_read_flag flg,\n+                                           yyjson_read_err *err) {\n+    \n #define has_flag(_flag) unlikely((flg & YYJSON_READ_##_flag) != 0)\n-\n+    \n #define return_err(_pos, _code, _msg) do { \\\n-   if (_pos >= end) { \\\n-\t   err->pos = (usize)(end - hdr); \\\n-\t   err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \\\n-\t   err->msg = \"unexpected end of data\"; \\\n-   } else { \\\n-\t   err->pos = (usize)(_pos - hdr); \\\n-\t   err->code = YYJSON_READ_ERROR_##_code; \\\n-\t   err->msg = _msg; \\\n-   } \\\n-   if (val_hdr) alc.free(alc.ctx, (void *)val_hdr); \\\n-   return NULL; \\\n+    if (_pos >= end) { \\\n+        err->pos = (usize)(end - hdr); \\\n+        err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \\\n+        err->msg = \"unexpected end of data\"; \\\n+    } else { \\\n+        err->pos = (usize)(_pos - hdr); \\\n+        err->code = YYJSON_READ_ERROR_##_code; \\\n+        err->msg = _msg; \\\n+    } \\\n+    if (val_hdr) alc.free(alc.ctx, (void *)val_hdr); \\\n+    return NULL; \\\n } while (false)\n-\n+    \n #define val_incr() do { \\\n-   val++; \\\n-   if (unlikely(val >= val_end)) { \\\n-\t   alc_len += alc_len / 2; \\\n-\t   if ((alc_len >= alc_max)) goto fail_alloc; \\\n-\t   val_tmp = (yyjson_val *)alc.realloc(alc.ctx, (void *)val_hdr, \\\n-\t\t   alc_len * sizeof(yyjson_val)); \\\n-\t   if ((!val_tmp)) goto fail_alloc; \\\n-\t   val = val_tmp + (usize)(val - val_hdr); \\\n-\t   ctn = val_tmp + (usize)(ctn - val_hdr); \\\n-\t   val_hdr = val_tmp; \\\n-\t   val_end = val_tmp + (alc_len - 2); \\\n-   } \\\n+    val++; \\\n+    if (unlikely(val >= val_end)) { \\\n+        usize alc_old = alc_len; \\\n+        alc_len += alc_len / 2; \\\n+        if ((alc_len >= alc_max)) goto fail_alloc; \\\n+        val_tmp = (yyjson_val *)alc.realloc(alc.ctx, (void *)val_hdr, \\\n+            alc_old * sizeof(yyjson_val), \\\n+            alc_len * sizeof(yyjson_val)); \\\n+        if ((!val_tmp)) goto fail_alloc; \\\n+        val = val_tmp + (usize)(val - val_hdr); \\\n+        ctn = val_tmp + (usize)(ctn - val_hdr); \\\n+        val_hdr = val_tmp; \\\n+        val_end = val_tmp + (alc_len - 2); \\\n+    } \\\n } while (false)\n-\n-   usize dat_len; /* data length in bytes, hint for allocator */\n-   usize hdr_len; /* value count used by yyjson_doc */\n-   usize alc_len; /* value count allocated */\n-   usize alc_max; /* maximum value count for allocator */\n-   usize ctn_len; /* the number of elements in current container */\n-   yyjson_val *val_hdr; /* the head of allocated values */\n-   yyjson_val *val_end; /* the end of allocated values */\n-   yyjson_val *val_tmp; /* temporary pointer for realloc */\n-   yyjson_val *val; /* current JSON value */\n-   yyjson_val *ctn; /* current container */\n-   yyjson_val *ctn_parent; /* parent of current container */\n-   yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n-   const char *msg; /* error message */\n-\n-   bool raw; /* read number as raw */\n-   bool ext; /* allow inf and nan */\n-   bool inv; /* allow invalid unicode */\n-   u8 *raw_end; /* raw end for null-terminator */\n-   u8 **pre; /* previous raw end pointer */\n-\n-   dat_len = has_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);\n-   hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);\n-   hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n-   alc_max = USIZE_MAX / sizeof(yyjson_val);\n-   alc_len = hdr_len + (dat_len / YYJSON_READER_ESTIMATED_MINIFY_RATIO) + 4;\n-   alc_len = yyjson_min(alc_len, alc_max);\n-\n-   val_hdr = (yyjson_val *)alc.malloc(alc.ctx, alc_len * sizeof(yyjson_val));\n-   if (unlikely(!val_hdr)) goto fail_alloc;\n-   val_end = val_hdr + (alc_len - 2); /* padding for key-value pair reading */\n-   val = val_hdr + hdr_len;\n-   ctn = val;\n-   ctn_len = 0;\n-   raw = (flg & YYJSON_READ_NUMBER_AS_RAW) != 0;\n-   ext = (flg & YYJSON_READ_ALLOW_INF_AND_NAN) != 0;\n-   inv = (flg & YYJSON_READ_ALLOW_INVALID_UNICODE) != 0;\n-   raw_end = NULL;\n-   pre = raw ? &raw_end : NULL;\n-\n-   if (*cur++ == '{') {\n-\t   ctn->tag = YYJSON_TYPE_OBJ;\n-\t   ctn->uni.ofs = 0;\n-\t   goto obj_key_begin;\n-   } else {\n-\t   ctn->tag = YYJSON_TYPE_ARR;\n-\t   ctn->uni.ofs = 0;\n-\t   goto arr_val_begin;\n-   }\n-\n+    \n+    usize dat_len; /* data length in bytes, hint for allocator */\n+    usize hdr_len; /* value count used by yyjson_doc */\n+    usize alc_len; /* value count allocated */\n+    usize alc_max; /* maximum value count for allocator */\n+    usize ctn_len; /* the number of elements in current container */\n+    yyjson_val *val_hdr; /* the head of allocated values */\n+    yyjson_val *val_end; /* the end of allocated values */\n+    yyjson_val *val_tmp; /* temporary pointer for realloc */\n+    yyjson_val *val; /* current JSON value */\n+    yyjson_val *ctn; /* current container */\n+    yyjson_val *ctn_parent; /* parent of current container */\n+    yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n+    const char *msg; /* error message */\n+    \n+    bool raw; /* read number as raw */\n+    bool ext; /* allow inf and nan */\n+    bool inv; /* allow invalid unicode */\n+    u8 *raw_end; /* raw end for null-terminator */\n+    u8 **pre; /* previous raw end pointer */\n+    \n+    dat_len = has_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);\n+    hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);\n+    hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n+    alc_max = USIZE_MAX / sizeof(yyjson_val);\n+    alc_len = hdr_len + (dat_len / YYJSON_READER_ESTIMATED_MINIFY_RATIO) + 4;\n+    alc_len = yyjson_min(alc_len, alc_max);\n+    \n+    val_hdr = (yyjson_val *)alc.malloc(alc.ctx, alc_len * sizeof(yyjson_val));\n+    if (unlikely(!val_hdr)) goto fail_alloc;\n+    val_end = val_hdr + (alc_len - 2); /* padding for key-value pair reading */\n+    val = val_hdr + hdr_len;\n+    ctn = val;\n+    ctn_len = 0;\n+    raw = (flg & YYJSON_READ_NUMBER_AS_RAW) != 0;\n+    ext = (flg & YYJSON_READ_ALLOW_INF_AND_NAN) != 0;\n+    inv = (flg & YYJSON_READ_ALLOW_INVALID_UNICODE) != 0;\n+    raw_end = NULL;\n+    pre = raw ? &raw_end : NULL;\n+    \n+    if (*cur++ == '{') {\n+        ctn->tag = YYJSON_TYPE_OBJ;\n+        ctn->uni.ofs = 0;\n+        goto obj_key_begin;\n+    } else {\n+        ctn->tag = YYJSON_TYPE_ARR;\n+        ctn->uni.ofs = 0;\n+        goto arr_val_begin;\n+    }\n+    \n arr_begin:\n-   /* save current container */\n-   ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n-\t\t\t  (ctn->tag & YYJSON_TAG_MASK);\n-\n-   /* create a new array value, save parent container offset */\n-   val_incr();\n-   val->tag = YYJSON_TYPE_ARR;\n-   val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n-\n-   /* push the new array value as current container */\n-   ctn = val;\n-   ctn_len = 0;\n-\n+    /* save current container */\n+    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n+               (ctn->tag & YYJSON_TAG_MASK);\n+    \n+    /* create a new array value, save parent container offset */\n+    val_incr();\n+    val->tag = YYJSON_TYPE_ARR;\n+    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n+    \n+    /* push the new array value as current container */\n+    ctn = val;\n+    ctn_len = 0;\n+    \n arr_val_begin:\n-   if (*cur == '{') {\n-\t   cur++;\n-\t   goto obj_begin;\n-   }\n-   if (*cur == '[') {\n-\t   cur++;\n-\t   goto arr_begin;\n-   }\n-   if (char_is_number(*cur)) {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_number(&cur, pre, ext, val, &msg))) goto arr_val_end;\n-\t   goto fail_number;\n-   }\n-   if (*cur == '\"') {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_string(&cur, end, inv, val, &msg))) goto arr_val_end;\n-\t   goto fail_string;\n-   }\n-   if (*cur == 't') {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_true(&cur, val))) goto arr_val_end;\n-\t   goto fail_literal;\n-   }\n-   if (*cur == 'f') {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_false(&cur, val))) goto arr_val_end;\n-\t   goto fail_literal;\n-   }\n-   if (*cur == 'n') {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_null(&cur, val))) goto arr_val_end;\n-\t   if (unlikely(ext)) {\n-\t\t   if (read_nan(false, &cur, pre, val)) goto arr_val_end;\n-\t   }\n-\t   goto fail_literal;\n-   }\n-   if (*cur == ']') {\n-\t   cur++;\n-\t   if (likely(ctn_len == 0)) goto arr_end;\n-\t   if (has_flag(ALLOW_TRAILING_COMMAS)) goto arr_end;\n-\t   goto fail_trailing_comma;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto arr_val_begin;\n-   }\n-   if (unlikely(ext) && (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (read_inf_or_nan(false, &cur, pre, val)) goto arr_val_end;\n-\t   goto fail_character;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto arr_val_begin;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    if (*cur == '{') {\n+        cur++;\n+        goto obj_begin;\n+    }\n+    if (*cur == '[') {\n+        cur++;\n+        goto arr_begin;\n+    }\n+    if (char_is_number(*cur)) {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_number(&cur, pre, ext, val, &msg))) goto arr_val_end;\n+        goto fail_number;\n+    }\n+    if (*cur == '\"') {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_string(&cur, end, inv, val, &msg))) goto arr_val_end;\n+        goto fail_string;\n+    }\n+    if (*cur == 't') {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_true(&cur, val))) goto arr_val_end;\n+        goto fail_literal;\n+    }\n+    if (*cur == 'f') {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_false(&cur, val))) goto arr_val_end;\n+        goto fail_literal;\n+    }\n+    if (*cur == 'n') {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_null(&cur, val))) goto arr_val_end;\n+        if (unlikely(ext)) {\n+            if (read_nan(false, &cur, pre, val)) goto arr_val_end;\n+        }\n+        goto fail_literal;\n+    }\n+    if (*cur == ']') {\n+        cur++;\n+        if (likely(ctn_len == 0)) goto arr_end;\n+        if (has_flag(ALLOW_TRAILING_COMMAS)) goto arr_end;\n+        goto fail_trailing_comma;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto arr_val_begin;\n+    }\n+    if (unlikely(ext) && (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n+        val_incr();\n+        ctn_len++;\n+        if (read_inf_or_nan(false, &cur, pre, val)) goto arr_val_end;\n+        goto fail_character;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto arr_val_begin;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n arr_val_end:\n-   if (*cur == ',') {\n-\t   cur++;\n-\t   goto arr_val_begin;\n-   }\n-   if (*cur == ']') {\n-\t   cur++;\n-\t   goto arr_end;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto arr_val_end;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto arr_val_end;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    if (*cur == ',') {\n+        cur++;\n+        goto arr_val_begin;\n+    }\n+    if (*cur == ']') {\n+        cur++;\n+        goto arr_end;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto arr_val_end;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto arr_val_end;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n arr_end:\n-   /* get parent container */\n-   ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n-\n-   /* save the next sibling value offset */\n-   ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n-   ctn->tag = ((ctn_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR;\n-   if (unlikely(ctn == ctn_parent)) goto doc_end;\n-\n-   /* pop parent as current container */\n-   ctn = ctn_parent;\n-   ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n-   if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n-\t   goto obj_val_end;\n-   } else {\n-\t   goto arr_val_end;\n-   }\n-\n+    /* get parent container */\n+    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n+    \n+    /* save the next sibling value offset */\n+    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n+    ctn->tag = ((ctn_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR;\n+    if (unlikely(ctn == ctn_parent)) goto doc_end;\n+    \n+    /* pop parent as current container */\n+    ctn = ctn_parent;\n+    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n+    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n+        goto obj_val_end;\n+    } else {\n+        goto arr_val_end;\n+    }\n+    \n obj_begin:\n-   /* push container */\n-   ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n-\t\t\t  (ctn->tag & YYJSON_TAG_MASK);\n-   val_incr();\n-   val->tag = YYJSON_TYPE_OBJ;\n-   /* offset to the parent */\n-   val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n-   ctn = val;\n-   ctn_len = 0;\n-\n+    /* push container */\n+    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n+               (ctn->tag & YYJSON_TAG_MASK);\n+    val_incr();\n+    val->tag = YYJSON_TYPE_OBJ;\n+    /* offset to the parent */\n+    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n+    ctn = val;\n+    ctn_len = 0;\n+    \n obj_key_begin:\n-   if (likely(*cur == '\"')) {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_key_end;\n-\t   goto fail_string;\n-   }\n-   if (likely(*cur == '}')) {\n-\t   cur++;\n-\t   if (likely(ctn_len == 0)) goto obj_end;\n-\t   if (has_flag(ALLOW_TRAILING_COMMAS)) goto obj_end;\n-\t   goto fail_trailing_comma;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto obj_key_begin;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto obj_key_begin;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    if (likely(*cur == '\"')) {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_key_end;\n+        goto fail_string;\n+    }\n+    if (likely(*cur == '}')) {\n+        cur++;\n+        if (likely(ctn_len == 0)) goto obj_end;\n+        if (has_flag(ALLOW_TRAILING_COMMAS)) goto obj_end;\n+        goto fail_trailing_comma;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto obj_key_begin;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto obj_key_begin;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n obj_key_end:\n-   if (*cur == ':') {\n-\t   cur++;\n-\t   goto obj_val_begin;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto obj_key_end;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto obj_key_end;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    if (*cur == ':') {\n+        cur++;\n+        goto obj_val_begin;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto obj_key_end;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto obj_key_end;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n obj_val_begin:\n-   if (*cur == '\"') {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_val_end;\n-\t   goto fail_string;\n-   }\n-   if (char_is_number(*cur)) {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (likely(read_number(&cur, pre, ext, val, &msg))) goto obj_val_end;\n-\t   goto fail_number;\n-   }\n-   if (*cur == '{') {\n-\t   cur++;\n-\t   goto obj_begin;\n-   }\n-   if (*cur == '[') {\n-\t   cur++;\n-\t   goto arr_begin;\n-   }\n-   if (*cur == 't') {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (likely(read_true(&cur, val))) goto obj_val_end;\n-\t   goto fail_literal;\n-   }\n-   if (*cur == 'f') {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (likely(read_false(&cur, val))) goto obj_val_end;\n-\t   goto fail_literal;\n-   }\n-   if (*cur == 'n') {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (likely(read_null(&cur, val))) goto obj_val_end;\n-\t   if (unlikely(ext)) {\n-\t\t   if (read_nan(false, &cur, pre, val)) goto obj_val_end;\n-\t   }\n-\t   goto fail_literal;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto obj_val_begin;\n-   }\n-   if (unlikely(ext) && (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (read_inf_or_nan(false, &cur, pre, val)) goto obj_val_end;\n-\t   goto fail_character;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto obj_val_begin;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    if (*cur == '\"') {\n+        val++;\n+        ctn_len++;\n+        if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_val_end;\n+        goto fail_string;\n+    }\n+    if (char_is_number(*cur)) {\n+        val++;\n+        ctn_len++;\n+        if (likely(read_number(&cur, pre, ext, val, &msg))) goto obj_val_end;\n+        goto fail_number;\n+    }\n+    if (*cur == '{') {\n+        cur++;\n+        goto obj_begin;\n+    }\n+    if (*cur == '[') {\n+        cur++;\n+        goto arr_begin;\n+    }\n+    if (*cur == 't') {\n+        val++;\n+        ctn_len++;\n+        if (likely(read_true(&cur, val))) goto obj_val_end;\n+        goto fail_literal;\n+    }\n+    if (*cur == 'f') {\n+        val++;\n+        ctn_len++;\n+        if (likely(read_false(&cur, val))) goto obj_val_end;\n+        goto fail_literal;\n+    }\n+    if (*cur == 'n') {\n+        val++;\n+        ctn_len++;\n+        if (likely(read_null(&cur, val))) goto obj_val_end;\n+        if (unlikely(ext)) {\n+            if (read_nan(false, &cur, pre, val)) goto obj_val_end;\n+        }\n+        goto fail_literal;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto obj_val_begin;\n+    }\n+    if (unlikely(ext) && (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n+        val++;\n+        ctn_len++;\n+        if (read_inf_or_nan(false, &cur, pre, val)) goto obj_val_end;\n+        goto fail_character;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto obj_val_begin;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n obj_val_end:\n-   if (likely(*cur == ',')) {\n-\t   cur++;\n-\t   goto obj_key_begin;\n-   }\n-   if (likely(*cur == '}')) {\n-\t   cur++;\n-\t   goto obj_end;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto obj_val_end;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto obj_val_end;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    if (likely(*cur == ',')) {\n+        cur++;\n+        goto obj_key_begin;\n+    }\n+    if (likely(*cur == '}')) {\n+        cur++;\n+        goto obj_end;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto obj_val_end;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto obj_val_end;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n obj_end:\n-   /* pop container */\n-   ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n-   /* point to the next value */\n-   ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n-   ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\n-   if (unlikely(ctn == ctn_parent)) goto doc_end;\n-   ctn = ctn_parent;\n-   ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n-   if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n-\t   goto obj_val_end;\n-   } else {\n-\t   goto arr_val_end;\n-   }\n-\n+    /* pop container */\n+    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n+    /* point to the next value */\n+    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n+    ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\n+    if (unlikely(ctn == ctn_parent)) goto doc_end;\n+    ctn = ctn_parent;\n+    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n+    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n+        goto obj_val_end;\n+    } else {\n+        goto arr_val_end;\n+    }\n+    \n doc_end:\n-   /* check invalid contents after json document */\n-   if (unlikely(cur < end) && !has_flag(STOP_WHEN_DONE)) {\n-\t   if (has_flag(ALLOW_COMMENTS)) skip_spaces_and_comments(&cur);\n-\t   else while (char_is_space(*cur)) cur++;\n-\t   if (unlikely(cur < end)) goto fail_garbage;\n-   }\n-\n-   if (pre && *pre) **pre = '\\0';\n-   doc = (yyjson_doc *)val_hdr;\n-   doc->root = val_hdr + hdr_len;\n-   doc->alc = alc;\n-   doc->dat_read = (usize)(cur - hdr);\n-   doc->val_read = (usize)((val - doc->root) + 1);\n-   doc->str_pool = has_flag(INSITU) ? NULL : (char *)hdr;\n-   return doc;\n-\n+    /* check invalid contents after json document */\n+    if (unlikely(cur < end) && !has_flag(STOP_WHEN_DONE)) {\n+        if (has_flag(ALLOW_COMMENTS)) skip_spaces_and_comments(&cur);\n+        else while (char_is_space(*cur)) cur++;\n+        if (unlikely(cur < end)) goto fail_garbage;\n+    }\n+    \n+    if (pre && *pre) **pre = '\\0';\n+    doc = (yyjson_doc *)val_hdr;\n+    doc->root = val_hdr + hdr_len;\n+    doc->alc = alc;\n+    doc->dat_read = (usize)(cur - hdr);\n+    doc->val_read = (usize)((val - doc->root) + 1);\n+    doc->str_pool = has_flag(INSITU) ? NULL : (char *)hdr;\n+    return doc;\n+    \n fail_string:\n-   return_err(cur, INVALID_STRING, msg);\n+    return_err(cur, INVALID_STRING, msg);\n fail_number:\n-   return_err(cur, INVALID_NUMBER, msg);\n+    return_err(cur, INVALID_NUMBER, msg);\n fail_alloc:\n-   return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");\n+    return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");\n fail_trailing_comma:\n-   return_err(cur, JSON_STRUCTURE, \"trailing comma is not allowed\");\n+    return_err(cur, JSON_STRUCTURE, \"trailing comma is not allowed\");\n fail_literal:\n-   return_err(cur, LITERAL, \"invalid literal\");\n+    return_err(cur, LITERAL, \"invalid literal\");\n fail_comment:\n-   return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\n+    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\n fail_character:\n-   return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\n+    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\n fail_garbage:\n-   return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\n-\n+    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\n+    \n #undef has_flag\n #undef val_incr\n #undef return_err\n@@ -5017,423 +5133,425 @@ static_inline yyjson_doc *read_root_minify(u8 *hdr,\n \n /** Read JSON document (accept all style, but optimized for pretty). */\n static_inline yyjson_doc *read_root_pretty(u8 *hdr,\n-\t\t\t\t\t\t\t\t\t\t  u8 *cur,\n-\t\t\t\t\t\t\t\t\t\t  u8 *end,\n-\t\t\t\t\t\t\t\t\t\t  yyjson_alc alc,\n-\t\t\t\t\t\t\t\t\t\t  yyjson_read_flag flg,\n-\t\t\t\t\t\t\t\t\t\t  yyjson_read_err *err) {\n-\n+                                           u8 *cur,\n+                                           u8 *end,\n+                                           yyjson_alc alc,\n+                                           yyjson_read_flag flg,\n+                                           yyjson_read_err *err) {\n+    \n #define has_flag(_flag) unlikely((flg & YYJSON_READ_##_flag) != 0)\n-\n+    \n #define return_err(_pos, _code, _msg) do { \\\n-   if (_pos >= end) { \\\n-\t   err->pos = (usize)(end - hdr); \\\n-\t   err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \\\n-\t   err->msg = \"unexpected end of data\"; \\\n-   } else { \\\n-\t   err->pos = (usize)(_pos - hdr); \\\n-\t   err->code = YYJSON_READ_ERROR_##_code; \\\n-\t   err->msg = _msg; \\\n-   } \\\n-   if (val_hdr) alc.free(alc.ctx, (void *)val_hdr); \\\n-   return NULL; \\\n+    if (_pos >= end) { \\\n+        err->pos = (usize)(end - hdr); \\\n+        err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \\\n+        err->msg = \"unexpected end of data\"; \\\n+    } else { \\\n+        err->pos = (usize)(_pos - hdr); \\\n+        err->code = YYJSON_READ_ERROR_##_code; \\\n+        err->msg = _msg; \\\n+    } \\\n+    if (val_hdr) alc.free(alc.ctx, (void *)val_hdr); \\\n+    return NULL; \\\n } while (false)\n-\n+    \n #define val_incr() do { \\\n-   val++; \\\n-   if (unlikely(val >= val_end)) { \\\n-\t   alc_len += alc_len / 2; \\\n-\t   if ((alc_len >= alc_max)) goto fail_alloc; \\\n-\t   val_tmp = (yyjson_val *)alc.realloc(alc.ctx, (void *)val_hdr, \\\n-\t\t   alc_len * sizeof(yyjson_val)); \\\n-\t   if ((!val_tmp)) goto fail_alloc; \\\n-\t   val = val_tmp + (usize)(val - val_hdr); \\\n-\t   ctn = val_tmp + (usize)(ctn - val_hdr); \\\n-\t   val_hdr = val_tmp; \\\n-\t   val_end = val_tmp + (alc_len - 2); \\\n-   } \\\n+    val++; \\\n+    if (unlikely(val >= val_end)) { \\\n+        usize alc_old = alc_len; \\\n+        alc_len += alc_len / 2; \\\n+        if ((alc_len >= alc_max)) goto fail_alloc; \\\n+        val_tmp = (yyjson_val *)alc.realloc(alc.ctx, (void *)val_hdr, \\\n+            alc_old * sizeof(yyjson_val), \\\n+            alc_len * sizeof(yyjson_val)); \\\n+        if ((!val_tmp)) goto fail_alloc; \\\n+        val = val_tmp + (usize)(val - val_hdr); \\\n+        ctn = val_tmp + (usize)(ctn - val_hdr); \\\n+        val_hdr = val_tmp; \\\n+        val_end = val_tmp + (alc_len - 2); \\\n+    } \\\n } while (false)\n-\n-   usize dat_len; /* data length in bytes, hint for allocator */\n-   usize hdr_len; /* value count used by yyjson_doc */\n-   usize alc_len; /* value count allocated */\n-   usize alc_max; /* maximum value count for allocator */\n-   usize ctn_len; /* the number of elements in current container */\n-   yyjson_val *val_hdr; /* the head of allocated values */\n-   yyjson_val *val_end; /* the end of allocated values */\n-   yyjson_val *val_tmp; /* temporary pointer for realloc */\n-   yyjson_val *val; /* current JSON value */\n-   yyjson_val *ctn; /* current container */\n-   yyjson_val *ctn_parent; /* parent of current container */\n-   yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n-   const char *msg; /* error message */\n-\n-   bool raw; /* read number as raw */\n-   bool ext; /* allow inf and nan */\n-   bool inv; /* allow invalid unicode */\n-   u8 *raw_end; /* raw end for null-terminator */\n-   u8 **pre; /* previous raw end pointer */\n-\n-   dat_len = has_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);\n-   hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);\n-   hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n-   alc_max = USIZE_MAX / sizeof(yyjson_val);\n-   alc_len = hdr_len + (dat_len / YYJSON_READER_ESTIMATED_PRETTY_RATIO) + 4;\n-   alc_len = yyjson_min(alc_len, alc_max);\n-\n-   val_hdr = (yyjson_val *)alc.malloc(alc.ctx, alc_len * sizeof(yyjson_val));\n-   if (unlikely(!val_hdr)) goto fail_alloc;\n-   val_end = val_hdr + (alc_len - 2); /* padding for key-value pair reading */\n-   val = val_hdr + hdr_len;\n-   ctn = val;\n-   ctn_len = 0;\n-   raw = (flg & YYJSON_READ_NUMBER_AS_RAW) != 0;\n-   ext = (flg & YYJSON_READ_ALLOW_INF_AND_NAN) != 0;\n-   inv = (flg & YYJSON_READ_ALLOW_INVALID_UNICODE) != 0;\n-   raw_end = NULL;\n-   pre = raw ? &raw_end : NULL;\n-\n-   if (*cur++ == '{') {\n-\t   ctn->tag = YYJSON_TYPE_OBJ;\n-\t   ctn->uni.ofs = 0;\n-\t   if (*cur == '\\n') cur++;\n-\t   goto obj_key_begin;\n-   } else {\n-\t   ctn->tag = YYJSON_TYPE_ARR;\n-\t   ctn->uni.ofs = 0;\n-\t   if (*cur == '\\n') cur++;\n-\t   goto arr_val_begin;\n-   }\n-\n+    \n+    usize dat_len; /* data length in bytes, hint for allocator */\n+    usize hdr_len; /* value count used by yyjson_doc */\n+    usize alc_len; /* value count allocated */\n+    usize alc_max; /* maximum value count for allocator */\n+    usize ctn_len; /* the number of elements in current container */\n+    yyjson_val *val_hdr; /* the head of allocated values */\n+    yyjson_val *val_end; /* the end of allocated values */\n+    yyjson_val *val_tmp; /* temporary pointer for realloc */\n+    yyjson_val *val; /* current JSON value */\n+    yyjson_val *ctn; /* current container */\n+    yyjson_val *ctn_parent; /* parent of current container */\n+    yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n+    const char *msg; /* error message */\n+    \n+    bool raw; /* read number as raw */\n+    bool ext; /* allow inf and nan */\n+    bool inv; /* allow invalid unicode */\n+    u8 *raw_end; /* raw end for null-terminator */\n+    u8 **pre; /* previous raw end pointer */\n+    \n+    dat_len = has_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);\n+    hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);\n+    hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n+    alc_max = USIZE_MAX / sizeof(yyjson_val);\n+    alc_len = hdr_len + (dat_len / YYJSON_READER_ESTIMATED_PRETTY_RATIO) + 4;\n+    alc_len = yyjson_min(alc_len, alc_max);\n+    \n+    val_hdr = (yyjson_val *)alc.malloc(alc.ctx, alc_len * sizeof(yyjson_val));\n+    if (unlikely(!val_hdr)) goto fail_alloc;\n+    val_end = val_hdr + (alc_len - 2); /* padding for key-value pair reading */\n+    val = val_hdr + hdr_len;\n+    ctn = val;\n+    ctn_len = 0;\n+    raw = (flg & YYJSON_READ_NUMBER_AS_RAW) != 0;\n+    ext = (flg & YYJSON_READ_ALLOW_INF_AND_NAN) != 0;\n+    inv = (flg & YYJSON_READ_ALLOW_INVALID_UNICODE) != 0;\n+    raw_end = NULL;\n+    pre = raw ? &raw_end : NULL;\n+    \n+    if (*cur++ == '{') {\n+        ctn->tag = YYJSON_TYPE_OBJ;\n+        ctn->uni.ofs = 0;\n+        if (*cur == '\\n') cur++;\n+        goto obj_key_begin;\n+    } else {\n+        ctn->tag = YYJSON_TYPE_ARR;\n+        ctn->uni.ofs = 0;\n+        if (*cur == '\\n') cur++;\n+        goto arr_val_begin;\n+    }\n+    \n arr_begin:\n-   /* save current container */\n-   ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n-\t\t\t  (ctn->tag & YYJSON_TAG_MASK);\n-\n-   /* create a new array value, save parent container offset */\n-   val_incr();\n-   val->tag = YYJSON_TYPE_ARR;\n-   val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n-\n-   /* push the new array value as current container */\n-   ctn = val;\n-   ctn_len = 0;\n-   if (*cur == '\\n') cur++;\n-\n+    /* save current container */\n+    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n+               (ctn->tag & YYJSON_TAG_MASK);\n+    \n+    /* create a new array value, save parent container offset */\n+    val_incr();\n+    val->tag = YYJSON_TYPE_ARR;\n+    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n+    \n+    /* push the new array value as current container */\n+    ctn = val;\n+    ctn_len = 0;\n+    if (*cur == '\\n') cur++;\n+    \n arr_val_begin:\n #if YYJSON_IS_REAL_GCC\n-   while (true) repeat16({\n-\t\t   if (byte_match_2(cur, \"  \")) cur += 2;\n-\t\t   else break;\n-\t   });\n+    while (true) repeat16({\n+        if (byte_match_2(cur, \"  \")) cur += 2;\n+        else break;\n+    });\n #else\n-   while (true) repeat16({\n-\t\t   if (likely(byte_match_2(cur, \"  \"))) cur += 2;\n-\t\t   else break;\n-\t   });\n+    while (true) repeat16({\n+        if (likely(byte_match_2(cur, \"  \"))) cur += 2;\n+        else break;\n+    });\n #endif\n-\n-   if (*cur == '{') {\n-\t   cur++;\n-\t   goto obj_begin;\n-   }\n-   if (*cur == '[') {\n-\t   cur++;\n-\t   goto arr_begin;\n-   }\n-   if (char_is_number(*cur)) {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_number(&cur, pre, ext, val, &msg))) goto arr_val_end;\n-\t   goto fail_number;\n-   }\n-   if (*cur == '\"') {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_string(&cur, end, inv, val, &msg))) goto arr_val_end;\n-\t   goto fail_string;\n-   }\n-   if (*cur == 't') {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_true(&cur, val))) goto arr_val_end;\n-\t   goto fail_literal;\n-   }\n-   if (*cur == 'f') {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_false(&cur, val))) goto arr_val_end;\n-\t   goto fail_literal;\n-   }\n-   if (*cur == 'n') {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_null(&cur, val))) goto arr_val_end;\n-\t   if (unlikely(ext)) {\n-\t\t   if (read_nan(false, &cur, pre, val)) goto arr_val_end;\n-\t   }\n-\t   goto fail_literal;\n-   }\n-   if (*cur == ']') {\n-\t   cur++;\n-\t   if (likely(ctn_len == 0)) goto arr_end;\n-\t   if (has_flag(ALLOW_TRAILING_COMMAS)) goto arr_end;\n-\t   goto fail_trailing_comma;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto arr_val_begin;\n-   }\n-   if (unlikely(ext) && (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (read_inf_or_nan(false, &cur, pre, val)) goto arr_val_end;\n-\t   goto fail_character;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto arr_val_begin;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    \n+    if (*cur == '{') {\n+        cur++;\n+        goto obj_begin;\n+    }\n+    if (*cur == '[') {\n+        cur++;\n+        goto arr_begin;\n+    }\n+    if (char_is_number(*cur)) {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_number(&cur, pre, ext, val, &msg))) goto arr_val_end;\n+        goto fail_number;\n+    }\n+    if (*cur == '\"') {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_string(&cur, end, inv, val, &msg))) goto arr_val_end;\n+        goto fail_string;\n+    }\n+    if (*cur == 't') {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_true(&cur, val))) goto arr_val_end;\n+        goto fail_literal;\n+    }\n+    if (*cur == 'f') {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_false(&cur, val))) goto arr_val_end;\n+        goto fail_literal;\n+    }\n+    if (*cur == 'n') {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_null(&cur, val))) goto arr_val_end;\n+        if (unlikely(ext)) {\n+            if (read_nan(false, &cur, pre, val)) goto arr_val_end;\n+        }\n+        goto fail_literal;\n+    }\n+    if (*cur == ']') {\n+        cur++;\n+        if (likely(ctn_len == 0)) goto arr_end;\n+        if (has_flag(ALLOW_TRAILING_COMMAS)) goto arr_end;\n+        goto fail_trailing_comma;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto arr_val_begin;\n+    }\n+    if (unlikely(ext) && (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n+        val_incr();\n+        ctn_len++;\n+        if (read_inf_or_nan(false, &cur, pre, val)) goto arr_val_end;\n+        goto fail_character;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto arr_val_begin;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n arr_val_end:\n-   if (byte_match_2(cur, \",\\n\")) {\n-\t   cur += 2;\n-\t   goto arr_val_begin;\n-   }\n-   if (*cur == ',') {\n-\t   cur++;\n-\t   goto arr_val_begin;\n-   }\n-   if (*cur == ']') {\n-\t   cur++;\n-\t   goto arr_end;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto arr_val_end;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto arr_val_end;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    if (byte_match_2(cur, \",\\n\")) {\n+        cur += 2;\n+        goto arr_val_begin;\n+    }\n+    if (*cur == ',') {\n+        cur++;\n+        goto arr_val_begin;\n+    }\n+    if (*cur == ']') {\n+        cur++;\n+        goto arr_end;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto arr_val_end;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto arr_val_end;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n arr_end:\n-   /* get parent container */\n-   ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n-\n-   /* save the next sibling value offset */\n-   ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n-   ctn->tag = ((ctn_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR;\n-   if (unlikely(ctn == ctn_parent)) goto doc_end;\n-\n-   /* pop parent as current container */\n-   ctn = ctn_parent;\n-   ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n-   if (*cur == '\\n') cur++;\n-   if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n-\t   goto obj_val_end;\n-   } else {\n-\t   goto arr_val_end;\n-   }\n-\n+    /* get parent container */\n+    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n+    \n+    /* save the next sibling value offset */\n+    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n+    ctn->tag = ((ctn_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR;\n+    if (unlikely(ctn == ctn_parent)) goto doc_end;\n+    \n+    /* pop parent as current container */\n+    ctn = ctn_parent;\n+    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n+    if (*cur == '\\n') cur++;\n+    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n+        goto obj_val_end;\n+    } else {\n+        goto arr_val_end;\n+    }\n+    \n obj_begin:\n-   /* push container */\n-   ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n-\t\t\t  (ctn->tag & YYJSON_TAG_MASK);\n-   val_incr();\n-   val->tag = YYJSON_TYPE_OBJ;\n-   /* offset to the parent */\n-   val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n-   ctn = val;\n-   ctn_len = 0;\n-   if (*cur == '\\n') cur++;\n-\n+    /* push container */\n+    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n+               (ctn->tag & YYJSON_TAG_MASK);\n+    val_incr();\n+    val->tag = YYJSON_TYPE_OBJ;\n+    /* offset to the parent */\n+    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n+    ctn = val;\n+    ctn_len = 0;\n+    if (*cur == '\\n') cur++;\n+    \n obj_key_begin:\n #if YYJSON_IS_REAL_GCC\n-   while (true) repeat16({\n-\t\t   if (byte_match_2(cur, \"  \")) cur += 2;\n-\t\t   else break;\n-\t   });\n+    while (true) repeat16({\n+        if (byte_match_2(cur, \"  \")) cur += 2;\n+        else break;\n+    });\n #else\n-   while (true) repeat16({\n-\t\t   if (likely(byte_match_2(cur, \"  \"))) cur += 2;\n-\t\t   else break;\n-\t   });\n+    while (true) repeat16({\n+        if (likely(byte_match_2(cur, \"  \"))) cur += 2;\n+        else break;\n+    });\n #endif\n-   if (likely(*cur == '\"')) {\n-\t   val_incr();\n-\t   ctn_len++;\n-\t   if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_key_end;\n-\t   goto fail_string;\n-   }\n-   if (likely(*cur == '}')) {\n-\t   cur++;\n-\t   if (likely(ctn_len == 0)) goto obj_end;\n-\t   if (has_flag(ALLOW_TRAILING_COMMAS)) goto obj_end;\n-\t   goto fail_trailing_comma;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto obj_key_begin;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto obj_key_begin;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    if (likely(*cur == '\"')) {\n+        val_incr();\n+        ctn_len++;\n+        if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_key_end;\n+        goto fail_string;\n+    }\n+    if (likely(*cur == '}')) {\n+        cur++;\n+        if (likely(ctn_len == 0)) goto obj_end;\n+        if (has_flag(ALLOW_TRAILING_COMMAS)) goto obj_end;\n+        goto fail_trailing_comma;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto obj_key_begin;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto obj_key_begin;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n obj_key_end:\n-   if (byte_match_2(cur, \": \")) {\n-\t   cur += 2;\n-\t   goto obj_val_begin;\n-   }\n-   if (*cur == ':') {\n-\t   cur++;\n-\t   goto obj_val_begin;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto obj_key_end;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto obj_key_end;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    if (byte_match_2(cur, \": \")) {\n+        cur += 2;\n+        goto obj_val_begin;\n+    }\n+    if (*cur == ':') {\n+        cur++;\n+        goto obj_val_begin;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto obj_key_end;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto obj_key_end;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n obj_val_begin:\n-   if (*cur == '\"') {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_val_end;\n-\t   goto fail_string;\n-   }\n-   if (char_is_number(*cur)) {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (likely(read_number(&cur, pre, ext, val, &msg))) goto obj_val_end;\n-\t   goto fail_number;\n-   }\n-   if (*cur == '{') {\n-\t   cur++;\n-\t   goto obj_begin;\n-   }\n-   if (*cur == '[') {\n-\t   cur++;\n-\t   goto arr_begin;\n-   }\n-   if (*cur == 't') {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (likely(read_true(&cur, val))) goto obj_val_end;\n-\t   goto fail_literal;\n-   }\n-   if (*cur == 'f') {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (likely(read_false(&cur, val))) goto obj_val_end;\n-\t   goto fail_literal;\n-   }\n-   if (*cur == 'n') {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (likely(read_null(&cur, val))) goto obj_val_end;\n-\t   if (unlikely(ext)) {\n-\t\t   if (read_nan(false, &cur, pre, val)) goto obj_val_end;\n-\t   }\n-\t   goto fail_literal;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto obj_val_begin;\n-   }\n-   if (unlikely(ext) && (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n-\t   val++;\n-\t   ctn_len++;\n-\t   if (read_inf_or_nan(false, &cur, pre, val)) goto obj_val_end;\n-\t   goto fail_character;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto obj_val_begin;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    if (*cur == '\"') {\n+        val++;\n+        ctn_len++;\n+        if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_val_end;\n+        goto fail_string;\n+    }\n+    if (char_is_number(*cur)) {\n+        val++;\n+        ctn_len++;\n+        if (likely(read_number(&cur, pre, ext, val, &msg))) goto obj_val_end;\n+        goto fail_number;\n+    }\n+    if (*cur == '{') {\n+        cur++;\n+        goto obj_begin;\n+    }\n+    if (*cur == '[') {\n+        cur++;\n+        goto arr_begin;\n+    }\n+    if (*cur == 't') {\n+        val++;\n+        ctn_len++;\n+        if (likely(read_true(&cur, val))) goto obj_val_end;\n+        goto fail_literal;\n+    }\n+    if (*cur == 'f') {\n+        val++;\n+        ctn_len++;\n+        if (likely(read_false(&cur, val))) goto obj_val_end;\n+        goto fail_literal;\n+    }\n+    if (*cur == 'n') {\n+        val++;\n+        ctn_len++;\n+        if (likely(read_null(&cur, val))) goto obj_val_end;\n+        if (unlikely(ext)) {\n+            if (read_nan(false, &cur, pre, val)) goto obj_val_end;\n+        }\n+        goto fail_literal;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto obj_val_begin;\n+    }\n+    if (unlikely(ext) && (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n+        val++;\n+        ctn_len++;\n+        if (read_inf_or_nan(false, &cur, pre, val)) goto obj_val_end;\n+        goto fail_character;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto obj_val_begin;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n obj_val_end:\n-   if (byte_match_2(cur, \",\\n\")) {\n-\t   cur += 2;\n-\t   goto obj_key_begin;\n-   }\n-   if (likely(*cur == ',')) {\n-\t   cur++;\n-\t   goto obj_key_begin;\n-   }\n-   if (likely(*cur == '}')) {\n-\t   cur++;\n-\t   goto obj_end;\n-   }\n-   if (char_is_space(*cur)) {\n-\t   while (char_is_space(*++cur));\n-\t   goto obj_val_end;\n-   }\n-   if (has_flag(ALLOW_COMMENTS)) {\n-\t   if (skip_spaces_and_comments(&cur)) goto obj_val_end;\n-\t   if (byte_match_2(cur, \"/*\")) goto fail_comment;\n-   }\n-   goto fail_character;\n-\n+    if (byte_match_2(cur, \",\\n\")) {\n+        cur += 2;\n+        goto obj_key_begin;\n+    }\n+    if (likely(*cur == ',')) {\n+        cur++;\n+        goto obj_key_begin;\n+    }\n+    if (likely(*cur == '}')) {\n+        cur++;\n+        goto obj_end;\n+    }\n+    if (char_is_space(*cur)) {\n+        while (char_is_space(*++cur));\n+        goto obj_val_end;\n+    }\n+    if (has_flag(ALLOW_COMMENTS)) {\n+        if (skip_spaces_and_comments(&cur)) goto obj_val_end;\n+        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n+    }\n+    goto fail_character;\n+    \n obj_end:\n-   /* pop container */\n-   ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n-   /* point to the next value */\n-   ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n-   ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\n-   if (unlikely(ctn == ctn_parent)) goto doc_end;\n-   ctn = ctn_parent;\n-   ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n-   if (*cur == '\\n') cur++;\n-   if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n-\t   goto obj_val_end;\n-   } else {\n-\t   goto arr_val_end;\n-   }\n-\n+    /* pop container */\n+    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n+    /* point to the next value */\n+    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n+    ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\n+    if (unlikely(ctn == ctn_parent)) goto doc_end;\n+    ctn = ctn_parent;\n+    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n+    if (*cur == '\\n') cur++;\n+    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n+        goto obj_val_end;\n+    } else {\n+        goto arr_val_end;\n+    }\n+    \n doc_end:\n-   /* check invalid contents after json document */\n-   if (unlikely(cur < end) && !has_flag(STOP_WHEN_DONE)) {\n-\t   if (has_flag(ALLOW_COMMENTS)) skip_spaces_and_comments(&cur);\n-\t   else while (char_is_space(*cur)) cur++;\n-\t   if (unlikely(cur < end)) goto fail_garbage;\n-   }\n-\n-   if (pre && *pre) **pre = '\\0';\n-   doc = (yyjson_doc *)val_hdr;\n-   doc->root = val_hdr + hdr_len;\n-   doc->alc = alc;\n-   doc->dat_read = (usize)(cur - hdr);\n-   doc->val_read = (usize)((val - val_hdr)) - hdr_len + 1;\n-   doc->str_pool = has_flag(INSITU) ? NULL : (char *)hdr;\n-   return doc;\n-\n+    /* check invalid contents after json document */\n+    if (unlikely(cur < end) && !has_flag(STOP_WHEN_DONE)) {\n+        if (has_flag(ALLOW_COMMENTS)) skip_spaces_and_comments(&cur);\n+        else while (char_is_space(*cur)) cur++;\n+        if (unlikely(cur < end)) goto fail_garbage;\n+    }\n+    \n+    if (pre && *pre) **pre = '\\0';\n+    doc = (yyjson_doc *)val_hdr;\n+    doc->root = val_hdr + hdr_len;\n+    doc->alc = alc;\n+    doc->dat_read = (usize)(cur - hdr);\n+    doc->val_read = (usize)((val - val_hdr)) - hdr_len + 1;\n+    doc->str_pool = has_flag(INSITU) ? NULL : (char *)hdr;\n+    return doc;\n+    \n fail_string:\n-   return_err(cur, INVALID_STRING, msg);\n+    return_err(cur, INVALID_STRING, msg);\n fail_number:\n-   return_err(cur, INVALID_NUMBER, msg);\n+    return_err(cur, INVALID_NUMBER, msg);\n fail_alloc:\n-   return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");\n+    return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");\n fail_trailing_comma:\n-   return_err(cur, JSON_STRUCTURE, \"trailing comma is not allowed\");\n+    return_err(cur, JSON_STRUCTURE, \"trailing comma is not allowed\");\n fail_literal:\n-   return_err(cur, LITERAL, \"invalid literal\");\n+    return_err(cur, LITERAL, \"invalid literal\");\n fail_comment:\n-   return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\n+    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\n fail_character:\n-   return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\n+    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\n fail_garbage:\n-   return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\n-\n+    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\n+    \n #undef has_flag\n #undef val_incr\n #undef return_err\n@@ -5442,217 +5560,262 @@ static_inline yyjson_doc *read_root_pretty(u8 *hdr,\n \n \n /*==============================================================================\n-* JSON Reader Entrance\n-*============================================================================*/\n+ * JSON Reader Entrance\n+ *============================================================================*/\n \n yyjson_doc *yyjson_read_opts(char *dat,\n-\t\t\t\t\t\t\tusize len,\n-\t\t\t\t\t\t\tyyjson_read_flag flg,\n-\t\t\t\t\t\t\tconst yyjson_alc *alc_ptr,\n-\t\t\t\t\t\t\tyyjson_read_err *err) {\n-\n+                             usize len,\n+                             yyjson_read_flag flg,\n+                             const yyjson_alc *alc_ptr,\n+                             yyjson_read_err *err) {\n+    \n #define has_flag(_flag) unlikely((flg & YYJSON_READ_##_flag) != 0)\n-\n+    \n #define return_err(_pos, _code, _msg) do { \\\n-   err->pos = (usize)(_pos); \\\n-   err->msg = _msg; \\\n-   err->code = YYJSON_READ_ERROR_##_code; \\\n-   if (!has_flag(INSITU) && hdr) alc.free(alc.ctx, (void *)hdr); \\\n-   return NULL; \\\n+    err->pos = (usize)(_pos); \\\n+    err->msg = _msg; \\\n+    err->code = YYJSON_READ_ERROR_##_code; \\\n+    if (!has_flag(INSITU) && hdr) alc.free(alc.ctx, (void *)hdr); \\\n+    return NULL; \\\n } while (false)\n-\n-   yyjson_read_err dummy_err;\n-   yyjson_alc alc;\n-   yyjson_doc *doc;\n-   u8 *hdr = NULL, *end, *cur;\n-\n+    \n+    yyjson_read_err dummy_err;\n+    yyjson_alc alc;\n+    yyjson_doc *doc;\n+    u8 *hdr = NULL, *end, *cur;\n+    \n #if YYJSON_DISABLE_NON_STANDARD\n-   flg &= ~YYJSON_READ_ALLOW_TRAILING_COMMAS;\n-   flg &= ~YYJSON_READ_ALLOW_COMMENTS;\n-   flg &= ~YYJSON_READ_ALLOW_INF_AND_NAN;\n-   flg &= ~YYJSON_READ_ALLOW_INVALID_UNICODE;\n+    flg &= ~YYJSON_READ_ALLOW_TRAILING_COMMAS;\n+    flg &= ~YYJSON_READ_ALLOW_COMMENTS;\n+    flg &= ~YYJSON_READ_ALLOW_INF_AND_NAN;\n+    flg &= ~YYJSON_READ_ALLOW_INVALID_UNICODE;\n #endif\n-\n-   /* validate input parameters */\n-   if (!err) err = &dummy_err;\n-   if (likely(!alc_ptr)) {\n-\t   alc = YYJSON_DEFAULT_ALC;\n-   } else {\n-\t   alc = *alc_ptr;\n-   }\n-   if (unlikely(!dat)) {\n-\t   return_err(0, INVALID_PARAMETER, \"input data is NULL\");\n-   }\n-   if (unlikely(!len)) {\n-\t   return_err(0, INVALID_PARAMETER, \"input length is 0\");\n-   }\n-\n-   /* add 4-byte zero padding for input data if necessary */\n-   if (has_flag(INSITU)) {\n-\t   hdr = (u8 *)dat;\n-\t   end = (u8 *)dat + len;\n-\t   cur = (u8 *)dat;\n-   } else {\n-\t   if (unlikely(len >= USIZE_MAX - YYJSON_PADDING_SIZE)) {\n-\t\t   return_err(0, MEMORY_ALLOCATION, \"memory allocation failed\");\n-\t   }\n-\t   hdr = (u8 *)alc.malloc(alc.ctx, len + YYJSON_PADDING_SIZE);\n-\t   if (unlikely(!hdr)) {\n-\t\t   return_err(0, MEMORY_ALLOCATION, \"memory allocation failed\");\n-\t   }\n-\t   end = hdr + len;\n-\t   cur = hdr;\n-\t   memcpy(hdr, dat, len);\n-\t   memset(end, 0, YYJSON_PADDING_SIZE);\n-   }\n-\n-   /* skip empty contents before json document */\n-   if (unlikely(char_is_space_or_comment(*cur))) {\n-\t   if (has_flag(ALLOW_COMMENTS)) {\n-\t\t   if (!skip_spaces_and_comments(&cur)) {\n-\t\t\t   return_err(cur - hdr, INVALID_COMMENT,\n-\t\t\t\t\t\t  \"unclosed multiline comment\");\n-\t\t   }\n-\t   } else {\n-\t\t   if (likely(char_is_space(*cur))) {\n-\t\t\t   while (char_is_space(*++cur));\n-\t\t   }\n-\t   }\n-\t   if (unlikely(cur >= end)) {\n-\t\t   return_err(0, EMPTY_CONTENT, \"input data is empty\");\n-\t   }\n-   }\n-\n-   /* read json document */\n-   if (likely(char_is_container(*cur))) {\n-\t   if (char_is_space(cur[1]) && char_is_space(cur[2])) {\n-\t\t   doc = read_root_pretty(hdr, cur, end, alc, flg, err);\n-\t   } else {\n-\t\t   doc = read_root_minify(hdr, cur, end, alc, flg, err);\n-\t   }\n-   } else {\n-\t   doc = read_root_single(hdr, cur, end, alc, flg, err);\n-   }\n-\n-   /* check result */\n-   if (likely(doc)) {\n-\t   memset(err, 0, sizeof(yyjson_read_err));\n-   } else {\n-\t   /* RFC 8259: JSON text MUST be encoded using UTF-8 */\n-\t   if (err->pos == 0 && err->code != YYJSON_READ_ERROR_MEMORY_ALLOCATION) {\n-\t\t   if ((hdr[0] == 0xEF && hdr[1] == 0xBB && hdr[2] == 0xBF)) {\n-\t\t\t   err->msg = \"byte order mark (BOM) is not supported\";\n-\t\t   } else if (len >= 4 &&\n-\t\t\t\t\t  ((hdr[0] == 0x00 && hdr[1] == 0x00 &&\n-\t\t\t\t\t\thdr[2] == 0xFE && hdr[3] == 0xFF) ||\n-\t\t\t\t\t   (hdr[0] == 0xFF && hdr[1] == 0xFE &&\n-\t\t\t\t\t\thdr[2] == 0x00 && hdr[3] == 0x00))) {\n-\t\t\t   err->msg = \"UTF-32 encoding is not supported\";\n-\t\t   } else if (len >= 2 &&\n-\t\t\t\t\t  ((hdr[0] == 0xFE && hdr[1] == 0xFF) ||\n-\t\t\t\t\t   (hdr[0] == 0xFF && hdr[1] == 0xFE))) {\n-\t\t\t   err->msg = \"UTF-16 encoding is not supported\";\n-\t\t   }\n-\t   }\n-\t   if (!has_flag(INSITU)) alc.free(alc.ctx, (void *)hdr);\n-   }\n-   return doc;\n-\n+    \n+    /* validate input parameters */\n+    if (!err) err = &dummy_err;\n+    if (likely(!alc_ptr)) {\n+        alc = YYJSON_DEFAULT_ALC;\n+    } else {\n+        alc = *alc_ptr;\n+    }\n+    if (unlikely(!dat)) {\n+        return_err(0, INVALID_PARAMETER, \"input data is NULL\");\n+    }\n+    if (unlikely(!len)) {\n+        return_err(0, INVALID_PARAMETER, \"input length is 0\");\n+    }\n+    \n+    /* add 4-byte zero padding for input data if necessary */\n+    if (has_flag(INSITU)) {\n+        hdr = (u8 *)dat;\n+        end = (u8 *)dat + len;\n+        cur = (u8 *)dat;\n+    } else {\n+        if (unlikely(len >= USIZE_MAX - YYJSON_PADDING_SIZE)) {\n+            return_err(0, MEMORY_ALLOCATION, \"memory allocation failed\");\n+        }\n+        hdr = (u8 *)alc.malloc(alc.ctx, len + YYJSON_PADDING_SIZE);\n+        if (unlikely(!hdr)) {\n+            return_err(0, MEMORY_ALLOCATION, \"memory allocation failed\");\n+        }\n+        end = hdr + len;\n+        cur = hdr;\n+        memcpy(hdr, dat, len);\n+        memset(end, 0, YYJSON_PADDING_SIZE);\n+    }\n+    \n+    /* skip empty contents before json document */\n+    if (unlikely(char_is_space_or_comment(*cur))) {\n+        if (has_flag(ALLOW_COMMENTS)) {\n+            if (!skip_spaces_and_comments(&cur)) {\n+                return_err(cur - hdr, INVALID_COMMENT,\n+                           \"unclosed multiline comment\");\n+            }\n+        } else {\n+            if (likely(char_is_space(*cur))) {\n+                while (char_is_space(*++cur));\n+            }\n+        }\n+        if (unlikely(cur >= end)) {\n+            return_err(0, EMPTY_CONTENT, \"input data is empty\");\n+        }\n+    }\n+    \n+    /* read json document */\n+    if (likely(char_is_container(*cur))) {\n+        if (char_is_space(cur[1]) && char_is_space(cur[2])) {\n+            doc = read_root_pretty(hdr, cur, end, alc, flg, err);\n+        } else {\n+            doc = read_root_minify(hdr, cur, end, alc, flg, err);\n+        }\n+    } else {\n+        doc = read_root_single(hdr, cur, end, alc, flg, err);\n+    }\n+    \n+    /* check result */\n+    if (likely(doc)) {\n+        memset(err, 0, sizeof(yyjson_read_err));\n+    } else {\n+        /* RFC 8259: JSON text MUST be encoded using UTF-8 */\n+        if (err->pos == 0 && err->code != YYJSON_READ_ERROR_MEMORY_ALLOCATION) {\n+            if ((hdr[0] == 0xEF && hdr[1] == 0xBB && hdr[2] == 0xBF)) {\n+                err->msg = \"byte order mark (BOM) is not supported\";\n+            } else if (len >= 4 &&\n+                       ((hdr[0] == 0x00 && hdr[1] == 0x00 &&\n+                         hdr[2] == 0xFE && hdr[3] == 0xFF) ||\n+                        (hdr[0] == 0xFF && hdr[1] == 0xFE &&\n+                         hdr[2] == 0x00 && hdr[3] == 0x00))) {\n+                err->msg = \"UTF-32 encoding is not supported\";\n+            } else if (len >= 2 &&\n+                       ((hdr[0] == 0xFE && hdr[1] == 0xFF) ||\n+                        (hdr[0] == 0xFF && hdr[1] == 0xFE))) {\n+                err->msg = \"UTF-16 encoding is not supported\";\n+            }\n+        }\n+        if (!has_flag(INSITU)) alc.free(alc.ctx, (void *)hdr);\n+    }\n+    return doc;\n+    \n #undef has_flag\n #undef return_err\n }\n \n yyjson_doc *yyjson_read_file(const char *path,\n-\t\t\t\t\t\t\tyyjson_read_flag flg,\n-\t\t\t\t\t\t\tconst yyjson_alc *alc_ptr,\n-\t\t\t\t\t\t\tyyjson_read_err *err) {\n-\n+                             yyjson_read_flag flg,\n+                             const yyjson_alc *alc_ptr,\n+                             yyjson_read_err *err) {\n+    \n #define return_err(_code, _msg) do { \\\n-   err->pos = 0; \\\n-   err->msg = _msg; \\\n-   err->code = YYJSON_READ_ERROR_##_code; \\\n-   if (file) fclose(file); \\\n-   if (buf) alc.free(alc.ctx, buf); \\\n-   return NULL; \\\n+    err->pos = 0; \\\n+    err->msg = _msg; \\\n+    err->code = YYJSON_READ_ERROR_##_code; \\\n+    if (file) fclose(file); \\\n+    if (buf) alc.free(alc.ctx, buf); \\\n+    return NULL; \\\n } while (false)\n+    \n+    yyjson_read_err dummy_err;\n+    yyjson_alc alc = alc_ptr ? *alc_ptr : YYJSON_DEFAULT_ALC;\n+    yyjson_doc *doc;\n+    \n+    FILE *file = NULL;\n+    long file_size = 0;\n+    void *buf = NULL;\n+    usize buf_size = 0;\n+    \n+    /* validate input parameters */\n+    if (!err) err = &dummy_err;\n+    if (unlikely(!path)) return_err(INVALID_PARAMETER, \"input path is NULL\");\n+    \n+    /* open file */\n+    file = fopen_readonly(path);\n+    if (file == NULL) return_err(FILE_OPEN, \"file opening failed\");\n+    \n+    /* get file size */\n+    if (fseek(file, 0, SEEK_END) == 0) file_size = ftell(file);\n+    rewind(file);\n+    \n+    /* read file */\n+    if (file_size > 0) {\n+        /* read the entire file in one call */\n+        buf_size = (usize)file_size + YYJSON_PADDING_SIZE;\n+        buf = alc.malloc(alc.ctx, buf_size);\n+        if (buf == NULL) {\n+            return_err(MEMORY_ALLOCATION, \"fail to alloc memory\");\n+        }\n+        if (fread_safe(buf, (usize)file_size, file) != (usize)file_size) {\n+            return_err(FILE_READ, \"file reading failed\");\n+        }\n+    } else {\n+        /* failed to get file size, read it as a stream */\n+        usize chunk_min = (usize)64;\n+        usize chunk_max = (usize)512 * 1024 * 1024;\n+        usize chunk_now = chunk_min;\n+        usize read_size;\n+        void *tmp;\n+        \n+        buf_size = YYJSON_PADDING_SIZE;\n+        while (true) {\n+            if (buf_size + chunk_now < buf_size) { /* overflow */\n+                return_err(MEMORY_ALLOCATION, \"fail to alloc memory\");\n+            }\n+            buf_size += chunk_now;\n+            if (!buf) {\n+                buf = alc.malloc(alc.ctx, buf_size);\n+                if (!buf) return_err(MEMORY_ALLOCATION, \"fail to alloc memory\");\n+            } else {\n+                tmp = alc.realloc(alc.ctx, buf, buf_size - chunk_now, buf_size);\n+                if (!tmp) return_err(MEMORY_ALLOCATION, \"fail to alloc memory\");\n+                buf = tmp;\n+            }\n+            tmp = ((u8 *)buf) + buf_size - YYJSON_PADDING_SIZE - chunk_now;\n+            read_size = fread_safe(tmp, chunk_now, file);\n+            file_size += (long)read_size;\n+            if (read_size != chunk_now) break;\n+            \n+            chunk_now *= 2;\n+            if (chunk_now > chunk_max) chunk_now = chunk_max;\n+        }\n+    }\n+    fclose(file);\n+    \n+    /* read JSON */\n+    memset((u8 *)buf + file_size, 0, YYJSON_PADDING_SIZE);\n+    flg |= YYJSON_READ_INSITU;\n+    doc = yyjson_read_opts((char *)buf, (usize)file_size, flg, &alc, err);\n+    if (doc) {\n+        doc->str_pool = (char *)buf;\n+        return doc;\n+    } else {\n+        alc.free(alc.ctx, buf);\n+        return NULL;\n+    }\n+    \n+#undef return_err\n+}\n \n-   yyjson_read_err dummy_err;\n-   yyjson_alc alc = alc_ptr ? *alc_ptr : YYJSON_DEFAULT_ALC;\n-   yyjson_doc *doc;\n-\n-   FILE *file = NULL;\n-   long file_size = 0;\n-   void *buf = NULL;\n-   usize buf_size = 0;\n-\n-   /* validate input parameters */\n-   if (!err) err = &dummy_err;\n-   if (unlikely(!path)) return_err(INVALID_PARAMETER, \"input path is NULL\");\n-\n-   /* open file */\n-   file = fopen_readonly(path);\n-   if (file == NULL) return_err(FILE_OPEN, \"file opening failed\");\n-\n-   /* get file size */\n-   if (fseek(file, 0, SEEK_END) == 0) file_size = ftell(file);\n-   rewind(file);\n-\n-   /* read file */\n-   if (file_size > 0) {\n-\t   /* read the entire file in one call */\n-\t   buf_size = (usize)file_size + YYJSON_PADDING_SIZE;\n-\t   buf = alc.malloc(alc.ctx, buf_size);\n-\t   if (buf == NULL) {\n-\t\t   return_err(MEMORY_ALLOCATION, \"fail to alloc memory\");\n-\t   }\n-\t   if (fread_safe(buf, (usize)file_size, file) != (usize)file_size) {\n-\t\t   return_err(FILE_READ, \"file reading failed\");\n-\t   }\n-   } else {\n-\t   /* failed to get file size, read it as a stream */\n-\t   usize chunk_min = (usize)64;\n-\t   usize chunk_max = (usize)512 * 1024 * 1024;\n-\t   usize chunk_now = chunk_min;\n-\t   usize read_size;\n-\t   void *tmp;\n-\n-\t   buf_size = YYJSON_PADDING_SIZE;\n-\t   while (true) {\n-\t\t   if (buf_size + chunk_now < buf_size) { /* overflow */\n-\t\t\t   return_err(MEMORY_ALLOCATION, \"fail to alloc memory\");\n-\t\t   }\n-\t\t   buf_size += chunk_now;\n-\t\t   if (!buf) {\n-\t\t\t   buf = alc.malloc(alc.ctx, buf_size);\n-\t\t\t   if (!buf) return_err(MEMORY_ALLOCATION, \"fail to alloc memory\");\n-\t\t   } else {\n-\t\t\t   tmp = alc.realloc(alc.ctx, buf, buf_size);\n-\t\t\t   if (!tmp) return_err(MEMORY_ALLOCATION, \"fail to alloc memory\");\n-\t\t\t   buf = tmp;\n-\t\t   }\n-\t\t   tmp = ((u8 *)buf) + buf_size - YYJSON_PADDING_SIZE - chunk_now;\n-\t\t   read_size = fread_safe(tmp, chunk_now, file);\n-\t\t   file_size += (long)read_size;\n-\t\t   if (read_size != chunk_now) break;\n-\n-\t\t   chunk_now *= 2;\n-\t\t   if (chunk_now > chunk_max) chunk_now = chunk_max;\n-\t   }\n-   }\n-   fclose(file);\n-\n-   /* read JSON */\n-   memset((u8 *)buf + file_size, 0, YYJSON_PADDING_SIZE);\n-   flg |= YYJSON_READ_INSITU;\n-   doc = yyjson_read_opts((char *)buf, (usize)file_size, flg, &alc, err);\n-   if (doc) {\n-\t   doc->str_pool = (char *)buf;\n-\t   return doc;\n-   } else {\n-\t   alc.free(alc.ctx, buf);\n-\t   return NULL;\n-   }\n-\n+const char *yyjson_read_number(const char *dat,\n+                               yyjson_val *val,\n+                               yyjson_read_flag flg,\n+                               yyjson_read_err *err) {\n+#define return_err(_pos, _code, _msg) do { \\\n+    err->pos = _pos > hdr ? (usize)(_pos - hdr) : 0; \\\n+    err->msg = _msg; \\\n+    err->code = YYJSON_READ_ERROR_##_code; \\\n+    return NULL; \\\n+} while (false)\n+    \n+    u8 *hdr = (u8 *)dat, *cur = hdr;\n+    bool raw; /* read number as raw */\n+    bool ext; /* allow inf and nan */\n+    u8 *raw_end; /* raw end for null-terminator */\n+    u8 **pre; /* previous raw end pointer */\n+    const char *msg;\n+    yyjson_read_err dummy_err;\n+    if (!err) err = &dummy_err;\n+    \n+    if (unlikely(!dat)) {\n+        return_err(cur, INVALID_PARAMETER, \"input data is NULL\");\n+    }\n+    if (unlikely(!val)) {\n+        return_err(cur, INVALID_PARAMETER, \"output value is NULL\");\n+    }\n+    \n+#if YYJSON_DISABLE_NON_STANDARD\n+    ext = false;\n+#else\n+    ext = (flg & YYJSON_READ_ALLOW_INF_AND_NAN) != 0;\n+#endif\n+    \n+    raw = (flg & YYJSON_READ_NUMBER_AS_RAW) != 0;\n+    raw_end = NULL;\n+    pre = raw ? &raw_end : NULL;\n+    \n+    if (!read_number(&cur, pre, ext, val, &msg)) {\n+        return_err(cur, INVALID_NUMBER, msg);\n+    }\n+    return (const char *)cur;\n+    \n #undef return_err\n }\n \n@@ -5663,666 +5826,669 @@ yyjson_doc *yyjson_read_file(const char *path,\n #if !YYJSON_DISABLE_WRITER\n \n /*==============================================================================\n-* Integer Writer\n-*\n-* The maximum value of uint32_t is 4294967295 (10 digits),\n-* these digits are named as 'aabbccddee' here.\n-*\n-* Although most compilers may convert the \"division by constant value\" into\n-* \"multiply and shift\", manual conversion can still help some compilers\n-* generate fewer and better instructions.\n-*\n-* Reference:\n-* Division by Invariant Integers using Multiplication, 1994.\n-* https://gmplib.org/~tege/divcnst-pldi94.pdf\n-* Improved division by invariant integers, 2011.\n-* https://gmplib.org/~tege/division-paper.pdf\n-*============================================================================*/\n+ * Integer Writer\n+ *\n+ * The maximum value of uint32_t is 4294967295 (10 digits),\n+ * these digits are named as 'aabbccddee' here.\n+ *\n+ * Although most compilers may convert the \"division by constant value\" into\n+ * \"multiply and shift\", manual conversion can still help some compilers\n+ * generate fewer and better instructions.\n+ *\n+ * Reference:\n+ * Division by Invariant Integers using Multiplication, 1994.\n+ * https://gmplib.org/~tege/divcnst-pldi94.pdf\n+ * Improved division by invariant integers, 2011.\n+ * https://gmplib.org/~tege/division-paper.pdf\n+ *============================================================================*/\n \n /** Digit table from 00 to 99. */\n yyjson_align(2)\n-   static const char digit_table[200] = {\n-\t   '0', '0', '0', '1', '0', '2', '0', '3', '0', '4',\n-\t   '0', '5', '0', '6', '0', '7', '0', '8', '0', '9',\n-\t   '1', '0', '1', '1', '1', '2', '1', '3', '1', '4',\n-\t   '1', '5', '1', '6', '1', '7', '1', '8', '1', '9',\n-\t   '2', '0', '2', '1', '2', '2', '2', '3', '2', '4',\n-\t   '2', '5', '2', '6', '2', '7', '2', '8', '2', '9',\n-\t   '3', '0', '3', '1', '3', '2', '3', '3', '3', '4',\n-\t   '3', '5', '3', '6', '3', '7', '3', '8', '3', '9',\n-\t   '4', '0', '4', '1', '4', '2', '4', '3', '4', '4',\n-\t   '4', '5', '4', '6', '4', '7', '4', '8', '4', '9',\n-\t   '5', '0', '5', '1', '5', '2', '5', '3', '5', '4',\n-\t   '5', '5', '5', '6', '5', '7', '5', '8', '5', '9',\n-\t   '6', '0', '6', '1', '6', '2', '6', '3', '6', '4',\n-\t   '6', '5', '6', '6', '6', '7', '6', '8', '6', '9',\n-\t   '7', '0', '7', '1', '7', '2', '7', '3', '7', '4',\n-\t   '7', '5', '7', '6', '7', '7', '7', '8', '7', '9',\n-\t   '8', '0', '8', '1', '8', '2', '8', '3', '8', '4',\n-\t   '8', '5', '8', '6', '8', '7', '8', '8', '8', '9',\n-\t   '9', '0', '9', '1', '9', '2', '9', '3', '9', '4',\n-\t   '9', '5', '9', '6', '9', '7', '9', '8', '9', '9'\n+static const char digit_table[200] = {\n+    '0', '0', '0', '1', '0', '2', '0', '3', '0', '4',\n+    '0', '5', '0', '6', '0', '7', '0', '8', '0', '9',\n+    '1', '0', '1', '1', '1', '2', '1', '3', '1', '4',\n+    '1', '5', '1', '6', '1', '7', '1', '8', '1', '9',\n+    '2', '0', '2', '1', '2', '2', '2', '3', '2', '4',\n+    '2', '5', '2', '6', '2', '7', '2', '8', '2', '9',\n+    '3', '0', '3', '1', '3', '2', '3', '3', '3', '4',\n+    '3', '5', '3', '6', '3', '7', '3', '8', '3', '9',\n+    '4', '0', '4', '1', '4', '2', '4', '3', '4', '4',\n+    '4', '5', '4', '6', '4', '7', '4', '8', '4', '9',\n+    '5', '0', '5', '1', '5', '2', '5', '3', '5', '4',\n+    '5', '5', '5', '6', '5', '7', '5', '8', '5', '9',\n+    '6', '0', '6', '1', '6', '2', '6', '3', '6', '4',\n+    '6', '5', '6', '6', '6', '7', '6', '8', '6', '9',\n+    '7', '0', '7', '1', '7', '2', '7', '3', '7', '4',\n+    '7', '5', '7', '6', '7', '7', '7', '8', '7', '9',\n+    '8', '0', '8', '1', '8', '2', '8', '3', '8', '4',\n+    '8', '5', '8', '6', '8', '7', '8', '8', '8', '9',\n+    '9', '0', '9', '1', '9', '2', '9', '3', '9', '4',\n+    '9', '5', '9', '6', '9', '7', '9', '8', '9', '9'\n };\n \n static_inline u8 *write_u32_len_8(u32 val, u8 *buf) {\n-   u32 aa, bb, cc, dd, aabb, ccdd;                 /* 8 digits: aabbccdd */\n-   aabb = (u32)(((u64)val * 109951163) >> 40);     /* (val / 10000) */\n-   ccdd = val - aabb * 10000;                      /* (val % 10000) */\n-   aa = (aabb * 5243) >> 19;                       /* (aabb / 100) */\n-   cc = (ccdd * 5243) >> 19;                       /* (ccdd / 100) */\n-   bb = aabb - aa * 100;                           /* (aabb % 100) */\n-   dd = ccdd - cc * 100;                           /* (ccdd % 100) */\n-   ((v16 *)buf)[0] = ((const v16 *)digit_table)[aa];\n-   ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n-   ((v16 *)buf)[2] = ((const v16 *)digit_table)[cc];\n-   ((v16 *)buf)[3] = ((const v16 *)digit_table)[dd];\n-   return buf + 8;\n+    u32 aa, bb, cc, dd, aabb, ccdd;                 /* 8 digits: aabbccdd */\n+    aabb = (u32)(((u64)val * 109951163) >> 40);     /* (val / 10000) */\n+    ccdd = val - aabb * 10000;                      /* (val % 10000) */\n+    aa = (aabb * 5243) >> 19;                       /* (aabb / 100) */\n+    cc = (ccdd * 5243) >> 19;                       /* (ccdd / 100) */\n+    bb = aabb - aa * 100;                           /* (aabb % 100) */\n+    dd = ccdd - cc * 100;                           /* (ccdd % 100) */\n+    ((v16 *)buf)[0] = ((const v16 *)digit_table)[aa];\n+    ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n+    ((v16 *)buf)[2] = ((const v16 *)digit_table)[cc];\n+    ((v16 *)buf)[3] = ((const v16 *)digit_table)[dd];\n+    return buf + 8;\n }\n \n static_inline u8 *write_u32_len_4(u32 val, u8 *buf) {\n-   u32 aa, bb;                                     /* 4 digits: aabb */\n-   aa = (val * 5243) >> 19;                        /* (val / 100) */\n-   bb = val - aa * 100;                            /* (val % 100) */\n-   ((v16 *)buf)[0] = ((const v16 *)digit_table)[aa];\n-   ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n-   return buf + 4;\n+    u32 aa, bb;                                     /* 4 digits: aabb */\n+    aa = (val * 5243) >> 19;                        /* (val / 100) */\n+    bb = val - aa * 100;                            /* (val % 100) */\n+    ((v16 *)buf)[0] = ((const v16 *)digit_table)[aa];\n+    ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n+    return buf + 4;\n }\n \n static_inline u8 *write_u32_len_1_8(u32 val, u8 *buf) {\n-   u32 aa, bb, cc, dd, aabb, bbcc, ccdd, lz;\n-\n-   if (val < 100) {                                /* 1-2 digits: aa */\n-\t   lz = val < 10;                              /* leading zero: 0 or 1 */\n-\t   ((v16 *)buf)[0] = *(const v16 *)(digit_table + (val * 2 + lz));\n-\t   buf -= lz;\n-\t   return buf + 2;\n-\n-   } else if (val < 10000) {                       /* 3-4 digits: aabb */\n-\t   aa = (val * 5243) >> 19;                    /* (val / 100) */\n-\t   bb = val - aa * 100;                        /* (val % 100) */\n-\t   lz = aa < 10;                               /* leading zero: 0 or 1 */\n-\t   ((v16 *)buf)[0] = *(const v16 *)(digit_table + (aa * 2 + lz));\n-\t   buf -= lz;\n-\t   ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n-\t   return buf + 4;\n-\n-   } else if (val < 1000000) {                     /* 5-6 digits: aabbcc */\n-\t   aa = (u32)(((u64)val * 429497) >> 32);      /* (val / 10000) */\n-\t   bbcc = val - aa * 10000;                    /* (val % 10000) */\n-\t   bb = (bbcc * 5243) >> 19;                   /* (bbcc / 100) */\n-\t   cc = bbcc - bb * 100;                       /* (bbcc % 100) */\n-\t   lz = aa < 10;                               /* leading zero: 0 or 1 */\n-\t   ((v16 *)buf)[0] = *(const v16 *)(digit_table + (aa * 2 + lz));\n-\t   buf -= lz;\n-\t   ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n-\t   ((v16 *)buf)[2] = ((const v16 *)digit_table)[cc];\n-\t   return buf + 6;\n-\n-   } else {                                        /* 7-8 digits: aabbccdd */\n-\t   aabb = (u32)(((u64)val * 109951163) >> 40); /* (val / 10000) */\n-\t   ccdd = val - aabb * 10000;                  /* (val % 10000) */\n-\t   aa = (aabb * 5243) >> 19;                   /* (aabb / 100) */\n-\t   cc = (ccdd * 5243) >> 19;                   /* (ccdd / 100) */\n-\t   bb = aabb - aa * 100;                       /* (aabb % 100) */\n-\t   dd = ccdd - cc * 100;                       /* (ccdd % 100) */\n-\t   lz = aa < 10;                               /* leading zero: 0 or 1 */\n-\t   ((v16 *)buf)[0] = *(const v16 *)(digit_table + (aa * 2 + lz));\n-\t   buf -= lz;\n-\t   ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n-\t   ((v16 *)buf)[2] = ((const v16 *)digit_table)[cc];\n-\t   ((v16 *)buf)[3] = ((const v16 *)digit_table)[dd];\n-\t   return buf + 8;\n-   }\n+    u32 aa, bb, cc, dd, aabb, bbcc, ccdd, lz;\n+    \n+    if (val < 100) {                                /* 1-2 digits: aa */\n+        lz = val < 10;                              /* leading zero: 0 or 1 */\n+        ((v16 *)buf)[0] = *(const v16 *)(digit_table + (val * 2 + lz));\n+        buf -= lz;\n+        return buf + 2;\n+        \n+    } else if (val < 10000) {                       /* 3-4 digits: aabb */\n+        aa = (val * 5243) >> 19;                    /* (val / 100) */\n+        bb = val - aa * 100;                        /* (val % 100) */\n+        lz = aa < 10;                               /* leading zero: 0 or 1 */\n+        ((v16 *)buf)[0] = *(const v16 *)(digit_table + (aa * 2 + lz));\n+        buf -= lz;\n+        ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n+        return buf + 4;\n+        \n+    } else if (val < 1000000) {                     /* 5-6 digits: aabbcc */\n+        aa = (u32)(((u64)val * 429497) >> 32);      /* (val / 10000) */\n+        bbcc = val - aa * 10000;                    /* (val % 10000) */\n+        bb = (bbcc * 5243) >> 19;                   /* (bbcc / 100) */\n+        cc = bbcc - bb * 100;                       /* (bbcc % 100) */\n+        lz = aa < 10;                               /* leading zero: 0 or 1 */\n+        ((v16 *)buf)[0] = *(const v16 *)(digit_table + (aa * 2 + lz));\n+        buf -= lz;\n+        ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n+        ((v16 *)buf)[2] = ((const v16 *)digit_table)[cc];\n+        return buf + 6;\n+        \n+    } else {                                        /* 7-8 digits: aabbccdd */\n+        aabb = (u32)(((u64)val * 109951163) >> 40); /* (val / 10000) */\n+        ccdd = val - aabb * 10000;                  /* (val % 10000) */\n+        aa = (aabb * 5243) >> 19;                   /* (aabb / 100) */\n+        cc = (ccdd * 5243) >> 19;                   /* (ccdd / 100) */\n+        bb = aabb - aa * 100;                       /* (aabb % 100) */\n+        dd = ccdd - cc * 100;                       /* (ccdd % 100) */\n+        lz = aa < 10;                               /* leading zero: 0 or 1 */\n+        ((v16 *)buf)[0] = *(const v16 *)(digit_table + (aa * 2 + lz));\n+        buf -= lz;\n+        ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n+        ((v16 *)buf)[2] = ((const v16 *)digit_table)[cc];\n+        ((v16 *)buf)[3] = ((const v16 *)digit_table)[dd];\n+        return buf + 8;\n+    }\n }\n \n static_inline u8 *write_u64_len_5_8(u32 val, u8 *buf) {\n-   u32 aa, bb, cc, dd, aabb, bbcc, ccdd, lz;\n-\n-   if (val < 1000000) {                            /* 5-6 digits: aabbcc */\n-\t   aa = (u32)(((u64)val * 429497) >> 32);      /* (val / 10000) */\n-\t   bbcc = val - aa * 10000;                    /* (val % 10000) */\n-\t   bb = (bbcc * 5243) >> 19;                   /* (bbcc / 100) */\n-\t   cc = bbcc - bb * 100;                       /* (bbcc % 100) */\n-\t   lz = aa < 10;                               /* leading zero: 0 or 1 */\n-\t   ((v16 *)buf)[0] = *(const v16 *)(digit_table + (aa * 2 + lz));\n-\t   buf -= lz;\n-\t   ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n-\t   ((v16 *)buf)[2] = ((const v16 *)digit_table)[cc];\n-\t   return buf + 6;\n-\n-   } else {                                        /* 7-8 digits: aabbccdd */\n-\t   aabb = (u32)(((u64)val * 109951163) >> 40); /* (val / 10000) */\n-\t   ccdd = val - aabb * 10000;                  /* (val % 10000) */\n-\t   aa = (aabb * 5243) >> 19;                   /* (aabb / 100) */\n-\t   cc = (ccdd * 5243) >> 19;                   /* (ccdd / 100) */\n-\t   bb = aabb - aa * 100;                       /* (aabb % 100) */\n-\t   dd = ccdd - cc * 100;                       /* (ccdd % 100) */\n-\t   lz = aa < 10;                               /* leading zero: 0 or 1 */\n-\t   ((v16 *)buf)[0] = *(const v16 *)(digit_table + (aa * 2 + lz));\n-\t   buf -= lz;\n-\t   ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n-\t   ((v16 *)buf)[2] = ((const v16 *)digit_table)[cc];\n-\t   ((v16 *)buf)[3] = ((const v16 *)digit_table)[dd];\n-\t   return buf + 8;\n-   }\n+    u32 aa, bb, cc, dd, aabb, bbcc, ccdd, lz;\n+    \n+    if (val < 1000000) {                            /* 5-6 digits: aabbcc */\n+        aa = (u32)(((u64)val * 429497) >> 32);      /* (val / 10000) */\n+        bbcc = val - aa * 10000;                    /* (val % 10000) */\n+        bb = (bbcc * 5243) >> 19;                   /* (bbcc / 100) */\n+        cc = bbcc - bb * 100;                       /* (bbcc % 100) */\n+        lz = aa < 10;                               /* leading zero: 0 or 1 */\n+        ((v16 *)buf)[0] = *(const v16 *)(digit_table + (aa * 2 + lz));\n+        buf -= lz;\n+        ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n+        ((v16 *)buf)[2] = ((const v16 *)digit_table)[cc];\n+        return buf + 6;\n+        \n+    } else {                                        /* 7-8 digits: aabbccdd */\n+        aabb = (u32)(((u64)val * 109951163) >> 40); /* (val / 10000) */\n+        ccdd = val - aabb * 10000;                  /* (val % 10000) */\n+        aa = (aabb * 5243) >> 19;                   /* (aabb / 100) */\n+        cc = (ccdd * 5243) >> 19;                   /* (ccdd / 100) */\n+        bb = aabb - aa * 100;                       /* (aabb % 100) */\n+        dd = ccdd - cc * 100;                       /* (ccdd % 100) */\n+        lz = aa < 10;                               /* leading zero: 0 or 1 */\n+        ((v16 *)buf)[0] = *(const v16 *)(digit_table + (aa * 2 + lz));\n+        buf -= lz;\n+        ((v16 *)buf)[1] = ((const v16 *)digit_table)[bb];\n+        ((v16 *)buf)[2] = ((const v16 *)digit_table)[cc];\n+        ((v16 *)buf)[3] = ((const v16 *)digit_table)[dd];\n+        return buf + 8;\n+    }\n }\n \n static_inline u8 *write_u64(u64 val, u8 *buf) {\n-   u64 tmp, hgh;\n-   u32 mid, low;\n-\n-   if (val < 100000000) {                          /* 1-8 digits */\n-\t   buf = write_u32_len_1_8((u32)val, buf);\n-\t   return buf;\n-\n-   } else if (val < (u64)100000000 * 100000000) {  /* 9-16 digits */\n-\t   hgh = val / 100000000;                      /* (val / 100000000) */\n-\t   low = (u32)(val - hgh * 100000000);         /* (val % 100000000) */\n-\t   buf = write_u32_len_1_8((u32)hgh, buf);\n-\t   buf = write_u32_len_8(low, buf);\n-\t   return buf;\n-\n-   } else {                                        /* 17-20 digits */\n-\t   tmp = val / 100000000;                      /* (val / 100000000) */\n-\t   low = (u32)(val - tmp * 100000000);         /* (val % 100000000) */\n-\t   hgh = (u32)(tmp / 10000);                   /* (tmp / 10000) */\n-\t   mid = (u32)(tmp - hgh * 10000);             /* (tmp % 10000) */\n-\t   buf = write_u64_len_5_8((u32)hgh, buf);\n-\t   buf = write_u32_len_4(mid, buf);\n-\t   buf = write_u32_len_8(low, buf);\n-\t   return buf;\n-   }\n+    u64 tmp, hgh;\n+    u32 mid, low;\n+    \n+    if (val < 100000000) {                          /* 1-8 digits */\n+        buf = write_u32_len_1_8((u32)val, buf);\n+        return buf;\n+        \n+    } else if (val < (u64)100000000 * 100000000) {  /* 9-16 digits */\n+        hgh = val / 100000000;                      /* (val / 100000000) */\n+        low = (u32)(val - hgh * 100000000);         /* (val % 100000000) */\n+        buf = write_u32_len_1_8((u32)hgh, buf);\n+        buf = write_u32_len_8(low, buf);\n+        return buf;\n+        \n+    } else {                                        /* 17-20 digits */\n+        tmp = val / 100000000;                      /* (val / 100000000) */\n+        low = (u32)(val - tmp * 100000000);         /* (val % 100000000) */\n+        hgh = (u32)(tmp / 10000);                   /* (tmp / 10000) */\n+        mid = (u32)(tmp - hgh * 10000);             /* (tmp % 10000) */\n+        buf = write_u64_len_5_8((u32)hgh, buf);\n+        buf = write_u32_len_4(mid, buf);\n+        buf = write_u32_len_8(low, buf);\n+        return buf;\n+    }\n }\n \n \n \n /*==============================================================================\n-* Number Writer\n-*============================================================================*/\n+ * Number Writer\n+ *============================================================================*/\n \n #if YYJSON_HAS_IEEE_754 && !YYJSON_DISABLE_FAST_FP_CONV  /* FP_WRITER */\n \n /** Trailing zero count table for number 0 to 99.\n-   (generate with misc/make_tables.c) */\n+    (generate with misc/make_tables.c) */\n static const u8 dec_trailing_zero_table[] = {\n-   2, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+    2, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 0, 0, 0, 0, 0, 0, 0, 0, 0\n };\n \n /** Write an unsigned integer with a length of 1 to 16. */\n static_inline u8 *write_u64_len_1_to_16(u64 val, u8 *buf) {\n-   u64 hgh;\n-   u32 low;\n-   if (val < 100000000) {                          /* 1-8 digits */\n-\t   buf = write_u32_len_1_8((u32)val, buf);\n-\t   return buf;\n-   } else {                                        /* 9-16 digits */\n-\t   hgh = val / 100000000;                      /* (val / 100000000) */\n-\t   low = (u32)(val - hgh * 100000000);         /* (val % 100000000) */\n-\t   buf = write_u32_len_1_8((u32)hgh, buf);\n-\t   buf = write_u32_len_8(low, buf);\n-\t   return buf;\n-   }\n+    u64 hgh;\n+    u32 low;\n+    if (val < 100000000) {                          /* 1-8 digits */\n+        buf = write_u32_len_1_8((u32)val, buf);\n+        return buf;\n+    } else {                                        /* 9-16 digits */\n+        hgh = val / 100000000;                      /* (val / 100000000) */\n+        low = (u32)(val - hgh * 100000000);         /* (val % 100000000) */\n+        buf = write_u32_len_1_8((u32)hgh, buf);\n+        buf = write_u32_len_8(low, buf);\n+        return buf;\n+    }\n }\n \n /** Write an unsigned integer with a length of 1 to 17. */\n static_inline u8 *write_u64_len_1_to_17(u64 val, u8 *buf) {\n-   u64 hgh;\n-   u32 mid, low, one;\n-   if (val >= (u64)100000000 * 10000000) {         /* len: 16 to 17 */\n-\t   hgh = val / 100000000;                      /* (val / 100000000) */\n-\t   low = (u32)(val - hgh * 100000000);         /* (val % 100000000) */\n-\t   one = (u32)(hgh / 100000000);               /* (hgh / 100000000) */\n-\t   mid = (u32)(hgh - (u64)one * 100000000);    /* (hgh % 100000000) */\n-\t   *buf = (u8)((u8)one + (u8)'0');\n-\t   buf += one > 0;\n-\t   buf = write_u32_len_8(mid, buf);\n-\t   buf = write_u32_len_8(low, buf);\n-\t   return buf;\n-   } else if (val >= (u64)100000000){              /* len: 9 to 15 */\n-\t   hgh = val / 100000000;                      /* (val / 100000000) */\n-\t   low = (u32)(val - hgh * 100000000);         /* (val % 100000000) */\n-\t   buf = write_u32_len_1_8((u32)hgh, buf);\n-\t   buf = write_u32_len_8(low, buf);\n-\t   return buf;\n-   } else { /* len: 1 to 8 */\n-\t   buf = write_u32_len_1_8((u32)val, buf);\n-\t   return buf;\n-   }\n+    u64 hgh;\n+    u32 mid, low, one;\n+    if (val >= (u64)100000000 * 10000000) {         /* len: 16 to 17 */\n+        hgh = val / 100000000;                      /* (val / 100000000) */\n+        low = (u32)(val - hgh * 100000000);         /* (val % 100000000) */\n+        one = (u32)(hgh / 100000000);               /* (hgh / 100000000) */\n+        mid = (u32)(hgh - (u64)one * 100000000);    /* (hgh % 100000000) */\n+        *buf = (u8)((u8)one + (u8)'0');\n+        buf += one > 0;\n+        buf = write_u32_len_8(mid, buf);\n+        buf = write_u32_len_8(low, buf);\n+        return buf;\n+    } else if (val >= (u64)100000000){              /* len: 9 to 15 */\n+        hgh = val / 100000000;                      /* (val / 100000000) */\n+        low = (u32)(val - hgh * 100000000);         /* (val % 100000000) */\n+        buf = write_u32_len_1_8((u32)hgh, buf);\n+        buf = write_u32_len_8(low, buf);\n+        return buf;\n+    } else { /* len: 1 to 8 */\n+        buf = write_u32_len_1_8((u32)val, buf);\n+        return buf;\n+    }\n }\n \n /**\n-Write an unsigned integer with a length of 15 to 17 with trailing zero trimmed.\n-These digits are named as \"aabbccddeeffgghhii\" here.\n-For example, input 1234567890123000, output \"1234567890123\".\n-*/\n+ Write an unsigned integer with a length of 15 to 17 with trailing zero trimmed.\n+ These digits are named as \"aabbccddeeffgghhii\" here.\n+ For example, input 1234567890123000, output \"1234567890123\".\n+ */\n static_inline u8 *write_u64_len_15_to_17_trim(u8 *buf, u64 sig) {\n-   bool lz;                                        /* leading zero */\n-   u32 tz1, tz2, tz;                               /* trailing zero */\n-\n-   u32 abbccddee = (u32)(sig / 100000000);\n-   u32 ffgghhii = (u32)(sig - (u64)abbccddee * 100000000);\n-   u32 abbcc = abbccddee / 10000;                  /* (abbccddee / 10000) */\n-   u32 ddee = abbccddee - abbcc * 10000;           /* (abbccddee % 10000) */\n-   u32 abb = (u32)(((u64)abbcc * 167773) >> 24);   /* (abbcc / 100) */\n-   u32 a = (abb * 41) >> 12;                       /* (abb / 100) */\n-   u32 bb = abb - a * 100;                         /* (abb % 100) */\n-   u32 cc = abbcc - abb * 100;                     /* (abbcc % 100) */\n-\n-   /* write abbcc */\n-   buf[0] = (u8)(a + '0');\n-   buf += a > 0;\n-   lz = bb < 10 && a == 0;\n-   ((v16 *)buf)[0] = *(const v16 *)(digit_table + (bb * 2 + lz));\n-   buf -= lz;\n-   ((v16 *)buf)[1] = ((const v16 *)digit_table)[cc];\n-\n-   if (ffgghhii) {\n-\t   u32 dd = (ddee * 5243) >> 19;               /* (ddee / 100) */\n-\t   u32 ee = ddee - dd * 100;                   /* (ddee % 100) */\n-\t   u32 ffgg = (u32)(((u64)ffgghhii * 109951163) >> 40); /* (val / 10000) */\n-\t   u32 hhii = ffgghhii - ffgg * 10000;         /* (val % 10000) */\n-\t   u32 ff = (ffgg * 5243) >> 19;               /* (aabb / 100) */\n-\t   u32 gg = ffgg - ff * 100;                   /* (aabb % 100) */\n-\t   ((v16 *)buf)[2] = ((const v16 *)digit_table)[dd];\n-\t   ((v16 *)buf)[3] = ((const v16 *)digit_table)[ee];\n-\t   ((v16 *)buf)[4] = ((const v16 *)digit_table)[ff];\n-\t   ((v16 *)buf)[5] = ((const v16 *)digit_table)[gg];\n-\t   if (hhii) {\n-\t\t   u32 hh = (hhii * 5243) >> 19;           /* (ccdd / 100) */\n-\t\t   u32 ii = hhii - hh * 100;               /* (ccdd % 100) */\n-\t\t   ((v16 *)buf)[6] = ((const v16 *)digit_table)[hh];\n-\t\t   ((v16 *)buf)[7] = ((const v16 *)digit_table)[ii];\n-\t\t   tz1 = dec_trailing_zero_table[hh];\n-\t\t   tz2 = dec_trailing_zero_table[ii];\n-\t\t   tz = ii ? tz2 : (tz1 + 2);\n-\t\t   buf += 16 - tz;\n-\t\t   return buf;\n-\t   } else {\n-\t\t   tz1 = dec_trailing_zero_table[ff];\n-\t\t   tz2 = dec_trailing_zero_table[gg];\n-\t\t   tz = gg ? tz2 : (tz1 + 2);\n-\t\t   buf += 12 - tz;\n-\t\t   return buf;\n-\t   }\n-   } else {\n-\t   if (ddee) {\n-\t\t   u32 dd = (ddee * 5243) >> 19;           /* (ddee / 100) */\n-\t\t   u32 ee = ddee - dd * 100;               /* (ddee % 100) */\n-\t\t   ((v16 *)buf)[2] = ((const v16 *)digit_table)[dd];\n-\t\t   ((v16 *)buf)[3] = ((const v16 *)digit_table)[ee];\n-\t\t   tz1 = dec_trailing_zero_table[dd];\n-\t\t   tz2 = dec_trailing_zero_table[ee];\n-\t\t   tz = ee ? tz2 : (tz1 + 2);\n-\t\t   buf += 8 - tz;\n-\t\t   return buf;\n-\t   } else {\n-\t\t   tz1 = dec_trailing_zero_table[bb];\n-\t\t   tz2 = dec_trailing_zero_table[cc];\n-\t\t   tz = cc ? tz2 : (tz1 + tz2);\n-\t\t   buf += 4 - tz;\n-\t\t   return buf;\n-\t   }\n-   }\n+    bool lz;                                        /* leading zero */\n+    u32 tz1, tz2, tz;                               /* trailing zero */\n+    \n+    u32 abbccddee = (u32)(sig / 100000000);\n+    u32 ffgghhii = (u32)(sig - (u64)abbccddee * 100000000);\n+    u32 abbcc = abbccddee / 10000;                  /* (abbccddee / 10000) */\n+    u32 ddee = abbccddee - abbcc * 10000;           /* (abbccddee % 10000) */\n+    u32 abb = (u32)(((u64)abbcc * 167773) >> 24);   /* (abbcc / 100) */\n+    u32 a = (abb * 41) >> 12;                       /* (abb / 100) */\n+    u32 bb = abb - a * 100;                         /* (abb % 100) */\n+    u32 cc = abbcc - abb * 100;                     /* (abbcc % 100) */\n+    \n+    /* write abbcc */\n+    buf[0] = (u8)(a + '0');\n+    buf += a > 0;\n+    lz = bb < 10 && a == 0;\n+    ((v16 *)buf)[0] = *(const v16 *)(digit_table + (bb * 2 + lz));\n+    buf -= lz;\n+    ((v16 *)buf)[1] = ((const v16 *)digit_table)[cc];\n+    \n+    if (ffgghhii) {\n+        u32 dd = (ddee * 5243) >> 19;               /* (ddee / 100) */\n+        u32 ee = ddee - dd * 100;                   /* (ddee % 100) */\n+        u32 ffgg = (u32)(((u64)ffgghhii * 109951163) >> 40); /* (val / 10000) */\n+        u32 hhii = ffgghhii - ffgg * 10000;         /* (val % 10000) */\n+        u32 ff = (ffgg * 5243) >> 19;               /* (aabb / 100) */\n+        u32 gg = ffgg - ff * 100;                   /* (aabb % 100) */\n+        ((v16 *)buf)[2] = ((const v16 *)digit_table)[dd];\n+        ((v16 *)buf)[3] = ((const v16 *)digit_table)[ee];\n+        ((v16 *)buf)[4] = ((const v16 *)digit_table)[ff];\n+        ((v16 *)buf)[5] = ((const v16 *)digit_table)[gg];\n+        if (hhii) {\n+            u32 hh = (hhii * 5243) >> 19;           /* (ccdd / 100) */\n+            u32 ii = hhii - hh * 100;               /* (ccdd % 100) */\n+            ((v16 *)buf)[6] = ((const v16 *)digit_table)[hh];\n+            ((v16 *)buf)[7] = ((const v16 *)digit_table)[ii];\n+            tz1 = dec_trailing_zero_table[hh];\n+            tz2 = dec_trailing_zero_table[ii];\n+            tz = ii ? tz2 : (tz1 + 2);\n+            buf += 16 - tz;\n+            return buf;\n+        } else {\n+            tz1 = dec_trailing_zero_table[ff];\n+            tz2 = dec_trailing_zero_table[gg];\n+            tz = gg ? tz2 : (tz1 + 2);\n+            buf += 12 - tz;\n+            return buf;\n+        }\n+    } else {\n+        if (ddee) {\n+            u32 dd = (ddee * 5243) >> 19;           /* (ddee / 100) */\n+            u32 ee = ddee - dd * 100;               /* (ddee % 100) */\n+            ((v16 *)buf)[2] = ((const v16 *)digit_table)[dd];\n+            ((v16 *)buf)[3] = ((const v16 *)digit_table)[ee];\n+            tz1 = dec_trailing_zero_table[dd];\n+            tz2 = dec_trailing_zero_table[ee];\n+            tz = ee ? tz2 : (tz1 + 2);\n+            buf += 8 - tz;\n+            return buf;\n+        } else {\n+            tz1 = dec_trailing_zero_table[bb];\n+            tz2 = dec_trailing_zero_table[cc];\n+            tz = cc ? tz2 : (tz1 + tz2);\n+            buf += 4 - tz;\n+            return buf;\n+        }\n+    }\n }\n \n /** Write a signed integer in the range -324 to 308. */\n static_inline u8 *write_f64_exp(i32 exp, u8 *buf) {\n-   buf[0] = '-';\n-   buf += exp < 0;\n-   exp = exp < 0 ? -exp : exp;\n-   if (exp < 100) {\n-\t   u32 lz = exp < 10;\n-\t   *(v16 *)&buf[0] = *(const v16 *)(digit_table + ((u32)exp * 2 + lz));\n-\t   return buf + 2 - lz;\n-   } else {\n-\t   u32 hi = ((u32)exp * 656) >> 16;            /* exp / 100 */\n-\t   u32 lo = (u32)exp - hi * 100;               /* exp % 100 */\n-\t   buf[0] = (u8)((u8)hi + (u8)'0');\n-\t   *(v16 *)&buf[1] = *(const v16 *)(digit_table + (lo * 2));\n-\t   return buf + 3;\n-   }\n+    buf[0] = '-';\n+    buf += exp < 0;\n+    exp = exp < 0 ? -exp : exp;\n+    if (exp < 100) {\n+        u32 lz = exp < 10;\n+        *(v16 *)&buf[0] = *(const v16 *)(digit_table + ((u32)exp * 2 + lz));\n+        return buf + 2 - lz;\n+    } else {\n+        u32 hi = ((u32)exp * 656) >> 16;            /* exp / 100 */\n+        u32 lo = (u32)exp - hi * 100;               /* exp % 100 */\n+        buf[0] = (u8)((u8)hi + (u8)'0');\n+        *(v16 *)&buf[1] = *(const v16 *)(digit_table + (lo * 2));\n+        return buf + 3;\n+    }\n }\n \n /** Multiplies 128-bit integer and returns highest 64-bit rounded value. */\n static_inline u64 round_to_odd(u64 hi, u64 lo, u64 cp) {\n-   u64 x_hi, x_lo, y_hi, y_lo;\n-   u128_mul(cp, lo, &x_hi, &x_lo);\n-   u128_mul_add(cp, hi, x_hi, &y_hi, &y_lo);\n-   return y_hi | (y_lo > 1);\n+    u64 x_hi, x_lo, y_hi, y_lo;\n+    u128_mul(cp, lo, &x_hi, &x_lo);\n+    u128_mul_add(cp, hi, x_hi, &y_hi, &y_lo);\n+    return y_hi | (y_lo > 1);\n }\n \n /**\n-Convert double number from binary to decimal.\n-The output significand is shortest decimal but may have trailing zeros.\n-\n-This function use the Schubfach algorithm:\n-Raffaello Giulietti, The Schubfach way to render doubles (5th version), 2022.\n-https://drive.google.com/file/d/1gp5xv4CAa78SVgCeWfGqqI4FfYYYuNFb\n-https://mail.openjdk.java.net/pipermail/core-libs-dev/2021-November/083536.html\n-https://github.com/openjdk/jdk/pull/3402 (Java implementation)\n-https://github.com/abolz/Drachennest (C++ implementation)\n-\n-See also:\n-Dragonbox: A New Floating-Point Binary-to-Decimal Conversion Algorithm, 2022.\n-https://github.com/jk-jeon/dragonbox/blob/master/other_files/Dragonbox.pdf\n-https://github.com/jk-jeon/dragonbox\n-\n-@param sig_raw The raw value of significand in IEEE 754 format.\n-@param exp_raw The raw value of exponent in IEEE 754 format.\n-@param sig_bin The decoded value of significand in binary.\n-@param exp_bin The decoded value of exponent in binary.\n-@param sig_dec The output value of significand in decimal.\n-@param exp_dec The output value of exponent in decimal.\n-@warning The input double number should not be 0, inf, nan.\n-*/\n+ Convert double number from binary to decimal.\n+ The output significand is shortest decimal but may have trailing zeros.\n+ \n+ This function use the Schubfach algorithm:\n+ Raffaello Giulietti, The Schubfach way to render doubles (5th version), 2022.\n+ https://drive.google.com/file/d/1gp5xv4CAa78SVgCeWfGqqI4FfYYYuNFb\n+ https://mail.openjdk.java.net/pipermail/core-libs-dev/2021-November/083536.html\n+ https://github.com/openjdk/jdk/pull/3402 (Java implementation)\n+ https://github.com/abolz/Drachennest (C++ implementation)\n+ \n+ See also:\n+ Dragonbox: A New Floating-Point Binary-to-Decimal Conversion Algorithm, 2022.\n+ https://github.com/jk-jeon/dragonbox/blob/master/other_files/Dragonbox.pdf\n+ https://github.com/jk-jeon/dragonbox\n+ \n+ @param sig_raw The raw value of significand in IEEE 754 format.\n+ @param exp_raw The raw value of exponent in IEEE 754 format.\n+ @param sig_bin The decoded value of significand in binary.\n+ @param exp_bin The decoded value of exponent in binary.\n+ @param sig_dec The output value of significand in decimal.\n+ @param exp_dec The output value of exponent in decimal.\n+ @warning The input double number should not be 0, inf, nan.\n+ */\n static_inline void f64_bin_to_dec(u64 sig_raw, u32 exp_raw,\n-\t\t\t\t\t\t\t\t u64 sig_bin, i32 exp_bin,\n-\t\t\t\t\t\t\t\t u64 *sig_dec, i32 *exp_dec) {\n-\n-   bool is_even, regular_spacing, u_inside, w_inside, round_up;\n-   u64 s, sp, cb, cbl, cbr, vb, vbl, vbr, pow10hi, pow10lo, upper, lower, mid;\n-   i32 k, h, exp10;\n-\n-   is_even = !(sig_bin & 1);\n-   regular_spacing = (sig_raw == 0 && exp_raw > 1);\n-\n-   cbl = 4 * sig_bin - 2 + regular_spacing;\n-   cb  = 4 * sig_bin;\n-   cbr = 4 * sig_bin + 2;\n-\n-   /* exp_bin: [-1074, 971]                                                  */\n-   /* k = regular_spacing ? floor(log10(pow(2, exp_bin)))                    */\n-   /*                     : floor(log10(pow(2, exp_bin) * 3.0 / 4.0))        */\n-   /*   = regular_spacing ? floor(exp_bin * log10(2))                        */\n-   /*                     : floor(exp_bin * log10(2) + log10(3.0 / 4.0))     */\n-   k = (i32)(exp_bin * 315653 - (regular_spacing ? 131237 : 0)) >> 20;\n-\n-   /* k: [-324, 292]                                                         */\n-   /* h = exp_bin + floor(log2(pow(10, e)))                                  */\n-   /*   = exp_bin + floor(log2(10) * e)                                      */\n-   exp10 = -k;\n-   h = exp_bin + ((exp10 * 217707) >> 16) + 1;\n-\n-   pow10_table_get_sig(exp10, &pow10hi, &pow10lo);\n-   pow10lo += (exp10 < POW10_SIG_TABLE_MIN_EXACT_EXP ||\n-\t\t\t   exp10 > POW10_SIG_TABLE_MAX_EXACT_EXP);\n-   vbl = round_to_odd(pow10hi, pow10lo, cbl << h);\n-   vb  = round_to_odd(pow10hi, pow10lo, cb  << h);\n-   vbr = round_to_odd(pow10hi, pow10lo, cbr << h);\n-\n-   lower = vbl + !is_even;\n-   upper = vbr - !is_even;\n-\n-   s = vb / 4;\n-   if (s >= 10) {\n-\t   sp = s / 10;\n-\t   u_inside = (lower <= 40 * sp);\n-\t   w_inside = (upper >= 40 * sp + 40);\n-\t   if (u_inside != w_inside) {\n-\t\t   *sig_dec = sp + w_inside;\n-\t\t   *exp_dec = k + 1;\n-\t\t   return;\n-\t   }\n-   }\n-\n-   u_inside = (lower <= 4 * s);\n-   w_inside = (upper >= 4 * s + 4);\n-\n-   mid = 4 * s + 2;\n-   round_up = (vb > mid) || (vb == mid && (s & 1) != 0);\n-\n-   *sig_dec = s + ((u_inside != w_inside) ? w_inside : round_up);\n-   *exp_dec = k;\n+                                  u64 sig_bin, i32 exp_bin,\n+                                  u64 *sig_dec, i32 *exp_dec) {\n+    \n+    bool is_even, regular_spacing, u_inside, w_inside, round_up;\n+    u64 s, sp, cb, cbl, cbr, vb, vbl, vbr, pow10hi, pow10lo, upper, lower, mid;\n+    i32 k, h, exp10;\n+    \n+    is_even = !(sig_bin & 1);\n+    regular_spacing = (sig_raw == 0 && exp_raw > 1);\n+    \n+    cbl = 4 * sig_bin - 2 + regular_spacing;\n+    cb  = 4 * sig_bin;\n+    cbr = 4 * sig_bin + 2;\n+    \n+    /* exp_bin: [-1074, 971]                                                  */\n+    /* k = regular_spacing ? floor(log10(pow(2, exp_bin)))                    */\n+    /*                     : floor(log10(pow(2, exp_bin) * 3.0 / 4.0))        */\n+    /*   = regular_spacing ? floor(exp_bin * log10(2))                        */\n+    /*                     : floor(exp_bin * log10(2) + log10(3.0 / 4.0))     */\n+    k = (i32)(exp_bin * 315653 - (regular_spacing ? 131237 : 0)) >> 20;\n+    \n+    /* k: [-324, 292]                                                         */\n+    /* h = exp_bin + floor(log2(pow(10, e)))                                  */\n+    /*   = exp_bin + floor(log2(10) * e)                                      */\n+    exp10 = -k;\n+    h = exp_bin + ((exp10 * 217707) >> 16) + 1;\n+    \n+    pow10_table_get_sig(exp10, &pow10hi, &pow10lo);\n+    pow10lo += (exp10 < POW10_SIG_TABLE_MIN_EXACT_EXP ||\n+                exp10 > POW10_SIG_TABLE_MAX_EXACT_EXP);\n+    vbl = round_to_odd(pow10hi, pow10lo, cbl << h);\n+    vb  = round_to_odd(pow10hi, pow10lo, cb  << h);\n+    vbr = round_to_odd(pow10hi, pow10lo, cbr << h);\n+    \n+    lower = vbl + !is_even;\n+    upper = vbr - !is_even;\n+    \n+    s = vb / 4;\n+    if (s >= 10) {\n+        sp = s / 10;\n+        u_inside = (lower <= 40 * sp);\n+        w_inside = (upper >= 40 * sp + 40);\n+        if (u_inside != w_inside) {\n+            *sig_dec = sp + w_inside;\n+            *exp_dec = k + 1;\n+            return;\n+        }\n+    }\n+    \n+    u_inside = (lower <= 4 * s);\n+    w_inside = (upper >= 4 * s + 4);\n+    \n+    mid = 4 * s + 2;\n+    round_up = (vb > mid) || (vb == mid && (s & 1) != 0);\n+    \n+    *sig_dec = s + ((u_inside != w_inside) ? w_inside : round_up);\n+    *exp_dec = k;\n }\n \n /**\n-Write a double number (requires 32 bytes buffer).\n-\n-We follows the ECMAScript specification to print floating point numbers,\n-but with the following changes:\n-1. Keep the negative sign of 0.0 to preserve input information.\n-2. Keep decimal point to indicate the number is floating point.\n-3. Remove positive sign of exponent part.\n-*/\n+ Write a double number (requires 32 bytes buffer).\n+ \n+ We follows the ECMAScript specification to print floating point numbers,\n+ but with the following changes:\n+ 1. Keep the negative sign of 0.0 to preserve input information.\n+ 2. Keep decimal point to indicate the number is floating point.\n+ 3. Remove positive sign of exponent part.\n+ */\n static_noinline u8 *write_f64_raw(u8 *buf, u64 raw, yyjson_write_flag flg) {\n-   u64 sig_bin, sig_dec, sig_raw;\n-   i32 exp_bin, exp_dec, sig_len, dot_pos, i, max;\n-   u32 exp_raw, hi, lo;\n-   u8 *hdr, *num_hdr, *num_end, *dot_end;\n-   bool sign;\n-\n-   /* decode raw bytes from IEEE-754 double format. */\n-   sign = (bool)(raw >> (F64_BITS - 1));\n-   sig_raw = raw & F64_SIG_MASK;\n-   exp_raw = (u32)((raw & F64_EXP_MASK) >> F64_SIG_BITS);\n-\n-   /* return inf and nan */\n-   if (unlikely(exp_raw == ((u32)1 << F64_EXP_BITS) - 1)) {\n-\t   if (flg & YYJSON_WRITE_INF_AND_NAN_AS_NULL) {\n-\t\t   byte_copy_4(buf, \"null\");\n-\t\t   return buf + 4;\n-\t   } else if (flg & YYJSON_WRITE_ALLOW_INF_AND_NAN) {\n-\t\t   if (sig_raw == 0) {\n-\t\t\t   buf[0] = '-';\n-\t\t\t   buf += sign;\n-\t\t\t   byte_copy_8(buf, \"Infinity\");\n-\t\t\t   buf += 8;\n-\t\t\t   return buf;\n-\t\t   } else {\n-\t\t\t   byte_copy_4(buf, \"NaN\");\n-\t\t\t   return buf + 3;\n-\t\t   }\n-\t   } else {\n-\t\t   return NULL;\n-\t   }\n-   }\n-\n-   /* add sign for all finite double value, including 0.0 and inf */\n-   buf[0] = '-';\n-   buf += sign;\n-   hdr = buf;\n-\n-   /* return zero */\n-   if ((raw << 1) == 0) {\n-\t   byte_copy_4(buf, \"0.0\");\n-\t   buf += 3;\n-\t   return buf;\n-   }\n-\n-   if (likely(exp_raw != 0)) {\n-\t   /* normal number */\n-\t   sig_bin = sig_raw | ((u64)1 << F64_SIG_BITS);\n-\t   exp_bin = (i32)exp_raw - F64_EXP_BIAS - F64_SIG_BITS;\n-\n-\t   /* fast path for small integer number without fraction */\n-\t   if (-F64_SIG_BITS <= exp_bin && exp_bin <= 0) {\n-\t\t   if (u64_tz_bits(sig_bin) >= (u32)-exp_bin) {\n-\t\t\t   /* number is integer in range 1 to 0x1FFFFFFFFFFFFF */\n-\t\t\t   sig_dec = sig_bin >> -exp_bin;\n-\t\t\t   buf = write_u64_len_1_to_16(sig_dec, buf);\n-\t\t\t   byte_copy_2(buf, \".0\");\n-\t\t\t   buf += 2;\n-\t\t\t   return buf;\n-\t\t   }\n-\t   }\n-\n-\t   /* binary to decimal */\n-\t   f64_bin_to_dec(sig_raw, exp_raw, sig_bin, exp_bin, &sig_dec, &exp_dec);\n-\n-\t   /* the sig length is 15 to 17 */\n-\t   sig_len = 17;\n-\t   sig_len -= (sig_dec < (u64)100000000 * 100000000);\n-\t   sig_len -= (sig_dec < (u64)100000000 * 10000000);\n-\n-\t   /* the decimal point position relative to the first digit */\n-\t   dot_pos = sig_len + exp_dec;\n-\n-\t   if (-6 < dot_pos && dot_pos <= 21) {\n-\t\t   /* no need to write exponent part */\n-\t\t   if (dot_pos <= 0) {\n-\t\t\t   /* dot before first digit */\n-\t\t\t   /* such as 0.1234, 0.000001234 */\n-\t\t\t   num_hdr = hdr + (2 - dot_pos);\n-\t\t\t   num_end = write_u64_len_15_to_17_trim(num_hdr, sig_dec);\n-\t\t\t   hdr[0] = '0';\n-\t\t\t   hdr[1] = '.';\n-\t\t\t   hdr += 2;\n-\t\t\t   max = -dot_pos;\n-\t\t\t   for (i = 0; i < max; i++) hdr[i] = '0';\n-\t\t\t   return num_end;\n-\t\t   } else {\n-\t\t\t   /* dot after first digit */\n-\t\t\t   /* such as 1.234, 1234.0, 123400000000000000000.0 */\n-\t\t\t   memset(hdr +  0, '0', 8);\n-\t\t\t   memset(hdr +  8, '0', 8);\n-\t\t\t   memset(hdr + 16, '0', 8);\n-\t\t\t   num_hdr = hdr + 1;\n-\t\t\t   num_end = write_u64_len_15_to_17_trim(num_hdr, sig_dec);\n-\t\t\t   for (i = 0; i < dot_pos; i++) hdr[i] = hdr[i + 1];\n-\t\t\t   hdr[dot_pos] = '.';\n-\t\t\t   dot_end = hdr + dot_pos + 2;\n-\t\t\t   return dot_end < num_end ? num_end : dot_end;\n-\t\t   }\n-\t   } else {\n-\t\t   /* write with scientific notation */\n-\t\t   /* such as 1.234e56 */\n-\t\t   u8 *end = write_u64_len_15_to_17_trim(buf + 1, sig_dec);\n-\t\t   end -= (end == buf + 2); /* remove '.0', e.g. 2.0e34 -> 2e134 */\n-\t\t   exp_dec += sig_len - 1;\n-\t\t   hdr[0] = hdr[1];\n-\t\t   hdr[1] = '.';\n-\t\t   end[0] = 'e';\n-\t\t   buf = write_f64_exp(exp_dec, end + 1);\n-\t\t   return buf;\n-\t   }\n-\n-   } else {\n-\t   /* subnormal number */\n-\t   sig_bin = sig_raw;\n-\t   exp_bin = 1 - F64_EXP_BIAS - F64_SIG_BITS;\n-\n-\t   /* binary to decimal */\n-\t   f64_bin_to_dec(sig_raw, exp_raw, sig_bin, exp_bin, &sig_dec, &exp_dec);\n-\n-\t   /* write significand part */\n-\t   buf = write_u64_len_1_to_17(sig_dec, buf + 1);\n-\t   hdr[0] = hdr[1];\n-\t   hdr[1] = '.';\n-\t   do {\n-\t\t   buf--;\n-\t\t   exp_dec++;\n-\t   } while (*buf == '0');\n-\t   exp_dec += (i32)(buf - hdr - 2);\n-\t   buf += (*buf != '.');\n-\t   buf[0] = 'e';\n-\t   buf++;\n-\n-\t   /* write exponent part */\n-\t   buf[0] = '-';\n-\t   buf++;\n-\t   exp_dec = -exp_dec;\n-\t   hi = ((u32)exp_dec * 656) >> 16; /* exp / 100 */\n-\t   lo = (u32)exp_dec - hi * 100; /* exp % 100 */\n-\t   buf[0] = (u8)((u8)hi + (u8)'0');\n-\t   *(v16 *)&buf[1] = *(const v16 *)(digit_table + (lo * 2));\n-\t   buf += 3;\n-\t   return buf;\n-   }\n+    u64 sig_bin, sig_dec, sig_raw;\n+    i32 exp_bin, exp_dec, sig_len, dot_pos, i, max;\n+    u32 exp_raw, hi, lo;\n+    u8 *hdr, *num_hdr, *num_end, *dot_end;\n+    bool sign;\n+    \n+    /* decode raw bytes from IEEE-754 double format. */\n+    sign = (bool)(raw >> (F64_BITS - 1));\n+    sig_raw = raw & F64_SIG_MASK;\n+    exp_raw = (u32)((raw & F64_EXP_MASK) >> F64_SIG_BITS);\n+    \n+    /* return inf and nan */\n+    if (unlikely(exp_raw == ((u32)1 << F64_EXP_BITS) - 1)) {\n+        if (flg & YYJSON_WRITE_INF_AND_NAN_AS_NULL) {\n+            byte_copy_4(buf, \"null\");\n+            return buf + 4;\n+        } else if (flg & YYJSON_WRITE_ALLOW_INF_AND_NAN) {\n+            if (sig_raw == 0) {\n+                buf[0] = '-';\n+                buf += sign;\n+                byte_copy_8(buf, \"Infinity\");\n+                buf += 8;\n+                return buf;\n+            } else {\n+                byte_copy_4(buf, \"NaN\");\n+                return buf + 3;\n+            }\n+        } else {\n+            return NULL;\n+        }\n+    }\n+    \n+    /* add sign for all finite double value, including 0.0 and inf */\n+    buf[0] = '-';\n+    buf += sign;\n+    hdr = buf;\n+    \n+    /* return zero */\n+    if ((raw << 1) == 0) {\n+        byte_copy_4(buf, \"0.0\");\n+        buf += 3;\n+        return buf;\n+    }\n+    \n+    if (likely(exp_raw != 0)) {\n+        /* normal number */\n+        sig_bin = sig_raw | ((u64)1 << F64_SIG_BITS);\n+        exp_bin = (i32)exp_raw - F64_EXP_BIAS - F64_SIG_BITS;\n+        \n+        /* fast path for small integer number without fraction */\n+        if (-F64_SIG_BITS <= exp_bin && exp_bin <= 0) {\n+            if (u64_tz_bits(sig_bin) >= (u32)-exp_bin) {\n+                /* number is integer in range 1 to 0x1FFFFFFFFFFFFF */\n+                sig_dec = sig_bin >> -exp_bin;\n+                buf = write_u64_len_1_to_16(sig_dec, buf);\n+                byte_copy_2(buf, \".0\");\n+                buf += 2;\n+                return buf;\n+            }\n+        }\n+        \n+        /* binary to decimal */\n+        f64_bin_to_dec(sig_raw, exp_raw, sig_bin, exp_bin, &sig_dec, &exp_dec);\n+        \n+        /* the sig length is 15 to 17 */\n+        sig_len = 17;\n+        sig_len -= (sig_dec < (u64)100000000 * 100000000);\n+        sig_len -= (sig_dec < (u64)100000000 * 10000000);\n+        \n+        /* the decimal point position relative to the first digit */\n+        dot_pos = sig_len + exp_dec;\n+        \n+        if (-6 < dot_pos && dot_pos <= 21) {\n+            /* no need to write exponent part */\n+            if (dot_pos <= 0) {\n+                /* dot before first digit */\n+                /* such as 0.1234, 0.000001234 */\n+                num_hdr = hdr + (2 - dot_pos);\n+                num_end = write_u64_len_15_to_17_trim(num_hdr, sig_dec);\n+                hdr[0] = '0';\n+                hdr[1] = '.';\n+                hdr += 2;\n+                max = -dot_pos;\n+                for (i = 0; i < max; i++) hdr[i] = '0';\n+                return num_end;\n+            } else {\n+                /* dot after first digit */\n+                /* such as 1.234, 1234.0, 123400000000000000000.0 */\n+                memset(hdr +  0, '0', 8);\n+                memset(hdr +  8, '0', 8);\n+                memset(hdr + 16, '0', 8);\n+                num_hdr = hdr + 1;\n+                num_end = write_u64_len_15_to_17_trim(num_hdr, sig_dec);\n+                for (i = 0; i < dot_pos; i++) hdr[i] = hdr[i + 1];\n+                hdr[dot_pos] = '.';\n+                dot_end = hdr + dot_pos + 2;\n+                return dot_end < num_end ? num_end : dot_end;\n+            }\n+        } else {\n+            /* write with scientific notation */\n+            /* such as 1.234e56 */\n+            u8 *end = write_u64_len_15_to_17_trim(buf + 1, sig_dec);\n+            end -= (end == buf + 2); /* remove '.0', e.g. 2.0e34 -> 2e34 */\n+            exp_dec += sig_len - 1;\n+            hdr[0] = hdr[1];\n+            hdr[1] = '.';\n+            end[0] = 'e';\n+            buf = write_f64_exp(exp_dec, end + 1);\n+            return buf;\n+        }\n+        \n+    } else {\n+        /* subnormal number */\n+        sig_bin = sig_raw;\n+        exp_bin = 1 - F64_EXP_BIAS - F64_SIG_BITS;\n+        \n+        /* binary to decimal */\n+        f64_bin_to_dec(sig_raw, exp_raw, sig_bin, exp_bin, &sig_dec, &exp_dec);\n+        \n+        /* write significand part */\n+        buf = write_u64_len_1_to_17(sig_dec, buf + 1);\n+        hdr[0] = hdr[1];\n+        hdr[1] = '.';\n+        do {\n+            buf--;\n+            exp_dec++;\n+        } while (*buf == '0');\n+        exp_dec += (i32)(buf - hdr - 2);\n+        buf += (*buf != '.');\n+        buf[0] = 'e';\n+        buf++;\n+        \n+        /* write exponent part */\n+        buf[0] = '-';\n+        buf++;\n+        exp_dec = -exp_dec;\n+        hi = ((u32)exp_dec * 656) >> 16; /* exp / 100 */\n+        lo = (u32)exp_dec - hi * 100; /* exp % 100 */\n+        buf[0] = (u8)((u8)hi + (u8)'0');\n+        *(v16 *)&buf[1] = *(const v16 *)(digit_table + (lo * 2));\n+        buf += 3;\n+        return buf;\n+    }\n }\n \n #else /* FP_WRITER */\n \n /** Write a double number (requires 32 bytes buffer). */\n static_noinline u8 *write_f64_raw(u8 *buf, u64 raw, yyjson_write_flag flg) {\n-   /*\n-\tFor IEEE 754, `DBL_DECIMAL_DIG` is 17 for round-trip.\n-\tFor non-IEEE formats, 17 is used to avoid buffer overflow,\n-\tround-trip is not guaranteed.\n-\t*/\n+    /*\n+     For IEEE 754, `DBL_DECIMAL_DIG` is 17 for round-trip.\n+     For non-IEEE formats, 17 is used to avoid buffer overflow,\n+     round-trip is not guaranteed.\n+     */\n #if defined(DBL_DECIMAL_DIG)\n-   int dig = DBL_DECIMAL_DIG > 17 ? 17 : DBL_DECIMAL_DIG;\n+    int dig = DBL_DECIMAL_DIG > 17 ? 17 : DBL_DECIMAL_DIG;\n #else\n-   int dig = 17;\n+    int dig = 17;\n #endif\n-\n-   /*\n-\tThe snprintf() function is locale-dependent. For currently known locales,\n-\t(en, zh, ja, ko, am, he, hi) use '.' as the decimal point, while other\n-\tlocales use ',' as the decimal point. we need to replace ',' with '.'\n-\tto avoid the locale setting.\n-\t*/\n-   f64 val = f64_from_raw(raw);\n+    \n+    /*\n+     The snprintf() function is locale-dependent. For currently known locales,\n+     (en, zh, ja, ko, am, he, hi) use '.' as the decimal point, while other\n+     locales use ',' as the decimal point. we need to replace ',' with '.'\n+     to avoid the locale setting.\n+     */\n+    f64 val = f64_from_raw(raw);\n #if YYJSON_MSC_VER >= 1400\n-   int len = sprintf_s((char *)buf, 32, \"%.*g\", dig, val);\n+    int len = sprintf_s((char *)buf, 32, \"%.*g\", dig, val);\n #elif defined(snprintf) || (YYJSON_STDC_VER >= 199901L)\n-   int len = snprintf((char *)buf, 32, \"%.*g\", dig, val);\n+    int len = snprintf((char *)buf, 32, \"%.*g\", dig, val);\n #else\n-   int len = sprintf((char *)buf, \"%.*g\", dig, val);\n+    int len = sprintf((char *)buf, \"%.*g\", dig, val);\n #endif\n-\n-   u8 *cur = buf;\n-   if (unlikely(len < 1)) return NULL;\n-   cur += (*cur == '-');\n-   if (unlikely(!digi_is_digit(*cur))) {\n-\t   /* nan, inf, or bad output */\n-\t   if (flg & YYJSON_WRITE_INF_AND_NAN_AS_NULL) {\n-\t\t   byte_copy_4(buf, \"null\");\n-\t\t   return buf + 4;\n-\t   } else if (flg & YYJSON_WRITE_ALLOW_INF_AND_NAN) {\n-\t\t   if (*cur == 'i') {\n-\t\t\t   byte_copy_8(cur, \"Infinity\");\n-\t\t\t   cur += 8;\n-\t\t\t   return cur;\n-\t\t   } else if (*cur == 'n') {\n-\t\t\t   byte_copy_4(buf, \"NaN\");\n-\t\t\t   return buf + 3;\n-\t\t   }\n-\t   }\n-\t   return NULL;\n-   } else {\n-\t   /* finite number */\n-\t   int i = 0;\n-\t   for (; i < len; i++) {\n-\t\t   if (buf[i] == ',') {\n-\t\t\t   buf[i] = '.';\n-\t\t\t   break;\n-\t\t   }\n-\t   }\n-   }\n-   return buf + len;\n+    \n+    u8 *cur = buf;\n+    if (unlikely(len < 1)) return NULL;\n+    cur += (*cur == '-');\n+    if (unlikely(!digi_is_digit(*cur))) {\n+        /* nan, inf, or bad output */\n+        if (flg & YYJSON_WRITE_INF_AND_NAN_AS_NULL) {\n+            byte_copy_4(buf, \"null\");\n+            return buf + 4;\n+        } else if (flg & YYJSON_WRITE_ALLOW_INF_AND_NAN) {\n+            if (*cur == 'i') {\n+                byte_copy_8(cur, \"Infinity\");\n+                cur += 8;\n+                return cur;\n+            } else if (*cur == 'n') {\n+                byte_copy_4(buf, \"NaN\");\n+                return buf + 3;\n+            }\n+        }\n+        return NULL;\n+    } else {\n+        /* finite number */\n+        int i = 0;\n+        bool fp = false;\n+        for (; i < len; i++) {\n+            if (buf[i] == ',') buf[i] = '.';\n+            if (digi_is_fp((u8)buf[i])) fp = true;\n+        }\n+        if (!fp) {\n+            buf[len++] = '.';\n+            buf[len++] = '0';\n+        }\n+    }\n+    return buf + len;\n }\n \n #endif /* FP_WRITER */\n \n /** Write a JSON number (requires 32 bytes buffer). */\n static_inline u8 *write_number(u8 *cur, yyjson_val *val,\n-\t\t\t\t\t\t\t  yyjson_write_flag flg) {\n-   if (val->tag & YYJSON_SUBTYPE_REAL) {\n-\t   u64 raw = val->uni.u64;\n-\t   return write_f64_raw(cur, raw, flg);\n-   } else {\n-\t   u64 pos = val->uni.u64;\n-\t   u64 neg = ~pos + 1;\n-\t   usize sgn = ((val->tag & YYJSON_SUBTYPE_SINT) > 0) & ((i64)pos < 0);\n-\t   *cur = '-';\n-\t   return write_u64(sgn ? neg : pos, cur + sgn);\n-   }\n+                               yyjson_write_flag flg) {\n+    if (val->tag & YYJSON_SUBTYPE_REAL) {\n+        u64 raw = val->uni.u64;\n+        return write_f64_raw(cur, raw, flg);\n+    } else {\n+        u64 pos = val->uni.u64;\n+        u64 neg = ~pos + 1;\n+        usize sgn = ((val->tag & YYJSON_SUBTYPE_SINT) > 0) & ((i64)pos < 0);\n+        *cur = '-';\n+        return write_u64(sgn ? neg : pos, cur + sgn);\n+    }\n }\n \n \n \n /*==============================================================================\n-* String Writer\n-*============================================================================*/\n+ * String Writer\n+ *============================================================================*/\n \n /** Character encode type, if (type > CHAR_ENC_ERR_1) bytes = type / 2; */\n typedef u8 char_enc_type;\n@@ -6338,524 +6504,524 @@ typedef u8 char_enc_type;\n #define CHAR_ENC_ESC_4  9 /* 4-byte UTF-8, escaped as '\\uXXXX\\uXXXX'. */\n \n /** Character encode type table: don't escape unicode, don't escape '/'.\n-   (generate with misc/make_tables.c) */\n+    (generate with misc/make_tables.c) */\n static const char_enc_type enc_table_cpy[256] = {\n-   3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 3, 3,\n-   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-   0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-   4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n-   8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1\n+    3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 3, 3,\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+    0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n+    8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1\n };\n \n /** Character encode type table: don't escape unicode, escape '/'.\n-   (generate with misc/make_tables.c) */\n+    (generate with misc/make_tables.c) */\n static const char_enc_type enc_table_cpy_slash[256] = {\n-   3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 3, 3,\n-   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-   0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-   4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n-   8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1\n+    3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 3, 3,\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+    0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n+    8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1\n };\n \n /** Character encode type table: escape unicode, don't escape '/'.\n-   (generate with misc/make_tables.c) */\n+    (generate with misc/make_tables.c) */\n static const char_enc_type enc_table_esc[256] = {\n-   3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 3, 3,\n-   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-   0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n-   9, 9, 9, 9, 9, 9, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1\n+    3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 3, 3,\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+    0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n+    9, 9, 9, 9, 9, 9, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1\n };\n \n /** Character encode type table: escape unicode, escape '/'.\n-   (generate with misc/make_tables.c) */\n+    (generate with misc/make_tables.c) */\n static const char_enc_type enc_table_esc_slash[256] = {\n-   3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 3, 3,\n-   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-   0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n-   9, 9, 9, 9, 9, 9, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1\n+    3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 3, 3,\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+    0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n+    9, 9, 9, 9, 9, 9, 9, 9, 1, 1, 1, 1, 1, 1, 1, 1\n };\n \n /** Escaped hex character table: [\"00\" \"01\" \"02\" ... \"FD\" \"FE\" \"FF\"].\n-   (generate with misc/make_tables.c) */\n+    (generate with misc/make_tables.c) */\n yyjson_align(2)\n-   static const u8 esc_hex_char_table[512] = {\n-\t   '0', '0', '0', '1', '0', '2', '0', '3',\n-\t   '0', '4', '0', '5', '0', '6', '0', '7',\n-\t   '0', '8', '0', '9', '0', 'A', '0', 'B',\n-\t   '0', 'C', '0', 'D', '0', 'E', '0', 'F',\n-\t   '1', '0', '1', '1', '1', '2', '1', '3',\n-\t   '1', '4', '1', '5', '1', '6', '1', '7',\n-\t   '1', '8', '1', '9', '1', 'A', '1', 'B',\n-\t   '1', 'C', '1', 'D', '1', 'E', '1', 'F',\n-\t   '2', '0', '2', '1', '2', '2', '2', '3',\n-\t   '2', '4', '2', '5', '2', '6', '2', '7',\n-\t   '2', '8', '2', '9', '2', 'A', '2', 'B',\n-\t   '2', 'C', '2', 'D', '2', 'E', '2', 'F',\n-\t   '3', '0', '3', '1', '3', '2', '3', '3',\n-\t   '3', '4', '3', '5', '3', '6', '3', '7',\n-\t   '3', '8', '3', '9', '3', 'A', '3', 'B',\n-\t   '3', 'C', '3', 'D', '3', 'E', '3', 'F',\n-\t   '4', '0', '4', '1', '4', '2', '4', '3',\n-\t   '4', '4', '4', '5', '4', '6', '4', '7',\n-\t   '4', '8', '4', '9', '4', 'A', '4', 'B',\n-\t   '4', 'C', '4', 'D', '4', 'E', '4', 'F',\n-\t   '5', '0', '5', '1', '5', '2', '5', '3',\n-\t   '5', '4', '5', '5', '5', '6', '5', '7',\n-\t   '5', '8', '5', '9', '5', 'A', '5', 'B',\n-\t   '5', 'C', '5', 'D', '5', 'E', '5', 'F',\n-\t   '6', '0', '6', '1', '6', '2', '6', '3',\n-\t   '6', '4', '6', '5', '6', '6', '6', '7',\n-\t   '6', '8', '6', '9', '6', 'A', '6', 'B',\n-\t   '6', 'C', '6', 'D', '6', 'E', '6', 'F',\n-\t   '7', '0', '7', '1', '7', '2', '7', '3',\n-\t   '7', '4', '7', '5', '7', '6', '7', '7',\n-\t   '7', '8', '7', '9', '7', 'A', '7', 'B',\n-\t   '7', 'C', '7', 'D', '7', 'E', '7', 'F',\n-\t   '8', '0', '8', '1', '8', '2', '8', '3',\n-\t   '8', '4', '8', '5', '8', '6', '8', '7',\n-\t   '8', '8', '8', '9', '8', 'A', '8', 'B',\n-\t   '8', 'C', '8', 'D', '8', 'E', '8', 'F',\n-\t   '9', '0', '9', '1', '9', '2', '9', '3',\n-\t   '9', '4', '9', '5', '9', '6', '9', '7',\n-\t   '9', '8', '9', '9', '9', 'A', '9', 'B',\n-\t   '9', 'C', '9', 'D', '9', 'E', '9', 'F',\n-\t   'A', '0', 'A', '1', 'A', '2', 'A', '3',\n-\t   'A', '4', 'A', '5', 'A', '6', 'A', '7',\n-\t   'A', '8', 'A', '9', 'A', 'A', 'A', 'B',\n-\t   'A', 'C', 'A', 'D', 'A', 'E', 'A', 'F',\n-\t   'B', '0', 'B', '1', 'B', '2', 'B', '3',\n-\t   'B', '4', 'B', '5', 'B', '6', 'B', '7',\n-\t   'B', '8', 'B', '9', 'B', 'A', 'B', 'B',\n-\t   'B', 'C', 'B', 'D', 'B', 'E', 'B', 'F',\n-\t   'C', '0', 'C', '1', 'C', '2', 'C', '3',\n-\t   'C', '4', 'C', '5', 'C', '6', 'C', '7',\n-\t   'C', '8', 'C', '9', 'C', 'A', 'C', 'B',\n-\t   'C', 'C', 'C', 'D', 'C', 'E', 'C', 'F',\n-\t   'D', '0', 'D', '1', 'D', '2', 'D', '3',\n-\t   'D', '4', 'D', '5', 'D', '6', 'D', '7',\n-\t   'D', '8', 'D', '9', 'D', 'A', 'D', 'B',\n-\t   'D', 'C', 'D', 'D', 'D', 'E', 'D', 'F',\n-\t   'E', '0', 'E', '1', 'E', '2', 'E', '3',\n-\t   'E', '4', 'E', '5', 'E', '6', 'E', '7',\n-\t   'E', '8', 'E', '9', 'E', 'A', 'E', 'B',\n-\t   'E', 'C', 'E', 'D', 'E', 'E', 'E', 'F',\n-\t   'F', '0', 'F', '1', 'F', '2', 'F', '3',\n-\t   'F', '4', 'F', '5', 'F', '6', 'F', '7',\n-\t   'F', '8', 'F', '9', 'F', 'A', 'F', 'B',\n-\t   'F', 'C', 'F', 'D', 'F', 'E', 'F', 'F'\n+static const u8 esc_hex_char_table[512] = {\n+    '0', '0', '0', '1', '0', '2', '0', '3',\n+    '0', '4', '0', '5', '0', '6', '0', '7',\n+    '0', '8', '0', '9', '0', 'A', '0', 'B',\n+    '0', 'C', '0', 'D', '0', 'E', '0', 'F',\n+    '1', '0', '1', '1', '1', '2', '1', '3',\n+    '1', '4', '1', '5', '1', '6', '1', '7',\n+    '1', '8', '1', '9', '1', 'A', '1', 'B',\n+    '1', 'C', '1', 'D', '1', 'E', '1', 'F',\n+    '2', '0', '2', '1', '2', '2', '2', '3',\n+    '2', '4', '2', '5', '2', '6', '2', '7',\n+    '2', '8', '2', '9', '2', 'A', '2', 'B',\n+    '2', 'C', '2', 'D', '2', 'E', '2', 'F',\n+    '3', '0', '3', '1', '3', '2', '3', '3',\n+    '3', '4', '3', '5', '3', '6', '3', '7',\n+    '3', '8', '3', '9', '3', 'A', '3', 'B',\n+    '3', 'C', '3', 'D', '3', 'E', '3', 'F',\n+    '4', '0', '4', '1', '4', '2', '4', '3',\n+    '4', '4', '4', '5', '4', '6', '4', '7',\n+    '4', '8', '4', '9', '4', 'A', '4', 'B',\n+    '4', 'C', '4', 'D', '4', 'E', '4', 'F',\n+    '5', '0', '5', '1', '5', '2', '5', '3',\n+    '5', '4', '5', '5', '5', '6', '5', '7',\n+    '5', '8', '5', '9', '5', 'A', '5', 'B',\n+    '5', 'C', '5', 'D', '5', 'E', '5', 'F',\n+    '6', '0', '6', '1', '6', '2', '6', '3',\n+    '6', '4', '6', '5', '6', '6', '6', '7',\n+    '6', '8', '6', '9', '6', 'A', '6', 'B',\n+    '6', 'C', '6', 'D', '6', 'E', '6', 'F',\n+    '7', '0', '7', '1', '7', '2', '7', '3',\n+    '7', '4', '7', '5', '7', '6', '7', '7',\n+    '7', '8', '7', '9', '7', 'A', '7', 'B',\n+    '7', 'C', '7', 'D', '7', 'E', '7', 'F',\n+    '8', '0', '8', '1', '8', '2', '8', '3',\n+    '8', '4', '8', '5', '8', '6', '8', '7',\n+    '8', '8', '8', '9', '8', 'A', '8', 'B',\n+    '8', 'C', '8', 'D', '8', 'E', '8', 'F',\n+    '9', '0', '9', '1', '9', '2', '9', '3',\n+    '9', '4', '9', '5', '9', '6', '9', '7',\n+    '9', '8', '9', '9', '9', 'A', '9', 'B',\n+    '9', 'C', '9', 'D', '9', 'E', '9', 'F',\n+    'A', '0', 'A', '1', 'A', '2', 'A', '3',\n+    'A', '4', 'A', '5', 'A', '6', 'A', '7',\n+    'A', '8', 'A', '9', 'A', 'A', 'A', 'B',\n+    'A', 'C', 'A', 'D', 'A', 'E', 'A', 'F',\n+    'B', '0', 'B', '1', 'B', '2', 'B', '3',\n+    'B', '4', 'B', '5', 'B', '6', 'B', '7',\n+    'B', '8', 'B', '9', 'B', 'A', 'B', 'B',\n+    'B', 'C', 'B', 'D', 'B', 'E', 'B', 'F',\n+    'C', '0', 'C', '1', 'C', '2', 'C', '3',\n+    'C', '4', 'C', '5', 'C', '6', 'C', '7',\n+    'C', '8', 'C', '9', 'C', 'A', 'C', 'B',\n+    'C', 'C', 'C', 'D', 'C', 'E', 'C', 'F',\n+    'D', '0', 'D', '1', 'D', '2', 'D', '3',\n+    'D', '4', 'D', '5', 'D', '6', 'D', '7',\n+    'D', '8', 'D', '9', 'D', 'A', 'D', 'B',\n+    'D', 'C', 'D', 'D', 'D', 'E', 'D', 'F',\n+    'E', '0', 'E', '1', 'E', '2', 'E', '3',\n+    'E', '4', 'E', '5', 'E', '6', 'E', '7',\n+    'E', '8', 'E', '9', 'E', 'A', 'E', 'B',\n+    'E', 'C', 'E', 'D', 'E', 'E', 'E', 'F',\n+    'F', '0', 'F', '1', 'F', '2', 'F', '3',\n+    'F', '4', 'F', '5', 'F', '6', 'F', '7',\n+    'F', '8', 'F', '9', 'F', 'A', 'F', 'B',\n+    'F', 'C', 'F', 'D', 'F', 'E', 'F', 'F'\n };\n \n /** Escaped single character table. (generate with misc/make_tables.c) */\n yyjson_align(2)\n-   static const u8 esc_single_char_table[512] = {\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   '\\\\', 'b', '\\\\', 't', '\\\\', 'n', ' ', ' ',\n-\t   '\\\\', 'f', '\\\\', 'r', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', '\\\\', '\"', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', '\\\\', '/',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   '\\\\', '\\\\', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n-\t   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '\n+static const u8 esc_single_char_table[512] = {\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    '\\\\', 'b', '\\\\', 't', '\\\\', 'n', ' ', ' ',\n+    '\\\\', 'f', '\\\\', 'r', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', '\\\\', '\"', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', '\\\\', '/',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    '\\\\', '\\\\', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n+    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '\n };\n \n /** Returns the encode table with options. */\n static_inline const char_enc_type *get_enc_table_with_flag(\n-   yyjson_read_flag flg) {\n-   if (unlikely(flg & YYJSON_WRITE_ESCAPE_UNICODE)) {\n-\t   if (unlikely(flg & YYJSON_WRITE_ESCAPE_SLASHES)) {\n-\t\t   return enc_table_esc_slash;\n-\t   } else {\n-\t\t   return enc_table_esc;\n-\t   }\n-   } else {\n-\t   if (unlikely(flg & YYJSON_WRITE_ESCAPE_SLASHES)) {\n-\t\t   return enc_table_cpy_slash;\n-\t   } else {\n-\t\t   return enc_table_cpy;\n-\t   }\n-   }\n+    yyjson_read_flag flg) {\n+    if (unlikely(flg & YYJSON_WRITE_ESCAPE_UNICODE)) {\n+        if (unlikely(flg & YYJSON_WRITE_ESCAPE_SLASHES)) {\n+            return enc_table_esc_slash;\n+        } else {\n+            return enc_table_esc;\n+        }\n+    } else {\n+        if (unlikely(flg & YYJSON_WRITE_ESCAPE_SLASHES)) {\n+            return enc_table_cpy_slash;\n+        } else {\n+            return enc_table_cpy;\n+        }\n+    }\n }\n \n /** Write raw string. */\n static_inline u8 *write_raw(u8 *cur, const u8 *raw, usize raw_len) {\n-   memcpy(cur, raw, raw_len);\n-   return cur + raw_len;\n+    memcpy(cur, raw, raw_len);\n+    return cur + raw_len;\n }\n \n /**\n-Write UTF-8 string (requires len * 6 + 2 bytes buffer).\n-@param cur Buffer cursor.\n-@param esc Escape unicode.\n-@param inv Allow invalid unicode.\n-@param str A UTF-8 string, null-terminator is not required.\n-@param str_len Length of string in bytes.\n-@param enc_table Encode type table for character.\n-@return The buffer cursor after string, or NULL on invalid unicode.\n-*/\n+ Write UTF-8 string (requires len * 6 + 2 bytes buffer).\n+ @param cur Buffer cursor.\n+ @param esc Escape unicode.\n+ @param inv Allow invalid unicode.\n+ @param str A UTF-8 string, null-terminator is not required.\n+ @param str_len Length of string in bytes.\n+ @param enc_table Encode type table for character.\n+ @return The buffer cursor after string, or NULL on invalid unicode.\n+ */\n static_inline u8 *write_string(u8 *cur, bool esc, bool inv,\n-\t\t\t\t\t\t\t  const u8 *str, usize str_len,\n-\t\t\t\t\t\t\t  const char_enc_type *enc_table) {\n-\n-   /* UTF-8 character mask and pattern, see `read_string` for details. */\n+                               const u8 *str, usize str_len,\n+                               const char_enc_type *enc_table) {\n+    \n+    /* UTF-8 character mask and pattern, see `read_string` for details. */\n #if YYJSON_ENDIAN == YYJSON_BIG_ENDIAN\n-   const u16 b2_mask = 0xE0C0UL;\n-   const u16 b2_patt = 0xC080UL;\n-   const u16 b2_requ = 0x1E00UL;\n-   const u32 b3_mask = 0xF0C0C000UL;\n-   const u32 b3_patt = 0xE0808000UL;\n-   const u32 b3_requ = 0x0F200000UL;\n-   const u32 b3_erro = 0x0D200000UL;\n-   const u32 b4_mask = 0xF8C0C0C0UL;\n-   const u32 b4_patt = 0xF0808080UL;\n-   const u32 b4_requ = 0x07300000UL;\n-   const u32 b4_err0 = 0x04000000UL;\n-   const u32 b4_err1 = 0x03300000UL;\n+    const u16 b2_mask = 0xE0C0UL;\n+    const u16 b2_patt = 0xC080UL;\n+    const u16 b2_requ = 0x1E00UL;\n+    const u32 b3_mask = 0xF0C0C000UL;\n+    const u32 b3_patt = 0xE0808000UL;\n+    const u32 b3_requ = 0x0F200000UL;\n+    const u32 b3_erro = 0x0D200000UL;\n+    const u32 b4_mask = 0xF8C0C0C0UL;\n+    const u32 b4_patt = 0xF0808080UL;\n+    const u32 b4_requ = 0x07300000UL;\n+    const u32 b4_err0 = 0x04000000UL;\n+    const u32 b4_err1 = 0x03300000UL;\n #elif YYJSON_ENDIAN == YYJSON_LITTLE_ENDIAN\n-   const u16 b2_mask = 0xC0E0UL;\n-   const u16 b2_patt = 0x80C0UL;\n-   const u16 b2_requ = 0x001EUL;\n-   const u32 b3_mask = 0x00C0C0F0UL;\n-   const u32 b3_patt = 0x008080E0UL;\n-   const u32 b3_requ = 0x0000200FUL;\n-   const u32 b3_erro = 0x0000200DUL;\n-   const u32 b4_mask = 0xC0C0C0F8UL;\n-   const u32 b4_patt = 0x808080F0UL;\n-   const u32 b4_requ = 0x00003007UL;\n-   const u32 b4_err0 = 0x00000004UL;\n-   const u32 b4_err1 = 0x00003003UL;\n+    const u16 b2_mask = 0xC0E0UL;\n+    const u16 b2_patt = 0x80C0UL;\n+    const u16 b2_requ = 0x001EUL;\n+    const u32 b3_mask = 0x00C0C0F0UL;\n+    const u32 b3_patt = 0x008080E0UL;\n+    const u32 b3_requ = 0x0000200FUL;\n+    const u32 b3_erro = 0x0000200DUL;\n+    const u32 b4_mask = 0xC0C0C0F8UL;\n+    const u32 b4_patt = 0x808080F0UL;\n+    const u32 b4_requ = 0x00003007UL;\n+    const u32 b4_err0 = 0x00000004UL;\n+    const u32 b4_err1 = 0x00003003UL;\n #else\n-   v16_uni b2_mask_uni = {{ 0xE0, 0xC0 }};\n-   v16_uni b2_patt_uni = {{ 0xC0, 0x80 }};\n-   v16_uni b2_requ_uni = {{ 0x1E, 0x00 }};\n-   v32_uni b3_mask_uni = {{ 0xF0, 0xC0, 0xC0, 0x00 }};\n-   v32_uni b3_patt_uni = {{ 0xE0, 0x80, 0x80, 0x00 }};\n-   v32_uni b3_requ_uni = {{ 0x0F, 0x20, 0x00, 0x00 }};\n-   v32_uni b3_erro_uni = {{ 0x0D, 0x20, 0x00, 0x00 }};\n-   v32_uni b4_mask_uni = {{ 0xF8, 0xC0, 0xC0, 0xC0 }};\n-   v32_uni b4_patt_uni = {{ 0xF0, 0x80, 0x80, 0x80 }};\n-   v32_uni b4_requ_uni = {{ 0x07, 0x30, 0x00, 0x00 }};\n-   v32_uni b4_err0_uni = {{ 0x04, 0x00, 0x00, 0x00 }};\n-   v32_uni b4_err1_uni = {{ 0x03, 0x30, 0x00, 0x00 }};\n-   u16 b2_mask = b2_mask_uni.u;\n-   u16 b2_patt = b2_patt_uni.u;\n-   u16 b2_requ = b2_requ_uni.u;\n-   u32 b3_mask = b3_mask_uni.u;\n-   u32 b3_patt = b3_patt_uni.u;\n-   u32 b3_requ = b3_requ_uni.u;\n-   u32 b3_erro = b3_erro_uni.u;\n-   u32 b4_mask = b4_mask_uni.u;\n-   u32 b4_patt = b4_patt_uni.u;\n-   u32 b4_requ = b4_requ_uni.u;\n-   u32 b4_err0 = b4_err0_uni.u;\n-   u32 b4_err1 = b4_err1_uni.u;\n+    v16_uni b2_mask_uni = {{ 0xE0, 0xC0 }};\n+    v16_uni b2_patt_uni = {{ 0xC0, 0x80 }};\n+    v16_uni b2_requ_uni = {{ 0x1E, 0x00 }};\n+    v32_uni b3_mask_uni = {{ 0xF0, 0xC0, 0xC0, 0x00 }};\n+    v32_uni b3_patt_uni = {{ 0xE0, 0x80, 0x80, 0x00 }};\n+    v32_uni b3_requ_uni = {{ 0x0F, 0x20, 0x00, 0x00 }};\n+    v32_uni b3_erro_uni = {{ 0x0D, 0x20, 0x00, 0x00 }};\n+    v32_uni b4_mask_uni = {{ 0xF8, 0xC0, 0xC0, 0xC0 }};\n+    v32_uni b4_patt_uni = {{ 0xF0, 0x80, 0x80, 0x80 }};\n+    v32_uni b4_requ_uni = {{ 0x07, 0x30, 0x00, 0x00 }};\n+    v32_uni b4_err0_uni = {{ 0x04, 0x00, 0x00, 0x00 }};\n+    v32_uni b4_err1_uni = {{ 0x03, 0x30, 0x00, 0x00 }};\n+    u16 b2_mask = b2_mask_uni.u;\n+    u16 b2_patt = b2_patt_uni.u;\n+    u16 b2_requ = b2_requ_uni.u;\n+    u32 b3_mask = b3_mask_uni.u;\n+    u32 b3_patt = b3_patt_uni.u;\n+    u32 b3_requ = b3_requ_uni.u;\n+    u32 b3_erro = b3_erro_uni.u;\n+    u32 b4_mask = b4_mask_uni.u;\n+    u32 b4_patt = b4_patt_uni.u;\n+    u32 b4_requ = b4_requ_uni.u;\n+    u32 b4_err0 = b4_err0_uni.u;\n+    u32 b4_err1 = b4_err1_uni.u;\n #endif\n-\n+    \n #define is_valid_seq_2(uni) ( \\\n-   ((uni & b2_mask) == b2_patt) && \\\n-   ((uni & b2_requ)) \\\n+    ((uni & b2_mask) == b2_patt) && \\\n+    ((uni & b2_requ)) \\\n )\n-\n+    \n #define is_valid_seq_3(uni) ( \\\n-   ((uni & b3_mask) == b3_patt) && \\\n-   ((tmp = (uni & b3_requ))) && \\\n-   ((tmp != b3_erro)) \\\n+    ((uni & b3_mask) == b3_patt) && \\\n+    ((tmp = (uni & b3_requ))) && \\\n+    ((tmp != b3_erro)) \\\n )\n-\n+    \n #define is_valid_seq_4(uni) ( \\\n-   ((uni & b4_mask) == b4_patt) && \\\n-   ((tmp = (uni & b4_requ))) && \\\n-   ((tmp & b4_err0) == 0 || (tmp & b4_err1) == 0) \\\n+    ((uni & b4_mask) == b4_patt) && \\\n+    ((tmp = (uni & b4_requ))) && \\\n+    ((tmp & b4_err0) == 0 || (tmp & b4_err1) == 0) \\\n )\n-\n-   /* The replacement character U+FFFD, used to indicate invalid character. */\n-   const v32 rep = { 'F', 'F', 'F', 'D' };\n-   const v32 pre = { '\\\\', 'u', '0', '0' };\n-\n-   const u8 *src = str;\n-   const u8 *end = str + str_len;\n-   *cur++ = '\"';\n-\n+    \n+    /* The replacement character U+FFFD, used to indicate invalid character. */\n+    const v32 rep = { 'F', 'F', 'F', 'D' };\n+    const v32 pre = { '\\\\', 'u', '0', '0' };\n+    \n+    const u8 *src = str;\n+    const u8 *end = str + str_len;\n+    *cur++ = '\"';\n+    \n copy_ascii:\n-   /*\n-\tCopy continuous ASCII, loop unrolling, same as the following code:\n-\n-\t\twhile (end > src) (\n-\t\t   if (unlikely(enc_table[*src])) break;\n-\t\t   *cur++ = *src++;\n-\t\t);\n-\t*/\n+    /*\n+     Copy continuous ASCII, loop unrolling, same as the following code:\n+     \n+         while (end > src) (\n+            if (unlikely(enc_table[*src])) break;\n+            *cur++ = *src++;\n+         );\n+     */\n #define expr_jump(i) \\\n-   if (unlikely(enc_table[src[i]])) goto stop_char_##i;\n-\n+    if (unlikely(enc_table[src[i]])) goto stop_char_##i;\n+    \n #define expr_stop(i) \\\n-   stop_char_##i: \\\n-   memcpy(cur, src, i); \\\n-   cur += i; src += i; goto copy_utf8;\n-\n-   while (end - src >= 16) {\n-\t   repeat16_incr(expr_jump);\n-\t   byte_copy_16(cur, src);\n-\t   cur += 16; src += 16;\n-   }\n-\n-   while (end - src >= 4) {\n-\t   repeat4_incr(expr_jump);\n-\t   byte_copy_4(cur, src);\n-\t   cur += 4; src += 4;\n-   }\n-\n-   while (end > src) {\n-\t   expr_jump(0);\n-\t   *cur++ = *src++;\n-   }\n-\n-   *cur++ = '\"';\n-   return cur;\n-\n-   repeat16_incr(expr_stop);\n-\n+    stop_char_##i: \\\n+    memcpy(cur, src, i); \\\n+    cur += i; src += i; goto copy_utf8;\n+    \n+    while (end - src >= 16) {\n+        repeat16_incr(expr_jump);\n+        byte_copy_16(cur, src);\n+        cur += 16; src += 16;\n+    }\n+    \n+    while (end - src >= 4) {\n+        repeat4_incr(expr_jump);\n+        byte_copy_4(cur, src);\n+        cur += 4; src += 4;\n+    }\n+    \n+    while (end > src) {\n+        expr_jump(0);\n+        *cur++ = *src++;\n+    }\n+    \n+    *cur++ = '\"';\n+    return cur;\n+    \n+    repeat16_incr(expr_stop);\n+    \n #undef expr_jump\n #undef expr_stop\n-\n+    \n copy_utf8:\n-   if (unlikely(src + 4 > end)) {\n-\t   if (end == src) goto copy_end;\n-\t   if (end - src < enc_table[*src] / 2) goto err_one;\n-   }\n-   switch (enc_table[*src]) {\n-   case CHAR_ENC_CPY_1: {\n-\t   *cur++ = *src++;\n-\t   goto copy_ascii;\n-   }\n-   case CHAR_ENC_CPY_2: {\n-\t   u16 v;\n-\t   v = byte_load_2(src);\n-\t   if (unlikely(!is_valid_seq_2(v))) goto err_cpy;\n-\n-\t   byte_copy_2(cur, src);\n-\t   cur += 2;\n-\t   src += 2;\n-\t   goto copy_utf8;\n-   }\n-   case CHAR_ENC_CPY_3: {\n-\t   u32 v, tmp;\n-\t   if (likely(src + 4 <= end)) {\n-\t\t   v = byte_load_4(src);\n-\t\t   if (unlikely(!is_valid_seq_3(v))) goto err_cpy;\n-\t\t   byte_copy_4(cur, src);\n-\t   } else {\n-\t\t   v = byte_load_3(src);\n-\t\t   if (unlikely(!is_valid_seq_3(v))) goto err_cpy;\n-\t\t   byte_copy_4(cur, &v);\n-\t   }\n-\t   cur += 3;\n-\t   src += 3;\n-\t   goto copy_utf8;\n-   }\n-   case CHAR_ENC_CPY_4: {\n-\t   u32 v, tmp;\n-\t   v = byte_load_4(src);\n-\t   if (unlikely(!is_valid_seq_4(v))) goto err_cpy;\n-\n-\t   byte_copy_4(cur, src);\n-\t   cur += 4;\n-\t   src += 4;\n-\t   goto copy_utf8;\n-   }\n-   case CHAR_ENC_ESC_A: {\n-\t   byte_move_2(cur, &esc_single_char_table[*src * 2]);\n-\t   cur += 2;\n-\t   src += 1;\n-\t   goto copy_utf8;\n-   }\n-   case CHAR_ENC_ESC_1: {\n-\t   byte_copy_4(cur + 0, &pre);\n-\t   byte_copy_2(cur + 4, &esc_hex_char_table[*src * 2]);\n-\t   cur += 6;\n-\t   src += 1;\n-\t   goto copy_utf8;\n-   }\n-   case CHAR_ENC_ESC_2: {\n-\t   u16 u, v;\n-\t   v = byte_load_2(src);\n-\t   if (unlikely(!is_valid_seq_2(v))) goto err_esc;\n-\n-\t   u = (u16)(((u16)(src[0] & 0x1F) << 6) |\n-\t\t\t\t ((u16)(src[1] & 0x3F) << 0));\n-\t   byte_copy_2(cur + 0, &pre);\n-\t   byte_copy_2(cur + 2, &esc_hex_char_table[(u >> 8) * 2]);\n-\t   byte_copy_2(cur + 4, &esc_hex_char_table[(u & 0xFF) * 2]);\n-\t   cur += 6;\n-\t   src += 2;\n-\t   goto copy_utf8;\n-   }\n-   case CHAR_ENC_ESC_3: {\n-\t   u16 u;\n-\t   u32 v, tmp;\n-\t   v = byte_load_3(src);\n-\t   if (unlikely(!is_valid_seq_3(v))) goto err_esc;\n-\n-\t   u = (u16)(((u16)(src[0] & 0x0F) << 12) |\n-\t\t\t\t ((u16)(src[1] & 0x3F) << 6) |\n-\t\t\t\t ((u16)(src[2] & 0x3F) << 0));\n-\t   byte_copy_2(cur + 0, &pre);\n-\t   byte_copy_2(cur + 2, &esc_hex_char_table[(u >> 8) * 2]);\n-\t   byte_copy_2(cur + 4, &esc_hex_char_table[(u & 0xFF) * 2]);\n-\t   cur += 6;\n-\t   src += 3;\n-\t   goto copy_utf8;\n-   }\n-   case CHAR_ENC_ESC_4: {\n-\t   u32 hi, lo, u, v, tmp;\n-\t   v = byte_load_4(src);\n-\t   if (unlikely(!is_valid_seq_4(v))) goto err_esc;\n-\n-\t   u = ((u32)(src[0] & 0x07) << 18) |\n-\t\t   ((u32)(src[1] & 0x3F) << 12) |\n-\t\t   ((u32)(src[2] & 0x3F) << 6) |\n-\t\t   ((u32)(src[3] & 0x3F) << 0);\n-\t   u -= 0x10000;\n-\t   hi = (u >> 10) + 0xD800;\n-\t   lo = (u & 0x3FF) + 0xDC00;\n-\t   byte_copy_2(cur + 0, &pre);\n-\t   byte_copy_2(cur + 2, &esc_hex_char_table[(hi >> 8) * 2]);\n-\t   byte_copy_2(cur + 4, &esc_hex_char_table[(hi & 0xFF) * 2]);\n-\t   byte_copy_2(cur + 6, &pre);\n-\t   byte_copy_2(cur + 8, &esc_hex_char_table[(lo >> 8) * 2]);\n-\t   byte_copy_2(cur + 10, &esc_hex_char_table[(lo & 0xFF) * 2]);\n-\t   cur += 12;\n-\t   src += 4;\n-\t   goto copy_utf8;\n-   }\n-   case CHAR_ENC_ERR_1: {\n-\t   goto err_one;\n-   }\n-   default: break;\n-   }\n-\n+    if (unlikely(src + 4 > end)) {\n+        if (end == src) goto copy_end;\n+        if (end - src < enc_table[*src] / 2) goto err_one;\n+    }\n+    switch (enc_table[*src]) {\n+        case CHAR_ENC_CPY_1: {\n+            *cur++ = *src++;\n+            goto copy_ascii;\n+        }\n+        case CHAR_ENC_CPY_2: {\n+            u16 v;\n+            v = byte_load_2(src);\n+            if (unlikely(!is_valid_seq_2(v))) goto err_cpy;\n+            \n+            byte_copy_2(cur, src);\n+            cur += 2;\n+            src += 2;\n+            goto copy_utf8;\n+        }\n+        case CHAR_ENC_CPY_3: {\n+            u32 v, tmp;\n+            if (likely(src + 4 <= end)) {\n+                v = byte_load_4(src);\n+                if (unlikely(!is_valid_seq_3(v))) goto err_cpy;\n+                byte_copy_4(cur, src);\n+            } else {\n+                v = byte_load_3(src);\n+                if (unlikely(!is_valid_seq_3(v))) goto err_cpy;\n+                byte_copy_4(cur, &v);\n+            }\n+            cur += 3;\n+            src += 3;\n+            goto copy_utf8;\n+        }\n+        case CHAR_ENC_CPY_4: {\n+            u32 v, tmp;\n+            v = byte_load_4(src);\n+            if (unlikely(!is_valid_seq_4(v))) goto err_cpy;\n+            \n+            byte_copy_4(cur, src);\n+            cur += 4;\n+            src += 4;\n+            goto copy_utf8;\n+        }\n+        case CHAR_ENC_ESC_A: {\n+            byte_move_2(cur, &esc_single_char_table[*src * 2]);\n+            cur += 2;\n+            src += 1;\n+            goto copy_utf8;\n+        }\n+        case CHAR_ENC_ESC_1: {\n+            byte_copy_4(cur + 0, &pre);\n+            byte_copy_2(cur + 4, &esc_hex_char_table[*src * 2]);\n+            cur += 6;\n+            src += 1;\n+            goto copy_utf8;\n+        }\n+        case CHAR_ENC_ESC_2: {\n+            u16 u, v;\n+            v = byte_load_2(src);\n+            if (unlikely(!is_valid_seq_2(v))) goto err_esc;\n+            \n+            u = (u16)(((u16)(src[0] & 0x1F) << 6) |\n+                      ((u16)(src[1] & 0x3F) << 0));\n+            byte_copy_2(cur + 0, &pre);\n+            byte_copy_2(cur + 2, &esc_hex_char_table[(u >> 8) * 2]);\n+            byte_copy_2(cur + 4, &esc_hex_char_table[(u & 0xFF) * 2]);\n+            cur += 6;\n+            src += 2;\n+            goto copy_utf8;\n+        }\n+        case CHAR_ENC_ESC_3: {\n+            u16 u;\n+            u32 v, tmp;\n+            v = byte_load_3(src);\n+            if (unlikely(!is_valid_seq_3(v))) goto err_esc;\n+            \n+            u = (u16)(((u16)(src[0] & 0x0F) << 12) |\n+                      ((u16)(src[1] & 0x3F) << 6) |\n+                      ((u16)(src[2] & 0x3F) << 0));\n+            byte_copy_2(cur + 0, &pre);\n+            byte_copy_2(cur + 2, &esc_hex_char_table[(u >> 8) * 2]);\n+            byte_copy_2(cur + 4, &esc_hex_char_table[(u & 0xFF) * 2]);\n+            cur += 6;\n+            src += 3;\n+            goto copy_utf8;\n+        }\n+        case CHAR_ENC_ESC_4: {\n+            u32 hi, lo, u, v, tmp;\n+            v = byte_load_4(src);\n+            if (unlikely(!is_valid_seq_4(v))) goto err_esc;\n+            \n+            u = ((u32)(src[0] & 0x07) << 18) |\n+                ((u32)(src[1] & 0x3F) << 12) |\n+                ((u32)(src[2] & 0x3F) << 6) |\n+                ((u32)(src[3] & 0x3F) << 0);\n+            u -= 0x10000;\n+            hi = (u >> 10) + 0xD800;\n+            lo = (u & 0x3FF) + 0xDC00;\n+            byte_copy_2(cur + 0, &pre);\n+            byte_copy_2(cur + 2, &esc_hex_char_table[(hi >> 8) * 2]);\n+            byte_copy_2(cur + 4, &esc_hex_char_table[(hi & 0xFF) * 2]);\n+            byte_copy_2(cur + 6, &pre);\n+            byte_copy_2(cur + 8, &esc_hex_char_table[(lo >> 8) * 2]);\n+            byte_copy_2(cur + 10, &esc_hex_char_table[(lo & 0xFF) * 2]);\n+            cur += 12;\n+            src += 4;\n+            goto copy_utf8;\n+        }\n+        case CHAR_ENC_ERR_1: {\n+            goto err_one;\n+        }\n+        default: break;\n+    }\n+    \n copy_end:\n-   *cur++ = '\"';\n-   return cur;\n-\n+    *cur++ = '\"';\n+    return cur;\n+    \n err_one:\n-   if (esc) goto err_esc;\n-   else goto err_cpy;\n-\n+    if (esc) goto err_esc;\n+    else goto err_cpy;\n+    \n err_cpy:\n-   if (!inv) return NULL;\n-   *cur++ = *src++;\n-   goto copy_utf8;\n-\n+    if (!inv) return NULL;\n+    *cur++ = *src++;\n+    goto copy_utf8;\n+    \n err_esc:\n-   if (!inv) return NULL;\n-   byte_copy_2(cur + 0, &pre);\n-   byte_copy_4(cur + 2, &rep);\n-   cur += 6;\n-   src += 1;\n-   goto copy_utf8;\n-\n+    if (!inv) return NULL;\n+    byte_copy_2(cur + 0, &pre);\n+    byte_copy_4(cur + 2, &rep);\n+    cur += 6;\n+    src += 1;\n+    goto copy_utf8;\n+    \n #undef is_valid_seq_2\n #undef is_valid_seq_3\n #undef is_valid_seq_4\n@@ -6864,1125 +7030,1128 @@ static_inline u8 *write_string(u8 *cur, bool esc, bool inv,\n \n \n /*==============================================================================\n-* Writer Utilities\n-*============================================================================*/\n+ * Writer Utilities\n+ *============================================================================*/\n \n /** Write null (requires 8 bytes buffer). */\n static_inline u8 *write_null(u8 *cur) {\n-   v64 v = { 'n', 'u', 'l', 'l', ',', '\\n', 0, 0 };\n-   byte_copy_8(cur, &v);\n-   return cur + 4;\n+    v64 v = { 'n', 'u', 'l', 'l', ',', '\\n', 0, 0 };\n+    byte_copy_8(cur, &v);\n+    return cur + 4;\n }\n \n /** Write bool (requires 8 bytes buffer). */\n static_inline u8 *write_bool(u8 *cur, bool val) {\n-   v64 v0 = { 'f', 'a', 'l', 's', 'e', ',', '\\n', 0 };\n-   v64 v1 = { 't', 'r', 'u', 'e', ',', '\\n', 0, 0 };\n-   if (val) {\n-\t   byte_copy_8(cur, &v1);\n-   } else {\n-\t   byte_copy_8(cur, &v0);\n-   }\n-   return cur + 5 - val;\n-}\n-\n-/** Write indent (requires level * 4 bytes buffer). */\n-static_inline u8 *write_indent(u8 *cur, usize level) {\n-   while (level-- > 0) {\n-\t   byte_copy_4(cur, \"    \");\n-\t   cur += 4;\n-   }\n-   return cur;\n+    v64 v0 = { 'f', 'a', 'l', 's', 'e', ',', '\\n', 0 };\n+    v64 v1 = { 't', 'r', 'u', 'e', ',', '\\n', 0, 0 };\n+    if (val) {\n+        byte_copy_8(cur, &v1);\n+    } else {\n+        byte_copy_8(cur, &v0);\n+    }\n+    return cur + 5 - val;\n+}\n+\n+/** Write indent (requires level x 4 bytes buffer).\n+    Param spaces should not larger than 4. */\n+static_inline u8 *write_indent(u8 *cur, usize level, usize spaces) {\n+    while (level-- > 0) {\n+        byte_copy_4(cur, \"    \");\n+        cur += spaces;\n+    }\n+    return cur;\n }\n \n /** Write data to file. */\n static bool write_dat_to_file(const char *path, u8 *dat, usize len,\n-\t\t\t\t\t\t\t yyjson_write_err *err) {\n-\n+                              yyjson_write_err *err) {\n+    \n #define return_err(_code, _msg) do { \\\n-   err->msg = _msg; \\\n-   err->code = YYJSON_WRITE_ERROR_##_code; \\\n-   if (file) fclose(file); \\\n-   return false; \\\n+    err->msg = _msg; \\\n+    err->code = YYJSON_WRITE_ERROR_##_code; \\\n+    if (file) fclose(file); \\\n+    return false; \\\n } while (false)\n-\n-   FILE *file = fopen_writeonly(path);\n-   if (file == NULL) {\n-\t   return_err(FILE_OPEN, \"file opening failed\");\n-   }\n-   if (fwrite(dat, len, 1, file) != 1) {\n-\t   return_err(FILE_WRITE, \"file writing failed\");\n-   }\n-   if (fclose(file) != 0) {\n-\t   file = NULL;\n-\t   return_err(FILE_WRITE, \"file closing failed\");\n-   }\n-   return true;\n-\n+    \n+    FILE *file = fopen_writeonly(path);\n+    if (file == NULL) {\n+        return_err(FILE_OPEN, \"file opening failed\");\n+    }\n+    if (fwrite(dat, len, 1, file) != 1) {\n+        return_err(FILE_WRITE, \"file writing failed\");\n+    }\n+    if (fclose(file) != 0) {\n+        file = NULL;\n+        return_err(FILE_WRITE, \"file closing failed\");\n+    }\n+    return true;\n+    \n #undef return_err\n }\n \n \n \n /*==============================================================================\n-* JSON Writer Implementation\n-*============================================================================*/\n+ * JSON Writer Implementation\n+ *============================================================================*/\n \n typedef struct yyjson_write_ctx {\n-   usize tag;\n+    usize tag;\n } yyjson_write_ctx;\n \n static_inline void yyjson_write_ctx_set(yyjson_write_ctx *ctx,\n-\t\t\t\t\t\t\t\t\t   usize size, bool is_obj) {\n-   ctx->tag = (size << 1) | (usize)is_obj;\n+                                        usize size, bool is_obj) {\n+    ctx->tag = (size << 1) | (usize)is_obj;\n }\n \n static_inline void yyjson_write_ctx_get(yyjson_write_ctx *ctx,\n-\t\t\t\t\t\t\t\t\t   usize *size, bool *is_obj) {\n-   usize tag = ctx->tag;\n-   *size = tag >> 1;\n-   *is_obj = (bool)(tag & 1);\n+                                        usize *size, bool *is_obj) {\n+    usize tag = ctx->tag;\n+    *size = tag >> 1;\n+    *is_obj = (bool)(tag & 1);\n }\n \n /** Write single JSON value. */\n static_inline u8 *yyjson_write_single(yyjson_val *val,\n-\t\t\t\t\t\t\t\t\t yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t yyjson_alc alc,\n-\t\t\t\t\t\t\t\t\t usize *dat_len,\n-\t\t\t\t\t\t\t\t\t yyjson_write_err *err) {\n-\n+                                      yyjson_write_flag flg,\n+                                      yyjson_alc alc,\n+                                      usize *dat_len,\n+                                      yyjson_write_err *err) {\n+    \n #define return_err(_code, _msg) do { \\\n-   if (hdr) alc.free(alc.ctx, (void *)hdr); \\\n-   *dat_len = 0; \\\n-   err->code = YYJSON_WRITE_ERROR_##_code; \\\n-   err->msg = _msg; \\\n-   return NULL; \\\n+    if (hdr) alc.free(alc.ctx, (void *)hdr); \\\n+    *dat_len = 0; \\\n+    err->code = YYJSON_WRITE_ERROR_##_code; \\\n+    err->msg = _msg; \\\n+    return NULL; \\\n } while (false)\n-\n+    \n #define incr_len(_len) do { \\\n-   hdr = (u8 *)alc.malloc(alc.ctx, _len); \\\n-   if (!hdr) goto fail_alloc; \\\n-   cur = hdr; \\\n+    hdr = (u8 *)alc.malloc(alc.ctx, _len); \\\n+    if (!hdr) goto fail_alloc; \\\n+    cur = hdr; \\\n } while (false)\n-\n+    \n #define check_str_len(_len) do { \\\n-   if ((USIZE_MAX < U64_MAX) && (_len >= (USIZE_MAX - 16) / 6)) \\\n-\t   goto fail_alloc; \\\n+    if ((USIZE_MAX < U64_MAX) && (_len >= (USIZE_MAX - 16) / 6)) \\\n+        goto fail_alloc; \\\n } while (false)\n-\n-   u8 *hdr = NULL, *cur;\n-   usize str_len;\n-   const u8 *str_ptr;\n-   const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n-   bool esc = (flg & YYJSON_WRITE_ESCAPE_UNICODE) != 0;\n-   bool inv = (flg & YYJSON_WRITE_ALLOW_INVALID_UNICODE) != 0;\n-\n-   switch (unsafe_yyjson_get_type(val)) {\n-   case YYJSON_TYPE_RAW:\n-\t   str_len = unsafe_yyjson_get_len(val);\n-\t   str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n-\t   check_str_len(str_len);\n-\t   incr_len(str_len + 1);\n-\t   cur = write_raw(cur, str_ptr, str_len);\n-\t   break;\n-\n-   case YYJSON_TYPE_STR:\n-\t   str_len = unsafe_yyjson_get_len(val);\n-\t   str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n-\t   check_str_len(str_len);\n-\t   incr_len(str_len * 6 + 4);\n-\t   cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n-\t   if (unlikely(!cur)) goto fail_str;\n-\t   break;\n-\n-   case YYJSON_TYPE_NUM:\n-\t   incr_len(32);\n-\t   cur = write_number(cur, val, flg);\n-\t   if (unlikely(!cur)) goto fail_num;\n-\t   break;\n-\n-   case YYJSON_TYPE_BOOL:\n-\t   incr_len(8);\n-\t   cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n-\t   break;\n-\n-   case YYJSON_TYPE_NULL:\n-\t   incr_len(8);\n-\t   cur = write_null(cur);\n-\t   break;\n-\n-   case YYJSON_TYPE_ARR:\n-\t   incr_len(4);\n-\t   byte_copy_2(cur, \"[]\");\n-\t   cur += 2;\n-\t   break;\n-\n-   case YYJSON_TYPE_OBJ:\n-\t   incr_len(4);\n-\t   byte_copy_2(cur, \"{}\");\n-\t   cur += 2;\n-\t   break;\n-\n-   default:\n-\t   goto fail_type;\n-   }\n-\n-   *cur = '\\0';\n-   *dat_len = (usize)(cur - hdr);\n-   memset(err, 0, sizeof(yyjson_write_err));\n-   return hdr;\n-\n+    \n+    u8 *hdr = NULL, *cur;\n+    usize str_len;\n+    const u8 *str_ptr;\n+    const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n+    bool esc = (flg & YYJSON_WRITE_ESCAPE_UNICODE) != 0;\n+    bool inv = (flg & YYJSON_WRITE_ALLOW_INVALID_UNICODE) != 0;\n+    \n+    switch (unsafe_yyjson_get_type(val)) {\n+        case YYJSON_TYPE_RAW:\n+            str_len = unsafe_yyjson_get_len(val);\n+            str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n+            check_str_len(str_len);\n+            incr_len(str_len + 1);\n+            cur = write_raw(cur, str_ptr, str_len);\n+            break;\n+            \n+        case YYJSON_TYPE_STR:\n+            str_len = unsafe_yyjson_get_len(val);\n+            str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n+            check_str_len(str_len);\n+            incr_len(str_len * 6 + 4);\n+            cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n+            if (unlikely(!cur)) goto fail_str;\n+            break;\n+            \n+        case YYJSON_TYPE_NUM:\n+            incr_len(32);\n+            cur = write_number(cur, val, flg);\n+            if (unlikely(!cur)) goto fail_num;\n+            break;\n+            \n+        case YYJSON_TYPE_BOOL:\n+            incr_len(8);\n+            cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n+            break;\n+            \n+        case YYJSON_TYPE_NULL:\n+            incr_len(8);\n+            cur = write_null(cur);\n+            break;\n+            \n+        case YYJSON_TYPE_ARR:\n+            incr_len(4);\n+            byte_copy_2(cur, \"[]\");\n+            cur += 2;\n+            break;\n+            \n+        case YYJSON_TYPE_OBJ:\n+            incr_len(4);\n+            byte_copy_2(cur, \"{}\");\n+            cur += 2;\n+            break;\n+            \n+        default:\n+            goto fail_type;\n+    }\n+    \n+    *cur = '\\0';\n+    *dat_len = (usize)(cur - hdr);\n+    memset(err, 0, sizeof(yyjson_write_err));\n+    return hdr;\n+    \n fail_alloc:\n-   return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\n+    return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\n fail_type:\n-   return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\n+    return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\n fail_num:\n-   return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\n+    return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\n fail_str:\n-   return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n-\n+    return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n+    \n #undef return_err\n #undef check_str_len\n #undef incr_len\n }\n \n /** Write JSON document minify.\n-   The root of this document should be a non-empty container. */\n+    The root of this document should be a non-empty container. */\n static_inline u8 *yyjson_write_minify(const yyjson_val *root,\n-\t\t\t\t\t\t\t\t\t const yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t const yyjson_alc alc,\n-\t\t\t\t\t\t\t\t\t usize *dat_len,\n-\t\t\t\t\t\t\t\t\t yyjson_write_err *err) {\n-\n+                                      const yyjson_write_flag flg,\n+                                      const yyjson_alc alc,\n+                                      usize *dat_len,\n+                                      yyjson_write_err *err) {\n+    \n #define return_err(_code, _msg) do { \\\n-   *dat_len = 0; \\\n-   err->code = YYJSON_WRITE_ERROR_##_code; \\\n-   err->msg = _msg; \\\n-   if (hdr) alc.free(alc.ctx, hdr); \\\n-   return NULL; \\\n+    *dat_len = 0; \\\n+    err->code = YYJSON_WRITE_ERROR_##_code; \\\n+    err->msg = _msg; \\\n+    if (hdr) alc.free(alc.ctx, hdr); \\\n+    return NULL; \\\n } while (false)\n-\n+    \n #define incr_len(_len) do { \\\n-   ext_len = (usize)(_len); \\\n-   if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n-\t   alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n-\t   alc_inc = size_align_up(alc_inc, sizeof(yyjson_write_ctx)); \\\n-\t   if (size_add_is_overflow(alc_len, alc_inc)) goto fail_alloc; \\\n-\t   alc_len += alc_inc; \\\n-\t   tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len); \\\n-\t   if (unlikely(!tmp)) goto fail_alloc; \\\n-\t   ctx_len = (usize)(end - (u8 *)ctx); \\\n-\t   ctx_tmp = (yyjson_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n-\t   memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n-\t   ctx = ctx_tmp; \\\n-\t   cur = tmp + (cur - hdr); \\\n-\t   end = tmp + alc_len; \\\n-\t   hdr = tmp; \\\n-   } \\\n+    ext_len = (usize)(_len); \\\n+    if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n+        alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n+        alc_inc = size_align_up(alc_inc, sizeof(yyjson_write_ctx)); \\\n+        if (size_add_is_overflow(alc_len, alc_inc)) goto fail_alloc; \\\n+        alc_len += alc_inc; \\\n+        tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len - alc_inc, alc_len); \\\n+        if (unlikely(!tmp)) goto fail_alloc; \\\n+        ctx_len = (usize)(end - (u8 *)ctx); \\\n+        ctx_tmp = (yyjson_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n+        memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n+        ctx = ctx_tmp; \\\n+        cur = tmp + (cur - hdr); \\\n+        end = tmp + alc_len; \\\n+        hdr = tmp; \\\n+    } \\\n } while (false)\n-\n+    \n #define check_str_len(_len) do { \\\n-   if ((USIZE_MAX < U64_MAX) && (_len >= (USIZE_MAX - 16) / 6)) \\\n-\t   goto fail_alloc; \\\n+    if ((USIZE_MAX < U64_MAX) && (_len >= (USIZE_MAX - 16) / 6)) \\\n+        goto fail_alloc; \\\n } while (false)\n-\n-   yyjson_val *val;\n-   yyjson_type val_type;\n-   usize ctn_len, ctn_len_tmp;\n-   bool ctn_obj, ctn_obj_tmp, is_key;\n-   u8 *hdr, *cur, *end, *tmp;\n-   yyjson_write_ctx *ctx, *ctx_tmp;\n-   usize alc_len, alc_inc, ctx_len, ext_len, str_len;\n-   const u8 *str_ptr;\n-   const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n-   bool esc = (flg & YYJSON_WRITE_ESCAPE_UNICODE) != 0;\n-   bool inv = (flg & YYJSON_WRITE_ALLOW_INVALID_UNICODE) != 0;\n-\n-   alc_len = root->uni.ofs / sizeof(yyjson_val);\n-   alc_len = alc_len * YYJSON_WRITER_ESTIMATED_MINIFY_RATIO + 64;\n-   alc_len = size_align_up(alc_len, sizeof(yyjson_write_ctx));\n-   hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n-   if (!hdr) goto fail_alloc;\n-   cur = hdr;\n-   end = hdr + alc_len;\n-   ctx = (yyjson_write_ctx *)(void *)end;\n-\n+    \n+    yyjson_val *val;\n+    yyjson_type val_type;\n+    usize ctn_len, ctn_len_tmp;\n+    bool ctn_obj, ctn_obj_tmp, is_key;\n+    u8 *hdr, *cur, *end, *tmp;\n+    yyjson_write_ctx *ctx, *ctx_tmp;\n+    usize alc_len, alc_inc, ctx_len, ext_len, str_len;\n+    const u8 *str_ptr;\n+    const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n+    bool esc = (flg & YYJSON_WRITE_ESCAPE_UNICODE) != 0;\n+    bool inv = (flg & YYJSON_WRITE_ALLOW_INVALID_UNICODE) != 0;\n+    \n+    alc_len = root->uni.ofs / sizeof(yyjson_val);\n+    alc_len = alc_len * YYJSON_WRITER_ESTIMATED_MINIFY_RATIO + 64;\n+    alc_len = size_align_up(alc_len, sizeof(yyjson_write_ctx));\n+    hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n+    if (!hdr) goto fail_alloc;\n+    cur = hdr;\n+    end = hdr + alc_len;\n+    ctx = (yyjson_write_ctx *)(void *)end;\n+    \n doc_begin:\n-   val = (yyjson_val *)root;\n-   val_type = unsafe_yyjson_get_type(val);\n-   ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n-   ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n-   *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n-   val++;\n-\n+    val = (yyjson_val *)root;\n+    val_type = unsafe_yyjson_get_type(val);\n+    ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n+    ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n+    *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n+    val++;\n+    \n val_begin:\n-   val_type = unsafe_yyjson_get_type(val);\n-   if (val_type == YYJSON_TYPE_STR) {\n-\t   is_key = ((u8)ctn_obj & (u8)~ctn_len);\n-\t   str_len = unsafe_yyjson_get_len(val);\n-\t   str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n-\t   check_str_len(str_len);\n-\t   incr_len(str_len * 6 + 16);\n-\t   cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n-\t   if (unlikely(!cur)) goto fail_str;\n-\t   *cur++ = is_key ? ':' : ',';\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_NUM) {\n-\t   incr_len(32);\n-\t   cur = write_number(cur, val, flg);\n-\t   if (unlikely(!cur)) goto fail_num;\n-\t   *cur++ = ',';\n-\t   goto val_end;\n-   }\n-   if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n-\t   (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n-\t   ctn_len_tmp = unsafe_yyjson_get_len(val);\n-\t   ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n-\t   incr_len(16);\n-\t   if (unlikely(ctn_len_tmp == 0)) {\n-\t\t   /* write empty container */\n-\t\t   *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n-\t\t   *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n-\t\t   *cur++ = ',';\n-\t\t   goto val_end;\n-\t   } else {\n-\t\t   /* push context, setup new container */\n-\t\t   yyjson_write_ctx_set(--ctx, ctn_len, ctn_obj);\n-\t\t   ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n-\t\t   ctn_obj = ctn_obj_tmp;\n-\t\t   *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n-\t\t   val++;\n-\t\t   goto val_begin;\n-\t   }\n-   }\n-   if (val_type == YYJSON_TYPE_BOOL) {\n-\t   incr_len(16);\n-\t   cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n-\t   cur++;\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_NULL) {\n-\t   incr_len(16);\n-\t   cur = write_null(cur);\n-\t   cur++;\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_RAW) {\n-\t   str_len = unsafe_yyjson_get_len(val);\n-\t   str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n-\t   check_str_len(str_len);\n-\t   incr_len(str_len + 2);\n-\t   cur = write_raw(cur, str_ptr, str_len);\n-\t   *cur++ = ',';\n-\t   goto val_end;\n-   }\n-   goto fail_type;\n-\n+    val_type = unsafe_yyjson_get_type(val);\n+    if (val_type == YYJSON_TYPE_STR) {\n+        is_key = ((u8)ctn_obj & (u8)~ctn_len);\n+        str_len = unsafe_yyjson_get_len(val);\n+        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n+        check_str_len(str_len);\n+        incr_len(str_len * 6 + 16);\n+        cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n+        if (unlikely(!cur)) goto fail_str;\n+        *cur++ = is_key ? ':' : ',';\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_NUM) {\n+        incr_len(32);\n+        cur = write_number(cur, val, flg);\n+        if (unlikely(!cur)) goto fail_num;\n+        *cur++ = ',';\n+        goto val_end;\n+    }\n+    if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n+                    (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n+        ctn_len_tmp = unsafe_yyjson_get_len(val);\n+        ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n+        incr_len(16);\n+        if (unlikely(ctn_len_tmp == 0)) {\n+            /* write empty container */\n+            *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n+            *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n+            *cur++ = ',';\n+            goto val_end;\n+        } else {\n+            /* push context, setup new container */\n+            yyjson_write_ctx_set(--ctx, ctn_len, ctn_obj);\n+            ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n+            ctn_obj = ctn_obj_tmp;\n+            *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n+            val++;\n+            goto val_begin;\n+        }\n+    }\n+    if (val_type == YYJSON_TYPE_BOOL) {\n+        incr_len(16);\n+        cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n+        cur++;\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_NULL) {\n+        incr_len(16);\n+        cur = write_null(cur);\n+        cur++;\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_RAW) {\n+        str_len = unsafe_yyjson_get_len(val);\n+        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n+        check_str_len(str_len);\n+        incr_len(str_len + 2);\n+        cur = write_raw(cur, str_ptr, str_len);\n+        *cur++ = ',';\n+        goto val_end;\n+    }\n+    goto fail_type;\n+    \n val_end:\n-   val++;\n-   ctn_len--;\n-   if (unlikely(ctn_len == 0)) goto ctn_end;\n-   goto val_begin;\n-\n+    val++;\n+    ctn_len--;\n+    if (unlikely(ctn_len == 0)) goto ctn_end;\n+    goto val_begin;\n+    \n ctn_end:\n-   cur--;\n-   *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n-   *cur++ = ',';\n-   if (unlikely((u8 *)ctx >= end)) goto doc_end;\n-   yyjson_write_ctx_get(ctx++, &ctn_len, &ctn_obj);\n-   ctn_len--;\n-   if (likely(ctn_len > 0)) {\n-\t   goto val_begin;\n-   } else {\n-\t   goto ctn_end;\n-   }\n-\n+    cur--;\n+    *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n+    *cur++ = ',';\n+    if (unlikely((u8 *)ctx >= end)) goto doc_end;\n+    yyjson_write_ctx_get(ctx++, &ctn_len, &ctn_obj);\n+    ctn_len--;\n+    if (likely(ctn_len > 0)) {\n+        goto val_begin;\n+    } else {\n+        goto ctn_end;\n+    }\n+    \n doc_end:\n-   *--cur = '\\0';\n-   *dat_len = (usize)(cur - hdr);\n-   memset(err, 0, sizeof(yyjson_write_err));\n-   return hdr;\n-\n+    *--cur = '\\0';\n+    *dat_len = (usize)(cur - hdr);\n+    memset(err, 0, sizeof(yyjson_write_err));\n+    return hdr;\n+    \n fail_alloc:\n-   return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\n+    return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\n fail_type:\n-   return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\n+    return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\n fail_num:\n-   return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\n+    return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\n fail_str:\n-   return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n-\n+    return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n+    \n #undef return_err\n #undef incr_len\n #undef check_str_len\n }\n \n /** Write JSON document pretty.\n-   The root of this document should be a non-empty container. */\n+    The root of this document should be a non-empty container. */\n static_inline u8 *yyjson_write_pretty(const yyjson_val *root,\n-\t\t\t\t\t\t\t\t\t const yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t const yyjson_alc alc,\n-\t\t\t\t\t\t\t\t\t usize *dat_len,\n-\t\t\t\t\t\t\t\t\t yyjson_write_err *err) {\n-\n+                                      const yyjson_write_flag flg,\n+                                      const yyjson_alc alc,\n+                                      usize *dat_len,\n+                                      yyjson_write_err *err) {\n+    \n #define return_err(_code, _msg) do { \\\n-   *dat_len = 0; \\\n-   err->code = YYJSON_WRITE_ERROR_##_code; \\\n-   err->msg = _msg; \\\n-   if (hdr) alc.free(alc.ctx, hdr); \\\n-   return NULL; \\\n+    *dat_len = 0; \\\n+    err->code = YYJSON_WRITE_ERROR_##_code; \\\n+    err->msg = _msg; \\\n+    if (hdr) alc.free(alc.ctx, hdr); \\\n+    return NULL; \\\n } while (false)\n-\n+    \n #define incr_len(_len) do { \\\n-   ext_len = (usize)(_len); \\\n-   if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n-\t   alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n-\t   alc_inc = size_align_up(alc_inc, sizeof(yyjson_write_ctx)); \\\n-\t   if (size_add_is_overflow(alc_len, alc_inc)) goto fail_alloc; \\\n-\t   alc_len += alc_inc; \\\n-\t   tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len); \\\n-\t   if (unlikely(!tmp)) goto fail_alloc; \\\n-\t   ctx_len = (usize)(end - (u8 *)ctx); \\\n-\t   ctx_tmp = (yyjson_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n-\t   memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n-\t   ctx = ctx_tmp; \\\n-\t   cur = tmp + (cur - hdr); \\\n-\t   end = tmp + alc_len; \\\n-\t   hdr = tmp; \\\n-   } \\\n+    ext_len = (usize)(_len); \\\n+    if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n+        alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n+        alc_inc = size_align_up(alc_inc, sizeof(yyjson_write_ctx)); \\\n+        if (size_add_is_overflow(alc_len, alc_inc)) goto fail_alloc; \\\n+        alc_len += alc_inc; \\\n+        tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len - alc_inc, alc_len); \\\n+        if (unlikely(!tmp)) goto fail_alloc; \\\n+        ctx_len = (usize)(end - (u8 *)ctx); \\\n+        ctx_tmp = (yyjson_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n+        memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n+        ctx = ctx_tmp; \\\n+        cur = tmp + (cur - hdr); \\\n+        end = tmp + alc_len; \\\n+        hdr = tmp; \\\n+    } \\\n } while (false)\n-\n+    \n #define check_str_len(_len) do { \\\n-   if ((USIZE_MAX < U64_MAX) && (_len >= (USIZE_MAX - 16) / 6)) \\\n-\t   goto fail_alloc; \\\n+    if ((USIZE_MAX < U64_MAX) && (_len >= (USIZE_MAX - 16) / 6)) \\\n+        goto fail_alloc; \\\n } while (false)\n-\n-   yyjson_val *val;\n-   yyjson_type val_type;\n-   usize ctn_len, ctn_len_tmp;\n-   bool ctn_obj, ctn_obj_tmp, is_key, no_indent;\n-   u8 *hdr, *cur, *end, *tmp;\n-   yyjson_write_ctx *ctx, *ctx_tmp;\n-   usize alc_len, alc_inc, ctx_len, ext_len, str_len, level;\n-   const u8 *str_ptr;\n-   const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n-   bool esc = (flg & YYJSON_WRITE_ESCAPE_UNICODE) != 0;\n-   bool inv = (flg & YYJSON_WRITE_ALLOW_INVALID_UNICODE) != 0;\n-\n-   alc_len = root->uni.ofs / sizeof(yyjson_val);\n-   alc_len = alc_len * YYJSON_WRITER_ESTIMATED_PRETTY_RATIO + 64;\n-   alc_len = size_align_up(alc_len, sizeof(yyjson_write_ctx));\n-   hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n-   if (!hdr) goto fail_alloc;\n-   cur = hdr;\n-   end = hdr + alc_len;\n-   ctx = (yyjson_write_ctx *)(void *)end;\n-\n+    \n+    yyjson_val *val;\n+    yyjson_type val_type;\n+    usize ctn_len, ctn_len_tmp;\n+    bool ctn_obj, ctn_obj_tmp, is_key, no_indent;\n+    u8 *hdr, *cur, *end, *tmp;\n+    yyjson_write_ctx *ctx, *ctx_tmp;\n+    usize alc_len, alc_inc, ctx_len, ext_len, str_len, level;\n+    const u8 *str_ptr;\n+    const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n+    bool esc = (flg & YYJSON_WRITE_ESCAPE_UNICODE) != 0;\n+    bool inv = (flg & YYJSON_WRITE_ALLOW_INVALID_UNICODE) != 0;\n+    usize spaces = (flg & YYJSON_WRITE_PRETTY_TWO_SPACES) ? 2 : 4;\n+    \n+    alc_len = root->uni.ofs / sizeof(yyjson_val);\n+    alc_len = alc_len * YYJSON_WRITER_ESTIMATED_PRETTY_RATIO + 64;\n+    alc_len = size_align_up(alc_len, sizeof(yyjson_write_ctx));\n+    hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n+    if (!hdr) goto fail_alloc;\n+    cur = hdr;\n+    end = hdr + alc_len;\n+    ctx = (yyjson_write_ctx *)(void *)end;\n+    \n doc_begin:\n-   val = (yyjson_val *)root;\n-   val_type = unsafe_yyjson_get_type(val);\n-   ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n-   ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n-   *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n-   *cur++ = '\\n';\n-   val++;\n-   level = 1;\n-\n+    val = (yyjson_val *)root;\n+    val_type = unsafe_yyjson_get_type(val);\n+    ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n+    ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n+    *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n+    *cur++ = '\\n';\n+    val++;\n+    level = 1;\n+    \n val_begin:\n-   val_type = unsafe_yyjson_get_type(val);\n-   if (val_type == YYJSON_TYPE_STR) {\n-\t   is_key = (bool)((u8)ctn_obj & (u8)~ctn_len);\n-\t   no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n-\t   str_len = unsafe_yyjson_get_len(val);\n-\t   str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n-\t   check_str_len(str_len);\n-\t   incr_len(str_len * 6 + 16 + (no_indent ? 0 : level * 4));\n-\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t   cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n-\t   if (unlikely(!cur)) goto fail_str;\n-\t   *cur++ = is_key ? ':' : ',';\n-\t   *cur++ = is_key ? ' ' : '\\n';\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_NUM) {\n-\t   no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n-\t   incr_len(32 + (no_indent ? 0 : level * 4));\n-\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t   cur = write_number(cur, val, flg);\n-\t   if (unlikely(!cur)) goto fail_num;\n-\t   *cur++ = ',';\n-\t   *cur++ = '\\n';\n-\t   goto val_end;\n-   }\n-   if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n-\t   (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n-\t   no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n-\t   ctn_len_tmp = unsafe_yyjson_get_len(val);\n-\t   ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n-\t   if (unlikely(ctn_len_tmp == 0)) {\n-\t\t   /* write empty container */\n-\t\t   incr_len(16 + (no_indent ? 0 : level * 4));\n-\t\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t\t   *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n-\t\t   *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n-\t\t   *cur++ = ',';\n-\t\t   *cur++ = '\\n';\n-\t\t   goto val_end;\n-\t   } else {\n-\t\t   /* push context, setup new container */\n-\t\t   incr_len(32 + (no_indent ? 0 : level * 4));\n-\t\t   yyjson_write_ctx_set(--ctx, ctn_len, ctn_obj);\n-\t\t   ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n-\t\t   ctn_obj = ctn_obj_tmp;\n-\t\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t\t   level++;\n-\t\t   *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n-\t\t   *cur++ = '\\n';\n-\t\t   val++;\n-\t\t   goto val_begin;\n-\t   }\n-   }\n-   if (val_type == YYJSON_TYPE_BOOL) {\n-\t   no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n-\t   incr_len(16 + (no_indent ? 0 : level * 4));\n-\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t   cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n-\t   cur += 2;\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_NULL) {\n-\t   no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n-\t   incr_len(16 + (no_indent ? 0 : level * 4));\n-\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t   cur = write_null(cur);\n-\t   cur += 2;\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_RAW) {\n-\t   str_len = unsafe_yyjson_get_len(val);\n-\t   str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n-\t   check_str_len(str_len);\n-\t   incr_len(str_len + 3);\n-\t   cur = write_raw(cur, str_ptr, str_len);\n-\t   *cur++ = ',';\n-\t   *cur++ = '\\n';\n-\t   goto val_end;\n-   }\n-   goto fail_type;\n-\n+    val_type = unsafe_yyjson_get_type(val);\n+    if (val_type == YYJSON_TYPE_STR) {\n+        is_key = (bool)((u8)ctn_obj & (u8)~ctn_len);\n+        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n+        str_len = unsafe_yyjson_get_len(val);\n+        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n+        check_str_len(str_len);\n+        incr_len(str_len * 6 + 16 + (no_indent ? 0 : level * 4));\n+        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+        cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n+        if (unlikely(!cur)) goto fail_str;\n+        *cur++ = is_key ? ':' : ',';\n+        *cur++ = is_key ? ' ' : '\\n';\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_NUM) {\n+        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n+        incr_len(32 + (no_indent ? 0 : level * 4));\n+        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+        cur = write_number(cur, val, flg);\n+        if (unlikely(!cur)) goto fail_num;\n+        *cur++ = ',';\n+        *cur++ = '\\n';\n+        goto val_end;\n+    }\n+    if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n+                    (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n+        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n+        ctn_len_tmp = unsafe_yyjson_get_len(val);\n+        ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n+        if (unlikely(ctn_len_tmp == 0)) {\n+            /* write empty container */\n+            incr_len(16 + (no_indent ? 0 : level * 4));\n+            cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+            *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n+            *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n+            *cur++ = ',';\n+            *cur++ = '\\n';\n+            goto val_end;\n+        } else {\n+            /* push context, setup new container */\n+            incr_len(32 + (no_indent ? 0 : level * 4));\n+            yyjson_write_ctx_set(--ctx, ctn_len, ctn_obj);\n+            ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n+            ctn_obj = ctn_obj_tmp;\n+            cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+            level++;\n+            *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n+            *cur++ = '\\n';\n+            val++;\n+            goto val_begin;\n+        }\n+    }\n+    if (val_type == YYJSON_TYPE_BOOL) {\n+        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n+        incr_len(16 + (no_indent ? 0 : level * 4));\n+        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+        cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n+        cur += 2;\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_NULL) {\n+        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n+        incr_len(16 + (no_indent ? 0 : level * 4));\n+        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+        cur = write_null(cur);\n+        cur += 2;\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_RAW) {\n+        str_len = unsafe_yyjson_get_len(val);\n+        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n+        check_str_len(str_len);\n+        incr_len(str_len + 3);\n+        cur = write_raw(cur, str_ptr, str_len);\n+        *cur++ = ',';\n+        *cur++ = '\\n';\n+        goto val_end;\n+    }\n+    goto fail_type;\n+    \n val_end:\n-   val++;\n-   ctn_len--;\n-   if (unlikely(ctn_len == 0)) goto ctn_end;\n-   goto val_begin;\n-\n+    val++;\n+    ctn_len--;\n+    if (unlikely(ctn_len == 0)) goto ctn_end;\n+    goto val_begin;\n+    \n ctn_end:\n-   cur -= 2;\n-   *cur++ = '\\n';\n-   incr_len(level * 4);\n-   cur = write_indent(cur, --level);\n-   *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n-   if (unlikely((u8 *)ctx >= end)) goto doc_end;\n-   yyjson_write_ctx_get(ctx++, &ctn_len, &ctn_obj);\n-   ctn_len--;\n-   *cur++ = ',';\n-   *cur++ = '\\n';\n-   if (likely(ctn_len > 0)) {\n-\t   goto val_begin;\n-   } else {\n-\t   goto ctn_end;\n-   }\n-\n+    cur -= 2;\n+    *cur++ = '\\n';\n+    incr_len(level * 4);\n+    cur = write_indent(cur, --level, spaces);\n+    *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n+    if (unlikely((u8 *)ctx >= end)) goto doc_end;\n+    yyjson_write_ctx_get(ctx++, &ctn_len, &ctn_obj);\n+    ctn_len--;\n+    *cur++ = ',';\n+    *cur++ = '\\n';\n+    if (likely(ctn_len > 0)) {\n+        goto val_begin;\n+    } else {\n+        goto ctn_end;\n+    }\n+    \n doc_end:\n-   *cur = '\\0';\n-   *dat_len = (usize)(cur - hdr);\n-   memset(err, 0, sizeof(yyjson_write_err));\n-   return hdr;\n-\n+    *cur = '\\0';\n+    *dat_len = (usize)(cur - hdr);\n+    memset(err, 0, sizeof(yyjson_write_err));\n+    return hdr;\n+    \n fail_alloc:\n-   return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\n+    return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\n fail_type:\n-   return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\n+    return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\n fail_num:\n-   return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\n+    return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\n fail_str:\n-   return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n-\n+    return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n+    \n #undef return_err\n #undef incr_len\n #undef check_str_len\n }\n \n char *yyjson_val_write_opts(const yyjson_val *val,\n-\t\t\t\t\t\t   yyjson_write_flag flg,\n-\t\t\t\t\t\t   const yyjson_alc *alc_ptr,\n-\t\t\t\t\t\t   usize *dat_len,\n-\t\t\t\t\t\t   yyjson_write_err *err) {\n-   yyjson_write_err dummy_err;\n-   usize dummy_dat_len;\n-   yyjson_alc alc = alc_ptr ? *alc_ptr : YYJSON_DEFAULT_ALC;\n-   yyjson_val *root = (yyjson_val *)val;\n-\n-   err = err ? err : &dummy_err;\n-   dat_len = dat_len ? dat_len : &dummy_dat_len;\n-\n+                            yyjson_write_flag flg,\n+                            const yyjson_alc *alc_ptr,\n+                            usize *dat_len,\n+                            yyjson_write_err *err) {\n+    yyjson_write_err dummy_err;\n+    usize dummy_dat_len;\n+    yyjson_alc alc = alc_ptr ? *alc_ptr : YYJSON_DEFAULT_ALC;\n+    yyjson_val *root = (yyjson_val *)val;\n+    \n+    err = err ? err : &dummy_err;\n+    dat_len = dat_len ? dat_len : &dummy_dat_len;\n+    \n #if YYJSON_DISABLE_NON_STANDARD\n-   flg &= ~YYJSON_WRITE_ALLOW_INF_AND_NAN;\n-   flg &= ~YYJSON_WRITE_ALLOW_INVALID_UNICODE;\n+    flg &= ~YYJSON_WRITE_ALLOW_INF_AND_NAN;\n+    flg &= ~YYJSON_WRITE_ALLOW_INVALID_UNICODE;\n #endif\n-\n-   if (unlikely(!root)) {\n-\t   *dat_len = 0;\n-\t   err->msg = \"input JSON is NULL\";\n-\t   err->code = YYJSON_READ_ERROR_INVALID_PARAMETER;\n-\t   return NULL;\n-   }\n-\n-   if (!unsafe_yyjson_is_ctn(root) || unsafe_yyjson_get_len(root) == 0) {\n-\t   return (char *)yyjson_write_single(root, flg, alc, dat_len, err);\n-   } else if (flg & YYJSON_WRITE_PRETTY) {\n-\t   return (char *)yyjson_write_pretty(root, flg, alc, dat_len, err);\n-   } else {\n-\t   return (char *)yyjson_write_minify(root, flg, alc, dat_len, err);\n-   }\n+    \n+    if (unlikely(!root)) {\n+        *dat_len = 0;\n+        err->msg = \"input JSON is NULL\";\n+        err->code = YYJSON_READ_ERROR_INVALID_PARAMETER;\n+        return NULL;\n+    }\n+    \n+    if (!unsafe_yyjson_is_ctn(root) || unsafe_yyjson_get_len(root) == 0) {\n+        return (char *)yyjson_write_single(root, flg, alc, dat_len, err);\n+    } else if (flg & (YYJSON_WRITE_PRETTY | YYJSON_WRITE_PRETTY_TWO_SPACES)) {\n+        return (char *)yyjson_write_pretty(root, flg, alc, dat_len, err);\n+    } else {\n+        return (char *)yyjson_write_minify(root, flg, alc, dat_len, err);\n+    }\n }\n \n char *yyjson_write_opts(const yyjson_doc *doc,\n-\t\t\t\t\t   yyjson_write_flag flg,\n-\t\t\t\t\t   const yyjson_alc *alc_ptr,\n-\t\t\t\t\t   usize *dat_len,\n-\t\t\t\t\t   yyjson_write_err *err) {\n-   yyjson_val *root = doc ? doc->root : NULL;\n-   return yyjson_val_write_opts(root, flg, alc_ptr, dat_len, err);\n+                        yyjson_write_flag flg,\n+                        const yyjson_alc *alc_ptr,\n+                        usize *dat_len,\n+                        yyjson_write_err *err) {\n+    yyjson_val *root = doc ? doc->root : NULL;\n+    return yyjson_val_write_opts(root, flg, alc_ptr, dat_len, err);\n }\n \n bool yyjson_val_write_file(const char *path,\n-\t\t\t\t\t\t  const yyjson_val *val,\n-\t\t\t\t\t\t  yyjson_write_flag flg,\n-\t\t\t\t\t\t  const yyjson_alc *alc_ptr,\n-\t\t\t\t\t\t  yyjson_write_err *err) {\n-   yyjson_write_err dummy_err;\n-   u8 *dat;\n-   usize dat_len = 0;\n-   yyjson_val *root = (yyjson_val *)val;\n-   bool suc;\n-\n-   alc_ptr = alc_ptr ? alc_ptr : &YYJSON_DEFAULT_ALC;\n-   err = err ? err : &dummy_err;\n-   if (unlikely(!path || !*path)) {\n-\t   err->msg = \"input path is invalid\";\n-\t   err->code = YYJSON_READ_ERROR_INVALID_PARAMETER;\n-\t   return false;\n-   }\n-\n-   dat = (u8 *)yyjson_val_write_opts(root, flg, alc_ptr, &dat_len, err);\n-   if (unlikely(!dat)) return false;\n-   suc = write_dat_to_file(path, dat, dat_len, err);\n-   alc_ptr->free(alc_ptr->ctx, dat);\n-   return suc;\n+                           const yyjson_val *val,\n+                           yyjson_write_flag flg,\n+                           const yyjson_alc *alc_ptr,\n+                           yyjson_write_err *err) {\n+    yyjson_write_err dummy_err;\n+    u8 *dat;\n+    usize dat_len = 0;\n+    yyjson_val *root = (yyjson_val *)val;\n+    bool suc;\n+    \n+    alc_ptr = alc_ptr ? alc_ptr : &YYJSON_DEFAULT_ALC;\n+    err = err ? err : &dummy_err;\n+    if (unlikely(!path || !*path)) {\n+        err->msg = \"input path is invalid\";\n+        err->code = YYJSON_READ_ERROR_INVALID_PARAMETER;\n+        return false;\n+    }\n+    \n+    dat = (u8 *)yyjson_val_write_opts(root, flg, alc_ptr, &dat_len, err);\n+    if (unlikely(!dat)) return false;\n+    suc = write_dat_to_file(path, dat, dat_len, err);\n+    alc_ptr->free(alc_ptr->ctx, dat);\n+    return suc;\n }\n \n bool yyjson_write_file(const char *path,\n-\t\t\t\t\t  const yyjson_doc *doc,\n-\t\t\t\t\t  yyjson_write_flag flg,\n-\t\t\t\t\t  const yyjson_alc *alc_ptr,\n-\t\t\t\t\t  yyjson_write_err *err) {\n-   yyjson_val *root = doc ? doc->root : NULL;\n-   return yyjson_val_write_file(path, root, flg, alc_ptr, err);\n+                       const yyjson_doc *doc,\n+                       yyjson_write_flag flg,\n+                       const yyjson_alc *alc_ptr,\n+                       yyjson_write_err *err) {\n+    yyjson_val *root = doc ? doc->root : NULL;\n+    return yyjson_val_write_file(path, root, flg, alc_ptr, err);\n }\n \n \n \n /*==============================================================================\n-* Mutable JSON Writer Implementation\n-*============================================================================*/\n+ * Mutable JSON Writer Implementation\n+ *============================================================================*/\n \n typedef struct yyjson_mut_write_ctx {\n-   usize tag;\n-   yyjson_mut_val *ctn;\n+    usize tag;\n+    yyjson_mut_val *ctn;\n } yyjson_mut_write_ctx;\n \n static_inline void yyjson_mut_write_ctx_set(yyjson_mut_write_ctx *ctx,\n-\t\t\t\t\t\t\t\t\t\t   yyjson_mut_val *ctn,\n-\t\t\t\t\t\t\t\t\t\t   usize size, bool is_obj) {\n-   ctx->tag = (size << 1) | (usize)is_obj;\n-   ctx->ctn = ctn;\n+                                            yyjson_mut_val *ctn,\n+                                            usize size, bool is_obj) {\n+    ctx->tag = (size << 1) | (usize)is_obj;\n+    ctx->ctn = ctn;\n }\n \n static_inline void yyjson_mut_write_ctx_get(yyjson_mut_write_ctx *ctx,\n-\t\t\t\t\t\t\t\t\t\t   yyjson_mut_val **ctn,\n-\t\t\t\t\t\t\t\t\t\t   usize *size, bool *is_obj) {\n-   usize tag = ctx->tag;\n-   *size = tag >> 1;\n-   *is_obj = (bool)(tag & 1);\n-   *ctn = ctx->ctn;\n+                                            yyjson_mut_val **ctn,\n+                                            usize *size, bool *is_obj) {\n+    usize tag = ctx->tag;\n+    *size = tag >> 1;\n+    *is_obj = (bool)(tag & 1);\n+    *ctn = ctx->ctn;\n }\n \n /** Write single JSON value. */\n static_inline u8 *yyjson_mut_write_single(yyjson_mut_val *val,\n-\t\t\t\t\t\t\t\t\t\t yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t\t yyjson_alc alc,\n-\t\t\t\t\t\t\t\t\t\t usize *dat_len,\n-\t\t\t\t\t\t\t\t\t\t yyjson_write_err *err) {\n-   return yyjson_write_single((yyjson_val *)val, flg, alc, dat_len, err);\n+                                          yyjson_write_flag flg,\n+                                          yyjson_alc alc,\n+                                          usize *dat_len,\n+                                          yyjson_write_err *err) {\n+    return yyjson_write_single((yyjson_val *)val, flg, alc, dat_len, err);\n }\n \n /** Write JSON document minify.\n-   The root of this document should be a non-empty container. */\n+    The root of this document should be a non-empty container. */\n static_inline u8 *yyjson_mut_write_minify(const yyjson_mut_val *root,\n-\t\t\t\t\t\t\t\t\t\t yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t\t yyjson_alc alc,\n-\t\t\t\t\t\t\t\t\t\t usize *dat_len,\n-\t\t\t\t\t\t\t\t\t\t yyjson_write_err *err) {\n-\n+                                          yyjson_write_flag flg,\n+                                          yyjson_alc alc,\n+                                          usize *dat_len,\n+                                          yyjson_write_err *err) {\n+    \n #define return_err(_code, _msg) do { \\\n-   *dat_len = 0; \\\n-   err->code = YYJSON_WRITE_ERROR_##_code; \\\n-   err->msg = _msg; \\\n-   if (hdr) alc.free(alc.ctx, hdr); \\\n-   return NULL; \\\n+    *dat_len = 0; \\\n+    err->code = YYJSON_WRITE_ERROR_##_code; \\\n+    err->msg = _msg; \\\n+    if (hdr) alc.free(alc.ctx, hdr); \\\n+    return NULL; \\\n } while (false)\n-\n+    \n #define incr_len(_len) do { \\\n-   ext_len = (usize)(_len); \\\n-   if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n-\t   alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n-\t   alc_inc = size_align_up(alc_inc, sizeof(yyjson_mut_write_ctx)); \\\n-\t   if (size_add_is_overflow(alc_len, alc_inc)) goto fail_alloc; \\\n-\t   alc_len += alc_inc; \\\n-\t   tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len); \\\n-\t   if (unlikely(!tmp)) goto fail_alloc; \\\n-\t   ctx_len = (usize)(end - (u8 *)ctx); \\\n-\t   ctx_tmp = (yyjson_mut_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n-\t   memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n-\t   ctx = ctx_tmp; \\\n-\t   cur = tmp + (cur - hdr); \\\n-\t   end = tmp + alc_len; \\\n-\t   hdr = tmp; \\\n-   } \\\n+    ext_len = (usize)(_len); \\\n+    if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n+        alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n+        alc_inc = size_align_up(alc_inc, sizeof(yyjson_mut_write_ctx)); \\\n+        if (size_add_is_overflow(alc_len, alc_inc)) goto fail_alloc; \\\n+        alc_len += alc_inc; \\\n+        tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len - alc_inc, alc_len); \\\n+        if (unlikely(!tmp)) goto fail_alloc; \\\n+        ctx_len = (usize)(end - (u8 *)ctx); \\\n+        ctx_tmp = (yyjson_mut_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n+        memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n+        ctx = ctx_tmp; \\\n+        cur = tmp + (cur - hdr); \\\n+        end = tmp + alc_len; \\\n+        hdr = tmp; \\\n+    } \\\n } while (false)\n-\n+    \n #define check_str_len(_len) do { \\\n-   if ((USIZE_MAX < U64_MAX) && (_len >= (USIZE_MAX - 16) / 6)) \\\n-\t   goto fail_alloc; \\\n+    if ((USIZE_MAX < U64_MAX) && (_len >= (USIZE_MAX - 16) / 6)) \\\n+        goto fail_alloc; \\\n } while (false)\n-\n-   yyjson_mut_val *val, *ctn;\n-   yyjson_type val_type;\n-   usize ctn_len, ctn_len_tmp;\n-   bool ctn_obj, ctn_obj_tmp, is_key;\n-   u8 *hdr, *cur, *end, *tmp;\n-   yyjson_mut_write_ctx *ctx, *ctx_tmp;\n-   usize alc_len, alc_inc, ctx_len, ext_len, str_len;\n-   const u8 *str_ptr;\n-   const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n-   bool esc = (flg & YYJSON_WRITE_ESCAPE_UNICODE) != 0;\n-   bool inv = (flg & YYJSON_WRITE_ALLOW_INVALID_UNICODE) != 0;\n-\n-   alc_len = 0 * YYJSON_WRITER_ESTIMATED_MINIFY_RATIO + 64;\n-   alc_len = size_align_up(alc_len, sizeof(yyjson_mut_write_ctx));\n-   hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n-   if (!hdr) goto fail_alloc;\n-   cur = hdr;\n-   end = hdr + alc_len;\n-   ctx = (yyjson_mut_write_ctx *)(void *)end;\n-\n+    \n+    yyjson_mut_val *val, *ctn;\n+    yyjson_type val_type;\n+    usize ctn_len, ctn_len_tmp;\n+    bool ctn_obj, ctn_obj_tmp, is_key;\n+    u8 *hdr, *cur, *end, *tmp;\n+    yyjson_mut_write_ctx *ctx, *ctx_tmp;\n+    usize alc_len, alc_inc, ctx_len, ext_len, str_len;\n+    const u8 *str_ptr;\n+    const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n+    bool esc = (flg & YYJSON_WRITE_ESCAPE_UNICODE) != 0;\n+    bool inv = (flg & YYJSON_WRITE_ALLOW_INVALID_UNICODE) != 0;\n+    \n+    alc_len = 0 * YYJSON_WRITER_ESTIMATED_MINIFY_RATIO + 64;\n+    alc_len = size_align_up(alc_len, sizeof(yyjson_mut_write_ctx));\n+    hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n+    if (!hdr) goto fail_alloc;\n+    cur = hdr;\n+    end = hdr + alc_len;\n+    ctx = (yyjson_mut_write_ctx *)(void *)end;\n+    \n doc_begin:\n-   val = (yyjson_mut_val *)root;\n-   val_type = unsafe_yyjson_get_type(val);\n-   ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n-   ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n-   *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n-   ctn = val;\n-   val = (yyjson_mut_val *)val->uni.ptr; /* tail */\n-   val = ctn_obj ? val->next->next : val->next;\n-\n+    val = (yyjson_mut_val *)root;\n+    val_type = unsafe_yyjson_get_type(val);\n+    ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n+    ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n+    *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n+    ctn = val;\n+    val = (yyjson_mut_val *)val->uni.ptr; /* tail */\n+    val = ctn_obj ? val->next->next : val->next;\n+    \n val_begin:\n-   val_type = unsafe_yyjson_get_type(val);\n-   if (val_type == YYJSON_TYPE_STR) {\n-\t   is_key = ((u8)ctn_obj & (u8)~ctn_len);\n-\t   str_len = unsafe_yyjson_get_len(val);\n-\t   str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n-\t   check_str_len(str_len);\n-\t   incr_len(str_len * 6 + 16);\n-\t   cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n-\t   if (unlikely(!cur)) goto fail_str;\n-\t   *cur++ = is_key ? ':' : ',';\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_NUM) {\n-\t   incr_len(32);\n-\t   cur = write_number(cur, (yyjson_val *)val, flg);\n-\t   if (unlikely(!cur)) goto fail_num;\n-\t   *cur++ = ',';\n-\t   goto val_end;\n-   }\n-   if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n-\t   (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n-\t   ctn_len_tmp = unsafe_yyjson_get_len(val);\n-\t   ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n-\t   incr_len(16);\n-\t   if (unlikely(ctn_len_tmp == 0)) {\n-\t\t   /* write empty container */\n-\t\t   *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n-\t\t   *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n-\t\t   *cur++ = ',';\n-\t\t   goto val_end;\n-\t   } else {\n-\t\t   /* push context, setup new container */\n-\t\t   yyjson_mut_write_ctx_set(--ctx, ctn, ctn_len, ctn_obj);\n-\t\t   ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n-\t\t   ctn_obj = ctn_obj_tmp;\n-\t\t   *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n-\t\t   ctn = val;\n-\t\t   val = (yyjson_mut_val *)ctn->uni.ptr; /* tail */\n-\t\t   val = ctn_obj ? val->next->next : val->next;\n-\t\t   goto val_begin;\n-\t   }\n-   }\n-   if (val_type == YYJSON_TYPE_BOOL) {\n-\t   incr_len(16);\n-\t   cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n-\t   cur++;\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_NULL) {\n-\t   incr_len(16);\n-\t   cur = write_null(cur);\n-\t   cur++;\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_RAW) {\n-\t   str_len = unsafe_yyjson_get_len(val);\n-\t   str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n-\t   check_str_len(str_len);\n-\t   incr_len(str_len + 2);\n-\t   cur = write_raw(cur, str_ptr, str_len);\n-\t   *cur++ = ',';\n-\t   goto val_end;\n-   }\n-   goto fail_type;\n-\n+    val_type = unsafe_yyjson_get_type(val);\n+    if (val_type == YYJSON_TYPE_STR) {\n+        is_key = ((u8)ctn_obj & (u8)~ctn_len);\n+        str_len = unsafe_yyjson_get_len(val);\n+        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n+        check_str_len(str_len);\n+        incr_len(str_len * 6 + 16);\n+        cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n+        if (unlikely(!cur)) goto fail_str;\n+        *cur++ = is_key ? ':' : ',';\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_NUM) {\n+        incr_len(32);\n+        cur = write_number(cur, (yyjson_val *)val, flg);\n+        if (unlikely(!cur)) goto fail_num;\n+        *cur++ = ',';\n+        goto val_end;\n+    }\n+    if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n+                    (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n+        ctn_len_tmp = unsafe_yyjson_get_len(val);\n+        ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n+        incr_len(16);\n+        if (unlikely(ctn_len_tmp == 0)) {\n+            /* write empty container */\n+            *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n+            *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n+            *cur++ = ',';\n+            goto val_end;\n+        } else {\n+            /* push context, setup new container */\n+            yyjson_mut_write_ctx_set(--ctx, ctn, ctn_len, ctn_obj);\n+            ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n+            ctn_obj = ctn_obj_tmp;\n+            *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n+            ctn = val;\n+            val = (yyjson_mut_val *)ctn->uni.ptr; /* tail */\n+            val = ctn_obj ? val->next->next : val->next;\n+            goto val_begin;\n+        }\n+    }\n+    if (val_type == YYJSON_TYPE_BOOL) {\n+        incr_len(16);\n+        cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n+        cur++;\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_NULL) {\n+        incr_len(16);\n+        cur = write_null(cur);\n+        cur++;\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_RAW) {\n+        str_len = unsafe_yyjson_get_len(val);\n+        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n+        check_str_len(str_len);\n+        incr_len(str_len + 2);\n+        cur = write_raw(cur, str_ptr, str_len);\n+        *cur++ = ',';\n+        goto val_end;\n+    }\n+    goto fail_type;\n+    \n val_end:\n-   ctn_len--;\n-   if (unlikely(ctn_len == 0)) goto ctn_end;\n-   val = val->next;\n-   goto val_begin;\n-\n+    ctn_len--;\n+    if (unlikely(ctn_len == 0)) goto ctn_end;\n+    val = val->next;\n+    goto val_begin;\n+    \n ctn_end:\n-   cur--;\n-   *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n-   *cur++ = ',';\n-   if (unlikely((u8 *)ctx >= end)) goto doc_end;\n-   val = ctn->next;\n-   yyjson_mut_write_ctx_get(ctx++, &ctn, &ctn_len, &ctn_obj);\n-   ctn_len--;\n-   if (likely(ctn_len > 0)) {\n-\t   goto val_begin;\n-   } else {\n-\t   goto ctn_end;\n-   }\n-\n+    cur--;\n+    *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n+    *cur++ = ',';\n+    if (unlikely((u8 *)ctx >= end)) goto doc_end;\n+    val = ctn->next;\n+    yyjson_mut_write_ctx_get(ctx++, &ctn, &ctn_len, &ctn_obj);\n+    ctn_len--;\n+    if (likely(ctn_len > 0)) {\n+        goto val_begin;\n+    } else {\n+        goto ctn_end;\n+    }\n+    \n doc_end:\n-   *--cur = '\\0';\n-   *dat_len = (usize)(cur - hdr);\n-   err->code = YYJSON_WRITE_SUCCESS;\n-   err->msg = \"success\";\n-   return hdr;\n-\n+    *--cur = '\\0';\n+    *dat_len = (usize)(cur - hdr);\n+    err->code = YYJSON_WRITE_SUCCESS;\n+    err->msg = \"success\";\n+    return hdr;\n+    \n fail_alloc:\n-   return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\n+    return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\n fail_type:\n-   return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\n+    return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\n fail_num:\n-   return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\n+    return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\n fail_str:\n-   return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n-\n+    return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n+    \n #undef return_err\n #undef incr_len\n #undef check_str_len\n }\n \n /** Write JSON document pretty.\n-   The root of this document should be a non-empty container. */\n+    The root of this document should be a non-empty container. */\n static_inline u8 *yyjson_mut_write_pretty(const yyjson_mut_val *root,\n-\t\t\t\t\t\t\t\t\t\t yyjson_write_flag flg,\n-\t\t\t\t\t\t\t\t\t\t yyjson_alc alc,\n-\t\t\t\t\t\t\t\t\t\t usize *dat_len,\n-\t\t\t\t\t\t\t\t\t\t yyjson_write_err *err) {\n-\n+                                          yyjson_write_flag flg,\n+                                          yyjson_alc alc,\n+                                          usize *dat_len,\n+                                          yyjson_write_err *err) {\n+    \n #define return_err(_code, _msg) do { \\\n-   *dat_len = 0; \\\n-   err->code = YYJSON_WRITE_ERROR_##_code; \\\n-   err->msg = _msg; \\\n-   if (hdr) alc.free(alc.ctx, hdr); \\\n-   return NULL; \\\n+    *dat_len = 0; \\\n+    err->code = YYJSON_WRITE_ERROR_##_code; \\\n+    err->msg = _msg; \\\n+    if (hdr) alc.free(alc.ctx, hdr); \\\n+    return NULL; \\\n } while (false)\n-\n+    \n #define incr_len(_len) do { \\\n-   ext_len = (usize)(_len); \\\n-   if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n-\t   alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n-\t   alc_inc = size_align_up(alc_inc, sizeof(yyjson_mut_write_ctx)); \\\n-\t   if (size_add_is_overflow(alc_len, alc_inc)) goto fail_alloc; \\\n-\t   alc_len += alc_inc; \\\n-\t   tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len); \\\n-\t   if (unlikely(!tmp)) goto fail_alloc; \\\n-\t   ctx_len = (usize)(end - (u8 *)ctx); \\\n-\t   ctx_tmp = (yyjson_mut_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n-\t   memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n-\t   ctx = ctx_tmp; \\\n-\t   cur = tmp + (cur - hdr); \\\n-\t   end = tmp + alc_len; \\\n-\t   hdr = tmp; \\\n-   } \\\n+    ext_len = (usize)(_len); \\\n+    if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n+        alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n+        alc_inc = size_align_up(alc_inc, sizeof(yyjson_mut_write_ctx)); \\\n+        if (size_add_is_overflow(alc_len, alc_inc)) goto fail_alloc; \\\n+        alc_len += alc_inc; \\\n+        tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len - alc_inc, alc_len); \\\n+        if (unlikely(!tmp)) goto fail_alloc; \\\n+        ctx_len = (usize)(end - (u8 *)ctx); \\\n+        ctx_tmp = (yyjson_mut_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n+        memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n+        ctx = ctx_tmp; \\\n+        cur = tmp + (cur - hdr); \\\n+        end = tmp + alc_len; \\\n+        hdr = tmp; \\\n+    } \\\n } while (false)\n-\n+    \n #define check_str_len(_len) do { \\\n-   if ((USIZE_MAX < U64_MAX) && (_len >= (USIZE_MAX - 16) / 6)) \\\n-\t   goto fail_alloc; \\\n+    if ((USIZE_MAX < U64_MAX) && (_len >= (USIZE_MAX - 16) / 6)) \\\n+        goto fail_alloc; \\\n } while (false)\n-\n-   yyjson_mut_val *val, *ctn;\n-   yyjson_type val_type;\n-   usize ctn_len, ctn_len_tmp;\n-   bool ctn_obj, ctn_obj_tmp, is_key, no_indent;\n-   u8 *hdr, *cur, *end, *tmp;\n-   yyjson_mut_write_ctx *ctx, *ctx_tmp;\n-   usize alc_len, alc_inc, ctx_len, ext_len, str_len, level;\n-   const u8 *str_ptr;\n-   const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n-   bool esc = (flg & YYJSON_WRITE_ESCAPE_UNICODE) != 0;\n-   bool inv = (flg & YYJSON_WRITE_ALLOW_INVALID_UNICODE) != 0;\n-\n-   alc_len = 0 * YYJSON_WRITER_ESTIMATED_PRETTY_RATIO + 64;\n-   alc_len = size_align_up(alc_len, sizeof(yyjson_mut_write_ctx));\n-   hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n-   if (!hdr) goto fail_alloc;\n-   cur = hdr;\n-   end = hdr + alc_len;\n-   ctx = (yyjson_mut_write_ctx *)(void *)end;\n-\n+    \n+    yyjson_mut_val *val, *ctn;\n+    yyjson_type val_type;\n+    usize ctn_len, ctn_len_tmp;\n+    bool ctn_obj, ctn_obj_tmp, is_key, no_indent;\n+    u8 *hdr, *cur, *end, *tmp;\n+    yyjson_mut_write_ctx *ctx, *ctx_tmp;\n+    usize alc_len, alc_inc, ctx_len, ext_len, str_len, level;\n+    const u8 *str_ptr;\n+    const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n+    bool esc = (flg & YYJSON_WRITE_ESCAPE_UNICODE) != 0;\n+    bool inv = (flg & YYJSON_WRITE_ALLOW_INVALID_UNICODE) != 0;\n+    usize spaces = (flg & YYJSON_WRITE_PRETTY_TWO_SPACES) ? 2 : 4;\n+    \n+    alc_len = 0 * YYJSON_WRITER_ESTIMATED_PRETTY_RATIO + 64;\n+    alc_len = size_align_up(alc_len, sizeof(yyjson_mut_write_ctx));\n+    hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n+    if (!hdr) goto fail_alloc;\n+    cur = hdr;\n+    end = hdr + alc_len;\n+    ctx = (yyjson_mut_write_ctx *)(void *)end;\n+    \n doc_begin:\n-   val = (yyjson_mut_val *)root;\n-   val_type = unsafe_yyjson_get_type(val);\n-   ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n-   ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n-   *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n-   *cur++ = '\\n';\n-   ctn = val;\n-   val = (yyjson_mut_val *)val->uni.ptr; /* tail */\n-   val = ctn_obj ? val->next->next : val->next;\n-   level = 1;\n-\n+    val = (yyjson_mut_val *)root;\n+    val_type = unsafe_yyjson_get_type(val);\n+    ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n+    ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n+    *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n+    *cur++ = '\\n';\n+    ctn = val;\n+    val = (yyjson_mut_val *)val->uni.ptr; /* tail */\n+    val = ctn_obj ? val->next->next : val->next;\n+    level = 1;\n+    \n val_begin:\n-   val_type = unsafe_yyjson_get_type(val);\n-   if (val_type == YYJSON_TYPE_STR) {\n-\t   is_key = (bool)((u8)ctn_obj & (u8)~ctn_len);\n-\t   no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n-\t   str_len = unsafe_yyjson_get_len(val);\n-\t   str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n-\t   check_str_len(str_len);\n-\t   incr_len(str_len * 6 + 16 + (no_indent ? 0 : level * 4));\n-\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t   cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n-\t   if (unlikely(!cur)) goto fail_str;\n-\t   *cur++ = is_key ? ':' : ',';\n-\t   *cur++ = is_key ? ' ' : '\\n';\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_NUM) {\n-\t   no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n-\t   incr_len(32 + (no_indent ? 0 : level * 4));\n-\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t   cur = write_number(cur, (yyjson_val *)val, flg);\n-\t   if (unlikely(!cur)) goto fail_num;\n-\t   *cur++ = ',';\n-\t   *cur++ = '\\n';\n-\t   goto val_end;\n-   }\n-   if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n-\t   (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n-\t   no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n-\t   ctn_len_tmp = unsafe_yyjson_get_len(val);\n-\t   ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n-\t   if (unlikely(ctn_len_tmp == 0)) {\n-\t\t   /* write empty container */\n-\t\t   incr_len(16 + (no_indent ? 0 : level * 4));\n-\t\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t\t   *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n-\t\t   *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n-\t\t   *cur++ = ',';\n-\t\t   *cur++ = '\\n';\n-\t\t   goto val_end;\n-\t   } else {\n-\t\t   /* push context, setup new container */\n-\t\t   incr_len(32 + (no_indent ? 0 : level * 4));\n-\t\t   yyjson_mut_write_ctx_set(--ctx, ctn, ctn_len, ctn_obj);\n-\t\t   ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n-\t\t   ctn_obj = ctn_obj_tmp;\n-\t\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t\t   level++;\n-\t\t   *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n-\t\t   *cur++ = '\\n';\n-\t\t   ctn = val;\n-\t\t   val = (yyjson_mut_val *)ctn->uni.ptr; /* tail */\n-\t\t   val = ctn_obj ? val->next->next : val->next;\n-\t\t   goto val_begin;\n-\t   }\n-   }\n-   if (val_type == YYJSON_TYPE_BOOL) {\n-\t   no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n-\t   incr_len(16 + (no_indent ? 0 : level * 4));\n-\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t   cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n-\t   cur += 2;\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_NULL) {\n-\t   no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n-\t   incr_len(16 + (no_indent ? 0 : level * 4));\n-\t   cur = write_indent(cur, no_indent ? 0 : level);\n-\t   cur = write_null(cur);\n-\t   cur += 2;\n-\t   goto val_end;\n-   }\n-   if (val_type == YYJSON_TYPE_RAW) {\n-\t   str_len = unsafe_yyjson_get_len(val);\n-\t   str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n-\t   check_str_len(str_len);\n-\t   incr_len(str_len + 3);\n-\t   cur = write_raw(cur, str_ptr, str_len);\n-\t   *cur++ = ',';\n-\t   *cur++ = '\\n';\n-\t   goto val_end;\n-   }\n-   goto fail_type;\n-\n+    val_type = unsafe_yyjson_get_type(val);\n+    if (val_type == YYJSON_TYPE_STR) {\n+        is_key = (bool)((u8)ctn_obj & (u8)~ctn_len);\n+        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n+        str_len = unsafe_yyjson_get_len(val);\n+        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n+        check_str_len(str_len);\n+        incr_len(str_len * 6 + 16 + (no_indent ? 0 : level * 4));\n+        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+        cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n+        if (unlikely(!cur)) goto fail_str;\n+        *cur++ = is_key ? ':' : ',';\n+        *cur++ = is_key ? ' ' : '\\n';\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_NUM) {\n+        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n+        incr_len(32 + (no_indent ? 0 : level * 4));\n+        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+        cur = write_number(cur, (yyjson_val *)val, flg);\n+        if (unlikely(!cur)) goto fail_num;\n+        *cur++ = ',';\n+        *cur++ = '\\n';\n+        goto val_end;\n+    }\n+    if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n+                    (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n+        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n+        ctn_len_tmp = unsafe_yyjson_get_len(val);\n+        ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n+        if (unlikely(ctn_len_tmp == 0)) {\n+            /* write empty container */\n+            incr_len(16 + (no_indent ? 0 : level * 4));\n+            cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+            *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n+            *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n+            *cur++ = ',';\n+            *cur++ = '\\n';\n+            goto val_end;\n+        } else {\n+            /* push context, setup new container */\n+            incr_len(32 + (no_indent ? 0 : level * 4));\n+            yyjson_mut_write_ctx_set(--ctx, ctn, ctn_len, ctn_obj);\n+            ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n+            ctn_obj = ctn_obj_tmp;\n+            cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+            level++;\n+            *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n+            *cur++ = '\\n';\n+            ctn = val;\n+            val = (yyjson_mut_val *)ctn->uni.ptr; /* tail */\n+            val = ctn_obj ? val->next->next : val->next;\n+            goto val_begin;\n+        }\n+    }\n+    if (val_type == YYJSON_TYPE_BOOL) {\n+        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n+        incr_len(16 + (no_indent ? 0 : level * 4));\n+        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+        cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n+        cur += 2;\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_NULL) {\n+        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n+        incr_len(16 + (no_indent ? 0 : level * 4));\n+        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n+        cur = write_null(cur);\n+        cur += 2;\n+        goto val_end;\n+    }\n+    if (val_type == YYJSON_TYPE_RAW) {\n+        str_len = unsafe_yyjson_get_len(val);\n+        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n+        check_str_len(str_len);\n+        incr_len(str_len + 3);\n+        cur = write_raw(cur, str_ptr, str_len);\n+        *cur++ = ',';\n+        *cur++ = '\\n';\n+        goto val_end;\n+    }\n+    goto fail_type;\n+    \n val_end:\n-   ctn_len--;\n-   if (unlikely(ctn_len == 0)) goto ctn_end;\n-   val = val->next;\n-   goto val_begin;\n-\n+    ctn_len--;\n+    if (unlikely(ctn_len == 0)) goto ctn_end;\n+    val = val->next;\n+    goto val_begin;\n+    \n ctn_end:\n-   cur -= 2;\n-   *cur++ = '\\n';\n-   incr_len(level * 4);\n-   cur = write_indent(cur, --level);\n-   *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n-   if (unlikely((u8 *)ctx >= end)) goto doc_end;\n-   val = ctn->next;\n-   yyjson_mut_write_ctx_get(ctx++, &ctn, &ctn_len, &ctn_obj);\n-   ctn_len--;\n-   *cur++ = ',';\n-   *cur++ = '\\n';\n-   if (likely(ctn_len > 0)) {\n-\t   goto val_begin;\n-   } else {\n-\t   goto ctn_end;\n-   }\n-\n+    cur -= 2;\n+    *cur++ = '\\n';\n+    incr_len(level * 4);\n+    cur = write_indent(cur, --level, spaces);\n+    *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n+    if (unlikely((u8 *)ctx >= end)) goto doc_end;\n+    val = ctn->next;\n+    yyjson_mut_write_ctx_get(ctx++, &ctn, &ctn_len, &ctn_obj);\n+    ctn_len--;\n+    *cur++ = ',';\n+    *cur++ = '\\n';\n+    if (likely(ctn_len > 0)) {\n+        goto val_begin;\n+    } else {\n+        goto ctn_end;\n+    }\n+    \n doc_end:\n-   *cur = '\\0';\n-   *dat_len = (usize)(cur - hdr);\n-   err->code = YYJSON_WRITE_SUCCESS;\n-   err->msg = \"success\";\n-   return hdr;\n-\n+    *cur = '\\0';\n+    *dat_len = (usize)(cur - hdr);\n+    err->code = YYJSON_WRITE_SUCCESS;\n+    err->msg = \"success\";\n+    return hdr;\n+    \n fail_alloc:\n-   return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\n+    return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\n fail_type:\n-   return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\n+    return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\n fail_num:\n-   return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\n+    return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\n fail_str:\n-   return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n-\n+    return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n+    \n #undef return_err\n #undef incr_len\n #undef check_str_len\n }\n \n char *yyjson_mut_val_write_opts(const yyjson_mut_val *val,\n-\t\t\t\t\t\t\t   yyjson_write_flag flg,\n-\t\t\t\t\t\t\t   const yyjson_alc *alc_ptr,\n-\t\t\t\t\t\t\t   usize *dat_len,\n-\t\t\t\t\t\t\t   yyjson_write_err *err) {\n-   yyjson_write_err dummy_err;\n-   usize dummy_dat_len;\n-   yyjson_alc alc = alc_ptr ? *alc_ptr : YYJSON_DEFAULT_ALC;\n-   yyjson_mut_val *root = (yyjson_mut_val *)val;\n-\n-   err = err ? err : &dummy_err;\n-   dat_len = dat_len ? dat_len : &dummy_dat_len;\n-\n+                                yyjson_write_flag flg,\n+                                const yyjson_alc *alc_ptr,\n+                                usize *dat_len,\n+                                yyjson_write_err *err) {\n+    yyjson_write_err dummy_err;\n+    usize dummy_dat_len;\n+    yyjson_alc alc = alc_ptr ? *alc_ptr : YYJSON_DEFAULT_ALC;\n+    yyjson_mut_val *root = (yyjson_mut_val *)val;\n+    \n+    err = err ? err : &dummy_err;\n+    dat_len = dat_len ? dat_len : &dummy_dat_len;\n+    \n #if YYJSON_DISABLE_NON_STANDARD\n-   flg &= ~YYJSON_WRITE_ALLOW_INF_AND_NAN;\n-   flg &= ~YYJSON_WRITE_ALLOW_INVALID_UNICODE;\n+    flg &= ~YYJSON_WRITE_ALLOW_INF_AND_NAN;\n+    flg &= ~YYJSON_WRITE_ALLOW_INVALID_UNICODE;\n #endif\n-\n-   if (unlikely(!root)) {\n-\t   *dat_len = 0;\n-\t   err->msg = \"input JSON is NULL\";\n-\t   err->code = YYJSON_WRITE_ERROR_INVALID_PARAMETER;\n-\t   return NULL;\n-   }\n-\n-   if (!unsafe_yyjson_is_ctn(root) || unsafe_yyjson_get_len(root) == 0) {\n-\t   return (char *)yyjson_mut_write_single(root, flg, alc, dat_len, err);\n-   } else if (flg & YYJSON_WRITE_PRETTY) {\n-\t   return (char *)yyjson_mut_write_pretty(root, flg, alc, dat_len, err);\n-   } else {\n-\t   return (char *)yyjson_mut_write_minify(root, flg, alc, dat_len, err);\n-   }\n+    \n+    if (unlikely(!root)) {\n+        *dat_len = 0;\n+        err->msg = \"input JSON is NULL\";\n+        err->code = YYJSON_WRITE_ERROR_INVALID_PARAMETER;\n+        return NULL;\n+    }\n+    \n+    if (!unsafe_yyjson_is_ctn(root) || unsafe_yyjson_get_len(root) == 0) {\n+        return (char *)yyjson_mut_write_single(root, flg, alc, dat_len, err);\n+    } else if (flg & (YYJSON_WRITE_PRETTY | YYJSON_WRITE_PRETTY_TWO_SPACES)) {\n+        return (char *)yyjson_mut_write_pretty(root, flg, alc, dat_len, err);\n+    } else {\n+        return (char *)yyjson_mut_write_minify(root, flg, alc, dat_len, err);\n+    }\n }\n \n char *yyjson_mut_write_opts(const yyjson_mut_doc *doc,\n-\t\t\t\t\t\t   yyjson_write_flag flg,\n-\t\t\t\t\t\t   const yyjson_alc *alc_ptr,\n-\t\t\t\t\t\t   usize *dat_len,\n-\t\t\t\t\t\t   yyjson_write_err *err) {\n-   yyjson_mut_val *root = doc ? doc->root : NULL;\n-   return yyjson_mut_val_write_opts(root, flg, alc_ptr, dat_len, err);\n+                            yyjson_write_flag flg,\n+                            const yyjson_alc *alc_ptr,\n+                            usize *dat_len,\n+                            yyjson_write_err *err) {\n+    yyjson_mut_val *root = doc ? doc->root : NULL;\n+    return yyjson_mut_val_write_opts(root, flg, alc_ptr, dat_len, err);\n }\n \n bool yyjson_mut_val_write_file(const char *path,\n-\t\t\t\t\t\t\t  const yyjson_mut_val *val,\n-\t\t\t\t\t\t\t  yyjson_write_flag flg,\n-\t\t\t\t\t\t\t  const yyjson_alc *alc_ptr,\n-\t\t\t\t\t\t\t  yyjson_write_err *err) {\n-   yyjson_write_err dummy_err;\n-   u8 *dat;\n-   usize dat_len = 0;\n-   yyjson_mut_val *root = (yyjson_mut_val *)val;\n-   bool suc;\n-\n-   alc_ptr = alc_ptr ? alc_ptr : &YYJSON_DEFAULT_ALC;\n-   err = err ? err : &dummy_err;\n-   if (unlikely(!path || !*path)) {\n-\t   err->msg = \"input path is invalid\";\n-\t   err->code = YYJSON_WRITE_ERROR_INVALID_PARAMETER;\n-\t   return false;\n-   }\n-\n-   dat = (u8 *)yyjson_mut_val_write_opts(root, flg, alc_ptr, &dat_len, err);\n-   if (unlikely(!dat)) return false;\n-   suc = write_dat_to_file(path, dat, dat_len, err);\n-   alc_ptr->free(alc_ptr->ctx, dat);\n-   return suc;\n-\n+                               const yyjson_mut_val *val,\n+                               yyjson_write_flag flg,\n+                               const yyjson_alc *alc_ptr,\n+                               yyjson_write_err *err) {\n+    yyjson_write_err dummy_err;\n+    u8 *dat;\n+    usize dat_len = 0;\n+    yyjson_mut_val *root = (yyjson_mut_val *)val;\n+    bool suc;\n+    \n+    alc_ptr = alc_ptr ? alc_ptr : &YYJSON_DEFAULT_ALC;\n+    err = err ? err : &dummy_err;\n+    if (unlikely(!path || !*path)) {\n+        err->msg = \"input path is invalid\";\n+        err->code = YYJSON_WRITE_ERROR_INVALID_PARAMETER;\n+        return false;\n+    }\n+    \n+    dat = (u8 *)yyjson_mut_val_write_opts(root, flg, alc_ptr, &dat_len, err);\n+    if (unlikely(!dat)) return false;\n+    suc = write_dat_to_file(path, dat, dat_len, err);\n+    alc_ptr->free(alc_ptr->ctx, dat);\n+    return suc;\n+    \n }\n \n bool yyjson_mut_write_file(const char *path,\n-\t\t\t\t\t\t  const yyjson_mut_doc *doc,\n-\t\t\t\t\t\t  yyjson_write_flag flg,\n-\t\t\t\t\t\t  const yyjson_alc *alc_ptr,\n-\t\t\t\t\t\t  yyjson_write_err *err) {\n-   yyjson_mut_val *root = doc ? doc->root : NULL;\n-   return yyjson_mut_val_write_file(path, root, flg, alc_ptr, err);\n+                           const yyjson_mut_doc *doc,\n+                           yyjson_write_flag flg,\n+                           const yyjson_alc *alc_ptr,\n+                           yyjson_write_err *err) {\n+    yyjson_mut_val *root = doc ? doc->root : NULL;\n+    return yyjson_mut_val_write_file(path, root, flg, alc_ptr, err);\n }\n \n #endif /* YYJSON_DISABLE_WRITER */\n@@ -7990,8 +8159,8 @@ bool yyjson_mut_write_file(const char *path,\n \n \n /*==============================================================================\n-* Compiler Hint End\n-*============================================================================*/\n+ * Compiler Hint End\n+ *============================================================================*/\n \n #if defined(__clang__)\n #   pragma clang diagnostic pop\ndiff --git a/extension/parquet/column_reader.cpp b/extension/parquet/column_reader.cpp\nindex 3af305b4185b..b35df52b0ba3 100644\n--- a/extension/parquet/column_reader.cpp\n+++ b/extension/parquet/column_reader.cpp\n@@ -1337,7 +1337,6 @@ unique_ptr<ColumnReader> ColumnReader::CreateReader(ParquetReader &reader, const\n \t\t    reader, type_p, schema_p, file_idx_p, max_define, max_repeat);\n \tcase LogicalTypeId::BLOB:\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\treturn make_unique<StringColumnReader>(reader, type_p, schema_p, file_idx_p, max_define, max_repeat);\n \tcase LogicalTypeId::DECIMAL:\n \t\t// we have to figure out what kind of int we need\ndiff --git a/extension/parquet/column_writer.cpp b/extension/parquet/column_writer.cpp\nindex 82a4fac858f3..a7b45d5f5bbe 100644\n--- a/extension/parquet/column_writer.cpp\n+++ b/extension/parquet/column_writer.cpp\n@@ -2027,7 +2027,6 @@ unique_ptr<ColumnWriter> ColumnWriter::CreateWriterRecursive(vector<duckdb_parqu\n \t\t}\n \tcase LogicalTypeId::BLOB:\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\treturn make_unique<StringColumnWriter>(writer, schema_idx, std::move(schema_path), max_repeat, max_define,\n \t\t                                       can_have_nulls);\n \tcase LogicalTypeId::UUID:\ndiff --git a/extension/parquet/parquet_reader.cpp b/extension/parquet/parquet_reader.cpp\nindex f674a61c9fe3..dc634162da95 100644\n--- a/extension/parquet/parquet_reader.cpp\n+++ b/extension/parquet/parquet_reader.cpp\n@@ -209,7 +209,7 @@ LogicalType ParquetReader::DeriveLogicalType(const SchemaElement &s_ele, bool bi\n \t\tcase ConvertedType::INTERVAL:\n \t\t\treturn LogicalType::INTERVAL;\n \t\tcase ConvertedType::JSON:\n-\t\t\treturn LogicalType::JSON;\n+\t\t\treturn LogicalType::VARCHAR;\n \t\tcase ConvertedType::MAP:\n \t\tcase ConvertedType::MAP_KEY_VALUE:\n \t\tcase ConvertedType::LIST:\ndiff --git a/extension/parquet/parquet_writer.cpp b/extension/parquet/parquet_writer.cpp\nindex 287aa637b67f..18de9a2bafc8 100644\n--- a/extension/parquet/parquet_writer.cpp\n+++ b/extension/parquet/parquet_writer.cpp\n@@ -70,7 +70,6 @@ Type::type ParquetWriter::DuckDBTypeToParquetType(const LogicalType &duckdb_type\n \t\treturn Type::DOUBLE;\n \tcase LogicalTypeId::ENUM:\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::BLOB:\n \t\treturn Type::BYTE_ARRAY;\n \tcase LogicalTypeId::TIME:\n@@ -176,7 +175,6 @@ void ParquetWriter::SetSchemaProperties(const LogicalType &duckdb_type,\n \t\tbreak;\n \tcase LogicalTypeId::ENUM:\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\tschema_ele.converted_type = ConvertedType::UTF8;\n \t\tschema_ele.__isset.converted_type = true;\n \t\tbreak;\ndiff --git a/src/catalog/default/default_types.cpp b/src/catalog/default/default_types.cpp\nindex f1607a5269a8..46b1e0804f71 100644\n--- a/src/catalog/default/default_types.cpp\n+++ b/src/catalog/default/default_types.cpp\n@@ -78,7 +78,6 @@ static DefaultType internal_types[] = {{\"int\", LogicalTypeId::INTEGER},\n                                        {\"union\", LogicalTypeId::UNION},\n                                        {\"timestamptz\", LogicalTypeId::TIMESTAMP_TZ},\n                                        {\"timetz\", LogicalTypeId::TIME_TZ},\n-                                       {\"json\", LogicalTypeId::JSON},\n                                        {\"enum\", LogicalTypeId::ENUM},\n                                        {\"null\", LogicalTypeId::SQLNULL},\n                                        {nullptr, LogicalTypeId::INVALID}};\ndiff --git a/src/common/arrow/arrow_appender.cpp b/src/common/arrow/arrow_appender.cpp\nindex b4d6d8b7976b..3a25c590825d 100644\n--- a/src/common/arrow/arrow_appender.cpp\n+++ b/src/common/arrow/arrow_appender.cpp\n@@ -607,7 +607,6 @@ static void InitializeFunctionPointers(ArrowAppendData &append_data, const Logic\n \t\tbreak;\n \tcase LogicalTypeId::VARCHAR:\n \tcase LogicalTypeId::BLOB:\n-\tcase LogicalTypeId::JSON:\n \t\tInitializeFunctionPointers<ArrowVarcharData<string_t>>(append_data);\n \t\tbreak;\n \tcase LogicalTypeId::UUID:\ndiff --git a/src/common/arrow/arrow_converter.cpp b/src/common/arrow/arrow_converter.cpp\nindex 6b3dc4fc2f0d..69c9750c19bf 100644\n--- a/src/common/arrow/arrow_converter.cpp\n+++ b/src/common/arrow/arrow_converter.cpp\n@@ -116,7 +116,6 @@ void SetArrowFormat(DuckDBArrowSchemaHolder &root_holder, ArrowSchema &child, co\n \t\tchild.format = \"g\";\n \t\tbreak;\n \tcase LogicalTypeId::UUID:\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR:\n \t\tchild.format = \"u\";\n \t\tbreak;\ndiff --git a/src/common/radix_partitioning.cpp b/src/common/radix_partitioning.cpp\nindex 10a65df8360a..8e38708e8901 100644\n--- a/src/common/radix_partitioning.cpp\n+++ b/src/common/radix_partitioning.cpp\n@@ -11,7 +11,7 @@\n namespace duckdb {\n \n template <class OP, class RETURN_TYPE, typename... ARGS>\n-RETURN_TYPE RadixBitsSwitch(idx_t radix_bits, ARGS &&...args) {\n+RETURN_TYPE RadixBitsSwitch(idx_t radix_bits, ARGS &&... args) {\n \tD_ASSERT(radix_bits <= sizeof(hash_t) * 8);\n \tswitch (radix_bits) {\n \tcase 1:\n@@ -40,7 +40,7 @@ RETURN_TYPE RadixBitsSwitch(idx_t radix_bits, ARGS &&...args) {\n }\n \n template <class OP, class RETURN_TYPE, idx_t radix_bits_1, typename... ARGS>\n-RETURN_TYPE DoubleRadixBitsSwitch2(idx_t radix_bits_2, ARGS &&...args) {\n+RETURN_TYPE DoubleRadixBitsSwitch2(idx_t radix_bits_2, ARGS &&... args) {\n \tD_ASSERT(radix_bits_2 <= sizeof(hash_t) * 8);\n \tswitch (radix_bits_2) {\n \tcase 1:\n@@ -69,7 +69,7 @@ RETURN_TYPE DoubleRadixBitsSwitch2(idx_t radix_bits_2, ARGS &&...args) {\n }\n \n template <class OP, class RETURN_TYPE, typename... ARGS>\n-RETURN_TYPE DoubleRadixBitsSwitch1(idx_t radix_bits_1, idx_t radix_bits_2, ARGS &&...args) {\n+RETURN_TYPE DoubleRadixBitsSwitch1(idx_t radix_bits_1, idx_t radix_bits_2, ARGS &&... args) {\n \tD_ASSERT(radix_bits_1 <= sizeof(hash_t) * 8);\n \tswitch (radix_bits_1) {\n \tcase 1:\ndiff --git a/src/common/sort/sort_state.cpp b/src/common/sort/sort_state.cpp\nindex 6db30388b475..653e842e619e 100644\n--- a/src/common/sort/sort_state.cpp\n+++ b/src/common/sort/sort_state.cpp\n@@ -1,9 +1,10 @@\n #include \"duckdb/common/fast_mem.hpp\"\n+#include \"duckdb/common/radix.hpp\"\n #include \"duckdb/common/row_operations/row_operations.hpp\"\n #include \"duckdb/common/sort/sort.hpp\"\n #include \"duckdb/common/sort/sorted_block.hpp\"\n #include \"duckdb/storage/statistics/string_statistics.hpp\"\n-#include \"duckdb/common/radix.hpp\"\n+\n #include <algorithm>\n #include <numeric>\n \n@@ -270,10 +271,12 @@ unique_ptr<RowDataBlock> LocalSortState::ConcatenateBlocks(RowDataCollection &ro\n \tauto new_block_handle = buffer_manager->Pin(new_block->block);\n \tdata_ptr_t new_block_ptr = new_block_handle.Ptr();\n \t// Copy the data of the blocks into a single block\n-\tfor (auto &block : row_data.blocks) {\n+\tfor (idx_t i = 0; i < row_data.blocks.size(); i++) {\n+\t\tauto &block = row_data.blocks[i];\n \t\tauto block_handle = buffer_manager->Pin(block->block);\n \t\tmemcpy(new_block_ptr, block_handle.Ptr(), block->count * entry_size);\n \t\tnew_block_ptr += block->count * entry_size;\n+\t\tblock.reset();\n \t}\n \trow_data.blocks.clear();\n \trow_data.count = 0;\ndiff --git a/src/common/symbols.cpp b/src/common/symbols.cpp\nindex 18ae29ee0e0f..42509b3b5f86 100644\n--- a/src/common/symbols.cpp\n+++ b/src/common/symbols.cpp\n@@ -88,6 +88,8 @@ template class std::weak_ptr<Pipeline>;\n template class std::shared_ptr<MetaPipeline>;\n template class std::unique_ptr<RowGroup>;\n template class std::shared_ptr<RowGroupCollection>;\n+template class std::unique_ptr<RowDataBlock>;\n+template class std::unique_ptr<RowDataCollection>;\n template class std::unique_ptr<ColumnDataCollection>;\n template class std::shared_ptr<ColumnDataAllocator>;\n template class std::unique_ptr<PartitionedColumnData>;\n@@ -186,6 +188,7 @@ template class std::vector<LogicalType>;\n INSTANTIATE_VECTOR(std::vector<std::unique_ptr<JoinHashTable>>)\n INSTANTIATE_VECTOR(std::vector<std::unique_ptr<ColumnDataCollection>>)\n INSTANTIATE_VECTOR(std::vector<std::shared_ptr<ColumnDataAllocator>>)\n+INSTANTIATE_VECTOR(std::vector<std::unique_ptr<RowDataBlock>>)\n \n #if !defined(__clang__)\n template struct std::atomic<uint64_t>;\ndiff --git a/src/common/types.cpp b/src/common/types.cpp\nindex 0db7fde28812..eb29dbbbb529 100644\n--- a/src/common/types.cpp\n+++ b/src/common/types.cpp\n@@ -1,23 +1,24 @@\n #include \"duckdb/common/types.hpp\"\n \n-#include \"duckdb/catalog/default/default_types.hpp\"\n+#include \"duckdb/catalog/catalog.hpp\"\n #include \"duckdb/catalog/catalog_entry/type_catalog_entry.hpp\"\n+#include \"duckdb/catalog/default/default_types.hpp\"\n #include \"duckdb/common/exception.hpp\"\n #include \"duckdb/common/field_writer.hpp\"\n #include \"duckdb/common/limits.hpp\"\n #include \"duckdb/common/operator/comparison_operators.hpp\"\n+#include \"duckdb/common/serializer.hpp\"\n+#include \"duckdb/common/string_map_set.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/common/types/decimal.hpp\"\n #include \"duckdb/common/types/hash.hpp\"\n #include \"duckdb/common/types/string_type.hpp\"\n #include \"duckdb/common/types/value.hpp\"\n #include \"duckdb/common/types/vector.hpp\"\n-#include \"duckdb/common/serializer.hpp\"\n #include \"duckdb/common/unordered_map.hpp\"\n+#include \"duckdb/function/cast_rules.hpp\"\n #include \"duckdb/parser/keyword_helper.hpp\"\n #include \"duckdb/parser/parser.hpp\"\n-#include \"duckdb/function/cast_rules.hpp\"\n-#include \"duckdb/common/string_map_set.hpp\"\n \n #include <cmath>\n \n@@ -103,7 +104,6 @@ PhysicalType LogicalType::GetInternalType() {\n \tcase LogicalTypeId::VARCHAR:\n \tcase LogicalTypeId::CHAR:\n \tcase LogicalTypeId::BLOB:\n-\tcase LogicalTypeId::JSON:\n \t\treturn PhysicalType::VARCHAR;\n \tcase LogicalTypeId::INTERVAL:\n \t\treturn PhysicalType::INTERVAL;\n@@ -177,7 +177,6 @@ constexpr const LogicalTypeId LogicalType::HASH;\n constexpr const LogicalTypeId LogicalType::POINTER;\n \n constexpr const LogicalTypeId LogicalType::VARCHAR;\n-constexpr const LogicalTypeId LogicalType::JSON;\n \n constexpr const LogicalTypeId LogicalType::BLOB;\n constexpr const LogicalTypeId LogicalType::INTERVAL;\n@@ -212,7 +211,7 @@ const vector<LogicalType> LogicalType::AllTypes() {\n \t    LogicalType::HUGEINT,  LogicalTypeId::DECIMAL, LogicalType::UTINYINT,     LogicalType::USMALLINT,\n \t    LogicalType::UINTEGER, LogicalType::UBIGINT,   LogicalType::TIME,         LogicalTypeId::LIST,\n \t    LogicalTypeId::STRUCT, LogicalType::TIME_TZ,   LogicalType::TIMESTAMP_TZ, LogicalTypeId::MAP,\n-\t    LogicalTypeId::UNION,  LogicalType::UUID,      LogicalType::JSON};\n+\t    LogicalTypeId::UNION,  LogicalType::UUID};\n \treturn types;\n }\n \n@@ -404,8 +403,6 @@ string LogicalTypeIdToString(LogicalTypeId id) {\n \t\treturn \"AGGREGATE_STATE\";\n \tcase LogicalTypeId::USER:\n \t\treturn \"USER\";\n-\tcase LogicalTypeId::JSON:\n-\t\treturn \"JSON\";\n \t}\n \treturn \"UNDEFINED\";\n }\n@@ -503,6 +500,13 @@ LogicalType TransformStringToLogicalType(const string &str) {\n \treturn Parser::ParseColumnList(\"dummy \" + str).GetColumn(LogicalIndex(0)).Type();\n }\n \n+LogicalType TransformStringToLogicalType(const string &str, ClientContext &context) {\n+\tauto type = TransformStringToLogicalType(str);\n+\treturn type.id() == LogicalTypeId::USER\n+\t           ? Catalog::GetSystemCatalog(context).GetType(context, SYSTEM_CATALOG, DEFAULT_SCHEMA, str)\n+\t           : type;\n+}\n+\n bool LogicalType::IsIntegral() const {\n \tswitch (id_) {\n \tcase LogicalTypeId::TINYINT:\ndiff --git a/src/common/types/value.cpp b/src/common/types/value.cpp\nindex 1b5f296b267c..4dc7ca4d939d 100644\n--- a/src/common/types/value.cpp\n+++ b/src/common/types/value.cpp\n@@ -613,24 +613,6 @@ Value Value::BLOB(const string &data) {\n \treturn result;\n }\n \n-Value Value::JSON(const char *val) {\n-\tauto result = Value(val);\n-\tresult.type_ = LogicalTypeId::JSON;\n-\treturn result;\n-}\n-\n-Value Value::JSON(string_t val) {\n-\tauto result = Value(val);\n-\tresult.type_ = LogicalTypeId::JSON;\n-\treturn result;\n-}\n-\n-Value Value::JSON(string val) {\n-\tauto result = Value(std::move(val));\n-\tresult.type_ = LogicalTypeId::JSON;\n-\treturn result;\n-}\n-\n Value Value::ENUM(uint64_t value, const LogicalType &original_type) {\n \tD_ASSERT(original_type.id() == LogicalTypeId::ENUM);\n \tValue result(original_type);\ndiff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp\nindex 144b1395e224..b51c22693ee5 100644\n--- a/src/common/types/vector.cpp\n+++ b/src/common/types/vector.cpp\n@@ -536,10 +536,6 @@ Value Vector::GetValueInternal(const Vector &v_p, idx_t index_p) {\n \t\tauto str = ((string_t *)data)[index];\n \t\treturn Value(str.GetString());\n \t}\n-\tcase LogicalTypeId::JSON: {\n-\t\tauto str = ((string_t *)data)[index];\n-\t\treturn Value::JSON(str.GetString());\n-\t}\n \tcase LogicalTypeId::AGGREGATE_STATE:\n \tcase LogicalTypeId::BLOB: {\n \t\tauto str = ((string_t *)data)[index];\n@@ -1114,7 +1110,7 @@ void Vector::Verify(Vector &vector_p, const SelectionVector &sel_p, idx_t count)\n \t    (vtype == VectorType::CONSTANT_VECTOR || vtype == VectorType::FLAT_VECTOR)) {\n \t\tD_ASSERT(!vector->auxiliary);\n \t}\n-\tif (type.id() == LogicalTypeId::VARCHAR || type.id() == LogicalTypeId::JSON) {\n+\tif (type.id() == LogicalTypeId::VARCHAR) {\n \t\t// verify that the string is correct unicode\n \t\tswitch (vtype) {\n \t\tcase VectorType::FLAT_VECTOR: {\n@@ -1355,7 +1351,7 @@ string_t StringVector::AddString(Vector &vector, const string &data) {\n }\n \n string_t StringVector::AddString(Vector &vector, string_t data) {\n-\tD_ASSERT(vector.GetType().id() == LogicalTypeId::VARCHAR || vector.GetType().id() == LogicalTypeId::JSON);\n+\tD_ASSERT(vector.GetType().id() == LogicalTypeId::VARCHAR);\n \tif (data.IsInlined()) {\n \t\t// string will be inlined: no need to store in string heap\n \t\treturn data;\ndiff --git a/src/common/vector_operations/vector_cast.cpp b/src/common/vector_operations/vector_cast.cpp\nindex 26b524c3d531..9841cb83ddc5 100644\n--- a/src/common/vector_operations/vector_cast.cpp\n+++ b/src/common/vector_operations/vector_cast.cpp\n@@ -1,5 +1,5 @@\n-#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n #include \"duckdb/common/limits.hpp\"\n+#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n #include \"duckdb/function/cast/cast_function_set.hpp\"\n #include \"duckdb/main/config.hpp\"\n \n@@ -8,7 +8,11 @@ namespace duckdb {\n bool VectorOperations::TryCast(CastFunctionSet &set, GetCastFunctionInput &input, Vector &source, Vector &result,\n                                idx_t count, string *error_message, bool strict) {\n \tauto cast_function = set.GetCastFunction(source.GetType(), result.GetType(), input);\n-\tCastParameters parameters(cast_function.cast_data.get(), strict, error_message);\n+\tunique_ptr<FunctionLocalState> local_state;\n+\tif (cast_function.init_local_state) {\n+\t\tlocal_state = cast_function.init_local_state(*input.context);\n+\t}\n+\tCastParameters parameters(cast_function.cast_data.get(), strict, error_message, local_state.get());\n \treturn cast_function.function(source, result, count, parameters);\n }\n \ndiff --git a/src/execution/expression_executor/execute_cast.cpp b/src/execution/expression_executor/execute_cast.cpp\nindex 2450b0156fc7..c370736d648f 100644\n--- a/src/execution/expression_executor/execute_cast.cpp\n+++ b/src/execution/expression_executor/execute_cast.cpp\n@@ -1,19 +1,25 @@\n #include \"duckdb/common/vector_operations/vector_operations.hpp\"\n #include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/function/scalar_function.hpp\"\n #include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n \n namespace duckdb {\n \n unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const BoundCastExpression &expr,\n                                                                 ExpressionExecutorState &root) {\n-\tauto result = make_unique<ExpressionState>(expr, root);\n+\tauto result = make_unique<ExecuteFunctionState>(expr, root);\n \tresult->AddChild(expr.child.get());\n \tresult->Finalize();\n-\treturn result;\n+\tif (expr.bound_cast.init_local_state) {\n+\t\tresult->local_state = expr.bound_cast.init_local_state(root.executor->GetContext());\n+\t}\n+\treturn std::move(result);\n }\n \n void ExpressionExecutor::Execute(const BoundCastExpression &expr, ExpressionState *state, const SelectionVector *sel,\n                                  idx_t count, Vector &result) {\n+\tauto lstate = ExecuteFunctionState::GetFunctionState(*state);\n+\n \t// resolve the child\n \tstate->intermediate_chunk.Reset();\n \n@@ -23,12 +29,12 @@ void ExpressionExecutor::Execute(const BoundCastExpression &expr, ExpressionStat\n \tExecute(*expr.child, child_state, sel, count, child);\n \tif (expr.try_cast) {\n \t\tstring error_message;\n-\t\tCastParameters parameters(expr.bound_cast.cast_data.get(), false, &error_message);\n+\t\tCastParameters parameters(expr.bound_cast.cast_data.get(), false, &error_message, lstate);\n \t\texpr.bound_cast.function(child, result, count, parameters);\n \t} else {\n \t\t// cast it to the type specified by the cast expression\n \t\tD_ASSERT(result.GetType() == expr.return_type);\n-\t\tCastParameters parameters(expr.bound_cast.cast_data.get(), false, nullptr);\n+\t\tCastParameters parameters(expr.bound_cast.cast_data.get(), false, nullptr, lstate);\n \t\texpr.bound_cast.function(child, result, count, parameters);\n \t}\n }\ndiff --git a/src/execution/operator/persistent/base_csv_reader.cpp b/src/execution/operator/persistent/base_csv_reader.cpp\nindex 0e055e50c716..a3a7d67c5d09 100644\n--- a/src/execution/operator/persistent/base_csv_reader.cpp\n+++ b/src/execution/operator/persistent/base_csv_reader.cpp\n@@ -330,7 +330,9 @@ bool BaseCSVReader::Flush(DataChunk &insert_chunk, bool try_add_line) {\n \t\t\t// target type is varchar: no need to convert\n \t\t\t// just test that all strings are valid utf-8 strings\n \t\t\tVerifyUTF8(col_idx);\n-\t\t\tinsert_chunk.data[insert_idx].Reference(parse_chunk.data[col_idx]);\n+\t\t\t// reinterpret rather than reference so we can deal with user-defined types\n+\t\t\tinsert_chunk.data[insert_idx].Reinterpret(parse_chunk.data[col_idx]);\n+\n \t\t} else {\n \t\t\tstring error_message;\n \t\t\tbool success;\ndiff --git a/src/function/cast/default_casts.cpp b/src/function/cast/default_casts.cpp\nindex b243b0677c9b..f31dd48a7580 100644\n--- a/src/function/cast/default_casts.cpp\n+++ b/src/function/cast/default_casts.cpp\n@@ -1,13 +1,14 @@\n #include \"duckdb/function/cast/default_casts.hpp\"\n+\n+#include \"duckdb/common/likely.hpp\"\n+#include \"duckdb/common/limits.hpp\"\n #include \"duckdb/common/operator/cast_operators.hpp\"\n-#include \"duckdb/function/cast/vector_cast_helpers.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/common/types/cast_helpers.hpp\"\n #include \"duckdb/common/types/chunk_collection.hpp\"\n-#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n #include \"duckdb/common/types/null_value.hpp\"\n-#include \"duckdb/common/string_util.hpp\"\n-#include \"duckdb/common/likely.hpp\"\n-#include \"duckdb/common/limits.hpp\"\n+#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n+#include \"duckdb/function/cast/vector_cast_helpers.hpp\"\n \n namespace duckdb {\n \n@@ -17,12 +18,13 @@ BindCastInfo::~BindCastInfo() {\n BoundCastData::~BoundCastData() {\n }\n \n-BoundCastInfo::BoundCastInfo(cast_function_t function_p, unique_ptr<BoundCastData> cast_data_p)\n-    : function(function_p), cast_data(std::move(cast_data_p)) {\n+BoundCastInfo::BoundCastInfo(cast_function_t function_p, unique_ptr<BoundCastData> cast_data_p,\n+                             init_cast_local_state_t init_local_state_p)\n+    : function(function_p), init_local_state(init_local_state_p), cast_data(std::move(cast_data_p)) {\n }\n \n BoundCastInfo BoundCastInfo::Copy() const {\n-\treturn BoundCastInfo(function, cast_data ? cast_data->Copy() : nullptr);\n+\treturn BoundCastInfo(function, cast_data ? cast_data->Copy() : nullptr, init_local_state);\n }\n \n bool DefaultCasts::NopCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {\n@@ -117,7 +119,6 @@ BoundCastInfo DefaultCasts::GetDefaultCastFunction(BindCastInput &input, const L\n \t\treturn TimestampSecCastSwitch(input, source, target);\n \tcase LogicalTypeId::INTERVAL:\n \t\treturn IntervalCastSwitch(input, source, target);\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR:\n \t\treturn StringCastSwitch(input, source, target);\n \tcase LogicalTypeId::BLOB:\ndiff --git a/src/function/cast/enum_casts.cpp b/src/function/cast/enum_casts.cpp\nindex bb8381d84eea..749c89406701 100644\n--- a/src/function/cast/enum_casts.cpp\n+++ b/src/function/cast/enum_casts.cpp\n@@ -140,7 +140,6 @@ BoundCastInfo DefaultCasts::EnumCastSwitch(BindCastInput &input, const LogicalTy\n \t\t\tthrow InternalException(\"ENUM can only have unsigned integers (except UINT64) as physical types\");\n \t\t}\n \t}\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR:\n \t\tswitch (enum_physical_type) {\n \t\tcase PhysicalType::UINT8:\ndiff --git a/src/function/cast/list_casts.cpp b/src/function/cast/list_casts.cpp\nindex 9b6b964f9170..e6d963c74ced 100644\n--- a/src/function/cast/list_casts.cpp\n+++ b/src/function/cast/list_casts.cpp\n@@ -118,7 +118,6 @@ BoundCastInfo DefaultCasts::ListCastSwitch(BindCastInput &input, const LogicalTy\n \tcase LogicalTypeId::LIST:\n \t\treturn BoundCastInfo(ListCast::ListToListCast, ListBoundCastData::BindListToListCast(input, source, target));\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\treturn BoundCastInfo(ListToVarcharCast, ListBoundCastData::BindListToListCast(\n \t\t                                            input, source, LogicalType::LIST(LogicalType::VARCHAR)));\n \tdefault:\ndiff --git a/src/function/cast/map_cast.cpp b/src/function/cast/map_cast.cpp\nindex 65fa79f8b6e8..11344652062d 100644\n--- a/src/function/cast/map_cast.cpp\n+++ b/src/function/cast/map_cast.cpp\n@@ -79,7 +79,6 @@ BoundCastInfo DefaultCasts::MapCastSwitch(BindCastInput &input, const LogicalTyp\n \tswitch (target.id()) {\n \tcase LogicalTypeId::MAP:\n \t\treturn BoundCastInfo(ListCast::ListToListCast, ListBoundCastData::BindListToListCast(input, source, target));\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR: {\n \t\tauto varchar_type = LogicalType::MAP(LogicalType::VARCHAR, LogicalType::VARCHAR);\n \t\treturn BoundCastInfo(MapToVarcharCast, ListBoundCastData::BindListToListCast(input, source, varchar_type));\ndiff --git a/src/function/cast/numeric_casts.cpp b/src/function/cast/numeric_casts.cpp\nindex d2392cc33365..cd705a60909e 100644\n--- a/src/function/cast/numeric_casts.cpp\n+++ b/src/function/cast/numeric_casts.cpp\n@@ -35,7 +35,6 @@ static BoundCastInfo InternalNumericCastSwitch(const LogicalType &source, const\n \t\treturn BoundCastInfo(&VectorCastHelpers::TryCastLoop<SRC, double, duckdb::NumericTryCast>);\n \tcase LogicalTypeId::DECIMAL:\n \t\treturn BoundCastInfo(&VectorCastHelpers::ToDecimalCast<SRC>);\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR:\n \t\treturn BoundCastInfo(&VectorCastHelpers::StringCast<SRC, duckdb::StringCast>);\n \tdefault:\ndiff --git a/src/function/cast/string_cast.cpp b/src/function/cast/string_cast.cpp\nindex a372e6979f09..2b56bcd2ea35 100644\n--- a/src/function/cast/string_cast.cpp\n+++ b/src/function/cast/string_cast.cpp\n@@ -366,7 +366,6 @@ BoundCastInfo DefaultCasts::StringCastSwitch(BindCastInput &input, const Logical\n \tcase LogicalTypeId::SQLNULL:\n \t\treturn &DefaultCasts::TryVectorNullCast;\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\treturn &DefaultCasts::ReinterpretCast;\n \tcase LogicalTypeId::LIST:\n \t\t// the second argument allows for a secondary casting function to be passed in the CastParameters\ndiff --git a/src/function/cast/struct_cast.cpp b/src/function/cast/struct_cast.cpp\nindex 1370c623a450..55998271228e 100644\n--- a/src/function/cast/struct_cast.cpp\n+++ b/src/function/cast/struct_cast.cpp\n@@ -122,7 +122,6 @@ BoundCastInfo DefaultCasts::StructCastSwitch(BindCastInput &input, const Logical\n \tswitch (target.id()) {\n \tcase LogicalTypeId::STRUCT:\n \t\treturn BoundCastInfo(StructToStructCast, StructBoundCastData::BindStructToStructCast(input, source, target));\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR: {\n \t\t// bind a cast in which we convert all child entries to VARCHAR entries\n \t\tauto &struct_children = StructType::GetChildTypes(source);\ndiff --git a/src/function/cast/time_casts.cpp b/src/function/cast/time_casts.cpp\nindex 9088c748f558..05ca7174c017 100644\n--- a/src/function/cast/time_casts.cpp\n+++ b/src/function/cast/time_casts.cpp\n@@ -7,7 +7,6 @@ BoundCastInfo DefaultCasts::DateCastSwitch(BindCastInput &input, const LogicalTy\n \t// now switch on the result type\n \tswitch (target.id()) {\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\t// date to varchar\n \t\treturn BoundCastInfo(&VectorCastHelpers::StringCast<date_t, duckdb::StringCast>);\n \tcase LogicalTypeId::TIMESTAMP:\n@@ -29,7 +28,6 @@ BoundCastInfo DefaultCasts::TimeCastSwitch(BindCastInput &input, const LogicalTy\n \t// now switch on the result type\n \tswitch (target.id()) {\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\t// time to varchar\n \t\treturn BoundCastInfo(&VectorCastHelpers::StringCast<dtime_t, duckdb::StringCast>);\n \tcase LogicalTypeId::TIME_TZ:\n@@ -45,7 +43,6 @@ BoundCastInfo DefaultCasts::TimeTzCastSwitch(BindCastInput &input, const Logical\n \t// now switch on the result type\n \tswitch (target.id()) {\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\t// time with time zone to varchar\n \t\treturn BoundCastInfo(&VectorCastHelpers::StringCast<dtime_t, duckdb::StringCastTZ>);\n \tcase LogicalTypeId::TIME:\n@@ -61,7 +58,6 @@ BoundCastInfo DefaultCasts::TimestampCastSwitch(BindCastInput &input, const Logi\n \t// now switch on the result type\n \tswitch (target.id()) {\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\t// timestamp to varchar\n \t\treturn BoundCastInfo(&VectorCastHelpers::StringCast<timestamp_t, duckdb::StringCast>);\n \tcase LogicalTypeId::DATE:\n@@ -96,7 +92,6 @@ BoundCastInfo DefaultCasts::TimestampTzCastSwitch(BindCastInput &input, const Lo\n \t// now switch on the result type\n \tswitch (target.id()) {\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\t// timestamp with time zone to varchar\n \t\treturn BoundCastInfo(&VectorCastHelpers::StringCast<timestamp_t, duckdb::StringCastTZ>);\n \tcase LogicalTypeId::TIME_TZ:\n@@ -116,7 +111,6 @@ BoundCastInfo DefaultCasts::TimestampNsCastSwitch(BindCastInput &input, const Lo\n \t// now switch on the result type\n \tswitch (target.id()) {\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\t// timestamp (ns) to varchar\n \t\treturn BoundCastInfo(&VectorCastHelpers::StringCast<timestamp_t, duckdb::CastFromTimestampNS>);\n \tcase LogicalTypeId::TIMESTAMP:\n@@ -133,7 +127,6 @@ BoundCastInfo DefaultCasts::TimestampMsCastSwitch(BindCastInput &input, const Lo\n \t// now switch on the result type\n \tswitch (target.id()) {\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\t// timestamp (ms) to varchar\n \t\treturn BoundCastInfo(&VectorCastHelpers::StringCast<timestamp_t, duckdb::CastFromTimestampMS>);\n \tcase LogicalTypeId::TIMESTAMP:\n@@ -150,7 +143,6 @@ BoundCastInfo DefaultCasts::TimestampSecCastSwitch(BindCastInput &input, const L\n \t// now switch on the result type\n \tswitch (target.id()) {\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\t// timestamp (sec) to varchar\n \t\treturn BoundCastInfo(&VectorCastHelpers::StringCast<timestamp_t, duckdb::CastFromTimestampSec>);\n \tcase LogicalTypeId::TIMESTAMP:\n@@ -166,7 +158,6 @@ BoundCastInfo DefaultCasts::IntervalCastSwitch(BindCastInput &input, const Logic\n \t// now switch on the result type\n \tswitch (target.id()) {\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\t// time to varchar\n \t\treturn BoundCastInfo(&VectorCastHelpers::StringCast<interval_t, duckdb::StringCast>);\n \tdefault:\ndiff --git a/src/function/cast/union_casts.cpp b/src/function/cast/union_casts.cpp\nindex 5ba47ca19a5d..ee412771aef8 100644\n--- a/src/function/cast/union_casts.cpp\n+++ b/src/function/cast/union_casts.cpp\n@@ -1,6 +1,7 @@\n-#include \"duckdb/function/cast/default_casts.hpp\"\n #include \"duckdb/function/cast/cast_function_set.hpp\"\n+#include \"duckdb/function/cast/default_casts.hpp\"\n #include \"duckdb/function/cast/vector_cast_helpers.hpp\"\n+\n #include <algorithm> // for std::sort\n \n namespace duckdb {\n@@ -331,7 +332,6 @@ static bool UnionToVarcharCast(Vector &source, Vector &result, idx_t count, Cast\n BoundCastInfo DefaultCasts::UnionCastSwitch(BindCastInput &input, const LogicalType &source,\n                                             const LogicalType &target) {\n \tswitch (target.id()) {\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR: {\n \t\t// bind a cast in which we convert all members to VARCHAR first\n \t\tchild_list_t<LogicalType> varchar_members;\ndiff --git a/src/function/cast/uuid_casts.cpp b/src/function/cast/uuid_casts.cpp\nindex 24afdf14bf9d..c2267b51e32e 100644\n--- a/src/function/cast/uuid_casts.cpp\n+++ b/src/function/cast/uuid_casts.cpp\n@@ -8,7 +8,6 @@ BoundCastInfo DefaultCasts::UUIDCastSwitch(BindCastInput &input, const LogicalTy\n \t// now switch on the result type\n \tswitch (target.id()) {\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \t\t// uuid to varchar\n \t\treturn BoundCastInfo(&VectorCastHelpers::StringCast<hugeint_t, duckdb::CastFromUUID>);\n \tdefault:\ndiff --git a/src/function/cast_rules.cpp b/src/function/cast_rules.cpp\nindex 01545a966a83..75d5c3085936 100644\n--- a/src/function/cast_rules.cpp\n+++ b/src/function/cast_rules.cpp\n@@ -215,13 +215,8 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\t// Implicit cast not allowed from BLOB to VARCHAR\n \t\treturn -1;\n \t}\n-\tif ((from.id() == LogicalTypeId::VARCHAR && to.id() == LogicalTypeId::JSON) ||\n-\t    (from.id() == LogicalTypeId::JSON && to.id() == LogicalTypeId::VARCHAR)) {\n-\t\t// Virtually no cost, just a different tag\n-\t\treturn 1;\n-\t}\n-\tif (to.id() == LogicalTypeId::VARCHAR || to.id() == LogicalTypeId::JSON) {\n-\t\t// everything can be cast to VARCHAR/JSON, but this cast has a high cost\n+\tif (to.id() == LogicalTypeId::VARCHAR) {\n+\t\t// everything can be cast to VARCHAR, but this cast has a high cost\n \t\treturn TargetTypeCost(to);\n \t}\n \tif (from.id() == LogicalTypeId::LIST && to.id() == LogicalTypeId::LIST) {\ndiff --git a/src/function/table/arrow_conversion.cpp b/src/function/table/arrow_conversion.cpp\nindex 43d4e2a468ab..e1af62972f32 100644\n--- a/src/function/table/arrow_conversion.cpp\n+++ b/src/function/table/arrow_conversion.cpp\n@@ -369,7 +369,6 @@ void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanLocalState\n \t\tDirectConversion(vector, array, scan_state, nested_offset);\n \t\tbreak;\n \t}\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR: {\n \t\tauto original_type = arrow_convert_data[col_idx]->variable_sz_type[arrow_convert_idx.first++];\n \t\tauto cdata = (char *)array.buffers[2];\ndiff --git a/src/function/table/copy_csv.cpp b/src/function/table/copy_csv.cpp\nindex 7962172a20a4..56b3e35f2306 100644\n--- a/src/function/table/copy_csv.cpp\n+++ b/src/function/table/copy_csv.cpp\n@@ -202,7 +202,7 @@ static void WriteQuotedString(Serializer &serializer, WriteCSVData &csv_data, co\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t} else {\n+\t\t} else if (options.quote.length() != 0) {\n \t\t\t// complex CSV\n \t\t\t// check for quote or escape separately\n \t\t\tif (ContainsFun::Find((const unsigned char *)str, len, (const unsigned char *)options.quote.c_str(),\n@@ -316,8 +316,8 @@ static void WriteCSVSink(ExecutionContext &context, FunctionData &bind_data, Glo\n \tcast_chunk.SetCardinality(input);\n \tfor (idx_t col_idx = 0; col_idx < input.ColumnCount(); col_idx++) {\n \t\tif (csv_data.sql_types[col_idx].id() == LogicalTypeId::VARCHAR) {\n-\t\t\t// VARCHAR, just create a reference\n-\t\t\tcast_chunk.data[col_idx].Reference(input.data[col_idx]);\n+\t\t\t// VARCHAR, just reinterpret (cannot reference, because LogicalTypeId::VARCHAR is used by the JSON type too)\n+\t\t\tcast_chunk.data[col_idx].Reinterpret(input.data[col_idx]);\n \t\t} else if (options.has_format[LogicalTypeId::DATE] && csv_data.sql_types[col_idx].id() == LogicalTypeId::DATE) {\n \t\t\t// use the date format to cast the chunk\n \t\t\tcsv_data.options.write_date_format[LogicalTypeId::DATE].ConvertDateVector(\ndiff --git a/src/function/table/read_csv.cpp b/src/function/table/read_csv.cpp\nindex 4723b660a7ba..82ad959bf5cc 100644\n--- a/src/function/table/read_csv.cpp\n+++ b/src/function/table/read_csv.cpp\n@@ -50,6 +50,7 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, TableFunctio\n \tif (!config.options.enable_external_access) {\n \t\tthrow PermissionException(\"Scanning CSV files is disabled through configuration\");\n \t}\n+\n \tauto result = make_unique<ReadCSVData>();\n \tauto &options = result->options;\n \n@@ -84,7 +85,7 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, TableFunctio\n \t\t\t\tif (val.type().id() != LogicalTypeId::VARCHAR) {\n \t\t\t\t\tthrow BinderException(\"read_csv requires a type specification as string\");\n \t\t\t\t}\n-\t\t\t\treturn_types.emplace_back(TransformStringToLogicalType(StringValue::Get(val)));\n+\t\t\t\treturn_types.emplace_back(TransformStringToLogicalType(StringValue::Get(val), context));\n \t\t\t}\n \t\t\tif (names.empty()) {\n \t\t\t\tthrow BinderException(\"read_csv requires at least a single column as input!\");\ndiff --git a/src/include/duckdb.h b/src/include/duckdb.h\nindex bf236a0d85f9..f51f96f6b16a 100644\n--- a/src/include/duckdb.h\n+++ b/src/include/duckdb.h\n@@ -119,8 +119,6 @@ typedef enum DUCKDB_TYPE {\n \tDUCKDB_TYPE_MAP,\n \t// duckdb_hugeint\n \tDUCKDB_TYPE_UUID,\n-\t// const char*\n-\tDUCKDB_TYPE_JSON,\n \t// union type, only useful as logical type\n \tDUCKDB_TYPE_UNION,\n } duckdb_type;\ndiff --git a/src/include/duckdb/common/allocator.hpp b/src/include/duckdb/common/allocator.hpp\nindex d349fab09e26..cda7c804578f 100644\n--- a/src/include/duckdb/common/allocator.hpp\n+++ b/src/include/duckdb/common/allocator.hpp\n@@ -120,7 +120,7 @@ void DeleteArray(T *ptr, idx_t size) {\n }\n \n template <typename T, typename... ARGS>\n-T *AllocateObject(ARGS &&...args) {\n+T *AllocateObject(ARGS &&... args) {\n \tauto data = Allocator::DefaultAllocator().AllocateData(sizeof(T));\n \treturn new (data) T(std::forward<ARGS>(args)...);\n }\ndiff --git a/src/include/duckdb/common/field_writer.hpp b/src/include/duckdb/common/field_writer.hpp\nindex 6fc55886d6cd..e9cae65d06bf 100644\n--- a/src/include/duckdb/common/field_writer.hpp\n+++ b/src/include/duckdb/common/field_writer.hpp\n@@ -271,7 +271,7 @@ class FieldReader {\n \t}\n \n \ttemplate <class T, typename... ARGS>\n-\tunique_ptr<T> ReadOptional(unique_ptr<T> default_value, ARGS &&...args) {\n+\tunique_ptr<T> ReadOptional(unique_ptr<T> default_value, ARGS &&... args) {\n \t\tif (field_count >= max_field_count) {\n \t\t\t// field is not there, read the default value\n \t\t\treturn default_value;\n@@ -293,7 +293,7 @@ class FieldReader {\n \t}\n \n \ttemplate <class T, class RETURN_TYPE = unique_ptr<T>, typename... ARGS>\n-\tRETURN_TYPE ReadSerializable(RETURN_TYPE default_value, ARGS &&...args) {\n+\tRETURN_TYPE ReadSerializable(RETURN_TYPE default_value, ARGS &&... args) {\n \t\tif (field_count >= max_field_count) {\n \t\t\t// field is not there, read the default value\n \t\t\treturn default_value;\n@@ -315,7 +315,7 @@ class FieldReader {\n \t}\n \n \ttemplate <class T, class RETURN_TYPE = unique_ptr<T>, typename... ARGS>\n-\tRETURN_TYPE ReadRequiredSerializable(ARGS &&...args) {\n+\tRETURN_TYPE ReadRequiredSerializable(ARGS &&... args) {\n \t\tif (field_count >= max_field_count) {\n \t\t\t// field is not there, throw an exception\n \t\t\tthrow SerializationException(\"Attempting to read mandatory field, but field is missing\");\n@@ -326,7 +326,7 @@ class FieldReader {\n \t}\n \n \ttemplate <class T, class RETURN_TYPE = unique_ptr<T>, typename... ARGS>\n-\tvector<RETURN_TYPE> ReadRequiredSerializableList(ARGS &&...args) {\n+\tvector<RETURN_TYPE> ReadRequiredSerializableList(ARGS &&... args) {\n \t\tif (field_count >= max_field_count) {\n \t\t\t// field is not there, throw an exception\n \t\t\tthrow SerializationException(\"Attempting to read mandatory field, but field is missing\");\ndiff --git a/src/include/duckdb/common/file_opener.hpp b/src/include/duckdb/common/file_opener.hpp\nindex 767ca9703dc7..a56f47bfcf38 100644\n--- a/src/include/duckdb/common/file_opener.hpp\n+++ b/src/include/duckdb/common/file_opener.hpp\n@@ -9,6 +9,7 @@\n #pragma once\n \n #include \"duckdb/common/string.hpp\"\n+#include \"duckdb/common/winapi.hpp\"\n \n namespace duckdb {\n \n@@ -23,7 +24,7 @@ class FileOpener {\n \tvirtual bool TryGetCurrentSetting(const string &key, Value &result) = 0;\n \tvirtual ClientContext *TryGetClientContext() = 0;\n \n-\tstatic FileOpener *Get(ClientContext &context);\n+\tDUCKDB_API static FileOpener *Get(ClientContext &context);\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/common/serializer.hpp b/src/include/duckdb/common/serializer.hpp\nindex d6b1ae3e01ab..87ff24d69334 100644\n--- a/src/include/duckdb/common/serializer.hpp\n+++ b/src/include/duckdb/common/serializer.hpp\n@@ -119,7 +119,7 @@ class Deserializer {\n \t}\n \n \ttemplate <class T, typename... ARGS>\n-\tvoid ReadList(vector<unique_ptr<T>> &list, ARGS &&...args) {\n+\tvoid ReadList(vector<unique_ptr<T>> &list, ARGS &&... args) {\n \t\tauto select_count = Read<uint32_t>();\n \t\tfor (uint32_t i = 0; i < select_count; i++) {\n \t\t\tauto child = T::Deserialize(*this, std::forward<ARGS>(args)...);\n@@ -128,7 +128,7 @@ class Deserializer {\n \t}\n \n \ttemplate <class T, class RETURN_TYPE = T, typename... ARGS>\n-\tunique_ptr<RETURN_TYPE> ReadOptional(ARGS &&...args) {\n+\tunique_ptr<RETURN_TYPE> ReadOptional(ARGS &&... args) {\n \t\tauto has_entry = Read<bool>();\n \t\tif (has_entry) {\n \t\t\treturn T::Deserialize(*this, std::forward<ARGS>(args)...);\ndiff --git a/src/include/duckdb/common/types.hpp b/src/include/duckdb/common/types.hpp\nindex 5bc4765e5951..6269f032a3eb 100644\n--- a/src/include/duckdb/common/types.hpp\n+++ b/src/include/duckdb/common/types.hpp\n@@ -257,7 +257,6 @@ enum class LogicalTypeId : uint8_t {\n \tUBIGINT = 31,\n \tTIMESTAMP_TZ = 32,\n \tTIME_TZ = 34,\n-\tJSON = 35,\n \n \tHUGEINT = 50,\n \tPOINTER = 51,\n@@ -398,7 +397,6 @@ struct LogicalType {\n \tstatic constexpr const LogicalTypeId TABLE = LogicalTypeId::TABLE;\n \tstatic constexpr const LogicalTypeId LAMBDA = LogicalTypeId::LAMBDA;\n \tstatic constexpr const LogicalTypeId INVALID = LogicalTypeId::INVALID;\n-\tstatic constexpr const LogicalTypeId JSON = LogicalTypeId::JSON;\n \tstatic constexpr const LogicalTypeId ROW_TYPE = LogicalTypeId::BIGINT;\n \n \t// explicitly allowing these functions to be capitalized to be in-line with the remaining functions\n@@ -481,6 +479,8 @@ DUCKDB_API LogicalTypeId TransformStringToLogicalTypeId(const string &str);\n \n DUCKDB_API LogicalType TransformStringToLogicalType(const string &str);\n \n+DUCKDB_API LogicalType TransformStringToLogicalType(const string &str, ClientContext &context);\n+\n //! The PhysicalType used by the row identifiers column\n extern const PhysicalType ROW_TYPE;\n \ndiff --git a/src/include/duckdb/common/types/value.hpp b/src/include/duckdb/common/types/value.hpp\nindex 153c1c1728f6..aede0910bc7d 100644\n--- a/src/include/duckdb/common/types/value.hpp\n+++ b/src/include/duckdb/common/types/value.hpp\n@@ -131,10 +131,6 @@ class Value {\n \t                                  int32_t micros);\n \tDUCKDB_API static Value INTERVAL(int32_t months, int32_t days, int64_t micros);\n \tDUCKDB_API static Value INTERVAL(interval_t interval);\n-\t//! Creates a JSON Value\n-\tDUCKDB_API static Value JSON(const char *val);\n-\tDUCKDB_API static Value JSON(string_t val);\n-\tDUCKDB_API static Value JSON(string val);\n \n \t// Create a enum Value from a specified uint value\n \tDUCKDB_API static Value ENUM(uint64_t value, const LogicalType &original_type);\ndiff --git a/src/include/duckdb/execution/expression_executor_state.hpp b/src/include/duckdb/execution/expression_executor_state.hpp\nindex 249f83aadac3..34ed4314b9b4 100644\n--- a/src/include/duckdb/execution/expression_executor_state.hpp\n+++ b/src/include/duckdb/execution/expression_executor_state.hpp\n@@ -37,7 +37,7 @@ struct ExpressionState {\n \tvoid Finalize();\n \tAllocator &GetAllocator();\n \tbool HasContext();\n-\tClientContext &GetContext();\n+\tDUCKDB_API ClientContext &GetContext();\n \n \tvoid Verify(ExpressionExecutorState &root);\n };\n@@ -49,7 +49,7 @@ struct ExecuteFunctionState : public ExpressionState {\n \tunique_ptr<FunctionLocalState> local_state;\n \n public:\n-\tstatic FunctionLocalState *GetFunctionState(ExpressionState &state) {\n+\tDUCKDB_API static FunctionLocalState *GetFunctionState(ExpressionState &state) {\n \t\treturn ((ExecuteFunctionState &)state).local_state.get();\n \t}\n };\ndiff --git a/src/include/duckdb/function/cast/default_casts.hpp b/src/include/duckdb/function/cast/default_casts.hpp\nindex 2ad86fb63a55..1b26c35b982f 100644\n--- a/src/include/duckdb/function/cast/default_casts.hpp\n+++ b/src/include/duckdb/function/cast/default_casts.hpp\n@@ -12,7 +12,9 @@\n #include \"duckdb/common/types/vector.hpp\"\n \n namespace duckdb {\n+\n class CastFunctionSet;\n+struct FunctionLocalState;\n \n //! Extra data that can be attached to a bind function of a cast, and is available during binding\n struct BindCastInfo {\n@@ -29,8 +31,8 @@ struct BoundCastData {\n struct CastParameters {\n \tCastParameters() {\n \t}\n-\tCastParameters(BoundCastData *cast_data, bool strict, string *error_message)\n-\t    : cast_data(cast_data), strict(strict), error_message(error_message) {\n+\tCastParameters(BoundCastData *cast_data, bool strict, string *error_message, FunctionLocalState *local_state)\n+\t    : cast_data(cast_data), strict(strict), error_message(error_message), local_state(local_state) {\n \t}\n \tCastParameters(CastParameters &parent, BoundCastData *cast_data = nullptr)\n \t    : cast_data(cast_data), strict(parent.strict), error_message(parent.error_message) {\n@@ -42,16 +44,20 @@ struct CastParameters {\n \tbool strict = false;\n \t// out: error message in case cast has failed\n \tstring *error_message = nullptr;\n+\t//! Local state\n+\tFunctionLocalState *local_state = nullptr;\n };\n \n typedef bool (*cast_function_t)(Vector &source, Vector &result, idx_t count, CastParameters &parameters);\n+typedef unique_ptr<FunctionLocalState> (*init_cast_local_state_t)(ClientContext &context);\n \n struct BoundCastInfo {\n \tDUCKDB_API\n-\tBoundCastInfo(cast_function_t function,\n-\t              unique_ptr<BoundCastData> cast_data = nullptr); // NOLINT: allow explicit cast from cast_function_t\n-\n+\tBoundCastInfo(\n+\t    cast_function_t function, unique_ptr<BoundCastData> cast_data = nullptr,\n+\t    init_cast_local_state_t init_local_state = nullptr); // NOLINT: allow explicit cast from cast_function_t\n \tcast_function_t function;\n+\tinit_cast_local_state_t init_local_state;\n \tunique_ptr<BoundCastData> cast_data;\n \n public:\n@@ -126,12 +132,12 @@ struct MapBoundCastData : public BoundCastData {\n };\n \n struct DefaultCasts {\n-\tstatic BoundCastInfo GetDefaultCastFunction(BindCastInput &input, const LogicalType &source,\n-\t                                            const LogicalType &target);\n+\tDUCKDB_API static BoundCastInfo GetDefaultCastFunction(BindCastInput &input, const LogicalType &source,\n+\t                                                       const LogicalType &target);\n \n-\tstatic bool NopCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters);\n-\tstatic bool TryVectorNullCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters);\n-\tstatic bool ReinterpretCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters);\n+\tDUCKDB_API static bool NopCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters);\n+\tDUCKDB_API static bool TryVectorNullCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters);\n+\tDUCKDB_API static bool ReinterpretCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters);\n \n private:\n \tstatic BoundCastInfo BlobCastSwitch(BindCastInput &input, const LogicalType &source, const LogicalType &target);\ndiff --git a/src/include/duckdb/parallel/task_scheduler.hpp b/src/include/duckdb/parallel/task_scheduler.hpp\nindex 7a6df6cbaa2b..e812d012a01f 100644\n--- a/src/include/duckdb/parallel/task_scheduler.hpp\n+++ b/src/include/duckdb/parallel/task_scheduler.hpp\n@@ -42,8 +42,8 @@ class TaskScheduler {\n \tTaskScheduler(DatabaseInstance &db);\n \t~TaskScheduler();\n \n-\tstatic TaskScheduler &GetScheduler(ClientContext &context);\n-\tstatic TaskScheduler &GetScheduler(DatabaseInstance &db);\n+\tDUCKDB_API static TaskScheduler &GetScheduler(ClientContext &context);\n+\tDUCKDB_API static TaskScheduler &GetScheduler(DatabaseInstance &db);\n \n \tunique_ptr<ProducerToken> CreateProducer();\n \t//! Schedule a task to be executed by the task scheduler\n@@ -62,7 +62,7 @@ class TaskScheduler {\n \t//! The main thread will also be used for execution\n \tvoid SetThreads(int32_t n);\n \t//! Returns the number of threads\n-\tint32_t NumberOfThreads();\n+\tDUCKDB_API int32_t NumberOfThreads();\n \n \t//! Send signals to n threads, signalling for them to wake up and attempt to execute a task\n \tvoid Signal(idx_t n);\ndiff --git a/src/include/duckdb/storage/arena_allocator.hpp b/src/include/duckdb/storage/arena_allocator.hpp\nindex 29541631307c..2a58d2ac318f 100644\n--- a/src/include/duckdb/storage/arena_allocator.hpp\n+++ b/src/include/duckdb/storage/arena_allocator.hpp\n@@ -31,16 +31,21 @@ class ArenaAllocator {\n \tDUCKDB_API ArenaAllocator(Allocator &allocator, idx_t initial_capacity = ARENA_ALLOCATOR_INITIAL_CAPACITY);\n \tDUCKDB_API ~ArenaAllocator();\n \n-\tdata_ptr_t Allocate(idx_t size);\n+\tDUCKDB_API data_ptr_t Allocate(idx_t size);\n+\tDUCKDB_API data_ptr_t Reallocate(data_ptr_t pointer, idx_t old_size, idx_t size);\n+\n+\tDUCKDB_API data_ptr_t AllocateAligned(idx_t size);\n+\tDUCKDB_API data_ptr_t ReallocateAligned(data_ptr_t pointer, idx_t old_size, idx_t size);\n+\n \t//! Resets the current head and destroys all previous arena chunks\n-\tvoid Reset();\n-\tvoid Destroy();\n-\tvoid Move(ArenaAllocator &allocator);\n+\tDUCKDB_API void Reset();\n+\tDUCKDB_API void Destroy();\n+\tDUCKDB_API void Move(ArenaAllocator &allocator);\n \n-\tArenaChunk *GetHead();\n-\tArenaChunk *GetTail();\n+\tDUCKDB_API ArenaChunk *GetHead();\n+\tDUCKDB_API ArenaChunk *GetTail();\n \n-\tbool IsEmpty();\n+\tDUCKDB_API bool IsEmpty();\n \n private:\n \t//! Internal allocator that is used by the arena allocator\ndiff --git a/src/include/duckdb/storage/buffer_manager.hpp b/src/include/duckdb/storage/buffer_manager.hpp\nindex 80814cd802e8..329650f8833f 100644\n--- a/src/include/duckdb/storage/buffer_manager.hpp\n+++ b/src/include/duckdb/storage/buffer_manager.hpp\n@@ -57,7 +57,7 @@ class BufferManager {\n \t//! blocks can be evicted\n \tvoid SetLimit(idx_t limit = (idx_t)-1);\n \n-\tstatic BufferManager &GetBufferManager(ClientContext &context);\n+\tDUCKDB_API static BufferManager &GetBufferManager(ClientContext &context);\n \tDUCKDB_API static BufferManager &GetBufferManager(DatabaseInstance &db);\n \tDUCKDB_API static BufferManager &GetBufferManager(AttachedDatabase &db);\n \ndiff --git a/src/main/capi/helper-c.cpp b/src/main/capi/helper-c.cpp\nindex 3aab134a9f74..8e29fadfb2ff 100644\n--- a/src/main/capi/helper-c.cpp\n+++ b/src/main/capi/helper-c.cpp\n@@ -36,8 +36,6 @@ LogicalTypeId ConvertCTypeToCPP(duckdb_type c_type) {\n \t\treturn LogicalTypeId::TIME;\n \tcase DUCKDB_TYPE_VARCHAR:\n \t\treturn LogicalTypeId::VARCHAR;\n-\tcase DUCKDB_TYPE_JSON:\n-\t\treturn LogicalTypeId::JSON;\n \tcase DUCKDB_TYPE_BLOB:\n \t\treturn LogicalTypeId::BLOB;\n \tcase DUCKDB_TYPE_INTERVAL:\n@@ -98,8 +96,6 @@ duckdb_type ConvertCPPTypeToC(const LogicalType &sql_type) {\n \t\treturn DUCKDB_TYPE_TIME;\n \tcase LogicalTypeId::VARCHAR:\n \t\treturn DUCKDB_TYPE_VARCHAR;\n-\tcase LogicalTypeId::JSON:\n-\t\treturn DUCKDB_TYPE_JSON;\n \tcase LogicalTypeId::BLOB:\n \t\treturn DUCKDB_TYPE_BLOB;\n \tcase LogicalTypeId::INTERVAL:\ndiff --git a/src/storage/arena_allocator.cpp b/src/storage/arena_allocator.cpp\nindex d4c6a270b19b..22ef86fce2bd 100644\n--- a/src/storage/arena_allocator.cpp\n+++ b/src/storage/arena_allocator.cpp\n@@ -1,4 +1,5 @@\n #include \"duckdb/storage/arena_allocator.hpp\"\n+\n #include \"duckdb/common/assert.hpp\"\n \n namespace duckdb {\n@@ -46,6 +47,35 @@ data_ptr_t ArenaAllocator::Allocate(idx_t len) {\n \treturn result;\n }\n \n+data_ptr_t ArenaAllocator::Reallocate(data_ptr_t pointer, idx_t old_size, idx_t size) {\n+\tD_ASSERT(head);\n+\tif (old_size == size) {\n+\t\t// nothing to do\n+\t\treturn pointer;\n+\t}\n+\n+\tauto head_ptr = head->data.get() + head->current_position;\n+\tint64_t diff = size - old_size;\n+\tif (pointer == head_ptr && (size < old_size || head->current_position + diff <= head->maximum_size)) {\n+\t\t// passed pointer is the head pointer, and the diff fits on the current chunk\n+\t\thead->current_position += diff;\n+\t\treturn pointer;\n+\t} else {\n+\t\t// allocate new memory\n+\t\tauto result = Allocate(size);\n+\t\tmemcpy(result, pointer, old_size);\n+\t\treturn result;\n+\t}\n+}\n+\n+data_ptr_t ArenaAllocator::AllocateAligned(idx_t size) {\n+\treturn Allocate(AlignValue<idx_t>(size));\n+}\n+\n+data_ptr_t ArenaAllocator::ReallocateAligned(data_ptr_t pointer, idx_t old_size, idx_t size) {\n+\treturn Reallocate(pointer, old_size, AlignValue<idx_t>(size));\n+}\n+\n void ArenaAllocator::Reset() {\n \n \tif (head) {\ndiff --git a/src/storage/storage_info.cpp b/src/storage/storage_info.cpp\nindex 81511306bc6a..8456cf4e32d3 100644\n--- a/src/storage/storage_info.cpp\n+++ b/src/storage/storage_info.cpp\n@@ -2,7 +2,7 @@\n \n namespace duckdb {\n \n-const uint64_t VERSION_NUMBER = 41;\n+const uint64_t VERSION_NUMBER = 42;\n \n struct StorageVersionInfo {\n \tconst char *version_name;\ndiff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp\nindex 3798a613b657..dc071a541c2c 100644\n--- a/tools/jdbc/src/jni/duckdb_java.cpp\n+++ b/tools/jdbc/src/jni/duckdb_java.cpp\n@@ -723,7 +723,6 @@ JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(\n \t\t\tvec.ReferenceAndSetType(string_vec);\n \t\t\t// fall through on purpose\n \t\t}\n-\t\tcase LogicalTypeId::JSON:\n \t\tcase LogicalTypeId::VARCHAR:\n \t\t\tvarlen_data = env->NewObjectArray(row_count, J_String, nullptr);\n \t\t\tfor (idx_t row_idx = 0; row_idx < row_count; row_idx++) {\ndiff --git a/tools/juliapkg/src/ctypes.jl b/tools/juliapkg/src/ctypes.jl\nindex ffa5ac6384c7..1ae5fe379886 100644\n--- a/tools/juliapkg/src/ctypes.jl\n+++ b/tools/juliapkg/src/ctypes.jl\n@@ -56,7 +56,6 @@ const DUCKDB_PENDING_ERROR = 2;\n     DUCKDB_TYPE_STRUCT\n     DUCKDB_TYPE_MAP\n     DUCKDB_TYPE_UUID\n-    DUCKDB_TYPE_JSON\n     DUCKDB_TYPE_UNION\n end\n \n@@ -175,7 +174,6 @@ INTERNAL_TYPE_MAP = Dict(\n     DUCKDB_TYPE_HUGEINT => duckdb_hugeint,\n     DUCKDB_TYPE_UUID => duckdb_hugeint,\n     DUCKDB_TYPE_VARCHAR => duckdb_string_t,\n-    DUCKDB_TYPE_JSON => duckdb_string_t,\n     DUCKDB_TYPE_BLOB => duckdb_string_t,\n     DUCKDB_TYPE_UUID => duckdb_hugeint,\n     DUCKDB_TYPE_LIST => duckdb_list_entry_t,\n@@ -207,7 +205,6 @@ JULIA_TYPE_MAP = Dict(\n     DUCKDB_TYPE_INTERVAL => Dates.CompoundPeriod,\n     DUCKDB_TYPE_UUID => UUID,\n     DUCKDB_TYPE_VARCHAR => String,\n-    DUCKDB_TYPE_JSON => String,\n     DUCKDB_TYPE_ENUM => String,\n     DUCKDB_TYPE_BLOB => Base.CodeUnits{UInt8, String},\n     DUCKDB_TYPE_MAP => Dict\ndiff --git a/tools/juliapkg/src/result.jl b/tools/juliapkg/src/result.jl\nindex ce8574c659e5..6e71cf1af35a 100644\n--- a/tools/juliapkg/src/result.jl\n+++ b/tools/juliapkg/src/result.jl\n@@ -466,7 +466,7 @@ end\n \n function get_conversion_function(logical_type::LogicalType)::Function\n     type = get_type_id(logical_type)\n-    if type == DUCKDB_TYPE_VARCHAR || type == DUCKDB_TYPE_JSON\n+    if type == DUCKDB_TYPE_VARCHAR\n         return convert_string\n     elseif type == DUCKDB_TYPE_BLOB\n         return convert_blob\n@@ -504,7 +504,7 @@ end\n \n function get_conversion_loop_function(logical_type::LogicalType)::Function\n     type = get_type_id(logical_type)\n-    if type == DUCKDB_TYPE_VARCHAR || type == DUCKDB_TYPE_BLOB || type == DUCKDB_TYPE_JSON\n+    if type == DUCKDB_TYPE_VARCHAR || type == DUCKDB_TYPE_BLOB\n         return convert_vector_string\n     elseif type == DUCKDB_TYPE_LIST\n         return convert_vector_list\ndiff --git a/tools/pythonpkg/src/array_wrapper.cpp b/tools/pythonpkg/src/array_wrapper.cpp\nindex c2e93f3d4256..e0019920fab5 100644\n--- a/tools/pythonpkg/src/array_wrapper.cpp\n+++ b/tools/pythonpkg/src/array_wrapper.cpp\n@@ -509,7 +509,6 @@ RawArrayWrapper::RawArrayWrapper(const LogicalType &type) : data(nullptr), type(\n \tcase LogicalTypeId::TIME:\n \tcase LogicalTypeId::TIME_TZ:\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::BLOB:\n \tcase LogicalTypeId::ENUM:\n \tcase LogicalTypeId::LIST:\n@@ -575,7 +574,6 @@ void RawArrayWrapper::Initialize(idx_t capacity) {\n \tcase LogicalTypeId::TIME:\n \tcase LogicalTypeId::TIME_TZ:\n \tcase LogicalTypeId::VARCHAR:\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::BLOB:\n \tcase LogicalTypeId::LIST:\n \tcase LogicalTypeId::MAP:\n@@ -717,7 +715,6 @@ void ArrayWrapper::Append(idx_t current_offset, Vector &input, idx_t count) {\n \t\tmay_have_null = ConvertColumn<interval_t, int64_t, duckdb_py_convert::IntervalConvert>(current_offset, dataptr,\n \t\t                                                                                       maskptr, idata, count);\n \t\tbreak;\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR:\n \t\tmay_have_null = ConvertColumn<string_t, PyObject *, duckdb_py_convert::StringConvert>(current_offset, dataptr,\n \t\t                                                                                      maskptr, idata, count);\ndiff --git a/tools/pythonpkg/src/pyresult.cpp b/tools/pythonpkg/src/pyresult.cpp\nindex 28b86c9c2e38..17287652ba54 100644\n--- a/tools/pythonpkg/src/pyresult.cpp\n+++ b/tools/pythonpkg/src/pyresult.cpp\n@@ -324,7 +324,6 @@ py::str GetTypeToPython(const LogicalType &type) {\n \tcase LogicalTypeId::DECIMAL: {\n \t\treturn py::str(\"NUMBER\");\n \t}\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR:\n \t\treturn py::str(\"STRING\");\n \tcase LogicalTypeId::BLOB:\ndiff --git a/tools/pythonpkg/src/python_objects.cpp b/tools/pythonpkg/src/python_objects.cpp\nindex 34fe382c2826..bc193da37c9c 100644\n--- a/tools/pythonpkg/src/python_objects.cpp\n+++ b/tools/pythonpkg/src/python_objects.cpp\n@@ -311,7 +311,6 @@ py::object PythonObject::FromValue(const Value &val, const LogicalType &type) {\n \t}\n \tcase LogicalTypeId::ENUM:\n \t\treturn py::cast(EnumType::GetValue(val));\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR:\n \t\treturn py::cast(StringValue::Get(val));\n \tcase LogicalTypeId::BLOB:\ndiff --git a/tools/rpkg/src/relational.cpp b/tools/rpkg/src/relational.cpp\nindex 538b5c233c4e..9430fcd1f5bb 100644\n--- a/tools/rpkg/src/relational.cpp\n+++ b/tools/rpkg/src/relational.cpp\n@@ -27,7 +27,7 @@ using namespace duckdb;\n using namespace cpp11;\n \n template <typename T, typename... Args>\n-external_pointer<T> make_external(const string &rclass, Args &&...args) {\n+external_pointer<T> make_external(const string &rclass, Args &&... args) {\n \tauto extptr = external_pointer<T>(new T(std::forward<Args>(args)...));\n \t((sexp)extptr).attr(\"class\") = rclass;\n \treturn (extptr);\ndiff --git a/tools/rpkg/src/transform.cpp b/tools/rpkg/src/transform.cpp\nindex bb16c2af8305..b634b940581c 100644\n--- a/tools/rpkg/src/transform.cpp\n+++ b/tools/rpkg/src/transform.cpp\n@@ -73,7 +73,6 @@ SEXP duckdb_r_allocate(const LogicalType &type, RProtector &r_varvalue, idx_t nr\n \t\tvarvalue = r_varvalue.Protect(cpp11::as_sexp(dest_list));\n \t\tbreak;\n \t}\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR:\n \tcase LogicalTypeId::UUID:\n \t\tvarvalue = r_varvalue.Protect(NEW_STRING(nrows));\n@@ -156,7 +155,6 @@ void duckdb_r_decorate(const LogicalType &type, SEXP &dest, bool integer64) {\n \tcase LogicalTypeId::DOUBLE:\n \tcase LogicalTypeId::VARCHAR:\n \tcase LogicalTypeId::BLOB:\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::UUID:\n \tcase LogicalTypeId::LIST:\n \t\tbreak; // no extra decoration required, do nothing\n@@ -383,7 +381,6 @@ void duckdb_r_transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n,\n \tcase LogicalTypeId::DOUBLE:\n \t\tVectorToR<double, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n \t\tbreak;\n-\tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR: {\n \t\tauto src_ptr = FlatVector::GetData<string_t>(src_vec);\n \t\tauto &mask = FlatVector::Validity(src_vec);\ndiff --git a/tools/rpkg/src/types.cpp b/tools/rpkg/src/types.cpp\nindex 118a3d8d6e93..76184ab2b888 100644\n--- a/tools/rpkg/src/types.cpp\n+++ b/tools/rpkg/src/types.cpp\n@@ -135,7 +135,6 @@ string RApiTypes::DetectLogicalType(const LogicalType &stype, const char *caller\n \t\treturn \"numeric\";\n \tcase LogicalTypeId::VARCHAR:\n \tcase LogicalTypeId::UUID:\n-\tcase LogicalTypeId::JSON:\n \t\treturn \"character\";\n \tcase LogicalTypeId::BLOB:\n \t\treturn \"raw\";\n",
  "test_patch": "diff --git a/src/function/table/system/test_all_types.cpp b/src/function/table/system/test_all_types.cpp\nindex 862fabefa63c..124dde519fa2 100644\n--- a/src/function/table/system/test_all_types.cpp\n+++ b/src/function/table/system/test_all_types.cpp\n@@ -1,7 +1,8 @@\n-#include \"duckdb/function/table/system_functions.hpp\"\n #include \"duckdb/common/pair.hpp\"\n #include \"duckdb/common/types/date.hpp\"\n #include \"duckdb/common/types/timestamp.hpp\"\n+#include \"duckdb/function/table/system_functions.hpp\"\n+\n #include <cmath>\n #include <limits>\n \n@@ -59,7 +60,6 @@ vector<TestType> TestAllTypesFun::GetTestTypes() {\n \t// strings/blobs\n \tresult.emplace_back(LogicalType::VARCHAR, \"varchar\", Value(\"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\"),\n \t                    Value(string(\"goo\\x00se\", 6)));\n-\tresult.emplace_back(LogicalType::JSON, \"json\", Value(\"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\"), Value(\"goose\"));\n \tresult.emplace_back(LogicalType::BLOB, \"blob\", Value::BLOB(\"thisisalongblob\\\\x00withnullbytes\"),\n \t                    Value::BLOB(\"\\\\x00\\\\x00\\\\x00a\"));\n \ndiff --git a/test/sql/aggregate/aggregates/test_list_aggregate_function.test b/test/sql/aggregate/aggregates/test_list_aggregate_function.test\nindex 72581ffb9861..210f8a0848f1 100644\n--- a/test/sql/aggregate/aggregates/test_list_aggregate_function.test\n+++ b/test/sql/aggregate/aggregates/test_list_aggregate_function.test\n@@ -155,7 +155,7 @@ SELECT tconst, list(principals) as principals FROM parquet_scan('data/parquet-te\n \n # test all data types\n \n-foreach type bool tinyint smallint int bigint hugeint utinyint usmallint uint ubigint date time timestamp timestamp_s timestamp_ms timestamp_ns time_tz timestamp_tz float double dec_4_1 dec_9_4 dec_18_6 dec38_10 uuid interval varchar json blob small_enum medium_enum large_enum int_array double_array date_array timestamp_array timestamptz_array varchar_array nested_int_array struct struct_of_arrays array_of_structs map\n+foreach type bool tinyint smallint int bigint hugeint utinyint usmallint uint ubigint date time timestamp timestamp_s timestamp_ms timestamp_ns time_tz timestamp_tz float double dec_4_1 dec_9_4 dec_18_6 dec38_10 uuid interval varchar blob small_enum medium_enum large_enum int_array double_array date_array timestamp_array timestamptz_array varchar_array nested_int_array struct struct_of_arrays array_of_structs map\n \n statement ok\n CREATE TABLE t1 AS SELECT ${type} AS c1 FROM test_all_types();\ndiff --git a/test/sql/cast/string_to_struct_cast.test b/test/sql/cast/string_to_struct_cast.test\nindex 37bc3bedc7df..3188618912d7 100644\n--- a/test/sql/cast/string_to_struct_cast.test\n+++ b/test/sql/cast/string_to_struct_cast.test\n@@ -386,6 +386,8 @@ SELECT * FROM assorted_structs;\n #               JSON format to Struct testing\n # ---------------------------------------------------\n \n+require json\n+\n statement ok\n CREATE TABLE json_tbl(col1 VARCHAR);\n \ndiff --git a/test/sql/function/list/aggregates/incorrect.test b/test/sql/function/list/aggregates/incorrect.test\nindex 34f1c277e38b..bf793c638bd6 100644\n--- a/test/sql/function/list/aggregates/incorrect.test\n+++ b/test/sql/function/list/aggregates/incorrect.test\n@@ -27,7 +27,7 @@ SELECT list_aggr('hello', '${func_name}')\n statement error\n SELECT list_aggr(1, 2, '${func_name}')\n \n-foreach type boolean varchar tinyint smallint integer bigint hugeint utinyint usmallint uinteger ubigint float double decimal(4,1) decimal(9,4) decimal(18,6) decimal(38,10) date time timestamp timestamp_s timestamp_ms timestamp_ns timetz timestamptz interval json blob\n+foreach type boolean varchar tinyint smallint integer bigint hugeint utinyint usmallint uinteger ubigint float double decimal(4,1) decimal(9,4) decimal(18,6) decimal(38,10) date time timestamp timestamp_s timestamp_ms timestamp_ns timetz timestamptz interval blob\n \n statement error\n SELECT list_aggr(NULL::${type}, '${func_name}')\ndiff --git a/test/sql/function/list/aggregates/types.test b/test/sql/function/list/aggregates/types.test\nindex 5e379d76202a..1a1c50ceadd0 100644\n--- a/test/sql/function/list/aggregates/types.test\n+++ b/test/sql/function/list/aggregates/types.test\n@@ -285,40 +285,9 @@ SELECT list_aggr([INTERVAL 1 YEAR], '${func_name}')\n \n endloop\n \n-# JSON\n-\n-# result {a: 1}\n-foreach func_name first arbitrary last max median min mode string_agg group_concat\n-\n-query I\n-SELECT list_aggr(['{a: 1}'::JSON], '${func_name}')\n-----\n-{a: 1}\n-\n-query I\n-SELECT list_aggr([NULL::JSON], '${func_name}')\n-----\n-NULL\n-\n-endloop\n-\n # any other result\n foreach func_name approx_count_distinct count entropy histogram array_agg list\n \n-statement ok\n-SELECT list_aggr(['{a: 1}'::JSON], '${func_name}')\n-\n-statement ok\n-SELECT list_aggr([NULL::JSON], '${func_name}')\n-\n-endloop\n-\n-# statement error for JSON\n-foreach func_name avg favg bit_and bit_or bit_xor bool_and bool_or kurtosis mad product sem skewness sum fsum sumKahan kahan_sum var_samp var_pop stddev stddev_pop variance stddev_samp\n-\n-statement error\n-SELECT list_aggr(['{a: 1}'::JSON], '${func_name}')\n-\n endloop\n \n # BLOB\ndiff --git a/test/sql/function/list/list_distinct.test b/test/sql/function/list/list_distinct.test\nindex 9adabc483bb8..36f6ab340525 100644\n--- a/test/sql/function/list/list_distinct.test\n+++ b/test/sql/function/list/list_distinct.test\n@@ -40,7 +40,7 @@ SELECT list_distinct([1, 2], 2)\n \n # test incorrect parameter type\n \n-foreach type boolean varchar tinyint smallint integer bigint hugeint utinyint usmallint uinteger ubigint float double decimal(4,1) decimal(9,4) decimal(18,6) decimal(38,10) date time timestamp timestamp_s timestamp_ms timestamp_ns timetz timestamptz interval json blob\n+foreach type boolean varchar tinyint smallint integer bigint hugeint utinyint usmallint uinteger ubigint float double decimal(4,1) decimal(9,4) decimal(18,6) decimal(38,10) date time timestamp timestamp_s timestamp_ms timestamp_ns timetz timestamptz interval blob\n \n statement error\n SELECT list_distinct(NULL::${type})\n@@ -218,18 +218,6 @@ SELECT list_distinct([NULL::${type}])\n \n endloop\n \n-# JSON\n-\n-query I\n-SELECT list_distinct(['{a: 1}'::JSON, '{a: 1}'::JSON])\n-----\n-[{a: 1}]\n-\n-query I\n-SELECT list_distinct([NULL::JSON])\n-----\n-[]\n-\n # enums\n statement ok\n CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy')\ndiff --git a/test/sql/function/list/list_sort.test b/test/sql/function/list/list_sort.test\nindex 73961e0a970d..0db2590ad259 100644\n--- a/test/sql/function/list/list_sort.test\n+++ b/test/sql/function/list/list_sort.test\n@@ -61,7 +61,7 @@ SELECT list_sort([1, 2], 'NULLS FIRST')\n \n foreach func_name list_sort list_reverse_sort\n \n-foreach type boolean varchar tinyint smallint integer bigint hugeint utinyint usmallint uinteger ubigint float double decimal(4,1) decimal(9,4) decimal(18,6) decimal(38,10) date time timestamp timestamp_s timestamp_ms timestamp_ns timetz timestamptz interval json blob\n+foreach type boolean varchar tinyint smallint integer bigint hugeint utinyint usmallint uinteger ubigint float double decimal(4,1) decimal(9,4) decimal(18,6) decimal(38,10) date time timestamp timestamp_s timestamp_ms timestamp_ns timetz timestamptz interval blob\n \n statement error\n SELECT ${func_name}(NULL::${type})\n@@ -321,18 +321,6 @@ SELECT list_sort([NULL::${type}])\n \n endloop\n \n-# JSON\n-\n-query I\n-SELECT list_sort(['{a: 1}'::JSON, '{a: 3}'::JSON])\n-----\n-[{a: 1}, {a: 3}]\n-\n-query I\n-SELECT list_sort([NULL::JSON])\n-----\n-[NULL]\n-\n # BLOB\n \n query I\ndiff --git a/test/sql/function/list/list_unique.test b/test/sql/function/list/list_unique.test\nindex 4a065b6e9940..95e5298e9319 100644\n--- a/test/sql/function/list/list_unique.test\n+++ b/test/sql/function/list/list_unique.test\n@@ -36,7 +36,7 @@ SELECT list_unique([1, 2], 2)\n \n # test incorrect parameter type\n \n-foreach type boolean varchar tinyint smallint integer bigint hugeint utinyint usmallint uinteger ubigint float double decimal(4,1) decimal(9,4) decimal(18,6) decimal(38,10) date time timestamp timestamp_s timestamp_ms timestamp_ns timetz timestamptz interval json blob\n+foreach type boolean varchar tinyint smallint integer bigint hugeint utinyint usmallint uinteger ubigint float double decimal(4,1) decimal(9,4) decimal(18,6) decimal(38,10) date time timestamp timestamp_s timestamp_ms timestamp_ns timetz timestamptz interval blob\n \n statement error\n SELECT list_unique(NULL::${type})\n@@ -203,18 +203,6 @@ SELECT list_unique([NULL::${type}])\n \n endloop\n \n-# JSON\n-\n-query I\n-SELECT list_unique(['{a: 1}'::JSON, '{a: 1}'::JSON])\n-----\n-1\n-\n-query I\n-SELECT list_unique([NULL::JSON])\n-----\n-0\n-\n # enums\n statement ok\n CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy')\ndiff --git a/test/sql/json/read_json_objects.test b/test/sql/json/read_json_objects.test\nnew file mode 100644\nindex 000000000000..8a3a42897bc2\n--- /dev/null\n+++ b/test/sql/json/read_json_objects.test\n@@ -0,0 +1,224 @@\n+# name: test/sql/json/read_json_objects.test\n+# description: Read ndjson files\n+# group: [json]\n+\n+# this was the previous implementation, doesn't work without JSON extension (no JSON type in catalog)\n+statement error\n+SELECT * FROM read_csv('data/json/example_n.ndjson', columns={'json': 'JSON'}, delim=NULL, header=0, quote=NULL, escape=NULL)\n+\n+require json\n+\n+# now it should work!\n+query I\n+SELECT * FROM read_csv('data/json/example_n.ndjson', columns={'json': 'JSON'}, delim=NULL, header=0, quote=NULL, escape=NULL)\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+# example_n is with regular \\n newlines\n+query I\n+SELECT * FROM read_json_objects('data/json/example_n.ndjson')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+query I\n+SELECT * FROM read_ndjson_objects('data/json/example_n.ndjson')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+# we can auto-detect that it's newline-delimited\n+query I\n+SELECT * FROM read_json_objects('data/json/example_n.ndjson', format='auto')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+# example_r is with \\r newlines - works with read_json_objects\n+query I\n+SELECT * FROM read_json_objects('data/json/example_r.ndjson')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+# we can detect that it's not newline-delimited\n+query I\n+SELECT * FROM read_json_objects('data/json/example_r.ndjson', format='auto')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+# \\r newlines are NOT valid according to ndjson spec - this does not work, all a single line\n+statement error\n+SELECT * FROM read_ndjson_objects('data/json/example_r.ndjson')\n+----\n+Invalid Input Error: Malformed JSON at byte 45 of input\n+\n+# example_rn is with \\r\\n newlines\n+query I\n+SELECT * FROM read_json_objects('data/json/example_rn.ndjson')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+query I\n+SELECT * FROM read_ndjson_objects('data/json/example_rn.ndjson')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+# same but gzipped\n+query I\n+SELECT * FROM read_json_objects('data/json/example_rn.ndjson.gz')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+query I\n+SELECT * FROM read_ndjson_objects('data/json/example_rn.ndjson.gz')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+# multi-file scan\n+query I\n+SELECT count(*) from read_json_objects(['data/json/example_n.ndjson', 'data/json/example_r.ndjson', 'data/json/example_rn.ndjson'])\n+----\n+15\n+\n+query I\n+SELECT count(*) from read_ndjson_objects(['data/json/example_n.ndjson', 'data/json/example_rn.ndjson'])\n+----\n+10\n+\n+# globbing\n+query I\n+SELECT count(*) from read_json_objects('data/json/example_*.ndjson')\n+----\n+15\n+\n+query I\n+SELECT count(*) from read_ndjson_objects('data/json/example_*n.ndjson')\n+----\n+10\n+\n+require httpfs\n+\n+# same file but hosted on github\n+query I\n+select * from read_json_objects('https://github.com/duckdb/duckdb-data/releases/download/v1.0/example_rn.ndjson')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+query I\n+select * from read_ndjson_objects('https://github.com/duckdb/duckdb-data/releases/download/v1.0/example_rn.ndjson')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+# empty file\n+query I\n+select * from read_json_objects('data/json/empty.ndjson')\n+---\n+\n+query I\n+select * from read_ndjson_objects('data/json/empty.ndjson')\n+---\n+\n+# invalid json stuff\n+statement error\n+select * from read_json_objects('data/json/unterminated_quotes.ndjson')\n+----\n+Invalid Input Error: Malformed JSON at byte 25 of input\n+\n+statement error\n+select * from read_ndjson_objects('data/json/unterminated_quotes.ndjson')\n+----\n+Invalid Input Error: Malformed JSON at byte 25 of input\n+\n+# we can auto-detect and ignore the error (becomes NULL)\n+query I\n+select * from read_ndjson_objects('data/json/unterminated_quotes.ndjson', format='auto', ignore_errors=true)\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+NULL\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+# multiple objects per line (works for read_json_objects)\n+query I\n+select * from read_json_objects('data/json/multiple_objects_per_line.ndjson')\n+----\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}\n+\n+# does not work for read_ndjson_objects\n+statement error\n+select * from read_ndjson_objects('data/json/multiple_objects_per_line.ndjson')\n+----\n+Invalid Input Error: Malformed JSON at byte 44 of input\n+\n+# what if we try to read a CSV?\n+statement error\n+select * from read_json_objects('data/csv/tpcds_14.csv')\n+----\n+Invalid Input Error: Malformed JSON at byte 0 of input\n+\n+# error occurs at different byte\n+statement error\n+select * from read_ndjson_objects('data/csv/tpcds_14.csv')\n+----\n+Invalid Input Error: Malformed JSON at byte 0 of input\n+\n+# how about parquet?\n+statement error\n+select * from read_json_objects('data/parquet-testing/blob.parquet')\n+----\n+Invalid Input Error: Malformed JSON at byte 0 of input\n+\n+statement error\n+select * from read_ndjson_objects('data/parquet-testing/blob.parquet')\n+----\n+Invalid Input Error: Malformed JSON at byte 0 of input\ndiff --git a/test/sql/json/read_ndjson.test b/test/sql/json/read_ndjson.test\ndeleted file mode 100644\nindex e83b2d7cd47e..000000000000\n--- a/test/sql/json/read_ndjson.test\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-# name: test/sql/json/read_ndjson.test\n-# description: Read ndjson files\n-# group: [json]\n-\n-require json\n-\n-query I\n-SELECT * FROM read_json_objects('data/json/example.ndjson')\n-----\n-{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n-{\"id\":2,\"name\":\"Home for the Holidays\"}\n-{\"id\":3,\"name\":\"The Firm\"}\n-{\"id\":4,\"name\":\"Broadcast News\"}\n-{\"id\":5,\"name\":\"Raising Arizona\"}\n-\n-query I\n-SELECT * FROM read_ndjson_objects('data/json/example.ndjson')\n-----\n-{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n-{\"id\":2,\"name\":\"Home for the Holidays\"}\n-{\"id\":3,\"name\":\"The Firm\"}\n-{\"id\":4,\"name\":\"Broadcast News\"}\n-{\"id\":5,\"name\":\"Raising Arizona\"}\ndiff --git a/test/sql/json/test_json_contains.test b/test/sql/json/test_json_contains.test\nindex 6a80b62e6962..f5b1c3a96969 100644\n--- a/test/sql/json/test_json_contains.test\n+++ b/test/sql/json/test_json_contains.test\n@@ -78,3 +78,15 @@ query T\n select json_contains('{\"a\": {\"b\": [{\"c\": 1, \"d\": 2}]}}', '[]')\n ----\n True\n+\n+# Issue 5960\n+query T\n+select json_contains(json('{\"key\":\"value\"}'),json('{\"blah\":\"value\"}'))\n+----\n+False\n+\n+# Check if the recursion properly stops\n+query T\n+select json_contains('{\"a\": {\"b\": 42}}', '{\"a\": 42}')\n+----\n+False\ndiff --git a/test/sql/json/test_json_extract.test b/test/sql/json/test_json_extract.test\nindex 7a20fd45e613..359b8d6650e8 100644\n--- a/test/sql/json/test_json_extract.test\n+++ b/test/sql/json/test_json_extract.test\n@@ -252,8 +252,8 @@ SELECT x::JSON->'$.settings.layer2.\"tris.legomenon\".\"summary.report\"' FROM t12;\n ----\n false\n \n-# can't deal with force reload / force storage (#5132)\n \n+# can't deal with force reload / force storage (#5132)\n require skip_reload\n \n # test issue #5063\ndiff --git a/test/sql/json/test_json_persistence.test b/test/sql/json/test_json_persistence.test\nnew file mode 100644\nindex 000000000000..5c4402b1d843\n--- /dev/null\n+++ b/test/sql/json/test_json_persistence.test\n@@ -0,0 +1,32 @@\n+# name: test/sql/json/test_json_persistence.test\n+# description: Test persistence of the JSON type\n+# group: [json]\n+\n+require json\n+\n+require skip_reload\n+\n+# load the DB from disk\n+load __TEST_DIR__/json_type.db\n+\n+statement ok\n+create table test (j json)\n+\n+statement ok\n+insert into test values ('{\"duck\": 42}'), (NULL), ('{\"goose\": 43}')\n+\n+query II\n+select typeof(j), j from test\n+----\n+JSON\t{\"duck\": 42}\n+JSON\tNULL\n+JSON\t{\"goose\": 43}\n+\n+restart\n+\n+query II\n+select typeof(j), j from test\n+----\n+JSON\t{\"duck\": 42}\n+JSON\tNULL\n+JSON\t{\"goose\": 43}\ndiff --git a/test/sql/json/tpch_round_trip.test_slow b/test/sql/json/tpch_round_trip.test_slow\nnew file mode 100644\nindex 000000000000..3c7e6be849e3\n--- /dev/null\n+++ b/test/sql/json/tpch_round_trip.test_slow\n@@ -0,0 +1,64 @@\n+# name: test/sql/json/tpch_round_trip.test_slow\n+# description: TPCH JSON round trip\n+# group: [json]\n+\n+# TODO: implement COPY functions for JSON and do all tables more easily, we just do Q1 for now with from_json\n+\n+require tpch\n+\n+require json\n+\n+statement ok\n+call dbgen(sf=1)\n+\n+statement ok\n+copy (select to_json(lineitem) from lineitem) to '__TEST_DIR__/lineitem.json' (format csv, quote '')\n+\n+statement ok\n+drop table lineitem\n+\n+statement ok\n+create table lineitem_struct as select from_json(json, '{\n+\"l_orderkey\":\"INTEGER\",\n+\"l_partkey\":\"INTEGER\",\n+\"l_suppkey\":\"INTEGER\",\n+\"l_linenumber\":\"INTEGER\",\n+\"l_quantity\":\"INTEGER\",\n+\"l_extendedprice\":\"DECIMAL(15,2)\",\n+\"l_discount\":\"DECIMAL(15,2)\",\n+\"l_tax\":\"DECIMAL(15,2)\",\n+\"l_returnflag\":\"VARCHAR\",\n+\"l_linestatus\":\"VARCHAR\",\n+\"l_shipdate\":\"DATE\",\n+\"l_commitdate\":\"DATE\",\n+\"l_receiptdate\":\"DATE\",\n+\"l_shipinstruct\":\"VARCHAR\",\n+\"l_shipmode\":\"VARCHAR\",\n+\"l_comment\":\"VARCHAR\"\n+}') j\n+from read_ndjson_objects('__TEST_DIR__/lineitem.json')\n+\n+statement ok\n+CREATE VIEW lineitem AS SELECT\n+j['l_orderkey'] AS l_orderkey,\n+j['l_partkey'] AS l_partkey,\n+j['l_suppkey'] AS l_suppkey,\n+j['l_linenumber'] AS l_linenumber,\n+j['l_quantity'] AS l_quantity,\n+j['l_extendedprice'] AS l_extendedprice,\n+j['l_discount'] AS l_discount,\n+j['l_tax'] AS l_tax,\n+j['l_returnflag'] AS l_returnflag,\n+j['l_linestatus'] AS l_linestatus,\n+j['l_shipdate'] AS l_shipdate,\n+j['l_commitdate'] AS l_commitdate,\n+j['l_receiptdate'] AS l_receiptdate,\n+j['l_shipinstruct'] AS l_shipinstruct,\n+j['l_shipmode'] AS l_shipmode,\n+j['l_comment'] AS l_comment\n+FROM lineitem_struct\n+\n+query I\n+PRAGMA tpch(1)\n+----\n+<FILE>:extension/tpch/dbgen/answers/sf1/q01.csv\ndiff --git a/test/sql/storage_version/storage_version.db b/test/sql/storage_version/storage_version.db\nindex 09d033c7dd16..83870ce4c1ed 100644\nBinary files a/test/sql/storage_version/storage_version.db and b/test/sql/storage_version/storage_version.db differ\ndiff --git a/test/sql/types/test_all_types.test_coverage b/test/sql/types/test_all_types.test_coverage\nindex 6012f2680ee3..598cc931aa59 100644\n--- a/test/sql/types/test_all_types.test_coverage\n+++ b/test/sql/types/test_all_types.test_coverage\n@@ -5,12 +5,12 @@\n statement ok\n PRAGMA enable_verification\n \n-query IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\n+query IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\n SELECT * FROM test_all_types();\n ----\n-False\t-128\t-32768\t-2147483648\t-9223372036854775808\t-170141183460469231731687303715884105727\t0\t0\t0\t0\t5877642-06-25 (BC)\t00:00:00\t290309-12-22 (BC) 00:00:00\t290309-12-22 (BC) 00:00:00\t290309-12-22 (BC) 00:00:00\t1677-09-21 00:12:43.145225\t00:00:00+00\t290309-12-22 (BC) 00:00:00+00\t-340282346638528859811704183484516925440.000000\t-179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000\t-999.9\t-99999.9999\t-999999999999.999999\t-9999999999999999999999999999.9999999999\t00000000-0000-0000-0000-000000000001\t00:00:00\t\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\t\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\tthisisalongblob\\x00withnullbytes\tDUCK_DUCK_ENUM\tenum_0\tenum_0\t[]\t[]\t[]\t[]\t[]\t[]\t[]\t{'a': NULL, 'b': NULL}\t{'a': NULL, 'b': NULL}\t[]\t{}\n-True\t127\t32767\t2147483647\t9223372036854775807\t170141183460469231731687303715884105727\t255\t65535\t4294967295\t18446744073709551615\t5881580-07-10\t23:59:59.999999\t294247-01-10 04:00:54.775806\t294247-01-10 04:00:54\t294247-01-10 04:00:54.775\t2262-04-11 23:47:16.854775\t23:59:59.999999+00\t294247-01-10 04:00:54.775806+00\t340282346638528859811704183484516925440.000000\t179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000\t999.9\t99999.9999\t999999999999.999999\t9999999999999999999999999999.9999999999\tffffffff-ffff-ffff-ffff-ffffffffffff\t83 years 3 months 999 days 00:16:39.999999\tgoo\\0se\tgoose\t\\x00\\x00\\x00a\tGOOSE\tenum_299\tenum_69999\t[42, 999, NULL, NULL, -42]\t[42.0, nan, inf, -inf, NULL, -42.0]\t[1970-01-01, infinity, -infinity, NULL, 2022-05-12]\t[1970-01-01 00:00:00, infinity, -infinity, NULL, 2022-05-12 16:23:45]\t[1970-01-01 00:00:00+00, infinity, -infinity, NULL, 2022-05-12 23:23:45+00]\t[\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, goose, NULL, ]\t[[], [42, 999, NULL, NULL, -42], NULL, [], [42, 999, NULL, NULL, -42]]\t{'a': 42, 'b': \ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86}\t{'a': [42, 999, NULL, NULL, -42], 'b': [\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, goose, NULL, ]}\t[{'a': NULL, 'b': NULL}, {'a': 42, 'b': \ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86}, NULL]\t{key1=\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, key2=goose}\n-NULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\n+False\t-128\t-32768\t-2147483648\t-9223372036854775808\t-170141183460469231731687303715884105727\t0\t0\t0\t0\t5877642-06-25 (BC)\t00:00:00\t290309-12-22 (BC) 00:00:00\t290309-12-22 (BC) 00:00:00\t290309-12-22 (BC) 00:00:00\t1677-09-21 00:12:43.145225\t00:00:00+00\t290309-12-22 (BC) 00:00:00+00\t-340282346638528859811704183484516925440.000000\t-179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000\t-999.9\t-99999.9999\t-999999999999.999999\t-9999999999999999999999999999.9999999999\t00000000-0000-0000-0000-000000000001\t00:00:00\t\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\tthisisalongblob\\x00withnullbytes\tDUCK_DUCK_ENUM\tenum_0\tenum_0\t[]\t[]\t[]\t[]\t[]\t[]\t[]\t{'a': NULL, 'b': NULL}\t{'a': NULL, 'b': NULL}\t[]\t{}\n+True\t127\t32767\t2147483647\t9223372036854775807\t170141183460469231731687303715884105727\t255\t65535\t4294967295\t18446744073709551615\t5881580-07-10\t23:59:59.999999\t294247-01-10 04:00:54.775806\t294247-01-10 04:00:54\t294247-01-10 04:00:54.775\t2262-04-11 23:47:16.854775\t23:59:59.999999+00\t294247-01-10 04:00:54.775806+00\t340282346638528859811704183484516925440.000000\t179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000\t999.9\t99999.9999\t999999999999.999999\t9999999999999999999999999999.9999999999\tffffffff-ffff-ffff-ffff-ffffffffffff\t83 years 3 months 999 days 00:16:39.999999\tgoo\\0se\t\\x00\\x00\\x00a\tGOOSE\tenum_299\tenum_69999\t[42, 999, NULL, NULL, -42]\t[42.0, nan, inf, -inf, NULL, -42.0]\t[1970-01-01, infinity, -infinity, NULL, 2022-05-12]\t[1970-01-01 00:00:00, infinity, -infinity, NULL, 2022-05-12 16:23:45]\t[1970-01-01 00:00:00+00, infinity, -infinity, NULL, 2022-05-12 23:23:45+00]\t[\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, goose, NULL, ]\t[[], [42, 999, NULL, NULL, -42], NULL, [], [42, 999, NULL, NULL, -42]]\t{'a': 42, 'b': \ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86}\t{'a': [42, 999, NULL, NULL, -42], 'b': [\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, goose, NULL, ]}\t[{'a': NULL, 'b': NULL}, {'a': 42, 'b': \ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86}, NULL]\t{key1=\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, key2=goose}\n+NULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\n \n statement ok\n CREATE TABLE all_types AS SELECT * FROM test_all_types();\ndiff --git a/test/sqlite/sqllogic_test_runner.cpp b/test/sqlite/sqllogic_test_runner.cpp\nindex 49d6a032bfe0..28b56802eb37 100644\n--- a/test/sqlite/sqllogic_test_runner.cpp\n+++ b/test/sqlite/sqllogic_test_runner.cpp\n@@ -169,7 +169,6 @@ bool SQLLogicTestRunner::ForEachTokenReplace(const string &parameter, vector<str\n \t\tresult.push_back(\"bool\");\n \t\tresult.push_back(\"interval\");\n \t\tresult.push_back(\"varchar\");\n-\t\tresult.push_back(\"json\");\n \t\tcollection = true;\n \t}\n \tif (is_compression) {\ndiff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex 687932411a92..e5220a1ce151 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -2298,21 +2298,21 @@ public static void test_json() throws Exception {\n \t\t}\n \n \t\ttry (Statement stmt = conn.createStatement()) {\n-\t\t\tResultSet rs = stmt.executeQuery(\"select {'key': 'value'}::JSON\");\n+\t\t\tResultSet rs = stmt.executeQuery(\"select '{\\\"key\\\": \\\"value\\\"}'::JSON\");\n \t\t\trs.next();\n \t\t\tassertEquals(rs.getMetaData().getColumnType(1), Types.JAVA_OBJECT);\n \t\t\tJsonNode jsonNode = (JsonNode) rs.getObject(1);\n \t\t\tassertTrue(jsonNode.isObject());\n-\t\t\tassertEquals(jsonNode.toString(), \"{'key': value}\"); // this isn't valid json output, must load json extension for that\n+\t\t\tassertEquals(jsonNode.toString(), \"{\\\"key\\\": \\\"value\\\"}\"); // this isn't valid json output, must load json extension for that\n \t\t}\n \n \t\ttry (Statement stmt = conn.createStatement()) {\n-\t\t\tResultSet rs = stmt.executeQuery(\"select 'hello'::JSON\");\n+\t\t\tResultSet rs = stmt.executeQuery(\"select '\\\"hello\\\"'::JSON\");\n \t\t\trs.next();\n \t\t\tassertEquals(rs.getMetaData().getColumnType(1), Types.JAVA_OBJECT);\n \t\t\tJsonNode jsonNode = (JsonNode) rs.getObject(1);\n \t\t\tassertTrue(jsonNode.isString());\n-\t\t\tassertEquals(jsonNode.toString(), \"hello\");\n+\t\t\tassertEquals(jsonNode.toString(), \"\\\"hello\\\"\");\n \t\t}\n \t}\n \ndiff --git a/tools/juliapkg/test/test_all_types.jl b/tools/juliapkg/test/test_all_types.jl\nindex 4659a86ec012..55d7657853e9 100644\n--- a/tools/juliapkg/test/test_all_types.jl\n+++ b/tools/juliapkg/test/test_all_types.jl\n@@ -41,7 +41,6 @@\n         df.dec38_10,\n         [-9999999999999999999999999999.9999999999, 9999999999999999999999999999.9999999999, missing]\n     )\n-    @test isequal(df.json, [\"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\", \"goose\", missing])\n     @test isequal(df.small_enum, [\"DUCK_DUCK_ENUM\", \"GOOSE\", missing])\n     @test isequal(df.medium_enum, [\"enum_0\", \"enum_299\", missing])\n     @test isequal(df.large_enum, [\"enum_0\", \"enum_69999\", missing])\ndiff --git a/tools/rpkg/tests/testthat/_snaps/types.md b/tools/rpkg/tests/testthat/_snaps/types.md\nindex fec7819ebaeb..9c5114d3ed3a 100644\n--- a/tools/rpkg/tests/testthat/_snaps/types.md\n+++ b/tools/rpkg/tests/testthat/_snaps/types.md\n@@ -87,9 +87,6 @@\n       $varchar\n       [1] \"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\" \"goose\"        NA            \n       \n-      $json\n-      [1] \"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\" \"goose\"        NA            \n-      \n       $blob\n       $blob[[1]]\n        [1] 74 68 69 73 69 73 61 6c 6f 6e 67 62 6c 6f 62 00 77 69 74 68 6e 75 6c 6c 62\ndiff --git a/tools/shell/shell-test.py b/tools/shell/shell-test.py\nindex 91e7d2e7e1e3..f58f69acfd73 100644\n--- a/tools/shell/shell-test.py\n+++ b/tools/shell/shell-test.py\n@@ -955,6 +955,32 @@ def tf():\n           input_file='data/csv/tpcds_14.csv',\n           out='''web,8006004,844.21,21''')\n \n+     test('''create table mytable as select * from\n+read_json_objects('/dev/stdin');\n+select * from mytable;\n+          ''',\n+          extra_commands=['-list', ':memory:'],\n+          input_file='data/json/example_rn.ndjson',\n+          out='''json\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}''')\n+\n+     test('''create table mytable as select * from\n+read_ndjson_objects('/dev/stdin');\n+select * from mytable;\n+          ''',\n+          extra_commands=['-list', ':memory:'],\n+          input_file='data/json/example_rn.ndjson',\n+          out='''json\n+{\"id\":1,\"name\":\"O Brother, Where Art Thou?\"}\n+{\"id\":2,\"name\":\"Home for the Holidays\"}\n+{\"id\":3,\"name\":\"The Firm\"}\n+{\"id\":4,\"name\":\"Broadcast News\"}\n+{\"id\":5,\"name\":\"Raising Arizona\"}''')\n+\n      test('''\n      COPY (SELECT 42) TO '/dev/stdout' WITH (FORMAT 'csv');\n      ''',\n",
  "problem_statement": "json_contains only checks value from second parameter\n### What happens?\n\nMy second argument to json_contains has the same value as the first parameter, but a different key. I would expect this to return false, since the entire json in the second parameter is not present in the first.\n\n### To Reproduce\n\n```sql\r\nselect json_contains(json('{\"key\":\"value\"}'),json('{\"blah\":\"value\"}')) as my_json_contains;\r\n```\r\n| my_json_contains |\r\n|------------------|\r\n| true             |\n\n### OS:\n\nWindows\n\n### DuckDB Version:\n\n0.6.1 and 0.6.2-dev1283\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nAlex Monahan\n\n### Affiliation:\n\nIntel and DuckDB Labs\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2022-11-29T19:48:58Z"
}