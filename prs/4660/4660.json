{
  "repo": "duckdb/duckdb",
  "pull_number": 4660,
  "instance_id": "duckdb__duckdb-4660",
  "issue_numbers": [
    "4499"
  ],
  "base_commit": "626cd542acbcdba0a2a759c31de0211f8db75299",
  "patch": "diff --git a/src/common/arrow/arrow_appender.cpp b/src/common/arrow/arrow_appender.cpp\nindex dc5f8a14dd64..99a9fa5d8cc4 100644\n--- a/src/common/arrow/arrow_appender.cpp\n+++ b/src/common/arrow/arrow_appender.cpp\n@@ -62,7 +62,7 @@ static void GetBitPosition(idx_t row_idx, idx_t &current_byte, uint8_t &current_\n }\n \n static void UnsetBit(uint8_t *data, idx_t current_byte, uint8_t current_bit) {\n-\tdata[current_byte] &= ~(1 << current_bit);\n+\tdata[current_byte] &= ~((uint64_t)1 << current_bit);\n }\n \n static void NextBit(idx_t &current_byte, uint8_t &current_bit) {\ndiff --git a/src/execution/perfect_aggregate_hashtable.cpp b/src/execution/perfect_aggregate_hashtable.cpp\nindex 77afca3c7005..3977fabdf0d5 100644\n--- a/src/execution/perfect_aggregate_hashtable.cpp\n+++ b/src/execution/perfect_aggregate_hashtable.cpp\n@@ -16,7 +16,7 @@ PerfectAggregateHashTable::PerfectAggregateHashTable(Allocator &allocator, Buffe\n \t\ttotal_required_bits += group_bits;\n \t}\n \t// the total amount of groups we allocate space for is 2^required_bits\n-\ttotal_groups = 1 << total_required_bits;\n+\ttotal_groups = (uint64_t)1 << total_required_bits;\n \t// we don't need to store the groups in a perfect hash table, since the group keys can be deduced by their location\n \tgrouping_columns = group_types_p.size();\n \tlayout.Initialize(move(aggregate_objects_p));\n@@ -200,7 +200,7 @@ static void ReconstructGroupVectorTemplated(uint32_t group_values[], Value &min,\n static void ReconstructGroupVector(uint32_t group_values[], Value &min, idx_t required_bits, idx_t shift,\n                                    idx_t entry_count, Vector &result) {\n \t// construct the mask for this entry\n-\tidx_t mask = (1 << required_bits) - 1;\n+\tidx_t mask = ((uint64_t)1 << required_bits) - 1;\n \tswitch (result.GetType().InternalType()) {\n \tcase PhysicalType::INT8:\n \t\tReconstructGroupVectorTemplated<int8_t>(group_values, min, mask, shift, entry_count, result);\ndiff --git a/src/execution/radix_partitioned_hashtable.cpp b/src/execution/radix_partitioned_hashtable.cpp\nindex fa0ac0196bb9..de2657f6e775 100644\n--- a/src/execution/radix_partitioned_hashtable.cpp\n+++ b/src/execution/radix_partitioned_hashtable.cpp\n@@ -16,7 +16,7 @@ void RadixPartitionedHashTable::SetGroupingValues() {\n \t\tfor (idx_t i = 0; i < grouping.size(); i++) {\n \t\t\tif (grouping_set.find(grouping[i]) == grouping_set.end()) {\n \t\t\t\t// we don't group on this value!\n-\t\t\t\tgrouping_value += 1 << (grouping.size() - (i + 1));\n+\t\t\t\tgrouping_value += (int64_t)1 << (grouping.size() - (i + 1));\n \t\t\t}\n \t\t}\n \t\tgrouping_values.push_back(Value::BIGINT(grouping_value));\ndiff --git a/src/include/duckdb/common/radix_partitioning.hpp b/src/include/duckdb/common/radix_partitioning.hpp\nindex 95d24471f2ca..84ad8f85956c 100644\n--- a/src/include/duckdb/common/radix_partitioning.hpp\n+++ b/src/include/duckdb/common/radix_partitioning.hpp\n@@ -24,7 +24,7 @@ template <idx_t radix_bits>\n struct RadixPartitioningConstants {\n public:\n \tstatic constexpr const idx_t NUM_RADIX_BITS = radix_bits;\n-\tstatic constexpr const idx_t NUM_PARTITIONS = 1 << NUM_RADIX_BITS;\n+\tstatic constexpr const idx_t NUM_PARTITIONS = (idx_t)1 << NUM_RADIX_BITS;\n \tstatic constexpr const idx_t TMP_BUF_SIZE = 8;\n \n public:\n@@ -42,7 +42,7 @@ struct RadixPartitioningConstants {\n struct RadixPartitioning {\n public:\n \tstatic idx_t NumberOfPartitions(idx_t radix_bits) {\n-\t\treturn 1 << radix_bits;\n+\t\treturn (idx_t)1 << radix_bits;\n \t}\n \n \t//! Partition the data in block_collection/string_heap to multiple partitions\ndiff --git a/src/main/capi/data_chunk-c.cpp b/src/main/capi/data_chunk-c.cpp\nindex d6232e92de43..4f5c58821b8e 100644\n--- a/src/main/capi/data_chunk-c.cpp\n+++ b/src/main/capi/data_chunk-c.cpp\n@@ -142,7 +142,7 @@ bool duckdb_validity_row_is_valid(uint64_t *validity, idx_t row) {\n \t}\n \tidx_t entry_idx = row / 64;\n \tidx_t idx_in_entry = row % 64;\n-\treturn validity[entry_idx] & (1 << idx_in_entry);\n+\treturn validity[entry_idx] & ((idx_t)1 << idx_in_entry);\n }\n \n void duckdb_validity_set_row_validity(uint64_t *validity, idx_t row, bool valid) {\n@@ -159,7 +159,7 @@ void duckdb_validity_set_row_invalid(uint64_t *validity, idx_t row) {\n \t}\n \tidx_t entry_idx = row / 64;\n \tidx_t idx_in_entry = row % 64;\n-\tvalidity[entry_idx] &= ~(1 << idx_in_entry);\n+\tvalidity[entry_idx] &= ~((uint64_t)1 << idx_in_entry);\n }\n \n void duckdb_validity_set_row_valid(uint64_t *validity, idx_t row) {\n@@ -168,5 +168,5 @@ void duckdb_validity_set_row_valid(uint64_t *validity, idx_t row) {\n \t}\n \tidx_t entry_idx = row / 64;\n \tidx_t idx_in_entry = row % 64;\n-\tvalidity[entry_idx] |= 1 << idx_in_entry;\n+\tvalidity[entry_idx] |= (uint64_t)1 << idx_in_entry;\n }\n",
  "test_patch": "diff --git a/test/api/capi/test_capi_data_chunk.cpp b/test/api/capi/test_capi_data_chunk.cpp\nindex 7f98fe9eab57..132481ebf356 100644\n--- a/test/api/capi/test_capi_data_chunk.cpp\n+++ b/test/api/capi/test_capi_data_chunk.cpp\n@@ -3,6 +3,57 @@\n using namespace duckdb;\n using namespace std;\n \n+TEST_CASE(\"Test table_info incorrect 'is_valid' value for 'dflt_value' column\", \"[capi]\") {\n+\tduckdb_database db;\n+\tduckdb_connection con;\n+\tduckdb_result result;\n+\n+\tREQUIRE(duckdb_open(NULL, &db) != DuckDBError);\n+\tREQUIRE(duckdb_connect(db, &con) != DuckDBError);\n+\t//! Create a table with 40 columns\n+\tREQUIRE(duckdb_query(con,\n+\t                     \"CREATE TABLE foo (c00 varchar, c01 varchar, c02 varchar, c03 varchar, c04 varchar, c05 \"\n+\t                     \"varchar, c06 varchar, c07 varchar, c08 varchar, c09 varchar, c10 varchar, c11 varchar, c12 \"\n+\t                     \"varchar, c13 varchar, c14 varchar, c15 varchar, c16 varchar, c17 varchar, c18 varchar, c19 \"\n+\t                     \"varchar, c20 varchar, c21 varchar, c22 varchar, c23 varchar, c24 varchar, c25 varchar, c26 \"\n+\t                     \"varchar, c27 varchar, c28 varchar, c29 varchar, c30 varchar, c31 varchar, c32 varchar, c33 \"\n+\t                     \"varchar, c34 varchar, c35 varchar, c36 varchar, c37 varchar, c38 varchar, c39 varchar);\",\n+\t                     NULL) != DuckDBError);\n+\t//! Get table info for the created table\n+\tREQUIRE(duckdb_query(con, \"PRAGMA table_info(foo);\", &result) != DuckDBError);\n+\n+\t//! Columns ({cid, name, type, notnull, dflt_value, pk}}\n+\tidx_t col_count = duckdb_column_count(&result);\n+\tREQUIRE(col_count == 6);\n+\tidx_t chunk_count = duckdb_result_chunk_count(result);\n+\n+\t// Loop over the produced chunks\n+\tfor (idx_t chunk_idx = 0; chunk_idx < chunk_count; chunk_idx++) {\n+\t\tduckdb_data_chunk chunk = duckdb_result_get_chunk(result, chunk_idx);\n+\t\tidx_t row_count = duckdb_data_chunk_get_size(chunk);\n+\n+\t\tfor (idx_t row_idx = 0; row_idx < row_count; row_idx++) {\n+\t\t\tfor (idx_t col_idx = 0; col_idx < col_count; col_idx++) {\n+\t\t\t\t//! Get the column\n+\t\t\t\tduckdb_vector vector = duckdb_data_chunk_get_vector(chunk, col_idx);\n+\t\t\t\tuint64_t *validity = duckdb_vector_get_validity(vector);\n+\t\t\t\tbool is_valid = duckdb_validity_row_is_valid(validity, row_idx);\n+\n+\t\t\t\tprintf(\"Is row %d, col %d valid? %s\\n\", (int)row_idx, (int)col_idx, is_valid ? \"yes\" : \"no\");\n+\t\t\t\tif (col_idx == 4) {\n+\t\t\t\t\t//'dflt_value' column\n+\t\t\t\t\tREQUIRE(is_valid == false);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tduckdb_destroy_data_chunk(&chunk);\n+\t}\n+\n+\tduckdb_destroy_result(&result);\n+\tduckdb_disconnect(&con);\n+\tduckdb_close(&db);\n+}\n+\n TEST_CASE(\"Test Logical Types C API\", \"[capi]\") {\n \tduckdb_logical_type type = duckdb_create_logical_type(DUCKDB_TYPE_BIGINT);\n \tREQUIRE(type);\n",
  "problem_statement": "PRAGMA table_info returns invalid dflt_value using data chunks API\n### What happens?\n\nExecuting `PRAGMA table_info(foo)` returns an invalid value for the `dflt_value` col using the data chunks API. I can't reproduce this with the CLI.\r\n\r\nThe issue is based on an issue I received for the DuckDB Go driver [here](https://github.com/marcboeker/go-duckdb/issues/39).\r\n\r\nDo you have any idea why this happens?\n\n### To Reproduce\n\nSchema:\r\n\r\n`CREATE TABLE foo (id integer)`\r\n\r\nRunning `PRAGMA table_info(foo)` should return 1 row with 6 cols. All columns are reported correctly but except for the `dflt_value` column. \r\n\r\nI'm going this way (simplified) to fetch the data in the go-duckdb client driver:\r\n\r\n1. `chunk = duckdb_result_get_chunk(res, 0)` with res as the result of `PRAGMA table_info(foo)` and 0 for the first chunk.\r\n2. `vector = duckdb_data_chunk_get_vector(chunk, 4)` with 4 as the column index for the `dflt_value` column.\r\n3. `validity = duckdb_vector_get_validity(vector)`\r\n4. Check `duckdb_validity_row_is_valid(validity, 0)` for the first row that always fails with a non null return value.\r\n\r\nThis is the output for `PRAGMA table_info(foo)`:\r\n\r\n```\r\nRow: 0, Col: 0, Name: cid, Value: 0\r\nRow: 0, Col: 1, Name: name, Value: id\r\nRow: 0, Col: 2, Name: type, Value: INTEGER\r\nRow: 0, Col: 3, Name: notnull, Value: false\r\n0x1257bf980 <--- Result from duckdb_vector_get_validity(vector)\r\nError: row is invalid\r\n```\r\n\r\nBut querying for `PRAGMA database_size` works totally fine:\r\n\r\n```\r\nRow: 0, Col: 0, Name: database_size, Value: 0 bytes\r\nRow: 0, Col: 1, Name: block_size, Value: 262144\r\nRow: 0, Col: 2, Name: total_blocks, Value: 0\r\nRow: 0, Col: 3, Name: used_blocks, Value: 0\r\nRow: 0, Col: 4, Name: free_blocks, Value: 0\r\nRow: 0, Col: 5, Name: wal_size, Value: 563 bytes\r\nRow: 0, Col: 6, Name: memory_usage, Value: 0 bytes\r\nRow: 0, Col: 7, Name: memory_limit, Value: 27.4GB\r\n```\r\n\r\nSo I went to `src/function/table/system/pragma_table_info.cpp` and changed `output.SetValue(4, index, def_value);` to `output.SetValue(4, index, Value(column.Name()));` just to return some other value and whoops the verification for validity doesn't complain anymore, except I'm now returning the column's name instead of its default value.\r\n\r\n```\r\nRow: 0, Col: 0, Name: cid, Value: 0\r\nRow: 0, Col: 1, Name: name, Value: id\r\nRow: 0, Col: 2, Name: type, Value: INTEGER\r\nRow: 0, Col: 3, Name: notnull, Value: false\r\nRow: 0, Col: 4, Name: dflt_value, Value: id <--- Now the column's name \"id\" is returned\r\nRow: 0, Col: 5, Name: pk, Value: false\r\n```\n\n### OS:\n\nmacOS\n\n### DuckDB Version:\n\n0.4.0\n\n### DuckDB Client:\n\ngo-duckdb\n\n### Full Name:\n\nMarc Boeker\n\n### Affiliation:\n\nPrivate\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "So the default value should be `NULL` for this row/column because there is no default value. So `duckdb_validity_row_is_valid` should return `false`, but it looks like from what you wrote that this is not the case, right?\nExactly. I'm getting `0x1257bf980` instead of `false`.\njust a note that we'd also love a fix for this specific issue ~ we filed the original issue linked above.\nThijs, can you have a look please?\nI can not seem to reproduce this, I've created this test for it:\r\n```c\r\nTEST_CASE(\"Test invalid pragma_table_info return\", \"[capi]\") {\r\n\tduckdb_database db;\r\n\tduckdb_connection con;\r\n\tduckdb_result result;\r\n\tduckdb_result result_count;\r\n\r\n\tREQUIRE(duckdb_open(NULL, &db) != DuckDBError);\r\n\tREQUIRE(duckdb_connect(db, &con) != DuckDBError);\r\n\tREQUIRE(duckdb_query(con, \"CREATE TABLE foo (id integer);\", NULL) != DuckDBError);\r\n\tREQUIRE(duckdb_query(con, \"PRAGMA table_info(foo);\", &result) != DuckDBError);\r\n\tduckdb_data_chunk chunk = duckdb_result_get_chunk(result, 0);\r\n\tduckdb_vector vector = duckdb_data_chunk_get_vector(chunk, 4);\r\n\tuint64_t* validity = duckdb_vector_get_validity(vector);\r\n\tbool is_valid = duckdb_validity_row_is_valid(validity, 0);\r\n\tprintf(\"Is row 0, column 4 valid ? %s\\n\", is_valid ? \"true\" : \"false\");\r\n\r\n\tduckdb_destroy_result(&result);\r\n\tduckdb_destroy_data_chunk(&chunk);\r\n}\r\n```\r\nand this outputs:\r\n```\r\nIs row 0, column 4 valid ? false\r\n```\r\nWhich is what we're expecting, because there is no default value supplied right?\r\n\r\nI don't get the error you were getting, am I missing something in my reproduction?\nHi Tishj, \r\n\r\nThanks for looking into this! I tried to replicate your test case on v0.5 and also found that it works as expected. So instead, I tried to replicate the bug from the source issue (https://github.com/marcboeker/go-duckdb/issues/39) purely in C.\r\n\r\nFor me, it seems I only encounter the bug on the 32nd row in the result. Here's my C code:\r\n\r\n```c\r\n#import <stdio.h>\r\n#import <duckdb.h>\r\n\r\n// Based on tools/juliapkg/src/ctypes.jl:126\r\nstruct duckdb_string_t {\r\n    uint32_t length;\r\n    char prefix[12];\r\n};\r\ntypedef struct duckdb_string_t duckdb_string_t;\r\n\r\nint main() {\r\n    duckdb_database db;\r\n    if (duckdb_open(NULL, &db) == DuckDBError) {\r\n        printf(\"error: duckdb_open\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    duckdb_connection con;\r\n    if (duckdb_connect(db, &con) == DuckDBError) {\r\n        printf(\"error: duckdb_connect\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    if (duckdb_query(con, \"INSTALL 'parquet'; LOAD 'parquet';\", NULL) == DuckDBError) {\r\n        printf(\"error: duckdb_query: install parquet\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    // Using dataset from: https://github.com/marcboeker/go-duckdb/issues/39\r\n    char *query = \"CREATE OR REPLACE TABLE foo AS SELECT * FROM 'nyc311-reduced.parquet';\";\r\n    if (duckdb_query(con, query, NULL) == DuckDBError) {\r\n        printf(\"error: duckdb_query: create table\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    // // I was able to partially replicate the bug with this empty table. However, it's slightly less \"exotic\"\u00a0-- it always reports the string length of row 31, col 4 as 0.\r\n    // char *query = \"CREATE OR REPLACE TABLE foo (c00 varchar, c01 varchar, c02 varchar, c03 varchar, c04 varchar, c05 varchar, c06 varchar, c07 varchar, c08 varchar, c09 varchar, c10 varchar, c11 varchar, c12 varchar, c13 varchar, c14 varchar, c15 varchar, c16 varchar, c17 varchar, c18 varchar, c19 varchar, c20 varchar, c21 varchar, c22 varchar, c23 varchar, c24 varchar, c25 varchar, c26 varchar, c27 varchar, c28 varchar, c29 varchar, c30 varchar, c31 varchar, c32 varchar, c33 varchar, c34 varchar, c35 varchar, c36 varchar, c37 varchar, c38 varchar, c39 varchar);\";\r\n    // if (duckdb_query(con, query, NULL) == DuckDBError) {\r\n    //     printf(\"error: duckdb_query: create table\\n\");\r\n    //     exit(1);\r\n    // }\r\n\r\n    duckdb_result result;\r\n    query = \"PRAGMA table_info(foo);\";\r\n    if (duckdb_query(con, query, &result) == DuckDBError) {\r\n        printf(\"error: duckdb_query: pragma table_info\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    idx_t col_count = duckdb_column_count(&result);\r\n    idx_t chunk_count = duckdb_result_chunk_count(result);\r\n\r\n    for (idx_t chunk_idx = 0; chunk_idx <= chunk_count; chunk_idx++) { // For each chunk\r\n        duckdb_data_chunk chunk = duckdb_result_get_chunk(result, chunk_idx);\r\n        idx_t row_count = duckdb_data_chunk_get_size(chunk);\r\n\r\n        for (idx_t row_idx = 0; row_idx < row_count; row_idx++) { // For each row in chunk\r\n            for (idx_t col_idx = 0; col_idx < col_count; col_idx++) { // For each column in chunk\r\n                duckdb_vector vector = duckdb_data_chunk_get_vector(chunk, col_idx);\r\n                uint64_t *validity = duckdb_vector_get_validity(vector);\r\n                bool is_valid = duckdb_validity_row_is_valid(validity, row_idx);\r\n\r\n                printf(\"Is row %d, col %d valid? %s\\n\", (int)row_idx, (int)col_idx, is_valid ? \"yes\" : \"no\");\r\n\r\n                if (is_valid && col_idx == 4) {\r\n                    void* data = duckdb_vector_get_data(vector);\r\n                    duckdb_string_t s = ((duckdb_string_t *)data)[row_idx];\r\n                    printf(\"Length of string at row %d, col %d is: %d\\n\", (int)row_idx, (int)col_idx, s.length);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    duckdb_destroy_result(&result);    \r\n}\r\n```\r\n\r\nAnd here's the output I'm seeing:\r\n\r\n```\r\n...\r\nIs row 30, col 0 valid? yes\r\nIs row 30, col 1 valid? yes\r\nIs row 30, col 2 valid? yes\r\nIs row 30, col 3 valid? yes\r\nIs row 30, col 4 valid? no\r\nIs row 30, col 5 valid? yes\r\nIs row 31, col 0 valid? yes\r\nIs row 31, col 1 valid? yes\r\nIs row 31, col 2 valid? yes\r\nIs row 31, col 3 valid? yes\r\nIs row 31, col 4 valid? yes\r\nLength of string at row 31, col 4 is: 1163023443\r\nIs row 31, col 5 valid? yes\r\nIs row 32, col 0 valid? yes\r\nIs row 32, col 1 valid? yes\r\nIs row 32, col 2 valid? yes\r\nIs row 32, col 3 valid? yes\r\nIs row 32, col 4 valid? no\r\nIs row 32, col 5 valid? yes\r\n...\r\n```\r\n\r\nThe C code above is largely based on the methodology used in the `go-duckdb` driver. As an aside, the `chunk_idx <= chunk_count` check in the for loop looks weird to me (but seems unrelated to the bug).\nAnother note, I also tried to adapt your test case to use a table with more than 32 columns, and that also replicates a variant of the bug:\r\n\r\n```c++\r\nTEST_CASE(\"Test invalid pragma_table_info return\", \"[capi]\") {\r\n\tduckdb_database db;\r\n\tduckdb_connection con;\r\n\tduckdb_result result;\r\n\r\n\tREQUIRE(duckdb_open(NULL, &db) != DuckDBError);\r\n\tREQUIRE(duckdb_connect(db, &con) != DuckDBError);\r\n\tREQUIRE(duckdb_query(con, \"CREATE TABLE foo (c00 varchar, c01 varchar, c02 varchar, c03 varchar, c04 varchar, c05 varchar, c06 varchar, c07 varchar, c08 varchar, c09 varchar, c10 varchar, c11 varchar, c12 varchar, c13 varchar, c14 varchar, c15 varchar, c16 varchar, c17 varchar, c18 varchar, c19 varchar, c20 varchar, c21 varchar, c22 varchar, c23 varchar, c24 varchar, c25 varchar, c26 varchar, c27 varchar, c28 varchar, c29 varchar, c30 varchar, c31 varchar, c32 varchar, c33 varchar, c34 varchar, c35 varchar, c36 varchar, c37 varchar, c38 varchar, c39 varchar);\", NULL) != DuckDBError);\r\n\tREQUIRE(duckdb_query(con, \"PRAGMA table_info(foo);\", &result) != DuckDBError);\r\n\r\n\tidx_t col_count = duckdb_column_count(&result);\r\n\tidx_t chunk_count = duckdb_result_chunk_count(result);\r\n\r\n\tfor (idx_t chunk_idx = 0; chunk_idx <= chunk_count; chunk_idx++) {\r\n\t\tduckdb_data_chunk chunk = duckdb_result_get_chunk(result, chunk_idx);\r\n\t\tidx_t row_count = duckdb_data_chunk_get_size(chunk);\r\n\r\n\t\tfor (idx_t row_idx = 0; row_idx < row_count; row_idx++) {\r\n\t\t\tfor (idx_t col_idx = 0; col_idx < col_count; col_idx++) {\r\n\t\t\t\tduckdb_vector vector = duckdb_data_chunk_get_vector(chunk, col_idx);\r\n\t\t\t\tuint64_t* validity = duckdb_vector_get_validity(vector);\r\n\t\t\t\tbool is_valid = duckdb_validity_row_is_valid(validity, row_idx);\r\n\r\n\t\t\t\tprintf(\"Is row %d, col %d valid? %s\\n\", (int)row_idx, (int)col_idx, is_valid ? \"yes\" : \"no\");\r\n\t\t\t}\r\n\t\t}\t\r\n\t}\r\n\t\r\n\tduckdb_destroy_result(&result);\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nIs row 29, col 5 valid? yes\r\nIs row 30, col 0 valid? yes\r\nIs row 30, col 1 valid? yes\r\nIs row 30, col 2 valid? yes\r\nIs row 30, col 3 valid? yes\r\nIs row 30, col 4 valid? no\r\nIs row 30, col 5 valid? yes\r\nIs row 31, col 0 valid? yes\r\nIs row 31, col 1 valid? yes\r\nIs row 31, col 2 valid? yes\r\nIs row 31, col 3 valid? yes\r\nIs row 31, col 4 valid? yes\r\nIs row 31, col 5 valid? yes\r\n/Users/.../data_chunk-c.cpp:145:34: runtime error: shift exponent 32 is too large for 32-bit type 'int'\r\n```\r\n\r\nHere you also see the wrong `Is row 31, col 4 valid? yes` output. Not sure whether the runtime error that follows is related to the bug \u2013 might just be me running the tests wrongly.\nHey! Thank you for the additional reproductions, that will help a lot!\r\nI'm sorry I didn't respond sooner, it seems I did not receive any e-mail notifications on this somehow..",
  "created_at": "2022-09-09T11:09:48Z"
}