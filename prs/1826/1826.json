{
  "repo": "duckdb/duckdb",
  "pull_number": 1826,
  "instance_id": "duckdb__duckdb-1826",
  "issue_numbers": [
    "1724"
  ],
  "base_commit": "6d3586322e55390fd5d9280febaf4d53fdc927c0",
  "patch": "diff --git a/src/common/limits.cpp b/src/common/limits.cpp\nindex 9a4d2bc1162a..4ef56778dc97 100644\n--- a/src/common/limits.cpp\n+++ b/src/common/limits.cpp\n@@ -90,7 +90,7 @@ uint64_t NumericLimits<uint64_t>::Maximum() {\n \n hugeint_t NumericLimits<hugeint_t>::Minimum() {\n \thugeint_t result;\n-\tresult.lower = 0;\n+\tresult.lower = 1;\n \tresult.upper = numeric_limits<int64_t>::lowest();\n \treturn result;\n }\ndiff --git a/src/common/types/hugeint.cpp b/src/common/types/hugeint.cpp\nindex e904071a5499..c42e6e60e24d 100644\n--- a/src/common/types/hugeint.cpp\n+++ b/src/common/types/hugeint.cpp\n@@ -347,7 +347,8 @@ bool Hugeint::SubtractInPlace(hugeint_t &lhs, hugeint_t rhs) {\n \t\t}\n \t} else {\n \t\t// RHS is negative: check for overflow\n-\t\tif (lhs.upper >= (std::numeric_limits<int64_t>::max() + rhs.upper + underflow - 1)) {\n+\t\tif (lhs.upper > std::numeric_limits<int64_t>::min() &&\n+\t\t    lhs.upper - 1 >= (std::numeric_limits<int64_t>::max() + rhs.upper + underflow)) {\n \t\t\treturn false;\n \t\t}\n \t}\n",
  "test_patch": "diff --git a/test/sql/types/hugeint/test_hugeint_arithmetic.test b/test/sql/types/hugeint/test_hugeint_arithmetic.test\nindex 64512fb6eeb9..01438c0dd7fa 100644\n--- a/test/sql/types/hugeint/test_hugeint_arithmetic.test\n+++ b/test/sql/types/hugeint/test_hugeint_arithmetic.test\n@@ -191,3 +191,123 @@ query II\n SELECT ABS('100'::HUGEINT), ABS('-100'::HUGEINT);;\n ----\n 100\t100\n+\n+# addition\n+query I\n+SELECT '-170141183460469231731687303715884105726'::HUGEINT + -1;\n+----\n+-170141183460469231731687303715884105727\n+\n+query I\n+SELECT '170141183460469231731687303715884105726'::HUGEINT + 1;\n+----\n+170141183460469231731687303715884105727\n+\n+statement error\n+SELECT -170141183460469231731687303715884105727 + -1;\n+\n+statement error\n+SELECT 170141183460469231731687303715884105727 + 1;\n+\n+# the other way around (i.e. move away from the overflow direction)\n+query I\n+SELECT '170141183460469231731687303715884105727'::HUGEINT + -1;\n+----\n+170141183460469231731687303715884105726\n+\n+query I\n+SELECT '-170141183460469231731687303715884105727'::HUGEINT + 1;\n+----\n+-170141183460469231731687303715884105726\n+\n+# subtraction\n+query I\n+SELECT '-170141183460469231731687303715884105726'::HUGEINT - 1;\n+----\n+-170141183460469231731687303715884105727\n+\n+statement error\n+SELECT -170141183460469231731687303715884105727 - 1;\n+\n+query I\n+SELECT 170141183460469231731687303715884105724 - (-1);\n+----\n+170141183460469231731687303715884105725\n+\n+query I\n+SELECT 170141183460469231731687303715884105725 - (-1);\n+----\n+170141183460469231731687303715884105726\n+\n+query I\n+SELECT 170141183460469231731687303715884105726 - (-1);\n+----\n+170141183460469231731687303715884105727\n+\n+statement error\n+SELECT 170141183460469231731687303715884105727 - (-1);\n+\n+# the other way around (i.e. move away from the overflow direction)\n+query I\n+SELECT 170141183460469231731687303715884105727 - 1;\n+----\n+170141183460469231731687303715884105726\n+\n+query I\n+SELECT -170141183460469231731687303715884105727 - (-1);\n+----\n+-170141183460469231731687303715884105726\n+\n+# multiplication\n+query I\n+SELECT 170141183460469231731687303715884105727 * 1;\n+----\n+170141183460469231731687303715884105727\n+\n+query I\n+SELECT 170141183460469231731687303715884105727 * -1;\n+----\n+-170141183460469231731687303715884105727\n+\n+query I\n+SELECT -170141183460469231731687303715884105727 * 1;\n+----\n+-170141183460469231731687303715884105727\n+\n+query I\n+SELECT -170141183460469231731687303715884105727 * -1;\n+----\n+170141183460469231731687303715884105727\n+\n+statement error\n+SELECT 85070591730234615865843651857942052864 * 2\n+\n+statement error\n+SELECT -85070591730234615865843651857942052864 * 2\n+\n+statement error\n+SELECT 85070591730234615865843651857942052864 * -2\n+\n+statement error\n+SELECT -85070591730234615865843651857942052864 * -2\n+\n+# division\n+query I\n+SELECT 170141183460469231731687303715884105727 / 1;\n+----\n+170141183460469231731687303715884105727\n+\n+query I\n+SELECT 170141183460469231731687303715884105727 / -1;\n+----\n+-170141183460469231731687303715884105727\n+\n+query I\n+SELECT -170141183460469231731687303715884105727 / 1;\n+----\n+-170141183460469231731687303715884105727\n+\n+query I\n+SELECT -170141183460469231731687303715884105727 / -1;\n+----\n+170141183460469231731687303715884105727\n",
  "problem_statement": "Lower bound and subtraction overflow bugs in hugeint_t\n**What does happen?**\r\n1. The minimum value of `hugeint_t` defined in `src/common/limits.cpp` does not match the minimum value in https://duckdb.org/docs/sql/data_types/numeric.  \r\n \r\n2.  `NumericLimits<hugeint_t>::Maximum() - 1` minus `-1` (both of them are `hugeint_t`) causes subtraction overflow.\r\n\r\n**What should happen?**\r\nDescribe what you expect DuckDB to do instead.\r\nHere is the existing definition of minimum value of hugeint_t.\r\n```cpp\r\nhugeint_t NumericLimits<hugeint_t>::Minimum() {\r\n\thugeint_t result;\r\n\tresult.lower = 1;\r\n\tresult.upper = numeric_limits<int64_t>::lowest() + 1;\r\n\treturn result;\r\n}\r\n```\r\nThe actual value is `-170141183460469231713240559642174554111` instead of `-170141183460469231731687303715884105727`\r\nI think it might be :\r\n```cpp\r\nhugeint_t NumericLimits<hugeint_t>::Minimum() {\r\n\thugeint_t result;\r\n\tresult.lower = 1;\r\n\tresult.upper = numeric_limits<int64_t>::lowest();\r\n\treturn result;\r\n}\r\n```\r\n2. The subtraction should not lead to overflow and return `NumericLimits<hugeint_t>::Maximum()`, that is `170141183460469231731687303715884105727`\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n1.  Use `HugeInt::ToString( NumericLimits<hugeint_t>::Minimum()` to get the string of existing minimum value.\r\n2. The bug could be reproduced by the following python code.\r\n\r\n```python\r\nimport duckdb\r\ncur = duckdb.connect(database=':memory:', read_only=False)\r\ncur.execute(\"select 170141183460469231731687303715884105726 - (-1)\").fetchall()\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nRuntimeError: Out of Range Error: Underflow in HUGEINT addition\r\n```\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Ubuntu 20.04\r\n - DuckDB Version 22\r\n \r\n**Before submitting**\r\n- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\n",
  "hints_text": "Thanks for the report and in-depth investigation! I think you are correct, the +1 should not be there in the `upper` part of the hugeint. Could you perhaps send a PR with a fix for this, ideally combined with a SQL test that demonstrates the issue?\n> Thanks for the report and in-depth investigation! I think you are correct, the +1 should not be there in the `upper` part of the hugeint. Could you perhaps send a PR with a fix for this, ideally combined with a SQL test that demonstrates the issue?\r\n\r\nThanks for the reply. \r\nI think the reason why the bug is implicit is that the minimum value of `hugeint_t` is only used in https://github.com/duckdb/duckdb/blob/master/src/common/operator/cast_operators.cpp#L1548. I tried many SQL statements to trigger the bug but failed.  \r\nI am wondering if my second issue is a bug or a just feature.   \nIndeed it seems that this issue might not be triggerable from SQL, as the hugeint <> string conversion uses a separate code path, and the double <> hugeint conversion path has floating point accuracy problems that might make it difficult to come up with an exact test case. Could you just send a PR that corrects the minimum value?\r\n\r\n\nFor the second problem, the overflow detection in https://github.com/duckdb/duckdb/blob/master/src/common/types/hugeint.cpp#L349 looks strange. I am wondering why there is a `+1`. I think `lhs.upper >= (std::numeric_limits<int64_t>::max() + rhs.upper + underflow` is enough.\nThat should be detectable using SQL. If that is wrong could you make a SQL test that shows that?\n> That should be detectable using SQL. If that is wrong could you make a SQL test that shows that?\r\n\r\nI use python API to show the bug.\r\n\r\n```python\r\nimport duckdb\r\ncur = duckdb.connect(database=':memory:', read_only=False)\r\ncur.execute(\"select 170141183460469231731687303715884105726 - (-1)\").fetchall()\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nRuntimeError: Out of Range Error: Underflow in HUGEINT addition\r\n```\nGreat! Thanks. Could you submit a PR that fixes this and adds the broken query to the hugeint arithmetic tests (`test/sql/types/hugeint/test_hugeint_arithmetic.test`)?\n> Great! Thanks. Could you submit a PR that fixes this and adds the broken query to the hugeint arithmetic tests (`test/sql/types/hugeint/test_hugeint_arithmetic.test`)?\r\n\r\nI will do it later.",
  "created_at": "2021-06-01T06:14:11Z"
}