You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Lower bound and subtraction overflow bugs in hugeint_t
**What does happen?**
1. The minimum value of `hugeint_t` defined in `src/common/limits.cpp` does not match the minimum value in https://duckdb.org/docs/sql/data_types/numeric.  
 
2.  `NumericLimits<hugeint_t>::Maximum() - 1` minus `-1` (both of them are `hugeint_t`) causes subtraction overflow.

**What should happen?**
Describe what you expect DuckDB to do instead.
Here is the existing definition of minimum value of hugeint_t.
```cpp
hugeint_t NumericLimits<hugeint_t>::Minimum() {
	hugeint_t result;
	result.lower = 1;
	result.upper = numeric_limits<int64_t>::lowest() + 1;
	return result;
}
```
The actual value is `-170141183460469231713240559642174554111` instead of `-170141183460469231731687303715884105727`
I think it might be :
```cpp
hugeint_t NumericLimits<hugeint_t>::Minimum() {
	hugeint_t result;
	result.lower = 1;
	result.upper = numeric_limits<int64_t>::lowest();
	return result;
}
```
2. The subtraction should not lead to overflow and return `NumericLimits<hugeint_t>::Maximum()`, that is `170141183460469231731687303715884105727`

**To Reproduce**
Steps to reproduce the behavior. Bonus points if those are only SQL queries.
1.  Use `HugeInt::ToString( NumericLimits<hugeint_t>::Minimum()` to get the string of existing minimum value.
2. The bug could be reproduced by the following python code.

```python
import duckdb
cur = duckdb.connect(database=':memory:', read_only=False)
cur.execute("select 170141183460469231731687303715884105726 - (-1)").fetchall()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
RuntimeError: Out of Range Error: Underflow in HUGEINT addition
```

**Environment (please complete the following information):**
 - OS: Ubuntu 20.04
 - DuckDB Version 22
 
**Before submitting**
- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?
- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds


</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/common/limits.cpp]
1: #include "duckdb/common/limits.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/windows_undefs.hpp"
5: #include <limits>
6: 
7: namespace duckdb {
8: 
9: using std::numeric_limits;
10: 
11: int8_t NumericLimits<int8_t>::Minimum() {
12: 	return numeric_limits<int8_t>::lowest();
13: }
14: 
15: int8_t NumericLimits<int8_t>::Maximum() {
16: 	return numeric_limits<int8_t>::max();
17: }
18: 
19: int16_t NumericLimits<int16_t>::Minimum() {
20: 	return numeric_limits<int16_t>::lowest();
21: }
22: 
23: int16_t NumericLimits<int16_t>::Maximum() {
24: 	return numeric_limits<int16_t>::max();
25: }
26: 
27: int32_t NumericLimits<int32_t>::Minimum() {
28: 	return numeric_limits<int32_t>::lowest();
29: }
30: 
31: int32_t NumericLimits<int32_t>::Maximum() {
32: 	return numeric_limits<int32_t>::max();
33: }
34: 
35: int64_t NumericLimits<int64_t>::Minimum() {
36: 	return numeric_limits<int64_t>::lowest();
37: }
38: 
39: int64_t NumericLimits<int64_t>::Maximum() {
40: 	return numeric_limits<int64_t>::max();
41: }
42: 
43: float NumericLimits<float>::Minimum() {
44: 	return numeric_limits<float>::lowest();
45: }
46: 
47: float NumericLimits<float>::Maximum() {
48: 	return numeric_limits<float>::max();
49: }
50: 
51: double NumericLimits<double>::Minimum() {
52: 	return numeric_limits<double>::lowest();
53: }
54: 
55: double NumericLimits<double>::Maximum() {
56: 	return numeric_limits<double>::max();
57: }
58: 
59: uint8_t NumericLimits<uint8_t>::Minimum() {
60: 	return numeric_limits<uint8_t>::lowest();
61: }
62: 
63: uint8_t NumericLimits<uint8_t>::Maximum() {
64: 	return numeric_limits<uint8_t>::max();
65: }
66: 
67: uint16_t NumericLimits<uint16_t>::Minimum() {
68: 	return numeric_limits<uint16_t>::lowest();
69: }
70: 
71: uint16_t NumericLimits<uint16_t>::Maximum() {
72: 	return numeric_limits<uint16_t>::max();
73: }
74: 
75: uint32_t NumericLimits<uint32_t>::Minimum() {
76: 	return numeric_limits<uint32_t>::lowest();
77: }
78: 
79: uint32_t NumericLimits<uint32_t>::Maximum() {
80: 	return numeric_limits<uint32_t>::max();
81: }
82: 
83: uint64_t NumericLimits<uint64_t>::Minimum() {
84: 	return numeric_limits<uint64_t>::lowest();
85: }
86: 
87: uint64_t NumericLimits<uint64_t>::Maximum() {
88: 	return numeric_limits<uint64_t>::max();
89: }
90: 
91: hugeint_t NumericLimits<hugeint_t>::Minimum() {
92: 	hugeint_t result;
93: 	result.lower = 0;
94: 	result.upper = numeric_limits<int64_t>::lowest();
95: 	return result;
96: }
97: 
98: hugeint_t NumericLimits<hugeint_t>::Maximum() {
99: 	hugeint_t result;
100: 	result.lower = numeric_limits<uint64_t>::max();
101: 	result.upper = numeric_limits<int64_t>::max();
102: 	return result;
103: }
104: 
105: // we offset the minimum value by 1 to account for the NULL value in the
106: // hashtables
107: static int64_t MinimumValue(PhysicalType type) {
108: 	switch (type) {
109: 	case PhysicalType::INT8:
110: 		return NumericLimits<int8_t>::Minimum();
111: 	case PhysicalType::INT16:
112: 		return NumericLimits<int16_t>::Minimum();
113: 	case PhysicalType::INT32:
114: 		return NumericLimits<int32_t>::Minimum();
115: 	case PhysicalType::INT64:
116: 	case PhysicalType::INT128:
117: 		return NumericLimits<int64_t>::Minimum();
118: 	default:
119: 		throw InvalidTypeException(type, "MinimumValue requires integral type");
120: 	}
121: }
122: 
123: static uint64_t MaximumValue(PhysicalType type) {
124: 	switch (type) {
125: 	case PhysicalType::INT8:
126: 		return NumericLimits<int8_t>::Maximum();
127: 	case PhysicalType::INT16:
128: 		return NumericLimits<int16_t>::Maximum();
129: 	case PhysicalType::INT32:
130: 		return NumericLimits<int32_t>::Maximum();
131: 	case PhysicalType::INT64:
132: 	case PhysicalType::INT128:
133: 		return NumericLimits<int64_t>::Maximum();
134: 	default:
135: 		throw InvalidTypeException(type, "MaximumValue requires integral type");
136: 	}
137: }
138: 
139: PhysicalType MinimalType(int64_t value) {
140: 	if (value >= MinimumValue(PhysicalType::INT8) && (uint64_t)value <= MaximumValue(PhysicalType::INT8)) {
141: 		return PhysicalType::INT8;
142: 	}
143: 	if (value >= MinimumValue(PhysicalType::INT16) && (uint64_t)value <= MaximumValue(PhysicalType::INT16)) {
144: 		return PhysicalType::INT16;
145: 	}
146: 	if (value >= MinimumValue(PhysicalType::INT32) && (uint64_t)value <= MaximumValue(PhysicalType::INT32)) {
147: 		return PhysicalType::INT32;
148: 	}
149: 	return PhysicalType::INT64;
150: }
151: 
152: } // namespace duckdb
[end of src/common/limits.cpp]
[start of src/common/types/hugeint.cpp]
1: #include "duckdb/common/types/hugeint.hpp"
2: #include "duckdb/common/exception.hpp"
3: #include "duckdb/common/algorithm.hpp"
4: #include "duckdb/common/limits.hpp"
5: 
6: #include <cmath>
7: #include <limits>
8: 
9: namespace duckdb {
10: 
11: //===--------------------------------------------------------------------===//
12: // String Conversion
13: //===--------------------------------------------------------------------===//
14: const hugeint_t Hugeint::POWERS_OF_TEN[] {
15:     hugeint_t(1),
16:     hugeint_t(10),
17:     hugeint_t(100),
18:     hugeint_t(1000),
19:     hugeint_t(10000),
20:     hugeint_t(100000),
21:     hugeint_t(1000000),
22:     hugeint_t(10000000),
23:     hugeint_t(100000000),
24:     hugeint_t(1000000000),
25:     hugeint_t(10000000000),
26:     hugeint_t(100000000000),
27:     hugeint_t(1000000000000),
28:     hugeint_t(10000000000000),
29:     hugeint_t(100000000000000),
30:     hugeint_t(1000000000000000),
31:     hugeint_t(10000000000000000),
32:     hugeint_t(100000000000000000),
33:     hugeint_t(1000000000000000000),
34:     hugeint_t(1000000000000000000) * hugeint_t(10),
35:     hugeint_t(1000000000000000000) * hugeint_t(100),
36:     hugeint_t(1000000000000000000) * hugeint_t(1000),
37:     hugeint_t(1000000000000000000) * hugeint_t(10000),
38:     hugeint_t(1000000000000000000) * hugeint_t(100000),
39:     hugeint_t(1000000000000000000) * hugeint_t(1000000),
40:     hugeint_t(1000000000000000000) * hugeint_t(10000000),
41:     hugeint_t(1000000000000000000) * hugeint_t(100000000),
42:     hugeint_t(1000000000000000000) * hugeint_t(1000000000),
43:     hugeint_t(1000000000000000000) * hugeint_t(10000000000),
44:     hugeint_t(1000000000000000000) * hugeint_t(100000000000),
45:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000),
46:     hugeint_t(1000000000000000000) * hugeint_t(10000000000000),
47:     hugeint_t(1000000000000000000) * hugeint_t(100000000000000),
48:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000),
49:     hugeint_t(1000000000000000000) * hugeint_t(10000000000000000),
50:     hugeint_t(1000000000000000000) * hugeint_t(100000000000000000),
51:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000000),
52:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000000) * hugeint_t(10),
53:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000000) * hugeint_t(100)};
54: 
55: static uint8_t PositiveHugeintHighestBit(hugeint_t bits) {
56: 	uint8_t out = 0;
57: 	if (bits.upper) {
58: 		out = 64;
59: 		uint64_t up = bits.upper;
60: 		while (up) {
61: 			up >>= 1;
62: 			out++;
63: 		}
64: 	} else {
65: 		uint64_t low = bits.lower;
66: 		while (low) {
67: 			low >>= 1;
68: 			out++;
69: 		}
70: 	}
71: 	return out;
72: }
73: 
74: static bool PositiveHugeintIsBitSet(hugeint_t lhs, uint8_t bit_position) {
75: 	if (bit_position < 64) {
76: 		return lhs.lower & (uint64_t(1) << uint64_t(bit_position));
77: 	} else {
78: 		return lhs.upper & (uint64_t(1) << uint64_t(bit_position - 64));
79: 	}
80: }
81: 
82: hugeint_t PositiveHugeintLeftShift(hugeint_t lhs, uint32_t amount) {
83: 	D_ASSERT(amount > 0 && amount < 64);
84: 	hugeint_t result;
85: 	result.lower = lhs.lower << amount;
86: 	result.upper = (lhs.upper << amount) + (lhs.lower >> (64 - amount));
87: 	return result;
88: }
89: 
90: hugeint_t Hugeint::DivModPositive(hugeint_t lhs, uint64_t rhs, uint64_t &remainder) {
91: 	D_ASSERT(lhs.upper >= 0);
92: 	// DivMod code adapted from:
93: 	// https://github.com/calccrypto/uint128_t/blob/master/uint128_t.cpp
94: 
95: 	// initialize the result and remainder to 0
96: 	hugeint_t div_result;
97: 	div_result.lower = 0;
98: 	div_result.upper = 0;
99: 	remainder = 0;
100: 
101: 	uint8_t highest_bit_set = PositiveHugeintHighestBit(lhs);
102: 	// now iterate over the amount of bits that are set in the LHS
103: 	for (uint8_t x = highest_bit_set; x > 0; x--) {
104: 		// left-shift the current result and remainder by 1
105: 		div_result = PositiveHugeintLeftShift(div_result, 1);
106: 		remainder <<= 1;
107: 		// we get the value of the bit at position X, where position 0 is the least-significant bit
108: 		if (PositiveHugeintIsBitSet(lhs, x - 1)) {
109: 			// increment the remainder
110: 			remainder++;
111: 		}
112: 		if (remainder >= rhs) {
113: 			// the remainder has passed the division multiplier: add one to the divide result
114: 			remainder -= rhs;
115: 			div_result.lower++;
116: 			if (div_result.lower == 0) {
117: 				// overflow
118: 				div_result.upper++;
119: 			}
120: 		}
121: 	}
122: 	return div_result;
123: }
124: 
125: string Hugeint::ToString(hugeint_t input) {
126: 	uint64_t remainder;
127: 	string result;
128: 	bool negative = input.upper < 0;
129: 	if (negative) {
130: 		NegateInPlace(input);
131: 	}
132: 	while (true) {
133: 		if (!input.lower && !input.upper) {
134: 			break;
135: 		}
136: 		input = Hugeint::DivModPositive(input, 10, remainder);
137: 		result = string(1, '0' + remainder) + result; // NOLINT
138: 	}
139: 	if (result.empty()) {
140: 		// value is zero
141: 		return "0";
142: 	}
143: 	return negative ? "-" + result : result;
144: }
145: 
146: //===--------------------------------------------------------------------===//
147: // Multiply
148: //===--------------------------------------------------------------------===//
149: bool Hugeint::TryMultiply(hugeint_t lhs, hugeint_t rhs, hugeint_t &result) {
150: 	bool lhs_negative = lhs.upper < 0;
151: 	bool rhs_negative = rhs.upper < 0;
152: 	if (lhs_negative) {
153: 		NegateInPlace(lhs);
154: 	}
155: 	if (rhs_negative) {
156: 		NegateInPlace(rhs);
157: 	}
158: #if ((__GNUC__ >= 5) || defined(__clang__)) && defined(__SIZEOF_INT128__)
159: 	__uint128_t left = __uint128_t(lhs.lower) + (__uint128_t(lhs.upper) << 64);
160: 	__uint128_t right = __uint128_t(rhs.lower) + (__uint128_t(rhs.upper) << 64);
161: 	__uint128_t result_i128;
162: 	if (__builtin_mul_overflow(left, right, &result_i128)) {
163: 		return false;
164: 	}
165: 	uint64_t upper = uint64_t(result_i128 >> 64);
166: 	if (upper & 0x8000000000000000) {
167: 		return false;
168: 	}
169: 	result.upper = int64_t(upper);
170: 	result.lower = uint64_t(result_i128 & 0xffffffffffffffff);
171: #else
172: 	// Multiply code adapted from:
173: 	// https://github.com/calccrypto/uint128_t/blob/master/uint128_t.cpp
174: 
175: 	// split values into 4 32-bit parts
176: 	uint64_t top[4] = {uint64_t(lhs.upper) >> 32, uint64_t(lhs.upper) & 0xffffffff, lhs.lower >> 32,
177: 	                   lhs.lower & 0xffffffff};
178: 	uint64_t bottom[4] = {uint64_t(rhs.upper) >> 32, uint64_t(rhs.upper) & 0xffffffff, rhs.lower >> 32,
179: 	                      rhs.lower & 0xffffffff};
180: 	uint64_t products[4][4];
181: 
182: 	// multiply each component of the values
183: 	for (auto x = 0; x < 4; x++) {
184: 		for (auto y = 0; y < 4; y++) {
185: 			products[x][y] = top[x] * bottom[y];
186: 		}
187: 	}
188: 
189: 	// if any of these products are set to a non-zero value, there is always an overflow
190: 	if (products[0][0] || products[0][1] || products[0][2] || products[1][0] || products[2][0] || products[1][1]) {
191: 		return false;
192: 	}
193: 	// if the high bits of any of these are set, there is always an overflow
194: 	if ((products[0][3] & 0xffffffff80000000) || (products[1][2] & 0xffffffff80000000) ||
195: 	    (products[2][1] & 0xffffffff80000000) || (products[3][0] & 0xffffffff80000000)) {
196: 		return false;
197: 	}
198: 
199: 	// otherwise we merge the result of the different products together in-order
200: 
201: 	// first row
202: 	uint64_t fourth32 = (products[3][3] & 0xffffffff);
203: 	uint64_t third32 = (products[3][2] & 0xffffffff) + (products[3][3] >> 32);
204: 	uint64_t second32 = (products[3][1] & 0xffffffff) + (products[3][2] >> 32);
205: 	uint64_t first32 = (products[3][0] & 0xffffffff) + (products[3][1] >> 32);
206: 
207: 	// second row
208: 	third32 += (products[2][3] & 0xffffffff);
209: 	second32 += (products[2][2] & 0xffffffff) + (products[2][3] >> 32);
210: 	first32 += (products[2][1] & 0xffffffff) + (products[2][2] >> 32);
211: 
212: 	// third row
213: 	second32 += (products[1][3] & 0xffffffff);
214: 	first32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
215: 
216: 	// fourth row
217: 	first32 += (products[0][3] & 0xffffffff);
218: 
219: 	// move carry to next digit
220: 	third32 += fourth32 >> 32;
221: 	second32 += third32 >> 32;
222: 	first32 += second32 >> 32;
223: 
224: 	// check if the combination of the different products resulted in an overflow
225: 	if (first32 & 0xffffff80000000) {
226: 		return false;
227: 	}
228: 
229: 	// remove carry from current digit
230: 	fourth32 &= 0xffffffff;
231: 	third32 &= 0xffffffff;
232: 	second32 &= 0xffffffff;
233: 	first32 &= 0xffffffff;
234: 
235: 	// combine components
236: 	result.lower = (third32 << 32) | fourth32;
237: 	result.upper = (first32 << 32) | second32;
238: #endif
239: 	if (lhs_negative ^ rhs_negative) {
240: 		NegateInPlace(result);
241: 	}
242: 	return true;
243: }
244: 
245: hugeint_t Hugeint::Multiply(hugeint_t lhs, hugeint_t rhs) {
246: 	hugeint_t result;
247: 	if (!TryMultiply(lhs, rhs, result)) {
248: 		throw OutOfRangeException("Overflow in HUGEINT multiplication!");
249: 	}
250: 	return result;
251: }
252: 
253: //===--------------------------------------------------------------------===//
254: // Divide
255: //===--------------------------------------------------------------------===//
256: hugeint_t Hugeint::DivMod(hugeint_t lhs, hugeint_t rhs, hugeint_t &remainder) {
257: 	// division by zero not allowed
258: 	D_ASSERT(!(rhs.upper == 0 && rhs.lower == 0));
259: 
260: 	bool lhs_negative = lhs.upper < 0;
261: 	bool rhs_negative = rhs.upper < 0;
262: 	if (lhs_negative) {
263: 		Hugeint::NegateInPlace(lhs);
264: 	}
265: 	if (rhs_negative) {
266: 		Hugeint::NegateInPlace(rhs);
267: 	}
268: 	// DivMod code adapted from:
269: 	// https://github.com/calccrypto/uint128_t/blob/master/uint128_t.cpp
270: 
271: 	// initialize the result and remainder to 0
272: 	hugeint_t div_result;
273: 	div_result.lower = 0;
274: 	div_result.upper = 0;
275: 	remainder.lower = 0;
276: 	remainder.upper = 0;
277: 
278: 	uint8_t highest_bit_set = PositiveHugeintHighestBit(lhs);
279: 	// now iterate over the amount of bits that are set in the LHS
280: 	for (uint8_t x = highest_bit_set; x > 0; x--) {
281: 		// left-shift the current result and remainder by 1
282: 		div_result = PositiveHugeintLeftShift(div_result, 1);
283: 		remainder = PositiveHugeintLeftShift(remainder, 1);
284: 
285: 		// we get the value of the bit at position X, where position 0 is the least-significant bit
286: 		if (PositiveHugeintIsBitSet(lhs, x - 1)) {
287: 			// increment the remainder
288: 			Hugeint::AddInPlace(remainder, 1);
289: 		}
290: 		if (Hugeint::GreaterThanEquals(remainder, rhs)) {
291: 			// the remainder has passed the division multiplier: add one to the divide result
292: 			remainder = Hugeint::Subtract(remainder, rhs);
293: 			Hugeint::AddInPlace(div_result, 1);
294: 		}
295: 	}
296: 	if (lhs_negative ^ rhs_negative) {
297: 		Hugeint::NegateInPlace(div_result);
298: 	}
299: 	if (lhs_negative) {
300: 		Hugeint::NegateInPlace(remainder);
301: 	}
302: 	return div_result;
303: }
304: 
305: hugeint_t Hugeint::Divide(hugeint_t lhs, hugeint_t rhs) {
306: 	hugeint_t remainder;
307: 	return Hugeint::DivMod(lhs, rhs, remainder);
308: }
309: 
310: hugeint_t Hugeint::Modulo(hugeint_t lhs, hugeint_t rhs) {
311: 	hugeint_t remainder;
312: 	Hugeint::DivMod(lhs, rhs, remainder);
313: 	return remainder;
314: }
315: 
316: //===--------------------------------------------------------------------===//
317: // Add/Subtract
318: //===--------------------------------------------------------------------===//
319: bool Hugeint::AddInPlace(hugeint_t &lhs, hugeint_t rhs) {
320: 	int overflow = lhs.lower + rhs.lower < lhs.lower;
321: 	if (rhs.upper >= 0) {
322: 		// RHS is positive: check for overflow
323: 		if (lhs.upper > (std::numeric_limits<int64_t>::max() - rhs.upper - overflow)) {
324: 			return false;
325: 		}
326: 	} else {
327: 		// RHS is negative: check for underflow
328: 		if (lhs.upper < std::numeric_limits<int64_t>::min() - rhs.upper - overflow) {
329: 			return false;
330: 		}
331: 	}
332: 	lhs.upper = lhs.upper + overflow + rhs.upper;
333: 	lhs.lower += rhs.lower;
334: 	if (lhs.upper == std::numeric_limits<int64_t>::min() && lhs.lower == 0) {
335: 		return false;
336: 	}
337: 	return true;
338: }
339: 
340: bool Hugeint::SubtractInPlace(hugeint_t &lhs, hugeint_t rhs) {
341: 	// underflow
342: 	int underflow = lhs.lower - rhs.lower > lhs.lower;
343: 	if (rhs.upper >= 0) {
344: 		// RHS is positive: check for underflow
345: 		if (lhs.upper < (std::numeric_limits<int64_t>::min() + rhs.upper + underflow)) {
346: 			return false;
347: 		}
348: 	} else {
349: 		// RHS is negative: check for overflow
350: 		if (lhs.upper >= (std::numeric_limits<int64_t>::max() + rhs.upper + underflow - 1)) {
351: 			return false;
352: 		}
353: 	}
354: 	lhs.upper = lhs.upper - rhs.upper - underflow;
355: 	lhs.lower -= rhs.lower;
356: 	if (lhs.upper == std::numeric_limits<int64_t>::min() && lhs.lower == 0) {
357: 		return false;
358: 	}
359: 	return true;
360: }
361: 
362: hugeint_t Hugeint::Add(hugeint_t lhs, hugeint_t rhs) {
363: 	if (!AddInPlace(lhs, rhs)) {
364: 		throw OutOfRangeException("Overflow in HUGEINT addition");
365: 	}
366: 	return lhs;
367: }
368: 
369: hugeint_t Hugeint::Subtract(hugeint_t lhs, hugeint_t rhs) {
370: 	if (!SubtractInPlace(lhs, rhs)) {
371: 		throw OutOfRangeException("Underflow in HUGEINT addition");
372: 	}
373: 	return lhs;
374: }
375: 
376: //===--------------------------------------------------------------------===//
377: // Hugeint Cast/Conversion
378: //===--------------------------------------------------------------------===//
379: template <class DST>
380: bool HugeintTryCastInteger(hugeint_t input, DST &result) {
381: 	switch (input.upper) {
382: 	case 0:
383: 		// positive number: check if the positive number is in range
384: 		if (input.lower <= uint64_t(NumericLimits<DST>::Maximum())) {
385: 			result = DST(input.lower);
386: 			return true;
387: 		}
388: 		break;
389: 	case -1:
390: 		// negative number: check if the negative number is in range
391: 		if (input.lower > NumericLimits<uint64_t>::Maximum() - uint64_t(NumericLimits<DST>::Maximum())) {
392: 			result = -DST(NumericLimits<uint64_t>::Maximum() - input.lower + 1);
393: 			return true;
394: 		}
395: 		break;
396: 	default:
397: 		break;
398: 	}
399: 	return false;
400: }
401: 
402: template <>
403: bool Hugeint::TryCast(hugeint_t input, int8_t &result) {
404: 	return HugeintTryCastInteger<int8_t>(input, result);
405: }
406: 
407: template <>
408: bool Hugeint::TryCast(hugeint_t input, int16_t &result) {
409: 	return HugeintTryCastInteger<int16_t>(input, result);
410: }
411: 
412: template <>
413: bool Hugeint::TryCast(hugeint_t input, int32_t &result) {
414: 	return HugeintTryCastInteger<int32_t>(input, result);
415: }
416: 
417: template <>
418: bool Hugeint::TryCast(hugeint_t input, int64_t &result) {
419: 	return HugeintTryCastInteger<int64_t>(input, result);
420: }
421: 
422: template <>
423: bool Hugeint::TryCast(hugeint_t input, uint8_t &result) {
424: 	return HugeintTryCastInteger<uint8_t>(input, result);
425: }
426: 
427: template <>
428: bool Hugeint::TryCast(hugeint_t input, uint16_t &result) {
429: 	return HugeintTryCastInteger<uint16_t>(input, result);
430: }
431: 
432: template <>
433: bool Hugeint::TryCast(hugeint_t input, uint32_t &result) {
434: 	return HugeintTryCastInteger<uint32_t>(input, result);
435: }
436: 
437: template <>
438: bool Hugeint::TryCast(hugeint_t input, uint64_t &result) {
439: 	return HugeintTryCastInteger<uint64_t>(input, result);
440: }
441: 
442: template <>
443: bool Hugeint::TryCast(hugeint_t input, hugeint_t &result) {
444: 	result = input;
445: 	return true;
446: }
447: 
448: template <>
449: bool Hugeint::TryCast(hugeint_t input, float &result) {
450: 	double dbl_result;
451: 	Hugeint::TryCast(input, dbl_result);
452: 	result = (float)dbl_result;
453: 	return true;
454: }
455: 
456: template <>
457: bool Hugeint::TryCast(hugeint_t input, double &result) {
458: 	switch (input.upper) {
459: 	case -1:
460: 		// special case for upper = -1 to avoid rounding issues in small negative numbers
461: 		result = -double(NumericLimits<uint64_t>::Maximum() - input.lower) - 1;
462: 		break;
463: 	default:
464: 		result = double(input.lower) + double(input.upper) * double(NumericLimits<uint64_t>::Maximum());
465: 		break;
466: 	}
467: 	return true;
468: }
469: 
470: template <class DST>
471: hugeint_t HugeintConvertInteger(DST input) {
472: 	hugeint_t result;
473: 	result.lower = (uint64_t)input;
474: 	result.upper = (input < 0) * -1;
475: 	return result;
476: }
477: 
478: template <>
479: hugeint_t Hugeint::Convert(int8_t value) {
480: 	return HugeintConvertInteger<int8_t>(value);
481: }
482: 
483: template <>
484: hugeint_t Hugeint::Convert(int16_t value) {
485: 	return HugeintConvertInteger<int16_t>(value);
486: }
487: 
488: template <>
489: hugeint_t Hugeint::Convert(int32_t value) {
490: 	return HugeintConvertInteger<int32_t>(value);
491: }
492: 
493: template <>
494: hugeint_t Hugeint::Convert(int64_t value) {
495: 	return HugeintConvertInteger<int64_t>(value);
496: }
497: template <>
498: hugeint_t Hugeint::Convert(uint8_t value) {
499: 	return HugeintConvertInteger<uint8_t>(value);
500: }
501: template <>
502: hugeint_t Hugeint::Convert(uint16_t value) {
503: 	return HugeintConvertInteger<uint16_t>(value);
504: }
505: template <>
506: hugeint_t Hugeint::Convert(uint32_t value) {
507: 	return HugeintConvertInteger<uint32_t>(value);
508: }
509: template <>
510: hugeint_t Hugeint::Convert(uint64_t value) {
511: 	return HugeintConvertInteger<uint64_t>(value);
512: }
513: 
514: template <>
515: hugeint_t Hugeint::Convert(float value) {
516: 	return Hugeint::Convert<double>(value);
517: }
518: 
519: template <>
520: hugeint_t Hugeint::Convert(double value) {
521: 	if (value <= -170141183460469231731687303715884105728.0 || value >= 170141183460469231731687303715884105727.0) {
522: 		throw OutOfRangeException("Double out of range of HUGEINT");
523: 	}
524: 	hugeint_t result;
525: 	bool negative = value < 0;
526: 	if (negative) {
527: 		value = -value;
528: 	}
529: 	result.lower = (uint64_t)fmod(value, double(NumericLimits<uint64_t>::Maximum()));
530: 	result.upper = (uint64_t)(value / double(NumericLimits<uint64_t>::Maximum()));
531: 	if (negative) {
532: 		NegateInPlace(result);
533: 	}
534: 	return result;
535: }
536: 
537: //===--------------------------------------------------------------------===//
538: // hugeint_t operators
539: //===--------------------------------------------------------------------===//
540: hugeint_t::hugeint_t(int64_t value) {
541: 	auto result = Hugeint::Convert(value);
542: 	this->lower = result.lower;
543: 	this->upper = result.upper;
544: }
545: 
546: bool hugeint_t::operator==(const hugeint_t &rhs) const {
547: 	return Hugeint::Equals(*this, rhs);
548: }
549: 
550: bool hugeint_t::operator!=(const hugeint_t &rhs) const {
551: 	return Hugeint::NotEquals(*this, rhs);
552: }
553: 
554: bool hugeint_t::operator<(const hugeint_t &rhs) const {
555: 	return Hugeint::LessThan(*this, rhs);
556: }
557: 
558: bool hugeint_t::operator<=(const hugeint_t &rhs) const {
559: 	return Hugeint::LessThanEquals(*this, rhs);
560: }
561: 
562: bool hugeint_t::operator>(const hugeint_t &rhs) const {
563: 	return Hugeint::GreaterThan(*this, rhs);
564: }
565: 
566: bool hugeint_t::operator>=(const hugeint_t &rhs) const {
567: 	return Hugeint::GreaterThanEquals(*this, rhs);
568: }
569: 
570: hugeint_t hugeint_t::operator+(const hugeint_t &rhs) const {
571: 	return Hugeint::Add(*this, rhs);
572: }
573: 
574: hugeint_t hugeint_t::operator-(const hugeint_t &rhs) const {
575: 	return Hugeint::Subtract(*this, rhs);
576: }
577: 
578: hugeint_t hugeint_t::operator*(const hugeint_t &rhs) const {
579: 	return Hugeint::Multiply(*this, rhs);
580: }
581: 
582: hugeint_t hugeint_t::operator/(const hugeint_t &rhs) const {
583: 	return Hugeint::Divide(*this, rhs);
584: }
585: 
586: hugeint_t hugeint_t::operator%(const hugeint_t &rhs) const {
587: 	return Hugeint::Modulo(*this, rhs);
588: }
589: 
590: hugeint_t hugeint_t::operator-() const {
591: 	return Hugeint::Negate(*this);
592: }
593: 
594: hugeint_t hugeint_t::operator>>(const hugeint_t &rhs) const {
595: 	if (upper < 0) {
596: 		return hugeint_t(0);
597: 	}
598: 	hugeint_t result;
599: 	uint64_t shift = rhs.lower;
600: 	if (rhs.upper != 0 || shift >= 128) {
601: 		return hugeint_t(0);
602: 	} else if (shift == 64) {
603: 		result.upper = 0;
604: 		result.lower = upper;
605: 	} else if (shift == 0) {
606: 		return *this;
607: 	} else if (shift < 64) {
608: 		// perform upper shift in unsigned integer, and mask away the most significant bit
609: 		result.lower = (uint64_t(upper) << (64 - shift)) + (lower >> shift);
610: 		result.upper = uint64_t(upper) >> shift;
611: 	} else {
612: 		D_ASSERT(shift < 128);
613: 		result.lower = uint64_t(upper) >> (shift - 64);
614: 		result.upper = 0;
615: 	}
616: 	return result;
617: }
618: 
619: hugeint_t hugeint_t::operator<<(const hugeint_t &rhs) const {
620: 	if (upper < 0) {
621: 		return hugeint_t(0);
622: 	}
623: 	hugeint_t result;
624: 	uint64_t shift = rhs.lower;
625: 	if (rhs.upper != 0 || shift >= 128) {
626: 		return hugeint_t(0);
627: 	} else if (shift == 64) {
628: 		result.upper = lower;
629: 		result.lower = 0;
630: 	} else if (shift == 0) {
631: 		return *this;
632: 	} else if (shift < 64) {
633: 		// perform upper shift in unsigned integer, and mask away the most significant bit
634: 		uint64_t upper_shift = ((uint64_t(upper) << shift) + (lower >> (64 - shift))) & 0x7FFFFFFFFFFFFFFF;
635: 		result.lower = lower << shift;
636: 		result.upper = upper_shift;
637: 	} else {
638: 		D_ASSERT(shift < 128);
639: 		result.lower = 0;
640: 		result.upper = (lower << (shift - 64)) & 0x7FFFFFFFFFFFFFFF;
641: 	}
642: 	return result;
643: }
644: 
645: hugeint_t hugeint_t::operator&(const hugeint_t &rhs) const {
646: 	hugeint_t result;
647: 	result.lower = lower & rhs.lower;
648: 	result.upper = upper & rhs.upper;
649: 	return result;
650: }
651: 
652: hugeint_t hugeint_t::operator|(const hugeint_t &rhs) const {
653: 	hugeint_t result;
654: 	result.lower = lower | rhs.lower;
655: 	result.upper = upper | rhs.upper;
656: 	return result;
657: }
658: 
659: hugeint_t hugeint_t::operator^(const hugeint_t &rhs) const {
660: 	hugeint_t result;
661: 	result.lower = lower ^ rhs.lower;
662: 	result.upper = upper ^ rhs.upper;
663: 	return result;
664: }
665: 
666: hugeint_t hugeint_t::operator~() const {
667: 	hugeint_t result;
668: 	result.lower = ~lower;
669: 	result.upper = ~upper;
670: 	return result;
671: }
672: 
673: hugeint_t &hugeint_t::operator+=(const hugeint_t &rhs) {
674: 	Hugeint::AddInPlace(*this, rhs);
675: 	return *this;
676: }
677: hugeint_t &hugeint_t::operator-=(const hugeint_t &rhs) {
678: 	Hugeint::SubtractInPlace(*this, rhs);
679: 	return *this;
680: }
681: hugeint_t &hugeint_t::operator*=(const hugeint_t &rhs) {
682: 	*this = Hugeint::Multiply(*this, rhs);
683: 	return *this;
684: }
685: hugeint_t &hugeint_t::operator/=(const hugeint_t &rhs) {
686: 	*this = Hugeint::Divide(*this, rhs);
687: 	return *this;
688: }
689: hugeint_t &hugeint_t::operator%=(const hugeint_t &rhs) {
690: 	*this = Hugeint::Modulo(*this, rhs);
691: 	return *this;
692: }
693: hugeint_t &hugeint_t::operator>>=(const hugeint_t &rhs) {
694: 	*this = *this >> rhs;
695: 	return *this;
696: }
697: hugeint_t &hugeint_t::operator<<=(const hugeint_t &rhs) {
698: 	*this = *this << rhs;
699: 	return *this;
700: }
701: hugeint_t &hugeint_t::operator&=(const hugeint_t &rhs) {
702: 	lower &= rhs.lower;
703: 	upper &= rhs.upper;
704: 	return *this;
705: }
706: hugeint_t &hugeint_t::operator|=(const hugeint_t &rhs) {
707: 	lower |= rhs.lower;
708: 	upper |= rhs.upper;
709: 	return *this;
710: }
711: hugeint_t &hugeint_t::operator^=(const hugeint_t &rhs) {
712: 	lower ^= rhs.lower;
713: 	upper ^= rhs.upper;
714: 	return *this;
715: }
716: 
717: string hugeint_t::ToString() const {
718: 	return Hugeint::ToString(*this);
719: }
720: 
721: } // namespace duckdb
[end of src/common/types/hugeint.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: