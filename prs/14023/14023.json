{
  "repo": "duckdb/duckdb",
  "pull_number": 14023,
  "instance_id": "duckdb__duckdb-14023",
  "issue_numbers": [
    "10961",
    "10961"
  ],
  "base_commit": "e3dd35894dbeed2a2f1a318c06d04a3963931ff9",
  "patch": "diff --git a/.github/config/out_of_tree_extensions.cmake b/.github/config/out_of_tree_extensions.cmake\nindex 6e1af53494c9..dda2e8bd37db 100644\n--- a/.github/config/out_of_tree_extensions.cmake\n+++ b/.github/config/out_of_tree_extensions.cmake\n@@ -104,6 +104,7 @@ duckdb_extension_load(spatial\n     GIT_TAG 4107eb788f933c9e268b52f6f927a6b36b9ea440\n     INCLUDE_DIR spatial/include\n     TEST_DIR test/sql\n+    APPLY_PATCHES\n     )\n \n ################# SQLITE_SCANNER\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 4cc7bb0139ee..407b1eea03f9 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -107,7 +107,7 @@ class ExpressionBinder {\n \t//! Returns a qualified column reference from a column reference with column_names.size() > 2\n \tunique_ptr<ParsedExpression> QualifyColumnNameWithManyDots(ColumnRefExpression &col_ref, ErrorData &error);\n \t//! Returns a qualified column reference from a column reference\n-\tunique_ptr<ParsedExpression> QualifyColumnName(ColumnRefExpression &col_ref, ErrorData &error);\n+\tvirtual unique_ptr<ParsedExpression> QualifyColumnName(ColumnRefExpression &col_ref, ErrorData &error);\n \t//! Enables special-handling of lambda parameters by tracking them in the lambda_params vector\n \tvoid QualifyColumnNamesInLambda(FunctionExpression &function, vector<unordered_set<string>> &lambda_params);\n \t//! Recursively qualifies the column references in the (children) of the expression. Passes on the\n@@ -116,6 +116,7 @@ class ExpressionBinder {\n \t                        const bool within_function_expression = false);\n \t//! Entry point for qualifying the column references of the expression\n \tstatic void QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr);\n+\tstatic void QualifyColumnNames(ExpressionBinder &binder, unique_ptr<ParsedExpression> &expr);\n \n \tstatic bool PushCollation(ClientContext &context, unique_ptr<Expression> &source, const LogicalType &sql_type);\n \tstatic void TestCollation(ClientContext &context, const string &collation);\ndiff --git a/src/include/duckdb/planner/expression_binder/having_binder.hpp b/src/include/duckdb/planner/expression_binder/having_binder.hpp\nindex 4cb65dab041e..b111cc368fa4 100644\n--- a/src/include/duckdb/planner/expression_binder/having_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/having_binder.hpp\n@@ -25,6 +25,8 @@ class HavingBinder : public BaseSelectBinder {\n \tBindResult BindWindow(WindowExpression &expr, idx_t depth) override;\n \tBindResult BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) override;\n \n+\tunique_ptr<ParsedExpression> QualifyColumnName(ColumnRefExpression &col_ref, ErrorData &error) override;\n+\n private:\n \tColumnAliasBinder column_alias_binder;\n \tAggregateHandling aggregate_handling;\ndiff --git a/src/planner/bind_context.cpp b/src/planner/bind_context.cpp\nindex be68c9e61dab..bca3c448d94b 100644\n--- a/src/planner/bind_context.cpp\n+++ b/src/planner/bind_context.cpp\n@@ -534,8 +534,8 @@ void BindContext::AddBaseTable(idx_t index, const string &alias, const vector<st\n void BindContext::AddBaseTable(idx_t index, const string &alias, const vector<string> &names,\n                                const vector<LogicalType> &types, vector<column_t> &bound_column_ids,\n                                const string &table_name) {\n-\tAddBinding(\n-\t    make_uniq<TableBinding>(alias.empty() ? table_name : alias, types, names, bound_column_ids, nullptr, index));\n+\tAddBinding(make_uniq<TableBinding>(alias.empty() ? table_name : alias, types, names, bound_column_ids, nullptr,\n+\t                                   index, true));\n }\n \n void BindContext::AddTableFunction(idx_t index, const string &alias, const vector<string> &names,\ndiff --git a/src/planner/binder/expression/bind_columnref_expression.cpp b/src/planner/binder/expression/bind_columnref_expression.cpp\nindex dcd34e70cd83..473bd2139c25 100644\n--- a/src/planner/binder/expression/bind_columnref_expression.cpp\n+++ b/src/planner/binder/expression/bind_columnref_expression.cpp\n@@ -218,6 +218,11 @@ void ExpressionBinder::QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpre\n \twhere_binder.QualifyColumnNames(expr, lambda_params);\n }\n \n+void ExpressionBinder::QualifyColumnNames(ExpressionBinder &expression_binder, unique_ptr<ParsedExpression> &expr) {\n+\tvector<unordered_set<string>> lambda_params;\n+\texpression_binder.QualifyColumnNames(expr, lambda_params);\n+}\n+\n unique_ptr<ParsedExpression> ExpressionBinder::CreateStructExtract(unique_ptr<ParsedExpression> base,\n                                                                    const string &field_name) {\n \ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex f1bad4c335da..27901d363928 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -514,7 +514,7 @@ unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_\n \t// bind the HAVING clause, if any\n \tif (statement.having) {\n \t\tHavingBinder having_binder(*this, context, *result, info, statement.aggregate_handling);\n-\t\tExpressionBinder::QualifyColumnNames(*this, statement.having);\n+\t\tExpressionBinder::QualifyColumnNames(having_binder, statement.having);\n \t\tresult->having = having_binder.Bind(statement.having);\n \t}\n \ndiff --git a/src/planner/expression_binder/having_binder.cpp b/src/planner/expression_binder/having_binder.cpp\nindex 27b0124bcb93..6f0c96a06517 100644\n--- a/src/planner/expression_binder/having_binder.cpp\n+++ b/src/planner/expression_binder/having_binder.cpp\n@@ -22,6 +22,22 @@ BindResult HavingBinder::BindLambdaReference(LambdaRefExpression &expr, idx_t de\n \treturn (*lambda_bindings)[expr.lambda_idx].Bind(lambda_ref, depth);\n }\n \n+unique_ptr<ParsedExpression> HavingBinder::QualifyColumnName(ColumnRefExpression &colref, ErrorData &error) {\n+\tauto qualified_colref = ExpressionBinder::QualifyColumnName(colref, error);\n+\tif (!qualified_colref) {\n+\t\treturn nullptr;\n+\t}\n+\n+\tauto group_index = TryBindGroup(*qualified_colref);\n+\tif (group_index != DConstants::INVALID_INDEX) {\n+\t\treturn qualified_colref;\n+\t}\n+\tif (column_alias_binder.QualifyColumnAlias(colref)) {\n+\t\treturn nullptr;\n+\t}\n+\treturn qualified_colref;\n+}\n+\n BindResult HavingBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {\n \n \t// Keep the original column name to return a meaningful error message.\n",
  "test_patch": "diff --git a/test/sql/aggregate/having/having_alias.test b/test/sql/aggregate/having/having_alias.test\nnew file mode 100644\nindex 000000000000..0b5f3fbedd37\n--- /dev/null\n+++ b/test/sql/aggregate/having/having_alias.test\n@@ -0,0 +1,39 @@\n+# name: test/sql/aggregate/having/having_alias.test\n+# description: Test aliases in the HAVING clause\n+# group: [having]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query II\n+SELECT b, sum(a) AS a\n+FROM (VALUES (1, 0), (1, 1)) t(a, b)\n+GROUP BY b\n+HAVING a > 0\n+ORDER BY ALL\n+----\n+0\t1\n+1\t1\n+\n+# if a reference is both a group and an alias, we prefer to bind to the group\n+statement ok\n+create table t1(a int);\n+\n+statement ok\n+insert into t1 values (42), (84);\n+\n+query I\n+select a+1 as a from t1 group by a having a=42;\n+----\n+43\n+\n+statement ok\n+create table t2(a int);\n+\n+statement ok\n+insert into t2 values (42), (84), (42);\n+\n+query II\n+select a as b, sum(a) as a from t2 group by b having a=42;\n+----\n+42\t84\ndiff --git a/test/sql/binder/test_having_alias.test b/test/sql/binder/test_having_alias.test\nindex bfb0f2e06aa5..573ae895c1b8 100644\n--- a/test/sql/binder/test_having_alias.test\n+++ b/test/sql/binder/test_having_alias.test\n@@ -46,15 +46,20 @@ SELECT COUNT(i) AS j FROM integers HAVING j=5;\n ----\n 5\n \n-# These don't work since i in HAVING refers the column instead of the alias\n-# (SQLite says: 'Error: a GROUP BY clause is required before HAVING')\n-statement error\n+\n+query I\n SELECT COUNT(i) AS i FROM integers HAVING i=5;\n ----\n+5\n \n-statement error\n+query I\n+SELECT COUNT(i) AS i FROM integers GROUP BY i HAVING i=5;\n+----\n+\n+query I\n SELECT COUNT(i) AS i FROM integers HAVING i=5 ORDER BY i;\n ----\n+5\n \n # use the same alias multiple times\n query I\n",
  "problem_statement": "Cannot use overriding column alias for aggregate expression in HAVING clause\n### What happens?\r\n\r\nDuckDB doesn't let me use aliases in the HAVING clause that I define in the SELECT clause and that override an existing column. (More precisely, it gives higher precedence to the original columns over  aliases in the SELECT when resolving column names in HAVING expressions, and then throws because the original column is not being aggregated over.)\r\n\r\nDuckDB does let me use aliases in the HAVING clause that I define in the SELECT clause as long as they do not override an existing column. \r\n\r\nPrior art:\r\n- MySQL lets me use all aliases in the HAVING clause, see https://www.db-fiddle.com/f/6CMxm3gtr2h7PWLXkJkax3/0\r\n- SQLite allows aliases in the HAVING clause but in case of overrides gives precedence to original columns (and if those original columns are not GROUPED over, it'll filter the groups by checking the filter condition on a randomly selected row of each group, which seems insane to me)\r\n- PostgreSQL and SQLServer don't let me use any alias in the HAVING clause.\r\n\r\nThis may as well be intentional, just opening in case there is interest in adopting MySQL behavior here, which I find more convenient, since duckdb is already deviating from PostgreSQL.\r\n\r\nPersonally, I find that:\r\n\r\n- even in non-grouped by select statements, the aliases should take precedence over the original columns, see https://github.com/duckdb/duckdb/issues/13991\r\n- even if not, typing the HAVING instead of the ubiquitous WHERE raises enough alerts in my brain that I'm now talking about groups, so I see even less danger of accidentally referring to the alias when the original column was meant. Also, MySQL here offers a precedent, the lack of which was given in #13991 as a reason not to make a general switch to alias precedence. \r\n \r\n\r\n### To Reproduce\r\n\r\n\r\n\r\n```sql\r\nSELECT b, sum(a) AS a\r\nFROM (VALUES (1, 0), (1, 1)) t(a, b)\r\nGROUP BY b\r\nHAVING a > 0\r\n```\r\n```\r\nError: column t.a must appear in the GROUP BY clause or be used in an aggregate function\r\n```\r\n\r\nwhile\r\n```sql\r\nSELECT b, sum(a) AS c\r\nFROM (VALUES (1, 0), (1, 1)) t(a, b)\r\nGROUP BY b\r\nHAVING c > 0\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   b   \u2502   c    \u2502\r\n\u2502 int32 \u2502 int128 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502      1 \u2502\r\n\u2502     0 \u2502      1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n'0.10.1-dev717'\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nSoeren Wolfers\r\n\r\n### Affiliation:\r\n\r\nG-Research\r\n\r\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\r\n\r\nI have tested with a nightly build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\nCannot use overriding column alias for aggregate expression in HAVING clause\n### What happens?\r\n\r\nDuckDB doesn't let me use aliases in the HAVING clause that I define in the SELECT clause and that override an existing column. (More precisely, it gives higher precedence to the original columns over  aliases in the SELECT when resolving column names in HAVING expressions, and then throws because the original column is not being aggregated over.)\r\n\r\nDuckDB does let me use aliases in the HAVING clause that I define in the SELECT clause as long as they do not override an existing column. \r\n\r\nPrior art:\r\n- MySQL lets me use all aliases in the HAVING clause, see https://www.db-fiddle.com/f/6CMxm3gtr2h7PWLXkJkax3/0\r\n- SQLite allows aliases in the HAVING clause but in case of overrides gives precedence to original columns (and if those original columns are not GROUPED over, it'll filter the groups by checking the filter condition on a randomly selected row of each group, which seems insane to me)\r\n- PostgreSQL and SQLServer don't let me use any alias in the HAVING clause.\r\n\r\nThis may as well be intentional, just opening in case there is interest in adopting MySQL behavior here, which I find more convenient, since duckdb is already deviating from PostgreSQL.\r\n\r\nPersonally, I find that:\r\n\r\n- even in non-grouped by select statements, the aliases should take precedence over the original columns, see https://github.com/duckdb/duckdb/issues/13991\r\n- even if not, typing the HAVING instead of the ubiquitous WHERE raises enough alerts in my brain that I'm now talking about groups, so I see even less danger of accidentally referring to the alias when the original column was meant. Also, MySQL here offers a precedent, the lack of which was given in #13991 as a reason not to make a general switch to alias precedence. \r\n \r\n\r\n### To Reproduce\r\n\r\n\r\n\r\n```sql\r\nSELECT b, sum(a) AS a\r\nFROM (VALUES (1, 0), (1, 1)) t(a, b)\r\nGROUP BY b\r\nHAVING a > 0\r\n```\r\n```\r\nError: column t.a must appear in the GROUP BY clause or be used in an aggregate function\r\n```\r\n\r\nwhile\r\n```sql\r\nSELECT b, sum(a) AS c\r\nFROM (VALUES (1, 0), (1, 1)) t(a, b)\r\nGROUP BY b\r\nHAVING c > 0\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   b   \u2502   c    \u2502\r\n\u2502 int32 \u2502 int128 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502      1 \u2502\r\n\u2502     0 \u2502      1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n'0.10.1-dev717'\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nSoeren Wolfers\r\n\r\n### Affiliation:\r\n\r\nG-Research\r\n\r\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\r\n\r\nI have tested with a nightly build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "This is likely a standard behaviour. I checked it on teradata and it behaves the same.\r\n\r\nThat being said, it is unfortunate. If I wanted to filter the original column, I would do it in the `WHERE` clause, not in the `HAVING` clause. There I want to filter the result of the aggregation so the alias should be used.\r\n\r\nIt gets even worse if you use `GROUP BY ALL` - it will add the original column to the group list without warning, leading to a non-intuitive behaviour and ugly bugs. \r\n\r\nConsider this:\r\n```\r\nSELECT a, sum(b) AS b\r\n  FROM (VALUES (1, -1), (1, 1)) t(a, b)\r\n  GROUP BY ALL\r\n  ;\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   a   \u2502   b    \u2502\r\n\u2502 int32 \u2502 int128 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502      0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nBut putting there `HAVING` we get this without any warning:\r\n\r\n```\r\nSELECT a, sum(b) AS b\r\n  FROM (VALUES (1, -1), (1, 1)) t(a, b)\r\n  GROUP BY ALL\r\n  HAVING b <> 0;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   a   \u2502   b    \u2502\r\n\u2502 int32 \u2502 int128 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502      1 \u2502\r\n\u2502     1 \u2502     -1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nInstead of having no rows in the output, we see the two original rows.\r\n\r\nOf course changing it is a breaking change but it would go in line with the DuckDB's pledge of having friendly SQL.\r\n\r\nThank you for your good work.\nIt's not standard behavior; the four major dialects all behave differently than duckdb and they behave differently in different ways (both of which are friendlier that duckdb's solution, IMO). \r\n\r\nI do agree with you that the behavior with GROUP BY ALL is an even clearer argument that the current behavior should be changed.\nThis issue is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.\n@szarnyasg This is still an issue on 1.0.0. I cannot remove the stale label myself. Is it okay to tag you in each of these (i have O(10) affected tickets) or is there an alternative solution? (For example, if the closing after 30 days happens non-automatically I guess I can just leave a comment under each ticket for the manual closer to read)\nThanks for the report!\r\n\r\nI've looked into this - and I think the issue here is a bit more complex than just which order columns are resolved in. MySQL prefers the original columns over the aliases as well. Below are some queries that return the same result in all systems I've tested (DuckDB, MySQL, SQLite, Postgres) showing the original columns are filtered instead of the aliases:\r\n\r\n```sql\r\ncreate table t1(a int);\r\ninsert into t1 values (42), (84);\r\nselect a+1 as a from t1 group by a having a=42;\r\n+------+\r\n| a    |\r\n+------+\r\n|   43 |\r\n+------+\r\n\r\ncreate table t2(a int);\r\ninsert into t2 values (42), (84), (42);\r\nselect a as b, sum(a) as a from t2 group by b having a=42;\r\n+------+------+\r\n| b    | a    |\r\n+------+------+\r\n|   42 |   84 |\r\n+------+------+\r\n```\r\n\r\nIt seems to me that what MySQL/SQLite are doing is instead: filter on the original columns first, if filtering on the original column is not possible because it is part of an aggregate then we filter on an alias.\r\n\r\nI think that's fair, and actually seems like a good solution to the issue here since the alternative is throwing an error. I would argue the `GROUP BY ALL` should adopt the same binding rule or throw an error in that scenario.\r\n\r\n> @szarnyasg This is still an issue on 1.0.0. I cannot remove the stale label myself. Is it okay to tag you in each of these (i have O(10) affected tickets) or is there an alternative solution? (For example, if the closing after 30 days happens non-automatically I guess I can just leave a comment under each ticket for the manual closer to read)\r\n\r\nThe stalebot automatically removes the label if there's any activity in the issue.\r\n\r\n\r\n\nAs usual, you have a keener eye for these intricacies. lf the discussion in #13991 ever results in a way to explicitly refer to an alias, that can adopted here too, but until then your solution sounds great. \r\n\r\n> The stalebot automatically removes the label if there's any activity in the issue.\r\n\r\nGood bot.\nThis is likely a standard behaviour. I checked it on teradata and it behaves the same.\r\n\r\nThat being said, it is unfortunate. If I wanted to filter the original column, I would do it in the `WHERE` clause, not in the `HAVING` clause. There I want to filter the result of the aggregation so the alias should be used.\r\n\r\nIt gets even worse if you use `GROUP BY ALL` - it will add the original column to the group list without warning, leading to a non-intuitive behaviour and ugly bugs. \r\n\r\nConsider this:\r\n```\r\nSELECT a, sum(b) AS b\r\n  FROM (VALUES (1, -1), (1, 1)) t(a, b)\r\n  GROUP BY ALL\r\n  ;\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   a   \u2502   b    \u2502\r\n\u2502 int32 \u2502 int128 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502      0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nBut putting there `HAVING` we get this without any warning:\r\n\r\n```\r\nSELECT a, sum(b) AS b\r\n  FROM (VALUES (1, -1), (1, 1)) t(a, b)\r\n  GROUP BY ALL\r\n  HAVING b <> 0;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   a   \u2502   b    \u2502\r\n\u2502 int32 \u2502 int128 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502      1 \u2502\r\n\u2502     1 \u2502     -1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nInstead of having no rows in the output, we see the two original rows.\r\n\r\nOf course changing it is a breaking change but it would go in line with the DuckDB's pledge of having friendly SQL.\r\n\r\nThank you for your good work.\nIt's not standard behavior; the four major dialects all behave differently than duckdb and they behave differently in different ways (both of which are friendlier that duckdb's solution, IMO). \r\n\r\nI do agree with you that the behavior with GROUP BY ALL is an even clearer argument that the current behavior should be changed.\nThis issue is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.\n@szarnyasg This is still an issue on 1.0.0. I cannot remove the stale label myself. Is it okay to tag you in each of these (i have O(10) affected tickets) or is there an alternative solution? (For example, if the closing after 30 days happens non-automatically I guess I can just leave a comment under each ticket for the manual closer to read)\nThanks for the report!\r\n\r\nI've looked into this - and I think the issue here is a bit more complex than just which order columns are resolved in. MySQL prefers the original columns over the aliases as well. Below are some queries that return the same result in all systems I've tested (DuckDB, MySQL, SQLite, Postgres) showing the original columns are filtered instead of the aliases:\r\n\r\n```sql\r\ncreate table t1(a int);\r\ninsert into t1 values (42), (84);\r\nselect a+1 as a from t1 group by a having a=42;\r\n+------+\r\n| a    |\r\n+------+\r\n|   43 |\r\n+------+\r\n\r\ncreate table t2(a int);\r\ninsert into t2 values (42), (84), (42);\r\nselect a as b, sum(a) as a from t2 group by b having a=42;\r\n+------+------+\r\n| b    | a    |\r\n+------+------+\r\n|   42 |   84 |\r\n+------+------+\r\n```\r\n\r\nIt seems to me that what MySQL/SQLite are doing is instead: filter on the original columns first, if filtering on the original column is not possible because it is part of an aggregate then we filter on an alias.\r\n\r\nI think that's fair, and actually seems like a good solution to the issue here since the alternative is throwing an error. I would argue the `GROUP BY ALL` should adopt the same binding rule or throw an error in that scenario.\r\n\r\n> @szarnyasg This is still an issue on 1.0.0. I cannot remove the stale label myself. Is it okay to tag you in each of these (i have O(10) affected tickets) or is there an alternative solution? (For example, if the closing after 30 days happens non-automatically I guess I can just leave a comment under each ticket for the manual closer to read)\r\n\r\nThe stalebot automatically removes the label if there's any activity in the issue.\r\n\r\n\r\n\nAs usual, you have a keener eye for these intricacies. lf the discussion in #13991 ever results in a way to explicitly refer to an alias, that can adopted here too, but until then your solution sounds great. \r\n\r\n> The stalebot automatically removes the label if there's any activity in the issue.\r\n\r\nGood bot.",
  "created_at": "2024-09-18T19:58:59Z"
}