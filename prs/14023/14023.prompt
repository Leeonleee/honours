You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Cannot use overriding column alias for aggregate expression in HAVING clause
### What happens?

DuckDB doesn't let me use aliases in the HAVING clause that I define in the SELECT clause and that override an existing column. (More precisely, it gives higher precedence to the original columns over  aliases in the SELECT when resolving column names in HAVING expressions, and then throws because the original column is not being aggregated over.)

DuckDB does let me use aliases in the HAVING clause that I define in the SELECT clause as long as they do not override an existing column. 

Prior art:
- MySQL lets me use all aliases in the HAVING clause, see https://www.db-fiddle.com/f/6CMxm3gtr2h7PWLXkJkax3/0
- SQLite allows aliases in the HAVING clause but in case of overrides gives precedence to original columns (and if those original columns are not GROUPED over, it'll filter the groups by checking the filter condition on a randomly selected row of each group, which seems insane to me)
- PostgreSQL and SQLServer don't let me use any alias in the HAVING clause.

This may as well be intentional, just opening in case there is interest in adopting MySQL behavior here, which I find more convenient, since duckdb is already deviating from PostgreSQL.

Personally, I find that:

- even in non-grouped by select statements, the aliases should take precedence over the original columns, see https://github.com/duckdb/duckdb/issues/13991
- even if not, typing the HAVING instead of the ubiquitous WHERE raises enough alerts in my brain that I'm now talking about groups, so I see even less danger of accidentally referring to the alias when the original column was meant. Also, MySQL here offers a precedent, the lack of which was given in #13991 as a reason not to make a general switch to alias precedence. 
 

### To Reproduce



```sql
SELECT b, sum(a) AS a
FROM (VALUES (1, 0), (1, 1)) t(a, b)
GROUP BY b
HAVING a > 0
```
```
Error: column t.a must appear in the GROUP BY clause or be used in an aggregate function
```

while
```sql
SELECT b, sum(a) AS c
FROM (VALUES (1, 0), (1, 1)) t(a, b)
GROUP BY b
HAVING c > 0
```
```
┌───────┬────────┐
│   b   │   c    │
│ int32 │ int128 │
├───────┼────────┤
│     1 │      1 │
│     0 │      1 │
└───────┴────────┘
```

### OS:

Linux

### DuckDB Version:

'0.10.1-dev717'

### DuckDB Client:

Python

### Full Name:

Soeren Wolfers

### Affiliation:

G-Research

### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?

I have tested with a nightly build

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] Yes, I have
Cannot use overriding column alias for aggregate expression in HAVING clause
### What happens?

DuckDB doesn't let me use aliases in the HAVING clause that I define in the SELECT clause and that override an existing column. (More precisely, it gives higher precedence to the original columns over  aliases in the SELECT when resolving column names in HAVING expressions, and then throws because the original column is not being aggregated over.)

DuckDB does let me use aliases in the HAVING clause that I define in the SELECT clause as long as they do not override an existing column. 

Prior art:
- MySQL lets me use all aliases in the HAVING clause, see https://www.db-fiddle.com/f/6CMxm3gtr2h7PWLXkJkax3/0
- SQLite allows aliases in the HAVING clause but in case of overrides gives precedence to original columns (and if those original columns are not GROUPED over, it'll filter the groups by checking the filter condition on a randomly selected row of each group, which seems insane to me)
- PostgreSQL and SQLServer don't let me use any alias in the HAVING clause.

This may as well be intentional, just opening in case there is interest in adopting MySQL behavior here, which I find more convenient, since duckdb is already deviating from PostgreSQL.

Personally, I find that:

- even in non-grouped by select statements, the aliases should take precedence over the original columns, see https://github.com/duckdb/duckdb/issues/13991
- even if not, typing the HAVING instead of the ubiquitous WHERE raises enough alerts in my brain that I'm now talking about groups, so I see even less danger of accidentally referring to the alias when the original column was meant. Also, MySQL here offers a precedent, the lack of which was given in #13991 as a reason not to make a general switch to alias precedence. 
 

### To Reproduce



```sql
SELECT b, sum(a) AS a
FROM (VALUES (1, 0), (1, 1)) t(a, b)
GROUP BY b
HAVING a > 0
```
```
Error: column t.a must appear in the GROUP BY clause or be used in an aggregate function
```

while
```sql
SELECT b, sum(a) AS c
FROM (VALUES (1, 0), (1, 1)) t(a, b)
GROUP BY b
HAVING c > 0
```
```
┌───────┬────────┐
│   b   │   c    │
│ int32 │ int128 │
├───────┼────────┤
│     1 │      1 │
│     0 │      1 │
└───────┴────────┘
```

### OS:

Linux

### DuckDB Version:

'0.10.1-dev717'

### DuckDB Client:

Python

### Full Name:

Soeren Wolfers

### Affiliation:

G-Research

### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?

I have tested with a nightly build

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of .github/config/out_of_tree_extensions.cmake]
1: #
2: # This config file holds all out-of-tree extension that are built with DuckDB's CI
3: #
4: # to build duckdb with this configuration run:
5: #   EXTENSION_CONFIGS=.github/config/out_of_tree_extensions.cmake make
6: #
7: #  Note that many of these packages require vcpkg, and a merged manifest must be created to
8: #  compile multiple of them.
9: #
10: #  After setting up vcpkg, build using e.g. the following commands:
11: #  USE_MERGED_VCPKG_MANIFEST=1 BUILD_ALL_EXT=1 make extension_configuration
12: #  USE_MERGED_VCPKG_MANIFEST=1 BUILD_ALL_EXT=1 make debug
13: #
14: #  Make sure the VCPKG_TOOLCHAIN_PATH and VCPKG_TARGET_TRIPLET are set. For example:
15: #  VCPKG_TOOLCHAIN_PATH=~/vcpkg/scripts/buildsystems/vcpkg.cmake
16: #  VCPKG_TARGET_TRIPLET=arm64-osx
17: 
18: ################# ARROW
19: if (NOT MINGW)
20:     duckdb_extension_load(arrow
21:             LOAD_TESTS DONT_LINK
22:             GIT_URL https://github.com/duckdb/arrow
23:             GIT_TAG c50862c82c065096722745631f4230832a3a04e8
24:             )
25: endif()
26: 
27: ################## AWS
28: if (NOT MINGW)
29:     duckdb_extension_load(aws
30:             LOAD_TESTS
31:             GIT_URL https://github.com/duckdb/duckdb_aws
32:             GIT_TAG e738b4cc07a86d323db8b38220323752cd183a04
33:             )
34: endif()
35: 
36: ################# AZURE
37: if (NOT MINGW)
38:     duckdb_extension_load(azure
39:             LOAD_TESTS
40:             GIT_URL https://github.com/duckdb/duckdb_azure
41:             GIT_TAG eddc48422c76a2f02a57a45d31b650b2680168f5
42:             )
43: endif()
44: 
45: ################# DELTA
46: # MinGW build is not available, and our current manylinux ci does not have enough storage space to run the rust build
47: # for Delta
48: if (NOT MINGW AND NOT "${OS_NAME}" STREQUAL "linux")
49:     duckdb_extension_load(delta
50:             LOAD_TESTS
51:             GIT_URL https://github.com/duckdb/duckdb_delta
52:             GIT_TAG 3933ebd800ad06a64656c9aef6ca7d62897fa4db
53:     )
54: endif()
55: 
56: ################# EXCEL
57: duckdb_extension_load(excel
58:     LOAD_TESTS
59:     GIT_URL https://github.com/duckdb/duckdb_excel
60:     GIT_TAG 0e99dc789038c7af658e30d579b818473a6d6ea8
61:     INCLUDE_DIR extension/excel/include
62:     )
63: 
64: ################# ICEBERG
65: # Windows tests for iceberg currently not working
66: if (NOT WIN32)
67:     set(LOAD_ICEBERG_TESTS "LOAD_TESTS")
68: else ()
69:     set(LOAD_ICEBERG_TESTS "")
70: endif()
71: 
72: if (NOT MINGW)
73:     duckdb_extension_load(iceberg
74:             ${LOAD_ICEBERG_TESTS}
75:             GIT_URL https://github.com/duckdb/duckdb_iceberg
76:             GIT_TAG 3f6d753787252e3da1d12157910b62edf729fc6e
77:             )
78: endif()
79: 
80: ################# INET
81: duckdb_extension_load(inet
82:     LOAD_TESTS
83:     GIT_URL https://github.com/duckdb/duckdb_inet
84:     GIT_TAG eca867b2517af06eabc89ccd6234266e9a7d6d71
85:     INCLUDE_DIR src/include
86:     TEST_DIR test/sql
87:     )
88: 
89: ################# POSTGRES_SCANNER
90: # Note: tests for postgres_scanner are currently not run. All of them need a postgres server running. One test
91: #       uses a remote rds server but that's not something we want to run here.
92: if (NOT MINGW)
93:     duckdb_extension_load(postgres_scanner
94:             DONT_LINK
95:             GIT_URL https://github.com/duckdb/postgres_scanner
96:             GIT_TAG 58dc3d0c7620f3978c27d4a490563fd65884d103
97:             )
98: endif()
99: 
100: ################# SPATIAL
101: duckdb_extension_load(spatial
102:     DONT_LINK LOAD_TESTS
103:     GIT_URL https://github.com/duckdb/duckdb_spatial.git
104:     GIT_TAG 4107eb788f933c9e268b52f6f927a6b36b9ea440
105:     INCLUDE_DIR spatial/include
106:     TEST_DIR test/sql
107:     )
108: 
109: ################# SQLITE_SCANNER
110: # Static linking on windows does not properly work due to symbol collision
111: if (WIN32)
112:     set(STATIC_LINK_SQLITE "DONT_LINK")
113: else ()
114:     set(STATIC_LINK_SQLITE "")
115: endif()
116: 
117: duckdb_extension_load(sqlite_scanner
118:         ${STATIC_LINK_SQLITE} LOAD_TESTS
119:         GIT_URL https://github.com/duckdb/sqlite_scanner
120:         GIT_TAG 315861963c8106397af36cbda10faebc8dae485a
121:         )
122: 
123: duckdb_extension_load(sqlsmith
124:         DONT_LINK LOAD_TESTS
125:         GIT_URL https://github.com/duckdb/duckdb_sqlsmith
126:         GIT_TAG 7b00307a0c00fbb85bef2010330946f11311ba4c
127:         )
128: 
129: ################# SUBSTRAIT
130: if (NOT WIN32)
131:     duckdb_extension_load(substrait
132:             LOAD_TESTS DONT_LINK
133:             GIT_URL https://github.com/duckdb/substrait
134:             GIT_TAG 800be4945807b831754f6b0d1a064a3d30f9cada
135:             )
136: endif()
137: 
138: 
139: ################# VSS
140: duckdb_extension_load(vss
141:         LOAD_TESTS
142:         DONT_LINK
143:         GIT_URL https://github.com/duckdb/duckdb_vss
144:         GIT_TAG 77739ea5382cce3220af83803ac0b1e98b3ab7d8
145:         TEST_DIR test/sql
146:     )
147: 
148: ################# MYSQL
149: if (NOT MINGW)
150:     duckdb_extension_load(mysql_scanner
151:             DONT_LINK
152:             LOAD_TESTS
153:             GIT_URL https://github.com/duckdb/duckdb_mysql
154:             GIT_TAG d0c56abf1169cca1c54f55448b68a85ae4279ea4
155:             )
156: endif()
[end of .github/config/out_of_tree_extensions.cmake]
[start of src/include/duckdb/planner/expression_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/exception.hpp"
12: #include "duckdb/common/stack_checker.hpp"
13: #include "duckdb/common/exception/binder_exception.hpp"
14: #include "duckdb/common/error_data.hpp"
15: #include "duckdb/common/unordered_map.hpp"
16: #include "duckdb/parser/expression/bound_expression.hpp"
17: #include "duckdb/parser/expression/lambdaref_expression.hpp"
18: #include "duckdb/parser/parsed_expression.hpp"
19: #include "duckdb/parser/tokens.hpp"
20: #include "duckdb/planner/expression.hpp"
21: #include "duckdb/catalog/catalog_entry_retriever.hpp"
22: #include "duckdb/planner/expression/bound_lambda_expression.hpp"
23: #include "duckdb/function/scalar_function.hpp"
24: #include "duckdb/planner/column_binding.hpp"
25: 
26: namespace duckdb {
27: 
28: class Binder;
29: class ClientContext;
30: class QueryNode;
31: 
32: class ScalarFunctionCatalogEntry;
33: class AggregateFunctionCatalogEntry;
34: class ScalarMacroCatalogEntry;
35: class CatalogEntry;
36: class SimpleFunction;
37: 
38: struct DummyBinding;
39: struct SelectBindState;
40: 
41: struct BoundColumnReferenceInfo {
42: 	string name;
43: 	optional_idx query_location;
44: };
45: 
46: struct BindResult {
47: 	BindResult() {
48: 	}
49: 	explicit BindResult(const Exception &ex) : error(ex) {
50: 	}
51: 	explicit BindResult(const string &error_msg) : error(ExceptionType::BINDER, error_msg) {
52: 	}
53: 	explicit BindResult(ErrorData error) : error(std::move(error)) {
54: 	}
55: 	explicit BindResult(unique_ptr<Expression> expr) : expression(std::move(expr)) {
56: 	}
57: 
58: 	bool HasError() const {
59: 		return error.HasError();
60: 	}
61: 	void SetError(const string &error_message) {
62: 		error = ErrorData(ExceptionType::BINDER, error_message);
63: 	}
64: 
65: 	unique_ptr<Expression> expression;
66: 	ErrorData error;
67: };
68: 
69: class ExpressionBinder {
70: 	friend class StackChecker<ExpressionBinder>;
71: 
72: public:
73: 	ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder = false);
74: 	virtual ~ExpressionBinder();
75: 
76: 	//! The target type that should result from the binder. If the result is not of this type, a cast to this type will
77: 	//! be added. Defaults to INVALID.
78: 	LogicalType target_type;
79: 
80: 	optional_ptr<DummyBinding> macro_binding;
81: 	optional_ptr<vector<DummyBinding>> lambda_bindings;
82: 
83: public:
84: 	unique_ptr<Expression> Bind(unique_ptr<ParsedExpression> &expr, optional_ptr<LogicalType> result_type = nullptr,
85: 	                            bool root_expression = true);
86: 
87: 	//! Returns whether or not any columns have been bound by the expression binder
88: 	bool HasBoundColumns() {
89: 		return !bound_columns.empty();
90: 	}
91: 	const vector<BoundColumnReferenceInfo> &GetBoundColumns() {
92: 		return bound_columns;
93: 	}
94: 
95: 	void SetCatalogLookupCallback(catalog_entry_callback_t callback);
96: 	ErrorData Bind(unique_ptr<ParsedExpression> &expr, idx_t depth, bool root_expression = false);
97: 
98: 	//! Returns the STRUCT_EXTRACT operator expression
99: 	unique_ptr<ParsedExpression> CreateStructExtract(unique_ptr<ParsedExpression> base, const string &field_name);
100: 	//! Returns a STRUCT_PACK function expression
101: 	unique_ptr<ParsedExpression> CreateStructPack(ColumnRefExpression &col_ref);
102: 
103: 	BindResult BindQualifiedColumnName(ColumnRefExpression &colref, const string &table_name);
104: 
105: 	//! Returns a qualified column reference from a column name
106: 	unique_ptr<ParsedExpression> QualifyColumnName(const string &column_name, ErrorData &error);
107: 	//! Returns a qualified column reference from a column reference with column_names.size() > 2
108: 	unique_ptr<ParsedExpression> QualifyColumnNameWithManyDots(ColumnRefExpression &col_ref, ErrorData &error);
109: 	//! Returns a qualified column reference from a column reference
110: 	unique_ptr<ParsedExpression> QualifyColumnName(ColumnRefExpression &col_ref, ErrorData &error);
111: 	//! Enables special-handling of lambda parameters by tracking them in the lambda_params vector
112: 	void QualifyColumnNamesInLambda(FunctionExpression &function, vector<unordered_set<string>> &lambda_params);
113: 	//! Recursively qualifies the column references in the (children) of the expression. Passes on the
114: 	//! within_function_expression state from outer expressions, or sets it
115: 	void QualifyColumnNames(unique_ptr<ParsedExpression> &expr, vector<unordered_set<string>> &lambda_params,
116: 	                        const bool within_function_expression = false);
117: 	//! Entry point for qualifying the column references of the expression
118: 	static void QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr);
119: 
120: 	static bool PushCollation(ClientContext &context, unique_ptr<Expression> &source, const LogicalType &sql_type);
121: 	static void TestCollation(ClientContext &context, const string &collation);
122: 
123: 	BindResult BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr, ErrorData error_message);
124: 
125: 	void BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, ErrorData &error);
126: 	static void ExtractCorrelatedExpressions(Binder &binder, Expression &expr);
127: 
128: 	static bool ContainsNullType(const LogicalType &type);
129: 	static LogicalType ExchangeNullType(const LogicalType &type);
130: 	static bool ContainsType(const LogicalType &type, LogicalTypeId target);
131: 	static LogicalType ExchangeType(const LogicalType &type, LogicalTypeId target, LogicalType new_type);
132: 
133: 	virtual bool TryBindAlias(ColumnRefExpression &colref, bool root_expression, BindResult &result);
134: 	virtual bool QualifyColumnAlias(const ColumnRefExpression &colref);
135: 
136: 	//! Bind the given expression. Unlike Bind(), this does *not* mute the given ParsedExpression.
137: 	//! Exposed to be used from sub-binders that aren't subclasses of ExpressionBinder.
138: 	virtual BindResult BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth,
139: 	                                  bool root_expression = false);
140: 
141: 	//! FIXME: Generalise this for extensibility.
142: 	//! Recursively replaces macro parameters with the provided input parameters.
143: 	void ReplaceMacroParameters(unique_ptr<ParsedExpression> &expr, vector<unordered_set<string>> &lambda_params);
144: 	//! Enables special-handling of lambda parameters during macro replacement by tracking them in the lambda_params
145: 	//! vector.
146: 	void ReplaceMacroParametersInLambda(FunctionExpression &function, vector<unordered_set<string>> &lambda_params);
147: 	//! Recursively qualifies column references in ON CONFLICT DO UPDATE SET expressions.
148: 	void DoUpdateSetQualify(unique_ptr<ParsedExpression> &expr, const string &table_name,
149: 	                        vector<unordered_set<string>> &lambda_params);
150: 	//! Enables special-handling of lambda parameters during ON CONFLICT TO UPDATE SET qualification by tracking them in
151: 	//! the lambda_params vector.
152: 	void DoUpdateSetQualifyInLambda(FunctionExpression &function, const string &table_name,
153: 	                                vector<unordered_set<string>> &lambda_params);
154: 
155: 	static LogicalType GetExpressionReturnType(const Expression &expr);
156: 
157: private:
158: 	//! Current stack depth
159: 	idx_t stack_depth = DConstants::INVALID_INDEX;
160: 
161: 	void InitializeStackCheck();
162: 	StackChecker<ExpressionBinder> StackCheck(const ParsedExpression &expr, idx_t extra_stack = 1);
163: 
164: protected:
165: 	BindResult BindExpression(BetweenExpression &expr, idx_t depth);
166: 	BindResult BindExpression(CaseExpression &expr, idx_t depth);
167: 	BindResult BindExpression(CollateExpression &expr, idx_t depth);
168: 	BindResult BindExpression(CastExpression &expr, idx_t depth);
169: 	BindResult BindExpression(ColumnRefExpression &expr, idx_t depth, bool root_expression);
170: 	BindResult BindExpression(LambdaRefExpression &expr, idx_t depth);
171: 	BindResult BindExpression(ComparisonExpression &expr, idx_t depth);
172: 	BindResult BindExpression(ConjunctionExpression &expr, idx_t depth);
173: 	BindResult BindExpression(ConstantExpression &expr, idx_t depth);
174: 	BindResult BindExpression(FunctionExpression &expr, idx_t depth, unique_ptr<ParsedExpression> &expr_ptr);
175: 	BindResult BindExpression(LambdaExpression &expr, idx_t depth, const LogicalType &list_child_type,
176: 	                          optional_ptr<bind_lambda_function_t> bind_lambda_function);
177: 	BindResult BindExpression(OperatorExpression &expr, idx_t depth);
178: 	BindResult BindExpression(ParameterExpression &expr, idx_t depth);
179: 	BindResult BindExpression(SubqueryExpression &expr, idx_t depth);
180: 	BindResult BindPositionalReference(unique_ptr<ParsedExpression> &expr, idx_t depth, bool root_expression);
181: 
182: 	void TransformCapturedLambdaColumn(unique_ptr<Expression> &original, unique_ptr<Expression> &replacement,
183: 	                                   BoundLambdaExpression &bound_lambda_expr,
184: 	                                   const optional_ptr<bind_lambda_function_t> bind_lambda_function,
185: 	                                   const LogicalType &list_child_type);
186: 	void CaptureLambdaColumns(BoundLambdaExpression &bound_lambda_expr, unique_ptr<Expression> &expr,
187: 	                          const optional_ptr<bind_lambda_function_t> bind_lambda_function,
188: 	                          const LogicalType &list_child_type);
189: 
190: 	virtual unique_ptr<ParsedExpression> GetSQLValueFunction(const string &column_name);
191: 
192: 	LogicalType ResolveOperatorType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);
193: 	LogicalType ResolveCoalesceType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);
194: 	LogicalType ResolveNotType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);
195: 
196: 	BindResult BindUnsupportedExpression(ParsedExpression &expr, idx_t depth, const string &message);
197: 
198: protected:
199: 	virtual BindResult BindGroupingFunction(OperatorExpression &op, idx_t depth);
200: 	virtual BindResult BindFunction(FunctionExpression &expr, ScalarFunctionCatalogEntry &function, idx_t depth);
201: 	virtual BindResult BindLambdaFunction(FunctionExpression &expr, ScalarFunctionCatalogEntry &function, idx_t depth);
202: 	virtual BindResult BindAggregate(FunctionExpression &expr, AggregateFunctionCatalogEntry &function, idx_t depth);
203: 	virtual BindResult BindUnnest(FunctionExpression &expr, idx_t depth, bool root_expression);
204: 	virtual BindResult BindMacro(FunctionExpression &expr, ScalarMacroCatalogEntry &macro, idx_t depth,
205: 	                             unique_ptr<ParsedExpression> &expr_ptr);
206: 	void UnfoldMacroExpression(FunctionExpression &function, ScalarMacroCatalogEntry &macro_func,
207: 	                           unique_ptr<ParsedExpression> &expr);
208: 
209: 	virtual string UnsupportedAggregateMessage();
210: 	virtual string UnsupportedUnnestMessage();
211: 	optional_ptr<CatalogEntry> GetCatalogEntry(CatalogType type, const string &catalog, const string &schema,
212: 	                                           const string &name, OnEntryNotFound on_entry_not_found,
213: 	                                           QueryErrorContext &error_context);
214: 
215: 	Binder &binder;
216: 	ClientContext &context;
217: 	optional_ptr<ExpressionBinder> stored_binder;
218: 	vector<BoundColumnReferenceInfo> bound_columns;
219: 
220: 	//! Returns true if the function name is an alias for the UNNEST function
221: 	static bool IsUnnestFunction(const string &function_name);
222: 	BindResult TryBindLambdaOrJson(FunctionExpression &function, idx_t depth, CatalogEntry &func);
223: 
224: 	unique_ptr<ParsedExpression> QualifyColumnNameWithManyDotsInternal(ColumnRefExpression &col_ref, ErrorData &error,
225: 	                                                                   idx_t &struct_extract_start);
226: 	virtual void ThrowIfUnnestInLambda(const ColumnBinding &column_binding);
227: };
228: 
229: } // namespace duckdb
[end of src/include/duckdb/planner/expression_binder.hpp]
[start of src/include/duckdb/planner/expression_binder/having_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression_binder/having_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/planner/expression_binder/base_select_binder.hpp"
12: #include "duckdb/planner/expression_binder/column_alias_binder.hpp"
13: #include "duckdb/common/enums/aggregate_handling.hpp"
14: 
15: namespace duckdb {
16: 
17: //! The HAVING binder is responsible for binding an expression within the HAVING clause of a SQL statement.
18: class HavingBinder : public BaseSelectBinder {
19: public:
20: 	HavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,
21: 	             AggregateHandling aggregate_handling);
22: 
23: protected:
24: 	BindResult BindLambdaReference(LambdaRefExpression &expr, idx_t depth);
25: 	BindResult BindWindow(WindowExpression &expr, idx_t depth) override;
26: 	BindResult BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) override;
27: 
28: private:
29: 	ColumnAliasBinder column_alias_binder;
30: 	AggregateHandling aggregate_handling;
31: };
32: 
33: } // namespace duckdb
[end of src/include/duckdb/planner/expression_binder/having_binder.hpp]
[start of src/planner/bind_context.cpp]
1: #include "duckdb/planner/bind_context.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_column_type.hpp"
4: #include "duckdb/catalog/standard_entry.hpp"
5: #include "duckdb/common/pair.hpp"
6: #include "duckdb/common/string_util.hpp"
7: #include "duckdb/parser/expression/columnref_expression.hpp"
8: #include "duckdb/parser/expression/operator_expression.hpp"
9: #include "duckdb/parser/expression/positional_reference_expression.hpp"
10: #include "duckdb/parser/expression/star_expression.hpp"
11: #include "duckdb/parser/tableref/subqueryref.hpp"
12: #include "duckdb/parser/tableref/table_function_ref.hpp"
13: #include "duckdb/planner/bound_query_node.hpp"
14: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
15: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
16: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
17: #include "duckdb/planner/expression_binder/constant_binder.hpp"
18: #include "duckdb/planner/binder.hpp"
19: 
20: #include <algorithm>
21: 
22: namespace duckdb {
23: 
24: BindContext::BindContext(Binder &binder) : binder(binder) {
25: }
26: 
27: string MinimumUniqueAlias(const BindingAlias &alias, const BindingAlias &other) {
28: 	if (!StringUtil::CIEquals(alias.GetAlias(), other.GetAlias())) {
29: 		return alias.GetAlias();
30: 	}
31: 	if (!StringUtil::CIEquals(alias.GetSchema(), other.GetSchema())) {
32: 		return alias.GetSchema() + "." + alias.GetAlias();
33: 	}
34: 	return alias.ToString();
35: }
36: 
37: optional_ptr<Binding> BindContext::GetMatchingBinding(const string &column_name) {
38: 	optional_ptr<Binding> result;
39: 	for (auto &binding_ptr : bindings_list) {
40: 		auto &binding = *binding_ptr;
41: 		auto is_using_binding = GetUsingBinding(column_name, binding.alias);
42: 		if (is_using_binding) {
43: 			continue;
44: 		}
45: 		if (binding.HasMatchingBinding(column_name)) {
46: 			if (result || is_using_binding) {
47: 				throw BinderException("Ambiguous reference to column name \"%s\" (use: \"%s.%s\" "
48: 				                      "or \"%s.%s\")",
49: 				                      column_name, MinimumUniqueAlias(result->alias, binding.alias), column_name,
50: 				                      MinimumUniqueAlias(binding.alias, result->alias), column_name);
51: 			}
52: 			result = &binding;
53: 		}
54: 	}
55: 	return result;
56: }
57: 
58: vector<string> BindContext::GetSimilarBindings(const string &column_name) {
59: 	vector<pair<string, double>> scores;
60: 	for (auto &binding_ptr : bindings_list) {
61: 		auto binding = *binding_ptr;
62: 		for (auto &name : binding.names) {
63: 			double distance = StringUtil::SimilarityRating(name, column_name);
64: 			scores.emplace_back(binding.GetAlias() + "." + name, distance);
65: 		}
66: 	}
67: 	return StringUtil::TopNStrings(scores);
68: }
69: 
70: void BindContext::AddUsingBinding(const string &column_name, UsingColumnSet &set) {
71: 	using_columns[column_name].insert(set);
72: }
73: 
74: void BindContext::AddUsingBindingSet(unique_ptr<UsingColumnSet> set) {
75: 	using_column_sets.push_back(std::move(set));
76: }
77: 
78: optional_ptr<UsingColumnSet> BindContext::GetUsingBinding(const string &column_name) {
79: 	auto entry = using_columns.find(column_name);
80: 	if (entry == using_columns.end()) {
81: 		return nullptr;
82: 	}
83: 	auto &using_bindings = entry->second;
84: 	if (using_bindings.size() > 1) {
85: 		string error = "Ambiguous column reference: column \"" + column_name + "\" can refer to either:\n";
86: 		for (auto &using_set_ref : using_bindings) {
87: 			auto &using_set = using_set_ref.get();
88: 			string result_bindings;
89: 			for (auto &binding : using_set.bindings) {
90: 				if (result_bindings.empty()) {
91: 					result_bindings = "[";
92: 				} else {
93: 					result_bindings += ", ";
94: 				}
95: 				result_bindings += binding.GetAlias();
96: 				result_bindings += ".";
97: 				result_bindings += GetActualColumnName(binding, column_name);
98: 			}
99: 			error += result_bindings + "]";
100: 		}
101: 		throw BinderException(error);
102: 	}
103: 	for (auto &using_set : using_bindings) {
104: 		return &using_set.get();
105: 	}
106: 	throw InternalException("Using binding found but no entries");
107: }
108: 
109: optional_ptr<UsingColumnSet> BindContext::GetUsingBinding(const string &column_name, const BindingAlias &binding) {
110: 	if (!binding.IsSet()) {
111: 		throw InternalException("GetUsingBinding: expected non-empty binding_name");
112: 	}
113: 	auto entry = using_columns.find(column_name);
114: 	if (entry == using_columns.end()) {
115: 		return nullptr;
116: 	}
117: 	auto &using_bindings = entry->second;
118: 	for (auto &using_set_ref : using_bindings) {
119: 		auto &using_set = using_set_ref.get();
120: 		auto &bindings = using_set.bindings;
121: 		for (auto &using_binding : bindings) {
122: 			if (using_binding == binding) {
123: 				return &using_set;
124: 			}
125: 		}
126: 	}
127: 	return nullptr;
128: }
129: 
130: void BindContext::RemoveUsingBinding(const string &column_name, UsingColumnSet &set) {
131: 	auto entry = using_columns.find(column_name);
132: 	if (entry == using_columns.end()) {
133: 		throw InternalException("Attempting to remove using binding that is not there");
134: 	}
135: 	auto &bindings = entry->second;
136: 	if (bindings.find(set) != bindings.end()) {
137: 		bindings.erase(set);
138: 	}
139: 	if (bindings.empty()) {
140: 		using_columns.erase(column_name);
141: 	}
142: }
143: 
144: void BindContext::TransferUsingBinding(BindContext &current_context, optional_ptr<UsingColumnSet> current_set,
145:                                        UsingColumnSet &new_set, const string &using_column) {
146: 	AddUsingBinding(using_column, new_set);
147: 	if (current_set) {
148: 		current_context.RemoveUsingBinding(using_column, *current_set);
149: 	}
150: }
151: 
152: string BindContext::GetActualColumnName(Binding &binding, const string &column_name) {
153: 	column_t binding_index;
154: 	if (!binding.TryGetBindingIndex(column_name, binding_index)) { // LCOV_EXCL_START
155: 		throw InternalException("Binding with name \"%s\" does not have a column named \"%s\"", binding.GetAlias(),
156: 		                        column_name);
157: 	} // LCOV_EXCL_STOP
158: 	return binding.names[binding_index];
159: }
160: 
161: string BindContext::GetActualColumnName(const BindingAlias &binding_alias, const string &column_name) {
162: 	ErrorData error;
163: 	auto binding = GetBinding(binding_alias, error);
164: 	if (!binding) {
165: 		throw InternalException("No binding with name \"%s\": %s", binding_alias.GetAlias(), error.RawMessage());
166: 	}
167: 	return GetActualColumnName(*binding, column_name);
168: }
169: 
170: vector<reference<Binding>> BindContext::GetMatchingBindings(const string &column_name) {
171: 	vector<reference<Binding>> result;
172: 	for (auto &binding_ptr : bindings_list) {
173: 		auto &binding = *binding_ptr;
174: 		if (binding.HasMatchingBinding(column_name)) {
175: 			result.push_back(binding);
176: 		}
177: 	}
178: 	return result;
179: }
180: 
181: unique_ptr<ParsedExpression> BindContext::ExpandGeneratedColumn(TableBinding &table_binding,
182:                                                                 const string &column_name) {
183: 	auto result = table_binding.ExpandGeneratedColumn(column_name);
184: 	result->alias = column_name;
185: 	return result;
186: }
187: 
188: unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const BindingAlias &table_alias,
189:                                                                 const string &column_name, ColumnBindType bind_type) {
190: 	return CreateColumnReference(table_alias.GetCatalog(), table_alias.GetSchema(), table_alias.GetAlias(), column_name,
191: 	                             bind_type);
192: }
193: 
194: unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const string &table_name, const string &column_name,
195:                                                                 ColumnBindType bind_type) {
196: 	string schema_name;
197: 	return CreateColumnReference(schema_name, table_name, column_name, bind_type);
198: }
199: 
200: static bool ColumnIsGenerated(Binding &binding, column_t index) {
201: 	if (binding.binding_type != BindingType::TABLE) {
202: 		return false;
203: 	}
204: 	auto &table_binding = binding.Cast<TableBinding>();
205: 	auto catalog_entry = table_binding.GetStandardEntry();
206: 	if (!catalog_entry) {
207: 		return false;
208: 	}
209: 	if (index == COLUMN_IDENTIFIER_ROW_ID) {
210: 		return false;
211: 	}
212: 	D_ASSERT(catalog_entry->type == CatalogType::TABLE_ENTRY);
213: 	auto &table_entry = catalog_entry->Cast<TableCatalogEntry>();
214: 	return table_entry.GetColumn(LogicalIndex(index)).Generated();
215: }
216: 
217: unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const string &catalog_name, const string &schema_name,
218:                                                                 const string &table_name, const string &column_name,
219:                                                                 ColumnBindType bind_type) {
220: 	ErrorData error;
221: 	vector<string> names;
222: 	if (!catalog_name.empty()) {
223: 		names.push_back(catalog_name);
224: 	}
225: 	if (!schema_name.empty()) {
226: 		names.push_back(schema_name);
227: 	}
228: 	names.push_back(table_name);
229: 	names.push_back(column_name);
230: 
231: 	BindingAlias alias(catalog_name, schema_name, table_name);
232: 	auto result = make_uniq<ColumnRefExpression>(std::move(names));
233: 	auto binding = GetBinding(alias, error);
234: 	if (!binding) {
235: 		return std::move(result);
236: 	}
237: 	auto column_index = binding->GetBindingIndex(column_name);
238: 	if (bind_type == ColumnBindType::EXPAND_GENERATED_COLUMNS && ColumnIsGenerated(*binding, column_index)) {
239: 		return ExpandGeneratedColumn(binding->Cast<TableBinding>(), column_name);
240: 	} else if (column_index < binding->names.size() && binding->names[column_index] != column_name) {
241: 		// because of case insensitivity in the binder we rename the column to the original name
242: 		// as it appears in the binding itself
243: 		result->alias = binding->names[column_index];
244: 	}
245: 	return std::move(result);
246: }
247: 
248: unique_ptr<ParsedExpression> BindContext::CreateColumnReference(const string &schema_name, const string &table_name,
249:                                                                 const string &column_name, ColumnBindType bind_type) {
250: 	string catalog_name;
251: 	return CreateColumnReference(catalog_name, schema_name, table_name, column_name, bind_type);
252: }
253: 
254: optional_ptr<Binding> BindContext::GetCTEBinding(const string &ctename) {
255: 	auto match = cte_bindings.find(ctename);
256: 	if (match == cte_bindings.end()) {
257: 		return nullptr;
258: 	}
259: 	return match->second.get();
260: }
261: 
262: optional_ptr<Binding> BindContext::GetBinding(const BindingAlias &alias, ErrorData &out_error) {
263: 	if (!alias.IsSet()) {
264: 		throw InternalException("BindingAlias is not set");
265: 	}
266: 	vector<reference<Binding>> matching_bindings;
267: 	for (auto &binding : bindings_list) {
268: 		if (binding->alias.Matches(alias)) {
269: 			matching_bindings.push_back(*binding);
270: 		}
271: 	}
272: 	if (matching_bindings.size() == 1) {
273: 		// found a matching alias
274: 		return &matching_bindings[0].get();
275: 	}
276: 	if (matching_bindings.size() > 1) {
277: 		// found multiple matching aliases
278: 		string result = "(use: ";
279: 		for (idx_t i = 0; i < matching_bindings.size(); i++) {
280: 			if (i > 0) {
281: 				if (i + 1 == matching_bindings.size()) {
282: 					result += " or ";
283: 				} else {
284: 					result += ", ";
285: 				}
286: 			}
287: 			// find the minimum alias that uniquely describes this table reference
288: 			auto &current_alias = matching_bindings[i].get().alias;
289: 			string minimum_alias;
290: 			for (idx_t k = 0; k < matching_bindings.size(); k++) {
291: 				if (k == i) {
292: 					continue;
293: 				}
294: 				auto &other_alias = matching_bindings[k].get().alias;
295: 				string new_minimum_alias = MinimumUniqueAlias(current_alias, other_alias);
296: 				if (new_minimum_alias.size() > minimum_alias.size()) {
297: 					minimum_alias = std::move(new_minimum_alias);
298: 				}
299: 			}
300: 			result += minimum_alias;
301: 		}
302: 		result += ")";
303: 		throw BinderException("Ambiguous reference to table \"%s\" %s", alias.ToString(), result);
304: 	}
305: 	// alias not found in this BindContext
306: 	vector<string> candidates;
307: 	for (auto &binding : bindings_list) {
308: 		candidates.push_back(binding->alias.GetAlias());
309: 	}
310: 	string candidate_str =
311: 	    StringUtil::CandidatesMessage(StringUtil::TopNJaroWinkler(candidates, alias.GetAlias()), "Candidate tables");
312: 	out_error = ErrorData(ExceptionType::BINDER,
313: 	                      StringUtil::Format("Referenced table \"%s\" not found!%s", alias.GetAlias(), candidate_str));
314: 	return nullptr;
315: }
316: 
317: optional_ptr<Binding> BindContext::GetBinding(const string &name, ErrorData &out_error) {
318: 	return GetBinding(BindingAlias(name), out_error);
319: }
320: 
321: BindingAlias GetBindingAlias(ColumnRefExpression &colref) {
322: 	if (colref.column_names.size() <= 1 || colref.column_names.size() > 4) {
323: 		throw InternalException("Cannot get binding alias from column ref unless it has 2..4 entries");
324: 	}
325: 	if (colref.column_names.size() >= 4) {
326: 		return BindingAlias(colref.column_names[0], colref.column_names[1], colref.column_names[2]);
327: 	}
328: 	if (colref.column_names.size() == 3) {
329: 		return BindingAlias(colref.column_names[0], colref.column_names[1]);
330: 	}
331: 	return BindingAlias(colref.column_names[0]);
332: }
333: 
334: BindResult BindContext::BindColumn(ColumnRefExpression &colref, idx_t depth) {
335: 	if (!colref.IsQualified()) {
336: 		throw InternalException("Could not bind alias \"%s\"!", colref.GetColumnName());
337: 	}
338: 
339: 	ErrorData error;
340: 	BindingAlias alias;
341: 	auto binding = GetBinding(GetBindingAlias(colref), error);
342: 	if (!binding) {
343: 		return BindResult(std::move(error));
344: 	}
345: 	return binding->Bind(colref, depth);
346: }
347: 
348: string BindContext::BindColumn(PositionalReferenceExpression &ref, string &table_name, string &column_name) {
349: 	idx_t total_columns = 0;
350: 	idx_t current_position = ref.index - 1;
351: 	for (auto &entry : bindings_list) {
352: 		auto &binding = *entry;
353: 		idx_t entry_column_count = binding.names.size();
354: 		if (ref.index == 0) {
355: 			// this is a row id
356: 			table_name = binding.alias.GetAlias();
357: 			column_name = "rowid";
358: 			return string();
359: 		}
360: 		if (current_position < entry_column_count) {
361: 			table_name = binding.alias.GetAlias();
362: 			column_name = binding.names[current_position];
363: 			return string();
364: 		} else {
365: 			total_columns += entry_column_count;
366: 			current_position -= entry_column_count;
367: 		}
368: 	}
369: 	return StringUtil::Format("Positional reference %d out of range (total %d columns)", ref.index, total_columns);
370: }
371: 
372: unique_ptr<ColumnRefExpression> BindContext::PositionToColumn(PositionalReferenceExpression &ref) {
373: 	string table_name, column_name;
374: 
375: 	string error = BindColumn(ref, table_name, column_name);
376: 	if (!error.empty()) {
377: 		throw BinderException(error);
378: 	}
379: 	return make_uniq<ColumnRefExpression>(column_name, table_name);
380: }
381: 
382: bool BindContext::CheckExclusionList(StarExpression &expr, const string &column_name,
383:                                      vector<unique_ptr<ParsedExpression>> &new_select_list,
384:                                      case_insensitive_set_t &excluded_columns) {
385: 	if (expr.exclude_list.find(column_name) != expr.exclude_list.end()) {
386: 		excluded_columns.insert(column_name);
387: 		return true;
388: 	}
389: 	auto entry = expr.replace_list.find(column_name);
390: 	if (entry != expr.replace_list.end()) {
391: 		auto new_entry = entry->second->Copy();
392: 		new_entry->alias = entry->first;
393: 		excluded_columns.insert(entry->first);
394: 		new_select_list.push_back(std::move(new_entry));
395: 		return true;
396: 	}
397: 	return false;
398: }
399: 
400: void BindContext::GenerateAllColumnExpressions(StarExpression &expr,
401:                                                vector<unique_ptr<ParsedExpression>> &new_select_list) {
402: 	if (bindings_list.empty()) {
403: 		throw BinderException("* expression without FROM clause!");
404: 	}
405: 	case_insensitive_set_t excluded_columns;
406: 	if (expr.relation_name.empty()) {
407: 		// SELECT * case
408: 		// bind all expressions of each table in-order
409: 		reference_set_t<UsingColumnSet> handled_using_columns;
410: 		for (auto &entry : bindings_list) {
411: 			auto &binding = *entry;
412: 			for (auto &column_name : binding.names) {
413: 				if (CheckExclusionList(expr, column_name, new_select_list, excluded_columns)) {
414: 					continue;
415: 				}
416: 				// check if this column is a USING column
417: 				auto using_binding_ptr = GetUsingBinding(column_name, binding.alias);
418: 				if (using_binding_ptr) {
419: 					auto &using_binding = *using_binding_ptr;
420: 					// it is!
421: 					// check if we have already emitted the using column
422: 					if (handled_using_columns.find(using_binding) != handled_using_columns.end()) {
423: 						// we have! bail out
424: 						continue;
425: 					}
426: 					// we have not! output the using column
427: 					if (!using_binding.primary_binding.IsSet()) {
428: 						// no primary binding: output a coalesce
429: 						auto coalesce = make_uniq<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
430: 						for (auto &child_binding : using_binding.bindings) {
431: 							coalesce->children.push_back(make_uniq<ColumnRefExpression>(column_name, child_binding));
432: 						}
433: 						coalesce->alias = column_name;
434: 						new_select_list.push_back(std::move(coalesce));
435: 					} else {
436: 						// primary binding: output the qualified column ref
437: 						new_select_list.push_back(
438: 						    make_uniq<ColumnRefExpression>(column_name, using_binding.primary_binding));
439: 					}
440: 					handled_using_columns.insert(using_binding);
441: 					continue;
442: 				}
443: 				new_select_list.push_back(
444: 				    CreateColumnReference(binding.alias, column_name, ColumnBindType::DO_NOT_EXPAND_GENERATED_COLUMNS));
445: 			}
446: 		}
447: 	} else {
448: 		// SELECT tbl.* case
449: 		// SELECT struct.* case
450: 		ErrorData error;
451: 		auto binding = GetBinding(expr.relation_name, error);
452: 		bool is_struct_ref = false;
453: 		if (!binding) {
454: 			binding = GetMatchingBinding(expr.relation_name);
455: 			if (!binding) {
456: 				error.Throw();
457: 			}
458: 			is_struct_ref = true;
459: 		}
460: 
461: 		if (is_struct_ref) {
462: 			auto col_idx = binding->GetBindingIndex(expr.relation_name);
463: 			auto col_type = binding->types[col_idx];
464: 			if (col_type.id() != LogicalTypeId::STRUCT) {
465: 				throw BinderException(StringUtil::Format(
466: 				    "Cannot extract field from expression \"%s\" because it is not a struct", expr.ToString()));
467: 			}
468: 			auto &struct_children = StructType::GetChildTypes(col_type);
469: 			vector<string> column_names(3);
470: 			column_names[0] = binding->alias.GetAlias();
471: 			column_names[1] = expr.relation_name;
472: 			for (auto &child : struct_children) {
473: 				if (CheckExclusionList(expr, child.first, new_select_list, excluded_columns)) {
474: 					continue;
475: 				}
476: 				column_names[2] = child.first;
477: 				new_select_list.push_back(make_uniq<ColumnRefExpression>(column_names));
478: 			}
479: 		} else {
480: 			for (auto &column_name : binding->names) {
481: 				if (CheckExclusionList(expr, column_name, new_select_list, excluded_columns)) {
482: 					continue;
483: 				}
484: 
485: 				new_select_list.push_back(CreateColumnReference(binding->alias, column_name,
486: 				                                                ColumnBindType::DO_NOT_EXPAND_GENERATED_COLUMNS));
487: 			}
488: 		}
489: 	}
490: 	if (binder.GetBindingMode() == BindingMode::EXTRACT_NAMES) {
491: 		expr.exclude_list.clear();
492: 		expr.replace_list.clear();
493: 	}
494: 	for (auto &excluded : expr.exclude_list) {
495: 		if (excluded_columns.find(excluded) == excluded_columns.end()) {
496: 			throw BinderException("Column \"%s\" in EXCLUDE list not found in %s", excluded,
497: 			                      expr.relation_name.empty() ? "FROM clause" : expr.relation_name.c_str());
498: 		}
499: 	}
500: 	for (auto &entry : expr.replace_list) {
501: 		if (excluded_columns.find(entry.first) == excluded_columns.end()) {
502: 			throw BinderException("Column \"%s\" in REPLACE list not found in %s", entry.first,
503: 			                      expr.relation_name.empty() ? "FROM clause" : expr.relation_name.c_str());
504: 		}
505: 	}
506: }
507: 
508: void BindContext::GetTypesAndNames(vector<string> &result_names, vector<LogicalType> &result_types) {
509: 	for (auto &binding_entry : bindings_list) {
510: 		auto &binding = *binding_entry;
511: 		D_ASSERT(binding.names.size() == binding.types.size());
512: 		for (idx_t i = 0; i < binding.names.size(); i++) {
513: 			result_names.push_back(binding.names[i]);
514: 			result_types.push_back(binding.types[i]);
515: 		}
516: 	}
517: }
518: 
519: void BindContext::AddBinding(unique_ptr<Binding> binding) {
520: 	for (auto &other_bindings : bindings_list) {
521: 		if (binding->alias == other_bindings->alias) {
522: 			throw BinderException("Duplicate alias \"%s\" in query!", binding->alias.GetAlias());
523: 		}
524: 	}
525: 	bindings_list.push_back(std::move(binding));
526: }
527: 
528: void BindContext::AddBaseTable(idx_t index, const string &alias, const vector<string> &names,
529:                                const vector<LogicalType> &types, vector<column_t> &bound_column_ids,
530:                                StandardEntry &entry, bool add_row_id) {
531: 	AddBinding(make_uniq<TableBinding>(alias, types, names, bound_column_ids, &entry, index, add_row_id));
532: }
533: 
534: void BindContext::AddBaseTable(idx_t index, const string &alias, const vector<string> &names,
535:                                const vector<LogicalType> &types, vector<column_t> &bound_column_ids,
536:                                const string &table_name) {
537: 	AddBinding(
538: 	    make_uniq<TableBinding>(alias.empty() ? table_name : alias, types, names, bound_column_ids, nullptr, index));
539: }
540: 
541: void BindContext::AddTableFunction(idx_t index, const string &alias, const vector<string> &names,
542:                                    const vector<LogicalType> &types, vector<column_t> &bound_column_ids,
543:                                    optional_ptr<StandardEntry> entry) {
544: 	AddBinding(make_uniq<TableBinding>(alias, types, names, bound_column_ids, entry, index));
545: }
546: 
547: static string AddColumnNameToBinding(const string &base_name, case_insensitive_set_t &current_names) {
548: 	idx_t index = 1;
549: 	string name = base_name;
550: 	while (current_names.find(name) != current_names.end()) {
551: 		name = base_name + "_" + std::to_string(index++);
552: 	}
553: 	current_names.insert(name);
554: 	return name;
555: }
556: 
557: vector<string> BindContext::AliasColumnNames(const string &table_name, const vector<string> &names,
558:                                              const vector<string> &column_aliases) {
559: 	vector<string> result;
560: 	if (column_aliases.size() > names.size()) {
561: 		throw BinderException("table \"%s\" has %lld columns available but %lld columns specified", table_name,
562: 		                      names.size(), column_aliases.size());
563: 	}
564: 	case_insensitive_set_t current_names;
565: 	// use any provided column aliases first
566: 	for (idx_t i = 0; i < column_aliases.size(); i++) {
567: 		result.push_back(AddColumnNameToBinding(column_aliases[i], current_names));
568: 	}
569: 	// if not enough aliases were provided, use the default names for remaining columns
570: 	for (idx_t i = column_aliases.size(); i < names.size(); i++) {
571: 		result.push_back(AddColumnNameToBinding(names[i], current_names));
572: 	}
573: 	return result;
574: }
575: 
576: void BindContext::AddSubquery(idx_t index, const string &alias, SubqueryRef &ref, BoundQueryNode &subquery) {
577: 	auto names = AliasColumnNames(alias, subquery.names, ref.column_name_alias);
578: 	AddGenericBinding(index, alias, names, subquery.types);
579: }
580: 
581: void BindContext::AddEntryBinding(idx_t index, const string &alias, const vector<string> &names,
582:                                   const vector<LogicalType> &types, StandardEntry &entry) {
583: 	AddBinding(make_uniq<EntryBinding>(alias, types, names, index, entry));
584: }
585: 
586: void BindContext::AddView(idx_t index, const string &alias, SubqueryRef &ref, BoundQueryNode &subquery,
587:                           ViewCatalogEntry &view) {
588: 	auto names = AliasColumnNames(alias, subquery.names, ref.column_name_alias);
589: 	AddEntryBinding(index, alias, names, subquery.types, view.Cast<StandardEntry>());
590: }
591: 
592: void BindContext::AddSubquery(idx_t index, const string &alias, TableFunctionRef &ref, BoundQueryNode &subquery) {
593: 	auto names = AliasColumnNames(alias, subquery.names, ref.column_name_alias);
594: 	AddGenericBinding(index, alias, names, subquery.types);
595: }
596: 
597: void BindContext::AddGenericBinding(idx_t index, const string &alias, const vector<string> &names,
598:                                     const vector<LogicalType> &types) {
599: 	AddBinding(make_uniq<Binding>(BindingType::BASE, BindingAlias(alias), types, names, index));
600: }
601: 
602: void BindContext::AddCTEBinding(idx_t index, const string &alias, const vector<string> &names,
603:                                 const vector<LogicalType> &types) {
604: 	auto binding = make_shared_ptr<Binding>(BindingType::BASE, BindingAlias(alias), types, names, index);
605: 
606: 	if (cte_bindings.find(alias) != cte_bindings.end()) {
607: 		throw BinderException("Duplicate alias \"%s\" in query!", alias);
608: 	}
609: 	cte_bindings[alias] = std::move(binding);
610: 	cte_references[alias] = make_shared_ptr<idx_t>(0);
611: }
612: 
613: void BindContext::AddContext(BindContext other) {
614: 	for (auto &binding : other.bindings_list) {
615: 		AddBinding(std::move(binding));
616: 	}
617: 	for (auto &entry : other.using_columns) {
618: 		for (auto &alias : entry.second) {
619: #ifdef DEBUG
620: 			for (auto &other_alias : using_columns[entry.first]) {
621: 				for (auto &col : alias.get().bindings) {
622: 					D_ASSERT(std::find(other_alias.get().bindings.begin(), other_alias.get().bindings.end(), col) ==
623: 					         other_alias.get().bindings.end());
624: 				}
625: 			}
626: #endif
627: 			using_columns[entry.first].insert(alias);
628: 		}
629: 	}
630: }
631: 
632: vector<BindingAlias> BindContext::GetBindingAliases() {
633: 	vector<BindingAlias> result;
634: 	for (auto &binding : bindings_list) {
635: 		result.push_back(BindingAlias(binding->alias));
636: 	}
637: 	return result;
638: }
639: 
640: void BindContext::RemoveContext(const vector<BindingAlias> &aliases) {
641: 	for (auto &alias : aliases) {
642: 		auto it = std::remove_if(bindings_list.begin(), bindings_list.end(),
643: 		                         [&](unique_ptr<Binding> &x) { return x->alias == alias; });
644: 		bindings_list.erase(it, bindings_list.end());
645: 	}
646: }
647: 
648: } // namespace duckdb
[end of src/planner/bind_context.cpp]
[start of src/planner/binder/expression/bind_columnref_expression.cpp]
1: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/function/scalar/nested_functions.hpp"
4: #include "duckdb/parser/expression/columnref_expression.hpp"
5: #include "duckdb/parser/expression/constant_expression.hpp"
6: #include "duckdb/parser/expression/function_expression.hpp"
7: #include "duckdb/parser/expression/operator_expression.hpp"
8: #include "duckdb/parser/expression/positional_reference_expression.hpp"
9: #include "duckdb/parser/expression/subquery_expression.hpp"
10: #include "duckdb/parser/parsed_expression_iterator.hpp"
11: #include "duckdb/planner/binder.hpp"
12: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
13: #include "duckdb/planner/expression/bound_constant_expression.hpp"
14: #include "duckdb/planner/expression_binder.hpp"
15: #include "duckdb/planner/expression_binder/where_binder.hpp"
16: 
17: namespace duckdb {
18: 
19: string GetSQLValueFunctionName(const string &column_name) {
20: 	auto lcase = StringUtil::Lower(column_name);
21: 	if (lcase == "current_catalog") {
22: 		return "current_catalog";
23: 	} else if (lcase == "current_date") {
24: 		return "current_date";
25: 	} else if (lcase == "current_schema") {
26: 		return "current_schema";
27: 	} else if (lcase == "current_role") {
28: 		return "current_role";
29: 	} else if (lcase == "current_time") {
30: 		return "get_current_time";
31: 	} else if (lcase == "current_timestamp") {
32: 		return "get_current_timestamp";
33: 	} else if (lcase == "current_user") {
34: 		return "current_user";
35: 	} else if (lcase == "localtime") {
36: 		return "current_localtime";
37: 	} else if (lcase == "localtimestamp") {
38: 		return "current_localtimestamp";
39: 	} else if (lcase == "session_user") {
40: 		return "session_user";
41: 	} else if (lcase == "user") {
42: 		return "user";
43: 	}
44: 	return string();
45: }
46: 
47: unique_ptr<ParsedExpression> ExpressionBinder::GetSQLValueFunction(const string &column_name) {
48: 	auto value_function = GetSQLValueFunctionName(column_name);
49: 	if (value_function.empty()) {
50: 		return nullptr;
51: 	}
52: 
53: 	vector<unique_ptr<ParsedExpression>> children;
54: 	return make_uniq<FunctionExpression>(value_function, std::move(children));
55: }
56: 
57: unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(const string &column_name, ErrorData &error) {
58: 	auto using_binding = binder.bind_context.GetUsingBinding(column_name);
59: 	if (using_binding) {
60: 		// we are referencing a USING column
61: 		// check if we can refer to one of the base columns directly
62: 		unique_ptr<Expression> expression;
63: 		if (using_binding->primary_binding.IsSet()) {
64: 			// we can! just assign the table name and re-bind
65: 			return binder.bind_context.CreateColumnReference(using_binding->primary_binding, column_name);
66: 		} else {
67: 			// we cannot! we need to bind this as COALESCE between all the relevant columns
68: 			auto coalesce = make_uniq<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
69: 			coalesce->children.reserve(using_binding->bindings.size());
70: 			for (auto &entry : using_binding->bindings) {
71: 				coalesce->children.push_back(make_uniq<ColumnRefExpression>(column_name, entry));
72: 			}
73: 			return std::move(coalesce);
74: 		}
75: 	}
76: 
77: 	// try binding as a lambda parameter
78: 	auto lambda_ref = LambdaRefExpression::FindMatchingBinding(lambda_bindings, column_name);
79: 	if (lambda_ref) {
80: 		return lambda_ref;
81: 	}
82: 
83: 	// find a table binding that contains this column name
84: 	auto table_binding = binder.bind_context.GetMatchingBinding(column_name);
85: 
86: 	// throw an error if a macro parameter name conflicts with a column name
87: 	auto is_macro_column = false;
88: 	if (binder.macro_binding && binder.macro_binding->HasMatchingBinding(column_name)) {
89: 		is_macro_column = true;
90: 		if (table_binding) {
91: 			throw BinderException("Conflicting column names for column " + column_name + "!");
92: 		}
93: 	}
94: 
95: 	// bind as a macro column
96: 	if (is_macro_column) {
97: 		return binder.bind_context.CreateColumnReference(binder.macro_binding->alias, column_name);
98: 	}
99: 
100: 	// bind as a regular column
101: 	if (table_binding) {
102: 		return binder.bind_context.CreateColumnReference(table_binding->alias, column_name);
103: 	}
104: 
105: 	// it's not, find candidates and error
106: 	auto similar_bindings = binder.bind_context.GetSimilarBindings(column_name);
107: 	error = ErrorData(BinderException::ColumnNotFound(column_name, similar_bindings));
108: 	return nullptr;
109: }
110: 
111: void ExpressionBinder::QualifyColumnNames(unique_ptr<ParsedExpression> &expr,
112:                                           vector<unordered_set<string>> &lambda_params,
113:                                           const bool within_function_expression) {
114: 
115: 	bool next_within_function_expression = false;
116: 	switch (expr->type) {
117: 	case ExpressionType::COLUMN_REF: {
118: 		auto &col_ref = expr->Cast<ColumnRefExpression>();
119: 
120: 		// don't qualify lambda parameters
121: 		if (LambdaExpression::IsLambdaParameter(lambda_params, col_ref.GetName())) {
122: 			return;
123: 		}
124: 
125: 		ErrorData error;
126: 		auto new_expr = QualifyColumnName(col_ref, error);
127: 
128: 		if (new_expr) {
129: 			if (!expr->alias.empty()) {
130: 				// Pre-existing aliases are added to the qualified column reference
131: 				new_expr->alias = expr->alias;
132: 			} else if (within_function_expression) {
133: 				// Qualifying the column reference may add an alias, but this needs to be removed within function
134: 				// expressions, because the alias here means a named parameter instead of a positional parameter
135: 				new_expr->alias = "";
136: 			}
137: 
138: 			// replace the expression with the qualified column reference
139: 			new_expr->query_location = col_ref.query_location;
140: 			expr = std::move(new_expr);
141: 		}
142: 		return;
143: 	}
144: 	case ExpressionType::POSITIONAL_REFERENCE: {
145: 		auto &ref = expr->Cast<PositionalReferenceExpression>();
146: 		if (ref.alias.empty()) {
147: 			string table_name, column_name;
148: 			auto error = binder.bind_context.BindColumn(ref, table_name, column_name);
149: 			if (error.empty()) {
150: 				ref.alias = column_name;
151: 			}
152: 		}
153: 		break;
154: 	}
155: 	case ExpressionType::FUNCTION: {
156: 		// Special-handling for lambdas, which are inside function expressions.
157: 		auto &function = expr->Cast<FunctionExpression>();
158: 		if (function.IsLambdaFunction()) {
159: 			return QualifyColumnNamesInLambda(function, lambda_params);
160: 		}
161: 
162: 		next_within_function_expression = true;
163: 		break;
164: 	}
165: 	default: // fall through
166: 		break;
167: 	}
168: 
169: 	// recurse on the child expressions
170: 	ParsedExpressionIterator::EnumerateChildren(*expr, [&](unique_ptr<ParsedExpression> &child) {
171: 		QualifyColumnNames(child, lambda_params, next_within_function_expression);
172: 	});
173: }
174: 
175: void ExpressionBinder::QualifyColumnNamesInLambda(FunctionExpression &function,
176:                                                   vector<unordered_set<string>> &lambda_params) {
177: 
178: 	for (auto &child : function.children) {
179: 		if (child->expression_class != ExpressionClass::LAMBDA) {
180: 			// not a lambda expression
181: 			QualifyColumnNames(child, lambda_params, true);
182: 			continue;
183: 		}
184: 
185: 		// special-handling for LHS lambda parameters
186: 		// we do not qualify them, and we add them to the lambda_params vector
187: 		auto &lambda_expr = child->Cast<LambdaExpression>();
188: 		string error_message;
189: 		auto column_ref_expressions = lambda_expr.ExtractColumnRefExpressions(error_message);
190: 
191: 		if (!error_message.empty()) {
192: 			// possibly a JSON function, qualify both LHS and RHS
193: 			QualifyColumnNames(lambda_expr.lhs, lambda_params, true);
194: 			QualifyColumnNames(lambda_expr.expr, lambda_params, true);
195: 			continue;
196: 		}
197: 
198: 		// push this level
199: 		lambda_params.emplace_back();
200: 
201: 		// push the lambda parameter names
202: 		for (const auto &column_ref_expr : column_ref_expressions) {
203: 			const auto &column_ref = column_ref_expr.get().Cast<ColumnRefExpression>();
204: 			lambda_params.back().emplace(column_ref.GetName());
205: 		}
206: 
207: 		// only qualify in RHS
208: 		QualifyColumnNames(lambda_expr.expr, lambda_params, true);
209: 
210: 		// pop this level
211: 		lambda_params.pop_back();
212: 	}
213: }
214: 
215: void ExpressionBinder::QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr) {
216: 	WhereBinder where_binder(binder, binder.context);
217: 	vector<unordered_set<string>> lambda_params;
218: 	where_binder.QualifyColumnNames(expr, lambda_params);
219: }
220: 
221: unique_ptr<ParsedExpression> ExpressionBinder::CreateStructExtract(unique_ptr<ParsedExpression> base,
222:                                                                    const string &field_name) {
223: 
224: 	vector<unique_ptr<ParsedExpression>> children;
225: 	children.push_back(std::move(base));
226: 	children.push_back(make_uniq_base<ParsedExpression, ConstantExpression>(Value(field_name)));
227: 	auto extract_fun = make_uniq<OperatorExpression>(ExpressionType::STRUCT_EXTRACT, std::move(children));
228: 	return std::move(extract_fun);
229: }
230: 
231: unique_ptr<ParsedExpression> ExpressionBinder::CreateStructPack(ColumnRefExpression &col_ref) {
232: 	if (col_ref.column_names.size() > 3) {
233: 		return nullptr;
234: 	}
235: 	D_ASSERT(!col_ref.column_names.empty());
236: 
237: 	// get a matching binding
238: 	ErrorData error;
239: 	optional_ptr<Binding> binding;
240: 	switch (col_ref.column_names.size()) {
241: 	case 1: {
242: 		// single entry - this must be the table name
243: 		BindingAlias alias(col_ref.column_names[0]);
244: 		binding = binder.bind_context.GetBinding(alias, error);
245: 		break;
246: 	}
247: 	case 2: {
248: 		// two entries - this can either be "catalog.table" or "schema.table" - try both
249: 		BindingAlias alias(col_ref.column_names[0], col_ref.column_names[1]);
250: 		binding = binder.bind_context.GetBinding(alias, error);
251: 		if (!binding) {
252: 			alias = BindingAlias(col_ref.column_names[0], INVALID_SCHEMA, col_ref.column_names[1]);
253: 			binding = binder.bind_context.GetBinding(alias, error);
254: 		}
255: 		break;
256: 	}
257: 	case 3: {
258: 		// three entries - this must be "catalog.schema.table"
259: 		BindingAlias alias(col_ref.column_names[0], col_ref.column_names[1], col_ref.column_names[2]);
260: 		binding = binder.bind_context.GetBinding(alias, error);
261: 		break;
262: 	}
263: 	default:
264: 		throw InternalException("Expected 1, 2 or 3 column names for CreateStructPack");
265: 	}
266: 	if (!binding) {
267: 		return nullptr;
268: 	}
269: 
270: 	// We found the table, now create the struct_pack expression
271: 	vector<unique_ptr<ParsedExpression>> child_expressions;
272: 	child_expressions.reserve(binding->names.size());
273: 	for (const auto &column_name : binding->names) {
274: 		child_expressions.push_back(binder.bind_context.CreateColumnReference(
275: 		    binding->alias, column_name, ColumnBindType::DO_NOT_EXPAND_GENERATED_COLUMNS));
276: 	}
277: 	return make_uniq<FunctionExpression>("struct_pack", std::move(child_expressions));
278: }
279: 
280: unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnNameWithManyDotsInternal(ColumnRefExpression &col_ref,
281:                                                                                      ErrorData &error,
282:                                                                                      idx_t &struct_extract_start) {
283: 	// two or more dots (i.e. "part1.part2.part3.part4...")
284: 	// -> part1 is a catalog, part2 is a schema, part3 is a table, part4 is a column name, part 5 and beyond are
285: 	// struct fields
286: 	// -> part1 is a catalog, part2 is a table, part3 is a column name, part4 and beyond are struct fields
287: 	// -> part1 is a schema, part2 is a table, part3 is a column name, part4 and beyond are struct fields
288: 	// -> part1 is a table, part2 is a column name, part3 and beyond are struct fields
289: 	// -> part1 is a column, part2 and beyond are struct fields
290: 
291: 	// we always prefer the most top-level view
292: 	// i.e. in case of multiple resolution options, we resolve in order:
293: 	// -> 1. resolve "part1" as a catalog
294: 	// -> 2. resolve "part1" as a schema
295: 	// -> 3. resolve "part1" as a table
296: 	// -> 4. resolve "part1" as a column
297: 
298: 	// first check if part1 is a catalog
299: 	optional_ptr<Binding> binding;
300: 	if (col_ref.column_names.size() > 3) {
301: 		binding = binder.GetMatchingBinding(col_ref.column_names[0], col_ref.column_names[1], col_ref.column_names[2],
302: 		                                    col_ref.column_names[3], error);
303: 		if (binding) {
304: 			// part1 is a catalog - the column reference is "catalog.schema.table.column"
305: 			struct_extract_start = 4;
306: 			return binder.bind_context.CreateColumnReference(binding->alias, col_ref.column_names[3]);
307: 		}
308: 	}
309: 	binding = binder.GetMatchingBinding(col_ref.column_names[0], INVALID_SCHEMA, col_ref.column_names[1],
310: 	                                    col_ref.column_names[2], error);
311: 	if (binding) {
312: 		// part1 is a catalog - the column reference is "catalog.table.column"
313: 		struct_extract_start = 3;
314: 		return binder.bind_context.CreateColumnReference(binding->alias, col_ref.column_names[2]);
315: 	}
316: 	binding =
317: 	    binder.GetMatchingBinding(col_ref.column_names[0], col_ref.column_names[1], col_ref.column_names[2], error);
318: 	if (binding) {
319: 		// part1 is a schema - the column reference is "schema.table.column"
320: 		// any additional fields are turned into struct_extract calls
321: 		struct_extract_start = 3;
322: 		return binder.bind_context.CreateColumnReference(binding->alias, col_ref.column_names[2]);
323: 	}
324: 	binding = binder.GetMatchingBinding(col_ref.column_names[0], col_ref.column_names[1], error);
325: 	if (binding) {
326: 		// part1 is a table
327: 		// the column reference is "table.column"
328: 		// any additional fields are turned into struct_extract calls
329: 		struct_extract_start = 2;
330: 		return binder.bind_context.CreateColumnReference(binding->alias, col_ref.column_names[1]);
331: 	}
332: 	// part1 could be a column
333: 	ErrorData col_error;
334: 	auto result_expr = QualifyColumnName(col_ref.column_names[0], col_error);
335: 	if (result_expr) {
336: 		// it is! add the struct extract calls
337: 		struct_extract_start = 1;
338: 		return result_expr;
339: 	}
340: 	return CreateStructPack(col_ref);
341: }
342: unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnNameWithManyDots(ColumnRefExpression &col_ref,
343:                                                                              ErrorData &error) {
344: 	idx_t struct_extract_start = col_ref.column_names.size();
345: 	auto result_expr = QualifyColumnNameWithManyDotsInternal(col_ref, error, struct_extract_start);
346: 	if (!result_expr) {
347: 		return nullptr;
348: 	}
349: 
350: 	// create a struct extract with all remaining column names
351: 	for (idx_t i = struct_extract_start; i < col_ref.column_names.size(); i++) {
352: 		result_expr = CreateStructExtract(std::move(result_expr), col_ref.column_names[i]);
353: 	}
354: 
355: 	return result_expr;
356: }
357: 
358: unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(ColumnRefExpression &col_ref, ErrorData &error) {
359: 
360: 	// try binding as a lambda parameter
361: 	if (!col_ref.IsQualified()) {
362: 		auto lambda_ref = LambdaRefExpression::FindMatchingBinding(lambda_bindings, col_ref.GetName());
363: 		if (lambda_ref) {
364: 			return lambda_ref;
365: 		}
366: 	}
367: 
368: 	idx_t column_parts = col_ref.column_names.size();
369: 
370: 	// column names can have an arbitrary amount of dots
371: 	// here is how the resolution works:
372: 	if (column_parts == 1) {
373: 		// no dots (i.e. "part1")
374: 		// -> part1 refers to a column
375: 		// check if we can qualify the column name with the table name
376: 		auto qualified_col_ref = QualifyColumnName(col_ref.GetColumnName(), error);
377: 		if (qualified_col_ref) {
378: 			// we could: return it
379: 			return qualified_col_ref;
380: 		}
381: 		// we could not! Try creating an implicit struct_pack
382: 		return CreateStructPack(col_ref);
383: 	}
384: 
385: 	if (column_parts == 2) {
386: 		// one dot (i.e. "part1.part2")
387: 		// EITHER:
388: 		// -> part1 is a table, part2 is a column
389: 		// -> part1 is a column, part2 is a property of that column (i.e. struct_extract)
390: 
391: 		// first check if part1 is a table, and part2 is a standard column name
392: 		auto binding = binder.GetMatchingBinding(col_ref.column_names[0], col_ref.column_names[1], error);
393: 		if (binding) {
394: 			// it is! return the column reference directly
395: 			return binder.bind_context.CreateColumnReference(binding->alias, col_ref.GetColumnName());
396: 		}
397: 
398: 		// otherwise check if we can turn this into a struct extract
399: 		ErrorData other_error;
400: 		auto qualified_col_ref = QualifyColumnName(col_ref.column_names[0], other_error);
401: 		if (qualified_col_ref) {
402: 			// we could: create a struct extract
403: 			return CreateStructExtract(std::move(qualified_col_ref), col_ref.column_names[1]);
404: 		}
405: 		// we could not! Try creating an implicit struct_pack
406: 		return CreateStructPack(col_ref);
407: 	}
408: 
409: 	// three or more dots
410: 	return QualifyColumnNameWithManyDots(col_ref, error);
411: }
412: 
413: BindResult ExpressionBinder::BindExpression(LambdaRefExpression &lambda_ref, idx_t depth) {
414: 	D_ASSERT(lambda_bindings && lambda_ref.lambda_idx < lambda_bindings->size());
415: 	return (*lambda_bindings)[lambda_ref.lambda_idx].Bind(lambda_ref, depth);
416: }
417: 
418: BindResult ExpressionBinder::BindExpression(ColumnRefExpression &col_ref_p, idx_t depth, bool root_expression) {
419: 	if (binder.GetBindingMode() == BindingMode::EXTRACT_NAMES) {
420: 		return BindResult(make_uniq<BoundConstantExpression>(Value(LogicalType::SQLNULL)));
421: 	}
422: 
423: 	ErrorData error;
424: 	auto expr = QualifyColumnName(col_ref_p, error);
425: 	if (!expr) {
426: 		if (!col_ref_p.IsQualified()) {
427: 			// column was not found
428: 			// first try to bind it as an alias
429: 			BindResult alias_result;
430: 			auto found_alias = TryBindAlias(col_ref_p, root_expression, alias_result);
431: 			if (found_alias) {
432: 				return alias_result;
433: 			}
434: 
435: 			// column was not found - check if it is a SQL value function
436: 			auto value_function = GetSQLValueFunction(col_ref_p.GetColumnName());
437: 			if (value_function) {
438: 				return BindExpression(value_function, depth);
439: 			}
440: 		}
441: 		error.AddQueryLocation(col_ref_p);
442: 		return BindResult(std::move(error));
443: 	}
444: 
445: 	expr->query_location = col_ref_p.query_location;
446: 
447: 	// the above QualifyColumName returns a generated expression for a generated
448: 	// column, and struct_extract for a struct, or a lambda reference expression,
449: 	// all of them are not column reference expressions, so we return here
450: 	if (expr->type != ExpressionType::COLUMN_REF) {
451: 		auto alias = expr->alias;
452: 		auto result = BindExpression(expr, depth);
453: 		if (result.expression) {
454: 			result.expression->alias = std::move(alias);
455: 		}
456: 		return result;
457: 	}
458: 
459: 	// the above QualifyColumnName returned an individual column reference
460: 	// expression, which we resolve to either a base table or a subquery expression,
461: 	// and if it was a macro parameter, then we let macro_binding bind it to the argument
462: 	BindResult result;
463: 	auto &col_ref = expr->Cast<ColumnRefExpression>();
464: 	D_ASSERT(col_ref.IsQualified());
465: 	auto &table_name = col_ref.GetTableName();
466: 
467: 	if (binder.macro_binding && table_name == binder.macro_binding->GetAlias()) {
468: 		result = binder.macro_binding->Bind(col_ref, depth);
469: 	} else {
470: 		result = binder.bind_context.BindColumn(col_ref, depth);
471: 	}
472: 
473: 	if (result.HasError()) {
474: 		result.error.AddQueryLocation(col_ref_p);
475: 		return result;
476: 	}
477: 
478: 	// we bound the column reference
479: 	BoundColumnReferenceInfo ref;
480: 	ref.name = col_ref.column_names.back();
481: 	ref.query_location = col_ref.query_location;
482: 	bound_columns.push_back(std::move(ref));
483: 	return result;
484: }
485: 
486: bool ExpressionBinder::QualifyColumnAlias(const ColumnRefExpression &col_ref) {
487: 	// only the BaseSelectBinder will have a valid column alias map,
488: 	// otherwise we return false
489: 	return false;
490: }
491: } // namespace duckdb
[end of src/planner/binder/expression/bind_columnref_expression.cpp]
[start of src/planner/binder/query_node/bind_select_node.cpp]
1: #include "duckdb/common/limits.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/function/aggregate/distributive_functions.hpp"
5: #include "duckdb/function/function_binder.hpp"
6: #include "duckdb/main/config.hpp"
7: #include "duckdb/parser/expression/columnref_expression.hpp"
8: #include "duckdb/parser/expression/comparison_expression.hpp"
9: #include "duckdb/parser/expression/conjunction_expression.hpp"
10: #include "duckdb/parser/expression/constant_expression.hpp"
11: #include "duckdb/parser/expression/function_expression.hpp"
12: #include "duckdb/parser/expression/star_expression.hpp"
13: #include "duckdb/parser/expression/subquery_expression.hpp"
14: #include "duckdb/parser/parsed_expression_iterator.hpp"
15: #include "duckdb/parser/query_node/select_node.hpp"
16: #include "duckdb/parser/tableref/basetableref.hpp"
17: #include "duckdb/parser/tableref/joinref.hpp"
18: #include "duckdb/planner/binder.hpp"
19: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
20: #include "duckdb/planner/expression/bound_constant_expression.hpp"
21: #include "duckdb/planner/expression/bound_expanded_expression.hpp"
22: #include "duckdb/planner/expression_binder/column_alias_binder.hpp"
23: #include "duckdb/planner/expression_binder/constant_binder.hpp"
24: #include "duckdb/planner/expression_binder/group_binder.hpp"
25: #include "duckdb/planner/expression_binder/having_binder.hpp"
26: #include "duckdb/planner/expression_binder/order_binder.hpp"
27: #include "duckdb/planner/expression_binder/qualify_binder.hpp"
28: #include "duckdb/planner/expression_binder/select_bind_state.hpp"
29: #include "duckdb/planner/expression_binder/select_binder.hpp"
30: #include "duckdb/planner/expression_binder/where_binder.hpp"
31: #include "duckdb/planner/query_node/bound_select_node.hpp"
32: 
33: namespace duckdb {
34: 
35: unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {
36: 	// we treat the distinct list as an ORDER BY
37: 	auto bound_expr = order_binder.Bind(std::move(expr));
38: 	if (!bound_expr) {
39: 		// DISTINCT ON non-integer constant
40: 		// remove the expression from the DISTINCT ON list
41: 		return nullptr;
42: 	}
43: 	D_ASSERT(bound_expr->type == ExpressionType::VALUE_CONSTANT);
44: 	return bound_expr;
45: }
46: 
47: BoundLimitNode Binder::BindLimitValue(OrderBinder &order_binder, unique_ptr<ParsedExpression> limit_val,
48:                                       bool is_percentage, bool is_offset) {
49: 	auto new_binder = Binder::CreateBinder(context, this);
50: 	ExpressionBinder expr_binder(*new_binder, context);
51: 	auto target_type = is_percentage ? LogicalType::DOUBLE : LogicalType::BIGINT;
52: 	expr_binder.target_type = target_type;
53: 	auto original_limit = limit_val->Copy();
54: 	auto expr = expr_binder.Bind(limit_val);
55: 	if (expr->HasSubquery()) {
56: 		if (!order_binder.HasExtraList()) {
57: 			throw BinderException("Subquery in LIMIT/OFFSET not supported in set operation");
58: 		}
59: 		auto bound_limit = order_binder.CreateExtraReference(std::move(original_limit));
60: 		if (is_percentage) {
61: 			return BoundLimitNode::ExpressionPercentage(std::move(bound_limit));
62: 		} else {
63: 			return BoundLimitNode::ExpressionValue(std::move(bound_limit));
64: 		}
65: 	}
66: 	if (expr->IsFoldable()) {
67: 		//! this is a constant
68: 		auto val = ExpressionExecutor::EvaluateScalar(context, *expr).CastAs(context, target_type);
69: 		if (is_percentage) {
70: 			D_ASSERT(!is_offset);
71: 			double percentage_val;
72: 			if (val.IsNull()) {
73: 				percentage_val = 100.0;
74: 			} else {
75: 				percentage_val = val.GetValue<double>();
76: 			}
77: 			if (Value::IsNan(percentage_val) || percentage_val < 0 || percentage_val > 100) {
78: 				throw OutOfRangeException("Limit percent out of range, should be between 0% and 100%");
79: 			}
80: 			return BoundLimitNode::ConstantPercentage(percentage_val);
81: 		} else {
82: 			int64_t constant_val;
83: 			if (val.IsNull()) {
84: 				constant_val = is_offset ? 0 : NumericLimits<int64_t>::Maximum();
85: 			} else {
86: 				constant_val = val.GetValue<int64_t>();
87: 			}
88: 			if (constant_val < 0) {
89: 				throw BinderException(expr->query_location, "LIMIT/OFFSET cannot be negative");
90: 			}
91: 			return BoundLimitNode::ConstantValue(constant_val);
92: 		}
93: 	}
94: 	if (!new_binder->correlated_columns.empty()) {
95: 		throw BinderException("Correlated columns not supported in LIMIT/OFFSET");
96: 	}
97: 	// move any correlated columns to this binder
98: 	MoveCorrelatedExpressions(*new_binder);
99: 	if (is_percentage) {
100: 		return BoundLimitNode::ExpressionPercentage(std::move(expr));
101: 	} else {
102: 		return BoundLimitNode::ExpressionValue(std::move(expr));
103: 	}
104: }
105: 
106: duckdb::unique_ptr<BoundResultModifier> Binder::BindLimit(OrderBinder &order_binder, LimitModifier &limit_mod) {
107: 	auto result = make_uniq<BoundLimitModifier>();
108: 	if (limit_mod.limit) {
109: 		result->limit_val = BindLimitValue(order_binder, std::move(limit_mod.limit), false, false);
110: 	}
111: 	if (limit_mod.offset) {
112: 		result->offset_val = BindLimitValue(order_binder, std::move(limit_mod.offset), false, true);
113: 	}
114: 	return std::move(result);
115: }
116: 
117: unique_ptr<BoundResultModifier> Binder::BindLimitPercent(OrderBinder &order_binder, LimitPercentModifier &limit_mod) {
118: 	auto result = make_uniq<BoundLimitModifier>();
119: 	if (limit_mod.limit) {
120: 		result->limit_val = BindLimitValue(order_binder, std::move(limit_mod.limit), true, false);
121: 	}
122: 	if (limit_mod.offset) {
123: 		result->offset_val = BindLimitValue(order_binder, std::move(limit_mod.offset), false, true);
124: 	}
125: 	return std::move(result);
126: }
127: 
128: void Binder::PrepareModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result) {
129: 	for (auto &mod : statement.modifiers) {
130: 		unique_ptr<BoundResultModifier> bound_modifier;
131: 		switch (mod->type) {
132: 		case ResultModifierType::DISTINCT_MODIFIER: {
133: 			auto &distinct = mod->Cast<DistinctModifier>();
134: 			auto bound_distinct = make_uniq<BoundDistinctModifier>();
135: 			bound_distinct->distinct_type =
136: 			    distinct.distinct_on_targets.empty() ? DistinctType::DISTINCT : DistinctType::DISTINCT_ON;
137: 			if (distinct.distinct_on_targets.empty()) {
138: 				for (idx_t i = 0; i < result.names.size(); i++) {
139: 					distinct.distinct_on_targets.push_back(
140: 					    make_uniq<ConstantExpression>(Value::INTEGER(UnsafeNumericCast<int32_t>(1 + i))));
141: 				}
142: 			}
143: 			for (auto &distinct_on_target : distinct.distinct_on_targets) {
144: 				auto expr = BindOrderExpression(order_binder, std::move(distinct_on_target));
145: 				if (!expr) {
146: 					continue;
147: 				}
148: 				bound_distinct->target_distincts.push_back(std::move(expr));
149: 			}
150: 			bound_modifier = std::move(bound_distinct);
151: 			break;
152: 		}
153: 		case ResultModifierType::ORDER_MODIFIER: {
154: 			auto &order = mod->Cast<OrderModifier>();
155: 			auto bound_order = make_uniq<BoundOrderModifier>();
156: 			auto &config = DBConfig::GetConfig(context);
157: 			D_ASSERT(!order.orders.empty());
158: 			auto &order_binders = order_binder.GetBinders();
159: 			if (order.orders.size() == 1 && order.orders[0].expression->type == ExpressionType::STAR) {
160: 				auto &star = order.orders[0].expression->Cast<StarExpression>();
161: 				if (star.exclude_list.empty() && star.replace_list.empty() && !star.expr) {
162: 					// ORDER BY ALL
163: 					// replace the order list with the all elements in the SELECT list
164: 					auto order_type = config.ResolveOrder(order.orders[0].type);
165: 					auto null_order = config.ResolveNullOrder(order_type, order.orders[0].null_order);
166: 					auto constant_expr = make_uniq<BoundConstantExpression>(Value("ALL"));
167: 					bound_order->orders.emplace_back(order_type, null_order, std::move(constant_expr));
168: 					bound_modifier = std::move(bound_order);
169: 					break;
170: 				}
171: 			}
172: #if 0
173: 			// When this verification is enabled, replace ORDER BY x, y with ORDER BY create_sort_key(x, y)
174: 			// note that we don't enable this during actual verification since it doesn't always work
175: 			// e.g. it breaks EXPLAIN output on queries
176: 			bool can_replace = true;
177: 			for (auto &order_node : order.orders) {
178: 				if (order_node.expression->type == ExpressionType::VALUE_CONSTANT) {
179: 					// we cannot replace the sort key when we order by literals (e.g. ORDER BY 1, 2`
180: 					can_replace = false;
181: 					break;
182: 				}
183: 			}
184: 			if (!order_binder.HasExtraList()) {
185: 				// we can only do the replacement when we can order by elements that are not in the selection list
186: 				can_replace = false;
187: 			}
188: 			if (can_replace) {
189: 				vector<unique_ptr<ParsedExpression>> sort_key_parameters;
190: 				for (auto &order_node : order.orders) {
191: 					sort_key_parameters.push_back(std::move(order_node.expression));
192: 					auto type = config.ResolveOrder(order_node.type);
193: 					auto null_order = config.ResolveNullOrder(type, order_node.null_order);
194: 					string sort_param = EnumUtil::ToString(type) + " " + EnumUtil::ToString(null_order);
195: 					sort_key_parameters.push_back(make_uniq<ConstantExpression>(Value(sort_param)));
196: 				}
197: 				order.orders.clear();
198: 				auto create_sort_key = make_uniq<FunctionExpression>("create_sort_key", std::move(sort_key_parameters));
199: 				order.orders.emplace_back(OrderType::ASCENDING, OrderByNullType::NULLS_LAST, std::move(create_sort_key));
200: 			}
201: #endif
202: 			for (auto &order_node : order.orders) {
203: 				vector<unique_ptr<ParsedExpression>> order_list;
204: 				order_binders[0].get().ExpandStarExpression(std::move(order_node.expression), order_list);
205: 
206: 				auto type = config.ResolveOrder(order_node.type);
207: 				auto null_order = config.ResolveNullOrder(type, order_node.null_order);
208: 				for (auto &order_expr : order_list) {
209: 					auto bound_expr = BindOrderExpression(order_binder, std::move(order_expr));
210: 					if (!bound_expr) {
211: 						continue;
212: 					}
213: 					bound_order->orders.emplace_back(type, null_order, std::move(bound_expr));
214: 				}
215: 			}
216: 			if (!bound_order->orders.empty()) {
217: 				bound_modifier = std::move(bound_order);
218: 			}
219: 			break;
220: 		}
221: 		case ResultModifierType::LIMIT_MODIFIER:
222: 			bound_modifier = BindLimit(order_binder, mod->Cast<LimitModifier>());
223: 			break;
224: 		case ResultModifierType::LIMIT_PERCENT_MODIFIER:
225: 			bound_modifier = BindLimitPercent(order_binder, mod->Cast<LimitPercentModifier>());
226: 			break;
227: 		default:
228: 			throw InternalException("Unsupported result modifier");
229: 		}
230: 		if (bound_modifier) {
231: 			result.modifiers.push_back(std::move(bound_modifier));
232: 		}
233: 	}
234: }
235: 
236: unique_ptr<Expression> CreateOrderExpression(unique_ptr<Expression> expr, const vector<string> &names,
237:                                              const vector<LogicalType> &sql_types, idx_t table_index, idx_t index) {
238: 	if (index >= sql_types.size()) {
239: 		throw BinderException(*expr, "ORDER term out of range - should be between 1 and %lld", sql_types.size());
240: 	}
241: 	auto result = make_uniq<BoundColumnRefExpression>(std::move(expr->alias), sql_types[index],
242: 	                                                  ColumnBinding(table_index, index));
243: 	if (result->alias.empty() && index < names.size()) {
244: 		result->alias = names[index];
245: 	}
246: 	return std::move(result);
247: }
248: 
249: unique_ptr<Expression> FinalizeBindOrderExpression(unique_ptr<Expression> expr, idx_t table_index,
250:                                                    const vector<string> &names, const vector<LogicalType> &sql_types,
251:                                                    const SelectBindState &bind_state) {
252: 	auto &constant = expr->Cast<BoundConstantExpression>();
253: 	switch (constant.value.type().id()) {
254: 	case LogicalTypeId::UBIGINT: {
255: 		// index
256: 		auto index = UBigIntValue::Get(constant.value);
257: 		return CreateOrderExpression(std::move(expr), names, sql_types, table_index, bind_state.GetFinalIndex(index));
258: 	}
259: 	case LogicalTypeId::VARCHAR: {
260: 		// ORDER BY ALL
261: 		return nullptr;
262: 	}
263: 	case LogicalTypeId::STRUCT: {
264: 		// collation
265: 		auto &struct_values = StructValue::GetChildren(constant.value);
266: 		if (struct_values.size() > 2) {
267: 			throw InternalException("Expected one or two children: index and optional collation");
268: 		}
269: 		auto index = UBigIntValue::Get(struct_values[0]);
270: 		string collation;
271: 		if (struct_values.size() == 2) {
272: 			collation = StringValue::Get(struct_values[1]);
273: 		}
274: 		auto result = CreateOrderExpression(std::move(expr), names, sql_types, table_index, index);
275: 		if (!collation.empty()) {
276: 			if (sql_types[index].id() != LogicalTypeId::VARCHAR) {
277: 				throw BinderException(*result, "COLLATE can only be applied to varchar columns");
278: 			}
279: 			result->return_type = LogicalType::VARCHAR_COLLATION(std::move(collation));
280: 		}
281: 		return result;
282: 	}
283: 	default:
284: 		throw InternalException("Unknown type in FinalizeBindOrderExpression");
285: 	}
286: }
287: 
288: static void AssignReturnType(unique_ptr<Expression> &expr, idx_t table_index, const vector<string> &names,
289:                              const vector<LogicalType> &sql_types, const SelectBindState &bind_state) {
290: 	if (!expr) {
291: 		return;
292: 	}
293: 	if (expr->type == ExpressionType::VALUE_CONSTANT) {
294: 		expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
295: 	}
296: 	if (expr->type != ExpressionType::BOUND_COLUMN_REF) {
297: 		return;
298: 	}
299: 	auto &bound_colref = expr->Cast<BoundColumnRefExpression>();
300: 	bound_colref.return_type = sql_types[bound_colref.binding.column_index];
301: }
302: 
303: void Binder::BindModifiers(BoundQueryNode &result, idx_t table_index, const vector<string> &names,
304:                            const vector<LogicalType> &sql_types, const SelectBindState &bind_state) {
305: 	for (auto &bound_mod : result.modifiers) {
306: 		switch (bound_mod->type) {
307: 		case ResultModifierType::DISTINCT_MODIFIER: {
308: 			auto &distinct = bound_mod->Cast<BoundDistinctModifier>();
309: 			D_ASSERT(!distinct.target_distincts.empty());
310: 			// set types of distinct targets
311: 			for (auto &expr : distinct.target_distincts) {
312: 				expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
313: 				if (!expr) {
314: 					throw InternalException("DISTINCT ON ORDER BY ALL not supported");
315: 				}
316: 			}
317: 			for (auto &expr : distinct.target_distincts) {
318: 				ExpressionBinder::PushCollation(context, expr, expr->return_type);
319: 			}
320: 			break;
321: 		}
322: 		case ResultModifierType::LIMIT_MODIFIER: {
323: 			auto &limit = bound_mod->Cast<BoundLimitModifier>();
324: 			AssignReturnType(limit.limit_val.GetExpression(), table_index, names, sql_types, bind_state);
325: 			AssignReturnType(limit.offset_val.GetExpression(), table_index, names, sql_types, bind_state);
326: 			break;
327: 		}
328: 		case ResultModifierType::ORDER_MODIFIER: {
329: 			auto &order = bound_mod->Cast<BoundOrderModifier>();
330: 			bool order_by_all = false;
331: 			for (auto &order_node : order.orders) {
332: 				auto &expr = order_node.expression;
333: 				expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
334: 				if (!expr) {
335: 					order_by_all = true;
336: 				}
337: 			}
338: 			if (order_by_all) {
339: 				D_ASSERT(order.orders.size() == 1);
340: 				auto order_type = order.orders[0].type;
341: 				auto null_order = order.orders[0].null_order;
342: 				order.orders.clear();
343: 				for (idx_t i = 0; i < sql_types.size(); i++) {
344: 					auto expr = make_uniq<BoundColumnRefExpression>(sql_types[i], ColumnBinding(table_index, i));
345: 					if (i < names.size()) {
346: 						expr->alias = names[i];
347: 					}
348: 					order.orders.emplace_back(order_type, null_order, std::move(expr));
349: 				}
350: 			}
351: 			for (auto &order_node : order.orders) {
352: 				auto &expr = order_node.expression;
353: 				ExpressionBinder::PushCollation(context, order_node.expression, expr->return_type);
354: 			}
355: 			break;
356: 		}
357: 		default:
358: 			break;
359: 		}
360: 	}
361: }
362: 
363: unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
364: 	D_ASSERT(statement.from_table);
365: 
366: 	// first bind the FROM table statement
367: 	auto from = std::move(statement.from_table);
368: 	auto from_table = Bind(*from);
369: 	return BindSelectNode(statement, std::move(from_table));
370: }
371: 
372: void Binder::BindWhereStarExpression(unique_ptr<ParsedExpression> &expr) {
373: 	// expand any expressions in the upper AND recursively
374: 	if (expr->type == ExpressionType::CONJUNCTION_AND) {
375: 		auto &conj = expr->Cast<ConjunctionExpression>();
376: 		for (auto &child : conj.children) {
377: 			BindWhereStarExpression(child);
378: 		}
379: 		return;
380: 	}
381: 	if (expr->type == ExpressionType::STAR) {
382: 		auto &star = expr->Cast<StarExpression>();
383: 		if (!star.columns) {
384: 			throw ParserException("STAR expression is not allowed in the WHERE clause. Use COLUMNS(*) instead.");
385: 		}
386: 	}
387: 	// expand the stars for this expression
388: 	vector<unique_ptr<ParsedExpression>> new_conditions;
389: 	ExpandStarExpression(std::move(expr), new_conditions);
390: 	if (new_conditions.empty()) {
391: 		throw ParserException("COLUMNS expansion resulted in empty set of columns");
392: 	}
393: 
394: 	// set up an AND conjunction between the expanded conditions
395: 	expr = std::move(new_conditions[0]);
396: 	for (idx_t i = 1; i < new_conditions.size(); i++) {
397: 		auto and_conj = make_uniq<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, std::move(expr),
398: 		                                                 std::move(new_conditions[i]));
399: 		expr = std::move(and_conj);
400: 	}
401: }
402: 
403: unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_ptr<BoundTableRef> from_table) {
404: 	D_ASSERT(from_table);
405: 	D_ASSERT(!statement.from_table);
406: 	auto result = make_uniq<BoundSelectNode>();
407: 	result->projection_index = GenerateTableIndex();
408: 	result->group_index = GenerateTableIndex();
409: 	result->aggregate_index = GenerateTableIndex();
410: 	result->groupings_index = GenerateTableIndex();
411: 	result->window_index = GenerateTableIndex();
412: 	result->prune_index = GenerateTableIndex();
413: 
414: 	result->from_table = std::move(from_table);
415: 	// bind the sample clause
416: 	if (statement.sample) {
417: 		result->sample_options = std::move(statement.sample);
418: 	}
419: 
420: 	// visit the select list and expand any "*" statements
421: 	vector<unique_ptr<ParsedExpression>> new_select_list;
422: 	ExpandStarExpressions(statement.select_list, new_select_list);
423: 
424: 	if (new_select_list.empty()) {
425: 		throw BinderException("SELECT list is empty after resolving * expressions!");
426: 	}
427: 	statement.select_list = std::move(new_select_list);
428: 
429: 	auto &bind_state = result->bind_state;
430: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
431: 		auto &expr = statement.select_list[i];
432: 		result->names.push_back(expr->GetName());
433: 		ExpressionBinder::QualifyColumnNames(*this, expr);
434: 		if (!expr->alias.empty()) {
435: 			bind_state.alias_map[expr->alias] = i;
436: 			result->names[i] = expr->alias;
437: 		}
438: 		bind_state.projection_map[*expr] = i;
439: 		bind_state.original_expressions.push_back(expr->Copy());
440: 	}
441: 	result->column_count = statement.select_list.size();
442: 
443: 	// first visit the WHERE clause
444: 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
445: 	if (statement.where_clause) {
446: 		// bind any star expressions in the WHERE clause
447: 		BindWhereStarExpression(statement.where_clause);
448: 
449: 		ColumnAliasBinder alias_binder(bind_state);
450: 		WhereBinder where_binder(*this, context, &alias_binder);
451: 		unique_ptr<ParsedExpression> condition = std::move(statement.where_clause);
452: 		result->where_clause = where_binder.Bind(condition);
453: 	}
454: 
455: 	// now bind all the result modifiers; including DISTINCT and ORDER BY targets
456: 	OrderBinder order_binder({*this}, statement, bind_state);
457: 	PrepareModifiers(order_binder, statement, *result);
458: 
459: 	vector<unique_ptr<ParsedExpression>> unbound_groups;
460: 	BoundGroupInformation info;
461: 	auto &group_expressions = statement.groups.group_expressions;
462: 	if (!group_expressions.empty()) {
463: 		// the statement has a GROUP BY clause, bind it
464: 		unbound_groups.resize(group_expressions.size());
465: 		GroupBinder group_binder(*this, context, statement, result->group_index, bind_state, info.alias_map);
466: 		for (idx_t i = 0; i < group_expressions.size(); i++) {
467: 
468: 			// we keep a copy of the unbound expression;
469: 			// we keep the unbound copy around to check for group references in the SELECT and HAVING clause
470: 			// the reason we want the unbound copy is because we want to figure out whether an expression
471: 			// is a group reference BEFORE binding in the SELECT/HAVING binder
472: 			group_binder.unbound_expression = group_expressions[i]->Copy();
473: 			group_binder.bind_index = i;
474: 
475: 			// bind the groups
476: 			LogicalType group_type;
477: 			auto bound_expr = group_binder.Bind(group_expressions[i], &group_type);
478: 			D_ASSERT(bound_expr->return_type.id() != LogicalTypeId::INVALID);
479: 
480: 			// find out whether the expression contains a subquery, it can't be copied if so
481: 			auto &bound_expr_ref = *bound_expr;
482: 			bool contains_subquery = bound_expr_ref.HasSubquery();
483: 
484: 			// push a potential collation, if necessary
485: 			bool requires_collation = ExpressionBinder::PushCollation(context, bound_expr, group_type);
486: 			if (!contains_subquery && requires_collation) {
487: 				// if there is a collation on a group x, we should group by the collated expr,
488: 				// but also push a first(x) aggregate in case x is selected (uncollated)
489: 				info.collated_groups[i] = result->aggregates.size();
490: 
491: 				auto first_fun = FirstFun::GetFunction(bound_expr_ref.return_type);
492: 				vector<unique_ptr<Expression>> first_children;
493: 				// FIXME: would be better to just refer to this expression, but for now we copy
494: 				first_children.push_back(bound_expr_ref.Copy());
495: 
496: 				FunctionBinder function_binder(context);
497: 				auto function = function_binder.BindAggregateFunction(first_fun, std::move(first_children));
498: 				function->alias = "__collated_group";
499: 				result->aggregates.push_back(std::move(function));
500: 			}
501: 			result->groups.group_expressions.push_back(std::move(bound_expr));
502: 
503: 			// in the unbound expression we DO bind the table names of any ColumnRefs
504: 			// we do this to make sure that "table.a" and "a" are treated the same
505: 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
506: 			// hence we convert "a" -> "test.a" in the unbound expression
507: 			unbound_groups[i] = std::move(group_binder.unbound_expression);
508: 			ExpressionBinder::QualifyColumnNames(*this, unbound_groups[i]);
509: 			info.map[*unbound_groups[i]] = i;
510: 		}
511: 	}
512: 	result->groups.grouping_sets = std::move(statement.groups.grouping_sets);
513: 
514: 	// bind the HAVING clause, if any
515: 	if (statement.having) {
516: 		HavingBinder having_binder(*this, context, *result, info, statement.aggregate_handling);
517: 		ExpressionBinder::QualifyColumnNames(*this, statement.having);
518: 		result->having = having_binder.Bind(statement.having);
519: 	}
520: 
521: 	// bind the QUALIFY clause, if any
522: 	vector<BoundColumnReferenceInfo> bound_qualify_columns;
523: 	if (statement.qualify) {
524: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
525: 			throw BinderException("Combining QUALIFY with GROUP BY ALL is not supported yet");
526: 		}
527: 		QualifyBinder qualify_binder(*this, context, *result, info);
528: 		ExpressionBinder::QualifyColumnNames(*this, statement.qualify);
529: 		result->qualify = qualify_binder.Bind(statement.qualify);
530: 		if (qualify_binder.HasBoundColumns()) {
531: 			if (qualify_binder.BoundAggregates()) {
532: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
533: 			}
534: 			bound_qualify_columns = qualify_binder.GetBoundColumns();
535: 		}
536: 	}
537: 
538: 	// after that, we bind to the SELECT list
539: 	SelectBinder select_binder(*this, context, *result, info);
540: 
541: 	// if we expand select-list expressions, e.g., via UNNEST, then we need to possibly
542: 	// adjust the column index of the already bound ORDER BY modifiers, and not only set their types
543: 	vector<idx_t> group_by_all_indexes;
544: 	vector<string> new_names;
545: 	vector<LogicalType> internal_sql_types;
546: 
547: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
548: 		bool is_window = statement.select_list[i]->IsWindow();
549: 		idx_t unnest_count = result->unnests.size();
550: 		LogicalType result_type;
551: 		auto expr = select_binder.Bind(statement.select_list[i], &result_type, true);
552: 		bool is_original_column = i < result->column_count;
553: 		bool can_group_by_all =
554: 		    statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES && is_original_column;
555: 		result->bound_column_count++;
556: 
557: 		if (expr->type == ExpressionType::BOUND_EXPANDED) {
558: 			if (!is_original_column) {
559: 				throw BinderException("UNNEST of struct cannot be used in ORDER BY/DISTINCT ON clause");
560: 			}
561: 			if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
562: 				throw BinderException("UNNEST of struct cannot be combined with GROUP BY ALL");
563: 			}
564: 
565: 			auto &expanded = expr->Cast<BoundExpandedExpression>();
566: 			auto &struct_expressions = expanded.expanded_expressions;
567: 			D_ASSERT(!struct_expressions.empty());
568: 
569: 			for (auto &struct_expr : struct_expressions) {
570: 				new_names.push_back(struct_expr->GetName());
571: 				result->types.push_back(struct_expr->return_type);
572: 				internal_sql_types.push_back(struct_expr->return_type);
573: 				result->select_list.push_back(std::move(struct_expr));
574: 			}
575: 			bind_state.AddExpandedColumn(struct_expressions.size());
576: 			continue;
577: 		}
578: 
579: 		if (expr->IsVolatile()) {
580: 			bind_state.SetExpressionIsVolatile(i);
581: 		}
582: 		if (expr->HasSubquery()) {
583: 			bind_state.SetExpressionHasSubquery(i);
584: 		}
585: 		bind_state.AddRegularColumn();
586: 
587: 		if (can_group_by_all && select_binder.HasBoundColumns()) {
588: 			if (select_binder.BoundAggregates()) {
589: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
590: 			}
591: 			if (is_window) {
592: 				throw BinderException("Cannot group on a window clause");
593: 			}
594: 			if (result->unnests.size() > unnest_count) {
595: 				throw BinderException("Cannot group on an UNNEST or UNLIST clause");
596: 			}
597: 			// we are forcing aggregates, and the node has columns bound
598: 			// this entry becomes a group
599: 			group_by_all_indexes.push_back(i);
600: 		}
601: 
602: 		result->select_list.push_back(std::move(expr));
603: 		if (is_original_column) {
604: 			new_names.push_back(std::move(result->names[i]));
605: 			result->types.push_back(result_type);
606: 		}
607: 		internal_sql_types.push_back(result_type);
608: 
609: 		if (can_group_by_all) {
610: 			select_binder.ResetBindings();
611: 		}
612: 	}
613: 
614: 	// push the GROUP BY ALL expressions into the group set
615: 	for (auto &group_by_all_index : group_by_all_indexes) {
616: 		auto &expr = result->select_list[group_by_all_index];
617: 		auto group_ref = make_uniq<BoundColumnRefExpression>(
618: 		    expr->return_type, ColumnBinding(result->group_index, result->groups.group_expressions.size()));
619: 		result->groups.group_expressions.push_back(std::move(expr));
620: 		expr = std::move(group_ref);
621: 	}
622: 	result->column_count = new_names.size();
623: 	result->names = std::move(new_names);
624: 	result->need_prune = result->select_list.size() > result->column_count;
625: 
626: 	// in the normal select binder, we bind columns as if there is no aggregation
627: 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
628: 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
629: 	// we choose the former one [CONTROVERSIAL: this is the PostgreSQL behavior]
630: 	if (!result->groups.group_expressions.empty() || !result->aggregates.empty() || statement.having ||
631: 	    !result->groups.grouping_sets.empty()) {
632: 		if (statement.aggregate_handling == AggregateHandling::NO_AGGREGATES_ALLOWED) {
633: 			throw BinderException("Aggregates cannot be present in a Project relation!");
634: 		} else {
635: 			vector<BoundColumnReferenceInfo> bound_columns;
636: 			if (select_binder.HasBoundColumns()) {
637: 				bound_columns = select_binder.GetBoundColumns();
638: 			}
639: 			for (auto &bound_qualify_col : bound_qualify_columns) {
640: 				bound_columns.push_back(bound_qualify_col);
641: 			}
642: 			if (!bound_columns.empty()) {
643: 				string error;
644: 				error = "column \"%s\" must appear in the GROUP BY clause or must be part of an aggregate function.";
645: 				if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
646: 					error += "\nGROUP BY ALL will only group entries in the SELECT list. Add it to the SELECT list or "
647: 					         "GROUP BY this entry explicitly.";
648: 					throw BinderException(bound_columns[0].query_location, error, bound_columns[0].name);
649: 				} else {
650: 					error +=
651: 					    "\nEither add it to the GROUP BY list, or use \"ANY_VALUE(%s)\" if the exact value of \"%s\" "
652: 					    "is not important.";
653: 					throw BinderException(bound_columns[0].query_location, error, bound_columns[0].name,
654: 					                      bound_columns[0].name, bound_columns[0].name);
655: 				}
656: 			}
657: 		}
658: 	}
659: 
660: 	// QUALIFY clause requires at least one window function to be specified in at least one of the SELECT column list or
661: 	// the filter predicate of the QUALIFY clause
662: 	if (statement.qualify && result->windows.empty()) {
663: 		throw BinderException("at least one window function must appear in the SELECT column or QUALIFY clause");
664: 	}
665: 
666: 	// now that the SELECT list is bound, we set the types of DISTINCT/ORDER BY expressions
667: 	BindModifiers(*result, result->projection_index, result->names, internal_sql_types, bind_state);
668: 	return std::move(result);
669: }
670: 
671: } // namespace duckdb
[end of src/planner/binder/query_node/bind_select_node.cpp]
[start of src/planner/expression_binder/having_binder.cpp]
1: #include "duckdb/planner/expression_binder/having_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/expression/window_expression.hpp"
5: #include "duckdb/planner/binder.hpp"
6: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
7: #include "duckdb/common/string_util.hpp"
8: #include "duckdb/planner/query_node/bound_select_node.hpp"
9: 
10: namespace duckdb {
11: 
12: HavingBinder::HavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,
13:                            AggregateHandling aggregate_handling)
14:     : BaseSelectBinder(binder, context, node, info), column_alias_binder(node.bind_state),
15:       aggregate_handling(aggregate_handling) {
16: 	target_type = LogicalType(LogicalTypeId::BOOLEAN);
17: }
18: 
19: BindResult HavingBinder::BindLambdaReference(LambdaRefExpression &expr, idx_t depth) {
20: 	D_ASSERT(lambda_bindings && expr.lambda_idx < lambda_bindings->size());
21: 	auto &lambda_ref = expr.Cast<LambdaRefExpression>();
22: 	return (*lambda_bindings)[expr.lambda_idx].Bind(lambda_ref, depth);
23: }
24: 
25: BindResult HavingBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
26: 
27: 	// Keep the original column name to return a meaningful error message.
28: 	auto col_ref = expr_ptr->Cast<ColumnRefExpression>();
29: 	const auto &column_name = col_ref.GetColumnName();
30: 
31: 	// Try binding as a lambda parameter
32: 	if (!col_ref.IsQualified()) {
33: 		auto lambda_ref = LambdaRefExpression::FindMatchingBinding(lambda_bindings, col_ref.GetName());
34: 		if (lambda_ref) {
35: 			return BindLambdaReference(lambda_ref->Cast<LambdaRefExpression>(), depth);
36: 		}
37: 		// column was not found - check if it is a SQL value function
38: 		auto value_function = GetSQLValueFunction(col_ref.GetColumnName());
39: 		if (value_function) {
40: 			return BindExpression(value_function, depth);
41: 		}
42: 	}
43: 
44: 	// Bind the alias.
45: 	BindResult alias_result;
46: 	auto found_alias = column_alias_binder.BindAlias(*this, expr_ptr, depth, root_expression, alias_result);
47: 	if (found_alias) {
48: 		if (depth > 0) {
49: 			throw BinderException("Having clause cannot reference alias \"%s\" in correlated subquery", column_name);
50: 		}
51: 		return alias_result;
52: 	}
53: 
54: 	if (aggregate_handling != AggregateHandling::FORCE_AGGREGATES) {
55: 		return BindResult(StringUtil::Format(
56: 		    "column %s must appear in the GROUP BY clause or be used in an aggregate function", column_name));
57: 	}
58: 
59: 	if (depth > 0) {
60: 		throw BinderException("Having clause cannot reference column \"%s\" in correlated subquery and group by all",
61: 		                      column_name);
62: 	}
63: 
64: 	auto expr = duckdb::BaseSelectBinder::BindColumnRef(expr_ptr, depth, root_expression);
65: 	if (expr.HasError()) {
66: 		return expr;
67: 	}
68: 
69: 	// Return a GROUP BY column reference expression.
70: 	auto return_type = expr.expression->return_type;
71: 	auto column_binding = ColumnBinding(node.group_index, node.groups.group_expressions.size());
72: 	auto group_ref = make_uniq<BoundColumnRefExpression>(return_type, column_binding);
73: 	node.groups.group_expressions.push_back(std::move(expr.expression));
74: 	return BindResult(std::move(group_ref));
75: }
76: 
77: BindResult HavingBinder::BindWindow(WindowExpression &expr, idx_t depth) {
78: 	return BindResult(BinderException::Unsupported(expr, "HAVING clause cannot contain window functions!"));
79: }
80: 
81: } // namespace duckdb
[end of src/planner/expression_binder/having_binder.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: