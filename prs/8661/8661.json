{
  "repo": "duckdb/duckdb",
  "pull_number": 8661,
  "instance_id": "duckdb__duckdb-8661",
  "issue_numbers": [
    "8659"
  ],
  "base_commit": "4c2de0a942a80879ace9a9bbc2b81f8acf1960b8",
  "patch": "diff --git a/src/planner/expression/bound_cast_expression.cpp b/src/planner/expression/bound_cast_expression.cpp\nindex 33e51f71bb38..3bd6d4712831 100644\n--- a/src/planner/expression/bound_cast_expression.cpp\n+++ b/src/planner/expression/bound_cast_expression.cpp\n@@ -142,12 +142,10 @@ bool BoundCastExpression::CastIsInvertible(const LogicalType &source_type, const\n \t}\n \tif (source_type.id() == LogicalTypeId::VARCHAR) {\n \t\tswitch (target_type.id()) {\n-\t\tcase LogicalTypeId::TIME:\n \t\tcase LogicalTypeId::TIMESTAMP:\n \t\tcase LogicalTypeId::TIMESTAMP_NS:\n \t\tcase LogicalTypeId::TIMESTAMP_MS:\n \t\tcase LogicalTypeId::TIMESTAMP_SEC:\n-\t\tcase LogicalTypeId::TIME_TZ:\n \t\tcase LogicalTypeId::TIMESTAMP_TZ:\n \t\t\treturn true;\n \t\tdefault:\n",
  "test_patch": "diff --git a/test/sql/optimizer/expression/test_comparison_simplification.test b/test/sql/optimizer/expression/test_comparison_simplification.test\nnew file mode 100644\nindex 000000000000..281437052dc1\n--- /dev/null\n+++ b/test/sql/optimizer/expression/test_comparison_simplification.test\n@@ -0,0 +1,17 @@\n+# name: test/sql/optimizer/expression/test_comparison_simplification.test\n+# description: Test ComparisonSimplificationRule\n+# group: [expression]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# VARCHAR => TIME is not invertible.\n+query I\n+WITH results AS (     \n+\tSELECT '2023-08-17T23:00:08.539Z' as timestamp \n+\t) \n+SELECT * \n+FROM results \n+WHERE timestamp::TIME BETWEEN '22:00:00'::TIME AND '23:59:59'::TIME ;\n+----\n+2023-08-17T23:00:08.539Z\n",
  "problem_statement": "Issue comparing timestamp str with time when optimizer enabled\n### What happens?\r\n\r\nIf you cast a timestamp str like `2023-08-17T23:00:08.539Z` to time and try to compare it with a regular time the comparison doesn't work as expected.\r\n\r\nThis can be fixed by:\r\n- Converting the str to a timestamp first\r\n- Or disabling the optimizer\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nWITH results AS (\r\n    SELECT '2023-08-17T23:00:08.539Z' as timestamp\r\n)\r\nSELECT * FROM results WHERE timestamp::TIME BETWEEN '22:00:00'::TIME AND '23:59:59'::TIME\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 timestamp \u2502\r\n\u2502  varchar  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502  0 rows   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\npragma disable_optimizer;\r\n\r\nWITH results AS (\r\n    SELECT '2023-08-17T23:00:08.539Z' as timestamp\r\n)\r\nSELECT * FROM results WHERE timestamp::TIME BETWEEN '22:00:00'::TIME AND '23:59:59'::TIME\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502        timestamp         \u2502\r\n\u2502         varchar          \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 2023-08-17T23:00:08.539Z \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu 20\r\n\r\n### DuckDB Version:\r\n\r\n0.8.1\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nTom Burch\r\n\r\n### Affiliation:\r\n\r\nOcado Technology\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "The optimiser somehow appears to be evaluating the expression incorrectly. When I ask for the query plan, it just says empty result.\n`ComparisonSimplificationRule::Apply` assumes that if all the inputs are casts from the same type that the comparison rules work for the base type. Which is clearly not true here.\nNot sure if this is helpful but the query does seem to work if you replace `BETWEEN '22:00:00'` with `'19:00:00'` or earlier\nThe optimiser is comparing the strings. And since the year of the string being cast is `2023`, any time string that collates before 202 will work.\n`BoundCastExpression::CastIsInvertible` thinks that string casts to time are invertible. But since we allow casting from full timestamp strings, that is not true.",
  "created_at": "2023-08-23T04:23:18Z"
}