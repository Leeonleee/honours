You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
crash when having constant in struct_pack
The following causes duckdb to crash
```
v0.2.6-dev307 b1d730018
Enter ".help" for usage hints.
D SELECT STRUCT_PACK(i :=range, j :=3) FROM range(2);
┌───────────────────────┐
│ struct_pack(range, 3) │
├───────────────────────┤
│ <i: 0, j: 3>          │
│ <i: 1, j: 1073741824> │
└───────────────────────┘
D SELECT STRUCT_PACK(i :=range, j :='x') FROM range(2);
zsh: segmentation fault  
```

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of src/common/vector_operations/vector_copy.cpp]
1: //===--------------------------------------------------------------------===//
2: // copy.cpp
3: // Description: This file contains the implementation of the different copy
4: // functions
5: //===--------------------------------------------------------------------===//
6: 
7: #include "duckdb/common/exception.hpp"
8: #include "duckdb/common/types/null_value.hpp"
9: #include "duckdb/common/types/chunk_collection.hpp"
10: 
11: #include "duckdb/common/vector_operations/vector_operations.hpp"
12: 
13: namespace duckdb {
14: 
15: template <class T>
16: static void TemplatedCopy(const Vector &source, const SelectionVector &sel, Vector &target, idx_t source_offset,
17:                           idx_t target_offset, idx_t copy_count) {
18: 	auto ldata = FlatVector::GetData<T>(source);
19: 	auto tdata = FlatVector::GetData<T>(target);
20: 	for (idx_t i = 0; i < copy_count; i++) {
21: 		auto source_idx = sel.get_index(source_offset + i);
22: 		tdata[target_offset + i] = ldata[source_idx];
23: 	}
24: }
25: 
26: void VectorOperations::Copy(const Vector &source, Vector &target, const SelectionVector &sel, idx_t source_count,
27:                             idx_t source_offset, idx_t target_offset) {
28: 	D_ASSERT(source_offset <= source_count);
29: 	D_ASSERT(target.GetVectorType() == VectorType::FLAT_VECTOR);
30: 	D_ASSERT(source.GetType() == target.GetType());
31: 	switch (source.GetVectorType()) {
32: 	case VectorType::DICTIONARY_VECTOR: {
33: 		// dictionary vector: merge selection vectors
34: 		auto &child = DictionaryVector::Child(source);
35: 		auto &dict_sel = DictionaryVector::SelVector(source);
36: 		// merge the selection vectors and verify the child
37: 		auto new_buffer = dict_sel.Slice(sel, source_count);
38: 		SelectionVector merged_sel(new_buffer);
39: 		VectorOperations::Copy(child, target, merged_sel, source_count, source_offset, target_offset);
40: 		return;
41: 	}
42: 	case VectorType::SEQUENCE_VECTOR: {
43: 		int64_t start, increment;
44: 		Vector seq(source.GetType());
45: 		SequenceVector::GetSequence(source, start, increment);
46: 		VectorOperations::GenerateSequence(seq, source_count, sel, start, increment);
47: 		VectorOperations::Copy(seq, target, sel, source_count, source_offset, target_offset);
48: 		return;
49: 	}
50: 	case VectorType::CONSTANT_VECTOR:
51: 	case VectorType::FLAT_VECTOR:
52: 		break;
53: 	default:
54: 		throw NotImplementedException("FIXME unimplemented vector type for VectorOperations::Copy");
55: 	}
56: 
57: 	idx_t copy_count = source_count - source_offset;
58: 	if (copy_count == 0) {
59: 		return;
60: 	}
61: 
62: 	// first copy the nullmask
63: 	auto &tmask = FlatVector::Validity(target);
64: 	if (source.GetVectorType() == VectorType::CONSTANT_VECTOR) {
65: 		if (ConstantVector::IsNull(source)) {
66: 			for (idx_t i = 0; i < copy_count; i++) {
67: 				tmask.SetInvalid(target_offset + i);
68: 			}
69: 		}
70: 	} else {
71: 		auto &smask = FlatVector::Validity(source);
72: 		if (smask.IsMaskSet()) {
73: 			for (idx_t i = 0; i < copy_count; i++) {
74: 				auto idx = sel.get_index(source_offset + i);
75: 				tmask.Set(target_offset + i, smask.RowIsValid(idx));
76: 			}
77: 		}
78: 	}
79: 
80: 	// now copy over the data
81: 	switch (source.GetType().InternalType()) {
82: 	case PhysicalType::BOOL:
83: 	case PhysicalType::INT8:
84: 		TemplatedCopy<int8_t>(source, sel, target, source_offset, target_offset, copy_count);
85: 		break;
86: 	case PhysicalType::INT16:
87: 		TemplatedCopy<int16_t>(source, sel, target, source_offset, target_offset, copy_count);
88: 		break;
89: 	case PhysicalType::INT32:
90: 		TemplatedCopy<int32_t>(source, sel, target, source_offset, target_offset, copy_count);
91: 		break;
92: 	case PhysicalType::HASH:
93: 	case PhysicalType::INT64:
94: 		TemplatedCopy<int64_t>(source, sel, target, source_offset, target_offset, copy_count);
95: 		break;
96: 	case PhysicalType::UINT8:
97: 		TemplatedCopy<uint8_t>(source, sel, target, source_offset, target_offset, copy_count);
98: 		break;
99: 	case PhysicalType::UINT16:
100: 		TemplatedCopy<uint16_t>(source, sel, target, source_offset, target_offset, copy_count);
101: 		break;
102: 	case PhysicalType::UINT32:
103: 		TemplatedCopy<uint32_t>(source, sel, target, source_offset, target_offset, copy_count);
104: 		break;
105: 	case PhysicalType::UINT64:
106: 		TemplatedCopy<uint64_t>(source, sel, target, source_offset, target_offset, copy_count);
107: 		break;
108: 	case PhysicalType::INT128:
109: 		TemplatedCopy<hugeint_t>(source, sel, target, source_offset, target_offset, copy_count);
110: 		break;
111: 	case PhysicalType::POINTER:
112: 		TemplatedCopy<uintptr_t>(source, sel, target, source_offset, target_offset, copy_count);
113: 		break;
114: 	case PhysicalType::FLOAT:
115: 		TemplatedCopy<float>(source, sel, target, source_offset, target_offset, copy_count);
116: 		break;
117: 	case PhysicalType::DOUBLE:
118: 		TemplatedCopy<double>(source, sel, target, source_offset, target_offset, copy_count);
119: 		break;
120: 	case PhysicalType::INTERVAL:
121: 		TemplatedCopy<interval_t>(source, sel, target, source_offset, target_offset, copy_count);
122: 		break;
123: 	case PhysicalType::VARCHAR: {
124: 		auto ldata = FlatVector::GetData<string_t>(source);
125: 		auto tdata = FlatVector::GetData<string_t>(target);
126: 		for (idx_t i = 0; i < copy_count; i++) {
127: 			auto source_idx = sel.get_index(source_offset + i);
128: 			auto target_idx = target_offset + i;
129: 			if (tmask.RowIsValid(target_idx)) {
130: 				tdata[target_idx] = StringVector::AddStringOrBlob(target, ldata[source_idx]);
131: 			}
132: 		}
133: 		break;
134: 	}
135: 	case PhysicalType::STRUCT: {
136: 		if (StructVector::HasEntries(target)) {
137: 			// target already has entries: append to them
138: 			auto &source_children = StructVector::GetEntries(source);
139: 			auto &target_children = StructVector::GetEntries(target);
140: 			D_ASSERT(source_children.size() == target_children.size());
141: 			for (idx_t i = 0; i < source_children.size(); i++) {
142: 				D_ASSERT(target_children[i].first == target_children[i].first);
143: 				VectorOperations::Copy(*source_children[i].second, *target_children[i].second, sel, source_count,
144: 				                       source_offset, target_offset);
145: 			}
146: 		} else {
147: 			D_ASSERT(target_offset == 0);
148: 			// target has no entries: create new entries for the target
149: 			auto &source_children = StructVector::GetEntries(source);
150: 			for (auto &child : source_children) {
151: 				auto child_copy = make_unique<Vector>(child.second->GetType());
152: 
153: 				VectorOperations::Copy(*child.second, *child_copy, sel, source_count, source_offset, target_offset);
154: 				StructVector::AddEntry(target, child.first, move(child_copy));
155: 			}
156: 		}
157: 		break;
158: 	}
159: 	case PhysicalType::LIST: {
160: 		D_ASSERT(target.GetType().InternalType() == PhysicalType::LIST);
161: 		if (ListVector::HasEntry(source)) {
162: 			//! if the source has list offsets, we need to append them to the target
163: 			if (!ListVector::HasEntry(target)) {
164: 				auto target_child = make_unique<Vector>(target.GetType().child_types()[0].second);
165: 				ListVector::SetEntry(target, move(target_child));
166: 			}
167: 
168: 			//! build a selection vector for the copied child elements
169: 			auto sdata = FlatVector::GetData<list_entry_t>(source);
170: 			vector<sel_t> child_rows;
171: 			for (idx_t i = 0; i < copy_count; ++i) {
172: 				if (tmask.RowIsValid(target_offset + i)) {
173: 					auto source_idx = sel.get_index(source_offset + i);
174: 					auto &source_entry = sdata[source_idx];
175: 					for (idx_t j = 0; j < source_entry.length; ++j) {
176: 						child_rows.emplace_back(source_entry.offset + j);
177: 					}
178: 				}
179: 			}
180: 			idx_t source_child_size = child_rows.size();
181: 			SelectionVector child_sel(child_rows.data());
182: 
183: 			auto &source_child = ListVector::GetEntry(source);
184: 
185: 			idx_t old_target_child_len = ListVector::GetListSize(target);
186: 
187: 			//! append to list itself
188: 			ListVector::Append(target, source_child, child_sel, source_child_size);
189: 
190: 			//! now write the list offsets
191: 			auto tdata = FlatVector::GetData<list_entry_t>(target);
192: 			for (idx_t i = 0; i < copy_count; i++) {
193: 				auto source_idx = sel.get_index(source_offset + i);
194: 				auto &source_entry = sdata[source_idx];
195: 				auto &target_entry = tdata[target_offset + i];
196: 
197: 				target_entry.length = source_entry.length;
198: 				target_entry.offset = old_target_child_len;
199: 				if (tmask.RowIsValid(target_offset + i)) {
200: 					old_target_child_len += target_entry.length;
201: 				}
202: 			}
203: 		}
204: 		break;
205: 	}
206: 	default:
207: 		throw NotImplementedException("Unimplemented type '%s' for copy!",
208: 		                              TypeIdToString(source.GetType().InternalType()));
209: 	}
210: }
211: 
212: void VectorOperations::Copy(const Vector &source, Vector &target, idx_t source_count, idx_t source_offset,
213:                             idx_t target_offset) {
214: 	switch (source.GetVectorType()) {
215: 	case VectorType::DICTIONARY_VECTOR: {
216: 		// dictionary: continue into child with selection vector
217: 		auto &child = DictionaryVector::Child(source);
218: 		auto &dict_sel = DictionaryVector::SelVector(source);
219: 		VectorOperations::Copy(child, target, dict_sel, source_count, source_offset, target_offset);
220: 		break;
221: 	}
222: 	case VectorType::CONSTANT_VECTOR:
223: 		VectorOperations::Copy(source, target, ConstantVector::ZERO_SELECTION_VECTOR, source_count, source_offset,
224: 		                       target_offset);
225: 		break;
226: 	case VectorType::FLAT_VECTOR:
227: 		if (target_offset + source_count - source_offset > STANDARD_VECTOR_SIZE) {
228: 			idx_t sel_vec_size = target_offset + source_count - source_offset;
229: 			SelectionVector selection_vector(sel_vec_size);
230: 			for (size_t i = 0; i < sel_vec_size; i++) {
231: 				selection_vector.set_index(i, i);
232: 			}
233: 			VectorOperations::Copy(source, target, selection_vector, source_count, source_offset, target_offset);
234: 		} else {
235: 			VectorOperations::Copy(source, target, FlatVector::INCREMENTAL_SELECTION_VECTOR, source_count,
236: 			                       source_offset, target_offset);
237: 		}
238: 		break;
239: 	case VectorType::SEQUENCE_VECTOR: {
240: 		int64_t start, increment;
241: 		SequenceVector::GetSequence(source, start, increment);
242: 		Vector flattened(source.GetType());
243: 		VectorOperations::GenerateSequence(flattened, source_count, start, increment);
244: 
245: 		VectorOperations::Copy(flattened, target, FlatVector::INCREMENTAL_SELECTION_VECTOR, source_count, source_offset,
246: 		                       target_offset);
247: 		break;
248: 	}
249: 	default:
250: 		throw NotImplementedException("FIXME: unimplemented vector type for VectorOperations::Copy");
251: 	}
252: }
253: 
254: } // namespace duckdb
[end of src/common/vector_operations/vector_copy.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: