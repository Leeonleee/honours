{
  "repo": "duckdb/duckdb",
  "pull_number": 3375,
  "instance_id": "duckdb__duckdb-3375",
  "issue_numbers": [
    "2125",
    "3364"
  ],
  "base_commit": "e4ba94a4f4540fe6d34fb2f6b7abf18e00ad3ca9",
  "patch": "diff --git a/extension/icu/icu-dateadd.cpp b/extension/icu/icu-dateadd.cpp\nindex 2fd4a1e62036..c91827b44944 100644\n--- a/extension/icu/icu-dateadd.cpp\n+++ b/extension/icu/icu-dateadd.cpp\n@@ -88,7 +88,7 @@ interval_t ICUCalendarSub::Operation(timestamp_t end_date, timestamp_t start_dat\n \n \t// Borrow 1ms from end_date if we wrap. This works because start_date <= end_date\n \t// and if the \u00b5s are out of order, then there must be an extra ms.\n-\tif (start_micros > (idx_t) end_micros) {\n+\tif (start_micros > (idx_t)end_micros) {\n \t\tend_date.value -= Interval::MICROS_PER_MSEC;\n \t\tend_micros += Interval::MICROS_PER_MSEC;\n \t}\n@@ -120,7 +120,7 @@ interval_t ICUCalendarAge::Operation(timestamp_t end_date, timestamp_t start_dat\n \n \t// Borrow 1ms from end_date if we wrap. This works because start_date <= end_date\n \t// and if the \u00b5s are out of order, then there must be an extra ms.\n-\tif (start_micros > (idx_t) end_micros) {\n+\tif (start_micros > (idx_t)end_micros) {\n \t\tend_date.value -= Interval::MICROS_PER_MSEC;\n \t\tend_micros += Interval::MICROS_PER_MSEC;\n \t}\n@@ -178,7 +178,7 @@ struct ICUDateAdd : public ICUDateFunc {\n \ttemplate <typename TA, typename TB, typename TR, typename OP>\n \tinline static ScalarFunction GetBinaryDateFunction(const LogicalTypeId &left_type, const LogicalTypeId &right_type,\n \t                                                   const LogicalTypeId &result_type) {\n-\t\treturn ScalarFunction({left_type, right_type}, result_type, ExecuteBinary<TA, TB, TR, OP>,false, false, Bind);\n+\t\treturn ScalarFunction({left_type, right_type}, result_type, ExecuteBinary<TA, TB, TR, OP>, false, false, Bind);\n \t}\n \n \ttemplate <typename TA, typename TB, typename OP>\ndiff --git a/extension/icu/icu-strptime.cpp b/extension/icu/icu-strptime.cpp\nindex da2e5c485606..6f7b41227fee 100644\n--- a/extension/icu/icu-strptime.cpp\n+++ b/extension/icu/icu-strptime.cpp\n@@ -132,7 +132,8 @@ struct ICUStrptime : public ICUDateFunc {\n \t\tauto &func = (ScalarFunctionCatalogEntry &)*entry;\n \t\tvector<LogicalType> types {LogicalType::VARCHAR, LogicalType::VARCHAR};\n \t\tstring error;\n-\t\tconst idx_t best_function = Function::BindFunction(func.name, func.functions, types, error);\n+\t\tbool cast_parameters;\n+\t\tconst idx_t best_function = Function::BindFunction(func.name, func.functions, types, error, cast_parameters);\n \t\tif (best_function == DConstants::INVALID_INDEX) {\n \t\t\treturn;\n \t\t}\ndiff --git a/src/common/symbols.cpp b/src/common/symbols.cpp\nindex 515cfcd7e548..f1466e1a4581 100644\n--- a/src/common/symbols.cpp\n+++ b/src/common/symbols.cpp\n@@ -150,6 +150,7 @@ INSTANTIATE_VECTOR(std::vector<OrderByNode>)\n template class std::vector<uint64_t>;\n template class std::vector<string>;\n INSTANTIATE_VECTOR(std::vector<Expression *>)\n+INSTANTIATE_VECTOR(std::vector<BoundParameterExpression *>)\n INSTANTIATE_VECTOR(std::vector<std::unique_ptr<Expression>>)\n INSTANTIATE_VECTOR(std::vector<std::unique_ptr<DataChunk>>)\n INSTANTIATE_VECTOR(std::vector<std::unique_ptr<SQLStatement>>)\ndiff --git a/src/execution/physical_plan/plan_execute.cpp b/src/execution/physical_plan/plan_execute.cpp\nindex 0b6f5b7520c9..bd96b89456d7 100644\n--- a/src/execution/physical_plan/plan_execute.cpp\n+++ b/src/execution/physical_plan/plan_execute.cpp\n@@ -5,8 +5,17 @@\n namespace duckdb {\n \n unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalExecute &op) {\n-\tD_ASSERT(op.children.size() == 0);\n-\treturn make_unique<PhysicalExecute>(op.prepared->plan.get());\n+\tif (!op.prepared->plan) {\n+\t\tD_ASSERT(op.children.size() == 1);\n+\t\tauto owned_plan = CreatePlan(*op.children[0]);\n+\t\tauto execute = make_unique<PhysicalExecute>(owned_plan.get());\n+\t\texecute->owned_plan = move(owned_plan);\n+\t\texecute->prepared = move(op.prepared);\n+\t\treturn move(execute);\n+\t} else {\n+\t\tD_ASSERT(op.children.size() == 0);\n+\t\treturn make_unique<PhysicalExecute>(op.prepared->plan.get());\n+\t}\n }\n \n } // namespace duckdb\ndiff --git a/src/function/cast_rules.cpp b/src/function/cast_rules.cpp\nindex 6addf93c608b..a656b40844c4 100644\n--- a/src/function/cast_rules.cpp\n+++ b/src/function/cast_rules.cpp\n@@ -194,10 +194,14 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\t// anything can be cast to ANY type for no cost\n \t\treturn 0;\n \t}\n-\tif (from.id() == LogicalTypeId::SQLNULL || from.id() == LogicalTypeId::UNKNOWN) {\n-\t\t// NULL expression or parameter expression can be cast to anything\n+\tif (from.id() == LogicalTypeId::SQLNULL) {\n+\t\t// NULL expression can be cast to anything\n \t\treturn TargetTypeCost(to);\n \t}\n+\tif (from.id() == LogicalTypeId::UNKNOWN) {\n+\t\t// parameter expression can be cast to anything for no cost\n+\t\treturn 0;\n+\t}\n \tif (from.id() == LogicalTypeId::BLOB && to.id() == LogicalTypeId::VARCHAR) {\n \t\t// Implicit cast not allowed from BLOB to VARCHAR\n \t\treturn -1;\ndiff --git a/src/function/function.cpp b/src/function/function.cpp\nindex 6f58518f1377..ecb8832203b7 100644\n--- a/src/function/function.cpp\n+++ b/src/function/function.cpp\n@@ -275,11 +275,11 @@ static int64_t BindFunctionCost(SimpleFunction &func, vector<LogicalType> &argum\n }\n \n template <class T>\n-static idx_t BindFunctionFromArguments(const string &name, vector<T> &functions, vector<LogicalType> &arguments,\n-                                       string &error) {\n+static vector<idx_t> BindFunctionsFromArguments(const string &name, vector<T> &functions,\n+                                                vector<LogicalType> &arguments, string &error) {\n \tidx_t best_function = DConstants::INVALID_INDEX;\n \tint64_t lowest_cost = NumericLimits<int64_t>::Maximum();\n-\tvector<idx_t> conflicting_functions;\n+\tvector<idx_t> candidate_functions;\n \tfor (idx_t f_idx = 0; f_idx < functions.size(); f_idx++) {\n \t\tauto &func = functions[f_idx];\n \t\t// check the arguments of the function\n@@ -289,32 +289,16 @@ static idx_t BindFunctionFromArguments(const string &name, vector<T> &functions,\n \t\t\tcontinue;\n \t\t}\n \t\tif (cost == lowest_cost) {\n-\t\t\tconflicting_functions.push_back(f_idx);\n+\t\t\tcandidate_functions.push_back(f_idx);\n \t\t\tcontinue;\n \t\t}\n \t\tif (cost > lowest_cost) {\n \t\t\tcontinue;\n \t\t}\n-\t\tconflicting_functions.clear();\n+\t\tcandidate_functions.clear();\n \t\tlowest_cost = cost;\n \t\tbest_function = f_idx;\n \t}\n-\tif (!conflicting_functions.empty()) {\n-\t\t// there are multiple possible function definitions\n-\t\t// throw an exception explaining which overloads are there\n-\t\tconflicting_functions.push_back(best_function);\n-\t\tstring call_str = Function::CallToString(name, arguments);\n-\t\tstring candidate_str = \"\";\n-\t\tfor (auto &conf : conflicting_functions) {\n-\t\t\tauto &f = functions[conf];\n-\t\t\tcandidate_str += \"\\t\" + f.ToString() + \"\\n\";\n-\t\t}\n-\t\terror =\n-\t\t    StringUtil::Format(\"Could not choose a best candidate function for the function call \\\"%s\\\". In order to \"\n-\t\t                       \"select one, please add explicit type casts.\\n\\tCandidate functions:\\n%s\",\n-\t\t                       call_str, candidate_str);\n-\t\treturn DConstants::INVALID_INDEX;\n-\t}\n \tif (best_function == DConstants::INVALID_INDEX) {\n \t\t// no matching function was found, throw an error\n \t\tstring call_str = Function::CallToString(name, arguments);\n@@ -325,24 +309,77 @@ static idx_t BindFunctionFromArguments(const string &name, vector<T> &functions,\n \t\terror = StringUtil::Format(\"No function matches the given name and argument types '%s'. You might need to add \"\n \t\t                           \"explicit type casts.\\n\\tCandidate functions:\\n%s\",\n \t\t                           call_str, candidate_str);\n+\t\treturn candidate_functions;\n+\t}\n+\tcandidate_functions.push_back(best_function);\n+\treturn candidate_functions;\n+}\n+\n+template <class T>\n+static idx_t MultipleCandidateException(const string &name, vector<T> &functions, vector<idx_t> &candidate_functions,\n+                                        vector<LogicalType> &arguments, string &error) {\n+\tD_ASSERT(functions.size() > 1);\n+\t// there are multiple possible function definitions\n+\t// throw an exception explaining which overloads are there\n+\tstring call_str = Function::CallToString(name, arguments);\n+\tstring candidate_str = \"\";\n+\tfor (auto &conf : candidate_functions) {\n+\t\tauto &f = functions[conf];\n+\t\tcandidate_str += \"\\t\" + f.ToString() + \"\\n\";\n+\t}\n+\terror = StringUtil::Format(\"Could not choose a best candidate function for the function call \\\"%s\\\". In order to \"\n+\t                           \"select one, please add explicit type casts.\\n\\tCandidate functions:\\n%s\",\n+\t                           call_str, candidate_str);\n+\treturn DConstants::INVALID_INDEX;\n+}\n+\n+template <class T>\n+static idx_t BindFunctionFromArguments(const string &name, vector<T> &functions, vector<LogicalType> &arguments,\n+                                       string &error, bool &cast_parameters) {\n+\tauto candidate_functions = BindFunctionsFromArguments<T>(name, functions, arguments, error);\n+\tif (candidate_functions.empty()) {\n+\t\t// no candidates\n \t\treturn DConstants::INVALID_INDEX;\n \t}\n-\treturn best_function;\n+\tcast_parameters = true;\n+\tif (candidate_functions.size() > 1) {\n+\t\t// multiple candidates, check if there are any unknown arguments\n+\t\tbool has_parameters = false;\n+\t\tfor (auto &arg_type : arguments) {\n+\t\t\tif (arg_type.id() == LogicalTypeId::UNKNOWN) {\n+\t\t\t\t//! there are! disable casting of parameters, but do not throw an error\n+\t\t\t\tcast_parameters = false;\n+\t\t\t\thas_parameters = true;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tif (!has_parameters) {\n+\t\t\treturn MultipleCandidateException(name, functions, candidate_functions, arguments, error);\n+\t\t}\n+\t}\n+\treturn candidate_functions[0];\n }\n \n idx_t Function::BindFunction(const string &name, vector<ScalarFunction> &functions, vector<LogicalType> &arguments,\n-                             string &error) {\n-\treturn BindFunctionFromArguments(name, functions, arguments, error);\n+                             string &error, bool &cast_parameters) {\n+\treturn BindFunctionFromArguments(name, functions, arguments, error, cast_parameters);\n+}\n+\n+idx_t Function::BindFunction(const string &name, vector<AggregateFunction> &functions, vector<LogicalType> &arguments,\n+                             string &error, bool &cast_parameters) {\n+\treturn BindFunctionFromArguments(name, functions, arguments, error, cast_parameters);\n }\n \n idx_t Function::BindFunction(const string &name, vector<AggregateFunction> &functions, vector<LogicalType> &arguments,\n                              string &error) {\n-\treturn BindFunctionFromArguments(name, functions, arguments, error);\n+\tbool cast_parameters;\n+\treturn BindFunction(name, functions, arguments, error, cast_parameters);\n }\n \n idx_t Function::BindFunction(const string &name, vector<TableFunction> &functions, vector<LogicalType> &arguments,\n                              string &error) {\n-\treturn BindFunctionFromArguments(name, functions, arguments, error);\n+\tbool cast_parameters;\n+\treturn BindFunctionFromArguments(name, functions, arguments, error, cast_parameters);\n }\n \n idx_t Function::BindFunction(const string &name, vector<PragmaFunction> &functions, PragmaInfo &info, string &error) {\n@@ -350,7 +387,8 @@ idx_t Function::BindFunction(const string &name, vector<PragmaFunction> &functio\n \tfor (auto &value : info.parameters) {\n \t\ttypes.push_back(value.type());\n \t}\n-\tidx_t entry = BindFunctionFromArguments(name, functions, types, error);\n+\tbool cast_parameters;\n+\tidx_t entry = BindFunctionFromArguments(name, functions, types, error, cast_parameters);\n \tif (entry == DConstants::INVALID_INDEX) {\n \t\tthrow BinderException(error);\n \t}\n@@ -374,9 +412,9 @@ vector<LogicalType> GetLogicalTypesFromExpressions(vector<unique_ptr<Expression>\n }\n \n idx_t Function::BindFunction(const string &name, vector<ScalarFunction> &functions,\n-                             vector<unique_ptr<Expression>> &arguments, string &error) {\n+                             vector<unique_ptr<Expression>> &arguments, string &error, bool &cast_parameters) {\n \tauto types = GetLogicalTypesFromExpressions(arguments);\n-\treturn Function::BindFunction(name, functions, types, error);\n+\treturn Function::BindFunction(name, functions, types, error, cast_parameters);\n }\n \n idx_t Function::BindFunction(const string &name, vector<AggregateFunction> &functions,\n@@ -406,23 +444,21 @@ LogicalTypeComparisonResult RequiresCast(const LogicalType &source_type, const L\n \treturn LogicalTypeComparisonResult::DIFFERENT_TYPES;\n }\n \n-void BaseScalarFunction::CastToFunctionArguments(vector<unique_ptr<Expression>> &children) {\n+void BaseScalarFunction::CastToFunctionArguments(vector<unique_ptr<Expression>> &children,\n+                                                 bool cast_parameter_expressions) {\n \tfor (idx_t i = 0; i < children.size(); i++) {\n \t\tauto target_type = i < this->arguments.size() ? this->arguments[i] : this->varargs;\n \t\ttarget_type.Verify();\n+\t\t// check if the source type is a paramter, and we have disabled casting of parameters\n+\t\tif (children[i]->return_type.id() == LogicalTypeId::UNKNOWN && !cast_parameter_expressions) {\n+\t\t\tcontinue;\n+\t\t}\n \t\t// check if the type of child matches the type of function argument\n \t\t// if not we need to add a cast\n \t\tauto cast_result = RequiresCast(children[i]->return_type, target_type);\n \t\t// except for one special case: if the function accepts ANY argument\n \t\t// in that case we don't add a cast\n-\t\tif (cast_result == LogicalTypeComparisonResult::TARGET_IS_ANY) {\n-\t\t\tif (children[i]->return_type.id() == LogicalTypeId::UNKNOWN) {\n-\t\t\t\t// UNLESS the child is a prepared statement parameter\n-\t\t\t\t// in that case we default the prepared statement parameter to VARCHAR\n-\t\t\t\tchildren[i]->return_type =\n-\t\t\t\t    ExpressionBinder::ExchangeType(target_type, LogicalTypeId::ANY, LogicalType::VARCHAR);\n-\t\t\t}\n-\t\t} else if (cast_result == LogicalTypeComparisonResult::DIFFERENT_TYPES) {\n+\t\tif (cast_result == LogicalTypeComparisonResult::DIFFERENT_TYPES) {\n \t\t\tchildren[i] = BoundCastExpression::AddCastToType(move(children[i]), target_type);\n \t\t}\n \t}\n@@ -444,25 +480,27 @@ unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientCon\n                                                                        vector<unique_ptr<Expression>> children,\n                                                                        string &error, bool is_operator) {\n \t// bind the function\n-\tidx_t best_function = Function::BindFunction(func.name, func.functions, children, error);\n+\tbool cast_parameters;\n+\tidx_t best_function = Function::BindFunction(func.name, func.functions, children, error, cast_parameters);\n \tif (best_function == DConstants::INVALID_INDEX) {\n \t\treturn nullptr;\n \t}\n+\n \t// found a matching function!\n \tauto &bound_function = func.functions[best_function];\n-\treturn ScalarFunction::BindScalarFunction(context, bound_function, move(children), is_operator);\n+\treturn ScalarFunction::BindScalarFunction(context, bound_function, move(children), is_operator, cast_parameters);\n }\n \n unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientContext &context,\n                                                                        ScalarFunction bound_function,\n                                                                        vector<unique_ptr<Expression>> children,\n-                                                                       bool is_operator) {\n+                                                                       bool is_operator, bool cast_parameters) {\n \tunique_ptr<FunctionData> bind_info;\n \tif (bound_function.bind) {\n \t\tbind_info = bound_function.bind(context, bound_function, children);\n \t}\n \t// check if we need to add casts to the children\n-\tbound_function.CastToFunctionArguments(children);\n+\tbound_function.CastToFunctionArguments(children, cast_parameters);\n \n \t// now create the function\n \tauto return_type = bound_function.return_type;\n@@ -470,10 +508,9 @@ unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientCon\n \t                                            move(bind_info), is_operator);\n }\n \n-unique_ptr<BoundAggregateExpression>\n-AggregateFunction::BindAggregateFunction(ClientContext &context, AggregateFunction bound_function,\n-                                         vector<unique_ptr<Expression>> children, unique_ptr<Expression> filter,\n-                                         bool is_distinct, unique_ptr<BoundOrderModifier> order_bys) {\n+unique_ptr<BoundAggregateExpression> AggregateFunction::BindAggregateFunction(\n+    ClientContext &context, AggregateFunction bound_function, vector<unique_ptr<Expression>> children,\n+    unique_ptr<Expression> filter, bool is_distinct, unique_ptr<BoundOrderModifier> order_bys, bool cast_parameters) {\n \tunique_ptr<FunctionData> bind_info;\n \tif (bound_function.bind) {\n \t\tbind_info = bound_function.bind(context, bound_function, children);\n@@ -482,7 +519,7 @@ AggregateFunction::BindAggregateFunction(ClientContext &context, AggregateFuncti\n \t}\n \n \t// check if we need to add casts to the children\n-\tbound_function.CastToFunctionArguments(children);\n+\tbound_function.CastToFunctionArguments(children, cast_parameters);\n \n \t// Special case: for ORDER BY aggregates, we wrap the aggregate function in a SortedAggregateFunction\n \t// The children are the sort clauses and the binding contains the ordering data.\ndiff --git a/src/function/scalar/list/array_slice.cpp b/src/function/scalar/list/array_slice.cpp\nindex ae85ba11723e..4c3440216075 100644\n--- a/src/function/scalar/list/array_slice.cpp\n+++ b/src/function/scalar/list/array_slice.cpp\n@@ -184,6 +184,10 @@ static unique_ptr<FunctionData> ArraySliceBind(ClientContext &context, ScalarFun\n \t\tbound_function.arguments[1] = LogicalType::INTEGER;\n \t\tbound_function.arguments[2] = LogicalType::INTEGER;\n \t\tbreak;\n+\tcase LogicalTypeId::UNKNOWN:\n+\t\tbound_function.arguments[0] = LogicalTypeId::UNKNOWN;\n+\t\tbound_function.return_type = LogicalType::SQLNULL;\n+\t\tbreak;\n \tdefault:\n \t\tthrow BinderException(\"ARRAY_SLICE can only operate on LISTs and VARCHARs\");\n \t}\ndiff --git a/src/function/scalar/list/contains_or_position.cpp b/src/function/scalar/list/contains_or_position.cpp\nindex f10dcaa5a71b..8fbfbcc2a4cb 100644\n--- a/src/function/scalar/list/contains_or_position.cpp\n+++ b/src/function/scalar/list/contains_or_position.cpp\n@@ -179,10 +179,22 @@ static unique_ptr<FunctionData> ListContainsOrPositionBind(ClientContext &contex\n \t\tbound_function.arguments[0] = list;\n \t\tbound_function.arguments[1] = value;\n \t\tbound_function.return_type = LogicalTypeId::SQLNULL;\n+\t} else if (list.id() == LogicalTypeId::UNKNOWN) {\n+\t\tbound_function.return_type = RETURN_TYPE;\n+\t\tif (value.id() != LogicalTypeId::UNKNOWN) {\n+\t\t\t// only list is a parameter, cast it to a list of value type\n+\t\t\tbound_function.arguments[0] = LogicalType::LIST(value);\n+\t\t\tbound_function.arguments[1] = value;\n+\t\t}\n+\t} else if (value.id() == LogicalTypeId::UNKNOWN) {\n+\t\t// only value is a parameter: we expect the child type of list\n+\t\tauto const &child_type = ListType::GetChildType(list);\n+\t\tbound_function.arguments[0] = list;\n+\t\tbound_function.arguments[1] = child_type;\n+\t\tbound_function.return_type = RETURN_TYPE;\n \t} else {\n-\t\tauto const &child_type = ListType::GetChildType(arguments[0]->return_type);\n+\t\tauto const &child_type = ListType::GetChildType(list);\n \t\tauto max_child_type = LogicalType::MaxLogicalType(child_type, value);\n-\t\tExpressionBinder::ResolveParameterType(max_child_type);\n \t\tauto list_type = LogicalType::LIST(max_child_type);\n \n \t\tbound_function.arguments[0] = list_type;\ndiff --git a/src/function/scalar/list/flatten.cpp b/src/function/scalar/list/flatten.cpp\nindex 421acf09dd99..7c7afd853c96 100644\n--- a/src/function/scalar/list/flatten.cpp\n+++ b/src/function/scalar/list/flatten.cpp\n@@ -97,6 +97,11 @@ static unique_ptr<FunctionData> ListFlattenBind(ClientContext &context, ScalarFu\n \t\tbound_function.return_type = LogicalType(LogicalTypeId::SQLNULL);\n \t\treturn make_unique<VariableReturnBindData>(bound_function.return_type);\n \t}\n+\tif (input_type.id() == LogicalTypeId::UNKNOWN) {\n+\t\tbound_function.arguments[0] = LogicalType(LogicalTypeId::UNKNOWN);\n+\t\tbound_function.return_type = LogicalType(LogicalTypeId::SQLNULL);\n+\t\treturn nullptr;\n+\t}\n \tD_ASSERT(input_type.id() == LogicalTypeId::LIST);\n \n \tauto child_type = ListType::GetChildType(input_type);\ndiff --git a/src/function/scalar/list/list_aggregates.cpp b/src/function/scalar/list/list_aggregates.cpp\nindex 6bd769877587..618238f7de25 100644\n--- a/src/function/scalar/list/list_aggregates.cpp\n+++ b/src/function/scalar/list/list_aggregates.cpp\n@@ -165,8 +165,8 @@ static unique_ptr<FunctionData> ListAggregateBind(ClientContext &context, Scalar\n \t\treturn make_unique<VariableReturnBindData>(bound_function.return_type);\n \t}\n \n-\tD_ASSERT(LogicalTypeId::LIST == arguments[0]->return_type.id());\n-\tauto list_child_type = ListType::GetChildType(arguments[0]->return_type);\n+\tbool is_parameter = arguments[0]->return_type.id() == LogicalTypeId::UNKNOWN;\n+\tauto list_child_type = is_parameter ? LogicalTypeId::UNKNOWN : ListType::GetChildType(arguments[0]->return_type);\n \tbound_function.return_type = list_child_type;\n \n \tif (!arguments[1]->IsFoldable()) {\n@@ -182,8 +182,7 @@ static unique_ptr<FunctionData> ListAggregateBind(ClientContext &context, Scalar\n \n \t// create the child expression and its type\n \tvector<unique_ptr<Expression>> children;\n-\tauto expr = make_unique<BoundConstantExpression>(Value(LogicalType::SQLNULL));\n-\texpr->return_type = list_child_type;\n+\tauto expr = make_unique<BoundConstantExpression>(Value(list_child_type));\n \tchildren.push_back(move(expr));\n \n \t// look up the aggregate function in the catalog\n@@ -192,6 +191,12 @@ static unique_ptr<FunctionData> ListAggregateBind(ClientContext &context, Scalar\n \t    context, DEFAULT_SCHEMA, function_name, false, error_context);\n \tD_ASSERT(func->type == CatalogType::AGGREGATE_FUNCTION_ENTRY);\n \n+\tif (is_parameter) {\n+\t\tbound_function.arguments[0] = LogicalTypeId::UNKNOWN;\n+\t\tbound_function.return_type = LogicalType::SQLNULL;\n+\t\treturn nullptr;\n+\t}\n+\n \t// find a matching aggregate function\n \tstring error;\n \tauto best_function_idx = Function::BindFunction(func->name, func->functions, types, error);\n@@ -203,8 +208,8 @@ static unique_ptr<FunctionData> ListAggregateBind(ClientContext &context, Scalar\n \tauto &best_function = func->functions[best_function_idx];\n \tauto bound_aggr_function = AggregateFunction::BindAggregateFunction(context, best_function, move(children));\n \n-\tbound_function.arguments[0] =\n-\t    LogicalType::LIST(bound_aggr_function->function.arguments[0]); // for proper casting of the vectors\n+\t// for proper casting of the vectors\n+\tbound_function.arguments[0] = LogicalType::LIST(bound_aggr_function->function.arguments[0]);\n \tbound_function.return_type = bound_aggr_function->function.return_type;\n \treturn make_unique<ListAggregatesBindData>(bound_function.return_type, move(bound_aggr_function));\n }\ndiff --git a/src/function/scalar/list/list_concat.cpp b/src/function/scalar/list/list_concat.cpp\nindex 3d42a23a134f..9519f8ebda2a 100644\n--- a/src/function/scalar/list/list_concat.cpp\n+++ b/src/function/scalar/list/list_concat.cpp\n@@ -95,7 +95,6 @@ static unique_ptr<FunctionData> ListConcatBind(ClientContext &context, ScalarFun\n \t\tfor (const auto &argument : arguments) {\n \t\t\tchild_type = LogicalType::MaxLogicalType(child_type, ListType::GetChildType(argument->return_type));\n \t\t}\n-\t\tExpressionBinder::ResolveParameterType(child_type);\n \t\tauto list_type = LogicalType::LIST(move(child_type));\n \n \t\tbound_function.arguments[0] = list_type;\ndiff --git a/src/function/scalar/list/list_extract.cpp b/src/function/scalar/list/list_extract.cpp\nindex 82fc37b201e6..1602dda25399 100644\n--- a/src/function/scalar/list/list_extract.cpp\n+++ b/src/function/scalar/list/list_extract.cpp\n@@ -159,8 +159,8 @@ static void ExecuteListExtract(Vector &result, Vector &list, Vector &offsets, co\n }\n \n static void ExecuteStringExtract(Vector &result, Vector &input_vector, Vector &subscript_vector, const idx_t count) {\n-\tBinaryExecutor::Execute<string_t, int32_t, string_t>(\n-\t    input_vector, subscript_vector, result, count, [&](string_t input_string, int32_t subscript) {\n+\tBinaryExecutor::Execute<string_t, int64_t, string_t>(\n+\t    input_vector, subscript_vector, result, count, [&](string_t input_string, int64_t subscript) {\n \t\t    return SubstringFun::SubstringScalarFunction(result, input_string, subscript, 1);\n \t    });\n }\n@@ -230,7 +230,7 @@ void ListExtractFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunction lfun({LogicalType::LIST(LogicalType::ANY), LogicalType::BIGINT}, LogicalType::ANY,\n \t                    ListExtractFunction, false, false, ListExtractBind, nullptr, ListExtractStats);\n \n-\tScalarFunction sfun({LogicalType::VARCHAR, LogicalType::INTEGER}, LogicalType::VARCHAR, ListExtractFunction, false,\n+\tScalarFunction sfun({LogicalType::VARCHAR, LogicalType::BIGINT}, LogicalType::VARCHAR, ListExtractFunction, false,\n \t                    false, nullptr);\n \n \tScalarFunctionSet list_extract(\"list_extract\");\ndiff --git a/src/function/scalar/list/list_value.cpp b/src/function/scalar/list/list_value.cpp\nindex 6b2150c9c60e..c5653bec2d18 100644\n--- a/src/function/scalar/list/list_value.cpp\n+++ b/src/function/scalar/list/list_value.cpp\n@@ -39,7 +39,6 @@ static unique_ptr<FunctionData> ListValueBind(ClientContext &context, ScalarFunc\n \tfor (idx_t i = 0; i < arguments.size(); i++) {\n \t\tchild_type = LogicalType::MaxLogicalType(child_type, arguments[i]->return_type);\n \t}\n-\tExpressionBinder::ResolveParameterType(child_type);\n \n \t// this is more for completeness reasons\n \tbound_function.varargs = child_type;\ndiff --git a/src/function/scalar/string/printf.cpp b/src/function/scalar/string/printf.cpp\nindex ca270d7ea854..9f1150eb7b46 100644\n--- a/src/function/scalar/string/printf.cpp\n+++ b/src/function/scalar/string/printf.cpp\n@@ -41,6 +41,10 @@ unique_ptr<FunctionData> BindPrintfFunction(ClientContext &context, ScalarFuncti\n \t\t\t// decimal type: add cast to double\n \t\t\tbound_function.arguments.emplace_back(LogicalType::DOUBLE);\n \t\t\tbreak;\n+\t\tcase LogicalTypeId::UNKNOWN:\n+\t\t\t// parameter: accept any input and rebind later\n+\t\t\tbound_function.arguments.emplace_back(LogicalType::ANY);\n+\t\t\tbreak;\n \t\tdefault:\n \t\t\t// all other types: add cast to string\n \t\t\tbound_function.arguments.emplace_back(LogicalType::VARCHAR);\ndiff --git a/src/function/scalar/struct/struct_pack.cpp b/src/function/scalar/struct/struct_pack.cpp\nindex a18391344c4a..2105f73c5d4f 100644\n--- a/src/function/scalar/struct/struct_pack.cpp\n+++ b/src/function/scalar/struct/struct_pack.cpp\n@@ -49,7 +49,6 @@ static unique_ptr<FunctionData> StructPackBind(ClientContext &context, ScalarFun\n \t\tif (name_collision_set.find(child->alias) != name_collision_set.end()) {\n \t\t\tthrow BinderException(\"Duplicate struct entry name \\\"%s\\\"\", child->alias);\n \t\t}\n-\t\tExpressionBinder::ResolveParameterType(arguments[i]);\n \t\tname_collision_set.insert(child->alias);\n \t\tstruct_children.push_back(make_pair(child->alias, arguments[i]->return_type));\n \t}\ndiff --git a/src/include/duckdb/execution/operator/helper/physical_execute.hpp b/src/include/duckdb/execution/operator/helper/physical_execute.hpp\nindex b7e12be6177b..971d0f827149 100644\n--- a/src/include/duckdb/execution/operator/helper/physical_execute.hpp\n+++ b/src/include/duckdb/execution/operator/helper/physical_execute.hpp\n@@ -9,6 +9,7 @@\n #pragma once\n \n #include \"duckdb/execution/physical_operator.hpp\"\n+#include \"duckdb/main/prepared_statement_data.hpp\"\n \n namespace duckdb {\n \n@@ -17,6 +18,8 @@ class PhysicalExecute : public PhysicalOperator {\n \texplicit PhysicalExecute(PhysicalOperator *plan);\n \n \tPhysicalOperator *plan;\n+\tunique_ptr<PhysicalOperator> owned_plan;\n+\tshared_ptr<PreparedStatementData> prepared;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/function/aggregate_function.hpp b/src/include/duckdb/function/aggregate_function.hpp\nindex 50ca6ca81fb5..02e13488642e 100644\n--- a/src/include/duckdb/function/aggregate_function.hpp\n+++ b/src/include/duckdb/function/aggregate_function.hpp\n@@ -131,7 +131,8 @@ class AggregateFunction : public BaseScalarFunction {\n \tDUCKDB_API static unique_ptr<BoundAggregateExpression>\n \tBindAggregateFunction(ClientContext &context, AggregateFunction bound_function,\n \t                      vector<unique_ptr<Expression>> children, unique_ptr<Expression> filter = nullptr,\n-\t                      bool is_distinct = false, unique_ptr<BoundOrderModifier> order_bys = nullptr);\n+\t                      bool is_distinct = false, unique_ptr<BoundOrderModifier> order_bys = nullptr,\n+\t                      bool cast_parameters = true);\n \n \tDUCKDB_API static unique_ptr<FunctionData> BindSortedAggregate(AggregateFunction &bound_function,\n \t                                                               vector<unique_ptr<Expression>> &children,\ndiff --git a/src/include/duckdb/function/function.hpp b/src/include/duckdb/function/function.hpp\nindex 45629d379849..db5112a5f3f9 100644\n--- a/src/include/duckdb/function/function.hpp\n+++ b/src/include/duckdb/function/function.hpp\n@@ -77,11 +77,14 @@ class Function {\n \t//! Bind a scalar function from the set of functions and input arguments. Returns the index of the chosen function,\n \t//! returns DConstants::INVALID_INDEX and sets error if none could be found\n \tDUCKDB_API static idx_t BindFunction(const string &name, vector<ScalarFunction> &functions,\n-\t                                     vector<LogicalType> &arguments, string &error);\n+\t                                     vector<LogicalType> &arguments, string &error, bool &cast_parameters);\n \tDUCKDB_API static idx_t BindFunction(const string &name, vector<ScalarFunction> &functions,\n-\t                                     vector<unique_ptr<Expression>> &arguments, string &error);\n+\t                                     vector<unique_ptr<Expression>> &arguments, string &error,\n+\t                                     bool &cast_parameters);\n \t//! Bind an aggregate function from the set of functions and input arguments. Returns the index of the chosen\n \t//! function, returns DConstants::INVALID_INDEX and sets error if none could be found\n+\tDUCKDB_API static idx_t BindFunction(const string &name, vector<AggregateFunction> &functions,\n+\t                                     vector<LogicalType> &arguments, string &error, bool &cast_parameters);\n \tDUCKDB_API static idx_t BindFunction(const string &name, vector<AggregateFunction> &functions,\n \t                                     vector<LogicalType> &arguments, string &error);\n \tDUCKDB_API static idx_t BindFunction(const string &name, vector<AggregateFunction> &functions,\n@@ -148,7 +151,8 @@ class BaseScalarFunction : public SimpleFunction {\n \tDUCKDB_API hash_t Hash() const;\n \n \t//! Cast a set of expressions to the arguments of this function\n-\tDUCKDB_API void CastToFunctionArguments(vector<unique_ptr<Expression>> &children);\n+\tDUCKDB_API void CastToFunctionArguments(vector<unique_ptr<Expression>> &children,\n+\t                                        bool cast_parameter_expressions = true);\n \n \tDUCKDB_API string ToString() override;\n };\ndiff --git a/src/include/duckdb/function/scalar_function.hpp b/src/include/duckdb/function/scalar_function.hpp\nindex 951794ff678f..f25a43ba3ced 100644\n--- a/src/include/duckdb/function/scalar_function.hpp\n+++ b/src/include/duckdb/function/scalar_function.hpp\n@@ -73,10 +73,9 @@ class ScalarFunction : public BaseScalarFunction {\n \t                                                                         vector<unique_ptr<Expression>> children,\n \t                                                                         string &error, bool is_operator = false);\n \n-\tDUCKDB_API static unique_ptr<BoundFunctionExpression> BindScalarFunction(ClientContext &context,\n-\t                                                                         ScalarFunction bound_function,\n-\t                                                                         vector<unique_ptr<Expression>> children,\n-\t                                                                         bool is_operator = false);\n+\tDUCKDB_API static unique_ptr<BoundFunctionExpression>\n+\tBindScalarFunction(ClientContext &context, ScalarFunction bound_function, vector<unique_ptr<Expression>> children,\n+\t                   bool is_operator = false, bool cast_parameters = true);\n \n \tDUCKDB_API bool operator==(const ScalarFunction &rhs) const;\n \tDUCKDB_API bool operator!=(const ScalarFunction &rhs) const;\ndiff --git a/src/include/duckdb/main/client_context.hpp b/src/include/duckdb/main/client_context.hpp\nindex 7d38f38e4a0d..babb1bd47501 100644\n--- a/src/include/duckdb/main/client_context.hpp\n+++ b/src/include/duckdb/main/client_context.hpp\n@@ -211,7 +211,8 @@ class ClientContext : public std::enable_shared_from_this<ClientContext> {\n \n \t//! Internally prepare a SQL statement. Caller must hold the context_lock.\n \tshared_ptr<PreparedStatementData> CreatePreparedStatement(ClientContextLock &lock, const string &query,\n-\t                                                          unique_ptr<SQLStatement> statement);\n+\t                                                          unique_ptr<SQLStatement> statement,\n+\t                                                          vector<Value> *values = nullptr);\n \tunique_ptr<PendingQueryResult> PendingStatementInternal(ClientContextLock &lock, const string &query,\n \t                                                        unique_ptr<SQLStatement> statement);\n \tunique_ptr<QueryResult> RunStatementInternal(ClientContextLock &lock, const string &query,\ndiff --git a/src/include/duckdb/main/prepared_statement_data.hpp b/src/include/duckdb/main/prepared_statement_data.hpp\nindex d4f5fb9ca223..f56222ae05ce 100644\n--- a/src/include/duckdb/main/prepared_statement_data.hpp\n+++ b/src/include/duckdb/main/prepared_statement_data.hpp\n@@ -44,6 +44,8 @@ class PreparedStatementData {\n \tbool requires_valid_transaction;\n \t//! Whether or not the result can be streamed to the client\n \tbool allow_stream_result;\n+\t//! Whether or not all parameters have successfully had their types determined\n+\tbool bound_all_parameters;\n \n \t//! The catalog version of when the prepared statement was bound\n \t//! If this version is lower than the current catalog version, we have to rebind the prepared statement\ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 4e4c8b3cd84e..916f577f94a6 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -81,6 +81,8 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \tvector<CorrelatedColumnInfo> correlated_columns;\n \t//! The set of parameter expressions bound by this binder\n \tvector<BoundParameterExpression *> *parameters;\n+\t//! The types of the prepared statement parameters, if any\n+\tvector<LogicalType> *parameter_types;\n \t//! Whether or not the bound statement is read-only\n \tbool read_only;\n \t//! Whether or not the statement requires a valid transaction to run\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 5343735e5d15..693eea1afc39 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -99,9 +99,6 @@ class ExpressionBinder {\n \tstatic bool ContainsType(const LogicalType &type, LogicalTypeId target);\n \tstatic LogicalType ExchangeType(const LogicalType &type, LogicalTypeId target, LogicalType new_type);\n \n-\tstatic void ResolveParameterType(LogicalType &type);\n-\tstatic void ResolveParameterType(unique_ptr<Expression> &expr);\n-\n \t//! Bind the given expresion. Unlike Bind(), this does *not* mute the given ParsedExpression.\n \t//! Exposed to be used from sub-binders that aren't subclasses of ExpressionBinder.\n \tvirtual BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,\n@@ -123,7 +120,6 @@ class ExpressionBinder {\n \tBindResult BindExpression(OperatorExpression &expr, idx_t depth);\n \tBindResult BindExpression(ParameterExpression &expr, idx_t depth);\n \tBindResult BindExpression(PositionalReferenceExpression &ref, idx_t depth);\n-\tBindResult BindExpression(StarExpression &expr, idx_t depth);\n \tBindResult BindExpression(SubqueryExpression &expr, idx_t depth);\n \n protected:\ndiff --git a/src/include/duckdb/planner/planner.hpp b/src/include/duckdb/planner/planner.hpp\nindex 1c04bb5cb014..62aeff267d46 100644\n--- a/src/include/duckdb/planner/planner.hpp\n+++ b/src/include/duckdb/planner/planner.hpp\n@@ -28,6 +28,7 @@ class Planner {\n \tvector<string> names;\n \tvector<LogicalType> types;\n \tunordered_map<idx_t, vector<unique_ptr<Value>>> value_map;\n+\tvector<LogicalType> parameter_types;\n \n \tshared_ptr<Binder> binder;\n \tClientContext &context;\n@@ -35,17 +36,12 @@ class Planner {\n \tbool read_only;\n \tbool requires_valid_transaction;\n \tbool allow_stream_result;\n+\tbool bound_all_parameters;\n \n private:\n \tvoid CreatePlan(SQLStatement &statement);\n \tshared_ptr<PreparedStatementData> PrepareSQLStatement(unique_ptr<SQLStatement> statement);\n \tvoid PlanPrepare(unique_ptr<SQLStatement> statement);\n \tvoid PlanExecute(unique_ptr<SQLStatement> statement);\n-\n-\t// void VerifyQuery(BoundSQLStatement &statement);\n-\t// void VerifyNode(BoundQueryNode &statement);\n-\t// void VerifyExpression(Expression &expr, vector<unique_ptr<Expression>> &copies);\n-\n-\t// bool StatementRequiresValidTransaction(BoundSQLStatement &statement);\n };\n } // namespace duckdb\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex a567fb3f2348..c4bd9e2e4afc 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -241,13 +241,19 @@ unique_ptr<QueryResult> ClientContext::FetchResultInternal(ClientContextLock &lo\n }\n \n shared_ptr<PreparedStatementData> ClientContext::CreatePreparedStatement(ClientContextLock &lock, const string &query,\n-                                                                         unique_ptr<SQLStatement> statement) {\n+                                                                         unique_ptr<SQLStatement> statement,\n+                                                                         vector<Value> *values) {\n \tStatementType statement_type = statement->type;\n \tauto result = make_shared<PreparedStatementData>(statement_type);\n \n \tauto &profiler = QueryProfiler::Get(*this);\n \tprofiler.StartPhase(\"planner\");\n \tPlanner planner(*this);\n+\tif (values) {\n+\t\tfor (auto &value : *values) {\n+\t\t\tplanner.parameter_types.push_back(value.type());\n+\t\t}\n+\t}\n \tplanner.CreatePlan(move(statement));\n \tD_ASSERT(planner.plan);\n \tprofiler.EndPhase();\n@@ -264,6 +270,7 @@ shared_ptr<PreparedStatementData> ClientContext::CreatePreparedStatement(ClientC\n \tresult->types = planner.types;\n \tresult->value_map = move(planner.value_map);\n \tresult->catalog_version = Transaction::GetTransaction(*this).catalog_version;\n+\tresult->bound_all_parameters = planner.bound_all_parameters;\n \n \tif (config.enable_optimizer) {\n \t\tprofiler.StartPhase(\"optimizer\");\n@@ -572,15 +579,17 @@ ClientContext::PendingStatementOrPreparedStatement(ClientContextLock &lock, cons\n \t\t\tresult = PendingStatementInternal(lock, query, move(statement));\n \t\t} else {\n \t\t\tauto &catalog = Catalog::GetCatalog(*this);\n-\t\t\tif (prepared->unbound_statement && catalog.GetCatalogVersion() != prepared->catalog_version) {\n-\t\t\t\tD_ASSERT(prepared->unbound_statement.get());\n+\t\t\tif (prepared->unbound_statement &&\n+\t\t\t    (catalog.GetCatalogVersion() != prepared->catalog_version || !prepared->bound_all_parameters)) {\n \t\t\t\t// catalog was modified: rebind the statement before execution\n-\t\t\t\tauto new_prepared = CreatePreparedStatement(lock, query, prepared->unbound_statement->Copy());\n-\t\t\t\tif (prepared->types != new_prepared->types) {\n+\t\t\t\tauto new_prepared = CreatePreparedStatement(lock, query, prepared->unbound_statement->Copy(), values);\n+\t\t\t\tif (prepared->types != new_prepared->types && prepared->bound_all_parameters) {\n \t\t\t\t\tthrow BinderException(\"Rebinding statement after catalog change resulted in change of types\");\n \t\t\t\t}\n+\t\t\t\tD_ASSERT(new_prepared->bound_all_parameters);\n \t\t\t\tnew_prepared->unbound_statement = move(prepared->unbound_statement);\n \t\t\t\tprepared = move(new_prepared);\n+\t\t\t\tprepared->bound_all_parameters = false;\n \t\t\t}\n \t\t\tresult = PendingPreparedStatement(lock, prepared, *values);\n \t\t}\ndiff --git a/src/main/prepared_statement_data.cpp b/src/main/prepared_statement_data.cpp\nindex c2f9edb759e8..700945a8aab8 100644\n--- a/src/main/prepared_statement_data.cpp\n+++ b/src/main/prepared_statement_data.cpp\n@@ -5,7 +5,8 @@\n namespace duckdb {\n \n PreparedStatementData::PreparedStatementData(StatementType type)\n-    : statement_type(type), read_only(true), requires_valid_transaction(true), allow_stream_result(false) {\n+    : statement_type(type), read_only(true), requires_valid_transaction(true), allow_stream_result(false),\n+      bound_all_parameters(true) {\n }\n \n PreparedStatementData::~PreparedStatementData() {\ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex 97db05bdec07..8b28a7848505 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -25,6 +25,7 @@ Binder::Binder(bool, ClientContext &context, shared_ptr<Binder> parent_p, bool i\n     : context(context), read_only(true), requires_valid_transaction(true), allow_stream_result(false),\n       parent(move(parent_p)), bound_tables(0), inherit_ctes(inherit_ctes_p) {\n \tparameters = nullptr;\n+\tparameter_types = nullptr;\n \tif (parent) {\n \t\t// We have to inherit macro parameter bindings from the parent binder, if there is a parent.\n \t\tmacro_binding = parent->macro_binding;\n@@ -33,6 +34,7 @@ Binder::Binder(bool, ClientContext &context, shared_ptr<Binder> parent_p, bool i\n \t\t\tbind_context.SetCTEBindings(parent->bind_context.GetCTEBindings());\n \t\t\tbind_context.cte_references = parent->bind_context.cte_references;\n \t\t\tparameters = parent->parameters;\n+\t\t\tparameter_types = parent->parameter_types;\n \t\t}\n \t}\n }\ndiff --git a/src/planner/binder/expression/bind_aggregate_expression.cpp b/src/planner/binder/expression/bind_aggregate_expression.cpp\nindex 77d327d7d847..a02fa47cd40b 100644\n--- a/src/planner/binder/expression/bind_aggregate_expression.cpp\n+++ b/src/planner/binder/expression/bind_aggregate_expression.cpp\n@@ -148,7 +148,8 @@ BindResult SelectBinder::BindAggregate(FunctionExpression &aggr, AggregateFuncti\n \t}\n \n \t// bind the aggregate\n-\tidx_t best_function = Function::BindFunction(func->name, func->functions, types, error);\n+\tbool cast_parameters;\n+\tidx_t best_function = Function::BindFunction(func->name, func->functions, types, error, cast_parameters);\n \tif (best_function == DConstants::INVALID_INDEX) {\n \t\tthrow BinderException(binder.FormatError(aggr, error));\n \t}\n@@ -168,8 +169,8 @@ BindResult SelectBinder::BindAggregate(FunctionExpression &aggr, AggregateFuncti\n \t\t}\n \t}\n \n-\tauto aggregate = AggregateFunction::BindAggregateFunction(context, bound_function, move(children),\n-\t                                                          move(bound_filter), aggr.distinct, move(order_bys));\n+\tauto aggregate = AggregateFunction::BindAggregateFunction(\n+\t    context, bound_function, move(children), move(bound_filter), aggr.distinct, move(order_bys), cast_parameters);\n \tif (aggr.export_state) {\n \t\taggregate = ExportAggregateFunction::Bind(move(aggregate));\n \t}\ndiff --git a/src/planner/binder/expression/bind_case_expression.cpp b/src/planner/binder/expression/bind_case_expression.cpp\nindex dd9169dd9bc1..37b82f153891 100644\n--- a/src/planner/binder/expression/bind_case_expression.cpp\n+++ b/src/planner/binder/expression/bind_case_expression.cpp\n@@ -23,7 +23,6 @@ BindResult ExpressionBinder::BindExpression(CaseExpression &expr, idx_t depth) {\n \t\tauto &then_expr = (BoundExpression &)*check.then_expr;\n \t\treturn_type = LogicalType::MaxLogicalType(return_type, then_expr.expr->return_type);\n \t}\n-\tExpressionBinder::ResolveParameterType(return_type);\n \n \t// bind all the individual components of the CASE statement\n \tauto result = make_unique<BoundCaseExpression>(return_type);\ndiff --git a/src/planner/binder/expression/bind_comparison_expression.cpp b/src/planner/binder/expression/bind_comparison_expression.cpp\nindex d7d507de197e..d2886b607c2a 100644\n--- a/src/planner/binder/expression/bind_comparison_expression.cpp\n+++ b/src/planner/binder/expression/bind_comparison_expression.cpp\n@@ -101,10 +101,6 @@ LogicalType BoundComparisonExpression::BindComparison(LogicalType left_type, Log\n \t\t\t}\n \t\t}\n \t\treturn result_type;\n-\tcase LogicalTypeId::UNKNOWN:\n-\t\t// comparing two prepared statement parameters (e.g. SELECT ?=?)\n-\t\t// default to VARCHAR\n-\t\treturn LogicalType::VARCHAR;\n \tdefault:\n \t\treturn result_type;\n \t}\ndiff --git a/src/planner/binder/expression/bind_operator_expression.cpp b/src/planner/binder/expression/bind_operator_expression.cpp\nindex a918b51362b2..7d8ffa91b4a3 100644\n--- a/src/planner/binder/expression/bind_operator_expression.cpp\n+++ b/src/planner/binder/expression/bind_operator_expression.cpp\n@@ -23,7 +23,6 @@ static LogicalType ResolveInType(OperatorExpression &op, vector<BoundExpression\n \tfor (idx_t i = 1; i < children.size(); i++) {\n \t\tmax_type = LogicalType::MaxLogicalType(max_type, children[i]->expr->return_type);\n \t}\n-\tExpressionBinder::ResolveParameterType(max_type);\n \n \t// cast all children to the same type\n \tfor (idx_t i = 0; i < children.size(); i++) {\n@@ -38,7 +37,6 @@ static LogicalType ResolveOperatorType(OperatorExpression &op, vector<BoundExpre\n \tcase ExpressionType::OPERATOR_IS_NULL:\n \tcase ExpressionType::OPERATOR_IS_NOT_NULL:\n \t\t// IS (NOT) NULL always returns a boolean, and does not cast its children\n-\t\tExpressionBinder::ResolveParameterType(children[0]->expr);\n \t\treturn LogicalType::BOOLEAN;\n \tcase ExpressionType::COMPARE_IN:\n \tcase ExpressionType::COMPARE_NOT_IN:\ndiff --git a/src/planner/binder/expression/bind_parameter_expression.cpp b/src/planner/binder/expression/bind_parameter_expression.cpp\nindex 8e12236ad806..29a60c5803cc 100644\n--- a/src/planner/binder/expression/bind_parameter_expression.cpp\n+++ b/src/planner/binder/expression/bind_parameter_expression.cpp\n@@ -11,6 +11,9 @@ BindResult ExpressionBinder::BindExpression(ParameterExpression &expr, idx_t dep\n \t\tthrow std::runtime_error(\"Unexpected prepared parameter. This type of statement can't be prepared!\");\n \t}\n \tbinder.parameters->push_back(bound_parameter.get());\n+\tif (binder.parameter_types && expr.parameter_nr <= binder.parameter_types->size()) {\n+\t\tbound_parameter->return_type = (*binder.parameter_types)[expr.parameter_nr - 1];\n+\t}\n \treturn BindResult(move(bound_parameter));\n }\n \ndiff --git a/src/planner/binder/expression/bind_subquery_expression.cpp b/src/planner/binder/expression/bind_subquery_expression.cpp\nindex 08b2fbccf687..9d8c7ea8790f 100644\n--- a/src/planner/binder/expression/bind_subquery_expression.cpp\n+++ b/src/planner/binder/expression/bind_subquery_expression.cpp\n@@ -76,7 +76,9 @@ BindResult ExpressionBinder::BindExpression(SubqueryExpression &expr, idx_t dept\n \tauto bound_node = move(bound_subquery->bound_node);\n \tLogicalType return_type =\n \t    expr.subquery_type == SubqueryType::SCALAR ? bound_node->types[0] : LogicalType(LogicalTypeId::BOOLEAN);\n-\tD_ASSERT(return_type.id() != LogicalTypeId::UNKNOWN);\n+\tif (return_type.id() == LogicalTypeId::UNKNOWN) {\n+\t\treturn_type = LogicalType::SQLNULL;\n+\t}\n \n \tauto result = make_unique<BoundSubqueryExpression>(return_type);\n \tif (expr.subquery_type == SubqueryType::ANY) {\ndiff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp\nindex 383bb491b11b..38bd32238f2b 100644\n--- a/src/planner/expression_binder.cpp\n+++ b/src/planner/expression_binder.cpp\n@@ -165,19 +165,6 @@ LogicalType ExpressionBinder::ExchangeNullType(const LogicalType &type) {\n \treturn ExchangeType(type, LogicalTypeId::SQLNULL, LogicalType::INTEGER);\n }\n \n-void ExpressionBinder::ResolveParameterType(LogicalType &type) {\n-\tif (type.id() == LogicalTypeId::UNKNOWN) {\n-\t\ttype = LogicalType::VARCHAR;\n-\t}\n-}\n-\n-void ExpressionBinder::ResolveParameterType(unique_ptr<Expression> &expr) {\n-\tif (ContainsType(expr->return_type, LogicalTypeId::UNKNOWN)) {\n-\t\tauto result_type = ExchangeType(expr->return_type, LogicalTypeId::UNKNOWN, LogicalType::VARCHAR);\n-\t\texpr = BoundCastExpression::AddCastToType(move(expr), result_type);\n-\t}\n-}\n-\n unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr, LogicalType *result_type,\n                                               bool root_expression) {\n \t// bind the main expression\n@@ -206,9 +193,6 @@ unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr\n \t\t\t\tresult = BoundCastExpression::AddCastToType(move(result), result_type);\n \t\t\t}\n \t\t}\n-\t\t// check if we failed to convert any parameters\n-\t\t// if we did, we push a cast\n-\t\tExpressionBinder::ResolveParameterType(result);\n \t}\n \tif (result_type) {\n \t\t*result_type = result->return_type;\ndiff --git a/src/planner/planner.cpp b/src/planner/planner.cpp\nindex eb08ea75e0ba..3a37be7c1211 100644\n--- a/src/planner/planner.cpp\n+++ b/src/planner/planner.cpp\n@@ -28,6 +28,7 @@ void Planner::CreatePlan(SQLStatement &statement) {\n \t// first bind the tables and columns to the catalog\n \tprofiler.StartPhase(\"binder\");\n \tbinder->parameters = &bound_parameters;\n+\tbinder->parameter_types = &parameter_types;\n \tauto bound_statement = binder->Bind(statement);\n \tprofiler.EndPhase();\n \n@@ -37,20 +38,23 @@ void Planner::CreatePlan(SQLStatement &statement) {\n \tthis->names = bound_statement.names;\n \tthis->types = bound_statement.types;\n \tthis->plan = move(bound_statement.plan);\n+\tthis->bound_all_parameters = true;\n \n \t// set up a map of parameter number -> value entries\n \tfor (auto &expr : bound_parameters) {\n \t\t// check if the type of the parameter could be resolved\n \t\tif (expr->return_type.id() == LogicalTypeId::INVALID || expr->return_type.id() == LogicalTypeId::UNKNOWN) {\n-\t\t\tthrow BinderException(\"Could not determine type of parameters\");\n+\t\t\tthis->bound_all_parameters = false;\n+\t\t\tcontinue;\n \t\t}\n \t\tauto value = make_unique<Value>(expr->return_type);\n \t\texpr->value = value.get();\n \t\t// check if the parameter number has been used before\n-\t\tif (value_map.find(expr->parameter_nr) == value_map.end()) {\n+\t\tauto entry = value_map.find(expr->parameter_nr);\n+\t\tif (entry == value_map.end()) {\n \t\t\t// not used before, create vector\n \t\t\tvalue_map[expr->parameter_nr] = vector<unique_ptr<Value>>();\n-\t\t} else if (value_map[expr->parameter_nr].back()->type() != value->type()) {\n+\t\t} else if (entry->second.back()->type() != value->type()) {\n \t\t\t// used before, but types are inconsistent\n \t\t\tthrow BinderException(\"Inconsistent types found for parameter with index %llu\", expr->parameter_nr);\n \t\t}\n@@ -72,6 +76,7 @@ shared_ptr<PreparedStatementData> Planner::PrepareSQLStatement(unique_ptr<SQLSta\n \tprepared_data->requires_valid_transaction = this->requires_valid_transaction;\n \tprepared_data->allow_stream_result = this->allow_stream_result;\n \tprepared_data->catalog_version = Transaction::GetTransaction(context).catalog_version;\n+\tprepared_data->bound_all_parameters = this->bound_all_parameters;\n \treturn prepared_data;\n }\n \n@@ -89,30 +94,43 @@ void Planner::PlanExecute(unique_ptr<SQLStatement> statement) {\n \tauto prepared = entry->second;\n \tauto &catalog = Catalog::GetCatalog(context);\n \tbool rebound = false;\n-\tif (catalog.GetCatalogVersion() != entry->second->catalog_version) {\n-\t\t// catalog was modified: rebind the statement before running the execute\n-\t\tprepared = PrepareSQLStatement(entry->second->unbound_statement->Copy());\n-\t\tif (prepared->types != entry->second->types) {\n-\t\t\tthrow BinderException(\"Rebinding statement \\\"%s\\\" after catalog change resulted in change of types\",\n-\t\t\t                      stmt.name);\n-\t\t}\n-\t\trebound = true;\n-\t}\n \n-\t// the bound prepared statement is ready: bind any supplied parameters\n+\t// bind any supplied parameters\n \tvector<Value> bind_values;\n \tfor (idx_t i = 0; i < stmt.values.size(); i++) {\n \t\tConstantBinder cbinder(*binder, context, \"EXECUTE statement\");\n-\t\tif (prepared->value_map.count(i + 1)) {\n-\t\t\tcbinder.target_type = prepared->GetType(i + 1);\n-\t\t}\n \t\tauto bound_expr = cbinder.Bind(stmt.values[i]);\n \n \t\tValue value = ExpressionExecutor::EvaluateScalar(*bound_expr);\n \t\tbind_values.push_back(move(value));\n \t}\n+\tbool all_bound = prepared->bound_all_parameters;\n+\tif (catalog.GetCatalogVersion() != entry->second->catalog_version || !all_bound) {\n+\t\t// catalog was modified or statement does not have clear types: rebind the statement before running the execute\n+\t\tfor (auto &value : bind_values) {\n+\t\t\tparameter_types.push_back(value.type());\n+\t\t}\n+\t\tprepared = PrepareSQLStatement(entry->second->unbound_statement->Copy());\n+\t\tif (all_bound && prepared->types != entry->second->types) {\n+\t\t\tthrow BinderException(\"Rebinding statement \\\"%s\\\" after catalog change resulted in change of types\",\n+\t\t\t                      stmt.name);\n+\t\t}\n+\t\tD_ASSERT(prepared->bound_all_parameters);\n+\t\trebound = true;\n+\t}\n+\t// add casts to the prepared statement parameters as required\n+\tfor (idx_t i = 0; i < bind_values.size(); i++) {\n+\t\tif (prepared->value_map.count(i + 1) == 0) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tbind_values[i] = bind_values[i].CastAs(prepared->GetType(i + 1));\n+\t}\n+\n \tprepared->Bind(move(bind_values));\n \tif (rebound) {\n+\t\tauto execute_plan = make_unique<LogicalExecute>(move(prepared));\n+\t\texecute_plan->children.push_back(move(plan));\n+\t\tthis->plan = move(execute_plan);\n \t\treturn;\n \t}\n \n@@ -122,6 +140,7 @@ void Planner::PlanExecute(unique_ptr<SQLStatement> statement) {\n \tthis->allow_stream_result = prepared->allow_stream_result;\n \tthis->names = prepared->names;\n \tthis->types = prepared->types;\n+\tthis->bound_all_parameters = prepared->bound_all_parameters;\n \tthis->plan = make_unique<LogicalExecute>(move(prepared));\n }\n \n@@ -136,6 +155,7 @@ void Planner::PlanPrepare(unique_ptr<SQLStatement> statement) {\n \t// this is required because most clients ALWAYS invoke prepared statements\n \tthis->requires_valid_transaction = false;\n \tthis->allow_stream_result = false;\n+\tthis->bound_all_parameters = true;\n \tthis->names = {\"Success\"};\n \tthis->types = {LogicalType::BOOLEAN};\n \tthis->plan = move(prepare);\ndiff --git a/tools/rpkg/src/statement.cpp b/tools/rpkg/src/statement.cpp\nindex 90baf4dca024..276fef91cf25 100644\n--- a/tools/rpkg/src/statement.cpp\n+++ b/tools/rpkg/src/statement.cpp\n@@ -112,6 +112,9 @@ static void VectorToR(Vector &src_vec, size_t count, void *dest, uint64_t dest_o\n \t\tcase LogicalTypeId::ENUM:\n \t\t\trtype = \"factor\";\n \t\t\tbreak;\n+\t\tcase LogicalTypeId::UNKNOWN:\n+\t\t\trtype = \"unknown\";\n+\t\t\tbreak;\n \t\tdefault:\n \t\t\tcpp11::stop(\"rapi_prepare: Unknown column type for prepare: %s\", stype.ToString().c_str());\n \t\t\tbreak;\n",
  "test_patch": "diff --git a/test/api/test_prepared_api.cpp b/test/api/test_prepared_api.cpp\nindex 5a8d86240fb3..74da545453bc 100644\n--- a/test/api/test_prepared_api.cpp\n+++ b/test/api/test_prepared_api.cpp\n@@ -456,3 +456,22 @@ TEST_CASE(\"Prepare all types of statements\", \"[prepared]\") {\n \t// TRANSACTION\n \tREQUIRE_NO_FAIL(TestExecutePrepared(con, \"COMMIT\"));\n }\n+\n+TEST_CASE(\"Test ambiguous prepared statement parameter types\", \"[api]\") {\n+\tunique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tresult = con.Query(\"SELECT ?\", 42);\n+\tREQUIRE(CHECK_COLUMN(result, 0, {42}));\n+\n+\tresult = con.Query(\"SELECT ?\", \"hello\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {\"hello\"}));\n+\n+\tauto prep = con.Prepare(\"SELECT ?\");\n+\tresult = prep->Execute(42);\n+\tREQUIRE(CHECK_COLUMN(result, 0, {42}));\n+\n+\tresult = prep->Execute(\"hello\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {\"hello\"}));\n+}\ndiff --git a/test/issues/fuzz/prepared_statement_crash.test b/test/issues/fuzz/prepared_statement_crash.test\nnew file mode 100644\nindex 000000000000..bea5df5ec2ab\n--- /dev/null\n+++ b/test/issues/fuzz/prepared_statement_crash.test\n@@ -0,0 +1,12 @@\n+# name: test/issues/fuzz/prepared_statement_crash.test\n+# description: Issue #3364: heap-use-after-free in duckdb::LogicalType::operator==(duckdb::LogicalType const&)\n+# group: [fuzz]\n+\n+statement ok\n+PREPARE s1 AS SELECT CAST(? AS INTEGER), CAST(? AS STRING);\n+\n+statement ok\n+SELECT MIN ( DISTINCT + CAST ( NULL AS INTEGER ) ) * COUNT ( * ) * - + 16 * CASE + + AVG ( ALL 97 ) WHEN ( + NULLIF ( SUM ( CAST ( NULL AS REAL ) ), 6 ) ) THEN 51 * 31 + - 6 WHEN + 48 * - 34 THEN NULL WHEN 91 * + ( SUM ( CAST ( NULL AS INTEGER ) ) ) THEN NULL END * - 4 + - 67;\n+\n+statement ok\n+EXECUTE s1(42, 'dpfkg');\ndiff --git a/test/issues/general/test_2416.test b/test/issues/general/test_2416.test\nindex c6a596291c5f..71740655d078 100644\n--- a/test/issues/general/test_2416.test\n+++ b/test/issues/general/test_2416.test\n@@ -83,9 +83,14 @@ EXECUTE v3(NULL)\n ----\n NULL\n \n-statement error\n+statement ok\n PREPARE v4 AS SELECT array_length($1)\n \n+query I\n+EXECUTE v4([1, 2, 3])\n+----\n+3\n+\n statement ok\n create macro array_l(my_arr) as array_length(my_arr);\n \ndiff --git a/test/sql/prepared/prepare_default_varchar.test b/test/sql/prepared/prepare_default_varchar.test\nindex 359b648a3f33..7a38cf484c7c 100644\n--- a/test/sql/prepared/prepare_default_varchar.test\n+++ b/test/sql/prepared/prepare_default_varchar.test\n@@ -38,10 +38,8 @@ EXECUTE v2('hello world', 'hello mars')\n ----\n false\n \n-query I\n+statement error\n EXECUTE v2([1, 2, 3], '[1, 2, 3]')\n-----\n-true\n \n # unbound parameter in scalar subquery\n statement ok\n@@ -121,14 +119,14 @@ EXECUTE v6(NULL)\n \n # unbound parameter with printf\n statement ok\n-PREPARE v7 AS SELECT printf('%s: %s', ?, ?)\n+PREPARE v7 AS SELECT printf('%s: %d', ?, ?)\n \n query I\n EXECUTE v7('time', 27)\n ----\n time: 27\n \n-query I\n+statement error\n EXECUTE v7('hello world', [1, 2, 3])\n ----\n hello world: [1, 2, 3]\ndiff --git a/test/sql/prepared/prepare_list_functions.test b/test/sql/prepared/prepare_list_functions.test\nnew file mode 100644\nindex 000000000000..cbedec09fb6d\n--- /dev/null\n+++ b/test/sql/prepared/prepare_list_functions.test\n@@ -0,0 +1,55 @@\n+# name: test/sql/prepared/prepare_list_functions.test\n+# description: PREPARE of various LIST functions\n+# group: [prepared]\n+\n+# list_aggregate\n+statement ok\n+PREPARE v1 AS SELECT list_aggregate(?, 'min')\n+\n+query I\n+EXECUTE v1([1, 2, 3])\n+----\n+1\n+\n+query I\n+EXECUTE v1(['hello', 'world'])\n+----\n+hello\n+\n+\n+query I\n+EXECUTE v1(NULL::INT[])\n+----\n+NULL\n+\n+# array_slice\n+statement ok\n+PREPARE v2 AS SELECT array_slice(?, 1, 2);\n+\n+query I\n+EXECUTE v2([1, 2, 3]);\n+----\n+[1, 2]\n+\n+query I\n+EXECUTE v2('123');\n+----\n+12\n+\n+# flatten\n+statement ok\n+PREPARE v3 AS SELECT flatten(?)\n+\n+query I\n+EXECUTE v3([[1,2,3],[4,5]]);\n+----\n+[1, 2, 3, 4, 5]\n+\n+# list_extract\n+statement ok\n+PREPARE v4 AS SELECT list_extract(?, 2)\n+\n+query I\n+EXECUTE v4([1, 2, 3]);\n+----\n+2\n\\ No newline at end of file\ndiff --git a/test/sql/prepared/prepare_window_functions.test b/test/sql/prepared/prepare_window_functions.test\nnew file mode 100644\nindex 000000000000..fe893007beaf\n--- /dev/null\n+++ b/test/sql/prepared/prepare_window_functions.test\n@@ -0,0 +1,24 @@\n+# name: test/sql/prepared/prepare_window_functions.test\n+# description: PREPARE of window functions\n+# group: [prepared]\n+\n+require vector_size 512\n+\n+# ambiguous window function usage\n+statement ok\n+PREPARE v1 AS SELECT SUM(?) OVER ()\n+\n+query I\n+EXECUTE v1(2)\n+----\n+2\n+\n+query I\n+EXECUTE v1(2::HUGEINT)\n+----\n+2\n+\n+query I\n+EXECUTE v1(0.5)\n+----\n+0.5\n\\ No newline at end of file\ndiff --git a/test/sql/prepared/test_prepare_ambiguous_type.test b/test/sql/prepared/test_prepare_ambiguous_type.test\nnew file mode 100644\nindex 000000000000..c05eb32ddb8f\n--- /dev/null\n+++ b/test/sql/prepared/test_prepare_ambiguous_type.test\n@@ -0,0 +1,296 @@\n+# name: test/sql/prepared/test_prepare_ambiguous_type.test\n+# description: PREPARE of ambiguous types\n+# group: [prepared]\n+\n+# typeof\n+statement ok\n+PREPARE v1 AS SELECT typeof(?)\n+\n+query I\n+EXECUTE v1(3::int)\n+----\n+INTEGER\n+\n+query I\n+EXECUTE v1('hello')\n+----\n+VARCHAR\n+\n+query I\n+EXECUTE v1([1, 2, 3])\n+----\n+INTEGER[]\n+\n+# direct select without cast\n+statement ok\n+PREPARE v2 AS SELECT ?\n+\n+query I\n+EXECUTE v2(3::int)\n+----\n+3\n+\n+query I\n+EXECUTE v2('hello')\n+----\n+hello\n+\n+query I\n+EXECUTE v2([1, 2, 3])\n+----\n+[1, 2, 3]\n+\n+# ambiguous comparison\n+statement ok\n+PREPARE v3 AS SELECT ?=?\n+\n+query I\n+EXECUTE v3(3::int, 4::bigint)\n+----\n+false\n+\n+query I\n+EXECUTE v3('hello', 'hello')\n+----\n+true\n+\n+query I\n+EXECUTE v3([1, 2, 3], [1, 2, 3])\n+----\n+true\n+\n+# ambiguous function usage (date_part)\n+statement ok\n+PREPARE v4 AS SELECT extract(year from ?)\n+\n+query I\n+EXECUTE v4(DATE '1992-01-01')\n+----\n+1992\n+\n+query I\n+EXECUTE v4(TIMESTAMP '1992-01-01 23:00:20')\n+----\n+1992\n+\n+# printf\n+statement ok\n+PREPARE v5 AS SELECT printf('%s', ?)\n+\n+statement error\n+EXECUTE v5(4)\n+\n+query I\n+EXECUTE v5('hello')\n+----\n+hello\n+\n+statement ok\n+PREPARE v6 AS SELECT printf('%d', ?)\n+\n+query I\n+EXECUTE v6(4)\n+----\n+4\n+\n+statement error\n+EXECUTE v6('hello')\n+\n+# lists and structs\n+statement ok\n+PREPARE v7 AS SELECT [?]\n+\n+query I\n+EXECUTE v7(1)\n+----\n+[1]\n+\n+query I\n+EXECUTE v7('hello')\n+----\n+[hello]\n+\n+query I\n+EXECUTE v7([1,2,3])\n+----\n+[[1, 2, 3]]\n+\n+\n+query I\n+EXECUTE v7(NULL)\n+----\n+[NULL]\n+\n+statement ok\n+PREPARE v8 AS SELECT [?, ?, ?]\n+\n+query I\n+EXECUTE v8(1, 2, 3)\n+----\n+[1, 2, 3]\n+\n+query I\n+EXECUTE v8(NULL, NULL, NULL)\n+----\n+[NULL, NULL, NULL]\n+\n+query I\n+EXECUTE v8('hello', 'world', NULL)\n+----\n+[hello, world, NULL]\n+\n+statement ok\n+PREPARE v9 AS SELECT {'a': ?}\n+\n+query I\n+EXECUTE v9(42)\n+----\n+{'a': 42}\n+\n+query I\n+EXECUTE v9([1,2,3])\n+----\n+{'a': [1, 2, 3]}\n+\n+query I\n+EXECUTE v9(NULL)\n+----\n+{'a': NULL}\n+\n+statement ok\n+PREPARE v10 AS SELECT {'a': ?, 'b': 42, 'c': ?}\n+\n+query I\n+EXECUTE v10(33, [1, 2, 3])\n+----\n+{'a': 33, 'b': 42, 'c': [1, 2, 3]}\n+\n+query I\n+EXECUTE v10(NULL, {'a': 88})\n+----\n+{'a': NULL, 'b': 42, 'c': {'a': 88}}\n+\n+statement ok\n+PREPARE v11 AS SELECT ROW(?, ?)\n+\n+query I\n+EXECUTE v11(11, 'hello')\n+----\n+{'v1': 11, 'v2': hello}\n+\n+statement ok\n+PREPARE v12 AS SELECT ? IS NULL\n+\n+query I\n+EXECUTE v12('hello')\n+----\n+false\n+\n+query I\n+EXECUTE v12([1, 2, 3])\n+----\n+false\n+\n+query I\n+EXECUTE v12(NULL)\n+----\n+true\n+\n+# subqueries\n+statement ok\n+PREPARE v13 AS SELECT (SELECT ?)\n+\n+query I\n+EXECUTE v13(3::int)\n+----\n+3\n+\n+query I\n+EXECUTE v13('hello')\n+----\n+hello\n+\n+query I\n+EXECUTE v13([1, 2, 3])\n+----\n+[1, 2, 3]\n+\n+\n+# ambiguous aggregate usage\n+statement ok\n+PREPARE v14 AS SELECT SUM(?) FROM RANGE(100)\n+\n+query I\n+EXECUTE v14(2)\n+----\n+200\n+\n+query I\n+EXECUTE v14(2::HUGEINT)\n+----\n+200\n+\n+query I\n+EXECUTE v14(0.005)\n+----\n+0.5\n+\n+# ambiguous function usage (addition)\n+statement ok\n+PREPARE v15 AS SELECT ?+?\n+\n+query I\n+EXECUTE v15(0.25, 0.25)\n+----\n+0.5\n+\n+query I\n+EXECUTE v15(1000000000000000000000000000000000000::hugeint, 1000000000000000000000000000000000000::hugeint)\n+----\n+2000000000000000000000000000000000000\n+\n+# array contains usage\n+statement ok\n+PREPARE v17 AS SELECT ARRAY_CONTAINS(?, ?)\n+\n+query I\n+EXECUTE v17([1, 2, 3], 1)\n+----\n+true\n+\n+query I\n+EXECUTE v17([], 1)\n+----\n+false\n+\n+query I\n+EXECUTE v17(['hello', NULL, 'world'], 'world')\n+----\n+true\n+\n+statement ok\n+PREPARE v18 AS SELECT ARRAY_CONTAINS([1, 2, 3], ?)\n+\n+query I\n+EXECUTE v18(1)\n+----\n+true\n+\n+query I\n+EXECUTE v18(0)\n+----\n+false\n+\n+statement error\n+EXECUTE v18([1])\n+\n+statement ok\n+PREPARE v19 AS SELECT ARRAY_CONTAINS(?, 1)\n+\n+query I\n+EXECUTE v19([1, 2, 3])\n+----\n+true\n+\n+statement error\n+EXECUTE v19(0)\ndiff --git a/tools/juliapkg/test/test_prepare.jl b/tools/juliapkg/test/test_prepare.jl\nindex 1edafd90afdc..67e14d1586ff 100644\n--- a/tools/juliapkg/test/test_prepare.jl\n+++ b/tools/juliapkg/test/test_prepare.jl\n@@ -86,3 +86,17 @@ end\n \n     DBInterface.close!(con)\n end\n+\n+@testset \"DBInterface.prepare: ambiguous parameters\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    stmt = DBInterface.prepare(con, \"SELECT ? AS a\")\n+    result = DataFrame(DBInterface.execute(stmt, [42]))\n+    @test isequal(result.a, [42])\n+\n+    result = DataFrame(DBInterface.execute(stmt, [\"hello world\"]))\n+    @test isequal(result.a, [\"hello world\"])\n+\n+    result = DataFrame(DBInterface.execute(stmt, [DateTime(1992, 9, 20, 23, 10, 33)]))\n+    @test isequal(result.a, [DateTime(1992, 9, 20, 23, 10, 33)])\n+end\ndiff --git a/tools/pythonpkg/tests/fast/test_ambiguous_prepare.py b/tools/pythonpkg/tests/fast/test_ambiguous_prepare.py\nnew file mode 100644\nindex 000000000000..b45c8be1cd0f\n--- /dev/null\n+++ b/tools/pythonpkg/tests/fast/test_ambiguous_prepare.py\n@@ -0,0 +1,12 @@\n+import duckdb\n+import pandas as pd\n+import pytest\n+\n+class TestAmbiguousPrepare(object):\n+    def test_bool(self, duckdb_cursor):\n+        conn = duckdb.connect()\n+        res = conn.execute(\"select ?, ?, ?\", (True, 42, [1, 2, 3])).fetchall()\n+        assert res[0][0] == True\n+        assert res[0][1] == 42\n+        assert res[0][2] == [1, 2, 3]\n+\ndiff --git a/tools/rpkg/tests/testthat/test_ambiguous_prepare.R b/tools/rpkg/tests/testthat/test_ambiguous_prepare.R\nnew file mode 100644\nindex 000000000000..eea0fbe2aaf2\n--- /dev/null\n+++ b/tools/rpkg/tests/testthat/test_ambiguous_prepare.R\n@@ -0,0 +1,10 @@\n+test_that(\"Test ambiguous prepare statements\", {\n+  con <- dbConnect(duckdb())\n+  on.exit(dbDisconnect(con, shutdown = TRUE))\n+\n+  res <- dbGetQuery(con, \"select ?\", 42)\n+  expect_identical(res[[1]], 42)\n+\n+  res <- dbGetQuery(con, \"select ?\", \"hello world\")\n+  expect_identical(res[[1]], \"hello world\")\n+})\n",
  "problem_statement": "R: Defer fixing parameter type\n**What does happen?**\r\n\r\nA certain type of parameterized query isn't yet supported, this causes a small subset of DBItest tests to fail.\r\n\r\n**What should happen?**\r\n\r\nFind a way to test the behavior, by implementing in DuckDB or by adapting DBItest.\r\n\r\n**To Reproduce**\r\n\r\n``` r\r\nlibrary(DBI)\r\n\r\ndrv1 <- duckdb::duckdb()\r\nconn1 <- dbConnect(drv1, debug = FALSE)\r\ndbGetQuery(conn1, \"SELECT CASE WHEN (? = 1) AND (? = 2) AND (? = 3) AND ((? IS NULL)) THEN 1.5 ELSE 2.5 END AS a\", params = list(1L, 2L, 3L, NA_integer_))\r\n#> Error in .local(conn, statement, ...): duckdb_prepare_R: Failed to prepare query SELECT CASE WHEN (? = 1) AND (? = 2) AND (? = 3) AND ((? IS NULL)) THEN 1.5 ELSE 2.5 END AS a\r\n#> Error: Binder Error: Could not determine type of parameters: try adding explicit type casts\r\ndbDisconnect(conn1)\r\n```\r\n\r\n<sup>Created on 2021-08-11 by the [reprex package](https://reprex.tidyverse.org) (v2.0.1)</sup>\r\n\r\n**Environment (please complete the following information):**\r\n - OS: macOS\r\n - DuckDB Version: 0.2.9\r\n\r\n**Before submitting**\r\n- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\nheap-use-after-free in duckdb::LogicalType::operator==(duckdb::LogicalType const&)\n#### What happens?\r\n```\r\nheap-use-after-free in duckdb::LogicalType::operator==(duckdb::LogicalType const&) const /root/duckdb/src/common/types.cpp:1388:6\r\n```\r\n\r\n#### To Reproduce\r\n```\r\nPREPARE s1 AS SELECT CAST(? AS INTEGER), CAST(? AS STRING);\r\nSELECT MIN ( DISTINCT + CAST ( NULL AS INTEGER ) ) * COUNT ( * ) * - + 16 * CASE + + AVG ( ALL 97 ) WHEN ( + NULLIF ( SUM ( CAST ( NULL AS REAL ) ), 6 ) ) THEN 51 * 31 + - 6 WHEN + 48 * - 34 THEN NULL WHEN 91 * + ( SUM ( CAST ( NULL AS INTEGER ) ) ) THEN NULL END * - 4 + - 67;\r\nEXECUTE s1(42, 'dpfkg');\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: linux\r\n - DuckDB Version: v0.3.3-dev1399 7c5ba6c0e\r\n - DuckDB Client: /usr/local/bin/duckdb\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\r\n#### ASAN detail\r\n```\r\n==61101==ERROR: AddressSanitizer: heap-use-after-free on address 0x60c0000193c0 at pc 0x0000036e5e2c bp 0x7fffa2af7e10 sp 0x7fffa2af7e08\r\nREAD of size 1 at 0x60c0000193c0 thread T0\r\n    #0 0x36e5e2b in duckdb::LogicalType::operator==(duckdb::LogicalType const&) const /root/duckdb/src/common/types.cpp:1388:6\r\n    #1 0x3a8046c in duckdb::ExpressionExecutor::Execute(duckdb::BoundParameterExpression const&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::Vector&) /root/duckdb/src/execution/expression_executor/execute_parameter.cpp:17:2\r\n    #2 0x44b2184 in duckdb::ExpressionExecutor::Execute(duckdb::Expression const&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::Vector&) /root/duckdb/src/execution/expression_executor.cpp:179:3\r\n    #3 0x44ad550 in duckdb::ExpressionExecutor::ExecuteExpression(unsigned long, duckdb::Vector&) /root/duckdb/src/execution/expression_executor.cpp:75:2\r\n    #4 0x44ac004 in duckdb::ExpressionExecutor::Execute(duckdb::DataChunk*, duckdb::DataChunk&) /root/duckdb/src/execution/expression_executor.cpp:46:3\r\n    #5 0x413d93c in duckdb::ExpressionExecutor::Execute(duckdb::DataChunk&, duckdb::DataChunk&) /root/duckdb/src/include/duckdb/execution/expression_executor.hpp:32:3\r\n    #6 0xa0d0f56 in duckdb::PhysicalProjection::Execute(duckdb::ExecutionContext&, duckdb::DataChunk&, duckdb::DataChunk&, duckdb::GlobalOperatorState&, duckdb::OperatorState&) const /root/duckdb/src/execution/operator/projection/physical_projection.cpp:29:17\r\n    #7 0x4a523ef in duckdb::PipelineExecutor::Execute(duckdb::DataChunk&, duckdb::DataChunk&, unsigned long) /root/duckdb/src/parallel/pipeline_executor.cpp:275:36\r\n    #8 0x4a2ff57 in duckdb::PipelineExecutor::ExecutePull(duckdb::DataChunk&) /root/duckdb/src/parallel/pipeline_executor.cpp:200:5\r\n    #9 0x4a2e480 in duckdb::Executor::FetchChunk() /root/duckdb/src/parallel/executor.cpp:729:18\r\n    #10 0x46eab4d in duckdb::ClientContext::FetchInternal(duckdb::ClientContextLock&, duckdb::Executor&, duckdb::BaseQueryResult&) /root/duckdb/src/main/client_context.cpp:96:25\r\n    #11 0x46ea4e2 in duckdb::ClientContext::Fetch(duckdb::ClientContextLock&, duckdb::StreamQueryResult&) /root/duckdb/src/main/client_context.cpp:88:9\r\n    #12 0x4798d50 in duckdb::StreamQueryResult::FetchRaw() /root/duckdb/src/main/stream_query_result.cpp:47:20\r\n    #13 0x47867b7 in duckdb::QueryResult::Fetch() /root/duckdb/src/main/query_result.cpp:50:15\r\n    #14 0x1cdb59e in duckdb::QueryResult::TryFetch(std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) /root/duckdb/src/include/duckdb/main/query_result.hpp:85:13\r\n    #15 0x1cd819c in sqlite3_step /root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:229:23\r\n    #16 0x1c900ea in exec_prepared_stmt_columnar /root/duckdb/tools/shell/shell.c:12710:8\r\n    #17 0x1c8bd27 in exec_prepared_stmt /root/duckdb/tools/shell/shell.c:12886:5\r\n    #18 0x1b7f8b3 in shell_exec /root/duckdb/tools/shell/shell.c:13204:7\r\n    #19 0x1ca01d5 in runOneSqlLine /root/duckdb/tools/shell/shell.c:19991:8\r\n    #20 0x1b85691 in process_input /root/duckdb/tools/shell/shell.c:20106:17\r\n    #21 0x1b1d1db in main /root/duckdb/tools/shell/shell.c:20908:12\r\n    #22 0x7fb79fd590b2 in __libc_start_main /build/glibc-sMfBJT/glibc-2.31/csu/../csu/libc-start.c:308:16\r\n    #23 0x1a379fd in _start (/root/bld_asan_debug/duckdb+0x1a379fd)\r\n\r\n0x60c0000193c0 is located 0 bytes inside of 128-byte region [0x60c0000193c0,0x60c000019440)\r\nfreed by thread T0 here:\r\n    #0 0x1ae457d in operator delete(void*) (/root/bld_asan_debug/duckdb+0x1ae457d)\r\n    #1 0x47a474a in std::default_delete<duckdb::Value>::operator()(duckdb::Value*) const /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:81:2\r\n    #2 0x47a416a in std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >::~unique_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:292:4\r\n    #3 0x47a3da0 in void std::_Destroy<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > >(std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:98:19\r\n    #4 0x47a3bca in void std::_Destroy_aux<false>::__destroy<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >*>(std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >*, std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:108:6\r\n    #5 0x47a3af4 in void std::_Destroy<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >*>(std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >*, std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:136:7\r\n    #6 0x47a33dc in void std::_Destroy<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >*, std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > >(std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >*, std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >*, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > >&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:206:7\r\n    #7 0x47a32db in std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > >::~vector() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:677:2\r\n    #8 0x47a2e3c in std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >::~pair() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_pair.h:208:12\r\n    #9 0x47a2d4e in void __gnu_cxx::new_allocator<std::__detail::_Hash_node<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >, false> >::destroy<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > > >(std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/ext/new_allocator.h:152:10\r\n    #10 0x47a2916 in void std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >, false> > >::destroy<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > > >(std::allocator<std::__detail::_Hash_node<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >, false> >&, std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/alloc_traits.h:496:8\r\n    #11 0x47a2827 in std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >, false> > >::_M_deallocate_node(std::__detail::_Hash_node<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >, false>*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:2102:7\r\n    #12 0x47a18e7 in std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >, false> > >::_M_deallocate_nodes(std::__detail::_Hash_node<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >, false>*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable_policy.h:2124:4\r\n    #13 0x47f8576 in std::_Hashtable<unsigned long, std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >, std::allocator<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::clear() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable.h:2063:13\r\n    #14 0x47f83b8 in std::_Hashtable<unsigned long, std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > >, std::allocator<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > > >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::~_Hashtable() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/hashtable.h:1387:7\r\n    #15 0x474e2b8 in std::unordered_map<unsigned long, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > >, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<unsigned long const, std::vector<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> >, std::allocator<std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > > > > > >::~unordered_map() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unordered_map.h:102:11\r\n    #16 0x474e1b6 in duckdb::PreparedStatementData::~PreparedStatementData() /root/duckdb/src/main/prepared_statement_data.cpp:12:1\r\n    #17 0x487c9ee in void __gnu_cxx::new_allocator<duckdb::PreparedStatementData>::destroy<duckdb::PreparedStatementData>(duckdb::PreparedStatementData*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/ext/new_allocator.h:152:10\r\n    #18 0x487c686 in void std::allocator_traits<std::allocator<duckdb::PreparedStatementData> >::destroy<duckdb::PreparedStatementData>(std::allocator<duckdb::PreparedStatementData>&, duckdb::PreparedStatementData*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/alloc_traits.h:496:8\r\n    #19 0x487b735 in std::_Sp_counted_ptr_inplace<duckdb::PreparedStatementData, std::allocator<duckdb::PreparedStatementData>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:557:2\r\n    #20 0x1d0b943 in std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:155:6\r\n    #21 0x1d0b5fc in std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:730:11\r\n    #22 0x380edbc in std::__shared_ptr<duckdb::PreparedStatementData, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:1169:31\r\n    #23 0x46fa8c8 in std::shared_ptr<duckdb::PreparedStatementData>::~shared_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr.h:103:11\r\n    #24 0x5da2406 in duckdb::Planner::PlanExecute(std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/planner/planner.cpp:126:1\r\n    #25 0x5d9e1a5 in duckdb::Planner::CreatePlan(std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/planner/planner.cpp:168:3\r\n    #26 0x4612bee in duckdb::ClientContext::CreatePreparedStatement(duckdb::ClientContextLock&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/main/client_context.cpp:251:10\r\n    #27 0x4881efc in duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >)::$_1::operator()() const /root/duckdb/src/main/client_context.cpp:416:36\r\n    #28 0x488103c in std::_Function_handler<void (), duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >)::$_1>::_M_invoke(std::_Any_data const&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/std_function.h:300:2\r\n    #29 0x4714e43 in std::function<void ()>::operator()() const /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/std_function.h:688:14\r\n\r\npreviously allocated by thread T0 here:\r\n    #0 0x1ae3d1d in operator new(unsigned long) (/root/bld_asan_debug/duckdb+0x1ae3d1d)\r\n    #1 0x5d9a03a in std::unique_ptr<duckdb::Value, std::default_delete<duckdb::Value> > duckdb::make_unique<duckdb::Value, duckdb::LogicalType&>(duckdb::LogicalType&) /root/duckdb/src/include/duckdb/common/helper.hpp:41:23\r\n    #2 0x5d97c06 in duckdb::Planner::CreatePlan(duckdb::SQLStatement&) /root/duckdb/src/planner/planner.cpp:47:16\r\n    #3 0x5d9e0a8 in duckdb::Planner::CreatePlan(std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/planner/planner.cpp:165:3\r\n    #4 0x5d9bcb8 in duckdb::Planner::PrepareSQLStatement(std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/planner/planner.cpp:64:2\r\n    #5 0x5da011f in duckdb::Planner::PlanExecute(std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/planner/planner.cpp:94:14\r\n    #6 0x5d9e1a5 in duckdb::Planner::CreatePlan(std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/planner/planner.cpp:168:3\r\n    #7 0x4612bee in duckdb::ClientContext::CreatePreparedStatement(duckdb::ClientContextLock&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/main/client_context.cpp:251:10\r\n    #8 0x4881efc in duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >)::$_1::operator()() const /root/duckdb/src/main/client_context.cpp:416:36\r\n    #9 0x488103c in std::_Function_handler<void (), duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >)::$_1>::_M_invoke(std::_Any_data const&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/std_function.h:300:2\r\n    #10 0x4714e43 in std::function<void ()>::operator()() const /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/std_function.h:688:14\r\n    #11 0x47054ce in duckdb::ClientContext::RunFunctionInTransactionInternal(duckdb::ClientContextLock&, std::function<void ()> const&, bool) /root/duckdb/src/main/client_context.cpp:939:3\r\n    #12 0x4706b37 in duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/main/client_context.cpp:415:2\r\n    #13 0x47083fa in duckdb::ClientContext::Prepare(std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/main/client_context.cpp:426:10\r\n    #14 0x4728d33 in duckdb::Connection::Prepare(std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/main/connection.cpp:95:18\r\n    #15 0x1cd10c9 in sqlite3_prepare_v2 /root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:164:28\r\n    #16 0x1b7cd09 in shell_exec /root/duckdb/tools/shell/shell.c:13110:10\r\n    #17 0x1ca01d5 in runOneSqlLine /root/duckdb/tools/shell/shell.c:19991:8\r\n    #18 0x1b85691 in process_input /root/duckdb/tools/shell/shell.c:20106:17\r\n    #19 0x1b1d1db in main /root/duckdb/tools/shell/shell.c:20908:12\r\n    #20 0x7fb79fd590b2 in __libc_start_main /build/glibc-sMfBJT/glibc-2.31/csu/../csu/libc-start.c:308:16\r\n\r\nSUMMARY: AddressSanitizer: heap-use-after-free /root/duckdb/src/common/types.cpp:1388:6 in duckdb::LogicalType::operator==(duckdb::LogicalType const&) const\r\nShadow bytes around the buggy address:\r\n  0x0c187fffb220: fd fd fd fd fd fd fd fd fa fa fa fa fa fa fa fa\r\n  0x0c187fffb230: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\n  0x0c187fffb240: fa fa fa fa fa fa fa fa fd fd fd fd fd fd fd fd\r\n  0x0c187fffb250: fd fd fd fd fd fd fd fd fa fa fa fa fa fa fa fa\r\n  0x0c187fffb260: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n=>0x0c187fffb270: fa fa fa fa fa fa fa fa[fd]fd fd fd fd fd fd fd\r\n  0x0c187fffb280: fd fd fd fd fd fd fd fd fa fa fa fa fa fa fa fa\r\n  0x0c187fffb290: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\n  0x0c187fffb2a0: fa fa fa fa fa fa fa fa fd fd fd fd fd fd fd fd\r\n  0x0c187fffb2b0: fd fd fd fd fd fd fd fd fa fa fa fa fa fa fa fa\r\n  0x0c187fffb2c0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07 \r\n  Heap left redzone:       fa\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n  Left alloca redzone:     ca\r\n  Right alloca redzone:    cb\r\n  Shadow gap:              cc\r\n==61101==ABORTING\r\n```\r\n\n",
  "hints_text": "The problem here is as indicated by the error, the type of one of the parameters could not be determined (although the error should be extended to specify which one!). The problem is specifically this clause:\r\n\r\n```sql\r\n(? IS NULL)\r\n```\r\n\r\nNow this parameter could be any type, as `IS NULL` can be used with varchars, integers, lists, etc.\r\n\r\nNote that Postgres gives us the exact same error:\r\n\r\n```sql\r\nPREPARE v1 AS SELECT CASE WHEN ($1 = 1) AND ($2 = 2) AND ($3 = 3) AND (($4 IS NULL)) THEN 1.5 ELSE 2.5 END AS a;\r\n-- ERROR:  could not determine data type of parameter $4\r\n```\r\n\r\nSince DuckDB is a strongly typed engine (like Postgres) we need to know the column types during the binding phase, which for a prepared statement happens once during the prepare phase. This is by design since we want to avoid re-binding for every execute. \r\n\r\nOne possible solution would be to add a fallback here to a `VARCHAR` type in the general case, since every type can be cast to VARCHAR this would generally achieve the expected result, although perhaps this would lead to unexpected behavior in some cases.\r\n\r\nIn any case the error should be improved.\nAfter some discussion we are going to implement the fallback to VARCHAR in case the type could not be determined.\nThanks.\r\n\r\nI can split the tests so that the `IS NULL` test is separated from the other values.\r\n\r\nAFAICT the same tests succeeds in RPostgres, but we're not using an explicit `PREPARE` there. Need to double-check what happens there.\nThis should be fixed in the master now.\n",
  "created_at": "2022-04-04T09:30:57Z"
}