diff --git a/extension/icu/icu-dateadd.cpp b/extension/icu/icu-dateadd.cpp
index 2fd4a1e62036..c91827b44944 100644
--- a/extension/icu/icu-dateadd.cpp
+++ b/extension/icu/icu-dateadd.cpp
@@ -88,7 +88,7 @@ interval_t ICUCalendarSub::Operation(timestamp_t end_date, timestamp_t start_dat
 
 	// Borrow 1ms from end_date if we wrap. This works because start_date <= end_date
 	// and if the µs are out of order, then there must be an extra ms.
-	if (start_micros > (idx_t) end_micros) {
+	if (start_micros > (idx_t)end_micros) {
 		end_date.value -= Interval::MICROS_PER_MSEC;
 		end_micros += Interval::MICROS_PER_MSEC;
 	}
@@ -120,7 +120,7 @@ interval_t ICUCalendarAge::Operation(timestamp_t end_date, timestamp_t start_dat
 
 	// Borrow 1ms from end_date if we wrap. This works because start_date <= end_date
 	// and if the µs are out of order, then there must be an extra ms.
-	if (start_micros > (idx_t) end_micros) {
+	if (start_micros > (idx_t)end_micros) {
 		end_date.value -= Interval::MICROS_PER_MSEC;
 		end_micros += Interval::MICROS_PER_MSEC;
 	}
@@ -178,7 +178,7 @@ struct ICUDateAdd : public ICUDateFunc {
 	template <typename TA, typename TB, typename TR, typename OP>
 	inline static ScalarFunction GetBinaryDateFunction(const LogicalTypeId &left_type, const LogicalTypeId &right_type,
 	                                                   const LogicalTypeId &result_type) {
-		return ScalarFunction({left_type, right_type}, result_type, ExecuteBinary<TA, TB, TR, OP>,false, false, Bind);
+		return ScalarFunction({left_type, right_type}, result_type, ExecuteBinary<TA, TB, TR, OP>, false, false, Bind);
 	}
 
 	template <typename TA, typename TB, typename OP>
diff --git a/extension/icu/icu-strptime.cpp b/extension/icu/icu-strptime.cpp
index da2e5c485606..6f7b41227fee 100644
--- a/extension/icu/icu-strptime.cpp
+++ b/extension/icu/icu-strptime.cpp
@@ -132,7 +132,8 @@ struct ICUStrptime : public ICUDateFunc {
 		auto &func = (ScalarFunctionCatalogEntry &)*entry;
 		vector<LogicalType> types {LogicalType::VARCHAR, LogicalType::VARCHAR};
 		string error;
-		const idx_t best_function = Function::BindFunction(func.name, func.functions, types, error);
+		bool cast_parameters;
+		const idx_t best_function = Function::BindFunction(func.name, func.functions, types, error, cast_parameters);
 		if (best_function == DConstants::INVALID_INDEX) {
 			return;
 		}
diff --git a/src/common/symbols.cpp b/src/common/symbols.cpp
index 515cfcd7e548..f1466e1a4581 100644
--- a/src/common/symbols.cpp
+++ b/src/common/symbols.cpp
@@ -150,6 +150,7 @@ INSTANTIATE_VECTOR(std::vector<OrderByNode>)
 template class std::vector<uint64_t>;
 template class std::vector<string>;
 INSTANTIATE_VECTOR(std::vector<Expression *>)
+INSTANTIATE_VECTOR(std::vector<BoundParameterExpression *>)
 INSTANTIATE_VECTOR(std::vector<std::unique_ptr<Expression>>)
 INSTANTIATE_VECTOR(std::vector<std::unique_ptr<DataChunk>>)
 INSTANTIATE_VECTOR(std::vector<std::unique_ptr<SQLStatement>>)
diff --git a/src/execution/physical_plan/plan_execute.cpp b/src/execution/physical_plan/plan_execute.cpp
index 0b6f5b7520c9..bd96b89456d7 100644
--- a/src/execution/physical_plan/plan_execute.cpp
+++ b/src/execution/physical_plan/plan_execute.cpp
@@ -5,8 +5,17 @@
 namespace duckdb {
 
 unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalExecute &op) {
-	D_ASSERT(op.children.size() == 0);
-	return make_unique<PhysicalExecute>(op.prepared->plan.get());
+	if (!op.prepared->plan) {
+		D_ASSERT(op.children.size() == 1);
+		auto owned_plan = CreatePlan(*op.children[0]);
+		auto execute = make_unique<PhysicalExecute>(owned_plan.get());
+		execute->owned_plan = move(owned_plan);
+		execute->prepared = move(op.prepared);
+		return move(execute);
+	} else {
+		D_ASSERT(op.children.size() == 0);
+		return make_unique<PhysicalExecute>(op.prepared->plan.get());
+	}
 }
 
 } // namespace duckdb
diff --git a/src/function/cast_rules.cpp b/src/function/cast_rules.cpp
index 6addf93c608b..a656b40844c4 100644
--- a/src/function/cast_rules.cpp
+++ b/src/function/cast_rules.cpp
@@ -194,10 +194,14 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)
 		// anything can be cast to ANY type for no cost
 		return 0;
 	}
-	if (from.id() == LogicalTypeId::SQLNULL || from.id() == LogicalTypeId::UNKNOWN) {
-		// NULL expression or parameter expression can be cast to anything
+	if (from.id() == LogicalTypeId::SQLNULL) {
+		// NULL expression can be cast to anything
 		return TargetTypeCost(to);
 	}
+	if (from.id() == LogicalTypeId::UNKNOWN) {
+		// parameter expression can be cast to anything for no cost
+		return 0;
+	}
 	if (from.id() == LogicalTypeId::BLOB && to.id() == LogicalTypeId::VARCHAR) {
 		// Implicit cast not allowed from BLOB to VARCHAR
 		return -1;
diff --git a/src/function/function.cpp b/src/function/function.cpp
index 6f58518f1377..ecb8832203b7 100644
--- a/src/function/function.cpp
+++ b/src/function/function.cpp
@@ -275,11 +275,11 @@ static int64_t BindFunctionCost(SimpleFunction &func, vector<LogicalType> &argum
 }
 
 template <class T>
-static idx_t BindFunctionFromArguments(const string &name, vector<T> &functions, vector<LogicalType> &arguments,
-                                       string &error) {
+static vector<idx_t> BindFunctionsFromArguments(const string &name, vector<T> &functions,
+                                                vector<LogicalType> &arguments, string &error) {
 	idx_t best_function = DConstants::INVALID_INDEX;
 	int64_t lowest_cost = NumericLimits<int64_t>::Maximum();
-	vector<idx_t> conflicting_functions;
+	vector<idx_t> candidate_functions;
 	for (idx_t f_idx = 0; f_idx < functions.size(); f_idx++) {
 		auto &func = functions[f_idx];
 		// check the arguments of the function
@@ -289,32 +289,16 @@ static idx_t BindFunctionFromArguments(const string &name, vector<T> &functions,
 			continue;
 		}
 		if (cost == lowest_cost) {
-			conflicting_functions.push_back(f_idx);
+			candidate_functions.push_back(f_idx);
 			continue;
 		}
 		if (cost > lowest_cost) {
 			continue;
 		}
-		conflicting_functions.clear();
+		candidate_functions.clear();
 		lowest_cost = cost;
 		best_function = f_idx;
 	}
-	if (!conflicting_functions.empty()) {
-		// there are multiple possible function definitions
-		// throw an exception explaining which overloads are there
-		conflicting_functions.push_back(best_function);
-		string call_str = Function::CallToString(name, arguments);
-		string candidate_str = "";
-		for (auto &conf : conflicting_functions) {
-			auto &f = functions[conf];
-			candidate_str += "\t" + f.ToString() + "
";
-		}
-		error =
-		    StringUtil::Format("Could not choose a best candidate function for the function call \"%s\". In order to "
-		                       "select one, please add explicit type casts.
\tCandidate functions:
%s",
-		                       call_str, candidate_str);
-		return DConstants::INVALID_INDEX;
-	}
 	if (best_function == DConstants::INVALID_INDEX) {
 		// no matching function was found, throw an error
 		string call_str = Function::CallToString(name, arguments);
@@ -325,24 +309,77 @@ static idx_t BindFunctionFromArguments(const string &name, vector<T> &functions,
 		error = StringUtil::Format("No function matches the given name and argument types '%s'. You might need to add "
 		                           "explicit type casts.
\tCandidate functions:
%s",
 		                           call_str, candidate_str);
+		return candidate_functions;
+	}
+	candidate_functions.push_back(best_function);
+	return candidate_functions;
+}
+
+template <class T>
+static idx_t MultipleCandidateException(const string &name, vector<T> &functions, vector<idx_t> &candidate_functions,
+                                        vector<LogicalType> &arguments, string &error) {
+	D_ASSERT(functions.size() > 1);
+	// there are multiple possible function definitions
+	// throw an exception explaining which overloads are there
+	string call_str = Function::CallToString(name, arguments);
+	string candidate_str = "";
+	for (auto &conf : candidate_functions) {
+		auto &f = functions[conf];
+		candidate_str += "\t" + f.ToString() + "
";
+	}
+	error = StringUtil::Format("Could not choose a best candidate function for the function call \"%s\". In order to "
+	                           "select one, please add explicit type casts.
\tCandidate functions:
%s",
+	                           call_str, candidate_str);
+	return DConstants::INVALID_INDEX;
+}
+
+template <class T>
+static idx_t BindFunctionFromArguments(const string &name, vector<T> &functions, vector<LogicalType> &arguments,
+                                       string &error, bool &cast_parameters) {
+	auto candidate_functions = BindFunctionsFromArguments<T>(name, functions, arguments, error);
+	if (candidate_functions.empty()) {
+		// no candidates
 		return DConstants::INVALID_INDEX;
 	}
-	return best_function;
+	cast_parameters = true;
+	if (candidate_functions.size() > 1) {
+		// multiple candidates, check if there are any unknown arguments
+		bool has_parameters = false;
+		for (auto &arg_type : arguments) {
+			if (arg_type.id() == LogicalTypeId::UNKNOWN) {
+				//! there are! disable casting of parameters, but do not throw an error
+				cast_parameters = false;
+				has_parameters = true;
+				break;
+			}
+		}
+		if (!has_parameters) {
+			return MultipleCandidateException(name, functions, candidate_functions, arguments, error);
+		}
+	}
+	return candidate_functions[0];
 }
 
 idx_t Function::BindFunction(const string &name, vector<ScalarFunction> &functions, vector<LogicalType> &arguments,
-                             string &error) {
-	return BindFunctionFromArguments(name, functions, arguments, error);
+                             string &error, bool &cast_parameters) {
+	return BindFunctionFromArguments(name, functions, arguments, error, cast_parameters);
+}
+
+idx_t Function::BindFunction(const string &name, vector<AggregateFunction> &functions, vector<LogicalType> &arguments,
+                             string &error, bool &cast_parameters) {
+	return BindFunctionFromArguments(name, functions, arguments, error, cast_parameters);
 }
 
 idx_t Function::BindFunction(const string &name, vector<AggregateFunction> &functions, vector<LogicalType> &arguments,
                              string &error) {
-	return BindFunctionFromArguments(name, functions, arguments, error);
+	bool cast_parameters;
+	return BindFunction(name, functions, arguments, error, cast_parameters);
 }
 
 idx_t Function::BindFunction(const string &name, vector<TableFunction> &functions, vector<LogicalType> &arguments,
                              string &error) {
-	return BindFunctionFromArguments(name, functions, arguments, error);
+	bool cast_parameters;
+	return BindFunctionFromArguments(name, functions, arguments, error, cast_parameters);
 }
 
 idx_t Function::BindFunction(const string &name, vector<PragmaFunction> &functions, PragmaInfo &info, string &error) {
@@ -350,7 +387,8 @@ idx_t Function::BindFunction(const string &name, vector<PragmaFunction> &functio
 	for (auto &value : info.parameters) {
 		types.push_back(value.type());
 	}
-	idx_t entry = BindFunctionFromArguments(name, functions, types, error);
+	bool cast_parameters;
+	idx_t entry = BindFunctionFromArguments(name, functions, types, error, cast_parameters);
 	if (entry == DConstants::INVALID_INDEX) {
 		throw BinderException(error);
 	}
@@ -374,9 +412,9 @@ vector<LogicalType> GetLogicalTypesFromExpressions(vector<unique_ptr<Expression>
 }
 
 idx_t Function::BindFunction(const string &name, vector<ScalarFunction> &functions,
-                             vector<unique_ptr<Expression>> &arguments, string &error) {
+                             vector<unique_ptr<Expression>> &arguments, string &error, bool &cast_parameters) {
 	auto types = GetLogicalTypesFromExpressions(arguments);
-	return Function::BindFunction(name, functions, types, error);
+	return Function::BindFunction(name, functions, types, error, cast_parameters);
 }
 
 idx_t Function::BindFunction(const string &name, vector<AggregateFunction> &functions,
@@ -406,23 +444,21 @@ LogicalTypeComparisonResult RequiresCast(const LogicalType &source_type, const L
 	return LogicalTypeComparisonResult::DIFFERENT_TYPES;
 }
 
-void BaseScalarFunction::CastToFunctionArguments(vector<unique_ptr<Expression>> &children) {
+void BaseScalarFunction::CastToFunctionArguments(vector<unique_ptr<Expression>> &children,
+                                                 bool cast_parameter_expressions) {
 	for (idx_t i = 0; i < children.size(); i++) {
 		auto target_type = i < this->arguments.size() ? this->arguments[i] : this->varargs;
 		target_type.Verify();
+		// check if the source type is a paramter, and we have disabled casting of parameters
+		if (children[i]->return_type.id() == LogicalTypeId::UNKNOWN && !cast_parameter_expressions) {
+			continue;
+		}
 		// check if the type of child matches the type of function argument
 		// if not we need to add a cast
 		auto cast_result = RequiresCast(children[i]->return_type, target_type);
 		// except for one special case: if the function accepts ANY argument
 		// in that case we don't add a cast
-		if (cast_result == LogicalTypeComparisonResult::TARGET_IS_ANY) {
-			if (children[i]->return_type.id() == LogicalTypeId::UNKNOWN) {
-				// UNLESS the child is a prepared statement parameter
-				// in that case we default the prepared statement parameter to VARCHAR
-				children[i]->return_type =
-				    ExpressionBinder::ExchangeType(target_type, LogicalTypeId::ANY, LogicalType::VARCHAR);
-			}
-		} else if (cast_result == LogicalTypeComparisonResult::DIFFERENT_TYPES) {
+		if (cast_result == LogicalTypeComparisonResult::DIFFERENT_TYPES) {
 			children[i] = BoundCastExpression::AddCastToType(move(children[i]), target_type);
 		}
 	}
@@ -444,25 +480,27 @@ unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientCon
                                                                        vector<unique_ptr<Expression>> children,
                                                                        string &error, bool is_operator) {
 	// bind the function
-	idx_t best_function = Function::BindFunction(func.name, func.functions, children, error);
+	bool cast_parameters;
+	idx_t best_function = Function::BindFunction(func.name, func.functions, children, error, cast_parameters);
 	if (best_function == DConstants::INVALID_INDEX) {
 		return nullptr;
 	}
+
 	// found a matching function!
 	auto &bound_function = func.functions[best_function];
-	return ScalarFunction::BindScalarFunction(context, bound_function, move(children), is_operator);
+	return ScalarFunction::BindScalarFunction(context, bound_function, move(children), is_operator, cast_parameters);
 }
 
 unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientContext &context,
                                                                        ScalarFunction bound_function,
                                                                        vector<unique_ptr<Expression>> children,
-                                                                       bool is_operator) {
+                                                                       bool is_operator, bool cast_parameters) {
 	unique_ptr<FunctionData> bind_info;
 	if (bound_function.bind) {
 		bind_info = bound_function.bind(context, bound_function, children);
 	}
 	// check if we need to add casts to the children
-	bound_function.CastToFunctionArguments(children);
+	bound_function.CastToFunctionArguments(children, cast_parameters);
 
 	// now create the function
 	auto return_type = bound_function.return_type;
@@ -470,10 +508,9 @@ unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientCon
 	                                            move(bind_info), is_operator);
 }
 
-unique_ptr<BoundAggregateExpression>
-AggregateFunction::BindAggregateFunction(ClientContext &context, AggregateFunction bound_function,
-                                         vector<unique_ptr<Expression>> children, unique_ptr<Expression> filter,
-                                         bool is_distinct, unique_ptr<BoundOrderModifier> order_bys) {
+unique_ptr<BoundAggregateExpression> AggregateFunction::BindAggregateFunction(
+    ClientContext &context, AggregateFunction bound_function, vector<unique_ptr<Expression>> children,
+    unique_ptr<Expression> filter, bool is_distinct, unique_ptr<BoundOrderModifier> order_bys, bool cast_parameters) {
 	unique_ptr<FunctionData> bind_info;
 	if (bound_function.bind) {
 		bind_info = bound_function.bind(context, bound_function, children);
@@ -482,7 +519,7 @@ AggregateFunction::BindAggregateFunction(ClientContext &context, AggregateFuncti
 	}
 
 	// check if we need to add casts to the children
-	bound_function.CastToFunctionArguments(children);
+	bound_function.CastToFunctionArguments(children, cast_parameters);
 
 	// Special case: for ORDER BY aggregates, we wrap the aggregate function in a SortedAggregateFunction
 	// The children are the sort clauses and the binding contains the ordering data.
diff --git a/src/function/scalar/list/array_slice.cpp b/src/function/scalar/list/array_slice.cpp
index ae85ba11723e..4c3440216075 100644
--- a/src/function/scalar/list/array_slice.cpp
+++ b/src/function/scalar/list/array_slice.cpp
@@ -184,6 +184,10 @@ static unique_ptr<FunctionData> ArraySliceBind(ClientContext &context, ScalarFun
 		bound_function.arguments[1] = LogicalType::INTEGER;
 		bound_function.arguments[2] = LogicalType::INTEGER;
 		break;
+	case LogicalTypeId::UNKNOWN:
+		bound_function.arguments[0] = LogicalTypeId::UNKNOWN;
+		bound_function.return_type = LogicalType::SQLNULL;
+		break;
 	default:
 		throw BinderException("ARRAY_SLICE can only operate on LISTs and VARCHARs");
 	}
diff --git a/src/function/scalar/list/contains_or_position.cpp b/src/function/scalar/list/contains_or_position.cpp
index f10dcaa5a71b..8fbfbcc2a4cb 100644
--- a/src/function/scalar/list/contains_or_position.cpp
+++ b/src/function/scalar/list/contains_or_position.cpp
@@ -179,10 +179,22 @@ static unique_ptr<FunctionData> ListContainsOrPositionBind(ClientContext &contex
 		bound_function.arguments[0] = list;
 		bound_function.arguments[1] = value;
 		bound_function.return_type = LogicalTypeId::SQLNULL;
+	} else if (list.id() == LogicalTypeId::UNKNOWN) {
+		bound_function.return_type = RETURN_TYPE;
+		if (value.id() != LogicalTypeId::UNKNOWN) {
+			// only list is a parameter, cast it to a list of value type
+			bound_function.arguments[0] = LogicalType::LIST(value);
+			bound_function.arguments[1] = value;
+		}
+	} else if (value.id() == LogicalTypeId::UNKNOWN) {
+		// only value is a parameter: we expect the child type of list
+		auto const &child_type = ListType::GetChildType(list);
+		bound_function.arguments[0] = list;
+		bound_function.arguments[1] = child_type;
+		bound_function.return_type = RETURN_TYPE;
 	} else {
-		auto const &child_type = ListType::GetChildType(arguments[0]->return_type);
+		auto const &child_type = ListType::GetChildType(list);
 		auto max_child_type = LogicalType::MaxLogicalType(child_type, value);
-		ExpressionBinder::ResolveParameterType(max_child_type);
 		auto list_type = LogicalType::LIST(max_child_type);
 
 		bound_function.arguments[0] = list_type;
diff --git a/src/function/scalar/list/flatten.cpp b/src/function/scalar/list/flatten.cpp
index 421acf09dd99..7c7afd853c96 100644
--- a/src/function/scalar/list/flatten.cpp
+++ b/src/function/scalar/list/flatten.cpp
@@ -97,6 +97,11 @@ static unique_ptr<FunctionData> ListFlattenBind(ClientContext &context, ScalarFu
 		bound_function.return_type = LogicalType(LogicalTypeId::SQLNULL);
 		return make_unique<VariableReturnBindData>(bound_function.return_type);
 	}
+	if (input_type.id() == LogicalTypeId::UNKNOWN) {
+		bound_function.arguments[0] = LogicalType(LogicalTypeId::UNKNOWN);
+		bound_function.return_type = LogicalType(LogicalTypeId::SQLNULL);
+		return nullptr;
+	}
 	D_ASSERT(input_type.id() == LogicalTypeId::LIST);
 
 	auto child_type = ListType::GetChildType(input_type);
diff --git a/src/function/scalar/list/list_aggregates.cpp b/src/function/scalar/list/list_aggregates.cpp
index 6bd769877587..618238f7de25 100644
--- a/src/function/scalar/list/list_aggregates.cpp
+++ b/src/function/scalar/list/list_aggregates.cpp
@@ -165,8 +165,8 @@ static unique_ptr<FunctionData> ListAggregateBind(ClientContext &context, Scalar
 		return make_unique<VariableReturnBindData>(bound_function.return_type);
 	}
 
-	D_ASSERT(LogicalTypeId::LIST == arguments[0]->return_type.id());
-	auto list_child_type = ListType::GetChildType(arguments[0]->return_type);
+	bool is_parameter = arguments[0]->return_type.id() == LogicalTypeId::UNKNOWN;
+	auto list_child_type = is_parameter ? LogicalTypeId::UNKNOWN : ListType::GetChildType(arguments[0]->return_type);
 	bound_function.return_type = list_child_type;
 
 	if (!arguments[1]->IsFoldable()) {
@@ -182,8 +182,7 @@ static unique_ptr<FunctionData> ListAggregateBind(ClientContext &context, Scalar
 
 	// create the child expression and its type
 	vector<unique_ptr<Expression>> children;
-	auto expr = make_unique<BoundConstantExpression>(Value(LogicalType::SQLNULL));
-	expr->return_type = list_child_type;
+	auto expr = make_unique<BoundConstantExpression>(Value(list_child_type));
 	children.push_back(move(expr));
 
 	// look up the aggregate function in the catalog
@@ -192,6 +191,12 @@ static unique_ptr<FunctionData> ListAggregateBind(ClientContext &context, Scalar
 	    context, DEFAULT_SCHEMA, function_name, false, error_context);
 	D_ASSERT(func->type == CatalogType::AGGREGATE_FUNCTION_ENTRY);
 
+	if (is_parameter) {
+		bound_function.arguments[0] = LogicalTypeId::UNKNOWN;
+		bound_function.return_type = LogicalType::SQLNULL;
+		return nullptr;
+	}
+
 	// find a matching aggregate function
 	string error;
 	auto best_function_idx = Function::BindFunction(func->name, func->functions, types, error);
@@ -203,8 +208,8 @@ static unique_ptr<FunctionData> ListAggregateBind(ClientContext &context, Scalar
 	auto &best_function = func->functions[best_function_idx];
 	auto bound_aggr_function = AggregateFunction::BindAggregateFunction(context, best_function, move(children));
 
-	bound_function.arguments[0] =
-	    LogicalType::LIST(bound_aggr_function->function.arguments[0]); // for proper casting of the vectors
+	// for proper casting of the vectors
+	bound_function.arguments[0] = LogicalType::LIST(bound_aggr_function->function.arguments[0]);
 	bound_function.return_type = bound_aggr_function->function.return_type;
 	return make_unique<ListAggregatesBindData>(bound_function.return_type, move(bound_aggr_function));
 }
diff --git a/src/function/scalar/list/list_concat.cpp b/src/function/scalar/list/list_concat.cpp
index 3d42a23a134f..9519f8ebda2a 100644
--- a/src/function/scalar/list/list_concat.cpp
+++ b/src/function/scalar/list/list_concat.cpp
@@ -95,7 +95,6 @@ static unique_ptr<FunctionData> ListConcatBind(ClientContext &context, ScalarFun
 		for (const auto &argument : arguments) {
 			child_type = LogicalType::MaxLogicalType(child_type, ListType::GetChildType(argument->return_type));
 		}
-		ExpressionBinder::ResolveParameterType(child_type);
 		auto list_type = LogicalType::LIST(move(child_type));
 
 		bound_function.arguments[0] = list_type;
diff --git a/src/function/scalar/list/list_extract.cpp b/src/function/scalar/list/list_extract.cpp
index 82fc37b201e6..1602dda25399 100644
--- a/src/function/scalar/list/list_extract.cpp
+++ b/src/function/scalar/list/list_extract.cpp
@@ -159,8 +159,8 @@ static void ExecuteListExtract(Vector &result, Vector &list, Vector &offsets, co
 }
 
 static void ExecuteStringExtract(Vector &result, Vector &input_vector, Vector &subscript_vector, const idx_t count) {
-	BinaryExecutor::Execute<string_t, int32_t, string_t>(
-	    input_vector, subscript_vector, result, count, [&](string_t input_string, int32_t subscript) {
+	BinaryExecutor::Execute<string_t, int64_t, string_t>(
+	    input_vector, subscript_vector, result, count, [&](string_t input_string, int64_t subscript) {
 		    return SubstringFun::SubstringScalarFunction(result, input_string, subscript, 1);
 	    });
 }
@@ -230,7 +230,7 @@ void ListExtractFun::RegisterFunction(BuiltinFunctions &set) {
 	ScalarFunction lfun({LogicalType::LIST(LogicalType::ANY), LogicalType::BIGINT}, LogicalType::ANY,
 	                    ListExtractFunction, false, false, ListExtractBind, nullptr, ListExtractStats);
 
-	ScalarFunction sfun({LogicalType::VARCHAR, LogicalType::INTEGER}, LogicalType::VARCHAR, ListExtractFunction, false,
+	ScalarFunction sfun({LogicalType::VARCHAR, LogicalType::BIGINT}, LogicalType::VARCHAR, ListExtractFunction, false,
 	                    false, nullptr);
 
 	ScalarFunctionSet list_extract("list_extract");
diff --git a/src/function/scalar/list/list_value.cpp b/src/function/scalar/list/list_value.cpp
index 6b2150c9c60e..c5653bec2d18 100644
--- a/src/function/scalar/list/list_value.cpp
+++ b/src/function/scalar/list/list_value.cpp
@@ -39,7 +39,6 @@ static unique_ptr<FunctionData> ListValueBind(ClientContext &context, ScalarFunc
 	for (idx_t i = 0; i < arguments.size(); i++) {
 		child_type = LogicalType::MaxLogicalType(child_type, arguments[i]->return_type);
 	}
-	ExpressionBinder::ResolveParameterType(child_type);
 
 	// this is more for completeness reasons
 	bound_function.varargs = child_type;
diff --git a/src/function/scalar/string/printf.cpp b/src/function/scalar/string/printf.cpp
index ca270d7ea854..9f1150eb7b46 100644
--- a/src/function/scalar/string/printf.cpp
+++ b/src/function/scalar/string/printf.cpp
@@ -41,6 +41,10 @@ unique_ptr<FunctionData> BindPrintfFunction(ClientContext &context, ScalarFuncti
 			// decimal type: add cast to double
 			bound_function.arguments.emplace_back(LogicalType::DOUBLE);
 			break;
+		case LogicalTypeId::UNKNOWN:
+			// parameter: accept any input and rebind later
+			bound_function.arguments.emplace_back(LogicalType::ANY);
+			break;
 		default:
 			// all other types: add cast to string
 			bound_function.arguments.emplace_back(LogicalType::VARCHAR);
diff --git a/src/function/scalar/struct/struct_pack.cpp b/src/function/scalar/struct/struct_pack.cpp
index a18391344c4a..2105f73c5d4f 100644
--- a/src/function/scalar/struct/struct_pack.cpp
+++ b/src/function/scalar/struct/struct_pack.cpp
@@ -49,7 +49,6 @@ static unique_ptr<FunctionData> StructPackBind(ClientContext &context, ScalarFun
 		if (name_collision_set.find(child->alias) != name_collision_set.end()) {
 			throw BinderException("Duplicate struct entry name \"%s\"", child->alias);
 		}
-		ExpressionBinder::ResolveParameterType(arguments[i]);
 		name_collision_set.insert(child->alias);
 		struct_children.push_back(make_pair(child->alias, arguments[i]->return_type));
 	}
diff --git a/src/include/duckdb/execution/operator/helper/physical_execute.hpp b/src/include/duckdb/execution/operator/helper/physical_execute.hpp
index b7e12be6177b..971d0f827149 100644
--- a/src/include/duckdb/execution/operator/helper/physical_execute.hpp
+++ b/src/include/duckdb/execution/operator/helper/physical_execute.hpp
@@ -9,6 +9,7 @@
 #pragma once
 
 #include "duckdb/execution/physical_operator.hpp"
+#include "duckdb/main/prepared_statement_data.hpp"
 
 namespace duckdb {
 
@@ -17,6 +18,8 @@ class PhysicalExecute : public PhysicalOperator {
 	explicit PhysicalExecute(PhysicalOperator *plan);
 
 	PhysicalOperator *plan;
+	unique_ptr<PhysicalOperator> owned_plan;
+	shared_ptr<PreparedStatementData> prepared;
 };
 
 } // namespace duckdb
diff --git a/src/include/duckdb/function/aggregate_function.hpp b/src/include/duckdb/function/aggregate_function.hpp
index 50ca6ca81fb5..02e13488642e 100644
--- a/src/include/duckdb/function/aggregate_function.hpp
+++ b/src/include/duckdb/function/aggregate_function.hpp
@@ -131,7 +131,8 @@ class AggregateFunction : public BaseScalarFunction {
 	DUCKDB_API static unique_ptr<BoundAggregateExpression>
 	BindAggregateFunction(ClientContext &context, AggregateFunction bound_function,
 	                      vector<unique_ptr<Expression>> children, unique_ptr<Expression> filter = nullptr,
-	                      bool is_distinct = false, unique_ptr<BoundOrderModifier> order_bys = nullptr);
+	                      bool is_distinct = false, unique_ptr<BoundOrderModifier> order_bys = nullptr,
+	                      bool cast_parameters = true);
 
 	DUCKDB_API static unique_ptr<FunctionData> BindSortedAggregate(AggregateFunction &bound_function,
 	                                                               vector<unique_ptr<Expression>> &children,
diff --git a/src/include/duckdb/function/function.hpp b/src/include/duckdb/function/function.hpp
index 45629d379849..db5112a5f3f9 100644
--- a/src/include/duckdb/function/function.hpp
+++ b/src/include/duckdb/function/function.hpp
@@ -77,11 +77,14 @@ class Function {
 	//! Bind a scalar function from the set of functions and input arguments. Returns the index of the chosen function,
 	//! returns DConstants::INVALID_INDEX and sets error if none could be found
 	DUCKDB_API static idx_t BindFunction(const string &name, vector<ScalarFunction> &functions,
-	                                     vector<LogicalType> &arguments, string &error);
+	                                     vector<LogicalType> &arguments, string &error, bool &cast_parameters);
 	DUCKDB_API static idx_t BindFunction(const string &name, vector<ScalarFunction> &functions,
-	                                     vector<unique_ptr<Expression>> &arguments, string &error);
+	                                     vector<unique_ptr<Expression>> &arguments, string &error,
+	                                     bool &cast_parameters);
 	//! Bind an aggregate function from the set of functions and input arguments. Returns the index of the chosen
 	//! function, returns DConstants::INVALID_INDEX and sets error if none could be found
+	DUCKDB_API static idx_t BindFunction(const string &name, vector<AggregateFunction> &functions,
+	                                     vector<LogicalType> &arguments, string &error, bool &cast_parameters);
 	DUCKDB_API static idx_t BindFunction(const string &name, vector<AggregateFunction> &functions,
 	                                     vector<LogicalType> &arguments, string &error);
 	DUCKDB_API static idx_t BindFunction(const string &name, vector<AggregateFunction> &functions,
@@ -148,7 +151,8 @@ class BaseScalarFunction : public SimpleFunction {
 	DUCKDB_API hash_t Hash() const;
 
 	//! Cast a set of expressions to the arguments of this function
-	DUCKDB_API void CastToFunctionArguments(vector<unique_ptr<Expression>> &children);
+	DUCKDB_API void CastToFunctionArguments(vector<unique_ptr<Expression>> &children,
+	                                        bool cast_parameter_expressions = true);
 
 	DUCKDB_API string ToString() override;
 };
diff --git a/src/include/duckdb/function/scalar_function.hpp b/src/include/duckdb/function/scalar_function.hpp
index 951794ff678f..f25a43ba3ced 100644
--- a/src/include/duckdb/function/scalar_function.hpp
+++ b/src/include/duckdb/function/scalar_function.hpp
@@ -73,10 +73,9 @@ class ScalarFunction : public BaseScalarFunction {
 	                                                                         vector<unique_ptr<Expression>> children,
 	                                                                         string &error, bool is_operator = false);
 
-	DUCKDB_API static unique_ptr<BoundFunctionExpression> BindScalarFunction(ClientContext &context,
-	                                                                         ScalarFunction bound_function,
-	                                                                         vector<unique_ptr<Expression>> children,
-	                                                                         bool is_operator = false);
+	DUCKDB_API static unique_ptr<BoundFunctionExpression>
+	BindScalarFunction(ClientContext &context, ScalarFunction bound_function, vector<unique_ptr<Expression>> children,
+	                   bool is_operator = false, bool cast_parameters = true);
 
 	DUCKDB_API bool operator==(const ScalarFunction &rhs) const;
 	DUCKDB_API bool operator!=(const ScalarFunction &rhs) const;
diff --git a/src/include/duckdb/main/client_context.hpp b/src/include/duckdb/main/client_context.hpp
index 7d38f38e4a0d..babb1bd47501 100644
--- a/src/include/duckdb/main/client_context.hpp
+++ b/src/include/duckdb/main/client_context.hpp
@@ -211,7 +211,8 @@ class ClientContext : public std::enable_shared_from_this<ClientContext> {
 
 	//! Internally prepare a SQL statement. Caller must hold the context_lock.
 	shared_ptr<PreparedStatementData> CreatePreparedStatement(ClientContextLock &lock, const string &query,
-	                                                          unique_ptr<SQLStatement> statement);
+	                                                          unique_ptr<SQLStatement> statement,
+	                                                          vector<Value> *values = nullptr);
 	unique_ptr<PendingQueryResult> PendingStatementInternal(ClientContextLock &lock, const string &query,
 	                                                        unique_ptr<SQLStatement> statement);
 	unique_ptr<QueryResult> RunStatementInternal(ClientContextLock &lock, const string &query,
diff --git a/src/include/duckdb/main/prepared_statement_data.hpp b/src/include/duckdb/main/prepared_statement_data.hpp
index d4f5fb9ca223..f56222ae05ce 100644
--- a/src/include/duckdb/main/prepared_statement_data.hpp
+++ b/src/include/duckdb/main/prepared_statement_data.hpp
@@ -44,6 +44,8 @@ class PreparedStatementData {
 	bool requires_valid_transaction;
 	//! Whether or not the result can be streamed to the client
 	bool allow_stream_result;
+	//! Whether or not all parameters have successfully had their types determined
+	bool bound_all_parameters;
 
 	//! The catalog version of when the prepared statement was bound
 	//! If this version is lower than the current catalog version, we have to rebind the prepared statement
diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp
index 4e4c8b3cd84e..916f577f94a6 100644
--- a/src/include/duckdb/planner/binder.hpp
+++ b/src/include/duckdb/planner/binder.hpp
@@ -81,6 +81,8 @@ class Binder : public std::enable_shared_from_this<Binder> {
 	vector<CorrelatedColumnInfo> correlated_columns;
 	//! The set of parameter expressions bound by this binder
 	vector<BoundParameterExpression *> *parameters;
+	//! The types of the prepared statement parameters, if any
+	vector<LogicalType> *parameter_types;
 	//! Whether or not the bound statement is read-only
 	bool read_only;
 	//! Whether or not the statement requires a valid transaction to run
diff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp
index 5343735e5d15..693eea1afc39 100644
--- a/src/include/duckdb/planner/expression_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder.hpp
@@ -99,9 +99,6 @@ class ExpressionBinder {
 	static bool ContainsType(const LogicalType &type, LogicalTypeId target);
 	static LogicalType ExchangeType(const LogicalType &type, LogicalTypeId target, LogicalType new_type);
 
-	static void ResolveParameterType(LogicalType &type);
-	static void ResolveParameterType(unique_ptr<Expression> &expr);
-
 	//! Bind the given expresion. Unlike Bind(), this does *not* mute the given ParsedExpression.
 	//! Exposed to be used from sub-binders that aren't subclasses of ExpressionBinder.
 	virtual BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,
@@ -123,7 +120,6 @@ class ExpressionBinder {
 	BindResult BindExpression(OperatorExpression &expr, idx_t depth);
 	BindResult BindExpression(ParameterExpression &expr, idx_t depth);
 	BindResult BindExpression(PositionalReferenceExpression &ref, idx_t depth);
-	BindResult BindExpression(StarExpression &expr, idx_t depth);
 	BindResult BindExpression(SubqueryExpression &expr, idx_t depth);
 
 protected:
diff --git a/src/include/duckdb/planner/planner.hpp b/src/include/duckdb/planner/planner.hpp
index 1c04bb5cb014..62aeff267d46 100644
--- a/src/include/duckdb/planner/planner.hpp
+++ b/src/include/duckdb/planner/planner.hpp
@@ -28,6 +28,7 @@ class Planner {
 	vector<string> names;
 	vector<LogicalType> types;
 	unordered_map<idx_t, vector<unique_ptr<Value>>> value_map;
+	vector<LogicalType> parameter_types;
 
 	shared_ptr<Binder> binder;
 	ClientContext &context;
@@ -35,17 +36,12 @@ class Planner {
 	bool read_only;
 	bool requires_valid_transaction;
 	bool allow_stream_result;
+	bool bound_all_parameters;
 
 private:
 	void CreatePlan(SQLStatement &statement);
 	shared_ptr<PreparedStatementData> PrepareSQLStatement(unique_ptr<SQLStatement> statement);
 	void PlanPrepare(unique_ptr<SQLStatement> statement);
 	void PlanExecute(unique_ptr<SQLStatement> statement);
-
-	// void VerifyQuery(BoundSQLStatement &statement);
-	// void VerifyNode(BoundQueryNode &statement);
-	// void VerifyExpression(Expression &expr, vector<unique_ptr<Expression>> &copies);
-
-	// bool StatementRequiresValidTransaction(BoundSQLStatement &statement);
 };
 } // namespace duckdb
diff --git a/src/main/client_context.cpp b/src/main/client_context.cpp
index a567fb3f2348..c4bd9e2e4afc 100644
--- a/src/main/client_context.cpp
+++ b/src/main/client_context.cpp
@@ -241,13 +241,19 @@ unique_ptr<QueryResult> ClientContext::FetchResultInternal(ClientContextLock &lo
 }
 
 shared_ptr<PreparedStatementData> ClientContext::CreatePreparedStatement(ClientContextLock &lock, const string &query,
-                                                                         unique_ptr<SQLStatement> statement) {
+                                                                         unique_ptr<SQLStatement> statement,
+                                                                         vector<Value> *values) {
 	StatementType statement_type = statement->type;
 	auto result = make_shared<PreparedStatementData>(statement_type);
 
 	auto &profiler = QueryProfiler::Get(*this);
 	profiler.StartPhase("planner");
 	Planner planner(*this);
+	if (values) {
+		for (auto &value : *values) {
+			planner.parameter_types.push_back(value.type());
+		}
+	}
 	planner.CreatePlan(move(statement));
 	D_ASSERT(planner.plan);
 	profiler.EndPhase();
@@ -264,6 +270,7 @@ shared_ptr<PreparedStatementData> ClientContext::CreatePreparedStatement(ClientC
 	result->types = planner.types;
 	result->value_map = move(planner.value_map);
 	result->catalog_version = Transaction::GetTransaction(*this).catalog_version;
+	result->bound_all_parameters = planner.bound_all_parameters;
 
 	if (config.enable_optimizer) {
 		profiler.StartPhase("optimizer");
@@ -572,15 +579,17 @@ ClientContext::PendingStatementOrPreparedStatement(ClientContextLock &lock, cons
 			result = PendingStatementInternal(lock, query, move(statement));
 		} else {
 			auto &catalog = Catalog::GetCatalog(*this);
-			if (prepared->unbound_statement && catalog.GetCatalogVersion() != prepared->catalog_version) {
-				D_ASSERT(prepared->unbound_statement.get());
+			if (prepared->unbound_statement &&
+			    (catalog.GetCatalogVersion() != prepared->catalog_version || !prepared->bound_all_parameters)) {
 				// catalog was modified: rebind the statement before execution
-				auto new_prepared = CreatePreparedStatement(lock, query, prepared->unbound_statement->Copy());
-				if (prepared->types != new_prepared->types) {
+				auto new_prepared = CreatePreparedStatement(lock, query, prepared->unbound_statement->Copy(), values);
+				if (prepared->types != new_prepared->types && prepared->bound_all_parameters) {
 					throw BinderException("Rebinding statement after catalog change resulted in change of types");
 				}
+				D_ASSERT(new_prepared->bound_all_parameters);
 				new_prepared->unbound_statement = move(prepared->unbound_statement);
 				prepared = move(new_prepared);
+				prepared->bound_all_parameters = false;
 			}
 			result = PendingPreparedStatement(lock, prepared, *values);
 		}
diff --git a/src/main/prepared_statement_data.cpp b/src/main/prepared_statement_data.cpp
index c2f9edb759e8..700945a8aab8 100644
--- a/src/main/prepared_statement_data.cpp
+++ b/src/main/prepared_statement_data.cpp
@@ -5,7 +5,8 @@
 namespace duckdb {
 
 PreparedStatementData::PreparedStatementData(StatementType type)
-    : statement_type(type), read_only(true), requires_valid_transaction(true), allow_stream_result(false) {
+    : statement_type(type), read_only(true), requires_valid_transaction(true), allow_stream_result(false),
+      bound_all_parameters(true) {
 }
 
 PreparedStatementData::~PreparedStatementData() {
diff --git a/src/planner/binder.cpp b/src/planner/binder.cpp
index 97db05bdec07..8b28a7848505 100644
--- a/src/planner/binder.cpp
+++ b/src/planner/binder.cpp
@@ -25,6 +25,7 @@ Binder::Binder(bool, ClientContext &context, shared_ptr<Binder> parent_p, bool i
     : context(context), read_only(true), requires_valid_transaction(true), allow_stream_result(false),
       parent(move(parent_p)), bound_tables(0), inherit_ctes(inherit_ctes_p) {
 	parameters = nullptr;
+	parameter_types = nullptr;
 	if (parent) {
 		// We have to inherit macro parameter bindings from the parent binder, if there is a parent.
 		macro_binding = parent->macro_binding;
@@ -33,6 +34,7 @@ Binder::Binder(bool, ClientContext &context, shared_ptr<Binder> parent_p, bool i
 			bind_context.SetCTEBindings(parent->bind_context.GetCTEBindings());
 			bind_context.cte_references = parent->bind_context.cte_references;
 			parameters = parent->parameters;
+			parameter_types = parent->parameter_types;
 		}
 	}
 }
diff --git a/src/planner/binder/expression/bind_aggregate_expression.cpp b/src/planner/binder/expression/bind_aggregate_expression.cpp
index 77d327d7d847..a02fa47cd40b 100644
--- a/src/planner/binder/expression/bind_aggregate_expression.cpp
+++ b/src/planner/binder/expression/bind_aggregate_expression.cpp
@@ -148,7 +148,8 @@ BindResult SelectBinder::BindAggregate(FunctionExpression &aggr, AggregateFuncti
 	}
 
 	// bind the aggregate
-	idx_t best_function = Function::BindFunction(func->name, func->functions, types, error);
+	bool cast_parameters;
+	idx_t best_function = Function::BindFunction(func->name, func->functions, types, error, cast_parameters);
 	if (best_function == DConstants::INVALID_INDEX) {
 		throw BinderException(binder.FormatError(aggr, error));
 	}
@@ -168,8 +169,8 @@ BindResult SelectBinder::BindAggregate(FunctionExpression &aggr, AggregateFuncti
 		}
 	}
 
-	auto aggregate = AggregateFunction::BindAggregateFunction(context, bound_function, move(children),
-	                                                          move(bound_filter), aggr.distinct, move(order_bys));
+	auto aggregate = AggregateFunction::BindAggregateFunction(
+	    context, bound_function, move(children), move(bound_filter), aggr.distinct, move(order_bys), cast_parameters);
 	if (aggr.export_state) {
 		aggregate = ExportAggregateFunction::Bind(move(aggregate));
 	}
diff --git a/src/planner/binder/expression/bind_case_expression.cpp b/src/planner/binder/expression/bind_case_expression.cpp
index dd9169dd9bc1..37b82f153891 100644
--- a/src/planner/binder/expression/bind_case_expression.cpp
+++ b/src/planner/binder/expression/bind_case_expression.cpp
@@ -23,7 +23,6 @@ BindResult ExpressionBinder::BindExpression(CaseExpression &expr, idx_t depth) {
 		auto &then_expr = (BoundExpression &)*check.then_expr;
 		return_type = LogicalType::MaxLogicalType(return_type, then_expr.expr->return_type);
 	}
-	ExpressionBinder::ResolveParameterType(return_type);
 
 	// bind all the individual components of the CASE statement
 	auto result = make_unique<BoundCaseExpression>(return_type);
diff --git a/src/planner/binder/expression/bind_comparison_expression.cpp b/src/planner/binder/expression/bind_comparison_expression.cpp
index d7d507de197e..d2886b607c2a 100644
--- a/src/planner/binder/expression/bind_comparison_expression.cpp
+++ b/src/planner/binder/expression/bind_comparison_expression.cpp
@@ -101,10 +101,6 @@ LogicalType BoundComparisonExpression::BindComparison(LogicalType left_type, Log
 			}
 		}
 		return result_type;
-	case LogicalTypeId::UNKNOWN:
-		// comparing two prepared statement parameters (e.g. SELECT ?=?)
-		// default to VARCHAR
-		return LogicalType::VARCHAR;
 	default:
 		return result_type;
 	}
diff --git a/src/planner/binder/expression/bind_operator_expression.cpp b/src/planner/binder/expression/bind_operator_expression.cpp
index a918b51362b2..7d8ffa91b4a3 100644
--- a/src/planner/binder/expression/bind_operator_expression.cpp
+++ b/src/planner/binder/expression/bind_operator_expression.cpp
@@ -23,7 +23,6 @@ static LogicalType ResolveInType(OperatorExpression &op, vector<BoundExpression
 	for (idx_t i = 1; i < children.size(); i++) {
 		max_type = LogicalType::MaxLogicalType(max_type, children[i]->expr->return_type);
 	}
-	ExpressionBinder::ResolveParameterType(max_type);
 
 	// cast all children to the same type
 	for (idx_t i = 0; i < children.size(); i++) {
@@ -38,7 +37,6 @@ static LogicalType ResolveOperatorType(OperatorExpression &op, vector<BoundExpre
 	case ExpressionType::OPERATOR_IS_NULL:
 	case ExpressionType::OPERATOR_IS_NOT_NULL:
 		// IS (NOT) NULL always returns a boolean, and does not cast its children
-		ExpressionBinder::ResolveParameterType(children[0]->expr);
 		return LogicalType::BOOLEAN;
 	case ExpressionType::COMPARE_IN:
 	case ExpressionType::COMPARE_NOT_IN:
diff --git a/src/planner/binder/expression/bind_parameter_expression.cpp b/src/planner/binder/expression/bind_parameter_expression.cpp
index 8e12236ad806..29a60c5803cc 100644
--- a/src/planner/binder/expression/bind_parameter_expression.cpp
+++ b/src/planner/binder/expression/bind_parameter_expression.cpp
@@ -11,6 +11,9 @@ BindResult ExpressionBinder::BindExpression(ParameterExpression &expr, idx_t dep
 		throw std::runtime_error("Unexpected prepared parameter. This type of statement can't be prepared!");
 	}
 	binder.parameters->push_back(bound_parameter.get());
+	if (binder.parameter_types && expr.parameter_nr <= binder.parameter_types->size()) {
+		bound_parameter->return_type = (*binder.parameter_types)[expr.parameter_nr - 1];
+	}
 	return BindResult(move(bound_parameter));
 }
 
diff --git a/src/planner/binder/expression/bind_subquery_expression.cpp b/src/planner/binder/expression/bind_subquery_expression.cpp
index 08b2fbccf687..9d8c7ea8790f 100644
--- a/src/planner/binder/expression/bind_subquery_expression.cpp
+++ b/src/planner/binder/expression/bind_subquery_expression.cpp
@@ -76,7 +76,9 @@ BindResult ExpressionBinder::BindExpression(SubqueryExpression &expr, idx_t dept
 	auto bound_node = move(bound_subquery->bound_node);
 	LogicalType return_type =
 	    expr.subquery_type == SubqueryType::SCALAR ? bound_node->types[0] : LogicalType(LogicalTypeId::BOOLEAN);
-	D_ASSERT(return_type.id() != LogicalTypeId::UNKNOWN);
+	if (return_type.id() == LogicalTypeId::UNKNOWN) {
+		return_type = LogicalType::SQLNULL;
+	}
 
 	auto result = make_unique<BoundSubqueryExpression>(return_type);
 	if (expr.subquery_type == SubqueryType::ANY) {
diff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp
index 383bb491b11b..38bd32238f2b 100644
--- a/src/planner/expression_binder.cpp
+++ b/src/planner/expression_binder.cpp
@@ -165,19 +165,6 @@ LogicalType ExpressionBinder::ExchangeNullType(const LogicalType &type) {
 	return ExchangeType(type, LogicalTypeId::SQLNULL, LogicalType::INTEGER);
 }
 
-void ExpressionBinder::ResolveParameterType(LogicalType &type) {
-	if (type.id() == LogicalTypeId::UNKNOWN) {
-		type = LogicalType::VARCHAR;
-	}
-}
-
-void ExpressionBinder::ResolveParameterType(unique_ptr<Expression> &expr) {
-	if (ContainsType(expr->return_type, LogicalTypeId::UNKNOWN)) {
-		auto result_type = ExchangeType(expr->return_type, LogicalTypeId::UNKNOWN, LogicalType::VARCHAR);
-		expr = BoundCastExpression::AddCastToType(move(expr), result_type);
-	}
-}
-
 unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr, LogicalType *result_type,
                                               bool root_expression) {
 	// bind the main expression
@@ -206,9 +193,6 @@ unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr
 				result = BoundCastExpression::AddCastToType(move(result), result_type);
 			}
 		}
-		// check if we failed to convert any parameters
-		// if we did, we push a cast
-		ExpressionBinder::ResolveParameterType(result);
 	}
 	if (result_type) {
 		*result_type = result->return_type;
diff --git a/src/planner/planner.cpp b/src/planner/planner.cpp
index eb08ea75e0ba..3a37be7c1211 100644
--- a/src/planner/planner.cpp
+++ b/src/planner/planner.cpp
@@ -28,6 +28,7 @@ void Planner::CreatePlan(SQLStatement &statement) {
 	// first bind the tables and columns to the catalog
 	profiler.StartPhase("binder");
 	binder->parameters = &bound_parameters;
+	binder->parameter_types = &parameter_types;
 	auto bound_statement = binder->Bind(statement);
 	profiler.EndPhase();
 
@@ -37,20 +38,23 @@ void Planner::CreatePlan(SQLStatement &statement) {
 	this->names = bound_statement.names;
 	this->types = bound_statement.types;
 	this->plan = move(bound_statement.plan);
+	this->bound_all_parameters = true;
 
 	// set up a map of parameter number -> value entries
 	for (auto &expr : bound_parameters) {
 		// check if the type of the parameter could be resolved
 		if (expr->return_type.id() == LogicalTypeId::INVALID || expr->return_type.id() == LogicalTypeId::UNKNOWN) {
-			throw BinderException("Could not determine type of parameters");
+			this->bound_all_parameters = false;
+			continue;
 		}
 		auto value = make_unique<Value>(expr->return_type);
 		expr->value = value.get();
 		// check if the parameter number has been used before
-		if (value_map.find(expr->parameter_nr) == value_map.end()) {
+		auto entry = value_map.find(expr->parameter_nr);
+		if (entry == value_map.end()) {
 			// not used before, create vector
 			value_map[expr->parameter_nr] = vector<unique_ptr<Value>>();
-		} else if (value_map[expr->parameter_nr].back()->type() != value->type()) {
+		} else if (entry->second.back()->type() != value->type()) {
 			// used before, but types are inconsistent
 			throw BinderException("Inconsistent types found for parameter with index %llu", expr->parameter_nr);
 		}
@@ -72,6 +76,7 @@ shared_ptr<PreparedStatementData> Planner::PrepareSQLStatement(unique_ptr<SQLSta
 	prepared_data->requires_valid_transaction = this->requires_valid_transaction;
 	prepared_data->allow_stream_result = this->allow_stream_result;
 	prepared_data->catalog_version = Transaction::GetTransaction(context).catalog_version;
+	prepared_data->bound_all_parameters = this->bound_all_parameters;
 	return prepared_data;
 }
 
@@ -89,30 +94,43 @@ void Planner::PlanExecute(unique_ptr<SQLStatement> statement) {
 	auto prepared = entry->second;
 	auto &catalog = Catalog::GetCatalog(context);
 	bool rebound = false;
-	if (catalog.GetCatalogVersion() != entry->second->catalog_version) {
-		// catalog was modified: rebind the statement before running the execute
-		prepared = PrepareSQLStatement(entry->second->unbound_statement->Copy());
-		if (prepared->types != entry->second->types) {
-			throw BinderException("Rebinding statement \"%s\" after catalog change resulted in change of types",
-			                      stmt.name);
-		}
-		rebound = true;
-	}
 
-	// the bound prepared statement is ready: bind any supplied parameters
+	// bind any supplied parameters
 	vector<Value> bind_values;
 	for (idx_t i = 0; i < stmt.values.size(); i++) {
 		ConstantBinder cbinder(*binder, context, "EXECUTE statement");
-		if (prepared->value_map.count(i + 1)) {
-			cbinder.target_type = prepared->GetType(i + 1);
-		}
 		auto bound_expr = cbinder.Bind(stmt.values[i]);
 
 		Value value = ExpressionExecutor::EvaluateScalar(*bound_expr);
 		bind_values.push_back(move(value));
 	}
+	bool all_bound = prepared->bound_all_parameters;
+	if (catalog.GetCatalogVersion() != entry->second->catalog_version || !all_bound) {
+		// catalog was modified or statement does not have clear types: rebind the statement before running the execute
+		for (auto &value : bind_values) {
+			parameter_types.push_back(value.type());
+		}
+		prepared = PrepareSQLStatement(entry->second->unbound_statement->Copy());
+		if (all_bound && prepared->types != entry->second->types) {
+			throw BinderException("Rebinding statement \"%s\" after catalog change resulted in change of types",
+			                      stmt.name);
+		}
+		D_ASSERT(prepared->bound_all_parameters);
+		rebound = true;
+	}
+	// add casts to the prepared statement parameters as required
+	for (idx_t i = 0; i < bind_values.size(); i++) {
+		if (prepared->value_map.count(i + 1) == 0) {
+			continue;
+		}
+		bind_values[i] = bind_values[i].CastAs(prepared->GetType(i + 1));
+	}
+
 	prepared->Bind(move(bind_values));
 	if (rebound) {
+		auto execute_plan = make_unique<LogicalExecute>(move(prepared));
+		execute_plan->children.push_back(move(plan));
+		this->plan = move(execute_plan);
 		return;
 	}
 
@@ -122,6 +140,7 @@ void Planner::PlanExecute(unique_ptr<SQLStatement> statement) {
 	this->allow_stream_result = prepared->allow_stream_result;
 	this->names = prepared->names;
 	this->types = prepared->types;
+	this->bound_all_parameters = prepared->bound_all_parameters;
 	this->plan = make_unique<LogicalExecute>(move(prepared));
 }
 
@@ -136,6 +155,7 @@ void Planner::PlanPrepare(unique_ptr<SQLStatement> statement) {
 	// this is required because most clients ALWAYS invoke prepared statements
 	this->requires_valid_transaction = false;
 	this->allow_stream_result = false;
+	this->bound_all_parameters = true;
 	this->names = {"Success"};
 	this->types = {LogicalType::BOOLEAN};
 	this->plan = move(prepare);
diff --git a/tools/rpkg/src/statement.cpp b/tools/rpkg/src/statement.cpp
index 90baf4dca024..276fef91cf25 100644
--- a/tools/rpkg/src/statement.cpp
+++ b/tools/rpkg/src/statement.cpp
@@ -112,6 +112,9 @@ static void VectorToR(Vector &src_vec, size_t count, void *dest, uint64_t dest_o
 		case LogicalTypeId::ENUM:
 			rtype = "factor";
 			break;
+		case LogicalTypeId::UNKNOWN:
+			rtype = "unknown";
+			break;
 		default:
 			cpp11::stop("rapi_prepare: Unknown column type for prepare: %s", stype.ToString().c_str());
 			break;
