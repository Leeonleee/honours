diff --git a/test/api/test_prepared_api.cpp b/test/api/test_prepared_api.cpp
index 5a8d86240fb3..74da545453bc 100644
--- a/test/api/test_prepared_api.cpp
+++ b/test/api/test_prepared_api.cpp
@@ -456,3 +456,22 @@ TEST_CASE("Prepare all types of statements", "[prepared]") {
 	// TRANSACTION
 	REQUIRE_NO_FAIL(TestExecutePrepared(con, "COMMIT"));
 }
+
+TEST_CASE("Test ambiguous prepared statement parameter types", "[api]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db);
+
+	result = con.Query("SELECT ?", 42);
+	REQUIRE(CHECK_COLUMN(result, 0, {42}));
+
+	result = con.Query("SELECT ?", "hello");
+	REQUIRE(CHECK_COLUMN(result, 0, {"hello"}));
+
+	auto prep = con.Prepare("SELECT ?");
+	result = prep->Execute(42);
+	REQUIRE(CHECK_COLUMN(result, 0, {42}));
+
+	result = prep->Execute("hello");
+	REQUIRE(CHECK_COLUMN(result, 0, {"hello"}));
+}
diff --git a/test/issues/fuzz/prepared_statement_crash.test b/test/issues/fuzz/prepared_statement_crash.test
new file mode 100644
index 000000000000..bea5df5ec2ab
--- /dev/null
+++ b/test/issues/fuzz/prepared_statement_crash.test
@@ -0,0 +1,12 @@
+# name: test/issues/fuzz/prepared_statement_crash.test
+# description: Issue #3364: heap-use-after-free in duckdb::LogicalType::operator==(duckdb::LogicalType const&)
+# group: [fuzz]
+
+statement ok
+PREPARE s1 AS SELECT CAST(? AS INTEGER), CAST(? AS STRING);
+
+statement ok
+SELECT MIN ( DISTINCT + CAST ( NULL AS INTEGER ) ) * COUNT ( * ) * - + 16 * CASE + + AVG ( ALL 97 ) WHEN ( + NULLIF ( SUM ( CAST ( NULL AS REAL ) ), 6 ) ) THEN 51 * 31 + - 6 WHEN + 48 * - 34 THEN NULL WHEN 91 * + ( SUM ( CAST ( NULL AS INTEGER ) ) ) THEN NULL END * - 4 + - 67;
+
+statement ok
+EXECUTE s1(42, 'dpfkg');
diff --git a/test/issues/general/test_2416.test b/test/issues/general/test_2416.test
index c6a596291c5f..71740655d078 100644
--- a/test/issues/general/test_2416.test
+++ b/test/issues/general/test_2416.test
@@ -83,9 +83,14 @@ EXECUTE v3(NULL)
 ----
 NULL
 
-statement error
+statement ok
 PREPARE v4 AS SELECT array_length($1)
 
+query I
+EXECUTE v4([1, 2, 3])
+----
+3
+
 statement ok
 create macro array_l(my_arr) as array_length(my_arr);
 
diff --git a/test/sql/prepared/prepare_default_varchar.test b/test/sql/prepared/prepare_default_varchar.test
index 359b648a3f33..7a38cf484c7c 100644
--- a/test/sql/prepared/prepare_default_varchar.test
+++ b/test/sql/prepared/prepare_default_varchar.test
@@ -38,10 +38,8 @@ EXECUTE v2('hello world', 'hello mars')
 ----
 false
 
-query I
+statement error
 EXECUTE v2([1, 2, 3], '[1, 2, 3]')
-----
-true
 
 # unbound parameter in scalar subquery
 statement ok
@@ -121,14 +119,14 @@ EXECUTE v6(NULL)
 
 # unbound parameter with printf
 statement ok
-PREPARE v7 AS SELECT printf('%s: %s', ?, ?)
+PREPARE v7 AS SELECT printf('%s: %d', ?, ?)
 
 query I
 EXECUTE v7('time', 27)
 ----
 time: 27
 
-query I
+statement error
 EXECUTE v7('hello world', [1, 2, 3])
 ----
 hello world: [1, 2, 3]
diff --git a/test/sql/prepared/prepare_list_functions.test b/test/sql/prepared/prepare_list_functions.test
new file mode 100644
index 000000000000..cbedec09fb6d
--- /dev/null
+++ b/test/sql/prepared/prepare_list_functions.test
@@ -0,0 +1,55 @@
+# name: test/sql/prepared/prepare_list_functions.test
+# description: PREPARE of various LIST functions
+# group: [prepared]
+
+# list_aggregate
+statement ok
+PREPARE v1 AS SELECT list_aggregate(?, 'min')
+
+query I
+EXECUTE v1([1, 2, 3])
+----
+1
+
+query I
+EXECUTE v1(['hello', 'world'])
+----
+hello
+
+
+query I
+EXECUTE v1(NULL::INT[])
+----
+NULL
+
+# array_slice
+statement ok
+PREPARE v2 AS SELECT array_slice(?, 1, 2);
+
+query I
+EXECUTE v2([1, 2, 3]);
+----
+[1, 2]
+
+query I
+EXECUTE v2('123');
+----
+12
+
+# flatten
+statement ok
+PREPARE v3 AS SELECT flatten(?)
+
+query I
+EXECUTE v3([[1,2,3],[4,5]]);
+----
+[1, 2, 3, 4, 5]
+
+# list_extract
+statement ok
+PREPARE v4 AS SELECT list_extract(?, 2)
+
+query I
+EXECUTE v4([1, 2, 3]);
+----
+2
\ No newline at end of file
diff --git a/test/sql/prepared/prepare_window_functions.test b/test/sql/prepared/prepare_window_functions.test
new file mode 100644
index 000000000000..fe893007beaf
--- /dev/null
+++ b/test/sql/prepared/prepare_window_functions.test
@@ -0,0 +1,24 @@
+# name: test/sql/prepared/prepare_window_functions.test
+# description: PREPARE of window functions
+# group: [prepared]
+
+require vector_size 512
+
+# ambiguous window function usage
+statement ok
+PREPARE v1 AS SELECT SUM(?) OVER ()
+
+query I
+EXECUTE v1(2)
+----
+2
+
+query I
+EXECUTE v1(2::HUGEINT)
+----
+2
+
+query I
+EXECUTE v1(0.5)
+----
+0.5
\ No newline at end of file
diff --git a/test/sql/prepared/test_prepare_ambiguous_type.test b/test/sql/prepared/test_prepare_ambiguous_type.test
new file mode 100644
index 000000000000..c05eb32ddb8f
--- /dev/null
+++ b/test/sql/prepared/test_prepare_ambiguous_type.test
@@ -0,0 +1,296 @@
+# name: test/sql/prepared/test_prepare_ambiguous_type.test
+# description: PREPARE of ambiguous types
+# group: [prepared]
+
+# typeof
+statement ok
+PREPARE v1 AS SELECT typeof(?)
+
+query I
+EXECUTE v1(3::int)
+----
+INTEGER
+
+query I
+EXECUTE v1('hello')
+----
+VARCHAR
+
+query I
+EXECUTE v1([1, 2, 3])
+----
+INTEGER[]
+
+# direct select without cast
+statement ok
+PREPARE v2 AS SELECT ?
+
+query I
+EXECUTE v2(3::int)
+----
+3
+
+query I
+EXECUTE v2('hello')
+----
+hello
+
+query I
+EXECUTE v2([1, 2, 3])
+----
+[1, 2, 3]
+
+# ambiguous comparison
+statement ok
+PREPARE v3 AS SELECT ?=?
+
+query I
+EXECUTE v3(3::int, 4::bigint)
+----
+false
+
+query I
+EXECUTE v3('hello', 'hello')
+----
+true
+
+query I
+EXECUTE v3([1, 2, 3], [1, 2, 3])
+----
+true
+
+# ambiguous function usage (date_part)
+statement ok
+PREPARE v4 AS SELECT extract(year from ?)
+
+query I
+EXECUTE v4(DATE '1992-01-01')
+----
+1992
+
+query I
+EXECUTE v4(TIMESTAMP '1992-01-01 23:00:20')
+----
+1992
+
+# printf
+statement ok
+PREPARE v5 AS SELECT printf('%s', ?)
+
+statement error
+EXECUTE v5(4)
+
+query I
+EXECUTE v5('hello')
+----
+hello
+
+statement ok
+PREPARE v6 AS SELECT printf('%d', ?)
+
+query I
+EXECUTE v6(4)
+----
+4
+
+statement error
+EXECUTE v6('hello')
+
+# lists and structs
+statement ok
+PREPARE v7 AS SELECT [?]
+
+query I
+EXECUTE v7(1)
+----
+[1]
+
+query I
+EXECUTE v7('hello')
+----
+[hello]
+
+query I
+EXECUTE v7([1,2,3])
+----
+[[1, 2, 3]]
+
+
+query I
+EXECUTE v7(NULL)
+----
+[NULL]
+
+statement ok
+PREPARE v8 AS SELECT [?, ?, ?]
+
+query I
+EXECUTE v8(1, 2, 3)
+----
+[1, 2, 3]
+
+query I
+EXECUTE v8(NULL, NULL, NULL)
+----
+[NULL, NULL, NULL]
+
+query I
+EXECUTE v8('hello', 'world', NULL)
+----
+[hello, world, NULL]
+
+statement ok
+PREPARE v9 AS SELECT {'a': ?}
+
+query I
+EXECUTE v9(42)
+----
+{'a': 42}
+
+query I
+EXECUTE v9([1,2,3])
+----
+{'a': [1, 2, 3]}
+
+query I
+EXECUTE v9(NULL)
+----
+{'a': NULL}
+
+statement ok
+PREPARE v10 AS SELECT {'a': ?, 'b': 42, 'c': ?}
+
+query I
+EXECUTE v10(33, [1, 2, 3])
+----
+{'a': 33, 'b': 42, 'c': [1, 2, 3]}
+
+query I
+EXECUTE v10(NULL, {'a': 88})
+----
+{'a': NULL, 'b': 42, 'c': {'a': 88}}
+
+statement ok
+PREPARE v11 AS SELECT ROW(?, ?)
+
+query I
+EXECUTE v11(11, 'hello')
+----
+{'v1': 11, 'v2': hello}
+
+statement ok
+PREPARE v12 AS SELECT ? IS NULL
+
+query I
+EXECUTE v12('hello')
+----
+false
+
+query I
+EXECUTE v12([1, 2, 3])
+----
+false
+
+query I
+EXECUTE v12(NULL)
+----
+true
+
+# subqueries
+statement ok
+PREPARE v13 AS SELECT (SELECT ?)
+
+query I
+EXECUTE v13(3::int)
+----
+3
+
+query I
+EXECUTE v13('hello')
+----
+hello
+
+query I
+EXECUTE v13([1, 2, 3])
+----
+[1, 2, 3]
+
+
+# ambiguous aggregate usage
+statement ok
+PREPARE v14 AS SELECT SUM(?) FROM RANGE(100)
+
+query I
+EXECUTE v14(2)
+----
+200
+
+query I
+EXECUTE v14(2::HUGEINT)
+----
+200
+
+query I
+EXECUTE v14(0.005)
+----
+0.5
+
+# ambiguous function usage (addition)
+statement ok
+PREPARE v15 AS SELECT ?+?
+
+query I
+EXECUTE v15(0.25, 0.25)
+----
+0.5
+
+query I
+EXECUTE v15(1000000000000000000000000000000000000::hugeint, 1000000000000000000000000000000000000::hugeint)
+----
+2000000000000000000000000000000000000
+
+# array contains usage
+statement ok
+PREPARE v17 AS SELECT ARRAY_CONTAINS(?, ?)
+
+query I
+EXECUTE v17([1, 2, 3], 1)
+----
+true
+
+query I
+EXECUTE v17([], 1)
+----
+false
+
+query I
+EXECUTE v17(['hello', NULL, 'world'], 'world')
+----
+true
+
+statement ok
+PREPARE v18 AS SELECT ARRAY_CONTAINS([1, 2, 3], ?)
+
+query I
+EXECUTE v18(1)
+----
+true
+
+query I
+EXECUTE v18(0)
+----
+false
+
+statement error
+EXECUTE v18([1])
+
+statement ok
+PREPARE v19 AS SELECT ARRAY_CONTAINS(?, 1)
+
+query I
+EXECUTE v19([1, 2, 3])
+----
+true
+
+statement error
+EXECUTE v19(0)
diff --git a/tools/juliapkg/test/test_prepare.jl b/tools/juliapkg/test/test_prepare.jl
index 1edafd90afdc..67e14d1586ff 100644
--- a/tools/juliapkg/test/test_prepare.jl
+++ b/tools/juliapkg/test/test_prepare.jl
@@ -86,3 +86,17 @@ end
 
     DBInterface.close!(con)
 end
+
+@testset "DBInterface.prepare: ambiguous parameters" begin
+    con = DBInterface.connect(DuckDB.DB)
+
+    stmt = DBInterface.prepare(con, "SELECT ? AS a")
+    result = DataFrame(DBInterface.execute(stmt, [42]))
+    @test isequal(result.a, [42])
+
+    result = DataFrame(DBInterface.execute(stmt, ["hello world"]))
+    @test isequal(result.a, ["hello world"])
+
+    result = DataFrame(DBInterface.execute(stmt, [DateTime(1992, 9, 20, 23, 10, 33)]))
+    @test isequal(result.a, [DateTime(1992, 9, 20, 23, 10, 33)])
+end
diff --git a/tools/pythonpkg/tests/fast/test_ambiguous_prepare.py b/tools/pythonpkg/tests/fast/test_ambiguous_prepare.py
new file mode 100644
index 000000000000..b45c8be1cd0f
--- /dev/null
+++ b/tools/pythonpkg/tests/fast/test_ambiguous_prepare.py
@@ -0,0 +1,12 @@
+import duckdb
+import pandas as pd
+import pytest
+
+class TestAmbiguousPrepare(object):
+    def test_bool(self, duckdb_cursor):
+        conn = duckdb.connect()
+        res = conn.execute("select ?, ?, ?", (True, 42, [1, 2, 3])).fetchall()
+        assert res[0][0] == True
+        assert res[0][1] == 42
+        assert res[0][2] == [1, 2, 3]
+
diff --git a/tools/rpkg/tests/testthat/test_ambiguous_prepare.R b/tools/rpkg/tests/testthat/test_ambiguous_prepare.R
new file mode 100644
index 000000000000..eea0fbe2aaf2
--- /dev/null
+++ b/tools/rpkg/tests/testthat/test_ambiguous_prepare.R
@@ -0,0 +1,10 @@
+test_that("Test ambiguous prepare statements", {
+  con <- dbConnect(duckdb())
+  on.exit(dbDisconnect(con, shutdown = TRUE))
+
+  res <- dbGetQuery(con, "select ?", 42)
+  expect_identical(res[[1]], 42)
+
+  res <- dbGetQuery(con, "select ?", "hello world")
+  expect_identical(res[[1]], "hello world")
+})
