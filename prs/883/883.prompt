You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Unify scan ops and allow filter and projection pushdown into table functions (e.g. CSV/Parquet reader)
Hi,

is it already possible to read only specific columns from (gzipped) csv-files  into an existing table?
It would save us from preprocessing files or loading unneeded data.

(unfortunately, read_csv_auto might crash, if data type is guessed incorrectly)

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="30">
2: 
3: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of benchmark/benchmark_runner.cpp]
1: #include "benchmark_runner.hpp"
2: 
3: #include "duckdb/common/profiler.hpp"
4: #include "duckdb/common/string_util.hpp"
5: #include "duckdb.hpp"
6: #include "duckdb_benchmark.hpp"
7: #include "interpreted_benchmark.hpp"
8: 
9: #define CATCH_CONFIG_RUNNER
10: #include "catch.hpp"
11: #include "re2/re2.h"
12: 
13: #include <fstream>
14: #include <sstream>
15: #include <thread>
16: 
17: using namespace duckdb;
18: using namespace std;
19: 
20: void BenchmarkRunner::RegisterBenchmark(Benchmark *benchmark) {
21: 	GetInstance().benchmarks.push_back(benchmark);
22: }
23: 
24: Benchmark::Benchmark(bool register_benchmark, string name, string group) : name(name), group(group) {
25: 	if (register_benchmark) {
26: 		BenchmarkRunner::RegisterBenchmark(this);
27: 	}
28: }
29: 
30: static void listFiles(FileSystem &fs, const string &path, std::function<void(const string &)> cb) {
31: 	fs.ListFiles(path, [&](string fname, bool is_dir) {
32: 		string full_path = fs.JoinPath(path, fname);
33: 		if (is_dir) {
34: 			// recurse into directory
35: 			listFiles(fs, full_path, cb);
36: 		} else {
37: 			cb(full_path);
38: 		}
39: 	});
40: }
41: 
42: static bool endsWith(const string &mainStr, const string &toMatch) {
43: 	return (mainStr.size() >= toMatch.size() &&
44: 	        mainStr.compare(mainStr.size() - toMatch.size(), toMatch.size(), toMatch) == 0);
45: }
46: 
47: BenchmarkRunner::BenchmarkRunner() {
48: }
49: 
50: void BenchmarkRunner::SaveDatabase(DuckDB &db, string name) {
51: 	auto &fs = db.GetFileSystem();
52: 	// check if the database directory exists; if not create it
53: 	if (!fs.DirectoryExists(DUCKDB_BENCHMARK_DIRECTORY)) {
54: 		fs.CreateDirectory(DUCKDB_BENCHMARK_DIRECTORY);
55: 	}
56: 	Connection con(db);
57: 	auto result = con.Query(
58: 	    StringUtil::Format("EXPORT DATABASE '%s' (FORMAT CSV)", fs.JoinPath(DUCKDB_BENCHMARK_DIRECTORY, name)));
59: 	if (!result->success) {
60: 		throw Exception("Failed to save database: " + result->error);
61: 	}
62: }
63: 
64: bool BenchmarkRunner::TryLoadDatabase(DuckDB &db, string name) {
65: 	auto &fs = db.GetFileSystem();
66: 	if (!fs.DirectoryExists(DUCKDB_BENCHMARK_DIRECTORY)) {
67: 		return false;
68: 	}
69: 	string base_dir = fs.JoinPath(DUCKDB_BENCHMARK_DIRECTORY, name);
70: 	// check if the [name]/schema.sql file exists
71: 	if (!fs.FileExists(fs.JoinPath(base_dir, "schema.sql"))) {
72: 		return false;
73: 	}
74: 	Connection con(db);
75: 	auto result = con.Query(StringUtil::Format("IMPORT DATABASE '%s'", base_dir));
76: 	if (!result->success) {
77: 		throw Exception("Failed to load database: " + result->error);
78: 	}
79: 	return true;
80: }
81: 
82: volatile bool is_active = false;
83: volatile bool timeout = false;
84: 
85: void sleep_thread(Benchmark *benchmark, BenchmarkState *state, int timeout_duration) {
86: 	// timeout is given in seconds
87: 	// we wait 10ms per iteration, so timeout * 100 gives us the amount of
88: 	// iterations
89: 	if (timeout_duration < 0) {
90: 		return;
91: 	}
92: 	for (size_t i = 0; i < (size_t)(timeout_duration * 100) && is_active; i++) {
93: 		std::this_thread::sleep_for(std::chrono::milliseconds(10));
94: 	}
95: 	if (is_active) {
96: 		timeout = true;
97: 		benchmark->Interrupt(state);
98: 	}
99: }
100: 
101: void BenchmarkRunner::Log(string message) {
102: 	fprintf(stderr, "%s", message.c_str());
103: }
104: 
105: void BenchmarkRunner::LogLine(string message) {
106: 	fprintf(stderr, "%s\n", message.c_str());
107: }
108: 
109: void BenchmarkRunner::LogResult(string message) {
110: 	LogLine(message);
111: 	if (out_file.good()) {
112: 		out_file << message << endl;
113: 		out_file.flush();
114: 	}
115: }
116: 
117: void BenchmarkRunner::LogOutput(string message) {
118: 	if (log_file.good()) {
119: 		log_file << message << endl;
120: 		log_file.flush();
121: 	}
122: }
123: 
124: void BenchmarkRunner::RunBenchmark(Benchmark *benchmark) {
125: 	Profiler profiler;
126: 	LogLine(string(benchmark->name.size() + 6, '-'));
127: 	LogLine("|| " + benchmark->name + " ||");
128: 	LogLine(string(benchmark->name.size() + 6, '-'));
129: 	auto state = benchmark->Initialize();
130: 	auto nruns = benchmark->NRuns();
131: 	for (size_t i = 0; i < nruns + 1; i++) {
132: 		bool hotrun = i > 0;
133: 		if (hotrun) {
134: 			Log(StringUtil::Format("%d/%d...", i, nruns));
135: 		} else {
136: 			Log("Cold run...");
137: 		}
138: 		if (hotrun && benchmark->RequireReinit()) {
139: 			state = benchmark->Initialize();
140: 		}
141: 		is_active = true;
142: 		timeout = false;
143: 		thread interrupt_thread(sleep_thread, benchmark, state.get(), benchmark->Timeout());
144: 
145: 		profiler.Start();
146: 		benchmark->Run(state.get());
147: 		profiler.End();
148: 
149: 		benchmark->Cleanup(state.get());
150: 
151: 		is_active = false;
152: 		interrupt_thread.join();
153: 		if (hotrun) {
154: 			LogOutput(benchmark->GetLogOutput(state.get()));
155: 			if (timeout) {
156: 				// write timeout
157: 				LogResult("TIMEOUT");
158: 				break;
159: 			} else {
160: 				// write time
161: 				auto verify = benchmark->Verify(state.get());
162: 				if (!verify.empty()) {
163: 					LogResult("INCORRECT");
164: 					LogLine("INCORRECT RESULT: " + verify);
165: 					LogOutput("INCORRECT RESULT: " + verify);
166: 					break;
167: 				} else {
168: 					LogResult(to_string(profiler.Elapsed()));
169: 				}
170: 			}
171: 		} else {
172: 			LogLine("DONE");
173: 		}
174: 	}
175: 	benchmark->Finalize();
176: }
177: 
178: void BenchmarkRunner::RunBenchmarks() {
179: 	LogLine("Starting benchmark run.");
180: 	for (auto &benchmark : benchmarks) {
181: 		RunBenchmark(benchmark);
182: 	}
183: }
184: 
185: void print_help() {
186: 	fprintf(stderr, "Usage: benchmark_runner\n");
187: 	fprintf(stderr, "              --list         Show a list of all benchmarks\n");
188: 	fprintf(stderr, "              --out=[file]   Move benchmark output to file\n");
189: 	fprintf(stderr, "              --log=[file]   Move log output to file\n");
190: 	fprintf(stderr, "              --info         Prints info about the benchmark\n");
191: 	fprintf(stderr, "              --group        Prints group name of the benchmark\n");
192: 	fprintf(stderr, "              --query        Prints query of the benchmark\n");
193: 	fprintf(stderr, "              [name_pattern] Run only the benchmark which names match the specified name pattern, "
194: 	                "e.g., DS.* for TPC-DS benchmarks\n");
195: }
196: 
197: enum class BenchmarkMetaType { NONE, INFO, GROUP, QUERY };
198: 
199: struct BenchmarkConfiguration {
200: 	std::string name_pattern{};
201: 	BenchmarkMetaType meta = BenchmarkMetaType::NONE;
202: };
203: 
204: enum ConfigurationError { None, BenchmarkNotFound, InfoWithoutBenchmarkName };
205: 
206: /**
207:  * Builds a configuration based on the passed arguments.
208:  */
209: BenchmarkConfiguration parse_arguments(const int arg_counter, char const *const *arg_values) {
210: 	auto &instance = BenchmarkRunner::GetInstance();
211: 	auto &benchmarks = instance.benchmarks;
212: 	BenchmarkConfiguration configuration;
213: 	for (int arg_index = 1; arg_index < arg_counter; ++arg_index) {
214: 		string arg = arg_values[arg_index];
215: 		if (arg == "--list") {
216: 			// list names of all benchmarks
217: 			for (auto &benchmark : benchmarks) {
218: 				fprintf(stdout, "%s\n", benchmark->name.c_str());
219: 			}
220: 			exit(0);
221: 		} else if (arg == "--info") {
222: 			// write info of benchmark
223: 			configuration.meta = BenchmarkMetaType::INFO;
224: 		} else if (arg == "--group") {
225: 			// write group of benchmark
226: 			configuration.meta = BenchmarkMetaType::GROUP;
227: 		} else if (arg == "--query") {
228: 			// write group of benchmark
229: 			configuration.meta = BenchmarkMetaType::QUERY;
230: 		} else if (StringUtil::StartsWith(arg, "--out=") || StringUtil::StartsWith(arg, "--log=")) {
231: 			auto splits = StringUtil::Split(arg, '=');
232: 			if (splits.size() != 2) {
233: 				print_help();
234: 				exit(1);
235: 			}
236: 			auto &file = StringUtil::StartsWith(arg, "--out=") ? instance.out_file : instance.log_file;
237: 			file.open(splits[1]);
238: 			if (!file.good()) {
239: 				fprintf(stderr, "Could not open file %s for writing\n", splits[1].c_str());
240: 				exit(1);
241: 			}
242: 		} else {
243: 			if (!configuration.name_pattern.empty()) {
244: 				fprintf(stderr, "Only one benchmark can be specified.\n");
245: 				print_help();
246: 				exit(1);
247: 			}
248: 			configuration.name_pattern = arg;
249: 		}
250: 	}
251: 	return configuration;
252: }
253: 
254: /**
255:  * Runs the benchmarks specified by the configuration if possible.
256:  * Returns an configuration error code.
257:  */
258: ConfigurationError run_benchmarks(const BenchmarkConfiguration &configuration) {
259: 	auto &instance = BenchmarkRunner::GetInstance();
260: 	// first load interpreted benchmarks
261: 	FileSystem fs;
262: 	listFiles(fs, "benchmark", [](string path) {
263: 		if (endsWith(path, ".benchmark")) {
264: 			new InterpretedBenchmark(path);
265: 		}
266: 	});
267: 	auto &benchmarks = instance.benchmarks;
268: 	if (!configuration.name_pattern.empty()) {
269: 		// run only benchmarks which names matches the
270: 		// passed name pattern.
271: 		std::vector<int> benchmark_indices{};
272: 		benchmark_indices.reserve(benchmarks.size());
273: 		for (idx_t index = 0; index < benchmarks.size(); ++index) {
274: 			if (RE2::FullMatch(benchmarks[index]->name, configuration.name_pattern)) {
275: 				benchmark_indices.emplace_back(index);
276: 			} else if (RE2::FullMatch(benchmarks[index]->group, configuration.name_pattern)) {
277: 				benchmark_indices.emplace_back(index);
278: 			}
279: 		}
280: 		benchmark_indices.shrink_to_fit();
281: 		if (benchmark_indices.empty()) {
282: 			return ConfigurationError::BenchmarkNotFound;
283: 		}
284: 		if (configuration.meta == BenchmarkMetaType::INFO) {
285: 			// print info of benchmarks
286: 			for (const auto &benchmark_index : benchmark_indices) {
287: 				auto info = benchmarks[benchmark_index]->GetInfo();
288: 				fprintf(stdout, "%s\n", info.c_str());
289: 			}
290: 		} else if (configuration.meta == BenchmarkMetaType::GROUP) {
291: 			// print group of benchmarks
292: 			for (const auto &benchmark_index : benchmark_indices) {
293: 				fprintf(stdout, "%s\n", benchmarks[benchmark_index]->group.c_str());
294: 			}
295: 		} else if (configuration.meta == BenchmarkMetaType::QUERY) {
296: 			for (const auto &benchmark_index : benchmark_indices) {
297: 				auto query = benchmarks[benchmark_index]->GetQuery();
298: 				if (query.empty()) {
299: 					continue;
300: 				}
301: 				fprintf(stdout, "%s\n", query.c_str());
302: 			}
303: 		} else {
304: 			for (const auto &benchmark_index : benchmark_indices) {
305: 				instance.RunBenchmark(benchmarks[benchmark_index]);
306: 			}
307: 		}
308: 	} else {
309: 		if (configuration.meta != BenchmarkMetaType::NONE) {
310: 			return ConfigurationError::InfoWithoutBenchmarkName;
311: 		}
312: 		// default: run all benchmarks
313: 		instance.RunBenchmarks();
314: 	}
315: 	return ConfigurationError::None;
316: }
317: 
318: void print_error_message(const ConfigurationError &error) {
319: 	switch (error) {
320: 	case ConfigurationError::BenchmarkNotFound:
321: 		fprintf(stderr, "Benchmark to run could not be found.\n");
322: 		break;
323: 	case ConfigurationError::InfoWithoutBenchmarkName:
324: 		fprintf(stderr, "Info requires benchmark name pattern.\n");
325: 		break;
326: 	case ConfigurationError::None:
327: 		break;
328: 	}
329: 	print_help();
330: }
331: 
332: int main(int argc, char **argv) {
333: 	BenchmarkConfiguration configuration = parse_arguments(argc, argv);
334: 	const auto configuration_error = run_benchmarks(configuration);
335: 	if (configuration_error != ConfigurationError::None) {
336: 		print_error_message(configuration_error);
337: 		exit(1);
338: 	}
339: }
[end of benchmark/benchmark_runner.cpp]
[start of benchmark/interpreted_benchmark.cpp]
1: #include "interpreted_benchmark.hpp"
2: #include "benchmark_runner.hpp"
3: #include "duckdb.hpp"
4: 
5: #include <fstream>
6: #include <sstream>
7: 
8: #include "duckdb/common/string_util.hpp"
9: #include "duckdb/main/client_context.hpp"
10: 
11: #include "extension_helper.hpp"
12: 
13: namespace duckdb {
14: 
15: static string ParseGroupFromPath(string file) {
16: 	string extension = "";
17: 	// move backwards to the last slash
18: 	int group_begin = -1, group_end = -1;
19: 	for (size_t i = file.size(); i > 0; i--) {
20: 		if (file[i - 1] == '/' || file[i - 1] == '\\') {
21: 			if (group_end == -1) {
22: 				group_end = i - 1;
23: 			} else {
24: 				group_begin = i;
25: 				return "[" + file.substr(group_begin, group_end - group_begin) + "]" + extension;
26: 			}
27: 		}
28: 	}
29: 	if (group_end == -1) {
30: 		return "[" + file + "]" + extension;
31: 	}
32: 	return "[" + file.substr(0, group_end) + "]" + extension;
33: }
34: 
35: struct InterpretedBenchmarkState : public BenchmarkState {
36: 	DuckDB db;
37: 	Connection con;
38: 	unique_ptr<MaterializedQueryResult> result;
39: 
40: 	InterpretedBenchmarkState() : db(nullptr), con(db) {
41: 		con.EnableProfiling();
42: 	}
43: };
44: 
45: struct BenchmarkFileReader {
46: 	BenchmarkFileReader(string path_, unordered_map<std::string, std::string> replacement_map)
47: 	    : path(path_), infile(path), linenr(0), replacements(replacement_map) {
48: 	}
49: 
50: public:
51: 	bool ReadLine(std::string &line) {
52: 		if (!std::getline(infile, line)) {
53: 			return false;
54: 		}
55: 		linenr++;
56: 		for (auto &replacement : replacements) {
57: 			line = StringUtil::Replace(line, "${" + replacement.first + "}", replacement.second);
58: 		}
59: 		StringUtil::Trim(line);
60: 		return true;
61: 	}
62: 
63: 	int LineNumber() {
64: 		return linenr;
65: 	}
66: 
67: 	std::string FormatException(string exception_msg) {
68: 		return path + ":" + to_string(linenr) + " - " + exception_msg;
69: 	}
70: 
71: private:
72: 	std::string path;
73: 	std::ifstream infile;
74: 	int linenr;
75: 	unordered_map<std::string, std::string> replacements;
76: };
77: 
78: InterpretedBenchmark::InterpretedBenchmark(string full_path)
79:     : Benchmark(true, full_path, ParseGroupFromPath(full_path)), benchmark_path(full_path) {
80: 	replacement_mapping["BENCHMARK_DIR"] = BenchmarkRunner::DUCKDB_BENCHMARK_DIRECTORY;
81: }
82: 
83: void InterpretedBenchmark::LoadBenchmark() {
84: 	BenchmarkFileReader reader(benchmark_path, replacement_mapping);
85: 	string line;
86: 	while (reader.ReadLine(line)) {
87: 		// skip blank lines and comments
88: 		if (line.empty() || line[0] == '#') {
89: 			continue;
90: 		}
91: 		// look for a command in this line
92: 		auto splits = StringUtil::Split(StringUtil::Lower(line), ' ');
93: 		if (splits[0] == "load" || splits[0] == "run" || splits[0] == "init" || splits[0] == "cleanup") {
94: 			if (queries.find(splits[0]) != queries.end()) {
95: 				throw std::runtime_error("Multiple calls to " + splits[0] + " in the same benchmark file");
96: 			}
97: 			// load command: keep reading until we find a blank line or EOF
98: 			string query;
99: 			while (reader.ReadLine(line)) {
100: 				if (line.empty()) {
101: 					break;
102: 				} else {
103: 					query += line + " ";
104: 				}
105: 			}
106: 			queries[splits[0]] = query;
107: 		} else if (splits[0] == "require") {
108: 			if (splits.size() != 2) {
109: 				throw std::runtime_error(reader.FormatException("require requires a single parameter"));
110: 			}
111: 			extensions.insert(splits[1]);
112: 		} else if (splits[0] == "cache") {
113: 			if (splits.size() != 2) {
114: 				throw std::runtime_error(reader.FormatException("cache requires a single parameter"));
115: 			}
116: 			data_cache = splits[1];
117: 		} else if (splits[0] == "result") {
118: 			if (result_column_count > 0) {
119: 				throw std::runtime_error(reader.FormatException("multiple results found"));
120: 			}
121: 			// count the amount of columns
122: 			if (splits.size() <= 1 || splits[1].size() == 0) {
123: 				throw std::runtime_error(
124: 				    reader.FormatException("result must be followed by a column count (e.g. result III) or a file "
125: 				                           "(e.g. result /path/to/file.csv)"));
126: 			}
127: 			bool is_file = false;
128: 			for (idx_t i = 0; i < splits[1].size(); i++) {
129: 				if (splits[1][i] != 'i') {
130: 					is_file = true;
131: 					break;
132: 				}
133: 			}
134: 			if (is_file) {
135: 				// read the results from the file
136: 				result_column_count = -1;
137: 				std::ifstream csv_infile(splits[1]);
138: 				bool skipped_header = false;
139: 				while (std::getline(csv_infile, line)) {
140: 					if (line.empty()) {
141: 						break;
142: 					}
143: 					if (!skipped_header) {
144: 						skipped_header = true;
145: 						continue;
146: 					}
147: 					auto result_splits = StringUtil::Split(line, "|");
148: 					if (result_column_count < 0) {
149: 						result_column_count = result_splits.size();
150: 					} else if (result_column_count != result_splits.size()) {
151: 						throw std::runtime_error("error in file " + splits[1] + ", inconsistent amount of rows in CSV");
152: 					}
153: 					result_values.push_back(move(result_splits));
154: 				}
155: 
156: 				// read the main file until we encounter an empty line
157: 				while (reader.ReadLine(line)) {
158: 					if (line.empty()) {
159: 						break;
160: 					}
161: 				}
162: 			} else {
163: 				result_column_count = splits[1].size();
164: 				// keep reading results until eof
165: 				while (reader.ReadLine(line)) {
166: 					if (line.empty()) {
167: 						break;
168: 					}
169: 					auto result_splits = StringUtil::Split(line, "\t");
170: 					if ((int64_t)result_splits.size() != result_column_count) {
171: 						throw std::runtime_error(reader.FormatException("expected " + to_string(result_column_count) +
172: 						                                                " values but got " +
173: 						                                                to_string(result_splits.size())));
174: 					}
175: 					result_values.push_back(move(result_splits));
176: 				}
177: 			}
178: 		} else if (splits[0] == "template") {
179: 			// template: update the path to read
180: 			benchmark_path = splits[1];
181: 			// now read parameters
182: 			while (reader.ReadLine(line)) {
183: 				if (line.empty()) {
184: 					break;
185: 				}
186: 				auto parameters = StringUtil::Split(line, '=');
187: 				if (parameters.size() != 2) {
188: 					throw std::runtime_error(
189: 					    reader.FormatException("Expected a template parameter in the form of X=Y"));
190: 				}
191: 				replacement_mapping[parameters[0]] = parameters[1];
192: 			}
193: 			// restart the load from the template file
194: 			LoadBenchmark();
195: 			return;
196: 		} else {
197: 			throw std::runtime_error(reader.FormatException("unrecognized command " + splits[0]));
198: 		}
199: 	}
200: }
201: 
202: unique_ptr<BenchmarkState> InterpretedBenchmark::Initialize() {
203: 	unique_ptr<QueryResult> result;
204: 	LoadBenchmark();
205: 	if (queries.find("run") == queries.end()) {
206: 		throw Exception("Invalid benchmark file: no \"run\" query specified");
207: 	}
208: 	run_query = queries["run"];
209: 
210: 	auto state = make_unique<InterpretedBenchmarkState>();
211: 	for (auto &extension : extensions) {
212: 		auto result = ExtensionHelper::LoadExtension(state->db, extension);
213: 		if (result == ExtensionLoadResult::EXTENSION_UNKNOWN) {
214: 			throw std::runtime_error("Unknown extension " + extension);
215: 		} else if (result == ExtensionLoadResult::NOT_LOADED) {
216: 			throw std::runtime_error("Extension " + extension +
217: 			                         " is not available/was not compiled. Cannot run this benchmark.");
218: 		}
219: 	}
220: 
221: 	if (queries.find("init") != queries.end()) {
222: 		string init_query = queries["init"];
223: 		result = state->con.Query(init_query);
224: 		while (result) {
225: 			if (!result->success) {
226: 				throw Exception(result->error);
227: 			}
228: 			result = move(result->next);
229: 		}
230: 	}
231: 
232: 	string load_query;
233: 	if (queries.find("load") != queries.end()) {
234: 		load_query = queries["load"];
235: 	}
236: 
237: 	if (data_cache.empty()) {
238: 		// no cache specified: just run the initialization code
239: 		result = state->con.Query(load_query);
240: 	} else {
241: 		// cache specified: try to load the cache
242: 		if (!BenchmarkRunner::TryLoadDatabase(state->db, data_cache)) {
243: 			// failed to load: write the cache
244: 			result = state->con.Query(load_query);
245: 			BenchmarkRunner::SaveDatabase(state->db, data_cache);
246: 		}
247: 	}
248: 	while (result) {
249: 		if (!result->success) {
250: 			throw Exception(result->error);
251: 		}
252: 		result = move(result->next);
253: 	}
254: 	return state;
255: }
256: 
257: void InterpretedBenchmark::Run(BenchmarkState *state_) {
258: 	auto &state = (InterpretedBenchmarkState &)*state_;
259: 	state.result = state.con.Query(run_query);
260: }
261: 
262: void InterpretedBenchmark::Cleanup(BenchmarkState *state_) {
263: 	auto &state = (InterpretedBenchmarkState &)*state_;
264: 	if (queries.find("cleanup") != queries.end()) {
265: 		unique_ptr<QueryResult> result;
266: 		string cleanup_query = queries["cleanup"];
267: 		result = state.con.Query(cleanup_query);
268: 		while (result) {
269: 			if (!result->success) {
270: 				throw Exception(result->error);
271: 			}
272: 			result = move(result->next);
273: 		}
274: 	}
275: }
276: 
277: string InterpretedBenchmark::Verify(BenchmarkState *state_) {
278: 	auto &state = (InterpretedBenchmarkState &)*state_;
279: 	if (!state.result->success) {
280: 		return state.result->error;
281: 	}
282: 	if (result_column_count == 0) {
283: 		// no result specified
284: 		return string();
285: 	}
286: 	// compare the column count
287: 	if ((int64_t)state.result->column_count() != result_column_count) {
288: 		return StringUtil::Format("Error in result: expected %lld columns but got %lld\nObtained result: %s",
289: 		                          (int64_t)result_column_count, (int64_t)state.result->column_count(),
290: 		                          state.result->ToString());
291: 	}
292: 	// compare row count
293: 	if (state.result->collection.count != result_values.size()) {
294: 		return StringUtil::Format("Error in result: expected %lld rows but got %lld\nObtained result: %s",
295: 		                          (int64_t)state.result->collection.count, (int64_t)result_values.size(),
296: 		                          state.result->ToString());
297: 	}
298: 	// compare values
299: 	for (int64_t r = 0; r < (int64_t)result_values.size(); r++) {
300: 		for (int64_t c = 0; c < result_column_count; c++) {
301: 			auto value = state.result->collection.GetValue(c, r);
302: 			Value verify_val(result_values[r][c]);
303: 			verify_val = verify_val.CastAs(state.result->types[c]);
304: 			if (!Value::ValuesAreEqual(value, verify_val)) {
305: 				return StringUtil::Format(
306: 				    "Error in result on row %lld column %lld: expected value \"%s\" but got value \"%s\"", r + 1, c + 1,
307: 				    verify_val.ToString().c_str(), value.ToString().c_str());
308: 			}
309: 		}
310: 	}
311: 	return string();
312: }
313: 
314: void InterpretedBenchmark::Interrupt(BenchmarkState *state_) {
315: 	auto &state = (InterpretedBenchmarkState &)*state_;
316: 	state.con.Interrupt();
317: }
318: 
319: string InterpretedBenchmark::BenchmarkInfo() {
320: 	return name + " - " + run_query;
321: }
322: 
323: string InterpretedBenchmark::GetLogOutput(BenchmarkState *state_) {
324: 	auto &state = (InterpretedBenchmarkState &)*state_;
325: 	return state.con.context->profiler.ToJSON();
326: }
327: 
328: } // namespace duckdb
[end of benchmark/interpreted_benchmark.cpp]
[start of benchmark/micro/CMakeLists.txt]
1: include_directories(../../third_party/sqlite/include)
2: add_library(
3:   duckdb_benchmark_micro OBJECT
4:   append.cpp
5:   bulkupdate.cpp
6:   cast.cpp
7:   data_skipping.cpp
8:   groupby.cpp
9:   in.cpp
10:   multiplications.cpp
11:   orderby.cpp
12:   pointquery.cpp
13:   indexcreation.cpp
14:   rangejoin.cpp
15:   rangequery.cpp
16:   string.cpp
17:   window.cpp
18:   storage.cpp)
19: set(BENCHMARK_OBJECT_FILES
20:     ${BENCHMARK_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_benchmark_micro>
21:     PARENT_SCOPE)
[end of benchmark/micro/CMakeLists.txt]
[start of benchmark/micro/pointquery.cpp]
1: #include "benchmark_runner.hpp"
2: #include "duckdb_benchmark_macro.hpp"
3: #include "duckdb/main/appender.hpp"
4: 
5: #include <random>
6: 
7: using namespace duckdb;
8: using namespace std;
9: 
10: #define POINT_QUERY_ROW_COUNT 100000000
11: #define POINT_QUERY_ENTRY 50000
12: 
13: DUCKDB_BENCHMARK(PointQueryWithoutIndex, "[micro]")
14: virtual void Load(DuckDBBenchmarkState *state) {
15: 	state->conn.Query("CREATE TABLE integers(i INTEGER, j INTEGER);");
16: 	Appender appender(state->conn, "integers"); // insert the elements into the database
17: 	for (size_t i = 0; i < POINT_QUERY_ROW_COUNT; i++) {
18: 		appender.BeginRow();
19: 		appender.Append<int32_t>(i);
20: 		appender.Append<int32_t>(i + 2);
21: 		appender.EndRow();
22: 	}
23: }
24: 
25: virtual string GetQuery() {
26: 	return "SELECT j FROM integers WHERE i=" + to_string(POINT_QUERY_ENTRY);
27: }
28: 
29: virtual string VerifyResult(QueryResult *result) {
30: 	if (!result->success) {
31: 		return result->error;
32: 	}
33: 	auto &materialized = (MaterializedQueryResult &)*result;
34: 	if (materialized.collection.count != 1) {
35: 		return "Incorrect amount of rows in result";
36: 	}
37: 	if (materialized.names.size() != 1) {
38: 		return "Incorrect amount of columns";
39: 	}
40: 	if (materialized.GetValue<int32_t>(0, 0) != POINT_QUERY_ENTRY + 2) {
41: 		return "Incorrect result returned, expected " + to_string(POINT_QUERY_ENTRY + 2);
42: 	}
43: 	return string();
44: }
45: 
46: virtual string BenchmarkInfo() {
47: 	return StringUtil::Format("Runs the following query: \"" + GetQuery() + "\" without an index");
48: }
49: FINISH_BENCHMARK(PointQueryWithoutIndex)
50: 
51: DUCKDB_BENCHMARK(PointQueryWithIndexART, "[micro]")
52: virtual void Load(DuckDBBenchmarkState *state) {
53: 	state->conn.Query("CREATE TABLE integers(i INTEGER, j INTEGER);");
54: 	Appender appender(state->conn, "integers"); // insert the elements into the database
55: 	for (size_t i = 0; i < POINT_QUERY_ROW_COUNT; i++) {
56: 		appender.BeginRow();
57: 		appender.Append<int32_t>(i);
58: 		appender.Append<int32_t>(i + 2);
59: 		appender.EndRow();
60: 	}
61: 	appender.Close();
62: 	state->conn.Query("CREATE INDEX i_index ON integers using art(i)");
63: }
64: 
65: virtual string GetQuery() {
66: 	return "SELECT j FROM integers WHERE i=" + to_string(POINT_QUERY_ENTRY);
67: }
68: 
69: virtual string VerifyResult(QueryResult *result) {
70: 	if (!result->success) {
71: 		return result->error;
72: 	}
73: 	auto &materialized = (MaterializedQueryResult &)*result;
74: 	if (materialized.collection.count != 1) {
75: 		return "Incorrect amount of rows in result";
76: 	}
77: 	if (materialized.names.size() != 1) {
78: 		return "Incorrect amount of columns";
79: 	}
80: 	if (materialized.GetValue<int32_t>(0, 0) != POINT_QUERY_ENTRY + 2) {
81: 		return "Incorrect result returned, expected " + to_string(POINT_QUERY_ENTRY + 2);
82: 	}
83: 	return string();
84: }
85: 
86: virtual string BenchmarkInfo() {
87: 	return StringUtil::Format("Runs the following query: \"" + GetQuery() + "\" with an ART index");
88: }
89: FINISH_BENCHMARK(PointQueryWithIndexART)
[end of benchmark/micro/pointquery.cpp]
[start of extension/parquet/parquet-extension.cpp]
1: #include <string>
2: #include <vector>
3: #include <bitset>
4: #include <fstream>
5: #include <cstring>
6: #include <iostream>
7: #include <sstream>
8: 
9: #include "parquet-extension.hpp"
10: 
11: #ifndef DUCKDB_AMALGAMATION
12: #include "duckdb/function/table_function.hpp"
13: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
14: #include "duckdb/parser/parsed_data/create_copy_function_info.hpp"
15: #include "duckdb/main/client_context.hpp"
16: #include "duckdb/main/connection.hpp"
17: #include "duckdb/common/types/date.hpp"
18: #include "duckdb/common/types/time.hpp"
19: #include "duckdb/common/types/timestamp.hpp"
20: #include "duckdb/common/serializer/buffered_file_writer.hpp"
21: #include "duckdb/common/serializer/buffered_serializer.hpp"
22: 
23: #include "utf8proc_wrapper.hpp"
24: 
25: #include "thrift/protocol/TCompactProtocol.h"
26: #include "thrift/transport/TBufferTransports.h"
27: #include "parquet_types.h"
28: #include "snappy.h"
29: #include "miniz.hpp"
30: #endif
31: 
32: using namespace duckdb;
33: using namespace duckdb_miniz;
34: using namespace std;
35: 
36: using namespace parquet;
37: using namespace apache::thrift;
38: using namespace apache::thrift::protocol;
39: using namespace apache::thrift::transport;
40: 
41: using parquet::format::CompressionCodec;
42: using parquet::format::Encoding;
43: using parquet::format::FieldRepetitionType;
44: using parquet::format::FileMetaData;
45: using parquet::format::PageHeader;
46: using parquet::format::PageType;
47: using parquet::format::RowGroup;
48: using parquet::format::Type;
49: 
50: struct Int96 {
51: 	uint32_t value[3];
52: };
53: 
54: class ByteBuffer { // on to the 10 thousandth impl
55: public:
56: 	char *ptr = nullptr;
57: 	uint64_t len = 0;
58: 
59: 	ByteBuffer(){};
60: 	ByteBuffer(char *ptr, uint64_t len) : ptr(ptr), len(len){};
61: 
62: 	void inc(uint64_t increment) {
63: 		available(increment);
64: 		len -= increment;
65: 		ptr += increment;
66: 	}
67: 
68: 	template <class T> T read() {
69: 		available(sizeof(T));
70: 		T val = *(T *)ptr;
71: 		inc(sizeof(T));
72: 		return val;
73: 	}
74: 
75: 	void copy_to(char *dest, uint64_t len) {
76: 		available(len);
77: 		memcpy(dest, ptr, len);
78: 	}
79: 
80: 	void available(uint64_t req_len) {
81: 		if (req_len > len) {
82: 			throw runtime_error("Out of buffer");
83: 		}
84: 	}
85: };
86: 
87: class ResizeableBuffer : public ByteBuffer {
88: public:
89: 	void resize(uint64_t new_size) {
90: 		if (new_size > len) {
91: 			auto new_holder = std::unique_ptr<char[]>(new char[new_size]);
92: 			holder = move(new_holder);
93: 		}
94: 		len = new_size;
95: 		ptr = holder.get();
96: 	}
97: 
98: private:
99: 	std::unique_ptr<char[]> holder = nullptr;
100: };
101: 
102: static TCompactProtocolFactoryT<TMemoryBuffer> tproto_factory;
103: 
104: template <class T> static void thrift_unpack(const uint8_t *buf, uint32_t *len, T *deserialized_msg) {
105: 	shared_ptr<TMemoryBuffer> tmem_transport(new TMemoryBuffer(const_cast<uint8_t *>(buf), *len));
106: 	shared_ptr<TProtocol> tproto = tproto_factory.getProtocol(tmem_transport);
107: 	try {
108: 		deserialized_msg->read(tproto.get());
109: 	} catch (std::exception &e) {
110: 		std::stringstream ss;
111: 		ss << "Couldn't deserialize thrift: " << e.what() << "\n";
112: 		throw std::runtime_error(ss.str());
113: 	}
114: 	uint32_t bytes_left = tmem_transport->available_read();
115: 	*len = *len - bytes_left;
116: }
117: 
118: // adapted from arrow parquet reader
119: class RleBpDecoder {
120: 
121: public:
122: 	/// Create a decoder object. buffer/buffer_len is the decoded data.
123: 	/// bit_width is the width of each value (before encoding).
124: 	RleBpDecoder(const uint8_t *buffer, uint32_t buffer_len, uint32_t bit_width)
125: 	    : buffer(buffer), bit_width_(bit_width), current_value_(0), repeat_count_(0), literal_count_(0) {
126: 
127: 		if (bit_width >= 64) {
128: 			throw runtime_error("Decode bit width too large");
129: 		}
130: 		byte_encoded_len = ((bit_width_ + 7) / 8);
131: 		max_val = (1 << bit_width_) - 1;
132: 	}
133: 
134: 	/// Gets a batch of values.  Returns the number of decoded elements.
135: 	template <typename T> void GetBatch(char *values_target_ptr, uint32_t batch_size) {
136: 		auto values = (T *)values_target_ptr;
137: 		uint32_t values_read = 0;
138: 
139: 		while (values_read < batch_size) {
140: 			if (repeat_count_ > 0) {
141: 				int repeat_batch = std::min(batch_size - values_read, static_cast<uint32_t>(repeat_count_));
142: 				std::fill(values + values_read, values + values_read + repeat_batch, static_cast<T>(current_value_));
143: 				repeat_count_ -= repeat_batch;
144: 				values_read += repeat_batch;
145: 			} else if (literal_count_ > 0) {
146: 				uint32_t literal_batch = std::min(batch_size - values_read, static_cast<uint32_t>(literal_count_));
147: 				uint32_t actual_read = BitUnpack<T>(values + values_read, literal_batch);
148: 				if (literal_batch != actual_read) {
149: 					throw runtime_error("Did not find enough values");
150: 				}
151: 				literal_count_ -= literal_batch;
152: 				values_read += literal_batch;
153: 			} else {
154: 				if (!NextCounts<T>()) {
155: 					if (values_read != batch_size) {
156: 						throw runtime_error("RLE decode did not find enough values");
157: 					}
158: 					return;
159: 				}
160: 			}
161: 		}
162: 		if (values_read != batch_size) {
163: 			throw runtime_error("RLE decode did not find enough values");
164: 		}
165: 	}
166: 
167: private:
168: 	const uint8_t *buffer;
169: 
170: 	/// Number of bits needed to encode the value. Must be between 0 and 64.
171: 	int bit_width_;
172: 	uint64_t current_value_;
173: 	uint32_t repeat_count_;
174: 	uint32_t literal_count_;
175: 	uint8_t byte_encoded_len;
176: 	uint32_t max_val;
177: 
178: 	int8_t bitpack_pos = 0;
179: 
180: 	// this is slow but whatever, calls are rare
181: 	static uint8_t VarintDecode(const uint8_t *source, uint32_t *result_out) {
182: 		uint32_t result = 0;
183: 		uint8_t shift = 0;
184: 		uint8_t len = 0;
185: 		while (true) {
186: 			auto byte = *source++;
187: 			len++;
188: 			result |= (byte & 127) << shift;
189: 			if ((byte & 128) == 0)
190: 				break;
191: 			shift += 7;
192: 			if (shift > 32) {
193: 				throw runtime_error("Varint-decoding found too large number");
194: 			}
195: 		}
196: 		*result_out = result;
197: 		return len;
198: 	}
199: 
200: 	/// Fills literal_count_ and repeat_count_ with next values. Returns false if there
201: 	/// are no more.
202: 	template <typename T> bool NextCounts() {
203: 		// Read the next run's indicator int, it could be a literal or repeated run.
204: 		// The int is encoded as a vlq-encoded value.
205: 		uint32_t indicator_value;
206: 		if (bitpack_pos != 0) {
207: 			buffer++;
208: 			bitpack_pos = 0;
209: 		}
210: 		buffer += VarintDecode(buffer, &indicator_value);
211: 
212: 		// lsb indicates if it is a literal run or repeated run
213: 		bool is_literal = indicator_value & 1;
214: 		if (is_literal) {
215: 			literal_count_ = (indicator_value >> 1) * 8;
216: 		} else {
217: 			repeat_count_ = indicator_value >> 1;
218: 			// (ARROW-4018) this is not big-endian compatible, lol
219: 			current_value_ = 0;
220: 			for (auto i = 0; i < byte_encoded_len; i++) {
221: 				current_value_ |= ((uint8_t)*buffer++) << (i * 8);
222: 			}
223: 			// sanity check
224: 			if (repeat_count_ > 0 && current_value_ > max_val) {
225: 				throw runtime_error("Payload value bigger than allowed. Corrupted file?");
226: 			}
227: 		}
228: 		// TODO complain if we run out of buffer
229: 		return true;
230: 	}
231: 
232: 	// somewhat optimized implementation that avoids non-alignment
233: 
234: 	static const uint32_t BITPACK_MASKS[];
235: 	static const uint8_t BITPACK_DLEN;
236: 
237: 	template <typename T> uint32_t BitUnpack(T *dest, uint32_t count) {
238: 		assert(bit_width_ < 32);
239: 
240: 		// auto source = buffer;
241: 		auto mask = BITPACK_MASKS[bit_width_];
242: 
243: 		for (uint32_t i = 0; i < count; i++) {
244: 			T val = (*buffer >> bitpack_pos) & mask;
245: 			bitpack_pos += bit_width_;
246: 			while (bitpack_pos > BITPACK_DLEN) {
247: 				val |= (*++buffer << (BITPACK_DLEN - (bitpack_pos - bit_width_))) & mask;
248: 				bitpack_pos -= BITPACK_DLEN;
249: 			}
250: 			dest[i] = val;
251: 		}
252: 		return count;
253: 	}
254: };
255: 
256: const uint32_t RleBpDecoder::BITPACK_MASKS[] = {
257:     0,       1,       3,        7,        15,       31,        63,        127,       255,        511,       1023,
258:     2047,    4095,    8191,     16383,    32767,    65535,     131071,    262143,    524287,     1048575,   2097151,
259:     4194303, 8388607, 16777215, 33554431, 67108863, 134217727, 268435455, 536870911, 1073741823, 2147483647};
260: 
261: const uint8_t RleBpDecoder::BITPACK_DLEN = 8;
262: 
263: // surely they are joking
264: static constexpr int64_t kJulianToUnixEpochDays = 2440588LL;
265: static constexpr int64_t kMillisecondsInADay = 86400000LL;
266: static constexpr int64_t kNanosecondsInADay = kMillisecondsInADay * 1000LL * 1000LL;
267: 
268: static int64_t impala_timestamp_to_nanoseconds(const Int96 &impala_timestamp) {
269: 	int64_t days_since_epoch = impala_timestamp.value[2] - kJulianToUnixEpochDays;
270: 	int64_t nanoseconds = *(reinterpret_cast<const int64_t *>(&(impala_timestamp.value)));
271: 	return days_since_epoch * kNanosecondsInADay + nanoseconds;
272: }
273: 
274: static timestamp_t impala_timestamp_to_timestamp_t(const Int96 &raw_ts) {
275: 	auto impala_ns = impala_timestamp_to_nanoseconds(raw_ts);
276: 	auto ms = impala_ns / 1000000; // nanoseconds
277: 	auto ms_per_day = (int64_t)60 * 60 * 24 * 1000;
278: 	date_t date = Date::EpochToDate(ms / 1000);
279: 	dtime_t time = (dtime_t)(ms % ms_per_day);
280: 	return Timestamp::FromDatetime(date, time);
281: }
282: 
283: static Int96 timestamp_t_to_impala_timestamp(timestamp_t &ts) {
284: 	int32_t hour, min, sec, msec;
285: 	Time::Convert(Timestamp::GetTime(ts), hour, min, sec, msec);
286: 	uint64_t ms_since_midnight = hour * 60 * 60 * 1000 + min * 60 * 1000 + sec * 1000 + msec;
287: 	auto days_since_epoch = Date::Epoch(Timestamp::GetDate(ts)) / (24 * 60 * 60);
288: 	// first two uint32 in Int96 are nanoseconds since midnights
289: 	// last uint32 is number of days since year 4713 BC ("Julian date")
290: 	Int96 impala_ts;
291: 	*((uint64_t *)impala_ts.value) = ms_since_midnight * 1000000;
292: 	impala_ts.value[2] = days_since_epoch + kJulianToUnixEpochDays;
293: 	return impala_ts;
294: }
295: 
296: struct ParquetScanColumnData {
297: 	idx_t chunk_offset;
298: 
299: 	idx_t page_offset;
300: 	idx_t page_value_count = 0;
301: 
302: 	idx_t dict_size;
303: 
304: 	uint8_t byte_pos = 0; // to decode plain booleans from bit fields
305: 
306: 	ResizeableBuffer buf;
307: 	ResizeableBuffer decompressed_buf; // only used for compressed files
308: 	ResizeableBuffer dict;
309: 	ResizeableBuffer offset_buf;
310: 	ResizeableBuffer defined_buf;
311: 
312: 	ByteBuffer payload;
313: 
314: 	Encoding::type page_encoding;
315: 	// these point into buf or decompressed_buf
316: 	unique_ptr<RleBpDecoder> defined_decoder;
317: 	unique_ptr<RleBpDecoder> dict_decoder;
318: 
319: 	unique_ptr<ChunkCollection> string_collection;
320: };
321: 
322: struct ParquetScanFunctionData : public TableFunctionData {
323: 	static constexpr uint8_t GZIP_HEADER_MINSIZE = 10;
324: 	static constexpr uint8_t GZIP_COMPRESSION_DEFLATE = 0x08;
325: 	static constexpr unsigned char GZIP_FLAG_UNSUPPORTED = 0x1 | 0x2 | 0x4 | 0x10 | 0x20;
326: 
327: public:
328: 	void ReadChunk(DataChunk &output);
329: 	void PrepareChunkBuffer(idx_t col_idx);
330: 	bool PreparePageBuffers(idx_t col_idx);
331: 
332: 	template <class T>
333: 	static void _fill_from_dict(ParquetScanColumnData &col_data, idx_t count, Vector &target, idx_t target_offset) {
334: 		for (idx_t i = 0; i < count; i++) {
335: 			if (col_data.defined_buf.ptr[i]) {
336: 				auto offset = col_data.offset_buf.read<uint32_t>();
337: 				if (offset > col_data.dict_size) {
338: 					throw runtime_error("Offset " + to_string(offset) + " greater than dictionary size " +
339: 					                    to_string(col_data.dict_size) + " at " + to_string(i + target_offset) +
340: 					                    ". Corrupt file?");
341: 				}
342: 				((T *)FlatVector::GetData(target))[i + target_offset] = ((const T *)col_data.dict.ptr)[offset];
343: 			} else {
344: 				FlatVector::SetNull(target, i + target_offset, true);
345: 			}
346: 		}
347: 	}
348: 
349: 	template <class T>
350: 	static void _fill_from_plain(ParquetScanColumnData &col_data, idx_t count, Vector &target, idx_t target_offset) {
351: 		for (idx_t i = 0; i < count; i++) {
352: 			if (col_data.defined_buf.ptr[i]) {
353: 				((T *)FlatVector::GetData(target))[i + target_offset] = col_data.payload.read<T>();
354: 			} else {
355: 				FlatVector::SetNull(target, i + target_offset, true);
356: 			}
357: 		}
358: 	}
359: 
360: public:
361: 	int64_t current_group;
362: 	int64_t group_offset;
363: 
364: 	ifstream pfile;
365: 
366: 	FileMetaData file_meta_data;
367: 	vector<LogicalType> sql_types;
368: 	vector<ParquetScanColumnData> column_data;
369: 	bool finished;
370: };
371: 
372: bool ParquetScanFunctionData::PreparePageBuffers(idx_t col_idx) {
373: 	auto &col_data = column_data[col_idx];
374: 	auto &chunk = file_meta_data.row_groups[current_group].columns[col_idx];
375: 
376: 	// clean up a bit to avoid nasty surprises
377: 	col_data.payload.ptr = nullptr;
378: 	col_data.payload.len = 0;
379: 	col_data.dict_decoder = nullptr;
380: 	col_data.defined_decoder = nullptr;
381: 	col_data.byte_pos = 0;
382: 
383: 	auto page_header_len = col_data.buf.len;
384: 	if (page_header_len < 1) {
385: 		throw runtime_error("Ran out of bytes to read header from. File corrupt?");
386: 	}
387: 	PageHeader page_hdr;
388: 	thrift_unpack((const uint8_t *)col_data.buf.ptr + col_data.chunk_offset, (uint32_t *)&page_header_len, &page_hdr);
389: 
390: 	// the payload starts behind the header, obvsl.
391: 	col_data.buf.inc(page_header_len);
392: 
393: 	col_data.payload.len = page_hdr.uncompressed_page_size;
394: 
395: 	// handle compression, in the end we expect a pointer to uncompressed parquet data in payload_ptr
396: 	switch (chunk.meta_data.codec) {
397: 	case CompressionCodec::UNCOMPRESSED:
398: 		col_data.payload.ptr = col_data.buf.ptr;
399: 		break;
400: 
401: 	case CompressionCodec::SNAPPY: {
402: 		col_data.decompressed_buf.resize(page_hdr.uncompressed_page_size);
403: 		auto res =
404: 		    snappy::RawUncompress(col_data.buf.ptr, page_hdr.compressed_page_size, col_data.decompressed_buf.ptr);
405: 		if (!res) {
406: 			throw runtime_error("Decompression failure");
407: 		}
408: 		col_data.payload.ptr = col_data.decompressed_buf.ptr;
409: 		break;
410: 	}
411: 	case CompressionCodec::GZIP: {
412: 		struct MiniZStream {
413: 			~MiniZStream() {
414: 				if (init) {
415: 					mz_inflateEnd(&stream);
416: 				}
417: 			}
418: 
419: 			mz_stream stream;
420: 			bool init = false;
421: 		} s;
422: 		auto &stream = s.stream;
423: 		memset(&stream, 0, sizeof(mz_stream));
424: 
425: 		auto mz_ret = mz_inflateInit2(&stream, -MZ_DEFAULT_WINDOW_BITS);
426: 		if (mz_ret != MZ_OK) {
427: 			throw Exception("Failed to initialize miniz");
428: 		}
429: 		s.init = true;
430: 
431: 		col_data.buf.available(GZIP_HEADER_MINSIZE);
432: 		auto gzip_hdr = (const unsigned char *)col_data.buf.ptr;
433: 
434: 		if (gzip_hdr[0] != 0x1F || gzip_hdr[1] != 0x8B || gzip_hdr[2] != GZIP_COMPRESSION_DEFLATE ||
435: 		    gzip_hdr[3] & GZIP_FLAG_UNSUPPORTED) {
436: 			throw Exception("Input is invalid/unsupported GZIP stream");
437: 		}
438: 
439: 		col_data.decompressed_buf.resize(page_hdr.uncompressed_page_size);
440: 
441: 		stream.next_in = (const unsigned char *)col_data.buf.ptr + GZIP_HEADER_MINSIZE;
442: 		stream.avail_in = page_hdr.compressed_page_size - GZIP_HEADER_MINSIZE;
443: 		stream.next_out = (unsigned char *)col_data.decompressed_buf.ptr;
444: 		stream.avail_out = page_hdr.uncompressed_page_size;
445: 
446: 		mz_ret = mz_inflate(&stream, MZ_FINISH);
447: 		if (mz_ret != MZ_OK && mz_ret != MZ_STREAM_END) {
448: 			throw runtime_error("Decompression failure: " + string(mz_error(mz_ret)));
449: 		}
450: 
451: 		col_data.payload.ptr = col_data.decompressed_buf.ptr;
452: 		break;
453: 	}
454: 	default:
455: 		throw runtime_error("Unsupported compression codec. Try uncompressed, gzip or snappy");
456: 	}
457: 	col_data.buf.inc(page_hdr.compressed_page_size);
458: 
459: 	// handle page contents
460: 	switch (page_hdr.type) {
461: 	case PageType::DICTIONARY_PAGE: {
462: 		// fill the dictionary vector
463: 
464: 		if (page_hdr.__isset.data_page_header || !page_hdr.__isset.dictionary_page_header) {
465: 			throw runtime_error("Dictionary page header mismatch");
466: 		}
467: 
468: 		// make sure we like the encoding
469: 		switch (page_hdr.dictionary_page_header.encoding) {
470: 		case Encoding::PLAIN:
471: 		case Encoding::PLAIN_DICTIONARY: // deprecated
472: 			break;
473: 
474: 		default:
475: 			throw runtime_error("Dictionary page has unsupported/invalid encoding");
476: 		}
477: 
478: 		col_data.dict_size = page_hdr.dictionary_page_header.num_values;
479: 		auto dict_byte_size = col_data.dict_size * GetTypeIdSize(sql_types[col_idx].InternalType());
480: 
481: 		col_data.dict.resize(dict_byte_size);
482: 
483: 		switch (sql_types[col_idx].id()) {
484: 		case LogicalTypeId::BOOLEAN:
485: 		case LogicalTypeId::INTEGER:
486: 		case LogicalTypeId::BIGINT:
487: 		case LogicalTypeId::FLOAT:
488: 		case LogicalTypeId::DOUBLE:
489: 			col_data.payload.available(dict_byte_size);
490: 			// TODO this copy could be avoided if we use different buffers for dicts
491: 			col_data.payload.copy_to(col_data.dict.ptr, dict_byte_size);
492: 			break;
493: 		case LogicalTypeId::TIMESTAMP:
494: 			col_data.payload.available(dict_byte_size);
495: 			// immediately convert timestamps to duckdb format, potentially fewer conversions
496: 			for (idx_t dict_index = 0; dict_index < col_data.dict_size; dict_index++) {
497: 				((timestamp_t *)col_data.dict.ptr)[dict_index] =
498: 				    impala_timestamp_to_timestamp_t(((Int96 *)col_data.payload.ptr)[dict_index]);
499: 			}
500: 
501: 			break;
502: 		case LogicalTypeId::VARCHAR: {
503: 			// strings we directly fill a string heap that we can use for the vectors later
504: 			col_data.string_collection = make_unique<ChunkCollection>();
505: 
506: 			// we hand-roll a chunk collection to avoid copying strings
507: 			auto append_chunk = make_unique<DataChunk>();
508: 			vector<LogicalType> types = {LogicalType::VARCHAR};
509: 			col_data.string_collection->types = types;
510: 			append_chunk->Initialize(types);
511: 
512: 			for (idx_t dict_index = 0; dict_index < col_data.dict_size; dict_index++) {
513: 				uint32_t str_len = col_data.payload.read<uint32_t>();
514: 				col_data.payload.available(str_len);
515: 
516: 				if (append_chunk->size() == STANDARD_VECTOR_SIZE) {
517: 					col_data.string_collection->count += append_chunk->size();
518: 					col_data.string_collection->chunks.push_back(move(append_chunk));
519: 					append_chunk = make_unique<DataChunk>();
520: 					append_chunk->Initialize(types);
521: 				}
522: 
523: 				auto utf_type = Utf8Proc::Analyze(col_data.payload.ptr, str_len);
524: 				switch (utf_type) {
525: 				case UnicodeType::ASCII:
526: 					FlatVector::GetData<string_t>(append_chunk->data[0])[append_chunk->size()] =
527: 					    StringVector::AddString(append_chunk->data[0], col_data.payload.ptr, str_len);
528: 					break;
529: 				case UnicodeType::UNICODE:
530: 					// this regrettably copies to normalize
531: 					FlatVector::GetData<string_t>(append_chunk->data[0])[append_chunk->size()] =
532: 					    StringVector::AddString(append_chunk->data[0],
533: 					                            Utf8Proc::Normalize(string(col_data.payload.ptr, str_len)));
534: 
535: 					break;
536: 				case UnicodeType::INVALID:
537: 					throw runtime_error("invalid string encoding");
538: 				}
539: 
540: 				append_chunk->SetCardinality(append_chunk->size() + 1);
541: 				col_data.payload.inc(str_len);
542: 			}
543: 			// FLUSH last chunk!
544: 			if (append_chunk->size() > 0) {
545: 				col_data.string_collection->count += append_chunk->size();
546: 				col_data.string_collection->chunks.push_back(move(append_chunk));
547: 			}
548: 			col_data.string_collection->Verify();
549: 		} break;
550: 		default:
551: 			throw runtime_error(sql_types[col_idx].ToString());
552: 		}
553: 		// important, move to next page which should be a data page
554: 		return false;
555: 	}
556: 	case PageType::DATA_PAGE: {
557: 		if (!page_hdr.__isset.data_page_header || page_hdr.__isset.dictionary_page_header) {
558: 			throw runtime_error("Data page header mismatch");
559: 		}
560: 
561: 		if (page_hdr.__isset.data_page_header_v2) {
562: 			throw runtime_error("v2 data page format is not supported");
563: 		}
564: 
565: 		col_data.page_value_count = page_hdr.data_page_header.num_values;
566: 		col_data.page_encoding = page_hdr.data_page_header.encoding;
567: 
568: 		// we have to first decode the define levels
569: 		switch (page_hdr.data_page_header.definition_level_encoding) {
570: 		case Encoding::RLE: {
571: 			// read length of define payload, always
572: 			uint32_t def_length = col_data.payload.read<uint32_t>();
573: 			col_data.payload.available(def_length);
574: 			col_data.defined_decoder = make_unique<RleBpDecoder>((const uint8_t *)col_data.payload.ptr, def_length, 1);
575: 			col_data.payload.inc(def_length);
576: 		} break;
577: 		default:
578: 			throw runtime_error("Definition levels have unsupported/invalid encoding");
579: 		}
580: 
581: 		switch (page_hdr.data_page_header.encoding) {
582: 		case Encoding::RLE_DICTIONARY:
583: 		case Encoding::PLAIN_DICTIONARY: {
584: 			auto enc_length = col_data.payload.read<uint8_t>();
585: 			col_data.dict_decoder =
586: 			    make_unique<RleBpDecoder>((const uint8_t *)col_data.payload.ptr, col_data.payload.len, enc_length);
587: 			break;
588: 		}
589: 		case Encoding::PLAIN:
590: 			// nothing here, see below
591: 			break;
592: 
593: 		default:
594: 			throw runtime_error("Data page has unsupported/invalid encoding");
595: 		}
596: 
597: 		break;
598: 	}
599: 	case PageType::DATA_PAGE_V2:
600: 		throw runtime_error("v2 data page format is not supported");
601: 
602: 	default:
603: 		break; // ignore INDEX page type and any other custom extensions
604: 	}
605: 	return true;
606: }
607: 
608: void ParquetScanFunctionData::PrepareChunkBuffer(idx_t col_idx) {
609: 	auto &chunk = file_meta_data.row_groups[current_group].columns[col_idx];
610: 	if (chunk.__isset.file_path) {
611: 		throw runtime_error("Only inlined data files are supported (no references)");
612: 	}
613: 
614: 	if (chunk.meta_data.path_in_schema.size() != 1) {
615: 		throw runtime_error("Only flat tables are supported (no nesting)");
616: 	}
617: 
618: 	// ugh. sometimes there is an extra offset for the dict. sometimes it's wrong.
619: 	auto chunk_start = chunk.meta_data.data_page_offset;
620: 	if (chunk.meta_data.__isset.dictionary_page_offset && chunk.meta_data.dictionary_page_offset >= 4) {
621: 		// this assumes the data pages follow the dict pages directly.
622: 		chunk_start = chunk.meta_data.dictionary_page_offset;
623: 	}
624: 	auto chunk_len = chunk.meta_data.total_compressed_size;
625: 
626: 	// read entire chunk into RAM
627: 	pfile.seekg(chunk_start);
628: 	column_data[col_idx].buf.resize(chunk_len);
629: 	pfile.read(column_data[col_idx].buf.ptr, chunk_len);
630: 	if (!pfile) {
631: 		throw runtime_error("Could not read chunk. File corrupt?");
632: 	}
633: }
634: 
635: void ParquetScanFunctionData::ReadChunk(DataChunk &output) {
636: 	if (finished) {
637: 		return;
638: 	}
639: 
640: 	// see if we have to switch to the next row group in the parquet file
641: 	if (current_group < 0 || group_offset >= file_meta_data.row_groups[current_group].num_rows) {
642: 
643: 		current_group++;
644: 		group_offset = 0;
645: 
646: 		if ((idx_t)current_group == file_meta_data.row_groups.size()) {
647: 			finished = true;
648: 			return;
649: 		}
650: 
651: 		for (idx_t out_col_idx = 0; out_col_idx < output.column_count(); out_col_idx++) {
652: 			auto file_col_idx = column_ids[out_col_idx];
653: 
654: 			// this is a special case where we are not interested in the actual contents of the file
655: 			if (file_col_idx == COLUMN_IDENTIFIER_ROW_ID) {
656: 				continue;
657: 			}
658: 
659: 			PrepareChunkBuffer(file_col_idx);
660: 			// trigger the reading of a new page below
661: 			column_data[file_col_idx].page_value_count = 0;
662: 		}
663: 	}
664: 
665: 	auto current_row_group = file_meta_data.row_groups[current_group];
666: 	output.SetCardinality(std::min<int64_t>(STANDARD_VECTOR_SIZE, current_row_group.num_rows - group_offset));
667: 
668: 	if (output.size() == 0) {
669: 		return;
670: 	}
671: 
672: 	for (idx_t out_col_idx = 0; out_col_idx < output.column_count(); out_col_idx++) {
673: 		auto file_col_idx = column_ids[out_col_idx];
674: 		if (file_col_idx == COLUMN_IDENTIFIER_ROW_ID) {
675: 			Value constant_42 = Value::BIGINT(42);
676: 			output.data[out_col_idx].Reference(constant_42);
677: 			continue;
678: 		}
679: 
680: 		auto &col_data = column_data[file_col_idx];
681: 
682: 		// we might need to read multiple pages to fill the data chunk
683: 		idx_t output_offset = 0;
684: 		while (output_offset < output.size()) {
685: 			// do this unpack business only if we run out of stuff from the current page
686: 			if (col_data.page_offset >= col_data.page_value_count) {
687: 
688: 				// read dictionaries and data page headers so that we are ready to go for scan
689: 				if (!PreparePageBuffers(file_col_idx)) {
690: 					continue;
691: 				}
692: 				col_data.page_offset = 0;
693: 			}
694: 
695: 			auto current_batch_size =
696: 			    std::min(col_data.page_value_count - col_data.page_offset, output.size() - output_offset);
697: 
698: 			assert(current_batch_size > 0);
699: 
700: 			col_data.defined_buf.resize(current_batch_size);
701: 			col_data.defined_decoder->GetBatch<uint8_t>(col_data.defined_buf.ptr, current_batch_size);
702: 
703: 			switch (col_data.page_encoding) {
704: 			case Encoding::RLE_DICTIONARY:
705: 			case Encoding::PLAIN_DICTIONARY: {
706: 
707: 				idx_t null_count = 0;
708: 				for (idx_t i = 0; i < current_batch_size; i++) {
709: 					if (!col_data.defined_buf.ptr[i]) {
710: 						null_count++;
711: 					}
712: 				}
713: 
714: 				col_data.offset_buf.resize(current_batch_size * sizeof(uint32_t));
715: 				col_data.dict_decoder->GetBatch<uint32_t>(col_data.offset_buf.ptr, current_batch_size - null_count);
716: 
717: 				// TODO ensure we had seen a dict page IN THIS CHUNK before getting here
718: 
719: 				switch (sql_types[file_col_idx].id()) {
720: 				case LogicalTypeId::BOOLEAN:
721: 					_fill_from_dict<bool>(col_data, current_batch_size, output.data[out_col_idx], output_offset);
722: 					break;
723: 				case LogicalTypeId::INTEGER:
724: 					_fill_from_dict<int32_t>(col_data, current_batch_size, output.data[out_col_idx], output_offset);
725: 					break;
726: 				case LogicalTypeId::BIGINT:
727: 					_fill_from_dict<int64_t>(col_data, current_batch_size, output.data[out_col_idx], output_offset);
728: 					break;
729: 				case LogicalTypeId::FLOAT:
730: 					_fill_from_dict<float>(col_data, current_batch_size, output.data[out_col_idx], output_offset);
731: 					break;
732: 				case LogicalTypeId::DOUBLE:
733: 					_fill_from_dict<double>(col_data, current_batch_size, output.data[out_col_idx], output_offset);
734: 					break;
735: 				case LogicalTypeId::TIMESTAMP:
736: 					_fill_from_dict<timestamp_t>(col_data, current_batch_size, output.data[out_col_idx], output_offset);
737: 					break;
738: 				case LogicalTypeId::VARCHAR: {
739: 					if (!col_data.string_collection) {
740: 						throw runtime_error("Did not see a dictionary for strings. Corrupt file?");
741: 					}
742: 
743: 					// the strings can be anywhere in the collection so just reference it all
744: 					for (auto &chunk : col_data.string_collection->chunks) {
745: 						StringVector::AddHeapReference(output.data[out_col_idx], chunk->data[0]);
746: 					}
747: 
748: 					auto out_data_ptr = FlatVector::GetData<string_t>(output.data[out_col_idx]);
749: 					for (idx_t i = 0; i < current_batch_size; i++) {
750: 						if (col_data.defined_buf.ptr[i]) {
751: 							auto offset = col_data.offset_buf.read<uint32_t>();
752: 							if (offset >= col_data.string_collection->count) {
753: 								throw runtime_error("string dictionary offset out of bounds");
754: 							}
755: 							auto &chunk = col_data.string_collection->chunks[offset / STANDARD_VECTOR_SIZE];
756: 							auto &vec = chunk->data[0];
757: 
758: 							out_data_ptr[i + output_offset] =
759: 							    FlatVector::GetData<string_t>(vec)[offset % STANDARD_VECTOR_SIZE];
760: 						} else {
761: 							FlatVector::SetNull(output.data[out_col_idx], i + output_offset, true);
762: 						}
763: 					}
764: 				} break;
765: 				default:
766: 					throw runtime_error(sql_types[file_col_idx].ToString());
767: 				}
768: 
769: 				break;
770: 			}
771: 			case Encoding::PLAIN:
772: 				assert(col_data.payload.ptr);
773: 				switch (sql_types[file_col_idx].id()) {
774: 				case LogicalTypeId::BOOLEAN: {
775: 					// bit packed this
776: 					auto target_ptr = FlatVector::GetData<bool>(output.data[out_col_idx]);
777: 					for (idx_t i = 0; i < current_batch_size; i++) {
778: 						if (!col_data.defined_buf.ptr[i]) {
779: 							FlatVector::SetNull(output.data[out_col_idx], i + output_offset, true);
780: 							continue;
781: 						}
782: 						col_data.payload.available(1);
783: 						target_ptr[i + output_offset] = (*col_data.payload.ptr >> col_data.byte_pos) & 1;
784: 						col_data.byte_pos++;
785: 						if (col_data.byte_pos == 8) {
786: 							col_data.byte_pos = 0;
787: 							col_data.payload.inc(1);
788: 						}
789: 					}
790: 					break;
791: 				}
792: 				case LogicalTypeId::INTEGER:
793: 					_fill_from_plain<int32_t>(col_data, current_batch_size, output.data[out_col_idx], output_offset);
794: 					break;
795: 				case LogicalTypeId::BIGINT:
796: 					_fill_from_plain<int64_t>(col_data, current_batch_size, output.data[out_col_idx], output_offset);
797: 					break;
798: 				case LogicalTypeId::FLOAT:
799: 					_fill_from_plain<float>(col_data, current_batch_size, output.data[out_col_idx], output_offset);
800: 					break;
801: 				case LogicalTypeId::DOUBLE:
802: 					_fill_from_plain<double>(col_data, current_batch_size, output.data[out_col_idx], output_offset);
803: 					break;
804: 				case LogicalTypeId::TIMESTAMP: {
805: 					for (idx_t i = 0; i < current_batch_size; i++) {
806: 						if (col_data.defined_buf.ptr[i]) {
807: 							((timestamp_t *)FlatVector::GetData(output.data[out_col_idx]))[i + output_offset] =
808: 							    impala_timestamp_to_timestamp_t(col_data.payload.read<Int96>());
809: 						} else {
810: 							FlatVector::SetNull(output.data[out_col_idx], i + output_offset, true);
811: 						}
812: 					}
813: 
814: 					break;
815: 				}
816: 				case LogicalTypeId::VARCHAR: {
817: 					for (idx_t i = 0; i < current_batch_size; i++) {
818: 						if (col_data.defined_buf.ptr[i]) {
819: 							uint32_t str_len = col_data.payload.read<uint32_t>();
820: 							col_data.payload.available(str_len);
821: 							FlatVector::GetData<string_t>(output.data[out_col_idx])[i + output_offset] =
822: 							    StringVector::AddString(output.data[out_col_idx], col_data.payload.ptr, str_len);
823: 							col_data.payload.inc(str_len);
824: 						} else {
825: 							FlatVector::SetNull(output.data[out_col_idx], i + output_offset, true);
826: 						}
827: 					}
828: 					break;
829: 				}
830: 				default:
831: 					throw runtime_error(sql_types[file_col_idx].ToString());
832: 				}
833: 
834: 				break;
835: 
836: 			default:
837: 				throw runtime_error("Data page has unsupported/invalid encoding");
838: 			}
839: 
840: 			output_offset += current_batch_size;
841: 			col_data.page_offset += current_batch_size;
842: 		}
843: 	}
844: 	group_offset += output.size();
845: }
846: 
847: class ParquetScanFunction : public TableFunction {
848: public:
849: 	ParquetScanFunction()
850: 	    : TableFunction("parquet_scan", {LogicalType::VARCHAR}, parquet_scan_bind, parquet_scan_function, nullptr) {
851: 		supports_projection = true;
852: 	}
853: 
854: 	static unique_ptr<FunctionData> ReadParquetHeader(string file_name, vector<LogicalType> &return_types,
855: 	                                                  vector<string> &names) {
856: 		auto res = make_unique<ParquetScanFunctionData>();
857: 
858: 		auto &pfile = res->pfile;
859: 		auto &file_meta_data = res->file_meta_data;
860: 
861: 		pfile.open(file_name, std::ios::binary);
862: 
863: 		ResizeableBuffer buf;
864: 		buf.resize(4);
865: 		memset(buf.ptr, '\0', 4);
866: 		// check for magic bytes at start of file
867: 		pfile.read(buf.ptr, 4);
868: 		if (strncmp(buf.ptr, "PAR1", 4) != 0) {
869: 			throw runtime_error("File not found or missing magic bytes");
870: 		}
871: 
872: 		// check for magic bytes at end of file
873: 		pfile.seekg(-4, ios_base::end);
874: 		pfile.read(buf.ptr, 4);
875: 		if (strncmp(buf.ptr, "PAR1", 4) != 0) {
876: 			throw runtime_error("No magic bytes found at end of file");
877: 		}
878: 
879: 		// read four-byte footer length from just before the end magic bytes
880: 		pfile.seekg(-8, ios_base::end);
881: 		pfile.read(buf.ptr, 4);
882: 		int32_t footer_len = *(uint32_t *)buf.ptr;
883: 		if (footer_len == 0) {
884: 			throw runtime_error("Footer length can't be 0");
885: 		}
886: 
887: 		// read footer into buffer and de-thrift
888: 		buf.resize(footer_len);
889: 		pfile.seekg(-(footer_len + 8), ios_base::end);
890: 		pfile.read(buf.ptr, footer_len);
891: 		if (!pfile) {
892: 			throw runtime_error("Could not read footer");
893: 		}
894: 
895: 		thrift_unpack((const uint8_t *)buf.ptr, (uint32_t *)&footer_len, &file_meta_data);
896: 
897: 		if (file_meta_data.__isset.encryption_algorithm) {
898: 			throw runtime_error("Encrypted Parquet files are not supported");
899: 		}
900: 		// check if we like this schema
901: 		if (file_meta_data.schema.size() < 2) {
902: 			throw runtime_error("Need at least one column in the file");
903: 		}
904: 		if (file_meta_data.schema[0].num_children != (int32_t)(file_meta_data.schema.size() - 1)) {
905: 			throw runtime_error("Only flat tables are supported (no nesting)");
906: 		}
907: 
908: 		bool has_expected_types = return_types.size() > 0;
909: 
910: 		// skip the first column its the root and otherwise useless
911: 		for (uint64_t col_idx = 1; col_idx < file_meta_data.schema.size(); col_idx++) {
912: 			auto &s_ele = file_meta_data.schema[col_idx];
913: 			if (!s_ele.__isset.type || s_ele.num_children > 0) {
914: 				throw runtime_error("Only flat tables are supported (no nesting)");
915: 			}
916: 			// if this is REQUIRED, there are no defined levels in file, seems unused
917: 			// if field is REPEATED, no bueno
918: 			if (s_ele.repetition_type != FieldRepetitionType::OPTIONAL) {
919: 				throw runtime_error("Only OPTIONAL fields support");
920: 			}
921: 
922: 			LogicalType type;
923: 			switch (s_ele.type) {
924: 			case Type::BOOLEAN:
925: 				type = LogicalType::BOOLEAN;
926: 				break;
927: 			case Type::INT32:
928: 				type = LogicalType::INTEGER;
929: 				break;
930: 			case Type::INT64:
931: 				type = LogicalType::BIGINT;
932: 				break;
933: 			case Type::INT96: // always a timestamp?
934: 				type = LogicalType::TIMESTAMP;
935: 				break;
936: 			case Type::FLOAT:
937: 				type = LogicalType::FLOAT;
938: 				break;
939: 			case Type::DOUBLE:
940: 				type = LogicalType::DOUBLE;
941: 				break;
942: 				//			case parquet::format::Type::FIXED_LEN_BYTE_ARRAY: {
943: 				// TODO some decimals yuck
944: 			case Type::BYTE_ARRAY:
945: 				type = LogicalType::VARCHAR;
946: 				break;
947: 
948: 			default:
949: 				throw NotImplementedException("Invalid type");
950: 				break;
951: 			}
952: 			if (has_expected_types) {
953: 				if (return_types[col_idx - 1] != type) {
954: 					throw NotImplementedException("PARQUET file contains type %s, could not auto cast to type %s",
955: 					                              type.ToString(), return_types[col_idx - 1].ToString());
956: 				}
957: 			} else {
958: 				names.push_back(s_ele.name);
959: 				return_types.push_back(type);
960: 			}
961: 
962: 			res->sql_types.push_back(type);
963: 		}
964: 		res->group_offset = 0;
965: 		res->current_group = -1;
966: 		res->column_data.resize(return_types.size());
967: 		res->finished = false;
968: 		return move(res);
969: 	}
970: 
971: 	static unique_ptr<FunctionData> parquet_read_bind(ClientContext &context, CopyInfo &info,
972: 	                                                  vector<string> &expected_names,
973: 	                                                  vector<LogicalType> &expected_types) {
974: 		for (auto &option : info.options) {
975: 			throw NotImplementedException("Unsupported option for COPY FROM parquet: %s", option.first);
976: 		}
977: 		auto data = ReadParquetHeader(info.file_path, expected_types, expected_names);
978: 		// FIXME: hacky
979: 		auto &pdata = (ParquetScanFunctionData &)*data;
980: 		for (idx_t i = 0; i < expected_types.size(); i++) {
981: 			pdata.column_ids.push_back(i);
982: 		}
983: 		return data;
984: 	}
985: 
986: 	static unique_ptr<FunctionData> parquet_scan_bind(ClientContext &context, vector<Value> &inputs,
987: 	                                                  unordered_map<string, Value> &named_parameters,
988: 	                                                  vector<LogicalType> &return_types, vector<string> &names) {
989: 		auto file_name = inputs[0].GetValue<string>();
990: 		return ReadParquetHeader(file_name, return_types, names);
991: 	}
992: 
993: 	static unique_ptr<GlobalFunctionData> parquet_read_initialize(ClientContext &context, FunctionData &fdata) {
994: 		return make_unique<GlobalFunctionData>();
995: 	}
996: 
997: 	static void parquet_read_function(ExecutionContext &context, GlobalFunctionData &gstate, FunctionData &bind_data,
998: 	                                  DataChunk &output) {
999: 		auto &data = (ParquetScanFunctionData &)bind_data;
1000: 		data.ReadChunk(output);
1001: 	}
1002: 
1003: 	static void parquet_scan_function(ClientContext &context, vector<Value> &input, DataChunk &output,
1004: 	                                  FunctionData *dataptr) {
1005: 		auto &data = *((ParquetScanFunctionData *)dataptr);
1006: 		data.ReadChunk(output);
1007: 	}
1008: };
1009: 
1010: class MyTransport : public TTransport {
1011: public:
1012: 	MyTransport(Serializer &serializer) : serializer(serializer) {
1013: 	}
1014: 
1015: 	bool isOpen() const override {
1016: 		return true;
1017: 	}
1018: 
1019: 	void open() override {
1020: 	}
1021: 
1022: 	void close() override {
1023: 	}
1024: 
1025: 	void write_virt(const uint8_t *buf, uint32_t len) override {
1026: 		serializer.WriteData((const_data_ptr_t)buf, len);
1027: 	}
1028: 
1029: private:
1030: 	Serializer &serializer;
1031: };
1032: 
1033: static Type::type duckdb_type_to_parquet_type(LogicalType duckdb_type) {
1034: 	switch (duckdb_type.id()) {
1035: 	case LogicalTypeId::BOOLEAN:
1036: 		return Type::BOOLEAN;
1037: 	case LogicalTypeId::TINYINT:
1038: 	case LogicalTypeId::SMALLINT:
1039: 	case LogicalTypeId::INTEGER:
1040: 		return Type::INT32;
1041: 	case LogicalTypeId::BIGINT:
1042: 		return Type::INT64;
1043: 	case LogicalTypeId::FLOAT:
1044: 		return Type::FLOAT;
1045: 	case LogicalTypeId::DECIMAL: // for now...
1046: 	case LogicalTypeId::DOUBLE:
1047: 		return Type::DOUBLE;
1048: 	case LogicalTypeId::VARCHAR:
1049: 	case LogicalTypeId::BLOB:
1050: 		return Type::BYTE_ARRAY;
1051: 	case LogicalTypeId::DATE:
1052: 	case LogicalTypeId::TIMESTAMP:
1053: 		return Type::INT96;
1054: 	default:
1055: 		throw NotImplementedException(duckdb_type.ToString());
1056: 	}
1057: }
1058: 
1059: static void VarintEncode(uint32_t val, Serializer &ser) {
1060: 	do {
1061: 		uint8_t byte = val & 127;
1062: 		val >>= 7;
1063: 		if (val != 0) {
1064: 			byte |= 128;
1065: 		}
1066: 		ser.Write<uint8_t>(byte);
1067: 	} while (val != 0);
1068: }
1069: 
1070: static uint8_t GetVarintSize(uint32_t val) {
1071: 	uint8_t res = 0;
1072: 	do {
1073: 		uint8_t byte = val & 127;
1074: 		val >>= 7;
1075: 		if (val != 0) {
1076: 			byte |= 128;
1077: 		}
1078: 		res++;
1079: 	} while (val != 0);
1080: 	return res;
1081: }
1082: 
1083: template <class SRC, class TGT>
1084: static void _write_plain(Vector &col, idx_t length, nullmask_t &nullmask, Serializer &ser) {
1085: 	auto *ptr = FlatVector::GetData<SRC>(col);
1086: 	for (idx_t r = 0; r < length; r++) {
1087: 		if (!nullmask[r]) {
1088: 			ser.Write<TGT>((TGT)ptr[r]);
1089: 		}
1090: 	}
1091: }
1092: 
1093: struct ParquetWriteBindData : public FunctionData {
1094: 	vector<LogicalType> sql_types;
1095: 	string file_name;
1096: 	vector<string> column_names;
1097: 	// TODO compression flag to test the param passing stuff
1098: };
1099: 
1100: struct ParquetWriteGlobalState : public GlobalFunctionData {
1101: public:
1102: 	void Flush(ChunkCollection &buffer) {
1103: 		if (buffer.count == 0) {
1104: 			return;
1105: 		}
1106: 		std::lock_guard<std::mutex> glock(lock);
1107: 
1108: 		// set up a new row group for this chunk collection
1109: 		RowGroup row_group;
1110: 		row_group.num_rows = 0;
1111: 		row_group.file_offset = writer->GetTotalWritten();
1112: 		row_group.__isset.file_offset = true;
1113: 		row_group.columns.resize(buffer.column_count());
1114: 
1115: 		// iterate over each of the columns of the chunk collection and write them
1116: 		for (idx_t i = 0; i < buffer.column_count(); i++) {
1117: 			// we start off by writing everything into a temporary buffer
1118: 			// this is necessary to (1) know the total written size, and (2) to compress it with snappy afterwards
1119: 			BufferedSerializer temp_writer;
1120: 
1121: 			// set up some metadata
1122: 			PageHeader hdr;
1123: 			hdr.compressed_page_size = 0;
1124: 			hdr.uncompressed_page_size = 0;
1125: 			hdr.type = PageType::DATA_PAGE;
1126: 			hdr.__isset.data_page_header = true;
1127: 
1128: 			hdr.data_page_header.num_values = buffer.count;
1129: 			hdr.data_page_header.encoding = Encoding::PLAIN;
1130: 			hdr.data_page_header.definition_level_encoding = Encoding::RLE;
1131: 			hdr.data_page_header.repetition_level_encoding = Encoding::BIT_PACKED;
1132: 
1133: 			// record the current offset of the writer into the file
1134: 			// this is the starting position of the current page
1135: 			auto start_offset = writer->GetTotalWritten();
1136: 
1137: 			// write the definition levels (i.e. the inverse of the nullmask)
1138: 			// we always bit pack everything
1139: 
1140: 			// first figure out how many bytes we need (1 byte per 8 rows, rounded up)
1141: 			auto define_byte_count = (buffer.count + 7) / 8;
1142: 			// we need to set up the count as a varint, plus an added marker for the RLE scheme
1143: 			// for this marker we shift the count left 1 and set low bit to 1 to indicate bit packed literals
1144: 			uint32_t define_header = (define_byte_count << 1) | 1;
1145: 			uint32_t define_size = GetVarintSize(define_header) + define_byte_count;
1146: 
1147: 			// we write the actual definitions into the temp_writer for now
1148: 			temp_writer.Write<uint32_t>(define_size);
1149: 			VarintEncode(define_header, temp_writer);
1150: 
1151: 			for (auto &chunk : buffer.chunks) {
1152: 				auto defined = FlatVector::Nullmask(chunk->data[i]);
1153: 				// flip the nullmask to go from nulls -> defines
1154: 				defined.flip();
1155: 				// write the bits of the nullmask
1156: 				auto chunk_define_byte_count = (chunk->size() + 7) / 8;
1157: 				temp_writer.WriteData((const_data_ptr_t)&defined, chunk_define_byte_count);
1158: 			}
1159: 
1160: 			// now write the actual payload: we write this as PLAIN values (for now? possibly for ever?)
1161: 			for (auto &chunk : buffer.chunks) {
1162: 				auto &input = *chunk;
1163: 				auto &input_column = input.data[i];
1164: 				auto &nullmask = FlatVector::Nullmask(input_column);
1165: 
1166: 				// write actual payload data
1167: 				switch (sql_types[i].id()) {
1168: 				case LogicalTypeId::BOOLEAN: {
1169: 					auto *ptr = FlatVector::GetData<bool>(input_column);
1170: 					uint8_t byte = 0;
1171: 					uint8_t byte_pos = 0;
1172: 					for (idx_t r = 0; r < input.size(); r++) {
1173: 						if (!nullmask[r]) { // only encode if non-null
1174: 							byte |= (ptr[r] & 1) << byte_pos;
1175: 							byte_pos++;
1176: 
1177: 							temp_writer.Write<uint8_t>(byte);
1178: 							if (byte_pos == 8) {
1179: 								temp_writer.Write<uint8_t>(byte);
1180: 								byte = 0;
1181: 								byte_pos = 0;
1182: 							}
1183: 						}
1184: 					}
1185: 					// flush last byte if req
1186: 					if (byte_pos > 0) {
1187: 						temp_writer.Write<uint8_t>(byte);
1188: 					}
1189: 					break;
1190: 				}
1191: 				case LogicalTypeId::TINYINT:
1192: 					_write_plain<int8_t, int32_t>(input_column, input.size(), nullmask, temp_writer);
1193: 					break;
1194: 				case LogicalTypeId::SMALLINT:
1195: 					_write_plain<int16_t, int32_t>(input_column, input.size(), nullmask, temp_writer);
1196: 					break;
1197: 				case LogicalTypeId::INTEGER:
1198: 					_write_plain<int32_t, int32_t>(input_column, input.size(), nullmask, temp_writer);
1199: 					break;
1200: 				case LogicalTypeId::BIGINT:
1201: 					_write_plain<int64_t, int64_t>(input_column, input.size(), nullmask, temp_writer);
1202: 					break;
1203: 				case LogicalTypeId::FLOAT:
1204: 					_write_plain<float, float>(input_column, input.size(), nullmask, temp_writer);
1205: 					break;
1206: 				case LogicalTypeId::DECIMAL: {
1207: 					// FIXME: fixed length byte array...
1208: 					Vector double_vec(LogicalType::DOUBLE);
1209: 					VectorOperations::Cast(input_column, double_vec, input.size());
1210: 					_write_plain<double, double>(double_vec, input.size(), nullmask, temp_writer);
1211: 					break;
1212: 				}
1213: 				case LogicalTypeId::DOUBLE:
1214: 					_write_plain<double, double>(input_column, input.size(), nullmask, temp_writer);
1215: 					break;
1216: 				case LogicalTypeId::DATE: {
1217: 					auto *ptr = FlatVector::GetData<date_t>(input_column);
1218: 					for (idx_t r = 0; r < input.size(); r++) {
1219: 						if (!nullmask[r]) {
1220: 							auto ts = Timestamp::FromDatetime(ptr[r], 0);
1221: 							temp_writer.Write<Int96>(timestamp_t_to_impala_timestamp(ts));
1222: 						}
1223: 					}
1224: 					break;
1225: 				}
1226: 				case LogicalTypeId::TIMESTAMP: {
1227: 					auto *ptr = FlatVector::GetData<timestamp_t>(input_column);
1228: 					for (idx_t r = 0; r < input.size(); r++) {
1229: 						if (!nullmask[r]) {
1230: 							temp_writer.Write<Int96>(timestamp_t_to_impala_timestamp(ptr[r]));
1231: 						}
1232: 					}
1233: 					break;
1234: 				}
1235: 				case LogicalTypeId::VARCHAR: {
1236: 					auto *ptr = FlatVector::GetData<string_t>(input_column);
1237: 					for (idx_t r = 0; r < input.size(); r++) {
1238: 						if (!nullmask[r]) {
1239: 							temp_writer.Write<uint32_t>(ptr[r].GetSize());
1240: 							temp_writer.WriteData((const_data_ptr_t)ptr[r].GetData(), ptr[r].GetSize());
1241: 						}
1242: 					}
1243: 					break;
1244: 				}
1245: 					// TODO date blob etc.
1246: 				default:
1247: 					throw NotImplementedException((sql_types[i].ToString()));
1248: 				}
1249: 			}
1250: 
1251: 			// now that we have finished writing the data we know the uncompressed size
1252: 			hdr.uncompressed_page_size = temp_writer.blob.size;
1253: 
1254: 			// we perform snappy compression (FIXME: this should be a flag, possibly also include gzip?)
1255: 			size_t compressed_size = snappy::MaxCompressedLength(temp_writer.blob.size);
1256: 			auto compressed_buf = unique_ptr<data_t[]>(new data_t[compressed_size]);
1257: 			snappy::RawCompress((const char *)temp_writer.blob.data.get(), temp_writer.blob.size,
1258: 			                    (char *)compressed_buf.get(), &compressed_size);
1259: 
1260: 			hdr.compressed_page_size = compressed_size;
1261: 
1262: 			// now finally write the data to the actual file
1263: 			hdr.write(protocol.get());
1264: 			writer->WriteData(compressed_buf.get(), compressed_size);
1265: 
1266: 			auto &column_chunk = row_group.columns[i];
1267: 			column_chunk.__isset.meta_data = true;
1268: 			column_chunk.meta_data.data_page_offset = start_offset;
1269: 			column_chunk.meta_data.total_compressed_size = writer->GetTotalWritten() - start_offset;
1270: 			column_chunk.meta_data.codec = CompressionCodec::SNAPPY;
1271: 			column_chunk.meta_data.path_in_schema.push_back(file_meta_data.schema[i + 1].name);
1272: 			column_chunk.meta_data.num_values = buffer.count;
1273: 			column_chunk.meta_data.type = file_meta_data.schema[i + 1].type;
1274: 		}
1275: 		row_group.num_rows += buffer.count;
1276: 
1277: 		// append the row group to the file meta data
1278: 		file_meta_data.row_groups.push_back(row_group);
1279: 		file_meta_data.num_rows += buffer.count;
1280: 	}
1281: 
1282: 	void Finalize() {
1283: 		auto start_offset = writer->GetTotalWritten();
1284: 		file_meta_data.write(protocol.get());
1285: 
1286: 		writer->Write<uint32_t>(writer->GetTotalWritten() - start_offset);
1287: 
1288: 		// parquet files also end with the string "PAR1"
1289: 		writer->WriteData((const_data_ptr_t) "PAR1", 4);
1290: 
1291: 		// flush to disk
1292: 		writer->Sync();
1293: 		writer.reset();
1294: 	}
1295: 
1296: public:
1297: 	unique_ptr<BufferedFileWriter> writer;
1298: 	shared_ptr<TProtocol> protocol;
1299: 	FileMetaData file_meta_data;
1300: 	vector<LogicalType> sql_types;
1301: 	std::mutex lock;
1302: };
1303: 
1304: struct ParquetWriteLocalState : public LocalFunctionData {
1305: 	ParquetWriteLocalState() {
1306: 		buffer = make_unique<ChunkCollection>();
1307: 	}
1308: 
1309: 	unique_ptr<ChunkCollection> buffer;
1310: };
1311: 
1312: unique_ptr<FunctionData> parquet_write_bind(ClientContext &context, CopyInfo &info, vector<string> &names,
1313:                                             vector<LogicalType> &sql_types) {
1314: 	auto bind_data = make_unique<ParquetWriteBindData>();
1315: 	bind_data->sql_types = sql_types;
1316: 	bind_data->column_names = names;
1317: 	bind_data->file_name = info.file_path;
1318: 	return move(bind_data);
1319: }
1320: 
1321: unique_ptr<GlobalFunctionData> parquet_write_initialize_global(ClientContext &context, FunctionData &bind_data) {
1322: 	auto global_state = make_unique<ParquetWriteGlobalState>();
1323: 	auto &parquet_bind = (ParquetWriteBindData &)bind_data;
1324: 
1325: 	// initialize the file writer
1326: 	global_state->writer =
1327: 	    make_unique<BufferedFileWriter>(context.db.GetFileSystem(), parquet_bind.file_name.c_str(),
1328: 	                                    FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE_NEW);
1329: 	// parquet files start with the string "PAR1"
1330: 	global_state->writer->WriteData((const_data_ptr_t) "PAR1", 4);
1331: 	TCompactProtocolFactoryT<MyTransport> tproto_factory;
1332: 	global_state->protocol = tproto_factory.getProtocol(make_shared<MyTransport>(*global_state->writer));
1333: 	global_state->file_meta_data.num_rows = 0;
1334: 	global_state->file_meta_data.schema.resize(parquet_bind.sql_types.size() + 1);
1335: 
1336: 	global_state->file_meta_data.schema[0].num_children = parquet_bind.sql_types.size();
1337: 	global_state->file_meta_data.schema[0].__isset.num_children = true;
1338: 	global_state->file_meta_data.version = 1;
1339: 
1340: 	for (idx_t i = 0; i < parquet_bind.sql_types.size(); i++) {
1341: 		auto &schema_element = global_state->file_meta_data.schema[i + 1];
1342: 
1343: 		schema_element.type = duckdb_type_to_parquet_type(parquet_bind.sql_types[i]);
1344: 		schema_element.repetition_type = FieldRepetitionType::OPTIONAL;
1345: 		schema_element.num_children = 0;
1346: 		schema_element.__isset.num_children = true;
1347: 		schema_element.__isset.type = true;
1348: 		schema_element.__isset.repetition_type = true;
1349: 		schema_element.name = parquet_bind.column_names[i];
1350: 	}
1351: 	global_state->sql_types = parquet_bind.sql_types;
1352: 	return move(global_state);
1353: }
1354: 
1355: void parquet_write_sink(ClientContext &context, FunctionData &bind_data, GlobalFunctionData &gstate,
1356:                         LocalFunctionData &lstate, DataChunk &input) {
1357: 	auto &global_state = (ParquetWriteGlobalState &)gstate;
1358: 	auto &local_state = (ParquetWriteLocalState &)lstate;
1359: 
1360: 	// append data to the local (buffered) chunk collection
1361: 	local_state.buffer->Append(input);
1362: 	if (local_state.buffer->count > 100000) {
1363: 		// if the chunk collection exceeds a certain size we flush it to the parquet file
1364: 		global_state.Flush(*local_state.buffer);
1365: 		// and reset the buffer
1366: 		local_state.buffer = make_unique<ChunkCollection>();
1367: 	}
1368: }
1369: 
1370: void parquet_write_combine(ClientContext &context, FunctionData &bind_data, GlobalFunctionData &gstate,
1371:                            LocalFunctionData &lstate) {
1372: 	auto &global_state = (ParquetWriteGlobalState &)gstate;
1373: 	auto &local_state = (ParquetWriteLocalState &)lstate;
1374: 	// flush any data left in the local state to the file
1375: 	global_state.Flush(*local_state.buffer);
1376: }
1377: 
1378: void parquet_write_finalize(ClientContext &context, FunctionData &bind_data, GlobalFunctionData &gstate) {
1379: 	auto &global_state = (ParquetWriteGlobalState &)gstate;
1380: 	// finalize: write any additional metadata to the file here
1381: 	global_state.Finalize();
1382: }
1383: 
1384: unique_ptr<LocalFunctionData> parquet_write_initialize_local(ClientContext &context, FunctionData &bind_data) {
1385: 	return make_unique<ParquetWriteLocalState>();
1386: }
1387: 
1388: void ParquetExtension::Load(DuckDB &db) {
1389: 	ParquetScanFunction scan_fun;
1390: 	CreateTableFunctionInfo cinfo(scan_fun);
1391: 	cinfo.name = "read_parquet";
1392: 	CreateTableFunctionInfo pq_scan = cinfo;
1393: 	pq_scan.name = "parquet_scan";
1394: 
1395: 	CopyFunction function("parquet");
1396: 	function.copy_to_bind = parquet_write_bind;
1397: 	function.copy_to_initialize_global = parquet_write_initialize_global;
1398: 	function.copy_to_initialize_local = parquet_write_initialize_local;
1399: 	function.copy_to_sink = parquet_write_sink;
1400: 	function.copy_to_combine = parquet_write_combine;
1401: 	function.copy_to_finalize = parquet_write_finalize;
1402: 	function.copy_from_bind = ParquetScanFunction::parquet_read_bind;
1403: 	function.copy_from_initialize = ParquetScanFunction::parquet_read_initialize;
1404: 	function.copy_from_get_chunk = ParquetScanFunction::parquet_read_function;
1405: 
1406: 	function.extension = "parquet";
1407: 	CreateCopyFunctionInfo info(function);
1408: 
1409: 	Connection conn(db);
1410: 	conn.context->transaction.BeginTransaction();
1411: 	db.catalog->CreateCopyFunction(*conn.context, &info);
1412: 	db.catalog->CreateTableFunction(*conn.context, &cinfo);
1413: 	db.catalog->CreateTableFunction(*conn.context, &pq_scan);
1414: 
1415: 	conn.context->transaction.Commit();
1416: }
[end of extension/parquet/parquet-extension.cpp]
[start of extension/tpch/tpch-extension.cpp]
1: #include "tpch-extension.hpp"
2: #include "duckdb/function/table_function.hpp"
3: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
4: #include "duckdb/parser/parsed_data/create_view_info.hpp"
5: #include "duckdb/parser/parser.hpp"
6: #include "duckdb/parser/statement/select_statement.hpp"
7: #include "duckdb/parser/parsed_data/create_pragma_function_info.hpp"
8: 
9: #include "dbgen.hpp"
10: 
11: namespace duckdb {
12: 
13: struct DBGenFunctionData : public TableFunctionData {
14: 	DBGenFunctionData() {
15: 	}
16: 
17: 	bool finished = false;
18: 	double sf = 0;
19: 	string schema = DEFAULT_SCHEMA;
20: 	string suffix;
21: 	bool overwrite = false;
22: };
23: 
24: static unique_ptr<FunctionData> dbgen_bind(ClientContext &context, vector<Value> &inputs,
25:                                            unordered_map<string, Value> &named_parameters,
26:                                            vector<LogicalType> &return_types, vector<string> &names) {
27: 	auto result = make_unique<DBGenFunctionData>();
28: 	for (auto &kv : named_parameters) {
29: 		if (kv.first == "sf") {
30: 			result->sf = kv.second.value_.double_;
31: 		} else if (kv.first == "schema") {
32: 			result->schema = kv.second.str_value;
33: 		} else if (kv.first == "suffix") {
34: 			result->suffix = kv.second.str_value;
35: 		} else if (kv.first == "overwrite") {
36: 			result->overwrite = kv.second.value_.boolean;
37: 		}
38: 	}
39: 	return_types.push_back(LogicalType::BOOLEAN);
40: 	names.push_back("Success");
41: 	return move(result);
42: }
43: 
44: static void dbgen_function(ClientContext &context, vector<Value> &input, DataChunk &output, FunctionData *dataptr) {
45: 	auto &data = ((DBGenFunctionData &)*dataptr);
46: 	if (data.finished) {
47: 		return;
48: 	}
49: 	tpch::DBGenWrapper::CreateTPCHSchema(context, data.schema, data.suffix);
50: 	tpch::DBGenWrapper::LoadTPCHData(context, data.sf, data.schema, data.suffix);
51: 
52: 	data.finished = true;
53: }
54: static string pragma_tpch_query(ClientContext &context, vector<Value> parameters) {
55: 	auto index = parameters[0].GetValue<int32_t>();
56: 	return tpch::DBGenWrapper::GetQuery(index);
57: }
58: 
59: void TPCHExtension::Load(DuckDB &db) {
60: 	Connection con(db);
61: 	con.BeginTransaction();
62: 
63: 	TableFunction dbgen_func("dbgen", {}, dbgen_bind, dbgen_function);
64: 	dbgen_func.named_parameters["sf"] = LogicalType::DOUBLE;
65: 	dbgen_func.named_parameters["overwrite"] = LogicalType::BOOLEAN;
66: 	dbgen_func.named_parameters["schema"] = LogicalType::VARCHAR;
67: 	dbgen_func.named_parameters["suffix"] = LogicalType::VARCHAR;
68: 	CreateTableFunctionInfo dbgen_info(dbgen_func);
69: 
70: 	// create the dbgen function
71: 	db.catalog->CreateTableFunction(*con.context, &dbgen_info);
72: 
73: 	// create the TPCH pragma that allows us to run the query
74: 	auto tpch_func = PragmaFunction::PragmaCall("tpch", pragma_tpch_query, {LogicalType::BIGINT});
75: 
76: 	CreatePragmaFunctionInfo info(tpch_func);
77: 	db.catalog->CreatePragmaFunction(*con.context, &info);
78: 
79: 	con.Commit();
80: }
81: 
82: std::string TPCHExtension::GetQuery(int query) {
83: 	return tpch::DBGenWrapper::GetQuery(query);
84: }
85: 
86: std::string TPCHExtension::GetAnswer(double sf, int query) {
87: 	return tpch::DBGenWrapper::GetAnswer(sf, query);
88: }
89: 
90: } // namespace duckdb
[end of extension/tpch/tpch-extension.cpp]
[start of src/common/enums/logical_operator_type.cpp]
1: #include "duckdb/common/enums/logical_operator_type.hpp"
2: 
3: using namespace std;
4: 
5: namespace duckdb {
6: 
7: //===--------------------------------------------------------------------===//
8: // Value <--> String Utilities
9: //===--------------------------------------------------------------------===//
10: string LogicalOperatorToString(LogicalOperatorType type) {
11: 	switch (type) {
12: 	case LogicalOperatorType::GET:
13: 		return "GET";
14: 	case LogicalOperatorType::CHUNK_GET:
15: 		return "CHUNK_GET";
16: 	case LogicalOperatorType::DELIM_GET:
17: 		return "DELIM_GET";
18: 	case LogicalOperatorType::EMPTY_RESULT:
19: 		return "EMPTY_RESULT";
20: 	case LogicalOperatorType::EXPRESSION_GET:
21: 		return "EXPRESSION_GET";
22: 	case LogicalOperatorType::ANY_JOIN:
23: 		return "ANY_JOIN";
24: 	case LogicalOperatorType::COMPARISON_JOIN:
25: 		return "COMPARISON_JOIN";
26: 	case LogicalOperatorType::DELIM_JOIN:
27: 		return "DELIM_JOIN";
28: 	case LogicalOperatorType::PROJECTION:
29: 		return "PROJECTION";
30: 	case LogicalOperatorType::FILTER:
31: 		return "FILTER";
32: 	case LogicalOperatorType::AGGREGATE_AND_GROUP_BY:
33: 		return "AGGREGATE_AND_GROUP_BY";
34: 	case LogicalOperatorType::WINDOW:
35: 		return "WINDOW";
36: 	case LogicalOperatorType::UNNEST:
37: 		return "UNNEST";
38: 	case LogicalOperatorType::LIMIT:
39: 		return "LIMIT";
40: 	case LogicalOperatorType::ORDER_BY:
41: 		return "ORDER_BY";
42: 	case LogicalOperatorType::TOP_N:
43: 		return "TOP_N";
44: 	case LogicalOperatorType::COPY_TO_FILE:
45: 		return "COPY_TO_FILE";
46: 	case LogicalOperatorType::COPY_FROM_FILE:
47: 		return "COPY_FROM_FILE";
48: 	case LogicalOperatorType::JOIN:
49: 		return "JOIN";
50: 	case LogicalOperatorType::CROSS_PRODUCT:
51: 		return "CROSS_PRODUCT";
52: 	case LogicalOperatorType::UNION:
53: 		return "UNION";
54: 	case LogicalOperatorType::EXCEPT:
55: 		return "EXCEPT";
56: 	case LogicalOperatorType::INTERSECT:
57: 		return "INTERSECT";
58: 	case LogicalOperatorType::INSERT:
59: 		return "INSERT";
60: 	case LogicalOperatorType::DISTINCT:
61: 		return "DISTINCT";
62: 	case LogicalOperatorType::DELETE:
63: 		return "DELETE";
64: 	case LogicalOperatorType::UPDATE:
65: 		return "UPDATE";
66: 	case LogicalOperatorType::PREPARE:
67: 		return "PREPARE";
68: 	case LogicalOperatorType::TABLE_FUNCTION:
69: 		return "TABLE_FUNCTION";
70: 	case LogicalOperatorType::CREATE_INDEX:
71: 		return "CREATE_INDEX";
72: 	case LogicalOperatorType::CREATE_TABLE:
73: 		return "CREATE_TABLE";
74: 	case LogicalOperatorType::EXPLAIN:
75: 		return "EXPLAIN";
76: 	case LogicalOperatorType::EXECUTE:
77: 		return "EXECUTE";
78: 	case LogicalOperatorType::VACUUM:
79: 		return "VACUUM";
80: 	case LogicalOperatorType::INDEX_SCAN:
81: 		return "INDEX_SCAN";
82: 	case LogicalOperatorType::RECURSIVE_CTE:
83: 		return "REC_CTE";
84: 	case LogicalOperatorType::CTE_REF:
85: 		return "CTE_SCAN";
86: 	case LogicalOperatorType::INVALID:
87: 		return "INVALID";
88: 	case LogicalOperatorType::ALTER:
89: 		return "ALTER";
90: 	case LogicalOperatorType::CREATE_SEQUENCE:
91: 		return "CREATE_SEQUENCE";
92: 	case LogicalOperatorType::CREATE_VIEW:
93: 		return "CREATE_VIEW";
94: 	case LogicalOperatorType::CREATE_SCHEMA:
95: 		return "CREATE_SCHEMA";
96: 	case LogicalOperatorType::DROP:
97: 		return "DROP";
98: 	case LogicalOperatorType::PRAGMA:
99: 		return "PRAGMA";
100: 	case LogicalOperatorType::TRANSACTION:
101: 		return "TRANSACTION";
102: 	case LogicalOperatorType::EXPORT:
103: 		return "EXPORT";
104: 	}
105: 	return "UNDEFINED";
106: }
107: 
108: } // namespace duckdb
[end of src/common/enums/logical_operator_type.cpp]
[start of src/common/enums/physical_operator_type.cpp]
1: #include "duckdb/common/enums/physical_operator_type.hpp"
2: 
3: using namespace std;
4: 
5: namespace duckdb {
6: 
7: string PhysicalOperatorToString(PhysicalOperatorType type) {
8: 	switch (type) {
9: 	case PhysicalOperatorType::LEAF:
10: 		return "LEAF";
11: 	case PhysicalOperatorType::DUMMY_SCAN:
12: 		return "DUMMY_SCAN";
13: 	case PhysicalOperatorType::SEQ_SCAN:
14: 		return "SEQ_SCAN";
15: 	case PhysicalOperatorType::INDEX_SCAN:
16: 		return "INDEX_SCAN";
17: 	case PhysicalOperatorType::CHUNK_SCAN:
18: 		return "CHUNK_SCAN";
19: 	case PhysicalOperatorType::DELIM_SCAN:
20: 		return "DELIM_SCAN";
21: 	case PhysicalOperatorType::EXTERNAL_FILE_SCAN:
22: 		return "EXTERNAL_FILE_SCAN";
23: 	case PhysicalOperatorType::QUERY_DERIVED_SCAN:
24: 		return "QUERY_DERIVED_SCAN";
25: 	case PhysicalOperatorType::ORDER_BY:
26: 		return "ORDER_BY";
27: 	case PhysicalOperatorType::LIMIT:
28: 		return "LIMIT";
29: 	case PhysicalOperatorType::TOP_N:
30: 		return "TOP_N";
31: 	case PhysicalOperatorType::AGGREGATE:
32: 		return "AGGREGATE";
33: 	case PhysicalOperatorType::WINDOW:
34: 		return "WINDOW";
35: 	case PhysicalOperatorType::UNNEST:
36: 		return "UNNEST";
37: 	case PhysicalOperatorType::DISTINCT:
38: 		return "DISTINCT";
39: 	case PhysicalOperatorType::SIMPLE_AGGREGATE:
40: 		return "SIMPLE_AGGREGATE";
41: 	case PhysicalOperatorType::HASH_GROUP_BY:
42: 		return "HASH_GROUP_BY";
43: 	case PhysicalOperatorType::SORT_GROUP_BY:
44: 		return "SORT_GROUP_BY";
45: 	case PhysicalOperatorType::FILTER:
46: 		return "FILTER";
47: 	case PhysicalOperatorType::PROJECTION:
48: 		return "PROJECTION";
49: 	case PhysicalOperatorType::COPY_FROM_FILE:
50: 		return "COPY_FROM_FILE";
51: 	case PhysicalOperatorType::COPY_TO_FILE:
52: 		return "COPY_TO_FILE";
53: 	case PhysicalOperatorType::DELIM_JOIN:
54: 		return "DELIM_JOIN";
55: 	case PhysicalOperatorType::BLOCKWISE_NL_JOIN:
56: 		return "BLOCKWISE_NL_JOIN";
57: 	case PhysicalOperatorType::NESTED_LOOP_JOIN:
58: 		return "NESTED_LOOP_JOIN";
59: 	case PhysicalOperatorType::HASH_JOIN:
60: 		return "HASH_JOIN";
61: 	case PhysicalOperatorType::PIECEWISE_MERGE_JOIN:
62: 		return "PIECEWISE_MERGE_JOIN";
63: 	case PhysicalOperatorType::CROSS_PRODUCT:
64: 		return "CROSS_PRODUCT";
65: 	case PhysicalOperatorType::UNION:
66: 		return "UNION";
67: 	case PhysicalOperatorType::INSERT:
68: 		return "INSERT";
69: 	case PhysicalOperatorType::INSERT_SELECT:
70: 		return "INSERT_SELECT";
71: 	case PhysicalOperatorType::DELETE:
72: 		return "DELETE";
73: 	case PhysicalOperatorType::UPDATE:
74: 		return "UPDATE";
75: 	case PhysicalOperatorType::EXPORT_EXTERNAL_FILE:
76: 		return "EXPORT_EXTERNAL_FILE";
77: 	case PhysicalOperatorType::EMPTY_RESULT:
78: 		return "EMPTY_RESULT";
79: 	case PhysicalOperatorType::TABLE_FUNCTION:
80: 		return "TABLE_FUNCTION";
81: 	case PhysicalOperatorType::CREATE:
82: 		return "CREATE";
83: 	case PhysicalOperatorType::CREATE_INDEX:
84: 		return "CREATE_INDEX";
85: 	case PhysicalOperatorType::EXPLAIN:
86: 		return "EXPLAIN";
87: 	case PhysicalOperatorType::EXECUTE:
88: 		return "EXECUTE";
89: 	case PhysicalOperatorType::VACUUM:
90: 		return "VACUUM";
91: 	case PhysicalOperatorType::RECURSIVE_CTE:
92: 		return "REC_CTE";
93: 	case PhysicalOperatorType::RECURSIVE_CTE_SCAN:
94: 		return "REC_CTE_SCAN";
95: 	case PhysicalOperatorType::INVALID:
96: 		return "INVALID";
97: 	case PhysicalOperatorType::EXPRESSION_SCAN:
98: 		return "EXPRESSION_SCAN";
99: 	case PhysicalOperatorType::ALTER:
100: 		return "ALTER";
101: 	case PhysicalOperatorType::CREATE_SEQUENCE:
102: 		return "CREATE_SEQUENCE";
103: 	case PhysicalOperatorType::CREATE_VIEW:
104: 		return "CREATE_VIEW";
105: 	case PhysicalOperatorType::CREATE_SCHEMA:
106: 		return "CREATE_SCHEMA";
107: 	case PhysicalOperatorType::DROP:
108: 		return "DROP";
109: 	case PhysicalOperatorType::PRAGMA:
110: 		return "PRAGMA";
111: 	case PhysicalOperatorType::TRANSACTION:
112: 		return "TRANSACTION";
113: 	case PhysicalOperatorType::PREPARE:
114: 		return "PREPARE";
115: 	case PhysicalOperatorType::EXPORT:
116: 		return "EXPORT";
117: 	}
118: 	return "UNDEFINED";
119: }
120: 
121: } // namespace duckdb
[end of src/common/enums/physical_operator_type.cpp]
[start of src/execution/index/art/art.cpp]
1: #include "duckdb/execution/index/art/art.hpp"
2: #include "duckdb/execution/expression_executor.hpp"
3: #include "duckdb/common/vector_operations/vector_operations.hpp"
4: #include <algorithm>
5: #include <ctgmath>
6: 
7: namespace duckdb {
8: 
9: using namespace std;
10: 
11: ART::ART(vector<column_t> column_ids, vector<unique_ptr<Expression>> unbound_expressions, bool is_unique)
12:     : Index(IndexType::ART, column_ids, move(unbound_expressions)), is_unique(is_unique) {
13: 	tree = nullptr;
14: 	expression_result.Initialize(logical_types);
15: 	int n = 1;
16: 	//! little endian if true
17: 	if (*(char *)&n == 1) {
18: 		is_little_endian = true;
19: 	} else {
20: 		is_little_endian = false;
21: 	}
22: 	switch (types[0]) {
23: 	case PhysicalType::BOOL:
24: 	case PhysicalType::INT8:
25: 	case PhysicalType::INT16:
26: 	case PhysicalType::INT32:
27: 	case PhysicalType::INT64:
28: 	case PhysicalType::FLOAT:
29: 	case PhysicalType::DOUBLE:
30: 	case PhysicalType::VARCHAR:
31: 		break;
32: 	default:
33: 		throw InvalidTypeException(types[0], "Invalid type for index");
34: 	}
35: }
36: 
37: ART::~ART() {
38: }
39: 
40: bool ART::LeafMatches(Node *node, Key &key, unsigned depth) {
41: 	auto leaf = static_cast<Leaf *>(node);
42: 	Key &leaf_key = *leaf->value;
43: 	for (idx_t i = depth; i < leaf_key.len; i++) {
44: 		if (leaf_key[i] != key[i]) {
45: 			return false;
46: 		}
47: 	}
48: 
49: 	return true;
50: }
51: 
52: unique_ptr<IndexScanState> ART::InitializeScanSinglePredicate(Transaction &transaction, vector<column_t> column_ids,
53:                                                               Value value, ExpressionType expression_type) {
54: 	auto result = make_unique<ARTIndexScanState>(column_ids);
55: 	result->values[0] = value;
56: 	result->expressions[0] = expression_type;
57: 	return move(result);
58: }
59: 
60: unique_ptr<IndexScanState> ART::InitializeScanTwoPredicates(Transaction &transaction, vector<column_t> column_ids,
61:                                                             Value low_value, ExpressionType low_expression_type,
62:                                                             Value high_value, ExpressionType high_expression_type) {
63: 	auto result = make_unique<ARTIndexScanState>(column_ids);
64: 	result->values[0] = low_value;
65: 	result->expressions[0] = low_expression_type;
66: 	result->values[1] = high_value;
67: 	result->expressions[1] = high_expression_type;
68: 	return move(result);
69: }
70: 
71: //===--------------------------------------------------------------------===//
72: // Insert
73: //===--------------------------------------------------------------------===//
74: template <class T>
75: static void generate_keys(Vector &input, idx_t count, vector<unique_ptr<Key>> &keys, bool is_little_endian) {
76: 	VectorData idata;
77: 	input.Orrify(count, idata);
78: 
79: 	auto input_data = (T *)idata.data;
80: 	for (idx_t i = 0; i < count; i++) {
81: 		auto idx = idata.sel->get_index(i);
82: 		if ((*idata.nullmask)[idx]) {
83: 			keys.push_back(nullptr);
84: 		} else {
85: 			keys.push_back(Key::CreateKey<T>(input_data[idx], is_little_endian));
86: 		}
87: 	}
88: }
89: 
90: template <class T>
91: static void concatenate_keys(Vector &input, idx_t count, vector<unique_ptr<Key>> &keys, bool is_little_endian) {
92: 	VectorData idata;
93: 	input.Orrify(count, idata);
94: 
95: 	auto input_data = (T *)idata.data;
96: 	for (idx_t i = 0; i < count; i++) {
97: 		auto idx = idata.sel->get_index(i);
98: 		if ((*idata.nullmask)[idx] || !keys[i]) {
99: 			// either this column is NULL, or the previous column is NULL!
100: 			keys[i] = nullptr;
101: 		} else {
102: 			// concatenate the keys
103: 			auto old_key = move(keys[i]);
104: 			auto new_key = Key::CreateKey<T>(input_data[idx], is_little_endian);
105: 			auto keyLen = old_key->len + new_key->len;
106: 			auto compound_data = unique_ptr<data_t[]>(new data_t[keyLen]);
107: 			memcpy(compound_data.get(), old_key->data.get(), old_key->len);
108: 			memcpy(compound_data.get() + old_key->len, new_key->data.get(), new_key->len);
109: 			keys[i] = make_unique<Key>(move(compound_data), keyLen);
110: 		}
111: 	}
112: }
113: 
114: void ART::GenerateKeys(DataChunk &input, vector<unique_ptr<Key>> &keys) {
115: 	keys.reserve(STANDARD_VECTOR_SIZE);
116: 	// generate keys for the first input column
117: 	switch (input.data[0].type.InternalType()) {
118: 	case PhysicalType::BOOL:
119: 		generate_keys<bool>(input.data[0], input.size(), keys, is_little_endian);
120: 		break;
121: 	case PhysicalType::INT8:
122: 		generate_keys<int8_t>(input.data[0], input.size(), keys, is_little_endian);
123: 		break;
124: 	case PhysicalType::INT16:
125: 		generate_keys<int16_t>(input.data[0], input.size(), keys, is_little_endian);
126: 		break;
127: 	case PhysicalType::INT32:
128: 		generate_keys<int32_t>(input.data[0], input.size(), keys, is_little_endian);
129: 		break;
130: 	case PhysicalType::INT64:
131: 		generate_keys<int64_t>(input.data[0], input.size(), keys, is_little_endian);
132: 		break;
133: 	case PhysicalType::FLOAT:
134: 		generate_keys<float>(input.data[0], input.size(), keys, is_little_endian);
135: 		break;
136: 	case PhysicalType::DOUBLE:
137: 		generate_keys<double>(input.data[0], input.size(), keys, is_little_endian);
138: 		break;
139: 	case PhysicalType::VARCHAR:
140: 		generate_keys<string_t>(input.data[0], input.size(), keys, is_little_endian);
141: 		break;
142: 	default:
143: 		throw InvalidTypeException(input.data[0].type, "Invalid type for index");
144: 	}
145: 	for (idx_t i = 1; i < input.column_count(); i++) {
146: 		// for each of the remaining columns, concatenate
147: 		switch (input.data[i].type.InternalType()) {
148: 		case PhysicalType::BOOL:
149: 			concatenate_keys<bool>(input.data[i], input.size(), keys, is_little_endian);
150: 			break;
151: 		case PhysicalType::INT8:
152: 			concatenate_keys<int8_t>(input.data[i], input.size(), keys, is_little_endian);
153: 			break;
154: 		case PhysicalType::INT16:
155: 			concatenate_keys<int16_t>(input.data[i], input.size(), keys, is_little_endian);
156: 			break;
157: 		case PhysicalType::INT32:
158: 			concatenate_keys<int32_t>(input.data[i], input.size(), keys, is_little_endian);
159: 			break;
160: 		case PhysicalType::INT64:
161: 			concatenate_keys<int64_t>(input.data[i], input.size(), keys, is_little_endian);
162: 			break;
163: 		case PhysicalType::FLOAT:
164: 			concatenate_keys<float>(input.data[i], input.size(), keys, is_little_endian);
165: 			break;
166: 		case PhysicalType::DOUBLE:
167: 			concatenate_keys<double>(input.data[i], input.size(), keys, is_little_endian);
168: 			break;
169: 		case PhysicalType::VARCHAR:
170: 			concatenate_keys<string_t>(input.data[i], input.size(), keys, is_little_endian);
171: 			break;
172: 		default:
173: 			throw InvalidTypeException(input.data[0].type, "Invalid type for index");
174: 		}
175: 	}
176: }
177: 
178: bool ART::Insert(IndexLock &lock, DataChunk &input, Vector &row_ids) {
179: 	assert(row_ids.type.InternalType() == ROW_TYPE);
180: 	assert(logical_types[0] == input.data[0].type);
181: 
182: 	// generate the keys for the given input
183: 	vector<unique_ptr<Key>> keys;
184: 	GenerateKeys(input, keys);
185: 
186: 	// now insert the elements into the index
187: 	row_ids.Normalify(input.size());
188: 	auto row_identifiers = FlatVector::GetData<row_t>(row_ids);
189: 	idx_t failed_index = INVALID_INDEX;
190: 	for (idx_t i = 0; i < input.size(); i++) {
191: 		if (!keys[i]) {
192: 			continue;
193: 		}
194: 
195: 		row_t row_id = row_identifiers[i];
196: 		if (!Insert(tree, move(keys[i]), 0, row_id)) {
197: 			// failed to insert because of constraint violation
198: 			failed_index = i;
199: 			break;
200: 		}
201: 	}
202: 	if (failed_index != INVALID_INDEX) {
203: 		// failed to insert because of constraint violation: remove previously inserted entries
204: 		// generate keys again
205: 		keys.clear();
206: 		GenerateKeys(input, keys);
207: 		unique_ptr<Key> key;
208: 
209: 		// now erase the entries
210: 		for (idx_t i = 0; i < failed_index; i++) {
211: 			if (!keys[i]) {
212: 				continue;
213: 			}
214: 			row_t row_id = row_identifiers[i];
215: 			Erase(tree, *keys[i], 0, row_id);
216: 		}
217: 		return false;
218: 	}
219: 	return true;
220: }
221: 
222: bool ART::Append(IndexLock &lock, DataChunk &appended_data, Vector &row_identifiers) {
223: 	// first resolve the expressions for the index
224: 	ExecuteExpressions(appended_data, expression_result);
225: 
226: 	// now insert into the index
227: 	return Insert(lock, expression_result, row_identifiers);
228: }
229: 
230: void ART::VerifyAppend(DataChunk &chunk) {
231: 	if (!is_unique) {
232: 		return;
233: 	}
234: 	// unique index, check
235: 	lock_guard<mutex> l(lock);
236: 	// first resolve the expressions for the index
237: 	ExecuteExpressions(chunk, expression_result);
238: 
239: 	// generate the keys for the given input
240: 	vector<unique_ptr<Key>> keys;
241: 	GenerateKeys(expression_result, keys);
242: 
243: 	for (idx_t i = 0; i < chunk.size(); i++) {
244: 		if (!keys[i]) {
245: 			continue;
246: 		}
247: 		if (Lookup(tree, *keys[i], 0) != nullptr) {
248: 			// node already exists in tree
249: 			throw ConstraintException("duplicate key value violates primary key or unique constraint");
250: 		}
251: 	}
252: }
253: 
254: bool ART::InsertToLeaf(Leaf &leaf, row_t row_id) {
255: 	if (is_unique && leaf.num_elements != 0) {
256: 		return false;
257: 	}
258: 	leaf.Insert(row_id);
259: 	return true;
260: }
261: 
262: bool ART::Insert(unique_ptr<Node> &node, unique_ptr<Key> value, unsigned depth, row_t row_id) {
263: 	Key &key = *value;
264: 	if (!node) {
265: 		// node is currently empty, create a leaf here with the key
266: 		node = make_unique<Leaf>(*this, move(value), row_id);
267: 		return true;
268: 	}
269: 
270: 	if (node->type == NodeType::NLeaf) {
271: 		// Replace leaf with Node4 and store both leaves in it
272: 		auto leaf = static_cast<Leaf *>(node.get());
273: 
274: 		Key &existingKey = *leaf->value;
275: 		uint32_t newPrefixLength = 0;
276: 		// Leaf node is already there, update row_id vector
277: 		if (depth + newPrefixLength == existingKey.len && existingKey.len == key.len) {
278: 			return InsertToLeaf(*leaf, row_id);
279: 		}
280: 		while (existingKey[depth + newPrefixLength] == key[depth + newPrefixLength]) {
281: 			newPrefixLength++;
282: 			// Leaf node is already there, update row_id vector
283: 			if (depth + newPrefixLength == existingKey.len && existingKey.len == key.len) {
284: 				return InsertToLeaf(*leaf, row_id);
285: 			}
286: 		}
287: 
288: 		unique_ptr<Node> newNode = make_unique<Node4>(*this, newPrefixLength);
289: 		newNode->prefix_length = newPrefixLength;
290: 		memcpy(newNode->prefix.get(), &key[depth], newPrefixLength);
291: 		Node4::insert(*this, newNode, existingKey[depth + newPrefixLength], node);
292: 		unique_ptr<Node> leaf_node = make_unique<Leaf>(*this, move(value), row_id);
293: 		Node4::insert(*this, newNode, key[depth + newPrefixLength], leaf_node);
294: 		node = move(newNode);
295: 		return true;
296: 	}
297: 
298: 	// Handle prefix of inner node
299: 	if (node->prefix_length) {
300: 		uint32_t mismatchPos = Node::PrefixMismatch(*this, node.get(), key, depth);
301: 		if (mismatchPos != node->prefix_length) {
302: 			// Prefix differs, create new node
303: 			unique_ptr<Node> newNode = make_unique<Node4>(*this, mismatchPos);
304: 			newNode->prefix_length = mismatchPos;
305: 			memcpy(newNode->prefix.get(), node->prefix.get(), mismatchPos);
306: 			// Break up prefix
307: 			auto node_ptr = node.get();
308: 			Node4::insert(*this, newNode, node->prefix[mismatchPos], node);
309: 			node_ptr->prefix_length -= (mismatchPos + 1);
310: 			memmove(node_ptr->prefix.get(), node_ptr->prefix.get() + mismatchPos + 1, node_ptr->prefix_length);
311: 			unique_ptr<Node> leaf_node = make_unique<Leaf>(*this, move(value), row_id);
312: 			Node4::insert(*this, newNode, key[depth + mismatchPos], leaf_node);
313: 			node = move(newNode);
314: 			return true;
315: 		}
316: 		depth += node->prefix_length;
317: 	}
318: 
319: 	// Recurse
320: 	idx_t pos = node->GetChildPos(key[depth]);
321: 	if (pos != INVALID_INDEX) {
322: 		auto child = node->GetChild(pos);
323: 		return Insert(*child, move(value), depth + 1, row_id);
324: 	}
325: 	unique_ptr<Node> newNode = make_unique<Leaf>(*this, move(value), row_id);
326: 	Node::InsertLeaf(*this, node, key[depth], newNode);
327: 	return true;
328: }
329: 
330: //===--------------------------------------------------------------------===//
331: // Delete
332: //===--------------------------------------------------------------------===//
333: void ART::Delete(IndexLock &state, DataChunk &input, Vector &row_ids) {
334: 	// first resolve the expressions
335: 	ExecuteExpressions(input, expression_result);
336: 
337: 	// then generate the keys for the given input
338: 	vector<unique_ptr<Key>> keys;
339: 	GenerateKeys(expression_result, keys);
340: 
341: 	// now erase the elements from the database
342: 	row_ids.Normalify(input.size());
343: 	auto row_identifiers = FlatVector::GetData<row_t>(row_ids);
344: 
345: 	for (idx_t i = 0; i < input.size(); i++) {
346: 		if (!keys[i]) {
347: 			continue;
348: 		}
349: 		Erase(tree, *keys[i], 0, row_identifiers[i]);
350: 	}
351: }
352: 
353: void ART::Erase(unique_ptr<Node> &node, Key &key, unsigned depth, row_t row_id) {
354: 	if (!node) {
355: 		return;
356: 	}
357: 	// Delete a leaf from a tree
358: 	if (node->type == NodeType::NLeaf) {
359: 		// Make sure we have the right leaf
360: 		if (ART::LeafMatches(node.get(), key, depth)) {
361: 			auto leaf = static_cast<Leaf *>(node.get());
362: 			leaf->Remove(row_id);
363: 			if (leaf->num_elements == 0) {
364: 				node.reset();
365: 			}
366: 		}
367: 		return;
368: 	}
369: 
370: 	// Handle prefix
371: 	if (node->prefix_length) {
372: 		if (Node::PrefixMismatch(*this, node.get(), key, depth) != node->prefix_length) {
373: 			return;
374: 		}
375: 		depth += node->prefix_length;
376: 	}
377: 	idx_t pos = node->GetChildPos(key[depth]);
378: 	if (pos != INVALID_INDEX) {
379: 		auto child = node->GetChild(pos);
380: 		assert(child);
381: 
382: 		unique_ptr<Node> &child_ref = *child;
383: 		if (child_ref->type == NodeType::NLeaf && LeafMatches(child_ref.get(), key, depth)) {
384: 			// Leaf found, remove entry
385: 			auto leaf = static_cast<Leaf *>(child_ref.get());
386: 			leaf->Remove(row_id);
387: 			if (leaf->num_elements == 0) {
388: 				// Leaf is empty, delete leaf, decrement node counter and maybe shrink node
389: 				Node::Erase(*this, node, pos);
390: 			}
391: 		} else {
392: 			// Recurse
393: 			Erase(*child, key, depth + 1, row_id);
394: 		}
395: 	}
396: }
397: 
398: //===--------------------------------------------------------------------===//
399: // Point Query
400: //===--------------------------------------------------------------------===//
401: static unique_ptr<Key> CreateKey(ART &art, PhysicalType type, Value &value) {
402: 	assert(type == value.type().InternalType());
403: 	switch (type) {
404: 	case PhysicalType::BOOL:
405: 		return Key::CreateKey<bool>(value.value_.boolean, art.is_little_endian);
406: 	case PhysicalType::INT8:
407: 		return Key::CreateKey<int8_t>(value.value_.tinyint, art.is_little_endian);
408: 	case PhysicalType::INT16:
409: 		return Key::CreateKey<int16_t>(value.value_.smallint, art.is_little_endian);
410: 	case PhysicalType::INT32:
411: 		return Key::CreateKey<int32_t>(value.value_.integer, art.is_little_endian);
412: 	case PhysicalType::INT64:
413: 		return Key::CreateKey<int64_t>(value.value_.bigint, art.is_little_endian);
414: 	case PhysicalType::FLOAT:
415: 		return Key::CreateKey<float>(value.value_.float_, art.is_little_endian);
416: 	case PhysicalType::DOUBLE:
417: 		return Key::CreateKey<double>(value.value_.double_, art.is_little_endian);
418: 	case PhysicalType::VARCHAR:
419: 		return Key::CreateKey<string_t>(string_t(value.str_value.c_str(), value.str_value.size()),
420: 		                                art.is_little_endian);
421: 	default:
422: 		throw InvalidTypeException(type, "Invalid type for index");
423: 	}
424: }
425: 
426: void ART::SearchEqual(vector<row_t> &result_ids, ARTIndexScanState *state) {
427: 	unique_ptr<Key> key = CreateKey(*this, types[0], state->values[0]);
428: 	auto leaf = static_cast<Leaf *>(Lookup(tree, *key, 0));
429: 	if (!leaf) {
430: 		return;
431: 	}
432: 	for (idx_t i = 0; i < leaf->num_elements; i++) {
433: 		row_t row_id = leaf->GetRowId(i);
434: 		result_ids.push_back(row_id);
435: 	}
436: }
437: 
438: Node *ART::Lookup(unique_ptr<Node> &node, Key &key, unsigned depth) {
439: 	auto node_val = node.get();
440: 
441: 	while (node_val) {
442: 		if (node_val->type == NodeType::NLeaf) {
443: 			auto leaf = static_cast<Leaf *>(node_val);
444: 			Key &leafKey = *leaf->value;
445: 			//! Check leaf
446: 			for (idx_t i = depth; i < leafKey.len; i++) {
447: 				if (leafKey[i] != key[i]) {
448: 					return nullptr;
449: 				}
450: 			}
451: 			return node_val;
452: 		}
453: 		if (node_val->prefix_length) {
454: 			for (idx_t pos = 0; pos < node_val->prefix_length; pos++) {
455: 				if (key[depth + pos] != node_val->prefix[pos]) {
456: 					return nullptr;
457: 				}
458: 			}
459: 			depth += node_val->prefix_length;
460: 		}
461: 		idx_t pos = node_val->GetChildPos(key[depth]);
462: 		if (pos == INVALID_INDEX) {
463: 			return nullptr;
464: 		}
465: 		node_val = node_val->GetChild(pos)->get();
466: 		assert(node_val);
467: 
468: 		depth++;
469: 	}
470: 
471: 	return nullptr;
472: }
473: 
474: //===--------------------------------------------------------------------===//
475: // Iterator scans
476: //===--------------------------------------------------------------------===//
477: template <bool HAS_BOUND, bool INCLUSIVE>
478: void ART::IteratorScan(ARTIndexScanState *state, Iterator *it, vector<row_t> &result_ids, Key *bound) {
479: 	bool has_next;
480: 	do {
481: 		if (HAS_BOUND) {
482: 			assert(bound);
483: 			if (INCLUSIVE) {
484: 				if (*it->node->value > *bound) {
485: 					break;
486: 				}
487: 			} else {
488: 				if (*it->node->value >= *bound) {
489: 					break;
490: 				}
491: 			}
492: 		}
493: 		for (idx_t i = 0; i < it->node->num_elements; i++) {
494: 			row_t row_id = it->node->GetRowId(i);
495: 			result_ids.push_back(row_id);
496: 		}
497: 		has_next = ART::IteratorNext(*it);
498: 	} while (has_next);
499: }
500: 
501: bool ART::IteratorNext(Iterator &it) {
502: 	// Skip leaf
503: 	if ((it.depth) && ((it.stack[it.depth - 1].node)->type == NodeType::NLeaf)) {
504: 		it.depth--;
505: 	}
506: 
507: 	// Look for the next leaf
508: 	while (it.depth > 0) {
509: 		auto &top = it.stack[it.depth - 1];
510: 		Node *node = top.node;
511: 
512: 		if (node->type == NodeType::NLeaf) {
513: 			// found a leaf: move to next node
514: 			it.node = (Leaf *)node;
515: 			return true;
516: 		}
517: 
518: 		// Find next node
519: 		top.pos = node->GetNextPos(top.pos);
520: 		if (top.pos != INVALID_INDEX) {
521: 			// next node found: go there
522: 			it.stack[it.depth].node = node->GetChild(top.pos)->get();
523: 			it.stack[it.depth].pos = INVALID_INDEX;
524: 			it.depth++;
525: 		} else {
526: 			// no node found: move up the tree
527: 			it.depth--;
528: 		}
529: 	}
530: 	return false;
531: }
532: 
533: //===--------------------------------------------------------------------===//
534: // Greater Than
535: // Returns: True (If found leaf >= key)
536: //          False (Otherwise)
537: //===--------------------------------------------------------------------===//
538: bool ART::Bound(unique_ptr<Node> &n, Key &key, Iterator &it, bool inclusive) {
539: 	it.depth = 0;
540: 	bool equal = false;
541: 	if (!n) {
542: 		return false;
543: 	}
544: 	Node *node = n.get();
545: 
546: 	idx_t depth = 0;
547: 	while (true) {
548: 		auto &top = it.stack[it.depth];
549: 		top.node = node;
550: 		it.depth++;
551: 		if (!equal) {
552: 			while (node->type != NodeType::NLeaf) {
553: 				node = node->GetChild(node->GetMin())->get();
554: 				auto &c_top = it.stack[it.depth];
555: 				c_top.node = node;
556: 				it.depth++;
557: 			}
558: 		}
559: 		if (node->type == NodeType::NLeaf) {
560: 			// found a leaf node: check if it is bigger or equal than the current key
561: 			auto leaf = static_cast<Leaf *>(node);
562: 			it.node = leaf;
563: 			// if the search is not inclusive the leaf node could still be equal to the current value
564: 			// check if leaf is equal to the current key
565: 			if (*leaf->value == key) {
566: 				// if its not inclusive check if there is a next leaf
567: 				if (!inclusive && !IteratorNext(it)) {
568: 					return false;
569: 				} else {
570: 					return true;
571: 				}
572: 			}
573: 
574: 			if (*leaf->value > key) {
575: 				return true;
576: 			}
577: 			// Leaf is lower than key
578: 			// Check if next leaf is still lower than key
579: 			while (IteratorNext(it)) {
580: 				if (*it.node->value == key) {
581: 					// if its not inclusive check if there is a next leaf
582: 					if (!inclusive && !IteratorNext(it)) {
583: 						return false;
584: 					} else {
585: 						return true;
586: 					}
587: 				} else if (*it.node->value > key) {
588: 					// if its not inclusive check if there is a next leaf
589: 					return true;
590: 				}
591: 			}
592: 			return false;
593: 		}
594: 		uint32_t mismatchPos = Node::PrefixMismatch(*this, node, key, depth);
595: 		if (mismatchPos != node->prefix_length) {
596: 			if (node->prefix[mismatchPos] < key[depth + mismatchPos]) {
597: 				// Less
598: 				it.depth--;
599: 				return IteratorNext(it);
600: 			} else {
601: 				// Greater
602: 				top.pos = INVALID_INDEX;
603: 				return IteratorNext(it);
604: 			}
605: 		}
606: 		// prefix matches, search inside the child for the key
607: 		depth += node->prefix_length;
608: 
609: 		top.pos = node->GetChildGreaterEqual(key[depth], equal);
610: 		if (top.pos == INVALID_INDEX) {
611: 			// Find min leaf
612: 			top.pos = node->GetMin();
613: 		}
614: 		node = node->GetChild(top.pos)->get();
615: 		//! This means all children of this node qualify as geq
616: 
617: 		depth++;
618: 	}
619: }
620: 
621: void ART::SearchGreater(vector<row_t> &result_ids, ARTIndexScanState *state, bool inclusive) {
622: 	Iterator *it = &state->iterator;
623: 	auto key = CreateKey(*this, types[0], state->values[0]);
624: 
625: 	// greater than scan: first set the iterator to the node at which we will start our scan by finding the lowest node
626: 	// that satisfies our requirement
627: 	if (!it->start) {
628: 		bool found = ART::Bound(tree, *key, *it, inclusive);
629: 		if (!found) {
630: 			return;
631: 		}
632: 		it->start = true;
633: 	}
634: 	// after that we continue the scan; we don't need to check the bounds as any value following this value is
635: 	// automatically bigger and hence satisfies our predicate
636: 	IteratorScan<false, false>(state, it, result_ids, nullptr);
637: }
638: 
639: //===--------------------------------------------------------------------===//
640: // Less Than
641: //===--------------------------------------------------------------------===//
642: static Leaf &FindMinimum(Iterator &it, Node &node) {
643: 	Node *next = nullptr;
644: 	idx_t pos = 0;
645: 	switch (node.type) {
646: 	case NodeType::NLeaf:
647: 		it.node = (Leaf *)&node;
648: 		return (Leaf &)node;
649: 	case NodeType::N4:
650: 		next = ((Node4 &)node).child[0].get();
651: 		break;
652: 	case NodeType::N16:
653: 		next = ((Node16 &)node).child[0].get();
654: 		break;
655: 	case NodeType::N48: {
656: 		auto &n48 = (Node48 &)node;
657: 		while (n48.childIndex[pos] == Node::EMPTY_MARKER) {
658: 			pos++;
659: 		}
660: 		next = n48.child[n48.childIndex[pos]].get();
661: 		break;
662: 	}
663: 	case NodeType::N256: {
664: 		auto &n256 = (Node256 &)node;
665: 		while (!n256.child[pos]) {
666: 			pos++;
667: 		}
668: 		next = n256.child[pos].get();
669: 		break;
670: 	}
671: 	}
672: 	it.stack[it.depth].node = &node;
673: 	it.stack[it.depth].pos = pos;
674: 	it.depth++;
675: 	return FindMinimum(it, *next);
676: }
677: 
678: void ART::SearchLess(vector<row_t> &result_ids, ARTIndexScanState *state, bool inclusive) {
679: 	if (!tree) {
680: 		return;
681: 	}
682: 
683: 	Iterator *it = &state->iterator;
684: 	auto upper_bound = CreateKey(*this, types[0], state->values[0]);
685: 
686: 	if (!it->start) {
687: 		// first find the minimum value in the ART: we start scanning from this value
688: 		auto &minimum = FindMinimum(state->iterator, *tree);
689: 		// early out min value higher than upper bound query
690: 		if (*minimum.value > *upper_bound) {
691: 			return;
692: 		}
693: 		it->start = true;
694: 	}
695: 	// now continue the scan until we reach the upper bound
696: 	if (inclusive) {
697: 		IteratorScan<true, true>(state, it, result_ids, upper_bound.get());
698: 	} else {
699: 		IteratorScan<true, false>(state, it, result_ids, upper_bound.get());
700: 	}
701: }
702: 
703: //===--------------------------------------------------------------------===//
704: // Closed Range Query
705: //===--------------------------------------------------------------------===//
706: void ART::SearchCloseRange(vector<row_t> &result_ids, ARTIndexScanState *state, bool left_inclusive,
707:                            bool right_inclusive) {
708: 	auto lower_bound = CreateKey(*this, types[0], state->values[0]);
709: 	auto upper_bound = CreateKey(*this, types[0], state->values[1]);
710: 	Iterator *it = &state->iterator;
711: 	// first find the first node that satisfies the left predicate
712: 	if (!it->start) {
713: 		bool found = ART::Bound(tree, *lower_bound, *it, left_inclusive);
714: 		if (!found) {
715: 			return;
716: 		}
717: 		it->start = true;
718: 	}
719: 	// now continue the scan until we reach the upper bound
720: 	if (right_inclusive) {
721: 		IteratorScan<true, true>(state, it, result_ids, upper_bound.get());
722: 	} else {
723: 		IteratorScan<true, false>(state, it, result_ids, upper_bound.get());
724: 	}
725: }
726: 
727: void ART::Scan(Transaction &transaction, DataTable &table, TableIndexScanState &table_state, DataChunk &result) {
728: 	auto state = (ARTIndexScanState *)table_state.index_state.get();
729: 
730: 	// scan the index
731: 	if (!state->checked) {
732: 		vector<row_t> result_ids;
733: 		assert(state->values[0].type().InternalType() == types[0]);
734: 
735: 		if (state->values[1].is_null) {
736: 			lock_guard<mutex> l(lock);
737: 			// single predicate
738: 			switch (state->expressions[0]) {
739: 			case ExpressionType::COMPARE_EQUAL:
740: 				SearchEqual(result_ids, state);
741: 				break;
742: 			case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
743: 				SearchGreater(result_ids, state, true);
744: 				break;
745: 			case ExpressionType::COMPARE_GREATERTHAN:
746: 				SearchGreater(result_ids, state, false);
747: 				break;
748: 			case ExpressionType::COMPARE_LESSTHANOREQUALTO:
749: 				SearchLess(result_ids, state, true);
750: 				break;
751: 			case ExpressionType::COMPARE_LESSTHAN:
752: 				SearchLess(result_ids, state, false);
753: 				break;
754: 			default:
755: 				throw NotImplementedException("Operation not implemented");
756: 			}
757: 		} else {
758: 			lock_guard<mutex> l(lock);
759: 			// two predicates
760: 			assert(state->values[1].type().InternalType() == types[0]);
761: 			bool left_inclusive = state->expressions[0] == ExpressionType ::COMPARE_GREATERTHANOREQUALTO;
762: 			bool right_inclusive = state->expressions[1] == ExpressionType ::COMPARE_LESSTHANOREQUALTO;
763: 			SearchCloseRange(result_ids, state, left_inclusive, right_inclusive);
764: 		}
765: 		state->checked = true;
766: 
767: 		if (result_ids.size() == 0) {
768: 			return;
769: 		}
770: 
771: 		// sort the row ids
772: 		sort(result_ids.begin(), result_ids.end());
773: 		// duplicate eliminate the row ids and append them to the row ids of the state
774: 		state->result_ids.reserve(result_ids.size());
775: 
776: 		state->result_ids.push_back(result_ids[0]);
777: 		for (idx_t i = 1; i < result_ids.size(); i++) {
778: 			if (result_ids[i] != result_ids[i - 1]) {
779: 				state->result_ids.push_back(result_ids[i]);
780: 			}
781: 		}
782: 	}
783: 
784: 	if (state->result_index >= state->result_ids.size()) {
785: 		// exhausted all row ids
786: 		return;
787: 	}
788: 
789: 	// create a vector pointing to the current set of row ids
790: 	Vector row_identifiers(LOGICAL_ROW_TYPE, (data_ptr_t)&state->result_ids[state->result_index]);
791: 	idx_t scan_count = MinValue<idx_t>(STANDARD_VECTOR_SIZE, state->result_ids.size() - state->result_index);
792: 
793: 	// fetch the actual values from the base table
794: 	table.Fetch(transaction, result, state->column_ids, row_identifiers, scan_count, table_state);
795: 
796: 	// move to the next set of row ids
797: 	state->result_index += scan_count;
798: }
799: } // namespace duckdb
[end of src/execution/index/art/art.cpp]
[start of src/execution/operator/scan/CMakeLists.txt]
1: add_library_unity(duckdb_operator_scan
2:                   OBJECT
3:                   physical_chunk_scan.cpp
4:                   physical_dummy_scan.cpp
5:                   physical_empty_result.cpp
6:                   physical_expression_scan.cpp
7:                   physical_index_scan.cpp
8:                   physical_table_function.cpp
9:                   physical_table_scan.cpp)
10: set(ALL_OBJECT_FILES
11:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_operator_scan>
12:     PARENT_SCOPE)
[end of src/execution/operator/scan/CMakeLists.txt]
[start of src/execution/operator/scan/physical_index_scan.cpp]
1: #include "duckdb/execution/operator/scan/physical_index_scan.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
4: #include "duckdb/transaction/transaction.hpp"
5: 
6: using namespace std;
7: 
8: namespace duckdb {
9: 
10: class PhysicalIndexScanOperatorState : public PhysicalOperatorState {
11: public:
12: 	PhysicalIndexScanOperatorState() : PhysicalOperatorState(nullptr), initialized(false) {
13: 	}
14: 
15: 	bool initialized;
16: 	TableIndexScanState scan_state;
17: };
18: 
19: void PhysicalIndexScan::GetChunkInternal(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state_) {
20: 	auto state = reinterpret_cast<PhysicalIndexScanOperatorState *>(state_);
21: 	if (column_ids.size() == 0) {
22: 		return;
23: 	}
24: 
25: 	auto &transaction = Transaction::GetTransaction(context.client);
26: 	if (!state->initialized) {
27: 		// initialize the scan state of the index
28: 		if (low_index && high_index) {
29: 			// two predicates
30: 			table.InitializeIndexScan(transaction, state->scan_state, index, low_value, low_expression_type, high_value,
31: 			                          high_expression_type, column_ids);
32: 		} else {
33: 			// single predicate
34: 			Value value;
35: 			ExpressionType type;
36: 			if (low_index) {
37: 				// > or >=
38: 				value = low_value;
39: 				type = low_expression_type;
40: 			} else if (high_index) {
41: 				// < or <=
42: 				value = high_value;
43: 				type = high_expression_type;
44: 			} else {
45: 				// equality
46: 				assert(equal_index);
47: 				value = equal_value;
48: 				type = ExpressionType::COMPARE_EQUAL;
49: 			}
50: 			table.InitializeIndexScan(transaction, state->scan_state, index, value, type, column_ids);
51: 		}
52: 		state->initialized = true;
53: 	}
54: 	// scan the index
55: 	table.IndexScan(transaction, chunk, state->scan_state);
56: }
57: 
58: string PhysicalIndexScan::ExtraRenderInformation() const {
59: 	return tableref.name + "[" + low_value.ToString() + "]";
60: }
61: 
62: unique_ptr<PhysicalOperatorState> PhysicalIndexScan::GetOperatorState() {
63: 	return make_unique<PhysicalIndexScanOperatorState>();
64: }
65: 
66: } // namespace duckdb
[end of src/execution/operator/scan/physical_index_scan.cpp]
[start of src/execution/operator/scan/physical_table_function.cpp]
1: #include "duckdb/execution/operator/scan/physical_table_function.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
5: #include "duckdb/execution/expression_executor.hpp"
6: #include "duckdb/planner/expression/bound_function_expression.hpp"
7: 
8: using namespace std;
9: 
10: namespace duckdb {
11: 
12: void PhysicalTableFunction::GetChunkInternal(ExecutionContext &context, DataChunk &chunk,
13:                                              PhysicalOperatorState *state) {
14: 	// run main code
15: 	function.function(context.client, parameters, chunk, bind_data.get());
16: 	if (chunk.size() == 0) {
17: 		// finished, call clean up
18: 		if (function.final) {
19: 			function.final(context.client, bind_data.get());
20: 		}
21: 	}
22: }
23: 
24: string PhysicalTableFunction::ExtraRenderInformation() const {
25: 	return function.name;
26: }
27: 
28: } // namespace duckdb
[end of src/execution/operator/scan/physical_table_function.cpp]
[start of src/execution/operator/scan/physical_table_scan.cpp]
1: #include "duckdb/execution/operator/scan/physical_table_scan.hpp"
2: 
3: #include <utility>
4: 
5: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
6: #include "duckdb/transaction/transaction.hpp"
7: #include "duckdb/planner/expression/bound_conjunction_expression.hpp"
8: 
9: #include "duckdb/parallel/task_context.hpp"
10: 
11: using namespace std;
12: 
13: namespace duckdb {
14: 
15: class PhysicalTableScanOperatorState : public PhysicalOperatorState {
16: public:
17: 	PhysicalTableScanOperatorState(Expression &expr)
18: 	    : PhysicalOperatorState(nullptr), initialized(false), executor(expr) {
19: 	}
20: 	PhysicalTableScanOperatorState() : PhysicalOperatorState(nullptr), initialized(false) {
21: 	}
22: 	//! Whether or not the scan has been initialized
23: 	bool initialized;
24: 	//! The current position in the scan
25: 	TableScanState scan_state;
26: 	//! Execute filters inside the table
27: 	ExpressionExecutor executor;
28: };
29: 
30: PhysicalTableScan::PhysicalTableScan(vector<LogicalType> types, TableCatalogEntry &tableref, DataTable &table,
31:                                      vector<column_t> column_ids, vector<unique_ptr<Expression>> filter,
32:                                      unordered_map<idx_t, vector<TableFilter>> table_filters)
33:     : PhysicalOperator(PhysicalOperatorType::SEQ_SCAN, move(types)), tableref(tableref), table(table),
34:       column_ids(move(column_ids)), table_filters(move(table_filters)) {
35: 	if (filter.size() > 1) {
36: 		//! create a big AND out of the expressions
37: 		auto conjunction = make_unique<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
38: 		for (auto &expr : filter) {
39: 			conjunction->children.push_back(move(expr));
40: 		}
41: 		expression = move(conjunction);
42: 	} else if (filter.size() == 1) {
43: 		expression = move(filter[0]);
44: 	}
45: }
46: 
47: class TableScanTaskInfo : public OperatorTaskInfo {
48: public:
49: 	TableScanState state;
50: };
51: 
52: void PhysicalTableScan::ParallelScanInfo(ClientContext &context,
53:                                          std::function<void(unique_ptr<OperatorTaskInfo>)> callback) {
54: 	// generate parallel scans
55: 	table.InitializeParallelScan(context, column_ids, &table_filters, [&](TableScanState state) {
56: 		auto task = make_unique<TableScanTaskInfo>();
57: 		task->state = move(state);
58: 		callback(move(task));
59: 	});
60: }
61: 
62: void PhysicalTableScan::GetChunkInternal(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state_) {
63: 	auto state = reinterpret_cast<PhysicalTableScanOperatorState *>(state_);
64: 	if (column_ids.empty()) {
65: 		return;
66: 	}
67: 	auto &transaction = Transaction::GetTransaction(context.client);
68: 	if (!state->initialized) {
69: 		auto &task = context.task;
70: 		auto task_info = task.task_info.find(this);
71: 		if (task_info != task.task_info.end()) {
72: 			// task specific limitations: scan the part indicated by the task
73: 			auto &info = (TableScanTaskInfo &)*task_info->second;
74: 			state->scan_state = move(info.state);
75: 		} else {
76: 			// no task specific limitations for the scan: scan the entire table
77: 			table.InitializeScan(transaction, state->scan_state, column_ids, &table_filters);
78: 		}
79: 		state->initialized = true;
80: 	}
81: 	table.Scan(transaction, chunk, state->scan_state, column_ids, table_filters);
82: }
83: 
84: string PhysicalTableScan::ExtraRenderInformation() const {
85: 	if (expression) {
86: 		return tableref.name + " " + expression->ToString();
87: 	} else {
88: 		return tableref.name;
89: 	}
90: }
91: 
92: unique_ptr<PhysicalOperatorState> PhysicalTableScan::GetOperatorState() {
93: 	if (expression) {
94: 		return make_unique<PhysicalTableScanOperatorState>(*expression);
95: 	} else {
96: 		return make_unique<PhysicalTableScanOperatorState>();
97: 	}
98: }
99: 
100: } // namespace duckdb
[end of src/execution/operator/scan/physical_table_scan.cpp]
[start of src/execution/physical_plan/CMakeLists.txt]
1: add_library_unity(
2:   duckdb_physical_plan
3:   OBJECT
4:   plan_aggregate.cpp
5:   plan_any_join.cpp
6:   plan_chunk_get.cpp
7:   plan_comparison_join.cpp
8:   plan_copy_from_file.cpp
9:   plan_copy_to_file.cpp
10:   plan_create.cpp
11:   plan_create_index.cpp
12:   plan_create_table.cpp
13:   plan_cross_product.cpp
14:   plan_delete.cpp
15:   plan_delim_get.cpp
16:   plan_delim_join.cpp
17:   plan_distinct.cpp
18:   plan_empty_result.cpp
19:   plan_execute.cpp
20:   plan_explain.cpp
21:   plan_export.cpp
22:   plan_filter.cpp
23:   plan_get.cpp
24:   plan_index_scan.cpp
25:   plan_insert.cpp
26:   plan_limit.cpp
27:   plan_order.cpp
28:   plan_pragma.cpp
29:   plan_prepare.cpp
30:   plan_projection.cpp
31:   plan_set_operation.cpp
32:   plan_simple.cpp
33:   plan_table_function.cpp
34:   plan_top_n.cpp
35:   plan_update.cpp
36:   plan_window.cpp
37:   plan_unnest.cpp
38:   plan_expression_get.cpp
39:   plan_recursive_cte.cpp)
40: set(ALL_OBJECT_FILES
41:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_physical_plan>
42:     PARENT_SCOPE)
[end of src/execution/physical_plan/CMakeLists.txt]
[start of src/execution/physical_plan/plan_get.cpp]
1: #include "duckdb/execution/operator/scan/physical_dummy_scan.hpp"
2: #include "duckdb/execution/operator/scan/physical_table_scan.hpp"
3: #include "duckdb/execution/physical_plan_generator.hpp"
4: #include "duckdb/planner/operator/logical_get.hpp"
5: 
6: namespace duckdb {
7: using namespace std;
8: 
9: unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalGet &op) {
10: 	assert(op.children.empty());
11: 	unordered_map<idx_t, vector<TableFilter>> table_filter_umap;
12: 	if (!op.table) {
13: 		return make_unique<PhysicalDummyScan>(op.types);
14: 	} else {
15: 		for (auto &tableFilter : op.tableFilters) {
16: 			for (idx_t i = 0; i < op.column_ids.size(); i++) {
17: 				if (tableFilter.column_index == op.column_ids[i]) {
18: 					tableFilter.column_index = i;
19: 					auto filter = table_filter_umap.find(i);
20: 					if (filter != table_filter_umap.end()) {
21: 						filter->second.push_back(tableFilter);
22: 					} else {
23: 						table_filter_umap.insert(make_pair(i, vector<TableFilter>{tableFilter}));
24: 					}
25: 					break;
26: 				}
27: 			}
28: 		}
29: 		dependencies.insert(op.table);
30: 		return make_unique<PhysicalTableScan>(op.types, *op.table, *op.table->storage, op.column_ids,
31: 		                                      move(op.expressions), move(table_filter_umap));
32: 	}
33: }
34: 
35: } // namespace duckdb
[end of src/execution/physical_plan/plan_get.cpp]
[start of src/execution/physical_plan/plan_index_scan.cpp]
1: #include "duckdb/execution/operator/scan/physical_index_scan.hpp"
2: #include "duckdb/execution/physical_plan_generator.hpp"
3: 
4: #include "duckdb/planner/operator/logical_index_scan.hpp"
5: 
6: namespace duckdb {
7: using namespace std;
8: 
9: unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalIndexScan &op) {
10: 	unique_ptr<PhysicalOperator> plan;
11: 	auto node = make_unique<PhysicalIndexScan>(op, op.tableref, op.table, op.index, op.column_ids);
12: 	if (op.equal_index) {
13: 		node->equal_value = op.equal_value;
14: 		node->equal_index = true;
15: 	}
16: 	if (op.low_index) {
17: 		node->low_value = op.low_value;
18: 		node->low_index = true;
19: 		node->low_expression_type = op.low_expression_type;
20: 	}
21: 	if (op.high_index) {
22: 		node->high_value = op.high_value;
23: 		node->high_index = true;
24: 		node->high_expression_type = op.high_expression_type;
25: 	}
26: 	plan = move(node);
27: 	return plan;
28: }
29: 
30: } // namespace duckdb
[end of src/execution/physical_plan/plan_index_scan.cpp]
[start of src/execution/physical_plan/plan_table_function.cpp]
1: #include "duckdb/execution/operator/scan/physical_table_function.hpp"
2: #include "duckdb/execution/physical_plan_generator.hpp"
3: #include "duckdb/planner/operator/logical_table_function.hpp"
4: 
5: namespace duckdb {
6: using namespace std;
7: 
8: unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalTableFunction &op) {
9: 	assert(op.children.size() == 0);
10: 
11: 	auto tfd = (TableFunctionData *)op.bind_data.get();
12: 	assert(tfd);
13: 	// pass on bound column ids into the bind data so the function scan can see them
14: 	tfd->column_ids = op.column_ids;
15: 	return make_unique<PhysicalTableFunction>(op.types, op.function, move(op.bind_data), move(op.parameters));
16: }
17: 
18: } // namespace duckdb
[end of src/execution/physical_plan/plan_table_function.cpp]
[start of src/execution/physical_plan_generator.cpp]
1: #include "duckdb/execution/physical_plan_generator.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
4: #include "duckdb/execution/column_binding_resolver.hpp"
5: #include "duckdb/main/client_context.hpp"
6: #include "duckdb/planner/expression/bound_function_expression.hpp"
7: 
8: namespace duckdb {
9: using namespace std;
10: 
11: class DependencyExtractor : public LogicalOperatorVisitor {
12: public:
13: 	DependencyExtractor(unordered_set<CatalogEntry *> &dependencies) : dependencies(dependencies) {
14: 	}
15: 
16: protected:
17: 	unique_ptr<Expression> VisitReplace(BoundFunctionExpression &expr, unique_ptr<Expression> *expr_ptr) override {
18: 		// extract dependencies from the bound function expression
19: 		if (expr.function.dependency) {
20: 			expr.function.dependency(expr, dependencies);
21: 		}
22: 		return nullptr;
23: 	}
24: 
25: private:
26: 	unordered_set<CatalogEntry *> &dependencies;
27: };
28: 
29: unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(unique_ptr<LogicalOperator> op) {
30: 	// first resolve column references
31: 	context.profiler.StartPhase("column_binding");
32: 	ColumnBindingResolver resolver;
33: 	resolver.VisitOperator(*op);
34: 	context.profiler.EndPhase();
35: 
36: 	// now resolve types of all the operators
37: 	context.profiler.StartPhase("resolve_types");
38: 	op->ResolveOperatorTypes();
39: 	context.profiler.EndPhase();
40: 
41: 	// extract dependencies from the logical plan
42: 	DependencyExtractor extractor(dependencies);
43: 	extractor.VisitOperator(*op);
44: 
45: 	// then create the main physical plan
46: 	context.profiler.StartPhase("create_plan");
47: 	auto plan = CreatePlan(*op);
48: 	context.profiler.EndPhase();
49: 	return plan;
50: }
51: 
52: unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalOperator &op) {
53: 	switch (op.type) {
54: 	case LogicalOperatorType::GET:
55: 		return CreatePlan((LogicalGet &)op);
56: 	case LogicalOperatorType::PROJECTION:
57: 		return CreatePlan((LogicalProjection &)op);
58: 	case LogicalOperatorType::EMPTY_RESULT:
59: 		return CreatePlan((LogicalEmptyResult &)op);
60: 	case LogicalOperatorType::FILTER:
61: 		return CreatePlan((LogicalFilter &)op);
62: 	case LogicalOperatorType::AGGREGATE_AND_GROUP_BY:
63: 		return CreatePlan((LogicalAggregate &)op);
64: 	case LogicalOperatorType::WINDOW:
65: 		return CreatePlan((LogicalWindow &)op);
66: 	case LogicalOperatorType::UNNEST:
67: 		return CreatePlan((LogicalUnnest &)op);
68: 	case LogicalOperatorType::LIMIT:
69: 		return CreatePlan((LogicalLimit &)op);
70: 	case LogicalOperatorType::ORDER_BY:
71: 		return CreatePlan((LogicalOrder &)op);
72: 	case LogicalOperatorType::TOP_N:
73: 		return CreatePlan((LogicalTopN &)op);
74: 	case LogicalOperatorType::COPY_FROM_FILE:
75: 		return CreatePlan((LogicalCopyFromFile &)op);
76: 	case LogicalOperatorType::COPY_TO_FILE:
77: 		return CreatePlan((LogicalCopyToFile &)op);
78: 	case LogicalOperatorType::TABLE_FUNCTION:
79: 		return CreatePlan((LogicalTableFunction &)op);
80: 	case LogicalOperatorType::ANY_JOIN:
81: 		return CreatePlan((LogicalAnyJoin &)op);
82: 	case LogicalOperatorType::DELIM_JOIN:
83: 		return CreatePlan((LogicalDelimJoin &)op);
84: 	case LogicalOperatorType::COMPARISON_JOIN:
85: 		return CreatePlan((LogicalComparisonJoin &)op);
86: 	case LogicalOperatorType::CROSS_PRODUCT:
87: 		return CreatePlan((LogicalCrossProduct &)op);
88: 	case LogicalOperatorType::UNION:
89: 	case LogicalOperatorType::EXCEPT:
90: 	case LogicalOperatorType::INTERSECT:
91: 		return CreatePlan((LogicalSetOperation &)op);
92: 	case LogicalOperatorType::INSERT:
93: 		return CreatePlan((LogicalInsert &)op);
94: 	case LogicalOperatorType::DELETE:
95: 		return CreatePlan((LogicalDelete &)op);
96: 	case LogicalOperatorType::CHUNK_GET:
97: 		return CreatePlan((LogicalChunkGet &)op);
98: 	case LogicalOperatorType::DELIM_GET:
99: 		return CreatePlan((LogicalDelimGet &)op);
100: 	case LogicalOperatorType::EXPRESSION_GET:
101: 		return CreatePlan((LogicalExpressionGet &)op);
102: 	case LogicalOperatorType::UPDATE:
103: 		return CreatePlan((LogicalUpdate &)op);
104: 	case LogicalOperatorType::CREATE_TABLE:
105: 		return CreatePlan((LogicalCreateTable &)op);
106: 	case LogicalOperatorType::CREATE_INDEX:
107: 		return CreatePlan((LogicalCreateIndex &)op);
108: 	case LogicalOperatorType::EXPLAIN:
109: 		return CreatePlan((LogicalExplain &)op);
110: 	case LogicalOperatorType::DISTINCT:
111: 		return CreatePlan((LogicalDistinct &)op);
112: 	case LogicalOperatorType::PREPARE:
113: 		return CreatePlan((LogicalPrepare &)op);
114: 	case LogicalOperatorType::EXECUTE:
115: 		return CreatePlan((LogicalExecute &)op);
116: 	case LogicalOperatorType::INDEX_SCAN:
117: 		return CreatePlan((LogicalIndexScan &)op);
118: 	case LogicalOperatorType::CREATE_VIEW:
119: 	case LogicalOperatorType::CREATE_SEQUENCE:
120: 	case LogicalOperatorType::CREATE_SCHEMA:
121: 		return CreatePlan((LogicalCreate &)op);
122: 	case LogicalOperatorType::PRAGMA:
123: 		return CreatePlan((LogicalPragma &)op);
124: 	case LogicalOperatorType::TRANSACTION:
125: 	case LogicalOperatorType::ALTER:
126: 	case LogicalOperatorType::DROP:
127: 	case LogicalOperatorType::VACUUM:
128: 		return CreatePlan((LogicalSimple &)op);
129: 	case LogicalOperatorType::RECURSIVE_CTE:
130: 		return CreatePlan((LogicalRecursiveCTE &)op);
131: 	case LogicalOperatorType::CTE_REF:
132: 		return CreatePlan((LogicalCTERef &)op);
133: 	case LogicalOperatorType::EXPORT:
134: 		return CreatePlan((LogicalExport &)op);
135: 	default:
136: 		throw NotImplementedException("Unimplemented logical operator type!");
137: 	}
138: }
139: 
140: } // namespace duckdb
[end of src/execution/physical_plan_generator.cpp]
[start of src/function/table/CMakeLists.txt]
1: add_subdirectory(version)
2: add_subdirectory(sqlite)
3: add_library_unity(
4:   duckdb_func_table
5:   OBJECT
6:   arrow.cpp
7:   range.cpp
8:   repeat.cpp
9:   copy_csv.cpp
10:   read_csv.cpp
11:   sqlite_functions.cpp)
12: 
13: set(ALL_OBJECT_FILES
14:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_func_table>
15:     PARENT_SCOPE)
[end of src/function/table/CMakeLists.txt]
[start of src/function/table/arrow.cpp]
1: #include "duckdb.hpp"
2: 
3: #include "duckdb/common/arrow.hpp"
4: #include "duckdb/function/table/arrow.hpp"
5: 
6: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
7: #include "duckdb/main/client_context.hpp"
8: #include "duckdb/main/connection.hpp"
9: #include "duckdb/function/table_function.hpp"
10: #include "duckdb/common/types/timestamp.hpp"
11: #include "duckdb/common/types/date.hpp"
12: 
13: #include "utf8proc_wrapper.hpp"
14: 
15: namespace duckdb {
16: 
17: struct ArrowScanFunctionData : public TableFunctionData {
18: 	ArrowArrayStream *stream;
19: 	ArrowSchema schema_root;
20: 	ArrowArray current_chunk_root;
21: 	idx_t chunk_idx = 0;
22: 	idx_t chunk_offset = 0;
23: 
24: 	void ReleaseArray() {
25: 		if (current_chunk_root.release) {
26: 			for (idx_t child_idx = 0; child_idx < (idx_t)current_chunk_root.n_children; child_idx++) {
27: 				auto &child = *current_chunk_root.children[child_idx];
28: 				if (child.release) {
29: 					child.release(&child);
30: 				}
31: 			}
32: 			current_chunk_root.release(&current_chunk_root);
33: 		}
34: 	}
35: 
36: 	void ReleaseSchema() {
37: 		if (schema_root.release) {
38: 			for (idx_t child_idx = 0; child_idx < (idx_t)schema_root.n_children; child_idx++) {
39: 				auto &child = *schema_root.children[child_idx];
40: 				if (child.release) {
41: 					child.release(&child);
42: 				}
43: 			}
44: 			schema_root.release(&schema_root);
45: 		}
46: 	}
47: 
48: 	~ArrowScanFunctionData() {
49: 		ReleaseSchema();
50: 		ReleaseArray();
51: 	}
52: };
53: 
54: static unique_ptr<FunctionData> arrow_scan_bind(ClientContext &context, vector<Value> &inputs,
55:                                                 unordered_map<string, Value> &named_parameters,
56:                                                 vector<LogicalType> &return_types, vector<string> &names) {
57: 
58: 	auto res = make_unique<ArrowScanFunctionData>();
59: 	auto &data = *res;
60: 
61: 	data.stream = (ArrowArrayStream *)inputs[0].GetValue<uintptr_t>();
62: 	if (!data.stream) {
63: 		throw InvalidInputException("arrow_scan: NULL pointer passed");
64: 	}
65: 
66: 	if (data.stream->get_schema(data.stream, &data.schema_root)) {
67: 		throw InvalidInputException("arrow_scan: get_schema failed(): %s",
68: 		                            string(data.stream->get_last_error(data.stream)));
69: 	}
70: 
71: 	if (!data.schema_root.release) {
72: 		throw InvalidInputException("arrow_scan: released schema passed");
73: 	}
74: 
75: 	if (data.schema_root.n_children < 1) {
76: 		throw InvalidInputException("arrow_scan: empty schema passed");
77: 	}
78: 
79: 	for (idx_t col_idx = 0; col_idx < (idx_t)data.schema_root.n_children; col_idx++) {
80: 		auto &schema = *data.schema_root.children[col_idx];
81: 		if (!schema.release) {
82: 			throw InvalidInputException("arrow_scan: released schema passed");
83: 		}
84: 		if (schema.dictionary) {
85: 			throw NotImplementedException("arrow_scan: dictionary vectors not supported yet");
86: 		}
87: 		auto format = string(schema.format);
88: 		if (format == "b") {
89: 			return_types.push_back(LogicalType::BOOLEAN);
90: 		} else if (format == "c") {
91: 			return_types.push_back(LogicalType::TINYINT);
92: 		} else if (format == "s") {
93: 			return_types.push_back(LogicalType::SMALLINT);
94: 		} else if (format == "i") {
95: 			return_types.push_back(LogicalType::INTEGER);
96: 		} else if (format == "l") {
97: 			return_types.push_back(LogicalType::BIGINT);
98: 		} else if (format == "f") {
99: 			return_types.push_back(LogicalType::FLOAT);
100: 		} else if (format == "g") {
101: 			return_types.push_back(LogicalType::DOUBLE);
102: 		} else if (format == "d:38,0") { // decimal128
103: 			return_types.push_back(LogicalType::HUGEINT);
104: 		} else if (format == "u") {
105: 			return_types.push_back(LogicalType::VARCHAR);
106: 		} else if (format == "tsn:") {
107: 			return_types.push_back(LogicalType::TIMESTAMP);
108: 		} else {
109: 			throw NotImplementedException("Unsupported Arrow type %s", format);
110: 		}
111: 		auto name = string(schema.name);
112: 		if (name.empty()) {
113: 			name = string("v") + to_string(col_idx);
114: 		}
115: 		names.push_back(name);
116: 	}
117: 	data.ReleaseSchema();
118: 	return move(res);
119: }
120: 
121: static void arrow_scan_function(ClientContext &context, vector<Value> &input, DataChunk &output,
122:                                 FunctionData *dataptr) {
123: 	auto &data = *((ArrowScanFunctionData *)dataptr);
124: 
125: 	if (!data.stream->release) { // no more chunks
126: 		return;
127: 	}
128: 
129: 	// have we run out of data on the current chunk? move to next one
130: 	if (data.chunk_offset >= (idx_t)data.current_chunk_root.length) {
131: 		data.chunk_offset = 0;
132: 		data.ReleaseArray();
133: 		if (data.stream->get_next(data.stream, &data.current_chunk_root)) {
134: 			throw InvalidInputException("arrow_scan: get_next failed(): %s",
135: 			                            string(data.stream->get_last_error(data.stream)));
136: 		}
137: 	}
138: 
139: 	// have we run out of chunks? we done
140: 	if (!data.current_chunk_root.release) {
141: 		data.stream->release(data.stream);
142: 		return;
143: 	}
144: 
145: 	if ((idx_t)data.current_chunk_root.n_children != output.column_count()) {
146: 		throw InvalidInputException("arrow_scan: array column count mismatch");
147: 	}
148: 
149: 	output.SetCardinality(
150: 	    std::min((int64_t)STANDARD_VECTOR_SIZE, (int64_t)(data.current_chunk_root.length - data.chunk_offset)));
151: 
152: 	for (idx_t col_idx = 0; col_idx < output.column_count(); col_idx++) {
153: 		auto &array = *data.current_chunk_root.children[col_idx];
154: 		if (!array.release) {
155: 			throw InvalidInputException("arrow_scan: released array passed");
156: 		}
157: 		if (array.length != data.current_chunk_root.length) {
158: 			throw InvalidInputException("arrow_scan: array length mismatch");
159: 		}
160: 		if (array.dictionary) {
161: 			throw NotImplementedException("arrow_scan: dictionary vectors not supported yet");
162: 		}
163: 		if (array.null_count != 0 && array.buffers[0]) {
164: 			auto &nullmask = FlatVector::Nullmask(output.data[col_idx]);
165: 
166: 			auto bit_offset = data.chunk_offset + array.offset;
167: 			auto n_bitmask_bytes = (output.size() + 8 - 1) / 8;
168: 
169: 			if (bit_offset % 8 == 0) {
170: 				// just memcpy nullmask
171: 				memcpy(&nullmask, (uint8_t *)array.buffers[0] + bit_offset / 8, n_bitmask_bytes);
172: 			} else {
173: 				// need to re-align nullmask :/
174: 				bitset<STANDARD_VECTOR_SIZE + 8> temp_nullmask;
175: 				memcpy(&temp_nullmask, (uint8_t *)array.buffers[0] + bit_offset / 8, n_bitmask_bytes + 1);
176: 
177: 				temp_nullmask >>= (bit_offset % 8); // why this has to be a right shift is a mystery to me
178: 				memcpy(&nullmask, (data_ptr_t)&temp_nullmask, n_bitmask_bytes);
179: 			}
180: 			nullmask.flip(); // arrow uses inverse nullmask logic
181: 		}
182: 
183: 		switch (output.data[col_idx].type.id()) {
184: 		case LogicalTypeId::BOOLEAN:
185: 		case LogicalTypeId::TINYINT:
186: 		case LogicalTypeId::SMALLINT:
187: 		case LogicalTypeId::INTEGER:
188: 		case LogicalTypeId::FLOAT:
189: 		case LogicalTypeId::DOUBLE:
190: 		case LogicalTypeId::BIGINT:
191: 		case LogicalTypeId::HUGEINT:
192: 			FlatVector::SetData(output.data[col_idx],
193: 			                    (data_ptr_t)array.buffers[1] + GetTypeIdSize(output.data[col_idx].type.InternalType()) *
194: 			                                                       (data.chunk_offset + array.offset));
195: 			break;
196: 
197: 		case LogicalTypeId::VARCHAR: {
198: 			auto offsets = (uint32_t *)array.buffers[1] + array.offset + data.chunk_offset;
199: 			auto cdata = (char *)array.buffers[2];
200: 
201: 			for (idx_t row_idx = 0; row_idx < output.size(); row_idx++) {
202: 				if (FlatVector::Nullmask(output.data[col_idx])[row_idx]) {
203: 					continue;
204: 				}
205: 				auto cptr = cdata + offsets[row_idx];
206: 				auto str_len = offsets[row_idx + 1] - offsets[row_idx];
207: 
208: 				auto utf_type = Utf8Proc::Analyze(cptr, str_len);
209: 				switch (utf_type) {
210: 				case UnicodeType::ASCII:
211: 					FlatVector::GetData<string_t>(output.data[col_idx])[row_idx] =
212: 					    StringVector::AddString(output.data[col_idx], cptr, str_len);
213: 					break;
214: 				case UnicodeType::UNICODE:
215: 					// this regrettably copies to normalize
216: 					FlatVector::GetData<string_t>(output.data[col_idx])[row_idx] =
217: 					    StringVector::AddString(output.data[col_idx], Utf8Proc::Normalize(string(cptr, str_len)));
218: 
219: 					break;
220: 				case UnicodeType::INVALID:
221: 					throw runtime_error("Invalid UTF8 string encoding");
222: 				}
223: 			}
224: 
225: 			break;
226: 		} // TODO timestamps in duckdb are subject to change
227: 		case LogicalTypeId::TIMESTAMP: {
228: 			auto src_ptr = (uint64_t *)array.buffers[1] + data.chunk_offset;
229: 			auto tgt_ptr = (timestamp_t *)FlatVector::GetData(output.data[col_idx]);
230: 
231: 			for (idx_t row = 0; row < output.size(); row++) {
232: 				auto source_idx = data.chunk_offset + row;
233: 
234: 				auto ms = src_ptr[source_idx] / 1000000; // nanoseconds
235: 				auto ms_per_day = (int64_t)60 * 60 * 24 * 1000;
236: 				date_t date = Date::EpochToDate(ms / 1000);
237: 				dtime_t time = (dtime_t)(ms % ms_per_day);
238: 				tgt_ptr[row] = Timestamp::FromDatetime(date, time);
239: 			}
240: 			break;
241: 		}
242: 		default:
243: 			throw runtime_error("Unsupported type " + output.data[col_idx].type.ToString());
244: 		}
245: 	}
246: 	output.Verify();
247: 	data.chunk_offset += output.size();
248: }
249: 
250: void ArrowTableFunction::RegisterFunction(BuiltinFunctions &set) {
251: 	TableFunctionSet arrow("arrow_scan");
252: 
253: 	arrow.AddFunction(TableFunction({LogicalType::POINTER}, arrow_scan_bind, arrow_scan_function));
254: 	set.AddFunction(arrow);
255: }
256: 
257: void BuiltinFunctions::RegisterArrowFunctions() {
258: 	ArrowTableFunction::RegisterFunction(*this);
259: }
260: } // namespace duckdb
[end of src/function/table/arrow.cpp]
[start of src/function/table/range.cpp]
1: #include "duckdb/function/table/range.hpp"
2: #include "duckdb/function/table_function.hpp"
3: #include "duckdb/function/function_set.hpp"
4: #include "duckdb/common/algorithm.hpp"
5: 
6: using namespace std;
7: 
8: namespace duckdb {
9: 
10: struct RangeFunctionData : public TableFunctionData {
11: 	Value start;
12: 	Value end;
13: 	Value increment;
14: 	idx_t current_idx;
15: };
16: 
17: static unique_ptr<FunctionData> range_function_bind(ClientContext &context, vector<Value> &inputs,
18:                                                     unordered_map<string, Value> &named_parameters,
19:                                                     vector<LogicalType> &return_types, vector<string> &names) {
20: 	auto result = make_unique<RangeFunctionData>();
21: 	if (inputs.size() < 2) {
22: 		// single argument: only the end is specified
23: 		result->start = Value::BIGINT(0);
24: 		result->end = inputs[0].CastAs(LogicalType::BIGINT);
25: 	} else {
26: 		// two arguments: first two arguments are start and end
27: 		result->start = inputs[0].CastAs(LogicalType::BIGINT);
28: 		result->end = inputs[1].CastAs(LogicalType::BIGINT);
29: 	}
30: 	if (inputs.size() < 3) {
31: 		result->increment = Value::BIGINT(1);
32: 	} else {
33: 		result->increment = inputs[2].CastAs(LogicalType::BIGINT);
34: 	}
35: 	if (result->increment == 0) {
36: 		throw BinderException("interval cannot be 0!");
37: 	}
38: 	if (result->start > result->end && result->increment > 0) {
39: 		throw BinderException("start is bigger than end, but increment is positive: cannot generate infinite series");
40: 	} else if (result->start < result->end && result->increment < 0) {
41: 		throw BinderException("start is smaller than end, but increment is negative: cannot generate infinite series");
42: 	}
43: 	result->current_idx = 0;
44: 	return_types.push_back(LogicalType::BIGINT);
45: 	names.push_back("range");
46: 	return move(result);
47: }
48: 
49: static void range_function(ClientContext &context, vector<Value> &input, DataChunk &output, FunctionData *dataptr) {
50: 	auto &data = ((RangeFunctionData &)*dataptr);
51: 	auto increment = data.increment.value_.bigint;
52: 	auto end = data.end.value_.bigint;
53: 	int64_t current_value = data.start.value_.bigint + (int64_t)increment * data.current_idx;
54: 	// set the result vector as a sequence vector
55: 	output.data[0].Sequence(current_value, increment);
56: 	idx_t remaining = min<int64_t>((end - current_value) / increment, STANDARD_VECTOR_SIZE);
57: 	// increment the index pointer by the remaining count
58: 	data.current_idx += remaining;
59: 	output.SetCardinality(remaining);
60: }
61: 
62: void RangeTableFunction::RegisterFunction(BuiltinFunctions &set) {
63: 	TableFunctionSet range("range");
64: 
65: 	// single argument range: (end) - implicit start = 0 and increment = 1
66: 	range.AddFunction(TableFunction({LogicalType::BIGINT}, range_function_bind, range_function));
67: 	// two arguments range: (start, end) - implicit increment = 1
68: 	range.AddFunction(TableFunction({LogicalType::BIGINT, LogicalType::BIGINT}, range_function_bind, range_function));
69: 	// three arguments range: (start, end, increment)
70: 	range.AddFunction(TableFunction({LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT},
71: 	                                range_function_bind, range_function));
72: 	set.AddFunction(range);
73: 	range.name = "generate_series";
74: 	set.AddFunction(range);
75: }
76: 
77: void BuiltinFunctions::RegisterTableFunctions() {
78: 	RangeTableFunction::RegisterFunction(*this);
79: 	RepeatTableFunction::RegisterFunction(*this);
80: }
81: 
82: } // namespace duckdb
[end of src/function/table/range.cpp]
[start of src/function/table/read_csv.cpp]
1: #include "duckdb/function/table/read_csv.hpp"
2: #include "duckdb/execution/operator/persistent/buffered_csv_reader.hpp"
3: #include "duckdb/function/function_set.hpp"
4: #include "duckdb/main/client_context.hpp"
5: #include "duckdb/main/database.hpp"
6: 
7: using namespace std;
8: 
9: namespace duckdb {
10: 
11: struct ReadCSVFunctionData : public TableFunctionData {
12: 	ReadCSVFunctionData() {
13: 	}
14: 
15: 	//! The CSV reader
16: 	unique_ptr<BufferedCSVReader> csv_reader;
17: };
18: 
19: static unique_ptr<FunctionData> read_csv_bind(ClientContext &context, vector<Value> &inputs,
20:                                               unordered_map<string, Value> &named_parameters,
21:                                               vector<LogicalType> &return_types, vector<string> &names) {
22: 	auto result = make_unique<ReadCSVFunctionData>();
23: 
24: 	BufferedCSVReaderOptions options;
25: 	options.file_path = inputs[0].str_value;
26: 	options.auto_detect = false;
27: 	options.header = false;
28: 	options.delimiter = ",";
29: 	options.quote = "\"";
30: 
31: 	for (auto &kv : named_parameters) {
32: 		if (kv.first == "auto_detect") {
33: 			options.auto_detect = kv.second.value_.boolean;
34: 		} else if (kv.first == "sep" || kv.first == "delim") {
35: 			options.delimiter = kv.second.str_value;
36: 			options.has_delimiter = true;
37: 		} else if (kv.first == "header") {
38: 			options.header = kv.second.value_.boolean;
39: 			options.has_header = true;
40: 		} else if (kv.first == "quote") {
41: 			options.quote = kv.second.str_value;
42: 			options.has_quote = true;
43: 		} else if (kv.first == "escape") {
44: 			options.escape = kv.second.str_value;
45: 			options.has_escape = true;
46: 		} else if (kv.first == "nullstr") {
47: 			options.null_str = kv.second.str_value;
48: 		} else if (kv.first == "sample_size") {
49: 			options.sample_size = kv.second.GetValue<int64_t>();
50: 			if (options.sample_size > STANDARD_VECTOR_SIZE) {
51: 				throw BinderException(
52: 				    "Unsupported parameter for SAMPLE_SIZE: cannot be bigger than STANDARD_VECTOR_SIZE %d",
53: 				    STANDARD_VECTOR_SIZE);
54: 			} else if (options.sample_size < 1) {
55: 				throw BinderException("Unsupported parameter for SAMPLE_SIZE: cannot be smaller than 1");
56: 			}
57: 		} else if (kv.first == "num_samples") {
58: 			options.num_samples = kv.second.GetValue<int64_t>();
59: 			if (options.num_samples < 1) {
60: 				throw BinderException("Unsupported parameter for NUM_SAMPLES: cannot be smaller than 1");
61: 			}
62: 		} else if (kv.first == "dateformat") {
63: 			options.has_date_format = true;
64: 			options.date_format.format_specifier = kv.second.str_value;
65: 			string error = StrTimeFormat::ParseFormatSpecifier(kv.second.str_value, options.date_format);
66: 			if (!error.empty()) {
67: 				throw InvalidInputException("Could not parse DATEFORMAT: %s", error.c_str());
68: 			}
69: 		} else if (kv.first == "timestampformat") {
70: 			options.has_timestamp_format = true;
71: 			options.timestamp_format.format_specifier = kv.second.str_value;
72: 			string error = StrTimeFormat::ParseFormatSpecifier(kv.second.str_value, options.timestamp_format);
73: 			if (!error.empty()) {
74: 				throw InvalidInputException("Could not parse TIMESTAMPFORMAT: %s", error.c_str());
75: 			}
76: 		} else if (kv.first == "columns") {
77: 			for (auto &val : kv.second.struct_value) {
78: 				names.push_back(val.first);
79: 				if (val.second.type().id() != LogicalTypeId::VARCHAR) {
80: 					throw BinderException("read_csv requires a type specification as string");
81: 				}
82: 				return_types.push_back(TransformStringToLogicalType(val.second.str_value.c_str()));
83: 			}
84: 			if (names.size() == 0) {
85: 				throw BinderException("read_csv requires at least a single column as input!");
86: 			}
87: 		}
88: 	}
89: 	if (!options.auto_detect && return_types.size() == 0) {
90: 		throw BinderException("Specifying CSV options requires columns to be specified as well (for now)");
91: 	}
92: 	if (return_types.size() > 0) {
93: 		// return types specified: no auto detect
94: 		result->csv_reader = make_unique<BufferedCSVReader>(context, move(options), return_types);
95: 	} else {
96: 		// auto detect options
97: 		result->csv_reader = make_unique<BufferedCSVReader>(context, move(options));
98: 
99: 		return_types.assign(result->csv_reader->sql_types.begin(), result->csv_reader->sql_types.end());
100: 		names.assign(result->csv_reader->col_names.begin(), result->csv_reader->col_names.end());
101: 	}
102: 	return move(result);
103: }
104: 
105: static unique_ptr<FunctionData> read_csv_auto_bind(ClientContext &context, vector<Value> &inputs,
106:                                                    unordered_map<string, Value> &named_parameters,
107:                                                    vector<LogicalType> &return_types, vector<string> &names) {
108: 	named_parameters["auto_detect"] = Value::BOOLEAN(true);
109: 	return read_csv_bind(context, inputs, named_parameters, return_types, names);
110: }
111: 
112: static void read_csv_info(ClientContext &context, vector<Value> &input, DataChunk &output, FunctionData *dataptr) {
113: 	auto &data = ((ReadCSVFunctionData &)*dataptr);
114: 	data.csv_reader->ParseCSV(output);
115: }
116: 
117: static void add_named_parameters(TableFunction &table_function) {
118: 	table_function.named_parameters["sep"] = LogicalType::VARCHAR;
119: 	table_function.named_parameters["delim"] = LogicalType::VARCHAR;
120: 	table_function.named_parameters["quote"] = LogicalType::VARCHAR;
121: 	table_function.named_parameters["escape"] = LogicalType::VARCHAR;
122: 	table_function.named_parameters["nullstr"] = LogicalType::VARCHAR;
123: 	table_function.named_parameters["columns"] = LogicalType::STRUCT;
124: 	table_function.named_parameters["header"] = LogicalType::BOOLEAN;
125: 	table_function.named_parameters["auto_detect"] = LogicalType::BOOLEAN;
126: 	table_function.named_parameters["sample_size"] = LogicalType::BIGINT;
127: 	table_function.named_parameters["num_samples"] = LogicalType::BIGINT;
128: 	table_function.named_parameters["dateformat"] = LogicalType::VARCHAR;
129: 	table_function.named_parameters["timestampformat"] = LogicalType::VARCHAR;
130: }
131: 
132: void ReadCSVTableFunction::RegisterFunction(BuiltinFunctions &set) {
133: 	TableFunction read_csv_function =
134: 	    TableFunction("read_csv", {LogicalType::VARCHAR}, read_csv_bind, read_csv_info, nullptr);
135: 	add_named_parameters(read_csv_function);
136: 	set.AddFunction(read_csv_function);
137: 
138: 	TableFunction read_csv_auto_function =
139: 	    TableFunction("read_csv_auto", {LogicalType::VARCHAR}, read_csv_auto_bind, read_csv_info, nullptr);
140: 	add_named_parameters(read_csv_auto_function);
141: 	set.AddFunction(read_csv_auto_function);
142: }
143: 
144: void BuiltinFunctions::RegisterReadFunctions() {
145: 	CSVCopyFunction::RegisterFunction(*this);
146: 	ReadCSVTableFunction::RegisterFunction(*this);
147: }
148: 
149: } // namespace duckdb
[end of src/function/table/read_csv.cpp]
[start of src/function/table/repeat.cpp]
1: #include "duckdb/function/table/range.hpp"
2: #include "duckdb/common/algorithm.hpp"
3: 
4: using namespace std;
5: 
6: namespace duckdb {
7: 
8: struct RepeatFunctionData : public TableFunctionData {
9: 	RepeatFunctionData(idx_t target_count) : current_count(0), target_count(target_count) {
10: 	}
11: 
12: 	idx_t current_count;
13: 	idx_t target_count;
14: };
15: 
16: static unique_ptr<FunctionData> repeat_bind(ClientContext &context, vector<Value> &inputs,
17:                                             unordered_map<string, Value> &named_parameters,
18:                                             vector<LogicalType> &return_types, vector<string> &names) {
19: 	// the repeat function returns the type of the first argument
20: 	return_types.push_back(inputs[0].type());
21: 	names.push_back(inputs[0].ToString());
22: 	return make_unique<RepeatFunctionData>(inputs[1].GetValue<int64_t>());
23: }
24: 
25: static void repeat_function(ClientContext &context, vector<Value> &input, DataChunk &output, FunctionData *dataptr) {
26: 	auto &repeat = (RepeatFunctionData &)*dataptr;
27: 	idx_t remaining = min<idx_t>(repeat.target_count - repeat.current_count, STANDARD_VECTOR_SIZE);
28: 	output.data[0].Reference(input[0]);
29: 	output.SetCardinality(remaining);
30: 	repeat.current_count += remaining;
31: }
32: 
33: void RepeatTableFunction::RegisterFunction(BuiltinFunctions &set) {
34: 	TableFunction repeat("repeat", {LogicalType::ANY, LogicalType::BIGINT}, repeat_bind, repeat_function, nullptr);
35: 	set.AddFunction(repeat);
36: }
37: 
38: } // namespace duckdb
[end of src/function/table/repeat.cpp]
[start of src/function/table/sqlite/pragma_collations.cpp]
1: #include "duckdb/function/table/sqlite_functions.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/catalog/catalog_entry/collate_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
6: #include "duckdb/common/exception.hpp"
7: #include "duckdb/transaction/transaction.hpp"
8: 
9: using namespace std;
10: 
11: namespace duckdb {
12: 
13: struct PragmaCollateData : public TableFunctionData {
14: 	PragmaCollateData() : initialized(false), offset(0) {
15: 	}
16: 
17: 	bool initialized;
18: 	vector<CatalogEntry *> entries;
19: 	idx_t offset;
20: };
21: 
22: static unique_ptr<FunctionData> pragma_collate_bind(ClientContext &context, vector<Value> &inputs,
23:                                                     unordered_map<string, Value> &named_parameters,
24:                                                     vector<LogicalType> &return_types, vector<string> &names) {
25: 	names.push_back("collname");
26: 	return_types.push_back(LogicalType::VARCHAR);
27: 
28: 	return make_unique<PragmaCollateData>();
29: }
30: 
31: static void pragma_collate_info(ClientContext &context, vector<Value> &input, DataChunk &output,
32:                                 FunctionData *dataptr) {
33: 	auto &data = *((PragmaCollateData *)dataptr);
34: 	assert(input.size() == 0);
35: 	if (!data.initialized) {
36: 		// scan all the schemas
37: 		auto &transaction = Transaction::GetTransaction(context);
38: 		Catalog::GetCatalog(context).schemas->Scan(transaction, [&](CatalogEntry *entry) {
39: 			auto schema = (SchemaCatalogEntry *)entry;
40: 			schema->collations.Scan(transaction, [&](CatalogEntry *entry) { data.entries.push_back(entry); });
41: 		});
42: 		data.initialized = true;
43: 	}
44: 
45: 	if (data.offset >= data.entries.size()) {
46: 		// finished returning values
47: 		return;
48: 	}
49: 	idx_t next = min(data.offset + STANDARD_VECTOR_SIZE, (idx_t)data.entries.size());
50: 	output.SetCardinality(next - data.offset);
51: 	for (idx_t i = data.offset; i < next; i++) {
52: 		auto index = i - data.offset;
53: 		auto entry = (CollateCatalogEntry *)data.entries[i];
54: 
55: 		output.SetValue(0, index, Value(entry->name));
56: 	}
57: 
58: 	data.offset = next;
59: }
60: 
61: void PragmaCollations::RegisterFunction(BuiltinFunctions &set) {
62: 	set.AddFunction(TableFunction("pragma_collations", {}, pragma_collate_bind, pragma_collate_info, nullptr));
63: }
64: 
65: } // namespace duckdb
[end of src/function/table/sqlite/pragma_collations.cpp]
[start of src/function/table/sqlite/pragma_database_list.cpp]
1: #include "duckdb/function/table/sqlite_functions.hpp"
2: 
3: #include "duckdb/storage/storage_manager.hpp"
4: 
5: using namespace std;
6: 
7: namespace duckdb {
8: 
9: struct PragmaDatabaseListData : public TableFunctionData {
10: 	PragmaDatabaseListData() : finished(false) {
11: 	}
12: 
13: 	bool finished;
14: };
15: 
16: static unique_ptr<FunctionData> pragma_database_list_bind(ClientContext &context, vector<Value> &inputs,
17:                                                           unordered_map<string, Value> &named_parameters,
18:                                                           vector<LogicalType> &return_types, vector<string> &names) {
19: 	names.push_back("seq");
20: 	return_types.push_back(LogicalType::INTEGER);
21: 
22: 	names.push_back("name");
23: 	return_types.push_back(LogicalType::VARCHAR);
24: 
25: 	names.push_back("file");
26: 	return_types.push_back(LogicalType::VARCHAR);
27: 
28: 	// initialize the function data structure
29: 	return make_unique<PragmaDatabaseListData>();
30: }
31: 
32: void pragma_database_list(ClientContext &context, vector<Value> &input, DataChunk &output, FunctionData *dataptr) {
33: 	auto &data = *((PragmaDatabaseListData *)dataptr);
34: 	if (data.finished) {
35: 		return;
36: 	}
37: 
38: 	output.SetCardinality(1);
39: 	output.data[0].SetValue(0, Value::INTEGER(0));
40: 	output.data[1].SetValue(0, Value("main"));
41: 	output.data[2].SetValue(0, Value(StorageManager::GetStorageManager(context).GetDBPath()));
42: 
43: 	data.finished = true;
44: }
45: 
46: void PragmaDatabaseList::RegisterFunction(BuiltinFunctions &set) {
47: 	set.AddFunction(
48: 	    TableFunction("pragma_database_list", {}, pragma_database_list_bind, pragma_database_list, nullptr));
49: }
50: 
51: } // namespace duckdb
[end of src/function/table/sqlite/pragma_database_list.cpp]
[start of src/function/table/sqlite/pragma_table_info.cpp]
1: #include "duckdb/function/table/sqlite_functions.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
6: #include "duckdb/common/exception.hpp"
7: #include "duckdb/common/limits.hpp"
8: 
9: #include <algorithm>
10: 
11: using namespace std;
12: 
13: namespace duckdb {
14: 
15: struct PragmaTableFunctionData : public TableFunctionData {
16: 	PragmaTableFunctionData() : entry(nullptr), offset(0) {
17: 	}
18: 
19: 	CatalogEntry *entry;
20: 	idx_t offset;
21: };
22: 
23: static unique_ptr<FunctionData> pragma_table_info_bind(ClientContext &context, vector<Value> &inputs,
24:                                                        unordered_map<string, Value> &named_parameters,
25:                                                        vector<LogicalType> &return_types, vector<string> &names) {
26: 	names.push_back("cid");
27: 	return_types.push_back(LogicalType::INTEGER);
28: 
29: 	names.push_back("name");
30: 	return_types.push_back(LogicalType::VARCHAR);
31: 
32: 	names.push_back("type");
33: 	return_types.push_back(LogicalType::VARCHAR);
34: 
35: 	names.push_back("notnull");
36: 	return_types.push_back(LogicalType::BOOLEAN);
37: 
38: 	names.push_back("dflt_value");
39: 	return_types.push_back(LogicalType::VARCHAR);
40: 
41: 	names.push_back("pk");
42: 	return_types.push_back(LogicalType::BOOLEAN);
43: 
44: 	return make_unique<PragmaTableFunctionData>();
45: }
46: 
47: static void pragma_table_info_table(PragmaTableFunctionData &data, TableCatalogEntry *table, DataChunk &output) {
48: 	if (data.offset >= table->columns.size()) {
49: 		// finished returning values
50: 		return;
51: 	}
52: 	// start returning values
53: 	// either fill up the chunk or return all the remaining columns
54: 	idx_t next = min(data.offset + STANDARD_VECTOR_SIZE, (idx_t)table->columns.size());
55: 	output.SetCardinality(next - data.offset);
56: 
57: 	for (idx_t i = data.offset; i < next; i++) {
58: 		auto index = i - data.offset;
59: 		auto &column = table->columns[i];
60: 		// return values:
61: 		// "cid", PhysicalType::INT32
62: 		assert(column.oid < (idx_t)NumericLimits<int32_t>::Maximum());
63: 
64: 		output.SetValue(0, index, Value::INTEGER((int32_t)column.oid));
65: 		// "name", PhysicalType::VARCHAR
66: 		output.SetValue(1, index, Value(column.name));
67: 		// "type", PhysicalType::VARCHAR
68: 		output.SetValue(2, index, Value(column.type.ToString()));
69: 		// "notnull", PhysicalType::BOOL
70: 		// FIXME: look at constraints
71: 		output.SetValue(3, index, Value::BOOLEAN(false));
72: 		// "dflt_value", PhysicalType::VARCHAR
73: 		Value def_value = column.default_value ? Value(column.default_value->ToString()) : Value();
74: 		output.SetValue(4, index, def_value);
75: 		// "pk", PhysicalType::BOOL
76: 		// FIXME: look at constraints
77: 		output.SetValue(5, index, Value::BOOLEAN(false));
78: 	}
79: 	data.offset = next;
80: }
81: 
82: static void pragma_table_info_view(PragmaTableFunctionData &data, ViewCatalogEntry *view, DataChunk &output) {
83: 	if (data.offset >= view->types.size()) {
84: 		// finished returning values
85: 		return;
86: 	}
87: 	// start returning values
88: 	// either fill up the chunk or return all the remaining columns
89: 	idx_t next = min(data.offset + STANDARD_VECTOR_SIZE, (idx_t)view->types.size());
90: 	output.SetCardinality(next - data.offset);
91: 
92: 	for (idx_t i = data.offset; i < next; i++) {
93: 		auto index = i - data.offset;
94: 		auto type = view->types[index];
95: 		auto &name = view->aliases[index];
96: 		// return values:
97: 		// "cid", PhysicalType::INT32
98: 
99: 		output.SetValue(0, index, Value::INTEGER((int32_t)index));
100: 		// "name", PhysicalType::VARCHAR
101: 		output.SetValue(1, index, Value(name));
102: 		// "type", PhysicalType::VARCHAR
103: 		output.SetValue(2, index, Value(type.ToString()));
104: 		// "notnull", PhysicalType::BOOL
105: 		output.SetValue(3, index, Value::BOOLEAN(false));
106: 		// "dflt_value", PhysicalType::VARCHAR
107: 		output.SetValue(4, index, Value());
108: 		// "pk", PhysicalType::BOOL
109: 		output.SetValue(5, index, Value::BOOLEAN(false));
110: 	}
111: 	data.offset = next;
112: }
113: 
114: static void pragma_table_info(ClientContext &context, vector<Value> &input, DataChunk &output, FunctionData *dataptr) {
115: 	auto &data = *((PragmaTableFunctionData *)dataptr);
116: 	if (!data.entry) {
117: 		// first call: load the entry from the catalog
118: 		assert(input.size() == 1);
119: 
120: 		string schema, table_name;
121: 		auto range_var = input[0].GetValue<string>();
122: 		Catalog::ParseRangeVar(range_var, schema, table_name);
123: 
124: 		// look up the table name in the catalog
125: 		auto &catalog = Catalog::GetCatalog(context);
126: 		data.entry = catalog.GetEntry(context, CatalogType::TABLE_ENTRY, schema, table_name);
127: 	}
128: 	switch (data.entry->type) {
129: 	case CatalogType::TABLE_ENTRY:
130: 		pragma_table_info_table(data, (TableCatalogEntry *)data.entry, output);
131: 		break;
132: 	case CatalogType::VIEW_ENTRY:
133: 		pragma_table_info_view(data, (ViewCatalogEntry *)data.entry, output);
134: 		break;
135: 	default:
136: 		throw NotImplementedException("Unimplemented catalog type for pragma_table_info");
137: 	}
138: }
139: 
140: void PragmaTableInfo::RegisterFunction(BuiltinFunctions &set) {
141: 	set.AddFunction(
142: 	    TableFunction("pragma_table_info", {LogicalType::VARCHAR}, pragma_table_info_bind, pragma_table_info, nullptr));
143: }
144: 
145: } // namespace duckdb
[end of src/function/table/sqlite/pragma_table_info.cpp]
[start of src/function/table/sqlite/sqlite_master.cpp]
1: #include "duckdb/function/table/sqlite_functions.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
6: #include "duckdb/common/exception.hpp"
7: #include "duckdb/transaction/transaction.hpp"
8: 
9: #include <algorithm>
10: 
11: using namespace std;
12: 
13: namespace duckdb {
14: 
15: struct SQLiteMasterData : public TableFunctionData {
16: 	SQLiteMasterData() : initialized(false), offset(0) {
17: 	}
18: 
19: 	bool initialized;
20: 	vector<CatalogEntry *> entries;
21: 	idx_t offset;
22: };
23: 
24: static unique_ptr<FunctionData> sqlite_master_bind(ClientContext &context, vector<Value> &inputs,
25:                                                    unordered_map<string, Value> &named_parameters,
26:                                                    vector<LogicalType> &return_types, vector<string> &names) {
27: 	names.push_back("type");
28: 	return_types.push_back(LogicalType::VARCHAR);
29: 
30: 	names.push_back("name");
31: 	return_types.push_back(LogicalType::VARCHAR);
32: 
33: 	names.push_back("tbl_name");
34: 	return_types.push_back(LogicalType::VARCHAR);
35: 
36: 	names.push_back("rootpage");
37: 	return_types.push_back(LogicalType::INTEGER);
38: 
39: 	names.push_back("sql");
40: 	return_types.push_back(LogicalType::VARCHAR);
41: 
42: 	// initialize the function data structure
43: 	return make_unique<SQLiteMasterData>();
44: }
45: 
46: void sqlite_master(ClientContext &context, vector<Value> &input, DataChunk &output, FunctionData *dataptr) {
47: 	auto &data = *((SQLiteMasterData *)dataptr);
48: 	assert(input.size() == 0);
49: 	if (!data.initialized) {
50: 		// scan all the schemas
51: 		auto &transaction = Transaction::GetTransaction(context);
52: 		Catalog::GetCatalog(context).schemas->Scan(transaction, [&](CatalogEntry *entry) {
53: 			auto schema = (SchemaCatalogEntry *)entry;
54: 			schema->tables.Scan(transaction, [&](CatalogEntry *entry) { data.entries.push_back(entry); });
55: 		});
56: 		data.initialized = true;
57: 	}
58: 
59: 	if (data.offset >= data.entries.size()) {
60: 		// finished returning values
61: 		return;
62: 	}
63: 	idx_t next = min(data.offset + STANDARD_VECTOR_SIZE, (idx_t)data.entries.size());
64: 	output.SetCardinality(next - data.offset);
65: 
66: 	// start returning values
67: 	// either fill up the chunk or return all the remaining columns
68: 	for (idx_t i = data.offset; i < next; i++) {
69: 		auto index = i - data.offset;
70: 		auto &entry = data.entries[i];
71: 
72: 		// return values:
73: 		// "type", PhysicalType::VARCHAR
74: 		const char *type_str;
75: 		switch (entry->type) {
76: 		case CatalogType::TABLE_ENTRY:
77: 			type_str = "table";
78: 			break;
79: 		case CatalogType::SCHEMA_ENTRY:
80: 			type_str = "schema";
81: 			break;
82: 		case CatalogType::TABLE_FUNCTION_ENTRY:
83: 			type_str = "function";
84: 			break;
85: 		case CatalogType::VIEW_ENTRY:
86: 			type_str = "view";
87: 			break;
88: 		default:
89: 			type_str = "unknown";
90: 		}
91: 		output.SetValue(0, index, Value(type_str));
92: 		// "name", PhysicalType::VARCHAR
93: 		output.SetValue(1, index, Value(entry->name));
94: 		// "tbl_name", PhysicalType::VARCHAR
95: 		output.SetValue(2, index, Value(entry->name));
96: 		// "rootpage", PhysicalType::INT32
97: 		output.SetValue(3, index, Value::INTEGER(0));
98: 		// "sql", PhysicalType::VARCHAR
99: 		output.SetValue(4, index, Value(entry->ToSQL()));
100: 	}
101: 	data.offset = next;
102: }
103: 
104: void SQLiteMaster::RegisterFunction(BuiltinFunctions &set) {
105: 	set.AddFunction(TableFunction("sqlite_master", {}, sqlite_master_bind, sqlite_master, nullptr));
106: }
107: 
108: } // namespace duckdb
[end of src/function/table/sqlite/sqlite_master.cpp]
[start of src/function/table/sqlite_functions.cpp]
1: #include "duckdb/function/table/sqlite_functions.hpp"
2: #include "duckdb/parser/parsed_data/create_view_info.hpp"
3: #include "duckdb/parser/query_node/select_node.hpp"
4: #include "duckdb/parser/expression/star_expression.hpp"
5: #include "duckdb/parser/tableref/table_function_ref.hpp"
6: #include "duckdb/parser/expression/function_expression.hpp"
7: #include "duckdb/catalog/catalog.hpp"
8: 
9: using namespace std;
10: 
11: namespace duckdb {
12: 
13: void BuiltinFunctions::RegisterSQLiteFunctions() {
14: 	PragmaVersion::RegisterFunction(*this);
15: 	PragmaCollations::RegisterFunction(*this);
16: 	PragmaTableInfo::RegisterFunction(*this);
17: 	SQLiteMaster::RegisterFunction(*this);
18: 	PragmaDatabaseList::RegisterFunction(*this);
19: 
20: 	CreateViewInfo info;
21: 	info.schema = DEFAULT_SCHEMA;
22: 	info.view_name = "sqlite_master";
23: 	info.on_conflict = OnCreateConflict::REPLACE;
24: 
25: 	auto select = make_unique<SelectNode>();
26: 	select->select_list.push_back(make_unique<StarExpression>());
27: 	vector<unique_ptr<ParsedExpression>> children;
28: 
29: 	auto function = make_unique<FunctionExpression>(DEFAULT_SCHEMA, "sqlite_master", children);
30: 	auto function_expr = make_unique<TableFunctionRef>();
31: 	function_expr->function = move(function);
32: 	select->from_table = move(function_expr);
33: 	info.query = move(select);
34: 	//	catalog.CreateView(transaction, &info);
35: }
36: 
37: } // namespace duckdb
[end of src/function/table/sqlite_functions.cpp]
[start of src/function/table/version/pragma_version.cpp]
1: #include "duckdb/function/table/sqlite_functions.hpp"
2: #include "duckdb/main/database.hpp"
3: 
4: namespace duckdb {
5: 
6: struct PragmaVersionData : public TableFunctionData {
7: 	PragmaVersionData() : done(false) {
8: 	}
9: 	bool done;
10: };
11: 
12: static unique_ptr<FunctionData> pragma_version_bind(ClientContext &context, vector<Value> &inputs,
13:                                                     unordered_map<string, Value> &named_parameters,
14:                                                     vector<LogicalType> &return_types, vector<string> &names) {
15: 	names.push_back("library_version");
16: 	return_types.push_back(LogicalType::VARCHAR);
17: 	names.push_back("source_id");
18: 	return_types.push_back(LogicalType::VARCHAR);
19: 
20: 	return make_unique<PragmaVersionData>();
21: }
22: 
23: static void pragma_version_info(ClientContext &context, vector<Value> &input, DataChunk &output,
24:                                 FunctionData *dataptr) {
25: 	auto &data = *((PragmaVersionData *)dataptr);
26: 	assert(input.size() == 0);
27: 	if (data.done) {
28: 		// finished returning values
29: 		return;
30: 	}
31: 	output.SetCardinality(1);
32: 	output.SetValue(0, 0, DuckDB::LibraryVersion());
33: 	output.SetValue(1, 0, DuckDB::SourceID());
34: 	data.done = true;
35: }
36: 
37: void PragmaVersion::RegisterFunction(BuiltinFunctions &set) {
38: 	set.AddFunction(TableFunction("pragma_version", {}, pragma_version_bind, pragma_version_info, nullptr));
39: }
40: 
41: const char *DuckDB::SourceID() {
42: 	return DUCKDB_SOURCE_ID;
43: }
44: 
45: const char *DuckDB::LibraryVersion() {
46: 	return "DuckDB";
47: }
48: 
49: } // namespace duckdb
[end of src/function/table/version/pragma_version.cpp]
[start of src/include/duckdb/common/enums/logical_operator_type.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/enums/logical_operator_type.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/constants.hpp"
12: 
13: namespace duckdb {
14: 
15: //===--------------------------------------------------------------------===//
16: // Logical Operator Types
17: //===--------------------------------------------------------------------===//
18: enum class LogicalOperatorType : uint8_t {
19: 	INVALID = 0,
20: 	PROJECTION = 1,
21: 	FILTER = 2,
22: 	AGGREGATE_AND_GROUP_BY = 3,
23: 	WINDOW = 4,
24: 	UNNEST = 5,
25: 	LIMIT = 6,
26: 	ORDER_BY = 7,
27: 	TOP_N = 8,
28: 	COPY_FROM_FILE = 9,
29: 	COPY_TO_FILE = 10,
30: 	DISTINCT = 11,
31: 	INDEX_SCAN = 12,
32: 	// -----------------------------
33: 	// Data sources
34: 	// -----------------------------
35: 	GET = 25,
36: 	CHUNK_GET = 26,
37: 	DELIM_GET = 27,
38: 	EXPRESSION_GET = 28,
39: 	TABLE_FUNCTION = 29,
40: 	EMPTY_RESULT = 30,
41: 	CTE_REF = 31,
42: 	// -----------------------------
43: 	// Joins
44: 	// -----------------------------
45: 	JOIN = 50,
46: 	DELIM_JOIN = 51,
47: 	COMPARISON_JOIN = 52,
48: 	ANY_JOIN = 53,
49: 	CROSS_PRODUCT = 54,
50: 	// -----------------------------
51: 	// SetOps
52: 	// -----------------------------
53: 	UNION = 75,
54: 	EXCEPT = 76,
55: 	INTERSECT = 77,
56: 	RECURSIVE_CTE = 78,
57: 
58: 	// -----------------------------
59: 	// Updates
60: 	// -----------------------------
61: 	INSERT = 100,
62: 	DELETE = 101,
63: 	UPDATE = 102,
64: 
65: 	// -----------------------------
66: 	// Schema
67: 	// -----------------------------
68: 	ALTER = 125,
69: 	CREATE_TABLE = 126,
70: 	CREATE_INDEX = 127,
71: 	CREATE_SEQUENCE = 128,
72: 	CREATE_VIEW = 129,
73: 	CREATE_SCHEMA = 130,
74: 	DROP = 131,
75: 	PRAGMA = 132,
76: 	TRANSACTION = 133,
77: 
78: 	// -----------------------------
79: 	// Explain
80: 	// -----------------------------
81: 	EXPLAIN = 150,
82: 
83: 	// -----------------------------
84: 	// Helpers
85: 	// -----------------------------
86: 	PREPARE = 175,
87: 	EXECUTE = 176,
88: 	EXPORT = 177,
89: 	VACUUM = 178
90: };
91: 
92: string LogicalOperatorToString(LogicalOperatorType type);
93: 
94: } // namespace duckdb
[end of src/include/duckdb/common/enums/logical_operator_type.hpp]
[start of src/include/duckdb/common/enums/physical_operator_type.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/enums/physical_operator_type.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/constants.hpp"
12: 
13: namespace duckdb {
14: 
15: //===--------------------------------------------------------------------===//
16: // Physical Operator Types
17: //===--------------------------------------------------------------------===//
18: enum class PhysicalOperatorType : uint8_t {
19: 	INVALID,
20: 	LEAF,
21: 	ORDER_BY,
22: 	LIMIT,
23: 	TOP_N,
24: 	AGGREGATE,
25: 	WINDOW,
26: 	UNNEST,
27: 	DISTINCT,
28: 	SIMPLE_AGGREGATE,
29: 	HASH_GROUP_BY,
30: 	SORT_GROUP_BY,
31: 	FILTER,
32: 	PROJECTION,
33: 	COPY_FROM_FILE,
34: 	COPY_TO_FILE,
35: 	TABLE_FUNCTION,
36: 	// -----------------------------
37: 	// Scans
38: 	// -----------------------------
39: 	DUMMY_SCAN,
40: 	SEQ_SCAN,
41: 	INDEX_SCAN,
42: 	CHUNK_SCAN,
43: 	RECURSIVE_CTE_SCAN,
44: 	DELIM_SCAN,
45: 	EXTERNAL_FILE_SCAN,
46: 	QUERY_DERIVED_SCAN,
47: 	EXPRESSION_SCAN,
48: 	// -----------------------------
49: 	// Joins
50: 	// -----------------------------
51: 	BLOCKWISE_NL_JOIN,
52: 	NESTED_LOOP_JOIN,
53: 	HASH_JOIN,
54: 	CROSS_PRODUCT,
55: 	PIECEWISE_MERGE_JOIN,
56: 	DELIM_JOIN,
57: 
58: 	// -----------------------------
59: 	// SetOps
60: 	// -----------------------------
61: 	UNION,
62: 	RECURSIVE_CTE,
63: 
64: 	// -----------------------------
65: 	// Updates
66: 	// -----------------------------
67: 	INSERT,
68: 	INSERT_SELECT,
69: 	DELETE,
70: 	UPDATE,
71: 	EXPORT_EXTERNAL_FILE,
72: 
73: 	// -----------------------------
74: 	// Schema
75: 	// -----------------------------
76: 	CREATE,
77: 	CREATE_INDEX,
78: 	ALTER,
79: 	CREATE_SEQUENCE,
80: 	CREATE_VIEW,
81: 	CREATE_SCHEMA,
82: 	DROP,
83: 	PRAGMA,
84: 	TRANSACTION,
85: 
86: 	// -----------------------------
87: 	// Helpers
88: 	// -----------------------------
89: 	EXPLAIN,
90: 	EMPTY_RESULT,
91: 	EXECUTE,
92: 	PREPARE,
93: 	VACUUM,
94: 	EXPORT
95: };
96: 
97: string PhysicalOperatorToString(PhysicalOperatorType type);
98: 
99: } // namespace duckdb
[end of src/include/duckdb/common/enums/physical_operator_type.hpp]
[start of src/include/duckdb/execution/index/art/art.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/index/art/art.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types/data_chunk.hpp"
13: #include "duckdb/common/types/vector.hpp"
14: #include "duckdb/parser/parsed_expression.hpp"
15: #include "duckdb/storage/data_table.hpp"
16: #include "duckdb/storage/index.hpp"
17: 
18: #include "duckdb/execution/index/art/art_key.hpp"
19: #include "duckdb/execution/index/art/leaf.hpp"
20: #include "duckdb/execution/index/art/node.hpp"
21: #include "duckdb/execution/index/art/node4.hpp"
22: #include "duckdb/execution/index/art/node16.hpp"
23: #include "duckdb/execution/index/art/node48.hpp"
24: #include "duckdb/execution/index/art/node256.hpp"
25: 
26: namespace duckdb {
27: struct IteratorEntry {
28: 	Node *node = nullptr;
29: 	idx_t pos = 0;
30: };
31: 
32: struct Iterator {
33: 	//! The current Leaf Node, valid if depth>0
34: 	Leaf *node = nullptr;
35: 	//! The current depth
36: 	int32_t depth = 0;
37: 	//! Stack, actually the size is determined at runtime
38: 	IteratorEntry stack[9];
39: 
40: 	bool start = false;
41: };
42: 
43: struct ARTIndexScanState : public IndexScanState {
44: 	ARTIndexScanState(vector<column_t> column_ids) : IndexScanState(column_ids), checked(false), result_index(0) {
45: 	}
46: 
47: 	Value values[2];
48: 	ExpressionType expressions[2];
49: 	bool checked;
50: 	idx_t result_index = 0;
51: 	vector<row_t> result_ids;
52: 	Iterator iterator;
53: };
54: 
55: class ART : public Index {
56: public:
57: 	ART(vector<column_t> column_ids, vector<unique_ptr<Expression>> unbound_expressions, bool is_unique = false);
58: 	~ART();
59: 
60: 	//! Root of the tree
61: 	unique_ptr<Node> tree;
62: 	//! True if machine is little endian
63: 	bool is_little_endian;
64: 	//! Whether or not the ART is an index built to enforce a UNIQUE constraint
65: 	bool is_unique;
66: 
67: public:
68: 	//! Initialize a scan on the index with the given expression and column ids
69: 	//! to fetch from the base table for a single predicate
70: 	unique_ptr<IndexScanState> InitializeScanSinglePredicate(Transaction &transaction, vector<column_t> column_ids,
71: 	                                                         Value value, ExpressionType expressionType) override;
72: 
73: 	//! Initialize a scan on the index with the given expression and column ids
74: 	//! to fetch from the base table for two predicates
75: 	unique_ptr<IndexScanState> InitializeScanTwoPredicates(Transaction &transaction, vector<column_t> column_ids,
76: 	                                                       Value low_value, ExpressionType low_expression_type,
77: 	                                                       Value high_value,
78: 	                                                       ExpressionType high_expression_type) override;
79: 
80: 	//! Perform a lookup on the index
81: 	void Scan(Transaction &transaction, DataTable &table, TableIndexScanState &state, DataChunk &result) override;
82: 	//! Append entries to the index
83: 	bool Append(IndexLock &lock, DataChunk &entries, Vector &row_identifiers) override;
84: 	//! Verify that data can be appended to the index
85: 	void VerifyAppend(DataChunk &chunk) override;
86: 	//! Delete entries in the index
87: 	void Delete(IndexLock &lock, DataChunk &entries, Vector &row_identifiers) override;
88: 
89: 	//! Insert data into the index.
90: 	bool Insert(IndexLock &lock, DataChunk &data, Vector &row_ids) override;
91: 
92: private:
93: 	DataChunk expression_result;
94: 
95: private:
96: 	//! Insert a row id into a leaf node
97: 	bool InsertToLeaf(Leaf &leaf, row_t row_id);
98: 	//! Insert the leaf value into the tree
99: 	bool Insert(unique_ptr<Node> &node, unique_ptr<Key> key, unsigned depth, row_t row_id);
100: 
101: 	//! Erase element from leaf (if leaf has more than one value) or eliminate the leaf itself
102: 	void Erase(unique_ptr<Node> &node, Key &key, unsigned depth, row_t row_id);
103: 
104: 	//! Check if the key of the leaf is equal to the searched key
105: 	bool LeafMatches(Node *node, Key &key, unsigned depth);
106: 
107: 	//! Find the node with a matching key, optimistic version
108: 	Node *Lookup(unique_ptr<Node> &node, Key &key, unsigned depth);
109: 
110: 	//! Find the first node that is bigger (or equal to) a specific key
111: 	bool Bound(unique_ptr<Node> &node, Key &key, Iterator &iterator, bool inclusive);
112: 
113: 	//! Gets next node for range queries
114: 	bool IteratorNext(Iterator &iter);
115: 
116: 	void SearchEqual(vector<row_t> &result_ids, ARTIndexScanState *state);
117: 	void SearchGreater(vector<row_t> &result_ids, ARTIndexScanState *state, bool inclusive);
118: 	void SearchLess(vector<row_t> &result_ids, ARTIndexScanState *state, bool inclusive);
119: 	void SearchCloseRange(vector<row_t> &result_ids, ARTIndexScanState *state, bool left_inclusive,
120: 	                      bool right_inclusive);
121: 
122: private:
123: 	template <bool HAS_BOUND, bool INCLUSIVE>
124: 	void IteratorScan(ARTIndexScanState *state, Iterator *it, vector<row_t> &result_ids, Key *upper_bound);
125: 
126: 	void GenerateKeys(DataChunk &input, vector<unique_ptr<Key>> &keys);
127: };
128: 
129: } // namespace duckdb
[end of src/include/duckdb/execution/index/art/art.hpp]
[start of src/include/duckdb/execution/operator/list.hpp]
1: #include "duckdb/execution/operator/aggregate/physical_hash_aggregate.hpp"
2: #include "duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp"
3: #include "duckdb/execution/operator/aggregate/physical_window.hpp"
4: #include "duckdb/execution/operator/filter/physical_filter.hpp"
5: #include "duckdb/execution/operator/helper/physical_execute.hpp"
6: #include "duckdb/execution/operator/helper/physical_limit.hpp"
7: #include "duckdb/execution/operator/helper/physical_pragma.hpp"
8: #include "duckdb/execution/operator/helper/physical_prepare.hpp"
9: #include "duckdb/execution/operator/helper/physical_transaction.hpp"
10: #include "duckdb/execution/operator/helper/physical_vacuum.hpp"
11: #include "duckdb/execution/operator/join/physical_blockwise_nl_join.hpp"
12: #include "duckdb/execution/operator/join/physical_comparison_join.hpp"
13: #include "duckdb/execution/operator/join/physical_cross_product.hpp"
14: #include "duckdb/execution/operator/join/physical_delim_join.hpp"
15: #include "duckdb/execution/operator/join/physical_hash_join.hpp"
16: #include "duckdb/execution/operator/join/physical_join.hpp"
17: #include "duckdb/execution/operator/join/physical_nested_loop_join.hpp"
18: #include "duckdb/execution/operator/join/physical_piecewise_merge_join.hpp"
19: #include "duckdb/execution/operator/order/physical_order.hpp"
20: #include "duckdb/execution/operator/order/physical_top_n.hpp"
21: #include "duckdb/execution/operator/persistent/buffered_csv_reader.hpp"
22: #include "duckdb/execution/operator/persistent/physical_copy_from_file.hpp"
23: #include "duckdb/execution/operator/persistent/physical_copy_to_file.hpp"
24: #include "duckdb/execution/operator/persistent/physical_delete.hpp"
25: #include "duckdb/execution/operator/persistent/physical_insert.hpp"
26: #include "duckdb/execution/operator/persistent/physical_update.hpp"
27: #include "duckdb/execution/operator/projection/physical_projection.hpp"
28: #include "duckdb/execution/operator/projection/physical_unnest.hpp"
29: #include "duckdb/execution/operator/scan/physical_chunk_scan.hpp"
30: #include "duckdb/execution/operator/scan/physical_dummy_scan.hpp"
31: #include "duckdb/execution/operator/scan/physical_empty_result.hpp"
32: #include "duckdb/execution/operator/scan/physical_expression_scan.hpp"
33: #include "duckdb/execution/operator/scan/physical_index_scan.hpp"
34: #include "duckdb/execution/operator/scan/physical_table_function.hpp"
35: #include "duckdb/execution/operator/scan/physical_table_scan.hpp"
36: #include "duckdb/execution/operator/schema/physical_alter.hpp"
37: #include "duckdb/execution/operator/schema/physical_create_index.hpp"
38: #include "duckdb/execution/operator/schema/physical_create_schema.hpp"
39: #include "duckdb/execution/operator/schema/physical_create_sequence.hpp"
40: #include "duckdb/execution/operator/schema/physical_create_table.hpp"
41: #include "duckdb/execution/operator/schema/physical_create_view.hpp"
42: #include "duckdb/execution/operator/schema/physical_drop.hpp"
43: #include "duckdb/execution/operator/set/physical_recursive_cte.hpp"
44: #include "duckdb/execution/operator/set/physical_union.hpp"
[end of src/include/duckdb/execution/operator/list.hpp]
[start of src/include/duckdb/execution/operator/scan/physical_index_scan.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/operator/scan/physical_index_scan.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/execution/physical_operator.hpp"
12: #include "duckdb/storage/data_table.hpp"
13: #include "duckdb/storage/index.hpp"
14: 
15: namespace duckdb {
16: 
17: //! Represents a scan of an index
18: class PhysicalIndexScan : public PhysicalOperator {
19: public:
20: 	PhysicalIndexScan(LogicalOperator &op, TableCatalogEntry &tableref, DataTable &table, Index &index,
21: 	                  vector<column_t> column_ids)
22: 	    : PhysicalOperator(PhysicalOperatorType::INDEX_SCAN, op.types), tableref(tableref), table(table), index(index),
23: 	      column_ids(column_ids) {
24: 	}
25: 
26: 	//! The table to scan
27: 	TableCatalogEntry &tableref;
28: 	//! The physical data table to scan
29: 	DataTable &table;
30: 	//! The index to use for the scan
31: 	Index &index;
32: 	//! The column ids to project
33: 	vector<column_t> column_ids;
34: 
35: 	//! The value for the query predicate
36: 	Value low_value;
37: 	Value high_value;
38: 	Value equal_value;
39: 
40: 	//! If the predicate is low, high or equal
41: 	bool low_index = false;
42: 	bool high_index = false;
43: 	bool equal_index = false;
44: 
45: 	//! The expression type (e.g., >, <, >=, <=)
46: 	ExpressionType low_expression_type;
47: 	ExpressionType high_expression_type;
48: 
49: public:
50: 	void GetChunkInternal(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state) override;
51: 	string ExtraRenderInformation() const override;
52: 	unique_ptr<PhysicalOperatorState> GetOperatorState() override;
53: };
54: 
55: } // namespace duckdb
[end of src/include/duckdb/execution/operator/scan/physical_index_scan.hpp]
[start of src/include/duckdb/execution/operator/scan/physical_table_function.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/operator/scan/physical_table_function.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/execution/physical_operator.hpp"
12: #include "duckdb/function/table_function.hpp"
13: #include "duckdb/storage/data_table.hpp"
14: 
15: namespace duckdb {
16: 
17: //! Represents a scan of a base table
18: class PhysicalTableFunction : public PhysicalOperator {
19: public:
20: 	PhysicalTableFunction(vector<LogicalType> types, TableFunction function, unique_ptr<FunctionData> bind_data,
21: 	                      vector<Value> parameters)
22: 	    : PhysicalOperator(PhysicalOperatorType::TABLE_FUNCTION, move(types)), function(move(function)),
23: 	      bind_data(move(bind_data)), parameters(move(parameters)) {
24: 	}
25: 
26: 	//! Function to call
27: 	TableFunction function;
28: 	//! The bind data
29: 	unique_ptr<FunctionData> bind_data;
30: 	//! Parameters
31: 	vector<Value> parameters;
32: 
33: public:
34: 	void GetChunkInternal(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state) override;
35: 	string ExtraRenderInformation() const override;
36: };
37: 
38: } // namespace duckdb
[end of src/include/duckdb/execution/operator/scan/physical_table_function.hpp]
[start of src/include/duckdb/execution/operator/scan/physical_table_scan.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/operator/scan/physical_table_scan.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/execution/physical_operator.hpp"
12: #include "duckdb/storage/data_table.hpp"
13: 
14: namespace duckdb {
15: 
16: //! Represents a scan of a base table
17: class PhysicalTableScan : public PhysicalOperator {
18: public:
19: 	PhysicalTableScan(vector<LogicalType> types, TableCatalogEntry &tableref, DataTable &table,
20: 	                  vector<column_t> column_ids, vector<unique_ptr<Expression>> filter,
21: 	                  unordered_map<idx_t, vector<TableFilter>> table_filters);
22: 
23: 	//! The table to scan
24: 	TableCatalogEntry &tableref;
25: 	//! The physical data table to scan
26: 	DataTable &table;
27: 	//! The column ids to project
28: 	vector<column_t> column_ids;
29: 
30: 	//! The filter expression
31: 	unique_ptr<Expression> expression;
32: 	//! Filters pushed down to table scan
33: 	unordered_map<idx_t, vector<TableFilter>> table_filters;
34: 
35: public:
36: 	void GetChunkInternal(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state) override;
37: 	string ExtraRenderInformation() const override;
38: 	unique_ptr<PhysicalOperatorState> GetOperatorState() override;
39: 
40: 	void ParallelScanInfo(ClientContext &context, std::function<void(unique_ptr<OperatorTaskInfo>)> callback) override;
41: };
42: 
43: } // namespace duckdb
[end of src/include/duckdb/execution/operator/scan/physical_table_scan.hpp]
[start of src/include/duckdb/execution/physical_operator.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/physical_operator.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/catalog.hpp"
12: #include "duckdb/common/common.hpp"
13: #include "duckdb/common/enums/physical_operator_type.hpp"
14: #include "duckdb/common/types/data_chunk.hpp"
15: #include "duckdb/planner/expression.hpp"
16: #include "duckdb/execution/execution_context.hpp"
17: 
18: #include <functional>
19: 
20: namespace duckdb {
21: class ExpressionExecutor;
22: class PhysicalOperator;
23: class OperatorTaskInfo;
24: 
25: //! The current state/context of the operator. The PhysicalOperatorState is
26: //! updated using the GetChunk function, and allows the caller to repeatedly
27: //! call the GetChunk function and get new batches of data everytime until the
28: //! data source is exhausted.
29: class PhysicalOperatorState {
30: public:
31: 	PhysicalOperatorState(PhysicalOperator *child);
32: 	virtual ~PhysicalOperatorState() = default;
33: 
34: 	//! Flag indicating whether or not the operator is finished [note: not all
35: 	//! operators use this flag]
36: 	bool finished;
37: 	//! DataChunk that stores data from the child of this operator
38: 	DataChunk child_chunk;
39: 	//! State of the child of this operator
40: 	unique_ptr<PhysicalOperatorState> child_state;
41: };
42: 
43: //! PhysicalOperator is the base class of the physical operators present in the
44: //! execution plan
45: /*!
46:     The execution model is a pull-based execution model. GetChunk is called on
47:    the root node, which causes the root node to be executed, and presumably call
48:    GetChunk again on its child nodes. Every node in the operator chain has a
49:    state that is updated as GetChunk is called: PhysicalOperatorState (different
50:    operators subclass this state and add different properties).
51: */
52: class PhysicalOperator {
53: public:
54: 	PhysicalOperator(PhysicalOperatorType type, vector<LogicalType> types) : type(type), types(types) {
55: 	}
56: 	virtual ~PhysicalOperator() {
57: 	}
58: 
59: 	//! The physical operator type
60: 	PhysicalOperatorType type;
61: 	//! The set of children of the operator
62: 	vector<unique_ptr<PhysicalOperator>> children;
63: 	//! The types returned by this physical operator
64: 	vector<LogicalType> types;
65: 
66: public:
67: 	string ToString(idx_t depth = 0) const;
68: 	void Print();
69: 
70: 	//! Return a vector of the types that will be returned by this operator
71: 	vector<LogicalType> &GetTypes() {
72: 		return types;
73: 	}
74: 	//! Initialize a given chunk to the types that will be returned by this
75: 	//! operator, this will prepare chunk for a call to GetChunk. This method
76: 	//! only has to be called once for any amount of calls to GetChunk.
77: 	virtual void InitializeChunk(DataChunk &chunk) {
78: 		auto &types = GetTypes();
79: 		chunk.Initialize(types);
80: 	}
81: 	//! Retrieves a chunk from this operator and stores it in the chunk
82: 	//! variable.
83: 	virtual void GetChunkInternal(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state) = 0;
84: 
85: 	void GetChunk(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state);
86: 
87: 	//! Create a new empty instance of the operator state
88: 	virtual unique_ptr<PhysicalOperatorState> GetOperatorState() {
89: 		return make_unique<PhysicalOperatorState>(children.size() == 0 ? nullptr : children[0].get());
90: 	}
91: 
92: 	virtual string ExtraRenderInformation() const {
93: 		return "";
94: 	}
95: 
96: 	virtual bool IsSink() const {
97: 		return false;
98: 	}
99: 
100: 	//! Provides an interface for parallel scans of this operator. For every OperatorTaskInfo returned, one task is
101: 	//! created. The OperatorTaskInfo can be accessed as part of the TaskContext during execution.
102: 	virtual void ParallelScanInfo(ClientContext &context, std::function<void(unique_ptr<OperatorTaskInfo>)> callback);
103: };
104: 
105: } // namespace duckdb
[end of src/include/duckdb/execution/physical_operator.hpp]
[start of src/include/duckdb/execution/physical_plan_generator.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/physical_plan_generator.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/execution/physical_operator.hpp"
13: #include "duckdb/planner/logical_operator.hpp"
14: #include "duckdb/planner/logical_tokens.hpp"
15: #include "duckdb/common/types/chunk_collection.hpp"
16: #include "duckdb/common/unordered_map.hpp"
17: #include "duckdb/common/unordered_set.hpp"
18: 
19: namespace duckdb {
20: class ClientContext;
21: 
22: //! The physical plan generator generates a physical execution plan from a
23: //! logical query plan
24: class PhysicalPlanGenerator {
25: public:
26: 	PhysicalPlanGenerator(ClientContext &context) : context(context) {
27: 	}
28: 
29: 	unordered_set<CatalogEntry *> dependencies;
30: 	//! Recursive CTEs require at least one ChunkScan, referencing the working_table.
31: 	//! This data structure is used to establish it.
32: 	unordered_map<idx_t, std::shared_ptr<ChunkCollection>> rec_ctes;
33: 
34: public:
35: 	//! Creates a plan from the logical operator. This involves resolving column bindings and generating physical
36: 	//! operator nodes.
37: 	unique_ptr<PhysicalOperator> CreatePlan(unique_ptr<LogicalOperator> logical);
38: 
39: protected:
40: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalOperator &op);
41: 
42: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalAggregate &op);
43: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalAnyJoin &op);
44: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalChunkGet &op);
45: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalComparisonJoin &op);
46: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalCreate &op);
47: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalCreateTable &op);
48: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalCreateIndex &op);
49: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalCrossProduct &op);
50: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalDelete &op);
51: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalDelimGet &op);
52: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalDelimJoin &op);
53: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalDistinct &op);
54: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalEmptyResult &op);
55: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalExpressionGet &op);
56: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalExport &op);
57: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalFilter &op);
58: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalGet &op);
59: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalLimit &op);
60: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalIndexScan &op);
61: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalOrder &op);
62: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalTopN &op);
63: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalProjection &op);
64: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalInsert &op);
65: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalCopyFromFile &op);
66: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalCopyToFile &op);
67: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalExplain &op);
68: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalSetOperation &op);
69: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalUpdate &op);
70: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalTableFunction &expr);
71: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalPrepare &expr);
72: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalWindow &expr);
73: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalExecute &op);
74: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalPragma &op);
75: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalSimple &op);
76: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalUnnest &op);
77: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalRecursiveCTE &op);
78: 	unique_ptr<PhysicalOperator> CreatePlan(LogicalCTERef &op);
79: 
80: 	unique_ptr<PhysicalOperator> CreateDistinct(unique_ptr<PhysicalOperator> child);
81: 	unique_ptr<PhysicalOperator> CreateDistinctOn(unique_ptr<PhysicalOperator> child,
82: 	                                              vector<unique_ptr<Expression>> distinct_targets);
83: 
84: private:
85: 	ClientContext &context;
86: };
87: } // namespace duckdb
[end of src/include/duckdb/execution/physical_plan_generator.hpp]
[start of src/include/duckdb/function/table_function.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/table_function.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/function.hpp"
12: #include "duckdb/common/unordered_map.hpp"
13: 
14: namespace duckdb {
15: 
16: //! Function used for determining the return type of a table producing function
17: typedef unique_ptr<FunctionData> (*table_function_bind_t)(ClientContext &context, vector<Value> &inputs,
18:                                                           unordered_map<string, Value> &named_parameters,
19:                                                           vector<LogicalType> &return_types, vector<string> &names);
20: //! Type used for table-returning function
21: typedef void (*table_function_t)(ClientContext &context, vector<Value> &input, DataChunk &output,
22:                                  FunctionData *dataptr);
23: //! Type used for final (cleanup) function
24: typedef void (*table_function_final_t)(ClientContext &context, FunctionData *dataptr);
25: 
26: class TableFunction : public SimpleFunction {
27: public:
28: 	TableFunction(string name, vector<LogicalType> arguments, table_function_bind_t bind, table_function_t function,
29: 	              table_function_final_t final = nullptr, bool supports_projection = false)
30: 	    : SimpleFunction(name, move(arguments)), bind(bind), function(function), final(final),
31: 	      supports_projection(supports_projection) {
32: 	}
33: 	TableFunction(vector<LogicalType> arguments, table_function_bind_t bind, table_function_t function,
34: 	              table_function_final_t final = nullptr, bool supports_projection = false)
35: 	    : TableFunction(string(), move(arguments), bind, function, final, supports_projection) {
36: 	}
37: 
38: 	//! The bind function
39: 	table_function_bind_t bind;
40: 	//! The function pointer
41: 	table_function_t function;
42: 	//! Final function pointer
43: 	table_function_final_t final;
44: 	//! Supported named parameters by the function
45: 	unordered_map<string, LogicalType> named_parameters;
46: 	//! Whether or not the table function supports projection
47: 	bool supports_projection;
48: 
49: 	string ToString();
50: };
51: 
52: } // namespace duckdb
[end of src/include/duckdb/function/table_function.hpp]
[start of src/include/duckdb/optimizer/filter_combiner.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/optimizer/filter_combiner.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/types/value.hpp"
12: #include "duckdb/common/unordered_map.hpp"
13: #include "duckdb/parser/expression_map.hpp"
14: #include "duckdb/planner/expression.hpp"
15: 
16: #include "duckdb/storage/data_table.hpp"
17: #include <functional>
18: 
19: namespace duckdb {
20: 
21: enum class ValueComparisonResult { PRUNE_LEFT, PRUNE_RIGHT, UNSATISFIABLE_CONDITION, PRUNE_NOTHING };
22: enum class FilterResult { UNSATISFIABLE, SUCCESS, UNSUPPORTED };
23: 
24: //! The FilterCombiner combines several filters and generates a logically equivalent set that is more efficient
25: //! Amongst others:
26: //! (1) it prunes obsolete filter conditions: i.e. [X > 5 and X > 7] => [X > 7]
27: //! (2) it generates new filters for expressions in the same equivalence set: i.e. [X = Y and X = 500] => [Y = 500]
28: //! (3) it prunes branches that have unsatisfiable filters: i.e. [X = 5 AND X > 6] => FALSE, prune branch
29: class FilterCombiner {
30: public:
31: 	struct ExpressionValueInformation {
32: 		Value constant;
33: 		ExpressionType comparison_type;
34: 	};
35: 
36: 	FilterResult AddFilter(unique_ptr<Expression> expr);
37: 
38: 	void GenerateFilters(std::function<void(unique_ptr<Expression> filter)> callback);
39: 	bool HasFilters();
40: 	vector<TableFilter> GenerateTableScanFilters(std::function<void(unique_ptr<Expression> filter)> callback,
41: 	                                             vector<idx_t> &column_ids);
42: 
43: private:
44: 	FilterResult AddFilter(Expression *expr);
45: 
46: 	Expression *GetNode(Expression *expr);
47: 	idx_t GetEquivalenceSet(Expression *expr);
48: 	FilterResult AddConstantComparison(vector<ExpressionValueInformation> &info_list, ExpressionValueInformation info);
49: 
50: 	vector<unique_ptr<Expression>> remaining_filters;
51: 
52: 	expression_map_t<unique_ptr<Expression>> stored_expressions;
53: 	unordered_map<Expression *, idx_t> equivalence_set_map;
54: 	unordered_map<idx_t, vector<ExpressionValueInformation>> constant_values;
55: 	unordered_map<idx_t, vector<Expression *>> equivalence_map;
56: 	idx_t set_index = 0;
57: };
58: 
59: } // namespace duckdb
[end of src/include/duckdb/optimizer/filter_combiner.hpp]
[start of src/include/duckdb/optimizer/index_scan.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/optimizer/index_scan.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/optimizer/filter_combiner.hpp"
12: #include "duckdb/optimizer/rule.hpp"
13: 
14: namespace duckdb {
15: class Optimizer;
16: 
17: class IndexScan {
18: public:
19: 	//! Optimize Filters in Index Scans
20: 	unique_ptr<LogicalOperator> Optimize(unique_ptr<LogicalOperator> node);
21: 
22: private:
23: 	//! Transform a Filter in an index scan
24: 	unique_ptr<LogicalOperator> TransformFilterToIndexScan(unique_ptr<LogicalOperator> op);
25: };
26: 
27: } // namespace duckdb
[end of src/include/duckdb/optimizer/index_scan.hpp]
[start of src/include/duckdb/planner/bind_context.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/bind_context.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/catalog.hpp"
12: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
13: #include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
14: #include "duckdb/common/unordered_map.hpp"
15: #include "duckdb/common/unordered_set.hpp"
16: #include "duckdb/parser/expression/columnref_expression.hpp"
17: #include "duckdb/parser/parsed_expression.hpp"
18: #include "duckdb/planner/expression.hpp"
19: #include "duckdb/planner/expression_binder.hpp"
20: #include "duckdb/planner/table_binding.hpp"
21: 
22: namespace duckdb {
23: class LogicalGet;
24: class BoundQueryNode;
25: 
26: //! The BindContext object keeps track of all the tables and columns that are
27: //! encountered during the binding process.
28: class BindContext {
29: public:
30: 	//! Given a column name, find the matching table it belongs to. Throws an
31: 	//! exception if no table has a column of the given name.
32: 	string GetMatchingBinding(const string &column_name);
33: 	//! Like GetMatchingBinding, but instead of throwing an error if multiple tables have the same binding it will
34: 	//! return a list of all the matching ones
35: 	unordered_set<string> GetMatchingBindings(const string &column_name);
36: 
37: 	Binding *GetCTEBinding(const string &ctename);
38: 	//! Binds a column expression to the base table. Returns the bound expression
39: 	//! or throws an exception if the column could not be bound.
40: 	BindResult BindColumn(ColumnRefExpression &colref, idx_t depth);
41: 
42: 	//! Generate column expressions for all columns that are present in the
43: 	//! referenced tables. This is used to resolve the * expression in a
44: 	//! selection list.
45: 	void GenerateAllColumnExpressions(vector<unique_ptr<ParsedExpression>> &new_select_list, string relation_name = "");
46: 
47: 	//! Adds a base table with the given alias to the BindContext.
48: 	void AddBaseTable(idx_t index, const string &alias, TableCatalogEntry &table, LogicalGet &get);
49: 	//! Adds a subquery with a given alias to the BindContext.
50: 	void AddSubquery(idx_t index, const string &alias, SubqueryRef &ref, BoundQueryNode &subquery);
51: 	//! Adds a base table with the given alias to the BindContext.
52: 	void AddGenericBinding(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types);
53: 
54: 	//! Adds a base table with the given alias to the CTE BindContext.
55: 	//! We need this to correctly bind recursive CTEs with multiple references.
56: 	void AddCTEBinding(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types);
57: 
58: 	bool BindingIsHidden(const string &binding_name, const string &column_name);
59: 	unordered_set<string> hidden_columns;
60: 
61: 	//! Keep track of recursive CTE references
62: 	unordered_map<string, std::shared_ptr<idx_t>> cte_references;
63: 
64: 	unordered_map<string, std::shared_ptr<Binding>> GetCTEBindings() {
65: 		return cte_bindings;
66: 	}
67: 	void SetCTEBindings(unordered_map<string, std::shared_ptr<Binding>> bindings) {
68: 		cte_bindings = bindings;
69: 	}
70: 
71: private:
72: 	void AddBinding(const string &alias, unique_ptr<Binding> binding);
73: 
74: 	//! The set of bindings
75: 	unordered_map<string, unique_ptr<Binding>> bindings;
76: 	//! The list of bindings in insertion order
77: 	vector<std::pair<string, Binding *>> bindings_list;
78: 
79: 	//! The set of CTE bindings
80: 	unordered_map<string, std::shared_ptr<Binding>> cte_bindings;
81: };
82: } // namespace duckdb
[end of src/include/duckdb/planner/bind_context.hpp]
[start of src/include/duckdb/planner/logical_tokens.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/logical_tokens.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: namespace duckdb {
12: 
13: class LogicalOperator;
14: 
15: class LogicalAggregate;
16: class LogicalAnyJoin;
17: class LogicalChunkGet;
18: class LogicalComparisonJoin;
19: class LogicalCopyFromFile;
20: class LogicalCopyToFile;
21: class LogicalCreate;
22: class LogicalCreateTable;
23: class LogicalCreateIndex;
24: class LogicalCreateTable;
25: class LogicalCrossProduct;
26: class LogicalCTERef;
27: class LogicalDelete;
28: class LogicalDelimGet;
29: class LogicalDelimJoin;
30: class LogicalDistinct;
31: class LogicalEmptyResult;
32: class LogicalExecute;
33: class LogicalExplain;
34: class LogicalExport;
35: class LogicalExpressionGet;
36: class LogicalFilter;
37: class LogicalGet;
38: class LogicalIndexScan;
39: class LogicalInsert;
40: class LogicalJoin;
41: class LogicalLimit;
42: class LogicalOrder;
43: class LogicalPragma;
44: class LogicalPrepare;
45: class LogicalProjection;
46: class LogicalRecursiveCTE;
47: class LogicalSetOperation;
48: class LogicalSimple;
49: class LogicalTableFunction;
50: class LogicalTopN;
51: class LogicalUnnest;
52: class LogicalUpdate;
53: class LogicalWindow;
54: 
55: } // namespace duckdb
[end of src/include/duckdb/planner/logical_tokens.hpp]
[start of src/include/duckdb/planner/operator/list.hpp]
1: #include "duckdb/planner/operator/logical_aggregate.hpp"
2: #include "duckdb/planner/operator/logical_any_join.hpp"
3: #include "duckdb/planner/operator/logical_chunk_get.hpp"
4: #include "duckdb/planner/operator/logical_comparison_join.hpp"
5: #include "duckdb/planner/operator/logical_copy_from_file.hpp"
6: #include "duckdb/planner/operator/logical_copy_to_file.hpp"
7: #include "duckdb/planner/operator/logical_create.hpp"
8: #include "duckdb/planner/operator/logical_create_index.hpp"
9: #include "duckdb/planner/operator/logical_create_table.hpp"
10: #include "duckdb/planner/operator/logical_cross_product.hpp"
11: #include "duckdb/planner/operator/logical_cteref.hpp"
12: #include "duckdb/planner/operator/logical_delete.hpp"
13: #include "duckdb/planner/operator/logical_delim_get.hpp"
14: #include "duckdb/planner/operator/logical_delim_join.hpp"
15: #include "duckdb/planner/operator/logical_distinct.hpp"
16: #include "duckdb/planner/operator/logical_empty_result.hpp"
17: #include "duckdb/planner/operator/logical_execute.hpp"
18: #include "duckdb/planner/operator/logical_explain.hpp"
19: #include "duckdb/planner/operator/logical_export.hpp"
20: #include "duckdb/planner/operator/logical_expression_get.hpp"
21: #include "duckdb/planner/operator/logical_filter.hpp"
22: #include "duckdb/planner/operator/logical_get.hpp"
23: #include "duckdb/planner/operator/logical_index_scan.hpp"
24: #include "duckdb/planner/operator/logical_insert.hpp"
25: #include "duckdb/planner/operator/logical_join.hpp"
26: #include "duckdb/planner/operator/logical_limit.hpp"
27: #include "duckdb/planner/operator/logical_order.hpp"
28: #include "duckdb/planner/operator/logical_pragma.hpp"
29: #include "duckdb/planner/operator/logical_prepare.hpp"
30: #include "duckdb/planner/operator/logical_projection.hpp"
31: #include "duckdb/planner/operator/logical_recursive_cte.hpp"
32: #include "duckdb/planner/operator/logical_set_operation.hpp"
33: #include "duckdb/planner/operator/logical_simple.hpp"
34: #include "duckdb/planner/operator/logical_table_function.hpp"
35: #include "duckdb/planner/operator/logical_top_n.hpp"
36: #include "duckdb/planner/operator/logical_unnest.hpp"
37: #include "duckdb/planner/operator/logical_update.hpp"
38: #include "duckdb/planner/operator/logical_window.hpp"
[end of src/include/duckdb/planner/operator/list.hpp]
[start of src/include/duckdb/planner/operator/logical_get.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/operator/logical_get.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
12: #include "duckdb/planner/logical_operator.hpp"
13: 
14: #include "duckdb/storage/data_table.hpp"
15: 
16: namespace duckdb {
17: 
18: //! LogicalGet represents a scan operation from a data source
19: class LogicalGet : public LogicalOperator {
20: public:
21: 	LogicalGet(idx_t table_index);
22: 	LogicalGet(TableCatalogEntry *table, idx_t table_index);
23: 	LogicalGet(TableCatalogEntry *table, idx_t table_index, vector<column_t> column_ids);
24: 
25: 	idx_t EstimateCardinality() override;
26: 
27: 	//! The base table to retrieve data from
28: 	TableCatalogEntry *table;
29: 	//! The table index in the current bind context
30: 	idx_t table_index;
31: 	//! Bound column IDs
32: 	vector<column_t> column_ids;
33: 	//! Filters pushed down for table scan
34: 	vector<TableFilter> tableFilters;
35: 	string ParamsToString() const override;
36: 
37: public:
38: 	vector<ColumnBinding> GetColumnBindings() override;
39: 
40: protected:
41: 	void ResolveTypes() override;
42: };
43: } // namespace duckdb
[end of src/include/duckdb/planner/operator/logical_get.hpp]
[start of src/include/duckdb/planner/operator/logical_index_scan.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/operator/logical_index_scan.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/planner/logical_operator.hpp"
12: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
13: #include "duckdb/storage/index.hpp"
14: 
15: namespace duckdb {
16: 
17: //! LogicalIndex represents an Index Scan operation
18: class LogicalIndexScan : public LogicalOperator {
19: public:
20: 	LogicalIndexScan(TableCatalogEntry &tableref, DataTable &table, Index &index, vector<column_t> column_ids,
21: 	                 idx_t table_index)
22: 	    : LogicalOperator(LogicalOperatorType::INDEX_SCAN), tableref(tableref), table(table), index(index),
23: 	      column_ids(column_ids), table_index(table_index) {
24: 	}
25: 
26: 	//! The table to scan
27: 	TableCatalogEntry &tableref;
28: 	//! The physical data table to scan
29: 	DataTable &table;
30: 	//! The index to use for the scan
31: 	Index &index;
32: 	//! The column ids to project
33: 	vector<column_t> column_ids;
34: 
35: 	//! The value for the query predicate
36: 	Value low_value;
37: 	Value high_value;
38: 	Value equal_value;
39: 
40: 	//! If the predicate is low, high or equal
41: 	bool low_index = false;
42: 	bool high_index = false;
43: 	bool equal_index = false;
44: 
45: 	//! The expression type (e.g., >, <, >=, <=)
46: 	ExpressionType low_expression_type;
47: 	ExpressionType high_expression_type;
48: 
49: 	//! The table index in the current bind context
50: 	idx_t table_index;
51: 
52: public:
53: 	vector<ColumnBinding> GetColumnBindings() override {
54: 		return GenerateColumnBindings(table_index, column_ids.size());
55: 	}
56: 
57: protected:
58: 	void ResolveTypes() override {
59: 		if (column_ids.size() == 0) {
60: 			types = {LogicalType::INTEGER};
61: 		} else {
62: 			types = tableref.GetTypes(column_ids);
63: 		}
64: 	}
65: };
66: 
67: } // namespace duckdb
[end of src/include/duckdb/planner/operator/logical_index_scan.hpp]
[start of src/include/duckdb/planner/operator/logical_table_function.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/operator/logical_table_function.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/planner/logical_operator.hpp"
12: #include "duckdb/function/table_function.hpp"
13: #include "duckdb/common/types/value.hpp"
14: 
15: namespace duckdb {
16: 
17: //! LogicalTableFunction represents a call to a table-producing function
18: class LogicalTableFunction : public LogicalOperator {
19: public:
20: 	LogicalTableFunction(TableFunction function, idx_t table_index, unique_ptr<FunctionData> bind_data,
21: 	                     vector<Value> parameters, vector<LogicalType> return_types, vector<string> names)
22: 	    : LogicalOperator(LogicalOperatorType::TABLE_FUNCTION), function(move(function)), table_index(table_index),
23: 	      bind_data(move(bind_data)), parameters(move(parameters)), return_types(move(return_types)),
24: 	      names(move(names)) {
25: 	}
26: 
27: 	//! The function
28: 	TableFunction function;
29: 	//! The table index of the table-producing function
30: 	idx_t table_index;
31: 	//! The bind data of the function
32: 	unique_ptr<FunctionData> bind_data;
33: 	//! The input parameters
34: 	vector<Value> parameters;
35: 	//! The set of returned sql types
36: 	vector<LogicalType> return_types;
37: 	//! The set of returned column names
38: 	vector<string> names;
39: 	//! Bound column IDs
40: 	vector<column_t> column_ids;
41: 
42: public:
43: 	vector<ColumnBinding> GetColumnBindings() override;
44: 	string ParamsToString() const override;
45: 
46: protected:
47: 	void ResolveTypes() override;
48: };
49: } // namespace duckdb
[end of src/include/duckdb/planner/operator/logical_table_function.hpp]
[start of src/include/duckdb/planner/table_binding.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/table_binding.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/unordered_map.hpp"
13: #include "duckdb/parser/column_definition.hpp"
14: #include "duckdb/parser/parsed_expression.hpp"
15: #include "duckdb/planner/expression_binder.hpp"
16: 
17: namespace duckdb {
18: class BindContext;
19: class BoundQueryNode;
20: class ColumnRefExpression;
21: class SubqueryRef;
22: class LogicalGet;
23: class TableCatalogEntry;
24: class TableFunctionCatalogEntry;
25: class BoundTableFunction;
26: 
27: enum class BindingType : uint8_t { TABLE = 0, SUBQUERY = 1, TABLE_FUNCTION = 2, GENERIC = 3 };
28: 
29: //! A Binding represents a binding to a table, table-producing function or subquery with a specified table index. Used
30: //! in the binder.
31: struct Binding {
32: 	Binding(BindingType type, const string &alias, idx_t index) : type(type), alias(alias), index(index) {
33: 	}
34: 	virtual ~Binding() = default;
35: 
36: 	BindingType type;
37: 	string alias;
38: 	idx_t index;
39: 
40: public:
41: 	virtual bool HasMatchingBinding(const string &column_name) = 0;
42: 	virtual BindResult Bind(ColumnRefExpression &colref, idx_t depth) = 0;
43: 	virtual void GenerateAllColumnExpressions(BindContext &context,
44: 	                                          vector<unique_ptr<ParsedExpression>> &select_list) = 0;
45: };
46: 
47: //! Represents a binding to a base table
48: struct TableBinding : public Binding {
49: 	TableBinding(const string &alias, TableCatalogEntry &table, LogicalGet &get, idx_t index);
50: 
51: 	TableCatalogEntry &table;
52: 	LogicalGet &get;
53: 
54: public:
55: 	bool HasMatchingBinding(const string &column_name) override;
56: 	BindResult Bind(ColumnRefExpression &colref, idx_t depth) override;
57: 	void GenerateAllColumnExpressions(BindContext &context, vector<unique_ptr<ParsedExpression>> &select_list) override;
58: };
59: 
60: //! Represents a generic binding with types and names
61: struct GenericBinding : public Binding {
62: 	GenericBinding(const string &alias, vector<LogicalType> types, vector<string> names, idx_t index);
63: 
64: 	vector<LogicalType> types;
65: 	//! Column names of the subquery
66: 	vector<string> names;
67: 	//! Name -> index for the names
68: 	unordered_map<string, column_t> name_map;
69: 
70: public:
71: 	bool HasMatchingBinding(const string &column_name) override;
72: 	BindResult Bind(ColumnRefExpression &colref, idx_t depth) override;
73: 	void GenerateAllColumnExpressions(BindContext &context, vector<unique_ptr<ParsedExpression>> &select_list) override;
74: };
75: 
76: } // namespace duckdb
[end of src/include/duckdb/planner/table_binding.hpp]
[start of src/include/duckdb/planner/tableref/bound_basetableref.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/tableref/bound_basetableref.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/planner/bound_tableref.hpp"
12: #include "duckdb/planner/logical_operator.hpp"
13: 
14: namespace duckdb {
15: class TableCatalogEntry;
16: 
17: //! Represents a TableReference to a base table in the schema
18: class BoundBaseTableRef : public BoundTableRef {
19: public:
20: 	BoundBaseTableRef(unique_ptr<LogicalOperator> get) : BoundTableRef(TableReferenceType::BASE_TABLE), get(move(get)) {
21: 	}
22: 
23: 	unique_ptr<LogicalOperator> get;
24: };
25: } // namespace duckdb
[end of src/include/duckdb/planner/tableref/bound_basetableref.hpp]
[start of src/include/duckdb/planner/tableref/bound_table_function.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/tableref/bound_table_function.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/types/value.hpp"
12: #include "duckdb/planner/expression.hpp"
13: #include "duckdb/planner/bound_tableref.hpp"
14: #include "duckdb/function/table_function.hpp"
15: 
16: namespace duckdb {
17: 
18: //! Represents a reference to a table-producing function call
19: class BoundTableFunction : public BoundTableRef {
20: public:
21: 	BoundTableFunction(TableFunction function, idx_t bind_index)
22: 	    : BoundTableRef(TableReferenceType::TABLE_FUNCTION), function(function), bind_index(bind_index) {
23: 	}
24: 
25: 	//! The function that is called
26: 	TableFunction function;
27: 	//! The bind data of the function
28: 	unique_ptr<FunctionData> bind_data;
29: 	//! The set of parameters to use as input to the table-producing function
30: 	vector<Value> parameters;
31: 	//! The set of returned sql types
32: 	vector<LogicalType> return_types;
33: 	//! The set of returned column names
34: 	vector<string> names;
35: 	//! The index in the bind context
36: 	idx_t bind_index;
37: };
38: } // namespace duckdb
[end of src/include/duckdb/planner/tableref/bound_table_function.hpp]
[start of src/include/duckdb/storage/data_table.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/storage/data_table.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/enums/index_type.hpp"
12: #include "duckdb/common/types/data_chunk.hpp"
13: #include "duckdb/storage/index.hpp"
14: #include "duckdb/storage/table_statistics.hpp"
15: #include "duckdb/storage/block.hpp"
16: #include "duckdb/storage/column_data.hpp"
17: #include "duckdb/storage/table/column_segment.hpp"
18: #include "duckdb/storage/table/persistent_segment.hpp"
19: #include "duckdb/storage/table/version_manager.hpp"
20: #include "duckdb/transaction/local_storage.hpp"
21: 
22: #include <atomic>
23: #include <mutex>
24: 
25: namespace duckdb {
26: class ClientContext;
27: class ColumnDefinition;
28: class DataTable;
29: class StorageManager;
30: class TableCatalogEntry;
31: class Transaction;
32: 
33: typedef unique_ptr<vector<unique_ptr<PersistentSegment>>[]> persistent_data_t;
34: 
35: //! TableFilter represents a filter pushed down into the table scan.
36: class TableFilter {
37: public:
38: 	TableFilter(Value constant, ExpressionType comparison_type, idx_t column_index)
39: 	    : constant(constant), comparison_type(comparison_type), column_index(column_index){};
40: 	Value constant;
41: 	ExpressionType comparison_type;
42: 	idx_t column_index;
43: };
44: 
45: struct DataTableInfo {
46: 	DataTableInfo(string schema, string table) : cardinality(0), schema(move(schema)), table(move(table)) {
47: 	}
48: 
49: 	//! The amount of elements in the table. Note that this number signifies the amount of COMMITTED entries in the
50: 	//! table. It can be inaccurate inside of transactions. More work is needed to properly support that.
51: 	std::atomic<idx_t> cardinality;
52: 	// schema of the table
53: 	string schema;
54: 	// name of the table
55: 	string table;
56: 	//! Indexes associated with the current table
57: 	vector<unique_ptr<Index>> indexes;
58: 
59: 	bool IsTemporary() {
60: 		return schema == TEMP_SCHEMA;
61: 	}
62: };
63: 
64: //! DataTable represents a physical table on disk
65: class DataTable {
66: public:
67: 	//! Constructs a new data table from an (optional) set of persistent segments
68: 	DataTable(StorageManager &storage, string schema, string table, vector<LogicalType> types, persistent_data_t data);
69: 	//! Constructs a DataTable as a delta on an existing data table with a newly added column
70: 	DataTable(ClientContext &context, DataTable &parent, ColumnDefinition &new_column, Expression *default_value);
71: 	//! Constructs a DataTable as a delta on an existing data table but with one column removed
72: 	DataTable(ClientContext &context, DataTable &parent, idx_t removed_column);
73: 	//! Constructs a DataTable as a delta on an existing data table but with one column changed type
74: 	DataTable(ClientContext &context, DataTable &parent, idx_t changed_idx, LogicalType target_type,
75: 	          vector<column_t> bound_columns, Expression &cast_expr);
76: 
77: 	shared_ptr<DataTableInfo> info;
78: 	//! Types managed by data table
79: 	vector<LogicalType> types;
80: 	//! A reference to the base storage manager
81: 	StorageManager &storage;
82: 
83: public:
84: 	void InitializeScan(TableScanState &state, const vector<column_t> &column_ids,
85: 	                    unordered_map<idx_t, vector<TableFilter>> *table_filter = nullptr);
86: 	void InitializeScan(Transaction &transaction, TableScanState &state, const vector<column_t> &column_ids,
87: 	                    unordered_map<idx_t, vector<TableFilter>> *table_filters = nullptr);
88: 
89: 	void InitializeParallelScan(ClientContext &context, const vector<column_t> &column_ids,
90: 	                            unordered_map<idx_t, vector<TableFilter>> *table_filters,
91: 	                            std::function<void(TableScanState)> callback);
92: 
93: 	//! Scans up to STANDARD_VECTOR_SIZE elements from the table starting
94: 	//! from offset and store them in result. Offset is incremented with how many
95: 	//! elements were returned.
96: 	//! Returns true if all pushed down filters were executed during data fetching
97: 	void Scan(Transaction &transaction, DataChunk &result, TableScanState &state, vector<column_t> &column_ids,
98: 	          unordered_map<idx_t, vector<TableFilter>> &table_filters);
99: 
100: 	//! Initialize an index scan with a single predicate and a comparison type (= <= < > >=)
101: 	void InitializeIndexScan(Transaction &transaction, TableIndexScanState &state, Index &index, Value value,
102: 	                         ExpressionType expr_type, vector<column_t> column_ids);
103: 	//! Initialize an index scan with two predicates and two comparison types (> >= < <=)
104: 	void InitializeIndexScan(Transaction &transaction, TableIndexScanState &state, Index &index, Value low_value,
105: 	                         ExpressionType low_type, Value high_value, ExpressionType high_type,
106: 	                         vector<column_t> column_ids);
107: 	//! Scans up to STANDARD_VECTOR_SIZE elements from the table from the given index structure
108: 	void IndexScan(Transaction &transaction, DataChunk &result, TableIndexScanState &state);
109: 
110: 	//! Fetch data from the specific row identifiers from the base table
111: 	void Fetch(Transaction &transaction, DataChunk &result, vector<column_t> &column_ids, Vector &row_ids,
112: 	           idx_t fetch_count, TableIndexScanState &state);
113: 
114: 	//! Append a DataChunk to the table. Throws an exception if the columns don't match the tables' columns.
115: 	void Append(TableCatalogEntry &table, ClientContext &context, DataChunk &chunk);
116: 	//! Delete the entries with the specified row identifier from the table
117: 	void Delete(TableCatalogEntry &table, ClientContext &context, Vector &row_ids, idx_t count);
118: 	//! Update the entries with the specified row identifier from the table
119: 	void Update(TableCatalogEntry &table, ClientContext &context, Vector &row_ids, vector<column_t> &column_ids,
120: 	            DataChunk &data);
121: 
122: 	//! Add an index to the DataTable
123: 	void AddIndex(unique_ptr<Index> index, vector<unique_ptr<Expression>> &expressions);
124: 
125: 	//! Begin appending structs to this table, obtaining necessary locks, etc
126: 	void InitializeAppend(TableAppendState &state);
127: 	//! Append a chunk to the table using the AppendState obtained from BeginAppend
128: 	void Append(Transaction &transaction, transaction_t commit_id, DataChunk &chunk, TableAppendState &state);
129: 	//! Revert a set of appends made by the given AppendState, used to revert appends in the event of an error during
130: 	//! commit (e.g. because of an I/O exception)
131: 	void RevertAppend(TableAppendState &state);
132: 
133: 	//! Append a chunk with the row ids [row_start, ..., row_start + chunk.size()] to all indexes of the table, returns
134: 	//! whether or not the append succeeded
135: 	bool AppendToIndexes(TableAppendState &state, DataChunk &chunk, row_t row_start);
136: 	//! Remove a chunk with the row ids [row_start, ..., row_start + chunk.size()] from all indexes of the table
137: 	void RemoveFromIndexes(TableAppendState &state, DataChunk &chunk, row_t row_start);
138: 	//! Remove the chunk with the specified set of row identifiers from all indexes of the table
139: 	void RemoveFromIndexes(TableAppendState &state, DataChunk &chunk, Vector &row_identifiers);
140: 	//! Remove the row identifiers from all the indexes of the table
141: 	void RemoveFromIndexes(Vector &row_identifiers, idx_t count);
142: 
143: 	void SetAsRoot() {
144: 		this->is_root = true;
145: 	}
146: 
147: private:
148: 	//! Verify constraints with a chunk from the Append containing all columns of the table
149: 	void VerifyAppendConstraints(TableCatalogEntry &table, DataChunk &chunk);
150: 	//! Verify constraints with a chunk from the Update containing only the specified column_ids
151: 	void VerifyUpdateConstraints(TableCatalogEntry &table, DataChunk &chunk, vector<column_t> &column_ids);
152: 
153: 	void InitializeIndexScan(Transaction &transaction, TableIndexScanState &state, Index &index,
154: 	                         vector<column_t> column_ids);
155: 
156: 	void InitializeScanWithOffset(TableScanState &state, const vector<column_t> &column_ids,
157: 	                              unordered_map<idx_t, vector<TableFilter>> *table_filters, idx_t offset);
158: 	bool CheckZonemap(TableScanState &state, unordered_map<idx_t, vector<TableFilter>> &table_filters,
159: 	                  idx_t &current_row);
160: 	bool ScanBaseTable(Transaction &transaction, DataChunk &result, TableScanState &state,
161: 	                   const vector<column_t> &column_ids, idx_t &current_row, idx_t max_row, idx_t base_row,
162: 	                   VersionManager &manager, unordered_map<idx_t, vector<TableFilter>> &table_filters);
163: 	bool ScanCreateIndex(CreateIndexScanState &state, const vector<column_t> &column_ids, DataChunk &result,
164: 	                     idx_t &current_row, idx_t max_row, idx_t base_row);
165: 
166: 	//! Figure out which of the row ids to use for the given transaction by looking at inserted/deleted data. Returns
167: 	//! the amount of rows to use and places the row_ids in the result_rows array.
168: 	idx_t FetchRows(Transaction &transaction, Vector &row_identifiers, idx_t fetch_count, row_t result_rows[]);
169: 
170: 	//! The CreateIndexScan is a special scan that is used to create an index on the table, it keeps locks on the table
171: 	void InitializeCreateIndexScan(CreateIndexScanState &state, const vector<column_t> &column_ids);
172: 	void CreateIndexScan(CreateIndexScanState &structure, const vector<column_t> &column_ids, DataChunk &result);
173: 
174: private:
175: 	//! Lock for appending entries to the table
176: 	std::mutex append_lock;
177: 	//! The version manager of the persistent segments of the tree
178: 	shared_ptr<VersionManager> persistent_manager;
179: 	//! The version manager of the transient segments of the tree
180: 	shared_ptr<VersionManager> transient_manager;
181: 	//! The physical columns of the table
182: 	vector<shared_ptr<ColumnData>> columns;
183: 	//! Whether or not the data table is the root DataTable for this table; the root DataTable is the newest version
184: 	//! that can be appended to
185: 	bool is_root;
186: };
187: } // namespace duckdb
[end of src/include/duckdb/storage/data_table.hpp]
[start of src/include/duckdb/storage/index.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/storage/index.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_set.hpp"
12: #include "duckdb/common/enums/index_type.hpp"
13: #include "duckdb/common/types/data_chunk.hpp"
14: #include "duckdb/parser/parsed_expression.hpp"
15: #include "duckdb/planner/expression.hpp"
16: #include "duckdb/storage/table/scan_state.hpp"
17: #include "duckdb/execution/expression_executor.hpp"
18: 
19: namespace duckdb {
20: 
21: class ClientContext;
22: class Transaction;
23: 
24: struct IndexLock;
25: 
26: //! The index is an abstract base class that serves as the basis for indexes
27: class Index {
28: public:
29: 	Index(IndexType type, vector<column_t> column_ids, vector<unique_ptr<Expression>> unbound_expressions);
30: 	virtual ~Index() = default;
31: 
32: 	//! Lock used for updating the index
33: 	std::mutex lock;
34: 	//! The type of the index
35: 	IndexType type;
36: 	//! Column identifiers to extract from the base table
37: 	vector<column_t> column_ids;
38: 	//! unordered_set of column_ids used by the index
39: 	unordered_set<column_t> column_id_set;
40: 	//! Unbound expressions used by the index
41: 	vector<unique_ptr<Expression>> unbound_expressions;
42: 	//! The physical types stored in the index
43: 	vector<PhysicalType> types;
44: 	//! The logical types of the expressions
45: 	vector<LogicalType> logical_types;
46: 
47: public:
48: 	//! Initialize a scan on the index with the given expression and column ids
49: 	//! to fetch from the base table when we only have one query predicate
50: 	virtual unique_ptr<IndexScanState> InitializeScanSinglePredicate(Transaction &transaction,
51: 	                                                                 vector<column_t> column_ids, Value value,
52: 	                                                                 ExpressionType expressionType) = 0;
53: 	//! Initialize a scan on the index with the given expression and column ids
54: 	//! to fetch from the base table for two query predicates
55: 	virtual unique_ptr<IndexScanState> InitializeScanTwoPredicates(Transaction &transaction,
56: 	                                                               vector<column_t> column_ids, Value low_value,
57: 	                                                               ExpressionType low_expression_type, Value high_value,
58: 	                                                               ExpressionType high_expression_type) = 0;
59: 	//! Perform a lookup on the index
60: 	virtual void Scan(Transaction &transaction, DataTable &table, TableIndexScanState &state, DataChunk &result) = 0;
61: 
62: 	//! Obtain a lock on the index
63: 	virtual void InitializeLock(IndexLock &state);
64: 	//! Called when data is appended to the index. The lock obtained from InitializeAppend must be held
65: 	virtual bool Append(IndexLock &state, DataChunk &entries, Vector &row_identifiers) = 0;
66: 	bool Append(DataChunk &entries, Vector &row_identifiers);
67: 	//! Verify that data can be appended to the index
68: 	virtual void VerifyAppend(DataChunk &chunk) {
69: 	}
70: 
71: 	//! Called when data inside the index is Deleted
72: 	virtual void Delete(IndexLock &state, DataChunk &entries, Vector &row_identifiers) = 0;
73: 	void Delete(DataChunk &entries, Vector &row_identifiers);
74: 
75: 	//! Insert data into the index. Does not lock the index.
76: 	virtual bool Insert(IndexLock &lock, DataChunk &input, Vector &row_identifiers) = 0;
77: 
78: 	//! Returns true if the index is affected by updates on the specified column ids, and false otherwise
79: 	bool IndexIsUpdated(vector<column_t> &column_ids);
80: 
81: protected:
82: 	void ExecuteExpressions(DataChunk &input, DataChunk &result);
83: 
84: private:
85: 	//! Bound expressions used by the index
86: 	vector<unique_ptr<Expression>> bound_expressions;
87: 	//! Expression executor for the index expressions
88: 	ExpressionExecutor executor;
89: 
90: 	unique_ptr<Expression> BindExpression(unique_ptr<Expression> expr);
91: };
92: 
93: } // namespace duckdb
[end of src/include/duckdb/storage/index.hpp]
[start of src/include/duckdb/storage/table/scan_state.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/storage/table/scan_state.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/storage/buffer/buffer_handle.hpp"
13: #include "duckdb/storage/storage_lock.hpp"
14: #include "duckdb/storage/table/column_segment.hpp"
15: 
16: #include "duckdb/execution/adaptive_filter.hpp"
17: 
18: namespace duckdb {
19: class LocalTableStorage;
20: class Index;
21: class PersistentSegment;
22: class TransientSegment;
23: 
24: struct IndexScanState {
25: 	vector<column_t> column_ids;
26: 
27: 	IndexScanState(vector<column_t> column_ids) : column_ids(column_ids) {
28: 	}
29: 	virtual ~IndexScanState() {
30: 	}
31: };
32: 
33: typedef unordered_map<block_id_t, unique_ptr<BufferHandle>> buffer_handle_set_t;
34: 
35: struct ColumnScanState {
36: 	//! The column segment that is currently being scanned
37: 	ColumnSegment *current;
38: 	//! The vector index of the transient segment
39: 	idx_t vector_index;
40: 	//! The primary buffer handle
41: 	unique_ptr<BufferHandle> primary_handle;
42: 	//! The set of pinned block handles for this scan
43: 	buffer_handle_set_t handles;
44: 	//! The locks that are held during the scan, only used by the index scan
45: 	vector<unique_ptr<StorageLockKey>> locks;
46: 	//! Whether or not InitializeState has been called for this segment
47: 	bool initialized;
48: 	//! If this segment has already been checked for skipping puorposes
49: 	bool segment_checked;
50: 
51: public:
52: 	//! Move on to the next vector in the scan
53: 	void Next();
54: };
55: 
56: struct ColumnFetchState {
57: 	//! The set of pinned block handles for this set of fetches
58: 	buffer_handle_set_t handles;
59: };
60: 
61: struct LocalScanState {
62: 	LocalTableStorage *storage = nullptr;
63: 
64: 	idx_t chunk_index;
65: 	idx_t max_index;
66: 	idx_t last_chunk_count;
67: };
68: 
69: class TableScanState {
70: public:
71: 	TableScanState(){};
72: 	idx_t current_persistent_row, max_persistent_row;
73: 	idx_t current_transient_row, max_transient_row;
74: 	unique_ptr<ColumnScanState[]> column_scans;
75: 	idx_t column_count;
76: 	unique_ptr<AdaptiveFilter> adaptive_filter;
77: 	LocalScanState local_state;
78: 
79: 	//! Move to the next vector
80: 	void NextVector();
81: };
82: 
83: class CreateIndexScanState : public TableScanState {
84: public:
85: 	vector<unique_ptr<StorageLockKey>> locks;
86: 	std::unique_lock<std::mutex> append_lock;
87: };
88: 
89: struct TableIndexScanState {
90: 	Index *index;
91: 	unique_ptr<IndexScanState> index_state;
92: 	ColumnFetchState fetch_state;
93: 	LocalScanState local_state;
94: 	vector<column_t> column_ids;
95: };
96: 
97: } // namespace duckdb
[end of src/include/duckdb/storage/table/scan_state.hpp]
[start of src/main/query_profiler.cpp]
1: #include "duckdb/main/query_profiler.hpp"
2: 
3: #include "duckdb/common/fstream.hpp"
4: #include "duckdb/common/printer.hpp"
5: #include "duckdb/common/string_util.hpp"
6: #include "duckdb/execution/physical_operator.hpp"
7: #include "duckdb/execution/operator/join/physical_delim_join.hpp"
8: #include "duckdb/execution/operator/helper/physical_execute.hpp"
9: #include "duckdb/parser/sql_statement.hpp"
10: #include "duckdb/common/printer.hpp"
11: #include "duckdb/common/limits.hpp"
12: 
13: #include <iostream>
14: #include <utility>
15: #include <algorithm>
16: 
17: using namespace std;
18: 
19: namespace duckdb {
20: 
21: constexpr idx_t TREE_RENDER_WIDTH = 20;
22: constexpr idx_t REMAINING_RENDER_WIDTH = TREE_RENDER_WIDTH - 2;
23: constexpr idx_t MAX_EXTRA_LINES = 10;
24: 
25: void QueryProfiler::StartQuery(string query, SQLStatement &statement) {
26: 	if (!enabled) {
27: 		return;
28: 	}
29: 	this->running = true;
30: 	this->query = query;
31: 	tree_map.clear();
32: 	root = nullptr;
33: 	phase_timings.clear();
34: 	phase_stack.clear();
35: 
36: 	main_query.Start();
37: }
38: 
39: bool QueryProfiler::OperatorRequiresProfiling(PhysicalOperatorType op_type) {
40: 	switch (op_type) {
41: 	case PhysicalOperatorType::ORDER_BY:
42: 	case PhysicalOperatorType::LIMIT:
43: 	case PhysicalOperatorType::TOP_N:
44: 	case PhysicalOperatorType::AGGREGATE:
45: 	case PhysicalOperatorType::WINDOW:
46: 	case PhysicalOperatorType::UNNEST:
47: 	case PhysicalOperatorType::DISTINCT:
48: 	case PhysicalOperatorType::SIMPLE_AGGREGATE:
49: 	case PhysicalOperatorType::HASH_GROUP_BY:
50: 	case PhysicalOperatorType::SORT_GROUP_BY:
51: 	case PhysicalOperatorType::FILTER:
52: 	case PhysicalOperatorType::PROJECTION:
53: 	case PhysicalOperatorType::COPY_FROM_FILE:
54: 	case PhysicalOperatorType::COPY_TO_FILE:
55: 	case PhysicalOperatorType::TABLE_FUNCTION:
56: 	case PhysicalOperatorType::SEQ_SCAN:
57: 	case PhysicalOperatorType::INDEX_SCAN:
58: 	case PhysicalOperatorType::CHUNK_SCAN:
59: 	case PhysicalOperatorType::DELIM_SCAN:
60: 	case PhysicalOperatorType::EXTERNAL_FILE_SCAN:
61: 	case PhysicalOperatorType::QUERY_DERIVED_SCAN:
62: 	case PhysicalOperatorType::EXPRESSION_SCAN:
63: 	case PhysicalOperatorType::BLOCKWISE_NL_JOIN:
64: 	case PhysicalOperatorType::NESTED_LOOP_JOIN:
65: 	case PhysicalOperatorType::HASH_JOIN:
66: 	case PhysicalOperatorType::CROSS_PRODUCT:
67: 	case PhysicalOperatorType::PIECEWISE_MERGE_JOIN:
68: 	case PhysicalOperatorType::DELIM_JOIN:
69: 	case PhysicalOperatorType::UNION:
70: 	case PhysicalOperatorType::RECURSIVE_CTE:
71: 		return true;
72: 	default:
73: 		return false;
74: 	}
75: }
76: 
77: void QueryProfiler::EndQuery() {
78: 	if (!enabled || !running) {
79: 		return;
80: 	}
81: 
82: 	main_query.End();
83: 	this->running = false;
84: 	// print or output the query profiling after termination, if this is enabled
85: 	if (automatic_print_format != ProfilerPrintFormat::NONE) {
86: 		// check if this query should be output based on the operator types
87: 		string query_info;
88: 		if (automatic_print_format == ProfilerPrintFormat::JSON) {
89: 			query_info = ToJSON();
90: 		} else if (automatic_print_format == ProfilerPrintFormat::QUERY_TREE) {
91: 			query_info = ToString();
92: 		}
93: 
94: 		if (save_location.empty()) {
95: 			Printer::Print(query_info);
96: 			Printer::Print("\n");
97: 		} else {
98: 			WriteToFile(save_location.c_str(), query_info);
99: 		}
100: 	}
101: }
102: 
103: void QueryProfiler::StartPhase(string new_phase) {
104: 	if (!enabled || !running) {
105: 		return;
106: 	}
107: 
108: 	if (!phase_stack.empty()) {
109: 		// there are active phases
110: 		phase_profiler.End();
111: 		// add the timing to all phases prior to this one
112: 		string prefix = "";
113: 		for (auto &phase : phase_stack) {
114: 			phase_timings[phase] += phase_profiler.Elapsed();
115: 			prefix += phase + " > ";
116: 		}
117: 		// when there are previous phases, we prefix the current phase with those phases
118: 		new_phase = prefix + new_phase;
119: 	}
120: 
121: 	// start a new phase
122: 	phase_stack.push_back(new_phase);
123: 	// restart the timer
124: 	phase_profiler.Start();
125: }
126: 
127: void QueryProfiler::EndPhase() {
128: 	if (!enabled || !running) {
129: 		return;
130: 	}
131: 	assert(phase_stack.size() > 0);
132: 
133: 	// end the timer
134: 	phase_profiler.End();
135: 	// add the timing to all currently active phases
136: 	for (auto &phase : phase_stack) {
137: 		phase_timings[phase] += phase_profiler.Elapsed();
138: 	}
139: 	// now remove the last added phase
140: 	phase_stack.pop_back();
141: 
142: 	if (phase_stack.size() > 0) {
143: 		phase_profiler.Start();
144: 	}
145: }
146: 
147: void QueryProfiler::Initialize(PhysicalOperator *root_op) {
148: 	if (!enabled || !running) {
149: 		return;
150: 	}
151: 	this->query_requires_profiling = false;
152: 	this->root = CreateTree(root_op);
153: 	if (!query_requires_profiling) {
154: 		// query does not require profiling: disable profiling for this query
155: 		this->running = false;
156: 		tree_map.clear();
157: 		root = nullptr;
158: 		phase_timings.clear();
159: 		phase_stack.clear();
160: 	}
161: }
162: 
163: OperatorProfiler::OperatorProfiler(bool enabled_) : enabled(enabled_) {
164: 	execution_stack = stack<PhysicalOperator *>();
165: }
166: 
167: void OperatorProfiler::StartOperator(PhysicalOperator *phys_op) {
168: 	if (!enabled) {
169: 		return;
170: 	}
171: 
172: 	if (!execution_stack.empty()) {
173: 		// add timing for the previous element
174: 		op.End();
175: 
176: 		AddTiming(execution_stack.top(), op.Elapsed(), 0);
177: 	}
178: 
179: 	execution_stack.push(phys_op);
180: 
181: 	// start timing for current element
182: 	op.Start();
183: }
184: 
185: void OperatorProfiler::EndOperator(DataChunk *chunk) {
186: 	if (!enabled) {
187: 		return;
188: 	}
189: 
190: 	// finish timing for the current element
191: 	op.End();
192: 
193: 	AddTiming(execution_stack.top(), op.Elapsed(), chunk ? chunk->size() : 0);
194: 
195: 	assert(!execution_stack.empty());
196: 	execution_stack.pop();
197: 
198: 	// start timing again for the previous element, if any
199: 	if (!execution_stack.empty()) {
200: 		op.Start();
201: 	}
202: }
203: 
204: void OperatorProfiler::AddTiming(PhysicalOperator *op, double time, idx_t elements) {
205: 	auto entry = timings.find(op);
206: 	if (entry == timings.end()) {
207: 		// add new entry
208: 		timings[op] = OperatorTimingInformation(time, elements);
209: 	} else {
210: 		// add to existing entry
211: 		entry->second.time += time;
212: 		entry->second.elements += elements;
213: 	}
214: }
215: 
216: void QueryProfiler::Flush(OperatorProfiler &profiler) {
217: 	for (auto &node : profiler.timings) {
218: 		auto entry = tree_map.find(node.first);
219: 		assert(entry != tree_map.end());
220: 
221: 		entry->second->info.time += node.second.time;
222: 		entry->second->info.elements += node.second.elements;
223: 	}
224: }
225: 
226: string QueryProfiler::ToString() const {
227: 	if (!enabled) {
228: 		return "Query profiling is disabled. Call "
229: 		       "Connection::EnableProfiling() to enable profiling!";
230: 	}
231: 
232: 	if (query.empty()) {
233: 		return "<<Empty Profiling Information>>";
234: 	}
235: 	string result = "<<Query Profiling Information>>\n";
236: 	result += StringUtil::Replace(query, "\n", " ") + "\n";
237: 	result += "<<Timing>>\n";
238: 	result += "Total Time: " + to_string(main_query.Elapsed()) + "s\n";
239: 	// print phase timings
240: 	for (const auto &entry : GetOrderedPhaseTimings()) {
241: 		result += entry.first + ": " + to_string(entry.second) + "s\n";
242: 	}
243: 	// render the main operator tree
244: 	result += "<<Operator Tree>>\n";
245: 	if (!root) {
246: 		result += "<<ERROR RENDERING ROOT>";
247: 	} else {
248: 		result += RenderTree(*root);
249: 	}
250: 	return result;
251: }
252: 
253: static string ToJSONRecursive(QueryProfiler::TreeNode &node) {
254: 	string result = "{ \"name\": \"" + node.name + "\",\n";
255: 	result += "\"timing\":" + StringUtil::Format("%.2f", node.info.time) + ",\n";
256: 	result += "\"cardinality\":" + to_string(node.info.elements) + ",\n";
257: 	result += "\"extra_info\": \"" + StringUtil::Replace(node.extra_info, "\n", "\\n") + "\",\n";
258: 	result += "\"children\": [";
259: 	result +=
260: 	    StringUtil::Join(node.children, node.children.size(), ",\n",
261: 	                     [](const unique_ptr<QueryProfiler::TreeNode> &child) { return ToJSONRecursive(*child); });
262: 	result += "]\n}\n";
263: 	return result;
264: }
265: 
266: string QueryProfiler::ToJSON() const {
267: 	if (!enabled) {
268: 		return "{ \"result\": \"disabled\" }\n";
269: 	}
270: 	if (query.empty()) {
271: 		return "{ \"result\": \"empty\" }\n";
272: 	}
273: 	if (!root) {
274: 		return "{ \"result\": \"error\" }\n";
275: 	}
276: 	string result = "{ \"result\": " + to_string(main_query.Elapsed()) + ",\n";
277: 	// print the phase timings
278: 	result += "\"timings\": {\n";
279: 	const auto &ordered_phase_timings = GetOrderedPhaseTimings();
280: 	result +=
281: 	    StringUtil::Join(ordered_phase_timings, ordered_phase_timings.size(), ",\n", [](const PhaseTimingItem &entry) {
282: 		    return "\"" + entry.first + "\": " + to_string(entry.second);
283: 	    });
284: 	result += "},\n";
285: 	// recursively print the physical operator tree
286: 	result += "\"tree\": ";
287: 	result += ToJSONRecursive(*root);
288: 	return result + "}";
289: }
290: 
291: void QueryProfiler::WriteToFile(const char *path, string &info) const {
292: 	ofstream out(path);
293: 	out << info;
294: 	out.close();
295: }
296: 
297: static bool is_non_split_char(char l) {
298: 	return (l >= 65 && l <= 90) || (l >= 97 && l <= 122) || l == 95 || l == ']' || l == ')';
299: }
300: 
301: static bool is_padding(char l) {
302: 	return l == ' ' || l == '(' || l == ')';
303: }
304: 
305: static string remove_padding(string l) {
306: 	idx_t start = 0, end = l.size();
307: 	while (start < l.size() && is_padding(l[start])) {
308: 		start++;
309: 	}
310: 	while (end > 0 && is_padding(l[end - 1])) {
311: 		end--;
312: 	}
313: 	return l.substr(start, end - start);
314: }
315: 
316: unique_ptr<QueryProfiler::TreeNode> QueryProfiler::CreateTree(PhysicalOperator *root, idx_t depth) {
317: 	if (OperatorRequiresProfiling(root->type)) {
318: 		this->query_requires_profiling = true;
319: 	}
320: 	auto node = make_unique<QueryProfiler::TreeNode>();
321: 	node->name = PhysicalOperatorToString(root->type);
322: 	node->extra_info = root->ExtraRenderInformation();
323: 	if (!node->extra_info.empty()) {
324: 		auto splits = StringUtil::Split(node->extra_info, '\n');
325: 		for (auto &split : splits) {
326: 			string str = remove_padding(split);
327: 			constexpr idx_t max_segment_size = REMAINING_RENDER_WIDTH - 2;
328: 			idx_t location = 0;
329: 			while (location < str.size() && node->split_extra_info.size() < MAX_EXTRA_LINES) {
330: 				bool has_to_split = (str.size() - location) > max_segment_size;
331: 				if (has_to_split) {
332: 					// look for a split character
333: 					idx_t i;
334: 					for (i = 8; i < max_segment_size; i++) {
335: 						if (!is_non_split_char(str[location + i])) {
336: 							// split here
337: 							break;
338: 						}
339: 					}
340: 					node->split_extra_info.push_back(str.substr(location, i));
341: 					location += i;
342: 				} else {
343: 					node->split_extra_info.push_back(str.substr(location));
344: 					break;
345: 				}
346: 			}
347: 		}
348: 	}
349: 	node->depth = depth;
350: 	tree_map[root] = node.get();
351: 	for (auto &child : root->children) {
352: 		auto child_node = CreateTree(child.get(), depth + 1);
353: 		node->children.push_back(move(child_node));
354: 	}
355: 	switch (root->type) {
356: 	case PhysicalOperatorType::DELIM_JOIN: {
357: 		auto &delim_join = (PhysicalDelimJoin &)*root;
358: 		auto child_node = CreateTree((PhysicalOperator *)delim_join.join.get(), depth + 1);
359: 		node->children.push_back(move(child_node));
360: 		child_node = CreateTree((PhysicalOperator *)delim_join.distinct.get(), depth + 1);
361: 		node->children.push_back(move(child_node));
362: 		break;
363: 	}
364: 	case PhysicalOperatorType::EXECUTE: {
365: 		auto &execute = (PhysicalExecute &)*root;
366: 		auto child_node = CreateTree((PhysicalOperator *)execute.plan, depth + 1);
367: 		node->children.push_back(move(child_node));
368: 		break;
369: 	}
370: 	default:
371: 		break;
372: 	}
373: 	return node;
374: }
375: 
376: static string DrawPadded(string text, char padding_character = ' ') {
377: 	auto remaining_width = REMAINING_RENDER_WIDTH;
378: 	if (text.size() > remaining_width) {
379: 		text = text.substr(0, remaining_width);
380: 	}
381: 	assert(text.size() <= (idx_t)NumericLimits<int32_t>::Maximum());
382: 
383: 	auto right_padding = (remaining_width - text.size()) / 2;
384: 	auto left_padding = remaining_width - text.size() - right_padding;
385: 	return "|" + string(left_padding, padding_character) + text + string(right_padding, padding_character) + "|";
386: }
387: 
388: idx_t QueryProfiler::RenderTreeRecursive(QueryProfiler::TreeNode &node, vector<string> &render,
389:                                          vector<idx_t> &render_heights, idx_t base_render_x, idx_t start_depth,
390:                                          idx_t depth) {
391: 	auto render_height = render_heights[depth];
392: 	auto width = base_render_x;
393: 	// render this node
394: 	// first add any padding to render at this location
395: 	auto start_position = width * TREE_RENDER_WIDTH;
396: 	for (idx_t i = 0; i < render_height; i++) {
397: 		if (render[start_depth + i].size() > start_position) {
398: 			// something has already been rendered here!
399: 			throw Exception("Tree rendering error, overlapping nodes!");
400: 		} else {
401: 			// add the padding
402: 			render[start_depth + i] += string(start_position - render[start_depth + i].size(), ' ');
403: 		}
404: 	}
405: 
406: 	// draw the boundaries of the box
407: 	render[start_depth] += string(TREE_RENDER_WIDTH, '-');
408: 	render[start_depth + render_height - 1] += string(TREE_RENDER_WIDTH, '-');
409: 
410: 	// draw the name
411: 	string name = node.name;
412: 	render[start_depth + 1] += DrawPadded(name);
413: 	// draw extra information
414: 	for (idx_t i = 2; i < render_height - 3; i++) {
415: 		auto split_index = i - 2;
416: 		string string = split_index < node.split_extra_info.size() ? node.split_extra_info[split_index] : "";
417: 		render[start_depth + i] += DrawPadded(string);
418: 	}
419: 	// draw the timing information
420: 	string timing = StringUtil::Format("%.2f", node.info.time);
421: 	render[start_depth + render_height - 3] += DrawPadded("(" + timing + "s)");
422: 	// draw the intermediate count
423: 	render[start_depth + render_height - 2] += DrawPadded(to_string(node.info.elements));
424: 
425: 	for (auto &child : node.children) {
426: 		// render all the children
427: 		width =
428: 		    RenderTreeRecursive(*child, render, render_heights, width, start_depth + render_heights[depth], depth + 1);
429: 		width++;
430: 	}
431: 	if (node.children.size() > 0) {
432: 		width--;
433: 	}
434: 	return width;
435: }
436: 
437: idx_t QueryProfiler::GetDepth(QueryProfiler::TreeNode &node) {
438: 	idx_t depth = 0;
439: 	for (auto &child : node.children) {
440: 		depth = max(depth, GetDepth(*child));
441: 	}
442: 	return depth + 1;
443: }
444: 
445: static void GetRenderHeight(QueryProfiler::TreeNode &node, vector<idx_t> &render_heights, int depth = 0) {
446: 	render_heights[depth] = max(render_heights[depth], (5 + (idx_t)node.split_extra_info.size()));
447: 	for (auto &child : node.children) {
448: 		GetRenderHeight(*child, render_heights, depth + 1);
449: 	}
450: }
451: 
452: string QueryProfiler::RenderTree(QueryProfiler::TreeNode &node) {
453: 	vector<idx_t> render_heights;
454: 	// compute the height of each level
455: 	auto depth = GetDepth(node);
456: 
457: 	// compute the render height
458: 	render_heights.resize(depth);
459: 	GetRenderHeight(node, render_heights);
460: 	int32_t total_height = 0;
461: 	for (auto height : render_heights) {
462: 		total_height += height;
463: 	}
464: 
465: 	// now actually render the tree
466: 	vector<string> render;
467: 	render.resize(total_height);
468: 
469: 	RenderTreeRecursive(node, render, render_heights);
470: 	string text;
471: 	for (auto &str : render) {
472: 		text += str + "\n";
473: 	}
474: 	return text;
475: }
476: 
477: void QueryProfiler::Print() {
478: 	Printer::Print(ToString());
479: }
480: 
481: vector<QueryProfiler::PhaseTimingItem> QueryProfiler::GetOrderedPhaseTimings() const {
482: 	vector<PhaseTimingItem> result;
483: 	// first sort the phases alphabetically
484: 	vector<string> phases;
485: 	for (auto &entry : phase_timings) {
486: 		phases.push_back(entry.first);
487: 	}
488: 	std::sort(phases.begin(), phases.end());
489: 	for (const auto &phase : phases) {
490: 		auto entry = phase_timings.find(phase);
491: 		assert(entry != phase_timings.end());
492: 		result.emplace_back(entry->first, entry->second);
493: 	}
494: 	return result;
495: }
496: 
497: } // namespace duckdb
[end of src/main/query_profiler.cpp]
[start of src/optimizer/CMakeLists.txt]
1: add_subdirectory(matcher)
2: add_subdirectory(join_order)
3: add_subdirectory(pushdown)
4: add_subdirectory(rule)
5: 
6: add_library_unity(duckdb_optimizer
7:                   OBJECT
8:                   cse_optimizer.cpp
9:                   column_lifetime_analyzer.cpp
10:                   expression_heuristics.cpp
11:                   filter_combiner.cpp
12:                   filter_pushdown.cpp
13:                   in_clause_rewriter.cpp
14:                   join_order_optimizer.cpp
15:                   optimizer.cpp
16:                   expression_rewriter.cpp
17:                   regex_range_filter.cpp
18:                   remove_unused_columns.cpp
19:                   index_scan.cpp
20:                   topn_optimizer.cpp)
21: set(ALL_OBJECT_FILES
22:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_optimizer>
23:     PARENT_SCOPE)
[end of src/optimizer/CMakeLists.txt]
[start of src/optimizer/filter_combiner.cpp]
1: #include "duckdb/optimizer/filter_combiner.hpp"
2: 
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/planner/expression/bound_between_expression.hpp"
5: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
6: #include "duckdb/planner/expression/bound_constant_expression.hpp"
7: #include "duckdb/planner/expression/bound_function_expression.hpp"
8: #include "duckdb/planner/operator/logical_empty_result.hpp"
9: #include "duckdb/planner/operator/logical_filter.hpp"
10: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
11: #include "duckdb/planner/expression.hpp"
12: namespace duckdb {
13: using namespace std;
14: 
15: using ExpressionValueInformation = FilterCombiner::ExpressionValueInformation;
16: 
17: ValueComparisonResult CompareValueInformation(ExpressionValueInformation &left, ExpressionValueInformation &right);
18: 
19: Expression *FilterCombiner::GetNode(Expression *expr) {
20: 	auto entry = stored_expressions.find(expr);
21: 	if (entry != stored_expressions.end()) {
22: 		// expression already exists: return a reference to the stored expression
23: 		return entry->second.get();
24: 	}
25: 	// expression does not exist yet: create a copy and store it
26: 	auto copy = expr->Copy();
27: 	auto pointer_copy = copy.get();
28: 	assert(stored_expressions.find(pointer_copy) == stored_expressions.end());
29: 	stored_expressions.insert(make_pair(pointer_copy, move(copy)));
30: 	return pointer_copy;
31: }
32: 
33: idx_t FilterCombiner::GetEquivalenceSet(Expression *expr) {
34: 	assert(stored_expressions.find(expr) != stored_expressions.end());
35: 	assert(stored_expressions.find(expr)->second.get() == expr);
36: 
37: 	auto entry = equivalence_set_map.find(expr);
38: 	if (entry == equivalence_set_map.end()) {
39: 		idx_t index = set_index++;
40: 		equivalence_set_map[expr] = index;
41: 		equivalence_map[index].push_back(expr);
42: 		constant_values.insert(make_pair(index, vector<ExpressionValueInformation>()));
43: 		return index;
44: 	} else {
45: 		return entry->second;
46: 	}
47: }
48: 
49: FilterResult FilterCombiner::AddConstantComparison(vector<ExpressionValueInformation> &info_list,
50:                                                    ExpressionValueInformation info) {
51: 	for (idx_t i = 0; i < info_list.size(); i++) {
52: 		auto comparison = CompareValueInformation(info_list[i], info);
53: 		switch (comparison) {
54: 		case ValueComparisonResult::PRUNE_LEFT:
55: 			// prune the entry from the info list
56: 			info_list.erase(info_list.begin() + i);
57: 			i--;
58: 			break;
59: 		case ValueComparisonResult::PRUNE_RIGHT:
60: 			// prune the current info
61: 			return FilterResult::SUCCESS;
62: 		case ValueComparisonResult::UNSATISFIABLE_CONDITION:
63: 			// combination of filters is unsatisfiable: prune the entire branch
64: 			return FilterResult::UNSATISFIABLE;
65: 		default:
66: 			// prune nothing, move to the next condition
67: 			break;
68: 		}
69: 	}
70: 	// finally add the entry to the list
71: 	info_list.push_back(info);
72: 	return FilterResult::SUCCESS;
73: }
74: 
75: FilterResult FilterCombiner::AddFilter(unique_ptr<Expression> expr) {
76: 	// try to push the filter into the combiner
77: 	auto result = AddFilter(expr.get());
78: 	if (result == FilterResult::UNSUPPORTED) {
79: 		// unsupported filter, push into remaining filters
80: 		remaining_filters.push_back(move(expr));
81: 		return FilterResult::SUCCESS;
82: 	}
83: 	return result;
84: }
85: 
86: void FilterCombiner::GenerateFilters(std::function<void(unique_ptr<Expression> filter)> callback) {
87: 	// first loop over the remaining filters
88: 	for (auto &filter : remaining_filters) {
89: 		callback(move(filter));
90: 	}
91: 	remaining_filters.clear();
92: 	// now loop over the equivalence sets
93: 	for (auto &entry : equivalence_map) {
94: 		auto equivalence_set = entry.first;
95: 		auto &entries = entry.second;
96: 		auto &constant_list = constant_values.find(equivalence_set)->second;
97: 		// for each entry generate an equality expression comparing to each other
98: 		for (idx_t i = 0; i < entries.size(); i++) {
99: 			for (idx_t k = i + 1; k < entries.size(); k++) {
100: 				auto comparison = make_unique<BoundComparisonExpression>(ExpressionType::COMPARE_EQUAL,
101: 				                                                         entries[i]->Copy(), entries[k]->Copy());
102: 				callback(move(comparison));
103: 			}
104: 			// for each entry also create a comparison with each constant
105: 			int lower_index = -1, upper_index = -1;
106: 			bool lower_inclusive, upper_inclusive;
107: 			for (idx_t k = 0; k < constant_list.size(); k++) {
108: 				auto &info = constant_list[k];
109: 				if (info.comparison_type == ExpressionType::COMPARE_GREATERTHAN ||
110: 				    info.comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO) {
111: 					lower_index = k;
112: 					lower_inclusive = info.comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO;
113: 				} else if (info.comparison_type == ExpressionType::COMPARE_LESSTHAN ||
114: 				           info.comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO) {
115: 					upper_index = k;
116: 					upper_inclusive = info.comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO;
117: 				} else {
118: 					auto constant = make_unique<BoundConstantExpression>(info.constant);
119: 					auto comparison = make_unique<BoundComparisonExpression>(info.comparison_type, entries[i]->Copy(),
120: 					                                                         move(constant));
121: 					callback(move(comparison));
122: 				}
123: 			}
124: 			if (lower_index >= 0 && upper_index >= 0) {
125: 				// found both lower and upper index, create a BETWEEN expression
126: 				auto lower_constant = make_unique<BoundConstantExpression>(constant_list[lower_index].constant);
127: 				auto upper_constant = make_unique<BoundConstantExpression>(constant_list[upper_index].constant);
128: 				auto between = make_unique<BoundBetweenExpression>(
129: 				    entries[i]->Copy(), move(lower_constant), move(upper_constant), lower_inclusive, upper_inclusive);
130: 				callback(move(between));
131: 			} else if (lower_index >= 0) {
132: 				// only lower index found, create simple comparison expression
133: 				auto constant = make_unique<BoundConstantExpression>(constant_list[lower_index].constant);
134: 				auto comparison = make_unique<BoundComparisonExpression>(constant_list[lower_index].comparison_type,
135: 				                                                         entries[i]->Copy(), move(constant));
136: 				callback(move(comparison));
137: 			} else if (upper_index >= 0) {
138: 				// only upper index found, create simple comparison expression
139: 				auto constant = make_unique<BoundConstantExpression>(constant_list[upper_index].constant);
140: 				auto comparison = make_unique<BoundComparisonExpression>(constant_list[upper_index].comparison_type,
141: 				                                                         entries[i]->Copy(), move(constant));
142: 				callback(move(comparison));
143: 			}
144: 		}
145: 	}
146: 	stored_expressions.clear();
147: 	equivalence_set_map.clear();
148: 	constant_values.clear();
149: 	equivalence_map.clear();
150: }
151: 
152: bool FilterCombiner::HasFilters() {
153: 	bool has_filters = false;
154: 	GenerateFilters([&](unique_ptr<Expression> child) { has_filters = true; });
155: 	return has_filters;
156: }
157: 
158: vector<TableFilter>
159: FilterCombiner::GenerateTableScanFilters(std::function<void(unique_ptr<Expression> filter)> callback,
160:                                          vector<idx_t> &column_ids) {
161: 	vector<TableFilter> tableFilters;
162: 	//! First, we figure the filters that have constant expressions that we can push down to the table scan
163: 	for (auto &constant_value : constant_values) {
164: 		if (constant_value.second.size() > 0) {
165: 			//			for (idx_t i = 0; i < constant_value.second.size(); ++i) {
166: 			auto filter_exp = equivalence_map.end();
167: 			if ((constant_value.second[0].comparison_type == ExpressionType::COMPARE_EQUAL ||
168: 			     constant_value.second[0].comparison_type == ExpressionType::COMPARE_GREATERTHAN ||
169: 			     constant_value.second[0].comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO ||
170: 			     constant_value.second[0].comparison_type == ExpressionType::COMPARE_LESSTHAN ||
171: 			     constant_value.second[0].comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO) &&
172: 			    (TypeIsNumeric(constant_value.second[0].constant.type().InternalType()) ||
173: 			     constant_value.second[0].constant.type().InternalType() == PhysicalType::VARCHAR)) {
174: 				//! Here we check if these filters are column references
175: 				filter_exp = equivalence_map.find(constant_value.first);
176: 				if (filter_exp->second.size() == 1 && filter_exp->second[0]->type == ExpressionType::BOUND_COLUMN_REF) {
177: 					auto filter_col_exp = static_cast<BoundColumnRefExpression *>(filter_exp->second[0]);
178: 					if (column_ids[filter_col_exp->binding.column_index] == COLUMN_IDENTIFIER_ROW_ID) {
179: 						break;
180: 					}
181: 					auto equivalence_set = filter_exp->first;
182: 					auto &entries = filter_exp->second;
183: 					auto &constant_list = constant_values.find(equivalence_set)->second;
184: 					// for each entry generate an equality expression comparing to each other
185: 					for (idx_t i = 0; i < entries.size(); i++) {
186: 						for (idx_t k = i + 1; k < entries.size(); k++) {
187: 							auto comparison = make_unique<BoundComparisonExpression>(
188: 							    ExpressionType::COMPARE_EQUAL, entries[i]->Copy(), entries[k]->Copy());
189: 							callback(move(comparison));
190: 						}
191: 						// for each entry also create a comparison with each constant
192: 						int lower_index = -1, upper_index = -1;
193: 						for (idx_t k = 0; k < constant_list.size(); k++) {
194: 							tableFilters.push_back(TableFilter(constant_value.second[k].constant,
195: 							                                   constant_value.second[k].comparison_type,
196: 							                                   filter_col_exp->binding.column_index));
197: 							auto &info = constant_list[k];
198: 							if (info.comparison_type == ExpressionType::COMPARE_GREATERTHAN ||
199: 							    info.comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO) {
200: 								lower_index = k;
201: 
202: 							} else if (info.comparison_type == ExpressionType::COMPARE_LESSTHAN ||
203: 							           info.comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO) {
204: 								upper_index = k;
205: 							} else {
206: 								auto constant = make_unique<BoundConstantExpression>(info.constant);
207: 								auto comparison = make_unique<BoundComparisonExpression>(
208: 								    info.comparison_type, entries[i]->Copy(), move(constant));
209: 								callback(move(comparison));
210: 							}
211: 						}
212: 						if (lower_index >= 0) {
213: 							// only lower index found, create simple comparison expression
214: 							auto constant = make_unique<BoundConstantExpression>(constant_list[lower_index].constant);
215: 							auto comparison = make_unique<BoundComparisonExpression>(
216: 							    constant_list[lower_index].comparison_type, entries[i]->Copy(), move(constant));
217: 							callback(move(comparison));
218: 						}
219: 						if (upper_index >= 0) {
220: 							// only upper index found, create simple comparison expression
221: 							auto constant = make_unique<BoundConstantExpression>(constant_list[upper_index].constant);
222: 							auto comparison = make_unique<BoundComparisonExpression>(
223: 							    constant_list[upper_index].comparison_type, entries[i]->Copy(), move(constant));
224: 							callback(move(comparison));
225: 						}
226: 					}
227: 					equivalence_map.erase(filter_exp);
228: 				}
229: 			}
230: 		}
231: 	}
232: 	//! Here we look for LIKE filters with a prefix to use them to skip partitions
233: 	for (auto &remaining_filter : remaining_filters) {
234: 		if (remaining_filter->expression_class == ExpressionClass::BOUND_FUNCTION) {
235: 			auto &func = (BoundFunctionExpression &)*remaining_filter;
236: 			if (func.function.name == "prefix" &&
237: 			    func.children[0]->expression_class == ExpressionClass::BOUND_COLUMN_REF &&
238: 			    func.children[1]->type == ExpressionType::VALUE_CONSTANT) {
239: 				//! This is a like function.
240: 				auto &column_ref = (BoundColumnRefExpression &)*func.children[0].get();
241: 				auto &constant_value_expr = (BoundConstantExpression &)*func.children[1].get();
242: 				string like_string = constant_value_expr.value.str_value;
243: 				if (like_string.empty()) {
244: 					continue;
245: 				}
246: 				auto const_value = constant_value_expr.value.Copy();
247: 				const_value.str_value = like_string;
248: 				//! Here the like must be transformed to a BOUND COMPARISON geq le
249: 				tableFilters.push_back(TableFilter(const_value, ExpressionType::COMPARE_GREATERTHANOREQUALTO,
250: 				                                   column_ref.binding.column_index));
251: 				const_value.str_value[const_value.str_value.size() - 1]++;
252: 				tableFilters.push_back(
253: 				    TableFilter(const_value, ExpressionType::COMPARE_LESSTHAN, column_ref.binding.column_index));
254: 			}
255: 			if (func.function.name == "~~" && func.children[0]->expression_class == ExpressionClass::BOUND_COLUMN_REF &&
256: 			    func.children[1]->type == ExpressionType::VALUE_CONSTANT) {
257: 				//! This is a like function.
258: 				auto &column_ref = (BoundColumnRefExpression &)*func.children[0].get();
259: 				auto &constant_value_expr = (BoundConstantExpression &)*func.children[1].get();
260: 				string like_string = constant_value_expr.value.str_value;
261: 				auto const_value = constant_value_expr.value.Copy();
262: 				if (like_string[0] == '%' || like_string[0] == '_') {
263: 					//! We have no prefix so nothing to pushdown
264: 					break;
265: 				}
266: 				string prefix;
267: 				bool equality = true;
268: 				for (char const &c : like_string) {
269: 					if (c == '%' || c == '_') {
270: 						equality = false;
271: 						break;
272: 					}
273: 					prefix += c;
274: 				}
275: 				const_value.str_value = prefix;
276: 				if (equality) {
277: 					//! Here the like can be transformed to an equality query
278: 					tableFilters.push_back(
279: 					    TableFilter(const_value, ExpressionType::COMPARE_EQUAL, column_ref.binding.column_index));
280: 				} else {
281: 					//! Here the like must be transformed to a BOUND COMPARISON geq le
282: 					tableFilters.push_back(TableFilter(const_value, ExpressionType::COMPARE_GREATERTHANOREQUALTO,
283: 					                                   column_ref.binding.column_index));
284: 					const_value.str_value[const_value.str_value.size() - 1]++;
285: 					tableFilters.push_back(
286: 					    TableFilter(const_value, ExpressionType::COMPARE_LESSTHAN, column_ref.binding.column_index));
287: 				}
288: 			}
289: 		}
290: 	}
291: 
292: 	return tableFilters;
293: }
294: 
295: FilterResult FilterCombiner::AddFilter(Expression *expr) {
296: 	if (expr->HasParameter()) {
297: 		return FilterResult::UNSUPPORTED;
298: 	}
299: 	if (expr->IsFoldable()) {
300: 		// scalar condition, evaluate it
301: 		auto result = ExpressionExecutor::EvaluateScalar(*expr).CastAs(LogicalType::BOOLEAN);
302: 		// check if the filter passes
303: 		if (result.is_null || !result.value_.boolean) {
304: 			// the filter does not pass the scalar test, create an empty result
305: 			return FilterResult::UNSATISFIABLE;
306: 		} else {
307: 			// the filter passes the scalar test, just remove the condition
308: 			return FilterResult::SUCCESS;
309: 		}
310: 	}
311: 	assert(!expr->IsFoldable());
312: 	if (expr->GetExpressionClass() == ExpressionClass::BOUND_BETWEEN) {
313: 		auto &comparison = (BoundBetweenExpression &)*expr;
314: 		//! check if one of the sides is a scalar value
315: 		bool left_is_scalar = comparison.lower->IsFoldable();
316: 		bool right_is_scalar = comparison.upper->IsFoldable();
317: 		if (left_is_scalar || right_is_scalar) {
318: 			//! comparison with scalar
319: 			auto node = GetNode(comparison.input.get());
320: 			idx_t equivalence_set = GetEquivalenceSet(node);
321: 			auto scalar = comparison.lower.get();
322: 			auto constant_value = ExpressionExecutor::EvaluateScalar(*scalar);
323: 
324: 			// create the ExpressionValueInformation
325: 			ExpressionValueInformation info;
326: 			if (comparison.lower_inclusive) {
327: 				info.comparison_type = ExpressionType::COMPARE_GREATERTHANOREQUALTO;
328: 			} else {
329: 				info.comparison_type = ExpressionType::COMPARE_GREATERTHAN;
330: 			}
331: 			info.constant = constant_value;
332: 
333: 			// get the current bucket of constant values
334: 			assert(constant_values.find(equivalence_set) != constant_values.end());
335: 			auto &info_list = constant_values.find(equivalence_set)->second;
336: 			// check the existing constant comparisons to see if we can do any pruning
337: 			AddConstantComparison(info_list, info);
338: 			scalar = comparison.upper.get();
339: 			constant_value = ExpressionExecutor::EvaluateScalar(*scalar);
340: 
341: 			// create the ExpressionValueInformation
342: 			if (comparison.upper_inclusive) {
343: 				info.comparison_type = ExpressionType::COMPARE_LESSTHANOREQUALTO;
344: 			} else {
345: 				info.comparison_type = ExpressionType::COMPARE_LESSTHAN;
346: 			}
347: 			info.constant = constant_value;
348: 
349: 			// get the current bucket of constant values
350: 			assert(constant_values.find(equivalence_set) != constant_values.end());
351: 			// check the existing constant comparisons to see if we can do any pruning
352: 			return AddConstantComparison(constant_values.find(equivalence_set)->second, info);
353: 		}
354: 	} else if (expr->GetExpressionClass() == ExpressionClass::BOUND_COMPARISON) {
355: 		auto &comparison = (BoundComparisonExpression &)*expr;
356: 		if (comparison.type != ExpressionType::COMPARE_LESSTHAN &&
357: 		    comparison.type != ExpressionType::COMPARE_LESSTHANOREQUALTO &&
358: 		    comparison.type != ExpressionType::COMPARE_GREATERTHAN &&
359: 		    comparison.type != ExpressionType::COMPARE_GREATERTHANOREQUALTO &&
360: 		    comparison.type != ExpressionType::COMPARE_EQUAL && comparison.type != ExpressionType::COMPARE_NOTEQUAL) {
361: 			// only support [>, >=, <, <=, ==] expressions
362: 			return FilterResult::UNSUPPORTED;
363: 		}
364: 		// check if one of the sides is a scalar value
365: 		bool left_is_scalar = comparison.left->IsFoldable();
366: 		bool right_is_scalar = comparison.right->IsFoldable();
367: 		if (left_is_scalar || right_is_scalar) {
368: 			// comparison with scalar
369: 			auto node = GetNode(left_is_scalar ? comparison.right.get() : comparison.left.get());
370: 			idx_t equivalence_set = GetEquivalenceSet(node);
371: 			auto scalar = left_is_scalar ? comparison.left.get() : comparison.right.get();
372: 			auto constant_value = ExpressionExecutor::EvaluateScalar(*scalar);
373: 
374: 			// create the ExpressionValueInformation
375: 			ExpressionValueInformation info;
376: 			info.comparison_type = left_is_scalar ? FlipComparisionExpression(comparison.type) : comparison.type;
377: 			info.constant = constant_value;
378: 
379: 			// get the current bucket of constant values
380: 			assert(constant_values.find(equivalence_set) != constant_values.end());
381: 			auto &info_list = constant_values.find(equivalence_set)->second;
382: 			// check the existing constant comparisons to see if we can do any pruning
383: 			return AddConstantComparison(info_list, info);
384: 		} else {
385: 			// comparison between two non-scalars
386: 			// only handle comparisons for now
387: 			if (expr->type != ExpressionType::COMPARE_EQUAL) {
388: 				return FilterResult::UNSUPPORTED;
389: 			}
390: 			// get the LHS and RHS nodes
391: 			auto left_node = GetNode(comparison.left.get());
392: 			auto right_node = GetNode(comparison.right.get());
393: 			if (BaseExpression::Equals(left_node, right_node)) {
394: 				return FilterResult::UNSUPPORTED;
395: 			}
396: 			// get the equivalence sets of the LHS and RHS
397: 			auto left_equivalence_set = GetEquivalenceSet(left_node);
398: 			auto right_equivalence_set = GetEquivalenceSet(right_node);
399: 			if (left_equivalence_set == right_equivalence_set) {
400: 				// this equality filter already exists, prune it
401: 				return FilterResult::SUCCESS;
402: 			}
403: 			// add the right bucket into the left bucket
404: 			assert(equivalence_map.find(left_equivalence_set) != equivalence_map.end());
405: 			assert(equivalence_map.find(right_equivalence_set) != equivalence_map.end());
406: 
407: 			auto &left_bucket = equivalence_map.find(left_equivalence_set)->second;
408: 			auto &right_bucket = equivalence_map.find(right_equivalence_set)->second;
409: 			for (idx_t i = 0; i < right_bucket.size(); i++) {
410: 				// rewrite the equivalence set mapping for this node
411: 				equivalence_set_map[right_bucket[i]] = left_equivalence_set;
412: 				// add the node to the left bucket
413: 				left_bucket.push_back(right_bucket[i]);
414: 			}
415: 			// now add all constant values from the right bucket to the left bucket
416: 			assert(constant_values.find(left_equivalence_set) != constant_values.end());
417: 			assert(constant_values.find(right_equivalence_set) != constant_values.end());
418: 			auto &left_constant_bucket = constant_values.find(left_equivalence_set)->second;
419: 			auto &right_constant_bucket = constant_values.find(right_equivalence_set)->second;
420: 			for (idx_t i = 0; i < right_constant_bucket.size(); i++) {
421: 				if (AddConstantComparison(left_constant_bucket, right_constant_bucket[i]) ==
422: 				    FilterResult::UNSATISFIABLE) {
423: 					return FilterResult::UNSATISFIABLE;
424: 				}
425: 			}
426: 		}
427: 		return FilterResult::SUCCESS;
428: 	}
429: 	// only comparisons supported for now
430: 	return FilterResult::UNSUPPORTED;
431: }
432: 
433: static bool IsGreaterThan(ExpressionType type) {
434: 	return type == ExpressionType::COMPARE_GREATERTHAN || type == ExpressionType::COMPARE_GREATERTHANOREQUALTO;
435: }
436: 
437: static bool IsLessThan(ExpressionType type) {
438: 	return type == ExpressionType::COMPARE_LESSTHAN || type == ExpressionType::COMPARE_LESSTHANOREQUALTO;
439: }
440: 
441: ValueComparisonResult InvertValueComparisonResult(ValueComparisonResult result) {
442: 	if (result == ValueComparisonResult::PRUNE_RIGHT) {
443: 		return ValueComparisonResult::PRUNE_LEFT;
444: 	}
445: 	if (result == ValueComparisonResult::PRUNE_LEFT) {
446: 		return ValueComparisonResult::PRUNE_RIGHT;
447: 	}
448: 	return result;
449: }
450: 
451: ValueComparisonResult CompareValueInformation(ExpressionValueInformation &left, ExpressionValueInformation &right) {
452: 	if (left.comparison_type == ExpressionType::COMPARE_EQUAL) {
453: 		// left is COMPARE_EQUAL, we can either
454: 		// (1) prune the right side or
455: 		// (2) return UNSATISFIABLE
456: 		bool prune_right_side = false;
457: 		switch (right.comparison_type) {
458: 		case ExpressionType::COMPARE_LESSTHAN:
459: 			prune_right_side = left.constant < right.constant;
460: 			break;
461: 		case ExpressionType::COMPARE_LESSTHANOREQUALTO:
462: 			prune_right_side = left.constant <= right.constant;
463: 			break;
464: 		case ExpressionType::COMPARE_GREATERTHAN:
465: 			prune_right_side = left.constant > right.constant;
466: 			break;
467: 		case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
468: 			prune_right_side = left.constant >= right.constant;
469: 			break;
470: 		case ExpressionType::COMPARE_NOTEQUAL:
471: 			prune_right_side = left.constant != right.constant;
472: 			break;
473: 		default:
474: 			assert(right.comparison_type == ExpressionType::COMPARE_EQUAL);
475: 			prune_right_side = left.constant == right.constant;
476: 			break;
477: 		}
478: 		if (prune_right_side) {
479: 			return ValueComparisonResult::PRUNE_RIGHT;
480: 		} else {
481: 			return ValueComparisonResult::UNSATISFIABLE_CONDITION;
482: 		}
483: 	} else if (right.comparison_type == ExpressionType::COMPARE_EQUAL) {
484: 		// right is COMPARE_EQUAL
485: 		return InvertValueComparisonResult(CompareValueInformation(right, left));
486: 	} else if (left.comparison_type == ExpressionType::COMPARE_NOTEQUAL) {
487: 		// left is COMPARE_NOTEQUAL, we can either
488: 		// (1) prune the left side or
489: 		// (2) not prune anything
490: 		bool prune_left_side = false;
491: 		switch (right.comparison_type) {
492: 		case ExpressionType::COMPARE_LESSTHAN:
493: 			prune_left_side = left.constant >= right.constant;
494: 			break;
495: 		case ExpressionType::COMPARE_LESSTHANOREQUALTO:
496: 			prune_left_side = left.constant > right.constant;
497: 			break;
498: 		case ExpressionType::COMPARE_GREATERTHAN:
499: 			prune_left_side = left.constant <= right.constant;
500: 			break;
501: 		case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
502: 			prune_left_side = left.constant < right.constant;
503: 			break;
504: 		default:
505: 			assert(right.comparison_type == ExpressionType::COMPARE_NOTEQUAL);
506: 			prune_left_side = left.constant == right.constant;
507: 			break;
508: 		}
509: 		if (prune_left_side) {
510: 			return ValueComparisonResult::PRUNE_LEFT;
511: 		} else {
512: 			return ValueComparisonResult::PRUNE_NOTHING;
513: 		}
514: 	} else if (right.comparison_type == ExpressionType::COMPARE_NOTEQUAL) {
515: 		return InvertValueComparisonResult(CompareValueInformation(right, left));
516: 	} else if (IsGreaterThan(left.comparison_type) && IsGreaterThan(right.comparison_type)) {
517: 		// both comparisons are [>], we can either
518: 		// (1) prune the left side or
519: 		// (2) prune the right side
520: 		if (left.constant > right.constant) {
521: 			// left constant is more selective, prune right
522: 			return ValueComparisonResult::PRUNE_RIGHT;
523: 		} else if (left.constant < right.constant) {
524: 			// right constant is more selective, prune left
525: 			return ValueComparisonResult::PRUNE_LEFT;
526: 		} else {
527: 			// constants are equivalent
528: 			// however we can still have the scenario where one is [>=] and the other is [>]
529: 			// we want to prune the [>=] because [>] is more selective
530: 			// if left is [>=] we prune the left, else we prune the right
531: 			if (left.comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO) {
532: 				return ValueComparisonResult::PRUNE_LEFT;
533: 			} else {
534: 				return ValueComparisonResult::PRUNE_RIGHT;
535: 			}
536: 		}
537: 	} else if (IsLessThan(left.comparison_type) && IsLessThan(right.comparison_type)) {
538: 		// both comparisons are [<], we can either
539: 		// (1) prune the left side or
540: 		// (2) prune the right side
541: 		if (left.constant < right.constant) {
542: 			// left constant is more selective, prune right
543: 			return ValueComparisonResult::PRUNE_RIGHT;
544: 		} else if (left.constant > right.constant) {
545: 			// right constant is more selective, prune left
546: 			return ValueComparisonResult::PRUNE_LEFT;
547: 		} else {
548: 			// constants are equivalent
549: 			// however we can still have the scenario where one is [<=] and the other is [<]
550: 			// we want to prune the [<=] because [<] is more selective
551: 			// if left is [<=] we prune the left, else we prune the right
552: 			if (left.comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO) {
553: 				return ValueComparisonResult::PRUNE_LEFT;
554: 			} else {
555: 				return ValueComparisonResult::PRUNE_RIGHT;
556: 			}
557: 		}
558: 	} else if (IsLessThan(left.comparison_type)) {
559: 		assert(IsGreaterThan(right.comparison_type));
560: 		// left is [<] and right is [>], in this case we can either
561: 		// (1) prune nothing or
562: 		// (2) return UNSATISFIABLE
563: 		// the SMALLER THAN constant has to be greater than the BIGGER THAN constant
564: 		if (left.constant >= right.constant) {
565: 			return ValueComparisonResult::PRUNE_NOTHING;
566: 		} else {
567: 			return ValueComparisonResult::UNSATISFIABLE_CONDITION;
568: 		}
569: 	} else {
570: 		// left is [>] and right is [<] or [!=]
571: 		assert(IsLessThan(right.comparison_type) && IsGreaterThan(left.comparison_type));
572: 		return InvertValueComparisonResult(CompareValueInformation(right, left));
573: 	}
574: }
575: 
576: } // namespace duckdb
[end of src/optimizer/filter_combiner.cpp]
[start of src/optimizer/index_scan.cpp]
1: #include "duckdb/optimizer/index_scan.hpp"
2: #include "duckdb/optimizer/matcher/expression_matcher.hpp"
3: 
4: #include "duckdb/parser/expression/comparison_expression.hpp"
5: 
6: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
7: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
8: #include "duckdb/planner/expression/bound_constant_expression.hpp"
9: #include "duckdb/planner/expression_iterator.hpp"
10: #include "duckdb/planner/operator/logical_filter.hpp"
11: #include "duckdb/planner/operator/logical_get.hpp"
12: #include "duckdb/planner/operator/logical_index_scan.hpp"
13: 
14: #include "duckdb/storage/data_table.hpp"
15: namespace duckdb {
16: using namespace std;
17: 
18: unique_ptr<LogicalOperator> IndexScan::Optimize(unique_ptr<LogicalOperator> op) {
19: 	if (op->type == LogicalOperatorType::FILTER && op->children[0]->type == LogicalOperatorType::GET) {
20: 		return TransformFilterToIndexScan(move(op));
21: 	}
22: 	for (auto &child : op->children) {
23: 		child = Optimize(move(child));
24: 	}
25: 	return op;
26: }
27: 
28: static void RewriteIndexExpression(Index &index, LogicalGet &get, Expression &expr, bool &rewrite_possible) {
29: 	if (expr.type == ExpressionType::BOUND_COLUMN_REF) {
30: 		auto &bound_colref = (BoundColumnRefExpression &)expr;
31: 		// bound column ref: rewrite to fit in the current set of bound column ids
32: 		bound_colref.binding.table_index = get.table_index;
33: 		column_t referenced_column = index.column_ids[bound_colref.binding.column_index];
34: 		// search for the referenced column in the set of column_ids
35: 		for (idx_t i = 0; i < get.column_ids.size(); i++) {
36: 			if (get.column_ids[i] == referenced_column) {
37: 				bound_colref.binding.column_index = i;
38: 				return;
39: 			}
40: 		}
41: 		// column id not found in bound columns in the LogicalGet: rewrite not possible
42: 		rewrite_possible = false;
43: 	}
44: 	ExpressionIterator::EnumerateChildren(
45: 	    expr, [&](Expression &child) { RewriteIndexExpression(index, get, child, rewrite_possible); });
46: }
47: 
48: unique_ptr<LogicalOperator> IndexScan::TransformFilterToIndexScan(unique_ptr<LogicalOperator> op) {
49: 	assert(op->type == LogicalOperatorType::FILTER);
50: 	auto &filter = (LogicalFilter &)*op;
51: 	auto get = (LogicalGet *)op->children[0].get();
52: 
53: 	if (!get->table) {
54: 		return op;
55: 	}
56: 
57: 	auto &storage = *get->table->storage;
58: 
59: 	if (storage.info->indexes.size() == 0) {
60: 		// no indexes on the table, can't rewrite
61: 		return op;
62: 	}
63: 
64: 	// check all the indexes
65: 	for (size_t j = 0; j < storage.info->indexes.size(); j++) {
66: 		auto &index = storage.info->indexes[j];
67: 
68: 		//		assert(index->unbound_expressions.size() == 1);
69: 		// first rewrite the index expression so the ColumnBindings align with the column bindings of the current table
70: 		if (index->unbound_expressions.size() > 1)
71: 			continue;
72: 		auto index_expression = index->unbound_expressions[0]->Copy();
73: 		bool rewrite_possible = true;
74: 		RewriteIndexExpression(*index, *get, *index_expression, rewrite_possible);
75: 		if (!rewrite_possible) {
76: 			// could not rewrite!
77: 			continue;
78: 		}
79: 
80: 		Value low_value, high_value, equal_value;
81: 		// try to find a matching index for any of the filter expressions
82: 		auto expr = filter.expressions[0].get();
83: 		auto low_comparison_type = expr->type;
84: 		auto high_comparison_type = expr->type;
85: 		for (idx_t i = 0; i < filter.expressions.size(); i++) {
86: 			expr = filter.expressions[i].get();
87: 			// create a matcher for a comparison with a constant
88: 			ComparisonExpressionMatcher matcher;
89: 			// match on a comparison type
90: 			matcher.expr_type = make_unique<ComparisonExpressionTypeMatcher>();
91: 			// match on a constant comparison with the indexed expression
92: 			matcher.matchers.push_back(make_unique<ExpressionEqualityMatcher>(index_expression.get()));
93: 			matcher.matchers.push_back(make_unique<ConstantExpressionMatcher>());
94: 
95: 			matcher.policy = SetMatcher::Policy::UNORDERED;
96: 
97: 			vector<Expression *> bindings;
98: 			if (matcher.Match(expr, bindings)) {
99: 				// range or equality comparison with constant value
100: 				// we can use our index here
101: 				// bindings[0] = the expression
102: 				// bindings[1] = the index expression
103: 				// bindings[2] = the constant
104: 				auto comparison = (BoundComparisonExpression *)bindings[0];
105: 				assert(bindings[0]->GetExpressionClass() == ExpressionClass::BOUND_COMPARISON);
106: 				assert(bindings[2]->type == ExpressionType::VALUE_CONSTANT);
107: 
108: 				auto constant_value = ((BoundConstantExpression *)bindings[2])->value;
109: 				auto comparison_type = comparison->type;
110: 				if (comparison->left->type == ExpressionType::VALUE_CONSTANT) {
111: 					// the expression is on the right side, we flip them around
112: 					comparison_type = FlipComparisionExpression(comparison_type);
113: 				}
114: 				if (comparison_type == ExpressionType::COMPARE_EQUAL) {
115: 					// equality value
116: 					// equality overrides any other bounds so we just break here
117: 					equal_value = constant_value;
118: 					break;
119: 				} else if (comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO ||
120: 				           comparison_type == ExpressionType::COMPARE_GREATERTHAN) {
121: 					// greater than means this is a lower bound
122: 					low_value = constant_value;
123: 					low_comparison_type = comparison_type;
124: 				} else {
125: 					// smaller than means this is an upper bound
126: 					high_value = constant_value;
127: 					high_comparison_type = comparison_type;
128: 				}
129: 			}
130: 		}
131: 		if (!equal_value.is_null || !low_value.is_null || !high_value.is_null) {
132: 			auto logical_index_scan = make_unique<LogicalIndexScan>(*get->table, *get->table->storage, *index,
133: 			                                                        get->column_ids, get->table_index);
134: 			if (!equal_value.is_null) {
135: 				logical_index_scan->equal_value = equal_value;
136: 				logical_index_scan->equal_index = true;
137: 			}
138: 			if (!low_value.is_null) {
139: 				logical_index_scan->low_value = low_value;
140: 				logical_index_scan->low_index = true;
141: 				logical_index_scan->low_expression_type = low_comparison_type;
142: 			}
143: 			if (!high_value.is_null) {
144: 				logical_index_scan->high_value = high_value;
145: 				logical_index_scan->high_index = true;
146: 				logical_index_scan->high_expression_type = high_comparison_type;
147: 			}
148: 			op->children[0] = move(logical_index_scan);
149: 			break;
150: 		}
151: 	}
152: 	return op;
153: }
154: 
155: } // namespace duckdb
[end of src/optimizer/index_scan.cpp]
[start of src/optimizer/join_order_optimizer.cpp]
1: #include "duckdb/optimizer/join_order_optimizer.hpp"
2: 
3: #include "duckdb/planner/expression/list.hpp"
4: #include "duckdb/planner/expression_iterator.hpp"
5: #include "duckdb/planner/operator/list.hpp"
6: 
7: #include <algorithm>
8: 
9: namespace duckdb {
10: using namespace std;
11: 
12: using JoinNode = JoinOrderOptimizer::JoinNode;
13: 
14: //! Returns true if A and B are disjoint, false otherwise
15: template <class T> static bool Disjoint(unordered_set<T> &a, unordered_set<T> &b) {
16: 	for (auto &entry : a) {
17: 		if (b.find(entry) != b.end()) {
18: 			return false;
19: 		}
20: 	}
21: 	return true;
22: }
23: 
24: //! Extract the set of relations referred to inside an expression
25: bool JoinOrderOptimizer::ExtractBindings(Expression &expression, unordered_set<idx_t> &bindings) {
26: 	if (expression.type == ExpressionType::BOUND_COLUMN_REF) {
27: 		auto &colref = (BoundColumnRefExpression &)expression;
28: 		assert(colref.depth == 0);
29: 		assert(colref.binding.table_index != INVALID_INDEX);
30: 		// map the base table index to the relation index used by the JoinOrderOptimizer
31: 		assert(relation_mapping.find(colref.binding.table_index) != relation_mapping.end());
32: 		bindings.insert(relation_mapping[colref.binding.table_index]);
33: 	}
34: 	if (expression.type == ExpressionType::BOUND_REF) {
35: 		// bound expression
36: 		bindings.clear();
37: 		return false;
38: 	}
39: 	assert(expression.type != ExpressionType::SUBQUERY);
40: 	bool can_reorder = true;
41: 	ExpressionIterator::EnumerateChildren(expression, [&](Expression &expr) {
42: 		if (!ExtractBindings(expr, bindings)) {
43: 			can_reorder = false;
44: 			return;
45: 		}
46: 	});
47: 	return can_reorder;
48: }
49: 
50: static unique_ptr<LogicalOperator> PushFilter(unique_ptr<LogicalOperator> node, unique_ptr<Expression> expr) {
51: 	// push an expression into a filter
52: 	// first check if we have any filter to push it into
53: 	if (node->type != LogicalOperatorType::FILTER) {
54: 		// we don't, we need to create one
55: 		auto filter = make_unique<LogicalFilter>();
56: 		filter->children.push_back(move(node));
57: 		node = move(filter);
58: 	}
59: 	// push the filter into the LogicalFilter
60: 	assert(node->type == LogicalOperatorType::FILTER);
61: 	auto filter = (LogicalFilter *)node.get();
62: 	filter->expressions.push_back(move(expr));
63: 	return node;
64: }
65: 
66: bool JoinOrderOptimizer::ExtractJoinRelations(LogicalOperator &input_op, vector<LogicalOperator *> &filter_operators,
67:                                               LogicalOperator *parent) {
68: 	LogicalOperator *op = &input_op;
69: 	while (op->children.size() == 1 &&
70: 	       (op->type != LogicalOperatorType::PROJECTION && op->type != LogicalOperatorType::EXPRESSION_GET)) {
71: 		if (op->type == LogicalOperatorType::FILTER) {
72: 			// extract join conditions from filter
73: 			filter_operators.push_back(op);
74: 		}
75: 		if (op->type == LogicalOperatorType::AGGREGATE_AND_GROUP_BY || op->type == LogicalOperatorType::WINDOW) {
76: 			// don't push filters through projection or aggregate and group by
77: 			JoinOrderOptimizer optimizer;
78: 			op->children[0] = optimizer.Optimize(move(op->children[0]));
79: 			return false;
80: 		}
81: 		op = op->children[0].get();
82: 	}
83: 	bool non_reorderable_operation = false;
84: 	if (op->type == LogicalOperatorType::UNION || op->type == LogicalOperatorType::EXCEPT ||
85: 	    op->type == LogicalOperatorType::INTERSECT || op->type == LogicalOperatorType::DELIM_JOIN ||
86: 	    op->type == LogicalOperatorType::ANY_JOIN) {
87: 		// set operation, optimize separately in children
88: 		non_reorderable_operation = true;
89: 	}
90: 
91: 	if (op->type == LogicalOperatorType::COMPARISON_JOIN) {
92: 		LogicalJoin *join = (LogicalJoin *)op;
93: 		if (join->join_type == JoinType::INNER) {
94: 			// extract join conditions from inner join
95: 			filter_operators.push_back(op);
96: 		} else {
97: 			// non-inner join, not reordarable yet
98: 			non_reorderable_operation = true;
99: 		}
100: 	}
101: 	if (non_reorderable_operation) {
102: 		// we encountered a non-reordable operation (setop or non-inner join)
103: 		// we do not reorder non-inner joins yet, however we do want to expand the potential join graph around them
104: 		// non-inner joins are also tricky because we can't freely make conditions through them
105: 		// e.g. suppose we have (left LEFT OUTER JOIN right WHERE right IS NOT NULL), the join can generate
106: 		// new NULL values in the right side, so pushing this condition through the join leads to incorrect results
107: 		// for this reason, we just start a new JoinOptimizer pass in each of the children of the join
108: 		for (idx_t i = 0; i < op->children.size(); i++) {
109: 			JoinOrderOptimizer optimizer;
110: 			op->children[i] = optimizer.Optimize(move(op->children[i]));
111: 		}
112: 		// after this we want to treat this node as one  "end node" (like e.g. a base relation)
113: 		// however the join refers to multiple base relations
114: 		// enumerate all base relations obtained from this join and add them to the relation mapping
115: 		// also, we have to resolve the join conditions for the joins here
116: 		// get the left and right bindings
117: 		unordered_set<idx_t> bindings;
118: 		LogicalJoin::GetTableReferences(*op, bindings);
119: 		// now create the relation that refers to all these bindings
120: 		auto relation = make_unique<SingleJoinRelation>(&input_op, parent);
121: 		for (idx_t it : bindings) {
122: 			relation_mapping[it] = relations.size();
123: 		}
124: 		relations.push_back(move(relation));
125: 		return true;
126: 	}
127: 	if (op->type == LogicalOperatorType::COMPARISON_JOIN || op->type == LogicalOperatorType::CROSS_PRODUCT) {
128: 		// inner join or cross product
129: 		bool can_reorder_left = ExtractJoinRelations(*op->children[0], filter_operators, op);
130: 		bool can_reorder_right = ExtractJoinRelations(*op->children[1], filter_operators, op);
131: 		return can_reorder_left && can_reorder_right;
132: 	} else if (op->type == LogicalOperatorType::GET) {
133: 		// base table scan, add to set of relations
134: 		auto get = (LogicalGet *)op;
135: 		auto relation = make_unique<SingleJoinRelation>(&input_op, parent);
136: 		relation_mapping[get->table_index] = relations.size();
137: 		relations.push_back(move(relation));
138: 		return true;
139: 	} else if (op->type == LogicalOperatorType::EXPRESSION_GET) {
140: 		// base table scan, add to set of relations
141: 		auto get = (LogicalExpressionGet *)op;
142: 		auto relation = make_unique<SingleJoinRelation>(&input_op, parent);
143: 		relation_mapping[get->table_index] = relations.size();
144: 		relations.push_back(move(relation));
145: 		return true;
146: 	} else if (op->type == LogicalOperatorType::TABLE_FUNCTION) {
147: 		// table function call, add to set of relations
148: 		auto table_function = (LogicalTableFunction *)op;
149: 		auto relation = make_unique<SingleJoinRelation>(&input_op, parent);
150: 		relation_mapping[table_function->table_index] = relations.size();
151: 		relations.push_back(move(relation));
152: 		return true;
153: 	} else if (op->type == LogicalOperatorType::PROJECTION) {
154: 		auto proj = (LogicalProjection *)op;
155: 		// we run the join order optimizer witin the subquery as well
156: 		JoinOrderOptimizer optimizer;
157: 		op->children[0] = optimizer.Optimize(move(op->children[0]));
158: 		// projection, add to the set of relations
159: 		auto relation = make_unique<SingleJoinRelation>(&input_op, parent);
160: 		relation_mapping[proj->table_index] = relations.size();
161: 		relations.push_back(move(relation));
162: 		return true;
163: 	}
164: 	return false;
165: }
166: 
167: //! Update the exclusion set with all entries in the subgraph
168: static void UpdateExclusionSet(JoinRelationSet *node, unordered_set<idx_t> &exclusion_set) {
169: 	for (idx_t i = 0; i < node->count; i++) {
170: 		exclusion_set.insert(node->relations[i]);
171: 	}
172: }
173: 
174: //! Create a new JoinTree node by joining together two previous JoinTree nodes
175: static unique_ptr<JoinNode> CreateJoinTree(JoinRelationSet *set, NeighborInfo *info, JoinNode *left, JoinNode *right) {
176: 	// for the hash join we want the right side (build side) to have the smallest cardinality
177: 	// also just a heuristic but for now...
178: 	// FIXME: we should probably actually benchmark that as well
179: 	// FIXME: should consider different join algorithms, should we pick a join algorithm here as well? (probably)
180: 	if (left->cardinality < right->cardinality) {
181: 		return CreateJoinTree(set, info, right, left);
182: 	}
183: 	// the expected cardinality is the max of the child cardinalities
184: 	// FIXME: we should obviously use better cardinality estimation here
185: 	// but for now we just assume foreign key joins only
186: 	idx_t expected_cardinality;
187: 	if (info->filters.size() == 0) {
188: 		// cross product
189: 		expected_cardinality = left->cardinality * right->cardinality;
190: 	} else {
191: 		// normal join, expect foreign key join
192: 		expected_cardinality = MaxValue(left->cardinality, right->cardinality);
193: 	}
194: 	// cost is expected_cardinality plus the cost of the previous plans
195: 	idx_t cost = expected_cardinality;
196: 	return make_unique<JoinNode>(set, info, left, right, expected_cardinality, cost);
197: }
198: 
199: JoinNode *JoinOrderOptimizer::EmitPair(JoinRelationSet *left, JoinRelationSet *right, NeighborInfo *info) {
200: 	// get the left and right join plans
201: 	auto &left_plan = plans[left];
202: 	auto &right_plan = plans[right];
203: 	auto new_set = set_manager.Union(left, right);
204: 	// create the join tree based on combining the two plans
205: 	auto new_plan = CreateJoinTree(new_set, info, left_plan.get(), right_plan.get());
206: 	// check if this plan is the optimal plan we found for this set of relations
207: 	auto entry = plans.find(new_set);
208: 	if (entry == plans.end() || new_plan->cost < entry->second->cost) {
209: 		// the plan is the optimal plan, move it into the dynamic programming tree
210: 		auto result = new_plan.get();
211: 		plans[new_set] = move(new_plan);
212: 		return result;
213: 	}
214: 	return entry->second.get();
215: }
216: 
217: bool JoinOrderOptimizer::TryEmitPair(JoinRelationSet *left, JoinRelationSet *right, NeighborInfo *info) {
218: 	pairs++;
219: 	if (pairs >= 2000) {
220: 		// when the amount of pairs gets too large we exit the dynamic programming and resort to a greedy algorithm
221: 		// FIXME: simple heuristic currently
222: 		// at 10K pairs stop searching exactly and switch to heuristic
223: 		return false;
224: 	}
225: 	EmitPair(left, right, info);
226: 	return true;
227: }
228: 
229: bool JoinOrderOptimizer::EmitCSG(JoinRelationSet *node) {
230: 	// create the exclusion set as everything inside the subgraph AND anything with members BELOW it
231: 	unordered_set<idx_t> exclusion_set;
232: 	for (idx_t i = 0; i < node->relations[0]; i++) {
233: 		exclusion_set.insert(i);
234: 	}
235: 	UpdateExclusionSet(node, exclusion_set);
236: 	// find the neighbors given this exclusion set
237: 	auto neighbors = query_graph.GetNeighbors(node, exclusion_set);
238: 	if (neighbors.size() == 0) {
239: 		return true;
240: 	}
241: 	// we iterate over the neighbors ordered by their first node
242: 	sort(neighbors.begin(), neighbors.end());
243: 	for (auto neighbor : neighbors) {
244: 		// since the GetNeighbors only returns the smallest element in a list, the entry might not be connected to
245: 		// (only!) this neighbor,  hence we have to do a connectedness check before we can emit it
246: 		auto neighbor_relation = set_manager.GetJoinRelation(neighbor);
247: 		auto connection = query_graph.GetConnection(node, neighbor_relation);
248: 		if (connection) {
249: 			if (!TryEmitPair(node, neighbor_relation, connection)) {
250: 				return false;
251: 			}
252: 		}
253: 		if (!EnumerateCmpRecursive(node, neighbor_relation, exclusion_set)) {
254: 			return false;
255: 		}
256: 	}
257: 	return true;
258: }
259: 
260: bool JoinOrderOptimizer::EnumerateCmpRecursive(JoinRelationSet *left, JoinRelationSet *right,
261:                                                unordered_set<idx_t> exclusion_set) {
262: 	// get the neighbors of the second relation under the exclusion set
263: 	auto neighbors = query_graph.GetNeighbors(right, exclusion_set);
264: 	if (neighbors.size() == 0) {
265: 		return true;
266: 	}
267: 	vector<JoinRelationSet *> union_sets;
268: 	union_sets.resize(neighbors.size());
269: 	for (idx_t i = 0; i < neighbors.size(); i++) {
270: 		auto neighbor = set_manager.GetJoinRelation(neighbors[i]);
271: 		// emit the combinations of this node and its neighbors
272: 		auto combined_set = set_manager.Union(right, neighbor);
273: 		if (plans.find(combined_set) != plans.end()) {
274: 			auto connection = query_graph.GetConnection(left, combined_set);
275: 			if (connection) {
276: 				if (!TryEmitPair(left, combined_set, connection)) {
277: 					return false;
278: 				}
279: 			}
280: 		}
281: 		union_sets[i] = combined_set;
282: 	}
283: 	// recursively enumerate the sets
284: 	for (idx_t i = 0; i < neighbors.size(); i++) {
285: 		// updated the set of excluded entries with this neighbor
286: 		unordered_set<idx_t> new_exclusion_set = exclusion_set;
287: 		new_exclusion_set.insert(neighbors[i]);
288: 		if (!EnumerateCmpRecursive(left, union_sets[i], new_exclusion_set)) {
289: 			return false;
290: 		}
291: 	}
292: 	return true;
293: }
294: 
295: bool JoinOrderOptimizer::EnumerateCSGRecursive(JoinRelationSet *node, unordered_set<idx_t> &exclusion_set) {
296: 	// find neighbors of S under the exlusion set
297: 	auto neighbors = query_graph.GetNeighbors(node, exclusion_set);
298: 	if (neighbors.size() == 0) {
299: 		return true;
300: 	}
301: 	// now first emit the connected subgraphs of the neighbors
302: 	vector<JoinRelationSet *> union_sets;
303: 	union_sets.resize(neighbors.size());
304: 	for (idx_t i = 0; i < neighbors.size(); i++) {
305: 		auto neighbor = set_manager.GetJoinRelation(neighbors[i]);
306: 		// emit the combinations of this node and its neighbors
307: 		auto new_set = set_manager.Union(node, neighbor);
308: 		if (plans.find(new_set) != plans.end()) {
309: 			if (!EmitCSG(new_set)) {
310: 				return false;
311: 			}
312: 		}
313: 		union_sets[i] = new_set;
314: 	}
315: 	// recursively enumerate the sets
316: 	for (idx_t i = 0; i < neighbors.size(); i++) {
317: 		// updated the set of excluded entries with this neighbor
318: 		unordered_set<idx_t> new_exclusion_set = exclusion_set;
319: 		new_exclusion_set.insert(neighbors[i]);
320: 		if (!EnumerateCSGRecursive(union_sets[i], new_exclusion_set)) {
321: 			return false;
322: 		}
323: 	}
324: 	return true;
325: }
326: 
327: bool JoinOrderOptimizer::SolveJoinOrderExactly() {
328: 	// now we perform the actual dynamic programming to compute the final result
329: 	// we enumerate over all the possible pairs in the neighborhood
330: 	for (idx_t i = relations.size(); i > 0; i--) {
331: 		// for every node in the set, we consider it as the start node once
332: 		auto start_node = set_manager.GetJoinRelation(i - 1);
333: 		// emit the start node
334: 		if (!EmitCSG(start_node)) {
335: 			return false;
336: 		}
337: 		// initialize the set of exclusion_set as all the nodes with a number below this
338: 		unordered_set<idx_t> exclusion_set;
339: 		for (idx_t j = 0; j < i - 1; j++) {
340: 			exclusion_set.insert(j);
341: 		}
342: 		// then we recursively search for neighbors that do not belong to the banned entries
343: 		if (!EnumerateCSGRecursive(start_node, exclusion_set)) {
344: 			return false;
345: 		}
346: 	}
347: 	return true;
348: }
349: 
350: void JoinOrderOptimizer::SolveJoinOrderApproximately() {
351: 	// at this point, we exited the dynamic programming but did not compute the final join order because it took too
352: 	// long instead, we use a greedy heuristic to obtain a join ordering now we use Greedy Operator Ordering to
353: 	// construct the result tree first we start out with all the base relations (the to-be-joined relations)
354: 	vector<JoinRelationSet *> T;
355: 	for (idx_t i = 0; i < relations.size(); i++) {
356: 		T.push_back(set_manager.GetJoinRelation(i));
357: 	}
358: 	while (T.size() > 1) {
359: 		// now in every step of the algorithm, we greedily pick the join between the to-be-joined relations that has the
360: 		// smallest cost. This is O(r^2) per step, and every step will reduce the total amount of relations to-be-joined
361: 		// by 1, so the total cost is O(r^3) in the amount of relations
362: 		idx_t best_left = 0, best_right = 0;
363: 		JoinNode *best_connection = nullptr;
364: 		for (idx_t i = 0; i < T.size(); i++) {
365: 			auto left = T[i];
366: 			for (idx_t j = i + 1; j < T.size(); j++) {
367: 				auto right = T[j];
368: 				// check if we can connect these two relations
369: 				auto connection = query_graph.GetConnection(left, right);
370: 				if (connection) {
371: 					// we can! check the cost of this connection
372: 					auto node = EmitPair(left, right, connection);
373: 					if (!best_connection || node->cost < best_connection->cost) {
374: 						// best pair found so far
375: 						best_connection = node;
376: 						best_left = i;
377: 						best_right = j;
378: 					}
379: 				}
380: 			}
381: 		}
382: 		if (!best_connection) {
383: 			// could not find a connection, but we were not done with finding a completed plan
384: 			// we have to add a cross product; we add it between the two smallest relations
385: 			JoinNode *smallest_plans[2] = {nullptr};
386: 			idx_t smallest_index[2];
387: 			for (idx_t i = 0; i < T.size(); i++) {
388: 				// get the plan for this relation
389: 				auto current_plan = plans[T[i]].get();
390: 				// check if the cardinality is smaller than the smallest two found so far
391: 				for (idx_t j = 0; j < 2; j++) {
392: 					if (!smallest_plans[j] || smallest_plans[j]->cardinality > current_plan->cardinality) {
393: 						smallest_plans[j] = current_plan;
394: 						smallest_index[j] = i;
395: 						break;
396: 					}
397: 				}
398: 			}
399: 			assert(smallest_plans[0] && smallest_plans[1]);
400: 			assert(smallest_index[0] != smallest_index[1]);
401: 			auto left = smallest_plans[0]->set, right = smallest_plans[1]->set;
402: 			// create a cross product edge (i.e. edge with empty filter) between these two sets in the query graph
403: 			query_graph.CreateEdge(left, right, nullptr);
404: 			// now emit the pair and continue with the algorithm
405: 			auto connection = query_graph.GetConnection(left, right);
406: 			assert(connection);
407: 
408: 			best_connection = EmitPair(left, right, connection);
409: 			best_left = smallest_index[0];
410: 			best_right = smallest_index[1];
411: 			// the code below assumes best_right > best_left
412: 			if (best_left > best_right) {
413: 				swap(best_left, best_right);
414: 			}
415: 		}
416: 		// now update the to-be-checked pairs
417: 		// remove left and right, and add the combination
418: 
419: 		// important to erase the biggest element first
420: 		// if we erase the smallest element first the index of the biggest element changes
421: 		assert(best_right > best_left);
422: 		T.erase(T.begin() + best_right);
423: 		T.erase(T.begin() + best_left);
424: 		T.push_back(best_connection->set);
425: 	}
426: }
427: 
428: void JoinOrderOptimizer::SolveJoinOrder() {
429: 	// first try to solve the join order exactly
430: 	if (!SolveJoinOrderExactly()) {
431: 		// otherwise, if that times out we resort to a greedy algorithm
432: 		SolveJoinOrderApproximately();
433: 	}
434: }
435: 
436: void JoinOrderOptimizer::GenerateCrossProducts() {
437: 	// generate a set of cross products to combine the currently available plans into a full join plan
438: 	// we create edges between every relation with a high cost
439: 	for (idx_t i = 0; i < relations.size(); i++) {
440: 		auto left = set_manager.GetJoinRelation(i);
441: 		for (idx_t j = 0; j < relations.size(); j++) {
442: 			if (i != j) {
443: 				auto right = set_manager.GetJoinRelation(j);
444: 				query_graph.CreateEdge(left, right, nullptr);
445: 				query_graph.CreateEdge(right, left, nullptr);
446: 			}
447: 		}
448: 	}
449: }
450: 
451: static unique_ptr<LogicalOperator> ExtractJoinRelation(SingleJoinRelation &rel) {
452: 	auto &children = rel.parent->children;
453: 	for (idx_t i = 0; i < children.size(); i++) {
454: 		if (children[i].get() == rel.op) {
455: 			// found it! take ownership of it from the parent
456: 			auto result = move(children[i]);
457: 			children.erase(children.begin() + i);
458: 			return result;
459: 		}
460: 	}
461: 	throw Exception("Could not find relation in parent node (?)");
462: }
463: 
464: pair<JoinRelationSet *, unique_ptr<LogicalOperator>>
465: JoinOrderOptimizer::GenerateJoins(vector<unique_ptr<LogicalOperator>> &extracted_relations, JoinNode *node) {
466: 	JoinRelationSet *left_node = nullptr, *right_node = nullptr;
467: 	JoinRelationSet *result_relation;
468: 	unique_ptr<LogicalOperator> result_operator;
469: 	if (node->left && node->right) {
470: 		// generate the left and right children
471: 		auto left = GenerateJoins(extracted_relations, node->left);
472: 		auto right = GenerateJoins(extracted_relations, node->right);
473: 
474: 		if (node->info->filters.size() == 0) {
475: 			// no filters, create a cross product
476: 			auto join = make_unique<LogicalCrossProduct>();
477: 			join->children.push_back(move(left.second));
478: 			join->children.push_back(move(right.second));
479: 			result_operator = move(join);
480: 		} else {
481: 			// we have filters, create a join node
482: 			auto join = make_unique<LogicalComparisonJoin>(JoinType::INNER);
483: 			join->children.push_back(move(left.second));
484: 			join->children.push_back(move(right.second));
485: 			// set the join conditions from the join node
486: 			for (auto &f : node->info->filters) {
487: 				// extract the filter from the operator it originally belonged to
488: 				assert(filters[f->filter_index]);
489: 				auto condition = move(filters[f->filter_index]);
490: 				// now create the actual join condition
491: 				assert((JoinRelationSet::IsSubset(left.first, f->left_set) &&
492: 				        JoinRelationSet::IsSubset(right.first, f->right_set)) ||
493: 				       (JoinRelationSet::IsSubset(left.first, f->right_set) &&
494: 				        JoinRelationSet::IsSubset(right.first, f->left_set)));
495: 				JoinCondition cond;
496: 				assert(condition->GetExpressionClass() == ExpressionClass::BOUND_COMPARISON);
497: 				auto &comparison = (BoundComparisonExpression &)*condition;
498: 				// we need to figure out which side is which by looking at the relations available to us
499: 				bool invert = JoinRelationSet::IsSubset(left.first, f->left_set) ? false : true;
500: 				cond.left = !invert ? move(comparison.left) : move(comparison.right);
501: 				cond.right = !invert ? move(comparison.right) : move(comparison.left);
502: 				cond.comparison = condition->type;
503: 				if (invert) {
504: 					// reverse comparison expression if we reverse the order of the children
505: 					cond.comparison = FlipComparisionExpression(cond.comparison);
506: 				}
507: 				join->conditions.push_back(move(cond));
508: 			}
509: 			assert(join->conditions.size() > 0);
510: 			result_operator = move(join);
511: 		}
512: 		left_node = left.first;
513: 		right_node = right.first;
514: 		result_relation = set_manager.Union(left_node, right_node);
515: 	} else {
516: 		// base node, get the entry from the list of extracted relations
517: 		assert(node->set->count == 1);
518: 		assert(extracted_relations[node->set->relations[0]]);
519: 		result_relation = node->set;
520: 		result_operator = move(extracted_relations[node->set->relations[0]]);
521: 	}
522: 	// check if we should do a pushdown on this node
523: 	// basically, any remaining filter that is a subset of the current relation will no longer be used in joins
524: 	// hence we should push it here
525: 	for (idx_t i = 0; i < filter_infos.size(); i++) {
526: 		// check if the filter has already been extracted
527: 		auto info = filter_infos[i].get();
528: 		if (filters[info->filter_index]) {
529: 			// now check if the filter is a subset of the current relation
530: 			// note that infos with an empty relation set are a special case and we do not push them down
531: 			if (info->set->count > 0 && JoinRelationSet::IsSubset(result_relation, info->set)) {
532: 				auto filter = move(filters[info->filter_index]);
533: 				// if it is, we can push the filter
534: 				// we can push it either into a join or as a filter
535: 				// check if we are in a join or in a base table
536: 				if (!left_node || !info->left_set) {
537: 					// base table or non-comparison expression, push it as a filter
538: 					result_operator = PushFilter(move(result_operator), move(filter));
539: 					continue;
540: 				}
541: 				// the node below us is a join or cross product and the expression is a comparison
542: 				// check if the nodes can be split up into left/right
543: 				bool found_subset = false;
544: 				bool invert = false;
545: 				if (JoinRelationSet::IsSubset(left_node, info->left_set) &&
546: 				    JoinRelationSet::IsSubset(right_node, info->right_set)) {
547: 					found_subset = true;
548: 				} else if (JoinRelationSet::IsSubset(right_node, info->left_set) &&
549: 				           JoinRelationSet::IsSubset(left_node, info->right_set)) {
550: 					invert = true;
551: 					found_subset = true;
552: 				}
553: 				if (!found_subset) {
554: 					// could not be split up into left/right
555: 					result_operator = PushFilter(move(result_operator), move(filter));
556: 					continue;
557: 				}
558: 				// create the join condition
559: 				JoinCondition cond;
560: 				assert(filter->GetExpressionClass() == ExpressionClass::BOUND_COMPARISON);
561: 				auto &comparison = (BoundComparisonExpression &)*filter;
562: 				// we need to figure out which side is which by looking at the relations available to us
563: 				cond.left = !invert ? move(comparison.left) : move(comparison.right);
564: 				cond.right = !invert ? move(comparison.right) : move(comparison.left);
565: 				cond.comparison = comparison.type;
566: 				if (invert) {
567: 					// reverse comparison expression if we reverse the order of the children
568: 					cond.comparison = FlipComparisionExpression(comparison.type);
569: 				}
570: 				// now find the join to push it into
571: 				auto node = result_operator.get();
572: 				if (node->type == LogicalOperatorType::FILTER) {
573: 					node = node->children[0].get();
574: 				}
575: 				if (node->type == LogicalOperatorType::CROSS_PRODUCT) {
576: 					// turn into comparison join
577: 					auto comp_join = make_unique<LogicalComparisonJoin>(JoinType::INNER);
578: 					comp_join->children.push_back(move(node->children[0]));
579: 					comp_join->children.push_back(move(node->children[1]));
580: 					comp_join->conditions.push_back(move(cond));
581: 					if (node == result_operator.get()) {
582: 						result_operator = move(comp_join);
583: 					} else {
584: 						assert(result_operator->type == LogicalOperatorType::FILTER);
585: 						result_operator->children[0] = move(comp_join);
586: 					}
587: 				} else {
588: 					assert(node->type == LogicalOperatorType::COMPARISON_JOIN);
589: 					auto &comp_join = (LogicalComparisonJoin &)*node;
590: 					comp_join.conditions.push_back(move(cond));
591: 				}
592: 			}
593: 		}
594: 	}
595: 	return make_pair(result_relation, move(result_operator));
596: }
597: 
598: unique_ptr<LogicalOperator> JoinOrderOptimizer::RewritePlan(unique_ptr<LogicalOperator> plan, JoinNode *node) {
599: 	// now we have to rewrite the plan
600: 	bool root_is_join = plan->children.size() > 1;
601: 
602: 	// first we will extract all relations from the main plan
603: 	vector<unique_ptr<LogicalOperator>> extracted_relations;
604: 	for (idx_t i = 0; i < relations.size(); i++) {
605: 		extracted_relations.push_back(ExtractJoinRelation(*relations[i]));
606: 	}
607: 	// now we generate the actual joins
608: 	auto join_tree = GenerateJoins(extracted_relations, node);
609: 	// perform the final pushdown of remaining filters
610: 	for (idx_t i = 0; i < filters.size(); i++) {
611: 		// check if the filter has already been extracted
612: 		if (filters[i]) {
613: 			// if not we need to push it
614: 			join_tree.second = PushFilter(move(join_tree.second), move(filters[i]));
615: 		}
616: 	}
617: 
618: 	// find the first join in the relation to know where to place this node
619: 	if (root_is_join) {
620: 		// first node is the join, return it immediately
621: 		return move(join_tree.second);
622: 	}
623: 	assert(plan->children.size() == 1);
624: 	// have to move up through the relations
625: 	auto op = plan.get();
626: 	auto parent = plan.get();
627: 	while (op->type != LogicalOperatorType::CROSS_PRODUCT && op->type != LogicalOperatorType::COMPARISON_JOIN) {
628: 		assert(op->children.size() == 1);
629: 		parent = op;
630: 		op = op->children[0].get();
631: 	}
632: 	// have to replace at this node
633: 	parent->children[0] = move(join_tree.second);
634: 	return plan;
635: }
636: 
637: // the join ordering is pretty much a straight implementation of the paper "Dynamic Programming Strikes Back" by Guido
638: // Moerkotte and Thomas Neumannn, see that paper for additional info/documentation bonus slides:
639: // https://db.in.tum.de/teaching/ws1415/queryopt/chapter3.pdf?lang=de
640: // FIXME: incorporate cardinality estimation into the plans, possibly by pushing samples?
641: unique_ptr<LogicalOperator> JoinOrderOptimizer::Optimize(unique_ptr<LogicalOperator> plan) {
642: 	assert(filters.size() == 0 && relations.size() == 0); // assert that the JoinOrderOptimizer has not been used before
643: 	LogicalOperator *op = plan.get();
644: 	// now we optimize the current plan
645: 	// we skip past until we find the first projection, we do this because the HAVING clause inserts a Filter AFTER the
646: 	// group by and this filter cannot be reordered
647: 	// extract a list of all relations that have to be joined together
648: 	// and a list of all conditions that is applied to them
649: 	vector<LogicalOperator *> filter_operators;
650: 	if (!ExtractJoinRelations(*op, filter_operators)) {
651: 		// do not support reordering this type of plan
652: 		return plan;
653: 	}
654: 	if (relations.size() <= 1) {
655: 		// at most one relation, nothing to reorder
656: 		return plan;
657: 	}
658: 	// now that we know we are going to perform join ordering we actually extract the filters, eliminating duplicate
659: 	// filters in the process
660: 	expression_set_t filter_set;
661: 	for (auto &op : filter_operators) {
662: 		if (op->type == LogicalOperatorType::COMPARISON_JOIN) {
663: 			auto &join = (LogicalComparisonJoin &)*op;
664: 			assert(join.join_type == JoinType::INNER);
665: 			assert(join.expressions.size() == 0);
666: 			for (auto &cond : join.conditions) {
667: 				auto comparison =
668: 				    make_unique<BoundComparisonExpression>(cond.comparison, move(cond.left), move(cond.right));
669: 				if (filter_set.find(comparison.get()) == filter_set.end()) {
670: 					filter_set.insert(comparison.get());
671: 					filters.push_back(move(comparison));
672: 				}
673: 			}
674: 			join.conditions.clear();
675: 		} else {
676: 			for (idx_t i = 0; i < op->expressions.size(); i++) {
677: 				if (filter_set.find(op->expressions[i].get()) == filter_set.end()) {
678: 					filter_set.insert(op->expressions[i].get());
679: 					filters.push_back(move(op->expressions[i]));
680: 				}
681: 			}
682: 			op->expressions.clear();
683: 		}
684: 	}
685: 	// create potential edges from the comparisons
686: 	for (idx_t i = 0; i < filters.size(); i++) {
687: 		auto &filter = filters[i];
688: 		auto info = make_unique<FilterInfo>();
689: 		auto filter_info = info.get();
690: 		filter_infos.push_back(move(info));
691: 		// first extract the relation set for the entire filter
692: 		unordered_set<idx_t> bindings;
693: 		ExtractBindings(*filter, bindings);
694: 		filter_info->set = set_manager.GetJoinRelation(bindings);
695: 		filter_info->filter_index = i;
696: 		// now check if it can be used as a join predicate
697: 		if (filter->GetExpressionClass() == ExpressionClass::BOUND_COMPARISON) {
698: 			auto comparison = (BoundComparisonExpression *)filter.get();
699: 			// extract the bindings that are required for the left and right side of the comparison
700: 			unordered_set<idx_t> left_bindings, right_bindings;
701: 			ExtractBindings(*comparison->left, left_bindings);
702: 			ExtractBindings(*comparison->right, right_bindings);
703: 			if (left_bindings.size() > 0 && right_bindings.size() > 0) {
704: 				// both the left and the right side have bindings
705: 				// first create the relation sets, if they do not exist
706: 				filter_info->left_set = set_manager.GetJoinRelation(left_bindings);
707: 				filter_info->right_set = set_manager.GetJoinRelation(right_bindings);
708: 				// we can only create a meaningful edge if the sets are not exactly the same
709: 				if (filter_info->left_set != filter_info->right_set) {
710: 					// check if the sets are disjoint
711: 					if (Disjoint(left_bindings, right_bindings)) {
712: 						// they are disjoint, we only need to create one set of edges in the join graph
713: 						query_graph.CreateEdge(filter_info->left_set, filter_info->right_set, filter_info);
714: 						query_graph.CreateEdge(filter_info->right_set, filter_info->left_set, filter_info);
715: 					} else {
716: 						continue;
717: 						// the sets are not disjoint, we create two sets of edges
718: 						// auto left_difference = set_manager.Difference(filter_info->left_set, filter_info->right_set);
719: 						// auto right_difference = set_manager.Difference(filter_info->right_set,
720: 						// filter_info->left_set);
721: 						// // -> LEFT <-> RIGHT \ LEFT
722: 						// query_graph.CreateEdge(filter_info->left_set, right_difference, filter_info);
723: 						// query_graph.CreateEdge(right_difference, filter_info->left_set, filter_info);
724: 						// // -> RIGHT <-> LEFT \ RIGHT
725: 						// query_graph.CreateEdge(left_difference, filter_info->right_set, filter_info);
726: 						// query_graph.CreateEdge(filter_info->right_set, left_difference, filter_info);
727: 					}
728: 					continue;
729: 				}
730: 			}
731: 		}
732: 	}
733: 	// now use dynamic programming to figure out the optimal join order
734: 	// First we initialize each of the single-node plans with themselves and with their cardinalities these are the leaf
735: 	// nodes of the join tree NOTE: we can just use pointers to JoinRelationSet* here because the GetJoinRelation
736: 	// function ensures that a unique combination of relations will have a unique JoinRelationSet object.
737: 	for (idx_t i = 0; i < relations.size(); i++) {
738: 		auto &rel = *relations[i];
739: 		auto node = set_manager.GetJoinRelation(i);
740: 		plans[node] = make_unique<JoinNode>(node, rel.op->EstimateCardinality());
741: 	}
742: 	// now we perform the actual dynamic programming to compute the final result
743: 	SolveJoinOrder();
744: 	// now the optimal join path should have been found
745: 	// get it from the node
746: 	unordered_set<idx_t> bindings;
747: 	for (idx_t i = 0; i < relations.size(); i++) {
748: 		bindings.insert(i);
749: 	}
750: 	auto total_relation = set_manager.GetJoinRelation(bindings);
751: 	auto final_plan = plans.find(total_relation);
752: 	if (final_plan == plans.end()) {
753: 		// could not find the final plan
754: 		// this should only happen in case the sets are actually disjunct
755: 		// in this case we need to generate cross product to connect the disjoint sets
756: 		GenerateCrossProducts();
757: 		//! solve the join order again
758: 		SolveJoinOrder();
759: 		// now we can obtain the final plan!
760: 		final_plan = plans.find(total_relation);
761: 		assert(final_plan != plans.end());
762: 	}
763: 	// now perform the actual reordering
764: 	return RewritePlan(move(plan), final_plan->second.get());
765: }
766: 
767: } // namespace duckdb
[end of src/optimizer/join_order_optimizer.cpp]
[start of src/optimizer/optimizer.cpp]
1: #include "duckdb/optimizer/optimizer.hpp"
2: 
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/main/client_context.hpp"
5: #include "duckdb/optimizer/column_lifetime_optimizer.hpp"
6: #include "duckdb/optimizer/cse_optimizer.hpp"
7: #include "duckdb/optimizer/expression_heuristics.hpp"
8: #include "duckdb/optimizer/filter_pushdown.hpp"
9: #include "duckdb/optimizer/in_clause_rewriter.hpp"
10: #include "duckdb/optimizer/index_scan.hpp"
11: #include "duckdb/optimizer/join_order_optimizer.hpp"
12: #include "duckdb/optimizer/regex_range_filter.hpp"
13: #include "duckdb/optimizer/remove_unused_columns.hpp"
14: #include "duckdb/optimizer/rule/list.hpp"
15: #include "duckdb/optimizer/topn_optimizer.hpp"
16: #include "duckdb/planner/binder.hpp"
17: 
18: namespace duckdb {
19: using namespace std;
20: 
21: Optimizer::Optimizer(Binder &binder, ClientContext &context) : context(context), binder(binder), rewriter(context) {
22: 	rewriter.rules.push_back(make_unique<ConstantFoldingRule>(rewriter));
23: 	rewriter.rules.push_back(make_unique<DistributivityRule>(rewriter));
24: 	rewriter.rules.push_back(make_unique<ArithmeticSimplificationRule>(rewriter));
25: 	rewriter.rules.push_back(make_unique<CaseSimplificationRule>(rewriter));
26: 	rewriter.rules.push_back(make_unique<ConjunctionSimplificationRule>(rewriter));
27: 	rewriter.rules.push_back(make_unique<DatePartSimplificationRule>(rewriter));
28: 	rewriter.rules.push_back(make_unique<ComparisonSimplificationRule>(rewriter));
29: 	rewriter.rules.push_back(make_unique<MoveConstantsRule>(rewriter));
30: 	rewriter.rules.push_back(make_unique<LikeOptimizationRule>(rewriter));
31: 	rewriter.rules.push_back(make_unique<EmptyNeedleRemovalRule>(rewriter));
32: 
33: #ifdef DEBUG
34: 	for (auto &rule : rewriter.rules) {
35: 		// root not defined in rule
36: 		assert(rule->root);
37: 	}
38: #endif
39: }
40: 
41: unique_ptr<LogicalOperator> Optimizer::Optimize(unique_ptr<LogicalOperator> plan) {
42: 	// first we perform expression rewrites using the ExpressionRewriter
43: 	// this does not change the logical plan structure, but only simplifies the expression trees
44: 	context.profiler.StartPhase("expression_rewriter");
45: 	rewriter.Apply(*plan);
46: 	context.profiler.EndPhase();
47: 
48: 	// perform filter pushdown
49: 	context.profiler.StartPhase("filter_pushdown");
50: 	FilterPushdown filter_pushdown(*this);
51: 	plan = filter_pushdown.Rewrite(move(plan));
52: 	context.profiler.EndPhase();
53: 
54: 	// check if filters match with existing indexes, if true transforms filters to index scans
55: 	context.profiler.StartPhase("index_scan");
56: 	IndexScan index_scan;
57: 	plan = index_scan.Optimize(move(plan));
58: 	context.profiler.EndPhase();
59: 
60: 	context.profiler.StartPhase("regex_range");
61: 	RegexRangeFilter regex_opt;
62: 	plan = regex_opt.Rewrite(move(plan));
63: 	context.profiler.EndPhase();
64: 
65: 	context.profiler.StartPhase("in_clause");
66: 	InClauseRewriter rewriter(*this);
67: 	plan = rewriter.Rewrite(move(plan));
68: 	context.profiler.EndPhase();
69: 
70: 	// then we perform the join ordering optimization
71: 	// this also rewrites cross products + filters into joins and performs filter pushdowns
72: 	context.profiler.StartPhase("join_order");
73: 	JoinOrderOptimizer optimizer;
74: 	plan = optimizer.Optimize(move(plan));
75: 	context.profiler.EndPhase();
76: 
77: 	// then we extract common subexpressions inside the different operators
78: 	// context.profiler.StartPhase("common_subexpressions");
79: 	// CommonSubExpressionOptimizer cse_optimizer;
80: 	// cse_optimizer.VisitOperator(*plan);
81: 	// context.profiler.EndPhase();
82: 
83: 	context.profiler.StartPhase("unused_columns");
84: 	RemoveUnusedColumns unused(context, true);
85: 	unused.VisitOperator(*plan);
86: 	context.profiler.EndPhase();
87: 
88: 	context.profiler.StartPhase("column_lifetime");
89: 	ColumnLifetimeAnalyzer column_lifetime(true);
90: 	column_lifetime.VisitOperator(*plan);
91: 	context.profiler.EndPhase();
92: 
93: 	// transform ORDER BY + LIMIT to TopN
94: 	context.profiler.StartPhase("top_n");
95: 	TopN topn;
96: 	plan = topn.Optimize(move(plan));
97: 	context.profiler.EndPhase();
98: 
99: 	// apply simple expression heuristics to get an initial reordering
100: 	context.profiler.StartPhase("reorder_filter_expressions");
101: 	ExpressionHeuristics expression_heuristics(*this);
102: 	plan = expression_heuristics.Rewrite(move(plan));
103: 	context.profiler.EndPhase();
104: 
105: 	return plan;
106: }
107: 
108: } // namespace duckdb
[end of src/optimizer/optimizer.cpp]
[start of src/optimizer/pushdown/pushdown_get.cpp]
1: #include "duckdb/optimizer/filter_pushdown.hpp"
2: #include "duckdb/planner/operator/logical_filter.hpp"
3: #include "duckdb/planner/operator/logical_get.hpp"
4: #include "duckdb/storage/data_table.hpp"
5: namespace duckdb {
6: using namespace std;
7: 
8: unique_ptr<LogicalOperator> FilterPushdown::PushdownGet(unique_ptr<LogicalOperator> op) {
9: 	assert(op->type == LogicalOperatorType::GET);
10: 	auto &get = (LogicalGet &)*op;
11: 	if (!get.tableFilters.empty()) {
12: 		if (!filters.empty()) {
13: 			//! We didn't managed to push down all filters to table scan
14: 			auto logicalFilter = make_unique<LogicalFilter>();
15: 			for (auto &f : filters) {
16: 				logicalFilter->expressions.push_back(move(f->filter));
17: 			}
18: 			logicalFilter->children.push_back(move(op));
19: 			return move(logicalFilter);
20: 		} else {
21: 			return op;
22: 		}
23: 	}
24: 	//! FIXME: We only need to skip if the index is in the column being filtered
25: 	if (!get.table || !get.table->storage->info->indexes.empty()) {
26: 		//! now push any existing filters
27: 		if (filters.empty()) {
28: 			//! no filters to push
29: 			return op;
30: 		}
31: 		auto filter = make_unique<LogicalFilter>();
32: 		for (auto &f : filters) {
33: 			filter->expressions.push_back(move(f->filter));
34: 		}
35: 		filter->children.push_back(move(op));
36: 		return move(filter);
37: 	}
38: 	PushFilters();
39: 
40: 	vector<unique_ptr<Filter>> filtersToPushDown;
41: 	get.tableFilters = combiner.GenerateTableScanFilters(
42: 	    [&](unique_ptr<Expression> filter) {
43: 		    auto f = make_unique<Filter>();
44: 		    f->filter = move(filter);
45: 		    f->ExtractBindings();
46: 		    filtersToPushDown.push_back(move(f));
47: 	    },
48: 	    get.column_ids);
49: 	for (auto &f : get.tableFilters) {
50: 		f.column_index = get.column_ids[f.column_index];
51: 	}
52: 
53: 	GenerateFilters();
54: 	for (auto &f : filtersToPushDown) {
55: 		get.expressions.push_back(move(f->filter));
56: 	}
57: 
58: 	if (!filters.empty()) {
59: 		//! We didn't managed to push down all filters to table scan
60: 		auto logicalFilter = make_unique<LogicalFilter>();
61: 		for (auto &f : filters) {
62: 			logicalFilter->expressions.push_back(move(f->filter));
63: 		}
64: 		logicalFilter->children.push_back(move(op));
65: 		return move(logicalFilter);
66: 	}
67: 	return op;
68: }
69: 
70: } // namespace duckdb
[end of src/optimizer/pushdown/pushdown_get.cpp]
[start of src/optimizer/remove_unused_columns.cpp]
1: #include <map>
2: 
3: #include "duckdb/optimizer/remove_unused_columns.hpp"
4: 
5: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
6: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
7: #include "duckdb/planner/expression/bound_constant_expression.hpp"
8: 
9: #include "duckdb/planner/operator/logical_aggregate.hpp"
10: #include "duckdb/planner/operator/logical_comparison_join.hpp"
11: #include "duckdb/planner/operator/logical_filter.hpp"
12: #include "duckdb/planner/operator/logical_get.hpp"
13: #include "duckdb/planner/operator/logical_table_function.hpp"
14: #include "duckdb/planner/operator/logical_projection.hpp"
15: #include "duckdb/planner/column_binding_map.hpp"
16: 
17: #include "duckdb/function/aggregate/distributive_functions.hpp"
18: 
19: #include "duckdb/planner/expression_iterator.hpp"
20: 
21: namespace duckdb {
22: using namespace std;
23: 
24: void RemoveUnusedColumns::ReplaceBinding(ColumnBinding current_binding, ColumnBinding new_binding) {
25: 	auto colrefs = column_references.find(current_binding);
26: 	if (colrefs != column_references.end()) {
27: 		for (auto &colref : colrefs->second) {
28: 			assert(colref->binding == current_binding);
29: 			colref->binding = new_binding;
30: 		}
31: 	}
32: }
33: 
34: template <class T> void RemoveUnusedColumns::ClearUnusedExpressions(vector<T> &list, idx_t table_idx) {
35: 	idx_t offset = 0;
36: 	for (idx_t col_idx = 0; col_idx < list.size(); col_idx++) {
37: 		auto current_binding = ColumnBinding(table_idx, col_idx + offset);
38: 		auto entry = column_references.find(current_binding);
39: 		if (entry == column_references.end()) {
40: 			// this entry is not referred to, erase it from the set of expressions
41: 			list.erase(list.begin() + col_idx);
42: 			offset++;
43: 			col_idx--;
44: 		} else if (offset > 0) {
45: 			// column is used but the ColumnBinding has changed because of removed columns
46: 			ReplaceBinding(current_binding, ColumnBinding(table_idx, col_idx));
47: 		}
48: 	}
49: }
50: 
51: void RemoveUnusedColumns::VisitOperator(LogicalOperator &op) {
52: 	switch (op.type) {
53: 	case LogicalOperatorType::AGGREGATE_AND_GROUP_BY: {
54: 		// aggregate
55: 		if (!everything_referenced) {
56: 			// FIXME: groups that are not referenced need to stay -> but they don't need to be scanned and output!
57: 			auto &aggr = (LogicalAggregate &)op;
58: 			ClearUnusedExpressions(aggr.expressions, aggr.aggregate_index);
59: 
60: 			if (aggr.expressions.size() == 0 && aggr.groups.size() == 0) {
61: 				// removed all expressions from the aggregate: push a COUNT(*)
62: 				auto count_star_fun = CountStarFun::GetFunction();
63: 				aggr.expressions.push_back(
64: 				    AggregateFunction::BindAggregateFunction(context, count_star_fun, {}, false));
65: 			}
66: 		}
67: 
68: 		// then recurse into the children of the aggregate
69: 		RemoveUnusedColumns remove(context);
70: 		remove.VisitOperatorExpressions(op);
71: 		remove.VisitOperator(*op.children[0]);
72: 		return;
73: 	}
74: 	case LogicalOperatorType::DELIM_JOIN:
75: 	case LogicalOperatorType::COMPARISON_JOIN: {
76: 		if (!everything_referenced) {
77: 			auto &comp_join = (LogicalComparisonJoin &)op;
78: 
79: 			if (comp_join.join_type != JoinType::INNER) {
80: 				break;
81: 			}
82: 			// for inner joins with equality predicates in the form of (X=Y)
83: 			// we can replace any references to the RHS (Y) to references to the LHS (X)
84: 			// this reduces the amount of columns we need to extract from the join hash table
85: 			for (auto &cond : comp_join.conditions) {
86: 				if (cond.comparison == ExpressionType::COMPARE_EQUAL) {
87: 					if (cond.left->expression_class == ExpressionClass::BOUND_COLUMN_REF &&
88: 					    cond.right->expression_class == ExpressionClass::BOUND_COLUMN_REF) {
89: 						// comparison join between two bound column refs
90: 						// we can replace any reference to the RHS (build-side) with a reference to the LHS (probe-side)
91: 						auto &lhs_col = (BoundColumnRefExpression &)*cond.left;
92: 						auto &rhs_col = (BoundColumnRefExpression &)*cond.right;
93: 						// if there are any columns that refer to the RHS,
94: 						auto colrefs = column_references.find(rhs_col.binding);
95: 						if (colrefs != column_references.end()) {
96: 							for (auto &entry : colrefs->second) {
97: 								entry->binding = lhs_col.binding;
98: 								column_references[lhs_col.binding].push_back(entry);
99: 							}
100: 							column_references.erase(rhs_col.binding);
101: 						}
102: 					}
103: 				}
104: 			}
105: 		}
106: 		break;
107: 	}
108: 	case LogicalOperatorType::ANY_JOIN:
109: 		break;
110: 	case LogicalOperatorType::UNION:
111: 	case LogicalOperatorType::EXCEPT:
112: 	case LogicalOperatorType::INTERSECT:
113: 		// for set operations we don't remove anything, just recursively visit the children
114: 		// FIXME: for UNION we can remove unreferenced columns as long as everything_referenced is false (i.e. we
115: 		// encounter a UNION node that is not preceded by a DISTINCT)
116: 		for (auto &child : op.children) {
117: 			RemoveUnusedColumns remove(context, true);
118: 			remove.VisitOperator(*child);
119: 		}
120: 		return;
121: 	case LogicalOperatorType::PROJECTION: {
122: 		if (!everything_referenced) {
123: 			auto &proj = (LogicalProjection &)op;
124: 			ClearUnusedExpressions(proj.expressions, proj.table_index);
125: 
126: 			if (proj.expressions.size() == 0) {
127: 				// nothing references the projected expressions
128: 				// this happens in the case of e.g. EXISTS(SELECT * FROM ...)
129: 				// in this case we only need to project a single constant
130: 				proj.expressions.push_back(make_unique<BoundConstantExpression>(Value::INTEGER(42)));
131: 			}
132: 		}
133: 		// then recurse into the children of this projection
134: 		RemoveUnusedColumns remove(context);
135: 		remove.VisitOperatorExpressions(op);
136: 		remove.VisitOperator(*op.children[0]);
137: 		return;
138: 	}
139: 	case LogicalOperatorType::GET:
140: 		LogicalOperatorVisitor::VisitOperatorExpressions(op);
141: 		if (!everything_referenced) {
142: 			auto &get = (LogicalGet &)op;
143: 			// table scan: figure out which columns are referenced
144: 			ClearUnusedExpressions(get.column_ids, get.table_index);
145: 
146: 			if (get.column_ids.size() == 0) {
147: 				// this generally means we are only interested in whether or not anything exists in the table (e.g.
148: 				// EXISTS(SELECT * FROM tbl)) in this case, we just scan the row identifier column as it means we do not
149: 				// need to read any of the columns
150: 				get.column_ids.push_back(COLUMN_IDENTIFIER_ROW_ID);
151: 			}
152: 		}
153: 		return;
154: 	case LogicalOperatorType::TABLE_FUNCTION: {
155: 		LogicalOperatorVisitor::VisitOperatorExpressions(op);
156: 		auto &fun = (LogicalTableFunction &)op;
157: 		if (!everything_referenced && fun.function.supports_projection) {
158: 			// table producing function: figure out which columns are referenced
159: 			ClearUnusedExpressions(fun.column_ids, fun.table_index);
160: 			// see above for this special case
161: 			if (fun.column_ids.size() == 0) {
162: 				fun.column_ids.push_back(COLUMN_IDENTIFIER_ROW_ID);
163: 			}
164: 		}
165: 		return;
166: 	}
167: 	case LogicalOperatorType::DISTINCT: {
168: 		// distinct, all projected columns are used for the DISTINCT computation
169: 		// mark all columns as used and continue to the children
170: 		// FIXME: DISTINCT with expression list does not implicitly reference everything
171: 		everything_referenced = true;
172: 		break;
173: 	}
174: 	case LogicalOperatorType::RECURSIVE_CTE: {
175: 		everything_referenced = true;
176: 		break;
177: 	}
178: 	case LogicalOperatorType::CTE_REF: {
179: 		everything_referenced = true;
180: 		break;
181: 	}
182: 	default:
183: 		break;
184: 	}
185: 	LogicalOperatorVisitor::VisitOperatorExpressions(op);
186: 	LogicalOperatorVisitor::VisitOperatorChildren(op);
187: }
188: 
189: unique_ptr<Expression> RemoveUnusedColumns::VisitReplace(BoundColumnRefExpression &expr,
190:                                                          unique_ptr<Expression> *expr_ptr) {
191: 	// add a column reference
192: 	column_references[expr.binding].push_back(&expr);
193: 	return nullptr;
194: }
195: 
196: unique_ptr<Expression> RemoveUnusedColumns::VisitReplace(BoundReferenceExpression &expr,
197:                                                          unique_ptr<Expression> *expr_ptr) {
198: 	// BoundReferenceExpression should not be used here yet, they only belong in the physical plan
199: 	throw InternalException("BoundReferenceExpression should not be used here yet!");
200: }
201: 
202: } // namespace duckdb
[end of src/optimizer/remove_unused_columns.cpp]
[start of src/parallel/pipeline.cpp]
1: #include "duckdb/parallel/pipeline.hpp"
2: 
3: #include "duckdb/common/printer.hpp"
4: #include "duckdb/execution/executor.hpp"
5: #include "duckdb/main/client_context.hpp"
6: #include "duckdb/parallel/task_context.hpp"
7: #include "duckdb/parallel/thread_context.hpp"
8: #include "duckdb/parallel/task_scheduler.hpp"
9: 
10: #include "duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp"
11: #include "duckdb/execution/operator/scan/physical_table_scan.hpp"
12: #include "duckdb/execution/operator/aggregate/physical_hash_aggregate.hpp"
13: 
14: using namespace std;
15: 
16: namespace duckdb {
17: 
18: class PipelineTask : public Task {
19: public:
20: 	PipelineTask(Pipeline *pipeline_) : pipeline(pipeline_) {
21: 	}
22: 
23: 	TaskContext task;
24: 	Pipeline *pipeline;
25: 
26: public:
27: 	void Execute() override {
28: 		pipeline->Execute(task);
29: 		pipeline->FinishTask();
30: 	}
31: };
32: 
33: Pipeline::Pipeline(Executor &executor_)
34:     : executor(executor_), finished_dependencies(0), finished(false), finished_tasks(0), total_tasks(0), recursive_cte(nullptr) {
35: }
36: 
37: void Pipeline::Execute(TaskContext &task) {
38: 	auto &client = executor.context;
39: 	if (client.interrupted) {
40: 		return;
41: 	}
42: 
43: 	ThreadContext thread(client);
44: 	ExecutionContext context(client, thread, task);
45: 	try {
46: 		auto state = child->GetOperatorState();
47: 		auto lstate = sink->GetLocalSinkState(context);
48: 		// incrementally process the pipeline
49: 		DataChunk intermediate;
50: 		child->InitializeChunk(intermediate);
51: 		while (true) {
52: 			child->GetChunk(context, intermediate, state.get());
53: 			thread.profiler.StartOperator(sink);
54: 			if (intermediate.size() == 0) {
55: 				sink->Combine(context, *sink_state, *lstate);
56: 				break;
57: 			}
58: 			sink->Sink(context, *sink_state, *lstate, intermediate);
59: 			thread.profiler.EndOperator(nullptr);
60: 		}
61: 	} catch (std::exception &ex) {
62: 		executor.PushError(ex.what());
63: 	} catch (...) {
64: 		executor.PushError("Unknown exception in pipeline!");
65: 	}
66: 	executor.Flush(thread);
67: }
68: 
69: void Pipeline::FinishTask() {
70: 	assert(finished_tasks < total_tasks);
71: 	idx_t current_finished = ++finished_tasks;
72: 	if (current_finished == total_tasks) {
73: 		try {
74: 			sink->Finalize(executor.context, move(sink_state));
75: 		} catch(std::exception &ex) {
76: 			executor.PushError(ex.what());
77: 		} catch (...) {
78: 			executor.PushError("Unknown exception in Finalize!");
79: 		}
80: 		Finish();
81: 	}
82: }
83: 
84: void Pipeline::ScheduleSequentialTask() {
85: 	auto &scheduler = TaskScheduler::GetScheduler(executor.context);
86: 	auto task = make_unique<PipelineTask>(this);
87: 
88: 	this->total_tasks = 1;
89: 	scheduler.ScheduleTask(*executor.producer, move(task));
90: }
91: 
92: bool Pipeline::ScheduleOperator(PhysicalOperator *op) {
93: 	switch (op->type) {
94: 	case PhysicalOperatorType::FILTER:
95: 	case PhysicalOperatorType::PROJECTION:
96: 	case PhysicalOperatorType::HASH_JOIN:
97: 		// filter, projection or hash probe: continue in children
98: 		return ScheduleOperator(op->children[0].get());
99: 	case PhysicalOperatorType::SEQ_SCAN: {
100: 		// we reached a scan: split it up into parts and schedule the parts
101: 		auto &scheduler = TaskScheduler::GetScheduler(executor.context);
102: 
103: 		// first we gather all of the tasks of this pipeline
104: 		// we gather the tasks first because we want to set total_tasks to the actual task amount
105: 		// otherwise we can encounter race conditions in which a pipeline could finish twice
106: 		vector<unique_ptr<OperatorTaskInfo>> tasks;
107: 		op->ParallelScanInfo(executor.context, [&](unique_ptr<OperatorTaskInfo> info) { tasks.push_back(move(info)); });
108: 		this->total_tasks = tasks.size();
109: 		if (this->total_tasks == 0) {
110: 			// could not generate parallel tasks, or parallel tasks were determined as not worthwhile
111: 			// move on to sequential execution
112: 			return false;
113: 		}
114: 		// after we have gathered all the tasks we actually schedule them for execution
115: 		for (auto &info : tasks) {
116: 			auto task = make_unique<PipelineTask>(this);
117: 			task->task.task_info[op] = move(info);
118: 			scheduler.ScheduleTask(*executor.producer, move(task));
119: 		}
120: 		return true;
121: 	}
122: 	case PhysicalOperatorType::HASH_GROUP_BY: {
123: 		// FIXME: parallelize scan of GROUP_BY HT
124: 		return false;
125: 	}
126: 	default:
127: 		// unknown operator: skip parallel task scheduling
128: 		return false;
129: 	}
130: }
131: 
132: void Pipeline::Reset(ClientContext &context) {
133: 	sink_state = sink->GetGlobalState(context);
134: 	finished_tasks = 0;
135: 	total_tasks = 1;
136: 	finished = false;
137: }
138: 
139: void Pipeline::Schedule() {
140: 	assert(finished_tasks == 0);
141: 	assert(total_tasks == 0);
142: 	assert(finished_dependencies == dependencies.size());
143: 	// check if we can parallelize this task based on the sink
144: 	switch (sink->type) {
145: 	case PhysicalOperatorType::SIMPLE_AGGREGATE: {
146: 		auto &simple_aggregate = (PhysicalSimpleAggregate &)*sink;
147: 		// simple aggregate: check if we can parallelize it
148: 		if (!simple_aggregate.all_combinable) {
149: 			// not all aggregates are parallelizable: switch to sequential mode
150: 			break;
151: 		}
152: 		if (ScheduleOperator(sink->children[0].get())) {
153: 			// all parallel tasks have been scheduled: return
154: 			return;
155: 		}
156: 		break;
157: 	}
158: 	case PhysicalOperatorType::HASH_GROUP_BY: {
159: 		auto &hash_aggr = (PhysicalHashAggregate &)*sink;
160: 		if (!hash_aggr.all_combinable) {
161: 			// not all aggregates are parallelizable: switch to sequential mode
162: 			break;
163: 		}
164: 		if (ScheduleOperator(sink->children[0].get())) {
165: 			// all parallel tasks have been scheduled: return
166: 			return;
167: 		}
168: 		break;
169: 	}
170: 	case PhysicalOperatorType::HASH_JOIN: {
171: 		// schedule build side of the join
172: 		if (ScheduleOperator(sink->children[1].get())) {
173: 			// all parallel tasks have been scheduled: return
174: 			return;
175: 		}
176: 		break;
177: 	}
178: 	default:
179: 		break;
180: 	}
181: 	// could not parallelize this pipeline: push a sequential task instead
182: 	ScheduleSequentialTask();
183: }
184: 
185: void Pipeline::AddDependency(Pipeline *pipeline) {
186: 	this->dependencies.insert(pipeline);
187: 	pipeline->parents.insert(this);
188: }
189: 
190: void Pipeline::CompleteDependency() {
191: 	idx_t current_finished = ++finished_dependencies;
192: 	if (current_finished == dependencies.size()) {
193: 		// all dependencies have been completed: schedule the pipeline
194: 		Schedule();
195: 	}
196: }
197: 
198: void Pipeline::Finish() {
199: 	assert(!finished);
200: 	finished = true;
201: 	// finished processing the pipeline, now we can schedule pipelines that depend on this pipeline
202: 	for (auto &parent : parents) {
203: 		// mark a dependency as completed for each of the parents
204: 		parent->CompleteDependency();
205: 	}
206: 	executor.completed_pipelines++;
207: }
208: 
209: string Pipeline::ToString() const {
210: 	string str = PhysicalOperatorToString(sink->type);
211: 	auto node = this->child;
212: 	while (node) {
213: 		str = PhysicalOperatorToString(node->type) + " -> " + str;
214: 		node = node->children[0].get();
215: 	}
216: 	return str;
217: }
218: 
219: void Pipeline::Print() const {
220: 	Printer::Print(ToString());
221: }
222: 
223: } // namespace duckdb
[end of src/parallel/pipeline.cpp]
[start of src/planner/bind_context.cpp]
1: #include "duckdb/planner/bind_context.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/tableref/subqueryref.hpp"
5: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
6: #include "duckdb/planner/bound_query_node.hpp"
7: 
8: #include "duckdb/common/string_util.hpp"
9: 
10: #include <algorithm>
11: 
12: namespace duckdb {
13: using namespace std;
14: 
15: string BindContext::GetMatchingBinding(const string &column_name) {
16: 	string result;
17: 	for (auto &kv : bindings) {
18: 		auto binding = kv.second.get();
19: 		if (binding->HasMatchingBinding(column_name)) {
20: 			// check if the binding is ignored
21: 			if (BindingIsHidden(kv.first, column_name)) {
22: 				continue;
23: 			}
24: 
25: 			if (!result.empty()) {
26: 				throw BinderException("Ambiguous reference to column name \"%s\" (use: \"%s.%s\" "
27: 				                      "or \"%s.%s\")",
28: 				                      column_name, result, column_name, kv.first, column_name);
29: 			}
30: 			result = kv.first;
31: 		}
32: 	}
33: 	return result;
34: }
35: 
36: bool BindContext::BindingIsHidden(const string &binding_name, const string &column_name) {
37: 	string total_binding = binding_name + "." + column_name;
38: 	return hidden_columns.find(total_binding) != hidden_columns.end();
39: }
40: 
41: unordered_set<string> BindContext::GetMatchingBindings(const string &column_name) {
42: 	unordered_set<string> result;
43: 	for (auto &kv : bindings) {
44: 		auto binding = kv.second.get();
45: 		if (binding->HasMatchingBinding(column_name)) {
46: 			result.insert(kv.first);
47: 		}
48: 	}
49: 	return result;
50: }
51: 
52: Binding *BindContext::GetCTEBinding(const string &ctename) {
53: 	auto match = cte_bindings.find(ctename);
54: 	if (match == cte_bindings.end()) {
55: 		return nullptr;
56: 	}
57: 	return match->second.get();
58: }
59: 
60: BindResult BindContext::BindColumn(ColumnRefExpression &colref, idx_t depth) {
61: 	if (colref.table_name.empty()) {
62: 		return BindResult(StringUtil::Format("Could not bind alias \"%s\"!", colref.column_name));
63: 	}
64: 
65: 	auto match = bindings.find(colref.table_name);
66: 	if (match == bindings.end()) {
67: 		// alias not found in this BindContext
68: 		return BindResult(StringUtil::Format("Referenced table \"%s\" not found!", colref.table_name));
69: 	}
70: 	auto binding = match->second.get();
71: 	return binding->Bind(colref, depth);
72: }
73: 
74: void BindContext::GenerateAllColumnExpressions(vector<unique_ptr<ParsedExpression>> &new_select_list,
75:                                                string relation_name) {
76: 	if (bindings_list.size() == 0) {
77: 		throw BinderException("SELECT * expression without FROM clause!");
78: 	}
79: 	if (relation_name == "") { // SELECT * case
80: 		// we have to bind the tables and subqueries in order of table_index
81: 		for (auto &entry : bindings_list) {
82: 			auto binding = entry.second;
83: 			binding->GenerateAllColumnExpressions(*this, new_select_list);
84: 		}
85: 	} else { // SELECT tbl.* case
86: 		auto match = bindings.find(relation_name);
87: 		if (match == bindings.end()) {
88: 			// alias not found in this BindContext
89: 			throw BinderException("SELECT table.* expression but can't find table");
90: 		}
91: 		auto binding = match->second.get();
92: 		binding->GenerateAllColumnExpressions(*this, new_select_list);
93: 	}
94: }
95: 
96: void BindContext::AddBinding(const string &alias, unique_ptr<Binding> binding) {
97: 	if (bindings.find(alias) != bindings.end()) {
98: 		throw BinderException("Duplicate alias \"%s\" in query!", alias);
99: 	}
100: 	bindings_list.push_back(make_pair(alias, binding.get()));
101: 	bindings[alias] = move(binding);
102: }
103: 
104: void BindContext::AddBaseTable(idx_t index, const string &alias, TableCatalogEntry &table, LogicalGet &get) {
105: 	AddBinding(alias, make_unique<TableBinding>(alias, table, get, index));
106: }
107: 
108: void BindContext::AddSubquery(idx_t index, const string &alias, SubqueryRef &ref, BoundQueryNode &subquery) {
109: 	vector<string> names;
110: 	if (ref.column_name_alias.size() > subquery.names.size()) {
111: 		throw BinderException("table \"%s\" has %lld columns available but %lld columns specified", alias,
112: 		                      subquery.names.size(), ref.column_name_alias.size());
113: 	}
114: 	// use any provided aliases from the subquery
115: 	for (idx_t i = 0; i < ref.column_name_alias.size(); i++) {
116: 		names.push_back(ref.column_name_alias[i]);
117: 	}
118: 	// if not enough aliases were provided, use the default names for remaining columns
119: 	for (idx_t i = ref.column_name_alias.size(); i < subquery.names.size(); i++) {
120: 		names.push_back(subquery.names[i]);
121: 	}
122: 	AddGenericBinding(index, alias, names, subquery.types);
123: }
124: 
125: void BindContext::AddGenericBinding(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types) {
126: 	AddBinding(alias, make_unique<GenericBinding>(alias, move(types), move(names), index));
127: }
128: 
129: void BindContext::AddCTEBinding(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types) {
130: 	auto binding = make_shared<GenericBinding>(alias, move(types), move(names), index);
131: 
132: 	if (cte_bindings.find(alias) != cte_bindings.end()) {
133: 		throw BinderException("Duplicate alias \"%s\" in query!", alias);
134: 	}
135: 	cte_bindings[alias] = move(binding);
136: 	cte_references[alias] = std::make_shared<idx_t>(0);
137: }
138: 
139: } // namespace duckdb
[end of src/planner/bind_context.cpp]
[start of src/planner/binder/statement/bind_call.cpp]
1: #include "duckdb/planner/binder.hpp"
2: #include "duckdb/parser/statement/call_statement.hpp"
3: #include "duckdb/parser/tableref/table_function_ref.hpp"
4: #include "duckdb/planner/tableref/bound_table_function.hpp"
5: 
6: namespace duckdb {
7: using namespace std;
8: 
9: BoundStatement Binder::Bind(CallStatement &stmt) {
10: 	BoundStatement result;
11: 
12: 	TableFunctionRef ref;
13: 	ref.function = move(stmt.function);
14: 
15: 	auto bound_func = Bind(ref);
16: 	auto &bound_table_func = (BoundTableFunction &)*bound_func;
17: 
18: 	result.types = bound_table_func.return_types;
19: 	result.names = bound_table_func.names;
20: 	result.plan = CreatePlan(*bound_func);
21: 	return result;
22: }
23: 
24: } // namespace duckdb
[end of src/planner/binder/statement/bind_call.cpp]
[start of src/planner/binder/statement/bind_create.cpp]
1: #include "duckdb/parser/statement/create_statement.hpp"
2: #include "duckdb/planner/operator/logical_create.hpp"
3: #include "duckdb/planner/operator/logical_create_table.hpp"
4: #include "duckdb/planner/operator/logical_create_index.hpp"
5: #include "duckdb/planner/operator/logical_get.hpp"
6: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
7: #include "duckdb/catalog/catalog.hpp"
8: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
9: #include "duckdb/planner/binder.hpp"
10: #include "duckdb/planner/expression_binder/index_binder.hpp"
11: #include "duckdb/parser/parsed_data/create_view_info.hpp"
12: #include "duckdb/parser/parsed_data/create_index_info.hpp"
13: #include "duckdb/planner/bound_query_node.hpp"
14: #include "duckdb/planner/tableref/bound_basetableref.hpp"
15: #include "duckdb/main/client_context.hpp"
16: 
17: namespace duckdb {
18: using namespace std;
19: 
20: SchemaCatalogEntry *Binder::BindSchema(CreateInfo &info) {
21: 	if (info.schema == INVALID_SCHEMA) {
22: 		info.schema = info.temporary ? TEMP_SCHEMA : DEFAULT_SCHEMA;
23: 	}
24: 
25: 	if (!info.temporary) {
26: 		// non-temporary create: not read only
27: 		if (info.schema == TEMP_SCHEMA) {
28: 			throw ParserException("Only TEMPORARY table names can use the \"temp\" schema");
29: 		}
30: 		this->read_only = false;
31: 	} else {
32: 		if (info.schema != TEMP_SCHEMA) {
33: 			throw ParserException("TEMPORARY table names can *only* use the \"%s\" schema", TEMP_SCHEMA);
34: 		}
35: 	}
36: 	// fetch the schema in which we want to create the object
37: 	auto schema_obj = Catalog::GetCatalog(context).GetSchema(context, info.schema);
38: 	assert(schema_obj->type == CatalogType::SCHEMA_ENTRY);
39: 	info.schema = schema_obj->name;
40: 	return schema_obj;
41: }
42: 
43: BoundStatement Binder::Bind(CreateStatement &stmt) {
44: 	BoundStatement result;
45: 	result.names = {"Count"};
46: 	result.types = {LogicalType::BIGINT};
47: 
48: 	auto catalog_type = stmt.info->type;
49: 	switch (catalog_type) {
50: 	case CatalogType::SCHEMA_ENTRY:
51: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::CREATE_SCHEMA, move(stmt.info));
52: 		break;
53: 	case CatalogType::VIEW_ENTRY: {
54: 		auto &base = (CreateViewInfo &)*stmt.info;
55: 		// extract the SQL from the query, if any
56: 		if (stmt.stmt_location + stmt.stmt_length <= context.query.size()) {
57: 			base.sql = context.query.substr(stmt.stmt_location, stmt.stmt_length);
58: 		}
59: 		// bind the schema
60: 		auto schema = BindSchema(*stmt.info);
61: 
62: 		// bind the view as if it were a query so we can catch errors
63: 		// note that we bind a copy and don't actually use the bind result
64: 		auto copy = base.query->Copy();
65: 		auto query_node = Bind(*copy);
66: 		if (base.aliases.size() > query_node.names.size()) {
67: 			throw BinderException("More VIEW aliases than columns in query result");
68: 		}
69: 		// fill up the aliases with the remaining names of the bound query
70: 		for (idx_t i = base.aliases.size(); i < query_node.names.size(); i++) {
71: 			base.aliases.push_back(query_node.names[i]);
72: 		}
73: 		base.types = query_node.types;
74: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::CREATE_VIEW, move(stmt.info), schema);
75: 		break;
76: 	}
77: 	case CatalogType::SEQUENCE_ENTRY: {
78: 		auto schema = BindSchema(*stmt.info);
79: 		result.plan = make_unique<LogicalCreate>(LogicalOperatorType::CREATE_SEQUENCE, move(stmt.info), schema);
80: 		break;
81: 	}
82: 	case CatalogType::INDEX_ENTRY: {
83: 		auto &base = (CreateIndexInfo &)*stmt.info;
84: 
85: 		// visit the table reference
86: 		auto bound_table = Bind(*base.table);
87: 		if (bound_table->type != TableReferenceType::BASE_TABLE) {
88: 			throw BinderException("Can only delete from base table!");
89: 		}
90: 		// bind the index expressions
91: 		vector<unique_ptr<Expression>> expressions;
92: 		IndexBinder binder(*this, context);
93: 		for (auto &expr : base.expressions) {
94: 			expressions.push_back(binder.Bind(expr));
95: 		}
96: 
97: 		auto plan = CreatePlan(*bound_table);
98: 		if (plan->type != LogicalOperatorType::GET) {
99: 			throw BinderException("Cannot create index on a view!");
100: 		}
101: 		auto &get = (LogicalGet &)*plan;
102: 		for (auto &column_id : get.column_ids) {
103: 			if (column_id == COLUMN_IDENTIFIER_ROW_ID) {
104: 				throw BinderException("Cannot create an index on the rowid!");
105: 			}
106: 		}
107: 		// this gives us a logical table scan
108: 		// we take the required columns from here
109: 		// create the logical operator
110: 		result.plan = make_unique<LogicalCreateIndex>(*get.table, get.column_ids, move(expressions),
111: 		                                              unique_ptr_cast<CreateInfo, CreateIndexInfo>(move(stmt.info)));
112: 		break;
113: 	}
114: 	case CatalogType::TABLE_ENTRY: {
115: 		auto bound_info = BindCreateTableInfo(move(stmt.info));
116: 		auto root = move(bound_info->query);
117: 
118: 		// create the logical operator
119: 		auto create_table = make_unique<LogicalCreateTable>(bound_info->schema, move(bound_info));
120: 		if (root) {
121: 			create_table->children.push_back(move(root));
122: 		}
123: 		result.plan = move(create_table);
124: 		return result;
125: 	}
126: 	default:
127: 		throw Exception("Unrecognized type!");
128: 	}
129: 	return result;
130: }
131: 
132: } // namespace duckdb
[end of src/planner/binder/statement/bind_create.cpp]
[start of src/planner/binder/statement/bind_delete.cpp]
1: #include "duckdb/parser/statement/delete_statement.hpp"
2: #include "duckdb/planner/binder.hpp"
3: #include "duckdb/planner/expression_binder/where_binder.hpp"
4: #include "duckdb/planner/operator/logical_delete.hpp"
5: #include "duckdb/planner/operator/logical_filter.hpp"
6: #include "duckdb/planner/operator/logical_get.hpp"
7: #include "duckdb/planner/bound_tableref.hpp"
8: 
9: namespace duckdb {
10: using namespace std;
11: 
12: BoundStatement Binder::Bind(DeleteStatement &stmt) {
13: 	BoundStatement result;
14: 
15: 	// visit the table reference
16: 	auto bound_table = Bind(*stmt.table);
17: 	if (bound_table->type != TableReferenceType::BASE_TABLE) {
18: 		throw BinderException("Can only delete from base table!");
19: 	}
20: 	auto root = CreatePlan(*bound_table);
21: 	auto &get = (LogicalGet &)*root;
22: 	assert(root->type == LogicalOperatorType::GET && get.table);
23: 
24: 	if (!get.table->temporary) {
25: 		// delete from persistent table: not read only!
26: 		this->read_only = false;
27: 	}
28: 	// project any additional columns required for the condition
29: 	unique_ptr<Expression> condition;
30: 	if (stmt.condition) {
31: 		WhereBinder binder(*this, context);
32: 		condition = binder.Bind(stmt.condition);
33: 
34: 		PlanSubqueries(&condition, &root);
35: 		auto filter = make_unique<LogicalFilter>(move(condition));
36: 		filter->AddChild(move(root));
37: 		root = move(filter);
38: 	}
39: 	// create the delete node
40: 	auto del = make_unique<LogicalDelete>(get.table);
41: 	del->AddChild(move(root));
42: 
43: 	// set up the delete expression
44: 	del->expressions.push_back(
45: 	    make_unique<BoundColumnRefExpression>(LOGICAL_ROW_TYPE, ColumnBinding(get.table_index, get.column_ids.size())));
46: 	get.column_ids.push_back(COLUMN_IDENTIFIER_ROW_ID);
47: 
48: 	result.plan = move(del);
49: 	result.names = {"Count"};
50: 	result.types = {LogicalType::BIGINT};
51: 	return result;
52: }
53: 
54: } // namespace duckdb
[end of src/planner/binder/statement/bind_delete.cpp]
[start of src/planner/binder/statement/bind_update.cpp]
1: #include "duckdb/parser/statement/update_statement.hpp"
2: #include "duckdb/planner/binder.hpp"
3: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
4: #include "duckdb/planner/expression/bound_default_expression.hpp"
5: #include "duckdb/planner/expression_binder/update_binder.hpp"
6: #include "duckdb/planner/expression_binder/where_binder.hpp"
7: #include "duckdb/planner/operator/logical_filter.hpp"
8: #include "duckdb/planner/operator/logical_get.hpp"
9: #include "duckdb/planner/operator/logical_projection.hpp"
10: #include "duckdb/planner/operator/logical_update.hpp"
11: #include "duckdb/planner/constraints/bound_check_constraint.hpp"
12: #include "duckdb/parser/expression/columnref_expression.hpp"
13: #include "duckdb/storage/data_table.hpp"
14: #include "duckdb/planner/bound_tableref.hpp"
15: 
16: #include <algorithm>
17: 
18: using namespace std;
19: 
20: namespace duckdb {
21: 
22: static void BindExtraColumns(TableCatalogEntry &table, LogicalGet &get, LogicalProjection &proj, LogicalUpdate &update,
23:                              unordered_set<column_t> &bound_columns) {
24: 	if (bound_columns.size() <= 1) {
25: 		return;
26: 	}
27: 	idx_t found_column_count = 0;
28: 	unordered_set<idx_t> found_columns;
29: 	for (idx_t i = 0; i < update.columns.size(); i++) {
30: 		if (bound_columns.find(update.columns[i]) != bound_columns.end()) {
31: 			// this column is referenced in the CHECK constraint
32: 			found_column_count++;
33: 			found_columns.insert(update.columns[i]);
34: 		}
35: 	}
36: 	if (found_column_count > 0 && found_column_count != bound_columns.size()) {
37: 		// columns in this CHECK constraint were referenced, but not all were part of the UPDATE
38: 		// add them to the scan and update set
39: 		for (auto &check_column_id : bound_columns) {
40: 			if (found_columns.find(check_column_id) != found_columns.end()) {
41: 				// column is already projected
42: 				continue;
43: 			}
44: 			// column is not projected yet: project it by adding the clause "i=i" to the set of updated columns
45: 			auto &column = table.columns[check_column_id];
46: 			// first add
47: 			update.expressions.push_back(make_unique<BoundColumnRefExpression>(
48: 			    column.type, ColumnBinding(proj.table_index, proj.expressions.size())));
49: 			proj.expressions.push_back(make_unique<BoundColumnRefExpression>(
50: 			    column.type, ColumnBinding(get.table_index, get.column_ids.size())));
51: 			get.column_ids.push_back(check_column_id);
52: 			update.columns.push_back(check_column_id);
53: 		}
54: 	}
55: }
56: 
57: static void BindUpdateConstraints(TableCatalogEntry &table, LogicalGet &get, LogicalProjection &proj,
58:                                   LogicalUpdate &update) {
59: 	// check the constraints and indexes of the table to see if we need to project any additional columns
60: 	// we do this for indexes with multiple columns and CHECK constraints in the UPDATE clause
61: 	// suppose we have a constraint CHECK(i + j < 10); now we need both i and j to check the constraint
62: 	// if we are only updating one of the two columns we add the other one to the UPDATE set
63: 	// with a "useless" update (i.e. i=i) so we can verify that the CHECK constraint is not violated
64: 	for (auto &constraint : table.bound_constraints) {
65: 		if (constraint->type == ConstraintType::CHECK) {
66: 			auto &check = *reinterpret_cast<BoundCheckConstraint *>(constraint.get());
67: 			// check constraint! check if we need to add any extra columns to the UPDATE clause
68: 			BindExtraColumns(table, get, proj, update, check.bound_columns);
69: 		}
70: 	}
71: 	// for index updates, we do the same, however, for index updates we always turn any update into an insert and a
72: 	// delete for the insert, we thus need all the columns to be available, hence we check if the update touches any
73: 	// index columns
74: 	update.is_index_update = false;
75: 	for (auto &index : table.storage->info->indexes) {
76: 		if (index->IndexIsUpdated(update.columns)) {
77: 			update.is_index_update = true;
78: 		}
79: 	}
80: 	if (update.is_index_update) {
81: 		// the update updates a column required by an index, push projections for all columns
82: 		unordered_set<column_t> all_columns;
83: 		for (idx_t i = 0; i < table.storage->types.size(); i++) {
84: 			all_columns.insert(i);
85: 		}
86: 		BindExtraColumns(table, get, proj, update, all_columns);
87: 	}
88: }
89: 
90: BoundStatement Binder::Bind(UpdateStatement &stmt) {
91: 	BoundStatement result;
92: 	// visit the table reference
93: 	auto bound_table = Bind(*stmt.table);
94: 	if (bound_table->type != TableReferenceType::BASE_TABLE) {
95: 		throw BinderException("Can only update base table!");
96: 	}
97: 	auto root = CreatePlan(*bound_table);
98: 	auto &get = (LogicalGet &)*root;
99: 	assert(root->type == LogicalOperatorType::GET && get.table);
100: 
101: 	auto &table = get.table;
102: 	if (!table->temporary) {
103: 		// update of persistent table: not read only!
104: 		this->read_only = false;
105: 	}
106: 	auto update = make_unique<LogicalUpdate>(table);
107: 	// bind the default values
108: 	BindDefaultValues(table->columns, update->bound_defaults);
109: 
110: 	// project any additional columns required for the condition/expressions
111: 	if (stmt.condition) {
112: 		WhereBinder binder(*this, context);
113: 		auto condition = binder.Bind(stmt.condition);
114: 
115: 		PlanSubqueries(&condition, &root);
116: 		auto filter = make_unique<LogicalFilter>(move(condition));
117: 		filter->AddChild(move(root));
118: 		root = move(filter);
119: 	}
120: 
121: 	assert(stmt.columns.size() == stmt.expressions.size());
122: 
123: 	auto proj_index = GenerateTableIndex();
124: 	vector<unique_ptr<Expression>> projection_expressions;
125: 	for (idx_t i = 0; i < stmt.columns.size(); i++) {
126: 		auto &colname = stmt.columns[i];
127: 		auto &expr = stmt.expressions[i];
128: 		if (!table->ColumnExists(colname)) {
129: 			throw BinderException("Referenced update column %s not found in table!", colname);
130: 		}
131: 		auto &column = table->GetColumn(colname);
132: 		if (std::find(update->columns.begin(), update->columns.end(), column.oid) != update->columns.end()) {
133: 			throw BinderException("Multiple assignments to same column \"%s\"", colname);
134: 		}
135: 		update->columns.push_back(column.oid);
136: 
137: 		if (expr->type == ExpressionType::VALUE_DEFAULT) {
138: 			update->expressions.push_back(make_unique<BoundDefaultExpression>(column.type));
139: 		} else {
140: 			UpdateBinder binder(*this, context);
141: 			binder.target_type = column.type;
142: 			auto bound_expr = binder.Bind(expr);
143: 			PlanSubqueries(&bound_expr, &root);
144: 
145: 			update->expressions.push_back(make_unique<BoundColumnRefExpression>(
146: 			    bound_expr->return_type, ColumnBinding(proj_index, projection_expressions.size())));
147: 			projection_expressions.push_back(move(bound_expr));
148: 		}
149: 	}
150: 	// now create the projection
151: 	auto proj = make_unique<LogicalProjection>(proj_index, move(projection_expressions));
152: 	proj->AddChild(move(root));
153: 
154: 	// bind any extra columns necessary for CHECK constraints or indexes
155: 	BindUpdateConstraints(*table, get, *proj, *update);
156: 
157: 	// finally add the row id column to the projection list
158: 	proj->expressions.push_back(
159: 	    make_unique<BoundColumnRefExpression>(LOGICAL_ROW_TYPE, ColumnBinding(get.table_index, get.column_ids.size())));
160: 	get.column_ids.push_back(COLUMN_IDENTIFIER_ROW_ID);
161: 
162: 	// set the projection as child of the update node and finalize the result
163: 	update->AddChild(move(proj));
164: 
165: 	result.names = {"Count"};
166: 	result.types = {LogicalType::BIGINT};
167: 	result.plan = move(update);
168: 	return result;
169: }
170: 
171: } // namespace duckdb
[end of src/planner/binder/statement/bind_update.cpp]
[start of src/planner/binder/tableref/bind_basetableref.cpp]
1: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
2: #include "duckdb/parser/tableref/basetableref.hpp"
3: #include "duckdb/parser/tableref/subqueryref.hpp"
4: #include "duckdb/planner/binder.hpp"
5: #include "duckdb/planner/tableref/bound_basetableref.hpp"
6: #include "duckdb/planner/tableref/bound_subqueryref.hpp"
7: #include "duckdb/planner/tableref/bound_cteref.hpp"
8: #include "duckdb/planner/operator/logical_get.hpp"
9: #include "duckdb/parser/statement/select_statement.hpp"
10: 
11: namespace duckdb {
12: using namespace std;
13: 
14: unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {
15: 	// CTEs and views are also referred to using BaseTableRefs, hence need to distinguish here
16: 	// check if the table name refers to a CTE
17: 	auto cte = FindCTE(ref.table_name);
18: 	if (cte) {
19: 		// Check if there is a CTE binding in the BindContext
20: 		auto ctebinding = bind_context.GetCTEBinding(ref.table_name);
21: 		if (!ctebinding) {
22: 			// Move CTE to subquery and bind recursively
23: 			SubqueryRef subquery(cte->query->Copy());
24: 			subquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;
25: 			subquery.column_name_alias = cte->aliases;
26: 			return Bind(subquery);
27: 		} else {
28: 			// There is a CTE binding in the BindContext.
29: 			// This can only be the case if there is a recursive CTE present.
30: 			auto index = GenerateTableIndex();
31: 			auto result = make_unique<BoundCTERef>(index, ctebinding->index);
32: 			auto b = (GenericBinding *)ctebinding;
33: 
34: 			bind_context.AddGenericBinding(index, ref.alias.empty() ? ref.table_name : ref.alias, b->names, b->types);
35: 			// Update references to CTE
36: 			auto cteref = bind_context.cte_references[ref.table_name];
37: 			(*cteref)++;
38: 
39: 			result->types = b->types;
40: 			result->bound_columns = b->names;
41: 			return move(result);
42: 		}
43: 	}
44: 	// not a CTE
45: 	// extract a table or view from the catalog
46: 	auto table_or_view =
47: 	    Catalog::GetCatalog(context).GetEntry(context, CatalogType::TABLE_ENTRY, ref.schema_name, ref.table_name);
48: 	switch (table_or_view->type) {
49: 	case CatalogType::TABLE_ENTRY: {
50: 		// base table: create the BoundBaseTableRef node
51: 		auto table_index = GenerateTableIndex();
52: 		auto table = (TableCatalogEntry *)table_or_view;
53: 
54: 		auto logical_get = make_unique<LogicalGet>(table, table_index);
55: 		auto alias = ref.alias.empty() ? ref.table_name : ref.alias;
56: 		bind_context.AddBaseTable(table_index, alias, *table, *logical_get);
57: 		return make_unique_base<BoundTableRef, BoundBaseTableRef>(move(logical_get));
58: 	}
59: 	case CatalogType::VIEW_ENTRY: {
60: 		// the node is a view: get the query that the view represents
61: 		auto view_catalog_entry = (ViewCatalogEntry *)table_or_view;
62: 		SubqueryRef subquery(view_catalog_entry->query->Copy());
63: 		subquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;
64: 		subquery.column_name_alias = view_catalog_entry->aliases;
65: 		// bind the child subquery
66: 		auto bound_child = Bind(subquery);
67: 		assert(bound_child->type == TableReferenceType::SUBQUERY);
68: 		// verify that the types and names match up with the expected types and names
69: 		auto &bound_subquery = (BoundSubqueryRef &)*bound_child;
70: 		if (bound_subquery.subquery->types != view_catalog_entry->types) {
71: 			throw BinderException("Contents of view were altered: types don't match!");
72: 		}
73: 		return bound_child;
74: 	}
75: 	default:
76: 		throw NotImplementedException("Catalog entry type");
77: 	}
78: }
79: } // namespace duckdb
[end of src/planner/binder/tableref/bind_basetableref.cpp]
[start of src/planner/binder/tableref/bind_table_function.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/parser/expression/function_expression.hpp"
3: #include "duckdb/parser/tableref/table_function_ref.hpp"
4: #include "duckdb/planner/binder.hpp"
5: #include "duckdb/parser/expression/columnref_expression.hpp"
6: #include "duckdb/parser/expression/comparison_expression.hpp"
7: #include "duckdb/planner/expression_binder/constant_binder.hpp"
8: #include "duckdb/planner/tableref/bound_table_function.hpp"
9: #include "duckdb/execution/expression_executor.hpp"
10: #include "duckdb/common/algorithm.hpp"
11: 
12: namespace duckdb {
13: using namespace std;
14: 
15: unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {
16: 	auto bind_index = GenerateTableIndex();
17: 
18: 	assert(ref.function->type == ExpressionType::FUNCTION);
19: 	auto fexpr = (FunctionExpression *)ref.function.get();
20: 
21: 	// evalate the input parameters to the function
22: 	vector<LogicalType> arguments;
23: 	vector<Value> parameters;
24: 	unordered_map<string, Value> named_parameters;
25: 	for (auto &child : fexpr->children) {
26: 		string parameter_name;
27: 
28: 		ConstantBinder binder(*this, context, "TABLE FUNCTION parameter");
29: 		if (child->type == ExpressionType::COMPARE_EQUAL) {
30: 			// comparison, check if the LHS is a columnref
31: 			auto &comp = (ComparisonExpression &)*child;
32: 			if (comp.left->type == ExpressionType::COLUMN_REF) {
33: 				auto &colref = (ColumnRefExpression &)*comp.left;
34: 				if (colref.table_name.empty()) {
35: 					parameter_name = colref.column_name;
36: 					child = move(comp.right);
37: 				}
38: 			}
39: 		}
40: 		LogicalType sql_type;
41: 		auto expr = binder.Bind(child, &sql_type);
42: 		if (!expr->IsFoldable()) {
43: 			throw BinderException("Named parameter requires a constant parameter");
44: 		}
45: 		auto constant = ExpressionExecutor::EvaluateScalar(*expr);
46: 		if (parameter_name.empty()) {
47: 			// unnamed parameter
48: 			if (named_parameters.size() > 0) {
49: 				throw BinderException("Unnamed parameters cannot come after named parameters");
50: 			}
51: 			arguments.push_back(sql_type);
52: 			parameters.push_back(move(constant));
53: 		} else {
54: 			named_parameters[parameter_name] = move(constant);
55: 		}
56: 	}
57: 	// fetch the function from the catalog
58: 	auto function =
59: 	    Catalog::GetCatalog(context).GetEntry<TableFunctionCatalogEntry>(context, fexpr->schema, fexpr->function_name);
60: 
61: 	// select the function based on the input parameters
62: 	idx_t best_function_idx = Function::BindFunction(function->name, function->functions, arguments);
63: 	auto &table_function = function->functions[best_function_idx];
64: 
65: 	// now check the named parameters
66: 	for (auto &kv : named_parameters) {
67: 		auto entry = table_function.named_parameters.find(kv.first);
68: 		if (entry == table_function.named_parameters.end()) {
69: 			throw BinderException("Invalid named parameter \"%s\" for function %s", kv.first, table_function.name);
70: 		}
71: 		kv.second = kv.second.CastAs(entry->second);
72: 	}
73: 
74: 	// cast the parameters to the type of the function
75: 	auto result = make_unique<BoundTableFunction>(table_function, bind_index);
76: 	for (idx_t i = 0; i < arguments.size(); i++) {
77: 		if (table_function.arguments[i] == LogicalType::ANY) {
78: 			result->parameters.push_back(move(parameters[i]));
79: 		} else {
80: 			result->parameters.push_back(parameters[i].CastAs(table_function.arguments[i]));
81: 		}
82: 	}
83: 
84: 	// perform the binding
85: 	result->bind_data =
86: 	    table_function.bind(context, result->parameters, named_parameters, result->return_types, result->names);
87: 	assert(result->return_types.size() == result->names.size());
88: 	assert(result->return_types.size() > 0);
89: 	vector<string> names = result->names;
90: 	for (idx_t i = 0; i < ref.column_name_alias.size() && i < result->names.size(); i++) {
91: 		names[i] = ref.column_name_alias[i];
92: 	}
93: 	// now add the table function to the bind context so its columns can be bound
94: 	bind_context.AddGenericBinding(bind_index, ref.alias.empty() ? fexpr->function_name : ref.alias, names,
95: 	                               result->return_types);
96: 
97: 	return move(result);
98: }
99: 
100: } // namespace duckdb
[end of src/planner/binder/tableref/bind_table_function.cpp]
[start of src/planner/binder/tableref/plan_dummytableref.cpp]
1: #include "duckdb/planner/binder.hpp"
2: #include "duckdb/planner/operator/logical_get.hpp"
3: #include "duckdb/planner/tableref/bound_dummytableref.hpp"
4: 
5: namespace duckdb {
6: using namespace std;
7: 
8: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundEmptyTableRef &ref) {
9: 	return make_unique<LogicalGet>(ref.bind_index);
10: }
11: 
12: } // namespace duckdb
[end of src/planner/binder/tableref/plan_dummytableref.cpp]
[start of src/planner/binder/tableref/plan_expressionlistref.cpp]
1: #include "duckdb/planner/binder.hpp"
2: #include "duckdb/planner/tableref/bound_expressionlistref.hpp"
3: #include "duckdb/planner/operator/logical_expression_get.hpp"
4: #include "duckdb/planner/operator/logical_get.hpp"
5: 
6: namespace duckdb {
7: using namespace std;
8: 
9: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundExpressionListRef &ref) {
10: 	auto root = make_unique_base<LogicalOperator, LogicalGet>(0);
11: 	// values list, first plan any subqueries in the list
12: 	for (auto &expr_list : ref.values) {
13: 		for (auto &expr : expr_list) {
14: 			PlanSubqueries(&expr, &root);
15: 		}
16: 	}
17: 	// now create a LogicalExpressionGet from the set of expressions
18: 	// fetch the types
19: 	vector<LogicalType> types;
20: 	for (auto &expr : ref.values[0]) {
21: 		types.push_back(expr->return_type);
22: 	}
23: 	auto expr_get = make_unique<LogicalExpressionGet>(ref.bind_index, types, move(ref.values));
24: 	expr_get->AddChild(move(root));
25: 	return move(expr_get);
26: }
27: 
28: } // namespace duckdb
[end of src/planner/binder/tableref/plan_expressionlistref.cpp]
[start of src/planner/binder/tableref/plan_table_function.cpp]
1: #include "duckdb/planner/binder.hpp"
2: #include "duckdb/planner/operator/logical_table_function.hpp"
3: #include "duckdb/planner/tableref/bound_table_function.hpp"
4: 
5: namespace duckdb {
6: using namespace std;
7: 
8: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundTableFunction &ref) {
9: 
10: 	auto logical_fun = make_unique<LogicalTableFunction>(ref.function, ref.bind_index, move(ref.bind_data),
11: 	                                                     move(ref.parameters), ref.return_types, ref.names);
12: 	for (idx_t i = 0; i < ref.return_types.size(); i++) {
13: 		logical_fun->column_ids.push_back(i);
14: 	}
15: 	return move(logical_fun);
16: }
17: 
18: } // namespace duckdb
[end of src/planner/binder/tableref/plan_table_function.cpp]
[start of src/planner/operator/CMakeLists.txt]
1: add_library_unity(duckdb_planner_operator
2:                   OBJECT
3:                   logical_aggregate.cpp
4:                   logical_empty_result.cpp
5:                   logical_any_join.cpp
6:                   logical_comparison_join.cpp
7:                   logical_cross_product.cpp
8:                   logical_filter.cpp
9:                   logical_get.cpp
10:                   logical_join.cpp
11:                   logical_projection.cpp
12:                   logical_table_function.cpp
13:                   logical_unnest.cpp
14:                   logical_window.cpp
15:                   logical_distinct.cpp)
16: set(ALL_OBJECT_FILES ${ALL_OBJECT_FILES}
17:                      $<TARGET_OBJECTS:duckdb_planner_operator> PARENT_SCOPE)
[end of src/planner/operator/CMakeLists.txt]
[start of src/planner/operator/logical_get.cpp]
1: #include "duckdb/planner/operator/logical_get.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
4: #include "duckdb/storage/data_table.hpp"
5: 
6: namespace duckdb {
7: using namespace std;
8: 
9: LogicalGet::LogicalGet(idx_t table_index)
10:     : LogicalOperator(LogicalOperatorType::GET), table(nullptr), table_index(table_index) {
11: }
12: LogicalGet::LogicalGet(TableCatalogEntry *table, idx_t table_index)
13:     : LogicalOperator(LogicalOperatorType::GET), table(table), table_index(table_index) {
14: }
15: LogicalGet::LogicalGet(TableCatalogEntry *table, idx_t table_index, vector<column_t> column_ids)
16:     : LogicalOperator(LogicalOperatorType::GET), table(table), table_index(table_index), column_ids(column_ids) {
17: }
18: 
19: string LogicalGet::ParamsToString() const {
20: 	if (!table) {
21: 		return "";
22: 	}
23: 	return "(" + table->name + ")";
24: }
25: 
26: vector<ColumnBinding> LogicalGet::GetColumnBindings() {
27: 	if (!table) {
28: 		return {ColumnBinding(INVALID_INDEX, 0)};
29: 	}
30: 	if (column_ids.size() == 0) {
31: 		return {ColumnBinding(table_index, 0)};
32: 	}
33: 	vector<ColumnBinding> result;
34: 	for (idx_t i = 0; i < column_ids.size(); i++) {
35: 		result.push_back(ColumnBinding(table_index, i));
36: 	}
37: 	return result;
38: }
39: 
40: void LogicalGet::ResolveTypes() {
41: 	if (column_ids.size() == 0) {
42: 		column_ids.push_back(COLUMN_IDENTIFIER_ROW_ID);
43: 	}
44: 	types = table->GetTypes(column_ids);
45: }
46: 
47: idx_t LogicalGet::EstimateCardinality() {
48: 	if (table) {
49: 		return table->storage->info->cardinality;
50: 	} else {
51: 		return 1;
52: 	}
53: }
54: 
55: } // namespace duckdb
[end of src/planner/operator/logical_get.cpp]
[start of src/planner/operator/logical_table_function.cpp]
1: #include "duckdb/planner/operator/logical_table_function.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
4: 
5: namespace duckdb {
6: using namespace std;
7: 
8: vector<ColumnBinding> LogicalTableFunction::GetColumnBindings() {
9: 	vector<ColumnBinding> result;
10: 	for (idx_t i = 0; i < column_ids.size(); i++) {
11: 		result.push_back(ColumnBinding(table_index, i));
12: 	}
13: 	return result;
14: }
15: 
16: void LogicalTableFunction::ResolveTypes() {
17: 	for (auto col_idx : column_ids) {
18: 		if (col_idx == COLUMN_IDENTIFIER_ROW_ID) {
19: 			types.push_back(LOGICAL_ROW_TYPE);
20: 			continue;
21: 		}
22: 		types.push_back(return_types[col_idx]);
23: 	}
24: }
25: 
26: string LogicalTableFunction::ParamsToString() const {
27: 	return "(" + function.name + ")";
28: }
29: 
30: } // namespace duckdb
[end of src/planner/operator/logical_table_function.cpp]
[start of src/planner/table_binding.cpp]
1: #include "duckdb/planner/table_binding.hpp"
2: 
3: #include "duckdb/common/string_util.hpp"
4: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
6: #include "duckdb/parser/expression/columnref_expression.hpp"
7: #include "duckdb/parser/tableref/subqueryref.hpp"
8: #include "duckdb/planner/bind_context.hpp"
9: #include "duckdb/planner/bound_query_node.hpp"
10: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
11: #include "duckdb/planner/operator/logical_get.hpp"
12: 
13: namespace duckdb {
14: using namespace std;
15: 
16: TableBinding::TableBinding(const string &alias, TableCatalogEntry &table, LogicalGet &get, idx_t index)
17:     : Binding(BindingType::TABLE, alias, index), table(table), get(get) {
18: }
19: 
20: bool TableBinding::HasMatchingBinding(const string &column_name) {
21: 	return table.ColumnExists(column_name);
22: }
23: 
24: BindResult TableBinding::Bind(ColumnRefExpression &colref, idx_t depth) {
25: 	auto entry = table.name_map.find(colref.column_name);
26: 	if (entry == table.name_map.end()) {
27: 		return BindResult(StringUtil::Format("Table \"%s\" does not have a column named \"%s\"", colref.table_name,
28: 		                                     colref.column_name));
29: 	}
30: 	auto col_index = entry->second;
31: 	// fetch the type of the column
32: 	LogicalType col_type;
33: 	if (entry->second == COLUMN_IDENTIFIER_ROW_ID) {
34: 		// row id: BIGINT type
35: 		col_type = LogicalType::BIGINT;
36: 	} else {
37: 		// normal column: fetch type from base column
38: 		auto &col = table.columns[col_index];
39: 		col_type = col.type;
40: 	}
41: 
42: 	auto &column_ids = get.column_ids;
43: 	// check if the entry already exists in the column list for the table
44: 	ColumnBinding binding;
45: 
46: 	binding.column_index = column_ids.size();
47: 	for (idx_t i = 0; i < column_ids.size(); i++) {
48: 		if (column_ids[i] == col_index) {
49: 			binding.column_index = i;
50: 			break;
51: 		}
52: 	}
53: 	if (binding.column_index == column_ids.size()) {
54: 		// column binding not found: add it to the list of bindings
55: 		column_ids.push_back(col_index);
56: 	}
57: 	binding.table_index = index;
58: 	return BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), col_type, binding, depth));
59: }
60: 
61: void TableBinding::GenerateAllColumnExpressions(BindContext &context,
62:                                                 vector<unique_ptr<ParsedExpression>> &select_list) {
63: 	for (auto &column : table.columns) {
64: 		if (context.BindingIsHidden(alias, column.name)) {
65: 			continue;
66: 		}
67: 		assert(!column.name.empty());
68: 		select_list.push_back(make_unique<ColumnRefExpression>(column.name, alias));
69: 	}
70: }
71: 
72: GenericBinding::GenericBinding(const string &alias, vector<LogicalType> coltypes, vector<string> colnames, idx_t index)
73:     : Binding(BindingType::GENERIC, alias, index), types(move(coltypes)), names(move(colnames)) {
74: 	assert(types.size() == names.size());
75: 	for (idx_t i = 0; i < names.size(); i++) {
76: 		auto &name = names[i];
77: 		assert(!name.empty());
78: 		if (name_map.find(name) != name_map.end()) {
79: 			throw BinderException("table \"%s\" has duplicate column name \"%s\"", alias, name);
80: 		}
81: 		name_map[name] = i;
82: 	}
83: 	TableCatalogEntry::AddLowerCaseAliases(name_map);
84: }
85: 
86: bool GenericBinding::HasMatchingBinding(const string &column_name) {
87: 	auto entry = name_map.find(column_name);
88: 	return entry != name_map.end();
89: }
90: 
91: BindResult GenericBinding::Bind(ColumnRefExpression &colref, idx_t depth) {
92: 	auto column_entry = name_map.find(colref.column_name);
93: 	if (column_entry == name_map.end()) {
94: 		return BindResult(StringUtil::Format("Values list \"%s\" does not have a column named \"%s\"", alias.c_str(),
95: 		                                     colref.column_name.c_str()));
96: 	}
97: 	ColumnBinding binding;
98: 	binding.table_index = index;
99: 	binding.column_index = column_entry->second;
100: 	LogicalType sql_type = types[column_entry->second];
101: 	return BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), sql_type, binding, depth));
102: }
103: 
104: void GenericBinding::GenerateAllColumnExpressions(BindContext &context,
105:                                                   vector<unique_ptr<ParsedExpression>> &select_list) {
106: 	for (auto &column_name : names) {
107: 		assert(!column_name.empty());
108: 		if (context.BindingIsHidden(alias, column_name)) {
109: 			continue;
110: 		}
111: 		select_list.push_back(make_unique<ColumnRefExpression>(column_name, alias));
112: 	}
113: }
114: 
115: } // namespace duckdb
[end of src/planner/table_binding.cpp]
[start of src/storage/data_table.cpp]
1: #include "duckdb/storage/data_table.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
4: #include "duckdb/common/exception.hpp"
5: #include "duckdb/common/helper.hpp"
6: #include "duckdb/common/vector_operations/vector_operations.hpp"
7: #include "duckdb/execution/expression_executor.hpp"
8: #include "duckdb/planner/constraints/list.hpp"
9: #include "duckdb/transaction/transaction.hpp"
10: #include "duckdb/transaction/transaction_manager.hpp"
11: #include "duckdb/storage/table/transient_segment.hpp"
12: #include "duckdb/storage/storage_manager.hpp"
13: #include "duckdb/main/client_context.hpp"
14: 
15: namespace duckdb {
16: using namespace std;
17: using namespace chrono;
18: 
19: DataTable::DataTable(StorageManager &storage, string schema, string table, vector<LogicalType> types_,
20:                      unique_ptr<vector<unique_ptr<PersistentSegment>>[]> data)
21:     : info(make_shared<DataTableInfo>(schema, table)), types(types_), storage(storage),
22:       persistent_manager(make_shared<VersionManager>(*info)), transient_manager(make_shared<VersionManager>(*info)),
23:       is_root(true) {
24: 	// set up the segment trees for the column segments
25: 	for (idx_t i = 0; i < types.size(); i++) {
26: 		auto column_data = make_shared<ColumnData>(*storage.buffer_manager, *info);
27: 		column_data->type = types[i];
28: 		column_data->column_idx = i;
29: 		columns.push_back(move(column_data));
30: 	}
31: 
32: 	// initialize the table with the existing data from disk, if any
33: 	if (data && data[0].size() > 0) {
34: 		// first append all the segments to the set of column segments
35: 		for (idx_t i = 0; i < types.size(); i++) {
36: 			columns[i]->Initialize(data[i]);
37: 			if (columns[i]->persistent_rows != columns[0]->persistent_rows) {
38: 				throw Exception("Column length mismatch in table load!");
39: 			}
40: 		}
41: 		persistent_manager->max_row = columns[0]->persistent_rows;
42: 		transient_manager->base_row = persistent_manager->max_row;
43: 	}
44: }
45: 
46: DataTable::DataTable(ClientContext &context, DataTable &parent, ColumnDefinition &new_column, Expression *default_value)
47:     : info(parent.info), types(parent.types), storage(parent.storage), persistent_manager(parent.persistent_manager),
48:       transient_manager(parent.transient_manager), columns(parent.columns), is_root(true) {
49: 	// prevent any new tuples from being added to the parent
50: 	lock_guard<mutex> parent_lock(parent.append_lock);
51: 	// add the new column to this DataTable
52: 	auto new_column_type = new_column.type;
53: 	idx_t new_column_idx = columns.size();
54: 
55: 	types.push_back(new_column_type);
56: 	auto column_data = make_shared<ColumnData>(*storage.buffer_manager, *info);
57: 	column_data->type = new_column_type;
58: 	column_data->column_idx = new_column_idx;
59: 	columns.push_back(move(column_data));
60: 
61: 	// fill the column with its DEFAULT value, or NULL if none is specified
62: 	idx_t rows_to_write = persistent_manager->max_row + transient_manager->max_row;
63: 	if (rows_to_write > 0) {
64: 		ExpressionExecutor executor;
65: 		DataChunk dummy_chunk;
66: 		Vector result(new_column_type);
67: 		if (!default_value) {
68: 			FlatVector::Nullmask(result).set();
69: 		} else {
70: 			executor.AddExpression(*default_value);
71: 		}
72: 
73: 		ColumnAppendState state;
74: 		columns[new_column_idx]->InitializeAppend(state);
75: 		for (idx_t i = 0; i < rows_to_write; i += STANDARD_VECTOR_SIZE) {
76: 			idx_t rows_in_this_vector = MinValue<idx_t>(rows_to_write - i, STANDARD_VECTOR_SIZE);
77: 			if (default_value) {
78: 				dummy_chunk.SetCardinality(rows_in_this_vector);
79: 				executor.ExecuteExpression(dummy_chunk, result);
80: 			}
81: 			columns[new_column_idx]->Append(state, result, rows_in_this_vector);
82: 		}
83: 	}
84: 	// also add this column to client local storage
85: 	Transaction::GetTransaction(context).storage.AddColumn(&parent, this, new_column, default_value);
86: 
87: 	// this table replaces the previous table, hence the parent is no longer the root DataTable
88: 	parent.is_root = false;
89: }
90: 
91: DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t removed_column)
92:     : info(parent.info), types(parent.types), storage(parent.storage), persistent_manager(parent.persistent_manager),
93:       transient_manager(parent.transient_manager), columns(parent.columns), is_root(true) {
94: 	// prevent any new tuples from being added to the parent
95: 	lock_guard<mutex> parent_lock(parent.append_lock);
96: 	// first check if there are any indexes that exist that point to the removed column
97: 	for (auto &index : info->indexes) {
98: 		for (auto &column_id : index->column_ids) {
99: 			if (column_id == removed_column) {
100: 				throw CatalogException("Cannot drop this column: an index depends on it!");
101: 			} else if (column_id > removed_column) {
102: 				throw CatalogException("Cannot drop this column: an index depends on a column after it!");
103: 			}
104: 		}
105: 	}
106: 	// erase the column from this DataTable
107: 	assert(removed_column < types.size());
108: 	types.erase(types.begin() + removed_column);
109: 	columns.erase(columns.begin() + removed_column);
110: 
111: 	// this table replaces the previous table, hence the parent is no longer the root DataTable
112: 	parent.is_root = false;
113: }
114: 
115: DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t changed_idx, LogicalType target_type,
116:                      vector<column_t> bound_columns, Expression &cast_expr)
117:     : info(parent.info), types(parent.types), storage(parent.storage), persistent_manager(parent.persistent_manager),
118:       transient_manager(parent.transient_manager), columns(parent.columns), is_root(true) {
119: 
120: 	// prevent any new tuples from being added to the parent
121: 	CreateIndexScanState scan_state;
122: 	parent.InitializeCreateIndexScan(scan_state, bound_columns);
123: 
124: 	// first check if there are any indexes that exist that point to the changed column
125: 	for (auto &index : info->indexes) {
126: 		for (auto &column_id : index->column_ids) {
127: 			if (column_id == changed_idx) {
128: 				throw CatalogException("Cannot change the type of this column: an index depends on it!");
129: 			}
130: 		}
131: 	}
132: 	// change the type in this DataTable
133: 	types[changed_idx] = target_type;
134: 
135: 	// construct a new column data for this type
136: 	auto column_data = make_shared<ColumnData>(*storage.buffer_manager, *info);
137: 	column_data->type = target_type;
138: 	column_data->column_idx = changed_idx;
139: 
140: 	ColumnAppendState append_state;
141: 	column_data->InitializeAppend(append_state);
142: 
143: 	// scan the original table, and fill the new column with the transformed value
144: 	auto &transaction = Transaction::GetTransaction(context);
145: 
146: 	vector<LogicalType> types;
147: 	for (idx_t i = 0; i < bound_columns.size(); i++) {
148: 		if (bound_columns[i] == COLUMN_IDENTIFIER_ROW_ID) {
149: 			types.push_back(LOGICAL_ROW_TYPE);
150: 		} else {
151: 			types.push_back(parent.types[bound_columns[i]]);
152: 		}
153: 	}
154: 
155: 	DataChunk scan_chunk;
156: 	scan_chunk.Initialize(types);
157: 
158: 	ExpressionExecutor executor;
159: 	executor.AddExpression(cast_expr);
160: 
161: 	Vector append_vector(target_type);
162: 	while (true) {
163: 		// scan the table
164: 		scan_chunk.Reset();
165: 		parent.CreateIndexScan(scan_state, bound_columns, scan_chunk);
166: 		if (scan_chunk.size() == 0) {
167: 			break;
168: 		}
169: 		// execute the expression
170: 		executor.ExecuteExpression(scan_chunk, append_vector);
171: 		column_data->Append(append_state, append_vector, scan_chunk.size());
172: 	}
173: 	// also add this column to client local storage
174: 	transaction.storage.ChangeType(&parent, this, changed_idx, target_type, bound_columns, cast_expr);
175: 
176: 	columns[changed_idx] = move(column_data);
177: 
178: 	// this table replaces the previous table, hence the parent is no longer the root DataTable
179: 	parent.is_root = false;
180: }
181: 
182: //===--------------------------------------------------------------------===//
183: // Scan
184: //===--------------------------------------------------------------------===//
185: void DataTable::InitializeScan(TableScanState &state, const vector<column_t> &column_ids,
186:                                unordered_map<idx_t, vector<TableFilter>> *table_filters) {
187: 	// initialize a column scan state for each column
188: 	state.column_scans = unique_ptr<ColumnScanState[]>(new ColumnScanState[column_ids.size()]);
189: 	for (idx_t i = 0; i < column_ids.size(); i++) {
190: 		auto column = column_ids[i];
191: 		if (column != COLUMN_IDENTIFIER_ROW_ID) {
192: 			columns[column]->InitializeScan(state.column_scans[i]);
193: 		} else {
194: 			state.column_scans[i].current = nullptr;
195: 		}
196: 	}
197: 	// initialize the chunk scan state
198: 	state.column_count = column_ids.size();
199: 	state.current_persistent_row = 0;
200: 	state.max_persistent_row = persistent_manager->max_row;
201: 	state.current_transient_row = 0;
202: 	state.max_transient_row = transient_manager->max_row;
203: 	if (table_filters && table_filters->size() > 0) {
204: 		state.adaptive_filter = make_unique<AdaptiveFilter>(*table_filters);
205: 	}
206: }
207: 
208: void DataTable::InitializeScan(Transaction &transaction, TableScanState &state, const vector<column_t> &column_ids,
209:                                unordered_map<idx_t, vector<TableFilter>> *table_filters) {
210: 	InitializeScan(state, column_ids, table_filters);
211: 	transaction.storage.InitializeScan(this, state.local_state);
212: }
213: 
214: void DataTable::InitializeScanWithOffset(TableScanState &state, const vector<column_t> &column_ids,
215:                                          unordered_map<idx_t, vector<TableFilter>> *table_filters, idx_t offset) {
216: 	// initialize a column scan state for each column
217: 	state.column_scans = unique_ptr<ColumnScanState[]>(new ColumnScanState[column_ids.size()]);
218: 	for (idx_t i = 0; i < column_ids.size(); i++) {
219: 		auto column = column_ids[i];
220: 		if (column != COLUMN_IDENTIFIER_ROW_ID) {
221: 			columns[column]->InitializeScanWithOffset(state.column_scans[i], offset);
222: 		} else {
223: 			state.column_scans[i].current = nullptr;
224: 		}
225: 	}
226: 	// initialize the chunk scan state
227: 	state.column_count = column_ids.size();
228: 	state.current_persistent_row = 0;
229: 	state.max_persistent_row = 0;
230: 	state.current_transient_row = 0;
231: 	state.max_transient_row = 0;
232: 	if (table_filters && table_filters->size() > 0) {
233: 		state.adaptive_filter = make_unique<AdaptiveFilter>(*table_filters);
234: 	}
235: }
236: 
237: void DataTable::InitializeParallelScan(ClientContext &context, const vector<column_t> &column_ids,
238:                                        unordered_map<idx_t, vector<TableFilter>> *table_filters,
239:                                        std::function<void(TableScanState)> callback) {
240: 	idx_t PARALLEL_SCAN_VECTOR_COUNT = 100;
241: 	idx_t PARALLEL_SCAN_TUPLE_COUNT = STANDARD_VECTOR_SIZE * PARALLEL_SCAN_VECTOR_COUNT;
242: 
243: 	idx_t current_offset = 0;
244: 	// create parallel scans for the persistent rows
245: 	for (idx_t i = 0; i < persistent_manager->max_row; i += PARALLEL_SCAN_TUPLE_COUNT) {
246: 		idx_t current = i;
247: 		idx_t next = MinValue(i + PARALLEL_SCAN_TUPLE_COUNT, persistent_manager->max_row);
248: 
249: 		TableScanState state;
250: 		InitializeScanWithOffset(state, column_ids, table_filters, current_offset);
251: 		state.current_persistent_row = current;
252: 		state.max_persistent_row = next;
253: 
254: 		callback(move(state));
255: 
256: 		current_offset += PARALLEL_SCAN_VECTOR_COUNT;
257: 	}
258: 	if (persistent_manager->max_row > 0) {
259: 		current_offset = (persistent_manager->max_row / STANDARD_VECTOR_SIZE) + 1;
260: 	}
261: 	// now create parallel scans for the transient rows
262: 	if (context.force_parallelism) {
263: 		// force parallelism: create one task per vector
264: 		PARALLEL_SCAN_VECTOR_COUNT = 1;
265: 		PARALLEL_SCAN_TUPLE_COUNT = STANDARD_VECTOR_SIZE * PARALLEL_SCAN_VECTOR_COUNT;
266: 	}
267: 	for (idx_t i = 0; i < transient_manager->max_row; i += PARALLEL_SCAN_TUPLE_COUNT) {
268: 		idx_t current = i;
269: 		idx_t next = MinValue(i + PARALLEL_SCAN_TUPLE_COUNT, transient_manager->max_row);
270: 
271: 		TableScanState state;
272: 		InitializeScanWithOffset(state, column_ids, table_filters, current_offset);
273: 		state.current_transient_row = current;
274: 		state.max_transient_row = next;
275: 
276: 		callback(move(state));
277: 
278: 		current_offset += PARALLEL_SCAN_VECTOR_COUNT;
279: 	}
280: 
281: 	// create a task for scanning the local data
282: 	// FIXME: this should also be potentially parallelized
283: 	auto &transaction = Transaction::GetTransaction(context);
284: 	TableScanState state;
285: 	state.current_persistent_row = state.max_persistent_row = 0;
286: 	state.current_transient_row = state.max_transient_row = 0;
287: 	transaction.storage.InitializeScan(this, state.local_state);
288: 	callback(move(state));
289: }
290: 
291: void DataTable::Scan(Transaction &transaction, DataChunk &result, TableScanState &state, vector<column_t> &column_ids,
292:                      unordered_map<idx_t, vector<TableFilter>> &table_filters) {
293: 	// scan the persistent segments
294: 	while (ScanBaseTable(transaction, result, state, column_ids, state.current_persistent_row, state.max_persistent_row,
295: 	                     0, *persistent_manager, table_filters)) {
296: 		if (result.size() > 0) {
297: 			return;
298: 		}
299: 		result.Reset();
300: 	}
301: 	// scan the transient segments
302: 	while (ScanBaseTable(transaction, result, state, column_ids, state.current_transient_row, state.max_transient_row,
303: 	                     persistent_manager->max_row, *transient_manager, table_filters)) {
304: 		if (result.size() > 0) {
305: 			return;
306: 		}
307: 		result.Reset();
308: 	}
309: 
310: 	// scan the transaction-local segments
311: 	transaction.storage.Scan(state.local_state, column_ids, result, &table_filters);
312: }
313: 
314: template <class T> bool checkZonemap(TableScanState &state, TableFilter &table_filter, T constant) {
315: 	T *min = (T *)state.column_scans[table_filter.column_index].current->stats.minimum.get();
316: 	T *max = (T *)state.column_scans[table_filter.column_index].current->stats.maximum.get();
317: 	switch (table_filter.comparison_type) {
318: 	case ExpressionType::COMPARE_EQUAL:
319: 		return constant >= *min && constant <= *max;
320: 	case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
321: 		return constant <= *max;
322: 	case ExpressionType::COMPARE_GREATERTHAN:
323: 		return constant < *max;
324: 	case ExpressionType::COMPARE_LESSTHANOREQUALTO:
325: 		return constant >= *min;
326: 	case ExpressionType::COMPARE_LESSTHAN:
327: 		return constant > *min;
328: 	default:
329: 		throw NotImplementedException("Operation not implemented");
330: 	}
331: }
332: 
333: bool checkZonemapString(TableScanState &state, TableFilter &table_filter, const char *constant) {
334: 	char *min = (char *)state.column_scans[table_filter.column_index].current->stats.minimum.get();
335: 	char *max = (char *)state.column_scans[table_filter.column_index].current->stats.maximum.get();
336: 	int min_comp = strcmp(min, constant);
337: 	int max_comp = strcmp(max, constant);
338: 	switch (table_filter.comparison_type) {
339: 	case ExpressionType::COMPARE_EQUAL:
340: 		return min_comp <= 0 && max_comp >= 0;
341: 	case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
342: 	case ExpressionType::COMPARE_GREATERTHAN:
343: 		return max_comp >= 0;
344: 	case ExpressionType::COMPARE_LESSTHAN:
345: 	case ExpressionType::COMPARE_LESSTHANOREQUALTO:
346: 		return min_comp <= 0;
347: 	default:
348: 		throw NotImplementedException("Operation not implemented");
349: 	}
350: }
351: 
352: bool DataTable::CheckZonemap(TableScanState &state, unordered_map<idx_t, vector<TableFilter>> &table_filters,
353:                              idx_t &current_row) {
354: 	for (auto &table_filter : table_filters) {
355: 		for (auto &predicate_constant : table_filter.second) {
356: 			bool readSegment = true;
357: 
358: 			if (!state.column_scans[predicate_constant.column_index].segment_checked) {
359: 				state.column_scans[predicate_constant.column_index].segment_checked = true;
360: 				if (!state.column_scans[predicate_constant.column_index].current) {
361: 					return true;
362: 				}
363: 				switch (state.column_scans[predicate_constant.column_index].current->type) {
364: 				case PhysicalType::INT8: {
365: 					int8_t constant = predicate_constant.constant.value_.tinyint;
366: 					readSegment = checkZonemap<int8_t>(state, predicate_constant, constant);
367: 					break;
368: 				}
369: 				case PhysicalType::INT16: {
370: 					int16_t constant = predicate_constant.constant.value_.smallint;
371: 					readSegment = checkZonemap<int16_t>(state, predicate_constant, constant);
372: 					break;
373: 				}
374: 				case PhysicalType::INT32: {
375: 					int32_t constant = predicate_constant.constant.value_.integer;
376: 					readSegment = checkZonemap<int32_t>(state, predicate_constant, constant);
377: 					break;
378: 				}
379: 				case PhysicalType::INT64: {
380: 					int64_t constant = predicate_constant.constant.value_.bigint;
381: 					readSegment = checkZonemap<int64_t>(state, predicate_constant, constant);
382: 					break;
383: 				}
384: 				case PhysicalType::INT128: {
385: 					auto constant = predicate_constant.constant.value_.hugeint;
386: 					readSegment = checkZonemap<hugeint_t>(state, predicate_constant, constant);
387: 					break;
388: 				}
389: 				case PhysicalType::FLOAT: {
390: 					float constant = predicate_constant.constant.value_.float_;
391: 					readSegment = checkZonemap<float>(state, predicate_constant, constant);
392: 					break;
393: 				}
394: 				case PhysicalType::DOUBLE: {
395: 					double constant = predicate_constant.constant.value_.double_;
396: 					readSegment = checkZonemap<double>(state, predicate_constant, constant);
397: 					break;
398: 				}
399: 				case PhysicalType::VARCHAR: {
400: 					//! we can only compare the first 7 bytes
401: 					size_t value_size = predicate_constant.constant.str_value.size() > 7
402: 					                        ? 7
403: 					                        : predicate_constant.constant.str_value.size();
404: 					string constant;
405: 					for (size_t i = 0; i < value_size; i++) {
406: 						constant += predicate_constant.constant.str_value[i];
407: 					}
408: 					readSegment = checkZonemapString(state, predicate_constant, constant.c_str());
409: 					break;
410: 				}
411: 				default:
412: 					throw NotImplementedException("Unimplemented type for zonemaps");
413: 				}
414: 			}
415: 			if (!readSegment) {
416: 				//! We can skip this partition
417: 				idx_t vectorsToSkip =
418: 				    ceil((double)(state.column_scans[predicate_constant.column_index].current->count +
419: 				                  state.column_scans[predicate_constant.column_index].current->start - current_row) /
420: 				         STANDARD_VECTOR_SIZE);
421: 				for (idx_t i = 0; i < vectorsToSkip; ++i) {
422: 					state.NextVector();
423: 					current_row += STANDARD_VECTOR_SIZE;
424: 				}
425: 				return false;
426: 			}
427: 		}
428: 	}
429: 
430: 	return true;
431: }
432: 
433: bool DataTable::ScanBaseTable(Transaction &transaction, DataChunk &result, TableScanState &state,
434:                               const vector<column_t> &column_ids, idx_t &current_row, idx_t max_row, idx_t base_row,
435:                               VersionManager &manager, unordered_map<idx_t, vector<TableFilter>> &table_filters) {
436: 	if (current_row >= max_row) {
437: 		// exceeded the amount of rows to scan
438: 		return false;
439: 	}
440: 	idx_t max_count = MinValue<idx_t>(STANDARD_VECTOR_SIZE, max_row - current_row);
441: 	idx_t vector_offset = current_row / STANDARD_VECTOR_SIZE;
442: 	//! first check the zonemap if we have to scan this partition
443: 	if (!CheckZonemap(state, table_filters, current_row)) {
444: 		return true;
445: 	}
446: 	// second, scan the version chunk manager to figure out which tuples to load for this transaction
447: 	SelectionVector valid_sel(STANDARD_VECTOR_SIZE);
448: 	idx_t count = manager.GetSelVector(transaction, vector_offset, valid_sel, max_count);
449: 	if (count == 0) {
450: 		// nothing to scan for this vector, skip the entire vector
451: 		state.NextVector();
452: 		current_row += STANDARD_VECTOR_SIZE;
453: 		return true;
454: 	}
455: 	idx_t approved_tuple_count = count;
456: 	if (count == max_count && table_filters.empty()) {
457: 		//! If we don't have any deleted tuples or filters we can just run a regular scan
458: 		for (idx_t i = 0; i < column_ids.size(); i++) {
459: 			auto column = column_ids[i];
460: 			if (column == COLUMN_IDENTIFIER_ROW_ID) {
461: 				// scan row id
462: 				assert(result.data[i].type.InternalType() == ROW_TYPE);
463: 				result.data[i].Sequence(base_row + current_row, 1);
464: 			} else {
465: 				columns[column]->Scan(transaction, state.column_scans[i], result.data[i]);
466: 			}
467: 		}
468: 	} else {
469: 		SelectionVector sel;
470: 
471: 		if (count != max_count) {
472: 			sel.Initialize(valid_sel);
473: 		} else {
474: 			sel.Initialize(FlatVector::IncrementalSelectionVector);
475: 		}
476: 		//! First, we scan the columns with filters, fetch their data and generate a selection vector.
477: 		//! get runtime statistics
478: 		auto start_time = high_resolution_clock::now();
479: 		for (idx_t i = 0; i < table_filters.size(); i++) {
480: 			auto tf_idx = state.adaptive_filter->permutation[i];
481: 			auto col_idx = column_ids[tf_idx];
482: 			columns[col_idx]->Select(transaction, state.column_scans[tf_idx], result.data[tf_idx], sel,
483: 			                         approved_tuple_count, table_filters[tf_idx]);
484: 		}
485: 		for (auto &table_filter : table_filters) {
486: 			result.data[table_filter.first].Slice(sel, approved_tuple_count);
487: 		}
488: 		//! Now we use the selection vector to fetch data for the other columns.
489: 		for (idx_t i = 0; i < column_ids.size(); i++) {
490: 			if (table_filters.find(i) == table_filters.end()) {
491: 				auto column = column_ids[i];
492: 				if (column == COLUMN_IDENTIFIER_ROW_ID) {
493: 					assert(result.data[i].type.InternalType() == PhysicalType::INT64);
494: 					result.data[i].vector_type = VectorType::FLAT_VECTOR;
495: 					auto result_data = (int64_t *)FlatVector::GetData(result.data[i]);
496: 					for (size_t sel_idx = 0; sel_idx < approved_tuple_count; sel_idx++) {
497: 						result_data[sel_idx] = base_row + current_row + sel.get_index(sel_idx);
498: 					}
499: 				} else {
500: 					columns[column]->FilterScan(transaction, state.column_scans[i], result.data[i], sel,
501: 					                            approved_tuple_count);
502: 				}
503: 			}
504: 		}
505: 		auto end_time = high_resolution_clock::now();
506: 		if (state.adaptive_filter && table_filters.size() > 1) {
507: 			state.adaptive_filter->AdaptRuntimeStatistics(
508: 			    duration_cast<duration<double>>(end_time - start_time).count());
509: 		}
510: 	}
511: 
512: 	result.SetCardinality(approved_tuple_count);
513: 	current_row += STANDARD_VECTOR_SIZE;
514: 	return true;
515: }
516: 
517: //===--------------------------------------------------------------------===//
518: // Index Scan
519: //===--------------------------------------------------------------------===//
520: void DataTable::InitializeIndexScan(Transaction &transaction, TableIndexScanState &state, Index &index,
521:                                     vector<column_t> column_ids) {
522: 	state.index = &index;
523: 	state.column_ids = move(column_ids);
524: 	transaction.storage.InitializeScan(this, state.local_state);
525: }
526: 
527: void DataTable::InitializeIndexScan(Transaction &transaction, TableIndexScanState &state, Index &index, Value value,
528:                                     ExpressionType expr_type, vector<column_t> column_ids) {
529: 	InitializeIndexScan(transaction, state, index, move(column_ids));
530: 	state.index_state = index.InitializeScanSinglePredicate(transaction, state.column_ids, value, expr_type);
531: }
532: 
533: void DataTable::InitializeIndexScan(Transaction &transaction, TableIndexScanState &state, Index &index, Value low_value,
534:                                     ExpressionType low_type, Value high_value, ExpressionType high_type,
535:                                     vector<column_t> column_ids) {
536: 	InitializeIndexScan(transaction, state, index, move(column_ids));
537: 	state.index_state =
538: 	    index.InitializeScanTwoPredicates(transaction, state.column_ids, low_value, low_type, high_value, high_type);
539: }
540: 
541: void DataTable::IndexScan(Transaction &transaction, DataChunk &result, TableIndexScanState &state) {
542: 	// clear any previously pinned blocks
543: 	state.fetch_state.handles.clear();
544: 	// scan the index
545: 	state.index->Scan(transaction, *this, state, result);
546: 	if (result.size() > 0) {
547: 		return;
548: 	}
549: 	// scan the local structure
550: 	transaction.storage.Scan(state.local_state, state.column_ids, result);
551: }
552: 
553: //===--------------------------------------------------------------------===//
554: // Fetch
555: //===--------------------------------------------------------------------===//
556: void DataTable::Fetch(Transaction &transaction, DataChunk &result, vector<column_t> &column_ids,
557:                       Vector &row_identifiers, idx_t fetch_count, TableIndexScanState &state) {
558: 	// first figure out which row identifiers we should use for this transaction by looking at the VersionManagers
559: 	row_t rows[STANDARD_VECTOR_SIZE];
560: 	idx_t count = FetchRows(transaction, row_identifiers, fetch_count, rows);
561: 
562: 	if (count == 0) {
563: 		// no rows to use
564: 		return;
565: 	}
566: 	// for each of the remaining rows, now fetch the data
567: 	result.SetCardinality(count);
568: 	for (idx_t col_idx = 0; col_idx < column_ids.size(); col_idx++) {
569: 		auto column = column_ids[col_idx];
570: 		if (column == COLUMN_IDENTIFIER_ROW_ID) {
571: 			// row id column: fill in the row ids
572: 			assert(result.data[col_idx].type.InternalType() == PhysicalType::INT64);
573: 			result.data[col_idx].vector_type = VectorType::FLAT_VECTOR;
574: 			auto data = FlatVector::GetData<row_t>(result.data[col_idx]);
575: 			for (idx_t i = 0; i < count; i++) {
576: 				data[i] = rows[i];
577: 			}
578: 		} else {
579: 			// regular column: fetch data from the base column
580: 			for (idx_t i = 0; i < count; i++) {
581: 				auto row_id = rows[i];
582: 				columns[column]->FetchRow(state.fetch_state, transaction, row_id, result.data[col_idx], i);
583: 			}
584: 		}
585: 	}
586: }
587: 
588: idx_t DataTable::FetchRows(Transaction &transaction, Vector &row_identifiers, idx_t fetch_count, row_t result_rows[]) {
589: 	assert(row_identifiers.type.InternalType() == ROW_TYPE);
590: 
591: 	// obtain a read lock on the version managers
592: 	auto l1 = persistent_manager->lock.GetSharedLock();
593: 	auto l2 = transient_manager->lock.GetSharedLock();
594: 
595: 	// now iterate over the row ids and figure out which rows to use
596: 	idx_t count = 0;
597: 
598: 	auto row_ids = FlatVector::GetData<row_t>(row_identifiers);
599: 	for (idx_t i = 0; i < fetch_count; i++) {
600: 		auto row_id = row_ids[i];
601: 		bool use_row;
602: 		if ((idx_t)row_id < persistent_manager->max_row) {
603: 			// persistent row: use persistent manager
604: 			use_row = persistent_manager->Fetch(transaction, row_id);
605: 		} else {
606: 			// transient row: use transient manager
607: 			use_row = transient_manager->Fetch(transaction, row_id);
608: 		}
609: 		if (use_row) {
610: 			// row is not deleted; use the row
611: 			result_rows[count++] = row_id;
612: 		}
613: 	}
614: 	return count;
615: }
616: 
617: //===--------------------------------------------------------------------===//
618: // Append
619: //===--------------------------------------------------------------------===//
620: static void VerifyNotNullConstraint(TableCatalogEntry &table, Vector &vector, idx_t count, string &col_name) {
621: 	if (VectorOperations::HasNull(vector, count)) {
622: 		throw ConstraintException("NOT NULL constraint failed: %s.%s", table.name, col_name);
623: 	}
624: }
625: 
626: static void VerifyCheckConstraint(TableCatalogEntry &table, Expression &expr, DataChunk &chunk) {
627: 	ExpressionExecutor executor(expr);
628: 	Vector result(LogicalType::INTEGER);
629: 	try {
630: 		executor.ExecuteExpression(chunk, result);
631: 	} catch (Exception &ex) {
632: 		throw ConstraintException("CHECK constraint failed: %s (Error: %s)", table.name, ex.what());
633: 	} catch (...) {
634: 		throw ConstraintException("CHECK constraint failed: %s (Unknown Error)", table.name);
635: 	}
636: 	VectorData vdata;
637: 	result.Orrify(chunk.size(), vdata);
638: 
639: 	auto dataptr = (int32_t *)vdata.data;
640: 	for (idx_t i = 0; i < chunk.size(); i++) {
641: 		auto idx = vdata.sel->get_index(i);
642: 		if (!(*vdata.nullmask)[idx] && dataptr[idx] == 0) {
643: 			throw ConstraintException("CHECK constraint failed: %s", table.name);
644: 		}
645: 	}
646: }
647: 
648: void DataTable::VerifyAppendConstraints(TableCatalogEntry &table, DataChunk &chunk) {
649: 	for (auto &constraint : table.bound_constraints) {
650: 		switch (constraint->type) {
651: 		case ConstraintType::NOT_NULL: {
652: 			auto &not_null = *reinterpret_cast<BoundNotNullConstraint *>(constraint.get());
653: 			VerifyNotNullConstraint(table, chunk.data[not_null.index], chunk.size(),
654: 			                        table.columns[not_null.index].name);
655: 			break;
656: 		}
657: 		case ConstraintType::CHECK: {
658: 			auto &check = *reinterpret_cast<BoundCheckConstraint *>(constraint.get());
659: 			VerifyCheckConstraint(table, *check.expression, chunk);
660: 			break;
661: 		}
662: 		case ConstraintType::UNIQUE: {
663: 			//! check whether or not the chunk can be inserted into the indexes
664: 			for (auto &index : info->indexes) {
665: 				index->VerifyAppend(chunk);
666: 			}
667: 			break;
668: 		}
669: 		case ConstraintType::FOREIGN_KEY:
670: 		default:
671: 			throw NotImplementedException("Constraint type not implemented!");
672: 		}
673: 	}
674: }
675: 
676: void DataTable::Append(TableCatalogEntry &table, ClientContext &context, DataChunk &chunk) {
677: 	if (chunk.size() == 0) {
678: 		return;
679: 	}
680: 	if (chunk.column_count() != table.columns.size()) {
681: 		throw CatalogException("Mismatch in column count for append");
682: 	}
683: 	if (!is_root) {
684: 		throw TransactionException("Transaction conflict: adding entries to a table that has been altered!");
685: 	}
686: 
687: 	chunk.Verify();
688: 
689: 	// verify any constraints on the new chunk
690: 	VerifyAppendConstraints(table, chunk);
691: 
692: 	// append to the transaction local data
693: 	auto &transaction = Transaction::GetTransaction(context);
694: 	transaction.storage.Append(this, chunk);
695: }
696: 
697: void DataTable::InitializeAppend(TableAppendState &state) {
698: 	// obtain the append lock for this table
699: 	state.append_lock = unique_lock<mutex>(append_lock);
700: 	if (!is_root) {
701: 		throw TransactionException("Transaction conflict: adding entries to a table that has been altered!");
702: 	}
703: 	// obtain locks on all indexes for the table
704: 	state.index_locks = unique_ptr<IndexLock[]>(new IndexLock[info->indexes.size()]);
705: 	for (idx_t i = 0; i < info->indexes.size(); i++) {
706: 		info->indexes[i]->InitializeLock(state.index_locks[i]);
707: 	}
708: 	// for each column, initialize the append state
709: 	state.states = unique_ptr<ColumnAppendState[]>(new ColumnAppendState[types.size()]);
710: 	for (idx_t i = 0; i < types.size(); i++) {
711: 		columns[i]->InitializeAppend(state.states[i]);
712: 	}
713: 	state.row_start = transient_manager->max_row;
714: 	state.current_row = state.row_start;
715: }
716: 
717: void DataTable::Append(Transaction &transaction, transaction_t commit_id, DataChunk &chunk, TableAppendState &state) {
718: 	assert(is_root);
719: 	assert(chunk.column_count() == types.size());
720: 	chunk.Verify();
721: 
722: 	// set up the inserted info in the version manager
723: 	transient_manager->Append(transaction, state.current_row, chunk.size(), commit_id);
724: 
725: 	// append the physical data to each of the entries
726: 	for (idx_t i = 0; i < types.size(); i++) {
727: 		columns[i]->Append(state.states[i], chunk.data[i], chunk.size());
728: 	}
729: 	info->cardinality += chunk.size();
730: 	state.current_row += chunk.size();
731: }
732: 
733: void DataTable::RevertAppend(TableAppendState &state) {
734: 	if (state.row_start == state.current_row) {
735: 		// nothing to revert!
736: 		return;
737: 	}
738: 	assert(is_root);
739: 	// revert changes in the base columns
740: 	for (idx_t i = 0; i < types.size(); i++) {
741: 		columns[i]->RevertAppend(state.row_start);
742: 	}
743: 	// adjust the cardinality
744: 	info->cardinality -= state.current_row - state.row_start;
745: 	transient_manager->max_row = state.row_start;
746: 	// revert changes in the transient manager
747: 	transient_manager->RevertAppend(state.row_start, state.current_row);
748: }
749: 
750: //===--------------------------------------------------------------------===//
751: // Indexes
752: //===--------------------------------------------------------------------===//
753: bool DataTable::AppendToIndexes(TableAppendState &state, DataChunk &chunk, row_t row_start) {
754: 	assert(is_root);
755: 	if (info->indexes.size() == 0) {
756: 		return true;
757: 	}
758: 	// first generate the vector of row identifiers
759: 	Vector row_identifiers(LOGICAL_ROW_TYPE);
760: 	VectorOperations::GenerateSequence(row_identifiers, chunk.size(), row_start, 1);
761: 
762: 	idx_t failed_index = INVALID_INDEX;
763: 	// now append the entries to the indices
764: 	for (idx_t i = 0; i < info->indexes.size(); i++) {
765: 		if (!info->indexes[i]->Append(state.index_locks[i], chunk, row_identifiers)) {
766: 			failed_index = i;
767: 			break;
768: 		}
769: 	}
770: 	if (failed_index != INVALID_INDEX) {
771: 		// constraint violation!
772: 		// remove any appended entries from previous indexes (if any)
773: 		for (idx_t i = 0; i < failed_index; i++) {
774: 			info->indexes[i]->Delete(state.index_locks[i], chunk, row_identifiers);
775: 		}
776: 		return false;
777: 	}
778: 	return true;
779: }
780: 
781: void DataTable::RemoveFromIndexes(TableAppendState &state, DataChunk &chunk, row_t row_start) {
782: 	assert(is_root);
783: 	if (info->indexes.size() == 0) {
784: 		return;
785: 	}
786: 	// first generate the vector of row identifiers
787: 	Vector row_identifiers(LOGICAL_ROW_TYPE);
788: 	VectorOperations::GenerateSequence(row_identifiers, chunk.size(), row_start, 1);
789: 
790: 	// now remove the entries from the indices
791: 	RemoveFromIndexes(state, chunk, row_identifiers);
792: }
793: 
794: void DataTable::RemoveFromIndexes(TableAppendState &state, DataChunk &chunk, Vector &row_identifiers) {
795: 	assert(is_root);
796: 	for (idx_t i = 0; i < info->indexes.size(); i++) {
797: 		info->indexes[i]->Delete(state.index_locks[i], chunk, row_identifiers);
798: 	}
799: }
800: 
801: void DataTable::RemoveFromIndexes(Vector &row_identifiers, idx_t count) {
802: 	assert(is_root);
803: 	auto row_ids = FlatVector::GetData<row_t>(row_identifiers);
804: 	// create a selection vector from the row_ids
805: 	SelectionVector sel(STANDARD_VECTOR_SIZE);
806: 	for (idx_t i = 0; i < count; i++) {
807: 		sel.set_index(i, row_ids[i] % STANDARD_VECTOR_SIZE);
808: 	}
809: 
810: 	// fetch the data for these row identifiers
811: 	DataChunk result;
812: 	result.Initialize(types);
813: 	// FIXME: we do not need to fetch all columns, only the columns required by the indices!
814: 	auto states = unique_ptr<ColumnScanState[]>(new ColumnScanState[types.size()]);
815: 	for (idx_t i = 0; i < types.size(); i++) {
816: 		columns[i]->Fetch(states[i], row_ids[0], result.data[i]);
817: 	}
818: 	result.Slice(sel, count);
819: 	for (idx_t i = 0; i < info->indexes.size(); i++) {
820: 		info->indexes[i]->Delete(result, row_identifiers);
821: 	}
822: }
823: 
824: //===--------------------------------------------------------------------===//
825: // Delete
826: //===--------------------------------------------------------------------===//
827: void DataTable::Delete(TableCatalogEntry &table, ClientContext &context, Vector &row_identifiers, idx_t count) {
828: 	assert(row_identifiers.type.InternalType() == ROW_TYPE);
829: 	if (count == 0) {
830: 		return;
831: 	}
832: 
833: 	auto &transaction = Transaction::GetTransaction(context);
834: 
835: 	row_identifiers.Normalify(count);
836: 	auto ids = FlatVector::GetData<row_t>(row_identifiers);
837: 	auto first_id = ids[0];
838: 
839: 	if (first_id >= MAX_ROW_ID) {
840: 		// deletion is in transaction-local storage: push delete into local chunk collection
841: 		transaction.storage.Delete(this, row_identifiers, count);
842: 	} else if ((idx_t)first_id < persistent_manager->max_row) {
843: 		// deletion is in persistent storage: delete in the persistent version manager
844: 		persistent_manager->Delete(transaction, this, row_identifiers, count);
845: 	} else {
846: 		// deletion is in transient storage: delete in the persistent version manager
847: 		transient_manager->Delete(transaction, this, row_identifiers, count);
848: 	}
849: }
850: 
851: //===--------------------------------------------------------------------===//
852: // Update
853: //===--------------------------------------------------------------------===//
854: static void CreateMockChunk(vector<LogicalType> &types, vector<column_t> &column_ids, DataChunk &chunk,
855:                             DataChunk &mock_chunk) {
856: 	// construct a mock DataChunk
857: 	mock_chunk.InitializeEmpty(types);
858: 	for (column_t i = 0; i < column_ids.size(); i++) {
859: 		mock_chunk.data[column_ids[i]].Reference(chunk.data[i]);
860: 	}
861: 	mock_chunk.SetCardinality(chunk.size());
862: }
863: 
864: static bool CreateMockChunk(TableCatalogEntry &table, vector<column_t> &column_ids,
865:                             unordered_set<column_t> &desired_column_ids, DataChunk &chunk, DataChunk &mock_chunk) {
866: 	idx_t found_columns = 0;
867: 	// check whether the desired columns are present in the UPDATE clause
868: 	for (column_t i = 0; i < column_ids.size(); i++) {
869: 		if (desired_column_ids.find(column_ids[i]) != desired_column_ids.end()) {
870: 			found_columns++;
871: 		}
872: 	}
873: 	if (found_columns == 0) {
874: 		// no columns were found: no need to check the constraint again
875: 		return false;
876: 	}
877: 	if (found_columns != desired_column_ids.size()) {
878: 		// FIXME: not all columns in UPDATE clause are present!
879: 		// this should not be triggered at all as the binder should add these columns
880: 		throw NotImplementedException(
881: 		    "Not all columns required for the CHECK constraint are present in the UPDATED chunk!");
882: 	}
883: 	// construct a mock DataChunk
884: 	auto types = table.GetTypes();
885: 	CreateMockChunk(types, column_ids, chunk, mock_chunk);
886: 	return true;
887: }
888: 
889: void DataTable::VerifyUpdateConstraints(TableCatalogEntry &table, DataChunk &chunk, vector<column_t> &column_ids) {
890: 	for (auto &constraint : table.bound_constraints) {
891: 		switch (constraint->type) {
892: 		case ConstraintType::NOT_NULL: {
893: 			auto &not_null = *reinterpret_cast<BoundNotNullConstraint *>(constraint.get());
894: 			// check if the constraint is in the list of column_ids
895: 			for (idx_t i = 0; i < column_ids.size(); i++) {
896: 				if (column_ids[i] == not_null.index) {
897: 					// found the column id: check the data in
898: 					VerifyNotNullConstraint(table, chunk.data[i], chunk.size(), table.columns[not_null.index].name);
899: 					break;
900: 				}
901: 			}
902: 			break;
903: 		}
904: 		case ConstraintType::CHECK: {
905: 			auto &check = *reinterpret_cast<BoundCheckConstraint *>(constraint.get());
906: 
907: 			DataChunk mock_chunk;
908: 			if (CreateMockChunk(table, column_ids, check.bound_columns, chunk, mock_chunk)) {
909: 				VerifyCheckConstraint(table, *check.expression, mock_chunk);
910: 			}
911: 			break;
912: 		}
913: 		case ConstraintType::UNIQUE:
914: 		case ConstraintType::FOREIGN_KEY:
915: 			break;
916: 		default:
917: 			throw NotImplementedException("Constraint type not implemented!");
918: 		}
919: 	}
920: 	// update should not be called for indexed columns!
921: 	// instead update should have been rewritten to delete + update on higher layer
922: #ifdef DEBUG
923: 	for (idx_t i = 0; i < info->indexes.size(); i++) {
924: 		assert(!info->indexes[i]->IndexIsUpdated(column_ids));
925: 	}
926: #endif
927: }
928: 
929: void DataTable::Update(TableCatalogEntry &table, ClientContext &context, Vector &row_ids, vector<column_t> &column_ids,
930:                        DataChunk &updates) {
931: 	assert(row_ids.type.InternalType() == ROW_TYPE);
932: 
933: 	updates.Verify();
934: 	if (updates.size() == 0) {
935: 		return;
936: 	}
937: 
938: 	// first verify that no constraints are violated
939: 	VerifyUpdateConstraints(table, updates, column_ids);
940: 
941: 	// now perform the actual update
942: 	auto &transaction = Transaction::GetTransaction(context);
943: 
944: 	updates.Normalify();
945: 	row_ids.Normalify(updates.size());
946: 	auto first_id = FlatVector::GetValue<row_t>(row_ids, 0);
947: 	if (first_id >= MAX_ROW_ID) {
948: 		// update is in transaction-local storage: push update into local storage
949: 		transaction.storage.Update(this, row_ids, column_ids, updates);
950: 		return;
951: 	}
952: 
953: 	for (idx_t i = 0; i < column_ids.size(); i++) {
954: 		auto column = column_ids[i];
955: 		assert(column != COLUMN_IDENTIFIER_ROW_ID);
956: 
957: 		columns[column]->Update(transaction, updates.data[i], row_ids, updates.size());
958: 	}
959: }
960: 
961: //===--------------------------------------------------------------------===//
962: // Create Index Scan
963: //===--------------------------------------------------------------------===//
964: void DataTable::InitializeCreateIndexScan(CreateIndexScanState &state, const vector<column_t> &column_ids) {
965: 	// we grab the append lock to make sure nothing is appended until AFTER we finish the index scan
966: 	state.append_lock = unique_lock<mutex>(append_lock);
967: 	// get a read lock on the VersionManagers to prevent any further deletions
968: 	state.locks.push_back(persistent_manager->lock.GetSharedLock());
969: 	state.locks.push_back(transient_manager->lock.GetSharedLock());
970: 
971: 	InitializeScan(state, column_ids);
972: }
973: 
974: void DataTable::CreateIndexScan(CreateIndexScanState &state, const vector<column_t> &column_ids, DataChunk &result) {
975: 	// scan the persistent segments
976: 	if (ScanCreateIndex(state, column_ids, result, state.current_persistent_row, state.max_persistent_row, 0)) {
977: 		return;
978: 	}
979: 	// scan the transient segments
980: 	if (ScanCreateIndex(state, column_ids, result, state.current_transient_row, state.max_transient_row,
981: 	                    state.max_persistent_row)) {
982: 		return;
983: 	}
984: }
985: 
986: bool DataTable::ScanCreateIndex(CreateIndexScanState &state, const vector<column_t> &column_ids, DataChunk &result,
987:                                 idx_t &current_row, idx_t max_row, idx_t base_row) {
988: 	if (current_row >= max_row) {
989: 		return false;
990: 	}
991: 	idx_t count = MinValue<idx_t>(STANDARD_VECTOR_SIZE, max_row - current_row);
992: 
993: 	// scan the base columns to fetch the actual data
994: 	// note that we insert all data into the index, even if it is marked as deleted
995: 	// FIXME: tuples that are already "cleaned up" do not need to be inserted into the index!
996: 	for (idx_t i = 0; i < column_ids.size(); i++) {
997: 		auto column = column_ids[i];
998: 		if (column == COLUMN_IDENTIFIER_ROW_ID) {
999: 			// scan row id
1000: 			assert(result.data[i].type.InternalType() == ROW_TYPE);
1001: 			result.data[i].Sequence(base_row + current_row, 1);
1002: 		} else {
1003: 			// scan actual base column
1004: 			columns[column]->IndexScan(state.column_scans[i], result.data[i]);
1005: 		}
1006: 	}
1007: 	result.SetCardinality(count);
1008: 
1009: 	current_row += STANDARD_VECTOR_SIZE;
1010: 	return count > 0;
1011: }
1012: 
1013: void DataTable::AddIndex(unique_ptr<Index> index, vector<unique_ptr<Expression>> &expressions) {
1014: 	DataChunk result;
1015: 	result.Initialize(index->logical_types);
1016: 
1017: 	DataChunk intermediate;
1018: 	vector<LogicalType> intermediate_types;
1019: 	auto column_ids = index->column_ids;
1020: 	column_ids.push_back(COLUMN_IDENTIFIER_ROW_ID);
1021: 	for (auto &id : index->column_ids) {
1022: 		intermediate_types.push_back(types[id]);
1023: 	}
1024: 	intermediate_types.push_back(LOGICAL_ROW_TYPE);
1025: 	intermediate.Initialize(intermediate_types);
1026: 
1027: 	// initialize an index scan
1028: 	CreateIndexScanState state;
1029: 	InitializeCreateIndexScan(state, column_ids);
1030: 
1031: 	if (!is_root) {
1032: 		throw TransactionException("Transaction conflict: cannot add an index to a table that has been altered!");
1033: 	}
1034: 
1035: 	// now start incrementally building the index
1036: 	IndexLock lock;
1037: 	index->InitializeLock(lock);
1038: 	ExpressionExecutor executor(expressions);
1039: 	while (true) {
1040: 		intermediate.Reset();
1041: 		// scan a new chunk from the table to index
1042: 		CreateIndexScan(state, column_ids, intermediate);
1043: 		if (intermediate.size() == 0) {
1044: 			// finished scanning for index creation
1045: 			// release all locks
1046: 			break;
1047: 		}
1048: 		// resolve the expressions for this chunk
1049: 		executor.Execute(intermediate, result);
1050: 
1051: 		// insert into the index
1052: 		if (!index->Insert(lock, result, intermediate.data[intermediate.column_count() - 1])) {
1053: 			throw ConstraintException("Cant create unique index, table contains duplicate data on indexed column(s)");
1054: 		}
1055: 	}
1056: 	info->indexes.push_back(move(index));
1057: }
1058: 
1059: } // namespace duckdb
[end of src/storage/data_table.cpp]
[start of src/storage/uncompressed_segment.cpp]
1: #include "duckdb/common/vector_operations/binary_executor.hpp"
2: #include "duckdb/storage/data_table.hpp"
3: #include "duckdb/common/operator/comparison_operators.hpp"
4: #include "duckdb/common/vector_operations/vector_operations.hpp"
5: #include "duckdb/storage/uncompressed_segment.hpp"
6: #include "duckdb/common/exception.hpp"
7: #include "duckdb/common/types/vector.hpp"
8: #include "duckdb/transaction/update_info.hpp"
9: 
10: namespace duckdb {
11: using namespace std;
12: 
13: UncompressedSegment::UncompressedSegment(BufferManager &manager, PhysicalType type, idx_t row_start)
14:     : manager(manager), type(type), block_id(INVALID_BLOCK), max_vector_count(0), tuple_count(0), row_start(row_start),
15:       versions(nullptr) {
16: }
17: 
18: UncompressedSegment::~UncompressedSegment() {
19: 	if (block_id >= MAXIMUM_BLOCK) {
20: 		// if the uncompressed segment had an in-memory segment, destroy it when the uncompressed segment is destroyed
21: 		manager.DestroyBuffer(block_id);
22: 	}
23: }
24: 
25: void UncompressedSegment::Verify(Transaction &transaction) {
26: #ifdef DEBUG
27: 	// ColumnScanState state;
28: 	// InitializeScan(state);
29: 
30: 	// Vector result(this->type);
31: 	// for (idx_t i = 0; i < this->tuple_count; i += STANDARD_VECTOR_SIZE) {
32: 	// 	idx_t vector_idx = i / STANDARD_VECTOR_SIZE;
33: 	// 	idx_t count = MinValue((idx_t)STANDARD_VECTOR_SIZE, tuple_count - i);
34: 	// 	Scan(transaction, state, vector_idx, result);
35: 	// 	result.Verify(count);
36: 	// }
37: #endif
38: }
39: 
40: static void CheckForConflicts(UpdateInfo *info, Transaction &transaction, row_t *ids, idx_t count, row_t offset,
41:                               UpdateInfo *&node) {
42: 	if (info->version_number == transaction.transaction_id) {
43: 		// this UpdateInfo belongs to the current transaction, set it in the node
44: 		node = info;
45: 	} else if (info->version_number > transaction.start_time) {
46: 		// potential conflict, check that tuple ids do not conflict
47: 		// as both ids and info->tuples are sorted, this is similar to a merge join
48: 		idx_t i = 0, j = 0;
49: 		while (true) {
50: 			auto id = ids[i] - offset;
51: 			if (id == info->tuples[j]) {
52: 				throw TransactionException("Conflict on update!");
53: 			} else if (id < info->tuples[j]) {
54: 				// id < the current tuple in info, move to next id
55: 				i++;
56: 				if (i == count) {
57: 					break;
58: 				}
59: 			} else {
60: 				// id > the current tuple, move to next tuple in info
61: 				j++;
62: 				if (j == info->N) {
63: 					break;
64: 				}
65: 			}
66: 		}
67: 	}
68: 	if (info->next) {
69: 		CheckForConflicts(info->next, transaction, ids, count, offset, node);
70: 	}
71: }
72: 
73: void UncompressedSegment::Update(ColumnData &column_data, SegmentStatistics &stats, Transaction &transaction,
74:                                  Vector &update, row_t *ids, idx_t count, row_t offset) {
75: 	// can only perform in-place updates on temporary blocks
76: 	assert(block_id >= MAXIMUM_BLOCK);
77: 
78: 	// obtain an exclusive lock
79: 	auto write_lock = lock.GetExclusiveLock();
80: 
81: #ifdef DEBUG
82: 	// verify that the ids are sorted and there are no duplicates
83: 	for (idx_t i = 1; i < count; i++) {
84: 		assert(ids[i] > ids[i - 1]);
85: 	}
86: #endif
87: 
88: 	// create the versions for this segment, if there are none yet
89: 	if (!versions) {
90: 		this->versions = unique_ptr<UpdateInfo *[]>(new UpdateInfo *[max_vector_count]);
91: 		for (idx_t i = 0; i < max_vector_count; i++) {
92: 			this->versions[i] = nullptr;
93: 		}
94: 	}
95: 
96: 	// get the vector index based on the first id
97: 	// we assert that all updates must be part of the same vector
98: 	auto first_id = ids[0];
99: 	idx_t vector_index = (first_id - offset) / STANDARD_VECTOR_SIZE;
100: 	idx_t vector_offset = offset + vector_index * STANDARD_VECTOR_SIZE;
101: 
102: 	assert(first_id >= offset);
103: 	assert(vector_index < max_vector_count);
104: 
105: 	// first check the version chain
106: 	UpdateInfo *node = nullptr;
107: 	if (versions[vector_index]) {
108: 		// there is already a version here, check if there are any conflicts and search for the node that belongs to
109: 		// this transaction in the version chain
110: 		CheckForConflicts(versions[vector_index], transaction, ids, count, vector_offset, node);
111: 	}
112: 	Update(column_data, stats, transaction, update, ids, count, vector_index, vector_offset, node);
113: }
114: 
115: UpdateInfo *UncompressedSegment::CreateUpdateInfo(ColumnData &column_data, Transaction &transaction, row_t *ids,
116:                                                   idx_t count, idx_t vector_index, idx_t vector_offset,
117:                                                   idx_t type_size) {
118: 	auto node = transaction.CreateUpdateInfo(type_size, STANDARD_VECTOR_SIZE);
119: 	node->column_data = &column_data;
120: 	node->segment = this;
121: 	node->vector_index = vector_index;
122: 	node->prev = nullptr;
123: 	node->next = versions[vector_index];
124: 	if (node->next) {
125: 		node->next->prev = node;
126: 	}
127: 	versions[vector_index] = node;
128: 
129: 	// set up the tuple ids
130: 	node->N = count;
131: 	for (idx_t i = 0; i < count; i++) {
132: 		assert((idx_t)ids[i] >= vector_offset && (idx_t)ids[i] < vector_offset + STANDARD_VECTOR_SIZE);
133: 		node->tuples[i] = ids[i] - vector_offset;
134: 	};
135: 	return node;
136: }
137: 
138: void UncompressedSegment::Fetch(ColumnScanState &state, idx_t vector_index, Vector &result) {
139: 	auto read_lock = lock.GetSharedLock();
140: 	InitializeScan(state);
141: 	FetchBaseData(state, vector_index, result);
142: }
143: 
144: //===--------------------------------------------------------------------===//
145: // Filter
146: //===--------------------------------------------------------------------===//
147: template <class T>
148: static void filterSelectionType(T *vec, T *predicate, SelectionVector &sel, idx_t &approved_tuple_count,
149:                                 ExpressionType comparison_type, nullmask_t &nullmask) {
150: 	SelectionVector new_sel(approved_tuple_count);
151: 	// the inplace loops take the result as the last parameter
152: 	switch (comparison_type) {
153: 	case ExpressionType::COMPARE_EQUAL: {
154: 		if (!nullmask.any()) {
155: 			approved_tuple_count = BinaryExecutor::SelectFlatLoop<T, T, Equals, false, true, true, true, false>(
156: 			    vec, predicate, &sel, approved_tuple_count, nullmask, &new_sel, &sel);
157: 		} else {
158: 			approved_tuple_count = BinaryExecutor::SelectFlatLoop<T, T, Equals, false, true, false, true, false>(
159: 			    vec, predicate, &sel, approved_tuple_count, nullmask, &new_sel, &sel);
160: 		}
161: 		break;
162: 	}
163: 	case ExpressionType::COMPARE_LESSTHAN: {
164: 		if (!nullmask.any()) {
165: 			approved_tuple_count = BinaryExecutor::SelectFlatLoop<T, T, LessThan, false, true, true, true, false>(
166: 			    vec, predicate, &sel, approved_tuple_count, nullmask, &new_sel, &sel);
167: 		} else {
168: 			approved_tuple_count = BinaryExecutor::SelectFlatLoop<T, T, LessThan, false, true, false, true, false>(
169: 			    vec, predicate, &sel, approved_tuple_count, nullmask, &new_sel, &sel);
170: 		}
171: 		break;
172: 	}
173: 	case ExpressionType::COMPARE_GREATERTHAN: {
174: 		if (!nullmask.any()) {
175: 			approved_tuple_count = BinaryExecutor::SelectFlatLoop<T, T, GreaterThan, false, true, true, true, false>(
176: 			    vec, predicate, &sel, approved_tuple_count, nullmask, &new_sel, &sel);
177: 		} else {
178: 			approved_tuple_count = BinaryExecutor::SelectFlatLoop<T, T, GreaterThan, false, true, false, true, false>(
179: 			    vec, predicate, &sel, approved_tuple_count, nullmask, &new_sel, &sel);
180: 		}
181: 		break;
182: 	}
183: 	case ExpressionType::COMPARE_LESSTHANOREQUALTO: {
184: 		if (!nullmask.any()) {
185: 			approved_tuple_count = BinaryExecutor::SelectFlatLoop<T, T, LessThanEquals, false, true, true, true, false>(
186: 			    vec, predicate, &sel, approved_tuple_count, nullmask, &new_sel, &sel);
187: 		} else {
188: 			approved_tuple_count =
189: 			    BinaryExecutor::SelectFlatLoop<T, T, LessThanEquals, false, true, false, true, false>(
190: 			        vec, predicate, &sel, approved_tuple_count, nullmask, &new_sel, &sel);
191: 		}
192: 		break;
193: 	}
194: 	case ExpressionType::COMPARE_GREATERTHANOREQUALTO: {
195: 		if (!nullmask.any()) {
196: 			approved_tuple_count =
197: 			    BinaryExecutor::SelectFlatLoop<T, T, GreaterThanEquals, false, true, true, true, false>(
198: 			        vec, predicate, &sel, approved_tuple_count, nullmask, &new_sel, &sel);
199: 		} else {
200: 			approved_tuple_count =
201: 			    BinaryExecutor::SelectFlatLoop<T, T, GreaterThanEquals, false, true, false, true, false>(
202: 			        vec, predicate, &sel, approved_tuple_count, nullmask, &new_sel, &sel);
203: 		}
204: 		break;
205: 	}
206: 	default:
207: 		throw NotImplementedException("Unknown comparison type for filter pushed down to table!");
208: 	}
209: 	sel.Initialize(new_sel);
210: }
211: 
212: void UncompressedSegment::filterSelection(SelectionVector &sel, Vector &result, TableFilter filter,
213:                                           idx_t &approved_tuple_count, nullmask_t &nullmask) {
214: 	// the inplace loops take the result as the last parameter
215: 	switch (result.type.InternalType()) {
216: 	case PhysicalType::INT8: {
217: 		auto result_flat = FlatVector::GetData<int8_t>(result);
218: 		auto predicate_vector = Vector(filter.constant.value_.tinyint);
219: 		auto predicate = FlatVector::GetData<int8_t>(predicate_vector);
220: 		filterSelectionType<int8_t>(result_flat, predicate, sel, approved_tuple_count, filter.comparison_type,
221: 		                            nullmask);
222: 		break;
223: 	}
224: 	case PhysicalType::INT16: {
225: 		auto result_flat = FlatVector::GetData<int16_t>(result);
226: 		auto predicate_vector = Vector(filter.constant.value_.smallint);
227: 		auto predicate = FlatVector::GetData<int16_t>(predicate_vector);
228: 		filterSelectionType<int16_t>(result_flat, predicate, sel, approved_tuple_count, filter.comparison_type,
229: 		                             nullmask);
230: 		break;
231: 	}
232: 	case PhysicalType::INT32: {
233: 		auto result_flat = FlatVector::GetData<int32_t>(result);
234: 		auto predicate_vector = Vector(filter.constant.value_.integer);
235: 		auto predicate = FlatVector::GetData<int32_t>(predicate_vector);
236: 		filterSelectionType<int32_t>(result_flat, predicate, sel, approved_tuple_count, filter.comparison_type,
237: 		                             nullmask);
238: 		break;
239: 	}
240: 	case PhysicalType::INT64: {
241: 		auto result_flat = FlatVector::GetData<int64_t>(result);
242: 		auto predicate_vector = Vector(filter.constant.value_.bigint);
243: 		auto predicate = FlatVector::GetData<int64_t>(predicate_vector);
244: 		filterSelectionType<int64_t>(result_flat, predicate, sel, approved_tuple_count, filter.comparison_type,
245: 		                             nullmask);
246: 		break;
247: 	}
248: 	case PhysicalType::FLOAT: {
249: 		auto result_flat = FlatVector::GetData<float>(result);
250: 		auto predicate_vector = Vector(filter.constant.value_.float_);
251: 		auto predicate = FlatVector::GetData<float>(predicate_vector);
252: 		filterSelectionType<float>(result_flat, predicate, sel, approved_tuple_count, filter.comparison_type, nullmask);
253: 		break;
254: 	}
255: 	case PhysicalType::DOUBLE: {
256: 		auto result_flat = FlatVector::GetData<double>(result);
257: 		auto predicate_vector = Vector(filter.constant.value_.double_);
258: 		auto predicate = FlatVector::GetData<double>(predicate_vector);
259: 		filterSelectionType<double>(result_flat, predicate, sel, approved_tuple_count, filter.comparison_type,
260: 		                            nullmask);
261: 		break;
262: 	}
263: 	case PhysicalType::VARCHAR: {
264: 		auto result_flat = FlatVector::GetData<string_t>(result);
265: 		auto predicate_vector = Vector(filter.constant.str_value);
266: 		auto predicate = FlatVector::GetData<string_t>(predicate_vector);
267: 		filterSelectionType<string_t>(result_flat, predicate, sel, approved_tuple_count, filter.comparison_type,
268: 		                              nullmask);
269: 		break;
270: 	}
271: 	default:
272: 		throw InvalidTypeException(result.type, "Invalid type for filter pushed down to table comparison");
273: 	}
274: }
275: 
276: void UncompressedSegment::Select(Transaction &transaction, Vector &result, vector<TableFilter> &tableFilters,
277:                                  SelectionVector &sel, idx_t &approved_tuple_count, ColumnScanState &state) {
278: 	auto read_lock = lock.GetSharedLock();
279: 	if (versions && versions[state.vector_index]) {
280: 		Scan(transaction, state, state.vector_index, result, false);
281: 		auto vector_index = state.vector_index;
282: 		// pin the buffer for this segment
283: 		auto handle = manager.Pin(block_id);
284: 		auto data = handle->node->buffer;
285: 		auto offset = vector_index * vector_size;
286: 		auto source_nullmask = (nullmask_t *)(data + offset);
287: 		for (auto &table_filter : tableFilters) {
288: 			filterSelection(sel, result, table_filter, approved_tuple_count, *source_nullmask);
289: 		}
290: 	} else {
291: 		//! Select the data from the base table
292: 		Select(state, result, sel, approved_tuple_count, tableFilters);
293: 	}
294: }
295: 
296: //===--------------------------------------------------------------------===//
297: // Scan
298: //===--------------------------------------------------------------------===//
299: void UncompressedSegment::Scan(Transaction &transaction, ColumnScanState &state, idx_t vector_index, Vector &result,
300:                                bool get_lock) {
301: 	unique_ptr<StorageLockKey> read_lock;
302: 	if (get_lock) {
303: 		read_lock = lock.GetSharedLock();
304: 	}
305: 	// first fetch the data from the base table
306: 	FetchBaseData(state, vector_index, result);
307: 	if (versions && versions[vector_index]) {
308: 		// if there are any versions, check if we need to overwrite the data with the versioned data
309: 		FetchUpdateData(state, transaction, versions[vector_index], result);
310: 	}
311: }
312: 
313: void UncompressedSegment::FilterScan(Transaction &transaction, ColumnScanState &state, Vector &result,
314:                                      SelectionVector &sel, idx_t &approved_tuple_count) {
315: 	auto read_lock = lock.GetSharedLock();
316: 	if (versions && versions[state.vector_index]) {
317: 		// if there are any versions, we do a regular scan
318: 		Scan(transaction, state, state.vector_index, result, false);
319: 		result.Slice(sel, approved_tuple_count);
320: 	} else {
321: 		FilterFetchBaseData(state, result, sel, approved_tuple_count);
322: 	}
323: }
324: 
325: void UncompressedSegment::IndexScan(ColumnScanState &state, idx_t vector_index, Vector &result) {
326: 	if (vector_index == 0) {
327: 		// vector_index = 0, obtain a shared lock on the segment that we keep until the index scan is complete
328: 		state.locks.push_back(lock.GetSharedLock());
329: 	}
330: 	if (versions && versions[vector_index]) {
331: 		throw TransactionException("Cannot create index with outstanding updates");
332: 	}
333: 	FetchBaseData(state, vector_index, result);
334: }
335: 
336: //===--------------------------------------------------------------------===//
337: // Update
338: //===--------------------------------------------------------------------===//
339: void UncompressedSegment::CleanupUpdate(UpdateInfo *info) {
340: 	if (info->prev) {
341: 		// there is a prev info: remove from the chain
342: 		auto prev = info->prev;
343: 		prev->next = info->next;
344: 		if (prev->next) {
345: 			prev->next->prev = prev;
346: 		}
347: 	} else {
348: 		// there is no prev info: remove from base segment
349: 		info->segment->versions[info->vector_index] = info->next;
350: 		if (info->next) {
351: 			info->next->prev = nullptr;
352: 		}
353: 	}
354: }
355: 
356: //===--------------------------------------------------------------------===//
357: // ToTemporary
358: //===--------------------------------------------------------------------===//
359: void UncompressedSegment::ToTemporary() {
360: 	auto write_lock = lock.GetExclusiveLock();
361: 
362: 	if (block_id >= MAXIMUM_BLOCK) {
363: 		// conversion has already been performed by a different thread
364: 		return;
365: 	}
366: 	// pin the current block
367: 	auto current = manager.Pin(block_id);
368: 
369: 	// now allocate a new block from the buffer manager
370: 	auto handle = manager.Allocate(Storage::BLOCK_ALLOC_SIZE);
371: 	// now copy the data over and switch to using the new block id
372: 	memcpy(handle->node->buffer, current->node->buffer, Storage::BLOCK_SIZE);
373: 	this->block_id = handle->block_id;
374: }
375: 
376: } // namespace duckdb
[end of src/storage/uncompressed_segment.cpp]
[start of third_party/catch/catch.hpp]
1: /*
2:  *  Catch v2.4.0
3:  *  Generated: 2018-09-04 11:55:01.682061
4:  *  ----------------------------------------------------------
5:  *  This file has been merged from multiple headers. Please don't edit it directly
6:  *  Copyright (c) 2018 Two Blue Cubes Ltd. All rights reserved.
7:  *
8:  *  Distributed under the Boost Software License, Version 1.0. (See accompanying
9:  *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
10:  */
11: #pragma once
12: 
13: #ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
14: #define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
15: // start catch.hpp
16: 
17: 
18: #define CATCH_VERSION_MAJOR 2
19: #define CATCH_VERSION_MINOR 4
20: #define CATCH_VERSION_PATCH 0
21: 
22: #ifdef __clang__
23: #    pragma clang system_header
24: #elif defined __GNUC__
25: #    pragma GCC system_header
26: #endif
27: 
28: // start catch_suppress_warnings.h
29: 
30: #ifdef __clang__
31: #   ifdef __ICC // icpc defines the __clang__ macro
32: #       pragma warning(push)
33: #       pragma warning(disable: 161 1682)
34: #   else // __ICC
35: #       pragma clang diagnostic push
36: #       pragma clang diagnostic ignored "-Wpadded"
37: #       pragma clang diagnostic ignored "-Wswitch-enum"
38: #       pragma clang diagnostic ignored "-Wcovered-switch-default"
39: #    endif
40: #elif defined __GNUC__
41:      // GCC likes to warn on REQUIREs, and we cannot suppress them
42:      // locally because g++'s support for _Pragma is lacking in older,
43:      // still supported, versions
44: #    pragma GCC diagnostic ignored "-Wparentheses"
45: #    pragma GCC diagnostic push
46: #    pragma GCC diagnostic ignored "-Wunused-variable"
47: #    pragma GCC diagnostic ignored "-Wpadded"
48: #endif
49: // end catch_suppress_warnings.h
50: #if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)
51: #  define CATCH_IMPL
52: #  define CATCH_CONFIG_ALL_PARTS
53: #endif
54: 
55: // In the impl file, we want to have access to all parts of the headers
56: // Can also be used to sanely support PCHs
57: #if defined(CATCH_CONFIG_ALL_PARTS)
58: #  define CATCH_CONFIG_EXTERNAL_INTERFACES
59: #  if defined(CATCH_CONFIG_DISABLE_MATCHERS)
60: #    undef CATCH_CONFIG_DISABLE_MATCHERS
61: #  endif
62: #  if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
63: #    define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
64: #  endif
65: #endif
66: 
67: #if !defined(CATCH_CONFIG_IMPL_ONLY)
68: // start catch_platform.h
69: 
70: #ifdef __APPLE__
71: # include <TargetConditionals.h>
72: # if TARGET_OS_OSX == 1
73: #  define CATCH_PLATFORM_MAC
74: # elif TARGET_OS_IPHONE == 1
75: #  define CATCH_PLATFORM_IPHONE
76: # endif
77: 
78: #elif defined(linux) || defined(__linux) || defined(__linux__)
79: #  define CATCH_PLATFORM_LINUX
80: 
81: #elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)
82: #  define CATCH_PLATFORM_WINDOWS
83: #endif
84: 
85: // end catch_platform.h
86: 
87: #ifdef CATCH_IMPL
88: #  ifndef CLARA_CONFIG_MAIN
89: #    define CLARA_CONFIG_MAIN_NOT_DEFINED
90: #    define CLARA_CONFIG_MAIN
91: #  endif
92: #endif
93: 
94: // start catch_user_interfaces.h
95: 
96: namespace Catch {
97:     unsigned int rngSeed();
98: }
99: 
100: // end catch_user_interfaces.h
101: // start catch_tag_alias_autoregistrar.h
102: 
103: // start catch_common.h
104: 
105: // start catch_compiler_capabilities.h
106: 
107: // Detect a number of compiler features - by compiler
108: // The following features are defined:
109: //
110: // CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?
111: // CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?
112: // CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?
113: // CATCH_CONFIG_DISABLE_EXCEPTIONS : Are exceptions enabled?
114: // ****************
115: // Note to maintainers: if new toggles are added please document them
116: // in configuration.md, too
117: // ****************
118: 
119: // In general each macro has a _NO_<feature name> form
120: // (e.g. CATCH_CONFIG_NO_POSIX_SIGNALS) which disables the feature.
121: // Many features, at point of detection, define an _INTERNAL_ macro, so they
122: // can be combined, en-mass, with the _NO_ forms later.
123: 
124: #ifdef __cplusplus
125: 
126: #  if __cplusplus >= 201402L
127: #    define CATCH_CPP14_OR_GREATER
128: #  endif
129: 
130: #  if __cplusplus >= 201703L
131: #    define CATCH_CPP17_OR_GREATER
132: #  endif
133: 
134: #endif
135: 
136: #if defined(CATCH_CPP17_OR_GREATER)
137: #  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
138: #endif
139: 
140: #ifdef __clang__
141: 
142: #       define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
143:             _Pragma( "clang diagnostic push" ) \
144:             _Pragma( "clang diagnostic ignored \"-Wexit-time-destructors\"" ) \
145:             _Pragma( "clang diagnostic ignored \"-Wglobal-constructors\"")
146: #       define CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \
147:             _Pragma( "clang diagnostic pop" )
148: 
149: #       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
150:             _Pragma( "clang diagnostic push" ) \
151:             _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )
152: #       define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \
153:             _Pragma( "clang diagnostic pop" )
154: 
155: #       define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
156:             _Pragma( "clang diagnostic push" ) \
157:             _Pragma( "clang diagnostic ignored \"-Wunused-variable\"" )
158: #       define CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS \
159:             _Pragma( "clang diagnostic pop" )
160: 
161: #endif // __clang__
162: 
163: ////////////////////////////////////////////////////////////////////////////////
164: // Assume that non-Windows platforms support posix signals by default
165: #if !defined(CATCH_PLATFORM_WINDOWS)
166:     #define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS
167: #endif
168: 
169: ////////////////////////////////////////////////////////////////////////////////
170: // We know some environments not to support full POSIX signals
171: #if defined(__CYGWIN__) || defined(__QNX__) || defined(__EMSCRIPTEN__) || defined(__DJGPP__)
172:     #define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
173: #endif
174: 
175: #ifdef __OS400__
176: #       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
177: #       define CATCH_CONFIG_COLOUR_NONE
178: #endif
179: 
180: ////////////////////////////////////////////////////////////////////////////////
181: // Android somehow still does not support std::to_string
182: #if defined(__ANDROID__)
183: #    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
184: #endif
185: 
186: ////////////////////////////////////////////////////////////////////////////////
187: // Not all Windows environments support SEH properly
188: #if defined(__MINGW32__)
189: #    define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
190: #endif
191: 
192: ////////////////////////////////////////////////////////////////////////////////
193: // PS4
194: #if defined(__ORBIS__)
195: #    define CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE
196: #endif
197: 
198: ////////////////////////////////////////////////////////////////////////////////
199: // Cygwin
200: #ifdef __CYGWIN__
201: 
202: // Required for some versions of Cygwin to declare gettimeofday
203: // see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin
204: #   define _BSD_SOURCE
205: 
206: #endif // __CYGWIN__
207: 
208: ////////////////////////////////////////////////////////////////////////////////
209: // Visual C++
210: #ifdef _MSC_VER
211: 
212: #  if _MSC_VER >= 1900 // Visual Studio 2015 or newer
213: #    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
214: #  endif
215: 
216: // Universal Windows platform does not support SEH
217: // Or console colours (or console at all...)
218: #  if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
219: #    define CATCH_CONFIG_COLOUR_NONE
220: #  else
221: #    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH
222: #  endif
223: 
224: #endif // _MSC_VER
225: 
226: ////////////////////////////////////////////////////////////////////////////////
227: // Check if we are compiled with -fno-exceptions or equivalent
228: #if defined(__EXCEPTIONS) || defined(__cpp_exceptions) || defined(_CPPUNWIND)
229: #  define CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED
230: #endif
231: 
232: ////////////////////////////////////////////////////////////////////////////////
233: // DJGPP
234: #ifdef __DJGPP__
235: #  define CATCH_INTERNAL_CONFIG_NO_WCHAR
236: #endif // __DJGPP__
237: 
238: ////////////////////////////////////////////////////////////////////////////////
239: 
240: // Use of __COUNTER__ is suppressed during code analysis in
241: // CLion/AppCode 2017.2.x and former, because __COUNTER__ is not properly
242: // handled by it.
243: // Otherwise all supported compilers support COUNTER macro,
244: // but user still might want to turn it off
245: #if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ >= 20170300L )
246:     #define CATCH_INTERNAL_CONFIG_COUNTER
247: #endif
248: 
249: #if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)
250: #   define CATCH_CONFIG_COUNTER
251: #endif
252: #if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) && !defined(CATCH_CONFIG_NO_WINDOWS_SEH) && !defined(CATCH_CONFIG_WINDOWS_SEH) && !defined(CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH)
253: #   define CATCH_CONFIG_WINDOWS_SEH
254: #endif
255: // This is set by default, because we assume that unix compilers are posix-signal-compatible by default.
256: #if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) && !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_POSIX_SIGNALS)
257: #   define CATCH_CONFIG_POSIX_SIGNALS
258: #endif
259: // This is set by default, because we assume that compilers with no wchar_t support are just rare exceptions.
260: #if !defined(CATCH_INTERNAL_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_WCHAR)
261: #   define CATCH_CONFIG_WCHAR
262: #endif
263: 
264: #if !defined(CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_CPP11_TO_STRING)
265: #    define CATCH_CONFIG_CPP11_TO_STRING
266: #endif
267: 
268: #if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
269: #  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
270: #endif
271: 
272: #if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
273: #  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE
274: #endif
275: 
276: #if defined(CATCH_INTERNAL_CONFIG_NEW_CAPTURE) && !defined(CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NEW_CAPTURE)
277: #  define CATCH_CONFIG_NEW_CAPTURE
278: #endif
279: 
280: #if !defined(CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED) && !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
281: #  define CATCH_CONFIG_DISABLE_EXCEPTIONS
282: #endif
283: 
284: #if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
285: #   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
286: #   define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS
287: #endif
288: #if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)
289: #   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
290: #   define CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS
291: #endif
292: #if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS)
293: #   define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS
294: #   define CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS
295: #endif
296: 
297: #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
298: #define CATCH_TRY if ((true))
299: #define CATCH_CATCH_ALL if ((false))
300: #define CATCH_CATCH_ANON(type) if ((false))
301: #else
302: #define CATCH_TRY try
303: #define CATCH_CATCH_ALL catch (...)
304: #define CATCH_CATCH_ANON(type) catch (type)
305: #endif
306: 
307: // end catch_compiler_capabilities.h
308: #define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
309: #define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
310: #ifdef CATCH_CONFIG_COUNTER
311: #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
312: #else
313: #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
314: #endif
315: 
316: #include <iosfwd>
317: #include <string>
318: #include <cstdint>
319: 
320: namespace Catch {
321: 
322:     struct CaseSensitive { enum Choice {
323:         Yes,
324:         No
325:     }; };
326: 
327:     class NonCopyable {
328:         NonCopyable( NonCopyable const& )              = delete;
329:         NonCopyable( NonCopyable && )                  = delete;
330:         NonCopyable& operator = ( NonCopyable const& ) = delete;
331:         NonCopyable& operator = ( NonCopyable && )     = delete;
332: 
333:     protected:
334:         NonCopyable();
335:         virtual ~NonCopyable();
336:     };
337: 
338:     struct SourceLineInfo {
339: 
340:         SourceLineInfo() = delete;
341:         SourceLineInfo( char const* _file, std::size_t _line ) noexcept
342:         :   file( _file ),
343:             line( _line )
344:         {}
345: 
346:         SourceLineInfo( SourceLineInfo const& other )        = default;
347:         SourceLineInfo( SourceLineInfo && )                  = default;
348:         SourceLineInfo& operator = ( SourceLineInfo const& ) = default;
349:         SourceLineInfo& operator = ( SourceLineInfo && )     = default;
350: 
351:         bool empty() const noexcept;
352:         bool operator == ( SourceLineInfo const& other ) const noexcept;
353:         bool operator < ( SourceLineInfo const& other ) const noexcept;
354: 
355:         char const* file;
356:         std::size_t line;
357:     };
358: 
359:     std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );
360: 
361:     // Use this in variadic streaming macros to allow
362:     //    >> +StreamEndStop
363:     // as well as
364:     //    >> stuff +StreamEndStop
365:     struct StreamEndStop {
366:         std::string operator+() const;
367:     };
368:     template<typename T>
369:     T const& operator + ( T const& value, StreamEndStop ) {
370:         return value;
371:     }
372: }
373: 
374: #define CATCH_INTERNAL_LINEINFO \
375:     ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )
376: 
377: // end catch_common.h
378: namespace Catch {
379: 
380:     struct RegistrarForTagAliases {
381:         RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
382:     };
383: 
384: } // end namespace Catch
385: 
386: #define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \
387:     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
388:     namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); } \
389:     CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS
390: 
391: // end catch_tag_alias_autoregistrar.h
392: // start catch_test_registry.h
393: 
394: // start catch_interfaces_testcase.h
395: 
396: #include <vector>
397: #include <memory>
398: 
399: namespace Catch {
400: 
401:     class TestSpec;
402: 
403:     struct ITestInvoker {
404:         virtual void invoke () const = 0;
405:         virtual ~ITestInvoker();
406:     };
407: 
408:     using ITestCasePtr = std::shared_ptr<ITestInvoker>;
409: 
410:     class TestCase;
411:     struct IConfig;
412: 
413:     struct ITestCaseRegistry {
414:         virtual ~ITestCaseRegistry();
415:         virtual std::vector<TestCase> const& getAllTests() const = 0;
416:         virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;
417:     };
418: 
419:     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
420:     std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
421:     std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );
422: 
423: }
424: 
425: // end catch_interfaces_testcase.h
426: // start catch_stringref.h
427: 
428: #include <cstddef>
429: #include <string>
430: #include <iosfwd>
431: 
432: namespace Catch {
433: 
434:     class StringData;
435: 
436:     /// A non-owning string class (similar to the forthcoming std::string_view)
437:     /// Note that, because a StringRef may be a substring of another string,
438:     /// it may not be null terminated. c_str() must return a null terminated
439:     /// string, however, and so the StringRef will internally take ownership
440:     /// (taking a copy), if necessary. In theory this ownership is not externally
441:     /// visible - but it does mean (substring) StringRefs should not be shared between
442:     /// threads.
443:     class StringRef {
444:     public:
445:         using size_type = std::size_t;
446: 
447:     private:
448:         friend struct StringRefTestAccess;
449: 
450:         char const* m_start;
451:         size_type m_size;
452: 
453:         char* m_data = nullptr;
454: 
455:         void takeOwnership();
456: 
457:         static constexpr char const* const s_empty = "";
458: 
459:     public: // construction/ assignment
460:         StringRef() noexcept
461:         :   StringRef( s_empty, 0 )
462:         {}
463: 
464:         StringRef( StringRef const& other ) noexcept
465:         :   m_start( other.m_start ),
466:             m_size( other.m_size )
467:         {}
468: 
469:         StringRef( StringRef&& other ) noexcept
470:         :   m_start( other.m_start ),
471:             m_size( other.m_size ),
472:             m_data( other.m_data )
473:         {
474:             other.m_data = nullptr;
475:         }
476: 
477:         StringRef( char const* rawChars ) noexcept;
478: 
479:         StringRef( char const* rawChars, size_type size ) noexcept
480:         :   m_start( rawChars ),
481:             m_size( size )
482:         {}
483: 
484:         StringRef( std::string const& stdString ) noexcept
485:         :   m_start( stdString.c_str() ),
486:             m_size( stdString.size() )
487:         {}
488: 
489:         ~StringRef() noexcept {
490:             delete[] m_data;
491:         }
492: 
493:         auto operator = ( StringRef const &other ) noexcept -> StringRef& {
494:             delete[] m_data;
495:             m_data = nullptr;
496:             m_start = other.m_start;
497:             m_size = other.m_size;
498:             return *this;
499:         }
500: 
501:         operator std::string() const;
502: 
503:         void swap( StringRef& other ) noexcept;
504: 
505:     public: // operators
506:         auto operator == ( StringRef const& other ) const noexcept -> bool;
507:         auto operator != ( StringRef const& other ) const noexcept -> bool;
508: 
509:         auto operator[] ( size_type index ) const noexcept -> char;
510: 
511:     public: // named queries
512:         auto empty() const noexcept -> bool {
513:             return m_size == 0;
514:         }
515:         auto size() const noexcept -> size_type {
516:             return m_size;
517:         }
518: 
519:         auto numberOfCharacters() const noexcept -> size_type;
520:         auto c_str() const -> char const*;
521: 
522:     public: // substrings and searches
523:         auto substr( size_type start, size_type size ) const noexcept -> StringRef;
524: 
525:         // Returns the current start pointer.
526:         // Note that the pointer can change when if the StringRef is a substring
527:         auto currentData() const noexcept -> char const*;
528: 
529:     private: // ownership queries - may not be consistent between calls
530:         auto isOwned() const noexcept -> bool;
531:         auto isSubstring() const noexcept -> bool;
532:     };
533: 
534:     auto operator + ( StringRef const& lhs, StringRef const& rhs ) -> std::string;
535:     auto operator + ( StringRef const& lhs, char const* rhs ) -> std::string;
536:     auto operator + ( char const* lhs, StringRef const& rhs ) -> std::string;
537: 
538:     auto operator += ( std::string& lhs, StringRef const& sr ) -> std::string&;
539:     auto operator << ( std::ostream& os, StringRef const& sr ) -> std::ostream&;
540: 
541:     inline auto operator "" _sr( char const* rawChars, std::size_t size ) noexcept -> StringRef {
542:         return StringRef( rawChars, size );
543:     }
544: 
545: } // namespace Catch
546: 
547: inline auto operator "" _catch_sr( char const* rawChars, std::size_t size ) noexcept -> Catch::StringRef {
548:     return Catch::StringRef( rawChars, size );
549: }
550: 
551: // end catch_stringref.h
552: namespace Catch {
553: 
554: template<typename C>
555: class TestInvokerAsMethod : public ITestInvoker {
556:     void (C::*m_testAsMethod)();
557: public:
558:     TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}
559: 
560:     void invoke() const override {
561:         C obj;
562:         (obj.*m_testAsMethod)();
563:     }
564: };
565: 
566: auto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker*;
567: 
568: template<typename C>
569: auto makeTestInvoker( void (C::*testAsMethod)() ) noexcept -> ITestInvoker* {
570:     return new(std::nothrow) TestInvokerAsMethod<C>( testAsMethod );
571: }
572: 
573: struct NameAndTags {
574:     NameAndTags( StringRef const& name_ = StringRef(), StringRef const& tags_ = StringRef() ) noexcept;
575:     StringRef name;
576:     StringRef tags;
577: };
578: 
579: struct AutoReg : NonCopyable {
580:     AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept;
581:     ~AutoReg();
582: };
583: 
584: } // end namespace Catch
585: 
586: #define INTERNAL_CATCH_EXPAND1(param) INTERNAL_CATCH_EXPAND2(param)
587: #define INTERNAL_CATCH_EXPAND2(...) INTERNAL_CATCH_NO## __VA_ARGS__
588: #define INTERNAL_CATCH_DEF(...) INTERNAL_CATCH_DEF __VA_ARGS__
589: #define INTERNAL_CATCH_NOINTERNAL_CATCH_DEF
590: 
591: #if defined(CATCH_CONFIG_DISABLE)
592:     #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \
593:         static void TestName()
594:     #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \
595:         namespace{                        \
596:             struct TestName : INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF ClassName) { \
597:                 void test();              \
598:             };                            \
599:         }                                 \
600:         void TestName::test()
601: 
602: #endif
603: 
604:     ///////////////////////////////////////////////////////////////////////////////
605:     #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
606:         static void TestName(); \
607:         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
608:         namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
609:         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \
610:         static void TestName()
611:     #define INTERNAL_CATCH_TESTCASE( ... ) \
612:         INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )
613: 
614:     ///////////////////////////////////////////////////////////////////////////////
615:     #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
616:         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
617:         namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &QualifiedMethod ), CATCH_INTERNAL_LINEINFO, "&" #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
618:         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS
619: 
620:     ///////////////////////////////////////////////////////////////////////////////
621:     #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
622:         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
623:         namespace{ \
624:             struct TestName : INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF ClassName) { \
625:                 void test(); \
626:             }; \
627:             Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( Catch::makeTestInvoker( &TestName::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
628:         } \
629:         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \
630:         void TestName::test()
631:     #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
632:         INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )
633: 
634:     ///////////////////////////////////////////////////////////////////////////////
635:     #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
636:         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
637:         Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
638:         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS
639: 
640: // end catch_test_registry.h
641: // start catch_capture.hpp
642: 
643: // start catch_assertionhandler.h
644: 
645: // start catch_assertioninfo.h
646: 
647: // start catch_result_type.h
648: 
649: namespace Catch {
650: 
651:     // ResultWas::OfType enum
652:     struct ResultWas { enum OfType {
653:         Unknown = -1,
654:         Ok = 0,
655:         Info = 1,
656:         Warning = 2,
657: 
658:         FailureBit = 0x10,
659: 
660:         ExpressionFailed = FailureBit | 1,
661:         ExplicitFailure = FailureBit | 2,
662: 
663:         Exception = 0x100 | FailureBit,
664: 
665:         ThrewException = Exception | 1,
666:         DidntThrowException = Exception | 2,
667: 
668:         FatalErrorCondition = 0x200 | FailureBit
669: 
670:     }; };
671: 
672:     bool isOk( ResultWas::OfType resultType );
673:     bool isJustInfo( int flags );
674: 
675:     // ResultDisposition::Flags enum
676:     struct ResultDisposition { enum Flags {
677:         Normal = 0x01,
678: 
679:         ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
680:         FalseTest = 0x04,           // Prefix expression with !
681:         SuppressFail = 0x08         // Failures are reported but do not fail the test
682:     }; };
683: 
684:     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );
685: 
686:     bool shouldContinueOnFailure( int flags );
687:     inline bool isFalseTest( int flags ) { return ( flags & ResultDisposition::FalseTest ) != 0; }
688:     bool shouldSuppressFailure( int flags );
689: 
690: } // end namespace Catch
691: 
692: // end catch_result_type.h
693: namespace Catch {
694: 
695:     struct AssertionInfo
696:     {
697:         StringRef macroName;
698:         SourceLineInfo lineInfo;
699:         StringRef capturedExpression;
700:         ResultDisposition::Flags resultDisposition;
701: 
702:         // We want to delete this constructor but a compiler bug in 4.8 means
703:         // the struct is then treated as non-aggregate
704:         //AssertionInfo() = delete;
705:     };
706: 
707: } // end namespace Catch
708: 
709: // end catch_assertioninfo.h
710: // start catch_decomposer.h
711: 
712: // start catch_tostring.h
713: 
714: #include <vector>
715: #include <cstddef>
716: #include <type_traits>
717: #include <string>
718: // start catch_stream.h
719: 
720: #include <iosfwd>
721: #include <cstddef>
722: #include <ostream>
723: 
724: namespace Catch {
725: 
726:     std::ostream& cout();
727:     std::ostream& cerr();
728:     std::ostream& clog();
729: 
730:     class StringRef;
731: 
732:     struct IStream {
733:         virtual ~IStream();
734:         virtual std::ostream& stream() const = 0;
735:     };
736: 
737:     auto makeStream( StringRef const &filename ) -> IStream const*;
738: 
739:     class ReusableStringStream {
740:         std::size_t m_index;
741:         std::ostream* m_oss;
742:     public:
743:         ReusableStringStream();
744:         ~ReusableStringStream();
745: 
746:         auto str() const -> std::string;
747: 
748:         template<typename T>
749:         auto operator << ( T const& value ) -> ReusableStringStream& {
750:             *m_oss << value;
751:             return *this;
752:         }
753:         auto get() -> std::ostream& { return *m_oss; }
754:     };
755: }
756: 
757: // end catch_stream.h
758: 
759: #ifdef __OBJC__
760: // start catch_objc_arc.hpp
761: 
762: #import <Foundation/Foundation.h>
763: 
764: #ifdef __has_feature
765: #define CATCH_ARC_ENABLED __has_feature(objc_arc)
766: #else
767: #define CATCH_ARC_ENABLED 0
768: #endif
769: 
770: void arcSafeRelease( NSObject* obj );
771: id performOptionalSelector( id obj, SEL sel );
772: 
773: #if !CATCH_ARC_ENABLED
774: inline void arcSafeRelease( NSObject* obj ) {
775:     [obj release];
776: }
777: inline id performOptionalSelector( id obj, SEL sel ) {
778:     if( [obj respondsToSelector: sel] )
779:         return [obj performSelector: sel];
780:     return nil;
781: }
782: #define CATCH_UNSAFE_UNRETAINED
783: #define CATCH_ARC_STRONG
784: #else
785: inline void arcSafeRelease( NSObject* ){}
786: inline id performOptionalSelector( id obj, SEL sel ) {
787: #ifdef __clang__
788: #pragma clang diagnostic push
789: #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
790: #endif
791:     if( [obj respondsToSelector: sel] )
792:         return [obj performSelector: sel];
793: #ifdef __clang__
794: #pragma clang diagnostic pop
795: #endif
796:     return nil;
797: }
798: #define CATCH_UNSAFE_UNRETAINED __unsafe_unretained
799: #define CATCH_ARC_STRONG __strong
800: #endif
801: 
802: // end catch_objc_arc.hpp
803: #endif
804: 
805: #ifdef _MSC_VER
806: #pragma warning(push)
807: #pragma warning(disable:4180) // We attempt to stream a function (address) by const&, which MSVC complains about but is harmless
808: #endif
809: 
810: // We need a dummy global operator<< so we can bring it into Catch namespace later
811: struct Catch_global_namespace_dummy {};
812: std::ostream& operator<<(std::ostream&, Catch_global_namespace_dummy);
813: 
814: namespace Catch {
815:     // Bring in operator<< from global namespace into Catch namespace
816:     using ::operator<<;
817: 
818:     namespace Detail {
819: 
820:         extern const std::string unprintableString;
821: 
822:         std::string rawMemoryToString( const void *object, std::size_t size );
823: 
824:         template<typename T>
825:         std::string rawMemoryToString( const T& object ) {
826:           return rawMemoryToString( &object, sizeof(object) );
827:         }
828: 
829:         template<typename T>
830:         class IsStreamInsertable {
831:             template<typename SSX, typename TT>
832:             static auto test(int)
833:                 -> decltype(std::declval<SSX&>() << std::declval<TT>(), std::true_type());
834: 
835:             template<typename, typename>
836:             static auto test(...)->std::false_type;
837: 
838:         public:
839:             static const bool value = decltype(test<std::ostream, const T&>(0))::value;
840:         };
841: 
842:         template<typename E>
843:         std::string convertUnknownEnumToString( E e );
844: 
845:         template<typename T>
846:         typename std::enable_if<
847:             !std::is_enum<T>::value && !std::is_base_of<std::exception, T>::value,
848:         std::string>::type convertUnstreamable( T const& ) {
849:             return Detail::unprintableString;
850:         }
851:         template<typename T>
852:         typename std::enable_if<
853:             !std::is_enum<T>::value && std::is_base_of<std::exception, T>::value,
854:          std::string>::type convertUnstreamable(T const& ex) {
855:             return ex.what();
856:         }
857: 
858:         template<typename T>
859:         typename std::enable_if<
860:             std::is_enum<T>::value
861:         , std::string>::type convertUnstreamable( T const& value ) {
862:             return convertUnknownEnumToString( value );
863:         }
864: 
865: #if defined(_MANAGED)
866:         //! Convert a CLR string to a utf8 std::string
867:         template<typename T>
868:         std::string clrReferenceToString( T^ ref ) {
869:             if (ref == nullptr)
870:                 return std::string("null");
871:             auto bytes = System::Text::Encoding::UTF8->GetBytes(ref->ToString());
872:             cli::pin_ptr<System::Byte> p = &bytes[0];
873:             return std::string(reinterpret_cast<char const *>(p), bytes->Length);
874:         }
875: #endif
876: 
877:     } // namespace Detail
878: 
879:     // If we decide for C++14, change these to enable_if_ts
880:     template <typename T, typename = void>
881:     struct StringMaker {
882:         template <typename Fake = T>
883:         static
884:         typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
885:             convert(const Fake& value) {
886:                 ReusableStringStream rss;
887:                 // NB: call using the function-like syntax to avoid ambiguity with
888:                 // user-defined templated operator<< under clang.
889:                 rss.operator<<(value);
890:                 return rss.str();
891:         }
892: 
893:         template <typename Fake = T>
894:         static
895:         typename std::enable_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
896:             convert( const Fake& value ) {
897: #if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)
898:             return Detail::convertUnstreamable(value);
899: #else
900:             return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);
901: #endif
902:         }
903:     };
904: 
905:     namespace Detail {
906: 
907:         // This function dispatches all stringification requests inside of Catch.
908:         // Should be preferably called fully qualified, like ::Catch::Detail::stringify
909:         template <typename T>
910:         std::string stringify(const T& e) {
911:             return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
912:         }
913: 
914:         template<typename E>
915:         std::string convertUnknownEnumToString( E e ) {
916:             return ::Catch::Detail::stringify(static_cast<typename std::underlying_type<E>::type>(e));
917:         }
918: 
919: #if defined(_MANAGED)
920:         template <typename T>
921:         std::string stringify( T^ e ) {
922:             return ::Catch::StringMaker<T^>::convert(e);
923:         }
924: #endif
925: 
926:     } // namespace Detail
927: 
928:     // Some predefined specializations
929: 
930:     template<>
931:     struct StringMaker<std::string> {
932:         static std::string convert(const std::string& str);
933:     };
934: #ifdef CATCH_CONFIG_WCHAR
935:     template<>
936:     struct StringMaker<std::wstring> {
937:         static std::string convert(const std::wstring& wstr);
938:     };
939: #endif
940: 
941:     template<>
942:     struct StringMaker<char const *> {
943:         static std::string convert(char const * str);
944:     };
945:     template<>
946:     struct StringMaker<char *> {
947:         static std::string convert(char * str);
948:     };
949: 
950: #ifdef CATCH_CONFIG_WCHAR
951:     template<>
952:     struct StringMaker<wchar_t const *> {
953:         static std::string convert(wchar_t const * str);
954:     };
955:     template<>
956:     struct StringMaker<wchar_t *> {
957:         static std::string convert(wchar_t * str);
958:     };
959: #endif
960: 
961:     // TBD: Should we use `strnlen` to ensure that we don't go out of the buffer,
962:     //      while keeping string semantics?
963:     template<int SZ>
964:     struct StringMaker<char[SZ]> {
965:         static std::string convert(char const* str) {
966:             return ::Catch::Detail::stringify(std::string{ str });
967:         }
968:     };
969:     template<int SZ>
970:     struct StringMaker<signed char[SZ]> {
971:         static std::string convert(signed char const* str) {
972:             return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
973:         }
974:     };
975:     template<int SZ>
976:     struct StringMaker<unsigned char[SZ]> {
977:         static std::string convert(unsigned char const* str) {
978:             return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
979:         }
980:     };
981: 
982:     template<>
983:     struct StringMaker<int> {
984:         static std::string convert(int value);
985:     };
986:     template<>
987:     struct StringMaker<long> {
988:         static std::string convert(long value);
989:     };
990:     template<>
991:     struct StringMaker<long long> {
992:         static std::string convert(long long value);
993:     };
994:     template<>
995:     struct StringMaker<unsigned int> {
996:         static std::string convert(unsigned int value);
997:     };
998:     template<>
999:     struct StringMaker<unsigned long> {
1000:         static std::string convert(unsigned long value);
1001:     };
1002:     template<>
1003:     struct StringMaker<unsigned long long> {
1004:         static std::string convert(unsigned long long value);
1005:     };
1006: 
1007:     template<>
1008:     struct StringMaker<bool> {
1009:         static std::string convert(bool b);
1010:     };
1011: 
1012:     template<>
1013:     struct StringMaker<char> {
1014:         static std::string convert(char c);
1015:     };
1016:     template<>
1017:     struct StringMaker<signed char> {
1018:         static std::string convert(signed char c);
1019:     };
1020:     template<>
1021:     struct StringMaker<unsigned char> {
1022:         static std::string convert(unsigned char c);
1023:     };
1024: 
1025:     template<>
1026:     struct StringMaker<std::nullptr_t> {
1027:         static std::string convert(std::nullptr_t);
1028:     };
1029: 
1030:     template<>
1031:     struct StringMaker<float> {
1032:         static std::string convert(float value);
1033:     };
1034:     template<>
1035:     struct StringMaker<double> {
1036:         static std::string convert(double value);
1037:     };
1038: 
1039:     template <typename T>
1040:     struct StringMaker<T*> {
1041:         template <typename U>
1042:         static std::string convert(U* p) {
1043:             if (p) {
1044:                 return ::Catch::Detail::rawMemoryToString(p);
1045:             } else {
1046:                 return "nullptr";
1047:             }
1048:         }
1049:     };
1050: 
1051:     template <typename R, typename C>
1052:     struct StringMaker<R C::*> {
1053:         static std::string convert(R C::* p) {
1054:             if (p) {
1055:                 return ::Catch::Detail::rawMemoryToString(p);
1056:             } else {
1057:                 return "nullptr";
1058:             }
1059:         }
1060:     };
1061: 
1062: #if defined(_MANAGED)
1063:     template <typename T>
1064:     struct StringMaker<T^> {
1065:         static std::string convert( T^ ref ) {
1066:             return ::Catch::Detail::clrReferenceToString(ref);
1067:         }
1068:     };
1069: #endif
1070: 
1071:     namespace Detail {
1072:         template<typename InputIterator>
1073:         std::string rangeToString(InputIterator first, InputIterator last) {
1074:             ReusableStringStream rss;
1075:             rss << "{ ";
1076:             if (first != last) {
1077:                 rss << ::Catch::Detail::stringify(*first);
1078:                 for (++first; first != last; ++first)
1079:                     rss << ", " << ::Catch::Detail::stringify(*first);
1080:             }
1081:             rss << " }";
1082:             return rss.str();
1083:         }
1084:     }
1085: 
1086: #ifdef __OBJC__
1087:     template<>
1088:     struct StringMaker<NSString*> {
1089:         static std::string convert(NSString * nsstring) {
1090:             if (!nsstring)
1091:                 return "nil";
1092:             return std::string("@") + [nsstring UTF8String];
1093:         }
1094:     };
1095:     template<>
1096:     struct StringMaker<NSObject*> {
1097:         static std::string convert(NSObject* nsObject) {
1098:             return ::Catch::Detail::stringify([nsObject description]);
1099:         }
1100: 
1101:     };
1102:     namespace Detail {
1103:         inline std::string stringify( NSString* nsstring ) {
1104:             return StringMaker<NSString*>::convert( nsstring );
1105:         }
1106: 
1107:     } // namespace Detail
1108: #endif // __OBJC__
1109: 
1110: } // namespace Catch
1111: 
1112: //////////////////////////////////////////////////////
1113: // Separate std-lib types stringification, so it can be selectively enabled
1114: // This means that we do not bring in
1115: 
1116: #if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)
1117: #  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
1118: #  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
1119: #  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
1120: #endif
1121: 
1122: // Separate std::pair specialization
1123: #if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)
1124: #include <utility>
1125: namespace Catch {
1126:     template<typename T1, typename T2>
1127:     struct StringMaker<std::pair<T1, T2> > {
1128:         static std::string convert(const std::pair<T1, T2>& pair) {
1129:             ReusableStringStream rss;
1130:             rss << "{ "
1131:                 << ::Catch::Detail::stringify(pair.first)
1132:                 << ", "
1133:                 << ::Catch::Detail::stringify(pair.second)
1134:                 << " }";
1135:             return rss.str();
1136:         }
1137:     };
1138: }
1139: #endif // CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
1140: 
1141: // Separate std::tuple specialization
1142: #if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)
1143: #include <tuple>
1144: namespace Catch {
1145:     namespace Detail {
1146:         template<
1147:             typename Tuple,
1148:             std::size_t N = 0,
1149:             bool = (N < std::tuple_size<Tuple>::value)
1150:             >
1151:             struct TupleElementPrinter {
1152:             static void print(const Tuple& tuple, std::ostream& os) {
1153:                 os << (N ? ", " : " ")
1154:                     << ::Catch::Detail::stringify(std::get<N>(tuple));
1155:                 TupleElementPrinter<Tuple, N + 1>::print(tuple, os);
1156:             }
1157:         };
1158: 
1159:         template<
1160:             typename Tuple,
1161:             std::size_t N
1162:         >
1163:             struct TupleElementPrinter<Tuple, N, false> {
1164:             static void print(const Tuple&, std::ostream&) {}
1165:         };
1166: 
1167:     }
1168: 
1169:     template<typename ...Types>
1170:     struct StringMaker<std::tuple<Types...>> {
1171:         static std::string convert(const std::tuple<Types...>& tuple) {
1172:             ReusableStringStream rss;
1173:             rss << '{';
1174:             Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());
1175:             rss << " }";
1176:             return rss.str();
1177:         }
1178:     };
1179: }
1180: #endif // CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
1181: 
1182: namespace Catch {
1183:     struct not_this_one {}; // Tag type for detecting which begin/ end are being selected
1184: 
1185:     // Import begin/ end from std here so they are considered alongside the fallback (...) overloads in this namespace
1186:     using std::begin;
1187:     using std::end;
1188: 
1189:     not_this_one begin( ... );
1190:     not_this_one end( ... );
1191: 
1192:     template <typename T>
1193:     struct is_range {
1194:         static const bool value =
1195:             !std::is_same<decltype(begin(std::declval<T>())), not_this_one>::value &&
1196:             !std::is_same<decltype(end(std::declval<T>())), not_this_one>::value;
1197:     };
1198: 
1199: #if defined(_MANAGED) // Managed types are never ranges
1200:     template <typename T>
1201:     struct is_range<T^> {
1202:         static const bool value = false;
1203:     };
1204: #endif
1205: 
1206:     template<typename Range>
1207:     std::string rangeToString( Range const& range ) {
1208:         return ::Catch::Detail::rangeToString( begin( range ), end( range ) );
1209:     }
1210: 
1211:     // Handle vector<bool> specially
1212:     template<typename Allocator>
1213:     std::string rangeToString( std::vector<bool, Allocator> const& v ) {
1214:         ReusableStringStream rss;
1215:         rss << "{ ";
1216:         bool first = true;
1217:         for( bool b : v ) {
1218:             if( first )
1219:                 first = false;
1220:             else
1221:                 rss << ", ";
1222:             rss << ::Catch::Detail::stringify( b );
1223:         }
1224:         rss << " }";
1225:         return rss.str();
1226:     }
1227: 
1228:     template<typename R>
1229:     struct StringMaker<R, typename std::enable_if<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>::type> {
1230:         static std::string convert( R const& range ) {
1231:             return rangeToString( range );
1232:         }
1233:     };
1234: 
1235:     template <typename T, int SZ>
1236:     struct StringMaker<T[SZ]> {
1237:         static std::string convert(T const(&arr)[SZ]) {
1238:             return rangeToString(arr);
1239:         }
1240:     };
1241: 
1242: } // namespace Catch
1243: 
1244: // Separate std::chrono::duration specialization
1245: #if defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
1246: #include <ctime>
1247: #include <ratio>
1248: #include <chrono>
1249: 
1250: namespace Catch {
1251: 
1252: template <class Ratio>
1253: struct ratio_string {
1254:     static std::string symbol();
1255: };
1256: 
1257: template <class Ratio>
1258: std::string ratio_string<Ratio>::symbol() {
1259:     Catch::ReusableStringStream rss;
1260:     rss << '[' << Ratio::num << '/'
1261:         << Ratio::den << ']';
1262:     return rss.str();
1263: }
1264: template <>
1265: struct ratio_string<std::atto> {
1266:     static std::string symbol();
1267: };
1268: template <>
1269: struct ratio_string<std::femto> {
1270:     static std::string symbol();
1271: };
1272: template <>
1273: struct ratio_string<std::pico> {
1274:     static std::string symbol();
1275: };
1276: template <>
1277: struct ratio_string<std::nano> {
1278:     static std::string symbol();
1279: };
1280: template <>
1281: struct ratio_string<std::micro> {
1282:     static std::string symbol();
1283: };
1284: template <>
1285: struct ratio_string<std::milli> {
1286:     static std::string symbol();
1287: };
1288: 
1289:     ////////////
1290:     // std::chrono::duration specializations
1291:     template<typename Value, typename Ratio>
1292:     struct StringMaker<std::chrono::duration<Value, Ratio>> {
1293:         static std::string convert(std::chrono::duration<Value, Ratio> const& duration) {
1294:             ReusableStringStream rss;
1295:             rss << duration.count() << ' ' << ratio_string<Ratio>::symbol() << 's';
1296:             return rss.str();
1297:         }
1298:     };
1299:     template<typename Value>
1300:     struct StringMaker<std::chrono::duration<Value, std::ratio<1>>> {
1301:         static std::string convert(std::chrono::duration<Value, std::ratio<1>> const& duration) {
1302:             ReusableStringStream rss;
1303:             rss << duration.count() << " s";
1304:             return rss.str();
1305:         }
1306:     };
1307:     template<typename Value>
1308:     struct StringMaker<std::chrono::duration<Value, std::ratio<60>>> {
1309:         static std::string convert(std::chrono::duration<Value, std::ratio<60>> const& duration) {
1310:             ReusableStringStream rss;
1311:             rss << duration.count() << " m";
1312:             return rss.str();
1313:         }
1314:     };
1315:     template<typename Value>
1316:     struct StringMaker<std::chrono::duration<Value, std::ratio<3600>>> {
1317:         static std::string convert(std::chrono::duration<Value, std::ratio<3600>> const& duration) {
1318:             ReusableStringStream rss;
1319:             rss << duration.count() << " h";
1320:             return rss.str();
1321:         }
1322:     };
1323: 
1324:     ////////////
1325:     // std::chrono::time_point specialization
1326:     // Generic time_point cannot be specialized, only std::chrono::time_point<system_clock>
1327:     template<typename Clock, typename Duration>
1328:     struct StringMaker<std::chrono::time_point<Clock, Duration>> {
1329:         static std::string convert(std::chrono::time_point<Clock, Duration> const& time_point) {
1330:             return ::Catch::Detail::stringify(time_point.time_since_epoch()) + " since epoch";
1331:         }
1332:     };
1333:     // std::chrono::time_point<system_clock> specialization
1334:     template<typename Duration>
1335:     struct StringMaker<std::chrono::time_point<std::chrono::system_clock, Duration>> {
1336:         static std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> const& time_point) {
1337:             auto converted = std::chrono::system_clock::to_time_t(time_point);
1338: 
1339: #ifdef _MSC_VER
1340:             std::tm timeInfo = {};
1341:             gmtime_s(&timeInfo, &converted);
1342: #else
1343:             std::tm* timeInfo = std::gmtime(&converted);
1344: #endif
1345: 
1346:             auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");
1347:             char timeStamp[timeStampSize];
1348:             const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";
1349: 
1350: #ifdef _MSC_VER
1351:             std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
1352: #else
1353:             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
1354: #endif
1355:             return std::string(timeStamp);
1356:         }
1357:     };
1358: }
1359: #endif // CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
1360: 
1361: #ifdef _MSC_VER
1362: #pragma warning(pop)
1363: #endif
1364: 
1365: // end catch_tostring.h
1366: #include <iosfwd>
1367: 
1368: #ifdef _MSC_VER
1369: #pragma warning(push)
1370: #pragma warning(disable:4389) // '==' : signed/unsigned mismatch
1371: #pragma warning(disable:4018) // more "signed/unsigned mismatch"
1372: #pragma warning(disable:4312) // Converting int to T* using reinterpret_cast (issue on x64 platform)
1373: #pragma warning(disable:4180) // qualifier applied to function type has no meaning
1374: #endif
1375: 
1376: namespace Catch {
1377: 
1378:     struct ITransientExpression {
1379:         auto isBinaryExpression() const -> bool { return m_isBinaryExpression; }
1380:         auto getResult() const -> bool { return m_result; }
1381:         virtual void streamReconstructedExpression( std::ostream &os ) const = 0;
1382: 
1383:         ITransientExpression( bool isBinaryExpression, bool result )
1384:         :   m_isBinaryExpression( isBinaryExpression ),
1385:             m_result( result )
1386:         {}
1387: 
1388:         // We don't actually need a virtual destructor, but many static analysers
1389:         // complain if it's not here :-(
1390:         virtual ~ITransientExpression();
1391: 
1392:         bool m_isBinaryExpression;
1393:         bool m_result;
1394: 
1395:     };
1396: 
1397:     void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs );
1398: 
1399:     template<typename LhsT, typename RhsT>
1400:     class BinaryExpr  : public ITransientExpression {
1401:         LhsT m_lhs;
1402:         StringRef m_op;
1403:         RhsT m_rhs;
1404: 
1405:         void streamReconstructedExpression( std::ostream &os ) const override {
1406:             formatReconstructedExpression
1407:                     ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );
1408:         }
1409: 
1410:     public:
1411:         BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )
1412:         :   ITransientExpression{ true, comparisonResult },
1413:             m_lhs( lhs ),
1414:             m_op( op ),
1415:             m_rhs( rhs )
1416:         {}
1417:     };
1418: 
1419:     template<typename LhsT>
1420:     class UnaryExpr : public ITransientExpression {
1421:         LhsT m_lhs;
1422: 
1423:         void streamReconstructedExpression( std::ostream &os ) const override {
1424:             os << Catch::Detail::stringify( m_lhs );
1425:         }
1426: 
1427:     public:
1428:         explicit UnaryExpr( LhsT lhs )
1429:         :   ITransientExpression{ false, lhs ? true : false },
1430:             m_lhs( lhs )
1431:         {}
1432:     };
1433: 
1434:     // Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)
1435:     template<typename LhsT, typename RhsT>
1436:     auto compareEqual( LhsT const& lhs, RhsT const& rhs ) -> bool { return static_cast<bool>(lhs == rhs); }
1437:     template<typename T>
1438:     auto compareEqual( T* const& lhs, int rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
1439:     template<typename T>
1440:     auto compareEqual( T* const& lhs, long rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
1441:     template<typename T>
1442:     auto compareEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
1443:     template<typename T>
1444:     auto compareEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
1445: 
1446:     template<typename LhsT, typename RhsT>
1447:     auto compareNotEqual( LhsT const& lhs, RhsT&& rhs ) -> bool { return static_cast<bool>(lhs != rhs); }
1448:     template<typename T>
1449:     auto compareNotEqual( T* const& lhs, int rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
1450:     template<typename T>
1451:     auto compareNotEqual( T* const& lhs, long rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
1452:     template<typename T>
1453:     auto compareNotEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
1454:     template<typename T>
1455:     auto compareNotEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
1456: 
1457:     template<typename LhsT>
1458:     class ExprLhs {
1459:         LhsT m_lhs;
1460:     public:
1461:         explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}
1462: 
1463:         template<typename RhsT>
1464:         auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
1465:             return { compareEqual( m_lhs, rhs ), m_lhs, "==", rhs };
1466:         }
1467:         auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
1468:             return { m_lhs == rhs, m_lhs, "==", rhs };
1469:         }
1470: 
1471:         template<typename RhsT>
1472:         auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
1473:             return { compareNotEqual( m_lhs, rhs ), m_lhs, "!=", rhs };
1474:         }
1475:         auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
1476:             return { m_lhs != rhs, m_lhs, "!=", rhs };
1477:         }
1478: 
1479:         template<typename RhsT>
1480:         auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
1481:             return { static_cast<bool>(m_lhs > rhs), m_lhs, ">", rhs };
1482:         }
1483:         template<typename RhsT>
1484:         auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
1485:             return { static_cast<bool>(m_lhs < rhs), m_lhs, "<", rhs };
1486:         }
1487:         template<typename RhsT>
1488:         auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
1489:             return { static_cast<bool>(m_lhs >= rhs), m_lhs, ">=", rhs };
1490:         }
1491:         template<typename RhsT>
1492:         auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
1493:             return { static_cast<bool>(m_lhs <= rhs), m_lhs, "<=", rhs };
1494:         }
1495: 
1496:         auto makeUnaryExpr() const -> UnaryExpr<LhsT> {
1497:             return UnaryExpr<LhsT>{ m_lhs };
1498:         }
1499:     };
1500: 
1501:     void handleExpression( ITransientExpression const& expr );
1502: 
1503:     template<typename T>
1504:     void handleExpression( ExprLhs<T> const& expr ) {
1505:         handleExpression( expr.makeUnaryExpr() );
1506:     }
1507: 
1508:     struct Decomposer {
1509:         template<typename T>
1510:         auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {
1511:             return ExprLhs<T const&>{ lhs };
1512:         }
1513: 
1514:         auto operator <=( bool value ) -> ExprLhs<bool> {
1515:             return ExprLhs<bool>{ value };
1516:         }
1517:     };
1518: 
1519: } // end namespace Catch
1520: 
1521: #ifdef _MSC_VER
1522: #pragma warning(pop)
1523: #endif
1524: 
1525: // end catch_decomposer.h
1526: // start catch_interfaces_capture.h
1527: 
1528: #include <string>
1529: 
1530: namespace Catch {
1531: 
1532:     class AssertionResult;
1533:     struct AssertionInfo;
1534:     struct SectionInfo;
1535:     struct SectionEndInfo;
1536:     struct MessageInfo;
1537:     struct Counts;
1538:     struct BenchmarkInfo;
1539:     struct BenchmarkStats;
1540:     struct AssertionReaction;
1541:     struct SourceLineInfo;
1542: 
1543:     struct ITransientExpression;
1544:     struct IGeneratorTracker;
1545: 
1546:     struct IResultCapture {
1547: 
1548:         virtual ~IResultCapture();
1549: 
1550:         virtual bool sectionStarted(    SectionInfo const& sectionInfo,
1551:                                         Counts& assertions ) = 0;
1552:         virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;
1553:         virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;
1554: 
1555:         virtual auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& = 0;
1556: 
1557:         virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;
1558:         virtual void benchmarkEnded( BenchmarkStats const& stats ) = 0;
1559: 
1560:         virtual void pushScopedMessage( MessageInfo const& message ) = 0;
1561:         virtual void popScopedMessage( MessageInfo const& message ) = 0;
1562: 
1563:         virtual void handleFatalErrorCondition( StringRef message ) = 0;
1564: 
1565:         virtual void handleExpr
1566:                 (   AssertionInfo const& info,
1567:                     ITransientExpression const& expr,
1568:                     AssertionReaction& reaction ) = 0;
1569:         virtual void handleMessage
1570:                 (   AssertionInfo const& info,
1571:                     ResultWas::OfType resultType,
1572:                     StringRef const& message,
1573:                     AssertionReaction& reaction ) = 0;
1574:         virtual void handleUnexpectedExceptionNotThrown
1575:                 (   AssertionInfo const& info,
1576:                     AssertionReaction& reaction ) = 0;
1577:         virtual void handleUnexpectedInflightException
1578:                 (   AssertionInfo const& info,
1579:                     std::string const& message,
1580:                     AssertionReaction& reaction ) = 0;
1581:         virtual void handleIncomplete
1582:                 (   AssertionInfo const& info ) = 0;
1583:         virtual void handleNonExpr
1584:                 (   AssertionInfo const &info,
1585:                     ResultWas::OfType resultType,
1586:                     AssertionReaction &reaction ) = 0;
1587: 
1588:         virtual bool lastAssertionPassed() = 0;
1589:         virtual void assertionPassed() = 0;
1590: 
1591:         // Deprecated, do not use:
1592:         virtual std::string getCurrentTestName() const = 0;
1593:         virtual const AssertionResult* getLastResult() const = 0;
1594:         virtual void exceptionEarlyReported() = 0;
1595:     };
1596: 
1597:     IResultCapture& getResultCapture();
1598: }
1599: 
1600: // end catch_interfaces_capture.h
1601: namespace Catch {
1602: 
1603:     struct TestFailureException{};
1604:     struct AssertionResultData;
1605:     struct IResultCapture;
1606:     class RunContext;
1607: 
1608:     class LazyExpression {
1609:         friend class AssertionHandler;
1610:         friend struct AssertionStats;
1611:         friend class RunContext;
1612: 
1613:         ITransientExpression const* m_transientExpression = nullptr;
1614:         bool m_isNegated;
1615:     public:
1616:         LazyExpression( bool isNegated );
1617:         LazyExpression( LazyExpression const& other );
1618:         LazyExpression& operator = ( LazyExpression const& ) = delete;
1619: 
1620:         explicit operator bool() const;
1621: 
1622:         friend auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream&;
1623:     };
1624: 
1625:     struct AssertionReaction {
1626:         bool shouldDebugBreak = false;
1627:         bool shouldThrow = false;
1628:     };
1629: 
1630:     class AssertionHandler {
1631:         AssertionInfo m_assertionInfo;
1632:         AssertionReaction m_reaction;
1633:         bool m_completed = false;
1634:         IResultCapture& m_resultCapture;
1635: 
1636:     public:
1637:         AssertionHandler
1638:             (   StringRef const& macroName,
1639:                 SourceLineInfo const& lineInfo,
1640:                 StringRef capturedExpression,
1641:                 ResultDisposition::Flags resultDisposition );
1642:         ~AssertionHandler() {
1643:             if ( !m_completed ) {
1644:                 m_resultCapture.handleIncomplete( m_assertionInfo );
1645:             }
1646:         }
1647: 
1648:         template<typename T>
1649:         void handleExpr( ExprLhs<T> const& expr ) {
1650:             handleExpr( expr.makeUnaryExpr() );
1651:         }
1652:         void handleExpr( ITransientExpression const& expr );
1653: 
1654:         void handleMessage(ResultWas::OfType resultType, StringRef const& message);
1655: 
1656:         void handleExceptionThrownAsExpected();
1657:         void handleUnexpectedExceptionNotThrown();
1658:         void handleExceptionNotThrownAsExpected();
1659:         void handleThrowingCallSkipped();
1660:         void handleUnexpectedInflightException();
1661: 
1662:         void complete();
1663:         void setCompleted();
1664: 
1665:         // query
1666:         auto allowThrows() const -> bool;
1667:     };
1668: 
1669:     void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef const& matcherString );
1670: 
1671: } // namespace Catch
1672: 
1673: // end catch_assertionhandler.h
1674: // start catch_message.h
1675: 
1676: #include <string>
1677: #include <vector>
1678: 
1679: namespace Catch {
1680: 
1681:     struct MessageInfo {
1682:         MessageInfo(    StringRef const& _macroName,
1683:                         SourceLineInfo const& _lineInfo,
1684:                         ResultWas::OfType _type );
1685: 
1686:         StringRef macroName;
1687:         std::string message;
1688:         SourceLineInfo lineInfo;
1689:         ResultWas::OfType type;
1690:         unsigned int sequence;
1691: 
1692:         bool operator == ( MessageInfo const& other ) const;
1693:         bool operator < ( MessageInfo const& other ) const;
1694:     private:
1695:         static unsigned int globalCount;
1696:     };
1697: 
1698:     struct MessageStream {
1699: 
1700:         template<typename T>
1701:         MessageStream& operator << ( T const& value ) {
1702:             m_stream << value;
1703:             return *this;
1704:         }
1705: 
1706:         ReusableStringStream m_stream;
1707:     };
1708: 
1709:     struct MessageBuilder : MessageStream {
1710:         MessageBuilder( StringRef const& macroName,
1711:                         SourceLineInfo const& lineInfo,
1712:                         ResultWas::OfType type );
1713: 
1714:         template<typename T>
1715:         MessageBuilder& operator << ( T const& value ) {
1716:             m_stream << value;
1717:             return *this;
1718:         }
1719: 
1720:         MessageInfo m_info;
1721:     };
1722: 
1723:     class ScopedMessage {
1724:     public:
1725:         explicit ScopedMessage( MessageBuilder const& builder );
1726:         ~ScopedMessage();
1727: 
1728:         MessageInfo m_info;
1729:     };
1730: 
1731:     class Capturer {
1732:         std::vector<MessageInfo> m_messages;
1733:         IResultCapture& m_resultCapture = getResultCapture();
1734:         size_t m_captured = 0;
1735:     public:
1736:         Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );
1737:         ~Capturer();
1738: 
1739:         void captureValue( size_t index, StringRef value );
1740: 
1741:         template<typename T>
1742:         void captureValues( size_t index, T&& value ) {
1743:             captureValue( index, Catch::Detail::stringify( value ) );
1744:         }
1745: 
1746:         template<typename T, typename... Ts>
1747:         void captureValues( size_t index, T&& value, Ts&&... values ) {
1748:             captureValues( index, value );
1749:             captureValues( index+1, values... );
1750:         }
1751:     };
1752: 
1753: } // end namespace Catch
1754: 
1755: // end catch_message.h
1756: #if !defined(CATCH_CONFIG_DISABLE)
1757: 
1758: #if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)
1759:   #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__
1760: #else
1761:   #define CATCH_INTERNAL_STRINGIFY(...) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"
1762: #endif
1763: 
1764: #if defined(CATCH_CONFIG_FAST_COMPILE) || defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
1765: 
1766: ///////////////////////////////////////////////////////////////////////////////
1767: // Another way to speed-up compilation is to omit local try-catch for REQUIRE*
1768: // macros.
1769: #define INTERNAL_CATCH_TRY
1770: #define INTERNAL_CATCH_CATCH( capturer )
1771: 
1772: #else // CATCH_CONFIG_FAST_COMPILE
1773: 
1774: #define INTERNAL_CATCH_TRY try
1775: #define INTERNAL_CATCH_CATCH( handler ) catch(...) { handler.handleUnexpectedInflightException(); }
1776: 
1777: #endif
1778: 
1779: #define INTERNAL_CATCH_REACT( handler ) handler.complete();
1780: 
1781: ///////////////////////////////////////////////////////////////////////////////
1782: #define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \
1783:     do { \
1784:         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
1785:         INTERNAL_CATCH_TRY { \
1786:             CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
1787:             catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); \
1788:             CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \
1789:         } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
1790:         INTERNAL_CATCH_REACT( catchAssertionHandler ) \
1791:     } while( (void)0, false && static_cast<bool>( !!(__VA_ARGS__) ) ) // the expression here is never evaluated at runtime but it forces the compiler to give it a look
1792:     // The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.
1793: 
1794: ///////////////////////////////////////////////////////////////////////////////
1795: #define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \
1796:     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
1797:     if( Catch::getResultCapture().lastAssertionPassed() )
1798: 
1799: ///////////////////////////////////////////////////////////////////////////////
1800: #define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \
1801:     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
1802:     if( !Catch::getResultCapture().lastAssertionPassed() )
1803: 
1804: ///////////////////////////////////////////////////////////////////////////////
1805: #define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \
1806:     do { \
1807:         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
1808:         try { \
1809:             static_cast<void>(__VA_ARGS__); \
1810:             catchAssertionHandler.handleExceptionNotThrownAsExpected(); \
1811:         } \
1812:         catch( ... ) { \
1813:             catchAssertionHandler.handleUnexpectedInflightException(); \
1814:         } \
1815:         INTERNAL_CATCH_REACT( catchAssertionHandler ) \
1816:     } while( false )
1817: 
1818: ///////////////////////////////////////////////////////////////////////////////
1819: #define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \
1820:     do { \
1821:         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \
1822:         if( catchAssertionHandler.allowThrows() ) \
1823:             try { \
1824:                 static_cast<void>(__VA_ARGS__); \
1825:                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
1826:             } \
1827:             catch( ... ) { \
1828:                 catchAssertionHandler.handleExceptionThrownAsExpected(); \
1829:             } \
1830:         else \
1831:             catchAssertionHandler.handleThrowingCallSkipped(); \
1832:         INTERNAL_CATCH_REACT( catchAssertionHandler ) \
1833:     } while( false )
1834: 
1835: ///////////////////////////////////////////////////////////////////////////////
1836: #define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \
1837:     do { \
1838:         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) ", " CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \
1839:         if( catchAssertionHandler.allowThrows() ) \
1840:             try { \
1841:                 static_cast<void>(expr); \
1842:                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
1843:             } \
1844:             catch( exceptionType const& ) { \
1845:                 catchAssertionHandler.handleExceptionThrownAsExpected(); \
1846:             } \
1847:             catch( ... ) { \
1848:                 catchAssertionHandler.handleUnexpectedInflightException(); \
1849:             } \
1850:         else \
1851:             catchAssertionHandler.handleThrowingCallSkipped(); \
1852:         INTERNAL_CATCH_REACT( catchAssertionHandler ) \
1853:     } while( false )
1854: 
1855: ///////////////////////////////////////////////////////////////////////////////
1856: #define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \
1857:     do { \
1858:         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \
1859:         catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \
1860:         INTERNAL_CATCH_REACT( catchAssertionHandler ) \
1861:     } while( false )
1862: 
1863: ///////////////////////////////////////////////////////////////////////////////
1864: #define INTERNAL_CATCH_CAPTURE( varName, macroName, ... ) \
1865:     auto varName = Catch::Capturer( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info, #__VA_ARGS__ ); \
1866:     varName.captureValues( 0, __VA_ARGS__ )
1867: 
1868: ///////////////////////////////////////////////////////////////////////////////
1869: #define INTERNAL_CATCH_INFO( macroName, log ) \
1870:     Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log );
1871: 
1872: ///////////////////////////////////////////////////////////////////////////////
1873: // Although this is matcher-based, it can be used with just a string
1874: #define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \
1875:     do { \
1876:         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
1877:         if( catchAssertionHandler.allowThrows() ) \
1878:             try { \
1879:                 static_cast<void>(__VA_ARGS__); \
1880:                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
1881:             } \
1882:             catch( ... ) { \
1883:                 Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, #matcher##_catch_sr ); \
1884:             } \
1885:         else \
1886:             catchAssertionHandler.handleThrowingCallSkipped(); \
1887:         INTERNAL_CATCH_REACT( catchAssertionHandler ) \
1888:     } while( false )
1889: 
1890: #endif // CATCH_CONFIG_DISABLE
1891: 
1892: // end catch_capture.hpp
1893: // start catch_section.h
1894: 
1895: // start catch_section_info.h
1896: 
1897: // start catch_totals.h
1898: 
1899: #include <cstddef>
1900: 
1901: namespace Catch {
1902: 
1903:     struct Counts {
1904:         Counts operator - ( Counts const& other ) const;
1905:         Counts& operator += ( Counts const& other );
1906: 
1907:         std::size_t total() const;
1908:         bool allPassed() const;
1909:         bool allOk() const;
1910: 
1911:         std::size_t passed = 0;
1912:         std::size_t failed = 0;
1913:         std::size_t failedButOk = 0;
1914:     };
1915: 
1916:     struct Totals {
1917: 
1918:         Totals operator - ( Totals const& other ) const;
1919:         Totals& operator += ( Totals const& other );
1920: 
1921:         Totals delta( Totals const& prevTotals ) const;
1922: 
1923:         int error = 0;
1924:         Counts assertions;
1925:         Counts testCases;
1926:     };
1927: }
1928: 
1929: // end catch_totals.h
1930: #include <string>
1931: 
1932: namespace Catch {
1933: 
1934:     struct SectionInfo {
1935:         SectionInfo
1936:             (   SourceLineInfo const& _lineInfo,
1937:                 std::string const& _name );
1938: 
1939:         // Deprecated
1940:         SectionInfo
1941:             (   SourceLineInfo const& _lineInfo,
1942:                 std::string const& _name,
1943:                 std::string const& ) : SectionInfo( _lineInfo, _name ) {}
1944: 
1945:         std::string name;
1946:         std::string description; // !Deprecated: this will always be empty
1947:         SourceLineInfo lineInfo;
1948:     };
1949: 
1950:     struct SectionEndInfo {
1951:         SectionInfo sectionInfo;
1952:         Counts prevAssertions;
1953:         double durationInSeconds;
1954:     };
1955: 
1956: } // end namespace Catch
1957: 
1958: // end catch_section_info.h
1959: // start catch_timer.h
1960: 
1961: #include <cstdint>
1962: 
1963: namespace Catch {
1964: 
1965:     auto getCurrentNanosecondsSinceEpoch() -> uint64_t;
1966:     auto getEstimatedClockResolution() -> uint64_t;
1967: 
1968:     class Timer {
1969:         uint64_t m_nanoseconds = 0;
1970:     public:
1971:         void start();
1972:         auto getElapsedNanoseconds() const -> uint64_t;
1973:         auto getElapsedMicroseconds() const -> uint64_t;
1974:         auto getElapsedMilliseconds() const -> unsigned int;
1975:         auto getElapsedSeconds() const -> double;
1976:     };
1977: 
1978: } // namespace Catch
1979: 
1980: // end catch_timer.h
1981: #include <string>
1982: 
1983: namespace Catch {
1984: 
1985:     class Section : NonCopyable {
1986:     public:
1987:         Section( SectionInfo const& info );
1988:         ~Section();
1989: 
1990:         // This indicates whether the section should be executed or not
1991:         explicit operator bool() const;
1992: 
1993:     private:
1994:         SectionInfo m_info;
1995: 
1996:         std::string m_name;
1997:         Counts m_assertions;
1998:         bool m_sectionIncluded;
1999:         Timer m_timer;
2000:     };
2001: 
2002: } // end namespace Catch
2003: 
2004: #define INTERNAL_CATCH_SECTION( ... ) \
2005:     CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
2006:     if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \
2007:     CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS
2008: 
2009: #define INTERNAL_CATCH_DYNAMIC_SECTION( ... ) \
2010:     CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
2011:     if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, (Catch::ReusableStringStream() << __VA_ARGS__).str() ) ) \
2012:     CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS
2013: 
2014: // end catch_section.h
2015: // start catch_benchmark.h
2016: 
2017: #include <cstdint>
2018: #include <string>
2019: 
2020: namespace Catch {
2021: 
2022:     class BenchmarkLooper {
2023: 
2024:         std::string m_name;
2025:         std::size_t m_count = 0;
2026:         std::size_t m_iterationsToRun = 1;
2027:         uint64_t m_resolution;
2028:         Timer m_timer;
2029: 
2030:         static auto getResolution() -> uint64_t;
2031:     public:
2032:         // Keep most of this inline as it's on the code path that is being timed
2033:         BenchmarkLooper( StringRef name )
2034:         :   m_name( name ),
2035:             m_resolution( getResolution() )
2036:         {
2037:             reportStart();
2038:             m_timer.start();
2039:         }
2040: 
2041:         explicit operator bool() {
2042:             if( m_count < m_iterationsToRun )
2043:                 return true;
2044:             return needsMoreIterations();
2045:         }
2046: 
2047:         void increment() {
2048:             ++m_count;
2049:         }
2050: 
2051:         void reportStart();
2052:         auto needsMoreIterations() -> bool;
2053:     };
2054: 
2055: } // end namespace Catch
2056: 
2057: #define BENCHMARK( name ) \
2058:     for( Catch::BenchmarkLooper looper( name ); looper; looper.increment() )
2059: 
2060: // end catch_benchmark.h
2061: // start catch_interfaces_exception.h
2062: 
2063: // start catch_interfaces_registry_hub.h
2064: 
2065: #include <string>
2066: #include <memory>
2067: 
2068: namespace Catch {
2069: 
2070:     class TestCase;
2071:     struct ITestCaseRegistry;
2072:     struct IExceptionTranslatorRegistry;
2073:     struct IExceptionTranslator;
2074:     struct IReporterRegistry;
2075:     struct IReporterFactory;
2076:     struct ITagAliasRegistry;
2077:     class StartupExceptionRegistry;
2078: 
2079:     using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;
2080: 
2081:     struct IRegistryHub {
2082:         virtual ~IRegistryHub();
2083: 
2084:         virtual IReporterRegistry const& getReporterRegistry() const = 0;
2085:         virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
2086:         virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;
2087: 
2088:         virtual IExceptionTranslatorRegistry const& getExceptionTranslatorRegistry() const = 0;
2089: 
2090:         virtual StartupExceptionRegistry const& getStartupExceptionRegistry() const = 0;
2091:     };
2092: 
2093:     struct IMutableRegistryHub {
2094:         virtual ~IMutableRegistryHub();
2095:         virtual void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) = 0;
2096:         virtual void registerListener( IReporterFactoryPtr const& factory ) = 0;
2097:         virtual void registerTest( TestCase const& testInfo ) = 0;
2098:         virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
2099:         virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;
2100:         virtual void registerStartupException() noexcept = 0;
2101:     };
2102: 
2103:     IRegistryHub const& getRegistryHub();
2104:     IMutableRegistryHub& getMutableRegistryHub();
2105:     void cleanUp();
2106:     std::string translateActiveException();
2107: 
2108: }
2109: 
2110: // end catch_interfaces_registry_hub.h
2111: #if defined(CATCH_CONFIG_DISABLE)
2112:     #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \
2113:         static std::string translatorName( signature )
2114: #endif
2115: 
2116: #include <exception>
2117: #include <string>
2118: #include <vector>
2119: 
2120: namespace Catch {
2121:     using exceptionTranslateFunction = std::string(*)();
2122: 
2123:     struct IExceptionTranslator;
2124:     using ExceptionTranslators = std::vector<std::unique_ptr<IExceptionTranslator const>>;
2125: 
2126:     struct IExceptionTranslator {
2127:         virtual ~IExceptionTranslator();
2128:         virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
2129:     };
2130: 
2131:     struct IExceptionTranslatorRegistry {
2132:         virtual ~IExceptionTranslatorRegistry();
2133: 
2134:         virtual std::string translateActiveException() const = 0;
2135:     };
2136: 
2137:     class ExceptionTranslatorRegistrar {
2138:         template<typename T>
2139:         class ExceptionTranslator : public IExceptionTranslator {
2140:         public:
2141: 
2142:             ExceptionTranslator( std::string(*translateFunction)( T& ) )
2143:             : m_translateFunction( translateFunction )
2144:             {}
2145: 
2146:             std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {
2147:                 try {
2148:                     if( it == itEnd )
2149:                         std::rethrow_exception(std::current_exception());
2150:                     else
2151:                         return (*it)->translate( it+1, itEnd );
2152:                 }
2153:                 catch( T& ex ) {
2154:                     return m_translateFunction( ex );
2155:                 }
2156:             }
2157: 
2158:         protected:
2159:             std::string(*m_translateFunction)( T& );
2160:         };
2161: 
2162:     public:
2163:         template<typename T>
2164:         ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
2165:             getMutableRegistryHub().registerTranslator
2166:                 ( new ExceptionTranslator<T>( translateFunction ) );
2167:         }
2168:     };
2169: }
2170: 
2171: ///////////////////////////////////////////////////////////////////////////////
2172: #define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
2173:     static std::string translatorName( signature ); \
2174:     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
2175:     namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); } \
2176:     CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \
2177:     static std::string translatorName( signature )
2178: 
2179: #define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
2180: 
2181: // end catch_interfaces_exception.h
2182: // start catch_approx.h
2183: 
2184: #include <type_traits>
2185: 
2186: namespace Catch {
2187: namespace Detail {
2188: 
2189:     class Approx {
2190:     private:
2191:         bool equalityComparisonImpl(double other) const;
2192:         // Validates the new margin (margin >= 0)
2193:         // out-of-line to avoid including stdexcept in the header
2194:         void setMargin(double margin);
2195:         // Validates the new epsilon (0 < epsilon < 1)
2196:         // out-of-line to avoid including stdexcept in the header
2197:         void setEpsilon(double epsilon);
2198: 
2199:     public:
2200:         explicit Approx ( double value );
2201: 
2202:         static Approx custom();
2203: 
2204:         Approx operator-() const;
2205: 
2206:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2207:         Approx operator()( T const& value ) {
2208:             Approx approx( static_cast<double>(value) );
2209:             approx.m_epsilon = m_epsilon;
2210:             approx.m_margin = m_margin;
2211:             approx.m_scale = m_scale;
2212:             return approx;
2213:         }
2214: 
2215:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2216:         explicit Approx( T const& value ): Approx(static_cast<double>(value))
2217:         {}
2218: 
2219:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2220:         friend bool operator == ( const T& lhs, Approx const& rhs ) {
2221:             auto lhs_v = static_cast<double>(lhs);
2222:             return rhs.equalityComparisonImpl(lhs_v);
2223:         }
2224: 
2225:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2226:         friend bool operator == ( Approx const& lhs, const T& rhs ) {
2227:             return operator==( rhs, lhs );
2228:         }
2229: 
2230:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2231:         friend bool operator != ( T const& lhs, Approx const& rhs ) {
2232:             return !operator==( lhs, rhs );
2233:         }
2234: 
2235:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2236:         friend bool operator != ( Approx const& lhs, T const& rhs ) {
2237:             return !operator==( rhs, lhs );
2238:         }
2239: 
2240:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2241:         friend bool operator <= ( T const& lhs, Approx const& rhs ) {
2242:             return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;
2243:         }
2244: 
2245:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2246:         friend bool operator <= ( Approx const& lhs, T const& rhs ) {
2247:             return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;
2248:         }
2249: 
2250:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2251:         friend bool operator >= ( T const& lhs, Approx const& rhs ) {
2252:             return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;
2253:         }
2254: 
2255:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2256:         friend bool operator >= ( Approx const& lhs, T const& rhs ) {
2257:             return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;
2258:         }
2259: 
2260:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2261:         Approx& epsilon( T const& newEpsilon ) {
2262:             double epsilonAsDouble = static_cast<double>(newEpsilon);
2263:             setEpsilon(epsilonAsDouble);
2264:             return *this;
2265:         }
2266: 
2267:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2268:         Approx& margin( T const& newMargin ) {
2269:             double marginAsDouble = static_cast<double>(newMargin);
2270:             setMargin(marginAsDouble);
2271:             return *this;
2272:         }
2273: 
2274:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
2275:         Approx& scale( T const& newScale ) {
2276:             m_scale = static_cast<double>(newScale);
2277:             return *this;
2278:         }
2279: 
2280:         std::string toString() const;
2281: 
2282:     private:
2283:         double m_epsilon;
2284:         double m_margin;
2285:         double m_scale;
2286:         double m_value;
2287:     };
2288: } // end namespace Detail
2289: 
2290: namespace literals {
2291:     Detail::Approx operator "" _a(long double val);
2292:     Detail::Approx operator "" _a(unsigned long long val);
2293: } // end namespace literals
2294: 
2295: template<>
2296: struct StringMaker<Catch::Detail::Approx> {
2297:     static std::string convert(Catch::Detail::Approx const& value);
2298: };
2299: 
2300: } // end namespace Catch
2301: 
2302: // end catch_approx.h
2303: // start catch_string_manip.h
2304: 
2305: #include <string>
2306: #include <iosfwd>
2307: 
2308: namespace Catch {
2309: 
2310:     bool startsWith( std::string const& s, std::string const& prefix );
2311:     bool startsWith( std::string const& s, char prefix );
2312:     bool endsWith( std::string const& s, std::string const& suffix );
2313:     bool endsWith( std::string const& s, char suffix );
2314:     bool contains( std::string const& s, std::string const& infix );
2315:     void toLowerInPlace( std::string& s );
2316:     std::string toLower( std::string const& s );
2317:     std::string trim( std::string const& str );
2318:     bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );
2319: 
2320:     struct pluralise {
2321:         pluralise( std::size_t count, std::string const& label );
2322: 
2323:         friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );
2324: 
2325:         std::size_t m_count;
2326:         std::string m_label;
2327:     };
2328: }
2329: 
2330: // end catch_string_manip.h
2331: #ifndef CATCH_CONFIG_DISABLE_MATCHERS
2332: // start catch_capture_matchers.h
2333: 
2334: // start catch_matchers.h
2335: 
2336: #include <string>
2337: #include <vector>
2338: 
2339: namespace Catch {
2340: namespace Matchers {
2341:     namespace Impl {
2342: 
2343:         template<typename ArgT> struct MatchAllOf;
2344:         template<typename ArgT> struct MatchAnyOf;
2345:         template<typename ArgT> struct MatchNotOf;
2346: 
2347:         class MatcherUntypedBase {
2348:         public:
2349:             MatcherUntypedBase() = default;
2350:             MatcherUntypedBase ( MatcherUntypedBase const& ) = default;
2351:             MatcherUntypedBase& operator = ( MatcherUntypedBase const& ) = delete;
2352:             std::string toString() const;
2353: 
2354:         protected:
2355:             virtual ~MatcherUntypedBase();
2356:             virtual std::string describe() const = 0;
2357:             mutable std::string m_cachedToString;
2358:         };
2359: 
2360: #ifdef __clang__
2361: #    pragma clang diagnostic push
2362: #    pragma clang diagnostic ignored "-Wnon-virtual-dtor"
2363: #endif
2364: 
2365:         template<typename ObjectT>
2366:         struct MatcherMethod {
2367:             virtual bool match( ObjectT const& arg ) const = 0;
2368:         };
2369:         template<typename PtrT>
2370:         struct MatcherMethod<PtrT*> {
2371:             virtual bool match( PtrT* arg ) const = 0;
2372:         };
2373: 
2374: #ifdef __clang__
2375: #    pragma clang diagnostic pop
2376: #endif
2377: 
2378:         template<typename T>
2379:         struct MatcherBase : MatcherUntypedBase, MatcherMethod<T> {
2380: 
2381:             MatchAllOf<T> operator && ( MatcherBase const& other ) const;
2382:             MatchAnyOf<T> operator || ( MatcherBase const& other ) const;
2383:             MatchNotOf<T> operator ! () const;
2384:         };
2385: 
2386:         template<typename ArgT>
2387:         struct MatchAllOf : MatcherBase<ArgT> {
2388:             bool match( ArgT const& arg ) const override {
2389:                 for( auto matcher : m_matchers ) {
2390:                     if (!matcher->match(arg))
2391:                         return false;
2392:                 }
2393:                 return true;
2394:             }
2395:             std::string describe() const override {
2396:                 std::string description;
2397:                 description.reserve( 4 + m_matchers.size()*32 );
2398:                 description += "( ";
2399:                 bool first = true;
2400:                 for( auto matcher : m_matchers ) {
2401:                     if( first )
2402:                         first = false;
2403:                     else
2404:                         description += " and ";
2405:                     description += matcher->toString();
2406:                 }
2407:                 description += " )";
2408:                 return description;
2409:             }
2410: 
2411:             MatchAllOf<ArgT>& operator && ( MatcherBase<ArgT> const& other ) {
2412:                 m_matchers.push_back( &other );
2413:                 return *this;
2414:             }
2415: 
2416:             std::vector<MatcherBase<ArgT> const*> m_matchers;
2417:         };
2418:         template<typename ArgT>
2419:         struct MatchAnyOf : MatcherBase<ArgT> {
2420: 
2421:             bool match( ArgT const& arg ) const override {
2422:                 for( auto matcher : m_matchers ) {
2423:                     if (matcher->match(arg))
2424:                         return true;
2425:                 }
2426:                 return false;
2427:             }
2428:             std::string describe() const override {
2429:                 std::string description;
2430:                 description.reserve( 4 + m_matchers.size()*32 );
2431:                 description += "( ";
2432:                 bool first = true;
2433:                 for( auto matcher : m_matchers ) {
2434:                     if( first )
2435:                         first = false;
2436:                     else
2437:                         description += " or ";
2438:                     description += matcher->toString();
2439:                 }
2440:                 description += " )";
2441:                 return description;
2442:             }
2443: 
2444:             MatchAnyOf<ArgT>& operator || ( MatcherBase<ArgT> const& other ) {
2445:                 m_matchers.push_back( &other );
2446:                 return *this;
2447:             }
2448: 
2449:             std::vector<MatcherBase<ArgT> const*> m_matchers;
2450:         };
2451: 
2452:         template<typename ArgT>
2453:         struct MatchNotOf : MatcherBase<ArgT> {
2454: 
2455:             MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
2456: 
2457:             bool match( ArgT const& arg ) const override {
2458:                 return !m_underlyingMatcher.match( arg );
2459:             }
2460: 
2461:             std::string describe() const override {
2462:                 return "not " + m_underlyingMatcher.toString();
2463:             }
2464:             MatcherBase<ArgT> const& m_underlyingMatcher;
2465:         };
2466: 
2467:         template<typename T>
2468:         MatchAllOf<T> MatcherBase<T>::operator && ( MatcherBase const& other ) const {
2469:             return MatchAllOf<T>() && *this && other;
2470:         }
2471:         template<typename T>
2472:         MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase const& other ) const {
2473:             return MatchAnyOf<T>() || *this || other;
2474:         }
2475:         template<typename T>
2476:         MatchNotOf<T> MatcherBase<T>::operator ! () const {
2477:             return MatchNotOf<T>( *this );
2478:         }
2479: 
2480:     } // namespace Impl
2481: 
2482: } // namespace Matchers
2483: 
2484: using namespace Matchers;
2485: using Matchers::Impl::MatcherBase;
2486: 
2487: } // namespace Catch
2488: 
2489: // end catch_matchers.h
2490: // start catch_matchers_floating.h
2491: 
2492: #include <type_traits>
2493: #include <cmath>
2494: 
2495: namespace Catch {
2496: namespace Matchers {
2497: 
2498:     namespace Floating {
2499: 
2500:         enum class FloatingPointKind : uint8_t;
2501: 
2502:         struct WithinAbsMatcher : MatcherBase<double> {
2503:             WithinAbsMatcher(double target, double margin);
2504:             bool match(double const& matchee) const override;
2505:             std::string describe() const override;
2506:         private:
2507:             double m_target;
2508:             double m_margin;
2509:         };
2510: 
2511:         struct WithinUlpsMatcher : MatcherBase<double> {
2512:             WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType);
2513:             bool match(double const& matchee) const override;
2514:             std::string describe() const override;
2515:         private:
2516:             double m_target;
2517:             int m_ulps;
2518:             FloatingPointKind m_type;
2519:         };
2520: 
2521:     } // namespace Floating
2522: 
2523:     // The following functions create the actual matcher objects.
2524:     // This allows the types to be inferred
2525:     Floating::WithinUlpsMatcher WithinULP(double target, int maxUlpDiff);
2526:     Floating::WithinUlpsMatcher WithinULP(float target, int maxUlpDiff);
2527:     Floating::WithinAbsMatcher WithinAbs(double target, double margin);
2528: 
2529: } // namespace Matchers
2530: } // namespace Catch
2531: 
2532: // end catch_matchers_floating.h
2533: // start catch_matchers_generic.hpp
2534: 
2535: #include <functional>
2536: #include <string>
2537: 
2538: namespace Catch {
2539: namespace Matchers {
2540: namespace Generic {
2541: 
2542: namespace Detail {
2543:     std::string finalizeDescription(const std::string& desc);
2544: }
2545: 
2546: template <typename T>
2547: class PredicateMatcher : public MatcherBase<T> {
2548:     std::function<bool(T const&)> m_predicate;
2549:     std::string m_description;
2550: public:
2551: 
2552:     PredicateMatcher(std::function<bool(T const&)> const& elem, std::string const& descr)
2553:         :m_predicate(std::move(elem)),
2554:         m_description(Detail::finalizeDescription(descr))
2555:     {}
2556: 
2557:     bool match( T const& item ) const override {
2558:         return m_predicate(item);
2559:     }
2560: 
2561:     std::string describe() const override {
2562:         return m_description;
2563:     }
2564: };
2565: 
2566: } // namespace Generic
2567: 
2568:     // The following functions create the actual matcher objects.
2569:     // The user has to explicitly specify type to the function, because
2570:     // infering std::function<bool(T const&)> is hard (but possible) and
2571:     // requires a lot of TMP.
2572:     template<typename T>
2573:     Generic::PredicateMatcher<T> Predicate(std::function<bool(T const&)> const& predicate, std::string const& description = "") {
2574:         return Generic::PredicateMatcher<T>(predicate, description);
2575:     }
2576: 
2577: } // namespace Matchers
2578: } // namespace Catch
2579: 
2580: // end catch_matchers_generic.hpp
2581: // start catch_matchers_string.h
2582: 
2583: #include <string>
2584: 
2585: namespace Catch {
2586: namespace Matchers {
2587: 
2588:     namespace StdString {
2589: 
2590:         struct CasedString
2591:         {
2592:             CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );
2593:             std::string adjustString( std::string const& str ) const;
2594:             std::string caseSensitivitySuffix() const;
2595: 
2596:             CaseSensitive::Choice m_caseSensitivity;
2597:             std::string m_str;
2598:         };
2599: 
2600:         struct StringMatcherBase : MatcherBase<std::string> {
2601:             StringMatcherBase( std::string const& operation, CasedString const& comparator );
2602:             std::string describe() const override;
2603: 
2604:             CasedString m_comparator;
2605:             std::string m_operation;
2606:         };
2607: 
2608:         struct EqualsMatcher : StringMatcherBase {
2609:             EqualsMatcher( CasedString const& comparator );
2610:             bool match( std::string const& source ) const override;
2611:         };
2612:         struct ContainsMatcher : StringMatcherBase {
2613:             ContainsMatcher( CasedString const& comparator );
2614:             bool match( std::string const& source ) const override;
2615:         };
2616:         struct StartsWithMatcher : StringMatcherBase {
2617:             StartsWithMatcher( CasedString const& comparator );
2618:             bool match( std::string const& source ) const override;
2619:         };
2620:         struct EndsWithMatcher : StringMatcherBase {
2621:             EndsWithMatcher( CasedString const& comparator );
2622:             bool match( std::string const& source ) const override;
2623:         };
2624: 
2625:         struct RegexMatcher : MatcherBase<std::string> {
2626:             RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );
2627:             bool match( std::string const& matchee ) const override;
2628:             std::string describe() const override;
2629: 
2630:         private:
2631:             std::string m_regex;
2632:             CaseSensitive::Choice m_caseSensitivity;
2633:         };
2634: 
2635:     } // namespace StdString
2636: 
2637:     // The following functions create the actual matcher objects.
2638:     // This allows the types to be inferred
2639: 
2640:     StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2641:     StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2642:     StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2643:     StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2644:     StdString::RegexMatcher Matches( std::string const& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
2645: 
2646: } // namespace Matchers
2647: } // namespace Catch
2648: 
2649: // end catch_matchers_string.h
2650: // start catch_matchers_vector.h
2651: 
2652: #include <algorithm>
2653: 
2654: namespace Catch {
2655: namespace Matchers {
2656: 
2657:     namespace Vector {
2658:         namespace Detail {
2659:             template <typename InputIterator, typename T>
2660:             size_t count(InputIterator first, InputIterator last, T const& item) {
2661:                 size_t cnt = 0;
2662:                 for (; first != last; ++first) {
2663:                     if (*first == item) {
2664:                         ++cnt;
2665:                     }
2666:                 }
2667:                 return cnt;
2668:             }
2669:             template <typename InputIterator, typename T>
2670:             bool contains(InputIterator first, InputIterator last, T const& item) {
2671:                 for (; first != last; ++first) {
2672:                     if (*first == item) {
2673:                         return true;
2674:                     }
2675:                 }
2676:                 return false;
2677:             }
2678:         }
2679: 
2680:         template<typename T>
2681:         struct ContainsElementMatcher : MatcherBase<std::vector<T>> {
2682: 
2683:             ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}
2684: 
2685:             bool match(std::vector<T> const &v) const override {
2686:                 for (auto const& el : v) {
2687:                     if (el == m_comparator) {
2688:                         return true;
2689:                     }
2690:                 }
2691:                 return false;
2692:             }
2693: 
2694:             std::string describe() const override {
2695:                 return "Contains: " + ::Catch::Detail::stringify( m_comparator );
2696:             }
2697: 
2698:             T const& m_comparator;
2699:         };
2700: 
2701:         template<typename T>
2702:         struct ContainsMatcher : MatcherBase<std::vector<T>> {
2703: 
2704:             ContainsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}
2705: 
2706:             bool match(std::vector<T> const &v) const override {
2707:                 // !TBD: see note in EqualsMatcher
2708:                 if (m_comparator.size() > v.size())
2709:                     return false;
2710:                 for (auto const& comparator : m_comparator) {
2711:                     auto present = false;
2712:                     for (const auto& el : v) {
2713:                         if (el == comparator) {
2714:                             present = true;
2715:                             break;
2716:                         }
2717:                     }
2718:                     if (!present) {
2719:                         return false;
2720:                     }
2721:                 }
2722:                 return true;
2723:             }
2724:             std::string describe() const override {
2725:                 return "Contains: " + ::Catch::Detail::stringify( m_comparator );
2726:             }
2727: 
2728:             std::vector<T> const& m_comparator;
2729:         };
2730: 
2731:         template<typename T>
2732:         struct EqualsMatcher : MatcherBase<std::vector<T>> {
2733: 
2734:             EqualsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}
2735: 
2736:             bool match(std::vector<T> const &v) const override {
2737:                 // !TBD: This currently works if all elements can be compared using !=
2738:                 // - a more general approach would be via a compare template that defaults
2739:                 // to using !=. but could be specialised for, e.g. std::vector<T> etc
2740:                 // - then just call that directly
2741:                 if (m_comparator.size() != v.size())
2742:                     return false;
2743:                 for (std::size_t i = 0; i < v.size(); ++i)
2744:                     if (m_comparator[i] != v[i])
2745:                         return false;
2746:                 return true;
2747:             }
2748:             std::string describe() const override {
2749:                 return "Equals: " + ::Catch::Detail::stringify( m_comparator );
2750:             }
2751:             std::vector<T> const& m_comparator;
2752:         };
2753: 
2754:         template<typename T>
2755:         struct UnorderedEqualsMatcher : MatcherBase<std::vector<T>> {
2756:             UnorderedEqualsMatcher(std::vector<T> const& target) : m_target(target) {}
2757:             bool match(std::vector<T> const& vec) const override {
2758:                 // Note: This is a reimplementation of std::is_permutation,
2759:                 //       because I don't want to include <algorithm> inside the common path
2760:                 if (m_target.size() != vec.size()) {
2761:                     return false;
2762:                 }
2763:                 auto lfirst = m_target.begin(), llast = m_target.end();
2764:                 auto rfirst = vec.begin(), rlast = vec.end();
2765:                 // Cut common prefix to optimize checking of permuted parts
2766:                 while (lfirst != llast && *lfirst != *rfirst) {
2767:                     ++lfirst; ++rfirst;
2768:                 }
2769:                 if (lfirst == llast) {
2770:                     return true;
2771:                 }
2772: 
2773:                 for (auto mid = lfirst; mid != llast; ++mid) {
2774:                     // Skip already counted items
2775:                     if (Detail::contains(lfirst, mid, *mid)) {
2776:                         continue;
2777:                     }
2778:                     size_t num_vec = Detail::count(rfirst, rlast, *mid);
2779:                     if (num_vec == 0 || Detail::count(lfirst, llast, *mid) != num_vec) {
2780:                         return false;
2781:                     }
2782:                 }
2783: 
2784:                 return true;
2785:             }
2786: 
2787:             std::string describe() const override {
2788:                 return "UnorderedEquals: " + ::Catch::Detail::stringify(m_target);
2789:             }
2790:         private:
2791:             std::vector<T> const& m_target;
2792:         };
2793: 
2794:     } // namespace Vector
2795: 
2796:     // The following functions create the actual matcher objects.
2797:     // This allows the types to be inferred
2798: 
2799:     template<typename T>
2800:     Vector::ContainsMatcher<T> Contains( std::vector<T> const& comparator ) {
2801:         return Vector::ContainsMatcher<T>( comparator );
2802:     }
2803: 
2804:     template<typename T>
2805:     Vector::ContainsElementMatcher<T> VectorContains( T const& comparator ) {
2806:         return Vector::ContainsElementMatcher<T>( comparator );
2807:     }
2808: 
2809:     template<typename T>
2810:     Vector::EqualsMatcher<T> Equals( std::vector<T> const& comparator ) {
2811:         return Vector::EqualsMatcher<T>( comparator );
2812:     }
2813: 
2814:     template<typename T>
2815:     Vector::UnorderedEqualsMatcher<T> UnorderedEquals(std::vector<T> const& target) {
2816:         return Vector::UnorderedEqualsMatcher<T>(target);
2817:     }
2818: 
2819: } // namespace Matchers
2820: } // namespace Catch
2821: 
2822: // end catch_matchers_vector.h
2823: namespace Catch {
2824: 
2825:     template<typename ArgT, typename MatcherT>
2826:     class MatchExpr : public ITransientExpression {
2827:         ArgT const& m_arg;
2828:         MatcherT m_matcher;
2829:         StringRef m_matcherString;
2830:     public:
2831:         MatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef const& matcherString )
2832:         :   ITransientExpression{ true, matcher.match( arg ) },
2833:             m_arg( arg ),
2834:             m_matcher( matcher ),
2835:             m_matcherString( matcherString )
2836:         {}
2837: 
2838:         void streamReconstructedExpression( std::ostream &os ) const override {
2839:             auto matcherAsString = m_matcher.toString();
2840:             os << Catch::Detail::stringify( m_arg ) << ' ';
2841:             if( matcherAsString == Detail::unprintableString )
2842:                 os << m_matcherString;
2843:             else
2844:                 os << matcherAsString;
2845:         }
2846:     };
2847: 
2848:     using StringMatcher = Matchers::Impl::MatcherBase<std::string>;
2849: 
2850:     void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef const& matcherString  );
2851: 
2852:     template<typename ArgT, typename MatcherT>
2853:     auto makeMatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef const& matcherString  ) -> MatchExpr<ArgT, MatcherT> {
2854:         return MatchExpr<ArgT, MatcherT>( arg, matcher, matcherString );
2855:     }
2856: 
2857: } // namespace Catch
2858: 
2859: ///////////////////////////////////////////////////////////////////////////////
2860: #define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \
2861:     do { \
2862:         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
2863:         INTERNAL_CATCH_TRY { \
2864:             catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, #matcher##_catch_sr ) ); \
2865:         } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
2866:         INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2867:     } while( false )
2868: 
2869: ///////////////////////////////////////////////////////////////////////////////
2870: #define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \
2871:     do { \
2872:         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(exceptionType) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
2873:         if( catchAssertionHandler.allowThrows() ) \
2874:             try { \
2875:                 static_cast<void>(__VA_ARGS__ ); \
2876:                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
2877:             } \
2878:             catch( exceptionType const& ex ) { \
2879:                 catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, #matcher##_catch_sr ) ); \
2880:             } \
2881:             catch( ... ) { \
2882:                 catchAssertionHandler.handleUnexpectedInflightException(); \
2883:             } \
2884:         else \
2885:             catchAssertionHandler.handleThrowingCallSkipped(); \
2886:         INTERNAL_CATCH_REACT( catchAssertionHandler ) \
2887:     } while( false )
2888: 
2889: // end catch_capture_matchers.h
2890: #endif
2891: // start catch_generators.hpp
2892: 
2893: // start catch_interfaces_generatortracker.h
2894: 
2895: 
2896: #include <memory>
2897: 
2898: namespace Catch {
2899: 
2900:     namespace Generators {
2901:         class GeneratorBase {
2902:         protected:
2903:             size_t m_size = 0;
2904: 
2905:         public:
2906:             GeneratorBase( size_t size ) : m_size( size ) {}
2907:             virtual ~GeneratorBase();
2908:             auto size() const -> size_t { return m_size; }
2909:         };
2910:         using GeneratorBasePtr = std::unique_ptr<GeneratorBase>;
2911: 
2912:     } // namespace Generators
2913: 
2914:     struct IGeneratorTracker {
2915:         virtual ~IGeneratorTracker();
2916:         virtual auto hasGenerator() const -> bool = 0;
2917:         virtual auto getGenerator() const -> Generators::GeneratorBasePtr const& = 0;
2918:         virtual void setGenerator( Generators::GeneratorBasePtr&& generator ) = 0;
2919:         virtual auto getIndex() const -> std::size_t = 0;
2920:     };
2921: 
2922: } // namespace Catch
2923: 
2924: // end catch_interfaces_generatortracker.h
2925: // start catch_enforce.h
2926: 
2927: #include <stdexcept>
2928: 
2929: namespace Catch {
2930: #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
2931:     template <typename Ex>
2932:     [[noreturn]]
2933:     void throw_exception(Ex const& e) {
2934:         throw e;
2935:     }
2936: #else // ^^ Exceptions are enabled //  Exceptions are disabled vv
2937:     [[noreturn]]
2938:     void throw_exception(std::exception const& e);
2939: #endif
2940: } // namespace Catch;
2941: 
2942: #define CATCH_PREPARE_EXCEPTION( type, msg ) \
2943:     type( ( Catch::ReusableStringStream() << msg ).str() )
2944: #define CATCH_INTERNAL_ERROR( msg ) \
2945:     Catch::throw_exception(CATCH_PREPARE_EXCEPTION( std::logic_error, CATCH_INTERNAL_LINEINFO << ": Internal Catch error: " << msg))
2946: #define CATCH_ERROR( msg ) \
2947:     Catch::throw_exception(CATCH_PREPARE_EXCEPTION( std::domain_error, msg ))
2948: #define CATCH_RUNTIME_ERROR( msg ) \
2949:     Catch::throw_exception(CATCH_PREPARE_EXCEPTION( std::runtime_error, msg ))
2950: #define CATCH_ENFORCE( condition, msg ) \
2951:     do{ if( !(condition) ) CATCH_ERROR( msg ); } while(false)
2952: 
2953: // end catch_enforce.h
2954: #include <memory>
2955: #include <vector>
2956: #include <cassert>
2957: 
2958: #include <utility>
2959: 
2960: namespace Catch {
2961: namespace Generators {
2962: 
2963:     // !TBD move this into its own location?
2964:     namespace pf{
2965:         template<typename T, typename... Args>
2966:         std::unique_ptr<T> make_unique( Args&&... args ) {
2967:             return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
2968:         }
2969:     }
2970: 
2971:     template<typename T>
2972:     struct IGenerator {
2973:         virtual ~IGenerator() {}
2974:         virtual auto get( size_t index ) const -> T = 0;
2975:     };
2976: 
2977:     template<typename T>
2978:     class SingleValueGenerator : public IGenerator<T> {
2979:         T m_value;
2980:     public:
2981:         SingleValueGenerator( T const& value ) : m_value( value ) {}
2982: 
2983:         auto get( size_t ) const -> T override {
2984:             return m_value;
2985:         }
2986:     };
2987: 
2988:     template<typename T>
2989:     class FixedValuesGenerator : public IGenerator<T> {
2990:         std::vector<T> m_values;
2991: 
2992:     public:
2993:         FixedValuesGenerator( std::initializer_list<T> values ) : m_values( values ) {}
2994: 
2995:         auto get( size_t index ) const -> T override {
2996:             return m_values[index];
2997:         }
2998:     };
2999: 
3000:     template<typename T>
3001:     class RangeGenerator : public IGenerator<T> {
3002:         T const m_first;
3003:         T const m_last;
3004: 
3005:     public:
3006:         RangeGenerator( T const& first, T const& last ) : m_first( first ), m_last( last ) {
3007:             assert( m_last > m_first );
3008:         }
3009: 
3010:         auto get( size_t index ) const -> T override {
3011:             // ToDo:: introduce a safe cast to catch potential overflows
3012:             return static_cast<T>(m_first+index);
3013:         }
3014:     };
3015: 
3016:     template<typename T>
3017:     struct NullGenerator : IGenerator<T> {
3018:         auto get( size_t ) const -> T override {
3019:             CATCH_INTERNAL_ERROR("A Null Generator is always empty");
3020:         }
3021:     };
3022: 
3023:     template<typename T>
3024:     class Generator {
3025:         std::unique_ptr<IGenerator<T>> m_generator;
3026:         size_t m_size;
3027: 
3028:     public:
3029:         Generator( size_t size, std::unique_ptr<IGenerator<T>> generator )
3030:         :   m_generator( std::move( generator ) ),
3031:             m_size( size )
3032:         {}
3033: 
3034:         auto size() const -> size_t { return m_size; }
3035:         auto operator[]( size_t index ) const -> T {
3036:             assert( index < m_size );
3037:             return m_generator->get( index );
3038:         }
3039:     };
3040: 
3041:     std::vector<size_t> randomiseIndices( size_t selectionSize, size_t sourceSize );
3042: 
3043:     template<typename T>
3044:     class GeneratorRandomiser : public IGenerator<T> {
3045:         Generator<T> m_baseGenerator;
3046: 
3047:         std::vector<size_t> m_indices;
3048:     public:
3049:         GeneratorRandomiser( Generator<T>&& baseGenerator, size_t numberOfItems )
3050:         :   m_baseGenerator( std::move( baseGenerator ) ),
3051:             m_indices( randomiseIndices( numberOfItems, m_baseGenerator.size() ) )
3052:         {}
3053: 
3054:         auto get( size_t index ) const -> T override {
3055:             return m_baseGenerator[m_indices[index]];
3056:         }
3057:     };
3058: 
3059:     template<typename T>
3060:     struct RequiresASpecialisationFor;
3061: 
3062:     template<typename T>
3063:     auto all() -> Generator<T> { return RequiresASpecialisationFor<T>(); }
3064: 
3065:     template<>
3066:     auto all<int>() -> Generator<int>;
3067: 
3068:     template<typename T>
3069:     auto range( T const& first, T const& last ) -> Generator<T> {
3070:         return Generator<T>( (last-first), pf::make_unique<RangeGenerator<T>>( first, last ) );
3071:     }
3072: 
3073:     template<typename T>
3074:     auto random( T const& first, T const& last ) -> Generator<T> {
3075:         auto gen = range( first, last );
3076:         auto size = gen.size();
3077: 
3078:         return Generator<T>( size, pf::make_unique<GeneratorRandomiser<T>>( std::move( gen ), size ) );
3079:     }
3080:     template<typename T>
3081:     auto random( size_t size ) -> Generator<T> {
3082:         return Generator<T>( size, pf::make_unique<GeneratorRandomiser<T>>( all<T>(), size ) );
3083:     }
3084: 
3085:     template<typename T>
3086:     auto values( std::initializer_list<T> values ) -> Generator<T> {
3087:         return Generator<T>( values.size(), pf::make_unique<FixedValuesGenerator<T>>( values ) );
3088:     }
3089:     template<typename T>
3090:     auto value( T const& val ) -> Generator<T> {
3091:         return Generator<T>( 1, pf::make_unique<SingleValueGenerator<T>>( val ) );
3092:     }
3093: 
3094:     template<typename T>
3095:     auto as() -> Generator<T> {
3096:         return Generator<T>( 0, pf::make_unique<NullGenerator<T>>() );
3097:     }
3098: 
3099:     template<typename... Ts>
3100:     auto table( std::initializer_list<std::tuple<Ts...>>&& tuples ) -> Generator<std::tuple<Ts...>> {
3101:         return values<std::tuple<Ts...>>( std::forward<std::initializer_list<std::tuple<Ts...>>>( tuples ) );
3102:     }
3103: 
3104:     template<typename T>
3105:     struct Generators : GeneratorBase {
3106:         std::vector<Generator<T>> m_generators;
3107: 
3108:         using type = T;
3109: 
3110:         Generators() : GeneratorBase( 0 ) {}
3111: 
3112:         void populate( T&& val ) {
3113:             m_size += 1;
3114:             m_generators.emplace_back( value( std::move( val ) ) );
3115:         }
3116:         template<typename U>
3117:         void populate( U&& val ) {
3118:             populate( T( std::move( val ) ) );
3119:         }
3120:         void populate( Generator<T>&& generator ) {
3121:             m_size += generator.size();
3122:             m_generators.emplace_back( std::move( generator ) );
3123:         }
3124: 
3125:         template<typename U, typename... Gs>
3126:         void populate( U&& valueOrGenerator, Gs... moreGenerators ) {
3127:             populate( std::forward<U>( valueOrGenerator ) );
3128:             populate( std::forward<Gs>( moreGenerators )... );
3129:         }
3130: 
3131:         auto operator[]( size_t index ) const -> T {
3132:             size_t sizes = 0;
3133:             for( auto const& gen : m_generators ) {
3134:                 auto localIndex = index-sizes;
3135:                 sizes += gen.size();
3136:                 if( index < sizes )
3137:                     return gen[localIndex];
3138:             }
3139:             CATCH_INTERNAL_ERROR("Index '" << index << "' is out of range (" << sizes << ')');
3140:         }
3141:     };
3142: 
3143:     template<typename T, typename... Gs>
3144:     auto makeGenerators( Generator<T>&& generator, Gs... moreGenerators ) -> Generators<T> {
3145:         Generators<T> generators;
3146:         generators.m_generators.reserve( 1+sizeof...(Gs) );
3147:         generators.populate( std::move( generator ), std::forward<Gs>( moreGenerators )... );
3148:         return generators;
3149:     }
3150:     template<typename T>
3151:     auto makeGenerators( Generator<T>&& generator ) -> Generators<T> {
3152:         Generators<T> generators;
3153:         generators.populate( std::move( generator ) );
3154:         return generators;
3155:     }
3156:     template<typename T, typename... Gs>
3157:     auto makeGenerators( T&& val, Gs... moreGenerators ) -> Generators<T> {
3158:         return makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );
3159:     }
3160:     template<typename T, typename U, typename... Gs>
3161:     auto makeGenerators( U&& val, Gs... moreGenerators ) -> Generators<T> {
3162:         return makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );
3163:     }
3164: 
3165:     auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker&;
3166: 
3167:     template<typename L>
3168:     // Note: The type after -> is weird, because VS2015 cannot parse
3169:     //       the expression used in the typedef inside, when it is in
3170:     //       return type. Yeah, ¯\_(ツ)_/¯
3171:     auto generate( SourceLineInfo const& lineInfo, L const& generatorExpression ) -> decltype(std::declval<decltype(generatorExpression())>()[0]) {
3172:         using UnderlyingType = typename decltype(generatorExpression())::type;
3173: 
3174:         IGeneratorTracker& tracker = acquireGeneratorTracker( lineInfo );
3175:         if( !tracker.hasGenerator() )
3176:             tracker.setGenerator( pf::make_unique<Generators<UnderlyingType>>( generatorExpression() ) );
3177: 
3178:         auto const& generator = static_cast<Generators<UnderlyingType> const&>( *tracker.getGenerator() );
3179:         return generator[tracker.getIndex()];
3180:     }
3181: 
3182: } // namespace Generators
3183: } // namespace Catch
3184: 
3185: #define GENERATE( ... ) \
3186:     Catch::Generators::generate( CATCH_INTERNAL_LINEINFO, []{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } )
3187: 
3188: // end catch_generators.hpp
3189: 
3190: // These files are included here so the single_include script doesn't put them
3191: // in the conditionally compiled sections
3192: // start catch_test_case_info.h
3193: 
3194: #include <string>
3195: #include <vector>
3196: #include <memory>
3197: 
3198: #ifdef __clang__
3199: #pragma clang diagnostic push
3200: #pragma clang diagnostic ignored "-Wpadded"
3201: #endif
3202: 
3203: namespace Catch {
3204: 
3205:     struct ITestInvoker;
3206: 
3207:     struct TestCaseInfo {
3208:         enum SpecialProperties{
3209:             None = 0,
3210:             IsHidden = 1 << 1,
3211:             ShouldFail = 1 << 2,
3212:             MayFail = 1 << 3,
3213:             Throws = 1 << 4,
3214:             NonPortable = 1 << 5,
3215:             Benchmark = 1 << 6
3216:         };
3217: 
3218:         TestCaseInfo(   std::string const& _name,
3219:                         std::string const& _className,
3220:                         std::string const& _description,
3221:                         std::vector<std::string> const& _tags,
3222:                         SourceLineInfo const& _lineInfo );
3223: 
3224:         friend void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags );
3225: 
3226:         bool isHidden() const;
3227:         bool throws() const;
3228:         bool okToFail() const;
3229:         bool expectedToFail() const;
3230: 
3231:         std::string tagsAsString() const;
3232: 
3233:         std::string name;
3234:         std::string className;
3235:         std::string description;
3236:         std::vector<std::string> tags;
3237:         std::vector<std::string> lcaseTags;
3238:         SourceLineInfo lineInfo;
3239:         SpecialProperties properties;
3240:     };
3241: 
3242:     class TestCase : public TestCaseInfo {
3243:     public:
3244: 
3245:         TestCase( ITestInvoker* testCase, TestCaseInfo&& info );
3246: 
3247:         TestCase withName( std::string const& _newName ) const;
3248: 
3249:         void invoke() const;
3250: 
3251:         TestCaseInfo const& getTestCaseInfo() const;
3252: 
3253:         bool operator == ( TestCase const& other ) const;
3254:         bool operator < ( TestCase const& other ) const;
3255: 
3256:     private:
3257:         std::shared_ptr<ITestInvoker> test;
3258:     };
3259: 
3260:     TestCase makeTestCase(  ITestInvoker* testCase,
3261:                             std::string const& className,
3262:                             NameAndTags const& nameAndTags,
3263:                             SourceLineInfo const& lineInfo );
3264: }
3265: 
3266: #ifdef __clang__
3267: #pragma clang diagnostic pop
3268: #endif
3269: 
3270: // end catch_test_case_info.h
3271: // start catch_interfaces_runner.h
3272: 
3273: namespace Catch {
3274: 
3275:     struct IRunner {
3276:         virtual ~IRunner();
3277:         virtual bool aborting() const = 0;
3278:     };
3279: }
3280: 
3281: // end catch_interfaces_runner.h
3282: 
3283: #ifdef __OBJC__
3284: // start catch_objc.hpp
3285: 
3286: #import <objc/runtime.h>
3287: 
3288: #include <string>
3289: 
3290: // NB. Any general catch headers included here must be included
3291: // in catch.hpp first to make sure they are included by the single
3292: // header for non obj-usage
3293: 
3294: ///////////////////////////////////////////////////////////////////////////////
3295: // This protocol is really only here for (self) documenting purposes, since
3296: // all its methods are optional.
3297: @protocol OcFixture
3298: 
3299: @optional
3300: 
3301: -(void) setUp;
3302: -(void) tearDown;
3303: 
3304: @end
3305: 
3306: namespace Catch {
3307: 
3308:     class OcMethod : public ITestInvoker {
3309: 
3310:     public:
3311:         OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}
3312: 
3313:         virtual void invoke() const {
3314:             id obj = [[m_cls alloc] init];
3315: 
3316:             performOptionalSelector( obj, @selector(setUp)  );
3317:             performOptionalSelector( obj, m_sel );
3318:             performOptionalSelector( obj, @selector(tearDown)  );
3319: 
3320:             arcSafeRelease( obj );
3321:         }
3322:     private:
3323:         virtual ~OcMethod() {}
3324: 
3325:         Class m_cls;
3326:         SEL m_sel;
3327:     };
3328: 
3329:     namespace Detail{
3330: 
3331:         inline std::string getAnnotation(   Class cls,
3332:                                             std::string const& annotationName,
3333:                                             std::string const& testCaseName ) {
3334:             NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];
3335:             SEL sel = NSSelectorFromString( selStr );
3336:             arcSafeRelease( selStr );
3337:             id value = performOptionalSelector( cls, sel );
3338:             if( value )
3339:                 return [(NSString*)value UTF8String];
3340:             return "";
3341:         }
3342:     }
3343: 
3344:     inline std::size_t registerTestMethods() {
3345:         std::size_t noTestMethods = 0;
3346:         int noClasses = objc_getClassList( nullptr, 0 );
3347: 
3348:         Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);
3349:         objc_getClassList( classes, noClasses );
3350: 
3351:         for( int c = 0; c < noClasses; c++ ) {
3352:             Class cls = classes[c];
3353:             {
3354:                 u_int count;
3355:                 Method* methods = class_copyMethodList( cls, &count );
3356:                 for( u_int m = 0; m < count ; m++ ) {
3357:                     SEL selector = method_getName(methods[m]);
3358:                     std::string methodName = sel_getName(selector);
3359:                     if( startsWith( methodName, "Catch_TestCase_" ) ) {
3360:                         std::string testCaseName = methodName.substr( 15 );
3361:                         std::string name = Detail::getAnnotation( cls, "Name", testCaseName );
3362:                         std::string desc = Detail::getAnnotation( cls, "Description", testCaseName );
3363:                         const char* className = class_getName( cls );
3364: 
3365:                         getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, NameAndTags( name.c_str(), desc.c_str() ), SourceLineInfo("",0) ) );
3366:                         noTestMethods++;
3367:                     }
3368:                 }
3369:                 free(methods);
3370:             }
3371:         }
3372:         return noTestMethods;
3373:     }
3374: 
3375: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
3376: 
3377:     namespace Matchers {
3378:         namespace Impl {
3379:         namespace NSStringMatchers {
3380: 
3381:             struct StringHolder : MatcherBase<NSString*>{
3382:                 StringHolder( NSString* substr ) : m_substr( [substr copy] ){}
3383:                 StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}
3384:                 StringHolder() {
3385:                     arcSafeRelease( m_substr );
3386:                 }
3387: 
3388:                 bool match( NSString* arg ) const override {
3389:                     return false;
3390:                 }
3391: 
3392:                 NSString* CATCH_ARC_STRONG m_substr;
3393:             };
3394: 
3395:             struct Equals : StringHolder {
3396:                 Equals( NSString* substr ) : StringHolder( substr ){}
3397: 
3398:                 bool match( NSString* str ) const override {
3399:                     return  (str != nil || m_substr == nil ) &&
3400:                             [str isEqualToString:m_substr];
3401:                 }
3402: 
3403:                 std::string describe() const override {
3404:                     return "equals string: " + Catch::Detail::stringify( m_substr );
3405:                 }
3406:             };
3407: 
3408:             struct Contains : StringHolder {
3409:                 Contains( NSString* substr ) : StringHolder( substr ){}
3410: 
3411:                 bool match( NSString* str ) const {
3412:                     return  (str != nil || m_substr == nil ) &&
3413:                             [str rangeOfString:m_substr].location != NSNotFound;
3414:                 }
3415: 
3416:                 std::string describe() const override {
3417:                     return "contains string: " + Catch::Detail::stringify( m_substr );
3418:                 }
3419:             };
3420: 
3421:             struct StartsWith : StringHolder {
3422:                 StartsWith( NSString* substr ) : StringHolder( substr ){}
3423: 
3424:                 bool match( NSString* str ) const override {
3425:                     return  (str != nil || m_substr == nil ) &&
3426:                             [str rangeOfString:m_substr].location == 0;
3427:                 }
3428: 
3429:                 std::string describe() const override {
3430:                     return "starts with: " + Catch::Detail::stringify( m_substr );
3431:                 }
3432:             };
3433:             struct EndsWith : StringHolder {
3434:                 EndsWith( NSString* substr ) : StringHolder( substr ){}
3435: 
3436:                 bool match( NSString* str ) const override {
3437:                     return  (str != nil || m_substr == nil ) &&
3438:                             [str rangeOfString:m_substr].location == [str length] - [m_substr length];
3439:                 }
3440: 
3441:                 std::string describe() const override {
3442:                     return "ends with: " + Catch::Detail::stringify( m_substr );
3443:                 }
3444:             };
3445: 
3446:         } // namespace NSStringMatchers
3447:         } // namespace Impl
3448: 
3449:         inline Impl::NSStringMatchers::Equals
3450:             Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }
3451: 
3452:         inline Impl::NSStringMatchers::Contains
3453:             Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }
3454: 
3455:         inline Impl::NSStringMatchers::StartsWith
3456:             StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }
3457: 
3458:         inline Impl::NSStringMatchers::EndsWith
3459:             EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }
3460: 
3461:     } // namespace Matchers
3462: 
3463:     using namespace Matchers;
3464: 
3465: #endif // CATCH_CONFIG_DISABLE_MATCHERS
3466: 
3467: } // namespace Catch
3468: 
3469: ///////////////////////////////////////////////////////////////////////////////
3470: #define OC_MAKE_UNIQUE_NAME( root, uniqueSuffix ) root##uniqueSuffix
3471: #define OC_TEST_CASE2( name, desc, uniqueSuffix ) \
3472: +(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Name_test_, uniqueSuffix ) \
3473: { \
3474: return @ name; \
3475: } \
3476: +(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Description_test_, uniqueSuffix ) \
3477: { \
3478: return @ desc; \
3479: } \
3480: -(void) OC_MAKE_UNIQUE_NAME( Catch_TestCase_test_, uniqueSuffix )
3481: 
3482: #define OC_TEST_CASE( name, desc ) OC_TEST_CASE2( name, desc, __LINE__ )
3483: 
3484: // end catch_objc.hpp
3485: #endif
3486: 
3487: #ifdef CATCH_CONFIG_EXTERNAL_INTERFACES
3488: // start catch_external_interfaces.h
3489: 
3490: // start catch_reporter_bases.hpp
3491: 
3492: // start catch_interfaces_reporter.h
3493: 
3494: // start catch_config.hpp
3495: 
3496: // start catch_test_spec_parser.h
3497: 
3498: #ifdef __clang__
3499: #pragma clang diagnostic push
3500: #pragma clang diagnostic ignored "-Wpadded"
3501: #endif
3502: 
3503: // start catch_test_spec.h
3504: 
3505: #ifdef __clang__
3506: #pragma clang diagnostic push
3507: #pragma clang diagnostic ignored "-Wpadded"
3508: #endif
3509: 
3510: // start catch_wildcard_pattern.h
3511: 
3512: namespace Catch
3513: {
3514:     class WildcardPattern {
3515:         enum WildcardPosition {
3516:             NoWildcard = 0,
3517:             WildcardAtStart = 1,
3518:             WildcardAtEnd = 2,
3519:             WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
3520:         };
3521: 
3522:     public:
3523: 
3524:         WildcardPattern( std::string const& pattern, CaseSensitive::Choice caseSensitivity );
3525:         virtual ~WildcardPattern() = default;
3526:         virtual bool matches( std::string const& str ) const;
3527: 
3528:     private:
3529:         std::string adjustCase( std::string const& str ) const;
3530:         CaseSensitive::Choice m_caseSensitivity;
3531:         WildcardPosition m_wildcard = NoWildcard;
3532:         std::string m_pattern;
3533:     };
3534: }
3535: 
3536: // end catch_wildcard_pattern.h
3537: #include <string>
3538: #include <vector>
3539: #include <memory>
3540: 
3541: namespace Catch {
3542: 
3543:     class TestSpec {
3544:         struct Pattern {
3545:             virtual ~Pattern();
3546:             virtual bool matches( TestCaseInfo const& testCase ) const = 0;
3547:         };
3548:         using PatternPtr = std::shared_ptr<Pattern>;
3549: 
3550:         class NamePattern : public Pattern {
3551:         public:
3552:             NamePattern( std::string const& name );
3553:             virtual ~NamePattern();
3554:             virtual bool matches( TestCaseInfo const& testCase ) const override;
3555:         private:
3556:             WildcardPattern m_wildcardPattern;
3557:         };
3558: 
3559:         class TagPattern : public Pattern {
3560:         public:
3561:             TagPattern( std::string const& tag );
3562:             virtual ~TagPattern();
3563:             virtual bool matches( TestCaseInfo const& testCase ) const override;
3564:         private:
3565:             std::string m_tag;
3566:         };
3567: 
3568:         class ExcludedPattern : public Pattern {
3569:         public:
3570:             ExcludedPattern( PatternPtr const& underlyingPattern );
3571:             virtual ~ExcludedPattern();
3572:             virtual bool matches( TestCaseInfo const& testCase ) const override;
3573:         private:
3574:             PatternPtr m_underlyingPattern;
3575:         };
3576: 
3577:         struct Filter {
3578:             std::vector<PatternPtr> m_patterns;
3579: 
3580:             bool matches( TestCaseInfo const& testCase ) const;
3581:         };
3582: 
3583:     public:
3584:         bool hasFilters() const;
3585:         bool matches( TestCaseInfo const& testCase ) const;
3586: 
3587:     private:
3588:         std::vector<Filter> m_filters;
3589: 
3590:         friend class TestSpecParser;
3591:     };
3592: }
3593: 
3594: #ifdef __clang__
3595: #pragma clang diagnostic pop
3596: #endif
3597: 
3598: // end catch_test_spec.h
3599: // start catch_interfaces_tag_alias_registry.h
3600: 
3601: #include <string>
3602: 
3603: namespace Catch {
3604: 
3605:     struct TagAlias;
3606: 
3607:     struct ITagAliasRegistry {
3608:         virtual ~ITagAliasRegistry();
3609:         // Nullptr if not present
3610:         virtual TagAlias const* find( std::string const& alias ) const = 0;
3611:         virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;
3612: 
3613:         static ITagAliasRegistry const& get();
3614:     };
3615: 
3616: } // end namespace Catch
3617: 
3618: // end catch_interfaces_tag_alias_registry.h
3619: namespace Catch {
3620: 
3621:     class TestSpecParser {
3622:         enum Mode{ None, Name, QuotedName, Tag, EscapedName };
3623:         Mode m_mode = None;
3624:         bool m_exclusion = false;
3625:         std::size_t m_start = std::string::npos, m_pos = 0;
3626:         std::string m_arg;
3627:         std::vector<std::size_t> m_escapeChars;
3628:         TestSpec::Filter m_currentFilter;
3629:         TestSpec m_testSpec;
3630:         ITagAliasRegistry const* m_tagAliases = nullptr;
3631: 
3632:     public:
3633:         TestSpecParser( ITagAliasRegistry const& tagAliases );
3634: 
3635:         TestSpecParser& parse( std::string const& arg );
3636:         TestSpec testSpec();
3637: 
3638:     private:
3639:         void visitChar( char c );
3640:         void startNewMode( Mode mode, std::size_t start );
3641:         void escape();
3642:         std::string subString() const;
3643: 
3644:         template<typename T>
3645:         void addPattern() {
3646:             std::string token = subString();
3647:             for( std::size_t i = 0; i < m_escapeChars.size(); ++i )
3648:                 token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );
3649:             m_escapeChars.clear();
3650:             if( startsWith( token, "exclude:" ) ) {
3651:                 m_exclusion = true;
3652:                 token = token.substr( 8 );
3653:             }
3654:             if( !token.empty() ) {
3655:                 TestSpec::PatternPtr pattern = std::make_shared<T>( token );
3656:                 if( m_exclusion )
3657:                     pattern = std::make_shared<TestSpec::ExcludedPattern>( pattern );
3658:                 m_currentFilter.m_patterns.push_back( pattern );
3659:             }
3660:             m_exclusion = false;
3661:             m_mode = None;
3662:         }
3663: 
3664:         void addFilter();
3665:     };
3666:     TestSpec parseTestSpec( std::string const& arg );
3667: 
3668: } // namespace Catch
3669: 
3670: #ifdef __clang__
3671: #pragma clang diagnostic pop
3672: #endif
3673: 
3674: // end catch_test_spec_parser.h
3675: // start catch_interfaces_config.h
3676: 
3677: #include <iosfwd>
3678: #include <string>
3679: #include <vector>
3680: #include <memory>
3681: 
3682: namespace Catch {
3683: 
3684:     enum class Verbosity {
3685:         Quiet = 0,
3686:         Normal,
3687:         High
3688:     };
3689: 
3690:     struct WarnAbout { enum What {
3691:         Nothing = 0x00,
3692:         NoAssertions = 0x01,
3693:         NoTests = 0x02
3694:     }; };
3695: 
3696:     struct ShowDurations { enum OrNot {
3697:         DefaultForReporter,
3698:         Always,
3699:         Never
3700:     }; };
3701:     struct RunTests { enum InWhatOrder {
3702:         InDeclarationOrder,
3703:         InLexicographicalOrder,
3704:         InRandomOrder
3705:     }; };
3706:     struct UseColour { enum YesOrNo {
3707:         Auto,
3708:         Yes,
3709:         No
3710:     }; };
3711:     struct WaitForKeypress { enum When {
3712:         Never,
3713:         BeforeStart = 1,
3714:         BeforeExit = 2,
3715:         BeforeStartAndExit = BeforeStart | BeforeExit
3716:     }; };
3717: 
3718:     class TestSpec;
3719: 
3720:     struct IConfig : NonCopyable {
3721: 
3722:         virtual ~IConfig();
3723: 
3724:         virtual bool allowThrows() const = 0;
3725:         virtual std::ostream& stream() const = 0;
3726:         virtual std::string name() const = 0;
3727:         virtual bool includeSuccessfulResults() const = 0;
3728:         virtual bool shouldDebugBreak() const = 0;
3729:         virtual bool warnAboutMissingAssertions() const = 0;
3730:         virtual bool warnAboutNoTests() const = 0;
3731:         virtual int abortAfter() const = 0;
3732:         virtual bool showInvisibles() const = 0;
3733:         virtual ShowDurations::OrNot showDurations() const = 0;
3734:         virtual TestSpec const& testSpec() const = 0;
3735:         virtual bool hasTestFilters() const = 0;
3736:         virtual RunTests::InWhatOrder runOrder() const = 0;
3737:         virtual unsigned int rngSeed() const = 0;
3738:         virtual int benchmarkResolutionMultiple() const = 0;
3739:         virtual UseColour::YesOrNo useColour() const = 0;
3740:         virtual std::vector<std::string> const& getSectionsToRun() const = 0;
3741:         virtual Verbosity verbosity() const = 0;
3742:     };
3743: 
3744:     using IConfigPtr = std::shared_ptr<IConfig const>;
3745: }
3746: 
3747: // end catch_interfaces_config.h
3748: // Libstdc++ doesn't like incomplete classes for unique_ptr
3749: 
3750: #include <memory>
3751: #include <vector>
3752: #include <string>
3753: 
3754: #ifndef CATCH_CONFIG_CONSOLE_WIDTH
3755: #define CATCH_CONFIG_CONSOLE_WIDTH 80
3756: #endif
3757: 
3758: namespace Catch {
3759: 
3760:     struct IStream;
3761: 
3762:     struct ConfigData {
3763:         bool listTests = false;
3764:         bool listTags = false;
3765:         bool listReporters = false;
3766:         bool listTestNamesOnly = false;
3767: 
3768:         bool showSuccessfulTests = false;
3769:         bool shouldDebugBreak = false;
3770:         bool noThrow = false;
3771:         bool showHelp = false;
3772:         bool showInvisibles = false;
3773:         bool filenamesAsTags = false;
3774:         bool libIdentify = false;
3775: 
3776:         int abortAfter = -1;
3777:         unsigned int rngSeed = 0;
3778:         int benchmarkResolutionMultiple = 100;
3779: 
3780:         Verbosity verbosity = Verbosity::Normal;
3781:         WarnAbout::What warnings = WarnAbout::Nothing;
3782:         ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;
3783:         RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;
3784:         UseColour::YesOrNo useColour = UseColour::Auto;
3785:         WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;
3786: 
3787:         std::string outputFilename;
3788:         std::string name;
3789:         std::string processName;
3790: #ifndef CATCH_CONFIG_DEFAULT_REPORTER
3791: #define CATCH_CONFIG_DEFAULT_REPORTER "console"
3792: #endif
3793:         std::string reporterName = CATCH_CONFIG_DEFAULT_REPORTER;
3794: #undef CATCH_CONFIG_DEFAULT_REPORTER
3795: 
3796:         std::vector<std::string> testsOrTags;
3797:         std::vector<std::string> sectionsToRun;
3798:     };
3799: 
3800:     class Config : public IConfig {
3801:     public:
3802: 
3803:         Config() = default;
3804:         Config( ConfigData const& data );
3805:         virtual ~Config() = default;
3806: 
3807:         std::string const& getFilename() const;
3808: 
3809:         bool listTests() const;
3810:         bool listTestNamesOnly() const;
3811:         bool listTags() const;
3812:         bool listReporters() const;
3813: 
3814:         std::string getProcessName() const;
3815:         std::string const& getReporterName() const;
3816: 
3817:         std::vector<std::string> const& getTestsOrTags() const;
3818:         std::vector<std::string> const& getSectionsToRun() const override;
3819: 
3820:         virtual TestSpec const& testSpec() const override;
3821:         bool hasTestFilters() const override;
3822: 
3823:         bool showHelp() const;
3824: 
3825:         // IConfig interface
3826:         bool allowThrows() const override;
3827:         std::ostream& stream() const override;
3828:         std::string name() const override;
3829:         bool includeSuccessfulResults() const override;
3830:         bool warnAboutMissingAssertions() const override;
3831:         bool warnAboutNoTests() const override;
3832:         ShowDurations::OrNot showDurations() const override;
3833:         RunTests::InWhatOrder runOrder() const override;
3834:         unsigned int rngSeed() const override;
3835:         int benchmarkResolutionMultiple() const override;
3836:         UseColour::YesOrNo useColour() const override;
3837:         bool shouldDebugBreak() const override;
3838:         int abortAfter() const override;
3839:         bool showInvisibles() const override;
3840:         Verbosity verbosity() const override;
3841: 
3842:     private:
3843: 
3844:         IStream const* openStream();
3845:         ConfigData m_data;
3846: 
3847:         std::unique_ptr<IStream const> m_stream;
3848:         TestSpec m_testSpec;
3849:         bool m_hasTestFilters = false;
3850:     };
3851: 
3852: } // end namespace Catch
3853: 
3854: // end catch_config.hpp
3855: // start catch_assertionresult.h
3856: 
3857: #include <string>
3858: 
3859: namespace Catch {
3860: 
3861:     struct AssertionResultData
3862:     {
3863:         AssertionResultData() = delete;
3864: 
3865:         AssertionResultData( ResultWas::OfType _resultType, LazyExpression const& _lazyExpression );
3866: 
3867:         std::string message;
3868:         mutable std::string reconstructedExpression;
3869:         LazyExpression lazyExpression;
3870:         ResultWas::OfType resultType;
3871: 
3872:         std::string reconstructExpression() const;
3873:     };
3874: 
3875:     class AssertionResult {
3876:     public:
3877:         AssertionResult() = delete;
3878:         AssertionResult( AssertionInfo const& info, AssertionResultData const& data );
3879: 
3880:         bool isOk() const;
3881:         bool succeeded() const;
3882:         ResultWas::OfType getResultType() const;
3883:         bool hasExpression() const;
3884:         bool hasMessage() const;
3885:         std::string getExpression() const;
3886:         std::string getExpressionInMacro() const;
3887:         bool hasExpandedExpression() const;
3888:         std::string getExpandedExpression() const;
3889:         std::string getMessage() const;
3890:         SourceLineInfo getSourceInfo() const;
3891:         StringRef getTestMacroName() const;
3892: 
3893:     //protected:
3894:         AssertionInfo m_info;
3895:         AssertionResultData m_resultData;
3896:     };
3897: 
3898: } // end namespace Catch
3899: 
3900: // end catch_assertionresult.h
3901: // start catch_option.hpp
3902: 
3903: namespace Catch {
3904: 
3905:     // An optional type
3906:     template<typename T>
3907:     class Option {
3908:     public:
3909:         Option() : nullableValue( nullptr ) {}
3910:         Option( T const& _value )
3911:         : nullableValue( new( storage ) T( _value ) )
3912:         {}
3913:         Option( Option const& _other )
3914:         : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )
3915:         {}
3916: 
3917:         ~Option() {
3918:             reset();
3919:         }
3920: 
3921:         Option& operator= ( Option const& _other ) {
3922:             if( &_other != this ) {
3923:                 reset();
3924:                 if( _other )
3925:                     nullableValue = new( storage ) T( *_other );
3926:             }
3927:             return *this;
3928:         }
3929:         Option& operator = ( T const& _value ) {
3930:             reset();
3931:             nullableValue = new( storage ) T( _value );
3932:             return *this;
3933:         }
3934: 
3935:         void reset() {
3936:             if( nullableValue )
3937:                 nullableValue->~T();
3938:             nullableValue = nullptr;
3939:         }
3940: 
3941:         T& operator*() { return *nullableValue; }
3942:         T const& operator*() const { return *nullableValue; }
3943:         T* operator->() { return nullableValue; }
3944:         const T* operator->() const { return nullableValue; }
3945: 
3946:         T valueOr( T const& defaultValue ) const {
3947:             return nullableValue ? *nullableValue : defaultValue;
3948:         }
3949: 
3950:         bool some() const { return nullableValue != nullptr; }
3951:         bool none() const { return nullableValue == nullptr; }
3952: 
3953:         bool operator !() const { return nullableValue == nullptr; }
3954:         explicit operator bool() const {
3955:             return some();
3956:         }
3957: 
3958:     private:
3959:         T *nullableValue;
3960:         alignas(alignof(T)) char storage[sizeof(T)];
3961:     };
3962: 
3963: } // end namespace Catch
3964: 
3965: // end catch_option.hpp
3966: #include <string>
3967: #include <iosfwd>
3968: #include <map>
3969: #include <set>
3970: #include <memory>
3971: 
3972: namespace Catch {
3973: 
3974:     struct ReporterConfig {
3975:         explicit ReporterConfig( IConfigPtr const& _fullConfig );
3976: 
3977:         ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream );
3978: 
3979:         std::ostream& stream() const;
3980:         IConfigPtr fullConfig() const;
3981: 
3982:     private:
3983:         std::ostream* m_stream;
3984:         IConfigPtr m_fullConfig;
3985:     };
3986: 
3987:     struct ReporterPreferences {
3988:         bool shouldRedirectStdOut = false;
3989:         bool shouldReportAllAssertions = false;
3990:     };
3991: 
3992:     template<typename T>
3993:     struct LazyStat : Option<T> {
3994:         LazyStat& operator=( T const& _value ) {
3995:             Option<T>::operator=( _value );
3996:             used = false;
3997:             return *this;
3998:         }
3999:         void reset() {
4000:             Option<T>::reset();
4001:             used = false;
4002:         }
4003:         bool used = false;
4004:     };
4005: 
4006:     struct TestRunInfo {
4007:         TestRunInfo( std::string const& _name );
4008:         std::string name;
4009:     };
4010:     struct GroupInfo {
4011:         GroupInfo(  std::string const& _name,
4012:                     std::size_t _groupIndex,
4013:                     std::size_t _groupsCount );
4014: 
4015:         std::string name;
4016:         std::size_t groupIndex;
4017:         std::size_t groupsCounts;
4018:     };
4019: 
4020:     struct AssertionStats {
4021:         AssertionStats( AssertionResult const& _assertionResult,
4022:                         std::vector<MessageInfo> const& _infoMessages,
4023:                         Totals const& _totals );
4024: 
4025:         AssertionStats( AssertionStats const& )              = default;
4026:         AssertionStats( AssertionStats && )                  = default;
4027:         AssertionStats& operator = ( AssertionStats const& ) = default;
4028:         AssertionStats& operator = ( AssertionStats && )     = default;
4029:         virtual ~AssertionStats();
4030: 
4031:         AssertionResult assertionResult;
4032:         std::vector<MessageInfo> infoMessages;
4033:         Totals totals;
4034:     };
4035: 
4036:     struct SectionStats {
4037:         SectionStats(   SectionInfo const& _sectionInfo,
4038:                         Counts const& _assertions,
4039:                         double _durationInSeconds,
4040:                         bool _missingAssertions );
4041:         SectionStats( SectionStats const& )              = default;
4042:         SectionStats( SectionStats && )                  = default;
4043:         SectionStats& operator = ( SectionStats const& ) = default;
4044:         SectionStats& operator = ( SectionStats && )     = default;
4045:         virtual ~SectionStats();
4046: 
4047:         SectionInfo sectionInfo;
4048:         Counts assertions;
4049:         double durationInSeconds;
4050:         bool missingAssertions;
4051:     };
4052: 
4053:     struct TestCaseStats {
4054:         TestCaseStats(  TestCaseInfo const& _testInfo,
4055:                         Totals const& _totals,
4056:                         std::string const& _stdOut,
4057:                         std::string const& _stdErr,
4058:                         bool _aborting );
4059: 
4060:         TestCaseStats( TestCaseStats const& )              = default;
4061:         TestCaseStats( TestCaseStats && )                  = default;
4062:         TestCaseStats& operator = ( TestCaseStats const& ) = default;
4063:         TestCaseStats& operator = ( TestCaseStats && )     = default;
4064:         virtual ~TestCaseStats();
4065: 
4066:         TestCaseInfo testInfo;
4067:         Totals totals;
4068:         std::string stdOut;
4069:         std::string stdErr;
4070:         bool aborting;
4071:     };
4072: 
4073:     struct TestGroupStats {
4074:         TestGroupStats( GroupInfo const& _groupInfo,
4075:                         Totals const& _totals,
4076:                         bool _aborting );
4077:         TestGroupStats( GroupInfo const& _groupInfo );
4078: 
4079:         TestGroupStats( TestGroupStats const& )              = default;
4080:         TestGroupStats( TestGroupStats && )                  = default;
4081:         TestGroupStats& operator = ( TestGroupStats const& ) = default;
4082:         TestGroupStats& operator = ( TestGroupStats && )     = default;
4083:         virtual ~TestGroupStats();
4084: 
4085:         GroupInfo groupInfo;
4086:         Totals totals;
4087:         bool aborting;
4088:     };
4089: 
4090:     struct TestRunStats {
4091:         TestRunStats(   TestRunInfo const& _runInfo,
4092:                         Totals const& _totals,
4093:                         bool _aborting );
4094: 
4095:         TestRunStats( TestRunStats const& )              = default;
4096:         TestRunStats( TestRunStats && )                  = default;
4097:         TestRunStats& operator = ( TestRunStats const& ) = default;
4098:         TestRunStats& operator = ( TestRunStats && )     = default;
4099:         virtual ~TestRunStats();
4100: 
4101:         TestRunInfo runInfo;
4102:         Totals totals;
4103:         bool aborting;
4104:     };
4105: 
4106:     struct BenchmarkInfo {
4107:         std::string name;
4108:     };
4109:     struct BenchmarkStats {
4110:         BenchmarkInfo info;
4111:         std::size_t iterations;
4112:         uint64_t elapsedTimeInNanoseconds;
4113:     };
4114: 
4115:     struct IStreamingReporter {
4116:         virtual ~IStreamingReporter() = default;
4117: 
4118:         // Implementing class must also provide the following static methods:
4119:         // static std::string getDescription();
4120:         // static std::set<Verbosity> getSupportedVerbosities()
4121: 
4122:         virtual ReporterPreferences getPreferences() const = 0;
4123: 
4124:         virtual void noMatchingTestCases( std::string const& spec ) = 0;
4125: 
4126:         virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;
4127:         virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;
4128: 
4129:         virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;
4130:         virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;
4131: 
4132:         // *** experimental ***
4133:         virtual void benchmarkStarting( BenchmarkInfo const& ) {}
4134: 
4135:         virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;
4136: 
4137:         // The return value indicates if the messages buffer should be cleared:
4138:         virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;
4139: 
4140:         // *** experimental ***
4141:         virtual void benchmarkEnded( BenchmarkStats const& ) {}
4142: 
4143:         virtual void sectionEnded( SectionStats const& sectionStats ) = 0;
4144:         virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;
4145:         virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;
4146:         virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;
4147: 
4148:         virtual void skipTest( TestCaseInfo const& testInfo ) = 0;
4149: 
4150:         // Default empty implementation provided
4151:         virtual void fatalErrorEncountered( StringRef name );
4152: 
4153:         virtual bool isMulti() const;
4154:     };
4155:     using IStreamingReporterPtr = std::unique_ptr<IStreamingReporter>;
4156: 
4157:     struct IReporterFactory {
4158:         virtual ~IReporterFactory();
4159:         virtual IStreamingReporterPtr create( ReporterConfig const& config ) const = 0;
4160:         virtual std::string getDescription() const = 0;
4161:     };
4162:     using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;
4163: 
4164:     struct IReporterRegistry {
4165:         using FactoryMap = std::map<std::string, IReporterFactoryPtr>;
4166:         using Listeners = std::vector<IReporterFactoryPtr>;
4167: 
4168:         virtual ~IReporterRegistry();
4169:         virtual IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const = 0;
4170:         virtual FactoryMap const& getFactories() const = 0;
4171:         virtual Listeners const& getListeners() const = 0;
4172:     };
4173: 
4174: } // end namespace Catch
4175: 
4176: // end catch_interfaces_reporter.h
4177: #include <algorithm>
4178: #include <cstring>
4179: #include <cfloat>
4180: #include <cstdio>
4181: #include <cassert>
4182: #include <memory>
4183: #include <ostream>
4184: 
4185: namespace Catch {
4186:     void prepareExpandedExpression(AssertionResult& result);
4187: 
4188:     // Returns double formatted as %.3f (format expected on output)
4189:     std::string getFormattedDuration( double duration );
4190: 
4191:     template<typename DerivedT>
4192:     struct StreamingReporterBase : IStreamingReporter {
4193: 
4194:         StreamingReporterBase( ReporterConfig const& _config )
4195:         :   m_config( _config.fullConfig() ),
4196:             stream( _config.stream() )
4197:         {
4198:             m_reporterPrefs.shouldRedirectStdOut = false;
4199:             if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
4200:                 CATCH_ERROR( "Verbosity level not supported by this reporter" );
4201:         }
4202: 
4203:         ReporterPreferences getPreferences() const override {
4204:             return m_reporterPrefs;
4205:         }
4206: 
4207:         static std::set<Verbosity> getSupportedVerbosities() {
4208:             return { Verbosity::Normal };
4209:         }
4210: 
4211:         ~StreamingReporterBase() override = default;
4212: 
4213:         void noMatchingTestCases(std::string const&) override {}
4214: 
4215:         void testRunStarting(TestRunInfo const& _testRunInfo) override {
4216:             currentTestRunInfo = _testRunInfo;
4217:         }
4218:         void testGroupStarting(GroupInfo const& _groupInfo) override {
4219:             currentGroupInfo = _groupInfo;
4220:         }
4221: 
4222:         void testCaseStarting(TestCaseInfo const& _testInfo) override  {
4223:             currentTestCaseInfo = _testInfo;
4224:         }
4225:         void sectionStarting(SectionInfo const& _sectionInfo) override {
4226:             m_sectionStack.push_back(_sectionInfo);
4227:         }
4228: 
4229:         void sectionEnded(SectionStats const& /* _sectionStats */) override {
4230:             m_sectionStack.pop_back();
4231:         }
4232:         void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {
4233:             currentTestCaseInfo.reset();
4234:         }
4235:         void testGroupEnded(TestGroupStats const& /* _testGroupStats */) override {
4236:             currentGroupInfo.reset();
4237:         }
4238:         void testRunEnded(TestRunStats const& /* _testRunStats */) override {
4239:             currentTestCaseInfo.reset();
4240:             currentGroupInfo.reset();
4241:             currentTestRunInfo.reset();
4242:         }
4243: 
4244:         void skipTest(TestCaseInfo const&) override {
4245:             // Don't do anything with this by default.
4246:             // It can optionally be overridden in the derived class.
4247:         }
4248: 
4249:         IConfigPtr m_config;
4250:         std::ostream& stream;
4251: 
4252:         LazyStat<TestRunInfo> currentTestRunInfo;
4253:         LazyStat<GroupInfo> currentGroupInfo;
4254:         LazyStat<TestCaseInfo> currentTestCaseInfo;
4255: 
4256:         std::vector<SectionInfo> m_sectionStack;
4257:         ReporterPreferences m_reporterPrefs;
4258:     };
4259: 
4260:     template<typename DerivedT>
4261:     struct CumulativeReporterBase : IStreamingReporter {
4262:         template<typename T, typename ChildNodeT>
4263:         struct Node {
4264:             explicit Node( T const& _value ) : value( _value ) {}
4265:             virtual ~Node() {}
4266: 
4267:             using ChildNodes = std::vector<std::shared_ptr<ChildNodeT>>;
4268:             T value;
4269:             ChildNodes children;
4270:         };
4271:         struct SectionNode {
4272:             explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}
4273:             virtual ~SectionNode() = default;
4274: 
4275:             bool operator == (SectionNode const& other) const {
4276:                 return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
4277:             }
4278:             bool operator == (std::shared_ptr<SectionNode> const& other) const {
4279:                 return operator==(*other);
4280:             }
4281: 
4282:             SectionStats stats;
4283:             using ChildSections = std::vector<std::shared_ptr<SectionNode>>;
4284:             using Assertions = std::vector<AssertionStats>;
4285:             ChildSections childSections;
4286:             Assertions assertions;
4287:             std::string stdOut;
4288:             std::string stdErr;
4289:         };
4290: 
4291:         struct BySectionInfo {
4292:             BySectionInfo( SectionInfo const& other ) : m_other( other ) {}
4293:             BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}
4294:             bool operator() (std::shared_ptr<SectionNode> const& node) const {
4295:                 return ((node->stats.sectionInfo.name == m_other.name) &&
4296:                         (node->stats.sectionInfo.lineInfo == m_other.lineInfo));
4297:             }
4298:             void operator=(BySectionInfo const&) = delete;
4299: 
4300:         private:
4301:             SectionInfo const& m_other;
4302:         };
4303: 
4304:         using TestCaseNode = Node<TestCaseStats, SectionNode>;
4305:         using TestGroupNode = Node<TestGroupStats, TestCaseNode>;
4306:         using TestRunNode = Node<TestRunStats, TestGroupNode>;
4307: 
4308:         CumulativeReporterBase( ReporterConfig const& _config )
4309:         :   m_config( _config.fullConfig() ),
4310:             stream( _config.stream() )
4311:         {
4312:             m_reporterPrefs.shouldRedirectStdOut = false;
4313:             if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
4314:                 CATCH_ERROR( "Verbosity level not supported by this reporter" );
4315:         }
4316:         ~CumulativeReporterBase() override = default;
4317: 
4318:         ReporterPreferences getPreferences() const override {
4319:             return m_reporterPrefs;
4320:         }
4321: 
4322:         static std::set<Verbosity> getSupportedVerbosities() {
4323:             return { Verbosity::Normal };
4324:         }
4325: 
4326:         void testRunStarting( TestRunInfo const& ) override {}
4327:         void testGroupStarting( GroupInfo const& ) override {}
4328: 
4329:         void testCaseStarting( TestCaseInfo const& ) override {}
4330: 
4331:         void sectionStarting( SectionInfo const& sectionInfo ) override {
4332:             SectionStats incompleteStats( sectionInfo, Counts(), 0, false );
4333:             std::shared_ptr<SectionNode> node;
4334:             if( m_sectionStack.empty() ) {
4335:                 if( !m_rootSection )
4336:                     m_rootSection = std::make_shared<SectionNode>( incompleteStats );
4337:                 node = m_rootSection;
4338:             }
4339:             else {
4340:                 SectionNode& parentNode = *m_sectionStack.back();
4341:                 auto it =
4342:                     std::find_if(   parentNode.childSections.begin(),
4343:                                     parentNode.childSections.end(),
4344:                                     BySectionInfo( sectionInfo ) );
4345:                 if( it == parentNode.childSections.end() ) {
4346:                     node = std::make_shared<SectionNode>( incompleteStats );
4347:                     parentNode.childSections.push_back( node );
4348:                 }
4349:                 else
4350:                     node = *it;
4351:             }
4352:             m_sectionStack.push_back( node );
4353:             m_deepestSection = std::move(node);
4354:         }
4355: 
4356:         void assertionStarting(AssertionInfo const&) override {}
4357: 
4358:         bool assertionEnded(AssertionStats const& assertionStats) override {
4359:             assert(!m_sectionStack.empty());
4360:             // AssertionResult holds a pointer to a temporary DecomposedExpression,
4361:             // which getExpandedExpression() calls to build the expression string.
4362:             // Our section stack copy of the assertionResult will likely outlive the
4363:             // temporary, so it must be expanded or discarded now to avoid calling
4364:             // a destroyed object later.
4365:             prepareExpandedExpression(const_cast<AssertionResult&>( assertionStats.assertionResult ) );
4366:             SectionNode& sectionNode = *m_sectionStack.back();
4367:             sectionNode.assertions.push_back(assertionStats);
4368:             return true;
4369:         }
4370:         void sectionEnded(SectionStats const& sectionStats) override {
4371:             assert(!m_sectionStack.empty());
4372:             SectionNode& node = *m_sectionStack.back();
4373:             node.stats = sectionStats;
4374:             m_sectionStack.pop_back();
4375:         }
4376:         void testCaseEnded(TestCaseStats const& testCaseStats) override {
4377:             auto node = std::make_shared<TestCaseNode>(testCaseStats);
4378:             assert(m_sectionStack.size() == 0);
4379:             node->children.push_back(m_rootSection);
4380:             m_testCases.push_back(node);
4381:             m_rootSection.reset();
4382: 
4383:             assert(m_deepestSection);
4384:             m_deepestSection->stdOut = testCaseStats.stdOut;
4385:             m_deepestSection->stdErr = testCaseStats.stdErr;
4386:         }
4387:         void testGroupEnded(TestGroupStats const& testGroupStats) override {
4388:             auto node = std::make_shared<TestGroupNode>(testGroupStats);
4389:             node->children.swap(m_testCases);
4390:             m_testGroups.push_back(node);
4391:         }
4392:         void testRunEnded(TestRunStats const& testRunStats) override {
4393:             auto node = std::make_shared<TestRunNode>(testRunStats);
4394:             node->children.swap(m_testGroups);
4395:             m_testRuns.push_back(node);
4396:             testRunEndedCumulative();
4397:         }
4398:         virtual void testRunEndedCumulative() = 0;
4399: 
4400:         void skipTest(TestCaseInfo const&) override {}
4401: 
4402:         IConfigPtr m_config;
4403:         std::ostream& stream;
4404:         std::vector<AssertionStats> m_assertions;
4405:         std::vector<std::vector<std::shared_ptr<SectionNode>>> m_sections;
4406:         std::vector<std::shared_ptr<TestCaseNode>> m_testCases;
4407:         std::vector<std::shared_ptr<TestGroupNode>> m_testGroups;
4408: 
4409:         std::vector<std::shared_ptr<TestRunNode>> m_testRuns;
4410: 
4411:         std::shared_ptr<SectionNode> m_rootSection;
4412:         std::shared_ptr<SectionNode> m_deepestSection;
4413:         std::vector<std::shared_ptr<SectionNode>> m_sectionStack;
4414:         ReporterPreferences m_reporterPrefs;
4415:     };
4416: 
4417:     template<char C>
4418:     char const* getLineOfChars() {
4419:         static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
4420:         if( !*line ) {
4421:             std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
4422:             line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
4423:         }
4424:         return line;
4425:     }
4426: 
4427:     struct TestEventListenerBase : StreamingReporterBase<TestEventListenerBase> {
4428:         TestEventListenerBase( ReporterConfig const& _config );
4429: 
4430:         void assertionStarting(AssertionInfo const&) override;
4431:         bool assertionEnded(AssertionStats const&) override;
4432:     };
4433: 
4434: } // end namespace Catch
4435: 
4436: // end catch_reporter_bases.hpp
4437: // start catch_console_colour.h
4438: 
4439: namespace Catch {
4440: 
4441:     struct Colour {
4442:         enum Code {
4443:             None = 0,
4444: 
4445:             White,
4446:             Red,
4447:             Green,
4448:             Blue,
4449:             Cyan,
4450:             Yellow,
4451:             Grey,
4452: 
4453:             Bright = 0x10,
4454: 
4455:             BrightRed = Bright | Red,
4456:             BrightGreen = Bright | Green,
4457:             LightGrey = Bright | Grey,
4458:             BrightWhite = Bright | White,
4459:             BrightYellow = Bright | Yellow,
4460: 
4461:             // By intention
4462:             FileName = LightGrey,
4463:             Warning = BrightYellow,
4464:             ResultError = BrightRed,
4465:             ResultSuccess = BrightGreen,
4466:             ResultExpectedFailure = Warning,
4467: 
4468:             Error = BrightRed,
4469:             Success = Green,
4470: 
4471:             OriginalExpression = Cyan,
4472:             ReconstructedExpression = BrightYellow,
4473: 
4474:             SecondaryText = LightGrey,
4475:             Headers = White
4476:         };
4477: 
4478:         // Use constructed object for RAII guard
4479:         Colour( Code _colourCode );
4480:         Colour( Colour&& other ) noexcept;
4481:         Colour& operator=( Colour&& other ) noexcept;
4482:         ~Colour();
4483: 
4484:         // Use static method for one-shot changes
4485:         static void use( Code _colourCode );
4486: 
4487:     private:
4488:         bool m_moved = false;
4489:     };
4490: 
4491:     std::ostream& operator << ( std::ostream& os, Colour const& );
4492: 
4493: } // end namespace Catch
4494: 
4495: // end catch_console_colour.h
4496: // start catch_reporter_registrars.hpp
4497: 
4498: 
4499: namespace Catch {
4500: 
4501:     template<typename T>
4502:     class ReporterRegistrar {
4503: 
4504:         class ReporterFactory : public IReporterFactory {
4505: 
4506:             virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {
4507:                 return std::unique_ptr<T>( new T( config ) );
4508:             }
4509: 
4510:             virtual std::string getDescription() const override {
4511:                 return T::getDescription();
4512:             }
4513:         };
4514: 
4515:     public:
4516: 
4517:         explicit ReporterRegistrar( std::string const& name ) {
4518:             getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );
4519:         }
4520:     };
4521: 
4522:     template<typename T>
4523:     class ListenerRegistrar {
4524: 
4525:         class ListenerFactory : public IReporterFactory {
4526: 
4527:             virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {
4528:                 return std::unique_ptr<T>( new T( config ) );
4529:             }
4530:             virtual std::string getDescription() const override {
4531:                 return std::string();
4532:             }
4533:         };
4534: 
4535:     public:
4536: 
4537:         ListenerRegistrar() {
4538:             getMutableRegistryHub().registerListener( std::make_shared<ListenerFactory>() );
4539:         }
4540:     };
4541: }
4542: 
4543: #if !defined(CATCH_CONFIG_DISABLE)
4544: 
4545: #define CATCH_REGISTER_REPORTER( name, reporterType ) \
4546:     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS          \
4547:     namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); } \
4548:     CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS
4549: 
4550: #define CATCH_REGISTER_LISTENER( listenerType ) \
4551:      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS   \
4552:      namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; } \
4553:      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
4554: #else // CATCH_CONFIG_DISABLE
4555: 
4556: #define CATCH_REGISTER_REPORTER(name, reporterType)
4557: #define CATCH_REGISTER_LISTENER(listenerType)
4558: 
4559: #endif // CATCH_CONFIG_DISABLE
4560: 
4561: // end catch_reporter_registrars.hpp
4562: // Allow users to base their work off existing reporters
4563: // start catch_reporter_compact.h
4564: 
4565: namespace Catch {
4566: 
4567:     struct CompactReporter : StreamingReporterBase<CompactReporter> {
4568: 
4569:         using StreamingReporterBase::StreamingReporterBase;
4570: 
4571:         ~CompactReporter() override;
4572: 
4573:         static std::string getDescription();
4574: 
4575:         ReporterPreferences getPreferences() const override;
4576: 
4577:         void noMatchingTestCases(std::string const& spec) override;
4578: 
4579:         void assertionStarting(AssertionInfo const&) override;
4580: 
4581:         bool assertionEnded(AssertionStats const& _assertionStats) override;
4582: 
4583:         void sectionEnded(SectionStats const& _sectionStats) override;
4584: 
4585:         void testRunEnded(TestRunStats const& _testRunStats) override;
4586: 
4587:     };
4588: 
4589: } // end namespace Catch
4590: 
4591: // end catch_reporter_compact.h
4592: // start catch_reporter_console.h
4593: 
4594: #if defined(_MSC_VER)
4595: #pragma warning(push)
4596: #pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
4597:                               // Note that 4062 (not all labels are handled
4598:                               // and default is missing) is enabled
4599: #endif
4600: 
4601: namespace Catch {
4602:     // Fwd decls
4603:     struct SummaryColumn;
4604:     class TablePrinter;
4605: 
4606:     struct ConsoleReporter : StreamingReporterBase<ConsoleReporter> {
4607:         std::unique_ptr<TablePrinter> m_tablePrinter;
4608: 
4609:         ConsoleReporter(ReporterConfig const& config);
4610:         ~ConsoleReporter() override;
4611:         static std::string getDescription();
4612: 
4613:         void noMatchingTestCases(std::string const& spec) override;
4614: 
4615:         void assertionStarting(AssertionInfo const&) override;
4616: 
4617:         bool assertionEnded(AssertionStats const& _assertionStats) override;
4618: 
4619:         void sectionStarting(SectionInfo const& _sectionInfo) override;
4620:         void sectionEnded(SectionStats const& _sectionStats) override;
4621: 
4622:         void benchmarkStarting(BenchmarkInfo const& info) override;
4623:         void benchmarkEnded(BenchmarkStats const& stats) override;
4624: 
4625:         void testCaseEnded(TestCaseStats const& _testCaseStats) override;
4626:         void testGroupEnded(TestGroupStats const& _testGroupStats) override;
4627:         void testRunEnded(TestRunStats const& _testRunStats) override;
4628: 
4629:     private:
4630: 
4631:         void lazyPrint();
4632: 
4633:         void lazyPrintWithoutClosingBenchmarkTable();
4634:         void lazyPrintRunInfo();
4635:         void lazyPrintGroupInfo();
4636:         void printTestCaseAndSectionHeader();
4637: 
4638:         void printClosedHeader(std::string const& _name);
4639:         void printOpenHeader(std::string const& _name);
4640: 
4641:         // if string has a : in first line will set indent to follow it on
4642:         // subsequent lines
4643:         void printHeaderString(std::string const& _string, std::size_t indent = 0);
4644: 
4645:         void printTotals(Totals const& totals);
4646:         void printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row);
4647: 
4648:         void printTotalsDivider(Totals const& totals);
4649:         void printSummaryDivider();
4650: 
4651:     private:
4652:         bool m_headerPrinted = false;
4653:     };
4654: 
4655: } // end namespace Catch
4656: 
4657: #if defined(_MSC_VER)
4658: #pragma warning(pop)
4659: #endif
4660: 
4661: // end catch_reporter_console.h
4662: // start catch_reporter_junit.h
4663: 
4664: // start catch_xmlwriter.h
4665: 
4666: #include <vector>
4667: 
4668: namespace Catch {
4669: 
4670:     class XmlEncode {
4671:     public:
4672:         enum ForWhat { ForTextNodes, ForAttributes };
4673: 
4674:         XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes );
4675: 
4676:         void encodeTo( std::ostream& os ) const;
4677: 
4678:         friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );
4679: 
4680:     private:
4681:         std::string m_str;
4682:         ForWhat m_forWhat;
4683:     };
4684: 
4685:     class XmlWriter {
4686:     public:
4687: 
4688:         class ScopedElement {
4689:         public:
4690:             ScopedElement( XmlWriter* writer );
4691: 
4692:             ScopedElement( ScopedElement&& other ) noexcept;
4693:             ScopedElement& operator=( ScopedElement&& other ) noexcept;
4694: 
4695:             ~ScopedElement();
4696: 
4697:             ScopedElement& writeText( std::string const& text, bool indent = true );
4698: 
4699:             template<typename T>
4700:             ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
4701:                 m_writer->writeAttribute( name, attribute );
4702:                 return *this;
4703:             }
4704: 
4705:         private:
4706:             mutable XmlWriter* m_writer = nullptr;
4707:         };
4708: 
4709:         XmlWriter( std::ostream& os = Catch::cout() );
4710:         ~XmlWriter();
4711: 
4712:         XmlWriter( XmlWriter const& ) = delete;
4713:         XmlWriter& operator=( XmlWriter const& ) = delete;
4714: 
4715:         XmlWriter& startElement( std::string const& name );
4716: 
4717:         ScopedElement scopedElement( std::string const& name );
4718: 
4719:         XmlWriter& endElement();
4720: 
4721:         XmlWriter& writeAttribute( std::string const& name, std::string const& attribute );
4722: 
4723:         XmlWriter& writeAttribute( std::string const& name, bool attribute );
4724: 
4725:         template<typename T>
4726:         XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
4727:             ReusableStringStream rss;
4728:             rss << attribute;
4729:             return writeAttribute( name, rss.str() );
4730:         }
4731: 
4732:         XmlWriter& writeText( std::string const& text, bool indent = true );
4733: 
4734:         XmlWriter& writeComment( std::string const& text );
4735: 
4736:         void writeStylesheetRef( std::string const& url );
4737: 
4738:         XmlWriter& writeBlankLine();
4739: 
4740:         void ensureTagClosed();
4741: 
4742:     private:
4743: 
4744:         void writeDeclaration();
4745: 
4746:         void newlineIfNecessary();
4747: 
4748:         bool m_tagIsOpen = false;
4749:         bool m_needsNewline = false;
4750:         std::vector<std::string> m_tags;
4751:         std::string m_indent;
4752:         std::ostream& m_os;
4753:     };
4754: 
4755: }
4756: 
4757: // end catch_xmlwriter.h
4758: namespace Catch {
4759: 
4760:     class JunitReporter : public CumulativeReporterBase<JunitReporter> {
4761:     public:
4762:         JunitReporter(ReporterConfig const& _config);
4763: 
4764:         ~JunitReporter() override;
4765: 
4766:         static std::string getDescription();
4767: 
4768:         void noMatchingTestCases(std::string const& /*spec*/) override;
4769: 
4770:         void testRunStarting(TestRunInfo const& runInfo) override;
4771: 
4772:         void testGroupStarting(GroupInfo const& groupInfo) override;
4773: 
4774:         void testCaseStarting(TestCaseInfo const& testCaseInfo) override;
4775:         bool assertionEnded(AssertionStats const& assertionStats) override;
4776: 
4777:         void testCaseEnded(TestCaseStats const& testCaseStats) override;
4778: 
4779:         void testGroupEnded(TestGroupStats const& testGroupStats) override;
4780: 
4781:         void testRunEndedCumulative() override;
4782: 
4783:         void writeGroup(TestGroupNode const& groupNode, double suiteTime);
4784: 
4785:         void writeTestCase(TestCaseNode const& testCaseNode);
4786: 
4787:         void writeSection(std::string const& className,
4788:                           std::string const& rootName,
4789:                           SectionNode const& sectionNode);
4790: 
4791:         void writeAssertions(SectionNode const& sectionNode);
4792:         void writeAssertion(AssertionStats const& stats);
4793: 
4794:         XmlWriter xml;
4795:         Timer suiteTimer;
4796:         std::string stdOutForSuite;
4797:         std::string stdErrForSuite;
4798:         unsigned int unexpectedExceptions = 0;
4799:         bool m_okToFail = false;
4800:     };
4801: 
4802: } // end namespace Catch
4803: 
4804: // end catch_reporter_junit.h
4805: // start catch_reporter_xml.h
4806: 
4807: namespace Catch {
4808:     class XmlReporter : public StreamingReporterBase<XmlReporter> {
4809:     public:
4810:         XmlReporter(ReporterConfig const& _config);
4811: 
4812:         ~XmlReporter() override;
4813: 
4814:         static std::string getDescription();
4815: 
4816:         virtual std::string getStylesheetRef() const;
4817: 
4818:         void writeSourceInfo(SourceLineInfo const& sourceInfo);
4819: 
4820:     public: // StreamingReporterBase
4821: 
4822:         void noMatchingTestCases(std::string const& s) override;
4823: 
4824:         void testRunStarting(TestRunInfo const& testInfo) override;
4825: 
4826:         void testGroupStarting(GroupInfo const& groupInfo) override;
4827: 
4828:         void testCaseStarting(TestCaseInfo const& testInfo) override;
4829: 
4830:         void sectionStarting(SectionInfo const& sectionInfo) override;
4831: 
4832:         void assertionStarting(AssertionInfo const&) override;
4833: 
4834:         bool assertionEnded(AssertionStats const& assertionStats) override;
4835: 
4836:         void sectionEnded(SectionStats const& sectionStats) override;
4837: 
4838:         void testCaseEnded(TestCaseStats const& testCaseStats) override;
4839: 
4840:         void testGroupEnded(TestGroupStats const& testGroupStats) override;
4841: 
4842:         void testRunEnded(TestRunStats const& testRunStats) override;
4843: 
4844:     private:
4845:         Timer m_testCaseTimer;
4846:         XmlWriter m_xml;
4847:         int m_sectionDepth = 0;
4848:     };
4849: 
4850: } // end namespace Catch
4851: 
4852: // end catch_reporter_xml.h
4853: 
4854: // end catch_external_interfaces.h
4855: #endif
4856: 
4857: #endif // ! CATCH_CONFIG_IMPL_ONLY
4858: 
4859: #ifdef CATCH_IMPL
4860: // start catch_impl.hpp
4861: 
4862: #ifdef __clang__
4863: #pragma clang diagnostic push
4864: #pragma clang diagnostic ignored "-Wweak-vtables"
4865: #endif
4866: 
4867: // Keep these here for external reporters
4868: // start catch_test_case_tracker.h
4869: 
4870: #include <string>
4871: #include <vector>
4872: #include <memory>
4873: 
4874: namespace Catch {
4875: namespace TestCaseTracking {
4876: 
4877:     struct NameAndLocation {
4878:         std::string name;
4879:         SourceLineInfo location;
4880: 
4881:         NameAndLocation( std::string const& _name, SourceLineInfo const& _location );
4882:     };
4883: 
4884:     struct ITracker;
4885: 
4886:     using ITrackerPtr = std::shared_ptr<ITracker>;
4887: 
4888:     struct ITracker {
4889:         virtual ~ITracker();
4890: 
4891:         // static queries
4892:         virtual NameAndLocation const& nameAndLocation() const = 0;
4893: 
4894:         // dynamic queries
4895:         virtual bool isComplete() const = 0; // Successfully completed or failed
4896:         virtual bool isSuccessfullyCompleted() const = 0;
4897:         virtual bool isOpen() const = 0; // Started but not complete
4898:         virtual bool hasChildren() const = 0;
4899: 
4900:         virtual ITracker& parent() = 0;
4901: 
4902:         // actions
4903:         virtual void close() = 0; // Successfully complete
4904:         virtual void fail() = 0;
4905:         virtual void markAsNeedingAnotherRun() = 0;
4906: 
4907:         virtual void addChild( ITrackerPtr const& child ) = 0;
4908:         virtual ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) = 0;
4909:         virtual void openChild() = 0;
4910: 
4911:         // Debug/ checking
4912:         virtual bool isSectionTracker() const = 0;
4913:         virtual bool isIndexTracker() const = 0;
4914:     };
4915: 
4916:     class TrackerContext {
4917: 
4918:         enum RunState {
4919:             NotStarted,
4920:             Executing,
4921:             CompletedCycle
4922:         };
4923: 
4924:         ITrackerPtr m_rootTracker;
4925:         ITracker* m_currentTracker = nullptr;
4926:         RunState m_runState = NotStarted;
4927: 
4928:     public:
4929: 
4930:         static TrackerContext& instance();
4931: 
4932:         ITracker& startRun();
4933:         void endRun();
4934: 
4935:         void startCycle();
4936:         void completeCycle();
4937: 
4938:         bool completedCycle() const;
4939:         ITracker& currentTracker();
4940:         void setCurrentTracker( ITracker* tracker );
4941:     };
4942: 
4943:     class TrackerBase : public ITracker {
4944:     protected:
4945:         enum CycleState {
4946:             NotStarted,
4947:             Executing,
4948:             ExecutingChildren,
4949:             NeedsAnotherRun,
4950:             CompletedSuccessfully,
4951:             Failed
4952:         };
4953: 
4954:         using Children = std::vector<ITrackerPtr>;
4955:         NameAndLocation m_nameAndLocation;
4956:         TrackerContext& m_ctx;
4957:         ITracker* m_parent;
4958:         Children m_children;
4959:         CycleState m_runState = NotStarted;
4960: 
4961:     public:
4962:         TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );
4963: 
4964:         NameAndLocation const& nameAndLocation() const override;
4965:         bool isComplete() const override;
4966:         bool isSuccessfullyCompleted() const override;
4967:         bool isOpen() const override;
4968:         bool hasChildren() const override;
4969: 
4970:         void addChild( ITrackerPtr const& child ) override;
4971: 
4972:         ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) override;
4973:         ITracker& parent() override;
4974: 
4975:         void openChild() override;
4976: 
4977:         bool isSectionTracker() const override;
4978:         bool isIndexTracker() const override;
4979: 
4980:         void open();
4981: 
4982:         void close() override;
4983:         void fail() override;
4984:         void markAsNeedingAnotherRun() override;
4985: 
4986:     private:
4987:         void moveToParent();
4988:         void moveToThis();
4989:     };
4990: 
4991:     class SectionTracker : public TrackerBase {
4992:         std::vector<std::string> m_filters;
4993:     public:
4994:         SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );
4995: 
4996:         bool isSectionTracker() const override;
4997: 
4998:         static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );
4999: 
5000:         void tryOpen();
5001: 
5002:         void addInitialFilters( std::vector<std::string> const& filters );
5003:         void addNextFilters( std::vector<std::string> const& filters );
5004:     };
5005: 
5006:     class IndexTracker : public TrackerBase {
5007:         int m_size;
5008:         int m_index = -1;
5009:     public:
5010:         IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size );
5011: 
5012:         bool isIndexTracker() const override;
5013:         void close() override;
5014: 
5015:         static IndexTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size );
5016: 
5017:         int index() const;
5018: 
5019:         void moveNext();
5020:     };
5021: 
5022: } // namespace TestCaseTracking
5023: 
5024: using TestCaseTracking::ITracker;
5025: using TestCaseTracking::TrackerContext;
5026: using TestCaseTracking::SectionTracker;
5027: using TestCaseTracking::IndexTracker;
5028: 
5029: } // namespace Catch
5030: 
5031: // end catch_test_case_tracker.h
5032: 
5033: // start catch_leak_detector.h
5034: 
5035: namespace Catch {
5036: 
5037:     struct LeakDetector {
5038:         LeakDetector();
5039:     };
5040: 
5041: }
5042: // end catch_leak_detector.h
5043: // Cpp files will be included in the single-header file here
5044: // start catch_approx.cpp
5045: 
5046: #include <cmath>
5047: #include <limits>
5048: 
5049: namespace {
5050: 
5051: // Performs equivalent check of std::fabs(lhs - rhs) <= margin
5052: // But without the subtraction to allow for INFINITY in comparison
5053: bool marginComparison(double lhs, double rhs, double margin) {
5054:     return (lhs + margin >= rhs) && (rhs + margin >= lhs);
5055: }
5056: 
5057: }
5058: 
5059: namespace Catch {
5060: namespace Detail {
5061: 
5062:     Approx::Approx ( double value )
5063:     :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),
5064:         m_margin( 0.0 ),
5065:         m_scale( 0.0 ),
5066:         m_value( value )
5067:     {}
5068: 
5069:     Approx Approx::custom() {
5070:         return Approx( 0 );
5071:     }
5072: 
5073:     Approx Approx::operator-() const {
5074:         auto temp(*this);
5075:         temp.m_value = -temp.m_value;
5076:         return temp;
5077:     }
5078: 
5079:     std::string Approx::toString() const {
5080:         ReusableStringStream rss;
5081:         rss << "Approx( " << ::Catch::Detail::stringify( m_value ) << " )";
5082:         return rss.str();
5083:     }
5084: 
5085:     bool Approx::equalityComparisonImpl(const double other) const {
5086:         // First try with fixed margin, then compute margin based on epsilon, scale and Approx's value
5087:         // Thanks to Richard Harris for his help refining the scaled margin value
5088:         return marginComparison(m_value, other, m_margin) || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(m_value)));
5089:     }
5090: 
5091:     void Approx::setMargin(double margin) {
5092:         CATCH_ENFORCE(margin >= 0,
5093:             "Invalid Approx::margin: " << margin << '.'
5094:             << " Approx::Margin has to be non-negative.");
5095:         m_margin = margin;
5096:     }
5097: 
5098:     void Approx::setEpsilon(double epsilon) {
5099:         CATCH_ENFORCE(epsilon >= 0 && epsilon <= 1.0,
5100:             "Invalid Approx::epsilon: " << epsilon << '.'
5101:             << " Approx::epsilon has to be in [0, 1]");
5102:         m_epsilon = epsilon;
5103:     }
5104: 
5105: } // end namespace Detail
5106: 
5107: namespace literals {
5108:     Detail::Approx operator "" _a(long double val) {
5109:         return Detail::Approx(val);
5110:     }
5111:     Detail::Approx operator "" _a(unsigned long long val) {
5112:         return Detail::Approx(val);
5113:     }
5114: } // end namespace literals
5115: 
5116: std::string StringMaker<Catch::Detail::Approx>::convert(Catch::Detail::Approx const& value) {
5117:     return value.toString();
5118: }
5119: 
5120: } // end namespace Catch
5121: // end catch_approx.cpp
5122: // start catch_assertionhandler.cpp
5123: 
5124: // start catch_context.h
5125: 
5126: #include <memory>
5127: 
5128: namespace Catch {
5129: 
5130:     struct IResultCapture;
5131:     struct IRunner;
5132:     struct IConfig;
5133:     struct IMutableContext;
5134: 
5135:     using IConfigPtr = std::shared_ptr<IConfig const>;
5136: 
5137:     struct IContext
5138:     {
5139:         virtual ~IContext();
5140: 
5141:         virtual IResultCapture* getResultCapture() = 0;
5142:         virtual IRunner* getRunner() = 0;
5143:         virtual IConfigPtr const& getConfig() const = 0;
5144:     };
5145: 
5146:     struct IMutableContext : IContext
5147:     {
5148:         virtual ~IMutableContext();
5149:         virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
5150:         virtual void setRunner( IRunner* runner ) = 0;
5151:         virtual void setConfig( IConfigPtr const& config ) = 0;
5152: 
5153:     private:
5154:         static IMutableContext *currentContext;
5155:         friend IMutableContext& getCurrentMutableContext();
5156:         friend void cleanUpContext();
5157:         static void createContext();
5158:     };
5159: 
5160:     inline IMutableContext& getCurrentMutableContext()
5161:     {
5162:         if( !IMutableContext::currentContext )
5163:             IMutableContext::createContext();
5164:         return *IMutableContext::currentContext;
5165:     }
5166: 
5167:     inline IContext& getCurrentContext()
5168:     {
5169:         return getCurrentMutableContext();
5170:     }
5171: 
5172:     void cleanUpContext();
5173: }
5174: 
5175: // end catch_context.h
5176: // start catch_debugger.h
5177: 
5178: namespace Catch {
5179:     bool isDebuggerActive();
5180: }
5181: 
5182: #ifdef CATCH_PLATFORM_MAC
5183: 
5184:     #define CATCH_TRAP() __asm__("int $3\n" : : ) /* NOLINT */
5185: 
5186: #elif defined(CATCH_PLATFORM_LINUX)
5187:     // If we can use inline assembler, do it because this allows us to break
5188:     // directly at the location of the failing check instead of breaking inside
5189:     // raise() called from it, i.e. one stack frame below.
5190:     #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))
5191:         #define CATCH_TRAP() asm volatile ("int $3") /* NOLINT */
5192:     #else // Fall back to the generic way.
5193:         #include <signal.h>
5194: 
5195:         #define CATCH_TRAP() raise(SIGTRAP)
5196:     #endif
5197: #elif defined(_MSC_VER)
5198:     #define CATCH_TRAP() __debugbreak()
5199: #elif defined(__MINGW32__)
5200:     extern "C" __declspec(dllimport) void __stdcall DebugBreak();
5201:     #define CATCH_TRAP() DebugBreak()
5202: #endif
5203: 
5204: #ifdef CATCH_TRAP
5205:     #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { CATCH_TRAP(); }
5206: #else
5207:     namespace Catch {
5208:         inline void doNothing() {}
5209:     }
5210:     #define CATCH_BREAK_INTO_DEBUGGER() Catch::doNothing()
5211: #endif
5212: 
5213: // end catch_debugger.h
5214: // start catch_run_context.h
5215: 
5216: // start catch_fatal_condition.h
5217: 
5218: // start catch_windows_h_proxy.h
5219: 
5220: 
5221: #if defined(CATCH_PLATFORM_WINDOWS)
5222: 
5223: #if !defined(NOMINMAX) && !defined(CATCH_CONFIG_NO_NOMINMAX)
5224: #  define CATCH_DEFINED_NOMINMAX
5225: #  define NOMINMAX
5226: #endif
5227: #if !defined(WIN32_LEAN_AND_MEAN) && !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
5228: #  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN
5229: #  define WIN32_LEAN_AND_MEAN
5230: #endif
5231: 
5232: #ifdef __AFXDLL
5233: #include <AfxWin.h>
5234: #else
5235: #include <windows.h>
5236: #endif
5237: 
5238: #ifdef CATCH_DEFINED_NOMINMAX
5239: #  undef NOMINMAX
5240: #endif
5241: #ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN
5242: #  undef WIN32_LEAN_AND_MEAN
5243: #endif
5244: 
5245: #endif // defined(CATCH_PLATFORM_WINDOWS)
5246: 
5247: // end catch_windows_h_proxy.h
5248: #if defined( CATCH_CONFIG_WINDOWS_SEH )
5249: 
5250: namespace Catch {
5251: 
5252:     struct FatalConditionHandler {
5253: 
5254:         static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo);
5255:         FatalConditionHandler();
5256:         static void reset();
5257:         ~FatalConditionHandler();
5258: 
5259:     private:
5260:         static bool isSet;
5261:         static ULONG guaranteeSize;
5262:         static PVOID exceptionHandlerHandle;
5263:     };
5264: 
5265: } // namespace Catch
5266: 
5267: #elif defined ( CATCH_CONFIG_POSIX_SIGNALS )
5268: 
5269: #include <signal.h>
5270: 
5271: namespace Catch {
5272: 
5273:     struct FatalConditionHandler {
5274: 
5275:         static bool isSet;
5276:         static struct sigaction oldSigActions[];
5277:         static stack_t oldSigStack;
5278:         static char altStackMem[];
5279: 
5280:         static void handleSignal( int sig );
5281: 
5282:         FatalConditionHandler();
5283:         ~FatalConditionHandler();
5284:         static void reset();
5285:     };
5286: 
5287: } // namespace Catch
5288: 
5289: #else
5290: 
5291: namespace Catch {
5292:     struct FatalConditionHandler {
5293:         void reset();
5294:     };
5295: }
5296: 
5297: #endif
5298: 
5299: // end catch_fatal_condition.h
5300: #include <string>
5301: 
5302: namespace Catch {
5303: 
5304:     struct IMutableContext;
5305: 
5306:     ///////////////////////////////////////////////////////////////////////////
5307: 
5308:     class RunContext : public IResultCapture, public IRunner {
5309: 
5310:     public:
5311:         RunContext( RunContext const& ) = delete;
5312:         RunContext& operator =( RunContext const& ) = delete;
5313: 
5314:         explicit RunContext( IConfigPtr const& _config, IStreamingReporterPtr&& reporter );
5315: 
5316:         ~RunContext() override;
5317: 
5318:         void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount );
5319:         void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount );
5320: 
5321:         Totals runTest(TestCase const& testCase);
5322: 
5323:         IConfigPtr config() const;
5324:         IStreamingReporter& reporter() const;
5325: 
5326:     public: // IResultCapture
5327: 
5328:         // Assertion handlers
5329:         void handleExpr
5330:                 (   AssertionInfo const& info,
5331:                     ITransientExpression const& expr,
5332:                     AssertionReaction& reaction ) override;
5333:         void handleMessage
5334:                 (   AssertionInfo const& info,
5335:                     ResultWas::OfType resultType,
5336:                     StringRef const& message,
5337:                     AssertionReaction& reaction ) override;
5338:         void handleUnexpectedExceptionNotThrown
5339:                 (   AssertionInfo const& info,
5340:                     AssertionReaction& reaction ) override;
5341:         void handleUnexpectedInflightException
5342:                 (   AssertionInfo const& info,
5343:                     std::string const& message,
5344:                     AssertionReaction& reaction ) override;
5345:         void handleIncomplete
5346:                 (   AssertionInfo const& info ) override;
5347:         void handleNonExpr
5348:                 (   AssertionInfo const &info,
5349:                     ResultWas::OfType resultType,
5350:                     AssertionReaction &reaction ) override;
5351: 
5352:         bool sectionStarted( SectionInfo const& sectionInfo, Counts& assertions ) override;
5353: 
5354:         void sectionEnded( SectionEndInfo const& endInfo ) override;
5355:         void sectionEndedEarly( SectionEndInfo const& endInfo ) override;
5356: 
5357:         auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& override;
5358: 
5359:         void benchmarkStarting( BenchmarkInfo const& info ) override;
5360:         void benchmarkEnded( BenchmarkStats const& stats ) override;
5361: 
5362:         void pushScopedMessage( MessageInfo const& message ) override;
5363:         void popScopedMessage( MessageInfo const& message ) override;
5364: 
5365:         std::string getCurrentTestName() const override;
5366: 
5367:         const AssertionResult* getLastResult() const override;
5368: 
5369:         void exceptionEarlyReported() override;
5370: 
5371:         void handleFatalErrorCondition( StringRef message ) override;
5372: 
5373:         bool lastAssertionPassed() override;
5374: 
5375:         void assertionPassed() override;
5376: 
5377:     public:
5378:         // !TBD We need to do this another way!
5379:         bool aborting() const final;
5380: 
5381:     private:
5382: 
5383:         void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );
5384:         void invokeActiveTestCase();
5385: 
5386:         void resetAssertionInfo();
5387:         bool testForMissingAssertions( Counts& assertions );
5388: 
5389:         void assertionEnded( AssertionResult const& result );
5390:         void reportExpr
5391:                 (   AssertionInfo const &info,
5392:                     ResultWas::OfType resultType,
5393:                     ITransientExpression const *expr,
5394:                     bool negated );
5395: 
5396:         void populateReaction( AssertionReaction& reaction );
5397: 
5398:     private:
5399: 
5400:         void handleUnfinishedSections();
5401: 
5402:         TestRunInfo m_runInfo;
5403:         IMutableContext& m_context;
5404:         TestCase const* m_activeTestCase = nullptr;
5405:         ITracker* m_testCaseTracker;
5406:         Option<AssertionResult> m_lastResult;
5407: 
5408:         IConfigPtr m_config;
5409:         Totals m_totals;
5410:         IStreamingReporterPtr m_reporter;
5411:         std::vector<MessageInfo> m_messages;
5412:         AssertionInfo m_lastAssertionInfo;
5413:         std::vector<SectionEndInfo> m_unfinishedSections;
5414:         std::vector<ITracker*> m_activeSections;
5415:         TrackerContext m_trackerContext;
5416:         bool m_lastAssertionPassed = false;
5417:         bool m_shouldReportUnexpected = true;
5418:         bool m_includeSuccessfulResults;
5419:     };
5420: 
5421: } // end namespace Catch
5422: 
5423: // end catch_run_context.h
5424: namespace Catch {
5425: 
5426:     namespace {
5427:         auto operator <<( std::ostream& os, ITransientExpression const& expr ) -> std::ostream& {
5428:             expr.streamReconstructedExpression( os );
5429:             return os;
5430:         }
5431:     }
5432: 
5433:     LazyExpression::LazyExpression( bool isNegated )
5434:     :   m_isNegated( isNegated )
5435:     {}
5436: 
5437:     LazyExpression::LazyExpression( LazyExpression const& other ) : m_isNegated( other.m_isNegated ) {}
5438: 
5439:     LazyExpression::operator bool() const {
5440:         return m_transientExpression != nullptr;
5441:     }
5442: 
5443:     auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream& {
5444:         if( lazyExpr.m_isNegated )
5445:             os << "!";
5446: 
5447:         if( lazyExpr ) {
5448:             if( lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression() )
5449:                 os << "(" << *lazyExpr.m_transientExpression << ")";
5450:             else
5451:                 os << *lazyExpr.m_transientExpression;
5452:         }
5453:         else {
5454:             os << "{** error - unchecked empty expression requested **}";
5455:         }
5456:         return os;
5457:     }
5458: 
5459:     AssertionHandler::AssertionHandler
5460:         (   StringRef const& macroName,
5461:             SourceLineInfo const& lineInfo,
5462:             StringRef capturedExpression,
5463:             ResultDisposition::Flags resultDisposition )
5464:     :   m_assertionInfo{ macroName, lineInfo, capturedExpression, resultDisposition },
5465:         m_resultCapture( getResultCapture() )
5466:     {}
5467: 
5468:     void AssertionHandler::handleExpr( ITransientExpression const& expr ) {
5469:         m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );
5470:     }
5471:     void AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef const& message) {
5472:         m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );
5473:     }
5474: 
5475:     auto AssertionHandler::allowThrows() const -> bool {
5476:         return getCurrentContext().getConfig()->allowThrows();
5477:     }
5478: 
5479:     void AssertionHandler::complete() {
5480:         setCompleted();
5481:         if( m_reaction.shouldDebugBreak ) {
5482: 
5483:             // If you find your debugger stopping you here then go one level up on the
5484:             // call-stack for the code that caused it (typically a failed assertion)
5485: 
5486:             // (To go back to the test and change execution, jump over the throw, next)
5487:             CATCH_BREAK_INTO_DEBUGGER();
5488:         }
5489:         if (m_reaction.shouldThrow) {
5490: #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
5491:             throw Catch::TestFailureException();
5492: #else
5493:             CATCH_ERROR( "Test failure requires aborting test!" );
5494: #endif
5495:         }
5496:     }
5497:     void AssertionHandler::setCompleted() {
5498:         m_completed = true;
5499:     }
5500: 
5501:     void AssertionHandler::handleUnexpectedInflightException() {
5502:         m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );
5503:     }
5504: 
5505:     void AssertionHandler::handleExceptionThrownAsExpected() {
5506:         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
5507:     }
5508:     void AssertionHandler::handleExceptionNotThrownAsExpected() {
5509:         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
5510:     }
5511: 
5512:     void AssertionHandler::handleUnexpectedExceptionNotThrown() {
5513:         m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );
5514:     }
5515: 
5516:     void AssertionHandler::handleThrowingCallSkipped() {
5517:         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
5518:     }
5519: 
5520:     // This is the overload that takes a string and infers the Equals matcher from it
5521:     // The more general overload, that takes any string matcher, is in catch_capture_matchers.cpp
5522:     void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef const& matcherString  ) {
5523:         handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );
5524:     }
5525: 
5526: } // namespace Catch
5527: // end catch_assertionhandler.cpp
5528: // start catch_assertionresult.cpp
5529: 
5530: namespace Catch {
5531:     AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression const & _lazyExpression):
5532:         lazyExpression(_lazyExpression),
5533:         resultType(_resultType) {}
5534: 
5535:     std::string AssertionResultData::reconstructExpression() const {
5536: 
5537:         if( reconstructedExpression.empty() ) {
5538:             if( lazyExpression ) {
5539:                 ReusableStringStream rss;
5540:                 rss << lazyExpression;
5541:                 reconstructedExpression = rss.str();
5542:             }
5543:         }
5544:         return reconstructedExpression;
5545:     }
5546: 
5547:     AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data )
5548:     :   m_info( info ),
5549:         m_resultData( data )
5550:     {}
5551: 
5552:     // Result was a success
5553:     bool AssertionResult::succeeded() const {
5554:         return Catch::isOk( m_resultData.resultType );
5555:     }
5556: 
5557:     // Result was a success, or failure is suppressed
5558:     bool AssertionResult::isOk() const {
5559:         return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );
5560:     }
5561: 
5562:     ResultWas::OfType AssertionResult::getResultType() const {
5563:         return m_resultData.resultType;
5564:     }
5565: 
5566:     bool AssertionResult::hasExpression() const {
5567:         return m_info.capturedExpression[0] != 0;
5568:     }
5569: 
5570:     bool AssertionResult::hasMessage() const {
5571:         return !m_resultData.message.empty();
5572:     }
5573: 
5574:     std::string AssertionResult::getExpression() const {
5575:         if( isFalseTest( m_info.resultDisposition ) )
5576:             return "!(" + m_info.capturedExpression + ")";
5577:         else
5578:             return m_info.capturedExpression;
5579:     }
5580: 
5581:     std::string AssertionResult::getExpressionInMacro() const {
5582:         std::string expr;
5583:         if( m_info.macroName[0] == 0 )
5584:             expr = m_info.capturedExpression;
5585:         else {
5586:             expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );
5587:             expr += m_info.macroName;
5588:             expr += "( ";
5589:             expr += m_info.capturedExpression;
5590:             expr += " )";
5591:         }
5592:         return expr;
5593:     }
5594: 
5595:     bool AssertionResult::hasExpandedExpression() const {
5596:         return hasExpression() && getExpandedExpression() != getExpression();
5597:     }
5598: 
5599:     std::string AssertionResult::getExpandedExpression() const {
5600:         std::string expr = m_resultData.reconstructExpression();
5601:         return expr.empty()
5602:                 ? getExpression()
5603:                 : expr;
5604:     }
5605: 
5606:     std::string AssertionResult::getMessage() const {
5607:         return m_resultData.message;
5608:     }
5609:     SourceLineInfo AssertionResult::getSourceInfo() const {
5610:         return m_info.lineInfo;
5611:     }
5612: 
5613:     StringRef AssertionResult::getTestMacroName() const {
5614:         return m_info.macroName;
5615:     }
5616: 
5617: } // end namespace Catch
5618: // end catch_assertionresult.cpp
5619: // start catch_benchmark.cpp
5620: 
5621: namespace Catch {
5622: 
5623:     auto BenchmarkLooper::getResolution() -> uint64_t {
5624:         return getEstimatedClockResolution() * getCurrentContext().getConfig()->benchmarkResolutionMultiple();
5625:     }
5626: 
5627:     void BenchmarkLooper::reportStart() {
5628:         getResultCapture().benchmarkStarting( { m_name } );
5629:     }
5630:     auto BenchmarkLooper::needsMoreIterations() -> bool {
5631:         auto elapsed = m_timer.getElapsedNanoseconds();
5632: 
5633:         // Exponentially increasing iterations until we're confident in our timer resolution
5634:         if( elapsed < m_resolution ) {
5635:             m_iterationsToRun *= 10;
5636:             return true;
5637:         }
5638: 
5639:         getResultCapture().benchmarkEnded( { { m_name }, m_count, elapsed } );
5640:         return false;
5641:     }
5642: 
5643: } // end namespace Catch
5644: // end catch_benchmark.cpp
5645: // start catch_capture_matchers.cpp
5646: 
5647: namespace Catch {
5648: 
5649:     using StringMatcher = Matchers::Impl::MatcherBase<std::string>;
5650: 
5651:     // This is the general overload that takes a any string matcher
5652:     // There is another overload, in catch_assertionhandler.h/.cpp, that only takes a string and infers
5653:     // the Equals matcher (so the header does not mention matchers)
5654:     void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef const& matcherString  ) {
5655:         std::string exceptionMessage = Catch::translateActiveException();
5656:         MatchExpr<std::string, StringMatcher const&> expr( exceptionMessage, matcher, matcherString );
5657:         handler.handleExpr( expr );
5658:     }
5659: 
5660: } // namespace Catch
5661: // end catch_capture_matchers.cpp
5662: // start catch_commandline.cpp
5663: 
5664: // start catch_commandline.h
5665: 
5666: // start catch_clara.h
5667: 
5668: // Use Catch's value for console width (store Clara's off to the side, if present)
5669: #ifdef CLARA_CONFIG_CONSOLE_WIDTH
5670: #define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
5671: #undef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
5672: #endif
5673: #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH-1
5674: 
5675: #ifdef __clang__
5676: #pragma clang diagnostic push
5677: #pragma clang diagnostic ignored "-Wweak-vtables"
5678: #pragma clang diagnostic ignored "-Wexit-time-destructors"
5679: #pragma clang diagnostic ignored "-Wshadow"
5680: #endif
5681: 
5682: // start clara.hpp
5683: // Copyright 2017 Two Blue Cubes Ltd. All rights reserved.
5684: //
5685: // Distributed under the Boost Software License, Version 1.0. (See accompanying
5686: // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
5687: //
5688: // See https://github.com/philsquared/Clara for more details
5689: 
5690: // Clara v1.1.4
5691: 
5692: 
5693: #ifndef CATCH_CLARA_CONFIG_CONSOLE_WIDTH
5694: #define CATCH_CLARA_CONFIG_CONSOLE_WIDTH 80
5695: #endif
5696: 
5697: #ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
5698: #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CLARA_CONFIG_CONSOLE_WIDTH
5699: #endif
5700: 
5701: #ifndef CLARA_CONFIG_OPTIONAL_TYPE
5702: #ifdef __has_include
5703: #if __has_include(<optional>) && __cplusplus >= 201703L
5704: #include <optional>
5705: #define CLARA_CONFIG_OPTIONAL_TYPE std::optional
5706: #endif
5707: #endif
5708: #endif
5709: 
5710: // ----------- #included from clara_textflow.hpp -----------
5711: 
5712: // TextFlowCpp
5713: //
5714: // A single-header library for wrapping and laying out basic text, by Phil Nash
5715: //
5716: // This work is licensed under the BSD 2-Clause license.
5717: // See the accompanying LICENSE file, or the one at https://opensource.org/licenses/BSD-2-Clause
5718: //
5719: // This project is hosted at https://github.com/philsquared/textflowcpp
5720: 
5721: 
5722: #include <cassert>
5723: #include <ostream>
5724: #include <sstream>
5725: #include <vector>
5726: 
5727: #ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
5728: #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH 80
5729: #endif
5730: 
5731: namespace Catch { namespace clara { namespace TextFlow {
5732: 
5733:     inline auto isWhitespace( char c ) -> bool {
5734:         static std::string chars = " \t\n\r";
5735:         return chars.find( c ) != std::string::npos;
5736:     }
5737:     inline auto isBreakableBefore( char c ) -> bool {
5738:         static std::string chars = "[({<|";
5739:         return chars.find( c ) != std::string::npos;
5740:     }
5741:     inline auto isBreakableAfter( char c ) -> bool {
5742:         static std::string chars = "])}>.,:;*+-=&/\\";
5743:         return chars.find( c ) != std::string::npos;
5744:     }
5745: 
5746:     class Columns;
5747: 
5748:     class Column {
5749:         std::vector<std::string> m_strings;
5750:         size_t m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;
5751:         size_t m_indent = 0;
5752:         size_t m_initialIndent = std::string::npos;
5753: 
5754:     public:
5755:         class iterator {
5756:             friend Column;
5757: 
5758:             Column const& m_column;
5759:             size_t m_stringIndex = 0;
5760:             size_t m_pos = 0;
5761: 
5762:             size_t m_len = 0;
5763:             size_t m_end = 0;
5764:             bool m_suffix = false;
5765: 
5766:             iterator( Column const& column, size_t stringIndex )
5767:             :   m_column( column ),
5768:                 m_stringIndex( stringIndex )
5769:             {}
5770: 
5771:             auto line() const -> std::string const& { return m_column.m_strings[m_stringIndex]; }
5772: 
5773:             auto isBoundary( size_t at ) const -> bool {
5774:                 assert( at > 0 );
5775:                 assert( at <= line().size() );
5776: 
5777:                 return at == line().size() ||
5778:                        ( isWhitespace( line()[at] ) && !isWhitespace( line()[at-1] ) ) ||
5779:                        isBreakableBefore( line()[at] ) ||
5780:                        isBreakableAfter( line()[at-1] );
5781:             }
5782: 
5783:             void calcLength() {
5784:                 assert( m_stringIndex < m_column.m_strings.size() );
5785: 
5786:                 m_suffix = false;
5787:                 auto width = m_column.m_width-indent();
5788:                 m_end = m_pos;
5789:                 while( m_end < line().size() && line()[m_end] != '\n' )
5790:                     ++m_end;
5791: 
5792:                 if( m_end < m_pos + width ) {
5793:                     m_len = m_end - m_pos;
5794:                 }
5795:                 else {
5796:                     size_t len = width;
5797:                     while (len > 0 && !isBoundary(m_pos + len))
5798:                         --len;
5799:                     while (len > 0 && isWhitespace( line()[m_pos + len - 1] ))
5800:                         --len;
5801: 
5802:                     if (len > 0) {
5803:                         m_len = len;
5804:                     } else {
5805:                         m_suffix = true;
5806:                         m_len = width - 1;
5807:                     }
5808:                 }
5809:             }
5810: 
5811:             auto indent() const -> size_t {
5812:                 auto initial = m_pos == 0 && m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;
5813:                 return initial == std::string::npos ? m_column.m_indent : initial;
5814:             }
5815: 
5816:             auto addIndentAndSuffix(std::string const &plain) const -> std::string {
5817:                 return std::string( indent(), ' ' ) + (m_suffix ? plain + "-" : plain);
5818:             }
5819: 
5820:         public:
5821:             explicit iterator( Column const& column ) : m_column( column ) {
5822:                 assert( m_column.m_width > m_column.m_indent );
5823:                 assert( m_column.m_initialIndent == std::string::npos || m_column.m_width > m_column.m_initialIndent );
5824:                 calcLength();
5825:                 if( m_len == 0 )
5826:                     m_stringIndex++; // Empty string
5827:             }
5828: 
5829:             auto operator *() const -> std::string {
5830:                 assert( m_stringIndex < m_column.m_strings.size() );
5831:                 assert( m_pos <= m_end );
5832:                 if( m_pos + m_column.m_width < m_end )
5833:                     return addIndentAndSuffix(line().substr(m_pos, m_len));
5834:                 else
5835:                     return addIndentAndSuffix(line().substr(m_pos, m_end - m_pos));
5836:             }
5837: 
5838:             auto operator ++() -> iterator& {
5839:                 m_pos += m_len;
5840:                 if( m_pos < line().size() && line()[m_pos] == '\n' )
5841:                     m_pos += 1;
5842:                 else
5843:                     while( m_pos < line().size() && isWhitespace( line()[m_pos] ) )
5844:                         ++m_pos;
5845: 
5846:                 if( m_pos == line().size() ) {
5847:                     m_pos = 0;
5848:                     ++m_stringIndex;
5849:                 }
5850:                 if( m_stringIndex < m_column.m_strings.size() )
5851:                     calcLength();
5852:                 return *this;
5853:             }
5854:             auto operator ++(int) -> iterator {
5855:                 iterator prev( *this );
5856:                 operator++();
5857:                 return prev;
5858:             }
5859: 
5860:             auto operator ==( iterator const& other ) const -> bool {
5861:                 return
5862:                     m_pos == other.m_pos &&
5863:                     m_stringIndex == other.m_stringIndex &&
5864:                     &m_column == &other.m_column;
5865:             }
5866:             auto operator !=( iterator const& other ) const -> bool {
5867:                 return !operator==( other );
5868:             }
5869:         };
5870:         using const_iterator = iterator;
5871: 
5872:         explicit Column( std::string const& text ) { m_strings.push_back( text ); }
5873: 
5874:         auto width( size_t newWidth ) -> Column& {
5875:             assert( newWidth > 0 );
5876:             m_width = newWidth;
5877:             return *this;
5878:         }
5879:         auto indent( size_t newIndent ) -> Column& {
5880:             m_indent = newIndent;
5881:             return *this;
5882:         }
5883:         auto initialIndent( size_t newIndent ) -> Column& {
5884:             m_initialIndent = newIndent;
5885:             return *this;
5886:         }
5887: 
5888:         auto width() const -> size_t { return m_width; }
5889:         auto begin() const -> iterator { return iterator( *this ); }
5890:         auto end() const -> iterator { return { *this, m_strings.size() }; }
5891: 
5892:         inline friend std::ostream& operator << ( std::ostream& os, Column const& col ) {
5893:             bool first = true;
5894:             for( auto line : col ) {
5895:                 if( first )
5896:                     first = false;
5897:                 else
5898:                     os << "\n";
5899:                 os <<  line;
5900:             }
5901:             return os;
5902:         }
5903: 
5904:         auto operator + ( Column const& other ) -> Columns;
5905: 
5906:         auto toString() const -> std::string {
5907:             std::ostringstream oss;
5908:             oss << *this;
5909:             return oss.str();
5910:         }
5911:     };
5912: 
5913:     class Spacer : public Column {
5914: 
5915:     public:
5916:         explicit Spacer( size_t spaceWidth ) : Column( "" ) {
5917:             width( spaceWidth );
5918:         }
5919:     };
5920: 
5921:     class Columns {
5922:         std::vector<Column> m_columns;
5923: 
5924:     public:
5925: 
5926:         class iterator {
5927:             friend Columns;
5928:             struct EndTag {};
5929: 
5930:             std::vector<Column> const& m_columns;
5931:             std::vector<Column::iterator> m_iterators;
5932:             size_t m_activeIterators;
5933: 
5934:             iterator( Columns const& columns, EndTag )
5935:             :   m_columns( columns.m_columns ),
5936:                 m_activeIterators( 0 )
5937:             {
5938:                 m_iterators.reserve( m_columns.size() );
5939: 
5940:                 for( auto const& col : m_columns )
5941:                     m_iterators.push_back( col.end() );
5942:             }
5943: 
5944:         public:
5945:             explicit iterator( Columns const& columns )
5946:             :   m_columns( columns.m_columns ),
5947:                 m_activeIterators( m_columns.size() )
5948:             {
5949:                 m_iterators.reserve( m_columns.size() );
5950: 
5951:                 for( auto const& col : m_columns )
5952:                     m_iterators.push_back( col.begin() );
5953:             }
5954: 
5955:             auto operator ==( iterator const& other ) const -> bool {
5956:                 return m_iterators == other.m_iterators;
5957:             }
5958:             auto operator !=( iterator const& other ) const -> bool {
5959:                 return m_iterators != other.m_iterators;
5960:             }
5961:             auto operator *() const -> std::string {
5962:                 std::string row, padding;
5963: 
5964:                 for( size_t i = 0; i < m_columns.size(); ++i ) {
5965:                     auto width = m_columns[i].width();
5966:                     if( m_iterators[i] != m_columns[i].end() ) {
5967:                         std::string col = *m_iterators[i];
5968:                         row += padding + col;
5969:                         if( col.size() < width )
5970:                             padding = std::string( width - col.size(), ' ' );
5971:                         else
5972:                             padding = "";
5973:                     }
5974:                     else {
5975:                         padding += std::string( width, ' ' );
5976:                     }
5977:                 }
5978:                 return row;
5979:             }
5980:             auto operator ++() -> iterator& {
5981:                 for( size_t i = 0; i < m_columns.size(); ++i ) {
5982:                     if (m_iterators[i] != m_columns[i].end())
5983:                         ++m_iterators[i];
5984:                 }
5985:                 return *this;
5986:             }
5987:             auto operator ++(int) -> iterator {
5988:                 iterator prev( *this );
5989:                 operator++();
5990:                 return prev;
5991:             }
5992:         };
5993:         using const_iterator = iterator;
5994: 
5995:         auto begin() const -> iterator { return iterator( *this ); }
5996:         auto end() const -> iterator { return { *this, iterator::EndTag() }; }
5997: 
5998:         auto operator += ( Column const& col ) -> Columns& {
5999:             m_columns.push_back( col );
6000:             return *this;
6001:         }
6002:         auto operator + ( Column const& col ) -> Columns {
6003:             Columns combined = *this;
6004:             combined += col;
6005:             return combined;
6006:         }
6007: 
6008:         inline friend std::ostream& operator << ( std::ostream& os, Columns const& cols ) {
6009: 
6010:             bool first = true;
6011:             for( auto line : cols ) {
6012:                 if( first )
6013:                     first = false;
6014:                 else
6015:                     os << "\n";
6016:                 os << line;
6017:             }
6018:             return os;
6019:         }
6020: 
6021:         auto toString() const -> std::string {
6022:             std::ostringstream oss;
6023:             oss << *this;
6024:             return oss.str();
6025:         }
6026:     };
6027: 
6028:     inline auto Column::operator + ( Column const& other ) -> Columns {
6029:         Columns cols;
6030:         cols += *this;
6031:         cols += other;
6032:         return cols;
6033:     }
6034: }}} // namespace Catch::clara::TextFlow
6035: 
6036: // ----------- end of #include from clara_textflow.hpp -----------
6037: // ........... back in clara.hpp
6038: 
6039: #include <memory>
6040: #include <set>
6041: #include <algorithm>
6042: 
6043: #if !defined(CATCH_PLATFORM_WINDOWS) && ( defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) )
6044: #define CATCH_PLATFORM_WINDOWS
6045: #endif
6046: 
6047: namespace Catch { namespace clara {
6048: namespace detail {
6049: 
6050:     // Traits for extracting arg and return type of lambdas (for single argument lambdas)
6051:     template<typename L>
6052:     struct UnaryLambdaTraits : UnaryLambdaTraits<decltype( &L::operator() )> {};
6053: 
6054:     template<typename ClassT, typename ReturnT, typename... Args>
6055:     struct UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> {
6056:         static const bool isValid = false;
6057:     };
6058: 
6059:     template<typename ClassT, typename ReturnT, typename ArgT>
6060:     struct UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> {
6061:         static const bool isValid = true;
6062:         using ArgType = typename std::remove_const<typename std::remove_reference<ArgT>::type>::type;
6063:         using ReturnType = ReturnT;
6064:     };
6065: 
6066:     class TokenStream;
6067: 
6068:     // Transport for raw args (copied from main args, or supplied via init list for testing)
6069:     class Args {
6070:         friend TokenStream;
6071:         std::string m_exeName;
6072:         std::vector<std::string> m_args;
6073: 
6074:     public:
6075:         Args( int argc, char const* const* argv )
6076:             : m_exeName(argv[0]),
6077:               m_args(argv + 1, argv + argc) {}
6078: 
6079:         Args( std::initializer_list<std::string> args )
6080:         :   m_exeName( *args.begin() ),
6081:             m_args( args.begin()+1, args.end() )
6082:         {}
6083: 
6084:         auto exeName() const -> std::string {
6085:             return m_exeName;
6086:         }
6087:     };
6088: 
6089:     // Wraps a token coming from a token stream. These may not directly correspond to strings as a single string
6090:     // may encode an option + its argument if the : or = form is used
6091:     enum class TokenType {
6092:         Option, Argument
6093:     };
6094:     struct Token {
6095:         TokenType type;
6096:         std::string token;
6097:     };
6098: 
6099:     inline auto isOptPrefix( char c ) -> bool {
6100:         return c == '-'
6101: #ifdef CATCH_PLATFORM_WINDOWS
6102:             || c == '/'
6103: #endif
6104:         ;
6105:     }
6106: 
6107:     // Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled
6108:     class TokenStream {
6109:         using Iterator = std::vector<std::string>::const_iterator;
6110:         Iterator it;
6111:         Iterator itEnd;
6112:         std::vector<Token> m_tokenBuffer;
6113: 
6114:         void loadBuffer() {
6115:             m_tokenBuffer.resize( 0 );
6116: 
6117:             // Skip any empty strings
6118:             while( it != itEnd && it->empty() )
6119:                 ++it;
6120: 
6121:             if( it != itEnd ) {
6122:                 auto const &next = *it;
6123:                 if( isOptPrefix( next[0] ) ) {
6124:                     auto delimiterPos = next.find_first_of( " :=" );
6125:                     if( delimiterPos != std::string::npos ) {
6126:                         m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );
6127:                         m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );
6128:                     } else {
6129:                         if( next[1] != '-' && next.size() > 2 ) {
6130:                             std::string opt = "- ";
6131:                             for( size_t i = 1; i < next.size(); ++i ) {
6132:                                 opt[1] = next[i];
6133:                                 m_tokenBuffer.push_back( { TokenType::Option, opt } );
6134:                             }
6135:                         } else {
6136:                             m_tokenBuffer.push_back( { TokenType::Option, next } );
6137:                         }
6138:                     }
6139:                 } else {
6140:                     m_tokenBuffer.push_back( { TokenType::Argument, next } );
6141:                 }
6142:             }
6143:         }
6144: 
6145:     public:
6146:         explicit TokenStream( Args const &args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}
6147: 
6148:         TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {
6149:             loadBuffer();
6150:         }
6151: 
6152:         explicit operator bool() const {
6153:             return !m_tokenBuffer.empty() || it != itEnd;
6154:         }
6155: 
6156:         auto count() const -> size_t { return m_tokenBuffer.size() + (itEnd - it); }
6157: 
6158:         auto operator*() const -> Token {
6159:             assert( !m_tokenBuffer.empty() );
6160:             return m_tokenBuffer.front();
6161:         }
6162: 
6163:         auto operator->() const -> Token const * {
6164:             assert( !m_tokenBuffer.empty() );
6165:             return &m_tokenBuffer.front();
6166:         }
6167: 
6168:         auto operator++() -> TokenStream & {
6169:             if( m_tokenBuffer.size() >= 2 ) {
6170:                 m_tokenBuffer.erase( m_tokenBuffer.begin() );
6171:             } else {
6172:                 if( it != itEnd )
6173:                     ++it;
6174:                 loadBuffer();
6175:             }
6176:             return *this;
6177:         }
6178:     };
6179: 
6180:     class ResultBase {
6181:     public:
6182:         enum Type {
6183:             Ok, LogicError, RuntimeError
6184:         };
6185: 
6186:     protected:
6187:         ResultBase( Type type ) : m_type( type ) {}
6188:         virtual ~ResultBase() = default;
6189: 
6190:         virtual void enforceOk() const = 0;
6191: 
6192:         Type m_type;
6193:     };
6194: 
6195:     template<typename T>
6196:     class ResultValueBase : public ResultBase {
6197:     public:
6198:         auto value() const -> T const & {
6199:             enforceOk();
6200:             return m_value;
6201:         }
6202: 
6203:     protected:
6204:         ResultValueBase( Type type ) : ResultBase( type ) {}
6205: 
6206:         ResultValueBase( ResultValueBase const &other ) : ResultBase( other ) {
6207:             if( m_type == ResultBase::Ok )
6208:                 new( &m_value ) T( other.m_value );
6209:         }
6210: 
6211:         ResultValueBase( Type, T const &value ) : ResultBase( Ok ) {
6212:             new( &m_value ) T( value );
6213:         }
6214: 
6215:         auto operator=( ResultValueBase const &other ) -> ResultValueBase & {
6216:             if( m_type == ResultBase::Ok )
6217:                 m_value.~T();
6218:             ResultBase::operator=(other);
6219:             if( m_type == ResultBase::Ok )
6220:                 new( &m_value ) T( other.m_value );
6221:             return *this;
6222:         }
6223: 
6224:         ~ResultValueBase() override {
6225:             if( m_type == Ok )
6226:                 m_value.~T();
6227:         }
6228: 
6229:         union {
6230:             T m_value;
6231:         };
6232:     };
6233: 
6234:     template<>
6235:     class ResultValueBase<void> : public ResultBase {
6236:     protected:
6237:         using ResultBase::ResultBase;
6238:     };
6239: 
6240:     template<typename T = void>
6241:     class BasicResult : public ResultValueBase<T> {
6242:     public:
6243:         template<typename U>
6244:         explicit BasicResult( BasicResult<U> const &other )
6245:         :   ResultValueBase<T>( other.type() ),
6246:             m_errorMessage( other.errorMessage() )
6247:         {
6248:             assert( type() != ResultBase::Ok );
6249:         }
6250: 
6251:         template<typename U>
6252:         static auto ok( U const &value ) -> BasicResult { return { ResultBase::Ok, value }; }
6253:         static auto ok() -> BasicResult { return { ResultBase::Ok }; }
6254:         static auto logicError( std::string const &message ) -> BasicResult { return { ResultBase::LogicError, message }; }
6255:         static auto runtimeError( std::string const &message ) -> BasicResult { return { ResultBase::RuntimeError, message }; }
6256: 
6257:         explicit operator bool() const { return m_type == ResultBase::Ok; }
6258:         auto type() const -> ResultBase::Type { return m_type; }
6259:         auto errorMessage() const -> std::string { return m_errorMessage; }
6260: 
6261:     protected:
6262:         void enforceOk() const override {
6263: 
6264:             // Errors shouldn't reach this point, but if they do
6265:             // the actual error message will be in m_errorMessage
6266:             assert( m_type != ResultBase::LogicError );
6267:             assert( m_type != ResultBase::RuntimeError );
6268:             if( m_type != ResultBase::Ok )
6269:                 std::abort();
6270:         }
6271: 
6272:         std::string m_errorMessage; // Only populated if resultType is an error
6273: 
6274:         BasicResult( ResultBase::Type type, std::string const &message )
6275:         :   ResultValueBase<T>(type),
6276:             m_errorMessage(message)
6277:         {
6278:             assert( m_type != ResultBase::Ok );
6279:         }
6280: 
6281:         using ResultValueBase<T>::ResultValueBase;
6282:         using ResultBase::m_type;
6283:     };
6284: 
6285:     enum class ParseResultType {
6286:         Matched, NoMatch, ShortCircuitAll, ShortCircuitSame
6287:     };
6288: 
6289:     class ParseState {
6290:     public:
6291: 
6292:         ParseState( ParseResultType type, TokenStream const &remainingTokens )
6293:         : m_type(type),
6294:           m_remainingTokens( remainingTokens )
6295:         {}
6296: 
6297:         auto type() const -> ParseResultType { return m_type; }
6298:         auto remainingTokens() const -> TokenStream { return m_remainingTokens; }
6299: 
6300:     private:
6301:         ParseResultType m_type;
6302:         TokenStream m_remainingTokens;
6303:     };
6304: 
6305:     using Result = BasicResult<void>;
6306:     using ParserResult = BasicResult<ParseResultType>;
6307:     using InternalParseResult = BasicResult<ParseState>;
6308: 
6309:     struct HelpColumns {
6310:         std::string left;
6311:         std::string right;
6312:     };
6313: 
6314:     template<typename T>
6315:     inline auto convertInto( std::string const &source, T& target ) -> ParserResult {
6316:         std::stringstream ss;
6317:         ss << source;
6318:         ss >> target;
6319:         if( ss.fail() )
6320:             return ParserResult::runtimeError( "Unable to convert '" + source + "' to destination type" );
6321:         else
6322:             return ParserResult::ok( ParseResultType::Matched );
6323:     }
6324:     inline auto convertInto( std::string const &source, std::string& target ) -> ParserResult {
6325:         target = source;
6326:         return ParserResult::ok( ParseResultType::Matched );
6327:     }
6328:     inline auto convertInto( std::string const &source, bool &target ) -> ParserResult {
6329:         std::string srcLC = source;
6330:         std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( char c ) { return static_cast<char>( ::tolower(c) ); } );
6331:         if (srcLC == "y" || srcLC == "1" || srcLC == "true" || srcLC == "yes" || srcLC == "on")
6332:             target = true;
6333:         else if (srcLC == "n" || srcLC == "0" || srcLC == "false" || srcLC == "no" || srcLC == "off")
6334:             target = false;
6335:         else
6336:             return ParserResult::runtimeError( "Expected a boolean value but did not recognise: '" + source + "'" );
6337:         return ParserResult::ok( ParseResultType::Matched );
6338:     }
6339: #ifdef CLARA_CONFIG_OPTIONAL_TYPE
6340:     template<typename T>
6341:     inline auto convertInto( std::string const &source, CLARA_CONFIG_OPTIONAL_TYPE<T>& target ) -> ParserResult {
6342:         T temp;
6343:         auto result = convertInto( source, temp );
6344:         if( result )
6345:             target = std::move(temp);
6346:         return result;
6347:     }
6348: #endif // CLARA_CONFIG_OPTIONAL_TYPE
6349: 
6350:     struct NonCopyable {
6351:         NonCopyable() = default;
6352:         NonCopyable( NonCopyable const & ) = delete;
6353:         NonCopyable( NonCopyable && ) = delete;
6354:         NonCopyable &operator=( NonCopyable const & ) = delete;
6355:         NonCopyable &operator=( NonCopyable && ) = delete;
6356:     };
6357: 
6358:     struct BoundRef : NonCopyable {
6359:         virtual ~BoundRef() = default;
6360:         virtual auto isContainer() const -> bool { return false; }
6361:         virtual auto isFlag() const -> bool { return false; }
6362:     };
6363:     struct BoundValueRefBase : BoundRef {
6364:         virtual auto setValue( std::string const &arg ) -> ParserResult = 0;
6365:     };
6366:     struct BoundFlagRefBase : BoundRef {
6367:         virtual auto setFlag( bool flag ) -> ParserResult = 0;
6368:         virtual auto isFlag() const -> bool { return true; }
6369:     };
6370: 
6371:     template<typename T>
6372:     struct BoundValueRef : BoundValueRefBase {
6373:         T &m_ref;
6374: 
6375:         explicit BoundValueRef( T &ref ) : m_ref( ref ) {}
6376: 
6377:         auto setValue( std::string const &arg ) -> ParserResult override {
6378:             return convertInto( arg, m_ref );
6379:         }
6380:     };
6381: 
6382:     template<typename T>
6383:     struct BoundValueRef<std::vector<T>> : BoundValueRefBase {
6384:         std::vector<T> &m_ref;
6385: 
6386:         explicit BoundValueRef( std::vector<T> &ref ) : m_ref( ref ) {}
6387: 
6388:         auto isContainer() const -> bool override { return true; }
6389: 
6390:         auto setValue( std::string const &arg ) -> ParserResult override {
6391:             T temp;
6392:             auto result = convertInto( arg, temp );
6393:             if( result )
6394:                 m_ref.push_back( temp );
6395:             return result;
6396:         }
6397:     };
6398: 
6399:     struct BoundFlagRef : BoundFlagRefBase {
6400:         bool &m_ref;
6401: 
6402:         explicit BoundFlagRef( bool &ref ) : m_ref( ref ) {}
6403: 
6404:         auto setFlag( bool flag ) -> ParserResult override {
6405:             m_ref = flag;
6406:             return ParserResult::ok( ParseResultType::Matched );
6407:         }
6408:     };
6409: 
6410:     template<typename ReturnType>
6411:     struct LambdaInvoker {
6412:         static_assert( std::is_same<ReturnType, ParserResult>::value, "Lambda must return void or clara::ParserResult" );
6413: 
6414:         template<typename L, typename ArgType>
6415:         static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
6416:             return lambda( arg );
6417:         }
6418:     };
6419: 
6420:     template<>
6421:     struct LambdaInvoker<void> {
6422:         template<typename L, typename ArgType>
6423:         static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
6424:             lambda( arg );
6425:             return ParserResult::ok( ParseResultType::Matched );
6426:         }
6427:     };
6428: 
6429:     template<typename ArgType, typename L>
6430:     inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
6431:         ArgType temp{};
6432:         auto result = convertInto( arg, temp );
6433:         return !result
6434:            ? result
6435:            : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
6436:     }
6437: 
6438:     template<typename L>
6439:     struct BoundLambda : BoundValueRefBase {
6440:         L m_lambda;
6441: 
6442:         static_assert( UnaryLambdaTraits<L>::isValid, "Supplied lambda must take exactly one argument" );
6443:         explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
6444: 
6445:         auto setValue( std::string const &arg ) -> ParserResult override {
6446:             return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
6447:         }
6448:     };
6449: 
6450:     template<typename L>
6451:     struct BoundFlagLambda : BoundFlagRefBase {
6452:         L m_lambda;
6453: 
6454:         static_assert( UnaryLambdaTraits<L>::isValid, "Supplied lambda must take exactly one argument" );
6455:         static_assert( std::is_same<typename UnaryLambdaTraits<L>::ArgType, bool>::value, "flags must be boolean" );
6456: 
6457:         explicit BoundFlagLambda( L const &lambda ) : m_lambda( lambda ) {}
6458: 
6459:         auto setFlag( bool flag ) -> ParserResult override {
6460:             return LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );
6461:         }
6462:     };
6463: 
6464:     enum class Optionality { Optional, Required };
6465: 
6466:     struct Parser;
6467: 
6468:     class ParserBase {
6469:     public:
6470:         virtual ~ParserBase() = default;
6471:         virtual auto validate() const -> Result { return Result::ok(); }
6472:         virtual auto parse( std::string const& exeName, TokenStream const &tokens) const -> InternalParseResult  = 0;
6473:         virtual auto cardinality() const -> size_t { return 1; }
6474: 
6475:         auto parse( Args const &args ) const -> InternalParseResult {
6476:             return parse( args.exeName(), TokenStream( args ) );
6477:         }
6478:     };
6479: 
6480:     template<typename DerivedT>
6481:     class ComposableParserImpl : public ParserBase {
6482:     public:
6483:         template<typename T>
6484:         auto operator|( T const &other ) const -> Parser;
6485: 
6486: 		template<typename T>
6487:         auto operator+( T const &other ) const -> Parser;
6488:     };
6489: 
6490:     // Common code and state for Args and Opts
6491:     template<typename DerivedT>
6492:     class ParserRefImpl : public ComposableParserImpl<DerivedT> {
6493:     protected:
6494:         Optionality m_optionality = Optionality::Optional;
6495:         std::shared_ptr<BoundRef> m_ref;
6496:         std::string m_hint;
6497:         std::string m_description;
6498: 
6499:         explicit ParserRefImpl( std::shared_ptr<BoundRef> const &ref ) : m_ref( ref ) {}
6500: 
6501:     public:
6502:         template<typename T>
6503:         ParserRefImpl( T &ref, std::string const &hint )
6504:         :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),
6505:             m_hint( hint )
6506:         {}
6507: 
6508:         template<typename LambdaT>
6509:         ParserRefImpl( LambdaT const &ref, std::string const &hint )
6510:         :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
6511:             m_hint(hint)
6512:         {}
6513: 
6514:         auto operator()( std::string const &description ) -> DerivedT & {
6515:             m_description = description;
6516:             return static_cast<DerivedT &>( *this );
6517:         }
6518: 
6519:         auto optional() -> DerivedT & {
6520:             m_optionality = Optionality::Optional;
6521:             return static_cast<DerivedT &>( *this );
6522:         };
6523: 
6524:         auto required() -> DerivedT & {
6525:             m_optionality = Optionality::Required;
6526:             return static_cast<DerivedT &>( *this );
6527:         };
6528: 
6529:         auto isOptional() const -> bool {
6530:             return m_optionality == Optionality::Optional;
6531:         }
6532: 
6533:         auto cardinality() const -> size_t override {
6534:             if( m_ref->isContainer() )
6535:                 return 0;
6536:             else
6537:                 return 1;
6538:         }
6539: 
6540:         auto hint() const -> std::string { return m_hint; }
6541:     };
6542: 
6543:     class ExeName : public ComposableParserImpl<ExeName> {
6544:         std::shared_ptr<std::string> m_name;
6545:         std::shared_ptr<BoundValueRefBase> m_ref;
6546: 
6547:         template<typename LambdaT>
6548:         static auto makeRef(LambdaT const &lambda) -> std::shared_ptr<BoundValueRefBase> {
6549:             return std::make_shared<BoundLambda<LambdaT>>( lambda) ;
6550:         }
6551: 
6552:     public:
6553:         ExeName() : m_name( std::make_shared<std::string>( "<executable>" ) ) {}
6554: 
6555:         explicit ExeName( std::string &ref ) : ExeName() {
6556:             m_ref = std::make_shared<BoundValueRef<std::string>>( ref );
6557:         }
6558: 
6559:         template<typename LambdaT>
6560:         explicit ExeName( LambdaT const& lambda ) : ExeName() {
6561:             m_ref = std::make_shared<BoundLambda<LambdaT>>( lambda );
6562:         }
6563: 
6564:         // The exe name is not parsed out of the normal tokens, but is handled specially
6565:         auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {
6566:             return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
6567:         }
6568: 
6569:         auto name() const -> std::string { return *m_name; }
6570:         auto set( std::string const& newName ) -> ParserResult {
6571: 
6572:             auto lastSlash = newName.find_last_of( "\\/" );
6573:             auto filename = ( lastSlash == std::string::npos )
6574:                     ? newName
6575:                     : newName.substr( lastSlash+1 );
6576: 
6577:             *m_name = filename;
6578:             if( m_ref )
6579:                 return m_ref->setValue( filename );
6580:             else
6581:                 return ParserResult::ok( ParseResultType::Matched );
6582:         }
6583:     };
6584: 
6585:     class Arg : public ParserRefImpl<Arg> {
6586:     public:
6587:         using ParserRefImpl::ParserRefImpl;
6588: 
6589:         auto parse( std::string const &, TokenStream const &tokens ) const -> InternalParseResult override {
6590:             auto validationResult = validate();
6591:             if( !validationResult )
6592:                 return InternalParseResult( validationResult );
6593: 
6594:             auto remainingTokens = tokens;
6595:             auto const &token = *remainingTokens;
6596:             if( token.type != TokenType::Argument )
6597:                 return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
6598: 
6599:             assert( !m_ref->isFlag() );
6600:             auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );
6601: 
6602:             auto result = valueRef->setValue( remainingTokens->token );
6603:             if( !result )
6604:                 return InternalParseResult( result );
6605:             else
6606:                 return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
6607:         }
6608:     };
6609: 
6610:     inline auto normaliseOpt( std::string const &optName ) -> std::string {
6611: #ifdef CATCH_PLATFORM_WINDOWS
6612:         if( optName[0] == '/' )
6613:             return "-" + optName.substr( 1 );
6614:         else
6615: #endif
6616:             return optName;
6617:     }
6618: 
6619:     class Opt : public ParserRefImpl<Opt> {
6620:     protected:
6621:         std::vector<std::string> m_optNames;
6622: 
6623:     public:
6624:         template<typename LambdaT>
6625:         explicit Opt( LambdaT const &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) {}
6626: 
6627:         explicit Opt( bool &ref ) : ParserRefImpl( std::make_shared<BoundFlagRef>( ref ) ) {}
6628: 
6629:         template<typename LambdaT>
6630:         Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
6631: 
6632:         template<typename T>
6633:         Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
6634: 
6635:         auto operator[]( std::string const &optName ) -> Opt & {
6636:             m_optNames.push_back( optName );
6637:             return *this;
6638:         }
6639: 
6640:         auto getHelpColumns() const -> std::vector<HelpColumns> {
6641:             std::ostringstream oss;
6642:             bool first = true;
6643:             for( auto const &opt : m_optNames ) {
6644:                 if (first)
6645:                     first = false;
6646:                 else
6647:                     oss << ", ";
6648:                 oss << opt;
6649:             }
6650:             if( !m_hint.empty() )
6651:                 oss << " <" << m_hint << ">";
6652:             return { { oss.str(), m_description } };
6653:         }
6654: 
6655:         auto isMatch( std::string const &optToken ) const -> bool {
6656:             auto normalisedToken = normaliseOpt( optToken );
6657:             for( auto const &name : m_optNames ) {
6658:                 if( normaliseOpt( name ) == normalisedToken )
6659:                     return true;
6660:             }
6661:             return false;
6662:         }
6663: 
6664:         using ParserBase::parse;
6665: 
6666:         auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {
6667:             auto validationResult = validate();
6668:             if( !validationResult )
6669:                 return InternalParseResult( validationResult );
6670: 
6671:             auto remainingTokens = tokens;
6672:             if( remainingTokens && remainingTokens->type == TokenType::Option ) {
6673:                 auto const &token = *remainingTokens;
6674:                 if( isMatch(token.token ) ) {
6675:                     if( m_ref->isFlag() ) {
6676:                         auto flagRef = static_cast<detail::BoundFlagRefBase*>( m_ref.get() );
6677:                         auto result = flagRef->setFlag( true );
6678:                         if( !result )
6679:                             return InternalParseResult( result );
6680:                         if( result.value() == ParseResultType::ShortCircuitAll )
6681:                             return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
6682:                     } else {
6683:                         auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );
6684:                         ++remainingTokens;
6685:                         if( !remainingTokens )
6686:                             return InternalParseResult::runtimeError( "Expected argument following " + token.token );
6687:                         auto const &argToken = *remainingTokens;
6688:                         if( argToken.type != TokenType::Argument )
6689:                             return InternalParseResult::runtimeError( "Expected argument following " + token.token );
6690:                         auto result = valueRef->setValue( argToken.token );
6691:                         if( !result )
6692:                             return InternalParseResult( result );
6693:                         if( result.value() == ParseResultType::ShortCircuitAll )
6694:                             return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
6695:                     }
6696:                     return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
6697:                 }
6698:             }
6699:             return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
6700:         }
6701: 
6702:         auto validate() const -> Result override {
6703:             if( m_optNames.empty() )
6704:                 return Result::logicError( "No options supplied to Opt" );
6705:             for( auto const &name : m_optNames ) {
6706:                 if( name.empty() )
6707:                     return Result::logicError( "Option name cannot be empty" );
6708: #ifdef CATCH_PLATFORM_WINDOWS
6709:                 if( name[0] != '-' && name[0] != '/' )
6710:                     return Result::logicError( "Option name must begin with '-' or '/'" );
6711: #else
6712:                 if( name[0] != '-' )
6713:                     return Result::logicError( "Option name must begin with '-'" );
6714: #endif
6715:             }
6716:             return ParserRefImpl::validate();
6717:         }
6718:     };
6719: 
6720:     struct Help : Opt {
6721:         Help( bool &showHelpFlag )
6722:         :   Opt([&]( bool flag ) {
6723:                 showHelpFlag = flag;
6724:                 return ParserResult::ok( ParseResultType::ShortCircuitAll );
6725:             })
6726:         {
6727:             static_cast<Opt &>( *this )
6728:                     ("display usage information")
6729:                     ["-?"]["-h"]["--help"]
6730:                     .optional();
6731:         }
6732:     };
6733: 
6734:     struct Parser : ParserBase {
6735: 
6736:         mutable ExeName m_exeName;
6737:         std::vector<Opt> m_options;
6738:         std::vector<Arg> m_args;
6739: 
6740:         auto operator|=( ExeName const &exeName ) -> Parser & {
6741:             m_exeName = exeName;
6742:             return *this;
6743:         }
6744: 
6745:         auto operator|=( Arg const &arg ) -> Parser & {
6746:             m_args.push_back(arg);
6747:             return *this;
6748:         }
6749: 
6750:         auto operator|=( Opt const &opt ) -> Parser & {
6751:             m_options.push_back(opt);
6752:             return *this;
6753:         }
6754: 
6755:         auto operator|=( Parser const &other ) -> Parser & {
6756:             m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());
6757:             m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());
6758:             return *this;
6759:         }
6760: 
6761:         template<typename T>
6762:         auto operator|( T const &other ) const -> Parser {
6763:             return Parser( *this ) |= other;
6764:         }
6765: 
6766:         // Forward deprecated interface with '+' instead of '|'
6767:         template<typename T>
6768:         auto operator+=( T const &other ) -> Parser & { return operator|=( other ); }
6769:         template<typename T>
6770:         auto operator+( T const &other ) const -> Parser { return operator|( other ); }
6771: 
6772:         auto getHelpColumns() const -> std::vector<HelpColumns> {
6773:             std::vector<HelpColumns> cols;
6774:             for (auto const &o : m_options) {
6775:                 auto childCols = o.getHelpColumns();
6776:                 cols.insert( cols.end(), childCols.begin(), childCols.end() );
6777:             }
6778:             return cols;
6779:         }
6780: 
6781:         void writeToStream( std::ostream &os ) const {
6782:             if (!m_exeName.name().empty()) {
6783:                 os << "usage:\n" << "  " << m_exeName.name() << " ";
6784:                 bool required = true, first = true;
6785:                 for( auto const &arg : m_args ) {
6786:                     if (first)
6787:                         first = false;
6788:                     else
6789:                         os << " ";
6790:                     if( arg.isOptional() && required ) {
6791:                         os << "[";
6792:                         required = false;
6793:                     }
6794:                     os << "<" << arg.hint() << ">";
6795:                     if( arg.cardinality() == 0 )
6796:                         os << " ... ";
6797:                 }
6798:                 if( !required )
6799:                     os << "]";
6800:                 if( !m_options.empty() )
6801:                     os << " options";
6802:                 os << "\n\nwhere options are:" << std::endl;
6803:             }
6804: 
6805:             auto rows = getHelpColumns();
6806:             size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;
6807:             size_t optWidth = 0;
6808:             for( auto const &cols : rows )
6809:                 optWidth = (std::max)(optWidth, cols.left.size() + 2);
6810: 
6811:             optWidth = (std::min)(optWidth, consoleWidth/2);
6812: 
6813:             for( auto const &cols : rows ) {
6814:                 auto row =
6815:                         TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +
6816:                         TextFlow::Spacer(4) +
6817:                         TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );
6818:                 os << row << std::endl;
6819:             }
6820:         }
6821: 
6822:         friend auto operator<<( std::ostream &os, Parser const &parser ) -> std::ostream& {
6823:             parser.writeToStream( os );
6824:             return os;
6825:         }
6826: 
6827:         auto validate() const -> Result override {
6828:             for( auto const &opt : m_options ) {
6829:                 auto result = opt.validate();
6830:                 if( !result )
6831:                     return result;
6832:             }
6833:             for( auto const &arg : m_args ) {
6834:                 auto result = arg.validate();
6835:                 if( !result )
6836:                     return result;
6837:             }
6838:             return Result::ok();
6839:         }
6840: 
6841:         using ParserBase::parse;
6842: 
6843:         auto parse( std::string const& exeName, TokenStream const &tokens ) const -> InternalParseResult override {
6844: 
6845:             struct ParserInfo {
6846:                 ParserBase const* parser = nullptr;
6847:                 size_t count = 0;
6848:             };
6849:             const size_t totalParsers = m_options.size() + m_args.size();
6850:             assert( totalParsers < 512 );
6851:             // ParserInfo parseInfos[totalParsers]; // <-- this is what we really want to do
6852:             ParserInfo parseInfos[512];
6853: 
6854:             {
6855:                 size_t i = 0;
6856:                 for (auto const &opt : m_options) parseInfos[i++].parser = &opt;
6857:                 for (auto const &arg : m_args) parseInfos[i++].parser = &arg;
6858:             }
6859: 
6860:             m_exeName.set( exeName );
6861: 
6862:             auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
6863:             while( result.value().remainingTokens() ) {
6864:                 bool tokenParsed = false;
6865: 
6866:                 for( size_t i = 0; i < totalParsers; ++i ) {
6867:                     auto&  parseInfo = parseInfos[i];
6868:                     if( parseInfo.parser->cardinality() == 0 || parseInfo.count < parseInfo.parser->cardinality() ) {
6869:                         result = parseInfo.parser->parse(exeName, result.value().remainingTokens());
6870:                         if (!result)
6871:                             return result;
6872:                         if (result.value().type() != ParseResultType::NoMatch) {
6873:                             tokenParsed = true;
6874:                             ++parseInfo.count;
6875:                             break;
6876:                         }
6877:                     }
6878:                 }
6879: 
6880:                 if( result.value().type() == ParseResultType::ShortCircuitAll )
6881:                     return result;
6882:                 if( !tokenParsed )
6883:                     return InternalParseResult::runtimeError( "Unrecognised token: " + result.value().remainingTokens()->token );
6884:             }
6885:             // !TBD Check missing required options
6886:             return result;
6887:         }
6888:     };
6889: 
6890:     template<typename DerivedT>
6891:     template<typename T>
6892:     auto ComposableParserImpl<DerivedT>::operator|( T const &other ) const -> Parser {
6893:         return Parser() | static_cast<DerivedT const &>( *this ) | other;
6894:     }
6895: } // namespace detail
6896: 
6897: // A Combined parser
6898: using detail::Parser;
6899: 
6900: // A parser for options
6901: using detail::Opt;
6902: 
6903: // A parser for arguments
6904: using detail::Arg;
6905: 
6906: // Wrapper for argc, argv from main()
6907: using detail::Args;
6908: 
6909: // Specifies the name of the executable
6910: using detail::ExeName;
6911: 
6912: // Convenience wrapper for option parser that specifies the help option
6913: using detail::Help;
6914: 
6915: // enum of result types from a parse
6916: using detail::ParseResultType;
6917: 
6918: // Result type for parser operation
6919: using detail::ParserResult;
6920: 
6921: }} // namespace Catch::clara
6922: 
6923: // end clara.hpp
6924: #ifdef __clang__
6925: #pragma clang diagnostic pop
6926: #endif
6927: 
6928: // Restore Clara's value for console width, if present
6929: #ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
6930: #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
6931: #undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
6932: #endif
6933: 
6934: // end catch_clara.h
6935: namespace Catch {
6936: 
6937:     clara::Parser makeCommandLineParser( ConfigData& config );
6938: 
6939: } // end namespace Catch
6940: 
6941: // end catch_commandline.h
6942: #include <fstream>
6943: #include <ctime>
6944: 
6945: namespace Catch {
6946: 
6947:     clara::Parser makeCommandLineParser( ConfigData& config ) {
6948: 
6949:         using namespace clara;
6950: 
6951:         auto const setWarning = [&]( std::string const& warning ) {
6952:                 auto warningSet = [&]() {
6953:                     if( warning == "NoAssertions" )
6954:                         return WarnAbout::NoAssertions;
6955: 
6956:                     if ( warning == "NoTests" )
6957:                         return WarnAbout::NoTests;
6958: 
6959:                     return WarnAbout::Nothing;
6960:                 }();
6961: 
6962:                 if (warningSet == WarnAbout::Nothing)
6963:                     return ParserResult::runtimeError( "Unrecognised warning: '" + warning + "'" );
6964:                 config.warnings = static_cast<WarnAbout::What>( config.warnings | warningSet );
6965:                 return ParserResult::ok( ParseResultType::Matched );
6966:             };
6967:         auto const loadTestNamesFromFile = [&]( std::string const& filename ) {
6968:                 std::ifstream f( filename.c_str() );
6969:                 if( !f.is_open() )
6970:                     return ParserResult::runtimeError( "Unable to load input file: '" + filename + "'" );
6971: 
6972:                 std::string line;
6973:                 while( std::getline( f, line ) ) {
6974:                     line = trim(line);
6975:                     if( !line.empty() && !startsWith( line, '#' ) ) {
6976:                         if( !startsWith( line, '"' ) )
6977:                             line = '"' + line + '"';
6978:                         config.testsOrTags.push_back( line + ',' );
6979:                     }
6980:                 }
6981:                 return ParserResult::ok( ParseResultType::Matched );
6982:             };
6983:         auto const setTestOrder = [&]( std::string const& order ) {
6984:                 if( startsWith( "declared", order ) )
6985:                     config.runOrder = RunTests::InDeclarationOrder;
6986:                 else if( startsWith( "lexical", order ) )
6987:                     config.runOrder = RunTests::InLexicographicalOrder;
6988:                 else if( startsWith( "random", order ) )
6989:                     config.runOrder = RunTests::InRandomOrder;
6990:                 else
6991:                     return clara::ParserResult::runtimeError( "Unrecognised ordering: '" + order + "'" );
6992:                 return ParserResult::ok( ParseResultType::Matched );
6993:             };
6994:         auto const setRngSeed = [&]( std::string const& seed ) {
6995:                 if( seed != "time" )
6996:                     return clara::detail::convertInto( seed, config.rngSeed );
6997:                 config.rngSeed = static_cast<unsigned int>( std::time(nullptr) );
6998:                 return ParserResult::ok( ParseResultType::Matched );
6999:             };
7000:         auto const setColourUsage = [&]( std::string const& useColour ) {
7001:                     auto mode = toLower( useColour );
7002: 
7003:                     if( mode == "yes" )
7004:                         config.useColour = UseColour::Yes;
7005:                     else if( mode == "no" )
7006:                         config.useColour = UseColour::No;
7007:                     else if( mode == "auto" )
7008:                         config.useColour = UseColour::Auto;
7009:                     else
7010:                         return ParserResult::runtimeError( "colour mode must be one of: auto, yes or no. '" + useColour + "' not recognised" );
7011:                 return ParserResult::ok( ParseResultType::Matched );
7012:             };
7013:         auto const setWaitForKeypress = [&]( std::string const& keypress ) {
7014:                 auto keypressLc = toLower( keypress );
7015:                 if( keypressLc == "start" )
7016:                     config.waitForKeypress = WaitForKeypress::BeforeStart;
7017:                 else if( keypressLc == "exit" )
7018:                     config.waitForKeypress = WaitForKeypress::BeforeExit;
7019:                 else if( keypressLc == "both" )
7020:                     config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;
7021:                 else
7022:                     return ParserResult::runtimeError( "keypress argument must be one of: start, exit or both. '" + keypress + "' not recognised" );
7023:             return ParserResult::ok( ParseResultType::Matched );
7024:             };
7025:         auto const setVerbosity = [&]( std::string const& verbosity ) {
7026:             auto lcVerbosity = toLower( verbosity );
7027:             if( lcVerbosity == "quiet" )
7028:                 config.verbosity = Verbosity::Quiet;
7029:             else if( lcVerbosity == "normal" )
7030:                 config.verbosity = Verbosity::Normal;
7031:             else if( lcVerbosity == "high" )
7032:                 config.verbosity = Verbosity::High;
7033:             else
7034:                 return ParserResult::runtimeError( "Unrecognised verbosity, '" + verbosity + "'" );
7035:             return ParserResult::ok( ParseResultType::Matched );
7036:         };
7037: 
7038:         auto cli
7039:             = ExeName( config.processName )
7040:             | Help( config.showHelp )
7041:             | Opt( config.listTests )
7042:                 ["-l"]["--list-tests"]
7043:                 ( "list all/matching test cases" )
7044:             | Opt( config.listTags )
7045:                 ["-t"]["--list-tags"]
7046:                 ( "list all/matching tags" )
7047:             | Opt( config.showSuccessfulTests )
7048:                 ["-s"]["--success"]
7049:                 ( "include successful tests in output" )
7050:             | Opt( config.shouldDebugBreak )
7051:                 ["-b"]["--break"]
7052:                 ( "break into debugger on failure" )
7053:             | Opt( config.noThrow )
7054:                 ["-e"]["--nothrow"]
7055:                 ( "skip exception tests" )
7056:             | Opt( config.showInvisibles )
7057:                 ["-i"]["--invisibles"]
7058:                 ( "show invisibles (tabs, newlines)" )
7059:             | Opt( config.outputFilename, "filename" )
7060:                 ["-o"]["--out"]
7061:                 ( "output filename" )
7062:             | Opt( config.reporterName, "name" )
7063:                 ["-r"]["--reporter"]
7064:                 ( "reporter to use (defaults to console)" )
7065:             | Opt( config.name, "name" )
7066:                 ["-n"]["--name"]
7067:                 ( "suite name" )
7068:             | Opt( [&]( bool ){ config.abortAfter = 1; } )
7069:                 ["-a"]["--abort"]
7070:                 ( "abort at first failure" )
7071:             | Opt( [&]( int x ){ config.abortAfter = x; }, "no. failures" )
7072:                 ["-x"]["--abortx"]
7073:                 ( "abort after x failures" )
7074:             | Opt( setWarning, "warning name" )
7075:                 ["-w"]["--warn"]
7076:                 ( "enable warnings" )
7077:             | Opt( [&]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, "yes|no" )
7078:                 ["-d"]["--durations"]
7079:                 ( "show test durations" )
7080:             | Opt( loadTestNamesFromFile, "filename" )
7081:                 ["-f"]["--input-file"]
7082:                 ( "load test names to run from a file" )
7083:             | Opt( config.filenamesAsTags )
7084:                 ["-#"]["--filenames-as-tags"]
7085:                 ( "adds a tag for the filename" )
7086:             | Opt( config.sectionsToRun, "section name" )
7087:                 ["-c"]["--section"]
7088:                 ( "specify section to run" )
7089:             | Opt( setVerbosity, "quiet|normal|high" )
7090:                 ["-v"]["--verbosity"]
7091:                 ( "set output verbosity" )
7092:             | Opt( config.listTestNamesOnly )
7093:                 ["--list-test-names-only"]
7094:                 ( "list all/matching test cases names only" )
7095:             | Opt( config.listReporters )
7096:                 ["--list-reporters"]
7097:                 ( "list all reporters" )
7098:             | Opt( setTestOrder, "decl|lex|rand" )
7099:                 ["--order"]
7100:                 ( "test case order (defaults to decl)" )
7101:             | Opt( setRngSeed, "'time'|number" )
7102:                 ["--rng-seed"]
7103:                 ( "set a specific seed for random numbers" )
7104:             | Opt( setColourUsage, "yes|no" )
7105:                 ["--use-colour"]
7106:                 ( "should output be colourised" )
7107:             | Opt( config.libIdentify )
7108:                 ["--libidentify"]
7109:                 ( "report name and version according to libidentify standard" )
7110:             | Opt( setWaitForKeypress, "start|exit|both" )
7111:                 ["--wait-for-keypress"]
7112:                 ( "waits for a keypress before exiting" )
7113:             | Opt( config.benchmarkResolutionMultiple, "multiplier" )
7114:                 ["--benchmark-resolution-multiple"]
7115:                 ( "multiple of clock resolution to run benchmarks" )
7116: 
7117:             | Arg( config.testsOrTags, "test name|pattern|tags" )
7118:                 ( "which test or tests to use" );
7119: 
7120:         return cli;
7121:     }
7122: 
7123: } // end namespace Catch
7124: // end catch_commandline.cpp
7125: // start catch_common.cpp
7126: 
7127: #include <cstring>
7128: #include <ostream>
7129: 
7130: namespace Catch {
7131: 
7132:     bool SourceLineInfo::empty() const noexcept {
7133:         return file[0] == '\0';
7134:     }
7135:     bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const noexcept {
7136:         return line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);
7137:     }
7138:     bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const noexcept {
7139:         // We can assume that the same file will usually have the same pointer.
7140:         // Thus, if the pointers are the same, there is no point in calling the strcmp
7141:         return line < other.line || ( line == other.line && file != other.file && (std::strcmp(file, other.file) < 0));
7142:     }
7143: 
7144:     std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {
7145: #ifndef __GNUG__
7146:         os << info.file << '(' << info.line << ')';
7147: #else
7148:         os << info.file << ':' << info.line;
7149: #endif
7150:         return os;
7151:     }
7152: 
7153:     std::string StreamEndStop::operator+() const {
7154:         return std::string();
7155:     }
7156: 
7157:     NonCopyable::NonCopyable() = default;
7158:     NonCopyable::~NonCopyable() = default;
7159: 
7160: }
7161: // end catch_common.cpp
7162: // start catch_config.cpp
7163: 
7164: namespace Catch {
7165: 
7166:     Config::Config( ConfigData const& data )
7167:     :   m_data( data ),
7168:         m_stream( openStream() )
7169:     {
7170:         TestSpecParser parser(ITagAliasRegistry::get());
7171:         if (data.testsOrTags.empty()) {
7172:             parser.parse("~[.]"); // All not hidden tests
7173:         }
7174:         else {
7175:             m_hasTestFilters = true;
7176:             for( auto const& testOrTags : data.testsOrTags )
7177:                 parser.parse( testOrTags );
7178:         }
7179:         m_testSpec = parser.testSpec();
7180:     }
7181: 
7182:     std::string const& Config::getFilename() const {
7183:         return m_data.outputFilename ;
7184:     }
7185: 
7186:     bool Config::listTests() const          { return m_data.listTests; }
7187:     bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }
7188:     bool Config::listTags() const           { return m_data.listTags; }
7189:     bool Config::listReporters() const      { return m_data.listReporters; }
7190: 
7191:     std::string Config::getProcessName() const { return m_data.processName; }
7192:     std::string const& Config::getReporterName() const { return m_data.reporterName; }
7193: 
7194:     std::vector<std::string> const& Config::getTestsOrTags() const { return m_data.testsOrTags; }
7195:     std::vector<std::string> const& Config::getSectionsToRun() const { return m_data.sectionsToRun; }
7196: 
7197:     TestSpec const& Config::testSpec() const { return m_testSpec; }
7198:     bool Config::hasTestFilters() const { return m_hasTestFilters; }
7199: 
7200:     bool Config::showHelp() const { return m_data.showHelp; }
7201: 
7202:     // IConfig interface
7203:     bool Config::allowThrows() const                   { return !m_data.noThrow; }
7204:     std::ostream& Config::stream() const               { return m_stream->stream(); }
7205:     std::string Config::name() const                   { return m_data.name.empty() ? m_data.processName : m_data.name; }
7206:     bool Config::includeSuccessfulResults() const      { return m_data.showSuccessfulTests; }
7207:     bool Config::warnAboutMissingAssertions() const    { return !!(m_data.warnings & WarnAbout::NoAssertions); }
7208:     bool Config::warnAboutNoTests() const              { return !!(m_data.warnings & WarnAbout::NoTests); }
7209:     ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }
7210:     RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }
7211:     unsigned int Config::rngSeed() const               { return m_data.rngSeed; }
7212:     int Config::benchmarkResolutionMultiple() const    { return m_data.benchmarkResolutionMultiple; }
7213:     UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }
7214:     bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }
7215:     int Config::abortAfter() const                     { return m_data.abortAfter; }
7216:     bool Config::showInvisibles() const                { return m_data.showInvisibles; }
7217:     Verbosity Config::verbosity() const                { return m_data.verbosity; }
7218: 
7219:     IStream const* Config::openStream() {
7220:         return Catch::makeStream(m_data.outputFilename);
7221:     }
7222: 
7223: } // end namespace Catch
7224: // end catch_config.cpp
7225: // start catch_console_colour.cpp
7226: 
7227: #if defined(__clang__)
7228: #    pragma clang diagnostic push
7229: #    pragma clang diagnostic ignored "-Wexit-time-destructors"
7230: #endif
7231: 
7232: // start catch_errno_guard.h
7233: 
7234: namespace Catch {
7235: 
7236:     class ErrnoGuard {
7237:     public:
7238:         ErrnoGuard();
7239:         ~ErrnoGuard();
7240:     private:
7241:         int m_oldErrno;
7242:     };
7243: 
7244: }
7245: 
7246: // end catch_errno_guard.h
7247: #include <sstream>
7248: 
7249: namespace Catch {
7250:     namespace {
7251: 
7252:         struct IColourImpl {
7253:             virtual ~IColourImpl() = default;
7254:             virtual void use( Colour::Code _colourCode ) = 0;
7255:         };
7256: 
7257:         struct NoColourImpl : IColourImpl {
7258:             void use( Colour::Code ) {}
7259: 
7260:             static IColourImpl* instance() {
7261:                 static NoColourImpl s_instance;
7262:                 return &s_instance;
7263:             }
7264:         };
7265: 
7266:     } // anon namespace
7267: } // namespace Catch
7268: 
7269: #if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )
7270: #   ifdef CATCH_PLATFORM_WINDOWS
7271: #       define CATCH_CONFIG_COLOUR_WINDOWS
7272: #   else
7273: #       define CATCH_CONFIG_COLOUR_ANSI
7274: #   endif
7275: #endif
7276: 
7277: #if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) /////////////////////////////////////////
7278: 
7279: namespace Catch {
7280: namespace {
7281: 
7282:     class Win32ColourImpl : public IColourImpl {
7283:     public:
7284:         Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
7285:         {
7286:             CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
7287:             GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );
7288:             originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );
7289:             originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );
7290:         }
7291: 
7292:         virtual void use( Colour::Code _colourCode ) override {
7293:             switch( _colourCode ) {
7294:                 case Colour::None:      return setTextAttribute( originalForegroundAttributes );
7295:                 case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
7296:                 case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
7297:                 case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
7298:                 case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
7299:                 case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
7300:                 case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
7301:                 case Colour::Grey:      return setTextAttribute( 0 );
7302: 
7303:                 case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
7304:                 case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
7305:                 case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
7306:                 case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
7307:                 case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );
7308: 
7309:                 case Colour::Bright: CATCH_INTERNAL_ERROR( "not a colour" );
7310: 
7311:                 default:
7312:                     CATCH_ERROR( "Unknown colour requested" );
7313:             }
7314:         }
7315: 
7316:     private:
7317:         void setTextAttribute( WORD _textAttribute ) {
7318:             SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );
7319:         }
7320:         HANDLE stdoutHandle;
7321:         WORD originalForegroundAttributes;
7322:         WORD originalBackgroundAttributes;
7323:     };
7324: 
7325:     IColourImpl* platformColourInstance() {
7326:         static Win32ColourImpl s_instance;
7327: 
7328:         IConfigPtr config = getCurrentContext().getConfig();
7329:         UseColour::YesOrNo colourMode = config
7330:             ? config->useColour()
7331:             : UseColour::Auto;
7332:         if( colourMode == UseColour::Auto )
7333:             colourMode = UseColour::Yes;
7334:         return colourMode == UseColour::Yes
7335:             ? &s_instance
7336:             : NoColourImpl::instance();
7337:     }
7338: 
7339: } // end anon namespace
7340: } // end namespace Catch
7341: 
7342: #elif defined( CATCH_CONFIG_COLOUR_ANSI ) //////////////////////////////////////
7343: 
7344: #include <unistd.h>
7345: 
7346: namespace Catch {
7347: namespace {
7348: 
7349:     // use POSIX/ ANSI console terminal codes
7350:     // Thanks to Adam Strzelecki for original contribution
7351:     // (http://github.com/nanoant)
7352:     // https://github.com/philsquared/Catch/pull/131
7353:     class PosixColourImpl : public IColourImpl {
7354:     public:
7355:         virtual void use( Colour::Code _colourCode ) override {
7356:             switch( _colourCode ) {
7357:                 case Colour::None:
7358:                 case Colour::White:     return setColour( "[0m" );
7359:                 case Colour::Red:       return setColour( "[0;31m" );
7360:                 case Colour::Green:     return setColour( "[0;32m" );
7361:                 case Colour::Blue:      return setColour( "[0;34m" );
7362:                 case Colour::Cyan:      return setColour( "[0;36m" );
7363:                 case Colour::Yellow:    return setColour( "[0;33m" );
7364:                 case Colour::Grey:      return setColour( "[1;30m" );
7365: 
7366:                 case Colour::LightGrey:     return setColour( "[0;37m" );
7367:                 case Colour::BrightRed:     return setColour( "[1;31m" );
7368:                 case Colour::BrightGreen:   return setColour( "[1;32m" );
7369:                 case Colour::BrightWhite:   return setColour( "[1;37m" );
7370:                 case Colour::BrightYellow:  return setColour( "[1;33m" );
7371: 
7372:                 case Colour::Bright: CATCH_INTERNAL_ERROR( "not a colour" );
7373:                 default: CATCH_INTERNAL_ERROR( "Unknown colour requested" );
7374:             }
7375:         }
7376:         static IColourImpl* instance() {
7377:             static PosixColourImpl s_instance;
7378:             return &s_instance;
7379:         }
7380: 
7381:     private:
7382:         void setColour( const char* _escapeCode ) {
7383:             Catch::cout() << '\033' << _escapeCode;
7384:         }
7385:     };
7386: 
7387:     bool useColourOnPlatform() {
7388:         return
7389: #ifdef CATCH_PLATFORM_MAC
7390:             !isDebuggerActive() &&
7391: #endif
7392: #if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))
7393:             isatty(STDOUT_FILENO)
7394: #else
7395:             false
7396: #endif
7397:             ;
7398:     }
7399:     IColourImpl* platformColourInstance() {
7400:         ErrnoGuard guard;
7401:         IConfigPtr config = getCurrentContext().getConfig();
7402:         UseColour::YesOrNo colourMode = config
7403:             ? config->useColour()
7404:             : UseColour::Auto;
7405:         if( colourMode == UseColour::Auto )
7406:             colourMode = useColourOnPlatform()
7407:                 ? UseColour::Yes
7408:                 : UseColour::No;
7409:         return colourMode == UseColour::Yes
7410:             ? PosixColourImpl::instance()
7411:             : NoColourImpl::instance();
7412:     }
7413: 
7414: } // end anon namespace
7415: } // end namespace Catch
7416: 
7417: #else  // not Windows or ANSI ///////////////////////////////////////////////
7418: 
7419: namespace Catch {
7420: 
7421:     static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }
7422: 
7423: } // end namespace Catch
7424: 
7425: #endif // Windows/ ANSI/ None
7426: 
7427: namespace Catch {
7428: 
7429:     Colour::Colour( Code _colourCode ) { use( _colourCode ); }
7430:     Colour::Colour( Colour&& rhs ) noexcept {
7431:         m_moved = rhs.m_moved;
7432:         rhs.m_moved = true;
7433:     }
7434:     Colour& Colour::operator=( Colour&& rhs ) noexcept {
7435:         m_moved = rhs.m_moved;
7436:         rhs.m_moved  = true;
7437:         return *this;
7438:     }
7439: 
7440:     Colour::~Colour(){ if( !m_moved ) use( None ); }
7441: 
7442:     void Colour::use( Code _colourCode ) {
7443:         static IColourImpl* impl = platformColourInstance();
7444:         impl->use( _colourCode );
7445:     }
7446: 
7447:     std::ostream& operator << ( std::ostream& os, Colour const& ) {
7448:         return os;
7449:     }
7450: 
7451: } // end namespace Catch
7452: 
7453: #if defined(__clang__)
7454: #    pragma clang diagnostic pop
7455: #endif
7456: 
7457: // end catch_console_colour.cpp
7458: // start catch_context.cpp
7459: 
7460: namespace Catch {
7461: 
7462:     class Context : public IMutableContext, NonCopyable {
7463: 
7464:     public: // IContext
7465:         virtual IResultCapture* getResultCapture() override {
7466:             return m_resultCapture;
7467:         }
7468:         virtual IRunner* getRunner() override {
7469:             return m_runner;
7470:         }
7471: 
7472:         virtual IConfigPtr const& getConfig() const override {
7473:             return m_config;
7474:         }
7475: 
7476:         virtual ~Context() override;
7477: 
7478:     public: // IMutableContext
7479:         virtual void setResultCapture( IResultCapture* resultCapture ) override {
7480:             m_resultCapture = resultCapture;
7481:         }
7482:         virtual void setRunner( IRunner* runner ) override {
7483:             m_runner = runner;
7484:         }
7485:         virtual void setConfig( IConfigPtr const& config ) override {
7486:             m_config = config;
7487:         }
7488: 
7489:         friend IMutableContext& getCurrentMutableContext();
7490: 
7491:     private:
7492:         IConfigPtr m_config;
7493:         IRunner* m_runner = nullptr;
7494:         IResultCapture* m_resultCapture = nullptr;
7495:     };
7496: 
7497:     IMutableContext *IMutableContext::currentContext = nullptr;
7498: 
7499:     void IMutableContext::createContext()
7500:     {
7501:         currentContext = new Context();
7502:     }
7503: 
7504:     void cleanUpContext() {
7505:         delete IMutableContext::currentContext;
7506:         IMutableContext::currentContext = nullptr;
7507:     }
7508:     IContext::~IContext() = default;
7509:     IMutableContext::~IMutableContext() = default;
7510:     Context::~Context() = default;
7511: }
7512: // end catch_context.cpp
7513: // start catch_debug_console.cpp
7514: 
7515: // start catch_debug_console.h
7516: 
7517: #include <string>
7518: 
7519: namespace Catch {
7520:     void writeToDebugConsole( std::string const& text );
7521: }
7522: 
7523: // end catch_debug_console.h
7524: #ifdef CATCH_PLATFORM_WINDOWS
7525: 
7526:     namespace Catch {
7527:         void writeToDebugConsole( std::string const& text ) {
7528:             ::OutputDebugStringA( text.c_str() );
7529:         }
7530:     }
7531: 
7532: #else
7533: 
7534:     namespace Catch {
7535:         void writeToDebugConsole( std::string const& text ) {
7536:             // !TBD: Need a version for Mac/ XCode and other IDEs
7537:             Catch::cout() << text;
7538:         }
7539:     }
7540: 
7541: #endif // Platform
7542: // end catch_debug_console.cpp
7543: // start catch_debugger.cpp
7544: 
7545: #ifdef CATCH_PLATFORM_MAC
7546: 
7547: #  include <assert.h>
7548: #  include <stdbool.h>
7549: #  include <sys/types.h>
7550: #  include <unistd.h>
7551: #  include <sys/sysctl.h>
7552: #  include <cstddef>
7553: #  include <ostream>
7554: 
7555: namespace Catch {
7556: 
7557:         // The following function is taken directly from the following technical note:
7558:         // http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html
7559: 
7560:         // Returns true if the current process is being debugged (either
7561:         // running under the debugger or has a debugger attached post facto).
7562:         bool isDebuggerActive(){
7563: 
7564:             int                 mib[4];
7565:             struct kinfo_proc   info;
7566:             std::size_t         size;
7567: 
7568:             // Initialize the flags so that, if sysctl fails for some bizarre
7569:             // reason, we get a predictable result.
7570: 
7571:             info.kp_proc.p_flag = 0;
7572: 
7573:             // Initialize mib, which tells sysctl the info we want, in this case
7574:             // we're looking for information about a specific process ID.
7575: 
7576:             mib[0] = CTL_KERN;
7577:             mib[1] = KERN_PROC;
7578:             mib[2] = KERN_PROC_PID;
7579:             mib[3] = getpid();
7580: 
7581:             // Call sysctl.
7582: 
7583:             size = sizeof(info);
7584:             if( sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, nullptr, 0) != 0 ) {
7585:                 Catch::cerr() << "\n** Call to sysctl failed - unable to determine if debugger is active **\n" << std::endl;
7586:                 return false;
7587:             }
7588: 
7589:             // We're being debugged if the P_TRACED flag is set.
7590: 
7591:             return ( (info.kp_proc.p_flag & P_TRACED) != 0 );
7592:         }
7593:     } // namespace Catch
7594: 
7595: #elif defined(CATCH_PLATFORM_LINUX)
7596:     #include <fstream>
7597:     #include <string>
7598: 
7599:     namespace Catch{
7600:         // The standard POSIX way of detecting a debugger is to attempt to
7601:         // ptrace() the process, but this needs to be done from a child and not
7602:         // this process itself to still allow attaching to this process later
7603:         // if wanted, so is rather heavy. Under Linux we have the PID of the
7604:         // "debugger" (which doesn't need to be gdb, of course, it could also
7605:         // be strace, for example) in /proc/$PID/status, so just get it from
7606:         // there instead.
7607:         bool isDebuggerActive(){
7608:             // Libstdc++ has a bug, where std::ifstream sets errno to 0
7609:             // This way our users can properly assert over errno values
7610:             ErrnoGuard guard;
7611:             std::ifstream in("/proc/self/status");
7612:             for( std::string line; std::getline(in, line); ) {
7613:                 static const int PREFIX_LEN = 11;
7614:                 if( line.compare(0, PREFIX_LEN, "TracerPid:\t") == 0 ) {
7615:                     // We're traced if the PID is not 0 and no other PID starts
7616:                     // with 0 digit, so it's enough to check for just a single
7617:                     // character.
7618:                     return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';
7619:                 }
7620:             }
7621: 
7622:             return false;
7623:         }
7624:     } // namespace Catch
7625: #elif defined(_MSC_VER)
7626:     extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
7627:     namespace Catch {
7628:         bool isDebuggerActive() {
7629:             return IsDebuggerPresent() != 0;
7630:         }
7631:     }
7632: #elif defined(__MINGW32__)
7633:     extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
7634:     namespace Catch {
7635:         bool isDebuggerActive() {
7636:             return IsDebuggerPresent() != 0;
7637:         }
7638:     }
7639: #else
7640:     namespace Catch {
7641:        bool isDebuggerActive() { return false; }
7642:     }
7643: #endif // Platform
7644: // end catch_debugger.cpp
7645: // start catch_decomposer.cpp
7646: 
7647: namespace Catch {
7648: 
7649:     ITransientExpression::~ITransientExpression() = default;
7650: 
7651:     void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs ) {
7652:         if( lhs.size() + rhs.size() < 40 &&
7653:                 lhs.find('\n') == std::string::npos &&
7654:                 rhs.find('\n') == std::string::npos )
7655:             os << lhs << " " << op << " " << rhs;
7656:         else
7657:             os << lhs << "\n" << op << "\n" << rhs;
7658:     }
7659: }
7660: // end catch_decomposer.cpp
7661: // start catch_enforce.cpp
7662: 
7663: namespace Catch {
7664: #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS) && !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER)
7665:     [[noreturn]]
7666:     void throw_exception(std::exception const& e) {
7667:         Catch::cerr() << "Catch will terminate because it needed to throw an exception.\n"
7668:                       << "The message was: " << e.what() << '\n';
7669:         std::terminate();
7670:     }
7671: #endif
7672: } // namespace Catch;
7673: // end catch_enforce.cpp
7674: // start catch_errno_guard.cpp
7675: 
7676: #include <cerrno>
7677: 
7678: namespace Catch {
7679:         ErrnoGuard::ErrnoGuard():m_oldErrno(errno){}
7680:         ErrnoGuard::~ErrnoGuard() { errno = m_oldErrno; }
7681: }
7682: // end catch_errno_guard.cpp
7683: // start catch_exception_translator_registry.cpp
7684: 
7685: // start catch_exception_translator_registry.h
7686: 
7687: #include <vector>
7688: #include <string>
7689: #include <memory>
7690: 
7691: namespace Catch {
7692: 
7693:     class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
7694:     public:
7695:         ~ExceptionTranslatorRegistry();
7696:         virtual void registerTranslator( const IExceptionTranslator* translator );
7697:         virtual std::string translateActiveException() const override;
7698:         std::string tryTranslators() const;
7699: 
7700:     private:
7701:         std::vector<std::unique_ptr<IExceptionTranslator const>> m_translators;
7702:     };
7703: }
7704: 
7705: // end catch_exception_translator_registry.h
7706: #ifdef __OBJC__
7707: #import "Foundation/Foundation.h"
7708: #endif
7709: 
7710: namespace Catch {
7711: 
7712:     ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {
7713:     }
7714: 
7715:     void ExceptionTranslatorRegistry::registerTranslator( const IExceptionTranslator* translator ) {
7716:         m_translators.push_back( std::unique_ptr<const IExceptionTranslator>( translator ) );
7717:     }
7718: 
7719: #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
7720:     std::string ExceptionTranslatorRegistry::translateActiveException() const {
7721:         try {
7722: #ifdef __OBJC__
7723:             // In Objective-C try objective-c exceptions first
7724:             @try {
7725:                 return tryTranslators();
7726:             }
7727:             @catch (NSException *exception) {
7728:                 return Catch::Detail::stringify( [exception description] );
7729:             }
7730: #else
7731:             // Compiling a mixed mode project with MSVC means that CLR
7732:             // exceptions will be caught in (...) as well. However, these
7733:             // do not fill-in std::current_exception and thus lead to crash
7734:             // when attempting rethrow.
7735:             // /EHa switch also causes structured exceptions to be caught
7736:             // here, but they fill-in current_exception properly, so
7737:             // at worst the output should be a little weird, instead of
7738:             // causing a crash.
7739:             if (std::current_exception() == nullptr) {
7740:                 return "Non C++ exception. Possibly a CLR exception.";
7741:             }
7742:             return tryTranslators();
7743: #endif
7744:         }
7745:         catch( TestFailureException& ) {
7746:             std::rethrow_exception(std::current_exception());
7747:         }
7748:         catch( std::exception& ex ) {
7749:             return ex.what();
7750:         }
7751:         catch( std::string& msg ) {
7752:             return msg;
7753:         }
7754:         catch( const char* msg ) {
7755:             return msg;
7756:         }
7757:         catch(...) {
7758:             return "Unknown exception";
7759:         }
7760:     }
7761: 
7762: #else // ^^ Exceptions are enabled // Exceptions are disabled vv
7763:     std::string ExceptionTranslatorRegistry::translateActiveException() const {
7764:         CATCH_INTERNAL_ERROR("Attempted to translate active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!");
7765:     }
7766: #endif
7767: 
7768:     std::string ExceptionTranslatorRegistry::tryTranslators() const {
7769:         if( m_translators.empty() )
7770:             std::rethrow_exception(std::current_exception());
7771:         else
7772:             return m_translators[0]->translate( m_translators.begin()+1, m_translators.end() );
7773:     }
7774: }
7775: // end catch_exception_translator_registry.cpp
7776: // start catch_fatal_condition.cpp
7777: 
7778: #if defined(__GNUC__)
7779: #    pragma GCC diagnostic push
7780: #    pragma GCC diagnostic ignored "-Wmissing-field-initializers"
7781: #endif
7782: 
7783: #if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )
7784: 
7785: namespace {
7786:     // Report the error condition
7787:     void reportFatal( char const * const message ) {
7788:         Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );
7789:     }
7790: }
7791: 
7792: #endif // signals/SEH handling
7793: 
7794: #if defined( CATCH_CONFIG_WINDOWS_SEH )
7795: 
7796: namespace Catch {
7797:     struct SignalDefs { DWORD id; const char* name; };
7798: 
7799:     // There is no 1-1 mapping between signals and windows exceptions.
7800:     // Windows can easily distinguish between SO and SigSegV,
7801:     // but SigInt, SigTerm, etc are handled differently.
7802:     static SignalDefs signalDefs[] = {
7803:         { EXCEPTION_ILLEGAL_INSTRUCTION,  "SIGILL - Illegal instruction signal" },
7804:         { EXCEPTION_STACK_OVERFLOW, "SIGSEGV - Stack overflow" },
7805:         { EXCEPTION_ACCESS_VIOLATION, "SIGSEGV - Segmentation violation signal" },
7806:         { EXCEPTION_INT_DIVIDE_BY_ZERO, "Divide by zero error" },
7807:     };
7808: 
7809:     LONG CALLBACK FatalConditionHandler::handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
7810:         for (auto const& def : signalDefs) {
7811:             if (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) {
7812:                 reportFatal(def.name);
7813:             }
7814:         }
7815:         // If its not an exception we care about, pass it along.
7816:         // This stops us from eating debugger breaks etc.
7817:         return EXCEPTION_CONTINUE_SEARCH;
7818:     }
7819: 
7820:     FatalConditionHandler::FatalConditionHandler() {
7821:         isSet = true;
7822:         // 32k seems enough for Catch to handle stack overflow,
7823:         // but the value was found experimentally, so there is no strong guarantee
7824:         guaranteeSize = 32 * 1024;
7825:         exceptionHandlerHandle = nullptr;
7826:         // Register as first handler in current chain
7827:         exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);
7828:         // Pass in guarantee size to be filled
7829:         SetThreadStackGuarantee(&guaranteeSize);
7830:     }
7831: 
7832:     void FatalConditionHandler::reset() {
7833:         if (isSet) {
7834:             RemoveVectoredExceptionHandler(exceptionHandlerHandle);
7835:             SetThreadStackGuarantee(&guaranteeSize);
7836:             exceptionHandlerHandle = nullptr;
7837:             isSet = false;
7838:         }
7839:     }
7840: 
7841:     FatalConditionHandler::~FatalConditionHandler() {
7842:         reset();
7843:     }
7844: 
7845: bool FatalConditionHandler::isSet = false;
7846: ULONG FatalConditionHandler::guaranteeSize = 0;
7847: PVOID FatalConditionHandler::exceptionHandlerHandle = nullptr;
7848: 
7849: } // namespace Catch
7850: 
7851: #elif defined( CATCH_CONFIG_POSIX_SIGNALS )
7852: 
7853: namespace Catch {
7854: 
7855:     struct SignalDefs {
7856:         int id;
7857:         const char* name;
7858:     };
7859: 
7860:     // 32kb for the alternate stack seems to be sufficient. However, this value
7861:     // is experimentally determined, so that's not guaranteed.
7862:     constexpr static std::size_t sigStackSize = 32768 >= MINSIGSTKSZ ? 32768 : MINSIGSTKSZ;
7863: 
7864:     static SignalDefs signalDefs[] = {
7865:         { SIGINT,  "SIGINT - Terminal interrupt signal" },
7866:         { SIGILL,  "SIGILL - Illegal instruction signal" },
7867:         { SIGFPE,  "SIGFPE - Floating point error signal" },
7868:         { SIGSEGV, "SIGSEGV - Segmentation violation signal" },
7869:         { SIGTERM, "SIGTERM - Termination request signal" },
7870:         { SIGABRT, "SIGABRT - Abort (abnormal termination) signal" }
7871:     };
7872: 
7873:     void FatalConditionHandler::handleSignal( int sig ) {
7874:         char const * name = "<unknown signal>";
7875:         for (auto const& def : signalDefs) {
7876:             if (sig == def.id) {
7877:                 name = def.name;
7878:                 break;
7879:             }
7880:         }
7881:         reset();
7882:         reportFatal(name);
7883:         raise( sig );
7884:     }
7885: 
7886:     FatalConditionHandler::FatalConditionHandler() {
7887:         isSet = true;
7888:         stack_t sigStack;
7889:         sigStack.ss_sp = altStackMem;
7890:         sigStack.ss_size = sigStackSize;
7891:         sigStack.ss_flags = 0;
7892:         sigaltstack(&sigStack, &oldSigStack);
7893:         struct sigaction sa = { };
7894: 
7895:         sa.sa_handler = handleSignal;
7896:         sa.sa_flags = SA_ONSTACK;
7897:         for (std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i) {
7898:             sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);
7899:         }
7900:     }
7901: 
7902:     FatalConditionHandler::~FatalConditionHandler() {
7903:         reset();
7904:     }
7905: 
7906:     void FatalConditionHandler::reset() {
7907:         if( isSet ) {
7908:             // Set signals back to previous values -- hopefully nobody overwrote them in the meantime
7909:             for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i ) {
7910:                 sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);
7911:             }
7912:             // Return the old stack
7913:             sigaltstack(&oldSigStack, nullptr);
7914:             isSet = false;
7915:         }
7916:     }
7917: 
7918:     bool FatalConditionHandler::isSet = false;
7919:     struct sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = {};
7920:     stack_t FatalConditionHandler::oldSigStack = {};
7921:     char FatalConditionHandler::altStackMem[sigStackSize] = {};
7922: 
7923: } // namespace Catch
7924: 
7925: #else
7926: 
7927: namespace Catch {
7928:     void FatalConditionHandler::reset() {}
7929: }
7930: 
7931: #endif // signals/SEH handling
7932: 
7933: #if defined(__GNUC__)
7934: #    pragma GCC diagnostic pop
7935: #endif
7936: // end catch_fatal_condition.cpp
7937: // start catch_generators.cpp
7938: 
7939: // start catch_random_number_generator.h
7940: 
7941: #include <algorithm>
7942: #include <random>
7943: 
7944: namespace Catch {
7945: 
7946:     struct IConfig;
7947: 
7948:     std::mt19937& rng();
7949:     void seedRng( IConfig const& config );
7950:     unsigned int rngSeed();
7951: 
7952: }
7953: 
7954: // end catch_random_number_generator.h
7955: #include <limits>
7956: #include <set>
7957: 
7958: namespace Catch {
7959: 
7960: IGeneratorTracker::~IGeneratorTracker() {}
7961: 
7962: namespace Generators {
7963: 
7964:     GeneratorBase::~GeneratorBase() {}
7965: 
7966:     std::vector<size_t> randomiseIndices( size_t selectionSize, size_t sourceSize ) {
7967: 
7968:         assert( selectionSize <= sourceSize );
7969:         std::vector<size_t> indices;
7970:         indices.reserve( selectionSize );
7971:         std::uniform_int_distribution<size_t> uid( 0, sourceSize-1 );
7972: 
7973:         std::set<size_t> seen;
7974:         // !TBD: improve this algorithm
7975:         while( indices.size() < selectionSize ) {
7976:             auto index = uid( rng() );
7977:             if( seen.insert( index ).second )
7978:                 indices.push_back( index );
7979:         }
7980:         return indices;
7981:     }
7982: 
7983:     auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& {
7984:         return getResultCapture().acquireGeneratorTracker( lineInfo );
7985:     }
7986: 
7987:     template<>
7988:     auto all<int>() -> Generator<int> {
7989:         return range( std::numeric_limits<int>::min(), std::numeric_limits<int>::max() );
7990:     }
7991: 
7992: } // namespace Generators
7993: } // namespace Catch
7994: // end catch_generators.cpp
7995: // start catch_interfaces_capture.cpp
7996: 
7997: namespace Catch {
7998:     IResultCapture::~IResultCapture() = default;
7999: }
8000: // end catch_interfaces_capture.cpp
8001: // start catch_interfaces_config.cpp
8002: 
8003: namespace Catch {
8004:     IConfig::~IConfig() = default;
8005: }
8006: // end catch_interfaces_config.cpp
8007: // start catch_interfaces_exception.cpp
8008: 
8009: namespace Catch {
8010:     IExceptionTranslator::~IExceptionTranslator() = default;
8011:     IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;
8012: }
8013: // end catch_interfaces_exception.cpp
8014: // start catch_interfaces_registry_hub.cpp
8015: 
8016: namespace Catch {
8017:     IRegistryHub::~IRegistryHub() = default;
8018:     IMutableRegistryHub::~IMutableRegistryHub() = default;
8019: }
8020: // end catch_interfaces_registry_hub.cpp
8021: // start catch_interfaces_reporter.cpp
8022: 
8023: // start catch_reporter_listening.h
8024: 
8025: namespace Catch {
8026: 
8027:     class ListeningReporter : public IStreamingReporter {
8028:         using Reporters = std::vector<IStreamingReporterPtr>;
8029:         Reporters m_listeners;
8030:         IStreamingReporterPtr m_reporter = nullptr;
8031:         ReporterPreferences m_preferences;
8032: 
8033:     public:
8034:         ListeningReporter();
8035: 
8036:         void addListener( IStreamingReporterPtr&& listener );
8037:         void addReporter( IStreamingReporterPtr&& reporter );
8038: 
8039:     public: // IStreamingReporter
8040: 
8041:         ReporterPreferences getPreferences() const override;
8042: 
8043:         void noMatchingTestCases( std::string const& spec ) override;
8044: 
8045:         static std::set<Verbosity> getSupportedVerbosities();
8046: 
8047:         void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;
8048:         void benchmarkEnded( BenchmarkStats const& benchmarkStats ) override;
8049: 
8050:         void testRunStarting( TestRunInfo const& testRunInfo ) override;
8051:         void testGroupStarting( GroupInfo const& groupInfo ) override;
8052:         void testCaseStarting( TestCaseInfo const& testInfo ) override;
8053:         void sectionStarting( SectionInfo const& sectionInfo ) override;
8054:         void assertionStarting( AssertionInfo const& assertionInfo ) override;
8055: 
8056:         // The return value indicates if the messages buffer should be cleared:
8057:         bool assertionEnded( AssertionStats const& assertionStats ) override;
8058:         void sectionEnded( SectionStats const& sectionStats ) override;
8059:         void testCaseEnded( TestCaseStats const& testCaseStats ) override;
8060:         void testGroupEnded( TestGroupStats const& testGroupStats ) override;
8061:         void testRunEnded( TestRunStats const& testRunStats ) override;
8062: 
8063:         void skipTest( TestCaseInfo const& testInfo ) override;
8064:         bool isMulti() const override;
8065: 
8066:     };
8067: 
8068: } // end namespace Catch
8069: 
8070: // end catch_reporter_listening.h
8071: namespace Catch {
8072: 
8073:     ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig )
8074:     :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}
8075: 
8076:     ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream )
8077:     :   m_stream( &_stream ), m_fullConfig( _fullConfig ) {}
8078: 
8079:     std::ostream& ReporterConfig::stream() const { return *m_stream; }
8080:     IConfigPtr ReporterConfig::fullConfig() const { return m_fullConfig; }
8081: 
8082:     TestRunInfo::TestRunInfo( std::string const& _name ) : name( _name ) {}
8083: 
8084:     GroupInfo::GroupInfo(  std::string const& _name,
8085:                            std::size_t _groupIndex,
8086:                            std::size_t _groupsCount )
8087:     :   name( _name ),
8088:         groupIndex( _groupIndex ),
8089:         groupsCounts( _groupsCount )
8090:     {}
8091: 
8092:      AssertionStats::AssertionStats( AssertionResult const& _assertionResult,
8093:                                      std::vector<MessageInfo> const& _infoMessages,
8094:                                      Totals const& _totals )
8095:     :   assertionResult( _assertionResult ),
8096:         infoMessages( _infoMessages ),
8097:         totals( _totals )
8098:     {
8099:         assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;
8100: 
8101:         if( assertionResult.hasMessage() ) {
8102:             // Copy message into messages list.
8103:             // !TBD This should have been done earlier, somewhere
8104:             MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
8105:             builder << assertionResult.getMessage();
8106:             builder.m_info.message = builder.m_stream.str();
8107: 
8108:             infoMessages.push_back( builder.m_info );
8109:         }
8110:     }
8111: 
8112:      AssertionStats::~AssertionStats() = default;
8113: 
8114:     SectionStats::SectionStats(  SectionInfo const& _sectionInfo,
8115:                                  Counts const& _assertions,
8116:                                  double _durationInSeconds,
8117:                                  bool _missingAssertions )
8118:     :   sectionInfo( _sectionInfo ),
8119:         assertions( _assertions ),
8120:         durationInSeconds( _durationInSeconds ),
8121:         missingAssertions( _missingAssertions )
8122:     {}
8123: 
8124:     SectionStats::~SectionStats() = default;
8125: 
8126:     TestCaseStats::TestCaseStats(  TestCaseInfo const& _testInfo,
8127:                                    Totals const& _totals,
8128:                                    std::string const& _stdOut,
8129:                                    std::string const& _stdErr,
8130:                                    bool _aborting )
8131:     : testInfo( _testInfo ),
8132:         totals( _totals ),
8133:         stdOut( _stdOut ),
8134:         stdErr( _stdErr ),
8135:         aborting( _aborting )
8136:     {}
8137: 
8138:     TestCaseStats::~TestCaseStats() = default;
8139: 
8140:     TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo,
8141:                                     Totals const& _totals,
8142:                                     bool _aborting )
8143:     :   groupInfo( _groupInfo ),
8144:         totals( _totals ),
8145:         aborting( _aborting )
8146:     {}
8147: 
8148:     TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo )
8149:     :   groupInfo( _groupInfo ),
8150:         aborting( false )
8151:     {}
8152: 
8153:     TestGroupStats::~TestGroupStats() = default;
8154: 
8155:     TestRunStats::TestRunStats(   TestRunInfo const& _runInfo,
8156:                     Totals const& _totals,
8157:                     bool _aborting )
8158:     :   runInfo( _runInfo ),
8159:         totals( _totals ),
8160:         aborting( _aborting )
8161:     {}
8162: 
8163:     TestRunStats::~TestRunStats() = default;
8164: 
8165:     void IStreamingReporter::fatalErrorEncountered( StringRef ) {}
8166:     bool IStreamingReporter::isMulti() const { return false; }
8167: 
8168:     IReporterFactory::~IReporterFactory() = default;
8169:     IReporterRegistry::~IReporterRegistry() = default;
8170: 
8171: } // end namespace Catch
8172: // end catch_interfaces_reporter.cpp
8173: // start catch_interfaces_runner.cpp
8174: 
8175: namespace Catch {
8176:     IRunner::~IRunner() = default;
8177: }
8178: // end catch_interfaces_runner.cpp
8179: // start catch_interfaces_testcase.cpp
8180: 
8181: namespace Catch {
8182:     ITestInvoker::~ITestInvoker() = default;
8183:     ITestCaseRegistry::~ITestCaseRegistry() = default;
8184: }
8185: // end catch_interfaces_testcase.cpp
8186: // start catch_leak_detector.cpp
8187: 
8188: #ifdef CATCH_CONFIG_WINDOWS_CRTDBG
8189: #include <crtdbg.h>
8190: 
8191: namespace Catch {
8192: 
8193:     LeakDetector::LeakDetector() {
8194:         int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
8195:         flag |= _CRTDBG_LEAK_CHECK_DF;
8196:         flag |= _CRTDBG_ALLOC_MEM_DF;
8197:         _CrtSetDbgFlag(flag);
8198:         _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
8199:         _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
8200:         // Change this to leaking allocation's number to break there
8201:         _CrtSetBreakAlloc(-1);
8202:     }
8203: }
8204: 
8205: #else
8206: 
8207:     Catch::LeakDetector::LeakDetector() {}
8208: 
8209: #endif
8210: // end catch_leak_detector.cpp
8211: // start catch_list.cpp
8212: 
8213: // start catch_list.h
8214: 
8215: #include <set>
8216: 
8217: namespace Catch {
8218: 
8219:     std::size_t listTests( Config const& config );
8220: 
8221:     std::size_t listTestsNamesOnly( Config const& config );
8222: 
8223:     struct TagInfo {
8224:         void add( std::string const& spelling );
8225:         std::string all() const;
8226: 
8227:         std::set<std::string> spellings;
8228:         std::size_t count = 0;
8229:     };
8230: 
8231:     std::size_t listTags( Config const& config );
8232: 
8233:     std::size_t listReporters( Config const& /*config*/ );
8234: 
8235:     Option<std::size_t> list( Config const& config );
8236: 
8237: } // end namespace Catch
8238: 
8239: // end catch_list.h
8240: // start catch_text.h
8241: 
8242: namespace Catch {
8243:     using namespace clara::TextFlow;
8244: }
8245: 
8246: // end catch_text.h
8247: #include <limits>
8248: #include <algorithm>
8249: #include <iomanip>
8250: 
8251: namespace Catch {
8252: 
8253:     std::size_t listTests( Config const& config ) {
8254:         TestSpec testSpec = config.testSpec();
8255:         if( config.hasTestFilters() )
8256:             Catch::cout() << "Matching test cases:\n";
8257:         else {
8258:             Catch::cout() << "All available test cases:\n";
8259:         }
8260: 
8261:         auto matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8262:         for( auto const& testCaseInfo : matchedTestCases ) {
8263:             Colour::Code colour = testCaseInfo.isHidden()
8264:                 ? Colour::SecondaryText
8265:                 : Colour::None;
8266:             Colour colourGuard( colour );
8267: 
8268:             Catch::cout() << Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) << "\n";
8269:             if( config.verbosity() >= Verbosity::High ) {
8270:                 Catch::cout() << Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) << std::endl;
8271:                 std::string description = testCaseInfo.description;
8272:                 if( description.empty() )
8273:                     description = "(NO DESCRIPTION)";
8274:                 Catch::cout() << Column( description ).indent(4) << std::endl;
8275:             }
8276:             if( !testCaseInfo.tags.empty() )
8277:                 Catch::cout() << Column( testCaseInfo.tagsAsString() ).indent( 6 ) << "\n";
8278:         }
8279: 
8280:         if( !config.hasTestFilters() )
8281:             Catch::cout() << pluralise( matchedTestCases.size(), "test case" ) << '\n' << std::endl;
8282:         else
8283:             Catch::cout() << pluralise( matchedTestCases.size(), "matching test case" ) << '\n' << std::endl;
8284:         return matchedTestCases.size();
8285:     }
8286: 
8287:     std::size_t listTestsNamesOnly( Config const& config ) {
8288:         TestSpec testSpec = config.testSpec();
8289:         std::size_t matchedTests = 0;
8290:         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8291:         for( auto const& testCaseInfo : matchedTestCases ) {
8292:             matchedTests++;
8293:             if( startsWith( testCaseInfo.name, '#' ) )
8294:                Catch::cout() << '"' << testCaseInfo.name << '"';
8295:             else
8296:                Catch::cout() << testCaseInfo.name;
8297:             if ( config.verbosity() >= Verbosity::High )
8298:                 Catch::cout() << "\t@" << testCaseInfo.lineInfo;
8299:             Catch::cout() << std::endl;
8300:         }
8301:         return matchedTests;
8302:     }
8303: 
8304:     void TagInfo::add( std::string const& spelling ) {
8305:         ++count;
8306:         spellings.insert( spelling );
8307:     }
8308: 
8309:     std::string TagInfo::all() const {
8310:         std::string out;
8311:         for( auto const& spelling : spellings )
8312:             out += "[" + spelling + "]";
8313:         return out;
8314:     }
8315: 
8316:     std::size_t listTags( Config const& config ) {
8317:         TestSpec testSpec = config.testSpec();
8318:         if( config.hasTestFilters() )
8319:             Catch::cout() << "Tags for matching test cases:\n";
8320:         else {
8321:             Catch::cout() << "All available tags:\n";
8322:         }
8323: 
8324:         std::map<std::string, TagInfo> tagCounts;
8325: 
8326:         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
8327:         for( auto const& testCase : matchedTestCases ) {
8328:             for( auto const& tagName : testCase.getTestCaseInfo().tags ) {
8329:                 std::string lcaseTagName = toLower( tagName );
8330:                 auto countIt = tagCounts.find( lcaseTagName );
8331:                 if( countIt == tagCounts.end() )
8332:                     countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;
8333:                 countIt->second.add( tagName );
8334:             }
8335:         }
8336: 
8337:         for( auto const& tagCount : tagCounts ) {
8338:             ReusableStringStream rss;
8339:             rss << "  " << std::setw(2) << tagCount.second.count << "  ";
8340:             auto str = rss.str();
8341:             auto wrapper = Column( tagCount.second.all() )
8342:                                                     .initialIndent( 0 )
8343:                                                     .indent( str.size() )
8344:                                                     .width( CATCH_CONFIG_CONSOLE_WIDTH-10 );
8345:             Catch::cout() << str << wrapper << '\n';
8346:         }
8347:         Catch::cout() << pluralise( tagCounts.size(), "tag" ) << '\n' << std::endl;
8348:         return tagCounts.size();
8349:     }
8350: 
8351:     std::size_t listReporters( Config const& /*config*/ ) {
8352:         Catch::cout() << "Available reporters:\n";
8353:         IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
8354:         std::size_t maxNameLen = 0;
8355:         for( auto const& factoryKvp : factories )
8356:             maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );
8357: 
8358:         for( auto const& factoryKvp : factories ) {
8359:             Catch::cout()
8360:                     << Column( factoryKvp.first + ":" )
8361:                             .indent(2)
8362:                             .width( 5+maxNameLen )
8363:                     +  Column( factoryKvp.second->getDescription() )
8364:                             .initialIndent(0)
8365:                             .indent(2)
8366:                             .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 )
8367:                     << "\n";
8368:         }
8369:         Catch::cout() << std::endl;
8370:         return factories.size();
8371:     }
8372: 
8373:     Option<std::size_t> list( Config const& config ) {
8374:         Option<std::size_t> listedCount;
8375:         if( config.listTests() )
8376:             listedCount = listedCount.valueOr(0) + listTests( config );
8377:         if( config.listTestNamesOnly() )
8378:             listedCount = listedCount.valueOr(0) + listTestsNamesOnly( config );
8379:         if( config.listTags() )
8380:             listedCount = listedCount.valueOr(0) + listTags( config );
8381:         if( config.listReporters() )
8382:             listedCount = listedCount.valueOr(0) + listReporters( config );
8383:         return listedCount;
8384:     }
8385: 
8386: } // end namespace Catch
8387: // end catch_list.cpp
8388: // start catch_matchers.cpp
8389: 
8390: namespace Catch {
8391: namespace Matchers {
8392:     namespace Impl {
8393: 
8394:         std::string MatcherUntypedBase::toString() const {
8395:             if( m_cachedToString.empty() )
8396:                 m_cachedToString = describe();
8397:             return m_cachedToString;
8398:         }
8399: 
8400:         MatcherUntypedBase::~MatcherUntypedBase() = default;
8401: 
8402:     } // namespace Impl
8403: } // namespace Matchers
8404: 
8405: using namespace Matchers;
8406: using Matchers::Impl::MatcherBase;
8407: 
8408: } // namespace Catch
8409: // end catch_matchers.cpp
8410: // start catch_matchers_floating.cpp
8411: 
8412: // start catch_to_string.hpp
8413: 
8414: #include <string>
8415: 
8416: namespace Catch {
8417:     template <typename T>
8418:     std::string to_string(T const& t) {
8419: #if defined(CATCH_CONFIG_CPP11_TO_STRING)
8420:         return std::to_string(t);
8421: #else
8422:         ReusableStringStream rss;
8423:         rss << t;
8424:         return rss.str();
8425: #endif
8426:     }
8427: } // end namespace Catch
8428: 
8429: // end catch_to_string.hpp
8430: #include <cstdlib>
8431: #include <cstdint>
8432: #include <cstring>
8433: 
8434: namespace Catch {
8435: namespace Matchers {
8436: namespace Floating {
8437: enum class FloatingPointKind : uint8_t {
8438:     Float,
8439:     Double
8440: };
8441: }
8442: }
8443: }
8444: 
8445: namespace {
8446: 
8447: template <typename T>
8448: struct Converter;
8449: 
8450: template <>
8451: struct Converter<float> {
8452:     static_assert(sizeof(float) == sizeof(int32_t), "Important ULP matcher assumption violated");
8453:     Converter(float f) {
8454:         std::memcpy(&i, &f, sizeof(f));
8455:     }
8456:     int32_t i;
8457: };
8458: 
8459: template <>
8460: struct Converter<double> {
8461:     static_assert(sizeof(double) == sizeof(int64_t), "Important ULP matcher assumption violated");
8462:     Converter(double d) {
8463:         std::memcpy(&i, &d, sizeof(d));
8464:     }
8465:     int64_t i;
8466: };
8467: 
8468: template <typename T>
8469: auto convert(T t) -> Converter<T> {
8470:     return Converter<T>(t);
8471: }
8472: 
8473: template <typename FP>
8474: bool almostEqualUlps(FP lhs, FP rhs, int maxUlpDiff) {
8475:     // Comparison with NaN should always be false.
8476:     // This way we can rule it out before getting into the ugly details
8477:     if (std::isnan(lhs) || std::isnan(rhs)) {
8478:         return false;
8479:     }
8480: 
8481:     auto lc = convert(lhs);
8482:     auto rc = convert(rhs);
8483: 
8484:     if ((lc.i < 0) != (rc.i < 0)) {
8485:         // Potentially we can have +0 and -0
8486:         return lhs == rhs;
8487:     }
8488: 
8489:     auto ulpDiff = std::abs(lc.i - rc.i);
8490:     return ulpDiff <= maxUlpDiff;
8491: }
8492: 
8493: }
8494: 
8495: namespace Catch {
8496: namespace Matchers {
8497: namespace Floating {
8498:     WithinAbsMatcher::WithinAbsMatcher(double target, double margin)
8499:         :m_target{ target }, m_margin{ margin } {
8500:         CATCH_ENFORCE(margin >= 0, "Invalid margin: " << margin << '.'
8501:             << " Margin has to be non-negative.");
8502:     }
8503: 
8504:     // Performs equivalent check of std::fabs(lhs - rhs) <= margin
8505:     // But without the subtraction to allow for INFINITY in comparison
8506:     bool WithinAbsMatcher::match(double const& matchee) const {
8507:         return (matchee + m_margin >= m_target) && (m_target + m_margin >= matchee);
8508:     }
8509: 
8510:     std::string WithinAbsMatcher::describe() const {
8511:         return "is within " + ::Catch::Detail::stringify(m_margin) + " of " + ::Catch::Detail::stringify(m_target);
8512:     }
8513: 
8514:     WithinUlpsMatcher::WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType)
8515:         :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {
8516:         CATCH_ENFORCE(ulps >= 0, "Invalid ULP setting: " << ulps << '.'
8517:             << " ULPs have to be non-negative.");
8518:     }
8519: 
8520: #if defined(__clang__)
8521: #pragma clang diagnostic push
8522: // Clang <3.5 reports on the default branch in the switch below
8523: #pragma clang diagnostic ignored "-Wunreachable-code"
8524: #endif
8525: 
8526:     bool WithinUlpsMatcher::match(double const& matchee) const {
8527:         switch (m_type) {
8528:         case FloatingPointKind::Float:
8529:             return almostEqualUlps<float>(static_cast<float>(matchee), static_cast<float>(m_target), m_ulps);
8530:         case FloatingPointKind::Double:
8531:             return almostEqualUlps<double>(matchee, m_target, m_ulps);
8532:         default:
8533:             CATCH_INTERNAL_ERROR( "Unknown FloatingPointKind value" );
8534:         }
8535:     }
8536: 
8537: #if defined(__clang__)
8538: #pragma clang diagnostic pop
8539: #endif
8540: 
8541:     std::string WithinUlpsMatcher::describe() const {
8542:         return "is within " + Catch::to_string(m_ulps) + " ULPs of " + ::Catch::Detail::stringify(m_target) + ((m_type == FloatingPointKind::Float)? "f" : "");
8543:     }
8544: 
8545: }// namespace Floating
8546: 
8547: Floating::WithinUlpsMatcher WithinULP(double target, int maxUlpDiff) {
8548:     return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);
8549: }
8550: 
8551: Floating::WithinUlpsMatcher WithinULP(float target, int maxUlpDiff) {
8552:     return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);
8553: }
8554: 
8555: Floating::WithinAbsMatcher WithinAbs(double target, double margin) {
8556:     return Floating::WithinAbsMatcher(target, margin);
8557: }
8558: 
8559: } // namespace Matchers
8560: } // namespace Catch
8561: 
8562: // end catch_matchers_floating.cpp
8563: // start catch_matchers_generic.cpp
8564: 
8565: std::string Catch::Matchers::Generic::Detail::finalizeDescription(const std::string& desc) {
8566:     if (desc.empty()) {
8567:         return "matches undescribed predicate";
8568:     } else {
8569:         return "matches predicate: \"" + desc + '"';
8570:     }
8571: }
8572: // end catch_matchers_generic.cpp
8573: // start catch_matchers_string.cpp
8574: 
8575: #include <regex>
8576: 
8577: namespace Catch {
8578: namespace Matchers {
8579: 
8580:     namespace StdString {
8581: 
8582:         CasedString::CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )
8583:         :   m_caseSensitivity( caseSensitivity ),
8584:             m_str( adjustString( str ) )
8585:         {}
8586:         std::string CasedString::adjustString( std::string const& str ) const {
8587:             return m_caseSensitivity == CaseSensitive::No
8588:                    ? toLower( str )
8589:                    : str;
8590:         }
8591:         std::string CasedString::caseSensitivitySuffix() const {
8592:             return m_caseSensitivity == CaseSensitive::No
8593:                    ? " (case insensitive)"
8594:                    : std::string();
8595:         }
8596: 
8597:         StringMatcherBase::StringMatcherBase( std::string const& operation, CasedString const& comparator )
8598:         : m_comparator( comparator ),
8599:           m_operation( operation ) {
8600:         }
8601: 
8602:         std::string StringMatcherBase::describe() const {
8603:             std::string description;
8604:             description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +
8605:                                         m_comparator.caseSensitivitySuffix().size());
8606:             description += m_operation;
8607:             description += ": \"";
8608:             description += m_comparator.m_str;
8609:             description += "\"";
8610:             description += m_comparator.caseSensitivitySuffix();
8611:             return description;
8612:         }
8613: 
8614:         EqualsMatcher::EqualsMatcher( CasedString const& comparator ) : StringMatcherBase( "equals", comparator ) {}
8615: 
8616:         bool EqualsMatcher::match( std::string const& source ) const {
8617:             return m_comparator.adjustString( source ) == m_comparator.m_str;
8618:         }
8619: 
8620:         ContainsMatcher::ContainsMatcher( CasedString const& comparator ) : StringMatcherBase( "contains", comparator ) {}
8621: 
8622:         bool ContainsMatcher::match( std::string const& source ) const {
8623:             return contains( m_comparator.adjustString( source ), m_comparator.m_str );
8624:         }
8625: 
8626:         StartsWithMatcher::StartsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "starts with", comparator ) {}
8627: 
8628:         bool StartsWithMatcher::match( std::string const& source ) const {
8629:             return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );
8630:         }
8631: 
8632:         EndsWithMatcher::EndsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "ends with", comparator ) {}
8633: 
8634:         bool EndsWithMatcher::match( std::string const& source ) const {
8635:             return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );
8636:         }
8637: 
8638:         RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}
8639: 
8640:         bool RegexMatcher::match(std::string const& matchee) const {
8641:             auto flags = std::regex::ECMAScript; // ECMAScript is the default syntax option anyway
8642:             if (m_caseSensitivity == CaseSensitive::Choice::No) {
8643:                 flags |= std::regex::icase;
8644:             }
8645:             auto reg = std::regex(m_regex, flags);
8646:             return std::regex_match(matchee, reg);
8647:         }
8648: 
8649:         std::string RegexMatcher::describe() const {
8650:             return "matches " + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? " case sensitively" : " case insensitively");
8651:         }
8652: 
8653:     } // namespace StdString
8654: 
8655:     StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
8656:         return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );
8657:     }
8658:     StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
8659:         return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );
8660:     }
8661:     StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
8662:         return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );
8663:     }
8664:     StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
8665:         return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );
8666:     }
8667: 
8668:     StdString::RegexMatcher Matches(std::string const& regex, CaseSensitive::Choice caseSensitivity) {
8669:         return StdString::RegexMatcher(regex, caseSensitivity);
8670:     }
8671: 
8672: } // namespace Matchers
8673: } // namespace Catch
8674: // end catch_matchers_string.cpp
8675: // start catch_message.cpp
8676: 
8677: // start catch_uncaught_exceptions.h
8678: 
8679: namespace Catch {
8680:     bool uncaught_exceptions();
8681: } // end namespace Catch
8682: 
8683: // end catch_uncaught_exceptions.h
8684: #include <cassert>
8685: 
8686: namespace Catch {
8687: 
8688:     MessageInfo::MessageInfo(   StringRef const& _macroName,
8689:                                 SourceLineInfo const& _lineInfo,
8690:                                 ResultWas::OfType _type )
8691:     :   macroName( _macroName ),
8692:         lineInfo( _lineInfo ),
8693:         type( _type ),
8694:         sequence( ++globalCount )
8695:     {}
8696: 
8697:     bool MessageInfo::operator==( MessageInfo const& other ) const {
8698:         return sequence == other.sequence;
8699:     }
8700: 
8701:     bool MessageInfo::operator<( MessageInfo const& other ) const {
8702:         return sequence < other.sequence;
8703:     }
8704: 
8705:     // This may need protecting if threading support is added
8706:     unsigned int MessageInfo::globalCount = 0;
8707: 
8708:     ////////////////////////////////////////////////////////////////////////////
8709: 
8710:     Catch::MessageBuilder::MessageBuilder( StringRef const& macroName,
8711:                                            SourceLineInfo const& lineInfo,
8712:                                            ResultWas::OfType type )
8713:         :m_info(macroName, lineInfo, type) {}
8714: 
8715:     ////////////////////////////////////////////////////////////////////////////
8716: 
8717:     ScopedMessage::ScopedMessage( MessageBuilder const& builder )
8718:     : m_info( builder.m_info )
8719:     {
8720:         m_info.message = builder.m_stream.str();
8721:         getResultCapture().pushScopedMessage( m_info );
8722:     }
8723: 
8724:     ScopedMessage::~ScopedMessage() {
8725:         if ( !uncaught_exceptions() ){
8726:             getResultCapture().popScopedMessage(m_info);
8727:         }
8728:     }
8729: 
8730:     Capturer::Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names ) {
8731:         auto start = std::string::npos;
8732:         for( size_t pos = 0; pos <= names.size(); ++pos ) {
8733:             char c = names[pos];
8734:             if( pos == names.size() || c == ' ' || c == '\t' || c == ',' || c == ']' ) {
8735:                 if( start != std::string::npos ) {
8736:                     m_messages.push_back( MessageInfo( macroName, lineInfo, resultType ) );
8737:                     m_messages.back().message = names.substr( start, pos-start) + " := ";
8738:                     start = std::string::npos;
8739:                 }
8740:             }
8741:             else if( c != '[' && c != ']' && start == std::string::npos )
8742:                 start = pos;
8743:         }
8744:     }
8745:     Capturer::~Capturer() {
8746:         if ( !uncaught_exceptions() ){
8747:             assert( m_captured == m_messages.size() );
8748:             for( size_t i = 0; i < m_captured; ++i  )
8749:                 m_resultCapture.popScopedMessage( m_messages[i] );
8750:         }
8751:     }
8752: 
8753:     void Capturer::captureValue( size_t index, StringRef value ) {
8754:         assert( index < m_messages.size() );
8755:         m_messages[index].message += value;
8756:         m_resultCapture.pushScopedMessage( m_messages[index] );
8757:         m_captured++;
8758:     }
8759: 
8760: } // end namespace Catch
8761: // end catch_message.cpp
8762: // start catch_output_redirect.cpp
8763: 
8764: // start catch_output_redirect.h
8765: #ifndef TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
8766: #define TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
8767: 
8768: #include <cstdio>
8769: #include <iosfwd>
8770: #include <string>
8771: 
8772: namespace Catch {
8773: 
8774:     class RedirectedStream {
8775:         std::ostream& m_originalStream;
8776:         std::ostream& m_redirectionStream;
8777:         std::streambuf* m_prevBuf;
8778: 
8779:     public:
8780:         RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream );
8781:         ~RedirectedStream();
8782:     };
8783: 
8784:     class RedirectedStdOut {
8785:         ReusableStringStream m_rss;
8786:         RedirectedStream m_cout;
8787:     public:
8788:         RedirectedStdOut();
8789:         auto str() const -> std::string;
8790:     };
8791: 
8792:     // StdErr has two constituent streams in C++, std::cerr and std::clog
8793:     // This means that we need to redirect 2 streams into 1 to keep proper
8794:     // order of writes
8795:     class RedirectedStdErr {
8796:         ReusableStringStream m_rss;
8797:         RedirectedStream m_cerr;
8798:         RedirectedStream m_clog;
8799:     public:
8800:         RedirectedStdErr();
8801:         auto str() const -> std::string;
8802:     };
8803: 
8804: #if defined(CATCH_CONFIG_NEW_CAPTURE)
8805: 
8806:     // Windows's implementation of std::tmpfile is terrible (it tries
8807:     // to create a file inside system folder, thus requiring elevated
8808:     // privileges for the binary), so we have to use tmpnam(_s) and
8809:     // create the file ourselves there.
8810:     class TempFile {
8811:     public:
8812:         TempFile(TempFile const&) = delete;
8813:         TempFile& operator=(TempFile const&) = delete;
8814:         TempFile(TempFile&&) = delete;
8815:         TempFile& operator=(TempFile&&) = delete;
8816: 
8817:         TempFile();
8818:         ~TempFile();
8819: 
8820:         std::FILE* getFile();
8821:         std::string getContents();
8822: 
8823:     private:
8824:         std::FILE* m_file = nullptr;
8825:     #if defined(_MSC_VER)
8826:         char m_buffer[L_tmpnam] = { 0 };
8827:     #endif
8828:     };
8829: 
8830:     class OutputRedirect {
8831:     public:
8832:         OutputRedirect(OutputRedirect const&) = delete;
8833:         OutputRedirect& operator=(OutputRedirect const&) = delete;
8834:         OutputRedirect(OutputRedirect&&) = delete;
8835:         OutputRedirect& operator=(OutputRedirect&&) = delete;
8836: 
8837:         OutputRedirect(std::string& stdout_dest, std::string& stderr_dest);
8838:         ~OutputRedirect();
8839: 
8840:     private:
8841:         int m_originalStdout = -1;
8842:         int m_originalStderr = -1;
8843:         TempFile m_stdoutFile;
8844:         TempFile m_stderrFile;
8845:         std::string& m_stdoutDest;
8846:         std::string& m_stderrDest;
8847:     };
8848: 
8849: #endif
8850: 
8851: } // end namespace Catch
8852: 
8853: #endif // TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
8854: // end catch_output_redirect.h
8855: #include <cstdio>
8856: #include <cstring>
8857: #include <fstream>
8858: #include <sstream>
8859: #include <stdexcept>
8860: 
8861: #if defined(CATCH_CONFIG_NEW_CAPTURE)
8862:     #if defined(_MSC_VER)
8863:     #include <io.h>      //_dup and _dup2
8864:     #define dup _dup
8865:     #define dup2 _dup2
8866:     #define fileno _fileno
8867:     #else
8868:     #include <unistd.h>  // dup and dup2
8869:     #endif
8870: #endif
8871: 
8872: namespace Catch {
8873: 
8874:     RedirectedStream::RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream )
8875:     :   m_originalStream( originalStream ),
8876:         m_redirectionStream( redirectionStream ),
8877:         m_prevBuf( m_originalStream.rdbuf() )
8878:     {
8879:         m_originalStream.rdbuf( m_redirectionStream.rdbuf() );
8880:     }
8881: 
8882:     RedirectedStream::~RedirectedStream() {
8883:         m_originalStream.rdbuf( m_prevBuf );
8884:     }
8885: 
8886:     RedirectedStdOut::RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}
8887:     auto RedirectedStdOut::str() const -> std::string { return m_rss.str(); }
8888: 
8889:     RedirectedStdErr::RedirectedStdErr()
8890:     :   m_cerr( Catch::cerr(), m_rss.get() ),
8891:         m_clog( Catch::clog(), m_rss.get() )
8892:     {}
8893:     auto RedirectedStdErr::str() const -> std::string { return m_rss.str(); }
8894: 
8895: #if defined(CATCH_CONFIG_NEW_CAPTURE)
8896: 
8897: #if defined(_MSC_VER)
8898:     TempFile::TempFile() {
8899:         if (tmpnam_s(m_buffer)) {
8900:             CATCH_RUNTIME_ERROR("Could not get a temp filename");
8901:         }
8902:         if (fopen_s(&m_file, m_buffer, "w")) {
8903:             char buffer[100];
8904:             if (strerror_s(buffer, errno)) {
8905:                 CATCH_RUNTIME_ERROR("Could not translate errno to a string");
8906:             }
8907:             CATCH_RUNTIME_ERROR("Coul dnot open the temp file: '" << m_buffer << "' because: " << buffer);
8908:         }
8909:     }
8910: #else
8911:     TempFile::TempFile() {
8912:         m_file = std::tmpfile();
8913:         if (!m_file) {
8914:             CATCH_RUNTIME_ERROR("Could not create a temp file.");
8915:         }
8916:     }
8917: 
8918: #endif
8919: 
8920:     TempFile::~TempFile() {
8921:          // TBD: What to do about errors here?
8922:          std::fclose(m_file);
8923:          // We manually create the file on Windows only, on Linux
8924:          // it will be autodeleted
8925: #if defined(_MSC_VER)
8926:          std::remove(m_buffer);
8927: #endif
8928:     }
8929: 
8930:     FILE* TempFile::getFile() {
8931:         return m_file;
8932:     }
8933: 
8934:     std::string TempFile::getContents() {
8935:         std::stringstream sstr;
8936:         char buffer[100] = {};
8937:         std::rewind(m_file);
8938:         while (std::fgets(buffer, sizeof(buffer), m_file)) {
8939:             sstr << buffer;
8940:         }
8941:         return sstr.str();
8942:     }
8943: 
8944:     OutputRedirect::OutputRedirect(std::string& stdout_dest, std::string& stderr_dest) :
8945:         m_originalStdout(dup(1)),
8946:         m_originalStderr(dup(2)),
8947:         m_stdoutDest(stdout_dest),
8948:         m_stderrDest(stderr_dest) {
8949:         dup2(fileno(m_stdoutFile.getFile()), 1);
8950:         dup2(fileno(m_stderrFile.getFile()), 2);
8951:     }
8952: 
8953:     OutputRedirect::~OutputRedirect() {
8954:         Catch::cout() << std::flush;
8955:         fflush(stdout);
8956:         // Since we support overriding these streams, we flush cerr
8957:         // even though std::cerr is unbuffered
8958:         Catch::cerr() << std::flush;
8959:         Catch::clog() << std::flush;
8960:         fflush(stderr);
8961: 
8962:         dup2(m_originalStdout, 1);
8963:         dup2(m_originalStderr, 2);
8964: 
8965:         m_stdoutDest += m_stdoutFile.getContents();
8966:         m_stderrDest += m_stderrFile.getContents();
8967:     }
8968: 
8969: #endif // CATCH_CONFIG_NEW_CAPTURE
8970: 
8971: } // namespace Catch
8972: 
8973: #if defined(CATCH_CONFIG_NEW_CAPTURE)
8974:     #if defined(_MSC_VER)
8975:     #undef dup
8976:     #undef dup2
8977:     #undef fileno
8978:     #endif
8979: #endif
8980: // end catch_output_redirect.cpp
8981: // start catch_random_number_generator.cpp
8982: 
8983: namespace Catch {
8984: 
8985:     std::mt19937& rng() {
8986:         static std::mt19937 s_rng;
8987:         return s_rng;
8988:     }
8989: 
8990:     void seedRng( IConfig const& config ) {
8991:         if( config.rngSeed() != 0 ) {
8992:             std::srand( config.rngSeed() );
8993:             rng().seed( config.rngSeed() );
8994:         }
8995:     }
8996: 
8997:     unsigned int rngSeed() {
8998:         return getCurrentContext().getConfig()->rngSeed();
8999:     }
9000: }
9001: // end catch_random_number_generator.cpp
9002: // start catch_registry_hub.cpp
9003: 
9004: // start catch_test_case_registry_impl.h
9005: 
9006: #include <vector>
9007: #include <set>
9008: #include <algorithm>
9009: #include <ios>
9010: 
9011: namespace Catch {
9012: 
9013:     class TestCase;
9014:     struct IConfig;
9015: 
9016:     std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases );
9017:     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
9018: 
9019:     void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions );
9020: 
9021:     std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
9022:     std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );
9023: 
9024:     class TestRegistry : public ITestCaseRegistry {
9025:     public:
9026:         virtual ~TestRegistry() = default;
9027: 
9028:         virtual void registerTest( TestCase const& testCase );
9029: 
9030:         std::vector<TestCase> const& getAllTests() const override;
9031:         std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const override;
9032: 
9033:     private:
9034:         std::vector<TestCase> m_functions;
9035:         mutable RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;
9036:         mutable std::vector<TestCase> m_sortedFunctions;
9037:         std::size_t m_unnamedCount = 0;
9038:         std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised
9039:     };
9040: 
9041:     ///////////////////////////////////////////////////////////////////////////
9042: 
9043:     class TestInvokerAsFunction : public ITestInvoker {
9044:         void(*m_testAsFunction)();
9045:     public:
9046:         TestInvokerAsFunction( void(*testAsFunction)() ) noexcept;
9047: 
9048:         void invoke() const override;
9049:     };
9050: 
9051:     std::string extractClassName( StringRef const& classOrQualifiedMethodName );
9052: 
9053:     ///////////////////////////////////////////////////////////////////////////
9054: 
9055: } // end namespace Catch
9056: 
9057: // end catch_test_case_registry_impl.h
9058: // start catch_reporter_registry.h
9059: 
9060: #include <map>
9061: 
9062: namespace Catch {
9063: 
9064:     class ReporterRegistry : public IReporterRegistry {
9065: 
9066:     public:
9067: 
9068:         ~ReporterRegistry() override;
9069: 
9070:         IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const override;
9071: 
9072:         void registerReporter( std::string const& name, IReporterFactoryPtr const& factory );
9073:         void registerListener( IReporterFactoryPtr const& factory );
9074: 
9075:         FactoryMap const& getFactories() const override;
9076:         Listeners const& getListeners() const override;
9077: 
9078:     private:
9079:         FactoryMap m_factories;
9080:         Listeners m_listeners;
9081:     };
9082: }
9083: 
9084: // end catch_reporter_registry.h
9085: // start catch_tag_alias_registry.h
9086: 
9087: // start catch_tag_alias.h
9088: 
9089: #include <string>
9090: 
9091: namespace Catch {
9092: 
9093:     struct TagAlias {
9094:         TagAlias(std::string const& _tag, SourceLineInfo _lineInfo);
9095: 
9096:         std::string tag;
9097:         SourceLineInfo lineInfo;
9098:     };
9099: 
9100: } // end namespace Catch
9101: 
9102: // end catch_tag_alias.h
9103: #include <map>
9104: 
9105: namespace Catch {
9106: 
9107:     class TagAliasRegistry : public ITagAliasRegistry {
9108:     public:
9109:         ~TagAliasRegistry() override;
9110:         TagAlias const* find( std::string const& alias ) const override;
9111:         std::string expandAliases( std::string const& unexpandedTestSpec ) const override;
9112:         void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );
9113: 
9114:     private:
9115:         std::map<std::string, TagAlias> m_registry;
9116:     };
9117: 
9118: } // end namespace Catch
9119: 
9120: // end catch_tag_alias_registry.h
9121: // start catch_startup_exception_registry.h
9122: 
9123: #include <vector>
9124: #include <exception>
9125: 
9126: namespace Catch {
9127: 
9128:     class StartupExceptionRegistry {
9129:     public:
9130:         void add(std::exception_ptr const& exception) noexcept;
9131:         std::vector<std::exception_ptr> const& getExceptions() const noexcept;
9132:     private:
9133:         std::vector<std::exception_ptr> m_exceptions;
9134:     };
9135: 
9136: } // end namespace Catch
9137: 
9138: // end catch_startup_exception_registry.h
9139: // start catch_singletons.hpp
9140: 
9141: namespace Catch {
9142: 
9143:     struct ISingleton {
9144:         virtual ~ISingleton();
9145:     };
9146: 
9147:     void addSingleton( ISingleton* singleton );
9148:     void cleanupSingletons();
9149: 
9150:     template<typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT>
9151:     class Singleton : SingletonImplT, public ISingleton {
9152: 
9153:         static auto getInternal() -> Singleton* {
9154:             static Singleton* s_instance = nullptr;
9155:             if( !s_instance ) {
9156:                 s_instance = new Singleton;
9157:                 addSingleton( s_instance );
9158:             }
9159:             return s_instance;
9160:         }
9161: 
9162:     public:
9163:         static auto get() -> InterfaceT const& {
9164:             return *getInternal();
9165:         }
9166:         static auto getMutable() -> MutableInterfaceT& {
9167:             return *getInternal();
9168:         }
9169:     };
9170: 
9171: } // namespace Catch
9172: 
9173: // end catch_singletons.hpp
9174: namespace Catch {
9175: 
9176:     namespace {
9177: 
9178:         class RegistryHub : public IRegistryHub, public IMutableRegistryHub,
9179:                             private NonCopyable {
9180: 
9181:         public: // IRegistryHub
9182:             RegistryHub() = default;
9183:             IReporterRegistry const& getReporterRegistry() const override {
9184:                 return m_reporterRegistry;
9185:             }
9186:             ITestCaseRegistry const& getTestCaseRegistry() const override {
9187:                 return m_testCaseRegistry;
9188:             }
9189:             IExceptionTranslatorRegistry const& getExceptionTranslatorRegistry() const override {
9190:                 return m_exceptionTranslatorRegistry;
9191:             }
9192:             ITagAliasRegistry const& getTagAliasRegistry() const override {
9193:                 return m_tagAliasRegistry;
9194:             }
9195:             StartupExceptionRegistry const& getStartupExceptionRegistry() const override {
9196:                 return m_exceptionRegistry;
9197:             }
9198: 
9199:         public: // IMutableRegistryHub
9200:             void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) override {
9201:                 m_reporterRegistry.registerReporter( name, factory );
9202:             }
9203:             void registerListener( IReporterFactoryPtr const& factory ) override {
9204:                 m_reporterRegistry.registerListener( factory );
9205:             }
9206:             void registerTest( TestCase const& testInfo ) override {
9207:                 m_testCaseRegistry.registerTest( testInfo );
9208:             }
9209:             void registerTranslator( const IExceptionTranslator* translator ) override {
9210:                 m_exceptionTranslatorRegistry.registerTranslator( translator );
9211:             }
9212:             void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) override {
9213:                 m_tagAliasRegistry.add( alias, tag, lineInfo );
9214:             }
9215:             void registerStartupException() noexcept override {
9216:                 m_exceptionRegistry.add(std::current_exception());
9217:             }
9218: 
9219:         private:
9220:             TestRegistry m_testCaseRegistry;
9221:             ReporterRegistry m_reporterRegistry;
9222:             ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
9223:             TagAliasRegistry m_tagAliasRegistry;
9224:             StartupExceptionRegistry m_exceptionRegistry;
9225:         };
9226:     }
9227: 
9228:     using RegistryHubSingleton = Singleton<RegistryHub, IRegistryHub, IMutableRegistryHub>;
9229: 
9230:     IRegistryHub const& getRegistryHub() {
9231:         return RegistryHubSingleton::get();
9232:     }
9233:     IMutableRegistryHub& getMutableRegistryHub() {
9234:         return RegistryHubSingleton::getMutable();
9235:     }
9236:     void cleanUp() {
9237:         cleanupSingletons();
9238:         cleanUpContext();
9239:     }
9240:     std::string translateActiveException() {
9241:         return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
9242:     }
9243: 
9244: } // end namespace Catch
9245: // end catch_registry_hub.cpp
9246: // start catch_reporter_registry.cpp
9247: 
9248: namespace Catch {
9249: 
9250:     ReporterRegistry::~ReporterRegistry() = default;
9251: 
9252:     IStreamingReporterPtr ReporterRegistry::create( std::string const& name, IConfigPtr const& config ) const {
9253:         auto it =  m_factories.find( name );
9254:         if( it == m_factories.end() )
9255:             return nullptr;
9256:         return it->second->create( ReporterConfig( config ) );
9257:     }
9258: 
9259:     void ReporterRegistry::registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) {
9260:         m_factories.emplace(name, factory);
9261:     }
9262:     void ReporterRegistry::registerListener( IReporterFactoryPtr const& factory ) {
9263:         m_listeners.push_back( factory );
9264:     }
9265: 
9266:     IReporterRegistry::FactoryMap const& ReporterRegistry::getFactories() const {
9267:         return m_factories;
9268:     }
9269:     IReporterRegistry::Listeners const& ReporterRegistry::getListeners() const {
9270:         return m_listeners;
9271:     }
9272: 
9273: }
9274: // end catch_reporter_registry.cpp
9275: // start catch_result_type.cpp
9276: 
9277: namespace Catch {
9278: 
9279:     bool isOk( ResultWas::OfType resultType ) {
9280:         return ( resultType & ResultWas::FailureBit ) == 0;
9281:     }
9282:     bool isJustInfo( int flags ) {
9283:         return flags == ResultWas::Info;
9284:     }
9285: 
9286:     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
9287:         return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );
9288:     }
9289: 
9290:     bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }
9291:     bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }
9292: 
9293: } // end namespace Catch
9294: // end catch_result_type.cpp
9295: // start catch_run_context.cpp
9296: 
9297: #include <cassert>
9298: #include <algorithm>
9299: #include <sstream>
9300: 
9301: namespace Catch {
9302: 
9303:     namespace Generators {
9304:         struct GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker {
9305:             size_t m_index = static_cast<size_t>( -1 );
9306:             GeneratorBasePtr m_generator;
9307: 
9308:             GeneratorTracker( TestCaseTracking::NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
9309:             :   TrackerBase( nameAndLocation, ctx, parent )
9310:             {}
9311:             ~GeneratorTracker();
9312: 
9313:             static GeneratorTracker& acquire( TrackerContext& ctx, TestCaseTracking::NameAndLocation const& nameAndLocation ) {
9314:                 std::shared_ptr<GeneratorTracker> tracker;
9315: 
9316:                 ITracker& currentTracker = ctx.currentTracker();
9317:                 if( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
9318:                     assert( childTracker );
9319:                     assert( childTracker->isIndexTracker() );
9320:                     tracker = std::static_pointer_cast<GeneratorTracker>( childTracker );
9321:                 }
9322:                 else {
9323:                     tracker = std::make_shared<GeneratorTracker>( nameAndLocation, ctx, &currentTracker );
9324:                     currentTracker.addChild( tracker );
9325:                 }
9326: 
9327:                 if( !ctx.completedCycle() && !tracker->isComplete() ) {
9328:                     if( tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun )
9329:                         tracker->moveNext();
9330:                     tracker->open();
9331:                 }
9332: 
9333:                 return *tracker;
9334:             }
9335: 
9336:             void moveNext() {
9337:                 m_index++;
9338:                 m_children.clear();
9339:             }
9340: 
9341:             // TrackerBase interface
9342:             bool isIndexTracker() const override { return true; }
9343:             auto hasGenerator() const -> bool override {
9344:                 return !!m_generator;
9345:             }
9346:             void close() override {
9347:                 TrackerBase::close();
9348:                 if( m_runState == CompletedSuccessfully && m_index < m_generator->size()-1 )
9349:                     m_runState = Executing;
9350:             }
9351: 
9352:             // IGeneratorTracker interface
9353:             auto getGenerator() const -> GeneratorBasePtr const& override {
9354:                 return m_generator;
9355:             }
9356:             void setGenerator( GeneratorBasePtr&& generator ) override {
9357:                 m_generator = std::move( generator );
9358:             }
9359:             auto getIndex() const -> size_t override {
9360:                 return m_index;
9361:             }
9362:         };
9363:         GeneratorTracker::~GeneratorTracker() {}
9364:     }
9365: 
9366:     RunContext::RunContext(IConfigPtr const& _config, IStreamingReporterPtr&& reporter)
9367:     :   m_runInfo(_config->name()),
9368:         m_context(getCurrentMutableContext()),
9369:         m_config(_config),
9370:         m_reporter(std::move(reporter)),
9371:         m_lastAssertionInfo{ StringRef(), SourceLineInfo("",0), StringRef(), ResultDisposition::Normal },
9372:         m_includeSuccessfulResults( m_config->includeSuccessfulResults() || m_reporter->getPreferences().shouldReportAllAssertions )
9373:     {
9374:         m_context.setRunner(this);
9375:         m_context.setConfig(m_config);
9376:         m_context.setResultCapture(this);
9377:         m_reporter->testRunStarting(m_runInfo);
9378:     }
9379: 
9380:     RunContext::~RunContext() {
9381:         m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
9382:     }
9383: 
9384:     void RunContext::testGroupStarting(std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount) {
9385:         m_reporter->testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));
9386:     }
9387: 
9388:     void RunContext::testGroupEnded(std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount) {
9389:         m_reporter->testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));
9390:     }
9391: 
9392:     Totals RunContext::runTest(TestCase const& testCase) {
9393:         Totals prevTotals = m_totals;
9394: 
9395:         std::string redirectedCout;
9396:         std::string redirectedCerr;
9397: 
9398:         auto const& testInfo = testCase.getTestCaseInfo();
9399: 
9400:         m_reporter->testCaseStarting(testInfo);
9401: 
9402:         m_activeTestCase = &testCase;
9403: 
9404:         ITracker& rootTracker = m_trackerContext.startRun();
9405:         assert(rootTracker.isSectionTracker());
9406:         static_cast<SectionTracker&>(rootTracker).addInitialFilters(m_config->getSectionsToRun());
9407:         do {
9408:             m_trackerContext.startCycle();
9409:             m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));
9410:             runCurrentTest(redirectedCout, redirectedCerr);
9411:         } while (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());
9412: 
9413:         Totals deltaTotals = m_totals.delta(prevTotals);
9414:         if (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) {
9415:             deltaTotals.assertions.failed++;
9416:             deltaTotals.testCases.passed--;
9417:             deltaTotals.testCases.failed++;
9418:         }
9419:         m_totals.testCases += deltaTotals.testCases;
9420:         m_reporter->testCaseEnded(TestCaseStats(testInfo,
9421:                                   deltaTotals,
9422:                                   redirectedCout,
9423:                                   redirectedCerr,
9424:                                   aborting()));
9425: 
9426:         m_activeTestCase = nullptr;
9427:         m_testCaseTracker = nullptr;
9428: 
9429:         return deltaTotals;
9430:     }
9431: 
9432:     IConfigPtr RunContext::config() const {
9433:         return m_config;
9434:     }
9435: 
9436:     IStreamingReporter& RunContext::reporter() const {
9437:         return *m_reporter;
9438:     }
9439: 
9440:     void RunContext::assertionEnded(AssertionResult const & result) {
9441:         if (result.getResultType() == ResultWas::Ok) {
9442:             m_totals.assertions.passed++;
9443:             m_lastAssertionPassed = true;
9444:         } else if (!result.isOk()) {
9445:             m_lastAssertionPassed = false;
9446:             if( m_activeTestCase->getTestCaseInfo().okToFail() )
9447:                 m_totals.assertions.failedButOk++;
9448:             else
9449:                 m_totals.assertions.failed++;
9450:         }
9451:         else {
9452:             m_lastAssertionPassed = true;
9453:         }
9454: 
9455:         // We have no use for the return value (whether messages should be cleared), because messages were made scoped
9456:         // and should be let to clear themselves out.
9457:         static_cast<void>(m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)));
9458: 
9459:         // Reset working state
9460:         resetAssertionInfo();
9461:         m_lastResult = result;
9462:     }
9463:     void RunContext::resetAssertionInfo() {
9464:         m_lastAssertionInfo.macroName = StringRef();
9465:         m_lastAssertionInfo.capturedExpression = "{Unknown expression after the reported line}"_sr;
9466:     }
9467: 
9468:     bool RunContext::sectionStarted(SectionInfo const & sectionInfo, Counts & assertions) {
9469:         ITracker& sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));
9470:         if (!sectionTracker.isOpen())
9471:             return false;
9472:         m_activeSections.push_back(&sectionTracker);
9473: 
9474:         m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;
9475: 
9476:         m_reporter->sectionStarting(sectionInfo);
9477: 
9478:         assertions = m_totals.assertions;
9479: 
9480:         return true;
9481:     }
9482:     auto RunContext::acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& {
9483:         using namespace Generators;
9484:         GeneratorTracker& tracker = GeneratorTracker::acquire( m_trackerContext, TestCaseTracking::NameAndLocation( "generator", lineInfo ) );
9485:         assert( tracker.isOpen() );
9486:         m_lastAssertionInfo.lineInfo = lineInfo;
9487:         return tracker;
9488:     }
9489: 
9490:     bool RunContext::testForMissingAssertions(Counts& assertions) {
9491:         if (assertions.total() != 0)
9492:             return false;
9493:         if (!m_config->warnAboutMissingAssertions())
9494:             return false;
9495:         if (m_trackerContext.currentTracker().hasChildren())
9496:             return false;
9497:         m_totals.assertions.failed++;
9498:         assertions.failed++;
9499:         return true;
9500:     }
9501: 
9502:     void RunContext::sectionEnded(SectionEndInfo const & endInfo) {
9503:         Counts assertions = m_totals.assertions - endInfo.prevAssertions;
9504:         bool missingAssertions = testForMissingAssertions(assertions);
9505: 
9506:         if (!m_activeSections.empty()) {
9507:             m_activeSections.back()->close();
9508:             m_activeSections.pop_back();
9509:         }
9510: 
9511:         m_reporter->sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));
9512:         m_messages.clear();
9513:     }
9514: 
9515:     void RunContext::sectionEndedEarly(SectionEndInfo const & endInfo) {
9516:         if (m_unfinishedSections.empty())
9517:             m_activeSections.back()->fail();
9518:         else
9519:             m_activeSections.back()->close();
9520:         m_activeSections.pop_back();
9521: 
9522:         m_unfinishedSections.push_back(endInfo);
9523:     }
9524:     void RunContext::benchmarkStarting( BenchmarkInfo const& info ) {
9525:         m_reporter->benchmarkStarting( info );
9526:     }
9527:     void RunContext::benchmarkEnded( BenchmarkStats const& stats ) {
9528:         m_reporter->benchmarkEnded( stats );
9529:     }
9530: 
9531:     void RunContext::pushScopedMessage(MessageInfo const & message) {
9532:         m_messages.push_back(message);
9533:     }
9534: 
9535:     void RunContext::popScopedMessage(MessageInfo const & message) {
9536:         m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());
9537:     }
9538: 
9539:     std::string RunContext::getCurrentTestName() const {
9540:         return m_activeTestCase
9541:             ? m_activeTestCase->getTestCaseInfo().name
9542:             : std::string();
9543:     }
9544: 
9545:     const AssertionResult * RunContext::getLastResult() const {
9546:         return &(*m_lastResult);
9547:     }
9548: 
9549:     void RunContext::exceptionEarlyReported() {
9550:         m_shouldReportUnexpected = false;
9551:     }
9552: 
9553:     void RunContext::handleFatalErrorCondition( StringRef message ) {
9554:         // First notify reporter that bad things happened
9555:         m_reporter->fatalErrorEncountered(message);
9556: 
9557:         // Don't rebuild the result -- the stringification itself can cause more fatal errors
9558:         // Instead, fake a result data.
9559:         AssertionResultData tempResult( ResultWas::FatalErrorCondition, { false } );
9560:         tempResult.message = message;
9561:         AssertionResult result(m_lastAssertionInfo, tempResult);
9562: 
9563:         assertionEnded(result);
9564: 
9565:         handleUnfinishedSections();
9566: 
9567:         // Recreate section for test case (as we will lose the one that was in scope)
9568:         auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
9569:         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
9570: 
9571:         Counts assertions;
9572:         assertions.failed = 1;
9573:         SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);
9574:         m_reporter->sectionEnded(testCaseSectionStats);
9575: 
9576:         auto const& testInfo = m_activeTestCase->getTestCaseInfo();
9577: 
9578:         Totals deltaTotals;
9579:         deltaTotals.testCases.failed = 1;
9580:         deltaTotals.assertions.failed = 1;
9581:         m_reporter->testCaseEnded(TestCaseStats(testInfo,
9582:                                   deltaTotals,
9583:                                   std::string(),
9584:                                   std::string(),
9585:                                   false));
9586:         m_totals.testCases.failed++;
9587:         testGroupEnded(std::string(), m_totals, 1, 1);
9588:         m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, false));
9589:     }
9590: 
9591:     bool RunContext::lastAssertionPassed() {
9592:          return m_lastAssertionPassed;
9593:     }
9594: 
9595:     void RunContext::assertionPassed() {
9596:         m_lastAssertionPassed = true;
9597:         ++m_totals.assertions.passed;
9598:         resetAssertionInfo();
9599:     }
9600: 
9601:     bool RunContext::aborting() const {
9602:         return m_totals.assertions.failed == static_cast<std::size_t>(m_config->abortAfter());
9603:     }
9604: 
9605:     void RunContext::runCurrentTest(std::string & redirectedCout, std::string & redirectedCerr) {
9606:         auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
9607:         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
9608:         m_reporter->sectionStarting(testCaseSection);
9609:         Counts prevAssertions = m_totals.assertions;
9610:         double duration = 0;
9611:         m_shouldReportUnexpected = true;
9612:         m_lastAssertionInfo = { "TEST_CASE"_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal };
9613: 
9614:         seedRng(*m_config);
9615: 
9616:         Timer timer;
9617:         CATCH_TRY {
9618:             if (m_reporter->getPreferences().shouldRedirectStdOut) {
9619: #if !defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
9620:                 RedirectedStdOut redirectedStdOut;
9621:                 RedirectedStdErr redirectedStdErr;
9622: 
9623:                 timer.start();
9624:                 invokeActiveTestCase();
9625:                 redirectedCout += redirectedStdOut.str();
9626:                 redirectedCerr += redirectedStdErr.str();
9627: #else
9628:                 OutputRedirect r(redirectedCout, redirectedCerr);
9629:                 timer.start();
9630:                 invokeActiveTestCase();
9631: #endif
9632:             } else {
9633:                 timer.start();
9634:                 invokeActiveTestCase();
9635:             }
9636:             duration = timer.getElapsedSeconds();
9637:         } CATCH_CATCH_ANON (TestFailureException&) {
9638:             // This just means the test was aborted due to failure
9639:         } CATCH_CATCH_ALL {
9640:             // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions
9641:             // are reported without translation at the point of origin.
9642:             if( m_shouldReportUnexpected ) {
9643:                 AssertionReaction dummyReaction;
9644:                 handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );
9645:             }
9646:         }
9647:         Counts assertions = m_totals.assertions - prevAssertions;
9648:         bool missingAssertions = testForMissingAssertions(assertions);
9649: 
9650:         m_testCaseTracker->close();
9651:         handleUnfinishedSections();
9652:         m_messages.clear();
9653: 
9654:         SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);
9655:         m_reporter->sectionEnded(testCaseSectionStats);
9656:     }
9657: 
9658:     void RunContext::invokeActiveTestCase() {
9659:         FatalConditionHandler fatalConditionHandler; // Handle signals
9660:         m_activeTestCase->invoke();
9661:         fatalConditionHandler.reset();
9662:     }
9663: 
9664:     void RunContext::handleUnfinishedSections() {
9665:         // If sections ended prematurely due to an exception we stored their
9666:         // infos here so we can tear them down outside the unwind process.
9667:         for (auto it = m_unfinishedSections.rbegin(),
9668:              itEnd = m_unfinishedSections.rend();
9669:              it != itEnd;
9670:              ++it)
9671:             sectionEnded(*it);
9672:         m_unfinishedSections.clear();
9673:     }
9674: 
9675:     void RunContext::handleExpr(
9676:         AssertionInfo const& info,
9677:         ITransientExpression const& expr,
9678:         AssertionReaction& reaction
9679:     ) {
9680:         m_reporter->assertionStarting( info );
9681: 
9682:         bool negated = isFalseTest( info.resultDisposition );
9683:         bool result = expr.getResult() != negated;
9684: 
9685:         if( result ) {
9686:             if (!m_includeSuccessfulResults) {
9687:                 assertionPassed();
9688:             }
9689:             else {
9690:                 reportExpr(info, ResultWas::Ok, &expr, negated);
9691:             }
9692:         }
9693:         else {
9694:             reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );
9695:             populateReaction( reaction );
9696:         }
9697:     }
9698:     void RunContext::reportExpr(
9699:             AssertionInfo const &info,
9700:             ResultWas::OfType resultType,
9701:             ITransientExpression const *expr,
9702:             bool negated ) {
9703: 
9704:         m_lastAssertionInfo = info;
9705:         AssertionResultData data( resultType, LazyExpression( negated ) );
9706: 
9707:         AssertionResult assertionResult{ info, data };
9708:         assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;
9709: 
9710:         assertionEnded( assertionResult );
9711:     }
9712: 
9713:     void RunContext::handleMessage(
9714:             AssertionInfo const& info,
9715:             ResultWas::OfType resultType,
9716:             StringRef const& message,
9717:             AssertionReaction& reaction
9718:     ) {
9719:         m_reporter->assertionStarting( info );
9720: 
9721:         m_lastAssertionInfo = info;
9722: 
9723:         AssertionResultData data( resultType, LazyExpression( false ) );
9724:         data.message = message;
9725:         AssertionResult assertionResult{ m_lastAssertionInfo, data };
9726:         assertionEnded( assertionResult );
9727:         if( !assertionResult.isOk() )
9728:             populateReaction( reaction );
9729:     }
9730:     void RunContext::handleUnexpectedExceptionNotThrown(
9731:             AssertionInfo const& info,
9732:             AssertionReaction& reaction
9733:     ) {
9734:         handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);
9735:     }
9736: 
9737:     void RunContext::handleUnexpectedInflightException(
9738:             AssertionInfo const& info,
9739:             std::string const& message,
9740:             AssertionReaction& reaction
9741:     ) {
9742:         m_lastAssertionInfo = info;
9743: 
9744:         AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
9745:         data.message = message;
9746:         AssertionResult assertionResult{ info, data };
9747:         assertionEnded( assertionResult );
9748:         populateReaction( reaction );
9749:     }
9750: 
9751:     void RunContext::populateReaction( AssertionReaction& reaction ) {
9752:         reaction.shouldDebugBreak = m_config->shouldDebugBreak();
9753:         reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition & ResultDisposition::Normal);
9754:     }
9755: 
9756:     void RunContext::handleIncomplete(
9757:             AssertionInfo const& info
9758:     ) {
9759:         m_lastAssertionInfo = info;
9760: 
9761:         AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
9762:         data.message = "Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE";
9763:         AssertionResult assertionResult{ info, data };
9764:         assertionEnded( assertionResult );
9765:     }
9766:     void RunContext::handleNonExpr(
9767:             AssertionInfo const &info,
9768:             ResultWas::OfType resultType,
9769:             AssertionReaction &reaction
9770:     ) {
9771:         m_lastAssertionInfo = info;
9772: 
9773:         AssertionResultData data( resultType, LazyExpression( false ) );
9774:         AssertionResult assertionResult{ info, data };
9775:         assertionEnded( assertionResult );
9776: 
9777:         if( !assertionResult.isOk() )
9778:             populateReaction( reaction );
9779:     }
9780: 
9781:     IResultCapture& getResultCapture() {
9782:         if (auto* capture = getCurrentContext().getResultCapture())
9783:             return *capture;
9784:         else
9785:             CATCH_INTERNAL_ERROR("No result capture instance");
9786:     }
9787: }
9788: // end catch_run_context.cpp
9789: // start catch_section.cpp
9790: 
9791: namespace Catch {
9792: 
9793:     Section::Section( SectionInfo const& info )
9794:     :   m_info( info ),
9795:         m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )
9796:     {
9797:         m_timer.start();
9798:     }
9799: 
9800:     Section::~Section() {
9801:         if( m_sectionIncluded ) {
9802:             SectionEndInfo endInfo{ m_info, m_assertions, m_timer.getElapsedSeconds() };
9803:             if( uncaught_exceptions() )
9804:                 getResultCapture().sectionEndedEarly( endInfo );
9805:             else
9806:                 getResultCapture().sectionEnded( endInfo );
9807:         }
9808:     }
9809: 
9810:     // This indicates whether the section should be executed or not
9811:     Section::operator bool() const {
9812:         return m_sectionIncluded;
9813:     }
9814: 
9815: } // end namespace Catch
9816: // end catch_section.cpp
9817: // start catch_section_info.cpp
9818: 
9819: namespace Catch {
9820: 
9821:     SectionInfo::SectionInfo
9822:         (   SourceLineInfo const& _lineInfo,
9823:             std::string const& _name )
9824:     :   name( _name ),
9825:         lineInfo( _lineInfo )
9826:     {}
9827: 
9828: } // end namespace Catch
9829: // end catch_section_info.cpp
9830: // start catch_session.cpp
9831: 
9832: // start catch_session.h
9833: 
9834: #include <memory>
9835: 
9836: namespace Catch {
9837: 
9838:     class Session : NonCopyable {
9839:     public:
9840: 
9841:         Session();
9842:         ~Session() override;
9843: 
9844:         void showHelp() const;
9845:         void libIdentify();
9846: 
9847:         int applyCommandLine( int argc, char const * const * argv );
9848: 
9849:         void useConfigData( ConfigData const& configData );
9850: 
9851:         int run( int argc, char* argv[] );
9852:     #if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(UNICODE)
9853:         int run( int argc, wchar_t* const argv[] );
9854:     #endif
9855:         int run();
9856: 
9857:         clara::Parser const& cli() const;
9858:         void cli( clara::Parser const& newParser );
9859:         ConfigData& configData();
9860:         Config& config();
9861:     private:
9862:         int runInternal();
9863: 
9864:         clara::Parser m_cli;
9865:         ConfigData m_configData;
9866:         std::shared_ptr<Config> m_config;
9867:         bool m_startupExceptions = false;
9868:     };
9869: 
9870: } // end namespace Catch
9871: 
9872: // end catch_session.h
9873: // start catch_version.h
9874: 
9875: #include <iosfwd>
9876: 
9877: namespace Catch {
9878: 
9879:     // Versioning information
9880:     struct Version {
9881:         Version( Version const& ) = delete;
9882:         Version& operator=( Version const& ) = delete;
9883:         Version(    unsigned int _majorVersion,
9884:                     unsigned int _minorVersion,
9885:                     unsigned int _patchNumber,
9886:                     char const * const _branchName,
9887:                     unsigned int _buildNumber );
9888: 
9889:         unsigned int const majorVersion;
9890:         unsigned int const minorVersion;
9891:         unsigned int const patchNumber;
9892: 
9893:         // buildNumber is only used if branchName is not null
9894:         char const * const branchName;
9895:         unsigned int const buildNumber;
9896: 
9897:         friend std::ostream& operator << ( std::ostream& os, Version const& version );
9898:     };
9899: 
9900:     Version const& libraryVersion();
9901: }
9902: 
9903: // end catch_version.h
9904: #include <cstdlib>
9905: #include <iomanip>
9906: #include <iostream>
9907: 
9908: namespace Catch {
9909: 
9910:     namespace {
9911:         const int MaxExitCode = 255;
9912: 
9913:         IStreamingReporterPtr createReporter(std::string const& reporterName, IConfigPtr const& config) {
9914:             auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);
9915:             CATCH_ENFORCE(reporter, "No reporter registered with name: '" << reporterName << "'");
9916: 
9917:             return reporter;
9918:         }
9919: 
9920:         IStreamingReporterPtr makeReporter(std::shared_ptr<Config> const& config) {
9921:             if (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) {
9922:                 return createReporter(config->getReporterName(), config);
9923:             }
9924: 
9925:             auto multi = std::unique_ptr<ListeningReporter>(new ListeningReporter);
9926: 
9927:             auto const& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();
9928:             for (auto const& listener : listeners) {
9929:                 multi->addListener(listener->create(Catch::ReporterConfig(config)));
9930:             }
9931:             multi->addReporter(createReporter(config->getReporterName(), config));
9932:             return std::move(multi);
9933:         }
9934: 
9935:         void renderTestProgress(int current_test, int total_tests, std::string next_test) {
9936:             double progress = (double) current_test / (double) total_tests;
9937:             int render_width = 80;
9938:             std::string result = "[" + std::to_string(current_test) + "/" + std::to_string(total_tests) + "] (" + std::to_string(int(progress * 100)) + "%): " + next_test;
9939:             if (result.size() < render_width) {
9940:                 result += std::string(render_width - result.size(), ' ');
9941:             } else if (result.size() > render_width) {
9942:                 result = result.substr(0, render_width - 3) + "...";
9943:             }
9944:             std::cout << "\r" << result;
9945:             std::cout.flush();
9946:         }
9947: 
9948:         Catch::Totals runTests(std::shared_ptr<Config> const& config) {
9949:             // FixMe: Add listeners in order first, then add reporters.
9950: 
9951:             auto reporter = makeReporter(config);
9952: 
9953:             RunContext context(config, std::move(reporter));
9954: 
9955:             Totals totals;
9956: 
9957:             context.testGroupStarting(config->name(), 1, 1);
9958: 
9959:             TestSpec testSpec = config->testSpec();
9960: 
9961:             auto const& allTestCases = getAllTestCasesSorted(*config);
9962:             int total_tests_run = 0, current_test = 0;
9963:             for (auto const& testCase : allTestCases) {
9964:                 if (matchTest(testCase, testSpec, *config)) {
9965:                     total_tests_run++;
9966:                 }
9967:             }
9968:             for (auto const& testCase : allTestCases) {
9969:                 if (!context.aborting() && matchTest(testCase, testSpec, *config)) {
9970:                     renderTestProgress(current_test, total_tests_run, testCase.name);
9971:                     totals += context.runTest(testCase);
9972:                     current_test++;
9973:                     if (current_test == total_tests_run) {
9974:                         renderTestProgress(current_test, total_tests_run, testCase.name);
9975:                         std::cout << std::endl;
9976:                     }
9977:                 } else {
9978:                     context.reporter().skipTest(testCase);
9979:                 }
9980:             }
9981: 
9982:             if (config->warnAboutNoTests() && totals.testCases.total() == 0) {
9983:                 ReusableStringStream testConfig;
9984: 
9985:                 bool first = true;
9986:                 for (const auto& input : config->getTestsOrTags()) {
9987:                     if (!first) { testConfig << ' '; }
9988:                     first = false;
9989:                     testConfig << input;
9990:                 }
9991: 
9992:                 context.reporter().noMatchingTestCases(testConfig.str());
9993:                 totals.error = -1;
9994:             }
9995: 
9996:             context.testGroupEnded(config->name(), totals, 1, 1);
9997:             return totals;
9998:         }
9999: 
10000:         void applyFilenamesAsTags(Catch::IConfig const& config) {
10001:             auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));
10002:             for (auto& testCase : tests) {
10003:                 auto tags = testCase.tags;
10004: 
10005:                 std::string filename = testCase.lineInfo.file;
10006:                 auto lastSlash = filename.find_last_of("\\/");
10007:                 if (lastSlash != std::string::npos) {
10008:                     filename.erase(0, lastSlash);
10009:                     filename[0] = '#';
10010:                 }
10011: 
10012:                 auto lastDot = filename.find_last_of('.');
10013:                 if (lastDot != std::string::npos) {
10014:                     filename.erase(lastDot);
10015:                 }
10016: 
10017:                 tags.push_back(std::move(filename));
10018:                 setTags(testCase, tags);
10019:             }
10020:         }
10021: 
10022:     } // anon namespace
10023: 
10024:     Session::Session() {
10025:         static bool alreadyInstantiated = false;
10026:         if( alreadyInstantiated ) {
10027:             CATCH_TRY { CATCH_INTERNAL_ERROR( "Only one instance of Catch::Session can ever be used" ); }
10028:             CATCH_CATCH_ALL { getMutableRegistryHub().registerStartupException(); }
10029:         }
10030: 
10031:         // There cannot be exceptions at startup in no-exception mode.
10032: #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10033:         const auto& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();
10034:         if ( !exceptions.empty() ) {
10035:             m_startupExceptions = true;
10036:             Colour colourGuard( Colour::Red );
10037:             Catch::cerr() << "Errors occurred during startup!" << '\n';
10038:             // iterate over all exceptions and notify user
10039:             for ( const auto& ex_ptr : exceptions ) {
10040:                 try {
10041:                     std::rethrow_exception(ex_ptr);
10042:                 } catch ( std::exception const& ex ) {
10043:                     Catch::cerr() << Column( ex.what() ).indent(2) << '\n';
10044:                 }
10045:             }
10046:         }
10047: #endif
10048: 
10049:         alreadyInstantiated = true;
10050:         m_cli = makeCommandLineParser( m_configData );
10051:     }
10052:     Session::~Session() {
10053:         Catch::cleanUp();
10054:     }
10055: 
10056:     void Session::showHelp() const {
10057:         Catch::cout()
10058:                 << "\nCatch v" << libraryVersion() << "\n"
10059:                 << m_cli << std::endl
10060:                 << "For more detailed usage please see the project docs\n" << std::endl;
10061:     }
10062:     void Session::libIdentify() {
10063:         Catch::cout()
10064:                 << std::left << std::setw(16) << "description: " << "A Catch test executable\n"
10065:                 << std::left << std::setw(16) << "category: " << "testframework\n"
10066:                 << std::left << std::setw(16) << "framework: " << "Catch Test\n"
10067:                 << std::left << std::setw(16) << "version: " << libraryVersion() << std::endl;
10068:     }
10069: 
10070:     int Session::applyCommandLine( int argc, char const * const * argv ) {
10071:         if( m_startupExceptions )
10072:             return 1;
10073: 
10074:         auto result = m_cli.parse( clara::Args( argc, argv ) );
10075:         if( !result ) {
10076:             Catch::cerr()
10077:                 << Colour( Colour::Red )
10078:                 << "\nError(s) in input:\n"
10079:                 << Column( result.errorMessage() ).indent( 2 )
10080:                 << "\n\n";
10081:             Catch::cerr() << "Run with -? for usage\n" << std::endl;
10082:             return MaxExitCode;
10083:         }
10084: 
10085:         if( m_configData.showHelp )
10086:             showHelp();
10087:         if( m_configData.libIdentify )
10088:             libIdentify();
10089:         m_config.reset();
10090:         return 0;
10091:     }
10092: 
10093:     void Session::useConfigData( ConfigData const& configData ) {
10094:         m_configData = configData;
10095:         m_config.reset();
10096:     }
10097: 
10098:     int Session::run( int argc, char* argv[] ) {
10099:         if( m_startupExceptions )
10100:             return 1;
10101:         int returnCode = applyCommandLine( argc, argv );
10102:         if( returnCode == 0 )
10103:             returnCode = run();
10104:         return returnCode;
10105:     }
10106: 
10107: #if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(UNICODE)
10108:     int Session::run( int argc, wchar_t* const argv[] ) {
10109: 
10110:         char **utf8Argv = new char *[ argc ];
10111: 
10112:         for ( int i = 0; i < argc; ++i ) {
10113:             int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, NULL, 0, NULL, NULL );
10114: 
10115:             utf8Argv[ i ] = new char[ bufSize ];
10116: 
10117:             WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, NULL, NULL );
10118:         }
10119: 
10120:         int returnCode = run( argc, utf8Argv );
10121: 
10122:         for ( int i = 0; i < argc; ++i )
10123:             delete [] utf8Argv[ i ];
10124: 
10125:         delete [] utf8Argv;
10126: 
10127:         return returnCode;
10128:     }
10129: #endif
10130:     int Session::run() {
10131:         if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) {
10132:             Catch::cout() << "...waiting for enter/ return before starting" << std::endl;
10133:             static_cast<void>(std::getchar());
10134:         }
10135:         int exitCode = runInternal();
10136:         if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) {
10137:             Catch::cout() << "...waiting for enter/ return before exiting, with code: " << exitCode << std::endl;
10138:             static_cast<void>(std::getchar());
10139:         }
10140:         return exitCode;
10141:     }
10142: 
10143:     clara::Parser const& Session::cli() const {
10144:         return m_cli;
10145:     }
10146:     void Session::cli( clara::Parser const& newParser ) {
10147:         m_cli = newParser;
10148:     }
10149:     ConfigData& Session::configData() {
10150:         return m_configData;
10151:     }
10152:     Config& Session::config() {
10153:         if( !m_config )
10154:             m_config = std::make_shared<Config>( m_configData );
10155:         return *m_config;
10156:     }
10157: 
10158:     int Session::runInternal() {
10159:         if( m_startupExceptions )
10160:             return 1;
10161: 
10162:         if (m_configData.showHelp || m_configData.libIdentify) {
10163:             return 0;
10164:         }
10165: 
10166:         CATCH_TRY {
10167:             config(); // Force config to be constructed
10168: 
10169:             seedRng( *m_config );
10170: 
10171:             if( m_configData.filenamesAsTags )
10172:                 applyFilenamesAsTags( *m_config );
10173: 
10174:             // Handle list request
10175:             if( Option<std::size_t> listed = list( config() ) )
10176:                 return static_cast<int>( *listed );
10177: 
10178:             auto totals = runTests( m_config );
10179:             // Note that on unices only the lower 8 bits are usually used, clamping
10180:             // the return value to 255 prevents false negative when some multiple
10181:             // of 256 tests has failed
10182:             return (std::min) (MaxExitCode, (std::max) (totals.error, static_cast<int>(totals.assertions.failed)));
10183:         }
10184: #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
10185:         catch( std::exception& ex ) {
10186:             Catch::cerr() << ex.what() << std::endl;
10187:             return MaxExitCode;
10188:         }
10189: #endif
10190:     }
10191: 
10192: } // end namespace Catch
10193: // end catch_session.cpp
10194: // start catch_singletons.cpp
10195: 
10196: #include <vector>
10197: 
10198: namespace Catch {
10199: 
10200:     namespace {
10201:         static auto getSingletons() -> std::vector<ISingleton*>*& {
10202:             static std::vector<ISingleton*>* g_singletons = nullptr;
10203:             if( !g_singletons )
10204:                 g_singletons = new std::vector<ISingleton*>();
10205:             return g_singletons;
10206:         }
10207:     }
10208: 
10209:     ISingleton::~ISingleton() {}
10210: 
10211:     void addSingleton(ISingleton* singleton ) {
10212:         getSingletons()->push_back( singleton );
10213:     }
10214:     void cleanupSingletons() {
10215:         auto& singletons = getSingletons();
10216:         for( auto singleton : *singletons )
10217:             delete singleton;
10218:         delete singletons;
10219:         singletons = nullptr;
10220:     }
10221: 
10222: } // namespace Catch
10223: // end catch_singletons.cpp
10224: // start catch_startup_exception_registry.cpp
10225: 
10226: namespace Catch {
10227: void StartupExceptionRegistry::add( std::exception_ptr const& exception ) noexcept {
10228:         CATCH_TRY {
10229:             m_exceptions.push_back(exception);
10230:         } CATCH_CATCH_ALL {
10231:             // If we run out of memory during start-up there's really not a lot more we can do about it
10232:             std::terminate();
10233:         }
10234:     }
10235: 
10236:     std::vector<std::exception_ptr> const& StartupExceptionRegistry::getExceptions() const noexcept {
10237:         return m_exceptions;
10238:     }
10239: 
10240: } // end namespace Catch
10241: // end catch_startup_exception_registry.cpp
10242: // start catch_stream.cpp
10243: 
10244: #include <cstdio>
10245: #include <iostream>
10246: #include <fstream>
10247: #include <sstream>
10248: #include <vector>
10249: #include <memory>
10250: 
10251: namespace Catch {
10252: 
10253:     Catch::IStream::~IStream() = default;
10254: 
10255:     namespace detail { namespace {
10256:         template<typename WriterF, std::size_t bufferSize=256>
10257:         class StreamBufImpl : public std::streambuf {
10258:             char data[bufferSize];
10259:             WriterF m_writer;
10260: 
10261:         public:
10262:             StreamBufImpl() {
10263:                 setp( data, data + sizeof(data) );
10264:             }
10265: 
10266:             ~StreamBufImpl() noexcept {
10267:                 StreamBufImpl::sync();
10268:             }
10269: 
10270:         private:
10271:             int overflow( int c ) override {
10272:                 sync();
10273: 
10274:                 if( c != EOF ) {
10275:                     if( pbase() == epptr() )
10276:                         m_writer( std::string( 1, static_cast<char>( c ) ) );
10277:                     else
10278:                         sputc( static_cast<char>( c ) );
10279:                 }
10280:                 return 0;
10281:             }
10282: 
10283:             int sync() override {
10284:                 if( pbase() != pptr() ) {
10285:                     m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );
10286:                     setp( pbase(), epptr() );
10287:                 }
10288:                 return 0;
10289:             }
10290:         };
10291: 
10292:         ///////////////////////////////////////////////////////////////////////////
10293: 
10294:         struct OutputDebugWriter {
10295: 
10296:             void operator()( std::string const&str ) {
10297:                 writeToDebugConsole( str );
10298:             }
10299:         };
10300: 
10301:         ///////////////////////////////////////////////////////////////////////////
10302: 
10303:         class FileStream : public IStream {
10304:             mutable std::ofstream m_ofs;
10305:         public:
10306:             FileStream( StringRef filename ) {
10307:                 m_ofs.open( filename.c_str() );
10308:                 CATCH_ENFORCE( !m_ofs.fail(), "Unable to open file: '" << filename << "'" );
10309:             }
10310:             ~FileStream() override = default;
10311:         public: // IStream
10312:             std::ostream& stream() const override {
10313:                 return m_ofs;
10314:             }
10315:         };
10316: 
10317:         ///////////////////////////////////////////////////////////////////////////
10318: 
10319:         class CoutStream : public IStream {
10320:             mutable std::ostream m_os;
10321:         public:
10322:             // Store the streambuf from cout up-front because
10323:             // cout may get redirected when running tests
10324:             CoutStream() : m_os( Catch::cout().rdbuf() ) {}
10325:             ~CoutStream() override = default;
10326: 
10327:         public: // IStream
10328:             std::ostream& stream() const override { return m_os; }
10329:         };
10330: 
10331:         ///////////////////////////////////////////////////////////////////////////
10332: 
10333:         class DebugOutStream : public IStream {
10334:             std::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;
10335:             mutable std::ostream m_os;
10336:         public:
10337:             DebugOutStream()
10338:             :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),
10339:                 m_os( m_streamBuf.get() )
10340:             {}
10341: 
10342:             ~DebugOutStream() override = default;
10343: 
10344:         public: // IStream
10345:             std::ostream& stream() const override { return m_os; }
10346:         };
10347: 
10348:     }} // namespace anon::detail
10349: 
10350:     ///////////////////////////////////////////////////////////////////////////
10351: 
10352:     auto makeStream( StringRef const &filename ) -> IStream const* {
10353:         if( filename.empty() )
10354:             return new detail::CoutStream();
10355:         else if( filename[0] == '%' ) {
10356:             if( filename == "%debug" )
10357:                 return new detail::DebugOutStream();
10358:             else
10359:                 CATCH_ERROR( "Unrecognised stream: '" << filename << "'" );
10360:         }
10361:         else
10362:             return new detail::FileStream( filename );
10363:     }
10364: 
10365:     // This class encapsulates the idea of a pool of ostringstreams that can be reused.
10366:     struct StringStreams {
10367:         std::vector<std::unique_ptr<std::ostringstream>> m_streams;
10368:         std::vector<std::size_t> m_unused;
10369:         std::ostringstream m_referenceStream; // Used for copy state/ flags from
10370: 
10371:         auto add() -> std::size_t {
10372:             if( m_unused.empty() ) {
10373:                 m_streams.push_back( std::unique_ptr<std::ostringstream>( new std::ostringstream ) );
10374:                 return m_streams.size()-1;
10375:             }
10376:             else {
10377:                 auto index = m_unused.back();
10378:                 m_unused.pop_back();
10379:                 return index;
10380:             }
10381:         }
10382: 
10383:         void release( std::size_t index ) {
10384:             m_streams[index]->copyfmt( m_referenceStream ); // Restore initial flags and other state
10385:             m_unused.push_back(index);
10386:         }
10387:     };
10388: 
10389:     ReusableStringStream::ReusableStringStream()
10390:     :   m_index( Singleton<StringStreams>::getMutable().add() ),
10391:         m_oss( Singleton<StringStreams>::getMutable().m_streams[m_index].get() )
10392:     {}
10393: 
10394:     ReusableStringStream::~ReusableStringStream() {
10395:         static_cast<std::ostringstream*>( m_oss )->str("");
10396:         m_oss->clear();
10397:         Singleton<StringStreams>::getMutable().release( m_index );
10398:     }
10399: 
10400:     auto ReusableStringStream::str() const -> std::string {
10401:         return static_cast<std::ostringstream*>( m_oss )->str();
10402:     }
10403: 
10404:     ///////////////////////////////////////////////////////////////////////////
10405: 
10406: #ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement these functions
10407:     std::ostream& cout() { return std::cout; }
10408:     std::ostream& cerr() { return std::cerr; }
10409:     std::ostream& clog() { return std::clog; }
10410: #endif
10411: }
10412: // end catch_stream.cpp
10413: // start catch_string_manip.cpp
10414: 
10415: #include <algorithm>
10416: #include <ostream>
10417: #include <cstring>
10418: #include <cctype>
10419: 
10420: namespace Catch {
10421: 
10422:     namespace {
10423:         char toLowerCh(char c) {
10424:             return static_cast<char>( std::tolower( c ) );
10425:         }
10426:     }
10427: 
10428:     bool startsWith( std::string const& s, std::string const& prefix ) {
10429:         return s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());
10430:     }
10431:     bool startsWith( std::string const& s, char prefix ) {
10432:         return !s.empty() && s[0] == prefix;
10433:     }
10434:     bool endsWith( std::string const& s, std::string const& suffix ) {
10435:         return s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
10436:     }
10437:     bool endsWith( std::string const& s, char suffix ) {
10438:         return !s.empty() && s[s.size()-1] == suffix;
10439:     }
10440:     bool contains( std::string const& s, std::string const& infix ) {
10441:         return s.find( infix ) != std::string::npos;
10442:     }
10443:     void toLowerInPlace( std::string& s ) {
10444:         std::transform( s.begin(), s.end(), s.begin(), toLowerCh );
10445:     }
10446:     std::string toLower( std::string const& s ) {
10447:         std::string lc = s;
10448:         toLowerInPlace( lc );
10449:         return lc;
10450:     }
10451:     std::string trim( std::string const& str ) {
10452:         static char const* whitespaceChars = "\n\r\t ";
10453:         std::string::size_type start = str.find_first_not_of( whitespaceChars );
10454:         std::string::size_type end = str.find_last_not_of( whitespaceChars );
10455: 
10456:         return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();
10457:     }
10458: 
10459:     bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {
10460:         bool replaced = false;
10461:         std::size_t i = str.find( replaceThis );
10462:         while( i != std::string::npos ) {
10463:             replaced = true;
10464:             str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
10465:             if( i < str.size()-withThis.size() )
10466:                 i = str.find( replaceThis, i+withThis.size() );
10467:             else
10468:                 i = std::string::npos;
10469:         }
10470:         return replaced;
10471:     }
10472: 
10473:     pluralise::pluralise( std::size_t count, std::string const& label )
10474:     :   m_count( count ),
10475:         m_label( label )
10476:     {}
10477: 
10478:     std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {
10479:         os << pluraliser.m_count << ' ' << pluraliser.m_label;
10480:         if( pluraliser.m_count != 1 )
10481:             os << 's';
10482:         return os;
10483:     }
10484: 
10485: }
10486: // end catch_string_manip.cpp
10487: // start catch_stringref.cpp
10488: 
10489: #if defined(__clang__)
10490: #    pragma clang diagnostic push
10491: #    pragma clang diagnostic ignored "-Wexit-time-destructors"
10492: #endif
10493: 
10494: #include <ostream>
10495: #include <cstring>
10496: #include <cstdint>
10497: 
10498: namespace {
10499:     const uint32_t byte_2_lead = 0xC0;
10500:     const uint32_t byte_3_lead = 0xE0;
10501:     const uint32_t byte_4_lead = 0xF0;
10502: }
10503: 
10504: namespace Catch {
10505:     StringRef::StringRef( char const* rawChars ) noexcept
10506:     : StringRef( rawChars, static_cast<StringRef::size_type>(std::strlen(rawChars) ) )
10507:     {}
10508: 
10509:     StringRef::operator std::string() const {
10510:         return std::string( m_start, m_size );
10511:     }
10512: 
10513:     void StringRef::swap( StringRef& other ) noexcept {
10514:         std::swap( m_start, other.m_start );
10515:         std::swap( m_size, other.m_size );
10516:         std::swap( m_data, other.m_data );
10517:     }
10518: 
10519:     auto StringRef::c_str() const -> char const* {
10520:         if( isSubstring() )
10521:            const_cast<StringRef*>( this )->takeOwnership();
10522:         return m_start;
10523:     }
10524:     auto StringRef::currentData() const noexcept -> char const* {
10525:         return m_start;
10526:     }
10527: 
10528:     auto StringRef::isOwned() const noexcept -> bool {
10529:         return m_data != nullptr;
10530:     }
10531:     auto StringRef::isSubstring() const noexcept -> bool {
10532:         return m_start[m_size] != '\0';
10533:     }
10534: 
10535:     void StringRef::takeOwnership() {
10536:         if( !isOwned() ) {
10537:             m_data = new char[m_size+1];
10538:             memcpy( m_data, m_start, m_size );
10539:             m_data[m_size] = '\0';
10540:             m_start = m_data;
10541:         }
10542:     }
10543:     auto StringRef::substr( size_type start, size_type size ) const noexcept -> StringRef {
10544:         if( start < m_size )
10545:             return StringRef( m_start+start, size );
10546:         else
10547:             return StringRef();
10548:     }
10549:     auto StringRef::operator == ( StringRef const& other ) const noexcept -> bool {
10550:         return
10551:             size() == other.size() &&
10552:             (std::strncmp( m_start, other.m_start, size() ) == 0);
10553:     }
10554:     auto StringRef::operator != ( StringRef const& other ) const noexcept -> bool {
10555:         return !operator==( other );
10556:     }
10557: 
10558:     auto StringRef::operator[](size_type index) const noexcept -> char {
10559:         return m_start[index];
10560:     }
10561: 
10562:     auto StringRef::numberOfCharacters() const noexcept -> size_type {
10563:         size_type noChars = m_size;
10564:         // Make adjustments for uft encodings
10565:         for( size_type i=0; i < m_size; ++i ) {
10566:             char c = m_start[i];
10567:             if( ( c & byte_2_lead ) == byte_2_lead ) {
10568:                 noChars--;
10569:                 if (( c & byte_3_lead ) == byte_3_lead )
10570:                     noChars--;
10571:                 if( ( c & byte_4_lead ) == byte_4_lead )
10572:                     noChars--;
10573:             }
10574:         }
10575:         return noChars;
10576:     }
10577: 
10578:     auto operator + ( StringRef const& lhs, StringRef const& rhs ) -> std::string {
10579:         std::string str;
10580:         str.reserve( lhs.size() + rhs.size() );
10581:         str += lhs;
10582:         str += rhs;
10583:         return str;
10584:     }
10585:     auto operator + ( StringRef const& lhs, const char* rhs ) -> std::string {
10586:         return std::string( lhs ) + std::string( rhs );
10587:     }
10588:     auto operator + ( char const* lhs, StringRef const& rhs ) -> std::string {
10589:         return std::string( lhs ) + std::string( rhs );
10590:     }
10591: 
10592:     auto operator << ( std::ostream& os, StringRef const& str ) -> std::ostream& {
10593:         return os.write(str.currentData(), str.size());
10594:     }
10595: 
10596:     auto operator+=( std::string& lhs, StringRef const& rhs ) -> std::string& {
10597:         lhs.append(rhs.currentData(), rhs.size());
10598:         return lhs;
10599:     }
10600: 
10601: } // namespace Catch
10602: 
10603: #if defined(__clang__)
10604: #    pragma clang diagnostic pop
10605: #endif
10606: // end catch_stringref.cpp
10607: // start catch_tag_alias.cpp
10608: 
10609: namespace Catch {
10610:     TagAlias::TagAlias(std::string const & _tag, SourceLineInfo _lineInfo): tag(_tag), lineInfo(_lineInfo) {}
10611: }
10612: // end catch_tag_alias.cpp
10613: // start catch_tag_alias_autoregistrar.cpp
10614: 
10615: namespace Catch {
10616: 
10617:     RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const& lineInfo) {
10618:         CATCH_TRY {
10619:             getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);
10620:         } CATCH_CATCH_ALL {
10621:             // Do not throw when constructing global objects, instead register the exception to be processed later
10622:             getMutableRegistryHub().registerStartupException();
10623:         }
10624:     }
10625: 
10626: }
10627: // end catch_tag_alias_autoregistrar.cpp
10628: // start catch_tag_alias_registry.cpp
10629: 
10630: #include <sstream>
10631: 
10632: namespace Catch {
10633: 
10634:     TagAliasRegistry::~TagAliasRegistry() {}
10635: 
10636:     TagAlias const* TagAliasRegistry::find( std::string const& alias ) const {
10637:         auto it = m_registry.find( alias );
10638:         if( it != m_registry.end() )
10639:             return &(it->second);
10640:         else
10641:             return nullptr;
10642:     }
10643: 
10644:     std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {
10645:         std::string expandedTestSpec = unexpandedTestSpec;
10646:         for( auto const& registryKvp : m_registry ) {
10647:             std::size_t pos = expandedTestSpec.find( registryKvp.first );
10648:             if( pos != std::string::npos ) {
10649:                 expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
10650:                                     registryKvp.second.tag +
10651:                                     expandedTestSpec.substr( pos + registryKvp.first.size() );
10652:             }
10653:         }
10654:         return expandedTestSpec;
10655:     }
10656: 
10657:     void TagAliasRegistry::add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) {
10658:         CATCH_ENFORCE( startsWith(alias, "[@") && endsWith(alias, ']'),
10659:                       "error: tag alias, '" << alias << "' is not of the form [@alias name].\n" << lineInfo );
10660: 
10661:         CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,
10662:                       "error: tag alias, '" << alias << "' already registered.\n"
10663:                       << "\tFirst seen at: " << find(alias)->lineInfo << "\n"
10664:                       << "\tRedefined at: " << lineInfo );
10665:     }
10666: 
10667:     ITagAliasRegistry::~ITagAliasRegistry() {}
10668: 
10669:     ITagAliasRegistry const& ITagAliasRegistry::get() {
10670:         return getRegistryHub().getTagAliasRegistry();
10671:     }
10672: 
10673: } // end namespace Catch
10674: // end catch_tag_alias_registry.cpp
10675: // start catch_test_case_info.cpp
10676: 
10677: #include <cctype>
10678: #include <exception>
10679: #include <algorithm>
10680: #include <sstream>
10681: 
10682: namespace Catch {
10683: 
10684:     namespace {
10685:         TestCaseInfo::SpecialProperties parseSpecialTag( std::string const& tag ) {
10686:             if( startsWith( tag, '.' ) ||
10687:                 tag == "!hide" )
10688:                 return TestCaseInfo::IsHidden;
10689:             else if( tag == "!throws" )
10690:                 return TestCaseInfo::Throws;
10691:             else if( tag == "!shouldfail" )
10692:                 return TestCaseInfo::ShouldFail;
10693:             else if( tag == "!mayfail" )
10694:                 return TestCaseInfo::MayFail;
10695:             else if( tag == "!nonportable" )
10696:                 return TestCaseInfo::NonPortable;
10697:             else if( tag == "!benchmark" )
10698:                 return static_cast<TestCaseInfo::SpecialProperties>( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );
10699:             else
10700:                 return TestCaseInfo::None;
10701:         }
10702:         bool isReservedTag( std::string const& tag ) {
10703:             return parseSpecialTag( tag ) == TestCaseInfo::None && tag.size() > 0 && !std::isalnum( static_cast<unsigned char>(tag[0]) );
10704:         }
10705:         void enforceNotReservedTag( std::string const& tag, SourceLineInfo const& _lineInfo ) {
10706:             CATCH_ENFORCE( !isReservedTag(tag),
10707:                           "Tag name: [" << tag << "] is not allowed.\n"
10708:                           << "Tag names starting with non alpha-numeric characters are reserved\n"
10709:                           << _lineInfo );
10710:         }
10711:     }
10712: 
10713:     TestCase makeTestCase(  ITestInvoker* _testCase,
10714:                             std::string const& _className,
10715:                             NameAndTags const& nameAndTags,
10716:                             SourceLineInfo const& _lineInfo )
10717:     {
10718:         bool isHidden = false;
10719: 
10720:         // Parse out tags
10721:         std::vector<std::string> tags;
10722:         std::string desc, tag;
10723:         bool inTag = false;
10724:         std::string _descOrTags = nameAndTags.tags;
10725:         for (char c : _descOrTags) {
10726:             if( !inTag ) {
10727:                 if( c == '[' )
10728:                     inTag = true;
10729:                 else
10730:                     desc += c;
10731:             }
10732:             else {
10733:                 if( c == ']' ) {
10734:                     TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );
10735:                     if( ( prop & TestCaseInfo::IsHidden ) != 0 )
10736:                         isHidden = true;
10737:                     else if( prop == TestCaseInfo::None )
10738:                         enforceNotReservedTag( tag, _lineInfo );
10739: 
10740:                     tags.push_back( tag );
10741:                     tag.clear();
10742:                     inTag = false;
10743:                 }
10744:                 else
10745:                     tag += c;
10746:             }
10747:         }
10748:         if( isHidden ) {
10749:             tags.push_back( "." );
10750:         }
10751: 
10752:         TestCaseInfo info( nameAndTags.name, _className, desc, tags, _lineInfo );
10753:         return TestCase( _testCase, std::move(info) );
10754:     }
10755: 
10756:     void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags ) {
10757:         std::sort(begin(tags), end(tags));
10758:         tags.erase(std::unique(begin(tags), end(tags)), end(tags));
10759:         testCaseInfo.lcaseTags.clear();
10760: 
10761:         for( auto const& tag : tags ) {
10762:             std::string lcaseTag = toLower( tag );
10763:             testCaseInfo.properties = static_cast<TestCaseInfo::SpecialProperties>( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );
10764:             testCaseInfo.lcaseTags.push_back( lcaseTag );
10765:         }
10766:         testCaseInfo.tags = std::move(tags);
10767:     }
10768: 
10769:     TestCaseInfo::TestCaseInfo( std::string const& _name,
10770:                                 std::string const& _className,
10771:                                 std::string const& _description,
10772:                                 std::vector<std::string> const& _tags,
10773:                                 SourceLineInfo const& _lineInfo )
10774:     :   name( _name ),
10775:         className( _className ),
10776:         description( _description ),
10777:         lineInfo( _lineInfo ),
10778:         properties( None )
10779:     {
10780:         setTags( *this, _tags );
10781:     }
10782: 
10783:     bool TestCaseInfo::isHidden() const {
10784:         return ( properties & IsHidden ) != 0;
10785:     }
10786:     bool TestCaseInfo::throws() const {
10787:         return ( properties & Throws ) != 0;
10788:     }
10789:     bool TestCaseInfo::okToFail() const {
10790:         return ( properties & (ShouldFail | MayFail ) ) != 0;
10791:     }
10792:     bool TestCaseInfo::expectedToFail() const {
10793:         return ( properties & (ShouldFail ) ) != 0;
10794:     }
10795: 
10796:     std::string TestCaseInfo::tagsAsString() const {
10797:         std::string ret;
10798:         // '[' and ']' per tag
10799:         std::size_t full_size = 2 * tags.size();
10800:         for (const auto& tag : tags) {
10801:             full_size += tag.size();
10802:         }
10803:         ret.reserve(full_size);
10804:         for (const auto& tag : tags) {
10805:             ret.push_back('[');
10806:             ret.append(tag);
10807:             ret.push_back(']');
10808:         }
10809: 
10810:         return ret;
10811:     }
10812: 
10813:     TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo&& info ) : TestCaseInfo( std::move(info) ), test( testCase ) {}
10814: 
10815:     TestCase TestCase::withName( std::string const& _newName ) const {
10816:         TestCase other( *this );
10817:         other.name = _newName;
10818:         return other;
10819:     }
10820: 
10821:     void TestCase::invoke() const {
10822:         test->invoke();
10823:     }
10824: 
10825:     bool TestCase::operator == ( TestCase const& other ) const {
10826:         return  test.get() == other.test.get() &&
10827:                 name == other.name &&
10828:                 className == other.className;
10829:     }
10830: 
10831:     bool TestCase::operator < ( TestCase const& other ) const {
10832:         return name < other.name;
10833:     }
10834: 
10835:     TestCaseInfo const& TestCase::getTestCaseInfo() const
10836:     {
10837:         return *this;
10838:     }
10839: 
10840: } // end namespace Catch
10841: // end catch_test_case_info.cpp
10842: // start catch_test_case_registry_impl.cpp
10843: 
10844: #include <sstream>
10845: 
10846: namespace Catch {
10847: 
10848:     std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases ) {
10849: 
10850:         std::vector<TestCase> sorted = unsortedTestCases;
10851: 
10852:         switch( config.runOrder() ) {
10853:             case RunTests::InLexicographicalOrder:
10854:                 std::sort( sorted.begin(), sorted.end() );
10855:                 break;
10856:             case RunTests::InRandomOrder:
10857:                 seedRng( config );
10858:                 std::shuffle( sorted.begin(), sorted.end(), rng() );
10859:                 break;
10860:             case RunTests::InDeclarationOrder:
10861:                 // already in declaration order
10862:                 break;
10863:         }
10864:         return sorted;
10865:     }
10866:     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {
10867:         return testSpec.matches( testCase ) && ( config.allowThrows() || !testCase.throws() );
10868:     }
10869: 
10870:     void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {
10871:         std::set<TestCase> seenFunctions;
10872:         for( auto const& function : functions ) {
10873:             auto prev = seenFunctions.insert( function );
10874:             CATCH_ENFORCE( prev.second,
10875:                     "error: TEST_CASE( \"" << function.name << "\" ) already defined.\n"
10876:                     << "\tFirst seen at " << prev.first->getTestCaseInfo().lineInfo << "\n"
10877:                     << "\tRedefined at " << function.getTestCaseInfo().lineInfo );
10878:         }
10879:     }
10880: 
10881:     std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config ) {
10882:         std::vector<TestCase> filtered;
10883:         filtered.reserve( testCases.size() );
10884:         for( auto const& testCase : testCases )
10885:             if( matchTest( testCase, testSpec, config ) )
10886:                 filtered.push_back( testCase );
10887:         return filtered;
10888:     }
10889:     std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config ) {
10890:         return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );
10891:     }
10892: 
10893:     void TestRegistry::registerTest( TestCase const& testCase ) {
10894:         std::string name = testCase.getTestCaseInfo().name;
10895:         if( name.empty() ) {
10896:             ReusableStringStream rss;
10897:             rss << "Anonymous test case " << ++m_unnamedCount;
10898:             return registerTest( testCase.withName( rss.str() ) );
10899:         }
10900:         m_functions.push_back( testCase );
10901:     }
10902: 
10903:     std::vector<TestCase> const& TestRegistry::getAllTests() const {
10904:         return m_functions;
10905:     }
10906:     std::vector<TestCase> const& TestRegistry::getAllTestsSorted( IConfig const& config ) const {
10907:         if( m_sortedFunctions.empty() )
10908:             enforceNoDuplicateTestCases( m_functions );
10909: 
10910:         if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
10911:             m_sortedFunctions = sortTests( config, m_functions );
10912:             m_currentSortOrder = config.runOrder();
10913:         }
10914:         return m_sortedFunctions;
10915:     }
10916: 
10917:     ///////////////////////////////////////////////////////////////////////////
10918:     TestInvokerAsFunction::TestInvokerAsFunction( void(*testAsFunction)() ) noexcept : m_testAsFunction( testAsFunction ) {}
10919: 
10920:     void TestInvokerAsFunction::invoke() const {
10921:         m_testAsFunction();
10922:     }
10923: 
10924:     std::string extractClassName( StringRef const& classOrQualifiedMethodName ) {
10925:         std::string className = classOrQualifiedMethodName;
10926:         if( startsWith( className, '&' ) )
10927:         {
10928:             std::size_t lastColons = className.rfind( "::" );
10929:             std::size_t penultimateColons = className.rfind( "::", lastColons-1 );
10930:             if( penultimateColons == std::string::npos )
10931:                 penultimateColons = 1;
10932:             className = className.substr( penultimateColons, lastColons-penultimateColons );
10933:         }
10934:         return className;
10935:     }
10936: 
10937: } // end namespace Catch
10938: // end catch_test_case_registry_impl.cpp
10939: // start catch_test_case_tracker.cpp
10940: 
10941: #include <algorithm>
10942: #include <cassert>
10943: #include <stdexcept>
10944: #include <memory>
10945: #include <sstream>
10946: 
10947: #if defined(__clang__)
10948: #    pragma clang diagnostic push
10949: #    pragma clang diagnostic ignored "-Wexit-time-destructors"
10950: #endif
10951: 
10952: namespace Catch {
10953: namespace TestCaseTracking {
10954: 
10955:     NameAndLocation::NameAndLocation( std::string const& _name, SourceLineInfo const& _location )
10956:     :   name( _name ),
10957:         location( _location )
10958:     {}
10959: 
10960:     ITracker::~ITracker() = default;
10961: 
10962:     TrackerContext& TrackerContext::instance() {
10963:         static TrackerContext s_instance;
10964:         return s_instance;
10965:     }
10966: 
10967:     ITracker& TrackerContext::startRun() {
10968:         m_rootTracker = std::make_shared<SectionTracker>( NameAndLocation( "{root}", CATCH_INTERNAL_LINEINFO ), *this, nullptr );
10969:         m_currentTracker = nullptr;
10970:         m_runState = Executing;
10971:         return *m_rootTracker;
10972:     }
10973: 
10974:     void TrackerContext::endRun() {
10975:         m_rootTracker.reset();
10976:         m_currentTracker = nullptr;
10977:         m_runState = NotStarted;
10978:     }
10979: 
10980:     void TrackerContext::startCycle() {
10981:         m_currentTracker = m_rootTracker.get();
10982:         m_runState = Executing;
10983:     }
10984:     void TrackerContext::completeCycle() {
10985:         m_runState = CompletedCycle;
10986:     }
10987: 
10988:     bool TrackerContext::completedCycle() const {
10989:         return m_runState == CompletedCycle;
10990:     }
10991:     ITracker& TrackerContext::currentTracker() {
10992:         return *m_currentTracker;
10993:     }
10994:     void TrackerContext::setCurrentTracker( ITracker* tracker ) {
10995:         m_currentTracker = tracker;
10996:     }
10997: 
10998:     TrackerBase::TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
10999:     :   m_nameAndLocation( nameAndLocation ),
11000:         m_ctx( ctx ),
11001:         m_parent( parent )
11002:     {}
11003: 
11004:     NameAndLocation const& TrackerBase::nameAndLocation() const {
11005:         return m_nameAndLocation;
11006:     }
11007:     bool TrackerBase::isComplete() const {
11008:         return m_runState == CompletedSuccessfully || m_runState == Failed;
11009:     }
11010:     bool TrackerBase::isSuccessfullyCompleted() const {
11011:         return m_runState == CompletedSuccessfully;
11012:     }
11013:     bool TrackerBase::isOpen() const {
11014:         return m_runState != NotStarted && !isComplete();
11015:     }
11016:     bool TrackerBase::hasChildren() const {
11017:         return !m_children.empty();
11018:     }
11019: 
11020:     void TrackerBase::addChild( ITrackerPtr const& child ) {
11021:         m_children.push_back( child );
11022:     }
11023: 
11024:     ITrackerPtr TrackerBase::findChild( NameAndLocation const& nameAndLocation ) {
11025:         auto it = std::find_if( m_children.begin(), m_children.end(),
11026:             [&nameAndLocation]( ITrackerPtr const& tracker ){
11027:                 return
11028:                     tracker->nameAndLocation().location == nameAndLocation.location &&
11029:                     tracker->nameAndLocation().name == nameAndLocation.name;
11030:             } );
11031:         return( it != m_children.end() )
11032:             ? *it
11033:             : nullptr;
11034:     }
11035:     ITracker& TrackerBase::parent() {
11036:         assert( m_parent ); // Should always be non-null except for root
11037:         return *m_parent;
11038:     }
11039: 
11040:     void TrackerBase::openChild() {
11041:         if( m_runState != ExecutingChildren ) {
11042:             m_runState = ExecutingChildren;
11043:             if( m_parent )
11044:                 m_parent->openChild();
11045:         }
11046:     }
11047: 
11048:     bool TrackerBase::isSectionTracker() const { return false; }
11049:     bool TrackerBase::isIndexTracker() const { return false; }
11050: 
11051:     void TrackerBase::open() {
11052:         m_runState = Executing;
11053:         moveToThis();
11054:         if( m_parent )
11055:             m_parent->openChild();
11056:     }
11057: 
11058:     void TrackerBase::close() {
11059: 
11060:         // Close any still open children (e.g. generators)
11061:         while( &m_ctx.currentTracker() != this )
11062:             m_ctx.currentTracker().close();
11063: 
11064:         switch( m_runState ) {
11065:             case NeedsAnotherRun:
11066:                 break;
11067: 
11068:             case Executing:
11069:                 m_runState = CompletedSuccessfully;
11070:                 break;
11071:             case ExecutingChildren:
11072:                 if( m_children.empty() || m_children.back()->isComplete() )
11073:                     m_runState = CompletedSuccessfully;
11074:                 break;
11075: 
11076:             case NotStarted:
11077:             case CompletedSuccessfully:
11078:             case Failed:
11079:                 CATCH_INTERNAL_ERROR( "Illogical state: " << m_runState );
11080: 
11081:             default:
11082:                 CATCH_INTERNAL_ERROR( "Unknown state: " << m_runState );
11083:         }
11084:         moveToParent();
11085:         m_ctx.completeCycle();
11086:     }
11087:     void TrackerBase::fail() {
11088:         m_runState = Failed;
11089:         if( m_parent )
11090:             m_parent->markAsNeedingAnotherRun();
11091:         moveToParent();
11092:         m_ctx.completeCycle();
11093:     }
11094:     void TrackerBase::markAsNeedingAnotherRun() {
11095:         m_runState = NeedsAnotherRun;
11096:     }
11097: 
11098:     void TrackerBase::moveToParent() {
11099:         assert( m_parent );
11100:         m_ctx.setCurrentTracker( m_parent );
11101:     }
11102:     void TrackerBase::moveToThis() {
11103:         m_ctx.setCurrentTracker( this );
11104:     }
11105: 
11106:     SectionTracker::SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
11107:     :   TrackerBase( nameAndLocation, ctx, parent )
11108:     {
11109:         if( parent ) {
11110:             while( !parent->isSectionTracker() )
11111:                 parent = &parent->parent();
11112: 
11113:             SectionTracker& parentSection = static_cast<SectionTracker&>( *parent );
11114:             addNextFilters( parentSection.m_filters );
11115:         }
11116:     }
11117: 
11118:     bool SectionTracker::isSectionTracker() const { return true; }
11119: 
11120:     SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {
11121:         std::shared_ptr<SectionTracker> section;
11122: 
11123:         ITracker& currentTracker = ctx.currentTracker();
11124:         if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
11125:             assert( childTracker );
11126:             assert( childTracker->isSectionTracker() );
11127:             section = std::static_pointer_cast<SectionTracker>( childTracker );
11128:         }
11129:         else {
11130:             section = std::make_shared<SectionTracker>( nameAndLocation, ctx, &currentTracker );
11131:             currentTracker.addChild( section );
11132:         }
11133:         if( !ctx.completedCycle() )
11134:             section->tryOpen();
11135:         return *section;
11136:     }
11137: 
11138:     void SectionTracker::tryOpen() {
11139:         if( !isComplete() && (m_filters.empty() || m_filters[0].empty() ||  m_filters[0] == m_nameAndLocation.name ) )
11140:             open();
11141:     }
11142: 
11143:     void SectionTracker::addInitialFilters( std::vector<std::string> const& filters ) {
11144:         if( !filters.empty() ) {
11145:             m_filters.push_back(""); // Root - should never be consulted
11146:             m_filters.push_back(""); // Test Case - not a section filter
11147:             m_filters.insert( m_filters.end(), filters.begin(), filters.end() );
11148:         }
11149:     }
11150:     void SectionTracker::addNextFilters( std::vector<std::string> const& filters ) {
11151:         if( filters.size() > 1 )
11152:             m_filters.insert( m_filters.end(), ++filters.begin(), filters.end() );
11153:     }
11154: 
11155:     IndexTracker::IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size )
11156:     :   TrackerBase( nameAndLocation, ctx, parent ),
11157:         m_size( size )
11158:     {}
11159: 
11160:     bool IndexTracker::isIndexTracker() const { return true; }
11161: 
11162:     IndexTracker& IndexTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size ) {
11163:         std::shared_ptr<IndexTracker> tracker;
11164: 
11165:         ITracker& currentTracker = ctx.currentTracker();
11166:         if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
11167:             assert( childTracker );
11168:             assert( childTracker->isIndexTracker() );
11169:             tracker = std::static_pointer_cast<IndexTracker>( childTracker );
11170:         }
11171:         else {
11172:             tracker = std::make_shared<IndexTracker>( nameAndLocation, ctx, &currentTracker, size );
11173:             currentTracker.addChild( tracker );
11174:         }
11175: 
11176:         if( !ctx.completedCycle() && !tracker->isComplete() ) {
11177:             if( tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun )
11178:                 tracker->moveNext();
11179:             tracker->open();
11180:         }
11181: 
11182:         return *tracker;
11183:     }
11184: 
11185:     int IndexTracker::index() const { return m_index; }
11186: 
11187:     void IndexTracker::moveNext() {
11188:         m_index++;
11189:         m_children.clear();
11190:     }
11191: 
11192:     void IndexTracker::close() {
11193:         TrackerBase::close();
11194:         if( m_runState == CompletedSuccessfully && m_index < m_size-1 )
11195:             m_runState = Executing;
11196:     }
11197: 
11198: } // namespace TestCaseTracking
11199: 
11200: using TestCaseTracking::ITracker;
11201: using TestCaseTracking::TrackerContext;
11202: using TestCaseTracking::SectionTracker;
11203: using TestCaseTracking::IndexTracker;
11204: 
11205: } // namespace Catch
11206: 
11207: #if defined(__clang__)
11208: #    pragma clang diagnostic pop
11209: #endif
11210: // end catch_test_case_tracker.cpp
11211: // start catch_test_registry.cpp
11212: 
11213: namespace Catch {
11214: 
11215:     auto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker* {
11216:         return new(std::nothrow) TestInvokerAsFunction( testAsFunction );
11217:     }
11218: 
11219:     NameAndTags::NameAndTags( StringRef const& name_ , StringRef const& tags_ ) noexcept : name( name_ ), tags( tags_ ) {}
11220: 
11221:     AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept {
11222:         CATCH_TRY {
11223:             getMutableRegistryHub()
11224:                     .registerTest(
11225:                         makeTestCase(
11226:                             invoker,
11227:                             extractClassName( classOrMethod ),
11228:                             nameAndTags,
11229:                             lineInfo));
11230:         } CATCH_CATCH_ALL {
11231:             // Do not throw when constructing global objects, instead register the exception to be processed later
11232:             getMutableRegistryHub().registerStartupException();
11233:         }
11234:     }
11235: 
11236:     AutoReg::~AutoReg() = default;
11237: }
11238: // end catch_test_registry.cpp
11239: // start catch_test_spec.cpp
11240: 
11241: #include <algorithm>
11242: #include <string>
11243: #include <vector>
11244: #include <memory>
11245: 
11246: namespace Catch {
11247: 
11248:     TestSpec::Pattern::~Pattern() = default;
11249:     TestSpec::NamePattern::~NamePattern() = default;
11250:     TestSpec::TagPattern::~TagPattern() = default;
11251:     TestSpec::ExcludedPattern::~ExcludedPattern() = default;
11252: 
11253:     TestSpec::NamePattern::NamePattern( std::string const& name )
11254:     : m_wildcardPattern( toLower( name ), CaseSensitive::No )
11255:     {}
11256:     bool TestSpec::NamePattern::matches( TestCaseInfo const& testCase ) const {
11257:         return m_wildcardPattern.matches( toLower( testCase.name ) );
11258:     }
11259: 
11260:     TestSpec::TagPattern::TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}
11261:     bool TestSpec::TagPattern::matches( TestCaseInfo const& testCase ) const {
11262:         return std::find(begin(testCase.lcaseTags),
11263:                          end(testCase.lcaseTags),
11264:                          m_tag) != end(testCase.lcaseTags);
11265:     }
11266: 
11267:     TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) {}
11268:     bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }
11269: 
11270:     bool TestSpec::Filter::matches( TestCaseInfo const& testCase ) const {
11271:         // All patterns in a filter must match for the filter to be a match
11272:         for( auto const& pattern : m_patterns ) {
11273:             if( !pattern->matches( testCase ) )
11274:                 return false;
11275:         }
11276:         return true;
11277:     }
11278: 
11279:     bool TestSpec::hasFilters() const {
11280:         return !m_filters.empty();
11281:     }
11282:     bool TestSpec::matches( TestCaseInfo const& testCase ) const {
11283:         // A TestSpec matches if any filter matches
11284:         for( auto const& filter : m_filters )
11285:             if( filter.matches( testCase ) )
11286:                 return true;
11287:         return false;
11288:     }
11289: }
11290: // end catch_test_spec.cpp
11291: // start catch_test_spec_parser.cpp
11292: 
11293: namespace Catch {
11294: 
11295:     TestSpecParser::TestSpecParser( ITagAliasRegistry const& tagAliases ) : m_tagAliases( &tagAliases ) {}
11296: 
11297:     TestSpecParser& TestSpecParser::parse( std::string const& arg ) {
11298:         m_mode = None;
11299:         m_exclusion = false;
11300:         m_start = std::string::npos;
11301:         m_arg = m_tagAliases->expandAliases( arg );
11302:         m_escapeChars.clear();
11303:         for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )
11304:             visitChar( m_arg[m_pos] );
11305:         if( m_mode == Name )
11306:             addPattern<TestSpec::NamePattern>();
11307:         return *this;
11308:     }
11309:     TestSpec TestSpecParser::testSpec() {
11310:         addFilter();
11311:         return m_testSpec;
11312:     }
11313: 
11314:     void TestSpecParser::visitChar( char c ) {
11315:         if( m_mode == None ) {
11316:             switch( c ) {
11317:             case ' ': return;
11318:             case '~': m_exclusion = true; return;
11319:             case '[': return startNewMode( Tag, ++m_pos );
11320:             case '"': return startNewMode( QuotedName, ++m_pos );
11321:             case '\\': return escape();
11322:             default: startNewMode( Name, m_pos ); break;
11323:             }
11324:         }
11325:         if( m_mode == Name ) {
11326:             if( c == ',' ) {
11327:                 addPattern<TestSpec::NamePattern>();
11328:                 addFilter();
11329:             }
11330:             else if( c == '[' ) {
11331:                 if( subString() == "exclude:" )
11332:                     m_exclusion = true;
11333:                 else
11334:                     addPattern<TestSpec::NamePattern>();
11335:                 startNewMode( Tag, ++m_pos );
11336:             }
11337:             else if( c == '\\' )
11338:                 escape();
11339:         }
11340:         else if( m_mode == EscapedName )
11341:             m_mode = Name;
11342:         else if( m_mode == QuotedName && c == '"' )
11343:             addPattern<TestSpec::NamePattern>();
11344:         else if( m_mode == Tag && c == ']' )
11345:             addPattern<TestSpec::TagPattern>();
11346:     }
11347:     void TestSpecParser::startNewMode( Mode mode, std::size_t start ) {
11348:         m_mode = mode;
11349:         m_start = start;
11350:     }
11351:     void TestSpecParser::escape() {
11352:         if( m_mode == None )
11353:             m_start = m_pos;
11354:         m_mode = EscapedName;
11355:         m_escapeChars.push_back( m_pos );
11356:     }
11357:     std::string TestSpecParser::subString() const { return m_arg.substr( m_start, m_pos - m_start ); }
11358: 
11359:     void TestSpecParser::addFilter() {
11360:         if( !m_currentFilter.m_patterns.empty() ) {
11361:             m_testSpec.m_filters.push_back( m_currentFilter );
11362:             m_currentFilter = TestSpec::Filter();
11363:         }
11364:     }
11365: 
11366:     TestSpec parseTestSpec( std::string const& arg ) {
11367:         return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
11368:     }
11369: 
11370: } // namespace Catch
11371: // end catch_test_spec_parser.cpp
11372: // start catch_timer.cpp
11373: 
11374: #include <chrono>
11375: 
11376: static const uint64_t nanosecondsInSecond = 1000000000;
11377: 
11378: namespace Catch {
11379: 
11380:     auto getCurrentNanosecondsSinceEpoch() -> uint64_t {
11381:         return std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();
11382:     }
11383: 
11384:     namespace {
11385:         auto estimateClockResolution() -> uint64_t {
11386:             uint64_t sum = 0;
11387:             static const uint64_t iterations = 1000000;
11388: 
11389:             auto startTime = getCurrentNanosecondsSinceEpoch();
11390: 
11391:             for( std::size_t i = 0; i < iterations; ++i ) {
11392: 
11393:                 uint64_t ticks;
11394:                 uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();
11395:                 do {
11396:                     ticks = getCurrentNanosecondsSinceEpoch();
11397:                 } while( ticks == baseTicks );
11398: 
11399:                 auto delta = ticks - baseTicks;
11400:                 sum += delta;
11401: 
11402:                 // If we have been calibrating for over 3 seconds -- the clock
11403:                 // is terrible and we should move on.
11404:                 // TBD: How to signal that the measured resolution is probably wrong?
11405:                 if (ticks > startTime + 3 * nanosecondsInSecond) {
11406:                     return sum / i;
11407:                 }
11408:             }
11409: 
11410:             // We're just taking the mean, here. To do better we could take the std. dev and exclude outliers
11411:             // - and potentially do more iterations if there's a high variance.
11412:             return sum/iterations;
11413:         }
11414:     }
11415:     auto getEstimatedClockResolution() -> uint64_t {
11416:         static auto s_resolution = estimateClockResolution();
11417:         return s_resolution;
11418:     }
11419: 
11420:     void Timer::start() {
11421:        m_nanoseconds = getCurrentNanosecondsSinceEpoch();
11422:     }
11423:     auto Timer::getElapsedNanoseconds() const -> uint64_t {
11424:         return getCurrentNanosecondsSinceEpoch() - m_nanoseconds;
11425:     }
11426:     auto Timer::getElapsedMicroseconds() const -> uint64_t {
11427:         return getElapsedNanoseconds()/1000;
11428:     }
11429:     auto Timer::getElapsedMilliseconds() const -> unsigned int {
11430:         return static_cast<unsigned int>(getElapsedMicroseconds()/1000);
11431:     }
11432:     auto Timer::getElapsedSeconds() const -> double {
11433:         return getElapsedMicroseconds()/1000000.0;
11434:     }
11435: 
11436: } // namespace Catch
11437: // end catch_timer.cpp
11438: // start catch_tostring.cpp
11439: 
11440: #if defined(__clang__)
11441: #    pragma clang diagnostic push
11442: #    pragma clang diagnostic ignored "-Wexit-time-destructors"
11443: #    pragma clang diagnostic ignored "-Wglobal-constructors"
11444: #endif
11445: 
11446: // Enable specific decls locally
11447: #if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
11448: #define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
11449: #endif
11450: 
11451: #include <cmath>
11452: #include <iomanip>
11453: 
11454: namespace Catch {
11455: 
11456: namespace Detail {
11457: 
11458:     const std::string unprintableString = "{?}";
11459: 
11460:     namespace {
11461:         const int hexThreshold = 255;
11462: 
11463:         struct Endianness {
11464:             enum Arch { Big, Little };
11465: 
11466:             static Arch which() {
11467:                 union _{
11468:                     int asInt;
11469:                     char asChar[sizeof (int)];
11470:                 } u;
11471: 
11472:                 u.asInt = 1;
11473:                 return ( u.asChar[sizeof(int)-1] == 1 ) ? Big : Little;
11474:             }
11475:         };
11476:     }
11477: 
11478:     std::string rawMemoryToString( const void *object, std::size_t size ) {
11479:         // Reverse order for little endian architectures
11480:         int i = 0, end = static_cast<int>( size ), inc = 1;
11481:         if( Endianness::which() == Endianness::Little ) {
11482:             i = end-1;
11483:             end = inc = -1;
11484:         }
11485: 
11486:         unsigned char const *bytes = static_cast<unsigned char const *>(object);
11487:         ReusableStringStream rss;
11488:         rss << "0x" << std::setfill('0') << std::hex;
11489:         for( ; i != end; i += inc )
11490:              rss << std::setw(2) << static_cast<unsigned>(bytes[i]);
11491:        return rss.str();
11492:     }
11493: }
11494: 
11495: template<typename T>
11496: std::string fpToString( T value, int precision ) {
11497:     if (std::isnan(value)) {
11498:         return "nan";
11499:     }
11500: 
11501:     ReusableStringStream rss;
11502:     rss << std::setprecision( precision )
11503:         << std::fixed
11504:         << value;
11505:     std::string d = rss.str();
11506:     std::size_t i = d.find_last_not_of( '0' );
11507:     if( i != std::string::npos && i != d.size()-1 ) {
11508:         if( d[i] == '.' )
11509:             i++;
11510:         d = d.substr( 0, i+1 );
11511:     }
11512:     return d;
11513: }
11514: 
11515: //// ======================================================= ////
11516: //
11517: //   Out-of-line defs for full specialization of StringMaker
11518: //
11519: //// ======================================================= ////
11520: 
11521: std::string StringMaker<std::string>::convert(const std::string& str) {
11522:     if (!getCurrentContext().getConfig()->showInvisibles()) {
11523:         return '"' + str + '"';
11524:     }
11525: 
11526:     std::string s("\"");
11527:     for (char c : str) {
11528:         switch (c) {
11529:         case '\n':
11530:             s.append("\\n");
11531:             break;
11532:         case '\t':
11533:             s.append("\\t");
11534:             break;
11535:         default:
11536:             s.push_back(c);
11537:             break;
11538:         }
11539:     }
11540:     s.append("\"");
11541:     return s;
11542: }
11543: 
11544: #ifdef CATCH_CONFIG_WCHAR
11545: std::string StringMaker<std::wstring>::convert(const std::wstring& wstr) {
11546:     std::string s;
11547:     s.reserve(wstr.size());
11548:     for (auto c : wstr) {
11549:         s += (c <= 0xff) ? static_cast<char>(c) : '?';
11550:     }
11551:     return ::Catch::Detail::stringify(s);
11552: }
11553: #endif
11554: 
11555: std::string StringMaker<char const*>::convert(char const* str) {
11556:     if (str) {
11557:         return ::Catch::Detail::stringify(std::string{ str });
11558:     } else {
11559:         return{ "{null string}" };
11560:     }
11561: }
11562: std::string StringMaker<char*>::convert(char* str) {
11563:     if (str) {
11564:         return ::Catch::Detail::stringify(std::string{ str });
11565:     } else {
11566:         return{ "{null string}" };
11567:     }
11568: }
11569: #ifdef CATCH_CONFIG_WCHAR
11570: std::string StringMaker<wchar_t const*>::convert(wchar_t const * str) {
11571:     if (str) {
11572:         return ::Catch::Detail::stringify(std::wstring{ str });
11573:     } else {
11574:         return{ "{null string}" };
11575:     }
11576: }
11577: std::string StringMaker<wchar_t *>::convert(wchar_t * str) {
11578:     if (str) {
11579:         return ::Catch::Detail::stringify(std::wstring{ str });
11580:     } else {
11581:         return{ "{null string}" };
11582:     }
11583: }
11584: #endif
11585: 
11586: std::string StringMaker<int>::convert(int value) {
11587:     return ::Catch::Detail::stringify(static_cast<long long>(value));
11588: }
11589: std::string StringMaker<long>::convert(long value) {
11590:     return ::Catch::Detail::stringify(static_cast<long long>(value));
11591: }
11592: std::string StringMaker<long long>::convert(long long value) {
11593:     ReusableStringStream rss;
11594:     rss << value;
11595:     if (value > Detail::hexThreshold) {
11596:         rss << " (0x" << std::hex << value << ')';
11597:     }
11598:     return rss.str();
11599: }
11600: 
11601: std::string StringMaker<unsigned int>::convert(unsigned int value) {
11602:     return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));
11603: }
11604: std::string StringMaker<unsigned long>::convert(unsigned long value) {
11605:     return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));
11606: }
11607: std::string StringMaker<unsigned long long>::convert(unsigned long long value) {
11608:     ReusableStringStream rss;
11609:     rss << value;
11610:     if (value > Detail::hexThreshold) {
11611:         rss << " (0x" << std::hex << value << ')';
11612:     }
11613:     return rss.str();
11614: }
11615: 
11616: std::string StringMaker<bool>::convert(bool b) {
11617:     return b ? "true" : "false";
11618: }
11619: 
11620: std::string StringMaker<char>::convert(char value) {
11621:     if (value == '\r') {
11622:         return "'\\r'";
11623:     } else if (value == '\f') {
11624:         return "'\\f'";
11625:     } else if (value == '\n') {
11626:         return "'\\n'";
11627:     } else if (value == '\t') {
11628:         return "'\\t'";
11629:     } else if ('\0' <= value && value < ' ') {
11630:         return ::Catch::Detail::stringify(static_cast<unsigned int>(value));
11631:     } else {
11632:         char chstr[] = "' '";
11633:         chstr[1] = value;
11634:         return chstr;
11635:     }
11636: }
11637: std::string StringMaker<signed char>::convert(signed char c) {
11638:     return ::Catch::Detail::stringify(static_cast<char>(c));
11639: }
11640: std::string StringMaker<unsigned char>::convert(unsigned char c) {
11641:     return ::Catch::Detail::stringify(static_cast<char>(c));
11642: }
11643: 
11644: std::string StringMaker<std::nullptr_t>::convert(std::nullptr_t) {
11645:     return "nullptr";
11646: }
11647: 
11648: std::string StringMaker<float>::convert(float value) {
11649:     return fpToString(value, 5) + 'f';
11650: }
11651: std::string StringMaker<double>::convert(double value) {
11652:     return fpToString(value, 10);
11653: }
11654: 
11655: std::string ratio_string<std::atto>::symbol() { return "a"; }
11656: std::string ratio_string<std::femto>::symbol() { return "f"; }
11657: std::string ratio_string<std::pico>::symbol() { return "p"; }
11658: std::string ratio_string<std::nano>::symbol() { return "n"; }
11659: std::string ratio_string<std::micro>::symbol() { return "u"; }
11660: std::string ratio_string<std::milli>::symbol() { return "m"; }
11661: 
11662: } // end namespace Catch
11663: 
11664: #if defined(__clang__)
11665: #    pragma clang diagnostic pop
11666: #endif
11667: 
11668: // end catch_tostring.cpp
11669: // start catch_totals.cpp
11670: 
11671: namespace Catch {
11672: 
11673:     Counts Counts::operator - ( Counts const& other ) const {
11674:         Counts diff;
11675:         diff.passed = passed - other.passed;
11676:         diff.failed = failed - other.failed;
11677:         diff.failedButOk = failedButOk - other.failedButOk;
11678:         return diff;
11679:     }
11680: 
11681:     Counts& Counts::operator += ( Counts const& other ) {
11682:         passed += other.passed;
11683:         failed += other.failed;
11684:         failedButOk += other.failedButOk;
11685:         return *this;
11686:     }
11687: 
11688:     std::size_t Counts::total() const {
11689:         return passed + failed + failedButOk;
11690:     }
11691:     bool Counts::allPassed() const {
11692:         return failed == 0 && failedButOk == 0;
11693:     }
11694:     bool Counts::allOk() const {
11695:         return failed == 0;
11696:     }
11697: 
11698:     Totals Totals::operator - ( Totals const& other ) const {
11699:         Totals diff;
11700:         diff.assertions = assertions - other.assertions;
11701:         diff.testCases = testCases - other.testCases;
11702:         return diff;
11703:     }
11704: 
11705:     Totals& Totals::operator += ( Totals const& other ) {
11706:         assertions += other.assertions;
11707:         testCases += other.testCases;
11708:         return *this;
11709:     }
11710: 
11711:     Totals Totals::delta( Totals const& prevTotals ) const {
11712:         Totals diff = *this - prevTotals;
11713:         if( diff.assertions.failed > 0 )
11714:             ++diff.testCases.failed;
11715:         else if( diff.assertions.failedButOk > 0 )
11716:             ++diff.testCases.failedButOk;
11717:         else
11718:             ++diff.testCases.passed;
11719:         return diff;
11720:     }
11721: 
11722: }
11723: // end catch_totals.cpp
11724: // start catch_uncaught_exceptions.cpp
11725: 
11726: #include <exception>
11727: 
11728: namespace Catch {
11729:     bool uncaught_exceptions() {
11730: #if defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
11731:         return std::uncaught_exceptions() > 0;
11732: #else
11733:         return std::uncaught_exception();
11734: #endif
11735:   }
11736: } // end namespace Catch
11737: // end catch_uncaught_exceptions.cpp
11738: // start catch_version.cpp
11739: 
11740: #include <ostream>
11741: 
11742: namespace Catch {
11743: 
11744:     Version::Version
11745:         (   unsigned int _majorVersion,
11746:             unsigned int _minorVersion,
11747:             unsigned int _patchNumber,
11748:             char const * const _branchName,
11749:             unsigned int _buildNumber )
11750:     :   majorVersion( _majorVersion ),
11751:         minorVersion( _minorVersion ),
11752:         patchNumber( _patchNumber ),
11753:         branchName( _branchName ),
11754:         buildNumber( _buildNumber )
11755:     {}
11756: 
11757:     std::ostream& operator << ( std::ostream& os, Version const& version ) {
11758:         os  << version.majorVersion << '.'
11759:             << version.minorVersion << '.'
11760:             << version.patchNumber;
11761:         // branchName is never null -> 0th char is \0 if it is empty
11762:         if (version.branchName[0]) {
11763:             os << '-' << version.branchName
11764:                << '.' << version.buildNumber;
11765:         }
11766:         return os;
11767:     }
11768: 
11769:     Version const& libraryVersion() {
11770:         static Version version( 2, 4, 0, "", 0 );
11771:         return version;
11772:     }
11773: 
11774: }
11775: // end catch_version.cpp
11776: // start catch_wildcard_pattern.cpp
11777: 
11778: #include <sstream>
11779: 
11780: namespace Catch {
11781: 
11782:     WildcardPattern::WildcardPattern( std::string const& pattern,
11783:                                       CaseSensitive::Choice caseSensitivity )
11784:     :   m_caseSensitivity( caseSensitivity ),
11785:         m_pattern( adjustCase( pattern ) )
11786:     {
11787:         if( startsWith( m_pattern, '*' ) ) {
11788:             m_pattern = m_pattern.substr( 1 );
11789:             m_wildcard = WildcardAtStart;
11790:         }
11791:         if( endsWith( m_pattern, '*' ) ) {
11792:             m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );
11793:             m_wildcard = static_cast<WildcardPosition>( m_wildcard | WildcardAtEnd );
11794:         }
11795:     }
11796: 
11797:     bool WildcardPattern::matches( std::string const& str ) const {
11798:         switch( m_wildcard ) {
11799:             case NoWildcard:
11800:                 return m_pattern == adjustCase( str );
11801:             case WildcardAtStart:
11802:                 return endsWith( adjustCase( str ), m_pattern );
11803:             case WildcardAtEnd:
11804:                 return startsWith( adjustCase( str ), m_pattern );
11805:             case WildcardAtBothEnds:
11806:                 return contains( adjustCase( str ), m_pattern );
11807:             default:
11808:                 CATCH_INTERNAL_ERROR( "Unknown enum" );
11809:         }
11810:     }
11811: 
11812:     std::string WildcardPattern::adjustCase( std::string const& str ) const {
11813:         return m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str;
11814:     }
11815: }
11816: // end catch_wildcard_pattern.cpp
11817: // start catch_xmlwriter.cpp
11818: 
11819: #include <iomanip>
11820: 
11821: using uchar = unsigned char;
11822: 
11823: namespace Catch {
11824: 
11825: namespace {
11826: 
11827:     size_t trailingBytes(unsigned char c) {
11828:         if ((c & 0xE0) == 0xC0) {
11829:             return 2;
11830:         }
11831:         if ((c & 0xF0) == 0xE0) {
11832:             return 3;
11833:         }
11834:         if ((c & 0xF8) == 0xF0) {
11835:             return 4;
11836:         }
11837:         CATCH_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
11838:     }
11839: 
11840:     uint32_t headerValue(unsigned char c) {
11841:         if ((c & 0xE0) == 0xC0) {
11842:             return c & 0x1F;
11843:         }
11844:         if ((c & 0xF0) == 0xE0) {
11845:             return c & 0x0F;
11846:         }
11847:         if ((c & 0xF8) == 0xF0) {
11848:             return c & 0x07;
11849:         }
11850:         CATCH_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
11851:     }
11852: 
11853:     void hexEscapeChar(std::ostream& os, unsigned char c) {
11854:         os << "\\x"
11855:             << std::uppercase << std::hex << std::setfill('0') << std::setw(2)
11856:             << static_cast<int>(c);
11857:     }
11858: 
11859: } // anonymous namespace
11860: 
11861:     XmlEncode::XmlEncode( std::string const& str, ForWhat forWhat )
11862:     :   m_str( str ),
11863:         m_forWhat( forWhat )
11864:     {}
11865: 
11866:     void XmlEncode::encodeTo( std::ostream& os ) const {
11867:         // Apostrophe escaping not necessary if we always use " to write attributes
11868:         // (see: http://www.w3.org/TR/xml/#syntax)
11869: 
11870:         for( std::size_t idx = 0; idx < m_str.size(); ++ idx ) {
11871:             uchar c = m_str[idx];
11872:             switch (c) {
11873:             case '<':   os << "&lt;"; break;
11874:             case '&':   os << "&amp;"; break;
11875: 
11876:             case '>':
11877:                 // See: http://www.w3.org/TR/xml/#syntax
11878:                 if (idx > 2 && m_str[idx - 1] == ']' && m_str[idx - 2] == ']')
11879:                     os << "&gt;";
11880:                 else
11881:                     os << c;
11882:                 break;
11883: 
11884:             case '\"':
11885:                 if (m_forWhat == ForAttributes)
11886:                     os << "&quot;";
11887:                 else
11888:                     os << c;
11889:                 break;
11890: 
11891:             default:
11892:                 // Check for control characters and invalid utf-8
11893: 
11894:                 // Escape control characters in standard ascii
11895:                 // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
11896:                 if (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) {
11897:                     hexEscapeChar(os, c);
11898:                     break;
11899:                 }
11900: 
11901:                 // Plain ASCII: Write it to stream
11902:                 if (c < 0x7F) {
11903:                     os << c;
11904:                     break;
11905:                 }
11906: 
11907:                 // UTF-8 territory
11908:                 // Check if the encoding is valid and if it is not, hex escape bytes.
11909:                 // Important: We do not check the exact decoded values for validity, only the encoding format
11910:                 // First check that this bytes is a valid lead byte:
11911:                 // This means that it is not encoded as 1111 1XXX
11912:                 // Or as 10XX XXXX
11913:                 if (c <  0xC0 ||
11914:                     c >= 0xF8) {
11915:                     hexEscapeChar(os, c);
11916:                     break;
11917:                 }
11918: 
11919:                 auto encBytes = trailingBytes(c);
11920:                 // Are there enough bytes left to avoid accessing out-of-bounds memory?
11921:                 if (idx + encBytes - 1 >= m_str.size()) {
11922:                     hexEscapeChar(os, c);
11923:                     break;
11924:                 }
11925:                 // The header is valid, check data
11926:                 // The next encBytes bytes must together be a valid utf-8
11927:                 // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)
11928:                 bool valid = true;
11929:                 uint32_t value = headerValue(c);
11930:                 for (std::size_t n = 1; n < encBytes; ++n) {
11931:                     uchar nc = m_str[idx + n];
11932:                     valid &= ((nc & 0xC0) == 0x80);
11933:                     value = (value << 6) | (nc & 0x3F);
11934:                 }
11935: 
11936:                 if (
11937:                     // Wrong bit pattern of following bytes
11938:                     (!valid) ||
11939:                     // Overlong encodings
11940:                     (value < 0x80) ||
11941:                     (0x80 <= value && value < 0x800   && encBytes > 2) ||
11942:                     (0x800 < value && value < 0x10000 && encBytes > 3) ||
11943:                     // Encoded value out of range
11944:                     (value >= 0x110000)
11945:                     ) {
11946:                     hexEscapeChar(os, c);
11947:                     break;
11948:                 }
11949: 
11950:                 // If we got here, this is in fact a valid(ish) utf-8 sequence
11951:                 for (std::size_t n = 0; n < encBytes; ++n) {
11952:                     os << m_str[idx + n];
11953:                 }
11954:                 idx += encBytes - 1;
11955:                 break;
11956:             }
11957:         }
11958:     }
11959: 
11960:     std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {
11961:         xmlEncode.encodeTo( os );
11962:         return os;
11963:     }
11964: 
11965:     XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer )
11966:     :   m_writer( writer )
11967:     {}
11968: 
11969:     XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) noexcept
11970:     :   m_writer( other.m_writer ){
11971:         other.m_writer = nullptr;
11972:     }
11973:     XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) noexcept {
11974:         if ( m_writer ) {
11975:             m_writer->endElement();
11976:         }
11977:         m_writer = other.m_writer;
11978:         other.m_writer = nullptr;
11979:         return *this;
11980:     }
11981: 
11982:     XmlWriter::ScopedElement::~ScopedElement() {
11983:         if( m_writer )
11984:             m_writer->endElement();
11985:     }
11986: 
11987:     XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText( std::string const& text, bool indent ) {
11988:         m_writer->writeText( text, indent );
11989:         return *this;
11990:     }
11991: 
11992:     XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )
11993:     {
11994:         writeDeclaration();
11995:     }
11996: 
11997:     XmlWriter::~XmlWriter() {
11998:         while( !m_tags.empty() )
11999:             endElement();
12000:     }
12001: 
12002:     XmlWriter& XmlWriter::startElement( std::string const& name ) {
12003:         ensureTagClosed();
12004:         newlineIfNecessary();
12005:         m_os << m_indent << '<' << name;
12006:         m_tags.push_back( name );
12007:         m_indent += "  ";
12008:         m_tagIsOpen = true;
12009:         return *this;
12010:     }
12011: 
12012:     XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const& name ) {
12013:         ScopedElement scoped( this );
12014:         startElement( name );
12015:         return scoped;
12016:     }
12017: 
12018:     XmlWriter& XmlWriter::endElement() {
12019:         newlineIfNecessary();
12020:         m_indent = m_indent.substr( 0, m_indent.size()-2 );
12021:         if( m_tagIsOpen ) {
12022:             m_os << "/>";
12023:             m_tagIsOpen = false;
12024:         }
12025:         else {
12026:             m_os << m_indent << "</" << m_tags.back() << ">";
12027:         }
12028:         m_os << std::endl;
12029:         m_tags.pop_back();
12030:         return *this;
12031:     }
12032: 
12033:     XmlWriter& XmlWriter::writeAttribute( std::string const& name, std::string const& attribute ) {
12034:         if( !name.empty() && !attribute.empty() )
12035:             m_os << ' ' << name << "=\"" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '"';
12036:         return *this;
12037:     }
12038: 
12039:     XmlWriter& XmlWriter::writeAttribute( std::string const& name, bool attribute ) {
12040:         m_os << ' ' << name << "=\"" << ( attribute ? "true" : "false" ) << '"';
12041:         return *this;
12042:     }
12043: 
12044:     XmlWriter& XmlWriter::writeText( std::string const& text, bool indent ) {
12045:         if( !text.empty() ){
12046:             bool tagWasOpen = m_tagIsOpen;
12047:             ensureTagClosed();
12048:             if( tagWasOpen && indent )
12049:                 m_os << m_indent;
12050:             m_os << XmlEncode( text );
12051:             m_needsNewline = true;
12052:         }
12053:         return *this;
12054:     }
12055: 
12056:     XmlWriter& XmlWriter::writeComment( std::string const& text ) {
12057:         ensureTagClosed();
12058:         m_os << m_indent << "<!--" << text << "-->";
12059:         m_needsNewline = true;
12060:         return *this;
12061:     }
12062: 
12063:     void XmlWriter::writeStylesheetRef( std::string const& url ) {
12064:         m_os << "<?xml-stylesheet type=\"text/xsl\" href=\"" << url << "\"?>\n";
12065:     }
12066: 
12067:     XmlWriter& XmlWriter::writeBlankLine() {
12068:         ensureTagClosed();
12069:         m_os << '\n';
12070:         return *this;
12071:     }
12072: 
12073:     void XmlWriter::ensureTagClosed() {
12074:         if( m_tagIsOpen ) {
12075:             m_os << ">" << std::endl;
12076:             m_tagIsOpen = false;
12077:         }
12078:     }
12079: 
12080:     void XmlWriter::writeDeclaration() {
12081:         m_os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
12082:     }
12083: 
12084:     void XmlWriter::newlineIfNecessary() {
12085:         if( m_needsNewline ) {
12086:             m_os << std::endl;
12087:             m_needsNewline = false;
12088:         }
12089:     }
12090: }
12091: // end catch_xmlwriter.cpp
12092: // start catch_reporter_bases.cpp
12093: 
12094: #include <cstring>
12095: #include <cfloat>
12096: #include <cstdio>
12097: #include <cassert>
12098: #include <memory>
12099: 
12100: namespace Catch {
12101:     void prepareExpandedExpression(AssertionResult& result) {
12102:         result.getExpandedExpression();
12103:     }
12104: 
12105:     // Because formatting using c++ streams is stateful, drop down to C is required
12106:     // Alternatively we could use stringstream, but its performance is... not good.
12107:     std::string getFormattedDuration( double duration ) {
12108:         // Max exponent + 1 is required to represent the whole part
12109:         // + 1 for decimal point
12110:         // + 3 for the 3 decimal places
12111:         // + 1 for null terminator
12112:         const std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;
12113:         char buffer[maxDoubleSize];
12114: 
12115:         // Save previous errno, to prevent sprintf from overwriting it
12116:         ErrnoGuard guard;
12117: #ifdef _MSC_VER
12118:         sprintf_s(buffer, "%.3f", duration);
12119: #else
12120:         sprintf(buffer, "%.3f", duration);
12121: #endif
12122:         return std::string(buffer);
12123:     }
12124: 
12125:     TestEventListenerBase::TestEventListenerBase(ReporterConfig const & _config)
12126:         :StreamingReporterBase(_config) {}
12127: 
12128:     void TestEventListenerBase::assertionStarting(AssertionInfo const &) {}
12129: 
12130:     bool TestEventListenerBase::assertionEnded(AssertionStats const &) {
12131:         return false;
12132:     }
12133: 
12134: } // end namespace Catch
12135: // end catch_reporter_bases.cpp
12136: // start catch_reporter_compact.cpp
12137: 
12138: namespace {
12139: 
12140: #ifdef CATCH_PLATFORM_MAC
12141:     const char* failedString() { return "FAILED"; }
12142:     const char* passedString() { return "PASSED"; }
12143: #else
12144:     const char* failedString() { return "failed"; }
12145:     const char* passedString() { return "passed"; }
12146: #endif
12147: 
12148:     // Colour::LightGrey
12149:     Catch::Colour::Code dimColour() { return Catch::Colour::FileName; }
12150: 
12151:     std::string bothOrAll( std::size_t count ) {
12152:         return count == 1 ? std::string() :
12153:                count == 2 ? "both " : "all " ;
12154:     }
12155: 
12156: } // anon namespace
12157: 
12158: namespace Catch {
12159: namespace {
12160: // Colour, message variants:
12161: // - white: No tests ran.
12162: // -   red: Failed [both/all] N test cases, failed [both/all] M assertions.
12163: // - white: Passed [both/all] N test cases (no assertions).
12164: // -   red: Failed N tests cases, failed M assertions.
12165: // - green: Passed [both/all] N tests cases with M assertions.
12166: void printTotals(std::ostream& out, const Totals& totals) {
12167:     if (totals.testCases.total() == 0) {
12168:         out << "No tests ran.";
12169:     } else if (totals.testCases.failed == totals.testCases.total()) {
12170:         Colour colour(Colour::ResultError);
12171:         const std::string qualify_assertions_failed =
12172:             totals.assertions.failed == totals.assertions.total() ?
12173:             bothOrAll(totals.assertions.failed) : std::string();
12174:         out <<
12175:             "Failed " << bothOrAll(totals.testCases.failed)
12176:             << pluralise(totals.testCases.failed, "test case") << ", "
12177:             "failed " << qualify_assertions_failed <<
12178:             pluralise(totals.assertions.failed, "assertion") << '.';
12179:     } else if (totals.assertions.total() == 0) {
12180:         out <<
12181:             "Passed " << bothOrAll(totals.testCases.total())
12182:             << pluralise(totals.testCases.total(), "test case")
12183:             << " (no assertions).";
12184:     } else if (totals.assertions.failed) {
12185:         Colour colour(Colour::ResultError);
12186:         out <<
12187:             "Failed " << pluralise(totals.testCases.failed, "test case") << ", "
12188:             "failed " << pluralise(totals.assertions.failed, "assertion") << '.';
12189:     } else {
12190:         Colour colour(Colour::ResultSuccess);
12191:         out <<
12192:             "Passed " << bothOrAll(totals.testCases.passed)
12193:             << pluralise(totals.testCases.passed, "test case") <<
12194:             " with " << pluralise(totals.assertions.passed, "assertion") << '.';
12195:     }
12196: }
12197: 
12198: // Implementation of CompactReporter formatting
12199: class AssertionPrinter {
12200: public:
12201:     AssertionPrinter& operator= (AssertionPrinter const&) = delete;
12202:     AssertionPrinter(AssertionPrinter const&) = delete;
12203:     AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
12204:         : stream(_stream)
12205:         , result(_stats.assertionResult)
12206:         , messages(_stats.infoMessages)
12207:         , itMessage(_stats.infoMessages.begin())
12208:         , printInfoMessages(_printInfoMessages) {}
12209: 
12210:     void print() {
12211:         printSourceInfo();
12212: 
12213:         itMessage = messages.begin();
12214: 
12215:         switch (result.getResultType()) {
12216:         case ResultWas::Ok:
12217:             printResultType(Colour::ResultSuccess, passedString());
12218:             printOriginalExpression();
12219:             printReconstructedExpression();
12220:             if (!result.hasExpression())
12221:                 printRemainingMessages(Colour::None);
12222:             else
12223:                 printRemainingMessages();
12224:             break;
12225:         case ResultWas::ExpressionFailed:
12226:             if (result.isOk())
12227:                 printResultType(Colour::ResultSuccess, failedString() + std::string(" - but was ok"));
12228:             else
12229:                 printResultType(Colour::Error, failedString());
12230:             printOriginalExpression();
12231:             printReconstructedExpression();
12232:             printRemainingMessages();
12233:             break;
12234:         case ResultWas::ThrewException:
12235:             printResultType(Colour::Error, failedString());
12236:             printIssue("unexpected exception with message:");
12237:             printMessage();
12238:             printExpressionWas();
12239:             printRemainingMessages();
12240:             break;
12241:         case ResultWas::FatalErrorCondition:
12242:             printResultType(Colour::Error, failedString());
12243:             printIssue("fatal error condition with message:");
12244:             printMessage();
12245:             printExpressionWas();
12246:             printRemainingMessages();
12247:             break;
12248:         case ResultWas::DidntThrowException:
12249:             printResultType(Colour::Error, failedString());
12250:             printIssue("expected exception, got none");
12251:             printExpressionWas();
12252:             printRemainingMessages();
12253:             break;
12254:         case ResultWas::Info:
12255:             printResultType(Colour::None, "info");
12256:             printMessage();
12257:             printRemainingMessages();
12258:             break;
12259:         case ResultWas::Warning:
12260:             printResultType(Colour::None, "warning");
12261:             printMessage();
12262:             printRemainingMessages();
12263:             break;
12264:         case ResultWas::ExplicitFailure:
12265:             printResultType(Colour::Error, failedString());
12266:             printIssue("explicitly");
12267:             printRemainingMessages(Colour::None);
12268:             break;
12269:             // These cases are here to prevent compiler warnings
12270:         case ResultWas::Unknown:
12271:         case ResultWas::FailureBit:
12272:         case ResultWas::Exception:
12273:             printResultType(Colour::Error, "** internal error **");
12274:             break;
12275:         }
12276:     }
12277: 
12278: private:
12279:     void printSourceInfo() const {
12280:         Colour colourGuard(Colour::FileName);
12281:         stream << result.getSourceInfo() << ':';
12282:     }
12283: 
12284:     void printResultType(Colour::Code colour, std::string const& passOrFail) const {
12285:         if (!passOrFail.empty()) {
12286:             {
12287:                 Colour colourGuard(colour);
12288:                 stream << ' ' << passOrFail;
12289:             }
12290:             stream << ':';
12291:         }
12292:     }
12293: 
12294:     void printIssue(std::string const& issue) const {
12295:         stream << ' ' << issue;
12296:     }
12297: 
12298:     void printExpressionWas() {
12299:         if (result.hasExpression()) {
12300:             stream << ';';
12301:             {
12302:                 Colour colour(dimColour());
12303:                 stream << " expression was:";
12304:             }
12305:             printOriginalExpression();
12306:         }
12307:     }
12308: 
12309:     void printOriginalExpression() const {
12310:         if (result.hasExpression()) {
12311:             stream << ' ' << result.getExpression();
12312:         }
12313:     }
12314: 
12315:     void printReconstructedExpression() const {
12316:         if (result.hasExpandedExpression()) {
12317:             {
12318:                 Colour colour(dimColour());
12319:                 stream << " for: ";
12320:             }
12321:             stream << result.getExpandedExpression();
12322:         }
12323:     }
12324: 
12325:     void printMessage() {
12326:         if (itMessage != messages.end()) {
12327:             stream << " '" << itMessage->message << '\'';
12328:             ++itMessage;
12329:         }
12330:     }
12331: 
12332:     void printRemainingMessages(Colour::Code colour = dimColour()) {
12333:         if (itMessage == messages.end())
12334:             return;
12335: 
12336:         // using messages.end() directly yields (or auto) compilation error:
12337:         std::vector<MessageInfo>::const_iterator itEnd = messages.end();
12338:         const std::size_t N = static_cast<std::size_t>(std::distance(itMessage, itEnd));
12339: 
12340:         {
12341:             Colour colourGuard(colour);
12342:             stream << " with " << pluralise(N, "message") << ':';
12343:         }
12344: 
12345:         for (; itMessage != itEnd; ) {
12346:             // If this assertion is a warning ignore any INFO messages
12347:             if (printInfoMessages || itMessage->type != ResultWas::Info) {
12348:                 stream << " '" << itMessage->message << '\'';
12349:                 if (++itMessage != itEnd) {
12350:                     Colour colourGuard(dimColour());
12351:                     stream << " and";
12352:                 }
12353:             }
12354:         }
12355:     }
12356: 
12357: private:
12358:     std::ostream& stream;
12359:     AssertionResult const& result;
12360:     std::vector<MessageInfo> messages;
12361:     std::vector<MessageInfo>::const_iterator itMessage;
12362:     bool printInfoMessages;
12363: };
12364: 
12365: } // anon namespace
12366: 
12367:         std::string CompactReporter::getDescription() {
12368:             return "Reports test results on a single line, suitable for IDEs";
12369:         }
12370: 
12371:         ReporterPreferences CompactReporter::getPreferences() const {
12372:             return m_reporterPrefs;
12373:         }
12374: 
12375:         void CompactReporter::noMatchingTestCases( std::string const& spec ) {
12376:             stream << "No test cases matched '" << spec << '\'' << std::endl;
12377:         }
12378: 
12379:         void CompactReporter::assertionStarting( AssertionInfo const& ) {}
12380: 
12381:         bool CompactReporter::assertionEnded( AssertionStats const& _assertionStats ) {
12382:             AssertionResult const& result = _assertionStats.assertionResult;
12383: 
12384:             bool printInfoMessages = true;
12385: 
12386:             // Drop out if result was successful and we're not printing those
12387:             if( !m_config->includeSuccessfulResults() && result.isOk() ) {
12388:                 if( result.getResultType() != ResultWas::Warning )
12389:                     return false;
12390:                 printInfoMessages = false;
12391:             }
12392: 
12393:             AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
12394:             printer.print();
12395: 
12396:             stream << std::endl;
12397:             return true;
12398:         }
12399: 
12400:         void CompactReporter::sectionEnded(SectionStats const& _sectionStats) {
12401:             if (m_config->showDurations() == ShowDurations::Always) {
12402:                 stream << getFormattedDuration(_sectionStats.durationInSeconds) << " s: " << _sectionStats.sectionInfo.name << std::endl;
12403:             }
12404:         }
12405: 
12406:         void CompactReporter::testRunEnded( TestRunStats const& _testRunStats ) {
12407:             printTotals( stream, _testRunStats.totals );
12408:             stream << '\n' << std::endl;
12409:             StreamingReporterBase::testRunEnded( _testRunStats );
12410:         }
12411: 
12412:         CompactReporter::~CompactReporter() {}
12413: 
12414:     CATCH_REGISTER_REPORTER( "compact", CompactReporter )
12415: 
12416: } // end namespace Catch
12417: // end catch_reporter_compact.cpp
12418: // start catch_reporter_console.cpp
12419: 
12420: #include <cfloat>
12421: #include <cstdio>
12422: 
12423: #if defined(_MSC_VER)
12424: #pragma warning(push)
12425: #pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
12426:  // Note that 4062 (not all labels are handled
12427:  // and default is missing) is enabled
12428: #endif
12429: 
12430: namespace Catch {
12431: 
12432: namespace {
12433: 
12434: // Formatter impl for ConsoleReporter
12435: class ConsoleAssertionPrinter {
12436: public:
12437:     ConsoleAssertionPrinter& operator= (ConsoleAssertionPrinter const&) = delete;
12438:     ConsoleAssertionPrinter(ConsoleAssertionPrinter const&) = delete;
12439:     ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
12440:         : stream(_stream),
12441:         stats(_stats),
12442:         result(_stats.assertionResult),
12443:         colour(Colour::None),
12444:         message(result.getMessage()),
12445:         messages(_stats.infoMessages),
12446:         printInfoMessages(_printInfoMessages) {
12447:         switch (result.getResultType()) {
12448:         case ResultWas::Ok:
12449:             colour = Colour::Success;
12450:             passOrFail = "PASSED";
12451:             //if( result.hasMessage() )
12452:             if (_stats.infoMessages.size() == 1)
12453:                 messageLabel = "with message";
12454:             if (_stats.infoMessages.size() > 1)
12455:                 messageLabel = "with messages";
12456:             break;
12457:         case ResultWas::ExpressionFailed:
12458:             if (result.isOk()) {
12459:                 colour = Colour::Success;
12460:                 passOrFail = "FAILED - but was ok";
12461:             } else {
12462:                 colour = Colour::Error;
12463:                 passOrFail = "FAILED";
12464:             }
12465:             if (_stats.infoMessages.size() == 1)
12466:                 messageLabel = "with message";
12467:             if (_stats.infoMessages.size() > 1)
12468:                 messageLabel = "with messages";
12469:             break;
12470:         case ResultWas::ThrewException:
12471:             colour = Colour::Error;
12472:             passOrFail = "FAILED";
12473:             messageLabel = "due to unexpected exception with ";
12474:             if (_stats.infoMessages.size() == 1)
12475:                 messageLabel += "message";
12476:             if (_stats.infoMessages.size() > 1)
12477:                 messageLabel += "messages";
12478:             break;
12479:         case ResultWas::FatalErrorCondition:
12480:             colour = Colour::Error;
12481:             passOrFail = "FAILED";
12482:             messageLabel = "due to a fatal error condition";
12483:             break;
12484:         case ResultWas::DidntThrowException:
12485:             colour = Colour::Error;
12486:             passOrFail = "FAILED";
12487:             messageLabel = "because no exception was thrown where one was expected";
12488:             break;
12489:         case ResultWas::Info:
12490:             messageLabel = "info";
12491:             break;
12492:         case ResultWas::Warning:
12493:             messageLabel = "warning";
12494:             break;
12495:         case ResultWas::ExplicitFailure:
12496:             passOrFail = "FAILED";
12497:             colour = Colour::Error;
12498:             if (_stats.infoMessages.size() == 1)
12499:                 messageLabel = "explicitly with message";
12500:             if (_stats.infoMessages.size() > 1)
12501:                 messageLabel = "explicitly with messages";
12502:             break;
12503:             // These cases are here to prevent compiler warnings
12504:         case ResultWas::Unknown:
12505:         case ResultWas::FailureBit:
12506:         case ResultWas::Exception:
12507:             passOrFail = "** internal error **";
12508:             colour = Colour::Error;
12509:             break;
12510:         }
12511:     }
12512: 
12513:     void print() const {
12514:         printSourceInfo();
12515:         if (stats.totals.assertions.total() > 0) {
12516:             if (result.isOk())
12517:                 stream << '\n';
12518:             printResultType();
12519:             printOriginalExpression();
12520:             printReconstructedExpression();
12521:         } else {
12522:             stream << '\n';
12523:         }
12524:         printMessage();
12525:     }
12526: 
12527: private:
12528:     void printResultType() const {
12529:         if (!passOrFail.empty()) {
12530:             Colour colourGuard(colour);
12531:             stream << passOrFail << ":\n";
12532:         }
12533:     }
12534:     void printOriginalExpression() const {
12535:         if (result.hasExpression()) {
12536:             Colour colourGuard(Colour::OriginalExpression);
12537:             stream << "  ";
12538:             stream << result.getExpressionInMacro();
12539:             stream << '\n';
12540:         }
12541:     }
12542:     void printReconstructedExpression() const {
12543:         if (result.hasExpandedExpression()) {
12544:             stream << "with expansion:\n";
12545:             Colour colourGuard(Colour::ReconstructedExpression);
12546:             stream << Column(result.getExpandedExpression()).indent(2) << '\n';
12547:         }
12548:     }
12549:     void printMessage() const {
12550:         if (!messageLabel.empty())
12551:             stream << messageLabel << ':' << '\n';
12552:         for (auto const& msg : messages) {
12553:             // If this assertion is a warning ignore any INFO messages
12554:             if (printInfoMessages || msg.type != ResultWas::Info)
12555:                 stream << Column(msg.message).indent(2) << '\n';
12556:         }
12557:     }
12558:     void printSourceInfo() const {
12559:         Colour colourGuard(Colour::FileName);
12560:         stream << result.getSourceInfo() << ": ";
12561:     }
12562: 
12563:     std::ostream& stream;
12564:     AssertionStats const& stats;
12565:     AssertionResult const& result;
12566:     Colour::Code colour;
12567:     std::string passOrFail;
12568:     std::string messageLabel;
12569:     std::string message;
12570:     std::vector<MessageInfo> messages;
12571:     bool printInfoMessages;
12572: };
12573: 
12574: std::size_t makeRatio(std::size_t number, std::size_t total) {
12575:     std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;
12576:     return (ratio == 0 && number > 0) ? 1 : ratio;
12577: }
12578: 
12579: std::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) {
12580:     if (i > j && i > k)
12581:         return i;
12582:     else if (j > k)
12583:         return j;
12584:     else
12585:         return k;
12586: }
12587: 
12588: struct ColumnInfo {
12589:     enum Justification { Left, Right };
12590:     std::string name;
12591:     int width;
12592:     Justification justification;
12593: };
12594: struct ColumnBreak {};
12595: struct RowBreak {};
12596: 
12597: class Duration {
12598:     enum class Unit {
12599:         Auto,
12600:         Nanoseconds,
12601:         Microseconds,
12602:         Milliseconds,
12603:         Seconds,
12604:         Minutes
12605:     };
12606:     static const uint64_t s_nanosecondsInAMicrosecond = 1000;
12607:     static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;
12608:     static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;
12609:     static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;
12610: 
12611:     uint64_t m_inNanoseconds;
12612:     Unit m_units;
12613: 
12614: public:
12615:     explicit Duration(uint64_t inNanoseconds, Unit units = Unit::Auto)
12616:         : m_inNanoseconds(inNanoseconds),
12617:         m_units(units) {
12618:         if (m_units == Unit::Auto) {
12619:             if (m_inNanoseconds < s_nanosecondsInAMicrosecond)
12620:                 m_units = Unit::Nanoseconds;
12621:             else if (m_inNanoseconds < s_nanosecondsInAMillisecond)
12622:                 m_units = Unit::Microseconds;
12623:             else if (m_inNanoseconds < s_nanosecondsInASecond)
12624:                 m_units = Unit::Milliseconds;
12625:             else if (m_inNanoseconds < s_nanosecondsInAMinute)
12626:                 m_units = Unit::Seconds;
12627:             else
12628:                 m_units = Unit::Minutes;
12629:         }
12630: 
12631:     }
12632: 
12633:     auto value() const -> double {
12634:         switch (m_units) {
12635:         case Unit::Microseconds:
12636:             return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMicrosecond);
12637:         case Unit::Milliseconds:
12638:             return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMillisecond);
12639:         case Unit::Seconds:
12640:             return m_inNanoseconds / static_cast<double>(s_nanosecondsInASecond);
12641:         case Unit::Minutes:
12642:             return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMinute);
12643:         default:
12644:             return static_cast<double>(m_inNanoseconds);
12645:         }
12646:     }
12647:     auto unitsAsString() const -> std::string {
12648:         switch (m_units) {
12649:         case Unit::Nanoseconds:
12650:             return "ns";
12651:         case Unit::Microseconds:
12652:             return "µs";
12653:         case Unit::Milliseconds:
12654:             return "ms";
12655:         case Unit::Seconds:
12656:             return "s";
12657:         case Unit::Minutes:
12658:             return "m";
12659:         default:
12660:             return "** internal error **";
12661:         }
12662: 
12663:     }
12664:     friend auto operator << (std::ostream& os, Duration const& duration) -> std::ostream& {
12665:         return os << duration.value() << " " << duration.unitsAsString();
12666:     }
12667: };
12668: } // end anon namespace
12669: 
12670: class TablePrinter {
12671:     std::ostream& m_os;
12672:     std::vector<ColumnInfo> m_columnInfos;
12673:     std::ostringstream m_oss;
12674:     int m_currentColumn = -1;
12675:     bool m_isOpen = false;
12676: 
12677: public:
12678:     TablePrinter( std::ostream& os, std::vector<ColumnInfo> columnInfos )
12679:     :   m_os( os ),
12680:         m_columnInfos( std::move( columnInfos ) ) {}
12681: 
12682:     auto columnInfos() const -> std::vector<ColumnInfo> const& {
12683:         return m_columnInfos;
12684:     }
12685: 
12686:     void open() {
12687:         if (!m_isOpen) {
12688:             m_isOpen = true;
12689:             *this << RowBreak();
12690:             for (auto const& info : m_columnInfos)
12691:                 *this << info.name << ColumnBreak();
12692:             *this << RowBreak();
12693:             m_os << Catch::getLineOfChars<'-'>() << "\n";
12694:         }
12695:     }
12696:     void close() {
12697:         if (m_isOpen) {
12698:             *this << RowBreak();
12699:             m_os << std::endl;
12700:             m_isOpen = false;
12701:         }
12702:     }
12703: 
12704:     template<typename T>
12705:     friend TablePrinter& operator << (TablePrinter& tp, T const& value) {
12706:         tp.m_oss << value;
12707:         return tp;
12708:     }
12709: 
12710:     friend TablePrinter& operator << (TablePrinter& tp, ColumnBreak) {
12711:         auto colStr = tp.m_oss.str();
12712:         // This takes account of utf8 encodings
12713:         auto strSize = Catch::StringRef(colStr).numberOfCharacters();
12714:         tp.m_oss.str("");
12715:         tp.open();
12716:         if (tp.m_currentColumn == static_cast<int>(tp.m_columnInfos.size() - 1)) {
12717:             tp.m_currentColumn = -1;
12718:             tp.m_os << "\n";
12719:         }
12720:         tp.m_currentColumn++;
12721: 
12722:         auto colInfo = tp.m_columnInfos[tp.m_currentColumn];
12723:         auto padding = (strSize + 2 < static_cast<std::size_t>(colInfo.width))
12724:             ? std::string(colInfo.width - (strSize + 2), ' ')
12725:             : std::string();
12726:         if (colInfo.justification == ColumnInfo::Left)
12727:             tp.m_os << colStr << padding << " ";
12728:         else
12729:             tp.m_os << padding << colStr << " ";
12730:         return tp;
12731:     }
12732: 
12733:     friend TablePrinter& operator << (TablePrinter& tp, RowBreak) {
12734:         if (tp.m_currentColumn > 0) {
12735:             tp.m_os << "\n";
12736:             tp.m_currentColumn = -1;
12737:         }
12738:         return tp;
12739:     }
12740: };
12741: 
12742: ConsoleReporter::ConsoleReporter(ReporterConfig const& config)
12743:     : StreamingReporterBase(config),
12744:     m_tablePrinter(new TablePrinter(config.stream(),
12745:     {
12746:         { "benchmark name", CATCH_CONFIG_CONSOLE_WIDTH - 32, ColumnInfo::Left },
12747:         { "iters", 8, ColumnInfo::Right },
12748:         { "elapsed ns", 14, ColumnInfo::Right },
12749:         { "average", 14, ColumnInfo::Right }
12750:     })) {}
12751: ConsoleReporter::~ConsoleReporter() = default;
12752: 
12753: std::string ConsoleReporter::getDescription() {
12754:     return "Reports test results as plain lines of text";
12755: }
12756: 
12757: void ConsoleReporter::noMatchingTestCases(std::string const& spec) {
12758:     stream << "No test cases matched '" << spec << '\'' << std::endl;
12759: }
12760: 
12761: void ConsoleReporter::assertionStarting(AssertionInfo const&) {}
12762: 
12763: bool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {
12764:     AssertionResult const& result = _assertionStats.assertionResult;
12765: 
12766:     bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();
12767: 
12768:     // Drop out if result was successful but we're not printing them.
12769:     if (!includeResults && result.getResultType() != ResultWas::Warning)
12770:         return false;
12771: 
12772:     lazyPrint();
12773: 
12774:     ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);
12775:     printer.print();
12776:     stream << std::endl;
12777:     return true;
12778: }
12779: 
12780: void ConsoleReporter::sectionStarting(SectionInfo const& _sectionInfo) {
12781:     m_headerPrinted = false;
12782:     StreamingReporterBase::sectionStarting(_sectionInfo);
12783: }
12784: void ConsoleReporter::sectionEnded(SectionStats const& _sectionStats) {
12785:     m_tablePrinter->close();
12786:     if (_sectionStats.missingAssertions) {
12787:         lazyPrint();
12788:         Colour colour(Colour::ResultError);
12789:         if (m_sectionStack.size() > 1)
12790:             stream << "\nNo assertions in section";
12791:         else
12792:             stream << "\nNo assertions in test case";
12793:         stream << " '" << _sectionStats.sectionInfo.name << "'\n" << std::endl;
12794:     }
12795:     if (m_config->showDurations() == ShowDurations::Always) {
12796:         stream << getFormattedDuration(_sectionStats.durationInSeconds) << " s: " << _sectionStats.sectionInfo.name << std::endl;
12797:     }
12798:     if (m_headerPrinted) {
12799:         m_headerPrinted = false;
12800:     }
12801:     StreamingReporterBase::sectionEnded(_sectionStats);
12802: }
12803: 
12804: void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {
12805:     lazyPrintWithoutClosingBenchmarkTable();
12806: 
12807:     auto nameCol = Column( info.name ).width( static_cast<std::size_t>( m_tablePrinter->columnInfos()[0].width - 2 ) );
12808: 
12809:     bool firstLine = true;
12810:     for (auto line : nameCol) {
12811:         if (!firstLine)
12812:             (*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();
12813:         else
12814:             firstLine = false;
12815: 
12816:         (*m_tablePrinter) << line << ColumnBreak();
12817:     }
12818: }
12819: void ConsoleReporter::benchmarkEnded(BenchmarkStats const& stats) {
12820:     Duration average(stats.elapsedTimeInNanoseconds / stats.iterations);
12821:     (*m_tablePrinter)
12822:         << stats.iterations << ColumnBreak()
12823:         << stats.elapsedTimeInNanoseconds << ColumnBreak()
12824:         << average << ColumnBreak();
12825: }
12826: 
12827: void ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {
12828:     m_tablePrinter->close();
12829:     StreamingReporterBase::testCaseEnded(_testCaseStats);
12830:     m_headerPrinted = false;
12831: }
12832: void ConsoleReporter::testGroupEnded(TestGroupStats const& _testGroupStats) {
12833:     if (currentGroupInfo.used) {
12834:         printSummaryDivider();
12835:         stream << "Summary for group '" << _testGroupStats.groupInfo.name << "':\n";
12836:         printTotals(_testGroupStats.totals);
12837:         stream << '\n' << std::endl;
12838:     }
12839:     StreamingReporterBase::testGroupEnded(_testGroupStats);
12840: }
12841: void ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {
12842:     printTotalsDivider(_testRunStats.totals);
12843:     printTotals(_testRunStats.totals);
12844:     stream << std::endl;
12845:     StreamingReporterBase::testRunEnded(_testRunStats);
12846: }
12847: 
12848: void ConsoleReporter::lazyPrint() {
12849: 
12850:     m_tablePrinter->close();
12851:     lazyPrintWithoutClosingBenchmarkTable();
12852: }
12853: 
12854: void ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() {
12855: 
12856:     if (!currentTestRunInfo.used)
12857:         lazyPrintRunInfo();
12858:     if (!currentGroupInfo.used)
12859:         lazyPrintGroupInfo();
12860: 
12861:     if (!m_headerPrinted) {
12862:         printTestCaseAndSectionHeader();
12863:         m_headerPrinted = true;
12864:     }
12865: }
12866: void ConsoleReporter::lazyPrintRunInfo() {
12867:     stream << '\n' << getLineOfChars<'~'>() << '\n';
12868:     Colour colour(Colour::SecondaryText);
12869:     stream << currentTestRunInfo->name
12870:         << " is a Catch v" << libraryVersion() << " host application.\n"
12871:         << "Run with -? for options\n\n";
12872: 
12873:     if (m_config->rngSeed() != 0)
12874:         stream << "Randomness seeded to: " << m_config->rngSeed() << "\n\n";
12875: 
12876:     currentTestRunInfo.used = true;
12877: }
12878: void ConsoleReporter::lazyPrintGroupInfo() {
12879:     if (!currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1) {
12880:         printClosedHeader("Group: " + currentGroupInfo->name);
12881:         currentGroupInfo.used = true;
12882:     }
12883: }
12884: void ConsoleReporter::printTestCaseAndSectionHeader() {
12885:     assert(!m_sectionStack.empty());
12886:     printOpenHeader(currentTestCaseInfo->name);
12887: 
12888:     if (m_sectionStack.size() > 1) {
12889:         Colour colourGuard(Colour::Headers);
12890: 
12891:         auto
12892:             it = m_sectionStack.begin() + 1, // Skip first section (test case)
12893:             itEnd = m_sectionStack.end();
12894:         for (; it != itEnd; ++it)
12895:             printHeaderString(it->name, 2);
12896:     }
12897: 
12898:     SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;
12899: 
12900:     if (!lineInfo.empty()) {
12901:         stream << getLineOfChars<'-'>() << '\n';
12902:         Colour colourGuard(Colour::FileName);
12903:         stream << lineInfo << '\n';
12904:     }
12905:     stream << getLineOfChars<'.'>() << '\n' << std::endl;
12906: }
12907: 
12908: void ConsoleReporter::printClosedHeader(std::string const& _name) {
12909:     printOpenHeader(_name);
12910:     stream << getLineOfChars<'.'>() << '\n';
12911: }
12912: void ConsoleReporter::printOpenHeader(std::string const& _name) {
12913:     stream << getLineOfChars<'-'>() << '\n';
12914:     {
12915:         Colour colourGuard(Colour::Headers);
12916:         printHeaderString(_name);
12917:     }
12918: }
12919: 
12920: // if string has a : in first line will set indent to follow it on
12921: // subsequent lines
12922: void ConsoleReporter::printHeaderString(std::string const& _string, std::size_t indent) {
12923:     std::size_t i = _string.find(": ");
12924:     if (i != std::string::npos)
12925:         i += 2;
12926:     else
12927:         i = 0;
12928:     stream << Column(_string).indent(indent + i).initialIndent(indent) << '\n';
12929: }
12930: 
12931: struct SummaryColumn {
12932: 
12933:     SummaryColumn( std::string _label, Colour::Code _colour )
12934:     :   label( std::move( _label ) ),
12935:         colour( _colour ) {}
12936:     SummaryColumn addRow( std::size_t count ) {
12937:         ReusableStringStream rss;
12938:         rss << count;
12939:         std::string row = rss.str();
12940:         for (auto& oldRow : rows) {
12941:             while (oldRow.size() < row.size())
12942:                 oldRow = ' ' + oldRow;
12943:             while (oldRow.size() > row.size())
12944:                 row = ' ' + row;
12945:         }
12946:         rows.push_back(row);
12947:         return *this;
12948:     }
12949: 
12950:     std::string label;
12951:     Colour::Code colour;
12952:     std::vector<std::string> rows;
12953: 
12954: };
12955: 
12956: void ConsoleReporter::printTotals( Totals const& totals ) {
12957:     if (totals.testCases.total() == 0) {
12958:         stream << Colour(Colour::Warning) << "No tests ran\n";
12959:     } else if (totals.assertions.total() > 0 && totals.testCases.allPassed()) {
12960:         stream << Colour(Colour::ResultSuccess) << "All tests passed";
12961:         stream << " ("
12962:             << pluralise(totals.assertions.passed, "assertion") << " in "
12963:             << pluralise(totals.testCases.passed, "test case") << ')'
12964:             << '\n';
12965:     } else {
12966: 
12967:         std::vector<SummaryColumn> columns;
12968:         columns.push_back(SummaryColumn("", Colour::None)
12969:                           .addRow(totals.testCases.total())
12970:                           .addRow(totals.assertions.total()));
12971:         columns.push_back(SummaryColumn("passed", Colour::Success)
12972:                           .addRow(totals.testCases.passed)
12973:                           .addRow(totals.assertions.passed));
12974:         columns.push_back(SummaryColumn("failed", Colour::ResultError)
12975:                           .addRow(totals.testCases.failed)
12976:                           .addRow(totals.assertions.failed));
12977:         columns.push_back(SummaryColumn("failed as expected", Colour::ResultExpectedFailure)
12978:                           .addRow(totals.testCases.failedButOk)
12979:                           .addRow(totals.assertions.failedButOk));
12980: 
12981:         printSummaryRow("test cases", columns, 0);
12982:         printSummaryRow("assertions", columns, 1);
12983:     }
12984: }
12985: void ConsoleReporter::printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row) {
12986:     for (auto col : cols) {
12987:         std::string value = col.rows[row];
12988:         if (col.label.empty()) {
12989:             stream << label << ": ";
12990:             if (value != "0")
12991:                 stream << value;
12992:             else
12993:                 stream << Colour(Colour::Warning) << "- none -";
12994:         } else if (value != "0") {
12995:             stream << Colour(Colour::LightGrey) << " | ";
12996:             stream << Colour(col.colour)
12997:                 << value << ' ' << col.label;
12998:         }
12999:     }
13000:     stream << '\n';
13001: }
13002: 
13003: void ConsoleReporter::printTotalsDivider(Totals const& totals) {
13004:     if (totals.testCases.total() > 0) {
13005:         std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());
13006:         std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());
13007:         std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());
13008:         while (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)
13009:             findMax(failedRatio, failedButOkRatio, passedRatio)++;
13010:         while (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)
13011:             findMax(failedRatio, failedButOkRatio, passedRatio)--;
13012: 
13013:         stream << Colour(Colour::Error) << std::string(failedRatio, '=');
13014:         stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, '=');
13015:         if (totals.testCases.allPassed())
13016:             stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, '=');
13017:         else
13018:             stream << Colour(Colour::Success) << std::string(passedRatio, '=');
13019:     } else {
13020:         stream << Colour(Colour::Warning) << std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, '=');
13021:     }
13022:     stream << '\n';
13023: }
13024: void ConsoleReporter::printSummaryDivider() {
13025:     stream << getLineOfChars<'-'>() << '\n';
13026: }
13027: 
13028: CATCH_REGISTER_REPORTER("console", ConsoleReporter)
13029: 
13030: } // end namespace Catch
13031: 
13032: #if defined(_MSC_VER)
13033: #pragma warning(pop)
13034: #endif
13035: // end catch_reporter_console.cpp
13036: // start catch_reporter_junit.cpp
13037: 
13038: #include <cassert>
13039: #include <sstream>
13040: #include <ctime>
13041: #include <algorithm>
13042: 
13043: namespace Catch {
13044: 
13045:     namespace {
13046:         std::string getCurrentTimestamp() {
13047:             // Beware, this is not reentrant because of backward compatibility issues
13048:             // Also, UTC only, again because of backward compatibility (%z is C++11)
13049:             time_t rawtime;
13050:             std::time(&rawtime);
13051:             auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");
13052: 
13053: #ifdef _MSC_VER
13054:             std::tm timeInfo = {};
13055:             gmtime_s(&timeInfo, &rawtime);
13056: #else
13057:             std::tm* timeInfo;
13058:             timeInfo = std::gmtime(&rawtime);
13059: #endif
13060: 
13061:             char timeStamp[timeStampSize];
13062:             const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";
13063: 
13064: #ifdef _MSC_VER
13065:             std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
13066: #else
13067:             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
13068: #endif
13069:             return std::string(timeStamp);
13070:         }
13071: 
13072:         std::string fileNameTag(const std::vector<std::string> &tags) {
13073:             auto it = std::find_if(begin(tags),
13074:                                    end(tags),
13075:                                    [] (std::string const& tag) {return tag.front() == '#'; });
13076:             if (it != tags.end())
13077:                 return it->substr(1);
13078:             return std::string();
13079:         }
13080:     } // anonymous namespace
13081: 
13082:     JunitReporter::JunitReporter( ReporterConfig const& _config )
13083:         :   CumulativeReporterBase( _config ),
13084:             xml( _config.stream() )
13085:         {
13086:             m_reporterPrefs.shouldRedirectStdOut = true;
13087:             m_reporterPrefs.shouldReportAllAssertions = true;
13088:         }
13089: 
13090:     JunitReporter::~JunitReporter() {}
13091: 
13092:     std::string JunitReporter::getDescription() {
13093:         return "Reports test results in an XML format that looks like Ant's junitreport target";
13094:     }
13095: 
13096:     void JunitReporter::noMatchingTestCases( std::string const& /*spec*/ ) {}
13097: 
13098:     void JunitReporter::testRunStarting( TestRunInfo const& runInfo )  {
13099:         CumulativeReporterBase::testRunStarting( runInfo );
13100:         xml.startElement( "testsuites" );
13101:     }
13102: 
13103:     void JunitReporter::testGroupStarting( GroupInfo const& groupInfo ) {
13104:         suiteTimer.start();
13105:         stdOutForSuite.clear();
13106:         stdErrForSuite.clear();
13107:         unexpectedExceptions = 0;
13108:         CumulativeReporterBase::testGroupStarting( groupInfo );
13109:     }
13110: 
13111:     void JunitReporter::testCaseStarting( TestCaseInfo const& testCaseInfo ) {
13112:         m_okToFail = testCaseInfo.okToFail();
13113:     }
13114: 
13115:     bool JunitReporter::assertionEnded( AssertionStats const& assertionStats ) {
13116:         if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )
13117:             unexpectedExceptions++;
13118:         return CumulativeReporterBase::assertionEnded( assertionStats );
13119:     }
13120: 
13121:     void JunitReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
13122:         stdOutForSuite += testCaseStats.stdOut;
13123:         stdErrForSuite += testCaseStats.stdErr;
13124:         CumulativeReporterBase::testCaseEnded( testCaseStats );
13125:     }
13126: 
13127:     void JunitReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
13128:         double suiteTime = suiteTimer.getElapsedSeconds();
13129:         CumulativeReporterBase::testGroupEnded( testGroupStats );
13130:         writeGroup( *m_testGroups.back(), suiteTime );
13131:     }
13132: 
13133:     void JunitReporter::testRunEndedCumulative() {
13134:         xml.endElement();
13135:     }
13136: 
13137:     void JunitReporter::writeGroup( TestGroupNode const& groupNode, double suiteTime ) {
13138:         XmlWriter::ScopedElement e = xml.scopedElement( "testsuite" );
13139:         TestGroupStats const& stats = groupNode.value;
13140:         xml.writeAttribute( "name", stats.groupInfo.name );
13141:         xml.writeAttribute( "errors", unexpectedExceptions );
13142:         xml.writeAttribute( "failures", stats.totals.assertions.failed-unexpectedExceptions );
13143:         xml.writeAttribute( "tests", stats.totals.assertions.total() );
13144:         xml.writeAttribute( "hostname", "tbd" ); // !TBD
13145:         if( m_config->showDurations() == ShowDurations::Never )
13146:             xml.writeAttribute( "time", "" );
13147:         else
13148:             xml.writeAttribute( "time", suiteTime );
13149:         xml.writeAttribute( "timestamp", getCurrentTimestamp() );
13150: 
13151:         // Write test cases
13152:         for( auto const& child : groupNode.children )
13153:             writeTestCase( *child );
13154: 
13155:         xml.scopedElement( "system-out" ).writeText( trim( stdOutForSuite ), false );
13156:         xml.scopedElement( "system-err" ).writeText( trim( stdErrForSuite ), false );
13157:     }
13158: 
13159:     void JunitReporter::writeTestCase( TestCaseNode const& testCaseNode ) {
13160:         TestCaseStats const& stats = testCaseNode.value;
13161: 
13162:         // All test cases have exactly one section - which represents the
13163:         // test case itself. That section may have 0-n nested sections
13164:         assert( testCaseNode.children.size() == 1 );
13165:         SectionNode const& rootSection = *testCaseNode.children.front();
13166: 
13167:         std::string className = stats.testInfo.className;
13168: 
13169:         if( className.empty() ) {
13170:             className = fileNameTag(stats.testInfo.tags);
13171:             if ( className.empty() )
13172:                 className = "global";
13173:         }
13174: 
13175:         if ( !m_config->name().empty() )
13176:             className = m_config->name() + "." + className;
13177: 
13178:         writeSection( className, "", rootSection );
13179:     }
13180: 
13181:     void JunitReporter::writeSection(  std::string const& className,
13182:                         std::string const& rootName,
13183:                         SectionNode const& sectionNode ) {
13184:         std::string name = trim( sectionNode.stats.sectionInfo.name );
13185:         if( !rootName.empty() )
13186:             name = rootName + '/' + name;
13187: 
13188:         if( !sectionNode.assertions.empty() ||
13189:             !sectionNode.stdOut.empty() ||
13190:             !sectionNode.stdErr.empty() ) {
13191:             XmlWriter::ScopedElement e = xml.scopedElement( "testcase" );
13192:             if( className.empty() ) {
13193:                 xml.writeAttribute( "classname", name );
13194:                 xml.writeAttribute( "name", "root" );
13195:             }
13196:             else {
13197:                 xml.writeAttribute( "classname", className );
13198:                 xml.writeAttribute( "name", name );
13199:             }
13200:             xml.writeAttribute( "time", ::Catch::Detail::stringify( sectionNode.stats.durationInSeconds ) );
13201: 
13202:             writeAssertions( sectionNode );
13203: 
13204:             if( !sectionNode.stdOut.empty() )
13205:                 xml.scopedElement( "system-out" ).writeText( trim( sectionNode.stdOut ), false );
13206:             if( !sectionNode.stdErr.empty() )
13207:                 xml.scopedElement( "system-err" ).writeText( trim( sectionNode.stdErr ), false );
13208:         }
13209:         for( auto const& childNode : sectionNode.childSections )
13210:             if( className.empty() )
13211:                 writeSection( name, "", *childNode );
13212:             else
13213:                 writeSection( className, name, *childNode );
13214:     }
13215: 
13216:     void JunitReporter::writeAssertions( SectionNode const& sectionNode ) {
13217:         for( auto const& assertion : sectionNode.assertions )
13218:             writeAssertion( assertion );
13219:     }
13220: 
13221:     void JunitReporter::writeAssertion( AssertionStats const& stats ) {
13222:         AssertionResult const& result = stats.assertionResult;
13223:         if( !result.isOk() ) {
13224:             std::string elementName;
13225:             switch( result.getResultType() ) {
13226:                 case ResultWas::ThrewException:
13227:                 case ResultWas::FatalErrorCondition:
13228:                     elementName = "error";
13229:                     break;
13230:                 case ResultWas::ExplicitFailure:
13231:                     elementName = "failure";
13232:                     break;
13233:                 case ResultWas::ExpressionFailed:
13234:                     elementName = "failure";
13235:                     break;
13236:                 case ResultWas::DidntThrowException:
13237:                     elementName = "failure";
13238:                     break;
13239: 
13240:                 // We should never see these here:
13241:                 case ResultWas::Info:
13242:                 case ResultWas::Warning:
13243:                 case ResultWas::Ok:
13244:                 case ResultWas::Unknown:
13245:                 case ResultWas::FailureBit:
13246:                 case ResultWas::Exception:
13247:                     elementName = "internalError";
13248:                     break;
13249:             }
13250: 
13251:             XmlWriter::ScopedElement e = xml.scopedElement( elementName );
13252: 
13253:             xml.writeAttribute( "message", result.getExpandedExpression() );
13254:             xml.writeAttribute( "type", result.getTestMacroName() );
13255: 
13256:             ReusableStringStream rss;
13257:             if( !result.getMessage().empty() )
13258:                 rss << result.getMessage() << '\n';
13259:             for( auto const& msg : stats.infoMessages )
13260:                 if( msg.type == ResultWas::Info )
13261:                     rss << msg.message << '\n';
13262: 
13263:             rss << "at " << result.getSourceInfo();
13264:             xml.writeText( rss.str(), false );
13265:         }
13266:     }
13267: 
13268:     CATCH_REGISTER_REPORTER( "junit", JunitReporter )
13269: 
13270: } // end namespace Catch
13271: // end catch_reporter_junit.cpp
13272: // start catch_reporter_listening.cpp
13273: 
13274: #include <cassert>
13275: 
13276: namespace Catch {
13277: 
13278:     ListeningReporter::ListeningReporter() {
13279:         // We will assume that listeners will always want all assertions
13280:         m_preferences.shouldReportAllAssertions = true;
13281:     }
13282: 
13283:     void ListeningReporter::addListener( IStreamingReporterPtr&& listener ) {
13284:         m_listeners.push_back( std::move( listener ) );
13285:     }
13286: 
13287:     void ListeningReporter::addReporter(IStreamingReporterPtr&& reporter) {
13288:         assert(!m_reporter && "Listening reporter can wrap only 1 real reporter");
13289:         m_reporter = std::move( reporter );
13290:         m_preferences.shouldRedirectStdOut = m_reporter->getPreferences().shouldRedirectStdOut;
13291:     }
13292: 
13293:     ReporterPreferences ListeningReporter::getPreferences() const {
13294:         return m_preferences;
13295:     }
13296: 
13297:     std::set<Verbosity> ListeningReporter::getSupportedVerbosities() {
13298:         return std::set<Verbosity>{ };
13299:     }
13300: 
13301:     void ListeningReporter::noMatchingTestCases( std::string const& spec ) {
13302:         for ( auto const& listener : m_listeners ) {
13303:             listener->noMatchingTestCases( spec );
13304:         }
13305:         m_reporter->noMatchingTestCases( spec );
13306:     }
13307: 
13308:     void ListeningReporter::benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) {
13309:         for ( auto const& listener : m_listeners ) {
13310:             listener->benchmarkStarting( benchmarkInfo );
13311:         }
13312:         m_reporter->benchmarkStarting( benchmarkInfo );
13313:     }
13314:     void ListeningReporter::benchmarkEnded( BenchmarkStats const& benchmarkStats ) {
13315:         for ( auto const& listener : m_listeners ) {
13316:             listener->benchmarkEnded( benchmarkStats );
13317:         }
13318:         m_reporter->benchmarkEnded( benchmarkStats );
13319:     }
13320: 
13321:     void ListeningReporter::testRunStarting( TestRunInfo const& testRunInfo ) {
13322:         for ( auto const& listener : m_listeners ) {
13323:             listener->testRunStarting( testRunInfo );
13324:         }
13325:         m_reporter->testRunStarting( testRunInfo );
13326:     }
13327: 
13328:     void ListeningReporter::testGroupStarting( GroupInfo const& groupInfo ) {
13329:         for ( auto const& listener : m_listeners ) {
13330:             listener->testGroupStarting( groupInfo );
13331:         }
13332:         m_reporter->testGroupStarting( groupInfo );
13333:     }
13334: 
13335:     void ListeningReporter::testCaseStarting( TestCaseInfo const& testInfo ) {
13336:         for ( auto const& listener : m_listeners ) {
13337:             listener->testCaseStarting( testInfo );
13338:         }
13339:         m_reporter->testCaseStarting( testInfo );
13340:     }
13341: 
13342:     void ListeningReporter::sectionStarting( SectionInfo const& sectionInfo ) {
13343:         for ( auto const& listener : m_listeners ) {
13344:             listener->sectionStarting( sectionInfo );
13345:         }
13346:         m_reporter->sectionStarting( sectionInfo );
13347:     }
13348: 
13349:     void ListeningReporter::assertionStarting( AssertionInfo const& assertionInfo ) {
13350:         for ( auto const& listener : m_listeners ) {
13351:             listener->assertionStarting( assertionInfo );
13352:         }
13353:         m_reporter->assertionStarting( assertionInfo );
13354:     }
13355: 
13356:     // The return value indicates if the messages buffer should be cleared:
13357:     bool ListeningReporter::assertionEnded( AssertionStats const& assertionStats ) {
13358:         for( auto const& listener : m_listeners ) {
13359:             static_cast<void>( listener->assertionEnded( assertionStats ) );
13360:         }
13361:         return m_reporter->assertionEnded( assertionStats );
13362:     }
13363: 
13364:     void ListeningReporter::sectionEnded( SectionStats const& sectionStats ) {
13365:         for ( auto const& listener : m_listeners ) {
13366:             listener->sectionEnded( sectionStats );
13367:         }
13368:         m_reporter->sectionEnded( sectionStats );
13369:     }
13370: 
13371:     void ListeningReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
13372:         for ( auto const& listener : m_listeners ) {
13373:             listener->testCaseEnded( testCaseStats );
13374:         }
13375:         m_reporter->testCaseEnded( testCaseStats );
13376:     }
13377: 
13378:     void ListeningReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
13379:         for ( auto const& listener : m_listeners ) {
13380:             listener->testGroupEnded( testGroupStats );
13381:         }
13382:         m_reporter->testGroupEnded( testGroupStats );
13383:     }
13384: 
13385:     void ListeningReporter::testRunEnded( TestRunStats const& testRunStats ) {
13386:         for ( auto const& listener : m_listeners ) {
13387:             listener->testRunEnded( testRunStats );
13388:         }
13389:         m_reporter->testRunEnded( testRunStats );
13390:     }
13391: 
13392:     void ListeningReporter::skipTest( TestCaseInfo const& testInfo ) {
13393:         for ( auto const& listener : m_listeners ) {
13394:             listener->skipTest( testInfo );
13395:         }
13396:         m_reporter->skipTest( testInfo );
13397:     }
13398: 
13399:     bool ListeningReporter::isMulti() const {
13400:         return true;
13401:     }
13402: 
13403: } // end namespace Catch
13404: // end catch_reporter_listening.cpp
13405: // start catch_reporter_xml.cpp
13406: 
13407: #if defined(_MSC_VER)
13408: #pragma warning(push)
13409: #pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
13410:                               // Note that 4062 (not all labels are handled
13411:                               // and default is missing) is enabled
13412: #endif
13413: 
13414: namespace Catch {
13415:     XmlReporter::XmlReporter( ReporterConfig const& _config )
13416:     :   StreamingReporterBase( _config ),
13417:         m_xml(_config.stream())
13418:     {
13419:         m_reporterPrefs.shouldRedirectStdOut = true;
13420:         m_reporterPrefs.shouldReportAllAssertions = true;
13421:     }
13422: 
13423:     XmlReporter::~XmlReporter() = default;
13424: 
13425:     std::string XmlReporter::getDescription() {
13426:         return "Reports test results as an XML document";
13427:     }
13428: 
13429:     std::string XmlReporter::getStylesheetRef() const {
13430:         return std::string();
13431:     }
13432: 
13433:     void XmlReporter::writeSourceInfo( SourceLineInfo const& sourceInfo ) {
13434:         m_xml
13435:             .writeAttribute( "filename", sourceInfo.file )
13436:             .writeAttribute( "line", sourceInfo.line );
13437:     }
13438: 
13439:     void XmlReporter::noMatchingTestCases( std::string const& s ) {
13440:         StreamingReporterBase::noMatchingTestCases( s );
13441:     }
13442: 
13443:     void XmlReporter::testRunStarting( TestRunInfo const& testInfo ) {
13444:         StreamingReporterBase::testRunStarting( testInfo );
13445:         std::string stylesheetRef = getStylesheetRef();
13446:         if( !stylesheetRef.empty() )
13447:             m_xml.writeStylesheetRef( stylesheetRef );
13448:         m_xml.startElement( "Catch" );
13449:         if( !m_config->name().empty() )
13450:             m_xml.writeAttribute( "name", m_config->name() );
13451:     }
13452: 
13453:     void XmlReporter::testGroupStarting( GroupInfo const& groupInfo ) {
13454:         StreamingReporterBase::testGroupStarting( groupInfo );
13455:         m_xml.startElement( "Group" )
13456:             .writeAttribute( "name", groupInfo.name );
13457:     }
13458: 
13459:     void XmlReporter::testCaseStarting( TestCaseInfo const& testInfo ) {
13460:         StreamingReporterBase::testCaseStarting(testInfo);
13461:         m_xml.startElement( "TestCase" )
13462:             .writeAttribute( "name", trim( testInfo.name ) )
13463:             .writeAttribute( "description", testInfo.description )
13464:             .writeAttribute( "tags", testInfo.tagsAsString() );
13465: 
13466:         writeSourceInfo( testInfo.lineInfo );
13467: 
13468:         if ( m_config->showDurations() == ShowDurations::Always )
13469:             m_testCaseTimer.start();
13470:         m_xml.ensureTagClosed();
13471:     }
13472: 
13473:     void XmlReporter::sectionStarting( SectionInfo const& sectionInfo ) {
13474:         StreamingReporterBase::sectionStarting( sectionInfo );
13475:         if( m_sectionDepth++ > 0 ) {
13476:             m_xml.startElement( "Section" )
13477:                 .writeAttribute( "name", trim( sectionInfo.name ) );
13478:             writeSourceInfo( sectionInfo.lineInfo );
13479:             m_xml.ensureTagClosed();
13480:         }
13481:     }
13482: 
13483:     void XmlReporter::assertionStarting( AssertionInfo const& ) { }
13484: 
13485:     bool XmlReporter::assertionEnded( AssertionStats const& assertionStats ) {
13486: 
13487:         AssertionResult const& result = assertionStats.assertionResult;
13488: 
13489:         bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();
13490: 
13491:         if( includeResults || result.getResultType() == ResultWas::Warning ) {
13492:             // Print any info messages in <Info> tags.
13493:             for( auto const& msg : assertionStats.infoMessages ) {
13494:                 if( msg.type == ResultWas::Info && includeResults ) {
13495:                     m_xml.scopedElement( "Info" )
13496:                             .writeText( msg.message );
13497:                 } else if ( msg.type == ResultWas::Warning ) {
13498:                     m_xml.scopedElement( "Warning" )
13499:                             .writeText( msg.message );
13500:                 }
13501:             }
13502:         }
13503: 
13504:         // Drop out if result was successful but we're not printing them.
13505:         if( !includeResults && result.getResultType() != ResultWas::Warning )
13506:             return true;
13507: 
13508:         // Print the expression if there is one.
13509:         if( result.hasExpression() ) {
13510:             m_xml.startElement( "Expression" )
13511:                 .writeAttribute( "success", result.succeeded() )
13512:                 .writeAttribute( "type", result.getTestMacroName() );
13513: 
13514:             writeSourceInfo( result.getSourceInfo() );
13515: 
13516:             m_xml.scopedElement( "Original" )
13517:                 .writeText( result.getExpression() );
13518:             m_xml.scopedElement( "Expanded" )
13519:                 .writeText( result.getExpandedExpression() );
13520:         }
13521: 
13522:         // And... Print a result applicable to each result type.
13523:         switch( result.getResultType() ) {
13524:             case ResultWas::ThrewException:
13525:                 m_xml.startElement( "Exception" );
13526:                 writeSourceInfo( result.getSourceInfo() );
13527:                 m_xml.writeText( result.getMessage() );
13528:                 m_xml.endElement();
13529:                 break;
13530:             case ResultWas::FatalErrorCondition:
13531:                 m_xml.startElement( "FatalErrorCondition" );
13532:                 writeSourceInfo( result.getSourceInfo() );
13533:                 m_xml.writeText( result.getMessage() );
13534:                 m_xml.endElement();
13535:                 break;
13536:             case ResultWas::Info:
13537:                 m_xml.scopedElement( "Info" )
13538:                     .writeText( result.getMessage() );
13539:                 break;
13540:             case ResultWas::Warning:
13541:                 // Warning will already have been written
13542:                 break;
13543:             case ResultWas::ExplicitFailure:
13544:                 m_xml.startElement( "Failure" );
13545:                 writeSourceInfo( result.getSourceInfo() );
13546:                 m_xml.writeText( result.getMessage() );
13547:                 m_xml.endElement();
13548:                 break;
13549:             default:
13550:                 break;
13551:         }
13552: 
13553:         if( result.hasExpression() )
13554:             m_xml.endElement();
13555: 
13556:         return true;
13557:     }
13558: 
13559:     void XmlReporter::sectionEnded( SectionStats const& sectionStats ) {
13560:         StreamingReporterBase::sectionEnded( sectionStats );
13561:         if( --m_sectionDepth > 0 ) {
13562:             XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResults" );
13563:             e.writeAttribute( "successes", sectionStats.assertions.passed );
13564:             e.writeAttribute( "failures", sectionStats.assertions.failed );
13565:             e.writeAttribute( "expectedFailures", sectionStats.assertions.failedButOk );
13566: 
13567:             if ( m_config->showDurations() == ShowDurations::Always )
13568:                 e.writeAttribute( "durationInSeconds", sectionStats.durationInSeconds );
13569: 
13570:             m_xml.endElement();
13571:         }
13572:     }
13573: 
13574:     void XmlReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
13575:         StreamingReporterBase::testCaseEnded( testCaseStats );
13576:         XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResult" );
13577:         e.writeAttribute( "success", testCaseStats.totals.assertions.allOk() );
13578: 
13579:         if ( m_config->showDurations() == ShowDurations::Always )
13580:             e.writeAttribute( "durationInSeconds", m_testCaseTimer.getElapsedSeconds() );
13581: 
13582:         if( !testCaseStats.stdOut.empty() )
13583:             m_xml.scopedElement( "StdOut" ).writeText( trim( testCaseStats.stdOut ), false );
13584:         if( !testCaseStats.stdErr.empty() )
13585:             m_xml.scopedElement( "StdErr" ).writeText( trim( testCaseStats.stdErr ), false );
13586: 
13587:         m_xml.endElement();
13588:     }
13589: 
13590:     void XmlReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
13591:         StreamingReporterBase::testGroupEnded( testGroupStats );
13592:         // TODO: Check testGroupStats.aborting and act accordingly.
13593:         m_xml.scopedElement( "OverallResults" )
13594:             .writeAttribute( "successes", testGroupStats.totals.assertions.passed )
13595:             .writeAttribute( "failures", testGroupStats.totals.assertions.failed )
13596:             .writeAttribute( "expectedFailures", testGroupStats.totals.assertions.failedButOk );
13597:         m_xml.endElement();
13598:     }
13599: 
13600:     void XmlReporter::testRunEnded( TestRunStats const& testRunStats ) {
13601:         StreamingReporterBase::testRunEnded( testRunStats );
13602:         m_xml.scopedElement( "OverallResults" )
13603:             .writeAttribute( "successes", testRunStats.totals.assertions.passed )
13604:             .writeAttribute( "failures", testRunStats.totals.assertions.failed )
13605:             .writeAttribute( "expectedFailures", testRunStats.totals.assertions.failedButOk );
13606:         m_xml.endElement();
13607:     }
13608: 
13609:     CATCH_REGISTER_REPORTER( "xml", XmlReporter )
13610: 
13611: } // end namespace Catch
13612: 
13613: #if defined(_MSC_VER)
13614: #pragma warning(pop)
13615: #endif
13616: // end catch_reporter_xml.cpp
13617: 
13618: namespace Catch {
13619:     LeakDetector leakDetector;
13620: }
13621: 
13622: #ifdef __clang__
13623: #pragma clang diagnostic pop
13624: #endif
13625: 
13626: // end catch_impl.hpp
13627: #endif
13628: 
13629: #ifdef CATCH_CONFIG_MAIN
13630: // start catch_default_main.hpp
13631: 
13632: #ifndef __OBJC__
13633: 
13634: #if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)
13635: // Standard C/C++ Win32 Unicode wmain entry point
13636: extern "C" int wmain (int argc, wchar_t * argv[], wchar_t * []) {
13637: #else
13638: // Standard C/C++ main entry point
13639: int main (int argc, char * argv[]) {
13640: #endif
13641: 
13642:     return Catch::Session().run( argc, argv );
13643: }
13644: 
13645: #else // __OBJC__
13646: 
13647: // Objective-C entry point
13648: int main (int argc, char * const argv[]) {
13649: #if !CATCH_ARC_ENABLED
13650:     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
13651: #endif
13652: 
13653:     Catch::registerTestMethods();
13654:     int result = Catch::Session().run( argc, (char**)argv );
13655: 
13656: #if !CATCH_ARC_ENABLED
13657:     [pool drain];
13658: #endif
13659: 
13660:     return result;
13661: }
13662: 
13663: #endif // __OBJC__
13664: 
13665: // end catch_default_main.hpp
13666: #endif
13667: 
13668: #if !defined(CATCH_CONFIG_IMPL_ONLY)
13669: 
13670: #ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
13671: #  undef CLARA_CONFIG_MAIN
13672: #endif
13673: 
13674: #if !defined(CATCH_CONFIG_DISABLE)
13675: //////
13676: // If this config identifier is defined then all CATCH macros are prefixed with CATCH_
13677: #ifdef CATCH_CONFIG_PREFIX_ALL
13678: 
13679: #define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__ )
13680: #define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13681: 
13682: #define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "CATCH_REQUIRE_THROWS", Catch::ResultDisposition::Normal, "", __VA_ARGS__ )
13683: #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
13684: #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
13685: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13686: #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
13687: #endif// CATCH_CONFIG_DISABLE_MATCHERS
13688: #define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )
13689: 
13690: #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13691: #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13692: #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CATCH_CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13693: #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CATCH_CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13694: #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
13695: 
13696: #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CATCH_CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, "", __VA_ARGS__ )
13697: #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
13698: #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13699: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13700: #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13701: #endif // CATCH_CONFIG_DISABLE_MATCHERS
13702: #define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13703: 
13704: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13705: #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
13706: 
13707: #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
13708: #endif // CATCH_CONFIG_DISABLE_MATCHERS
13709: 
13710: #define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( "CATCH_INFO", msg )
13711: #define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( "CATCH_WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
13712: #define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CATCH_CAPTURE",__VA_ARGS__ )
13713: 
13714: #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
13715: #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
13716: #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
13717: #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
13718: #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
13719: #define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
13720: #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13721: #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13722: #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( "CATCH_SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13723: 
13724: #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
13725: 
13726: // "BDD-style" convenience wrappers
13727: #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )
13728: #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
13729: #define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )
13730: #define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )
13731: #define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )
13732: #define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )
13733: #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )
13734: #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )
13735: 
13736: // If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
13737: #else
13738: 
13739: #define REQUIRE( ... ) INTERNAL_CATCH_TEST( "REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__  )
13740: #define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13741: 
13742: #define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )
13743: #define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
13744: #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
13745: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13746: #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
13747: #endif // CATCH_CONFIG_DISABLE_MATCHERS
13748: #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )
13749: 
13750: #define CHECK( ... ) INTERNAL_CATCH_TEST( "CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13751: #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
13752: #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13753: #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13754: #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
13755: 
13756: #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13757: #define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
13758: #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13759: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13760: #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
13761: #endif // CATCH_CONFIG_DISABLE_MATCHERS
13762: #define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13763: 
13764: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13765: #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
13766: 
13767: #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
13768: #endif // CATCH_CONFIG_DISABLE_MATCHERS
13769: 
13770: #define INFO( msg ) INTERNAL_CATCH_INFO( "INFO", msg )
13771: #define WARN( msg ) INTERNAL_CATCH_MSG( "WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
13772: #define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CAPTURE",__VA_ARGS__ )
13773: 
13774: #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
13775: #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
13776: #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
13777: #define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
13778: #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
13779: #define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
13780: #define FAIL( ... ) INTERNAL_CATCH_MSG( "FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
13781: #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13782: #define SUCCEED( ... ) INTERNAL_CATCH_MSG( "SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
13783: #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
13784: 
13785: #endif
13786: 
13787: #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
13788: 
13789: // "BDD-style" convenience wrappers
13790: #define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
13791: #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
13792: 
13793: #define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )
13794: #define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )
13795: #define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )
13796: #define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )
13797: #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )
13798: #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )
13799: 
13800: using Catch::Detail::Approx;
13801: 
13802: #else // CATCH_CONFIG_DISABLE
13803: 
13804: //////
13805: // If this config identifier is defined then all CATCH macros are prefixed with CATCH_
13806: #ifdef CATCH_CONFIG_PREFIX_ALL
13807: 
13808: #define CATCH_REQUIRE( ... )        (void)(0)
13809: #define CATCH_REQUIRE_FALSE( ... )  (void)(0)
13810: 
13811: #define CATCH_REQUIRE_THROWS( ... ) (void)(0)
13812: #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
13813: #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )     (void)(0)
13814: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13815: #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13816: #endif// CATCH_CONFIG_DISABLE_MATCHERS
13817: #define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)
13818: 
13819: #define CATCH_CHECK( ... )         (void)(0)
13820: #define CATCH_CHECK_FALSE( ... )   (void)(0)
13821: #define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)
13822: #define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))
13823: #define CATCH_CHECK_NOFAIL( ... )  (void)(0)
13824: 
13825: #define CATCH_CHECK_THROWS( ... )  (void)(0)
13826: #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
13827: #define CATCH_CHECK_THROWS_WITH( expr, matcher )     (void)(0)
13828: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13829: #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13830: #endif // CATCH_CONFIG_DISABLE_MATCHERS
13831: #define CATCH_CHECK_NOTHROW( ... ) (void)(0)
13832: 
13833: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13834: #define CATCH_CHECK_THAT( arg, matcher )   (void)(0)
13835: 
13836: #define CATCH_REQUIRE_THAT( arg, matcher ) (void)(0)
13837: #endif // CATCH_CONFIG_DISABLE_MATCHERS
13838: 
13839: #define CATCH_INFO( msg )    (void)(0)
13840: #define CATCH_WARN( msg )    (void)(0)
13841: #define CATCH_CAPTURE( msg ) (void)(0)
13842: 
13843: #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13844: #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13845: #define CATCH_METHOD_AS_TEST_CASE( method, ... )
13846: #define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)
13847: #define CATCH_SECTION( ... )
13848: #define CATCH_DYNAMIC_SECTION( ... )
13849: #define CATCH_FAIL( ... ) (void)(0)
13850: #define CATCH_FAIL_CHECK( ... ) (void)(0)
13851: #define CATCH_SUCCEED( ... ) (void)(0)
13852: 
13853: #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13854: 
13855: // "BDD-style" convenience wrappers
13856: #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13857: #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
13858: #define CATCH_GIVEN( desc )
13859: #define CATCH_AND_GIVEN( desc )
13860: #define CATCH_WHEN( desc )
13861: #define CATCH_AND_WHEN( desc )
13862: #define CATCH_THEN( desc )
13863: #define CATCH_AND_THEN( desc )
13864: 
13865: // If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
13866: #else
13867: 
13868: #define REQUIRE( ... )       (void)(0)
13869: #define REQUIRE_FALSE( ... ) (void)(0)
13870: 
13871: #define REQUIRE_THROWS( ... ) (void)(0)
13872: #define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
13873: #define REQUIRE_THROWS_WITH( expr, matcher ) (void)(0)
13874: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13875: #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13876: #endif // CATCH_CONFIG_DISABLE_MATCHERS
13877: #define REQUIRE_NOTHROW( ... ) (void)(0)
13878: 
13879: #define CHECK( ... ) (void)(0)
13880: #define CHECK_FALSE( ... ) (void)(0)
13881: #define CHECKED_IF( ... ) if (__VA_ARGS__)
13882: #define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))
13883: #define CHECK_NOFAIL( ... ) (void)(0)
13884: 
13885: #define CHECK_THROWS( ... )  (void)(0)
13886: #define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
13887: #define CHECK_THROWS_WITH( expr, matcher ) (void)(0)
13888: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13889: #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
13890: #endif // CATCH_CONFIG_DISABLE_MATCHERS
13891: #define CHECK_NOTHROW( ... ) (void)(0)
13892: 
13893: #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
13894: #define CHECK_THAT( arg, matcher ) (void)(0)
13895: 
13896: #define REQUIRE_THAT( arg, matcher ) (void)(0)
13897: #endif // CATCH_CONFIG_DISABLE_MATCHERS
13898: 
13899: #define INFO( msg ) (void)(0)
13900: #define WARN( msg ) (void)(0)
13901: #define CAPTURE( msg ) (void)(0)
13902: 
13903: #define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13904: #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13905: #define METHOD_AS_TEST_CASE( method, ... )
13906: #define REGISTER_TEST_CASE( Function, ... ) (void)(0)
13907: #define SECTION( ... )
13908: #define DYNAMIC_SECTION( ... )
13909: #define FAIL( ... ) (void)(0)
13910: #define FAIL_CHECK( ... ) (void)(0)
13911: #define SUCCEED( ... ) (void)(0)
13912: #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
13913: 
13914: #endif
13915: 
13916: #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
13917: 
13918: // "BDD-style" convenience wrappers
13919: #define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )
13920: #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
13921: 
13922: #define GIVEN( desc )
13923: #define AND_GIVEN( desc )
13924: #define WHEN( desc )
13925: #define AND_WHEN( desc )
13926: #define THEN( desc )
13927: #define AND_THEN( desc )
13928: 
13929: using Catch::Detail::Approx;
13930: 
13931: #endif
13932: 
13933: #endif // ! CATCH_CONFIG_IMPL_ONLY
13934: 
13935: // start catch_reenable_warnings.h
13936: 
13937: 
13938: #ifdef __clang__
13939: #    ifdef __ICC // icpc defines the __clang__ macro
13940: #        pragma warning(pop)
13941: #    else
13942: #        pragma clang diagnostic pop
13943: #    endif
13944: #elif defined __GNUC__
13945: #    pragma GCC diagnostic pop
13946: #endif
13947: 
13948: // end catch_reenable_warnings.h
13949: // end catch.hpp
13950: #endif // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
13951: 
[end of third_party/catch/catch.hpp]
[start of tools/pythonpkg/duckdb_python.cpp]
1: #include <pybind11/pybind11.h>
2: #include <pybind11/numpy.h>
3: 
4: #include <unordered_map>
5: #include <vector>
6: 
7: #include "datetime.h" // from Python
8: 
9: #include "duckdb.hpp"
10: #include "duckdb/main/client_context.hpp"
11: #include "duckdb/common/arrow.hpp"
12: #include "duckdb/common/types/date.hpp"
13: #include "duckdb/common/types/hugeint.hpp"
14: #include "duckdb/common/types/time.hpp"
15: #include "duckdb/common/types/timestamp.hpp"
16: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
17: #include "parquet-extension.hpp"
18: 
19: #include <random>
20: 
21: namespace py = pybind11;
22: 
23: using namespace duckdb;
24: using namespace std;
25: 
26: namespace duckdb_py_convert {
27: 
28: struct RegularConvert {
29: 	template <class DUCKDB_T, class NUMPY_T> static NUMPY_T convert_value(DUCKDB_T val) {
30: 		return (NUMPY_T)val;
31: 	}
32: };
33: 
34: struct TimestampConvert {
35: 	template <class DUCKDB_T, class NUMPY_T> static int64_t convert_value(timestamp_t val) {
36: 		return Date::Epoch(Timestamp::GetDate(val)) * 1000 + (int64_t)(Timestamp::GetTime(val));
37: 	}
38: };
39: 
40: struct DateConvert {
41: 	template <class DUCKDB_T, class NUMPY_T> static int64_t convert_value(date_t val) {
42: 		return Date::Epoch(val);
43: 	}
44: };
45: 
46: struct TimeConvert {
47: 	template <class DUCKDB_T, class NUMPY_T> static py::str convert_value(time_t val) {
48: 		return py::str(duckdb::Time::ToString(val).c_str());
49: 	}
50: };
51: 
52: struct StringConvert {
53: 	template <class DUCKDB_T, class NUMPY_T> static py::str convert_value(string_t val) {
54: 		return py::str(val.GetData());
55: 	}
56: };
57: 
58: struct IntegralConvert {
59: 	template <class DUCKDB_T, class NUMPY_T> static NUMPY_T convert_value(DUCKDB_T val) {
60: 		return NUMPY_T(val);
61: 	}
62: };
63: 
64: template <>
65: double IntegralConvert::convert_value(hugeint_t val) {
66: 	double result;
67: 	Hugeint::TryCast(val, result);
68: 	return result;
69: }
70: 
71: template <class DUCKDB_T, class NUMPY_T, class CONVERT>
72: static py::array fetch_column(string numpy_type, ChunkCollection &collection, idx_t column) {
73: 	auto out = py::array(py::dtype(numpy_type), collection.count);
74: 	auto out_ptr = (NUMPY_T *)out.mutable_data();
75: 
76: 	idx_t out_offset = 0;
77: 	for (auto &data_chunk : collection.chunks) {
78: 		auto &src = data_chunk->data[column];
79: 		auto src_ptr = FlatVector::GetData<DUCKDB_T>(src);
80: 		auto &nullmask = FlatVector::Nullmask(src);
81: 		for (idx_t i = 0; i < data_chunk->size(); i++) {
82: 			if (nullmask[i]) {
83: 				continue;
84: 			}
85: 			out_ptr[i + out_offset] = CONVERT::template convert_value<DUCKDB_T, NUMPY_T>(src_ptr[i]);
86: 		}
87: 		out_offset += data_chunk->size();
88: 	}
89: 	return out;
90: }
91: 
92: template <class T> static py::array fetch_column_regular(string numpy_type, ChunkCollection &collection, idx_t column) {
93: 	return fetch_column<T, T, RegularConvert>(numpy_type, collection, column);
94: }
95: 
96: template<class DUCKDB_T>
97: static void decimal_convert_internal(ChunkCollection &collection, idx_t column, double *out_ptr, double division) {
98: 	idx_t out_offset = 0;
99: 	for (auto &data_chunk : collection.chunks) {
100: 		auto &src = data_chunk->data[column];
101: 		auto src_ptr = FlatVector::GetData<DUCKDB_T>(src);
102: 		auto &nullmask = FlatVector::Nullmask(src);
103: 		for (idx_t i = 0; i < data_chunk->size(); i++) {
104: 			if (nullmask[i]) {
105: 				continue;
106: 			}
107: 			out_ptr[i + out_offset] = IntegralConvert::convert_value<DUCKDB_T, double>(src_ptr[i]) / division;
108: 		}
109: 		out_offset += data_chunk->size();
110: 	}
111: }
112: 
113: static py::array fetch_column_decimal(string numpy_type, ChunkCollection &collection, idx_t column, LogicalType &decimal_type) {
114: 	auto out = py::array(py::dtype(numpy_type), collection.count);
115: 	auto out_ptr = (double *)out.mutable_data();
116: 
117: 	auto dec_scale = decimal_type.scale();
118: 	double division = pow(10, dec_scale);
119: 	switch(decimal_type.InternalType()) {
120: 	case PhysicalType::INT16:
121: 		decimal_convert_internal<int16_t>(collection, column, out_ptr, division);
122: 		break;
123: 	case PhysicalType::INT32:
124: 		decimal_convert_internal<int32_t>(collection, column, out_ptr, division);
125: 		break;
126: 	case PhysicalType::INT64:
127: 		decimal_convert_internal<int64_t>(collection, column, out_ptr, division);
128: 		break;
129: 	case PhysicalType::INT128:
130: 		decimal_convert_internal<hugeint_t>(collection, column, out_ptr, division);
131: 		break;
132: 	default:
133: 		throw NotImplementedException("Unimplemented internal type for DECIMAL");
134: 	}
135: 	return out;
136: }
137: 
138: } // namespace duckdb_py_convert
139: 
140: namespace random_string {
141: static std::random_device rd;
142: static std::mt19937 gen(rd());
143: static std::uniform_int_distribution<> dis(0, 15);
144: 
145: std::string generate() {
146: 	std::stringstream ss;
147: 	int i;
148: 	ss << std::hex;
149: 	for (i = 0; i < 16; i++) {
150: 		ss << dis(gen);
151: 	}
152: 	return ss.str();
153: }
154: } // namespace random_string
155: 
156: struct PandasScanFunctionData : public TableFunctionData {
157: 	PandasScanFunctionData(py::handle df, idx_t row_count, vector<LogicalType> sql_types)
158: 	    : df(df), row_count(row_count), sql_types(sql_types), position(0) {
159: 	}
160: 	py::handle df;
161: 	idx_t row_count;
162: 	vector<LogicalType> sql_types;
163: 	idx_t position;
164: };
165: 
166: struct PandasScanFunction : public TableFunction {
167: 	PandasScanFunction()
168: 	    : TableFunction("pandas_scan", {LogicalType::VARCHAR}, pandas_scan_bind, pandas_scan_function, nullptr){};
169: 
170: 	static unique_ptr<FunctionData> pandas_scan_bind(ClientContext &context, vector<Value> &inputs,
171: 	                                                 unordered_map<string, Value> &named_parameters,
172: 	                                                 vector<LogicalType> &return_types, vector<string> &names) {
173: 		// Hey, it works (TM)
174: 		py::handle df((PyObject *)std::stoull(inputs[0].GetValue<string>(), nullptr, 16));
175: 
176: 		/* TODO this fails on Python2 for some reason
177: 		auto pandas_mod = py::module::import("pandas.core.frame");
178: 		auto df_class = pandas_mod.attr("DataFrame");
179: 
180: 		if (!df.get_type().is(df_class)) {
181: 		    throw Exception("parameter is not a DataFrame");
182: 		} */
183: 
184: 		auto df_names = py::list(df.attr("columns"));
185: 		auto df_types = py::list(df.attr("dtypes"));
186: 		// TODO support masked arrays as well
187: 		// TODO support dicts of numpy arrays as well
188: 		if (py::len(df_names) == 0 || py::len(df_types) == 0 || py::len(df_names) != py::len(df_types)) {
189: 			throw runtime_error("Need a DataFrame with at least one column");
190: 		}
191: 		for (idx_t col_idx = 0; col_idx < py::len(df_names); col_idx++) {
192: 			auto col_type = string(py::str(df_types[col_idx]));
193: 			names.push_back(string(py::str(df_names[col_idx])));
194: 			LogicalType duckdb_col_type;
195: 			if (col_type == "bool") {
196: 				duckdb_col_type = LogicalType::BOOLEAN;
197: 			} else if (col_type == "int8") {
198: 				duckdb_col_type = LogicalType::TINYINT;
199: 			} else if (col_type == "int16") {
200: 				duckdb_col_type = LogicalType::SMALLINT;
201: 			} else if (col_type == "int32") {
202: 				duckdb_col_type = LogicalType::INTEGER;
203: 			} else if (col_type == "int64") {
204: 				duckdb_col_type = LogicalType::BIGINT;
205: 			} else if (col_type == "float32") {
206: 				duckdb_col_type = LogicalType::FLOAT;
207: 			} else if (col_type == "float64") {
208: 				duckdb_col_type = LogicalType::DOUBLE;
209: 			} else if (col_type == "datetime64[ns]") {
210: 				duckdb_col_type = LogicalType::TIMESTAMP;
211: 			} else if (col_type == "object") {
212: 				// this better be strings
213: 				duckdb_col_type = LogicalType::VARCHAR;
214: 			} else {
215: 				throw runtime_error("unsupported python type " + col_type);
216: 			}
217: 			return_types.push_back(duckdb_col_type);
218: 		}
219: 		idx_t row_count = py::len(df.attr("__getitem__")(df_names[0]));
220: 		return make_unique<PandasScanFunctionData>(df, row_count, return_types);
221: 	}
222: 
223: 	template <class T> static void scan_pandas_column(py::array numpy_col, idx_t count, idx_t offset, Vector &out) {
224: 		auto src_ptr = (T *)numpy_col.data();
225: 		FlatVector::SetData(out, (data_ptr_t)(src_ptr + offset));
226: 	}
227: 
228: 	template <class T> static bool ValueIsNull(T value) {
229: 		throw runtime_error("unsupported type for ValueIsNull");
230: 	}
231: 
232: 	template <class T> static void scan_pandas_fp_column(T *src_ptr, idx_t count, idx_t offset, Vector &out) {
233: 		FlatVector::SetData(out, (data_ptr_t)(src_ptr + offset));
234: 		auto tgt_ptr = (T *)FlatVector::GetData(out);
235: 		auto &nullmask = FlatVector::Nullmask(out);
236: 		for (idx_t i = 0; i < count; i++) {
237: 			if (ValueIsNull(tgt_ptr[i])) {
238: 				nullmask[i] = true;
239: 			}
240: 		}
241: 	}
242: 
243: 	static void pandas_scan_function(ClientContext &context, vector<Value> &input, DataChunk &output,
244: 	                                 FunctionData *dataptr) {
245: 		auto &data = *((PandasScanFunctionData *)dataptr);
246: 
247: 		if (data.position >= data.row_count) {
248: 			return;
249: 		}
250: 		idx_t this_count = std::min((idx_t)STANDARD_VECTOR_SIZE, data.row_count - data.position);
251: 
252: 		auto df_names = py::list(data.df.attr("columns"));
253: 		auto get_fun = data.df.attr("__getitem__");
254: 
255: 		output.SetCardinality(this_count);
256: 		for (idx_t col_idx = 0; col_idx < output.column_count(); col_idx++) {
257: 			auto numpy_col = py::array(get_fun(df_names[col_idx]).attr("to_numpy")());
258: 
259: 			switch (data.sql_types[col_idx].id()) {
260: 			case LogicalTypeId::BOOLEAN:
261: 				scan_pandas_column<bool>(numpy_col, this_count, data.position, output.data[col_idx]);
262: 				break;
263: 			case LogicalTypeId::TINYINT:
264: 				scan_pandas_column<int8_t>(numpy_col, this_count, data.position, output.data[col_idx]);
265: 				break;
266: 			case LogicalTypeId::SMALLINT:
267: 				scan_pandas_column<int16_t>(numpy_col, this_count, data.position, output.data[col_idx]);
268: 				break;
269: 			case LogicalTypeId::INTEGER:
270: 				scan_pandas_column<int32_t>(numpy_col, this_count, data.position, output.data[col_idx]);
271: 				break;
272: 			case LogicalTypeId::BIGINT:
273: 				scan_pandas_column<int64_t>(numpy_col, this_count, data.position, output.data[col_idx]);
274: 				break;
275: 			case LogicalTypeId::FLOAT:
276: 				scan_pandas_fp_column<float>((float *)numpy_col.data(), this_count, data.position,
277: 				                             output.data[col_idx]);
278: 				break;
279: 			case LogicalTypeId::DOUBLE:
280: 				scan_pandas_fp_column<double>((double *)numpy_col.data(), this_count, data.position,
281: 				                              output.data[col_idx]);
282: 				break;
283: 			case LogicalTypeId::TIMESTAMP: {
284: 				auto src_ptr = (int64_t *)numpy_col.data();
285: 				auto tgt_ptr = (timestamp_t *)FlatVector::GetData(output.data[col_idx]);
286: 				auto &nullmask = FlatVector::Nullmask(output.data[col_idx]);
287: 
288: 				for (idx_t row = 0; row < this_count; row++) {
289: 					auto source_idx = data.position + row;
290: 					if (src_ptr[source_idx] <= NumericLimits<int64_t>::Minimum()) {
291: 						// pandas Not a Time (NaT)
292: 						nullmask[row] = true;
293: 						continue;
294: 					}
295: 					auto ms = src_ptr[source_idx] / 1000000; // nanoseconds
296: 					auto ms_per_day = (int64_t)60 * 60 * 24 * 1000;
297: 					date_t date = Date::EpochToDate(ms / 1000);
298: 					dtime_t time = (dtime_t)(ms % ms_per_day);
299: 					tgt_ptr[row] = Timestamp::FromDatetime(date, time);
300: 				}
301: 				break;
302: 			} break;
303: 			case LogicalTypeId::VARCHAR: {
304: 				auto src_ptr = (PyObject **)numpy_col.data();
305: 				auto tgt_ptr = (string_t *)FlatVector::GetData(output.data[col_idx]);
306: 
307: 				for (idx_t row = 0; row < this_count; row++) {
308: 					auto source_idx = data.position + row;
309: 					auto val = src_ptr[source_idx];
310: 
311: #if PY_MAJOR_VERSION >= 3
312: 					if (!PyUnicode_Check(val)) {
313: 						FlatVector::SetNull(output.data[col_idx], row, true);
314: 						continue;
315: 					}
316: 					if (PyUnicode_READY(val) != 0) {
317: 						throw runtime_error("failure in PyUnicode_READY");
318: 					}
319: 					tgt_ptr[row] = StringVector::AddString(output.data[col_idx], ((py::object *)&val)->cast<string>());
320: #else
321: 					if (!py::isinstance<py::str>(*((py::object *)&val))) {
322: 						FlatVector::SetNull(output.data[col_idx], row, true);
323: 						continue;
324: 					}
325: 
326: 					tgt_ptr[row] = StringVector::AddString(output.data[col_idx], ((py::object *)&val)->cast<string>());
327: #endif
328: 				}
329: 				break;
330: 			}
331: 			default:
332: 				throw runtime_error("Unsupported type " + data.sql_types[col_idx].ToString());
333: 			}
334: 		}
335: 		data.position += this_count;
336: 	}
337: };
338: 
339: template <> bool PandasScanFunction::ValueIsNull(float value);
340: template <> bool PandasScanFunction::ValueIsNull(double value);
341: 
342: template <> bool PandasScanFunction::ValueIsNull(float value) {
343: 	return !Value::FloatIsValid(value);
344: }
345: 
346: template <> bool PandasScanFunction::ValueIsNull(double value) {
347: 	return !Value::DoubleIsValid(value);
348: }
349: 
350: struct DuckDBPyResult {
351: 
352: 	template <class SRC> static SRC fetch_scalar(Vector &src_vec, idx_t offset) {
353: 		auto src_ptr = FlatVector::GetData<SRC>(src_vec);
354: 		return src_ptr[offset];
355: 	}
356: 
357: 	py::object fetchone() {
358: 		if (!result) {
359: 			throw runtime_error("result closed");
360: 		}
361: 		if (!current_chunk || chunk_offset >= current_chunk->size()) {
362: 			current_chunk = result->Fetch();
363: 			chunk_offset = 0;
364: 		}
365: 		if (current_chunk->size() == 0) {
366: 			return py::none();
367: 		}
368: 		py::tuple res(result->types.size());
369: 
370: 		for (idx_t col_idx = 0; col_idx < result->types.size(); col_idx++) {
371: 			auto &nullmask = FlatVector::Nullmask(current_chunk->data[col_idx]);
372: 			if (nullmask[chunk_offset]) {
373: 				res[col_idx] = py::none();
374: 				continue;
375: 			}
376: 			auto val = current_chunk->data[col_idx].GetValue(chunk_offset);
377: 			switch (result->types[col_idx].id()) {
378: 			case LogicalTypeId::BOOLEAN:
379: 				res[col_idx] = val.GetValue<bool>();
380: 				break;
381: 			case LogicalTypeId::TINYINT:
382: 				res[col_idx] = val.GetValue<int8_t>();
383: 				break;
384: 			case LogicalTypeId::SMALLINT:
385: 				res[col_idx] = val.GetValue<int16_t>();
386: 				break;
387: 			case LogicalTypeId::INTEGER:
388: 				res[col_idx] = val.GetValue<int32_t>();
389: 				break;
390: 			case LogicalTypeId::BIGINT:
391: 				res[col_idx] = val.GetValue<int64_t>();
392: 				break;
393: 			case LogicalTypeId::HUGEINT: {
394: 				auto hugeint_str = val.GetValue<string>();
395: 				res[col_idx] = PyLong_FromString((char *)hugeint_str.c_str(), nullptr, 10);
396: 				break;
397: 			}
398: 			case LogicalTypeId::FLOAT:
399: 				res[col_idx] = val.GetValue<float>();
400: 				break;
401: 			case LogicalTypeId::DOUBLE:
402: 				res[col_idx] = val.GetValue<double>();
403: 				break;
404: 			case LogicalTypeId::DECIMAL:
405: 				res[col_idx] = val.CastAs(LogicalType::DOUBLE).GetValue<double>();
406: 				break;
407: 			case LogicalTypeId::VARCHAR:
408: 				res[col_idx] = val.GetValue<string>();
409: 				break;
410: 
411: 			case LogicalTypeId::TIMESTAMP: {
412: 				assert(result->types[col_idx].InternalType() == PhysicalType::INT64);
413: 
414: 				auto timestamp = val.GetValue<int64_t>();
415: 				auto date = Timestamp::GetDate(timestamp);
416: 				res[col_idx] = PyDateTime_FromDateAndTime(
417: 				    Date::ExtractYear(date), Date::ExtractMonth(date), Date::ExtractDay(date),
418: 				    Timestamp::GetHours(timestamp), Timestamp::GetMinutes(timestamp), Timestamp::GetSeconds(timestamp),
419: 				    Timestamp::GetMilliseconds(timestamp) * 1000 - Timestamp::GetSeconds(timestamp) * 1000000);
420: 
421: 				break;
422: 			}
423: 			case LogicalTypeId::TIME: {
424: 				assert(result->types[col_idx].InternalType() == PhysicalType::INT32);
425: 
426: 				int32_t hour, min, sec, msec;
427: 				auto time = val.GetValue<int32_t>();
428: 				duckdb::Time::Convert(time, hour, min, sec, msec);
429: 				res[col_idx] = PyTime_FromTime(hour, min, sec, msec * 1000);
430: 				break;
431: 			}
432: 			case LogicalTypeId::DATE: {
433: 				assert(result->types[col_idx].InternalType() == PhysicalType::INT32);
434: 
435: 				auto date = val.GetValue<int32_t>();
436: 				res[col_idx] = PyDate_FromDate(duckdb::Date::ExtractYear(date), duckdb::Date::ExtractMonth(date),
437: 				                               duckdb::Date::ExtractDay(date));
438: 				break;
439: 			}
440: 
441: 			default:
442: 				throw runtime_error("unsupported type: " + result->types[col_idx].ToString());
443: 			}
444: 		}
445: 		chunk_offset++;
446: 		return move(res);
447: 	}
448: 
449: 	py::list fetchall() {
450: 		py::list res;
451: 		while (true) {
452: 			auto fres = fetchone();
453: 			if (fres.is_none()) {
454: 				break;
455: 			}
456: 			res.append(fres);
457: 		}
458: 		return res;
459: 	}
460: 
461: 	py::dict fetchnumpy() {
462: 		if (!result) {
463: 			throw runtime_error("result closed");
464: 		}
465: 		// need to materialize the result if it was streamed because we need the count :/
466: 		MaterializedQueryResult *mres = nullptr;
467: 		unique_ptr<QueryResult> mat_res_holder;
468: 		if (result->type == QueryResultType::STREAM_RESULT) {
469: 			mat_res_holder = ((StreamQueryResult *)result.get())->Materialize();
470: 			mres = (MaterializedQueryResult *)mat_res_holder.get();
471: 		} else {
472: 			mres = (MaterializedQueryResult *)result.get();
473: 		}
474: 		assert(mres);
475: 
476: 		py::dict res;
477: 		for (idx_t col_idx = 0; col_idx < mres->types.size(); col_idx++) {
478: 			// convert the actual payload
479: 			py::array col_res;
480: 			switch (mres->types[col_idx].id()) {
481: 			case LogicalTypeId::BOOLEAN:
482: 				col_res = duckdb_py_convert::fetch_column_regular<bool>("bool", mres->collection, col_idx);
483: 				break;
484: 			case LogicalTypeId::TINYINT:
485: 				col_res = duckdb_py_convert::fetch_column_regular<int8_t>("int8", mres->collection, col_idx);
486: 				break;
487: 			case LogicalTypeId::SMALLINT:
488: 				col_res = duckdb_py_convert::fetch_column_regular<int16_t>("int16", mres->collection, col_idx);
489: 				break;
490: 			case LogicalTypeId::INTEGER:
491: 				col_res = duckdb_py_convert::fetch_column_regular<int32_t>("int32", mres->collection, col_idx);
492: 				break;
493: 			case LogicalTypeId::BIGINT:
494: 				col_res = duckdb_py_convert::fetch_column_regular<int64_t>("int64", mres->collection, col_idx);
495: 				break;
496: 			case LogicalTypeId::HUGEINT:
497: 				col_res = duckdb_py_convert::fetch_column<hugeint_t, double, duckdb_py_convert::IntegralConvert>(
498: 				    "float64", mres->collection, col_idx);
499: 				break;
500: 			case LogicalTypeId::FLOAT:
501: 				col_res = duckdb_py_convert::fetch_column_regular<float>("float32", mres->collection, col_idx);
502: 				break;
503: 			case LogicalTypeId::DOUBLE:
504: 				col_res = duckdb_py_convert::fetch_column_regular<double>("float64", mres->collection, col_idx);
505: 				break;
506: 			case LogicalTypeId::DECIMAL:
507: 				col_res = duckdb_py_convert::fetch_column_decimal("float64", mres->collection, col_idx, mres->types[col_idx]);
508: 				break;
509: 			case LogicalTypeId::TIMESTAMP:
510: 				col_res = duckdb_py_convert::fetch_column<timestamp_t, int64_t, duckdb_py_convert::TimestampConvert>(
511: 				    "datetime64[ms]", mres->collection, col_idx);
512: 				break;
513: 			case LogicalTypeId::DATE:
514: 				col_res = duckdb_py_convert::fetch_column<date_t, int64_t, duckdb_py_convert::DateConvert>(
515: 				    "datetime64[s]", mres->collection, col_idx);
516: 				break;
517: 			case LogicalTypeId::TIME:
518: 				col_res = duckdb_py_convert::fetch_column<time_t, py::str, duckdb_py_convert::TimeConvert>(
519: 				    "object", mres->collection, col_idx);
520: 				break;
521: 			case LogicalTypeId::VARCHAR:
522: 				col_res = duckdb_py_convert::fetch_column<string_t, py::str, duckdb_py_convert::StringConvert>(
523: 				    "object", mres->collection, col_idx);
524: 				break;
525: 			default:
526: 				throw runtime_error("unsupported type " + mres->types[col_idx].ToString());
527: 			}
528: 
529: 			// convert the nullmask
530: 			auto nullmask = py::array(py::dtype("bool"), mres->collection.count);
531: 			auto nullmask_ptr = (bool *)nullmask.mutable_data();
532: 			idx_t out_offset = 0;
533: 			for (auto &data_chunk : mres->collection.chunks) {
534: 				auto &src_nm = FlatVector::Nullmask(data_chunk->data[col_idx]);
535: 				for (idx_t i = 0; i < data_chunk->size(); i++) {
536: 					nullmask_ptr[i + out_offset] = src_nm[i];
537: 				}
538: 				out_offset += data_chunk->size();
539: 			}
540: 
541: 			// create masked array and assign to output
542: 			auto masked_array = py::module::import("numpy.ma").attr("masked_array")(col_res, nullmask);
543: 			res[mres->names[col_idx].c_str()] = masked_array;
544: 		}
545: 		return res;
546: 	}
547: 
548: 	py::object fetchdf() {
549: 		return py::module::import("pandas").attr("DataFrame").attr("from_dict")(fetchnumpy());
550: 	}
551: 
552: 	py::object fetch_arrow_table() {
553: 		if (!result) {
554: 			throw runtime_error("result closed");
555: 		}
556: 
557: 		auto pyarrow_lib_module = py::module::import("pyarrow").attr("lib");
558: 
559: 		auto batch_import_func = pyarrow_lib_module.attr("RecordBatch").attr("_import_from_c");
560: 		auto from_batches_func = pyarrow_lib_module.attr("Table").attr("from_batches");
561: 		auto schema_import_func = pyarrow_lib_module.attr("Schema").attr("_import_from_c");
562: 		ArrowSchema schema;
563: 		result->ToArrowSchema(&schema);
564: 		auto schema_obj = schema_import_func((uint64_t)&schema);
565: 
566: 		py::list batches;
567: 		while (true) {
568: 			auto data_chunk = result->Fetch();
569: 			if (data_chunk->size() == 0) {
570: 				break;
571: 			}
572: 			ArrowArray data;
573: 			data_chunk->ToArrowArray(&data);
574: 			ArrowSchema schema;
575: 			result->ToArrowSchema(&schema);
576: 			batches.append(batch_import_func((uint64_t)&data, (uint64_t)&schema));
577: 		}
578: 		return from_batches_func(batches, schema_obj);
579: 	}
580: 
581: 	py::list description() {
582: 		py::list desc(result->names.size());
583: 		for (idx_t col_idx = 0; col_idx < result->names.size(); col_idx++) {
584: 			py::tuple col_desc(7);
585: 			col_desc[0] = py::str(result->names[col_idx]);
586: 			col_desc[1] = py::none();
587: 			col_desc[2] = py::none();
588: 			col_desc[3] = py::none();
589: 			col_desc[4] = py::none();
590: 			col_desc[5] = py::none();
591: 			col_desc[6] = py::none();
592: 			desc[col_idx] = col_desc;
593: 		}
594: 		return desc;
595: 	}
596: 
597: 	void close() {
598: 		result = nullptr;
599: 	}
600: 	idx_t chunk_offset = 0;
601: 
602: 	unique_ptr<QueryResult> result;
603: 	unique_ptr<DataChunk> current_chunk;
604: };
605: 
606: struct DuckDBPyRelation;
607: 
608: struct DuckDBPyConnection {
609: 
610: 	DuckDBPyConnection *executemany(string query, py::object params = py::list()) {
611: 		execute(query, params, true);
612: 		return this;
613: 	}
614: 
615: 	~DuckDBPyConnection() {
616: 		for (auto &element : registered_dfs) {
617: 			unregister_df(element.first);
618: 		}
619: 	}
620: 
621: 	DuckDBPyConnection *execute(string query, py::object params = py::list(), bool many = false) {
622: 		if (!connection) {
623: 			throw runtime_error("connection closed");
624: 		}
625: 		result = nullptr;
626: 
627: 		auto prep = connection->Prepare(query);
628: 		if (!prep->success) {
629: 			throw runtime_error(prep->error);
630: 		}
631: 
632: 		// this is a list of a list of parameters in executemany
633: 		py::list params_set;
634: 		if (!many) {
635: 			params_set = py::list(1);
636: 			params_set[0] = params;
637: 		} else {
638: 			params_set = params;
639: 		}
640: 
641: 		for (const auto &single_query_params : params_set) {
642: 			if (prep->n_param != py::len(single_query_params)) {
643: 				throw runtime_error("Prepared statments needs " + to_string(prep->n_param) + " parameters, " +
644: 				                    to_string(py::len(single_query_params)) + " given");
645: 			}
646: 			auto args = DuckDBPyConnection::transform_python_param_list(single_query_params);
647: 			auto res = make_unique<DuckDBPyResult>();
648: 			res->result = prep->Execute(args);
649: 			if (!res->result->success) {
650: 				throw runtime_error(res->result->error);
651: 			}
652: 			if (!many) {
653: 				result = move(res);
654: 			}
655: 		}
656: 		return this;
657: 	}
658: 
659: 	DuckDBPyConnection *append(string name, py::object value) {
660: 		register_df("__append_df", value);
661: 		return execute("INSERT INTO \"" + name + "\" SELECT * FROM __append_df");
662: 	}
663: 
664: 	static string ptr_to_string(void const *ptr) {
665: 		std::ostringstream address;
666: 		address << ptr;
667: 		return address.str();
668: 	}
669: 
670: 	DuckDBPyConnection *register_df(string name, py::object value) {
671: 		// hack alert: put the pointer address into the function call as a string
672: 		execute("CREATE OR REPLACE VIEW \"" + name + "\" AS SELECT * FROM pandas_scan('" + ptr_to_string(value.ptr()) +
673: 		        "')");
674: 
675: 		// try to bind
676: 		execute("SELECT * FROM \"" + name + "\" WHERE FALSE");
677: 
678: 		// keep a reference
679: 		registered_dfs[name] = value;
680: 		return this;
681: 	}
682: 
683: 	unique_ptr<DuckDBPyRelation> table(string tname) {
684: 		if (!connection) {
685: 			throw runtime_error("connection closed");
686: 		}
687: 		return make_unique<DuckDBPyRelation>(connection->Table(tname));
688: 	}
689: 
690: 	unique_ptr<DuckDBPyRelation> values(py::object params = py::list()) {
691: 		if (!connection) {
692: 			throw runtime_error("connection closed");
693: 		}
694: 		vector<vector<Value>> values{DuckDBPyConnection::transform_python_param_list(params)};
695: 		return make_unique<DuckDBPyRelation>(connection->Values(values));
696: 	}
697: 
698: 	unique_ptr<DuckDBPyRelation> view(string vname) {
699: 		if (!connection) {
700: 			throw runtime_error("connection closed");
701: 		}
702: 		return make_unique<DuckDBPyRelation>(connection->View(vname));
703: 	}
704: 
705: 	unique_ptr<DuckDBPyRelation> table_function(string fname, py::object params = py::list()) {
706: 		if (!connection) {
707: 			throw runtime_error("connection closed");
708: 		}
709: 
710: 		return make_unique<DuckDBPyRelation>(
711: 		    connection->TableFunction(fname, DuckDBPyConnection::transform_python_param_list(params)));
712: 	}
713: 
714: 	unique_ptr<DuckDBPyRelation> from_df(py::object value) {
715: 		if (!connection) {
716: 			throw runtime_error("connection closed");
717: 		};
718: 		string name = "df_" + random_string::generate();
719: 		registered_dfs[name] = value;
720: 		vector<Value> params;
721: 		params.push_back(Value(ptr_to_string(value.ptr())));
722: 		return make_unique<DuckDBPyRelation>(connection->TableFunction("pandas_scan", params)->Alias(name));
723: 	}
724: 
725: 	unique_ptr<DuckDBPyRelation> from_csv_auto(string filename) {
726: 		if (!connection) {
727: 			throw runtime_error("connection closed");
728: 		};
729: 		vector<Value> params;
730: 		params.push_back(Value(filename));
731: 		return make_unique<DuckDBPyRelation>(connection->TableFunction("read_csv_auto", params)->Alias(filename));
732: 	}
733: 
734: 	unique_ptr<DuckDBPyRelation> from_parquet(string filename) {
735: 		if (!connection) {
736: 			throw runtime_error("connection closed");
737: 		};
738: 		vector<Value> params;
739: 		params.push_back(Value(filename));
740: 		return make_unique<DuckDBPyRelation>(connection->TableFunction("parquet_scan", params)->Alias(filename));
741: 	}
742: 
743: 	struct PythonTableArrowArrayStream {
744: 		PythonTableArrowArrayStream(py::object arrow_table) : arrow_table(arrow_table) {
745: 			stream.get_schema = PythonTableArrowArrayStream::my_stream_getschema;
746: 			stream.get_next = PythonTableArrowArrayStream::my_stream_getnext;
747: 			stream.release = PythonTableArrowArrayStream::my_stream_release;
748: 			stream.get_last_error = PythonTableArrowArrayStream::my_stream_getlasterror;
749: 			stream.private_data = this;
750: 
751: 			batches = arrow_table.attr("to_batches")();
752: 		}
753: 
754: 		static int my_stream_getschema(struct ArrowArrayStream *stream, struct ArrowSchema *out) {
755: 			assert(stream->private_data);
756: 			auto my_stream = (PythonTableArrowArrayStream *)stream->private_data;
757: 			if (!stream->release) {
758: 				my_stream->last_error = "stream was released";
759: 				return -1;
760: 			}
761: 			my_stream->arrow_table.attr("schema").attr("_export_to_c")((uint64_t)out);
762: 			return 0;
763: 		}
764: 
765: 		static int my_stream_getnext(struct ArrowArrayStream *stream, struct ArrowArray *out) {
766: 			assert(stream->private_data);
767: 			auto my_stream = (PythonTableArrowArrayStream *)stream->private_data;
768: 			if (!stream->release) {
769: 				my_stream->last_error = "stream was released";
770: 				return -1;
771: 			}
772: 			if (my_stream->batch_idx >= py::len(my_stream->batches)) {
773: 				out->release = nullptr;
774: 				return 0;
775: 			}
776: 			my_stream->batches[my_stream->batch_idx++].attr("_export_to_c")((uint64_t)out);
777: 			return 0;
778: 		}
779: 
780: 		static void my_stream_release(struct ArrowArrayStream *stream) {
781: 			if (!stream->release) {
782: 				return;
783: 			}
784: 			stream->release = nullptr;
785: 			delete (PythonTableArrowArrayStream *)stream->private_data;
786: 		}
787: 
788: 		static const char *my_stream_getlasterror(struct ArrowArrayStream *stream) {
789: 			if (!stream->release) {
790: 				return "stream was released";
791: 			}
792: 			assert(stream->private_data);
793: 			auto my_stream = (PythonTableArrowArrayStream *)stream->private_data;
794: 			return my_stream->last_error.c_str();
795: 		}
796: 
797: 		ArrowArrayStream stream;
798: 		string last_error;
799: 		py::object arrow_table;
800: 		py::list batches;
801: 		idx_t batch_idx = 0;
802: 	};
803: 
804: 	unique_ptr<DuckDBPyRelation> from_arrow_table(py::object table) {
805: 		if (!connection) {
806: 			throw runtime_error("connection closed");
807: 		};
808: 
809: 		// the following is a careful dance around having to depend on pyarrow
810: 		if (table.is_none() || string(py::str(table.get_type().attr("__name__"))) != "Table") {
811: 			throw runtime_error("Only arrow tables supported");
812: 		}
813: 
814: 		auto my_arrow_table = new PythonTableArrowArrayStream(table);
815: 		string name = "arrow_table_" + ptr_to_string((void *)my_arrow_table);
816: 		return make_unique<DuckDBPyRelation>(
817: 		    connection->TableFunction("arrow_scan", {Value::POINTER((uintptr_t)my_arrow_table)})->Alias(name));
818: 	}
819: 
820: 	DuckDBPyConnection *unregister_df(string name) {
821: 		registered_dfs[name] = py::none();
822: 		return this;
823: 	}
824: 
825: 	DuckDBPyConnection *begin() {
826: 		execute("BEGIN TRANSACTION");
827: 		return this;
828: 	}
829: 
830: 	DuckDBPyConnection *commit() {
831: 		if (connection->context->transaction.IsAutoCommit()) {
832: 			return this;
833: 		}
834: 		execute("COMMIT");
835: 		return this;
836: 	}
837: 
838: 	DuckDBPyConnection *rollback() {
839: 		execute("ROLLBACK");
840: 		return this;
841: 	}
842: 
843: 	py::object getattr(py::str key) {
844: 		if (key.cast<string>() == "description") {
845: 			if (!result) {
846: 				throw runtime_error("no open result set");
847: 			}
848: 			return result->description();
849: 		}
850: 		return py::none();
851: 	}
852: 
853: 	void close() {
854: 		connection = nullptr;
855: 		database = nullptr;
856: 	}
857: 
858: 	// cursor() is stupid
859: 	unique_ptr<DuckDBPyConnection> cursor() {
860: 		auto res = make_unique<DuckDBPyConnection>();
861: 		res->database = database;
862: 		res->connection = make_unique<Connection>(*res->database);
863: 		return res;
864: 	}
865: 
866: 	// these should be functions on the result but well
867: 	py::tuple fetchone() {
868: 		if (!result) {
869: 			throw runtime_error("no open result set");
870: 		}
871: 		return result->fetchone();
872: 	}
873: 
874: 	py::list fetchall() {
875: 		if (!result) {
876: 			throw runtime_error("no open result set");
877: 		}
878: 		return result->fetchall();
879: 	}
880: 
881: 	py::dict fetchnumpy() {
882: 		if (!result) {
883: 			throw runtime_error("no open result set");
884: 		}
885: 		return result->fetchnumpy();
886: 	}
887: 	py::object fetchdf() {
888: 		if (!result) {
889: 			throw runtime_error("no open result set");
890: 		}
891: 		return result->fetchdf();
892: 	}
893: 	py::object fetcharrow() {
894: 		if (!result) {
895: 			throw runtime_error("no open result set");
896: 		}
897: 		return result->fetch_arrow_table();
898: 	}
899: 
900: 	static unique_ptr<DuckDBPyConnection> connect(string database, bool read_only) {
901: 		auto res = make_unique<DuckDBPyConnection>();
902: 		DBConfig config;
903: 		if (read_only)
904: 			config.access_mode = AccessMode::READ_ONLY;
905: 		res->database = make_unique<DuckDB>(database, &config);
906: 		res->database->LoadExtension<ParquetExtension>();
907: 		res->connection = make_unique<Connection>(*res->database);
908: 
909: 		PandasScanFunction scan_fun;
910: 		CreateTableFunctionInfo info(scan_fun);
911: 
912: 		auto &context = *res->connection->context;
913: 		context.transaction.BeginTransaction();
914: 		context.catalog.CreateTableFunction(context, &info);
915: 		context.transaction.Commit();
916: 
917: 		if (!read_only) {
918: 			res->connection->Query("CREATE OR REPLACE VIEW sqlite_master AS SELECT * FROM sqlite_master()");
919: 		}
920: 
921: 		return res;
922: 	}
923: 
924: 	shared_ptr<DuckDB> database;
925: 	unique_ptr<Connection> connection;
926: 	unordered_map<string, py::object> registered_dfs;
927: 	unique_ptr<DuckDBPyResult> result;
928: 
929: 	static vector<Value> transform_python_param_list(py::handle params) {
930: 		vector<Value> args;
931: 
932: 		auto datetime_mod = py::module::import("datetime");
933: 		auto datetime_date = datetime_mod.attr("datetime");
934: 		auto datetime_datetime = datetime_mod.attr("date");
935: 
936: 		for (auto &ele : params) {
937: 			if (ele.is_none()) {
938: 				args.push_back(Value());
939: 			} else if (py::isinstance<py::bool_>(ele)) {
940: 				args.push_back(Value::BOOLEAN(ele.cast<bool>()));
941: 			} else if (py::isinstance<py::int_>(ele)) {
942: 				args.push_back(Value::BIGINT(ele.cast<int64_t>()));
943: 			} else if (py::isinstance<py::float_>(ele)) {
944: 				args.push_back(Value::DOUBLE(ele.cast<double>()));
945: 			} else if (py::isinstance<py::str>(ele)) {
946: 				args.push_back(Value(ele.cast<string>()));
947: 			} else if (ele.get_type().is(datetime_date)) {
948: 				throw runtime_error("date parameters not supported yet :/");
949: 				// args.push_back(Value::DATE(1984, 4, 24));
950: 			} else if (ele.get_type().is(datetime_datetime)) {
951: 				throw runtime_error("datetime parameters not supported yet :/");
952: 				// args.push_back(Value::TIMESTAMP(1984, 4, 24, 14, 42, 0, 0));
953: 			} else {
954: 				throw runtime_error("unknown param type " + py::str(ele.get_type()).cast<string>());
955: 			}
956: 		}
957: 		return args;
958: 	}
959: };
960: 
961: static unique_ptr<DuckDBPyConnection> default_connection_ = nullptr;
962: 
963: static DuckDBPyConnection *default_connection() {
964: 	if (!default_connection_) {
965: 		default_connection_ = DuckDBPyConnection::connect(":memory:", false);
966: 	}
967: 	return default_connection_.get();
968: }
969: 
970: struct DuckDBPyRelation {
971: 
972: 	DuckDBPyRelation(shared_ptr<Relation> rel) : rel(rel) {
973: 	}
974: 
975: 	static unique_ptr<DuckDBPyRelation> from_df(py::object df) {
976: 		return default_connection()->from_df(df);
977: 	}
978: 
979: 	static unique_ptr<DuckDBPyRelation> values(py::object values = py::list()) {
980: 		return default_connection()->values(values);
981: 	}
982: 
983: 	static unique_ptr<DuckDBPyRelation> from_csv_auto(string filename) {
984: 		return default_connection()->from_csv_auto(filename);
985: 	}
986: 
987: 	static unique_ptr<DuckDBPyRelation> from_parquet(string filename) {
988: 		return default_connection()->from_parquet(filename);
989: 	}
990: 
991: 	static unique_ptr<DuckDBPyRelation> from_arrow_table(py::object table) {
992: 		return default_connection()->from_arrow_table(table);
993: 	}
994: 
995: 	unique_ptr<DuckDBPyRelation> project(string expr) {
996: 		return make_unique<DuckDBPyRelation>(rel->Project(expr));
997: 	}
998: 
999: 	static unique_ptr<DuckDBPyRelation> project_df(py::object df, string expr) {
1000: 		return default_connection()->from_df(df)->project(expr);
1001: 	}
1002: 
1003: 	unique_ptr<DuckDBPyRelation> alias(string expr) {
1004: 		return make_unique<DuckDBPyRelation>(rel->Alias(expr));
1005: 	}
1006: 
1007: 	static unique_ptr<DuckDBPyRelation> alias_df(py::object df, string expr) {
1008: 		return default_connection()->from_df(df)->alias(expr);
1009: 	}
1010: 
1011: 	unique_ptr<DuckDBPyRelation> filter(string expr) {
1012: 		return make_unique<DuckDBPyRelation>(rel->Filter(expr));
1013: 	}
1014: 
1015: 	static unique_ptr<DuckDBPyRelation> filter_df(py::object df, string expr) {
1016: 		return default_connection()->from_df(df)->filter(expr);
1017: 	}
1018: 
1019: 	unique_ptr<DuckDBPyRelation> limit(int64_t n) {
1020: 		return make_unique<DuckDBPyRelation>(rel->Limit(n));
1021: 	}
1022: 
1023: 	static unique_ptr<DuckDBPyRelation> limit_df(py::object df, int64_t n) {
1024: 		return default_connection()->from_df(df)->limit(n);
1025: 	}
1026: 
1027: 	unique_ptr<DuckDBPyRelation> order(string expr) {
1028: 		return make_unique<DuckDBPyRelation>(rel->Order(expr));
1029: 	}
1030: 
1031: 	static unique_ptr<DuckDBPyRelation> order_df(py::object df, string expr) {
1032: 		return default_connection()->from_df(df)->order(expr);
1033: 	}
1034: 
1035: 	unique_ptr<DuckDBPyRelation> aggregate(string expr, string groups = "") {
1036: 		if (groups.size() > 0) {
1037: 			return make_unique<DuckDBPyRelation>(rel->Aggregate(expr, groups));
1038: 		}
1039: 		return make_unique<DuckDBPyRelation>(rel->Aggregate(expr));
1040: 	}
1041: 
1042: 	static unique_ptr<DuckDBPyRelation> aggregate_df(py::object df, string expr, string groups = "") {
1043: 		return default_connection()->from_df(df)->aggregate(expr, groups);
1044: 	}
1045: 
1046: 	unique_ptr<DuckDBPyRelation> distinct() {
1047: 		return make_unique<DuckDBPyRelation>(rel->Distinct());
1048: 	}
1049: 
1050: 	static unique_ptr<DuckDBPyRelation> distinct_df(py::object df) {
1051: 		return default_connection()->from_df(df)->distinct();
1052: 	}
1053: 
1054: 	py::object to_df() {
1055: 		auto res = make_unique<DuckDBPyResult>();
1056: 		res->result = rel->Execute();
1057: 		if (!res->result->success) {
1058: 			throw runtime_error(res->result->error);
1059: 		}
1060: 		return res->fetchdf();
1061: 	}
1062: 
1063: 	py::object to_arrow_table() {
1064: 		auto res = make_unique<DuckDBPyResult>();
1065: 		res->result = rel->Execute();
1066: 		if (!res->result->success) {
1067: 			throw runtime_error(res->result->error);
1068: 		}
1069: 		return res->fetch_arrow_table();
1070: 	}
1071: 
1072: 	unique_ptr<DuckDBPyRelation> union_(DuckDBPyRelation *other) {
1073: 		return make_unique<DuckDBPyRelation>(rel->Union(other->rel));
1074: 	}
1075: 
1076: 	unique_ptr<DuckDBPyRelation> except(DuckDBPyRelation *other) {
1077: 		return make_unique<DuckDBPyRelation>(rel->Except(other->rel));
1078: 	}
1079: 
1080: 	unique_ptr<DuckDBPyRelation> intersect(DuckDBPyRelation *other) {
1081: 		return make_unique<DuckDBPyRelation>(rel->Intersect(other->rel));
1082: 	}
1083: 
1084: 	unique_ptr<DuckDBPyRelation> join(DuckDBPyRelation *other, string condition) {
1085: 		return make_unique<DuckDBPyRelation>(rel->Join(other->rel, condition));
1086: 	}
1087: 
1088: 	void write_csv(string file) {
1089: 		rel->WriteCSV(file);
1090: 	}
1091: 
1092: 	static void write_csv_df(py::object df, string file) {
1093: 		return default_connection()->from_df(df)->write_csv(file);
1094: 	}
1095: 
1096: 	// should this return a rel with the new view?
1097: 	unique_ptr<DuckDBPyRelation> create_view(string view_name, bool replace = true) {
1098: 		rel->CreateView(view_name, replace);
1099: 		return make_unique<DuckDBPyRelation>(rel);
1100: 	}
1101: 
1102: 	static unique_ptr<DuckDBPyRelation> create_view_df(py::object df, string view_name, bool replace = true) {
1103: 		return default_connection()->from_df(df)->create_view(view_name, replace);
1104: 	}
1105: 
1106: 	unique_ptr<DuckDBPyResult> query(string view_name, string sql_query) {
1107: 		auto res = make_unique<DuckDBPyResult>();
1108: 		res->result = rel->Query(view_name, sql_query);
1109: 		if (!res->result->success) {
1110: 			throw runtime_error(res->result->error);
1111: 		}
1112: 		return res;
1113: 	}
1114: 
1115: 	unique_ptr<DuckDBPyResult> execute() {
1116: 		auto res = make_unique<DuckDBPyResult>();
1117: 		res->result = rel->Execute();
1118: 		if (!res->result->success) {
1119: 			throw runtime_error(res->result->error);
1120: 		}
1121: 		return res;
1122: 	}
1123: 
1124: 	static unique_ptr<DuckDBPyResult> query_df(py::object df, string view_name, string sql_query) {
1125: 		return default_connection()->from_df(df)->query(view_name, sql_query);
1126: 	}
1127: 
1128: 	void insert_into(string table) {
1129: 		rel->Insert(table);
1130: 	}
1131: 
1132: 	void insert(py::object params = py::list()) {
1133: 		vector<vector<Value>> values{DuckDBPyConnection::transform_python_param_list(params)};
1134: 		rel->Insert(values);
1135: 	}
1136: 
1137: 	void create(string table) {
1138: 		rel->Create(table);
1139: 	}
1140: 
1141: 	string print() {
1142: 		return rel->ToString() + "\n---------------------\n-- Result Preview  --\n---------------------\n" +
1143: 		       rel->Limit(10)->Execute()->ToString() + "\n";
1144: 	}
1145: 
1146: 	py::object getattr(py::str key) {
1147: 		auto key_s = key.cast<string>();
1148: 		if (key_s == "alias") {
1149: 			return py::str(string(rel->GetAlias()));
1150: 		} else if (key_s == "type") {
1151: 			return py::str(RelationTypeToString(rel->type));
1152: 		} else if (key_s == "columns") {
1153: 			py::list res;
1154: 			for (auto &col : rel->Columns()) {
1155: 				res.append(col.name);
1156: 			}
1157: 			return move(res);
1158: 		} else if (key_s == "types" || key_s == "dtypes") {
1159: 			py::list res;
1160: 			for (auto &col : rel->Columns()) {
1161: 				res.append(col.type.ToString());
1162: 			}
1163: 			return move(res);
1164: 		}
1165: 		return py::none();
1166: 	}
1167: 
1168: 	shared_ptr<Relation> rel;
1169: };
1170: 
1171: PYBIND11_MODULE(duckdb, m) {
1172: 	m.def("connect", &DuckDBPyConnection::connect,
1173: 	      "Create a DuckDB database instance. Can take a database file name to read/write persistent data and a "
1174: 	      "read_only flag if no changes are desired",
1175: 	      py::arg("database") = ":memory:", py::arg("read_only") = false);
1176: 
1177: 	auto conn_class =
1178: 	    py::class_<DuckDBPyConnection>(m, "DuckDBPyConnection")
1179: 	        .def("cursor", &DuckDBPyConnection::cursor, "Create a duplicate of the current connection")
1180: 	        .def("duplicate", &DuckDBPyConnection::cursor, "Create a duplicate of the current connection")
1181: 	        .def("execute", &DuckDBPyConnection::execute,
1182: 	             "Execute the given SQL query, optionally using prepared statements with parameters set",
1183: 	             py::arg("query"), py::arg("parameters") = py::list(), py::arg("multiple_parameter_sets") = false)
1184: 	        .def("executemany", &DuckDBPyConnection::executemany,
1185: 	             "Execute the given prepared statement multiple times using the list of parameter sets in parameters",
1186: 	             py::arg("query"), py::arg("parameters") = py::list())
1187: 	        .def("close", &DuckDBPyConnection::close, "Close the connection")
1188: 	        .def("fetchone", &DuckDBPyConnection::fetchone, "Fetch a single row from a result following execute")
1189: 	        .def("fetchall", &DuckDBPyConnection::fetchall, "Fetch all rows from a result following execute")
1190: 	        .def("fetchnumpy", &DuckDBPyConnection::fetchnumpy,
1191: 	             "Fetch a result as list of NumPy arrays following execute")
1192: 	        .def("fetchdf", &DuckDBPyConnection::fetchdf, "Fetch a result as Data.Frame following execute()")
1193: 	        .def("df", &DuckDBPyConnection::fetchdf, "Fetch a result as Data.Frame following execute()")
1194: 	        .def("fetch_arrow_table", &DuckDBPyConnection::fetcharrow,
1195: 	             "Fetch a result as Arrow table following execute()")
1196: 	        .def("arrow", &DuckDBPyConnection::fetcharrow, "Fetch a result as Arrow table following execute()")
1197: 	        .def("begin", &DuckDBPyConnection::begin, "Start a new transaction")
1198: 	        .def("commit", &DuckDBPyConnection::commit, "Commit changes performed within a transaction")
1199: 	        .def("rollback", &DuckDBPyConnection::rollback, "Roll back changes performed within a transaction")
1200: 	        .def("append", &DuckDBPyConnection::append, "Append the passed Data.Frame to the named table",
1201: 	             py::arg("table_name"), py::arg("df"))
1202: 	        .def("register", &DuckDBPyConnection::register_df,
1203: 	             "Register the passed Data.Frame value for querying with a view", py::arg("view_name"), py::arg("df"))
1204: 	        .def("unregister", &DuckDBPyConnection::unregister_df, "Unregister the view name", py::arg("view_name"))
1205: 	        .def("table", &DuckDBPyConnection::table, "Create a relation object for the name'd table",
1206: 	             py::arg("table_name"))
1207: 	        .def("view", &DuckDBPyConnection::view, "Create a relation object for the name'd view",
1208: 	             py::arg("view_name"))
1209: 	        .def("values", &DuckDBPyConnection::values, "Create a relation object from the passed values",
1210: 	             py::arg("values"))
1211: 	        .def("table_function", &DuckDBPyConnection::table_function,
1212: 	             "Create a relation object from the name'd table function with given parameters", py::arg("name"),
1213: 	             py::arg("parameters") = py::list())
1214: 	        .def("from_df", &DuckDBPyConnection::from_df, "Create a relation object from the Data.Frame in df",
1215: 	             py::arg("df"))
1216: 	        .def("from_arrow_table", &DuckDBPyConnection::from_arrow_table,
1217: 	             "Create a relation object from an Arrow table", py::arg("table"))
1218: 	        .def("df", &DuckDBPyConnection::from_df,
1219: 	             "Create a relation object from the Data.Frame in df (alias of from_df)", py::arg("df"))
1220: 	        .def("from_csv_auto", &DuckDBPyConnection::from_csv_auto,
1221: 	             "Create a relation object from the CSV file in file_name", py::arg("file_name"))
1222: 	        .def("from_parquet", &DuckDBPyConnection::from_parquet,
1223: 	             "Create a relation object from the Parquet file in file_name", py::arg("file_name"))
1224: 	        .def("__getattr__", &DuckDBPyConnection::getattr, "Get result set attributes, mainly column names");
1225: 
1226: 	py::class_<DuckDBPyResult>(m, "DuckDBPyResult")
1227: 	    .def("close", &DuckDBPyResult::close)
1228: 	    .def("fetchone", &DuckDBPyResult::fetchone)
1229: 	    .def("fetchall", &DuckDBPyResult::fetchall)
1230: 	    .def("fetchnumpy", &DuckDBPyResult::fetchnumpy)
1231: 	    .def("fetchdf", &DuckDBPyResult::fetchdf)
1232: 	    .def("fetch_df", &DuckDBPyResult::fetchdf)
1233: 	    .def("fetch_arrow_table", &DuckDBPyResult::fetch_arrow_table)
1234: 	    .def("arrow", &DuckDBPyResult::fetch_arrow_table)
1235: 	    .def("df", &DuckDBPyResult::fetchdf);
1236: 
1237: 	py::class_<DuckDBPyRelation>(m, "DuckDBPyRelation")
1238: 	    .def("filter", &DuckDBPyRelation::filter, "Filter the relation object by the filter in filter_expr",
1239: 	         py::arg("filter_expr"))
1240: 	    .def("project", &DuckDBPyRelation::project, "Project the relation object by the projection in project_expr",
1241: 	         py::arg("project_expr"))
1242: 	    .def("set_alias", &DuckDBPyRelation::alias, "Rename the relation object to new alias", py::arg("alias"))
1243: 	    .def("order", &DuckDBPyRelation::order, "Reorder the relation object by order_expr", py::arg("order_expr"))
1244: 	    .def("aggregate", &DuckDBPyRelation::aggregate,
1245: 	         "Compute the aggregate aggr_expr by the optional groups group_expr on the relation", py::arg("aggr_expr"),
1246: 	         py::arg("group_expr") = "")
1247: 	    .def("union", &DuckDBPyRelation::union_,
1248: 	         "Create the set union of this relation object with another relation object in other_rel")
1249: 	    .def("except_", &DuckDBPyRelation::except,
1250: 	         "Create the set except of this relation object with another relation object in other_rel",
1251: 	         py::arg("other_rel"))
1252: 	    .def("intersect", &DuckDBPyRelation::intersect,
1253: 	         "Create the set intersection of this relation object with another relation object in other_rel",
1254: 	         py::arg("other_rel"))
1255: 	    .def("join", &DuckDBPyRelation::join,
1256: 	         "Join the relation object with another relation object in other_rel using the join condition expression "
1257: 	         "in join_condition",
1258: 	         py::arg("other_rel"), py::arg("join_condition"))
1259: 	    .def("distinct", &DuckDBPyRelation::distinct, "Retrieve distinct rows from this relation object")
1260: 	    .def("limit", &DuckDBPyRelation::limit, "Only retrieve the first n rows from this relation object",
1261: 	         py::arg("n"))
1262: 	    .def("query", &DuckDBPyRelation::query,
1263: 	         "Run the given SQL query in sql_query on the view named virtual_table_name that refers to the relation "
1264: 	         "object",
1265: 	         py::arg("virtual_table_name"), py::arg("sql_query"))
1266: 	    .def("execute", &DuckDBPyRelation::execute, "Transform the relation into a result set")
1267: 	    .def("write_csv", &DuckDBPyRelation::write_csv, "Write the relation object to a CSV file in file_name",
1268: 	         py::arg("file_name"))
1269: 	    .def("insert_into", &DuckDBPyRelation::insert_into,
1270: 	         "Inserts the relation object into an existing table named table_name", py::arg("table_name"))
1271: 	    .def("insert", &DuckDBPyRelation::insert, "Inserts the given values into the relation", py::arg("values"))
1272: 	    .def("create", &DuckDBPyRelation::create,
1273: 	         "Creates a new table named table_name with the contents of the relation object", py::arg("table_name"))
1274: 	    .def("create_view", &DuckDBPyRelation::create_view,
1275: 	         "Creates a view named view_name that refers to the relation object", py::arg("view_name"),
1276: 	         py::arg("replace") = true)
1277: 	    .def("to_arrow_table", &DuckDBPyRelation::to_arrow_table, "Transforms the relation object into a Arrow table")
1278: 	    .def("arrow", &DuckDBPyRelation::to_arrow_table, "Transforms the relation object into a Arrow table")
1279: 	    .def("to_df", &DuckDBPyRelation::to_df, "Transforms the relation object into a Data.Frame")
1280: 	    .def("df", &DuckDBPyRelation::to_df, "Transforms the relation object into a Data.Frame")
1281: 	    .def("__str__", &DuckDBPyRelation::print)
1282: 	    .def("__repr__", &DuckDBPyRelation::print)
1283: 	    .def("__getattr__", &DuckDBPyRelation::getattr);
1284: 
1285: 	m.def("values", &DuckDBPyRelation::values, "Create a relation object from the passed values", py::arg("values"));
1286: 	m.def("from_csv_auto", &DuckDBPyRelation::from_csv_auto, "Creates a relation object from the CSV file in file_name",
1287: 	      py::arg("file_name"));
1288: 	m.def("from_parquet", &DuckDBPyRelation::from_parquet,
1289: 	      "Creates a relation object from the Parquet file in file_name", py::arg("file_name"));
1290: 	m.def("df", &DuckDBPyRelation::from_df, "Create a relation object from the Data.Frame df", py::arg("df"));
1291: 	m.def("from_df", &DuckDBPyRelation::from_df, "Create a relation object from the Data.Frame df", py::arg("df"));
1292: 	m.def("from_arrow_table", &DuckDBPyRelation::from_arrow_table, "Create a relation object from an Arrow table",
1293: 	      py::arg("table"));
1294: 	m.def("arrow", &DuckDBPyRelation::from_arrow_table, "Create a relation object from an Arrow table",
1295: 	      py::arg("table"));
1296: 	m.def("filter", &DuckDBPyRelation::filter_df, "Filter the Data.Frame df by the filter in filter_expr",
1297: 	      py::arg("df"), py::arg("filter_expr"));
1298: 	m.def("project", &DuckDBPyRelation::project_df, "Project the Data.Frame df by the projection in project_expr",
1299: 	      py::arg("df"), py::arg("project_expr"));
1300: 	m.def("alias", &DuckDBPyRelation::alias_df, "Create a relation from Data.Frame df with the passed alias",
1301: 	      py::arg("df"), py::arg("alias"));
1302: 	m.def("order", &DuckDBPyRelation::order_df, "Reorder the Data.Frame df by order_expr", py::arg("df"),
1303: 	      py::arg("order_expr"));
1304: 	m.def("aggregate", &DuckDBPyRelation::aggregate_df,
1305: 	      "Compute the aggregate aggr_expr by the optional groups group_expr on Data.frame df", py::arg("df"),
1306: 	      py::arg("aggr_expr"), py::arg("group_expr") = "");
1307: 	m.def("distinct", &DuckDBPyRelation::distinct_df, "Compute the distinct rows from Data.Frame df ", py::arg("df"));
1308: 	m.def("limit", &DuckDBPyRelation::limit_df, "Retrieve the first n rows from the Data.Frame df", py::arg("df"),
1309: 	      py::arg("n"));
1310: 	m.def("query", &DuckDBPyRelation::query_df,
1311: 	      "Run the given SQL query in sql_query on the view named virtual_table_name that contains the content of "
1312: 	      "Data.Frame df",
1313: 	      py::arg("df"), py::arg("virtual_table_name"), py::arg("sql_query"));
1314: 	m.def("write_csv", &DuckDBPyRelation::write_csv_df, "Write the Data.Frame df to a CSV file in file_name",
1315: 	      py::arg("df"), py::arg("file_name"));
1316: 
1317: 	// we need this because otherwise we try to remove registered_dfs on shutdown when python is already dead
1318: 	auto clean_default_connection = []() { default_connection_.reset(); };
1319: 	m.add_object("_clean_default_connection", py::capsule(clean_default_connection));
1320: 	PyDateTime_IMPORT;
1321: }
[end of tools/pythonpkg/duckdb_python.cpp]
[start of tools/rpkg/src/duckdbr.cpp]
1: #include "duckdb/common/types/date.hpp"
2: #include "duckdb/common/types/hugeint.hpp"
3: #include "duckdb/common/types/timestamp.hpp"
4: #include "duckdb/common/unordered_map.hpp"
5: #include "duckdb.hpp"
6: #include "duckdb/main/client_context.hpp"
7: #include "duckdb/main/stream_query_result.hpp"
8: #include "duckdb/transaction/transaction.hpp"
9: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
10: #include "parquet-extension.hpp"
11: 
12: #include <Rdefines.h>
13: #include <algorithm>
14: #include <sstream>
15: 
16: // motherfucker
17: #undef error
18: 
19: using namespace duckdb;
20: using namespace std;
21: 
22: struct RStatement {
23: 	unique_ptr<PreparedStatement> stmt;
24: 	vector<Value> parameters;
25: };
26: 
27: // converter for primitive types
28: template <class SRC, class DEST>
29: static void vector_to_r(Vector &src_vec, size_t count, void *dest, uint64_t dest_offset, DEST na_val) {
30: 	auto src_ptr = FlatVector::GetData<SRC>(src_vec);
31: 	auto &nullmask = FlatVector::Nullmask(src_vec);
32: 	auto dest_ptr = ((DEST *)dest) + dest_offset;
33: 	for (size_t row_idx = 0; row_idx < count; row_idx++) {
34: 		dest_ptr[row_idx] = nullmask[row_idx] ? na_val : src_ptr[row_idx];
35: 	}
36: }
37: 
38: struct RIntegralType {
39: 	template<class T>
40: 	static double DoubleCast(T val) {
41: 		return double(val);
42: 	}
43: };
44: 
45: template<class T>
46: static void RDecimalCastLoop(Vector &src_vec, size_t count, double *dest_ptr, uint8_t scale) {
47: 	auto src_ptr = FlatVector::GetData<T>(src_vec);
48: 	auto &nullmask = FlatVector::Nullmask(src_vec);
49: 	double division = pow(10, scale);
50: 	for (size_t row_idx = 0; row_idx < count; row_idx++) {
51: 		dest_ptr[row_idx] = nullmask[row_idx] ? NA_REAL : RIntegralType::DoubleCast<T>(src_ptr[row_idx]) / division;
52: 	}
53: }
54: 
55: template <> double RIntegralType::DoubleCast<>(hugeint_t val) {
56: 	return Hugeint::Cast<double>(val);
57: }
58: 
59: struct RDoubleType {
60: 	static bool IsNull(double val) {
61: 		return ISNA(val);
62: 	}
63: 
64: 	static double Convert(double val) {
65: 		return val;
66: 	}
67: };
68: 
69: struct RDateType {
70: 	static bool IsNull(double val) {
71: 		return RDoubleType::IsNull(val);
72: 	}
73: 
74: 	static double Convert(double val) {
75: 		return (date_t)val + 719528; // MAGIC!
76: 	}
77: };
78: 
79: struct RTimestampType {
80: 	static bool IsNull(double val) {
81: 		return RDoubleType::IsNull(val);
82: 	}
83: 
84: 	static timestamp_t Convert(double val) {
85: 		date_t date = Date::EpochToDate((int64_t)val);
86: 		dtime_t time = (dtime_t)(((int64_t)val % (60 * 60 * 24)) * 1000);
87: 		return Timestamp::FromDatetime(date, time);
88: 	}
89: };
90: 
91: struct RIntegerType {
92: 	static bool IsNull(int val) {
93: 		return val == NA_INTEGER;
94: 	}
95: 
96: 	static int Convert(int val) {
97: 		return val;
98: 	}
99: };
100: 
101: struct RBooleanType {
102: 	static bool IsNull(int val) {
103: 		return RIntegerType::IsNull(val);
104: 	}
105: 
106: 	static bool Convert(int val) {
107: 		return val;
108: 	}
109: };
110: 
111: template <class SRC, class DST, class RTYPE>
112: static void AppendColumnSegment(SRC *source_data, Vector &result, idx_t count) {
113: 	auto result_data = FlatVector::GetData<DST>(result);
114: 	auto &result_mask = FlatVector::Nullmask(result);
115: 	for (idx_t i = 0; i < count; i++) {
116: 		auto val = source_data[i];
117: 		if (RTYPE::IsNull(val)) {
118: 			result_mask[i] = true;
119: 		} else {
120: 			result_data[i] = RTYPE::Convert(val);
121: 		}
122: 	}
123: }
124: 
125: static void AppendStringSegment(SEXP coldata, Vector &result, idx_t row_idx, idx_t count) {
126: 	auto result_data = FlatVector::GetData<string_t>(result);
127: 	auto &result_mask = FlatVector::Nullmask(result);
128: 	for (idx_t i = 0; i < count; i++) {
129: 		SEXP val = STRING_ELT(coldata, row_idx + i);
130: 		if (val == NA_STRING) {
131: 			result_mask[i] = true;
132: 		} else {
133: 			result_data[i] = string_t((char *)CHAR(val));
134: 		}
135: 	}
136: }
137: 
138: static void AppendFactor(SEXP coldata, Vector &result, idx_t row_idx, idx_t count) {
139: 	auto source_data = INTEGER_POINTER(coldata) + row_idx;
140: 	auto result_data = FlatVector::GetData<string_t>(result);
141: 	auto &result_mask = FlatVector::Nullmask(result);
142: 	SEXP factor_levels = GET_LEVELS(coldata);
143: 	for (idx_t i = 0; i < count; i++) {
144: 		int val = source_data[i];
145: 		if (RIntegerType::IsNull(val)) {
146: 			result_mask[i] = true;
147: 		} else {
148: 			result_data[i] = string_t(CHAR(STRING_ELT(factor_levels, val - 1)));
149: 		}
150: 	}
151: }
152: 
153: static SEXP cstr_to_charsexp(const char *s) {
154: 	return mkCharCE(s, CE_UTF8);
155: }
156: 
157: static SEXP cpp_str_to_charsexp(string s) {
158: 	return cstr_to_charsexp(s.c_str());
159: }
160: 
161: static SEXP cpp_str_to_strsexp(vector<string> s) {
162: 	SEXP retsexp = PROTECT(NEW_STRING(s.size()));
163: 	for (idx_t i = 0; i < s.size(); i++) {
164: 		SET_STRING_ELT(retsexp, i, cpp_str_to_charsexp(s[i]));
165: 	}
166: 	UNPROTECT(1);
167: 	return retsexp;
168: }
169: 
170: enum class RType { UNKNOWN, LOGICAL, INTEGER, NUMERIC, STRING, FACTOR, DATE, TIMESTAMP };
171: 
172: static RType detect_rtype(SEXP v) {
173: 	if (TYPEOF(v) == REALSXP && TYPEOF(GET_CLASS(v)) == STRSXP &&
174: 	    strcmp("POSIXct", CHAR(STRING_ELT(GET_CLASS(v), 0))) == 0) {
175: 		return RType::TIMESTAMP;
176: 	} else if (TYPEOF(v) == REALSXP && TYPEOF(GET_CLASS(v)) == STRSXP &&
177: 	           strcmp("Date", CHAR(STRING_ELT(GET_CLASS(v), 0))) == 0) {
178: 		return RType::DATE;
179: 	} else if (isFactor(v) && TYPEOF(v) == INTSXP) {
180: 		return RType::FACTOR;
181: 	} else if (TYPEOF(v) == LGLSXP) {
182: 		return RType::LOGICAL;
183: 	} else if (TYPEOF(v) == INTSXP) {
184: 		return RType::INTEGER;
185: 	} else if (TYPEOF(v) == REALSXP) {
186: 		return RType::NUMERIC;
187: 	} else if (TYPEOF(v) == STRSXP) {
188: 		return RType::STRING;
189: 	}
190: 	return RType::UNKNOWN;
191: }
192: 
193: extern "C" {
194: 
195: SEXP duckdb_release_R(SEXP stmtsexp) {
196: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
197: 		Rf_error("duckdb_release_R: Need external pointer parameter");
198: 	}
199: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
200: 	if (stmtsexp) {
201: 		R_ClearExternalPtr(stmtsexp);
202: 		delete stmtholder;
203: 	}
204: 	return R_NilValue;
205: }
206: 
207: SEXP duckdb_finalize_statement_R(SEXP stmtsexp) {
208: 	return duckdb_release_R(stmtsexp);
209: }
210: 
211: SEXP duckdb_prepare_R(SEXP connsexp, SEXP querysexp) {
212: 	if (TYPEOF(querysexp) != STRSXP || LENGTH(querysexp) != 1) {
213: 		Rf_error("duckdb_prepare_R: Need single string parameter for query");
214: 	}
215: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
216: 		Rf_error("duckdb_prepare_R: Need external pointer parameter for connections");
217: 	}
218: 
219: 	char *query = (char *)CHAR(STRING_ELT(querysexp, 0));
220: 	if (!query) {
221: 		Rf_error("duckdb_prepare_R: No query");
222: 	}
223: 
224: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
225: 	if (!conn) {
226: 		Rf_error("duckdb_prepare_R: Invalid connection");
227: 	}
228: 
229: 	auto stmt = conn->Prepare(query);
230: 	if (!stmt->success) {
231: 		Rf_error("duckdb_prepare_R: Failed to prepare query %s\nError: %s", query, stmt->error.c_str());
232: 	}
233: 
234: 	auto stmtholder = new RStatement();
235: 	stmtholder->stmt = move(stmt);
236: 
237: 	SEXP retlist = PROTECT(NEW_LIST(6));
238: 
239: 	SEXP stmtsexp = PROTECT(R_MakeExternalPtr(stmtholder, R_NilValue, R_NilValue));
240: 	R_RegisterCFinalizer(stmtsexp, (void (*)(SEXP))duckdb_finalize_statement_R);
241: 
242: 	SEXP ret_names = cpp_str_to_strsexp({"str", "ref", "type", "names", "rtypes", "n_param"});
243: 	SET_NAMES(retlist, ret_names);
244: 
245: 	SET_VECTOR_ELT(retlist, 0, querysexp);
246: 	SET_VECTOR_ELT(retlist, 1, stmtsexp);
247: 	UNPROTECT(1); // stmtsxp
248: 
249: 	SEXP stmt_type = cpp_str_to_strsexp({StatementTypeToString(stmtholder->stmt->type)});
250: 	SET_VECTOR_ELT(retlist, 2, stmt_type);
251: 
252: 	SEXP col_names = cpp_str_to_strsexp(stmtholder->stmt->names);
253: 	SET_VECTOR_ELT(retlist, 3, col_names);
254: 
255: 	vector<string> rtypes;
256: 
257: 	for (auto &stype : stmtholder->stmt->types) {
258: 		string rtype = "";
259: 		switch (stype.id()) {
260: 		case LogicalTypeId::BOOLEAN:
261: 			rtype = "logical";
262: 			break;
263: 		case LogicalTypeId::TINYINT:
264: 		case LogicalTypeId::SMALLINT:
265: 		case LogicalTypeId::INTEGER:
266: 			rtype = "integer";
267: 			break;
268: 		case LogicalTypeId::TIMESTAMP:
269: 			rtype = "POSIXct";
270: 			break;
271: 		case LogicalTypeId::DATE:
272: 			rtype = "Date";
273: 			break;
274: 		case LogicalTypeId::TIME:
275: 			rtype = "difftime";
276: 			break;
277: 		case LogicalTypeId::BIGINT:
278: 		case LogicalTypeId::HUGEINT:
279: 		case LogicalTypeId::FLOAT:
280: 		case LogicalTypeId::DOUBLE:
281: 		case LogicalTypeId::DECIMAL:
282: 			rtype = "numeric";
283: 			break;
284: 		case LogicalTypeId::VARCHAR: {
285: 			rtype = "character";
286: 			break;
287: 		}
288: 		default:
289: 			UNPROTECT(1); // retlist
290: 			Rf_error("duckdb_prepare_R: Unknown column type for prepare: %s", stype.ToString().c_str());
291: 			break;
292: 		}
293: 		rtypes.push_back(rtype);
294: 	}
295: 
296: 	SEXP rtypessexp = cpp_str_to_strsexp(rtypes);
297: 	SET_VECTOR_ELT(retlist, 4, rtypessexp);
298: 
299: 	SET_VECTOR_ELT(retlist, 5, ScalarInteger(stmtholder->stmt->n_param));
300: 
301: 	UNPROTECT(1); // retlist
302: 	return retlist;
303: }
304: 
305: SEXP duckdb_bind_R(SEXP stmtsexp, SEXP paramsexp) {
306: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
307: 		Rf_error("duckdb_bind_R: Need external pointer parameter");
308: 	}
309: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
310: 	if (!stmtholder || !stmtholder->stmt) {
311: 		Rf_error("duckdb_bind_R: Invalid statement");
312: 	}
313: 
314: 	stmtholder->parameters.clear();
315: 	stmtholder->parameters.resize(stmtholder->stmt->n_param);
316: 
317: 	if (stmtholder->stmt->n_param == 0) {
318: 		Rf_error("duckdb_bind_R: dbBind called but query takes no parameters");
319: 		return R_NilValue;
320: 	}
321: 
322: 	if (TYPEOF(paramsexp) != VECSXP || (idx_t)LENGTH(paramsexp) != stmtholder->stmt->n_param) {
323: 		Rf_error("duckdb_bind_R: bind parameters need to be a list of length %i", stmtholder->stmt->n_param);
324: 	}
325: 
326: 	for (idx_t param_idx = 0; param_idx < (idx_t)LENGTH(paramsexp); param_idx++) {
327: 		Value val;
328: 		SEXP valsexp = VECTOR_ELT(paramsexp, param_idx);
329: 		if (LENGTH(valsexp) != 1) {
330: 			Rf_error("duckdb_bind_R: bind parameter values need to have length 1");
331: 		}
332: 		auto rtype = detect_rtype(valsexp);
333: 		switch (rtype) {
334: 		case RType::LOGICAL: {
335: 			auto lgl_val = INTEGER_POINTER(valsexp)[0];
336: 			val = Value::BOOLEAN(lgl_val);
337: 			val.is_null = RBooleanType::IsNull(lgl_val);
338: 			break;
339: 		}
340: 		case RType::INTEGER: {
341: 			auto int_val = INTEGER_POINTER(valsexp)[0];
342: 			val = Value::INTEGER(int_val);
343: 			val.is_null = RIntegerType::IsNull(int_val);
344: 			break;
345: 		}
346: 		case RType::NUMERIC: {
347: 			auto dbl_val = NUMERIC_POINTER(valsexp)[0];
348: 			val = Value::DOUBLE(dbl_val);
349: 			val.is_null = RDoubleType::IsNull(dbl_val);
350: 			break;
351: 		}
352: 		case RType::STRING: {
353: 			auto str_val = STRING_ELT(valsexp, 0);
354: 			val = Value(CHAR(str_val));
355: 			val.is_null = str_val == NA_STRING;
356: 			break;
357: 		}
358: 		case RType::FACTOR: {
359: 			auto int_val = INTEGER_POINTER(valsexp)[0];
360: 			auto levels = GET_LEVELS(valsexp);
361: 			bool is_null = RIntegerType::IsNull(int_val);
362: 			if (!is_null) {
363: 				auto str_val = STRING_ELT(levels, int_val - 1);
364: 				val = Value(CHAR(str_val));
365: 			} else {
366: 				val = Value(LogicalType::VARCHAR);
367: 			}
368: 			break;
369: 		}
370: 		case RType::TIMESTAMP: {
371: 			auto ts_val = NUMERIC_POINTER(valsexp)[0];
372: 			val = Value::TIMESTAMP(RTimestampType::Convert(ts_val));
373: 			val.is_null = RTimestampType::IsNull(ts_val);
374: 			break;
375: 		}
376: 		case RType::DATE: {
377: 			auto d_val = NUMERIC_POINTER(valsexp)[0];
378: 			val = Value::DATE(RDateType::Convert(d_val));
379: 			val.is_null = RDateType::IsNull(d_val);
380: 			break;
381: 		}
382: 		default:
383: 			Rf_error("duckdb_bind_R: Unsupported parameter type");
384: 		}
385: 		stmtholder->parameters[param_idx] = val;
386: 	}
387: 	return R_NilValue;
388: }
389: 
390: SEXP duckdb_execute_R(SEXP stmtsexp) {
391: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
392: 		Rf_error("duckdb_execute_R: Need external pointer parameter");
393: 	}
394: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
395: 	if (!stmtholder || !stmtholder->stmt) {
396: 		Rf_error("duckdb_execute_R: Invalid statement");
397: 	}
398: 
399: 	auto generic_result = stmtholder->stmt->Execute(stmtholder->parameters, false);
400: 
401: 	if (!generic_result->success) {
402: 		Rf_error("duckdb_execute_R: Failed to run query\nError: %s", generic_result->error.c_str());
403: 	}
404: 	assert(generic_result->type == QueryResultType::MATERIALIZED_RESULT);
405: 	MaterializedQueryResult *result = (MaterializedQueryResult *)generic_result.get();
406: 
407: 	// step 2: create result data frame and allocate columns
408: 	uint32_t ncols = result->types.size();
409: 	uint64_t nrows = result->collection.count;
410: 
411: 	if (ncols > 0) {
412: 		SEXP retlist = PROTECT(NEW_LIST(ncols));
413: 		SET_NAMES(retlist, cpp_str_to_strsexp(result->names));
414: 
415: 		for (size_t col_idx = 0; col_idx < ncols; col_idx++) {
416: 			SEXP varvalue = NULL;
417: 			switch (result->types[col_idx].id()) {
418: 			case LogicalTypeId::BOOLEAN:
419: 				varvalue = PROTECT(NEW_LOGICAL(nrows));
420: 				break;
421: 			case LogicalTypeId::TINYINT:
422: 			case LogicalTypeId::SMALLINT:
423: 			case LogicalTypeId::INTEGER:
424: 				varvalue = PROTECT(NEW_INTEGER(nrows));
425: 				break;
426: 			case LogicalTypeId::BIGINT:
427: 			case LogicalTypeId::HUGEINT:
428: 			case LogicalTypeId::FLOAT:
429: 			case LogicalTypeId::DOUBLE:
430: 			case LogicalTypeId::DECIMAL:
431: 			case LogicalTypeId::TIMESTAMP:
432: 			case LogicalTypeId::DATE:
433: 			case LogicalTypeId::TIME:
434: 				varvalue = PROTECT(NEW_NUMERIC(nrows));
435: 				break;
436: 			case LogicalTypeId::VARCHAR:
437: 				varvalue = PROTECT(NEW_STRING(nrows));
438: 				break;
439: 			default:
440: 				UNPROTECT(1); // retlist
441: 				Rf_error("duckdb_execute_R: Unknown column type for execute: %s",
442: 				         result->types[col_idx].ToString().c_str());
443: 			}
444: 			SET_VECTOR_ELT(retlist, col_idx, varvalue);
445: 			UNPROTECT(1); /* varvalue */
446: 		}
447: 
448: 		// at this point retlist is fully allocated and the only protected SEXP
449: 
450: 		// step 3: set values from chunks
451: 		uint64_t dest_offset = 0;
452: 		while (true) {
453: 			auto chunk = result->Fetch();
454: 			if (chunk->size() == 0) {
455: 				break;
456: 			}
457: 			assert(chunk->column_count() == ncols);
458: 			assert(chunk->column_count() == LENGTH(retlist));
459: 			for (size_t col_idx = 0; col_idx < chunk->column_count(); col_idx++) {
460: 				SEXP dest = VECTOR_ELT(retlist, col_idx);
461: 				switch (result->types[col_idx].id()) {
462: 				case LogicalTypeId::BOOLEAN:
463: 					vector_to_r<int8_t, uint32_t>(chunk->data[col_idx], chunk->size(), LOGICAL_POINTER(dest),
464: 					                              dest_offset, NA_LOGICAL);
465: 					break;
466: 				case LogicalTypeId::TINYINT:
467: 					vector_to_r<int8_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest),
468: 					                              dest_offset, NA_INTEGER);
469: 					break;
470: 				case LogicalTypeId::SMALLINT:
471: 					vector_to_r<int16_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest),
472: 					                               dest_offset, NA_INTEGER);
473: 					break;
474: 				case LogicalTypeId::INTEGER:
475: 					vector_to_r<int32_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest),
476: 					                               dest_offset, NA_INTEGER);
477: 					break;
478: 				case LogicalTypeId::TIMESTAMP: {
479: 					auto &src_vec = chunk->data[col_idx];
480: 					auto src_data = FlatVector::GetData<int64_t>(src_vec);
481: 					auto &nullmask = FlatVector::Nullmask(src_vec);
482: 					double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
483: 					for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
484: 						dest_ptr[row_idx] =
485: 						    nullmask[row_idx] ? NA_REAL : (double)Timestamp::GetEpoch(src_data[row_idx]);
486: 					}
487: 
488: 					// some dresssup for R
489: 					SEXP cl = PROTECT(NEW_STRING(2));
490: 					SET_STRING_ELT(cl, 0, PROTECT(mkChar("POSIXct")));
491: 					SET_STRING_ELT(cl, 1, PROTECT(mkChar("POSIXt")));
492: 					SET_CLASS(dest, cl);
493: 					setAttrib(dest, install("tzone"), PROTECT(mkString("UTC")));
494: 					UNPROTECT(4);
495: 					break;
496: 				}
497: 				case LogicalTypeId::DATE: {
498: 					auto &src_vec = chunk->data[col_idx];
499: 					auto src_data = FlatVector::GetData<int32_t>(src_vec);
500: 					auto &nullmask = FlatVector::Nullmask(src_vec);
501: 					double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
502: 					for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
503: 						dest_ptr[row_idx] = nullmask[row_idx] ? NA_REAL : (double)(src_data[row_idx]) - 719528;
504: 					}
505: 
506: 					// some dresssup for R
507: 					SET_CLASS(dest, PROTECT(mkString("Date")));
508: 					UNPROTECT(1);
509: 					break;
510: 				}
511: 				case LogicalTypeId::TIME: {
512: 					auto &src_vec = chunk->data[col_idx];
513: 					auto src_data = FlatVector::GetData<int32_t>(src_vec);
514: 					auto &nullmask = FlatVector::Nullmask(src_vec);
515: 					double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
516: 					for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
517: 
518: 						if (nullmask[row_idx]) {
519: 							dest_ptr[row_idx] = NA_REAL;
520: 						} else {
521: 							time_t n = src_data[row_idx];
522: 							int h;
523: 							double frac;
524: 							h = n / 3600000;
525: 							n -= h * 3600000;
526: 							frac = (n / 60000.0) / 60.0;
527: 							dest_ptr[row_idx] = h + frac;
528: 						}
529: 					}
530: 
531: 					// some dresssup for R
532: 					SET_CLASS(dest, PROTECT(mkString("difftime")));
533: 					setAttrib(dest, install("units"), PROTECT(mkString("hours")));
534: 					UNPROTECT(2);
535: 					break;
536: 				}
537: 				case LogicalTypeId::BIGINT:
538: 					vector_to_r<int64_t, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest),
539: 					                             dest_offset, NA_REAL);
540: 					break;
541: 				case LogicalTypeId::HUGEINT: {
542: 					auto &src_vec = chunk->data[col_idx];
543: 					auto src_data = FlatVector::GetData<hugeint_t>(src_vec);
544: 					auto &nullmask = FlatVector::Nullmask(src_vec);
545: 					double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
546: 					for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
547: 						if (nullmask[row_idx]) {
548: 							dest_ptr[row_idx] = NA_REAL;
549: 						} else {
550: 							Hugeint::TryCast(src_data[row_idx], dest_ptr[row_idx]);
551: 						}
552: 					}
553: 					break;
554: 				}
555: 				case LogicalTypeId::DECIMAL: {
556: 					auto &src_vec = chunk->data[col_idx];
557: 					auto &decimal_type = result->types[col_idx];
558: 					double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
559: 					auto dec_scale = decimal_type.scale();
560: 					switch(decimal_type.InternalType()) {
561: 					case PhysicalType::INT16:
562: 						RDecimalCastLoop<int16_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
563: 						break;
564: 					case PhysicalType::INT32:
565: 						RDecimalCastLoop<int32_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
566: 						break;
567: 					case PhysicalType::INT64:
568: 						RDecimalCastLoop<int64_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
569: 						break;
570: 					case PhysicalType::INT128:
571: 						RDecimalCastLoop<hugeint_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
572: 						break;
573: 					default:
574: 						throw NotImplementedException("Unimplemented internal type for DECIMAL");
575: 					}
576: 					break;
577: 				}
578: 				case LogicalTypeId::FLOAT:
579: 					vector_to_r<float, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
580: 					                           NA_REAL);
581: 					break;
582: 
583: 				case LogicalTypeId::DOUBLE:
584: 					vector_to_r<double, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
585: 					                            NA_REAL);
586: 					break;
587: 				case LogicalTypeId::VARCHAR: {
588: 					auto src_ptr = FlatVector::GetData<string_t>(chunk->data[col_idx]);
589: 					auto &nullmask = FlatVector::Nullmask(chunk->data[col_idx]);
590: 					for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
591: 						if (nullmask[row_idx]) {
592: 							SET_STRING_ELT(dest, dest_offset + row_idx, NA_STRING);
593: 						} else {
594: 							SET_STRING_ELT(dest, dest_offset + row_idx, mkCharCE(src_ptr[row_idx].GetData(), CE_UTF8));
595: 						}
596: 					}
597: 					break;
598: 				}
599: 				default:
600: 					Rf_error("duckdb_execute_R: Unknown column type for convert: %s",
601: 					         chunk->GetTypes()[col_idx].ToString().c_str());
602: 					break;
603: 				}
604: 			}
605: 			dest_offset += chunk->size();
606: 		}
607: 
608: 		assert(dest_offset == nrows);
609: 		UNPROTECT(1); /* retlist */
610: 		return retlist;
611: 	}
612: 	return ScalarReal(0); // no need for protection because no allocation can happen afterwards
613: }
614: 
615: static SEXP duckdb_finalize_database_R(SEXP dbsexp) {
616: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
617: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
618: 	}
619: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
620: 	if (dbaddr) {
621: 		warning("duckdb_finalize_database_R: Database is garbage-collected, use dbDisconnect(con, shutdown=TRUE) or "
622: 		        "duckdb::duckdb_shutdown(drv) to avoid this.");
623: 		R_ClearExternalPtr(dbsexp);
624: 		delete dbaddr;
625: 	}
626: 	return R_NilValue;
627: }
628: 
629: struct DataFrameScanFunctionData : public TableFunctionData {
630: 	DataFrameScanFunctionData(SEXP df, idx_t row_count, vector<RType> rtypes)
631: 	    : df(df), row_count(row_count), rtypes(rtypes), position(0) {
632: 	}
633: 	SEXP df;
634: 	idx_t row_count;
635: 	vector<RType> rtypes;
636: 	idx_t position;
637: };
638: 
639: struct DataFrameScanFunction : public TableFunction {
640: 	DataFrameScanFunction()
641: 	    : TableFunction("dataframe_scan", {LogicalType::VARCHAR}, dataframe_scan_bind, dataframe_scan_function,
642: 	                    nullptr){};
643: 
644: 	static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> &inputs,
645: 	                                                    unordered_map<string, Value> &named_parameters,
646: 	                                                    vector<LogicalType> &return_types, vector<string> &names) {
647: 		// TODO have a better way to pass this pointer
648: 		SEXP df((SEXP)std::stoull(inputs[0].GetValue<string>(), nullptr, 16));
649: 
650: 		auto df_names = GET_NAMES(df);
651: 		vector<RType> rtypes;
652: 
653: 		for (idx_t col_idx = 0; col_idx < (idx_t)LENGTH(df); col_idx++) {
654: 			names.push_back(string(CHAR(STRING_ELT(df_names, col_idx))));
655: 			SEXP coldata = VECTOR_ELT(df, col_idx);
656: 			rtypes.push_back(detect_rtype(coldata));
657: 			LogicalType duckdb_col_type;
658: 			switch (rtypes[col_idx]) {
659: 			case RType::LOGICAL:
660: 				duckdb_col_type = LogicalType::BOOLEAN;
661: 				break;
662: 			case RType::INTEGER:
663: 				duckdb_col_type = LogicalType::INTEGER;
664: 				break;
665: 			case RType::NUMERIC:
666: 				duckdb_col_type = LogicalType::DOUBLE;
667: 				break;
668: 			case RType::FACTOR:
669: 			case RType::STRING:
670: 				duckdb_col_type = LogicalType::VARCHAR;
671: 				break;
672: 			case RType::TIMESTAMP:
673: 				duckdb_col_type = LogicalType::TIMESTAMP;
674: 				break;
675: 			case RType::DATE:
676: 				duckdb_col_type = LogicalType::DATE;
677: 				break;
678: 			default:
679: 				Rf_error("Unsupported column type for scan");
680: 			}
681: 			return_types.push_back(duckdb_col_type);
682: 		}
683: 
684: 		auto row_count = LENGTH(VECTOR_ELT(df, 0));
685: 		return make_unique<DataFrameScanFunctionData>(df, row_count, rtypes);
686: 	}
687: 
688: 	static void dataframe_scan_function(ClientContext &context, vector<Value> &input, DataChunk &output,
689: 	                                    FunctionData *dataptr) {
690: 		auto &data = *((DataFrameScanFunctionData *)dataptr);
691: 
692: 		if (data.position >= data.row_count) {
693: 			return;
694: 		}
695: 		idx_t this_count = std::min((idx_t)STANDARD_VECTOR_SIZE, data.row_count - data.position);
696: 
697: 		output.SetCardinality(this_count);
698: 
699: 		// TODO this is quite similar to append, unify!
700: 		for (idx_t col_idx = 0; col_idx < output.column_count(); col_idx++) {
701: 			auto &v = output.data[col_idx];
702: 			SEXP coldata = VECTOR_ELT(data.df, col_idx);
703: 
704: 			switch (data.rtypes[col_idx]) {
705: 			case RType::LOGICAL: {
706: 				auto data_ptr = INTEGER_POINTER(coldata) + data.position;
707: 				AppendColumnSegment<int, bool, RBooleanType>(data_ptr, v, this_count);
708: 				break;
709: 			}
710: 			case RType::INTEGER: {
711: 				auto data_ptr = INTEGER_POINTER(coldata) + data.position;
712: 				AppendColumnSegment<int, int, RIntegerType>(data_ptr, v, this_count);
713: 				break;
714: 			}
715: 			case RType::NUMERIC: {
716: 				auto data_ptr = NUMERIC_POINTER(coldata) + data.position;
717: 				AppendColumnSegment<double, double, RDoubleType>(data_ptr, v, this_count);
718: 				break;
719: 			}
720: 			case RType::STRING:
721: 				AppendStringSegment(coldata, v, data.position, this_count);
722: 				break;
723: 			case RType::FACTOR:
724: 				AppendFactor(coldata, v, data.position, this_count);
725: 				break;
726: 			case RType::TIMESTAMP: {
727: 				auto data_ptr = NUMERIC_POINTER(coldata) + data.position;
728: 				AppendColumnSegment<double, timestamp_t, RTimestampType>(data_ptr, v, this_count);
729: 				break;
730: 			}
731: 			case RType::DATE: {
732: 				auto data_ptr = NUMERIC_POINTER(coldata) + data.position;
733: 				AppendColumnSegment<double, date_t, RDateType>(data_ptr, v, this_count);
734: 				break;
735: 			}
736: 			default:
737: 				throw;
738: 			}
739: 		}
740: 
741: 		data.position += this_count;
742: 	}
743: };
744: 
745: SEXP duckdb_startup_R(SEXP dbdirsexp, SEXP readonlysexp) {
746: 	if (TYPEOF(dbdirsexp) != STRSXP || LENGTH(dbdirsexp) != 1) {
747: 		Rf_error("duckdb_startup_R: Need string parameter for dbdir");
748: 	}
749: 	char *dbdir = (char *)CHAR(STRING_ELT(dbdirsexp, 0));
750: 
751: 	if (TYPEOF(readonlysexp) != LGLSXP || LENGTH(readonlysexp) != 1) {
752: 		Rf_error("duckdb_startup_R: Need string parameter for read_only");
753: 	}
754: 	bool read_only = (bool)LOGICAL_ELT(readonlysexp, 0);
755: 
756: 	if (strlen(dbdir) == 0 || strcmp(dbdir, ":memory:") == 0) {
757: 		dbdir = NULL;
758: 	}
759: 
760: 	DBConfig config;
761: 	config.access_mode = AccessMode::READ_WRITE;
762: 	if (read_only) {
763: 		config.access_mode = AccessMode::READ_ONLY;
764: 	}
765: 	DuckDB *dbaddr;
766: 	try {
767: 		dbaddr = new DuckDB(dbdir, &config);
768: 	} catch (...) {
769: 		Rf_error("duckdb_startup_R: Failed to open database");
770: 	}
771: 	dbaddr->LoadExtension<ParquetExtension>();
772: 
773: 	DataFrameScanFunction scan_fun;
774: 	CreateTableFunctionInfo info(scan_fun);
775: 	Connection conn(*dbaddr);
776: 	auto &context = *conn.context;
777: 	context.transaction.BeginTransaction();
778: 	context.catalog.CreateTableFunction(context, &info);
779: 	context.transaction.Commit();
780: 
781: 	SEXP dbsexp = PROTECT(R_MakeExternalPtr(dbaddr, R_NilValue, R_NilValue));
782: 	R_RegisterCFinalizer(dbsexp, (void (*)(SEXP))duckdb_finalize_database_R);
783: 	UNPROTECT(1);
784: 	return dbsexp;
785: }
786: 
787: SEXP duckdb_shutdown_R(SEXP dbsexp) {
788: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
789: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
790: 	}
791: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
792: 	if (dbaddr) {
793: 		R_ClearExternalPtr(dbsexp);
794: 		delete dbaddr;
795: 	}
796: 
797: 	return R_NilValue;
798: }
799: 
800: static SEXP duckdb_finalize_connection_R(SEXP connsexp) {
801: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
802: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
803: 	}
804: 	Connection *connaddr = (Connection *)R_ExternalPtrAddr(connsexp);
805: 	if (connaddr) {
806: 		warning("duckdb_finalize_connection_R: Connection is garbage-collected, use dbDisconnect() to avoid this.");
807: 		R_ClearExternalPtr(connsexp);
808: 		delete connaddr;
809: 	}
810: 	return R_NilValue;
811: }
812: 
813: SEXP duckdb_register_R(SEXP connsexp, SEXP namesexp, SEXP valuesexp) {
814: 
815: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
816: 		Rf_error("duckdb_append_R: Need external pointer parameter for connection");
817: 	}
818: 
819: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
820: 	if (!conn) {
821: 		Rf_error("duckdb_append_R: Invalid connection");
822: 	}
823: 
824: 	if (TYPEOF(namesexp) != STRSXP || LENGTH(namesexp) != 1) {
825: 		Rf_error("duckdb_append_R: Need single string parameter for name");
826: 	}
827: 	auto name = string(CHAR(STRING_ELT(namesexp, 0)));
828: 
829: 	if (TYPEOF(valuesexp) != VECSXP || LENGTH(valuesexp) < 1 ||
830: 	    strcmp("data.frame", CHAR(STRING_ELT(GET_CLASS(valuesexp), 0))) != 0) {
831: 		Rf_error("duckdb_append_R: Need at least one-column data frame parameter for value");
832: 	}
833: 
834: 	auto key = install(("_registered_df_" + name).c_str());
835: 	setAttrib(connsexp, key, valuesexp);
836: 
837: 	// TODO put it into a conn attr that contains a named list to keep from gc!
838: 	std::ostringstream address;
839: 	address << (void const *)valuesexp;
840: 	string pointer_str = address.str();
841: 
842: 	// hack alert: put the pointer address into the function call as a string
843: 	auto res = conn->Query("CREATE OR REPLACE TEMPORARY VIEW \"" + name + "\" AS SELECT * FROM dataframe_scan('" +
844: 	                       pointer_str + "')");
845: 	if (!res->success) {
846: 		Rf_error(res->error.c_str());
847: 	}
848: 	return R_NilValue;
849: }
850: 
851: SEXP duckdb_unregister_R(SEXP connsexp, SEXP namesexp) {
852: 
853: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
854: 		Rf_error("duckdb_append_R: Need external pointer parameter for connection");
855: 	}
856: 
857: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
858: 	if (!conn) {
859: 		Rf_error("duckdb_append_R: Invalid connection");
860: 	}
861: 
862: 	if (TYPEOF(namesexp) != STRSXP || LENGTH(namesexp) != 1) {
863: 		Rf_error("duckdb_append_R: Need single string parameter for name");
864: 	}
865: 	auto name = string(CHAR(STRING_ELT(namesexp, 0)));
866: 
867: 	auto key = install(("_registered_df_" + name).c_str());
868: 	setAttrib(connsexp, key, R_NilValue);
869: 
870: 	auto res = conn->Query("DROP VIEW IF EXISTS \"" + name + "\"");
871: 	if (!res->success) {
872: 		Rf_error(res->error.c_str());
873: 	}
874: 
875: 	// TODO
876: 	return R_NilValue;
877: }
878: 
879: SEXP duckdb_connect_R(SEXP dbsexp) {
880: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
881: 		Rf_error("duckdb_connect_R: Need external pointer parameter");
882: 	}
883: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
884: 	if (!dbaddr) {
885: 		Rf_error("duckdb_connect_R: Invalid database reference");
886: 	}
887: 
888: 	SEXP connsexp = PROTECT(R_MakeExternalPtr(new Connection(*dbaddr), R_NilValue, R_NilValue));
889: 	R_RegisterCFinalizer(connsexp, (void (*)(SEXP))duckdb_finalize_connection_R);
890: 	UNPROTECT(1);
891: 
892: 	return connsexp;
893: }
894: 
895: SEXP duckdb_disconnect_R(SEXP connsexp) {
896: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
897: 		Rf_error("duckdb_disconnect_R: Need external pointer parameter");
898: 	}
899: 	Connection *connaddr = (Connection *)R_ExternalPtrAddr(connsexp);
900: 	if (connaddr) {
901: 		R_ClearExternalPtr(connsexp);
902: 		delete connaddr;
903: 	}
904: 	return R_NilValue;
905: }
906: 
907: SEXP duckdb_ptr_to_str(SEXP extptr) {
908: 	if (TYPEOF(extptr) != EXTPTRSXP) {
909: 		Rf_error("duckdb_ptr_to_str: Need external pointer parameter");
910: 	}
911: 	SEXP ret = PROTECT(NEW_STRING(1));
912: 	SET_STRING_ELT(ret, 0, NA_STRING);
913: 	void *ptr = R_ExternalPtrAddr(extptr);
914: 	if (ptr != NULL) {
915: 		char buf[100];
916: 		snprintf(buf, 100, "%p", ptr);
917: 		SET_STRING_ELT(ret, 0, mkChar(buf));
918: 	}
919: 	UNPROTECT(1);
920: 	return ret;
921: }
922: 
923: // R native routine registration
924: #define CALLDEF(name, n)                                                                                               \
925: 	{ #name, (DL_FUNC)&name, n }
926: static const R_CallMethodDef R_CallDef[] = {CALLDEF(duckdb_startup_R, 2),
927:                                             CALLDEF(duckdb_connect_R, 1),
928:                                             CALLDEF(duckdb_prepare_R, 2),
929:                                             CALLDEF(duckdb_bind_R, 2),
930:                                             CALLDEF(duckdb_execute_R, 1),
931:                                             CALLDEF(duckdb_release_R, 1),
932:                                             CALLDEF(duckdb_register_R, 3),
933:                                             CALLDEF(duckdb_unregister_R, 2),
934:                                             CALLDEF(duckdb_disconnect_R, 1),
935:                                             CALLDEF(duckdb_shutdown_R, 1),
936:                                             CALLDEF(duckdb_ptr_to_str, 1),
937: 
938:                                             {NULL, NULL, 0}};
939: 
940: void R_init_duckdb(DllInfo *dll) {
941: 	R_registerRoutines(dll, NULL, R_CallDef, NULL, NULL);
942: 	R_useDynamicSymbols(dll, FALSE);
943: }
944: }
[end of tools/rpkg/src/duckdbr.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: