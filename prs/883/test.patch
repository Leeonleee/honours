diff --git a/test/optimizer/index_scan.test b/test/optimizer/index_scan.test
deleted file mode 100644
index 3cc41b530bd3..000000000000
--- a/test/optimizer/index_scan.test
+++ /dev/null
@@ -1,25 +0,0 @@
-# name: test/optimizer/index_scan.test
-# description: Test Index Scan Optimizer for Integers
-# group: [optimizer]
-
-statement ok
-CREATE TABLE test(i INTEGER);
-
-statement ok
-PRAGMA explain_output='optimized';
-
-statement ok
-CREATE INDEX i_index ON test(i)
-
-query II
-EXPLAIN SELECT i FROM test where i > 10::INTEGER
-----
-logical_opt	<REGEX>:.*INDEX_SCAN.*
-
-statement ok
-DROP INDEX i_index
-
-query II
-EXPLAIN SELECT i FROM test where i > 10::INTEGER
-----
-logical_opt	<REGEX>:.*GET.*
diff --git a/test/sql/copy/csv/recursive_read_csv.test b/test/sql/copy/csv/recursive_read_csv.test
new file mode 100644
index 000000000000..459125fd748f
--- /dev/null
+++ b/test/sql/copy/csv/recursive_read_csv.test
@@ -0,0 +1,69 @@
+# name: test/sql/copy/csv/recursive_read_csv.test
+# description: Test read CSV function in a recursive CTE
+# group: [csv]
+
+statement ok
+PRAGMA enable_verification
+
+# first create a table from read csv, and use that in a recursive te
+statement ok
+create table r AS SELECT * FROM read_csv('test/sql/copy/csv/data/test/date.csv', columns=STRUCT_PACK(d := 'DATE'), header=0, auto_detect=0);
+
+query II
+WITH RECURSIVE t(i) AS
+(
+	SELECT 1, NULL::DATE
+	UNION ALL
+	(
+		SELECT i+1, d
+		FROM t, r
+		WHERE i<5
+	)
+)
+SELECT * FROM t ORDER BY i;
+----
+1	NULL
+2	2019-06-05
+3	2019-06-05
+4	2019-06-05
+5	2019-06-05
+
+# directly calling the function should be equivalent
+query II
+WITH RECURSIVE t(i) AS
+(
+	SELECT 1, NULL::DATE
+	UNION ALL
+	(
+		SELECT i+1, d
+		FROM t, read_csv('test/sql/copy/csv/data/test/date.csv', columns=STRUCT_PACK(d := 'DATE'), header=0, auto_detect=0)
+		WHERE i<5
+	)
+)
+SELECT * FROM t ORDER BY i;
+----
+1	NULL
+2	2019-06-05
+3	2019-06-05
+4	2019-06-05
+5	2019-06-05
+
+# should also work if we use auto detect
+query II
+WITH RECURSIVE t(i) AS
+(
+	SELECT 1, NULL::DATE
+	UNION ALL
+	(
+		SELECT i+1, d
+		FROM t, read_csv('test/sql/copy/csv/data/test/date.csv', header=0, auto_detect=1) r(d)
+		WHERE i<5
+	)
+)
+SELECT * FROM t ORDER BY i;
+----
+1	NULL
+2	2019-06-05
+3	2019-06-05
+4	2019-06-05
+5	2019-06-05
diff --git a/test/sql/cte/game_of_life.test_slow b/test/sql/cte/game_of_life.test_slow
index 98142e6014cb..bb561b2238fa 100644
--- a/test/sql/cte/game_of_life.test_slow
+++ b/test/sql/cte/game_of_life.test_slow
@@ -1,9 +1,9 @@
-# name: test/sql/cte/game_of_life.test
+# name: test/sql/cte/game_of_life.test_slow
 # description: Run conways game of life as a CTE (https://gist.github.com/janickr/58fab629ee3ea7e5638a)
 # group: [cte]
 
 statement ok
-create table series as select * from range(-1,1+1) x(n);
+create table series as select * from generate_series(-1,1) x(n);
 
 # conway
 query III
@@ -35,9 +35,6 @@ select * from game where n=4 order by n, x, y; --select generation 4
 4	3	3
 4	3	4
 
-mode skip
-
-# FIXME: table functions keep state in function data -> this should be fixed, as it causes problems with recursive CTEs
 query III
 with recursive generation1(x,y) as (   --the initial board setup
   select 2, 3
@@ -54,7 +51,7 @@ game(n, x, y) as (
     select n, x+offset_x new_x, y+offset_y new_y, max(self) over (partition by n+1, x+offset_x, y+offset_y) cell_was_already_alive
     from game, (
         select x.n offset_x, y.n offset_y, case when x.n = 0 and y.n = 0 then 1 else 0 end self
-        from range(-1,2) x(n), range(-1,2) y(n) --join 2 row generators to get 9 pairs
+        from generate_series(-1,1) x(n), generate_series(-1,1) y(n) --join 2 row generators to get 9 pairs
       ) offsets_to_neighbours_and_self(offset_x, offset_y, self)
     where n < 100
   ) all_impacts
diff --git a/test/sql/cte/test_recursive_cte_union_all.test b/test/sql/cte/test_recursive_cte_union_all.test
index ed5cb9831c4a..fdd8e34d23b9 100644
--- a/test/sql/cte/test_recursive_cte_union_all.test
+++ b/test/sql/cte/test_recursive_cte_union_all.test
@@ -87,6 +87,28 @@ NULL
 NULL
 NULL
 
+# recursive CTE with table-producing function
+query I
+WITH RECURSIVE t AS (
+	SELECT 1 AS i
+	UNION ALL
+	SELECT j
+	FROM t, generate_series(0, 10, 1) series(j)
+	WHERE j=i+1
+)
+SELECT * FROM t;
+----
+1
+2
+3
+4
+5
+6
+7
+8
+9
+10
+
 # order by is not allowed in the recursive term of ctes
 statement error
 with recursive t as (select 1 as x union all select x+1 from t where x < 3 order by x) select * from t
diff --git a/test/sql/pragma/test_pragma_database_list.test b/test/sql/pragma/test_pragma_database_list.test
index 6785dff607b2..4e85bfcf0b51 100644
--- a/test/sql/pragma/test_pragma_database_list.test
+++ b/test/sql/pragma/test_pragma_database_list.test
@@ -15,11 +15,10 @@ SELECT * FROM pragma_database_list()
 statement error
 PRAGMA database_list()
 
-# FIXME: need to merge changes from hugeint branch
-# # load a database file
-# load __TEST_DIR__/test.db
+# load a database file
+load __TEST_DIR__/test.db
 
-# query III
-# SELECT * FROM pragma_database_list()
-# ----
-# 0	main	(empty)
+query II
+SELECT seq, name FROM pragma_database_list() WHERE file LIKE '%test.db%'
+----
+0	main
diff --git a/test/sql/table_function/sqlite_master.test b/test/sql/table_function/sqlite_master.test
new file mode 100644
index 000000000000..2f8b881d948a
--- /dev/null
+++ b/test/sql/table_function/sqlite_master.test
@@ -0,0 +1,32 @@
+# name: test/sql/table_function/sqlite_master.test
+# description: Test sqlite_master function
+# group: [table_function]
+
+statement ok
+CREATE TABLE integers(i INTEGER);
+
+query IIIII
+SELECT * FROM sqlite_master();
+----
+table	integers	integers	0	CREATE TABLE integers(i INTEGER);
+
+query I
+SELECT EXISTS(SELECT * FROM sqlite_master())
+----
+1
+
+query I
+SELECT EXISTS(SELECT * FROM sqlite_master() OFFSET 1)
+----
+0
+
+
+query I
+SELECT COUNT(*) FROM sqlite_master() WHERE name='test'
+----
+0
+
+query I
+SELECT COUNT(*) FROM sqlite_master() WHERE name='integers'
+----
+1
\ No newline at end of file
diff --git a/test/sql/table_function/test_range_function.test b/test/sql/table_function/test_range_function.test
index e41dbb60362d..4989576d4b5d 100644
--- a/test/sql/table_function/test_range_function.test
+++ b/test/sql/table_function/test_range_function.test
@@ -16,7 +16,7 @@ SELECT * FROM range(0, 10, 1)
 8
 9
 
-# generate_series is an alias for range for postgres compatibility
+# generate_series is similar to range, but has inclusive bounds (for postgres compatibility)
 query I
 SELECT * FROM generate_series(0, 10, 1)
 ----
@@ -30,6 +30,7 @@ SELECT * FROM generate_series(0, 10, 1)
 7
 8
 9
+10
 
 query I
 SELECT * FROM range(10, 0, -1) ORDER BY 1 ASC
@@ -45,6 +46,21 @@ SELECT * FROM range(10, 0, -1) ORDER BY 1 ASC
 9
 10
 
+query I
+SELECT * FROM generate_series(10, 0, -1) ORDER BY 1 ASC
+----
+0
+1
+2
+3
+4
+5
+6
+7
+8
+9
+10
+
 query I
 SELECT * FROM range(0, -5, -1)
 ----
@@ -94,6 +110,21 @@ SELECT * FROM range(0, 10)
 8
 9
 
+query I
+SELECT EXISTS(SELECT * FROM range(10))
+----
+1
+
+query I
+SELECT EXISTS(SELECT * FROM range(0))
+----
+0
+
+query I
+SELECT * FROM range(10) t1(j) WHERE j=3
+----
+3
+
 statement error
 SELECT * FROM range('hello')
 
diff --git a/test/sqlite/test_sqllogictest.cpp b/test/sqlite/test_sqllogictest.cpp
index eb2e574a93f7..a10d7fd515ab 100644
--- a/test/sqlite/test_sqllogictest.cpp
+++ b/test/sqlite/test_sqllogictest.cpp
@@ -516,6 +516,12 @@ struct Command {
 		}
 	}
 
+	unique_ptr<MaterializedQueryResult> ExecuteQuery(Connection *connection, string file_name, int query_line,
+	                                                 string sql_query) {
+		query_break(query_line);
+		return connection->Query(sql_query);
+	}
+
 	virtual void Execute() = 0;
 	void ExecuteLoop() {
 		// store the original query
@@ -575,7 +581,7 @@ void Statement::Execute() {
 	}
 
 	query_break(query_line);
-	auto result = connection->Query(sql_query);
+	auto result = ExecuteQuery(connection, file_name, query_line, sql_query);
 	bool error = !result->success;
 
 	if (runner.output_result_mode || runner.debug_mode) {
@@ -597,7 +603,7 @@ void Statement::Execute() {
 		if (result) {
 			result->Print();
 		}
-		FAIL();
+		FAIL_LINE(file_name, query_line);
 	}
 	REQUIRE(!error);
 }
@@ -610,7 +616,7 @@ void Query::ColumnCountMismatch(MaterializedQueryResult &result, int expected_co
 	print_sql(sql_query);
 	print_line_sep();
 	print_result_error(result, values, expected_column_count, row_wise);
-	FAIL();
+	FAIL_LINE(file_name, query_line);
 }
 
 vector<string> Query::LoadResultFromFile(string fname, vector<string> names) {
@@ -632,7 +638,7 @@ vector<string> Query::LoadResultFromFile(string fname, vector<string> names) {
 	if (!csv_result->success) {
 		string error = StringUtil::Format("Could not read CSV File \"%s\": %s", fname, csv_result->error);
 		print_error_header(error.c_str(), file_name.c_str(), query_line);
-		FAIL();
+		FAIL_LINE(file_name, query_line);
 	}
 	expected_column_count = csv_result->column_count();
 
@@ -661,8 +667,7 @@ void Query::Execute() {
 		print_line_sep();
 	}
 
-	query_break(query_line);
-	auto result = connection->Query(sql_query);
+	auto result = ExecuteQuery(connection, file_name, query_line, sql_query);
 	if (!result->success) {
 		print_line_sep();
 		fprintf(stderr, "Query unexpectedly failed (%s:%d)
", file_name.c_str(), query_line);
@@ -671,7 +676,7 @@ void Query::Execute() {
 		print_line_sep();
 		print_header("Actual result:");
 		result->Print();
-		FAIL();
+		FAIL_LINE(file_name, query_line);
 	}
 	vector<string> azResult;
 	int nResult;
@@ -817,7 +822,7 @@ void Query::Execute() {
 			fprintf(stderr, "Expected %d columns, but %d values were supplied
", (int)expected_column_count,
 			        (int)comparison_values.size());
 			fprintf(stderr, "This is not cleanly divisible (i.e. the last row does not have enough values)
");
-			FAIL();
+			FAIL_LINE(file_name, query_line);
 		}
 		if (expected_rows != result->collection.count) {
 			if (column_count_mismatch) {
@@ -830,7 +835,7 @@ void Query::Execute() {
 			print_sql(sql_query);
 			print_line_sep();
 			print_result_error(*result, comparison_values, expected_column_count, row_wise);
-			FAIL();
+			FAIL_LINE(file_name, query_line);
 		}
 
 		if (row_wise) {
@@ -853,14 +858,14 @@ void Query::Execute() {
 					print_line_sep();
 					print_sql(sql_query);
 					print_line_sep();
-					FAIL();
+					FAIL_LINE(file_name, query_line);
 				}
 				for (idx_t c = 0; c < splits.size(); c++) {
 					bool success = compare_values(*result, azResult[current_row * expected_column_count + c], splits[c],
 					                              file_name, query_line, sql_query, current_row, c, comparison_values,
 					                              expected_column_count, row_wise);
 					if (!success) {
-						FAIL();
+						FAIL_LINE(file_name, query_line);
 					}
 					// we do this just to increment the assertion counter
 					REQUIRE(success);
@@ -874,7 +879,7 @@ void Query::Execute() {
 				                              comparison_values[i], file_name, query_line, sql_query, current_row,
 				                              current_column, comparison_values, expected_column_count, row_wise);
 				if (!success) {
-					FAIL();
+					FAIL_LINE(file_name, query_line);
 				}
 				// we do this just to increment the assertion counter
 				REQUIRE(success);
@@ -901,7 +906,7 @@ void Query::Execute() {
 			          << string(result->column_count(), 'I') << termcolor::reset << termcolor::bold << "\""
 			          << termcolor::reset << std::endl;
 			print_line_sep();
-			FAIL();
+			FAIL_LINE(file_name, query_line);
 		}
 	} else {
 		bool hash_compare_error = false;
@@ -919,7 +924,7 @@ void Query::Execute() {
 			if (values.size() <= 0) {
 				print_error_header("Error in test: attempting to compare hash but no hash found!", file_name,
 				                   query_line);
-				FAIL();
+				FAIL_LINE(file_name, query_line);
 			}
 			hash_compare_error = strcmp(values[0].c_str(), zHash) != 0;
 		}
@@ -934,7 +939,7 @@ void Query::Execute() {
 			print_header("Actual result:");
 			print_line_sep();
 			result->Print();
-			FAIL();
+			FAIL_LINE(file_name, query_line);
 		}
 		REQUIRE(!hash_compare_error);
 	}
