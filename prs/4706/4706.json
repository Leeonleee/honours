{
  "repo": "duckdb/duckdb",
  "pull_number": 4706,
  "instance_id": "duckdb__duckdb-4706",
  "issue_numbers": [
    "4677"
  ],
  "base_commit": "a5b74ff1cdd60c1a64c6a5ba41e57a2dc20336c0",
  "patch": "diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp\nindex f9e19aad4277..dd2afe11fc05 100644\n--- a/src/catalog/catalog_entry/table_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp\n@@ -480,6 +480,9 @@ unique_ptr<CatalogEntry> TableCatalogEntry::SetNotNull(ClientContext &context, S\n \t}\n \n \tidx_t not_null_idx = GetColumnIndex(info.column_name);\n+\tif (columns[not_null_idx].Generated()) {\n+\t\tthrow BinderException(\"Unsupported constraint for generated column!\");\n+\t}\n \tbool has_not_null = false;\n \tfor (idx_t i = 0; i < constraints.size(); i++) {\n \t\tauto constraint = constraints[i]->Copy();\n@@ -503,8 +506,9 @@ unique_ptr<CatalogEntry> TableCatalogEntry::SetNotNull(ClientContext &context, S\n \t\t                                      storage);\n \t}\n \n-\t// Return with new storage info\n-\tauto new_storage = make_shared<DataTable>(context, *storage, make_unique<NotNullConstraint>(not_null_idx));\n+\t// Return with new storage info. Note that we need the bound column index here.\n+\tauto new_storage = make_shared<DataTable>(context, *storage,\n+\t                                          make_unique<BoundNotNullConstraint>(columns[not_null_idx].StorageOid()));\n \treturn make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(),\n \t                                      new_storage);\n }\ndiff --git a/src/include/duckdb/storage/data_table.hpp b/src/include/duckdb/storage/data_table.hpp\nindex 58b78f71b5cc..6203aa42cee6 100644\n--- a/src/include/duckdb/storage/data_table.hpp\n+++ b/src/include/duckdb/storage/data_table.hpp\n@@ -78,7 +78,7 @@ class DataTable {\n \tDataTable(ClientContext &context, DataTable &parent, idx_t changed_idx, const LogicalType &target_type,\n \t          vector<column_t> bound_columns, Expression &cast_expr);\n \t//! Constructs a DataTable as a delta on an existing data table but with one column added new constraint\n-\tDataTable(ClientContext &context, DataTable &parent, unique_ptr<Constraint> constraint);\n+\tDataTable(ClientContext &context, DataTable &parent, unique_ptr<BoundConstraint> constraint);\n \n \tshared_ptr<DataTableInfo> info;\n \n@@ -181,7 +181,7 @@ class DataTable {\n \n private:\n \t//! Verify the new added constraints against current persistent&local data\n-\tvoid VerifyNewConstraint(ClientContext &context, DataTable &parent, const Constraint *constraint);\n+\tvoid VerifyNewConstraint(ClientContext &context, DataTable &parent, const BoundConstraint *constraint);\n \t//! Verify constraints with a chunk from the Append containing all columns of the table\n \tvoid VerifyAppendConstraints(TableCatalogEntry &table, ClientContext &context, DataChunk &chunk);\n \t//! Verify constraints with a chunk from the Update containing only the specified column_ids\ndiff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp\nindex 22af9e6c8433..15c91e546019 100644\n--- a/src/storage/data_table.cpp\n+++ b/src/storage/data_table.cpp\n@@ -171,7 +171,7 @@ DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t removed_co\n }\n \n // Alter column to add new constraint\n-DataTable::DataTable(ClientContext &context, DataTable &parent, unique_ptr<Constraint> constraint)\n+DataTable::DataTable(ClientContext &context, DataTable &parent, unique_ptr<BoundConstraint> constraint)\n     : info(parent.info), db(parent.db), total_rows(parent.total_rows.load()), row_groups(parent.row_groups),\n       is_root(true) {\n \n@@ -625,14 +625,15 @@ static void VerifyDeleteForeignKeyConstraint(const BoundForeignKeyConstraint &bf\n \tVerifyForeignKeyConstraint(bfk, context, chunk, false);\n }\n \n-void DataTable::VerifyNewConstraint(ClientContext &context, DataTable &parent, const Constraint *constraint) {\n+void DataTable::VerifyNewConstraint(ClientContext &context, DataTable &parent, const BoundConstraint *constraint) {\n \tif (constraint->type != ConstraintType::NOT_NULL) {\n \t\tthrow NotImplementedException(\"FIXME: ALTER COLUMN with such constraint is not supported yet\");\n \t}\n \t// scan the original table, check if there's any null value\n-\tauto &not_null_constraint = (NotNullConstraint &)*constraint;\n+\tauto &not_null_constraint = (BoundNotNullConstraint &)*constraint;\n \tauto &transaction = Transaction::GetTransaction(context);\n \tvector<LogicalType> scan_types;\n+\tD_ASSERT(not_null_constraint.index < parent.column_definitions.size());\n \tscan_types.push_back(parent.column_definitions[not_null_constraint.index].Type());\n \tDataChunk scan_chunk;\n \tauto &allocator = Allocator::Get(context);\n",
  "test_patch": "diff --git a/test/fuzzer/pedro/alter_column_generated.test b/test/fuzzer/pedro/alter_column_generated.test\nnew file mode 100644\nindex 000000000000..cb8d7637317e\n--- /dev/null\n+++ b/test/fuzzer/pedro/alter_column_generated.test\n@@ -0,0 +1,34 @@\n+# name: test/fuzzer/pedro/alter_column_generated.test\n+# description: Issue #4677: heap-buffer-overflow on ALTER statement\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t0(c0 AS (1), c1 INT);\n+\n+statement ok\n+ALTER TABLE t0 ALTER c1 SET NOT NULL;\n+\n+statement ok\n+ALTER TABLE t0 ALTER c1 SET NOT NULL;\n+\n+statement error\n+ALTER TABLE t0 ALTER c0 SET NOT NULL;\n+\n+statement error\n+INSERT INTO t0 VALUES (NULL);\n+\n+statement ok\n+DROP TABLE t0;\n+\n+statement ok\n+CREATE TABLE t0(c0 AS (1), c1 INT);\n+\n+statement ok\n+INSERT INTO t0 VALUES (NULL);\n+\n+statement error\n+ALTER TABLE t0 ALTER c1 SET NOT NULL;\n+\ndiff --git a/test/sql/alter/alter_col/test_drop_not_null.test b/test/sql/alter/alter_col/test_drop_not_null.test\nindex 6bf0c4258bf3..61ea8364c14b 100644\n--- a/test/sql/alter/alter_col/test_drop_not_null.test\n+++ b/test/sql/alter/alter_col/test_drop_not_null.test\n@@ -49,3 +49,38 @@ ALTER TABLE test2 ALTER COLUMN j DROP NOT NULL\n statement ok \n INSERT INTO test VALUES (3, NULL)\n \n+# Drop not null with generated column presented\n+statement ok\n+DROP TABLE IF EXISTS test\n+\n+statement ok\n+CREATE TABLE test(i AS (1), j INTEGER NOT NULL)\n+\n+statement ok\n+INSERT INTO test VALUES (1), (2)\n+\n+statement error\n+INSERT INTO test VALUES (NULL)\n+\n+query II\n+SELECT * FROM test\n+----\n+1\t1\n+1\t2\n+\n+statement ok\n+ALTER TABLE test ALTER COLUMN i DROP NOT NULL\n+\n+statement ok\n+ALTER TABLE test ALTER COLUMN j DROP NOT NULL\n+\n+statement ok\n+INSERT INTO test VALUES (NULL)\n+\n+query II\n+SELECT * FROM test\n+----\n+1\t1\n+1\t2\n+1\tNULL\n+\ndiff --git a/test/sql/alter/alter_col/test_set_not_null.test b/test/sql/alter/alter_col/test_set_not_null.test\nindex 09c6e8567bf1..5a44343ae91a 100644\n--- a/test/sql/alter/alter_col/test_set_not_null.test\n+++ b/test/sql/alter/alter_col/test_set_not_null.test\n@@ -103,3 +103,46 @@ SELECT * FROM t WHERE j IS NULL\n ----\n 3\tNULL\n \n+# Basic test with generated column\n+statement ok\n+CREATE TABLE t0(c0 AS (1), c1 INT);\n+\n+statement ok\n+ALTER TABLE t0 ALTER c1 SET NOT NULL;\n+\n+# Insert null before&after drop constraint with generated column\n+statement ok\n+DROP TABLE IF EXISTS t\n+\n+statement ok\n+CREATE TABLE t(i AS (1), j INTEGER)\n+\n+statement ok\n+INSERT INTO t SELECT 1 FROM RANGE(65536)\n+\n+# Set not null\n+statement error\n+ALTER TABLE t ALTER COLUMN i SET NOT NULL\n+\n+# Set not null\n+statement ok\n+ALTER TABLE t ALTER COLUMN j SET NOT NULL\n+\n+# Failed to insert before drop constraint\n+statement error\n+INSERT INTO t VALUES (null)\n+\n+# Drop not null\n+statement ok\n+ALTER TABLE t ALTER COLUMN j DROP NOT NULL\n+\n+# Insert after drop constraint\n+statement ok\n+INSERT INTO t VALUES (null)\n+\n+# Only 1 null\n+query II\n+SELECT * FROM t WHERE j IS NULL\n+----\n+1\tNULL\n+\n",
  "problem_statement": "[Fuzzer] heap-buffer-overflow on ALTER statement\n### What happens?\n\nRun the following statements:\r\n```\r\nCREATE TABLE t0(c0 AS (1), c1 INT);\r\nALTER TABLE t0 ALTER c1 SET NOT NULL;\r\n```\r\nThe address sanitizer will report a heap-buffer-overflow.\r\n\r\nThe alter statement should succeed.\n\n### To Reproduce\n\nRun the statement above.\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\nlatest from sources\n\n### DuckDB Client:\n\nShell\n\n### Full Name:\n\nPedro Ferreira\n\n### Affiliation:\n\nHuawei\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2022-09-14T07:23:51Z"
}