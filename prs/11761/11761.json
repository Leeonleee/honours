{
  "repo": "duckdb/duckdb",
  "pull_number": 11761,
  "instance_id": "duckdb__duckdb-11761",
  "issue_numbers": [
    "11387"
  ],
  "base_commit": "8f16471dcb114bf112f436023e771dfd04619cd3",
  "patch": "diff --git a/.github/config/out_of_tree_extensions.cmake b/.github/config/out_of_tree_extensions.cmake\nindex f3cdf1d53bbb..338ab582ea1b 100644\n--- a/.github/config/out_of_tree_extensions.cmake\n+++ b/.github/config/out_of_tree_extensions.cmake\n@@ -79,6 +79,7 @@ duckdb_extension_load(spatial\n     GIT_URL https://github.com/duckdb/duckdb_spatial.git\n     GIT_TAG 8ac803e986ccda34f32dee82a7faae95b72b3492\n     INCLUDE_DIR spatial/include\n+    APPLY_PATCHES\n     TEST_DIR test/sql\n     )\n \ndiff --git a/.github/patches/extensions/spatial/replacement_scan.patch b/.github/patches/extensions/spatial/replacement_scan.patch\nnew file mode 100644\nindex 000000000000..e3637d355a40\n--- /dev/null\n+++ b/.github/patches/extensions/spatial/replacement_scan.patch\n@@ -0,0 +1,87 @@\n+diff --git a/duckdb b/duckdb\n+index 6598220..3c695d7 160000\n+--- a/duckdb\n++++ b/duckdb\n+@@ -1 +1 @@\n+-Subproject commit 6598220b953b0be8a612ea1a9d5c1bd85c5379c8\n++Subproject commit 3c695d7ba94d95d9facee48d395f46ed0bd72b46\n+diff --git a/spatial/include/spatial/gdal/functions.hpp b/spatial/include/spatial/gdal/functions.hpp\n+index 9bf2945..0a4bb2a 100644\n+--- a/spatial/include/spatial/gdal/functions.hpp\n++++ b/spatial/include/spatial/gdal/functions.hpp\n+@@ -3,6 +3,7 @@\n+ #include \"duckdb/function/table/arrow.hpp\"\n+ #include \"duckdb/parser/parsed_data/copy_info.hpp\"\n+ #include \"duckdb/function/copy_function.hpp\"\n++#include \"duckdb/function/replacement_scan.hpp\"\n+ \n+ #include \"spatial/common.hpp\"\n+ \n+@@ -26,8 +27,8 @@ private:\n+ \n+ \tstatic unique_ptr<NodeStatistics> Cardinality(ClientContext &context, const FunctionData *data);\n+ \n+-\tstatic unique_ptr<TableRef> ReplacementScan(ClientContext &context, const string &table_name,\n+-\t                                            ReplacementScanData *data);\n++\tstatic unique_ptr<TableRef> ReplacementScan(ClientContext &context, ReplacementScanInput &input,\n++\t                                            optional_ptr<ReplacementScanData> data);\n+ \n+ public:\n+ \tstatic void Register(DatabaseInstance &db);\n+diff --git a/spatial/src/spatial/core/io/osm/st_read_osm.cpp b/spatial/src/spatial/core/io/osm/st_read_osm.cpp\n+index 11055c9..72b3b71 100644\n+--- a/spatial/src/spatial/core/io/osm/st_read_osm.cpp\n++++ b/spatial/src/spatial/core/io/osm/st_read_osm.cpp\n+@@ -839,8 +839,9 @@ static idx_t GetBatchIndex(ClientContext &context, const FunctionData *bind_data\n+ \treturn state.block->block_idx;\n+ }\n+ \n+-static unique_ptr<TableRef> ReadOsmPBFReplacementScan(ClientContext &context, const string &table_name,\n+-                                                      ReplacementScanData *data) {\n++static unique_ptr<TableRef> ReadOsmPBFReplacementScan(ClientContext &context, ReplacementScanInput &input,\n++                                                      optional_ptr<ReplacementScanData> data) {\n++\tauto &table_name = input.table_name;\n+ \t// Check if the table name ends with .osm.pbf\n+ \tif (!StringUtil::EndsWith(StringUtil::Lower(table_name), \".osm.pbf\")) {\n+ \t\treturn nullptr;\n+diff --git a/spatial/src/spatial/core/io/shapefile/read_shapefile.cpp b/spatial/src/spatial/core/io/shapefile/read_shapefile.cpp\n+index fcc182e..1e7b5f7 100644\n+--- a/spatial/src/spatial/core/io/shapefile/read_shapefile.cpp\n++++ b/spatial/src/spatial/core/io/shapefile/read_shapefile.cpp\n+@@ -540,8 +540,9 @@ static unique_ptr<NodeStatistics> GetCardinality(ClientContext &context, const F\n+ \treturn result;\n+ }\n+ \n+-static unique_ptr<TableRef> GetReplacementScan(ClientContext &context, const string &table_name,\n+-                                               ReplacementScanData *data) {\n++static unique_ptr<TableRef> GetReplacementScan(ClientContext &context, ReplacementScanInput &input,\n++                                               optional_ptr<ReplacementScanData> data) {\n++\tauto &table_name = input.table_name;\n+ \t// Check if the table name ends with .shp\n+ \tif (!StringUtil::EndsWith(StringUtil::Lower(table_name), \".shp\")) {\n+ \t\treturn nullptr;\n+diff --git a/spatial/src/spatial/gdal/functions/st_read.cpp b/spatial/src/spatial/gdal/functions/st_read.cpp\n+index 9edf968..793a4df 100644\n+--- a/spatial/src/spatial/gdal/functions/st_read.cpp\n++++ b/spatial/src/spatial/gdal/functions/st_read.cpp\n+@@ -5,6 +5,7 @@\n+ #include \"duckdb/planner/filter/conjunction_filter.hpp\"\n+ #include \"duckdb/planner/filter/constant_filter.hpp\"\n+ #include \"duckdb/planner/table_filter.hpp\"\n++#include \"duckdb/parser/tableref.hpp\"\n+ #include \"duckdb/function/function.hpp\"\n+ #include \"duckdb/function/replacement_scan.hpp\"\n+ \n+@@ -592,9 +593,9 @@ unique_ptr<NodeStatistics> GdalTableFunction::Cardinality(ClientContext &context\n+ \treturn result;\n+ }\n+ \n+-unique_ptr<TableRef> GdalTableFunction::ReplacementScan(ClientContext &, const string &table_name,\n+-                                                        ReplacementScanData *) {\n+-\n++unique_ptr<TableRef> GdalTableFunction::ReplacementScan(ClientContext &, ReplacementScanInput &input,\n++                                                        optional_ptr<ReplacementScanData>) {\n++\tauto &table_name = input.table_name;\n+ \tauto lower_name = StringUtil::Lower(table_name);\n+ \t// Check if the table name ends with some common geospatial file extensions\n+ \tif (StringUtil::EndsWith(lower_name, \".gpkg\") || StringUtil::EndsWith(lower_name, \".fgb\")) {\ndiff --git a/extension/json/include/json_functions.hpp b/extension/json/include/json_functions.hpp\nindex 4f7f26b272c0..51fae296b58a 100644\n--- a/extension/json/include/json_functions.hpp\n+++ b/extension/json/include/json_functions.hpp\n@@ -70,8 +70,8 @@ class JSONFunctions {\n \tstatic vector<ScalarFunctionSet> GetScalarFunctions();\n \tstatic vector<PragmaFunctionSet> GetPragmaFunctions();\n \tstatic vector<TableFunctionSet> GetTableFunctions();\n-\tstatic unique_ptr<TableRef> ReadJSONReplacement(ClientContext &context, const string &table_name,\n-\t                                                ReplacementScanData *data);\n+\tstatic unique_ptr<TableRef> ReadJSONReplacement(ClientContext &context, ReplacementScanInput &input,\n+\t                                                optional_ptr<ReplacementScanData> data);\n \tstatic TableFunction GetReadJSONTableFunction(shared_ptr<JSONScanInfo> function_info);\n \tstatic CopyFunction GetJSONCopyFunction();\n \tstatic void RegisterSimpleCastFunctions(CastFunctionSet &casts);\ndiff --git a/extension/json/json_functions.cpp b/extension/json/json_functions.cpp\nindex e8241d6e35fe..8d0dedbb6da1 100644\n--- a/extension/json/json_functions.cpp\n+++ b/extension/json/json_functions.cpp\n@@ -194,8 +194,9 @@ vector<TableFunctionSet> JSONFunctions::GetTableFunctions() {\n \treturn functions;\n }\n \n-unique_ptr<TableRef> JSONFunctions::ReadJSONReplacement(ClientContext &context, const string &table_name,\n-                                                        ReplacementScanData *data) {\n+unique_ptr<TableRef> JSONFunctions::ReadJSONReplacement(ClientContext &context, ReplacementScanInput &input,\n+                                                        optional_ptr<ReplacementScanData> data) {\n+\tauto &table_name = input.table_name;\n \tif (!ReplacementScan::CanReplace(table_name, {\"json\", \"jsonl\", \"ndjson\"})) {\n \t\treturn nullptr;\n \t}\ndiff --git a/extension/parquet/parquet_extension.cpp b/extension/parquet/parquet_extension.cpp\nindex ab7184bd8158..7d69a2de52a6 100644\n--- a/extension/parquet/parquet_extension.cpp\n+++ b/extension/parquet/parquet_extension.cpp\n@@ -1340,8 +1340,9 @@ idx_t ParquetWriteFileSize(GlobalFunctionData &gstate) {\n //===--------------------------------------------------------------------===//\n // Scan Replacement\n //===--------------------------------------------------------------------===//\n-unique_ptr<TableRef> ParquetScanReplacement(ClientContext &context, const string &table_name,\n-                                            ReplacementScanData *data) {\n+unique_ptr<TableRef> ParquetScanReplacement(ClientContext &context, ReplacementScanInput &input,\n+                                            optional_ptr<ReplacementScanData> data) {\n+\tauto &table_name = input.table_name;\n \tif (!ReplacementScan::CanReplace(table_name, {\"parquet\"})) {\n \t\treturn nullptr;\n \t}\ndiff --git a/src/common/enum_util.cpp b/src/common/enum_util.cpp\nindex 3d486640c9b8..7ac2070fe384 100644\n--- a/src/common/enum_util.cpp\n+++ b/src/common/enum_util.cpp\n@@ -90,7 +90,6 @@\n #include \"duckdb/main/config.hpp\"\n #include \"duckdb/main/error_manager.hpp\"\n #include \"duckdb/main/extension_helper.hpp\"\n-#include \"duckdb/main/external_dependencies.hpp\"\n #include \"duckdb/main/query_result.hpp\"\n #include \"duckdb/main/secret/secret.hpp\"\n #include \"duckdb/main/settings.hpp\"\n@@ -2554,24 +2553,6 @@ ExtensionLoadResult EnumUtil::FromString<ExtensionLoadResult>(const char *value)\n \tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%s' not implemented\", value));\n }\n \n-template<>\n-const char* EnumUtil::ToChars<ExternalDependenciesType>(ExternalDependenciesType value) {\n-\tswitch(value) {\n-\tcase ExternalDependenciesType::PYTHON_DEPENDENCY:\n-\t\treturn \"PYTHON_DEPENDENCY\";\n-\tdefault:\n-\t\tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%d' not implemented\", value));\n-\t}\n-}\n-\n-template<>\n-ExternalDependenciesType EnumUtil::FromString<ExternalDependenciesType>(const char *value) {\n-\tif (StringUtil::Equals(value, \"PYTHON_DEPENDENCY\")) {\n-\t\treturn ExternalDependenciesType::PYTHON_DEPENDENCY;\n-\t}\n-\tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%s' not implemented\", value));\n-}\n-\n template<>\n const char* EnumUtil::ToChars<ExtraDropInfoType>(ExtraDropInfoType value) {\n \tswitch(value) {\ndiff --git a/src/function/table/arrow.cpp b/src/function/table/arrow.cpp\nindex f7fe3c481446..5060a196cb69 100644\n--- a/src/function/table/arrow.cpp\n+++ b/src/function/table/arrow.cpp\n@@ -10,6 +10,7 @@\n #include \"duckdb/function/table_function.hpp\"\n #include \"duckdb/parser/parsed_data/create_table_function_info.hpp\"\n #include \"duckdb/function/table/arrow/arrow_duck_schema.hpp\"\n+#include \"duckdb/parser/tableref/table_function_ref.hpp\"\n #include \"utf8proc_wrapper.hpp\"\n \n namespace duckdb {\n@@ -257,12 +258,21 @@ unique_ptr<FunctionData> ArrowTableFunction::ArrowScanBind(ClientContext &contex\n \tif (input.inputs[0].IsNull() || input.inputs[1].IsNull() || input.inputs[2].IsNull()) {\n \t\tthrow BinderException(\"arrow_scan: pointers cannot be null\");\n \t}\n+\tauto &ref = input.ref;\n+\n+\tshared_ptr<DependencyItem> dependency;\n+\tif (ref.external_dependency) {\n+\t\t// This was created during the replacement scan for Python (see python_replacement_scan.cpp)\n+\t\t// this object is the owning reference to 'stream_factory_ptr' and has to be kept alive.\n+\t\tdependency = ref.external_dependency->GetDependency(\"replacement_cache\");\n+\t\tD_ASSERT(dependency);\n+\t}\n \n \tauto stream_factory_ptr = input.inputs[0].GetPointer();\n \tauto stream_factory_produce = (stream_factory_produce_t)input.inputs[1].GetPointer();       // NOLINT\n \tauto stream_factory_get_schema = (stream_factory_get_schema_t)input.inputs[2].GetPointer(); // NOLINT\n \n-\tauto res = make_uniq<ArrowScanFunctionData>(stream_factory_produce, stream_factory_ptr);\n+\tauto res = make_uniq<ArrowScanFunctionData>(stream_factory_produce, stream_factory_ptr, std::move(dependency));\n \n \tauto &data = *res;\n \tstream_factory_get_schema(reinterpret_cast<ArrowArrayStream *>(stream_factory_ptr), data.schema_root.arrow_schema);\ndiff --git a/src/function/table/read_csv.cpp b/src/function/table/read_csv.cpp\nindex 0db63252e736..5f2d4f6f5fcb 100644\n--- a/src/function/table/read_csv.cpp\n+++ b/src/function/table/read_csv.cpp\n@@ -373,7 +373,9 @@ void ReadCSVTableFunction::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(MultiFileReader::CreateFunctionSet(ReadCSVTableFunction::GetAutoFunction()));\n }\n \n-unique_ptr<TableRef> ReadCSVReplacement(ClientContext &context, const string &table_name, ReplacementScanData *data) {\n+unique_ptr<TableRef> ReadCSVReplacement(ClientContext &context, ReplacementScanInput &input,\n+                                        optional_ptr<ReplacementScanData> data) {\n+\tauto &table_name = input.table_name;\n \tauto lower_name = StringUtil::Lower(table_name);\n \t// remove any compression\n \tif (StringUtil::EndsWith(lower_name, \".gz\")) {\ndiff --git a/src/include/duckdb/common/enum_util.hpp b/src/include/duckdb/common/enum_util.hpp\nindex b643a58a147a..4c00de8c22bb 100644\n--- a/src/include/duckdb/common/enum_util.hpp\n+++ b/src/include/duckdb/common/enum_util.hpp\n@@ -128,8 +128,6 @@ enum class ExpressionType : uint8_t;\n \n enum class ExtensionLoadResult : uint8_t;\n \n-enum class ExternalDependenciesType : uint8_t;\n-\n enum class ExtraDropInfoType : uint8_t;\n \n enum class ExtraTypeInfoType : uint8_t;\n@@ -473,9 +471,6 @@ const char* EnumUtil::ToChars<ExpressionType>(ExpressionType value);\n template<>\n const char* EnumUtil::ToChars<ExtensionLoadResult>(ExtensionLoadResult value);\n \n-template<>\n-const char* EnumUtil::ToChars<ExternalDependenciesType>(ExternalDependenciesType value);\n-\n template<>\n const char* EnumUtil::ToChars<ExtraDropInfoType>(ExtraDropInfoType value);\n \n@@ -918,9 +913,6 @@ ExpressionType EnumUtil::FromString<ExpressionType>(const char *value);\n template<>\n ExtensionLoadResult EnumUtil::FromString<ExtensionLoadResult>(const char *value);\n \n-template<>\n-ExternalDependenciesType EnumUtil::FromString<ExternalDependenciesType>(const char *value);\n-\n template<>\n ExtraDropInfoType EnumUtil::FromString<ExtraDropInfoType>(const char *value);\n \ndiff --git a/src/include/duckdb/function/function.hpp b/src/include/duckdb/function/function.hpp\nindex 7e89476e2526..8575f270fd60 100644\n--- a/src/include/duckdb/function/function.hpp\n+++ b/src/include/duckdb/function/function.hpp\n@@ -78,11 +78,6 @@ struct TableFunctionData : public FunctionData {\n \tDUCKDB_API bool Equals(const FunctionData &other) const override;\n };\n \n-struct PyTableFunctionData : public TableFunctionData {\n-\t//! External dependencies of this table function\n-\tunique_ptr<ExternalDependency> external_dependency;\n-};\n-\n struct FunctionParameters {\n \tvector<Value> values;\n \tnamed_parameter_map_t named_parameters;\ndiff --git a/src/include/duckdb/function/replacement_scan.hpp b/src/include/duckdb/function/replacement_scan.hpp\nindex 455f8ae19ebc..68a98a79b0f0 100644\n--- a/src/include/duckdb/function/replacement_scan.hpp\n+++ b/src/include/duckdb/function/replacement_scan.hpp\n@@ -17,12 +17,35 @@ class ClientContext;\n class TableRef;\n \n struct ReplacementScanData {\n+public:\n \tvirtual ~ReplacementScanData() {\n \t}\n+\n+public:\n+\ttemplate <class TARGET>\n+\tTARGET &Cast() {\n+\t\tDynamicCastCheck<TARGET>(this);\n+\t\treturn reinterpret_cast<TARGET &>(*this);\n+\t}\n+\ttemplate <class TARGET>\n+\tconst TARGET &Cast() const {\n+\t\tDynamicCastCheck<TARGET>(this);\n+\t\treturn reinterpret_cast<const TARGET &>(*this);\n+\t}\n+};\n+\n+struct ReplacementScanInput {\n+public:\n+\tReplacementScanInput(TableRef &ref, const string &table_name) : ref(ref), table_name(table_name) {\n+\t}\n+\n+public:\n+\tTableRef &ref;\n+\tconst string &table_name;\n };\n \n-typedef unique_ptr<TableRef> (*replacement_scan_t)(ClientContext &context, const string &table_name,\n-                                                   ReplacementScanData *data);\n+typedef unique_ptr<TableRef> (*replacement_scan_t)(ClientContext &context, ReplacementScanInput &input,\n+                                                   optional_ptr<ReplacementScanData> data);\n \n //! Replacement table scans are automatically attempted when a table name cannot be found in the schema\n //! This allows you to do e.g. SELECT * FROM 'filename.csv', and automatically convert this into a CSV scan\ndiff --git a/src/include/duckdb/function/table/arrow.hpp b/src/include/duckdb/function/table/arrow.hpp\nindex 8a9201217f9a..d2ea02304402 100644\n--- a/src/include/duckdb/function/table/arrow.hpp\n+++ b/src/include/duckdb/function/table/arrow.hpp\n@@ -46,10 +46,12 @@ typedef unique_ptr<ArrowArrayStreamWrapper> (*stream_factory_produce_t)(uintptr_\n                                                                         ArrowStreamParameters &parameters);\n typedef void (*stream_factory_get_schema_t)(ArrowArrayStream *stream_factory_ptr, ArrowSchema &schema);\n \n-struct ArrowScanFunctionData : public PyTableFunctionData {\n+struct ArrowScanFunctionData : public TableFunctionData {\n public:\n-\tArrowScanFunctionData(stream_factory_produce_t scanner_producer_p, uintptr_t stream_factory_ptr_p)\n-\t    : lines_read(0), stream_factory_ptr(stream_factory_ptr_p), scanner_producer(scanner_producer_p) {\n+\tArrowScanFunctionData(stream_factory_produce_t scanner_producer_p, uintptr_t stream_factory_ptr_p,\n+\t                      shared_ptr<DependencyItem> dependency = nullptr)\n+\t    : lines_read(0), stream_factory_ptr(stream_factory_ptr_p), scanner_producer(scanner_producer_p),\n+\t      dependency(std::move(dependency)) {\n \t}\n \tvector<LogicalType> all_types;\n \tatomic<idx_t> lines_read;\n@@ -59,6 +61,8 @@ struct ArrowScanFunctionData : public PyTableFunctionData {\n \tuintptr_t stream_factory_ptr;\n \t//! Pointer to the scanner factory produce\n \tstream_factory_produce_t scanner_producer;\n+\t//! The (optional) dependency of this function (used in Python for example)\n+\tshared_ptr<DependencyItem> dependency;\n \t//! Arrow table data\n \tArrowTableType arrow_table;\n };\ndiff --git a/src/include/duckdb/function/table_function.hpp b/src/include/duckdb/function/table_function.hpp\nindex 575f4c501218..503a3b2acb24 100644\n--- a/src/include/duckdb/function/table_function.hpp\n+++ b/src/include/duckdb/function/table_function.hpp\n@@ -85,9 +85,9 @@ struct TableFunctionBindInput {\n \tTableFunctionBindInput(vector<Value> &inputs, named_parameter_map_t &named_parameters,\n \t                       vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n \t                       optional_ptr<TableFunctionInfo> info, optional_ptr<Binder> binder,\n-\t                       const TableFunction &table_function)\n+\t                       const TableFunction &table_function, const TableFunctionRef &ref)\n \t    : inputs(inputs), named_parameters(named_parameters), input_table_types(input_table_types),\n-\t      input_table_names(input_table_names), info(info), binder(binder), table_function(table_function) {\n+\t      input_table_names(input_table_names), info(info), binder(binder), table_function(table_function), ref(ref) {\n \t}\n \n \tvector<Value> &inputs;\n@@ -97,6 +97,7 @@ struct TableFunctionBindInput {\n \toptional_ptr<TableFunctionInfo> info;\n \toptional_ptr<Binder> binder;\n \tconst TableFunction &table_function;\n+\tconst TableFunctionRef &ref;\n };\n \n struct TableFunctionInitInput {\ndiff --git a/src/include/duckdb/main/external_dependencies.hpp b/src/include/duckdb/main/external_dependencies.hpp\nindex 4523d9133fa3..ed6afd4a92c5 100644\n--- a/src/include/duckdb/main/external_dependencies.hpp\n+++ b/src/include/duckdb/main/external_dependencies.hpp\n@@ -6,17 +6,59 @@\n //\n //===----------------------------------------------------------------------===//\n \n+#include \"duckdb/common/case_insensitive_map.hpp\"\n+#include <functional>\n+\n #pragma once\n \n namespace duckdb {\n \n-enum class ExternalDependenciesType : uint8_t { PYTHON_DEPENDENCY };\n+class DependencyItem {\n+public:\n+\tvirtual ~DependencyItem() {};\n+\n+public:\n+\ttemplate <class TARGET>\n+\tTARGET &Cast() {\n+\t\tDynamicCastCheck<TARGET>(this);\n+\t\treturn reinterpret_cast<TARGET &>(*this);\n+\t}\n+\ttemplate <class TARGET>\n+\tconst TARGET &Cast() const {\n+\t\tDynamicCastCheck<TARGET>(this);\n+\t\treturn reinterpret_cast<const TARGET &>(*this);\n+\t}\n+};\n+\n+using dependency_scan_t = std::function<void(const string &name, shared_ptr<DependencyItem> item)>;\n \n class ExternalDependency {\n public:\n-\texplicit ExternalDependency(ExternalDependenciesType type_p) : type(type_p) {};\n-\tvirtual ~ExternalDependency() {};\n-\tExternalDependenciesType type;\n+\texplicit ExternalDependency() {\n+\t}\n+\t~ExternalDependency() {\n+\t}\n+\n+public:\n+\tvoid AddDependency(const string &name, shared_ptr<DependencyItem> item) {\n+\t\tobjects[name] = std::move(item);\n+\t}\n+\tshared_ptr<DependencyItem> GetDependency(const string &name) const {\n+\t\tauto it = objects.find(name);\n+\t\tif (it == objects.end()) {\n+\t\t\treturn nullptr;\n+\t\t}\n+\t\treturn it->second;\n+\t}\n+\tvoid ScanDependencies(const dependency_scan_t &callback) {\n+\t\tfor (auto &kv : objects) {\n+\t\t\tcallback(kv.first, kv.second);\n+\t\t}\n+\t}\n+\n+private:\n+\t//! The objects encompassed by this dependency\n+\tcase_insensitive_map_t<shared_ptr<DependencyItem>> objects;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/main/relation.hpp b/src/include/duckdb/main/relation.hpp\nindex 7a0e235d7ddb..f53770d8412b 100644\n--- a/src/include/duckdb/main/relation.hpp\n+++ b/src/include/duckdb/main/relation.hpp\n@@ -44,10 +44,8 @@ class Relation : public enable_shared_from_this<Relation> {\n \t}\n \n \tClientContextWrapper context;\n-\n \tRelationType type;\n-\n-\tshared_ptr<ExternalDependency> extra_dependencies;\n+\tvector<shared_ptr<ExternalDependency>> external_dependencies;\n \n public:\n \tDUCKDB_API virtual const vector<ColumnDefinition> &Columns() = 0;\n@@ -172,6 +170,7 @@ class Relation : public enable_shared_from_this<Relation> {\n \tvirtual Relation *ChildRelation() {\n \t\treturn nullptr;\n \t}\n+\tvoid AddExternalDependency(shared_ptr<ExternalDependency> dependency);\n \tDUCKDB_API vector<shared_ptr<ExternalDependency>> GetAllDependencies();\n \n protected:\ndiff --git a/src/include/duckdb/parser/tableref.hpp b/src/include/duckdb/parser/tableref.hpp\nindex 57a7e48548f2..d88142cf7c22 100644\n--- a/src/include/duckdb/parser/tableref.hpp\n+++ b/src/include/duckdb/parser/tableref.hpp\n@@ -12,6 +12,7 @@\n #include \"duckdb/common/optional_idx.hpp\"\n #include \"duckdb/common/enums/tableref_type.hpp\"\n #include \"duckdb/parser/parsed_data/sample_options.hpp\"\n+#include \"duckdb/main/external_dependencies.hpp\"\n \n namespace duckdb {\n \n@@ -32,6 +33,8 @@ class TableRef {\n \tunique_ptr<SampleOptions> sample;\n \t//! The location in the query (if any)\n \toptional_idx query_location;\n+\t// External dependencies of this table function\n+\tshared_ptr<ExternalDependency> external_dependency;\n \n public:\n \t//! Convert the object to a string\ndiff --git a/src/include/duckdb/parser/tableref/table_function_ref.hpp b/src/include/duckdb/parser/tableref/table_function_ref.hpp\nindex 7d782ca0f619..7cdc8caa0b3f 100644\n--- a/src/include/duckdb/parser/tableref/table_function_ref.hpp\n+++ b/src/include/duckdb/parser/tableref/table_function_ref.hpp\n@@ -12,7 +12,6 @@\n #include \"duckdb/parser/tableref.hpp\"\n #include \"duckdb/common/vector.hpp\"\n #include \"duckdb/parser/statement/select_statement.hpp\"\n-#include \"duckdb/main/external_dependencies.hpp\"\n \n namespace duckdb {\n //! Represents a Table producing function\n@@ -29,9 +28,6 @@ class TableFunctionRef : public TableRef {\n \t// if the function takes a subquery as argument its in here\n \tunique_ptr<SelectStatement> subquery;\n \n-\t// External dependencies of this table function\n-\tunique_ptr<ExternalDependency> external_dependency;\n-\n public:\n \tstring ToString() const override;\n \ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 96df1f4f0690..a41be84fd22c 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -324,11 +324,11 @@ class Binder : public enable_shared_from_this<Binder> {\n \tbool BindTableInTableOutFunction(vector<unique_ptr<ParsedExpression>> &expressions,\n \t                                 unique_ptr<BoundSubqueryRef> &subquery, ErrorData &error);\n \tunique_ptr<LogicalOperator> BindTableFunction(TableFunction &function, vector<Value> parameters);\n-\tunique_ptr<LogicalOperator>\n-\tBindTableFunctionInternal(TableFunction &table_function, const string &function_name, vector<Value> parameters,\n-\t                          named_parameter_map_t named_parameters, vector<LogicalType> input_table_types,\n-\t                          vector<string> input_table_names, const vector<string> &column_name_alias,\n-\t                          unique_ptr<ExternalDependency> external_dependency);\n+\tunique_ptr<LogicalOperator> BindTableFunctionInternal(TableFunction &table_function, const TableFunctionRef &ref,\n+\t                                                      vector<Value> parameters,\n+\t                                                      named_parameter_map_t named_parameters,\n+\t                                                      vector<LogicalType> input_table_types,\n+\t                                                      vector<string> input_table_names);\n \n \tunique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);\n \tunique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);\ndiff --git a/src/main/capi/replacement_scan-c.cpp b/src/main/capi/replacement_scan-c.cpp\nindex 2941b25a4952..ff3eae4ff5ae 100644\n--- a/src/main/capi/replacement_scan-c.cpp\n+++ b/src/main/capi/replacement_scan-c.cpp\n@@ -19,18 +19,19 @@ struct CAPIReplacementScanData : public ReplacementScanData {\n };\n \n struct CAPIReplacementScanInfo {\n-\tCAPIReplacementScanInfo(CAPIReplacementScanData *data) : data(data) {\n+\tCAPIReplacementScanInfo(optional_ptr<CAPIReplacementScanData> data) : data(data) {\n \t}\n \n-\tCAPIReplacementScanData *data;\n+\toptional_ptr<CAPIReplacementScanData> data;\n \tstring function_name;\n \tvector<Value> parameters;\n \tstring error;\n };\n \n-unique_ptr<TableRef> duckdb_capi_replacement_callback(ClientContext &context, const string &table_name,\n-                                                      ReplacementScanData *data) {\n-\tauto &scan_data = reinterpret_cast<CAPIReplacementScanData &>(*data);\n+unique_ptr<TableRef> duckdb_capi_replacement_callback(ClientContext &context, ReplacementScanInput &input,\n+                                                      optional_ptr<ReplacementScanData> data) {\n+\tauto &table_name = input.table_name;\n+\tauto &scan_data = data->Cast<CAPIReplacementScanData>();\n \n \tCAPIReplacementScanInfo info(&scan_data);\n \tscan_data.callback((duckdb_replacement_scan_info)&info, table_name.c_str(), scan_data.extra_data);\ndiff --git a/src/main/relation.cpp b/src/main/relation.cpp\nindex 2848a552c9bd..6215b037261b 100644\n--- a/src/main/relation.cpp\n+++ b/src/main/relation.cpp\n@@ -387,12 +387,16 @@ string Relation::RenderWhitespace(idx_t depth) {\n \treturn string(depth * 2, ' ');\n }\n \n+void Relation::AddExternalDependency(shared_ptr<ExternalDependency> dependency) {\n+\texternal_dependencies.push_back(std::move(dependency));\n+}\n+\n vector<shared_ptr<ExternalDependency>> Relation::GetAllDependencies() {\n \tvector<shared_ptr<ExternalDependency>> all_dependencies;\n \tRelation *cur = this;\n \twhile (cur) {\n-\t\tif (cur->extra_dependencies) {\n-\t\t\tall_dependencies.push_back(cur->extra_dependencies);\n+\t\tfor (auto &dep : cur->external_dependencies) {\n+\t\t\tall_dependencies.push_back(dep);\n \t\t}\n \t\tcur = cur->ChildRelation();\n \t}\ndiff --git a/src/main/relation/query_relation.cpp b/src/main/relation/query_relation.cpp\nindex 0ce867f51574..3261e6c2f87b 100644\n--- a/src/main/relation/query_relation.cpp\n+++ b/src/main/relation/query_relation.cpp\n@@ -2,14 +2,31 @@\n #include \"duckdb/main/client_context.hpp\"\n #include \"duckdb/parser/statement/select_statement.hpp\"\n #include \"duckdb/parser/tableref/subqueryref.hpp\"\n+#include \"duckdb/parser/tableref/joinref.hpp\"\n #include \"duckdb/parser/parser.hpp\"\n+#include \"duckdb/planner/bound_statement.hpp\"\n+#include \"duckdb/planner/binder.hpp\"\n+#include \"duckdb/parser/query_node/select_node.hpp\"\n+#include \"duckdb/planner/query_node/bound_select_node.hpp\"\n \n namespace duckdb {\n \n+static void InitializeTableRefDependency(TableRef &ref) {\n+\tif (ref.type == TableReferenceType::JOIN) {\n+\t\tauto &join_ref = ref.Cast<JoinRef>();\n+\t\tInitializeTableRefDependency(*join_ref.right);\n+\t\tInitializeTableRefDependency(*join_ref.left);\n+\t} else {\n+\t\tref.external_dependency = make_shared_ptr<ExternalDependency>();\n+\t}\n+}\n+\n QueryRelation::QueryRelation(const shared_ptr<ClientContext> &context, unique_ptr<SelectStatement> select_stmt_p,\n                              string alias_p)\n     : Relation(context, RelationType::QUERY_RELATION), select_stmt(std::move(select_stmt_p)),\n       alias(std::move(alias_p)) {\n+\tauto &ref = *select_stmt->node->Cast<SelectNode>().from_table;\n+\tInitializeTableRefDependency(ref);\n \tcontext->TryBindRelation(*this, this->columns);\n }\n \ndiff --git a/src/parser/tableref.cpp b/src/parser/tableref.cpp\nindex 3d72020f59ee..f8b8db70cd0d 100644\n--- a/src/parser/tableref.cpp\n+++ b/src/parser/tableref.cpp\n@@ -48,6 +48,7 @@ void TableRef::CopyProperties(TableRef &target) const {\n \ttarget.alias = alias;\n \ttarget.query_location = query_location;\n \ttarget.sample = sample ? sample->Copy() : nullptr;\n+\ttarget.external_dependency = external_dependency;\n }\n \n void TableRef::Print() {\ndiff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex 9b0c2862568f..494a5d83ec1c 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -46,31 +46,33 @@ static bool TryLoadExtensionForReplacementScan(ClientContext &context, const str\n unique_ptr<BoundTableRef> Binder::BindWithReplacementScan(ClientContext &context, const string &table_name,\n                                                           BaseTableRef &ref) {\n \tauto &config = DBConfig::GetConfig(context);\n-\tif (context.config.use_replacement_scans) {\n-\t\tfor (auto &scan : config.replacement_scans) {\n-\t\t\tauto replacement_function = scan.function(context, table_name, scan.data.get());\n-\t\t\tif (replacement_function) {\n-\t\t\t\tif (!ref.alias.empty()) {\n-\t\t\t\t\t// user-provided alias overrides the default alias\n-\t\t\t\t\treplacement_function->alias = ref.alias;\n-\t\t\t\t} else if (replacement_function->alias.empty()) {\n-\t\t\t\t\t// if the replacement scan itself did not provide an alias we use the table name\n-\t\t\t\t\treplacement_function->alias = ref.table_name;\n-\t\t\t\t}\n-\t\t\t\tif (replacement_function->type == TableReferenceType::TABLE_FUNCTION) {\n-\t\t\t\t\tauto &table_function = replacement_function->Cast<TableFunctionRef>();\n-\t\t\t\t\ttable_function.column_name_alias = ref.column_name_alias;\n-\t\t\t\t} else if (replacement_function->type == TableReferenceType::SUBQUERY) {\n-\t\t\t\t\tauto &subquery = replacement_function->Cast<SubqueryRef>();\n-\t\t\t\t\tsubquery.column_name_alias = ref.column_name_alias;\n-\t\t\t\t} else {\n-\t\t\t\t\tthrow InternalException(\"Replacement scan should return either a table function or a subquery\");\n-\t\t\t\t}\n-\t\t\t\treturn Bind(*replacement_function);\n-\t\t\t}\n+\tif (!context.config.use_replacement_scans) {\n+\t\treturn nullptr;\n+\t}\n+\tfor (auto &scan : config.replacement_scans) {\n+\t\tReplacementScanInput input(ref.Cast<TableRef>(), table_name);\n+\t\tauto replacement_function = scan.function(context, input, scan.data.get());\n+\t\tif (!replacement_function) {\n+\t\t\tcontinue;\n \t\t}\n+\t\tif (!ref.alias.empty()) {\n+\t\t\t// user-provided alias overrides the default alias\n+\t\t\treplacement_function->alias = ref.alias;\n+\t\t} else if (replacement_function->alias.empty()) {\n+\t\t\t// if the replacement scan itself did not provide an alias we use the table name\n+\t\t\treplacement_function->alias = ref.table_name;\n+\t\t}\n+\t\tif (replacement_function->type == TableReferenceType::TABLE_FUNCTION) {\n+\t\t\tauto &table_function = replacement_function->Cast<TableFunctionRef>();\n+\t\t\ttable_function.column_name_alias = ref.column_name_alias;\n+\t\t} else if (replacement_function->type == TableReferenceType::SUBQUERY) {\n+\t\t\tauto &subquery = replacement_function->Cast<SubqueryRef>();\n+\t\t\tsubquery.column_name_alias = ref.column_name_alias;\n+\t\t} else {\n+\t\t\tthrow InternalException(\"Replacement scan should return either a table function or a subquery\");\n+\t\t}\n+\t\treturn Bind(*replacement_function);\n \t}\n-\n \treturn nullptr;\n }\n \ndiff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp\nindex b2bf3c799a89..1654e1d48d03 100644\n--- a/src/planner/binder/tableref/bind_table_function.cpp\n+++ b/src/planner/binder/tableref/bind_table_function.cpp\n@@ -128,11 +128,25 @@ bool Binder::BindTableFunctionParameters(TableFunctionCatalogEntry &table_functi\n \treturn true;\n }\n \n-unique_ptr<LogicalOperator>\n-Binder::BindTableFunctionInternal(TableFunction &table_function, const string &function_name, vector<Value> parameters,\n-                                  named_parameter_map_t named_parameters, vector<LogicalType> input_table_types,\n-                                  vector<string> input_table_names, const vector<string> &column_name_alias,\n-                                  unique_ptr<ExternalDependency> external_dependency) {\n+static string GetAlias(const TableFunctionRef &ref) {\n+\tif (!ref.alias.empty()) {\n+\t\treturn ref.alias;\n+\t}\n+\tif (ref.function && ref.function->type == ExpressionType::FUNCTION) {\n+\t\tauto &function_expr = ref.function->Cast<FunctionExpression>();\n+\t\treturn function_expr.function_name;\n+\t}\n+\treturn string();\n+}\n+\n+unique_ptr<LogicalOperator> Binder::BindTableFunctionInternal(TableFunction &table_function,\n+                                                              const TableFunctionRef &ref, vector<Value> parameters,\n+                                                              named_parameter_map_t named_parameters,\n+                                                              vector<LogicalType> input_table_types,\n+                                                              vector<string> input_table_names) {\n+\tauto function_name = GetAlias(ref);\n+\tauto &column_name_alias = ref.column_name_alias;\n+\n \tauto bind_index = GenerateTableIndex();\n \t// perform the binding\n \tunique_ptr<FunctionData> bind_data;\n@@ -140,7 +154,7 @@ Binder::BindTableFunctionInternal(TableFunction &table_function, const string &f\n \tvector<string> return_names;\n \tif (table_function.bind || table_function.bind_replace) {\n \t\tTableFunctionBindInput bind_input(parameters, named_parameters, input_table_types, input_table_names,\n-\t\t                                  table_function.function_info.get(), this, table_function);\n+\t\t                                  table_function.function_info.get(), this, table_function, ref);\n \t\tif (table_function.bind_replace) {\n \t\t\tauto new_plan = table_function.bind_replace(context, bind_input);\n \t\t\tif (new_plan != nullptr) {\n@@ -151,10 +165,6 @@ Binder::BindTableFunctionInternal(TableFunction &table_function, const string &f\n \t\t\t}\n \t\t}\n \t\tbind_data = table_function.bind(context, bind_input, return_types, return_names);\n-\t\tif (table_function.name == \"pandas_scan\" || table_function.name == \"arrow_scan\") {\n-\t\t\tauto &arrow_bind = bind_data->Cast<PyTableFunctionData>();\n-\t\t\tarrow_bind.external_dependency = std::move(external_dependency);\n-\t\t}\n \t} else {\n \t\tthrow InvalidInputException(\"Cannot call function \\\"%s\\\" directly - it has no bind function\",\n \t\t                            table_function.name);\n@@ -197,10 +207,12 @@ unique_ptr<LogicalOperator> Binder::BindTableFunction(TableFunction &function, v\n \tnamed_parameter_map_t named_parameters;\n \tvector<LogicalType> input_table_types;\n \tvector<string> input_table_names;\n-\tvector<string> column_name_aliases;\n-\treturn BindTableFunctionInternal(function, function.name, std::move(parameters), std::move(named_parameters),\n-\t                                 std::move(input_table_types), std::move(input_table_names), column_name_aliases,\n-\t                                 nullptr);\n+\n+\tTableFunctionRef ref;\n+\tref.alias = function.name;\n+\tD_ASSERT(!ref.alias.empty());\n+\treturn BindTableFunctionInternal(function, ref, std::move(parameters), std::move(named_parameters),\n+\t                                 std::move(input_table_types), std::move(input_table_names));\n }\n \n unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {\n@@ -278,10 +290,8 @@ unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {\n \t\tinput_table_types = subquery->subquery->types;\n \t\tinput_table_names = subquery->subquery->names;\n \t}\n-\tauto get = BindTableFunctionInternal(table_function, ref.alias.empty() ? fexpr.function_name : ref.alias,\n-\t                                     std::move(parameters), std::move(named_parameters),\n-\t                                     std::move(input_table_types), std::move(input_table_names),\n-\t                                     ref.column_name_alias, std::move(ref.external_dependency));\n+\tauto get = BindTableFunctionInternal(table_function, ref, std::move(parameters), std::move(named_parameters),\n+\t                                     std::move(input_table_types), std::move(input_table_names));\n \tif (subquery) {\n \t\tget->children.push_back(Binder::CreatePlan(*subquery));\n \t}\ndiff --git a/src/planner/operator/logical_get.cpp b/src/planner/operator/logical_get.cpp\nindex b40d274f7f0f..188b0520660b 100644\n--- a/src/planner/operator/logical_get.cpp\n+++ b/src/planner/operator/logical_get.cpp\n@@ -9,6 +9,7 @@\n #include \"duckdb/storage/data_table.hpp\"\n #include \"duckdb/common/serializer/serializer.hpp\"\n #include \"duckdb/common/serializer/deserializer.hpp\"\n+#include \"duckdb/parser/tableref/table_function_ref.hpp\"\n \n namespace duckdb {\n \n@@ -164,9 +165,10 @@ unique_ptr<LogicalOperator> LogicalGet::Deserialize(Deserializer &deserializer)\n \t\tdeserializer.ReadProperty(207, \"named_parameters\", result->named_parameters);\n \t\tdeserializer.ReadProperty(208, \"input_table_types\", result->input_table_types);\n \t\tdeserializer.ReadProperty(209, \"input_table_names\", result->input_table_names);\n+\t\tTableFunctionRef empty_ref;\n \t\tTableFunctionBindInput input(result->parameters, result->named_parameters, result->input_table_types,\n-\t\t                             result->input_table_names, function.function_info.get(), nullptr,\n-\t\t                             result->function);\n+\t\t                             result->input_table_names, function.function_info.get(), nullptr, result->function,\n+\t\t                             empty_ref);\n \n \t\tvector<LogicalType> bind_return_types;\n \t\tvector<string> bind_names;\ndiff --git a/tools/pythonpkg/src/CMakeLists.txt b/tools/pythonpkg/src/CMakeLists.txt\nindex 22e511b515d1..7ab3984906c4 100644\n--- a/tools/pythonpkg/src/CMakeLists.txt\n+++ b/tools/pythonpkg/src/CMakeLists.txt\n@@ -25,6 +25,8 @@ add_library(\n   pyconnection.cpp\n   pystatement.cpp\n   python_import_cache.cpp\n+  python_replacement_scan.cpp\n+  python_dependency.cpp\n   pyrelation.cpp\n   pyexpression.cpp\n   dataframe.cpp\ndiff --git a/tools/pythonpkg/src/arrow/arrow_array_stream.cpp b/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\nindex 93b77b1e0e12..afd0242d84aa 100644\n--- a/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\n+++ b/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\n@@ -31,6 +31,7 @@ void VerifyArrowDatasetLoaded() {\n }\n \n PyArrowObjectType GetArrowType(const py::handle &obj) {\n+\tD_ASSERT(py::gil_check());\n \tauto &import_cache = *DuckDBPyConnection::ImportCache();\n \t// First Verify Lib Types\n \tauto table_class = import_cache.pyarrow.Table();\ndiff --git a/tools/pythonpkg/src/dataframe.cpp b/tools/pythonpkg/src/dataframe.cpp\nindex ec010aab8303..7c36053b14e6 100644\n--- a/tools/pythonpkg/src/dataframe.cpp\n+++ b/tools/pythonpkg/src/dataframe.cpp\n@@ -46,6 +46,18 @@ bool PandasDataFrame::IsPyArrowBacked(const py::handle &df) {\n \treturn false;\n }\n \n+py::object PandasDataFrame::ToArrowTable(const py::object &df) {\n+\tD_ASSERT(py::gil_check());\n+\ttry {\n+\t\treturn py::module_::import(\"pyarrow\").attr(\"lib\").attr(\"Table\").attr(\"from_pandas\")(df);\n+\t} catch (py::error_already_set &) {\n+\t\t// We don't fetch the original Python exception because it can cause a segfault\n+\t\t// The cause of this is not known yet, for now we just side-step the issue.\n+\t\tthrow InvalidInputException(\n+\t\t    \"The dataframe could not be converted to a pyarrow.lib.Table, because a Python exception occurred.\");\n+\t}\n+}\n+\n bool PolarsDataFrame::check_(const py::handle &object) { // NOLINT\n \tauto &import_cache = *DuckDBPyConnection::ImportCache();\n \treturn py::isinstance(object, import_cache.polars.DataFrame());\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pybind11/dataframe.hpp b/tools/pythonpkg/src/include/duckdb_python/pybind11/dataframe.hpp\nindex df10d766a0e4..51663a877ff7 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pybind11/dataframe.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pybind11/dataframe.hpp\n@@ -22,6 +22,7 @@ class PandasDataFrame : public py::object {\n public:\n \tstatic bool check_(const py::handle &object); // NOLINT\n \tstatic bool IsPyArrowBacked(const py::handle &df);\n+\tstatic py::object ToArrowTable(const py::object &df);\n };\n \n class PolarsDataFrame : public py::object {\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\nindex a7817053e633..b211c0c309a9 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n@@ -1,7 +1,7 @@\n //===----------------------------------------------------------------------===//\n //                         DuckDB\n //\n-// duckdb_python/pyconnection.hpp\n+// duckdb_python/pyconnection/pyconnection.hpp\n //\n //\n //===----------------------------------------------------------------------===//\n@@ -19,6 +19,7 @@\n #include \"duckdb/execution/operator/csv_scanner/csv_reader_options.hpp\"\n #include \"duckdb_python/pyfilesystem.hpp\"\n #include \"duckdb_python/pybind11/registered_py_object.hpp\"\n+#include \"duckdb_python/python_dependency.hpp\"\n #include \"duckdb/function/scalar_function.hpp\"\n #include \"duckdb_python/pybind11/conversions/exception_handling_enum.hpp\"\n #include \"duckdb_python/pybind11/conversions/python_udf_type_enum.hpp\"\n@@ -48,7 +49,7 @@ struct DuckDBPyConnection : public enable_shared_from_this<DuckDBPyConnection> {\n \tstd::mutex py_connection_lock;\n \t//! MemoryFileSystem used to temporarily store file-like objects for reading\n \tshared_ptr<ModifiedMemoryFileSystem> internal_object_filesystem;\n-\tcase_insensitive_map_t<unique_ptr<PythonDependencies>> registered_functions;\n+\tcase_insensitive_map_t<unique_ptr<ExternalDependency>> registered_functions;\n \n public:\n \texplicit DuckDBPyConnection() {\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp b/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\nindex 3289f42b35b3..60bf52316c8f 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\n@@ -25,33 +25,6 @@\n \n namespace duckdb {\n \n-struct DuckDBPyConnection;\n-\n-class PythonDependencies : public ExternalDependency {\n-public:\n-\texplicit PythonDependencies() : ExternalDependency(ExternalDependenciesType::PYTHON_DEPENDENCY) {\n-\t}\n-\t~PythonDependencies() override {\n-\t\tpy::gil_scoped_acquire gil;\n-\t\tpy_object_list.clear();\n-\t}\n-\n-\texplicit PythonDependencies(py::function map_function)\n-\t    : ExternalDependency(ExternalDependenciesType::PYTHON_DEPENDENCY), map_function(std::move(map_function)) {};\n-\texplicit PythonDependencies(unique_ptr<RegisteredObject> py_object)\n-\t    : ExternalDependency(ExternalDependenciesType::PYTHON_DEPENDENCY) {\n-\t\tpy_object_list.push_back(std::move(py_object));\n-\t};\n-\texplicit PythonDependencies(unique_ptr<RegisteredObject> py_object_original,\n-\t                            unique_ptr<RegisteredObject> py_object_copy)\n-\t    : ExternalDependency(ExternalDependenciesType::PYTHON_DEPENDENCY) {\n-\t\tpy_object_list.push_back(std::move(py_object_original));\n-\t\tpy_object_list.push_back(std::move(py_object_copy));\n-\t};\n-\tpy::function map_function;\n-\tvector<unique_ptr<RegisteredObject>> py_object_list;\n-};\n-\n struct DuckDBPyRelation {\n public:\n \texplicit DuckDBPyRelation(shared_ptr<Relation> rel);\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/python_dependency.hpp b/tools/pythonpkg/src/include/duckdb_python/python_dependency.hpp\nnew file mode 100644\nindex 000000000000..3b4281d08461\n--- /dev/null\n+++ b/tools/pythonpkg/src/include/duckdb_python/python_dependency.hpp\n@@ -0,0 +1,25 @@\n+#pragma once\n+\n+#include \"duckdb/common/string.hpp\"\n+#include \"duckdb/common/unique_ptr.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n+#include \"duckdb/main/external_dependencies.hpp\"\n+#include \"duckdb_python/pybind11/pybind_wrapper.hpp\"\n+#include \"duckdb_python/pybind11/registered_py_object.hpp\"\n+\n+namespace duckdb {\n+\n+class PythonDependencyItem : public DependencyItem {\n+public:\n+\texplicit PythonDependencyItem(unique_ptr<RegisteredObject> &&object);\n+\t~PythonDependencyItem() override;\n+\n+public:\n+\tstatic shared_ptr<DependencyItem> Create(py::object object);\n+\tstatic shared_ptr<DependencyItem> Create(unique_ptr<RegisteredObject> &&object);\n+\n+public:\n+\tunique_ptr<RegisteredObject> object;\n+};\n+\n+} // namespace duckdb\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/python_replacement_scan.hpp b/tools/pythonpkg/src/include/duckdb_python/python_replacement_scan.hpp\nnew file mode 100644\nindex 000000000000..6bdd089c697e\n--- /dev/null\n+++ b/tools/pythonpkg/src/include/duckdb_python/python_replacement_scan.hpp\n@@ -0,0 +1,16 @@\n+#pragma once\n+\n+#include \"duckdb/main/client_context_state.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n+#include \"duckdb/parser/tableref.hpp\"\n+#include \"duckdb/function/replacement_scan.hpp\"\n+\n+namespace duckdb {\n+\n+struct PythonReplacementScan {\n+public:\n+\tstatic unique_ptr<TableRef> Replace(ClientContext &context, ReplacementScanInput &input,\n+\t                                    optional_ptr<ReplacementScanData> data);\n+};\n+\n+} // namespace duckdb\ndiff --git a/tools/pythonpkg/src/pandas/scan.cpp b/tools/pythonpkg/src/pandas/scan.cpp\nindex 1077b05aaf71..147d77f4a0a3 100644\n--- a/tools/pythonpkg/src/pandas/scan.cpp\n+++ b/tools/pythonpkg/src/pandas/scan.cpp\n@@ -7,22 +7,24 @@\n #include \"duckdb_python/numpy/numpy_bind.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n #include \"duckdb_python/pandas/column/pandas_numpy_column.hpp\"\n+#include \"duckdb/parser/tableref/table_function_ref.hpp\"\n \n #include \"duckdb/common/atomic.hpp\"\n \n namespace duckdb {\n \n-struct PandasScanFunctionData : public PyTableFunctionData {\n+struct PandasScanFunctionData : public TableFunctionData {\n \tPandasScanFunctionData(py::handle df, idx_t row_count, vector<PandasColumnBindData> pandas_bind_data,\n-\t                       vector<LogicalType> sql_types)\n+\t                       vector<LogicalType> sql_types, shared_ptr<DependencyItem> dependency)\n \t    : df(df), row_count(row_count), lines_read(0), pandas_bind_data(std::move(pandas_bind_data)),\n-\t      sql_types(std::move(sql_types)) {\n+\t      sql_types(std::move(sql_types)), copied_df(std::move(dependency)) {\n \t}\n \tpy::handle df;\n \tidx_t row_count;\n \tatomic<idx_t> lines_read;\n \tvector<PandasColumnBindData> pandas_bind_data;\n \tvector<LogicalType> sql_types;\n+\tshared_ptr<DependencyItem> copied_df;\n \n \t~PandasScanFunctionData() override {\n \t\ttry {\n@@ -89,9 +91,18 @@ unique_ptr<FunctionData> PandasScanFunction::PandasScanBind(ClientContext &conte\n \t}\n \tauto df_columns = py::list(df.attr(\"keys\")());\n \n+\tauto &ref = input.ref;\n+\n+\tshared_ptr<DependencyItem> dependency_item;\n+\tif (ref.external_dependency) {\n+\t\t// This was created during the replacement scan (see python_replacement_scan.cpp)\n+\t\tdependency_item = ref.external_dependency->GetDependency(\"copy\");\n+\t\tD_ASSERT(dependency_item);\n+\t}\n+\n \tauto get_fun = df.attr(\"__getitem__\");\n \tidx_t row_count = py::len(get_fun(df_columns[0]));\n-\treturn make_uniq<PandasScanFunctionData>(df, row_count, std::move(pandas_bind_data), return_types);\n+\treturn make_uniq<PandasScanFunctionData>(df, row_count, std::move(pandas_bind_data), return_types, dependency_item);\n }\n \n unique_ptr<GlobalTableFunctionState> PandasScanFunction::PandasScanInitGlobal(ClientContext &context,\ndiff --git a/tools/pythonpkg/src/path_like.cpp b/tools/pythonpkg/src/path_like.cpp\nindex aa003a8fa8f5..a69bcd42c783 100644\n--- a/tools/pythonpkg/src/path_like.cpp\n+++ b/tools/pythonpkg/src/path_like.cpp\n@@ -71,7 +71,10 @@ PathLike PathLikeProcessor::Finalize() {\n \n \t// Create the dependency, which contains the logic to clean up the files in its destructor\n \tauto &fs = GetFS();\n-\tresult.dependency = make_uniq<PythonDependencies>(make_uniq<FileSystemObject>(fs, std::move(fs_files)));\n+\tauto dependency = make_uniq<ExternalDependency>();\n+\tauto dependency_item = PythonDependencyItem::Create(make_uniq<FileSystemObject>(fs, std::move(fs_files)));\n+\tdependency->AddDependency(\"file_handles\", std::move(dependency_item));\n+\tresult.dependency = std::move(dependency);\n \treturn result;\n }\n \ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex bfaba7a8c166..abbacfd0e934 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -50,6 +50,7 @@\n #include \"duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp\"\n #include \"duckdb/main/pending_query_result.hpp\"\n #include \"duckdb/parser/keyword_helper.hpp\"\n+#include \"duckdb_python/python_replacement_scan.hpp\"\n #include \"duckdb/common/shared_ptr.hpp\"\n #include \"duckdb/main/materialized_query_result.hpp\"\n #include \"duckdb/main/stream_query_result.hpp\"\n@@ -115,17 +116,6 @@ bool DuckDBPyConnection::IsJupyter() {\n \treturn DuckDBPyConnection::environment == PythonEnvironmentType::JUPYTER;\n }\n \n-py::object ArrowTableFromDataframe(const py::object &df) {\n-\ttry {\n-\t\treturn py::module_::import(\"pyarrow\").attr(\"lib\").attr(\"Table\").attr(\"from_pandas\")(df);\n-\t} catch (py::error_already_set &) {\n-\t\t// We don't fetch the original Python exception because it can cause a segfault\n-\t\t// The cause of this is not known yet, for now we just side-step the issue.\n-\t\tthrow InvalidInputException(\n-\t\t    \"The dataframe could not be converted to a pyarrow.lib.Table, because a Python exception occurred.\");\n-\t}\n-}\n-\n // NOTE: this function is generated by tools/pythonpkg/scripts/generate_connection_methods.py.\n // Do not edit this function manually, your changes will be overwritten!\n \n@@ -407,7 +397,9 @@ DuckDBPyConnection::RegisterScalarUDF(const string &name, const py::function &ud\n \n \tcontext.RegisterFunction(info);\n \n-\tregistered_functions[name] = make_uniq<PythonDependencies>(udf);\n+\tauto dependency = make_uniq<ExternalDependency>();\n+\tdependency->AddDependency(\"function\", PythonDependencyItem::Create(udf));\n+\tregistered_functions[name] = std::move(dependency);\n \n \treturn shared_from_this();\n }\n@@ -662,8 +654,11 @@ void DuckDBPyConnection::RegisterArrowObject(const py::object &arrow_object, con\n \t\t        ->CreateView(name, true, true);\n \t}\n \tvector<shared_ptr<ExternalDependency>> dependencies;\n-\tdependencies.push_back(\n-\t    make_shared_ptr<PythonDependencies>(make_uniq<RegisteredArrow>(std::move(stream_factory), arrow_object)));\n+\tauto dependency = make_shared_ptr<ExternalDependency>();\n+\tauto dependency_item =\n+\t    PythonDependencyItem::Create(make_uniq<RegisteredArrow>(std::move(stream_factory), arrow_object));\n+\tdependency->AddDependency(\"object\", std::move(dependency_item));\n+\tdependencies.push_back(std::move(dependency));\n \tconnection->context->external_dependencies[name] = std::move(dependencies);\n }\n \n@@ -675,7 +670,7 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::RegisterPythonObject(const st\n \n \tif (DuckDBPyConnection::IsPandasDataframe(python_object)) {\n \t\tif (PandasDataFrame::IsPyArrowBacked(python_object)) {\n-\t\t\tauto arrow_table = ArrowTableFromDataframe(python_object);\n+\t\t\tauto arrow_table = PandasDataFrame::ToArrowTable(python_object);\n \t\t\tRegisterArrowObject(arrow_table, name);\n \t\t} else {\n \t\t\tauto new_df = PandasScanFunction::PandasReplaceCopiedNames(python_object);\n@@ -686,10 +681,12 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::RegisterPythonObject(const st\n \t\t\t\t        ->CreateView(name, true, true);\n \t\t\t}\n \n-\t\t\t// keep a reference\n+\t\t\tauto dependency = make_shared_ptr<ExternalDependency>();\n+\t\t\tdependency->AddDependency(\"original\", PythonDependencyItem::Create(python_object));\n+\t\t\tdependency->AddDependency(\"copy\", PythonDependencyItem::Create(std::move(new_df)));\n+\n \t\t\tvector<shared_ptr<ExternalDependency>> dependencies;\n-\t\t\tdependencies.push_back(make_shared_ptr<PythonDependencies>(make_uniq<RegisteredObject>(python_object),\n-\t\t\t                                                           make_uniq<RegisteredObject>(new_df)));\n+\t\t\tdependencies.push_back(std::move(dependency));\n \t\t\tconnection->context->external_dependencies[name] = std::move(dependencies);\n \t\t}\n \t} else if (IsAcceptedArrowObject(python_object) || IsPolarsDataframe(python_object)) {\n@@ -1019,8 +1016,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \tauto read_csv_p = connection->ReadCSV(name, std::move(bind_parameters));\n \tauto &read_csv = read_csv_p->Cast<ReadCSVRelation>();\n \tif (file_like_object_wrapper) {\n-\t\tD_ASSERT(!read_csv.extra_dependencies);\n-\t\tread_csv.extra_dependencies = std::move(file_like_object_wrapper);\n+\t\tread_csv.AddExternalDependency(std::move(file_like_object_wrapper));\n \t}\n \n \treturn make_uniq<DuckDBPyRelation>(read_csv_p->Alias(read_csv.alias));\n@@ -1118,15 +1114,17 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromDF(const PandasDataFrame &v\n \t}\n \tstring name = \"df_\" + StringUtil::GenerateRandomName();\n \tif (PandasDataFrame::IsPyArrowBacked(value)) {\n-\t\tauto table = ArrowTableFromDataframe(value);\n+\t\tauto table = PandasDataFrame::ToArrowTable(value);\n \t\treturn DuckDBPyConnection::FromArrow(table);\n \t}\n \tauto new_df = PandasScanFunction::PandasReplaceCopiedNames(value);\n \tvector<Value> params;\n \tparams.emplace_back(Value::POINTER(CastPointerToValue(new_df.ptr())));\n \tauto rel = connection->TableFunction(\"pandas_scan\", params)->Alias(name);\n-\trel->extra_dependencies =\n-\t    make_uniq<PythonDependencies>(make_uniq<RegisteredObject>(value), make_uniq<RegisteredObject>(new_df));\n+\tauto dependency = make_shared_ptr<ExternalDependency>();\n+\tdependency->AddDependency(\"original\", PythonDependencyItem::Create(value));\n+\tdependency->AddDependency(\"copy\", PythonDependencyItem::Create(new_df));\n+\trel->AddExternalDependency(std::move(dependency));\n \treturn make_uniq<DuckDBPyRelation>(std::move(rel));\n }\n \n@@ -1208,8 +1206,11 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromArrow(py::object &arrow_obj\n \t                                              Value::POINTER(CastPointerToValue(stream_factory_produce)),\n \t                                              Value::POINTER(CastPointerToValue(stream_factory_get_schema))})\n \t               ->Alias(name);\n-\trel->extra_dependencies =\n-\t    make_uniq<PythonDependencies>(make_uniq<RegisteredArrow>(std::move(stream_factory), arrow_object));\n+\tauto dependency = make_shared_ptr<ExternalDependency>();\n+\tauto dependency_item =\n+\t    PythonDependencyItem::Create(make_uniq<RegisteredArrow>(std::move(stream_factory), arrow_object));\n+\tdependency->AddDependency(\"object\", std::move(dependency_item));\n+\trel->AddExternalDependency(std::move(dependency));\n \treturn make_uniq<DuckDBPyRelation>(std::move(rel));\n }\n \n@@ -1422,138 +1423,6 @@ duckdb::pyarrow::RecordBatchReader DuckDBPyConnection::FetchRecordBatchReader(co\n \treturn result->FetchRecordBatchReader(rows_per_batch);\n }\n \n-static void CreateArrowScan(py::object entry, TableFunctionRef &table_function,\n-                            vector<unique_ptr<ParsedExpression>> &children, ClientProperties &client_properties) {\n-\tauto stream_factory = make_uniq<PythonTableArrowArrayStreamFactory>(entry.ptr(), client_properties);\n-\tauto stream_factory_produce = PythonTableArrowArrayStreamFactory::Produce;\n-\tauto stream_factory_get_schema = PythonTableArrowArrayStreamFactory::GetSchema;\n-\n-\tchildren.push_back(make_uniq<ConstantExpression>(Value::POINTER(CastPointerToValue(stream_factory.get()))));\n-\tchildren.push_back(make_uniq<ConstantExpression>(Value::POINTER(CastPointerToValue(stream_factory_produce))));\n-\tchildren.push_back(make_uniq<ConstantExpression>(Value::POINTER(CastPointerToValue(stream_factory_get_schema))));\n-\n-\ttable_function.function = make_uniq<FunctionExpression>(\"arrow_scan\", std::move(children));\n-\ttable_function.external_dependency =\n-\t    make_uniq<PythonDependencies>(make_uniq<RegisteredArrow>(std::move(stream_factory), entry));\n-}\n-\n-static unique_ptr<TableRef> TryReplacement(py::dict &dict, py::str &table_name, ClientProperties &client_properties,\n-                                           py::object &current_frame) {\n-\tif (!dict.contains(table_name)) {\n-\t\t// not present in the globals\n-\t\treturn nullptr;\n-\t}\n-\tauto entry = dict[table_name];\n-\tauto table_function = make_uniq<TableFunctionRef>();\n-\tvector<unique_ptr<ParsedExpression>> children;\n-\tNumpyObjectType numpytype; // Identify the type of accepted numpy objects.\n-\tif (DuckDBPyConnection::IsPandasDataframe(entry)) {\n-\t\tif (PandasDataFrame::IsPyArrowBacked(entry)) {\n-\t\t\tauto table = ArrowTableFromDataframe(entry);\n-\t\t\tCreateArrowScan(table, *table_function, children, client_properties);\n-\t\t} else {\n-\t\t\tauto new_df = PandasScanFunction::PandasReplaceCopiedNames(entry);\n-\t\t\tchildren.push_back(make_uniq<ConstantExpression>(Value::POINTER(CastPointerToValue(new_df.ptr()))));\n-\t\t\ttable_function->function = make_uniq<FunctionExpression>(\"pandas_scan\", std::move(children));\n-\t\t\ttable_function->external_dependency =\n-\t\t\t    make_uniq<PythonDependencies>(make_uniq<RegisteredObject>(entry), make_uniq<RegisteredObject>(new_df));\n-\t\t}\n-\n-\t} else if (DuckDBPyConnection::IsAcceptedArrowObject(entry)) {\n-\t\tCreateArrowScan(entry, *table_function, children, client_properties);\n-\t} else if (DuckDBPyRelation::IsRelation(entry)) {\n-\t\tauto pyrel = py::cast<DuckDBPyRelation *>(entry);\n-\t\t// create a subquery from the underlying relation object\n-\t\tauto select = make_uniq<SelectStatement>();\n-\t\tselect->node = pyrel->GetRel().GetQueryNode();\n-\n-\t\tauto subquery = make_uniq<SubqueryRef>(std::move(select));\n-\t\treturn std::move(subquery);\n-\t} else if (PolarsDataFrame::IsDataFrame(entry)) {\n-\t\tauto arrow_dataset = entry.attr(\"to_arrow\")();\n-\t\tCreateArrowScan(arrow_dataset, *table_function, children, client_properties);\n-\t} else if (PolarsDataFrame::IsLazyFrame(entry)) {\n-\t\tauto materialized = entry.attr(\"collect\")();\n-\t\tauto arrow_dataset = materialized.attr(\"to_arrow\")();\n-\t\tCreateArrowScan(arrow_dataset, *table_function, children, client_properties);\n-\t} else if ((numpytype = DuckDBPyConnection::IsAcceptedNumpyObject(entry)) != NumpyObjectType::INVALID) { // NOLINT\n-\t\tpy::dict data; // we will convert all the supported format to dict{\"key\": np.array(value)}.\n-\t\tsize_t idx = 0;\n-\t\tswitch (numpytype) {\n-\t\tcase NumpyObjectType::NDARRAY1D:\n-\t\t\tdata[\"column0\"] = entry;\n-\t\t\tbreak;\n-\t\tcase NumpyObjectType::NDARRAY2D:\n-\t\t\tidx = 0;\n-\t\t\tfor (auto item : py::cast<py::array>(entry)) {\n-\t\t\t\tdata[(\"column\" + std::to_string(idx)).c_str()] = item;\n-\t\t\t\tidx++;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase NumpyObjectType::LIST:\n-\t\t\tidx = 0;\n-\t\t\tfor (auto item : py::cast<py::list>(entry)) {\n-\t\t\t\tdata[(\"column\" + std::to_string(idx)).c_str()] = item;\n-\t\t\t\tidx++;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase NumpyObjectType::DICT:\n-\t\t\tdata = py::cast<py::dict>(entry);\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\tthrow NotImplementedException(\"Unsupported Numpy object\");\n-\t\t\tbreak;\n-\t\t}\n-\t\tchildren.push_back(make_uniq<ConstantExpression>(Value::POINTER(CastPointerToValue(data.ptr()))));\n-\t\ttable_function->function = make_uniq<FunctionExpression>(\"pandas_scan\", std::move(children));\n-\t\ttable_function->external_dependency =\n-\t\t    make_uniq<PythonDependencies>(make_uniq<RegisteredObject>(entry), make_uniq<RegisteredObject>(data));\n-\t} else {\n-\t\tstd::string location = py::cast<py::str>(current_frame.attr(\"f_code\").attr(\"co_filename\"));\n-\t\tlocation += \":\";\n-\t\tlocation += py::cast<py::str>(current_frame.attr(\"f_lineno\"));\n-\t\tstd::string cpp_table_name = table_name;\n-\t\tauto py_object_type = string(py::str(entry.get_type().attr(\"__name__\")));\n-\n-\t\tthrow InvalidInputException(\n-\t\t    \"Python Object \\\"%s\\\" of type \\\"%s\\\" found on line \\\"%s\\\" not suitable for replacement scans.\\nMake sure \"\n-\t\t    \"that \\\"%s\\\" is either a pandas.DataFrame, duckdb.DuckDBPyRelation, pyarrow Table, Dataset, \"\n-\t\t    \"RecordBatchReader, Scanner, or NumPy ndarrays with supported format\",\n-\t\t    cpp_table_name, py_object_type, location, cpp_table_name);\n-\t}\n-\treturn std::move(table_function);\n-}\n-\n-static unique_ptr<TableRef> ScanReplacement(ClientContext &context, const string &table_name,\n-                                            ReplacementScanData *data) {\n-\tpy::gil_scoped_acquire acquire;\n-\tauto py_table_name = py::str(table_name);\n-\t// Here we do an exhaustive search on the frame lineage\n-\tauto current_frame = py::module::import(\"inspect\").attr(\"currentframe\")();\n-\tauto client_properties = context.GetClientProperties();\n-\twhile (hasattr(current_frame, \"f_locals\")) {\n-\t\tauto local_dict = py::reinterpret_borrow<py::dict>(current_frame.attr(\"f_locals\"));\n-\t\t// search local dictionary\n-\t\tif (local_dict) {\n-\t\t\tauto result = TryReplacement(local_dict, py_table_name, client_properties, current_frame);\n-\t\t\tif (result) {\n-\t\t\t\treturn result;\n-\t\t\t}\n-\t\t}\n-\t\t// search global dictionary\n-\t\tauto global_dict = py::reinterpret_borrow<py::dict>(current_frame.attr(\"f_globals\"));\n-\t\tif (global_dict) {\n-\t\t\tauto result = TryReplacement(global_dict, py_table_name, client_properties, current_frame);\n-\t\t\tif (result) {\n-\t\t\t\treturn result;\n-\t\t\t}\n-\t\t}\n-\t\tcurrent_frame = current_frame.attr(\"f_back\");\n-\t}\n-\t// Not found :(\n-\treturn nullptr;\n-}\n-\n case_insensitive_map_t<Value> TransformPyConfigDict(const py::dict &py_config_dict) {\n \tcase_insensitive_map_t<Value> config_dict;\n \tfor (auto &kv : py_config_dict) {\n@@ -1568,7 +1437,7 @@ void CreateNewInstance(DuckDBPyConnection &res, const string &database, DBConfig\n \t// We don't cache unnamed memory instances (i.e., :memory:)\n \tbool cache_instance = database != \":memory:\" && !database.empty();\n \tif (config.options.enable_external_access) {\n-\t\tconfig.replacement_scans.emplace_back(ScanReplacement);\n+\t\tconfig.replacement_scans.emplace_back(PythonReplacementScan::Replace);\n \t}\n \tres.database = instance_cache.CreateInstance(database, config, cache_instance);\n \tres.connection = make_uniq<Connection>(*res.database);\ndiff --git a/tools/pythonpkg/src/pyrelation.cpp b/tools/pythonpkg/src/pyrelation.cpp\nindex 54ed07ec891e..ea21334ba56e 100644\n--- a/tools/pythonpkg/src/pyrelation.cpp\n+++ b/tools/pythonpkg/src/pyrelation.cpp\n@@ -62,7 +62,9 @@ DuckDBPyRelation::DuckDBPyRelation(unique_ptr<DuckDBPyResult> result_p) : rel(nu\n \n unique_ptr<DuckDBPyRelation> DuckDBPyRelation::ProjectFromExpression(const string &expression) {\n \tauto projected_relation = make_uniq<DuckDBPyRelation>(rel->Project(expression));\n-\tprojected_relation->rel->extra_dependencies = this->rel->extra_dependencies;\n+\tfor (auto &dep : this->rel->external_dependencies) {\n+\t\tprojected_relation->rel->AddExternalDependency(dep);\n+\t}\n \treturn projected_relation;\n }\n \n@@ -1356,10 +1358,10 @@ unique_ptr<DuckDBPyRelation> DuckDBPyRelation::Map(py::function fun, Optional<py\n \tparams.emplace_back(Value::POINTER(CastPointerToValue(fun.ptr())));\n \tparams.emplace_back(Value::POINTER(CastPointerToValue(schema.ptr())));\n \tauto relation = make_uniq<DuckDBPyRelation>(rel->TableFunction(\"python_map_function\", params));\n-\tauto rel_dependency = make_uniq<PythonDependencies>();\n-\trel_dependency->map_function = std::move(fun);\n-\trel_dependency->py_object_list.push_back(make_uniq<RegisteredObject>(std::move(schema)));\n-\trelation->rel->extra_dependencies = std::move(rel_dependency);\n+\tauto rel_dependency = make_uniq<ExternalDependency>();\n+\trel_dependency->AddDependency(\"map\", PythonDependencyItem::Create(std::move(fun)));\n+\trel_dependency->AddDependency(\"schema\", PythonDependencyItem::Create(std::move(schema)));\n+\trelation->rel->AddExternalDependency(std::move(rel_dependency));\n \treturn relation;\n }\n \ndiff --git a/tools/pythonpkg/src/python_dependency.cpp b/tools/pythonpkg/src/python_dependency.cpp\nnew file mode 100644\nindex 000000000000..dc62d24856ed\n--- /dev/null\n+++ b/tools/pythonpkg/src/python_dependency.cpp\n@@ -0,0 +1,23 @@\n+#include \"duckdb_python/python_dependency.hpp\"\n+#include \"duckdb/common/helper.hpp\"\n+\n+namespace duckdb {\n+\n+PythonDependencyItem::PythonDependencyItem(unique_ptr<RegisteredObject> &&object) : object(std::move(object)) {\n+}\n+\n+PythonDependencyItem::~PythonDependencyItem() { // NOLINT - cannot throw in exception\n+\tpy::gil_scoped_acquire gil;\n+\tobject.reset();\n+}\n+\n+shared_ptr<DependencyItem> PythonDependencyItem::Create(py::object object) {\n+\tauto registered_object = make_uniq<RegisteredObject>(std::move(object));\n+\treturn make_shared_ptr<PythonDependencyItem>(std::move(registered_object));\n+}\n+\n+shared_ptr<DependencyItem> PythonDependencyItem::Create(unique_ptr<RegisteredObject> &&object) {\n+\treturn make_shared_ptr<PythonDependencyItem>(std::move(object));\n+}\n+\n+} // namespace duckdb\ndiff --git a/tools/pythonpkg/src/python_replacement_scan.cpp b/tools/pythonpkg/src/python_replacement_scan.cpp\nnew file mode 100644\nindex 000000000000..2fc5026fe12b\n--- /dev/null\n+++ b/tools/pythonpkg/src/python_replacement_scan.cpp\n@@ -0,0 +1,203 @@\n+#include \"duckdb_python/python_replacement_scan.hpp\"\n+#include \"duckdb_python/pybind11/pybind_wrapper.hpp\"\n+#include \"duckdb/main/client_properties.hpp\"\n+#include \"duckdb_python/numpy/numpy_type.hpp\"\n+#include \"duckdb/parser/tableref/table_function_ref.hpp\"\n+#include \"duckdb_python/pyconnection/pyconnection.hpp\"\n+#include \"duckdb_python/pybind11/dataframe.hpp\"\n+#include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/expression/function_expression.hpp\"\n+#include \"duckdb/common/typedefs.hpp\"\n+#include \"duckdb_python/pandas/pandas_scan.hpp\"\n+#include \"duckdb/parser/tableref/subqueryref.hpp\"\n+#include \"duckdb_python/pyrelation.hpp\"\n+\n+namespace duckdb {\n+\n+static void CreateArrowScan(const string &name, py::object entry, TableFunctionRef &table_function,\n+                            vector<unique_ptr<ParsedExpression>> &children, ClientProperties &client_properties) {\n+\tauto stream_factory = make_uniq<PythonTableArrowArrayStreamFactory>(entry.ptr(), client_properties);\n+\tauto stream_factory_produce = PythonTableArrowArrayStreamFactory::Produce;\n+\tauto stream_factory_get_schema = PythonTableArrowArrayStreamFactory::GetSchema;\n+\n+\tchildren.push_back(make_uniq<ConstantExpression>(Value::POINTER(CastPointerToValue(stream_factory.get()))));\n+\tchildren.push_back(make_uniq<ConstantExpression>(Value::POINTER(CastPointerToValue(stream_factory_produce))));\n+\tchildren.push_back(make_uniq<ConstantExpression>(Value::POINTER(CastPointerToValue(stream_factory_get_schema))));\n+\n+\ttable_function.function = make_uniq<FunctionExpression>(\"arrow_scan\", std::move(children));\n+\tauto dependency = make_uniq<ExternalDependency>();\n+\tauto dependency_item = PythonDependencyItem::Create(make_uniq<RegisteredArrow>(std::move(stream_factory), entry));\n+\tdependency->AddDependency(\"replacement_cache\", std::move(dependency_item));\n+\ttable_function.external_dependency = std::move(dependency);\n+}\n+\n+static unique_ptr<TableRef> TryReplacementObject(const py::object &entry, const string &name,\n+                                                 ClientProperties &client_properties) {\n+\tauto table_function = make_uniq<TableFunctionRef>();\n+\tvector<unique_ptr<ParsedExpression>> children;\n+\tNumpyObjectType numpytype; // Identify the type of accepted numpy objects.\n+\tif (DuckDBPyConnection::IsPandasDataframe(entry)) {\n+\t\tif (PandasDataFrame::IsPyArrowBacked(entry)) {\n+\t\t\tauto table = PandasDataFrame::ToArrowTable(entry);\n+\t\t\tCreateArrowScan(name, table, *table_function, children, client_properties);\n+\t\t} else {\n+\t\t\tstring name = \"df_\" + StringUtil::GenerateRandomName();\n+\t\t\tauto new_df = PandasScanFunction::PandasReplaceCopiedNames(entry);\n+\t\t\tchildren.push_back(make_uniq<ConstantExpression>(Value::POINTER(CastPointerToValue(new_df.ptr()))));\n+\t\t\ttable_function->function = make_uniq<FunctionExpression>(\"pandas_scan\", std::move(children));\n+\t\t\tauto dependency = make_uniq<ExternalDependency>();\n+\t\t\tdependency->AddDependency(\"replacement_cache\", PythonDependencyItem::Create(entry));\n+\t\t\tdependency->AddDependency(\"copy\", PythonDependencyItem::Create(new_df));\n+\t\t\ttable_function->external_dependency = std::move(dependency);\n+\t\t}\n+\t} else if (DuckDBPyConnection::IsAcceptedArrowObject(entry)) {\n+\t\tCreateArrowScan(name, entry, *table_function, children, client_properties);\n+\t} else if (DuckDBPyRelation::IsRelation(entry)) {\n+\t\tauto pyrel = py::cast<DuckDBPyRelation *>(entry);\n+\t\t// create a subquery from the underlying relation object\n+\t\tauto select = make_uniq<SelectStatement>();\n+\t\tselect->node = pyrel->GetRel().GetQueryNode();\n+\t\tauto subquery = make_uniq<SubqueryRef>(std::move(select));\n+\t\tauto dependency = make_uniq<ExternalDependency>();\n+\t\tdependency->AddDependency(\"replacement_cache\", PythonDependencyItem::Create(entry));\n+\t\tsubquery->external_dependency = std::move(dependency);\n+\t\treturn std::move(subquery);\n+\t} else if (PolarsDataFrame::IsDataFrame(entry)) {\n+\t\tauto arrow_dataset = entry.attr(\"to_arrow\")();\n+\t\tCreateArrowScan(name, arrow_dataset, *table_function, children, client_properties);\n+\t} else if (PolarsDataFrame::IsLazyFrame(entry)) {\n+\t\tauto materialized = entry.attr(\"collect\")();\n+\t\tauto arrow_dataset = materialized.attr(\"to_arrow\")();\n+\t\tCreateArrowScan(name, arrow_dataset, *table_function, children, client_properties);\n+\t} else if ((numpytype = DuckDBPyConnection::IsAcceptedNumpyObject(entry)) != NumpyObjectType::INVALID) {\n+\t\tstring name = \"np_\" + StringUtil::GenerateRandomName();\n+\t\tpy::dict data; // we will convert all the supported format to dict{\"key\": np.array(value)}.\n+\t\tsize_t idx = 0;\n+\t\tswitch (numpytype) {\n+\t\tcase NumpyObjectType::NDARRAY1D:\n+\t\t\tdata[\"column0\"] = entry;\n+\t\t\tbreak;\n+\t\tcase NumpyObjectType::NDARRAY2D:\n+\t\t\tidx = 0;\n+\t\t\tfor (auto item : py::cast<py::array>(entry)) {\n+\t\t\t\tdata[(\"column\" + std::to_string(idx)).c_str()] = item;\n+\t\t\t\tidx++;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase NumpyObjectType::LIST:\n+\t\t\tidx = 0;\n+\t\t\tfor (auto item : py::cast<py::list>(entry)) {\n+\t\t\t\tdata[(\"column\" + std::to_string(idx)).c_str()] = item;\n+\t\t\t\tidx++;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase NumpyObjectType::DICT:\n+\t\t\tdata = py::cast<py::dict>(entry);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow NotImplementedException(\"Unsupported Numpy object\");\n+\t\t\tbreak;\n+\t\t}\n+\t\tchildren.push_back(make_uniq<ConstantExpression>(Value::POINTER(CastPointerToValue(data.ptr()))));\n+\t\ttable_function->function = make_uniq<FunctionExpression>(\"pandas_scan\", std::move(children));\n+\t\tauto dependency = make_uniq<ExternalDependency>();\n+\t\tdependency->AddDependency(\"replacement_cache\", PythonDependencyItem::Create(entry));\n+\t\tdependency->AddDependency(\"data\", PythonDependencyItem::Create(data));\n+\t\ttable_function->external_dependency = std::move(dependency);\n+\t} else {\n+\t\t// This throws an error later on!\n+\t\treturn nullptr;\n+\t}\n+\treturn std::move(table_function);\n+}\n+\n+static unique_ptr<TableRef> TryReplacement(py::dict &dict, const string &name, ClientProperties &client_properties,\n+                                           py::object &current_frame) {\n+\tauto table_name = py::str(name);\n+\tif (!dict.contains(table_name)) {\n+\t\t// not present in the globals\n+\t\treturn nullptr;\n+\t}\n+\tconst py::object &entry = dict[table_name];\n+\tauto result = TryReplacementObject(entry, name, client_properties);\n+\tif (!result) {\n+\t\tstd::string location = py::cast<py::str>(current_frame.attr(\"f_code\").attr(\"co_filename\"));\n+\t\tlocation += \":\";\n+\t\tlocation += py::cast<py::str>(current_frame.attr(\"f_lineno\"));\n+\t\tstd::string cpp_table_name = table_name;\n+\t\tauto py_object_type = string(py::str(entry.get_type().attr(\"__name__\")));\n+\n+\t\tthrow InvalidInputException(\n+\t\t    \"Python Object \\\"%s\\\" of type \\\"%s\\\" found on line \\\"%s\\\" not suitable for replacement scans.\\nMake sure \"\n+\t\t    \"that \\\"%s\\\" is either a pandas.DataFrame, duckdb.DuckDBPyRelation, pyarrow Table, Dataset, \"\n+\t\t    \"RecordBatchReader, Scanner, or NumPy ndarrays with supported format\",\n+\t\t    cpp_table_name, py_object_type, location, cpp_table_name);\n+\t}\n+\treturn result;\n+}\n+\n+static unique_ptr<TableRef> ReplaceInternal(ClientContext &context, const string &table_name) {\n+\tpy::gil_scoped_acquire acquire;\n+\t// Here we do an exhaustive search on the frame lineage\n+\tauto current_frame = py::module::import(\"inspect\").attr(\"currentframe\")();\n+\tauto client_properties = context.GetClientProperties();\n+\twhile (hasattr(current_frame, \"f_locals\")) {\n+\t\tauto local_dict = py::reinterpret_borrow<py::dict>(current_frame.attr(\"f_locals\"));\n+\t\t// search local dictionary\n+\t\tif (local_dict) {\n+\t\t\tauto result = TryReplacement(local_dict, table_name, client_properties, current_frame);\n+\t\t\tif (result) {\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t\t// search global dictionary\n+\t\tauto global_dict = py::reinterpret_borrow<py::dict>(current_frame.attr(\"f_globals\"));\n+\t\tif (global_dict) {\n+\t\t\tauto result = TryReplacement(global_dict, table_name, client_properties, current_frame);\n+\t\t\tif (result) {\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t\tcurrent_frame = current_frame.attr(\"f_back\");\n+\t}\n+\t// Not found :(\n+\treturn nullptr;\n+}\n+unique_ptr<TableRef> PythonReplacementScan::Replace(ClientContext &context, ReplacementScanInput &input,\n+                                                    optional_ptr<ReplacementScanData> data) {\n+\tauto &table_name = input.table_name;\n+\n+\tauto &table_ref = input.ref;\n+\tif (table_ref.external_dependency) {\n+\t\tauto dependency_item = table_ref.external_dependency->GetDependency(\"replacement_cache\");\n+\t\tif (dependency_item) {\n+\t\t\tpy::gil_scoped_acquire acquire;\n+\t\t\tauto &python_dependency = dependency_item->Cast<PythonDependencyItem>();\n+\t\t\tauto &registered_object = *python_dependency.object;\n+\t\t\tauto &py_object = registered_object.obj;\n+\t\t\tauto client_properties = context.GetClientProperties();\n+\t\t\tauto result = TryReplacementObject(py_object, table_name, client_properties);\n+\t\t\t// This was cached, so it was successful before, it should be successfull now\n+\t\t\tD_ASSERT(result);\n+\t\t\treturn std::move(result);\n+\t\t}\n+\t}\n+\n+\tunique_ptr<TableRef> result;\n+\tresult = ReplaceInternal(context, table_name);\n+\tif (!result) {\n+\t\treturn nullptr;\n+\t}\n+\tif (table_ref.external_dependency) {\n+\t\tD_ASSERT(result->external_dependency);\n+\n+\t\tD_ASSERT(result->external_dependency->GetDependency(\"replacement_cache\") != nullptr);\n+\t\tresult->external_dependency->ScanDependencies(\n+\t\t    [&table_ref](const string &name, shared_ptr<DependencyItem> item) {\n+\t\t\t    table_ref.external_dependency->AddDependency(name, std::move(item));\n+\t\t    });\n+\t}\n+\treturn result;\n+}\n+\n+} // namespace duckdb\ndiff --git a/tools/pythonpkg/src/python_udf.cpp b/tools/pythonpkg/src/python_udf.cpp\nindex d94bfeff37ab..b24bfb05c95b 100644\n--- a/tools/pythonpkg/src/python_udf.cpp\n+++ b/tools/pythonpkg/src/python_udf.cpp\n@@ -15,6 +15,7 @@\n #include \"duckdb_python/numpy/numpy_scan.hpp\"\n #include \"duckdb_python/arrow/arrow_export_utils.hpp\"\n #include \"duckdb/common/types/arrow_aux_data.hpp\"\n+#include \"duckdb/parser/tableref/table_function_ref.hpp\"\n \n namespace duckdb {\n \n@@ -65,10 +66,11 @@ static void ConvertPyArrowToDataChunk(const py::object &table, Vector &out, Clie\n \tvector<LogicalType> input_types;\n \tvector<string> input_names;\n \n+\tTableFunctionRef empty;\n \tTableFunction dummy_table_function;\n \tdummy_table_function.name = \"ConvertPyArrowToDataChunk\";\n \tTableFunctionBindInput bind_input(children, named_params, input_types, input_names, nullptr, nullptr,\n-\t                                  dummy_table_function);\n+\t                                  dummy_table_function, empty);\n \tvector<LogicalType> return_types;\n \tvector<string> return_names;\n \n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/arrow/test_5547.py b/tools/pythonpkg/tests/fast/arrow/test_5547.py\nindex 5a376ad7f57e..b27b29b24d50 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_5547.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_5547.py\n@@ -27,8 +27,7 @@ def test_5547():\n     expected = tbl.to_pandas()\n     result = con.execute(\n         \"\"\"\n-    SELECT *\n-    FROM tbl\n+\t\tSELECT * FROM tbl\n     \"\"\"\n     ).df()\n \ndiff --git a/tools/pythonpkg/tests/fast/arrow/test_arrow_recordbatchreader.py b/tools/pythonpkg/tests/fast/arrow/test_arrow_recordbatchreader.py\nindex 05325375a3b5..0f8a701dbfe4 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_arrow_recordbatchreader.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_arrow_recordbatchreader.py\n@@ -1,21 +1,15 @@\n import duckdb\n import os\n+import pytest\n \n-try:\n-    import pyarrow\n-    import pyarrow.parquet\n-    import pyarrow.dataset\n-    import numpy as np\n-\n-    can_run = True\n-except:\n-    can_run = False\n+pyarrow = pytest.importorskip(\"pyarrow\")\n+pyarrow.parquet = pytest.importorskip(\"pyarrow.parquet\")\n+pyarrow.dataset = pytest.importorskip(\"pyarrow.dataset\")\n+np = pytest.importorskip(\"numpy\")\n \n \n class TestArrowRecordBatchReader(object):\n     def test_parallel_reader(self, duckdb_cursor):\n-        if not can_run:\n-            return\n \n         duckdb_conn = duckdb.connect()\n         duckdb_conn.execute(\"PRAGMA threads=4\")\n@@ -45,8 +39,6 @@ def test_parallel_reader(self, duckdb_cursor):\n         )\n \n     def test_parallel_reader_replacement_scans(self, duckdb_cursor):\n-        if not can_run:\n-            return\n \n         duckdb_conn = duckdb.connect()\n         duckdb_conn.execute(\"PRAGMA threads=4\")\n@@ -67,20 +59,18 @@ def test_parallel_reader_replacement_scans(self, duckdb_cursor):\n \n         assert (\n             duckdb_conn.execute(\n-                \"select count(*) from reader where first_name=\\'Jose\\' and salary > 134708.82\"\n+                \"select count(*) r1 from reader where first_name=\\'Jose\\' and salary > 134708.82\"\n             ).fetchone()[0]\n             == 12\n         )\n         assert (\n             duckdb_conn.execute(\n-                \"select count(*) from reader where first_name=\\'Jose\\' and salary > 134708.82\"\n+                \"select count(*) r2 from reader where first_name=\\'Jose\\' and salary > 134708.82\"\n             ).fetchone()[0]\n             == 0\n         )\n \n     def test_parallel_reader_register(self, duckdb_cursor):\n-        if not can_run:\n-            return\n \n         duckdb_conn = duckdb.connect()\n         duckdb_conn.execute(\"PRAGMA threads=4\")\n@@ -115,8 +105,6 @@ def test_parallel_reader_register(self, duckdb_cursor):\n         )\n \n     def test_parallel_reader_default_conn(self, duckdb_cursor):\n-        if not can_run:\n-            return\n \n         parquet_filename = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data', 'userdata1.parquet')\n \ndiff --git a/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py b/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py\nindex 5fdbae2f9f64..0afcc9277e44 100644\n--- a/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py\n+++ b/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py\n@@ -123,7 +123,8 @@ def test_replacement_scan_recursion(self, duckdb_cursor):\n             # With the default we reach a stack overflow in the CI\n             depth_limit = 250\n         duckdb_cursor.execute(f\"SET max_expression_depth TO {depth_limit}\")\n-        rel = duckdb_cursor.sql('select 42')\n-        rel = duckdb_cursor.sql('select * from rel')\n-        with pytest.raises(duckdb.BinderException, match=f'Max expression depth limit of {depth_limit} exceeded'):\n-            duckdb_cursor.sql('select * from rel')\n+        rel = duckdb_cursor.sql('select 42 a, 21 b')\n+        rel = duckdb_cursor.sql('select a+a a, b+b b from rel')\n+        other_rel = duckdb_cursor.sql('select a from rel')\n+        res = other_rel.fetchall()\n+        assert res == [(84,)]\ndiff --git a/tools/pythonpkg/tests/fast/test_relation.py b/tools/pythonpkg/tests/fast/test_relation.py\nindex 5c2bda13637d..8272ee1374bf 100644\n--- a/tools/pythonpkg/tests/fast/test_relation.py\n+++ b/tools/pythonpkg/tests/fast/test_relation.py\n@@ -4,6 +4,7 @@\n import os\n import pandas as pd\n import pytest\n+from conftest import ArrowPandas, NumpyPandas\n import datetime\n from duckdb import ColumnExpression\n \n@@ -28,6 +29,25 @@ def test_csv_auto(self):\n         csv_rel = duckdb.from_csv_auto(temp_file_name)\n         assert df_rel.execute().fetchall() == csv_rel.execute().fetchall()\n \n+    @pytest.mark.parametrize('pandas', [NumpyPandas(), ArrowPandas()])\n+    def test_relation_view(self, duckdb_cursor, pandas):\n+        def create_view(duckdb_cursor):\n+            df_in = pandas.DataFrame({'numbers': [1, 2, 3, 4, 5]})\n+            rel = duckdb_cursor.query(\"select * from df_in\")\n+            rel.to_view(\"my_view\")\n+\n+        create_view(duckdb_cursor)\n+        with pytest.raises(duckdb.CatalogException, match=\"df_in does not exist\"):\n+            # The df_in object is no longer reachable\n+            rel1 = duckdb_cursor.query(\"select * from df_in\")\n+        # But it **is** reachable through our 'my_view' VIEW\n+        # Because a Relation was created that references the df_in, the 'df_in' TableRef was injected with an ExternalDependency on the dataframe object\n+        # We then created a VIEW from that Relation, which in turn copied this 'df_in' TableRef into the ViewCatalogEntry\n+        # Because of this, the df_in object will stay alive for as long as our 'my_view' entry exists.\n+        rel2 = duckdb_cursor.query(\"select * from my_view\")\n+        res = rel2.fetchall()\n+        assert res == [(1,), (2,), (3,), (4,), (5,)]\n+\n     def test_filter_operator(self):\n         conn = duckdb.connect()\n         rel = get_relation(conn)\n@@ -226,6 +246,36 @@ def test_df_proj(self):\n         rel = duckdb.project(test_df, 'i')\n         assert rel.execute().fetchall() == [(1,), (2,), (3,), (4,)]\n \n+    def test_relation_lifetime(self, duckdb_cursor):\n+        def create_relation(con):\n+            df = pd.DataFrame({'a': [1, 2, 3]})\n+            return con.sql(\"select * from df\")\n+\n+        assert create_relation(duckdb_cursor).fetchall() == [(1,), (2,), (3,)]\n+\n+        def create_simple_join(con):\n+            df1 = pd.DataFrame({'a': ['a', 'b', 'c'], 'b': [1, 2, 3]})\n+            df2 = pd.DataFrame({'a': ['a', 'b', 'c'], 'b': [4, 5, 6]})\n+\n+            return con.sql(\"select * from df1 JOIN df2 USING (a, a)\")\n+\n+        assert create_simple_join(duckdb_cursor).fetchall() == [('a', 1, 4), ('b', 2, 5), ('c', 3, 6)]\n+\n+        def create_complex_join(con):\n+            df1 = pd.DataFrame({'a': [1], '1': [1]})\n+            df2 = pd.DataFrame({'a': [1], '2': [2]})\n+            df3 = pd.DataFrame({'a': [1], '3': [3]})\n+            df4 = pd.DataFrame({'a': [1], '4': [4]})\n+            df5 = pd.DataFrame({'a': [1], '5': [5]})\n+            df6 = pd.DataFrame({'a': [1], '6': [6]})\n+            query = \"select * from df1\"\n+            for i in range(5):\n+                query += f\" JOIN df{i + 2} USING (a, a)\"\n+            return con.sql(query)\n+\n+        rel = create_complex_join(duckdb_cursor)\n+        assert rel.fetchall() == [(1, 1, 2, 3, 4, 5, 6)]\n+\n     def test_project_on_types(self):\n         con = duckdb.connect()\n         con.sql(\ndiff --git a/tools/pythonpkg/tests/fast/test_replacement_scan.py b/tools/pythonpkg/tests/fast/test_replacement_scan.py\nindex 2ebb7f7b52b6..87e6e519b7ab 100644\n--- a/tools/pythonpkg/tests/fast/test_replacement_scan.py\n+++ b/tools/pythonpkg/tests/fast/test_replacement_scan.py\n@@ -3,6 +3,7 @@\n import pytest\n \n pl = pytest.importorskip(\"polars\")\n+pd = pytest.importorskip(\"pandas\")\n \n \n def using_table(con, to_scan, object_name):\n@@ -102,6 +103,19 @@ def test_replacement_scan_pandas_alias(self):\n         df3 = con.query('from df1 join df2 using(i)')\n         assert df3.fetchall() == [(1, 2, 10)]\n \n+    def test_replacement_scan_caching(self, duckdb_cursor):\n+        def return_rel(conn):\n+            df = pd.DataFrame({'a': [1, 2, 3]})\n+            rel = conn.sql(\"select * from df\")\n+            return rel\n+\n+        rel = return_rel(duckdb_cursor)\n+        # FIXME: this test should fail in the future\n+        # The correct answer here is [1,2,3], as that is the 'df' that was visible during creation of the Relation\n+        duckdb_cursor.execute(\"create table df as select * from unnest([4,5,6])\")\n+        res = rel.fetchall()\n+        assert res == [(4,), (5,), (6,)]\n+\n     def test_replacement_scan_fail(self):\n         random_object = \"I love salmiak rondos\"\n         con = duckdb.connect()\ndiff --git a/tools/pythonpkg/tests/fast/test_runtime_error.py b/tools/pythonpkg/tests/fast/test_runtime_error.py\nindex 6c6fb459b4ab..9f1f5378c5e4 100644\n--- a/tools/pythonpkg/tests/fast/test_runtime_error.py\n+++ b/tools/pythonpkg/tests/fast/test_runtime_error.py\n@@ -58,7 +58,7 @@ def test_arrow_record_batch_reader_error(self):\n             res.fetch_arrow_reader(1)\n \n     @pytest.mark.parametrize('pandas', [NumpyPandas(), ArrowPandas()])\n-    def test_relation_fetchall_error(self, pandas):\n+    def test_relation_cache_fetchall(self, pandas):\n         conn = duckdb.connect()\n         df_in = pandas.DataFrame(\n             {\n@@ -69,10 +69,13 @@ def test_relation_fetchall_error(self, pandas):\n         rel = conn.query(\"select * from x\")\n         del df_in\n         with pytest.raises(duckdb.ProgrammingError, match='Table with name df_in does not exist'):\n+            # Even when we preserve ExternalDependency objects correctly, this is not supported\n+            # Relations only save dependencies for their immediate TableRefs,\n+            # so the dependency of 'x' on 'df_in' is not registered in 'rel'\n             rel.fetchall()\n \n     @pytest.mark.parametrize('pandas', [NumpyPandas(), ArrowPandas()])\n-    def test_relation_fetchall_execute(self, pandas):\n+    def test_relation_cache_execute(self, pandas):\n         conn = duckdb.connect()\n         df_in = pandas.DataFrame(\n             {\n",
  "problem_statement": "Incorrect/inconsistent replacement scans behavior\n### What happens?\r\n\r\nThe replacement scans do not work properly once the relation object is passed to function. \r\n\r\n```python\r\ndef build_rel_upon_rel(conn: duckdb.DuckDBPyConnection, rel: duckdb.DuckDBPyRelation):\r\n    return conn.sql(\"select * from rel\")\r\n\r\ndb = duckdb.connect()\r\nrel_fetch_schema = db.sql(\"select * from information_schema.schemata\")\r\nnew_rel = build_rel_upon_rel(rel_fetch_schema)\r\n```\r\n\r\nThis won't work unless the `rel` variable is explicitly defined **OUTSIDE** the function call. That is:\r\n\r\n```python\r\n\r\nrel_fetch_schema = db.sql(\"select * from information_schema.schemata\")\r\nrel = rel_fetch_schema\r\nnew_rel = build_rel_upon_rel(rel_fetch_schema) \r\n# You didn't see wrong, not even rel itself, now passing the rel_fetch_schema also works!\r\n```\r\n\r\n### To Reproduce\r\n\r\n```python\r\nimport duckdb\r\n\r\n\r\ndef build_rel_on_rel_unamed(conn: duckdb.DuckDBPyConnection, rel: duckdb.DuckDBPyRelation):\r\n    return conn.sql(\"select * from rel\")\r\n\r\n\r\ndef build_rel_on_rel_named(conn: duckdb.DuckDBPyConnection, rel: duckdb.DuckDBPyRelation = None):\r\n    return conn.sql(\"select * from rel\")\r\n\r\n\r\ndef invocation_1(db: duckdb.DuckDBPyConnection, ):\r\n    schemas = db.sql(\"select * from information_schema.schemata\")\r\n    try:\r\n        result = build_rel_on_rel_unamed(db, schemas).fetchall()\r\n    except Exception as e:\r\n        print(f\"\\n\\nError occurred with invocation_1: {e}\")\r\n        return None\r\n\r\n    print(f\"Succeeded with invocation_1\")\r\n    return result\r\n\r\n\r\ndef invocation_2(db: duckdb.DuckDBPyConnection, ):\r\n    schemas = db.sql(\"select * from information_schema.schemata\")\r\n    other_name = schemas\r\n    try:\r\n        result = build_rel_on_rel_unamed(db, other_name).fetchall()\r\n    except Exception as e:\r\n        print(f\"\\n\\nError occurred with invocation_2: {e}\")\r\n        return None\r\n\r\n    print(f\"Succeeded with invocation_2\")\r\n    return result\r\n\r\n\r\ndef invocation_3(db: duckdb.DuckDBPyConnection, ):\r\n    schemas = db.sql(\"select * from information_schema.schemata\")\r\n    rel = schemas\r\n    try:\r\n        result = build_rel_on_rel_unamed(db, schemas).fetchall()\r\n    except Exception as e:\r\n        print(f\"\\n\\nError occurred with invocation_3: {e}\")\r\n        return None\r\n\r\n    print(f\"Succeeded with invocation_3\")\r\n    return result\r\n\r\n\r\ndef test_1_2_3():\r\n    db = duckdb.connect()\r\n    assert invocation_1(db) is None\r\n    assert invocation_2(db) is None\r\n    assert invocation_3(db) is not None\r\n    db.close()\r\n\r\n\r\ndef test_2_1_3():\r\n    db = duckdb.connect()\r\n    assert invocation_2(db) is None\r\n    assert invocation_1(db) is None\r\n    assert invocation_3(db) is not None\r\n    db.close()\r\n\r\n\r\ndef test_3_2_1():\r\n    db = duckdb.connect()\r\n    assert invocation_3(db) is not None\r\n    assert invocation_2(db) is None\r\n    assert invocation_1(db) is None\r\n    db.close()\r\n\r\n\r\ndef test_3_1_2():\r\n    db = duckdb.connect()\r\n    assert invocation_3(db) is not None\r\n    assert invocation_1(db) is None\r\n    assert invocation_2(db) is None\r\n    db.close()\r\n\r\n\r\ndef invocation_4(db: duckdb.DuckDBPyConnection, ):\r\n    schemas = db.sql(\"select * from information_schema.schemata\")\r\n    try:\r\n        result = build_rel_on_rel_named(db, rel=schemas).fetchall()\r\n    except Exception as e:\r\n        print(f\"\\n\\nError occurred with invocation_4: {e}\")\r\n        return None\r\n\r\n    print(f\"Succeeded with invocation_4\")\r\n    return result\r\n\r\n\r\ndef invocation_5(db: duckdb.DuckDBPyConnection, ):\r\n    schemas = db.sql(\"select * from information_schema.schemata\")\r\n    other_name = schemas\r\n    try:\r\n        result = build_rel_on_rel_unamed(db, rel=other_name).fetchall()\r\n    except Exception as e:\r\n        print(f\"\\n\\nError occurred with invocation_5: {e}\")\r\n        return None\r\n\r\n    print(f\"Succeeded with invocation_5\")\r\n    return result\r\n\r\n\r\ndef invocation_6(db: duckdb.DuckDBPyConnection, ):\r\n    schemas = db.sql(\"select * from information_schema.schemata\")\r\n    rel = schemas\r\n    try:\r\n        result = build_rel_on_rel_unamed(db, rel=schemas).fetchall()\r\n    except Exception as e:\r\n        print(f\"\\n\\nError occurred with invocation_6: {e}\")\r\n        return None\r\n\r\n    print(f\"Succeeded with invocation_6\")\r\n    return result\r\n\r\n\r\ndef test_4_5_6():\r\n    db = duckdb.connect()\r\n    assert invocation_4(db) is None\r\n    assert invocation_5(db) is None\r\n    assert invocation_6(db) is not None\r\n    db.close()\r\n\r\n\r\ndef test_6_5_4():\r\n    db = duckdb.connect()\r\n    assert invocation_6(db) is not None\r\n    assert invocation_5(db) is None\r\n    assert invocation_4(db) is None\r\n    db.close()\r\n\r\n\r\ndef test_5_4_6():\r\n    db = duckdb.connect()\r\n    assert invocation_5(db) is None\r\n    assert invocation_4(db) is None\r\n    assert invocation_6(db) is not None\r\n    db.close()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    test_1_2_3()\r\n    test_3_2_1()\r\n    test_2_1_3()\r\n    test_3_1_2()\r\n\r\n    test_4_5_6()\r\n    test_6_5_4()\r\n    test_5_4_6()\r\n```\r\n\r\n### OS:\r\n\r\nmacOS 13.5.2 (22G91)\r\n\r\n### DuckDB Version:\r\n\r\n0.10.1\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nHank Zhong\r\n\r\n### Affiliation:\r\n\r\nwww.shanshu.ai\r\n\r\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\r\n\r\nI have tested with a release build (and could not test with a nightly build)\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Related to #11224, being worked on \ud83d\udc4d \r\n\r\nTo explain it a bit further, we create ExternalDependency objects that are used to hold ownership over the objects we rely on, currently those are not persisted between creation and execution.\r\nOn execution we would do the same look up again, but that can fail if the object has already died.\r\n\r\nThe fix is to persist these dependencies between creation and execution",
  "created_at": "2024-04-22T11:43:19Z"
}