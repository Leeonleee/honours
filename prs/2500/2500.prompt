You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Incorrect Struct Sorting Order on Ties
```sql
CREATE TABLE list_str AS
SELECT * FROM (VALUES
	({'x': 'duck', 'y': ''}),
	({'x': 'duck', 'y': 'goose'})
) tbl(i);
SELECT lhs.i, rhs.i
FROM list_str lhs, list_str rhs
ORDER BY lhs.i, rhs.i;
┌─────────────────────────┬─────────────────────────┐
│            i            │            i            │
├─────────────────────────┼─────────────────────────┤
│ {'x': duck, 'y': goose} │ {'x': duck, 'y': }      │
│ {'x': duck, 'y': goose} │ {'x': duck, 'y': goose} │
│ {'x': duck, 'y': }      │ {'x': duck, 'y': }      │
│ {'x': duck, 'y': }      │ {'x': duck, 'y': goose} │
└─────────────────────────┴─────────────────────────┘
```

Without the `'x': 'duck'` the rows are sorted in the correct order:

```sql
CREATE TABLE list_str AS
SELECT * FROM (VALUES
	({'y': ''}),
	({'y': 'goose'})
) tbl(i);
SELECT lhs.i, rhs.i
FROM list_str lhs, list_str rhs
ORDER BY lhs.i, rhs.i;
┌──────────────┬──────────────┐
│      i       │      i       │
├──────────────┼──────────────┤
│ {'y': }      │ {'y': }      │
│ {'y': }      │ {'y': goose} │
│ {'y': goose} │ {'y': }      │
│ {'y': goose} │ {'y': goose} │
└──────────────┴──────────────┘
```


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/common/sort/comparators.cpp]
1: #include "duckdb/common/sort/comparators.hpp"
2: 
3: #include "duckdb/common/sort/sort.hpp"
4: 
5: namespace duckdb {
6: 
7: bool Comparators::TieIsBreakable(const idx_t &col_idx, const data_ptr_t row_ptr, const RowLayout &row_layout) {
8: 	// Check if the blob is NULL
9: 	ValidityBytes row_mask(row_ptr);
10: 	idx_t entry_idx;
11: 	idx_t idx_in_entry;
12: 	ValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry);
13: 	if (!row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {
14: 		// Can't break a NULL tie
15: 		return false;
16: 	}
17: 	if (row_layout.GetTypes()[col_idx].InternalType() == PhysicalType::VARCHAR) {
18: 		const auto &tie_col_offset = row_layout.GetOffsets()[col_idx];
19: 		string_t tie_string = Load<string_t>(row_ptr + tie_col_offset);
20: 		if (tie_string.GetSize() < string_t::INLINE_LENGTH) {
21: 			// No need to break the tie - we already compared the full string
22: 			return false;
23: 		}
24: 	}
25: 	return true;
26: }
27: 
28: int Comparators::CompareTuple(const SortedBlock &left, const SortedBlock &right, const data_ptr_t &l_ptr,
29:                               const data_ptr_t &r_ptr, const SortLayout &sort_layout, const bool &external_sort) {
30: 	// Compare the sorting columns one by one
31: 	int comp_res = 0;
32: 	data_ptr_t l_ptr_offset = l_ptr;
33: 	data_ptr_t r_ptr_offset = r_ptr;
34: 	for (idx_t col_idx = 0; col_idx < sort_layout.column_count; col_idx++) {
35: 		comp_res = memcmp(l_ptr_offset, r_ptr_offset, sort_layout.column_sizes[col_idx]);
36: 		if (comp_res == 0 && !sort_layout.constant_size[col_idx]) {
37: 			comp_res =
38: 			    BreakBlobTie(col_idx, *left.blob_sorting_data, *right.blob_sorting_data, sort_layout, external_sort);
39: 		}
40: 		if (comp_res != 0) {
41: 			break;
42: 		}
43: 		l_ptr_offset += sort_layout.column_sizes[col_idx];
44: 		r_ptr_offset += sort_layout.column_sizes[col_idx];
45: 	}
46: 	return comp_res;
47: }
48: 
49: int Comparators::CompareVal(const data_ptr_t l_ptr, const data_ptr_t r_ptr, const LogicalType &type) {
50: 	switch (type.InternalType()) {
51: 	case PhysicalType::VARCHAR:
52: 		return TemplatedCompareVal<string_t>(l_ptr, r_ptr);
53: 	case PhysicalType::LIST:
54: 	case PhysicalType::STRUCT: {
55: 		auto l_nested_ptr = Load<data_ptr_t>(l_ptr);
56: 		auto r_nested_ptr = Load<data_ptr_t>(r_ptr);
57: 		return CompareValAndAdvance(l_nested_ptr, r_nested_ptr, type);
58: 	}
59: 	default:
60: 		throw NotImplementedException("Unimplemented CompareVal for type %s", type.ToString());
61: 	}
62: }
63: 
64: int Comparators::BreakBlobTie(const idx_t &tie_col, const SortedData &left, const SortedData &right,
65:                               const SortLayout &sort_layout, const bool &external) {
66: 	const idx_t &col_idx = sort_layout.sorting_to_blob_col.at(tie_col);
67: 	data_ptr_t l_data_ptr = left.DataPtr();
68: 	data_ptr_t r_data_ptr = right.DataPtr();
69: 	if (!TieIsBreakable(col_idx, l_data_ptr, sort_layout.blob_layout)) {
70: 		// Quick check to see if ties can be broken
71: 		return 0;
72: 	}
73: 	// Align the pointers
74: 	const auto &tie_col_offset = sort_layout.blob_layout.GetOffsets()[col_idx];
75: 	l_data_ptr += tie_col_offset;
76: 	r_data_ptr += tie_col_offset;
77: 	// Do the comparison
78: 	const int order = sort_layout.order_types[tie_col] == OrderType::DESCENDING ? -1 : 1;
79: 	const auto &type = left.layout.GetTypes()[col_idx];
80: 	int result;
81: 	if (external) {
82: 		// Store heap pointers
83: 		data_ptr_t l_heap_ptr = left.HeapPtr();
84: 		data_ptr_t r_heap_ptr = right.HeapPtr();
85: 		// Unswizzle offset to pointer
86: 		UnswizzleSingleValue(l_data_ptr, l_heap_ptr, type);
87: 		UnswizzleSingleValue(r_data_ptr, r_heap_ptr, type);
88: 		// Compare
89: 		result = CompareVal(l_data_ptr, r_data_ptr, type);
90: 		// Swizzle the pointers back to offsets
91: 		SwizzleSingleValue(l_data_ptr, l_heap_ptr, type);
92: 		SwizzleSingleValue(r_data_ptr, r_heap_ptr, type);
93: 	} else {
94: 		result = CompareVal(l_data_ptr, r_data_ptr, type);
95: 	}
96: 	return order * result;
97: }
98: 
99: template <class T>
100: int Comparators::TemplatedCompareVal(const data_ptr_t &left_ptr, const data_ptr_t &right_ptr) {
101: 	const auto left_val = Load<T>(left_ptr);
102: 	const auto right_val = Load<T>(right_ptr);
103: 	if (Equals::Operation<T>(left_val, right_val)) {
104: 		return 0;
105: 	} else if (LessThan::Operation<T>(left_val, right_val)) {
106: 		return -1;
107: 	} else {
108: 		return 1;
109: 	}
110: }
111: 
112: int Comparators::CompareValAndAdvance(data_ptr_t &l_ptr, data_ptr_t &r_ptr, const LogicalType &type) {
113: 	switch (type.InternalType()) {
114: 	case PhysicalType::BOOL:
115: 	case PhysicalType::INT8:
116: 		return TemplatedCompareAndAdvance<int8_t>(l_ptr, r_ptr);
117: 	case PhysicalType::INT16:
118: 		return TemplatedCompareAndAdvance<int16_t>(l_ptr, r_ptr);
119: 	case PhysicalType::INT32:
120: 		return TemplatedCompareAndAdvance<int32_t>(l_ptr, r_ptr);
121: 	case PhysicalType::INT64:
122: 		return TemplatedCompareAndAdvance<int64_t>(l_ptr, r_ptr);
123: 	case PhysicalType::UINT8:
124: 		return TemplatedCompareAndAdvance<uint8_t>(l_ptr, r_ptr);
125: 	case PhysicalType::UINT16:
126: 		return TemplatedCompareAndAdvance<uint16_t>(l_ptr, r_ptr);
127: 	case PhysicalType::UINT32:
128: 		return TemplatedCompareAndAdvance<uint32_t>(l_ptr, r_ptr);
129: 	case PhysicalType::UINT64:
130: 		return TemplatedCompareAndAdvance<uint64_t>(l_ptr, r_ptr);
131: 	case PhysicalType::INT128:
132: 		return TemplatedCompareAndAdvance<hugeint_t>(l_ptr, r_ptr);
133: 	case PhysicalType::FLOAT:
134: 		return TemplatedCompareAndAdvance<float>(l_ptr, r_ptr);
135: 	case PhysicalType::DOUBLE:
136: 		return TemplatedCompareAndAdvance<double>(l_ptr, r_ptr);
137: 	case PhysicalType::INTERVAL:
138: 		return TemplatedCompareAndAdvance<interval_t>(l_ptr, r_ptr);
139: 	case PhysicalType::VARCHAR:
140: 		return CompareStringAndAdvance(l_ptr, r_ptr);
141: 	case PhysicalType::LIST:
142: 		return CompareListAndAdvance(l_ptr, r_ptr, ListType::GetChildType(type));
143: 	case PhysicalType::STRUCT:
144: 		return CompareStructAndAdvance(l_ptr, r_ptr, StructType::GetChildTypes(type));
145: 	default:
146: 		throw NotImplementedException("Unimplemented CompareValAndAdvance for type %s", type.ToString());
147: 	}
148: }
149: 
150: template <class T>
151: int Comparators::TemplatedCompareAndAdvance(data_ptr_t &left_ptr, data_ptr_t &right_ptr) {
152: 	auto result = TemplatedCompareVal<T>(left_ptr, right_ptr);
153: 	left_ptr += sizeof(T);
154: 	right_ptr += sizeof(T);
155: 	return result;
156: }
157: 
158: int Comparators::CompareStringAndAdvance(data_ptr_t &left_ptr, data_ptr_t &right_ptr) {
159: 	// Construct the string_t
160: 	uint32_t left_string_size = Load<uint32_t>(left_ptr);
161: 	uint32_t right_string_size = Load<uint32_t>(right_ptr);
162: 	left_ptr += sizeof(uint32_t);
163: 	right_ptr += sizeof(uint32_t);
164: 	string_t left_val((const char *)left_ptr, left_string_size);
165: 	string_t right_val((const char *)right_ptr, left_string_size);
166: 	left_ptr += left_string_size;
167: 	right_ptr += right_string_size;
168: 	// Compare
169: 	return TemplatedCompareVal<string_t>((data_ptr_t)&left_val, (data_ptr_t)&right_val);
170: }
171: 
172: int Comparators::CompareStructAndAdvance(data_ptr_t &left_ptr, data_ptr_t &right_ptr,
173:                                          const child_list_t<LogicalType> &types) {
174: 	idx_t count = types.size();
175: 	// Load validity masks
176: 	ValidityBytes left_validity(left_ptr);
177: 	ValidityBytes right_validity(right_ptr);
178: 	left_ptr += (count + 7) / 8;
179: 	right_ptr += (count + 7) / 8;
180: 	// Initialize variables
181: 	bool left_valid;
182: 	bool right_valid;
183: 	idx_t entry_idx;
184: 	idx_t idx_in_entry;
185: 	// Compare
186: 	int comp_res = 0;
187: 	for (idx_t i = 0; i < count; i++) {
188: 		ValidityBytes::GetEntryIndex(i, entry_idx, idx_in_entry);
189: 		left_valid = left_validity.RowIsValid(left_validity.GetValidityEntry(entry_idx), idx_in_entry);
190: 		right_valid = right_validity.RowIsValid(right_validity.GetValidityEntry(entry_idx), idx_in_entry);
191: 		auto &type = types[i].second;
192: 		if ((left_valid && right_valid) || TypeIsConstantSize(type.InternalType())) {
193: 			comp_res = CompareValAndAdvance(left_ptr, right_ptr, types[i].second);
194: 		}
195: 		if (!left_valid && !right_valid) {
196: 			comp_res = 0;
197: 		} else if (!left_valid) {
198: 			comp_res = 1;
199: 		} else if (!right_valid) {
200: 			comp_res = -1;
201: 		}
202: 		if (comp_res != 0) {
203: 			break;
204: 		}
205: 	}
206: 	return comp_res;
207: }
208: 
209: int Comparators::CompareListAndAdvance(data_ptr_t &left_ptr, data_ptr_t &right_ptr, const LogicalType &type) {
210: 	// Load list lengths
211: 	auto left_len = Load<idx_t>(left_ptr);
212: 	auto right_len = Load<idx_t>(right_ptr);
213: 	left_ptr += sizeof(idx_t);
214: 	right_ptr += sizeof(idx_t);
215: 	// Load list validity masks
216: 	ValidityBytes left_validity(left_ptr);
217: 	ValidityBytes right_validity(right_ptr);
218: 	left_ptr += (left_len + 7) / 8;
219: 	right_ptr += (right_len + 7) / 8;
220: 	// Compare
221: 	int comp_res = 0;
222: 	idx_t count = MinValue(left_len, right_len);
223: 	if (TypeIsConstantSize(type.InternalType())) {
224: 		// Templated code for fixed-size types
225: 		switch (type.InternalType()) {
226: 		case PhysicalType::BOOL:
227: 		case PhysicalType::INT8:
228: 			comp_res = TemplatedCompareListLoop<int8_t>(left_ptr, right_ptr, left_validity, right_validity, count);
229: 			break;
230: 		case PhysicalType::INT16:
231: 			comp_res = TemplatedCompareListLoop<int16_t>(left_ptr, right_ptr, left_validity, right_validity, count);
232: 			break;
233: 		case PhysicalType::INT32:
234: 			comp_res = TemplatedCompareListLoop<int32_t>(left_ptr, right_ptr, left_validity, right_validity, count);
235: 			break;
236: 		case PhysicalType::INT64:
237: 			comp_res = TemplatedCompareListLoop<int64_t>(left_ptr, right_ptr, left_validity, right_validity, count);
238: 			break;
239: 		case PhysicalType::UINT8:
240: 			comp_res = TemplatedCompareListLoop<uint8_t>(left_ptr, right_ptr, left_validity, right_validity, count);
241: 			break;
242: 		case PhysicalType::UINT16:
243: 			comp_res = TemplatedCompareListLoop<uint16_t>(left_ptr, right_ptr, left_validity, right_validity, count);
244: 			break;
245: 		case PhysicalType::UINT32:
246: 			comp_res = TemplatedCompareListLoop<uint32_t>(left_ptr, right_ptr, left_validity, right_validity, count);
247: 			break;
248: 		case PhysicalType::UINT64:
249: 			comp_res = TemplatedCompareListLoop<uint64_t>(left_ptr, right_ptr, left_validity, right_validity, count);
250: 			break;
251: 		case PhysicalType::INT128:
252: 			comp_res = TemplatedCompareListLoop<hugeint_t>(left_ptr, right_ptr, left_validity, right_validity, count);
253: 			break;
254: 		case PhysicalType::FLOAT:
255: 			comp_res = TemplatedCompareListLoop<float>(left_ptr, right_ptr, left_validity, right_validity, count);
256: 			break;
257: 		case PhysicalType::DOUBLE:
258: 			comp_res = TemplatedCompareListLoop<double>(left_ptr, right_ptr, left_validity, right_validity, count);
259: 			break;
260: 		case PhysicalType::INTERVAL:
261: 			comp_res = TemplatedCompareListLoop<interval_t>(left_ptr, right_ptr, left_validity, right_validity, count);
262: 			break;
263: 		default:
264: 			throw NotImplementedException("CompareListAndAdvance for fixed-size type %s", type.ToString());
265: 		}
266: 	} else {
267: 		// Variable-sized list entries
268: 		bool left_valid;
269: 		bool right_valid;
270: 		idx_t entry_idx;
271: 		idx_t idx_in_entry;
272: 		// Size (in bytes) of all variable-sizes entries is stored before the entries begin,
273: 		// to make deserialization easier. We need to skip over them
274: 		left_ptr += left_len * sizeof(idx_t);
275: 		right_ptr += right_len * sizeof(idx_t);
276: 		for (idx_t i = 0; i < count; i++) {
277: 			ValidityBytes::GetEntryIndex(i, entry_idx, idx_in_entry);
278: 			left_valid = left_validity.RowIsValid(left_validity.GetValidityEntry(entry_idx), idx_in_entry);
279: 			right_valid = right_validity.RowIsValid(right_validity.GetValidityEntry(entry_idx), idx_in_entry);
280: 			if (left_valid && right_valid) {
281: 				switch (type.InternalType()) {
282: 				case PhysicalType::LIST:
283: 					comp_res = CompareListAndAdvance(left_ptr, right_ptr, ListType::GetChildType(type));
284: 					break;
285: 				case PhysicalType::VARCHAR:
286: 					comp_res = CompareStringAndAdvance(left_ptr, right_ptr);
287: 					break;
288: 				case PhysicalType::STRUCT:
289: 					comp_res = CompareStructAndAdvance(left_ptr, right_ptr, StructType::GetChildTypes(type));
290: 					break;
291: 				default:
292: 					throw NotImplementedException("CompareListAndAdvance for variable-size type %s", type.ToString());
293: 				}
294: 			} else if (!left_valid && !right_valid) {
295: 				comp_res = 0;
296: 			} else if (left_valid) {
297: 				comp_res = -1;
298: 			} else {
299: 				comp_res = 1;
300: 			}
301: 			if (comp_res != 0) {
302: 				break;
303: 			}
304: 		}
305: 	}
306: 	// All values that we looped over were equal
307: 	if (comp_res == 0 && left_len != right_len) {
308: 		// Smaller lists first
309: 		if (left_len < right_len) {
310: 			comp_res = -1;
311: 		} else {
312: 			comp_res = 1;
313: 		}
314: 	}
315: 	return comp_res;
316: }
317: 
318: template <class T>
319: int Comparators::TemplatedCompareListLoop(data_ptr_t &left_ptr, data_ptr_t &right_ptr,
320:                                           const ValidityBytes &left_validity, const ValidityBytes &right_validity,
321:                                           const idx_t &count) {
322: 	int comp_res = 0;
323: 	bool left_valid;
324: 	bool right_valid;
325: 	idx_t entry_idx;
326: 	idx_t idx_in_entry;
327: 	for (idx_t i = 0; i < count; i++) {
328: 		ValidityBytes::GetEntryIndex(i, entry_idx, idx_in_entry);
329: 		left_valid = left_validity.RowIsValid(left_validity.GetValidityEntry(entry_idx), idx_in_entry);
330: 		right_valid = right_validity.RowIsValid(right_validity.GetValidityEntry(entry_idx), idx_in_entry);
331: 		comp_res = TemplatedCompareAndAdvance<T>(left_ptr, right_ptr);
332: 		if (!left_valid && !right_valid) {
333: 			comp_res = 0;
334: 		} else if (!left_valid) {
335: 			comp_res = 1;
336: 		} else if (!right_valid) {
337: 			comp_res = -1;
338: 		}
339: 		if (comp_res != 0) {
340: 			break;
341: 		}
342: 	}
343: 	return comp_res;
344: }
345: 
346: void Comparators::UnswizzleSingleValue(data_ptr_t data_ptr, const data_ptr_t &heap_ptr, const LogicalType &type) {
347: 	if (type.InternalType() == PhysicalType::VARCHAR) {
348: 		data_ptr += sizeof(uint32_t) + string_t::PREFIX_LENGTH;
349: 	}
350: 	Store<data_ptr_t>(heap_ptr + Load<idx_t>(data_ptr), data_ptr);
351: }
352: 
353: void Comparators::SwizzleSingleValue(data_ptr_t data_ptr, const data_ptr_t &heap_ptr, const LogicalType &type) {
354: 	if (type.InternalType() == PhysicalType::VARCHAR) {
355: 		data_ptr += sizeof(uint32_t) + string_t::PREFIX_LENGTH;
356: 	}
357: 	Store<idx_t>(Load<data_ptr_t>(data_ptr) - heap_ptr, data_ptr);
358: }
359: 
360: } // namespace duckdb
[end of src/common/sort/comparators.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: