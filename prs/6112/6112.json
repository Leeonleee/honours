{
  "repo": "duckdb/duckdb",
  "pull_number": 6112,
  "instance_id": "duckdb__duckdb-6112",
  "issue_numbers": [
    "6092",
    "6092"
  ],
  "base_commit": "01a87dafc6d04bbd2186c9788955b7a9729a4913",
  "patch": "diff --git a/src/parser/transform/statement/transform_show.cpp b/src/parser/transform/statement/transform_show.cpp\nindex 37f55bca6615..ddfca881519d 100644\n--- a/src/parser/transform/statement/transform_show.cpp\n+++ b/src/parser/transform/statement/transform_show.cpp\n@@ -9,13 +9,14 @@ namespace duckdb {\n \n static void TransformShowName(unique_ptr<PragmaStatement> &result, const string &name) {\n \tauto &info = *result->info;\n+\tauto lname = StringUtil::Lower(name);\n \n-\tif (StringUtil::Lower(name) == \"\\\"databases\\\"\") {\n+\tif (lname == \"\\\"databases\\\"\") {\n \t\tinfo.name = \"show_databases\";\n-\t} else if (name == \"\\\"tables\\\"\") {\n+\t} else if (lname == \"\\\"tables\\\"\") {\n \t\t// show all tables\n \t\tinfo.name = \"show_tables\";\n-\t} else if (name == \"__show_tables_expanded\") {\n+\t} else if (lname == \"__show_tables_expanded\") {\n \t\tinfo.name = \"show_tables_expanded\";\n \t} else {\n \t\t// show one specific table\ndiff --git a/third_party/libpg_query/scan.l b/third_party/libpg_query/scan.l\nindex 063109a7469e..1402e5de2156 100644\n--- a/third_party/libpg_query/scan.l\n+++ b/third_party/libpg_query/scan.l\n@@ -1057,7 +1057,7 @@ other\t\t\t.\n \t\t\t\t\t\tif (keyword_text[yyleng - 1] == '\\0') {\n \t\t\t\t\t\t\tyyless(yyleng - 1);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tyylval->keyword = keyword->name;\n+\t\t\t\t\t\tyylval->keyword = keyword_text;\n \t\t\t\t\t\treturn keyword->value;\n \t\t\t\t\t}\n \ndiff --git a/third_party/libpg_query/src_backend_parser_gram.cpp b/third_party/libpg_query/src_backend_parser_gram.cpp\nindex 6af304995ea1..d008de16ecdb 100644\n--- a/third_party/libpg_query/src_backend_parser_gram.cpp\n+++ b/third_party/libpg_query/src_backend_parser_gram.cpp\n@@ -17414,8 +17414,7 @@ YYLTYPE yylloc;\n \n   yystate = 0;\n   yyerrstatus = 0;\n-  yynerrs = 0;\n-  (void)yynerrs;\n+  yynerrs = 0; (void)yynerrs;\n   yychar = YYEMPTY;\t\t/* Cause a token to be read.  */\n \n   /* Initialize stack pointers.\ndiff --git a/third_party/libpg_query/src_backend_parser_scan.cpp b/third_party/libpg_query/src_backend_parser_scan.cpp\nindex 0b0c829ed939..83394737c6dc 100644\n--- a/third_party/libpg_query/src_backend_parser_scan.cpp\n+++ b/third_party/libpg_query/src_backend_parser_scan.cpp\n@@ -1,5 +1,4 @@\n-#line 2 \"third_party/libpg_query/src_backend_parser_scan.cpp\"\n-#line 2 \"third_party/libpg_query/scan.l\"\n+#line 1 \"third_party/libpg_query/src_backend_parser_scan.cpp\"\n /*-------------------------------------------------------------------------\n  *\n  * scan.l\n@@ -41,10 +40,7 @@\n \n #include <stdexcept>\n \n-\n-\n-\n-#line 48 \"third_party/libpg_query/src_backend_parser_scan.cpp\"\n+#line 43 \"third_party/libpg_query/src_backend_parser_scan.cpp\"\n \n #define  YY_INT_ALIGNED short int\n \n@@ -52,12 +48,246 @@\n \n #define FLEX_SCANNER\n #define YY_FLEX_MAJOR_VERSION 2\n-#define YY_FLEX_MINOR_VERSION 5\n-#define YY_FLEX_SUBMINOR_VERSION 35\n+#define YY_FLEX_MINOR_VERSION 6\n+#define YY_FLEX_SUBMINOR_VERSION 4\n #if YY_FLEX_SUBMINOR_VERSION > 0\n #define FLEX_BETA\n #endif\n \n+#ifdef yy_create_buffer\n+#define core_yy_create_buffer_ALREADY_DEFINED\n+#else\n+#define yy_create_buffer core_yy_create_buffer\n+#endif\n+\n+#ifdef yy_delete_buffer\n+#define core_yy_delete_buffer_ALREADY_DEFINED\n+#else\n+#define yy_delete_buffer core_yy_delete_buffer\n+#endif\n+\n+#ifdef yy_scan_buffer\n+#define core_yy_scan_buffer_ALREADY_DEFINED\n+#else\n+#define yy_scan_buffer core_yy_scan_buffer\n+#endif\n+\n+#ifdef yy_scan_string\n+#define core_yy_scan_string_ALREADY_DEFINED\n+#else\n+#define yy_scan_string core_yy_scan_string\n+#endif\n+\n+#ifdef yy_scan_bytes\n+#define core_yy_scan_bytes_ALREADY_DEFINED\n+#else\n+#define yy_scan_bytes core_yy_scan_bytes\n+#endif\n+\n+#ifdef yy_init_buffer\n+#define core_yy_init_buffer_ALREADY_DEFINED\n+#else\n+#define yy_init_buffer core_yy_init_buffer\n+#endif\n+\n+#ifdef yy_flush_buffer\n+#define core_yy_flush_buffer_ALREADY_DEFINED\n+#else\n+#define yy_flush_buffer core_yy_flush_buffer\n+#endif\n+\n+#ifdef yy_load_buffer_state\n+#define core_yy_load_buffer_state_ALREADY_DEFINED\n+#else\n+#define yy_load_buffer_state core_yy_load_buffer_state\n+#endif\n+\n+#ifdef yy_switch_to_buffer\n+#define core_yy_switch_to_buffer_ALREADY_DEFINED\n+#else\n+#define yy_switch_to_buffer core_yy_switch_to_buffer\n+#endif\n+\n+#ifdef yypush_buffer_state\n+#define core_yypush_buffer_state_ALREADY_DEFINED\n+#else\n+#define yypush_buffer_state core_yypush_buffer_state\n+#endif\n+\n+#ifdef yypop_buffer_state\n+#define core_yypop_buffer_state_ALREADY_DEFINED\n+#else\n+#define yypop_buffer_state core_yypop_buffer_state\n+#endif\n+\n+#ifdef yyensure_buffer_stack\n+#define core_yyensure_buffer_stack_ALREADY_DEFINED\n+#else\n+#define yyensure_buffer_stack core_yyensure_buffer_stack\n+#endif\n+\n+#ifdef yylex\n+#define core_yylex_ALREADY_DEFINED\n+#else\n+#define yylex core_yylex\n+#endif\n+\n+#ifdef yyrestart\n+#define core_yyrestart_ALREADY_DEFINED\n+#else\n+#define yyrestart core_yyrestart\n+#endif\n+\n+#ifdef yylex_init\n+#define core_yylex_init_ALREADY_DEFINED\n+#else\n+#define yylex_init core_yylex_init\n+#endif\n+\n+#ifdef yylex_init_extra\n+#define core_yylex_init_extra_ALREADY_DEFINED\n+#else\n+#define yylex_init_extra core_yylex_init_extra\n+#endif\n+\n+#ifdef yylex_destroy\n+#define core_yylex_destroy_ALREADY_DEFINED\n+#else\n+#define yylex_destroy core_yylex_destroy\n+#endif\n+\n+#ifdef yyget_debug\n+#define core_yyget_debug_ALREADY_DEFINED\n+#else\n+#define yyget_debug core_yyget_debug\n+#endif\n+\n+#ifdef yyset_debug\n+#define core_yyset_debug_ALREADY_DEFINED\n+#else\n+#define yyset_debug core_yyset_debug\n+#endif\n+\n+#ifdef yyget_extra\n+#define core_yyget_extra_ALREADY_DEFINED\n+#else\n+#define yyget_extra core_yyget_extra\n+#endif\n+\n+#ifdef yyset_extra\n+#define core_yyset_extra_ALREADY_DEFINED\n+#else\n+#define yyset_extra core_yyset_extra\n+#endif\n+\n+#ifdef yyget_in\n+#define core_yyget_in_ALREADY_DEFINED\n+#else\n+#define yyget_in core_yyget_in\n+#endif\n+\n+#ifdef yyset_in\n+#define core_yyset_in_ALREADY_DEFINED\n+#else\n+#define yyset_in core_yyset_in\n+#endif\n+\n+#ifdef yyget_out\n+#define core_yyget_out_ALREADY_DEFINED\n+#else\n+#define yyget_out core_yyget_out\n+#endif\n+\n+#ifdef yyset_out\n+#define core_yyset_out_ALREADY_DEFINED\n+#else\n+#define yyset_out core_yyset_out\n+#endif\n+\n+#ifdef yyget_leng\n+#define core_yyget_leng_ALREADY_DEFINED\n+#else\n+#define yyget_leng core_yyget_leng\n+#endif\n+\n+#ifdef yyget_text\n+#define core_yyget_text_ALREADY_DEFINED\n+#else\n+#define yyget_text core_yyget_text\n+#endif\n+\n+#ifdef yyget_lineno\n+#define core_yyget_lineno_ALREADY_DEFINED\n+#else\n+#define yyget_lineno core_yyget_lineno\n+#endif\n+\n+#ifdef yyset_lineno\n+#define core_yyset_lineno_ALREADY_DEFINED\n+#else\n+#define yyset_lineno core_yyset_lineno\n+#endif\n+\n+#ifdef yyget_column\n+#define core_yyget_column_ALREADY_DEFINED\n+#else\n+#define yyget_column core_yyget_column\n+#endif\n+\n+#ifdef yyset_column\n+#define core_yyset_column_ALREADY_DEFINED\n+#else\n+#define yyset_column core_yyset_column\n+#endif\n+\n+#ifdef yywrap\n+#define core_yywrap_ALREADY_DEFINED\n+#else\n+#define yywrap core_yywrap\n+#endif\n+\n+#ifdef yyget_lval\n+#define core_yyget_lval_ALREADY_DEFINED\n+#else\n+#define yyget_lval core_yyget_lval\n+#endif\n+\n+#ifdef yyset_lval\n+#define core_yyset_lval_ALREADY_DEFINED\n+#else\n+#define yyset_lval core_yyset_lval\n+#endif\n+\n+#ifdef yyget_lloc\n+#define core_yyget_lloc_ALREADY_DEFINED\n+#else\n+#define yyget_lloc core_yyget_lloc\n+#endif\n+\n+#ifdef yyset_lloc\n+#define core_yyset_lloc_ALREADY_DEFINED\n+#else\n+#define yyset_lloc core_yyset_lloc\n+#endif\n+\n+#ifdef yyalloc\n+#define core_yyalloc_ALREADY_DEFINED\n+#else\n+#define yyalloc core_yyalloc\n+#endif\n+\n+#ifdef yyrealloc\n+#define core_yyrealloc_ALREADY_DEFINED\n+#else\n+#define yyrealloc core_yyrealloc\n+#endif\n+\n+#ifdef yyfree\n+#define core_yyfree_ALREADY_DEFINED\n+#else\n+#define yyfree core_yyfree\n+#endif\n+\n /* First, we deal with  platform-specific or compiler-specific issues. */\n \n /* begin standard C headers. */\n@@ -100,7 +330,6 @@ typedef int flex_int32_t;\n typedef unsigned char flex_uint8_t; \n typedef unsigned short int flex_uint16_t;\n typedef unsigned int flex_uint32_t;\n-#endif /* ! C99 */\n \n /* Limits of integral types. */\n #ifndef INT8_MIN\n@@ -131,38 +360,32 @@ typedef unsigned int flex_uint32_t;\n #define UINT32_MAX             (4294967295U)\n #endif\n \n-#endif /* ! FLEXINT_H */\n-\n-#ifdef __cplusplus\n-\n-/* The \"const\" storage-class-modifier is valid. */\n-#define YY_USE_CONST\n-\n-#else\t/* ! __cplusplus */\n+#ifndef SIZE_MAX\n+#define SIZE_MAX               (~(size_t)0)\n+#endif\n \n-/* C99 requires __STDC__ to be defined as 1. */\n-#if defined (__STDC__)\n+#endif /* ! C99 */\n \n-#define YY_USE_CONST\n+#endif /* ! FLEXINT_H */\n \n-#endif\t/* defined (__STDC__) */\n-#endif\t/* ! __cplusplus */\n+/* begin standard C++ headers. */\n \n-#ifdef YY_USE_CONST\n+/* TODO: this is always defined, so inline it */\n #define yyconst const\n+\n+#if defined(__GNUC__) && __GNUC__ >= 3\n+#define yynoreturn __attribute__((__noreturn__))\n #else\n-#define yyconst\n+#define yynoreturn\n #endif\n \n /* Returned upon end-of-file. */\n #define YY_NULL 0\n \n-/* Promotes a possibly negative, possibly signed char to an unsigned\n- * integer for use as an array index.  If the signed char is negative,\n- * we want to instead treat it as an 8-bit unsigned char, hence the\n- * double cast.\n+/* Promotes a possibly negative, possibly signed char to an\n+ *   integer in range [0..255] for use as an array index.\n  */\n-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)\n+#define YY_SC_TO_UI(c) ((YY_CHAR) (c))\n \n /* An opaque pointer. */\n #ifndef YY_TYPEDEF_YY_SCANNER_T\n@@ -186,25 +409,29 @@ typedef void* yyscan_t;\n  * definition of BEGIN.\n  */\n #define BEGIN yyg->yy_start = 1 + 2 *\n-\n /* Translate the current start state into a value that can be later handed\n  * to BEGIN to return to the state.  The YYSTATE alias is for lex\n  * compatibility.\n  */\n #define YY_START ((yyg->yy_start - 1) / 2)\n #define YYSTATE YY_START\n-\n /* Action number for EOF rule of a given start state. */\n #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)\n-\n /* Special action meaning \"start processing a new file\". */\n-#define YY_NEW_FILE core_yyrestart(yyin ,yyscanner )\n-\n+#define YY_NEW_FILE yyrestart( yyin , yyscanner )\n #define YY_END_OF_BUFFER_CHAR 0\n \n /* Size of default input buffer. */\n #ifndef YY_BUF_SIZE\n+#ifdef __ia64__\n+/* On IA-64, the buffer size is 16k, not 8k.\n+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.\n+ * Ditto for the __ia64__ case accordingly.\n+ */\n+#define YY_BUF_SIZE 32768\n+#else\n #define YY_BUF_SIZE 16384\n+#endif /* __ia64__ */\n #endif\n \n /* The state buf must be large enough to hold one state per character in the main buffer.\n@@ -224,8 +451,9 @@ typedef size_t yy_size_t;\n #define EOB_ACT_CONTINUE_SCAN 0\n #define EOB_ACT_END_OF_FILE 1\n #define EOB_ACT_LAST_MATCH 2\n-\n+    \n     #define YY_LESS_LINENO(n)\n+    #define YY_LINENO_REWIND_TO(ptr)\n     \n /* Return all but the first \"n\" matched characters back to the input stream. */\n #define yyless(n) \\\n@@ -240,7 +468,6 @@ typedef size_t yy_size_t;\n \t\tYY_DO_BEFORE_ACTION; /* set up yytext again */ \\\n \t\t} \\\n \twhile ( 0 )\n-\n #define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )\n \n #ifndef YY_STRUCT_YY_BUFFER_STATE\n@@ -283,7 +510,7 @@ struct yy_buffer_state\n \n     int yy_bs_lineno; /**< The line count. */\n     int yy_bs_column; /**< The column count. */\n-    \n+\n \t/* Whether to try to fill the input buffer when we reach the\n \t * end of it.\n \t */\n@@ -300,7 +527,7 @@ struct yy_buffer_state\n \t * possible backing-up.\n \t *\n \t * When we actually see the EOF, we change the status to \"new\"\n-\t * (via core_yyrestart()), so that the user can continue scanning by\n+\t * (via yyrestart()), so that the user can continue scanning by\n \t * just pointing yyin at a new input file.\n \t */\n #define YY_BUFFER_EOF_PENDING 2\n@@ -317,73 +544,67 @@ struct yy_buffer_state\n #define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \\\n                           ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \\\n                           : NULL)\n-\n /* Same as previous macro, but useful when we know that the buffer stack is not\n  * NULL or when we need an lvalue. For internal use only.\n  */\n #define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]\n \n-void core_yyrestart (FILE *input_file ,yyscan_t yyscanner );\n-void core_yy_switch_to_buffer (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );\n-YY_BUFFER_STATE core_yy_create_buffer (FILE *file,int size ,yyscan_t yyscanner );\n-void core_yy_delete_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );\n-void core_yy_flush_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );\n-void core_yypush_buffer_state (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );\n-void core_yypop_buffer_state (yyscan_t yyscanner );\n-\n-static void core_yyensure_buffer_stack (yyscan_t yyscanner );\n-static void core_yy_load_buffer_state (yyscan_t yyscanner );\n-static void core_yy_init_buffer (YY_BUFFER_STATE b,FILE *file ,yyscan_t yyscanner );\n-\n-#define YY_FLUSH_BUFFER core_yy_flush_buffer(YY_CURRENT_BUFFER ,yyscanner)\n+void yyrestart ( FILE *input_file , yyscan_t yyscanner );\n+void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );\n+YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );\n+void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );\n+void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );\n+void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );\n+void yypop_buffer_state ( yyscan_t yyscanner );\n \n-YY_BUFFER_STATE core_yy_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );\n-YY_BUFFER_STATE core_yy_scan_string (yyconst char *yy_str ,yyscan_t yyscanner );\n-YY_BUFFER_STATE core_yy_scan_bytes (yyconst char *bytes,yy_size_t len ,yyscan_t yyscanner );\n+static void yyensure_buffer_stack ( yyscan_t yyscanner );\n+static void yy_load_buffer_state ( yyscan_t yyscanner );\n+static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file , yyscan_t yyscanner );\n+#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER , yyscanner)\n \n-void *core_yyalloc (yy_size_t ,yyscan_t yyscanner );\n-void *core_yyrealloc (void *,yy_size_t ,yyscan_t yyscanner );\n-void core_yyfree (void * ,yyscan_t yyscanner );\n+YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );\n+YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );\n+YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, yy_size_t len , yyscan_t yyscanner );\n \n-#define yy_new_buffer core_yy_create_buffer\n+void *yyalloc ( yy_size_t , yyscan_t yyscanner );\n+void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );\n+void yyfree ( void * , yyscan_t yyscanner );\n \n+#define yy_new_buffer yy_create_buffer\n #define yy_set_interactive(is_interactive) \\\n \t{ \\\n \tif ( ! YY_CURRENT_BUFFER ){ \\\n-        core_yyensure_buffer_stack (yyscanner); \\\n+        yyensure_buffer_stack (yyscanner); \\\n \t\tYY_CURRENT_BUFFER_LVALUE =    \\\n-            core_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \\\n+            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \\\n \t} \\\n \tYY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \\\n \t}\n-\n #define yy_set_bol(at_bol) \\\n \t{ \\\n \tif ( ! YY_CURRENT_BUFFER ){\\\n-        core_yyensure_buffer_stack (yyscanner); \\\n+        yyensure_buffer_stack (yyscanner); \\\n \t\tYY_CURRENT_BUFFER_LVALUE =    \\\n-            core_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \\\n+            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \\\n \t} \\\n \tYY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \\\n \t}\n-\n #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)\n \n /* Begin user sect3 */\n \n-#define core_yywrap(n) 1\n+#define core_yywrap(yyscanner) (/*CONSTCOND*/1)\n #define YY_SKIP_YYWRAP\n-\n-typedef unsigned char YY_CHAR;\n+typedef flex_uint8_t YY_CHAR;\n \n typedef int yy_state_type;\n \n #define yytext_ptr yytext_r\n \n-static yy_state_type yy_get_previous_state (yyscan_t yyscanner );\n-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  ,yyscan_t yyscanner);\n-static int yy_get_next_buffer (yyscan_t yyscanner );\n-static void yy_fatal_error (yyconst char msg[] ,yyscan_t yyscanner );\n+static yy_state_type yy_get_previous_state ( yyscan_t yyscanner );\n+static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  , yyscan_t yyscanner);\n+static int yy_get_next_buffer ( yyscan_t yyscanner );\n+static void yynoreturn yy_fatal_error ( const char* msg , yyscan_t yyscanner );\n \n /* Done after the current pattern has been matched and before the\n  * corresponding action - sets up yytext.\n@@ -394,7 +615,6 @@ static void yy_fatal_error (yyconst char msg[] ,yyscan_t yyscanner );\n \tyyg->yy_hold_char = *yy_cp; \\\n \t*yy_cp = '\\0'; \\\n \tyyg->yy_c_buf_p = yy_cp;\n-\n #define YY_NUM_RULES 83\n #define YY_END_OF_BUFFER 84\n /* This struct is not used in this scanner,\n@@ -404,7 +624,7 @@ struct yy_trans_info\n \tflex_int32_t yy_verify;\n \tflex_int32_t yy_nxt;\n \t};\n-static yyconst flex_int16_t yy_accept[296] =\n+static const flex_int16_t yy_accept[296] =\n     {   0,\n         0,    0,   12,   12,    0,    0,    0,    0,   11,   11,\n         0,    0,    0,    0,    0,    0,    0,    0,   55,   55,\n@@ -441,7 +661,7 @@ static yyconst flex_int16_t yy_accept[296] =\n \n     } ;\n \n-static yyconst flex_int32_t yy_ec[256] =\n+static const YY_CHAR yy_ec[256] =\n     {   0,\n         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,\n         1,    2,    4,    1,    1,    1,    1,    1,    1,    1,\n@@ -473,7 +693,7 @@ static yyconst flex_int32_t yy_ec[256] =\n        30,   30,   30,   30,   30\n     } ;\n \n-static yyconst flex_int32_t yy_meta[39] =\n+static const YY_CHAR yy_meta[39] =\n     {   0,\n         1,    1,    2,    2,    3,    4,    5,    3,    3,    6,\n         1,    7,    3,    3,    1,    7,    8,    8,    1,    3,\n@@ -481,7 +701,7 @@ static yyconst flex_int32_t yy_meta[39] =\n        10,   10,   10,   10,   10,   11,   10,   10\n     } ;\n \n-static yyconst flex_int16_t yy_base[363] =\n+static const flex_int16_t yy_base[363] =\n     {   0,\n         0,    0,  431,  430,   34,   54,  428,  419,  414,  409,\n        41,   50,  408,  402,   38,   54,  405,  393,   85,  121,\n@@ -525,7 +745,7 @@ static yyconst flex_int16_t yy_base[363] =\n      1185, 1196\n     } ;\n \n-static yyconst flex_int16_t yy_def[363] =\n+static const flex_int16_t yy_def[363] =\n     {   0,\n       295,    1,  296,  296,  297,  297,  298,  298,  299,  299,\n       300,  300,  301,  301,  302,  302,  298,  298,  303,  303,\n@@ -569,7 +789,7 @@ static yyconst flex_int16_t yy_def[363] =\n       295,  295\n     } ;\n \n-static yyconst flex_int16_t yy_nxt[1247] =\n+static const flex_int16_t yy_nxt[1247] =\n     {   0,\n        28,   29,   30,   29,   31,   32,   33,   34,   35,   36,\n        37,   38,   34,   39,   40,   41,   42,   42,   43,   44,\n@@ -710,7 +930,7 @@ static yyconst flex_int16_t yy_nxt[1247] =\n       295,  295,  295,  295,  295,  295\n     } ;\n \n-static yyconst flex_int16_t yy_chk[1247] =\n+static const flex_int16_t yy_chk[1247] =\n     {   0,\n         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n@@ -887,7 +1107,7 @@ bool\t\tstandard_conforming_strings = true;\n #define YY_EXTRA_TYPE core_yy_extra_type *\n \n /*\n- * Each call to core_yylex must set yylloc to the location of the found token\n+ * Each call to yylex must set yylloc to the location of the found token\n  * (expressed as a byte offset from the start of the input text).\n  * When we parse a token that requires multiple lexer rules to process,\n  * this should be done in the first such rule, else yylloc will point\n@@ -929,6 +1149,7 @@ static void check_escape_warning(core_yyscan_t yyscanner);\n extern int\tcore_yyget_column(yyscan_t yyscanner);\n extern void core_yyset_column(int column_no, yyscan_t yyscanner);\n \n+#line 1151 \"third_party/libpg_query/src_backend_parser_scan.cpp\"\n #define YY_NO_INPUT 1\n /*\n  * OK, here is a short description of lex/flex rules behavior.\n@@ -958,17 +1179,6 @@ extern void core_yyset_column(int column_no, yyscan_t yyscanner);\n  * The default one is probably not the right thing.\n  */\n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n /*\n  * In order to make the world safe for Windows and Mac clients as well as\n  * Unix ones, we accept either \\n or \\r as a newline.  A DOS-style \\r\\n\n@@ -1093,7 +1303,7 @@ extern void core_yyset_column(int column_no, yyscan_t yyscanner);\n  * Note that xcstart must appear before operator, as explained above!\n  *  Also whitespace (comment) must appear before operator.\n  */\n-#line 1096 \"third_party/libpg_query/src_backend_parser_scan.cpp\"\n+#line 1305 \"third_party/libpg_query/src_backend_parser_scan.cpp\"\n \n #define INITIAL 0\n #define xb 1\n@@ -1151,7 +1361,7 @@ struct yyguts_t\n \n     }; /* end struct yyguts_t */\n \n-static int yy_init_globals (yyscan_t yyscanner );\n+static int yy_init_globals ( yyscan_t yyscanner );\n \n     /* This must go here because YYSTYPE and YYLTYPE are included\n      * from bison output in section 1.*/\n@@ -1159,46 +1369,50 @@ static int yy_init_globals (yyscan_t yyscanner );\n     \n     #    define yylloc yyg->yylloc_r\n     \n-int core_yylex_init (yyscan_t* scanner);\n+int yylex_init (yyscan_t* scanner);\n \n-int core_yylex_init_extra (YY_EXTRA_TYPE user_defined,yyscan_t* scanner);\n+int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);\n \n /* Accessor methods to globals.\n    These are made visible to non-reentrant scanners for convenience. */\n \n-int core_yylex_destroy (yyscan_t yyscanner );\n+int yylex_destroy ( yyscan_t yyscanner );\n+\n+int yyget_debug ( yyscan_t yyscanner );\n \n-int core_yyget_debug (yyscan_t yyscanner );\n+void yyset_debug ( int debug_flag , yyscan_t yyscanner );\n \n-void core_yyset_debug (int debug_flag ,yyscan_t yyscanner );\n+YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );\n \n-YY_EXTRA_TYPE core_yyget_extra (yyscan_t yyscanner );\n+void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );\n \n-void core_yyset_extra (YY_EXTRA_TYPE user_defined ,yyscan_t yyscanner );\n+FILE *yyget_in ( yyscan_t yyscanner );\n \n-FILE *core_yyget_in (yyscan_t yyscanner );\n+void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );\n \n-void core_yyset_in  (FILE * in_str ,yyscan_t yyscanner );\n+FILE *yyget_out ( yyscan_t yyscanner );\n \n-FILE *core_yyget_out (yyscan_t yyscanner );\n+void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );\n \n-void core_yyset_out  (FILE * out_str ,yyscan_t yyscanner );\n+\t\t\tyy_size_t yyget_leng ( yyscan_t yyscanner );\n \n-yy_size_t core_yyget_leng (yyscan_t yyscanner );\n+char *yyget_text ( yyscan_t yyscanner );\n \n-char *core_yyget_text (yyscan_t yyscanner );\n+int yyget_lineno ( yyscan_t yyscanner );\n \n-int core_yyget_lineno (yyscan_t yyscanner );\n+void yyset_lineno ( int _line_number , yyscan_t yyscanner );\n \n-void core_yyset_lineno (int line_number ,yyscan_t yyscanner );\n+int yyget_column  ( yyscan_t yyscanner );\n \n-YYSTYPE * core_yyget_lval (yyscan_t yyscanner );\n+void yyset_column ( int _column_no , yyscan_t yyscanner );\n \n-void core_yyset_lval (YYSTYPE * yylval_param ,yyscan_t yyscanner );\n+YYSTYPE * yyget_lval ( yyscan_t yyscanner );\n \n-       YYLTYPE *core_yyget_lloc (yyscan_t yyscanner );\n+void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );\n+\n+       YYLTYPE *yyget_lloc ( yyscan_t yyscanner );\n     \n-        void core_yyset_lloc (YYLTYPE * yylloc_param ,yyscan_t yyscanner );\n+        void yyset_lloc ( YYLTYPE * yylloc_param , yyscan_t yyscanner );\n     \n /* Macros after this point can all be overridden by user definitions in\n  * section 1.\n@@ -1206,33 +1420,41 @@ void core_yyset_lval (YYSTYPE * yylval_param ,yyscan_t yyscanner );\n \n #ifndef YY_SKIP_YYWRAP\n #ifdef __cplusplus\n-extern \"C\" int core_yywrap (yyscan_t yyscanner );\n+extern \"C\" int yywrap ( yyscan_t yyscanner );\n #else\n-extern int core_yywrap (yyscan_t yyscanner );\n+extern int yywrap ( yyscan_t yyscanner );\n+#endif\n #endif\n+\n+#ifndef YY_NO_UNPUT\n+    \n #endif\n \n #ifndef yytext_ptr\n-static void yy_flex_strncpy (char *,yyconst char *,int ,yyscan_t yyscanner);\n+static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);\n #endif\n \n #ifdef YY_NEED_STRLEN\n-static int yy_flex_strlen (yyconst char * ,yyscan_t yyscanner);\n+static int yy_flex_strlen ( const char * , yyscan_t yyscanner);\n #endif\n \n #ifndef YY_NO_INPUT\n-\n #ifdef __cplusplus\n-static int yyinput (yyscan_t yyscanner );\n+static int yyinput ( yyscan_t yyscanner );\n #else\n-static int input (yyscan_t yyscanner );\n+static int input ( yyscan_t yyscanner );\n #endif\n \n #endif\n \n /* Amount of stuff to slurp up with each read. */\n #ifndef YY_READ_BUF_SIZE\n+#ifdef __ia64__\n+/* On IA-64, the buffer size is 16k, not 8k */\n+#define YY_READ_BUF_SIZE 16384\n+#else\n #define YY_READ_BUF_SIZE 8192\n+#endif /* __ia64__ */\n #endif\n \n /* Copy whatever the last rule matched to the standard output. */\n@@ -1240,7 +1462,7 @@ static int input (yyscan_t yyscanner );\n /* This used to be an fputs(), but since the string might contain NUL's,\n  * we now use fwrite().\n  */\n-#define ECHO fwrite( yytext, yyleng, 1, yyout )\n+#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)\n #endif\n \n /* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,\n@@ -1264,7 +1486,7 @@ static int input (yyscan_t yyscanner );\n \telse \\\n \t\t{ \\\n \t\terrno=0; \\\n-\t\twhile ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\\n+\t\twhile ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \\\n \t\t\t{ \\\n \t\t\tif( errno != EINTR) \\\n \t\t\t\t{ \\\n@@ -1305,10 +1527,10 @@ static int input (yyscan_t yyscanner );\n #ifndef YY_DECL\n #define YY_DECL_IS_OURS 1\n \n-extern int core_yylex \\\n-               (YYSTYPE * yylval_param,YYLTYPE * yylloc_param ,yyscan_t yyscanner);\n+extern int yylex \\\n+               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner);\n \n-#define YY_DECL int core_yylex \\\n+#define YY_DECL int yylex \\\n                (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)\n #endif /* !YY_DECL */\n \n@@ -1321,7 +1543,7 @@ extern int core_yylex \\\n \n /* Code executed at the end of each rule. */\n #ifndef YY_BREAK\n-#define YY_BREAK break;\n+#define YY_BREAK /*LINTED*/break;\n #endif\n \n #define YY_RULE_SETUP \\\n@@ -1336,11 +1558,6 @@ YY_DECL\n \tint yy_act;\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \n-#line 403 \"third_party/libpg_query/scan.l\"\n-\n-\n-#line 1342 \"third_party/libpg_query/src_backend_parser_scan.cpp\"\n-\n     yylval = yylval_param;\n \n     yylloc = yylloc_param;\n@@ -1356,15 +1573,21 @@ YY_DECL\n \t\tif ( ! yyg->yy_start )\n \t\t\tyyg->yy_start = 1;\t/* first start state */\n \t\tif ( ! YY_CURRENT_BUFFER ) {\n-\t\t\tcore_yyensure_buffer_stack (yyscanner);\n+\t\t\tyyensure_buffer_stack (yyscanner);\n \t\t\tYY_CURRENT_BUFFER_LVALUE =\n-\t\t\t\tcore_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);\n+\t\t\t\tyy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);\n \t\t}\n \n-\t\tcore_yy_load_buffer_state(yyscanner );\n+\t\tyy_load_buffer_state( yyscanner );\n \t\t}\n \n-\twhile ( 1 )\t\t/* loops until end-of-file is reached */\n+\t{\n+#line 403 \"third_party/libpg_query/scan.l\"\n+\n+\n+#line 1594 \"third_party/libpg_query/src_backend_parser_scan.cpp\"\n+\n+\twhile ( /*CONSTCOND*/1 )\t\t/* loops until end-of-file is reached */\n \t\t{\n \t\tyy_cp = yyg->yy_c_buf_p;\n \n@@ -1380,7 +1603,7 @@ YY_DECL\n yy_match:\n \t\tdo\n \t\t\t{\n-\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];\n+\t\t\tYY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;\n \t\t\tif ( yy_accept[yy_current_state] )\n \t\t\t\t{\n \t\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n@@ -1390,9 +1613,9 @@ YY_DECL\n \t\t\t\t{\n \t\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n \t\t\t\tif ( yy_current_state >= 296 )\n-\t\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n+\t\t\t\t\tyy_c = yy_meta[yy_c];\n \t\t\t\t}\n-\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n+\t\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n \t\t\t++yy_cp;\n \t\t\t}\n \t\twhile ( yy_current_state != 295 );\n@@ -2392,7 +2615,7 @@ YY_RULE_SETUP\n \t\t\t\t\t\tif (keyword_text[yyleng - 1] == '\\0') {\n \t\t\t\t\t\t\tyyless(yyleng - 1);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tyylval->keyword = keyword->name;\n+\t\t\t\t\t\tyylval->keyword = keyword_text;\n \t\t\t\t\t\treturn keyword->value;\n \t\t\t\t\t}\n \n@@ -2425,7 +2648,7 @@ YY_RULE_SETUP\n #line 1083 \"third_party/libpg_query/scan.l\"\n YY_FATAL_ERROR( \"flex scanner jammed\" );\n \tYY_BREAK\n-#line 2435 \"third_party/libpg_query/src_backend_parser_scan.cpp\"\n+#line 2657 \"third_party/libpg_query/src_backend_parser_scan.cpp\"\n \n \tcase YY_END_OF_BUFFER:\n \t\t{\n@@ -2441,7 +2664,7 @@ YY_FATAL_ERROR( \"flex scanner jammed\" );\n \t\t\t/* We're scanning a new file or input source.  It's\n \t\t\t * possible that this happened because the user\n \t\t\t * just pointed yyin at a new source and called\n-\t\t\t * core_yylex().  If so, then we have to assure\n+\t\t\t * yylex().  If so, then we have to assure\n \t\t\t * consistency between YY_CURRENT_BUFFER and our\n \t\t\t * globals.  Here is the right place to do so, because\n \t\t\t * this is the first action (other than possibly a\n@@ -2502,7 +2725,7 @@ YY_FATAL_ERROR( \"flex scanner jammed\" );\n \t\t\t\t{\n \t\t\t\tyyg->yy_did_buffer_switch_on_eof = 0;\n \n-\t\t\t\tif ( core_yywrap(yyscanner ) )\n+\t\t\t\tif ( yywrap( yyscanner ) )\n \t\t\t\t\t{\n \t\t\t\t\t/* Note: because we've taken care in\n \t\t\t\t\t * yy_get_next_buffer() to have set up\n@@ -2555,7 +2778,8 @@ YY_FATAL_ERROR( \"flex scanner jammed\" );\n \t\t\t\"fatal flex scanner internal error--no action found\" );\n \t} /* end of action switch */\n \t\t} /* end of scanning one token */\n-} /* end of core_yylex */\n+\t} /* end of user's declarations */\n+} /* end of yylex */\n \n /* yy_get_next_buffer - try to read in a new buffer\n  *\n@@ -2598,7 +2822,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \t/* Try to read more data. */\n \n \t/* First move last chars to start of buffer. */\n-\tnumber_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;\n+\tnumber_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);\n \n \tfor ( i = 0; i < number_to_move; ++i )\n \t\t*(dest++) = *(source++);\n@@ -2618,7 +2842,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \t\t\t{ /* Not enough room in the buffer - grow it. */\n \n \t\t\t/* just a shorter name for the current buffer */\n-\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n+\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n \n \t\t\tint yy_c_buf_p_offset =\n \t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);\n@@ -2634,11 +2858,12 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \n \t\t\t\tb->yy_ch_buf = (char *)\n \t\t\t\t\t/* Include room in for 2 EOB chars. */\n-\t\t\t\t\tcore_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );\n+\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n+\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2) , yyscanner );\n \t\t\t\t}\n \t\t\telse\n \t\t\t\t/* Can't grow it, we don't own it. */\n-\t\t\t\tb->yy_ch_buf = 0;\n+\t\t\t\tb->yy_ch_buf = NULL;\n \n \t\t\tif ( ! b->yy_ch_buf )\n \t\t\t\tYY_FATAL_ERROR(\n@@ -2666,7 +2891,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \t\tif ( number_to_move == YY_MORE_ADJ )\n \t\t\t{\n \t\t\tret_val = EOB_ACT_END_OF_FILE;\n-\t\t\tcore_yyrestart(yyin  ,yyscanner);\n+\t\t\tyyrestart( yyin  , yyscanner);\n \t\t\t}\n \n \t\telse\n@@ -2680,12 +2905,15 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \telse\n \t\tret_val = EOB_ACT_CONTINUE_SCAN;\n \n-\tif ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n+\tif ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n \t\t/* Extend the array by 50%, plus the number we really need. */\n \t\tyy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);\n-\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) core_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n+\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );\n \t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n \t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n+\t\t/* \"- 2\" to take care of EOB's */\n+\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n \t}\n \n \tyyg->yy_n_chars += number_to_move;\n@@ -2719,9 +2947,9 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \t\t\t{\n \t\t\tyy_current_state = (int) yy_def[yy_current_state];\n \t\t\tif ( yy_current_state >= 296 )\n-\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n+\t\t\t\tyy_c = yy_meta[yy_c];\n \t\t\t}\n-\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n+\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n \t\t}\n \n \treturn yy_current_state;\n@@ -2748,14 +2976,19 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \t\t{\n \t\tyy_current_state = (int) yy_def[yy_current_state];\n \t\tif ( yy_current_state >= 296 )\n-\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n+\t\t\tyy_c = yy_meta[yy_c];\n \t\t}\n-\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n+\tyy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];\n \tyy_is_jam = (yy_current_state == 295);\n \n+\t(void)yyg;\n \treturn yy_is_jam ? 0 : yy_current_state;\n }\n \n+#ifndef YY_NO_UNPUT\n+\n+#endif\n+\n #ifndef YY_NO_INPUT\n #ifdef __cplusplus\n     static int yyinput (yyscan_t yyscanner)\n@@ -2798,13 +3031,13 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \t\t\t\t\t */\n \n \t\t\t\t\t/* Reset buffer status. */\n-\t\t\t\t\tcore_yyrestart(yyin ,yyscanner);\n+\t\t\t\t\tyyrestart( yyin , yyscanner);\n \n \t\t\t\t\t/*FALLTHROUGH*/\n \n \t\t\t\tcase EOB_ACT_END_OF_FILE:\n \t\t\t\t\t{\n-\t\t\t\t\tif ( core_yywrap(yyscanner ) )\n+\t\t\t\t\tif ( yywrap( yyscanner ) )\n \t\t\t\t\t\treturn 0;\n \n \t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n@@ -2836,34 +3069,34 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n  * @param yyscanner The scanner object.\n  * @note This function does not reset the start condition to @c INITIAL .\n  */\n-    void core_yyrestart  (FILE * input_file , yyscan_t yyscanner)\n+    void yyrestart  (FILE * input_file , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \n \tif ( ! YY_CURRENT_BUFFER ){\n-        core_yyensure_buffer_stack (yyscanner);\n+        yyensure_buffer_stack (yyscanner);\n \t\tYY_CURRENT_BUFFER_LVALUE =\n-            core_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);\n+            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);\n \t}\n \n-\tcore_yy_init_buffer(YY_CURRENT_BUFFER,input_file ,yyscanner);\n-\tcore_yy_load_buffer_state(yyscanner );\n+\tyy_init_buffer( YY_CURRENT_BUFFER, input_file , yyscanner);\n+\tyy_load_buffer_state( yyscanner );\n }\n \n /** Switch to a different input buffer.\n  * @param new_buffer The new input buffer.\n  * @param yyscanner The scanner object.\n  */\n-    void core_yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)\n+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \n \t/* TODO. We should be able to replace this entire function body\n \t * with\n-\t *\t\tcore_yypop_buffer_state();\n-\t *\t\tcore_yypush_buffer_state(new_buffer);\n+\t *\t\tyypop_buffer_state();\n+\t *\t\tyypush_buffer_state(new_buffer);\n      */\n-\tcore_yyensure_buffer_stack (yyscanner);\n+\tyyensure_buffer_stack (yyscanner);\n \tif ( YY_CURRENT_BUFFER == new_buffer )\n \t\treturn;\n \n@@ -2876,17 +3109,17 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \t\t}\n \n \tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n-\tcore_yy_load_buffer_state(yyscanner );\n+\tyy_load_buffer_state( yyscanner );\n \n \t/* We don't actually know whether we did this switch during\n-\t * EOF (core_yywrap()) processing, but the only time this flag\n-\t * is looked at is after core_yywrap() is called, so it's safe\n+\t * EOF (yywrap()) processing, but the only time this flag\n+\t * is looked at is after yywrap() is called, so it's safe\n \t * to go ahead and always set it.\n \t */\n \tyyg->yy_did_buffer_switch_on_eof = 1;\n }\n \n-static void core_yy_load_buffer_state  (yyscan_t yyscanner)\n+static void yy_load_buffer_state  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n@@ -2901,35 +3134,35 @@ static void core_yy_load_buffer_state  (yyscan_t yyscanner)\n  * @param yyscanner The scanner object.\n  * @return the allocated buffer state.\n  */\n-    YY_BUFFER_STATE core_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)\n+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)\n {\n \tYY_BUFFER_STATE b;\n     \n-\tb = (YY_BUFFER_STATE) core_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );\n+\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );\n \tif ( ! b )\n-\t\tYY_FATAL_ERROR( \"out of dynamic memory in core_yy_create_buffer()\" );\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n \n \tb->yy_buf_size = size;\n \n \t/* yy_ch_buf has to be 2 characters longer than the size given because\n \t * we need to put in 2 end-of-buffer characters.\n \t */\n-\tb->yy_ch_buf = (char *) core_yyalloc(b->yy_buf_size + 2 ,yyscanner );\n+\tb->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2) , yyscanner );\n \tif ( ! b->yy_ch_buf )\n-\t\tYY_FATAL_ERROR( \"out of dynamic memory in core_yy_create_buffer()\" );\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n \n \tb->yy_is_our_buffer = 1;\n \n-\tcore_yy_init_buffer(b,file ,yyscanner);\n+\tyy_init_buffer( b, file , yyscanner);\n \n \treturn b;\n }\n \n /** Destroy the buffer.\n- * @param b a buffer created with core_yy_create_buffer()\n+ * @param b a buffer created with yy_create_buffer()\n  * @param yyscanner The scanner object.\n  */\n-    void core_yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)\n+    void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \n@@ -2940,28 +3173,28 @@ static void core_yy_load_buffer_state  (yyscan_t yyscanner)\n \t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n \n \tif ( b->yy_is_our_buffer )\n-\t\tcore_yyfree((void *) b->yy_ch_buf ,yyscanner );\n+\t\tyyfree( (void *) b->yy_ch_buf , yyscanner );\n \n-\tcore_yyfree((void *) b ,yyscanner );\n+\tyyfree( (void *) b , yyscanner );\n }\n \n /* Initializes or reinitializes a buffer.\n  * This function is sometimes called more than once on the same buffer,\n- * such as during a core_yyrestart() or at EOF.\n+ * such as during a yyrestart() or at EOF.\n  */\n-    static void core_yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)\n+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)\n \n {\n \tint oerrno = errno;\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \n-\tcore_yy_flush_buffer(b ,yyscanner);\n+\tyy_flush_buffer( b , yyscanner);\n \n \tb->yy_input_file = file;\n \tb->yy_fill_buffer = 1;\n \n-    /* If b is the current buffer, then core_yy_init_buffer was _probably_\n-     * called from core_yyrestart() or through yy_get_next_buffer.\n+    /* If b is the current buffer, then yy_init_buffer was _probably_\n+     * called from yyrestart() or through yy_get_next_buffer.\n      * In that case, we don't want to reset the lineno or column.\n      */\n     if (b != YY_CURRENT_BUFFER){\n@@ -2978,7 +3211,7 @@ static void core_yy_load_buffer_state  (yyscan_t yyscanner)\n  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n  * @param yyscanner The scanner object.\n  */\n-    void core_yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)\n+    void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \tif ( ! b )\n@@ -2999,7 +3232,7 @@ static void core_yy_load_buffer_state  (yyscan_t yyscanner)\n \tb->yy_buffer_status = YY_BUFFER_NEW;\n \n \tif ( b == YY_CURRENT_BUFFER )\n-\t\tcore_yy_load_buffer_state(yyscanner );\n+\t\tyy_load_buffer_state( yyscanner );\n }\n \n /** Pushes the new state onto the stack. The new state becomes\n@@ -3008,15 +3241,15 @@ static void core_yy_load_buffer_state  (yyscan_t yyscanner)\n  *  @param new_buffer The new state.\n  *  @param yyscanner The scanner object.\n  */\n-void core_yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)\n+void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \tif (new_buffer == NULL)\n \t\treturn;\n \n-\tcore_yyensure_buffer_stack(yyscanner);\n+\tyyensure_buffer_stack(yyscanner);\n \n-\t/* This block is copied from core_yy_switch_to_buffer. */\n+\t/* This block is copied from yy_switch_to_buffer. */\n \tif ( YY_CURRENT_BUFFER )\n \t\t{\n \t\t/* Flush out information for old buffer. */\n@@ -3030,8 +3263,8 @@ void core_yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)\n \t\tyyg->yy_buffer_stack_top++;\n \tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n \n-\t/* copied from core_yy_switch_to_buffer. */\n-\tcore_yy_load_buffer_state(yyscanner );\n+\t/* copied from yy_switch_to_buffer. */\n+\tyy_load_buffer_state( yyscanner );\n \tyyg->yy_did_buffer_switch_on_eof = 1;\n }\n \n@@ -3039,19 +3272,19 @@ void core_yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)\n  *  The next element becomes the new top.\n  *  @param yyscanner The scanner object.\n  */\n-void core_yypop_buffer_state (yyscan_t yyscanner)\n+void yypop_buffer_state (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \tif (!YY_CURRENT_BUFFER)\n \t\treturn;\n \n-\tcore_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);\n+\tyy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);\n \tYY_CURRENT_BUFFER_LVALUE = NULL;\n \tif (yyg->yy_buffer_stack_top > 0)\n \t\t--yyg->yy_buffer_stack_top;\n \n \tif (YY_CURRENT_BUFFER) {\n-\t\tcore_yy_load_buffer_state(yyscanner );\n+\t\tyy_load_buffer_state( yyscanner );\n \t\tyyg->yy_did_buffer_switch_on_eof = 1;\n \t}\n }\n@@ -3059,7 +3292,7 @@ void core_yypop_buffer_state (yyscan_t yyscanner)\n /* Allocates the stack if it does not exist.\n  *  Guarantees space for at least one push.\n  */\n-static void core_yyensure_buffer_stack (yyscan_t yyscanner)\n+static void yyensure_buffer_stack (yyscan_t yyscanner)\n {\n \tyy_size_t num_to_alloc;\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n@@ -3070,15 +3303,15 @@ static void core_yyensure_buffer_stack (yyscan_t yyscanner)\n \t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n \t\t * immediate realloc on the next call.\n          */\n-\t\tnum_to_alloc = 1;\n-\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)core_yyalloc\n+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n+\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc\n \t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n-\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in core_yyensure_buffer_stack()\" );\n-\t\t\t\t\t\t\t\t  \n+\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n+\n \t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n-\t\t\t\t\n+\n \t\tyyg->yy_buffer_stack_max = num_to_alloc;\n \t\tyyg->yy_buffer_stack_top = 0;\n \t\treturn;\n@@ -3087,15 +3320,15 @@ static void core_yyensure_buffer_stack (yyscan_t yyscanner)\n \tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n \n \t\t/* Increase the buffer to prepare for a possible push. */\n-\t\tint grow_size = 8 /* arbitrary grow size */;\n+\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n \n \t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n-\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)core_yyrealloc\n+\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc\n \t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n \t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n-\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in core_yyensure_buffer_stack()\" );\n+\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n \n \t\t/* zero only the new slots.*/\n \t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n@@ -3107,9 +3340,9 @@ static void core_yyensure_buffer_stack (yyscan_t yyscanner)\n  * @param base the character buffer\n  * @param size the size in bytes of the character buffer\n  * @param yyscanner The scanner object.\n- * @return the newly allocated buffer state object. \n+ * @return the newly allocated buffer state object.\n  */\n-YY_BUFFER_STATE core_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n {\n \tYY_BUFFER_STATE b;\n     \n@@ -3117,68 +3350,69 @@ YY_BUFFER_STATE core_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yy\n \t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n \t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n \t\t/* They forgot to leave room for the EOB's. */\n-\t\treturn 0;\n+\t\treturn NULL;\n \n-\tb = (YY_BUFFER_STATE) core_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );\n+\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );\n \tif ( ! b )\n-\t\tYY_FATAL_ERROR( \"out of dynamic memory in core_yy_scan_buffer()\" );\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n \n-\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n+\tb->yy_buf_size = (int) (size - 2);\t/* \"- 2\" to take care of EOB's */\n \tb->yy_buf_pos = b->yy_ch_buf = base;\n \tb->yy_is_our_buffer = 0;\n-\tb->yy_input_file = 0;\n+\tb->yy_input_file = NULL;\n \tb->yy_n_chars = b->yy_buf_size;\n \tb->yy_is_interactive = 0;\n \tb->yy_at_bol = 1;\n \tb->yy_fill_buffer = 0;\n \tb->yy_buffer_status = YY_BUFFER_NEW;\n \n-\tcore_yy_switch_to_buffer(b ,yyscanner );\n+\tyy_switch_to_buffer( b , yyscanner );\n \n \treturn b;\n }\n \n-/** Setup the input buffer state to scan a string. The next call to core_yylex() will\n+/** Setup the input buffer state to scan a string. The next call to yylex() will\n  * scan from a @e copy of @a str.\n  * @param yystr a NUL-terminated string to scan\n  * @param yyscanner The scanner object.\n  * @return the newly allocated buffer state object.\n  * @note If you want to scan bytes that may contain NUL values, then use\n- *       core_yy_scan_bytes() instead.\n+ *       yy_scan_bytes() instead.\n  */\n-YY_BUFFER_STATE core_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)\n+YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)\n {\n     \n-\treturn core_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);\n+\treturn yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);\n }\n \n-/** Setup the input buffer state to scan the given bytes. The next call to core_yylex() will\n+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n  * scan from a @e copy of @a bytes.\n- * @param bytes the byte buffer to scan\n- * @param len the number of bytes in the buffer pointed to by @a bytes.\n+ * @param yybytes the byte buffer to scan\n+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n  * @param yyscanner The scanner object.\n  * @return the newly allocated buffer state object.\n  */\n-YY_BUFFER_STATE core_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)\n+YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)\n {\n \tYY_BUFFER_STATE b;\n \tchar *buf;\n-\tyy_size_t n, i;\n+\tyy_size_t n;\n+\tyy_size_t i;\n     \n \t/* Get memory for full buffer, including space for trailing EOB's. */\n-\tn = _yybytes_len + 2;\n-\tbuf = (char *) core_yyalloc(n ,yyscanner );\n+\tn = (yy_size_t) (_yybytes_len + 2);\n+\tbuf = (char *) yyalloc( n , yyscanner );\n \tif ( ! buf )\n-\t\tYY_FATAL_ERROR( \"out of dynamic memory in core_yy_scan_bytes()\" );\n+\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n \n \tfor ( i = 0; i < _yybytes_len; ++i )\n \t\tbuf[i] = yybytes[i];\n \n \tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n \n-\tb = core_yy_scan_buffer(buf,n ,yyscanner);\n+\tb = yy_scan_buffer( buf, n , yyscanner);\n \tif ( ! b )\n-\t\tYY_FATAL_ERROR( \"bad buffer in core_yy_scan_bytes()\" );\n+\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n \n \t/* It's okay to grow etc. this buffer, and we should throw it\n \t * away when we're done.\n@@ -3192,9 +3426,11 @@ YY_BUFFER_STATE core_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes\n #define YY_EXIT_FAILURE 2\n #endif\n \n-static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)\n+static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)\n {\n-    \t//( stderr, \"%s\\n\", msg );\n+\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n+\t(void)yyg;\n+\t//( stderr, \"%s\\n\", msg );\n \tthrow std::runtime_error(msg); // YY_EXIT_FAILURE );\n }\n \n@@ -3205,7 +3441,7 @@ static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)\n \tdo \\\n \t\t{ \\\n \t\t/* Undo effects of setting up yytext. */ \\\n-        int yyless_macro_arg = (n); \\\n+        yy_size_t yyless_macro_arg = (n); \\\n         YY_LESS_LINENO(yyless_macro_arg);\\\n \t\tyytext[yyleng] = yyg->yy_hold_char; \\\n \t\tyyg->yy_c_buf_p = yytext + yyless_macro_arg; \\\n@@ -3220,7 +3456,7 @@ static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)\n /** Get the user-defined data for this scanner.\n  * @param yyscanner The scanner object.\n  */\n-YY_EXTRA_TYPE core_yyget_extra  (yyscan_t yyscanner)\n+YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     return yyextra;\n@@ -3229,10 +3465,10 @@ YY_EXTRA_TYPE core_yyget_extra  (yyscan_t yyscanner)\n /** Get the current line number.\n  * @param yyscanner The scanner object.\n  */\n-int core_yyget_lineno  (yyscan_t yyscanner)\n+int yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -3242,10 +3478,10 @@ int core_yyget_lineno  (yyscan_t yyscanner)\n /** Get the current column number.\n  * @param yyscanner The scanner object.\n  */\n-int core_yyget_column  (yyscan_t yyscanner)\n+int yyget_column  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -3255,7 +3491,7 @@ int core_yyget_column  (yyscan_t yyscanner)\n /** Get the input stream.\n  * @param yyscanner The scanner object.\n  */\n-FILE *core_yyget_in  (yyscan_t yyscanner)\n+FILE *yyget_in  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     return yyin;\n@@ -3264,7 +3500,7 @@ FILE *core_yyget_in  (yyscan_t yyscanner)\n /** Get the output stream.\n  * @param yyscanner The scanner object.\n  */\n-FILE *core_yyget_out  (yyscan_t yyscanner)\n+FILE *yyget_out  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     return yyout;\n@@ -3273,7 +3509,7 @@ FILE *core_yyget_out  (yyscan_t yyscanner)\n /** Get the length of the current token.\n  * @param yyscanner The scanner object.\n  */\n-yy_size_t core_yyget_leng  (yyscan_t yyscanner)\n+yy_size_t yyget_leng  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     return yyleng;\n@@ -3283,7 +3519,7 @@ yy_size_t core_yyget_leng  (yyscan_t yyscanner)\n  * @param yyscanner The scanner object.\n  */\n \n-char *core_yyget_text  (yyscan_t yyscanner)\n+char *yyget_text  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     return yytext;\n@@ -3293,93 +3529,93 @@ char *core_yyget_text  (yyscan_t yyscanner)\n  * @param user_defined The data to be associated with this scanner.\n  * @param yyscanner The scanner object.\n  */\n-void core_yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)\n+void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     yyextra = user_defined ;\n }\n \n /** Set the current line number.\n- * @param line_number\n+ * @param _line_number line number\n  * @param yyscanner The scanner object.\n  */\n-void core_yyset_lineno (int  line_number , yyscan_t yyscanner)\n+void yyset_lineno (int  _line_number , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \n         /* lineno is only valid if an input buffer exists. */\n         if (! YY_CURRENT_BUFFER )\n-           yy_fatal_error( \"core_yyset_lineno called with no buffer\" , yyscanner); \n+           YY_FATAL_ERROR( \"yyset_lineno called with no buffer\" );\n     \n-    yylineno = line_number;\n+    yylineno = _line_number;\n }\n \n /** Set the current column.\n- * @param line_number\n+ * @param _column_no column number\n  * @param yyscanner The scanner object.\n  */\n-void core_yyset_column (int  column_no , yyscan_t yyscanner)\n+void yyset_column (int  _column_no , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \n         /* column is only valid if an input buffer exists. */\n         if (! YY_CURRENT_BUFFER )\n-           yy_fatal_error( \"core_yyset_column called with no buffer\" , yyscanner); \n+           YY_FATAL_ERROR( \"yyset_column called with no buffer\" );\n     \n-    yycolumn = column_no;\n+    yycolumn = _column_no;\n }\n \n /** Set the input stream. This does not discard the current\n  * input buffer.\n- * @param in_str A readable stream.\n+ * @param _in_str A readable stream.\n  * @param yyscanner The scanner object.\n- * @see core_yy_switch_to_buffer\n+ * @see yy_switch_to_buffer\n  */\n-void core_yyset_in (FILE *  in_str , yyscan_t yyscanner)\n+void yyset_in (FILE *  _in_str , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    yyin = in_str ;\n+    yyin = _in_str ;\n }\n \n-void core_yyset_out (FILE *  out_str , yyscan_t yyscanner)\n+void yyset_out (FILE *  _out_str , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    yyout = out_str ;\n+    yyout = _out_str ;\n }\n \n-int core_yyget_debug  (yyscan_t yyscanner)\n+int yyget_debug  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     return yy_flex_debug;\n }\n \n-void core_yyset_debug (int  bdebug , yyscan_t yyscanner)\n+void yyset_debug (int  _bdebug , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    yy_flex_debug = bdebug ;\n+    yy_flex_debug = _bdebug ;\n }\n \n /* Accessor methods for yylval and yylloc */\n \n-YYSTYPE * core_yyget_lval  (yyscan_t yyscanner)\n+YYSTYPE * yyget_lval  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     return yylval;\n }\n \n-void core_yyset_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)\n+void yyset_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     yylval = yylval_param;\n }\n \n-YYLTYPE *core_yyget_lloc  (yyscan_t yyscanner)\n+YYLTYPE *yyget_lloc  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     return yylloc;\n }\n     \n-void core_yyset_lloc (YYLTYPE *  yylloc_param , yyscan_t yyscanner)\n+void yyset_lloc (YYLTYPE *  yylloc_param , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     yylloc = yylloc_param;\n@@ -3387,20 +3623,18 @@ void core_yyset_lloc (YYLTYPE *  yylloc_param , yyscan_t yyscanner)\n     \n /* User-visible API */\n \n-/* core_yylex_init is special because it creates the scanner itself, so it is\n+/* yylex_init is special because it creates the scanner itself, so it is\n  * the ONLY reentrant function that doesn't take the scanner as the last argument.\n  * That's why we explicitly handle the declaration, instead of using our macros.\n  */\n-\n-int core_yylex_init(yyscan_t* ptr_yy_globals)\n-\n+int yylex_init(yyscan_t* ptr_yy_globals)\n {\n     if (ptr_yy_globals == NULL){\n         errno = EINVAL;\n         return 1;\n     }\n \n-    *ptr_yy_globals = (yyscan_t) core_yyalloc ( sizeof( struct yyguts_t ), NULL );\n+    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );\n \n     if (*ptr_yy_globals == NULL){\n         errno = ENOMEM;\n@@ -3413,39 +3647,37 @@ int core_yylex_init(yyscan_t* ptr_yy_globals)\n     return yy_init_globals ( *ptr_yy_globals );\n }\n \n-/* core_yylex_init_extra has the same functionality as core_yylex_init, but follows the\n+/* yylex_init_extra has the same functionality as yylex_init, but follows the\n  * convention of taking the scanner as the last argument. Note however, that\n  * this is a *pointer* to a scanner, as it will be allocated by this call (and\n  * is the reason, too, why this function also must handle its own declaration).\n- * The user defined value in the first argument will be available to core_yyalloc in\n+ * The user defined value in the first argument will be available to yyalloc in\n  * the yyextra field.\n  */\n-\n-int core_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n-\n+int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )\n {\n     struct yyguts_t dummy_yyguts;\n \n-    core_yyset_extra (yy_user_defined, &dummy_yyguts);\n+    yyset_extra (yy_user_defined, &dummy_yyguts);\n \n     if (ptr_yy_globals == NULL){\n         errno = EINVAL;\n         return 1;\n     }\n-\t\n-    *ptr_yy_globals = (yyscan_t) core_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n-\t\n+\n+    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n+\n     if (*ptr_yy_globals == NULL){\n         errno = ENOMEM;\n         return 1;\n     }\n-    \n+\n     /* By setting to 0xAA, we expose bugs in\n     yy_init_globals. Leave at 0x00 for releases. */\n     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n-    \n-    core_yyset_extra (yy_user_defined, *ptr_yy_globals);\n-    \n+\n+    yyset_extra (yy_user_defined, *ptr_yy_globals);\n+\n     return yy_init_globals ( *ptr_yy_globals );\n }\n \n@@ -3453,13 +3685,13 @@ static int yy_init_globals (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     /* Initialization is the same as for the non-reentrant scanner.\n-     * This function is called from core_yylex_destroy(), so don't allocate here.\n+     * This function is called from yylex_destroy(), so don't allocate here.\n      */\n \n-    yyg->yy_buffer_stack = 0;\n+    yyg->yy_buffer_stack = NULL;\n     yyg->yy_buffer_stack_top = 0;\n     yyg->yy_buffer_stack_max = 0;\n-    yyg->yy_c_buf_p = (char *) 0;\n+    yyg->yy_c_buf_p = NULL;\n     yyg->yy_init = 0;\n     yyg->yy_start = 0;\n \n@@ -3468,41 +3700,46 @@ static int yy_init_globals (yyscan_t yyscanner)\n     yyg->yy_start_stack =  NULL;\n \n /* Defined in main.c */\n-    yyin = (FILE *) 0;\n-    yyout = (FILE *) 0;\n+#ifdef YY_STDINIT\n+    yyin = stdin;\n+    yyout = stdout;\n+#else\n+    yyin = NULL;\n+    yyout = NULL;\n+#endif\n \n     /* For future reference: Set errno on error, since we are called by\n-     * core_yylex_init()\n+     * yylex_init()\n      */\n     return 0;\n }\n \n-/* core_yylex_destroy is for both reentrant and non-reentrant scanners. */\n-int core_yylex_destroy  (yyscan_t yyscanner)\n+/* yylex_destroy is for both reentrant and non-reentrant scanners. */\n+int yylex_destroy  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \n     /* Pop the buffer stack, destroying each element. */\n \twhile(YY_CURRENT_BUFFER){\n-\t\tcore_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner );\n+\t\tyy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );\n \t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n-\t\tcore_yypop_buffer_state(yyscanner);\n+\t\tyypop_buffer_state(yyscanner);\n \t}\n \n \t/* Destroy the stack itself. */\n-\tcore_yyfree(yyg->yy_buffer_stack ,yyscanner);\n+\tyyfree(yyg->yy_buffer_stack , yyscanner);\n \tyyg->yy_buffer_stack = NULL;\n \n     /* Destroy the start condition stack. */\n-        core_yyfree(yyg->yy_start_stack ,yyscanner );\n+        yyfree( yyg->yy_start_stack , yyscanner );\n         yyg->yy_start_stack = NULL;\n \n     /* Reset the globals. This is important in a non-reentrant scanner so the next time\n-     * core_yylex() is called, initialization will occur. */\n+     * yylex() is called, initialization will occur. */\n     yy_init_globals( yyscanner);\n \n     /* Destroy the main struct (reentrant only). */\n-    core_yyfree ( yyscanner , yyscanner );\n+    yyfree ( yyscanner , yyscanner );\n     yyscanner = NULL;\n     return 0;\n }\n@@ -3512,8 +3749,11 @@ int core_yylex_destroy  (yyscan_t yyscanner)\n  */\n \n #ifndef yytext_ptr\n-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)\n+static void yy_flex_strncpy (char* s1, const char * s2, int n , yyscan_t yyscanner)\n {\n+\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n+\t(void)yyg;\n+\n \tint i;\n \tfor ( i = 0; i < n; ++i )\n \t\ts1[i] = s2[i];\n@@ -3521,7 +3761,7 @@ static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yysca\n #endif\n \n #ifdef YY_NEED_STRLEN\n-static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)\n+static int yy_flex_strlen (const char * s , yyscan_t yyscanner)\n {\n \tint n;\n \tfor ( n = 0; s[n]; ++n )\n@@ -3536,11 +3776,10 @@ static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)\n #line 1083 \"third_party/libpg_query/scan.l\"\n \n \n-\n /* LCOV_EXCL_STOP */\n \n /*\n- * Arrange access to yyextra for subroutines of the main core_yylex() function.\n+ * Arrange access to yyextra for subroutines of the main yylex() function.\n  * We expect each subroutine to have a yyscanner parameter.  Rather than\n  * use the yyget_xxx functions, which might or might not get inlined by the\n  * compiler, we cheat just a bit and cast yyscanner to the right type.\n@@ -3585,7 +3824,7 @@ scanner_errposition(int location, core_yyscan_t yyscanner)\n  *\t\tReport a lexer or grammar error.\n  *\n  * The message's cursor position is whatever YYLLOC was last set to,\n- * ie, the start of the current token if called within core_yylex(), or the\n+ * ie, the start of the current token if called within yylex(), or the\n  * most recently lexed token if called from the grammar.\n  * This is OK for syntax error messages from the Bison parser, because Bison\n  * parsers report error as soon as the first unparsable token is reached.\n@@ -3628,8 +3867,8 @@ scanner_init(const char *str,\n \tPGSize\t\tslen = strlen(str);\n \tyyscan_t\tscanner;\n \n-\tif (core_yylex_init(&scanner) != 0)\n-\t\telog(ERROR, \"core_yylex_init() failed: %m\");\n+\tif (yylex_init(&scanner) != 0)\n+\t\telog(ERROR, \"yylex_init() failed: %m\");\n \n \tcore_yyset_extra(yyext, scanner);\n \n@@ -3647,7 +3886,7 @@ scanner_init(const char *str,\n \tyyext->scanbuflen = slen;\n \tmemcpy(yyext->scanbuf, str, slen);\n \tyyext->scanbuf[slen] = yyext->scanbuf[slen + 1] = YY_END_OF_BUFFER_CHAR;\n-\tcore_yy_scan_buffer(yyext->scanbuf,slen + 2,scanner);\n+\tyy_scan_buffer(yyext->scanbuf, slen + 2, scanner);\n \n \t/* initialize literal buffer to a reasonable but expansible size */\n \tyyext->literalalloc = 1024;\n@@ -3665,7 +3904,7 @@ void\n scanner_finish(core_yyscan_t yyscanner)\n {\n \t/*\n-\t * We don't bother to call core_yylex_destroy(), because all it would do is\n+\t * We don't bother to call yylex_destroy(), because all it would do is\n \t * pfree a small amount of control storage.  It's cheaper to leak the\n \t * storage until the parsing context is destroyed.  The amount of space\n \t * involved is usually negligible compared to the output parse tree\n",
  "test_patch": "diff --git a/test/sql/parser/unreserved_keyword_casing.test b/test/sql/parser/unreserved_keyword_casing.test\nnew file mode 100644\nindex 000000000000..34a116a94e53\n--- /dev/null\n+++ b/test/sql/parser/unreserved_keyword_casing.test\n@@ -0,0 +1,16 @@\n+# name: test/sql/parser/unreserved_keyword_casing.test\n+# description: Issue #6092 - Unreserved keywords used as column names don't retain their casing\n+# group: [parser]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE people(Name VARCHAR, STATE VARCHAR, Country VARCHAR);\n+\n+query IIIIII\n+DESCRIBE people\n+----\n+Name\tVARCHAR\tYES\tNULL\tNULL\tNULL\n+STATE\tVARCHAR\tYES\tNULL\tNULL\tNULL\n+Country\tVARCHAR\tYES\tNULL\tNULL\tNULL\n",
  "problem_statement": "Unreserved keywords used as column names don't retain their casing\n### What happens?\r\n\r\nUnreserved keywords used as column names don't retain their casing and are automatically lower-cased.\r\n\r\n### To Reproduce\r\n\r\n`name` is an unreserved keyword:\r\n```\r\nD select * from duckdb_keywords() where keyword_name = 'name';\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 keyword_name \u2502 keyword_category \u2502\r\n\u2502   varchar    \u2502     varchar      \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 name         \u2502 unreserved       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nWhen using `name` in a `create table` statement it is automatically lower-cased:\r\n```\r\nD CREATE TABLE people(Name VARCHAR, STATE VARCHAR, Country VARCHAR);\r\nD .schema people\r\nCREATE TABLE people(\"name\" VARCHAR, \"STATE\" VARCHAR, \"Country\" VARCHAR);;\r\n```\r\n\r\nI was expecting `name` to keep its casing (like the other column names do) as per [this PR](https://github.com/duckdb/duckdb/pull/2919) and [these docs](https://duckdb.org/2022/05/04/friendlier-sql.html):\r\n> DuckDB allows queries to be case insensitive, while maintaining the specified case as data flows into and out of the system.\r\n\r\n### OS:\r\n\r\nmacos arm64\r\n\r\n### DuckDB Version:\r\n\r\nv0.6.0 2213f9c946\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nOliver Mannion\r\n\r\n### Affiliation:\r\n\r\nXero\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\nUnreserved keywords used as column names don't retain their casing\n### What happens?\r\n\r\nUnreserved keywords used as column names don't retain their casing and are automatically lower-cased.\r\n\r\n### To Reproduce\r\n\r\n`name` is an unreserved keyword:\r\n```\r\nD select * from duckdb_keywords() where keyword_name = 'name';\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 keyword_name \u2502 keyword_category \u2502\r\n\u2502   varchar    \u2502     varchar      \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 name         \u2502 unreserved       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nWhen using `name` in a `create table` statement it is automatically lower-cased:\r\n```\r\nD CREATE TABLE people(Name VARCHAR, STATE VARCHAR, Country VARCHAR);\r\nD .schema people\r\nCREATE TABLE people(\"name\" VARCHAR, \"STATE\" VARCHAR, \"Country\" VARCHAR);;\r\n```\r\n\r\nI was expecting `name` to keep its casing (like the other column names do) as per [this PR](https://github.com/duckdb/duckdb/pull/2919) and [these docs](https://duckdb.org/2022/05/04/friendlier-sql.html):\r\n> DuckDB allows queries to be case insensitive, while maintaining the specified case as data flows into and out of the system.\r\n\r\n### OS:\r\n\r\nmacos arm64\r\n\r\n### DuckDB Version:\r\n\r\nv0.6.0 2213f9c946\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nOliver Mannion\r\n\r\n### Affiliation:\r\n\r\nXero\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "\n",
  "created_at": "2023-02-06T16:10:39Z"
}