{
  "repo": "duckdb/duckdb",
  "pull_number": 10789,
  "instance_id": "duckdb__duckdb-10789",
  "issue_numbers": [
    "9915"
  ],
  "base_commit": "431627ef4d4d0f5c33d558fec3681740f0c02ddb",
  "patch": "diff --git a/src/execution/operator/persistent/physical_insert.cpp b/src/execution/operator/persistent/physical_insert.cpp\nindex 1dd14127d232..bf711935d6f9 100644\n--- a/src/execution/operator/persistent/physical_insert.cpp\n+++ b/src/execution/operator/persistent/physical_insert.cpp\n@@ -431,14 +431,13 @@ SinkResultType PhysicalInsert::Sink(ExecutionContext &context, DataChunk &chunk,\n \t\t\tgstate.initialized = true;\n \t\t}\n \n+\t\tif (return_chunk) {\n+\t\t\tgstate.return_collection.Append(lstate.insert_chunk);\n+\t\t}\n \t\tidx_t updated_tuples = OnConflictHandling(table, context, lstate);\n \t\tgstate.insert_count += lstate.insert_chunk.size();\n \t\tgstate.insert_count += updated_tuples;\n \t\tstorage.LocalAppend(gstate.append_state, table, context.client, lstate.insert_chunk, true);\n-\n-\t\tif (return_chunk) {\n-\t\t\tgstate.return_collection.Append(lstate.insert_chunk);\n-\t\t}\n \t} else {\n \t\tD_ASSERT(!return_chunk);\n \t\t// parallel append\ndiff --git a/src/planner/binder/statement/bind_insert.cpp b/src/planner/binder/statement/bind_insert.cpp\nindex d8a252af077d..d0827fde2ebb 100644\n--- a/src/planner/binder/statement/bind_insert.cpp\n+++ b/src/planner/binder/statement/bind_insert.cpp\n@@ -259,18 +259,21 @@ void Binder::BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &tabl\n \t\t\tif (!index.is_unique) {\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\t// does this work with multi-column indexes?\n \t\t\tauto &indexed_columns = index.column_set;\n+\t\t\tbool matches = false;\n \t\t\tfor (auto &column : table.GetColumns().Physical()) {\n \t\t\t\tif (indexed_columns.count(column.Physical().index)) {\n-\t\t\t\t\tfound_matching_indexes++;\n+\t\t\t\t\tmatches = true;\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tfound_matching_indexes += matches;\n \t\t}\n+\n \t\tif (!found_matching_indexes) {\n \t\t\tthrow BinderException(\n \t\t\t    \"There are no UNIQUE/PRIMARY KEY Indexes that refer to this table, ON CONFLICT is a no-op\");\n-\t\t} else if (storage_info.index_info.size() != 1) {\n+\t\t} else if (found_matching_indexes != 1) {\n \t\t\tif (insert.action_type != OnConflictAction::NOTHING) {\n \t\t\t\t// When no conflict target is provided, and the action type is UPDATE,\n \t\t\t\t// we only allow the operation when only a single Index exists\n",
  "test_patch": "diff --git a/test/sql/upsert/insert_or_replace/pk_and_non_unique_index.test b/test/sql/upsert/insert_or_replace/pk_and_non_unique_index.test\nnew file mode 100644\nindex 000000000000..f7fd8d89919d\n--- /dev/null\n+++ b/test/sql/upsert/insert_or_replace/pk_and_non_unique_index.test\n@@ -0,0 +1,25 @@\n+# name: test/sql/upsert/insert_or_replace/pk_and_non_unique_index.test\n+# group: [insert_or_replace]\n+\n+# Single primary key on multiple columns (with non-unique INDEX)\n+statement ok\n+create table tbl(\n+\ta int,\n+\tb int,\n+\tc int,\n+\tprimary key(a,b,c)\n+);\n+\n+statement ok\n+create index non_unique on tbl(b);\n+\n+statement ok\n+insert or replace into tbl values (1,2,3);\n+\n+statement ok\n+insert or replace into tbl values (1,2,3);\n+\n+query III\n+select * from tbl;\n+----\n+1\t2\t3\ndiff --git a/test/sql/upsert/insert_or_replace/primary_key.test b/test/sql/upsert/insert_or_replace/primary_key.test\nnew file mode 100644\nindex 000000000000..6d641bf9b9ce\n--- /dev/null\n+++ b/test/sql/upsert/insert_or_replace/primary_key.test\n@@ -0,0 +1,22 @@\n+# name: test/sql/upsert/insert_or_replace/primary_key.test\n+# group: [insert_or_replace]\n+\n+# Single primary key on multiple columns\n+statement ok\n+create table tbl(\n+\ta int,\n+\tb int,\n+\tc int,\n+\tprimary key(a,b,c)\n+);\n+\n+statement ok\n+insert or replace into tbl values (1,2,3);\n+\n+statement ok\n+insert or replace into tbl values (1,2,3);\n+\n+query III\n+select * from tbl;\n+----\n+1\t2\t3\ndiff --git a/test/sql/upsert/insert_or_replace/returning.test b/test/sql/upsert/insert_or_replace/returning.test\nnew file mode 100644\nindex 000000000000..ff653cf2504e\n--- /dev/null\n+++ b/test/sql/upsert/insert_or_replace/returning.test\n@@ -0,0 +1,24 @@\n+# name: test/sql/upsert/insert_or_replace/returning.test\n+# group: [insert_or_replace]\n+\n+statement ok\n+create table foo(\n+\tbar text primary key,\n+\tbaz bigint,\n+);\n+\n+query I\n+insert or replace into foo(bar, baz) values ('baz', 1) returning bar;\n+----\n+baz\n+\n+query I\n+insert or replace into foo(bar, baz) values ('baz', 2) returning bar;\n+----\n+baz\n+\n+query I\n+insert or replace into foo(bar, baz) values ('baz', 1), ('bar', 2) returning bar;\n+----\n+baz\n+bar\ndiff --git a/test/sql/upsert/insert_or_replace/unique_and_non_unique_index.test b/test/sql/upsert/insert_or_replace/unique_and_non_unique_index.test\nnew file mode 100644\nindex 000000000000..2f8d082c6806\n--- /dev/null\n+++ b/test/sql/upsert/insert_or_replace/unique_and_non_unique_index.test\n@@ -0,0 +1,27 @@\n+# name: test/sql/upsert/insert_or_replace/unique_and_non_unique_index.test\n+# group: [insert_or_replace]\n+\n+# Single UNIQUE INDEX + non-unique INDEX\n+statement ok\n+create table tbl(\n+\ta int,\n+\tb int,\n+\tc int\n+);\n+\n+statement ok\n+create UNIQUE index \"unique\" on tbl(a, b);\n+\n+statement ok\n+create index non_unique on tbl(a, b);\n+\n+statement ok\n+insert or replace into tbl values (1,2,3);\n+\n+statement ok\n+insert or replace into tbl values (1,2,3);\n+\n+query III\n+select * from tbl;\n+----\n+1\t2\t3\ndiff --git a/test/sql/upsert/insert_or_replace/unique_constraint.test b/test/sql/upsert/insert_or_replace/unique_constraint.test\nnew file mode 100644\nindex 000000000000..efa0574c9272\n--- /dev/null\n+++ b/test/sql/upsert/insert_or_replace/unique_constraint.test\n@@ -0,0 +1,33 @@\n+# name: test/sql/upsert/insert_or_replace/unique_constraint.test\n+# group: [insert_or_replace]\n+\n+# Single UNIQUE CONSTRAINT\n+statement ok\n+create table tbl(\n+\ta int unique,\n+\tb int\n+);\n+\n+statement ok\n+insert or replace into tbl values(1, 2);\n+\n+statement ok\n+insert or replace into tbl values(1, 2);\n+\n+query II\n+select * from tbl;\n+----\n+1\t2\n+\n+# Multiple UNIQUE CONSTRAINTs\n+statement ok\n+create table multiple_unique(\n+\ta int unique,\n+\tb int unique,\n+\tc int\n+);\n+\n+statement error\n+insert or replace into multiple_unique values(1, 2, 3);\n+----\n+Binder Error: Conflict target has to be provided for a DO UPDATE operation when the table has multiple UNIQUE/PRIMARY KEY constraints\ndiff --git a/test/sql/upsert/insert_or_replace/unique_constraint_and_non_unique_index.test b/test/sql/upsert/insert_or_replace/unique_constraint_and_non_unique_index.test\nnew file mode 100644\nindex 000000000000..4acd520cb85e\n--- /dev/null\n+++ b/test/sql/upsert/insert_or_replace/unique_constraint_and_non_unique_index.test\n@@ -0,0 +1,36 @@\n+# name: test/sql/upsert/insert_or_replace/unique_constraint_and_non_unique_index.test\n+# group: [insert_or_replace]\n+\n+# Single UNIQUE CONSTRAINT\n+statement ok\n+create table tbl(\n+\ta int unique,\n+\tb int\n+);\n+\n+statement ok\n+create index non_unique on tbl(a, b);\n+\n+statement ok\n+insert or replace into tbl values(1, 2);\n+\n+statement ok\n+insert or replace into tbl values(1, 2);\n+\n+query II\n+select * from tbl;\n+----\n+1\t2\n+\n+# Multiple UNIQUE CONSTRAINTs\n+statement ok\n+create table multiple_unique(\n+\ta int unique,\n+\tb int unique,\n+\tc int\n+);\n+\n+statement error\n+insert or replace into multiple_unique values(1, 2, 3);\n+----\n+Binder Error: Conflict target has to be provided for a DO UPDATE operation when the table has multiple UNIQUE/PRIMARY KEY constraints\ndiff --git a/test/sql/upsert/insert_or_replace/unique_index.test b/test/sql/upsert/insert_or_replace/unique_index.test\nnew file mode 100644\nindex 000000000000..5a06119702eb\n--- /dev/null\n+++ b/test/sql/upsert/insert_or_replace/unique_index.test\n@@ -0,0 +1,33 @@\n+# name: test/sql/upsert/insert_or_replace/unique_index.test\n+# group: [insert_or_replace]\n+\n+# Single UNIQUE INDEX\n+statement ok\n+create table tbl(\n+\ta int,\n+\tb int,\n+\tc int\n+);\n+\n+statement ok\n+create UNIQUE index \"unique\" on tbl(a, b);\n+\n+statement ok\n+insert or replace into tbl values (1,2,3);\n+\n+statement ok\n+insert or replace into tbl values (1,2,3);\n+\n+query III\n+select * from tbl;\n+----\n+1\t2\t3\n+\n+# Multiple UNIQUE INDEXes\n+statement ok\n+create unique index idx3 on tbl(b, c);\n+\n+statement error\n+insert or replace into tbl values (1,2,3);\n+----\n+Binder Error: Conflict target has to be provided for a DO UPDATE operation when the table has multiple UNIQUE/PRIMARY KEY constraints\ndiff --git a/test/sql/upsert/insert_or_replace_ambiguity.test b/test/sql/upsert/insert_or_replace_ambiguity.test\ndeleted file mode 100644\nindex 0e25f4ec3c41..000000000000\n--- a/test/sql/upsert/insert_or_replace_ambiguity.test\n+++ /dev/null\n@@ -1,84 +0,0 @@\n-# name: test/sql/upsert/insert_or_replace_ambiguity.test\n-# group: [upsert]\n-\n-# Single primary key on multiple columns\n-statement ok\n-create table single_pk(\n-\ta int,\n-\tb int,\n-\tc int,\n-\tprimary key(a,b,c)\n-);\n-\n-statement ok\n-insert or replace into single_pk values (1,2,3);\n-\n-statement ok\n-insert or replace into single_pk values (1,2,3);\n-\n-query III\n-select * from single_pk;\n-----\n-1\t2\t3\n-\n-# Single UNIQUE INDEX\n-statement ok\n-create table using_index(\n-\ta int,\n-\tb int,\n-\tc int\n-);\n-\n-statement ok\n-create UNIQUE index idx2 on using_index(a, b);\n-\n-statement ok\n-insert or replace into using_index values (1,2,3);\n-\n-statement ok\n-insert or replace into using_index values (1,2,3);\n-\n-query III\n-select * from using_index;\n-----\n-1\t2\t3\n-\n-# Multiple UNIQUE INDEXes\n-statement ok\n-create unique index idx3 on using_index(b, c);\n-\n-statement error\n-insert or replace into using_index values (1,2,3);\n-----\n-Binder Error: Conflict target has to be provided for a DO UPDATE operation when the table has multiple UNIQUE/PRIMARY KEY constraints\n-\n-# Single UNIQUE CONSTRAINT\n-statement ok\n-create table single_unique(\n-\ta int unique,\n-\tb int\n-);\n-\n-statement ok\n-insert or replace into single_unique values(1, 2);\n-\n-statement ok\n-insert or replace into single_unique values(1, 2);\n-\n-query II\n-select * from single_unique;\n-----\n-1\t2\n-\n-# Multiple UNIQUE CONSTRAINTs\n-statement ok\n-create table multiple_unique(\n-\ta int unique,\n-\tb int unique,\n-\tc int\n-);\n-\n-statement error\n-insert or replace into multiple_unique values(1, 2, 3);\n-----\n-Binder Error: Conflict target has to be provided for a DO UPDATE operation when the table has multiple UNIQUE/PRIMARY KEY constraints\n",
  "problem_statement": "Insert or replace returning behaves inconsistently.\n### What happens?\n\nIf I do `insert or replace ... returning`, the query actually returns something only when an `insert` happens, but not when the `replace` happens.\r\n\r\nI sort of get _why_ it's happening, since `update returning` seems not to be documented/defined, but it still caught me by surprise. From one point of view it's even the correct behavior - `insert returning` should return the inserted rows, and the `or replace` gets transformed into an `update`, so nothing is actually inserted, and nothing should be returned. It's just a bit confusing since the `replace` keyword suggests a replace happens every time. For the time being I can do `delete -> insert returning` instead.\n\n### To Reproduce\n\n```\r\n\ud83e\udd86 create table foo(bar text primary key);\r\n\ud83e\udd86 insert or replace into foo(bar) values ('baz') returning bar;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   bar   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 baz     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\ud83e\udd86 insert or replace into foo(bar) values ('baz') returning bar;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   bar   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0 rows  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n\n### OS:\n\nUbuntu x64 in WSL on Windows 11\n\n### DuckDB Version:\n\nv0.9.2 3c695d7ba9\n\n### DuckDB Client:\n\ncli and python\n\n### Full Name:\n\nM\u00edma Hlav\u00e1\u010dek\n\n### Affiliation:\n\nBlindspot.ai\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "Thanks for reporting it, will discuss this internally.\r\n\r\nWe'll definitely include this case in the `INSERT INTO` documentation page, which is just being reworked, see https://github.com/duckdb/duckdb-web/pull/1688",
  "created_at": "2024-02-21T14:38:15Z"
}