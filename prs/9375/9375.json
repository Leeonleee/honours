{
  "repo": "duckdb/duckdb",
  "pull_number": 9375,
  "instance_id": "duckdb__duckdb-9375",
  "issue_numbers": [
    "9367"
  ],
  "base_commit": "2646836f6fa6b47b41b2db0a96f4e9f95a4c6449",
  "patch": "diff --git a/src/catalog/catalog_entry/view_catalog_entry.cpp b/src/catalog/catalog_entry/view_catalog_entry.cpp\nindex 1f41f740bc0c..9c3a12cabdd7 100644\n--- a/src/catalog/catalog_entry/view_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/view_catalog_entry.cpp\n@@ -32,6 +32,7 @@ unique_ptr<CreateInfo> ViewCatalogEntry::GetInfo() const {\n \tresult->query = unique_ptr_cast<SQLStatement, SelectStatement>(query->Copy());\n \tresult->aliases = aliases;\n \tresult->types = types;\n+\tresult->temporary = temporary;\n \treturn std::move(result);\n }\n \n@@ -58,23 +59,16 @@ string ViewCatalogEntry::ToSQL() const {\n \t\t//! Return empty sql with view name so pragma view_tables don't complain\n \t\treturn sql;\n \t}\n-\treturn sql + \"\\n;\";\n+\tauto info = GetInfo();\n+\tauto result = info->ToString();\n+\treturn result + \";\\n\";\n }\n \n unique_ptr<CatalogEntry> ViewCatalogEntry::Copy(ClientContext &context) const {\n \tD_ASSERT(!internal);\n-\tCreateViewInfo create_info(schema, name);\n-\tcreate_info.query = unique_ptr_cast<SQLStatement, SelectStatement>(query->Copy());\n-\tfor (idx_t i = 0; i < aliases.size(); i++) {\n-\t\tcreate_info.aliases.push_back(aliases[i]);\n-\t}\n-\tfor (idx_t i = 0; i < types.size(); i++) {\n-\t\tcreate_info.types.push_back(types[i]);\n-\t}\n-\tcreate_info.temporary = temporary;\n-\tcreate_info.sql = sql;\n+\tauto create_info = GetInfo();\n \n-\treturn make_uniq<ViewCatalogEntry>(catalog, schema, create_info);\n+\treturn make_uniq<ViewCatalogEntry>(catalog, schema, create_info->Cast<CreateViewInfo>());\n }\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/parser/parsed_data/create_info.hpp b/src/include/duckdb/parser/parsed_data/create_info.hpp\nindex 3fd941288236..70e047286d42 100644\n--- a/src/include/duckdb/parser/parsed_data/create_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/create_info.hpp\n@@ -10,6 +10,7 @@\n \n #include \"duckdb/common/enums/catalog_type.hpp\"\n #include \"duckdb/parser/parsed_data/parse_info.hpp\"\n+#include \"duckdb/common/enum_util.hpp\"\n \n namespace duckdb {\n struct AlterInfo;\n@@ -61,6 +62,10 @@ struct CreateInfo : public ParseInfo {\n \tDUCKDB_API void CopyProperties(CreateInfo &other) const;\n \t//! Generates an alter statement from the create statement - used for OnCreateConflict::ALTER_ON_CONFLICT\n \tDUCKDB_API virtual unique_ptr<AlterInfo> GetAlterInfo() const;\n+\tvirtual string ToString() const {\n+\t\tthrow InternalException(\"ToString not supported for this type of CreateInfo: '%s'\",\n+\t\t                        EnumUtil::ToString(info_type));\n+\t}\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/parser/parsed_data/create_view_info.hpp b/src/include/duckdb/parser/parsed_data/create_view_info.hpp\nindex 4f9ff34ba5b7..c70a273c092c 100644\n--- a/src/include/duckdb/parser/parsed_data/create_view_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/create_view_info.hpp\n@@ -15,11 +15,13 @@ namespace duckdb {\n class SchemaCatalogEntry;\n \n struct CreateViewInfo : public CreateInfo {\n+public:\n \tCreateViewInfo();\n \tCreateViewInfo(SchemaCatalogEntry &schema, string view_name);\n \tCreateViewInfo(string catalog_p, string schema_p, string view_name);\n \n-\t//! Table name to insert to\n+public:\n+\t//! View name\n \tstring view_name;\n \t//! Aliases of the view\n \tvector<string> aliases;\n@@ -38,6 +40,7 @@ struct CreateViewInfo : public CreateInfo {\n \n \tDUCKDB_API void Serialize(Serializer &serializer) const override;\n \tDUCKDB_API static unique_ptr<CreateInfo> Deserialize(Deserializer &deserializer);\n+\tstring ToString() const override;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/parser/statement/create_statement.hpp b/src/include/duckdb/parser/statement/create_statement.hpp\nindex 362af2642b9f..74177d873113 100644\n--- a/src/include/duckdb/parser/statement/create_statement.hpp\n+++ b/src/include/duckdb/parser/statement/create_statement.hpp\n@@ -27,6 +27,7 @@ class CreateStatement : public SQLStatement {\n \n public:\n \tunique_ptr<SQLStatement> Copy() const override;\n+\tstring ToString() const override;\n };\n \n } // namespace duckdb\ndiff --git a/src/parser/parsed_data/create_view_info.cpp b/src/parser/parsed_data/create_view_info.cpp\nindex fde4a2c8c4bc..792f2547bb09 100644\n--- a/src/parser/parsed_data/create_view_info.cpp\n+++ b/src/parser/parsed_data/create_view_info.cpp\n@@ -19,6 +19,33 @@ CreateViewInfo::CreateViewInfo(SchemaCatalogEntry &schema, string view_name)\n     : CreateViewInfo(schema.catalog.GetName(), schema.name, std::move(view_name)) {\n }\n \n+string CreateViewInfo::ToString() const {\n+\tstring result;\n+\n+\tresult += \"CREATE\";\n+\tif (on_conflict == OnCreateConflict::REPLACE_ON_CONFLICT) {\n+\t\tresult += \" OR REPLACE\";\n+\t}\n+\tif (temporary) {\n+\t\tresult += \" TEMPORARY\";\n+\t}\n+\tresult += \" VIEW \";\n+\tif (schema != DEFAULT_SCHEMA) {\n+\t\tresult += KeywordHelper::WriteOptionallyQuoted(schema);\n+\t\tresult += \".\";\n+\t}\n+\tresult += KeywordHelper::WriteOptionallyQuoted(view_name);\n+\tif (!aliases.empty()) {\n+\t\tresult += \" (\";\n+\t\tresult += StringUtil::Join(aliases, aliases.size(), \", \",\n+\t\t                           [](const string &name) { return KeywordHelper::WriteOptionallyQuoted(name); });\n+\t\tresult += \")\";\n+\t}\n+\tresult += \" AS \";\n+\tresult += query->ToString();\n+\treturn result;\n+}\n+\n unique_ptr<CreateInfo> CreateViewInfo::Copy() const {\n \tauto result = make_uniq<CreateViewInfo>(catalog, schema, view_name);\n \tCopyProperties(*result);\ndiff --git a/src/parser/statement/create_statement.cpp b/src/parser/statement/create_statement.cpp\nindex 514807f0de2a..fbc86c874716 100644\n--- a/src/parser/statement/create_statement.cpp\n+++ b/src/parser/statement/create_statement.cpp\n@@ -12,4 +12,8 @@ unique_ptr<SQLStatement> CreateStatement::Copy() const {\n \treturn unique_ptr<CreateStatement>(new CreateStatement(*this));\n }\n \n+string CreateStatement::ToString() const {\n+\treturn info->ToString();\n+}\n+\n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/catalog/view/test_view.test b/test/sql/catalog/view/test_view.test\nindex d1979f04afe0..0a34542e58ec 100644\n--- a/test/sql/catalog/view/test_view.test\n+++ b/test/sql/catalog/view/test_view.test\n@@ -13,10 +13,14 @@ statement ok\n INSERT INTO t1 VALUES (41), (42), (43)\n \n statement ok\n-CREATE VIEW v1 AS SELECT i AS j FROM t1 WHERE i < 43\n+CREATE VIEW v1 AS SELECT\n+\ti AS j\n+FROM t1 WHERE i < 43\n \n statement error\n CREATE VIEW v1 AS SELECT 'whatever'\n+----\n+Catalog Error: View with name \"v1\" already exists!\n \n query I\n SELECT j FROM v1 WHERE j > 41\ndiff --git a/test/sql/catalog/view/test_view_schema_change.test b/test/sql/catalog/view/test_view_schema_change.test\nindex ba2bb4f7105d..07567620c7be 100644\n--- a/test/sql/catalog/view/test_view_schema_change.test\n+++ b/test/sql/catalog/view/test_view_schema_change.test\n@@ -68,3 +68,12 @@ query I\n SELECT * FROM v1\n ----\n \n+# Changing the types of the table that the view references also makes the view unusable\n+\n+statement ok\n+ALTER TABLE t1 ALTER i TYPE VARCHAR;\n+\n+statement error\n+select * from v1;\n+----\n+Binder Error: Contents of view were altered: types don't match!\ndiff --git a/test/sql/catalog/view/test_view_sql.test b/test/sql/catalog/view/test_view_sql.test\nnew file mode 100644\nindex 000000000000..6419dc3ee766\n--- /dev/null\n+++ b/test/sql/catalog/view/test_view_sql.test\n@@ -0,0 +1,92 @@\n+# name: test/sql/catalog/view/test_view_sql.test\n+# description: Test behavior of 'sql' on various different views\n+# group: [view]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create schema my_schema;\n+\n+# X contains columns `a` and `y`\n+statement ok\n+CREATE VIEW my_schema.X (a) AS SELECT 'x' as x, 'y' as y;\n+\n+query I\n+select trim(sql, chr(10)) from duckdb_views() where internal = false;\n+----\n+CREATE VIEW my_schema.X (a, y) AS SELECT 'x' AS x, 'y' AS y;\n+\n+statement ok\n+alter view my_schema.X rename to Y;\n+\n+# Properly renamed to Y\n+query I\n+select trim(sql, chr(10)) from duckdb_views() where internal = false;\n+----\n+CREATE VIEW my_schema.Y (a, y) AS SELECT 'x' AS x, 'y' AS y;\n+\n+statement ok\n+drop schema my_schema cascade;\n+\n+query I\n+select trim(sql, chr(10)) from duckdb_views() where internal = false;\n+----\n+\n+statement ok\n+create table tbl (\n+\ta integer,\n+\tb varchar\n+)\n+\n+statement ok\n+create view vw as select * from tbl;\n+\n+# sql is not affected by the column names of the table\n+query I\n+select trim(sql, chr(10)) from duckdb_views() where internal = false;\n+----\n+CREATE VIEW vw (a, b) AS SELECT * FROM tbl;\n+\n+statement ok\n+alter table tbl rename column b to x;\n+\n+# sql is not affected by the column names of the table\n+query I\n+select trim(sql, chr(10)) from duckdb_views() where internal = false;\n+----\n+CREATE VIEW vw (a, b) AS SELECT * FROM tbl;\n+\n+statement ok\n+create or replace view vw (c1, c2) as select * from tbl;\n+\n+statement ok\n+create or replace table \"table name\" (\n+\t\"column name 1\" integer,\n+\t\"column name 2\" varchar\n+)\n+\n+statement ok\n+create or replace view \"view name\" as select * from \"table name\";\n+\n+statement ok\n+drop view vw;\n+\n+query I\n+select trim(sql, chr(10)) from duckdb_views() where internal = false;\n+----\n+CREATE VIEW \"view name\" (\"column name 1\", \"column name 2\") AS SELECT * FROM \"table name\";\n+\n+statement ok\n+drop view \"view name\"\n+\n+statement ok\n+create schema \"schema name\";\n+\n+statement ok\n+CREATE VIEW \"schema name\".\"view name\" (\"other name 1\", \"column name 2\") AS SELECT * FROM \"table name\";\n+\n+query I\n+select trim(sql, chr(10)) from duckdb_views() where internal = false;\n+----\n+CREATE VIEW \"schema name\".\"view name\" (\"other name 1\", \"column name 2\") AS SELECT * FROM \"table name\";\ndiff --git a/test/sql/pg_catalog/sqlalchemy.test b/test/sql/pg_catalog/sqlalchemy.test\nindex 8d910cc6589d..c1775bd65ff5 100644\n--- a/test/sql/pg_catalog/sqlalchemy.test\n+++ b/test/sql/pg_catalog/sqlalchemy.test\n@@ -158,7 +158,7 @@ JOIN pg_namespace n ON n.oid = c.relnamespace\n WHERE n.nspname = 'myschema' AND c.relname = 'v1'\n AND c.relkind IN ('v', 'm')\n ----\n-CREATE VIEW myschema.v1 AS SELECT 42;\n+CREATE VIEW myschema.v1 (\"42\") AS SELECT 42;\n \n # get_columns\n query IIII\ndiff --git a/test/sql/table_function/duckdb_columns.test b/test/sql/table_function/duckdb_columns.test\nindex 6b03d66f1db3..f9dc3c3a18f5 100644\n--- a/test/sql/table_function/duckdb_columns.test\n+++ b/test/sql/table_function/duckdb_columns.test\n@@ -26,3 +26,59 @@ memory\tintegers\ti\tINTEGER\tNULL\tTrue\t32\t2\t0\n memory\ttest\ti\tINTEGER\tNULL\tFalse\t32\t2\t0\n memory\ttest\tj\tDECIMAL(18,3)\tNULL\tTrue\t18\t10\t3\n memory\ttest\tk\tVARCHAR\t'hello'\tTrue\tNULL\tNULL\tNULL\n+\n+statement ok\n+create view v1 as select * from test\n+\n+query II\n+select table_name, column_name from duckdb_columns where table_name = 'v1'\n+----\n+v1\ti\n+v1\tj\n+v1\tk\n+\n+statement ok\n+alter table test rename column j to renamed\n+\n+# Rename of the base table is not reflected in the view's info\n+query II\n+select table_name, column_name from duckdb_columns where table_name = 'v1'\n+----\n+v1\ti\n+v1\tj\n+v1\tk\n+\n+statement ok\n+alter table test rename column renamed to j\n+\n+statement ok\n+create or replace view v1 (a, b) as select * from test;\n+\n+query II\n+select table_name, column_name from duckdb_columns where table_name = 'v1'\n+----\n+v1\ta\n+v1\tb\n+v1\tk\n+\n+statement ok\n+alter table test rename column j to renamed\n+\n+# The rename of 'j' is not reflected in the view's info because it was aliased to 'b'\n+query II\n+select table_name, column_name from duckdb_columns where table_name = 'v1'\n+----\n+v1\ta\n+v1\tb\n+v1\tk\n+\n+statement ok\n+alter table test rename column k to not_k\n+\n+# The rename of 'k' is also not reflected in the view's info even though it was not aliased\n+query II\n+select table_name, column_name from duckdb_columns where table_name = 'v1'\n+----\n+v1\ta\n+v1\tb\n+v1\tk\n",
  "problem_statement": "Export of VIEWs does not respect RENAME\n### What happens?\n\nExporting a view seems to produce original SQL text it was defined with, which doesn't include ALTER VIEW RENAME changes. This is in particular a problem with dbt, since it first creates views with `__dbt_tmp` suffixes and renames as a kind of DDL transaction mechanism.\r\n\r\nhttps://github.com/dbt-labs/dbt-core/blob/efa6339e1804e07f7f47aebccb46492fd897f7f5/core/dbt/include/global_project/macros/adapters/relation.sql#L1-L12\n\n### To Reproduce\n\n```\r\n> duckdb-0.9.1 /tmp/view_name_repro.091.ddb\r\n> duckdb-latest-main /tmp/view_name_repro_latest.ddb\r\nv0.9.2-dev197 a00428dd4a\r\nEnter \".help\" for usage hints.\r\nD create view X as (select 'x');\r\nD alter view X rename to Y;\r\nD .maxwidth 10000\r\nD select view_name, sql from duckdb_views() where internal is false;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 view_name \u2502                sql                \u2502\r\n\u2502  varchar  \u2502              varchar              \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 Y         \u2502 create view X as (select 'x');\\n; \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n  ^\r\nD export database 'view_name_repro_latest_main';\r\n\r\n> cat view_name_repro_latest_main/schema.sql\r\ncreate view X as (select 'x');\r\n            ^ (!!)\r\n\r\n```\n\n### OS:\n\naarch64\n\n### DuckDB Version:\n\n0.9.1\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nNicholas Ursa\n\n### Affiliation:\n\nMotherDuck\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "cc @jwills \nThis came up when we were doing migrations to 0.9.1 of dbt users.",
  "created_at": "2023-10-17T13:34:41Z"
}