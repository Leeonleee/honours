{
  "repo": "duckdb/duckdb",
  "pull_number": 4259,
  "instance_id": "duckdb__duckdb-4259",
  "issue_numbers": [
    "4092"
  ],
  "base_commit": "5f0db8f65176e99b5abac024a5125f9b092d979a",
  "patch": "diff --git a/src/catalog/default/default_functions.cpp b/src/catalog/default/default_functions.cpp\nindex 13fd20abbe9a..82d6759e640a 100644\n--- a/src/catalog/default/default_functions.cpp\n+++ b/src/catalog/default/default_functions.cpp\n@@ -113,6 +113,7 @@ static DefaultMacro internal_macros[] = {\n \t{DEFAULT_SCHEMA, \"list_entropy\", {\"l\", nullptr}, \"list_aggr(l, 'entropy')\"},\n \t{DEFAULT_SCHEMA, \"list_last\", {\"l\", nullptr}, \"list_aggr(l, 'last')\"},\n \t{DEFAULT_SCHEMA, \"list_first\", {\"l\", nullptr}, \"list_aggr(l, 'first')\"},\n+\t{DEFAULT_SCHEMA, \"list_any_value\", {\"l\", nullptr}, \"list_aggr(l, 'any_value')\"},\n \t{DEFAULT_SCHEMA, \"list_kurtosis\", {\"l\", nullptr}, \"list_aggr(l, 'kurtosis')\"},\n \t{DEFAULT_SCHEMA, \"list_min\", {\"l\", nullptr}, \"list_aggr(l, 'min')\"},\n \t{DEFAULT_SCHEMA, \"list_max\", {\"l\", nullptr}, \"list_aggr(l, 'max')\"},\ndiff --git a/src/function/aggregate/distributive/first.cpp b/src/function/aggregate/distributive/first.cpp\nindex 84804ef4f39f..daa900285d8c 100644\n--- a/src/function/aggregate/distributive/first.cpp\n+++ b/src/function/aggregate/distributive/first.cpp\n@@ -24,15 +24,18 @@ struct FirstFunctionBase {\n \t}\n };\n \n-template <bool LAST>\n+template <bool LAST, bool SKIP_NULLS>\n struct FirstFunction : public FirstFunctionBase {\n \ttemplate <class INPUT_TYPE, class STATE, class OP>\n \tstatic void Operation(STATE *state, AggregateInputData &, INPUT_TYPE *input, ValidityMask &mask, idx_t idx) {\n \t\tif (LAST || !state->is_set) {\n-\t\t\tstate->is_set = true;\n \t\t\tif (!mask.RowIsValid(idx)) {\n+\t\t\t\tif (!SKIP_NULLS) {\n+\t\t\t\t\tstate->is_set = true;\n+\t\t\t\t}\n \t\t\t\tstate->is_null = true;\n \t\t\t} else {\n+\t\t\t\tstate->is_set = true;\n \t\t\t\tstate->is_null = false;\n \t\t\t\tstate->value = input[idx];\n \t\t\t}\n@@ -62,14 +65,17 @@ struct FirstFunction : public FirstFunctionBase {\n \t}\n };\n \n-template <bool LAST>\n+template <bool LAST, bool SKIP_NULLS>\n struct FirstFunctionString : public FirstFunctionBase {\n \ttemplate <class STATE>\n \tstatic void SetValue(STATE *state, string_t value, bool is_null) {\n-\t\tstate->is_set = true;\n \t\tif (is_null) {\n-\t\t\tstate->is_null = true;\n+\t\t\tif (!SKIP_NULLS) {\n+\t\t\t\tstate->is_set = true;\n+\t\t\t\tstate->is_null = true;\n+\t\t\t}\n \t\t} else {\n+\t\t\tstate->is_set = true;\n \t\t\tif (value.IsInlined()) {\n \t\t\t\tstate->value = value;\n \t\t\t} else {\n@@ -124,7 +130,7 @@ struct FirstStateVector {\n \tVector *value;\n };\n \n-template <bool LAST>\n+template <bool LAST, bool SKIP_NULLS>\n struct FirstVectorFunction {\n \ttemplate <class STATE>\n \tstatic void Initialize(STATE *state) {\n@@ -138,7 +144,7 @@ struct FirstVectorFunction {\n \t\t}\n \t}\n \tstatic bool IgnoreNull() {\n-\t\treturn false;\n+\t\treturn SKIP_NULLS;\n \t}\n \n \ttemplate <class STATE>\n@@ -154,11 +160,18 @@ struct FirstVectorFunction {\n \n \tstatic void Update(Vector inputs[], AggregateInputData &, idx_t input_count, Vector &state_vector, idx_t count) {\n \t\tauto &input = inputs[0];\n+\t\tUnifiedVectorFormat idata;\n+\t\tinput.ToUnifiedFormat(count, idata);\n+\n \t\tUnifiedVectorFormat sdata;\n \t\tstate_vector.ToUnifiedFormat(count, sdata);\n \n \t\tauto states = (FirstStateVector **)sdata.data;\n \t\tfor (idx_t i = 0; i < count; i++) {\n+\t\t\tconst auto idx = idata.sel->get_index(i);\n+\t\t\tif (SKIP_NULLS && !idata.validity.RowIsValid(idx)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tauto state = states[sdata.sel->get_index(i)];\n \t\t\tif (LAST || !state->value) {\n \t\t\t\tSetValue(state, input, i);\n@@ -197,79 +210,79 @@ struct FirstVectorFunction {\n \t}\n };\n \n-template <class T, bool LAST>\n+template <class T, bool LAST, bool SKIP_NULLS>\n static AggregateFunction GetFirstAggregateTemplated(LogicalType type) {\n-\tauto agg = AggregateFunction::UnaryAggregate<FirstState<T>, T, T, FirstFunction<LAST>>(type, type);\n+\tauto agg = AggregateFunction::UnaryAggregate<FirstState<T>, T, T, FirstFunction<LAST, SKIP_NULLS>>(type, type);\n \treturn agg;\n }\n \n-template <bool LAST>\n+template <bool LAST, bool SKIP_NULLS>\n static AggregateFunction GetFirstFunction(const LogicalType &type);\n \n-template <bool LAST>\n+template <bool LAST, bool SKIP_NULLS>\n AggregateFunction GetDecimalFirstFunction(const LogicalType &type) {\n \tD_ASSERT(type.id() == LogicalTypeId::DECIMAL);\n \tswitch (type.InternalType()) {\n \tcase PhysicalType::INT16:\n-\t\treturn GetFirstFunction<LAST>(LogicalType::SMALLINT);\n+\t\treturn GetFirstFunction<LAST, SKIP_NULLS>(LogicalType::SMALLINT);\n \tcase PhysicalType::INT32:\n-\t\treturn GetFirstFunction<LAST>(LogicalType::INTEGER);\n+\t\treturn GetFirstFunction<LAST, SKIP_NULLS>(LogicalType::INTEGER);\n \tcase PhysicalType::INT64:\n-\t\treturn GetFirstFunction<LAST>(LogicalType::BIGINT);\n+\t\treturn GetFirstFunction<LAST, SKIP_NULLS>(LogicalType::BIGINT);\n \tdefault:\n-\t\treturn GetFirstFunction<LAST>(LogicalType::HUGEINT);\n+\t\treturn GetFirstFunction<LAST, SKIP_NULLS>(LogicalType::HUGEINT);\n \t}\n }\n \n-template <bool LAST>\n+template <bool LAST, bool SKIP_NULLS>\n static AggregateFunction GetFirstFunction(const LogicalType &type) {\n \tswitch (type.id()) {\n \tcase LogicalTypeId::BOOLEAN:\n-\t\treturn GetFirstAggregateTemplated<int8_t, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<int8_t, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::TINYINT:\n-\t\treturn GetFirstAggregateTemplated<int8_t, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<int8_t, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::SMALLINT:\n-\t\treturn GetFirstAggregateTemplated<int16_t, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<int16_t, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::INTEGER:\n \tcase LogicalTypeId::DATE:\n-\t\treturn GetFirstAggregateTemplated<int32_t, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<int32_t, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::BIGINT:\n \tcase LogicalTypeId::TIME:\n \tcase LogicalTypeId::TIMESTAMP:\n \tcase LogicalTypeId::TIME_TZ:\n \tcase LogicalTypeId::TIMESTAMP_TZ:\n-\t\treturn GetFirstAggregateTemplated<int64_t, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<int64_t, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::UTINYINT:\n-\t\treturn GetFirstAggregateTemplated<uint8_t, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<uint8_t, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::USMALLINT:\n-\t\treturn GetFirstAggregateTemplated<uint16_t, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<uint16_t, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::UINTEGER:\n-\t\treturn GetFirstAggregateTemplated<uint32_t, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<uint32_t, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::UBIGINT:\n-\t\treturn GetFirstAggregateTemplated<uint64_t, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<uint64_t, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::HUGEINT:\n-\t\treturn GetFirstAggregateTemplated<hugeint_t, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<hugeint_t, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::FLOAT:\n-\t\treturn GetFirstAggregateTemplated<float, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<float, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::DOUBLE:\n-\t\treturn GetFirstAggregateTemplated<double, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<double, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::INTERVAL:\n-\t\treturn GetFirstAggregateTemplated<interval_t, LAST>(type);\n+\t\treturn GetFirstAggregateTemplated<interval_t, LAST, SKIP_NULLS>(type);\n \tcase LogicalTypeId::VARCHAR:\n \tcase LogicalTypeId::BLOB: {\n \t\tauto agg = AggregateFunction::UnaryAggregateDestructor<FirstState<string_t>, string_t, string_t,\n-\t\t                                                       FirstFunctionString<LAST>>(type, type);\n+\t\t                                                       FirstFunctionString<LAST, SKIP_NULLS>>(type, type);\n \t\treturn agg;\n \t}\n \tcase LogicalTypeId::DECIMAL: {\n \t\ttype.Verify();\n-\t\tAggregateFunction function = GetDecimalFirstFunction<LAST>(type);\n+\t\tAggregateFunction function = GetDecimalFirstFunction<LAST, SKIP_NULLS>(type);\n \t\tfunction.arguments[0] = type;\n \t\tfunction.return_type = type;\n \t\treturn function;\n \t}\n \tdefault: {\n-\t\tusing OP = FirstVectorFunction<LAST>;\n+\t\tusing OP = FirstVectorFunction<LAST, SKIP_NULLS>;\n \t\treturn AggregateFunction({type}, type, AggregateFunction::StateSize<FirstStateVector>,\n \t\t                         AggregateFunction::StateInitialize<FirstStateVector, OP>, OP::Update,\n \t\t                         AggregateFunction::StateCombine<FirstStateVector, OP>,\n@@ -280,16 +293,16 @@ static AggregateFunction GetFirstFunction(const LogicalType &type) {\n }\n \n AggregateFunction FirstFun::GetFunction(const LogicalType &type) {\n-\tauto fun = GetFirstFunction<false>(type);\n+\tauto fun = GetFirstFunction<false, false>(type);\n \tfun.name = \"first\";\n \treturn fun;\n }\n \n-template <bool LAST>\n+template <bool LAST, bool SKIP_NULLS>\n unique_ptr<FunctionData> BindDecimalFirst(ClientContext &context, AggregateFunction &function,\n                                           vector<unique_ptr<Expression>> &arguments) {\n \tauto decimal_type = arguments[0]->return_type;\n-\tfunction = GetFirstFunction<LAST>(decimal_type);\n+\tfunction = GetFirstFunction<LAST, SKIP_NULLS>(decimal_type);\n \tfunction.name = \"first\";\n \tfunction.return_type = decimal_type;\n \treturn nullptr;\n@@ -298,15 +311,19 @@ unique_ptr<FunctionData> BindDecimalFirst(ClientContext &context, AggregateFunct\n void FirstFun::RegisterFunction(BuiltinFunctions &set) {\n \tAggregateFunctionSet first(\"first\");\n \tAggregateFunctionSet last(\"last\");\n+\tAggregateFunctionSet any_value(\"any_value\");\n \tfor (auto &type : LogicalType::AllTypes()) {\n \t\tif (type.id() == LogicalTypeId::DECIMAL) {\n \t\t\tfirst.AddFunction(AggregateFunction({type}, type, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,\n-\t\t\t                                    BindDecimalFirst<false>, nullptr, nullptr, nullptr));\n+\t\t\t                                    BindDecimalFirst<false, false>, nullptr, nullptr, nullptr));\n \t\t\tlast.AddFunction(AggregateFunction({type}, type, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,\n-\t\t\t                                   BindDecimalFirst<true>, nullptr, nullptr, nullptr));\n+\t\t\t                                   BindDecimalFirst<true, false>, nullptr, nullptr, nullptr));\n+\t\t\tany_value.AddFunction(AggregateFunction({type}, type, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,\n+\t\t\t                                        BindDecimalFirst<false, true>, nullptr, nullptr, nullptr));\n \t\t} else {\n-\t\t\tfirst.AddFunction(GetFirstFunction<false>(type));\n-\t\t\tlast.AddFunction(GetFirstFunction<true>(type));\n+\t\t\tfirst.AddFunction(GetFirstFunction<false, false>(type));\n+\t\t\tlast.AddFunction(GetFirstFunction<true, false>(type));\n+\t\t\tany_value.AddFunction(GetFirstFunction<false, true>(type));\n \t\t}\n \t}\n \tset.AddFunction(first);\n@@ -314,6 +331,8 @@ void FirstFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(first);\n \n \tset.AddFunction(last);\n+\n+\tset.AddFunction(any_value);\n }\n \n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/aggregate/aggregates/test_any_value.test b/test/sql/aggregate/aggregates/test_any_value.test\nnew file mode 100644\nindex 000000000000..f1e902dcd389\n--- /dev/null\n+++ b/test/sql/aggregate/aggregates/test_any_value.test\n@@ -0,0 +1,228 @@\n+# name: test/sql/aggregate/aggregates/test_any_value.test\n+# description: Test the ANY_VALUE function\n+# group: [aggregates]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE tbl(i INTEGER)\n+\n+statement ok\n+INSERT INTO tbl VALUES (NULL), (2), (3)\n+\n+# FIRST() here returns NULL\n+query I\n+SELECT ANY_VALUE(i) AS a FROM tbl\n+----\n+2\n+\n+\n+statement ok\n+DROP TABLE tbl\n+\n+#\n+# Test all types\n+#\n+\n+# Numerics\n+foreach type <numeric>\n+\n+statement ok\n+CREATE TABLE five AS SELECT i::${type} AS i FROM range(1, 6, 1) t1(i)\n+\n+query I\n+SELECT ANY_VALUE(i) FROM five\n+----\n+1\n+\n+query II\n+SELECT i % 3 AS g, ANY_VALUE(i) FROM five GROUP BY 1 ORDER BY 1\n+----\n+0\t3\n+1\t1\n+2\t2\n+\n+query I\n+SELECT ANY_VALUE(i ORDER BY 5-i) FROM five\n+----\n+5\n+\n+query II\n+SELECT i % 3 AS g, ANY_VALUE(i ORDER BY 5-i) FROM five GROUP BY 1 ORDER BY 1\n+----\n+0\t3\n+1\t4\n+2\t5\n+\n+statement ok\n+DROP TABLE five\n+\n+endloop\n+\n+# Decimals\n+foreach type decimal(4,1) decimal(8,1) decimal(12,1) decimal(18,1)\n+\n+statement ok\n+CREATE TABLE five AS SELECT i::${type} AS i FROM range(1, 6, 1) t1(i)\n+\n+query I\n+SELECT ANY_VALUE(i ORDER BY 5-i) FROM five\n+----\n+5.0\n+\n+query II\n+SELECT i::INTEGER % 3 AS g, ANY_VALUE(i ORDER BY 5-i) FROM five GROUP BY 1 ORDER BY 1\n+----\n+0\t3.0\n+1\t4.0\n+2\t5.0\n+\n+statement ok\n+DROP TABLE five\n+\n+endloop\n+\n+# Temporal\n+statement ok\n+CREATE TABLE five_dates AS\n+        SELECT 1 AS i,\n+               NULL::DATE AS d,\n+               NULL::TIMESTAMP AS dt,\n+               NULL::TIME AS t,\n+               NULL::INTERVAL AS s\n+        UNION ALL\n+\tSELECT\n+\t\ti::integer AS i,\n+\t\t'2021-08-20'::DATE + i::INTEGER AS d,\n+\t\t'2021-08-20'::TIMESTAMP + INTERVAL (i) HOUR AS dt,\n+\t\t'14:59:37'::TIME + INTERVAL (i) MINUTE AS t,\n+\t\tINTERVAL (i) SECOND AS s\n+\tFROM range(1, 6, 1) t1(i)\n+\n+query IIII\n+SELECT ANY_VALUE(d), ANY_VALUE(dt), ANY_VALUE(t), ANY_VALUE(s) FROM five_dates\n+----\n+2021-08-21\t2021-08-20 01:00:00\t15:00:37\t00:00:01\n+\n+query IIIII\n+SELECT i % 3 AS g, ANY_VALUE(d), ANY_VALUE(dt), ANY_VALUE(t), ANY_VALUE(s)\n+FROM five_dates\n+GROUP BY 1\n+ORDER BY 1\n+----\n+0\t2021-08-23\t2021-08-20 03:00:00\t15:02:37\t00:00:03\n+1\t2021-08-21\t2021-08-20 01:00:00\t15:00:37\t00:00:01\n+2\t2021-08-22\t2021-08-20 02:00:00\t15:01:37\t00:00:02\n+\n+query IIII\n+SELECT ANY_VALUE(d ORDER BY 5-i), ANY_VALUE(dt ORDER BY 5-i), ANY_VALUE(t ORDER BY 5-i), ANY_VALUE(s ORDER BY 5-i) FROM five_dates\n+----\n+2021-08-25\t2021-08-20 05:00:00\t15:04:37\t00:00:05\n+\n+query IIIII\n+SELECT i % 3 AS g, ANY_VALUE(d ORDER BY 5-i), ANY_VALUE(dt ORDER BY 5-i), ANY_VALUE(t ORDER BY 5-i), ANY_VALUE(s ORDER BY 5-i)\n+FROM five_dates\n+GROUP BY 1\n+ORDER BY 1\n+----\n+0\t2021-08-23\t2021-08-20 03:00:00\t15:02:37\t00:00:03\n+1\t2021-08-24\t2021-08-20 04:00:00\t15:03:37\t00:00:04\n+2\t2021-08-25\t2021-08-20 05:00:00\t15:04:37\t00:00:05\n+\n+# WITH TIME ZONE\n+query II\n+SELECT ANY_VALUE(dt::TIMESTAMPTZ), ANY_VALUE(t::TIMETZ) FROM five_dates\n+----\n+2021-08-20 01:00:00+00\t15:00:37+00\n+\n+query III\n+SELECT i % 3 AS g, ANY_VALUE(dt::TIMESTAMPTZ), ANY_VALUE(t::TIMETZ)\n+FROM five_dates\n+GROUP BY 1\n+ORDER BY 1\n+----\n+0\t2021-08-20 03:00:00+00\t15:02:37+00\n+1\t2021-08-20 01:00:00+00\t15:00:37+00\n+2\t2021-08-20 02:00:00+00\t15:01:37+00\n+\n+query II\n+SELECT ANY_VALUE(dt::TIMESTAMPTZ ORDER BY 5-i), ANY_VALUE(t::TIMETZ ORDER BY 5-i) FROM five_dates\n+----\n+2021-08-20 05:00:00+00\t15:04:37+00\n+\n+query III\n+SELECT i % 3 AS g, ANY_VALUE(dt::TIMESTAMPTZ ORDER BY 5-i), ANY_VALUE(t::TIMETZ ORDER BY 5-i)\n+FROM five_dates\n+GROUP BY 1\n+ORDER BY 1\n+----\n+0\t2021-08-20 03:00:00+00\t15:02:37+00\n+1\t2021-08-20 04:00:00+00\t15:03:37+00\n+2\t2021-08-20 05:00:00+00\t15:04:37+00\n+\n+statement ok\n+DROP TABLE five_dates\n+\n+# Complex\n+statement ok\n+CREATE TABLE five_complex AS\n+\tSELECT\n+\t\t1 AS i,\n+\t\tNULL::VARCHAR AS s,\n+\t\tNULL::BIGINT[] AS l,\n+\t\tNULL AS r\n+        UNION ALL\n+\tSELECT\n+\t\ti::integer AS i,\n+\t\ti::VARCHAR AS s,\n+\t\t[i] AS l,\n+\t\t{'a': i} AS r\n+\tFROM range(1, 6, 1) t1(i)\n+\n+query III\n+SELECT ANY_VALUE(s), ANY_VALUE(l), ANY_VALUE(r)\n+FROM five_complex\n+----\n+1\t[1]\t{'a': 1}\n+\n+query IIII\n+SELECT i % 3 AS g, ANY_VALUE(s), ANY_VALUE(l), ANY_VALUE(r)\n+FROM five_complex\n+GROUP BY 1\n+ORDER BY 1\n+----\n+0\t3\t[3]\t{'a': 3}\n+1\t1\t[1]\t{'a': 1}\n+2\t2\t[2]\t{'a': 2}\n+\n+query III\n+SELECT ANY_VALUE(s ORDER BY 5-i), ANY_VALUE(l ORDER BY 5-i), ANY_VALUE(r ORDER BY 5-i)\n+FROM five_complex\n+----\n+5\t[5]\t{'a': 5}\n+\n+query IIII\n+SELECT i % 3 AS g, ANY_VALUE(s ORDER BY 5-i), ANY_VALUE(l ORDER BY 5-i), ANY_VALUE(r ORDER BY 5-i)\n+FROM five_complex\n+GROUP BY 1\n+ORDER BY 1\n+----\n+0\t3\t[3]\t{'a': 3}\n+1\t4\t[4]\t{'a': 4}\n+2\t5\t[5]\t{'a': 5}\n+\n+statement ok\n+DROP TABLE five_complex\n+\n+# Window Function\n+require vector_size 512\n+\n+query I\n+SELECT ANY_VALUE(i) OVER () AS a FROM generate_series(1, 5) t(i);\n+----\n+1\n+1\n+1\n+1\n+1\ndiff --git a/test/sql/aggregate/aggregates/test_any_value_noninlined.test b/test/sql/aggregate/aggregates/test_any_value_noninlined.test\nnew file mode 100644\nindex 000000000000..0c330d583b26\n--- /dev/null\n+++ b/test/sql/aggregate/aggregates/test_any_value_noninlined.test\n@@ -0,0 +1,58 @@\n+# name: test/sql/aggregate/aggregates/test_any_value_noninlined.test\n+# description: Test ANY_VALUE with non-inlined strings\n+# group: [aggregates]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE tbl(a INTEGER, b VARCHAR)\n+\n+statement ok\n+INSERT INTO tbl VALUES (1, NULL), (2, 'thisisalongstring'), (3, 'thisisalsoalongstring')\n+\n+# non-grouped aggregate\n+query T\n+SELECT ANY_VALUE(b) FROM tbl\n+----\n+thisisalongstring\n+\n+query T\n+SELECT ANY_VALUE(b) FROM tbl WHERE a=2\n+----\n+thisisalongstring\n+\n+query T\n+SELECT ANY_VALUE(b) FROM tbl WHERE a=1\n+----\n+NULL\n+\n+query T\n+SELECT ANY_VALUE(b) FROM tbl WHERE a=1 GROUP BY a\n+----\n+NULL\n+\n+query T\n+SELECT ANY_VALUE(b) FROM tbl WHERE a=0\n+----\n+NULL\n+\n+query T\n+SELECT ANY_VALUE(b) FROM tbl WHERE a=0 GROUP BY b\n+----\n+\n+# grouped aggregate\n+query IT\n+SELECT a, ANY_VALUE(b) FROM tbl GROUP BY a ORDER BY a\n+----\n+1\n+NULL\n+2\n+thisisalongstring\n+3\n+thisisalsoalongstring\n+\n+query I\n+SELECT ANY_VALUE(i) FROM (VALUES (NULL::INT32)) tbl(i)\n+----\n+NULL\ndiff --git a/test/sql/function/list/aggregates/any_value.test b/test/sql/function/list/aggregates/any_value.test\nnew file mode 100644\nindex 000000000000..3f1431b7201b\n--- /dev/null\n+++ b/test/sql/function/list/aggregates/any_value.test\n@@ -0,0 +1,114 @@\n+# name: test/sql/function/list/aggregates/any_value.test\n+# description: Test the list_any_value aggregate function\n+# group: [aggregates]\n+\n+query I\n+SELECT list_aggr([NULL, 1, 2], 'any_value')\n+----\n+1\n+\n+# incorrect usage\n+statement error\n+SELECT list_any_value()\n+\n+# different types\n+\n+# numerics\n+foreach type <numeric>\n+\n+statement ok\n+CREATE TABLE five AS SELECT LIST(i::${type}) AS i FROM range(1, 6, 1) t1(i)\n+\n+statement ok\n+INSERT INTO five VALUES (NULL), ([NULL]), ([]), ([NULL, 1, 2])\n+\n+query I\n+SELECT list_any_value(i) FROM five\n+----\n+1\n+NULL\n+NULL\n+NULL\n+1\n+\n+statement ok\n+DROP TABLE five\n+\n+endloop\n+\n+# temporal\n+statement ok\n+CREATE TABLE five_dates AS\n+\tSELECT\n+\t\tLIST(NULLIF(i,0)::integer) AS i,\n+\t\tLIST('2021-08-20'::DATE + NULLIF(i,0)::INTEGER) AS d,\n+\t\tLIST('2021-08-20'::TIMESTAMP + INTERVAL (NULLIF(i,0)) HOUR) AS dt,\n+\t\tLIST('14:59:37'::TIME + INTERVAL (NULLIF(i,0)) MINUTE) AS t,\n+\t\tLIST(INTERVAL (NULLIF(i,0)) SECOND) AS s\n+\tFROM range(0, 6, 1) t1(i)\n+\n+query IIII\n+SELECT list_any_value(d), list_any_value(dt), list_any_value(t), list_any_value(s) FROM five_dates\n+----\n+2021-08-21\t2021-08-20 01:00:00\t15:00:37\t00:00:01\n+\n+statement ok\n+DROP TABLE five_dates\n+\n+# with time zone\n+statement ok\n+CREATE TABLE five_dates_tz AS\n+\tSELECT\n+\t\tLIST(('2021-08-20'::TIMESTAMP + INTERVAL (NULLIF(i,0)) HOUR)::TIMESTAMPTZ) AS dt,\n+\t\tLIST(('14:59:37'::TIME + INTERVAL (NULLIF(i,0)) MINUTE)::TIMETZ) AS t,\n+\tFROM range(0, 6, 1) t1(i)\n+\n+query II\n+SELECT list_any_value(dt), list_any_value(t) FROM five_dates_tz\n+----\n+2021-08-20 01:00:00+00\t15:00:37+00\n+\n+statement ok\n+DROP TABLE five_dates_tz\n+\n+# complex types\n+statement ok\n+CREATE TABLE five_complex AS\n+\tSELECT\n+\t\tLIST(NULLIF(i,0)::integer) AS i,\n+\t\tLIST(NULLIF(i,0)::VARCHAR) AS s,\n+\t\tLIST([NULLIF(i,0)]) AS l,\n+\t\tLIST({'a': NULLIF(i,0)}) AS r\n+\tFROM range(0, 6, 1) t1(i)\n+\n+query III\n+SELECT list_any_value(s), list_any_value(l), list_any_value(r)\n+FROM five_complex\n+----\n+1\t[NULL]\t{'a': NULL}\n+\n+statement ok\n+DROP TABLE five_complex\n+\n+# decimals\n+foreach type decimal(4,1) decimal(8,1) decimal(12,1) decimal(18,1)\n+\n+statement ok\n+CREATE TABLE five AS SELECT LIST(i::${type}) AS i FROM range(1, 6, 1) t1(i)\n+\n+statement ok\n+INSERT INTO five VALUES (NULL), ([NULL]), ([]), ([NULL, 1, 2])\n+\n+query I\n+SELECT list_any_value(i) FROM five\n+----\n+1.0\n+NULL\n+NULL\n+NULL\n+1.0\n+\n+statement ok\n+DROP TABLE five\n+\n+endloop\n",
  "problem_statement": "Support ANY_VALUE aggregate function\nGoogle BigQuery supports the [any_value](https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#any_value) aggregate function which returns the first non-null value encountered. We have a similar function (`first`), but it returns the first value encountered. We would like to add support for the `ANY_VALUE` function as well.\n",
  "hints_text": "I'd like to give it a shot, unless somebody picked it already.\r\n\r\nI went through the code but I've a few questions:\r\n1. I think this could be implemented either in `first.cpp` adding an extra template parameter and tweaking the logic or adding a new class altogether (e.g. `any_value.cpp`), what's the preferred approach?\r\n2. When trying to run tests via `make unit` (from CONTRIBUTING) they take a lot longer than a minute, more around 15-20min, is that expected? I'm talking about running the tests, not building them. Am I doing something wrong?\r\n3. When looking into the existing code I noticed `last()` always returns the value from the first query block in case of union all (e.g. `select last(n) from (select 0 n union all select 1)` (reproduces in shell.duckdb.org), is that expected behavior? If not maybe I could try to look into that too (unless you think it would get too hard as a first issue) \r\n\r\nFull disclosure: my C++ is very rusty so I may stumble on simple things, apologies in advance\nHey, awesome to hear you wanna pick this up\r\n1. I haven't looked into it too much, but it sounds like `first` could have an optional second parameter, that - when passed a certain value like `SKIP_NULLS` for example - will make `first` skip null values.<br>\r\nThen `ANY_VALUE` could be a macro that calls `first` with `SKIP_NULLS`.\r\n(have a look at `src/catalog/default/default_functions.cpp` to see what I mean by macro)\r\n\r\n2. I believe `make unit` runs all (fast) unit tests, as that is the default behavior of `build/debug/test/unittest`.\r\nBut this same binary can also run a specific test file, which is useful for debugging, for example:  \r\n`./unittest test/sql/aggregate/aggregates/test_first_noninlined.test`\r\n\r\nI can't really give you an answer on 3 though, hopefully Mytherin has an answer for you :)",
  "created_at": "2022-08-01T02:41:58Z"
}