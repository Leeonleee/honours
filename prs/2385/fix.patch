diff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp
index 19591069cbde..b0cef78fe72c 100644
--- a/src/common/types/vector.cpp
+++ b/src/common/types/vector.cpp
@@ -95,6 +95,11 @@ void Vector::Reference(Vector &other) {
 	Reinterpret(other);
 }
 
+void Vector::ReferenceAndSetType(Vector &other) {
+	type = other.GetType();
+	Reference(other);
+}
+
 void Vector::Reinterpret(Vector &other) {
 	vector_type = other.vector_type;
 	AssignSharedPointer(buffer, other.buffer);
diff --git a/src/include/duckdb/common/types/vector.hpp b/src/include/duckdb/common/types/vector.hpp
index 80b305a4c820..7acb7ad6e266 100644
--- a/src/include/duckdb/common/types/vector.hpp
+++ b/src/include/duckdb/common/types/vector.hpp
@@ -84,6 +84,9 @@ class Vector {
 	//! Without changing the type of this vector
 	void Reinterpret(Vector &other);
 
+	//! Causes this vector to reference the data held by the other vector, changes the type if required.
+	void ReferenceAndSetType(Vector &other);
+
 	//! Resets a vector from a vector cache.
 	//! This turns the vector back into an empty FlatVector with STANDARD_VECTOR_SIZE entries.
 	//! The VectorCache is used so this can be done without requiring any allocations.
diff --git a/tools/jdbc/CMakeLists.txt b/tools/jdbc/CMakeLists.txt
index 0b8248d8a3ea..f69f69f0a3d3 100644
--- a/tools/jdbc/CMakeLists.txt
+++ b/tools/jdbc/CMakeLists.txt
@@ -19,6 +19,13 @@ add_jar(duckdb_jdbc ${JAVA_SRC_FILES} ${JAVA_TEST_FILES}
         META-INF/services/java.sql.Driver GENERATE_NATIVE_HEADERS duckdb-native)
 
 set(OS_NAME "unknown")
+set(JVM_ARCH "amd64")
+
+string(REGEX MATCH "(arm64|aarch64)" IS_ARM ${CMAKE_SYSTEM_PROCESSOR})
+if(IS_ARM)
+  set(JVM_ARCH "arm64")
+endif()
+
 if(APPLE)
   set(OS_NAME "osx")
 endif()
@@ -29,7 +36,6 @@ if(UNIX AND NOT APPLE)
   set(OS_NAME "linux") # sorry BSD
 endif()
 
-set(JVM_BITNESS "amd64")
 # TODO handle 32 bit architectures
 
 include_directories(../../extension/parquet/include)
@@ -41,7 +47,7 @@ if(OS_NAME STREQUAL "linux")
   target_link_libraries(duckdb_java -static-libgcc -static-libstdc++
   )# static link to libstdc++ to target more linux distro
 endif()
-string(JOIN "_" LIB_SUFFIX ".so" ${OS_NAME} ${JVM_BITNESS})
+string(JOIN "_" LIB_SUFFIX ".so" ${OS_NAME} ${JVM_ARCH})
 set_target_properties(duckdb_java PROPERTIES SUFFIX ${LIB_SUFFIX})
 set_target_properties(duckdb_java PROPERTIES PREFIX "lib")
 
diff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp
index 8c3c5cbf8fec..db397681685d 100644
--- a/tools/jdbc/src/jni/duckdb_java.cpp
+++ b/tools/jdbc/src/jni/duckdb_java.cpp
@@ -23,6 +23,7 @@ static string byte_array_to_string(JNIEnv *env, jbyteArray ba_j) {
 }
 
 static jobject decode_charbuffer_to_jstring(JNIEnv *env, const char *d_str, idx_t d_str_len) {
+	// TODO cache this somewhere, probably slow to look this stuff for every string
 	jclass charset_class = env->FindClass("java/nio/charset/Charset");
 	jclass charbuffer_class = env->FindClass("java/nio/CharBuffer");
 	jmethodID for_name =
@@ -320,7 +321,7 @@ JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(
 		case LogicalTypeId::DECIMAL: {
 			Vector double_vec(LogicalType::DOUBLE);
 			VectorOperations::Cast(vec, double_vec, row_count);
-			vec.Reference(double_vec);
+			vec.ReferenceAndSetType(double_vec);
 			// fall through on purpose
 		}
 		case LogicalTypeId::DOUBLE:
@@ -332,7 +333,7 @@ JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(
 		case LogicalTypeId::INTERVAL: {
 			Vector string_vec(LogicalType::VARCHAR);
 			VectorOperations::Cast(vec, string_vec, row_count);
-			vec.Reference(string_vec);
+			vec.ReferenceAndSetType(string_vec);
 			// fall through on purpose
 		}
 		case LogicalTypeId::VARCHAR:
@@ -346,6 +347,18 @@ JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(
 				env->SetObjectArrayElement(varlen_data, row_idx, j_str);
 			}
 			break;
+		case LogicalTypeId::BLOB:
+			varlen_data = env->NewObjectArray(row_count, env->FindClass("java/nio/ByteBuffer"), nullptr);
+
+			for (idx_t row_idx = 0; row_idx < row_count; row_idx++) {
+				if (FlatVector::IsNull(vec, row_idx)) {
+					continue;
+				}
+				auto &d_str = ((string_t *)FlatVector::GetData(vec))[row_idx];
+				auto j_obj = env->NewDirectByteBuffer((void *)d_str.GetDataUnsafe(), d_str.GetSize());
+				env->SetObjectArrayElement(varlen_data, row_idx, j_obj);
+			}
+			break;
 		default:
 			jclass Exception = env->FindClass("java/sql/SQLException");
 			env->ThrowNew(Exception, ("Unsupported result column type " + vec.GetType().ToString()).c_str());
diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java
new file mode 100644
index 000000000000..7f328ce734a2
--- /dev/null
+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java
@@ -0,0 +1,6 @@
+package org.duckdb;
+
+public enum DuckDBColumnType {
+	BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, UTINYINT, USMALLINT, UINTEGER, UBIGINT, HUGEINT, FLOAT, DOUBLE,
+	DECIMAL, VARCHAR, BLOB, TIME, DATE, TIMESTAMP, INTERVAL, LIST, STRUCT
+}
diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java
index 5f2442c4ba7b..5017f8ef0053 100644
--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java
+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java
@@ -667,7 +667,7 @@ public ResultSet getTables(String catalog, String schemaPattern, String tableNam
 					table_type_str += ',';
 				}
 			}
-			table_type_str +=  ") AND ";
+			table_type_str += ") AND ";
 		}
 		if (schemaPattern == null) {
 			schemaPattern = "%";
@@ -676,7 +676,9 @@ public ResultSet getTables(String catalog, String schemaPattern, String tableNam
 			tableNamePattern = "%";
 		}
 		PreparedStatement ps = conn.prepareStatement(
-				"SELECT table_catalog AS 'TABLE_CAT', table_schema AS 'TABLE_SCHEM', table_name AS 'TABLE_NAME', table_type as 'TABLE_TYPE', NULL AS 'REMARKS', NULL AS 'TYPE_CAT', NULL AS 'TYPE_SCHEM', NULL AS 'TYPE_NAME', NULL as 'SELF_REFERENCING_COL_NAME', NULL as 'REF_GENERATION' FROM information_schema.tables WHERE "+ table_type_str +" table_schema LIKE ? AND table_name LIKE ? ORDER BY \"TABLE_TYPE\", \"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\"");
+				"SELECT table_catalog AS 'TABLE_CAT', table_schema AS 'TABLE_SCHEM', table_name AS 'TABLE_NAME', table_type as 'TABLE_TYPE', NULL AS 'REMARKS', NULL AS 'TYPE_CAT', NULL AS 'TYPE_SCHEM', NULL AS 'TYPE_NAME', NULL as 'SELF_REFERENCING_COL_NAME', NULL as 'REF_GENERATION' FROM information_schema.tables WHERE "
+						+ table_type_str
+						+ " table_schema LIKE ? AND table_name LIKE ? ORDER BY \"TABLE_TYPE\", \"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\"");
 		ps.setString(1, schemaPattern);
 		ps.setString(2, tableNamePattern);
 		return ps.executeQuery();
@@ -707,8 +709,8 @@ public ResultSet getColumns(String catalog, String schemaPattern, String tableNa
 		ResultSet rs = gunky_statement
 				.executeQuery("SELECT DISTINCT data_type FROM information_schema.columns ORDER BY data_type");
 		while (rs.next()) {
-			values_str += ", ('" + rs.getString(1) + "', "
-					+ Integer.toString(DuckDBResultSetMetaData.type_to_int(rs.getString(1))) + ")";
+			values_str += ", ('" + rs.getString(1) + "', " + Integer.toString(
+					DuckDBResultSetMetaData.type_to_int(DuckDBResultSetMetaData.TypeNameToType(rs.getString(1)))) + ")";
 		}
 		rs.close();
 		gunky_statement.close();
diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java
index d9e085903b4e..fe454109cf69 100644
--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java
+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java
@@ -18,6 +18,9 @@ public class DuckDBNative {
 			if (os_arch_detect.equals("x86_64") || os_arch_detect.equals("amd64")) {
 				os_arch = "amd64";
 			}
+            if (os_arch_detect.equals("aarch64") || os_arch_detect.equals("arm64")) {
+                os_arch = "arm64";
+            }
 			// TODO 32 bit gunk
 
 			if (os_name_detect.startsWith("windows")) {
diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java
index c46c8f58dd09..d181c4102e24 100644
--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java
+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java
@@ -1,12 +1,12 @@
 package org.duckdb;
 
+import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
 import java.io.Reader;
-import java.io.UnsupportedEncodingException;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.net.URL;
-import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.sql.Array;
@@ -115,44 +115,46 @@ public Object getObject(int columnIndex) throws SQLException {
 		if (was_null) {
 			return null;
 		}
-		String column_type = meta.column_types[columnIndex - 1];
-		if (column_type.equals("BOOLEAN")) {
+		switch (meta.column_types[columnIndex - 1]) {
+		case BOOLEAN:
 			return getBoolean(columnIndex);
-		} else if (column_type.equals("TINYINT")) {
+		case TINYINT:
 			return getByte(columnIndex);
-		} else if (column_type.equals("SMALLINT")) {
+		case SMALLINT:
 			return getShort(columnIndex);
-		} else if (column_type.equals("INTEGER")) {
+		case INTEGER:
 			return getInt(columnIndex);
-		} else if (column_type.equals("BIGINT")) {
+		case BIGINT:
 			return getLong(columnIndex);
-		}else if (column_type.equals("UTINYINT")) {
-			return getShort(columnIndex);
-		} else if (column_type.equals("USMALLINT")) {
-			return getInt(columnIndex);
-		} else if (column_type.equals("UINTEGER")) {
-			return getLong(columnIndex);
-		} else if (column_type.equals("UBIGINT")) {
-			return getHugeint(columnIndex);
-		} else if (column_type.equals("HUGEINT")) {
+		case HUGEINT:
 			return getHugeint(columnIndex);
-		} else if (column_type.equals("FLOAT")) {
+		case UTINYINT:
+			return getUint8(columnIndex);
+		case USMALLINT:
+			return getUint16(columnIndex);
+		case UINTEGER:
+			return getUint32(columnIndex);
+		case UBIGINT:
+			return getUint64(columnIndex);
+		case FLOAT:
 			return getFloat(columnIndex);
-		} else if (column_type.equals("DOUBLE") || column_type.startsWith("DECIMAL")) {
+		case DOUBLE:
+		case DECIMAL:
 			return getDouble(columnIndex);
-		} else if (column_type.equals("VARCHAR")) {
+		case VARCHAR:
 			return getString(columnIndex);
-		} else if (column_type.equals("TIME")) {
+		case TIME:
 			return getTime(columnIndex);
-		} else if (column_type.equals("DATE")) {
+		case DATE:
 			return getDate(columnIndex);
-		} else if (column_type.equals("TIMESTAMP")) {
+		case TIMESTAMP:
 			return getTimestamp(columnIndex);
-		} else if (column_type.equals("INTERVAL")) {
+		case INTERVAL:
 			return getLazyString(columnIndex);
-		} else {
-			throw new SQLException("Not implemented type: " + meta.column_types[columnIndex - 1]);
+		default:
+			throw new SQLException("Not implemented type: " + meta.column_types_string[columnIndex - 1]);
 		}
+
 	}
 
 	public boolean wasNull() throws SQLException {
@@ -175,12 +177,16 @@ public String getLazyString(int columnIndex) throws SQLException {
 		return (String) current_chunk[columnIndex - 1].varlen_data[chunk_idx - 1];
 	}
 
+	private boolean isType(int columnIndex, DuckDBColumnType type) {
+		return meta.column_types[columnIndex - 1] == type;
+	}
+
 	public String getString(int columnIndex) throws SQLException {
 		if (check_and_null(columnIndex)) {
 			return null;
 		}
 
-		if ("VARCHAR".equals(meta.column_types[columnIndex - 1])) {
+		if (isType(columnIndex, DuckDBColumnType.VARCHAR)) {
 			return (String) current_chunk[columnIndex - 1].varlen_data[chunk_idx - 1];
 		}
 		Object res = getObject(columnIndex);
@@ -194,7 +200,7 @@ public String getString(int columnIndex) throws SQLException {
 	private ByteBuffer getbuf(int columnIndex, int typeWidth) throws SQLException {
 		ByteBuffer buf = current_chunk[columnIndex - 1].constlen_data;
 		buf.order(ByteOrder.LITTLE_ENDIAN);
-		((Buffer) buf).position((chunk_idx - 1) * typeWidth);
+		buf.position((chunk_idx - 1) * typeWidth);
 		return buf;
 	}
 
@@ -202,7 +208,7 @@ public boolean getBoolean(int columnIndex) throws SQLException {
 		if (check_and_null(columnIndex)) {
 			return false;
 		}
-		if ("BOOLEAN".equals(meta.column_types[columnIndex - 1])) {
+		if (isType(columnIndex, DuckDBColumnType.BOOLEAN)) {
 			return getbuf(columnIndex, 1).get() == 1;
 		}
 		Object o = getObject(columnIndex);
@@ -217,7 +223,7 @@ public byte getByte(int columnIndex) throws SQLException {
 		if (check_and_null(columnIndex)) {
 			return 0;
 		}
-		if ("TINYINT".equals(meta.column_types[columnIndex - 1])) {
+		if (isType(columnIndex, DuckDBColumnType.TINYINT)) {
 			return getbuf(columnIndex, 1).get();
 		}
 		Object o = getObject(columnIndex);
@@ -231,17 +237,9 @@ public short getShort(int columnIndex) throws SQLException {
 		if (check_and_null(columnIndex)) {
 			return 0;
 		}
-		if ("SMALLINT".equals(meta.column_types[columnIndex - 1])) {
+		if (isType(columnIndex, DuckDBColumnType.SMALLINT)) {
 			return getbuf(columnIndex, 2).getShort();
 		}
-		else if ("UTINYINT".equals(meta.column_types[columnIndex - 1])){
-			byte[] buf_res = new byte[2];
-			byte[] buf = new byte[1];
-			getbuf(columnIndex, 1).get(buf);
-			buf_res[1] = buf[0];
-			ByteBuffer bb = ByteBuffer.wrap(buf_res);
-			return bb.getShort();
-		}
 		Object o = getObject(columnIndex);
 		if (o instanceof Number) {
 			return ((Number) o).shortValue();
@@ -253,18 +251,9 @@ public int getInt(int columnIndex) throws SQLException {
 		if (check_and_null(columnIndex)) {
 			return 0;
 		}
-		if ("INTEGER".equals(meta.column_types[columnIndex - 1])) {
+		if (isType(columnIndex, DuckDBColumnType.INTEGER)) {
 			return getbuf(columnIndex, 4).getInt();
 		}
-		else if ("USMALLINT".equals(meta.column_types[columnIndex - 1])){
-			byte[] buf_res = new byte[4];
-			byte[] buf = new byte[2];
-			getbuf(columnIndex, 2).get(buf);
-			buf_res[2] = buf[0];
-			buf_res[3] = buf[1];
-			ByteBuffer bb = ByteBuffer.wrap(buf_res);
-			return bb.getInt();
-		}
 		Object o = getObject(columnIndex);
 		if (o instanceof Number) {
 			return ((Number) o).intValue();
@@ -272,24 +261,68 @@ else if ("USMALLINT".equals(meta.column_types[columnIndex - 1])){
 		return Integer.parseInt(o.toString());
 	}
 
-	public long getLong(int columnIndex) throws SQLException {
+	private short getUint8(int columnIndex) throws SQLException {
 		if (check_and_null(columnIndex)) {
 			return 0;
 		}
-		if ("BIGINT".equals(meta.column_types[columnIndex - 1])) {
-			return getbuf(columnIndex, 8).getLong();
+		if (isType(columnIndex, DuckDBColumnType.UTINYINT)) {
+			ByteBuffer buf = ByteBuffer.allocate(2);
+			getbuf(columnIndex, 1).get(buf.array(), 1, 1);
+			return buf.getShort();
+
+		}
+		throw new SQLFeatureNotSupportedException();
+	}
+
+	private int getUint16(int columnIndex) throws SQLException {
+		if (check_and_null(columnIndex)) {
+			return 0;
+		}
+		if (isType(columnIndex, DuckDBColumnType.USMALLINT)) {
+			ByteBuffer buf = ByteBuffer.allocate(4);
+			buf.order(ByteOrder.LITTLE_ENDIAN);
+			getbuf(columnIndex, 2).get(buf.array(), 0, 2);
+			return buf.getInt();
+		}
+		throw new SQLFeatureNotSupportedException();
+
+	}
+
+	private long getUint32(int columnIndex) throws SQLException {
+		if (check_and_null(columnIndex)) {
+			return 0;
+		}
+		if (isType(columnIndex, DuckDBColumnType.UINTEGER)) {
+			ByteBuffer buf = ByteBuffer.allocate(8);
+			buf.order(ByteOrder.LITTLE_ENDIAN);
+			getbuf(columnIndex, 4).get(buf.array(), 0, 4);
+			return buf.getLong();
+		}
+		throw new SQLFeatureNotSupportedException();
+	}
+
+	private BigInteger getUint64(int columnIndex) throws SQLException {
+		if (check_and_null(columnIndex)) {
+			return BigInteger.ZERO;
 		}
-		else if( "UINTEGER".equals(meta.column_types[columnIndex - 1])){
-			byte[] buf_res = new byte[8];
-			byte[] buf = new byte[4];
-			getbuf(columnIndex, 4).get(buf);
-			buf_res[4] = buf[0];
-			buf_res[5] = buf[1];
-			buf_res[6] = buf[2];
-			buf_res[7] = buf[3];
+		if (isType(columnIndex, DuckDBColumnType.UBIGINT)) {
+			byte[] buf_res = new byte[16];
+			byte[] buf = new byte[8];
+			getbuf(columnIndex, 8).get(buf);
+			for (int i = 0; i < 8; i++) {
+				buf_res[i + 8] = buf[7 - i];
+			}
+			return new BigInteger(buf_res);
+		}
+		throw new SQLFeatureNotSupportedException();
+	}
 
-			ByteBuffer bb = ByteBuffer.wrap(buf_res);
-			return bb.getLong();
+	public long getLong(int columnIndex) throws SQLException {
+		if (check_and_null(columnIndex)) {
+			return 0;
+		}
+		if (isType(columnIndex, DuckDBColumnType.BIGINT)) {
+			return getbuf(columnIndex, 8).getLong();
 		}
 		Object o = getObject(columnIndex);
 		if (o instanceof Number) {
@@ -302,10 +335,9 @@ public BigInteger getHugeint(int columnIndex) throws SQLException {
 		if (check_and_null(columnIndex)) {
 			return BigInteger.ZERO;
 		}
-		if ("HUGEINT".equals(meta.column_types[columnIndex - 1])) {
+		if (isType(columnIndex, DuckDBColumnType.HUGEINT)) {
 			byte[] buf = new byte[16];
 			getbuf(columnIndex, 16).get(buf);
-
 			for (int i = 0; i < 8; i++) {
 				byte keep = buf[i];
 				buf[i] = buf[15 - i];
@@ -313,20 +345,6 @@ public BigInteger getHugeint(int columnIndex) throws SQLException {
 			}
 			return new BigInteger(buf);
 		}
-		else if ("UBIGINT".equals(meta.column_types[columnIndex - 1])) {
-			byte[] buf_res = new byte[16];
-			byte[] buf = new byte[8];
-			getbuf(columnIndex, 8).get(buf);
-			buf_res[8] = buf[0];
-			buf_res[9] = buf[1];
-			buf_res[10] = buf[2];
-			buf_res[11] = buf[3];
-			buf_res[12] = buf[4];
-			buf_res[13] = buf[5];
-			buf_res[14] = buf[6];
-			buf_res[15] = buf[7];
-			return new BigInteger(buf_res);
-		}
 		Object o = getObject(columnIndex);
 		return new BigInteger(o.toString());
 	}
@@ -335,7 +353,7 @@ public float getFloat(int columnIndex) throws SQLException {
 		if (check_and_null(columnIndex)) {
 			return Float.NaN;
 		}
-		if ("FLOAT".equals(meta.column_types[columnIndex - 1])) {
+		if (isType(columnIndex, DuckDBColumnType.FLOAT)) {
 			return getbuf(columnIndex, 4).getFloat();
 		}
 		Object o = getObject(columnIndex);
@@ -349,8 +367,7 @@ public double getDouble(int columnIndex) throws SQLException {
 		if (check_and_null(columnIndex)) {
 			return Double.NaN;
 		}
-		String col_type_str = meta.column_types[columnIndex - 1];
-		if (col_type_str.equals("DOUBLE") || col_type_str.startsWith("DECIMAL")) {
+		if (isType(columnIndex, DuckDBColumnType.DOUBLE) || isType(columnIndex, DuckDBColumnType.DECIMAL)) {
 			return getbuf(columnIndex, 8).getDouble();
 		}
 		Object o = getObject(columnIndex);
@@ -454,6 +471,108 @@ public Timestamp getTimestamp(int columnIndex) throws SQLException {
 		}
 	}
 
+	static class DuckDBBlobResult implements Blob {
+
+		static class ByteBufferBackedInputStream extends InputStream {
+
+			ByteBuffer buf;
+
+			public ByteBufferBackedInputStream(ByteBuffer buf) {
+				this.buf = buf;
+			}
+
+			public int read() throws IOException {
+				if (!buf.hasRemaining()) {
+					return -1;
+				}
+				return buf.get() & 0xFF;
+			}
+
+			public int read(byte[] bytes, int off, int len) throws IOException {
+				if (!buf.hasRemaining()) {
+					return -1;
+				}
+
+				len = Math.min(len, buf.remaining());
+				buf.get(bytes, off, len);
+				return len;
+			}
+		}
+
+		public DuckDBBlobResult(ByteBuffer buffer_p) {
+			buffer_p.position(0);
+			buffer_p.order(ByteOrder.LITTLE_ENDIAN);
+			this.buffer = buffer_p;
+		}
+
+		public InputStream getBinaryStream() {
+			return getBinaryStream(0, length());
+		}
+
+		public InputStream getBinaryStream(long pos, long length) {
+			return new ByteBufferBackedInputStream(buffer);
+		}
+
+		public byte[] getBytes(long pos, int length) {
+			byte[] bytes = new byte[length];
+			buffer.position((int) pos);
+			buffer.get(bytes, 0, length);
+			return bytes;
+		}
+
+		public long position(Blob pattern, long start) throws SQLException {
+			throw new SQLFeatureNotSupportedException();
+		}
+
+		public long position(byte[] pattern, long start) throws SQLException {
+			throw new SQLFeatureNotSupportedException();
+		}
+
+		public long length() {
+			return buffer.capacity();
+		}
+
+		public void free() {
+			// nop
+		}
+
+		public OutputStream setBinaryStream(long pos) throws SQLException {
+			throw new SQLFeatureNotSupportedException();
+		}
+
+		public void truncate(long length) throws SQLException {
+			throw new SQLFeatureNotSupportedException();
+		}
+
+		public int setBytes(long pos, byte[] bytes) throws SQLException {
+			throw new SQLFeatureNotSupportedException();
+
+		}
+
+		public int setBytes(long pos, byte[] bytes, int offset, int len) throws SQLException {
+			throw new SQLFeatureNotSupportedException();
+
+		}
+
+		private ByteBuffer buffer;
+
+	}
+
+	public Blob getBlob(int columnIndex) throws SQLException {
+		if (check_and_null(columnIndex)) {
+			return null;
+		}
+		if (isType(columnIndex, DuckDBColumnType.BLOB)) {
+			return new DuckDBBlobResult(((ByteBuffer[]) current_chunk[columnIndex - 1].varlen_data)[chunk_idx - 1]);
+		}
+
+		throw new SQLFeatureNotSupportedException();
+	}
+
+	public Blob getBlob(String columnLabel) throws SQLException {
+		return getBlob(findColumn(columnLabel));
+	}
+
 	public InputStream getAsciiStream(int columnIndex) throws SQLException {
 		throw new SQLFeatureNotSupportedException();
 	}
@@ -803,10 +922,6 @@ public Ref getRef(int columnIndex) throws SQLException {
 		throw new SQLFeatureNotSupportedException();
 	}
 
-	public Blob getBlob(int columnIndex) throws SQLException {
-		throw new SQLFeatureNotSupportedException();
-	}
-
 	public Clob getClob(int columnIndex) throws SQLException {
 		throw new SQLFeatureNotSupportedException();
 	}
@@ -823,10 +938,6 @@ public Ref getRef(String columnLabel) throws SQLException {
 		throw new SQLFeatureNotSupportedException();
 	}
 
-	public Blob getBlob(String columnLabel) throws SQLException {
-		throw new SQLFeatureNotSupportedException();
-	}
-
 	public Clob getClob(String columnLabel) throws SQLException {
 		throw new SQLFeatureNotSupportedException();
 	}
diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java
index 56a25f55f1aa..02c6846fedae 100644
--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java
+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java
@@ -7,20 +7,40 @@
 import java.sql.Time;
 import java.sql.Timestamp;
 import java.sql.Types;
+import java.util.ArrayList;
+
+import org.duckdb.DuckDBResultSet.DuckDBBlobResult;
 
 public class DuckDBResultSetMetaData implements ResultSetMetaData {
 
-	public DuckDBResultSetMetaData(int param_count, int column_count, String[] column_names, String[] column_types) {
+	public DuckDBResultSetMetaData(int param_count, int column_count, String[] column_names,
+			String[] column_types_string) {
 		this.param_count = param_count;
 		this.column_count = column_count;
 		this.column_names = column_names;
-		this.column_types = column_types;
+		this.column_types_string = column_types_string;
+		ArrayList<DuckDBColumnType> column_types_al = new ArrayList<DuckDBColumnType>(column_count);
+
+		for (String column_type_string : this.column_types_string) {
+			column_types_al.add(TypeNameToType(column_type_string));
+		}
+		this.column_types = new DuckDBColumnType[column_count];
+		this.column_types = column_types_al.toArray(this.column_types);
+	}
+
+	public static DuckDBColumnType TypeNameToType(String type_name) {
+		if (type_name.startsWith("DECIMAL")) {
+			return DuckDBColumnType.DECIMAL;
+		} else {
+			return DuckDBColumnType.valueOf(type_name);
+		}
 	}
 
 	protected int param_count;
 	protected int column_count;
 	protected String[] column_names;
-	protected String[] column_types;
+	protected String[] column_types_string;
+	protected DuckDBColumnType[] column_types;
 
 	public int getColumnCount() throws SQLException {
 		return column_count;
@@ -37,38 +57,57 @@ public String getColumnName(int column) throws SQLException {
 		return column_names[column - 1];
 	}
 
-	public static int type_to_int(String type_name) throws SQLException {
-		if (type_name.equals("BOOLEAN")) {
+	public static int type_to_int(DuckDBColumnType type) throws SQLException {
+		switch (type) {
+		case BOOLEAN:
 			return Types.BOOLEAN;
-		} else if (type_name.equals("TINYINT")) {
+		case TINYINT:
 			return Types.TINYINT;
-		} else if (type_name.equals("SMALLINT")) {
+		case SMALLINT:
 			return Types.SMALLINT;
-		} else if (type_name.equals("INTEGER")) {
+		case INTEGER:
 			return Types.INTEGER;
-		} else if (type_name.equals("BIGINT")) {
+		case BIGINT:
 			return Types.BIGINT;
-		} else if (type_name.equals("FLOAT")) {
+		case HUGEINT:
+			return Types.JAVA_OBJECT;
+		case UTINYINT:
+			return Types.JAVA_OBJECT;
+		case USMALLINT:
+			return Types.JAVA_OBJECT;
+		case UINTEGER:
+			return Types.JAVA_OBJECT;
+		case UBIGINT:
+			return Types.JAVA_OBJECT;
+		case FLOAT:
 			return Types.FLOAT;
-		} else if (type_name.equals("DOUBLE") || type_name.startsWith("DECIMAL")) {
+		case DOUBLE:
 			return Types.DOUBLE;
-		} else if (type_name.equals("VARCHAR")) {
+		case DECIMAL:
+			return Types.DECIMAL;
+		case VARCHAR:
 			return Types.VARCHAR;
-		} else if (type_name.equals("TIME")) {
+		case TIME:
 			return Types.TIME;
-		} else if (type_name.equals("DATE")) {
+		case DATE:
 			return Types.DATE;
-		} else if (type_name.equals("TIMESTAMP")) {
+		case TIMESTAMP:
 			return Types.TIMESTAMP;
-		} else if (type_name.equals("INTERVAL")) {
-			return Types.VARCHAR;
-		} else {
-			throw new SQLException("Unknown type " + type_name);
+		case INTERVAL:
+			return Types.JAVA_OBJECT;
+		case BLOB:
+			return Types.BLOB;
+
+		default:
+			throw new SQLException("Unsupported type " + type.toString());
 		}
 	}
 
 	public int getColumnType(int column) throws SQLException {
-		return type_to_int(getColumnTypeName(column));
+		if (column > column_count) {
+			throw new SQLException("Column index out of bounds");
+		}
+		return type_to_int(column_types[column - 1]);
 	}
 
 	public String getColumnClassName(int column) throws SQLException {
@@ -95,6 +134,8 @@ public String getColumnClassName(int column) throws SQLException {
 			return Date.class.toString();
 		case Types.TIMESTAMP:
 			return Timestamp.class.toString();
+		case Types.BLOB:
+			return DuckDBBlobResult.class.toString();
 		default:
 			throw new SQLException("Unknown type " + getColumnTypeName(column));
 		}
@@ -104,7 +145,7 @@ public String getColumnTypeName(int column) throws SQLException {
 		if (column > column_count) {
 			throw new SQLException("Column index out of bounds");
 		}
-		return column_types[column - 1];
+		return column_types_string[column - 1];
 	}
 
 	public boolean isReadOnly(int column) throws SQLException {
