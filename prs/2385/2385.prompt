You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
JDBC: cannot select BLOB columns
I have tried to write a SELECT query which mentions a BLOB column, among others. However, I receive the following error:

```
2020-11-07 15:18:25 [main] ERROR DuckNode - Could not fetch property d on node 1
java.sql.SQLException: Unsupported result column type BLOB
	at org.duckdb.DuckDBNative.duckdb_jdbc_fetch(Native Method) ~[na:na]
	at org.duckdb.DuckDBResultSet.<init>(DuckDBResultSet.java:45) ~[na:na]
	at org.duckdb.DuckDBPreparedStatement.execute(DuckDBPreparedStatement.java:90) ~[na:na]
	at org.duckdb.DuckDBPreparedStatement.executeQuery(DuckDBPreparedStatement.java:100) ~[na:na]
	at org.eclipse.hawk.duckdb.DuckNode.getProperty(DuckNode.java:252) ~[na:na]
```

Should I be casting that column to a VARCHAR instead?

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/common/types/vector.cpp]
1: #include "duckdb/common/types/vector.hpp"
2: 
3: #include "duckdb/common/algorithm.hpp"
4: #include "duckdb/common/assert.hpp"
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/common/operator/comparison_operators.hpp"
7: #include "duckdb/common/pair.hpp"
8: #include "duckdb/common/printer.hpp"
9: #include "duckdb/common/serializer.hpp"
10: #include "duckdb/common/to_string.hpp"
11: #include "duckdb/common/types/chunk_collection.hpp"
12: #include "duckdb/common/types/null_value.hpp"
13: #include "duckdb/common/types/sel_cache.hpp"
14: #include "duckdb/common/types/vector_cache.hpp"
15: #include "duckdb/common/vector_operations/vector_operations.hpp"
16: #include "duckdb/storage/buffer/buffer_handle.hpp"
17: 
18: #include <cstring> // strlen() on Solaris
19: 
20: namespace duckdb {
21: 
22: Vector::Vector(LogicalType type_p, bool create_data, bool zero_data, idx_t capacity)
23:     : vector_type(VectorType::FLAT_VECTOR), type(move(type_p)), data(nullptr) {
24: 	if (create_data) {
25: 		Initialize(zero_data, capacity);
26: 	}
27: }
28: 
29: Vector::Vector(LogicalType type_p, idx_t capacity) : Vector(move(type_p), true, false, capacity) {
30: }
31: 
32: Vector::Vector(LogicalType type_p, data_ptr_t dataptr)
33:     : vector_type(VectorType::FLAT_VECTOR), type(move(type_p)), data(dataptr) {
34: 	if (dataptr && type.id() == LogicalTypeId::INVALID) {
35: 		throw InvalidTypeException(type, "Cannot create a vector of type INVALID!");
36: 	}
37: }
38: 
39: Vector::Vector(const VectorCache &cache) : type(cache.GetType()) {
40: 	ResetFromCache(cache);
41: }
42: 
43: Vector::Vector(Vector &other) : type(other.type) {
44: 	Reference(other);
45: }
46: 
47: Vector::Vector(Vector &other, const SelectionVector &sel, idx_t count) : type(other.type) {
48: 	Slice(other, sel, count);
49: }
50: 
51: Vector::Vector(Vector &other, idx_t offset) : type(other.type) {
52: 	Slice(other, offset);
53: }
54: 
55: Vector::Vector(const Value &value) : type(value.type()) {
56: 	Reference(value);
57: }
58: 
59: Vector::Vector(Vector &&other) noexcept
60:     : vector_type(other.vector_type), type(move(other.type)), data(other.data), validity(move(other.validity)),
61:       buffer(move(other.buffer)), auxiliary(move(other.auxiliary)) {
62: }
63: 
64: void Vector::Reference(const Value &value) {
65: 	D_ASSERT(GetType() == value.type());
66: 	this->vector_type = VectorType::CONSTANT_VECTOR;
67: 	buffer = VectorBuffer::CreateConstantVector(value.type());
68: 	auto internal_type = value.type().InternalType();
69: 	if (internal_type == PhysicalType::STRUCT) {
70: 		auto struct_buffer = make_unique<VectorStructBuffer>();
71: 		auto &child_types = StructType::GetChildTypes(value.type());
72: 		auto &child_vectors = struct_buffer->GetChildren();
73: 		for (idx_t i = 0; i < child_types.size(); i++) {
74: 			auto vector = make_unique<Vector>(value.is_null ? Value(child_types[i].second) : value.struct_value[i]);
75: 			child_vectors.push_back(move(vector));
76: 		}
77: 		auxiliary = move(struct_buffer);
78: 		if (value.is_null) {
79: 			SetValue(0, value);
80: 		}
81: 	} else if (internal_type == PhysicalType::LIST) {
82: 		auto list_buffer = make_unique<VectorListBuffer>(value.type());
83: 		auxiliary = move(list_buffer);
84: 		data = buffer->GetData();
85: 		SetValue(0, value);
86: 	} else {
87: 		auxiliary.reset();
88: 		data = buffer->GetData();
89: 		SetValue(0, value);
90: 	}
91: }
92: 
93: void Vector::Reference(Vector &other) {
94: 	D_ASSERT(other.GetType() == GetType());
95: 	Reinterpret(other);
96: }
97: 
98: void Vector::Reinterpret(Vector &other) {
99: 	vector_type = other.vector_type;
100: 	AssignSharedPointer(buffer, other.buffer);
101: 	AssignSharedPointer(auxiliary, other.auxiliary);
102: 	data = other.data;
103: 	validity = other.validity;
104: }
105: 
106: void Vector::ResetFromCache(const VectorCache &cache) {
107: 	cache.ResetFromCache(*this);
108: }
109: 
110: void Vector::Slice(Vector &other, idx_t offset) {
111: 	if (other.GetVectorType() == VectorType::CONSTANT_VECTOR) {
112: 		Reference(other);
113: 		return;
114: 	}
115: 	D_ASSERT(other.GetVectorType() == VectorType::FLAT_VECTOR);
116: 
117: 	auto internal_type = GetType().InternalType();
118: 	if (internal_type == PhysicalType::STRUCT) {
119: 		Vector new_vector(GetType());
120: 		auto &entries = StructVector::GetEntries(new_vector);
121: 		auto &other_entries = StructVector::GetEntries(other);
122: 		D_ASSERT(entries.size() == other_entries.size());
123: 		for (idx_t i = 0; i < entries.size(); i++) {
124: 			entries[i]->Slice(*other_entries[i], offset);
125: 		}
126: 		if (offset > 0) {
127: 			new_vector.validity.Slice(other.validity, offset);
128: 		} else {
129: 			new_vector.validity = other.validity;
130: 		}
131: 		Reference(new_vector);
132: 	} else {
133: 		Reference(other);
134: 		if (offset > 0) {
135: 			data = data + GetTypeIdSize(internal_type) * offset;
136: 			validity.Slice(other.validity, offset);
137: 		}
138: 	}
139: }
140: 
141: void Vector::Slice(Vector &other, const SelectionVector &sel, idx_t count) {
142: 	Reference(other);
143: 	Slice(sel, count);
144: }
145: 
146: void Vector::Slice(const SelectionVector &sel, idx_t count) {
147: 	if (GetVectorType() == VectorType::CONSTANT_VECTOR) {
148: 		// dictionary on a constant is just a constant
149: 		return;
150: 	}
151: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
152: 		// already a dictionary, slice the current dictionary
153: 		auto &current_sel = DictionaryVector::SelVector(*this);
154: 		auto sliced_dictionary = current_sel.Slice(sel, count);
155: 		buffer = make_buffer<DictionaryBuffer>(move(sliced_dictionary));
156: 		return;
157: 	}
158: 	Vector child_vector(*this);
159: 	auto child_ref = make_buffer<VectorChildBuffer>(move(child_vector));
160: 	auto dict_buffer = make_buffer<DictionaryBuffer>(sel);
161: 	vector_type = VectorType::DICTIONARY_VECTOR;
162: 	buffer = move(dict_buffer);
163: 	auxiliary = move(child_ref);
164: }
165: 
166: void Vector::Slice(const SelectionVector &sel, idx_t count, SelCache &cache) {
167: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
168: 		// dictionary vector: need to merge dictionaries
169: 		// check if we have a cached entry
170: 		auto &current_sel = DictionaryVector::SelVector(*this);
171: 		auto target_data = current_sel.data();
172: 		auto entry = cache.cache.find(target_data);
173: 		if (entry != cache.cache.end()) {
174: 			// cached entry exists: use that
175: 			this->buffer = make_buffer<DictionaryBuffer>(((DictionaryBuffer &)*entry->second).GetSelVector());
176: 			vector_type = VectorType::DICTIONARY_VECTOR;
177: 		} else {
178: 			Slice(sel, count);
179: 			cache.cache[target_data] = this->buffer;
180: 		}
181: 	} else {
182: 		Slice(sel, count);
183: 	}
184: }
185: 
186: void Vector::Initialize(bool zero_data, idx_t capacity) {
187: 	auxiliary.reset();
188: 	validity.Reset();
189: 	auto &type = GetType();
190: 	auto internal_type = type.InternalType();
191: 	if (internal_type == PhysicalType::STRUCT) {
192: 		auto struct_buffer = make_unique<VectorStructBuffer>(type, capacity);
193: 		auxiliary = move(struct_buffer);
194: 	} else if (internal_type == PhysicalType::LIST) {
195: 		auto list_buffer = make_unique<VectorListBuffer>(type);
196: 		auxiliary = move(list_buffer);
197: 	}
198: 	auto type_size = GetTypeIdSize(internal_type);
199: 	if (type_size > 0) {
200: 		buffer = VectorBuffer::CreateStandardVector(type, capacity);
201: 		data = buffer->GetData();
202: 		if (zero_data) {
203: 			memset(data, 0, capacity * type_size);
204: 		}
205: 	}
206: }
207: 
208: struct DataArrays {
209: 	Vector &vec;
210: 	data_ptr_t data;
211: 	VectorBuffer *buffer;
212: 	idx_t type_size;
213: 	bool is_nested;
214: 	DataArrays(Vector &vec, data_ptr_t data, VectorBuffer *buffer, idx_t type_size, bool is_nested)
215: 	    : vec(vec), data(data), buffer(buffer), type_size(type_size), is_nested(is_nested) {};
216: };
217: 
218: void FindChildren(std::vector<DataArrays> &to_resize, VectorBuffer &auxiliary) {
219: 	if (auxiliary.GetBufferType() == VectorBufferType::LIST_BUFFER) {
220: 		auto &buffer = (VectorListBuffer &)auxiliary;
221: 		auto &child = buffer.GetChild();
222: 		auto data = child.GetData();
223: 		if (!data) {
224: 			//! Nested type
225: 			DataArrays arrays(child, data, child.GetBuffer().get(), GetTypeIdSize(child.GetType().InternalType()),
226: 			                  true);
227: 			to_resize.emplace_back(arrays);
228: 			FindChildren(to_resize, *child.GetAuxiliary());
229: 		} else {
230: 			DataArrays arrays(child, data, child.GetBuffer().get(), GetTypeIdSize(child.GetType().InternalType()),
231: 			                  false);
232: 			to_resize.emplace_back(arrays);
233: 		}
234: 	} else if (auxiliary.GetBufferType() == VectorBufferType::STRUCT_BUFFER) {
235: 		auto &buffer = (VectorStructBuffer &)auxiliary;
236: 		auto &children = buffer.GetChildren();
237: 		for (auto &child : children) {
238: 			auto data = child->GetData();
239: 			if (!data) {
240: 				//! Nested type
241: 				DataArrays arrays(*child, data, child->GetBuffer().get(),
242: 				                  GetTypeIdSize(child->GetType().InternalType()), true);
243: 				to_resize.emplace_back(arrays);
244: 				FindChildren(to_resize, *child->GetAuxiliary());
245: 			} else {
246: 				DataArrays arrays(*child, data, child->GetBuffer().get(),
247: 				                  GetTypeIdSize(child->GetType().InternalType()), false);
248: 				to_resize.emplace_back(arrays);
249: 			}
250: 		}
251: 	}
252: }
253: void Vector::Resize(idx_t cur_size, idx_t new_size) {
254: 	std::vector<DataArrays> to_resize;
255: 	if (!buffer) {
256: 		buffer = make_unique<VectorBuffer>(0);
257: 	}
258: 	if (!data) {
259: 		//! this is a nested structure
260: 		DataArrays arrays(*this, data, buffer.get(), GetTypeIdSize(GetType().InternalType()), true);
261: 		to_resize.emplace_back(arrays);
262: 		FindChildren(to_resize, *auxiliary);
263: 	} else {
264: 		DataArrays arrays(*this, data, buffer.get(), GetTypeIdSize(GetType().InternalType()), false);
265: 		to_resize.emplace_back(arrays);
266: 	}
267: 	for (auto &data_to_resize : to_resize) {
268: 		if (!data_to_resize.is_nested) {
269: 			auto new_data = unique_ptr<data_t[]>(new data_t[new_size * data_to_resize.type_size]);
270: 			memcpy(new_data.get(), data_to_resize.data, cur_size * data_to_resize.type_size * sizeof(data_t));
271: 			data_to_resize.buffer->SetData(move(new_data));
272: 			data_to_resize.vec.data = data_to_resize.buffer->GetData();
273: 		}
274: 		data_to_resize.vec.validity.Resize(cur_size, new_size);
275: 	}
276: }
277: 
278: void Vector::SetValue(idx_t index, const Value &val) {
279: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
280: 		// dictionary: apply dictionary and forward to child
281: 		auto &sel_vector = DictionaryVector::SelVector(*this);
282: 		auto &child = DictionaryVector::Child(*this);
283: 		return child.SetValue(sel_vector.get_index(index), val);
284: 	}
285: 	if (val.type() != GetType()) {
286: 		SetValue(index, val.CastAs(GetType()));
287: 		return;
288: 	}
289: 
290: 	validity.EnsureWritable();
291: 	validity.Set(index, !val.is_null);
292: 	if (val.is_null && GetType().InternalType() != PhysicalType::STRUCT) {
293: 		// for structs we still need to set the child-entries to NULL
294: 		// so we do not bail out yet
295: 		return;
296: 	}
297: 
298: 	switch (GetType().id()) {
299: 	case LogicalTypeId::BOOLEAN:
300: 		((bool *)data)[index] = val.value_.boolean;
301: 		break;
302: 	case LogicalTypeId::TINYINT:
303: 		((int8_t *)data)[index] = val.value_.tinyint;
304: 		break;
305: 	case LogicalTypeId::SMALLINT:
306: 		((int16_t *)data)[index] = val.value_.smallint;
307: 		break;
308: 	case LogicalTypeId::DATE:
309: 	case LogicalTypeId::INTEGER:
310: 		((int32_t *)data)[index] = val.value_.integer;
311: 		break;
312: 	case LogicalTypeId::TIMESTAMP:
313: 	case LogicalTypeId::TIMESTAMP_SEC:
314: 	case LogicalTypeId::TIMESTAMP_MS:
315: 	case LogicalTypeId::TIMESTAMP_NS:
316: 	case LogicalTypeId::HASH:
317: 	case LogicalTypeId::TIME:
318: 	case LogicalTypeId::BIGINT:
319: 		((int64_t *)data)[index] = val.value_.bigint;
320: 		break;
321: 	case LogicalTypeId::UTINYINT:
322: 		((uint8_t *)data)[index] = val.value_.utinyint;
323: 		break;
324: 	case LogicalTypeId::USMALLINT:
325: 		((uint16_t *)data)[index] = val.value_.usmallint;
326: 		break;
327: 	case LogicalTypeId::UINTEGER:
328: 		((uint32_t *)data)[index] = val.value_.uinteger;
329: 		break;
330: 	case LogicalTypeId::UBIGINT:
331: 		((uint64_t *)data)[index] = val.value_.ubigint;
332: 		break;
333: 	case LogicalTypeId::HUGEINT:
334: 	case LogicalTypeId::UUID:
335: 		((hugeint_t *)data)[index] = val.value_.hugeint;
336: 		break;
337: 	case LogicalTypeId::DECIMAL:
338: 		D_ASSERT(DecimalType::GetWidth(GetType()) == DecimalType::GetWidth(val.type()));
339: 		D_ASSERT(DecimalType::GetScale(GetType()) == DecimalType::GetScale(val.type()));
340: 		switch (GetType().InternalType()) {
341: 		case PhysicalType::INT16:
342: 			((int16_t *)data)[index] = val.value_.smallint;
343: 			break;
344: 		case PhysicalType::INT32:
345: 			((int32_t *)data)[index] = val.value_.integer;
346: 			break;
347: 		case PhysicalType::INT64:
348: 			((int64_t *)data)[index] = val.value_.bigint;
349: 			break;
350: 		case PhysicalType::INT128:
351: 			((hugeint_t *)data)[index] = val.value_.hugeint;
352: 			break;
353: 		default:
354: 			throw InternalException("Widths bigger than 38 are not supported");
355: 		}
356: 		break;
357: 	case LogicalTypeId::FLOAT:
358: 		((float *)data)[index] = val.value_.float_;
359: 		break;
360: 	case LogicalTypeId::DOUBLE:
361: 		((double *)data)[index] = val.value_.double_;
362: 		break;
363: 	case LogicalTypeId::POINTER:
364: 		((uintptr_t *)data)[index] = val.value_.pointer;
365: 		break;
366: 	case LogicalTypeId::INTERVAL:
367: 		((interval_t *)data)[index] = val.value_.interval;
368: 		break;
369: 	case LogicalTypeId::VARCHAR:
370: 	case LogicalTypeId::BLOB:
371: 		((string_t *)data)[index] = StringVector::AddStringOrBlob(*this, val.str_value);
372: 		break;
373: 	case LogicalTypeId::MAP:
374: 	case LogicalTypeId::STRUCT: {
375: 		D_ASSERT(GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR);
376: 
377: 		auto &children = StructVector::GetEntries(*this);
378: 		D_ASSERT(val.is_null || children.size() == val.struct_value.size());
379: 		for (size_t i = 0; i < children.size(); i++) {
380: 			auto &vec_child = children[i];
381: 			if (!val.is_null) {
382: 				auto &struct_child = val.struct_value[i];
383: 				vec_child->SetValue(index, struct_child);
384: 			} else {
385: 				vec_child->SetValue(index, Value());
386: 			}
387: 		}
388: 		break;
389: 	}
390: 	case LogicalTypeId::LIST: {
391: 		auto offset = ListVector::GetListSize(*this);
392: 		if (!val.list_value.empty()) {
393: 			for (idx_t i = 0; i < val.list_value.size(); i++) {
394: 				Value v(val.list_value[i]);
395: 				ListVector::PushBack(*this, v);
396: 			}
397: 		}
398: 		//! now set the pointer
399: 		auto &entry = ((list_entry_t *)data)[index];
400: 		entry.length = val.list_value.size();
401: 		entry.offset = offset;
402: 		break;
403: 	}
404: 	default:
405: 		throw InternalException("Unimplemented type for Vector::SetValue");
406: 	}
407: }
408: 
409: Value Vector::GetValue(idx_t index) const {
410: 	switch (GetVectorType()) {
411: 	case VectorType::CONSTANT_VECTOR:
412: 		index = 0;
413: 		break;
414: 	case VectorType::FLAT_VECTOR:
415: 		break;
416: 		// dictionary: apply dictionary and forward to child
417: 	case VectorType::DICTIONARY_VECTOR: {
418: 		auto &sel_vector = DictionaryVector::SelVector(*this);
419: 		auto &child = DictionaryVector::Child(*this);
420: 		return child.GetValue(sel_vector.get_index(index));
421: 	}
422: 	case VectorType::SEQUENCE_VECTOR: {
423: 		int64_t start, increment;
424: 		SequenceVector::GetSequence(*this, start, increment);
425: 		return Value::Numeric(GetType(), start + increment * index);
426: 	}
427: 	default:
428: 		throw InternalException("Unimplemented vector type for Vector::GetValue");
429: 	}
430: 
431: 	if (!validity.RowIsValid(index)) {
432: 		return Value(GetType());
433: 	}
434: 	switch (GetType().id()) {
435: 	case LogicalTypeId::BOOLEAN:
436: 		return Value::BOOLEAN(((bool *)data)[index]);
437: 	case LogicalTypeId::TINYINT:
438: 		return Value::TINYINT(((int8_t *)data)[index]);
439: 	case LogicalTypeId::SMALLINT:
440: 		return Value::SMALLINT(((int16_t *)data)[index]);
441: 	case LogicalTypeId::INTEGER:
442: 		return Value::INTEGER(((int32_t *)data)[index]);
443: 	case LogicalTypeId::DATE:
444: 		return Value::DATE(((date_t *)data)[index]);
445: 	case LogicalTypeId::TIME:
446: 		return Value::TIME(((dtime_t *)data)[index]);
447: 	case LogicalTypeId::BIGINT:
448: 		return Value::BIGINT(((int64_t *)data)[index]);
449: 	case LogicalTypeId::UTINYINT:
450: 		return Value::UTINYINT(((uint8_t *)data)[index]);
451: 	case LogicalTypeId::USMALLINT:
452: 		return Value::USMALLINT(((uint16_t *)data)[index]);
453: 	case LogicalTypeId::UINTEGER:
454: 		return Value::UINTEGER(((uint32_t *)data)[index]);
455: 	case LogicalTypeId::UBIGINT:
456: 		return Value::UBIGINT(((uint64_t *)data)[index]);
457: 	case LogicalTypeId::TIMESTAMP:
458: 		return Value::TIMESTAMP(((timestamp_t *)data)[index]);
459: 	case LogicalTypeId::TIMESTAMP_NS:
460: 		return Value::TimestampNs(((timestamp_t *)data)[index]);
461: 	case LogicalTypeId::TIMESTAMP_MS:
462: 		return Value::TimestampMs(((timestamp_t *)data)[index]);
463: 	case LogicalTypeId::TIMESTAMP_SEC:
464: 		return Value::TimestampSec(((timestamp_t *)data)[index]);
465: 	case LogicalTypeId::HUGEINT:
466: 		return Value::HUGEINT(((hugeint_t *)data)[index]);
467: 	case LogicalTypeId::UUID:
468: 		return Value::UUID(((hugeint_t *)data)[index]);
469: 	case LogicalTypeId::DECIMAL: {
470: 		auto width = DecimalType::GetWidth(GetType());
471: 		auto scale = DecimalType::GetScale(GetType());
472: 		switch (GetType().InternalType()) {
473: 		case PhysicalType::INT16:
474: 			return Value::DECIMAL(((int16_t *)data)[index], width, scale);
475: 		case PhysicalType::INT32:
476: 			return Value::DECIMAL(((int32_t *)data)[index], width, scale);
477: 		case PhysicalType::INT64:
478: 			return Value::DECIMAL(((int64_t *)data)[index], width, scale);
479: 		case PhysicalType::INT128:
480: 			return Value::DECIMAL(((hugeint_t *)data)[index], width, scale);
481: 		default:
482: 			throw InternalException("Widths bigger than 38 are not supported");
483: 		}
484: 	}
485: 	case LogicalTypeId::HASH:
486: 		return Value::HASH(((hash_t *)data)[index]);
487: 	case LogicalTypeId::POINTER:
488: 		return Value::POINTER(((uintptr_t *)data)[index]);
489: 	case LogicalTypeId::FLOAT:
490: 		return Value::FLOAT(((float *)data)[index]);
491: 	case LogicalTypeId::DOUBLE:
492: 		return Value::DOUBLE(((double *)data)[index]);
493: 	case LogicalTypeId::INTERVAL:
494: 		return Value::INTERVAL(((interval_t *)data)[index]);
495: 	case LogicalTypeId::VARCHAR: {
496: 		auto str = ((string_t *)data)[index];
497: 		return Value(str.GetString());
498: 	}
499: 	case LogicalTypeId::BLOB: {
500: 		auto str = ((string_t *)data)[index];
501: 		return Value::BLOB((const_data_ptr_t)str.GetDataUnsafe(), str.GetSize());
502: 	}
503: 	case LogicalTypeId::MAP:
504: 	case LogicalTypeId::STRUCT: {
505: 		Value ret(GetType());
506: 		ret.is_null = false;
507: 		// we can derive the value schema from the vector schema
508: 		auto &child_entries = StructVector::GetEntries(*this);
509: 		for (auto &struct_child : child_entries) {
510: 			ret.struct_value.push_back(struct_child->GetValue(index));
511: 		}
512: 		return ret;
513: 	}
514: 	case LogicalTypeId::LIST: {
515: 		Value ret(GetType());
516: 		ret.is_null = false;
517: 		auto offlen = ((list_entry_t *)data)[index];
518: 		auto &child_vec = ListVector::GetEntry(*this);
519: 		for (idx_t i = offlen.offset; i < offlen.offset + offlen.length; i++) {
520: 			ret.list_value.push_back(child_vec.GetValue(i));
521: 		}
522: 		return ret;
523: 	}
524: 	default:
525: 		throw InternalException("Unimplemented type for value access");
526: 	}
527: }
528: 
529: // LCOV_EXCL_START
530: string VectorTypeToString(VectorType type) {
531: 	switch (type) {
532: 	case VectorType::FLAT_VECTOR:
533: 		return "FLAT";
534: 	case VectorType::SEQUENCE_VECTOR:
535: 		return "SEQUENCE";
536: 	case VectorType::DICTIONARY_VECTOR:
537: 		return "DICTIONARY";
538: 	case VectorType::CONSTANT_VECTOR:
539: 		return "CONSTANT";
540: 	default:
541: 		return "UNKNOWN";
542: 	}
543: }
544: 
545: string Vector::ToString(idx_t count) const {
546: 	string retval =
547: 	    VectorTypeToString(GetVectorType()) + " " + GetType().ToString() + ": " + to_string(count) + " = [ ";
548: 	switch (GetVectorType()) {
549: 	case VectorType::FLAT_VECTOR:
550: 	case VectorType::DICTIONARY_VECTOR:
551: 		for (idx_t i = 0; i < count; i++) {
552: 			retval += GetValue(i).ToString() + (i == count - 1 ? "" : ", ");
553: 		}
554: 		break;
555: 	case VectorType::CONSTANT_VECTOR:
556: 		retval += GetValue(0).ToString();
557: 		break;
558: 	case VectorType::SEQUENCE_VECTOR: {
559: 		int64_t start, increment;
560: 		SequenceVector::GetSequence(*this, start, increment);
561: 		for (idx_t i = 0; i < count; i++) {
562: 			retval += to_string(start + increment * i) + (i == count - 1 ? "" : ", ");
563: 		}
564: 		break;
565: 	}
566: 	default:
567: 		retval += "UNKNOWN VECTOR TYPE";
568: 		break;
569: 	}
570: 	retval += "]";
571: 	return retval;
572: }
573: 
574: void Vector::Print(idx_t count) {
575: 	Printer::Print(ToString(count));
576: }
577: 
578: string Vector::ToString() const {
579: 	string retval = VectorTypeToString(GetVectorType()) + " " + GetType().ToString() + ": (UNKNOWN COUNT) [ ";
580: 	switch (GetVectorType()) {
581: 	case VectorType::FLAT_VECTOR:
582: 	case VectorType::DICTIONARY_VECTOR:
583: 		break;
584: 	case VectorType::CONSTANT_VECTOR:
585: 		retval += GetValue(0).ToString();
586: 		break;
587: 	case VectorType::SEQUENCE_VECTOR: {
588: 		break;
589: 	}
590: 	default:
591: 		retval += "UNKNOWN VECTOR TYPE";
592: 		break;
593: 	}
594: 	retval += "]";
595: 	return retval;
596: }
597: 
598: void Vector::Print() {
599: 	Printer::Print(ToString());
600: }
601: // LCOV_EXCL_STOP
602: 
603: template <class T>
604: static void TemplatedFlattenConstantVector(data_ptr_t data, data_ptr_t old_data, idx_t count) {
605: 	auto constant = Load<T>(old_data);
606: 	auto output = (T *)data;
607: 	for (idx_t i = 0; i < count; i++) {
608: 		output[i] = constant;
609: 	}
610: }
611: 
612: void Vector::Normalify(idx_t count) {
613: 	switch (GetVectorType()) {
614: 	case VectorType::FLAT_VECTOR:
615: 		// already a flat vector
616: 		break;
617: 	case VectorType::DICTIONARY_VECTOR: {
618: 		// create a new flat vector of this type
619: 		Vector other(GetType());
620: 		// now copy the data of this vector to the other vector, removing the selection vector in the process
621: 		VectorOperations::Copy(*this, other, count, 0, 0);
622: 		// create a reference to the data in the other vector
623: 		this->Reference(other);
624: 		break;
625: 	}
626: 	case VectorType::CONSTANT_VECTOR: {
627: 		bool is_null = ConstantVector::IsNull(*this);
628: 		// allocate a new buffer for the vector
629: 		auto old_buffer = move(buffer);
630: 		auto old_data = data;
631: 		buffer = VectorBuffer::CreateStandardVector(type);
632: 		data = buffer->GetData();
633: 		vector_type = VectorType::FLAT_VECTOR;
634: 		if (is_null) {
635: 			// constant NULL, set nullmask
636: 			validity.EnsureWritable();
637: 			validity.SetAllInvalid(count);
638: 			return;
639: 		}
640: 		// non-null constant: have to repeat the constant
641: 		switch (GetType().InternalType()) {
642: 		case PhysicalType::BOOL:
643: 			TemplatedFlattenConstantVector<bool>(data, old_data, count);
644: 			break;
645: 		case PhysicalType::INT8:
646: 			TemplatedFlattenConstantVector<int8_t>(data, old_data, count);
647: 			break;
648: 		case PhysicalType::INT16:
649: 			TemplatedFlattenConstantVector<int16_t>(data, old_data, count);
650: 			break;
651: 		case PhysicalType::INT32:
652: 			TemplatedFlattenConstantVector<int32_t>(data, old_data, count);
653: 			break;
654: 		case PhysicalType::INT64:
655: 			TemplatedFlattenConstantVector<int64_t>(data, old_data, count);
656: 			break;
657: 		case PhysicalType::UINT8:
658: 			TemplatedFlattenConstantVector<uint8_t>(data, old_data, count);
659: 			break;
660: 		case PhysicalType::UINT16:
661: 			TemplatedFlattenConstantVector<uint16_t>(data, old_data, count);
662: 			break;
663: 		case PhysicalType::UINT32:
664: 			TemplatedFlattenConstantVector<uint32_t>(data, old_data, count);
665: 			break;
666: 		case PhysicalType::UINT64:
667: 			TemplatedFlattenConstantVector<uint64_t>(data, old_data, count);
668: 			break;
669: 		case PhysicalType::INT128:
670: 			TemplatedFlattenConstantVector<hugeint_t>(data, old_data, count);
671: 			break;
672: 		case PhysicalType::FLOAT:
673: 			TemplatedFlattenConstantVector<float>(data, old_data, count);
674: 			break;
675: 		case PhysicalType::DOUBLE:
676: 			TemplatedFlattenConstantVector<double>(data, old_data, count);
677: 			break;
678: 		case PhysicalType::INTERVAL:
679: 			TemplatedFlattenConstantVector<interval_t>(data, old_data, count);
680: 			break;
681: 		case PhysicalType::VARCHAR:
682: 			TemplatedFlattenConstantVector<string_t>(data, old_data, count);
683: 			break;
684: 		case PhysicalType::LIST: {
685: 			TemplatedFlattenConstantVector<list_entry_t>(data, old_data, count);
686: 			break;
687: 		}
688: 		case PhysicalType::STRUCT: {
689: 			auto normalified_buffer = make_unique<VectorStructBuffer>();
690: 
691: 			auto &new_children = normalified_buffer->GetChildren();
692: 
693: 			auto &child_entries = StructVector::GetEntries(*this);
694: 			for (auto &child : child_entries) {
695: 				D_ASSERT(child->GetVectorType() == VectorType::CONSTANT_VECTOR);
696: 				auto vector = make_unique<Vector>(*child);
697: 				vector->Normalify(count);
698: 				new_children.push_back(move(vector));
699: 			}
700: 			auxiliary = move(normalified_buffer);
701: 		} break;
702: 		default:
703: 			throw InternalException("Unimplemented type for VectorOperations::Normalify");
704: 		}
705: 		break;
706: 	}
707: 	case VectorType::SEQUENCE_VECTOR: {
708: 		int64_t start, increment;
709: 		SequenceVector::GetSequence(*this, start, increment);
710: 
711: 		buffer = VectorBuffer::CreateStandardVector(GetType());
712: 		data = buffer->GetData();
713: 		VectorOperations::GenerateSequence(*this, count, start, increment);
714: 		break;
715: 	}
716: 	default:
717: 		throw InternalException("Unimplemented type for normalify");
718: 	}
719: }
720: 
721: void Vector::Normalify(const SelectionVector &sel, idx_t count) {
722: 	switch (GetVectorType()) {
723: 	case VectorType::FLAT_VECTOR:
724: 		// already a flat vector
725: 		break;
726: 	case VectorType::SEQUENCE_VECTOR: {
727: 		int64_t start, increment;
728: 		SequenceVector::GetSequence(*this, start, increment);
729: 
730: 		buffer = VectorBuffer::CreateStandardVector(GetType());
731: 		data = buffer->GetData();
732: 		VectorOperations::GenerateSequence(*this, count, sel, start, increment);
733: 		break;
734: 	}
735: 	default:
736: 		throw InternalException("Unimplemented type for normalify with selection vector");
737: 	}
738: }
739: 
740: void Vector::Orrify(idx_t count, VectorData &data) {
741: 	switch (GetVectorType()) {
742: 	case VectorType::DICTIONARY_VECTOR: {
743: 		auto &sel = DictionaryVector::SelVector(*this);
744: 		auto &child = DictionaryVector::Child(*this);
745: 		if (child.GetVectorType() == VectorType::FLAT_VECTOR) {
746: 			data.sel = &sel;
747: 			data.data = FlatVector::GetData(child);
748: 			data.validity = FlatVector::Validity(child);
749: 		} else {
750: 			// dictionary with non-flat child: create a new reference to the child and normalify it
751: 			Vector child_vector(child);
752: 			child_vector.Normalify(sel, count);
753: 			auto new_aux = make_buffer<VectorChildBuffer>(move(child_vector));
754: 
755: 			data.sel = &sel;
756: 			data.data = FlatVector::GetData(new_aux->data);
757: 			data.validity = FlatVector::Validity(new_aux->data);
758: 			this->auxiliary = move(new_aux);
759: 		}
760: 		break;
761: 	}
762: 	case VectorType::CONSTANT_VECTOR:
763: 		data.sel = ConstantVector::ZeroSelectionVector(count, data.owned_sel);
764: 		data.data = ConstantVector::GetData(*this);
765: 		data.validity = ConstantVector::Validity(*this);
766: 		break;
767: 	default:
768: 		Normalify(count);
769: 		data.sel = &FlatVector::INCREMENTAL_SELECTION_VECTOR;
770: 		data.data = FlatVector::GetData(*this);
771: 		data.validity = FlatVector::Validity(*this);
772: 		break;
773: 	}
774: }
775: 
776: void Vector::Sequence(int64_t start, int64_t increment) {
777: 	this->vector_type = VectorType::SEQUENCE_VECTOR;
778: 	this->buffer = make_buffer<VectorBuffer>(sizeof(int64_t) * 2);
779: 	auto data = (int64_t *)buffer->GetData();
780: 	data[0] = start;
781: 	data[1] = increment;
782: 	validity.Reset();
783: 	auxiliary.reset();
784: }
785: 
786: void Vector::Serialize(idx_t count, Serializer &serializer) {
787: 	auto &type = GetType();
788: 
789: 	VectorData vdata;
790: 	Orrify(count, vdata);
791: 
792: 	const auto write_validity = (count > 0) && !vdata.validity.AllValid();
793: 	serializer.Write<bool>(write_validity);
794: 	if (write_validity) {
795: 		ValidityMask flat_mask(count);
796: 		for (idx_t i = 0; i < count; ++i) {
797: 			auto row_idx = vdata.sel->get_index(i);
798: 			flat_mask.Set(i, vdata.validity.RowIsValid(row_idx));
799: 		}
800: 		serializer.WriteData((const_data_ptr_t)flat_mask.GetData(), flat_mask.ValidityMaskSize(count));
801: 	}
802: 	if (TypeIsConstantSize(type.InternalType())) {
803: 		// constant size type: simple copy
804: 		idx_t write_size = GetTypeIdSize(type.InternalType()) * count;
805: 		auto ptr = unique_ptr<data_t[]>(new data_t[write_size]);
806: 		VectorOperations::WriteToStorage(*this, count, ptr.get());
807: 		serializer.WriteData(ptr.get(), write_size);
808: 	} else {
809: 		switch (type.InternalType()) {
810: 		case PhysicalType::VARCHAR: {
811: 			auto strings = (string_t *)vdata.data;
812: 			for (idx_t i = 0; i < count; i++) {
813: 				auto idx = vdata.sel->get_index(i);
814: 				auto source = !vdata.validity.RowIsValid(idx) ? NullValue<string_t>() : strings[idx];
815: 				serializer.WriteStringLen((const_data_ptr_t)source.GetDataUnsafe(), source.GetSize());
816: 			}
817: 			break;
818: 		}
819: 		case PhysicalType::STRUCT: {
820: 			Normalify(count);
821: 			auto &entries = StructVector::GetEntries(*this);
822: 			for (auto &entry : entries) {
823: 				entry->Serialize(count, serializer);
824: 			}
825: 			break;
826: 		}
827: 		case PhysicalType::LIST: {
828: 			auto &child = ListVector::GetEntry(*this);
829: 			auto list_size = ListVector::GetListSize(*this);
830: 
831: 			// serialize the list entries in a flat array
832: 			auto data = unique_ptr<list_entry_t[]>(new list_entry_t[count]);
833: 			auto source_array = (list_entry_t *)vdata.data;
834: 			for (idx_t i = 0; i < count; i++) {
835: 				auto idx = vdata.sel->get_index(i);
836: 				auto source = source_array[idx];
837: 				data[i].offset = source.offset;
838: 				data[i].length = source.length;
839: 			}
840: 
841: 			// write the list size
842: 			serializer.Write<idx_t>(list_size);
843: 			serializer.WriteData((data_ptr_t)data.get(), count * sizeof(list_entry_t));
844: 
845: 			child.Serialize(list_size, serializer);
846: 			break;
847: 		}
848: 		default:
849: 			throw InternalException("Unimplemented variable width type for Vector::Serialize!");
850: 		}
851: 	}
852: }
853: 
854: void Vector::Deserialize(idx_t count, Deserializer &source) {
855: 	auto &type = GetType();
856: 
857: 	auto &validity = FlatVector::Validity(*this);
858: 	validity.Reset();
859: 	const auto has_validity = source.Read<bool>();
860: 	if (has_validity) {
861: 		validity.Initialize(count);
862: 		source.ReadData((data_ptr_t)validity.GetData(), validity.ValidityMaskSize(count));
863: 	}
864: 
865: 	if (TypeIsConstantSize(type.InternalType())) {
866: 		// constant size type: read fixed amount of data from
867: 		auto column_size = GetTypeIdSize(type.InternalType()) * count;
868: 		auto ptr = unique_ptr<data_t[]>(new data_t[column_size]);
869: 		source.ReadData(ptr.get(), column_size);
870: 
871: 		VectorOperations::ReadFromStorage(ptr.get(), count, *this);
872: 	} else {
873: 		switch (type.InternalType()) {
874: 		case PhysicalType::VARCHAR: {
875: 			auto strings = FlatVector::GetData<string_t>(*this);
876: 			for (idx_t i = 0; i < count; i++) {
877: 				// read the strings
878: 				auto str = source.Read<string>();
879: 				// now add the string to the StringHeap of the vector
880: 				// and write the pointer into the vector
881: 				if (validity.RowIsValid(i)) {
882: 					strings[i] = StringVector::AddStringOrBlob(*this, str);
883: 				}
884: 			}
885: 			break;
886: 		}
887: 		case PhysicalType::STRUCT: {
888: 			auto &entries = StructVector::GetEntries(*this);
889: 			for (auto &entry : entries) {
890: 				entry->Deserialize(count, source);
891: 			}
892: 			break;
893: 		}
894: 		case PhysicalType::LIST: {
895: 			// read the list size
896: 			auto list_size = source.Read<idx_t>();
897: 			ListVector::Reserve(*this, list_size);
898: 			ListVector::SetListSize(*this, list_size);
899: 
900: 			// read the list entry
901: 			auto list_entries = FlatVector::GetData(*this);
902: 			source.ReadData(list_entries, count * sizeof(list_entry_t));
903: 
904: 			// deserialize the child vector
905: 			auto &child = ListVector::GetEntry(*this);
906: 			child.Deserialize(list_size, source);
907: 
908: 			break;
909: 		}
910: 		default:
911: 			throw InternalException("Unimplemented variable width type for Vector::Deserialize!");
912: 		}
913: 	}
914: }
915: 
916: void Vector::SetVectorType(VectorType vector_type_p) {
917: 	this->vector_type = vector_type_p;
918: 	if (vector_type == VectorType::CONSTANT_VECTOR && GetType().InternalType() == PhysicalType::STRUCT) {
919: 		auto &entries = StructVector::GetEntries(*this);
920: 		for (auto &entry : entries) {
921: 			entry->SetVectorType(vector_type);
922: 		}
923: 	}
924: }
925: 
926: void Vector::UTFVerify(const SelectionVector &sel, idx_t count) {
927: #ifdef DEBUG
928: 	if (count == 0) {
929: 		return;
930: 	}
931: 	if (GetType().InternalType() == PhysicalType::VARCHAR) {
932: 		// we just touch all the strings and let the sanitizer figure out if any
933: 		// of them are deallocated/corrupt
934: 		switch (GetVectorType()) {
935: 		case VectorType::CONSTANT_VECTOR: {
936: 			auto string = ConstantVector::GetData<string_t>(*this);
937: 			if (!ConstantVector::IsNull(*this)) {
938: 				string->Verify();
939: 			}
940: 			break;
941: 		}
942: 		case VectorType::FLAT_VECTOR: {
943: 			auto strings = FlatVector::GetData<string_t>(*this);
944: 			for (idx_t i = 0; i < count; i++) {
945: 				auto oidx = sel.get_index(i);
946: 				if (validity.RowIsValid(oidx)) {
947: 					strings[oidx].Verify();
948: 				}
949: 			}
950: 			break;
951: 		}
952: 		default:
953: 			break;
954: 		}
955: 	}
956: #endif
957: }
958: 
959: void Vector::UTFVerify(idx_t count) {
960: 	UTFVerify(FlatVector::INCREMENTAL_SELECTION_VECTOR, count);
961: }
962: 
963: void Vector::Verify(const SelectionVector &sel, idx_t count) {
964: #ifdef DEBUG
965: 	if (count == 0) {
966: 		return;
967: 	}
968: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
969: 		auto &child = DictionaryVector::Child(*this);
970: 		D_ASSERT(child.GetVectorType() != VectorType::DICTIONARY_VECTOR);
971: 		auto &dict_sel = DictionaryVector::SelVector(*this);
972: 		// merge the selection vectors and verify the child
973: 		auto new_buffer = dict_sel.Slice(sel, count);
974: 		SelectionVector new_sel(new_buffer);
975: 		child.Verify(new_sel, count);
976: 		return;
977: 	}
978: 	if (TypeIsConstantSize(GetType().InternalType()) &&
979: 	    (GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR)) {
980: 		D_ASSERT(!auxiliary);
981: 	}
982: 	if (GetType().InternalType() == PhysicalType::DOUBLE) {
983: 		// verify that there are no INF or NAN values
984: 		switch (GetVectorType()) {
985: 		case VectorType::CONSTANT_VECTOR: {
986: 			auto dbl = ConstantVector::GetData<double>(*this);
987: 			if (!ConstantVector::IsNull(*this)) {
988: 				D_ASSERT(Value::DoubleIsValid(*dbl));
989: 			}
990: 			break;
991: 		}
992: 		case VectorType::FLAT_VECTOR: {
993: 			auto doubles = FlatVector::GetData<double>(*this);
994: 			for (idx_t i = 0; i < count; i++) {
995: 				auto oidx = sel.get_index(i);
996: 				if (validity.RowIsValid(oidx)) {
997: 					D_ASSERT(Value::DoubleIsValid(doubles[oidx]));
998: 				}
999: 			}
1000: 			break;
1001: 		}
1002: 		default:
1003: 			break;
1004: 		}
1005: 	}
1006: 	if (GetType().id() == LogicalTypeId::VARCHAR) {
1007: 		// verify that there are no '\0' bytes in string values
1008: 		switch (GetVectorType()) {
1009: 		case VectorType::FLAT_VECTOR: {
1010: 			auto strings = FlatVector::GetData<string_t>(*this);
1011: 			for (idx_t i = 0; i < count; i++) {
1012: 				auto oidx = sel.get_index(i);
1013: 				if (validity.RowIsValid(oidx)) {
1014: 					strings[oidx].VerifyNull();
1015: 				}
1016: 			}
1017: 			break;
1018: 		}
1019: 		default:
1020: 			break;
1021: 		}
1022: 	}
1023: 
1024: 	if (GetType().InternalType() == PhysicalType::STRUCT) {
1025: 		auto &child_types = StructType::GetChildTypes(GetType());
1026: 		D_ASSERT(child_types.size() > 0);
1027: 		if (GetVectorType() == VectorType::FLAT_VECTOR || GetVectorType() == VectorType::CONSTANT_VECTOR) {
1028: 			// create a selection vector of the non-null entries of the struct vector
1029: 			auto &children = StructVector::GetEntries(*this);
1030: 			D_ASSERT(child_types.size() == children.size());
1031: 			for (idx_t child_idx = 0; child_idx < children.size(); child_idx++) {
1032: 				if (GetVectorType() == VectorType::CONSTANT_VECTOR) {
1033: 					D_ASSERT(children[child_idx]->GetVectorType() == VectorType::CONSTANT_VECTOR);
1034: 					if (ConstantVector::IsNull(*this)) {
1035: 						D_ASSERT(ConstantVector::IsNull(*children[child_idx]));
1036: 					}
1037: 				} else if (GetVectorType() == VectorType::FLAT_VECTOR &&
1038: 				           children[child_idx]->GetVectorType() == VectorType::FLAT_VECTOR) {
1039: 					// for any NULL entry in the struct, the child should be NULL as well
1040: 					auto &validity = FlatVector::Validity(*this);
1041: 					auto &child_validity = FlatVector::Validity(*children[child_idx]);
1042: 					for (idx_t i = 0; i < count; i++) {
1043: 						auto index = sel.get_index(i);
1044: 						if (!validity.RowIsValid(index)) {
1045: 							D_ASSERT(!child_validity.RowIsValid(index));
1046: 						}
1047: 					}
1048: 				}
1049: 				D_ASSERT(children[child_idx]->GetType() == child_types[child_idx].second);
1050: 				children[child_idx]->Verify(sel, count);
1051: 			}
1052: 		}
1053: 	}
1054: 
1055: 	if (GetType().InternalType() == PhysicalType::LIST) {
1056: 		if (GetVectorType() == VectorType::CONSTANT_VECTOR) {
1057: 			if (!ConstantVector::IsNull(*this)) {
1058: 				auto &child = ListVector::GetEntry(*this);
1059: 				SelectionVector child_sel(ListVector::GetListSize(*this));
1060: 				idx_t child_count = 0;
1061: 				auto le = ConstantVector::GetData<list_entry_t>(*this);
1062: 				D_ASSERT(le->offset + le->length <= ListVector::GetListSize(*this));
1063: 				for (idx_t k = 0; k < le->length; k++) {
1064: 					child_sel.set_index(child_count++, le->offset + k);
1065: 				}
1066: 				child.Verify(child_sel, child_count);
1067: 			}
1068: 		} else if (GetVectorType() == VectorType::FLAT_VECTOR) {
1069: 			auto &child = ListVector::GetEntry(*this);
1070: 			auto child_size = ListVector::GetListSize(*this);
1071: 			auto list_data = FlatVector::GetData<list_entry_t>(*this);
1072: 			idx_t total_size = 0;
1073: 			for (idx_t i = 0; i < count; i++) {
1074: 				auto idx = sel.get_index(i);
1075: 				auto &le = list_data[idx];
1076: 				if (validity.RowIsValid(idx)) {
1077: 					D_ASSERT(le.offset + le.length <= child_size);
1078: 					total_size += le.length;
1079: 				}
1080: 			}
1081: 			SelectionVector child_sel(total_size);
1082: 			idx_t child_count = 0;
1083: 			for (idx_t i = 0; i < count; i++) {
1084: 				auto idx = sel.get_index(i);
1085: 				auto &le = list_data[idx];
1086: 				if (validity.RowIsValid(idx)) {
1087: 					D_ASSERT(le.offset + le.length <= child_size);
1088: 					for (idx_t k = 0; k < le.length; k++) {
1089: 						child_sel.set_index(child_count++, le.offset + k);
1090: 					}
1091: 				}
1092: 			}
1093: 			child.Verify(child_sel, child_count);
1094: 		}
1095: 	}
1096: #endif
1097: }
1098: 
1099: void Vector::Verify(idx_t count) {
1100: 	if (count > STANDARD_VECTOR_SIZE) {
1101: 		SelectionVector selection_vector(count);
1102: 		for (size_t i = 0; i < count; i++) {
1103: 			selection_vector.set_index(i, i);
1104: 		}
1105: 		Verify(selection_vector, count);
1106: 	} else {
1107: 		Verify(FlatVector::INCREMENTAL_SELECTION_VECTOR, count);
1108: 	}
1109: }
1110: 
1111: void FlatVector::SetNull(Vector &vector, idx_t idx, bool is_null) {
1112: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR);
1113: 	vector.validity.Set(idx, !is_null);
1114: 	if (is_null && vector.GetType().InternalType() == PhysicalType::STRUCT) {
1115: 		// set all child entries to null as well
1116: 		auto &entries = StructVector::GetEntries(vector);
1117: 		for (auto &entry : entries) {
1118: 			FlatVector::SetNull(*entry, idx, is_null);
1119: 		}
1120: 	}
1121: }
1122: 
1123: void ConstantVector::SetNull(Vector &vector, bool is_null) {
1124: 	D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1125: 	vector.validity.Set(0, !is_null);
1126: 	if (is_null && vector.GetType().InternalType() == PhysicalType::STRUCT) {
1127: 		// set all child entries to null as well
1128: 		auto &entries = StructVector::GetEntries(vector);
1129: 		for (auto &entry : entries) {
1130: 			entry->SetVectorType(VectorType::CONSTANT_VECTOR);
1131: 			ConstantVector::SetNull(*entry, is_null);
1132: 		}
1133: 	}
1134: }
1135: 
1136: const SelectionVector *ConstantVector::ZeroSelectionVector(idx_t count, SelectionVector &owned_sel) {
1137: 	if (count <= STANDARD_VECTOR_SIZE) {
1138: 		return &ConstantVector::ZERO_SELECTION_VECTOR;
1139: 	}
1140: 	owned_sel.Initialize(count);
1141: 	for (idx_t i = 0; i < count; i++) {
1142: 		owned_sel.set_index(i, 0);
1143: 	}
1144: 	return &owned_sel;
1145: }
1146: 
1147: void ConstantVector::Reference(Vector &vector, Vector &source, idx_t position, idx_t count) {
1148: 	D_ASSERT(position < count);
1149: 	auto &source_type = source.GetType();
1150: 	switch (source_type.InternalType()) {
1151: 	case PhysicalType::LIST: {
1152: 		// retrieve the list entry from the source vector
1153: 		VectorData vdata;
1154: 		source.Orrify(count, vdata);
1155: 
1156: 		auto list_index = vdata.sel->get_index(position);
1157: 		if (!vdata.validity.RowIsValid(list_index)) {
1158: 			// list is null: create null value
1159: 			Value null_value(source_type);
1160: 			vector.Reference(null_value);
1161: 			break;
1162: 		}
1163: 
1164: 		auto list_data = (list_entry_t *)vdata.data;
1165: 		auto list_entry = list_data[list_index];
1166: 
1167: 		// add the list entry as the first element of "vector"
1168: 		// FIXME: we only need to allocate space for 1 tuple here
1169: 		auto target_data = FlatVector::GetData<list_entry_t>(vector);
1170: 		target_data[0] = list_entry;
1171: 
1172: 		// create a reference to the child list of the source vector
1173: 		auto &child = ListVector::GetEntry(vector);
1174: 		child.Reference(ListVector::GetEntry(source));
1175: 
1176: 		ListVector::SetListSize(vector, ListVector::GetListSize(source));
1177: 		vector.SetVectorType(VectorType::CONSTANT_VECTOR);
1178: 		break;
1179: 	}
1180: 	case PhysicalType::STRUCT: {
1181: 		VectorData vdata;
1182: 		source.Orrify(count, vdata);
1183: 
1184: 		auto struct_index = vdata.sel->get_index(position);
1185: 		if (!vdata.validity.RowIsValid(struct_index)) {
1186: 			// null struct: create null value
1187: 			Value null_value(source_type);
1188: 			vector.Reference(null_value);
1189: 			break;
1190: 		}
1191: 
1192: 		// struct: pass constant reference into child entries
1193: 		auto &source_entries = StructVector::GetEntries(source);
1194: 		auto &target_entries = StructVector::GetEntries(vector);
1195: 		for (idx_t i = 0; i < source_entries.size(); i++) {
1196: 			ConstantVector::Reference(*target_entries[i], *source_entries[i], position, count);
1197: 		}
1198: 		vector.SetVectorType(VectorType::CONSTANT_VECTOR);
1199: 		break;
1200: 	}
1201: 	default:
1202: 		// default behavior: get a value from the vector and reference it
1203: 		// this is not that expensive for scalar types
1204: 		auto value = source.GetValue(position);
1205: 		vector.Reference(value);
1206: 		D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1207: 		break;
1208: 	}
1209: }
1210: 
1211: string_t StringVector::AddString(Vector &vector, const char *data, idx_t len) {
1212: 	return StringVector::AddString(vector, string_t(data, len));
1213: }
1214: 
1215: string_t StringVector::AddStringOrBlob(Vector &vector, const char *data, idx_t len) {
1216: 	return StringVector::AddStringOrBlob(vector, string_t(data, len));
1217: }
1218: 
1219: string_t StringVector::AddString(Vector &vector, const char *data) {
1220: 	return StringVector::AddString(vector, string_t(data, strlen(data)));
1221: }
1222: 
1223: string_t StringVector::AddString(Vector &vector, const string &data) {
1224: 	return StringVector::AddString(vector, string_t(data.c_str(), data.size()));
1225: }
1226: 
1227: string_t StringVector::AddString(Vector &vector, string_t data) {
1228: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::VARCHAR);
1229: 	if (data.IsInlined()) {
1230: 		// string will be inlined: no need to store in string heap
1231: 		return data;
1232: 	}
1233: 	if (!vector.auxiliary) {
1234: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1235: 	}
1236: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1237: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1238: 	return string_buffer.AddString(data);
1239: }
1240: 
1241: string_t StringVector::AddStringOrBlob(Vector &vector, string_t data) {
1242: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1243: 	if (data.IsInlined()) {
1244: 		// string will be inlined: no need to store in string heap
1245: 		return data;
1246: 	}
1247: 	if (!vector.auxiliary) {
1248: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1249: 	}
1250: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1251: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1252: 	return string_buffer.AddBlob(data);
1253: }
1254: 
1255: string_t StringVector::EmptyString(Vector &vector, idx_t len) {
1256: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1257: 	if (len < string_t::INLINE_LENGTH) {
1258: 		return string_t(len);
1259: 	}
1260: 	if (!vector.auxiliary) {
1261: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1262: 	}
1263: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1264: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1265: 	return string_buffer.EmptyString(len);
1266: }
1267: 
1268: void StringVector::AddHandle(Vector &vector, unique_ptr<BufferHandle> handle) {
1269: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1270: 	if (!vector.auxiliary) {
1271: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1272: 	}
1273: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1274: 	string_buffer.AddHeapReference(make_buffer<ManagedVectorBuffer>(move(handle)));
1275: }
1276: 
1277: void StringVector::AddBuffer(Vector &vector, buffer_ptr<VectorBuffer> buffer) {
1278: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1279: 	D_ASSERT(buffer.get() != vector.auxiliary.get());
1280: 	if (!vector.auxiliary) {
1281: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1282: 	}
1283: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1284: 	string_buffer.AddHeapReference(move(buffer));
1285: }
1286: 
1287: void StringVector::AddHeapReference(Vector &vector, Vector &other) {
1288: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1289: 	D_ASSERT(other.GetType().InternalType() == PhysicalType::VARCHAR);
1290: 
1291: 	if (other.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1292: 		StringVector::AddHeapReference(vector, DictionaryVector::Child(other));
1293: 		return;
1294: 	}
1295: 	if (!other.auxiliary) {
1296: 		return;
1297: 	}
1298: 	StringVector::AddBuffer(vector, other.auxiliary);
1299: }
1300: 
1301: vector<unique_ptr<Vector>> &StructVector::GetEntries(Vector &vector) {
1302: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::STRUCT || vector.GetType().id() == LogicalTypeId::MAP);
1303: 	if (vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1304: 		auto &child = DictionaryVector::Child(vector);
1305: 		return StructVector::GetEntries(child);
1306: 	}
1307: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1308: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1309: 	D_ASSERT(vector.auxiliary);
1310: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRUCT_BUFFER);
1311: 	return ((VectorStructBuffer *)vector.auxiliary.get())->GetChildren();
1312: }
1313: 
1314: const vector<unique_ptr<Vector>> &StructVector::GetEntries(const Vector &vector) {
1315: 	return GetEntries((Vector &)vector);
1316: }
1317: 
1318: const Vector &ListVector::GetEntry(const Vector &vector) {
1319: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST);
1320: 	if (vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1321: 		auto &child = DictionaryVector::Child(vector);
1322: 		return ListVector::GetEntry(child);
1323: 	}
1324: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1325: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1326: 	D_ASSERT(vector.auxiliary);
1327: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::LIST_BUFFER);
1328: 	return ((VectorListBuffer *)vector.auxiliary.get())->GetChild();
1329: }
1330: 
1331: Vector &ListVector::GetEntry(Vector &vector) {
1332: 	const Vector &cvector = vector;
1333: 	return const_cast<Vector &>(ListVector::GetEntry(cvector));
1334: }
1335: 
1336: void ListVector::Reserve(Vector &vector, idx_t required_capacity) {
1337: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST);
1338: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1339: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1340: 	D_ASSERT(vector.auxiliary);
1341: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::LIST_BUFFER);
1342: 	auto &child_buffer = *((VectorListBuffer *)vector.auxiliary.get());
1343: 	child_buffer.Reserve(required_capacity);
1344: }
1345: 
1346: template <class T>
1347: void TemplatedSearchInMap(Vector &list, T key, vector<idx_t> &offsets, bool is_key_null, idx_t offset, idx_t length) {
1348: 	auto &list_vector = ListVector::GetEntry(list);
1349: 	VectorData vector_data;
1350: 	list_vector.Orrify(ListVector::GetListSize(list), vector_data);
1351: 	auto data = (T *)vector_data.data;
1352: 	auto validity_mask = vector_data.validity;
1353: 
1354: 	if (is_key_null) {
1355: 		for (idx_t i = offset; i < offset + length; i++) {
1356: 			if (!validity_mask.RowIsValid(i)) {
1357: 				offsets.push_back(i);
1358: 			}
1359: 		}
1360: 	} else {
1361: 		for (idx_t i = offset; i < offset + length; i++) {
1362: 			if (!validity_mask.RowIsValid(i)) {
1363: 				continue;
1364: 			}
1365: 			if (key == data[i]) {
1366: 				offsets.push_back(i);
1367: 			}
1368: 		}
1369: 	}
1370: }
1371: 
1372: void SearchString(Vector &list, string &key, vector<idx_t> &offsets, bool is_key_null, idx_t offset, idx_t length) {
1373: 	auto &list_vector = ListVector::GetEntry(list);
1374: 	VectorData vector_data;
1375: 	list_vector.Orrify(ListVector::GetListSize(list), vector_data);
1376: 	auto data = (string_t *)vector_data.data;
1377: 	auto validity_mask = vector_data.validity;
1378: 	if (is_key_null) {
1379: 		for (idx_t i = offset; i < offset + length; i++) {
1380: 			if (!validity_mask.RowIsValid(i)) {
1381: 				offsets.push_back(i);
1382: 			}
1383: 		}
1384: 	} else {
1385: 		string_t key_str_t(key);
1386: 		for (idx_t i = offset; i < offset + length; i++) {
1387: 			if (!validity_mask.RowIsValid(i)) {
1388: 				continue;
1389: 			}
1390: 			if (Equals::Operation<string_t>(data[i], key_str_t)) {
1391: 				offsets.push_back(i);
1392: 			}
1393: 		}
1394: 	}
1395: }
1396: 
1397: vector<idx_t> ListVector::Search(Vector &list, Value &key, idx_t row) {
1398: 	vector<idx_t> offsets;
1399: 
1400: 	auto &list_vector = ListVector::GetEntry(list);
1401: 	auto &entry = ((list_entry_t *)list.GetData())[row];
1402: 	switch (list_vector.GetType().id()) {
1403: 
1404: 	case LogicalTypeId::SQLNULL:
1405: 		if (key.is_null) {
1406: 			for (idx_t i = entry.offset; i < entry.offset + entry.length; i++) {
1407: 				offsets.push_back(i);
1408: 			}
1409: 		}
1410: 		break;
1411: 	case LogicalTypeId::UTINYINT:
1412: 		::duckdb::TemplatedSearchInMap<uint8_t>(list, key.value_.utinyint, offsets, key.is_null, entry.offset,
1413: 		                                        entry.length);
1414: 		break;
1415: 	case LogicalTypeId::TINYINT:
1416: 		::duckdb::TemplatedSearchInMap<int8_t>(list, key.value_.tinyint, offsets, key.is_null, entry.offset,
1417: 		                                       entry.length);
1418: 		break;
1419: 	case LogicalTypeId::USMALLINT:
1420: 		::duckdb::TemplatedSearchInMap<uint16_t>(list, key.value_.usmallint, offsets, key.is_null, entry.offset,
1421: 		                                         entry.length);
1422: 		break;
1423: 	case LogicalTypeId::SMALLINT:
1424: 		::duckdb::TemplatedSearchInMap<int16_t>(list, key.value_.smallint, offsets, key.is_null, entry.offset,
1425: 		                                        entry.length);
1426: 		break;
1427: 	case LogicalTypeId::UINTEGER:
1428: 		::duckdb::TemplatedSearchInMap<uint32_t>(list, key.value_.uinteger, offsets, key.is_null, entry.offset,
1429: 		                                         entry.length);
1430: 		break;
1431: 	case LogicalTypeId::INTEGER:
1432: 		::duckdb::TemplatedSearchInMap<int32_t>(list, key.value_.integer, offsets, key.is_null, entry.offset,
1433: 		                                        entry.length);
1434: 		break;
1435: 	case LogicalTypeId::UBIGINT:
1436: 		::duckdb::TemplatedSearchInMap<uint64_t>(list, key.value_.ubigint, offsets, key.is_null, entry.offset,
1437: 		                                         entry.length);
1438: 		break;
1439: 	case LogicalTypeId::BIGINT:
1440: 		::duckdb::TemplatedSearchInMap<int64_t>(list, key.value_.bigint, offsets, key.is_null, entry.offset,
1441: 		                                        entry.length);
1442: 		break;
1443: 	case LogicalTypeId::HUGEINT:
1444: 		::duckdb::TemplatedSearchInMap<hugeint_t>(list, key.value_.hugeint, offsets, key.is_null, entry.offset,
1445: 		                                          entry.length);
1446: 		break;
1447: 	case LogicalTypeId::FLOAT:
1448: 		::duckdb::TemplatedSearchInMap<float>(list, key.value_.float_, offsets, key.is_null, entry.offset,
1449: 		                                      entry.length);
1450: 		break;
1451: 	case LogicalTypeId::DOUBLE:
1452: 		::duckdb::TemplatedSearchInMap<double>(list, key.value_.double_, offsets, key.is_null, entry.offset,
1453: 		                                       entry.length);
1454: 		break;
1455: 	case LogicalTypeId::DATE:
1456: 		::duckdb::TemplatedSearchInMap<date_t>(list, key.value_.date, offsets, key.is_null, entry.offset, entry.length);
1457: 		break;
1458: 	case LogicalTypeId::TIME:
1459: 		::duckdb::TemplatedSearchInMap<dtime_t>(list, key.value_.time, offsets, key.is_null, entry.offset,
1460: 		                                        entry.length);
1461: 		break;
1462: 	case LogicalTypeId::TIMESTAMP:
1463: 		::duckdb::TemplatedSearchInMap<timestamp_t>(list, key.value_.timestamp, offsets, key.is_null, entry.offset,
1464: 		                                            entry.length);
1465: 		break;
1466: 	case LogicalTypeId::BLOB:
1467: 	case LogicalTypeId::VARCHAR:
1468: 		::duckdb::SearchString(list, key.str_value, offsets, key.is_null, entry.offset, entry.length);
1469: 		break;
1470: 	default:
1471: 		throw InvalidTypeException(list.GetType().id(), "Invalid type for List Vector Search");
1472: 	}
1473: 	return offsets;
1474: }
1475: 
1476: Value ListVector::GetValuesFromOffsets(Vector &list, vector<idx_t> &offsets) {
1477: 	Value ret(ListType::GetChildType(list.GetType()));
1478: 	ret.is_null = false;
1479: 	auto &child_vec = ListVector::GetEntry(list);
1480: 	for (auto &offset : offsets) {
1481: 		ret.list_value.push_back(child_vec.GetValue(offset));
1482: 	}
1483: 	return ret;
1484: }
1485: 
1486: idx_t ListVector::GetListSize(const Vector &vec) {
1487: 	if (vec.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1488: 		auto &child = DictionaryVector::Child(vec);
1489: 		return ListVector::GetListSize(child);
1490: 	}
1491: 	D_ASSERT(vec.auxiliary);
1492: 	return ((VectorListBuffer &)*vec.auxiliary).size;
1493: }
1494: 
1495: void ListVector::ReferenceEntry(Vector &vector, Vector &other) {
1496: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST);
1497: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1498: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1499: 	D_ASSERT(other.GetType().id() == LogicalTypeId::LIST);
1500: 	D_ASSERT(other.GetVectorType() == VectorType::FLAT_VECTOR || other.GetVectorType() == VectorType::CONSTANT_VECTOR);
1501: 	vector.auxiliary = other.auxiliary;
1502: }
1503: 
1504: void ListVector::SetListSize(Vector &vec, idx_t size) {
1505: 	if (vec.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1506: 		auto &child = DictionaryVector::Child(vec);
1507: 		ListVector::SetListSize(child, size);
1508: 	}
1509: 	((VectorListBuffer &)*vec.auxiliary).size = size;
1510: }
1511: 
1512: void ListVector::Append(Vector &target, const Vector &source, idx_t source_size, idx_t source_offset) {
1513: 	if (source_size - source_offset == 0) {
1514: 		//! Nothing to add
1515: 		return;
1516: 	}
1517: 	auto &target_buffer = (VectorListBuffer &)*target.auxiliary;
1518: 	target_buffer.Append(source, source_size, source_offset);
1519: }
1520: 
1521: void ListVector::Append(Vector &target, const Vector &source, const SelectionVector &sel, idx_t source_size,
1522:                         idx_t source_offset) {
1523: 	if (source_size - source_offset == 0) {
1524: 		//! Nothing to add
1525: 		return;
1526: 	}
1527: 	auto &target_buffer = (VectorListBuffer &)*target.auxiliary;
1528: 	target_buffer.Append(source, sel, source_size, source_offset);
1529: }
1530: 
1531: void ListVector::PushBack(Vector &target, Value &insert) {
1532: 	auto &target_buffer = (VectorListBuffer &)*target.auxiliary;
1533: 	target_buffer.PushBack(insert);
1534: }
1535: 
1536: } // namespace duckdb
[end of src/common/types/vector.cpp]
[start of src/include/duckdb/common/types/vector.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/vector.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/bitset.hpp"
12: #include "duckdb/common/common.hpp"
13: #include "duckdb/common/enums/vector_type.hpp"
14: #include "duckdb/common/types/selection_vector.hpp"
15: #include "duckdb/common/types/validity_mask.hpp"
16: #include "duckdb/common/types/value.hpp"
17: #include "duckdb/common/types/vector_buffer.hpp"
18: #include "duckdb/common/vector_size.hpp"
19: 
20: namespace duckdb {
21: 
22: struct VectorData {
23: 	const SelectionVector *sel;
24: 	data_ptr_t data;
25: 	ValidityMask validity;
26: 	SelectionVector owned_sel;
27: };
28: 
29: class VectorCache;
30: class VectorStructBuffer;
31: class VectorListBuffer;
32: class ChunkCollection;
33: 
34: struct SelCache;
35: 
36: //!  Vector of values of a specified PhysicalType.
37: class Vector {
38: 	friend struct ConstantVector;
39: 	friend struct DictionaryVector;
40: 	friend struct FlatVector;
41: 	friend struct ListVector;
42: 	friend struct StringVector;
43: 	friend struct StructVector;
44: 	friend struct SequenceVector;
45: 
46: 	friend class DataChunk;
47: 	friend class VectorCacheBuffer;
48: 
49: public:
50: 	//! Create a vector that references the other vector
51: 	explicit Vector(Vector &other);
52: 	//! Create a vector that slices another vector
53: 	explicit Vector(Vector &other, const SelectionVector &sel, idx_t count);
54: 	//! Create a vector that slices another vector starting from a specific offset
55: 	explicit Vector(Vector &other, idx_t offset);
56: 	//! Create a vector of size one holding the passed on value
57: 	explicit Vector(const Value &value);
58: 	//! Create a vector of size tuple_count (non-standard)
59: 	explicit Vector(LogicalType type, idx_t capacity = STANDARD_VECTOR_SIZE);
60: 	//! Create an empty standard vector with a type, equivalent to calling Vector(type, true, false)
61: 	explicit Vector(const VectorCache &cache);
62: 	//! Create a non-owning vector that references the specified data
63: 	Vector(LogicalType type, data_ptr_t dataptr);
64: 	//! Create an owning vector that holds at most STANDARD_VECTOR_SIZE entries.
65: 	/*!
66: 	    Create a new vector
67: 	    If create_data is true, the vector will be an owning empty vector.
68: 	    If zero_data is true, the allocated data will be zero-initialized.
69: 	*/
70: 	Vector(LogicalType type, bool create_data, bool zero_data, idx_t capacity = STANDARD_VECTOR_SIZE);
71: 	// implicit copying of Vectors is not allowed
72: 	Vector(const Vector &) = delete;
73: 	// but moving of vectors is allowed
74: 	Vector(Vector &&other) noexcept;
75: 
76: public:
77: 	//! Create a vector that references the specified value.
78: 	void Reference(const Value &value);
79: 	//! Causes this vector to reference the data held by the other vector.
80: 	//! The type of the "other" vector should match the type of this vector
81: 	void Reference(Vector &other);
82: 	//! Reinterpret the data of the other vector as the type of this vector
83: 	//! Note that this takes the data of the other vector as-is and places it in this vector
84: 	//! Without changing the type of this vector
85: 	void Reinterpret(Vector &other);
86: 
87: 	//! Resets a vector from a vector cache.
88: 	//! This turns the vector back into an empty FlatVector with STANDARD_VECTOR_SIZE entries.
89: 	//! The VectorCache is used so this can be done without requiring any allocations.
90: 	void ResetFromCache(const VectorCache &cache);
91: 
92: 	//! Creates a reference to a slice of the other vector
93: 	void Slice(Vector &other, idx_t offset);
94: 	//! Creates a reference to a slice of the other vector
95: 	void Slice(Vector &other, const SelectionVector &sel, idx_t count);
96: 	//! Turns the vector into a dictionary vector with the specified dictionary
97: 	void Slice(const SelectionVector &sel, idx_t count);
98: 	//! Slice the vector, keeping the result around in a cache or potentially using the cache instead of slicing
99: 	void Slice(const SelectionVector &sel, idx_t count, SelCache &cache);
100: 
101: 	//! Creates the data of this vector with the specified type. Any data that
102: 	//! is currently in the vector is destroyed.
103: 	void Initialize(bool zero_data = false, idx_t capacity = STANDARD_VECTOR_SIZE);
104: 
105: 	//! Converts this Vector to a printable string representation
106: 	string ToString(idx_t count) const;
107: 	void Print(idx_t count);
108: 
109: 	string ToString() const;
110: 	void Print();
111: 
112: 	//! Flatten the vector, removing any compression and turning it into a FLAT_VECTOR
113: 	DUCKDB_API void Normalify(idx_t count);
114: 	DUCKDB_API void Normalify(const SelectionVector &sel, idx_t count);
115: 	//! Obtains a selection vector and data pointer through which the data of this vector can be accessed
116: 	DUCKDB_API void Orrify(idx_t count, VectorData &data);
117: 
118: 	//! Turn the vector into a sequence vector
119: 	void Sequence(int64_t start, int64_t increment);
120: 
121: 	//! Verify that the Vector is in a consistent, not corrupt state. DEBUG
122: 	//! FUNCTION ONLY!
123: 	void Verify(idx_t count);
124: 	void Verify(const SelectionVector &sel, idx_t count);
125: 	void UTFVerify(idx_t count);
126: 	void UTFVerify(const SelectionVector &sel, idx_t count);
127: 
128: 	//! Returns the [index] element of the Vector as a Value.
129: 	Value GetValue(idx_t index) const;
130: 	//! Sets the [index] element of the Vector to the specified Value.
131: 	void SetValue(idx_t index, const Value &val);
132: 
133: 	void SetAuxiliary(buffer_ptr<VectorBuffer> new_buffer) {
134: 		auxiliary = std::move(new_buffer);
135: 	};
136: 
137: 	//! This functions resizes the vector
138: 	void Resize(idx_t cur_size, idx_t new_size);
139: 
140: 	//! Serializes a Vector to a stand-alone binary blob
141: 	void Serialize(idx_t count, Serializer &serializer);
142: 	//! Deserializes a blob back into a Vector
143: 	void Deserialize(idx_t count, Deserializer &source);
144: 
145: 	// Getters
146: 	inline VectorType GetVectorType() const {
147: 		return vector_type;
148: 	}
149: 	inline const LogicalType &GetType() const {
150: 		return type;
151: 	}
152: 	inline data_ptr_t GetData() {
153: 		return data;
154: 	}
155: 
156: 	buffer_ptr<VectorBuffer> GetAuxiliary() {
157: 		return auxiliary;
158: 	}
159: 
160: 	buffer_ptr<VectorBuffer> GetBuffer() {
161: 		return buffer;
162: 	}
163: 
164: 	// Setters
165: 	DUCKDB_API void SetVectorType(VectorType vector_type);
166: 
167: protected:
168: 	//! The vector type specifies how the data of the vector is physically stored (i.e. if it is a single repeated
169: 	//! constant, if it is compressed)
170: 	VectorType vector_type;
171: 	//! The type of the elements stored in the vector (e.g. integer, float)
172: 	LogicalType type;
173: 	//! A pointer to the data.
174: 	data_ptr_t data;
175: 	//! The validity mask of the vector
176: 	ValidityMask validity;
177: 	//! The main buffer holding the data of the vector
178: 	buffer_ptr<VectorBuffer> buffer;
179: 	//! The buffer holding auxiliary data of the vector
180: 	//! e.g. a string vector uses this to store strings
181: 	buffer_ptr<VectorBuffer> auxiliary;
182: };
183: 
184: //! The DictionaryBuffer holds a selection vector
185: class VectorChildBuffer : public VectorBuffer {
186: public:
187: 	VectorChildBuffer(Vector vector) : VectorBuffer(VectorBufferType::VECTOR_CHILD_BUFFER), data(move(vector)) {
188: 	}
189: 
190: public:
191: 	Vector data;
192: };
193: 
194: struct ConstantVector {
195: 	static inline const_data_ptr_t GetData(const Vector &vector) {
196: 		D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR ||
197: 		         vector.GetVectorType() == VectorType::FLAT_VECTOR);
198: 		return vector.data;
199: 	}
200: 	static inline data_ptr_t GetData(Vector &vector) {
201: 		D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR ||
202: 		         vector.GetVectorType() == VectorType::FLAT_VECTOR);
203: 		return vector.data;
204: 	}
205: 	template <class T>
206: 	static inline const T *GetData(const Vector &vector) {
207: 		return (const T *)ConstantVector::GetData(vector);
208: 	}
209: 	template <class T>
210: 	static inline T *GetData(Vector &vector) {
211: 		return (T *)ConstantVector::GetData(vector);
212: 	}
213: 	static inline bool IsNull(const Vector &vector) {
214: 		D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
215: 		return !vector.validity.RowIsValid(0);
216: 	}
217: 	DUCKDB_API static void SetNull(Vector &vector, bool is_null);
218: 	static inline ValidityMask &Validity(Vector &vector) {
219: 		D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
220: 		return vector.validity;
221: 	}
222: 	DUCKDB_API static const SelectionVector *ZeroSelectionVector(idx_t count, SelectionVector &owned_sel);
223: 	//! Turns "vector" into a constant vector by referencing a value within the source vector
224: 	DUCKDB_API static void Reference(Vector &vector, Vector &source, idx_t position, idx_t count);
225: 
226: 	static const sel_t ZERO_VECTOR[STANDARD_VECTOR_SIZE];
227: 	static const SelectionVector ZERO_SELECTION_VECTOR;
228: };
229: 
230: struct DictionaryVector {
231: 	static inline const SelectionVector &SelVector(const Vector &vector) {
232: 		D_ASSERT(vector.GetVectorType() == VectorType::DICTIONARY_VECTOR);
233: 		return ((const DictionaryBuffer &)*vector.buffer).GetSelVector();
234: 	}
235: 	static inline SelectionVector &SelVector(Vector &vector) {
236: 		D_ASSERT(vector.GetVectorType() == VectorType::DICTIONARY_VECTOR);
237: 		return ((DictionaryBuffer &)*vector.buffer).GetSelVector();
238: 	}
239: 	static inline const Vector &Child(const Vector &vector) {
240: 		D_ASSERT(vector.GetVectorType() == VectorType::DICTIONARY_VECTOR);
241: 		return ((const VectorChildBuffer &)*vector.auxiliary).data;
242: 	}
243: 	static inline Vector &Child(Vector &vector) {
244: 		D_ASSERT(vector.GetVectorType() == VectorType::DICTIONARY_VECTOR);
245: 		return ((VectorChildBuffer &)*vector.auxiliary).data;
246: 	}
247: };
248: 
249: struct FlatVector {
250: 	static inline data_ptr_t GetData(Vector &vector) {
251: 		return ConstantVector::GetData(vector);
252: 	}
253: 	template <class T>
254: 	static inline const T *GetData(const Vector &vector) {
255: 		return ConstantVector::GetData<T>(vector);
256: 	}
257: 	template <class T>
258: 	static inline T *GetData(Vector &vector) {
259: 		return ConstantVector::GetData<T>(vector);
260: 	}
261: 	static inline void SetData(Vector &vector, data_ptr_t data) {
262: 		D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR);
263: 		vector.data = data;
264: 	}
265: 	template <class T>
266: 	static inline T GetValue(Vector &vector, idx_t idx) {
267: 		D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR);
268: 		return FlatVector::GetData<T>(vector)[idx];
269: 	}
270: 	static inline const ValidityMask &Validity(const Vector &vector) {
271: 		D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR);
272: 		return vector.validity;
273: 	}
274: 	static inline ValidityMask &Validity(Vector &vector) {
275: 		D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR);
276: 		return vector.validity;
277: 	}
278: 	static inline void SetValidity(Vector &vector, ValidityMask &new_validity) {
279: 		D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR);
280: 		vector.validity.Initialize(new_validity);
281: 	}
282: 	static void SetNull(Vector &vector, idx_t idx, bool is_null);
283: 	static inline bool IsNull(const Vector &vector, idx_t idx) {
284: 		D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR);
285: 		return !vector.validity.RowIsValid(idx);
286: 	}
287: 
288: 	static const sel_t INCREMENTAL_VECTOR[STANDARD_VECTOR_SIZE];
289: 	static const SelectionVector INCREMENTAL_SELECTION_VECTOR;
290: };
291: 
292: struct ListVector {
293: 	static inline list_entry_t *GetData(Vector &v) {
294: 		if (v.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
295: 			auto &child = DictionaryVector::Child(v);
296: 			return GetData(child);
297: 		}
298: 		return FlatVector::GetData<list_entry_t>(v);
299: 	}
300: 	//! Gets a reference to the underlying child-vector of a list
301: 	DUCKDB_API static const Vector &GetEntry(const Vector &vector);
302: 	//! Gets a reference to the underlying child-vector of a list
303: 	DUCKDB_API static Vector &GetEntry(Vector &vector);
304: 	//! Gets the total size of the underlying child-vector of a list
305: 	DUCKDB_API static idx_t GetListSize(const Vector &vector);
306: 	//! Sets the total size of the underlying child-vector of a list
307: 	DUCKDB_API static void SetListSize(Vector &vec, idx_t size);
308: 	DUCKDB_API static void Reserve(Vector &vec, idx_t required_capacity);
309: 	DUCKDB_API static void Append(Vector &target, const Vector &source, idx_t source_size, idx_t source_offset = 0);
310: 	DUCKDB_API static void Append(Vector &target, const Vector &source, const SelectionVector &sel, idx_t source_size,
311: 	                              idx_t source_offset = 0);
312: 	DUCKDB_API static void PushBack(Vector &target, Value &insert);
313: 	DUCKDB_API static vector<idx_t> Search(Vector &list, Value &key, idx_t row);
314: 	DUCKDB_API static Value GetValuesFromOffsets(Vector &list, vector<idx_t> &offsets);
315: 	//! Share the entry of the other list vector
316: 	DUCKDB_API static void ReferenceEntry(Vector &vector, Vector &other);
317: };
318: 
319: struct StringVector {
320: 	//! Add a string to the string heap of the vector (auxiliary data)
321: 	DUCKDB_API static string_t AddString(Vector &vector, const char *data, idx_t len);
322: 	//! Add a string or a blob to the string heap of the vector (auxiliary data)
323: 	//! This function is the same as ::AddString, except the added data does not need to be valid UTF8
324: 	DUCKDB_API static string_t AddStringOrBlob(Vector &vector, const char *data, idx_t len);
325: 	//! Add a string to the string heap of the vector (auxiliary data)
326: 	DUCKDB_API static string_t AddString(Vector &vector, const char *data);
327: 	//! Add a string to the string heap of the vector (auxiliary data)
328: 	DUCKDB_API static string_t AddString(Vector &vector, string_t data);
329: 	//! Add a string to the string heap of the vector (auxiliary data)
330: 	DUCKDB_API static string_t AddString(Vector &vector, const string &data);
331: 	//! Add a string or a blob to the string heap of the vector (auxiliary data)
332: 	//! This function is the same as ::AddString, except the added data does not need to be valid UTF8
333: 	DUCKDB_API static string_t AddStringOrBlob(Vector &vector, string_t data);
334: 	//! Allocates an empty string of the specified size, and returns a writable pointer that can be used to store the
335: 	//! result of an operation
336: 	DUCKDB_API static string_t EmptyString(Vector &vector, idx_t len);
337: 	//! Adds a reference to a handle that stores strings of this vector
338: 	DUCKDB_API static void AddHandle(Vector &vector, unique_ptr<BufferHandle> handle);
339: 	//! Adds a reference to an unspecified vector buffer that stores strings of this vector
340: 	DUCKDB_API static void AddBuffer(Vector &vector, buffer_ptr<VectorBuffer> buffer);
341: 	//! Add a reference from this vector to the string heap of the provided vector
342: 	DUCKDB_API static void AddHeapReference(Vector &vector, Vector &other);
343: };
344: 
345: struct StructVector {
346: 	DUCKDB_API static const vector<unique_ptr<Vector>> &GetEntries(const Vector &vector);
347: 	DUCKDB_API static vector<unique_ptr<Vector>> &GetEntries(Vector &vector);
348: };
349: 
350: struct SequenceVector {
351: 	static void GetSequence(const Vector &vector, int64_t &start, int64_t &increment) {
352: 		D_ASSERT(vector.GetVectorType() == VectorType::SEQUENCE_VECTOR);
353: 		auto data = (int64_t *)vector.buffer->GetData();
354: 		start = data[0];
355: 		increment = data[1];
356: 	}
357: };
358: 
359: } // namespace duckdb
[end of src/include/duckdb/common/types/vector.hpp]
[start of tools/jdbc/CMakeLists.txt]
1: find_package(Java 1.8)
2: find_package(JNI)
3: 
4: cmake_minimum_required(VERSION 3.11.0)
5: 
6: if(NOT JNI_FOUND OR NOT Java_FOUND)
7:   message(FATAL_ERROR No compatible Java/JNI found)
8: endif()
9: 
10: include(UseJava)
11: project(DuckDBJDummy NONE)
12: 
13: file(GLOB JAVA_SRC_FILES src/main/java/org/duckdb/*.java)
14: file(GLOB JAVA_TEST_FILES src/test/java/org/duckdb/test/*.java)
15: 
16: set(CMAKE_JAVA_COMPILE_FLAGS -source 1.7 -target 1.7 -encoding utf-8)
17: 
18: add_jar(duckdb_jdbc ${JAVA_SRC_FILES} ${JAVA_TEST_FILES}
19:         META-INF/services/java.sql.Driver GENERATE_NATIVE_HEADERS duckdb-native)
20: 
21: set(OS_NAME "unknown")
22: if(APPLE)
23:   set(OS_NAME "osx")
24: endif()
25: if(WIN32)
26:   set(OS_NAME "windows")
27: endif()
28: if(UNIX AND NOT APPLE)
29:   set(OS_NAME "linux") # sorry BSD
30: endif()
31: 
32: set(JVM_BITNESS "amd64")
33: # TODO handle 32 bit architectures
34: 
35: include_directories(../../extension/parquet/include)
36: 
37: add_library(duckdb_java SHARED src/jni/duckdb_java.cpp)
38: target_compile_options(duckdb_java PRIVATE -fexceptions)
39: target_link_libraries(duckdb_java duckdb-native duckdb_static parquet_extension)
40: if(OS_NAME STREQUAL "linux")
41:   target_link_libraries(duckdb_java -static-libgcc -static-libstdc++
42:   )# static link to libstdc++ to target more linux distro
43: endif()
44: string(JOIN "_" LIB_SUFFIX ".so" ${OS_NAME} ${JVM_BITNESS})
45: set_target_properties(duckdb_java PROPERTIES SUFFIX ${LIB_SUFFIX})
46: set_target_properties(duckdb_java PROPERTIES PREFIX "lib")
47: 
48: add_custom_command(
49:   OUTPUT dummy_jdbc_target
50:   DEPENDS duckdb_java duckdb_jdbc
51:   COMMAND ${Java_JAR_EXECUTABLE} uf duckdb_jdbc.jar -C
52:           $<TARGET_FILE_DIR:duckdb_java> $<TARGET_FILE_NAME:duckdb_java>)
53: 
54: add_custom_target(jdbc ALL DEPENDS dummy_jdbc_target)
[end of tools/jdbc/CMakeLists.txt]
[start of tools/jdbc/src/jni/duckdb_java.cpp]
1: #include "org_duckdb_DuckDBNative.h"
2: #include "duckdb.hpp"
3: #include "duckdb/main/client_context.hpp"
4: #include "duckdb/main/appender.hpp"
5: #include "parquet-extension.hpp"
6: 
7: using namespace duckdb;
8: using namespace std;
9: 
10: static string byte_array_to_string(JNIEnv *env, jbyteArray ba_j) {
11: 	idx_t len = env->GetArrayLength(ba_j);
12: 	string ret;
13: 	ret.resize(len);
14: 
15: 	jbyte *bytes = (jbyte *)env->GetByteArrayElements(ba_j, NULL);
16: 
17: 	for (idx_t i = 0; i < len; i++) {
18: 		ret[i] = bytes[i];
19: 	}
20: 	env->ReleaseByteArrayElements(ba_j, bytes, 0);
21: 
22: 	return ret;
23: }
24: 
25: static jobject decode_charbuffer_to_jstring(JNIEnv *env, const char *d_str, idx_t d_str_len) {
26: 	jclass charset_class = env->FindClass("java/nio/charset/Charset");
27: 	jclass charbuffer_class = env->FindClass("java/nio/CharBuffer");
28: 	jmethodID for_name =
29: 	    env->GetStaticMethodID(charset_class, "forName", "(Ljava/lang/String;)Ljava/nio/charset/Charset;");
30: 	jobject charset = env->CallStaticObjectMethod(charset_class, for_name, env->NewStringUTF("UTF-8"));
31: 	jmethodID charset_decode =
32: 	    env->GetMethodID(charset_class, "decode", "(Ljava/nio/ByteBuffer;)Ljava/nio/CharBuffer;");
33: 	jmethodID charbuffer_to_string = env->GetMethodID(charbuffer_class, "toString", "()Ljava/lang/String;");
34: 
35: 	auto bb = env->NewDirectByteBuffer((void *)d_str, d_str_len);
36: 	auto j_cb = env->CallObjectMethod(charset, charset_decode, bb);
37: 	auto j_str = env->CallObjectMethod(j_cb, charbuffer_to_string);
38: 	return j_str;
39: }
40: 
41: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1startup(JNIEnv *env, jclass, jbyteArray database_j,
42:                                                                              jboolean read_only) {
43: 	auto database = byte_array_to_string(env, database_j);
44: 	DBConfig config;
45: 	if (read_only) {
46: 		config.access_mode = AccessMode::READ_ONLY;
47: 	}
48: 	try {
49: 		auto db = new DuckDB(database, &config);
50: 		db->LoadExtension<ParquetExtension>();
51: 		return env->NewDirectByteBuffer(db, 0);
52: 	} catch (exception &e) {
53: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
54: 	}
55: 	return nullptr;
56: }
57: 
58: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1shutdown(JNIEnv *env, jclass, jobject db_ref_buf) {
59: 	auto db_ref = (DuckDB *)env->GetDirectBufferAddress(db_ref_buf);
60: 	if (db_ref) {
61: 		delete db_ref;
62: 	}
63: }
64: 
65: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1connect(JNIEnv *env, jclass, jobject db_ref_buf) {
66: 	auto db_ref = (DuckDB *)env->GetDirectBufferAddress(db_ref_buf);
67: 	try {
68: 		auto conn = new Connection(*db_ref);
69: 		return env->NewDirectByteBuffer(conn, 0);
70: 	} catch (exception &e) {
71: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
72: 	}
73: 	return nullptr;
74: }
75: 
76: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1set_1auto_1commit(JNIEnv *env, jclass,
77:                                                                                     jobject conn_ref_buf,
78:                                                                                     jboolean auto_commit) {
79: 	auto conn_ref = (Connection *)env->GetDirectBufferAddress(conn_ref_buf);
80: 	if (!conn_ref || !conn_ref->context) {
81: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid connection");
82: 	}
83: 	conn_ref->context->RunFunctionInTransaction([&]() { conn_ref->SetAutoCommit(auto_commit); });
84: }
85: 
86: JNIEXPORT jboolean JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1get_1auto_1commit(JNIEnv *env, jclass,
87:                                                                                         jobject conn_ref_buf) {
88: 	auto conn_ref = (Connection *)env->GetDirectBufferAddress(conn_ref_buf);
89: 	if (!conn_ref) {
90: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid connection");
91: 	}
92: 	return conn_ref->IsAutoCommit();
93: }
94: 
95: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1disconnect(JNIEnv *env, jclass,
96:                                                                              jobject conn_ref_buf) {
97: 	auto conn_ref = (Connection *)env->GetDirectBufferAddress(conn_ref_buf);
98: 	if (conn_ref) {
99: 		delete conn_ref;
100: 	}
101: }
102: 
103: struct StatementHolder {
104: 	unique_ptr<PreparedStatement> stmt;
105: };
106: 
107: #include "utf8proc_wrapper.hpp"
108: 
109: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1prepare(JNIEnv *env, jclass, jobject conn_ref_buf,
110:                                                                              jbyteArray query_j) {
111: 	auto conn_ref = (Connection *)env->GetDirectBufferAddress(conn_ref_buf);
112: 	if (!conn_ref) {
113: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid connection");
114: 	}
115: 
116: 	auto query = byte_array_to_string(env, query_j);
117: 
118: 	auto stmt_ref = new StatementHolder();
119: 	stmt_ref->stmt = conn_ref->Prepare(query);
120: 	if (!stmt_ref->stmt->success) {
121: 		string error_msg = string(stmt_ref->stmt->error);
122: 		stmt_ref->stmt = nullptr;
123: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), error_msg.c_str());
124: 	}
125: 	return env->NewDirectByteBuffer(stmt_ref, 0);
126: }
127: 
128: struct ResultHolder {
129: 	unique_ptr<QueryResult> res;
130: 	unique_ptr<DataChunk> chunk;
131: };
132: 
133: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1execute(JNIEnv *env, jclass, jobject stmt_ref_buf,
134:                                                                              jobjectArray params) {
135: 	auto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);
136: 	if (!stmt_ref) {
137: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid statement");
138: 	}
139: 	auto res_ref = new ResultHolder();
140: 	vector<Value> duckdb_params;
141: 
142: 	idx_t param_len = env->GetArrayLength(params);
143: 	if (param_len != stmt_ref->stmt->n_param) {
144: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Parameter count mismatch");
145: 	}
146: 
147: 	if (param_len > 0) {
148: 		auto bool_class = env->FindClass("java/lang/Boolean");
149: 		auto byte_class = env->FindClass("java/lang/Byte");
150: 		auto short_class = env->FindClass("java/lang/Short");
151: 		auto integer_class = env->FindClass("java/lang/Integer");
152: 		auto long_class = env->FindClass("java/lang/Long");
153: 		auto float_class = env->FindClass("java/lang/Float");
154: 		auto double_class = env->FindClass("java/lang/Double");
155: 		auto string_class = env->FindClass("java/lang/String");
156: 
157: 		for (idx_t i = 0; i < param_len; i++) {
158: 			auto param = env->GetObjectArrayElement(params, i);
159: 			if (param == nullptr) {
160: 				duckdb_params.push_back(Value());
161: 				continue;
162: 			} else if (env->IsInstanceOf(param, bool_class)) {
163: 				duckdb_params.push_back(
164: 				    Value::BOOLEAN(env->CallBooleanMethod(param, env->GetMethodID(bool_class, "booleanValue", "()Z"))));
165: 				continue;
166: 			} else if (env->IsInstanceOf(param, byte_class)) {
167: 				duckdb_params.push_back(
168: 				    Value::TINYINT(env->CallByteMethod(param, env->GetMethodID(byte_class, "byteValue", "()B"))));
169: 				continue;
170: 			} else if (env->IsInstanceOf(param, short_class)) {
171: 				duckdb_params.push_back(
172: 				    Value::SMALLINT(env->CallShortMethod(param, env->GetMethodID(short_class, "shortValue", "()S"))));
173: 				continue;
174: 			} else if (env->IsInstanceOf(param, integer_class)) {
175: 				duckdb_params.push_back(
176: 				    Value::INTEGER(env->CallIntMethod(param, env->GetMethodID(integer_class, "intValue", "()I"))));
177: 				continue;
178: 			} else if (env->IsInstanceOf(param, long_class)) {
179: 				duckdb_params.push_back(
180: 				    Value::BIGINT(env->CallLongMethod(param, env->GetMethodID(long_class, "longValue", "()J"))));
181: 				continue;
182: 			} else if (env->IsInstanceOf(param, float_class)) {
183: 				duckdb_params.push_back(
184: 				    Value::FLOAT(env->CallFloatMethod(param, env->GetMethodID(float_class, "floatValue", "()F"))));
185: 				continue;
186: 			} else if (env->IsInstanceOf(param, double_class)) {
187: 				duckdb_params.push_back(
188: 				    Value::DOUBLE(env->CallDoubleMethod(param, env->GetMethodID(double_class, "doubleValue", "()D"))));
189: 				continue;
190: 			} else if (env->IsInstanceOf(param, string_class)) {
191: 				auto *param_string = env->GetStringUTFChars((jstring)param, 0);
192: 				duckdb_params.push_back(Value(param_string));
193: 				env->ReleaseStringUTFChars((jstring)param, param_string);
194: 				continue;
195: 			} else {
196: 				env->ThrowNew(env->FindClass("java/sql/SQLException"), "Unsupported parameter type");
197: 			}
198: 		}
199: 	}
200: 
201: 	res_ref->res = stmt_ref->stmt->Execute(duckdb_params, false);
202: 	if (!res_ref->res->success) {
203: 		string error_msg = string(res_ref->res->error);
204: 		res_ref->res = nullptr;
205: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), error_msg.c_str());
206: 	}
207: 	return env->NewDirectByteBuffer(res_ref, 0);
208: }
209: 
210: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1release(JNIEnv *env, jclass, jobject stmt_ref_buf) {
211: 	auto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);
212: 	if (stmt_ref) {
213: 		delete stmt_ref;
214: 	}
215: }
216: 
217: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1free_1result(JNIEnv *env, jclass,
218:                                                                                jobject res_ref_buf) {
219: 	auto res_ref = (ResultHolder *)env->GetDirectBufferAddress(res_ref_buf);
220: 	if (res_ref) {
221: 		delete res_ref;
222: 	}
223: }
224: 
225: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1meta(JNIEnv *env, jclass, jobject stmt_ref_buf) {
226: 
227: 	auto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);
228: 	if (!stmt_ref || !stmt_ref->stmt || !stmt_ref->stmt->success) {
229: 		jclass Exception = env->FindClass("java/sql/SQLException");
230: 		env->ThrowNew(Exception, "Invalid statement");
231: 	}
232: 
233: 	jclass meta = env->FindClass("org/duckdb/DuckDBResultSetMetaData");
234: 	jmethodID meta_construct = env->GetMethodID(meta, "<init>", "(II[Ljava/lang/String;[Ljava/lang/String;)V");
235: 
236: 	auto column_count = stmt_ref->stmt->ColumnCount();
237: 	auto &names = stmt_ref->stmt->GetNames();
238: 	auto &types = stmt_ref->stmt->GetTypes();
239: 
240: 	auto name_array = env->NewObjectArray(column_count, env->FindClass("java/lang/String"), nullptr);
241: 	auto type_array = env->NewObjectArray(column_count, env->FindClass("java/lang/String"), nullptr);
242: 
243: 	for (idx_t col_idx = 0; col_idx < column_count; col_idx++) {
244: 		env->SetObjectArrayElement(name_array, col_idx,
245: 		                           decode_charbuffer_to_jstring(env, names[col_idx].c_str(), names[col_idx].length()));
246: 		env->SetObjectArrayElement(type_array, col_idx, env->NewStringUTF(types[col_idx].ToString().c_str()));
247: 	}
248: 
249: 	return env->NewObject(meta, meta_construct, stmt_ref->stmt->n_param, column_count, name_array, type_array);
250: }
251: 
252: JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(JNIEnv *env, jclass,
253:                                                                                 jobject res_ref_buf) {
254: 	auto res_ref = (ResultHolder *)env->GetDirectBufferAddress(res_ref_buf);
255: 	if (!res_ref || !res_ref->res || !res_ref->res->success) {
256: 		jclass Exception = env->FindClass("java/sql/SQLException");
257: 		env->ThrowNew(Exception, "Invalid result set");
258: 	}
259: 
260: 	res_ref->chunk = res_ref->res->Fetch();
261: 	if (!res_ref->chunk) {
262: 		res_ref->chunk = make_unique<DataChunk>();
263: 	}
264: 	auto row_count = res_ref->chunk->size();
265: 
266: 	auto vec_array = (jobjectArray)env->NewObjectArray(res_ref->chunk->ColumnCount(),
267: 	                                                   env->FindClass("org/duckdb/DuckDBVector"), nullptr);
268: 	for (idx_t col_idx = 0; col_idx < res_ref->chunk->ColumnCount(); col_idx++) {
269: 		auto &vec = res_ref->chunk->data[col_idx];
270: 		auto type_str = env->NewStringUTF(vec.GetType().ToString().c_str());
271: 		// construct nullmask
272: 		auto null_array = env->NewBooleanArray(row_count);
273: 		jboolean *null_array_ptr = env->GetBooleanArrayElements(null_array, nullptr);
274: 		for (idx_t row_idx = 0; row_idx < row_count; row_idx++) {
275: 			null_array_ptr[row_idx] = FlatVector::IsNull(vec, row_idx);
276: 		}
277: 		env->ReleaseBooleanArrayElements(null_array, null_array_ptr, 0);
278: 
279: 		jclass vec_class = env->FindClass("org/duckdb/DuckDBVector");
280: 		jmethodID vec_construct = env->GetMethodID(vec_class, "<init>", "(Ljava/lang/String;I[Z)V");
281: 		auto jvec = env->NewObject(vec_class, vec_construct, type_str, (int)row_count, null_array);
282: 
283: 		jobject constlen_data = nullptr;
284: 		jobjectArray varlen_data = nullptr;
285: 
286: 		switch (vec.GetType().id()) {
287: 		case LogicalTypeId::BOOLEAN:
288: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(bool));
289: 			break;
290: 		case LogicalTypeId::TINYINT:
291: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(int8_t));
292: 			break;
293: 		case LogicalTypeId::SMALLINT:
294: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(int16_t));
295: 			break;
296: 		case LogicalTypeId::INTEGER:
297: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(int32_t));
298: 			break;
299: 		case LogicalTypeId::BIGINT:
300: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(int64_t));
301: 			break;
302: 		case LogicalTypeId::UTINYINT:
303: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(uint8_t));
304: 			break;
305: 		case LogicalTypeId::USMALLINT:
306: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(uint16_t));
307: 			break;
308: 		case LogicalTypeId::UINTEGER:
309: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(uint32_t));
310: 			break;
311: 		case LogicalTypeId::UBIGINT:
312: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(uint64_t));
313: 			break;
314: 		case LogicalTypeId::HUGEINT:
315: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(hugeint_t));
316: 			break;
317: 		case LogicalTypeId::FLOAT:
318: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(float));
319: 			break;
320: 		case LogicalTypeId::DECIMAL: {
321: 			Vector double_vec(LogicalType::DOUBLE);
322: 			VectorOperations::Cast(vec, double_vec, row_count);
323: 			vec.Reference(double_vec);
324: 			// fall through on purpose
325: 		}
326: 		case LogicalTypeId::DOUBLE:
327: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(double));
328: 			break;
329: 		case LogicalTypeId::TIME:
330: 		case LogicalTypeId::DATE:
331: 		case LogicalTypeId::TIMESTAMP:
332: 		case LogicalTypeId::INTERVAL: {
333: 			Vector string_vec(LogicalType::VARCHAR);
334: 			VectorOperations::Cast(vec, string_vec, row_count);
335: 			vec.Reference(string_vec);
336: 			// fall through on purpose
337: 		}
338: 		case LogicalTypeId::VARCHAR:
339: 			varlen_data = env->NewObjectArray(row_count, env->FindClass("java/lang/String"), nullptr);
340: 			for (idx_t row_idx = 0; row_idx < row_count; row_idx++) {
341: 				if (FlatVector::IsNull(vec, row_idx)) {
342: 					continue;
343: 				}
344: 				auto d_str = ((string_t *)FlatVector::GetData(vec))[row_idx];
345: 				auto j_str = decode_charbuffer_to_jstring(env, d_str.GetDataUnsafe(), d_str.GetSize());
346: 				env->SetObjectArrayElement(varlen_data, row_idx, j_str);
347: 			}
348: 			break;
349: 		default:
350: 			jclass Exception = env->FindClass("java/sql/SQLException");
351: 			env->ThrowNew(Exception, ("Unsupported result column type " + vec.GetType().ToString()).c_str());
352: 		}
353: 
354: 		jfieldID constlen_data_field = env->GetFieldID(vec_class, "constlen_data", "Ljava/nio/ByteBuffer;");
355: 		jfieldID varlen_data_field = env->GetFieldID(vec_class, "varlen_data", "[Ljava/lang/Object;");
356: 
357: 		env->SetObjectField(jvec, constlen_data_field, constlen_data);
358: 		env->SetObjectField(jvec, varlen_data_field, varlen_data);
359: 
360: 		env->SetObjectArrayElement(vec_array, col_idx, jvec);
361: 	}
362: 
363: 	return vec_array;
364: }
365: 
366: JNIEXPORT jint JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch_1size(JNIEnv *, jclass) {
367: 	return STANDARD_VECTOR_SIZE;
368: }
369: 
370: JNIEXPORT jstring JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1prepare_1type(JNIEnv *env, jclass,
371:                                                                                    jobject stmt_ref_buf) {
372: 
373: 	auto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);
374: 	if (!stmt_ref || !stmt_ref->stmt || !stmt_ref->stmt->success) {
375: 		jclass Exception = env->FindClass("java/sql/SQLException");
376: 		env->ThrowNew(Exception, "Invalid statement");
377: 	}
378: 	return env->NewStringUTF(StatementTypeToString(stmt_ref->stmt->GetStatementType()).c_str());
379: }
380: 
381: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1create_1appender(JNIEnv *env, jclass,
382:                                                                                       jobject conn_ref_buf,
383:                                                                                       jbyteArray schema_name_j,
384:                                                                                       jbyteArray table_name_j) {
385: 
386: 	auto conn_ref = (Connection *)env->GetDirectBufferAddress(conn_ref_buf);
387: 	if (!conn_ref || !conn_ref->context) {
388: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid connection");
389: 	}
390: 	auto schema_name = byte_array_to_string(env, schema_name_j);
391: 	auto table_name = byte_array_to_string(env, table_name_j);
392: 	try {
393: 		auto appender = new Appender(*conn_ref, schema_name, table_name);
394: 		return env->NewDirectByteBuffer(appender, 0);
395: 	} catch (exception &e) {
396: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
397: 	}
398: 	return nullptr;
399: }
400: 
401: static Appender *get_appender(JNIEnv *env, jobject appender_ref_buf) {
402: 	auto appender_ref = (Appender *)env->GetDirectBufferAddress(appender_ref_buf);
403: 	if (!appender_ref) {
404: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid appender");
405: 	}
406: 	return appender_ref;
407: }
408: 
409: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1begin_1row(JNIEnv *env, jclass,
410:                                                                                        jobject appender_ref_buf) {
411: 	try {
412: 		get_appender(env, appender_ref_buf)->BeginRow();
413: 	} catch (exception &e) {
414: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
415: 	}
416: }
417: 
418: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1end_1row(JNIEnv *env, jclass,
419:                                                                                      jobject appender_ref_buf) {
420: 	try {
421: 		get_appender(env, appender_ref_buf)->EndRow();
422: 	} catch (exception &e) {
423: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
424: 	}
425: }
426: 
427: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1flush(JNIEnv *env, jclass,
428:                                                                                   jobject appender_ref_buf) {
429: 	try {
430: 		get_appender(env, appender_ref_buf)->Flush();
431: 	} catch (exception &e) {
432: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
433: 	}
434: }
435: 
436: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1close(JNIEnv *env, jclass,
437:                                                                                   jobject appender_ref_buf) {
438: 	try {
439: 		auto appender = get_appender(env, appender_ref_buf);
440: 		appender->Close();
441: 		delete appender;
442: 	} catch (exception &e) {
443: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
444: 	}
445: }
446: 
447: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1boolean(JNIEnv *env, jclass,
448:                                                                                             jobject appender_ref_buf,
449:                                                                                             jboolean value) {
450: 	try {
451: 		get_appender(env, appender_ref_buf)->Append((bool)value);
452: 	} catch (exception &e) {
453: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
454: 	}
455: }
456: 
457: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1byte(JNIEnv *env, jclass,
458:                                                                                          jobject appender_ref_buf,
459:                                                                                          jbyte value) {
460: 	try {
461: 		get_appender(env, appender_ref_buf)->Append((int8_t)value);
462: 	} catch (exception &e) {
463: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
464: 	}
465: }
466: 
467: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1short(JNIEnv *env, jclass,
468:                                                                                           jobject appender_ref_buf,
469:                                                                                           jshort value) {
470: 	try {
471: 		get_appender(env, appender_ref_buf)->Append((int16_t)value);
472: 	} catch (exception &e) {
473: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
474: 	}
475: }
476: 
477: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1int(JNIEnv *env, jclass,
478:                                                                                         jobject appender_ref_buf,
479:                                                                                         jint value) {
480: 	try {
481: 		get_appender(env, appender_ref_buf)->Append((int32_t)value);
482: 	} catch (exception &e) {
483: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
484: 	}
485: }
486: 
487: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1long(JNIEnv *env, jclass,
488:                                                                                          jobject appender_ref_buf,
489:                                                                                          jlong value) {
490: 	try {
491: 		get_appender(env, appender_ref_buf)->Append((int64_t)value);
492: 	} catch (exception &e) {
493: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
494: 	}
495: }
496: 
497: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1float(JNIEnv *env, jclass,
498:                                                                                           jobject appender_ref_buf,
499:                                                                                           jfloat value) {
500: 	try {
501: 		get_appender(env, appender_ref_buf)->Append((float)value);
502: 	} catch (exception &e) {
503: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
504: 	}
505: }
506: 
507: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1double(JNIEnv *env, jclass,
508:                                                                                            jobject appender_ref_buf,
509:                                                                                            jdouble value) {
510: 	try {
511: 		get_appender(env, appender_ref_buf)->Append((double)value);
512: 	} catch (exception &e) {
513: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
514: 	}
515: }
516: 
517: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1string(JNIEnv *env, jclass,
518:                                                                                            jobject appender_ref_buf,
519:                                                                                            jbyteArray value) {
520: 	try {
521: 		auto string_value = byte_array_to_string(env, value);
522: 		get_appender(env, appender_ref_buf)->Append(string_value.c_str());
523: 	} catch (exception &e) {
524: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
525: 	}
526: }
[end of tools/jdbc/src/jni/duckdb_java.cpp]
[start of tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java]
1: package org.duckdb;
2: 
3: import java.sql.Connection;
4: import java.sql.DatabaseMetaData;
5: import java.sql.PreparedStatement;
6: import java.sql.ResultSet;
7: import java.sql.RowIdLifetime;
8: import java.sql.SQLException;
9: import java.sql.SQLFeatureNotSupportedException;
10: import java.sql.Statement;
11: 
12: public class DuckDBDatabaseMetaData implements DatabaseMetaData {
13: 	DuckDBConnection conn;
14: 
15: 	public DuckDBDatabaseMetaData(DuckDBConnection conn) {
16: 		this.conn = conn;
17: 	}
18: 
19: 	@Override
20: 	public <T> T unwrap(Class<T> iface) throws SQLException {
21: 		throw new SQLFeatureNotSupportedException();
22: 	}
23: 
24: 	@Override
25: 	public boolean isWrapperFor(Class<?> iface) throws SQLException {
26: 		throw new SQLFeatureNotSupportedException();
27: 	}
28: 
29: 	@Override
30: 	public boolean allProceduresAreCallable() throws SQLException {
31: 		return false;
32: 	}
33: 
34: 	@Override
35: 	public boolean allTablesAreSelectable() throws SQLException {
36: 		return true;
37: 	}
38: 
39: 	@Override
40: 	public String getURL() throws SQLException {
41: 		return conn.db.url;
42: 	}
43: 
44: 	@Override
45: 	public String getUserName() throws SQLException {
46: 		return "";
47: 	}
48: 
49: 	@Override
50: 	public boolean isReadOnly() throws SQLException {
51: 		return false;
52: 	}
53: 
54: 	@Override
55: 	public boolean nullsAreSortedHigh() throws SQLException {
56: 		return true;
57: 	}
58: 
59: 	@Override
60: 	public boolean nullsAreSortedLow() throws SQLException {
61: 		return false;
62: 	}
63: 
64: 	@Override
65: 	public boolean nullsAreSortedAtStart() throws SQLException {
66: 		return true;
67: 	}
68: 
69: 	@Override
70: 	public boolean nullsAreSortedAtEnd() throws SQLException {
71: 		return false;
72: 	}
73: 
74: 	@Override
75: 	public String getDatabaseProductName() throws SQLException {
76: 		return "DuckDB";
77: 	}
78: 
79: 	@Override
80: 	public String getDatabaseProductVersion() throws SQLException {
81: 		Statement s = conn.createStatement();
82: 		ResultSet rs = s.executeQuery("PRAGMA version");
83: 		rs.next();
84: 		String result = rs.getString(1);
85: 		rs.close();
86: 		s.close();
87: 		return result;
88: 	}
89: 
90: 	@Override
91: 	public String getDriverName() throws SQLException {
92: 		return "DuckDBJ";
93: 	}
94: 
95: 	@Override
96: 	public String getDriverVersion() throws SQLException {
97: 		return "1.0";
98: 	}
99: 
100: 	@Override
101: 	public int getDriverMajorVersion() {
102: 		return 1;
103: 	}
104: 
105: 	@Override
106: 	public int getDriverMinorVersion() {
107: 		return 0;
108: 	}
109: 
110: 	@Override
111: 	public boolean usesLocalFiles() throws SQLException {
112: 		return true;
113: 	}
114: 
115: 	@Override
116: 	public boolean usesLocalFilePerTable() throws SQLException {
117: 		return false;
118: 	}
119: 
120: 	@Override
121: 	public boolean supportsMixedCaseIdentifiers() throws SQLException {
122: 		return true;
123: 	}
124: 
125: 	@Override
126: 	public boolean storesUpperCaseIdentifiers() throws SQLException {
127: 		return false;
128: 	}
129: 
130: 	@Override
131: 	public boolean storesLowerCaseIdentifiers() throws SQLException {
132: 		return false;
133: 	}
134: 
135: 	@Override
136: 	public boolean storesMixedCaseIdentifiers() throws SQLException {
137: 		return true;
138: 	}
139: 
140: 	@Override
141: 	public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {
142: 		return true;
143: 	}
144: 
145: 	@Override
146: 	public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {
147: 		return false;
148: 	}
149: 
150: 	@Override
151: 	public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {
152: 		return false;
153: 	}
154: 
155: 	@Override
156: 	public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {
157: 		return true;
158: 	}
159: 
160: 	@Override
161: 	public String getIdentifierQuoteString() throws SQLException {
162: 		return "\"";
163: 	}
164: 
165: 	@Override
166: 	public String getSQLKeywords() throws SQLException {
167: 		throw new SQLFeatureNotSupportedException();
168: 	}
169: 
170: 	@Override
171: 	public String getNumericFunctions() throws SQLException {
172: 		throw new SQLFeatureNotSupportedException();
173: 	}
174: 
175: 	@Override
176: 	public String getStringFunctions() throws SQLException {
177: 		throw new SQLFeatureNotSupportedException();
178: 	}
179: 
180: 	@Override
181: 	public String getSystemFunctions() throws SQLException {
182: 		throw new SQLFeatureNotSupportedException();
183: 	}
184: 
185: 	@Override
186: 	public String getTimeDateFunctions() throws SQLException {
187: 		throw new SQLFeatureNotSupportedException();
188: 	}
189: 
190: 	@Override
191: 	public String getSearchStringEscape() throws SQLException {
192: 		return null;
193: 	}
194: 
195: 	@Override
196: 	public String getExtraNameCharacters() throws SQLException {
197: 		return "";
198: 	}
199: 
200: 	@Override
201: 	public boolean supportsAlterTableWithAddColumn() throws SQLException {
202: 		return true;
203: 	}
204: 
205: 	@Override
206: 	public boolean supportsAlterTableWithDropColumn() throws SQLException {
207: 		return true;
208: 	}
209: 
210: 	@Override
211: 	public boolean supportsColumnAliasing() throws SQLException {
212: 		return true;
213: 	}
214: 
215: 	@Override
216: 	public boolean nullPlusNonNullIsNull() throws SQLException {
217: 		return true;
218: 	}
219: 
220: 	@Override
221: 	public boolean supportsConvert() throws SQLException {
222: 		return false;
223: 	}
224: 
225: 	@Override
226: 	public boolean supportsConvert(int fromType, int toType) throws SQLException {
227: 		throw new SQLFeatureNotSupportedException();
228: 	}
229: 
230: 	@Override
231: 	public boolean supportsTableCorrelationNames() throws SQLException {
232: 		throw new SQLFeatureNotSupportedException();
233: 	}
234: 
235: 	@Override
236: 	public boolean supportsDifferentTableCorrelationNames() throws SQLException {
237: 		throw new SQLFeatureNotSupportedException();
238: 	}
239: 
240: 	@Override
241: 	public boolean supportsExpressionsInOrderBy() throws SQLException {
242: 		return true;
243: 	}
244: 
245: 	@Override
246: 	public boolean supportsOrderByUnrelated() throws SQLException {
247: 		return true;
248: 	}
249: 
250: 	@Override
251: 	public boolean supportsGroupBy() throws SQLException {
252: 		return true;
253: 	}
254: 
255: 	@Override
256: 	public boolean supportsGroupByUnrelated() throws SQLException {
257: 		return true;
258: 	}
259: 
260: 	@Override
261: 	public boolean supportsGroupByBeyondSelect() throws SQLException {
262: 		return true;
263: 	}
264: 
265: 	@Override
266: 	public boolean supportsLikeEscapeClause() throws SQLException {
267: 		return false;
268: 	}
269: 
270: 	@Override
271: 	public boolean supportsMultipleResultSets() throws SQLException {
272: 		return false;
273: 	}
274: 
275: 	@Override
276: 	public boolean supportsMultipleTransactions() throws SQLException {
277: 		return true;
278: 	}
279: 
280: 	@Override
281: 	public boolean supportsNonNullableColumns() throws SQLException {
282: 		return true;
283: 	}
284: 
285: 	@Override
286: 	public boolean supportsMinimumSQLGrammar() throws SQLException {
287: 		return true;
288: 	}
289: 
290: 	@Override
291: 	public boolean supportsCoreSQLGrammar() throws SQLException {
292: 		return true;
293: 	}
294: 
295: 	@Override
296: 	public boolean supportsExtendedSQLGrammar() throws SQLException {
297: 		return true;
298: 	}
299: 
300: 	@Override
301: 	public boolean supportsANSI92EntryLevelSQL() throws SQLException {
302: 		return true;
303: 	}
304: 
305: 	@Override
306: 	public boolean supportsANSI92IntermediateSQL() throws SQLException {
307: 		return true;
308: 	}
309: 
310: 	@Override
311: 	public boolean supportsANSI92FullSQL() throws SQLException {
312: 		return true;
313: 	}
314: 
315: 	@Override
316: 	public boolean supportsIntegrityEnhancementFacility() throws SQLException {
317: 		return false;
318: 	}
319: 
320: 	@Override
321: 	public boolean supportsOuterJoins() throws SQLException {
322: 		return true;
323: 	}
324: 
325: 	@Override
326: 	public boolean supportsFullOuterJoins() throws SQLException {
327: 		return true;
328: 	}
329: 
330: 	@Override
331: 	public boolean supportsLimitedOuterJoins() throws SQLException {
332: 		return true;
333: 	}
334: 
335: 	@Override
336: 	public String getSchemaTerm() throws SQLException {
337: 		return "schema";
338: 	}
339: 
340: 	@Override
341: 	public String getProcedureTerm() throws SQLException {
342: 		return "procedure";
343: 	}
344: 
345: 	@Override
346: 	public String getCatalogTerm() throws SQLException {
347: 		return "catalog";
348: 	}
349: 
350: 	@Override
351: 	public boolean isCatalogAtStart() throws SQLException {
352: 		return true;
353: 	}
354: 
355: 	@Override
356: 	public String getCatalogSeparator() throws SQLException {
357: 		return ".";
358: 	}
359: 
360: 	@Override
361: 	public boolean supportsSchemasInDataManipulation() throws SQLException {
362: 		return true;
363: 	}
364: 
365: 	@Override
366: 	public boolean supportsSchemasInProcedureCalls() throws SQLException {
367: 		return true;
368: 	}
369: 
370: 	@Override
371: 	public boolean supportsSchemasInTableDefinitions() throws SQLException {
372: 		return true;
373: 	}
374: 
375: 	@Override
376: 	public boolean supportsSchemasInIndexDefinitions() throws SQLException {
377: 		return true;
378: 	}
379: 
380: 	@Override
381: 	public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {
382: 		throw new SQLFeatureNotSupportedException();
383: 	}
384: 
385: 	@Override
386: 	public boolean supportsCatalogsInDataManipulation() throws SQLException {
387: 		return false;
388: 	}
389: 
390: 	@Override
391: 	public boolean supportsCatalogsInProcedureCalls() throws SQLException {
392: 		return false;
393: 	}
394: 
395: 	@Override
396: 	public boolean supportsCatalogsInTableDefinitions() throws SQLException {
397: 		return false;
398: 	}
399: 
400: 	@Override
401: 	public boolean supportsCatalogsInIndexDefinitions() throws SQLException {
402: 		return false;
403: 	}
404: 
405: 	@Override
406: 	public boolean supportsCatalogsInPrivilegeDefinitions() throws SQLException {
407: 		return false;
408: 	}
409: 
410: 	@Override
411: 	public boolean supportsPositionedDelete() throws SQLException {
412: 		return false;
413: 	}
414: 
415: 	@Override
416: 	public boolean supportsPositionedUpdate() throws SQLException {
417: 		return false;
418: 	}
419: 
420: 	@Override
421: 	public boolean supportsSelectForUpdate() throws SQLException {
422: 		return false;
423: 	}
424: 
425: 	@Override
426: 	public boolean supportsStoredProcedures() throws SQLException {
427: 		return false;
428: 	}
429: 
430: 	@Override
431: 	public boolean supportsSubqueriesInComparisons() throws SQLException {
432: 		return true;
433: 	}
434: 
435: 	@Override
436: 	public boolean supportsSubqueriesInExists() throws SQLException {
437: 		return true;
438: 	}
439: 
440: 	@Override
441: 	public boolean supportsSubqueriesInIns() throws SQLException {
442: 		return true;
443: 	}
444: 
445: 	@Override
446: 	public boolean supportsSubqueriesInQuantifieds() throws SQLException {
447: 		return true;
448: 	}
449: 
450: 	@Override
451: 	public boolean supportsCorrelatedSubqueries() throws SQLException {
452: 		return true;
453: 	}
454: 
455: 	@Override
456: 	public boolean supportsUnion() throws SQLException {
457: 		return true;
458: 	}
459: 
460: 	@Override
461: 	public boolean supportsUnionAll() throws SQLException {
462: 		return true;
463: 	}
464: 
465: 	@Override
466: 	public boolean supportsOpenCursorsAcrossCommit() throws SQLException {
467: 		return false;
468: 	}
469: 
470: 	@Override
471: 	public boolean supportsOpenCursorsAcrossRollback() throws SQLException {
472: 		return false;
473: 	}
474: 
475: 	@Override
476: 	public boolean supportsOpenStatementsAcrossCommit() throws SQLException {
477: 		return false;
478: 	}
479: 
480: 	@Override
481: 	public boolean supportsOpenStatementsAcrossRollback() throws SQLException {
482: 		return false;
483: 	}
484: 
485: 	@Override
486: 	public int getMaxBinaryLiteralLength() throws SQLException {
487: 
488: 		return 0;
489: 	}
490: 
491: 	@Override
492: 	public int getMaxCharLiteralLength() throws SQLException {
493: 		return 0;
494: 	}
495: 
496: 	@Override
497: 	public int getMaxColumnNameLength() throws SQLException {
498: 		return 0;
499: 	}
500: 
501: 	@Override
502: 	public int getMaxColumnsInGroupBy() throws SQLException {
503: 		return 0;
504: 	}
505: 
506: 	@Override
507: 	public int getMaxColumnsInIndex() throws SQLException {
508: 		return 0;
509: 	}
510: 
511: 	@Override
512: 	public int getMaxColumnsInOrderBy() throws SQLException {
513: 		return 0;
514: 	}
515: 
516: 	@Override
517: 	public int getMaxColumnsInSelect() throws SQLException {
518: 		return 0;
519: 	}
520: 
521: 	@Override
522: 	public int getMaxColumnsInTable() throws SQLException {
523: 		return 0;
524: 	}
525: 
526: 	@Override
527: 	public int getMaxConnections() throws SQLException {
528: 		return 0;
529: 	}
530: 
531: 	@Override
532: 	public int getMaxCursorNameLength() throws SQLException {
533: 		return 0;
534: 	}
535: 
536: 	@Override
537: 	public int getMaxIndexLength() throws SQLException {
538: 		return 0;
539: 	}
540: 
541: 	@Override
542: 	public int getMaxSchemaNameLength() throws SQLException {
543: 		return 0;
544: 	}
545: 
546: 	@Override
547: 	public int getMaxProcedureNameLength() throws SQLException {
548: 		return 0;
549: 	}
550: 
551: 	@Override
552: 	public int getMaxCatalogNameLength() throws SQLException {
553: 		return 0;
554: 	}
555: 
556: 	@Override
557: 	public int getMaxRowSize() throws SQLException {
558: 		return 0;
559: 	}
560: 
561: 	@Override
562: 	public boolean doesMaxRowSizeIncludeBlobs() throws SQLException {
563: 		return false;
564: 	}
565: 
566: 	@Override
567: 	public int getMaxStatementLength() throws SQLException {
568: 		return 0;
569: 	}
570: 
571: 	@Override
572: 	public int getMaxStatements() throws SQLException {
573: 		return 0;
574: 	}
575: 
576: 	@Override
577: 	public int getMaxTableNameLength() throws SQLException {
578: 		return 0;
579: 	}
580: 
581: 	@Override
582: 	public int getMaxTablesInSelect() throws SQLException {
583: 		return 0;
584: 	}
585: 
586: 	@Override
587: 	public int getMaxUserNameLength() throws SQLException {
588: 		return 0;
589: 	}
590: 
591: 	@Override
592: 	public int getDefaultTransactionIsolation() throws SQLException {
593: 		return Connection.TRANSACTION_REPEATABLE_READ;
594: 	}
595: 
596: 	@Override
597: 	public boolean supportsTransactions() throws SQLException {
598: 		return true;
599: 	}
600: 
601: 	@Override
602: 	public boolean supportsTransactionIsolationLevel(int level) throws SQLException {
603: 		return level < Connection.TRANSACTION_SERIALIZABLE;
604: 	}
605: 
606: 	@Override
607: 	public boolean supportsDataDefinitionAndDataManipulationTransactions() throws SQLException {
608: 		return true;
609: 	}
610: 
611: 	@Override
612: 	public boolean supportsDataManipulationTransactionsOnly() throws SQLException {
613: 		return false;
614: 	}
615: 
616: 	@Override
617: 	public boolean dataDefinitionCausesTransactionCommit() throws SQLException {
618: 		return false;
619: 	}
620: 
621: 	@Override
622: 	public boolean dataDefinitionIgnoredInTransactions() throws SQLException {
623: 		return false;
624: 	}
625: 
626: 	@Override
627: 	public ResultSet getCatalogs() throws SQLException {
628: 		return conn.createStatement().executeQuery(
629: 				"SELECT DISTINCT catalog_name AS 'TABLE_CAT' FROM information_schema.schemata ORDER BY \"TABLE_CAT\"");
630: 	}
631: 
632: 	@Override
633: 	public ResultSet getSchemas() throws SQLException {
634: 		return conn.createStatement().executeQuery(
635: 				"SELECT schema_name AS 'TABLE_SCHEM', catalog_name AS 'TABLE_CATALOG' FROM information_schema.schemata ORDER BY \"TABLE_CATALOG\", \"TABLE_SCHEM\"");
636: 	}
637: 
638: 	@Override
639: 	public ResultSet getSchemas(String catalog, String schemaPattern) throws SQLException {
640: 		if (catalog != null && !catalog.isEmpty()) {
641: 			throw new SQLException("catalog argument is not supported");
642: 		}
643: 		PreparedStatement ps = conn.prepareStatement(
644: 				"SELECT schema_name AS 'TABLE_SCHEM', catalog_name AS 'TABLE_CATALOG' FROM information_schema.schemata WHERE schema_name LIKE ? ORDER BY \"TABLE_CATALOG\", \"TABLE_SCHEM\"");
645: 		ps.setString(1, schemaPattern);
646: 		return ps.executeQuery();
647: 	}
648: 
649: 	@Override
650: 	public ResultSet getTableTypes() throws SQLException {
651: 		return conn.createStatement().executeQuery(
652: 				"SELECT DISTINCT table_type AS 'TABLE_TYPE' FROM information_schema.tables ORDER BY \"TABLE_TYPE\"");
653: 	}
654: 
655: 	@Override
656: 	public ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types)
657: 			throws SQLException {
658: 		if (catalog != null && !catalog.isEmpty()) {
659: 			throw new SQLException("Actual catalog argument is not supported, got " + catalog);
660: 		}
661: 		String table_type_str = "";
662: 		if (types != null && types.length > 0) {
663: 			table_type_str = "table_type IN (";
664: 			for (int i = 0; i < types.length; i++) {
665: 				table_type_str += "'" + types[i] + "'";
666: 				if (i < types.length - 1) {
667: 					table_type_str += ',';
668: 				}
669: 			}
670: 			table_type_str +=  ") AND ";
671: 		}
672: 		if (schemaPattern == null) {
673: 			schemaPattern = "%";
674: 		}
675: 		if (tableNamePattern == null) {
676: 			tableNamePattern = "%";
677: 		}
678: 		PreparedStatement ps = conn.prepareStatement(
679: 				"SELECT table_catalog AS 'TABLE_CAT', table_schema AS 'TABLE_SCHEM', table_name AS 'TABLE_NAME', table_type as 'TABLE_TYPE', NULL AS 'REMARKS', NULL AS 'TYPE_CAT', NULL AS 'TYPE_SCHEM', NULL AS 'TYPE_NAME', NULL as 'SELF_REFERENCING_COL_NAME', NULL as 'REF_GENERATION' FROM information_schema.tables WHERE "+ table_type_str +" table_schema LIKE ? AND table_name LIKE ? ORDER BY \"TABLE_TYPE\", \"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\"");
680: 		ps.setString(1, schemaPattern);
681: 		ps.setString(2, tableNamePattern);
682: 		return ps.executeQuery();
683: 
684: 	}
685: 
686: 	@Override
687: 	public ResultSet getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)
688: 			throws SQLException {
689: 		if (catalog != null && !catalog.isEmpty()) {
690: 			throw new SQLException("catalog argument is not supported");
691: 		}
692: 		if (schemaPattern == null) {
693: 			schemaPattern = "%";
694: 		}
695: 		if (tableNamePattern == null) {
696: 			tableNamePattern = "%";
697: 		}
698: 		if (columnNamePattern == null) {
699: 			columnNamePattern = "%";
700: 		}
701: 
702: 		// need to figure out the java types for the sql types :/
703: 		String values_str = "VALUES(NULL::STRING, NULL::INTEGER)";
704: 		Statement gunky_statement = conn.createStatement();
705: 		// TODO this could get slow with many many columns and we really only need the
706: 		// types :/
707: 		ResultSet rs = gunky_statement
708: 				.executeQuery("SELECT DISTINCT data_type FROM information_schema.columns ORDER BY data_type");
709: 		while (rs.next()) {
710: 			values_str += ", ('" + rs.getString(1) + "', "
711: 					+ Integer.toString(DuckDBResultSetMetaData.type_to_int(rs.getString(1))) + ")";
712: 		}
713: 		rs.close();
714: 		gunky_statement.close();
715: 
716: 		PreparedStatement ps = conn.prepareStatement(
717: 				"SELECT table_catalog AS 'TABLE_CAT', table_schema AS 'TABLE_SCHEM', table_name AS 'TABLE_NAME', column_name as 'COLUMN_NAME', type_id AS 'DATA_TYPE', c.data_type AS 'TYPE_NAME', NULL AS 'COLUMN_SIZE', NULL AS 'BUFFER_LENGTH', numeric_precision AS 'DECIMAL_DIGITS', 10 AS 'NUM_PREC_RADIX', CASE WHEN is_nullable = 'YES' THEN 1 else 0 END AS 'NULLABLE', NULL as 'REMARKS', column_default AS 'COLUMN_DEF', NULL AS 'SQL_DATA_TYPE', NULL AS 'SQL_DATETIME_SUB', character_octet_length AS 'CHAR_OCTET_LENGTH', ordinal_position AS 'ORDINAL_POSITION', is_nullable AS 'IS_NULLABLE', NULL AS 'SCOPE_CATALOG', NULL AS 'SCOPE_SCHEMA', NULL AS 'SCOPE_TABLE', NULL AS 'SOURCE_DATA_TYPE', '' AS 'IS_AUTOINCREMENT', '' AS 'IS_GENERATEDCOLUMN'  FROM information_schema.columns c JOIN ("
718: 						+ values_str
719: 						+ ") t(type_name, type_id) ON c.data_type = t.type_name WHERE table_schema LIKE ? AND table_name LIKE ? AND column_name LIKE ? ORDER BY \"TABLE_CAT\",\"TABLE_SCHEM\", \"TABLE_NAME\", \"ORDINAL_POSITION\"");
720: 		ps.setString(1, schemaPattern);
721: 		ps.setString(2, tableNamePattern);
722: 		ps.setString(3, columnNamePattern);
723: 		return ps.executeQuery();
724: 
725: 	}
726: 
727: 	@Override
728: 	public ResultSet getColumnPrivileges(String catalog, String schema, String table, String columnNamePattern)
729: 			throws SQLException {
730: 		throw new SQLFeatureNotSupportedException();
731: 	}
732: 
733: 	@Override
734: 	public ResultSet getTablePrivileges(String catalog, String schemaPattern, String tableNamePattern)
735: 			throws SQLException {
736: 		throw new SQLFeatureNotSupportedException();
737: 	}
738: 
739: 	@Override
740: 	public ResultSet getProcedures(String catalog, String schemaPattern, String procedureNamePattern)
741: 			throws SQLException {
742: 		return conn.createStatement().executeQuery("SELECT NULL WHERE FALSE");
743: 	}
744: 
745: 	@Override
746: 	public ResultSet getProcedureColumns(String catalog, String schemaPattern, String procedureNamePattern,
747: 			String columnNamePattern) throws SQLException {
748: 		return conn.createStatement().executeQuery("SELECT NULL WHERE FALSE");
749: 	}
750: 
751: 	@Override
752: 	public ResultSet getBestRowIdentifier(String catalog, String schema, String table, int scope, boolean nullable)
753: 			throws SQLException {
754: 		throw new SQLFeatureNotSupportedException();
755: 	}
756: 
757: 	@Override
758: 	public ResultSet getVersionColumns(String catalog, String schema, String table) throws SQLException {
759: 		throw new SQLFeatureNotSupportedException();
760: 	}
761: 
762: 	@Override
763: 	public ResultSet getPrimaryKeys(String catalog, String schema, String table) throws SQLException {
764: 		throw new SQLFeatureNotSupportedException();
765: 	}
766: 
767: 	@Override
768: 	public ResultSet getImportedKeys(String catalog, String schema, String table) throws SQLException {
769: 		throw new SQLFeatureNotSupportedException();
770: 	}
771: 
772: 	@Override
773: 	public ResultSet getExportedKeys(String catalog, String schema, String table) throws SQLException {
774: 		throw new SQLFeatureNotSupportedException();
775: 	}
776: 
777: 	@Override
778: 	public ResultSet getCrossReference(String parentCatalog, String parentSchema, String parentTable,
779: 			String foreignCatalog, String foreignSchema, String foreignTable) throws SQLException {
780: 		throw new SQLFeatureNotSupportedException();
781: 	}
782: 
783: 	@Override
784: 	public ResultSet getTypeInfo() throws SQLException {
785: 		throw new SQLFeatureNotSupportedException();
786: 	}
787: 
788: 	@Override
789: 	public ResultSet getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate)
790: 			throws SQLException {
791: 		throw new SQLFeatureNotSupportedException();
792: 	}
793: 
794: 	@Override
795: 	public boolean supportsResultSetType(int type) throws SQLException {
796: 		return type == ResultSet.TYPE_FORWARD_ONLY;
797: 	}
798: 
799: 	@Override
800: 	public boolean supportsResultSetConcurrency(int type, int concurrency) throws SQLException {
801: 		return type == ResultSet.TYPE_FORWARD_ONLY && concurrency == ResultSet.CONCUR_READ_ONLY;
802: 	}
803: 
804: 	@Override
805: 	public boolean ownUpdatesAreVisible(int type) throws SQLException {
806: 		throw new SQLFeatureNotSupportedException();
807: 	}
808: 
809: 	@Override
810: 	public boolean ownDeletesAreVisible(int type) throws SQLException {
811: 		throw new SQLFeatureNotSupportedException();
812: 	}
813: 
814: 	@Override
815: 	public boolean ownInsertsAreVisible(int type) throws SQLException {
816: 		throw new SQLFeatureNotSupportedException();
817: 	}
818: 
819: 	@Override
820: 	public boolean othersUpdatesAreVisible(int type) throws SQLException {
821: 		throw new SQLFeatureNotSupportedException();
822: 	}
823: 
824: 	@Override
825: 	public boolean othersDeletesAreVisible(int type) throws SQLException {
826: 		throw new SQLFeatureNotSupportedException();
827: 	}
828: 
829: 	@Override
830: 	public boolean othersInsertsAreVisible(int type) throws SQLException {
831: 		throw new SQLFeatureNotSupportedException();
832: 	}
833: 
834: 	@Override
835: 	public boolean updatesAreDetected(int type) throws SQLException {
836: 		throw new SQLFeatureNotSupportedException();
837: 	}
838: 
839: 	@Override
840: 	public boolean deletesAreDetected(int type) throws SQLException {
841: 		throw new SQLFeatureNotSupportedException();
842: 	}
843: 
844: 	@Override
845: 	public boolean insertsAreDetected(int type) throws SQLException {
846: 		throw new SQLFeatureNotSupportedException();
847: 	}
848: 
849: 	@Override
850: 	public boolean supportsBatchUpdates() throws SQLException {
851: 		throw new SQLFeatureNotSupportedException();
852: 	}
853: 
854: 	@Override
855: 	public ResultSet getUDTs(String catalog, String schemaPattern, String typeNamePattern, int[] types)
856: 			throws SQLException {
857: 		throw new SQLFeatureNotSupportedException();
858: 	}
859: 
860: 	@Override
861: 	public Connection getConnection() throws SQLException {
862: 		return conn;
863: 	}
864: 
865: 	@Override
866: 	public boolean supportsSavepoints() throws SQLException {
867: 		return false;
868: 	}
869: 
870: 	@Override
871: 	public boolean supportsNamedParameters() throws SQLException {
872: 		return false;
873: 	}
874: 
875: 	@Override
876: 	public boolean supportsMultipleOpenResults() throws SQLException {
877: 		return true;
878: 	}
879: 
880: 	@Override
881: 	public boolean supportsGetGeneratedKeys() throws SQLException {
882: 		return false;
883: 	}
884: 
885: 	@Override
886: 	public ResultSet getSuperTypes(String catalog, String schemaPattern, String typeNamePattern) throws SQLException {
887: 		throw new SQLFeatureNotSupportedException();
888: 	}
889: 
890: 	@Override
891: 	public ResultSet getSuperTables(String catalog, String schemaPattern, String tableNamePattern) throws SQLException {
892: 		throw new SQLFeatureNotSupportedException();
893: 	}
894: 
895: 	@Override
896: 	public ResultSet getAttributes(String catalog, String schemaPattern, String typeNamePattern,
897: 			String attributeNamePattern) throws SQLException {
898: 		throw new SQLFeatureNotSupportedException();
899: 	}
900: 
901: 	@Override
902: 	public boolean supportsResultSetHoldability(int holdability) throws SQLException {
903: 		throw new SQLFeatureNotSupportedException();
904: 	}
905: 
906: 	@Override
907: 	public int getResultSetHoldability() throws SQLException {
908: 		throw new SQLFeatureNotSupportedException();
909: 	}
910: 
911: 	@Override
912: 	public int getDatabaseMajorVersion() throws SQLException {
913: 		return 1;
914: 	}
915: 
916: 	@Override
917: 	public int getDatabaseMinorVersion() throws SQLException {
918: 		return 0;
919: 	}
920: 
921: 	@Override
922: 	public int getJDBCMajorVersion() throws SQLException {
923: 		return 1;
924: 	}
925: 
926: 	@Override
927: 	public int getJDBCMinorVersion() throws SQLException {
928: 		return 0;
929: 	}
930: 
931: 	@Override
932: 	public int getSQLStateType() throws SQLException {
933: 		throw new SQLFeatureNotSupportedException();
934: 	}
935: 
936: 	@Override
937: 	public boolean locatorsUpdateCopy() throws SQLException {
938: 		throw new SQLFeatureNotSupportedException();
939: 	}
940: 
941: 	@Override
942: 	public boolean supportsStatementPooling() throws SQLException {
943: 		throw new SQLFeatureNotSupportedException();
944: 	}
945: 
946: 	@Override
947: 	public RowIdLifetime getRowIdLifetime() throws SQLException {
948: 		throw new SQLFeatureNotSupportedException();
949: 	}
950: 
951: 	@Override
952: 	public boolean supportsStoredFunctionsUsingCallSyntax() throws SQLException {
953: 		throw new SQLFeatureNotSupportedException();
954: 	}
955: 
956: 	@Override
957: 	public boolean autoCommitFailureClosesAllResultSets() throws SQLException {
958: 		throw new SQLFeatureNotSupportedException();
959: 	}
960: 
961: 	@Override
962: 	public ResultSet getClientInfoProperties() throws SQLException {
963: 		throw new SQLFeatureNotSupportedException();
964: 	}
965: 
966: 	@Override
967: 	public ResultSet getFunctions(String catalog, String schemaPattern, String functionNamePattern)
968: 			throws SQLException {
969: 		return conn.createStatement().executeQuery("SELECT NULL WHERE FALSE");
970: 	}
971: 
972: 	@Override
973: 	public ResultSet getFunctionColumns(String catalog, String schemaPattern, String functionNamePattern,
974: 			String columnNamePattern) throws SQLException {
975: 		return conn.createStatement().executeQuery("SELECT NULL WHERE FALSE");
976: 	}
977: 
978: 	@Override
979: 	public ResultSet getPseudoColumns(String catalog, String schemaPattern, String tableNamePattern,
980: 			String columnNamePattern) throws SQLException {
981: 		throw new SQLFeatureNotSupportedException();
982: 	}
983: 
984: 	@Override
985: 	public boolean generatedKeyAlwaysReturned() throws SQLException {
986: 		throw new SQLFeatureNotSupportedException();
987: 	}
988: 
989: }
[end of tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java]
[start of tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java]
1: package org.duckdb;
2: 
3: import java.io.File;
4: import java.io.IOException;
5: import java.net.URL;
6: import java.nio.ByteBuffer;
7: import java.nio.file.Files;
8: import java.nio.file.Path;
9: import java.nio.file.StandardCopyOption;
10: 
11: public class DuckDBNative {
12: 	static {
13: 		try {
14: 			String os_name = "";
15: 			String os_arch = "";
16: 			String os_name_detect = System.getProperty("os.name").toLowerCase().trim();
17: 			String os_arch_detect = System.getProperty("os.arch").toLowerCase().trim();
18: 			if (os_arch_detect.equals("x86_64") || os_arch_detect.equals("amd64")) {
19: 				os_arch = "amd64";
20: 			}
21: 			// TODO 32 bit gunk
22: 
23: 			if (os_name_detect.startsWith("windows")) {
24: 				os_name = "windows";
25: 			} else if (os_name_detect.startsWith("mac")) {
26: 				os_name = "osx";
27: 			} else if (os_name_detect.startsWith("linux")) {
28: 				os_name = "linux";
29: 			}
30: 			String lib_res_name = "/libduckdb_java.so" + "_" + os_name + "_" + os_arch;
31: 
32: 			Path lib_file = Files.createTempFile("libduckdb_java", ".so");
33: 			URL lib_res = DuckDBNative.class.getResource(lib_res_name);
34: 			if (lib_res == null) {
35: 				throw new IOException(lib_res_name + " not found");
36: 			}
37: 			Files.copy(lib_res.openStream(), lib_file, StandardCopyOption.REPLACE_EXISTING);
38: 			new File(lib_file.toString()).deleteOnExit();
39: 			System.load(lib_file.toString());
40: 		} catch (IOException e) {
41: 			e.printStackTrace();
42: 		}
43: 
44: 	}
45: 	// We use zero-length ByteBuffer-s as a hacky but cheap way to pass C++ pointers
46: 	// back and forth
47: 
48: 	/*
49: 	 * NB: if you change anything below, run `javah` on this class to re-generate
50: 	 * the C header. CMake does this as well
51: 	 */
52: 
53: 	// results db_ref database reference object
54: 	protected static native ByteBuffer duckdb_jdbc_startup(byte[] path, boolean read_only);
55: 
56: 	protected static native void duckdb_jdbc_shutdown(ByteBuffer db_ref);
57: 
58: 	// returns conn_ref connection reference object
59: 	protected static native ByteBuffer duckdb_jdbc_connect(ByteBuffer db_ref);
60: 
61: 	protected static native void duckdb_jdbc_set_auto_commit(ByteBuffer conn_ref, boolean auto_commit);
62: 
63: 	protected static native boolean duckdb_jdbc_get_auto_commit(ByteBuffer conn_ref);
64: 
65: 	protected static native void duckdb_jdbc_disconnect(ByteBuffer conn_ref);
66: 
67: 	// returns stmt_ref result reference object
68: 	protected static native ByteBuffer duckdb_jdbc_prepare(ByteBuffer conn_ref, byte[] query);
69: 
70: 	protected static native String duckdb_jdbc_prepare_type(ByteBuffer stmt_ref);
71: 
72: 	protected static native void duckdb_jdbc_release(ByteBuffer stmt_ref);
73: 
74: 	protected static native DuckDBResultSetMetaData duckdb_jdbc_meta(ByteBuffer stmt_ref);
75: 
76: 
77: 	// returns res_ref result reference object
78: 	protected static native ByteBuffer duckdb_jdbc_execute(ByteBuffer stmt_ref, Object[] params);
79: 
80: 
81: 	protected static native void duckdb_jdbc_free_result(ByteBuffer res_ref);
82: 
83: 	protected static native DuckDBVector[] duckdb_jdbc_fetch(ByteBuffer res_ref);
84: 
85: 	protected static native int duckdb_jdbc_fetch_size();
86: 
87: 	protected static native ByteBuffer duckdb_jdbc_create_appender(ByteBuffer conn_ref, byte[] schema_name, byte[] table_name);
88: 
89: 	protected static native void duckdb_jdbc_appender_begin_row(ByteBuffer appender_ref);
90: 
91: 	protected static native void duckdb_jdbc_appender_end_row(ByteBuffer appender_ref);
92: 
93: 	protected static native void duckdb_jdbc_appender_flush(ByteBuffer appender_ref);
94: 
95: 	protected static native void duckdb_jdbc_appender_close(ByteBuffer appender_ref);
96: 
97: 	protected static native void duckdb_jdbc_appender_append_boolean(ByteBuffer appender_ref, boolean value);
98: 
99: 	protected static native void duckdb_jdbc_appender_append_byte(ByteBuffer appender_ref, byte value);
100: 
101: 	protected static native void duckdb_jdbc_appender_append_short(ByteBuffer appender_ref, short value);
102: 
103: 	protected static native void duckdb_jdbc_appender_append_int(ByteBuffer appender_ref, int value);
104: 
105: 	protected static native void duckdb_jdbc_appender_append_long(ByteBuffer appender_ref, long value);
106: 
107: 	protected static native void duckdb_jdbc_appender_append_float(ByteBuffer appender_ref, float value);
108: 
109: 	protected static native void duckdb_jdbc_appender_append_double(ByteBuffer appender_ref, double value);
110: 
111: 	protected static native void duckdb_jdbc_appender_append_string(ByteBuffer appender_ref, byte[] value);
112: 
113: }
[end of tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java]
[start of tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java]
1: package org.duckdb;
2: 
3: import java.io.InputStream;
4: import java.io.Reader;
5: import java.io.UnsupportedEncodingException;
6: import java.math.BigDecimal;
7: import java.math.BigInteger;
8: import java.net.URL;
9: import java.nio.Buffer;
10: import java.nio.ByteBuffer;
11: import java.nio.ByteOrder;
12: import java.sql.Array;
13: import java.sql.Blob;
14: import java.sql.Clob;
15: import java.sql.Date;
16: import java.sql.NClob;
17: import java.sql.Ref;
18: import java.sql.ResultSet;
19: import java.sql.ResultSetMetaData;
20: import java.sql.RowId;
21: import java.sql.SQLException;
22: import java.sql.SQLFeatureNotSupportedException;
23: import java.sql.SQLWarning;
24: import java.sql.SQLXML;
25: import java.sql.Statement;
26: import java.sql.Time;
27: import java.sql.Timestamp;
28: import java.util.Calendar;
29: import java.util.Map;
30: 
31: public class DuckDBResultSet implements ResultSet {
32: 
33: 	private DuckDBPreparedStatement stmt;
34: 	private DuckDBResultSetMetaData meta;
35: 
36: 	private ByteBuffer result_ref;
37: 	private DuckDBVector[] current_chunk;
38: 	private int chunk_idx = 0;
39: 	private boolean finished = false;
40: 	private boolean was_null;
41: 
42: 	public DuckDBResultSet(DuckDBPreparedStatement stmt, DuckDBResultSetMetaData meta, ByteBuffer result_ref) {
43: 		this.stmt = stmt;
44: 		this.result_ref = result_ref;
45: 		this.meta = meta;
46: 		current_chunk = DuckDBNative.duckdb_jdbc_fetch(result_ref);
47: 		if (current_chunk.length == 0) {
48: 			finished = true;
49: 		}
50: 	}
51: 
52: 	public Statement getStatement() throws SQLException {
53: 		if (isClosed()) {
54: 			throw new SQLException("ResultSet was closed");
55: 		}
56: 		return stmt;
57: 	}
58: 
59: 	public ResultSetMetaData getMetaData() throws SQLException {
60: 		if (isClosed()) {
61: 			throw new SQLException("ResultSet was closed");
62: 		}
63: 		return meta;
64: 	}
65: 
66: 	public boolean next() throws SQLException {
67: 		if (isClosed()) {
68: 			throw new SQLException("ResultSet was closed");
69: 		}
70: 		if (finished) {
71: 			return false;
72: 		}
73: 		chunk_idx++;
74: 		if (chunk_idx > current_chunk[0].length) {
75: 			current_chunk = DuckDBNative.duckdb_jdbc_fetch(result_ref);
76: 			chunk_idx = 1;
77: 		}
78: 		if (current_chunk.length == 0) {
79: 			finished = true;
80: 			return false;
81: 		}
82: 		return true;
83: 	}
84: 
85: 	public synchronized void close() throws SQLException {
86: 		if (result_ref != null) {
87: 			DuckDBNative.duckdb_jdbc_free_result(result_ref);
88: 			result_ref = null;
89: 		}
90: 		stmt = null;
91: 		meta = null;
92: 		current_chunk = null;
93: 	}
94: 
95: 	protected void finalize() throws Throwable {
96: 		close();
97: 	}
98: 
99: 	public boolean isClosed() throws SQLException {
100: 		return result_ref == null;
101: 	}
102: 
103: 	private void check(int columnIndex) throws SQLException {
104: 		if (isClosed()) {
105: 			throw new SQLException("ResultSet was closed");
106: 		}
107: 		if (columnIndex < 1 || columnIndex > meta.column_count) {
108: 			throw new SQLException("Column index out of bounds");
109: 		}
110: 
111: 	}
112: 
113: 	public Object getObject(int columnIndex) throws SQLException {
114: 		check_and_null(columnIndex);
115: 		if (was_null) {
116: 			return null;
117: 		}
118: 		String column_type = meta.column_types[columnIndex - 1];
119: 		if (column_type.equals("BOOLEAN")) {
120: 			return getBoolean(columnIndex);
121: 		} else if (column_type.equals("TINYINT")) {
122: 			return getByte(columnIndex);
123: 		} else if (column_type.equals("SMALLINT")) {
124: 			return getShort(columnIndex);
125: 		} else if (column_type.equals("INTEGER")) {
126: 			return getInt(columnIndex);
127: 		} else if (column_type.equals("BIGINT")) {
128: 			return getLong(columnIndex);
129: 		}else if (column_type.equals("UTINYINT")) {
130: 			return getShort(columnIndex);
131: 		} else if (column_type.equals("USMALLINT")) {
132: 			return getInt(columnIndex);
133: 		} else if (column_type.equals("UINTEGER")) {
134: 			return getLong(columnIndex);
135: 		} else if (column_type.equals("UBIGINT")) {
136: 			return getHugeint(columnIndex);
137: 		} else if (column_type.equals("HUGEINT")) {
138: 			return getHugeint(columnIndex);
139: 		} else if (column_type.equals("FLOAT")) {
140: 			return getFloat(columnIndex);
141: 		} else if (column_type.equals("DOUBLE") || column_type.startsWith("DECIMAL")) {
142: 			return getDouble(columnIndex);
143: 		} else if (column_type.equals("VARCHAR")) {
144: 			return getString(columnIndex);
145: 		} else if (column_type.equals("TIME")) {
146: 			return getTime(columnIndex);
147: 		} else if (column_type.equals("DATE")) {
148: 			return getDate(columnIndex);
149: 		} else if (column_type.equals("TIMESTAMP")) {
150: 			return getTimestamp(columnIndex);
151: 		} else if (column_type.equals("INTERVAL")) {
152: 			return getLazyString(columnIndex);
153: 		} else {
154: 			throw new SQLException("Not implemented type: " + meta.column_types[columnIndex - 1]);
155: 		}
156: 	}
157: 
158: 	public boolean wasNull() throws SQLException {
159: 		if (isClosed()) {
160: 			throw new SQLException("ResultSet was closed");
161: 		}
162: 		return was_null;
163: 	}
164: 
165: 	private boolean check_and_null(int columnIndex) throws SQLException {
166: 		check(columnIndex);
167: 		was_null = current_chunk[columnIndex - 1].nullmask[chunk_idx - 1];
168: 		return was_null;
169: 	}
170: 
171: 	public String getLazyString(int columnIndex) throws SQLException {
172: 		if (check_and_null(columnIndex)) {
173: 			return null;
174: 		}
175: 		return (String) current_chunk[columnIndex - 1].varlen_data[chunk_idx - 1];
176: 	}
177: 
178: 	public String getString(int columnIndex) throws SQLException {
179: 		if (check_and_null(columnIndex)) {
180: 			return null;
181: 		}
182: 
183: 		if ("VARCHAR".equals(meta.column_types[columnIndex - 1])) {
184: 			return (String) current_chunk[columnIndex - 1].varlen_data[chunk_idx - 1];
185: 		}
186: 		Object res = getObject(columnIndex);
187: 		if (res == null) {
188: 			return null;
189: 		} else {
190: 			return res.toString();
191: 		}
192: 	}
193: 
194: 	private ByteBuffer getbuf(int columnIndex, int typeWidth) throws SQLException {
195: 		ByteBuffer buf = current_chunk[columnIndex - 1].constlen_data;
196: 		buf.order(ByteOrder.LITTLE_ENDIAN);
197: 		((Buffer) buf).position((chunk_idx - 1) * typeWidth);
198: 		return buf;
199: 	}
200: 
201: 	public boolean getBoolean(int columnIndex) throws SQLException {
202: 		if (check_and_null(columnIndex)) {
203: 			return false;
204: 		}
205: 		if ("BOOLEAN".equals(meta.column_types[columnIndex - 1])) {
206: 			return getbuf(columnIndex, 1).get() == 1;
207: 		}
208: 		Object o = getObject(columnIndex);
209: 		if (o instanceof Number) {
210: 			return ((Number) o).byteValue() == 1;
211: 		}
212: 
213: 		return Boolean.parseBoolean(getObject(columnIndex).toString());
214: 	}
215: 
216: 	public byte getByte(int columnIndex) throws SQLException {
217: 		if (check_and_null(columnIndex)) {
218: 			return 0;
219: 		}
220: 		if ("TINYINT".equals(meta.column_types[columnIndex - 1])) {
221: 			return getbuf(columnIndex, 1).get();
222: 		}
223: 		Object o = getObject(columnIndex);
224: 		if (o instanceof Number) {
225: 			return ((Number) o).byteValue();
226: 		}
227: 		return Byte.parseByte(o.toString());
228: 	}
229: 
230: 	public short getShort(int columnIndex) throws SQLException {
231: 		if (check_and_null(columnIndex)) {
232: 			return 0;
233: 		}
234: 		if ("SMALLINT".equals(meta.column_types[columnIndex - 1])) {
235: 			return getbuf(columnIndex, 2).getShort();
236: 		}
237: 		else if ("UTINYINT".equals(meta.column_types[columnIndex - 1])){
238: 			byte[] buf_res = new byte[2];
239: 			byte[] buf = new byte[1];
240: 			getbuf(columnIndex, 1).get(buf);
241: 			buf_res[1] = buf[0];
242: 			ByteBuffer bb = ByteBuffer.wrap(buf_res);
243: 			return bb.getShort();
244: 		}
245: 		Object o = getObject(columnIndex);
246: 		if (o instanceof Number) {
247: 			return ((Number) o).shortValue();
248: 		}
249: 		return Short.parseShort(o.toString());
250: 	}
251: 
252: 	public int getInt(int columnIndex) throws SQLException {
253: 		if (check_and_null(columnIndex)) {
254: 			return 0;
255: 		}
256: 		if ("INTEGER".equals(meta.column_types[columnIndex - 1])) {
257: 			return getbuf(columnIndex, 4).getInt();
258: 		}
259: 		else if ("USMALLINT".equals(meta.column_types[columnIndex - 1])){
260: 			byte[] buf_res = new byte[4];
261: 			byte[] buf = new byte[2];
262: 			getbuf(columnIndex, 2).get(buf);
263: 			buf_res[2] = buf[0];
264: 			buf_res[3] = buf[1];
265: 			ByteBuffer bb = ByteBuffer.wrap(buf_res);
266: 			return bb.getInt();
267: 		}
268: 		Object o = getObject(columnIndex);
269: 		if (o instanceof Number) {
270: 			return ((Number) o).intValue();
271: 		}
272: 		return Integer.parseInt(o.toString());
273: 	}
274: 
275: 	public long getLong(int columnIndex) throws SQLException {
276: 		if (check_and_null(columnIndex)) {
277: 			return 0;
278: 		}
279: 		if ("BIGINT".equals(meta.column_types[columnIndex - 1])) {
280: 			return getbuf(columnIndex, 8).getLong();
281: 		}
282: 		else if( "UINTEGER".equals(meta.column_types[columnIndex - 1])){
283: 			byte[] buf_res = new byte[8];
284: 			byte[] buf = new byte[4];
285: 			getbuf(columnIndex, 4).get(buf);
286: 			buf_res[4] = buf[0];
287: 			buf_res[5] = buf[1];
288: 			buf_res[6] = buf[2];
289: 			buf_res[7] = buf[3];
290: 
291: 			ByteBuffer bb = ByteBuffer.wrap(buf_res);
292: 			return bb.getLong();
293: 		}
294: 		Object o = getObject(columnIndex);
295: 		if (o instanceof Number) {
296: 			return ((Number) o).longValue();
297: 		}
298: 		return Long.parseLong(o.toString());
299: 	}
300: 
301: 	public BigInteger getHugeint(int columnIndex) throws SQLException {
302: 		if (check_and_null(columnIndex)) {
303: 			return BigInteger.ZERO;
304: 		}
305: 		if ("HUGEINT".equals(meta.column_types[columnIndex - 1])) {
306: 			byte[] buf = new byte[16];
307: 			getbuf(columnIndex, 16).get(buf);
308: 
309: 			for (int i = 0; i < 8; i++) {
310: 				byte keep = buf[i];
311: 				buf[i] = buf[15 - i];
312: 				buf[15 - i] = keep;
313: 			}
314: 			return new BigInteger(buf);
315: 		}
316: 		else if ("UBIGINT".equals(meta.column_types[columnIndex - 1])) {
317: 			byte[] buf_res = new byte[16];
318: 			byte[] buf = new byte[8];
319: 			getbuf(columnIndex, 8).get(buf);
320: 			buf_res[8] = buf[0];
321: 			buf_res[9] = buf[1];
322: 			buf_res[10] = buf[2];
323: 			buf_res[11] = buf[3];
324: 			buf_res[12] = buf[4];
325: 			buf_res[13] = buf[5];
326: 			buf_res[14] = buf[6];
327: 			buf_res[15] = buf[7];
328: 			return new BigInteger(buf_res);
329: 		}
330: 		Object o = getObject(columnIndex);
331: 		return new BigInteger(o.toString());
332: 	}
333: 
334: 	public float getFloat(int columnIndex) throws SQLException {
335: 		if (check_and_null(columnIndex)) {
336: 			return Float.NaN;
337: 		}
338: 		if ("FLOAT".equals(meta.column_types[columnIndex - 1])) {
339: 			return getbuf(columnIndex, 4).getFloat();
340: 		}
341: 		Object o = getObject(columnIndex);
342: 		if (o instanceof Number) {
343: 			return ((Number) o).floatValue();
344: 		}
345: 		return Float.parseFloat(o.toString());
346: 	}
347: 
348: 	public double getDouble(int columnIndex) throws SQLException {
349: 		if (check_and_null(columnIndex)) {
350: 			return Double.NaN;
351: 		}
352: 		String col_type_str = meta.column_types[columnIndex - 1];
353: 		if (col_type_str.equals("DOUBLE") || col_type_str.startsWith("DECIMAL")) {
354: 			return getbuf(columnIndex, 8).getDouble();
355: 		}
356: 		Object o = getObject(columnIndex);
357: 		if (o instanceof Number) {
358: 			return ((Number) o).doubleValue();
359: 		}
360: 		return Double.parseDouble(o.toString());
361: 	}
362: 
363: 	public int findColumn(String columnLabel) throws SQLException {
364: 		if (isClosed()) {
365: 			throw new SQLException("ResultSet was closed");
366: 		}
367: 		for (int col_idx = 0; col_idx < meta.column_count; col_idx++) {
368: 			if (meta.column_names[col_idx].contentEquals(columnLabel)) {
369: 				return col_idx + 1;
370: 			}
371: 		}
372: 		throw new SQLException("Could not find column with label " + columnLabel);
373: 	}
374: 
375: 	public String getString(String columnLabel) throws SQLException {
376: 		return getString(findColumn(columnLabel));
377: 	}
378: 
379: 	public boolean getBoolean(String columnLabel) throws SQLException {
380: 		return getBoolean(findColumn(columnLabel));
381: 	}
382: 
383: 	public byte getByte(String columnLabel) throws SQLException {
384: 		return getByte(findColumn(columnLabel));
385: 	}
386: 
387: 	public short getShort(String columnLabel) throws SQLException {
388: 		return getShort(findColumn(columnLabel));
389: 	}
390: 
391: 	public int getInt(String columnLabel) throws SQLException {
392: 		return getInt(findColumn(columnLabel));
393: 	}
394: 
395: 	public long getLong(String columnLabel) throws SQLException {
396: 		return getLong(findColumn(columnLabel));
397: 	}
398: 
399: 	public float getFloat(String columnLabel) throws SQLException {
400: 		return getFloat(findColumn(columnLabel));
401: 	}
402: 
403: 	public double getDouble(String columnLabel) throws SQLException {
404: 		return getDouble(findColumn(columnLabel));
405: 	}
406: 
407: 	public Object getObject(String columnLabel) throws SQLException {
408: 		return getObject(findColumn(columnLabel));
409: 	}
410: 
411: 	public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
412: 		throw new SQLFeatureNotSupportedException();
413: 	}
414: 
415: 	public byte[] getBytes(int columnIndex) throws SQLException {
416: 		throw new SQLFeatureNotSupportedException();
417: 	}
418: 
419: 	public Date getDate(int columnIndex) throws SQLException {
420: 		String string_value = getLazyString(columnIndex);
421: 		if (string_value == null) {
422: 			return null;
423: 		}
424: 		try {
425: 			return Date.valueOf(string_value);
426: 		} catch (Exception e) {
427: 			return null;
428: 		}
429: 	}
430: 
431: 	public Time getTime(int columnIndex) throws SQLException {
432: 		String string_value = getLazyString(columnIndex);
433: 		if (string_value == null) {
434: 			return null;
435: 		}
436: 		try {
437: 
438: 			return Time.valueOf(getLazyString(columnIndex));
439: 		} catch (Exception e) {
440: 			return null;
441: 		}
442: 	}
443: 
444: 	public Timestamp getTimestamp(int columnIndex) throws SQLException {
445: 		String string_value = getLazyString(columnIndex);
446: 		if (string_value == null) {
447: 			return null;
448: 		}
449: 		try {
450: 
451: 			return Timestamp.valueOf(getLazyString(columnIndex));
452: 		} catch (Exception e) {
453: 			return null;
454: 		}
455: 	}
456: 
457: 	public InputStream getAsciiStream(int columnIndex) throws SQLException {
458: 		throw new SQLFeatureNotSupportedException();
459: 	}
460: 
461: 	public InputStream getUnicodeStream(int columnIndex) throws SQLException {
462: 		throw new SQLFeatureNotSupportedException();
463: 	}
464: 
465: 	public InputStream getBinaryStream(int columnIndex) throws SQLException {
466: 		throw new SQLFeatureNotSupportedException();
467: 	}
468: 
469: 	public BigDecimal getBigDecimal(String columnLabel, int scale) throws SQLException {
470: 		throw new SQLFeatureNotSupportedException();
471: 	}
472: 
473: 	public byte[] getBytes(String columnLabel) throws SQLException {
474: 		throw new SQLFeatureNotSupportedException();
475: 	}
476: 
477: 	public Date getDate(String columnLabel) throws SQLException {
478: 		return getDate(findColumn(columnLabel));
479: 	}
480: 
481: 	public Time getTime(String columnLabel) throws SQLException {
482: 		return getTime(findColumn(columnLabel));
483: 	}
484: 
485: 	public Timestamp getTimestamp(String columnLabel) throws SQLException {
486: 		return getTimestamp(findColumn(columnLabel));
487: 	}
488: 
489: 	public InputStream getAsciiStream(String columnLabel) throws SQLException {
490: 		throw new SQLFeatureNotSupportedException();
491: 	}
492: 
493: 	public InputStream getUnicodeStream(String columnLabel) throws SQLException {
494: 		throw new SQLFeatureNotSupportedException();
495: 	}
496: 
497: 	public InputStream getBinaryStream(String columnLabel) throws SQLException {
498: 		throw new SQLFeatureNotSupportedException();
499: 	}
500: 
501: 	public SQLWarning getWarnings() throws SQLException {
502: 		throw new SQLFeatureNotSupportedException();
503: 	}
504: 
505: 	public void clearWarnings() throws SQLException {
506: 		throw new SQLFeatureNotSupportedException();
507: 	}
508: 
509: 	public String getCursorName() throws SQLException {
510: 		throw new SQLFeatureNotSupportedException();
511: 	}
512: 
513: 	public Reader getCharacterStream(int columnIndex) throws SQLException {
514: 		throw new SQLFeatureNotSupportedException();
515: 	}
516: 
517: 	public Reader getCharacterStream(String columnLabel) throws SQLException {
518: 		throw new SQLFeatureNotSupportedException();
519: 	}
520: 
521: 	public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
522: 		return new BigDecimal(getHugeint(columnIndex));
523: 	}
524: 
525: 	public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
526: 		return getBigDecimal(findColumn(columnLabel));
527: 	}
528: 
529: 	public boolean isBeforeFirst() throws SQLException {
530: 		throw new SQLFeatureNotSupportedException();
531: 	}
532: 
533: 	public boolean isAfterLast() throws SQLException {
534: 		throw new SQLFeatureNotSupportedException();
535: 	}
536: 
537: 	public boolean isFirst() throws SQLException {
538: 		throw new SQLFeatureNotSupportedException();
539: 	}
540: 
541: 	public boolean isLast() throws SQLException {
542: 		throw new SQLFeatureNotSupportedException();
543: 	}
544: 
545: 	public void beforeFirst() throws SQLException {
546: 		throw new SQLFeatureNotSupportedException();
547: 	}
548: 
549: 	public void afterLast() throws SQLException {
550: 		throw new SQLFeatureNotSupportedException();
551: 	}
552: 
553: 	public boolean first() throws SQLException {
554: 		throw new SQLFeatureNotSupportedException();
555: 	}
556: 
557: 	public boolean last() throws SQLException {
558: 		throw new SQLFeatureNotSupportedException();
559: 	}
560: 
561: 	public int getRow() throws SQLException {
562: 		throw new SQLFeatureNotSupportedException();
563: 	}
564: 
565: 	public boolean absolute(int row) throws SQLException {
566: 		throw new SQLFeatureNotSupportedException();
567: 	}
568: 
569: 	public boolean relative(int rows) throws SQLException {
570: 		throw new SQLFeatureNotSupportedException();
571: 	}
572: 
573: 	public boolean previous() throws SQLException {
574: 		throw new SQLFeatureNotSupportedException();
575: 	}
576: 
577: 	public void setFetchDirection(int direction) throws SQLException {
578: 		if (direction != ResultSet.FETCH_FORWARD && direction != ResultSet.FETCH_UNKNOWN) {
579: 			throw new SQLFeatureNotSupportedException();
580: 		}
581: 	}
582: 
583: 	public int getFetchDirection() throws SQLException {
584: 		return ResultSet.FETCH_FORWARD;
585: 	}
586: 
587: 	public void setFetchSize(int rows) throws SQLException {
588: 		if (rows < 0) {
589: 			throw new SQLException("Fetch size has to be >= 0");
590: 		}
591: 		// whatevs
592: 	}
593: 
594: 	public int getFetchSize() throws SQLException {
595: 		return DuckDBNative.duckdb_jdbc_fetch_size();
596: 	}
597: 
598: 	public int getType() throws SQLException {
599: 		return ResultSet.TYPE_FORWARD_ONLY;
600: 	}
601: 
602: 	public int getConcurrency() throws SQLException {
603: 		return ResultSet.CONCUR_READ_ONLY;
604: 	}
605: 
606: 	public boolean rowUpdated() throws SQLException {
607: 		throw new SQLFeatureNotSupportedException();
608: 	}
609: 
610: 	public boolean rowInserted() throws SQLException {
611: 		throw new SQLFeatureNotSupportedException();
612: 	}
613: 
614: 	public boolean rowDeleted() throws SQLException {
615: 		throw new SQLFeatureNotSupportedException();
616: 	}
617: 
618: 	public void updateNull(int columnIndex) throws SQLException {
619: 		throw new SQLFeatureNotSupportedException();
620: 	}
621: 
622: 	public void updateBoolean(int columnIndex, boolean x) throws SQLException {
623: 		throw new SQLFeatureNotSupportedException();
624: 	}
625: 
626: 	public void updateByte(int columnIndex, byte x) throws SQLException {
627: 		throw new SQLFeatureNotSupportedException();
628: 	}
629: 
630: 	public void updateShort(int columnIndex, short x) throws SQLException {
631: 		throw new SQLFeatureNotSupportedException();
632: 	}
633: 
634: 	public void updateInt(int columnIndex, int x) throws SQLException {
635: 		throw new SQLFeatureNotSupportedException();
636: 	}
637: 
638: 	public void updateLong(int columnIndex, long x) throws SQLException {
639: 		throw new SQLFeatureNotSupportedException();
640: 	}
641: 
642: 	public void updateFloat(int columnIndex, float x) throws SQLException {
643: 		throw new SQLFeatureNotSupportedException();
644: 	}
645: 
646: 	public void updateDouble(int columnIndex, double x) throws SQLException {
647: 		throw new SQLFeatureNotSupportedException();
648: 	}
649: 
650: 	public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
651: 		throw new SQLFeatureNotSupportedException();
652: 	}
653: 
654: 	public void updateString(int columnIndex, String x) throws SQLException {
655: 		throw new SQLFeatureNotSupportedException();
656: 	}
657: 
658: 	public void updateBytes(int columnIndex, byte[] x) throws SQLException {
659: 		throw new SQLFeatureNotSupportedException();
660: 	}
661: 
662: 	public void updateDate(int columnIndex, Date x) throws SQLException {
663: 		throw new SQLFeatureNotSupportedException();
664: 	}
665: 
666: 	public void updateTime(int columnIndex, Time x) throws SQLException {
667: 		throw new SQLFeatureNotSupportedException();
668: 	}
669: 
670: 	public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException {
671: 		throw new SQLFeatureNotSupportedException();
672: 	}
673: 
674: 	public void updateAsciiStream(int columnIndex, InputStream x, int length) throws SQLException {
675: 		throw new SQLFeatureNotSupportedException();
676: 	}
677: 
678: 	public void updateBinaryStream(int columnIndex, InputStream x, int length) throws SQLException {
679: 		throw new SQLFeatureNotSupportedException();
680: 	}
681: 
682: 	public void updateCharacterStream(int columnIndex, Reader x, int length) throws SQLException {
683: 		throw new SQLFeatureNotSupportedException();
684: 	}
685: 
686: 	public void updateObject(int columnIndex, Object x, int scaleOrLength) throws SQLException {
687: 		throw new SQLFeatureNotSupportedException();
688: 	}
689: 
690: 	public void updateObject(int columnIndex, Object x) throws SQLException {
691: 		throw new SQLFeatureNotSupportedException();
692: 	}
693: 
694: 	public void updateNull(String columnLabel) throws SQLException {
695: 		throw new SQLFeatureNotSupportedException();
696: 	}
697: 
698: 	public void updateBoolean(String columnLabel, boolean x) throws SQLException {
699: 		throw new SQLFeatureNotSupportedException();
700: 	}
701: 
702: 	public void updateByte(String columnLabel, byte x) throws SQLException {
703: 		throw new SQLFeatureNotSupportedException();
704: 	}
705: 
706: 	public void updateShort(String columnLabel, short x) throws SQLException {
707: 		throw new SQLFeatureNotSupportedException();
708: 	}
709: 
710: 	public void updateInt(String columnLabel, int x) throws SQLException {
711: 		throw new SQLFeatureNotSupportedException();
712: 	}
713: 
714: 	public void updateLong(String columnLabel, long x) throws SQLException {
715: 		throw new SQLFeatureNotSupportedException();
716: 	}
717: 
718: 	public void updateFloat(String columnLabel, float x) throws SQLException {
719: 		throw new SQLFeatureNotSupportedException();
720: 	}
721: 
722: 	public void updateDouble(String columnLabel, double x) throws SQLException {
723: 		throw new SQLFeatureNotSupportedException();
724: 	}
725: 
726: 	public void updateBigDecimal(String columnLabel, BigDecimal x) throws SQLException {
727: 		throw new SQLFeatureNotSupportedException();
728: 	}
729: 
730: 	public void updateString(String columnLabel, String x) throws SQLException {
731: 		throw new SQLFeatureNotSupportedException();
732: 	}
733: 
734: 	public void updateBytes(String columnLabel, byte[] x) throws SQLException {
735: 		throw new SQLFeatureNotSupportedException();
736: 	}
737: 
738: 	public void updateDate(String columnLabel, Date x) throws SQLException {
739: 		throw new SQLFeatureNotSupportedException();
740: 	}
741: 
742: 	public void updateTime(String columnLabel, Time x) throws SQLException {
743: 		throw new SQLFeatureNotSupportedException();
744: 	}
745: 
746: 	public void updateTimestamp(String columnLabel, Timestamp x) throws SQLException {
747: 		throw new SQLFeatureNotSupportedException();
748: 	}
749: 
750: 	public void updateAsciiStream(String columnLabel, InputStream x, int length) throws SQLException {
751: 		throw new SQLFeatureNotSupportedException();
752: 	}
753: 
754: 	public void updateBinaryStream(String columnLabel, InputStream x, int length) throws SQLException {
755: 		throw new SQLFeatureNotSupportedException();
756: 	}
757: 
758: 	public void updateCharacterStream(String columnLabel, Reader reader, int length) throws SQLException {
759: 		throw new SQLFeatureNotSupportedException();
760: 	}
761: 
762: 	public void updateObject(String columnLabel, Object x, int scaleOrLength) throws SQLException {
763: 		throw new SQLFeatureNotSupportedException();
764: 	}
765: 
766: 	public void updateObject(String columnLabel, Object x) throws SQLException {
767: 		throw new SQLFeatureNotSupportedException();
768: 	}
769: 
770: 	public void insertRow() throws SQLException {
771: 		throw new SQLFeatureNotSupportedException();
772: 	}
773: 
774: 	public void updateRow() throws SQLException {
775: 		throw new SQLFeatureNotSupportedException();
776: 	}
777: 
778: 	public void deleteRow() throws SQLException {
779: 		throw new SQLFeatureNotSupportedException();
780: 	}
781: 
782: 	public void refreshRow() throws SQLException {
783: 		throw new SQLFeatureNotSupportedException();
784: 	}
785: 
786: 	public void cancelRowUpdates() throws SQLException {
787: 		throw new SQLFeatureNotSupportedException();
788: 	}
789: 
790: 	public void moveToInsertRow() throws SQLException {
791: 		throw new SQLFeatureNotSupportedException();
792: 	}
793: 
794: 	public void moveToCurrentRow() throws SQLException {
795: 		throw new SQLFeatureNotSupportedException();
796: 	}
797: 
798: 	public Object getObject(int columnIndex, Map<String, Class<?>> map) throws SQLException {
799: 		throw new SQLFeatureNotSupportedException();
800: 	}
801: 
802: 	public Ref getRef(int columnIndex) throws SQLException {
803: 		throw new SQLFeatureNotSupportedException();
804: 	}
805: 
806: 	public Blob getBlob(int columnIndex) throws SQLException {
807: 		throw new SQLFeatureNotSupportedException();
808: 	}
809: 
810: 	public Clob getClob(int columnIndex) throws SQLException {
811: 		throw new SQLFeatureNotSupportedException();
812: 	}
813: 
814: 	public Array getArray(int columnIndex) throws SQLException {
815: 		throw new SQLFeatureNotSupportedException();
816: 	}
817: 
818: 	public Object getObject(String columnLabel, Map<String, Class<?>> map) throws SQLException {
819: 		throw new SQLFeatureNotSupportedException();
820: 	}
821: 
822: 	public Ref getRef(String columnLabel) throws SQLException {
823: 		throw new SQLFeatureNotSupportedException();
824: 	}
825: 
826: 	public Blob getBlob(String columnLabel) throws SQLException {
827: 		throw new SQLFeatureNotSupportedException();
828: 	}
829: 
830: 	public Clob getClob(String columnLabel) throws SQLException {
831: 		throw new SQLFeatureNotSupportedException();
832: 	}
833: 
834: 	public Array getArray(String columnLabel) throws SQLException {
835: 		throw new SQLFeatureNotSupportedException();
836: 	}
837: 
838: 	public Date getDate(int columnIndex, Calendar cal) throws SQLException {
839: 		throw new SQLFeatureNotSupportedException();
840: 	}
841: 
842: 	public Date getDate(String columnLabel, Calendar cal) throws SQLException {
843: 		throw new SQLFeatureNotSupportedException();
844: 	}
845: 
846: 	public Time getTime(int columnIndex, Calendar cal) throws SQLException {
847: 		throw new SQLFeatureNotSupportedException();
848: 	}
849: 
850: 	public Time getTime(String columnLabel, Calendar cal) throws SQLException {
851: 		throw new SQLFeatureNotSupportedException();
852: 	}
853: 
854: 	public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
855: 		throw new SQLFeatureNotSupportedException();
856: 	}
857: 
858: 	public Timestamp getTimestamp(String columnLabel, Calendar cal) throws SQLException {
859: 		throw new SQLFeatureNotSupportedException();
860: 	}
861: 
862: 	public URL getURL(int columnIndex) throws SQLException {
863: 		throw new SQLFeatureNotSupportedException();
864: 	}
865: 
866: 	public URL getURL(String columnLabel) throws SQLException {
867: 		throw new SQLFeatureNotSupportedException();
868: 	}
869: 
870: 	public void updateRef(int columnIndex, Ref x) throws SQLException {
871: 		throw new SQLFeatureNotSupportedException();
872: 	}
873: 
874: 	public void updateRef(String columnLabel, Ref x) throws SQLException {
875: 		throw new SQLFeatureNotSupportedException();
876: 	}
877: 
878: 	public void updateBlob(int columnIndex, Blob x) throws SQLException {
879: 		throw new SQLFeatureNotSupportedException();
880: 	}
881: 
882: 	public void updateBlob(String columnLabel, Blob x) throws SQLException {
883: 		throw new SQLFeatureNotSupportedException();
884: 	}
885: 
886: 	public void updateClob(int columnIndex, Clob x) throws SQLException {
887: 		throw new SQLFeatureNotSupportedException();
888: 	}
889: 
890: 	public void updateClob(String columnLabel, Clob x) throws SQLException {
891: 		throw new SQLFeatureNotSupportedException();
892: 	}
893: 
894: 	public void updateArray(int columnIndex, Array x) throws SQLException {
895: 		throw new SQLFeatureNotSupportedException();
896: 	}
897: 
898: 	public void updateArray(String columnLabel, Array x) throws SQLException {
899: 		throw new SQLFeatureNotSupportedException();
900: 	}
901: 
902: 	public RowId getRowId(int columnIndex) throws SQLException {
903: 		throw new SQLFeatureNotSupportedException();
904: 	}
905: 
906: 	public RowId getRowId(String columnLabel) throws SQLException {
907: 		throw new SQLFeatureNotSupportedException();
908: 	}
909: 
910: 	public void updateRowId(int columnIndex, RowId x) throws SQLException {
911: 		throw new SQLFeatureNotSupportedException();
912: 	}
913: 
914: 	public void updateRowId(String columnLabel, RowId x) throws SQLException {
915: 		throw new SQLFeatureNotSupportedException();
916: 	}
917: 
918: 	public int getHoldability() throws SQLException {
919: 		throw new SQLFeatureNotSupportedException();
920: 	}
921: 
922: 	public void updateNString(int columnIndex, String nString) throws SQLException {
923: 		throw new SQLFeatureNotSupportedException();
924: 	}
925: 
926: 	public void updateNString(String columnLabel, String nString) throws SQLException {
927: 		throw new SQLFeatureNotSupportedException();
928: 	}
929: 
930: 	public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
931: 		throw new SQLFeatureNotSupportedException();
932: 	}
933: 
934: 	public void updateNClob(String columnLabel, NClob nClob) throws SQLException {
935: 		throw new SQLFeatureNotSupportedException();
936: 	}
937: 
938: 	public NClob getNClob(int columnIndex) throws SQLException {
939: 		throw new SQLFeatureNotSupportedException();
940: 	}
941: 
942: 	public NClob getNClob(String columnLabel) throws SQLException {
943: 		throw new SQLFeatureNotSupportedException();
944: 	}
945: 
946: 	public SQLXML getSQLXML(int columnIndex) throws SQLException {
947: 		throw new SQLFeatureNotSupportedException();
948: 	}
949: 
950: 	public SQLXML getSQLXML(String columnLabel) throws SQLException {
951: 		throw new SQLFeatureNotSupportedException();
952: 	}
953: 
954: 	public void updateSQLXML(int columnIndex, SQLXML xmlObject) throws SQLException {
955: 		throw new SQLFeatureNotSupportedException();
956: 	}
957: 
958: 	public void updateSQLXML(String columnLabel, SQLXML xmlObject) throws SQLException {
959: 		throw new SQLFeatureNotSupportedException();
960: 	}
961: 
962: 	public String getNString(int columnIndex) throws SQLException {
963: 		throw new SQLFeatureNotSupportedException();
964: 	}
965: 
966: 	public String getNString(String columnLabel) throws SQLException {
967: 		throw new SQLFeatureNotSupportedException();
968: 	}
969: 
970: 	public Reader getNCharacterStream(int columnIndex) throws SQLException {
971: 		throw new SQLFeatureNotSupportedException();
972: 	}
973: 
974: 	public Reader getNCharacterStream(String columnLabel) throws SQLException {
975: 		throw new SQLFeatureNotSupportedException();
976: 	}
977: 
978: 	public void updateNCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
979: 		throw new SQLFeatureNotSupportedException();
980: 	}
981: 
982: 	public void updateNCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
983: 		throw new SQLFeatureNotSupportedException();
984: 	}
985: 
986: 	public void updateAsciiStream(int columnIndex, InputStream x, long length) throws SQLException {
987: 		throw new SQLFeatureNotSupportedException();
988: 	}
989: 
990: 	public void updateBinaryStream(int columnIndex, InputStream x, long length) throws SQLException {
991: 		throw new SQLFeatureNotSupportedException();
992: 	}
993: 
994: 	public void updateCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
995: 		throw new SQLFeatureNotSupportedException();
996: 	}
997: 
998: 	public void updateAsciiStream(String columnLabel, InputStream x, long length) throws SQLException {
999: 		throw new SQLFeatureNotSupportedException();
1000: 	}
1001: 
1002: 	public void updateBinaryStream(String columnLabel, InputStream x, long length) throws SQLException {
1003: 		throw new SQLFeatureNotSupportedException();
1004: 	}
1005: 
1006: 	public void updateCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
1007: 		throw new SQLFeatureNotSupportedException();
1008: 	}
1009: 
1010: 	public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
1011: 		throw new SQLFeatureNotSupportedException();
1012: 	}
1013: 
1014: 	public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
1015: 		throw new SQLFeatureNotSupportedException();
1016: 	}
1017: 
1018: 	public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
1019: 		throw new SQLFeatureNotSupportedException();
1020: 	}
1021: 
1022: 	public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
1023: 		throw new SQLFeatureNotSupportedException();
1024: 	}
1025: 
1026: 	public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
1027: 		throw new SQLFeatureNotSupportedException();
1028: 	}
1029: 
1030: 	public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
1031: 		throw new SQLFeatureNotSupportedException();
1032: 	}
1033: 
1034: 	public void updateNCharacterStream(int columnIndex, Reader x) throws SQLException {
1035: 		throw new SQLFeatureNotSupportedException();
1036: 	}
1037: 
1038: 	public void updateNCharacterStream(String columnLabel, Reader reader) throws SQLException {
1039: 		throw new SQLFeatureNotSupportedException();
1040: 	}
1041: 
1042: 	public void updateAsciiStream(int columnIndex, InputStream x) throws SQLException {
1043: 		throw new SQLFeatureNotSupportedException();
1044: 	}
1045: 
1046: 	public void updateBinaryStream(int columnIndex, InputStream x) throws SQLException {
1047: 		throw new SQLFeatureNotSupportedException();
1048: 	}
1049: 
1050: 	public void updateCharacterStream(int columnIndex, Reader x) throws SQLException {
1051: 		throw new SQLFeatureNotSupportedException();
1052: 	}
1053: 
1054: 	public void updateAsciiStream(String columnLabel, InputStream x) throws SQLException {
1055: 		throw new SQLFeatureNotSupportedException();
1056: 	}
1057: 
1058: 	public void updateBinaryStream(String columnLabel, InputStream x) throws SQLException {
1059: 		throw new SQLFeatureNotSupportedException();
1060: 	}
1061: 
1062: 	public void updateCharacterStream(String columnLabel, Reader reader) throws SQLException {
1063: 		throw new SQLFeatureNotSupportedException();
1064: 	}
1065: 
1066: 	public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
1067: 		throw new SQLFeatureNotSupportedException();
1068: 	}
1069: 
1070: 	public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
1071: 		throw new SQLFeatureNotSupportedException();
1072: 	}
1073: 
1074: 	public void updateClob(int columnIndex, Reader reader) throws SQLException {
1075: 		throw new SQLFeatureNotSupportedException();
1076: 	}
1077: 
1078: 	public void updateClob(String columnLabel, Reader reader) throws SQLException {
1079: 		throw new SQLFeatureNotSupportedException();
1080: 	}
1081: 
1082: 	public void updateNClob(int columnIndex, Reader reader) throws SQLException {
1083: 		throw new SQLFeatureNotSupportedException();
1084: 	}
1085: 
1086: 	public void updateNClob(String columnLabel, Reader reader) throws SQLException {
1087: 		throw new SQLFeatureNotSupportedException();
1088: 	}
1089: 
1090: 	public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
1091: 		throw new SQLFeatureNotSupportedException();
1092: 	}
1093: 
1094: 	public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
1095: 		throw new SQLFeatureNotSupportedException();
1096: 	}
1097: 
1098: 	public <T> T unwrap(Class<T> iface) throws SQLException {
1099: 		throw new SQLFeatureNotSupportedException();
1100: 	}
1101: 
1102: 	public boolean isWrapperFor(Class<?> iface) throws SQLException {
1103: 		throw new SQLFeatureNotSupportedException();
1104: 	}
1105: 
1106: }
[end of tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java]
[start of tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java]
1: package org.duckdb;
2: 
3: import java.sql.Date;
4: import java.sql.ResultSetMetaData;
5: import java.sql.SQLException;
6: import java.sql.SQLFeatureNotSupportedException;
7: import java.sql.Time;
8: import java.sql.Timestamp;
9: import java.sql.Types;
10: 
11: public class DuckDBResultSetMetaData implements ResultSetMetaData {
12: 
13: 	public DuckDBResultSetMetaData(int param_count, int column_count, String[] column_names, String[] column_types) {
14: 		this.param_count = param_count;
15: 		this.column_count = column_count;
16: 		this.column_names = column_names;
17: 		this.column_types = column_types;
18: 	}
19: 
20: 	protected int param_count;
21: 	protected int column_count;
22: 	protected String[] column_names;
23: 	protected String[] column_types;
24: 
25: 	public int getColumnCount() throws SQLException {
26: 		return column_count;
27: 	}
28: 
29: 	public String getColumnLabel(int column) throws SQLException {
30: 		return getColumnName(column);
31: 	}
32: 
33: 	public String getColumnName(int column) throws SQLException {
34: 		if (column > column_count) {
35: 			throw new SQLException("Column index out of bounds");
36: 		}
37: 		return column_names[column - 1];
38: 	}
39: 
40: 	public static int type_to_int(String type_name) throws SQLException {
41: 		if (type_name.equals("BOOLEAN")) {
42: 			return Types.BOOLEAN;
43: 		} else if (type_name.equals("TINYINT")) {
44: 			return Types.TINYINT;
45: 		} else if (type_name.equals("SMALLINT")) {
46: 			return Types.SMALLINT;
47: 		} else if (type_name.equals("INTEGER")) {
48: 			return Types.INTEGER;
49: 		} else if (type_name.equals("BIGINT")) {
50: 			return Types.BIGINT;
51: 		} else if (type_name.equals("FLOAT")) {
52: 			return Types.FLOAT;
53: 		} else if (type_name.equals("DOUBLE") || type_name.startsWith("DECIMAL")) {
54: 			return Types.DOUBLE;
55: 		} else if (type_name.equals("VARCHAR")) {
56: 			return Types.VARCHAR;
57: 		} else if (type_name.equals("TIME")) {
58: 			return Types.TIME;
59: 		} else if (type_name.equals("DATE")) {
60: 			return Types.DATE;
61: 		} else if (type_name.equals("TIMESTAMP")) {
62: 			return Types.TIMESTAMP;
63: 		} else if (type_name.equals("INTERVAL")) {
64: 			return Types.VARCHAR;
65: 		} else {
66: 			throw new SQLException("Unknown type " + type_name);
67: 		}
68: 	}
69: 
70: 	public int getColumnType(int column) throws SQLException {
71: 		return type_to_int(getColumnTypeName(column));
72: 	}
73: 
74: 	public String getColumnClassName(int column) throws SQLException {
75: 		switch (getColumnType(column)) {
76: 		case Types.BOOLEAN:
77: 			return Boolean.class.toString();
78: 		case Types.TINYINT:
79: 			return Byte.class.toString();
80: 		case Types.SMALLINT:
81: 			return Short.class.toString();
82: 		case Types.INTEGER:
83: 			return Integer.class.toString();
84: 		case Types.BIGINT:
85: 			return Long.class.toString();
86: 		case Types.FLOAT:
87: 			return Float.class.toString();
88: 		case Types.DOUBLE:
89: 			return Double.class.toString();
90: 		case Types.VARCHAR:
91: 			return String.class.toString();
92: 		case Types.TIME:
93: 			return Time.class.toString();
94: 		case Types.DATE:
95: 			return Date.class.toString();
96: 		case Types.TIMESTAMP:
97: 			return Timestamp.class.toString();
98: 		default:
99: 			throw new SQLException("Unknown type " + getColumnTypeName(column));
100: 		}
101: 	}
102: 
103: 	public String getColumnTypeName(int column) throws SQLException {
104: 		if (column > column_count) {
105: 			throw new SQLException("Column index out of bounds");
106: 		}
107: 		return column_types[column - 1];
108: 	}
109: 
110: 	public boolean isReadOnly(int column) throws SQLException {
111: 		return true;
112: 	}
113: 
114: 	public boolean isWritable(int column) throws SQLException {
115: 		return false;
116: 	}
117: 
118: 	public boolean isDefinitelyWritable(int column) throws SQLException {
119: 		return false;
120: 	}
121: 
122: 	public boolean isCaseSensitive(int column) throws SQLException {
123: 		return true;
124: 	}
125: 
126: 	public int isNullable(int column) throws SQLException {
127: 		return columnNullable;
128: 	}
129: 
130: 	public String getSchemaName(int column) throws SQLException {
131: 		return "";
132: 	}
133: 
134: 	public boolean isAutoIncrement(int column) throws SQLException {
135: 		return false;
136: 	}
137: 
138: 	public boolean isSearchable(int column) throws SQLException {
139: 		return true;
140: 	}
141: 
142: 	public boolean isCurrency(int column) throws SQLException {
143: 		return false;
144: 	}
145: 
146: 	public boolean isSigned(int column) throws SQLException {
147: 		return false;
148: 	}
149: 
150: 	public int getColumnDisplaySize(int column) throws SQLException {
151: 		throw new SQLFeatureNotSupportedException();
152: 	}
153: 
154: 	public int getPrecision(int column) throws SQLException {
155: 		return 0;
156: 	}
157: 
158: 	public int getScale(int column) throws SQLException {
159: 		return 0;
160: 	}
161: 
162: 	public String getTableName(int column) throws SQLException {
163: 		return "";
164: 	}
165: 
166: 	public String getCatalogName(int column) throws SQLException {
167: 		return "";
168: 	}
169: 
170: 	public <T> T unwrap(Class<T> iface) throws SQLException {
171: 		throw new SQLFeatureNotSupportedException();
172: 	}
173: 
174: 	public boolean isWrapperFor(Class<?> iface) throws SQLException {
175: 		throw new SQLFeatureNotSupportedException();
176: 	}
177: }
[end of tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: