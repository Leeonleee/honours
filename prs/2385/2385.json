{
  "repo": "duckdb/duckdb",
  "pull_number": 2385,
  "instance_id": "duckdb__duckdb-2385",
  "issue_numbers": [
    "1090"
  ],
  "base_commit": "32a4c9d48b5f2b6fc00746b5653756fef1672683",
  "patch": "diff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp\nindex 19591069cbde..b0cef78fe72c 100644\n--- a/src/common/types/vector.cpp\n+++ b/src/common/types/vector.cpp\n@@ -95,6 +95,11 @@ void Vector::Reference(Vector &other) {\n \tReinterpret(other);\n }\n \n+void Vector::ReferenceAndSetType(Vector &other) {\n+\ttype = other.GetType();\n+\tReference(other);\n+}\n+\n void Vector::Reinterpret(Vector &other) {\n \tvector_type = other.vector_type;\n \tAssignSharedPointer(buffer, other.buffer);\ndiff --git a/src/include/duckdb/common/types/vector.hpp b/src/include/duckdb/common/types/vector.hpp\nindex 80b305a4c820..7acb7ad6e266 100644\n--- a/src/include/duckdb/common/types/vector.hpp\n+++ b/src/include/duckdb/common/types/vector.hpp\n@@ -84,6 +84,9 @@ class Vector {\n \t//! Without changing the type of this vector\n \tvoid Reinterpret(Vector &other);\n \n+\t//! Causes this vector to reference the data held by the other vector, changes the type if required.\n+\tvoid ReferenceAndSetType(Vector &other);\n+\n \t//! Resets a vector from a vector cache.\n \t//! This turns the vector back into an empty FlatVector with STANDARD_VECTOR_SIZE entries.\n \t//! The VectorCache is used so this can be done without requiring any allocations.\ndiff --git a/tools/jdbc/CMakeLists.txt b/tools/jdbc/CMakeLists.txt\nindex 0b8248d8a3ea..f69f69f0a3d3 100644\n--- a/tools/jdbc/CMakeLists.txt\n+++ b/tools/jdbc/CMakeLists.txt\n@@ -19,6 +19,13 @@ add_jar(duckdb_jdbc ${JAVA_SRC_FILES} ${JAVA_TEST_FILES}\n         META-INF/services/java.sql.Driver GENERATE_NATIVE_HEADERS duckdb-native)\n \n set(OS_NAME \"unknown\")\n+set(JVM_ARCH \"amd64\")\n+\n+string(REGEX MATCH \"(arm64|aarch64)\" IS_ARM ${CMAKE_SYSTEM_PROCESSOR})\n+if(IS_ARM)\n+  set(JVM_ARCH \"arm64\")\n+endif()\n+\n if(APPLE)\n   set(OS_NAME \"osx\")\n endif()\n@@ -29,7 +36,6 @@ if(UNIX AND NOT APPLE)\n   set(OS_NAME \"linux\") # sorry BSD\n endif()\n \n-set(JVM_BITNESS \"amd64\")\n # TODO handle 32 bit architectures\n \n include_directories(../../extension/parquet/include)\n@@ -41,7 +47,7 @@ if(OS_NAME STREQUAL \"linux\")\n   target_link_libraries(duckdb_java -static-libgcc -static-libstdc++\n   )# static link to libstdc++ to target more linux distro\n endif()\n-string(JOIN \"_\" LIB_SUFFIX \".so\" ${OS_NAME} ${JVM_BITNESS})\n+string(JOIN \"_\" LIB_SUFFIX \".so\" ${OS_NAME} ${JVM_ARCH})\n set_target_properties(duckdb_java PROPERTIES SUFFIX ${LIB_SUFFIX})\n set_target_properties(duckdb_java PROPERTIES PREFIX \"lib\")\n \ndiff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp\nindex 8c3c5cbf8fec..db397681685d 100644\n--- a/tools/jdbc/src/jni/duckdb_java.cpp\n+++ b/tools/jdbc/src/jni/duckdb_java.cpp\n@@ -23,6 +23,7 @@ static string byte_array_to_string(JNIEnv *env, jbyteArray ba_j) {\n }\n \n static jobject decode_charbuffer_to_jstring(JNIEnv *env, const char *d_str, idx_t d_str_len) {\n+\t// TODO cache this somewhere, probably slow to look this stuff for every string\n \tjclass charset_class = env->FindClass(\"java/nio/charset/Charset\");\n \tjclass charbuffer_class = env->FindClass(\"java/nio/CharBuffer\");\n \tjmethodID for_name =\n@@ -320,7 +321,7 @@ JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(\n \t\tcase LogicalTypeId::DECIMAL: {\n \t\t\tVector double_vec(LogicalType::DOUBLE);\n \t\t\tVectorOperations::Cast(vec, double_vec, row_count);\n-\t\t\tvec.Reference(double_vec);\n+\t\t\tvec.ReferenceAndSetType(double_vec);\n \t\t\t// fall through on purpose\n \t\t}\n \t\tcase LogicalTypeId::DOUBLE:\n@@ -332,7 +333,7 @@ JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(\n \t\tcase LogicalTypeId::INTERVAL: {\n \t\t\tVector string_vec(LogicalType::VARCHAR);\n \t\t\tVectorOperations::Cast(vec, string_vec, row_count);\n-\t\t\tvec.Reference(string_vec);\n+\t\t\tvec.ReferenceAndSetType(string_vec);\n \t\t\t// fall through on purpose\n \t\t}\n \t\tcase LogicalTypeId::VARCHAR:\n@@ -346,6 +347,18 @@ JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(\n \t\t\t\tenv->SetObjectArrayElement(varlen_data, row_idx, j_str);\n \t\t\t}\n \t\t\tbreak;\n+\t\tcase LogicalTypeId::BLOB:\n+\t\t\tvarlen_data = env->NewObjectArray(row_count, env->FindClass(\"java/nio/ByteBuffer\"), nullptr);\n+\n+\t\t\tfor (idx_t row_idx = 0; row_idx < row_count; row_idx++) {\n+\t\t\t\tif (FlatVector::IsNull(vec, row_idx)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tauto &d_str = ((string_t *)FlatVector::GetData(vec))[row_idx];\n+\t\t\t\tauto j_obj = env->NewDirectByteBuffer((void *)d_str.GetDataUnsafe(), d_str.GetSize());\n+\t\t\t\tenv->SetObjectArrayElement(varlen_data, row_idx, j_obj);\n+\t\t\t}\n+\t\t\tbreak;\n \t\tdefault:\n \t\t\tjclass Exception = env->FindClass(\"java/sql/SQLException\");\n \t\t\tenv->ThrowNew(Exception, (\"Unsupported result column type \" + vec.GetType().ToString()).c_str());\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java\nnew file mode 100644\nindex 000000000000..7f328ce734a2\n--- /dev/null\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java\n@@ -0,0 +1,6 @@\n+package org.duckdb;\n+\n+public enum DuckDBColumnType {\n+\tBOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, UTINYINT, USMALLINT, UINTEGER, UBIGINT, HUGEINT, FLOAT, DOUBLE,\n+\tDECIMAL, VARCHAR, BLOB, TIME, DATE, TIMESTAMP, INTERVAL, LIST, STRUCT\n+}\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java\nindex 5f2442c4ba7b..5017f8ef0053 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java\n@@ -667,7 +667,7 @@ public ResultSet getTables(String catalog, String schemaPattern, String tableNam\n \t\t\t\t\ttable_type_str += ',';\n \t\t\t\t}\n \t\t\t}\n-\t\t\ttable_type_str +=  \") AND \";\n+\t\t\ttable_type_str += \") AND \";\n \t\t}\n \t\tif (schemaPattern == null) {\n \t\t\tschemaPattern = \"%\";\n@@ -676,7 +676,9 @@ public ResultSet getTables(String catalog, String schemaPattern, String tableNam\n \t\t\ttableNamePattern = \"%\";\n \t\t}\n \t\tPreparedStatement ps = conn.prepareStatement(\n-\t\t\t\t\"SELECT table_catalog AS 'TABLE_CAT', table_schema AS 'TABLE_SCHEM', table_name AS 'TABLE_NAME', table_type as 'TABLE_TYPE', NULL AS 'REMARKS', NULL AS 'TYPE_CAT', NULL AS 'TYPE_SCHEM', NULL AS 'TYPE_NAME', NULL as 'SELF_REFERENCING_COL_NAME', NULL as 'REF_GENERATION' FROM information_schema.tables WHERE \"+ table_type_str +\" table_schema LIKE ? AND table_name LIKE ? ORDER BY \\\"TABLE_TYPE\\\", \\\"TABLE_CAT\\\", \\\"TABLE_SCHEM\\\", \\\"TABLE_NAME\\\"\");\n+\t\t\t\t\"SELECT table_catalog AS 'TABLE_CAT', table_schema AS 'TABLE_SCHEM', table_name AS 'TABLE_NAME', table_type as 'TABLE_TYPE', NULL AS 'REMARKS', NULL AS 'TYPE_CAT', NULL AS 'TYPE_SCHEM', NULL AS 'TYPE_NAME', NULL as 'SELF_REFERENCING_COL_NAME', NULL as 'REF_GENERATION' FROM information_schema.tables WHERE \"\n+\t\t\t\t\t\t+ table_type_str\n+\t\t\t\t\t\t+ \" table_schema LIKE ? AND table_name LIKE ? ORDER BY \\\"TABLE_TYPE\\\", \\\"TABLE_CAT\\\", \\\"TABLE_SCHEM\\\", \\\"TABLE_NAME\\\"\");\n \t\tps.setString(1, schemaPattern);\n \t\tps.setString(2, tableNamePattern);\n \t\treturn ps.executeQuery();\n@@ -707,8 +709,8 @@ public ResultSet getColumns(String catalog, String schemaPattern, String tableNa\n \t\tResultSet rs = gunky_statement\n \t\t\t\t.executeQuery(\"SELECT DISTINCT data_type FROM information_schema.columns ORDER BY data_type\");\n \t\twhile (rs.next()) {\n-\t\t\tvalues_str += \", ('\" + rs.getString(1) + \"', \"\n-\t\t\t\t\t+ Integer.toString(DuckDBResultSetMetaData.type_to_int(rs.getString(1))) + \")\";\n+\t\t\tvalues_str += \", ('\" + rs.getString(1) + \"', \" + Integer.toString(\n+\t\t\t\t\tDuckDBResultSetMetaData.type_to_int(DuckDBResultSetMetaData.TypeNameToType(rs.getString(1)))) + \")\";\n \t\t}\n \t\trs.close();\n \t\tgunky_statement.close();\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java\nindex d9e085903b4e..fe454109cf69 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java\n@@ -18,6 +18,9 @@ public class DuckDBNative {\n \t\t\tif (os_arch_detect.equals(\"x86_64\") || os_arch_detect.equals(\"amd64\")) {\n \t\t\t\tos_arch = \"amd64\";\n \t\t\t}\n+            if (os_arch_detect.equals(\"aarch64\") || os_arch_detect.equals(\"arm64\")) {\n+                os_arch = \"arm64\";\n+            }\n \t\t\t// TODO 32 bit gunk\n \n \t\t\tif (os_name_detect.startsWith(\"windows\")) {\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java\nindex c46c8f58dd09..d181c4102e24 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java\n@@ -1,12 +1,12 @@\n package org.duckdb;\n \n+import java.io.IOException;\n import java.io.InputStream;\n+import java.io.OutputStream;\n import java.io.Reader;\n-import java.io.UnsupportedEncodingException;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.net.URL;\n-import java.nio.Buffer;\n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n import java.sql.Array;\n@@ -115,44 +115,46 @@ public Object getObject(int columnIndex) throws SQLException {\n \t\tif (was_null) {\n \t\t\treturn null;\n \t\t}\n-\t\tString column_type = meta.column_types[columnIndex - 1];\n-\t\tif (column_type.equals(\"BOOLEAN\")) {\n+\t\tswitch (meta.column_types[columnIndex - 1]) {\n+\t\tcase BOOLEAN:\n \t\t\treturn getBoolean(columnIndex);\n-\t\t} else if (column_type.equals(\"TINYINT\")) {\n+\t\tcase TINYINT:\n \t\t\treturn getByte(columnIndex);\n-\t\t} else if (column_type.equals(\"SMALLINT\")) {\n+\t\tcase SMALLINT:\n \t\t\treturn getShort(columnIndex);\n-\t\t} else if (column_type.equals(\"INTEGER\")) {\n+\t\tcase INTEGER:\n \t\t\treturn getInt(columnIndex);\n-\t\t} else if (column_type.equals(\"BIGINT\")) {\n+\t\tcase BIGINT:\n \t\t\treturn getLong(columnIndex);\n-\t\t}else if (column_type.equals(\"UTINYINT\")) {\n-\t\t\treturn getShort(columnIndex);\n-\t\t} else if (column_type.equals(\"USMALLINT\")) {\n-\t\t\treturn getInt(columnIndex);\n-\t\t} else if (column_type.equals(\"UINTEGER\")) {\n-\t\t\treturn getLong(columnIndex);\n-\t\t} else if (column_type.equals(\"UBIGINT\")) {\n-\t\t\treturn getHugeint(columnIndex);\n-\t\t} else if (column_type.equals(\"HUGEINT\")) {\n+\t\tcase HUGEINT:\n \t\t\treturn getHugeint(columnIndex);\n-\t\t} else if (column_type.equals(\"FLOAT\")) {\n+\t\tcase UTINYINT:\n+\t\t\treturn getUint8(columnIndex);\n+\t\tcase USMALLINT:\n+\t\t\treturn getUint16(columnIndex);\n+\t\tcase UINTEGER:\n+\t\t\treturn getUint32(columnIndex);\n+\t\tcase UBIGINT:\n+\t\t\treturn getUint64(columnIndex);\n+\t\tcase FLOAT:\n \t\t\treturn getFloat(columnIndex);\n-\t\t} else if (column_type.equals(\"DOUBLE\") || column_type.startsWith(\"DECIMAL\")) {\n+\t\tcase DOUBLE:\n+\t\tcase DECIMAL:\n \t\t\treturn getDouble(columnIndex);\n-\t\t} else if (column_type.equals(\"VARCHAR\")) {\n+\t\tcase VARCHAR:\n \t\t\treturn getString(columnIndex);\n-\t\t} else if (column_type.equals(\"TIME\")) {\n+\t\tcase TIME:\n \t\t\treturn getTime(columnIndex);\n-\t\t} else if (column_type.equals(\"DATE\")) {\n+\t\tcase DATE:\n \t\t\treturn getDate(columnIndex);\n-\t\t} else if (column_type.equals(\"TIMESTAMP\")) {\n+\t\tcase TIMESTAMP:\n \t\t\treturn getTimestamp(columnIndex);\n-\t\t} else if (column_type.equals(\"INTERVAL\")) {\n+\t\tcase INTERVAL:\n \t\t\treturn getLazyString(columnIndex);\n-\t\t} else {\n-\t\t\tthrow new SQLException(\"Not implemented type: \" + meta.column_types[columnIndex - 1]);\n+\t\tdefault:\n+\t\t\tthrow new SQLException(\"Not implemented type: \" + meta.column_types_string[columnIndex - 1]);\n \t\t}\n+\n \t}\n \n \tpublic boolean wasNull() throws SQLException {\n@@ -175,12 +177,16 @@ public String getLazyString(int columnIndex) throws SQLException {\n \t\treturn (String) current_chunk[columnIndex - 1].varlen_data[chunk_idx - 1];\n \t}\n \n+\tprivate boolean isType(int columnIndex, DuckDBColumnType type) {\n+\t\treturn meta.column_types[columnIndex - 1] == type;\n+\t}\n+\n \tpublic String getString(int columnIndex) throws SQLException {\n \t\tif (check_and_null(columnIndex)) {\n \t\t\treturn null;\n \t\t}\n \n-\t\tif (\"VARCHAR\".equals(meta.column_types[columnIndex - 1])) {\n+\t\tif (isType(columnIndex, DuckDBColumnType.VARCHAR)) {\n \t\t\treturn (String) current_chunk[columnIndex - 1].varlen_data[chunk_idx - 1];\n \t\t}\n \t\tObject res = getObject(columnIndex);\n@@ -194,7 +200,7 @@ public String getString(int columnIndex) throws SQLException {\n \tprivate ByteBuffer getbuf(int columnIndex, int typeWidth) throws SQLException {\n \t\tByteBuffer buf = current_chunk[columnIndex - 1].constlen_data;\n \t\tbuf.order(ByteOrder.LITTLE_ENDIAN);\n-\t\t((Buffer) buf).position((chunk_idx - 1) * typeWidth);\n+\t\tbuf.position((chunk_idx - 1) * typeWidth);\n \t\treturn buf;\n \t}\n \n@@ -202,7 +208,7 @@ public boolean getBoolean(int columnIndex) throws SQLException {\n \t\tif (check_and_null(columnIndex)) {\n \t\t\treturn false;\n \t\t}\n-\t\tif (\"BOOLEAN\".equals(meta.column_types[columnIndex - 1])) {\n+\t\tif (isType(columnIndex, DuckDBColumnType.BOOLEAN)) {\n \t\t\treturn getbuf(columnIndex, 1).get() == 1;\n \t\t}\n \t\tObject o = getObject(columnIndex);\n@@ -217,7 +223,7 @@ public byte getByte(int columnIndex) throws SQLException {\n \t\tif (check_and_null(columnIndex)) {\n \t\t\treturn 0;\n \t\t}\n-\t\tif (\"TINYINT\".equals(meta.column_types[columnIndex - 1])) {\n+\t\tif (isType(columnIndex, DuckDBColumnType.TINYINT)) {\n \t\t\treturn getbuf(columnIndex, 1).get();\n \t\t}\n \t\tObject o = getObject(columnIndex);\n@@ -231,17 +237,9 @@ public short getShort(int columnIndex) throws SQLException {\n \t\tif (check_and_null(columnIndex)) {\n \t\t\treturn 0;\n \t\t}\n-\t\tif (\"SMALLINT\".equals(meta.column_types[columnIndex - 1])) {\n+\t\tif (isType(columnIndex, DuckDBColumnType.SMALLINT)) {\n \t\t\treturn getbuf(columnIndex, 2).getShort();\n \t\t}\n-\t\telse if (\"UTINYINT\".equals(meta.column_types[columnIndex - 1])){\n-\t\t\tbyte[] buf_res = new byte[2];\n-\t\t\tbyte[] buf = new byte[1];\n-\t\t\tgetbuf(columnIndex, 1).get(buf);\n-\t\t\tbuf_res[1] = buf[0];\n-\t\t\tByteBuffer bb = ByteBuffer.wrap(buf_res);\n-\t\t\treturn bb.getShort();\n-\t\t}\n \t\tObject o = getObject(columnIndex);\n \t\tif (o instanceof Number) {\n \t\t\treturn ((Number) o).shortValue();\n@@ -253,18 +251,9 @@ public int getInt(int columnIndex) throws SQLException {\n \t\tif (check_and_null(columnIndex)) {\n \t\t\treturn 0;\n \t\t}\n-\t\tif (\"INTEGER\".equals(meta.column_types[columnIndex - 1])) {\n+\t\tif (isType(columnIndex, DuckDBColumnType.INTEGER)) {\n \t\t\treturn getbuf(columnIndex, 4).getInt();\n \t\t}\n-\t\telse if (\"USMALLINT\".equals(meta.column_types[columnIndex - 1])){\n-\t\t\tbyte[] buf_res = new byte[4];\n-\t\t\tbyte[] buf = new byte[2];\n-\t\t\tgetbuf(columnIndex, 2).get(buf);\n-\t\t\tbuf_res[2] = buf[0];\n-\t\t\tbuf_res[3] = buf[1];\n-\t\t\tByteBuffer bb = ByteBuffer.wrap(buf_res);\n-\t\t\treturn bb.getInt();\n-\t\t}\n \t\tObject o = getObject(columnIndex);\n \t\tif (o instanceof Number) {\n \t\t\treturn ((Number) o).intValue();\n@@ -272,24 +261,68 @@ else if (\"USMALLINT\".equals(meta.column_types[columnIndex - 1])){\n \t\treturn Integer.parseInt(o.toString());\n \t}\n \n-\tpublic long getLong(int columnIndex) throws SQLException {\n+\tprivate short getUint8(int columnIndex) throws SQLException {\n \t\tif (check_and_null(columnIndex)) {\n \t\t\treturn 0;\n \t\t}\n-\t\tif (\"BIGINT\".equals(meta.column_types[columnIndex - 1])) {\n-\t\t\treturn getbuf(columnIndex, 8).getLong();\n+\t\tif (isType(columnIndex, DuckDBColumnType.UTINYINT)) {\n+\t\t\tByteBuffer buf = ByteBuffer.allocate(2);\n+\t\t\tgetbuf(columnIndex, 1).get(buf.array(), 1, 1);\n+\t\t\treturn buf.getShort();\n+\n+\t\t}\n+\t\tthrow new SQLFeatureNotSupportedException();\n+\t}\n+\n+\tprivate int getUint16(int columnIndex) throws SQLException {\n+\t\tif (check_and_null(columnIndex)) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tif (isType(columnIndex, DuckDBColumnType.USMALLINT)) {\n+\t\t\tByteBuffer buf = ByteBuffer.allocate(4);\n+\t\t\tbuf.order(ByteOrder.LITTLE_ENDIAN);\n+\t\t\tgetbuf(columnIndex, 2).get(buf.array(), 0, 2);\n+\t\t\treturn buf.getInt();\n+\t\t}\n+\t\tthrow new SQLFeatureNotSupportedException();\n+\n+\t}\n+\n+\tprivate long getUint32(int columnIndex) throws SQLException {\n+\t\tif (check_and_null(columnIndex)) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tif (isType(columnIndex, DuckDBColumnType.UINTEGER)) {\n+\t\t\tByteBuffer buf = ByteBuffer.allocate(8);\n+\t\t\tbuf.order(ByteOrder.LITTLE_ENDIAN);\n+\t\t\tgetbuf(columnIndex, 4).get(buf.array(), 0, 4);\n+\t\t\treturn buf.getLong();\n+\t\t}\n+\t\tthrow new SQLFeatureNotSupportedException();\n+\t}\n+\n+\tprivate BigInteger getUint64(int columnIndex) throws SQLException {\n+\t\tif (check_and_null(columnIndex)) {\n+\t\t\treturn BigInteger.ZERO;\n \t\t}\n-\t\telse if( \"UINTEGER\".equals(meta.column_types[columnIndex - 1])){\n-\t\t\tbyte[] buf_res = new byte[8];\n-\t\t\tbyte[] buf = new byte[4];\n-\t\t\tgetbuf(columnIndex, 4).get(buf);\n-\t\t\tbuf_res[4] = buf[0];\n-\t\t\tbuf_res[5] = buf[1];\n-\t\t\tbuf_res[6] = buf[2];\n-\t\t\tbuf_res[7] = buf[3];\n+\t\tif (isType(columnIndex, DuckDBColumnType.UBIGINT)) {\n+\t\t\tbyte[] buf_res = new byte[16];\n+\t\t\tbyte[] buf = new byte[8];\n+\t\t\tgetbuf(columnIndex, 8).get(buf);\n+\t\t\tfor (int i = 0; i < 8; i++) {\n+\t\t\t\tbuf_res[i + 8] = buf[7 - i];\n+\t\t\t}\n+\t\t\treturn new BigInteger(buf_res);\n+\t\t}\n+\t\tthrow new SQLFeatureNotSupportedException();\n+\t}\n \n-\t\t\tByteBuffer bb = ByteBuffer.wrap(buf_res);\n-\t\t\treturn bb.getLong();\n+\tpublic long getLong(int columnIndex) throws SQLException {\n+\t\tif (check_and_null(columnIndex)) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tif (isType(columnIndex, DuckDBColumnType.BIGINT)) {\n+\t\t\treturn getbuf(columnIndex, 8).getLong();\n \t\t}\n \t\tObject o = getObject(columnIndex);\n \t\tif (o instanceof Number) {\n@@ -302,10 +335,9 @@ public BigInteger getHugeint(int columnIndex) throws SQLException {\n \t\tif (check_and_null(columnIndex)) {\n \t\t\treturn BigInteger.ZERO;\n \t\t}\n-\t\tif (\"HUGEINT\".equals(meta.column_types[columnIndex - 1])) {\n+\t\tif (isType(columnIndex, DuckDBColumnType.HUGEINT)) {\n \t\t\tbyte[] buf = new byte[16];\n \t\t\tgetbuf(columnIndex, 16).get(buf);\n-\n \t\t\tfor (int i = 0; i < 8; i++) {\n \t\t\t\tbyte keep = buf[i];\n \t\t\t\tbuf[i] = buf[15 - i];\n@@ -313,20 +345,6 @@ public BigInteger getHugeint(int columnIndex) throws SQLException {\n \t\t\t}\n \t\t\treturn new BigInteger(buf);\n \t\t}\n-\t\telse if (\"UBIGINT\".equals(meta.column_types[columnIndex - 1])) {\n-\t\t\tbyte[] buf_res = new byte[16];\n-\t\t\tbyte[] buf = new byte[8];\n-\t\t\tgetbuf(columnIndex, 8).get(buf);\n-\t\t\tbuf_res[8] = buf[0];\n-\t\t\tbuf_res[9] = buf[1];\n-\t\t\tbuf_res[10] = buf[2];\n-\t\t\tbuf_res[11] = buf[3];\n-\t\t\tbuf_res[12] = buf[4];\n-\t\t\tbuf_res[13] = buf[5];\n-\t\t\tbuf_res[14] = buf[6];\n-\t\t\tbuf_res[15] = buf[7];\n-\t\t\treturn new BigInteger(buf_res);\n-\t\t}\n \t\tObject o = getObject(columnIndex);\n \t\treturn new BigInteger(o.toString());\n \t}\n@@ -335,7 +353,7 @@ public float getFloat(int columnIndex) throws SQLException {\n \t\tif (check_and_null(columnIndex)) {\n \t\t\treturn Float.NaN;\n \t\t}\n-\t\tif (\"FLOAT\".equals(meta.column_types[columnIndex - 1])) {\n+\t\tif (isType(columnIndex, DuckDBColumnType.FLOAT)) {\n \t\t\treturn getbuf(columnIndex, 4).getFloat();\n \t\t}\n \t\tObject o = getObject(columnIndex);\n@@ -349,8 +367,7 @@ public double getDouble(int columnIndex) throws SQLException {\n \t\tif (check_and_null(columnIndex)) {\n \t\t\treturn Double.NaN;\n \t\t}\n-\t\tString col_type_str = meta.column_types[columnIndex - 1];\n-\t\tif (col_type_str.equals(\"DOUBLE\") || col_type_str.startsWith(\"DECIMAL\")) {\n+\t\tif (isType(columnIndex, DuckDBColumnType.DOUBLE) || isType(columnIndex, DuckDBColumnType.DECIMAL)) {\n \t\t\treturn getbuf(columnIndex, 8).getDouble();\n \t\t}\n \t\tObject o = getObject(columnIndex);\n@@ -454,6 +471,108 @@ public Timestamp getTimestamp(int columnIndex) throws SQLException {\n \t\t}\n \t}\n \n+\tstatic class DuckDBBlobResult implements Blob {\n+\n+\t\tstatic class ByteBufferBackedInputStream extends InputStream {\n+\n+\t\t\tByteBuffer buf;\n+\n+\t\t\tpublic ByteBufferBackedInputStream(ByteBuffer buf) {\n+\t\t\t\tthis.buf = buf;\n+\t\t\t}\n+\n+\t\t\tpublic int read() throws IOException {\n+\t\t\t\tif (!buf.hasRemaining()) {\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t\treturn buf.get() & 0xFF;\n+\t\t\t}\n+\n+\t\t\tpublic int read(byte[] bytes, int off, int len) throws IOException {\n+\t\t\t\tif (!buf.hasRemaining()) {\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\n+\t\t\t\tlen = Math.min(len, buf.remaining());\n+\t\t\t\tbuf.get(bytes, off, len);\n+\t\t\t\treturn len;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic DuckDBBlobResult(ByteBuffer buffer_p) {\n+\t\t\tbuffer_p.position(0);\n+\t\t\tbuffer_p.order(ByteOrder.LITTLE_ENDIAN);\n+\t\t\tthis.buffer = buffer_p;\n+\t\t}\n+\n+\t\tpublic InputStream getBinaryStream() {\n+\t\t\treturn getBinaryStream(0, length());\n+\t\t}\n+\n+\t\tpublic InputStream getBinaryStream(long pos, long length) {\n+\t\t\treturn new ByteBufferBackedInputStream(buffer);\n+\t\t}\n+\n+\t\tpublic byte[] getBytes(long pos, int length) {\n+\t\t\tbyte[] bytes = new byte[length];\n+\t\t\tbuffer.position((int) pos);\n+\t\t\tbuffer.get(bytes, 0, length);\n+\t\t\treturn bytes;\n+\t\t}\n+\n+\t\tpublic long position(Blob pattern, long start) throws SQLException {\n+\t\t\tthrow new SQLFeatureNotSupportedException();\n+\t\t}\n+\n+\t\tpublic long position(byte[] pattern, long start) throws SQLException {\n+\t\t\tthrow new SQLFeatureNotSupportedException();\n+\t\t}\n+\n+\t\tpublic long length() {\n+\t\t\treturn buffer.capacity();\n+\t\t}\n+\n+\t\tpublic void free() {\n+\t\t\t// nop\n+\t\t}\n+\n+\t\tpublic OutputStream setBinaryStream(long pos) throws SQLException {\n+\t\t\tthrow new SQLFeatureNotSupportedException();\n+\t\t}\n+\n+\t\tpublic void truncate(long length) throws SQLException {\n+\t\t\tthrow new SQLFeatureNotSupportedException();\n+\t\t}\n+\n+\t\tpublic int setBytes(long pos, byte[] bytes) throws SQLException {\n+\t\t\tthrow new SQLFeatureNotSupportedException();\n+\n+\t\t}\n+\n+\t\tpublic int setBytes(long pos, byte[] bytes, int offset, int len) throws SQLException {\n+\t\t\tthrow new SQLFeatureNotSupportedException();\n+\n+\t\t}\n+\n+\t\tprivate ByteBuffer buffer;\n+\n+\t}\n+\n+\tpublic Blob getBlob(int columnIndex) throws SQLException {\n+\t\tif (check_and_null(columnIndex)) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tif (isType(columnIndex, DuckDBColumnType.BLOB)) {\n+\t\t\treturn new DuckDBBlobResult(((ByteBuffer[]) current_chunk[columnIndex - 1].varlen_data)[chunk_idx - 1]);\n+\t\t}\n+\n+\t\tthrow new SQLFeatureNotSupportedException();\n+\t}\n+\n+\tpublic Blob getBlob(String columnLabel) throws SQLException {\n+\t\treturn getBlob(findColumn(columnLabel));\n+\t}\n+\n \tpublic InputStream getAsciiStream(int columnIndex) throws SQLException {\n \t\tthrow new SQLFeatureNotSupportedException();\n \t}\n@@ -803,10 +922,6 @@ public Ref getRef(int columnIndex) throws SQLException {\n \t\tthrow new SQLFeatureNotSupportedException();\n \t}\n \n-\tpublic Blob getBlob(int columnIndex) throws SQLException {\n-\t\tthrow new SQLFeatureNotSupportedException();\n-\t}\n-\n \tpublic Clob getClob(int columnIndex) throws SQLException {\n \t\tthrow new SQLFeatureNotSupportedException();\n \t}\n@@ -823,10 +938,6 @@ public Ref getRef(String columnLabel) throws SQLException {\n \t\tthrow new SQLFeatureNotSupportedException();\n \t}\n \n-\tpublic Blob getBlob(String columnLabel) throws SQLException {\n-\t\tthrow new SQLFeatureNotSupportedException();\n-\t}\n-\n \tpublic Clob getClob(String columnLabel) throws SQLException {\n \t\tthrow new SQLFeatureNotSupportedException();\n \t}\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\nindex 56a25f55f1aa..02c6846fedae 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\n@@ -7,20 +7,40 @@\n import java.sql.Time;\n import java.sql.Timestamp;\n import java.sql.Types;\n+import java.util.ArrayList;\n+\n+import org.duckdb.DuckDBResultSet.DuckDBBlobResult;\n \n public class DuckDBResultSetMetaData implements ResultSetMetaData {\n \n-\tpublic DuckDBResultSetMetaData(int param_count, int column_count, String[] column_names, String[] column_types) {\n+\tpublic DuckDBResultSetMetaData(int param_count, int column_count, String[] column_names,\n+\t\t\tString[] column_types_string) {\n \t\tthis.param_count = param_count;\n \t\tthis.column_count = column_count;\n \t\tthis.column_names = column_names;\n-\t\tthis.column_types = column_types;\n+\t\tthis.column_types_string = column_types_string;\n+\t\tArrayList<DuckDBColumnType> column_types_al = new ArrayList<DuckDBColumnType>(column_count);\n+\n+\t\tfor (String column_type_string : this.column_types_string) {\n+\t\t\tcolumn_types_al.add(TypeNameToType(column_type_string));\n+\t\t}\n+\t\tthis.column_types = new DuckDBColumnType[column_count];\n+\t\tthis.column_types = column_types_al.toArray(this.column_types);\n+\t}\n+\n+\tpublic static DuckDBColumnType TypeNameToType(String type_name) {\n+\t\tif (type_name.startsWith(\"DECIMAL\")) {\n+\t\t\treturn DuckDBColumnType.DECIMAL;\n+\t\t} else {\n+\t\t\treturn DuckDBColumnType.valueOf(type_name);\n+\t\t}\n \t}\n \n \tprotected int param_count;\n \tprotected int column_count;\n \tprotected String[] column_names;\n-\tprotected String[] column_types;\n+\tprotected String[] column_types_string;\n+\tprotected DuckDBColumnType[] column_types;\n \n \tpublic int getColumnCount() throws SQLException {\n \t\treturn column_count;\n@@ -37,38 +57,57 @@ public String getColumnName(int column) throws SQLException {\n \t\treturn column_names[column - 1];\n \t}\n \n-\tpublic static int type_to_int(String type_name) throws SQLException {\n-\t\tif (type_name.equals(\"BOOLEAN\")) {\n+\tpublic static int type_to_int(DuckDBColumnType type) throws SQLException {\n+\t\tswitch (type) {\n+\t\tcase BOOLEAN:\n \t\t\treturn Types.BOOLEAN;\n-\t\t} else if (type_name.equals(\"TINYINT\")) {\n+\t\tcase TINYINT:\n \t\t\treturn Types.TINYINT;\n-\t\t} else if (type_name.equals(\"SMALLINT\")) {\n+\t\tcase SMALLINT:\n \t\t\treturn Types.SMALLINT;\n-\t\t} else if (type_name.equals(\"INTEGER\")) {\n+\t\tcase INTEGER:\n \t\t\treturn Types.INTEGER;\n-\t\t} else if (type_name.equals(\"BIGINT\")) {\n+\t\tcase BIGINT:\n \t\t\treturn Types.BIGINT;\n-\t\t} else if (type_name.equals(\"FLOAT\")) {\n+\t\tcase HUGEINT:\n+\t\t\treturn Types.JAVA_OBJECT;\n+\t\tcase UTINYINT:\n+\t\t\treturn Types.JAVA_OBJECT;\n+\t\tcase USMALLINT:\n+\t\t\treturn Types.JAVA_OBJECT;\n+\t\tcase UINTEGER:\n+\t\t\treturn Types.JAVA_OBJECT;\n+\t\tcase UBIGINT:\n+\t\t\treturn Types.JAVA_OBJECT;\n+\t\tcase FLOAT:\n \t\t\treturn Types.FLOAT;\n-\t\t} else if (type_name.equals(\"DOUBLE\") || type_name.startsWith(\"DECIMAL\")) {\n+\t\tcase DOUBLE:\n \t\t\treturn Types.DOUBLE;\n-\t\t} else if (type_name.equals(\"VARCHAR\")) {\n+\t\tcase DECIMAL:\n+\t\t\treturn Types.DECIMAL;\n+\t\tcase VARCHAR:\n \t\t\treturn Types.VARCHAR;\n-\t\t} else if (type_name.equals(\"TIME\")) {\n+\t\tcase TIME:\n \t\t\treturn Types.TIME;\n-\t\t} else if (type_name.equals(\"DATE\")) {\n+\t\tcase DATE:\n \t\t\treturn Types.DATE;\n-\t\t} else if (type_name.equals(\"TIMESTAMP\")) {\n+\t\tcase TIMESTAMP:\n \t\t\treturn Types.TIMESTAMP;\n-\t\t} else if (type_name.equals(\"INTERVAL\")) {\n-\t\t\treturn Types.VARCHAR;\n-\t\t} else {\n-\t\t\tthrow new SQLException(\"Unknown type \" + type_name);\n+\t\tcase INTERVAL:\n+\t\t\treturn Types.JAVA_OBJECT;\n+\t\tcase BLOB:\n+\t\t\treturn Types.BLOB;\n+\n+\t\tdefault:\n+\t\t\tthrow new SQLException(\"Unsupported type \" + type.toString());\n \t\t}\n \t}\n \n \tpublic int getColumnType(int column) throws SQLException {\n-\t\treturn type_to_int(getColumnTypeName(column));\n+\t\tif (column > column_count) {\n+\t\t\tthrow new SQLException(\"Column index out of bounds\");\n+\t\t}\n+\t\treturn type_to_int(column_types[column - 1]);\n \t}\n \n \tpublic String getColumnClassName(int column) throws SQLException {\n@@ -95,6 +134,8 @@ public String getColumnClassName(int column) throws SQLException {\n \t\t\treturn Date.class.toString();\n \t\tcase Types.TIMESTAMP:\n \t\t\treturn Timestamp.class.toString();\n+\t\tcase Types.BLOB:\n+\t\t\treturn DuckDBBlobResult.class.toString();\n \t\tdefault:\n \t\t\tthrow new SQLException(\"Unknown type \" + getColumnTypeName(column));\n \t\t}\n@@ -104,7 +145,7 @@ public String getColumnTypeName(int column) throws SQLException {\n \t\tif (column > column_count) {\n \t\t\tthrow new SQLException(\"Column index out of bounds\");\n \t\t}\n-\t\treturn column_types[column - 1];\n+\t\treturn column_types_string[column - 1];\n \t}\n \n \tpublic boolean isReadOnly(int column) throws SQLException {\n",
  "test_patch": "diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex 58a51881e617..eba65110dde8 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -1,11 +1,12 @@\n package org.duckdb.test;\n \n import java.lang.reflect.Method;\n-import java.lang.ArrayIndexOutOfBoundsException;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.sql.Blob;\n import java.sql.Connection;\n import java.sql.DatabaseMetaData;\n import java.sql.Date;\n@@ -14,8 +15,8 @@\n import java.sql.PreparedStatement;\n import java.sql.ResultSet;\n import java.sql.ResultSetMetaData;\n-import java.sql.Statement;\n import java.sql.SQLException;\n+import java.sql.Statement;\n import java.sql.Time;\n import java.sql.Timestamp;\n import java.sql.Types;\n@@ -23,8 +24,8 @@\n \n import org.duckdb.DuckDBAppender;\n import org.duckdb.DuckDBConnection;\n-import org.duckdb.DuckDBDriver;\n import org.duckdb.DuckDBDatabase;\n+import org.duckdb.DuckDBDriver;\n \n public class TestDuckDBJDBC {\n \n@@ -179,22 +180,22 @@ public static void test_result() throws Exception {\n \t\tassertEquals(rs.getInt(1), 42);\n \t\tassertEquals(rs.getString(1), \"42\");\n \t\tassertEquals(rs.getDouble(1), 42.0, 0.001);\n-\t\tassertTrue(rs.getObject(1).equals(new Integer(42)));\n+\t\tassertTrue(rs.getObject(1).equals(42));\n \n \t\tassertEquals(rs.getInt(\"a\"), 42);\n \t\tassertEquals(rs.getString(\"a\"), \"42\");\n \t\tassertEquals(rs.getDouble(\"a\"), 42.0, 0.001);\n-\t\tassertTrue(rs.getObject(\"a\").equals(new Integer(42)));\n+\t\tassertTrue(rs.getObject(\"a\").equals(42));\n \n \t\tassertEquals(rs.getInt(2), 4);\n \t\tassertEquals(rs.getString(2), \"4.2\");\n \t\tassertEquals(rs.getDouble(2), 4.2, 0.001);\n-\t\tassertTrue(rs.getObject(2).equals(new Double(4.2)));\n+\t\tassertTrue(rs.getObject(2).equals(4.2));\n \n \t\tassertEquals(rs.getInt(\"b\"), 4);\n \t\tassertEquals(rs.getString(\"b\"), \"4.2\");\n \t\tassertEquals(rs.getDouble(\"b\"), 4.2, 0.001);\n-\t\tassertTrue(rs.getObject(\"b\").equals(new Double(4.2)));\n+\t\tassertTrue(rs.getObject(\"b\").equals(4.2));\n \n \t\tassertFalse(rs.next());\n \n@@ -993,8 +994,7 @@ public static void test_connect_wrong_url_bug848() throws Exception {\n \tpublic static void test_parquet_reader() throws Exception {\n \t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n \t\tStatement stmt = conn.createStatement();\n-\t\tResultSet rs = stmt\n-\t\t\t\t.executeQuery(\"SELECT COUNT(*) FROM parquet_scan('data/parquet-testing/userdata1.parquet')\");\n+\t\tResultSet rs = stmt.executeQuery(\"SELECT COUNT(*) FROM parquet_scan('data/parquet-testing/userdata1.parquet')\");\n \t\tassertTrue(rs.next());\n \t\tassertEquals(rs.getInt(1), 1000);\n \t\trs.close();\n@@ -1313,6 +1313,80 @@ public static void test_statement_creation_bug1268() throws Exception {\n \t\tconn.close();\n \t}\n \n+\tprivate static String blob_to_string(Blob b) throws SQLException {\n+\t\treturn new String(b.getBytes(0, (int) b.length()), StandardCharsets.US_ASCII);\n+\t}\n+\n+\tpublic static void test_blob_bug1090() throws Exception {\n+\t\tDuckDBConnection conn = (DuckDBConnection) DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\tStatement stmt = conn.createStatement();\n+\n+\t\tString test_str1 = \"asdf\";\n+\t\tString test_str2 = \"asdxxxxxxxxxxxxxxf\";\n+\n+\t\tResultSet rs = stmt\n+\t\t\t\t.executeQuery(\"SELECT '\" + test_str1 + \"'::BLOB a, NULL::BLOB b, '\" + test_str2 + \"'::BLOB c\");\n+\t\tassertTrue(rs.next());\n+\n+\t\tassertTrue(test_str1.equals(blob_to_string(rs.getBlob(1))));\n+\t\tassertTrue(test_str1.equals(blob_to_string(rs.getBlob(\"a\"))));\n+\n+\t\tassertTrue(test_str2.equals(blob_to_string(rs.getBlob(\"c\"))));\n+\n+\t\trs.getBlob(\"a\");\n+\t\tassertFalse(rs.wasNull());\n+\n+\t\trs.getBlob(\"b\");\n+\t\tassertTrue(rs.wasNull());\n+\n+\t\trs.close();\n+\t\tstmt.close();\n+\t\tconn.close();\n+\t}\n+\n+\tpublic static void test_unsiged_integers() throws Exception {\n+\t\tDuckDBConnection conn = (DuckDBConnection) DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\tStatement stmt = conn.createStatement();\n+\n+\t\tResultSet rs = stmt.executeQuery(\n+\t\t\t\t\"SELECT 201::utinyint uint8, 40001::usmallint uint16, 4000000001::uinteger uint32, 18446744073709551615::ubigint uint64\");\n+\t\tassertTrue(rs.next());\n+\n+\t\tassertEquals(rs.getShort(\"uint8\"), Short.valueOf((short) 201));\n+\t\tassertEquals(rs.getObject(\"uint8\"), Short.valueOf((short) 201));\n+\t\tassertEquals(rs.getInt(\"uint8\"), Integer.valueOf((int) 201));\n+\n+\t\tassertEquals(rs.getInt(\"uint16\"), Integer.valueOf((int) 40001));\n+\t\tassertEquals(rs.getObject(\"uint16\"), Integer.valueOf((int) 40001));\n+\t\tassertEquals(rs.getLong(\"uint16\"), Long.valueOf((long) 40001));\n+\n+\t\tassertEquals(rs.getLong(\"uint32\"), Long.valueOf((long) 4000000001L));\n+\t\tassertEquals(rs.getObject(\"uint32\"), Long.valueOf((long) 4000000001L));\n+\n+\t\tassertEquals(rs.getObject(\"uint64\"), new BigInteger(\"18446744073709551615\"));\n+\n+\t\trs.close();\n+\n+\t\trs = stmt.executeQuery(\n+\t\t\t\t\"SELECT NULL::utinyint uint8, NULL::usmallint uint16, NULL::uinteger uint32, NULL::ubigint uint64\");\n+\t\tassertTrue(rs.next());\n+\n+\t\trs.getObject(1);\n+\t\tassertTrue(rs.wasNull());\n+\n+\t\trs.getObject(2);\n+\t\tassertTrue(rs.wasNull());\n+\n+\t\trs.getObject(3);\n+\t\tassertTrue(rs.wasNull());\n+\n+\t\trs.getObject(4);\n+\t\tassertTrue(rs.wasNull());\n+\n+\t\tstmt.close();\n+\t\tconn.close();\n+\t}\n+\n \tpublic static void main(String[] args) throws Exception {\n \t\t// Woo I can do reflection too, take this, JUnit!\n \t\tMethod[] methods = TestDuckDBJDBC.class.getMethods();\n",
  "problem_statement": "JDBC: cannot select BLOB columns\nI have tried to write a SELECT query which mentions a BLOB column, among others. However, I receive the following error:\r\n\r\n```\r\n2020-11-07 15:18:25 [main] ERROR DuckNode - Could not fetch property d on node 1\r\njava.sql.SQLException: Unsupported result column type BLOB\r\n\tat org.duckdb.DuckDBNative.duckdb_jdbc_fetch(Native Method) ~[na:na]\r\n\tat org.duckdb.DuckDBResultSet.<init>(DuckDBResultSet.java:45) ~[na:na]\r\n\tat org.duckdb.DuckDBPreparedStatement.execute(DuckDBPreparedStatement.java:90) ~[na:na]\r\n\tat org.duckdb.DuckDBPreparedStatement.executeQuery(DuckDBPreparedStatement.java:100) ~[na:na]\r\n\tat org.eclipse.hawk.duckdb.DuckNode.getProperty(DuckNode.java:252) ~[na:na]\r\n```\r\n\r\nShould I be casting that column to a VARCHAR instead?\n",
  "hints_text": "This simply has not been implemented yet. We should probably do that.\nI can work around this by doing a cast and decoding with Commons Codec, but yes, it'd be ideal if we could just call `getBlob`.\nhappy to review a PR ^^\n@bluezio how are you working around this, if you can share some pointers.\nNot documented on the site, but found the base64 function which can be used as an workaround for blobs (returned as strings). Here's a quick hint on how to do that (we have some JSON encoded as Smile in a column of the Parquet file).\r\n\r\n```CREATE TABLE inmemory AS SELECT id, base64(data) as payload FROM '/somewhere/to/your/data.gz.parquet'```\r\n\r\nFollowed by commons codec decoding and Smile's readTree:\r\n```\t\t\r\n\t\tString queryStatement = \"SELECT * FROM inmemory LIMIT 10\";\r\n\t\tPreparedStatement preparedQuery = duckConnection.prepareStatement (queryStatement);\r\n\t\tResultSet querySet = preparedQuery.executeQuery ();\r\n\t\tquerySet.next ();\r\n\t\tSmileMapper smileMapper = new SmileMapper ();\r\n\t\tbyte[] asBase64 = org.apache.commons.codec.binary.Base64.decodeBase64 (querySet.getString (\"payload\"));\r\n\t\tJsonNode asJsonNode = smileMapper.readTree (asBase64);\r\n```\r\nProbably for performance reasons the `getBlob` would avoid this Base64 step. Until that's implemented, it's a quirky work-around :)\nGoing to have a go at this ",
  "created_at": "2021-10-08T11:07:20Z"
}