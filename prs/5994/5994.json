{
  "repo": "duckdb/duckdb",
  "pull_number": 5994,
  "instance_id": "duckdb__duckdb-5994",
  "issue_numbers": [
    "5831"
  ],
  "base_commit": "8a8581e2e383326b67cd6a0d2d5bd2a650634839",
  "patch": "diff --git a/tools/rpkg/src/relational.cpp b/tools/rpkg/src/relational.cpp\nindex 5fd48993df78..e16605c4ad9f 100644\n--- a/tools/rpkg/src/relational.cpp\n+++ b/tools/rpkg/src/relational.cpp\n@@ -168,7 +168,7 @@ external_pointer<T> make_external(const string &rclass, ARGS &&... args) {\n \tvector<OrderByNode> res_orders;\n \n \tfor (expr_extptr_t expr : orders) {\n-\t\tres_orders.emplace_back(OrderType::ASCENDING, OrderByNullType::NULLS_FIRST, expr->Copy());\n+\t\tres_orders.emplace_back(OrderType::ASCENDING, OrderByNullType::NULLS_LAST, expr->Copy());\n \t}\n \n \tauto res = std::make_shared<OrderRelation>(rel->rel, std::move(res_orders));\n",
  "test_patch": "diff --git a/tools/rpkg/tests/testthat/test_relational.R b/tools/rpkg/tests/testthat/test_relational.R\nindex f217f208fb73..707c133612fe 100644\n--- a/tools/rpkg/tests/testthat/test_relational.R\n+++ b/tools/rpkg/tests/testthat/test_relational.R\n@@ -121,6 +121,18 @@ test_that(\"we can get the relation object back from an altrep df\", {\n   expect_true(TRUE)\n })\n \n+test_that(\"rel_order() sorts NAs last\", {\n+  test_df <- rel_from_df(con, data.frame(a = c(NA, 1:3)))\n+\n+  orders <- list(expr_reference(\"a\"))\n+\n+  rel <- rel_order(test_df, orders)\n+  rel_df <- rel_to_altrep(rel)\n+  expect_false(df_is_materialized(rel_df))\n+\n+  expected_result <- data.frame(a = c(1:3, NA))\n+  expect_equal(rel_df, expected_result)\n+})\n \n test_that(\"Inner join returns all inner relations\", {\n     dbExecute(con, \"CREATE OR REPLACE MACRO eq(a, b) AS a = b\")\n",
  "problem_statement": "Relational API orders NAs first, how can we order them last?\n### What happens?\n\nIn the relational API, `rel_order()` does the same as `ORDER BY` in SQL -- `NULL`s are ordered first. How can we make them appear last, for compatibility with data frames?\n\n### To Reproduce\n\n``` r\r\nlibrary(duckdb)\r\n#> Loading required package: DBI\r\n\r\ndf <- data.frame(a = c(1:2, NA))\r\n\r\ndplyr::arrange(df, a)\r\n#>    a\r\n#> 1  1\r\n#> 2  2\r\n#> 3 NA\r\n\r\ncon <- dbConnect(duckdb())\r\n\r\nrel <- duckdb:::rel_from_df(con, df)\r\n\r\nexprs <- list(duckdb:::expr_reference(\"a\"))\r\n\r\nout <- duckdb:::rel_order(rel, exprs)\r\nout\r\n#> DuckDB Relation: \r\n#> ---------------------\r\n#> --- Relation Tree ---\r\n#> ---------------------\r\n#> Order [a ASC]\r\n#>   r_dataframe_scan(0x1104eb860)\r\n#> \r\n#> ---------------------\r\n#> -- Result Columns  --\r\n#> ---------------------\r\n#> - a (INTEGER)\r\n\r\nduckdb:::rapi_rel_to_df(out)\r\n#> # A tibble: 3 \u00d7 1\r\n#>       a\r\n#>   <int>\r\n#> 1    NA\r\n#> 2     1\r\n#> 3     2\r\n```\r\n\r\n<sup>Created on 2023-01-05 with [reprex v2.0.2](https://reprex.tidyverse.org)</sup>\n\n### OS:\n\nmacOs aarch64\n\n### DuckDB Version:\n\n2dcdc245566bb9a0fc717bc9d2c3867f911abc6d\n\n### DuckDB Client:\n\nR\n\n### Full Name:\n\nKirill M\u00fcller\n\n### Affiliation:\n\ncynkra GmbH\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "NULLS_LAST instead of NULLS_FIRST [here](https://github.com/duckdb/duckdb/blob/2dcdc245566bb9a0fc717bc9d2c3867f911abc6d/tools/rpkg/src/relational.cpp#L165) ?\nIt should also be possible to specific that  with `PRAGMA default_null_order='NULLS LAST';`\r\nSomething like\r\n`DBI::dbExecute(con, \"PRAGMA default_null_order='NULLS LAST'\")`\r\nBut I imagine it may get overridden by the code that @rsund pointed out\r\n\nThanks. The `PRAGMA` doesn't work, changing the code does.\nGreat - can this be closed?\nWe need a mainline fix that changes https://github.com/duckdb/duckdb/blob/2dcdc245566bb9a0fc717bc9d2c3867f911abc6d/tools/rpkg/src/relational.cpp#L165 .",
  "created_at": "2023-01-25T16:14:04Z"
}