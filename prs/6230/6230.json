{
  "repo": "duckdb/duckdb",
  "pull_number": 6230,
  "instance_id": "duckdb__duckdb-6230",
  "issue_numbers": [
    "6227"
  ],
  "base_commit": "48a0a96bc6d10d29e5867891a0b87e11521fcb11",
  "patch": "diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java\nindex 5731c1ce90f6..bd4758f78be0 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java\n@@ -2,6 +2,9 @@\n \n import javax.sql.rowset.CachedRowSet;\n import javax.sql.rowset.RowSetProvider;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n import java.sql.Connection;\n import java.sql.DatabaseMetaData;\n import java.sql.PreparedStatement;\n@@ -672,41 +675,94 @@ public ResultSet getTableTypes() throws SQLException {\n \t@Override\n \tpublic ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types)\n \t\t\tthrows SQLException {\n-\t\tif (catalog != null && !catalog.isEmpty()) {\n-\t\t\tthrow new SQLException(\"Actual catalog argument is not supported, got \" + catalog);\n-\t\t}\n-\t\tif (schemaPattern == null) {\n-\t\t\tschemaPattern = \"%\";\n-\t\t}\n+\t\tStringWriter stringWriter = new StringWriter();\n+\t\tPrintWriter pw = new PrintWriter(stringWriter);\n+\n+\t\tpw.println(\"SELECT table_catalog AS 'TABLE_CAT'\");\n+\t\tpw.println(\", table_schema AS 'TABLE_SCHEM'\");\n+\t\tpw.println(\", table_name AS 'TABLE_NAME'\");\n+\t\tpw.println(\", table_type AS 'TABLE_TYPE'\");\n+\t\tpw.println(\", NULL::VARCHAR AS 'REMARKS'\");\n+\t\tpw.println(\", NULL::VARCHAR AS 'TYPE_CAT'\");\n+\t\tpw.println(\", NULL::VARCHAR AS 'TYPE_SCHEM'\");\n+\t\tpw.println(\", NULL::VARCHAR AS 'TYPE_NAME'\");\n+\t\tpw.println(\", NULL::VARCHAR AS 'SELF_REFERENCING_COL_NAME'\");\n+\t\tpw.println(\", NULL::VARCHAR AS 'REF_GENERATION'\");\n+\t\tpw.println(\"FROM information_schema.tables\");\n+\n+\t\t// tableNamePattern - a table name pattern; must match the table name as it is stored in the database\n \t\tif (tableNamePattern == null) {\n+\t\t\t// non-standard behavior.\n \t\t\ttableNamePattern = \"%\";\n \t\t}\n-\t\tString table_type_str = \"\";\n+\t\tpw.println(\"WHERE table_name LIKE ?\");\n+\n+\t\t// catalog - a catalog name; must match the catalog name as it is stored in the database; \n+\t\t// \"\" retrieves those without a catalog; \n+\t\t// null means that the catalog name should not be used to narrow the search\n+\t\tboolean hasCatalogParam = false;\n+\t\tif (catalog != null) {\n+\t\t\tpw.print(\"AND table_catalog \");\n+\t\t\tif (catalog.isEmpty()) {\n+\t\t\t\tpw.println(\"IS NULL\");\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tpw.println(\"= ?\");\n+\t\t\t\thasCatalogParam = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// schemaPattern - a schema name pattern; must match the schema name as it is stored in the database; \n+\t\t// \"\" retrieves those without a schema; \n+\t\t// null means that the schema name should not be used to narrow the search\n+\t\tboolean hasSchemaParam = false;\n+\t\tif (schemaPattern != null) {\n+\t\t\tpw.print(\"AND table_schema \");\n+\t\t\tif (schemaPattern.isEmpty()) {\n+\t\t\t\tpw.println(\"IS NULL\");\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tpw.println(\"LIKE ?\");\n+\t\t\t\thasSchemaParam = true;\n+\t\t\t}\n+\t\t}\n+\n \t\tif (types != null && types.length > 0) {\n+\t\t\tpw.print(\"AND table_type IN (\");\n \t\t\tfor (int i = 0; i < types.length; i++) {\n \t\t\t\tif (i > 0) {\n-\t\t\t\t\ttable_type_str += ',';\n+\t\t\t\t\tpw.print(\",\");\n \t\t\t\t}\n-\t\t\t\ttable_type_str += \"?\";\n+\t\t\t\tpw.print(\"?\");\n \t\t\t}\n-\t\t\ttable_type_str = \" AND table_type IN (\" + table_type_str + \")\";\n+\t\t\tpw.println(\")\");\n \t\t}\n-\t\tPreparedStatement ps = conn.prepareStatement(\n-\t\t\t\"SELECT table_catalog AS 'TABLE_CAT', table_schema AS 'TABLE_SCHEM', table_name AS 'TABLE_NAME'\" +\n-\t\t\t\", table_type as 'TABLE_TYPE', NULL AS 'REMARKS', NULL AS 'TYPE_CAT', NULL AS 'TYPE_SCHEM'\" +\n-\t\t\t\", NULL AS 'TYPE_NAME', NULL as 'SELF_REFERENCING_COL_NAME', NULL as 'REF_GENERATION' \" +\n-\t\t\t\"FROM information_schema.tables WHERE table_schema LIKE ? AND table_name LIKE ? \" + table_type_str +\n-\t\t\t\"ORDER BY \\\"TABLE_TYPE\\\", \\\"TABLE_CAT\\\", \\\"TABLE_SCHEM\\\", \\\"TABLE_NAME\\\"\"\n-\t\t);\n-\t\tps.setString(1, schemaPattern);\n-\t\tps.setString(2, tableNamePattern);\n+\n+\t\t// ordered by TABLE_TYPE, TABLE_CAT, TABLE_SCHEM and TABLE_NAME.\n+\t\tpw.println(\"ORDER BY table_type\");\n+\t\tpw.println(\", table_catalog\");\n+\t\tpw.println(\", table_schema\");\n+\t\tpw.println(\", table_name\");\n+\t\t\n+\t\tPreparedStatement ps = conn.prepareStatement(stringWriter.toString());\n+\t\t\n+\t\tint paramOffset = 1;\n+\t\tps.setString(paramOffset++, tableNamePattern);\n+\t\t\n+\t\tif (hasCatalogParam) {\n+\t\t\tps.setString(paramOffset++, catalog);\n+\t\t}\n+\t\tif (hasSchemaParam) {\n+\t\t\tps.setString(paramOffset++, schemaPattern);\n+\t\t}\n+\n \t\tif (types != null && types.length > 0) {\n \t\t\tfor (int i = 0; i < types.length; i++) {\n-\t\t\t  ps.setString(3 + i, types[i]);\n+\t\t\t  ps.setString(paramOffset + i, types[i]);\n \t\t\t}\n \t\t}\n-\t\treturn ps.executeQuery();\n \n+\t\treturn ps.executeQuery();\n \t}\n \n \t@Override\n",
  "test_patch": "diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex a5a4e44c3c9d..03295c378be7 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -1821,6 +1821,96 @@ public static void test_schema_reflection() throws Exception {\n \n \t\tconn.close();\n \t}\n+\t\n+\tpublic static void test_get_tables_with_current_catalog() throws Exception {\n+\t\tResultSet resultSet = null;\n+\t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\tfinal String currentCatalog = conn.getCatalog();\n+\t\tDatabaseMetaData databaseMetaData = conn.getMetaData();\n+\t\t\n+\t\tStatement statement = conn.createStatement();\n+\t\tstatement.execute(\"CREATE TABLE T1(ID INT)\");\n+\t\t// verify that the catalog argument is supported and does not throw\n+\t\ttry {\n+\t\t\tresultSet = databaseMetaData.getTables(currentCatalog, null, \"%\", null);\n+\t\t}\n+\t\tcatch (SQLException ex) {\n+\t\t\tassertFalse(ex.getMessage().startsWith(\"Actual catalog argument is not supported\"));\n+\t\t}\n+\t\tassertTrue(resultSet.next(), \"getTables should return exactly 1 table\");\n+\t\tfinal String returnedCatalog = resultSet.getString(\"TABLE_CAT\");\n+\t\tassertTrue(\n+\t\t\tcurrentCatalog.equals(returnedCatalog), \n+\t\t\tString.format(\"Returned catalog %s should equal current catalog %s\", returnedCatalog, currentCatalog)\n+\t\t);\n+\t\tassertTrue(resultSet.next() == false, \"getTables should return exactly 1 table\");\n+\t\t\n+\t\tresultSet.close();\n+\t}\n+\t\n+\tpublic static void test_get_tables_with_attached_catalog() throws Exception {\n+\t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\tfinal String currentCatalog = conn.getCatalog();\n+\t\tDatabaseMetaData databaseMetaData = conn.getMetaData();\n+\t\tStatement statement = conn.createStatement();\n+\t\t\n+\t\t// create one table in the current catalog\n+\t\tfinal String TABLE_NAME1 = \"T1\";\n+\t\tstatement.execute(String.format(\"CREATE TABLE %s(ID INT)\", TABLE_NAME1));\n+\n+\t\t// create one table in an attached catalog\n+\t\tString returnedCatalog, returnedTableName;\n+\t\tResultSet resultSet = null;\n+\t\tfinal String ATTACHED_CATALOG = \"ATTACHED_CATALOG\";\n+\t\tfinal String TABLE_NAME2 = \"T2\";\n+\t\tstatement.execute(String.format(\"ATTACH '' AS \\\"%s\\\"\", ATTACHED_CATALOG));\n+\t\tstatement.execute(String.format(\"CREATE TABLE %s.%s(ID INT)\", ATTACHED_CATALOG, TABLE_NAME2));\n+\n+\t\t// test if getTables can get tables from the remote catalog.\n+\t\tresultSet = databaseMetaData.getTables(ATTACHED_CATALOG, null, \"%\", null);\n+\t\tassertTrue(resultSet.next(), \"getTables should return exactly 1 table\");\n+\t\treturnedCatalog = resultSet.getString(\"TABLE_CAT\");\n+\t\tassertTrue(\n+\t\t\tATTACHED_CATALOG.equals(returnedCatalog), \n+\t\t\tString.format(\"Returned catalog %s should equal attached catalog %s\", returnedCatalog, ATTACHED_CATALOG)\n+\t\t);\n+\t\tassertTrue(resultSet.next() == false, \"getTables should return exactly 1 table\");\n+\t\tresultSet.close();\n+\t\t\n+\t\t// test if getTables with null catalog returns all tables.\n+\t\tresultSet = databaseMetaData.getTables(null, null, \"%\", null);\n+\t\t\n+\t\tassertTrue(resultSet.next(), \"getTables should return 2 tables, got 0\");\n+\t\t// first table should be ATTACHED_CATALOG.T2\n+\t\treturnedCatalog = resultSet.getString(\"TABLE_CAT\");\n+\t\tassertTrue(\n+\t\t\tATTACHED_CATALOG.equals(returnedCatalog), \n+\t\t\tString.format(\"Returned catalog %s should equal attached catalog %s\", returnedCatalog, ATTACHED_CATALOG)\n+\t\t);\n+\t\treturnedTableName = resultSet.getString(\"TABLE_NAME\");\n+\t\tassertTrue(\n+\t\t\tTABLE_NAME2.equals(returnedTableName), \n+\t\t\tString.format(\"Returned table %s should equal %s\", returnedTableName, TABLE_NAME2)\n+\t\t);\n+\t\t\n+\t\tassertTrue(resultSet.next(), \"getTables should return 2 tables, got 1\");\n+\t\t// second table should be <current catalog>.T1\n+\t\treturnedCatalog = resultSet.getString(\"TABLE_CAT\");\n+\t\tassertTrue(\n+\t\t\tcurrentCatalog.equals(returnedCatalog), \n+\t\t\tString.format(\"Returned catalog %s should equal current catalog %s\", returnedCatalog, currentCatalog)\n+\t\t);\n+\t\treturnedTableName = resultSet.getString(\"TABLE_NAME\");\n+\t\tassertTrue(\n+\t\t\tTABLE_NAME1.equals(returnedTableName), \n+\t\t\tString.format(\"Returned table %s should equal %s\", returnedTableName, TABLE_NAME1)\n+\t\t);\n+\t\t\n+\t\tassertTrue(resultSet.next() == false, \"getTables should return 2 tables, got > 2\");\n+\t\tresultSet.close();\n+\t\tstatement.close();\n+\t\tconn.close();\n+\t}\n \n \tpublic static void test_get_tables_param_binding_for_table_types() throws Exception {\n \t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n",
  "problem_statement": "DuckDBJ: DuckDBDatabaseMetaData.getTables always throws when specifying a catalog argument, whereas DuckDBDatabaseMetaData.getColumns doesn't\n### What happens?\n\n`java.sql.DatabaseMetadata.getTables()` supports a `catalog` argument (https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/DatabaseMetaData.html#getTables(java.lang.String,java.lang.String,java.lang.String,java.lang.String%5B%5D)). However, the implementation in `org.duckdb.DuckDBDatabaseMetaData`  (https://github.com/duckdb/duckdb/blob/master/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabaseMetaData.java#L676) always throws when it is not null or empty:\r\n\r\n```\r\n\t\tif (catalog != null && !catalog.isEmpty()) {\r\n\t\t\tthrow new SQLException(\"Actual catalog argument is not supported, got \" + catalog);\r\n\t\t}        \r\n```\r\n\r\nIt could be that duckdb simply chooses not to support this, but then it is strange (inconsistent) that a method like `org.duckdb.DuckDBDatabaseMetaData.getColumns` handles the catalog argument just like any other argument (i.e. it just uses it to filter and does not throw when not empty or null)\r\n\r\n(BTW there is another issue with getColumns which is related but still different https://github.com/duckdb/duckdb/issues/6225)\r\n\n\n### To Reproduce\n\n\tpublic static void test_get_tables_with_catalog() throws Exception {\r\n\t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\r\n\t\tString catalog = conn.getCatalog();\r\n\t\tDatabaseMetaData databaseMetaData = conn.getMetaData();\r\n\t\ttry {\r\n\t\t\tdatabaseMetaData.getTables(catalog, null, \"%\", null);\r\n\t\t}\r\n\t\tcatch (SQLException ex) {\r\n\t\t\tassertFalse(ex.getMessage().startsWith(\"Actual catalog argument is not supported\"));\r\n\t\t}\r\n\t}\r\n\n\n### OS:\n\nWindows 10 Pro\n\n### DuckDB Version:\n\nv0.6.2-dev2342\n\n### DuckDB Client:\n\nDuckDBJ\n\n### Full Name:\n\nRoland Bouman\n\n### Affiliation:\n\nJust-Bi.nl (an EPAM company) \n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Personally I think it should be possible to pass a catalog to getTables. If not, then applications will have no standard way to know about tables in any attached databases. It would be trivial to implement too with few modifications of the current implementation.\r\n\r\nIt would be cool if someone from duckdb labs could let me know if not supporting the catalog is a design decision. I would be happy to add support if I could get a go-ahead.\r\n\r\nThanks in advance!",
  "created_at": "2023-02-12T19:59:01Z"
}