diff --git a/src/include/duckdb/main/relation/materialized_relation.hpp b/src/include/duckdb/main/relation/materialized_relation.hpp
index 74825fe46e24..2911fae4ee87 100644
--- a/src/include/duckdb/main/relation/materialized_relation.hpp
+++ b/src/include/duckdb/main/relation/materialized_relation.hpp
@@ -17,12 +17,9 @@ class MaterializedRelation : public Relation {
 public:
 	MaterializedRelation(const shared_ptr<ClientContext> &context, unique_ptr<ColumnDataCollection> &&collection,
 	                     vector<string> names, string alias = "materialized");
-	MaterializedRelation(const shared_ptr<ClientContext> &context, const string &values, vector<string> names,
-	                     string alias = "materialized");
-
-	unique_ptr<ColumnDataCollection> collection;
 	vector<ColumnDefinition> columns;
 	string alias;
+	shared_ptr<ColumnDataCollection> collection;
 
 public:
 	const vector<ColumnDefinition> &Columns() override;
diff --git a/src/include/duckdb/parser/tableref/column_data_ref.hpp b/src/include/duckdb/parser/tableref/column_data_ref.hpp
index 300ecf3db803..b6a108e2f8aa 100644
--- a/src/include/duckdb/parser/tableref/column_data_ref.hpp
+++ b/src/include/duckdb/parser/tableref/column_data_ref.hpp
@@ -13,25 +13,26 @@
 #include "duckdb/common/types/column/column_data_collection.hpp"
 
 namespace duckdb {
+
 //! Represents a TableReference to a materialized result
 class ColumnDataRef : public TableRef {
 public:
 	static constexpr const TableReferenceType TYPE = TableReferenceType::COLUMN_DATA;
 
 public:
-	explicit ColumnDataRef(ColumnDataCollection &collection)
-	    : TableRef(TableReferenceType::COLUMN_DATA), collection(collection) {
+	explicit ColumnDataRef(shared_ptr<ColumnDataCollection> collection)
+	    : TableRef(TableReferenceType::COLUMN_DATA), collection(std::move(collection)) {
 	}
-	ColumnDataRef(vector<string> expected_names, optionally_owned_ptr<ColumnDataCollection> collection_p)
-	    : TableRef(TableReferenceType::COLUMN_DATA), collection(std::move(collection_p)),
-	      expected_names(std::move(expected_names)) {
+	ColumnDataRef(shared_ptr<ColumnDataCollection> collection, vector<string> expected_names)
+	    : TableRef(TableReferenceType::COLUMN_DATA), expected_names(std::move(expected_names)),
+	      collection(std::move(collection)) {
 	}
 
 public:
-	//! (optionally owned) materialized column data
-	optionally_owned_ptr<ColumnDataCollection> collection;
 	//! The set of expected names
 	vector<string> expected_names;
+	//! The collection to scan
+	shared_ptr<ColumnDataCollection> collection;
 
 public:
 	string ToString() const override;
@@ -43,4 +44,5 @@ class ColumnDataRef : public TableRef {
 	void Serialize(Serializer &serializer) const override;
 	static unique_ptr<TableRef> Deserialize(Deserializer &source);
 };
+
 } // namespace duckdb
diff --git a/src/include/duckdb/storage/serialization/tableref.json b/src/include/duckdb/storage/serialization/tableref.json
index 9128af8f23a7..90012d0a35ca 100644
--- a/src/include/duckdb/storage/serialization/tableref.json
+++ b/src/include/duckdb/storage/serialization/tableref.json
@@ -170,10 +170,10 @@
       {
         "id": 202,
         "name": "collection",
-        "type": "optionally_owned_ptr<ColumnDataCollection>"
+        "type": "shared_ptr<ColumnDataCollection>"
       }
     ],
-    "constructor": ["expected_names", "collection"]
+    "constructor": ["collection", "expected_names"]
   },
   {
     "class": "PivotRef",
diff --git a/src/main/relation/create_view_relation.cpp b/src/main/relation/create_view_relation.cpp
index 92dcf755c486..b9c80c074511 100644
--- a/src/main/relation/create_view_relation.cpp
+++ b/src/main/relation/create_view_relation.cpp
@@ -9,9 +9,6 @@ CreateViewRelation::CreateViewRelation(shared_ptr<Relation> child_p, string view
                                        bool temporary_p)
     : Relation(child_p->context, RelationType::CREATE_VIEW_RELATION), child(std::move(child_p)),
       view_name(std::move(view_name_p)), replace(replace_p), temporary(temporary_p) {
-	if (child->type == RelationType::MATERIALIZED_RELATION) {
-		throw NotImplementedException("Creating a VIEW from a MaterializedRelation is not supported");
-	}
 	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
@@ -20,9 +17,6 @@ CreateViewRelation::CreateViewRelation(shared_ptr<Relation> child_p, string sche
     : Relation(child_p->context, RelationType::CREATE_VIEW_RELATION), child(std::move(child_p)),
       schema_name(std::move(schema_name_p)), view_name(std::move(view_name_p)), replace(replace_p),
       temporary(temporary_p) {
-	if (child->type == RelationType::MATERIALIZED_RELATION) {
-		throw NotImplementedException("Creating a VIEW from a MaterializedRelation is not supported");
-	}
 	context.GetContext()->TryBindRelation(*this, this->columns);
 }
 
diff --git a/src/main/relation/materialized_relation.cpp b/src/main/relation/materialized_relation.cpp
index 4445240ea3f6..8e17168f0b3a 100644
--- a/src/main/relation/materialized_relation.cpp
+++ b/src/main/relation/materialized_relation.cpp
@@ -12,8 +12,8 @@ namespace duckdb {
 MaterializedRelation::MaterializedRelation(const shared_ptr<ClientContext> &context,
                                            unique_ptr<ColumnDataCollection> &&collection_p, vector<string> names,
                                            string alias_p)
-    : Relation(context, RelationType::MATERIALIZED_RELATION), collection(std::move(collection_p)),
-      alias(std::move(alias_p)) {
+    : Relation(context, RelationType::MATERIALIZED_RELATION), alias(std::move(alias_p)),
+      collection(std::move(collection_p)) {
 	// create constant expressions for the values
 	auto types = collection->Types();
 	D_ASSERT(types.size() == names.size());
@@ -35,7 +35,7 @@ unique_ptr<QueryNode> MaterializedRelation::GetQueryNode() {
 }
 
 unique_ptr<TableRef> MaterializedRelation::GetTableRef() {
-	auto table_ref = make_uniq<ColumnDataRef>(*collection);
+	auto table_ref = make_uniq<ColumnDataRef>(collection);
 	for (auto &col : columns) {
 		table_ref->expected_names.push_back(col.Name());
 	}
diff --git a/src/parser/tableref/column_data_ref.cpp b/src/parser/tableref/column_data_ref.cpp
index e815451dfdb7..dec10e1c295f 100644
--- a/src/parser/tableref/column_data_ref.cpp
+++ b/src/parser/tableref/column_data_ref.cpp
@@ -47,33 +47,7 @@ bool ColumnDataRef::Equals(const TableRef &other_p) const {
 }
 
 unique_ptr<TableRef> ColumnDataRef::Copy() {
-	unique_ptr<ColumnDataRef> result;
-	if (collection.is_owned()) {
-		// This collection is owned, the copy should be self sufficient so it needs a copy
-		auto new_collection = make_uniq<ColumnDataCollection>(*collection);
-
-		DataChunk chunk;
-		collection->InitializeScanChunk(chunk);
-
-		ColumnDataScanState scan_state;
-		collection->InitializeScan(scan_state);
-
-		ColumnDataAppendState append_state;
-		new_collection->InitializeAppend(append_state);
-		while (collection->Scan(scan_state, chunk)) {
-			new_collection->Append(append_state, chunk);
-		}
-#ifdef DEBUG
-		string error_message;
-		if (!ColumnDataCollection::ResultEquals(*collection, *new_collection, error_message, true)) {
-			throw InternalException("Copied ColumnDataCollection was not equal: %s", error_message);
-		}
-#endif
-		result = make_uniq<ColumnDataRef>(expected_names, std::move(new_collection));
-	} else {
-		result = make_uniq<ColumnDataRef>(*collection);
-	}
-	result->expected_names = expected_names;
+	auto result = make_uniq<ColumnDataRef>(collection, expected_names);
 	CopyProperties(*result);
 	return std::move(result);
 }
diff --git a/src/planner/binder/tableref/bind_column_data_ref.cpp b/src/planner/binder/tableref/bind_column_data_ref.cpp
index e6b2c45ef24e..e5587e8b0f3e 100644
--- a/src/planner/binder/tableref/bind_column_data_ref.cpp
+++ b/src/planner/binder/tableref/bind_column_data_ref.cpp
@@ -6,8 +6,9 @@
 namespace duckdb {
 
 unique_ptr<BoundTableRef> Binder::Bind(ColumnDataRef &ref) {
-	auto types = ref.collection->Types();
-	auto result = make_uniq<BoundColumnDataRef>(std::move(ref.collection));
+	auto &collection = *ref.collection;
+	auto types = collection.Types();
+	auto result = make_uniq<BoundColumnDataRef>(collection);
 	result->bind_index = GenerateTableIndex();
 	bind_context.AddGenericBinding(result->bind_index, ref.alias, ref.expected_names, types);
 	return unique_ptr_cast<BoundColumnDataRef, BoundTableRef>(std::move(result));
diff --git a/src/storage/serialization/serialize_tableref.cpp b/src/storage/serialization/serialize_tableref.cpp
index e59594cc66be..6dcfee6e894d 100644
--- a/src/storage/serialization/serialize_tableref.cpp
+++ b/src/storage/serialization/serialize_tableref.cpp
@@ -79,13 +79,13 @@ unique_ptr<TableRef> BaseTableRef::Deserialize(Deserializer &deserializer) {
 void ColumnDataRef::Serialize(Serializer &serializer) const {
 	TableRef::Serialize(serializer);
 	serializer.WritePropertyWithDefault<vector<string>>(200, "expected_names", expected_names);
-	serializer.WritePropertyWithDefault<optionally_owned_ptr<ColumnDataCollection>>(202, "collection", collection);
+	serializer.WritePropertyWithDefault<shared_ptr<ColumnDataCollection>>(202, "collection", collection);
 }
 
 unique_ptr<TableRef> ColumnDataRef::Deserialize(Deserializer &deserializer) {
 	auto expected_names = deserializer.ReadPropertyWithDefault<vector<string>>(200, "expected_names");
-	auto collection = deserializer.ReadPropertyWithDefault<optionally_owned_ptr<ColumnDataCollection>>(202, "collection");
-	auto result = duckdb::unique_ptr<ColumnDataRef>(new ColumnDataRef(std::move(expected_names), std::move(collection)));
+	auto collection = deserializer.ReadPropertyWithDefault<shared_ptr<ColumnDataCollection>>(202, "collection");
+	auto result = duckdb::unique_ptr<ColumnDataRef>(new ColumnDataRef(std::move(collection), std::move(expected_names)));
 	return std::move(result);
 }
 
