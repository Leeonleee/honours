{
  "repo": "duckdb/duckdb",
  "pull_number": 12998,
  "instance_id": "duckdb__duckdb-12998",
  "issue_numbers": [
    "12987"
  ],
  "base_commit": "5d97fdf44e2fbbc557f2d27f97e67b695a24aef3",
  "patch": "diff --git a/src/include/duckdb/main/relation/materialized_relation.hpp b/src/include/duckdb/main/relation/materialized_relation.hpp\nindex 74825fe46e24..2911fae4ee87 100644\n--- a/src/include/duckdb/main/relation/materialized_relation.hpp\n+++ b/src/include/duckdb/main/relation/materialized_relation.hpp\n@@ -17,12 +17,9 @@ class MaterializedRelation : public Relation {\n public:\n \tMaterializedRelation(const shared_ptr<ClientContext> &context, unique_ptr<ColumnDataCollection> &&collection,\n \t                     vector<string> names, string alias = \"materialized\");\n-\tMaterializedRelation(const shared_ptr<ClientContext> &context, const string &values, vector<string> names,\n-\t                     string alias = \"materialized\");\n-\n-\tunique_ptr<ColumnDataCollection> collection;\n \tvector<ColumnDefinition> columns;\n \tstring alias;\n+\tshared_ptr<ColumnDataCollection> collection;\n \n public:\n \tconst vector<ColumnDefinition> &Columns() override;\ndiff --git a/src/include/duckdb/parser/tableref/column_data_ref.hpp b/src/include/duckdb/parser/tableref/column_data_ref.hpp\nindex 300ecf3db803..b6a108e2f8aa 100644\n--- a/src/include/duckdb/parser/tableref/column_data_ref.hpp\n+++ b/src/include/duckdb/parser/tableref/column_data_ref.hpp\n@@ -13,25 +13,26 @@\n #include \"duckdb/common/types/column/column_data_collection.hpp\"\n \n namespace duckdb {\n+\n //! Represents a TableReference to a materialized result\n class ColumnDataRef : public TableRef {\n public:\n \tstatic constexpr const TableReferenceType TYPE = TableReferenceType::COLUMN_DATA;\n \n public:\n-\texplicit ColumnDataRef(ColumnDataCollection &collection)\n-\t    : TableRef(TableReferenceType::COLUMN_DATA), collection(collection) {\n+\texplicit ColumnDataRef(shared_ptr<ColumnDataCollection> collection)\n+\t    : TableRef(TableReferenceType::COLUMN_DATA), collection(std::move(collection)) {\n \t}\n-\tColumnDataRef(vector<string> expected_names, optionally_owned_ptr<ColumnDataCollection> collection_p)\n-\t    : TableRef(TableReferenceType::COLUMN_DATA), collection(std::move(collection_p)),\n-\t      expected_names(std::move(expected_names)) {\n+\tColumnDataRef(shared_ptr<ColumnDataCollection> collection, vector<string> expected_names)\n+\t    : TableRef(TableReferenceType::COLUMN_DATA), expected_names(std::move(expected_names)),\n+\t      collection(std::move(collection)) {\n \t}\n \n public:\n-\t//! (optionally owned) materialized column data\n-\toptionally_owned_ptr<ColumnDataCollection> collection;\n \t//! The set of expected names\n \tvector<string> expected_names;\n+\t//! The collection to scan\n+\tshared_ptr<ColumnDataCollection> collection;\n \n public:\n \tstring ToString() const override;\n@@ -43,4 +44,5 @@ class ColumnDataRef : public TableRef {\n \tvoid Serialize(Serializer &serializer) const override;\n \tstatic unique_ptr<TableRef> Deserialize(Deserializer &source);\n };\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/storage/serialization/tableref.json b/src/include/duckdb/storage/serialization/tableref.json\nindex 9128af8f23a7..90012d0a35ca 100644\n--- a/src/include/duckdb/storage/serialization/tableref.json\n+++ b/src/include/duckdb/storage/serialization/tableref.json\n@@ -170,10 +170,10 @@\n       {\n         \"id\": 202,\n         \"name\": \"collection\",\n-        \"type\": \"optionally_owned_ptr<ColumnDataCollection>\"\n+        \"type\": \"shared_ptr<ColumnDataCollection>\"\n       }\n     ],\n-    \"constructor\": [\"expected_names\", \"collection\"]\n+    \"constructor\": [\"collection\", \"expected_names\"]\n   },\n   {\n     \"class\": \"PivotRef\",\ndiff --git a/src/main/relation/create_view_relation.cpp b/src/main/relation/create_view_relation.cpp\nindex 92dcf755c486..b9c80c074511 100644\n--- a/src/main/relation/create_view_relation.cpp\n+++ b/src/main/relation/create_view_relation.cpp\n@@ -9,9 +9,6 @@ CreateViewRelation::CreateViewRelation(shared_ptr<Relation> child_p, string view\n                                        bool temporary_p)\n     : Relation(child_p->context, RelationType::CREATE_VIEW_RELATION), child(std::move(child_p)),\n       view_name(std::move(view_name_p)), replace(replace_p), temporary(temporary_p) {\n-\tif (child->type == RelationType::MATERIALIZED_RELATION) {\n-\t\tthrow NotImplementedException(\"Creating a VIEW from a MaterializedRelation is not supported\");\n-\t}\n \tcontext.GetContext()->TryBindRelation(*this, this->columns);\n }\n \n@@ -20,9 +17,6 @@ CreateViewRelation::CreateViewRelation(shared_ptr<Relation> child_p, string sche\n     : Relation(child_p->context, RelationType::CREATE_VIEW_RELATION), child(std::move(child_p)),\n       schema_name(std::move(schema_name_p)), view_name(std::move(view_name_p)), replace(replace_p),\n       temporary(temporary_p) {\n-\tif (child->type == RelationType::MATERIALIZED_RELATION) {\n-\t\tthrow NotImplementedException(\"Creating a VIEW from a MaterializedRelation is not supported\");\n-\t}\n \tcontext.GetContext()->TryBindRelation(*this, this->columns);\n }\n \ndiff --git a/src/main/relation/materialized_relation.cpp b/src/main/relation/materialized_relation.cpp\nindex 4445240ea3f6..8e17168f0b3a 100644\n--- a/src/main/relation/materialized_relation.cpp\n+++ b/src/main/relation/materialized_relation.cpp\n@@ -12,8 +12,8 @@ namespace duckdb {\n MaterializedRelation::MaterializedRelation(const shared_ptr<ClientContext> &context,\n                                            unique_ptr<ColumnDataCollection> &&collection_p, vector<string> names,\n                                            string alias_p)\n-    : Relation(context, RelationType::MATERIALIZED_RELATION), collection(std::move(collection_p)),\n-      alias(std::move(alias_p)) {\n+    : Relation(context, RelationType::MATERIALIZED_RELATION), alias(std::move(alias_p)),\n+      collection(std::move(collection_p)) {\n \t// create constant expressions for the values\n \tauto types = collection->Types();\n \tD_ASSERT(types.size() == names.size());\n@@ -35,7 +35,7 @@ unique_ptr<QueryNode> MaterializedRelation::GetQueryNode() {\n }\n \n unique_ptr<TableRef> MaterializedRelation::GetTableRef() {\n-\tauto table_ref = make_uniq<ColumnDataRef>(*collection);\n+\tauto table_ref = make_uniq<ColumnDataRef>(collection);\n \tfor (auto &col : columns) {\n \t\ttable_ref->expected_names.push_back(col.Name());\n \t}\ndiff --git a/src/parser/tableref/column_data_ref.cpp b/src/parser/tableref/column_data_ref.cpp\nindex e815451dfdb7..dec10e1c295f 100644\n--- a/src/parser/tableref/column_data_ref.cpp\n+++ b/src/parser/tableref/column_data_ref.cpp\n@@ -47,33 +47,7 @@ bool ColumnDataRef::Equals(const TableRef &other_p) const {\n }\n \n unique_ptr<TableRef> ColumnDataRef::Copy() {\n-\tunique_ptr<ColumnDataRef> result;\n-\tif (collection.is_owned()) {\n-\t\t// This collection is owned, the copy should be self sufficient so it needs a copy\n-\t\tauto new_collection = make_uniq<ColumnDataCollection>(*collection);\n-\n-\t\tDataChunk chunk;\n-\t\tcollection->InitializeScanChunk(chunk);\n-\n-\t\tColumnDataScanState scan_state;\n-\t\tcollection->InitializeScan(scan_state);\n-\n-\t\tColumnDataAppendState append_state;\n-\t\tnew_collection->InitializeAppend(append_state);\n-\t\twhile (collection->Scan(scan_state, chunk)) {\n-\t\t\tnew_collection->Append(append_state, chunk);\n-\t\t}\n-#ifdef DEBUG\n-\t\tstring error_message;\n-\t\tif (!ColumnDataCollection::ResultEquals(*collection, *new_collection, error_message, true)) {\n-\t\t\tthrow InternalException(\"Copied ColumnDataCollection was not equal: %s\", error_message);\n-\t\t}\n-#endif\n-\t\tresult = make_uniq<ColumnDataRef>(expected_names, std::move(new_collection));\n-\t} else {\n-\t\tresult = make_uniq<ColumnDataRef>(*collection);\n-\t}\n-\tresult->expected_names = expected_names;\n+\tauto result = make_uniq<ColumnDataRef>(collection, expected_names);\n \tCopyProperties(*result);\n \treturn std::move(result);\n }\ndiff --git a/src/planner/binder/tableref/bind_column_data_ref.cpp b/src/planner/binder/tableref/bind_column_data_ref.cpp\nindex e6b2c45ef24e..e5587e8b0f3e 100644\n--- a/src/planner/binder/tableref/bind_column_data_ref.cpp\n+++ b/src/planner/binder/tableref/bind_column_data_ref.cpp\n@@ -6,8 +6,9 @@\n namespace duckdb {\n \n unique_ptr<BoundTableRef> Binder::Bind(ColumnDataRef &ref) {\n-\tauto types = ref.collection->Types();\n-\tauto result = make_uniq<BoundColumnDataRef>(std::move(ref.collection));\n+\tauto &collection = *ref.collection;\n+\tauto types = collection.Types();\n+\tauto result = make_uniq<BoundColumnDataRef>(collection);\n \tresult->bind_index = GenerateTableIndex();\n \tbind_context.AddGenericBinding(result->bind_index, ref.alias, ref.expected_names, types);\n \treturn unique_ptr_cast<BoundColumnDataRef, BoundTableRef>(std::move(result));\ndiff --git a/src/storage/serialization/serialize_tableref.cpp b/src/storage/serialization/serialize_tableref.cpp\nindex e59594cc66be..6dcfee6e894d 100644\n--- a/src/storage/serialization/serialize_tableref.cpp\n+++ b/src/storage/serialization/serialize_tableref.cpp\n@@ -79,13 +79,13 @@ unique_ptr<TableRef> BaseTableRef::Deserialize(Deserializer &deserializer) {\n void ColumnDataRef::Serialize(Serializer &serializer) const {\n \tTableRef::Serialize(serializer);\n \tserializer.WritePropertyWithDefault<vector<string>>(200, \"expected_names\", expected_names);\n-\tserializer.WritePropertyWithDefault<optionally_owned_ptr<ColumnDataCollection>>(202, \"collection\", collection);\n+\tserializer.WritePropertyWithDefault<shared_ptr<ColumnDataCollection>>(202, \"collection\", collection);\n }\n \n unique_ptr<TableRef> ColumnDataRef::Deserialize(Deserializer &deserializer) {\n \tauto expected_names = deserializer.ReadPropertyWithDefault<vector<string>>(200, \"expected_names\");\n-\tauto collection = deserializer.ReadPropertyWithDefault<optionally_owned_ptr<ColumnDataCollection>>(202, \"collection\");\n-\tauto result = duckdb::unique_ptr<ColumnDataRef>(new ColumnDataRef(std::move(expected_names), std::move(collection)));\n+\tauto collection = deserializer.ReadPropertyWithDefault<shared_ptr<ColumnDataCollection>>(202, \"collection\");\n+\tauto result = duckdb::unique_ptr<ColumnDataRef>(new ColumnDataRef(std::move(collection), std::move(expected_names)));\n \treturn std::move(result);\n }\n \n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_relation.py b/tools/pythonpkg/tests/fast/test_relation.py\nindex b6e1cc9591d0..ec45b00d3357 100644\n--- a/tools/pythonpkg/tests/fast/test_relation.py\n+++ b/tools/pythonpkg/tests/fast/test_relation.py\n@@ -7,11 +7,18 @@\n import pytest\n from conftest import ArrowPandas, NumpyPandas\n import datetime\n+import gc\n from duckdb import ColumnExpression\n \n from duckdb.typing import BIGINT, VARCHAR, TINYINT, BOOLEAN\n \n \n+@pytest.fixture(scope=\"session\")\n+def tmp_database(tmp_path_factory):\n+    database = tmp_path_factory.mktemp(\"databases\", numbered=True) / \"tmp.duckdb\"\n+    return database\n+\n+\n def get_relation(conn):\n     test_df = pd.DataFrame.from_dict({\"i\": [1, 2, 3, 4], \"j\": [\"one\", \"two\", \"three\", \"four\"]})\n     conn.register(\"test_df\", test_df)\n@@ -465,11 +472,8 @@ def test_materialized_relation(self, duckdb_cursor, num_rows):\n         ):\n             rel.insert([1, 2, 3, 4])\n \n-        with pytest.raises(\n-            duckdb.NotImplementedException, match='Creating a VIEW from a MaterializedRelation is not supported'\n-        ):\n-            query_rel = rel.query('x', \"select 42 from x where column0 != 42\")\n-            assert query_rel.fetchall() == []\n+        query_rel = rel.query('x', \"select 42 from x where column0 != 42\")\n+        assert query_rel.fetchall() == []\n \n         distinct_rel = rel.distinct()\n         assert distinct_rel.fetchall() == [(42, 'test', 'this is a long string', True)]\n@@ -477,7 +481,8 @@ def test_materialized_relation(self, duckdb_cursor, num_rows):\n         limited_rel = rel.limit(50)\n         assert len(limited_rel.fetchall()) == 50\n \n-        materialized_one = duckdb_cursor.sql(\"call range(10)\").project(\n+        # Using parameters also results in a MaterializedRelation\n+        materialized_one = duckdb_cursor.sql(\"select * from range(?)\", params=[10]).project(\n             ColumnExpression('range').cast(str).alias('range')\n         )\n         materialized_two = duckdb_cursor.sql(\"call repeat('a', 5)\")\n@@ -521,13 +526,50 @@ def test_materialized_relation(self, duckdb_cursor, num_rows):\n         assert res == [('0',), ('1',), ('2',), ('3',), ('4',), ('5',), ('6',), ('7',), ('8',), ('9',)]\n \n     def test_materialized_relation_view(self, duckdb_cursor):\n-        with pytest.raises(\n-            duckdb.NotImplementedException, match='Creating a VIEW from a MaterializedRelation is not supported'\n-        ):\n+        def create_view(duckdb_cursor):\n             duckdb_cursor.sql(\n                 \"\"\"\n                 create table tbl(a varchar);\n                 insert into tbl values ('test') returning *\n             \"\"\"\n             ).to_view('vw')\n-            res = duckdb_cursor.sql(\"select * from vw\").fetchone()\n+\n+        create_view(duckdb_cursor)\n+        res = duckdb_cursor.sql(\"select * from vw\").fetchone()\n+        assert res == ('test',)\n+\n+    def test_materialized_relation_view2(self, duckdb_cursor):\n+        # This creates a MaterializedRelation\n+        rel = duckdb_cursor.sql(\"select * from (values ($1, $2))\", params=[(2,), (\"Alice\",)])\n+\n+        # This creates a ProjectionRelation, wrapping the materialized rel\n+        rel = rel.project(\"col0, col1\")\n+\n+        # Create a VIEW that contains a ColumnDataRef\n+        rel.create_view(\"test\", True)\n+        # Override the existing relation, the original MaterializedRelation has now gone out of scope\n+        # The VIEW still works because the CDC that is being referenced is kept alive through the MaterializedDependency item\n+        rel = duckdb_cursor.sql(\"select * from test\")\n+        res = rel.fetchall()\n+        assert res == [([2], ['Alice'])]\n+\n+    def test_serialized_materialized_relation(self, tmp_database):\n+        con = duckdb.connect(tmp_database)\n+\n+        def create_view(con, view_name: str):\n+            rel = con.sql(\"select 'this is not a small string ' || range::varchar from range(?)\", params=[10])\n+            rel.to_view(view_name)\n+\n+        expected = [(f'this is not a small string {i}',) for i in range(10)]\n+\n+        create_view(con, 'vw')\n+        res = con.sql(\"select * from vw\").fetchall()\n+        assert res == expected\n+\n+        # Make sure the VIEW has to be deserialized from disk\n+        con.close()\n+        gc.collect()\n+        con = duckdb.connect(tmp_database)\n+\n+        res = con.sql(\"select * from vw\").fetchall()\n+        assert res == expected\n",
  "problem_statement": "Lifetime issue with view created in experimental Spark API\n### What happens?\r\n\r\nThe context is that I am trying to change my application to be able to use either pyspark or your experimental Spark API. There are many cases where I am using Spark functions that you haven't implemented. In these cases, instead of using the DataFrame API, I am doing the following: (1) create a view (2) send a direct SQL query to that view, (3) delete all temp views eventually.\r\n\r\nQuerying a view when re-using a variable name fails in v1.0.0. It passes in v0.10.2. If I am doing something wrong, or if there is a better way, please let me know.\r\n\r\nA workaround is to:\r\n1. Create a view, as shown\r\n2. Create a table from that view (`CREATE TABLE my_table AS SELECT * from tmp_view`).\r\n3. Use the table going forward.\r\n\r\n### To Reproduce\r\n\r\nCopy this code into a script, such as `view.py`. \r\n```\r\nfrom uuid import uuid4\r\n\r\nfrom duckdb.experimental.spark.sql import DataFrame, SparkSession\r\nimport duckdb.experimental.spark.sql.functions as F\r\n\r\ndef create_tmp_view(df: DataFrame) -> str:\r\n    view = f\"tmp_{uuid4().hex}\"\r\n    df.createOrReplaceTempView(view)\r\n    return view\r\n\r\ndef main():\r\n    df = spark.createDataFrame([(2, \"Alice\"), (2, \"Bob\"), (2, \"Bob\"), (5, \"Bob\")], schema=[\"age\", \"name\"])\r\n    view = create_tmp_view(df)\r\n    df = spark.sql(f\"SELECT * FROM {view} WHERE name = 'Alice'\")\r\n    print(df.collect())\r\n\r\nif __name__ == \"__main__\":\r\n    spark = SparkSession.builder.getOrCreate()\r\n    main()\r\n```\r\n\r\nRun `python view.py` in the terminal.\r\n```\r\nTraceback (most recent call last):\r\n  File \"./view.py\", line 19, in <module>\r\n    main()\r\n  File \"./view.py\", line 15, in main\r\n    print(df.collect())\r\n          ^^^^^^^^^^^^\r\n  File \"/Users/dthom/python-envs/duckdb/lib/python3.11/site-packages/duckdb/experimental/spark/sql/dataframe.py\", line 981, in collect\r\n    result = self.relation.fetchall()\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^\r\nduckdb.duckdb.InvalidInputException: Invalid Input Error: Attempting to execute an unsuccessful or closed pending query result\r\nError: Invalid Error: vector\r\n```\r\nIf I change the variable name of the result of the query to `df2`, as in\r\n```\r\n    df2 = spark.sql(f\"SELECT * FROM {view} WHERE name = 'Alice'\")\r\n    print(df2.collect())\r\n```\r\nit works.\r\n\r\nThe original code works in v0.10.2. It seems to me that the view should not be tied to the variable instance.\r\n\r\n\r\n### OS:\r\n\r\nMacOS aarch64\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nDaniel Thom\r\n\r\n### Affiliation:\r\n\r\nNational Renewable Energy Laboratory (NREL)\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a source build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-07-15T15:28:21Z"
}