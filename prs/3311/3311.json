{
  "repo": "duckdb/duckdb",
  "pull_number": 3311,
  "instance_id": "duckdb__duckdb-3311",
  "issue_numbers": [
    "3272",
    "3272"
  ],
  "base_commit": "d1cbbb44cbfca1c2d55e1caba14724365b7cbcab",
  "patch": "diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 384a0b0f22da..4e4c8b3cd84e 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -188,9 +188,10 @@ class Binder : public std::enable_shared_from_this<Binder> {\n private:\n \t//! Bind the default values of the columns of a table\n \tvoid BindDefaultValues(vector<ColumnDefinition> &columns, vector<unique_ptr<Expression>> &bound_defaults);\n-\t//! Bind a delimiter value (LIMIT or OFFSET)\n-\tunique_ptr<Expression> BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,\n-\t                                     const LogicalType &type, Value &delimiter_value);\n+\t//! Bind a limit value (LIMIT or OFFSET)\n+\tunique_ptr<Expression> BindDelimiter(ClientContext &context, OrderBinder &order_binder,\n+\t                                     unique_ptr<ParsedExpression> delimiter, const LogicalType &type,\n+\t                                     Value &delimiter_value);\n \n \t//! Move correlated expressions from the child binder to this binder\n \tvoid MoveCorrelatedExpressions(Binder &other);\n@@ -251,10 +252,6 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \tunique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);\n \tunique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);\n \n-\tunique_ptr<LogicalOperator> BindTable(TableCatalogEntry &table, BaseTableRef &ref);\n-\tunique_ptr<LogicalOperator> BindView(ViewCatalogEntry &view, BaseTableRef &ref);\n-\tunique_ptr<LogicalOperator> BindTableOrView(BaseTableRef &ref);\n-\n \tBoundStatement BindCopyTo(CopyStatement &stmt);\n \tBoundStatement BindCopyFrom(CopyStatement &stmt);\n \n@@ -262,8 +259,8 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \tvoid BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index);\n \n \tBoundStatement BindSummarize(ShowStatement &stmt);\n-\tunique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);\n-\tunique_ptr<BoundResultModifier> BindLimitPercent(LimitPercentModifier &limit_mod);\n+\tunique_ptr<BoundResultModifier> BindLimit(OrderBinder &order_binder, LimitModifier &limit_mod);\n+\tunique_ptr<BoundResultModifier> BindLimitPercent(OrderBinder &order_binder, LimitPercentModifier &limit_mod);\n \tunique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);\n \n \tunique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);\ndiff --git a/src/include/duckdb/planner/expression_binder/order_binder.hpp b/src/include/duckdb/planner/expression_binder/order_binder.hpp\nindex da3519cf3f2c..d9f646c50140 100644\n--- a/src/include/duckdb/planner/expression_binder/order_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/order_binder.hpp\n@@ -33,6 +33,8 @@ class OrderBinder {\n \t\treturn max_count;\n \t}\n \n+\tunique_ptr<Expression> CreateExtraReference(unique_ptr<ParsedExpression> expr);\n+\n private:\n \tunique_ptr<Expression> CreateProjectionReference(ParsedExpression &expr, idx_t index);\n \ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 6a5b6bfffea7..4f7836e96e21 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -34,9 +34,13 @@ unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, un\n \treturn bound_expr;\n }\n \n-unique_ptr<Expression> Binder::BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,\n-                                             const LogicalType &type, Value &delimiter_value) {\n+unique_ptr<Expression> Binder::BindDelimiter(ClientContext &context, OrderBinder &order_binder,\n+                                             unique_ptr<ParsedExpression> delimiter, const LogicalType &type,\n+                                             Value &delimiter_value) {\n \tauto new_binder = Binder::CreateBinder(context, this, true);\n+\tif (delimiter->HasSubquery()) {\n+\t\treturn order_binder.CreateExtraReference(move(delimiter));\n+\t}\n \tExpressionBinder expr_binder(*new_binder, context);\n \texpr_binder.target_type = type;\n \tauto expr = expr_binder.Bind(delimiter);\n@@ -48,18 +52,18 @@ unique_ptr<Expression> Binder::BindDelimiter(ClientContext &context, unique_ptr<\n \treturn expr;\n }\n \n-unique_ptr<BoundResultModifier> Binder::BindLimit(LimitModifier &limit_mod) {\n+unique_ptr<BoundResultModifier> Binder::BindLimit(OrderBinder &order_binder, LimitModifier &limit_mod) {\n \tauto result = make_unique<BoundLimitModifier>();\n \tif (limit_mod.limit) {\n \t\tValue val;\n-\t\tresult->limit = BindDelimiter(context, move(limit_mod.limit), LogicalType::BIGINT, val);\n+\t\tresult->limit = BindDelimiter(context, order_binder, move(limit_mod.limit), LogicalType::BIGINT, val);\n \t\tif (!result->limit) {\n \t\t\tresult->limit_val = val.GetValue<int64_t>();\n \t\t}\n \t}\n \tif (limit_mod.offset) {\n \t\tValue val;\n-\t\tresult->offset = BindDelimiter(context, move(limit_mod.offset), LogicalType::BIGINT, val);\n+\t\tresult->offset = BindDelimiter(context, order_binder, move(limit_mod.offset), LogicalType::BIGINT, val);\n \t\tif (!result->offset) {\n \t\t\tresult->offset_val = val.GetValue<int64_t>();\n \t\t}\n@@ -67,11 +71,11 @@ unique_ptr<BoundResultModifier> Binder::BindLimit(LimitModifier &limit_mod) {\n \treturn move(result);\n }\n \n-unique_ptr<BoundResultModifier> Binder::BindLimitPercent(LimitPercentModifier &limit_mod) {\n+unique_ptr<BoundResultModifier> Binder::BindLimitPercent(OrderBinder &order_binder, LimitPercentModifier &limit_mod) {\n \tauto result = make_unique<BoundLimitPercentModifier>();\n \tif (limit_mod.limit) {\n \t\tValue val;\n-\t\tresult->limit = BindDelimiter(context, move(limit_mod.limit), LogicalType::DOUBLE, val);\n+\t\tresult->limit = BindDelimiter(context, order_binder, move(limit_mod.limit), LogicalType::DOUBLE, val);\n \t\tif (!result->limit) {\n \t\t\tresult->limit_percent = val.GetValue<double>();\n \t\t\tif (result->limit_percent < 0.0) {\n@@ -81,7 +85,7 @@ unique_ptr<BoundResultModifier> Binder::BindLimitPercent(LimitPercentModifier &l\n \t}\n \tif (limit_mod.offset) {\n \t\tValue val;\n-\t\tresult->offset = BindDelimiter(context, move(limit_mod.offset), LogicalType::BIGINT, val);\n+\t\tresult->offset = BindDelimiter(context, order_binder, move(limit_mod.offset), LogicalType::BIGINT, val);\n \t\tif (!result->offset) {\n \t\t\tresult->offset_val = val.GetValue<int64_t>();\n \t\t}\n@@ -146,10 +150,10 @@ void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, Boun\n \t\t\tbreak;\n \t\t}\n \t\tcase ResultModifierType::LIMIT_MODIFIER:\n-\t\t\tbound_modifier = BindLimit((LimitModifier &)*mod);\n+\t\t\tbound_modifier = BindLimit(order_binder, (LimitModifier &)*mod);\n \t\t\tbreak;\n \t\tcase ResultModifierType::LIMIT_PERCENT_MODIFIER:\n-\t\t\tbound_modifier = BindLimitPercent((LimitPercentModifier &)*mod);\n+\t\t\tbound_modifier = BindLimitPercent(order_binder, (LimitPercentModifier &)*mod);\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tthrow Exception(\"Unsupported result modifier\");\n@@ -160,6 +164,18 @@ void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, Boun\n \t}\n }\n \n+static void AssignReturnType(unique_ptr<Expression> &expr, const vector<LogicalType> &sql_types,\n+                             idx_t projection_index) {\n+\tif (!expr) {\n+\t\treturn;\n+\t}\n+\tif (expr->type != ExpressionType::BOUND_COLUMN_REF) {\n+\t\treturn;\n+\t}\n+\tauto &bound_colref = (BoundColumnRefExpression &)*expr;\n+\tbound_colref.return_type = sql_types[bound_colref.binding.column_index];\n+}\n+\n void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index) {\n \tfor (auto &bound_mod : result.modifiers) {\n \t\tswitch (bound_mod->type) {\n@@ -193,6 +209,18 @@ void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType>\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n+\t\tcase ResultModifierType::LIMIT_MODIFIER: {\n+\t\t\tauto &limit = (BoundLimitModifier &)*bound_mod;\n+\t\t\tAssignReturnType(limit.limit, sql_types, projection_index);\n+\t\t\tAssignReturnType(limit.offset, sql_types, projection_index);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase ResultModifierType::LIMIT_PERCENT_MODIFIER: {\n+\t\t\tauto &limit = (BoundLimitPercentModifier &)*bound_mod;\n+\t\t\tAssignReturnType(limit.limit, sql_types, projection_index);\n+\t\t\tAssignReturnType(limit.offset, sql_types, projection_index);\n+\t\t\tbreak;\n+\t\t}\n \t\tcase ResultModifierType::ORDER_MODIFIER: {\n \t\t\tauto &order = (BoundOrderModifier &)*bound_mod;\n \t\t\tfor (auto &order_node : order.orders) {\ndiff --git a/src/planner/binder/query_node/plan_select_node.cpp b/src/planner/binder/query_node/plan_select_node.cpp\nindex 7cfacbe71cc8..843482214dda 100644\n--- a/src/planner/binder/query_node/plan_select_node.cpp\n+++ b/src/planner/binder/query_node/plan_select_node.cpp\n@@ -104,36 +104,6 @@ unique_ptr<LogicalOperator> Binder::CreatePlan(BoundSelectNode &statement) {\n \t\tPlanSubqueries(&expr, &root);\n \t}\n \n-\tfor (size_t i = 0; i < statement.modifiers.size(); i++) {\n-\t\tauto &modifier = statement.modifiers[i];\n-\t\tunique_ptr<LogicalOperator> limit = nullptr;\n-\t\tif (modifier->type == ResultModifierType::LIMIT_MODIFIER) {\n-\t\t\tauto &limit_modifier = (BoundLimitModifier &)*modifier;\n-\t\t\tif (limit_modifier.limit || limit_modifier.offset) {\n-\t\t\t\tPlanSubqueries(&limit_modifier.limit, &root);\n-\t\t\t\tPlanSubqueries(&limit_modifier.offset, &root);\n-\t\t\t\tlimit = make_unique<LogicalLimit>(limit_modifier.limit_val, limit_modifier.offset_val,\n-\t\t\t\t                                  move(limit_modifier.limit), move(limit_modifier.offset));\n-\t\t\t}\n-\t\t} else if (modifier->type == ResultModifierType::LIMIT_PERCENT_MODIFIER) {\n-\t\t\tauto &limit_modifier = (BoundLimitPercentModifier &)*modifier;\n-\t\t\tif (limit_modifier.limit || limit_modifier.offset) {\n-\t\t\t\tPlanSubqueries(&limit_modifier.limit, &root);\n-\t\t\t\tPlanSubqueries(&limit_modifier.offset, &root);\n-\t\t\t\tlimit = make_unique<LogicalLimitPercent>(limit_modifier.limit_percent, limit_modifier.offset_val,\n-\t\t\t\t                                         move(limit_modifier.limit), move(limit_modifier.offset));\n-\t\t\t}\n-\t\t}\n-\t\tif (limit) {\n-\t\t\tlimit->AddChild(move(root));\n-\t\t\troot = move(limit);\n-\t\t\t// Delete from modifiers\n-\t\t\tstd::swap(statement.modifiers[i], statement.modifiers.back());\n-\t\t\tstatement.modifiers.erase(statement.modifiers.end() - 1);\n-\t\t\ti--;\n-\t\t}\n-\t}\n-\n \t// create the projection\n \tauto proj = make_unique<LogicalProjection>(statement.projection_index, move(statement.select_list));\n \tauto &projection = *proj;\ndiff --git a/src/planner/expression_binder/order_binder.cpp b/src/planner/expression_binder/order_binder.cpp\nindex cc06aba0e659..1a27ed018910 100644\n--- a/src/planner/expression_binder/order_binder.cpp\n+++ b/src/planner/expression_binder/order_binder.cpp\n@@ -32,6 +32,12 @@ unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &\n \t                                             ColumnBinding(projection_index, index));\n }\n \n+unique_ptr<Expression> OrderBinder::CreateExtraReference(unique_ptr<ParsedExpression> expr) {\n+\tauto result = CreateProjectionReference(*expr, extra_list->size());\n+\textra_list->push_back(move(expr));\n+\treturn result;\n+}\n+\n unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {\n \t// in the ORDER BY clause we do not bind children\n \t// we bind ONLY to the select list\n@@ -102,9 +108,7 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {\n \t\t                      expr->ToString());\n \t}\n \t// otherwise we need to push the ORDER BY entry into the select list\n-\tauto result = CreateProjectionReference(*expr, extra_list->size());\n-\textra_list->push_back(move(expr));\n-\treturn result;\n+\treturn CreateExtraReference(move(expr));\n }\n \n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/order/limit_parameter.test b/test/sql/order/limit_parameter.test\nnew file mode 100644\nindex 000000000000..d310542488a1\n--- /dev/null\n+++ b/test/sql/order/limit_parameter.test\n@@ -0,0 +1,75 @@\n+# name: test/sql/order/limit_parameter.test\n+# description: Test LIMIT with a parameter\n+# group: [order]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+SELECT * FROM generate_series(0, 10000, 1) tbl(i) ORDER BY i DESC LIMIT 5\n+----\n+10000\n+9999\n+9998\n+9997\n+9996\n+\n+statement ok\n+CREATE TABLE integers AS SELECT 5 k\n+\n+query I\n+SELECT * FROM generate_series(0, 10000, 1) tbl(i) ORDER BY i DESC LIMIT (SELECT k FROM integers)\n+----\n+10000\n+9999\n+9998\n+9997\n+9996\n+\n+statement ok\n+CREATE TABLE strings AS SELECT '5'::VARCHAR k\n+\n+query I\n+SELECT * FROM generate_series(0, 10000, 1) tbl(i) ORDER BY i DESC LIMIT (SELECT k FROM strings)\n+----\n+10000\n+9999\n+9998\n+9997\n+9996\n+\n+statement ok\n+PREPARE v1 AS SELECT * FROM generate_series(0, 10000, 1) tbl(i) ORDER BY i DESC LIMIT ?::VARCHAR\n+\n+query I\n+EXECUTE v1(5)\n+----\n+10000\n+9999\n+9998\n+9997\n+9996\n+\n+statement ok\n+PREPARE v1 AS SELECT * FROM generate_series(0, 10000, 1) tbl(i) ORDER BY i DESC LIMIT ?::VARCHAR %\n+\n+query I\n+EXECUTE v1('0.05')\n+----\n+10000\n+9999\n+9998\n+9997\n+9996\n+\n+statement ok\n+CREATE TABLE doubles AS SELECT 0.05 d\n+\n+query I\n+SELECT * FROM generate_series(0, 10000, 1) tbl(i) ORDER BY i DESC LIMIT (SELECT d FROM doubles) %\n+----\n+10000\n+9999\n+9998\n+9997\n+9996\n",
  "problem_statement": "bug: inconsistent / incorrect results when using a bind parameter for a LIMIT clause\n#### What happens?\r\nUsing `LIMIT ?` and binding it to a value returns the correct number of results, but the results are highly variable (even when they shouldn't be).\r\n\r\n#### To Reproduce\r\n```\r\nimport duckdb\r\n\r\ncon = duckdb.connect(\"tpch_sample.ddb\")\r\n\r\ncon.execute(\"CALL dbgen(sf=0.1)\")\r\n\r\n# This works fine\r\nquery = \"\"\"SELECT l_orderkey,\r\n       sum(l_extendedprice * (1 - l_discount)) AS revenue,\r\n       o_orderdate,\r\n       o_shippriority\r\nFROM customer,\r\n     orders,\r\n     lineitem\r\nWHERE c_mktsegment = 'BUILDING'\r\n  AND c_custkey = o_custkey\r\n  AND l_orderkey = o_orderkey\r\n  AND o_orderdate < '1995-03-15'\r\n  AND l_shipdate > '1995-03-15'\r\nGROUP BY l_orderkey,\r\n         o_orderdate,\r\n         o_shippriority\r\nORDER BY revenue DESC,\r\n         o_orderdate\r\nLIMIT 10\r\n;\r\n\"\"\"\r\n\r\n# This has some inconsistent behavior\r\nquery2 = \"\"\"SELECT l_orderkey,\r\n       sum(l_extendedprice * (1 - l_discount)) AS revenue,\r\n       o_orderdate,\r\n       o_shippriority\r\nFROM customer,\r\n     orders,\r\n     lineitem\r\nWHERE c_mktsegment = 'BUILDING'\r\n  AND c_custkey = o_custkey\r\n  AND l_orderkey = o_orderkey\r\n  AND o_orderdate < '1995-03-15'\r\n  AND l_shipdate > '1995-03-15'\r\nGROUP BY l_orderkey,\r\n         o_orderdate,\r\n         o_shippriority\r\nORDER BY revenue DESC,\r\n         o_orderdate\r\nLIMIT ?\r\n;\r\n\"\"\"\r\n\r\n\r\n# Replicable result\r\ncon.execute(query).fetch_df()\r\n\r\n# Unpredictable results\r\n# Run this several times to see the results jump around\r\ncon.execute(query2, (10,)).fetch_df()\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Arch Linux\r\n - DuckDB Version: Reproduced on `0.3.2` and `0.3.3-dev841`\r\n - DuckDB Client: Python\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nbug: inconsistent / incorrect results when using a bind parameter for a LIMIT clause\n#### What happens?\r\nUsing `LIMIT ?` and binding it to a value returns the correct number of results, but the results are highly variable (even when they shouldn't be).\r\n\r\n#### To Reproduce\r\n```\r\nimport duckdb\r\n\r\ncon = duckdb.connect(\"tpch_sample.ddb\")\r\n\r\ncon.execute(\"CALL dbgen(sf=0.1)\")\r\n\r\n# This works fine\r\nquery = \"\"\"SELECT l_orderkey,\r\n       sum(l_extendedprice * (1 - l_discount)) AS revenue,\r\n       o_orderdate,\r\n       o_shippriority\r\nFROM customer,\r\n     orders,\r\n     lineitem\r\nWHERE c_mktsegment = 'BUILDING'\r\n  AND c_custkey = o_custkey\r\n  AND l_orderkey = o_orderkey\r\n  AND o_orderdate < '1995-03-15'\r\n  AND l_shipdate > '1995-03-15'\r\nGROUP BY l_orderkey,\r\n         o_orderdate,\r\n         o_shippriority\r\nORDER BY revenue DESC,\r\n         o_orderdate\r\nLIMIT 10\r\n;\r\n\"\"\"\r\n\r\n# This has some inconsistent behavior\r\nquery2 = \"\"\"SELECT l_orderkey,\r\n       sum(l_extendedprice * (1 - l_discount)) AS revenue,\r\n       o_orderdate,\r\n       o_shippriority\r\nFROM customer,\r\n     orders,\r\n     lineitem\r\nWHERE c_mktsegment = 'BUILDING'\r\n  AND c_custkey = o_custkey\r\n  AND l_orderkey = o_orderkey\r\n  AND o_orderdate < '1995-03-15'\r\n  AND l_shipdate > '1995-03-15'\r\nGROUP BY l_orderkey,\r\n         o_orderdate,\r\n         o_shippriority\r\nORDER BY revenue DESC,\r\n         o_orderdate\r\nLIMIT ?\r\n;\r\n\"\"\"\r\n\r\n\r\n# Replicable result\r\ncon.execute(query).fetch_df()\r\n\r\n# Unpredictable results\r\n# Run this several times to see the results jump around\r\ncon.execute(query2, (10,)).fetch_df()\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Arch Linux\r\n - DuckDB Version: Reproduced on `0.3.2` and `0.3.3-dev841`\r\n - DuckDB Client: Python\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "\n",
  "created_at": "2022-03-28T14:45:19Z"
}