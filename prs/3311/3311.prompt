You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
bug: inconsistent / incorrect results when using a bind parameter for a LIMIT clause
#### What happens?
Using `LIMIT ?` and binding it to a value returns the correct number of results, but the results are highly variable (even when they shouldn't be).

#### To Reproduce
```
import duckdb

con = duckdb.connect("tpch_sample.ddb")

con.execute("CALL dbgen(sf=0.1)")

# This works fine
query = """SELECT l_orderkey,
       sum(l_extendedprice * (1 - l_discount)) AS revenue,
       o_orderdate,
       o_shippriority
FROM customer,
     orders,
     lineitem
WHERE c_mktsegment = 'BUILDING'
  AND c_custkey = o_custkey
  AND l_orderkey = o_orderkey
  AND o_orderdate < '1995-03-15'
  AND l_shipdate > '1995-03-15'
GROUP BY l_orderkey,
         o_orderdate,
         o_shippriority
ORDER BY revenue DESC,
         o_orderdate
LIMIT 10
;
"""

# This has some inconsistent behavior
query2 = """SELECT l_orderkey,
       sum(l_extendedprice * (1 - l_discount)) AS revenue,
       o_orderdate,
       o_shippriority
FROM customer,
     orders,
     lineitem
WHERE c_mktsegment = 'BUILDING'
  AND c_custkey = o_custkey
  AND l_orderkey = o_orderkey
  AND o_orderdate < '1995-03-15'
  AND l_shipdate > '1995-03-15'
GROUP BY l_orderkey,
         o_orderdate,
         o_shippriority
ORDER BY revenue DESC,
         o_orderdate
LIMIT ?
;
"""


# Replicable result
con.execute(query).fetch_df()

# Unpredictable results
# Run this several times to see the results jump around
con.execute(query2, (10,)).fetch_df()
```

#### Environment (please complete the following information):
 - OS: Arch Linux
 - DuckDB Version: Reproduced on `0.3.2` and `0.3.3-dev841`
 - DuckDB Client: Python

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

bug: inconsistent / incorrect results when using a bind parameter for a LIMIT clause
#### What happens?
Using `LIMIT ?` and binding it to a value returns the correct number of results, but the results are highly variable (even when they shouldn't be).

#### To Reproduce
```
import duckdb

con = duckdb.connect("tpch_sample.ddb")

con.execute("CALL dbgen(sf=0.1)")

# This works fine
query = """SELECT l_orderkey,
       sum(l_extendedprice * (1 - l_discount)) AS revenue,
       o_orderdate,
       o_shippriority
FROM customer,
     orders,
     lineitem
WHERE c_mktsegment = 'BUILDING'
  AND c_custkey = o_custkey
  AND l_orderkey = o_orderkey
  AND o_orderdate < '1995-03-15'
  AND l_shipdate > '1995-03-15'
GROUP BY l_orderkey,
         o_orderdate,
         o_shippriority
ORDER BY revenue DESC,
         o_orderdate
LIMIT 10
;
"""

# This has some inconsistent behavior
query2 = """SELECT l_orderkey,
       sum(l_extendedprice * (1 - l_discount)) AS revenue,
       o_orderdate,
       o_shippriority
FROM customer,
     orders,
     lineitem
WHERE c_mktsegment = 'BUILDING'
  AND c_custkey = o_custkey
  AND l_orderkey = o_orderkey
  AND o_orderdate < '1995-03-15'
  AND l_shipdate > '1995-03-15'
GROUP BY l_orderkey,
         o_orderdate,
         o_shippriority
ORDER BY revenue DESC,
         o_orderdate
LIMIT ?
;
"""


# Replicable result
con.execute(query).fetch_df()

# Unpredictable results
# Run this several times to see the results jump around
con.execute(query2, (10,)).fetch_df()
```

#### Environment (please complete the following information):
 - OS: Arch Linux
 - DuckDB Version: Reproduced on `0.3.2` and `0.3.3-dev841`
 - DuckDB Client: Python

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/parser/column_definition.hpp"
13: #include "duckdb/parser/tokens.hpp"
14: #include "duckdb/planner/bind_context.hpp"
15: #include "duckdb/planner/bound_tokens.hpp"
16: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
17: #include "duckdb/planner/logical_operator.hpp"
18: #include "duckdb/planner/bound_statement.hpp"
19: #include "duckdb/common/case_insensitive_map.hpp"
20: #include "duckdb/parser/result_modifier.hpp"
21: 
22: //#include "duckdb/catalog/catalog_entry/table_macro_catalog_entry.hpp"
23: 
24: namespace duckdb {
25: class BoundResultModifier;
26: class BoundSelectNode;
27: class ClientContext;
28: class ExpressionBinder;
29: class LimitModifier;
30: class OrderBinder;
31: class TableCatalogEntry;
32: class ViewCatalogEntry;
33: class TableMacroCatalogEntry;
34: 
35: struct CreateInfo;
36: struct BoundCreateTableInfo;
37: struct BoundCreateFunctionInfo;
38: struct CommonTableExpressionInfo;
39: 
40: enum class BindingMode : uint8_t { STANDARD_BINDING, EXTRACT_NAMES };
41: 
42: struct CorrelatedColumnInfo {
43: 	ColumnBinding binding;
44: 	LogicalType type;
45: 	string name;
46: 	idx_t depth;
47: 
48: 	explicit CorrelatedColumnInfo(BoundColumnRefExpression &expr)
49: 	    : binding(expr.binding), type(expr.return_type), name(expr.GetName()), depth(expr.depth) {
50: 	}
51: 
52: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
53: 		return binding == rhs.binding;
54: 	}
55: };
56: 
57: //! Bind the parsed query tree to the actual columns present in the catalog.
58: /*!
59:   The binder is responsible for binding tables and columns to actual physical
60:   tables and columns in the catalog. In the process, it also resolves types of
61:   all expressions.
62: */
63: class Binder : public std::enable_shared_from_this<Binder> {
64: 	friend class ExpressionBinder;
65: 	friend class SelectBinder;
66: 	friend class RecursiveSubqueryPlanner;
67: 
68: public:
69: 	static shared_ptr<Binder> CreateBinder(ClientContext &context, Binder *parent = nullptr, bool inherit_ctes = true);
70: 
71: 	//! The client context
72: 	ClientContext &context;
73: 	//! A mapping of names to common table expressions
74: 	case_insensitive_map_t<CommonTableExpressionInfo *> CTE_bindings;
75: 	//! The CTEs that have already been bound
76: 	unordered_set<CommonTableExpressionInfo *> bound_ctes;
77: 	//! The bind context
78: 	BindContext bind_context;
79: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
80: 	//! vector)
81: 	vector<CorrelatedColumnInfo> correlated_columns;
82: 	//! The set of parameter expressions bound by this binder
83: 	vector<BoundParameterExpression *> *parameters;
84: 	//! Whether or not the bound statement is read-only
85: 	bool read_only;
86: 	//! Whether or not the statement requires a valid transaction to run
87: 	bool requires_valid_transaction;
88: 	//! Whether or not the statement can be streamed to the client
89: 	bool allow_stream_result;
90: 	//! The alias for the currently processing subquery, if it exists
91: 	string alias;
92: 	//! Macro parameter bindings (if any)
93: 	MacroBinding *macro_binding = nullptr;
94: 
95: public:
96: 	BoundStatement Bind(SQLStatement &statement);
97: 	BoundStatement Bind(QueryNode &node);
98: 
99: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
100: 	void BindCreateViewInfo(CreateViewInfo &base);
101: 	SchemaCatalogEntry *BindSchema(CreateInfo &info);
102: 	SchemaCatalogEntry *BindCreateFunctionInfo(CreateInfo &info);
103: 
104: 	//! Check usage, and cast named parameters to their types
105: 	static void BindNamedParameters(named_parameter_type_map_t &types, named_parameter_map_t &values,
106: 	                                QueryErrorContext &error_context, string &func_name);
107: 
108: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
109: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
110: 
111: 	//! Generates an unused index for a table
112: 	idx_t GenerateTableIndex();
113: 
114: 	//! Add a common table expression to the binder
115: 	void AddCTE(const string &name, CommonTableExpressionInfo *cte);
116: 	//! Find a common table expression by name; returns nullptr if none exists
117: 	CommonTableExpressionInfo *FindCTE(const string &name, bool skip = false);
118: 
119: 	bool CTEIsAlreadyBound(CommonTableExpressionInfo *cte);
120: 
121: 	//! Add the view to the set of currently bound views - used for detecting recursive view definitions
122: 	void AddBoundView(ViewCatalogEntry *view);
123: 
124: 	void PushExpressionBinder(ExpressionBinder *binder);
125: 	void PopExpressionBinder();
126: 	void SetActiveBinder(ExpressionBinder *binder);
127: 	ExpressionBinder *GetActiveBinder();
128: 	bool HasActiveBinder();
129: 
130: 	vector<ExpressionBinder *> &GetActiveBinders();
131: 
132: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
133: 	//! Add a correlated column to this binder (if it does not exist)
134: 	void AddCorrelatedColumn(const CorrelatedColumnInfo &info);
135: 
136: 	string FormatError(ParsedExpression &expr_context, const string &message);
137: 	string FormatError(TableRef &ref_context, const string &message);
138: 
139: 	string FormatErrorRecursive(idx_t query_location, const string &message, vector<ExceptionFormatValue> &values);
140: 	template <class T, typename... Args>
141: 	string FormatErrorRecursive(idx_t query_location, const string &msg, vector<ExceptionFormatValue> &values, T param,
142: 	                            Args... params) {
143: 		values.push_back(ExceptionFormatValue::CreateFormatValue<T>(param));
144: 		return FormatErrorRecursive(query_location, msg, values, params...);
145: 	}
146: 
147: 	template <typename... Args>
148: 	string FormatError(idx_t query_location, const string &msg, Args... params) {
149: 		vector<ExceptionFormatValue> values;
150: 		return FormatErrorRecursive(query_location, msg, values, params...);
151: 	}
152: 
153: 	static void BindLogicalType(ClientContext &context, LogicalType &type, const string &schema = "");
154: 
155: 	bool HasMatchingBinding(const string &table_name, const string &column_name, string &error_message);
156: 	bool HasMatchingBinding(const string &schema_name, const string &table_name, const string &column_name,
157: 	                        string &error_message);
158: 
159: 	void SetBindingMode(BindingMode mode);
160: 	BindingMode GetBindingMode();
161: 	void AddTableName(string table_name);
162: 	const unordered_set<string> &GetTableNames();
163: 
164: private:
165: 	//! The parent binder (if any)
166: 	shared_ptr<Binder> parent;
167: 	//! The vector of active binders
168: 	vector<ExpressionBinder *> active_binders;
169: 	//! The count of bound_tables
170: 	idx_t bound_tables;
171: 	//! Whether or not the binder has any unplanned subqueries that still need to be planned
172: 	bool has_unplanned_subqueries = false;
173: 	//! Whether or not subqueries should be planned already
174: 	bool plan_subquery = true;
175: 	//! Whether CTEs should reference the parent binder (if it exists)
176: 	bool inherit_ctes = true;
177: 	//! Whether or not the binder can contain NULLs as the root of expressions
178: 	bool can_contain_nulls = false;
179: 	//! The root statement of the query that is currently being parsed
180: 	SQLStatement *root_statement = nullptr;
181: 	//! Binding mode
182: 	BindingMode mode = BindingMode::STANDARD_BINDING;
183: 	//! Table names extracted for BindingMode::EXTRACT_NAMES
184: 	unordered_set<string> table_names;
185: 	//! The set of bound views
186: 	unordered_set<ViewCatalogEntry *> bound_views;
187: 
188: private:
189: 	//! Bind the default values of the columns of a table
190: 	void BindDefaultValues(vector<ColumnDefinition> &columns, vector<unique_ptr<Expression>> &bound_defaults);
191: 	//! Bind a delimiter value (LIMIT or OFFSET)
192: 	unique_ptr<Expression> BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,
193: 	                                     const LogicalType &type, Value &delimiter_value);
194: 
195: 	//! Move correlated expressions from the child binder to this binder
196: 	void MoveCorrelatedExpressions(Binder &other);
197: 
198: 	BoundStatement Bind(SelectStatement &stmt);
199: 	BoundStatement Bind(InsertStatement &stmt);
200: 	BoundStatement Bind(CopyStatement &stmt);
201: 	BoundStatement Bind(DeleteStatement &stmt);
202: 	BoundStatement Bind(UpdateStatement &stmt);
203: 	BoundStatement Bind(CreateStatement &stmt);
204: 	BoundStatement Bind(DropStatement &stmt);
205: 	BoundStatement Bind(AlterStatement &stmt);
206: 	BoundStatement Bind(TransactionStatement &stmt);
207: 	BoundStatement Bind(PragmaStatement &stmt);
208: 	BoundStatement Bind(ExplainStatement &stmt);
209: 	BoundStatement Bind(VacuumStatement &stmt);
210: 	BoundStatement Bind(RelationStatement &stmt);
211: 	BoundStatement Bind(ShowStatement &stmt);
212: 	BoundStatement Bind(CallStatement &stmt);
213: 	BoundStatement Bind(ExportStatement &stmt);
214: 	BoundStatement Bind(SetStatement &stmt);
215: 	BoundStatement Bind(LoadStatement &stmt);
216: 	BoundStatement BindReturning(vector<unique_ptr<ParsedExpression>> returning_list, TableCatalogEntry *table,
217: 	                             idx_t update_table_index, unique_ptr<LogicalOperator> child_operator,
218: 	                             BoundStatement result);
219: 
220: 	unique_ptr<QueryNode> BindTableMacro(FunctionExpression &function, TableMacroCatalogEntry *macro_func, idx_t depth);
221: 
222: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
223: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
224: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
225: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
226: 
227: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
228: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
229: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
230: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
231: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
232: 
233: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
234: 	unique_ptr<BoundTableRef> Bind(CrossProductRef &ref);
235: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
236: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte = nullptr);
237: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
238: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
239: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
240: 
241: 	bool BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
242: 	                            vector<Value> &parameters, named_parameter_map_t &named_parameters,
243: 	                            unique_ptr<BoundSubqueryRef> &subquery, string &error);
244: 
245: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
246: 	unique_ptr<LogicalOperator> CreatePlan(BoundCrossProductRef &ref);
247: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
248: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
249: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
250: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
251: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
252: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
253: 
254: 	unique_ptr<LogicalOperator> BindTable(TableCatalogEntry &table, BaseTableRef &ref);
255: 	unique_ptr<LogicalOperator> BindView(ViewCatalogEntry &view, BaseTableRef &ref);
256: 	unique_ptr<LogicalOperator> BindTableOrView(BaseTableRef &ref);
257: 
258: 	BoundStatement BindCopyTo(CopyStatement &stmt);
259: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
260: 
261: 	void BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
262: 	void BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index);
263: 
264: 	BoundStatement BindSummarize(ShowStatement &stmt);
265: 	unique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);
266: 	unique_ptr<BoundResultModifier> BindLimitPercent(LimitPercentModifier &limit_mod);
267: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
268: 
269: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
270: 
271: 	void PlanSubqueries(unique_ptr<Expression> *expr, unique_ptr<LogicalOperator> *root);
272: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
273: 
274: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,
275: 	                                                       vector<LogicalType> &target_types,
276: 	                                                       unique_ptr<LogicalOperator> op);
277: 
278: 	string FindBinding(const string &using_column, const string &join_side);
279: 	bool TryFindBinding(const string &using_column, const string &join_side, string &result);
280: 
281: 	void AddUsingBindingSet(unique_ptr<UsingColumnSet> set);
282: 	string RetrieveUsingBinding(Binder &current_binder, UsingColumnSet *current_set, const string &column_name,
283: 	                            const string &join_side, UsingColumnSet *new_set);
284: 
285: public:
286: 	// This should really be a private constructor, but make_shared does not allow it...
287: 	// If you are thinking about calling this, you should probably call Binder::CreateBinder
288: 	Binder(bool I_know_what_I_am_doing, ClientContext &context, shared_ptr<Binder> parent, bool inherit_ctes);
289: };
290: 
291: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/include/duckdb/planner/expression_binder/order_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression_binder/order_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/case_insensitive_map.hpp"
12: #include "duckdb/parser/expression_map.hpp"
13: #include "duckdb/parser/parsed_expression.hpp"
14: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
15: 
16: namespace duckdb {
17: class Binder;
18: class Expression;
19: class SelectNode;
20: 
21: //! The ORDER binder is responsible for binding an expression within the ORDER BY clause of a SQL statement
22: class OrderBinder {
23: public:
24: 	OrderBinder(vector<Binder *> binders, idx_t projection_index, case_insensitive_map_t<idx_t> &alias_map,
25: 	            expression_map_t<idx_t> &projection_map, idx_t max_count);
26: 	OrderBinder(vector<Binder *> binders, idx_t projection_index, SelectNode &node,
27: 	            case_insensitive_map_t<idx_t> &alias_map, expression_map_t<idx_t> &projection_map);
28: 
29: public:
30: 	unique_ptr<Expression> Bind(unique_ptr<ParsedExpression> expr);
31: 
32: 	idx_t MaxCount() {
33: 		return max_count;
34: 	}
35: 
36: private:
37: 	unique_ptr<Expression> CreateProjectionReference(ParsedExpression &expr, idx_t index);
38: 
39: private:
40: 	vector<Binder *> binders;
41: 	idx_t projection_index;
42: 	idx_t max_count;
43: 	vector<unique_ptr<ParsedExpression>> *extra_list;
44: 	case_insensitive_map_t<idx_t> &alias_map;
45: 	expression_map_t<idx_t> &projection_map;
46: };
47: 
48: } // namespace duckdb
[end of src/include/duckdb/planner/expression_binder/order_binder.hpp]
[start of src/planner/binder/query_node/bind_select_node.cpp]
1: #include "duckdb/common/limits.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/main/config.hpp"
5: #include "duckdb/parser/expression/columnref_expression.hpp"
6: #include "duckdb/parser/expression/comparison_expression.hpp"
7: #include "duckdb/parser/expression/constant_expression.hpp"
8: #include "duckdb/parser/expression/subquery_expression.hpp"
9: #include "duckdb/parser/query_node/select_node.hpp"
10: #include "duckdb/parser/tableref/joinref.hpp"
11: #include "duckdb/planner/binder.hpp"
12: #include "duckdb/planner/expression_binder/column_alias_binder.hpp"
13: #include "duckdb/planner/expression_binder/constant_binder.hpp"
14: #include "duckdb/planner/expression_binder/group_binder.hpp"
15: #include "duckdb/planner/expression_binder/having_binder.hpp"
16: #include "duckdb/planner/expression_binder/qualify_binder.hpp"
17: #include "duckdb/planner/expression_binder/order_binder.hpp"
18: #include "duckdb/planner/expression_binder/select_binder.hpp"
19: #include "duckdb/planner/expression_binder/where_binder.hpp"
20: #include "duckdb/planner/query_node/bound_select_node.hpp"
21: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
22: 
23: namespace duckdb {
24: 
25: unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {
26: 	// we treat the Distinct list as a order by
27: 	auto bound_expr = order_binder.Bind(move(expr));
28: 	if (!bound_expr) {
29: 		// DISTINCT ON non-integer constant
30: 		// remove the expression from the DISTINCT ON list
31: 		return nullptr;
32: 	}
33: 	D_ASSERT(bound_expr->type == ExpressionType::BOUND_COLUMN_REF);
34: 	return bound_expr;
35: }
36: 
37: unique_ptr<Expression> Binder::BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,
38:                                              const LogicalType &type, Value &delimiter_value) {
39: 	auto new_binder = Binder::CreateBinder(context, this, true);
40: 	ExpressionBinder expr_binder(*new_binder, context);
41: 	expr_binder.target_type = type;
42: 	auto expr = expr_binder.Bind(delimiter);
43: 	if (expr->IsFoldable()) {
44: 		//! this is a constant
45: 		delimiter_value = ExpressionExecutor::EvaluateScalar(*expr).CastAs(type);
46: 		return nullptr;
47: 	}
48: 	return expr;
49: }
50: 
51: unique_ptr<BoundResultModifier> Binder::BindLimit(LimitModifier &limit_mod) {
52: 	auto result = make_unique<BoundLimitModifier>();
53: 	if (limit_mod.limit) {
54: 		Value val;
55: 		result->limit = BindDelimiter(context, move(limit_mod.limit), LogicalType::BIGINT, val);
56: 		if (!result->limit) {
57: 			result->limit_val = val.GetValue<int64_t>();
58: 			if (result->limit_val < 0) {
59: 				throw BinderException("LIMIT cannot be negative");
60: 			}
61: 		}
62: 	}
63: 	if (limit_mod.offset) {
64: 		Value val;
65: 		result->offset = BindDelimiter(context, move(limit_mod.offset), LogicalType::BIGINT, val);
66: 		if (!result->offset) {
67: 			result->offset_val = val.GetValue<int64_t>();
68: 			if (result->offset_val < 0) {
69: 				throw BinderException("OFFSET cannot be negative");
70: 			}
71: 		}
72: 	}
73: 	return move(result);
74: }
75: 
76: unique_ptr<BoundResultModifier> Binder::BindLimitPercent(LimitPercentModifier &limit_mod) {
77: 	auto result = make_unique<BoundLimitPercentModifier>();
78: 	if (limit_mod.limit) {
79: 		Value val;
80: 		result->limit = BindDelimiter(context, move(limit_mod.limit), LogicalType::DOUBLE, val);
81: 		if (!result->limit) {
82: 			result->limit_percent = val.GetValue<double>();
83: 			if (result->limit_percent < 0.0) {
84: 				throw Exception("Limit percentage can't be negative value");
85: 			}
86: 		}
87: 	}
88: 	if (limit_mod.offset) {
89: 		Value val;
90: 		result->offset = BindDelimiter(context, move(limit_mod.offset), LogicalType::BIGINT, val);
91: 		if (!result->offset) {
92: 			result->offset_val = val.GetValue<int64_t>();
93: 		}
94: 	}
95: 	return move(result);
96: }
97: 
98: void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result) {
99: 	for (auto &mod : statement.modifiers) {
100: 		unique_ptr<BoundResultModifier> bound_modifier;
101: 		switch (mod->type) {
102: 		case ResultModifierType::DISTINCT_MODIFIER: {
103: 			auto &distinct = (DistinctModifier &)*mod;
104: 			auto bound_distinct = make_unique<BoundDistinctModifier>();
105: 			if (distinct.distinct_on_targets.empty()) {
106: 				for (idx_t i = 0; i < result.names.size(); i++) {
107: 					distinct.distinct_on_targets.push_back(make_unique<ConstantExpression>(Value::INTEGER(1 + i)));
108: 				}
109: 			}
110: 			for (auto &distinct_on_target : distinct.distinct_on_targets) {
111: 				auto expr = BindOrderExpression(order_binder, move(distinct_on_target));
112: 				if (!expr) {
113: 					continue;
114: 				}
115: 				bound_distinct->target_distincts.push_back(move(expr));
116: 			}
117: 			bound_modifier = move(bound_distinct);
118: 			break;
119: 		}
120: 		case ResultModifierType::ORDER_MODIFIER: {
121: 			auto &order = (OrderModifier &)*mod;
122: 			auto bound_order = make_unique<BoundOrderModifier>();
123: 			auto &config = DBConfig::GetConfig(context);
124: 			D_ASSERT(!order.orders.empty());
125: 			if (order.orders[0].expression->type == ExpressionType::STAR) {
126: 				// ORDER BY ALL
127: 				// replace the order list with the maximum order by count
128: 				D_ASSERT(order.orders.size() == 1);
129: 				auto order_type = order.orders[0].type;
130: 				auto null_order = order.orders[0].null_order;
131: 
132: 				vector<OrderByNode> new_orders;
133: 				for (idx_t i = 0; i < order_binder.MaxCount(); i++) {
134: 					new_orders.emplace_back(order_type, null_order,
135: 					                        make_unique<ConstantExpression>(Value::INTEGER(i + 1)));
136: 				}
137: 				order.orders = move(new_orders);
138: 			}
139: 			for (auto &order_node : order.orders) {
140: 				auto order_expression = BindOrderExpression(order_binder, move(order_node.expression));
141: 				if (!order_expression) {
142: 					continue;
143: 				}
144: 				auto type = order_node.type == OrderType::ORDER_DEFAULT ? config.default_order_type : order_node.type;
145: 				auto null_order = order_node.null_order == OrderByNullType::ORDER_DEFAULT ? config.default_null_order
146: 				                                                                          : order_node.null_order;
147: 				bound_order->orders.emplace_back(type, null_order, move(order_expression));
148: 			}
149: 			if (!bound_order->orders.empty()) {
150: 				bound_modifier = move(bound_order);
151: 			}
152: 			break;
153: 		}
154: 		case ResultModifierType::LIMIT_MODIFIER:
155: 			bound_modifier = BindLimit((LimitModifier &)*mod);
156: 			break;
157: 		case ResultModifierType::LIMIT_PERCENT_MODIFIER:
158: 			bound_modifier = BindLimitPercent((LimitPercentModifier &)*mod);
159: 			break;
160: 		default:
161: 			throw Exception("Unsupported result modifier");
162: 		}
163: 		if (bound_modifier) {
164: 			result.modifiers.push_back(move(bound_modifier));
165: 		}
166: 	}
167: }
168: 
169: void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index) {
170: 	for (auto &bound_mod : result.modifiers) {
171: 		switch (bound_mod->type) {
172: 		case ResultModifierType::DISTINCT_MODIFIER: {
173: 			auto &distinct = (BoundDistinctModifier &)*bound_mod;
174: 			if (distinct.target_distincts.empty()) {
175: 				// DISTINCT without a target: push references to the standard select list
176: 				for (idx_t i = 0; i < sql_types.size(); i++) {
177: 					distinct.target_distincts.push_back(
178: 					    make_unique<BoundColumnRefExpression>(sql_types[i], ColumnBinding(projection_index, i)));
179: 				}
180: 			} else {
181: 				// DISTINCT with target list: set types
182: 				for (auto &expr : distinct.target_distincts) {
183: 					D_ASSERT(expr->type == ExpressionType::BOUND_COLUMN_REF);
184: 					auto &bound_colref = (BoundColumnRefExpression &)*expr;
185: 					if (bound_colref.binding.column_index == DConstants::INVALID_INDEX) {
186: 						throw BinderException("Ambiguous name in DISTINCT ON!");
187: 					}
188: 					D_ASSERT(bound_colref.binding.column_index < sql_types.size());
189: 					bound_colref.return_type = sql_types[bound_colref.binding.column_index];
190: 				}
191: 			}
192: 			for (auto &target_distinct : distinct.target_distincts) {
193: 				auto &bound_colref = (BoundColumnRefExpression &)*target_distinct;
194: 				auto sql_type = sql_types[bound_colref.binding.column_index];
195: 				if (sql_type.id() == LogicalTypeId::VARCHAR) {
196: 					target_distinct = ExpressionBinder::PushCollation(context, move(target_distinct),
197: 					                                                  StringType::GetCollation(sql_type), true);
198: 				}
199: 			}
200: 			break;
201: 		}
202: 		case ResultModifierType::ORDER_MODIFIER: {
203: 			auto &order = (BoundOrderModifier &)*bound_mod;
204: 			for (auto &order_node : order.orders) {
205: 				auto &expr = order_node.expression;
206: 				D_ASSERT(expr->type == ExpressionType::BOUND_COLUMN_REF);
207: 				auto &bound_colref = (BoundColumnRefExpression &)*expr;
208: 				if (bound_colref.binding.column_index == DConstants::INVALID_INDEX) {
209: 					throw BinderException("Ambiguous name in ORDER BY!");
210: 				}
211: 				D_ASSERT(bound_colref.binding.column_index < sql_types.size());
212: 				auto sql_type = sql_types[bound_colref.binding.column_index];
213: 				bound_colref.return_type = sql_types[bound_colref.binding.column_index];
214: 				if (sql_type.id() == LogicalTypeId::VARCHAR) {
215: 					order_node.expression = ExpressionBinder::PushCollation(context, move(order_node.expression),
216: 					                                                        StringType::GetCollation(sql_type));
217: 				}
218: 			}
219: 			break;
220: 		}
221: 		default:
222: 			break;
223: 		}
224: 	}
225: }
226: 
227: unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
228: 	auto result = make_unique<BoundSelectNode>();
229: 	result->projection_index = GenerateTableIndex();
230: 	result->group_index = GenerateTableIndex();
231: 	result->aggregate_index = GenerateTableIndex();
232: 	result->groupings_index = GenerateTableIndex();
233: 	result->window_index = GenerateTableIndex();
234: 	result->unnest_index = GenerateTableIndex();
235: 	result->prune_index = GenerateTableIndex();
236: 
237: 	// first bind the FROM table statement
238: 	result->from_table = Bind(*statement.from_table);
239: 
240: 	// bind the sample clause
241: 	if (statement.sample) {
242: 		result->sample_options = move(statement.sample);
243: 	}
244: 
245: 	// visit the select list and expand any "*" statements
246: 	vector<unique_ptr<ParsedExpression>> new_select_list;
247: 	for (auto &select_element : statement.select_list) {
248: 		if (select_element->GetExpressionType() == ExpressionType::STAR) {
249: 			// * statement, expand to all columns from the FROM clause
250: 			bind_context.GenerateAllColumnExpressions((StarExpression &)*select_element, new_select_list);
251: 		} else {
252: 			// regular statement, add it to the list
253: 			new_select_list.push_back(move(select_element));
254: 		}
255: 	}
256: 	if (new_select_list.empty()) {
257: 		throw BinderException("SELECT list is empty after resolving * expressions!");
258: 	}
259: 	statement.select_list = move(new_select_list);
260: 
261: 	// create a mapping of (alias -> index) and a mapping of (Expression -> index) for the SELECT list
262: 	case_insensitive_map_t<idx_t> alias_map;
263: 	expression_map_t<idx_t> projection_map;
264: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
265: 		auto &expr = statement.select_list[i];
266: 		result->names.push_back(expr->GetName());
267: 		ExpressionBinder::QualifyColumnNames(*this, expr);
268: 		if (!expr->alias.empty()) {
269: 			alias_map[expr->alias] = i;
270: 			result->names[i] = expr->alias;
271: 		}
272: 		projection_map[expr.get()] = i;
273: 		result->original_expressions.push_back(expr->Copy());
274: 	}
275: 	result->column_count = statement.select_list.size();
276: 
277: 	// first visit the WHERE clause
278: 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
279: 	if (statement.where_clause) {
280: 		ColumnAliasBinder alias_binder(*result, alias_map);
281: 		WhereBinder where_binder(*this, context, &alias_binder);
282: 		unique_ptr<ParsedExpression> condition = move(statement.where_clause);
283: 		result->where_clause = where_binder.Bind(condition);
284: 	}
285: 
286: 	// now bind all the result modifiers; including DISTINCT and ORDER BY targets
287: 	OrderBinder order_binder({this}, result->projection_index, statement, alias_map, projection_map);
288: 	BindModifiers(order_binder, statement, *result);
289: 
290: 	vector<unique_ptr<ParsedExpression>> unbound_groups;
291: 	BoundGroupInformation info;
292: 	auto &group_expressions = statement.groups.group_expressions;
293: 	if (!group_expressions.empty()) {
294: 		// the statement has a GROUP BY clause, bind it
295: 		unbound_groups.resize(group_expressions.size());
296: 		GroupBinder group_binder(*this, context, statement, result->group_index, alias_map, info.alias_map);
297: 		for (idx_t i = 0; i < group_expressions.size(); i++) {
298: 
299: 			// we keep a copy of the unbound expression;
300: 			// we keep the unbound copy around to check for group references in the SELECT and HAVING clause
301: 			// the reason we want the unbound copy is because we want to figure out whether an expression
302: 			// is a group reference BEFORE binding in the SELECT/HAVING binder
303: 			group_binder.unbound_expression = group_expressions[i]->Copy();
304: 			group_binder.bind_index = i;
305: 
306: 			// bind the groups
307: 			LogicalType group_type;
308: 			auto bound_expr = group_binder.Bind(group_expressions[i], &group_type);
309: 			D_ASSERT(bound_expr->return_type.id() != LogicalTypeId::INVALID);
310: 
311: 			// push a potential collation, if necessary
312: 			bound_expr =
313: 			    ExpressionBinder::PushCollation(context, move(bound_expr), StringType::GetCollation(group_type), true);
314: 			result->groups.group_expressions.push_back(move(bound_expr));
315: 
316: 			// in the unbound expression we DO bind the table names of any ColumnRefs
317: 			// we do this to make sure that "table.a" and "a" are treated the same
318: 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
319: 			// hence we convert "a" -> "test.a" in the unbound expression
320: 			unbound_groups[i] = move(group_binder.unbound_expression);
321: 			ExpressionBinder::QualifyColumnNames(*this, unbound_groups[i]);
322: 			info.map[unbound_groups[i].get()] = i;
323: 		}
324: 	}
325: 	result->groups.grouping_sets = move(statement.groups.grouping_sets);
326: 
327: 	// bind the HAVING clause, if any
328: 	if (statement.having) {
329: 		HavingBinder having_binder(*this, context, *result, info, alias_map);
330: 		ExpressionBinder::QualifyColumnNames(*this, statement.having);
331: 		result->having = having_binder.Bind(statement.having);
332: 	}
333: 
334: 	// bind the QUALIFY clause, if any
335: 	if (statement.qualify) {
336: 		QualifyBinder qualify_binder(*this, context, *result, info, alias_map);
337: 		ExpressionBinder::QualifyColumnNames(*this, statement.qualify);
338: 		result->qualify = qualify_binder.Bind(statement.qualify);
339: 	}
340: 
341: 	// after that, we bind to the SELECT list
342: 	SelectBinder select_binder(*this, context, *result, info);
343: 	vector<LogicalType> internal_sql_types;
344: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
345: 		LogicalType result_type;
346: 		auto expr = select_binder.Bind(statement.select_list[i], &result_type);
347: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES && select_binder.HasBoundColumns()) {
348: 			if (select_binder.BoundAggregates()) {
349: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
350: 			}
351: 			// we are forcing aggregates, and the node has columns bound
352: 			// this entry becomes a group
353: 			auto group_ref = make_unique<BoundColumnRefExpression>(
354: 			    expr->return_type, ColumnBinding(result->group_index, result->groups.group_expressions.size()));
355: 			result->groups.group_expressions.push_back(move(expr));
356: 			expr = move(group_ref);
357: 		}
358: 		result->select_list.push_back(move(expr));
359: 		if (i < result->column_count) {
360: 			result->types.push_back(result_type);
361: 		}
362: 		internal_sql_types.push_back(result_type);
363: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
364: 			select_binder.ResetBindings();
365: 		}
366: 	}
367: 	result->need_prune = result->select_list.size() > result->column_count;
368: 
369: 	// in the normal select binder, we bind columns as if there is no aggregation
370: 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
371: 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
372: 	// we choose the former one [CONTROVERSIAL: this is the PostgreSQL behavior]
373: 	if (!result->groups.group_expressions.empty() || !result->aggregates.empty() || statement.having ||
374: 	    !result->groups.grouping_sets.empty()) {
375: 		if (statement.aggregate_handling == AggregateHandling::NO_AGGREGATES_ALLOWED) {
376: 			throw BinderException("Aggregates cannot be present in a Project relation!");
377: 		} else if (statement.aggregate_handling == AggregateHandling::STANDARD_HANDLING) {
378: 			if (select_binder.HasBoundColumns()) {
379: 				auto &bound_columns = select_binder.GetBoundColumns();
380: 				throw BinderException(
381: 				    FormatError(bound_columns[0].query_location,
382: 				                "column \"%s\" must appear in the GROUP BY clause or be used in an aggregate function",
383: 				                bound_columns[0].name));
384: 			}
385: 		}
386: 	}
387: 
388: 	// QUALIFY clause requires at least one window function to be specified in at least one of the SELECT column list or
389: 	// the filter predicate of the QUALIFY clause
390: 	if (statement.qualify && result->windows.empty()) {
391: 		throw BinderException("at least one window function must appear in the SELECT column or QUALIFY clause");
392: 	}
393: 
394: 	// now that the SELECT list is bound, we set the types of DISTINCT/ORDER BY expressions
395: 	BindModifierTypes(*result, internal_sql_types, result->projection_index);
396: 	return move(result);
397: }
398: 
399: } // namespace duckdb
[end of src/planner/binder/query_node/bind_select_node.cpp]
[start of src/planner/binder/query_node/plan_select_node.cpp]
1: #include "duckdb/planner/binder.hpp"
2: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
3: #include "duckdb/planner/expression/bound_reference_expression.hpp"
4: #include "duckdb/planner/operator/list.hpp"
5: #include "duckdb/planner/operator/logical_expression_get.hpp"
6: #include "duckdb/planner/operator/logical_limit.hpp"
7: #include "duckdb/planner/operator/logical_limit_percent.hpp"
8: #include "duckdb/planner/query_node/bound_select_node.hpp"
9: #include "duckdb/planner/operator/logical_dummy_scan.hpp"
10: 
11: namespace duckdb {
12: 
13: unique_ptr<LogicalOperator> Binder::PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root) {
14: 	PlanSubqueries(&condition, &root);
15: 	auto filter = make_unique<LogicalFilter>(move(condition));
16: 	filter->AddChild(move(root));
17: 	return move(filter);
18: }
19: 
20: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundSelectNode &statement) {
21: 	unique_ptr<LogicalOperator> root;
22: 	D_ASSERT(statement.from_table);
23: 	root = CreatePlan(*statement.from_table);
24: 	D_ASSERT(root);
25: 
26: 	// plan the sample clause
27: 	if (statement.sample_options) {
28: 		root = make_unique<LogicalSample>(move(statement.sample_options), move(root));
29: 	}
30: 
31: 	if (statement.where_clause) {
32: 		root = PlanFilter(move(statement.where_clause), move(root));
33: 	}
34: 
35: 	if (!statement.aggregates.empty() || !statement.groups.group_expressions.empty()) {
36: 		if (!statement.groups.group_expressions.empty()) {
37: 			// visit the groups
38: 			for (auto &group : statement.groups.group_expressions) {
39: 				PlanSubqueries(&group, &root);
40: 			}
41: 		}
42: 		// now visit all aggregate expressions
43: 		for (auto &expr : statement.aggregates) {
44: 			PlanSubqueries(&expr, &root);
45: 		}
46: 		// finally create the aggregate node with the group_index and aggregate_index as obtained from the binder
47: 		auto aggregate =
48: 		    make_unique<LogicalAggregate>(statement.group_index, statement.aggregate_index, move(statement.aggregates));
49: 		aggregate->groups = move(statement.groups.group_expressions);
50: 		aggregate->groupings_index = statement.groupings_index;
51: 		aggregate->grouping_sets = move(statement.groups.grouping_sets);
52: 		aggregate->grouping_functions = move(statement.grouping_functions);
53: 
54: 		aggregate->AddChild(move(root));
55: 		root = move(aggregate);
56: 	} else if (!statement.groups.grouping_sets.empty()) {
57: 		// edge case: we have grouping sets but no groups or aggregates
58: 		// this can only happen if we have e.g. select 1 from tbl group by ();
59: 		// just output a dummy scan
60: 		root = make_unique_base<LogicalOperator, LogicalDummyScan>(statement.group_index);
61: 	}
62: 
63: 	if (statement.having) {
64: 		PlanSubqueries(&statement.having, &root);
65: 		auto having = make_unique<LogicalFilter>(move(statement.having));
66: 
67: 		having->AddChild(move(root));
68: 		root = move(having);
69: 	}
70: 
71: 	if (!statement.windows.empty()) {
72: 		auto win = make_unique<LogicalWindow>(statement.window_index);
73: 		win->expressions = move(statement.windows);
74: 		// visit the window expressions
75: 		for (auto &expr : win->expressions) {
76: 			PlanSubqueries(&expr, &root);
77: 		}
78: 		D_ASSERT(!win->expressions.empty());
79: 		win->AddChild(move(root));
80: 		root = move(win);
81: 	}
82: 
83: 	if (statement.qualify) {
84: 		PlanSubqueries(&statement.qualify, &root);
85: 		auto qualify = make_unique<LogicalFilter>(move(statement.qualify));
86: 
87: 		qualify->AddChild(move(root));
88: 		root = move(qualify);
89: 	}
90: 
91: 	if (!statement.unnests.empty()) {
92: 		auto unnest = make_unique<LogicalUnnest>(statement.unnest_index);
93: 		unnest->expressions = move(statement.unnests);
94: 		// visit the unnest expressions
95: 		for (auto &expr : unnest->expressions) {
96: 			PlanSubqueries(&expr, &root);
97: 		}
98: 		D_ASSERT(!unnest->expressions.empty());
99: 		unnest->AddChild(move(root));
100: 		root = move(unnest);
101: 	}
102: 
103: 	for (auto &expr : statement.select_list) {
104: 		PlanSubqueries(&expr, &root);
105: 	}
106: 
107: 	for (size_t i = 0; i < statement.modifiers.size(); i++) {
108: 		auto &modifier = statement.modifiers[i];
109: 		unique_ptr<LogicalOperator> limit = nullptr;
110: 		if (modifier->type == ResultModifierType::LIMIT_MODIFIER) {
111: 			auto &limit_modifier = (BoundLimitModifier &)*modifier;
112: 			if (limit_modifier.limit || limit_modifier.offset) {
113: 				PlanSubqueries(&limit_modifier.limit, &root);
114: 				PlanSubqueries(&limit_modifier.offset, &root);
115: 				limit = make_unique<LogicalLimit>(limit_modifier.limit_val, limit_modifier.offset_val,
116: 				                                  move(limit_modifier.limit), move(limit_modifier.offset));
117: 			}
118: 		} else if (modifier->type == ResultModifierType::LIMIT_PERCENT_MODIFIER) {
119: 			auto &limit_modifier = (BoundLimitPercentModifier &)*modifier;
120: 			if (limit_modifier.limit || limit_modifier.offset) {
121: 				PlanSubqueries(&limit_modifier.limit, &root);
122: 				PlanSubqueries(&limit_modifier.offset, &root);
123: 				limit = make_unique<LogicalLimitPercent>(limit_modifier.limit_percent, limit_modifier.offset_val,
124: 				                                         move(limit_modifier.limit), move(limit_modifier.offset));
125: 			}
126: 		}
127: 		if (limit) {
128: 			limit->AddChild(move(root));
129: 			root = move(limit);
130: 			// Delete from modifiers
131: 			std::swap(statement.modifiers[i], statement.modifiers.back());
132: 			statement.modifiers.erase(statement.modifiers.end() - 1);
133: 			i--;
134: 		}
135: 	}
136: 
137: 	// create the projection
138: 	auto proj = make_unique<LogicalProjection>(statement.projection_index, move(statement.select_list));
139: 	auto &projection = *proj;
140: 	proj->AddChild(move(root));
141: 	root = move(proj);
142: 
143: 	// finish the plan by handling the elements of the QueryNode
144: 	root = VisitQueryNode(statement, move(root));
145: 
146: 	// add a prune node if necessary
147: 	if (statement.need_prune) {
148: 		D_ASSERT(root);
149: 		vector<unique_ptr<Expression>> prune_expressions;
150: 		for (idx_t i = 0; i < statement.column_count; i++) {
151: 			prune_expressions.push_back(make_unique<BoundColumnRefExpression>(
152: 			    projection.expressions[i]->return_type, ColumnBinding(statement.projection_index, i)));
153: 		}
154: 		auto prune = make_unique<LogicalProjection>(statement.prune_index, move(prune_expressions));
155: 		prune->AddChild(move(root));
156: 		root = move(prune);
157: 	}
158: 	return root;
159: }
160: 
161: } // namespace duckdb
[end of src/planner/binder/query_node/plan_select_node.cpp]
[start of src/planner/expression_binder/order_binder.cpp]
1: #include "duckdb/planner/expression_binder/order_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/expression/positional_reference_expression.hpp"
5: #include "duckdb/parser/expression/constant_expression.hpp"
6: #include "duckdb/parser/expression/star_expression.hpp"
7: #include "duckdb/parser/query_node/select_node.hpp"
8: #include "duckdb/planner/expression_binder.hpp"
9: 
10: namespace duckdb {
11: 
12: OrderBinder::OrderBinder(vector<Binder *> binders, idx_t projection_index, case_insensitive_map_t<idx_t> &alias_map,
13:                          expression_map_t<idx_t> &projection_map, idx_t max_count)
14:     : binders(move(binders)), projection_index(projection_index), max_count(max_count), extra_list(nullptr),
15:       alias_map(alias_map), projection_map(projection_map) {
16: }
17: OrderBinder::OrderBinder(vector<Binder *> binders, idx_t projection_index, SelectNode &node,
18:                          case_insensitive_map_t<idx_t> &alias_map, expression_map_t<idx_t> &projection_map)
19:     : binders(move(binders)), projection_index(projection_index), alias_map(alias_map), projection_map(projection_map) {
20: 	this->max_count = node.select_list.size();
21: 	this->extra_list = &node.select_list;
22: }
23: 
24: unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &expr, idx_t index) {
25: 	string alias;
26: 	if (extra_list && index < extra_list->size()) {
27: 		alias = extra_list->at(index)->ToString();
28: 	} else {
29: 		alias = expr.GetName();
30: 	}
31: 	return make_unique<BoundColumnRefExpression>(move(alias), LogicalType::INVALID,
32: 	                                             ColumnBinding(projection_index, index));
33: }
34: 
35: unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {
36: 	// in the ORDER BY clause we do not bind children
37: 	// we bind ONLY to the select list
38: 	// if there is no matching entry in the SELECT list already, we add the expression to the SELECT list and refer the
39: 	// new expression the new entry will then be bound later during the binding of the SELECT list we also don't do type
40: 	// resolution here: this only happens after the SELECT list has been bound
41: 	switch (expr->expression_class) {
42: 	case ExpressionClass::CONSTANT: {
43: 		// ORDER BY constant
44: 		// is the ORDER BY expression a constant integer? (e.g. ORDER BY 1)
45: 		auto &constant = (ConstantExpression &)*expr;
46: 		// ORDER BY a constant
47: 		if (!constant.value.type().IsIntegral()) {
48: 			// non-integral expression, we just leave the constant here.
49: 			// ORDER BY <constant> has no effect
50: 			// CONTROVERSIAL: maybe we should throw an error
51: 			return nullptr;
52: 		}
53: 		// INTEGER constant: we use the integer as an index into the select list (e.g. ORDER BY 1)
54: 		auto index = (idx_t)constant.value.GetValue<int64_t>();
55: 		if (index < 1 || index > max_count) {
56: 			throw BinderException("ORDER term out of range - should be between 1 and %lld", (idx_t)max_count);
57: 		}
58: 		return CreateProjectionReference(*expr, index - 1);
59: 	}
60: 	case ExpressionClass::COLUMN_REF: {
61: 		// COLUMN REF expression
62: 		// check if we can bind it to an alias in the select list
63: 		auto &colref = (ColumnRefExpression &)*expr;
64: 		// if there is an explicit table name we can't bind to an alias
65: 		if (colref.IsQualified()) {
66: 			break;
67: 		}
68: 		// check the alias list
69: 		auto entry = alias_map.find(colref.column_names[0]);
70: 		if (entry != alias_map.end()) {
71: 			// it does! point it to that entry
72: 			return CreateProjectionReference(*expr, entry->second);
73: 		}
74: 		break;
75: 	}
76: 	case ExpressionClass::POSITIONAL_REFERENCE: {
77: 		auto &posref = (PositionalReferenceExpression &)*expr;
78: 		return CreateProjectionReference(*expr, posref.index - 1);
79: 	}
80: 	default:
81: 		break;
82: 	}
83: 	// general case
84: 	// first bind the table names of this entry
85: 	for (auto &binder : binders) {
86: 		ExpressionBinder::QualifyColumnNames(*binder, expr);
87: 	}
88: 	// first check if the ORDER BY clause already points to an entry in the projection list
89: 	auto entry = projection_map.find(expr.get());
90: 	if (entry != projection_map.end()) {
91: 		if (entry->second == DConstants::INVALID_INDEX) {
92: 			throw BinderException("Ambiguous reference to column");
93: 		}
94: 		// there is a matching entry in the projection list
95: 		// just point to that entry
96: 		return CreateProjectionReference(*expr, entry->second);
97: 	}
98: 	if (!extra_list) {
99: 		// no extra list specified: we cannot push an extra ORDER BY clause
100: 		throw BinderException("Could not ORDER BY column \"%s\": add the expression/function to every SELECT, or move "
101: 		                      "the UNION into a FROM clause.",
102: 		                      expr->ToString());
103: 	}
104: 	// otherwise we need to push the ORDER BY entry into the select list
105: 	auto result = CreateProjectionReference(*expr, extra_list->size());
106: 	extra_list->push_back(move(expr));
107: 	return result;
108: }
109: 
110: } // namespace duckdb
[end of src/planner/expression_binder/order_binder.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: