{
  "repo": "duckdb/duckdb",
  "pull_number": 11825,
  "instance_id": "duckdb__duckdb-11825",
  "issue_numbers": [
    "11798",
    "11798"
  ],
  "base_commit": "e356a1a252d1bb3e5b71da635bc9f22732a3dbf0",
  "patch": "diff --git a/extension/json/json_functions/copy_json.cpp b/extension/json/json_functions/copy_json.cpp\nindex 4744e5a78c82..c700397b86c5 100644\n--- a/extension/json/json_functions/copy_json.cpp\n+++ b/extension/json/json_functions/copy_json.cpp\n@@ -58,7 +58,7 @@ static BoundStatement CopyToJSONPlan(Binder &binder, CopyStatement &stmt) {\n \t}\n \n \t// Bind the select statement of the original to resolve the types\n-\tauto dummy_binder = Binder::CreateBinder(binder.context, &binder, true);\n+\tauto dummy_binder = Binder::CreateBinder(binder.context, &binder);\n \tauto bound_original = dummy_binder->Bind(*stmt.select_statement);\n \n \t// Create new SelectNode with the original SelectNode as a subquery in the FROM clause\ndiff --git a/src/common/enum_util.cpp b/src/common/enum_util.cpp\nindex 12a94a2b0f1c..d396c3dbdb21 100644\n--- a/src/common/enum_util.cpp\n+++ b/src/common/enum_util.cpp\n@@ -599,6 +599,29 @@ ArrowVariableSizeType EnumUtil::FromString<ArrowVariableSizeType>(const char *va\n \tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%s' not implemented\", value));\n }\n \n+template<>\n+const char* EnumUtil::ToChars<BinderType>(BinderType value) {\n+\tswitch(value) {\n+\tcase BinderType::REGULAR_BINDER:\n+\t\treturn \"REGULAR_BINDER\";\n+\tcase BinderType::VIEW_BINDER:\n+\t\treturn \"VIEW_BINDER\";\n+\tdefault:\n+\t\tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%d' not implemented\", value));\n+\t}\n+}\n+\n+template<>\n+BinderType EnumUtil::FromString<BinderType>(const char *value) {\n+\tif (StringUtil::Equals(value, \"REGULAR_BINDER\")) {\n+\t\treturn BinderType::REGULAR_BINDER;\n+\t}\n+\tif (StringUtil::Equals(value, \"VIEW_BINDER\")) {\n+\t\treturn BinderType::VIEW_BINDER;\n+\t}\n+\tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%s' not implemented\", value));\n+}\n+\n template<>\n const char* EnumUtil::ToChars<BindingMode>(BindingMode value) {\n \tswitch(value) {\ndiff --git a/src/include/duckdb/common/enum_util.hpp b/src/include/duckdb/common/enum_util.hpp\nindex 81b670cd74b5..39bafdec9fee 100644\n--- a/src/include/duckdb/common/enum_util.hpp\n+++ b/src/include/duckdb/common/enum_util.hpp\n@@ -62,6 +62,8 @@ enum class ArrowOffsetSize : uint8_t;\n \n enum class ArrowVariableSizeType : uint8_t;\n \n+enum class BinderType : uint8_t;\n+\n enum class BindingMode : uint8_t;\n \n enum class BitpackingMode : uint8_t;\n@@ -370,6 +372,9 @@ const char* EnumUtil::ToChars<ArrowOffsetSize>(ArrowOffsetSize value);\n template<>\n const char* EnumUtil::ToChars<ArrowVariableSizeType>(ArrowVariableSizeType value);\n \n+template<>\n+const char* EnumUtil::ToChars<BinderType>(BinderType value);\n+\n template<>\n const char* EnumUtil::ToChars<BindingMode>(BindingMode value);\n \n@@ -809,6 +814,9 @@ ArrowOffsetSize EnumUtil::FromString<ArrowOffsetSize>(const char *value);\n template<>\n ArrowVariableSizeType EnumUtil::FromString<ArrowVariableSizeType>(const char *value);\n \n+template<>\n+BinderType EnumUtil::FromString<BinderType>(const char *value);\n+\n template<>\n BindingMode EnumUtil::FromString<BindingMode>(const char *value);\n \ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex c2afbc1b8f5a..e05b287773b4 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -56,6 +56,7 @@ struct PivotColumnEntry;\n struct UnpivotEntry;\n \n enum class BindingMode : uint8_t { STANDARD_BINDING, EXTRACT_NAMES };\n+enum class BinderType : uint8_t { REGULAR_BINDER, VIEW_BINDER };\n \n struct CorrelatedColumnInfo {\n \tColumnBinding binding;\n@@ -88,7 +89,7 @@ class Binder : public enable_shared_from_this<Binder> {\n \n public:\n \tDUCKDB_API static shared_ptr<Binder> CreateBinder(ClientContext &context, optional_ptr<Binder> parent = nullptr,\n-\t                                                  bool inherit_ctes = true);\n+\t                                                  BinderType binder_type = BinderType::REGULAR_BINDER);\n \n \t//! The client context\n \tClientContext &context;\n@@ -209,8 +210,8 @@ class Binder : public enable_shared_from_this<Binder> {\n \tbool has_unplanned_dependent_joins = false;\n \t//! Whether or not outside dependent joins have been planned and flattened\n \tbool is_outside_flattened = true;\n-\t//! Whether CTEs should reference the parent binder (if it exists)\n-\tbool inherit_ctes = true;\n+\t//! What kind of node we are binding using this binder\n+\tBinderType binder_type = BinderType::REGULAR_BINDER;\n \t//! Whether or not the binder can contain NULLs as the root of expressions\n \tbool can_contain_nulls = false;\n \t//! The root statement of the query that is currently being parsed\n@@ -392,7 +393,7 @@ class Binder : public enable_shared_from_this<Binder> {\n public:\n \t// This should really be a private constructor, but make_shared_ptr does not allow it...\n \t// If you are thinking about calling this, you should probably call Binder::CreateBinder\n-\tBinder(bool i_know_what_i_am_doing, ClientContext &context, shared_ptr<Binder> parent, bool inherit_ctes);\n+\tBinder(bool i_know_what_i_am_doing, ClientContext &context, shared_ptr<Binder> parent, BinderType binder_type);\n };\n \n } // namespace duckdb\ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex 66d0949ddd5f..188cbb99f9db 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -40,26 +40,25 @@ idx_t Binder::GetBinderDepth() const {\n \treturn depth;\n }\n \n-shared_ptr<Binder> Binder::CreateBinder(ClientContext &context, optional_ptr<Binder> parent, bool inherit_ctes) {\n+shared_ptr<Binder> Binder::CreateBinder(ClientContext &context, optional_ptr<Binder> parent, BinderType binder_type) {\n \tauto depth = parent ? parent->GetBinderDepth() : 0;\n \tif (depth > context.config.max_expression_depth) {\n \t\tthrow BinderException(\"Max expression depth limit of %lld exceeded. Use \\\"SET max_expression_depth TO x\\\" to \"\n \t\t                      \"increase the maximum expression depth.\",\n \t\t                      context.config.max_expression_depth);\n \t}\n-\treturn make_shared_ptr<Binder>(true, context, parent ? parent->shared_from_this() : nullptr, inherit_ctes);\n+\treturn make_shared_ptr<Binder>(true, context, parent ? parent->shared_from_this() : nullptr, binder_type);\n }\n \n-Binder::Binder(bool, ClientContext &context, shared_ptr<Binder> parent_p, bool inherit_ctes_p)\n-    : context(context), bind_context(*this), parent(std::move(parent_p)), bound_tables(0),\n-      inherit_ctes(inherit_ctes_p) {\n+Binder::Binder(bool, ClientContext &context, shared_ptr<Binder> parent_p, BinderType binder_type)\n+    : context(context), bind_context(*this), parent(std::move(parent_p)), bound_tables(0), binder_type(binder_type) {\n \tif (parent) {\n \n \t\t// We have to inherit macro and lambda parameter bindings and from the parent binder, if there is a parent.\n \t\tmacro_binding = parent->macro_binding;\n \t\tlambda_bindings = parent->lambda_bindings;\n \n-\t\tif (inherit_ctes) {\n+\t\tif (binder_type == BinderType::REGULAR_BINDER) {\n \t\t\t// We have to inherit CTE bindings from the parent bind_context, if there is a parent.\n \t\t\tbind_context.SetCTEBindings(parent->bind_context.GetCTEBindings());\n \t\t\tbind_context.cte_references = parent->bind_context.cte_references;\n@@ -342,7 +341,7 @@ vector<reference<CommonTableExpressionInfo>> Binder::FindCTE(const string &name,\n \t\t\tctes.push_back(entry->second);\n \t\t}\n \t}\n-\tif (parent && inherit_ctes) {\n+\tif (parent && binder_type == BinderType::REGULAR_BINDER) {\n \t\tauto parent_ctes = parent->FindCTE(name, name == alias);\n \t\tctes.insert(ctes.end(), parent_ctes.begin(), parent_ctes.end());\n \t}\n@@ -353,7 +352,7 @@ bool Binder::CTEIsAlreadyBound(CommonTableExpressionInfo &cte) {\n \tif (bound_ctes.find(cte) != bound_ctes.end()) {\n \t\treturn true;\n \t}\n-\tif (parent && inherit_ctes) {\n+\tif (parent && binder_type == BinderType::REGULAR_BINDER) {\n \t\treturn parent->CTEIsAlreadyBound(cte);\n \t}\n \treturn false;\n@@ -399,7 +398,11 @@ bool Binder::HasActiveBinder() {\n }\n \n vector<reference<ExpressionBinder>> &Binder::GetActiveBinders() {\n-\tauto &root_binder = GetRootBinder();\n+\treference<Binder> root = *this;\n+\twhile (root.get().parent && root.get().binder_type == BinderType::REGULAR_BINDER) {\n+\t\troot = *root.get().parent;\n+\t}\n+\tauto &root_binder = root.get();\n \treturn root_binder.active_binders;\n }\n \ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 8c557a45151f..b434cb812c43 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -45,7 +45,7 @@ unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, un\n \n BoundLimitNode Binder::BindLimitValue(OrderBinder &order_binder, unique_ptr<ParsedExpression> limit_val,\n                                       bool is_percentage, bool is_offset) {\n-\tauto new_binder = Binder::CreateBinder(context, this, true);\n+\tauto new_binder = Binder::CreateBinder(context, this);\n \tExpressionBinder expr_binder(*new_binder, context);\n \tauto target_type = is_percentage ? LogicalType::DOUBLE : LogicalType::BIGINT;\n \texpr_binder.target_type = target_type;\ndiff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex 30b2b2640eb4..f850f7d93da4 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -231,8 +231,7 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \t\t// We need to use a new binder for the view that doesn't reference any CTEs\n \t\t// defined for this binder so there are no collisions between the CTEs defined\n \t\t// for the view and for the current query\n-\t\tbool inherit_ctes = false;\n-\t\tauto view_binder = Binder::CreateBinder(context, this, inherit_ctes);\n+\t\tauto view_binder = Binder::CreateBinder(context, this, BinderType::VIEW_BINDER);\n \t\tview_binder->can_contain_nulls = true;\n \t\tSubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(view_catalog_entry.query->Copy()));\n \t\tsubquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;\ndiff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp\nindex be9848683b54..4ba5dba0731c 100644\n--- a/src/planner/binder/tableref/bind_table_function.cpp\n+++ b/src/planner/binder/tableref/bind_table_function.cpp\n@@ -31,7 +31,7 @@ static bool IsTableInTableOutFunction(TableFunctionCatalogEntry &table_function)\n \n bool Binder::BindTableInTableOutFunction(vector<unique_ptr<ParsedExpression>> &expressions,\n                                          unique_ptr<BoundSubqueryRef> &subquery, ErrorData &error) {\n-\tauto binder = Binder::CreateBinder(this->context, this, true);\n+\tauto binder = Binder::CreateBinder(this->context, this);\n \tunique_ptr<QueryNode> subquery_node;\n \tif (expressions.size() == 1 && expressions[0]->type == ExpressionType::SUBQUERY) {\n \t\t// general case: argument is a subquery, bind it as part of the node\n@@ -91,7 +91,7 @@ bool Binder::BindTableFunctionParameters(TableFunctionCatalogEntry &table_functi\n \t\t\t\terror = ErrorData(\"Table function can have at most one subquery parameter\");\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tauto binder = Binder::CreateBinder(this->context, this, true);\n+\t\t\tauto binder = Binder::CreateBinder(this->context, this);\n \t\t\tauto &se = child->Cast<SubqueryExpression>();\n \t\t\tauto node = binder->BindNode(*se.subquery->node);\n \t\t\tsubquery = make_uniq<BoundSubqueryRef>(std::move(binder), std::move(node));\n",
  "test_patch": "diff --git a/test/fuzzer/pedro/view_not_rebound_error.test b/test/fuzzer/pedro/view_not_rebound_error.test\nindex 5906b17648e8..bd81e0a7d735 100644\n--- a/test/fuzzer/pedro/view_not_rebound_error.test\n+++ b/test/fuzzer/pedro/view_not_rebound_error.test\n@@ -19,4 +19,3 @@ CREATE TABLE t1 (c2 INT);\n statement error\n SELECT 1 FROM t2 JOIN t1 ON (SELECT TRUE FROM t0);\n ----\n-Contents of view were altered\ndiff --git a/test/sql/subquery/lateral/lateral_binding_views.test b/test/sql/subquery/lateral/lateral_binding_views.test\nnew file mode 100644\nindex 000000000000..3fb630e907e8\n--- /dev/null\n+++ b/test/sql/subquery/lateral/lateral_binding_views.test\n@@ -0,0 +1,19 @@\n+# name: test/sql/subquery/lateral/lateral_binding_views.test\n+# description: Verify that views cannot reference lateral join columns\n+# group: [lateral]\n+\n+statement ok\n+copy (select date '2000-01-01' as dt) to '__TEST_DIR__/datetest.csv';\n+\n+statement ok\n+create view v1 as select * from read_csv('__TEST_DIR__/datetest.csv', columns={'dt': date});\n+\n+query I\n+from v1\n+----\n+2000-01-01\n+\n+query II\n+select * from (select date '1992-01-01' as date), v1;\n+----\n+1992-01-01\t2000-01-01\n",
  "problem_statement": "Table function \"read_csv\" does not support lateral join column parameters\n### What happens?\n\nAfter upgrading from 0.10.1 to 0.10.2, I get the error \"Table function \"read_csv\" does not support lateral join column parameters\".\n\n### To Reproduce\n\nThe error comes from the second statement below. I have simplified it as much as possible.\r\n\r\ndb.execute(\"\"\"--sql\r\n  CREATE OR REPLACE VIEW actions AS\r\n           SELECT *\r\n           FROM read_csv('nasdaq-data-link/SHARADAR/ACTIONS-2024-04-23.csv.zst', columns={'date': date, 'action': varchar, 'ticker': varchar, 'name': varchar, 'value': varchar, 'contraticker': varchar, 'contraname': varchar}, header=true, dateformat='%Y-%m-%d')\r\n\"\"\")\r\n\r\ndb.execute(\"\"\"--sql\r\n   CREATE OR REPLACE VIEW symbolchanges AS\r\n            SELECT *\r\n            FROM actions f\r\n            INNER JOIN actions t ON f.ticker = t.ticker\r\n\"\"\")\n\n### OS:\n\nLinux PopOS x64\n\n### DuckDB Version:\n\n0.10.2 (via pip)\n\n### DuckDB Client:\n\nPython 3.11.7\n\n### Full Name:\n\nLaurent Debacker\n\n### Affiliation:\n\nPersonal research\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNo - I cannot share the data sets because they are confidential\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\nTable function \"read_csv\" does not support lateral join column parameters\n### What happens?\n\nAfter upgrading from 0.10.1 to 0.10.2, I get the error \"Table function \"read_csv\" does not support lateral join column parameters\".\n\n### To Reproduce\n\nThe error comes from the second statement below. I have simplified it as much as possible.\r\n\r\ndb.execute(\"\"\"--sql\r\n  CREATE OR REPLACE VIEW actions AS\r\n           SELECT *\r\n           FROM read_csv('nasdaq-data-link/SHARADAR/ACTIONS-2024-04-23.csv.zst', columns={'date': date, 'action': varchar, 'ticker': varchar, 'name': varchar, 'value': varchar, 'contraticker': varchar, 'contraname': varchar}, header=true, dateformat='%Y-%m-%d')\r\n\"\"\")\r\n\r\ndb.execute(\"\"\"--sql\r\n   CREATE OR REPLACE VIEW symbolchanges AS\r\n            SELECT *\r\n            FROM actions f\r\n            INNER JOIN actions t ON f.ticker = t.ticker\r\n\"\"\")\n\n### OS:\n\nLinux PopOS x64\n\n### DuckDB Version:\n\n0.10.2 (via pip)\n\n### DuckDB Client:\n\nPython 3.11.7\n\n### Full Name:\n\nLaurent Debacker\n\n### Affiliation:\n\nPersonal research\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNo - I cannot share the data sets because they are confidential\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "Thanks for opening this issue! Based on our automated check, it seems that your post contains some code but it does not use [code blocks](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-and-highlighting-code-blocks) to format it.\n          \nPlease double-check your post and revise it if necessary. To employ syntax highlighting, it's recommended to use code blocks with triple backticks, e.g.:\n````\n```sql\nSELECT ...\n```\n````\nIf this is a false positive, feel free to disregard this comment.\n\nThanks for opening this issue! Based on our automated check, it seems that your post contains some code but it does not use [code blocks](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-and-highlighting-code-blocks) to format it.\n          \nPlease double-check your post and revise it if necessary. To employ syntax highlighting, it's recommended to use code blocks with triple backticks, e.g.:\n````\n```sql\nSELECT ...\n```\n````\nIf this is a false positive, feel free to disregard this comment.\n",
  "created_at": "2024-04-25T07:34:22Z"
}