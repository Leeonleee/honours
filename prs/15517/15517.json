{
  "repo": "duckdb/duckdb",
  "pull_number": 15517,
  "instance_id": "duckdb__duckdb-15517",
  "issue_numbers": [
    "15428"
  ],
  "base_commit": "30c80bb3111b2ac8db37d31d71e971d47768987c",
  "patch": "diff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex 5ebd56819ba1..156be1e5ddcf 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -389,184 +389,6 @@ void Binder::BindLogicalType(LogicalType &type, optional_ptr<Catalog> catalog, c\n \t}\n }\n \n-static void FindMatchingPrimaryKeyColumns(const ColumnList &columns, const vector<unique_ptr<Constraint>> &constraints,\n-                                          ForeignKeyConstraint &fk) {\n-\t// find the matching primary key constraint\n-\tbool found_constraint = false;\n-\t// if no columns are defined, we will automatically try to bind to the primary key\n-\tbool find_primary_key = fk.pk_columns.empty();\n-\tfor (auto &constr : constraints) {\n-\t\tif (constr->type != ConstraintType::UNIQUE) {\n-\t\t\tcontinue;\n-\t\t}\n-\t\tauto &unique = constr->Cast<UniqueConstraint>();\n-\t\tif (find_primary_key && !unique.IsPrimaryKey()) {\n-\t\t\tcontinue;\n-\t\t}\n-\t\tfound_constraint = true;\n-\n-\t\tvector<string> pk_names;\n-\t\tif (unique.HasIndex()) {\n-\t\t\tpk_names.push_back(columns.GetColumn(LogicalIndex(unique.GetIndex())).Name());\n-\t\t} else {\n-\t\t\tpk_names = unique.GetColumnNames();\n-\t\t}\n-\t\tif (find_primary_key) {\n-\t\t\t// found matching primary key\n-\t\t\tif (pk_names.size() != fk.fk_columns.size()) {\n-\t\t\t\tauto pk_name_str = StringUtil::Join(pk_names, \",\");\n-\t\t\t\tauto fk_name_str = StringUtil::Join(fk.fk_columns, \",\");\n-\t\t\t\tthrow BinderException(\n-\t\t\t\t    \"Failed to create foreign key: number of referencing (%s) and referenced columns (%s) differ\",\n-\t\t\t\t    fk_name_str, pk_name_str);\n-\t\t\t}\n-\t\t\tfk.pk_columns = pk_names;\n-\t\t\treturn;\n-\t\t}\n-\t\tif (pk_names.size() != fk.fk_columns.size()) {\n-\t\t\t// the number of referencing and referenced columns for foreign keys must be the same\n-\t\t\tcontinue;\n-\t\t}\n-\t\tbool equals = true;\n-\t\tfor (idx_t i = 0; i < fk.pk_columns.size(); i++) {\n-\t\t\tif (!StringUtil::CIEquals(fk.pk_columns[i], pk_names[i])) {\n-\t\t\t\tequals = false;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\tif (!equals) {\n-\t\t\tcontinue;\n-\t\t}\n-\t\t// found match\n-\t\treturn;\n-\t}\n-\t// no match found! examine why\n-\tif (!found_constraint) {\n-\t\t// no unique constraint or primary key\n-\t\tstring search_term = find_primary_key ? \"primary key\" : \"primary key or unique constraint\";\n-\t\tthrow BinderException(\"Failed to create foreign key: there is no %s for referenced table \\\"%s\\\"\", search_term,\n-\t\t                      fk.info.table);\n-\t}\n-\t// check if all the columns exist\n-\tfor (auto &name : fk.pk_columns) {\n-\t\tbool found = columns.ColumnExists(name);\n-\t\tif (!found) {\n-\t\t\tthrow BinderException(\n-\t\t\t    \"Failed to create foreign key: referenced table \\\"%s\\\" does not have a column named \\\"%s\\\"\",\n-\t\t\t    fk.info.table, name);\n-\t\t}\n-\t}\n-\tauto fk_names = StringUtil::Join(fk.pk_columns, \",\");\n-\tthrow BinderException(\"Failed to create foreign key: referenced table \\\"%s\\\" does not have a primary key or unique \"\n-\t                      \"constraint on the columns %s\",\n-\t                      fk.info.table, fk_names);\n-}\n-\n-static void FindForeignKeyIndexes(const ColumnList &columns, const vector<string> &names,\n-                                  vector<PhysicalIndex> &indexes) {\n-\tD_ASSERT(indexes.empty());\n-\tD_ASSERT(!names.empty());\n-\tfor (auto &name : names) {\n-\t\tif (!columns.ColumnExists(name)) {\n-\t\t\tthrow BinderException(\"column \\\"%s\\\" named in key does not exist\", name);\n-\t\t}\n-\t\tauto &column = columns.GetColumn(name);\n-\t\tif (column.Generated()) {\n-\t\t\tthrow BinderException(\"Failed to create foreign key: referenced column \\\"%s\\\" is a generated column\",\n-\t\t\t                      column.Name());\n-\t\t}\n-\t\tindexes.push_back(column.Physical());\n-\t}\n-}\n-\n-static void CheckForeignKeyTypes(const ColumnList &pk_columns, const ColumnList &fk_columns, ForeignKeyConstraint &fk) {\n-\tD_ASSERT(fk.info.pk_keys.size() == fk.info.fk_keys.size());\n-\tfor (idx_t c_idx = 0; c_idx < fk.info.pk_keys.size(); c_idx++) {\n-\t\tauto &pk_col = pk_columns.GetColumn(fk.info.pk_keys[c_idx]);\n-\t\tauto &fk_col = fk_columns.GetColumn(fk.info.fk_keys[c_idx]);\n-\t\tif (pk_col.Type() != fk_col.Type()) {\n-\t\t\tthrow BinderException(\"Failed to create foreign key: incompatible types between column \\\"%s\\\" (\\\"%s\\\") and \"\n-\t\t\t                      \"column \\\"%s\\\" (\\\"%s\\\")\",\n-\t\t\t                      pk_col.Name(), pk_col.Type().ToString(), fk_col.Name(), fk_col.Type().ToString());\n-\t\t}\n-\t}\n-}\n-\n-void ExpressionContainsGeneratedColumn(const ParsedExpression &expr, const unordered_set<string> &gcols,\n-                                       bool &contains_gcol) {\n-\tif (contains_gcol) {\n-\t\treturn;\n-\t}\n-\tif (expr.GetExpressionType() == ExpressionType::COLUMN_REF) {\n-\t\tauto &column_ref = expr.Cast<ColumnRefExpression>();\n-\t\tauto &name = column_ref.GetColumnName();\n-\t\tif (gcols.count(name)) {\n-\t\t\tcontains_gcol = true;\n-\t\t\treturn;\n-\t\t}\n-\t}\n-\tParsedExpressionIterator::EnumerateChildren(\n-\t    expr, [&](const ParsedExpression &child) { ExpressionContainsGeneratedColumn(child, gcols, contains_gcol); });\n-}\n-\n-static bool AnyConstraintReferencesGeneratedColumn(CreateTableInfo &table_info) {\n-\tunordered_set<string> generated_columns;\n-\tfor (auto &col : table_info.columns.Logical()) {\n-\t\tif (!col.Generated()) {\n-\t\t\tcontinue;\n-\t\t}\n-\t\tgenerated_columns.insert(col.Name());\n-\t}\n-\tif (generated_columns.empty()) {\n-\t\treturn false;\n-\t}\n-\n-\tfor (auto &constr : table_info.constraints) {\n-\t\tswitch (constr->type) {\n-\t\tcase ConstraintType::CHECK: {\n-\t\t\tauto &constraint = constr->Cast<CheckConstraint>();\n-\t\t\tauto &expr = constraint.expression;\n-\t\t\tbool contains_generated_column = false;\n-\t\t\tExpressionContainsGeneratedColumn(*expr, generated_columns, contains_generated_column);\n-\t\t\tif (contains_generated_column) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase ConstraintType::NOT_NULL: {\n-\t\t\tauto &constraint = constr->Cast<NotNullConstraint>();\n-\t\t\tif (table_info.columns.GetColumn(constraint.index).Generated()) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase ConstraintType::UNIQUE: {\n-\t\t\tauto &constraint = constr->Cast<UniqueConstraint>();\n-\t\t\tif (!constraint.HasIndex()) {\n-\t\t\t\tfor (auto &col : constraint.GetColumnNames()) {\n-\t\t\t\t\tif (generated_columns.count(col)) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tif (table_info.columns.GetColumn(constraint.GetIndex()).Generated()) {\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase ConstraintType::FOREIGN_KEY: {\n-\t\t\t// If it contained a generated column, an exception would have been thrown inside AddDataTableIndex earlier\n-\t\t\tbreak;\n-\t\t}\n-\t\tdefault: {\n-\t\t\tthrow NotImplementedException(\"ConstraintType not implemented\");\n-\t\t}\n-\t\t}\n-\t}\n-\treturn false;\n-}\n-\n unique_ptr<LogicalOperator> DuckCatalog::BindCreateIndex(Binder &binder, CreateStatement &stmt,\n                                                          TableCatalogEntry &table, unique_ptr<LogicalOperator> plan) {\n \tD_ASSERT(plan->type == LogicalOperatorType::LOGICAL_GET);\n@@ -646,66 +468,8 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {\n \t\tbreak;\n \t}\n \tcase CatalogType::TABLE_ENTRY: {\n-\t\tauto &create_info = stmt.info->Cast<CreateTableInfo>();\n-\t\t// If there is a foreign key constraint, resolve primary key column's index from primary key column's name\n-\t\treference_set_t<SchemaCatalogEntry> fk_schemas;\n-\t\tfor (idx_t i = 0; i < create_info.constraints.size(); i++) {\n-\t\t\tauto &cond = create_info.constraints[i];\n-\t\t\tif (cond->type != ConstraintType::FOREIGN_KEY) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tauto &fk = cond->Cast<ForeignKeyConstraint>();\n-\t\t\tif (fk.info.type != ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tD_ASSERT(fk.info.pk_keys.empty());\n-\t\t\tD_ASSERT(fk.info.fk_keys.empty());\n-\t\t\tFindForeignKeyIndexes(create_info.columns, fk.fk_columns, fk.info.fk_keys);\n-\n-\t\t\t// Resolve the self-reference.\n-\t\t\tif (StringUtil::CIEquals(create_info.table, fk.info.table)) {\n-\t\t\t\tfk.info.type = ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE;\n-\t\t\t\tFindMatchingPrimaryKeyColumns(create_info.columns, create_info.constraints, fk);\n-\t\t\t\tFindForeignKeyIndexes(create_info.columns, fk.pk_columns, fk.info.pk_keys);\n-\t\t\t\tCheckForeignKeyTypes(create_info.columns, create_info.columns, fk);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t// Resolve the table reference.\n-\t\t\tauto table_entry =\n-\t\t\t    entry_retriever.GetEntry(CatalogType::TABLE_ENTRY, INVALID_CATALOG, fk.info.schema, fk.info.table);\n-\t\t\tif (table_entry->type == CatalogType::VIEW_ENTRY) {\n-\t\t\t\tthrow BinderException(\"cannot reference a VIEW with a FOREIGN KEY\");\n-\t\t\t}\n-\n-\t\t\tauto &pk_table_entry_ptr = table_entry->Cast<TableCatalogEntry>();\n-\t\t\tfk_schemas.insert(pk_table_entry_ptr.schema);\n-\t\t\tFindMatchingPrimaryKeyColumns(pk_table_entry_ptr.GetColumns(), pk_table_entry_ptr.GetConstraints(), fk);\n-\t\t\tFindForeignKeyIndexes(pk_table_entry_ptr.GetColumns(), fk.pk_columns, fk.info.pk_keys);\n-\t\t\tCheckForeignKeyTypes(pk_table_entry_ptr.GetColumns(), create_info.columns, fk);\n-\t\t\tauto &storage = pk_table_entry_ptr.GetStorage();\n-\n-\t\t\tif (!storage.HasForeignKeyIndex(fk.info.pk_keys, ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE)) {\n-\t\t\t\tauto fk_column_names = StringUtil::Join(fk.pk_columns, \",\");\n-\t\t\t\tthrow BinderException(\"Failed to create foreign key on %s(%s): no UNIQUE or PRIMARY KEY constraint \"\n-\t\t\t\t                      \"present on these columns\",\n-\t\t\t\t                      pk_table_entry_ptr.name, fk_column_names);\n-\t\t\t}\n-\n-\t\t\tD_ASSERT(fk.info.pk_keys.size() == fk.info.fk_keys.size());\n-\t\t\tD_ASSERT(fk.info.pk_keys.size() == fk.pk_columns.size());\n-\t\t\tD_ASSERT(fk.info.fk_keys.size() == fk.fk_columns.size());\n-\t\t}\n-\t\tif (AnyConstraintReferencesGeneratedColumn(create_info)) {\n-\t\t\tthrow BinderException(\"Constraints on generated columns are not supported yet\");\n-\t\t}\n \t\tauto bound_info = BindCreateTableInfo(std::move(stmt.info));\n \t\tauto root = std::move(bound_info->query);\n-\t\tfor (auto &fk_schema : fk_schemas) {\n-\t\t\tif (&fk_schema.get() != &bound_info->schema) {\n-\t\t\t\tthrow BinderException(\"Creating foreign keys across different schemas or catalogs is not supported\");\n-\t\t\t}\n-\t\t}\n \n \t\t// create the logical operator\n \t\tauto &schema = bound_info->schema;\ndiff --git a/src/planner/binder/statement/bind_create_table.cpp b/src/planner/binder/statement/bind_create_table.cpp\nindex 6a6bd564da23..80d50d074e00 100644\n--- a/src/planner/binder/statement/bind_create_table.cpp\n+++ b/src/planner/binder/statement/bind_create_table.cpp\n@@ -19,6 +19,8 @@\n #include \"duckdb/planner/expression_binder/index_binder.hpp\"\n #include \"duckdb/parser/parsed_data/create_index_info.hpp\"\n #include \"duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\"\n+#include \"duckdb/parser/parsed_expression_iterator.hpp\"\n+#include \"duckdb/storage/data_table.hpp\"\n \n namespace duckdb {\n \n@@ -309,6 +311,242 @@ unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableCheckpoint(unique_ptr<Cr\n \treturn result;\n }\n \n+void ExpressionContainsGeneratedColumn(const ParsedExpression &expr, const unordered_set<string> &gcols,\n+                                       bool &contains_gcol) {\n+\tif (contains_gcol) {\n+\t\treturn;\n+\t}\n+\tif (expr.GetExpressionType() == ExpressionType::COLUMN_REF) {\n+\t\tauto &column_ref = expr.Cast<ColumnRefExpression>();\n+\t\tauto &name = column_ref.GetColumnName();\n+\t\tif (gcols.count(name)) {\n+\t\t\tcontains_gcol = true;\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\tParsedExpressionIterator::EnumerateChildren(\n+\t    expr, [&](const ParsedExpression &child) { ExpressionContainsGeneratedColumn(child, gcols, contains_gcol); });\n+}\n+\n+static bool AnyConstraintReferencesGeneratedColumn(CreateTableInfo &table_info) {\n+\tunordered_set<string> generated_columns;\n+\tfor (auto &col : table_info.columns.Logical()) {\n+\t\tif (!col.Generated()) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tgenerated_columns.insert(col.Name());\n+\t}\n+\tif (generated_columns.empty()) {\n+\t\treturn false;\n+\t}\n+\n+\tfor (auto &constr : table_info.constraints) {\n+\t\tswitch (constr->type) {\n+\t\tcase ConstraintType::CHECK: {\n+\t\t\tauto &constraint = constr->Cast<CheckConstraint>();\n+\t\t\tauto &expr = constraint.expression;\n+\t\t\tbool contains_generated_column = false;\n+\t\t\tExpressionContainsGeneratedColumn(*expr, generated_columns, contains_generated_column);\n+\t\t\tif (contains_generated_column) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase ConstraintType::NOT_NULL: {\n+\t\t\tauto &constraint = constr->Cast<NotNullConstraint>();\n+\t\t\tif (table_info.columns.GetColumn(constraint.index).Generated()) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase ConstraintType::UNIQUE: {\n+\t\t\tauto &constraint = constr->Cast<UniqueConstraint>();\n+\t\t\tif (!constraint.HasIndex()) {\n+\t\t\t\tfor (auto &col : constraint.GetColumnNames()) {\n+\t\t\t\t\tif (generated_columns.count(col)) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (table_info.columns.GetColumn(constraint.GetIndex()).Generated()) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase ConstraintType::FOREIGN_KEY: {\n+\t\t\t// If it contained a generated column, an exception would have been thrown inside AddDataTableIndex earlier\n+\t\t\tbreak;\n+\t\t}\n+\t\tdefault: {\n+\t\t\tthrow NotImplementedException(\"ConstraintType not implemented\");\n+\t\t}\n+\t\t}\n+\t}\n+\treturn false;\n+}\n+\n+static void FindForeignKeyIndexes(const ColumnList &columns, const vector<string> &names,\n+                                  vector<PhysicalIndex> &indexes) {\n+\tD_ASSERT(indexes.empty());\n+\tD_ASSERT(!names.empty());\n+\tfor (auto &name : names) {\n+\t\tif (!columns.ColumnExists(name)) {\n+\t\t\tthrow BinderException(\"column \\\"%s\\\" named in key does not exist\", name);\n+\t\t}\n+\t\tauto &column = columns.GetColumn(name);\n+\t\tif (column.Generated()) {\n+\t\t\tthrow BinderException(\"Failed to create foreign key: referenced column \\\"%s\\\" is a generated column\",\n+\t\t\t                      column.Name());\n+\t\t}\n+\t\tindexes.push_back(column.Physical());\n+\t}\n+}\n+\n+static void FindMatchingPrimaryKeyColumns(const ColumnList &columns, const vector<unique_ptr<Constraint>> &constraints,\n+                                          ForeignKeyConstraint &fk) {\n+\t// find the matching primary key constraint\n+\tbool found_constraint = false;\n+\t// if no columns are defined, we will automatically try to bind to the primary key\n+\tbool find_primary_key = fk.pk_columns.empty();\n+\tfor (auto &constr : constraints) {\n+\t\tif (constr->type != ConstraintType::UNIQUE) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tauto &unique = constr->Cast<UniqueConstraint>();\n+\t\tif (find_primary_key && !unique.IsPrimaryKey()) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tfound_constraint = true;\n+\n+\t\tvector<string> pk_names;\n+\t\tif (unique.HasIndex()) {\n+\t\t\tpk_names.push_back(columns.GetColumn(LogicalIndex(unique.GetIndex())).Name());\n+\t\t} else {\n+\t\t\tpk_names = unique.GetColumnNames();\n+\t\t}\n+\t\tif (find_primary_key) {\n+\t\t\t// found matching primary key\n+\t\t\tif (pk_names.size() != fk.fk_columns.size()) {\n+\t\t\t\tauto pk_name_str = StringUtil::Join(pk_names, \",\");\n+\t\t\t\tauto fk_name_str = StringUtil::Join(fk.fk_columns, \",\");\n+\t\t\t\tthrow BinderException(\n+\t\t\t\t    \"Failed to create foreign key: number of referencing (%s) and referenced columns (%s) differ\",\n+\t\t\t\t    fk_name_str, pk_name_str);\n+\t\t\t}\n+\t\t\tfk.pk_columns = pk_names;\n+\t\t\treturn;\n+\t\t}\n+\t\tif (pk_names.size() != fk.fk_columns.size()) {\n+\t\t\t// the number of referencing and referenced columns for foreign keys must be the same\n+\t\t\tcontinue;\n+\t\t}\n+\t\tbool equals = true;\n+\t\tfor (idx_t i = 0; i < fk.pk_columns.size(); i++) {\n+\t\t\tif (!StringUtil::CIEquals(fk.pk_columns[i], pk_names[i])) {\n+\t\t\t\tequals = false;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tif (!equals) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// found match\n+\t\treturn;\n+\t}\n+\t// no match found! examine why\n+\tif (!found_constraint) {\n+\t\t// no unique constraint or primary key\n+\t\tstring search_term = find_primary_key ? \"primary key\" : \"primary key or unique constraint\";\n+\t\tthrow BinderException(\"Failed to create foreign key: there is no %s for referenced table \\\"%s\\\"\", search_term,\n+\t\t                      fk.info.table);\n+\t}\n+\t// check if all the columns exist\n+\tfor (auto &name : fk.pk_columns) {\n+\t\tbool found = columns.ColumnExists(name);\n+\t\tif (!found) {\n+\t\t\tthrow BinderException(\n+\t\t\t    \"Failed to create foreign key: referenced table \\\"%s\\\" does not have a column named \\\"%s\\\"\",\n+\t\t\t    fk.info.table, name);\n+\t\t}\n+\t}\n+\tauto fk_names = StringUtil::Join(fk.pk_columns, \",\");\n+\tthrow BinderException(\"Failed to create foreign key: referenced table \\\"%s\\\" does not have a primary key or unique \"\n+\t                      \"constraint on the columns %s\",\n+\t                      fk.info.table, fk_names);\n+}\n+\n+static void CheckForeignKeyTypes(const ColumnList &pk_columns, const ColumnList &fk_columns, ForeignKeyConstraint &fk) {\n+\tD_ASSERT(fk.info.pk_keys.size() == fk.info.fk_keys.size());\n+\tfor (idx_t c_idx = 0; c_idx < fk.info.pk_keys.size(); c_idx++) {\n+\t\tauto &pk_col = pk_columns.GetColumn(fk.info.pk_keys[c_idx]);\n+\t\tauto &fk_col = fk_columns.GetColumn(fk.info.fk_keys[c_idx]);\n+\t\tif (pk_col.Type() != fk_col.Type()) {\n+\t\t\tthrow BinderException(\"Failed to create foreign key: incompatible types between column \\\"%s\\\" (\\\"%s\\\") and \"\n+\t\t\t                      \"column \\\"%s\\\" (\\\"%s\\\")\",\n+\t\t\t                      pk_col.Name(), pk_col.Type().ToString(), fk_col.Name(), fk_col.Type().ToString());\n+\t\t}\n+\t}\n+}\n+\n+static void BindCreateTableConstraints(CreateTableInfo &create_info, CatalogEntryRetriever &entry_retriever,\n+                                       SchemaCatalogEntry &schema) {\n+\t// If there is a foreign key constraint, resolve primary key column's index from primary key column's name\n+\treference_set_t<SchemaCatalogEntry> fk_schemas;\n+\tfor (idx_t i = 0; i < create_info.constraints.size(); i++) {\n+\t\tauto &cond = create_info.constraints[i];\n+\t\tif (cond->type != ConstraintType::FOREIGN_KEY) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tauto &fk = cond->Cast<ForeignKeyConstraint>();\n+\t\tif (fk.info.type != ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tif (!fk.info.pk_keys.empty() && !fk.info.fk_keys.empty()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tD_ASSERT(fk.info.pk_keys.empty());\n+\t\tD_ASSERT(fk.info.fk_keys.empty());\n+\t\tFindForeignKeyIndexes(create_info.columns, fk.fk_columns, fk.info.fk_keys);\n+\n+\t\t// Resolve the self-reference.\n+\t\tif (StringUtil::CIEquals(create_info.table, fk.info.table)) {\n+\t\t\tfk.info.type = ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE;\n+\t\t\tFindMatchingPrimaryKeyColumns(create_info.columns, create_info.constraints, fk);\n+\t\t\tFindForeignKeyIndexes(create_info.columns, fk.pk_columns, fk.info.pk_keys);\n+\t\t\tCheckForeignKeyTypes(create_info.columns, create_info.columns, fk);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t// Resolve the table reference.\n+\t\tauto table_entry =\n+\t\t    entry_retriever.GetEntry(CatalogType::TABLE_ENTRY, INVALID_CATALOG, fk.info.schema, fk.info.table);\n+\t\tif (table_entry->type == CatalogType::VIEW_ENTRY) {\n+\t\t\tthrow BinderException(\"cannot reference a VIEW with a FOREIGN KEY\");\n+\t\t}\n+\n+\t\tauto &pk_table_entry_ptr = table_entry->Cast<TableCatalogEntry>();\n+\t\tif (&pk_table_entry_ptr.schema != &schema) {\n+\t\t\tthrow BinderException(\"Creating foreign keys across different schemas or catalogs is not supported\");\n+\t\t}\n+\t\tFindMatchingPrimaryKeyColumns(pk_table_entry_ptr.GetColumns(), pk_table_entry_ptr.GetConstraints(), fk);\n+\t\tFindForeignKeyIndexes(pk_table_entry_ptr.GetColumns(), fk.pk_columns, fk.info.pk_keys);\n+\t\tCheckForeignKeyTypes(pk_table_entry_ptr.GetColumns(), create_info.columns, fk);\n+\t\tauto &storage = pk_table_entry_ptr.GetStorage();\n+\n+\t\tif (!storage.HasForeignKeyIndex(fk.info.pk_keys, ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE)) {\n+\t\t\tauto fk_column_names = StringUtil::Join(fk.pk_columns, \",\");\n+\t\t\tthrow BinderException(\"Failed to create foreign key on %s(%s): no UNIQUE or PRIMARY KEY constraint \"\n+\t\t\t                      \"present on these columns\",\n+\t\t\t                      pk_table_entry_ptr.name, fk_column_names);\n+\t\t}\n+\n+\t\tD_ASSERT(fk.info.pk_keys.size() == fk.info.fk_keys.size());\n+\t\tD_ASSERT(fk.info.pk_keys.size() == fk.pk_columns.size());\n+\t\tD_ASSERT(fk.info.fk_keys.size() == fk.fk_columns.size());\n+\t}\n+}\n+\n unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateInfo> info, SchemaCatalogEntry &schema,\n                                                              vector<unique_ptr<Expression>> &bound_defaults) {\n \tauto &base = info->Cast<CreateTableInfo>();\n@@ -350,6 +588,14 @@ unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateIn\n \t\t\t\tbase.columns.AddColumn(ColumnDefinition(names[i], sql_types[i]));\n \t\t\t}\n \t\t}\n+\t\t// bind collations to detect any unsupported collation errors\n+\t\tfor (idx_t i = 0; i < base.columns.PhysicalColumnCount(); i++) {\n+\t\t\tauto &column = base.columns.GetColumnMutable(PhysicalIndex(i));\n+\t\t\tif (column.Type().id() == LogicalTypeId::VARCHAR) {\n+\t\t\t\tExpressionBinder::TestCollation(context, StringType::GetCollation(column.Type()));\n+\t\t\t}\n+\t\t\tBindLogicalType(column.TypeMutable(), &result->schema.catalog, result->schema.name);\n+\t\t}\n \t} else {\n \t\tSetCatalogLookupCallback([&dependencies, &schema](CatalogEntry &entry) {\n \t\t\tif (&schema.ParentCatalog() != &entry.ParentCatalog()) {\n@@ -362,6 +608,20 @@ unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateIn\n \t\t// bind the generated column expressions\n \t\tBindGeneratedColumns(*result);\n \t\t// bind any constraints\n+\n+\t\t// bind collations to detect any unsupported collation errors\n+\t\tfor (idx_t i = 0; i < base.columns.PhysicalColumnCount(); i++) {\n+\t\t\tauto &column = base.columns.GetColumnMutable(PhysicalIndex(i));\n+\t\t\tif (column.Type().id() == LogicalTypeId::VARCHAR) {\n+\t\t\t\tExpressionBinder::TestCollation(context, StringType::GetCollation(column.Type()));\n+\t\t\t}\n+\t\t\tBindLogicalType(column.TypeMutable(), &result->schema.catalog, result->schema.name);\n+\t\t}\n+\t\tBindCreateTableConstraints(base, entry_retriever, schema);\n+\n+\t\tif (AnyConstraintReferencesGeneratedColumn(base)) {\n+\t\t\tthrow BinderException(\"Constraints on generated columns are not supported yet\");\n+\t\t}\n \t\tbound_constraints = BindNewConstraints(base.constraints, base.table, base.columns);\n \t\t// bind the default values\n \t\tauto &catalog_name = schema.ParentCatalog().GetName();\n@@ -372,14 +632,7 @@ unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateIn\n \tif (base.columns.PhysicalColumnCount() == 0) {\n \t\tthrow BinderException(\"Creating a table without physical (non-generated) columns is not supported\");\n \t}\n-\t// bind collations to detect any unsupported collation errors\n-\tfor (idx_t i = 0; i < base.columns.PhysicalColumnCount(); i++) {\n-\t\tauto &column = base.columns.GetColumnMutable(PhysicalIndex(i));\n-\t\tif (column.Type().id() == LogicalTypeId::VARCHAR) {\n-\t\t\tExpressionBinder::TestCollation(context, StringType::GetCollation(column.Type()));\n-\t\t}\n-\t\tBindLogicalType(column.TypeMutable(), &result->schema.catalog, result->schema.name);\n-\t}\n+\n \tresult->dependencies.VerifyDependencies(schema.catalog, result->Base().table);\n \n \tauto &properties = GetStatementProperties();\n",
  "test_patch": "diff --git a/test/sql/collate/test_unsupported_collations.test b/test/sql/collate/test_unsupported_collations.test\nindex 8c7b7063f80c..9c79632783f7 100644\n--- a/test/sql/collate/test_unsupported_collations.test\n+++ b/test/sql/collate/test_unsupported_collations.test\n@@ -6,11 +6,13 @@\n statement error\n CREATE TABLE collate_test(s VARCHAR COLLATE blabla)\n ----\n+Catalog Error: Collation with name blabla does not exist!\n \n # non-varchar columns cannot have collations\n statement error\n CREATE TABLE collate_test(s INTEGER COLLATE blabla)\n ----\n+Parser Error: Only VARCHAR columns can have collations!\n \n # we can combine multiple of the same collation\n statement ok\n@@ -19,11 +21,14 @@ CREATE TABLE collate_test(s VARCHAR COLLATE NOACCENT.NOACCENT)\n statement error\n CREATE TABLE collate_test(s VARCHAR COLLATE 1)\n ----\n+Parser Error: syntax error at or near \"1\"\n \n statement error\n CREATE TABLE collate_test(s VARCHAR COLLATE 'hello')\n ----\n+Parser Error: syntax error at or near \"'hello'\"\n \n statement error\n PRAGMA default_collation='blabla'\n ----\n+Catalog Error: Collation with name blabla does not exist!\ndiff --git a/test/sql/constraints/foreignkey/test_fk_create_type.test b/test/sql/constraints/foreignkey/test_fk_create_type.test\nnew file mode 100644\nindex 000000000000..ed7499c7f7f4\n--- /dev/null\n+++ b/test/sql/constraints/foreignkey/test_fk_create_type.test\n@@ -0,0 +1,42 @@\n+# name: test/sql/constraints/foreignkey/test_fk_create_type.test\n+# group: [foreignkey]\n+\n+# Create a custom type\n+\n+statement ok\n+create type custom_type as integer;\n+\n+statement ok\n+create table parent (\n+\tid custom_type primary key\n+);\n+\n+# Use the type alias in both the primary key table and the foreign key table\n+\n+statement ok\n+create table child (\n+\tparent custom_type references parent\n+);\n+\n+statement ok\n+drop table child;\n+\n+# Also works with just 'integer'\n+\n+statement ok\n+create table child (\n+\tparent integer references parent\n+);\n+\n+statement ok\n+drop table child;\n+\n+statement ok\n+create type another_custom_type as integer;\n+\n+# And even with a different type alias that also resolves to 'integer'\n+\n+statement ok\n+create table child (\n+\tparent another_custom_type references parent\n+);\n",
  "problem_statement": "Foreign keys using user defined types fail to be defined\n### What happens?\r\n\r\nIf one uses `create type ...` to define a custom type, and then uses that as a primary key in some table, and it then references it as a foreign key, DuckDB (v1.1.3) fails with `Failed to create foreign key: incompatible types between column [...]`.\r\n\r\n(It seems to be related to issue #9234, which was however closed due to \"inactivity\".)\r\n\r\n\r\n### To Reproduce\r\n\r\nRunning the following simple SQL defining schema:\r\n\r\n```sql\r\ncreate type idtype as integer;\r\n\r\ncreate table parent (id idtype primary key);\r\ncreate table child (parent idtype references parent);\r\n```\r\n\r\nFails with:\r\n\r\n```console\r\nBinder Error: Failed to create foreign key: incompatible types between column \"id\" (\"INTEGER\") and column \"parent\" (\"idtype\")\r\n```\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n1.1.3\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Hardware:\r\n\r\nx86_64\r\n\r\n### Full Name:\r\n\r\n(see Github account submitting this issue)\r\n\r\n### Affiliation:\r\n\r\n(see Github account submitting this issue)\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2025-01-02T10:16:13Z"
}