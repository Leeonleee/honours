You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
SET/RESET not able to be used in prepared statements
### What happens?

```python
import duckdb
duckdb.execute("SET s3_region=?",["us-west-1"])
```

doesn't work

### To Reproduce

^^

### OS:

mac

### DuckDB Version:

1

### DuckDB Client:

python

### Full Name:

Andrew Grosser

### Affiliation:

Sourcetable

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

No - Other reason (please specify in the issue body)

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
SET/RESET not able to be used in prepared statements
### What happens?

```python
import duckdb
duckdb.execute("SET s3_region=?",["us-west-1"])
```

doesn't work

### To Reproduce

^^

### OS:

mac

### DuckDB Version:

1

### DuckDB Client:

python

### Full Name:

Andrew Grosser

### Affiliation:

Sourcetable

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

No - Other reason (please specify in the issue body)

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/main/client_context.cpp]
1: #include "duckdb/main/client_context.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_search_path.hpp"
6: #include "duckdb/common/error_data.hpp"
7: #include "duckdb/common/exception/transaction_exception.hpp"
8: #include "duckdb/common/progress_bar/progress_bar.hpp"
9: #include "duckdb/common/serializer/buffered_file_writer.hpp"
10: #include "duckdb/common/types/column/column_data_collection.hpp"
11: #include "duckdb/execution/column_binding_resolver.hpp"
12: #include "duckdb/execution/operator/helper/physical_result_collector.hpp"
13: #include "duckdb/execution/physical_plan_generator.hpp"
14: #include "duckdb/main/appender.hpp"
15: #include "duckdb/main/attached_database.hpp"
16: #include "duckdb/main/client_context_file_opener.hpp"
17: #include "duckdb/main/client_context_state.hpp"
18: #include "duckdb/main/client_data.hpp"
19: #include "duckdb/main/database.hpp"
20: #include "duckdb/main/database_manager.hpp"
21: #include "duckdb/main/error_manager.hpp"
22: #include "duckdb/main/materialized_query_result.hpp"
23: #include "duckdb/main/query_profiler.hpp"
24: #include "duckdb/main/query_result.hpp"
25: #include "duckdb/main/relation.hpp"
26: #include "duckdb/main/stream_query_result.hpp"
27: #include "duckdb/optimizer/optimizer.hpp"
28: #include "duckdb/parser/expression/constant_expression.hpp"
29: #include "duckdb/parser/expression/parameter_expression.hpp"
30: #include "duckdb/parser/parsed_data/create_function_info.hpp"
31: #include "duckdb/parser/parser.hpp"
32: #include "duckdb/parser/query_node/select_node.hpp"
33: #include "duckdb/parser/statement/drop_statement.hpp"
34: #include "duckdb/parser/statement/execute_statement.hpp"
35: #include "duckdb/parser/statement/explain_statement.hpp"
36: #include "duckdb/parser/statement/prepare_statement.hpp"
37: #include "duckdb/parser/statement/relation_statement.hpp"
38: #include "duckdb/parser/statement/select_statement.hpp"
39: #include "duckdb/planner/operator/logical_execute.hpp"
40: #include "duckdb/planner/planner.hpp"
41: #include "duckdb/planner/pragma_handler.hpp"
42: #include "duckdb/storage/data_table.hpp"
43: #include "duckdb/transaction/meta_transaction.hpp"
44: #include "duckdb/transaction/transaction_manager.hpp"
45: 
46: namespace duckdb {
47: 
48: struct ActiveQueryContext {
49: public:
50: 	//! The query that is currently being executed
51: 	string query;
52: 	//! Prepared statement data
53: 	shared_ptr<PreparedStatementData> prepared;
54: 	//! The query executor
55: 	unique_ptr<Executor> executor;
56: 	//! The progress bar
57: 	unique_ptr<ProgressBar> progress_bar;
58: 
59: public:
60: 	void SetOpenResult(BaseQueryResult &result) {
61: 		open_result = &result;
62: 	}
63: 	bool IsOpenResult(BaseQueryResult &result) {
64: 		return open_result == &result;
65: 	}
66: 	bool HasOpenResult() const {
67: 		return open_result != nullptr;
68: 	}
69: 
70: private:
71: 	//! The currently open result
72: 	BaseQueryResult *open_result = nullptr;
73: };
74: 
75: #ifdef DEBUG
76: struct DebugClientContextState : public ClientContextState {
77: 	~DebugClientContextState() override {
78: 		D_ASSERT(!active_transaction);
79: 		D_ASSERT(!active_query);
80: 	}
81: 
82: 	bool active_transaction = false;
83: 	bool active_query = false;
84: 
85: 	void QueryBegin(ClientContext &context) override {
86: 		if (active_query) {
87: 			throw InternalException("DebugClientContextState::QueryBegin called when a query is already active");
88: 		}
89: 		active_query = true;
90: 	}
91: 	void QueryEnd(ClientContext &context) override {
92: 		if (!active_query) {
93: 			throw InternalException("DebugClientContextState::QueryEnd called when no query is active");
94: 		}
95: 		active_query = false;
96: 	}
97: 	void TransactionBegin(MetaTransaction &transaction, ClientContext &context) override {
98: 		if (active_transaction) {
99: 			throw InternalException(
100: 			    "DebugClientContextState::TransactionBegin called when a transaction is already active");
101: 		}
102: 		active_transaction = true;
103: 	}
104: 	void TransactionCommit(MetaTransaction &transaction, ClientContext &context) override {
105: 		if (!active_transaction) {
106: 			throw InternalException("DebugClientContextState::TransactionCommit called when no transaction is active");
107: 		}
108: 		active_transaction = false;
109: 	}
110: 	void TransactionRollback(MetaTransaction &transaction, ClientContext &context) override {
111: 		if (!active_transaction) {
112: 			throw InternalException(
113: 			    "DebugClientContextState::TransactionRollback called when no transaction is active");
114: 		}
115: 		active_transaction = false;
116: 	}
117: #ifdef DUCKDB_DEBUG_REBIND
118: 	RebindQueryInfo OnPlanningError(ClientContext &context, SQLStatement &statement, ErrorData &error) override {
119: 		return RebindQueryInfo::ATTEMPT_TO_REBIND;
120: 	}
121: 	RebindQueryInfo OnFinalizePrepare(ClientContext &context, PreparedStatementData &prepared,
122: 	                                  PreparedStatementMode mode) override {
123: 		if (mode == PreparedStatementMode::PREPARE_AND_EXECUTE) {
124: 			return RebindQueryInfo::ATTEMPT_TO_REBIND;
125: 		}
126: 		return RebindQueryInfo::DO_NOT_REBIND;
127: 	}
128: 	RebindQueryInfo OnExecutePrepared(ClientContext &context, PreparedStatementCallbackInfo &info,
129: 	                                  RebindQueryInfo current_rebind) override {
130: 		return RebindQueryInfo::ATTEMPT_TO_REBIND;
131: 	}
132: #endif
133: };
134: #endif
135: 
136: ClientContext::ClientContext(shared_ptr<DatabaseInstance> database)
137:     : db(std::move(database)), interrupted(false), client_data(make_uniq<ClientData>(*this)), transaction(*this) {
138: 	registered_state = make_uniq<RegisteredStateManager>();
139: #ifdef DEBUG
140: 	registered_state->GetOrCreate<DebugClientContextState>("debug_client_context_state");
141: #endif
142: }
143: 
144: ClientContext::~ClientContext() {
145: 	if (Exception::UncaughtException()) {
146: 		return;
147: 	}
148: 	// destroy the client context and rollback if there is an active transaction
149: 	// but only if we are not destroying this client context as part of an exception stack unwind
150: 	Destroy();
151: }
152: 
153: unique_ptr<ClientContextLock> ClientContext::LockContext() {
154: 	return make_uniq<ClientContextLock>(context_lock);
155: }
156: 
157: void ClientContext::Destroy() {
158: 	auto lock = LockContext();
159: 	if (transaction.HasActiveTransaction()) {
160: 		transaction.ResetActiveQuery();
161: 		if (!transaction.IsAutoCommit()) {
162: 			transaction.Rollback(nullptr);
163: 		}
164: 	}
165: 	CleanupInternal(*lock);
166: }
167: 
168: void ClientContext::ProcessError(ErrorData &error, const string &query) const {
169: 	if (config.errors_as_json) {
170: 		error.ConvertErrorToJSON();
171: 	} else if (!query.empty()) {
172: 		error.AddErrorLocation(query);
173: 	}
174: }
175: 
176: template <class T>
177: unique_ptr<T> ClientContext::ErrorResult(ErrorData error, const string &query) {
178: 	ProcessError(error, query);
179: 	return make_uniq<T>(std::move(error));
180: }
181: 
182: void ClientContext::BeginQueryInternal(ClientContextLock &lock, const string &query) {
183: 	// check if we are on AutoCommit. In this case we should start a transaction
184: 	D_ASSERT(!active_query);
185: 	auto &db_inst = DatabaseInstance::GetDatabase(*this);
186: 	if (ValidChecker::IsInvalidated(db_inst)) {
187: 		throw ErrorManager::InvalidatedDatabase(*this, ValidChecker::InvalidatedMessage(db_inst));
188: 	}
189: 	active_query = make_uniq<ActiveQueryContext>();
190: 	if (transaction.IsAutoCommit()) {
191: 		transaction.BeginTransaction();
192: 	}
193: 	transaction.SetActiveQuery(db->GetDatabaseManager().GetNewQueryNumber());
194: 	LogQueryInternal(lock, query);
195: 	active_query->query = query;
196: 
197: 	query_progress.Initialize();
198: 	// Notify any registered state of query begin
199: 	for (auto &state : registered_state->States()) {
200: 		state->QueryBegin(*this);
201: 	}
202: }
203: 
204: ErrorData ClientContext::EndQueryInternal(ClientContextLock &lock, bool success, bool invalidate_transaction,
205:                                           optional_ptr<ErrorData> previous_error) {
206: 	client_data->profiler->EndQuery();
207: 
208: 	if (active_query->executor) {
209: 		active_query->executor->CancelTasks();
210: 	}
211: 	active_query->progress_bar.reset();
212: 
213: 	D_ASSERT(active_query.get());
214: 	active_query.reset();
215: 	query_progress.Initialize();
216: 	ErrorData error;
217: 	try {
218: 		if (transaction.HasActiveTransaction()) {
219: 			transaction.ResetActiveQuery();
220: 			if (transaction.IsAutoCommit()) {
221: 				if (success) {
222: 					transaction.Commit();
223: 				} else {
224: 					transaction.Rollback(previous_error);
225: 				}
226: 			} else if (invalidate_transaction) {
227: 				D_ASSERT(!success);
228: 				ValidChecker::Invalidate(ActiveTransaction(), "Failed to commit");
229: 			}
230: 		}
231: 	} catch (std::exception &ex) {
232: 		error = ErrorData(ex);
233: 		if (Exception::InvalidatesDatabase(error.Type())) {
234: 			auto &db_inst = DatabaseInstance::GetDatabase(*this);
235: 			ValidChecker::Invalidate(db_inst, error.RawMessage());
236: 		}
237: 	} catch (...) { // LCOV_EXCL_START
238: 		error = ErrorData("Unhandled exception!");
239: 	} // LCOV_EXCL_STOP
240: 
241: 	// Notify any registered state of query end
242: 	for (auto const &s : registered_state->States()) {
243: 		if (error.HasError()) {
244: 			s->QueryEnd(*this, &error);
245: 		} else {
246: 			s->QueryEnd(*this, previous_error);
247: 		}
248: 	}
249: 
250: 	return error;
251: }
252: 
253: void ClientContext::CleanupInternal(ClientContextLock &lock, BaseQueryResult *result, bool invalidate_transaction) {
254: 	if (!active_query) {
255: 		// no query currently active
256: 		return;
257: 	}
258: 	if (active_query->executor) {
259: 		active_query->executor->CancelTasks();
260: 	}
261: 	active_query->progress_bar.reset();
262: 
263: 	// Relaunch the threads if a SET THREADS command was issued
264: 	auto &scheduler = TaskScheduler::GetScheduler(*this);
265: 	scheduler.RelaunchThreads();
266: 
267: 	optional_ptr<ErrorData> passed_error = nullptr;
268: 	if (result && result->HasError()) {
269: 		passed_error = result->GetErrorObject();
270: 	}
271: 	auto error = EndQueryInternal(lock, result ? !result->HasError() : false, invalidate_transaction, passed_error);
272: 	if (result && !result->HasError()) {
273: 		// if an error occurred while committing report it in the result
274: 		result->SetError(error);
275: 	}
276: 	D_ASSERT(!active_query);
277: }
278: 
279: Executor &ClientContext::GetExecutor() {
280: 	D_ASSERT(active_query);
281: 	D_ASSERT(active_query->executor);
282: 	return *active_query->executor;
283: }
284: 
285: const string &ClientContext::GetCurrentQuery() {
286: 	D_ASSERT(active_query);
287: 	return active_query->query;
288: }
289: 
290: unique_ptr<QueryResult> ClientContext::FetchResultInternal(ClientContextLock &lock, PendingQueryResult &pending) {
291: 	D_ASSERT(active_query);
292: 	D_ASSERT(active_query->IsOpenResult(pending));
293: 	D_ASSERT(active_query->prepared);
294: 	auto &executor = GetExecutor();
295: 	auto &prepared = *active_query->prepared;
296: 	bool create_stream_result = prepared.properties.allow_stream_result && pending.allow_stream_result;
297: 	unique_ptr<QueryResult> result;
298: 	D_ASSERT(executor.HasResultCollector());
299: 	// we have a result collector - fetch the result directly from the result collector
300: 	result = executor.GetResult();
301: 	if (!create_stream_result) {
302: 		CleanupInternal(lock, result.get(), false);
303: 	} else {
304: 		active_query->SetOpenResult(*result);
305: 	}
306: 	return result;
307: }
308: 
309: static bool IsExplainAnalyze(SQLStatement *statement) {
310: 	if (!statement) {
311: 		return false;
312: 	}
313: 	if (statement->type != StatementType::EXPLAIN_STATEMENT) {
314: 		return false;
315: 	}
316: 	auto &explain = statement->Cast<ExplainStatement>();
317: 	return explain.explain_type == ExplainType::EXPLAIN_ANALYZE;
318: }
319: 
320: shared_ptr<PreparedStatementData>
321: ClientContext::CreatePreparedStatementInternal(ClientContextLock &lock, const string &query,
322:                                                unique_ptr<SQLStatement> statement,
323:                                                optional_ptr<case_insensitive_map_t<BoundParameterData>> values) {
324: 	StatementType statement_type = statement->type;
325: 	auto result = make_shared_ptr<PreparedStatementData>(statement_type);
326: 
327: 	auto &profiler = QueryProfiler::Get(*this);
328: 	profiler.StartQuery(query, IsExplainAnalyze(statement.get()), true);
329: 	profiler.StartPhase(MetricsType::PLANNER);
330: 	Planner planner(*this);
331: 	if (values) {
332: 		auto &parameter_values = *values;
333: 		for (auto &value : parameter_values) {
334: 			planner.parameter_data.emplace(value.first, BoundParameterData(value.second));
335: 		}
336: 	}
337: 
338: 	planner.CreatePlan(std::move(statement));
339: 	D_ASSERT(planner.plan || !planner.properties.bound_all_parameters);
340: 	profiler.EndPhase();
341: 
342: 	auto plan = std::move(planner.plan);
343: 	// extract the result column names from the plan
344: 	result->properties = planner.properties;
345: 	result->names = planner.names;
346: 	result->types = planner.types;
347: 	result->value_map = std::move(planner.value_map);
348: 	if (!planner.properties.bound_all_parameters) {
349: 		return result;
350: 	}
351: #ifdef DEBUG
352: 	plan->Verify(*this);
353: #endif
354: 	if (config.enable_optimizer && plan->RequireOptimizer()) {
355: 		profiler.StartPhase(MetricsType::ALL_OPTIMIZERS);
356: 		Optimizer optimizer(*planner.binder, *this);
357: 		plan = optimizer.Optimize(std::move(plan));
358: 		D_ASSERT(plan);
359: 		profiler.EndPhase();
360: 
361: #ifdef DEBUG
362: 		plan->Verify(*this);
363: #endif
364: 	}
365: 
366: 	profiler.StartPhase(MetricsType::PHYSICAL_PLANNER);
367: 	// now convert logical query plan into a physical query plan
368: 	PhysicalPlanGenerator physical_planner(*this);
369: 	auto physical_plan = physical_planner.CreatePlan(std::move(plan));
370: 	profiler.EndPhase();
371: 
372: #ifdef DEBUG
373: 	D_ASSERT(!physical_plan->ToString().empty());
374: #endif
375: 	result->plan = std::move(physical_plan);
376: 	return result;
377: }
378: 
379: shared_ptr<PreparedStatementData>
380: ClientContext::CreatePreparedStatement(ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,
381:                                        optional_ptr<case_insensitive_map_t<BoundParameterData>> values,
382:                                        PreparedStatementMode mode) {
383: 	// check if any client context state could request a rebind
384: 	bool can_request_rebind = false;
385: 	for (auto &state : registered_state->States()) {
386: 		if (state->CanRequestRebind()) {
387: 			can_request_rebind = true;
388: 		}
389: 	}
390: 	if (can_request_rebind) {
391: 		bool rebind = false;
392: 		// if any registered state can request a rebind we do the binding on a copy first
393: 		shared_ptr<PreparedStatementData> result;
394: 		try {
395: 			result = CreatePreparedStatementInternal(lock, query, statement->Copy(), values);
396: 		} catch (std::exception &ex) {
397: 			ErrorData error(ex);
398: 			// check if any registered client context state wants to try a rebind
399: 			for (auto &state : registered_state->States()) {
400: 				auto info = state->OnPlanningError(*this, *statement, error);
401: 				if (info == RebindQueryInfo::ATTEMPT_TO_REBIND) {
402: 					rebind = true;
403: 				}
404: 			}
405: 			if (!rebind) {
406: 				throw;
407: 			}
408: 		}
409: 		if (result) {
410: 			D_ASSERT(!rebind);
411: 			for (auto &state : registered_state->States()) {
412: 				auto info = state->OnFinalizePrepare(*this, *result, mode);
413: 				if (info == RebindQueryInfo::ATTEMPT_TO_REBIND) {
414: 					rebind = true;
415: 				}
416: 			}
417: 		}
418: 		if (!rebind) {
419: 			return result;
420: 		}
421: 		// an extension wants to do a rebind - do it once
422: 	}
423: 
424: 	return CreatePreparedStatementInternal(lock, query, std::move(statement), values);
425: }
426: 
427: QueryProgress ClientContext::GetQueryProgress() {
428: 	return query_progress;
429: }
430: 
431: void BindPreparedStatementParameters(PreparedStatementData &statement, const PendingQueryParameters &parameters) {
432: 	case_insensitive_map_t<BoundParameterData> owned_values;
433: 	if (parameters.parameters) {
434: 		auto &params = *parameters.parameters;
435: 		for (auto &val : params) {
436: 			owned_values.emplace(val);
437: 		}
438: 	}
439: 	statement.Bind(std::move(owned_values));
440: }
441: 
442: void ClientContext::RebindPreparedStatement(ClientContextLock &lock, const string &query,
443:                                             shared_ptr<PreparedStatementData> &prepared,
444:                                             const PendingQueryParameters &parameters) {
445: 	if (!prepared->unbound_statement) {
446: 		throw InternalException("ClientContext::RebindPreparedStatement called but PreparedStatementData did not have "
447: 		                        "an unbound statement so rebinding cannot be done");
448: 	}
449: 	// catalog was modified: rebind the statement before execution
450: 	auto new_prepared =
451: 	    CreatePreparedStatement(lock, query, prepared->unbound_statement->Copy(), parameters.parameters);
452: 	D_ASSERT(new_prepared->properties.bound_all_parameters);
453: 	prepared = std::move(new_prepared);
454: 	prepared->properties.bound_all_parameters = false;
455: }
456: 
457: void ClientContext::CheckIfPreparedStatementIsExecutable(PreparedStatementData &statement) {
458: 	if (ValidChecker::IsInvalidated(ActiveTransaction()) && statement.properties.requires_valid_transaction) {
459: 		throw ErrorManager::InvalidatedTransaction(*this);
460: 	}
461: 	auto &meta_transaction = MetaTransaction::Get(*this);
462: 	auto &manager = DatabaseManager::Get(*this);
463: 	for (auto &it : statement.properties.modified_databases) {
464: 		auto &modified_database = it.first;
465: 		auto entry = manager.GetDatabase(*this, modified_database);
466: 		if (!entry) {
467: 			throw InternalException("Database \"%s\" not found", modified_database);
468: 		}
469: 		if (entry->IsReadOnly()) {
470: 			throw InvalidInputException(StringUtil::Format(
471: 			    "Cannot execute statement of type \"%s\" on database \"%s\" which is attached in read-only mode!",
472: 			    StatementTypeToString(statement.statement_type), modified_database));
473: 		}
474: 		meta_transaction.ModifyDatabase(*entry);
475: 	}
476: }
477: 
478: unique_ptr<PendingQueryResult>
479: ClientContext::PendingPreparedStatementInternal(ClientContextLock &lock, shared_ptr<PreparedStatementData> statement_p,
480:                                                 const PendingQueryParameters &parameters) {
481: 	D_ASSERT(active_query);
482: 	auto &statement = *statement_p;
483: 
484: 	BindPreparedStatementParameters(statement, parameters);
485: 
486: 	active_query->executor = make_uniq<Executor>(*this);
487: 	auto &executor = *active_query->executor;
488: 	if (config.enable_progress_bar) {
489: 		progress_bar_display_create_func_t display_create_func = nullptr;
490: 		if (config.print_progress_bar) {
491: 			// If a custom display is set, use that, otherwise just use the default
492: 			display_create_func =
493: 			    config.display_create_func ? config.display_create_func : ProgressBar::DefaultProgressBarDisplay;
494: 		}
495: 		active_query->progress_bar =
496: 		    make_uniq<ProgressBar>(executor, NumericCast<idx_t>(config.wait_time), display_create_func);
497: 		active_query->progress_bar->Start();
498: 		query_progress.Restart();
499: 	}
500: 	auto stream_result = parameters.allow_stream_result && statement.properties.allow_stream_result;
501: 
502: 	get_result_collector_t get_method = PhysicalResultCollector::GetResultCollector;
503: 	auto &client_config = ClientConfig::GetConfig(*this);
504: 	if (!stream_result && client_config.result_collector) {
505: 		get_method = client_config.result_collector;
506: 	}
507: 	statement.is_streaming = stream_result;
508: 	auto collector = get_method(*this, statement);
509: 	D_ASSERT(collector->type == PhysicalOperatorType::RESULT_COLLECTOR);
510: 	executor.Initialize(std::move(collector));
511: 
512: 	auto types = executor.GetTypes();
513: 	D_ASSERT(types == statement.types);
514: 	D_ASSERT(!active_query->HasOpenResult());
515: 
516: 	auto pending_result =
517: 	    make_uniq<PendingQueryResult>(shared_from_this(), *statement_p, std::move(types), stream_result);
518: 	active_query->prepared = std::move(statement_p);
519: 	active_query->SetOpenResult(*pending_result);
520: 	return pending_result;
521: }
522: 
523: unique_ptr<PendingQueryResult> ClientContext::PendingPreparedStatement(ClientContextLock &lock, const string &query,
524:                                                                        shared_ptr<PreparedStatementData> prepared,
525:                                                                        const PendingQueryParameters &parameters) {
526: 	CheckIfPreparedStatementIsExecutable(*prepared);
527: 
528: 	RebindQueryInfo rebind = RebindQueryInfo::DO_NOT_REBIND;
529: 	if (prepared->RequireRebind(*this, parameters.parameters)) {
530: 		rebind = RebindQueryInfo::ATTEMPT_TO_REBIND;
531: 	}
532: 
533: 	for (auto &state : registered_state->States()) {
534: 		PreparedStatementCallbackInfo info(*prepared, parameters);
535: 		auto new_rebind = state->OnExecutePrepared(*this, info, rebind);
536: 		if (new_rebind == RebindQueryInfo::ATTEMPT_TO_REBIND) {
537: 			rebind = RebindQueryInfo::ATTEMPT_TO_REBIND;
538: 		}
539: 	}
540: 	if (rebind == RebindQueryInfo::ATTEMPT_TO_REBIND) {
541: 		RebindPreparedStatement(lock, query, prepared, parameters);
542: 	}
543: 	return PendingPreparedStatementInternal(lock, prepared, parameters);
544: }
545: 
546: void ClientContext::WaitForTask(ClientContextLock &lock, BaseQueryResult &result) {
547: 	active_query->executor->WaitForTask();
548: }
549: 
550: PendingExecutionResult ClientContext::ExecuteTaskInternal(ClientContextLock &lock, BaseQueryResult &result,
551:                                                           bool dry_run) {
552: 	D_ASSERT(active_query);
553: 	D_ASSERT(active_query->IsOpenResult(result));
554: 	bool invalidate_transaction = true;
555: 	try {
556: 		auto query_result = active_query->executor->ExecuteTask(dry_run);
557: 		if (active_query->progress_bar) {
558: 			auto is_finished = PendingQueryResult::IsResultReady(query_result);
559: 			active_query->progress_bar->Update(is_finished);
560: 			query_progress = active_query->progress_bar->GetDetailedQueryProgress();
561: 		}
562: 		return query_result;
563: 	} catch (std::exception &ex) {
564: 		auto error = ErrorData(ex);
565: 		if (error.Type() == ExceptionType::INTERRUPT) {
566: 			auto &executor = *active_query->executor;
567: 			if (!executor.HasError()) {
568: 				// Interrupted by the user
569: 				result.SetError(ex);
570: 				invalidate_transaction = true;
571: 			} else {
572: 				// Interrupted by an exception caused in a worker thread
573: 				error = executor.GetError();
574: 				invalidate_transaction = Exception::InvalidatesTransaction(error.Type());
575: 				result.SetError(error);
576: 			}
577: 		} else if (!Exception::InvalidatesTransaction(error.Type())) {
578: 			invalidate_transaction = false;
579: 		} else if (Exception::InvalidatesDatabase(error.Type())) {
580: 			// fatal exceptions invalidate the entire database
581: 			auto &db_instance = DatabaseInstance::GetDatabase(*this);
582: 			ValidChecker::Invalidate(db_instance, error.RawMessage());
583: 		}
584: 		ProcessError(error, active_query->query);
585: 		result.SetError(std::move(error));
586: 	} catch (...) { // LCOV_EXCL_START
587: 		result.SetError(ErrorData("Unhandled exception in ExecuteTaskInternal"));
588: 	} // LCOV_EXCL_STOP
589: 	EndQueryInternal(lock, false, invalidate_transaction, result.GetErrorObject());
590: 	return PendingExecutionResult::EXECUTION_ERROR;
591: }
592: 
593: void ClientContext::InitialCleanup(ClientContextLock &lock) {
594: 	//! Cleanup any open results and reset the interrupted flag
595: 	CleanupInternal(lock);
596: 	interrupted = false;
597: }
598: 
599: vector<unique_ptr<SQLStatement>> ClientContext::ParseStatements(const string &query) {
600: 	auto lock = LockContext();
601: 	return ParseStatementsInternal(*lock, query);
602: }
603: 
604: vector<unique_ptr<SQLStatement>> ClientContext::ParseStatementsInternal(ClientContextLock &lock, const string &query) {
605: 	Parser parser(GetParserOptions());
606: 	parser.ParseQuery(query);
607: 
608: 	PragmaHandler handler(*this);
609: 	handler.HandlePragmaStatements(lock, parser.statements);
610: 
611: 	return std::move(parser.statements);
612: }
613: 
614: void ClientContext::HandlePragmaStatements(vector<unique_ptr<SQLStatement>> &statements) {
615: 	auto lock = LockContext();
616: 
617: 	PragmaHandler handler(*this);
618: 	handler.HandlePragmaStatements(*lock, statements);
619: }
620: 
621: unique_ptr<LogicalOperator> ClientContext::ExtractPlan(const string &query) {
622: 	auto lock = LockContext();
623: 
624: 	auto statements = ParseStatementsInternal(*lock, query);
625: 	if (statements.size() != 1) {
626: 		throw InvalidInputException("ExtractPlan can only prepare a single statement");
627: 	}
628: 
629: 	unique_ptr<LogicalOperator> plan;
630: 	RunFunctionInTransactionInternal(*lock, [&]() {
631: 		Planner planner(*this);
632: 		planner.CreatePlan(std::move(statements[0]));
633: 		D_ASSERT(planner.plan);
634: 
635: 		plan = std::move(planner.plan);
636: 
637: 		if (config.enable_optimizer) {
638: 			Optimizer optimizer(*planner.binder, *this);
639: 			plan = optimizer.Optimize(std::move(plan));
640: 		}
641: 
642: 		ColumnBindingResolver resolver;
643: 		resolver.Verify(*plan);
644: 		resolver.VisitOperator(*plan);
645: 
646: 		plan->ResolveOperatorTypes();
647: 	});
648: 	return plan;
649: }
650: 
651: unique_ptr<PreparedStatement> ClientContext::PrepareInternal(ClientContextLock &lock,
652:                                                              unique_ptr<SQLStatement> statement) {
653: 	auto named_param_map = statement->named_param_map;
654: 	auto statement_query = statement->query;
655: 	shared_ptr<PreparedStatementData> prepared_data;
656: 	auto unbound_statement = statement->Copy();
657: 	RunFunctionInTransactionInternal(
658: 	    lock, [&]() { prepared_data = CreatePreparedStatement(lock, statement_query, std::move(statement)); }, false);
659: 	prepared_data->unbound_statement = std::move(unbound_statement);
660: 	return make_uniq<PreparedStatement>(shared_from_this(), std::move(prepared_data), std::move(statement_query),
661: 	                                    std::move(named_param_map));
662: }
663: 
664: unique_ptr<PreparedStatement> ClientContext::Prepare(unique_ptr<SQLStatement> statement) {
665: 	auto lock = LockContext();
666: 	// prepare the query
667: 	auto query = statement->query;
668: 	try {
669: 		InitialCleanup(*lock);
670: 		return PrepareInternal(*lock, std::move(statement));
671: 	} catch (std::exception &ex) {
672: 		return ErrorResult<PreparedStatement>(ErrorData(ex), query);
673: 	}
674: }
675: 
676: unique_ptr<PreparedStatement> ClientContext::Prepare(const string &query) {
677: 	auto lock = LockContext();
678: 	// prepare the query
679: 	try {
680: 		InitialCleanup(*lock);
681: 
682: 		// first parse the query
683: 		auto statements = ParseStatementsInternal(*lock, query);
684: 		if (statements.empty()) {
685: 			throw InvalidInputException("No statement to prepare!");
686: 		}
687: 		if (statements.size() > 1) {
688: 			throw InvalidInputException("Cannot prepare multiple statements at once!");
689: 		}
690: 		return PrepareInternal(*lock, std::move(statements[0]));
691: 	} catch (std::exception &ex) {
692: 		return ErrorResult<PreparedStatement>(ErrorData(ex), query);
693: 	}
694: }
695: 
696: unique_ptr<PendingQueryResult> ClientContext::PendingQueryPreparedInternal(ClientContextLock &lock, const string &query,
697:                                                                            shared_ptr<PreparedStatementData> &prepared,
698:                                                                            const PendingQueryParameters &parameters) {
699: 	try {
700: 		InitialCleanup(lock);
701: 	} catch (std::exception &ex) {
702: 		return ErrorResult<PendingQueryResult>(ErrorData(ex), query);
703: 	}
704: 	return PendingStatementOrPreparedStatementInternal(lock, query, nullptr, prepared, parameters);
705: }
706: 
707: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const string &query,
708:                                                            shared_ptr<PreparedStatementData> &prepared,
709:                                                            const PendingQueryParameters &parameters) {
710: 	auto lock = LockContext();
711: 	return PendingQueryPreparedInternal(*lock, query, prepared, parameters);
712: }
713: 
714: unique_ptr<QueryResult> ClientContext::Execute(const string &query, shared_ptr<PreparedStatementData> &prepared,
715:                                                const PendingQueryParameters &parameters) {
716: 	auto lock = LockContext();
717: 	auto pending = PendingQueryPreparedInternal(*lock, query, prepared, parameters);
718: 	if (pending->HasError()) {
719: 		return ErrorResult<MaterializedQueryResult>(pending->GetErrorObject());
720: 	}
721: 	return pending->ExecuteInternal(*lock);
722: }
723: 
724: unique_ptr<QueryResult> ClientContext::Execute(const string &query, shared_ptr<PreparedStatementData> &prepared,
725:                                                case_insensitive_map_t<BoundParameterData> &values,
726:                                                bool allow_stream_result) {
727: 	PendingQueryParameters parameters;
728: 	parameters.parameters = &values;
729: 	parameters.allow_stream_result = allow_stream_result;
730: 	return Execute(query, prepared, parameters);
731: }
732: 
733: unique_ptr<PendingQueryResult> ClientContext::PendingStatementInternal(ClientContextLock &lock, const string &query,
734:                                                                        unique_ptr<SQLStatement> statement,
735:                                                                        const PendingQueryParameters &parameters) {
736: 	// prepare the query for execution
737: 	auto prepared = CreatePreparedStatement(lock, query, std::move(statement), parameters.parameters,
738: 	                                        PreparedStatementMode::PREPARE_AND_EXECUTE);
739: 	idx_t parameter_count = !parameters.parameters ? 0 : parameters.parameters->size();
740: 	if (prepared->properties.parameter_count > 0 && parameter_count == 0) {
741: 		string error_message = StringUtil::Format("Expected %lld parameters, but none were supplied",
742: 		                                          prepared->properties.parameter_count);
743: 		return ErrorResult<PendingQueryResult>(InvalidInputException(error_message), query);
744: 	}
745: 	if (!prepared->properties.bound_all_parameters) {
746: 		return ErrorResult<PendingQueryResult>(InvalidInputException("Not all parameters were bound"), query);
747: 	}
748: 	// execute the prepared statement
749: 	CheckIfPreparedStatementIsExecutable(*prepared);
750: 	return PendingPreparedStatementInternal(lock, std::move(prepared), parameters);
751: }
752: 
753: unique_ptr<QueryResult> ClientContext::RunStatementInternal(ClientContextLock &lock, const string &query,
754:                                                             unique_ptr<SQLStatement> statement,
755:                                                             bool allow_stream_result, bool verify) {
756: 	PendingQueryParameters parameters;
757: 	parameters.allow_stream_result = allow_stream_result;
758: 	auto pending = PendingQueryInternal(lock, std::move(statement), parameters, verify);
759: 	if (pending->HasError()) {
760: 		return ErrorResult<MaterializedQueryResult>(pending->GetErrorObject());
761: 	}
762: 	return ExecutePendingQueryInternal(lock, *pending);
763: }
764: 
765: bool ClientContext::IsActiveResult(ClientContextLock &lock, BaseQueryResult &result) {
766: 	if (!active_query) {
767: 		return false;
768: 	}
769: 	return active_query->IsOpenResult(result);
770: }
771: 
772: unique_ptr<PendingQueryResult> ClientContext::PendingStatementOrPreparedStatementInternal(
773:     ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,
774:     shared_ptr<PreparedStatementData> &prepared, const PendingQueryParameters &parameters) {
775: #ifdef DUCKDB_ALTERNATIVE_VERIFY
776: 	if (statement && statement->type != StatementType::LOGICAL_PLAN_STATEMENT) {
777: 		statement = statement->Copy();
778: 	}
779: #endif
780: 	// check if we are on AutoCommit. In this case we should start a transaction.
781: 	if (statement && config.AnyVerification()) {
782: 		// query verification is enabled
783: 		// create a copy of the statement, and use the copy
784: 		// this way we verify that the copy correctly copies all properties
785: 		auto copied_statement = statement->Copy();
786: 		switch (statement->type) {
787: 		case StatementType::SELECT_STATEMENT: {
788: 			// in case this is a select query, we verify the original statement
789: 			ErrorData error;
790: 			try {
791: 				error = VerifyQuery(lock, query, std::move(statement));
792: 			} catch (std::exception &ex) {
793: 				error = ErrorData(ex);
794: 			}
795: 			if (error.HasError()) {
796: 				// error in verifying query
797: 				return ErrorResult<PendingQueryResult>(std::move(error), query);
798: 			}
799: 			statement = std::move(copied_statement);
800: 			break;
801: 		}
802: 		default: {
803: #ifndef DUCKDB_ALTERNATIVE_VERIFY
804: 			bool reparse_statement = true;
805: #else
806: 			bool reparse_statement = false;
807: #endif
808: 			statement = std::move(copied_statement);
809: 			if (statement->type == StatementType::RELATION_STATEMENT) {
810: 				reparse_statement = false;
811: 			}
812: 			if (reparse_statement) {
813: 				try {
814: 					Parser parser(GetParserOptions());
815: 					ErrorData error;
816: 					parser.ParseQuery(statement->ToString());
817: 					statement = std::move(parser.statements[0]);
818: 				} catch (const NotImplementedException &) {
819: 					// ToString was not implemented, just use the copied statement
820: 				}
821: 			}
822: 			break;
823: 		}
824: 		}
825: 	}
826: 	return PendingStatementOrPreparedStatement(lock, query, std::move(statement), prepared, parameters);
827: }
828: 
829: unique_ptr<PendingQueryResult> ClientContext::PendingStatementOrPreparedStatement(
830:     ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,
831:     shared_ptr<PreparedStatementData> &prepared, const PendingQueryParameters &parameters) {
832: 	unique_ptr<PendingQueryResult> pending;
833: 
834: 	try {
835: 		BeginQueryInternal(lock, query);
836: 	} catch (std::exception &ex) {
837: 		ErrorData error(ex);
838: 		if (Exception::InvalidatesDatabase(error.Type())) {
839: 			// fatal exceptions invalidate the entire database
840: 			auto &db_instance = DatabaseInstance::GetDatabase(*this);
841: 			ValidChecker::Invalidate(db_instance, error.RawMessage());
842: 		}
843: 		return ErrorResult<PendingQueryResult>(std::move(error), query);
844: 	}
845: 	// start the profiler
846: 	auto &profiler = QueryProfiler::Get(*this);
847: 	profiler.StartQuery(query, IsExplainAnalyze(statement ? statement.get() : prepared->unbound_statement.get()));
848: 
849: 	bool invalidate_query = true;
850: 	try {
851: 		if (statement) {
852: 			pending = PendingStatementInternal(lock, query, std::move(statement), parameters);
853: 		} else {
854: 			pending = PendingPreparedStatement(lock, query, prepared, parameters);
855: 		}
856: 	} catch (std::exception &ex) {
857: 		ErrorData error(ex);
858: 		if (!Exception::InvalidatesTransaction(error.Type())) {
859: 			// standard exceptions do not invalidate the current transaction
860: 			invalidate_query = false;
861: 		} else if (Exception::InvalidatesDatabase(error.Type())) {
862: 			// fatal exceptions invalidate the entire database
863: 			if (!config.query_verification_enabled) {
864: 				auto &db_instance = DatabaseInstance::GetDatabase(*this);
865: 				ValidChecker::Invalidate(db_instance, error.RawMessage());
866: 			}
867: 		}
868: 		// other types of exceptions do invalidate the current transaction
869: 		pending = ErrorResult<PendingQueryResult>(std::move(error), query);
870: 	}
871: 	if (pending->HasError()) {
872: 		// query failed: abort now
873: 		EndQueryInternal(lock, false, invalidate_query, pending->GetErrorObject());
874: 		return pending;
875: 	}
876: 	D_ASSERT(active_query->IsOpenResult(*pending));
877: 	return pending;
878: }
879: 
880: void ClientContext::LogQueryInternal(ClientContextLock &, const string &query) {
881: 	if (!client_data->log_query_writer) {
882: #ifdef DUCKDB_FORCE_QUERY_LOG
883: 		try {
884: 			string log_path(DUCKDB_FORCE_QUERY_LOG);
885: 			client_data->log_query_writer =
886: 			    make_uniq<BufferedFileWriter>(FileSystem::GetFileSystem(*this), log_path,
887: 			                                  BufferedFileWriter::DEFAULT_OPEN_FLAGS, client_data->file_opener.get());
888: 		} catch (...) {
889: 			return;
890: 		}
891: #else
892: 		return;
893: #endif
894: 	}
895: 	// log query path is set: log the query
896: 	client_data->log_query_writer->WriteData(const_data_ptr_cast(query.c_str()), query.size());
897: 	client_data->log_query_writer->WriteData(const_data_ptr_cast("\n"), 1);
898: 	client_data->log_query_writer->Flush();
899: 	client_data->log_query_writer->Sync();
900: }
901: 
902: unique_ptr<QueryResult> ClientContext::Query(unique_ptr<SQLStatement> statement, bool allow_stream_result) {
903: 	auto pending_query = PendingQuery(std::move(statement), allow_stream_result);
904: 	if (pending_query->HasError()) {
905: 		return ErrorResult<MaterializedQueryResult>(pending_query->GetErrorObject());
906: 	}
907: 	return pending_query->Execute();
908: }
909: 
910: unique_ptr<QueryResult> ClientContext::Query(const string &query, bool allow_stream_result) {
911: 	auto lock = LockContext();
912: 
913: 	ErrorData error;
914: 	vector<unique_ptr<SQLStatement>> statements;
915: 	if (!ParseStatements(*lock, query, statements, error)) {
916: 		return ErrorResult<MaterializedQueryResult>(std::move(error), query);
917: 	}
918: 	if (statements.empty()) {
919: 		// no statements, return empty successful result
920: 		StatementProperties properties;
921: 		vector<string> names;
922: 		auto collection = make_uniq<ColumnDataCollection>(Allocator::DefaultAllocator());
923: 		return make_uniq<MaterializedQueryResult>(StatementType::INVALID_STATEMENT, properties, std::move(names),
924: 		                                          std::move(collection), GetClientProperties());
925: 	}
926: 
927: 	unique_ptr<QueryResult> result;
928: 	QueryResult *last_result = nullptr;
929: 	bool last_had_result = false;
930: 	for (idx_t i = 0; i < statements.size(); i++) {
931: 		auto &statement = statements[i];
932: 		bool is_last_statement = i + 1 == statements.size();
933: 		PendingQueryParameters parameters;
934: 		parameters.allow_stream_result = allow_stream_result && is_last_statement;
935: 		auto pending_query = PendingQueryInternal(*lock, std::move(statement), parameters);
936: 		auto has_result = pending_query->properties.return_type == StatementReturnType::QUERY_RESULT;
937: 		unique_ptr<QueryResult> current_result;
938: 		if (pending_query->HasError()) {
939: 			current_result = ErrorResult<MaterializedQueryResult>(pending_query->GetErrorObject());
940: 		} else {
941: 			current_result = ExecutePendingQueryInternal(*lock, *pending_query);
942: 		}
943: 		// now append the result to the list of results
944: 		if (!last_result || !last_had_result) {
945: 			// first result of the query
946: 			result = std::move(current_result);
947: 			last_result = result.get();
948: 			last_had_result = has_result;
949: 		} else {
950: 			// later results; attach to the result chain
951: 			// but only if there is a result
952: 			if (!has_result) {
953: 				continue;
954: 			}
955: 			last_result->next = std::move(current_result);
956: 			last_result = last_result->next.get();
957: 		}
958: 		D_ASSERT(last_result);
959: 		if (last_result->HasError()) {
960: 			// Reset the interrupted flag, this was set by the task that found the error
961: 			// Next statements should not be bothered by that interruption
962: 			interrupted = false;
963: 		}
964: 	}
965: 	return result;
966: }
967: 
968: bool ClientContext::ParseStatements(ClientContextLock &lock, const string &query,
969:                                     vector<unique_ptr<SQLStatement>> &result, ErrorData &error) {
970: 	try {
971: 		InitialCleanup(lock);
972: 		// parse the query and transform it into a set of statements
973: 		result = ParseStatementsInternal(lock, query);
974: 		return true;
975: 	} catch (std::exception &ex) {
976: 		error = ErrorData(ex);
977: 		return false;
978: 	}
979: }
980: 
981: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const string &query, bool allow_stream_result) {
982: 	auto lock = LockContext();
983: 
984: 	ErrorData error;
985: 	vector<unique_ptr<SQLStatement>> statements;
986: 	if (!ParseStatements(*lock, query, statements, error)) {
987: 		return ErrorResult<PendingQueryResult>(std::move(error), query);
988: 	}
989: 	if (statements.size() != 1) {
990: 		return ErrorResult<PendingQueryResult>(ErrorData("PendingQuery can only take a single statement"), query);
991: 	}
992: 	PendingQueryParameters parameters;
993: 	parameters.allow_stream_result = allow_stream_result;
994: 	return PendingQueryInternal(*lock, std::move(statements[0]), parameters);
995: }
996: 
997: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(unique_ptr<SQLStatement> statement,
998:                                                            bool allow_stream_result) {
999: 	auto lock = LockContext();
1000: 
1001: 	try {
1002: 		InitialCleanup(*lock);
1003: 	} catch (std::exception &ex) {
1004: 		return ErrorResult<PendingQueryResult>(ErrorData(ex));
1005: 	}
1006: 
1007: 	PendingQueryParameters parameters;
1008: 	parameters.allow_stream_result = allow_stream_result;
1009: 	return PendingQueryInternal(*lock, std::move(statement), parameters);
1010: }
1011: 
1012: unique_ptr<PendingQueryResult> ClientContext::PendingQueryInternal(ClientContextLock &lock,
1013:                                                                    unique_ptr<SQLStatement> statement,
1014:                                                                    const PendingQueryParameters &parameters,
1015:                                                                    bool verify) {
1016: 	auto query = statement->query;
1017: 	shared_ptr<PreparedStatementData> prepared;
1018: 	if (verify) {
1019: 		return PendingStatementOrPreparedStatementInternal(lock, query, std::move(statement), prepared, parameters);
1020: 	} else {
1021: 		return PendingStatementOrPreparedStatement(lock, query, std::move(statement), prepared, parameters);
1022: 	}
1023: }
1024: 
1025: unique_ptr<QueryResult> ClientContext::ExecutePendingQueryInternal(ClientContextLock &lock, PendingQueryResult &query) {
1026: 	return query.ExecuteInternal(lock);
1027: }
1028: 
1029: void ClientContext::Interrupt() {
1030: 	interrupted = true;
1031: }
1032: 
1033: void ClientContext::CancelTransaction() {
1034: 	auto lock = LockContext();
1035: 	InitialCleanup(*lock);
1036: }
1037: 
1038: void ClientContext::EnableProfiling() {
1039: 	auto lock = LockContext();
1040: 	auto &client_config = ClientConfig::GetConfig(*this);
1041: 	client_config.enable_profiler = true;
1042: 	client_config.emit_profiler_output = true;
1043: }
1044: 
1045: void ClientContext::DisableProfiling() {
1046: 	auto lock = LockContext();
1047: 	auto &client_config = ClientConfig::GetConfig(*this);
1048: 	client_config.enable_profiler = false;
1049: }
1050: 
1051: void ClientContext::RegisterFunction(CreateFunctionInfo &info) {
1052: 	RunFunctionInTransaction([&]() {
1053: 		auto existing_function = Catalog::GetEntry<ScalarFunctionCatalogEntry>(*this, INVALID_CATALOG, info.schema,
1054: 		                                                                       info.name, OnEntryNotFound::RETURN_NULL);
1055: 		if (existing_function) {
1056: 			auto &new_info = info.Cast<CreateScalarFunctionInfo>();
1057: 			if (new_info.functions.MergeFunctionSet(existing_function->functions)) {
1058: 				// function info was updated from catalog entry, rewrite is needed
1059: 				info.on_conflict = OnCreateConflict::REPLACE_ON_CONFLICT;
1060: 			}
1061: 		}
1062: 		// create function
1063: 		auto &catalog = Catalog::GetSystemCatalog(*this);
1064: 		catalog.CreateFunction(*this, info);
1065: 	});
1066: }
1067: 
1068: void ClientContext::RunFunctionInTransactionInternal(ClientContextLock &lock, const std::function<void(void)> &fun,
1069:                                                      bool requires_valid_transaction) {
1070: 	if (requires_valid_transaction && transaction.HasActiveTransaction() &&
1071: 	    ValidChecker::IsInvalidated(ActiveTransaction())) {
1072: 		throw TransactionException(ErrorManager::FormatException(*this, ErrorType::INVALIDATED_TRANSACTION));
1073: 	}
1074: 	// check if we are on AutoCommit. In this case we should start a transaction
1075: 	bool require_new_transaction = transaction.IsAutoCommit() && !transaction.HasActiveTransaction();
1076: 	if (require_new_transaction) {
1077: 		D_ASSERT(!active_query);
1078: 		transaction.BeginTransaction();
1079: 	}
1080: 	try {
1081: 		fun();
1082: 	} catch (std::exception &ex) {
1083: 		ErrorData error(ex);
1084: 		bool invalidates_transaction = true;
1085: 		if (!Exception::InvalidatesTransaction(error.Type())) {
1086: 			// standard exceptions don't invalidate the transaction
1087: 			invalidates_transaction = false;
1088: 		} else if (Exception::InvalidatesDatabase(error.Type())) {
1089: 			auto &db_instance = DatabaseInstance::GetDatabase(*this);
1090: 			ValidChecker::Invalidate(db_instance, error.RawMessage());
1091: 		}
1092: 		if (require_new_transaction) {
1093: 			transaction.Rollback(error);
1094: 		} else if (invalidates_transaction) {
1095: 			ValidChecker::Invalidate(ActiveTransaction(), error.RawMessage());
1096: 		}
1097: 		throw;
1098: 	}
1099: 	if (require_new_transaction) {
1100: 		transaction.Commit();
1101: 	}
1102: }
1103: 
1104: void ClientContext::RunFunctionInTransaction(const std::function<void(void)> &fun, bool requires_valid_transaction) {
1105: 	auto lock = LockContext();
1106: 	RunFunctionInTransactionInternal(*lock, fun, requires_valid_transaction);
1107: }
1108: 
1109: unique_ptr<TableDescription> ClientContext::TableInfo(const string &schema_name, const string &table_name) {
1110: 	unique_ptr<TableDescription> result;
1111: 	RunFunctionInTransaction([&]() {
1112: 		// obtain the table info
1113: 		auto table = Catalog::GetEntry<TableCatalogEntry>(*this, INVALID_CATALOG, schema_name, table_name,
1114: 		                                                  OnEntryNotFound::RETURN_NULL);
1115: 		if (!table) {
1116: 			return;
1117: 		}
1118: 		// write the table info to the result
1119: 		result = make_uniq<TableDescription>();
1120: 		result->schema = schema_name;
1121: 		result->table = table_name;
1122: 		for (auto &column : table->GetColumns().Logical()) {
1123: 			result->columns.emplace_back(column.Copy());
1124: 		}
1125: 	});
1126: 	return result;
1127: }
1128: 
1129: void ClientContext::Append(TableDescription &description, ColumnDataCollection &collection) {
1130: 	RunFunctionInTransaction([&]() {
1131: 		auto &table_entry =
1132: 		    Catalog::GetEntry<TableCatalogEntry>(*this, INVALID_CATALOG, description.schema, description.table);
1133: 		// verify that the table columns and types match up
1134: 		if (description.columns.size() != table_entry.GetColumns().PhysicalColumnCount()) {
1135: 			throw InvalidInputException("Failed to append: table entry has different number of columns!");
1136: 		}
1137: 		for (idx_t i = 0; i < description.columns.size(); i++) {
1138: 			if (description.columns[i].Type() != table_entry.GetColumns().GetColumn(PhysicalIndex(i)).Type()) {
1139: 				throw InvalidInputException("Failed to append: table entry has different number of columns!");
1140: 			}
1141: 		}
1142: 		auto binder = Binder::CreateBinder(*this);
1143: 		auto bound_constraints = binder->BindConstraints(table_entry);
1144: 		MetaTransaction::Get(*this).ModifyDatabase(table_entry.ParentCatalog().GetAttached());
1145: 		table_entry.GetStorage().LocalAppend(table_entry, *this, collection, bound_constraints);
1146: 	});
1147: }
1148: 
1149: void ClientContext::TryBindRelation(Relation &relation, vector<ColumnDefinition> &result_columns) {
1150: #ifdef DEBUG
1151: 	D_ASSERT(!relation.GetAlias().empty());
1152: 	D_ASSERT(!relation.ToString().empty());
1153: #endif
1154: 	RunFunctionInTransaction([&]() {
1155: 		// bind the expressions
1156: 		auto binder = Binder::CreateBinder(*this);
1157: 		auto result = relation.Bind(*binder);
1158: 		D_ASSERT(result.names.size() == result.types.size());
1159: 
1160: 		result_columns.reserve(result_columns.size() + result.names.size());
1161: 		for (idx_t i = 0; i < result.names.size(); i++) {
1162: 			result_columns.emplace_back(result.names[i], result.types[i]);
1163: 		}
1164: 	});
1165: }
1166: 
1167: unordered_set<string> ClientContext::GetTableNames(const string &query) {
1168: 	auto lock = LockContext();
1169: 
1170: 	auto statements = ParseStatementsInternal(*lock, query);
1171: 	if (statements.size() != 1) {
1172: 		throw InvalidInputException("Expected a single statement");
1173: 	}
1174: 
1175: 	unordered_set<string> result;
1176: 	RunFunctionInTransactionInternal(*lock, [&]() {
1177: 		// bind the expressions
1178: 		auto binder = Binder::CreateBinder(*this);
1179: 		binder->SetBindingMode(BindingMode::EXTRACT_NAMES);
1180: 		binder->Bind(*statements[0]);
1181: 		result = binder->GetTableNames();
1182: 	});
1183: 	return result;
1184: }
1185: 
1186: unique_ptr<PendingQueryResult> ClientContext::PendingQueryInternal(ClientContextLock &lock,
1187:                                                                    const shared_ptr<Relation> &relation,
1188:                                                                    bool allow_stream_result) {
1189: 	InitialCleanup(lock);
1190: 
1191: 	string query;
1192: 	if (config.query_verification_enabled) {
1193: 		// run the ToString method of any relation we run, mostly to ensure it doesn't crash
1194: 		relation->ToString();
1195: 		relation->GetAlias();
1196: 		if (relation->IsReadOnly()) {
1197: 			// verify read only statements by running a select statement
1198: 			auto select = make_uniq<SelectStatement>();
1199: 			select->node = relation->GetQueryNode();
1200: 			RunStatementInternal(lock, query, std::move(select), false);
1201: 		}
1202: 	}
1203: 
1204: 	auto relation_stmt = make_uniq<RelationStatement>(relation);
1205: 	PendingQueryParameters parameters;
1206: 	parameters.allow_stream_result = allow_stream_result;
1207: 	return PendingQueryInternal(lock, std::move(relation_stmt), parameters);
1208: }
1209: 
1210: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const shared_ptr<Relation> &relation,
1211:                                                            bool allow_stream_result) {
1212: 	auto lock = LockContext();
1213: 	return PendingQueryInternal(*lock, relation, allow_stream_result);
1214: }
1215: 
1216: unique_ptr<QueryResult> ClientContext::Execute(const shared_ptr<Relation> &relation) {
1217: 	auto lock = LockContext();
1218: 	auto &expected_columns = relation->Columns();
1219: 	auto pending = PendingQueryInternal(*lock, relation, false);
1220: 	if (!pending->success) {
1221: 		return ErrorResult<MaterializedQueryResult>(pending->GetErrorObject());
1222: 	}
1223: 
1224: 	unique_ptr<QueryResult> result;
1225: 	result = ExecutePendingQueryInternal(*lock, *pending);
1226: 	if (result->HasError()) {
1227: 		return result;
1228: 	}
1229: 	// verify that the result types and result names of the query match the expected result types/names
1230: 	if (result->types.size() == expected_columns.size()) {
1231: 		bool mismatch = false;
1232: 		for (idx_t i = 0; i < result->types.size(); i++) {
1233: 			if (result->types[i] != expected_columns[i].Type() || result->names[i] != expected_columns[i].Name()) {
1234: 				mismatch = true;
1235: 				break;
1236: 			}
1237: 		}
1238: 		if (!mismatch) {
1239: 			// all is as expected: return the result
1240: 			return result;
1241: 		}
1242: 	}
1243: 	// result mismatch
1244: 	string err_str = "Result mismatch in query!\nExpected the following columns: [";
1245: 	for (idx_t i = 0; i < expected_columns.size(); i++) {
1246: 		if (i > 0) {
1247: 			err_str += ", ";
1248: 		}
1249: 		err_str += expected_columns[i].Name() + " " + expected_columns[i].Type().ToString();
1250: 	}
1251: 	err_str += "]\nBut result contained the following: ";
1252: 	for (idx_t i = 0; i < result->types.size(); i++) {
1253: 		err_str += i == 0 ? "[" : ", ";
1254: 		err_str += result->names[i] + " " + result->types[i].ToString();
1255: 	}
1256: 	err_str += "]";
1257: 	return ErrorResult<MaterializedQueryResult>(ErrorData(err_str));
1258: }
1259: 
1260: SettingLookupResult ClientContext::TryGetCurrentSetting(const std::string &key, Value &result) const {
1261: 	// first check the built-in settings
1262: 	auto &db_config = DBConfig::GetConfig(*this);
1263: 	auto option = db_config.GetOptionByName(key);
1264: 	if (option) {
1265: 		result = option->get_setting(*this);
1266: 		return SettingLookupResult(SettingScope::LOCAL);
1267: 	}
1268: 
1269: 	// check the client session values
1270: 	const auto &session_config_map = config.set_variables;
1271: 
1272: 	auto session_value = session_config_map.find(key);
1273: 	bool found_session_value = session_value != session_config_map.end();
1274: 	if (found_session_value) {
1275: 		result = session_value->second;
1276: 		return SettingLookupResult(SettingScope::LOCAL);
1277: 	}
1278: 	// finally check the global session values
1279: 	return db->TryGetCurrentSetting(key, result);
1280: }
1281: 
1282: ParserOptions ClientContext::GetParserOptions() const {
1283: 	auto &client_config = ClientConfig::GetConfig(*this);
1284: 	ParserOptions options;
1285: 	options.preserve_identifier_case = client_config.preserve_identifier_case;
1286: 	options.integer_division = client_config.integer_division;
1287: 	options.max_expression_depth = client_config.max_expression_depth;
1288: 	options.extensions = &DBConfig::GetConfig(*this).parser_extensions;
1289: 	return options;
1290: }
1291: 
1292: ClientProperties ClientContext::GetClientProperties() const {
1293: 	string timezone = "UTC";
1294: 	Value result;
1295: 
1296: 	if (TryGetCurrentSetting("TimeZone", result)) {
1297: 		timezone = result.ToString();
1298: 	}
1299: 	return {timezone, db->config.options.arrow_offset_size, db->config.options.arrow_use_list_view,
1300: 	        db->config.options.produce_arrow_string_views};
1301: }
1302: 
1303: bool ClientContext::ExecutionIsFinished() {
1304: 	if (!active_query || !active_query->executor) {
1305: 		return false;
1306: 	}
1307: 	return active_query->executor->ExecutionIsFinished();
1308: }
1309: 
1310: } // namespace duckdb
[end of src/main/client_context.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: