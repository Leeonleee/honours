{
  "repo": "duckdb/duckdb",
  "pull_number": 9874,
  "instance_id": "duckdb__duckdb-9874",
  "issue_numbers": [
    "9863",
    "9863"
  ],
  "base_commit": "16a054ee04cb1b891f74bd9d56a5204cb47ab5f3",
  "patch": "diff --git a/src/optimizer/filter_combiner.cpp b/src/optimizer/filter_combiner.cpp\nindex c612b177f72b..89df31775d3c 100644\n--- a/src/optimizer/filter_combiner.cpp\n+++ b/src/optimizer/filter_combiner.cpp\n@@ -608,7 +608,9 @@ FilterResult FilterCombiner::AddBoundComparisonFilter(Expression &expr) {\n \t\t// get the current bucket of constant values\n \t\tD_ASSERT(constant_values.find(equivalence_set) != constant_values.end());\n \t\tauto &info_list = constant_values.find(equivalence_set)->second;\n-\t\tD_ASSERT(node.return_type == info.constant.type());\n+\t\tif (node.return_type != info.constant.type()) {\n+\t\t\treturn FilterResult::UNSUPPORTED;\n+\t\t}\n \t\t// check the existing constant comparisons to see if we can do any pruning\n \t\tauto ret = AddConstantComparison(info_list, info);\n \ndiff --git a/src/optimizer/rule/move_constants.cpp b/src/optimizer/rule/move_constants.cpp\nindex 9749213b11a5..d6b4436bdca1 100644\n--- a/src/optimizer/rule/move_constants.cpp\n+++ b/src/optimizer/rule/move_constants.cpp\n@@ -21,8 +21,12 @@ MoveConstantsRule::MoveConstantsRule(ExpressionRewriter &rewriter) : Rule(rewrit\n \tarithmetic->function = make_uniq<ManyFunctionMatcher>(unordered_set<string> {\"+\", \"-\", \"*\"});\n \t// we match only on integral numeric types\n \tarithmetic->type = make_uniq<IntegerTypeMatcher>();\n-\tarithmetic->matchers.push_back(make_uniq<ConstantExpressionMatcher>());\n-\tarithmetic->matchers.push_back(make_uniq<ExpressionMatcher>());\n+\tauto child_constant_matcher = make_uniq<ConstantExpressionMatcher>();\n+\tauto child_expression_matcher = make_uniq<ExpressionMatcher>();\n+\tchild_constant_matcher->type = make_uniq<IntegerTypeMatcher>();\n+\tchild_expression_matcher->type = make_uniq<IntegerTypeMatcher>();\n+\tarithmetic->matchers.push_back(std::move(child_constant_matcher));\n+\tarithmetic->matchers.push_back(std::move(child_expression_matcher));\n \tarithmetic->policy = SetMatcher::Policy::SOME;\n \top->matchers.push_back(std::move(arithmetic));\n \troot = std::move(op);\n@@ -34,9 +38,8 @@ unique_ptr<Expression> MoveConstantsRule::Apply(LogicalOperator &op, vector<refe\n \tauto &outer_constant = bindings[1].get().Cast<BoundConstantExpression>();\n \tauto &arithmetic = bindings[2].get().Cast<BoundFunctionExpression>();\n \tauto &inner_constant = bindings[3].get().Cast<BoundConstantExpression>();\n-\tif (!TypeIsIntegral(arithmetic.return_type.InternalType())) {\n-\t\treturn nullptr;\n-\t}\n+\tD_ASSERT(arithmetic.return_type.IsIntegral());\n+\tD_ASSERT(arithmetic.children[0]->return_type.IsIntegral());\n \tif (inner_constant.value.IsNull() || outer_constant.value.IsNull()) {\n \t\treturn make_uniq<BoundConstantExpression>(Value(comparison.return_type));\n \t}\n",
  "test_patch": "diff --git a/test/sql/optimizer/expression/test_date_subtract_filter.test b/test/sql/optimizer/expression/test_date_subtract_filter.test\nnew file mode 100644\nindex 000000000000..1a28e412af84\n--- /dev/null\n+++ b/test/sql/optimizer/expression/test_date_subtract_filter.test\n@@ -0,0 +1,20 @@\n+# name: test/sql/optimizer/expression/test_date_subtract_filter.test\n+# description: Issue #9863 - query involving a subtraction between dates and a comparison\n+# group: [expression]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE dates(lo_commitdate DATE);\n+\n+statement ok\n+INSERT INTO dates VALUES (DATE '1992-02-10');\n+\n+query I\n+SELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\n+FROM dates AS \"ta_1\"\n+HAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\n+ORDER BY \"ca_1\" ASC;\n+----\n+10237\n",
  "problem_statement": "Inconsistent query results\n### What happens?\n\nI have a table of values and a simple `SELECT` statement, which does not appear to have any dynamic aspects to it. However, running the `SELECT` repeatedly yields multiple results. The query in question is:\r\n\r\n```sql\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n```\r\n\r\nWhen I run this repeatedly via the following:\r\n\r\n```sql\r\nCREATE TABLE tpch5k_falcon_default_schema_lineorder AS SELECT * FROM 'tpch5k_falcon_default_schema_lineorder.csv';\r\n\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n```\r\n\r\nI get the following results:\r\n\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 ca_1  \u2502\r\n\u2502 int64 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 10237 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  ca_1  \u2502\r\n\u2502 int64  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0 rows \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  ca_1  \u2502\r\n\u2502 int64  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0 rows \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  ca_1  \u2502\r\n\u2502 int64  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0 rows \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  ca_1  \u2502\r\n\u2502 int64  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0 rows \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nAs you can see, sometimes the result is `10237` and sometimes the result is zero rows returned.\n\n### To Reproduce\n\nI am attaching the SQL (test.sql) and the input data (tpch5k_falcon_default_schema_lineorder.csv) as a ZIP file:\r\n\r\n[Archive.zip](https://github.com/duckdb/duckdb/files/13517248/Archive.zip)\r\n\r\nUnzip the file and run the supplied SQL through DuckDB:\r\n\r\n```\r\nunzip Archive.zip\r\ncat test.sql | duckdb\r\n```\r\n\r\nYou should see that sometimes the query returns 1 row and sometimes it returns no rows.\n\n### OS:\n\nmacOS aarch64\n\n### DuckDB Version:\n\n0.9.2\n\n### DuckDB Client:\n\nCLI, JDBC\n\n### Full Name:\n\nRyan Kennedy\n\n### Affiliation:\n\nMode Analytics/ThoughtSpot\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a release build (and could not test with a main build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\nInconsistent query results\n### What happens?\n\nI have a table of values and a simple `SELECT` statement, which does not appear to have any dynamic aspects to it. However, running the `SELECT` repeatedly yields multiple results. The query in question is:\r\n\r\n```sql\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n```\r\n\r\nWhen I run this repeatedly via the following:\r\n\r\n```sql\r\nCREATE TABLE tpch5k_falcon_default_schema_lineorder AS SELECT * FROM 'tpch5k_falcon_default_schema_lineorder.csv';\r\n\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n\r\nSELECT CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) AS \"ca_1\"\r\nFROM \"tpch5k_falcon_default_schema_lineorder\" AS \"ta_1\"\r\nHAVING CAST('2020-02-20' AS date) - CAST(min(\"ta_1\".\"lo_commitdate\") AS date) > 4\r\nORDER BY \"ca_1\" ASC;\r\n```\r\n\r\nI get the following results:\r\n\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 ca_1  \u2502\r\n\u2502 int64 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 10237 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  ca_1  \u2502\r\n\u2502 int64  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0 rows \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  ca_1  \u2502\r\n\u2502 int64  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0 rows \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  ca_1  \u2502\r\n\u2502 int64  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0 rows \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  ca_1  \u2502\r\n\u2502 int64  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0 rows \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nAs you can see, sometimes the result is `10237` and sometimes the result is zero rows returned.\n\n### To Reproduce\n\nI am attaching the SQL (test.sql) and the input data (tpch5k_falcon_default_schema_lineorder.csv) as a ZIP file:\r\n\r\n[Archive.zip](https://github.com/duckdb/duckdb/files/13517248/Archive.zip)\r\n\r\nUnzip the file and run the supplied SQL through DuckDB:\r\n\r\n```\r\nunzip Archive.zip\r\ncat test.sql | duckdb\r\n```\r\n\r\nYou should see that sometimes the query returns 1 row and sometimes it returns no rows.\n\n### OS:\n\nmacOS aarch64\n\n### DuckDB Version:\n\n0.9.2\n\n### DuckDB Client:\n\nCLI, JDBC\n\n### Full Name:\n\nRyan Kennedy\n\n### Affiliation:\n\nMode Analytics/ThoughtSpot\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a release build (and could not test with a main build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "~I've just tried re-running this using a debug build of 37b775979b066bde52c0ba75c9c5c53e12b23e42 and I don't **think** I can reproduce this. I wonder if someone might know which change(s) on `main` that aren't in 0.9.2 could account for the issue no longer occurring if I use a `main` branch build. I'm curious to know if the problem was fully addressed or simply made less likely to occur.~\r\n\r\nUpdate: I was inadvertently on the `master` branch in my local check out, which dated back to June 2022. I have switched to the `main` branch, rebuilt the DuckDB CLI, and can also reproduce there.\nHi @rkennedy-mode, thanks for reporting it. I can reproduce it on the latest main build (`v0.9.3-dev1047 1bf52db88d`). I'm on macOS (M2 Pro CPU).\r\n\r\n```bash\r\ncat test.sql | ~/git/duckdb/build/release/duckdb\r\nRun Time (s): real 0.124 user 0.120220 sys 0.001468\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 ca_1  \u2502\r\n\u2502 int64 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 10237 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nRun Time (s): real 0.000 user 0.000388 sys 0.000126\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 ca_1  \u2502\r\n\u2502 int64 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 10237 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nRun Time (s): real 0.000 user 0.000245 sys 0.000059\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  ca_1  \u2502\r\n\u2502 int64  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0 rows \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nAh! Thanks, @szarnyasg. I didn't realize that my local copy was using the `master` branch and had fallen behind.\n~I've just tried re-running this using a debug build of 37b775979b066bde52c0ba75c9c5c53e12b23e42 and I don't **think** I can reproduce this. I wonder if someone might know which change(s) on `main` that aren't in 0.9.2 could account for the issue no longer occurring if I use a `main` branch build. I'm curious to know if the problem was fully addressed or simply made less likely to occur.~\r\n\r\nUpdate: I was inadvertently on the `master` branch in my local check out, which dated back to June 2022. I have switched to the `main` branch, rebuilt the DuckDB CLI, and can also reproduce there.\nHi @rkennedy-mode, thanks for reporting it. I can reproduce it on the latest main build (`v0.9.3-dev1047 1bf52db88d`). I'm on macOS (M2 Pro CPU).\r\n\r\n```bash\r\ncat test.sql | ~/git/duckdb/build/release/duckdb\r\nRun Time (s): real 0.124 user 0.120220 sys 0.001468\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 ca_1  \u2502\r\n\u2502 int64 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 10237 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nRun Time (s): real 0.000 user 0.000388 sys 0.000126\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 ca_1  \u2502\r\n\u2502 int64 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 10237 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nRun Time (s): real 0.000 user 0.000245 sys 0.000059\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  ca_1  \u2502\r\n\u2502 int64  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0 rows \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nAh! Thanks, @szarnyasg. I didn't realize that my local copy was using the `master` branch and had fallen behind.",
  "created_at": "2023-12-02T14:27:19Z"
}