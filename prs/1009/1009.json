{
  "repo": "duckdb/duckdb",
  "pull_number": 1009,
  "instance_id": "duckdb__duckdb-1009",
  "issue_numbers": [
    "1012"
  ],
  "base_commit": "cacca41f9d1873167506a631cdbf84c7a6d93a58",
  "patch": "diff --git a/.travis.yml b/.travis.yml\nindex 50a306fc7de9..dafb385f10f2 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -482,7 +482,7 @@ matrix:\n          # this tests whether we can run DuckDB as a UDF within PostgreSQL, mainly to check for symbol clashes in libpg_query\n         - sudo mkdir /home/postgres && sudo chown postgres /home/postgres\n         - sudo python3 -m pip install --prefix=/tmp tools/pythonpkg/wheelhouse/duckdb-*-cp36-cp36m-manylinux1_x86_64.whl\n-        - sudo -Hiu postgres psql -c \"CREATE EXTENSION plpython3u\"\n+        - python3 $TRAVIS_BUILD_DIR/scripts/repeat_until_success.py \"sudo -Hiu postgres psql -c \\\"CREATE EXTENSION plpython3u\\\"\"\n         - echo -e \"CREATE FUNCTION quack ()\\nRETURNS integer\\nAS \\$\\$\\nimport sys\\nsys.path.insert(0,'/tmp/lib/python3.6/site-packages/')\\nimport duckdb\\ncon = duckdb.connect(':memory:')\\ncon.execute('CREATE TABLE a(i integer)')\\ncon.execute('INSERT INTO a VALUES (42)')\\nreturn con.execute('SELECT * FROM a').fetchall()[0][0]\\n\\$\\$ LANGUAGE plpython3u\" | sudo -Hiu postgres psql\n         - sudo -Hiu postgres psql -c \"SELECT quack()\"\n \ndiff --git a/scripts/repeat_until_success.py b/scripts/repeat_until_success.py\nnew file mode 100644\nindex 000000000000..abf49698677e\n--- /dev/null\n+++ b/scripts/repeat_until_success.py\n@@ -0,0 +1,20 @@\n+import os\n+import sys\n+import time\n+\n+if len(sys.argv) <= 1:\n+\tprint(\"Expected usage: python3 repeat_until_success.py [command]\")\n+\texit(1)\n+\n+ntries = 10\n+sleep_duration = 3\n+cmd = sys.argv[1]\n+\n+for i in range(ntries):\n+\tret = os.system(cmd)\n+\tif ret is None or ret == 0:\n+\t\texit(0)\n+\tprint(\"Command {{ \" + cmd + \" }} failed, retrying (\" + str(i + 1) + \"/\" + str(ntries) + \")\")\n+\ttime.sleep(sleep_duration)\n+\n+exit(1)\ndiff --git a/src/common/file_system.cpp b/src/common/file_system.cpp\nindex d8199e182b06..012a67b93cfa 100644\n--- a/src/common/file_system.cpp\n+++ b/src/common/file_system.cpp\n@@ -8,11 +8,37 @@\n #include \"duckdb/main/database.hpp\"\n #include \"duckdb/function/scalar/string_functions.hpp\"\n \n+#include <cstdio>\n+\n+#ifndef _WIN32\n+#include <dirent.h>\n+#include <fcntl.h>\n+#include <string.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+#else\n+#include <string>\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+\n+#ifdef __MINGW32__\n+// need to manually define this for mingw\n+extern \"C\" WINBASEAPI BOOL WINAPI GetPhysicallyInstalledSystemMemory (PULONGLONG );\n+#endif\n+\n+\n+#undef CreateDirectory\n+#undef MoveFile\n+#undef RemoveDirectory\n+#undef FILE_CREATE // woo mingw\n+#endif\n+\n namespace duckdb {\n using namespace std;\n \n-#include <cstdio>\n-\n FileSystem &FileSystem::GetFileSystem(ClientContext &context) {\n \treturn *context.db.config.file_system;\n }\n@@ -28,14 +54,8 @@ static void AssertValidFileFlags(uint8_t flags) {\n \tassert(!(flags & FileFlags::FILE_FLAGS_FILE_CREATE && flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW));\n }\n \n-#ifndef _WIN32\n-#include <dirent.h>\n-#include <fcntl.h>\n-#include <string.h>\n-#include <sys/stat.h>\n-#include <sys/types.h>\n-#include <unistd.h>\n \n+#ifndef _WIN32\n // somehow sometimes this is missing\n #ifndef O_CLOEXEC\n #define O_CLOEXEC 0\n@@ -334,23 +354,6 @@ string FileSystem::GetWorkingDirectory() {\n }\n #else\n \n-#include <string>\n-#ifndef NOMINMAX\n-#define NOMINMAX\n-#endif\n-#include <windows.h>\n-\n-#ifdef __MINGW32__\n-// need to manually define this for mingw\n-extern \"C\" WINBASEAPI BOOL WINAPI GetPhysicallyInstalledSystemMemory (PULONGLONG );\n-#endif\n-\n-\n-#undef CreateDirectory\n-#undef MoveFile\n-#undef RemoveDirectory\n-#undef FILE_CREATE // woo mingw\n-\n // Returns the last Win32 error, in string format. Returns an empty string if there is no error.\n std::string GetLastErrorAsString() {\n \t// Get the error message, if any.\ndiff --git a/src/function/function.cpp b/src/function/function.cpp\nindex 16ce6da19988..560f8da5bb81 100644\n--- a/src/function/function.cpp\n+++ b/src/function/function.cpp\n@@ -353,7 +353,8 @@ unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientCon\n \tbound_function.CastToFunctionArguments(children);\n \n \t// now create the function\n-\treturn make_unique<BoundFunctionExpression>(bound_function.return_type, move(bound_function), move(children),\n+\tauto return_type = bound_function.return_type;\n+\treturn make_unique<BoundFunctionExpression>(move(return_type), move(bound_function), move(children),\n \t                                            move(bind_info), is_operator);\n }\n \ndiff --git a/src/include/duckdb/function/scalar/strftime.hpp b/src/include/duckdb/function/scalar/strftime.hpp\nindex 6654dbc85762..cdd716caf7c5 100644\n--- a/src/include/duckdb/function/scalar/strftime.hpp\n+++ b/src/include/duckdb/function/scalar/strftime.hpp\n@@ -54,6 +54,8 @@ enum class StrTimeSpecifier : uint8_t {\n \n struct StrTimeFormat {\n public:\n+\tvirtual ~StrTimeFormat(){}\n+\n \tstatic string ParseFormatSpecifier(string format_string, StrTimeFormat &format);\n \n protected:\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 67586a02428b..b0572b563f15 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -206,10 +206,11 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {\n \tfor (idx_t i = 0; i < statement.select_list.size(); i++) {\n \t\tauto &expr = statement.select_list[i];\n \t\tresult->names.push_back(expr->GetName());\n+\t\tExpressionBinder::BindTableNames(*this, *expr);\n \t\tif (!expr->alias.empty()) {\n \t\t\talias_map[expr->alias] = i;\n+\t\t\tresult->names[i] = expr->alias;\n \t\t}\n-\t\tExpressionBinder::BindTableNames(*this, *expr);\n \t\tprojection_map[expr.get()] = i;\n \t\tresult->original_expressions.push_back(expr->Copy());\n \t}\ndiff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp\nindex 70b9fa8185c3..6b9fd4761bdb 100644\n--- a/src/planner/expression_binder.cpp\n+++ b/src/planner/expression_binder.cpp\n@@ -169,6 +169,7 @@ void ExpressionBinder::BindTableNames(Binder &binder, ParsedExpression &expr) {\n \t\t\t// no table name: find a binding that contains this\n \t\t\tcolref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);\n \t\t}\n+\t\tbinder.bind_context.BindColumn(colref, 0);\n \t}\n \tParsedExpressionIterator::EnumerateChildren(\n \t    expr, [&](const ParsedExpression &child) { BindTableNames(binder, (ParsedExpression &)child); });\ndiff --git a/src/planner/table_binding.cpp b/src/planner/table_binding.cpp\nindex 7ca0f7beb47c..e50dd18f6c57 100644\n--- a/src/planner/table_binding.cpp\n+++ b/src/planner/table_binding.cpp\n@@ -42,6 +42,9 @@ BindResult Binding::Bind(ColumnRefExpression &colref, idx_t depth) {\n \tbinding.table_index = index;\n \tbinding.column_index = column_entry->second;\n \tLogicalType sql_type = types[column_entry->second];\n+\tif (colref.alias.empty()) {\n+\t\tcolref.alias = names[column_entry->second];\n+\t}\n \treturn BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), sql_type, binding, depth));\n }\n \n@@ -80,6 +83,9 @@ BindResult TableBinding::Bind(ColumnRefExpression &colref, idx_t depth) {\n \t} else {\n \t\t// normal column: fetch type from base column\n \t\tcol_type = types[col_index];\n+\t\tif (colref.alias.empty()) {\n+\t\t\tcolref.alias = names[entry->second];\n+\t\t}\n \t}\n \n \tauto &column_ids = get.column_ids;\ndiff --git a/third_party/concurrentqueue/lightweightsemaphore.h b/third_party/concurrentqueue/lightweightsemaphore.h\nindex 0980e94e9196..6c41353bb81c 100644\n--- a/third_party/concurrentqueue/lightweightsemaphore.h\n+++ b/third_party/concurrentqueue/lightweightsemaphore.h\n@@ -26,6 +26,7 @@ extern \"C\" {\n #include <mach/mach.h>\n #elif defined(__unix__)\n #include <semaphore.h>\n+#include <chrono>\n #endif\n \n namespace moodycamel\n@@ -160,8 +161,6 @@ class Semaphore\n \t}\n };\n #elif defined(__unix__)\n-#include <chrono>\n-\n //---------------------------------------------------------\n // Semaphore (POSIX, Linux)\n //---------------------------------------------------------\ndiff --git a/tools/shell/include/linenoise.h b/tools/shell/include/linenoise.h\nindex 6cbdd2bf744e..3748fa787ab8 100644\n--- a/tools/shell/include/linenoise.h\n+++ b/tools/shell/include/linenoise.h\n@@ -66,6 +66,8 @@ int linenoiseHistoryLoad(const char *filename);\n void linenoiseClearScreen(void);\n void linenoiseSetMultiLine(int ml);\n void linenoisePrintKeyCodes(void);\n+size_t linenoiseComputeRenderWidth(const char *buf, size_t len);\n+int linenoiseGetRenderPosition(const char *buf, size_t len, int max_width, int *n);\n \n #ifdef __cplusplus\n }\ndiff --git a/tools/shell/linenoise.cpp b/tools/shell/linenoise.cpp\nindex a184ef8547b1..4caf4a7906fb 100644\n--- a/tools/shell/linenoise.cpp\n+++ b/tools/shell/linenoise.cpp\n@@ -553,7 +553,7 @@ void refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {\n \t}\n }\n \n-static size_t compute_render_width(const char *buf, size_t len) {\n+size_t linenoiseComputeRenderWidth(const char *buf, size_t len) {\n \tif (utf8proc_is_valid(buf, len)) {\n \t\t// utf8 in prompt, get render width\n \t\tsize_t cpos = 0;\n@@ -570,6 +570,28 @@ static size_t compute_render_width(const char *buf, size_t len) {\n \t}\n }\n \n+int linenoiseGetRenderPosition(const char *buf, size_t len, int max_width, int *n) {\n+\tif (utf8proc_is_valid(buf, len)) {\n+\t\t// utf8 in prompt, get render width\n+\t\tsize_t cpos = 0;\n+\t\tsize_t render_width = 0;\n+\t\twhile (cpos < len) {\n+\t\t\tsize_t char_render_width = utf8proc_render_width(buf, len, cpos);\n+\t\t\tif (int(render_width + char_render_width) > max_width) {\n+\t\t\t\t*n = render_width;\n+\t\t\t\treturn cpos;\n+\t\t\t}\n+\t\t\tcpos = utf8proc_next_grapheme_cluster(buf, len, cpos);\n+\t\t\trender_width += char_render_width;\n+\t\t}\n+\t\t*n = render_width;\n+\t\treturn len;\n+\t} else {\n+\t\t// invalid utf8, return -1\n+\t\treturn -1;\n+\t}\n+}\n+\n #ifndef DISABLE_HIGHLIGHT\n const char *getColorOption(const char *option) {\n \tsize_t index = 0;\n@@ -678,7 +700,7 @@ std::string highlightText(char *buf, size_t len, size_t start_pos, size_t end_po\n  * cursor position, and number of columns of the terminal. */\n static void refreshSingleLine(struct linenoiseState *l) {\n \tchar seq[64];\n-\tsize_t plen = compute_render_width(l->prompt, strlen(l->prompt));\n+\tsize_t plen = linenoiseComputeRenderWidth(l->prompt, strlen(l->prompt));\n \tint fd = l->ofd;\n \tchar *buf = l->buf;\n \tsize_t len = l->len;\ndiff --git a/tools/shell/shell.c b/tools/shell/shell.c\nindex 5e176fcae08f..c3416be43a94 100644\n--- a/tools/shell/shell.c\n+++ b/tools/shell/shell.c\n@@ -573,6 +573,10 @@ static void utf8_width_print(FILE *pOut, int w, const char *zUtf){\n   int aw = w<0 ? -w : w;\n   char zBuf[1000];\n   if( aw>(int)sizeof(zBuf)/3 ) aw = (int)sizeof(zBuf)/3;\n+#ifdef HAVE_LINENOISE\n+  i = linenoiseGetRenderPosition(zUtf, strlen(zUtf), aw, &n);\n+  if (i < 0)\n+#endif\n   for(i=n=0; zUtf[i]; i++){\n     if( (zUtf[i]&0xc0)!=0x80 ){\n       n++;\n@@ -630,15 +634,18 @@ static int strlen30(const char *z){\n }\n \n /*\n-** Return the length of a string in characters.  Multibyte UTF8 characters\n-** count as a single character.\n+** Return the length of a string in characters.\n */\n static int strlenChar(const char *z){\n+#ifdef HAVE_LINENOISE\n+  return linenoiseComputeRenderWidth(z, strlen(z));\n+#else\n   int n = 0;\n   while( *z ){\n     if( (0xc0&*(z++))!=0x80 ) n++;\n   }\n   return n;\n+#endif\n }\n \n /*\n",
  "test_patch": "diff --git a/test/api/test_arrow.cpp b/test/api/test_arrow.cpp\nindex 91ca8d3f887b..5379271c12a8 100644\n--- a/test/api/test_arrow.cpp\n+++ b/test/api/test_arrow.cpp\n@@ -68,6 +68,7 @@ static void test_arrow_round_trip(string q) {\n \n \t// query that creates a bunch of values across the types\n \tauto result = con.Query(q);\n+\tREQUIRE(result->success);\n \tauto my_stream = new MyArrowArrayStream(move(result));\n \tauto result2 = con.TableFunction(\"arrow_scan\", {Value::POINTER((uintptr_t)&my_stream->stream)})->Execute();\n \n@@ -92,17 +93,15 @@ static void test_arrow_round_trip(string q) {\n }\n \n TEST_CASE(\"Test Arrow API round trip\", \"[arrow]\") {\n+\t// many types\n \ttest_arrow_round_trip(\n \t    \"select NULL c_null, (c % 4 = 0)::bool c_bool, (c%128)::tinyint c_tinyint, c::smallint*1000 c_smallint, \"\n \t    \"c::integer*100000 c_integer, c::bigint*1000000000000 c_bigint, c::hugeint*10000000000000000000000000000000 \"\n-\t    \"c_hugeint, c::float c_float, c::double c_double, 'c_' || c::string c_string, current_date::date c_date, \"\n-\t    \"'1969-01-01'::date, current_time::time c_time, now()::timestamp c_timestamp \"\n+\t    \"c_hugeint, c::float c_float, c::double c_double, 'c_' || c::string c_string, DATE '1992-01-01'::date c_date, \"\n+\t    \"'1969-01-01'::date, TIME '13:07:16'::time c_time, timestamp '1992-01-01 12:00:00' c_timestamp \"\n \t    \"from (select case when range % 2 == 0 then range else null end as c from range(-10, 10)) sq\");\n-\t// test_arrow_round_trip(\n-\t//     \"select NULL c_null, (c % 4 = 0)::bool c_bool, (c%128)::tinyint c_tinyint, c::smallint*1000 c_smallint, \"\n-\t//     \"c::integer*100000 c_integer, c::bigint*1000000000000 c_bigint, c::hugeint*10000000000000000000000000000000 \"\n-\t//     \"c_hugeint, c::float c_float, c::double c_double, 'c_' || c::string c_string, current_date::date c_date, \"\n-\t//     \"'1969-01-01'::date, current_time::time c_time, now()::timestamp c_timestamp \"\n-\t//     \"from (select case when range % 2 == 0 then range else null end as c from range(-1000, 1000)) sq\");\n+\t// big result set\n+\ttest_arrow_round_trip(\n+\t    \"select i from range(0, 2000) sq(i)\");\n }\n-// TODO timestamp date time interval decimal\n+// TODO interval decimal\ndiff --git a/test/sql/binder/test_case_insensitive_binding.test b/test/sql/binder/test_case_insensitive_binding.test\nindex b83e22615cdd..43aa901a00c8 100644\n--- a/test/sql/binder/test_case_insensitive_binding.test\n+++ b/test/sql/binder/test_case_insensitive_binding.test\n@@ -10,6 +10,9 @@ PRAGMA enable_verification\n statement ok\n CREATE TABLE test (\"HeLlO\" INTEGER)\n \n+statement ok\n+INSERT INTO test VALUES (1)\n+\n # lowercase names are aliased\n statement ok\n SELECT HeLlO FROM test\n@@ -27,6 +30,24 @@ SELECT \"HELLO\" FROM test\n statement error\n SELECT \"HELLo\" FROM test\n \n+# verify that the column name of the original column is returned\n+query I\n+SELECT alias(HeLlO) FROM test\n+----\n+HeLlO\n+\n+query I\n+SELECT alias(hello) FROM test\n+----\n+HeLlO\n+\n+# verify that an alias here still works\n+query I\n+SELECT alias(x) FROM (SELECT HeLlO as x FROM test) tbl;\n+----\n+x\n+\n+# verify that it also works when we specify the table-name explicitly\n statement ok\n SELECT test.HeLlO FROM test\n \ndiff --git a/tools/pythonpkg/test-nat.py b/tools/pythonpkg/test-nat.py\ndeleted file mode 100644\nindex 0ac6e328932b..000000000000\n--- a/tools/pythonpkg/test-nat.py\n+++ /dev/null\n@@ -1,29 +0,0 @@\n-import pandas\n-import numpy as np\n-import datetime\n-import duckdb\n-df = pandas.DataFrame([{\"col1\":\"val1\",\"col2\":1.05},{\"col1\":\"val3\",\"col2\":np.NaN}])\n-df[\"newcol1\"] = np.where(df[\"col1\"] == \"val1\",np.NaN,df[\"col1\"])\n-current_time = datetime.datetime.now().replace(microsecond=0)\n-df['datetest'] = current_time\n-df.loc[0,'datetest'] = pandas.NaT\n-conn = duckdb.connect(':memory:')\n-conn.register('testing_null_values', df)\n-results = conn.execute('select * from testing_null_values').fetchall()\n-assert results[0][0] == 'val1'\n-assert results[0][1] == 1.05\n-assert results[0][2] == None\n-assert results[0][3] == None\n-assert results[1][0] == 'val3'\n-assert results[1][1] == None\n-assert results[1][2] == 'val3'\n-assert results[1][3] == current_time\n-result_df = conn.execute('select * from testing_null_values').fetchdf()\n-assert result_df['col1'][0] == df['col1'][0]\n-assert result_df['col1'][1] == df['col1'][1]\n-assert result_df['col2'][0] == df['col2'][0]\n-assert np.isnan(result_df['col2'][1])\n-assert np.isnan(result_df['newcol1'][0])\n-assert result_df['newcol1'][1] == df['newcol1'][1]\n-assert pandas.isnull(result_df['datetest'][0])\n-assert result_df['datetest'][1] == df['datetest'][1]\ndiff --git a/tools/pythonpkg/tests/test_case_alias.py b/tools/pythonpkg/tests/test_case_alias.py\nnew file mode 100644\nindex 000000000000..d024fc5d3790\n--- /dev/null\n+++ b/tools/pythonpkg/tests/test_case_alias.py\n@@ -0,0 +1,39 @@\n+import pandas\n+import numpy as np\n+import datetime\n+import duckdb\n+\n+class TestCaseAlias(object):\n+    def test_case_alias(self, duckdb_cursor):\n+        import pandas\n+        import numpy as np\n+        import datetime\n+        import duckdb\n+\n+        con = duckdb.connect(':memory:')\n+\n+        df = pandas.DataFrame([{\"COL1\": \"val1\", \"CoL2\": 1.05},{\"COL1\": \"val3\", \"CoL2\": 17}])\n+\n+        r1 = con.from_df(df).query('df', 'select * from df').fetchdf()\n+        assert r1[\"COL1\"][0] == \"val1\"\n+        assert r1[\"COL1\"][1] == \"val3\"\n+        assert r1[\"CoL2\"][0] == 1.05\n+        assert r1[\"CoL2\"][1] == 17\n+\n+        r2 = con.from_df(df).query('df', 'select COL1, COL2 from df').fetchdf()\n+        assert r2[\"COL1\"][0] == \"val1\"\n+        assert r2[\"COL1\"][1] == \"val3\"\n+        assert r2[\"CoL2\"][0] == 1.05\n+        assert r2[\"CoL2\"][1] == 17\n+\n+        r3 = con.from_df(df).query('df', 'select COL1, COL2 from df ORDER BY COL1').fetchdf()\n+        assert r3[\"COL1\"][0] == \"val1\"\n+        assert r3[\"COL1\"][1] == \"val3\"\n+        assert r3[\"CoL2\"][0] == 1.05\n+        assert r3[\"CoL2\"][1] == 17\n+\n+        r4 = con.from_df(df).query('df', 'select COL1, COL2 from df GROUP BY COL1, COL2 ORDER BY COL1').fetchdf()\n+        assert r4[\"COL1\"][0] == \"val1\"\n+        assert r4[\"COL1\"][1] == \"val3\"\n+        assert r4[\"CoL2\"][0] == 1.05\n+        assert r4[\"CoL2\"][1] == 17\n",
  "problem_statement": "When reading data from DuckDB in to pandas Dataframe, the cases of column names are not consistently preserved.\nFollowing the documents, I save a  pandas Dataframe with all column names in uppercase in  DuckDB. \r\nLoading back the data into pandas dataFrame, I do get all column names in uppercase if I run:\r\n```\r\ndf = conn.execute(select * from tablename).fetchdf()\r\n```\r\nHowever, all of the column names will be in lowercase if I run\r\n```\r\ndf = conn.execute(select column_name1, column_name2 ... from tablename).fetchdf()\r\n```\n",
  "hints_text": "",
  "created_at": "2020-10-14T16:45:53Z"
}