diff --git a/.travis.yml b/.travis.yml
index 50a306fc7de9..dafb385f10f2 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -482,7 +482,7 @@ matrix:
          # this tests whether we can run DuckDB as a UDF within PostgreSQL, mainly to check for symbol clashes in libpg_query
         - sudo mkdir /home/postgres && sudo chown postgres /home/postgres
         - sudo python3 -m pip install --prefix=/tmp tools/pythonpkg/wheelhouse/duckdb-*-cp36-cp36m-manylinux1_x86_64.whl
-        - sudo -Hiu postgres psql -c "CREATE EXTENSION plpython3u"
+        - python3 $TRAVIS_BUILD_DIR/scripts/repeat_until_success.py "sudo -Hiu postgres psql -c \"CREATE EXTENSION plpython3u\""
         - echo -e "CREATE FUNCTION quack ()
RETURNS integer
AS \$\$
import sys
sys.path.insert(0,'/tmp/lib/python3.6/site-packages/')
import duckdb
con = duckdb.connect(':memory:')
con.execute('CREATE TABLE a(i integer)')
con.execute('INSERT INTO a VALUES (42)')
return con.execute('SELECT * FROM a').fetchall()[0][0]
\$\$ LANGUAGE plpython3u" | sudo -Hiu postgres psql
         - sudo -Hiu postgres psql -c "SELECT quack()"
 
diff --git a/scripts/repeat_until_success.py b/scripts/repeat_until_success.py
new file mode 100644
index 000000000000..abf49698677e
--- /dev/null
+++ b/scripts/repeat_until_success.py
@@ -0,0 +1,20 @@
+import os
+import sys
+import time
+
+if len(sys.argv) <= 1:
+	print("Expected usage: python3 repeat_until_success.py [command]")
+	exit(1)
+
+ntries = 10
+sleep_duration = 3
+cmd = sys.argv[1]
+
+for i in range(ntries):
+	ret = os.system(cmd)
+	if ret is None or ret == 0:
+		exit(0)
+	print("Command {{ " + cmd + " }} failed, retrying (" + str(i + 1) + "/" + str(ntries) + ")")
+	time.sleep(sleep_duration)
+
+exit(1)
diff --git a/src/common/file_system.cpp b/src/common/file_system.cpp
index d8199e182b06..012a67b93cfa 100644
--- a/src/common/file_system.cpp
+++ b/src/common/file_system.cpp
@@ -8,11 +8,37 @@
 #include "duckdb/main/database.hpp"
 #include "duckdb/function/scalar/string_functions.hpp"
 
+#include <cstdio>
+
+#ifndef _WIN32
+#include <dirent.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#else
+#include <string>
+#ifndef NOMINMAX
+#define NOMINMAX
+#endif
+#include <windows.h>
+
+#ifdef __MINGW32__
+// need to manually define this for mingw
+extern "C" WINBASEAPI BOOL WINAPI GetPhysicallyInstalledSystemMemory (PULONGLONG );
+#endif
+
+
+#undef CreateDirectory
+#undef MoveFile
+#undef RemoveDirectory
+#undef FILE_CREATE // woo mingw
+#endif
+
 namespace duckdb {
 using namespace std;
 
-#include <cstdio>
-
 FileSystem &FileSystem::GetFileSystem(ClientContext &context) {
 	return *context.db.config.file_system;
 }
@@ -28,14 +54,8 @@ static void AssertValidFileFlags(uint8_t flags) {
 	assert(!(flags & FileFlags::FILE_FLAGS_FILE_CREATE && flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW));
 }
 
-#ifndef _WIN32
-#include <dirent.h>
-#include <fcntl.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <unistd.h>
 
+#ifndef _WIN32
 // somehow sometimes this is missing
 #ifndef O_CLOEXEC
 #define O_CLOEXEC 0
@@ -334,23 +354,6 @@ string FileSystem::GetWorkingDirectory() {
 }
 #else
 
-#include <string>
-#ifndef NOMINMAX
-#define NOMINMAX
-#endif
-#include <windows.h>
-
-#ifdef __MINGW32__
-// need to manually define this for mingw
-extern "C" WINBASEAPI BOOL WINAPI GetPhysicallyInstalledSystemMemory (PULONGLONG );
-#endif
-
-
-#undef CreateDirectory
-#undef MoveFile
-#undef RemoveDirectory
-#undef FILE_CREATE // woo mingw
-
 // Returns the last Win32 error, in string format. Returns an empty string if there is no error.
 std::string GetLastErrorAsString() {
 	// Get the error message, if any.
diff --git a/src/function/function.cpp b/src/function/function.cpp
index 16ce6da19988..560f8da5bb81 100644
--- a/src/function/function.cpp
+++ b/src/function/function.cpp
@@ -353,7 +353,8 @@ unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientCon
 	bound_function.CastToFunctionArguments(children);
 
 	// now create the function
-	return make_unique<BoundFunctionExpression>(bound_function.return_type, move(bound_function), move(children),
+	auto return_type = bound_function.return_type;
+	return make_unique<BoundFunctionExpression>(move(return_type), move(bound_function), move(children),
 	                                            move(bind_info), is_operator);
 }
 
diff --git a/src/include/duckdb/function/scalar/strftime.hpp b/src/include/duckdb/function/scalar/strftime.hpp
index 6654dbc85762..cdd716caf7c5 100644
--- a/src/include/duckdb/function/scalar/strftime.hpp
+++ b/src/include/duckdb/function/scalar/strftime.hpp
@@ -54,6 +54,8 @@ enum class StrTimeSpecifier : uint8_t {
 
 struct StrTimeFormat {
 public:
+	virtual ~StrTimeFormat(){}
+
 	static string ParseFormatSpecifier(string format_string, StrTimeFormat &format);
 
 protected:
diff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp
index 67586a02428b..b0572b563f15 100644
--- a/src/planner/binder/query_node/bind_select_node.cpp
+++ b/src/planner/binder/query_node/bind_select_node.cpp
@@ -206,10 +206,11 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
 		auto &expr = statement.select_list[i];
 		result->names.push_back(expr->GetName());
+		ExpressionBinder::BindTableNames(*this, *expr);
 		if (!expr->alias.empty()) {
 			alias_map[expr->alias] = i;
+			result->names[i] = expr->alias;
 		}
-		ExpressionBinder::BindTableNames(*this, *expr);
 		projection_map[expr.get()] = i;
 		result->original_expressions.push_back(expr->Copy());
 	}
diff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp
index 70b9fa8185c3..6b9fd4761bdb 100644
--- a/src/planner/expression_binder.cpp
+++ b/src/planner/expression_binder.cpp
@@ -169,6 +169,7 @@ void ExpressionBinder::BindTableNames(Binder &binder, ParsedExpression &expr) {
 			// no table name: find a binding that contains this
 			colref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);
 		}
+		binder.bind_context.BindColumn(colref, 0);
 	}
 	ParsedExpressionIterator::EnumerateChildren(
 	    expr, [&](const ParsedExpression &child) { BindTableNames(binder, (ParsedExpression &)child); });
diff --git a/src/planner/table_binding.cpp b/src/planner/table_binding.cpp
index 7ca0f7beb47c..e50dd18f6c57 100644
--- a/src/planner/table_binding.cpp
+++ b/src/planner/table_binding.cpp
@@ -42,6 +42,9 @@ BindResult Binding::Bind(ColumnRefExpression &colref, idx_t depth) {
 	binding.table_index = index;
 	binding.column_index = column_entry->second;
 	LogicalType sql_type = types[column_entry->second];
+	if (colref.alias.empty()) {
+		colref.alias = names[column_entry->second];
+	}
 	return BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), sql_type, binding, depth));
 }
 
@@ -80,6 +83,9 @@ BindResult TableBinding::Bind(ColumnRefExpression &colref, idx_t depth) {
 	} else {
 		// normal column: fetch type from base column
 		col_type = types[col_index];
+		if (colref.alias.empty()) {
+			colref.alias = names[entry->second];
+		}
 	}
 
 	auto &column_ids = get.column_ids;
diff --git a/third_party/concurrentqueue/lightweightsemaphore.h b/third_party/concurrentqueue/lightweightsemaphore.h
index 0980e94e9196..6c41353bb81c 100644
--- a/third_party/concurrentqueue/lightweightsemaphore.h
+++ b/third_party/concurrentqueue/lightweightsemaphore.h
@@ -26,6 +26,7 @@ extern "C" {
 #include <mach/mach.h>
 #elif defined(__unix__)
 #include <semaphore.h>
+#include <chrono>
 #endif
 
 namespace moodycamel
@@ -160,8 +161,6 @@ class Semaphore
 	}
 };
 #elif defined(__unix__)
-#include <chrono>
-
 //---------------------------------------------------------
 // Semaphore (POSIX, Linux)
 //---------------------------------------------------------
diff --git a/tools/shell/include/linenoise.h b/tools/shell/include/linenoise.h
index 6cbdd2bf744e..3748fa787ab8 100644
--- a/tools/shell/include/linenoise.h
+++ b/tools/shell/include/linenoise.h
@@ -66,6 +66,8 @@ int linenoiseHistoryLoad(const char *filename);
 void linenoiseClearScreen(void);
 void linenoiseSetMultiLine(int ml);
 void linenoisePrintKeyCodes(void);
+size_t linenoiseComputeRenderWidth(const char *buf, size_t len);
+int linenoiseGetRenderPosition(const char *buf, size_t len, int max_width, int *n);
 
 #ifdef __cplusplus
 }
diff --git a/tools/shell/linenoise.cpp b/tools/shell/linenoise.cpp
index a184ef8547b1..4caf4a7906fb 100644
--- a/tools/shell/linenoise.cpp
+++ b/tools/shell/linenoise.cpp
@@ -553,7 +553,7 @@ void refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {
 	}
 }
 
-static size_t compute_render_width(const char *buf, size_t len) {
+size_t linenoiseComputeRenderWidth(const char *buf, size_t len) {
 	if (utf8proc_is_valid(buf, len)) {
 		// utf8 in prompt, get render width
 		size_t cpos = 0;
@@ -570,6 +570,28 @@ static size_t compute_render_width(const char *buf, size_t len) {
 	}
 }
 
+int linenoiseGetRenderPosition(const char *buf, size_t len, int max_width, int *n) {
+	if (utf8proc_is_valid(buf, len)) {
+		// utf8 in prompt, get render width
+		size_t cpos = 0;
+		size_t render_width = 0;
+		while (cpos < len) {
+			size_t char_render_width = utf8proc_render_width(buf, len, cpos);
+			if (int(render_width + char_render_width) > max_width) {
+				*n = render_width;
+				return cpos;
+			}
+			cpos = utf8proc_next_grapheme_cluster(buf, len, cpos);
+			render_width += char_render_width;
+		}
+		*n = render_width;
+		return len;
+	} else {
+		// invalid utf8, return -1
+		return -1;
+	}
+}
+
 #ifndef DISABLE_HIGHLIGHT
 const char *getColorOption(const char *option) {
 	size_t index = 0;
@@ -678,7 +700,7 @@ std::string highlightText(char *buf, size_t len, size_t start_pos, size_t end_po
  * cursor position, and number of columns of the terminal. */
 static void refreshSingleLine(struct linenoiseState *l) {
 	char seq[64];
-	size_t plen = compute_render_width(l->prompt, strlen(l->prompt));
+	size_t plen = linenoiseComputeRenderWidth(l->prompt, strlen(l->prompt));
 	int fd = l->ofd;
 	char *buf = l->buf;
 	size_t len = l->len;
diff --git a/tools/shell/shell.c b/tools/shell/shell.c
index 5e176fcae08f..c3416be43a94 100644
--- a/tools/shell/shell.c
+++ b/tools/shell/shell.c
@@ -573,6 +573,10 @@ static void utf8_width_print(FILE *pOut, int w, const char *zUtf){
   int aw = w<0 ? -w : w;
   char zBuf[1000];
   if( aw>(int)sizeof(zBuf)/3 ) aw = (int)sizeof(zBuf)/3;
+#ifdef HAVE_LINENOISE
+  i = linenoiseGetRenderPosition(zUtf, strlen(zUtf), aw, &n);
+  if (i < 0)
+#endif
   for(i=n=0; zUtf[i]; i++){
     if( (zUtf[i]&0xc0)!=0x80 ){
       n++;
@@ -630,15 +634,18 @@ static int strlen30(const char *z){
 }
 
 /*
-** Return the length of a string in characters.  Multibyte UTF8 characters
-** count as a single character.
+** Return the length of a string in characters.
 */
 static int strlenChar(const char *z){
+#ifdef HAVE_LINENOISE
+  return linenoiseComputeRenderWidth(z, strlen(z));
+#else
   int n = 0;
   while( *z ){
     if( (0xc0&*(z++))!=0x80 ) n++;
   }
   return n;
+#endif
 }
 
 /*
