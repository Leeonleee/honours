{
  "repo": "duckdb/duckdb",
  "pull_number": 9155,
  "instance_id": "duckdb__duckdb-9155",
  "issue_numbers": [
    "9144"
  ],
  "base_commit": "2d59ecbd2808a316e1d7d70fe1ee4cdb07761f65",
  "patch": "diff --git a/tools/pythonpkg/src/arrow/arrow_array_stream.cpp b/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\nindex 3d8e13454ee9..baf5ee1be856 100644\n--- a/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\n+++ b/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\n@@ -243,14 +243,22 @@ py::object GetScalar(Value &constant, const string &timezone_config, const Arrow\n \t\tpy::object date_type = py::module_::import(\"pyarrow\").attr(\"timestamp\");\n \t\treturn dataset_scalar(scalar(converted_value, date_type(time_unit_string, py::arg(\"tz\") = timezone_config)));\n \t}\n-\tcase LogicalTypeId::UTINYINT:\n-\t\treturn dataset_scalar(constant.GetValue<uint8_t>());\n-\tcase LogicalTypeId::USMALLINT:\n-\t\treturn dataset_scalar(constant.GetValue<uint16_t>());\n-\tcase LogicalTypeId::UINTEGER:\n-\t\treturn dataset_scalar(constant.GetValue<uint32_t>());\n-\tcase LogicalTypeId::UBIGINT:\n-\t\treturn dataset_scalar(constant.GetValue<uint64_t>());\n+\tcase LogicalTypeId::UTINYINT: {\n+\t\tpy::object integer_type = py::module_::import(\"pyarrow\").attr(\"uint8\");\n+\t\treturn dataset_scalar(scalar(constant.GetValue<uint8_t>(), integer_type()));\n+\t}\n+\tcase LogicalTypeId::USMALLINT: {\n+\t\tpy::object integer_type = py::module_::import(\"pyarrow\").attr(\"uint16\");\n+\t\treturn dataset_scalar(scalar(constant.GetValue<uint16_t>(), integer_type()));\n+\t}\n+\tcase LogicalTypeId::UINTEGER: {\n+\t\tpy::object integer_type = py::module_::import(\"pyarrow\").attr(\"uint32\");\n+\t\treturn dataset_scalar(scalar(constant.GetValue<uint32_t>(), integer_type()));\n+\t}\n+\tcase LogicalTypeId::UBIGINT: {\n+\t\tpy::object integer_type = py::module_::import(\"pyarrow\").attr(\"uint64\");\n+\t\treturn dataset_scalar(scalar(constant.GetValue<uint64_t>(), integer_type()));\n+\t}\n \tcase LogicalTypeId::FLOAT:\n \t\treturn dataset_scalar(constant.GetValue<float>());\n \tcase LogicalTypeId::DOUBLE:\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py b/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py\nindex 6a665ffe109b..dae1e92e161c 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py\n@@ -1,3 +1,4 @@\n+from re import S\n import duckdb\n import os\n import pytest\n@@ -8,124 +9,153 @@\n ds = pytest.importorskip(\"pyarrow.dataset\")\n np = pytest.importorskip(\"numpy\")\n re = pytest.importorskip(\"re\")\n-from conftest import NumpyPandas, ArrowPandas\n \n-## DuckDB connection used in this test\n-duckdb_conn = duckdb.connect()\n \n+def create_pyarrow_pandas(rel):\n+    return rel.df().convert_dtypes(dtype_backend='pyarrow')\n \n-def numeric_operators(data_type, tbl_name):\n-    duckdb_conn.execute(\"CREATE TABLE \" + tbl_name + \" (a \" + data_type + \", b \" + data_type + \", c \" + data_type + \")\")\n-    duckdb_conn.execute(\"INSERT INTO  \" + tbl_name + \" VALUES (1,1,1),(10,10,10),(100,10,100),(NULL,NULL,NULL)\")\n-    duck_tbl = duckdb_conn.table(tbl_name)\n-    arrow_table = duck_tbl.arrow()\n-    print(arrow_table)\n \n-    duckdb_conn.register(\"testarrow\", arrow_table)\n+def create_pyarrow_table(rel):\n+    return rel.arrow()\n+\n+\n+def create_pyarrow_dataset(rel):\n+    table = create_pyarrow_table(rel)\n+    return ds.dataset(table)\n+\n+\n+def numeric_operators(connection, data_type, tbl_name, create_table):\n+    connection.execute(\n+        f\"\"\"\n+        CREATE TABLE {tbl_name} (\n+            a {data_type},\n+            b {data_type},\n+            c {data_type}\n+        )\n+    \"\"\"\n+    )\n+    connection.execute(\n+        f\"\"\"\n+        INSERT INTO {tbl_name} VALUES\n+            (1,1,1),\n+            (10,10,10),\n+            (100,10,100),\n+            (NULL,NULL,NULL)\n+    \"\"\"\n+    )\n+    duck_tbl = connection.table(tbl_name)\n+    arrow_table = create_table(duck_tbl)\n+\n     # Try ==\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a =1\").fetchone()[0] == 1\n+    assert connection.execute(\"SELECT count(*) from arrow_table where a = 1\").fetchone()[0] == 1\n     # Try >\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >1\").fetchone()[0] == 2\n+    assert connection.execute(\"SELECT count(*) from arrow_table where a > 1\").fetchone()[0] == 2\n     # Try >=\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >=10\").fetchone()[0] == 2\n+    assert connection.execute(\"SELECT count(*) from arrow_table where a >= 10\").fetchone()[0] == 2\n     # Try <\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <10\").fetchone()[0] == 1\n+    assert connection.execute(\"SELECT count(*) from arrow_table where a < 10\").fetchone()[0] == 1\n     # Try <=\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <=10\").fetchone()[0] == 2\n+    assert connection.execute(\"SELECT count(*) from arrow_table where a <= 10\").fetchone()[0] == 2\n \n     # Try Is Null\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n+    assert connection.execute(\"SELECT count(*) from arrow_table where a IS NULL\").fetchone()[0] == 1\n     # Try Is Not Null\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n+    assert connection.execute(\"SELECT count(*) from arrow_table where a IS NOT NULL\").fetchone()[0] == 3\n \n     # Try And\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a=10 and b =1\").fetchone()[0] == 0\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a =100 and b = 10 and c = 100\").fetchone()[0] == 1\n+    assert connection.execute(\"SELECT count(*) from arrow_table where a = 10 and b = 1\").fetchone()[0] == 0\n+    assert (\n+        connection.execute(\"SELECT count(*) from arrow_table where a = 100 and b = 10 and c = 100\").fetchone()[0] == 1\n+    )\n \n     # Try Or\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a = 100 or b =1\").fetchone()[0] == 2\n-\n-    duckdb_conn.execute(\"EXPLAIN SELECT count(*) from testarrow where a = 100 or b =1\")\n-    print(duckdb_conn.fetchall())\n+    assert connection.execute(\"SELECT count(*) from arrow_table where a = 100 or b = 1\").fetchone()[0] == 2\n \n+    connection.execute(\"EXPLAIN SELECT count(*) from arrow_table where a = 100 or b = 1\")\n+    print(connection.fetchall())\n \n-def numeric_check_or_pushdown(tbl_name):\n-    duck_tbl = duckdb_conn.table(tbl_name)\n-    arrow_table = duck_tbl.arrow()\n \n-    arrow_tbl_name = \"testarrow_\" + tbl_name\n-    duckdb_conn.register(arrow_tbl_name, arrow_table)\n+def numeric_check_or_pushdown(connection, tbl_name, create_table):\n+    duck_tbl = connection.table(tbl_name)\n+    arrow_table = create_table(duck_tbl)\n \n     # Multiple column in the root OR node, don't push down\n-    query_res = duckdb_conn.execute(\n-        \"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a=1 OR b=2 AND (a>3 OR b<5)\"\n+    query_res = connection.execute(\n+        \"\"\"\n+        EXPLAIN SELECT * FROM arrow_table WHERE\n+            a = 1 OR b = 2 AND (a > 3 OR b < 5)\n+    \"\"\"\n     ).fetchall()\n     match = re.search(\".*ARROW_SCAN.*Filters:.*\", query_res[0][1])\n     assert not match\n \n     # Single column in the root OR node\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a=1 OR a=10\").fetchall()\n+    query_res = connection.execute(\n+        \"\"\"\n+        EXPLAIN SELECT * FROM arrow_table WHERE\n+            a = 1 OR a = 10\n+    \"\"\"\n+    ).fetchall()\n     match = re.search(\".*ARROW_SCAN.*Filters: a=1 OR a=10.*|$\", query_res[0][1])\n     assert match\n \n     # Single column + root OR node with AND\n-    query_res = duckdb_conn.execute(\n-        \"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a=1 OR (a>3 AND a<5)\"\n+    query_res = connection.execute(\n+        \"\"\"\n+        EXPLAIN SELECT * FROM arrow_table\n+            WHERE a = 1 OR (a > 3 AND a < 5)\n+    \"\"\"\n     ).fetchall()\n     match = re.search(\".*ARROW_SCAN.*Filters: a=1 OR a>3 AND a<5.*|$\", query_res[0][1])\n     assert match\n \n     # Single column multiple ORs\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a=1 OR a>3 OR a<5\").fetchall()\n+    query_res = connection.execute(\"EXPLAIN SELECT * FROM arrow_table WHERE a=1 OR a>3 OR a<5\").fetchall()\n     match = re.search(\".*ARROW_SCAN.*Filters: a=1 OR a>3 OR a<5.*|$\", query_res[0][1])\n     assert match\n \n     # Testing not equal\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a!=1 OR a>3 OR a<2\").fetchall()\n+    query_res = connection.execute(\"EXPLAIN SELECT * FROM arrow_table WHERE a!=1 OR a>3 OR a<2\").fetchall()\n     match = re.search(\".*ARROW_SCAN.*Filters: a!=1 OR a>3 OR a<2.*|$\", query_res[0][1])\n     assert match\n \n     # Multiple OR filters connected with ANDs\n-    query_res = duckdb_conn.execute(\n-        \"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE (a<2 OR a>3) AND (a=1 OR a=4) AND (b=1 OR b<5)\"\n+    query_res = connection.execute(\n+        \"EXPLAIN SELECT * FROM arrow_table WHERE (a<2 OR a>3) AND (a=1 OR a=4) AND (b=1 OR b<5)\"\n     ).fetchall()\n     match = re.search(\".*ARROW_SCAN.*Filters: a<2 OR a>3 AND a=1|\\n.*OR a=4.*\\n.*b=2 OR b<5.*|$\", query_res[0][1])\n     assert match\n \n \n-def string_check_or_pushdown(tbl_name):\n-    duck_tbl = duckdb_conn.table(tbl_name)\n-    arrow_table = duck_tbl.arrow()\n-\n-    arrow_tbl_name = \"testarrow_varchar\"\n-    duckdb_conn.register(arrow_tbl_name, arrow_table)\n+def string_check_or_pushdown(connection, tbl_name, create_table):\n+    duck_tbl = connection.table(tbl_name)\n+    arrow_table = create_table(duck_tbl)\n \n     # Check string zonemap\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a>='1' OR a<='10'\").fetchall()\n+    query_res = connection.execute(\"EXPLAIN SELECT * FROM arrow_table WHERE a >= '1' OR a <= '10'\").fetchall()\n     match = re.search(\".*ARROW_SCAN.*Filters: a>=1 OR a<=10.*|$\", query_res[0][1])\n     assert match\n \n     # No support for OR with is null\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a IS NULL or a='1'\").fetchall()\n+    query_res = connection.execute(\"EXPLAIN SELECT * FROM arrow_table WHERE a IS NULL or a = '1'\").fetchall()\n     match = re.search(\".*ARROW_SCAN.*Filters:.*\", query_res[0][1])\n     assert not match\n \n     # No support for OR with is not null\n-    query_res = duckdb_conn.execute(\n-        \"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a IS NOT NULL OR a='1'\"\n-    ).fetchall()\n+    query_res = connection.execute(\"EXPLAIN SELECT * FROM arrow_table WHERE a IS NOT NULL OR a = '1'\").fetchall()\n     match = re.search(\".*ARROW_SCAN.*Filters:.*\", query_res[0][1])\n     assert not match\n \n     # OR with the like operator\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a=1 OR a LIKE '10%'\").fetchall()\n+    query_res = connection.execute(\"EXPLAIN SELECT * FROM arrow_table WHERE a = 1 OR a LIKE '10%'\").fetchall()\n     match = re.search(\".*ARROW_SCAN.*Filters:.*\", query_res[0][1])\n     assert not match\n \n \n class TestArrowFilterPushdown(object):\n-    def test_filter_pushdown_numeric(self, duckdb_cursor):\n-        numeric_types = [\n+    @pytest.mark.parametrize(\n+        'data_type',\n+        [\n             'TINYINT',\n             'SMALLINT',\n             'INTEGER',\n@@ -137,265 +167,404 @@ def test_filter_pushdown_numeric(self, duckdb_cursor):\n             'FLOAT',\n             'DOUBLE',\n             'HUGEINT',\n-        ]\n-        for data_type in numeric_types:\n-            tbl_name = \"test_\" + data_type\n-            numeric_operators(data_type, tbl_name)\n-            numeric_check_or_pushdown(tbl_name)\n-\n-    def test_filter_pushdown_decimal(self, duckdb_cursor):\n-        numeric_types = {\n-            'DECIMAL(4,1)': 'test_decimal_4_1',\n-            'DECIMAL(9,1)': 'test_decimal_9_1',\n-            'DECIMAL(18,4)': 'test_decimal_18_4',\n-            'DECIMAL(30,12)': 'test_decimal_30_12',\n-        }\n-        for data_type in numeric_types:\n-            tbl_name = numeric_types[data_type]\n-            numeric_operators(data_type, tbl_name)\n-            numeric_check_or_pushdown(tbl_name)\n-\n-    def test_filter_pushdown_varchar(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_varchar (a  VARCHAR, b VARCHAR, c VARCHAR)\")\n-        duckdb_conn.execute(\n-            \"INSERT INTO  test_varchar VALUES ('1','1','1'),('10','10','10'),('100','10','100'),(NULL,NULL,NULL)\"\n-        )\n-        duck_tbl = duckdb_conn.table(\"test_varchar\")\n-        arrow_table = duck_tbl.arrow()\n-\n-        duckdb_conn.register(\"testarrow\", arrow_table)\n+            'DECIMAL(4,1)',\n+            'DECIMAL(9,1)',\n+            'DECIMAL(18,4)',\n+            'DECIMAL(30,12)',\n+        ],\n+    )\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table])\n+    def test_filter_pushdown_numeric(self, data_type, duckdb_cursor, create_table):\n+        tbl_name = \"tbl\"\n+        numeric_operators(duckdb_cursor, data_type, tbl_name, create_table)\n+        numeric_check_or_pushdown(duckdb_cursor, tbl_name, create_table)\n+\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table])\n+    def test_filter_pushdown_varchar(self, duckdb_cursor, create_table):\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            CREATE TABLE test_varchar (\n+                a VARCHAR,\n+                b VARCHAR,\n+                c VARCHAR\n+            )\n+        \"\"\"\n+        )\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            INSERT INTO test_varchar VALUES\n+                ('1','1','1'),\n+                ('10','10','10'),\n+                ('100','10','100'),\n+                (NULL, NULL, NULL)\n+        \"\"\"\n+        )\n+        duck_tbl = duckdb_cursor.table(\"test_varchar\")\n+        arrow_table = create_table(duck_tbl)\n+\n         # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='1'\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a = '1'\").fetchone()[0] == 1\n         # Try >\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >'1'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a > '1'\").fetchone()[0] == 2\n         # Try >=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >='10'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a >= '10'\").fetchone()[0] == 2\n         # Try <\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <'10'\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a < '10'\").fetchone()[0] == 1\n         # Try <=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <='10'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a <= '10'\").fetchone()[0] == 2\n \n         # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NULL\").fetchone()[0] == 1\n         # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NOT NULL\").fetchone()[0] == 3\n \n         # Try And\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a='10' and b ='1'\").fetchone()[0] == 0\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a = '10' and b = '1'\").fetchone()[0] == 0\n         assert (\n-            duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='100' and b = '10' and c = '100'\").fetchone()[\n-                0\n-            ]\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a = '100' and b = '10' and c = '100'\"\n+            ).fetchone()[0]\n             == 1\n         )\n         # Try Or\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a = '100' or b ='1'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a = '100' or b ='1'\").fetchone()[0] == 2\n \n         # More complex tests for OR pushed down on string\n-        string_check_or_pushdown(\"test_varchar\")\n-\n-    def test_filter_pushdown_bool(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_bool (a  BOOL, b BOOL)\")\n-        duckdb_conn.execute(\"INSERT INTO  test_bool VALUES (TRUE,TRUE),(TRUE,FALSE),(FALSE,TRUE),(NULL,NULL)\")\n-        duck_tbl = duckdb_conn.table(\"test_bool\")\n-        arrow_table = duck_tbl.arrow()\n+        string_check_or_pushdown(duckdb_cursor, \"test_varchar\", create_table)\n+\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table])\n+    def test_filter_pushdown_bool(self, duckdb_cursor, create_table):\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            CREATE TABLE test_bool (\n+                a BOOL,\n+                b BOOL\n+            )\n+        \"\"\"\n+        )\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            INSERT INTO test_bool VALUES\n+                (TRUE,TRUE),\n+                (TRUE,FALSE),\n+                (FALSE,TRUE),\n+                (NULL,NULL)\n+        \"\"\"\n+        )\n+        duck_tbl = duckdb_cursor.table(\"test_bool\")\n+        arrow_table = create_table(duck_tbl)\n \n-        duckdb_conn.register(\"testarrow\", arrow_table)\n         # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a =True\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a = True\").fetchone()[0] == 2\n \n         # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NULL\").fetchone()[0] == 1\n         # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NOT NULL\").fetchone()[0] == 3\n \n         # Try And\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a=True and b =True\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a= True and b = True\").fetchone()[0] == 1\n         # Try Or\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a = True or b =True\").fetchone()[0] == 3\n-\n-    def test_filter_pushdown_time(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_time (a  TIME, b TIME, c TIME)\")\n-        duckdb_conn.execute(\n-            \"INSERT INTO  test_time VALUES ('00:01:00','00:01:00','00:01:00'),('00:10:00','00:10:00','00:10:00'),('01:00:00','00:10:00','01:00:00'),(NULL,NULL,NULL)\"\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a = True or b = True\").fetchone()[0] == 3\n+\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table])\n+    def test_filter_pushdown_time(self, duckdb_cursor, create_table):\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            CREATE TABLE test_time (\n+                a TIME,\n+                b TIME,\n+                c TIME\n+            )\n+        \"\"\"\n+        )\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            INSERT INTO test_time VALUES\n+                ('00:01:00','00:01:00','00:01:00'),\n+                ('00:10:00','00:10:00','00:10:00'),\n+                ('01:00:00','00:10:00','01:00:00'),\n+                (NULL,NULL,NULL)\n+        \"\"\"\n         )\n-        duck_tbl = duckdb_conn.table(\"test_time\")\n-        arrow_table = duck_tbl.arrow()\n+        duck_tbl = duckdb_cursor.table(\"test_time\")\n+        arrow_table = create_table(duck_tbl)\n \n-        duckdb_conn.register(\"testarrow\", arrow_table)\n         # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='00:01:00'\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a ='00:01:00'\").fetchone()[0] == 1\n         # Try >\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >'00:01:00'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a >'00:01:00'\").fetchone()[0] == 2\n         # Try >=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >='00:10:00'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a >='00:10:00'\").fetchone()[0] == 2\n         # Try <\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <'00:10:00'\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a <'00:10:00'\").fetchone()[0] == 1\n         # Try <=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <='00:10:00'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a <='00:10:00'\").fetchone()[0] == 2\n \n         # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NULL\").fetchone()[0] == 1\n         # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NOT NULL\").fetchone()[0] == 3\n \n         # Try And\n         assert (\n-            duckdb_conn.execute(\"SELECT count(*) from testarrow where a='00:10:00' and b ='00:01:00'\").fetchone()[0]\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a='00:10:00' and b ='00:01:00'\").fetchone()[0]\n             == 0\n         )\n         assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a ='01:00:00' and b = '00:10:00' and c = '01:00:00'\"\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a ='01:00:00' and b = '00:10:00' and c = '01:00:00'\"\n             ).fetchone()[0]\n             == 1\n         )\n         # Try Or\n         assert (\n-            duckdb_conn.execute(\"SELECT count(*) from testarrow where a = '01:00:00' or b ='00:01:00'\").fetchone()[0]\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a = '01:00:00' or b ='00:01:00'\").fetchone()[\n+                0\n+            ]\n             == 2\n         )\n \n-    def test_filter_pushdown_timestamp(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_timestamp (a  TIMESTAMP, b TIMESTAMP, c TIMESTAMP)\")\n-        duckdb_conn.execute(\n-            \"INSERT INTO  test_timestamp VALUES ('2008-01-01 00:00:01','2008-01-01 00:00:01','2008-01-01 00:00:01'),('2010-01-01 10:00:01','2010-01-01 10:00:01','2010-01-01 10:00:01'),('2020-03-01 10:00:01','2010-01-01 10:00:01','2020-03-01 10:00:01'),(NULL,NULL,NULL)\"\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table])\n+    def test_filter_pushdown_timestamp(self, duckdb_cursor, create_table):\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            CREATE TABLE test_timestamp (\n+                a TIMESTAMP,\n+                b TIMESTAMP,\n+                c TIMESTAMP\n+            )\n+        \"\"\"\n         )\n-        duck_tbl = duckdb_conn.table(\"test_timestamp\")\n-        arrow_table = duck_tbl.arrow()\n-        print(arrow_table)\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            INSERT INTO test_timestamp VALUES\n+                ('2008-01-01 00:00:01','2008-01-01 00:00:01','2008-01-01 00:00:01'),\n+                ('2010-01-01 10:00:01','2010-01-01 10:00:01','2010-01-01 10:00:01'),\n+                ('2020-03-01 10:00:01','2010-01-01 10:00:01','2020-03-01 10:00:01'),\n+                (NULL,NULL,NULL)\n+        \"\"\"\n+        )\n+        duck_tbl = duckdb_cursor.table(\"test_timestamp\")\n+        arrow_table = create_table(duck_tbl)\n \n-        duckdb_conn.register(\"testarrow\", arrow_table)\n         # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='2008-01-01 00:00:01'\").fetchone()[0] == 1\n+        assert (\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a ='2008-01-01 00:00:01'\").fetchone()[0] == 1\n+        )\n         # Try >\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >'2008-01-01 00:00:01'\").fetchone()[0] == 2\n+        assert (\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a >'2008-01-01 00:00:01'\").fetchone()[0] == 2\n+        )\n         # Try >=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >='2010-01-01 10:00:01'\").fetchone()[0] == 2\n+        assert (\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a >='2010-01-01 10:00:01'\").fetchone()[0] == 2\n+        )\n         # Try <\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <'2010-01-01 10:00:01'\").fetchone()[0] == 1\n+        assert (\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a <'2010-01-01 10:00:01'\").fetchone()[0] == 1\n+        )\n         # Try <=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <='2010-01-01 10:00:01'\").fetchone()[0] == 2\n+        assert (\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a <='2010-01-01 10:00:01'\").fetchone()[0] == 2\n+        )\n \n         # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NULL\").fetchone()[0] == 1\n         # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NOT NULL\").fetchone()[0] == 3\n \n         # Try And\n         assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a='2010-01-01 10:00:01' and b ='2008-01-01 00:00:01'\"\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a='2010-01-01 10:00:01' and b ='2008-01-01 00:00:01'\"\n             ).fetchone()[0]\n             == 0\n         )\n         assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a ='2020-03-01 10:00:01' and b = '2010-01-01 10:00:01' and c = '2020-03-01 10:00:01'\"\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a ='2020-03-01 10:00:01' and b = '2010-01-01 10:00:01' and c = '2020-03-01 10:00:01'\"\n             ).fetchone()[0]\n             == 1\n         )\n         # Try Or\n         assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a = '2020-03-01 10:00:01' or b ='2008-01-01 00:00:01'\"\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a = '2020-03-01 10:00:01' or b ='2008-01-01 00:00:01'\"\n             ).fetchone()[0]\n             == 2\n         )\n \n-    def test_filter_pushdown_timestamp_TZ(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_timestamptz (a  TIMESTAMPTZ, b TIMESTAMPTZ, c TIMESTAMPTZ)\")\n-        duckdb_conn.execute(\n-            \"INSERT INTO  test_timestamptz VALUES ('2008-01-01 00:00:01','2008-01-01 00:00:01','2008-01-01 00:00:01'),('2010-01-01 10:00:01','2010-01-01 10:00:01','2010-01-01 10:00:01'),('2020-03-01 10:00:01','2010-01-01 10:00:01','2020-03-01 10:00:01'),(NULL,NULL,NULL)\"\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table])\n+    def test_filter_pushdown_timestamp_TZ(self, duckdb_cursor, create_table):\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            CREATE TABLE test_timestamptz (\n+                a TIMESTAMPTZ,\n+                b TIMESTAMPTZ,\n+                c TIMESTAMPTZ\n+            )\n+        \"\"\"\n+        )\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            INSERT INTO test_timestamptz VALUES\n+                ('2008-01-01 00:00:01','2008-01-01 00:00:01','2008-01-01 00:00:01'),\n+                ('2010-01-01 10:00:01','2010-01-01 10:00:01','2010-01-01 10:00:01'),\n+                ('2020-03-01 10:00:01','2010-01-01 10:00:01','2020-03-01 10:00:01'),\n+                (NULL,NULL,NULL)\n+            \"\"\"\n         )\n-        duck_tbl = duckdb_conn.table(\"test_timestamptz\")\n-        arrow_table = duck_tbl.arrow()\n-        print(arrow_table)\n+        duck_tbl = duckdb_cursor.table(\"test_timestamptz\")\n+        arrow_table = create_table(duck_tbl)\n \n-        duckdb_conn.register(\"testarrow\", arrow_table)\n         # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='2008-01-01 00:00:01'\").fetchone()[0] == 1\n+        assert (\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a = '2008-01-01 00:00:01'\").fetchone()[0] == 1\n+        )\n         # Try >\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >'2008-01-01 00:00:01'\").fetchone()[0] == 2\n+        assert (\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a > '2008-01-01 00:00:01'\").fetchone()[0] == 2\n+        )\n         # Try >=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >='2010-01-01 10:00:01'\").fetchone()[0] == 2\n+        assert (\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a >= '2010-01-01 10:00:01'\").fetchone()[0]\n+            == 2\n+        )\n         # Try <\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <'2010-01-01 10:00:01'\").fetchone()[0] == 1\n+        assert (\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a < '2010-01-01 10:00:01'\").fetchone()[0] == 1\n+        )\n         # Try <=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <='2010-01-01 10:00:01'\").fetchone()[0] == 2\n+        assert (\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a <= '2010-01-01 10:00:01'\").fetchone()[0]\n+            == 2\n+        )\n \n         # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NULL\").fetchone()[0] == 1\n         # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NOT NULL\").fetchone()[0] == 3\n \n         # Try And\n         assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a='2010-01-01 10:00:01' and b ='2008-01-01 00:00:01'\"\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a = '2010-01-01 10:00:01' and b = '2008-01-01 00:00:01'\"\n             ).fetchone()[0]\n             == 0\n         )\n         assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a ='2020-03-01 10:00:01' and b = '2010-01-01 10:00:01' and c = '2020-03-01 10:00:01'\"\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a = '2020-03-01 10:00:01' and b = '2010-01-01 10:00:01' and c = '2020-03-01 10:00:01'\"\n             ).fetchone()[0]\n             == 1\n         )\n         # Try Or\n         assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a = '2020-03-01 10:00:01' or b ='2008-01-01 00:00:01'\"\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a = '2020-03-01 10:00:01' or b ='2008-01-01 00:00:01'\"\n             ).fetchone()[0]\n             == 2\n         )\n \n-    def test_filter_pushdown_date(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_date (a  DATE, b DATE, c DATE)\")\n-        duckdb_conn.execute(\n-            \"INSERT INTO  test_date VALUES ('2000-01-01','2000-01-01','2000-01-01'),('2000-10-01','2000-10-01','2000-10-01'),('2010-01-01','2000-10-01','2010-01-01'),(NULL,NULL,NULL)\"\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table])\n+    @pytest.mark.parametrize(\n+        ['data_type', 'value'],\n+        [\n+            ['TINYINT', 127],\n+            ['SMALLINT', 32767],\n+            ['INTEGER', 2147483647],\n+            ['BIGINT', 9223372036854775807],\n+            ['UTINYINT', 255],\n+            ['USMALLINT', 65535],\n+            ['UINTEGER', 4294967295],\n+            ['UBIGINT', 18446744073709551615],\n+        ],\n+    )\n+    def test_filter_pushdown_integers(self, duckdb_cursor, data_type, value, create_table):\n+        duckdb_cursor.execute(\n+            f\"\"\"\n+            CREATE TABLE tbl as select {value}::{data_type} as i\n+        \"\"\"\n+        )\n+        expected = duckdb_cursor.table('tbl').fetchall()\n+        filter = \"i > 0\"\n+        rel = duckdb_cursor.table('tbl')\n+        arrow_table = create_table(rel)\n+        actual = duckdb_cursor.sql(f\"select * from arrow_table where {filter}\").fetchall()\n+        assert expected == actual\n+\n+        # Test with equivalent prepared statement\n+        actual = duckdb_cursor.execute(\"select * from arrow_table where i > ?\", (0,)).fetchall()\n+        assert expected == actual\n+        # Test equality\n+        actual = duckdb_cursor.execute(\"select * from arrow_table where i = ?\", (value,)).fetchall()\n+        assert expected == actual\n+\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table])\n+    def test_filter_pushdown_date(self, duckdb_cursor, create_table):\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            CREATE TABLE test_date (\n+                a DATE,\n+                b DATE,\n+                c DATE\n+            )\n+        \"\"\"\n+        )\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            INSERT INTO test_date VALUES\n+                ('2000-01-01','2000-01-01','2000-01-01'),\n+                ('2000-10-01','2000-10-01','2000-10-01'),\n+                ('2010-01-01','2000-10-01','2010-01-01'),\n+                (NULL,NULL,NULL)\n+        \"\"\"\n         )\n-        duck_tbl = duckdb_conn.table(\"test_date\")\n-        arrow_table = duck_tbl.arrow()\n+        duck_tbl = duckdb_cursor.table(\"test_date\")\n+        arrow_table = create_table(duck_tbl)\n \n-        duckdb_conn.register(\"testarrow\", arrow_table)\n         # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='2000-01-01'\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a = '2000-01-01'\").fetchone()[0] == 1\n         # Try >\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >'2000-01-01'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a > '2000-01-01'\").fetchone()[0] == 2\n         # Try >=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >='2000-10-01'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a >= '2000-10-01'\").fetchone()[0] == 2\n         # Try <\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <'2000-10-01'\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a < '2000-10-01'\").fetchone()[0] == 1\n         # Try <=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <='2000-10-01'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a <= '2000-10-01'\").fetchone()[0] == 2\n \n         # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NULL\").fetchone()[0] == 1\n         # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NOT NULL\").fetchone()[0] == 3\n \n         # Try And\n         assert (\n-            duckdb_conn.execute(\"SELECT count(*) from testarrow where a='2000-10-01' and b ='2000-01-01'\").fetchone()[0]\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a = '2000-10-01' and b = '2000-01-01'\"\n+            ).fetchone()[0]\n             == 0\n         )\n         assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a ='2010-01-01' and b = '2000-10-01' and c = '2010-01-01'\"\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a = '2010-01-01' and b = '2000-10-01' and c = '2010-01-01'\"\n             ).fetchone()[0]\n             == 1\n         )\n         # Try Or\n         assert (\n-            duckdb_conn.execute(\"SELECT count(*) from testarrow where a = '2010-01-01' or b ='2000-01-01'\").fetchone()[\n-                0\n-            ]\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a = '2010-01-01' or b = '2000-01-01'\"\n+            ).fetchone()[0]\n             == 2\n         )\n \n-    @pytest.mark.parametrize('pandas', [NumpyPandas(), ArrowPandas()])\n-    def test_filter_pushdown_blob(self, pandas):\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table])\n+    def test_filter_pushdown_blob(self, duckdb_cursor, create_table):\n+        import pandas\n+\n         df = pandas.DataFrame(\n             {\n                 'a': [bytes([1]), bytes([2]), bytes([3]), None],\n@@ -403,48 +572,67 @@ def test_filter_pushdown_blob(self, pandas):\n                 'c': [bytes([1]), bytes([2]), bytes([3]), None],\n             }\n         )\n-        arrow_table = pa.Table.from_pandas(df)\n+        rel = duckdb.from_df(df)\n+        arrow_table = create_table(rel)\n \n         # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from arrow_table where a ='\\x01'\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a = '\\x01'\").fetchone()[0] == 1\n         # # Try >\n-        assert duckdb_conn.execute(\"SELECT count(*) from arrow_table where a >'\\x01'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a > '\\x01'\").fetchone()[0] == 2\n         # Try >=\n-        assert duckdb_conn.execute(\"SELECT count(*) from arrow_table where a >='\\x02'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a >= '\\x02'\").fetchone()[0] == 2\n         # Try <\n-        assert duckdb_conn.execute(\"SELECT count(*) from arrow_table where a <'\\x02'\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a < '\\x02'\").fetchone()[0] == 1\n         # Try <=\n-        assert duckdb_conn.execute(\"SELECT count(*) from arrow_table where a <='\\x02'\").fetchone()[0] == 2\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a <= '\\x02'\").fetchone()[0] == 2\n \n         # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from arrow_table where a IS NULL\").fetchone()[0] == 1\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NULL\").fetchone()[0] == 1\n         # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from arrow_table where a IS NOT NULL\").fetchone()[0] == 3\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a IS NOT NULL\").fetchone()[0] == 3\n \n         # Try And\n-        assert duckdb_conn.execute(\"SELECT count(*) from arrow_table where a='\\x02' and b ='\\x01'\").fetchone()[0] == 0\n+        assert duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a='\\x02' and b ='\\x01'\").fetchone()[0] == 0\n         assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from arrow_table where a ='\\x02' and b = '\\x02' and c = '\\x02'\"\n+            duckdb_cursor.execute(\n+                \"SELECT count(*) from arrow_table where a = '\\x02' and b = '\\x02' and c = '\\x02'\"\n             ).fetchone()[0]\n             == 1\n         )\n         # Try Or\n-        assert duckdb_conn.execute(\"SELECT count(*) from arrow_table where a = '\\x01' or b ='\\x02'\").fetchone()[0] == 2\n-\n-    def test_filter_pushdown_no_projection(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_int (a  INTEGER, b INTEGER, c INTEGER)\")\n-        duckdb_conn.execute(\"INSERT INTO  test_int VALUES (1,1,1),(10,10,10),(100,10,100),(NULL,NULL,NULL)\")\n-        duck_tbl = duckdb_conn.table(\"test_int\")\n-        arrow_table = duck_tbl.arrow()\n-        duckdb_conn.register(\"testarrowtable\", arrow_table)\n-        assert duckdb_conn.execute(\"SELECT * FROM  testarrowtable VALUES where a =1\").fetchall() == [(1, 1, 1)]\n-        arrow_dataset = ds.dataset(arrow_table)\n-        duckdb_conn.register(\"testarrowdataset\", arrow_dataset)\n-        assert duckdb_conn.execute(\"SELECT * FROM  testarrowdataset VALUES where a =1\").fetchall() == [(1, 1, 1)]\n-\n-    @pytest.mark.parametrize('pandas', [NumpyPandas(), ArrowPandas()])\n-    def test_filter_pushdown_2145(self, duckdb_cursor, pandas):\n+        assert (\n+            duckdb_cursor.execute(\"SELECT count(*) from arrow_table where a = '\\x01' or b = '\\x02'\").fetchone()[0] == 2\n+        )\n+\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table, create_pyarrow_dataset])\n+    def test_filter_pushdown_no_projection(self, duckdb_cursor, create_table):\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            CREATE TABLE test_int (\n+                a INTEGER,\n+                b INTEGER,\n+                c INTEGER\n+            )\n+        \"\"\"\n+        )\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            INSERT INTO test_int VALUES\n+                (1,1,1),\n+                (10,10,10),\n+                (100,10,100),\n+                (NULL,NULL,NULL)\n+        \"\"\"\n+        )\n+        duck_tbl = duckdb_cursor.table(\"test_int\")\n+        arrow_table = create_table(duck_tbl)\n+\n+        assert duckdb_cursor.execute(\"SELECT * FROM arrow_table VALUES where a = 1\").fetchall() == [(1, 1, 1)]\n+\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table])\n+    def test_filter_pushdown_2145(self, duckdb_cursor, tmp_path, create_table):\n+        import pandas\n+\n         date1 = pandas.date_range(\"2018-01-01\", \"2018-12-31\", freq=\"B\")\n         df1 = pandas.DataFrame(np.random.randn(date1.shape[0], 5), columns=list(\"ABCDE\"))\n         df1[\"date\"] = date1\n@@ -453,28 +641,39 @@ def test_filter_pushdown_2145(self, duckdb_cursor, pandas):\n         df2 = pandas.DataFrame(np.random.randn(date2.shape[0], 5), columns=list(\"ABCDE\"))\n         df2[\"date\"] = date2\n \n-        con = duckdb.connect()\n-        con.execute(\"copy (select * from df1) to 'data1.parquet'\")\n-        con.execute(\"copy (select * from df2) to 'data2.parquet'\")\n-\n-        table = pq.ParquetDataset([\"data1.parquet\", \"data2.parquet\"]).read()\n+        data1 = tmp_path / 'data1.parquet'\n+        data2 = tmp_path / 'data2.parquet'\n+        duckdb_cursor.execute(f\"copy (select * from df1) to '{data1.as_posix()}'\")\n+        duckdb_cursor.execute(f\"copy (select * from df2) to '{data2.as_posix()}'\")\n \n-        con.register(\"testarrow\", table)\n+        glob_pattern = tmp_path / 'data*.parquet'\n+        table = duckdb_cursor.read_parquet(glob_pattern.as_posix()).arrow()\n \n         output_df = duckdb.arrow(table).filter(\"date > '2019-01-01'\").df()\n-        expected_df = duckdb.from_parquet(\"data*.parquet\").filter(\"date > '2019-01-01'\").df()\n+        expected_df = duckdb.from_parquet(glob_pattern.as_posix()).filter(\"date > '2019-01-01'\").df()\n         pandas.testing.assert_frame_equal(expected_df, output_df)\n \n-        os.remove(\"data1.parquet\")\n-        os.remove(\"data2.parquet\")\n-\n-    def test_filter_column_removal(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test AS SELECT range i, range j FROM range(5)\")\n-        duck_test_table = duckdb_conn.table(\"test\")\n-        arrow_test_table = duck_test_table.arrow()\n-        duckdb_conn.register(\"arrow_test_table\", arrow_test_table)\n+    # https://github.com/duckdb/duckdb/pull/4817/files#r1339973721\n+    @pytest.mark.parametrize('create_table', [create_pyarrow_pandas, create_pyarrow_table])\n+    @pytest.mark.skip(reason=\"This test is likely not testing what it's supposed to\")\n+    def test_filter_column_removal(self, duckdb_cursor, create_table):\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            CREATE TABLE test AS SELECT\n+                range i,\n+                range j\n+            FROM range(5)\n+        \"\"\"\n+        )\n+        duck_test_table = duckdb_cursor.table(\"test\")\n+        arrow_test_table = create_table(duck_test_table)\n \n         # PR 4817 - remove filter columns that are unused in the remainder of the query plan from the table function\n-        query_res = duckdb_conn.execute(\"EXPLAIN SELECT count(*) from testarrow where a = 100 or b =1\").fetchall()\n+        query_res = duckdb_cursor.execute(\n+            \"\"\"\n+            EXPLAIN SELECT count(*) from testarrow where\n+                a = 100 or b = 1\n+        \"\"\"\n+        ).fetchall()\n         match = re.search(\"\u2502 +j +\u2502\", query_res[0][1])\n         assert not match\ndiff --git a/tools/pythonpkg/tests/fast/pandas/test_pyarrow_filter_pushdown.py b/tools/pythonpkg/tests/fast/pandas/test_pyarrow_filter_pushdown.py\ndeleted file mode 100644\nindex 96fce728123a..000000000000\n--- a/tools/pythonpkg/tests/fast/pandas/test_pyarrow_filter_pushdown.py\n+++ /dev/null\n@@ -1,462 +0,0 @@\n-import duckdb\n-import os\n-import pytest\n-import tempfile\n-\n-from conftest import pandas_supports_arrow_backend\n-\n-pa = pytest.importorskip(\"pyarrow\")\n-pq = pytest.importorskip(\"pyarrow.parquet\")\n-ds = pytest.importorskip(\"pyarrow.dataset\")\n-np = pytest.importorskip(\"numpy\")\n-re = pytest.importorskip(\"re\")\n-_ = pytest.importorskip(\"pandas\", '2.0.0')\n-from conftest import ArrowPandas\n-\n-## DuckDB connection used in this test\n-duckdb_conn = duckdb.connect()\n-\n-\n-def numeric_operators(data_type, tbl_name):\n-    duckdb_conn.execute(f\"CREATE TABLE {tbl_name} (a {data_type}, b {data_type}, c {data_type})\")\n-    duckdb_conn.execute(\"INSERT INTO  \" + tbl_name + \" VALUES (1,1,1),(10,10,10),(100,10,100),(NULL,NULL,NULL)\")\n-    duck_tbl = duckdb_conn.table(tbl_name)\n-    arrow_df = duck_tbl.df().convert_dtypes(dtype_backend='pyarrow')\n-    print(arrow_df)\n-\n-    duckdb_conn.register(\"testarrow\", arrow_df)\n-    # Try ==\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a =1\").fetchone()[0] == 1\n-    # Try >\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >1\").fetchone()[0] == 2\n-    # Try >=\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >=10\").fetchone()[0] == 2\n-    # Try <\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <10\").fetchone()[0] == 1\n-    # Try <=\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <=10\").fetchone()[0] == 2\n-\n-    # Try Is Null\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n-    # Try Is Not Null\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n-\n-    # Try And\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a=10 and b =1\").fetchone()[0] == 0\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a =100 and b = 10 and c = 100\").fetchone()[0] == 1\n-\n-    # Try Or\n-    assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a = 100 or b =1\").fetchone()[0] == 2\n-\n-    duckdb_conn.execute(\"EXPLAIN SELECT count(*) from testarrow where a = 100 or b =1\")\n-    print(duckdb_conn.fetchall())\n-\n-\n-def numeric_check_or_pushdown(tbl_name):\n-    duck_tbl = duckdb_conn.table(tbl_name)\n-    arrow_df = duck_tbl.df().convert_dtypes(dtype_backend='pyarrow')\n-\n-    arrow_tbl_name = \"testarrow_\" + tbl_name\n-    duckdb_conn.register(arrow_tbl_name, arrow_df)\n-\n-    # Multiple column in the root OR node, don't push down\n-    query_res = duckdb_conn.execute(\n-        \"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a=1 OR b=2 AND (a>3 OR b<5)\"\n-    ).fetchall()\n-    match = re.search(\".*ARROW_SCAN.*Filters:.*\", query_res[0][1])\n-    assert not match\n-\n-    # Single column in the root OR node\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a=1 OR a=10\").fetchall()\n-    match = re.search(\".*ARROW_SCAN.*Filters: a=1 OR a=10.*|$\", query_res[0][1])\n-    assert match\n-\n-    # Single column + root OR node with AND\n-    query_res = duckdb_conn.execute(\n-        \"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a=1 OR (a>3 AND a<5)\"\n-    ).fetchall()\n-    match = re.search(\".*ARROW_SCAN.*Filters: a=1 OR a>3 AND a<5.*|$\", query_res[0][1])\n-    assert match\n-\n-    # Single column multiple ORs\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a=1 OR a>3 OR a<5\").fetchall()\n-    match = re.search(\".*ARROW_SCAN.*Filters: a=1 OR a>3 OR a<5.*|$\", query_res[0][1])\n-    assert match\n-\n-    # Testing not equal\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a!=1 OR a>3 OR a<2\").fetchall()\n-    match = re.search(\".*ARROW_SCAN.*Filters: a!=1 OR a>3 OR a<2.*|$\", query_res[0][1])\n-    assert match\n-\n-    # Multiple OR filters connected with ANDs\n-    query_res = duckdb_conn.execute(\n-        \"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE (a<2 OR a>3) AND (a=1 OR a=4) AND (b=1 OR b<5)\"\n-    ).fetchall()\n-    match = re.search(\".*ARROW_SCAN.*Filters: a<2 OR a>3 AND a=1|\\n.*OR a=4.*\\n.*b=2 OR b<5.*|$\", query_res[0][1])\n-    assert match\n-\n-\n-def string_check_or_pushdown(tbl_name):\n-    duck_tbl = duckdb_conn.table(tbl_name)\n-    arrow_df = duck_tbl.df().convert_dtypes(dtype_backend='pyarrow')\n-\n-    arrow_tbl_name = \"testarrow_varchar\"\n-    duckdb_conn.register(arrow_tbl_name, arrow_df)\n-\n-    # Check string zonemap\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a>='1' OR a<='10'\").fetchall()\n-    match = re.search(\".*ARROW_SCAN.*Filters: a>=1 OR a<=10.*|$\", query_res[0][1])\n-    assert match\n-\n-    # No support for OR with is null\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a IS NULL or a='1'\").fetchall()\n-    match = re.search(\".*ARROW_SCAN.*Filters:.*\", query_res[0][1])\n-    assert not match\n-\n-    # No support for OR with is not null\n-    query_res = duckdb_conn.execute(\n-        \"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a IS NOT NULL OR a='1'\"\n-    ).fetchall()\n-    match = re.search(\".*ARROW_SCAN.*Filters:.*\", query_res[0][1])\n-    assert not match\n-\n-    # OR with the like operator\n-    query_res = duckdb_conn.execute(\"EXPLAIN SELECT * FROM \" + arrow_tbl_name + \" WHERE a=1 OR a LIKE '10%'\").fetchall()\n-    match = re.search(\".*ARROW_SCAN.*Filters:.*\", query_res[0][1])\n-    assert not match\n-\n-\n-@pytest.mark.skipif(not pandas_supports_arrow_backend(), reason=\"pandas does not support the 'pyarrow' backend\")\n-class TestArrowDFFilterPushdown(object):\n-    def test_filter_pushdown_numeric(self, duckdb_cursor):\n-        numeric_types = [\n-            'TINYINT',\n-            'SMALLINT',\n-            'INTEGER',\n-            'BIGINT',\n-            'UTINYINT',\n-            'USMALLINT',\n-            'UINTEGER',\n-            'UBIGINT',\n-            'FLOAT',\n-            'DOUBLE',\n-            'HUGEINT',\n-        ]\n-        for data_type in numeric_types:\n-            tbl_name = \"test_\" + data_type\n-            numeric_operators(data_type, tbl_name)\n-            numeric_check_or_pushdown(tbl_name)\n-\n-    def test_filter_pushdown_decimal(self, duckdb_cursor):\n-        numeric_types = {\n-            'DECIMAL(4,1)': 'test_decimal_4_1',\n-            'DECIMAL(9,1)': 'test_decimal_9_1',\n-            'DECIMAL(18,4)': 'test_decimal_18_4',\n-            'DECIMAL(30,12)': 'test_decimal_30_12',\n-        }\n-        for data_type in numeric_types:\n-            tbl_name = numeric_types[data_type]\n-            numeric_operators(data_type, tbl_name)\n-            numeric_check_or_pushdown(tbl_name)\n-\n-    def test_filter_pushdown_varchar(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_varchar (a  VARCHAR, b VARCHAR, c VARCHAR)\")\n-        duckdb_conn.execute(\n-            \"INSERT INTO  test_varchar VALUES ('1','1','1'),('10','10','10'),('100','10','100'),(NULL,NULL,NULL)\"\n-        )\n-        duck_tbl = duckdb_conn.table(\"test_varchar\")\n-        arrow_table = duck_tbl.df().convert_dtypes(dtype_backend='pyarrow')\n-\n-        duckdb_conn.register(\"testarrow\", arrow_table)\n-        # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='1'\").fetchone()[0] == 1\n-        # Try >\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >'1'\").fetchone()[0] == 2\n-        # Try >=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >='10'\").fetchone()[0] == 2\n-        # Try <\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <'10'\").fetchone()[0] == 1\n-        # Try <=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <='10'\").fetchone()[0] == 2\n-\n-        # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n-        # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n-\n-        # Try And\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a='10' and b ='1'\").fetchone()[0] == 0\n-        assert (\n-            duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='100' and b = '10' and c = '100'\").fetchone()[\n-                0\n-            ]\n-            == 1\n-        )\n-        # Try Or\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a = '100' or b ='1'\").fetchone()[0] == 2\n-\n-        # More complex tests for OR pushed down on string\n-        string_check_or_pushdown(\"test_varchar\")\n-\n-    def test_filter_pushdown_bool(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_bool (a  BOOL, b BOOL)\")\n-        duckdb_conn.execute(\"INSERT INTO  test_bool VALUES (TRUE,TRUE),(TRUE,FALSE),(FALSE,TRUE),(NULL,NULL)\")\n-        duck_tbl = duckdb_conn.table(\"test_bool\")\n-        arrow_table = duck_tbl.df().convert_dtypes(dtype_backend='pyarrow')\n-\n-        duckdb_conn.register(\"testarrow\", arrow_table)\n-        # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a =True\").fetchone()[0] == 2\n-\n-        # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n-        # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n-\n-        # Try And\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a=True and b =True\").fetchone()[0] == 1\n-        # Try Or\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a = True or b =True\").fetchone()[0] == 3\n-\n-    def test_filter_pushdown_time(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_time (a  TIME, b TIME, c TIME)\")\n-        duckdb_conn.execute(\n-            \"INSERT INTO  test_time VALUES ('00:01:00','00:01:00','00:01:00'),('00:10:00','00:10:00','00:10:00'),('01:00:00','00:10:00','01:00:00'),(NULL,NULL,NULL)\"\n-        )\n-        duck_tbl = duckdb_conn.table(\"test_time\")\n-        arrow_table = duck_tbl.df().convert_dtypes(dtype_backend='pyarrow')\n-\n-        duckdb_conn.register(\"testarrow\", arrow_table)\n-        # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='00:01:00'\").fetchone()[0] == 1\n-        # Try >\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >'00:01:00'\").fetchone()[0] == 2\n-        # Try >=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >='00:10:00'\").fetchone()[0] == 2\n-        # Try <\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <'00:10:00'\").fetchone()[0] == 1\n-        # Try <=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <='00:10:00'\").fetchone()[0] == 2\n-\n-        # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n-        # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n-\n-        # Try And\n-        assert (\n-            duckdb_conn.execute(\"SELECT count(*) from testarrow where a='00:10:00' and b ='00:01:00'\").fetchone()[0]\n-            == 0\n-        )\n-        assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a ='01:00:00' and b = '00:10:00' and c = '01:00:00'\"\n-            ).fetchone()[0]\n-            == 1\n-        )\n-        # Try Or\n-        assert (\n-            duckdb_conn.execute(\"SELECT count(*) from testarrow where a = '01:00:00' or b ='00:01:00'\").fetchone()[0]\n-            == 2\n-        )\n-\n-    def test_filter_pushdown_timestamp(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_timestamp (a  TIMESTAMP, b TIMESTAMP, c TIMESTAMP)\")\n-        duckdb_conn.execute(\n-            \"INSERT INTO  test_timestamp VALUES ('2008-01-01 00:00:01','2008-01-01 00:00:01','2008-01-01 00:00:01'),('2010-01-01 10:00:01','2010-01-01 10:00:01','2010-01-01 10:00:01'),('2020-03-01 10:00:01','2010-01-01 10:00:01','2020-03-01 10:00:01'),(NULL,NULL,NULL)\"\n-        )\n-        duck_tbl = duckdb_conn.table(\"test_timestamp\")\n-        arrow_table = duck_tbl.df().convert_dtypes(dtype_backend='pyarrow')\n-        print(arrow_table)\n-\n-        duckdb_conn.register(\"testarrow\", arrow_table)\n-        # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='2008-01-01 00:00:01'\").fetchone()[0] == 1\n-        # Try >\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >'2008-01-01 00:00:01'\").fetchone()[0] == 2\n-        # Try >=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >='2010-01-01 10:00:01'\").fetchone()[0] == 2\n-        # Try <\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <'2010-01-01 10:00:01'\").fetchone()[0] == 1\n-        # Try <=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <='2010-01-01 10:00:01'\").fetchone()[0] == 2\n-\n-        # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n-        # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n-\n-        # Try And\n-        assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a='2010-01-01 10:00:01' and b ='2008-01-01 00:00:01'\"\n-            ).fetchone()[0]\n-            == 0\n-        )\n-        assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a ='2020-03-01 10:00:01' and b = '2010-01-01 10:00:01' and c = '2020-03-01 10:00:01'\"\n-            ).fetchone()[0]\n-            == 1\n-        )\n-        # Try Or\n-        assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a = '2020-03-01 10:00:01' or b ='2008-01-01 00:00:01'\"\n-            ).fetchone()[0]\n-            == 2\n-        )\n-\n-    def test_filter_pushdown_timestamp_TZ(self, duckdb_cursor):\n-        duckdb_conn.execute(\n-            \"\"\"\n-            CREATE TABLE test_timestamptz (\n-                a TIMESTAMPTZ,\n-                b TIMESTAMPTZ,\n-                c TIMESTAMPTZ\n-            )\n-        \"\"\"\n-        )\n-        duckdb_conn.execute(\n-            \"\"\"\n-            INSERT INTO test_timestamptz VALUES\n-                ('2008-01-01 00:00:01','2008-01-01 00:00:01','2008-01-01 00:00:01'),\n-                ('2010-01-01 10:00:01','2010-01-01 10:00:01','2010-01-01 10:00:01'),\n-                ('2020-03-01 10:00:01','2010-01-01 10:00:01','2020-03-01 10:00:01'),\n-                (NULL,NULL,NULL)\n-        \"\"\"\n-        )\n-        # Have to fetch as naive here, or the times will be converted into UTC and our predicates dont match\n-        duck_tbl = duckdb_conn.sql(\n-            \"\"\"\n-            select a::TIMESTAMP a, b::TIMESTAMP b, c::TIMESTAMP c from test_timestamptz\n-        \"\"\"\n-        )\n-        arrow_table = duck_tbl.df().convert_dtypes(dtype_backend='pyarrow')\n-        print(arrow_table)\n-\n-        duckdb_conn.register(\"testarrow\", arrow_table)\n-        # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='2008-01-01 00:00:01'\").fetchone()[0] == 1\n-        # Try >\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >'2008-01-01 00:00:01'\").fetchone()[0] == 2\n-        # Try >=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >='2010-01-01 10:00:01'\").fetchone()[0] == 2\n-        # Try <\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <'2010-01-01 10:00:01'\").fetchone()[0] == 1\n-        # Try <=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <='2010-01-01 10:00:01'\").fetchone()[0] == 2\n-\n-        # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n-        # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n-\n-        # Try And\n-        assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a='2010-01-01 10:00:01' and b ='2008-01-01 00:00:01'\"\n-            ).fetchone()[0]\n-            == 0\n-        )\n-        assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a ='2020-03-01 10:00:01' and b = '2010-01-01 10:00:01' and c = '2020-03-01 10:00:01'\"\n-            ).fetchone()[0]\n-            == 1\n-        )\n-        # Try Or\n-        assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a = '2020-03-01 10:00:01' or b ='2008-01-01 00:00:01'\"\n-            ).fetchone()[0]\n-            == 2\n-        )\n-\n-    def test_filter_pushdown_date(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_date (a  DATE, b DATE, c DATE)\")\n-        duckdb_conn.execute(\n-            \"INSERT INTO  test_date VALUES ('2000-01-01','2000-01-01','2000-01-01'),('2000-10-01','2000-10-01','2000-10-01'),('2010-01-01','2000-10-01','2010-01-01'),(NULL,NULL,NULL)\"\n-        )\n-        duck_tbl = duckdb_conn.table(\"test_date\")\n-        arrow_table = duck_tbl.df().convert_dtypes(dtype_backend='pyarrow')\n-\n-        duckdb_conn.register(\"testarrow\", arrow_table)\n-        # Try ==\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a ='2000-01-01'\").fetchone()[0] == 1\n-        # Try >\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >'2000-01-01'\").fetchone()[0] == 2\n-        # Try >=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a >='2000-10-01'\").fetchone()[0] == 2\n-        # Try <\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <'2000-10-01'\").fetchone()[0] == 1\n-        # Try <=\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a <='2000-10-01'\").fetchone()[0] == 2\n-\n-        # Try Is Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NULL\").fetchone()[0] == 1\n-        # Try Is Not Null\n-        assert duckdb_conn.execute(\"SELECT count(*) from testarrow where a IS NOT NULL\").fetchone()[0] == 3\n-\n-        # Try And\n-        assert (\n-            duckdb_conn.execute(\"SELECT count(*) from testarrow where a='2000-10-01' and b ='2000-01-01'\").fetchone()[0]\n-            == 0\n-        )\n-        assert (\n-            duckdb_conn.execute(\n-                \"SELECT count(*) from testarrow where a ='2010-01-01' and b = '2000-10-01' and c = '2010-01-01'\"\n-            ).fetchone()[0]\n-            == 1\n-        )\n-        # Try Or\n-        assert (\n-            duckdb_conn.execute(\"SELECT count(*) from testarrow where a = '2010-01-01' or b ='2000-01-01'\").fetchone()[\n-                0\n-            ]\n-            == 2\n-        )\n-\n-    def test_filter_pushdown_no_projection(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test_int (a  INTEGER, b INTEGER, c INTEGER)\")\n-        duckdb_conn.execute(\"INSERT INTO  test_int VALUES (1,1,1),(10,10,10),(100,10,100),(NULL,NULL,NULL)\")\n-        duck_tbl = duckdb_conn.table(\"test_int\")\n-        arrow_table = duck_tbl.df().convert_dtypes(dtype_backend='pyarrow')\n-        duckdb_conn.register(\"testarrowtable\", arrow_table)\n-        assert duckdb_conn.execute(\"SELECT * FROM  testarrowtable VALUES where a =1\").fetchall() == [(1, 1, 1)]\n-\n-    @pytest.mark.parametrize('pandas', [ArrowPandas()])\n-    def test_filter_pushdown_2145(self, duckdb_cursor, pandas):\n-        date1 = pandas.date_range(\"2018-01-01\", \"2018-12-31\", freq=\"B\")\n-        df1 = pandas.DataFrame(np.random.randn(date1.shape[0], 5), columns=list(\"ABCDE\"))\n-        df1[\"date\"] = date1\n-\n-        date2 = pandas.date_range(\"2019-01-01\", \"2019-12-31\", freq=\"B\")\n-        df2 = pandas.DataFrame(np.random.randn(date2.shape[0], 5), columns=list(\"ABCDE\"))\n-        df2[\"date\"] = date2\n-\n-        con = duckdb.connect()\n-        con.execute(\"copy (select * from df1) to 'data1.parquet'\")\n-        con.execute(\"copy (select * from df2) to 'data2.parquet'\")\n-\n-        table = pq.ParquetDataset([\"data1.parquet\", \"data2.parquet\"]).read()\n-\n-        con.register(\"testarrow\", table)\n-\n-        output_df = duckdb.arrow(table).filter(\"date > '2019-01-01'\").df()\n-        expected_df = duckdb.from_parquet(\"data*.parquet\").filter(\"date > '2019-01-01'\").df()\n-        pandas.testing.assert_frame_equal(expected_df, output_df)\n-\n-        os.remove(\"data1.parquet\")\n-        os.remove(\"data2.parquet\")\n-\n-    def test_filter_column_removal(self, duckdb_cursor):\n-        duckdb_conn.execute(\"CREATE TABLE test AS SELECT range i, range j FROM range(5)\")\n-        duck_test_table = duckdb_conn.table(\"test\")\n-        arrow_test_table = duck_test_table.df().convert_dtypes(dtype_backend='pyarrow')\n-        duckdb_conn.register(\"arrow_test_table\", arrow_test_table)\n-\n-        # PR 4817 - remove filter columns that are unused in the remainder of the query plan from the table function\n-        query_res = duckdb_conn.execute(\"EXPLAIN SELECT count(*) from testarrow where a = 100 or b =1\").fetchall()\n-        match = re.search(\"\u2502 +j +\u2502\", query_res[0][1])\n-        assert not match\n",
  "problem_statement": "Error mapping from python pyarrow/numpy uint64 to duckdb LogicalType\n### What happens?\r\n\r\nIf I have a pandas dataframe with a `uint64` column, I am able to use a `uint64` in a prepared statement. However, if that same dataframe is a pyarrow table, then it stops working.\r\n\r\n### To Reproduce\r\n\r\n```python\r\nimport pandas as pd\r\nimport pyarrow as pa\r\nimport numpy as np\r\nimport duckdb\r\n\r\nval = np.iinfo(np.uint64).max\r\ndf = pd.DataFrame({\"a\": np.array([val], dtype=np.uint64)})\r\n\r\ntry:\r\n    with duckdb.connect(database=\":memory:\", read_only=False) as con:\r\n        _ = con.execute(\"select * from df where a = $1\", (val,)).df()\r\nexcept Exception as e:\r\n    print(\"Attempt 1:\", e)\r\nelse:\r\n    print(\"Attempt 1: Success!\")\r\n\r\nt = pa.Table.from_pandas(df)\r\ntry:\r\n    with duckdb.connect(database=\":memory:\", read_only=False) as con:\r\n        _ = con.execute(\"select * from t where a = $1\", (val,)).df()\r\nexcept Exception as e:\r\n    print(\"Attempt 2:\", e)\r\nelse:\r\n    print(\"Attempt 2: Success!\")\r\n\r\ntry:\r\n    with duckdb.connect(database=\":memory:\", read_only=False) as con:\r\n        _ = con.execute(\"select * from t where a = $1\", pa.array([val], type=pa.uint64())).df()\r\nexcept Exception as e:\r\n    print(\"Attempt 3:\", e)\r\nelse:\r\n    print(\"Attempt 3: Success!\")\r\n\r\ntry:\r\n    with duckdb.connect(database=\":memory:\", read_only=False) as con:\r\n        _ = con.execute(\"select * from t where a = $1\", np.array([val], dtype=np.uint64)).df()\r\nexcept Exception as e:\r\n    print(\"Attempt 4:\", e)\r\nelse:\r\n    print(\"Attempt 4: Success!\")\r\n```\r\n\r\ngives\r\n\r\n```\r\nAttempt 1: Success!\r\nAttempt 2: Invalid Error: OverflowError: Python int too large to convert to C long\r\n\r\nAt:\r\n  pyarrow/error.pxi(144): pyarrow.lib.pyarrow_internal_check_status\r\n\r\nAttempt 3: Not implemented Error: Unable to transform python value of type '<class 'pyarrow.lib.UInt64Scalar'>' to DuckDB LogicalType\r\nAttempt 4: Not implemented Error: Unable to transform python value of type '<class 'numpy.uint64'>' to DuckDB LogicalType\r\n```\r\n\r\n### OS:\r\n\r\ndocker -- ubuntu 22.04\r\n\r\n### DuckDB Version:\r\n\r\npython-duckdb 0.8.1 from conda-forge\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nBrett Tully\r\n\r\n### Affiliation:\r\n\r\nNearmap\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "The prepared statement element might be a red herring. If I simplify completely I get an error that suggests duckdb isn't getting the scheme correctly from the pyarrow table?\r\n\r\n```python\r\ntry:\r\n    with duckdb.connect(database=\":memory:\", read_only=False) as con:\r\n        _ = con.execute(f\"select * from t where a > 0\").df()\r\nexcept Exception as e:\r\n    print(\"Attempt 5:\", e)\r\nelse:\r\n    print(\"Attempt 5: Success!\")\r\n```\r\n\r\nGives\r\n```\r\nAttempt 5: Invalid Input Error: arrow_scan: get_next failed(): Invalid: Integer value 18446744073709551615 not in range: 0 to 9223372036854775807\r\n```\n```python\r\nwith duckdb.connect(database=\":memory:\", read_only=False) as con:\r\n    display(con.execute(f\"describe select * from t\").df())\r\n```\r\nGives the expected result\r\n![image](https://github.com/duckdb/duckdb/assets/5830269/b55ba368-8134-48ad-ae0c-ebf092906793)\r\n\nContinuing the theme of something strange\r\n```python\r\ntry:\r\n    _ = duckdb.arrow(t).filter(\"a > 0\").df()\r\nexcept Exception as e:\r\n    print(\"Attempt 6:\", e)\r\nelse:\r\n    print(\"Attempt 6: Success!\")\r\n```\r\ngives\r\n```\r\nAttempt 6: Invalid Input Error: arrow_scan: get_next failed(): Invalid: Integer value 18446744073709551615 not in range: 0 to 9223372036854775807\r\n```\nFinally got something to work, but it's ugly...\r\n\r\n```python\r\nimport pyarrow.compute as pc\r\n\r\narrow_scanner = ds.Scanner.from_dataset(ds.dataset(t), filter=pc.greater(pc.field(\"a\"), pa.scalar(0, type=pa.uint64())))\r\nwith duckdb.connect(database=\":memory:\", read_only=False) as con:\r\n    df = con.execute(\"SELECT * FROM arrow_scanner\").df()\r\n    print(df)\r\n```\r\n\r\nIf I drop the type from the scalar, then I get the same errors as above\r\n\r\n```python\r\nimport pyarrow.compute as pc\r\n\r\narrow_scanner = ds.Scanner.from_dataset(ds.dataset(t), filter=pc.greater(pc.field(\"a\"), pa.scalar(0)))\r\nwith duckdb.connect(database=\":memory:\", read_only=False) as con:\r\n    df = con.execute(\"SELECT * FROM arrow_scanner\").df()\r\n    print(df)\r\n```\r\ngives\r\n```\r\nInvalidInputException: Invalid Input Error: arrow_scan: get_next failed(): Invalid: Integer value 18446744073709551615 not in range: 0 to 9223372036854775807\r\n```\nHey, thanks for raising the issue!\r\n\r\nThese are in fact two separate issues though, and I would categorize one as a feature request rather than a bug.\r\n\r\nI think this highlights a bug in our pyarrow filter pushdown logic, we had something similar with timestamps recently.\r\nNot accepting pyarrow/numpy scalars is expected though, happy to add it but that would not make it into 0.9.1\nInteresting, thanks @Tishj. For my own understanding, which cases fall into each bucket?\nfeature:\r\n```\r\nAttempt 3: Not implemented Error: Unable to transform python value of type '<class 'pyarrow.lib.UInt64Scalar'>' to DuckDB LogicalType\r\nAttempt 4: Not implemented Error: Unable to transform python value of type '<class 'numpy.uint64'>' to DuckDB LogicalType\r\n```\r\n\r\n(most likely) bug:\r\n```\r\nInvalidInputException: Invalid Input Error: arrow_scan: get_next failed(): ...\r\n```\r\nWhat likely happens is that when we scan the arrow batch we convert to a narrowing integer type, we create a filter set based on `(a > 0)`, then realize this is scanning an arrow batch reader so we convert the filter set to pyarrow and push it down to the scan.\r\nThe conversion of the filter set to pyarrow is likely where the bug is\nMakes sense, thanks.\n\nWith the type conversion feature request, I was wondering how that relates to the numpy types here: https://duckdb.org/docs/api/python/types.html#numpy-dtypes \nI have a fix \ud83d\udc4d \r\n\r\nWe were creating `pyarrow.dataset.scalar(value)` directly, without specifying a type explicitly\r\nSince the constant is `0`, this narrows to smaller than uint64.\r\n\r\nThat sounds like a bug in pyarrow to be honest, uint64 > int32 shouldn't narrow the schema to int32\r\nBut never the less it's fixed",
  "created_at": "2023-09-28T12:44:07Z"
}