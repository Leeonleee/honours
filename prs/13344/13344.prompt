You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Exception Raised when trying to EXPLAIN ANALYZE with parameters
### What happens?

When I `execute` the query `EXPLAIN ANALYZE SELECT * FROM my_table WHERE name = ?` with parameters I get `Error: Invalid Input Error: Parameter argument/count mismatch, identifiers of the excess parameters: 1`.

If I have to remove the parameters to make a sample query string it will take a long time. Thus please make parameters work.

I can see this is the same issue as in Javascript reported in the closed issue https://github.com/duckdb/duckdb/issues/9393.

### To Reproduce

```python
import duckdb

# Create a connection
con = duckdb.connect()

# Create a cursor
cur = con.cursor()

# Create a table
cur.execute("CREATE TABLE my_table (id INTEGER, name VARCHAR)")

# Insert some data
cur.execute("INSERT INTO my_table VALUES (1, 'John'), (2, 'Jane'), (3, 'Doe')")

# Execute a parameterized query
query = "EXPLAIN ANALYZE SELECT * FROM my_table WHERE name = ?"
params = ("John",)
cur.execute(query, params)

# Fetch the results
results = cur.fetchall()
print(results)

# Close the cursor and connection
cur.close()
con.close()
```

```bash
Traceback (most recent call last):
  File "/home/jovyan/repos/mt-pm-reporting/script.py", line 18, in <module>
    cur.execute(query, params)
duckdb.duckdb.InvalidInputException: Invalid Input Error: Attempting to execute an unsuccessful or closed pending query result
Error: Invalid Input Error: Parameter argument/count mismatch, identifiers of the excess parameters: 1
```

### OS:

x86

### DuckDB Version:

??

### DuckDB Client:

duckdb==1.0.0 in python

### Full Name:

Marc Skov Madsen

### Affiliation:

Ã˜rsted

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/include/duckdb/parser/transformer.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parser/transformer.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/case_insensitive_map.hpp"
12: #include "duckdb/common/constants.hpp"
13: #include "duckdb/common/enums/expression_type.hpp"
14: #include "duckdb/common/stack_checker.hpp"
15: #include "duckdb/common/types.hpp"
16: #include "duckdb/common/unordered_map.hpp"
17: #include "duckdb/parser/group_by_node.hpp"
18: #include "duckdb/parser/parsed_data/create_info.hpp"
19: #include "duckdb/parser/parsed_data/create_secret_info.hpp"
20: #include "duckdb/parser/qualified_name.hpp"
21: #include "duckdb/parser/query_node.hpp"
22: #include "duckdb/parser/query_node/cte_node.hpp"
23: #include "duckdb/parser/tokens.hpp"
24: #include "nodes/parsenodes.hpp"
25: #include "nodes/primnodes.hpp"
26: #include "pg_definitions.hpp"
27: #include "duckdb/parser/expression/parameter_expression.hpp"
28: #include "duckdb/common/enums/on_entry_not_found.hpp"
29: 
30: namespace duckdb {
31: 
32: class ColumnDefinition;
33: struct OrderByNode;
34: struct CopyInfo;
35: struct CommonTableExpressionInfo;
36: struct GroupingExpressionMap;
37: class OnConflictInfo;
38: class UpdateSetInfo;
39: class MacroFunction;
40: struct ParserOptions;
41: struct PivotColumn;
42: struct PivotColumnEntry;
43: 
44: //! The transformer class is responsible for transforming the internal Postgres
45: //! parser representation into the DuckDB representation
46: class Transformer {
47: 	friend class StackChecker<Transformer>;
48: 
49: 	struct CreatePivotEntry {
50: 		string enum_name;
51: 		unique_ptr<SelectNode> base;
52: 		unique_ptr<ParsedExpression> column;
53: 		unique_ptr<QueryNode> subquery;
54: 		bool has_parameters;
55: 	};
56: 
57: public:
58: 	explicit Transformer(ParserOptions &options);
59: 	Transformer(Transformer &parent);
60: 	~Transformer();
61: 
62: 	//! Transforms a Postgres parse tree into a set of SQL Statements
63: 	bool TransformParseTree(duckdb_libpgquery::PGList *tree, vector<unique_ptr<SQLStatement>> &statements);
64: 	string NodetypeToString(duckdb_libpgquery::PGNodeTag type);
65: 
66: 	idx_t ParamCount() const;
67: 
68: private:
69: 	optional_ptr<Transformer> parent;
70: 	//! Parser options
71: 	ParserOptions &options;
72: 	//! The current prepared statement parameter index
73: 	idx_t prepared_statement_parameter_index = 0;
74: 	//! Map from named parameter to parameter index;
75: 	case_insensitive_map_t<idx_t> named_param_map;
76: 	//! Last parameter type
77: 	PreparedParamType last_param_type = PreparedParamType::INVALID;
78: 	//! Holds window expressions defined by name. We need those when transforming the expressions referring to them.
79: 	case_insensitive_map_t<duckdb_libpgquery::PGWindowDef *> window_clauses;
80: 	//! The set of pivot entries to create
81: 	vector<unique_ptr<CreatePivotEntry>> pivot_entries;
82: 	//! Sets of stored CTEs, if any
83: 	vector<CommonTableExpressionMap *> stored_cte_map;
84: 	//! Whether or not we are currently binding a window definition
85: 	bool in_window_definition = false;
86: 
87: 	void Clear();
88: 	bool InWindowDefinition();
89: 
90: 	Transformer &RootTransformer();
91: 	const Transformer &RootTransformer() const;
92: 	void SetParamCount(idx_t new_count);
93: 	void SetParam(const string &name, idx_t index, PreparedParamType type);
94: 	bool GetParam(const string &name, idx_t &index, PreparedParamType type);
95: 
96: 	void AddPivotEntry(string enum_name, unique_ptr<SelectNode> source, unique_ptr<ParsedExpression> column,
97: 	                   unique_ptr<QueryNode> subquery, bool has_parameters);
98: 	unique_ptr<SQLStatement> GenerateCreateEnumStmt(unique_ptr<CreatePivotEntry> entry);
99: 	bool HasPivotEntries();
100: 	idx_t PivotEntryCount();
101: 	vector<unique_ptr<CreatePivotEntry>> &GetPivotEntries();
102: 	void PivotEntryCheck(const string &type);
103: 	void ExtractCTEsRecursive(CommonTableExpressionMap &cte_map);
104: 
105: private:
106: 	//! Transforms a Postgres statement into a single SQL statement
107: 	unique_ptr<SQLStatement> TransformStatement(duckdb_libpgquery::PGNode &stmt);
108: 	//! Transforms a Postgres statement into a single SQL statement
109: 	unique_ptr<SQLStatement> TransformStatementInternal(duckdb_libpgquery::PGNode &stmt);
110: 	//===--------------------------------------------------------------------===//
111: 	// Statement transformation
112: 	//===--------------------------------------------------------------------===//
113: 	//! Transform a Postgres duckdb_libpgquery::T_PGSelectStmt node into a SelectStatement
114: 	unique_ptr<SelectStatement> TransformSelect(optional_ptr<duckdb_libpgquery::PGNode> node, bool is_select = true);
115: 	//! Transform a Postgres duckdb_libpgquery::T_PGSelectStmt node into a SelectStatement
116: 	unique_ptr<SelectStatement> TransformSelect(duckdb_libpgquery::PGSelectStmt &select, bool is_select = true);
117: 	//! Transform a Postgres T_AlterStmt node into a AlterStatement
118: 	unique_ptr<AlterStatement> TransformAlter(duckdb_libpgquery::PGAlterTableStmt &stmt);
119: 	//! Transform a Postgres duckdb_libpgquery::T_PGRenameStmt node into a RenameStatement
120: 	unique_ptr<AlterStatement> TransformRename(duckdb_libpgquery::PGRenameStmt &stmt);
121: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateStmt node into a CreateStatement
122: 	unique_ptr<CreateStatement> TransformCreateTable(duckdb_libpgquery::PGCreateStmt &node);
123: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateStmt node into a CreateStatement
124: 	unique_ptr<CreateStatement> TransformCreateTableAs(duckdb_libpgquery::PGCreateTableAsStmt &stmt);
125: 	//! Transform a Postgres node into a CreateStatement
126: 	unique_ptr<CreateStatement> TransformCreateSchema(duckdb_libpgquery::PGCreateSchemaStmt &stmt);
127: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateSeqStmt node into a CreateStatement
128: 	unique_ptr<CreateStatement> TransformCreateSequence(duckdb_libpgquery::PGCreateSeqStmt &node);
129: 	//! Transform a Postgres duckdb_libpgquery::T_PGViewStmt node into a CreateStatement
130: 	unique_ptr<CreateStatement> TransformCreateView(duckdb_libpgquery::PGViewStmt &node);
131: 	//! Transform a Postgres duckdb_libpgquery::T_PGIndexStmt node into CreateStatement
132: 	unique_ptr<CreateStatement> TransformCreateIndex(duckdb_libpgquery::PGIndexStmt &stmt);
133: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateFunctionStmt node into CreateStatement
134: 	unique_ptr<CreateStatement> TransformCreateFunction(duckdb_libpgquery::PGCreateFunctionStmt &stmt);
135: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateTypeStmt node into CreateStatement
136: 	unique_ptr<CreateStatement> TransformCreateType(duckdb_libpgquery::PGCreateTypeStmt &stmt);
137: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateTypeStmt node into CreateStatement
138: 	unique_ptr<AlterStatement> TransformCommentOn(duckdb_libpgquery::PGCommentOnStmt &stmt);
139: 	//! Transform a Postgres duckdb_libpgquery::T_PGAlterSeqStmt node into CreateStatement
140: 	unique_ptr<AlterStatement> TransformAlterSequence(duckdb_libpgquery::PGAlterSeqStmt &stmt);
141: 	//! Transform a Postgres duckdb_libpgquery::T_PGDropStmt node into a Drop[Table,Schema]Statement
142: 	unique_ptr<SQLStatement> TransformDrop(duckdb_libpgquery::PGDropStmt &stmt);
143: 	//! Transform a Postgres duckdb_libpgquery::T_PGInsertStmt node into a InsertStatement
144: 	unique_ptr<InsertStatement> TransformInsert(duckdb_libpgquery::PGInsertStmt &stmt);
145: 
146: 	//! Transform a Postgres duckdb_libpgquery::T_PGOnConflictClause node into a OnConflictInfo
147: 	unique_ptr<OnConflictInfo> TransformOnConflictClause(duckdb_libpgquery::PGOnConflictClause *node,
148: 	                                                     const string &relname);
149: 	//! Transform a ON CONFLICT shorthand into a OnConflictInfo
150: 	unique_ptr<OnConflictInfo> DummyOnConflictClause(duckdb_libpgquery::PGOnConflictActionAlias type,
151: 	                                                 const string &relname);
152: 	//! Transform a Postgres duckdb_libpgquery::T_PGCopyStmt node into a CopyStatement
153: 	unique_ptr<CopyStatement> TransformCopy(duckdb_libpgquery::PGCopyStmt &stmt);
154: 	void TransformCopyOptions(CopyInfo &info, optional_ptr<duckdb_libpgquery::PGList> options);
155: 	void TransformCreateSecretOptions(CreateSecretInfo &info, optional_ptr<duckdb_libpgquery::PGList> options);
156: 	//! Transform a Postgres duckdb_libpgquery::T_PGTransactionStmt node into a TransactionStatement
157: 	unique_ptr<TransactionStatement> TransformTransaction(duckdb_libpgquery::PGTransactionStmt &stmt);
158: 	//! Transform a Postgres T_DeleteStatement node into a DeleteStatement
159: 	unique_ptr<DeleteStatement> TransformDelete(duckdb_libpgquery::PGDeleteStmt &stmt);
160: 	//! Transform a Postgres duckdb_libpgquery::T_PGUpdateStmt node into a UpdateStatement
161: 	unique_ptr<UpdateStatement> TransformUpdate(duckdb_libpgquery::PGUpdateStmt &stmt);
162: 	//! Transform a Postgres duckdb_libpgquery::T_PGUpdateExtensionsStmt node into a UpdateExtensionsStatement
163: 	unique_ptr<UpdateExtensionsStatement> TransformUpdateExtensions(duckdb_libpgquery::PGUpdateExtensionsStmt &stmt);
164: 	//! Transform a Postgres duckdb_libpgquery::T_PGPragmaStmt node into a PragmaStatement
165: 	unique_ptr<SQLStatement> TransformPragma(duckdb_libpgquery::PGPragmaStmt &stmt);
166: 	//! Transform a Postgres duckdb_libpgquery::T_PGExportStmt node into a ExportStatement
167: 	unique_ptr<ExportStatement> TransformExport(duckdb_libpgquery::PGExportStmt &stmt);
168: 	//! Transform a Postgres duckdb_libpgquery::T_PGImportStmt node into a PragmaStatement
169: 	unique_ptr<PragmaStatement> TransformImport(duckdb_libpgquery::PGImportStmt &stmt);
170: 	unique_ptr<ExplainStatement> TransformExplain(duckdb_libpgquery::PGExplainStmt &stmt);
171: 	unique_ptr<SQLStatement> TransformVacuum(duckdb_libpgquery::PGVacuumStmt &stmt);
172: 	unique_ptr<SelectStatement> TransformShow(duckdb_libpgquery::PGVariableShowStmt &stmt);
173: 	unique_ptr<SelectStatement> TransformShowSelect(duckdb_libpgquery::PGVariableShowSelectStmt &stmt);
174: 	unique_ptr<AttachStatement> TransformAttach(duckdb_libpgquery::PGAttachStmt &stmt);
175: 	unique_ptr<DetachStatement> TransformDetach(duckdb_libpgquery::PGDetachStmt &stmt);
176: 	unique_ptr<SetStatement> TransformUse(duckdb_libpgquery::PGUseStmt &stmt);
177: 	unique_ptr<SQLStatement> TransformCopyDatabase(duckdb_libpgquery::PGCopyDatabaseStmt &stmt);
178: 	unique_ptr<CreateStatement> TransformSecret(duckdb_libpgquery::PGCreateSecretStmt &stmt);
179: 	unique_ptr<DropStatement> TransformDropSecret(duckdb_libpgquery::PGDropSecretStmt &stmt);
180: 
181: 	unique_ptr<PrepareStatement> TransformPrepare(duckdb_libpgquery::PGPrepareStmt &stmt);
182: 	unique_ptr<ExecuteStatement> TransformExecute(duckdb_libpgquery::PGExecuteStmt &stmt);
183: 	unique_ptr<CallStatement> TransformCall(duckdb_libpgquery::PGCallStmt &stmt);
184: 	unique_ptr<DropStatement> TransformDeallocate(duckdb_libpgquery::PGDeallocateStmt &stmt);
185: 	unique_ptr<QueryNode> TransformPivotStatement(duckdb_libpgquery::PGSelectStmt &select);
186: 	unique_ptr<SQLStatement> CreatePivotStatement(unique_ptr<SQLStatement> statement);
187: 	PivotColumn TransformPivotColumn(duckdb_libpgquery::PGPivot &pivot, bool is_pivot);
188: 	vector<PivotColumn> TransformPivotList(duckdb_libpgquery::PGList &list, bool is_pivot);
189: 	static bool TransformPivotInList(unique_ptr<ParsedExpression> &expr, PivotColumnEntry &entry,
190: 	                                 bool root_entry = true);
191: 
192: 	//===--------------------------------------------------------------------===//
193: 	// SetStatement Transform
194: 	//===--------------------------------------------------------------------===//
195: 	unique_ptr<SetStatement> TransformSet(duckdb_libpgquery::PGVariableSetStmt &set);
196: 	unique_ptr<SetStatement> TransformSetVariable(duckdb_libpgquery::PGVariableSetStmt &stmt);
197: 	unique_ptr<SetStatement> TransformResetVariable(duckdb_libpgquery::PGVariableSetStmt &stmt);
198: 
199: 	unique_ptr<SQLStatement> TransformCheckpoint(duckdb_libpgquery::PGCheckPointStmt &stmt);
200: 	unique_ptr<LoadStatement> TransformLoad(duckdb_libpgquery::PGLoadStmt &stmt);
201: 
202: 	//===--------------------------------------------------------------------===//
203: 	// Query Node Transform
204: 	//===--------------------------------------------------------------------===//
205: 	//! Transform a Postgres duckdb_libpgquery::T_PGSelectStmt node into a QueryNode
206: 	unique_ptr<QueryNode> TransformSelectNode(duckdb_libpgquery::PGSelectStmt &select);
207: 	unique_ptr<QueryNode> TransformSelectInternal(duckdb_libpgquery::PGSelectStmt &select);
208: 	void TransformModifiers(duckdb_libpgquery::PGSelectStmt &stmt, QueryNode &node);
209: 
210: 	//===--------------------------------------------------------------------===//
211: 	// Expression Transform
212: 	//===--------------------------------------------------------------------===//
213: 	//! Transform a Postgres boolean expression into an Expression
214: 	unique_ptr<ParsedExpression> TransformBoolExpr(duckdb_libpgquery::PGBoolExpr &root);
215: 	//! Transform a Postgres case expression into an Expression
216: 	unique_ptr<ParsedExpression> TransformCase(duckdb_libpgquery::PGCaseExpr &root);
217: 	//! Transform a Postgres type cast into an Expression
218: 	unique_ptr<ParsedExpression> TransformTypeCast(duckdb_libpgquery::PGTypeCast &root);
219: 	//! Transform a Postgres coalesce into an Expression
220: 	unique_ptr<ParsedExpression> TransformCoalesce(duckdb_libpgquery::PGAExpr &root);
221: 	//! Transform a Postgres column reference into an Expression
222: 	unique_ptr<ParsedExpression> TransformColumnRef(duckdb_libpgquery::PGColumnRef &root);
223: 	//! Transform a Postgres constant value into an Expression
224: 	unique_ptr<ConstantExpression> TransformValue(duckdb_libpgquery::PGValue val);
225: 	//! Transform a Postgres operator into an Expression
226: 	unique_ptr<ParsedExpression> TransformAExpr(duckdb_libpgquery::PGAExpr &root);
227: 	unique_ptr<ParsedExpression> TransformAExprInternal(duckdb_libpgquery::PGAExpr &root);
228: 	//! Transform a Postgres abstract expression into an Expression
229: 	unique_ptr<ParsedExpression> TransformExpression(optional_ptr<duckdb_libpgquery::PGNode> node);
230: 	unique_ptr<ParsedExpression> TransformExpression(duckdb_libpgquery::PGNode &node);
231: 	//! Transform a Postgres function call into an Expression
232: 	unique_ptr<ParsedExpression> TransformFuncCall(duckdb_libpgquery::PGFuncCall &root);
233: 	//! Transform a Postgres boolean expression into an Expression
234: 	unique_ptr<ParsedExpression> TransformInterval(duckdb_libpgquery::PGIntervalConstant &root);
235: 	//! Transform a Postgres lambda node [e.g. (x, y) -> x + y] into a lambda expression
236: 	unique_ptr<ParsedExpression> TransformLambda(duckdb_libpgquery::PGLambdaFunction &node);
237: 	//! Transform a Postgres array access node (e.g. x[1] or x[1:3])
238: 	unique_ptr<ParsedExpression> TransformArrayAccess(duckdb_libpgquery::PGAIndirection &node);
239: 	//! Transform a positional reference (e.g. #1)
240: 	unique_ptr<ParsedExpression> TransformPositionalReference(duckdb_libpgquery::PGPositionalReference &node);
241: 	unique_ptr<ParsedExpression> TransformStarExpression(duckdb_libpgquery::PGAStar &node);
242: 	unique_ptr<ParsedExpression> TransformBooleanTest(duckdb_libpgquery::PGBooleanTest &node);
243: 
244: 	//! Transform a Postgres constant value into an Expression
245: 	unique_ptr<ParsedExpression> TransformConstant(duckdb_libpgquery::PGAConst &c);
246: 	unique_ptr<ParsedExpression> TransformGroupingFunction(duckdb_libpgquery::PGGroupingFunc &n);
247: 	unique_ptr<ParsedExpression> TransformResTarget(duckdb_libpgquery::PGResTarget &root);
248: 	unique_ptr<ParsedExpression> TransformNullTest(duckdb_libpgquery::PGNullTest &root);
249: 	unique_ptr<ParsedExpression> TransformParamRef(duckdb_libpgquery::PGParamRef &node);
250: 	unique_ptr<ParsedExpression> TransformNamedArg(duckdb_libpgquery::PGNamedArgExpr &root);
251: 
252: 	//! Transform multi assignment reference into an Expression
253: 	unique_ptr<ParsedExpression> TransformMultiAssignRef(duckdb_libpgquery::PGMultiAssignRef &root);
254: 
255: 	unique_ptr<ParsedExpression> TransformSQLValueFunction(duckdb_libpgquery::PGSQLValueFunction &node);
256: 
257: 	unique_ptr<ParsedExpression> TransformSubquery(duckdb_libpgquery::PGSubLink &root);
258: 	//===--------------------------------------------------------------------===//
259: 	// Constraints transform
260: 	//===--------------------------------------------------------------------===//
261: 	unique_ptr<Constraint> TransformConstraint(duckdb_libpgquery::PGListCell &cell);
262: 	unique_ptr<Constraint> TransformConstraint(duckdb_libpgquery::PGListCell &cell, ColumnDefinition &column,
263: 	                                           idx_t index);
264: 
265: 	//===--------------------------------------------------------------------===//
266: 	// Update transform
267: 	//===--------------------------------------------------------------------===//
268: 	unique_ptr<UpdateSetInfo> TransformUpdateSetInfo(duckdb_libpgquery::PGList *target_list,
269: 	                                                 duckdb_libpgquery::PGNode *where_clause);
270: 
271: 	//===--------------------------------------------------------------------===//
272: 	// Index transform
273: 	//===--------------------------------------------------------------------===//
274: 	vector<unique_ptr<ParsedExpression>> TransformIndexParameters(duckdb_libpgquery::PGList &list,
275: 	                                                              const string &relation_name);
276: 
277: 	//===--------------------------------------------------------------------===//
278: 	// Collation transform
279: 	//===--------------------------------------------------------------------===//
280: 	unique_ptr<ParsedExpression> TransformCollateExpr(duckdb_libpgquery::PGCollateClause &collate);
281: 
282: 	string TransformCollation(optional_ptr<duckdb_libpgquery::PGCollateClause> collate);
283: 
284: 	ColumnDefinition TransformColumnDefinition(duckdb_libpgquery::PGColumnDef &cdef);
285: 	//===--------------------------------------------------------------------===//
286: 	// Helpers
287: 	//===--------------------------------------------------------------------===//
288: 	OnCreateConflict TransformOnConflict(duckdb_libpgquery::PGOnCreateConflict conflict);
289: 	string TransformAlias(duckdb_libpgquery::PGAlias *root, vector<string> &column_name_alias);
290: 	vector<string> TransformStringList(duckdb_libpgquery::PGList *list);
291: 	void TransformCTE(duckdb_libpgquery::PGWithClause &de_with_clause, CommonTableExpressionMap &cte_map);
292: 	static unique_ptr<QueryNode> TransformMaterializedCTE(unique_ptr<QueryNode> root);
293: 	unique_ptr<SelectStatement> TransformRecursiveCTE(duckdb_libpgquery::PGCommonTableExpr &node,
294: 	                                                  CommonTableExpressionInfo &info);
295: 
296: 	unique_ptr<ParsedExpression> TransformUnaryOperator(const string &op, unique_ptr<ParsedExpression> child);
297: 	unique_ptr<ParsedExpression> TransformBinaryOperator(string op, unique_ptr<ParsedExpression> left,
298: 	                                                     unique_ptr<ParsedExpression> right);
299: 	static bool ConstructConstantFromExpression(const ParsedExpression &expr, Value &value);
300: 	//===--------------------------------------------------------------------===//
301: 	// TableRef transform
302: 	//===--------------------------------------------------------------------===//
303: 	//! Transform a Postgres node into a TableRef
304: 	unique_ptr<TableRef> TransformTableRefNode(duckdb_libpgquery::PGNode &n);
305: 	//! Transform a Postgres FROM clause into a TableRef
306: 	unique_ptr<TableRef> TransformFrom(optional_ptr<duckdb_libpgquery::PGList> root);
307: 	//! Transform a Postgres table reference into a TableRef
308: 	unique_ptr<TableRef> TransformRangeVar(duckdb_libpgquery::PGRangeVar &root);
309: 	//! Transform a Postgres table-producing function into a TableRef
310: 	unique_ptr<TableRef> TransformRangeFunction(duckdb_libpgquery::PGRangeFunction &root);
311: 	//! Transform a Postgres join node into a TableRef
312: 	unique_ptr<TableRef> TransformJoin(duckdb_libpgquery::PGJoinExpr &root);
313: 	//! Transform a Postgres pivot node into a TableRef
314: 	unique_ptr<TableRef> TransformPivot(duckdb_libpgquery::PGPivotExpr &root);
315: 	//! Transform a table producing subquery into a TableRef
316: 	unique_ptr<TableRef> TransformRangeSubselect(duckdb_libpgquery::PGRangeSubselect &root);
317: 	//! Transform a VALUES list into a set of expressions
318: 	unique_ptr<TableRef> TransformValuesList(duckdb_libpgquery::PGList *list);
319: 
320: 	//! Transform a range var into a (schema) qualified name
321: 	QualifiedName TransformQualifiedName(duckdb_libpgquery::PGRangeVar &root);
322: 
323: 	//! Transform a Postgres TypeName string into a LogicalType
324: 	LogicalType TransformTypeName(duckdb_libpgquery::PGTypeName &name);
325: 
326: 	//! Transform a list of type modifiers into a list of values
327: 	vector<Value> TransformTypeModifiers(duckdb_libpgquery::PGTypeName &name);
328: 
329: 	//! Transform a Postgres GROUP BY expression into a list of Expression
330: 	bool TransformGroupBy(optional_ptr<duckdb_libpgquery::PGList> group, SelectNode &result);
331: 	void TransformGroupByNode(duckdb_libpgquery::PGNode &n, GroupingExpressionMap &map, SelectNode &result,
332: 	                          vector<GroupingSet> &result_sets);
333: 	void AddGroupByExpression(unique_ptr<ParsedExpression> expression, GroupingExpressionMap &map, GroupByNode &result,
334: 	                          vector<idx_t> &result_set);
335: 	void TransformGroupByExpression(duckdb_libpgquery::PGNode &n, GroupingExpressionMap &map, GroupByNode &result,
336: 	                                vector<idx_t> &result_set);
337: 	//! Transform a Postgres ORDER BY expression into an OrderByDescription
338: 	bool TransformOrderBy(duckdb_libpgquery::PGList *order, vector<OrderByNode> &result);
339: 
340: 	//! Transform to a IN or NOT IN expression
341: 	unique_ptr<ParsedExpression> TransformInExpression(const string &name, duckdb_libpgquery::PGAExpr &root);
342: 
343: 	//! Transform a Postgres SELECT clause into a list of Expressions
344: 	void TransformExpressionList(duckdb_libpgquery::PGList &list, vector<unique_ptr<ParsedExpression>> &result);
345: 
346: 	//! Transform a Postgres PARTITION BY/ORDER BY specification into lists of expressions
347: 	void TransformWindowDef(duckdb_libpgquery::PGWindowDef &window_spec, WindowExpression &expr,
348: 	                        const char *window_name = nullptr);
349: 	//! Transform a Postgres window frame specification into frame expressions
350: 	void TransformWindowFrame(duckdb_libpgquery::PGWindowDef &window_spec, WindowExpression &expr);
351: 
352: 	unique_ptr<SampleOptions> TransformSampleOptions(optional_ptr<duckdb_libpgquery::PGNode> options);
353: 	//! Returns true if an expression is only a star (i.e. "*", without any other decorators)
354: 	bool ExpressionIsEmptyStar(ParsedExpression &expr);
355: 
356: 	OnEntryNotFound TransformOnEntryNotFound(bool missing_ok);
357: 
358: 	Vector PGListToVector(optional_ptr<duckdb_libpgquery::PGList> column_list, idx_t &size);
359: 	vector<string> TransformConflictTarget(duckdb_libpgquery::PGList &list);
360: 
361: 	unique_ptr<MacroFunction> TransformMacroFunction(duckdb_libpgquery::PGFunctionDefinition &function);
362: 
363: 	void ParseGenericOptionListEntry(case_insensitive_map_t<vector<Value>> &result_options, string &name,
364: 	                                 duckdb_libpgquery::PGNode *arg);
365: 
366: public:
367: 	static void SetQueryLocation(ParsedExpression &expr, int query_location);
368: 	static void SetQueryLocation(TableRef &ref, int query_location);
369: 
370: private:
371: 	//! Current stack depth
372: 	idx_t stack_depth;
373: 
374: 	void InitializeStackCheck();
375: 	StackChecker<Transformer> StackCheck(idx_t extra_stack = 1);
376: 
377: public:
378: 	template <class T>
379: 	static T &PGCast(duckdb_libpgquery::PGNode &node) {
380: 		return reinterpret_cast<T &>(node);
381: 	}
382: 	template <class T>
383: 	static optional_ptr<T> PGPointerCast(void *ptr) {
384: 		return optional_ptr<T>(reinterpret_cast<T *>(ptr));
385: 	}
386: };
387: 
388: vector<string> ReadPgListToString(duckdb_libpgquery::PGList *column_list);
389: 
390: } // namespace duckdb
[end of src/include/duckdb/parser/transformer.hpp]
[start of src/parser/transform/statement/transform_prepare.cpp]
1: #include "duckdb/parser/statement/drop_statement.hpp"
2: #include "duckdb/parser/statement/execute_statement.hpp"
3: #include "duckdb/parser/statement/prepare_statement.hpp"
4: #include "duckdb/parser/transformer.hpp"
5: #include "duckdb/parser/expression/comparison_expression.hpp"
6: #include "duckdb/parser/expression/columnref_expression.hpp"
7: 
8: namespace duckdb {
9: 
10: unique_ptr<PrepareStatement> Transformer::TransformPrepare(duckdb_libpgquery::PGPrepareStmt &stmt) {
11: 	if (stmt.argtypes && stmt.argtypes->length > 0) {
12: 		throw NotImplementedException("Prepared statement argument types are not supported, use CAST");
13: 	}
14: 
15: 	auto result = make_uniq<PrepareStatement>();
16: 	result->name = string(stmt.name);
17: 	result->statement = TransformStatement(*stmt.query);
18: 	SetParamCount(0);
19: 
20: 	return result;
21: }
22: 
23: static string NotAcceptedExpressionException() {
24: 	return "Only scalar parameters, named parameters or NULL supported for EXECUTE";
25: }
26: 
27: unique_ptr<ExecuteStatement> Transformer::TransformExecute(duckdb_libpgquery::PGExecuteStmt &stmt) {
28: 	auto result = make_uniq<ExecuteStatement>();
29: 	result->name = string(stmt.name);
30: 
31: 	vector<unique_ptr<ParsedExpression>> intermediate_values;
32: 	if (stmt.params) {
33: 		TransformExpressionList(*stmt.params, intermediate_values);
34: 	}
35: 
36: 	idx_t param_idx = 0;
37: 	for (idx_t i = 0; i < intermediate_values.size(); i++) {
38: 		auto &expr = intermediate_values[i];
39: 		if (!expr->IsScalar()) {
40: 			throw InvalidInputException(NotAcceptedExpressionException());
41: 		}
42: 		if (!expr->alias.empty() && param_idx != 0) {
43: 			// Found unnamed parameters mixed with named parameters
44: 			throw NotImplementedException("Mixing named parameters and positional parameters is not supported yet");
45: 		}
46: 		auto param_name = expr->alias;
47: 		if (expr->alias.empty()) {
48: 			param_name = std::to_string(param_idx + 1);
49: 			if (param_idx != i) {
50: 				throw NotImplementedException("Mixing named parameters and positional parameters is not supported yet");
51: 			}
52: 			param_idx++;
53: 		}
54: 		expr->alias.clear();
55: 		result->named_values[param_name] = std::move(expr);
56: 	}
57: 	intermediate_values.clear();
58: 	return result;
59: }
60: 
61: unique_ptr<DropStatement> Transformer::TransformDeallocate(duckdb_libpgquery::PGDeallocateStmt &stmt) {
62: 	if (!stmt.name) {
63: 		throw ParserException("DEALLOCATE requires a name");
64: 	}
65: 
66: 	auto result = make_uniq<DropStatement>();
67: 	result->info->type = CatalogType::PREPARED_STATEMENT;
68: 	result->info->name = string(stmt.name);
69: 	return result;
70: }
71: 
72: } // namespace duckdb
[end of src/parser/transform/statement/transform_prepare.cpp]
[start of src/parser/transformer.cpp]
1: #include "duckdb/parser/transformer.hpp"
2: 
3: #include "duckdb/parser/expression/list.hpp"
4: #include "duckdb/parser/statement/list.hpp"
5: #include "duckdb/parser/tableref/emptytableref.hpp"
6: #include "duckdb/parser/query_node/select_node.hpp"
7: #include "duckdb/parser/query_node/cte_node.hpp"
8: #include "duckdb/parser/parser_options.hpp"
9: 
10: namespace duckdb {
11: 
12: Transformer::Transformer(ParserOptions &options)
13:     : parent(nullptr), options(options), stack_depth(DConstants::INVALID_INDEX) {
14: }
15: 
16: Transformer::Transformer(Transformer &parent)
17:     : parent(&parent), options(parent.options), stack_depth(DConstants::INVALID_INDEX) {
18: }
19: 
20: Transformer::~Transformer() {
21: }
22: 
23: void Transformer::Clear() {
24: 	SetParamCount(0);
25: 	pivot_entries.clear();
26: }
27: 
28: bool Transformer::TransformParseTree(duckdb_libpgquery::PGList *tree, vector<unique_ptr<SQLStatement>> &statements) {
29: 	InitializeStackCheck();
30: 	for (auto entry = tree->head; entry != nullptr; entry = entry->next) {
31: 		Clear();
32: 		auto n = PGPointerCast<duckdb_libpgquery::PGNode>(entry->data.ptr_value);
33: 		auto stmt = TransformStatement(*n);
34: 		D_ASSERT(stmt);
35: 		if (HasPivotEntries()) {
36: 			stmt = CreatePivotStatement(std::move(stmt));
37: 		}
38: 		statements.push_back(std::move(stmt));
39: 	}
40: 	return true;
41: }
42: 
43: void Transformer::InitializeStackCheck() {
44: 	stack_depth = 0;
45: }
46: 
47: StackChecker<Transformer> Transformer::StackCheck(idx_t extra_stack) {
48: 	auto &root = RootTransformer();
49: 	D_ASSERT(root.stack_depth != DConstants::INVALID_INDEX);
50: 	if (root.stack_depth + extra_stack >= options.max_expression_depth) {
51: 		throw ParserException("Max expression depth limit of %lld exceeded. Use \"SET max_expression_depth TO x\" to "
52: 		                      "increase the maximum expression depth.",
53: 		                      options.max_expression_depth);
54: 	}
55: 	return StackChecker<Transformer>(root, extra_stack);
56: }
57: 
58: unique_ptr<SQLStatement> Transformer::TransformStatement(duckdb_libpgquery::PGNode &stmt) {
59: 	auto result = TransformStatementInternal(stmt);
60: 	if (!named_param_map.empty()) {
61: 		// Avoid overriding a previous move with nothing
62: 		result->named_param_map = std::move(named_param_map);
63: 	}
64: 	return result;
65: }
66: 
67: Transformer &Transformer::RootTransformer() {
68: 	reference<Transformer> node = *this;
69: 	while (node.get().parent) {
70: 		node = *node.get().parent;
71: 	}
72: 	return node.get();
73: }
74: 
75: const Transformer &Transformer::RootTransformer() const {
76: 	reference<const Transformer> node = *this;
77: 	while (node.get().parent) {
78: 		node = *node.get().parent;
79: 	}
80: 	return node.get();
81: }
82: 
83: idx_t Transformer::ParamCount() const {
84: 	auto &root = RootTransformer();
85: 	return root.prepared_statement_parameter_index;
86: }
87: 
88: void Transformer::SetParamCount(idx_t new_count) {
89: 	auto &root = RootTransformer();
90: 	root.prepared_statement_parameter_index = new_count;
91: }
92: 
93: static void ParamTypeCheck(PreparedParamType last_type, PreparedParamType new_type) {
94: 	// Mixing positional/auto-increment and named parameters is not supported
95: 	if (last_type == PreparedParamType::INVALID) {
96: 		return;
97: 	}
98: 	if (last_type == PreparedParamType::NAMED) {
99: 		if (new_type != PreparedParamType::NAMED) {
100: 			throw NotImplementedException("Mixing named and positional parameters is not supported yet");
101: 		}
102: 	}
103: 	if (last_type != PreparedParamType::NAMED) {
104: 		if (new_type == PreparedParamType::NAMED) {
105: 			throw NotImplementedException("Mixing named and positional parameters is not supported yet");
106: 		}
107: 	}
108: }
109: 
110: void Transformer::SetParam(const string &identifier, idx_t index, PreparedParamType type) {
111: 	auto &root = RootTransformer();
112: 	ParamTypeCheck(root.last_param_type, type);
113: 	root.last_param_type = type;
114: 	D_ASSERT(!root.named_param_map.count(identifier));
115: 	root.named_param_map[identifier] = index;
116: }
117: 
118: bool Transformer::GetParam(const string &identifier, idx_t &index, PreparedParamType type) {
119: 	auto &root = RootTransformer();
120: 	ParamTypeCheck(root.last_param_type, type);
121: 	auto entry = root.named_param_map.find(identifier);
122: 	if (entry == root.named_param_map.end()) {
123: 		return false;
124: 	}
125: 	index = entry->second;
126: 	return true;
127: }
128: 
129: unique_ptr<SQLStatement> Transformer::TransformStatementInternal(duckdb_libpgquery::PGNode &stmt) {
130: 	switch (stmt.type) {
131: 	case duckdb_libpgquery::T_PGRawStmt: {
132: 		auto &raw_stmt = PGCast<duckdb_libpgquery::PGRawStmt>(stmt);
133: 		auto result = TransformStatement(*raw_stmt.stmt);
134: 		if (result) {
135: 			result->stmt_location = NumericCast<idx_t>(raw_stmt.stmt_location);
136: 			result->stmt_length = NumericCast<idx_t>(raw_stmt.stmt_len);
137: 		}
138: 		return result;
139: 	}
140: 	case duckdb_libpgquery::T_PGSelectStmt:
141: 		return TransformSelect(PGCast<duckdb_libpgquery::PGSelectStmt>(stmt));
142: 	case duckdb_libpgquery::T_PGCreateStmt:
143: 		return TransformCreateTable(PGCast<duckdb_libpgquery::PGCreateStmt>(stmt));
144: 	case duckdb_libpgquery::T_PGCreateSchemaStmt:
145: 		return TransformCreateSchema(PGCast<duckdb_libpgquery::PGCreateSchemaStmt>(stmt));
146: 	case duckdb_libpgquery::T_PGViewStmt:
147: 		return TransformCreateView(PGCast<duckdb_libpgquery::PGViewStmt>(stmt));
148: 	case duckdb_libpgquery::T_PGCreateSeqStmt:
149: 		return TransformCreateSequence(PGCast<duckdb_libpgquery::PGCreateSeqStmt>(stmt));
150: 	case duckdb_libpgquery::T_PGCreateFunctionStmt:
151: 		return TransformCreateFunction(PGCast<duckdb_libpgquery::PGCreateFunctionStmt>(stmt));
152: 	case duckdb_libpgquery::T_PGDropStmt:
153: 		return TransformDrop(PGCast<duckdb_libpgquery::PGDropStmt>(stmt));
154: 	case duckdb_libpgquery::T_PGInsertStmt:
155: 		return TransformInsert(PGCast<duckdb_libpgquery::PGInsertStmt>(stmt));
156: 	case duckdb_libpgquery::T_PGCopyStmt:
157: 		return TransformCopy(PGCast<duckdb_libpgquery::PGCopyStmt>(stmt));
158: 	case duckdb_libpgquery::T_PGTransactionStmt:
159: 		return TransformTransaction(PGCast<duckdb_libpgquery::PGTransactionStmt>(stmt));
160: 	case duckdb_libpgquery::T_PGDeleteStmt:
161: 		return TransformDelete(PGCast<duckdb_libpgquery::PGDeleteStmt>(stmt));
162: 	case duckdb_libpgquery::T_PGUpdateStmt:
163: 		return TransformUpdate(PGCast<duckdb_libpgquery::PGUpdateStmt>(stmt));
164: 	case duckdb_libpgquery::T_PGUpdateExtensionsStmt:
165: 		return TransformUpdateExtensions(PGCast<duckdb_libpgquery::PGUpdateExtensionsStmt>(stmt));
166: 	case duckdb_libpgquery::T_PGIndexStmt:
167: 		return TransformCreateIndex(PGCast<duckdb_libpgquery::PGIndexStmt>(stmt));
168: 	case duckdb_libpgquery::T_PGAlterTableStmt:
169: 		return TransformAlter(PGCast<duckdb_libpgquery::PGAlterTableStmt>(stmt));
170: 	case duckdb_libpgquery::T_PGRenameStmt:
171: 		return TransformRename(PGCast<duckdb_libpgquery::PGRenameStmt>(stmt));
172: 	case duckdb_libpgquery::T_PGPrepareStmt:
173: 		return TransformPrepare(PGCast<duckdb_libpgquery::PGPrepareStmt>(stmt));
174: 	case duckdb_libpgquery::T_PGExecuteStmt:
175: 		return TransformExecute(PGCast<duckdb_libpgquery::PGExecuteStmt>(stmt));
176: 	case duckdb_libpgquery::T_PGDeallocateStmt:
177: 		return TransformDeallocate(PGCast<duckdb_libpgquery::PGDeallocateStmt>(stmt));
178: 	case duckdb_libpgquery::T_PGCreateTableAsStmt:
179: 		return TransformCreateTableAs(PGCast<duckdb_libpgquery::PGCreateTableAsStmt>(stmt));
180: 	case duckdb_libpgquery::T_PGPragmaStmt:
181: 		return TransformPragma(PGCast<duckdb_libpgquery::PGPragmaStmt>(stmt));
182: 	case duckdb_libpgquery::T_PGExportStmt:
183: 		return TransformExport(PGCast<duckdb_libpgquery::PGExportStmt>(stmt));
184: 	case duckdb_libpgquery::T_PGImportStmt:
185: 		return TransformImport(PGCast<duckdb_libpgquery::PGImportStmt>(stmt));
186: 	case duckdb_libpgquery::T_PGExplainStmt:
187: 		return TransformExplain(PGCast<duckdb_libpgquery::PGExplainStmt>(stmt));
188: 	case duckdb_libpgquery::T_PGVacuumStmt:
189: 		return TransformVacuum(PGCast<duckdb_libpgquery::PGVacuumStmt>(stmt));
190: 	case duckdb_libpgquery::T_PGVariableShowStmt:
191: 		return TransformShow(PGCast<duckdb_libpgquery::PGVariableShowStmt>(stmt));
192: 	case duckdb_libpgquery::T_PGVariableShowSelectStmt:
193: 		return TransformShowSelect(PGCast<duckdb_libpgquery::PGVariableShowSelectStmt>(stmt));
194: 	case duckdb_libpgquery::T_PGCallStmt:
195: 		return TransformCall(PGCast<duckdb_libpgquery::PGCallStmt>(stmt));
196: 	case duckdb_libpgquery::T_PGVariableSetStmt:
197: 		return TransformSet(PGCast<duckdb_libpgquery::PGVariableSetStmt>(stmt));
198: 	case duckdb_libpgquery::T_PGCheckPointStmt:
199: 		return TransformCheckpoint(PGCast<duckdb_libpgquery::PGCheckPointStmt>(stmt));
200: 	case duckdb_libpgquery::T_PGLoadStmt:
201: 		return TransformLoad(PGCast<duckdb_libpgquery::PGLoadStmt>(stmt));
202: 	case duckdb_libpgquery::T_PGCreateTypeStmt:
203: 		return TransformCreateType(PGCast<duckdb_libpgquery::PGCreateTypeStmt>(stmt));
204: 	case duckdb_libpgquery::T_PGAlterSeqStmt:
205: 		return TransformAlterSequence(PGCast<duckdb_libpgquery::PGAlterSeqStmt>(stmt));
206: 	case duckdb_libpgquery::T_PGAttachStmt:
207: 		return TransformAttach(PGCast<duckdb_libpgquery::PGAttachStmt>(stmt));
208: 	case duckdb_libpgquery::T_PGDetachStmt:
209: 		return TransformDetach(PGCast<duckdb_libpgquery::PGDetachStmt>(stmt));
210: 	case duckdb_libpgquery::T_PGUseStmt:
211: 		return TransformUse(PGCast<duckdb_libpgquery::PGUseStmt>(stmt));
212: 	case duckdb_libpgquery::T_PGCopyDatabaseStmt:
213: 		return TransformCopyDatabase(PGCast<duckdb_libpgquery::PGCopyDatabaseStmt>(stmt));
214: 	case duckdb_libpgquery::T_PGCreateSecretStmt:
215: 		return TransformSecret(PGCast<duckdb_libpgquery::PGCreateSecretStmt>(stmt));
216: 	case duckdb_libpgquery::T_PGDropSecretStmt:
217: 		return TransformDropSecret(PGCast<duckdb_libpgquery::PGDropSecretStmt>(stmt));
218: 	case duckdb_libpgquery::T_PGCommentOnStmt:
219: 		return TransformCommentOn(PGCast<duckdb_libpgquery::PGCommentOnStmt>(stmt));
220: 	default:
221: 		throw NotImplementedException(NodetypeToString(stmt.type));
222: 	}
223: }
224: 
225: unique_ptr<QueryNode> Transformer::TransformMaterializedCTE(unique_ptr<QueryNode> root) {
226: 	// Extract materialized CTEs from cte_map
227: 	vector<unique_ptr<CTENode>> materialized_ctes;
228: 
229: 	for (auto &cte : root->cte_map.map) {
230: 		auto &cte_entry = cte.second;
231: 		if (cte_entry->materialized == CTEMaterialize::CTE_MATERIALIZE_ALWAYS) {
232: 			auto mat_cte = make_uniq<CTENode>();
233: 			mat_cte->ctename = cte.first;
234: 			mat_cte->query = cte_entry->query->node->Copy();
235: 			mat_cte->aliases = cte_entry->aliases;
236: 			materialized_ctes.push_back(std::move(mat_cte));
237: 		}
238: 	}
239: 
240: 	while (!materialized_ctes.empty()) {
241: 		unique_ptr<CTENode> node_result;
242: 		node_result = std::move(materialized_ctes.back());
243: 		node_result->cte_map = root->cte_map.Copy();
244: 		node_result->child = std::move(root);
245: 		root = std::move(node_result);
246: 		materialized_ctes.pop_back();
247: 	}
248: 
249: 	return root;
250: }
251: 
252: void Transformer::SetQueryLocation(ParsedExpression &expr, int query_location) {
253: 	if (query_location < 0) {
254: 		return;
255: 	}
256: 	expr.query_location = optional_idx(idx_t(query_location));
257: }
258: 
259: void Transformer::SetQueryLocation(TableRef &ref, int query_location) {
260: 	if (query_location < 0) {
261: 		return;
262: 	}
263: 	ref.query_location = optional_idx(idx_t(query_location));
264: }
265: 
266: } // namespace duckdb
[end of src/parser/transformer.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: