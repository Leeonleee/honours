{
  "repo": "duckdb/duckdb",
  "pull_number": 10115,
  "instance_id": "duckdb__duckdb-10115",
  "issue_numbers": [
    "9948"
  ],
  "base_commit": "e61eb0c05100bad4e250be76bc014a08d6d874e4",
  "patch": "diff --git a/.github/config/out_of_tree_extensions.cmake b/.github/config/out_of_tree_extensions.cmake\nindex 3fec19326730..199e3b3ab179 100644\n--- a/.github/config/out_of_tree_extensions.cmake\n+++ b/.github/config/out_of_tree_extensions.cmake\n@@ -84,5 +84,6 @@ if (NOT WIN32)\n             LOAD_TESTS DONT_LINK\n             GIT_URL https://github.com/duckdb/substrait\n             GIT_TAG 52ff1cab21e97053999bfeec83d1da976b94ef57\n+            APPLY_PATCHES\n             )\n endif()\ndiff --git a/.github/patches/extensions/substrait/implicit_varchar_cast.patch b/.github/patches/extensions/substrait/implicit_varchar_cast.patch\nnew file mode 100644\nindex 000000000000..8109d13d4ef6\n--- /dev/null\n+++ b/.github/patches/extensions/substrait/implicit_varchar_cast.patch\n@@ -0,0 +1,54 @@\n+diff --git a/src/substrait_extension.cpp b/src/substrait_extension.cpp\n+index c24497f..15a8aab 100644\n+--- a/src/substrait_extension.cpp\n++++ b/src/substrait_extension.cpp\n+@@ -195,6 +195,9 @@ static unique_ptr<FunctionData> SubstraitBind(ClientContext &context, TableFunct\n+                                               vector<LogicalType> &return_types, vector<string> &names, bool is_json) {\n+ \tauto result = make_uniq<FromSubstraitFunctionData>();\n+ \tresult->conn = make_uniq<Connection>(*context.db);\n++\tif (input.inputs[0].IsNull()) {\n++\t\tthrow BinderException(\"from_substrait cannot be called with a NULL parameter\");\n++\t}\n+ \tstring serialized = input.inputs[0].GetValueUnsafe<string>();\n+ \tresult->plan = SubstraitPlanToDuckDBRel(*result->conn, serialized, is_json);\n+ \tfor (auto &column : result->plan->Columns()) {\n+diff --git a/test/sql/test_substrait.test b/test/sql/test_substrait.test\n+index 0fdd4cc..d7ce259 100644\n+--- a/test/sql/test_substrait.test\n++++ b/test/sql/test_substrait.test\n+@@ -72,9 +72,6 @@ syntax error at or near \"NULL\"\n+ statement error\n+ CALL from_substrait(NULL)\n+ ----\n+-No function matches the given name and argument types 'from_substrait(INTEGER)'\n+-\n+-\n+ \n+ # Should fail with Invalid Query\n+ statement error\n+@@ -91,7 +88,7 @@ Catalog Error: Table with name t does not exist!\n+ statement error\n+ CALL from_substrait('ongezoutennoten')\n+ ----\n+-No function matches the given name and argument types 'from_substrait(VARCHAR)'\n++No function matches\n+ \n+ # Should fail on empty plan\n+ statement error\n+diff --git a/test/sql/test_substrait_function_name.test b/test/sql/test_substrait_function_name.test\n+index 50c37ae..159e01a 100644\n+--- a/test/sql/test_substrait_function_name.test\n++++ b/test/sql/test_substrait_function_name.test\n+@@ -35,10 +35,10 @@ statement ok\n+ CALL get_substrait('SELECT abs(i) FROM ints');\n+ \n+ statement ok\n+-CALL get_substrait('SELECT prefix(i, ''1'') FROM ints');\n++CALL get_substrait('SELECT prefix(v, ''1'') FROM varchars');\n+ \n+ statement ok\n+-CALL get_substrait('SELECT suffix(i, ''3'') FROM ints');\n++CALL get_substrait('SELECT suffix(v, ''3'') FROM varchars');\n+ \n+ statement ok\n+ CALL get_substrait('SELECT substr(v, 1, 1) FROM varchars');\ndiff --git a/extension/inet/inet_extension.cpp b/extension/inet/inet_extension.cpp\nindex 1a7825795f96..f477ecb916a2 100644\n--- a/extension/inet/inet_extension.cpp\n+++ b/extension/inet/inet_extension.cpp\n@@ -28,8 +28,8 @@ void InetExtension::Load(DuckDB &db) {\n \tExtensionUtil::RegisterType(*db.instance, INET_TYPE_NAME, inet_type);\n \n \t// add the casts to and from INET type\n-\tExtensionUtil::RegisterCastFunction(*db.instance, LogicalType::VARCHAR, inet_type, INetFunctions::CastVarcharToINET,\n-\t                                    100);\n+\tExtensionUtil::RegisterCastFunction(*db.instance, LogicalType::VARCHAR, inet_type,\n+\t                                    INetFunctions::CastVarcharToINET);\n \tExtensionUtil::RegisterCastFunction(*db.instance, inet_type, LogicalType::VARCHAR,\n \t                                    INetFunctions::CastINETToVarchar);\n \ndiff --git a/extension/json/json_extension.cpp b/extension/json/json_extension.cpp\nindex 8b73fbfdb971..88671d30e361 100644\n--- a/extension/json/json_extension.cpp\n+++ b/extension/json/json_extension.cpp\n@@ -19,7 +19,7 @@ namespace duckdb {\n static DefaultMacro json_macros[] = {\n     {DEFAULT_SCHEMA, \"json_group_array\", {\"x\", nullptr}, \"to_json(list(x))\"},\n     {DEFAULT_SCHEMA, \"json_group_object\", {\"name\", \"value\", nullptr}, \"to_json(map(list(name), list(value)))\"},\n-    {DEFAULT_SCHEMA, \"json_group_structure\", {\"x\", nullptr}, \"json_structure(json_group_array(x))->0\"},\n+    {DEFAULT_SCHEMA, \"json_group_structure\", {\"x\", nullptr}, \"json_structure(json_group_array(x))->'0'\"},\n     {DEFAULT_SCHEMA, \"json\", {\"x\", nullptr}, \"json_extract(x, '$')\"},\n     {nullptr, nullptr, {nullptr}, nullptr}};\n \ndiff --git a/extension/json/json_functions.cpp b/extension/json/json_functions.cpp\nindex 5917052a5ee1..393b2b068cc6 100644\n--- a/extension/json/json_functions.cpp\n+++ b/extension/json/json_functions.cpp\n@@ -54,7 +54,7 @@ unique_ptr<FunctionData> JSONReadFunctionData::Bind(ClientContext &context, Scal\n                                                     vector<unique_ptr<Expression>> &arguments) {\n \tD_ASSERT(bound_function.arguments.size() == 2);\n \tbool constant = false;\n-\tstring path = \"\";\n+\tstring path;\n \tsize_t len = 0;\n \tJSONPathType path_type = JSONPathType::REGULAR;\n \tif (arguments[1]->IsFoldable()) {\n@@ -62,6 +62,7 @@ unique_ptr<FunctionData> JSONReadFunctionData::Bind(ClientContext &context, Scal\n \t\tconst auto path_val = ExpressionExecutor::EvaluateScalar(context, *arguments[1]);\n \t\tpath_type = CheckPath(path_val, path, len);\n \t}\n+\tbound_function.arguments[1] = LogicalType::VARCHAR;\n \tif (path_type == JSONCommon::JSONPathType::WILDCARD) {\n \t\tbound_function.return_type = LogicalType::LIST(bound_function.return_type);\n \t}\ndiff --git a/extension/json/json_functions/json_extract.cpp b/extension/json/json_functions/json_extract.cpp\nindex eb9e242d7a5d..59daa49ccc8e 100644\n--- a/extension/json/json_functions/json_extract.cpp\n+++ b/extension/json/json_functions/json_extract.cpp\n@@ -28,6 +28,8 @@ static void ExtractStringManyFunction(DataChunk &args, ExpressionState &state, V\n }\n \n static void GetExtractFunctionsInternal(ScalarFunctionSet &set, const LogicalType &input_type) {\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::BIGINT}, LogicalType::JSON(), ExtractFunction,\n+\t                               JSONReadFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n \tset.AddFunction(ScalarFunction({input_type, LogicalType::VARCHAR}, LogicalType::JSON(), ExtractFunction,\n \t                               JSONReadFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n \tset.AddFunction(ScalarFunction({input_type, LogicalType::LIST(LogicalType::VARCHAR)},\n@@ -44,6 +46,8 @@ ScalarFunctionSet JSONFunctions::GetExtractFunction() {\n }\n \n static void GetExtractStringFunctionsInternal(ScalarFunctionSet &set, const LogicalType &input_type) {\n+\tset.AddFunction(ScalarFunction({input_type, LogicalType::BIGINT}, LogicalType::VARCHAR, ExtractStringFunction,\n+\t                               JSONReadFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n \tset.AddFunction(ScalarFunction({input_type, LogicalType::VARCHAR}, LogicalType::VARCHAR, ExtractStringFunction,\n \t                               JSONReadFunctionData::Bind, nullptr, nullptr, JSONFunctionLocalState::Init));\n \tset.AddFunction(ScalarFunction({input_type, LogicalType::LIST(LogicalType::VARCHAR)},\ndiff --git a/src/catalog/default/default_functions.cpp b/src/catalog/default/default_functions.cpp\nindex e1c3d75e799d..cedef30b4bd4 100644\n--- a/src/catalog/default/default_functions.cpp\n+++ b/src/catalog/default/default_functions.cpp\n@@ -92,7 +92,7 @@ static DefaultMacro internal_macros[] = {\n \t{DEFAULT_SCHEMA, \"array_pop_front\", {\"arr\", nullptr}, \"arr[2:]\"},\n \t{DEFAULT_SCHEMA, \"array_push_back\", {\"arr\", \"e\", nullptr}, \"list_concat(arr, list_value(e))\"},\n \t{DEFAULT_SCHEMA, \"array_push_front\", {\"arr\", \"e\", nullptr}, \"list_concat(list_value(e), arr)\"},\n-\t{DEFAULT_SCHEMA, \"array_to_string\", {\"arr\", \"sep\", nullptr}, \"list_aggr(arr, 'string_agg', sep)\"},\n+\t{DEFAULT_SCHEMA, \"array_to_string\", {\"arr\", \"sep\", nullptr}, \"list_aggr(arr::varchar[], 'string_agg', sep)\"},\n \t{DEFAULT_SCHEMA, \"generate_subscripts\", {\"arr\", \"dim\", nullptr}, \"unnest(generate_series(1, array_length(arr, dim)))\"},\n \t{DEFAULT_SCHEMA, \"fdiv\", {\"x\", \"y\", nullptr}, \"floor(x/y)\"},\n \t{DEFAULT_SCHEMA, \"fmod\", {\"x\", \"y\", nullptr}, \"(x-y*floor(x/y))\"},\ndiff --git a/src/common/enum_util.cpp b/src/common/enum_util.cpp\nindex b6b7fc958a93..d7fdd51041b7 100644\n--- a/src/common/enum_util.cpp\n+++ b/src/common/enum_util.cpp\n@@ -3127,6 +3127,8 @@ const char* EnumUtil::ToChars<LogicalTypeId>(LogicalTypeId value) {\n \t\treturn \"TIME WITH TIME ZONE\";\n \tcase LogicalTypeId::BIT:\n \t\treturn \"BIT\";\n+\tcase LogicalTypeId::STRING_LITERAL:\n+\t\treturn \"STRING_LITERAL\";\n \tcase LogicalTypeId::UHUGEINT:\n \t\treturn \"UHUGEINT\";\n \tcase LogicalTypeId::HUGEINT:\n@@ -3252,6 +3254,9 @@ LogicalTypeId EnumUtil::FromString<LogicalTypeId>(const char *value) {\n \tif (StringUtil::Equals(value, \"BIT\")) {\n \t\treturn LogicalTypeId::BIT;\n \t}\n+\tif (StringUtil::Equals(value, \"STRING_LITERAL\")) {\n+\t\treturn LogicalTypeId::STRING_LITERAL;\n+\t}\n \tif (StringUtil::Equals(value, \"UHUGEINT\")) {\n \t\treturn LogicalTypeId::UHUGEINT;\n \t}\ndiff --git a/src/common/multi_file_reader.cpp b/src/common/multi_file_reader.cpp\nindex 15b4d30ccc85..bbb59705e29f 100644\n--- a/src/common/multi_file_reader.cpp\n+++ b/src/common/multi_file_reader.cpp\n@@ -377,8 +377,7 @@ void UnionByName::CombineUnionTypes(const vector<string> &col_names, const vecto\n \t\tif (union_find != union_names_map.end()) {\n \t\t\t// given same name , union_col's type must compatible with col's type\n \t\t\tauto &current_type = union_col_types[union_find->second];\n-\t\t\tLogicalType compatible_type;\n-\t\t\tcompatible_type = LogicalType::MaxLogicalType(current_type, sql_types[col]);\n+\t\t\tauto compatible_type = LogicalType::ForceMaxLogicalType(current_type, sql_types[col]);\n \t\t\tunion_col_types[union_find->second] = compatible_type;\n \t\t} else {\n \t\t\tunion_names_map[col_names[col]] = union_col_names.size();\ndiff --git a/src/common/types.cpp b/src/common/types.cpp\nindex 0623160f507d..2a2cc716eab9 100644\n--- a/src/common/types.cpp\n+++ b/src/common/types.cpp\n@@ -27,6 +27,7 @@\n #include \"duckdb/main/database_manager.hpp\"\n #include \"duckdb/parser/keyword_helper.hpp\"\n #include \"duckdb/parser/parser.hpp\"\n+#include \"duckdb/main/config.hpp\"\n \n #include <cmath>\n \n@@ -149,6 +150,7 @@ PhysicalType LogicalType::GetInternalType() {\n \tcase LogicalTypeId::ANY:\n \tcase LogicalTypeId::INVALID:\n \tcase LogicalTypeId::UNKNOWN:\n+\tcase LogicalTypeId::STRING_LITERAL:\n \t\treturn PhysicalType::INVALID;\n \tcase LogicalTypeId::USER:\n \t\treturn PhysicalType::UNKNOWN;\n@@ -675,22 +677,6 @@ static LogicalType CombineNumericTypes(const LogicalType &left, const LogicalTyp\n \t\t// arrange it so the left type is smaller to limit the number of options we need to check\n \t\treturn CombineNumericTypes(right, left);\n \t}\n-\tif (CastRules::ImplicitCast(left, right) >= 0) {\n-\t\t// we can implicitly cast left to right, return right\n-\t\t//! Depending on the type, we might need to grow the `width` of the DECIMAL type\n-\t\tif (right.id() == LogicalTypeId::DECIMAL) {\n-\t\t\treturn DecimalSizeCheck(left, right);\n-\t\t}\n-\t\treturn right;\n-\t}\n-\tif (CastRules::ImplicitCast(right, left) >= 0) {\n-\t\t// we can implicitly cast right to left, return left\n-\t\t//! Depending on the type, we might need to grow the `width` of the DECIMAL type\n-\t\tif (left.id() == LogicalTypeId::DECIMAL) {\n-\t\t\treturn DecimalSizeCheck(right, left);\n-\t\t}\n-\t\treturn left;\n-\t}\n \t// we can't cast implicitly either way and types are not equal\n \t// this happens when left is signed and right is unsigned\n \t// e.g. INTEGER and UINTEGER\n@@ -717,52 +703,95 @@ static LogicalType CombineNumericTypes(const LogicalType &left, const LogicalTyp\n \tthrow InternalException(\"Cannot combine these numeric types (%s & %s)\", left.ToString(), right.ToString());\n }\n \n-LogicalType LogicalType::MaxLogicalType(const LogicalType &left, const LogicalType &right) {\n-\t// If either side is JSON, pick the other side, since each more specific type is more performant than JSON,\n-\t// except for VARCHAR, because the JSON to VARCHAR cast is a special case\n-\tif (left.IsJSONType() && right.id() != LogicalTypeId::SQLNULL && right.id() != LogicalTypeId::VARCHAR) {\n-\t\treturn right;\n-\t} else if (right.IsJSONType() && left.id() != LogicalTypeId::SQLNULL && left.id() != LogicalTypeId::VARCHAR) {\n-\t\treturn left;\n+static LogicalType ReturnType(const LogicalType &type) {\n+\tif (type.id() == LogicalTypeId::STRING_LITERAL) {\n+\t\treturn LogicalType::VARCHAR;\n \t}\n+\treturn type;\n+}\n \n-\t// we always prefer aliased types\n-\tif (!left.GetAlias().empty()) {\n-\t\treturn left;\n+template <class OP>\n+static bool CombineUnequalTypes(const LogicalType &left, const LogicalType &right, LogicalType &result) {\n+\t// left and right are not equal\n+\t// for enums, match the varchar rules\n+\tif (left.id() == LogicalTypeId::ENUM) {\n+\t\treturn OP::Operation(LogicalType::VARCHAR, right, result);\n+\t} else if (right.id() == LogicalTypeId::ENUM) {\n+\t\treturn OP::Operation(left, LogicalType::VARCHAR, result);\n+\t}\n+\t// NULL/string literals/unknown (parameter) types always take the other type\n+\tLogicalTypeId other_types[] = {LogicalTypeId::UNKNOWN, LogicalTypeId::SQLNULL, LogicalTypeId::STRING_LITERAL};\n+\tfor (auto &other_type : other_types) {\n+\t\tif (left.id() == other_type) {\n+\t\t\tresult = ReturnType(right);\n+\t\t\treturn true;\n+\t\t} else if (right.id() == other_type) {\n+\t\t\tresult = ReturnType(left);\n+\t\t\treturn true;\n+\t\t}\n \t}\n-\tif (!right.GetAlias().empty()) {\n-\t\treturn right;\n+\n+\t// for other types - use implicit cast rules to check if we can combine the types\n+\tauto left_to_right_cost = CastRules::ImplicitCast(left, right);\n+\tauto right_to_left_cost = CastRules::ImplicitCast(right, left);\n+\tif (left_to_right_cost >= 0 && (left_to_right_cost < right_to_left_cost || right_to_left_cost < 0)) {\n+\t\t// we can implicitly cast left to right, return right\n+\t\t//! Depending on the type, we might need to grow the `width` of the DECIMAL type\n+\t\tif (right.id() == LogicalTypeId::DECIMAL) {\n+\t\t\tresult = DecimalSizeCheck(left, right);\n+\t\t} else {\n+\t\t\tresult = right;\n+\t\t}\n+\t\treturn true;\n \t}\n-\tif (left.id() != right.id() && left.IsNumeric() && right.IsNumeric()) {\n-\t\treturn CombineNumericTypes(left, right);\n-\t} else if (left.id() == LogicalTypeId::UNKNOWN) {\n-\t\treturn right;\n-\t} else if (right.id() == LogicalTypeId::UNKNOWN) {\n-\t\treturn left;\n-\t} else if ((right.id() == LogicalTypeId::ENUM || left.id() == LogicalTypeId::ENUM) && right.id() != left.id()) {\n-\t\t// if one is an enum and the other is not, compare strings, not enums\n-\t\t// see https://github.com/duckdb/duckdb/issues/8561\n-\t\treturn LogicalTypeId::VARCHAR;\n-\t} else if (left.id() < right.id()) {\n-\t\treturn right;\n+\tif (right_to_left_cost >= 0) {\n+\t\t// we can implicitly cast right to left, return left\n+\t\t//! Depending on the type, we might need to grow the `width` of the DECIMAL type\n+\t\tif (left.id() == LogicalTypeId::DECIMAL) {\n+\t\t\tresult = DecimalSizeCheck(right, left);\n+\t\t} else {\n+\t\t\tresult = left;\n+\t\t}\n+\t\treturn true;\n \t}\n-\tif (right.id() < left.id()) {\n-\t\treturn left;\n+\t// for unsigned/signed comparisons we have a few fallbacks\n+\tif (left.IsNumeric() && right.IsNumeric()) {\n+\t\tresult = CombineNumericTypes(left, right);\n+\t\treturn true;\n+\t}\n+\tif (left.id() == LogicalTypeId::BOOLEAN && right.IsIntegral()) {\n+\t\tresult = right;\n+\t\treturn true;\n+\t}\n+\tif (right.id() == LogicalTypeId::BOOLEAN && left.IsIntegral()) {\n+\t\tresult = left;\n+\t\treturn true;\n \t}\n+\treturn false;\n+}\n+\n+template <class OP>\n+static bool CombineEqualTypes(const LogicalType &left, const LogicalType &right, LogicalType &result) {\n \t// Since both left and right are equal we get the left type as our type_id for checks\n \tauto type_id = left.id();\n-\tif (type_id == LogicalTypeId::ENUM) {\n+\tswitch (type_id) {\n+\tcase LogicalTypeId::STRING_LITERAL:\n+\t\t// two string literals convert to varchar\n+\t\tresult = LogicalType::VARCHAR;\n+\t\treturn true;\n+\tcase LogicalTypeId::ENUM:\n \t\t// If both types are different ENUMs we do a string comparison.\n-\t\treturn left == right ? left : LogicalType::VARCHAR;\n-\t}\n-\tif (type_id == LogicalTypeId::VARCHAR) {\n+\t\tresult = left == right ? left : LogicalType::VARCHAR;\n+\t\treturn true;\n+\tcase LogicalTypeId::VARCHAR:\n \t\t// varchar: use type that has collation (if any)\n \t\tif (StringType::GetCollation(right).empty()) {\n-\t\t\treturn left;\n+\t\t\tresult = left;\n+\t\t} else {\n+\t\t\tresult = right;\n \t\t}\n-\t\treturn right;\n-\t}\n-\tif (type_id == LogicalTypeId::DECIMAL) {\n+\t\treturn true;\n+\tcase LogicalTypeId::DECIMAL: {\n \t\t// unify the width/scale so that the resulting decimal always fits\n \t\t// \"width - scale\" gives us the number of digits on the left side of the decimal point\n \t\t// \"scale\" gives us the number of digits allowed on the right of the decimal point\n@@ -777,52 +806,227 @@ LogicalType LogicalType::MaxLogicalType(const LogicalType &left, const LogicalTy\n \t\t\twidth = DecimalType::MaxWidth();\n \t\t\tscale = width - extra_width;\n \t\t}\n-\t\treturn LogicalType::DECIMAL(width, scale);\n+\t\tresult = LogicalType::DECIMAL(width, scale);\n+\t\treturn true;\n \t}\n-\tif (type_id == LogicalTypeId::LIST) {\n+\tcase LogicalTypeId::LIST: {\n \t\t// list: perform max recursively on child type\n-\t\tauto new_child = MaxLogicalType(ListType::GetChildType(left), ListType::GetChildType(right));\n-\t\treturn LogicalType::LIST(new_child);\n+\t\tLogicalType new_child;\n+\t\tif (!OP::Operation(ListType::GetChildType(left), ListType::GetChildType(right), new_child)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tresult = LogicalType::LIST(new_child);\n+\t\treturn true;\n \t}\n-\tif (type_id == LogicalTypeId::ARRAY) {\n-\t\tauto new_child = MaxLogicalType(ArrayType::GetChildType(left), ArrayType::GetChildType(right));\n+\tcase LogicalTypeId::ARRAY: {\n+\t\tLogicalType new_child;\n+\t\tif (!OP::Operation(ArrayType::GetChildType(left), ArrayType::GetChildType(right), new_child)) {\n+\t\t\treturn false;\n+\t\t}\n \t\tauto new_size = MaxValue(ArrayType::GetSize(left), ArrayType::GetSize(right));\n-\t\treturn LogicalType::ARRAY(new_child, new_size);\n+\t\tresult = LogicalType::ARRAY(new_child, new_size);\n+\t\treturn true;\n \t}\n-\tif (type_id == LogicalTypeId::MAP) {\n-\t\t// list: perform max recursively on child type\n-\t\tauto new_child = MaxLogicalType(ListType::GetChildType(left), ListType::GetChildType(right));\n-\t\treturn LogicalType::MAP(new_child);\n+\tcase LogicalTypeId::MAP: {\n+\t\t// map: perform max recursively on child type\n+\t\tLogicalType new_child;\n+\t\tif (!OP::Operation(ListType::GetChildType(left), ListType::GetChildType(right), new_child)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tresult = LogicalType::MAP(new_child);\n+\t\treturn true;\n \t}\n-\tif (type_id == LogicalTypeId::STRUCT) {\n-\t\t// struct: perform recursively\n+\tcase LogicalTypeId::STRUCT: {\n+\t\t// struct: perform recursively on each child\n \t\tauto &left_child_types = StructType::GetChildTypes(left);\n \t\tauto &right_child_types = StructType::GetChildTypes(right);\n \t\tif (left_child_types.size() != right_child_types.size()) {\n-\t\t\t// child types are not of equal size, we can't cast anyway\n-\t\t\t// just return the left child\n-\t\t\treturn left;\n+\t\t\t// child types are not of equal size, we can't cast\n+\t\t\t// return false\n+\t\t\treturn false;\n \t\t}\n \t\tchild_list_t<LogicalType> child_types;\n \t\tfor (idx_t i = 0; i < left_child_types.size(); i++) {\n-\t\t\tauto child_type = MaxLogicalType(left_child_types[i].second, right_child_types[i].second);\n+\t\t\tLogicalType child_type;\n+\t\t\tif (!OP::Operation(left_child_types[i].second, right_child_types[i].second, child_type)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t\tchild_types.emplace_back(left_child_types[i].first, std::move(child_type));\n \t\t}\n-\n-\t\treturn LogicalType::STRUCT(child_types);\n+\t\tresult = LogicalType::STRUCT(child_types);\n+\t\treturn true;\n \t}\n-\tif (type_id == LogicalTypeId::UNION) {\n+\tcase LogicalTypeId::UNION: {\n \t\tauto left_member_count = UnionType::GetMemberCount(left);\n \t\tauto right_member_count = UnionType::GetMemberCount(right);\n \t\tif (left_member_count != right_member_count) {\n \t\t\t// return the \"larger\" type, with the most members\n-\t\t\treturn left_member_count > right_member_count ? left : right;\n+\t\t\tresult = left_member_count > right_member_count ? left : right;\n+\t\t\treturn true;\n \t\t}\n \t\t// otherwise, keep left, don't try to meld the two together.\n+\t\tresult = left;\n+\t\treturn true;\n+\t}\n+\tdefault:\n+\t\tresult = left;\n+\t\treturn true;\n+\t}\n+}\n+\n+template <class OP>\n+bool TryGetMaxLogicalTypeInternal(const LogicalType &left, const LogicalType &right, LogicalType &result) {\n+\t// we always prefer aliased types\n+\tif (!left.GetAlias().empty()) {\n+\t\tresult = left;\n+\t\treturn true;\n+\t}\n+\tif (!right.GetAlias().empty()) {\n+\t\tresult = right;\n+\t\treturn true;\n+\t}\n+\tif (left.id() != right.id()) {\n+\t\treturn CombineUnequalTypes<OP>(left, right, result);\n+\t} else {\n+\t\treturn CombineEqualTypes<OP>(left, right, result);\n+\t}\n+}\n+\n+struct TryGetTypeOperation {\n+\tstatic bool Operation(const LogicalType &left, const LogicalType &right, LogicalType &result) {\n+\t\treturn TryGetMaxLogicalTypeInternal<TryGetTypeOperation>(left, right, result);\n+\t}\n+};\n+\n+struct ForceGetTypeOperation {\n+\tstatic bool Operation(const LogicalType &left, const LogicalType &right, LogicalType &result) {\n+\t\tresult = LogicalType::ForceMaxLogicalType(left, right);\n+\t\treturn true;\n+\t}\n+};\n+\n+bool LogicalType::TryGetMaxLogicalType(ClientContext &context, const LogicalType &left, const LogicalType &right,\n+                                       LogicalType &result) {\n+\tif (DBConfig::GetConfig(context).options.old_implicit_casting) {\n+\t\tresult = LogicalType::ForceMaxLogicalType(left, right);\n+\t\treturn true;\n+\t}\n+\treturn TryGetMaxLogicalTypeInternal<TryGetTypeOperation>(left, right, result);\n+}\n+\n+static idx_t GetLogicalTypeScore(const LogicalType &type) {\n+\treturn idx_t(type.id());\n+\tswitch (type.id()) {\n+\tcase LogicalTypeId::INVALID:\n+\tcase LogicalTypeId::SQLNULL:\n+\tcase LogicalTypeId::UNKNOWN:\n+\tcase LogicalTypeId::ANY:\n+\tcase LogicalTypeId::STRING_LITERAL:\n+\t\treturn 0;\n+\t// numerics\n+\tcase LogicalTypeId::BOOLEAN:\n+\t\treturn 10;\n+\tcase LogicalTypeId::UTINYINT:\n+\t\treturn 11;\n+\tcase LogicalTypeId::TINYINT:\n+\t\treturn 12;\n+\tcase LogicalTypeId::USMALLINT:\n+\t\treturn 13;\n+\tcase LogicalTypeId::SMALLINT:\n+\t\treturn 14;\n+\tcase LogicalTypeId::UINTEGER:\n+\t\treturn 15;\n+\tcase LogicalTypeId::INTEGER:\n+\t\treturn 16;\n+\tcase LogicalTypeId::UBIGINT:\n+\t\treturn 17;\n+\tcase LogicalTypeId::BIGINT:\n+\t\treturn 18;\n+\tcase LogicalTypeId::UHUGEINT:\n+\t\treturn 19;\n+\tcase LogicalTypeId::HUGEINT:\n+\t\treturn 20;\n+\tcase LogicalTypeId::DECIMAL:\n+\t\treturn 21;\n+\tcase LogicalTypeId::FLOAT:\n+\t\treturn 22;\n+\tcase LogicalTypeId::DOUBLE:\n+\t\treturn 23;\n+\t// date/time/timestamp\n+\tcase LogicalTypeId::TIME:\n+\tcase LogicalTypeId::TIME_TZ:\n+\t\treturn 50;\n+\tcase LogicalTypeId::DATE:\n+\t\treturn 51;\n+\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\treturn 52;\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\treturn 53;\n+\tcase LogicalTypeId::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\t\treturn 54;\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\treturn 55;\n+\tcase LogicalTypeId::INTERVAL:\n+\t\treturn 56;\n+\t// text/character strings\n+\tcase LogicalTypeId::CHAR:\n+\t\treturn 75;\n+\tcase LogicalTypeId::VARCHAR:\n+\t\treturn 77;\n+\tcase LogicalTypeId::ENUM:\n+\t\treturn 78;\n+\t// blob/complex types\n+\tcase LogicalTypeId::BIT:\n+\t\treturn 100;\n+\tcase LogicalTypeId::BLOB:\n+\t\treturn 101;\n+\tcase LogicalTypeId::UUID:\n+\t\treturn 102;\n+\t// nested types\n+\tcase LogicalTypeId::STRUCT:\n+\t\treturn 125;\n+\tcase LogicalTypeId::LIST:\n+\tcase LogicalTypeId::ARRAY:\n+\t\treturn 126;\n+\tcase LogicalTypeId::MAP:\n+\t\treturn 127;\n+\tcase LogicalTypeId::UNION:\n+\tcase LogicalTypeId::TABLE:\n+\t\treturn 150;\n+\t// weirdo types\n+\tcase LogicalTypeId::LAMBDA:\n+\tcase LogicalTypeId::AGGREGATE_STATE:\n+\tcase LogicalTypeId::POINTER:\n+\tcase LogicalTypeId::VALIDITY:\n+\tcase LogicalTypeId::USER:\n+\t\tbreak;\n+\t}\n+\treturn 1000;\n+}\n+\n+LogicalType LogicalType::ForceMaxLogicalType(const LogicalType &left, const LogicalType &right) {\n+\tLogicalType result;\n+\tif (TryGetMaxLogicalTypeInternal<ForceGetTypeOperation>(left, right, result)) {\n+\t\treturn result;\n+\t}\n+\t// we prefer the type with the highest score\n+\tauto left_score = GetLogicalTypeScore(left);\n+\tauto right_score = GetLogicalTypeScore(right);\n+\tif (left_score < right_score) {\n+\t\treturn right;\n+\t} else {\n \t\treturn left;\n \t}\n-\t// types are equal but no extra specifier: just return the type\n-\treturn left;\n+}\n+\n+LogicalType LogicalType::MaxLogicalType(ClientContext &context, const LogicalType &left, const LogicalType &right) {\n+\tLogicalType result;\n+\tif (!TryGetMaxLogicalType(context, left, right, result)) {\n+\t\tthrow NotImplementedException(\"Cannot combine types %s and %s - an explicit cast is required\", left.ToString(),\n+\t\t                              right.ToString());\n+\t}\n+\treturn result;\n }\n \n void LogicalType::Verify() const {\ndiff --git a/src/common/value_operations/comparison_operations.cpp b/src/common/value_operations/comparison_operations.cpp\nindex d4771a0de3e2..b2d59b0b579a 100644\n--- a/src/common/value_operations/comparison_operations.cpp\n+++ b/src/common/value_operations/comparison_operations.cpp\n@@ -103,7 +103,7 @@ static bool TemplatedBooleanOperation(const Value &left, const Value &right) {\n \t\tValue left_copy = left;\n \t\tValue right_copy = right;\n \n-\t\tLogicalType comparison_type = BoundComparisonExpression::BindComparison(left_type, right_type);\n+\t\tauto comparison_type = LogicalType::ForceMaxLogicalType(left_type, right_type);\n \t\tif (!left_copy.DefaultTryCastAs(comparison_type) || !right_copy.DefaultTryCastAs(comparison_type)) {\n \t\t\treturn false;\n \t\t}\ndiff --git a/src/core_functions/aggregate/distributive/approx_count.cpp b/src/core_functions/aggregate/distributive/approx_count.cpp\nindex 9d1d386bc7bf..ec1555c38ca2 100644\n--- a/src/core_functions/aggregate/distributive/approx_count.cpp\n+++ b/src/core_functions/aggregate/distributive/approx_count.cpp\n@@ -110,6 +110,12 @@ static void ApproxCountDistinctUpdateFunction(Vector inputs[], AggregateInputDat\n \tHyperLogLog::AddToLogs(vdata, count, indices, counts, reinterpret_cast<HyperLogLog ***>(states), sdata.sel);\n }\n \n+unique_ptr<FunctionData> ApproxCountDistinctAnyBind(ClientContext &context, AggregateFunction &function,\n+                                                    vector<unique_ptr<Expression>> &arguments) {\n+\tfunction.arguments[0] = LogicalType::VARCHAR;\n+\treturn nullptr;\n+}\n+\n AggregateFunction GetApproxCountDistinctFunction(const LogicalType &input_type) {\n \tauto fun = AggregateFunction(\n \t    {input_type}, LogicalTypeId::BIGINT, AggregateFunction::StateSize<ApproxDistinctCountState>,\n@@ -117,7 +123,8 @@ AggregateFunction GetApproxCountDistinctFunction(const LogicalType &input_type)\n \t    ApproxCountDistinctUpdateFunction,\n \t    AggregateFunction::StateCombine<ApproxDistinctCountState, ApproxCountDistinctFunction>,\n \t    AggregateFunction::StateFinalize<ApproxDistinctCountState, int64_t, ApproxCountDistinctFunction>,\n-\t    ApproxCountDistinctSimpleUpdateFunction, nullptr,\n+\t    ApproxCountDistinctSimpleUpdateFunction,\n+\t    input_type.id() == LogicalTypeId::ANY ? ApproxCountDistinctAnyBind : nullptr,\n \t    AggregateFunction::StateDestroy<ApproxDistinctCountState, ApproxCountDistinctFunction>);\n \tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \treturn fun;\n@@ -136,10 +143,10 @@ AggregateFunctionSet ApproxCountDistinctFun::GetFunctions() {\n \tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::HUGEINT));\n \tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::FLOAT));\n \tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::DOUBLE));\n-\tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::VARCHAR));\n \tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::TIMESTAMP));\n \tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::TIMESTAMP_TZ));\n \tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::BLOB));\n+\tapprox_count.AddFunction(GetApproxCountDistinctFunction(LogicalType::ANY));\n \treturn approx_count;\n }\n \ndiff --git a/src/core_functions/aggregate/distributive/arg_min_max.cpp b/src/core_functions/aggregate/distributive/arg_min_max.cpp\nindex ef1c714c541c..c6c1f8f6525c 100644\n--- a/src/core_functions/aggregate/distributive/arg_min_max.cpp\n+++ b/src/core_functions/aggregate/distributive/arg_min_max.cpp\n@@ -156,9 +156,7 @@ struct ArgMinMaxBase {\n \n \tstatic unique_ptr<FunctionData> Bind(ClientContext &context, AggregateFunction &function,\n \t                                     vector<unique_ptr<Expression>> &arguments) {\n-\t\tauto result_type =\n-\t\t    BoundComparisonExpression::BindComparison(arguments[0]->return_type, arguments[1]->return_type);\n-\t\tExpressionBinder::PushCollation(context, arguments[1], result_type, false);\n+\t\tExpressionBinder::PushCollation(context, arguments[1], arguments[1]->return_type, false);\n \t\tfunction.arguments[0] = arguments[0]->return_type;\n \t\tfunction.return_type = arguments[0]->return_type;\n \t\treturn nullptr;\ndiff --git a/src/core_functions/aggregate/distributive/entropy.cpp b/src/core_functions/aggregate/distributive/entropy.cpp\nindex b965b8119f5d..71cd6bf6056a 100644\n--- a/src/core_functions/aggregate/distributive/entropy.cpp\n+++ b/src/core_functions/aggregate/distributive/entropy.cpp\n@@ -120,6 +120,12 @@ AggregateFunction GetEntropyFunction(const LogicalType &input_type, const Logica\n \treturn fun;\n }\n \n+static unique_ptr<FunctionData> EntropyVarcharBind(ClientContext &context, AggregateFunction &function,\n+                                                   vector<unique_ptr<Expression>> &arguments) {\n+\tfunction.arguments[0] = LogicalType::VARCHAR;\n+\treturn nullptr;\n+}\n+\n AggregateFunction GetEntropyFunctionInternal(PhysicalType type) {\n \tswitch (type) {\n \tcase PhysicalType::UINT16:\n@@ -146,10 +152,13 @@ AggregateFunction GetEntropyFunctionInternal(PhysicalType type) {\n \tcase PhysicalType::DOUBLE:\n \t\treturn AggregateFunction::UnaryAggregateDestructor<EntropyState<double>, double, double, EntropyFunction>(\n \t\t    LogicalType::DOUBLE, LogicalType::DOUBLE);\n-\tcase PhysicalType::VARCHAR:\n-\t\treturn AggregateFunction::UnaryAggregateDestructor<EntropyState<string>, string_t, double,\n-\t\t                                                   EntropyFunctionString>(LogicalType::VARCHAR,\n-\t\t                                                                          LogicalType::DOUBLE);\n+\tcase PhysicalType::VARCHAR: {\n+\t\tAggregateFunction result =\n+\t\t    AggregateFunction::UnaryAggregateDestructor<EntropyState<string>, string_t, double, EntropyFunctionString>(\n+\t\t        LogicalType::ANY, LogicalType::DOUBLE);\n+\t\tresult.bind = EntropyVarcharBind;\n+\t\treturn result;\n+\t}\n \n \tdefault:\n \t\tthrow InternalException(\"Unimplemented approximate_count aggregate\");\ndiff --git a/src/core_functions/aggregate/distributive/string_agg.cpp b/src/core_functions/aggregate/distributive/string_agg.cpp\nindex b09c52fc04e6..4c6e2b48a2f5 100644\n--- a/src/core_functions/aggregate/distributive/string_agg.cpp\n+++ b/src/core_functions/aggregate/distributive/string_agg.cpp\n@@ -119,6 +119,7 @@ struct StringAggFunction {\n \n unique_ptr<FunctionData> StringAggBind(ClientContext &context, AggregateFunction &function,\n                                        vector<unique_ptr<Expression>> &arguments) {\n+\tfunction.arguments[0] = LogicalType::VARCHAR;\n \tif (arguments.size() == 1) {\n \t\t// single argument: default to comma\n \t\treturn make_uniq<StringAggBindData>(\",\");\n@@ -155,7 +156,7 @@ unique_ptr<FunctionData> StringAggDeserialize(Deserializer &deserializer, Aggreg\n AggregateFunctionSet StringAggFun::GetFunctions() {\n \tAggregateFunctionSet string_agg;\n \tAggregateFunction string_agg_param(\n-\t    {LogicalType::VARCHAR}, LogicalType::VARCHAR, AggregateFunction::StateSize<StringAggState>,\n+\t    {LogicalType::ANY}, LogicalType::VARCHAR, AggregateFunction::StateSize<StringAggState>,\n \t    AggregateFunction::StateInitialize<StringAggState, StringAggFunction>,\n \t    AggregateFunction::UnaryScatterUpdate<StringAggState, string_t, StringAggFunction>,\n \t    AggregateFunction::StateCombine<StringAggState, StringAggFunction>,\ndiff --git a/src/core_functions/aggregate/holistic/mode.cpp b/src/core_functions/aggregate/holistic/mode.cpp\nindex 31f75baa6a18..6ec899bc4cab 100644\n--- a/src/core_functions/aggregate/holistic/mode.cpp\n+++ b/src/core_functions/aggregate/holistic/mode.cpp\n@@ -308,11 +308,21 @@ struct ModeFunction {\n \t}\n };\n \n+static unique_ptr<FunctionData> ModeVarcharBind(ClientContext &context, AggregateFunction &function,\n+                                                vector<unique_ptr<Expression>> &arguments) {\n+\tfunction.arguments[0] = LogicalType::VARCHAR;\n+\treturn nullptr;\n+}\n+\n template <typename INPUT_TYPE, typename KEY_TYPE, typename ASSIGN_OP = ModeAssignmentStandard>\n AggregateFunction GetTypedModeFunction(const LogicalType &type) {\n \tusing STATE = ModeState<KEY_TYPE>;\n \tusing OP = ModeFunction<KEY_TYPE, ASSIGN_OP>;\n-\tauto func = AggregateFunction::UnaryAggregateDestructor<STATE, INPUT_TYPE, INPUT_TYPE, OP>(type, type);\n+\tauto return_type = type.id() == LogicalTypeId::ANY ? LogicalType::VARCHAR : type;\n+\tauto func = AggregateFunction::UnaryAggregateDestructor<STATE, INPUT_TYPE, INPUT_TYPE, OP>(type, return_type);\n+\tif (type.id() == LogicalTypeId::ANY) {\n+\t\tfunc.bind = ModeVarcharBind;\n+\t}\n \tfunc.window = AggregateFunction::UnaryWindow<STATE, INPUT_TYPE, INPUT_TYPE, OP>;\n \treturn func;\n }\n@@ -349,7 +359,7 @@ AggregateFunction GetModeAggregate(const LogicalType &type) {\n \t\treturn GetTypedModeFunction<interval_t, interval_t>(type);\n \n \tcase PhysicalType::VARCHAR:\n-\t\treturn GetTypedModeFunction<string_t, string, ModeAssignmentString>(type);\n+\t\treturn GetTypedModeFunction<string_t, string, ModeAssignmentString>(LogicalType::ANY);\n \n \tdefault:\n \t\tthrow NotImplementedException(\"Unimplemented mode aggregate\");\ndiff --git a/src/core_functions/aggregate/holistic/quantile.cpp b/src/core_functions/aggregate/holistic/quantile.cpp\nindex 2a21079d8933..c50a9756573a 100644\n--- a/src/core_functions/aggregate/holistic/quantile.cpp\n+++ b/src/core_functions/aggregate/holistic/quantile.cpp\n@@ -907,7 +907,8 @@ struct QuantileOperation {\n \n template <class STATE, class INPUT_TYPE, class RESULT_TYPE, class OP>\n static AggregateFunction QuantileListAggregate(const LogicalType &input_type, const LogicalType &child_type) { // NOLINT\n-\tLogicalType result_type = LogicalType::LIST(child_type);\n+\tLogicalType result_type =\n+\t    LogicalType::LIST(child_type.id() == LogicalTypeId::ANY ? LogicalType::VARCHAR : child_type);\n \treturn AggregateFunction(\n \t    {input_type}, result_type, AggregateFunction::StateSize<STATE>, AggregateFunction::StateInitialize<STATE, OP>,\n \t    AggregateFunction::UnaryScatterUpdate<STATE, INPUT_TYPE, OP>, AggregateFunction::StateCombine<STATE, OP>,\n@@ -969,7 +970,8 @@ template <typename INPUT_TYPE, typename SAVED_TYPE>\n AggregateFunction GetTypedDiscreteQuantileAggregateFunction(const LogicalType &type) {\n \tusing STATE = QuantileState<INPUT_TYPE, SAVED_TYPE>;\n \tusing OP = QuantileScalarOperation<true>;\n-\tauto fun = AggregateFunction::UnaryAggregateDestructor<STATE, INPUT_TYPE, INPUT_TYPE, OP>(type, type);\n+\tauto return_type = type.id() == LogicalTypeId::ANY ? LogicalType::VARCHAR : type;\n+\tauto fun = AggregateFunction::UnaryAggregateDestructor<STATE, INPUT_TYPE, INPUT_TYPE, OP>(type, return_type);\n \tfun.window = AggregateFunction::UnaryWindow<STATE, INPUT_TYPE, INPUT_TYPE, OP>;\n \tfun.window_init = OP::WindowInit<STATE, INPUT_TYPE>;\n \treturn fun;\n@@ -1014,8 +1016,7 @@ AggregateFunction GetDiscreteQuantileAggregateFunction(const LogicalType &type)\n \t\treturn GetTypedDiscreteQuantileAggregateFunction<int64_t, int64_t>(type);\n \tcase LogicalTypeId::INTERVAL:\n \t\treturn GetTypedDiscreteQuantileAggregateFunction<interval_t, interval_t>(type);\n-\n-\tcase LogicalTypeId::VARCHAR:\n+\tcase LogicalTypeId::ANY:\n \t\treturn GetTypedDiscreteQuantileAggregateFunction<string_t, std::string>(type);\n \n \tdefault:\n@@ -1137,7 +1138,7 @@ AggregateFunction GetDiscreteQuantileListAggregateFunction(const LogicalType &ty\n \t\treturn GetTypedDiscreteQuantileListAggregateFunction<dtime_t, dtime_t>(type);\n \tcase LogicalTypeId::INTERVAL:\n \t\treturn GetTypedDiscreteQuantileListAggregateFunction<interval_t, interval_t>(type);\n-\tcase LogicalTypeId::VARCHAR:\n+\tcase LogicalTypeId::ANY:\n \t\treturn GetTypedDiscreteQuantileListAggregateFunction<string_t, std::string>(type);\n \tdefault:\n \t\tthrow NotImplementedException(\"Unimplemented discrete quantile list aggregate\");\n@@ -1414,6 +1415,9 @@ struct MedianAbsoluteDeviationOperation : public QuantileOperation {\n \n unique_ptr<FunctionData> BindMedian(ClientContext &context, AggregateFunction &function,\n                                     vector<unique_ptr<Expression>> &arguments) {\n+\tif (function.arguments[0].id() == LogicalTypeId::ANY) {\n+\t\tfunction.arguments[0] = LogicalType::VARCHAR;\n+\t}\n \treturn make_uniq<QuantileBindData>(Value::DECIMAL(int16_t(5), 2, 1));\n }\n \n@@ -1585,6 +1589,7 @@ static bool CanInterpolate(const LogicalType &type) {\n \tswitch (type.id()) {\n \tcase LogicalTypeId::INTERVAL:\n \tcase LogicalTypeId::VARCHAR:\n+\tcase LogicalTypeId::ANY:\n \t\treturn false;\n \tdefault:\n \t\treturn true;\n@@ -1660,7 +1665,7 @@ vector<LogicalType> GetQuantileTypes() {\n \treturn {LogicalType::TINYINT,   LogicalType::SMALLINT, LogicalType::INTEGER,      LogicalType::BIGINT,\n \t        LogicalType::HUGEINT,   LogicalType::FLOAT,    LogicalType::DOUBLE,       LogicalType::DATE,\n \t        LogicalType::TIMESTAMP, LogicalType::TIME,     LogicalType::TIMESTAMP_TZ, LogicalType::TIME_TZ,\n-\t        LogicalType::INTERVAL,  LogicalType::VARCHAR};\n+\t        LogicalType::INTERVAL,  LogicalType::ANY};\n }\n \n AggregateFunctionSet MedianFun::GetFunctions() {\ndiff --git a/src/core_functions/aggregate/nested/histogram.cpp b/src/core_functions/aggregate/nested/histogram.cpp\nindex b50c535e29e1..e28093743e45 100644\n--- a/src/core_functions/aggregate/nested/histogram.cpp\n+++ b/src/core_functions/aggregate/nested/histogram.cpp\n@@ -155,6 +155,10 @@ unique_ptr<FunctionData> HistogramBindFunction(ClientContext &context, Aggregate\n \t    arguments[0]->return_type.id() == LogicalTypeId::MAP) {\n \t\tthrow NotImplementedException(\"Unimplemented type for histogram %s\", arguments[0]->return_type.ToString());\n \t}\n+\tif (function.arguments[0].id() == LogicalTypeId::ANY) {\n+\t\t// add varchar cast for ANY\n+\t\tfunction.arguments[0] = LogicalType::VARCHAR;\n+\t}\n \n \tauto struct_type = LogicalType::MAP(arguments[0]->return_type, LogicalType::UBIGINT);\n \n@@ -176,7 +180,6 @@ static AggregateFunction GetHistogramFunction(const LogicalType &type) {\n \n template <class OP, class T, bool IS_ORDERED>\n AggregateFunction GetMapType(const LogicalType &type) {\n-\n \tif (IS_ORDERED) {\n \t\treturn GetHistogramFunction<OP, T>(type);\n \t}\n@@ -209,8 +212,6 @@ AggregateFunction GetHistogramFunction(const LogicalType &type) {\n \t\treturn GetMapType<HistogramFunctor, float, IS_ORDERED>(type);\n \tcase LogicalType::DOUBLE:\n \t\treturn GetMapType<HistogramFunctor, double, IS_ORDERED>(type);\n-\tcase LogicalType::VARCHAR:\n-\t\treturn GetMapType<HistogramStringFunctor, string, IS_ORDERED>(type);\n \tcase LogicalType::TIMESTAMP:\n \t\treturn GetMapType<HistogramFunctor, timestamp_t, IS_ORDERED>(type);\n \tcase LogicalType::TIMESTAMP_TZ:\n@@ -227,6 +228,8 @@ AggregateFunction GetHistogramFunction(const LogicalType &type) {\n \t\treturn GetMapType<HistogramFunctor, dtime_tz_t, IS_ORDERED>(type);\n \tcase LogicalType::DATE:\n \t\treturn GetMapType<HistogramFunctor, date_t, IS_ORDERED>(type);\n+\tcase LogicalType::ANY:\n+\t\treturn GetMapType<HistogramStringFunctor, string, IS_ORDERED>(type);\n \tdefault:\n \t\tthrow InternalException(\"Unimplemented histogram aggregate\");\n \t}\n@@ -245,7 +248,6 @@ AggregateFunctionSet HistogramFun::GetFunctions() {\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::BIGINT));\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::FLOAT));\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::DOUBLE));\n-\tfun.AddFunction(GetHistogramFunction<>(LogicalType::VARCHAR));\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::TIMESTAMP));\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::TIMESTAMP_TZ));\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::TIMESTAMP_S));\n@@ -254,6 +256,7 @@ AggregateFunctionSet HistogramFun::GetFunctions() {\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::TIME));\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::TIME_TZ));\n \tfun.AddFunction(GetHistogramFunction<>(LogicalType::DATE));\n+\tfun.AddFunction(GetHistogramFunction<>(LogicalType::ANY));\n \treturn fun;\n }\n \ndiff --git a/src/core_functions/scalar/array/array_functions.cpp b/src/core_functions/scalar/array/array_functions.cpp\nindex ac1f7664e939..9840ba1cc728 100644\n--- a/src/core_functions/scalar/array/array_functions.cpp\n+++ b/src/core_functions/scalar/array/array_functions.cpp\n@@ -216,7 +216,7 @@ static unique_ptr<FunctionData> ArrayGenericBinaryBind(ClientContext &context, S\n \tauto size = left_size;\n \n \tauto child_type =\n-\t    LogicalType::MaxLogicalType(ArrayType::GetChildType(left_type), ArrayType::GetChildType(right_type));\n+\t    LogicalType::MaxLogicalType(context, ArrayType::GetChildType(left_type), ArrayType::GetChildType(right_type));\n \tif (child_type != LogicalTypeId::FLOAT && child_type != LogicalTypeId::DOUBLE) {\n \t\tthrow InvalidInputException(\n \t\t    StringUtil::Format(\"%s: Array arguments must be of type FLOAT or DOUBLE\", OP::NAME));\ndiff --git a/src/core_functions/scalar/array/array_value.cpp b/src/core_functions/scalar/array/array_value.cpp\nindex d9325e745014..ac4f0bd24e47 100644\n--- a/src/core_functions/scalar/array/array_value.cpp\n+++ b/src/core_functions/scalar/array/array_value.cpp\n@@ -51,7 +51,7 @@ static unique_ptr<FunctionData> ArrayValueBind(ClientContext &context, ScalarFun\n \t// construct return type\n \tLogicalType child_type = arguments[0]->return_type;\n \tfor (idx_t i = 1; i < arguments.size(); i++) {\n-\t\tchild_type = LogicalType::MaxLogicalType(child_type, arguments[i]->return_type);\n+\t\tchild_type = LogicalType::MaxLogicalType(context, child_type, arguments[i]->return_type);\n \t}\n \n \tif (arguments.size() > ArrayType::MAX_ARRAY_SIZE) {\ndiff --git a/src/core_functions/scalar/generic/error.cpp b/src/core_functions/scalar/generic/error.cpp\nindex 5d38236bf9c9..40d2ead8db4e 100644\n--- a/src/core_functions/scalar/generic/error.cpp\n+++ b/src/core_functions/scalar/generic/error.cpp\n@@ -11,8 +11,8 @@ struct ErrorOperator {\n };\n \n ScalarFunction ErrorFun::GetFunction() {\n-\tauto fun = ScalarFunction({LogicalType::VARCHAR}, LogicalType::BOOLEAN,\n-\t                          ScalarFunction::UnaryFunction<string_t, bool, ErrorOperator>);\n+\tauto fun = ScalarFunction({LogicalType::VARCHAR}, LogicalType::SQLNULL,\n+\t                          ScalarFunction::UnaryFunction<string_t, int32_t, ErrorOperator>);\n \t// Set the function with side effects to avoid the optimization.\n \tfun.side_effects = FunctionSideEffects::HAS_SIDE_EFFECTS;\n \treturn fun;\ndiff --git a/src/core_functions/scalar/list/list_value.cpp b/src/core_functions/scalar/list/list_value.cpp\nindex ea60d82125fc..386fbd958438 100644\n--- a/src/core_functions/scalar/list/list_value.cpp\n+++ b/src/core_functions/scalar/list/list_value.cpp\n@@ -36,9 +36,17 @@ static void ListValueFunction(DataChunk &args, ExpressionState &state, Vector &r\n static unique_ptr<FunctionData> ListValueBind(ClientContext &context, ScalarFunction &bound_function,\n                                               vector<unique_ptr<Expression>> &arguments) {\n \t// collect names and deconflict, construct return type\n-\tLogicalType child_type = arguments.empty() ? LogicalType::SQLNULL : arguments[0]->return_type;\n+\tLogicalType child_type =\n+\t    arguments.empty() ? LogicalType::SQLNULL : ExpressionBinder::GetExpressionReturnType(*arguments[0]);\n \tfor (idx_t i = 1; i < arguments.size(); i++) {\n-\t\tchild_type = LogicalType::MaxLogicalType(child_type, arguments[i]->return_type);\n+\t\tauto arg_type = ExpressionBinder::GetExpressionReturnType(*arguments[i]);\n+\t\tif (!LogicalType::TryGetMaxLogicalType(context, child_type, arg_type, child_type)) {\n+\t\t\tthrow BinderException(\"Cannot create a list of types %s and %s - an explicit cast is required\",\n+\t\t\t                      child_type.ToString(), arg_type.ToString());\n+\t\t}\n+\t}\n+\tif (child_type.id() == LogicalTypeId::STRING_LITERAL) {\n+\t\tchild_type = LogicalType::VARCHAR;\n \t}\n \n \t// this is more for completeness reasons\ndiff --git a/src/function/cast/cast_function_set.cpp b/src/function/cast/cast_function_set.cpp\nindex 6e239f8fe322..ce8c9943db3b 100644\n--- a/src/function/cast/cast_function_set.cpp\n+++ b/src/function/cast/cast_function_set.cpp\n@@ -1,4 +1,3 @@\n-\n #include \"duckdb/function/cast/cast_function_set.hpp\"\n \n #include \"duckdb/common/pair.hpp\"\n@@ -26,6 +25,10 @@ CastFunctionSet::CastFunctionSet() : map_info(nullptr) {\n \tbind_functions.emplace_back(DefaultCasts::GetDefaultCastFunction);\n }\n \n+CastFunctionSet::CastFunctionSet(DBConfig &config_p) : CastFunctionSet() {\n+\tthis->config = &config_p;\n+}\n+\n CastFunctionSet &CastFunctionSet::Get(ClientContext &context) {\n \treturn DBConfig::GetConfig(context).GetCastFunctions();\n }\n@@ -156,7 +159,13 @@ int64_t CastFunctionSet::ImplicitCastCost(const LogicalType &source, const Logic\n \t\t}\n \t}\n \t// if not, fallback to the default implicit cast rules\n-\treturn CastRules::ImplicitCast(source, target);\n+\tauto score = CastRules::ImplicitCast(source, target);\n+\tif (score < 0 && config && config->options.old_implicit_casting) {\n+\t\tif (source.id() != LogicalTypeId::BLOB && target.id() == LogicalTypeId::VARCHAR) {\n+\t\t\tscore = 149;\n+\t\t}\n+\t}\n+\treturn score;\n }\n \n BoundCastInfo MapCastFunction(BindCastInput &input, const LogicalType &source, const LogicalType &target) {\ndiff --git a/src/function/cast_rules.cpp b/src/function/cast_rules.cpp\nindex 4f6d18779c32..f1963c192f23 100644\n--- a/src/function/cast_rules.cpp\n+++ b/src/function/cast_rules.cpp\n@@ -13,8 +13,14 @@ static int64_t TargetTypeCost(const LogicalType &type) {\n \t\treturn 102;\n \tcase LogicalTypeId::HUGEINT:\n \t\treturn 120;\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\treturn 119;\n \tcase LogicalTypeId::TIMESTAMP:\n \t\treturn 120;\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\treturn 121;\n+\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\treturn 122;\n \tcase LogicalTypeId::VARCHAR:\n \t\treturn 149;\n \tcase LogicalTypeId::DECIMAL:\n@@ -25,6 +31,8 @@ static int64_t TargetTypeCost(const LogicalType &type) {\n \tcase LogicalTypeId::UNION:\n \tcase LogicalTypeId::ARRAY:\n \t\treturn 160;\n+\tcase LogicalTypeId::ANY:\n+\t\treturn 5;\n \tdefault:\n \t\treturn 110;\n \t}\n@@ -206,8 +214,106 @@ static int64_t ImplicitCastDate(const LogicalType &to) {\n \t}\n }\n \n+static int64_t ImplicitCastEnum(const LogicalType &to) {\n+\tswitch (to.id()) {\n+\tcase LogicalTypeId::VARCHAR:\n+\t\treturn TargetTypeCost(to);\n+\tdefault:\n+\t\treturn -1;\n+\t}\n+}\n+\n+static int64_t ImplicitCastTimestampSec(const LogicalType &to) {\n+\tswitch (to.id()) {\n+\tcase LogicalTypeId::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\treturn TargetTypeCost(to);\n+\tdefault:\n+\t\treturn -1;\n+\t}\n+}\n+\n+static int64_t ImplicitCastTimestampMS(const LogicalType &to) {\n+\tswitch (to.id()) {\n+\tcase LogicalTypeId::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\treturn TargetTypeCost(to);\n+\tdefault:\n+\t\treturn -1;\n+\t}\n+}\n+\n+static int64_t ImplicitCastTimestampNS(const LogicalType &to) {\n+\tswitch (to.id()) {\n+\tcase LogicalTypeId::TIMESTAMP:\n+\t\t// we allow casting ALL timestamps, including nanosecond ones, to TimestampNS\n+\t\treturn TargetTypeCost(to);\n+\tdefault:\n+\t\treturn -1;\n+\t}\n+}\n+\n+static int64_t ImplicitCastTimestamp(const LogicalType &to) {\n+\tswitch (to.id()) {\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\treturn TargetTypeCost(to);\n+\tdefault:\n+\t\treturn -1;\n+\t}\n+}\n+\n+bool LogicalTypeIsValid(const LogicalType &type) {\n+\tswitch (type.id()) {\n+\tcase LogicalTypeId::STRUCT:\n+\tcase LogicalTypeId::UNION:\n+\tcase LogicalTypeId::LIST:\n+\tcase LogicalTypeId::MAP:\n+\tcase LogicalTypeId::ARRAY:\n+\tcase LogicalTypeId::DECIMAL:\n+\t\t// these types are only valid with auxiliary info\n+\t\tif (!type.AuxInfo()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tbreak;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\tswitch (type.id()) {\n+\tcase LogicalTypeId::ANY:\n+\tcase LogicalTypeId::INVALID:\n+\tcase LogicalTypeId::UNKNOWN:\n+\t\treturn false;\n+\tcase LogicalTypeId::STRUCT: {\n+\t\tauto child_count = StructType::GetChildCount(type);\n+\t\tfor (idx_t i = 0; i < child_count; i++) {\n+\t\t\tif (!LogicalTypeIsValid(StructType::GetChildType(type, i))) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\tcase LogicalTypeId::UNION: {\n+\t\tauto member_count = UnionType::GetMemberCount(type);\n+\t\tfor (idx_t i = 0; i < member_count; i++) {\n+\t\t\tif (!LogicalTypeIsValid(UnionType::GetMemberType(type, i))) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\tcase LogicalTypeId::LIST:\n+\tcase LogicalTypeId::MAP:\n+\t\treturn LogicalTypeIsValid(ListType::GetChildType(type));\n+\tcase LogicalTypeId::ARRAY:\n+\t\treturn LogicalTypeIsValid(ArrayType::GetChildType(type));\n+\tdefault:\n+\t\treturn true;\n+\t}\n+}\n+\n int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to) {\n-\tif (from.id() == LogicalTypeId::SQLNULL) {\n+\tif (from.id() == LogicalTypeId::SQLNULL || to.id() == LogicalTypeId::ANY) {\n \t\t// NULL expression can be cast to anything\n \t\treturn TargetTypeCost(to);\n \t}\n@@ -215,9 +321,22 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\t// parameter expression can be cast to anything for no cost\n \t\treturn 0;\n \t}\n-\tif (to.id() == LogicalTypeId::ANY) {\n-\t\t// anything can be cast to ANY type for (almost no) cost\n-\t\treturn 1;\n+\tif (from.id() == LogicalTypeId::STRING_LITERAL) {\n+\t\t// string literals can be cast to any type for low cost as long as the type is valid\n+\t\t// i.e. we cannot cast to LIST(ANY) as we don't know what \"ANY\" should be\n+\t\t// we cannot cast to DECIMAL without precision/width specified\n+\t\t// etc...\n+\t\t// the exception is the ANY type - for the ANY type we just cast to VARCHAR\n+\t\t// but we prefer casting to VARCHAR\n+\t\tif (to.id() != LogicalType::ANY) {\n+\t\t\tif (!LogicalTypeIsValid(to)) {\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t}\n+\t\tif (to.id() == LogicalTypeId::VARCHAR && to.GetAlias().empty()) {\n+\t\t\treturn 1;\n+\t\t}\n+\t\treturn 20;\n \t}\n \tif (from.GetAlias() != to.GetAlias()) {\n \t\t// if aliases are different, an implicit cast is not possible\n@@ -226,7 +345,7 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \tif (from.id() == LogicalTypeId::LIST && to.id() == LogicalTypeId::LIST) {\n \t\t// Lists can be cast if their child types can be cast\n \t\tauto child_cost = ImplicitCast(ListType::GetChildType(from), ListType::GetChildType(to));\n-\t\tif (child_cost >= 100) {\n+\t\tif (child_cost >= 1) {\n \t\t\t// subtract one from the cost because we prefer LIST[X] -> LIST[VARCHAR] over LIST[X] -> VARCHAR\n \t\t\tchild_cost--;\n \t\t}\n@@ -263,14 +382,6 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\t// arguments match: do nothing\n \t\treturn 0;\n \t}\n-\tif (from.id() == LogicalTypeId::BLOB && to.id() == LogicalTypeId::VARCHAR) {\n-\t\t// Implicit cast not allowed from BLOB to VARCHAR\n-\t\treturn -1;\n-\t}\n-\tif (to.id() == LogicalTypeId::VARCHAR) {\n-\t\t// everything can be cast to VARCHAR, but this cast has a high cost\n-\t\treturn TargetTypeCost(to);\n-\t}\n \n \tif (from.id() == LogicalTypeId::UNION && to.id() == LogicalTypeId::UNION) {\n \t\t// Unions can be cast if the source tags are a subset of the target tags\n@@ -316,18 +427,6 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\t}\n \t}\n \n-\tif ((from.id() == LogicalTypeId::TIMESTAMP_SEC || from.id() == LogicalTypeId::TIMESTAMP_MS ||\n-\t     from.id() == LogicalTypeId::TIMESTAMP_NS) &&\n-\t    to.id() == LogicalTypeId::TIMESTAMP) {\n-\t\t//! Any timestamp type can be converted to the default (us) type at low cost\n-\t\treturn 101;\n-\t}\n-\tif ((to.id() == LogicalTypeId::TIMESTAMP_SEC || to.id() == LogicalTypeId::TIMESTAMP_MS ||\n-\t     to.id() == LogicalTypeId::TIMESTAMP_NS) &&\n-\t    from.id() == LogicalTypeId::TIMESTAMP) {\n-\t\t//! Any timestamp type can be converted to the default (us) type at low cost\n-\t\treturn 100;\n-\t}\n \tswitch (from.id()) {\n \tcase LogicalTypeId::TINYINT:\n \t\treturn ImplicitCastTinyint(to);\n@@ -357,6 +456,16 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\treturn ImplicitCastDate(to);\n \tcase LogicalTypeId::DECIMAL:\n \t\treturn ImplicitCastDecimal(to);\n+\tcase LogicalTypeId::ENUM:\n+\t\treturn ImplicitCastEnum(to);\n+\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\treturn ImplicitCastTimestampSec(to);\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\treturn ImplicitCastTimestampMS(to);\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\treturn ImplicitCastTimestampNS(to);\n+\tcase LogicalTypeId::TIMESTAMP:\n+\t\treturn ImplicitCastTimestamp(to);\n \tdefault:\n \t\treturn -1;\n \t}\ndiff --git a/src/function/function.cpp b/src/function/function.cpp\nindex 44547e88855a..82208d875564 100644\n--- a/src/function/function.cpp\n+++ b/src/function/function.cpp\n@@ -47,7 +47,7 @@ SimpleFunction::~SimpleFunction() {\n }\n \n string SimpleFunction::ToString() const {\n-\treturn Function::CallToString(name, arguments);\n+\treturn Function::CallToString(name, arguments, varargs);\n }\n \n bool SimpleFunction::HasVarArgs() const {\n@@ -81,7 +81,7 @@ BaseScalarFunction::~BaseScalarFunction() {\n }\n \n string BaseScalarFunction::ToString() const {\n-\treturn Function::CallToString(name, arguments, return_type);\n+\treturn Function::CallToString(name, arguments, varargs, return_type);\n }\n \n // add your initializer for new functions here\n@@ -118,16 +118,22 @@ hash_t BaseScalarFunction::Hash() const {\n \treturn hash;\n }\n \n-string Function::CallToString(const string &name, const vector<LogicalType> &arguments) {\n+string Function::CallToString(const string &name, const vector<LogicalType> &arguments, const LogicalType &varargs) {\n \tstring result = name + \"(\";\n-\tresult += StringUtil::Join(arguments, arguments.size(), \", \",\n-\t                           [](const LogicalType &argument) { return argument.ToString(); });\n+\tvector<string> string_arguments;\n+\tfor (auto &arg : arguments) {\n+\t\tstring_arguments.push_back(arg.ToString());\n+\t}\n+\tif (varargs.IsValid()) {\n+\t\tstring_arguments.push_back(\"[\" + varargs.ToString() + \"...]\");\n+\t}\n+\tresult += StringUtil::Join(string_arguments, \", \");\n \treturn result + \")\";\n }\n \n-string Function::CallToString(const string &name, const vector<LogicalType> &arguments,\n+string Function::CallToString(const string &name, const vector<LogicalType> &arguments, const LogicalType &varargs,\n                               const LogicalType &return_type) {\n-\tstring result = CallToString(name, arguments);\n+\tstring result = CallToString(name, arguments, varargs);\n \tresult += \" -> \" + return_type.ToString();\n \treturn result;\n }\ndiff --git a/src/function/function_binder.cpp b/src/function/function_binder.cpp\nindex eb97dc87c8b0..20ce9c40c90d 100644\n--- a/src/function/function_binder.cpp\n+++ b/src/function/function_binder.cpp\n@@ -102,7 +102,7 @@ vector<idx_t> FunctionBinder::BindFunctionsFromArguments(const string &name, Fun\n \tif (best_function == DConstants::INVALID_INDEX) {\n \t\t// no matching function was found, throw an error\n \t\tstring call_str = Function::CallToString(name, arguments);\n-\t\tstring candidate_str = \"\";\n+\t\tstring candidate_str;\n \t\tfor (auto &f : functions.functions) {\n \t\t\tcandidate_str += \"\\t\" + f.ToString() + \"\\n\";\n \t\t}\n@@ -123,7 +123,7 @@ idx_t FunctionBinder::MultipleCandidateException(const string &name, FunctionSet\n \t// there are multiple possible function definitions\n \t// throw an exception explaining which overloads are there\n \tstring call_str = Function::CallToString(name, arguments);\n-\tstring candidate_str = \"\";\n+\tstring candidate_str;\n \tfor (auto &conf : candidate_functions) {\n \t\tT f = functions.GetFunctionByOffset(conf);\n \t\tcandidate_str += \"\\t\" + f.ToString() + \"\\n\";\n@@ -197,7 +197,7 @@ vector<LogicalType> FunctionBinder::GetLogicalTypesFromExpressions(vector<unique\n \tvector<LogicalType> types;\n \ttypes.reserve(arguments.size());\n \tfor (auto &argument : arguments) {\n-\t\ttypes.push_back(argument->return_type);\n+\t\ttypes.push_back(ExpressionBinder::GetExpressionReturnType(*argument));\n \t}\n \treturn types;\n }\n@@ -241,6 +241,9 @@ LogicalTypeComparisonResult RequiresCast(const LogicalType &source_type, const L\n void FunctionBinder::CastToFunctionArguments(SimpleFunction &function, vector<unique_ptr<Expression>> &children) {\n \tfor (idx_t i = 0; i < children.size(); i++) {\n \t\tauto target_type = i < function.arguments.size() ? function.arguments[i] : function.varargs;\n+\t\tif (target_type.id() == LogicalTypeId::STRING_LITERAL) {\n+\t\t\tthrow InternalException(\"Function %s returned a STRING_LITERAL type - use VARCHAR instead\", function.name);\n+\t\t}\n \t\ttarget_type.Verify();\n \t\t// don't cast lambda children, they get removed before execution\n \t\tif (children[i]->return_type.id() == LogicalTypeId::LAMBDA) {\ndiff --git a/src/function/scalar/list/contains_or_position.cpp b/src/function/scalar/list/contains_or_position.cpp\nindex 3b9614359101..b7f454581d53 100644\n--- a/src/function/scalar/list/contains_or_position.cpp\n+++ b/src/function/scalar/list/contains_or_position.cpp\n@@ -41,7 +41,12 @@ static unique_ptr<FunctionData> ListContainsOrPositionBind(ClientContext &contex\n \t\tbound_function.return_type = RETURN_TYPE;\n \t} else {\n \t\tauto const &child_type = ListType::GetChildType(list);\n-\t\tauto max_child_type = LogicalType::MaxLogicalType(child_type, value);\n+\t\tLogicalType max_child_type;\n+\t\tif (!LogicalType::TryGetMaxLogicalType(context, child_type, value, max_child_type)) {\n+\t\t\tthrow BinderException(\n+\t\t\t    \"Cannot get list_position of element of type %s in a list of type %s[] - an explicit cast is required\",\n+\t\t\t    value.ToString(), child_type.ToString());\n+\t\t}\n \t\tauto list_type = LogicalType::LIST(max_child_type);\n \n \t\tbound_function.arguments[0] = list_type;\ndiff --git a/src/function/scalar/list/list_concat.cpp b/src/function/scalar/list/list_concat.cpp\nindex d992bd951a3a..880d752640a4 100644\n--- a/src/function/scalar/list/list_concat.cpp\n+++ b/src/function/scalar/list/list_concat.cpp\n@@ -99,7 +99,11 @@ static unique_ptr<FunctionData> ListConcatBind(ClientContext &context, ScalarFun\n \t\t// Resolve list type\n \t\tLogicalType child_type = LogicalType::SQLNULL;\n \t\tfor (const auto &argument : arguments) {\n-\t\t\tchild_type = LogicalType::MaxLogicalType(child_type, ListType::GetChildType(argument->return_type));\n+\t\t\tauto &next_type = ListType::GetChildType(argument->return_type);\n+\t\t\tif (!LogicalType::TryGetMaxLogicalType(context, child_type, next_type, child_type)) {\n+\t\t\t\tthrow BinderException(\"Cannot concatenate lists of types %s[] and %s[] - an explicit cast is required\",\n+\t\t\t\t                      child_type.ToString(), next_type.ToString());\n+\t\t\t}\n \t\t}\n \t\tauto list_type = LogicalType::LIST(child_type);\n \ndiff --git a/src/function/scalar/string/concat.cpp b/src/function/scalar/string/concat.cpp\nindex f5b04a4b8c0e..5ad0c9a3ede5 100644\n--- a/src/function/scalar/string/concat.cpp\n+++ b/src/function/scalar/string/concat.cpp\n@@ -231,6 +231,15 @@ static void ConcatWSFunction(DataChunk &args, ExpressionState &state, Vector &re\n \t}\n }\n \n+static unique_ptr<FunctionData> BindConcatFunction(ClientContext &context, ScalarFunction &bound_function,\n+                                                   vector<unique_ptr<Expression>> &arguments) {\n+\tfor (auto &arg : bound_function.arguments) {\n+\t\targ = LogicalType::VARCHAR;\n+\t}\n+\tbound_function.varargs = LogicalType::VARCHAR;\n+\treturn nullptr;\n+}\n+\n void ConcatFun::RegisterFunction(BuiltinFunctions &set) {\n \t// the concat operator and concat function have different behavior regarding NULLs\n \t// this is strange but seems consistent with postgresql and mysql\n@@ -247,14 +256,15 @@ void ConcatFun::RegisterFunction(BuiltinFunctions &set) {\n \t// e.g.:\n \t// concat_ws(',', NULL, NULL) = \"\"\n \t// concat_ws(',', '', '') = \",\"\n-\tScalarFunction concat = ScalarFunction(\"concat\", {LogicalType::VARCHAR}, LogicalType::VARCHAR, ConcatFunction);\n-\tconcat.varargs = LogicalType::VARCHAR;\n+\tScalarFunction concat =\n+\t    ScalarFunction(\"concat\", {LogicalType::ANY}, LogicalType::VARCHAR, ConcatFunction, BindConcatFunction);\n+\tconcat.varargs = LogicalType::ANY;\n \tconcat.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tset.AddFunction(concat);\n \n \tScalarFunctionSet concat_op(\"||\");\n \tconcat_op.AddFunction(\n-\t    ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::VARCHAR, ConcatOperator));\n+\t    ScalarFunction({LogicalType::ANY, LogicalType::ANY}, LogicalType::VARCHAR, ConcatOperator, BindConcatFunction));\n \tconcat_op.AddFunction(ScalarFunction({LogicalType::BLOB, LogicalType::BLOB}, LogicalType::BLOB, ConcatOperator));\n \tconcat_op.AddFunction(ListConcatFun::GetFunction());\n \tfor (auto &fun : concat_op.functions) {\n@@ -262,9 +272,9 @@ void ConcatFun::RegisterFunction(BuiltinFunctions &set) {\n \t}\n \tset.AddFunction(concat_op);\n \n-\tScalarFunction concat_ws = ScalarFunction(\"concat_ws\", {LogicalType::VARCHAR, LogicalType::VARCHAR},\n-\t                                          LogicalType::VARCHAR, ConcatWSFunction);\n-\tconcat_ws.varargs = LogicalType::VARCHAR;\n+\tScalarFunction concat_ws = ScalarFunction(\"concat_ws\", {LogicalType::VARCHAR, LogicalType::ANY},\n+\t                                          LogicalType::VARCHAR, ConcatWSFunction, BindConcatFunction);\n+\tconcat_ws.varargs = LogicalType::ANY;\n \tconcat_ws.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tset.AddFunction(concat_ws);\n }\ndiff --git a/src/include/duckdb/common/types.hpp b/src/include/duckdb/common/types.hpp\nindex 0be94148a61a..2462892b4a7e 100644\n--- a/src/include/duckdb/common/types.hpp\n+++ b/src/include/duckdb/common/types.hpp\n@@ -212,6 +212,7 @@ enum class LogicalTypeId : uint8_t {\n \tTIMESTAMP_TZ = 32,\n \tTIME_TZ = 34,\n \tBIT = 36,\n+\tSTRING_LITERAL = 37, /* string literals, used for constant strings - only exists while binding */\n \n \tUHUGEINT = 49,\n \tHUGEINT = 50,\n@@ -301,9 +302,14 @@ struct LogicalType {\n \tDUCKDB_API bool HasAlias() const;\n \tDUCKDB_API string GetAlias() const;\n \n-\tDUCKDB_API static LogicalType MaxLogicalType(const LogicalType &left, const LogicalType &right);\n+\t//! Returns the maximum logical type when combining the two types - or throws an exception if combining is not possible\n+\tDUCKDB_API static LogicalType MaxLogicalType(ClientContext &context, const LogicalType &left, const LogicalType &right);\n+\tDUCKDB_API static bool TryGetMaxLogicalType(ClientContext &context, const LogicalType &left, const LogicalType &right, LogicalType &result);\n+\t//! Forcibly returns a maximum logical type - similar to MaxLogicalType but never throws. As a fallback either left or right are returned.\n+\tDUCKDB_API static LogicalType ForceMaxLogicalType(const LogicalType &left, const LogicalType &right);\n \n-\t//! Gets the decimal properties of a numeric type. Fails if the type is not numeric.\n+\n+\t\t//! Gets the decimal properties of a numeric type. Fails if the type is not numeric.\n \tDUCKDB_API bool GetDecimalProperties(uint8_t &width, uint8_t &scale) const;\n \n \tDUCKDB_API void Verify() const;\ndiff --git a/src/include/duckdb/function/cast/cast_function_set.hpp b/src/include/duckdb/function/cast/cast_function_set.hpp\nindex 3395725ce394..1c6f38ceae76 100644\n--- a/src/include/duckdb/function/cast/cast_function_set.hpp\n+++ b/src/include/duckdb/function/cast/cast_function_set.hpp\n@@ -13,6 +13,7 @@\n namespace duckdb {\n struct MapCastInfo;\n struct MapCastNode;\n+struct DBConfig;\n \n typedef BoundCastInfo (*bind_cast_function_t)(BindCastInput &input, const LogicalType &source,\n                                               const LogicalType &target);\n@@ -38,6 +39,7 @@ struct BindCastFunction {\n class CastFunctionSet {\n public:\n \tCastFunctionSet();\n+\tCastFunctionSet(DBConfig &config);\n \n public:\n \tDUCKDB_API static CastFunctionSet &Get(ClientContext &context);\n@@ -57,6 +59,7 @@ class CastFunctionSet {\n \t                                     bind_cast_function_t bind, int64_t implicit_cast_cost = -1);\n \n private:\n+\toptional_ptr<DBConfig> config;\n \tvector<BindCastFunction> bind_functions;\n \t//! If any custom cast functions have been defined using RegisterCastFunction, this holds the map\n \toptional_ptr<MapCastInfo> map_info;\ndiff --git a/src/include/duckdb/function/function.hpp b/src/include/duckdb/function/function.hpp\nindex 9a9bb9e441fb..e12ead51fe0f 100644\n--- a/src/include/duckdb/function/function.hpp\n+++ b/src/include/duckdb/function/function.hpp\n@@ -96,10 +96,11 @@ class Function {\n \n public:\n \t//! Returns the formatted string name(arg1, arg2, ...)\n-\tDUCKDB_API static string CallToString(const string &name, const vector<LogicalType> &arguments);\n+\tDUCKDB_API static string CallToString(const string &name, const vector<LogicalType> &arguments,\n+\t                                      const LogicalType &varargs = LogicalType::INVALID);\n \t//! Returns the formatted string name(arg1, arg2..) -> return_type\n \tDUCKDB_API static string CallToString(const string &name, const vector<LogicalType> &arguments,\n-\t                                      const LogicalType &return_type);\n+\t                                      const LogicalType &varargs, const LogicalType &return_type);\n \t//! Returns the formatted string name(arg1, arg2.., np1=a, np2=b, ...)\n \tDUCKDB_API static string CallToString(const string &name, const vector<LogicalType> &arguments,\n \t                                      const named_parameter_type_map_t &named_parameters);\ndiff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp\nindex d553e7df2a12..5de6b7460d60 100644\n--- a/src/include/duckdb/main/config.hpp\n+++ b/src/include/duckdb/main/config.hpp\n@@ -181,6 +181,8 @@ struct DBConfigOptions {\n \tstring duckdb_api;\n \t//! Metadata from DuckDB callers\n \tstring custom_user_agent;\n+\t//! Use old implicit casting style (i.e. allow everything to be implicitly casted to VARCHAR)\n+\tbool old_implicit_casting = false;\n \n \tbool operator==(const DBConfigOptions &other) const;\n };\ndiff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp\nindex 3f098eef80b8..f076f0ffd838 100644\n--- a/src/include/duckdb/main/settings.hpp\n+++ b/src/include/duckdb/main/settings.hpp\n@@ -407,6 +407,15 @@ struct MaximumMemorySetting {\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n+struct OldImplicitCasting {\n+\tstatic constexpr const char *Name = \"old_implicit_casting\";\n+\tstatic constexpr const char *Description = \"Allow implicit casting to/from VARCHAR\";\n+\tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n+\tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n+\tstatic Value GetSetting(ClientContext &context);\n+};\n+\n struct PasswordSetting {\n \tstatic constexpr const char *Name = \"password\";\n \tstatic constexpr const char *Description = \"The password to use. Ignored for legacy compatibility.\";\ndiff --git a/src/include/duckdb/planner/expression/bound_comparison_expression.hpp b/src/include/duckdb/planner/expression/bound_comparison_expression.hpp\nindex 9e34e3cf35fe..25ac664ceb46 100644\n--- a/src/include/duckdb/planner/expression/bound_comparison_expression.hpp\n+++ b/src/include/duckdb/planner/expression/bound_comparison_expression.hpp\n@@ -33,6 +33,9 @@ class BoundComparisonExpression : public Expression {\n \tstatic unique_ptr<Expression> Deserialize(Deserializer &deserializer);\n \n public:\n-\tstatic LogicalType BindComparison(LogicalType left_type, LogicalType right_type);\n+\tstatic LogicalType BindComparison(ClientContext &context, const LogicalType &left_type,\n+\t                                  const LogicalType &right_type, ExpressionType comparison_type);\n+\tstatic bool TryBindComparison(ClientContext &context, const LogicalType &left_type, const LogicalType &right_type,\n+\t                              LogicalType &result_type, ExpressionType comparison_type);\n };\n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 16b9db820a4c..18ca6d214df1 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -116,6 +116,8 @@ class ExpressionBinder {\n \n \tvoid ReplaceMacroParametersRecursive(unique_ptr<ParsedExpression> &expr);\n \n+\tstatic LogicalType GetExpressionReturnType(const Expression &expr);\n+\n private:\n \t//! Maximum stack depth\n \tstatic constexpr const idx_t MAXIMUM_STACK_DEPTH = 128;\n@@ -153,6 +155,10 @@ class ExpressionBinder {\n \n \tstatic unique_ptr<ParsedExpression> GetSQLValueFunction(const string &column_name);\n \n+\tLogicalType ResolveOperatorType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);\n+\tLogicalType ResolveInType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);\n+\tLogicalType ResolveNotType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);\n+\n protected:\n \tvirtual BindResult BindGroupingFunction(OperatorExpression &op, idx_t depth);\n \tvirtual BindResult BindFunction(FunctionExpression &expr, ScalarFunctionCatalogEntry &function, idx_t depth);\ndiff --git a/src/main/config.cpp b/src/main/config.cpp\nindex f1abc1b4eef8..7beb3948d034 100644\n--- a/src/main/config.cpp\n+++ b/src/main/config.cpp\n@@ -92,6 +92,7 @@ static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting\n                                                  DUCKDB_LOCAL(IntegerDivisionSetting),\n                                                  DUCKDB_LOCAL(MaximumExpressionDepthSetting),\n                                                  DUCKDB_GLOBAL(MaximumMemorySetting),\n+                                                 DUCKDB_GLOBAL(OldImplicitCasting),\n                                                  DUCKDB_GLOBAL_ALIAS(\"memory_limit\", MaximumMemorySetting),\n                                                  DUCKDB_GLOBAL_ALIAS(\"null_order\", DefaultNullOrderSetting),\n                                                  DUCKDB_LOCAL(OrderedAggregateThreshold),\ndiff --git a/src/main/database.cpp b/src/main/database.cpp\nindex def004a20831..c519e3ee2e25 100644\n--- a/src/main/database.cpp\n+++ b/src/main/database.cpp\n@@ -30,7 +30,7 @@ namespace duckdb {\n \n DBConfig::DBConfig() {\n \tcompression_functions = make_uniq<CompressionFunctionSet>();\n-\tcast_functions = make_uniq<CastFunctionSet>();\n+\tcast_functions = make_uniq<CastFunctionSet>(*this);\n \terror_manager = make_uniq<ErrorManager>();\n \toptions.duckdb_api = StringUtil::Format(\"duckdb/%s(%s)\", DuckDB::LibraryVersion(), DuckDB::Platform());\n }\ndiff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp\nindex ee695cfd84c9..1cca6f7c7441 100644\n--- a/src/main/settings/settings.cpp\n+++ b/src/main/settings/settings.cpp\n@@ -911,6 +911,22 @@ Value MaximumMemorySetting::GetSetting(ClientContext &context) {\n \treturn Value(StringUtil::BytesToHumanReadableString(config.options.maximum_memory));\n }\n \n+//===--------------------------------------------------------------------===//\n+// Old Implicit Casting\n+//===--------------------------------------------------------------------===//\n+void OldImplicitCasting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {\n+\tconfig.options.old_implicit_casting = input.GetValue<bool>();\n+}\n+\n+void OldImplicitCasting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.old_implicit_casting = DBConfig().options.old_implicit_casting;\n+}\n+\n+Value OldImplicitCasting::GetSetting(ClientContext &context) {\n+\tauto &config = DBConfig::GetConfig(context);\n+\treturn Value::BOOLEAN(config.options.old_implicit_casting);\n+}\n+\n //===--------------------------------------------------------------------===//\n // Password Setting\n //===--------------------------------------------------------------------===//\ndiff --git a/src/parser/transform/expression/transform_constant.cpp b/src/parser/transform/expression/transform_constant.cpp\nindex 39f021e02b9a..95332278d0ae 100644\n--- a/src/parser/transform/expression/transform_constant.cpp\n+++ b/src/parser/transform/expression/transform_constant.cpp\n@@ -112,9 +112,9 @@ bool Transformer::ConstructConstantFromExpression(const ParsedExpression &expr,\n \t\t\t}\n \n \t\t\t// figure out child type\n-\t\t\tLogicalType child_type(LogicalTypeId::INTEGER);\n+\t\t\tLogicalType child_type(LogicalTypeId::SQLNULL);\n \t\t\tfor (auto &child_value : values) {\n-\t\t\t\tchild_type = LogicalType::MaxLogicalType(child_type, child_value.type());\n+\t\t\t\tchild_type = LogicalType::ForceMaxLogicalType(child_type, child_value.type());\n \t\t\t}\n \n \t\t\t// finally create the list\ndiff --git a/src/parser/transform/expression/transform_subquery.cpp b/src/parser/transform/expression/transform_subquery.cpp\nindex bb7a7272be63..ff34c5801077 100644\n--- a/src/parser/transform/expression/transform_subquery.cpp\n+++ b/src/parser/transform/expression/transform_subquery.cpp\n@@ -9,8 +9,9 @@ unique_ptr<ParsedExpression> Transformer::TransformSubquery(duckdb_libpgquery::P\n \tauto subquery_expr = make_uniq<SubqueryExpression>();\n \n \tsubquery_expr->subquery = TransformSelect(root.subselect);\n+\tsubquery_expr->query_location = root.location;\n \tD_ASSERT(subquery_expr->subquery);\n-\tD_ASSERT(subquery_expr->subquery->node->GetSelectList().size() > 0);\n+\tD_ASSERT(!subquery_expr->subquery->node->GetSelectList().empty());\n \n \tswitch (root.subLinkType) {\n \tcase duckdb_libpgquery::PG_EXISTS_SUBLINK: {\n@@ -97,7 +98,6 @@ unique_ptr<ParsedExpression> Transformer::TransformSubquery(duckdb_libpgquery::P\n \tdefault:\n \t\tthrow NotImplementedException(\"Subquery of type %d not implemented\\n\", (int)root.subLinkType);\n \t}\n-\tsubquery_expr->query_location = root.location;\n \treturn std::move(subquery_expr);\n }\n \ndiff --git a/src/planner/binder/expression/bind_between_expression.cpp b/src/planner/binder/expression/bind_between_expression.cpp\nindex a44e5d3783f3..e8bee48c2523 100644\n--- a/src/planner/binder/expression/bind_between_expression.cpp\n+++ b/src/planner/binder/expression/bind_between_expression.cpp\n@@ -5,6 +5,7 @@\n #include \"duckdb/planner/expression/bound_conjunction_expression.hpp\"\n #include \"duckdb/planner/expression/bound_parameter_expression.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n+#include \"duckdb/planner/binder.hpp\"\n \n namespace duckdb {\n \n@@ -22,14 +23,25 @@ BindResult ExpressionBinder::BindExpression(BetweenExpression &expr, idx_t depth\n \tauto &lower = BoundExpression::GetExpression(*expr.lower);\n \tauto &upper = BoundExpression::GetExpression(*expr.upper);\n \n-\tauto input_sql_type = input->return_type;\n-\tauto lower_sql_type = lower->return_type;\n-\tauto upper_sql_type = upper->return_type;\n+\tauto input_sql_type = ExpressionBinder::GetExpressionReturnType(*input);\n+\tauto lower_sql_type = ExpressionBinder::GetExpressionReturnType(*lower);\n+\tauto upper_sql_type = ExpressionBinder::GetExpressionReturnType(*upper);\n \n \t// cast the input types to the same type\n \t// now obtain the result type of the input types\n-\tauto input_type = BoundComparisonExpression::BindComparison(input_sql_type, lower_sql_type);\n-\tinput_type = BoundComparisonExpression::BindComparison(input_type, upper_sql_type);\n+\tLogicalType input_type;\n+\tif (!BoundComparisonExpression::TryBindComparison(context, input_sql_type, lower_sql_type, input_type, expr.type)) {\n+\t\tthrow BinderException(binder.FormatError(\n+\t\t    expr,\n+\t\t    StringUtil::Format(\"Cannot mix values of type %s and %s in BETWEEN clause - an explicit cast is required\",\n+\t\t                       input_sql_type.ToString(), lower_sql_type.ToString())));\n+\t}\n+\tif (!BoundComparisonExpression::TryBindComparison(context, input_type, upper_sql_type, input_type, expr.type)) {\n+\t\tthrow BinderException(binder.FormatError(\n+\t\t    expr,\n+\t\t    StringUtil::Format(\"Cannot mix values of type %s and %s in BETWEEN clause - an explicit cast is required\",\n+\t\t                       input_type.ToString(), upper_sql_type.ToString())));\n+\t}\n \t// add casts (if necessary)\n \tinput = BoundCastExpression::AddCastToType(context, std::move(input), input_type);\n \tlower = BoundCastExpression::AddCastToType(context, std::move(lower), input_type);\ndiff --git a/src/planner/binder/expression/bind_case_expression.cpp b/src/planner/binder/expression/bind_case_expression.cpp\nindex 6ba9bd8f3991..42d116a6d22a 100644\n--- a/src/planner/binder/expression/bind_case_expression.cpp\n+++ b/src/planner/binder/expression/bind_case_expression.cpp\n@@ -2,6 +2,7 @@\n #include \"duckdb/planner/expression/bound_case_expression.hpp\"\n #include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n+#include \"duckdb/planner/binder.hpp\"\n \n namespace duckdb {\n \n@@ -19,16 +20,21 @@ BindResult ExpressionBinder::BindExpression(CaseExpression &expr, idx_t depth) {\n \t// the children have been successfully resolved\n \t// figure out the result type of the CASE expression\n \tauto &else_expr = BoundExpression::GetExpression(*expr.else_expr);\n-\tauto return_type = else_expr->return_type;\n+\tauto return_type = ExpressionBinder::GetExpressionReturnType(*else_expr);\n \tfor (auto &check : expr.case_checks) {\n \t\tauto &then_expr = BoundExpression::GetExpression(*check.then_expr);\n-\t\treturn_type = LogicalType::MaxLogicalType(return_type, then_expr->return_type);\n+\t\tauto then_type = ExpressionBinder::GetExpressionReturnType(*then_expr);\n+\t\tif (!LogicalType::TryGetMaxLogicalType(context, return_type, then_type, return_type)) {\n+\t\t\tthrow BinderException(binder.FormatError(\n+\t\t\t    expr, StringUtil::Format(\n+\t\t\t              \"Cannot mix values of type %s and %s in CASE expression - an explicit cast is required\",\n+\t\t\t              return_type.ToString(), then_type.ToString())));\n+\t\t}\n \t}\n \n \t// bind all the individual components of the CASE statement\n \tauto result = make_uniq<BoundCaseExpression>(return_type);\n-\tfor (idx_t i = 0; i < expr.case_checks.size(); i++) {\n-\t\tauto &check = expr.case_checks[i];\n+\tfor (auto &check : expr.case_checks) {\n \t\tauto &when_expr = BoundExpression::GetExpression(*check.when_expr);\n \t\tauto &then_expr = BoundExpression::GetExpression(*check.then_expr);\n \t\tBoundCaseCheck result_check;\ndiff --git a/src/planner/binder/expression/bind_cast_expression.cpp b/src/planner/binder/expression/bind_cast_expression.cpp\nindex a62dd008408c..46a18918d341 100644\n--- a/src/planner/binder/expression/bind_cast_expression.cpp\n+++ b/src/planner/binder/expression/bind_cast_expression.cpp\n@@ -18,7 +18,7 @@ BindResult ExpressionBinder::BindExpression(CastExpression &expr, idx_t depth) {\n \t// the children have been successfully resolved\n \tauto &child = BoundExpression::GetExpression(*expr.child);\n \tif (expr.try_cast) {\n-\t\tif (child->return_type == expr.cast_type) {\n+\t\tif (ExpressionBinder::GetExpressionReturnType(*child) == expr.cast_type) {\n \t\t\t// no cast required: type matches\n \t\t\treturn BindResult(std::move(child));\n \t\t}\ndiff --git a/src/planner/binder/expression/bind_comparison_expression.cpp b/src/planner/binder/expression/bind_comparison_expression.cpp\nindex 0cff7da5bec9..89e19c72d37a 100644\n--- a/src/planner/binder/expression/bind_comparison_expression.cpp\n+++ b/src/planner/binder/expression/bind_comparison_expression.cpp\n@@ -73,9 +73,62 @@ void ExpressionBinder::TestCollation(ClientContext &context, const string &colla\n \tPushCollation(context, expr, LogicalType::VARCHAR_COLLATION(collation));\n }\n \n-LogicalType BoundComparisonExpression::BindComparison(LogicalType left_type, LogicalType right_type) {\n-\tauto result_type = LogicalType::MaxLogicalType(left_type, right_type);\n-\tswitch (result_type.id()) {\n+static bool SwitchVarcharComparison(const LogicalType &type) {\n+\tswitch (type.id()) {\n+\tcase LogicalTypeId::TINYINT:\n+\tcase LogicalTypeId::SMALLINT:\n+\tcase LogicalTypeId::INTEGER:\n+\tcase LogicalTypeId::BIGINT:\n+\tcase LogicalTypeId::HUGEINT:\n+\tcase LogicalTypeId::FLOAT:\n+\tcase LogicalTypeId::DOUBLE:\n+\tcase LogicalTypeId::DECIMAL:\n+\tcase LogicalTypeId::UTINYINT:\n+\tcase LogicalTypeId::USMALLINT:\n+\tcase LogicalTypeId::UINTEGER:\n+\tcase LogicalTypeId::UBIGINT:\n+\tcase LogicalTypeId::UHUGEINT:\n+\tcase LogicalTypeId::DATE:\n+\tcase LogicalTypeId::TIME:\n+\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\tcase LogicalTypeId::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\tcase LogicalTypeId::INTERVAL:\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\tcase LogicalTypeId::TIME_TZ:\n+\t\treturn true;\n+\tdefault:\n+\t\treturn false;\n+\t}\n+}\n+\n+bool BoundComparisonExpression::TryBindComparison(ClientContext &context, const LogicalType &left_type,\n+                                                  const LogicalType &right_type, LogicalType &result_type,\n+                                                  ExpressionType comparison_type) {\n+\tLogicalType res;\n+\tbool is_equality;\n+\tswitch (comparison_type) {\n+\tcase ExpressionType::COMPARE_EQUAL:\n+\tcase ExpressionType::COMPARE_NOTEQUAL:\n+\tcase ExpressionType::COMPARE_IN:\n+\tcase ExpressionType::COMPARE_NOT_IN:\n+\tcase ExpressionType::COMPARE_DISTINCT_FROM:\n+\tcase ExpressionType::COMPARE_NOT_DISTINCT_FROM:\n+\t\tis_equality = true;\n+\t\tbreak;\n+\tdefault:\n+\t\tis_equality = false;\n+\t\tbreak;\n+\t}\n+\tif (is_equality) {\n+\t\tres = LogicalType::ForceMaxLogicalType(left_type, right_type);\n+\t} else {\n+\t\tif (!LogicalType::TryGetMaxLogicalType(context, left_type, right_type, res)) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\tswitch (res.id()) {\n \tcase LogicalTypeId::DECIMAL: {\n \t\t// result is a decimal: we need the maximum width and the maximum scale over width\n \t\tvector<LogicalType> argument_types = {left_type, right_type};\n@@ -84,7 +137,8 @@ LogicalType BoundComparisonExpression::BindComparison(LogicalType left_type, Log\n \t\t\tuint8_t width, scale;\n \t\t\tauto can_convert = argument_types[i].GetDecimalProperties(width, scale);\n \t\t\tif (!can_convert) {\n-\t\t\t\treturn result_type;\n+\t\t\t\tresult_type = res;\n+\t\t\t\treturn true;\n \t\t\t}\n \t\t\tmax_width = MaxValue<uint8_t>(width, max_width);\n \t\t\tmax_scale = MaxValue<uint8_t>(scale, max_scale);\n@@ -95,14 +149,15 @@ LogicalType BoundComparisonExpression::BindComparison(LogicalType left_type, Log\n \t\t\t// target width does not fit in decimal: truncate the scale (if possible) to try and make it fit\n \t\t\tmax_width = Decimal::MAX_WIDTH_DECIMAL;\n \t\t}\n-\t\treturn LogicalType::DECIMAL(max_width, max_scale);\n+\t\tres = LogicalType::DECIMAL(max_width, max_scale);\n+\t\tbreak;\n \t}\n \tcase LogicalTypeId::VARCHAR:\n \t\t// for comparison with strings, we prefer to bind to the numeric types\n-\t\tif (left_type.IsNumeric() || left_type.id() == LogicalTypeId::BOOLEAN) {\n-\t\t\treturn left_type;\n-\t\t} else if (right_type.IsNumeric() || right_type.id() == LogicalTypeId::BOOLEAN) {\n-\t\t\treturn right_type;\n+\t\tif (left_type.id() != LogicalTypeId::VARCHAR && SwitchVarcharComparison(left_type)) {\n+\t\t\tres = left_type;\n+\t\t} else if (right_type.id() != LogicalTypeId::VARCHAR && SwitchVarcharComparison(right_type)) {\n+\t\t\tres = right_type;\n \t\t} else {\n \t\t\t// else: check if collations are compatible\n \t\t\tauto left_collation = StringType::GetCollation(left_type);\n@@ -111,10 +166,30 @@ LogicalType BoundComparisonExpression::BindComparison(LogicalType left_type, Log\n \t\t\t\tthrow BinderException(\"Cannot combine types with different collation!\");\n \t\t\t}\n \t\t}\n-\t\treturn result_type;\n+\t\tbreak;\n \tdefault:\n-\t\treturn result_type;\n+\t\tbreak;\n+\t}\n+\tresult_type = res;\n+\treturn true;\n+}\n+\n+LogicalType BoundComparisonExpression::BindComparison(ClientContext &context, const LogicalType &left_type,\n+                                                      const LogicalType &right_type, ExpressionType comparison_type) {\n+\tLogicalType result_type;\n+\tif (!BoundComparisonExpression::TryBindComparison(context, left_type, right_type, result_type, comparison_type)) {\n+\t\tthrow BinderException(\"Cannot mix values of type %s and %s - an explicit cast is required\",\n+\t\t                      left_type.ToString(), right_type.ToString());\n \t}\n+\treturn result_type;\n+}\n+\n+LogicalType ExpressionBinder::GetExpressionReturnType(const Expression &expr) {\n+\tif (expr.return_type == LogicalTypeId::VARCHAR && expr.expression_class == ExpressionClass::BOUND_CONSTANT &&\n+\t    StringType::GetCollation(expr.return_type).empty()) {\n+\t\treturn LogicalTypeId::STRING_LITERAL;\n+\t}\n+\treturn expr.return_type;\n }\n \n BindResult ExpressionBinder::BindExpression(ComparisonExpression &expr, idx_t depth) {\n@@ -129,11 +204,16 @@ BindResult ExpressionBinder::BindExpression(ComparisonExpression &expr, idx_t de\n \t// the children have been successfully resolved\n \tauto &left = BoundExpression::GetExpression(*expr.left);\n \tauto &right = BoundExpression::GetExpression(*expr.right);\n-\tauto left_sql_type = left->return_type;\n-\tauto right_sql_type = right->return_type;\n+\tauto left_sql_type = ExpressionBinder::GetExpressionReturnType(*left);\n+\tauto right_sql_type = ExpressionBinder::GetExpressionReturnType(*right);\n \t// cast the input types to the same type\n \t// now obtain the result type of the input types\n-\tauto input_type = BoundComparisonExpression::BindComparison(left_sql_type, right_sql_type);\n+\tLogicalType input_type;\n+\tif (!BoundComparisonExpression::TryBindComparison(context, left_sql_type, right_sql_type, input_type, expr.type)) {\n+\t\treturn BindResult(binder.FormatError(\n+\t\t    expr.query_location, \"Cannot compare values of type %s and type %s - an explicit cast is required\",\n+\t\t    left_sql_type.ToString(), right_sql_type.ToString()));\n+\t}\n \t// add casts (if necessary)\n \tleft = BoundCastExpression::AddCastToType(context, std::move(left), input_type,\n \t                                          input_type.id() == LogicalTypeId::ENUM);\ndiff --git a/src/planner/binder/expression/bind_operator_expression.cpp b/src/planner/binder/expression/bind_operator_expression.cpp\nindex 64f47f0cf9cd..c93dded40c79 100644\n--- a/src/planner/binder/expression/bind_operator_expression.cpp\n+++ b/src/planner/binder/expression/bind_operator_expression.cpp\n@@ -3,6 +3,7 @@\n #include \"duckdb/planner/expression/bound_case_expression.hpp\"\n #include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n #include \"duckdb/planner/expression/bound_comparison_expression.hpp\"\n+#include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n #include \"duckdb/planner/expression/bound_operator_expression.hpp\"\n #include \"duckdb/planner/expression/bound_parameter_expression.hpp\"\n@@ -10,61 +11,55 @@\n \n namespace duckdb {\n \n-static LogicalType ResolveNotType(OperatorExpression &op, vector<unique_ptr<Expression>> &children) {\n+LogicalType ExpressionBinder::ResolveNotType(OperatorExpression &op, vector<unique_ptr<Expression>> &children) {\n \t// NOT expression, cast child to BOOLEAN\n \tD_ASSERT(children.size() == 1);\n-\tchildren[0] = BoundCastExpression::AddDefaultCastToType(std::move(children[0]), LogicalType::BOOLEAN);\n+\tchildren[0] = BoundCastExpression::AddCastToType(context, std::move(children[0]), LogicalType::BOOLEAN);\n \treturn LogicalType(LogicalTypeId::BOOLEAN);\n }\n \n-static LogicalType ResolveInType(OperatorExpression &op, vector<unique_ptr<Expression>> &children,\n-                                 ClientContext &context) {\n+LogicalType ExpressionBinder::ResolveInType(OperatorExpression &op, vector<unique_ptr<Expression>> &children) {\n \tif (children.empty()) {\n \t\tthrow InternalException(\"IN requires at least a single child node\");\n \t}\n \t// get the maximum type from the children\n-\tLogicalType max_type = children[0]->return_type;\n-\tbool any_varchar = children[0]->return_type == LogicalType::VARCHAR;\n-\tbool any_enum = children[0]->return_type.id() == LogicalTypeId::ENUM;\n+\tLogicalType max_type = ExpressionBinder::GetExpressionReturnType(*children[0]);\n \tbool is_in_operator = (op.type == ExpressionType::COMPARE_IN || op.type == ExpressionType::COMPARE_NOT_IN);\n \tfor (idx_t i = 1; i < children.size(); i++) {\n+\t\tauto child_return = ExpressionBinder::GetExpressionReturnType(*children[i]);\n \t\tif (is_in_operator) {\n \t\t\t// If it's IN/NOT_IN operator, adjust DECIMAL and VARCHAR returned type.\n-\t\t\tmax_type = BoundComparisonExpression::BindComparison(max_type, children[i]->return_type);\n+\t\t\tif (!BoundComparisonExpression::TryBindComparison(context, max_type, child_return, max_type, op.type)) {\n+\t\t\t\tthrow BinderException(binder.FormatError(\n+\t\t\t\t    op.query_location,\n+\t\t\t\t    \"Cannot mix values of type %s and %s in %s clause - an explicit cast is required\",\n+\t\t\t\t    max_type.ToString(), child_return.ToString(),\n+\t\t\t\t    op.type == ExpressionType::COMPARE_IN ? \"IN\" : \"NOT IN\"));\n+\t\t\t}\n \t\t} else {\n \t\t\t// If it's COALESCE operator, don't do extra adjustment.\n-\t\t\tmax_type = LogicalType::MaxLogicalType(max_type, children[i]->return_type);\n-\t\t}\n-\t\tif (children[i]->return_type == LogicalType::VARCHAR) {\n-\t\t\tany_varchar = true;\n-\t\t}\n-\t\tif (children[i]->return_type.id() == LogicalTypeId::ENUM) {\n-\t\t\tany_enum = true;\n+\t\t\tif (!LogicalType::TryGetMaxLogicalType(context, max_type, child_return, max_type)) {\n+\t\t\t\tthrow BinderException(binder.FormatError(\n+\t\t\t\t    op.query_location,\n+\t\t\t\t    \"Cannot mix values of type %s and %s in COALESCE operator - an explicit cast is required\",\n+\t\t\t\t    max_type.ToString(), child_return.ToString()));\n+\t\t\t}\n \t\t}\n \t}\n \n-\t// If max_type is already VARCHAR, no need to adjust it incase it's IN/NOT_IN operator. Reassignment of max_type\n-\t// will cause collation information lost.\n-\tif (any_varchar && any_enum && max_type.id() != LogicalTypeId::VARCHAR) {\n-\t\t// For the coalesce function, we must be sure we always upcast the parameters to VARCHAR, if there are at least\n-\t\t// one enum and one varchar\n-\t\tmax_type = LogicalType::VARCHAR;\n-\t}\n-\n \t// cast all children to the same type\n-\tfor (idx_t i = 0; i < children.size(); i++) {\n-\t\tchildren[i] = BoundCastExpression::AddDefaultCastToType(std::move(children[i]), max_type);\n+\tfor (auto &child : children) {\n+\t\tchild = BoundCastExpression::AddCastToType(context, std::move(child), max_type);\n \t\tif (is_in_operator) {\n \t\t\t// If it's IN/NOT_IN operator, push collation functions.\n-\t\t\tExpressionBinder::PushCollation(context, children[i], max_type, true);\n+\t\t\tExpressionBinder::PushCollation(context, child, max_type, true);\n \t\t}\n \t}\n \t// (NOT) IN always returns a boolean\n \treturn LogicalType::BOOLEAN;\n }\n \n-static LogicalType ResolveOperatorType(OperatorExpression &op, vector<unique_ptr<Expression>> &children,\n-                                       ClientContext &context) {\n+LogicalType ExpressionBinder::ResolveOperatorType(OperatorExpression &op, vector<unique_ptr<Expression>> &children) {\n \tswitch (op.type) {\n \tcase ExpressionType::OPERATOR_IS_NULL:\n \tcase ExpressionType::OPERATOR_IS_NOT_NULL:\n@@ -75,9 +70,9 @@ static LogicalType ResolveOperatorType(OperatorExpression &op, vector<unique_ptr\n \t\treturn LogicalType::BOOLEAN;\n \tcase ExpressionType::COMPARE_IN:\n \tcase ExpressionType::COMPARE_NOT_IN:\n-\t\treturn ResolveInType(op, children, context);\n+\t\treturn ResolveInType(op, children);\n \tcase ExpressionType::OPERATOR_COALESCE: {\n-\t\tResolveInType(op, children, context);\n+\t\tResolveInType(op, children);\n \t\treturn children[0]->return_type;\n \t}\n \tcase ExpressionType::OPERATOR_NOT:\n@@ -181,7 +176,7 @@ BindResult ExpressionBinder::BindExpression(OperatorExpression &op, idx_t depth)\n \t\tchildren.push_back(std::move(BoundExpression::GetExpression(*op.children[i])));\n \t}\n \t// now resolve the types\n-\tLogicalType result_type = ResolveOperatorType(op, children, context);\n+\tLogicalType result_type = ResolveOperatorType(op, children);\n \tif (op.type == ExpressionType::OPERATOR_COALESCE) {\n \t\tif (children.empty()) {\n \t\t\tthrow BinderException(\"COALESCE needs at least one child\");\ndiff --git a/src/planner/binder/expression/bind_subquery_expression.cpp b/src/planner/binder/expression/bind_subquery_expression.cpp\nindex 9aa09ea5c948..4b8586c6c84f 100644\n--- a/src/planner/binder/expression/bind_subquery_expression.cpp\n+++ b/src/planner/binder/expression/bind_subquery_expression.cpp\n@@ -88,7 +88,14 @@ BindResult ExpressionBinder::BindExpression(SubqueryExpression &expr, idx_t dept\n \t\t// cast child and subquery child to equivalent types\n \t\tD_ASSERT(bound_node->types.size() == 1);\n \t\tauto &child = BoundExpression::GetExpression(*expr.child);\n-\t\tauto compare_type = LogicalType::MaxLogicalType(child->return_type, bound_node->types[0]);\n+\t\tauto child_type = ExpressionBinder::GetExpressionReturnType(*child);\n+\t\tLogicalType compare_type;\n+\t\tif (!LogicalType::TryGetMaxLogicalType(context, child_type, bound_node->types[0], compare_type)) {\n+\t\t\tthrow BinderException(binder.FormatError(\n+\t\t\t    expr, StringUtil::Format(\n+\t\t\t              \"Cannot compare values of type %s and %s in IN/ANY/ALL clause - an explicit cast is required\",\n+\t\t\t              child_type.ToString(), bound_node->types[0])));\n+\t\t}\n \t\tchild = BoundCastExpression::AddCastToType(context, std::move(child), compare_type);\n \t\tresult->child_type = bound_node->types[0];\n \t\tresult->child_target = compare_type;\ndiff --git a/src/planner/binder/expression/bind_window_expression.cpp b/src/planner/binder/expression/bind_window_expression.cpp\nindex 2b07c8673b7f..4a66a7fd78d0 100644\n--- a/src/planner/binder/expression/bind_window_expression.cpp\n+++ b/src/planner/binder/expression/bind_window_expression.cpp\n@@ -265,10 +265,10 @@ BindResult BaseSelectBinder::BindWindow(WindowExpression &window, idx_t depth) {\n \t\tauto &bound_order = BoundExpression::GetExpression(*order_expr);\n \t\tauto order_type = bound_order->return_type;\n \t\tif (window.start_expr) {\n-\t\t\torder_type = LogicalType::MaxLogicalType(order_type, start_type);\n+\t\t\torder_type = LogicalType::MaxLogicalType(context, order_type, start_type);\n \t\t}\n \t\tif (window.end_expr) {\n-\t\t\torder_type = LogicalType::MaxLogicalType(order_type, end_type);\n+\t\t\torder_type = LogicalType::MaxLogicalType(context, order_type, end_type);\n \t\t}\n \n \t\t// Cast all three to match\ndiff --git a/src/planner/binder/query_node/bind_setop_node.cpp b/src/planner/binder/query_node/bind_setop_node.cpp\nindex 1150ea4c8c48..0d8d4445f85f 100644\n--- a/src/planner/binder/query_node/bind_setop_node.cpp\n+++ b/src/planner/binder/query_node/bind_setop_node.cpp\n@@ -9,6 +9,7 @@\n #include \"duckdb/planner/expression_binder/order_binder.hpp\"\n #include \"duckdb/planner/query_node/bound_select_node.hpp\"\n #include \"duckdb/planner/query_node/bound_set_operation_node.hpp\"\n+#include \"duckdb/common/enum_util.hpp\"\n \n namespace duckdb {\n \n@@ -71,37 +72,37 @@ static void GatherAliases(BoundQueryNode &node, case_insensitive_map_t<idx_t> &a\n \t}\n }\n \n-static void BuildUnionByNameInfo(BoundSetOperationNode &result, bool can_contain_nulls) {\n+static void BuildUnionByNameInfo(ClientContext &context, BoundSetOperationNode &result, bool can_contain_nulls) {\n \tD_ASSERT(result.setop_type == SetOperationType::UNION_BY_NAME);\n \tcase_insensitive_map_t<idx_t> left_names_map;\n \tcase_insensitive_map_t<idx_t> right_names_map;\n \n-\tBoundQueryNode *left_node = result.left.get();\n-\tBoundQueryNode *right_node = result.right.get();\n+\tauto &left_node = *result.left;\n+\tauto &right_node = *result.right;\n \n \t// Build a name_map to use to check if a name exists\n \t// We throw a binder exception if two same name in the SELECT list\n-\tfor (idx_t i = 0; i < left_node->names.size(); ++i) {\n-\t\tif (left_names_map.find(left_node->names[i]) != left_names_map.end()) {\n+\tfor (idx_t i = 0; i < left_node.names.size(); ++i) {\n+\t\tif (left_names_map.find(left_node.names[i]) != left_names_map.end()) {\n \t\t\tthrow BinderException(\"UNION(ALL) BY NAME operation doesn't support same name in SELECT list\");\n \t\t}\n-\t\tleft_names_map[left_node->names[i]] = i;\n+\t\tleft_names_map[left_node.names[i]] = i;\n \t}\n \n-\tfor (idx_t i = 0; i < right_node->names.size(); ++i) {\n-\t\tif (right_names_map.find(right_node->names[i]) != right_names_map.end()) {\n+\tfor (idx_t i = 0; i < right_node.names.size(); ++i) {\n+\t\tif (right_names_map.find(right_node.names[i]) != right_names_map.end()) {\n \t\t\tthrow BinderException(\"UNION(ALL) BY NAME operation doesn't support same name in SELECT list\");\n \t\t}\n-\t\tif (left_names_map.find(right_node->names[i]) == left_names_map.end()) {\n-\t\t\tresult.names.push_back(right_node->names[i]);\n+\t\tif (left_names_map.find(right_node.names[i]) == left_names_map.end()) {\n+\t\t\tresult.names.push_back(right_node.names[i]);\n \t\t}\n-\t\tright_names_map[right_node->names[i]] = i;\n+\t\tright_names_map[right_node.names[i]] = i;\n \t}\n \n \tidx_t new_size = result.names.size();\n \tbool need_reorder = false;\n-\tvector<idx_t> left_reorder_idx(left_node->names.size());\n-\tvector<idx_t> right_reorder_idx(right_node->names.size());\n+\tvector<idx_t> left_reorder_idx(left_node.names.size());\n+\tvector<idx_t> right_reorder_idx(right_node.names.size());\n \n \t// Construct return type and reorder_idxs\n \t// reorder_idxs is used to gather correct alias_map\n@@ -113,20 +114,20 @@ static void BuildUnionByNameInfo(BoundSetOperationNode &result, bool can_contain\n \t\tbool right_exist = right_index != right_names_map.end();\n \t\tLogicalType result_type;\n \t\tif (left_exist && right_exist) {\n-\t\t\tresult_type = LogicalType::MaxLogicalType(left_node->types[left_index->second],\n-\t\t\t                                          right_node->types[right_index->second]);\n+\t\t\tresult_type = LogicalType::MaxLogicalType(context, left_node.types[left_index->second],\n+\t\t\t                                          right_node.types[right_index->second]);\n \t\t\tif (left_index->second != i || right_index->second != i) {\n \t\t\t\tneed_reorder = true;\n \t\t\t}\n \t\t\tleft_reorder_idx[left_index->second] = i;\n \t\t\tright_reorder_idx[right_index->second] = i;\n \t\t} else if (left_exist) {\n-\t\t\tresult_type = left_node->types[left_index->second];\n+\t\t\tresult_type = left_node.types[left_index->second];\n \t\t\tneed_reorder = true;\n \t\t\tleft_reorder_idx[left_index->second] = i;\n \t\t} else {\n \t\t\tD_ASSERT(right_exist);\n-\t\t\tresult_type = right_node->types[right_index->second];\n+\t\t\tresult_type = right_node.types[right_index->second];\n \t\t\tneed_reorder = true;\n \t\t\tright_reorder_idx[right_index->second] = i;\n \t\t}\n@@ -155,21 +156,21 @@ static void BuildUnionByNameInfo(BoundSetOperationNode &result, bool can_contain\n \t\t\tunique_ptr<Expression> right_reorder_expr;\n \t\t\tif (left_exist && right_exist) {\n \t\t\t\tleft_reorder_expr = make_uniq<BoundColumnRefExpression>(\n-\t\t\t\t    left_node->types[left_index->second], ColumnBinding(left_node->GetRootIndex(), left_index->second));\n+\t\t\t\t    left_node.types[left_index->second], ColumnBinding(left_node.GetRootIndex(), left_index->second));\n \t\t\t\tright_reorder_expr =\n-\t\t\t\t    make_uniq<BoundColumnRefExpression>(right_node->types[right_index->second],\n-\t\t\t\t                                        ColumnBinding(right_node->GetRootIndex(), right_index->second));\n+\t\t\t\t    make_uniq<BoundColumnRefExpression>(right_node.types[right_index->second],\n+\t\t\t\t                                        ColumnBinding(right_node.GetRootIndex(), right_index->second));\n \t\t\t} else if (left_exist) {\n \t\t\t\tleft_reorder_expr = make_uniq<BoundColumnRefExpression>(\n-\t\t\t\t    left_node->types[left_index->second], ColumnBinding(left_node->GetRootIndex(), left_index->second));\n+\t\t\t\t    left_node.types[left_index->second], ColumnBinding(left_node.GetRootIndex(), left_index->second));\n \t\t\t\t// create null value here\n \t\t\t\tright_reorder_expr = make_uniq<BoundConstantExpression>(Value(result.types[i]));\n \t\t\t} else {\n \t\t\t\tD_ASSERT(right_exist);\n \t\t\t\tleft_reorder_expr = make_uniq<BoundConstantExpression>(Value(result.types[i]));\n \t\t\t\tright_reorder_expr =\n-\t\t\t\t    make_uniq<BoundColumnRefExpression>(right_node->types[right_index->second],\n-\t\t\t\t                                        ColumnBinding(right_node->GetRootIndex(), right_index->second));\n+\t\t\t\t    make_uniq<BoundColumnRefExpression>(right_node.types[right_index->second],\n+\t\t\t\t                                        ColumnBinding(right_node.GetRootIndex(), right_index->second));\n \t\t\t}\n \t\t\tresult.left_reorder_exprs.push_back(std::move(left_reorder_expr));\n \t\t\tresult.right_reorder_exprs.push_back(std::move(right_reorder_expr));\n@@ -210,12 +211,11 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SetOperationNode &statement) {\n \t}\n \n \tif (result->setop_type == SetOperationType::UNION_BY_NAME) {\n-\t\tBuildUnionByNameInfo(*result, can_contain_nulls);\n-\n+\t\tBuildUnionByNameInfo(context, *result, can_contain_nulls);\n \t} else {\n \t\t// figure out the types of the setop result by picking the max of both\n \t\tfor (idx_t i = 0; i < result->left->types.size(); i++) {\n-\t\t\tauto result_type = LogicalType::MaxLogicalType(result->left->types[i], result->right->types[i]);\n+\t\t\tauto result_type = LogicalType::ForceMaxLogicalType(result->left->types[i], result->right->types[i]);\n \t\t\tif (!can_contain_nulls) {\n \t\t\t\tif (ExpressionBinder::ContainsNullType(result_type)) {\n \t\t\t\t\tresult_type = ExpressionBinder::ExchangeNullType(result_type);\ndiff --git a/src/planner/binder/tableref/bind_expressionlistref.cpp b/src/planner/binder/tableref/bind_expressionlistref.cpp\nindex a506764b208d..337458a649a6 100644\n--- a/src/planner/binder/tableref/bind_expressionlistref.cpp\n+++ b/src/planner/binder/tableref/bind_expressionlistref.cpp\n@@ -44,8 +44,14 @@ unique_ptr<BoundTableRef> Binder::Bind(ExpressionListRef &expr) {\n \t\tfor (idx_t list_idx = 0; list_idx < result->values.size(); list_idx++) {\n \t\t\tauto &list = result->values[list_idx];\n \t\t\tfor (idx_t val_idx = 0; val_idx < list.size(); val_idx++) {\n-\t\t\t\tresult->types[val_idx] =\n-\t\t\t\t    LogicalType::MaxLogicalType(result->types[val_idx], list[val_idx]->return_type);\n+\t\t\t\tauto &current_type = result->types[val_idx];\n+\t\t\t\tauto next_type = ExpressionBinder::GetExpressionReturnType(*list[val_idx]);\n+\t\t\t\tresult->types[val_idx] = LogicalType::MaxLogicalType(context, current_type, next_type);\n+\t\t\t}\n+\t\t}\n+\t\tfor (auto &type : result->types) {\n+\t\t\tif (type.id() == LogicalTypeId::STRING_LITERAL) {\n+\t\t\t\ttype = LogicalType::VARCHAR;\n \t\t\t}\n \t\t}\n \t\t// finally do another loop over the expressions and add casts where required\ndiff --git a/src/planner/binder/tableref/bind_pivot.cpp b/src/planner/binder/tableref/bind_pivot.cpp\nindex ed474f243683..3833711e9f56 100644\n--- a/src/planner/binder/tableref/bind_pivot.cpp\n+++ b/src/planner/binder/tableref/bind_pivot.cpp\n@@ -108,7 +108,8 @@ static unique_ptr<SelectNode> PivotFilteredAggregate(PivotRef &ref, vector<uniqu\n \t\tfor (auto &pivot_column : ref.pivots) {\n \t\t\tfor (auto &pivot_expr : pivot_column.pivot_expressions) {\n \t\t\t\tauto column_ref = make_uniq<CastExpression>(LogicalType::VARCHAR, pivot_expr->Copy());\n-\t\t\t\tauto constant_value = make_uniq<ConstantExpression>(pivot_value.values[pivot_value_idx++]);\n+\t\t\t\tauto constant_value = make_uniq<ConstantExpression>(\n+\t\t\t\t    pivot_value.values[pivot_value_idx++].DefaultCastAs(LogicalType::VARCHAR));\n \t\t\t\tauto comp_expr = make_uniq<ComparisonExpression>(ExpressionType::COMPARE_NOT_DISTINCT_FROM,\n \t\t\t\t                                                 std::move(column_ref), std::move(constant_value));\n \t\t\t\tif (filter) {\n@@ -559,7 +560,9 @@ unique_ptr<SelectNode> Binder::BindUnpivot(Binder &child_binder, PivotRef &ref,\n \t\tvector<unique_ptr<ParsedExpression>> expressions;\n \t\texpressions.reserve(unpivot.entries.size());\n \t\tfor (auto &entry : unpivot.entries) {\n-\t\t\texpressions.push_back(make_uniq<ColumnRefExpression>(entry.values[v_idx].ToString()));\n+\t\t\tauto colref = make_uniq<ColumnRefExpression>(entry.values[v_idx].ToString());\n+\t\t\tauto cast = make_uniq<CastExpression>(LogicalType::VARCHAR, std::move(colref));\n+\t\t\texpressions.push_back(std::move(cast));\n \t\t}\n \t\tunpivot_expressions.push_back(std::move(expressions));\n \t}\ndiff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp\nindex a3eddeacab63..0f5803e70a0d 100644\n--- a/src/planner/binder/tableref/bind_table_function.cpp\n+++ b/src/planner/binder/tableref/bind_table_function.cpp\n@@ -119,7 +119,7 @@ bool Binder::BindTableFunctionParameters(TableFunctionCatalogEntry &table_functi\n \t\t\t\terror = \"Unnamed parameters cannot come after named parameters\";\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\targuments.emplace_back(sql_type);\n+\t\t\targuments.emplace_back(constant.IsNull() ? LogicalType::SQLNULL : sql_type);\n \t\t\tparameters.emplace_back(std::move(constant));\n \t\t} else {\n \t\t\tnamed_parameters[parameter_name] = std::move(constant);\ndiff --git a/src/planner/expression/bound_cast_expression.cpp b/src/planner/expression/bound_cast_expression.cpp\nindex 1eca9b3f4031..ede876e7f981 100644\n--- a/src/planner/expression/bound_cast_expression.cpp\n+++ b/src/planner/expression/bound_cast_expression.cpp\n@@ -1,6 +1,7 @@\n #include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n #include \"duckdb/planner/expression/bound_default_expression.hpp\"\n #include \"duckdb/planner/expression/bound_parameter_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n #include \"duckdb/function/cast_rules.hpp\"\n #include \"duckdb/function/cast/cast_function_set.hpp\"\n #include \"duckdb/main/config.hpp\"\n@@ -28,7 +29,7 @@ BoundCastExpression::BoundCastExpression(ClientContext &context, unique_ptr<Expr\n \n unique_ptr<Expression> AddCastExpressionInternal(unique_ptr<Expression> expr, const LogicalType &target_type,\n                                                  BoundCastInfo bound_cast, bool try_cast) {\n-\tif (expr->return_type == target_type) {\n+\tif (ExpressionBinder::GetExpressionReturnType(*expr) == target_type) {\n \t\treturn expr;\n \t}\n \tauto &expr_type = expr->return_type;\n@@ -80,6 +81,12 @@ unique_ptr<Expression> AddCastToTypeInternal(unique_ptr<Expression> expr, const\n \t\tauto &def = expr->Cast<BoundDefaultExpression>();\n \t\tdef.return_type = target_type;\n \t}\n+\tif (expr->return_type.id() == LogicalTypeId::STRING_LITERAL) {\n+\t\t// when adding a cast to a string literal we need to transform the constant back into a VARCHAR\n+\t\tauto &constant = expr->Cast<BoundConstantExpression>();\n+\t\tconstant.value = Value(StringValue::Get(constant.value));\n+\t\tconstant.return_type = LogicalType::VARCHAR;\n+\t}\n \tif (!target_type.IsValid()) {\n \t\treturn expr;\n \t}\ndiff --git a/tools/pythonpkg/src/native/python_conversion.cpp b/tools/pythonpkg/src/native/python_conversion.cpp\nindex 2ae13cde8ac5..16a368d421c0 100644\n--- a/tools/pythonpkg/src/native/python_conversion.cpp\n+++ b/tools/pythonpkg/src/native/python_conversion.cpp\n@@ -98,8 +98,8 @@ Value TransformStructFormatDictionaryToMap(const PyDictionary &dict) {\n \t\tValue new_key = TransformPythonValue(dict.keys.attr(\"__getitem__\")(i));\n \t\tValue new_value = TransformPythonValue(dict.values.attr(\"__getitem__\")(i));\n \n-\t\tkey_type = LogicalType::MaxLogicalType(key_type, new_key.type());\n-\t\tvalue_type = LogicalType::MaxLogicalType(value_type, new_value.type());\n+\t\tkey_type = LogicalType::ForceMaxLogicalType(key_type, new_key.type());\n+\t\tvalue_type = LogicalType::ForceMaxLogicalType(value_type, new_value.type());\n \n \t\tchild_list_t<Value> struct_values;\n \t\tstruct_values.emplace_back(make_pair(\"key\", std::move(new_key)));\n@@ -141,8 +141,8 @@ Value TransformDictionaryToMap(const PyDictionary &dict, const LogicalType &targ\n \t\tValue new_key = ListValue::GetChildren(key_list)[i];\n \t\tValue new_value = ListValue::GetChildren(value_list)[i];\n \n-\t\tkey_type = LogicalType::MaxLogicalType(key_type, new_key.type());\n-\t\tvalue_type = LogicalType::MaxLogicalType(value_type, new_value.type());\n+\t\tkey_type = LogicalType::ForceMaxLogicalType(key_type, new_key.type());\n+\t\tvalue_type = LogicalType::ForceMaxLogicalType(value_type, new_value.type());\n \n \t\tchild_list_t<Value> struct_values;\n \t\tstruct_values.emplace_back(make_pair(\"key\", std::move(new_key)));\n@@ -196,7 +196,7 @@ Value TransformListValue(py::handle ele, const LogicalType &target_type = Logica\n \tfor (idx_t i = 0; i < size; i++) {\n \t\tauto &child_type = list_target ? ListType::GetChildType(target_type) : LogicalType::UNKNOWN;\n \t\tValue new_value = TransformPythonValue(ele.attr(\"__getitem__\")(i), child_type);\n-\t\telement_type = LogicalType::MaxLogicalType(element_type, new_value.type());\n+\t\telement_type = LogicalType::ForceMaxLogicalType(element_type, new_value.type());\n \t\tvalues.push_back(std::move(new_value));\n \t}\n \ndiff --git a/tools/pythonpkg/src/pandas/analyzer.cpp b/tools/pythonpkg/src/pandas/analyzer.cpp\nindex dd7992515654..6f5b4416cb18 100644\n--- a/tools/pythonpkg/src/pandas/analyzer.cpp\n+++ b/tools/pythonpkg/src/pandas/analyzer.cpp\n@@ -139,7 +139,7 @@ static bool UpgradeType(LogicalType &left, const LogicalType &right) {\n \t\t}\n \t}\n \t// If one of the types is map, this will set the resulting type to map\n-\tleft = LogicalType::MaxLogicalType(left, right);\n+\tleft = LogicalType::ForceMaxLogicalType(left, right);\n \treturn true;\n }\n \n",
  "test_patch": "diff --git a/test/api/test_reset.cpp b/test/api/test_reset.cpp\nindex 76d95606243f..9adaf05aba41 100644\n--- a/test/api/test_reset.cpp\n+++ b/test/api/test_reset.cpp\n@@ -56,6 +56,7 @@ OptionValueSet &GetValueForOption(const string &name) {\n \t    {\"debug_force_external\", {Value(true)}},\n \t    {\"debug_force_no_cross_product\", {Value(true)}},\n \t    {\"debug_force_external\", {Value(true)}},\n+\t    {\"old_implicit_casting\", {Value(true)}},\n \t    {\"prefer_range_joins\", {Value(true)}},\n \t    {\"allow_persistent_secrets\", {Value(false)}},\n \t    {\"secret_directory\", {\"/tmp/some/path\"}},\ndiff --git a/test/common/test_cast_struct.test b/test/common/test_cast_struct.test\nindex 8e7fce9558be..06104c70f15f 100644\n--- a/test/common/test_cast_struct.test\n+++ b/test/common/test_cast_struct.test\n@@ -121,10 +121,15 @@ select a::row(a integer, b string) r from (VALUES (ROW(1, 'asdf')), (ROW(4, 'fds\n {'a': 4, 'b': fdsa}\n \n statement error\n-select struct_extract({'a': a}, a) from range(10) tbl(a);\n+select struct_extract({'a': a}, a) from (select a::varchar as a from range(10) tbl(a));\n ----\n Key name for struct_extract needs to be a constant string\n \n+statement error\n+select struct_extract({'a': 42}, 42)\n+----\n+No function matches\n+\n # test string to struct within struct casting\n query I\n SELECT {a:{b:'{a:3, b: \"Hello World\"}'}}::STRUCT(a STRUCT(b STRUCT(a INT, b VARCHAR)));\ndiff --git a/test/fuzzer/duckfuzz/ordagg_nargs.test b/test/fuzzer/duckfuzz/ordagg_nargs.test\nindex 2171a8f7b770..261f2bbe5ce4 100644\n--- a/test/fuzzer/duckfuzz/ordagg_nargs.test\n+++ b/test/fuzzer/duckfuzz/ordagg_nargs.test\n@@ -14,6 +14,6 @@ SELECT cume_dist() OVER (ROWS\n \tAND regr_sxx(6311, 8320 \n \t\tORDER BY 1726 ASC NULLS FIRST, \n \t\t\t10101, \n-\t\t\t(TRY_CAST(946 AS INTEGER[]) BETWEEN 2053 AND 182) DESC NULLS LAST) \n+\t\t\t(946 BETWEEN 2053 AND 182) DESC NULLS LAST)\n \t\tFILTER (WHERE 118) PRECEDING\n \t)\ndiff --git a/test/fuzzer/duckfuzz/read_ndjson_non_varchar_input.test b/test/fuzzer/duckfuzz/read_ndjson_non_varchar_input.test\nindex 29eaa174e602..c71b6ac5233b 100644\n--- a/test/fuzzer/duckfuzz/read_ndjson_non_varchar_input.test\n+++ b/test/fuzzer/duckfuzz/read_ndjson_non_varchar_input.test\n@@ -10,9 +10,9 @@ PRAGMA enable_verification\n statement error\n FROM read_ndjson([42])\n ----\n-can only take a list of strings as a parameter\n+No function matches\n \n statement error\n FROM read_csv_auto([42])\n ----\n-can only take a list of strings as a parameter\n+No function matches\ndiff --git a/test/fuzzer/duckfuzz/regexp_replace_constant.test b/test/fuzzer/duckfuzz/regexp_replace_constant.test\nindex 5d8ca430daec..199368676162 100644\n--- a/test/fuzzer/duckfuzz/regexp_replace_constant.test\n+++ b/test/fuzzer/duckfuzz/regexp_replace_constant.test\n@@ -13,4 +13,4 @@ must not be NULL\n statement error\n SELECT regexp_extract('foobarbaz', 'B..', 0, 42);\n ----\n-must be a string\n+No function matches\ndiff --git a/test/fuzzer/duckfuzz/union_dict_tag.test b/test/fuzzer/duckfuzz/union_dict_tag.test\nindex ec18edff70e2..5b0632d95465 100644\n--- a/test/fuzzer/duckfuzz/union_dict_tag.test\n+++ b/test/fuzzer/duckfuzz/union_dict_tag.test\n@@ -6,4 +6,4 @@ statement ok\n create table all_types as select * exclude(small_enum, medium_enum, large_enum) from test_all_types();\n \n statement ok\n-SELECT encode(\"union\"), \"double\" FROM all_types where \"double\";\n+SELECT encode(\"union\"::varchar), \"double\" FROM all_types where \"double\";\ndiff --git a/test/fuzzer/pedro/buffer_manager_out_of_memory.test b/test/fuzzer/pedro/buffer_manager_out_of_memory.test\nindex 801f5c0ad4dd..49a9f262840f 100644\n--- a/test/fuzzer/pedro/buffer_manager_out_of_memory.test\n+++ b/test/fuzzer/pedro/buffer_manager_out_of_memory.test\n@@ -9,7 +9,7 @@ statement ok\n SET threads=8;\n \n statement ok\n-SELECT ((SELECT 1) EXCEPT (SELECT ('\\xF1\\x85\\x96\\xBA'::BLOB)::VARCHAR GROUP BY 1 ORDER BY 1));\n+SELECT ((SELECT 1::VARCHAR) EXCEPT (SELECT ('\\xF1\\x85\\x96\\xBA'::BLOB)::VARCHAR GROUP BY 1 ORDER BY 1));\n \n statement ok\n PRAGMA MEMORY_LIMIT='2MB';\ndiff --git a/test/fuzzer/pedro/complex_type_all_subquery.test b/test/fuzzer/pedro/complex_type_all_subquery.test\nindex 45c570b8b3f8..f88a8dcbbc68 100644\n--- a/test/fuzzer/pedro/complex_type_all_subquery.test\n+++ b/test/fuzzer/pedro/complex_type_all_subquery.test\n@@ -9,13 +9,13 @@ PRAGMA enable_verification\n statement error\n VALUES((0, 0) = ALL(SELECT 2));\n ----\n-Unimplemented\n+explicit cast is required\n \n # use ALL with complex types\n-query I\n+statement error\n SELECT {'a': 42} = ALL(SELECT {'a': '42'})\n ----\n-1\n+explicit cast is required\n \n foreach val 42 [1,2,3] {'a':42} {'a':[1,2,3],'b':'thisisalongstring'}\n \ndiff --git a/test/fuzzer/pedro/escaped_trim_function_call.test b/test/fuzzer/pedro/escaped_trim_function_call.test\nindex d74843943265..2ee6e7b44018 100644\n--- a/test/fuzzer/pedro/escaped_trim_function_call.test\n+++ b/test/fuzzer/pedro/escaped_trim_function_call.test\n@@ -6,7 +6,7 @@ statement ok\n PRAGMA enable_verification\n \n statement ok\n-SELECT \"trim\"(1);\n+SELECT \"trim\"('hello');\n \n statement ok\n-SELECT trim(1);\n+SELECT trim('hello');\ndiff --git a/test/fuzzer/pedro/like_empty_list.test b/test/fuzzer/pedro/like_empty_list.test\nindex ae232f01e41e..14876a009960 100644\n--- a/test/fuzzer/pedro/like_empty_list.test\n+++ b/test/fuzzer/pedro/like_empty_list.test\n@@ -5,22 +5,22 @@\n statement ok\n PRAGMA enable_verification\n \n-query I\n+statement error\n SELECT '1' LIKE [];\n ----\n-false\n+No function matches\n \n-query I\n+statement error\n SELECT [] LIKE 1;\n ----\n-false\n+No function matches\n \n-query I\n+statement error\n SELECT [] LIKE [];\n ----\n-true\n+No function matches\n \n-query I\n+statement error\n SELECT 1 FROM (SELECT 2) t1(c0) NATURAL RIGHT JOIN (SELECT 2) t0(c0) WHERE (0, t1.c0) NOT LIKE '0';\n ----\n-1\n+No function matches\ndiff --git a/test/fuzzer/pedro/pushdown_assertion_error.test b/test/fuzzer/pedro/pushdown_assertion_error.test\nindex fbe3a27d156a..58a579709795 100644\n--- a/test/fuzzer/pedro/pushdown_assertion_error.test\n+++ b/test/fuzzer/pedro/pushdown_assertion_error.test\n@@ -11,10 +11,12 @@ CREATE TABLE t2 (c2 INT);\n statement ok\n CREATE SEQUENCE t0;\n \n-query I\n+statement error\n SELECT 1 FROM t2 WHERE currval('t0') BETWEEN TRY_CAST(0 AS TIMESTAMP WITH TIME ZONE) AND 1;\n ----\n+explicit cast is required\n \n-query I\n+statement error\n SELECT 1 FROM t2 WHERE currval('t0') BETWEEN TRY_CAST(0 AS TIMESTAMP WITH TIME ZONE) AND -156587962151166338620429995158284936977;\n ----\n+explicit cast is required\ndiff --git a/test/fuzzer/sqlsmith/strptime_null_statistics.test b/test/fuzzer/sqlsmith/strptime_null_statistics.test\ndeleted file mode 100644\nindex 279a3f0d1998..000000000000\n--- a/test/fuzzer/sqlsmith/strptime_null_statistics.test\n+++ /dev/null\n@@ -1,12 +0,0 @@\n-# name: test/fuzzer/sqlsmith/strptime_null_statistics.test\n-# description: have you seen the fnords?\n-# group: [sqlsmith]\n-\n-statement ok\n-create table all_types as select * exclude(small_enum, medium_enum, large_enum) from test_all_types() limit 0;\n-\n-statement error\n-SELECT (COLUMNS(list_filter(*, (c6 -> strptime(c6, TRY_CAST(c3 AS BIGINT))))) BETWEEN c3 AND 6509) \n-FROM duckdb_databases() AS t5(c1, c2, c3, c4)\n-----\n-Binder Error: Star expression\ndiff --git a/test/issues/fuzz/argminmax_strings.test b/test/issues/fuzz/argminmax_strings.test\nindex bb32fdb20f41..09230ef36d8b 100644\n--- a/test/issues/fuzz/argminmax_strings.test\n+++ b/test/issues/fuzz/argminmax_strings.test\n@@ -15,6 +15,6 @@ CREATE TABLE i_class_id AS\n \tFROM range(1, 6, 1) t1(i_category_id);\n \n query II\n-select argmin(i_category_id,i_category_id), argmax(i_category_id,i_category_id) from i_class_id;\n+select argmin(i_category_id,i_category_id::VARCHAR), argmax(i_category_id, i_category_id::VARCHAR) from i_class_id;\n ----\n [1, 2, 3, 4, 5]\t[1, 2, 3, 4, 5]\ndiff --git a/test/issues/monetdb/groupings.test b/test/issues/monetdb/groupings.test\nindex 9ab80434fa7c..0e9d99ff87cb 100644\n--- a/test/issues/monetdb/groupings.test\n+++ b/test/issues/monetdb/groupings.test\n@@ -9,32 +9,32 @@ statement ok\n START TRANSACTION\n \n statement ok\n-CREATE TABLE categories (id INTEGER, \"description\" TEXT)\n+CREATE TABLE categories (id INTEGER, \"description\" TEXT);\n \n statement ok\n-CREATE TABLE sections (id INTEGER, \"description\" TEXT)\n+CREATE TABLE sections (id INTEGER, \"description\" TEXT);\n \n statement ok\n-CREATE TABLE products (id INTEGER, categoryid int, sectionid INTEGER, \"description\" TEXT, price DECIMAL(6,2))\n+CREATE TABLE products (id INTEGER, categoryid int, sectionid INTEGER, \"description\" TEXT, price DECIMAL(6,2));\n \n statement ok\n-CREATE TABLE sales (productid INTEGER, sale_day DATE, units INTEGER)\n+CREATE TABLE sales (productid INTEGER, sale_day DATE, units INTEGER);\n \n statement ok\n-INSERT INTO categories VALUES (1, 'fresh food'), (2, 'dry food'), (3, 'drinks')\n+INSERT INTO categories VALUES (1, 'fresh food'), (2, 'dry food'), (3, 'drinks');\n \n statement ok\n-INSERT INTO sections VALUES (1, 'front'), (2, 'side'), (3, 'back')\n+INSERT INTO sections VALUES (1, 'front'), (2, 'side'), (3, 'back');\n \n statement ok\n-INSERT INTO products VALUES (1, 1, 1, 'apples', 1.5), (2, 1, 2, 'melons', 4.0), (3, 2, 2, 'peanuts', 2.0), (4, 3, 1, 'water', 1.0), (5, 3, 3, 'wine', 5.0), (6, 2, 3, 'walnuts', 1.5)\n+INSERT INTO products VALUES (1, 1, 1, 'apples', 1.5), (2, 1, 2, 'melons', 4.0), (3, 2, 2, 'peanuts', 2.0), (4, 3, 1, 'water', 1.0), (5, 3, 3, 'wine', 5.0), (6, 2, 3, 'walnuts', 1.5);\n \n statement ok\n-INSERT INTO sales VALUES (1, date '2020-03-01', 10), (2, date '2020-03-01', 3), (4, date '2020-03-01', 4), (1, date '2020-03-02', 6), (4, date '2020-03-02', 5), (5, date '2020-03-02', 2), (1, date '2020-03-03', 7), (3, date '2020-03-03', 4), (2, date '2020-03-03', 3), (5, date '2020-03-03', 1), (6, date '2020-03-03', 1)\n+INSERT INTO sales VALUES (1, date '2020-03-01', 10), (2, date '2020-03-01', 3), (4, date '2020-03-01', 4), (1, date '2020-03-02', 6), (4, date '2020-03-02', 5), (5, date '2020-03-02', 2), (1, date '2020-03-03', 7), (3, date '2020-03-03', 4), (2, date '2020-03-03', 3), (5, date '2020-03-03', 1), (6, date '2020-03-03', 1);\n \n query TTR rowsort\n SELECT COALESCE(products.\"description\", 'all_products') AS \"description\",\n-       COALESCE(sale_day, 'all_days') AS sale_day,\n+       COALESCE(sale_day::VARCHAR, 'all_days') AS sale_day,\n        CAST(totals.total AS DECIMAL (12,4))\n FROM (\n     SELECT productid, sale_day, SUM(units * price) AS total\ndiff --git a/test/issues/rigger/complex_division.test b/test/issues/rigger/complex_division.test\nindex c27beb6b1a18..750c42e068eb 100644\n--- a/test/issues/rigger/complex_division.test\n+++ b/test/issues/rigger/complex_division.test\n@@ -40,7 +40,7 @@ SELECT c0, c1 FROM t0;\n \n \n query III\n-SELECT c0, c1, ((t0.c0)!~(((t0.c0)/(t0.c1)))) FROM t0;\n+SELECT c0, c1, ((t0.c0)::varchar!~(((t0.c0)/(t0.c1)))::varchar) FROM t0;\n ----\n 0.5\t0\tNULL\n 0.5\t1\tfalse\ndiff --git a/test/issues/rigger/expression_equality_bug.test b/test/issues/rigger/expression_equality_bug.test\nindex 86c78ad2c441..08a8393890e9 100644\n--- a/test/issues/rigger/expression_equality_bug.test\n+++ b/test/issues/rigger/expression_equality_bug.test\n@@ -8,5 +8,6 @@ PRAGMA enable_verification\n statement ok\n CREATE TABLE t0(c0 BOOLEAN DEFAULT(1168904737), c1 BOOLEAN DEFAULT(DATE '1969-12-28'), c2 DATE, PRIMARY KEY(c1, c2, c0));\n \n-statement ok\n+statement error\n SELECT t0.c0 FROM t0 WHERE (((t0.rowid)SIMILAR TO(TIMESTAMP '1970-01-11 11:17:02')) BETWEEN TIMESTAMP '1970-01-11 23:34:33' AND DATE '1970-01-20') UNION ALL SELECT t0.c0 FROM t0 WHERE (NOT (((t0.rowid)SIMILAR TO(TIMESTAMP '1970-01-11 11:17:02')) BETWEEN TIMESTAMP '1970-01-11 23:34:33' AND DATE '1970-01-20')) UNION ALL SELECT t0.c0 FROM t0 WHERE (((((t0.rowid)SIMILAR TO(TIMESTAMP '1970-01-11 11:17:02')) BETWEEN TIMESTAMP '1970-01-11 23:34:33' AND DATE '1970-01-20')) IS NULL);\n+----\ndiff --git a/test/issues/rigger/hugeint_div_by_zero.test b/test/issues/rigger/hugeint_div_by_zero.test\nindex 81fbd15c8e0b..6cbc014bc4bb 100644\n--- a/test/issues/rigger/hugeint_div_by_zero.test\n+++ b/test/issues/rigger/hugeint_div_by_zero.test\n@@ -84,4 +84,4 @@ statement ok\n INSERT INTO t1 VALUES(2139975183,0);\n \n statement ok\n-SELECT t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 FROM t1, t0 WHERE (((CASE ((t1.c0)*(0.537)) WHEN 0.09857124523209415 THEN (0.915585828038032 IN (t0.c2)) ELSE t1.c0 END )) IS NOT NULL) GROUP BY t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 UNION SELECT t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 FROM t1, t0 WHERE (NOT (((CASE ((t1.c0)*(0.537)) WHEN 0.09857124523209415 THEN (0.915585828038032 IN (t0.c2)) ELSE t1.c0 END )) IS NOT NULL)) GROUP BY t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 UNION SELECT t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 FROM t1, t0 WHERE (((((CASE ((t1.c0)*(0.537)) WHEN 0.09857124523209415 THEN (0.915585828038032 IN (t0.c2)) ELSE t1.c0 END )) IS NOT NULL)) IS NULL) GROUP BY t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 ORDER BY 1, 2, 3, 4, 5;\n+SELECT t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 FROM t1, t0 WHERE (((CASE ((t1.c0)*(0.537)) WHEN 0.09857124523209415 THEN (0.915585828038032::VARCHAR IN (t0.c2)) ELSE t1.c0 END )) IS NOT NULL) GROUP BY t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 UNION SELECT t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 FROM t1, t0 WHERE (NOT (((CASE ((t1.c0)*(0.537)) WHEN 0.09857124523209415 THEN (0.915585828038032::VARCHAR IN (t0.c2)) ELSE t1.c0 END )) IS NOT NULL)) GROUP BY t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 UNION SELECT t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 FROM t1, t0 WHERE (((((CASE ((t1.c0)*(0.537)) WHEN 0.09857124523209415 THEN (0.915585828038032::VARCHAR IN (t0.c2)) ELSE t1.c0 END )) IS NOT NULL)) IS NULL) GROUP BY t1.c0, t1.c1, t0.c2, t0.c0, t0.c1 ORDER BY 1, 2, 3, 4, 5;\ndiff --git a/test/issues/rigger/rowid_conjunction.test b/test/issues/rigger/rowid_conjunction.test\nindex 901d9bc617b5..83161e8ab46e 100644\n--- a/test/issues/rigger/rowid_conjunction.test\n+++ b/test/issues/rigger/rowid_conjunction.test\n@@ -14,7 +14,7 @@ CREATE TABLE t0(c0 TINYINT);\n statement ok\n INSERT INTO t0 VALUES (1), (2), (3), (NULL);\n \n-query I\n+statement error\n SELECT * FROM t0 WHERE (((0.7839485854397868 BETWEEN false AND PRINTF(((0.8341154324178778)NOT SIMILAR TO(t0.c0)), NULL, ((0.9015841357551267) ::VARCHAR), DATE '1969-12-25')))AND(t0.rowid))\n UNION\n SELECT * FROM t0 WHERE (NOT (((0.7839485854397868 BETWEEN false AND PRINTF(((0.8341154324178778)NOT SIMILAR TO(t0.c0)), NULL, ((0.9015841357551267) ::VARCHAR), DATE '1969-12-25')))AND(t0.rowid)))\n@@ -22,10 +22,6 @@ UNION\n SELECT * FROM t0 WHERE (((((0.7839485854397868 BETWEEN false AND PRINTF(((0.8341154324178778)NOT SIMILAR TO(t0.c0)), NULL, ((0.9015841357551267) ::VARCHAR), DATE '1969-12-25')))AND(t0.rowid))) IS NULL)\n ORDER BY 1\n ----\n-NULL\n-1\n-2\n-3\n \n query I\n SELECT DISTINCT * FROM t0 ORDER BY 1\ndiff --git a/test/issues/rigger/test_510.test b/test/issues/rigger/test_510.test\nindex d7e1b5653fb8..2ec98c49e5d9 100644\n--- a/test/issues/rigger/test_510.test\n+++ b/test/issues/rigger/test_510.test\n@@ -18,17 +18,17 @@ SELECT '-10' SIMILAR TO '0';\n 0\n \n query T\n-SELECT t0.c0 SIMILAR TO 0 FROM t0;\n+SELECT cast(t0.c0 as varchar) SIMILAR TO cast(0 as varchar) FROM t0;\n ----\n 0\n \n query T\n-SELECT t0.c0 NOT SIMILAR TO 0 FROM t0;\n+SELECT t0.c0::VARCHAR NOT SIMILAR TO 0::VARCHAR FROM t0;\n ----\n 1\n \n query I\n-SELECT * FROM t0 WHERE t0.c0 NOT SIMILAR TO 0;\n+SELECT * FROM t0 WHERE t0.c0::VARCHAR NOT SIMILAR TO 0::VARCHAR;\n ----\n -10\n \ndiff --git a/test/issues/rigger/test_535.test b/test/issues/rigger/test_535.test\nindex bfa76591313f..d55f0dbb953d 100644\n--- a/test/issues/rigger/test_535.test\n+++ b/test/issues/rigger/test_535.test\n@@ -19,7 +19,7 @@ statement ok\n CREATE INDEX i0 ON t0(c0);\n \n query R\n-SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0) ORDER BY 1;\n+SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0::VARCHAR) ORDER BY 1;\n ----\n -515965088.000000\n 1.000000\ndiff --git a/test/issues/rigger/test_547.test b/test/issues/rigger/test_547.test\nindex 57e431de0a1b..1bbe1479a743 100644\n--- a/test/issues/rigger/test_547.test\n+++ b/test/issues/rigger/test_547.test\n@@ -13,7 +13,7 @@ statement ok\n INSERT INTO t0 VALUES (0);\n \n query I\n-SELECT * FROM t0 WHERE t0.c0 SIMILAR TO '.';\n+SELECT * FROM t0 WHERE cast(t0.c0 as varchar) SIMILAR TO '.';\n ----\n 0\n \ndiff --git a/test/issues/rigger/test_549.test b/test/issues/rigger/test_549.test\nindex 60d7a79261c2..c181f4d32f7a 100644\n--- a/test/issues/rigger/test_549.test\n+++ b/test/issues/rigger/test_549.test\n@@ -16,10 +16,7 @@ statement error\n SELECT * FROM t0 WHERE CASE WHEN c0 THEN 0 ELSE CASE '0.1' WHEN c0 THEN '' END END;\n ----\n \n-query T\n+statement error\n SELECT CASE WHEN c0 THEN 0 ELSE (CASE '0' WHEN c0 THEN '0.6' END) END FROM t0;\n ----\n-NULL\n-0.6\n-0\n-\n+Cannot mix values of type\ndiff --git a/test/issues/rigger/test_580.test b/test/issues/rigger/test_580.test\nindex e0ec89d43398..2f5ee6cdd257 100644\n--- a/test/issues/rigger/test_580.test\n+++ b/test/issues/rigger/test_580.test\n@@ -7,7 +7,7 @@ PRAGMA enable_verification\n \n # SUBSTRING with an invalid start position causes a segmentation fault #580\n query T\n-SELECT SUBSTRING(0, 3, 0)\n+SELECT SUBSTRING(0::VARCHAR, 3, 0)\n ----\n (empty)\n \ndiff --git a/test/issues/rigger/test_583.test b/test/issues/rigger/test_583.test\nindex d51d61cdaf58..c7283bafb3d1 100644\n--- a/test/issues/rigger/test_583.test\n+++ b/test/issues/rigger/test_583.test\n@@ -20,7 +20,6 @@ UPDATE t0 SET c0=true;\n \n # -- expected: {true}, actual: {}\n query T\n-SELECT * FROM t0 WHERE t0.c0 = true;\n+SELECT * FROM t0 WHERE t0.c0 = true::varchar;\n ----\n true\n-\ndiff --git a/test/issues/rigger/test_584.test b/test/issues/rigger/test_584.test\nindex e51e7ff6adf0..f96e5a0afb24 100644\n--- a/test/issues/rigger/test_584.test\n+++ b/test/issues/rigger/test_584.test\n@@ -13,7 +13,7 @@ statement ok\n INSERT INTO t0(c0) VALUES (-2);\n \n query I\n-SELECT t0.c0 FROM t0 WHERE -1 BETWEEN t0.c0::VARCHAR AND 1;\n+SELECT t0.c0 FROM t0 WHERE -1 BETWEEN t0.c0::VARCHAR::INTEGER AND 1;\n ----\n -2\n \ndiff --git a/test/issues/rigger/test_590.test b/test/issues/rigger/test_590.test\nindex 47c3d0140cea..f8b4f79a415e 100644\n--- a/test/issues/rigger/test_590.test\n+++ b/test/issues/rigger/test_590.test\n@@ -13,7 +13,6 @@ statement ok\n INSERT INTO t0(c0) VALUES (DATE '2000-01-02');\n \n query T\n-SELECT * FROM t0 WHERE DATE '2000-01-01' < t0.c0;\n+SELECT * FROM t0 WHERE DATE '2000-01-01' < cast(t0.c0 as date);\n ----\n 2000-01-02\n-\ndiff --git a/test/issues/rigger/test_592.test b/test/issues/rigger/test_592.test\nindex 5c0260f828d4..56e36e95d8c6 100644\n--- a/test/issues/rigger/test_592.test\n+++ b/test/issues/rigger/test_592.test\n@@ -13,6 +13,5 @@ statement ok\n INSERT INTO t0 VALUES (0);\n \n query T\n-SELECT * FROM t0 WHERE c0 LIKE '' AND c0 < true;\n+SELECT * FROM t0 WHERE c0 LIKE '' AND c0 < true::VARCHAR;\n ----\n-\ndiff --git a/test/issues/rigger/test_603.test b/test/issues/rigger/test_603.test\nindex a7092d991282..4ee527a1244e 100644\n--- a/test/issues/rigger/test_603.test\n+++ b/test/issues/rigger/test_603.test\n@@ -13,6 +13,5 @@ statement ok\n INSERT INTO t0(c0) VALUES (NULL), ('2000-01-01');\n \n query TT\n-SELECT * FROM t0 WHERE 'a' BETWEEN c0 AND c1 COLLATE NOACCENT.NOCASE;\n+SELECT * FROM t0 WHERE 'a' BETWEEN c0::VARCHAR AND c1 COLLATE NOACCENT.NOCASE;\n ----\n-\ndiff --git a/test/issues/rigger/test_633.test b/test/issues/rigger/test_633.test\nindex 65c6ae418492..217fd4becd9b 100644\n--- a/test/issues/rigger/test_633.test\n+++ b/test/issues/rigger/test_633.test\n@@ -13,12 +13,12 @@ statement ok\n INSERT INTO t0(c0) VALUES (NULL);\n \n query T\n-SELECT LEFT(t0.c0, -1) FROM t0;\n+SELECT LEFT(t0.c0::VARCHAR, -1) FROM t0;\n ----\n NULL\n \n query T\n-SELECT RIGHT(t0.c0, -1) FROM t0;\n+SELECT RIGHT(t0.c0::VARCHAR, -1) FROM t0;\n ----\n NULL\n \ndiff --git a/test/issues/rigger/test_value_binop.test b/test/issues/rigger/test_value_binop.test\nindex 939c24df85e3..ddeee52b98aa 100644\n--- a/test/issues/rigger/test_value_binop.test\n+++ b/test/issues/rigger/test_value_binop.test\n@@ -11,5 +11,7 @@ CREATE TABLE t0(c0 DATE, c1 SMALLINT);\n statement ok\n CREATE TABLE t1(c0 NUMERIC, c1 DATE DEFAULT(true), PRIMARY KEY(c1));\n \n-statement ok\n+statement error\n SELECT COUNT((NOT IFNULL((CASE ((t0.rowid)+(0.250079098209133)) WHEN '0.3133638032049081' THEN t0.rowid WHEN t0.rowid THEN (((- t0.rowid)) IS NULL) ELSE (('1654422017')||((t0.rowid IN (false, '6\u3e6c', TIMESTAMP '1970-01-25 20:11:23')))) END ), DATE '1970-01-12'))) FROM t0;\n+----\n+Cannot mix values of type\ndiff --git a/test/issues/rigger/zonemap_column_out_of_range.test b/test/issues/rigger/zonemap_column_out_of_range.test\nindex d4cd766a9ba4..9da54d8f8e6b 100644\n--- a/test/issues/rigger/zonemap_column_out_of_range.test\n+++ b/test/issues/rigger/zonemap_column_out_of_range.test\n@@ -15,7 +15,7 @@ statement ok\n INSERT INTO t0 VALUES(0.0,NULL);\n \n query III\n-SELECT t0.rowid, t0.c0, t0.c1 FROM t0 WHERE (t0.c1 IN (true, 0.478943091545613)) GROUP BY t0.rowid, t0.c0, t0.c1 UNION SELECT t0.rowid, t0.c0, t0.c1 FROM t0 WHERE (NOT (t0.c1 IN (true, 0.478943091545613))) GROUP BY t0.rowid, t0.c0, t0.c1 UNION SELECT t0.rowid, t0.c0, t0.c1 FROM t0 WHERE (((t0.c1 IN (true, 0.478943091545613))) IS NULL) GROUP BY t0.rowid, t0.c0, t0.c1 ORDER BY 1, 2, 3;\n+SELECT t0.rowid, t0.c0, t0.c1 FROM t0 WHERE (t0.c1 IN (true::DOUBLE, 0.478943091545613)) GROUP BY t0.rowid, t0.c0, t0.c1 UNION SELECT t0.rowid, t0.c0, t0.c1 FROM t0 WHERE (NOT (t0.c1 IN (true::DOUBLE, 0.478943091545613))) GROUP BY t0.rowid, t0.c0, t0.c1 UNION SELECT t0.rowid, t0.c0, t0.c1 FROM t0 WHERE (((t0.c1 IN (true::DOUBLE, 0.478943091545613))) IS NULL) GROUP BY t0.rowid, t0.c0, t0.c1 ORDER BY 1, 2, 3;\n ----\n 0\t0\t1\n 1\t0\tNULL\ndiff --git a/test/optimizer/unnest_rewriter.test b/test/optimizer/unnest_rewriter.test\nindex 650f6a2982da..c8cf268cc723 100644\n--- a/test/optimizer/unnest_rewriter.test\n+++ b/test/optimizer/unnest_rewriter.test\n@@ -35,7 +35,7 @@ SELECT UNNEST(j) FROM (VALUES ([[1, 2, 3]]), ([[4, 5]])) t(i), (SELECT UNNEST(i)\n \n query I\n with stage1 as (\n-  SELECT r, md5(r) as h, gen_random_uuid() as id\n+  SELECT r, md5(r::varchar) as h, gen_random_uuid() as id\n   FROM (SELECT UNNEST(GENERATE_SERIES(1,10,1)) r ))\n , stage2 as (\n   SELECT a.*, list({r:b.r, h:b.h, id: gen_random_uuid()}) as sub\n@@ -99,7 +99,7 @@ logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n \n query II\n EXPLAIN with stage1 as (\n-  SELECT r, md5(r) as h, gen_random_uuid() as id\n+  SELECT r, md5(r::VARCHAR) as h, gen_random_uuid() as id\n   FROM (SELECT UNNEST(GENERATE_SERIES(1,10,1)) r ))\n , stage2 as (\n   SELECT a.*, list({r:b.r, h:b.h, id: gen_random_uuid()}) as sub\ndiff --git a/test/optimizer/zonemaps.test b/test/optimizer/zonemaps.test\nindex 47b25410f8b9..90c38c949f9f 100644\n--- a/test/optimizer/zonemaps.test\n+++ b/test/optimizer/zonemaps.test\n@@ -9,7 +9,7 @@ statement ok\n PRAGMA explain_output = PHYSICAL_ONLY;\n \n statement ok\n-create temporary table t as select range a, length(range) b, mod(range,10000) c, 5 d, 10000 e from range(100000);\n+create temporary table t as select range a, length(range::varchar) b, mod(range,10000) c, 5 d, 10000 e from range(100000);\n \n # 1) In-clause based on in-clause range/boundary zonemap check\n query II\ndiff --git a/test/sakila/test_sakila.test_slow b/test/sakila/test_sakila.test_slow\nindex 1c5ef2d58547..0b1d577ebf89 100644\n--- a/test/sakila/test_sakila.test_slow\n+++ b/test/sakila/test_sakila.test_slow\n@@ -213,7 +213,7 @@ SELECT\n     a.phone AS phone,\n     city.city AS city,\n     country.country AS country,\n-    CASE WHEN cu.active = 1 THEN\n+    CASE WHEN cu.active = 'Y' THEN\n         'active'\n     ELSE\n         ''\n@@ -392,7 +392,7 @@ Jon\tStephens\t1411 Lillydale Drive\n Mike\tHillyer\t23 Workhaven Lane\n \n query TTR\n-SELECT first_name, last_name, SUM(amount) as total FROM staff INNER JOIN payment ON staff.staff_id = payment.staff_id AND payment_date LIKE '2005-08%' GROUP BY first_name, last_name ORDER BY total\n+SELECT first_name, last_name, SUM(amount) as total FROM staff INNER JOIN payment ON staff.staff_id = payment.staff_id AND payment_date::VARCHAR LIKE '2005-08%' GROUP BY first_name, last_name ORDER BY total\n ----\n Mike\tHillyer\t11853.650000\n Jon\tStephens\t12218.480000\ndiff --git a/test/sql/aggregate/aggregates/test_aggregate_types.test b/test/sql/aggregate/aggregates/test_aggregate_types.test\nindex 02d39f21fdc7..70eee7195f86 100644\n--- a/test/sql/aggregate/aggregates/test_aggregate_types.test\n+++ b/test/sql/aggregate/aggregates/test_aggregate_types.test\n@@ -53,7 +53,7 @@ world r\n \n # complex agg with distinct and order by and conversion from int to string\n query IIITTT\n-SELECT g, COUNT(*), COUNT(s), MIN(s), MAX(s), STRING_AGG(DISTINCT g ORDER BY g DESC) FROM strings GROUP BY g ORDER BY g;\n+SELECT g, COUNT(*), COUNT(s), MIN(s), MAX(s), STRING_AGG(DISTINCT g::VARCHAR ORDER BY g DESC) FROM strings GROUP BY g ORDER BY g;\n ----\n 0\n 2\ndiff --git a/test/sql/aggregate/aggregates/test_aggregate_types_scalar.test b/test/sql/aggregate/aggregates/test_aggregate_types_scalar.test\nindex bcd14c66b095..0a812e448eab 100644\n--- a/test/sql/aggregate/aggregates/test_aggregate_types_scalar.test\n+++ b/test/sql/aggregate/aggregates/test_aggregate_types_scalar.test\n@@ -145,12 +145,12 @@ statement ok\n INSERT INTO test_val VALUES(1), (2), (3), (3), (2)\n \n query T\n-SELECT STRING_AGG(DISTINCT val ORDER BY val DESC) from test_val;\n+SELECT STRING_AGG(DISTINCT val::VARCHAR ORDER BY val DESC) from test_val;\n ----\n 3,2,1\n \n query IT\n-SELECT COUNT(NULL), STRING_AGG(DISTINCT val ORDER BY val ASC) from test_val;\n+SELECT COUNT(NULL), STRING_AGG(DISTINCT val::VARCHAR ORDER BY val ASC) from test_val;\n ----\n 0\n 1,2,3\ndiff --git a/test/sql/aggregate/aggregates/test_arg_min_max.test b/test/sql/aggregate/aggregates/test_arg_min_max.test\nindex 9475bb870bdc..d232b6335384 100644\n--- a/test/sql/aggregate/aggregates/test_arg_min_max.test\n+++ b/test/sql/aggregate/aggregates/test_arg_min_max.test\n@@ -94,7 +94,7 @@ select argmin(b,a), argmax(b,a)  from blobs ;\n \\xAA\\xFF\\xAA\t\\xAA\\xFF\\xAA\\xAA\\xFF\\xAA\n \n query II\n-select argmin(a,b), argmax(a,b)  from blobs ;\n+select argmin(a,b), argmax(a,b)  from blobs;\n ----\n 5\t20\n \ndiff --git a/test/sql/aggregate/aggregates/test_perfect_ht.test b/test/sql/aggregate/aggregates/test_perfect_ht.test\nindex df5b648e9562..14078d954c23 100644\n--- a/test/sql/aggregate/aggregates/test_perfect_ht.test\n+++ b/test/sql/aggregate/aggregates/test_perfect_ht.test\n@@ -35,7 +35,7 @@ NULL\t1\t1\t1\n \n # use aggregates with destructors\n query III\n-SELECT year, LIST(val), STRING_AGG(val, ',') FROM timeseries GROUP BY year ORDER BY year;\n+SELECT year, LIST(val), STRING_AGG(val::VARCHAR, ',') FROM timeseries GROUP BY year ORDER BY year;\n ----\n NULL\t[1]\t1\n 1996\t[10, 20, NULL]\t10,20\ndiff --git a/test/sql/aggregate/aggregates/test_string_agg.test b/test/sql/aggregate/aggregates/test_string_agg.test\nindex b8fd17b87eb7..54b5b3f28f90 100644\n--- a/test/sql/aggregate/aggregates/test_string_agg.test\n+++ b/test/sql/aggregate/aggregates/test_string_agg.test\n@@ -18,7 +18,7 @@ SELECT STRING_AGG()\n ----\n \n statement error\n-SELECT STRING_AGG(1, 2, 3)\n+SELECT STRING_AGG('a', 'b', 'c')\n ----\n \n statement error\n@@ -66,11 +66,11 @@ SELECT STRING_AGG(x,',') FROM strings WHERE g > 100\n ----\n NULL\n \n-# numerics are auto cast to strings\n-query T\n+# numerics are not auto cast to strings\n+statement error\n SELECT STRING_AGG(1, 2)\n ----\n-1\n+No function matches\n \n # group concat is an alias for string_agg\n query T\ndiff --git a/test/sql/binder/old_implicit_cast.test b/test/sql/binder/old_implicit_cast.test\nnew file mode 100644\nindex 000000000000..355cbe632701\n--- /dev/null\n+++ b/test/sql/binder/old_implicit_cast.test\n@@ -0,0 +1,39 @@\n+# name: test/sql/binder/old_implicit_cast.test\n+# description: Test old_implicit_cast setting\n+# group: [binder]\n+\n+statement ok\n+CREATE TABLE integers AS SELECT 42 AS i, '5' AS v;\n+\n+statement error\n+SELECT i >= v FROM integers\n+----\n+an explicit cast is required\n+\n+statement error\n+SELECT i[1] FROM integers\n+----\n+No function matches\n+\n+statement error\n+SELECT [i, v] FROM integers\n+----\n+an explicit cast is required\n+\n+statement ok\n+SET old_implicit_casting=true\n+\n+query I\n+SELECT i[1] FROM integers\n+----\n+4\n+\n+query I\n+SELECT i >= v FROM integers\n+----\n+true\n+\n+query I\n+SELECT [i, v] FROM integers\n+----\n+[42, 5]\ndiff --git a/test/sql/binder/string_literal_binding.test b/test/sql/binder/string_literal_binding.test\nnew file mode 100644\nindex 000000000000..71fc22143eb2\n--- /dev/null\n+++ b/test/sql/binder/string_literal_binding.test\n@@ -0,0 +1,109 @@\n+# name: test/sql/binder/string_literal_binding.test\n+# description: Test string literal binding\n+# group: [binder]\n+\n+# string literals bind differently from strings\n+# they can be auto-cast to everything\n+# this is an integer comparison\n+query I\n+select '01'=1;\n+----\n+true\n+\n+query I\n+SELECT cos('0')\n+----\n+1\n+\n+# date comparison\n+query I\n+select date '1992-01-01'>'1991-01-01';\n+----\n+true\n+\n+# Issue #9948 - this is a date comparison, and (2023-12-11 < 2023-12-11) = false\n+query I\n+select date '2023-12-11' < '2023-12-11 15:54:45.119';\n+----\n+false\n+\n+# Issue #8529 - Inconsistent Date Partition Handling Between DuckDB and PostgreSQL\n+statement ok\n+CREATE TABLE test (\n+    \"date\" DATE,\n+    value VARCHAR\n+);\n+\n+statement ok\n+INSERT INTO test VALUES ('2023-08-01', 1), ('2023-08-02', 2), ('2023-08-03', 3), ('2023-08-04', 4), ('2023-08-05', 5), ('2023-08-06', 6), ('2023-08-07', 7);\n+\n+query II\n+SELECT * FROM test WHERE date >= '2023-08-05 00:00:00' AND date < '2023-08-06 00:00:00';\n+----\n+2023-08-05\t5\n+\n+# literals prefer to be strings\n+query I\n+SELECT '[hello]'[1];\n+----\n+[\n+\n+query I\n+SELECT list('hello world')\n+----\n+[hello world]\n+\n+# literals in IN clause work correctly\n+query I\n+select 1 IN ('1', '2');\n+----\n+true\n+\n+# as does COALESCE with string literals\n+query I\n+SELECT COALESCE(1, '1');\n+----\n+1\n+\n+# we can do equality comparison with string columns\n+query I\n+select i=1 from (values ('01')) t(i);\n+----\n+true\n+\n+# or with an IN clause\n+query I\n+select i IN (1) from (values ('01')) t(i);\n+----\n+true\n+\n+# consistency between IN and equality\n+query I\n+WITH cte AS (SELECT '01' AS s)\n+SELECT 1=s AS in_res FROM cte;\n+----\n+true\n+\n+query I\n+WITH cte AS (SELECT '01' AS s)\n+SELECT 1 IN (s) AS in_res FROM cte;\n+----\n+true\n+\n+# but not >\n+statement error\n+select i>1 from (values ('01')) t(i);\n+----\n+an explicit cast is required\n+\n+# we cannot do the same comparison with string columns\n+statement error\n+select date '1992-01-01'>i from (values ('1991-01-01')) t(i);\n+----\n+Cannot compare values of type\n+\n+# we cannot subscript dates or other types\n+statement error\n+select d[1] from (values (date '1992-01-01')) t(d);\n+----\n+No function matches the given name and argument types\ndiff --git a/test/sql/binder/test_function_chainging_alias.test b/test/sql/binder/test_function_chainging_alias.test\nindex b1ebd44d81a4..b93a8b409e93 100644\n--- a/test/sql/binder/test_function_chainging_alias.test\n+++ b/test/sql/binder/test_function_chainging_alias.test\n@@ -64,7 +64,7 @@ INSERT INTO varchars VALUES ('Test Function Chainging Alias');\n \n # list\n query III\n-SELECT  v.split(' ') strings,\n+SELECT  v.split(' ')::VARCHAR strings,\n         strings.lower() lower,\n         lower.upper() upper\n FROM varchars\n@@ -83,8 +83,8 @@ FROM varchars\n # prepared statements\n statement ok\n PREPARE v1 AS \n-SELECT ?.split(' ').lower() lstrings,\n-       ?.split(' ').upper() ustrings,\n+SELECT (?.split(' ')::VARCHAR).lower() lstrings,\n+       (?.split(' ')::VARCHAR).upper() ustrings,\n        list_concat(lstrings::VARCHAR[], ustrings::VARCHAR[]) as mix_case_srings\n \n query III\ndiff --git a/test/sql/catalog/function/test_simple_macro.test b/test/sql/catalog/function/test_simple_macro.test\nindex 973ef117bc3e..93d96c21ee5e 100644\n--- a/test/sql/catalog/function/test_simple_macro.test\n+++ b/test/sql/catalog/function/test_simple_macro.test\n@@ -182,7 +182,7 @@ CREATE MACRO ifelse(a,b) AS a+b\n ----\n \n query T\n-SELECT IFELSE(1, 'random', RANDOM())\n+SELECT IFELSE('1', 'random', RANDOM()::VARCHAR)\n ----\n random\n \ndiff --git a/test/sql/catalog/table/test_create_table_parallelism.test b/test/sql/catalog/table/test_create_table_parallelism.test\nindex 1e5eaa8e14c4..6bc66c7eacb4 100644\n--- a/test/sql/catalog/table/test_create_table_parallelism.test\n+++ b/test/sql/catalog/table/test_create_table_parallelism.test\n@@ -12,7 +12,7 @@ statement ok\n PRAGMA verify_parallelism\n \n statement ok\n-CREATE TABLE test AS (SELECT string_agg(range, '\ud83e\udd86 ') AS s, mod(range, 10000) xx FROM range(50000) GROUP BY xx)\n+CREATE TABLE test AS (SELECT string_agg(range::VARCHAR, '\ud83e\udd86 ') AS s, mod(range, 10000) xx FROM range(50000) GROUP BY xx)\n \n statement ok\n CREATE TABLE test2 AS (SELECT unnest(string_split(s, ' ')) FROM test)\ndiff --git a/test/sql/copy/csv/glob/read_csv_glob.test b/test/sql/copy/csv/glob/read_csv_glob.test\nindex 8b0008e5cdae..a619062e1d93 100644\n--- a/test/sql/copy/csv/glob/read_csv_glob.test\n+++ b/test/sql/copy/csv/glob/read_csv_glob.test\n@@ -231,6 +231,11 @@ SELECT COUNT(*) FROM glob('test/sql/copy/csv/data/glob/*/*.csv');\n statement error\n SELECT * FROM read_csv_auto([]) ORDER BY 1\n ----\n+No function matches\n+\n+statement error\n+SELECT * FROM read_csv_auto([]::VARCHAR[]) ORDER BY 1\n+----\n at least one file\n \n # null list\ndiff --git a/test/sql/copy/hive_types.test b/test/sql/copy/hive_types.test\nindex e1ab8876a185..69eb055c8427 100644\n--- a/test/sql/copy/hive_types.test\n+++ b/test/sql/copy/hive_types.test\n@@ -89,11 +89,11 @@ BIGINT\tVARCHAR\tDATE\n \n # Complex filter filtering first file, filter should be pruned completely if hive_partitioning=1\n query II\n-explain from parquet_scan('__TEST_DIR__/partition/**/*.parquet', HIVE_PARTITIONING=0, HIVE_TYPES_AUTOCAST=0) where aired < '2006-1-1'::DATE;\n+explain from parquet_scan('__TEST_DIR__/partition/**/*.parquet', HIVE_PARTITIONING=0, HIVE_TYPES_AUTOCAST=0) where aired < '2006-1-1';\n ----\n physical_plan\t<REGEX>:.*(PARQUET_SCAN.*Filters:|FILTER).*\n \n query II\n-explain from parquet_scan('__TEST_DIR__/partition/**/*.parquet', HIVE_PARTITIONING=1, HIVE_TYPES_AUTOCAST=0) where aired < '2006-1-1'::DATE;\n+explain from parquet_scan('__TEST_DIR__/partition/**/*.parquet', HIVE_PARTITIONING=1, HIVE_TYPES_AUTOCAST=0) where aired < '2006-1-1';\n ----\n physical_plan\t<REGEX>:.*(PARQUET_SCAN.*File Filters: \\(aired \\<).*\ndiff --git a/test/sql/copy/parquet/parquet_hive.test b/test/sql/copy/parquet/parquet_hive.test\nindex f58a863d9b80..052e5b1a2880 100644\n--- a/test/sql/copy/parquet/parquet_hive.test\n+++ b/test/sql/copy/parquet/parquet_hive.test\n@@ -185,12 +185,12 @@ COPY (SELECT * FROM t1) TO '__TEST_DIR__/hive_filters_2' (FORMAT PARQUET, PARTIT\n \n # There should be Table Filters (id < 50) and regular filters\n query II\n-EXPLAIN select a from parquet_scan('__TEST_DIR__/hive_filters/*/*.parquet', HIVE_PARTITIONING=1, HIVE_TYPES_AUTOCAST=0) where c=500 and a < 4;\n+EXPLAIN select a from parquet_scan('__TEST_DIR__/hive_filters/*/*.parquet', HIVE_PARTITIONING=1, HIVE_TYPES_AUTOCAST=0) where c::INT=500 and a::INT < 4;\n ----\n physical_plan\t<REGEX>:.*PARQUET_SCAN.*Filters:.*a<4 AND a IS NOT.*NULL.*File Filters: \\(CAST\\(c AS.*INTEGER\\) = 500\\).*\n \n # unsatisfiable file filters also show up\n query II\n-EXPLAIN select a from parquet_scan('__TEST_DIR__/hive_filters_2/*/*/*.parquet', HIVE_PARTITIONING=1, HIVE_TYPES_AUTOCAST=0) where c > 500 and c < 500;\n+EXPLAIN select a from parquet_scan('__TEST_DIR__/hive_filters_2/*/*/*.parquet', HIVE_PARTITIONING=1, HIVE_TYPES_AUTOCAST=0) where c::INT > 500 and c::INT < 500;\n ----\n physical_plan\t<REGEX>:.*PARQUET_SCAN.*File Filters:.*\\(CAST\\(c AS.*INTEGER\\).*BETWEEN 500.*\ndiff --git a/test/sql/copy/parquet/parquet_list.test b/test/sql/copy/parquet/parquet_list.test\nindex 4397c3b33c2d..eea5fd9e5613 100644\n--- a/test/sql/copy/parquet/parquet_list.test\n+++ b/test/sql/copy/parquet/parquet_list.test\n@@ -32,7 +32,7 @@ select count(*) from parquet_scan(['data/parquet-testing/glob/t1.parquet', 'data\n \n # empty list\n statement error\n-select count(*) from parquet_scan([]);\n+select count(*) from parquet_scan([]::varchar[]);\n ----\n at least one file\n \ndiff --git a/test/sql/copy/parquet/parquet_union_by_name.test b/test/sql/copy/parquet/parquet_union_by_name.test\nindex ac73aa8e63ef..f5d35a5111c3 100644\n--- a/test/sql/copy/parquet/parquet_union_by_name.test\n+++ b/test/sql/copy/parquet/parquet_union_by_name.test\n@@ -129,13 +129,6 @@ LIMIT 1;\n ----\n INTEGER[]\tBIGINT[]\tINTEGER[]\n \n-\n-# interger can not cast to list\n-statement error\n-SELECT *\n-FROM parquet_scan('__TEST_DIR__/*.parquet', union_by_name=true);\n-----\n-\n statement ok\n PRAGMA threads=1\n \ndiff --git a/test/sql/copy/partitioned/hive_filter_pushdown.test b/test/sql/copy/partitioned/hive_filter_pushdown.test\nindex 0ae31ff48f92..e03265ff2b6e 100644\n--- a/test/sql/copy/partitioned/hive_filter_pushdown.test\n+++ b/test/sql/copy/partitioned/hive_filter_pushdown.test\n@@ -23,18 +23,18 @@ explain SELECT * FROM parquet_scan('__TEST_DIR__/hive_pushdown_bug/*/*.parquet')\n physical_plan\t<!REGEX>:.*PARQUET_SCAN.*File Filters:.*\n \n query II\n-explain SELECT * FROM parquet_scan('__TEST_DIR__/hive_pushdown_bug/*/*.parquet', HIVE_PARTITIONING=1) where a > c;\n+explain SELECT * FROM parquet_scan('__TEST_DIR__/hive_pushdown_bug/*/*.parquet', HIVE_PARTITIONING=1) where a::VARCHAR > c::VARCHAR;\n ----\n physical_plan\t<!REGEX>:.*AND.*\n \n # no file filters here\n query II nosort q2\n-explain SELECT * FROM parquet_scan('__TEST_DIR__/hive_pushdown_bug/*/*.parquet', HIVE_PARTITIONING=1) where a > c;\n+explain SELECT * FROM parquet_scan('__TEST_DIR__/hive_pushdown_bug/*/*.parquet', HIVE_PARTITIONING=1) where a::VARCHAR > c::VARCHAR;\n ----\n physical_plan\t<!REGEX>:.*PARQUET_SCAN.*File Filters:.*\n \n query II nosort q2\n-explain SELECT * FROM parquet_scan('__TEST_DIR__/hive_pushdown_bug/*/*.parquet') where a > c;\n+explain SELECT * FROM parquet_scan('__TEST_DIR__/hive_pushdown_bug/*/*.parquet') where a::VARCHAR > c::VARCHAR;\n ----\n physical_plan\t<!REGEX>:.*PARQUET_SCAN.*File Filters:.*\n \n@@ -45,7 +45,7 @@ explain SELECT * FROM parquet_scan('__TEST_DIR__/hive_pushdown_bug/*/*.parquet',\n physical_plan\t<REGEX>:.*PARQUET_SCAN.*File Filters: \\(c = 500\\).*\n \n query II\n-explain SELECT * FROM parquet_scan('__TEST_DIR__/hive_pushdown_bug/*/*.parquet', HIVE_PARTITIONING=1, HIVE_TYPES_AUTOCAST=1) where c=500 and b=20;\n+explain SELECT * FROM parquet_scan('__TEST_DIR__/hive_pushdown_bug/*/*.parquet', HIVE_PARTITIONING=1, HIVE_TYPES_AUTOCAST=1) where c=500 and b='20';\n ----\n physical_plan\t<REGEX>:.*PARQUET_SCAN.*File Filters: \\(c = 500\\).*\n \ndiff --git a/test/sql/excel/test_excel_numformat.test b/test/sql/excel/test_excel_numformat.test\nindex 2a62f0fc2f0a..c35a6fc10638 100644\n--- a/test/sql/excel/test_excel_numformat.test\n+++ b/test/sql/excel/test_excel_numformat.test\n@@ -543,7 +543,7 @@ SELECT excel_text(0.0, '_ $* #,##0.00_ ;_ $* -#,##0.00_ ;_ $*  - ??_ ;_ @_ ')\n  $ -    \n \n query T\n-SELECT text(1.0, 3.5)\n+SELECT text(1.0, '3.5')\n ----\n 3.5\n \ndiff --git a/test/sql/filter/test_filter_clause.test_slow b/test/sql/filter/test_filter_clause.test_slow\nindex 1ad55f22021b..a9e808d191b2 100644\n--- a/test/sql/filter/test_filter_clause.test_slow\n+++ b/test/sql/filter/test_filter_clause.test_slow\n@@ -434,7 +434,7 @@ endloop\n \n #Query with many different filter clauses (e.g. 5 aggregates, 5 different filters)\n statement ok\n-create temporary table t_2 as select range a, length(range) b, mod(range,100) c, 5 d, 10000 e from range(1000);\n+create temporary table t_2 as select range a, length(range::varchar) b, mod(range,100) c, 5 d, 10000 e from range(1000);\n \n query IIIII\n select count (a) filter (where a>10 and a < 15), count (b) filter (where b between 1 and 3),\ndiff --git a/test/sql/function/array/array_inner_product.test b/test/sql/function/array/array_inner_product.test\nindex db715e9592c7..6427ebadc049 100644\n--- a/test/sql/function/array/array_inner_product.test\n+++ b/test/sql/function/array/array_inner_product.test\n@@ -4,11 +4,11 @@\n statement ok\n PRAGMA enable_verification\n \n-# Erorr message coverage test\n+# Error message coverage test\n statement error\n SELECT array_inner_product('foo', 'bar');\n ----\n-Binder Error: No function matches the given name and argument types\n+Could not choose a best candidate function\n \n statement error\n SELECT array_inner_product([1,2,3]::INT[3], ['a','b','c']::VARCHAR[3]);\ndiff --git a/test/sql/function/date/test_strftime.test b/test/sql/function/date/test_strftime.test\nindex 15a55f994530..2c0a42331161 100644\n--- a/test/sql/function/date/test_strftime.test\n+++ b/test/sql/function/date/test_strftime.test\n@@ -104,7 +104,7 @@ SELECT strftime(DATE '1992-01-01', 'hello world');\n hello world\n \n query I\n-SELECT strftime('2019-01-23'::DATE, 42);\n+SELECT strftime('2019-01-23'::DATE, '42');\n ----\n 42\n \ndiff --git a/test/sql/function/generic/error.test b/test/sql/function/generic/error.test\nindex 0220789e94e7..aaef3f79d0de 100644\n--- a/test/sql/function/generic/error.test\n+++ b/test/sql/function/generic/error.test\n@@ -8,7 +8,7 @@ PRAGMA enable_verification\n statement error\n SELECT error('test')\n ----\n-Invalid Error: test\n+test\n \n statement error\n SELECT\n@@ -20,7 +20,7 @@ FROM (\n   SELECT 'foo' AS value UNION ALL\n   SELECT 'baz' AS value);\n ----\n-Invalid Error: Found unexpected value: baz\n+Found unexpected value: baz\n \n query I\n SELECT *\n@@ -34,4 +34,14 @@ SELECT *\n FROM (SELECT 3 AS x)\n WHERE IF(x % 2 = 0, true, ERROR(FORMAT('x must be even but is {}', x)));\n ----\n-Invalid Error: x must be even but is 3\n+x must be even but is 3\n+\n+statement error\n+SELECT 42=error('hello world')\n+----\n+hello world\n+\n+statement error\n+SELECT error('hello world') IS NULL\n+----\n+hello world\ndiff --git a/test/sql/function/generic/test_least_greatest.test b/test/sql/function/generic/test_least_greatest.test\nindex 97f841e1b314..13acb5623493 100644\n--- a/test/sql/function/generic/test_least_greatest.test\n+++ b/test/sql/function/generic/test_least_greatest.test\n@@ -101,10 +101,10 @@ SELECT GREATEST(TIMESTAMP '1992-01-01 13:45:21.890123', TIMESTAMP '1994-02-02 05\n infinity\n \n # test mix of types\n-query T\n+statement error\n SELECT LEAST(DATE '1992-01-01', 'hello', 123)\n ----\n-123\n+No function matches\n \n # tables\n statement ok\ndiff --git a/test/sql/function/generic/test_null_if.test b/test/sql/function/generic/test_null_if.test\nindex 1d1c161bab17..639d151608e3 100644\n--- a/test/sql/function/generic/test_null_if.test\n+++ b/test/sql/function/generic/test_null_if.test\n@@ -42,7 +42,7 @@ statement ok\n INSERT INTO test3 VALUES (11, 22), (13, 22), (12, 21)\n \n query T\n-SELECT NULLIF(CAST(a AS VARCHAR), 11) FROM test3;\n+SELECT NULLIF(CAST(a AS VARCHAR), '11') FROM test3;\n ----\n NULL\n 13\ndiff --git a/test/sql/function/list/aggregates/approx_count_distinct.test b/test/sql/function/list/aggregates/approx_count_distinct.test\nindex d1258b0c7556..7076ecc89f15 100644\n--- a/test/sql/function/list/aggregates/approx_count_distinct.test\n+++ b/test/sql/function/list/aggregates/approx_count_distinct.test\n@@ -16,7 +16,7 @@ select list_approx_count_distinct([10]), list_approx_count_distinct(['hello']) f\n query II\n select list_approx_count_distinct(l), list_approx_count_distinct(['hello']) from list_ints;\n ----\n-98\t1\n+100\t1\n \n query I\n select list_approx_count_distinct([]) from list_ints;\n@@ -29,7 +29,7 @@ INSERT INTO list_ints VALUES ([]), (NULL), ([NULL]);\n query I\n select list_approx_count_distinct(l) from list_ints;\n ----\n-98\n+100\n 0\n NULL\n 0\n@@ -80,7 +80,7 @@ INSERT INTO list_ints_2 SELECT LIST(a), LIST(mod(a, 10)) FROM range(2000) tbl(a)\n query III\n SELECT list_count(a), list_approx_count_distinct(a), list_approx_count_distinct(b) from list_ints_2\n ----\n-2000\t1991\t10\n+2000\t1951\t10\n \n statement ok\n DELETE FROM list_ints_2\n@@ -94,5 +94,5 @@ INSERT INTO list_ints_2 SELECT LIST(a), NULL FROM range(2000) tbl(a, b) WHERE a\n query I\n SELECT list_approx_count_distinct(a) from list_ints_2;\n ----\n-993\n-986\n+989\n+1006\ndiff --git a/test/sql/function/list/aggregates/string_agg.test b/test/sql/function/list/aggregates/string_agg.test\nindex 578a24ec9df7..d2ab1aa39697 100644\n--- a/test/sql/function/list/aggregates/string_agg.test\n+++ b/test/sql/function/list/aggregates/string_agg.test\n@@ -44,7 +44,7 @@ INSERT INTO strings VALUES ([1, 1, 2, 2, 2, 3, 4, 4, 4], ['a', 'b', 'i', NULL, '\n \t['/', '-', '/', '-', '+', '/', '/', '-', '+']);\n \n query TTT\n-SELECT list_string_agg(x), list_string_agg(y), list_string_agg(g) FROM strings\n+SELECT list_string_agg(x), list_string_agg(y), list_string_agg(g::varchar[]) FROM strings\n ----\n a,b,i,j,p,x,y,z\t/,-,/,-,+,/,/,-,+\t1,1,2,2,2,3,4,4,4\n \n@@ -52,12 +52,17 @@ query T\n SELECT list_string_agg(x) FROM strings WHERE g > [100]\n ----\n \n-# numerics are auto cast to strings\n-query T\n+# numerics are auto cast to strings for string agg\n+query I\n SELECT list_string_agg([1, 2])\n ----\n 1,2\n \n+query T\n+SELECT list_string_agg([1, 2]::varchar[])\n+----\n+1,2\n+\n # group concat is an alias for list_string_agg\n query T\n SELECT list_aggr(['a'], 'group_concat')\ndiff --git a/test/sql/function/list/aggregates/types.test b/test/sql/function/list/aggregates/types.test\nindex 995886fdb762..fe504b312456 100644\n--- a/test/sql/function/list/aggregates/types.test\n+++ b/test/sql/function/list/aggregates/types.test\n@@ -10,7 +10,8 @@ require strinline\n # BOOLEAN\n \n # result False\n-foreach func_name bool_and bool_or first arbitrary last max median min mode string_agg group_concat\n+#foreach func_name bool_and bool_or first arbitrary last max median min mode string_agg group_concat\n+foreach func_name median\n \n query I\n SELECT list_aggr([False], '${func_name}')\n@@ -83,7 +84,7 @@ endloop\n \n # INTEGER types\n \n-foreach func_name avg favg bit_and bit_or bit_xor first arbitrary last max median min mode product string_agg group_concat sum fsum sumKahan kahan_sum\n+foreach func_name avg favg bit_and bit_or bit_xor first arbitrary last max median min mode product sum fsum sumKahan kahan_sum\n \n foreach type tinyint smallint integer bigint hugeint utinyint usmallint uinteger ubigint uhugeint\n \n@@ -150,7 +151,7 @@ endloop\n endloop\n \n # any other result\n-foreach func_name approx_count_distinct count entropy histogram kurtosis mad array_agg list sem skewness string_agg group_concat var_samp var_pop stddev stddev_pop variance stddev_samp\n+foreach func_name approx_count_distinct count entropy histogram kurtosis mad array_agg list sem skewness var_samp var_pop stddev stddev_pop variance stddev_samp\n \n foreach type float double decimal(4,1) decimal(9,4) decimal(18,6) decimal(38,10)\n \n@@ -182,7 +183,7 @@ endloop\n # mad (works with everything except interval)\n \n # specific result\n-foreach func_name first arbitrary last max min mode string_agg group_concat\n+foreach func_name first arbitrary last max min mode\n \n # date\n query I\n@@ -240,7 +241,7 @@ SELECT list_aggr([INTERVAL 1 YEAR], '${func_name}')\n \n endloop\n \n-foreach func_name first arbitrary last max min mode string_agg group_concat\n+foreach func_name first arbitrary last max min mode\n \n foreach type date time timestamp timestamp_s timestamp_ms timestamp_ns timetz timestamptz interval\n \n@@ -314,7 +315,7 @@ NULL\n endloop\n \n # any other result\n-foreach func_name count array_agg list\n+foreach func_name count array_agg list entropy histogram median mode string_agg group_concat\n \n statement ok\n SELECT list_aggr(['{a: 1}'::BLOB], '${func_name}')\n@@ -325,7 +326,7 @@ SELECT list_aggr([NULL::BLOB], '${func_name}')\n endloop\n \n # statement error for BLOB\n-foreach func_name avg favg bit_and bit_or bit_xor bool_and bool_or entropy histogram kurtosis mad median mode product sem skewness string_agg group_concat sum fsum sumKahan kahan_sum var_samp var_pop stddev stddev_pop variance stddev_samp\n+foreach func_name avg favg bit_and bit_or bit_xor bool_and bool_or kurtosis mad product sem skewness sum fsum sumKahan kahan_sum var_samp var_pop stddev stddev_pop variance stddev_samp\n \n statement error\n SELECT list_aggr(['{a: 1}'::BLOB], '${func_name}')\n@@ -375,7 +376,7 @@ endloop\n # NESTED types\n \n # list, struct, result is [1] or {'a': 1}\n-foreach func_name first arbitrary last max median min mode string_agg group_concat\n+foreach func_name first arbitrary last max median min mode\n \n query I\n SELECT list_aggr([[1]], '${func_name}')\n@@ -390,7 +391,7 @@ SELECT list_aggr([{'a': 1}], '${func_name}')\n endloop\n \n # list, struct, any other result\n-foreach func_name approx_count_distinct count entropy array_agg list\n+foreach func_name approx_count_distinct count entropy array_agg list  string_agg group_concat\n \n statement ok\n SELECT list_aggr([[1]], '${func_name}')\ndiff --git a/test/sql/function/list/lambdas/filter.test b/test/sql/function/list/lambdas/filter.test\nindex da3da080e45e..027883b62679 100644\n--- a/test/sql/function/list/lambdas/filter.test\n+++ b/test/sql/function/list/lambdas/filter.test\n@@ -99,7 +99,7 @@ SELECT list_transform([[1, 3], [2, 3, 1], [2, 4, 2]], x -> list_filter(x, y -> y\n [[1], [2, 1], [2, 2]]\n \n query I\n-SELECT list_concat(list_filter([42, -42, 8, -5, 2], elem -> elem > 0), list_filter(['enjoy', 'life', 'to', 'the', 'fullest'], str -> str ILIKE '%e%'))\n+SELECT list_concat(list_filter([42, -42, 8, -5, 2], elem -> elem > 0)::varchar[], list_filter(['enjoy', 'life', 'to', 'the', 'fullest'], str -> str ILIKE '%e%'))\n ----\n [42, 8, 2, enjoy, life, the, fullest]\n \n@@ -163,7 +163,7 @@ SELECT n FROM corr_test WHERE list_count(list_filter(l, elem -> length(elem) >=\n \n query I\n SELECT ct.n FROM corr_test ct\n-WHERE list_count(ct.l) < (SELECT list_count(list_filter(list_concat(list(c.n), ct.l), a -> length(a) >= 1)) FROM corr_test c GROUP BY c.g)\n+WHERE list_count(ct.l) < (SELECT list_count(list_filter(list_concat(list(c.n)::varchar[], ct.l), a -> length(a) >= 1)) FROM corr_test c GROUP BY c.g)\n ORDER BY ct.n\n ----\n 0\ndiff --git a/test/sql/function/list/lambdas/transform.test b/test/sql/function/list/lambdas/transform.test\nindex 5c4f1a741f3e..191b6fecce3d 100644\n--- a/test/sql/function/list/lambdas/transform.test\n+++ b/test/sql/function/list/lambdas/transform.test\n@@ -123,9 +123,14 @@ SELECT list_transform([[1], [2], [3]], x -> list_concat(list_transform(x, y -> y\n ----\n [[2, 0], [3, 1], [4, 2]]\n \n-query I\n+statement error\n SELECT list_transform([[1], [4], NULL, [1], [8]], x -> list_concat(list_transform(x, y -> CASE WHEN y > 1 THEN 'yay' ELSE 'nay' END), x))\n ----\n+an explicit cast is required\n+\n+query I\n+SELECT list_transform([[1], [4], NULL, [1], [8]], x -> list_concat(list_transform(x, y -> CASE WHEN y > 1 THEN 'yay' ELSE 'nay' END), x::VARCHAR[]))\n+----\n [[nay, 1], [yay, 4], NULL, [nay, 1], [yay, 8]]\n \n # test aliases\ndiff --git a/test/sql/function/list/list_concat.test b/test/sql/function/list/list_concat.test\nindex 659c8a933ac5..b733b511b115 100644\n--- a/test/sql/function/list/list_concat.test\n+++ b/test/sql/function/list/list_concat.test\n@@ -57,9 +57,9 @@ SELECT [1, 2] + [3, 4]\n [1, 2, 3, 4]\n \n # type casting\n-foreach type_a <integral> varchar\n+foreach type_a <integral>\n \n-foreach type_b <integral> varchar\n+foreach type_b <integral>\n \n query T\n SELECT list_concat([1, 2]::${type_a}[], [3, 4]::${type_b}[])::INTEGER[]\ndiff --git a/test/sql/function/list/list_contains.test b/test/sql/function/list/list_contains.test\nindex 879c2b6ccb79..7d7072a9d895 100644\n--- a/test/sql/function/list/list_contains.test\n+++ b/test/sql/function/list/list_contains.test\n@@ -64,7 +64,7 @@ SELECT i, list_contains(i,'aaaaaaaaaaaaaaaaaaaaaaaa') from STR_TEST;\n [aaaaaaaaaaaaaaaaaaaaaaaa]\t1\n \n query TT\n-SELECT i, list_contains(i,0) from STR_TEST;\n+SELECT i, list_contains(i, '0') from STR_TEST;\n ----\n [a, b, c]\t0\n [d, a, e]\t0\n@@ -118,10 +118,10 @@ SELECT list_contains([1.0,2.0,3.0],4)\n 0\n \n \n-query T\n+statement error\n SELECT list_contains([1.0,2.0,3.0], 'a')\n ----\n-0\n+an explicit cast is required\n \n # Not a list as input\n statement error\n@@ -242,7 +242,7 @@ PRAGMA debug_force_external=true\n \n loop i 0 2\n \n-foreach type <integral> varchar\n+foreach type <integral>\n \n # list tests\n statement ok\ndiff --git a/test/sql/function/list/list_distinct.test b/test/sql/function/list/list_distinct.test\nindex 331b7ee03a04..b8060d0f6d40 100644\n--- a/test/sql/function/list/list_distinct.test\n+++ b/test/sql/function/list/list_distinct.test\n@@ -278,20 +278,16 @@ select list_distinct([\"${colname}\"]) FROM all_types;\n \n endloop\n \n-# we don't support histogram for the min/max values of these types (casting errors)\n+# we support histogram for the min/max values of these types\n foreach colname hugeint dec_18_6 dec38_10\n \n-statement error\n+statement ok\n select list_distinct([\"${colname}\"]) FROM all_types;\n-----\n-Invalid Input Error\n \n endloop\n \n-statement error\n+statement ok\n select list_distinct([\"blob\"]) FROM all_types;\n-----\n-No matching aggregate function\n \n # we don't support histogram for nested types\n foreach colname int_array double_array date_array timestamp_array timestamptz_array varchar_array nested_int_array struct struct_of_arrays array_of_structs map\ndiff --git a/test/sql/function/list/list_position.test b/test/sql/function/list/list_position.test\nindex a99808d7810b..73ab11f379ee 100644\n--- a/test/sql/function/list/list_position.test\n+++ b/test/sql/function/list/list_position.test\n@@ -64,7 +64,7 @@ SELECT i, list_position(i,'aaaaaaaaaaaaaaaaaaaaaaaa') from STR_TEST;\n [aaaaaaaaaaaaaaaaaaaaaaaa]\t1\n \n query TT\n-SELECT i, list_position(i,0) from STR_TEST;\n+SELECT i, list_position(i, '0') from STR_TEST;\n ----\n [a, b, c]\t0\n [d, a, e]\t0\n@@ -118,15 +118,21 @@ SELECT list_position([1.0,2.0,3.0],4)\n 0\n \n \n-query T\n+statement error\n SELECT list_position([1.0,2.0,3.0], 'a')\n ----\n+an explicit cast is required\n+\n+query I\n+SELECT list_position([1.0,2.0,3.0]::varchar[], 'a')\n+----\n 0\n \n # Not a list as input\n statement error\n SELECT list_position('a', 'a')\n ----\n+No function matches\n \n query T\n SELECT list_position(NULL,NULL)\n@@ -252,7 +258,7 @@ statement ok\n INSERT INTO test0 VALUES ([2]), ([1]), ([1, 2]), ([]), ([2, 2]), ([NULL]), ([2, 3])\n \n query T\n-SELECT list_position(i,1) from test0\n+SELECT list_position(i,1::${type}) from test0\n ----\n 0\n 1\ndiff --git a/test/sql/function/string/regex_capture.test b/test/sql/function/string/regex_capture.test\nindex 9f6c7078a503..fc73dda2bded 100644\n--- a/test/sql/function/string/regex_capture.test\n+++ b/test/sql/function/string/regex_capture.test\n@@ -107,7 +107,7 @@ statement error\n WITH patterns AS (\n \tSELECT 'rundate_(\\d+-\\d+-\\d+)_pass_(\\d+)' AS pattern FROM range(3)\n )\n-SELECT regexp_extract(filename, patterns, ['rundate', 'pass']) AS groups\n+SELECT regexp_extract(filename, pattern, ['rundate', 'pass']) AS groups\n FROM filenames, patterns\n ----\n constant pattern\ndiff --git a/test/sql/function/string/test_array_extract.test b/test/sql/function/string/test_array_extract.test\nindex 12f181e29a23..d83ceb56d1d3 100644\n--- a/test/sql/function/string/test_array_extract.test\n+++ b/test/sql/function/string/test_array_extract.test\n@@ -159,6 +159,6 @@ SELECT array_extract('1', 9223372036854775807);\n Out of Range Error: Substring offset outside of supported range (> 4294967295)\n \n statement error\n-SELECT array_extract(0, -9223372036854775808);\n+SELECT array_extract('0', -9223372036854775808);\n ----\n Out of Range Error: Substring offset outside of supported range (< -4294967296)\ndiff --git a/test/sql/function/string/test_ascii.test b/test/sql/function/string/test_ascii.test\nindex ffa5ef897891..beccf3552972 100644\n--- a/test/sql/function/string/test_ascii.test\n+++ b/test/sql/function/string/test_ascii.test\n@@ -38,7 +38,7 @@ SELECT ASCII('\u00c4')\n 196\n \n query I\n-SELECT ASCII(5)\n+SELECT ASCII('5')\n ----\n 53\n \ndiff --git a/test/sql/function/string/test_printf.test b/test/sql/function/string/test_printf.test\nindex 0b437958c44b..68e1934a771e 100644\n--- a/test/sql/function/string/test_printf.test\n+++ b/test/sql/function/string/test_printf.test\n@@ -158,7 +158,7 @@ SELECT printf(fmt) FROM strings ORDER BY idx\n ----\n \n query T\n-SELECT printf(CASE WHEN pint < 15 THEN NULL ELSE pint END) FROM strings ORDER BY idx\n+SELECT printf(CASE WHEN pint < 15 THEN NULL ELSE pint::VARCHAR END) FROM strings ORDER BY idx\n ----\n NULL\n 20\ndiff --git a/test/sql/function/timestamp/test_icu_makedate.test b/test/sql/function/timestamp/test_icu_makedate.test\nindex 463407266f0d..3d712cbc6274 100644\n--- a/test/sql/function/timestamp/test_icu_makedate.test\n+++ b/test/sql/function/timestamp/test_icu_makedate.test\n@@ -420,7 +420,7 @@ SELECT make_timestamptz(\n \tCAST(a.\"bigint\" AS BIGINT), CAST(a.\"bigint\" AS BIGINT), \n \tCAST(a.\"bigint\" AS BIGINT), CAST(a.\"bigint\" AS BIGINT), \n \tCAST(txid_current() AS BIGINT), \n-\tCAST(CAST(COALESCE(a.\"bigint\", a.\"bigint\") AS BIGINT) AS BIGINT))\n+\tCAST(CAST(COALESCE(a.\"bigint\", a.\"bigint\") AS BIGINT) AS VARCHAR))\n FROM all_types a;\n ----\n Overflow in subtraction\ndiff --git a/test/sql/inet/test_inet_functions.test b/test/sql/inet/test_inet_functions.test\nindex 72a74aacd8c6..10e0931900c7 100644\n--- a/test/sql/inet/test_inet_functions.test\n+++ b/test/sql/inet/test_inet_functions.test\n@@ -13,12 +13,18 @@ SELECT host(INET '127.0.0.1/17')\n ----\n 127.0.0.1\n \n-# we support auto-cast from varchar to inet\n+# we support auto-cast from string literals to inet\n query I\n SELECT host('127.0.0.1/17')\n ----\n 127.0.0.1\n \n+# we don't support auto-casting of VARCHAR to INET\n+statement error\n+SELECT host(a) from (values ('127.0.0.1/17')) t(a);\n+----\n+No function matches\n+\n # subtract\n query I\n SELECT INET '127.0.0.255' - 32;\ndiff --git a/test/sql/insert/test_insert_type.test b/test/sql/insert/test_insert_type.test\nindex 9ac3be9979dc..0980aaad0563 100644\n--- a/test/sql/insert/test_insert_type.test\n+++ b/test/sql/insert/test_insert_type.test\n@@ -25,7 +25,7 @@ SELECT * FROM strings\n NULL\n \n statement ok\n-UPDATE strings SET a=13 WHERE a=3\n+UPDATE strings SET a=13 WHERE a='3'\n \n query T\n SELECT * FROM strings ORDER BY cast(a AS INTEGER)\ndiff --git a/test/sql/join/right_outer/right_join_complex_null.test b/test/sql/join/right_outer/right_join_complex_null.test\nindex 425e55a216c0..0f518b00a80e 100644\n--- a/test/sql/join/right_outer/right_join_complex_null.test\n+++ b/test/sql/join/right_outer/right_join_complex_null.test\n@@ -24,12 +24,12 @@ statement ok\n INSERT INTO t0(c0) VALUES (DATE '1970-01-01'), (TIMESTAMP '1969-12-13 17:49:43');\n \n query I\n-SELECT MAX('a') FROM t0 JOIN t1 ON ((t0.c0)<=(((NULL)-(t1.rowid))));\n+SELECT MAX('a') FROM t0 JOIN t1 ON ((t0.c0)<=(((NULL)-(t1.rowid))::DATE));\n ----\n NULL\n \n query I\n-SELECT MAX('a') FROM t0 RIGHT JOIN t1 ON ((t0.c0)<=(((NULL)-(t1.rowid))));\n+SELECT MAX('a') FROM t0 RIGHT JOIN t1 ON ((t0.c0)<=(((NULL)-(t1.rowid))::DATE));\n ----\n a\n \ndiff --git a/test/sql/json/scalar/test_json_create.test b/test/sql/json/scalar/test_json_create.test\nindex be1a0579a0be..de69739ded43 100644\n--- a/test/sql/json/scalar/test_json_create.test\n+++ b/test/sql/json/scalar/test_json_create.test\n@@ -86,7 +86,7 @@ select json_object('nested', map(['duck', 'goose'], [42, 7]))\n {\"nested\":{\"duck\":42,\"goose\":7}}\n \n query T\n-select json_object('nested', map([0, 'goose'], [42, 7]))\n+select json_object('nested', map(['0', 'goose'], [42, 7]))\n ----\n {\"nested\":{\"0\":42,\"goose\":7}}\n \ndiff --git a/test/sql/json/scalar/test_json_extract.test b/test/sql/json/scalar/test_json_extract.test\nindex 50e71d9fcc77..6e13039fb2e6 100644\n--- a/test/sql/json/scalar/test_json_extract.test\n+++ b/test/sql/json/scalar/test_json_extract.test\n@@ -85,7 +85,7 @@ select '{\"my_field\": {\"my_nested_field\": [\"goose\", \"duckduckduckduck\"]}}'::JSON-\n duckduckduckduck\n \n query T\n-select json_extract('[1, 2, 42]', 2)\n+select json_extract('[1, 2, 42]', '2')\n ----\n 42\n \ndiff --git a/test/sql/optimizer/test_in_rewrite_rule.test b/test/sql/optimizer/test_in_rewrite_rule.test\nindex b89cf9425399..18a79b9265e8 100644\n--- a/test/sql/optimizer/test_in_rewrite_rule.test\n+++ b/test/sql/optimizer/test_in_rewrite_rule.test\n@@ -19,7 +19,7 @@ select * from t where i in ('1','2','y');\n 2\n \n query T\n-SELECT x::VARCHAR IN ('1', y) FROM (VALUES (1, 2), (2, 3)) tbl(x, y);\n+SELECT x::VARCHAR IN ('1', y::VARCHAR) FROM (VALUES (1, 2), (2, 3)) tbl(x, y);\n ----\n 1\n 0\ndiff --git a/test/sql/parser/function_chaining.test b/test/sql/parser/function_chaining.test\nindex b44a3c539d92..1bbcca3e5f38 100644\n--- a/test/sql/parser/function_chaining.test\n+++ b/test/sql/parser/function_chaining.test\n@@ -103,9 +103,9 @@ Hello\n \n # prepared statements\n statement ok\n-PREPARE v1 AS SELECT ?.split(' ').lower()\n+PREPARE v1 AS SELECT ?.split(' ')[1].lower()\n \n query I\n EXECUTE v1('Hello World')\n ----\n-[hello, world]\n+hello\ndiff --git a/test/sql/parser/test_columns_order.test b/test/sql/parser/test_columns_order.test\nindex 397b87424e70..08552c6468c5 100644\n--- a/test/sql/parser/test_columns_order.test\n+++ b/test/sql/parser/test_columns_order.test\n@@ -40,7 +40,7 @@ SELECT * FROM tbl ORDER BY COLUMNS('col2') DESC, COLUMNS('col3') ASC\n 2\t100\t20\n \n query III\n-SELECT * FROM tbl ORDER BY COLUMNS(x -> x[-1] IN (2, 3))\n+SELECT * FROM tbl ORDER BY COLUMNS(x -> x[-1] IN ('2', '3'))\n ----\n 2\t100\t20\n 3\t200\t0\ndiff --git a/test/sql/projection/test_coalesce.test_slow b/test/sql/projection/test_coalesce.test_slow\nindex e33de987e7fd..183256473528 100644\n--- a/test/sql/projection/test_coalesce.test_slow\n+++ b/test/sql/projection/test_coalesce.test_slow\n@@ -251,10 +251,10 @@ CREATE TABLE nestedtypes AS SELECT * FROM\n \t(\n \t\tVALUES\n \t\t\t(NULL, NULL, NULL, NULL, NULL, NULL),\n-\t\t\t([NULL, [NULL, NULL]], NULL, NULL, NULL, NULL, NULL),\n+\t\t\t([NULL, [NULL, NULL]]::STRUCT(x INTEGER[])[][], NULL, NULL, NULL, NULL, NULL),\n \t\t\t(NULL, [[{'x': [3, 4]}], [{'x': [17]}, {'x': [22, NULL]}]], NULL, NULL, NULL, NULL),\n-\t\t\t(NULL, NULL, [[], [], []], NULL, NULL, NULL),\n-\t\t\t(NULL, NULL, NULL, [[{'x': NULL}], NULL, [NULL, NULL], []], NULL, NULL),\n+\t\t\t(NULL, NULL, [[], [], []]::STRUCT(x INTEGER[])[][], NULL, NULL, NULL),\n+\t\t\t(NULL, NULL, NULL, [[{'x': NULL}], NULL, [NULL, NULL], []]::STRUCT(x INTEGER[])[][], NULL, NULL),\n \t\t\t(NULL, NULL, NULL, NULL, [[{'x': [10, 12, 13, 14, 15]}], [{'x': [NULL]}, NULL]], NULL),\n \t\t\t(NULL, NULL, NULL, NULL, NULL, NULL)\n \t) tbl(s1, s2, s3, s4, s5);\ndiff --git a/test/sql/projection/test_value_list.test b/test/sql/projection/test_value_list.test\nindex 76c766bed9ea..4a3800b1948a 100644\n--- a/test/sql/projection/test_value_list.test\n+++ b/test/sql/projection/test_value_list.test\n@@ -59,12 +59,10 @@ SELECT * FROM (VALUES ((SELECT MIN(a) FROM test), 2, 3), ((SELECT MAX(b) FROM te\n 4\t2\t3\n \n # value list with different types\n-query TI\n+statement error\n SELECT * FROM (VALUES ('hello', 2), (1 + 3, '5'), (DATE '1992-09-20', 3)) v1;\n ----\n-hello\t2\n-4\t5\n-1992-09-20\t3\n+an explicit cast is required\n \n # value list with NULLs\n query TI\n@@ -86,13 +84,22 @@ SELECT * FROM (VALUES (NULL, NULL), (3, 4)) v1;\n NULL\tNULL\n 3\t4\n \n-# type is the max type of all input columns\n query I\n-SELECT * FROM (VALUES (3), ('hello')) v1;\n+SELECT * FROM (VALUES (3), ('42')) v1;\n ----\n 3\n+42\n+\n+statement error\n+SELECT * FROM (VALUES (3), ('hello')) v1;\n+----\n hello\n \n+query I\n+SELECT typeof(x) FROM (VALUES (DATE '1992-01-01'), ('1992-01-01')) v1(x) LIMIT 1;\n+----\n+DATE\n+\n query I\n SELECT * FROM (VALUES (NULL), ('hello')) v1;\n ----\ndiff --git a/test/sql/returning/returning_delete.test b/test/sql/returning/returning_delete.test\nindex d440e2f15601..a8eb67b94d52 100644\n--- a/test/sql/returning/returning_delete.test\n+++ b/test/sql/returning/returning_delete.test\n@@ -219,7 +219,7 @@ RETURNING {'a': a, 'b': b};\n query I\n DELETE FROM table2\n WHERE b=4\n-RETURNING [a, b];\n+RETURNING [a, b::VARCHAR];\n ----\n [mysql, 4]\n \ndiff --git a/test/sql/returning/returning_update.test b/test/sql/returning/returning_update.test\nindex 59b3736bd196..38d933934705 100644\n--- a/test/sql/returning/returning_update.test\n+++ b/test/sql/returning/returning_update.test\n@@ -266,7 +266,7 @@ query I\n UPDATE table2\n SET b=98\n WHERE b=99\n-RETURNING [a, b];\n+RETURNING [a, b::VARCHAR];\n ----\n [Mr.Duck, 98]\n \ndiff --git a/test/sql/setops/test_setops.test b/test/sql/setops/test_setops.test\nindex ca0bb9543f6e..e517543780aa 100644\n--- a/test/sql/setops/test_setops.test\n+++ b/test/sql/setops/test_setops.test\n@@ -70,8 +70,8 @@ SELECT b FROM test WHERE a < 13 UNION ALL SELECT b FROM test WHERE a > 11\n 1\n 2\n \n-# mixing types, should upcast\n-query T\n+# mixing types, should error\n+query I\n SELECT 1 UNION ALL SELECT 'asdf'\n ----\n 1\ndiff --git a/test/sql/setops/test_union_all_by_name.test b/test/sql/setops/test_union_all_by_name.test\nindex 4642e92e3fac..cdba78269c45 100644\n--- a/test/sql/setops/test_union_all_by_name.test\n+++ b/test/sql/setops/test_union_all_by_name.test\n@@ -220,10 +220,10 @@ NULL\t1\n \n ########## type cast\n \n-query I\n+statement error\n SELECT DISTINCT ON(x) x FROM (SELECT 1 as x UNION ALL BY NAME SELECT '1' as x);\n ----\n-1\n+an explicit cast is required\n \n # have to sort here too because distinct on is hash-based, does not preserve order\n query I sort\ndiff --git a/test/sql/setops/test_union_type_cast.test b/test/sql/setops/test_union_type_cast.test\nindex bebbe10e1563..c3b28c519356 100644\n--- a/test/sql/setops/test_union_type_cast.test\n+++ b/test/sql/setops/test_union_type_cast.test\n@@ -37,7 +37,7 @@ SELECT 1 UNION ALL (SELECT 1.0 UNION ALL SELECT 1.0 UNION ALL SELECT 1.0) UNION\n 1\n 1\n \n-query T\n+query I\n SELECT 1 UNION (SELECT '1' UNION SELECT '1' UNION SELECT '1') UNION SELECT 1;\n ----\n 1\ndiff --git a/test/sql/subquery/lateral/lateral_fuzzer_5984_23.test b/test/sql/subquery/lateral/lateral_fuzzer_5984_23.test\nindex fb3a91437b8d..36521d2470f1 100644\n--- a/test/sql/subquery/lateral/lateral_fuzzer_5984_23.test\n+++ b/test/sql/subquery/lateral/lateral_fuzzer_5984_23.test\n@@ -3,11 +3,11 @@\n # group: [lateral]\n \n query I\n-SELECT 1 FROM (SELECT 1) t1(c1), (SELECT TRUE IN (TRUE, t1.c1 LIKE 'a' ESCAPE NULL));\n+SELECT 1 FROM (SELECT 1) t1(c1), (SELECT TRUE IN (TRUE, t1.c1::VARCHAR LIKE 'a' ESCAPE NULL));\n ----\n 1\n \n query I\n-SELECT (SELECT t1.c1 LIKE 'a' ESCAPE NULL) FROM (SELECT 1) t1(c1)\n+SELECT (SELECT t1.c1::VARCHAR LIKE 'a' ESCAPE NULL) FROM (SELECT 1) t1(c1)\n ----\n NULL\ndiff --git a/test/sql/subquery/scalar/test_varchar_correlated_subquery.test b/test/sql/subquery/scalar/test_varchar_correlated_subquery.test\nindex a84d886b81bc..00712a9dabeb 100644\n--- a/test/sql/subquery/scalar/test_varchar_correlated_subquery.test\n+++ b/test/sql/subquery/scalar/test_varchar_correlated_subquery.test\n@@ -23,9 +23,14 @@ SELECT NULL IN (SELECT * FROM strings WHERE v=s1.v) FROM strings s1 ORDER BY v\n NULL\n NULL\n \n-query T\n+statement error\n SELECT 3 IN (SELECT * FROM strings WHERE v=s1.v) FROM strings s1 ORDER BY v\n ----\n+explicit cast is required\n+\n+query T\n+SELECT '3' IN (SELECT * FROM strings WHERE v=s1.v) FROM strings s1 ORDER BY v\n+----\n 0\n 0\n 0\ndiff --git a/test/sql/timezone/test_icu_calendar.test b/test/sql/timezone/test_icu_calendar.test\nindex 24ef84a8050f..cf10a2184d62 100644\n--- a/test/sql/timezone/test_icu_calendar.test\n+++ b/test/sql/timezone/test_icu_calendar.test\n@@ -101,7 +101,7 @@ statement ok\n SET CALENDAR='islamic-umalqura';\n \n statement ok\n-SELECT strftime(TIMESTAMPTZ '-260722-3-4 0:3:52',TIMESTAMP '-285441-5-3 8:3:4');\n+SELECT strftime(TIMESTAMPTZ '-260722-3-4 0:3:52',TIMESTAMP '-285441-5-3 8:3:4'::VARCHAR);\n \n # Issue #5235\n statement ok\n@@ -117,7 +117,7 @@ statement ok\n PRAGMA CALENDAR='japanese';\n \n query I\n-SELECT strftime(TIMESTAMPTZ '-23831-1-15 2:5:17 America/La_Paz',TIMETZ '0:8:29 America/Cayman');\n+SELECT strftime(TIMESTAMPTZ '-23831-1-15 2:5:17 America/La_Paz',TIMETZ '0:8:29 America/Cayman'::VARCHAR);\n ----\n 00:08:29+00\n \ndiff --git a/test/sql/types/blob/test_blob_function.test b/test/sql/types/blob/test_blob_function.test\nindex 1bfc764ae142..126b80cf0861 100644\n--- a/test/sql/types/blob/test_blob_function.test\n+++ b/test/sql/types/blob/test_blob_function.test\n@@ -55,9 +55,10 @@ SELECT b || '\\x5A\\x5A'::BYTEA FROM blobs\n \\xFFZZ\n \n # BLOB || VARCHAR is not allowed, should fail\n-statement error\n+query I\n SELECT b || '5A5A'::VARCHAR FROM blobs\n ----\n+\\xFF5A5A\n \n # Octet Length tests\n statement ok\ndiff --git a/test/sql/types/enum/test_3641.test b/test/sql/types/enum/test_3641.test\nindex eba08e08f173..020eed2f86ab 100644\n--- a/test/sql/types/enum/test_3641.test\n+++ b/test/sql/types/enum/test_3641.test\n@@ -21,7 +21,7 @@ statement ok\n insert into m values ('sad', 'very sad')\n \n query II\n-select *  from m where m = ''\n+select * from m where m = ''::VARCHAR\n ----\n \n query I\n@@ -29,6 +29,14 @@ SELECT m='' FROM m\n ----\n false\n \n+statement ok\n+PREPARE v1 AS SELECT m=? FROM m;\n+\n+query I\n+EXECUTE v1('')\n+----\n+false\n+\n # implicit cast\n query II\n SELECT * FROM m WHERE m=m_2\ndiff --git a/test/sql/types/enum/test_enum_to_numbers.test b/test/sql/types/enum/test_enum_to_numbers.test\nindex 2d69ae1338ff..fe003a91d21f 100644\n--- a/test/sql/types/enum/test_enum_to_numbers.test\n+++ b/test/sql/types/enum/test_enum_to_numbers.test\n@@ -162,22 +162,22 @@ select a from t1, t2 where t1.a = t2.b;\n 4\n \n query I\n-select count(*) from t1, t2 where t1.a < t2.b;\n+select count(*) from t1, t2 where t1.a::VARCHAR < t2.b;\n ----\n 20\n \n query I\n-select count(*) from t1, t2 where t1.a <= t2.b;\n+select count(*) from t1, t2 where t1.a::VARCHAR <= t2.b;\n ----\n 28\n \n query I\n-select count(*) from t1, t2 where t1.a > t2.b;\n+select count(*) from t1, t2 where t1.a::VARCHAR > t2.b;\n ----\n 36\n \n query I\n-select count(*) from t1, t2 where t1.a >= t2.b;\n+select count(*) from t1, t2 where t1.a::VARCHAR >= t2.b;\n ----\n 44\n \n@@ -202,23 +202,35 @@ create table t1 as select date, time, timestamp, timestamp_s, timestamp_ms, time\n statement ok\n create table t2 as select * from VALUES ('294247-01-10 04:00:54.775806'::new_type), ('83 years 3 months 999 days 00:16:39.999999'::new_type), ('1677-09-21 00:12:43.145225'::new_type), ('other enum type'::new_type), ('another 1'::new_type), ('~~~'::new_type) t(b);\n \n-statement ok\n+statement error\n select count(*) from t1, t2 where t1.date = t2.b;\n+----\n+Conversion Error\n \n-statement ok\n+statement error\n select count(*) from t1, t2 where t1.time = t2.b;\n+----\n+Conversion Error\n \n-statement ok\n+statement error\n select count(*) from t1, t2 where t1.timestamp = t2.b;\n+----\n+Conversion Error\n \n-statement ok\n+statement error\n select count(*) from t1, t2 where t1.timestamp_s = t2.b;\n+----\n+Conversion Error\n \n-statement ok\n+statement error\n select count(*) from t1, t2 where t1.timestamp_ms = t2.b;\n+----\n+Conversion Error\n \n-statement ok\n+statement error\n select count(*) from t1, t2 where t1.timestamp_ns = t2.b;\n+----\n+Conversion Error\n \n # in types.hpp logical type of timestamp_tz, time_tz, interval, and blob are all higher \n # than varchar, causing a direct cast from varchar to the type to happen. \ndiff --git a/test/sql/types/map/map_cast.test b/test/sql/types/map/map_cast.test\nindex fb621bf03bfb..673d422f5722 100644\n--- a/test/sql/types/map/map_cast.test\n+++ b/test/sql/types/map/map_cast.test\n@@ -2,6 +2,9 @@\n # description: Test map cast\n # group: [map]\n \n+statement ok\n+PRAGMA enable_verification\n+\n query I\n SELECT MAP(['a', 'b', 'c'], [1, 2, NULL])::MAP(VARCHAR, VARCHAR)\n ----\n@@ -23,10 +26,10 @@ SELECT MAP([[1, 2, 3], [0], [123]], [1.0, 2.1, 4.9])::MAP(VARCHAR[], TINYINT)\n ----\n {[1, 2, 3]=1, [0]=2, [123]=5}\n \n-query I\n-SELECT MAP([1, 2, 'hi'], [1.0, 2.1, 4.9])::MAP(VARCHAR, TINYINT)\n+statement error\n+SELECT MAP([1, 2, 'hi'::VARCHAR], [1.0, 2.1, 4.9])::MAP(VARCHAR, TINYINT)\n ----\n-{1=1, 2=2, hi=5}\n+explicit cast\n \n query I\n SELECT MAP([1, 2, 3], ['A', 'B', 'C'])::MAP(TINYINT, VARCHAR)\ndiff --git a/test/sql/types/nested/list/array.test b/test/sql/types/nested/list/array.test\nindex 392f99882548..5abe3de94599 100644\n--- a/test/sql/types/nested/list/array.test\n+++ b/test/sql/types/nested/list/array.test\n@@ -38,16 +38,16 @@ SELECT ARRAY[i] FROM range(3) tbl(i) WHERE (ARRAY[i])[1] == 1\n [1]\n \n # conversion failure (mixed types)\n-query I\n-SELECT ARRAY[i, 'hello'] FROM range(3) tbl(i) WHERE (ARRAY[i])[1] == 1\n+statement error\n+SELECT ARRAY[i, 'hello'] FROM generate_series(0,2) tbl(i) WHERE (ARRAY[i])[1] == 1\n ----\n-[1, hello]\n+Could not convert string\n \n # conversion failure (nested mixed types)\n-query I\n+statement error\n SELECT ARRAY[ARRAY[1], ARRAY['hello']]\n ----\n-[[1], [hello]]\n+explicit cast is required\n \n # array casts\n query I\n@@ -79,16 +79,11 @@ SELECT ARRAY[[1, 2], [3, 4]]::VARCHAR[]\n ----\n [[1, 2], [3, 4]]\n \n-mode skip\n-\n-# FIXME: double unnest\n-query I\n+# double unnest\n+statement error\n SELECT UNNEST(UNNEST(ARRAY[[1, 2], [3, 4]]::VARCHAR[][]))\n ----\n-[1, 2]\n-[3, 4]\n-\n-mode unskip\n+not supported\n \n query I\n SELECT UNNEST(ARRAY[[1, 2], [3, 4]]::VARCHAR[])\ndiff --git a/test/sql/types/nested/list/list_aggr_parameter.test b/test/sql/types/nested/list/list_aggr_parameter.test\nindex 55cc5ce5128f..e351e625e9af 100644\n--- a/test/sql/types/nested/list/list_aggr_parameter.test\n+++ b/test/sql/types/nested/list/list_aggr_parameter.test\n@@ -16,7 +16,7 @@ SELECT list_aggr(list(i), 'quantile', [0.25, 0.5, 0.75]) FROM range(1, 11) tbl(i\n [3, 5, 8]\n \n query I\n-SELECT list_aggr(list(i), 'string_agg', '|') FROM range(1, 4) tbl(i);\n+SELECT list_aggr(list(i)::varchar[], 'string_agg', '|') FROM range(1, 4) tbl(i);\n ----\n 1|2|3\n \ndiff --git a/test/sql/types/nested/list/list_aggregates.test b/test/sql/types/nested/list/list_aggregates.test\nindex 76f3b0196aa9..89811cc43eeb 100644\n--- a/test/sql/types/nested/list/list_aggregates.test\n+++ b/test/sql/types/nested/list/list_aggregates.test\n@@ -74,7 +74,7 @@ select i%3 a, unnest(first([i])) from range(10) tbl(i) group by a order by a;\n 2\t2\n \n query I\n-select string_agg(list_value(i), ',') from range(10) tbl(i);\n+select string_agg(list_value(i)::varchar, ',') from range(10) tbl(i);\n ----\n [0],[1],[2],[3],[4],[5],[6],[7],[8],[9]\n \ndiff --git a/test/sql/types/nested/list/test_list_extract.test b/test/sql/types/nested/list/test_list_extract.test\nindex 1ae4ece413bc..5c7af4310e83 100644\n--- a/test/sql/types/nested/list/test_list_extract.test\n+++ b/test/sql/types/nested/list/test_list_extract.test\n@@ -10,10 +10,10 @@ SELECT LIST_EXTRACT(NULL, 1)\n ----\n NULL\n \n-query I\n+statement error\n SELECT LIST_EXTRACT(42, 1)\n ----\n-4\n+No function matches\n \n query I\n SELECT LIST_EXTRACT(LIST_VALUE(), 1)\ndiff --git a/test/sql/types/nested/list/test_scalar_list.test b/test/sql/types/nested/list/test_scalar_list.test\nindex 655107bd1e51..21210b060927 100644\n--- a/test/sql/types/nested/list/test_scalar_list.test\n+++ b/test/sql/types/nested/list/test_scalar_list.test\n@@ -98,13 +98,11 @@ SELECT UNNEST(a) ua FROM (VALUES (LIST_VALUE()), (LIST_VALUE(1, 2, 3, 4)), (LIST\n NULL\n 42\n \n-# list types get cast to highest type in values list\n-query I\n+# the same auto-casting rules apply to list elements\n+statement error\n SELECT * FROM (VALUES (LIST_VALUE(1, 2)), (LIST_VALUE()), (LIST_VALUE('a'))) lv(a)\n ----\n-[1, 2]\n-[]\n-[a]\n+an explicit cast is required\n \n # can't cast lists to stuff\n statement error\n@@ -116,11 +114,11 @@ statement error\n SELECT LIST_VALUE(42) + 4\n ----\n \n-# list value automatically upcasts to the highest type (varchar in this case)\n+# string literals join the other types in the list\n query I\n-SELECT LIST_VALUE(42, 'a')\n+SELECT LIST_VALUE(42, '84')\n ----\n-[42, a]\n+[42, 84]\n \n # can have unnest anywhere\n query I\n@@ -145,7 +143,7 @@ SELECT CASE WHEN g = 2 THEN LIST_VALUE(g, e, 42) ELSE LIST_VALUE(84, NULL) END F\n [NULL]\n \n query I\n-SELECT CASE WHEN g = 2 THEN LIST_VALUE(g, e, 42) ELSE LIST_VALUE('eeek') END FROM list_data\tWHERE g > 1\n+SELECT CASE WHEN g = 2 THEN LIST_VALUE(g, e, 42)::VARCHAR[] ELSE LIST_VALUE('eeek') END FROM list_data\tWHERE g > 1\n ----\n [2, 3, 42]\n [2, 4, 42]\ndiff --git a/test/sql/types/nested/struct/struct_aggregates.test b/test/sql/types/nested/struct/struct_aggregates.test\nindex d1bf8b02661d..602f17a3da7f 100644\n--- a/test/sql/types/nested/struct/struct_aggregates.test\n+++ b/test/sql/types/nested/struct/struct_aggregates.test\n@@ -17,7 +17,7 @@ select min(struct_pack(i := -i, j := -i - 2)), max(struct_pack(i := i + 2, j :=\n {'i': -9, 'j': -11}\t{'i': 11, 'j': 13}\t{'i': 0, 'j': 2}\n \n query I\n-select string_agg(struct_pack(i :=  i, j := i + 2), ',') from range(10) tbl(i);\n+select string_agg(struct_pack(i :=  i, j := i + 2)::VARCHAR, ',') from range(10) tbl(i);\n ----\n {'i': 0, 'j': 2},{'i': 1, 'j': 3},{'i': 2, 'j': 4},{'i': 3, 'j': 5},{'i': 4, 'j': 6},{'i': 5, 'j': 7},{'i': 6, 'j': 8},{'i': 7, 'j': 9},{'i': 8, 'j': 10},{'i': 9, 'j': 11}\n \ndiff --git a/test/sql/types/struct/struct_case.test b/test/sql/types/struct/struct_case.test\nindex 46666823d069..08b39e81b190 100644\n--- a/test/sql/types/struct/struct_case.test\n+++ b/test/sql/types/struct/struct_case.test\n@@ -94,11 +94,16 @@ SELECT i, CASE WHEN i%2=0 THEN {'i': [1,2,3]} ELSE {'i': NULL} END FROM range(6)\n \n # different types on child lists\n query II\n-SELECT i, CASE WHEN i%2=0 THEN {'i': [1,2,3]} ELSE {'i': ['hello']} END FROM range(6) tbl(i)\n+SELECT i, CASE WHEN i%2=0 THEN {'i': [1::INT,2::INT,3::INT]} ELSE {'i': [0::UBIGINT]} END FROM range(6) tbl(i)\n ----\n 0\t{'i': [1, 2, 3]}\n-1\t{'i': [hello]}\n+1\t{'i': [0]}\n 2\t{'i': [1, 2, 3]}\n-3\t{'i': [hello]}\n+3\t{'i': [0]}\n 4\t{'i': [1, 2, 3]}\n-5\t{'i': [hello]}\n+5\t{'i': [0]}\n+\n+statement error\n+SELECT i, CASE WHEN i%2=0 THEN {'i': [1,2,3]} ELSE {'i': ['hello']} END FROM range(6) tbl(i)\n+----\n+an explicit cast is required\ndiff --git a/test/sql/types/struct/struct_null_members.test b/test/sql/types/struct/struct_null_members.test\nindex 78c84ac8d46c..3d287385d887 100644\n--- a/test/sql/types/struct/struct_null_members.test\n+++ b/test/sql/types/struct/struct_null_members.test\n@@ -85,7 +85,7 @@ SELECT * FROM (VALUES\n \t({'x': 'duck', 'y': NULL}),\n \t({'x': NULL, 'y': 'goose'}),\n \t({'x': NULL, 'y': NULL}),\n-\t({'x': NULL, 'y': 0}),\n+\t({'x': NULL, 'y': '0'}),\n \t(NULL)\n ) tbl(i);\n \ndiff --git a/test/sql/types/timestamp/test_timestamp_auto_casting.test b/test/sql/types/timestamp/test_timestamp_auto_casting.test\nnew file mode 100644\nindex 000000000000..b21c97b7bf1d\n--- /dev/null\n+++ b/test/sql/types/timestamp/test_timestamp_auto_casting.test\n@@ -0,0 +1,43 @@\n+# name: test/sql/types/timestamp/test_timestamp_auto_casting.test\n+# description: Test auto-casting of timestamps\n+# group: [timestamp]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE timestamps(ts_SEC TIMESTAMP_S, ts_MS TIMESTAMP_MS, ts TIMESTAMP, ts_NS TIMESTAMP_NS)\n+\n+# FIXME - we don't actually support nanosecond precision in string parsing\n+statement ok\n+INSERT INTO timestamps VALUES ('2000-01-01 01:12:23', '2000-01-01 01:12:23.123', '2000-01-01 01:12:23.123456', '2000-01-01 01:12:23.123457');\n+\n+# All of these timestamps are different\n+query IIIIIIIIIIII\n+SELECT\n+\tts_SEC=ts_MS,\n+\tts_SEC=ts,\n+\tts_SEC=ts_NS,\n+\tts_MS=ts,\n+\tts_MS=ts_NS,\n+\tts=ts_NS,\n+\tts_MS=ts_SEC,\n+\tts=ts_SEC,\n+\tts_SEC=ts_NS,\n+\tts=ts_MS,\n+\tts_NS=ts_MS,\n+\tts_NS=ts,\n+FROM timestamps\n+----\n+false\tfalse\tfalse\tfalse\tfalse\tfalse\tfalse\tfalse\tfalse\tfalse\tfalse\tfalse\n+\n+# we always prefer the timestamp with the highest precision when auto-casting\n+query I\n+SELECT typeof([TIMESTAMP '2000-01-01 01:12:23.123456', TIMESTAMP_NS '2000-01-01 01:12:23.123456'])\n+----\n+TIMESTAMP_NS[]\n+\n+query I\n+SELECT typeof([TIMESTAMP_NS '2000-01-01 01:12:23.123456', TIMESTAMP '2000-01-01 01:12:23.123456'])\n+----\n+TIMESTAMP_NS[]\ndiff --git a/test/sql/types/union/union_list.test b/test/sql/types/union/union_list.test\nindex 4fe7590512d1..8fa13cd98677 100644\n--- a/test/sql/types/union/union_list.test\n+++ b/test/sql/types/union/union_list.test\n@@ -7,7 +7,7 @@ statement ok\n CREATE TABLE tbl1 (union_list UNION(str VARCHAR, num INT)[]);\n \n statement ok\n-INSERT INTO tbl1 VALUES ([1, 'one']), (['two', 2]), ([3, 'three', '3']), ([4]), (list_value('five')), ([6])\n+INSERT INTO tbl1 VALUES ([1::UNION(str VARCHAR, num INT), 'one']), (['two'::UNION(str VARCHAR, num INT), 2]), ([3::UNION(str VARCHAR, num INT), 'three', '3']), ([4]), (list_value('five')), ([6])\n \n query I\n SELECT * FROM tbl1\ndiff --git a/tools/juliapkg/test/test_big_nested.jl b/tools/juliapkg/test/test_big_nested.jl\nindex 3c8f1e1cc62a..f697d979dca6 100644\n--- a/tools/juliapkg/test/test_big_nested.jl\n+++ b/tools/juliapkg/test/test_big_nested.jl\n@@ -15,7 +15,7 @@ end\n \n     DBInterface.execute(con, \"CREATE TABLE bit_table (bits BIT);\")\n     # 131073 = 64 * 2048 + 1\n-    DBInterface.execute(con, \"INSERT INTO bit_table VALUES (bitstring('1010'::BIT, 131073));\")\n+    DBInterface.execute(con, \"INSERT INTO bit_table VALUES (bitstring('1010', 131073));\")\n     df = DataFrame(DBInterface.execute(con, \"SELECT * FROM bit_table;\"))\n     # Currently mapped to Julia in an odd way.\n     # Can reenable following https://github.com/duckdb/duckdb/issues/7065\ndiff --git a/tools/pythonpkg/tests/fast/pandas/test_df_recursive_nested.py b/tools/pythonpkg/tests/fast/pandas/test_df_recursive_nested.py\nindex 4ba24d63196e..f5cf2eb852dd 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_df_recursive_nested.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_df_recursive_nested.py\n@@ -38,7 +38,16 @@ def test_list_of_map(self, duckdb_cursor, pandas):\n             NULL,\n             [NULL, {'key': [3, 2, 4], 'value': [NULL, 'a', NULL]}, {'key': ['a', 'b', 'c'], 'value': [1, 2, 3]}],\n         ]\n-        reference_query = create_reference_query(data)\n+        reference_data = [\n+            [{'key': ['5'], 'value': [NULL]}, NULL, {'key': [], 'value': []}],\n+            NULL,\n+            [\n+                NULL,\n+                {'key': ['3', '2', '4'], 'value': [NULL, 'a', NULL]},\n+                {'key': ['a', 'b', 'c'], 'value': ['1', '2', '3']},\n+            ],\n+        ]\n+        reference_query = create_reference_query(reference_data)\n         df = pandas.DataFrame([{'a': data}])\n         check_equal(df, reference_query)\n \ndiff --git a/tools/pythonpkg/tests/fast/udf/test_remove_function.py b/tools/pythonpkg/tests/fast/udf/test_remove_function.py\nindex f73f793aee65..bb917400669a 100644\n--- a/tools/pythonpkg/tests/fast/udf/test_remove_function.py\n+++ b/tools/pythonpkg/tests/fast/udf/test_remove_function.py\n@@ -62,24 +62,17 @@ def func(x: str) -> str:\n \n         con = duckdb.connect()\n         con.create_function('func', func)\n-        rel1 = con.sql('select func(42)')\n-        rel2 = con.sql(\"select func('test')\")\n+\n+        with pytest.raises(duckdb.BinderException, match='No function matches the given name'):\n+            rel1 = con.sql('select func(42)')\n+        rel2 = con.sql(\"select func('test'::VARCHAR)\")\n         con.remove_function('func')\n \n         def also_func(x: int) -> int:\n             return x\n \n         con.create_function('func', also_func)\n-        res = rel1.fetchall()\n-        assert res[0][0] == 42\n-        \"\"\"\n-            Error: Binder Error: No function matches the given name and argument types 'func(VARCHAR)'. You might need to add explicit type casts.\n-                Candidate functions:\n-                func(BIGINT) -> BIGINT\n-        \"\"\"\n-        with pytest.raises(\n-            duckdb.InvalidInputException, match='Attempting to execute an unsuccessful or closed pending query result'\n-        ):\n+        with pytest.raises(duckdb.InvalidInputException, match='No function matches the given name'):\n             res = rel2.fetchall()\n \n     def test_overwrite_name(self):\n@@ -91,7 +84,7 @@ def func(x):\n         con.create_function('func', func, [BIGINT], BIGINT)\n \n         # create relation that uses the function\n-        rel1 = con.sql('select func(3)')\n+        rel1 = con.sql(\"select func('3')\")\n \n         def other_func(x):\n             return x\n",
  "problem_statement": "Comparing date with timestamp string yields unexpected results\n### What happens?\r\n\r\nHi \ud83e\udd86,\r\nWhen comparing a date with a timestamp string, we are getting `true` where we would expect `false`. This causes unintentional inclusion of the next (unwanted) date partition in the query results, when working with date-partitioned data.\r\n\r\nEDIT: also tried in current DuckDB WASM, same issue \r\n\r\n### To Reproduce\r\n\r\n```python\r\nimport platform; print(platform.machine())\r\nimport duckdb\r\nprint(duckdb.__version__)\r\nduckdb.sql(\"\"\"\r\nselect \r\n    '2023-12-11 15:54:45.119'::timestamp as a, \r\n    a::date as b, \r\n    \r\n    -- problem:\r\n    b < '2023-12-11 00:00:00', -- expect false, observe true\r\n    \r\n    -- work arounds:\r\n    b < '2023-12-11', -- compare vs implicit date\r\n    b < '2023-12-11 00:00:00'::timestamp -- explicit timestamp casting before comparison \r\n\"\"\")\r\n```\r\n```\r\nx86_64\r\n0.9.2\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502          a           \u2502     b      \u2502 (b < '2023-12-11 0\u2026  \u2502 (b < '2023-12-11') \u2502 (b < CAST('2023-12-11 00:00:00' AS\u2026  \u2502\r\n\u2502      timestamp       \u2502    date    \u2502       boolean        \u2502      boolean       \u2502               boolean                \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 2023-12-11 15:54:4\u2026  \u2502 2023-12-11 \u2502 true                 \u2502 false              \u2502 false                                \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### OS:\r\n\r\niOS x86_64\r\n\r\n### DuckDB Version:\r\n\r\n0.9.2\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nLukas Keller\r\n\r\n### Affiliation:\r\n\r\nNorthvolt\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "I believe this is a duplicate of duckdb/duckdb#8529. The problem is that the values are being compared as strings, instead of the PG tactic of initially tagging strings as \"unknown\". Fixing it would require a significant rewrite of the type binding system.",
  "created_at": "2024-01-03T09:20:56Z"
}