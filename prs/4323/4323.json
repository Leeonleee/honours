{
  "repo": "duckdb/duckdb",
  "pull_number": 4323,
  "instance_id": "duckdb__duckdb-4323",
  "issue_numbers": [
    "4241"
  ],
  "base_commit": "cf51f21dc0ef6dadd0b4c8dd89f00a6e46f53db0",
  "patch": "diff --git a/src/include/duckdb/main/query_profiler.hpp b/src/include/duckdb/main/query_profiler.hpp\nindex d675391b4fae..b4c5fb9b63f3 100644\n--- a/src/include/duckdb/main/query_profiler.hpp\n+++ b/src/include/duckdb/main/query_profiler.hpp\n@@ -149,11 +149,12 @@ class QueryProfiler {\n \tDUCKDB_API bool IsEnabled() const;\n \tDUCKDB_API bool IsDetailedEnabled() const;\n \tDUCKDB_API ProfilerPrintFormat GetPrintFormat() const;\n+\tDUCKDB_API bool PrintOptimizerOutput() const;\n \tDUCKDB_API string GetSaveLocation() const;\n \n \tDUCKDB_API static QueryProfiler &Get(ClientContext &context);\n \n-\tDUCKDB_API void StartQuery(string query, bool is_explain_analyze = false);\n+\tDUCKDB_API void StartQuery(string query, bool is_explain_analyze = false, bool start_at_optimizer = false);\n \tDUCKDB_API void EndQuery();\n \n \tDUCKDB_API void StartExplainAnalyze();\n@@ -166,8 +167,8 @@ class QueryProfiler {\n \n \tDUCKDB_API void Initialize(PhysicalOperator *root);\n \n-\tDUCKDB_API string QueryTreeToString(bool print_optimizer_output = false) const;\n-\tDUCKDB_API void QueryTreeToStream(std::ostream &str, bool print_optimizer_output = false) const;\n+\tDUCKDB_API string QueryTreeToString() const;\n+\tDUCKDB_API void QueryTreeToStream(std::ostream &str) const;\n \tDUCKDB_API void Print();\n \n \t//! return the printed as a string. Unlike ToString, which is always formatted as a string,\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex c1f703f32337..0dc41535acfd 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -265,6 +265,17 @@ unique_ptr<QueryResult> ClientContext::FetchResultInternal(ClientContextLock &lo\n \treturn result;\n }\n \n+static bool IsExplainAnalyze(SQLStatement *statement) {\n+\tif (!statement) {\n+\t\treturn false;\n+\t}\n+\tif (statement->type != StatementType::EXPLAIN_STATEMENT) {\n+\t\treturn false;\n+\t}\n+\tauto &explain = (ExplainStatement &)*statement;\n+\treturn explain.explain_type == ExplainType::EXPLAIN_ANALYZE;\n+}\n+\n shared_ptr<PreparedStatementData> ClientContext::CreatePreparedStatement(ClientContextLock &lock, const string &query,\n                                                                          unique_ptr<SQLStatement> statement,\n                                                                          vector<Value> *values) {\n@@ -272,6 +283,7 @@ shared_ptr<PreparedStatementData> ClientContext::CreatePreparedStatement(ClientC\n \tauto result = make_shared<PreparedStatementData>(statement_type);\n \n \tauto &profiler = QueryProfiler::Get(*this);\n+\tprofiler.StartQuery(query, IsExplainAnalyze(statement.get()), true);\n \tprofiler.StartPhase(\"planner\");\n \tPlanner planner(*this);\n \tif (values) {\n@@ -563,17 +575,6 @@ bool ClientContext::IsActiveResult(ClientContextLock &lock, BaseQueryResult *res\n \treturn active_query->open_result == result;\n }\n \n-static bool IsExplainAnalyze(SQLStatement *statement) {\n-\tif (!statement) {\n-\t\treturn false;\n-\t}\n-\tif (statement->type != StatementType::EXPLAIN_STATEMENT) {\n-\t\treturn false;\n-\t}\n-\tauto &explain = (ExplainStatement &)*statement;\n-\treturn explain.explain_type == ExplainType::EXPLAIN_ANALYZE;\n-}\n-\n unique_ptr<PendingQueryResult> ClientContext::PendingStatementOrPreparedStatementInternal(\n     ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,\n     shared_ptr<PreparedStatementData> &prepared, PendingQueryParameters parameters) {\ndiff --git a/src/main/connection.cpp b/src/main/connection.cpp\nindex 1a5c7c3527e3..c59f29ade93b 100644\n--- a/src/main/connection.cpp\n+++ b/src/main/connection.cpp\n@@ -1,17 +1,18 @@\n #include \"duckdb/main/connection.hpp\"\n-#include \"duckdb/main/query_profiler.hpp\"\n+\n+#include \"duckdb/execution/operator/persistent/buffered_csv_reader.hpp\"\n+#include \"duckdb/main/appender.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n+#include \"duckdb/main/connection_manager.hpp\"\n #include \"duckdb/main/database.hpp\"\n-#include \"duckdb/main/appender.hpp\"\n+#include \"duckdb/main/query_profiler.hpp\"\n #include \"duckdb/main/relation/query_relation.hpp\"\n #include \"duckdb/main/relation/read_csv_relation.hpp\"\n-#include \"duckdb/main/relation/table_relation.hpp\"\n #include \"duckdb/main/relation/table_function_relation.hpp\"\n+#include \"duckdb/main/relation/table_relation.hpp\"\n #include \"duckdb/main/relation/value_relation.hpp\"\n #include \"duckdb/main/relation/view_relation.hpp\"\n-#include \"duckdb/execution/operator/persistent/buffered_csv_reader.hpp\"\n #include \"duckdb/parser/parser.hpp\"\n-#include \"duckdb/main/connection_manager.hpp\"\n #include \"duckdb/planner/logical_operator.hpp\"\n \n namespace duckdb {\ndiff --git a/src/main/query_profiler.cpp b/src/main/query_profiler.cpp\nindex 4aa81db28e9e..142a5f030b19 100644\n--- a/src/main/query_profiler.cpp\n+++ b/src/main/query_profiler.cpp\n@@ -34,6 +34,10 @@ ProfilerPrintFormat QueryProfiler::GetPrintFormat() const {\n \treturn ClientConfig::GetConfig(context).profiler_print_format;\n }\n \n+bool QueryProfiler::PrintOptimizerOutput() const {\n+\treturn GetPrintFormat() == ProfilerPrintFormat::QUERY_TREE_OPTIMIZER || IsDetailedEnabled();\n+}\n+\n string QueryProfiler::GetSaveLocation() const {\n \treturn is_explain_analyze ? string() : ClientConfig::GetConfig(context).profiler_save_location;\n }\n@@ -42,13 +46,22 @@ QueryProfiler &QueryProfiler::Get(ClientContext &context) {\n \treturn *ClientData::Get(context).profiler;\n }\n \n-void QueryProfiler::StartQuery(string query, bool is_explain_analyze) {\n+void QueryProfiler::StartQuery(string query, bool is_explain_analyze, bool start_at_optimizer) {\n \tif (is_explain_analyze) {\n \t\tStartExplainAnalyze();\n \t}\n \tif (!IsEnabled()) {\n \t\treturn;\n \t}\n+\tif (start_at_optimizer && !PrintOptimizerOutput()) {\n+\t\t// This is the StartQuery call before the optimizer, but we don't have to print optimizer output\n+\t\treturn;\n+\t}\n+\tif (running) {\n+\t\t// Called while already running: this should only happen when we print optimizer output\n+\t\tD_ASSERT(PrintOptimizerOutput());\n+\t\treturn;\n+\t}\n \tthis->running = true;\n \tthis->query = move(query);\n \ttree_map.clear();\n@@ -139,11 +152,10 @@ string QueryProfiler::ToString() const {\n \tconst auto format = GetPrintFormat();\n \tswitch (format) {\n \tcase ProfilerPrintFormat::QUERY_TREE:\n+\tcase ProfilerPrintFormat::QUERY_TREE_OPTIMIZER:\n \t\treturn QueryTreeToString();\n \tcase ProfilerPrintFormat::JSON:\n \t\treturn ToJSON();\n-\tcase ProfilerPrintFormat::QUERY_TREE_OPTIMIZER:\n-\t\treturn QueryTreeToString(true);\n \tdefault:\n \t\tthrow InternalException(\"Unknown ProfilerPrintFormat \\\"%s\\\"\", format);\n \t}\n@@ -339,13 +351,13 @@ static string RenderTiming(double timing) {\n \treturn timing_s + \"s\";\n }\n \n-string QueryProfiler::QueryTreeToString(bool print_optimizer_output) const {\n+string QueryProfiler::QueryTreeToString() const {\n \tstd::stringstream str;\n-\tQueryTreeToStream(str, print_optimizer_output);\n+\tQueryTreeToStream(str);\n \treturn str.str();\n }\n \n-void QueryProfiler::QueryTreeToStream(std::ostream &ss, bool print_optimizer_output) const {\n+void QueryProfiler::QueryTreeToStream(std::ostream &ss) const {\n \tif (!IsEnabled()) {\n \t\tss << \"Query profiling is disabled. Call \"\n \t\t      \"Connection::EnableProfiling() to enable profiling!\";\n@@ -369,7 +381,7 @@ void QueryProfiler::QueryTreeToStream(std::ostream &ss, bool print_optimizer_out\n \tss << \"\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\\n\";\n \tss << \"\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\";\n \t// print phase timings\n-\tif (print_optimizer_output) {\n+\tif (PrintOptimizerOutput()) {\n \t\tbool has_previous_phase = false;\n \t\tfor (const auto &entry : GetOrderedPhaseTimings()) {\n \t\t\tif (!StringUtil::Contains(entry.first, \" > \")) {\n",
  "test_patch": "diff --git a/test/sql/detailed_profiler/test_detailed_profiler.test b/test/sql/detailed_profiler/test_detailed_profiler.test\nindex aaf14ad65a87..48c6bf46c8f1 100644\n--- a/test/sql/detailed_profiler/test_detailed_profiler.test\n+++ b/test/sql/detailed_profiler/test_detailed_profiler.test\n@@ -33,4 +33,12 @@ statement ok\n SELECT a FROM exprtest WHERE a BETWEEN 43 AND 44\n \n statement ok\n-SELECT CASE a WHEN 42 THEN 100 WHEN 43 THEN 200 ELSE 300 END FROM exprtest\n\\ No newline at end of file\n+SELECT CASE a WHEN 42 THEN 100 WHEN 43 THEN 200 ELSE 300 END FROM exprtest\n+\n+# At least one of the lines should contain the word \"Optimizer\" to verify that we're getting optimizer timings\n+query T\n+SELECT COUNT(*) > 0\n+FROM read_csv('__TEST_DIR__/test.json', columns={'c': 'VARCHAR'}, delim=NULL, header=0, quote=NULL, escape=NULL)\n+WHERE contains(c, 'Optimizer');\n+----\n+true\ndiff --git a/tools/shell/shell-test.py b/tools/shell/shell-test.py\nindex 41f1f094f8b9..f77a0270adc2 100644\n--- a/tools/shell/shell-test.py\n+++ b/tools/shell/shell-test.py\n@@ -440,6 +440,26 @@ def tf():\n test('.system echo 42', out=\"42\")\n test('.shell echo 42', out=\"42\")\n \n+# query profiling that includes the optimizer\n+test(\"\"\"\n+PRAGMA enable_profiling=query_tree_optimizer;\n+SELECT 42;\n+\"\"\", out=\"42\", err=\"Optimizer\")\n+\n+# detailed also includes optimizer\n+test(\"\"\"\n+PRAGMA enable_profiling;\n+PRAGMA profiling_mode=detailed;\n+SELECT 42;\n+\"\"\", out=\"42\", err=\"Optimizer\")\n+\n+# even in json output mode\n+test(\"\"\"\n+PRAGMA enable_profiling=json;\n+PRAGMA profiling_mode=detailed;\n+SELECT 42;\n+\"\"\", out=\"42\", err=\"optimizer\")\n+\n # this fails because db_config is missing\n # test('''\n # .eqp full\n",
  "problem_statement": "Profiler phase timings are reported inconsistently or not at all\n### What happens?\r\n\r\nWhen profiling is enabled, phase timings should be reported for the `optimizer`, `planning`, `column_binding` phases etc. These phases are not consistently reported under the `timings` key, as the value is usually an empty array. \r\n\r\n### To Reproduce\r\n\r\nbuild with TPCH enabled\r\n\r\n```\r\nPRAGMA enable_profiling=json;\r\nPRAGMA profile_output='profiling_output.json';\r\nCALL dbgen(sf=0.01);\r\nSELECT\r\n    nation,\r\n    o_year,\r\n    sum(amount) AS sum_profit\r\nFROM (\r\n    SELECT\r\n        n_name AS nation,\r\n        extract(year FROM o_orderdate) AS o_year,\r\n        l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity AS amount\r\n    FROM\r\n        part,\r\n        supplier,\r\n        lineitem,\r\n        partsupp,\r\n        orders,\r\n        nation\r\n    WHERE\r\n        s_suppkey = l_suppkey\r\n        AND ps_suppkey = l_suppkey\r\n        AND ps_partkey = l_partkey\r\n        AND p_partkey = l_partkey\r\n        AND o_orderkey = l_orderkey\r\n        AND s_nationkey = n_nationkey\r\n        AND p_name LIKE '%green%') AS profit\r\nGROUP BY\r\n    nation,\r\n    o_year\r\nORDER BY\r\n    nation,\r\n    o_year DESC;\r\n```\r\n\r\nOr if using python\r\n```\r\nimport duckdb\r\ncon = duckdb.connect()\r\ncon.execute('PRAGMA enable_profiling=json')\r\ncon.execute(\"PRAGMA profile_output='profiling_output.json')\r\ncon.execute(\"CALL dbgen(sf=0.1)\")\r\ncon.execute(\"SELECT nation, o_year, sum(amount) AS sum_profit FROM ( SELECT n_name AS nation, extract(year FROM o_orderdate) AS o_year, l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity AS amount FROM part, supplier, lineitem, partsupp, orders, nation WHERE s_suppkey = l_suppkey AND ps_suppkey = l_suppkey AND ps_partkey = l_partkey AND p_partkey = l_partkey AND o_orderkey = l_orderkey AND s_nationkey = n_nationkey AND p_name LIKE '%green%') AS profit GROUP BY nation, o_year ORDER BY nation, o_year DESC\")\r\n```\r\n\r\nThen inspect the profiling output. The following phases should be reported within the top level `timings` key\r\n1. column_binding\r\n2. resolve_types\r\n3. create_plan\r\n4. planner\r\n5. optimizer\r\n6. physical_planner\r\n7. binder\r\nIncluding a number of optimizer types.\r\n\r\n### OS:\r\n\r\nMacOS Monterey version 12.1\r\n\r\n### DuckDB Version:\r\n\r\n0.4.1.dev1096\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nTom Ebergen\r\n\r\n### Affiliation:\r\n\r\nMasters Student\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2022-08-08T12:02:19Z"
}