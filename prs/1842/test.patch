diff --git a/test/optimizer/statistics/statistics_struct.test b/test/optimizer/statistics/statistics_struct.test
new file mode 100644
index 000000000000..1a080b84620f
--- /dev/null
+++ b/test/optimizer/statistics/statistics_struct.test
@@ -0,0 +1,30 @@
+# name: test/optimizer/statistics/statistics_struct.test
+# description: Statistics propagation test with structs
+# group: [statistics]
+
+statement ok
+PRAGMA enable_verification;
+
+statement ok
+CREATE TABLE structs AS SELECT {'i': i} c FROM range(4) tbl(i);
+
+statement ok
+PRAGMA explain_output = OPTIMIZED_ONLY;
+
+# we can statically determine IS NULL/IS NOT NULL are false, if there are no null values for this column
+query II
+EXPLAIN SELECT c IS NULL FROM structs;
+----
+logical_opt	<!REGEX>:.*IS_NULL.*
+
+# the same applies to c['i']
+query II
+EXPLAIN SELECT c['i'] IS NULL FROM structs;
+----
+logical_opt	<!REGEX>:.*IS_NULL.*
+
+# filter is out of range
+query II
+EXPLAIN SELECT * FROM structs WHERE c['i']=4;
+----
+logical_opt	<REGEX>:.*EMPTY_RESULT.*
diff --git a/test/sql/aggregate/aggregates/test_histogram.test b/test/sql/aggregate/aggregates/test_histogram.test
index 07f835e0310b..e460556052aa 100644
--- a/test/sql/aggregate/aggregates/test_histogram.test
+++ b/test/sql/aggregate/aggregates/test_histogram.test
@@ -5,18 +5,14 @@
 statement ok
 PRAGMA enable_verification
 
-# Empty Table
 query I
-SELECT histogram(i) FROM range(100) tbl(i) WHERE 1=0;
+select histogram(NULL)
 ----
 NULL
 
-#Corner cases
-statement error
-select histogram()
-
+# Empty Table
 query I
-select histogram(NULL)
+SELECT histogram(i) FROM range(100) tbl(i) WHERE 1=0;
 ----
 NULL
 
@@ -25,9 +21,6 @@ select histogram(1)
 ----
 {1=1}
 
-statement error
-select histogram(*)
-
 query I
 SELECT histogram(2) FROM range(100);
 ----
@@ -90,4 +83,9 @@ select g,histogram(g) over (partition by g%2)
 3	{1=2, 3=1, 5=1}
 5	{1=2, 3=1, 5=1}
 
+#Corner cases
+statement error
+select histogram()
 
+statement error
+select histogram(*)
diff --git a/test/sql/function/time/test_extract_stats.test b/test/sql/function/time/test_extract_stats.test
index f4ee42886e9e..05a9db0d2bfc 100644
--- a/test/sql/function/time/test_extract_stats.test
+++ b/test/sql/function/time/test_extract_stats.test
@@ -18,29 +18,29 @@ PRAGMA disable_verification
 query I
 SELECT stats(EXTRACT(second FROM i)) FROM times LIMIT 1
 ----
-<REGEX>:.*true.*0.*60.*
+<REGEX>:.*0.*60.*true.*
 
 query I
 SELECT stats(EXTRACT(minute FROM i)) FROM times LIMIT 1
 ----
-<REGEX>:.*true.*0.*60.*
+<REGEX>:.*0.*60.*true.*
 
 query I
 SELECT stats(EXTRACT(hour FROM i)) FROM times LIMIT 1
 ----
-<REGEX>:.*true.*0.*24.*
+<REGEX>:.*0.*24.*true.*
 
 query I
 SELECT stats(EXTRACT(milliseconds FROM i)) FROM times LIMIT 1
 ----
-<REGEX>:.*true.*0.*60000.*
+<REGEX>:.*0.*60000.*true.*
 
 query I
 SELECT stats(EXTRACT(microseconds FROM i)) FROM times LIMIT 1
 ----
-<REGEX>:.*true.*0.*60000000.*
+<REGEX>:.*0.*60000000.*true.*
 
 query I
 SELECT stats(EXTRACT(epoch FROM i)) FROM times LIMIT 1
 ----
-<REGEX>:.*true.*0.*86400.*
+<REGEX>:.*0.*86400.*true.*
diff --git a/test/sql/pragma/test_storage_info.test b/test/sql/pragma/test_storage_info.test
index f719f48b56cf..008273f6f131 100644
--- a/test/sql/pragma/test_storage_info.test
+++ b/test/sql/pragma/test_storage_info.test
@@ -24,6 +24,16 @@ CREATE VIEW v1 AS SELECT 42
 statement error
 PRAGMA storage_info('v1')
 
-# non-existant table
+# non-existent table
 statement error
-PRAGMA storage_info('bla')
\ No newline at end of file
+PRAGMA storage_info('bla')
+
+# different types
+statement ok
+CREATE TABLE different_types(i INTEGER, j VARCHAR, k STRUCT(k INTEGER, l VARCHAR))
+
+statement ok
+INSERT INTO different_types VALUES (1, 'hello', {'k': 3, 'l': 'hello'})
+
+statement ok
+PRAGMA storage_info('different_types')
diff --git a/test/sql/storage/test_store_nulls_strings.test b/test/sql/storage/test_store_nulls_strings.test
index 5a26d95eced7..2b6e63add585 100644
--- a/test/sql/storage/test_store_nulls_strings.test
+++ b/test/sql/storage/test_store_nulls_strings.test
@@ -15,6 +15,13 @@ INSERT INTO test VALUES (NULL, 'hello'), (13, 'abcdefgh'), (12, NULL)
 statement ok
 CHECKPOINT
 
+query II
+SELECT a, b FROM test ORDER BY a
+----
+NULL	hello
+12	NULL
+13	abcdefgh
+
 restart
 
 query II
diff --git a/test/sql/storage/types/map/map_storage.test b/test/sql/storage/types/map/map_storage.test
new file mode 100644
index 000000000000..ffa5c89e4d5c
--- /dev/null
+++ b/test/sql/storage/types/map/map_storage.test
@@ -0,0 +1,31 @@
+# name: test/sql/storage/types/map/map_storage.test
+# description: Test maps with persistent storage
+# group: [map]
+
+# FIXME: maps need list support in storage
+
+mode skip
+
+# load the DB from disk
+load __TEST_DIR__/map_storage_test.db
+
+statement ok
+CREATE TABLE a(b MAP(INTEGER,INTEGER));
+
+statement ok
+INSERT INTO a VALUES (MAP([1], [2])), (MAP([1, 2, 3], [4, 5, 6]));
+
+query I
+SELECT * FROM a;
+----
+{1=2}
+{1=4, 2=5, 3=6}
+
+restart
+
+query I
+SELECT * FROM a;
+----
+{1=2}
+{1=4, 2=5, 3=6}
+
diff --git a/test/sql/storage/types/struct/nested_struct_storage.test b/test/sql/storage/types/struct/nested_struct_storage.test
new file mode 100644
index 000000000000..0d150dffdd14
--- /dev/null
+++ b/test/sql/storage/types/struct/nested_struct_storage.test
@@ -0,0 +1,157 @@
+# name: test/sql/storage/types/struct/nested_struct_storage.test
+# description: Test structs with persistent storage
+# group: [struct]
+
+# load the DB from disk
+load __TEST_DIR__/struct_storage_test.db
+
+statement ok
+CREATE TABLE a AS SELECT {
+	'r1': {
+		'a': 'hello',
+		'b': 3
+	},
+	'r2': {
+		'a': 'world',
+		'b': 17,
+		'c': NULL
+	}
+} c
+
+query I
+SELECT * FROM a
+----
+{'r1': {'a': hello, 'b': 3}, 'r2': {'a': world, 'b': 17, 'c': NULL}}
+
+query I
+SELECT c['r1']['a'] from a
+----
+hello
+
+restart
+
+query I
+SELECT * FROM a
+----
+{'r1': {'a': hello, 'b': 3}, 'r2': {'a': world, 'b': 17, 'c': NULL}}
+
+query I
+SELECT c['r1']['a'] from a
+----
+hello
+
+# update
+statement ok
+UPDATE a SET c={
+	'r1': {
+		'a': 'blabla',
+		'b': 3
+	},
+	'r2': {
+		'a': 'world',
+		'b': 18,
+		'c': NULL
+	}
+}
+
+query I
+SELECT * FROM a
+----
+{'r1': {'a': blabla, 'b': 3}, 'r2': {'a': world, 'b': 18, 'c': NULL}}
+
+query I
+SELECT c['r1']['a'] from a
+----
+blabla
+
+restart
+
+query I
+SELECT * FROM a
+----
+{'r1': {'a': blabla, 'b': 3}, 'r2': {'a': world, 'b': 18, 'c': NULL}}
+
+query I
+SELECT c['r1']['a'] from a
+----
+blabla
+
+# nulls at different levels
+statement ok
+INSERT INTO a VALUES (
+{
+	'r1': {
+		'a': NULL,
+		'b': 3
+	},
+	'r2': {
+		'a': NULL,
+		'b': 17,
+		'c': NULL
+	}
+})
+
+query I
+SELECT * FROM a
+----
+{'r1': {'a': blabla, 'b': 3}, 'r2': {'a': world, 'b': 18, 'c': NULL}}
+{'r1': {'a': NULL, 'b': 3}, 'r2': {'a': NULL, 'b': 17, 'c': NULL}}
+
+statement ok
+INSERT INTO a VALUES ({
+	'r1': NULL,
+	'r2': {
+		'a': NULL,
+		'b': 17,
+		'c': NULL
+	}
+})
+
+query I
+SELECT * FROM a
+----
+{'r1': {'a': blabla, 'b': 3}, 'r2': {'a': world, 'b': 18, 'c': NULL}}
+{'r1': {'a': NULL, 'b': 3}, 'r2': {'a': NULL, 'b': 17, 'c': NULL}}
+{'r1': NULL, 'r2': {'a': NULL, 'b': 17, 'c': NULL}}
+
+statement ok
+INSERT INTO a VALUES ({
+	'r1': NULL,
+	'r2': NULL
+})
+
+query I
+SELECT * FROM a
+----
+{'r1': {'a': blabla, 'b': 3}, 'r2': {'a': world, 'b': 18, 'c': NULL}}
+{'r1': {'a': NULL, 'b': 3}, 'r2': {'a': NULL, 'b': 17, 'c': NULL}}
+{'r1': NULL, 'r2': {'a': NULL, 'b': 17, 'c': NULL}}
+{'r1': NULL, 'r2': NULL}
+
+statement ok
+INSERT INTO a VALUES(NULL)
+
+query I
+SELECT * FROM a
+----
+{'r1': {'a': blabla, 'b': 3}, 'r2': {'a': world, 'b': 18, 'c': NULL}}
+{'r1': {'a': NULL, 'b': 3}, 'r2': {'a': NULL, 'b': 17, 'c': NULL}}
+{'r1': NULL, 'r2': {'a': NULL, 'b': 17, 'c': NULL}}
+{'r1': NULL, 'r2': NULL}
+NULL
+
+restart
+
+query I
+SELECT * FROM a
+----
+{'r1': {'a': blabla, 'b': 3}, 'r2': {'a': world, 'b': 18, 'c': NULL}}
+{'r1': {'a': NULL, 'b': 3}, 'r2': {'a': NULL, 'b': 17, 'c': NULL}}
+{'r1': NULL, 'r2': {'a': NULL, 'b': 17, 'c': NULL}}
+{'r1': NULL, 'r2': NULL}
+NULL
+
+# verify that no null values have crept their way into the stats
+query II
+select column_path, stats from pragma_storage_info('a') where  stats LIKE '%[Min: -2147483648, Max: -2147483648]%'
+----
diff --git a/test/sql/storage/types/struct/struct_large_nulls.test_slow b/test/sql/storage/types/struct/struct_large_nulls.test_slow
new file mode 100644
index 000000000000..8f4117893262
--- /dev/null
+++ b/test/sql/storage/types/struct/struct_large_nulls.test_slow
@@ -0,0 +1,108 @@
+# name: test/sql/storage/types/struct/struct_large_nulls.test_slow
+# description: Test that we reclaim space when dropping tables with struct columns
+# group: [struct]
+
+load __TEST_DIR__/test_struct_large_nulls.db
+
+statement ok
+CREATE TABLE structs AS SELECT -i-1 id, {'i': -i-1, 'j': i::VARCHAR} c FROM range(10000000) tbl(i);
+
+statement ok
+INSERT INTO structs SELECT i id, {'i': i, 'j': i::VARCHAR} c FROM range(1000) tbl(i);
+
+query III
+SELECT COUNT(*), COUNT(c['i']), COUNT(c['j']) FROM structs
+----
+10001000	10001000	10001000
+
+query I
+SELECT COUNT(*) FROM structs WHERE c['i'] >= 0
+----
+1000
+
+# verify that no null values have crept their way into the stats
+query II
+select column_path, stats from pragma_storage_info('structs') where stats LIKE '%[Min: -2147483648, Max: -2147483648]%'
+----
+
+query I
+UPDATE structs SET id=NULL, c={'i': NULL, 'j': c['i']::VARCHAR} WHERE c['i'] >= 0 AND c['i'] % 4 = 0
+----
+250
+
+# verify that no null values have crept their way into the stats
+query II
+select column_path, stats from pragma_storage_info('structs') where stats LIKE '%[Min: -2147483648, Max: -2147483648]%'
+----
+
+query I
+UPDATE structs SET c={'i': c['i'], 'j': NULL} WHERE c['i'] >= 0 AND c['i'] % 4 = 1
+----
+250
+
+# verify that no null values have crept their way into the stats
+query II
+select column_path, stats from pragma_storage_info('structs') where stats LIKE '%[Min: -2147483648, Max: -2147483648]%'
+----
+
+query I
+UPDATE structs SET id=NULL, c={'i': NULL, 'j': NULL} WHERE c['i'] >= 0 AND c['i'] % 4 = 2
+----
+250
+
+# verify that no null values have crept their way into the stats
+query II
+select column_path, stats from pragma_storage_info('structs') where stats LIKE '%[Min: -2147483648, Max: -2147483648]%'
+----
+
+query I
+UPDATE structs SET id=NULL, c=NULL WHERE c['i'] >= 0 AND c['i'] % 4 = 3
+----
+250
+
+# verify that no null values have crept their way into the stats
+query II
+select column_path, stats from pragma_storage_info('structs') where stats LIKE '%[Min: -2147483648, Max: -2147483648]%'
+----
+
+# query the null values
+query I
+SELECT COUNT(*) FROM structs WHERE c IS NULL
+----
+250
+
+query I
+SELECT COUNT(*) FROM structs WHERE c['i'] IS NULL
+----
+750
+
+query I
+SELECT COUNT(*) FROM structs WHERE c['j'] IS NULL
+----
+750
+
+query I
+SELECT COUNT(c['j']) FROM structs WHERE (c['i'] >= 0 OR c['i'] IS NULL)
+----
+250
+
+query I nosort sum_result
+SELECT SUM(id) FROM structs WHERE id >= 0
+----
+
+query I nosort sum_result
+SELECT SUM(c['i']) FROM structs WHERE c['i'] >= 0
+----
+
+query I nosort sum_result_nofilter
+SELECT SUM(id) FROM structs
+----
+
+query I nosort sum_result_nofilter
+SELECT SUM(c['i']) FROM structs
+----
+
+query III
+SELECT COUNT(c['j']), MIN(c['j']), MAX(c['j']) FROM structs WHERE (c['i'] >= 0 OR c['i'] IS NULL)
+----
+250	0	996
diff --git a/test/sql/storage/types/struct/struct_reclaim_space_drop.test_slow b/test/sql/storage/types/struct/struct_reclaim_space_drop.test_slow
new file mode 100644
index 000000000000..2b8369d48c7b
--- /dev/null
+++ b/test/sql/storage/types/struct/struct_reclaim_space_drop.test_slow
@@ -0,0 +1,48 @@
+# name: test/sql/storage/types/struct/struct_reclaim_space_drop.test_slow
+# description: Test that we reclaim space when dropping tables with struct columns
+# group: [struct]
+
+load __TEST_DIR__/test_reclaim_space.db
+
+statement ok
+PRAGMA force_checkpoint;
+
+statement ok
+CREATE TABLE structs AS SELECT {'i': i, 'j': i::VARCHAR} c FROM range(10000000) tbl(i);
+
+statement ok
+CHECKPOINT;
+
+statement ok
+CHECKPOINT;
+
+query III
+SELECT MIN(c['i']), MAX(c['i']), COUNT(*) FROM structs
+----
+0	9999999	10000000
+
+loop i 0 10
+
+statement ok
+DROP TABLE structs;
+
+statement ok
+CREATE TABLE structs AS SELECT {'i': i, 'j': i::VARCHAR} c FROM range(10000000) tbl(i);
+
+query III
+SELECT MIN(c['i']), MAX(c['i']), COUNT(*) FROM structs
+----
+0	9999999	10000000
+
+statement ok
+CHECKPOINT;
+
+query I nosort expected_blocks
+select round(total_blocks / 100.0) from pragma_database_size();
+
+query III
+SELECT MIN(c['i']), MAX(c['i']), COUNT(*) FROM structs
+----
+0	9999999	10000000
+
+endloop
diff --git a/test/sql/storage/types/struct/struct_storage.test b/test/sql/storage/types/struct/struct_storage.test
new file mode 100644
index 000000000000..45ec1994326f
--- /dev/null
+++ b/test/sql/storage/types/struct/struct_storage.test
@@ -0,0 +1,95 @@
+# name: test/sql/storage/types/struct/struct_storage.test
+# description: Test structs with persistent storage
+# group: [struct]
+
+# load the DB from disk
+load __TEST_DIR__/struct_storage_test.db
+
+statement ok
+CREATE TABLE a(b STRUCT(i INTEGER, j INTEGER));
+
+statement ok
+INSERT INTO a VALUES ({'i': 1, 'j': 2}), (NULL), ({'i': NULL, 'j': 2}), (ROW(1, NULL));
+
+query I
+SELECT * FROM a;
+----
+{'i': 1, 'j': 2}
+NULL
+{'i': NULL, 'j': 2}
+{'i': 1, 'j': NULL}
+
+query I
+SELECT COUNT(*) FROM a WHERE b IS NULL;
+----
+1
+
+restart
+
+query I
+SELECT * FROM a;
+----
+{'i': 1, 'j': 2}
+NULL
+{'i': NULL, 'j': 2}
+{'i': 1, 'j': NULL}
+
+query I
+SELECT COUNT(*) FROM a WHERE b IS NULL;
+----
+1
+
+# deletes
+query I
+DELETE FROM a WHERE (b).i=1
+----
+2
+
+query I
+SELECT * FROM a;
+----
+NULL
+{'i': NULL, 'j': 2}
+
+restart
+
+query I
+SELECT * FROM a;
+----
+NULL
+{'i': NULL, 'j': 2}
+
+query I
+SELECT COUNT(*) FROM a WHERE b IS NULL;
+----
+1
+
+# updates
+query I
+UPDATE a SET b={i: 7, j: 9} WHERE b IS NULL
+----
+1
+
+query I
+SELECT * FROM a;
+----
+{'i': 7, 'j': 9}
+{'i': NULL, 'j': 2}
+
+query I
+SELECT COUNT(*) FROM a WHERE b IS NULL;
+----
+0
+
+restart
+
+query I
+SELECT * FROM a;
+----
+{'i': 7, 'j': 9}
+{'i': NULL, 'j': 2}
+
+query I
+SELECT COUNT(*) FROM a WHERE b IS NULL;
+----
+0
diff --git a/test/sql/storage/types/struct/wal_struct_storage.test b/test/sql/storage/types/struct/wal_struct_storage.test
new file mode 100644
index 000000000000..3544f887c4b5
--- /dev/null
+++ b/test/sql/storage/types/struct/wal_struct_storage.test
@@ -0,0 +1,113 @@
+# name: test/sql/storage/types/struct/wal_struct_storage.test
+# description: Test structs with persistent storage
+# group: [struct]
+
+# load the DB from disk
+load __TEST_DIR__/struct_storage_test.db
+
+statement ok
+PRAGMA disable_checkpoint_on_shutdown
+
+statement ok
+PRAGMA wal_autocheckpoint='1TB';
+
+statement ok
+CREATE TABLE a(b STRUCT(i INTEGER, j INTEGER));
+
+statement ok
+INSERT INTO a VALUES ({'i': 1, 'j': 2}), (NULL), ({'i': NULL, 'j': 2}), (ROW(1, NULL));
+
+query I
+SELECT * FROM a;
+----
+{'i': 1, 'j': 2}
+NULL
+{'i': NULL, 'j': 2}
+{'i': 1, 'j': NULL}
+
+query I
+SELECT COUNT(*) FROM a WHERE b IS NULL;
+----
+1
+
+restart
+
+statement ok
+PRAGMA disable_checkpoint_on_shutdown
+
+statement ok
+PRAGMA wal_autocheckpoint='1TB';
+
+query I
+SELECT * FROM a;
+----
+{'i': 1, 'j': 2}
+NULL
+{'i': NULL, 'j': 2}
+{'i': 1, 'j': NULL}
+
+query I
+SELECT COUNT(*) FROM a WHERE b IS NULL;
+----
+1
+
+# deletes
+query I
+DELETE FROM a WHERE (b).i=1
+----
+2
+
+query I
+SELECT * FROM a;
+----
+NULL
+{'i': NULL, 'j': 2}
+
+restart
+
+statement ok
+PRAGMA disable_checkpoint_on_shutdown
+
+statement ok
+PRAGMA wal_autocheckpoint='1TB';
+
+query I
+SELECT * FROM a;
+----
+NULL
+{'i': NULL, 'j': 2}
+
+query I
+SELECT COUNT(*) FROM a WHERE b IS NULL;
+----
+1
+
+# updates
+query I
+UPDATE a SET b={i: 7, j: 9} WHERE b IS NULL
+----
+1
+
+query I
+SELECT * FROM a;
+----
+{'i': 7, 'j': 9}
+{'i': NULL, 'j': 2}
+
+query I
+SELECT COUNT(*) FROM a WHERE b IS NULL;
+----
+0
+
+restart
+
+query I
+SELECT * FROM a;
+----
+{'i': 7, 'j': 9}
+{'i': NULL, 'j': 2}
+
+query I
+SELECT COUNT(*) FROM a WHERE b IS NULL;
+----
+0
diff --git a/test/sql/tpch/tpch_sf001_struct.test_slow b/test/sql/tpch/tpch_sf001_struct.test_slow
new file mode 100644
index 000000000000..e957d69665cb
--- /dev/null
+++ b/test/sql/tpch/tpch_sf001_struct.test_slow
@@ -0,0 +1,214 @@
+# name: test/sql/tpch/tpch_sf001_struct.test_slow
+# description: Test TPC-H SF0.01
+# group: [tpch]
+
+require tpch
+
+load __TEST_DIR__/tpch_sf001_struct.db
+
+statement ok
+CALL dbgen(sf=0.01, suffix='_normal');
+
+statement ok
+CREATE TABLE lineitem_struct AS SELECT {
+'l_orderkey': l_orderkey,
+'l_partkey': l_partkey,
+'l_suppkey': l_suppkey,
+'l_linenumber': l_linenumber,
+'l_quantity': l_quantity,
+'l_extendedprice': l_extendedprice,
+'l_discount': l_discount,
+'l_tax': l_tax,
+'l_returnflag': l_returnflag,
+'l_linestatus': l_linestatus,
+'l_shipdate': l_shipdate,
+'l_commitdate': l_commitdate,
+'l_receiptdate': l_receiptdate,
+'l_shipinstruct': l_shipinstruct,
+'l_shipmode': l_shipmode,
+'l_comment': l_comment
+} c FROM lineitem_normal;
+
+statement ok
+CREATE VIEW lineitem AS SELECT
+c['l_orderkey'] AS l_orderkey,
+c['l_partkey'] AS l_partkey,
+c['l_suppkey'] AS l_suppkey,
+c['l_linenumber'] AS l_linenumber,
+c['l_quantity'] AS l_quantity,
+c['l_extendedprice'] AS l_extendedprice,
+c['l_discount'] AS l_discount,
+c['l_tax'] AS l_tax,
+c['l_returnflag'] AS l_returnflag,
+c['l_linestatus'] AS l_linestatus,
+c['l_shipdate'] AS l_shipdate,
+c['l_commitdate'] AS l_commitdate,
+c['l_receiptdate'] AS l_receiptdate,
+c['l_shipinstruct'] AS l_shipinstruct,
+c['l_shipmode'] AS l_shipmode,
+c['l_comment'] AS l_comment
+FROM lineitem_struct
+
+statement ok
+CREATE TABLE orders_struct AS SELECT {
+'o_orderkey': o_orderkey,
+'o_custkey': o_custkey,
+'o_orderstatus': o_orderstatus,
+'o_totalprice': o_totalprice,
+'o_orderdate': o_orderdate,
+'o_orderpriority': o_orderpriority,
+'o_clerk': o_clerk,
+'o_shippriority': o_shippriority,
+'o_comment': o_comment
+} c FROM orders_normal;
+
+statement ok
+CREATE VIEW orders AS SELECT
+c['o_orderkey'] AS o_orderkey,
+c['o_custkey'] AS o_custkey,
+c['o_orderstatus'] AS o_orderstatus,
+c['o_totalprice'] AS o_totalprice,
+c['o_orderdate'] AS o_orderdate,
+c['o_orderpriority'] AS o_orderpriority,
+c['o_clerk'] AS o_clerk,
+c['o_shippriority'] AS o_shippriority,
+c['o_comment'] AS o_comment
+FROM orders_struct
+
+statement ok
+CREATE TABLE part_struct AS SELECT {
+'p_partkey': p_partkey,
+'p_name': p_name,
+'p_mfgr': p_mfgr,
+'p_brand': p_brand,
+'p_type': p_type,
+'p_size': p_size,
+'p_container': p_container,
+'p_retailprice': p_retailprice,
+'p_comment': p_comment
+} c FROM part_normal;
+
+statement ok
+CREATE VIEW part AS SELECT
+c['p_partkey'] AS p_partkey,
+c['p_name'] AS p_name,
+c['p_mfgr'] AS p_mfgr,
+c['p_brand'] AS p_brand,
+c['p_type'] AS p_type,
+c['p_size'] AS p_size,
+c['p_container'] AS p_container,
+c['p_retailprice'] AS p_retailprice,
+c['p_comment'] AS p_comment
+FROM part_struct
+
+statement ok
+CREATE TABLE partsupp_struct AS SELECT {
+'ps_partkey': ps_partkey,
+'ps_suppkey': ps_suppkey,
+'ps_availqty': ps_availqty,
+'ps_supplycost': ps_supplycost,
+'ps_comment': ps_comment
+} c FROM partsupp_normal;
+
+statement ok
+CREATE VIEW partsupp AS SELECT
+c['ps_partkey'] AS ps_partkey,
+c['ps_suppkey'] AS ps_suppkey,
+c['ps_availqty'] AS ps_availqty,
+c['ps_supplycost'] AS ps_supplycost,
+c['ps_comment'] AS ps_comment
+FROM partsupp_struct
+
+statement ok
+CREATE TABLE customer_struct AS SELECT {
+'c_custkey': c_custkey,
+'c_name': c_name,
+'c_address': c_address,
+'c_nationkey': c_nationkey,
+'c_phone': c_phone,
+'c_acctbal': c_acctbal,
+'c_mktsegment': c_mktsegment,
+'c_comment': c_comment
+} c FROM customer_normal;
+
+statement ok
+CREATE VIEW customer AS SELECT
+c['c_custkey'] AS c_custkey,
+c['c_name'] AS c_name,
+c['c_address'] AS c_address,
+c['c_nationkey'] AS c_nationkey,
+c['c_phone'] AS c_phone,
+c['c_acctbal'] AS c_acctbal,
+c['c_mktsegment'] AS c_mktsegment,
+c['c_comment'] AS c_comment
+FROM customer_struct
+
+statement ok
+CREATE TABLE region_struct AS SELECT {
+'r_regionkey': r_regionkey,
+'r_name': r_name,
+'r_comment': r_comment
+} c FROM region_normal;
+
+statement ok
+CREATE VIEW region AS SELECT
+c['r_regionkey'] AS r_regionkey,
+c['r_name'] AS r_name,
+c['r_comment'] AS r_comment
+FROM region_struct
+
+statement ok
+CREATE TABLE supplier_struct AS SELECT {
+'s_suppkey': s_suppkey,
+'s_name': s_name,
+'s_address': s_address,
+'s_nationkey': s_nationkey,
+'s_phone': s_phone,
+'s_acctbal': s_acctbal,
+'s_comment': s_comment
+} c FROM supplier_normal;
+
+statement ok
+CREATE VIEW supplier AS SELECT
+c['s_suppkey'] AS s_suppkey,
+c['s_name'] AS s_name,
+c['s_address'] AS s_address,
+c['s_nationkey'] AS s_nationkey,
+c['s_phone'] AS s_phone,
+c['s_acctbal'] AS s_acctbal,
+c['s_comment'] AS s_comment
+FROM supplier_struct
+
+statement ok
+CREATE TABLE nation_struct AS SELECT {
+'n_nationkey': n_nationkey,
+'n_name': n_name,
+'n_regionkey': n_regionkey,
+'n_comment': n_comment
+} c FROM nation_normal;
+
+statement ok
+CREATE VIEW nation AS SELECT
+c['n_nationkey'] AS n_nationkey,
+c['n_name'] AS n_name,
+c['n_regionkey'] AS n_regionkey,
+c['n_comment'] AS n_comment
+FROM nation_struct
+
+loop i 1 9
+
+query I
+PRAGMA tpch(${i})
+----
+<FILE>:extension/tpch/dbgen/answers/sf0.01/q0${i}.csv
+
+endloop
+
+loop i 10 23
+
+query I
+PRAGMA tpch(${i})
+----
+<FILE>:extension/tpch/dbgen/answers/sf0.01/q${i}.csv
+
+endloop
diff --git a/test/sql/tpch/tpch_sf1_struct.test_slow b/test/sql/tpch/tpch_sf1_struct.test_slow
new file mode 100644
index 000000000000..6f90a4ef8578
--- /dev/null
+++ b/test/sql/tpch/tpch_sf1_struct.test_slow
@@ -0,0 +1,214 @@
+# name: test/sql/tpch/tpch_sf1_struct.test_slow
+# description: Test TPC-H SF1
+# group: [tpch]
+
+require tpch
+
+load __TEST_DIR__/tpch_sf1_struct.db
+
+statement ok
+CALL dbgen(sf=1, suffix='_normal');
+
+statement ok
+CREATE TABLE lineitem_struct AS SELECT {
+'l_orderkey': l_orderkey,
+'l_partkey': l_partkey,
+'l_suppkey': l_suppkey,
+'l_linenumber': l_linenumber,
+'l_quantity': l_quantity,
+'l_extendedprice': l_extendedprice,
+'l_discount': l_discount,
+'l_tax': l_tax,
+'l_returnflag': l_returnflag,
+'l_linestatus': l_linestatus,
+'l_shipdate': l_shipdate,
+'l_commitdate': l_commitdate,
+'l_receiptdate': l_receiptdate,
+'l_shipinstruct': l_shipinstruct,
+'l_shipmode': l_shipmode,
+'l_comment': l_comment
+} c FROM lineitem_normal;
+
+statement ok
+CREATE VIEW lineitem AS SELECT
+c['l_orderkey'] AS l_orderkey,
+c['l_partkey'] AS l_partkey,
+c['l_suppkey'] AS l_suppkey,
+c['l_linenumber'] AS l_linenumber,
+c['l_quantity'] AS l_quantity,
+c['l_extendedprice'] AS l_extendedprice,
+c['l_discount'] AS l_discount,
+c['l_tax'] AS l_tax,
+c['l_returnflag'] AS l_returnflag,
+c['l_linestatus'] AS l_linestatus,
+c['l_shipdate'] AS l_shipdate,
+c['l_commitdate'] AS l_commitdate,
+c['l_receiptdate'] AS l_receiptdate,
+c['l_shipinstruct'] AS l_shipinstruct,
+c['l_shipmode'] AS l_shipmode,
+c['l_comment'] AS l_comment
+FROM lineitem_struct
+
+statement ok
+CREATE TABLE orders_struct AS SELECT {
+'o_orderkey': o_orderkey,
+'o_custkey': o_custkey,
+'o_orderstatus': o_orderstatus,
+'o_totalprice': o_totalprice,
+'o_orderdate': o_orderdate,
+'o_orderpriority': o_orderpriority,
+'o_clerk': o_clerk,
+'o_shippriority': o_shippriority,
+'o_comment': o_comment
+} c FROM orders_normal;
+
+statement ok
+CREATE VIEW orders AS SELECT
+c['o_orderkey'] AS o_orderkey,
+c['o_custkey'] AS o_custkey,
+c['o_orderstatus'] AS o_orderstatus,
+c['o_totalprice'] AS o_totalprice,
+c['o_orderdate'] AS o_orderdate,
+c['o_orderpriority'] AS o_orderpriority,
+c['o_clerk'] AS o_clerk,
+c['o_shippriority'] AS o_shippriority,
+c['o_comment'] AS o_comment
+FROM orders_struct
+
+statement ok
+CREATE TABLE part_struct AS SELECT {
+'p_partkey': p_partkey,
+'p_name': p_name,
+'p_mfgr': p_mfgr,
+'p_brand': p_brand,
+'p_type': p_type,
+'p_size': p_size,
+'p_container': p_container,
+'p_retailprice': p_retailprice,
+'p_comment': p_comment
+} c FROM part_normal;
+
+statement ok
+CREATE VIEW part AS SELECT
+c['p_partkey'] AS p_partkey,
+c['p_name'] AS p_name,
+c['p_mfgr'] AS p_mfgr,
+c['p_brand'] AS p_brand,
+c['p_type'] AS p_type,
+c['p_size'] AS p_size,
+c['p_container'] AS p_container,
+c['p_retailprice'] AS p_retailprice,
+c['p_comment'] AS p_comment
+FROM part_struct
+
+statement ok
+CREATE TABLE partsupp_struct AS SELECT {
+'ps_partkey': ps_partkey,
+'ps_suppkey': ps_suppkey,
+'ps_availqty': ps_availqty,
+'ps_supplycost': ps_supplycost,
+'ps_comment': ps_comment
+} c FROM partsupp_normal;
+
+statement ok
+CREATE VIEW partsupp AS SELECT
+c['ps_partkey'] AS ps_partkey,
+c['ps_suppkey'] AS ps_suppkey,
+c['ps_availqty'] AS ps_availqty,
+c['ps_supplycost'] AS ps_supplycost,
+c['ps_comment'] AS ps_comment
+FROM partsupp_struct
+
+statement ok
+CREATE TABLE customer_struct AS SELECT {
+'c_custkey': c_custkey,
+'c_name': c_name,
+'c_address': c_address,
+'c_nationkey': c_nationkey,
+'c_phone': c_phone,
+'c_acctbal': c_acctbal,
+'c_mktsegment': c_mktsegment,
+'c_comment': c_comment
+} c FROM customer_normal;
+
+statement ok
+CREATE VIEW customer AS SELECT
+c['c_custkey'] AS c_custkey,
+c['c_name'] AS c_name,
+c['c_address'] AS c_address,
+c['c_nationkey'] AS c_nationkey,
+c['c_phone'] AS c_phone,
+c['c_acctbal'] AS c_acctbal,
+c['c_mktsegment'] AS c_mktsegment,
+c['c_comment'] AS c_comment
+FROM customer_struct
+
+statement ok
+CREATE TABLE region_struct AS SELECT {
+'r_regionkey': r_regionkey,
+'r_name': r_name,
+'r_comment': r_comment
+} c FROM region_normal;
+
+statement ok
+CREATE VIEW region AS SELECT
+c['r_regionkey'] AS r_regionkey,
+c['r_name'] AS r_name,
+c['r_comment'] AS r_comment
+FROM region_struct
+
+statement ok
+CREATE TABLE supplier_struct AS SELECT {
+'s_suppkey': s_suppkey,
+'s_name': s_name,
+'s_address': s_address,
+'s_nationkey': s_nationkey,
+'s_phone': s_phone,
+'s_acctbal': s_acctbal,
+'s_comment': s_comment
+} c FROM supplier_normal;
+
+statement ok
+CREATE VIEW supplier AS SELECT
+c['s_suppkey'] AS s_suppkey,
+c['s_name'] AS s_name,
+c['s_address'] AS s_address,
+c['s_nationkey'] AS s_nationkey,
+c['s_phone'] AS s_phone,
+c['s_acctbal'] AS s_acctbal,
+c['s_comment'] AS s_comment
+FROM supplier_struct
+
+statement ok
+CREATE TABLE nation_struct AS SELECT {
+'n_nationkey': n_nationkey,
+'n_name': n_name,
+'n_regionkey': n_regionkey,
+'n_comment': n_comment
+} c FROM nation_normal;
+
+statement ok
+CREATE VIEW nation AS SELECT
+c['n_nationkey'] AS n_nationkey,
+c['n_name'] AS n_name,
+c['n_regionkey'] AS n_regionkey,
+c['n_comment'] AS n_comment
+FROM nation_struct
+
+loop i 1 9
+
+query I
+PRAGMA tpch(${i})
+----
+<FILE>:extension/tpch/dbgen/answers/sf1/q0${i}.csv
+
+endloop
+
+loop i 10 23
+
+query I
+PRAGMA tpch(${i})
+----
+<FILE>:extension/tpch/dbgen/answers/sf1/q${i}.csv
+
+endloop
diff --git a/test/sql/types/list/test_nested_list.test b/test/sql/types/list/test_nested_list.test
index 2c3a02c97173..f2c81b957dbf 100644
--- a/test/sql/types/list/test_nested_list.test
+++ b/test/sql/types/list/test_nested_list.test
@@ -9,6 +9,12 @@ PRAGMA enable_verification
 statement ok
 PRAGMA threads=1
 
+# scalar nested lists
+query I
+SELECT [{'i': 1,'j': [2, 3]}, NULL, {'i': 1, 'j': [2, 3]}];
+----
+[{'i': 1, 'j': [2, 3]}, NULL, {'i': 1, 'j': [2, 3]}]
+
 statement ok
 CREATE TABLE list_data (g INTEGER, e INTEGER)
 
diff --git a/test/sql/types/struct/nested_structs.test b/test/sql/types/struct/nested_structs.test
new file mode 100644
index 000000000000..215ed9da3092
--- /dev/null
+++ b/test/sql/types/struct/nested_structs.test
@@ -0,0 +1,85 @@
+# name: test/sql/types/struct/nested_structs.test
+# description: Test storing nested structs in tables
+# group: [struct]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE a(c ROW(i ROW(a INTEGER), j INTEGER));
+
+statement ok
+INSERT INTO a VALUES ({
+	'i': {
+		'a': 3
+	},
+	'j': 4
+})
+
+query I
+SELECT * FROM a
+----
+{'i': {'a': 3}, 'j': 4}
+
+query I
+SELECT ((c).i).a FROM a
+----
+3
+
+statement ok
+INSERT INTO a VALUES (NULL)
+
+query I
+SELECT * FROM a
+----
+{'i': {'a': 3}, 'j': 4}
+NULL
+
+query I
+SELECT ((c).i).a FROM a
+----
+3
+NULL
+
+# nulls at different levels
+statement ok
+INSERT INTO a VALUES (ROW(ROW(NULL), 1))
+
+statement ok
+INSERT INTO a VALUES (ROW(ROW(1), NULL))
+
+statement ok
+INSERT INTO a VALUES (ROW(NULL, 1))
+
+query I
+SELECT * FROM a
+----
+{'i': {'a': 3}, 'j': 4}
+NULL
+{'i': {'a': NULL}, 'j': 1}
+{'i': {'a': 1}, 'j': NULL}
+{'i': NULL, 'j': 1}
+
+# create table as
+statement ok
+CREATE TABLE b AS SELECT {
+	'a': {
+		'a': 1,
+		'b': 'hello'
+	}
+} c;
+
+query I
+SELECT (c).a FROM b
+----
+{'a': 1, 'b': hello}
+
+# nested struct mismatch on insertion
+statement error
+INSERT INTO a VALUES (1)
+
+statement error
+INSERT INTO a VALUES (ROW(1, 2))
+
+statement error
+INSERT INTO a VALUES (ROW(ROW(1, 2, 3), 1))
diff --git a/test/sql/types/struct/struct_case.test b/test/sql/types/struct/struct_case.test
new file mode 100644
index 000000000000..46666823d069
--- /dev/null
+++ b/test/sql/types/struct/struct_case.test
@@ -0,0 +1,104 @@
+# name: test/sql/types/struct/struct_case.test
+# description: Test struct case statement
+# group: [struct]
+
+statement ok
+PRAGMA enable_verification
+
+# constant case
+query I
+SELECT CASE WHEN 1=1 THEN {'i': 1} ELSE {'i': 2} END
+----
+{'i': 1}
+
+query I
+SELECT CASE WHEN 1=0 THEN {'i': 1} ELSE {'i': 2} END
+----
+{'i': 2}
+
+# null values
+query I
+SELECT CASE WHEN 1=1 THEN NULL ELSE {'i': 2} END
+----
+NULL
+
+query I
+SELECT CASE WHEN 1=0 THEN NULL ELSE {'i': NULL} END
+----
+{'i': NULL}
+
+# now with a table
+query II
+SELECT i, CASE WHEN i%2=0 THEN {'i': 1} ELSE {'i': 2} END FROM range(6) tbl(i)
+----
+0	{'i': 1}
+1	{'i': 2}
+2	{'i': 1}
+3	{'i': 2}
+4	{'i': 1}
+5	{'i': 2}
+
+# strings
+query II
+SELECT i, CASE WHEN i%2=0 THEN {'i': 'hello'} ELSE {'i': 'world'} END FROM range(6) tbl(i)
+----
+0	{'i': hello}
+1	{'i': world}
+2	{'i': hello}
+3	{'i': world}
+4	{'i': hello}
+5	{'i': world}
+
+# nested structs
+query II
+SELECT i, CASE WHEN i%2=0 THEN {'i': 'hello', 'j': {'a': 3, 'b': NULL}} ELSE {'i': 'world', 'j': {'a': 7, 'b': 22}} END FROM range(6) tbl(i)
+----
+0	{'i': hello, 'j': {'a': 3, 'b': NULL}}
+1	{'i': world, 'j': {'a': 7, 'b': 22}}
+2	{'i': hello, 'j': {'a': 3, 'b': NULL}}
+3	{'i': world, 'j': {'a': 7, 'b': 22}}
+4	{'i': hello, 'j': {'a': 3, 'b': NULL}}
+5	{'i': world, 'j': {'a': 7, 'b': 22}}
+
+# lists in structs
+query II
+SELECT i, CASE WHEN i%2=0 THEN {'i': [1,2,3]} ELSE {'i': [7,8]} END FROM range(6) tbl(i)
+----
+0	{'i': [1, 2, 3]}
+1	{'i': [7, 8]}
+2	{'i': [1, 2, 3]}
+3	{'i': [7, 8]}
+4	{'i': [1, 2, 3]}
+5	{'i': [7, 8]}
+
+# null values
+query II
+SELECT i, CASE WHEN i%2=0 THEN {'i': [1,2,3]} ELSE NULL END FROM range(6) tbl(i)
+----
+0	{'i': [1, 2, 3]}
+1	NULL
+2	{'i': [1, 2, 3]}
+3	NULL
+4	{'i': [1, 2, 3]}
+5	NULL
+
+query II
+SELECT i, CASE WHEN i%2=0 THEN {'i': [1,2,3]} ELSE {'i': NULL} END FROM range(6) tbl(i)
+----
+0	{'i': [1, 2, 3]}
+1	{'i': NULL}
+2	{'i': [1, 2, 3]}
+3	{'i': NULL}
+4	{'i': [1, 2, 3]}
+5	{'i': NULL}
+
+# different types on child lists
+query II
+SELECT i, CASE WHEN i%2=0 THEN {'i': [1,2,3]} ELSE {'i': ['hello']} END FROM range(6) tbl(i)
+----
+0	{'i': [1, 2, 3]}
+1	{'i': [hello]}
+2	{'i': [1, 2, 3]}
+3	{'i': [hello]}
+4	{'i': [1, 2, 3]}
+5	{'i': [hello]}
diff --git a/test/sql/types/struct/struct_cast.test b/test/sql/types/struct/struct_cast.test
new file mode 100644
index 000000000000..061506d17f86
--- /dev/null
+++ b/test/sql/types/struct/struct_cast.test
@@ -0,0 +1,112 @@
+# name: test/sql/types/struct/struct_cast.test
+# description: Test struct cast
+# group: [struct]
+
+statement ok
+PRAGMA enable_verification
+
+# constant casts
+query I
+SELECT {'i': 1, 'j': 2}::ROW(i BIGINT, j VARCHAR);
+----
+{'i': 1, 'j': 2}
+
+query I
+SELECT {'i': NULL, 'j': 'hello'}::ROW(i BIGINT, j VARCHAR);
+----
+{'i': NULL, 'j': hello}
+
+query I
+SELECT {'i': NULL, 'j': NULL}::ROW(i BIGINT, j VARCHAR);
+----
+{'i': NULL, 'j': NULL}
+
+query I
+SELECT NULL::ROW(i BIGINT, j VARCHAR);
+----
+NULL
+
+# cast and extract
+query I
+SELECT ({'i': NULL, 'j': NULL}::ROW(i BIGINT, j VARCHAR))['i'];
+----
+NULL
+
+query I
+SELECT ({'i': NULL, 'j': NULL})['i']
+----
+NULL
+
+query I
+SELECT (NULL::ROW(i BIGINT, j VARCHAR))['i'];
+----
+NULL
+
+# nested struct casts
+query I
+SELECT {'i': 1, 'j': {'a': 2, 'b': 3}}::ROW(i BIGINT, j ROW(a BIGINT, b VARCHAR));
+----
+{'i': 1, 'j': {'a': 2, 'b': 3}}
+
+query I
+SELECT {'i': 1, 'j': {'a': NULL, 'b': 3}}::ROW(i BIGINT, j ROW(a BIGINT, b VARCHAR));
+----
+{'i': 1, 'j': {'a': NULL, 'b': 3}}
+
+query I
+SELECT {'i': 1, 'j': {'a': 2, 'b': NULL}}::ROW(i BIGINT, j ROW(a BIGINT, b VARCHAR));
+----
+{'i': 1, 'j': {'a': 2, 'b': NULL}}
+
+query I
+SELECT {'i': 1, 'j': NULL}::ROW(i BIGINT, j ROW(a BIGINT, b VARCHAR));
+----
+{'i': 1, 'j': NULL}
+
+# cast and extract
+query I
+SELECT ({'i': 1, 'j': NULL}::ROW(i BIGINT, j ROW(a BIGINT, b VARCHAR)))['j']['a'];
+----
+NULL
+
+query I
+SELECT NULL::ROW(i BIGINT, j ROW(a BIGINT, b VARCHAR));
+----
+NULL
+
+# now the same but non-constant
+statement ok
+CREATE TABLE structs(s ROW(i INTEGER, j INTEGER))
+
+statement ok
+INSERT INTO structs VALUES ({'i': 1, 'j': 2}), ({'i': NULL, 'j': 2}), ({'i': 1, 'j': NULL}), (NULL)
+
+query I
+SELECT s::ROW(i BIGINT, j VARCHAR) FROM structs
+----
+{'i': 1, 'j': 2}
+{'i': NULL, 'j': 2}
+{'i': 1, 'j': NULL}
+NULL
+
+# nested struct
+statement ok
+CREATE TABLE nested_structs(s ROW(i INTEGER, j ROW(a INTEGER, b INTEGER)))
+
+statement ok
+INSERT INTO nested_structs VALUES
+({'i': 1, 'j': {'a': 2, 'b': 3}}),
+({'i': 1, 'j': {'a': NULL, 'b': 3}}),
+({'i': 1, 'j': {'a': 2, 'b': NULL}}),
+({'i': 1, 'j': NULL}),
+(NULL)
+
+
+query I
+SELECT s::ROW(i BIGINT, j ROW(a BIGINT, b VARCHAR)) FROM nested_structs
+----
+{'i': 1, 'j': {'a': 2, 'b': 3}}
+{'i': 1, 'j': {'a': NULL, 'b': 3}}
+{'i': 1, 'j': {'a': 2, 'b': NULL}}
+{'i': 1, 'j': NULL}
+NULL
diff --git a/test/sql/types/struct/struct_dict.test b/test/sql/types/struct/struct_dict.test
index 7c71a4be8cb6..e65585819b51 100644
--- a/test/sql/types/struct/struct_dict.test
+++ b/test/sql/types/struct/struct_dict.test
@@ -2,6 +2,9 @@
 # description: Test dict syntax for structs
 # group: [struct]
 
+statement ok
+PRAGMA enable_verification
+
 query I
 SELECT {'i': 1, 'j': 2};
 ----
diff --git a/test/sql/types/struct/struct_index.test b/test/sql/types/struct/struct_index.test
new file mode 100644
index 000000000000..45e3c82bc626
--- /dev/null
+++ b/test/sql/types/struct/struct_index.test
@@ -0,0 +1,112 @@
+# name: test/sql/types/struct/struct_index.test
+# description: Test struct lookups using an index
+# group: [struct]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE a(id INTEGER PRIMARY KEY, c ROW(i ROW(a INTEGER), j INTEGER));
+
+statement ok
+INSERT INTO a VALUES (1, {
+	'i': {
+		'a': 3
+	},
+	'j': 4
+})
+
+# simple lookup
+query II
+SELECT * FROM a WHERE id=1
+----
+1	{'i': {'a': 3}, 'j': 4}
+
+# now with null values at different levels
+statement ok
+INSERT INTO a VALUES (2, NULL)
+
+statement ok
+INSERT INTO a VALUES (3, ROW(ROW(NULL), 1))
+
+statement ok
+INSERT INTO a VALUES (4, ROW(ROW(1), NULL))
+
+statement ok
+INSERT INTO a VALUES (5, ROW(NULL, 1))
+
+query II
+SELECT * FROM a WHERE id=2
+----
+2	NULL
+
+query II
+SELECT * FROM a WHERE id=3
+----
+3	{'i': {'a': NULL}, 'j': 1}
+
+query II
+SELECT * FROM a WHERE id=4
+----
+4	{'i': {'a': 1}, 'j': NULL}
+
+query II
+SELECT * FROM a WHERE id=5
+----
+5	{'i': NULL, 'j': 1}
+
+# test index construction on a table with structs
+statement ok
+DROP TABLE a;
+
+statement ok
+CREATE TABLE a(id INTEGER, c ROW(i ROW(a INTEGER), j INTEGER));
+
+statement ok
+INSERT INTO a VALUES (1, {
+	'i': {
+		'a': 3
+	},
+	'j': 4
+})
+
+statement ok
+INSERT INTO a VALUES (2, NULL)
+
+statement ok
+INSERT INTO a VALUES (3, ROW(ROW(NULL), 1))
+
+statement ok
+INSERT INTO a VALUES (4, ROW(ROW(1), NULL))
+
+statement ok
+INSERT INTO a VALUES (5, ROW(NULL, 1))
+
+statement ok
+CREATE INDEX a_index ON a(id);
+
+query II
+SELECT * FROM a WHERE id=1
+----
+1	{'i': {'a': 3}, 'j': 4}
+
+query II
+SELECT * FROM a WHERE id=2
+----
+2	NULL
+
+query II
+SELECT * FROM a WHERE id=3
+----
+3	{'i': {'a': NULL}, 'j': 1}
+
+query II
+SELECT * FROM a WHERE id=4
+----
+4	{'i': {'a': 1}, 'j': NULL}
+
+query II
+SELECT * FROM a WHERE id=5
+----
+5	{'i': NULL, 'j': 1}
+
diff --git a/test/sql/types/struct/struct_operations.test b/test/sql/types/struct/struct_operations.test
new file mode 100644
index 000000000000..df57ed589696
--- /dev/null
+++ b/test/sql/types/struct/struct_operations.test
@@ -0,0 +1,50 @@
+# name: test/sql/types/struct/struct_operations.test
+# description: Test various operations on structs
+# group: [struct]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE a(id INTEGER, b ROW(i INTEGER, j INTEGER));
+
+statement ok
+INSERT INTO a VALUES (1, {i: 1, j: 2});
+
+statement ok
+CREATE TABLE b(id INTEGER, j VARCHAR);
+
+statement ok
+INSERT INTO b VALUES (1, 'hello');
+
+# unequality join
+query IIII
+SELECT * FROM a LEFT JOIN b ON a.id<>b.id
+----
+1	{'i': 1, 'j': 2}	NULL	NULL
+
+query IIII
+SELECT * FROM a RIGHT JOIN b ON a.id<>b.id
+----
+NULL	NULL	1	hello
+
+# range join
+query IIII
+SELECT * FROM a LEFT JOIN b ON a.id>b.id
+----
+1	{'i': 1, 'j': 2}	NULL	NULL
+
+query IIII
+SELECT * FROM a RIGHT JOIN b ON a.id>b.id
+----
+NULL	NULL	1	hello
+
+# unsupported operations
+# TODO
+mode skip
+
+# subquery
+query I
+SELECT (SELECT b FROM a)
+----
+{'i': 1, 'j': 2}
\ No newline at end of file
diff --git a/test/sql/types/struct/struct_tables.test b/test/sql/types/struct/struct_tables.test
new file mode 100644
index 000000000000..a1abf898db39
--- /dev/null
+++ b/test/sql/types/struct/struct_tables.test
@@ -0,0 +1,68 @@
+# name: test/sql/types/struct/struct_tables.test
+# description: Test storing structs in in-memory tables
+# group: [struct]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE a(b ROW(i INTEGER, j INTEGER));
+
+# insert standard struct
+statement ok
+INSERT INTO a VALUES (STRUCT_PACK(i := 1, j:= 2));
+
+query I
+SELECT * FROM a ORDER BY (b).i;
+----
+{'i': 1, 'j': 2}
+
+statement ok
+INSERT INTO a VALUES (NULL);
+
+query I
+SELECT * FROM a ORDER BY (b).i;
+----
+NULL
+{'i': 1, 'j': 2}
+
+# unnamed struct
+statement ok
+INSERT INTO a VALUES (ROW(2, 3));
+
+query I
+SELECT * FROM a ORDER BY (b).i;
+----
+NULL
+{'i': 1, 'j': 2}
+{'i': 2, 'j': 3}
+
+# null values in children
+statement ok
+INSERT INTO a VALUES (ROW(3, NULL)), (ROW(NULL, 4));
+
+query I
+SELECT * FROM a ORDER BY (b).i, (b).j;
+----
+NULL
+{'i': NULL, 'j': 4}
+{'i': 1, 'j': 2}
+{'i': 2, 'j': 3}
+{'i': 3, 'j': NULL}
+
+# incorrect number of struct entries
+statement error
+INSERT INTO a VALUES (ROW(1, 2, 3))
+
+statement error
+INSERT INTO a VALUES (ROW(1))
+
+# incorrect types
+statement error
+INSERT INTO a VALUES (ROW('hello', 1))
+
+statement error
+INSERT INTO a VALUES (ROW('hello', [1, 2]))
+
+statement error
+INSERT INTO a VALUES (ROW(1, ROW(1, 7)))
diff --git a/test/sql/types/struct/struct_updates.test b/test/sql/types/struct/struct_updates.test
new file mode 100644
index 000000000000..86c28f834cf2
--- /dev/null
+++ b/test/sql/types/struct/struct_updates.test
@@ -0,0 +1,103 @@
+# name: test/sql/types/struct/struct_updates.test
+# description: Test updates on struct tables
+# group: [struct]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE a(b ROW(i INTEGER, j INTEGER));
+
+statement ok
+INSERT INTO a VALUES ({'i': 1, 'j': 2});
+
+query I
+SELECT * FROM a ORDER BY (b).i;
+----
+{'i': 1, 'j': 2}
+
+# standard update
+statement ok
+UPDATE a SET b={'i': 3, 'j': 4}
+
+query I
+SELECT * FROM a ORDER BY (b).i;
+----
+{'i': 3, 'j': 4}
+
+# NULL update
+statement ok
+UPDATE a SET b=NULL
+
+query I
+SELECT * FROM a ORDER BY (b).i;
+----
+NULL
+
+statement ok
+UPDATE a SET b={'i': NULL, 'j': 4}
+
+query I
+SELECT * FROM a ORDER BY (b).i;
+----
+{'i': NULL, 'j': 4}
+
+statement ok
+UPDATE a SET b={'i': 3, 'j': NULL}
+
+query I
+SELECT * FROM a ORDER BY (b).i;
+----
+{'i': 3, 'j': NULL}
+
+# rollbacks
+statement ok
+BEGIN TRANSACTION;
+
+statement ok
+UPDATE a SET b={'i': 3, 'j': 4}
+
+query I
+SELECT * FROM a ORDER BY (b).i;
+----
+{'i': 3, 'j': 4}
+
+statement ok
+ROLLBACK;
+
+query I
+SELECT * FROM a ORDER BY (b).i;
+----
+{'i': 3, 'j': NULL}
+
+# updates with a filter
+statement ok
+INSERT INTO a VALUES ({'i': 2, 'j': 3});
+
+query I
+SELECT * FROM a
+----
+{'i': 3, 'j': NULL}
+{'i': 2, 'j': 3}
+
+statement ok
+INSERT INTO a VALUES ({'i': 3, 'j': 4});
+
+query I
+SELECT * FROM a
+----
+{'i': 3, 'j': NULL}
+{'i': 2, 'j': 3}
+{'i': 3, 'j': 4}
+
+query I
+UPDATE a SET b={'i': NULL, 'j': NULL} WHERE (b).j>=3
+----
+2
+
+query I
+SELECT * FROM a
+----
+{'i': 3, 'j': NULL}
+{'i': NULL, 'j': NULL}
+{'i': NULL, 'j': NULL}
diff --git a/test/sql/types/struct/test_struct.test b/test/sql/types/struct/test_struct.test
index 8628227611fe..caed103e6685 100644
--- a/test/sql/types/struct/test_struct.test
+++ b/test/sql/types/struct/test_struct.test
@@ -173,7 +173,7 @@ SELECT STRUCT_EXTRACT(STRUCT_PACK(xx := e, yy := g), g) FROM struct_data
 statement error
 SELECT STRUCT_EXTRACT(STRUCT_PACK(xx := e, yy := g), '42') FROM struct_data
 
-statement error
+statement ok
 CREATE TABLE test AS SELECT e, STRUCT_PACK(e) FROM struct_data
 
 statement ok
