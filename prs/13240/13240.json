{
  "repo": "duckdb/duckdb",
  "pull_number": 13240,
  "instance_id": "duckdb__duckdb-13240",
  "issue_numbers": [
    "13227"
  ],
  "base_commit": "4e390e0512252949081d2c6d6a51f498561fe1ef",
  "patch": "diff --git a/src/common/types/vector_buffer.cpp b/src/common/types/vector_buffer.cpp\nindex 59bc6f9cadf2..aed61d192f52 100644\n--- a/src/common/types/vector_buffer.cpp\n+++ b/src/common/types/vector_buffer.cpp\n@@ -67,11 +67,12 @@ VectorListBuffer::VectorListBuffer(const LogicalType &list_type, idx_t initial_c\n \n void VectorListBuffer::Reserve(idx_t to_reserve) {\n \tif (to_reserve > capacity) {\n-\t\tidx_t new_capacity = NextPowerOfTwo(to_reserve);\n-\t\tif (new_capacity == 0) {\n-\t\t\t// Overflow: set to_reserve to the maximum value\n-\t\t\tnew_capacity = to_reserve;\n+\t\tif (to_reserve > DConstants::MAX_VECTOR_SIZE) {\n+\t\t\t// overflow: throw an exception\n+\t\t\tthrow OutOfRangeException(\"Cannot resize vector to %d rows: maximum allowed vector size is %s\", to_reserve,\n+\t\t\t                          StringUtil::BytesToHumanReadableString(DConstants::MAX_VECTOR_SIZE));\n \t\t}\n+\t\tidx_t new_capacity = NextPowerOfTwo(to_reserve);\n \t\tD_ASSERT(new_capacity >= to_reserve);\n \t\tchild->Resize(capacity, new_capacity);\n \t\tcapacity = new_capacity;\ndiff --git a/src/core_functions/scalar/string/repeat.cpp b/src/core_functions/scalar/string/repeat.cpp\nindex c7ceef99257b..31318290fe3a 100644\n--- a/src/core_functions/scalar/string/repeat.cpp\n+++ b/src/core_functions/scalar/string/repeat.cpp\n@@ -65,7 +65,8 @@ static void RepeatListFunction(DataChunk &args, ExpressionState &, Vector &resul\n \t\t    result_list.length = result_length;\n \t\t    for (idx_t i = 0; i < copy_count; i++) {\n \t\t\t    // repeat the list contents \"cnt\" times\n-\t\t\t    VectorOperations::Copy(source_child, result_child, list_input.length, list_input.offset, current_size);\n+\t\t\t    VectorOperations::Copy(source_child, result_child, list_input.offset + list_input.length,\n+\t\t\t                           list_input.offset, current_size);\n \t\t\t    current_size += list_input.length;\n \t\t    }\n \t\t    return result_list;\ndiff --git a/src/function/scalar/generic/binning.cpp b/src/function/scalar/generic/binning.cpp\nindex 8882f0c3f070..6d84b5f6191f 100644\n--- a/src/function/scalar/generic/binning.cpp\n+++ b/src/function/scalar/generic/binning.cpp\n@@ -129,15 +129,15 @@ struct EquiWidthBinsInteger {\n \t\thugeint_t step = span / Hugeint::Convert(bin_count);\n \t\tif (nice_rounding) {\n \t\t\t// when doing nice rounding we try to make the max/step values nicer\n-\t\t\tstep = MakeNumberNice(step, step, NiceRounding::ROUND);\n-\t\t\tmax = RoundToNumber(max, step, NiceRounding::CEILING);\n+\t\t\thugeint_t new_step = MakeNumberNice(step, step, NiceRounding::ROUND);\n+\t\t\thugeint_t new_max = RoundToNumber(max, new_step, NiceRounding::CEILING);\n+\t\t\tif (new_max != min && new_step != 0) {\n+\t\t\t\tmax = new_max;\n+\t\t\t\tstep = new_step;\n+\t\t\t}\n \t\t\t// we allow for more bins when doing nice rounding since the bin count is approximate\n \t\t\tbin_count *= 2;\n \t\t}\n-\t\tif (step == 0) {\n-\t\t\tthrow InternalException(\"step is 0!?\");\n-\t\t}\n-\n \t\tfor (hugeint_t bin_boundary = max; bin_boundary > min; bin_boundary -= step) {\n \t\t\tconst hugeint_t target_boundary = bin_boundary / FACTOR;\n \t\t\tint64_t real_boundary = Hugeint::Cast<int64_t>(target_boundary);\ndiff --git a/src/planner/binder/expression/bind_star_expression.cpp b/src/planner/binder/expression/bind_star_expression.cpp\nindex ae9bd0d98052..e25c69c160ee 100644\n--- a/src/planner/binder/expression/bind_star_expression.cpp\n+++ b/src/planner/binder/expression/bind_star_expression.cpp\n@@ -203,6 +203,9 @@ void Binder::ExpandStarExpression(unique_ptr<ParsedExpression> expr,\n \t\t\t// scan the list for all selected columns and construct a lookup table\n \t\t\tcase_insensitive_map_t<bool> selected_set;\n \t\t\tfor (auto &child : children) {\n+\t\t\t\tif (child.IsNull()) {\n+\t\t\t\t\tthrow BinderException(*star, \"Columns expression does not support NULL input parameters\");\n+\t\t\t\t}\n \t\t\t\tselected_set.insert(make_pair(StringValue::Get(child), false));\n \t\t\t}\n \t\t\t// now check the list of all possible expressions and select which ones make it in\n",
  "test_patch": "diff --git a/test/sql/aggregate/aggregates/binning.test b/test/sql/aggregate/aggregates/binning.test\nindex 2c9ade0e7420..c58d13c3e5aa 100644\n--- a/test/sql/aggregate/aggregates/binning.test\n+++ b/test/sql/aggregate/aggregates/binning.test\n@@ -306,6 +306,16 @@ select equi_width_bins(timestamp '2024-06-21 15:00:00.123456', timestamp '2024-0\n ----\n [2024-06-21 15:00:00.123456, 2024-06-21 15:00:00.123457, 2024-06-21 15:00:00.123458]\n \n+query I\n+SELECT EQUI_WIDTH_BINS(0, 10, 5999, TRUE)\n+----\n+[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n+\n+query I\n+SELECT EQUI_WIDTH_BINS(0, 10, 5999, false)\n+----\n+[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n+\n statement error\n SELECT equi_width_bins(-0.0, -1.0, 5, true);\n ----\ndiff --git a/test/sql/function/list/list_resize.test b/test/sql/function/list/list_resize.test\nindex a56cd1c46c27..7ae92a1ea9cb 100644\n--- a/test/sql/function/list/list_resize.test\n+++ b/test/sql/function/list/list_resize.test\n@@ -302,6 +302,11 @@ SELECT LIST_RESIZE([1, 2, 3], 9999999999999999999);\n ----\n maximum allowed vector size\n \n+statement error\n+SELECT LIST_RESIZE([1, 2, 3], 4000999999999999999)\n+----\n+maximum allowed vector size\n+\n endloop\n \n query I\ndiff --git a/test/sql/function/list/repeat_list.test b/test/sql/function/list/repeat_list.test\nindex 5340ddaf4696..80583b809787 100644\n--- a/test/sql/function/list/repeat_list.test\n+++ b/test/sql/function/list/repeat_list.test\n@@ -54,6 +54,22 @@ SELECT repeat(repeat([1], 50), 50) = repeat([1], 2500);\n ----\n true\n \n+# fuzzer issue with repeat of different vector types\n+query I\n+SELECT REPEAT(c,2) FROM TEST_VECTOR_TYPES(CAST(NULL AS INT[])) AS t(c)\n+----\n+[-2147483648, 2147483647, -2147483648, 2147483647]\n+[]\n+[NULL, NULL]\n+[-2147483648, 2147483647, -2147483648, 2147483647]\n+[-2147483648, 2147483647, -2147483648, 2147483647]\n+[-2147483648, 2147483647, -2147483648, 2147483647]\n+[]\n+[NULL, NULL]\n+[3, 5, 3, 5]\n+[]\n+[7, 7]\n+\n statement error\n SELECT repeat([1], 99999999999999999);\n ----\ndiff --git a/test/sql/parser/test_columns.test b/test/sql/parser/test_columns.test\nindex 2e967ed035a2..88dc0800d5f9 100644\n--- a/test/sql/parser/test_columns.test\n+++ b/test/sql/parser/test_columns.test\n@@ -84,6 +84,11 @@ statement error\n SELECT (SELECT COLUMNS(*)) FROM integers\n ----\n \n+statement error\n+SELECT columns([a, null]) FROM values (42) t(a);\n+----\n+does not support NULL input parameters\n+\n # COLUMNS in order by clause\n query III\n SELECT * FROM grouped_table ORDER BY COLUMNS('index[0-9]');\n",
  "problem_statement": "Fuzzer: DuckDB Internal Error with crafted COLUMNS expression: `Calling StringValue::Get on a NULL value`\n### What happens?\n\nDuckDB throws an internal error with crafted COLUMNS expression: `Calling StringValue::Get on a NULL value`.\n\n### To Reproduce\n\n```sql\r\nWITH integers AS (SELECT NULL AS i, NULL AS j) SELECT COLUMNS([j,null]) FROM integers\r\n```\r\n\r\nOutput:\r\n```\r\nINTERNAL Error: Calling StringValue::Get on a NULL value\r\n```\n\n### OS:\n\nUbuntu 20.04\n\n### DuckDB Version:\n\nv1.0.0 and v1.0.1-dev3550\n\n### DuckDB Client:\n\ncli\n\n### Full Name:\n\nJingzhou Fu\n\n### Affiliation:\n\nWingtecher Lab of Tsinghua University and ShuiMuYuLin Ltd.\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a source build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-07-31T15:42:07Z"
}