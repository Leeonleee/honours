You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Fuzzer: DuckDB Internal Error with crafted COLUMNS expression: `Calling StringValue::Get on a NULL value`
### What happens?

DuckDB throws an internal error with crafted COLUMNS expression: `Calling StringValue::Get on a NULL value`.

### To Reproduce

```sql
WITH integers AS (SELECT NULL AS i, NULL AS j) SELECT COLUMNS([j,null]) FROM integers
```

Output:
```
INTERNAL Error: Calling StringValue::Get on a NULL value
```

### OS:

Ubuntu 20.04

### DuckDB Version:

v1.0.0 and v1.0.1-dev3550

### DuckDB Client:

cli

### Full Name:

Jingzhou Fu

### Affiliation:

Wingtecher Lab of Tsinghua University and ShuiMuYuLin Ltd.

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a source build

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/common/types/vector_buffer.cpp]
1: #include "duckdb/common/types/vector_buffer.hpp"
2: 
3: #include "duckdb/common/assert.hpp"
4: #include "duckdb/common/types/vector.hpp"
5: #include "duckdb/common/vector_operations/vector_operations.hpp"
6: #include "duckdb/storage/buffer/buffer_handle.hpp"
7: 
8: namespace duckdb {
9: 
10: buffer_ptr<VectorBuffer> VectorBuffer::CreateStandardVector(PhysicalType type, idx_t capacity) {
11: 	return make_buffer<VectorBuffer>(capacity * GetTypeIdSize(type));
12: }
13: 
14: buffer_ptr<VectorBuffer> VectorBuffer::CreateConstantVector(PhysicalType type) {
15: 	return make_buffer<VectorBuffer>(GetTypeIdSize(type));
16: }
17: 
18: buffer_ptr<VectorBuffer> VectorBuffer::CreateConstantVector(const LogicalType &type) {
19: 	return VectorBuffer::CreateConstantVector(type.InternalType());
20: }
21: 
22: buffer_ptr<VectorBuffer> VectorBuffer::CreateStandardVector(const LogicalType &type, idx_t capacity) {
23: 	return VectorBuffer::CreateStandardVector(type.InternalType(), capacity);
24: }
25: 
26: VectorStringBuffer::VectorStringBuffer() : VectorBuffer(VectorBufferType::STRING_BUFFER) {
27: }
28: 
29: VectorStringBuffer::VectorStringBuffer(VectorBufferType type) : VectorBuffer(type) {
30: }
31: 
32: VectorFSSTStringBuffer::VectorFSSTStringBuffer() : VectorStringBuffer(VectorBufferType::FSST_BUFFER) {
33: }
34: 
35: VectorStructBuffer::VectorStructBuffer() : VectorBuffer(VectorBufferType::STRUCT_BUFFER) {
36: }
37: 
38: VectorStructBuffer::VectorStructBuffer(const LogicalType &type, idx_t capacity)
39:     : VectorBuffer(VectorBufferType::STRUCT_BUFFER) {
40: 	auto &child_types = StructType::GetChildTypes(type);
41: 	for (auto &child_type : child_types) {
42: 		auto vector = make_uniq<Vector>(child_type.second, capacity);
43: 		children.push_back(std::move(vector));
44: 	}
45: }
46: 
47: VectorStructBuffer::VectorStructBuffer(Vector &other, const SelectionVector &sel, idx_t count)
48:     : VectorBuffer(VectorBufferType::STRUCT_BUFFER) {
49: 	auto &other_vector = StructVector::GetEntries(other);
50: 	for (auto &child_vector : other_vector) {
51: 		auto vector = make_uniq<Vector>(*child_vector, sel, count);
52: 		children.push_back(std::move(vector));
53: 	}
54: }
55: 
56: VectorStructBuffer::~VectorStructBuffer() {
57: }
58: 
59: VectorListBuffer::VectorListBuffer(unique_ptr<Vector> vector, idx_t initial_capacity)
60:     : VectorBuffer(VectorBufferType::LIST_BUFFER), child(std::move(vector)), capacity(initial_capacity) {
61: }
62: 
63: VectorListBuffer::VectorListBuffer(const LogicalType &list_type, idx_t initial_capacity)
64:     : VectorBuffer(VectorBufferType::LIST_BUFFER),
65:       child(make_uniq<Vector>(ListType::GetChildType(list_type), initial_capacity)), capacity(initial_capacity) {
66: }
67: 
68: void VectorListBuffer::Reserve(idx_t to_reserve) {
69: 	if (to_reserve > capacity) {
70: 		idx_t new_capacity = NextPowerOfTwo(to_reserve);
71: 		if (new_capacity == 0) {
72: 			// Overflow: set to_reserve to the maximum value
73: 			new_capacity = to_reserve;
74: 		}
75: 		D_ASSERT(new_capacity >= to_reserve);
76: 		child->Resize(capacity, new_capacity);
77: 		capacity = new_capacity;
78: 	}
79: }
80: 
81: void VectorListBuffer::Append(const Vector &to_append, idx_t to_append_size, idx_t source_offset) {
82: 	Reserve(size + to_append_size - source_offset);
83: 	VectorOperations::Copy(to_append, *child, to_append_size, source_offset, size);
84: 	size += to_append_size - source_offset;
85: }
86: 
87: void VectorListBuffer::Append(const Vector &to_append, const SelectionVector &sel, idx_t to_append_size,
88:                               idx_t source_offset) {
89: 	Reserve(size + to_append_size - source_offset);
90: 	VectorOperations::Copy(to_append, *child, sel, to_append_size, source_offset, size);
91: 	size += to_append_size - source_offset;
92: }
93: 
94: void VectorListBuffer::PushBack(const Value &insert) {
95: 	while (size + 1 > capacity) {
96: 		child->Resize(capacity, capacity * 2);
97: 		capacity *= 2;
98: 	}
99: 	child->SetValue(size++, insert);
100: }
101: 
102: void VectorListBuffer::SetCapacity(idx_t new_capacity) {
103: 	this->capacity = new_capacity;
104: }
105: 
106: void VectorListBuffer::SetSize(idx_t new_size) {
107: 	this->size = new_size;
108: }
109: 
110: VectorListBuffer::~VectorListBuffer() {
111: }
112: 
113: VectorArrayBuffer::VectorArrayBuffer(unique_ptr<Vector> child_vector, idx_t array_size, idx_t initial_capacity)
114:     : VectorBuffer(VectorBufferType::ARRAY_BUFFER), child(std::move(child_vector)), array_size(array_size),
115:       size(initial_capacity) {
116: 	D_ASSERT(array_size != 0);
117: }
118: 
119: VectorArrayBuffer::VectorArrayBuffer(const LogicalType &array, idx_t initial)
120:     : VectorBuffer(VectorBufferType::ARRAY_BUFFER),
121:       child(make_uniq<Vector>(ArrayType::GetChildType(array), initial * ArrayType::GetSize(array))),
122:       array_size(ArrayType::GetSize(array)), size(initial) {
123: 	// initialize the child array with (array_size * size) ^
124: 	D_ASSERT(!ArrayType::IsAnySize(array));
125: }
126: 
127: VectorArrayBuffer::~VectorArrayBuffer() {
128: }
129: 
130: Vector &VectorArrayBuffer::GetChild() {
131: 	return *child;
132: }
133: 
134: idx_t VectorArrayBuffer::GetArraySize() {
135: 	return array_size;
136: }
137: 
138: idx_t VectorArrayBuffer::GetChildSize() {
139: 	return size * array_size;
140: }
141: 
142: ManagedVectorBuffer::ManagedVectorBuffer(BufferHandle handle)
143:     : VectorBuffer(VectorBufferType::MANAGED_BUFFER), handle(std::move(handle)) {
144: }
145: 
146: ManagedVectorBuffer::~ManagedVectorBuffer() {
147: }
148: 
149: } // namespace duckdb
[end of src/common/types/vector_buffer.cpp]
[start of src/core_functions/scalar/string/repeat.cpp]
1: #include "duckdb/common/vector_operations/binary_executor.hpp"
2: #include "duckdb/core_functions/scalar/string_functions.hpp"
3: #include "duckdb/common/operator/multiply.hpp"
4: 
5: namespace duckdb {
6: 
7: static void RepeatFunction(DataChunk &args, ExpressionState &, Vector &result) {
8: 	auto &str_vector = args.data[0];
9: 	auto &cnt_vector = args.data[1];
10: 
11: 	BinaryExecutor::Execute<string_t, int64_t, string_t>(
12: 	    str_vector, cnt_vector, result, args.size(), [&](string_t str, int64_t cnt) {
13: 		    auto input_str = str.GetData();
14: 		    auto size_str = str.GetSize();
15: 		    idx_t copy_count = cnt <= 0 || size_str == 0 ? 0 : UnsafeNumericCast<idx_t>(cnt);
16: 
17: 		    idx_t copy_size;
18: 		    if (TryMultiplyOperator::Operation(size_str, copy_count, copy_size)) {
19: 			    auto result_str = StringVector::EmptyString(result, copy_size);
20: 			    auto result_data = result_str.GetDataWriteable();
21: 			    for (idx_t i = 0; i < copy_count; i++) {
22: 				    memcpy(result_data + i * size_str, input_str, size_str);
23: 			    }
24: 			    result_str.Finalize();
25: 			    return result_str;
26: 		    } else {
27: 			    throw OutOfRangeException(
28: 			        "Cannot create a string of size: '%d' * '%d', the maximum supported string size is: '%d'", size_str,
29: 			        copy_count, string_t::MAX_STRING_SIZE);
30: 		    }
31: 	    });
32: }
33: 
34: unique_ptr<FunctionData> RepeatBindFunction(ClientContext &, ScalarFunction &bound_function,
35:                                             vector<unique_ptr<Expression>> &arguments) {
36: 	switch (arguments[0]->return_type.id()) {
37: 	case LogicalTypeId::UNKNOWN:
38: 		throw ParameterNotResolvedException();
39: 	case LogicalTypeId::LIST:
40: 		break;
41: 	default:
42: 		throw NotImplementedException("repeat(list, count) requires a list as parameter");
43: 	}
44: 	bound_function.arguments[0] = arguments[0]->return_type;
45: 	bound_function.return_type = arguments[0]->return_type;
46: 	return nullptr;
47: }
48: 
49: static void RepeatListFunction(DataChunk &args, ExpressionState &, Vector &result) {
50: 	auto &list_vector = args.data[0];
51: 	auto &cnt_vector = args.data[1];
52: 
53: 	auto &source_child = ListVector::GetEntry(list_vector);
54: 	auto &result_child = ListVector::GetEntry(result);
55: 
56: 	idx_t current_size = ListVector::GetListSize(result);
57: 	BinaryExecutor::Execute<list_entry_t, int64_t, list_entry_t>(
58: 	    list_vector, cnt_vector, result, args.size(), [&](list_entry_t list_input, int64_t cnt) {
59: 		    idx_t copy_count = cnt <= 0 || list_input.length == 0 ? 0 : UnsafeNumericCast<idx_t>(cnt);
60: 		    idx_t result_length = list_input.length * copy_count;
61: 		    idx_t new_size = current_size + result_length;
62: 		    ListVector::Reserve(result, new_size);
63: 		    list_entry_t result_list;
64: 		    result_list.offset = current_size;
65: 		    result_list.length = result_length;
66: 		    for (idx_t i = 0; i < copy_count; i++) {
67: 			    // repeat the list contents "cnt" times
68: 			    VectorOperations::Copy(source_child, result_child, list_input.length, list_input.offset, current_size);
69: 			    current_size += list_input.length;
70: 		    }
71: 		    return result_list;
72: 	    });
73: 	ListVector::SetListSize(result, current_size);
74: }
75: 
76: ScalarFunctionSet RepeatFun::GetFunctions() {
77: 	ScalarFunctionSet repeat;
78: 	for (const auto &type : {LogicalType::VARCHAR, LogicalType::BLOB}) {
79: 		repeat.AddFunction(ScalarFunction({type, LogicalType::BIGINT}, type, RepeatFunction));
80: 	}
81: 	repeat.AddFunction(ScalarFunction({LogicalType::LIST(LogicalType::ANY), LogicalType::BIGINT},
82: 	                                  LogicalType::LIST(LogicalType::ANY), RepeatListFunction, RepeatBindFunction));
83: 	return repeat;
84: }
85: 
86: } // namespace duckdb
[end of src/core_functions/scalar/string/repeat.cpp]
[start of src/function/scalar/generic/binning.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/common/hugeint.hpp"
3: #include "duckdb/common/types/date.hpp"
4: #include "duckdb/common/types/time.hpp"
5: #include "duckdb/common/types/timestamp.hpp"
6: #include "duckdb/common/vector_operations/generic_executor.hpp"
7: #include "duckdb/core_functions/scalar/generic_functions.hpp"
8: #include "duckdb/common/operator/subtract.hpp"
9: 
10: namespace duckdb {
11: 
12: static hugeint_t GetPreviousPowerOfTen(hugeint_t input) {
13: 	hugeint_t power_of_ten = 1;
14: 	while (power_of_ten < input) {
15: 		power_of_ten *= 10;
16: 	}
17: 	return power_of_ten / 10;
18: }
19: 
20: enum class NiceRounding { CEILING, ROUND };
21: 
22: hugeint_t RoundToNumber(hugeint_t input, hugeint_t num, NiceRounding rounding) {
23: 	if (rounding == NiceRounding::ROUND) {
24: 		return (input + (num / 2)) / num * num;
25: 	} else {
26: 		return (input + (num - 1)) / num * num;
27: 	}
28: }
29: 
30: hugeint_t MakeNumberNice(hugeint_t input, hugeint_t step, NiceRounding rounding) {
31: 	// we consider numbers nice if they are divisible by 2 or 5 times the power-of-ten one lower than the current
32: 	// e.g. 120 is a nice number because it is divisible by 20
33: 	//      122 is not a nice number -> we make it nice by turning it into 120 [/20]
34: 	//      153 is not a nice number -> we make it nice by turning it into 150 [/50]
35: 	//      1220 is not a nice number -> we turn it into 1200                  [/200]
36: 	// first figure out the previous power of 10 (i.e. for 67 we return 10)
37: 	// now the power of ten is the power BELOW the current number
38: 	// i.e. for 67, it is not 10
39: 	// now we can get the 2 or 5 divisors
40: 	hugeint_t power_of_ten = GetPreviousPowerOfTen(step);
41: 	hugeint_t two = power_of_ten * 2;
42: 	hugeint_t five = power_of_ten;
43: 	if (power_of_ten * 3 <= step) {
44: 		two *= 5;
45: 	}
46: 	if (power_of_ten * 2 <= step) {
47: 		five *= 5;
48: 	}
49: 
50: 	// compute the closest round number by adding the divisor / 2 and truncating
51: 	// do this for both divisors
52: 	hugeint_t round_to_two = RoundToNumber(input, two, rounding);
53: 	hugeint_t round_to_five = RoundToNumber(input, five, rounding);
54: 	// now pick the closest number of the two (i.e. for 147 we pick 150, not 140)
55: 	if (AbsValue(input - round_to_two) < AbsValue(input - round_to_five)) {
56: 		return round_to_two;
57: 	} else {
58: 		return round_to_five;
59: 	}
60: }
61: 
62: static double GetPreviousPowerOfTen(double input) {
63: 	double power_of_ten = 1;
64: 	if (input < 1) {
65: 		while (power_of_ten > input) {
66: 			power_of_ten /= 10;
67: 		}
68: 		return power_of_ten;
69: 	}
70: 	while (power_of_ten < input) {
71: 		power_of_ten *= 10;
72: 	}
73: 	return power_of_ten / 10;
74: }
75: 
76: double RoundToNumber(double input, double num, NiceRounding rounding) {
77: 	double result;
78: 	if (rounding == NiceRounding::ROUND) {
79: 		result = std::round(input / num) * num;
80: 	} else {
81: 		result = std::ceil(input / num) * num;
82: 	}
83: 	if (!Value::IsFinite(result)) {
84: 		return input;
85: 	}
86: 	return result;
87: }
88: 
89: double MakeNumberNice(double input, const double step, NiceRounding rounding) {
90: 	if (input == 0) {
91: 		return 0;
92: 	}
93: 	// now the power of ten is the power BELOW the current number
94: 	// i.e. for 67, it is not 10
95: 	// now we can get the 2 or 5 divisors
96: 	double power_of_ten = GetPreviousPowerOfTen(step);
97: 	double two = power_of_ten * 2;
98: 	double five = power_of_ten;
99: 	if (power_of_ten * 3 <= step) {
100: 		two *= 5;
101: 	}
102: 	if (power_of_ten * 2 <= step) {
103: 		five *= 5;
104: 	}
105: 
106: 	double round_to_two = RoundToNumber(input, two, rounding);
107: 	double round_to_five = RoundToNumber(input, five, rounding);
108: 	// now pick the closest number of the two (i.e. for 147 we pick 150, not 140)
109: 	if (AbsValue(input - round_to_two) < AbsValue(input - round_to_five)) {
110: 		return round_to_two;
111: 	} else {
112: 		return round_to_five;
113: 	}
114: }
115: 
116: struct EquiWidthBinsInteger {
117: 	static constexpr LogicalTypeId LOGICAL_TYPE = LogicalTypeId::BIGINT;
118: 
119: 	static vector<PrimitiveType<int64_t>> Operation(const Expression &expr, int64_t input_min, int64_t input_max,
120: 	                                                idx_t bin_count, bool nice_rounding) {
121: 		vector<PrimitiveType<int64_t>> result;
122: 		// to prevent integer truncation from affecting the bin boundaries we calculate them with numbers multiplied by
123: 		// 1000 we then divide to get the actual boundaries
124: 		const auto FACTOR = hugeint_t(1000);
125: 		auto min = hugeint_t(input_min) * FACTOR;
126: 		auto max = hugeint_t(input_max) * FACTOR;
127: 
128: 		const hugeint_t span = max - min;
129: 		hugeint_t step = span / Hugeint::Convert(bin_count);
130: 		if (nice_rounding) {
131: 			// when doing nice rounding we try to make the max/step values nicer
132: 			step = MakeNumberNice(step, step, NiceRounding::ROUND);
133: 			max = RoundToNumber(max, step, NiceRounding::CEILING);
134: 			// we allow for more bins when doing nice rounding since the bin count is approximate
135: 			bin_count *= 2;
136: 		}
137: 		if (step == 0) {
138: 			throw InternalException("step is 0!?");
139: 		}
140: 
141: 		for (hugeint_t bin_boundary = max; bin_boundary > min; bin_boundary -= step) {
142: 			const hugeint_t target_boundary = bin_boundary / FACTOR;
143: 			int64_t real_boundary = Hugeint::Cast<int64_t>(target_boundary);
144: 			if (!result.empty()) {
145: 				if (real_boundary < input_min || result.size() >= bin_count) {
146: 					// we can never generate input_min
147: 					break;
148: 				}
149: 				if (real_boundary == result.back().val) {
150: 					// we cannot generate the same value multiple times in a row - skip this step
151: 					continue;
152: 				}
153: 			}
154: 			result.push_back(real_boundary);
155: 		}
156: 		return result;
157: 	}
158: };
159: 
160: struct EquiWidthBinsDouble {
161: 	static constexpr LogicalTypeId LOGICAL_TYPE = LogicalTypeId::DOUBLE;
162: 
163: 	static vector<PrimitiveType<double>> Operation(const Expression &expr, double min, double input_max,
164: 	                                               idx_t bin_count, bool nice_rounding) {
165: 		double max = input_max;
166: 		if (!Value::IsFinite(min) || !Value::IsFinite(max)) {
167: 			throw InvalidInputException("equi_width_bucket does not support infinite or nan as min/max value");
168: 		}
169: 		vector<PrimitiveType<double>> result;
170: 		const double span = max - min;
171: 		double step;
172: 		if (!Value::IsFinite(span)) {
173: 			// max - min does not fit
174: 			step = max / static_cast<double>(bin_count) - min / static_cast<double>(bin_count);
175: 		} else {
176: 			step = span / static_cast<double>(bin_count);
177: 		}
178: 		const double step_power_of_ten = GetPreviousPowerOfTen(step);
179: 		if (nice_rounding) {
180: 			// when doing nice rounding we try to make the max/step values nicer
181: 			step = MakeNumberNice(step, step, NiceRounding::ROUND);
182: 			max = RoundToNumber(input_max, step, NiceRounding::CEILING);
183: 			// we allow for more bins when doing nice rounding since the bin count is approximate
184: 			bin_count *= 2;
185: 		}
186: 		if (step == 0) {
187: 			throw InternalException("step is 0!?");
188: 		}
189: 
190: 		const double round_multiplication = 10 / step_power_of_ten;
191: 		for (double bin_boundary = max; bin_boundary > min; bin_boundary -= step) {
192: 			// because floating point addition adds inaccuracies, we add rounding at every step
193: 			double real_boundary = bin_boundary;
194: 			if (nice_rounding) {
195: 				real_boundary = std::round(bin_boundary * round_multiplication) / round_multiplication;
196: 			}
197: 			if (!result.empty() && result.back().val == real_boundary) {
198: 				// skip this step
199: 				continue;
200: 			}
201: 			if (real_boundary <= min || result.size() >= bin_count) {
202: 				// we can never generate below input_min
203: 				break;
204: 			}
205: 			result.push_back(real_boundary);
206: 		}
207: 		return result;
208: 	}
209: };
210: 
211: void NextMonth(int32_t &year, int32_t &month) {
212: 	month++;
213: 	if (month == 13) {
214: 		year++;
215: 		month = 1;
216: 	}
217: }
218: 
219: void NextDay(int32_t &year, int32_t &month, int32_t &day) {
220: 	day++;
221: 	if (!Date::IsValid(year, month, day)) {
222: 		// day is out of range for month, move to next month
223: 		NextMonth(year, month);
224: 		day = 1;
225: 	}
226: }
227: 
228: void NextHour(int32_t &year, int32_t &month, int32_t &day, int32_t &hour) {
229: 	hour++;
230: 	if (hour >= 24) {
231: 		NextDay(year, month, day);
232: 		hour = 0;
233: 	}
234: }
235: 
236: void NextMinute(int32_t &year, int32_t &month, int32_t &day, int32_t &hour, int32_t &minute) {
237: 	minute++;
238: 	if (minute >= 60) {
239: 		NextHour(year, month, day, hour);
240: 		minute = 0;
241: 	}
242: }
243: 
244: void NextSecond(int32_t &year, int32_t &month, int32_t &day, int32_t &hour, int32_t &minute, int32_t &sec) {
245: 	sec++;
246: 	if (sec >= 60) {
247: 		NextMinute(year, month, day, hour, minute);
248: 		sec = 0;
249: 	}
250: }
251: 
252: timestamp_t MakeTimestampNice(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t sec,
253:                               int32_t micros, interval_t step) {
254: 	// how to make a timestamp nice depends on the step
255: 	if (step.months >= 12) {
256: 		// if the step involves one year or more, ceil to months
257: 		// set time component to 00:00:00.00
258: 		if (day > 1 || hour > 0 || minute > 0 || sec > 0 || micros > 0) {
259: 			// move to next month
260: 			NextMonth(year, month);
261: 			hour = minute = sec = micros = 0;
262: 			day = 1;
263: 		}
264: 	} else if (step.months > 0 || step.days >= 1) {
265: 		// if the step involves more than one day, ceil to days
266: 		if (hour > 0 || minute > 0 || sec > 0 || micros > 0) {
267: 			NextDay(year, month, day);
268: 			hour = minute = sec = micros = 0;
269: 		}
270: 	} else if (step.days > 0 || step.micros >= Interval::MICROS_PER_HOUR) {
271: 		// if the step involves more than one hour, ceil to hours
272: 		if (minute > 0 || sec > 0 || micros > 0) {
273: 			NextHour(year, month, day, hour);
274: 			minute = sec = micros = 0;
275: 		}
276: 	} else if (step.micros >= Interval::MICROS_PER_MINUTE) {
277: 		// if the step involves more than one minute, ceil to minutes
278: 		if (sec > 0 || micros > 0) {
279: 			NextMinute(year, month, day, hour, minute);
280: 			sec = micros = 0;
281: 		}
282: 	} else if (step.micros >= Interval::MICROS_PER_SEC) {
283: 		// if the step involves more than one second, ceil to seconds
284: 		if (micros > 0) {
285: 			NextSecond(year, month, day, hour, minute, sec);
286: 			micros = 0;
287: 		}
288: 	}
289: 	return Timestamp::FromDatetime(Date::FromDate(year, month, day), Time::FromTime(hour, minute, sec, micros));
290: }
291: 
292: int64_t RoundNumberToDivisor(int64_t number, int64_t divisor) {
293: 	return (number + (divisor / 2)) / divisor * divisor;
294: }
295: 
296: interval_t MakeIntervalNice(interval_t interval) {
297: 	if (interval.months >= 6) {
298: 		// if we have more than 6 months, we don't care about days
299: 		interval.days = 0;
300: 		interval.micros = 0;
301: 	} else if (interval.months > 0 || interval.days >= 5) {
302: 		// if we have any months or more than 5 days, we don't care about micros
303: 		interval.micros = 0;
304: 	} else if (interval.days > 0 || interval.micros >= 6 * Interval::MICROS_PER_HOUR) {
305: 		// if we any days or more than 6 hours, we want micros to be roundable by hours at least
306: 		interval.micros = RoundNumberToDivisor(interval.micros, Interval::MICROS_PER_HOUR);
307: 	} else if (interval.micros >= Interval::MICROS_PER_HOUR) {
308: 		// if we have more than an hour, we want micros to be divisible by quarter hours
309: 		interval.micros = RoundNumberToDivisor(interval.micros, Interval::MICROS_PER_MINUTE * 15);
310: 	} else if (interval.micros >= Interval::MICROS_PER_MINUTE * 10) {
311: 		// if we have more than 10 minutes, we want micros to be divisible by minutes
312: 		interval.micros = RoundNumberToDivisor(interval.micros, Interval::MICROS_PER_MINUTE);
313: 	} else if (interval.micros >= Interval::MICROS_PER_MINUTE) {
314: 		// if we have more than a minute, we want micros to be divisible by quarter minutes
315: 		interval.micros = RoundNumberToDivisor(interval.micros, Interval::MICROS_PER_SEC * 15);
316: 	} else if (interval.micros >= Interval::MICROS_PER_SEC * 10) {
317: 		// if we have more than 10 seconds, we want micros to be divisible by seconds
318: 		interval.micros = RoundNumberToDivisor(interval.micros, Interval::MICROS_PER_SEC);
319: 	}
320: 	return interval;
321: }
322: 
323: void GetTimestampComponents(timestamp_t input, int32_t &year, int32_t &month, int32_t &day, int32_t &hour,
324:                             int32_t &minute, int32_t &sec, int32_t &micros) {
325: 	date_t date;
326: 	dtime_t time;
327: 
328: 	Timestamp::Convert(input, date, time);
329: 	Date::Convert(date, year, month, day);
330: 	Time::Convert(time, hour, minute, sec, micros);
331: }
332: 
333: struct EquiWidthBinsTimestamp {
334: 	static constexpr LogicalTypeId LOGICAL_TYPE = LogicalTypeId::TIMESTAMP;
335: 
336: 	static vector<PrimitiveType<timestamp_t>> Operation(const Expression &expr, timestamp_t input_min,
337: 	                                                    timestamp_t input_max, idx_t bin_count, bool nice_rounding) {
338: 		if (!Value::IsFinite(input_min) || !Value::IsFinite(input_max)) {
339: 			throw InvalidInputException(expr, "equi_width_bucket does not support infinite or nan as min/max value");
340: 		}
341: 
342: 		if (!nice_rounding) {
343: 			// if we are not doing nice rounding it is pretty simple - just interpolate between the timestamp values
344: 			auto interpolated_values =
345: 			    EquiWidthBinsInteger::Operation(expr, input_min.value, input_max.value, bin_count, false);
346: 
347: 			vector<PrimitiveType<timestamp_t>> result;
348: 			for (auto &val : interpolated_values) {
349: 				result.push_back(timestamp_t(val.val));
350: 			}
351: 			return result;
352: 		}
353: 		// fetch the components of the timestamps
354: 		int32_t min_year, min_month, min_day, min_hour, min_minute, min_sec, min_micros;
355: 		int32_t max_year, max_month, max_day, max_hour, max_minute, max_sec, max_micros;
356: 		GetTimestampComponents(input_min, min_year, min_month, min_day, min_hour, min_minute, min_sec, min_micros);
357: 		GetTimestampComponents(input_max, max_year, max_month, max_day, max_hour, max_minute, max_sec, max_micros);
358: 
359: 		// get the interval differences per component
360: 		// note: these can be negative (except for the largest non-zero difference)
361: 		interval_t interval_diff;
362: 		interval_diff.months = (max_year - min_year) * Interval::MONTHS_PER_YEAR + (max_month - min_month);
363: 		interval_diff.days = max_day - min_day;
364: 		interval_diff.micros = (max_hour - min_hour) * Interval::MICROS_PER_HOUR +
365: 		                       (max_minute - min_minute) * Interval::MICROS_PER_MINUTE +
366: 		                       (max_sec - min_sec) * Interval::MICROS_PER_SEC + (max_micros - min_micros);
367: 
368: 		double step_months = static_cast<double>(interval_diff.months) / static_cast<double>(bin_count);
369: 		double step_days = static_cast<double>(interval_diff.days) / static_cast<int32_t>(bin_count);
370: 		double step_micros = static_cast<double>(interval_diff.micros) / static_cast<double>(bin_count);
371: 		// since we truncate the months/days, propagate any fractional component to the unit below (i.e. 0.2 months
372: 		// becomes 6 days)
373: 		if (step_months > 0) {
374: 			double overflow_months = step_months - std::floor(step_months);
375: 			step_days += overflow_months * Interval::DAYS_PER_MONTH;
376: 		}
377: 		if (step_days > 0) {
378: 			double overflow_days = step_days - std::floor(step_days);
379: 			step_micros += overflow_days * Interval::MICROS_PER_DAY;
380: 		}
381: 		interval_t step;
382: 		step.months = static_cast<int32_t>(step_months);
383: 		step.days = static_cast<int32_t>(step_days);
384: 		step.micros = static_cast<int64_t>(step_micros);
385: 
386: 		// now we make the max, and the step nice
387: 		step = MakeIntervalNice(step);
388: 		timestamp_t timestamp_val =
389: 		    MakeTimestampNice(max_year, max_month, max_day, max_hour, max_minute, max_sec, max_micros, step);
390: 		if (step.months <= 0 && step.days <= 0 && step.micros <= 0) {
391: 			// interval must be at least one microsecond
392: 			step.months = step.days = 0;
393: 			step.micros = 1;
394: 		}
395: 
396: 		vector<PrimitiveType<timestamp_t>> result;
397: 		while (timestamp_val.value >= input_min.value && result.size() < bin_count) {
398: 			result.push_back(timestamp_val);
399: 			timestamp_val = SubtractOperator::Operation<timestamp_t, interval_t, timestamp_t>(timestamp_val, step);
400: 		}
401: 		return result;
402: 	}
403: };
404: 
405: unique_ptr<FunctionData> BindEquiWidthFunction(ClientContext &, ScalarFunction &bound_function,
406:                                                vector<unique_ptr<Expression>> &arguments) {
407: 	// while internally the bins are computed over a unified type
408: 	// the equi_width_bins function returns the same type as the input MAX
409: 	LogicalType child_type;
410: 	switch (arguments[1]->return_type.id()) {
411: 	case LogicalTypeId::UNKNOWN:
412: 	case LogicalTypeId::SQLNULL:
413: 		return nullptr;
414: 	case LogicalTypeId::DECIMAL:
415: 		// for decimals we promote to double because
416: 		child_type = LogicalType::DOUBLE;
417: 		break;
418: 	default:
419: 		child_type = arguments[1]->return_type;
420: 		break;
421: 	}
422: 	bound_function.return_type = LogicalType::LIST(child_type);
423: 	return nullptr;
424: }
425: 
426: template <class T, class OP>
427: static void EquiWidthBinFunction(DataChunk &args, ExpressionState &state, Vector &result) {
428: 	static constexpr int64_t MAX_BIN_COUNT = 1000000;
429: 	auto &min_arg = args.data[0];
430: 	auto &max_arg = args.data[1];
431: 	auto &bin_count = args.data[2];
432: 	auto &nice_rounding = args.data[3];
433: 
434: 	Vector intermediate_result(LogicalType::LIST(OP::LOGICAL_TYPE));
435: 	GenericExecutor::ExecuteQuaternary<PrimitiveType<T>, PrimitiveType<T>, PrimitiveType<int64_t>, PrimitiveType<bool>,
436: 	                                   GenericListType<PrimitiveType<T>>>(
437: 	    min_arg, max_arg, bin_count, nice_rounding, intermediate_result, args.size(),
438: 	    [&](PrimitiveType<T> min_p, PrimitiveType<T> max_p, PrimitiveType<int64_t> bins_p,
439: 	        PrimitiveType<bool> nice_rounding_p) {
440: 		    if (max_p.val < min_p.val) {
441: 			    throw InvalidInputException(state.expr,
442: 			                                "Invalid input for bin function - max value is smaller than min value");
443: 		    }
444: 		    if (bins_p.val <= 0) {
445: 			    throw InvalidInputException(state.expr, "Invalid input for bin function - there must be > 0 bins");
446: 		    }
447: 		    if (bins_p.val > MAX_BIN_COUNT) {
448: 			    throw InvalidInputException(state.expr, "Invalid input for bin function - max bin count of %d exceeded",
449: 			                                MAX_BIN_COUNT);
450: 		    }
451: 		    GenericListType<PrimitiveType<T>> result_bins;
452: 		    if (max_p.val == min_p.val) {
453: 			    // if max = min return a single bucket
454: 			    result_bins.values.push_back(max_p.val);
455: 		    } else {
456: 			    result_bins.values = OP::Operation(state.expr, min_p.val, max_p.val, static_cast<idx_t>(bins_p.val),
457: 			                                       nice_rounding_p.val);
458: 			    // last bin should always be the input max
459: 			    if (result_bins.values[0].val < max_p.val) {
460: 				    result_bins.values[0].val = max_p.val;
461: 			    }
462: 			    std::reverse(result_bins.values.begin(), result_bins.values.end());
463: 		    }
464: 		    return result_bins;
465: 	    });
466: 	VectorOperations::DefaultCast(intermediate_result, result, args.size());
467: }
468: 
469: static void UnsupportedEquiWidth(DataChunk &args, ExpressionState &state, Vector &) {
470: 	throw BinderException(state.expr, "Unsupported type \"%s\" for equi_width_bins", args.data[0].GetType());
471: }
472: 
473: ScalarFunctionSet EquiWidthBinsFun::GetFunctions() {
474: 	ScalarFunctionSet functions("equi_width_bins");
475: 	functions.AddFunction(
476: 	    ScalarFunction({LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN},
477: 	                   LogicalType::LIST(LogicalType::BIGINT), EquiWidthBinFunction<int64_t, EquiWidthBinsInteger>,
478: 	                   BindEquiWidthFunction));
479: 	functions.AddFunction(
480: 	    ScalarFunction({LogicalType::DOUBLE, LogicalType::DOUBLE, LogicalType::BIGINT, LogicalType::BOOLEAN},
481: 	                   LogicalType::LIST(LogicalType::DOUBLE), EquiWidthBinFunction<double, EquiWidthBinsDouble>,
482: 	                   BindEquiWidthFunction));
483: 	functions.AddFunction(
484: 	    ScalarFunction({LogicalType::TIMESTAMP, LogicalType::TIMESTAMP, LogicalType::BIGINT, LogicalType::BOOLEAN},
485: 	                   LogicalType::LIST(LogicalType::DATE), EquiWidthBinFunction<timestamp_t, EquiWidthBinsTimestamp>,
486: 	                   BindEquiWidthFunction));
487: 	functions.AddFunction(
488: 	    ScalarFunction({LogicalType::ANY_PARAMS(LogicalType::ANY, 150), LogicalType::ANY_PARAMS(LogicalType::ANY, 150),
489: 	                    LogicalType::BIGINT, LogicalType::BOOLEAN},
490: 	                   LogicalType::LIST(LogicalType::ANY), UnsupportedEquiWidth, BindEquiWidthFunction));
491: 	return functions;
492: }
493: 
494: } // namespace duckdb
[end of src/function/scalar/generic/binning.cpp]
[start of src/planner/binder/expression/bind_star_expression.cpp]
1: #include "duckdb/planner/binder.hpp"
2: #include "duckdb/parser/expression/star_expression.hpp"
3: #include "duckdb/parser/expression/constant_expression.hpp"
4: #include "duckdb/parser/expression/columnref_expression.hpp"
5: #include "duckdb/parser/expression/operator_expression.hpp"
6: #include "duckdb/planner/expression_binder/table_function_binder.hpp"
7: #include "duckdb/parser/parsed_expression_iterator.hpp"
8: #include "duckdb/execution/expression_executor.hpp"
9: #include "duckdb/function/scalar/regexp.hpp"
10: #include "duckdb/parser/expression/function_expression.hpp"
11: 
12: namespace duckdb {
13: 
14: string GetColumnsStringValue(ParsedExpression &expr) {
15: 	if (expr.type == ExpressionType::COLUMN_REF) {
16: 		auto &colref = expr.Cast<ColumnRefExpression>();
17: 		return colref.GetColumnName();
18: 	} else {
19: 		return expr.ToString();
20: 	}
21: }
22: 
23: bool Binder::FindStarExpression(unique_ptr<ParsedExpression> &expr, StarExpression **star, bool is_root,
24:                                 bool in_columns) {
25: 	bool has_star = false;
26: 	if (expr->GetExpressionClass() == ExpressionClass::STAR) {
27: 		auto &current_star = expr->Cast<StarExpression>();
28: 		if (StarExpression::IsStar(*expr)) {
29: 			if (is_root) {
30: 				D_ASSERT(!in_columns);
31: 				// At the root level
32: 				*star = &current_star;
33: 				return true;
34: 			}
35: 
36: 			if (!in_columns) {
37: 				// '*' can only appear inside COLUMNS or at the root level
38: 				throw BinderException(
39: 				    "STAR expression is only allowed as the root element of an expression. Use COLUMNS(*) instead.");
40: 			}
41: 
42: 			if (!current_star.replace_list.empty()) {
43: 				// '*' inside COLUMNS can not have a REPLACE list
44: 				throw BinderException(
45: 				    "STAR expression with REPLACE list is only allowed as the root element of COLUMNS");
46: 			}
47: 
48: 			// '*' expression inside a COLUMNS - convert to a constant list of strings (column names)
49: 			vector<unique_ptr<ParsedExpression>> star_list;
50: 			bind_context.GenerateAllColumnExpressions(current_star, star_list);
51: 
52: 			vector<Value> values;
53: 			values.reserve(star_list.size());
54: 			for (auto &element : star_list) {
55: 				values.emplace_back(GetColumnsStringValue(*element));
56: 			}
57: 			D_ASSERT(!values.empty());
58: 			expr = make_uniq<ConstantExpression>(Value::LIST(LogicalType::VARCHAR, values));
59: 			return true;
60: 		}
61: 		if (in_columns) {
62: 			throw BinderException("COLUMNS expression is not allowed inside another COLUMNS expression");
63: 		}
64: 		in_columns = true;
65: 
66: 		if (*star) {
67: 			// we can have multiple
68: 			if (!(*star)->Equals(current_star)) {
69: 				throw BinderException(*expr,
70: 				                      "Multiple different STAR/COLUMNS in the same expression are not supported");
71: 			}
72: 			return true;
73: 		}
74: 		*star = &current_star;
75: 		has_star = true;
76: 	}
77: 	ParsedExpressionIterator::EnumerateChildren(*expr, [&](unique_ptr<ParsedExpression> &child_expr) {
78: 		if (FindStarExpression(child_expr, star, false, in_columns)) {
79: 			has_star = true;
80: 		}
81: 	});
82: 	return has_star;
83: }
84: 
85: void Binder::ReplaceStarExpression(unique_ptr<ParsedExpression> &expr, unique_ptr<ParsedExpression> &replacement) {
86: 	D_ASSERT(expr);
87: 	if (StarExpression::IsColumns(*expr) || StarExpression::IsStar(*expr)) {
88: 		D_ASSERT(replacement);
89: 		auto alias = expr->alias;
90: 		expr = replacement->Copy();
91: 		if (!alias.empty()) {
92: 			expr->alias = std::move(alias);
93: 		}
94: 		return;
95: 	}
96: 	ParsedExpressionIterator::EnumerateChildren(
97: 	    *expr, [&](unique_ptr<ParsedExpression> &child_expr) { ReplaceStarExpression(child_expr, replacement); });
98: }
99: 
100: static string ReplaceColumnsAlias(const string &alias, const string &column_name, optional_ptr<duckdb_re2::RE2> regex) {
101: 	string result;
102: 	result.reserve(alias.size());
103: 	for (idx_t c = 0; c < alias.size(); c++) {
104: 		if (alias[c] == '\\') {
105: 			c++;
106: 			if (c >= alias.size()) {
107: 				throw BinderException("Unterminated backslash in COLUMNS(*) \"%s\" alias. Backslashes must either be "
108: 				                      "escaped or followed by a number",
109: 				                      alias);
110: 			}
111: 			if (alias[c] == '\\') {
112: 				result += "\\";
113: 				continue;
114: 			}
115: 			if (alias[c] < '0' || alias[c] > '9') {
116: 				throw BinderException("Invalid backslash code in COLUMNS(*) \"%s\" alias. Backslashes must either be "
117: 				                      "escaped or followed by a number",
118: 				                      alias);
119: 			}
120: 			if (alias[c] == '0') {
121: 				result += column_name;
122: 			} else if (!regex) {
123: 				throw BinderException(
124: 				    "Only the backslash escape code \\0 can be used when no regex is supplied to COLUMNS(*)");
125: 			} else {
126: 				string extracted;
127: 				RE2::Extract(column_name, *regex, "\\" + alias.substr(c, 1), &extracted);
128: 				result += extracted;
129: 			}
130: 		} else {
131: 			result += alias[c];
132: 		}
133: 	}
134: 	return result;
135: }
136: 
137: void Binder::ExpandStarExpression(unique_ptr<ParsedExpression> expr,
138:                                   vector<unique_ptr<ParsedExpression>> &new_select_list) {
139: 	StarExpression *star = nullptr;
140: 	if (!FindStarExpression(expr, &star, true, false)) {
141: 		// no star expression: add it as-is
142: 		D_ASSERT(!star);
143: 		new_select_list.push_back(std::move(expr));
144: 		return;
145: 	}
146: 	D_ASSERT(star);
147: 	vector<unique_ptr<ParsedExpression>> star_list;
148: 	// we have star expressions! expand the list of star expressions
149: 	bind_context.GenerateAllColumnExpressions(*star, star_list);
150: 
151: 	unique_ptr<duckdb_re2::RE2> regex;
152: 	if (star->expr) {
153: 		// COLUMNS with an expression
154: 		// two options:
155: 		// VARCHAR parameter <- this is a regular expression
156: 		// LIST of VARCHAR parameters <- this is a set of columns
157: 		TableFunctionBinder binder(*this, context);
158: 		auto child = star->expr->Copy();
159: 		auto result = binder.Bind(child);
160: 		if (!result->IsFoldable()) {
161: 			// cannot resolve parameters here
162: 			if (star->expr->HasParameter()) {
163: 				throw ParameterNotResolvedException();
164: 			} else {
165: 				throw BinderException("Unsupported expression in COLUMNS");
166: 			}
167: 		}
168: 		auto val = ExpressionExecutor::EvaluateScalar(context, *result);
169: 		if (val.type().id() == LogicalTypeId::VARCHAR) {
170: 			// regex
171: 			if (val.IsNull()) {
172: 				throw BinderException("COLUMNS does not support NULL as regex argument");
173: 			}
174: 			auto &regex_str = StringValue::Get(val);
175: 			regex = make_uniq<duckdb_re2::RE2>(regex_str);
176: 			if (!regex->error().empty()) {
177: 				auto err = StringUtil::Format("Failed to compile regex \"%s\": %s", regex_str, regex->error());
178: 				throw BinderException(*star, err);
179: 			}
180: 			vector<unique_ptr<ParsedExpression>> new_list;
181: 			for (idx_t i = 0; i < star_list.size(); i++) {
182: 				auto &colref = star_list[i]->Cast<ColumnRefExpression>();
183: 				if (!RE2::PartialMatch(colref.GetColumnName(), *regex)) {
184: 					continue;
185: 				}
186: 				new_list.push_back(std::move(star_list[i]));
187: 			}
188: 			if (new_list.empty()) {
189: 				auto err = StringUtil::Format("No matching columns found that match regex \"%s\"", regex_str);
190: 				throw BinderException(*star, err);
191: 			}
192: 			star_list = std::move(new_list);
193: 		} else if (val.type().id() == LogicalTypeId::LIST &&
194: 		           ListType::GetChildType(val.type()).id() == LogicalTypeId::VARCHAR) {
195: 			// list of varchar columns
196: 			if (val.IsNull() || ListValue::GetChildren(val).empty()) {
197: 				auto err =
198: 				    StringUtil::Format("Star expression \"%s\" resulted in an empty set of columns", star->ToString());
199: 				throw BinderException(*star, err);
200: 			}
201: 			auto &children = ListValue::GetChildren(val);
202: 			vector<unique_ptr<ParsedExpression>> new_list;
203: 			// scan the list for all selected columns and construct a lookup table
204: 			case_insensitive_map_t<bool> selected_set;
205: 			for (auto &child : children) {
206: 				selected_set.insert(make_pair(StringValue::Get(child), false));
207: 			}
208: 			// now check the list of all possible expressions and select which ones make it in
209: 			for (auto &expr : star_list) {
210: 				auto str = GetColumnsStringValue(*expr);
211: 				auto entry = selected_set.find(str);
212: 				if (entry != selected_set.end()) {
213: 					new_list.push_back(std::move(expr));
214: 					entry->second = true;
215: 				}
216: 			}
217: 			// check if all expressions found a match
218: 			for (auto &entry : selected_set) {
219: 				if (!entry.second) {
220: 					throw BinderException("Column \"%s\" was selected but was not found in the FROM clause",
221: 					                      entry.first);
222: 				}
223: 			}
224: 			star_list = std::move(new_list);
225: 		} else {
226: 			throw BinderException(
227: 			    *star, "COLUMNS expects either a VARCHAR argument (regex) or a LIST of VARCHAR (list of columns)");
228: 		}
229: 	}
230: 
231: 	// now perform the replacement
232: 	if (StarExpression::IsColumnsUnpacked(*star)) {
233: 		if (StarExpression::IsColumnsUnpacked(*expr)) {
234: 			throw BinderException("*COLUMNS not allowed at the root level, use COLUMNS instead");
235: 		}
236: 		ReplaceUnpackedStarExpression(expr, star_list);
237: 		new_select_list.push_back(std::move(expr));
238: 		return;
239: 	}
240: 	for (idx_t i = 0; i < star_list.size(); i++) {
241: 		auto new_expr = expr->Copy();
242: 		ReplaceStarExpression(new_expr, star_list[i]);
243: 		if (StarExpression::IsColumns(*star)) {
244: 			optional_ptr<ParsedExpression> expr = star_list[i].get();
245: 			while (expr) {
246: 				if (expr->type == ExpressionType::COLUMN_REF) {
247: 					break;
248: 				}
249: 				if (expr->type == ExpressionType::OPERATOR_COALESCE) {
250: 					expr = expr->Cast<OperatorExpression>().children[0].get();
251: 				} else {
252: 					// unknown expression
253: 					expr = nullptr;
254: 				}
255: 			}
256: 			if (expr) {
257: 				auto &colref = expr->Cast<ColumnRefExpression>();
258: 				if (new_expr->alias.empty()) {
259: 					new_expr->alias = colref.GetColumnName();
260: 				} else {
261: 					new_expr->alias = ReplaceColumnsAlias(new_expr->alias, colref.GetColumnName(), regex.get());
262: 				}
263: 			}
264: 		}
265: 		new_select_list.push_back(std::move(new_expr));
266: 	}
267: }
268: 
269: void Binder::ExpandStarExpressions(vector<unique_ptr<ParsedExpression>> &select_list,
270:                                    vector<unique_ptr<ParsedExpression>> &new_select_list) {
271: 	for (auto &select_element : select_list) {
272: 		ExpandStarExpression(std::move(select_element), new_select_list);
273: 	}
274: }
275: 
276: } // namespace duckdb
[end of src/planner/binder/expression/bind_star_expression.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: