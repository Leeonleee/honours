diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp
index 7486d56badc7..4da68f21e4f2 100644
--- a/test/rigger/test_rigger.cpp
+++ b/test/rigger/test_rigger.cpp
@@ -253,4 +253,82 @@ TEST_CASE("Tests found by Rigger", "[rigger]") {
 		result = con.Query("SELECT * FROM t0 WHERE t0.c0 NOT SIMILAR TO 0;");
 		REQUIRE(CHECK_COLUMN(result, 0, {-10}));
 	}
+	SECTION("513") {
+		// LEFT JOIN with comparison on integer columns results in "Not implemented: Unimplemented type for nested loop join!"
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t1(c0) VALUES (0);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (0);"));
+		result = con.Query("SELECT * FROM t0 LEFT JOIN t1 ON t0.c0 <= t1.c0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {0}));
+		REQUIRE(CHECK_COLUMN(result, 1, {0}));
+	}
+	SECTION("514") {
+		// Incorrect result after an INSERT violates a UNIQUE constraint
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE UNIQUE INDEX i0 ON t0(c0);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (1);"));
+		result = con.Query("SELECT * FROM t0 WHERE t0.c0 = 1;");
+		REQUIRE(CHECK_COLUMN(result, 0, {1}));
+		REQUIRE_FAIL(con.Query("INSERT INTO t0(c0) VALUES (1);"));
+		result = con.Query("SELECT * FROM t0 WHERE t0.c0 = 1;");
+		REQUIRE(CHECK_COLUMN(result, 0, {1}));
+
+		// verify correct behavior here too when we have multiple nodes
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (2);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (3);"));
+		REQUIRE_FAIL(con.Query("INSERT INTO t0(c0) VALUES (2);"));
+		result = con.Query("SELECT * FROM t0 WHERE t0.c0 = 2;");
+		REQUIRE(CHECK_COLUMN(result, 0, {2}));
+	}
+	SECTION("515") {
+		// Query with a negative shift predicate yields an incorrect result
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 INT8, c1 DOUBLE);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t1(c0) VALUES (0);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t1(c1, c0) VALUES (1, 1);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0 VALUES (0);"));
+		result = con.Query("SELECT * FROM t1 JOIN t0 ON t1.c1 WHERE NOT (t1.c0<<-1);");
+		REQUIRE(CHECK_COLUMN(result, 0, {1}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1}));
+		REQUIRE(CHECK_COLUMN(result, 2, {0}));
+		result = con.Query("SELECT * FROM t1 JOIN t0 ON t1.c1 WHERE (t1.c0<<-1);");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+		REQUIRE(CHECK_COLUMN(result, 1, {}));
+		REQUIRE(CHECK_COLUMN(result, 2, {}));
+		result = con.Query("SELECT NOT (t1.c0<<-1) FROM t1;");
+		REQUIRE(CHECK_COLUMN(result, 0, {true, true}));
+	}
+	SECTION("516") {
+		// Query with comparison on boolean column results in "Invalid type: Invalid Type [BOOL]: Invalid type for index"
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 BOOL UNIQUE);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (0);"));
+		result = con.Query("SELECT * FROM t0 WHERE t0.c0 = true;");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+	}
+	SECTION("517") {
+		// Query with an AND predicate, NOT and comparison yields an incorrect result
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (0);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t1(c0) VALUES (0);"));
+		result = con.Query("SELECT * FROM t1, t0 WHERE NOT ((t1.c0 AND t0.c0) < 0);");
+		REQUIRE(CHECK_COLUMN(result, 0, {0}));
+		REQUIRE(CHECK_COLUMN(result, 0, {0}));
+		result = con.Query("SELECT * FROM t1, t0 WHERE ((t1.c0 AND t0.c0) < 0);");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+	}
+	SECTION("518") {
+		// Query using the LN() function does not terminate
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (0);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t1(c0) VALUES (0), (0), (1), (-1);"));
+		result = con.Query("SELECT LN(t1.c0) FROM t0, t1 WHERE LN(t1.c0) < t0.c0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+		result = con.Query("SELECT t1.c0, LN(t1.c0) FROM t1 ORDER BY t1.c0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {-1, 0, 0, 1}));
+		REQUIRE(CHECK_COLUMN(result, 1, {Value(), Value(), Value(), 0}));
+	}
 }
diff --git a/test/sql/function/test_math.cpp b/test/sql/function/test_math.cpp
index 82d301eb42f8..2bdd4255aa2f 100644
--- a/test/sql/function/test_math.cpp
+++ b/test/sql/function/test_math.cpp
@@ -230,3 +230,25 @@ TEST_CASE("Power test", "[function]") {
 	result = con.Query("select power(b, a) from powerme");
 	REQUIRE(CHECK_COLUMN(result, 0, {10.045}));
 }
+
+TEST_CASE("Test invalid input for math functions", "[function]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db);
+	con.EnableQueryVerification();
+
+	// any invalid input in math functions results in a NULL
+	// sqrt of negative number
+	result = con.Query("SELECT SQRT(-1), SQRT(0)");
+	REQUIRE(CHECK_COLUMN(result, 0, {Value()}));
+	REQUIRE(CHECK_COLUMN(result, 1, {0}));
+
+	// log of value <= 0
+	result = con.Query("SELECT LN(-1), LN(0), LOG10(-1), LOG10(0), LOG2(-1), LOG2(0)");
+	REQUIRE(CHECK_COLUMN(result, 0, {Value()}));
+	REQUIRE(CHECK_COLUMN(result, 1, {Value()}));
+	REQUIRE(CHECK_COLUMN(result, 2, {Value()}));
+	REQUIRE(CHECK_COLUMN(result, 3, {Value()}));
+	REQUIRE(CHECK_COLUMN(result, 4, {Value()}));
+	REQUIRE(CHECK_COLUMN(result, 5, {Value()}));
+}
diff --git a/test/sql/join/test_left_outer_join.cpp b/test/sql/join/test_left_outer_join.cpp
index 3b160d764835..a49a3ee8b5ac 100644
--- a/test/sql/join/test_left_outer_join.cpp
+++ b/test/sql/join/test_left_outer_join.cpp
@@ -131,4 +131,24 @@ TEST_CASE("Test LEFT OUTER JOIN", "[join]") {
 	REQUIRE(CHECK_COLUMN(result, 1, {2, 3, 4, 4}));
 	REQUIRE(CHECK_COLUMN(result, 2, {2, 2, 1, 2}));
 	REQUIRE(CHECK_COLUMN(result, 3, {20, 20, 10, 20}));
+
+	// range join
+	result = con.Query("SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.i<integers2.k WHERE integers.i <= 2 ORDER BY i");
+	REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+	REQUIRE(CHECK_COLUMN(result, 1, {2, 3}));
+	REQUIRE(CHECK_COLUMN(result, 2, {2, Value()}));
+	REQUIRE(CHECK_COLUMN(result, 3, {20, Value()}));
+
+	// multiple conditions
+	result = con.Query("SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.i<integers2.k AND integers.i<integers2.l WHERE integers.i <= 2 ORDER BY i");
+	REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+	REQUIRE(CHECK_COLUMN(result, 1, {2, 3}));
+	REQUIRE(CHECK_COLUMN(result, 2, {2, Value()}));
+	REQUIRE(CHECK_COLUMN(result, 3, {20, Value()}));
+
+	result = con.Query("SELECT * FROM integers LEFT OUTER JOIN (SELECT * FROM integers2 WHERE k=100) integers2 ON integers.i<integers2.k ORDER BY i");
+	REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));
+	REQUIRE(CHECK_COLUMN(result, 1, {2, 3, 4}));
+	REQUIRE(CHECK_COLUMN(result, 2, {Value(), Value(), Value()}));
+	REQUIRE(CHECK_COLUMN(result, 3, {Value(), Value(), Value()}));
 }
