{
  "repo": "duckdb/duckdb",
  "pull_number": 519,
  "instance_id": "duckdb__duckdb-519",
  "issue_numbers": [
    "518"
  ],
  "base_commit": "9795d18b6a6e250a4076fa448f248287e76f5693",
  "patch": "diff --git a/src/execution/index/art/art.cpp b/src/execution/index/art/art.cpp\nindex 6e7467e301fd..9b03b2ab8aff 100644\n--- a/src/execution/index/art/art.cpp\n+++ b/src/execution/index/art/art.cpp\n@@ -347,8 +347,6 @@ void ART::Delete(IndexLock &state, DataChunk &input, Vector &row_ids) {\n \t\t\tcontinue;\n \t\t}\n \t\tErase(tree, *keys[i], 0, row_identifiers[i]);\n-\t\t// assert that the entry was erased properly\n-\t\tassert(!is_unique || Lookup(tree, *keys[i], 0) == nullptr);\n \t}\n }\n \n@@ -360,7 +358,11 @@ void ART::Erase(unique_ptr<Node> &node, Key &key, unsigned depth, row_t row_id)\n \tif (node->type == NodeType::NLeaf) {\n \t\t// Make sure we have the right leaf\n \t\tif (ART::LeafMatches(node.get(), key, depth)) {\n-\t\t\tnode.reset();\n+\t\t\tauto leaf = static_cast<Leaf *>(node.get());\n+\t\t\tleaf->Remove(row_id);\n+\t\t\tif (leaf->num_elements == 0) {\n+\t\t\t\tnode.reset();\n+\t\t\t}\n \t\t}\n \t\treturn;\n \t}\n@@ -381,11 +383,9 @@ void ART::Erase(unique_ptr<Node> &node, Key &key, unsigned depth, row_t row_id)\n \t\tif (child_ref->type == NodeType::NLeaf && LeafMatches(child_ref.get(), key, depth)) {\n \t\t\t// Leaf found, remove entry\n \t\t\tauto leaf = static_cast<Leaf *>(child_ref.get());\n-\t\t\tif (leaf->num_elements > 1) {\n-\t\t\t\t// leaf has multiple rows: remove the row from the leaf\n-\t\t\t\tleaf->Remove(row_id);\n-\t\t\t} else {\n-\t\t\t\t// Leaf only has one element, delete leaf, decrement node counter and maybe shrink node\n+\t\t\tleaf->Remove(row_id);\n+\t\t\tif (leaf->num_elements == 0) {\n+\t\t\t\t// Leaf is empty, delete leaf, decrement node counter and maybe shrink node\n \t\t\t\tNode::Erase(*this, node, pos);\n \t\t\t}\n \t\t} else {\n@@ -401,6 +401,8 @@ void ART::Erase(unique_ptr<Node> &node, Key &key, unsigned depth, row_t row_id)\n static unique_ptr<Key> CreateKey(ART &art, TypeId type, Value &value) {\n \tassert(type == value.type);\n \tswitch (type) {\n+\tcase TypeId::BOOL:\n+\t\treturn Key::CreateKey<bool>(value.value_.boolean, art.is_little_endian);\n \tcase TypeId::INT8:\n \t\treturn Key::CreateKey<int8_t>(value.value_.tinyint, art.is_little_endian);\n \tcase TypeId::INT16:\ndiff --git a/src/execution/index/art/leaf.cpp b/src/execution/index/art/leaf.cpp\nindex 76613f97cae9..6bddd2984343 100644\n--- a/src/execution/index/art/leaf.cpp\n+++ b/src/execution/index/art/leaf.cpp\n@@ -27,13 +27,16 @@ void Leaf::Insert(row_t row_id) {\n \n //! TODO: Maybe shrink array dynamically?\n void Leaf::Remove(row_t row_id) {\n-\tidx_t entry_offset = -1;\n+\tidx_t entry_offset = INVALID_INDEX;\n \tfor (idx_t i = 0; i < num_elements; i++) {\n \t\tif (row_ids[i] == row_id) {\n \t\t\tentry_offset = i;\n \t\t\tbreak;\n \t\t}\n \t}\n+\tif (entry_offset == INVALID_INDEX) {\n+\t\treturn;\n+\t}\n \tnum_elements--;\n \tfor (idx_t j = entry_offset; j < num_elements; j++) {\n \t\trow_ids[j] = row_ids[j + 1];\ndiff --git a/src/execution/operator/join/physical_nested_loop_join.cpp b/src/execution/operator/join/physical_nested_loop_join.cpp\nindex c34d8caf9c09..ac20a66ae8c0 100644\n--- a/src/execution/operator/join/physical_nested_loop_join.cpp\n+++ b/src/execution/operator/join/physical_nested_loop_join.cpp\n@@ -25,6 +25,8 @@ class PhysicalNestedLoopJoinState : public PhysicalComparisonJoinState {\n \n \tidx_t left_tuple;\n \tidx_t right_tuple;\n+\n+\tunique_ptr<bool[]> left_found_match;\n };\n \n PhysicalNestedLoopJoin::PhysicalNestedLoopJoin(LogicalOperator &op, unique_ptr<PhysicalOperator> left,\n@@ -197,7 +199,6 @@ void PhysicalNestedLoopJoin::GetChunkInternal(ClientContext &context, DataChunk\n \t\t}\n \t\treturn;\n \t}\n-\n \tif ((type == JoinType::INNER || type == JoinType::LEFT) &&\n \t    state->right_chunk >= state->right_chunks.chunks.size()) {\n \t\treturn;\n@@ -214,6 +215,27 @@ void PhysicalNestedLoopJoin::GetChunkInternal(ClientContext &context, DataChunk\n \t\t\t\t// we exhausted all right chunks!\n \t\t\t\t// move to the next left chunk\n \t\t\t\tdo {\n+\t\t\t\t\tif (type == JoinType::LEFT) {\n+\t\t\t\t\t\t// left join: before we move to the next chunk, see if we need to output any vectors that didn't have a match found\n+\t\t\t\t\t\tif (state->left_found_match) {\n+\t\t\t\t\t\t\tSelectionVector remaining_sel(STANDARD_VECTOR_SIZE);\n+\t\t\t\t\t\t\tidx_t remaining_count = 0;\n+\t\t\t\t\t\t\tfor(idx_t i = 0; i < state->child_chunk.size(); i++) {\n+\t\t\t\t\t\t\t\tif (!state->left_found_match[i]) {\n+\t\t\t\t\t\t\t\t\tremaining_sel.set_index(remaining_count++, i);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tstate->left_found_match.reset();\n+\t\t\t\t\t\t\tchunk.Slice(state->child_chunk, remaining_sel, remaining_count);\n+\t\t\t\t\t\t\tfor (idx_t idx = state->child_chunk.column_count(); idx < chunk.column_count(); idx++) {\n+\t\t\t\t\t\t\t\tchunk.data[idx].vector_type = VectorType::CONSTANT_VECTOR;\n+\t\t\t\t\t\t\t\tConstantVector::SetNull(chunk.data[idx], true);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tstate->left_found_match = unique_ptr<bool[]>(new bool[STANDARD_VECTOR_SIZE]);\n+\t\t\t\t\t\t\tmemset(state->left_found_match.get(), 0, sizeof(bool) * STANDARD_VECTOR_SIZE);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t\tchildren[0]->GetChunk(context, state->child_chunk, state->child_state.get());\n \t\t\t\t\tif (state->child_chunk.size() == 0) {\n \t\t\t\t\t\treturn;\n@@ -271,6 +293,7 @@ void PhysicalNestedLoopJoin::GetChunkInternal(ClientContext &context, DataChunk\n \n \t\t// now perform the join\n \t\tswitch (type) {\n+\t\tcase JoinType::LEFT:\n \t\tcase JoinType::INNER: {\n \t\t\tSelectionVector lvector(STANDARD_VECTOR_SIZE), rvector(STANDARD_VECTOR_SIZE);\n \t\t\tidx_t match_count =\n@@ -283,6 +306,11 @@ void PhysicalNestedLoopJoin::GetChunkInternal(ClientContext &context, DataChunk\n \t\t\t}\n \t\t\t// we have matching tuples!\n \t\t\t// construct the result\n+\t\t\tif (state->left_found_match) {\n+\t\t\t\tfor(idx_t i = 0; i < match_count; i++) {\n+\t\t\t\t\tstate->left_found_match[lvector.get_index(i)] = true;\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tchunk.Slice(state->child_chunk, lvector, match_count);\n \t\t\tchunk.Slice(right_data, rvector, match_count, state->child_chunk.column_count());\n \t\t\tbreak;\ndiff --git a/src/execution/operator/join/physical_piecewise_merge_join.cpp b/src/execution/operator/join/physical_piecewise_merge_join.cpp\nindex 7f1587f06a4c..4c032d84a92c 100644\n--- a/src/execution/operator/join/physical_piecewise_merge_join.cpp\n+++ b/src/execution/operator/join/physical_piecewise_merge_join.cpp\n@@ -228,7 +228,7 @@ static void templated_quicksort_inplace(T *data, const SelectionVector &sel, idx\n \t\t\ti++;\n \t\t}\n \n-\t\twhile (i <= j && OP::Operation(data[dpivot_idx], data[sel.get_index(result.get_index(j))])) {\n+\t\twhile (i <= j && !OP::Operation(data[sel.get_index(result.get_index(j))], data[dpivot_idx])) {\n \t\t\tj--;\n \t\t}\n \n@@ -265,6 +265,30 @@ static void templated_quicksort(VectorData &vdata, const SelectionVector &not_nu\n \ttemplated_quicksort<T, duckdb::LessThanEquals>((T *)vdata.data, *vdata.sel, not_null_sel, not_null_count, result);\n }\n \n+idx_t FilterNulls(VectorData &vdata, idx_t count, SelectionVector &not_null) {\n+\tidx_t not_null_count = 0;\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tauto idx = vdata.sel->get_index(i);\n+\t\tif (!(*vdata.nullmask)[idx]) {\n+\t\t\tnot_null.set_index(not_null_count++, i);\n+\t\t}\n+\t}\n+\treturn not_null_count;\n+}\n+\n+template<class T>\n+idx_t FilterNullsAndNaNs(VectorData &vdata, idx_t count, SelectionVector &not_null) {\n+\tauto data = (T *) vdata.data;\n+\tidx_t not_null_count = 0;\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tauto idx = vdata.sel->get_index(i);\n+\t\tif (!(*vdata.nullmask)[idx] && (!std::isnan(data[idx]))) {\n+\t\t\tnot_null.set_index(not_null_count++, i);\n+\t\t}\n+\t}\n+\treturn not_null_count;\n+}\n+\n void OrderVector(Vector &vector, idx_t count, MergeOrder &order) {\n \tif (count == 0) {\n \t\torder.count = 0;\n@@ -274,13 +298,18 @@ void OrderVector(Vector &vector, idx_t count, MergeOrder &order) {\n \tauto &vdata = order.vdata;\n \n \t// first filter out all the non-null values\n-\tidx_t not_null_count = 0;\n \tSelectionVector not_null(STANDARD_VECTOR_SIZE);\n-\tfor (idx_t i = 0; i < count; i++) {\n-\t\tauto idx = vdata.sel->get_index(i);\n-\t\tif (!(*vdata.nullmask)[idx]) {\n-\t\t\tnot_null.set_index(not_null_count++, i);\n-\t\t}\n+\tidx_t not_null_count;\n+\tswitch(vector.type) {\n+\tcase TypeId::FLOAT:\n+\t\tnot_null_count = FilterNullsAndNaNs<float>(vdata, count, not_null);\n+\t\tbreak;\n+\tcase TypeId::DOUBLE:\n+\t\tnot_null_count = FilterNullsAndNaNs<double>(vdata, count, not_null);\n+\t\tbreak;\n+\tdefault:\n+\t\tnot_null_count = FilterNulls(vdata, count, not_null);\n+\t\tbreak;\n \t}\n \torder.count = not_null_count;\n \torder.order.Initialize(STANDARD_VECTOR_SIZE);\ndiff --git a/src/function/scalar/math/numeric.cpp b/src/function/scalar/math/numeric.cpp\nindex 190364a3d712..b5d4c284ef5a 100644\n--- a/src/function/scalar/math/numeric.cpp\n+++ b/src/function/scalar/math/numeric.cpp\n@@ -4,7 +4,6 @@\n #include <algorithm>\n #include <cmath>\n \n-using namespace duckdb;\n using namespace std;\n \n namespace duckdb {\n@@ -161,6 +160,37 @@ void PowFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(power_function);\n }\n \n+//===--------------------------------------------------------------------===//\n+// Unary wrappers to turn values < 0 or <= 0 into NULL\n+//===--------------------------------------------------------------------===//\n+struct UnaryNegativeWrapper {\n+\ttemplate <class FUNC, class OP, class INPUT_TYPE, class RESULT_TYPE>\n+\tstatic inline RESULT_TYPE Operation(FUNC fun, INPUT_TYPE input, nullmask_t &nullmask, idx_t idx) {\n+\t\tif (input < 0) {\n+\t\t\tnullmask[idx] = true;\n+\t\t\treturn 0;\n+\t\t} else {\n+\t\t\treturn OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input);\n+\t\t}\n+\t}\n+};\n+\n+struct UnaryZeroOrNegativeWrapper {\n+\ttemplate <class FUNC, class OP, class INPUT_TYPE, class RESULT_TYPE>\n+\tstatic inline RESULT_TYPE Operation(FUNC fun, INPUT_TYPE input, nullmask_t &nullmask, idx_t idx) {\n+\t\tif (input <= 0) {\n+\t\t\tnullmask[idx] = true;\n+\t\t\treturn 0;\n+\t\t} else {\n+\t\t\treturn OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input);\n+\t\t}\n+\t}\n+};\n+\n+template <class T, class OP, class OPWRAPPER>\n+static void UnaryScalarFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {\n+\tUnaryExecutor::Execute<T, T, OP, true, OPWRAPPER>(input.data[0], result, input.size());\n+}\n //===--------------------------------------------------------------------===//\n // sqrt\n //===--------------------------------------------------------------------===//\n@@ -172,12 +202,27 @@ struct SqrtOperator {\n \n void SqrtFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"sqrt\", {SQLType::DOUBLE}, SQLType::DOUBLE,\n-\t                               ScalarFunction::UnaryFunction<double, double, SqrtOperator>));\n+\t                               UnaryScalarFunctionWrapper<double, SqrtOperator, UnaryNegativeWrapper>));\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// cbrt\n+//===--------------------------------------------------------------------===//\n+struct CbRtOperator {\n+\ttemplate <class TA, class TR> static inline TR Operation(TA left) {\n+\t\treturn cbrt(left);\n+\t}\n+};\n+\n+void CbrtFun::RegisterFunction(BuiltinFunctions &set) {\n+\tset.AddFunction(ScalarFunction(\"cbrt\", {SQLType::DOUBLE}, SQLType::DOUBLE,\n+\t                               ScalarFunction::UnaryFunction<double, double, CbRtOperator>));\n }\n \n //===--------------------------------------------------------------------===//\n // ln\n //===--------------------------------------------------------------------===//\n+\n struct LnOperator {\n \ttemplate <class TA, class TR> static inline TR Operation(TA left) {\n \t\treturn log(left);\n@@ -186,7 +231,7 @@ struct LnOperator {\n \n void LnFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"ln\", {SQLType::DOUBLE}, SQLType::DOUBLE,\n-\t                               ScalarFunction::UnaryFunction<double, double, LnOperator>));\n+\t                               UnaryScalarFunctionWrapper<double, LnOperator, UnaryZeroOrNegativeWrapper>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -200,7 +245,7 @@ struct Log10Operator {\n \n void Log10Fun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunction log_function(\"log10\", {SQLType::DOUBLE}, SQLType::DOUBLE,\n-\t                            ScalarFunction::UnaryFunction<double, double, Log10Operator>);\n+\t                               UnaryScalarFunctionWrapper<double, Log10Operator, UnaryZeroOrNegativeWrapper>);\n \tset.AddFunction(log_function);\n \t// \"log\" is an alias for \"log10\"\n \tlog_function.name = \"log\";\n@@ -218,21 +263,7 @@ struct Log2Operator {\n \n void Log2Fun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"log2\", {SQLType::DOUBLE}, SQLType::DOUBLE,\n-\t                               ScalarFunction::UnaryFunction<double, double, Log2Operator>));\n-}\n-\n-//===--------------------------------------------------------------------===//\n-// cbrt\n-//===--------------------------------------------------------------------===//\n-struct CbRtOperator {\n-\ttemplate <class TA, class TR> static inline TR Operation(TA left) {\n-\t\treturn cbrt(left);\n-\t}\n-};\n-\n-void CbrtFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction(ScalarFunction(\"cbrt\", {SQLType::DOUBLE}, SQLType::DOUBLE,\n-\t                               ScalarFunction::UnaryFunction<double, double, CbRtOperator>));\n+\t                               UnaryScalarFunctionWrapper<double, Log2Operator, UnaryZeroOrNegativeWrapper>));\n }\n \n //===--------------------------------------------------------------------===//\ndiff --git a/src/function/scalar/operators/bitwise.cpp b/src/function/scalar/operators/bitwise.cpp\nindex d767423c680b..bb75a8705aa0 100644\n--- a/src/function/scalar/operators/bitwise.cpp\n+++ b/src/function/scalar/operators/bitwise.cpp\n@@ -65,7 +65,7 @@ void BitwiseXorFun::RegisterFunction(BuiltinFunctions &set) {\n //===--------------------------------------------------------------------===//\n struct BitwiseShiftLeftOperator {\n \ttemplate <class TA, class TB, class TR> static inline TR Operation(TA left, TB right) {\n-\t\treturn left << right;\n+\t\treturn right < 0 ? 0 : left << right;\n \t}\n };\n \n@@ -83,7 +83,7 @@ void LeftShiftFun::RegisterFunction(BuiltinFunctions &set) {\n //===--------------------------------------------------------------------===//\n struct BitwiseShiftRightOperator {\n \ttemplate <class TA, class TB, class TR> static inline TR Operation(TA left, TB right) {\n-\t\treturn left >> right;\n+\t\treturn right < 0 ? 0 : left >> right;\n \t}\n };\n \ndiff --git a/src/include/duckdb/common/vector_operations/unary_executor.hpp b/src/include/duckdb/common/vector_operations/unary_executor.hpp\nindex c2710dbaa6b6..821dfbd28c10 100644\n--- a/src/include/duckdb/common/vector_operations/unary_executor.hpp\n+++ b/src/include/duckdb/common/vector_operations/unary_executor.hpp\n@@ -18,14 +18,14 @@ namespace duckdb {\n \n struct UnaryOperatorWrapper {\n \ttemplate <class FUNC, class OP, class INPUT_TYPE, class RESULT_TYPE>\n-\tstatic inline RESULT_TYPE Operation(FUNC fun, INPUT_TYPE input) {\n+\tstatic inline RESULT_TYPE Operation(FUNC fun, INPUT_TYPE input, nullmask_t &nullmask, idx_t idx) {\n \t\treturn OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input);\n \t}\n };\n \n struct UnaryLambdaWrapper {\n \ttemplate <class FUNC, class OP, class INPUT_TYPE, class RESULT_TYPE>\n-\tstatic inline RESULT_TYPE Operation(FUNC fun, INPUT_TYPE input) {\n+\tstatic inline RESULT_TYPE Operation(FUNC fun, INPUT_TYPE input, nullmask_t &nullmask, idx_t idx) {\n \t\treturn fun(input);\n \t}\n };\n@@ -42,7 +42,7 @@ struct UnaryExecutor {\n \t\t\tfor (idx_t i = 0; i < count; i++) {\n \t\t\t\tauto idx = sel_vector->get_index(i);\n \t\t\t\tif (!nullmask[idx]) {\n-\t\t\t\t\tresult_data[i] = OPWRAPPER::template Operation<FUNC, OP, INPUT_TYPE, RESULT_TYPE>(fun, ldata[idx]);\n+\t\t\t\t\tresult_data[i] = OPWRAPPER::template Operation<FUNC, OP, INPUT_TYPE, RESULT_TYPE>(fun, ldata[idx], result_nullmask, i);\n \t\t\t\t} else {\n \t\t\t\t\tresult_nullmask[i] = true;\n \t\t\t\t}\n@@ -50,7 +50,7 @@ struct UnaryExecutor {\n \t\t} else {\n \t\t\tfor (idx_t i = 0; i < count; i++) {\n \t\t\t\tauto idx = sel_vector->get_index(i);\n-\t\t\t\tresult_data[i] = OPWRAPPER::template Operation<FUNC, OP, INPUT_TYPE, RESULT_TYPE>(fun, ldata[idx]);\n+\t\t\t\tresult_data[i] = OPWRAPPER::template Operation<FUNC, OP, INPUT_TYPE, RESULT_TYPE>(fun, ldata[idx], result_nullmask, i);\n \t\t\t}\n \t\t}\n \t}\n@@ -64,12 +64,12 @@ struct UnaryExecutor {\n \t\t\tresult_nullmask = nullmask;\n \t\t\tfor (idx_t i = 0; i < count; i++) {\n \t\t\t\tif (!nullmask[i]) {\n-\t\t\t\t\tresult_data[i] = OPWRAPPER::template Operation<FUNC, OP, INPUT_TYPE, RESULT_TYPE>(fun, ldata[i]);\n+\t\t\t\t\tresult_data[i] = OPWRAPPER::template Operation<FUNC, OP, INPUT_TYPE, RESULT_TYPE>(fun, ldata[i], result_nullmask, i);\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor (idx_t i = 0; i < count; i++) {\n-\t\t\t\tresult_data[i] = OPWRAPPER::template Operation<FUNC, OP, INPUT_TYPE, RESULT_TYPE>(fun, ldata[i]);\n+\t\t\t\tresult_data[i] = OPWRAPPER::template Operation<FUNC, OP, INPUT_TYPE, RESULT_TYPE>(fun, ldata[i], result_nullmask, i);\n \t\t\t}\n \t\t}\n \t}\n@@ -86,7 +86,7 @@ struct UnaryExecutor {\n \t\t\t\tConstantVector::SetNull(result, true);\n \t\t\t} else {\n \t\t\t\tConstantVector::SetNull(result, false);\n-\t\t\t\t*result_data = OPWRAPPER::template Operation<FUNC, OP, INPUT_TYPE, RESULT_TYPE>(fun, *ldata);\n+\t\t\t\t*result_data = OPWRAPPER::template Operation<FUNC, OP, INPUT_TYPE, RESULT_TYPE>(fun, *ldata, ConstantVector::Nullmask(result), 0);\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n@@ -117,9 +117,9 @@ struct UnaryExecutor {\n \t}\n \n public:\n-\ttemplate <class INPUT_TYPE, class RESULT_TYPE, class OP, bool IGNORE_NULL = false>\n+\ttemplate <class INPUT_TYPE, class RESULT_TYPE, class OP, bool IGNORE_NULL = false, class OPWRAPPER=UnaryOperatorWrapper>\n \tstatic void Execute(Vector &input, Vector &result, idx_t count) {\n-\t\tExecuteStandard<INPUT_TYPE, RESULT_TYPE, UnaryOperatorWrapper, OP, bool, IGNORE_NULL>(input, result, count,\n+\t\tExecuteStandard<INPUT_TYPE, RESULT_TYPE, OPWRAPPER, OP, bool, IGNORE_NULL>(input, result, count,\n \t\t                                                                                      false);\n \t}\n \ndiff --git a/src/parser/transform/expression/transform_bool_expr.cpp b/src/parser/transform/expression/transform_bool_expr.cpp\nindex 9fa37086f43b..386f7c52f5eb 100644\n--- a/src/parser/transform/expression/transform_bool_expr.cpp\n+++ b/src/parser/transform/expression/transform_bool_expr.cpp\n@@ -32,6 +32,12 @@ unique_ptr<ParsedExpression> Transformer::TransformBoolExpr(PGBoolExpr *root) {\n \t\t\t\t// convert COMPARE_IN to COMPARE_NOT_IN\n \t\t\t\tnext->type = ExpressionType::COMPARE_NOT_IN;\n \t\t\t\tresult = move(next);\n+\t\t\t} else if (next->type >= ExpressionType::COMPARE_EQUAL &&\n+\t\t\t        next->type <= ExpressionType::COMPARE_GREATERTHANOREQUALTO) {\n+\t\t\t\t// NOT on a comparison: we can negate the comparison\n+\t\t\t\t// e.g. NOT(x > y) is equivalent to x <= y\n+\t\t\t\tnext->type = NegateComparisionExpression(next->type);\n+\t\t\t\tresult = move(next);\n \t\t\t} else {\n \t\t\t\tresult = make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(next));\n \t\t\t}\ndiff --git a/src/planner/binder/tableref/plan_joinref.cpp b/src/planner/binder/tableref/plan_joinref.cpp\nindex 757266b601ac..2efd47145c76 100644\n--- a/src/planner/binder/tableref/plan_joinref.cpp\n+++ b/src/planner/binder/tableref/plan_joinref.cpp\n@@ -74,28 +74,6 @@ unique_ptr<LogicalOperator> LogicalComparisonJoin::CreateJoin(JoinType type, uni\n \t\t\t\t// successfully created the join condition\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t} else if (expr->type == ExpressionType::OPERATOR_NOT) {\n-\t\t\tauto &not_expr = (BoundOperatorExpression &)*expr;\n-\t\t\tassert(not_expr.children.size() == 1);\n-\t\t\tExpressionType child_type = not_expr.children[0]->GetExpressionType();\n-\t\t\t// the condition is ON NOT (EXPRESSION)\n-\t\t\t// we can transform this to remove the NOT if the child is a Comparison\n-\t\t\t// e.g.:\n-\t\t\t// ON NOT (X = 3) can be turned into ON (X <> 3)\n-\t\t\t// ON NOT (X > 3) can be turned into ON (X <= 3)\n-\t\t\t// for non-comparison operators here we just push the filter\n-\t\t\tif (child_type >= ExpressionType::COMPARE_EQUAL &&\n-\t\t\t    child_type <= ExpressionType::COMPARE_GREATERTHANOREQUALTO) {\n-\t\t\t\t// switcheroo the child condition\n-\t\t\t\t// our join needs to compare explicit left and right sides. So we\n-\t\t\t\t// invert the condition to express NOT, this way we can still use\n-\t\t\t\t// equi-joins\n-\t\t\t\tnot_expr.children[0]->type = NegateComparisionExpression(child_type);\n-\t\t\t\tif (CreateJoinCondition(*not_expr.children[0], left_bindings, right_bindings, conditions)) {\n-\t\t\t\t\t// successfully created the join condition\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n \t\t}\n \t\tarbitrary_expressions.push_back(move(expr));\n \t}\n",
  "test_patch": "diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp\nindex 7486d56badc7..4da68f21e4f2 100644\n--- a/test/rigger/test_rigger.cpp\n+++ b/test/rigger/test_rigger.cpp\n@@ -253,4 +253,82 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 NOT SIMILAR TO 0;\");\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {-10}));\n \t}\n+\tSECTION(\"513\") {\n+\t\t// LEFT JOIN with comparison on integer columns results in \"Not implemented: Unimplemented type for nested loop join!\"\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1(c0) VALUES (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 LEFT JOIN t1 ON t0.c0 <= t1.c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {0}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {0}));\n+\t}\n+\tSECTION(\"514\") {\n+\t\t// Incorrect result after an INSERT violates a UNIQUE constraint\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE UNIQUE INDEX i0 ON t0(c0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (1);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 = 1;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {1}));\n+\t\tREQUIRE_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (1);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 = 1;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {1}));\n+\n+\t\t// verify correct behavior here too when we have multiple nodes\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (2);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (3);\"));\n+\t\tREQUIRE_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (2);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 = 2;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {2}));\n+\t}\n+\tSECTION(\"515\") {\n+\t\t// Query with a negative shift predicate yields an incorrect result\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 INT8, c1 DOUBLE);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1(c0) VALUES (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1(c1, c0) VALUES (1, 1);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t1 JOIN t0 ON t1.c1 WHERE NOT (t1.c0<<-1);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {1}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {1}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 2, {0}));\n+\t\tresult = con.Query(\"SELECT * FROM t1 JOIN t0 ON t1.c1 WHERE (t1.c0<<-1);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 2, {}));\n+\t\tresult = con.Query(\"SELECT NOT (t1.c0<<-1) FROM t1;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {true, true}));\n+\t}\n+\tSECTION(\"516\") {\n+\t\t// Query with comparison on boolean column results in \"Invalid type: Invalid Type [BOOL]: Invalid type for index\"\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 BOOL UNIQUE);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 = true;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t}\n+\tSECTION(\"517\") {\n+\t\t// Query with an AND predicate, NOT and comparison yields an incorrect result\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1(c0) VALUES (0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t1, t0 WHERE NOT ((t1.c0 AND t0.c0) < 0);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {0}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {0}));\n+\t\tresult = con.Query(\"SELECT * FROM t1, t0 WHERE ((t1.c0 AND t0.c0) < 0);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t}\n+\tSECTION(\"518\") {\n+\t\t// Query using the LN() function does not terminate\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1(c0) VALUES (0), (0), (1), (-1);\"));\n+\t\tresult = con.Query(\"SELECT LN(t1.c0) FROM t0, t1 WHERE LN(t1.c0) < t0.c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t\tresult = con.Query(\"SELECT t1.c0, LN(t1.c0) FROM t1 ORDER BY t1.c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {-1, 0, 0, 1}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {Value(), Value(), Value(), 0}));\n+\t}\n }\ndiff --git a/test/sql/function/test_math.cpp b/test/sql/function/test_math.cpp\nindex 82d301eb42f8..2bdd4255aa2f 100644\n--- a/test/sql/function/test_math.cpp\n+++ b/test/sql/function/test_math.cpp\n@@ -230,3 +230,25 @@ TEST_CASE(\"Power test\", \"[function]\") {\n \tresult = con.Query(\"select power(b, a) from powerme\");\n \tREQUIRE(CHECK_COLUMN(result, 0, {10.045}));\n }\n+\n+TEST_CASE(\"Test invalid input for math functions\", \"[function]\") {\n+\tunique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\tcon.EnableQueryVerification();\n+\n+\t// any invalid input in math functions results in a NULL\n+\t// sqrt of negative number\n+\tresult = con.Query(\"SELECT SQRT(-1), SQRT(0)\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value()}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {0}));\n+\n+\t// log of value <= 0\n+\tresult = con.Query(\"SELECT LN(-1), LN(0), LOG10(-1), LOG10(0), LOG2(-1), LOG2(0)\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value()}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value()}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {Value()}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {Value()}));\n+\tREQUIRE(CHECK_COLUMN(result, 4, {Value()}));\n+\tREQUIRE(CHECK_COLUMN(result, 5, {Value()}));\n+}\ndiff --git a/test/sql/join/test_left_outer_join.cpp b/test/sql/join/test_left_outer_join.cpp\nindex 3b160d764835..a49a3ee8b5ac 100644\n--- a/test/sql/join/test_left_outer_join.cpp\n+++ b/test/sql/join/test_left_outer_join.cpp\n@@ -131,4 +131,24 @@ TEST_CASE(\"Test LEFT OUTER JOIN\", \"[join]\") {\n \tREQUIRE(CHECK_COLUMN(result, 1, {2, 3, 4, 4}));\n \tREQUIRE(CHECK_COLUMN(result, 2, {2, 2, 1, 2}));\n \tREQUIRE(CHECK_COLUMN(result, 3, {20, 20, 10, 20}));\n+\n+\t// range join\n+\tresult = con.Query(\"SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.i<integers2.k WHERE integers.i <= 2 ORDER BY i\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 2}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {2, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {2, Value()}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {20, Value()}));\n+\n+\t// multiple conditions\n+\tresult = con.Query(\"SELECT * FROM integers LEFT OUTER JOIN integers2 ON integers.i<integers2.k AND integers.i<integers2.l WHERE integers.i <= 2 ORDER BY i\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 2}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {2, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {2, Value()}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {20, Value()}));\n+\n+\tresult = con.Query(\"SELECT * FROM integers LEFT OUTER JOIN (SELECT * FROM integers2 WHERE k=100) integers2 ON integers.i<integers2.k ORDER BY i\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {2, 3, 4}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {Value(), Value(), Value()}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {Value(), Value(), Value()}));\n }\n",
  "problem_statement": "Query using the LN() function does not terminate\nConsider the following statements:\r\n```sql\r\nCREATE TABLE t0(c0 INT);\r\nCREATE TABLE t1(c0 INT);\r\nINSERT INTO t0(c0) VALUES (0);\r\nINSERT INTO t1(c0) VALUES (0), (0), (1), (-1);\r\nSELECT * FROM t0, t1 WHERE LN(t1.c0) < t0.c0; -- does not terminate\r\n```\r\nUnexpectedly, the `SELECT` does not terminate.\r\n\r\nI found this bug based on the latest master commit (9795d18b6a6e250a4076fa448f248287e76f5693).\n",
  "hints_text": "Very interesting! I wonder what causes this :)",
  "created_at": "2020-04-11T18:47:40Z"
}