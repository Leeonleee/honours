{
  "repo": "duckdb/duckdb",
  "pull_number": 13415,
  "instance_id": "duckdb__duckdb-13415",
  "issue_numbers": [
    "13414"
  ],
  "base_commit": "3677209ef514027be1b55593a2fb7514346b1337",
  "patch": "diff --git a/src/function/table/system/duckdb_indexes.cpp b/src/function/table/system/duckdb_indexes.cpp\nindex 80938f605c14..b7ffe7fef121 100644\n--- a/src/function/table/system/duckdb_indexes.cpp\n+++ b/src/function/table/system/duckdb_indexes.cpp\n@@ -55,7 +55,7 @@ static unique_ptr<FunctionData> DuckDBIndexesBind(ClientContext &context, TableF\n \treturn_types.emplace_back(LogicalType::BOOLEAN);\n \n \tnames.emplace_back(\"expressions\");\n-\treturn_types.emplace_back(LogicalType::VARCHAR);\n+\treturn_types.emplace_back(LogicalType::LIST(LogicalType::VARCHAR));\n \n \tnames.emplace_back(\"sql\");\n \treturn_types.emplace_back(LogicalType::VARCHAR);\n@@ -75,6 +75,20 @@ unique_ptr<GlobalTableFunctionState> DuckDBIndexesInit(ClientContext &context, T\n \treturn std::move(result);\n }\n \n+Value GetIndexExpressions(IndexCatalogEntry &index) {\n+\tauto create_info = index.GetInfo();\n+\tauto &create_index_info = create_info->Cast<CreateIndexInfo>();\n+\n+\tauto vec = create_index_info.ExpressionsToList();\n+\n+\tvector<Value> content;\n+\tcontent.reserve(vec.size());\n+\tfor (auto &item : vec) {\n+\t\tcontent.push_back(Value(item));\n+\t}\n+\treturn Value::LIST(LogicalType::VARCHAR, std::move(content));\n+}\n+\n void DuckDBIndexesFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {\n \tauto &data = data_p.global_state->Cast<DuckDBIndexesData>();\n \tif (data.offset >= data.entries.size()) {\n@@ -119,7 +133,7 @@ void DuckDBIndexesFunction(ClientContext &context, TableFunctionInput &data_p, D\n \t\t// is_primary, BOOLEAN\n \t\toutput.SetValue(col++, count, Value::BOOLEAN(index.IsPrimary()));\n \t\t// expressions, VARCHAR\n-\t\toutput.SetValue(col++, count, Value());\n+\t\toutput.SetValue(col++, count, GetIndexExpressions(index));\n \t\t// sql, VARCHAR\n \t\tauto sql = index.ToSQL();\n \t\toutput.SetValue(col++, count, sql.empty() ? Value() : Value(std::move(sql)));\ndiff --git a/src/include/duckdb/parser/parsed_data/create_index_info.hpp b/src/include/duckdb/parser/parsed_data/create_index_info.hpp\nindex 4b42e8e0c6c3..08ff3826f11a 100644\n--- a/src/include/duckdb/parser/parsed_data/create_index_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/create_index_info.hpp\n@@ -48,6 +48,8 @@ struct CreateIndexInfo : public CreateInfo {\n \tDUCKDB_API unique_ptr<CreateInfo> Copy() const override;\n \n \tstring ToString() const override;\n+\tvector<string> ExpressionsToList() const;\n+\tstring ExpressionsToString() const;\n \tvoid Serialize(Serializer &serializer) const override;\n \tstatic unique_ptr<CreateInfo> Deserialize(Deserializer &deserializer);\n };\ndiff --git a/src/parser/parsed_data/create_index_info.cpp b/src/parser/parsed_data/create_index_info.cpp\nindex 4f2ff610cd34..8f74c05c7086 100644\n--- a/src/parser/parsed_data/create_index_info.cpp\n+++ b/src/parser/parsed_data/create_index_info.cpp\n@@ -27,6 +27,38 @@ static void RemoveTableQualificationRecursive(unique_ptr<ParsedExpression> &expr\n \t}\n }\n \n+vector<string> CreateIndexInfo::ExpressionsToList() const {\n+\tvector<string> list;\n+\n+\tfor (idx_t i = 0; i < parsed_expressions.size(); i++) {\n+\t\tauto &expr = parsed_expressions[i];\n+\t\tauto copy = expr->Copy();\n+\t\t// column ref expressions are qualified with the table name\n+\t\t// we need to remove them to reproduce the original query\n+\t\tRemoveTableQualificationRecursive(copy, table);\n+\t\tbool add_parenthesis = true;\n+\t\tif (copy->type == ExpressionType::COLUMN_REF) {\n+\t\t\tauto &column_ref = copy->Cast<ColumnRefExpression>();\n+\t\t\tif (!column_ref.IsQualified()) {\n+\t\t\t\t// Only when column references are not qualified, i.e (col1, col2)\n+\t\t\t\t// then these expressions do not need to be wrapped in parenthesis\n+\t\t\t\tadd_parenthesis = false;\n+\t\t\t}\n+\t\t}\n+\t\tif (add_parenthesis) {\n+\t\t\tlist.push_back(StringUtil::Format(\"(%s)\", copy->ToString()));\n+\t\t} else {\n+\t\t\tlist.push_back(StringUtil::Format(\"%s\", copy->ToString()));\n+\t\t}\n+\t}\n+\treturn list;\n+}\n+\n+string CreateIndexInfo::ExpressionsToString() const {\n+\tauto list = ExpressionsToList();\n+\treturn StringUtil::Join(list, \", \");\n+}\n+\n string CreateIndexInfo::ToString() const {\n \tstring result;\n \n@@ -48,30 +80,7 @@ string CreateIndexInfo::ToString() const {\n \t\tresult += \" \";\n \t}\n \tresult += \"(\";\n-\tfor (idx_t i = 0; i < parsed_expressions.size(); i++) {\n-\t\tauto &expr = parsed_expressions[i];\n-\t\tauto copy = expr->Copy();\n-\t\tif (i > 0) {\n-\t\t\tresult += \", \";\n-\t\t}\n-\t\t// column ref expressions are qualified with the table name\n-\t\t// we need to remove them to reproduce the original query\n-\t\tRemoveTableQualificationRecursive(copy, table);\n-\t\tbool add_parenthesis = true;\n-\t\tif (copy->type == ExpressionType::COLUMN_REF) {\n-\t\t\tauto &column_ref = copy->Cast<ColumnRefExpression>();\n-\t\t\tif (!column_ref.IsQualified()) {\n-\t\t\t\t// Only when column references are not qualified, i.e (col1, col2)\n-\t\t\t\t// then these expressions do not need to be wrapped in parenthesis\n-\t\t\t\tadd_parenthesis = false;\n-\t\t\t}\n-\t\t}\n-\t\tif (add_parenthesis) {\n-\t\t\tresult += StringUtil::Format(\"(%s)\", copy->ToString());\n-\t\t} else {\n-\t\t\tresult += StringUtil::Format(\"%s\", copy->ToString());\n-\t\t}\n-\t}\n+\tresult += ExpressionsToString();\n \tresult += \")\";\n \tif (!options.empty()) {\n \t\tresult += \" WITH (\";\n",
  "test_patch": "diff --git a/test/sql/table_function/duckdb_indexes.test b/test/sql/table_function/duckdb_indexes.test\nindex afe941a13bbc..c739fd149978 100644\n--- a/test/sql/table_function/duckdb_indexes.test\n+++ b/test/sql/table_function/duckdb_indexes.test\n@@ -13,3 +13,8 @@ SELECT * FROM duckdb_indexes();\n \n statement ok nosort duckdb_col\n SELECT * FROM duckdb_indexes;\n+\n+query I\n+select expressions from duckdb_indexes where table_name = 'integers';\n+----\n+[((j + 1)), k]\n",
  "problem_statement": "Fields for indexes are not present anywhere  in metadata/information schema\n### What happens?\n\nWhen querying `duckdb_indexes()` the fields belonging to the index are not present.\r\n\r\nAccording to this link: https://discord.com/channels/909674491309850675/921073327009853451/1273234124177408051\r\nThe fields should be present under `expressions` but is not.\r\n\r\n\n\n### To Reproduce\n\n```\r\ncreate table test_index (id integer primary key, name varchar, age tinyint, class int);\r\n\r\nCREATE UNIQUE INDEX test_idx ON test_index (name, age, class);\r\n\r\nselect * from duckdb_indexes() WHERE table_name ='test_index' ;\r\n```\n\n### OS:\n\nMacOS Sonoma\n\n### DuckDB Version:\n\nv1.0.0 1f98600c2c\n\n### DuckDB Client:\n\nCommand Line\n\n### Full Name:\n\nYuv\n\n### Affiliation:\n\nN/A\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "At the time of creation of `duckdb_indexes` the IndexCatalogEntry was very minimal:\r\n```c++\r\nclass IndexCatalogEntry : public StandardEntry {\r\npublic:\r\n\t//! Create a real TableCatalogEntry and initialize storage for it\r\n\tIndexCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schema, CreateIndexInfo *info);\r\n\t~IndexCatalogEntry() override;\r\n\r\n\tIndex *index;\r\n\tshared_ptr<DataTableInfo> info;\r\n\tstring sql;\r\n\r\npublic:\r\n\tstring ToSQL() override;\r\n};\r\n```\r\n\r\nI think that's the reason \"expressions\" was left blank at the time\r\nThe PR that introduces this: <https://github.com/duckdb/duckdb/pull/1847> (2021) also likely predates the existence of the LIST type, which would be more suitable for \"expressions\" nowadays\r\n\nCompared to what the IndexCatalogEntry looks like nowadays:\r\n```c++\r\nclass IndexCatalogEntry : public StandardEntry {\r\npublic:\r\n\tstatic constexpr const CatalogType Type = CatalogType::INDEX_ENTRY;\r\n\tstatic constexpr const char *Name = \"index\";\r\n\r\npublic:\r\n\t//! Create an IndexCatalogEntry\r\n\tIndexCatalogEntry(Catalog &catalog, SchemaCatalogEntry &schema, CreateIndexInfo &info);\r\n\r\n\t//! The SQL of the CREATE INDEX statement\r\n\tstring sql;\r\n\t//! Additional index options\r\n\tcase_insensitive_map_t<Value> options;\r\n\r\n\t//! The index type (ART, B+-tree, Skip-List, ...)\r\n\tstring index_type;\r\n\t//! The index constraint type\r\n\tIndexConstraintType index_constraint_type;\r\n\t//! The column ids of the indexed table\r\n\tvector<column_t> column_ids;\r\n\t//! The set of expressions to index by\r\n\tvector<unique_ptr<ParsedExpression>> expressions;\r\n\tvector<unique_ptr<ParsedExpression>> parsed_expressions;\r\n\r\npublic:\r\n\t//! Returns the CreateIndexInfo\r\n\tunique_ptr<CreateInfo> GetInfo() const override;\r\n\t//! Returns the original CREATE INDEX SQL\r\n\tstring ToSQL() const override;\r\n\r\n\tvirtual string GetSchemaName() const = 0;\r\n\tvirtual string GetTableName() const = 0;\r\n\r\n\t//! Returns true, if this index is UNIQUE\r\n\tbool IsUnique() const;\r\n\t//! Returns true, if this index is a PRIMARY KEY\r\n\tbool IsPrimary() const;\r\n};\r\n```",
  "created_at": "2024-08-14T13:18:08Z"
}