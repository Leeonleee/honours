{
  "repo": "duckdb/duckdb",
  "pull_number": 6552,
  "instance_id": "duckdb__duckdb-6552",
  "issue_numbers": [
    "6541"
  ],
  "base_commit": "0e959820c53bb072b290b984db1a54c2c14208b9",
  "patch": "diff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp\nindex d76191d75161..29582d0604e3 100644\n--- a/src/common/types/vector.cpp\n+++ b/src/common/types/vector.cpp\n@@ -1601,122 +1601,6 @@ void ListVector::Reserve(Vector &vector, idx_t required_capacity) {\n \tchild_buffer.Reserve(required_capacity);\n }\n \n-template <class T>\n-void TemplatedSearchInMap(Vector &keys, idx_t count, T key, vector<idx_t> &offsets, bool is_key_null, idx_t offset,\n-                          idx_t length) {\n-\tUnifiedVectorFormat vector_data;\n-\tkeys.ToUnifiedFormat(count, vector_data);\n-\tauto data = (T *)vector_data.data;\n-\tauto validity_mask = vector_data.validity;\n-\n-\tif (is_key_null) {\n-\t\tfor (idx_t i = offset; i < offset + length; i++) {\n-\t\t\tif (!validity_mask.RowIsValid(i)) {\n-\t\t\t\toffsets.push_back(i);\n-\t\t\t}\n-\t\t}\n-\t} else {\n-\t\tfor (idx_t i = offset; i < offset + length; i++) {\n-\t\t\tif (!validity_mask.RowIsValid(i)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tif (key == data[i]) {\n-\t\t\t\toffsets.push_back(i);\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-template <class T>\n-void TemplatedSearchInMap(Vector &keys, idx_t count, const Value &key, vector<idx_t> &offsets, bool is_key_null,\n-                          idx_t offset, idx_t length) {\n-\tTemplatedSearchInMap<T>(keys, count, key.template GetValueUnsafe<T>(), offsets, is_key_null, offset, length);\n-}\n-\n-void SearchStringInMap(Vector &keys, idx_t count, const string &key, vector<idx_t> &offsets, bool is_key_null,\n-                       idx_t offset, idx_t length) {\n-\tUnifiedVectorFormat vector_data;\n-\tkeys.ToUnifiedFormat(count, vector_data);\n-\tauto data = (string_t *)vector_data.data;\n-\tauto validity_mask = vector_data.validity;\n-\tif (is_key_null) {\n-\t\tfor (idx_t i = offset; i < offset + length; i++) {\n-\t\t\tif (!validity_mask.RowIsValid(i)) {\n-\t\t\t\toffsets.push_back(i);\n-\t\t\t}\n-\t\t}\n-\t} else {\n-\t\tstring_t key_str_t(key);\n-\t\tfor (idx_t i = offset; i < offset + length; i++) {\n-\t\t\tif (!validity_mask.RowIsValid(i)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tif (Equals::Operation<string_t>(data[i], key_str_t)) {\n-\t\t\t\toffsets.push_back(i);\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-vector<idx_t> MapVector::Search(Vector &keys, idx_t count, const Value &key, list_entry_t &entry) {\n-\tvector<idx_t> offsets;\n-\n-\tswitch (keys.GetType().InternalType()) {\n-\tcase PhysicalType::BOOL:\n-\tcase PhysicalType::INT8:\n-\t\tTemplatedSearchInMap<int8_t>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::INT16:\n-\t\tTemplatedSearchInMap<int16_t>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::INT32:\n-\t\tTemplatedSearchInMap<int32_t>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::INT64:\n-\t\tTemplatedSearchInMap<int64_t>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::INT128:\n-\t\tTemplatedSearchInMap<hugeint_t>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::UINT8:\n-\t\tTemplatedSearchInMap<uint8_t>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::UINT16:\n-\t\tTemplatedSearchInMap<uint16_t>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::UINT32:\n-\t\tTemplatedSearchInMap<uint32_t>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::UINT64:\n-\t\tTemplatedSearchInMap<uint64_t>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::FLOAT:\n-\t\tTemplatedSearchInMap<float>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::DOUBLE:\n-\t\tTemplatedSearchInMap<double>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::INTERVAL:\n-\t\tTemplatedSearchInMap<interval_t>(keys, count, key, offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tcase PhysicalType::VARCHAR:\n-\t\tSearchStringInMap(keys, count, StringValue::Get(key), offsets, key.IsNull(), entry.offset, entry.length);\n-\t\tbreak;\n-\tdefault:\n-\t\tthrow InvalidTypeException(keys.GetType().id(), \"Invalid type for List Vector Search\");\n-\t}\n-\treturn offsets;\n-}\n-\n-Value FlatVector::GetValuesFromOffsets(Vector &values, vector<idx_t> &offsets) {\n-\tvector<Value> list_values;\n-\tlist_values.reserve(offsets.size());\n-\tfor (auto &offset : offsets) {\n-\t\tlist_values.push_back(values.GetValue(offset));\n-\t}\n-\treturn Value::LIST(values.GetType(), std::move(list_values));\n-}\n-\n idx_t ListVector::GetListSize(const Vector &vec) {\n \tif (vec.GetVectorType() == VectorType::DICTIONARY_VECTOR) {\n \t\tauto &child = DictionaryVector::Child(vec);\ndiff --git a/src/function/scalar/list/contains_or_position.cpp b/src/function/scalar/list/contains_or_position.cpp\nindex c1ee428f59df..18538bbc8986 100644\n--- a/src/function/scalar/list/contains_or_position.cpp\n+++ b/src/function/scalar/list/contains_or_position.cpp\n@@ -5,156 +5,14 @@\n \n namespace duckdb {\n \n-struct ContainsFunctor {\n-\tstatic inline bool Initialize() {\n-\t\treturn false;\n-\t}\n-\tstatic inline bool UpdateResultEntries(idx_t child_idx) {\n-\t\treturn true;\n-\t}\n-};\n-\n-struct PositionFunctor {\n-\tstatic inline int32_t Initialize() {\n-\t\treturn 0;\n-\t}\n-\tstatic inline int32_t UpdateResultEntries(idx_t child_idx) {\n-\t\treturn child_idx + 1;\n-\t}\n-};\n-\n-template <class CHILD_TYPE, class RETURN_TYPE, class OP>\n-static void TemplatedContainsOrPosition(DataChunk &args, ExpressionState &state, Vector &result,\n-                                        bool is_nested = false) {\n-\tD_ASSERT(args.ColumnCount() == 2);\n-\tauto count = args.size();\n-\tVector &list = args.data[0];\n-\tVector &value_vector = args.data[1];\n-\n-\t// Create a result vector of type RETURN_TYPE\n-\tresult.SetVectorType(VectorType::FLAT_VECTOR);\n-\tauto result_entries = FlatVector::GetData<RETURN_TYPE>(result);\n-\tauto &result_validity = FlatVector::Validity(result);\n-\n-\tif (list.GetType().id() == LogicalTypeId::SQLNULL) {\n-\t\tresult_validity.SetInvalid(0);\n-\t\treturn;\n-\t}\n-\n-\tauto list_size = ListVector::GetListSize(list);\n-\tauto &child_vector = ListVector::GetEntry(list);\n-\n-\tUnifiedVectorFormat child_data;\n-\tchild_vector.ToUnifiedFormat(list_size, child_data);\n-\n-\tUnifiedVectorFormat list_data;\n-\tlist.ToUnifiedFormat(count, list_data);\n-\tauto list_entries = (list_entry_t *)list_data.data;\n-\n-\tUnifiedVectorFormat value_data;\n-\tvalue_vector.ToUnifiedFormat(count, value_data);\n-\n-\t// not required for a comparison of nested types\n-\tauto child_value = (CHILD_TYPE *)child_data.data;\n-\tauto values = (CHILD_TYPE *)value_data.data;\n-\n-\tfor (idx_t i = 0; i < count; i++) {\n-\t\tauto list_index = list_data.sel->get_index(i);\n-\t\tauto value_index = value_data.sel->get_index(i);\n-\n-\t\tif (!list_data.validity.RowIsValid(list_index) || !value_data.validity.RowIsValid(value_index)) {\n-\t\t\tresult_validity.SetInvalid(i);\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tconst auto &list_entry = list_entries[list_index];\n-\n-\t\tresult_entries[i] = OP::Initialize();\n-\t\tfor (idx_t child_idx = 0; child_idx < list_entry.length; child_idx++) {\n-\n-\t\t\tauto child_value_idx = child_data.sel->get_index(list_entry.offset + child_idx);\n-\t\t\tif (!child_data.validity.RowIsValid(child_value_idx)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tif (!is_nested) {\n-\t\t\t\tif (Equals::Operation(child_value[child_value_idx], values[value_index])) {\n-\t\t\t\t\tresult_entries[i] = OP::UpdateResultEntries(child_idx);\n-\t\t\t\t\tbreak; // Found value in list, no need to look further\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// FIXME: using Value is less efficient than modifying the vector comparison code\n-\t\t\t\t// to more efficiently compare nested types\n-\t\t\t\tauto lvalue = child_vector.GetValue(child_value_idx);\n-\t\t\t\tauto rvalue = value_vector.GetValue(value_index);\n-\t\t\t\tif (Value::NotDistinctFrom(lvalue, rvalue)) {\n-\t\t\t\t\tresult_entries[i] = OP::UpdateResultEntries(child_idx);\n-\t\t\t\t\tbreak; // Found value in list, no need to look further\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif (args.AllConstant()) {\n-\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n-\t}\n-}\n-\n-template <class T, class OP>\n-static void ListContainsOrPosition(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tswitch (args.data[1].GetType().InternalType()) {\n-\tcase PhysicalType::BOOL:\n-\tcase PhysicalType::INT8:\n-\t\tTemplatedContainsOrPosition<int8_t, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::INT16:\n-\t\tTemplatedContainsOrPosition<int16_t, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::INT32:\n-\t\tTemplatedContainsOrPosition<int32_t, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::INT64:\n-\t\tTemplatedContainsOrPosition<int64_t, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::INT128:\n-\t\tTemplatedContainsOrPosition<hugeint_t, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::UINT8:\n-\t\tTemplatedContainsOrPosition<uint8_t, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::UINT16:\n-\t\tTemplatedContainsOrPosition<uint16_t, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::UINT32:\n-\t\tTemplatedContainsOrPosition<uint32_t, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::UINT64:\n-\t\tTemplatedContainsOrPosition<uint64_t, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::FLOAT:\n-\t\tTemplatedContainsOrPosition<float, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::DOUBLE:\n-\t\tTemplatedContainsOrPosition<double, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::VARCHAR:\n-\t\tTemplatedContainsOrPosition<string_t, T, OP>(args, state, result);\n-\t\tbreak;\n-\tcase PhysicalType::STRUCT:\n-\tcase PhysicalType::LIST:\n-\t\tTemplatedContainsOrPosition<int8_t, T, OP>(args, state, result, true);\n-\t\tbreak;\n-\tdefault:\n-\t\tthrow NotImplementedException(\"This function has not been implemented for this type\");\n-\t}\n-}\n-\n static void ListContainsFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\treturn ListContainsOrPosition<bool, ContainsFunctor>(args, state, result);\n+\t(void)state;\n+\treturn ListContainsOrPosition<bool, ContainsFunctor, ListArgFunctor>(args, result);\n }\n \n static void ListPositionFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\treturn ListContainsOrPosition<int32_t, PositionFunctor>(args, state, result);\n+\t(void)state;\n+\treturn ListContainsOrPosition<int32_t, PositionFunctor, ListArgFunctor>(args, result);\n }\n \n template <LogicalTypeId RETURN_TYPE>\ndiff --git a/src/function/scalar/map/map.cpp b/src/function/scalar/map/map.cpp\nindex 2b69a24d4b3e..28cf75fd8be8 100644\n--- a/src/function/scalar/map/map.cpp\n+++ b/src/function/scalar/map/map.cpp\n@@ -98,6 +98,52 @@ static void AlignVectorToReference(const Vector &original, const Vector &referen\n \tresult.Reference(expanded_const);\n }\n \n+static bool ListEntriesEqual(Vector &keys, Vector &values, idx_t count) {\n+\tauto key_count = ListVector::GetListSize(keys);\n+\tauto value_count = ListVector::GetListSize(values);\n+\tbool same_vector_type = keys.GetVectorType() == values.GetVectorType();\n+\n+\tD_ASSERT(keys.GetType().id() == LogicalTypeId::LIST);\n+\tD_ASSERT(values.GetType().id() == LogicalTypeId::LIST);\n+\n+\tUnifiedVectorFormat keys_data;\n+\tUnifiedVectorFormat values_data;\n+\n+\tkeys.ToUnifiedFormat(count, keys_data);\n+\tvalues.ToUnifiedFormat(count, values_data);\n+\n+\tauto keys_entries = (list_entry_t *)keys_data.data;\n+\tauto values_entries = (list_entry_t *)values_data.data;\n+\n+\tif (same_vector_type) {\n+\t\tconst auto key_data = keys_data.data;\n+\t\tconst auto value_data = values_data.data;\n+\n+\t\tif (keys.GetVectorType() == VectorType::CONSTANT_VECTOR) {\n+\t\t\tD_ASSERT(values.GetVectorType() == VectorType::CONSTANT_VECTOR);\n+\t\t\t// Only need to compare one entry in this case\n+\t\t\treturn memcmp(key_data, value_data, sizeof(list_entry_t)) == 0;\n+\t\t}\n+\n+\t\t// Fast path if the vector types are equal, can just check if the entries are the same\n+\t\tif (key_count != value_count) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn memcmp(key_data, value_data, count * sizeof(list_entry_t)) == 0;\n+\t}\n+\n+\t// Compare the list_entries one by one\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tauto keys_idx = keys_data.sel->get_index(i);\n+\t\tauto values_idx = values_data.sel->get_index(i);\n+\n+\t\tif (keys_entries[keys_idx] != values_entries[values_idx]) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\treturn true;\n+}\n+\n static void MapFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tD_ASSERT(result.GetType().id() == LogicalTypeId::MAP);\n \n@@ -132,7 +178,7 @@ static void MapFunction(DataChunk &args, ExpressionState &state, Vector &result)\n \t} else if (values_are_const && !keys_are_const) {\n \t\tAlignVectorToReference(args.data[1], args.data[0], args.size(), value_vector);\n \t} else {\n-\t\tif (key_count != value_count || memcmp(key_data, value_data, args.size() * sizeof(list_entry_t)) != 0) {\n+\t\tif (!ListEntriesEqual(args.data[0], args.data[1], args.size())) {\n \t\t\tthrow InvalidInputException(\"Error in MAP creation: key list and value list do not align. i.e. different \"\n \t\t\t                            \"size or incompatible structure\");\n \t\t}\ndiff --git a/src/function/scalar/map/map_extract.cpp b/src/function/scalar/map/map_extract.cpp\nindex 305b375883b3..f9bb6c6414fa 100644\n--- a/src/function/scalar/map/map_extract.cpp\n+++ b/src/function/scalar/map/map_extract.cpp\n@@ -5,19 +5,55 @@\n #include \"duckdb/common/types/data_chunk.hpp\"\n \n namespace duckdb {\n-void FillResult(Value &values, Vector &result, idx_t row) {\n-\t//! First Initialize List Vector\n-\tidx_t current_offset = ListVector::GetListSize(result);\n-\t//! Push Values to List Vector\n-\tauto &list_values = ListValue::GetChildren(values);\n-\tfor (idx_t i = 0; i < list_values.size(); i++) {\n-\t\tListVector::PushBack(result, list_values[i]);\n+void FillResult(Vector &map, Vector &offsets, Vector &result, idx_t count) {\n+\tUnifiedVectorFormat map_data;\n+\tmap.ToUnifiedFormat(count, map_data);\n+\n+\tUnifiedVectorFormat offset_data;\n+\toffsets.ToUnifiedFormat(count, offset_data);\n+\n+\tUnifiedVectorFormat result_data;\n+\tresult.ToUnifiedFormat(count, result_data);\n+\n+\tauto entry_count = ListVector::GetListSize(map);\n+\tauto &values_entries = MapVector::GetValues(map);\n+\tUnifiedVectorFormat values_entry_data;\n+\t// Note: this vector can have a different size than the map\n+\tvalues_entries.ToUnifiedFormat(entry_count, values_entry_data);\n+\n+\tfor (idx_t row = 0; row < count; row++) {\n+\t\tidx_t offset_idx = offset_data.sel->get_index(row);\n+\t\tauto offset = ((int32_t *)offset_data.data)[offset_idx];\n+\n+\t\t// Get the current size of the list, for the offset\n+\t\tidx_t current_offset = ListVector::GetListSize(result);\n+\t\tif (!offset_data.validity.RowIsValid(offset_idx) || !offset) {\n+\t\t\t// Set the entry data for this result row\n+\t\t\tidx_t result_index = result_data.sel->get_index(row);\n+\t\t\tauto &entry = ((list_entry_t *)result_data.data)[result_index];\n+\t\t\tentry.length = 0;\n+\t\t\tentry.offset = current_offset;\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// All list indices start at 1, reduce by 1 to get the actual index\n+\t\toffset--;\n+\n+\t\t// Get the 'values' list entry corresponding to the offset\n+\t\tidx_t value_index = map_data.sel->get_index(row);\n+\t\tauto &value_list_entry = ((list_entry_t *)map_data.data)[value_index];\n+\n+\t\t// Add the values to the result\n+\t\tidx_t list_offset = value_list_entry.offset + offset;\n+\t\t// All keys are unique, only one will ever match\n+\t\tidx_t length = 1;\n+\t\tListVector::Append(result, values_entries, length + list_offset, list_offset);\n+\n+\t\t// Set the entry data for this result row\n+\t\tidx_t result_index = result_data.sel->get_index(row);\n+\t\tauto &entry = ((list_entry_t *)result_data.data)[result_index];\n+\t\tentry.length = length;\n+\t\tentry.offset = current_offset;\n \t}\n-\n-\t//! now set the pointer\n-\tauto &entry = ListVector::GetData(result)[row];\n-\tentry.length = list_values.size();\n-\tentry.offset = current_offset;\n }\n \n static void MapExtractFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n@@ -25,6 +61,8 @@ static void MapExtractFunction(DataChunk &args, ExpressionState &state, Vector &\n \tD_ASSERT(args.data[0].GetType().id() == LogicalTypeId::MAP);\n \tresult.SetVectorType(VectorType::FLAT_VECTOR);\n \n+\tidx_t tuple_count = args.size();\n+\t// Optimization: because keys are not allowed to be NULL, we can early-out\n \tif (args.data[1].GetType().id() == LogicalTypeId::SQLNULL) {\n \t\t//! We don't need to look through the map if the 'key' to look for is NULL\n \t\tListVector::SetListSize(result, 0);\n@@ -32,7 +70,7 @@ static void MapExtractFunction(DataChunk &args, ExpressionState &state, Vector &\n \t\tauto list_data = ConstantVector::GetData<list_entry_t>(result);\n \t\tlist_data->offset = 0;\n \t\tlist_data->length = 0;\n-\t\tresult.Verify(args.size());\n+\t\tresult.Verify(tuple_count);\n \t\treturn;\n \t}\n \n@@ -41,26 +79,30 @@ static void MapExtractFunction(DataChunk &args, ExpressionState &state, Vector &\n \n \tUnifiedVectorFormat map_data;\n \n-\tauto &map_keys = MapVector::GetKeys(map);\n-\tauto &map_values = MapVector::GetValues(map);\n+\t// Create the chunk we'll feed to ListPosition\n+\tDataChunk list_position_chunk;\n+\tvector<LogicalType> chunk_types;\n+\tchunk_types.reserve(2);\n+\tchunk_types.push_back(map.GetType());\n+\tchunk_types.push_back(key.GetType());\n+\tlist_position_chunk.InitializeEmpty(chunk_types.begin(), chunk_types.end());\n \n-\tmap.ToUnifiedFormat(args.size(), map_data);\n+\t// Populate it with the map keys list and the key vector\n+\tlist_position_chunk.data[0].Reference(map);\n+\tlist_position_chunk.data[1].Reference(key);\n+\tlist_position_chunk.SetCardinality(tuple_count);\n \n-\tfor (idx_t row = 0; row < args.size(); row++) {\n-\t\tidx_t row_index = map_data.sel->get_index(row);\n-\t\tauto key_value = key.GetValue(row);\n+\tVector position_vector(LogicalType::LIST(LogicalType::INTEGER), tuple_count);\n+\t// We can pass around state as it's not used by ListPositionFunction anyways\n+\tListContainsOrPosition<int32_t, PositionFunctor, MapKeyArgFunctor>(list_position_chunk, position_vector);\n \n-\t\tlist_entry_t entry = ListVector::GetData(map)[row_index];\n-\t\tauto offsets = MapVector::Search(map_keys, args.size(), key_value, entry);\n-\t\tauto values = FlatVector::GetValuesFromOffsets(map_values, offsets);\n-\t\tFillResult(values, result, row);\n-\t}\n+\tFillResult(map, position_vector, result, tuple_count);\n \n-\tif (args.size() == 1) {\n+\tif (tuple_count == 1) {\n \t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n \t}\n \n-\tresult.Verify(args.size());\n+\tresult.Verify(tuple_count);\n }\n \n static unique_ptr<FunctionData> MapExtractBind(ClientContext &context, ScalarFunction &bound_function,\ndiff --git a/src/include/duckdb/common/types.hpp b/src/include/duckdb/common/types.hpp\nindex 2de4a0147ecd..cfbf3a0bd931 100644\n--- a/src/include/duckdb/common/types.hpp\n+++ b/src/include/duckdb/common/types.hpp\n@@ -94,6 +94,12 @@ struct list_entry_t {\n \tlist_entry_t() = default;\n \tlist_entry_t(uint64_t offset, uint64_t length) : offset(offset), length(length) {\n \t}\n+\tinline constexpr bool operator != (const list_entry_t &other) const {\n+\t\treturn !(*this == other);\n+\t}\n+\tinline constexpr bool operator == (const list_entry_t &other) const {\n+\t\treturn offset == other.offset && length == other.length;\n+\t}\n \n \tuint64_t offset;\n \tuint64_t length;\ndiff --git a/src/include/duckdb/common/types/vector.hpp b/src/include/duckdb/common/types/vector.hpp\nindex 06d10789bce1..55f11e4b43ad 100644\n--- a/src/include/duckdb/common/types/vector.hpp\n+++ b/src/include/duckdb/common/types/vector.hpp\n@@ -312,7 +312,6 @@ struct FlatVector {\n \t\treturn !vector.validity.RowIsValid(idx);\n \t}\n \tDUCKDB_API static const SelectionVector *IncrementalSelectionVector();\n-\tstatic Value GetValuesFromOffsets(Vector &values, vector<idx_t> &offsets);\n };\n \n struct ListVector {\ndiff --git a/src/include/duckdb/function/scalar/list/contains_or_position.hpp b/src/include/duckdb/function/scalar/list/contains_or_position.hpp\nnew file mode 100644\nindex 000000000000..d32c0f86a387\n--- /dev/null\n+++ b/src/include/duckdb/function/scalar/list/contains_or_position.hpp\n@@ -0,0 +1,138 @@\n+#pragma once\n+\n+namespace duckdb {\n+\n+template <class CHILD_TYPE, class RETURN_TYPE, class OP, class LIST_ACCESSOR>\n+static void TemplatedContainsOrPosition(DataChunk &args, Vector &result, bool is_nested = false) {\n+\tD_ASSERT(args.ColumnCount() == 2);\n+\tauto count = args.size();\n+\tVector &list = LIST_ACCESSOR::GetList(args.data[0]);\n+\tVector &value_vector = args.data[1];\n+\n+\t// Create a result vector of type RETURN_TYPE\n+\tresult.SetVectorType(VectorType::FLAT_VECTOR);\n+\tauto result_entries = FlatVector::GetData<RETURN_TYPE>(result);\n+\tauto &result_validity = FlatVector::Validity(result);\n+\n+\tif (list.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\tresult_validity.SetInvalid(0);\n+\t\treturn;\n+\t}\n+\n+\tauto list_size = LIST_ACCESSOR::GetListSize(list);\n+\tauto &child_vector = LIST_ACCESSOR::GetEntry(list);\n+\n+\tUnifiedVectorFormat child_data;\n+\tchild_vector.ToUnifiedFormat(list_size, child_data);\n+\n+\tUnifiedVectorFormat list_data;\n+\tlist.ToUnifiedFormat(count, list_data);\n+\tauto list_entries = (list_entry_t *)list_data.data;\n+\n+\tUnifiedVectorFormat value_data;\n+\tvalue_vector.ToUnifiedFormat(count, value_data);\n+\n+\t// not required for a comparison of nested types\n+\tauto child_value = (CHILD_TYPE *)child_data.data;\n+\tauto values = (CHILD_TYPE *)value_data.data;\n+\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tauto list_index = list_data.sel->get_index(i);\n+\t\tauto value_index = value_data.sel->get_index(i);\n+\n+\t\tif (!list_data.validity.RowIsValid(list_index) || !value_data.validity.RowIsValid(value_index)) {\n+\t\t\tresult_validity.SetInvalid(i);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tconst auto &list_entry = list_entries[list_index];\n+\n+\t\tresult_entries[i] = OP::Initialize();\n+\t\tfor (idx_t child_idx = 0; child_idx < list_entry.length; child_idx++) {\n+\n+\t\t\tauto child_value_idx = child_data.sel->get_index(list_entry.offset + child_idx);\n+\t\t\tif (!child_data.validity.RowIsValid(child_value_idx)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tif (!is_nested) {\n+\t\t\t\tif (Equals::Operation(child_value[child_value_idx], values[value_index])) {\n+\t\t\t\t\tresult_entries[i] = OP::UpdateResultEntries(child_idx);\n+\t\t\t\t\tbreak; // Found value in list, no need to look further\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// FIXME: using Value is less efficient than modifying the vector comparison code\n+\t\t\t\t// to more efficiently compare nested types\n+\n+\t\t\t\t// Note: When using GetValue we don't first apply the selection vector\n+\t\t\t\t// because it is already done inside GetValue\n+\t\t\t\tauto lvalue = child_vector.GetValue(list_entry.offset + child_idx);\n+\t\t\t\tauto rvalue = value_vector.GetValue(i);\n+\t\t\t\tif (Value::NotDistinctFrom(lvalue, rvalue)) {\n+\t\t\t\t\tresult_entries[i] = OP::UpdateResultEntries(child_idx);\n+\t\t\t\t\tbreak; // Found value in list, no need to look further\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (args.AllConstant()) {\n+\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\t}\n+}\n+\n+template <class T, class OP, class LIST_ACCESSOR>\n+void ListContainsOrPosition(DataChunk &args, Vector &result) {\n+\tconst auto physical_type = args.data[1].GetType().InternalType();\n+\tswitch (physical_type) {\n+\tcase PhysicalType::BOOL:\n+\tcase PhysicalType::INT8:\n+\t\tTemplatedContainsOrPosition<int8_t, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT16:\n+\t\tTemplatedContainsOrPosition<int16_t, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT32:\n+\t\tTemplatedContainsOrPosition<int32_t, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT64:\n+\t\tTemplatedContainsOrPosition<int64_t, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT128:\n+\t\tTemplatedContainsOrPosition<hugeint_t, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT8:\n+\t\tTemplatedContainsOrPosition<uint8_t, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT16:\n+\t\tTemplatedContainsOrPosition<uint16_t, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT32:\n+\t\tTemplatedContainsOrPosition<uint32_t, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT64:\n+\t\tTemplatedContainsOrPosition<uint64_t, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::FLOAT:\n+\t\tTemplatedContainsOrPosition<float, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::DOUBLE:\n+\t\tTemplatedContainsOrPosition<double, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::VARCHAR:\n+\t\tTemplatedContainsOrPosition<string_t, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::INTERVAL:\n+\t\tTemplatedContainsOrPosition<interval_t, T, OP, LIST_ACCESSOR>(args, result);\n+\t\tbreak;\n+\tcase PhysicalType::STRUCT:\n+\tcase PhysicalType::LIST:\n+\t\tTemplatedContainsOrPosition<int8_t, T, OP, LIST_ACCESSOR>(args, result, true);\n+\t\tbreak;\n+\tdefault:\n+\t\tthrow NotImplementedException(\"This function has not been implemented for physical type %s\",\n+\t\t                              TypeIdToString(physical_type));\n+\t}\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/function/scalar/nested_functions.hpp b/src/include/duckdb/function/scalar/nested_functions.hpp\nindex 29bb3a6a73cf..64810ff2931c 100644\n--- a/src/include/duckdb/function/scalar/nested_functions.hpp\n+++ b/src/include/duckdb/function/scalar/nested_functions.hpp\n@@ -14,12 +14,59 @@\n #include \"duckdb/common/unordered_map.hpp\"\n #include \"duckdb/common/field_writer.hpp\"\n #include \"duckdb/function/built_in_functions.hpp\"\n+#include \"duckdb/function/scalar/list/contains_or_position.hpp\"\n \n namespace duckdb {\n \n enum class MapInvalidReason : uint8_t { VALID, NULL_KEY_LIST, NULL_KEY, DUPLICATE_KEY };\n enum class UnionInvalidReason : uint8_t { VALID, TAG_OUT_OF_RANGE, NO_MEMBERS, VALIDITY_OVERLAP };\n \n+struct ListArgFunctor {\n+\tstatic Vector &GetList(Vector &list) {\n+\t\treturn list;\n+\t}\n+\tstatic idx_t GetListSize(Vector &list) {\n+\t\treturn ListVector::GetListSize(list);\n+\t}\n+\tstatic Vector &GetEntry(Vector &list) {\n+\t\treturn ListVector::GetEntry(list);\n+\t}\n+};\n+\n+struct MapKeyArgFunctor {\n+\t// MAP is a LIST(STRUCT(K,V))\n+\t// meaning the MAP itself is a List, but the child vector that we're interested in (the keys)\n+\t// are a level deeper than the initial child vector\n+\n+\tstatic Vector &GetList(Vector &map) {\n+\t\treturn map;\n+\t}\n+\tstatic idx_t GetListSize(Vector &map) {\n+\t\treturn ListVector::GetListSize(map);\n+\t}\n+\tstatic Vector &GetEntry(Vector &map) {\n+\t\treturn MapVector::GetKeys(map);\n+\t}\n+};\n+\n+struct ContainsFunctor {\n+\tstatic inline bool Initialize() {\n+\t\treturn false;\n+\t}\n+\tstatic inline bool UpdateResultEntries(idx_t child_idx) {\n+\t\treturn true;\n+\t}\n+};\n+\n+struct PositionFunctor {\n+\tstatic inline int32_t Initialize() {\n+\t\treturn 0;\n+\t}\n+\tstatic inline int32_t UpdateResultEntries(idx_t child_idx) {\n+\t\treturn child_idx + 1;\n+\t}\n+};\n+\n struct VariableReturnBindData : public FunctionData {\n \tLogicalType stype;\n \n",
  "test_patch": "diff --git a/test/sql/types/nested/map/test_map_subscript_all_types.test_slow b/test/sql/types/nested/map/test_map_subscript_all_types.test_slow\nnew file mode 100644\nindex 000000000000..c1c3528dfed7\n--- /dev/null\n+++ b/test/sql/types/nested/map/test_map_subscript_all_types.test_slow\n@@ -0,0 +1,20 @@\n+# name: test/sql/types/nested/map/test_map_subscript_all_types.test_slow\n+# description: Test cardinality function for maps\n+# group: [map]\n+\n+# Note: this is **incredibly** slow on debug\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+query I nosort all_types\n+SELECT [columns(*)]\n+FROM test_all_types()\n+WHERE bool IS NOT NULL;\n+----\n+\n+query I nosort all_types\n+SELECT map([columns(*)], [columns(*)])[columns(*)]\n+FROM test_all_types()\n+WHERE bool IS NOT NULL;\n+----\ndiff --git a/test/sql/types/nested/map/test_map_subscript_composite.test b/test/sql/types/nested/map/test_map_subscript_composite.test\nnew file mode 100644\nindex 000000000000..001f44945031\n--- /dev/null\n+++ b/test/sql/types/nested/map/test_map_subscript_composite.test\n@@ -0,0 +1,154 @@\n+# name: test/sql/types/nested/map/test_map_subscript_composite.test\n+# description: Test cardinality function for maps\n+# group: [map]\n+\n+# Single element on map\n+query I\n+select m[[2,0]] from (select MAP(LIST_VALUE([0], [1], [2,0], [3]),LIST_VALUE(10, 9, 8, 7)) as m) as T\n+----\n+[8]\n+\n+#Element not present on MAP\n+query I\n+select m[[2,3]] from (select MAP(LIST_VALUE([0], [1], [2,0], [3], [5]),LIST_VALUE(10, 9, 8, 7,11)) as m) as T\n+----\n+[]\n+\n+# Keys of a MAP can not be NULL\n+statement error\n+select m[NULL] from (select MAP(LIST_VALUE([2], [NULL], [3,0], [NULL,NULL],[5,4], NULL),LIST_VALUE(10, 9, 8, 7,11,42)) as m) as T\n+\n+# Null not present on map\n+query I\n+select m[NULL] from (select MAP(LIST_VALUE({a:3}, {b:4}, {c:5}, {d:6},{e:7}),LIST_VALUE(10, 9, 8, 7,11)) as m) as T\n+----\n+[]\n+\n+# Keys of a MAP have to be unique\n+statement error\n+select m[2] from (select MAP(LIST_VALUE([2,2], [2], [3,3], [4,4,4],[2]),LIST_VALUE(10, 9, 8, 7,11)) as m) as T\n+----\n+Invalid Input Error: Map keys have to be unique\n+\n+# Check autocast\n+query I\n+select m[[2::TINYINT,3::BIGINT]] from (select MAP(LIST_VALUE([1], [2,3], [3], [2],[3,2]),LIST_VALUE(10, 9, 8, 7,11)) as m) as T\n+----\n+[9]\n+\n+#Map with larger-than-vector-size cardinalities\n+query I\n+select m[[10,11]] from (select MAP(lst,lst) as m from (SELECT LIST([i,i+1]) as lst FROM range(10000) tbl(i)) as lst_tbl) as T\n+----\n+[[10, 11]]\n+\n+#Duplicate keys in a map\n+statement error\n+select m[[1]] from (select MAP(LIST_VALUE([1], [1], [1], [4]),LIST_VALUE(10, 9, 8, 7)) as m) as T\n+----\n+Invalid Input Error: Map keys have to be unique\n+\n+query I\n+select m[['Tenacious D', 'test']] from (select MAP(LIST_VALUE(['Jon Lajoie'], ['test', NULL], ['Tenacious D', 'test'], ['test', 'Tenacious D']),LIST_VALUE(5,10,9,11)) as m) as T\n+----\n+[9]\n+\n+query I\n+select m[['Jon Lajoie']] from (select MAP(LIST_VALUE(['Jon Lajoie'], ['Tenacious D', 'a', 'b', 'c']),LIST_VALUE(10,1)) as m) as T\n+----\n+[10]\n+\n+#Searching using a non-constant value (e.g. select m[a] from ...)\n+statement ok\n+create table ints (a integer[], b integer[])\n+\n+statement ok\n+insert into ints values ([1],[1]), ([2],[2]),([3],[3]),([4],[4])\n+\n+query I\n+select m from (select MAP(lsta,lstb) as m from (SELECT list(a) as lsta, list(b) as lstb FROM ints where a[1] < 4 and b[1] > 1) as lst_tbl) as T\n+----\n+{[2]=[2], [3]=[3]}\n+\n+query I\n+select m[[2]] from (select MAP(lsta,lstb) as m from (SELECT list(a) as lsta, list(b) as lstb FROM ints where a[1] < 4 and b[1] > 1) as lst_tbl) as T\n+----\n+[[2]]\n+\n+#What about multiple rows each with a map, instead of just a single row?\n+statement ok\n+insert into ints values ([5],[1]), ([1],[2]),([2],[3]),([6],[4])\n+\n+query I\n+select m from (select MAP(lsta,lstb) as m from (SELECT list(a) as lsta, list(b) as lstb FROM ints group by b) as lst_tbl) as T\n+----\n+{[1]=[1], [5]=[1]}\n+{[2]=[2], [1]=[2]}\n+{[3]=[3], [2]=[3]}\n+{[4]=[4], [6]=[4]}\n+\n+query I\n+select m[[1]] from (select MAP(lsta,lstb) as m from (SELECT list(a) as lsta, list(b) as lstb FROM ints group by b) as lst_tbl) as T\n+----\n+[[1]]\n+[[2]]\n+[]\n+[]\n+\n+#What about multiple rows each with a map, with a selection vector on top of them (e.g. because of a WHERE clause)?\n+statement ok\n+insert into ints values ([1],[4])\n+\n+query I\n+select m[[1]] from (select MAP(lsta,lstb) as m from (SELECT list(a) as lsta, list(b) as lstb FROM ints where b[1] <4 group by b) as lst_tbl) as T\n+----\n+[[1]]\n+[[2]]\n+[]\n+\n+#map_extract directly on a constant map (SELECT map_extract(MAP(..)), i.e. no FROM clause).\n+query I\n+SELECT map_extract(MAP(LIST_VALUE([10],[9],[12],[11],[13]),LIST_VALUE(10,9,10,11,13)),[10])\n+----\n+[10]\n+\n+#Multiple constants\n+query I\n+select m[{a:1, b:2, c:3}] from (select MAP(list_value({a:1, b:2, c:3}), list_value(2)) from range(5) tbl(i)) tbl(m);\n+----\n+[2]\n+[2]\n+[2]\n+[2]\n+[2]\n+\n+#Test dictionary vectors\n+query III\n+select grp, m, case when grp>1 then m[[0]] else list_value(null) end\n+from (select grp, MAP(lsta,lstb) as m\n+from (SELECT a%4 as grp, list([a]) as lsta, list(a) as lstb FROM range(7) tbl(a) group by grp) as lst_tbl) as T;\n+----\n+0\t{[0]=0, [4]=4}\t[NULL]\n+1\t{[1]=1, [5]=5}\t[NULL]\n+2\t{[2]=2, [6]=6}\t[]\n+3\t{[3]=3}\t[]\n+\n+# Doubly nested lists\n+query I\n+select map([3, 2, 1],\n+[\n+\t[\n+\t\t[4],\n+\t\t[4]\n+\t],\n+\t[\n+\t\t[4,3]\n+\t],\n+\t[\n+\t\t[3,3,3],\n+\t\t[2],\n+\t\t[NULL, 3, 2]\n+\t]\n+])[1]\n+----\n+[[[3, 3, 3], [2], [NULL, 3, 2]]]\ndiff --git a/test/sql/types/nested/map/test_map_subscript_vector_types.test b/test/sql/types/nested/map/test_map_subscript_vector_types.test\nnew file mode 100644\nindex 000000000000..72e69ccb9c18\n--- /dev/null\n+++ b/test/sql/types/nested/map/test_map_subscript_vector_types.test\n@@ -0,0 +1,72 @@\n+# name: test/sql/types/nested/map/test_map_subscript_vector_types.test\n+# description: Test cardinality function for maps\n+# group: [map]\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+# expected result\n+query I nosort correct\n+SELECT true as equal\n+FROM test_vector_types(NULL::INT[], false) t(c)\n+WHERE c IS NOT NULL;\n+----\n+\n+query I nosort correct\n+SELECT map([c], [c])[c] = [c] as equal\n+FROM test_vector_types(NULL::INT[], false) t(c)\n+WHERE c IS NOT NULL;\n+----\n+\n+# Filter the list for NULLs and duplicates, get the list_position of the last element\n+query I nosort expected\n+SELECT filtered, last_element, pos, true\n+from\n+(\n+\tSELECT\n+\t\tlist_distinct(c) as filtered,\n+\t\tfiltered[-1] as last_element,\n+\t\tCASE\n+\t\t\tWHEN last_element = NULL\n+\t\t\t\tTHEN 0\n+\t\t\tELSE list_position(filtered, last_element)\n+\t\tEND as pos,\n+\t\tCASE\n+\t\t\tWHEN last_element = NULL\n+\t\t\t\tTHEN []\n+\t\t\tELSE [list_position(filtered, last_element)]\n+\t\tEND as expected_result,\n+\tFROM test_vector_types(NULL::INT[], false) t(c)\n+\tWHERE c IS NOT NULL\n+);\n+----\n+\n+# Verify that the list_position result is correctly applied to the 'values' list of the MAP\n+query IIII nosort expected\n+SELECT\n+\tfiltered,\n+\tlast_element,\n+\tpos,\n+\texpected_result = result OR (result = [] AND expected_result = [NULL]) as equal\n+from\n+(\n+\tSELECT\n+\t\tlist_distinct(c) as filtered,\n+\t\tmap(filtered, range(1, len(filtered)+1)) as mymap,\n+\t\tfiltered[-1] as last_element,\n+\t\tCASE\n+\t\t\tWHEN last_element = NULL\n+\t\t\t\tTHEN 0\n+\t\t\tELSE list_position(filtered, last_element)\n+\t\tEND as pos,\n+\t\tCASE\n+\t\t\tWHEN last_element = NULL\n+\t\t\t\tTHEN []\n+\t\t\tELSE [list_position(filtered, last_element)]\n+\t\tEND as expected_result,\n+\t\tmymap[last_element] as result,\n+\tFROM test_vector_types(NULL::INT[], false) t(c)\n+\tWHERE c IS NOT NULL\n+);\n+----\n+true\n",
  "problem_statement": "Unexpected error when extracting entries from a map with nested keys\n### What happens?\r\n\r\nBuilding a map value with nested keys (lists or structs) works fine as indicated by the DuckDB documentation at  https://duckdb.org/docs/sql/data_types/map.\r\n\r\nExtracting a value from such maps yields an unexpected error, however:\r\n\r\n~~~\r\nError: Invalid type Error: Invalid Type [LIST]: Invalid type for List Vector Search\r\nError: Invalid type Error: Invalid Type [STRUCT]: Invalid type for List Vector Search\r\n~~~\r\n\r\n\r\n### To Reproduce\r\n\r\nMap with list-typed keys:\r\n\r\n~~~\r\nSELECT map_extract(map([[0,1]], ['X']), [0,1]);\r\n-- Error: Invalid type Error: Invalid Type [LIST]: Invalid type for List Vector Search\r\n~~~\r\n\r\nMap with struct-typed keys:\r\n~~~\r\nSELECT map_extract(map([(0,1)], ['X']), (0,1));\r\n-- Error: Invalid type Error: Invalid Type [STRUCT]: Invalid type for List Vector Search\r\n~~~\r\n\r\n### OS:\r\n\r\nmacOS Ventura 13.2.1\r\n\r\n### DuckDB Version:\r\n\r\nv0.7.2-dev14 c817201fa8\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nTorsten Grust\r\n\r\n### Affiliation:\r\n\r\nU T\u00fcbingen, Germany\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-03-03T13:59:54Z"
}