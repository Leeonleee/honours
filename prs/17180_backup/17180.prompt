You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
No order preservation for OR in where clause
### What happens?

https://duckdb.org/docs/stable/sql/dialect/order_preservation.html says that the prefer of results is preserved with where clauses. But this does not work when there is an `or` in the query.

### To Reproduce

```sql
CREATE TABLE tbl AS
    SELECT *
    FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c')) t(x, y);

SELECT *
FROM tbl;
```

```sql
 select * from tbl where y = 'b' or y = 'a';
```

Results in 

```
┌───────┬─────────┐
│   x   │    y    │
│ int32 │ varchar │
├───────┼─────────┤
│     2 │ b       │
│     1 │ a       │
└───────┴─────────┘
```

when it should be 

```
┌───────┬─────────┐
│   x   │    y    │
│ int32 │ varchar │
├───────┼─────────┤
│     1 │ a       │
│     2 │ b       │
└───────┴─────────┘
```

### OS:

macOS

### DuckDB Version:

v1.2.2 7c039464e4

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

Dominik Moritz

### Affiliation:

CMU

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [ ] Yes, I have
No order preservation for OR in where clause
### What happens?

https://duckdb.org/docs/stable/sql/dialect/order_preservation.html says that the prefer of results is preserved with where clauses. But this does not work when there is an `or` in the query.

### To Reproduce

```sql
CREATE TABLE tbl AS
    SELECT *
    FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c')) t(x, y);

SELECT *
FROM tbl;
```

```sql
 select * from tbl where y = 'b' or y = 'a';
```

Results in 

```
┌───────┬─────────┐
│   x   │    y    │
│ int32 │ varchar │
├───────┼─────────┤
│     2 │ b       │
│     1 │ a       │
└───────┴─────────┘
```

when it should be 

```
┌───────┬─────────┐
│   x   │    y    │
│ int32 │ varchar │
├───────┼─────────┤
│     1 │ a       │
│     2 │ b       │
└───────┴─────────┘
```

### OS:

macOS

### DuckDB Version:

v1.2.2 7c039464e4

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

Dominik Moritz

### Affiliation:

CMU

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [ ] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/stable/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/stable/clients/cli/overview) and has clients for [Python](https://duckdb.org/docs/stable/clients/python/overview), [R](https://duckdb.org/docs/stable/clients/r), [Java](https://duckdb.org/docs/stable/clients/java), [Wasm](https://duckdb.org/docs/stable/clients/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdb.org/docs/stable/clients/r#duckplyr-dplyr-api).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/stable/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/stable/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/stable/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/docs/stable/dev/building/overview) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/common/types/selection_vector.cpp]
1: #include "duckdb/common/types/selection_vector.hpp"
2: 
3: #include "duckdb/common/printer.hpp"
4: #include "duckdb/common/to_string.hpp"
5: 
6: namespace duckdb {
7: 
8: SelectionData::SelectionData(idx_t count) {
9: 	owned_data = Allocator::DefaultAllocator().Allocate(MaxValue<idx_t>(count, 1) * sizeof(sel_t));
10: #ifdef DEBUG
11: 	auto data_ptr = reinterpret_cast<sel_t *>(owned_data.get());
12: 	for (idx_t i = 0; i < count; i++) {
13: 		data_ptr[i] = std::numeric_limits<sel_t>::max();
14: 	}
15: #endif
16: }
17: 
18: // LCOV_EXCL_START
19: string SelectionVector::ToString(idx_t count) const {
20: 	string result = "Selection Vector (" + to_string(count) + ") [";
21: 	for (idx_t i = 0; i < count; i++) {
22: 		if (i != 0) {
23: 			result += ", ";
24: 		}
25: 		result += to_string(get_index(i));
26: 	}
27: 	result += "]";
28: 	return result;
29: }
30: 
31: void SelectionVector::Sort(idx_t count) {
32: 	std::sort(sel_vector, sel_vector + count);
33: }
34: 
35: void SelectionVector::Print(idx_t count) const {
36: 	Printer::Print(ToString(count));
37: }
38: // LCOV_EXCL_STOP
39: 
40: buffer_ptr<SelectionData> SelectionVector::Slice(const SelectionVector &sel, idx_t count) const {
41: 	auto data = make_buffer<SelectionData>(count);
42: 	auto result_ptr = reinterpret_cast<sel_t *>(data->owned_data.get());
43: 	// for every element, we perform result[i] = target[new[i]]
44: 	for (idx_t i = 0; i < count; i++) {
45: 		auto new_idx = sel.get_index(i);
46: 		auto idx = this->get_index(new_idx);
47: 		result_ptr[i] = UnsafeNumericCast<sel_t>(idx);
48: 	}
49: 	return data;
50: }
51: 
52: void SelectionVector::Verify(idx_t count, idx_t vector_size) const {
53: #ifdef DEBUG
54: 	D_ASSERT(vector_size >= 1);
55: 	for (idx_t i = 0; i < count; i++) {
56: 		auto index = get_index(i);
57: 		if (index >= vector_size) {
58: 			throw InternalException(
59: 			    "Provided SelectionVector is invalid, index %d points to %d, which is out of range. "
60: 			    "the valid range (0-%d)",
61: 			    i, index, vector_size - 1);
62: 		}
63: 	}
64: #endif
65: }
66: 
67: } // namespace duckdb
[end of src/common/types/selection_vector.cpp]
[start of src/execution/expression_executor/execute_conjunction.cpp]
1: #include "duckdb/common/vector_operations/vector_operations.hpp"
2: #include "duckdb/execution/expression_executor.hpp"
3: #include "duckdb/planner/expression/bound_conjunction_expression.hpp"
4: #include "duckdb/execution/adaptive_filter.hpp"
5: 
6: #include <random>
7: 
8: namespace duckdb {
9: 
10: struct ConjunctionState : public ExpressionState {
11: 	ConjunctionState(const Expression &expr, ExpressionExecutorState &root) : ExpressionState(expr, root) {
12: 		adaptive_filter = make_uniq<AdaptiveFilter>(expr);
13: 	}
14: 	unique_ptr<AdaptiveFilter> adaptive_filter;
15: };
16: 
17: unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const BoundConjunctionExpression &expr,
18:                                                                 ExpressionExecutorState &root) {
19: 	auto result = make_uniq<ConjunctionState>(expr, root);
20: 	for (auto &child : expr.children) {
21: 		result->AddChild(*child);
22: 	}
23: 
24: 	result->Finalize();
25: 	return std::move(result);
26: }
27: 
28: void ExpressionExecutor::Execute(const BoundConjunctionExpression &expr, ExpressionState *state,
29:                                  const SelectionVector *sel, idx_t count, Vector &result) {
30: 	// execute the children
31: 	state->intermediate_chunk.Reset();
32: 	for (idx_t i = 0; i < expr.children.size(); i++) {
33: 		auto &current_result = state->intermediate_chunk.data[i];
34: 		Execute(*expr.children[i], state->child_states[i].get(), sel, count, current_result);
35: 		if (i == 0) {
36: 			// move the result
37: 			result.Reference(current_result);
38: 		} else {
39: 			Vector intermediate(LogicalType::BOOLEAN);
40: 			// AND/OR together
41: 			switch (expr.GetExpressionType()) {
42: 			case ExpressionType::CONJUNCTION_AND:
43: 				VectorOperations::And(current_result, result, intermediate, count);
44: 				break;
45: 			case ExpressionType::CONJUNCTION_OR:
46: 				VectorOperations::Or(current_result, result, intermediate, count);
47: 				break;
48: 			default:
49: 				throw InternalException("Unknown conjunction type!");
50: 			}
51: 			result.Reference(intermediate);
52: 		}
53: 	}
54: }
55: 
56: idx_t ExpressionExecutor::Select(const BoundConjunctionExpression &expr, ExpressionState *state_p,
57:                                  const SelectionVector *sel, idx_t count, SelectionVector *true_sel,
58:                                  SelectionVector *false_sel) {
59: 	auto &state = state_p->Cast<ConjunctionState>();
60: 
61: 	if (expr.GetExpressionType() == ExpressionType::CONJUNCTION_AND) {
62: 		// get runtime statistics
63: 		auto filter_state = state.adaptive_filter->BeginFilter();
64: 		const SelectionVector *current_sel = sel;
65: 		idx_t current_count = count;
66: 		idx_t false_count = 0;
67: 
68: 		unique_ptr<SelectionVector> temp_true, temp_false;
69: 		if (false_sel) {
70: 			temp_false = make_uniq<SelectionVector>(STANDARD_VECTOR_SIZE);
71: 		}
72: 		if (!true_sel) {
73: 			temp_true = make_uniq<SelectionVector>(STANDARD_VECTOR_SIZE);
74: 			true_sel = temp_true.get();
75: 		}
76: 		for (idx_t i = 0; i < expr.children.size(); i++) {
77: 			idx_t tcount = Select(*expr.children[state.adaptive_filter->permutation[i]],
78: 			                      state.child_states[state.adaptive_filter->permutation[i]].get(), current_sel,
79: 			                      current_count, true_sel, temp_false.get());
80: 			idx_t fcount = current_count - tcount;
81: 			if (fcount > 0 && false_sel) {
82: 				// move failing tuples into the false_sel
83: 				// tuples passed, move them into the actual result vector
84: 				for (idx_t i = 0; i < fcount; i++) {
85: 					false_sel->set_index(false_count++, temp_false->get_index(i));
86: 				}
87: 			}
88: 			current_count = tcount;
89: 			if (current_count == 0) {
90: 				break;
91: 			}
92: 			if (current_count < count) {
93: 				// tuples were filtered out: move on to using the true_sel to only evaluate passing tuples in subsequent
94: 				// iterations
95: 				current_sel = true_sel;
96: 			}
97: 		}
98: 		// adapt runtime statistics
99: 		state.adaptive_filter->EndFilter(filter_state);
100: 		return current_count;
101: 	} else {
102: 		// get runtime statistics
103: 		auto filter_state = state.adaptive_filter->BeginFilter();
104: 
105: 		const SelectionVector *current_sel = sel;
106: 		idx_t current_count = count;
107: 		idx_t result_count = 0;
108: 
109: 		unique_ptr<SelectionVector> temp_true, temp_false;
110: 		if (true_sel) {
111: 			temp_true = make_uniq<SelectionVector>(STANDARD_VECTOR_SIZE);
112: 		}
113: 		if (!false_sel) {
114: 			temp_false = make_uniq<SelectionVector>(STANDARD_VECTOR_SIZE);
115: 			false_sel = temp_false.get();
116: 		}
117: 		for (idx_t i = 0; i < expr.children.size(); i++) {
118: 			idx_t tcount = Select(*expr.children[state.adaptive_filter->permutation[i]],
119: 			                      state.child_states[state.adaptive_filter->permutation[i]].get(), current_sel,
120: 			                      current_count, temp_true.get(), false_sel);
121: 			if (tcount > 0) {
122: 				if (true_sel) {
123: 					// tuples passed, move them into the actual result vector
124: 					for (idx_t i = 0; i < tcount; i++) {
125: 						true_sel->set_index(result_count++, temp_true->get_index(i));
126: 					}
127: 				}
128: 				// now move on to check only the non-passing tuples
129: 				current_count -= tcount;
130: 				current_sel = false_sel;
131: 			}
132: 		}
133: 		if (true_sel) {
134: 			true_sel->Sort(result_count);
135: 		}
136: 
137: 		// adapt runtime statistics
138: 		state.adaptive_filter->EndFilter(filter_state);
139: 		return result_count;
140: 	}
141: }
142: 
143: } // namespace duckdb
[end of src/execution/expression_executor/execute_conjunction.cpp]
[start of src/include/duckdb/common/types/selection_vector.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/selection_vector.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/allocator.hpp"
12: #include "duckdb/common/common.hpp"
13: #include "duckdb/common/numeric_utils.hpp"
14: #include "duckdb/common/types.hpp"
15: #include "duckdb/common/vector_size.hpp"
16: 
17: namespace duckdb {
18: class VectorBuffer;
19: 
20: struct SelectionData {
21: 	DUCKDB_API explicit SelectionData(idx_t count);
22: 
23: 	AllocatedData owned_data;
24: };
25: 
26: struct SelectionVector {
27: 	SelectionVector() : sel_vector(nullptr) {
28: 	}
29: 	explicit SelectionVector(sel_t *sel) {
30: 		Initialize(sel);
31: 	}
32: 	explicit SelectionVector(idx_t count) {
33: 		Initialize(count);
34: 	}
35: 	SelectionVector(idx_t start, idx_t count) {
36: 		Initialize(MaxValue<idx_t>(count, STANDARD_VECTOR_SIZE));
37: 		for (idx_t i = 0; i < count; i++) {
38: 			set_index(i, start + i);
39: 		}
40: 	}
41: 	SelectionVector(const SelectionVector &sel_vector) {
42: 		Initialize(sel_vector);
43: 	}
44: 	explicit SelectionVector(buffer_ptr<SelectionData> data) {
45: 		Initialize(std::move(data));
46: 	}
47: 	SelectionVector &operator=(SelectionVector &&other) noexcept {
48: 		sel_vector = other.sel_vector;
49: 		other.sel_vector = nullptr;
50: 		selection_data = std::move(other.selection_data);
51: 		return *this;
52: 	}
53: 
54: public:
55: 	static idx_t Inverted(const SelectionVector &src, SelectionVector &dst, idx_t source_size, idx_t count) {
56: 		idx_t src_idx = 0;
57: 		idx_t dst_idx = 0;
58: 		for (idx_t i = 0; i < count; i++) {
59: 			if (src_idx < source_size && src.get_index(src_idx) == i) {
60: 				src_idx++;
61: 				// This index is selected by 'src', skip it in 'dst'
62: 				continue;
63: 			}
64: 			// This index does not exist in 'src', add it to the selection of 'dst'
65: 			dst.set_index(dst_idx++, i);
66: 		}
67: 		return dst_idx;
68: 	}
69: 
70: 	void Initialize(sel_t *sel) {
71: 		selection_data.reset();
72: 		sel_vector = sel;
73: 	}
74: 	void Initialize(idx_t count = STANDARD_VECTOR_SIZE) {
75: 		selection_data = make_shared_ptr<SelectionData>(count);
76: 		sel_vector = reinterpret_cast<sel_t *>(selection_data->owned_data.get());
77: 	}
78: 	void Initialize(buffer_ptr<SelectionData> data) {
79: 		selection_data = std::move(data);
80: 		sel_vector = reinterpret_cast<sel_t *>(selection_data->owned_data.get());
81: 	}
82: 	void Initialize(const SelectionVector &other) {
83: 		selection_data = other.selection_data;
84: 		sel_vector = other.sel_vector;
85: 	}
86: 
87: 	inline void set_index(idx_t idx, idx_t loc) { // NOLINT: allow casing for legacy reasons
88: 		sel_vector[idx] = UnsafeNumericCast<sel_t>(loc);
89: 	}
90: 	inline void swap(idx_t i, idx_t j) { // NOLINT: allow casing for legacy reasons
91: 		sel_t tmp = sel_vector[i];
92: 		sel_vector[i] = sel_vector[j];
93: 		sel_vector[j] = tmp;
94: 	}
95: 	inline idx_t get_index(idx_t idx) const { // NOLINT: allow casing for legacy reasons
96: 		return sel_vector ? sel_vector[idx] : idx;
97: 	}
98: 	sel_t *data() { // NOLINT: allow casing for legacy reasons
99: 		return sel_vector;
100: 	}
101: 	const sel_t *data() const { // NOLINT: allow casing for legacy reasons
102: 		return sel_vector;
103: 	}
104: 	buffer_ptr<SelectionData> sel_data() { // NOLINT: allow casing for legacy reasons
105: 		return selection_data;
106: 	}
107: 	buffer_ptr<SelectionData> Slice(const SelectionVector &sel, idx_t count) const;
108: 
109: 	string ToString(idx_t count = 0) const;
110: 	void Print(idx_t count = 0) const;
111: 
112: 	inline sel_t &operator[](idx_t index) const {
113: 		return sel_vector[index];
114: 	}
115: 	inline bool IsSet() const {
116: 		return sel_vector;
117: 	}
118: 	void Verify(idx_t count, idx_t vector_size) const;
119: 	void Sort(idx_t count);
120: 
121: private:
122: 	sel_t *sel_vector;
123: 	buffer_ptr<SelectionData> selection_data;
124: };
125: 
126: class OptionalSelection {
127: public:
128: 	explicit OptionalSelection(SelectionVector *sel_p) {
129: 		Initialize(sel_p);
130: 	}
131: 	void Initialize(SelectionVector *sel_p) {
132: 		sel = sel_p;
133: 		if (sel) {
134: 			vec.Initialize(sel->data());
135: 			sel = &vec;
136: 		}
137: 	}
138: 
139: 	inline operator SelectionVector *() { // NOLINT: allow implicit conversion to SelectionVector
140: 		return sel;
141: 	}
142: 
143: 	inline void Append(idx_t &count, const idx_t idx) {
144: 		if (sel) {
145: 			sel->set_index(count, idx);
146: 		}
147: 		++count;
148: 	}
149: 
150: 	inline void Advance(idx_t completed) {
151: 		if (sel) {
152: 			sel->Initialize(sel->data() + completed);
153: 		}
154: 	}
155: 
156: private:
157: 	SelectionVector *sel;
158: 	SelectionVector vec;
159: };
160: 
161: // Contains a selection vector, combined with a count
162: class ManagedSelection {
163: public:
164: 	explicit inline ManagedSelection(idx_t size, bool initialize = true)
165: 	    : initialized(initialize), size(size), internal_opt_selvec(nullptr) {
166: 		count = 0;
167: 		if (!initialized) {
168: 			return;
169: 		}
170: 		sel_vec.Initialize(size);
171: 		internal_opt_selvec.Initialize(&sel_vec);
172: 	}
173: 
174: public:
175: 	bool Initialized() const {
176: 		return initialized;
177: 	}
178: 	void Initialize(idx_t new_size) {
179: 		D_ASSERT(!initialized);
180: 		this->size = new_size;
181: 		sel_vec.Initialize(new_size);
182: 		internal_opt_selvec.Initialize(&sel_vec);
183: 		initialized = true;
184: 	}
185: 
186: 	inline idx_t operator[](idx_t index) const {
187: 		D_ASSERT(index < size);
188: 		return sel_vec.get_index(index);
189: 	}
190: 	inline bool IndexMapsToLocation(idx_t idx, idx_t location) const {
191: 		return idx < count && sel_vec.get_index(idx) == location;
192: 	}
193: 	inline void Append(const idx_t idx) {
194: 		internal_opt_selvec.Append(count, idx);
195: 	}
196: 	inline idx_t Count() const {
197: 		return count;
198: 	}
199: 	inline idx_t Size() const {
200: 		return size;
201: 	}
202: 	inline const SelectionVector &Selection() const {
203: 		return sel_vec;
204: 	}
205: 	inline SelectionVector &Selection() {
206: 		return sel_vec;
207: 	}
208: 
209: private:
210: 	bool initialized = false;
211: 	idx_t count;
212: 	idx_t size;
213: 	SelectionVector sel_vec;
214: 	OptionalSelection internal_opt_selvec;
215: };
216: 
217: } // namespace duckdb
[end of src/include/duckdb/common/types/selection_vector.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.py
+++ b/file.py
@@ -1,27 +1,35 @@
def euclidean(a, b):
-    while b:
-        a, b = b, a % b
-    return a
+    if b == 0:
+        return a
+    return euclidean(b, a % b)

def bresenham(x0, y0, x1, y1):
    points = []
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
-    sx = 1 if x0 < x1 else -1
-    sy = 1 if y0 < y1 else -1
-    err = dx - dy
+    x, y = x0, y0
+    sx = -1 if x0 > x1 else1
+    sy = -1 if y0 > y1 else 1
    
-    while True:
-        points.append((x, y))
-        if x == x1 and y == y1:
-            break
-        e2 = 2 * err
-        if e2 > -dy:
+    if dx > dy:
+        err = dx / 2.0
+        while x != x1:
+            points.append((x, y))
             err -= dy
-            x0 += sx
-        if e2 < dx:
-            err += dx
-            y0 += sy
+            if err < 0:
+               y += sy
+               err += dx
+            x += sx       
+     else:
+        err = dy / 2.0
+        while y != y1:
+            points.append((x, y))
+            err -= dx
+            if err < 0:
+                x += sx
+                err += dy
+            y += sy

+    points.append((x, y))
    return points
</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.

Respond below: