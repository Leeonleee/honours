--- a/src/execution/expression_executor/execute_conjunction.cpp
+++ b/src/execution/expression_executor/execute_conjunction.cpp
@@ -117,8 +117,32 @@
     for (idx_t i = 0; i < expr.children.size(); i++) {
         idx_t tcount = Select(*expr.children[state.adaptive_filter->permutation[i]],
                               state.child_states[state.adaptive_filter->permutation[i]].get(), current_sel,
                               current_count, temp_true.get(), false_sel);
         if (tcount > 0) {
-            if (true_sel) {
-                // tuples passed, move them into the actual result vector
-                for (idx_t i = 0; i < tcount; i++) {
-                    true_sel->set_index(result_count++, temp_true->get_index(i));
-                }
-            }
-            // now move on to check only the non-passing tuples
-            current_count -= tcount;
-            current_sel = false_sel;
-        }
-    }
-    if (true_sel) {
-        true_sel->Sort(result_count);
-    }
+            if (true_sel) {
+                // For OR preservation: Only append TRUEs in input order, don't sort.
+                for (idx_t i = 0; i < tcount; i++) {
+                    true_sel->set_index(result_count++, temp_true->get_index(i));
+                }
+            }
+            // now move on to check only the non-passing tuples
+            current_count -= tcount;
+            current_sel = false_sel;
+        }
+    }
+    // --- Begin fix for OR order preservation ---
+    // For order preservation in OR, do NOT sort; preserve appearance order
+    // If true_sel is provided and result_count > 1, this vector may contain duplicates (if an item satisfies multiple OR-ed predicates).
+    // Remove duplicates, preserving first occurrence order
+    if (true_sel && result_count > 1) {
+        // Use an in-place stable de-duplication
+        std::unordered_set<idx_t> seen;
+        idx_t write_idx = 0;
+        for (idx_t read_idx = 0; read_idx < result_count; read_idx++) {
+            auto idx = true_sel->get_index(read_idx);
+            if (seen.insert(idx).second) {
+                true_sel->set_index(write_idx++, idx);
+            }
+        }
+        result_count = write_idx;
+    }
+    // --- End fix for OR order preservation ---
     // adapt runtime statistics
     state.adaptive_filter->EndFilter(filter_state);
     return result_count;
--- a/src/include/duckdb/common/types/selection_vector.hpp
+++ b/src/include/duckdb/common/types/selection_vector.hpp
@@ -119,8 +119,17 @@
     void Sort(idx_t count);
+
+    // Removes duplicates in-place, preserving the first occurrence order,
+    // and returns the new count after deduplication.
+    inline idx_t DeduplicateStable(idx_t count) {
+        std::unordered_set<sel_t> seen;
+        idx_t write_idx = 0;
+        for (idx_t read_idx = 0; read_idx < count; read_idx++) {
+            auto idx = get_index(read_idx);
+            if (seen.insert(idx).second) {
+                set_index(write_idx++, idx);
+            }
+        }
+        return write_idx;
+    }
 
     private:
         sel_t *sel_vector;
         buffer_ptr<SelectionData> selection_data;
     };
 
-