{
  "repo": "duckdb/duckdb",
  "pull_number": 3865,
  "instance_id": "duckdb__duckdb-3865",
  "issue_numbers": [
    "3860",
    "3860"
  ],
  "base_commit": "2000fbe9059e9a766ee12858d7ee2b4b43f5db79",
  "patch": "diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp\nindex 6edad95b0263..349e14ebda59 100644\n--- a/src/catalog/catalog_entry/table_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp\n@@ -437,6 +437,7 @@ unique_ptr<CatalogEntry> TableCatalogEntry::ChangeColumnType(ClientContext &cont\n \t}\n \tauto change_idx = GetColumnIndex(info.column_name);\n \tauto create_info = make_unique<CreateTableInfo>(schema->name, name);\n+\tcreate_info->temporary = temporary;\n \n \tfor (idx_t i = 0; i < columns.size(); i++) {\n \t\tauto copy = columns[i].Copy();\n@@ -518,6 +519,7 @@ unique_ptr<CatalogEntry> TableCatalogEntry::ChangeColumnType(ClientContext &cont\n \n unique_ptr<CatalogEntry> TableCatalogEntry::SetForeignKeyConstraint(ClientContext &context, AlterForeignKeyInfo &info) {\n \tauto create_info = make_unique<CreateTableInfo>(schema->name, name);\n+\tcreate_info->temporary = temporary;\n \n \tfor (idx_t i = 0; i < columns.size(); i++) {\n \t\tcreate_info->columns.push_back(columns[i].Copy());\ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex e68011479275..c61d51580af2 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -326,6 +326,8 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {\n \t\t// If there is a foreign key constraint, resolve primary key column's index from primary key column's name\n \t\tauto &create_info = (CreateTableInfo &)*stmt.info;\n \t\tauto &catalog = Catalog::GetCatalog(context);\n+\t\t// We first check if there are any user types, if yes we check to which custom types they refer.\n+\t\tunordered_set<SchemaCatalogEntry *> fk_schemas;\n \t\tfor (idx_t i = 0; i < create_info.constraints.size(); i++) {\n \t\t\tauto &cond = create_info.constraints[i];\n \t\t\tif (cond->type != ConstraintType::FOREIGN_KEY) {\n@@ -342,6 +344,7 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {\n \t\t\t} else {\n \t\t\t\t// have to resolve referenced table\n \t\t\t\tauto pk_table_entry_ptr = catalog.GetEntry<TableCatalogEntry>(context, fk.info.schema, fk.info.table);\n+\t\t\t\tfk_schemas.insert(pk_table_entry_ptr->schema);\n \t\t\t\tD_ASSERT(fk.info.pk_keys.empty());\n \t\t\t\tFindMatchingPrimaryKeyColumns(pk_table_entry_ptr->constraints, fk);\n \t\t\t\tfor (auto &keyname : fk.pk_columns) {\n@@ -366,10 +369,15 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {\n \t\tif (AnyConstraintReferencesGeneratedColumn(create_info)) {\n \t\t\tthrow BinderException(\"Constraints on generated columns are not supported yet\");\n \t\t}\n-\t\t// We first check if there are any user types, if yes we check to which custom types they refer.\n \t\tauto bound_info = BindCreateTableInfo(move(stmt.info));\n \t\tauto root = move(bound_info->query);\n \n+\t\tfor (auto &fk_schema : fk_schemas) {\n+\t\t\tif (fk_schema != bound_info->schema) {\n+\t\t\t\tthrow BinderException(\"Creating foreign keys across different schemas is not supported\");\n+\t\t\t}\n+\t\t}\n+\n \t\t// create the logical operator\n \t\tauto &schema = bound_info->schema;\n \t\tauto create_table = make_unique<LogicalCreateTable>(schema, move(bound_info));\n",
  "test_patch": "diff --git a/test/sql/constraints/foreignkey/test_fk_cross_schema.test b/test/sql/constraints/foreignkey/test_fk_cross_schema.test\nnew file mode 100644\nindex 000000000000..aaf1b641f4c0\n--- /dev/null\n+++ b/test/sql/constraints/foreignkey/test_fk_cross_schema.test\n@@ -0,0 +1,18 @@\n+# name: test/sql/constraints/foreignkey/test_fk_cross_schema.test\n+# description: Test foreign key constraint across different schemas\n+# group: [foreignkey]\n+\n+statement ok\n+CREATE SCHEMA s1\n+\n+statement ok\n+CREATE SCHEMA s2\n+\n+statement ok\n+CREATE TABLE s1.pk_integers(i INTEGER PRIMARY KEY)\n+\n+statement ok\n+INSERT INTO s1.pk_integers VALUES (1), (2), (3)\n+\n+statement error\n+CREATE TABLE s2.fk_integers(j INTEGER, FOREIGN KEY (j) REFERENCES s1.pk_intexgers(i))\ndiff --git a/test/sql/constraints/foreignkey/test_fk_temporary.test b/test/sql/constraints/foreignkey/test_fk_temporary.test\nnew file mode 100644\nindex 000000000000..e58ee3c7ac14\n--- /dev/null\n+++ b/test/sql/constraints/foreignkey/test_fk_temporary.test\n@@ -0,0 +1,247 @@\n+# name: test/sql/constraints/foreignkey/test_fk_temporary.test\n+# description: Test foreign key constraint\n+# group: [foreignkey]\n+\n+statement ok\n+CREATE TEMPORARY TABLE album(artistid INTEGER, albumname TEXT, albumcover TEXT, UNIQUE (artistid, albumname));\n+\n+statement ok\n+INSERT INTO album VALUES (1, 'A', 'A_cover'), (2, 'B', 'B_cover'), (3, 'C', 'C_cover'), (4, 'D', 'D_cover');\n+\n+statement ok\n+CREATE TEMPORARY TABLE song(songid INTEGER, songartist INTEGER, songalbum TEXT, songname TEXT, FOREIGN KEY(songartist, songalbum) REFERENCES album(artistid, albumname));\n+\n+# Any row that is inserted into the table with the foreign key must exist in the table with the primary key (constraint)\n+statement error\n+INSERT INTO song VALUES (11, 1, 'A', 'A_song'), (12, 2, 'E', 'B_song'), (13, 3, 'C', 'C_song');\n+\n+statement error\n+INSERT INTO song VALUES (11, 1, 'A', 'A_song'), (12, 5, 'D', 'B_song'), (13, 3, 'C', 'C_song');\n+\n+statement ok\n+INSERT INTO song VALUES (11, 1, 'A', 'A_song'), (12, 2, 'B', 'B_song'), (13, 3, 'C', 'C_song');\n+\n+# Any row that is deleted from the table with the primary key must not exist in the table with the foreign key (constraint)\n+statement error\n+DELETE FROM album WHERE albumname='C';\n+\n+statement ok\n+DELETE FROM album WHERE albumname='D';\n+\n+query ITT\n+SELECT * FROM album;\n+----\n+1\tA\tA_cover\n+2\tB\tB_cover\n+3\tC\tC_cover\n+\n+# Any row that is updated from the table has foreign key must exist in the table with the primary key (constraint)\n+statement error\n+UPDATE song SET songartist=5, songalbum='A' WHERE songname='B_song';\n+\n+statement ok\n+UPDATE song SET songartist=1, songalbum='A' WHERE songname='B_song';\n+\n+query ITT\n+SELECT * FROM album;\n+----\n+1\tA\tA_cover\n+2\tB\tB_cover\n+3\tC\tC_cover\n+\n+query IITT\n+SELECT * FROM song;\n+----\n+11\t1\tA\tA_song\n+13\t3\tC\tC_song\n+12\t1\tA\tB_song\n+\n+# Any row that is updated from the table with primary key must not exist in the table has foreign key (constraint)\n+statement error\n+UPDATE album SET albumname='B' WHERE albumcover='C_cover';\n+\n+statement error\n+UPDATE song SET songalbum='E' WHERE albumcover='C_song';\n+\n+statement ok\n+UPDATE album SET artistid=5, albumname='D' WHERE albumcover='B_cover';\n+\n+query ITT\n+SELECT * FROM album;\n+----\n+1\tA\tA_cover\n+3\tC\tC_cover\n+5\tD\tB_cover\n+\n+# perform an update on a column that is NOT part of the primary key in the main table\n+statement ok\n+UPDATE album SET albumcover='C_cover_new' WHERE artistid=3;\n+\n+# perform an update on a column that is NOT part of the foreign key in the referencing table\n+statement ok\n+UPDATE song SET songname='C_song_new' WHERE songartist=3;\n+\n+query ITT\n+SELECT * FROM album;\n+----\n+1\tA\tA_cover\n+3\tC\tC_cover_new\n+5\tD\tB_cover\n+\n+query IITT\n+SELECT * FROM song;\n+----\n+11\t1\tA\tA_song\n+13\t3\tC\tC_song_new\n+12\t1\tA\tB_song\n+\n+# Cannot rename the columns that are involved in the foreign key constraint\n+statement error\n+ALTER TABLE album RENAME COLUMN albumname TO albumname_new;\n+\n+statement error\n+ALTER TABLE song RENAME COLUMN songalbum TO songalbum_new;\n+\n+statement ok\n+ALTER TABLE song RENAME COLUMN songname TO songname_new;\n+\n+# Cannot change type of the columns that are involved in the foreign key constraint\n+statement error\n+ALTER TABLE song ALTER COLUMN songartist SET DATA TYPE TEXT;\n+\n+statement error\n+ALTER TABLE album ALTER COLUMN artistid SET DATA TYPE TEXT;\n+\n+statement ok\n+ALTER TABLE song ALTER COLUMN songname_new SET DATA TYPE VARCHAR;\n+\n+# Cannot drop the columns that are involved in the foreign key constraint because of dependency\n+statement error\n+ALTER TABLE album DROP COLUMN artistid;\n+\n+statement ok\n+ALTER TABLE song DROP COLUMN songname_new;\n+\n+# Can't drop the table with primary key corresponding with foreign key until exists the table has foreign key\n+statement error\n+DROP TABLE album;\n+\n+statement ok\n+DROP TABLE song;\n+\n+statement ok\n+ALTER TABLE album RENAME COLUMN albumname TO albumname_new;\n+\n+statement ok\n+ALTER TABLE album ALTER COLUMN albumcover SET DATA TYPE VARCHAR;\n+\n+statement ok\n+ALTER TABLE album DROP COLUMN albumcover;\n+\n+statement ok\n+DROP TABLE album;\n+\n+# multiple columns and indices\n+statement ok\n+CREATE TABLE pkt(i INTEGER UNIQUE, k INTEGER UNIQUE)\n+\n+statement ok\n+INSERT INTO pkt VALUES (1, 11), (2, 12), (3, 13)\n+\n+statement ok\n+CREATE TABLE fkt(j INTEGER, l INTEGER UNIQUE, FOREIGN KEY (j) REFERENCES pkt(i))\n+\n+statement ok\n+CREATE INDEX k_index ON pkt(k)\n+\n+statement ok\n+CREATE INDEX l_index ON fkt(l)\n+\n+statement ok\n+INSERT INTO fkt VALUES (1, 101), (2, 102)\n+\n+statement error\n+INSERT INTO fkt VALUES (4, 104)\n+\n+statement ok\n+INSERT INTO fkt VALUES (3, 103)\n+\n+statement error\n+DELETE FROM pkt WHERE k=13\n+\n+statement ok\n+DELETE FROM fkt WHERE l=103\n+\n+statement ok\n+DELETE FROM pkt WHERE k=13\n+\n+statement error\n+UPDATE pkt SET i=5 WHERE k=12\n+\n+statement error\n+UPDATE fkt SET i=4 WHERE l=102\n+\n+statement error\n+UPDATE fkt SET i=4 WHERE l=102\n+\n+statement ok\n+DROP INDEX k_index\n+\n+statement ok\n+DROP INDEX l_index\n+\n+statement error\n+DROP TABLE pkt;\n+\n+statement ok\n+DROP TABLE fkt;\n+\n+statement ok\n+DROP TABLE pkt;\n+\n+# for tables that do not live in the current schema search path\n+statement ok\n+CREATE SCHEMA s1\n+\n+statement ok\n+CREATE TABLE s1.pkt(i INTEGER PRIMARY KEY)\n+\n+statement ok\n+CREATE TABLE s1.fkt(j INTEGER, FOREIGN KEY (j) REFERENCES s1.pkt(i))\n+\n+statement ok\n+INSERT INTO s1.pkt VALUES (1), (2), (3), (4), (5)\n+\n+statement ok\n+INSERT INTO s1.fkt VALUES (2), (3)\n+\n+statement error\n+INSERT INTO s1.fkt VALUES (6)\n+\n+statement ok\n+INSERT INTO s1.fkt VALUES (1)\n+\n+statement error\n+DELETE FROM s1.pkt WHERE i=2\n+\n+statement ok\n+DELETE FROM s1.pkt WHERE i=5\n+\n+statement error\n+DROP TABLE s1.pkt;\n+\n+statement ok\n+DROP TABLE s1.fkt;\n+\n+statement ok\n+DROP TABLE s1.pkt;\n+\n+# insert NULL into the foreign key column\n+statement ok\n+CREATE TABLE pkt(i INTEGER UNIQUE)\n+\n+statement ok\n+CREATE TABLE fkt(j INTEGER, FOREIGN KEY (j) REFERENCES pkt(i))\n+\n+statement ok\n+INSERT INTO fkt VALUES (NULL)\ndiff --git a/test/sql/storage/test_foreign_key_persistent_storage.test b/test/sql/storage/constraints/foreignkey/foreign_key_persistent.test\nsimilarity index 91%\nrename from test/sql/storage/test_foreign_key_persistent_storage.test\nrename to test/sql/storage/constraints/foreignkey/foreign_key_persistent.test\nindex 3af151f7c85f..5998eb8178d7 100644\n--- a/test/sql/storage/test_foreign_key_persistent_storage.test\n+++ b/test/sql/storage/constraints/foreignkey/foreign_key_persistent.test\n@@ -1,6 +1,6 @@\n-# name: test/sql/storage/test_foreign_key_persistent_storage.test\n+# name: test/sql/storage/constraints/foreignkey/foreign_key_persistent.test\n # description: persistent storage tests with foreign key tables\n-# group: [storage]\n+# group: [foreignkey]\n \n # load the DB from disk\n load __TEST_DIR__/test_fk_persistent.db\n",
  "problem_statement": "Can't create foreign keys in temporary tables\n#### What happens?\r\n\r\nThe syntax `CREATE TEMP TABLE y (a int, FOREIGN KEY (a) REFERENCES x (a))` fails with a parser error: \"Parser Error: Only TEMPORARY table names can use the \"temp\" schema\"\r\n\r\n#### To Reproduce\r\n\r\n```sql\r\nCREATE TEMP TABLE x (a int, PRIMARY KEY (a))\r\nCREATE TEMP TABLE y (a int, FOREIGN KEY (a) REFERENCES x (a))\r\n```\r\n\r\n```sh\r\necho \"CREATE TEMP TABLE x (a int, PRIMARY KEY (a)); CREATE TEMP TABLE y (a int, FOREIGN KEY (a) REFERENCES x (a));\" | build/debug/duckdb\r\n```\r\n\r\n``` r\r\ncon <- DBI::dbConnect(duckdb::duckdb())\r\n\r\nDBI::dbExecute(con, \"CREATE TEMP TABLE x (a int, PRIMARY KEY (a))\")\r\n#> [1] 0\r\nDBI::dbExecute(con, \"CREATE TEMP TABLE y (a int, FOREIGN KEY (a) REFERENCES x (a))\")\r\n#> Error: rapi_execute: Failed to run query\r\n#> Error: Parser Error: Only TEMPORARY table names can use the \"temp\" schema\r\n```\r\n\r\n<sup>Created on 2022-06-15 by the [reprex package](https://reprex.tidyverse.org) (v2.0.1)</sup>\r\n\r\n#### Environment (please complete the following information):\r\n - OS: macOS\r\n - DuckDB Version: cdfb9f92ffb04669d46bd531de5c88e85ade9d43\r\n - DuckDB Client: CLI, R\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nCan't create foreign keys in temporary tables\n#### What happens?\r\n\r\nThe syntax `CREATE TEMP TABLE y (a int, FOREIGN KEY (a) REFERENCES x (a))` fails with a parser error: \"Parser Error: Only TEMPORARY table names can use the \"temp\" schema\"\r\n\r\n#### To Reproduce\r\n\r\n```sql\r\nCREATE TEMP TABLE x (a int, PRIMARY KEY (a))\r\nCREATE TEMP TABLE y (a int, FOREIGN KEY (a) REFERENCES x (a))\r\n```\r\n\r\n```sh\r\necho \"CREATE TEMP TABLE x (a int, PRIMARY KEY (a)); CREATE TEMP TABLE y (a int, FOREIGN KEY (a) REFERENCES x (a));\" | build/debug/duckdb\r\n```\r\n\r\n``` r\r\ncon <- DBI::dbConnect(duckdb::duckdb())\r\n\r\nDBI::dbExecute(con, \"CREATE TEMP TABLE x (a int, PRIMARY KEY (a))\")\r\n#> [1] 0\r\nDBI::dbExecute(con, \"CREATE TEMP TABLE y (a int, FOREIGN KEY (a) REFERENCES x (a))\")\r\n#> Error: rapi_execute: Failed to run query\r\n#> Error: Parser Error: Only TEMPORARY table names can use the \"temp\" schema\r\n```\r\n\r\n<sup>Created on 2022-06-15 by the [reprex package](https://reprex.tidyverse.org) (v2.0.1)</sup>\r\n\r\n#### Environment (please complete the following information):\r\n - OS: macOS\r\n - DuckDB Version: cdfb9f92ffb04669d46bd531de5c88e85ade9d43\r\n - DuckDB Client: CLI, R\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "Trying to remove the code that triggers the warning, checking if tests are failing: https://github.com/krlmlr/duckdb/actions/runs/2499751954.\nTrying to remove the code that triggers the warning, checking if tests are failing: https://github.com/krlmlr/duckdb/actions/runs/2499751954.",
  "created_at": "2022-06-15T11:28:00Z"
}