{
  "repo": "duckdb/duckdb",
  "pull_number": 16657,
  "instance_id": "duckdb__duckdb-16657",
  "issue_numbers": [
    "16551"
  ],
  "base_commit": "65061f58d439cc021db4c1a74218f118886a2fd4",
  "patch": "diff --git a/tools/pythonpkg/src/arrow/arrow_array_stream.cpp b/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\nindex 9546de74bdd8..2b13ddfc2451 100644\n--- a/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\n+++ b/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\n@@ -48,23 +48,21 @@ py::object PythonTableArrowArrayStreamFactory::ProduceScanner(DBConfig &config,\n \tpy::list projection_list = py::cast(column_list);\n \n \tbool has_filter = filters && !filters->filters.empty();\n+\tpy::dict kwargs;\n+\tif (!column_list.empty()) {\n+\t\tkwargs[\"columns\"] = projection_list;\n+\t}\n \n \tif (has_filter) {\n \t\tauto filter = TransformFilter(*filters, parameters.projected_columns.projection_map, filter_to_col,\n \t\t                              client_properties, arrow_table);\n-\t\tif (column_list.empty()) {\n-\t\t\treturn arrow_scanner(arrow_obj_handle, py::arg(\"filter\") = filter);\n-\t\t} else {\n-\t\t\treturn arrow_scanner(arrow_obj_handle, py::arg(\"columns\") = projection_list, py::arg(\"filter\") = filter);\n-\t\t}\n-\t} else {\n-\t\tif (column_list.empty()) {\n-\t\t\treturn arrow_scanner(arrow_obj_handle);\n-\t\t} else {\n-\t\t\treturn arrow_scanner(arrow_obj_handle, py::arg(\"columns\") = projection_list);\n+\t\tif (!filter.is(py::none())) {\n+\t\t\tkwargs[\"filter\"] = filter;\n \t\t}\n \t}\n+\treturn arrow_scanner(arrow_obj_handle, **kwargs);\n }\n+\n unique_ptr<ArrowArrayStreamWrapper> PythonTableArrowArrayStreamFactory::Produce(uintptr_t factory_ptr,\n                                                                                 ArrowStreamParameters &parameters) {\n \tpy::gil_scoped_acquire acquire;\n@@ -337,6 +335,9 @@ py::object TransformFilterRecursive(TableFilter &filter, vector<string> column_r\n \t\tfor (idx_t i = 0; i < or_filter.child_filters.size(); i++) {\n \t\t\tauto &child_filter = *or_filter.child_filters[i];\n \t\t\tpy::object child_expression = TransformFilterRecursive(child_filter, column_ref, timezone_config, type);\n+\t\t\tif (child_expression.is(py::none())) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tif (expression.is(py::none())) {\n \t\t\t\texpression = std::move(child_expression);\n \t\t\t} else {\n@@ -351,6 +352,9 @@ py::object TransformFilterRecursive(TableFilter &filter, vector<string> column_r\n \t\tfor (idx_t i = 0; i < and_filter.child_filters.size(); i++) {\n \t\t\tauto &child_filter = *and_filter.child_filters[i];\n \t\t\tpy::object child_expression = TransformFilterRecursive(child_filter, column_ref, timezone_config, type);\n+\t\t\tif (child_expression.is(py::none())) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tif (expression.is(py::none())) {\n \t\t\t\texpression = std::move(child_expression);\n \t\t\t} else {\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp b/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp\nindex 6717648d0b03..a492db9aaa6b 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp\n@@ -32,6 +32,8 @@ void gil_assert();\n bool is_list_like(handle obj);\n bool is_dict_like(handle obj);\n \n+std::string to_string(const object &obj);\n+\n } // namespace pybind11\n \n namespace duckdb {\ndiff --git a/tools/pythonpkg/src/pybind11/pybind_wrapper.cpp b/tools/pythonpkg/src/pybind11/pybind_wrapper.cpp\nindex 23bf80354a16..ce3122a0fc9c 100644\n--- a/tools/pythonpkg/src/pybind11/pybind_wrapper.cpp\n+++ b/tools/pythonpkg/src/pybind11/pybind_wrapper.cpp\n@@ -36,4 +36,9 @@ bool is_dict_like(handle obj) {\n \treturn isinstance(obj, mapping);\n }\n \n+// NOLINTNEXTLINE(readability-identifier-naming)\n+std::string to_string(const object &obj) {\n+\treturn std::string(py::str(obj));\n+}\n+\n } // namespace pybind11\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py b/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py\nindex 6ee575198f6b..142d1dace103 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py\n@@ -947,3 +947,42 @@ def test_in_filter_pushdown(self, duckdb_cursor):\n         duck_probe_arrow = duck_probe.arrow()\n         duckdb_conn.register(\"duck_probe_arrow\", duck_probe_arrow)\n         assert duckdb_conn.execute(\"SELECT * from duck_probe_arrow where a in (1, 999)\").fetchall() == [(1,), (999,)]\n+\n+    def test_pushdown_of_optional_filter(self, duckdb_cursor):\n+        cardinality_table = pa.Table.from_pydict(\n+            {\n+                'column_name': [\n+                    'id',\n+                    'product_code',\n+                    'price',\n+                    'quantity',\n+                    'category',\n+                    'is_available',\n+                    'rating',\n+                    'discount',\n+                    'color',\n+                ],\n+                'cardinality': [100, 100, 100, 45, 5, 3, 6, 39, 5],\n+            }\n+        )\n+\n+        result = duckdb.query(\n+            \"\"\"\n+            SELECT *\n+            FROM cardinality_table\n+            WHERE cardinality > 1\n+            ORDER BY cardinality ASC\n+        \"\"\"\n+        )\n+        res = result.fetchall()\n+        assert res == [\n+            ('is_available', 3),\n+            ('category', 5),\n+            ('color', 5),\n+            ('rating', 6),\n+            ('discount', 39),\n+            ('quantity', 45),\n+            ('id', 100),\n+            ('product_code', 100),\n+            ('price', 100),\n+        ]\n",
  "problem_statement": "ArrowNotImplementedError: 'and_kleene' error when querying Polars DataFrame in DuckDB\n### What happens?\n\nDuckDB query fails with \"ArrowNotImplementedError: Function 'and_kleene' has no kernel matching input types (bool, null)\" when querying a Polars DataFrame containing nullable boolean values.\n\n### To Reproduce\n\n## Code\n```python\nimport numpy as np\nimport random\nimport polars as pl\nimport duckdb\n\nnp.random.seed(42)\nrandom.seed(42)\nn_rows = 100\n\ndata = {\n    \"id\": list(range(1, n_rows + 1)),\n    \"product_code\": [f\"P{i:04d}\" for i in range(n_rows)],\n    \"price\": np.random.uniform(10, 1000, n_rows).tolist(),\n    \"quantity\": [random.randint(1, 50) if random.random() > 0.1 else None for _ in range(n_rows)],\n    \"category\": np.random.choice([\"A\", \"B\", \"C\", \"D\", None], n_rows, p=[0.3, 0.3, 0.2, 0.1, 0.1]).tolist(),\n    \"is_available\": np.random.choice([True, False, None], n_rows, p=[0.6, 0.3, 0.1]).tolist(),\n    \"rating\": [random.randint(1, 5) if random.random() > 0.2 else None for _ in range(n_rows)],\n    \"discount\": [round(random.uniform(0, 0.5), 2) if random.random() > 0.3 else None for _ in range(n_rows)],\n    \"color\": np.random.choice([\"red\", \"blue\", \"green\", \"black\", None], n_rows).tolist()\n}\n\ndf = pl.DataFrame(data)\ncardinality_df = pl.DataFrame({\n    \"column_name\": df.columns,\n    \"cardinality\": [df[col].n_unique() for col in df.columns]\n})\n\n# This successfully creates the cardinality dataframe\nprint(cardinality_df)\n\n# This query fails\nresult = duckdb.query(\"\"\"\nSELECT *\nFROM cardinality_df\nWHERE cardinality > 1\nORDER BY cardinality ASC\n\"\"\")\n\nprint(result)\n```\n\n## Output\nFirst, the Polars DataFrame is successfully created and displays correctly:\n```\nshape: (9, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 column_name  \u2506 cardinality \u2502\n\u2502 ---          \u2506 ---         \u2502\n\u2502 str          \u2506 i64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 id           \u2506 100         \u2502\n\u2502 product_code \u2506 100         \u2502\n\u2502 price        \u2506 100         \u2502\n\u2502 quantity     \u2506 45          \u2502\n\u2502 category     \u2506 5           \u2502\n\u2502 is_available \u2506 3           \u2502\n\u2502 rating       \u2506 6           \u2502\n\u2502 discount     \u2506 39          \u2502\n\u2502 color        \u2506 5           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nThen, when trying to run the DuckDB query, it fails with this error:\n```\nArrowNotImplementedError: Function 'and_kleene' has no kernel matching input types (bool, null)\nAt:\n  pyarrow/error.pxi(92): pyarrow.lib.check_status\n```\n\n## Expected behavior\nThe DuckDB query should successfully filter and sort the Polars DataFrame based on the cardinality column.\n\n## Additional info\nConverting the polars dataframe to pandas via `cardinality_df = cardinality_df.to_pandas()` avoids the error.\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n1.2.0\n\n### DuckDB Client:\n\nPython\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nPavel Khokhlov\n\n### Affiliation:\n\npersonal\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\n",
  "hints_text": "Hi @pkhokhlov thanks for reporting this! I added a print statement to trigger the error in a script and I could reproduce it.\nIt would be helpful to know the polars and pyarrow version you are using, as this doesn't reproduce on versions we have tested",
  "created_at": "2025-03-14T13:59:36Z"
}