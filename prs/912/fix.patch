diff --git a/src/catalog/catalog.cpp b/src/catalog/catalog.cpp
index ee77cc82dbb7..805df3f75e23 100644
--- a/src/catalog/catalog.cpp
+++ b/src/catalog/catalog.cpp
@@ -157,6 +157,18 @@ CatalogEntry *Catalog::GetEntry(ClientContext &context, CatalogType type, string
 	return schema->GetEntry(context, type, name, if_exists);
 }
 
+template <>
+ViewCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists) {
+	auto entry = GetEntry(context, CatalogType::VIEW_ENTRY, move(schema_name), name, if_exists);
+	if (!entry) {
+		return nullptr;
+	}
+	if (entry->type != CatalogType::VIEW_ENTRY) {
+		throw CatalogException("%s is not a view", name);
+	}
+	return (ViewCatalogEntry *)entry;
+}
+
 template <>
 TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists) {
 	auto entry = GetEntry(context, CatalogType::TABLE_ENTRY, move(schema_name), name, if_exists);
diff --git a/src/catalog/catalog_entry/schema_catalog_entry.cpp b/src/catalog/catalog_entry/schema_catalog_entry.cpp
index f35036483a79..1d86d989964d 100644
--- a/src/catalog/catalog_entry/schema_catalog_entry.cpp
+++ b/src/catalog/catalog_entry/schema_catalog_entry.cpp
@@ -160,13 +160,16 @@ void SchemaCatalogEntry::DropEntry(ClientContext &context, DropInfo *info) {
 
 void SchemaCatalogEntry::AlterTable(ClientContext &context, AlterTableInfo *info) {
 	switch (info->alter_table_type) {
-	case AlterTableType::RENAME_TABLE: {
+	case AlterTableType::RENAME_TABLE:
+	case AlterTableType::RENAME_VIEW: {
 		auto &transaction = Transaction::GetTransaction(context);
 		auto entry = tables.GetEntry(transaction, info->table);
 		if (entry == nullptr) {
-			throw CatalogException("Table \"%s\" doesn't exist!", info->table);
+			throw CatalogException("Relation \"%s\" doesn't exist!", info->table);
 		}
-		assert(entry->type == CatalogType::TABLE_ENTRY);
+		CatalogType expected_type =
+		    info->alter_table_type == AlterTableType::RENAME_VIEW ? CatalogType::VIEW_ENTRY : CatalogType::TABLE_ENTRY;
+		assert(entry->type == expected_type);
 
 		auto copied_entry = entry->Copy(context);
 
diff --git a/src/catalog/catalog_entry/view_catalog_entry.cpp b/src/catalog/catalog_entry/view_catalog_entry.cpp
index b0222b2955ec..d30aeac4c36c 100644
--- a/src/catalog/catalog_entry/view_catalog_entry.cpp
+++ b/src/catalog/catalog_entry/view_catalog_entry.cpp
@@ -64,4 +64,19 @@ string ViewCatalogEntry::ToSQL() {
 	return sql + "
;";
 }
 
+unique_ptr<CatalogEntry> ViewCatalogEntry::Copy(ClientContext &context) {
+	auto create_info = make_unique<CreateViewInfo>(schema->name, name);
+	create_info->query = query->Copy();
+	for (idx_t i = 0; i < aliases.size(); i++) {
+		create_info->aliases.push_back(aliases[i]);
+	}
+	for (idx_t i = 0; i < types.size(); i++) {
+		create_info->types.push_back(types[i]);
+	}
+	create_info->temporary = temporary;
+	create_info->sql = sql;
+
+	return make_unique<ViewCatalogEntry>(catalog, schema, create_info.get());
+}
+
 } // namespace duckdb
diff --git a/src/include/duckdb/catalog/catalog.hpp b/src/include/duckdb/catalog/catalog.hpp
index a5c94b03c66a..3ea7e89b966d 100644
--- a/src/include/duckdb/catalog/catalog.hpp
+++ b/src/include/duckdb/catalog/catalog.hpp
@@ -31,6 +31,7 @@ class AggregateFunctionCatalogEntry;
 class CollateCatalogEntry;
 class SchemaCatalogEntry;
 class TableCatalogEntry;
+class ViewCatalogEntry;
 class SequenceCatalogEntry;
 class TableFunctionCatalogEntry;
 class CopyFunctionCatalogEntry;
@@ -103,6 +104,8 @@ class Catalog {
 template <>
 TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists);
 template <>
+ViewCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists);
+template <>
 SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists);
 template <>
 TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
diff --git a/src/include/duckdb/catalog/catalog_entry/view_catalog_entry.hpp b/src/include/duckdb/catalog/catalog_entry/view_catalog_entry.hpp
index 70d3d7fffeba..351f388533c3 100644
--- a/src/include/duckdb/catalog/catalog_entry/view_catalog_entry.hpp
+++ b/src/include/duckdb/catalog/catalog_entry/view_catalog_entry.hpp
@@ -40,6 +40,8 @@ class ViewCatalogEntry : public StandardEntry {
 	//! Deserializes to a CreateTableInfo
 	static unique_ptr<CreateViewInfo> Deserialize(Deserializer &source);
 
+	unique_ptr<CatalogEntry> Copy(ClientContext &context) override;
+
 	string ToSQL() override;
 
 private:
diff --git a/src/include/duckdb/parser/parsed_data/alter_table_info.hpp b/src/include/duckdb/parser/parsed_data/alter_table_info.hpp
index 9c992e93028e..1afe05c76472 100644
--- a/src/include/duckdb/parser/parsed_data/alter_table_info.hpp
+++ b/src/include/duckdb/parser/parsed_data/alter_table_info.hpp
@@ -34,7 +34,8 @@ enum class AlterTableType : uint8_t {
 	ADD_COLUMN = 3,
 	REMOVE_COLUMN = 4,
 	ALTER_COLUMN_TYPE = 5,
-	SET_DEFAULT = 6
+	SET_DEFAULT = 6,
+	RENAME_VIEW = 7
 };
 
 struct AlterTableInfo : public AlterInfo {
@@ -79,18 +80,19 @@ struct RenameColumnInfo : public AlterTableInfo {
 // RenameTableInfo
 //===--------------------------------------------------------------------===//
 struct RenameTableInfo : public AlterTableInfo {
-	RenameTableInfo(string schema, string table, string new_name)
-	    : AlterTableInfo(AlterTableType::RENAME_TABLE, schema, table), new_table_name(new_name) {
+	RenameTableInfo(string schema, string table, string new_name, bool is_view)
+	    : AlterTableInfo(is_view ? AlterTableType::RENAME_VIEW : AlterTableType::RENAME_TABLE, schema, table),
+	      new_table_name(new_name) {
 	}
 	~RenameTableInfo() override {
 	}
 
-	//! Table new name
+	//! Relation new name
 	string new_table_name;
 
 public:
 	void Serialize(Serializer &serializer) override;
-	static unique_ptr<AlterInfo> Deserialize(Deserializer &source, string schema, string table);
+	static unique_ptr<AlterInfo> Deserialize(Deserializer &source, string schema, string table, bool is_view);
 };
 
 //===--------------------------------------------------------------------===//
diff --git a/src/parser/parsed_data/alter_table_info.cpp b/src/parser/parsed_data/alter_table_info.cpp
index 339ef7e4c223..9c587e994a8f 100644
--- a/src/parser/parsed_data/alter_table_info.cpp
+++ b/src/parser/parsed_data/alter_table_info.cpp
@@ -34,7 +34,9 @@ unique_ptr<AlterInfo> AlterTableInfo::Deserialize(Deserializer &source) {
 	case AlterTableType::RENAME_COLUMN:
 		return RenameColumnInfo::Deserialize(source, schema, table);
 	case AlterTableType::RENAME_TABLE:
-		return RenameTableInfo::Deserialize(source, schema, table);
+		return RenameTableInfo::Deserialize(source, schema, table, false);
+	case AlterTableType::RENAME_VIEW:
+		return RenameTableInfo::Deserialize(source, schema, table, true);
 	case AlterTableType::ADD_COLUMN:
 		return AddColumnInfo::Deserialize(source, schema, table);
 	case AlterTableType::REMOVE_COLUMN:
@@ -71,9 +73,9 @@ void RenameTableInfo::Serialize(Serializer &serializer) {
 	serializer.WriteString(new_table_name);
 }
 
-unique_ptr<AlterInfo> RenameTableInfo::Deserialize(Deserializer &source, string schema, string table) {
+unique_ptr<AlterInfo> RenameTableInfo::Deserialize(Deserializer &source, string schema, string table, bool is_view) {
 	auto new_name = source.Read<string>();
-	return make_unique<RenameTableInfo>(schema, table, new_name);
+	return make_unique<RenameTableInfo>(schema, table, new_name, is_view);
 }
 
 //===--------------------------------------------------------------------===//
diff --git a/src/parser/transform/statement/transform_rename.cpp b/src/parser/transform/statement/transform_rename.cpp
index 3c8be84e83a0..c4e28f1b775e 100644
--- a/src/parser/transform/statement/transform_rename.cpp
+++ b/src/parser/transform/statement/transform_rename.cpp
@@ -47,10 +47,27 @@ unique_ptr<AlterTableStatement> Transformer::TransformRename(PGNode *node) {
 			schema = stmt->relation->schemaname;
 		}
 		string new_name = stmt->newname;
-		info = make_unique<RenameTableInfo>(schema, table, new_name);
+		info = make_unique<RenameTableInfo>(schema, table, new_name, false /* is_view */);
 		break;
 	}
 
+	case PG_OBJECT_VIEW: {
+		// change view name
+
+		// get the view and schema
+		string schema = DEFAULT_SCHEMA;
+		string view;
+		assert(stmt->relation->relname);
+		if (stmt->relation->relname) {
+			view = stmt->relation->relname;
+		}
+		if (stmt->relation->schemaname) {
+			schema = stmt->relation->schemaname;
+		}
+		string new_name = stmt->newname;
+		info = make_unique<RenameTableInfo>(schema, view, new_name, true /* is_view */);
+		break;
+	}
 	case PG_OBJECT_DATABASE:
 	default:
 		throw NotImplementedException("Schema element not supported yet!");
diff --git a/src/planner/binder/statement/bind_simple.cpp b/src/planner/binder/statement/bind_simple.cpp
index 36302ee960b6..a399ad19ba2a 100644
--- a/src/planner/binder/statement/bind_simple.cpp
+++ b/src/planner/binder/statement/bind_simple.cpp
@@ -2,6 +2,8 @@
 #include "duckdb/parser/statement/transaction_statement.hpp"
 #include "duckdb/planner/operator/logical_simple.hpp"
 #include "duckdb/catalog/catalog.hpp"
+#include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
+#include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
 #include "duckdb/planner/binder.hpp"
 
 using namespace std;
@@ -15,10 +17,15 @@ BoundStatement Binder::Bind(AlterTableStatement &stmt) {
 	BoundStatement result;
 	result.names = {"Success"};
 	result.types = {LogicalType::BOOLEAN};
-	auto table =
-	    Catalog::GetCatalog(context).GetEntry<TableCatalogEntry>(context, stmt.info->schema, stmt.info->table, true);
+	Catalog &catalog = Catalog::GetCatalog(context);
+	CatalogEntry *table;
+	if (stmt.info->alter_table_type == AlterTableType::RENAME_VIEW) {
+		table = catalog.GetEntry<ViewCatalogEntry>(context, stmt.info->schema, stmt.info->table, true);
+	} else {
+		table = catalog.GetEntry<TableCatalogEntry>(context, stmt.info->schema, stmt.info->table, true);
+	}
 	if (table && !table->temporary) {
-		// we can only alter temporary tables in read-only mode
+		// we can only alter temporary tables/views in read-only mode
 		this->read_only = false;
 	}
 	result.plan = make_unique<LogicalSimple>(LogicalOperatorType::ALTER, move(stmt.info));
