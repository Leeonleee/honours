You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Support renaming views
I'm still cranking away on my [dbt](https://www.getdbt.com/) adapter for DuckDB and hit another bit of functionality I need: the ability to rename views. I found the `AlterTableInfo` code and put together some code that I _think_ implements the functionality I need; I'll post a PR shortly for review.

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="30">
2: 
3: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of src/catalog/catalog.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/catalog/catalog_set.hpp"
3: 
4: #include "duckdb/catalog/catalog_entry/list.hpp"
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/main/client_context.hpp"
7: #include "duckdb/parser/expression/function_expression.hpp"
8: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
9: #include "duckdb/parser/parsed_data/create_index_info.hpp"
10: #include "duckdb/parser/parsed_data/create_aggregate_function_info.hpp"
11: #include "duckdb/parser/parsed_data/create_collation_info.hpp"
12: #include "duckdb/parser/parsed_data/create_scalar_function_info.hpp"
13: #include "duckdb/parser/parsed_data/create_schema_info.hpp"
14: #include "duckdb/parser/parsed_data/create_sequence_info.hpp"
15: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
16: #include "duckdb/parser/parsed_data/create_copy_function_info.hpp"
17: #include "duckdb/parser/parsed_data/create_pragma_function_info.hpp"
18: #include "duckdb/parser/parsed_data/create_view_info.hpp"
19: #include "duckdb/parser/parsed_data/drop_info.hpp"
20: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
21: #include "duckdb/storage/storage_manager.hpp"
22: #include "duckdb/main/database.hpp"
23: #include "duckdb/catalog/dependency_manager.hpp"
24: 
25: namespace duckdb {
26: using namespace std;
27: 
28: Catalog::Catalog(StorageManager &storage)
29:     : storage(storage), schemas(make_unique<CatalogSet>(*this)),
30:       dependency_manager(make_unique<DependencyManager>(*this)) {
31: }
32: Catalog::~Catalog() {
33: }
34: 
35: Catalog &Catalog::GetCatalog(ClientContext &context) {
36: 	return context.catalog;
37: }
38: 
39: CatalogEntry *Catalog::CreateTable(ClientContext &context, BoundCreateTableInfo *info) {
40: 	auto schema = GetSchema(context, info->base->schema);
41: 	return schema->CreateTable(context, info);
42: }
43: 
44: CatalogEntry *Catalog::CreateView(ClientContext &context, CreateViewInfo *info) {
45: 	auto schema = GetSchema(context, info->schema);
46: 	return schema->CreateView(context, info);
47: }
48: 
49: CatalogEntry *Catalog::CreateSequence(ClientContext &context, CreateSequenceInfo *info) {
50: 	auto schema = GetSchema(context, info->schema);
51: 	return schema->CreateSequence(context, info);
52: }
53: 
54: CatalogEntry *Catalog::CreateTableFunction(ClientContext &context, CreateTableFunctionInfo *info) {
55: 	auto schema = GetSchema(context, info->schema);
56: 	return schema->CreateTableFunction(context, info);
57: }
58: 
59: CatalogEntry *Catalog::CreateCopyFunction(ClientContext &context, CreateCopyFunctionInfo *info) {
60: 	auto schema = GetSchema(context, info->schema);
61: 	return schema->CreateCopyFunction(context, info);
62: }
63: 
64: CatalogEntry *Catalog::CreatePragmaFunction(ClientContext &context, CreatePragmaFunctionInfo *info) {
65: 	auto schema = GetSchema(context, info->schema);
66: 	return schema->CreatePragmaFunction(context, info);
67: }
68: 
69: CatalogEntry *Catalog::CreateFunction(ClientContext &context, CreateFunctionInfo *info) {
70: 	auto schema = GetSchema(context, info->schema);
71: 	return schema->CreateFunction(context, info);
72: }
73: 
74: CatalogEntry *Catalog::CreateCollation(ClientContext &context, CreateCollationInfo *info) {
75: 	auto schema = GetSchema(context, info->schema);
76: 	return schema->CreateCollation(context, info);
77: }
78: 
79: CatalogEntry *Catalog::CreateSchema(ClientContext &context, CreateSchemaInfo *info) {
80: 	if (info->schema == INVALID_SCHEMA) {
81: 		throw CatalogException("Schema not specified");
82: 	}
83: 	if (info->schema == TEMP_SCHEMA) {
84: 		throw CatalogException("Cannot create built-in schema \"%s\"", info->schema);
85: 	}
86: 
87: 	unordered_set<CatalogEntry *> dependencies;
88: 	auto entry = make_unique<SchemaCatalogEntry>(this, info->schema);
89: 	auto result = entry.get();
90: 	if (!schemas->CreateEntry(context.ActiveTransaction(), info->schema, move(entry), dependencies)) {
91: 		if (info->on_conflict == OnCreateConflict::ERROR) {
92: 			throw CatalogException("Schema with name %s already exists!", info->schema);
93: 		} else {
94: 			assert(info->on_conflict == OnCreateConflict::IGNORE);
95: 		}
96: 		return nullptr;
97: 	}
98: 	return result;
99: }
100: 
101: void Catalog::DropSchema(ClientContext &context, DropInfo *info) {
102: 	if (info->name == INVALID_SCHEMA) {
103: 		throw CatalogException("Schema not specified");
104: 	}
105: 	if (info->name == DEFAULT_SCHEMA || info->name == TEMP_SCHEMA) {
106: 		throw CatalogException("Cannot drop schema \"%s\" because it is required by the database system", info->name);
107: 	}
108: 
109: 	if (!schemas->DropEntry(context.ActiveTransaction(), info->name, info->cascade)) {
110: 		if (!info->if_exists) {
111: 			throw CatalogException("Schema with name \"%s\" does not exist!", info->name);
112: 		}
113: 	}
114: }
115: 
116: void Catalog::DropEntry(ClientContext &context, DropInfo *info) {
117: 	if (info->type == CatalogType::SCHEMA_ENTRY) {
118: 		// DROP SCHEMA
119: 		DropSchema(context, info);
120: 	} else {
121: 		if (info->schema == INVALID_SCHEMA) {
122: 			// invalid schema: check if the entry is in the temp schema
123: 			auto entry = GetEntry(context, info->type, TEMP_SCHEMA, info->name, true);
124: 			info->schema = entry ? TEMP_SCHEMA : DEFAULT_SCHEMA;
125: 		}
126: 		auto schema = GetSchema(context, info->schema);
127: 		schema->DropEntry(context, info);
128: 	}
129: }
130: 
131: SchemaCatalogEntry *Catalog::GetSchema(ClientContext &context, const string &schema_name) {
132: 	if (schema_name == INVALID_SCHEMA) {
133: 		throw CatalogException("Schema not specified");
134: 	}
135: 	if (schema_name == TEMP_SCHEMA) {
136: 		return context.temporary_objects.get();
137: 	}
138: 	auto entry = schemas->GetEntry(context.ActiveTransaction(), schema_name);
139: 	if (!entry) {
140: 		throw CatalogException("Schema with name %s does not exist!", schema_name);
141: 	}
142: 	return (SchemaCatalogEntry *)entry;
143: }
144: 
145: CatalogEntry *Catalog::GetEntry(ClientContext &context, CatalogType type, string schema_name, const string &name,
146:                                 bool if_exists) {
147: 	if (schema_name == INVALID_SCHEMA) {
148: 		// invalid schema: first search the temporary schema
149: 		auto entry = GetEntry(context, type, TEMP_SCHEMA, name, true);
150: 		if (entry) {
151: 			return entry;
152: 		}
153: 		// if the entry does not exist in the temp schema, search in the default schema
154: 		schema_name = DEFAULT_SCHEMA;
155: 	}
156: 	auto schema = GetSchema(context, schema_name);
157: 	return schema->GetEntry(context, type, name, if_exists);
158: }
159: 
160: template <>
161: TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists) {
162: 	auto entry = GetEntry(context, CatalogType::TABLE_ENTRY, move(schema_name), name, if_exists);
163: 	if (!entry) {
164: 		return nullptr;
165: 	}
166: 	if (entry->type != CatalogType::TABLE_ENTRY) {
167: 		throw CatalogException("%s is not a table", name);
168: 	}
169: 	return (TableCatalogEntry *)entry;
170: }
171: 
172: template <>
173: SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
174:                                         bool if_exists) {
175: 	return (SequenceCatalogEntry *)GetEntry(context, CatalogType::SEQUENCE_ENTRY, move(schema_name), name, if_exists);
176: }
177: 
178: template <>
179: TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
180:                                              bool if_exists) {
181: 	return (TableFunctionCatalogEntry *)GetEntry(context, CatalogType::TABLE_FUNCTION_ENTRY, move(schema_name), name,
182: 	                                             if_exists);
183: }
184: 
185: template <>
186: CopyFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
187:                                             bool if_exists) {
188: 	return (CopyFunctionCatalogEntry *)GetEntry(context, CatalogType::COPY_FUNCTION_ENTRY, move(schema_name), name,
189: 	                                            if_exists);
190: }
191: 
192: template <>
193: PragmaFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
194:                                               bool if_exists) {
195: 	return (PragmaFunctionCatalogEntry *)GetEntry(context, CatalogType::PRAGMA_FUNCTION_ENTRY, move(schema_name), name,
196: 	                                              if_exists);
197: }
198: 
199: template <>
200: AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
201:                                                  bool if_exists) {
202: 	auto entry = GetEntry(context, CatalogType::AGGREGATE_FUNCTION_ENTRY, move(schema_name), name, if_exists);
203: 	if (entry->type != CatalogType::AGGREGATE_FUNCTION_ENTRY) {
204: 		throw CatalogException("%s is not an aggregate function", name);
205: 	}
206: 	return (AggregateFunctionCatalogEntry *)entry;
207: }
208: 
209: template <>
210: CollateCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists) {
211: 	return (CollateCatalogEntry *)GetEntry(context, CatalogType::COLLATION_ENTRY, move(schema_name), name, if_exists);
212: }
213: 
214: void Catalog::AlterTable(ClientContext &context, AlterTableInfo *info) {
215: 	if (info->schema == INVALID_SCHEMA) {
216: 		// invalid schema, look for table in temp schema
217: 		auto entry = GetEntry(context, CatalogType::TABLE_ENTRY, TEMP_SCHEMA, info->table, true);
218: 		info->schema = entry ? TEMP_SCHEMA : DEFAULT_SCHEMA;
219: 	}
220: 	auto schema = GetSchema(context, info->schema);
221: 	schema->AlterTable(context, info);
222: }
223: 
224: void Catalog::ParseRangeVar(string input, string &schema, string &name) {
225: 	idx_t idx = 0;
226: 	vector<string> entries;
227: 	string entry;
228: normal:
229: 	// quote
230: 	for (; idx < input.size(); idx++) {
231: 		if (input[idx] == '"') {
232: 			idx++;
233: 			goto quoted;
234: 		} else if (input[idx] == '.') {
235: 			goto separator;
236: 		}
237: 		entry += input[idx];
238: 	}
239: 	goto end;
240: separator:
241: 	entries.push_back(entry);
242: 	entry = "";
243: 	idx++;
244: 	goto normal;
245: quoted:
246: 	// look for another quote
247: 	for (; idx < input.size(); idx++) {
248: 		if (input[idx] == '"') {
249: 			// unquote
250: 			idx++;
251: 			goto normal;
252: 		}
253: 		entry += input[idx];
254: 	}
255: 	throw ParserException("Unterminated quote in range var!");
256: end:
257: 	if (entries.size() == 0) {
258: 		schema = INVALID_SCHEMA;
259: 		name = entry;
260: 	} else if (entries.size() == 1) {
261: 		schema = entries[0];
262: 		name = entry;
263: 	} else {
264: 		throw ParserException("Expected schema.entry or entry: too many entries found");
265: 	}
266: }
267: 
268: } // namespace duckdb
[end of src/catalog/catalog.cpp]
[start of src/catalog/catalog_entry/schema_catalog_entry.cpp]
1: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/catalog/catalog_entry/index_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp"
6: #include "duckdb/catalog/catalog_entry/collate_catalog_entry.hpp"
7: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
8: #include "duckdb/catalog/catalog_entry/sequence_catalog_entry.hpp"
9: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
10: #include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
11: #include "duckdb/catalog/catalog_entry/copy_function_catalog_entry.hpp"
12: #include "duckdb/catalog/catalog_entry/pragma_function_catalog_entry.hpp"
13: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
14: #include "duckdb/common/exception.hpp"
15: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
16: #include "duckdb/parser/parsed_data/create_index_info.hpp"
17: #include "duckdb/parser/parsed_data/create_scalar_function_info.hpp"
18: #include "duckdb/parser/parsed_data/create_copy_function_info.hpp"
19: #include "duckdb/parser/parsed_data/create_pragma_function_info.hpp"
20: #include "duckdb/parser/parsed_data/create_collation_info.hpp"
21: #include "duckdb/parser/parsed_data/create_schema_info.hpp"
22: #include "duckdb/parser/parsed_data/create_sequence_info.hpp"
23: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
24: #include "duckdb/parser/parsed_data/create_view_info.hpp"
25: #include "duckdb/parser/parsed_data/drop_info.hpp"
26: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
27: #include "duckdb/transaction/transaction.hpp"
28: 
29: #include <algorithm>
30: #include <sstream>
31: 
32: namespace duckdb {
33: using namespace std;
34: 
35: SchemaCatalogEntry::SchemaCatalogEntry(Catalog *catalog, string name)
36:     : CatalogEntry(CatalogType::SCHEMA_ENTRY, catalog, name), tables(*catalog), indexes(*catalog),
37:       table_functions(*catalog), copy_functions(*catalog), pragma_functions(*catalog), functions(*catalog),
38:       sequences(*catalog), collations(*catalog) {
39: }
40: 
41: CatalogEntry *SchemaCatalogEntry::AddEntry(ClientContext &context, unique_ptr<StandardEntry> entry,
42:                                            OnCreateConflict on_conflict, unordered_set<CatalogEntry *> dependencies) {
43: 	auto entry_name = entry->name;
44: 	auto entry_type = entry->type;
45: 	auto result = entry.get();
46: 	auto &transaction = Transaction::GetTransaction(context);
47: 
48: 	// first find the set for this entry
49: 	auto &set = GetCatalogSet(entry_type);
50: 
51: 	if (name != TEMP_SCHEMA) {
52: 		dependencies.insert(this);
53: 	} else {
54: 		entry->temporary = true;
55: 	}
56: 	if (on_conflict == OnCreateConflict::REPLACE) {
57: 		// CREATE OR REPLACE: first try to drop the entry
58: 		auto old_entry = set.GetEntry(transaction, entry_name);
59: 		if (old_entry) {
60: 			if (old_entry->type != entry_type) {
61: 				throw CatalogException("Existing object %s is of type %s, trying to replace with type %s", entry_name,
62: 				                       CatalogTypeToString(old_entry->type), CatalogTypeToString(entry_type));
63: 			}
64: 			(void)set.DropEntry(transaction, entry_name, false);
65: 		}
66: 	}
67: 	// now try to add the entry
68: 	if (!set.CreateEntry(transaction, entry_name, move(entry), dependencies)) {
69: 		// entry already exists!
70: 		if (on_conflict == OnCreateConflict::ERROR) {
71: 			throw CatalogException("%s with name \"%s\" already exists!", CatalogTypeToString(entry_type), entry_name);
72: 		} else {
73: 			return nullptr;
74: 		}
75: 	}
76: 	return result;
77: }
78: 
79: CatalogEntry *SchemaCatalogEntry::AddEntry(ClientContext &context, unique_ptr<StandardEntry> entry,
80:                                            OnCreateConflict on_conflict) {
81: 	unordered_set<CatalogEntry *> dependencies;
82: 	return AddEntry(context, move(entry), on_conflict, dependencies);
83: }
84: 
85: CatalogEntry *SchemaCatalogEntry::CreateSequence(ClientContext &context, CreateSequenceInfo *info) {
86: 	auto sequence = make_unique<SequenceCatalogEntry>(catalog, this, info);
87: 	return AddEntry(context, move(sequence), info->on_conflict);
88: }
89: 
90: CatalogEntry *SchemaCatalogEntry::CreateTable(ClientContext &context, BoundCreateTableInfo *info) {
91: 	auto table = make_unique<TableCatalogEntry>(catalog, this, info);
92: 	return AddEntry(context, move(table), info->Base().on_conflict, info->dependencies);
93: }
94: 
95: CatalogEntry *SchemaCatalogEntry::CreateView(ClientContext &context, CreateViewInfo *info) {
96: 	auto view = make_unique<ViewCatalogEntry>(catalog, this, info);
97: 	return AddEntry(context, move(view), info->on_conflict);
98: }
99: 
100: CatalogEntry *SchemaCatalogEntry::CreateIndex(ClientContext &context, CreateIndexInfo *info) {
101: 	auto index = make_unique<IndexCatalogEntry>(catalog, this, info);
102: 	return AddEntry(context, move(index), info->on_conflict);
103: }
104: 
105: CatalogEntry *SchemaCatalogEntry::CreateCollation(ClientContext &context, CreateCollationInfo *info) {
106: 	auto collation = make_unique<CollateCatalogEntry>(catalog, this, info);
107: 	return AddEntry(context, move(collation), info->on_conflict);
108: }
109: 
110: CatalogEntry *SchemaCatalogEntry::CreateTableFunction(ClientContext &context, CreateTableFunctionInfo *info) {
111: 	auto table_function = make_unique<TableFunctionCatalogEntry>(catalog, this, info);
112: 	return AddEntry(context, move(table_function), info->on_conflict);
113: }
114: 
115: CatalogEntry *SchemaCatalogEntry::CreateCopyFunction(ClientContext &context, CreateCopyFunctionInfo *info) {
116: 	auto copy_function = make_unique<CopyFunctionCatalogEntry>(catalog, this, info);
117: 	return AddEntry(context, move(copy_function), info->on_conflict);
118: }
119: 
120: CatalogEntry *SchemaCatalogEntry::CreatePragmaFunction(ClientContext &context, CreatePragmaFunctionInfo *info) {
121: 	auto pragma_function = make_unique<PragmaFunctionCatalogEntry>(catalog, this, info);
122: 	return AddEntry(context, move(pragma_function), info->on_conflict);
123: }
124: 
125: CatalogEntry *SchemaCatalogEntry::CreateFunction(ClientContext &context, CreateFunctionInfo *info) {
126: 	unique_ptr<StandardEntry> function;
127: 	if (info->type == CatalogType::SCALAR_FUNCTION_ENTRY) {
128: 		// create a scalar function
129: 		function = make_unique_base<StandardEntry, ScalarFunctionCatalogEntry>(catalog, this,
130: 		                                                                       (CreateScalarFunctionInfo *)info);
131: 	} else {
132: 		assert(info->type == CatalogType::AGGREGATE_FUNCTION_ENTRY);
133: 		// create an aggregate function
134: 		function = make_unique_base<StandardEntry, AggregateFunctionCatalogEntry>(catalog, this,
135: 		                                                                          (CreateAggregateFunctionInfo *)info);
136: 	}
137: 	return AddEntry(context, move(function), info->on_conflict);
138: }
139: 
140: void SchemaCatalogEntry::DropEntry(ClientContext &context, DropInfo *info) {
141: 	auto &set = GetCatalogSet(info->type);
142: 	auto &transaction = Transaction::GetTransaction(context);
143: 
144: 	// first find the entry
145: 	auto existing_entry = set.GetEntry(transaction, info->name);
146: 	if (!existing_entry) {
147: 		if (!info->if_exists) {
148: 			throw CatalogException("%s with name \"%s\" does not exist!", CatalogTypeToString(info->type), info->name);
149: 		}
150: 		return;
151: 	}
152: 	if (existing_entry->type != info->type) {
153: 		throw CatalogException("Existing object %s is of type %s, trying to replace with type %s", info->name,
154: 		                       CatalogTypeToString(existing_entry->type), CatalogTypeToString(info->type));
155: 	}
156: 	if (!set.DropEntry(transaction, info->name, info->cascade)) {
157: 		throw InternalException("Could not drop element because of an internal error");
158: 	}
159: }
160: 
161: void SchemaCatalogEntry::AlterTable(ClientContext &context, AlterTableInfo *info) {
162: 	switch (info->alter_table_type) {
163: 	case AlterTableType::RENAME_TABLE: {
164: 		auto &transaction = Transaction::GetTransaction(context);
165: 		auto entry = tables.GetEntry(transaction, info->table);
166: 		if (entry == nullptr) {
167: 			throw CatalogException("Table \"%s\" doesn't exist!", info->table);
168: 		}
169: 		assert(entry->type == CatalogType::TABLE_ENTRY);
170: 
171: 		auto copied_entry = entry->Copy(context);
172: 
173: 		// Drop the old table entry
174: 		if (!tables.DropEntry(transaction, info->table, false)) {
175: 			throw CatalogException("Could not drop \"%s\" entry!", info->table);
176: 		}
177: 
178: 		// Create a new table entry
179: 		auto &new_table = ((RenameTableInfo *)info)->new_table_name;
180: 		unordered_set<CatalogEntry *> dependencies;
181: 		copied_entry->name = new_table;
182: 		if (!tables.CreateEntry(transaction, new_table, move(copied_entry), dependencies)) {
183: 			throw CatalogException("Could not create \"%s\" entry!", new_table);
184: 		}
185: 		break;
186: 	}
187: 	default:
188: 		if (!tables.AlterEntry(context, info->table, info)) {
189: 			throw CatalogException("Table with name \"%s\" does not exist!", info->table);
190: 		}
191: 	} // end switch
192: }
193: 
194: CatalogEntry *SchemaCatalogEntry::GetEntry(ClientContext &context, CatalogType type, const string &name,
195:                                            bool if_exists) {
196: 	auto &set = GetCatalogSet(type);
197: 	auto &transaction = Transaction::GetTransaction(context);
198: 
199: 	auto entry = set.GetEntry(transaction, name);
200: 	if (!entry) {
201: 		if (!if_exists) {
202: 			throw CatalogException("%s with name %s does not exist!", CatalogTypeToString(type), name);
203: 		}
204: 		return nullptr;
205: 	}
206: 	return entry;
207: }
208: 
209: void SchemaCatalogEntry::Serialize(Serializer &serializer) {
210: 	serializer.WriteString(name);
211: }
212: 
213: unique_ptr<CreateSchemaInfo> SchemaCatalogEntry::Deserialize(Deserializer &source) {
214: 	auto info = make_unique<CreateSchemaInfo>();
215: 	info->schema = source.Read<string>();
216: 	return info;
217: }
218: 
219: string SchemaCatalogEntry::ToSQL() {
220: 	stringstream ss;
221: 	ss << "CREATE SCHEMA " << name << ";";
222: 	return ss.str();
223: }
224: 
225: CatalogSet &SchemaCatalogEntry::GetCatalogSet(CatalogType type) {
226: 	switch (type) {
227: 	case CatalogType::VIEW_ENTRY:
228: 	case CatalogType::TABLE_ENTRY:
229: 		return tables;
230: 	case CatalogType::INDEX_ENTRY:
231: 		return indexes;
232: 	case CatalogType::TABLE_FUNCTION_ENTRY:
233: 		return table_functions;
234: 	case CatalogType::COPY_FUNCTION_ENTRY:
235: 		return copy_functions;
236: 	case CatalogType::PRAGMA_FUNCTION_ENTRY:
237: 		return pragma_functions;
238: 	case CatalogType::AGGREGATE_FUNCTION_ENTRY:
239: 	case CatalogType::SCALAR_FUNCTION_ENTRY:
240: 		return functions;
241: 	case CatalogType::SEQUENCE_ENTRY:
242: 		return sequences;
243: 	case CatalogType::COLLATION_ENTRY:
244: 		return collations;
245: 	default:
246: 		throw CatalogException("Unsupported catalog type in schema");
247: 	}
248: }
249: 
250: } // namespace duckdb
[end of src/catalog/catalog_entry/schema_catalog_entry.cpp]
[start of src/catalog/catalog_entry/view_catalog_entry.cpp]
1: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
4: #include "duckdb/common/exception.hpp"
5: #include "duckdb/common/serializer.hpp"
6: #include "duckdb/parser/parsed_data/create_view_info.hpp"
7: #include "duckdb/common/limits.hpp"
8: 
9: #include <algorithm>
10: 
11: namespace duckdb {
12: using namespace std;
13: 
14: void ViewCatalogEntry::Initialize(CreateViewInfo *info) {
15: 	query = move(info->query);
16: 	this->aliases = info->aliases;
17: 	this->types = info->types;
18: 	this->temporary = info->temporary;
19: 	this->sql = info->sql;
20: }
21: 
22: ViewCatalogEntry::ViewCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schema, CreateViewInfo *info)
23:     : StandardEntry(CatalogType::VIEW_ENTRY, schema, catalog, info->view_name) {
24: 	Initialize(info);
25: }
26: 
27: void ViewCatalogEntry::Serialize(Serializer &serializer) {
28: 	serializer.WriteString(schema->name);
29: 	serializer.WriteString(name);
30: 	serializer.WriteString(sql);
31: 	query->Serialize(serializer);
32: 	assert(aliases.size() <= NumericLimits<uint32_t>::Maximum());
33: 	serializer.Write<uint32_t>((uint32_t)aliases.size());
34: 	for (auto &alias : aliases) {
35: 		serializer.WriteString(alias);
36: 	}
37: 	serializer.Write<uint32_t>((uint32_t)types.size());
38: 	for (auto &sql_type : types) {
39: 		sql_type.Serialize(serializer);
40: 	}
41: }
42: 
43: unique_ptr<CreateViewInfo> ViewCatalogEntry::Deserialize(Deserializer &source) {
44: 	auto info = make_unique<CreateViewInfo>();
45: 	info->schema = source.Read<string>();
46: 	info->view_name = source.Read<string>();
47: 	info->sql = source.Read<string>();
48: 	info->query = QueryNode::Deserialize(source);
49: 	auto alias_count = source.Read<uint32_t>();
50: 	for (uint32_t i = 0; i < alias_count; i++) {
51: 		info->aliases.push_back(source.Read<string>());
52: 	}
53: 	auto type_count = source.Read<uint32_t>();
54: 	for (uint32_t i = 0; i < type_count; i++) {
55: 		info->types.push_back(LogicalType::Deserialize(source));
56: 	}
57: 	return info;
58: }
59: 
60: string ViewCatalogEntry::ToSQL() {
61: 	if (sql.size() == 0) {
62: 		throw NotImplementedException("Cannot convert VIEW to SQL because it was not created with a SQL statement");
63: 	}
64: 	return sql + "\n;";
65: }
66: 
67: } // namespace duckdb
[end of src/catalog/catalog_entry/view_catalog_entry.cpp]
[start of src/include/duckdb/catalog/catalog.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/catalog/catalog.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/catalog_entry.hpp"
12: #include "duckdb/common/mutex.hpp"
13: 
14: namespace duckdb {
15: struct CreateSchemaInfo;
16: struct DropInfo;
17: struct BoundCreateTableInfo;
18: struct AlterTableInfo;
19: struct CreateTableFunctionInfo;
20: struct CreateCopyFunctionInfo;
21: struct CreatePragmaFunctionInfo;
22: struct CreateFunctionInfo;
23: struct CreateViewInfo;
24: struct CreateSequenceInfo;
25: struct CreateCollationInfo;
26: 
27: class ClientContext;
28: class Transaction;
29: 
30: class AggregateFunctionCatalogEntry;
31: class CollateCatalogEntry;
32: class SchemaCatalogEntry;
33: class TableCatalogEntry;
34: class SequenceCatalogEntry;
35: class TableFunctionCatalogEntry;
36: class CopyFunctionCatalogEntry;
37: class PragmaFunctionCatalogEntry;
38: class StorageManager;
39: class CatalogSet;
40: class DependencyManager;
41: 
42: //! The Catalog object represents the catalog of the database.
43: class Catalog {
44: public:
45: 	Catalog(StorageManager &storage);
46: 	~Catalog();
47: 
48: 	//! Reference to the storage manager
49: 	StorageManager &storage;
50: 	//! The catalog set holding the schemas
51: 	unique_ptr<CatalogSet> schemas;
52: 	//! The DependencyManager manages dependencies between different catalog objects
53: 	unique_ptr<DependencyManager> dependency_manager;
54: 	//! Write lock for the catalog
55: 	mutex write_lock;
56: 
57: public:
58: 	//! Get the ClientContext from the Catalog
59: 	static Catalog &GetCatalog(ClientContext &context);
60: 
61: 	//! Creates a schema in the catalog.
62: 	CatalogEntry *CreateSchema(ClientContext &context, CreateSchemaInfo *info);
63: 	//! Creates a table in the catalog.
64: 	CatalogEntry *CreateTable(ClientContext &context, BoundCreateTableInfo *info);
65: 	//! Create a table function in the catalog
66: 	CatalogEntry *CreateTableFunction(ClientContext &context, CreateTableFunctionInfo *info);
67: 	//! Create a copy function in the catalog
68: 	CatalogEntry *CreateCopyFunction(ClientContext &context, CreateCopyFunctionInfo *info);
69: 	//! Create a pragma function in the catalog
70: 	CatalogEntry *CreatePragmaFunction(ClientContext &context, CreatePragmaFunctionInfo *info);
71: 	//! Create a scalar or aggregate function in the catalog
72: 	CatalogEntry *CreateFunction(ClientContext &context, CreateFunctionInfo *info);
73: 	//! Creates a table in the catalog.
74: 	CatalogEntry *CreateView(ClientContext &context, CreateViewInfo *info);
75: 	//! Creates a table in the catalog.
76: 	CatalogEntry *CreateSequence(ClientContext &context, CreateSequenceInfo *info);
77: 	//! Creates a collation in the catalog
78: 	CatalogEntry *CreateCollation(ClientContext &context, CreateCollationInfo *info);
79: 
80: 	//! Drops an entry from the catalog
81: 	void DropEntry(ClientContext &context, DropInfo *info);
82: 
83: 	//! Returns the schema object with the specified name, or throws an exception if it does not exist
84: 	SchemaCatalogEntry *GetSchema(ClientContext &context, const string &name = DEFAULT_SCHEMA);
85: 	//! Gets the "schema.name" entry of the specified type, if if_exists=true returns nullptr if entry does not exist,
86: 	//! otherwise an exception is thrown
87: 	CatalogEntry *GetEntry(ClientContext &context, CatalogType type, string schema, const string &name,
88: 	                       bool if_exists = false);
89: 	template <class T>
90: 	T *GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists = false);
91: 
92: 	//! Alter an existing table in the catalog.
93: 	void AlterTable(ClientContext &context, AlterTableInfo *info);
94: 
95: 	//! Parse the (optional) schema and a name from a string in the format of e.g. "schema"."table"; if there is no dot
96: 	//! the schema will be set to DEFAULT_SCHEMA
97: 	static void ParseRangeVar(string input, string &schema, string &name);
98: 
99: private:
100: 	void DropSchema(ClientContext &context, DropInfo *info);
101: };
102: 
103: template <>
104: TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists);
105: template <>
106: SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists);
107: template <>
108: TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
109:                                              bool if_exists);
110: template <>
111: CopyFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
112:                                             bool if_exists);
113: template <>
114: PragmaFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
115:                                               bool if_exists);
116: template <>
117: AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
118:                                                  bool if_exists);
119: template <>
120: CollateCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists);
121: 
122: } // namespace duckdb
[end of src/include/duckdb/catalog/catalog.hpp]
[start of src/include/duckdb/catalog/catalog_entry/view_catalog_entry.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/catalog/catalog_entry/view_catalog_entry.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/standard_entry.hpp"
12: #include "duckdb/parser/query_node.hpp"
13: #include "duckdb/common/types.hpp"
14: #include "duckdb/common/vector.hpp"
15: 
16: namespace duckdb {
17: 
18: class ColumnStatistics;
19: class DataTable;
20: struct CreateViewInfo;
21: 
22: //! A view catalog entry
23: class ViewCatalogEntry : public StandardEntry {
24: public:
25: 	//! Create a real TableCatalogEntry and initialize storage for it
26: 	ViewCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schema, CreateViewInfo *info);
27: 
28: 	//! The query of the view
29: 	unique_ptr<QueryNode> query;
30: 	//! The SQL query (if any)
31: 	string sql;
32: 	//! The set of aliases associated with the view
33: 	vector<string> aliases;
34: 	//! The returned types of the view
35: 	vector<LogicalType> types;
36: 
37: public:
38: 	//! Serialize the meta information of the ViewCatalogEntry a serializer
39: 	virtual void Serialize(Serializer &serializer);
40: 	//! Deserializes to a CreateTableInfo
41: 	static unique_ptr<CreateViewInfo> Deserialize(Deserializer &source);
42: 
43: 	string ToSQL() override;
44: 
45: private:
46: 	void Initialize(CreateViewInfo *info);
47: };
48: } // namespace duckdb
[end of src/include/duckdb/catalog/catalog_entry/view_catalog_entry.hpp]
[start of src/include/duckdb/parser/parsed_data/alter_table_info.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parser/parsed_data/alter_table_info.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/parser/parsed_data/parse_info.hpp"
12: #include "duckdb/parser/column_definition.hpp"
13: 
14: namespace duckdb {
15: 
16: enum class AlterType : uint8_t { INVALID = 0, ALTER_TABLE = 1 };
17: 
18: struct AlterInfo : public ParseInfo {
19: 	AlterInfo(AlterType type) : type(type) {
20: 	}
21: 	virtual ~AlterInfo() {
22: 	}
23: 
24: 	AlterType type;
25: 
26: 	virtual void Serialize(Serializer &serializer);
27: 	static unique_ptr<AlterInfo> Deserialize(Deserializer &source);
28: };
29: 
30: enum class AlterTableType : uint8_t {
31: 	INVALID = 0,
32: 	RENAME_COLUMN = 1,
33: 	RENAME_TABLE = 2,
34: 	ADD_COLUMN = 3,
35: 	REMOVE_COLUMN = 4,
36: 	ALTER_COLUMN_TYPE = 5,
37: 	SET_DEFAULT = 6
38: };
39: 
40: struct AlterTableInfo : public AlterInfo {
41: 	AlterTableInfo(AlterTableType type, string schema, string table)
42: 	    : AlterInfo(AlterType::ALTER_TABLE), alter_table_type(type), schema(schema), table(table) {
43: 	}
44: 	virtual ~AlterTableInfo() override {
45: 	}
46: 
47: 	AlterTableType alter_table_type;
48: 	//! Schema name to alter to
49: 	string schema;
50: 	//! Table name to alter to
51: 	string table;
52: 
53: public:
54: 	virtual void Serialize(Serializer &serializer) override;
55: 	static unique_ptr<AlterInfo> Deserialize(Deserializer &source);
56: };
57: 
58: //===--------------------------------------------------------------------===//
59: // RenameColumnInfo
60: //===--------------------------------------------------------------------===//
61: struct RenameColumnInfo : public AlterTableInfo {
62: 	RenameColumnInfo(string schema, string table, string name, string new_name)
63: 	    : AlterTableInfo(AlterTableType::RENAME_COLUMN, schema, table), name(name), new_name(new_name) {
64: 	}
65: 	~RenameColumnInfo() override {
66: 	}
67: 
68: 	//! Column old name
69: 	string name;
70: 	//! Column new name
71: 	string new_name;
72: 
73: public:
74: 	void Serialize(Serializer &serializer) override;
75: 	static unique_ptr<AlterInfo> Deserialize(Deserializer &source, string schema, string table);
76: };
77: 
78: //===--------------------------------------------------------------------===//
79: // RenameTableInfo
80: //===--------------------------------------------------------------------===//
81: struct RenameTableInfo : public AlterTableInfo {
82: 	RenameTableInfo(string schema, string table, string new_name)
83: 	    : AlterTableInfo(AlterTableType::RENAME_TABLE, schema, table), new_table_name(new_name) {
84: 	}
85: 	~RenameTableInfo() override {
86: 	}
87: 
88: 	//! Table new name
89: 	string new_table_name;
90: 
91: public:
92: 	void Serialize(Serializer &serializer) override;
93: 	static unique_ptr<AlterInfo> Deserialize(Deserializer &source, string schema, string table);
94: };
95: 
96: //===--------------------------------------------------------------------===//
97: // AddColumnInfo
98: //===--------------------------------------------------------------------===//
99: struct AddColumnInfo : public AlterTableInfo {
100: 	AddColumnInfo(string schema, string table, ColumnDefinition new_column)
101: 	    : AlterTableInfo(AlterTableType::ADD_COLUMN, schema, table), new_column(move(new_column)) {
102: 	}
103: 	~AddColumnInfo() override {
104: 	}
105: 
106: 	//! New column
107: 	ColumnDefinition new_column;
108: 
109: public:
110: 	void Serialize(Serializer &serializer) override;
111: 	static unique_ptr<AlterInfo> Deserialize(Deserializer &source, string schema, string table);
112: };
113: 
114: //===--------------------------------------------------------------------===//
115: // RemoveColumnInfo
116: //===--------------------------------------------------------------------===//
117: struct RemoveColumnInfo : public AlterTableInfo {
118: 	RemoveColumnInfo(string schema, string table, string removed_column, bool if_exists)
119: 	    : AlterTableInfo(AlterTableType::REMOVE_COLUMN, schema, table), removed_column(move(removed_column)),
120: 	      if_exists(if_exists) {
121: 	}
122: 	~RemoveColumnInfo() override {
123: 	}
124: 
125: 	//! The column to remove
126: 	string removed_column;
127: 	//! Whether or not an error should be thrown if the column does not exist
128: 	bool if_exists;
129: 
130: public:
131: 	void Serialize(Serializer &serializer) override;
132: 	static unique_ptr<AlterInfo> Deserialize(Deserializer &source, string schema, string table);
133: };
134: 
135: //===--------------------------------------------------------------------===//
136: // ChangeColumnTypeInfo
137: //===--------------------------------------------------------------------===//
138: struct ChangeColumnTypeInfo : public AlterTableInfo {
139: 	ChangeColumnTypeInfo(string schema, string table, string column_name, LogicalType target_type,
140: 	                     unique_ptr<ParsedExpression> expression)
141: 	    : AlterTableInfo(AlterTableType::ALTER_COLUMN_TYPE, schema, table), column_name(move(column_name)),
142: 	      target_type(move(target_type)), expression(move(expression)) {
143: 	}
144: 	~ChangeColumnTypeInfo() override {
145: 	}
146: 
147: 	//! The column name to alter
148: 	string column_name;
149: 	//! The target type of the column
150: 	LogicalType target_type;
151: 	//! The expression used for data conversion
152: 	unique_ptr<ParsedExpression> expression;
153: 
154: public:
155: 	void Serialize(Serializer &serializer) override;
156: 	static unique_ptr<AlterInfo> Deserialize(Deserializer &source, string schema, string table);
157: };
158: 
159: //===--------------------------------------------------------------------===//
160: // SetDefaultInfo
161: //===--------------------------------------------------------------------===//
162: struct SetDefaultInfo : public AlterTableInfo {
163: 	SetDefaultInfo(string schema, string table, string column_name, unique_ptr<ParsedExpression> new_default)
164: 	    : AlterTableInfo(AlterTableType::SET_DEFAULT, schema, table), column_name(move(column_name)),
165: 	      expression(move(new_default)) {
166: 	}
167: 	~SetDefaultInfo() override {
168: 	}
169: 
170: 	//! The column name to alter
171: 	string column_name;
172: 	//! The expression used for data conversion
173: 	unique_ptr<ParsedExpression> expression;
174: 
175: public:
176: 	void Serialize(Serializer &serializer) override;
177: 	static unique_ptr<AlterInfo> Deserialize(Deserializer &source, string schema, string table);
178: };
179: 
180: } // namespace duckdb
[end of src/include/duckdb/parser/parsed_data/alter_table_info.hpp]
[start of src/parser/parsed_data/alter_table_info.cpp]
1: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
2: #include "duckdb/common/serializer.hpp"
3: 
4: namespace duckdb {
5: using namespace std;
6: 
7: void AlterInfo::Serialize(Serializer &serializer) {
8: 	serializer.Write<AlterType>(type);
9: }
10: 
11: unique_ptr<AlterInfo> AlterInfo::Deserialize(Deserializer &source) {
12: 	auto type = source.Read<AlterType>();
13: 	switch (type) {
14: 	case AlterType::ALTER_TABLE:
15: 		return AlterTableInfo::Deserialize(source);
16: 	default:
17: 		throw SerializationException("Unknown alter type for deserialization!");
18: 	}
19: }
20: 
21: void AlterTableInfo::Serialize(Serializer &serializer) {
22: 	AlterInfo::Serialize(serializer);
23: 	serializer.Write<AlterTableType>(alter_table_type);
24: 	serializer.WriteString(schema);
25: 	serializer.WriteString(table);
26: }
27: 
28: unique_ptr<AlterInfo> AlterTableInfo::Deserialize(Deserializer &source) {
29: 	auto type = source.Read<AlterTableType>();
30: 	auto schema = source.Read<string>();
31: 	auto table = source.Read<string>();
32: 	unique_ptr<AlterTableInfo> info;
33: 	switch (type) {
34: 	case AlterTableType::RENAME_COLUMN:
35: 		return RenameColumnInfo::Deserialize(source, schema, table);
36: 	case AlterTableType::RENAME_TABLE:
37: 		return RenameTableInfo::Deserialize(source, schema, table);
38: 	case AlterTableType::ADD_COLUMN:
39: 		return AddColumnInfo::Deserialize(source, schema, table);
40: 	case AlterTableType::REMOVE_COLUMN:
41: 		return RemoveColumnInfo::Deserialize(source, schema, table);
42: 	case AlterTableType::ALTER_COLUMN_TYPE:
43: 		return ChangeColumnTypeInfo::Deserialize(source, schema, table);
44: 	case AlterTableType::SET_DEFAULT:
45: 		return SetDefaultInfo::Deserialize(source, schema, table);
46: 	default:
47: 		throw SerializationException("Unknown alter table type for deserialization!");
48: 	}
49: }
50: 
51: //===--------------------------------------------------------------------===//
52: // RenameColumnInfo
53: //===--------------------------------------------------------------------===//
54: void RenameColumnInfo::Serialize(Serializer &serializer) {
55: 	AlterTableInfo::Serialize(serializer);
56: 	serializer.WriteString(name);
57: 	serializer.WriteString(new_name);
58: }
59: 
60: unique_ptr<AlterInfo> RenameColumnInfo::Deserialize(Deserializer &source, string schema, string table) {
61: 	auto name = source.Read<string>();
62: 	auto new_name = source.Read<string>();
63: 	return make_unique<RenameColumnInfo>(schema, table, name, new_name);
64: }
65: 
66: //===--------------------------------------------------------------------===//
67: // RenameTableInfo
68: //===--------------------------------------------------------------------===//
69: void RenameTableInfo::Serialize(Serializer &serializer) {
70: 	AlterTableInfo::Serialize(serializer);
71: 	serializer.WriteString(new_table_name);
72: }
73: 
74: unique_ptr<AlterInfo> RenameTableInfo::Deserialize(Deserializer &source, string schema, string table) {
75: 	auto new_name = source.Read<string>();
76: 	return make_unique<RenameTableInfo>(schema, table, new_name);
77: }
78: 
79: //===--------------------------------------------------------------------===//
80: // AddColumnInfo
81: //===--------------------------------------------------------------------===//
82: void AddColumnInfo::Serialize(Serializer &serializer) {
83: 	AlterTableInfo::Serialize(serializer);
84: 	new_column.Serialize(serializer);
85: }
86: 
87: unique_ptr<AlterInfo> AddColumnInfo::Deserialize(Deserializer &source, string schema, string table) {
88: 	auto new_column = ColumnDefinition::Deserialize(source);
89: 	return make_unique<AddColumnInfo>(schema, table, move(new_column));
90: }
91: 
92: //===--------------------------------------------------------------------===//
93: // RemoveColumnInfo
94: //===--------------------------------------------------------------------===//
95: void RemoveColumnInfo::Serialize(Serializer &serializer) {
96: 	AlterTableInfo::Serialize(serializer);
97: 	serializer.WriteString(removed_column);
98: 	serializer.Write<bool>(if_exists);
99: }
100: 
101: unique_ptr<AlterInfo> RemoveColumnInfo::Deserialize(Deserializer &source, string schema, string table) {
102: 	auto new_name = source.Read<string>();
103: 	auto if_exists = source.Read<bool>();
104: 	return make_unique<RemoveColumnInfo>(schema, table, new_name, if_exists);
105: }
106: 
107: //===--------------------------------------------------------------------===//
108: // ChangeColumnTypeInfo
109: //===--------------------------------------------------------------------===//
110: void ChangeColumnTypeInfo::Serialize(Serializer &serializer) {
111: 	AlterTableInfo::Serialize(serializer);
112: 	serializer.WriteString(column_name);
113: 	target_type.Serialize(serializer);
114: 	serializer.WriteOptional(expression);
115: }
116: 
117: unique_ptr<AlterInfo> ChangeColumnTypeInfo::Deserialize(Deserializer &source, string schema, string table) {
118: 	auto column_name = source.Read<string>();
119: 	auto target_type = LogicalType::Deserialize(source);
120: 	auto expression = source.ReadOptional<ParsedExpression>();
121: 	return make_unique<ChangeColumnTypeInfo>(schema, table, move(column_name), move(target_type), move(expression));
122: }
123: 
124: //===--------------------------------------------------------------------===//
125: // SetDefaultInfo
126: //===--------------------------------------------------------------------===//
127: void SetDefaultInfo::Serialize(Serializer &serializer) {
128: 	AlterTableInfo::Serialize(serializer);
129: 	serializer.WriteString(column_name);
130: 	serializer.WriteOptional(expression);
131: }
132: 
133: unique_ptr<AlterInfo> SetDefaultInfo::Deserialize(Deserializer &source, string schema, string table) {
134: 	auto column_name = source.Read<string>();
135: 	auto new_default = source.ReadOptional<ParsedExpression>();
136: 	return make_unique<SetDefaultInfo>(schema, table, move(column_name), move(new_default));
137: }
138: } // namespace duckdb
[end of src/parser/parsed_data/alter_table_info.cpp]
[start of src/parser/transform/statement/transform_rename.cpp]
1: #include "duckdb/parser/statement/alter_table_statement.hpp"
2: #include "duckdb/parser/transformer.hpp"
3: 
4: namespace duckdb {
5: using namespace std;
6: using namespace duckdb_libpgquery;
7: 
8: unique_ptr<AlterTableStatement> Transformer::TransformRename(PGNode *node) {
9: 	auto stmt = reinterpret_cast<PGRenameStmt *>(node);
10: 	assert(stmt);
11: 	assert(stmt->relation);
12: 
13: 	unique_ptr<AlterTableInfo> info;
14: 
15: 	// first we check the type of ALTER
16: 	switch (stmt->renameType) {
17: 	case PG_OBJECT_COLUMN: {
18: 		// change column name
19: 
20: 		// get the table and schema
21: 		string schema = INVALID_SCHEMA;
22: 		string table;
23: 		assert(stmt->relation->relname);
24: 		if (stmt->relation->relname) {
25: 			table = stmt->relation->relname;
26: 		}
27: 		if (stmt->relation->schemaname) {
28: 			schema = stmt->relation->schemaname;
29: 		}
30: 		// get the old name and the new name
31: 		string old_name = stmt->subname;
32: 		string new_name = stmt->newname;
33: 		info = make_unique<RenameColumnInfo>(schema, table, old_name, new_name);
34: 		break;
35: 	}
36: 	case PG_OBJECT_TABLE: {
37: 		// change table name
38: 
39: 		// get the table and schema
40: 		string schema = DEFAULT_SCHEMA;
41: 		string table;
42: 		assert(stmt->relation->relname);
43: 		if (stmt->relation->relname) {
44: 			table = stmt->relation->relname;
45: 		}
46: 		if (stmt->relation->schemaname) {
47: 			schema = stmt->relation->schemaname;
48: 		}
49: 		string new_name = stmt->newname;
50: 		info = make_unique<RenameTableInfo>(schema, table, new_name);
51: 		break;
52: 	}
53: 
54: 	case PG_OBJECT_DATABASE:
55: 	default:
56: 		throw NotImplementedException("Schema element not supported yet!");
57: 	}
58: 	assert(info);
59: 	return make_unique<AlterTableStatement>(move(info));
60: }
61: 
62: } // namespace duckdb
[end of src/parser/transform/statement/transform_rename.cpp]
[start of src/planner/binder/statement/bind_simple.cpp]
1: #include "duckdb/parser/statement/alter_table_statement.hpp"
2: #include "duckdb/parser/statement/transaction_statement.hpp"
3: #include "duckdb/planner/operator/logical_simple.hpp"
4: #include "duckdb/catalog/catalog.hpp"
5: #include "duckdb/planner/binder.hpp"
6: 
7: using namespace std;
8: 
9: //! This file contains the binder definitions for statements that do not need to be bound at all and only require a
10: //! straightforward conversion
11: 
12: namespace duckdb {
13: 
14: BoundStatement Binder::Bind(AlterTableStatement &stmt) {
15: 	BoundStatement result;
16: 	result.names = {"Success"};
17: 	result.types = {LogicalType::BOOLEAN};
18: 	auto table =
19: 	    Catalog::GetCatalog(context).GetEntry<TableCatalogEntry>(context, stmt.info->schema, stmt.info->table, true);
20: 	if (table && !table->temporary) {
21: 		// we can only alter temporary tables in read-only mode
22: 		this->read_only = false;
23: 	}
24: 	result.plan = make_unique<LogicalSimple>(LogicalOperatorType::ALTER, move(stmt.info));
25: 	return result;
26: }
27: 
28: BoundStatement Binder::Bind(TransactionStatement &stmt) {
29: 	// transaction statements do not require a valid transaction
30: 	this->requires_valid_transaction = false;
31: 
32: 	BoundStatement result;
33: 	result.names = {"Success"};
34: 	result.types = {LogicalType::BOOLEAN};
35: 	result.plan = make_unique<LogicalSimple>(LogicalOperatorType::TRANSACTION, move(stmt.info));
36: 	return result;
37: }
38: 
39: } // namespace duckdb
[end of src/planner/binder/statement/bind_simple.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: