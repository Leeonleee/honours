{
  "repo": "duckdb/duckdb",
  "pull_number": 912,
  "instance_id": "duckdb__duckdb-912",
  "issue_numbers": [
    "911"
  ],
  "base_commit": "c53ba41a871dbd90d60f6cdc80ce4c7ea95dbe31",
  "patch": "diff --git a/src/catalog/catalog.cpp b/src/catalog/catalog.cpp\nindex ee77cc82dbb7..805df3f75e23 100644\n--- a/src/catalog/catalog.cpp\n+++ b/src/catalog/catalog.cpp\n@@ -157,6 +157,18 @@ CatalogEntry *Catalog::GetEntry(ClientContext &context, CatalogType type, string\n \treturn schema->GetEntry(context, type, name, if_exists);\n }\n \n+template <>\n+ViewCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists) {\n+\tauto entry = GetEntry(context, CatalogType::VIEW_ENTRY, move(schema_name), name, if_exists);\n+\tif (!entry) {\n+\t\treturn nullptr;\n+\t}\n+\tif (entry->type != CatalogType::VIEW_ENTRY) {\n+\t\tthrow CatalogException(\"%s is not a view\", name);\n+\t}\n+\treturn (ViewCatalogEntry *)entry;\n+}\n+\n template <>\n TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists) {\n \tauto entry = GetEntry(context, CatalogType::TABLE_ENTRY, move(schema_name), name, if_exists);\ndiff --git a/src/catalog/catalog_entry/schema_catalog_entry.cpp b/src/catalog/catalog_entry/schema_catalog_entry.cpp\nindex f35036483a79..1d86d989964d 100644\n--- a/src/catalog/catalog_entry/schema_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/schema_catalog_entry.cpp\n@@ -160,13 +160,16 @@ void SchemaCatalogEntry::DropEntry(ClientContext &context, DropInfo *info) {\n \n void SchemaCatalogEntry::AlterTable(ClientContext &context, AlterTableInfo *info) {\n \tswitch (info->alter_table_type) {\n-\tcase AlterTableType::RENAME_TABLE: {\n+\tcase AlterTableType::RENAME_TABLE:\n+\tcase AlterTableType::RENAME_VIEW: {\n \t\tauto &transaction = Transaction::GetTransaction(context);\n \t\tauto entry = tables.GetEntry(transaction, info->table);\n \t\tif (entry == nullptr) {\n-\t\t\tthrow CatalogException(\"Table \\\"%s\\\" doesn't exist!\", info->table);\n+\t\t\tthrow CatalogException(\"Relation \\\"%s\\\" doesn't exist!\", info->table);\n \t\t}\n-\t\tassert(entry->type == CatalogType::TABLE_ENTRY);\n+\t\tCatalogType expected_type =\n+\t\t    info->alter_table_type == AlterTableType::RENAME_VIEW ? CatalogType::VIEW_ENTRY : CatalogType::TABLE_ENTRY;\n+\t\tassert(entry->type == expected_type);\n \n \t\tauto copied_entry = entry->Copy(context);\n \ndiff --git a/src/catalog/catalog_entry/view_catalog_entry.cpp b/src/catalog/catalog_entry/view_catalog_entry.cpp\nindex b0222b2955ec..d30aeac4c36c 100644\n--- a/src/catalog/catalog_entry/view_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/view_catalog_entry.cpp\n@@ -64,4 +64,19 @@ string ViewCatalogEntry::ToSQL() {\n \treturn sql + \"\\n;\";\n }\n \n+unique_ptr<CatalogEntry> ViewCatalogEntry::Copy(ClientContext &context) {\n+\tauto create_info = make_unique<CreateViewInfo>(schema->name, name);\n+\tcreate_info->query = query->Copy();\n+\tfor (idx_t i = 0; i < aliases.size(); i++) {\n+\t\tcreate_info->aliases.push_back(aliases[i]);\n+\t}\n+\tfor (idx_t i = 0; i < types.size(); i++) {\n+\t\tcreate_info->types.push_back(types[i]);\n+\t}\n+\tcreate_info->temporary = temporary;\n+\tcreate_info->sql = sql;\n+\n+\treturn make_unique<ViewCatalogEntry>(catalog, schema, create_info.get());\n+}\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/catalog/catalog.hpp b/src/include/duckdb/catalog/catalog.hpp\nindex a5c94b03c66a..3ea7e89b966d 100644\n--- a/src/include/duckdb/catalog/catalog.hpp\n+++ b/src/include/duckdb/catalog/catalog.hpp\n@@ -31,6 +31,7 @@ class AggregateFunctionCatalogEntry;\n class CollateCatalogEntry;\n class SchemaCatalogEntry;\n class TableCatalogEntry;\n+class ViewCatalogEntry;\n class SequenceCatalogEntry;\n class TableFunctionCatalogEntry;\n class CopyFunctionCatalogEntry;\n@@ -103,6 +104,8 @@ class Catalog {\n template <>\n TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists);\n template <>\n+ViewCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists);\n+template <>\n SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists);\n template <>\n TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,\ndiff --git a/src/include/duckdb/catalog/catalog_entry/view_catalog_entry.hpp b/src/include/duckdb/catalog/catalog_entry/view_catalog_entry.hpp\nindex 70d3d7fffeba..351f388533c3 100644\n--- a/src/include/duckdb/catalog/catalog_entry/view_catalog_entry.hpp\n+++ b/src/include/duckdb/catalog/catalog_entry/view_catalog_entry.hpp\n@@ -40,6 +40,8 @@ class ViewCatalogEntry : public StandardEntry {\n \t//! Deserializes to a CreateTableInfo\n \tstatic unique_ptr<CreateViewInfo> Deserialize(Deserializer &source);\n \n+\tunique_ptr<CatalogEntry> Copy(ClientContext &context) override;\n+\n \tstring ToSQL() override;\n \n private:\ndiff --git a/src/include/duckdb/parser/parsed_data/alter_table_info.hpp b/src/include/duckdb/parser/parsed_data/alter_table_info.hpp\nindex 9c992e93028e..1afe05c76472 100644\n--- a/src/include/duckdb/parser/parsed_data/alter_table_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/alter_table_info.hpp\n@@ -34,7 +34,8 @@ enum class AlterTableType : uint8_t {\n \tADD_COLUMN = 3,\n \tREMOVE_COLUMN = 4,\n \tALTER_COLUMN_TYPE = 5,\n-\tSET_DEFAULT = 6\n+\tSET_DEFAULT = 6,\n+\tRENAME_VIEW = 7\n };\n \n struct AlterTableInfo : public AlterInfo {\n@@ -79,18 +80,19 @@ struct RenameColumnInfo : public AlterTableInfo {\n // RenameTableInfo\n //===--------------------------------------------------------------------===//\n struct RenameTableInfo : public AlterTableInfo {\n-\tRenameTableInfo(string schema, string table, string new_name)\n-\t    : AlterTableInfo(AlterTableType::RENAME_TABLE, schema, table), new_table_name(new_name) {\n+\tRenameTableInfo(string schema, string table, string new_name, bool is_view)\n+\t    : AlterTableInfo(is_view ? AlterTableType::RENAME_VIEW : AlterTableType::RENAME_TABLE, schema, table),\n+\t      new_table_name(new_name) {\n \t}\n \t~RenameTableInfo() override {\n \t}\n \n-\t//! Table new name\n+\t//! Relation new name\n \tstring new_table_name;\n \n public:\n \tvoid Serialize(Serializer &serializer) override;\n-\tstatic unique_ptr<AlterInfo> Deserialize(Deserializer &source, string schema, string table);\n+\tstatic unique_ptr<AlterInfo> Deserialize(Deserializer &source, string schema, string table, bool is_view);\n };\n \n //===--------------------------------------------------------------------===//\ndiff --git a/src/parser/parsed_data/alter_table_info.cpp b/src/parser/parsed_data/alter_table_info.cpp\nindex 339ef7e4c223..9c587e994a8f 100644\n--- a/src/parser/parsed_data/alter_table_info.cpp\n+++ b/src/parser/parsed_data/alter_table_info.cpp\n@@ -34,7 +34,9 @@ unique_ptr<AlterInfo> AlterTableInfo::Deserialize(Deserializer &source) {\n \tcase AlterTableType::RENAME_COLUMN:\n \t\treturn RenameColumnInfo::Deserialize(source, schema, table);\n \tcase AlterTableType::RENAME_TABLE:\n-\t\treturn RenameTableInfo::Deserialize(source, schema, table);\n+\t\treturn RenameTableInfo::Deserialize(source, schema, table, false);\n+\tcase AlterTableType::RENAME_VIEW:\n+\t\treturn RenameTableInfo::Deserialize(source, schema, table, true);\n \tcase AlterTableType::ADD_COLUMN:\n \t\treturn AddColumnInfo::Deserialize(source, schema, table);\n \tcase AlterTableType::REMOVE_COLUMN:\n@@ -71,9 +73,9 @@ void RenameTableInfo::Serialize(Serializer &serializer) {\n \tserializer.WriteString(new_table_name);\n }\n \n-unique_ptr<AlterInfo> RenameTableInfo::Deserialize(Deserializer &source, string schema, string table) {\n+unique_ptr<AlterInfo> RenameTableInfo::Deserialize(Deserializer &source, string schema, string table, bool is_view) {\n \tauto new_name = source.Read<string>();\n-\treturn make_unique<RenameTableInfo>(schema, table, new_name);\n+\treturn make_unique<RenameTableInfo>(schema, table, new_name, is_view);\n }\n \n //===--------------------------------------------------------------------===//\ndiff --git a/src/parser/transform/statement/transform_rename.cpp b/src/parser/transform/statement/transform_rename.cpp\nindex 3c8be84e83a0..c4e28f1b775e 100644\n--- a/src/parser/transform/statement/transform_rename.cpp\n+++ b/src/parser/transform/statement/transform_rename.cpp\n@@ -47,10 +47,27 @@ unique_ptr<AlterTableStatement> Transformer::TransformRename(PGNode *node) {\n \t\t\tschema = stmt->relation->schemaname;\n \t\t}\n \t\tstring new_name = stmt->newname;\n-\t\tinfo = make_unique<RenameTableInfo>(schema, table, new_name);\n+\t\tinfo = make_unique<RenameTableInfo>(schema, table, new_name, false /* is_view */);\n \t\tbreak;\n \t}\n \n+\tcase PG_OBJECT_VIEW: {\n+\t\t// change view name\n+\n+\t\t// get the view and schema\n+\t\tstring schema = DEFAULT_SCHEMA;\n+\t\tstring view;\n+\t\tassert(stmt->relation->relname);\n+\t\tif (stmt->relation->relname) {\n+\t\t\tview = stmt->relation->relname;\n+\t\t}\n+\t\tif (stmt->relation->schemaname) {\n+\t\t\tschema = stmt->relation->schemaname;\n+\t\t}\n+\t\tstring new_name = stmt->newname;\n+\t\tinfo = make_unique<RenameTableInfo>(schema, view, new_name, true /* is_view */);\n+\t\tbreak;\n+\t}\n \tcase PG_OBJECT_DATABASE:\n \tdefault:\n \t\tthrow NotImplementedException(\"Schema element not supported yet!\");\ndiff --git a/src/planner/binder/statement/bind_simple.cpp b/src/planner/binder/statement/bind_simple.cpp\nindex 36302ee960b6..a399ad19ba2a 100644\n--- a/src/planner/binder/statement/bind_simple.cpp\n+++ b/src/planner/binder/statement/bind_simple.cpp\n@@ -2,6 +2,8 @@\n #include \"duckdb/parser/statement/transaction_statement.hpp\"\n #include \"duckdb/planner/operator/logical_simple.hpp\"\n #include \"duckdb/catalog/catalog.hpp\"\n+#include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n+#include \"duckdb/catalog/catalog_entry/view_catalog_entry.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n \n using namespace std;\n@@ -15,10 +17,15 @@ BoundStatement Binder::Bind(AlterTableStatement &stmt) {\n \tBoundStatement result;\n \tresult.names = {\"Success\"};\n \tresult.types = {LogicalType::BOOLEAN};\n-\tauto table =\n-\t    Catalog::GetCatalog(context).GetEntry<TableCatalogEntry>(context, stmt.info->schema, stmt.info->table, true);\n+\tCatalog &catalog = Catalog::GetCatalog(context);\n+\tCatalogEntry *table;\n+\tif (stmt.info->alter_table_type == AlterTableType::RENAME_VIEW) {\n+\t\ttable = catalog.GetEntry<ViewCatalogEntry>(context, stmt.info->schema, stmt.info->table, true);\n+\t} else {\n+\t\ttable = catalog.GetEntry<TableCatalogEntry>(context, stmt.info->schema, stmt.info->table, true);\n+\t}\n \tif (table && !table->temporary) {\n-\t\t// we can only alter temporary tables in read-only mode\n+\t\t// we can only alter temporary tables/views in read-only mode\n \t\tthis->read_only = false;\n \t}\n \tresult.plan = make_unique<LogicalSimple>(LogicalOperatorType::ALTER, move(stmt.info));\n",
  "test_patch": "diff --git a/test/sql/alter/rename_table/test_rename_table_view.test b/test/sql/alter/rename_table/test_rename_table_view.test\nindex 6efc0d0d5bd7..88bd2e21eefc 100644\n--- a/test/sql/alter/rename_table/test_rename_table_view.test\n+++ b/test/sql/alter/rename_table/test_rename_table_view.test\n@@ -15,7 +15,7 @@ statement error\n ALTER TABLE v1 RENAME TO v2\n \n query I\n-SELECT * FROM  v1\n+SELECT * FROM v1\n ----\n 999\n 100\ndiff --git a/test/sql/alter/rename_view/test_rename_view.test b/test/sql/alter/rename_view/test_rename_view.test\nnew file mode 100644\nindex 000000000000..4d9e95569aba\n--- /dev/null\n+++ b/test/sql/alter/rename_view/test_rename_view.test\n@@ -0,0 +1,60 @@\n+# name: test/sql/alter/rename_view/test_rename_view.test\n+# description: Test RENAME VIEW single transaction\n+# group: [rename_view]\n+\n+statement ok\n+CREATE TABLE tbl(i INTEGER);\n+INSERT INTO tbl VALUES (999), (100);\n+CREATE VIEW vw AS SELECT * FROM tbl;\n+\n+statement ok\n+BEGIN TRANSACTION\n+\n+statement ok\n+ALTER VIEW vw RENAME TO vw2\n+\n+query I\n+SELECT * FROM vw2\n+----\n+999\n+100\n+\n+statement error\n+SELECT * FROM vw\n+\n+statement ok\n+ROLLBACK\n+\n+query I\n+SELECT * FROM vw;\n+----\n+999\n+100\n+\n+statement error\n+SELECT * FROM vw2\n+\n+statement ok\n+BEGIN TRANSACTION;\n+\n+statement ok\n+ALTER VIEW vw RENAME TO vw2\n+\n+statement ok\n+COMMIT\n+\n+query I\n+SELECT * FROM vw2\n+----\n+999\n+100\n+\n+statement error\n+SELECT * FROM vw\n+\n+query I\n+SELECT * FROM vw2\n+----\n+999\n+100\n+\ndiff --git a/test/sql/alter/rename_view/test_rename_view_incorrect.test b/test/sql/alter/rename_view/test_rename_view_incorrect.test\nnew file mode 100644\nindex 000000000000..44565ac40459\n--- /dev/null\n+++ b/test/sql/alter/rename_view/test_rename_view_incorrect.test\n@@ -0,0 +1,21 @@\n+# name: test/sql/alter/rename_view/test_rename_view_incorrect.test\n+# description: Test RENAME VIEW: view does not exist and rename to an already existing view\n+# group: [rename_view]\n+\n+statement ok\n+CREATE TABLE tbl(i INTEGER)\n+\n+statement ok\n+CREATE VIEW vw AS SELECT * FROM tbl\n+\n+statement ok\n+CREATE VIEW vw2 AS SELECT 1729 AS i\n+\n+# Renaming a non existing view\n+statement error\n+ALTER VIEW non_view RENAME TO vw\n+\n+# rename to an already existing view\n+statement error\n+ALTER VIEW vw2 RENAME TO vw\n+\ndiff --git a/test/sql/alter/rename_view/test_rename_view_many_transactions.test b/test/sql/alter/rename_view/test_rename_view_many_transactions.test\nnew file mode 100644\nindex 000000000000..eae076444b7c\n--- /dev/null\n+++ b/test/sql/alter/rename_view/test_rename_view_many_transactions.test\n@@ -0,0 +1,101 @@\n+# name: test/sql/alter/rename_view/test_rename_view_many_transactions.test\n+# description: Test RENAME VIEW four view renames and four parallel transactions\n+# group: [rename_view]\n+\n+statement ok con1\n+CREATE TABLE tbl1(i INTEGER)\n+\n+statement ok con1\n+INSERT INTO tbl1 VALUES (999), (100)\n+\n+statement ok con1\n+CREATE VIEW vw1 AS SELECT * FROM tbl1\n+\n+# rename chain\n+# con2 starts a transaction now\n+statement ok con2\n+BEGIN TRANSACTION\n+\n+# rename in con1, con2 should still see \"vw1\"\n+statement ok con1\n+ALTER VIEW vw1 RENAME TO vw2\n+\n+# con3 starts a transaction now\n+statement ok con3\n+BEGIN TRANSACTION\n+\n+# rename in con1, con3 should still see \"vw2\"\n+statement ok con1\n+ALTER VIEW vw2 RENAME TO vw3\n+\n+# con4 starts a transaction now\n+statement ok con4\n+BEGIN TRANSACTION\n+\n+# rename in con1, con4 should still see \"vw3\"\n+statement ok con1\n+ALTER VIEW vw3 RENAME TO vw4\n+\n+# con2 sees ONLY vw1\n+query I con2\n+SELECT * FROM vw1\n+----\n+999\n+100\n+\n+statement error con2\n+SELECT * FROM vw2\n+\n+statement error con2\n+SELECT * FROM vw3\n+\n+statement error con2\n+SELECT * FROM vw4\n+\n+# con3 sees ONLY vw2\n+statement error con3\n+SELECT * FROM vw1\n+\n+query I con3\n+SELECT * FROM vw2\n+----\n+999\n+100\n+\n+statement error con3\n+SELECT * FROM vw3\n+\n+statement error con3\n+SELECT * FROM vw4\n+\n+# con4 sees ONLY vw3\n+statement error con4\n+SELECT * FROM vw1\n+\n+statement error con4\n+SELECT * FROM vw2\n+\n+query I con4\n+SELECT * FROM vw3\n+----\n+999\n+100\n+\n+statement error con4\n+SELECT * FROM vw4\n+\n+# con1 sees ONLY vw4\n+statement error con1\n+SELECT * FROM vw1\n+\n+statement error con1\n+SELECT * FROM vw2\n+\n+statement error con1\n+SELECT * FROM vw3\n+\n+query I con1\n+SELECT * FROM vw4\n+----\n+999\n+100\ndiff --git a/test/sql/alter/rename_view/test_rename_view_table.test b/test/sql/alter/rename_view/test_rename_view_table.test\nnew file mode 100644\nindex 000000000000..e2f448c62123\n--- /dev/null\n+++ b/test/sql/alter/rename_view/test_rename_view_table.test\n@@ -0,0 +1,22 @@\n+# name: test/sql/alter/rename_view/test_rename_view_table.test\n+# description: Test RENAME VIEW with a table as entry\n+# group: [rename_view]\n+\n+statement ok\n+CREATE TABLE tbl(i INTEGER)\n+\n+statement ok\n+INSERT INTO tbl VALUES (999), (100)\n+\n+statement ok\n+CREATE VIEW v1 AS SELECT * FROM tbl\n+\n+statement error\n+ALTER VIEW tbl RENAME TO tbl2\n+\n+query I\n+SELECT * FROM v1\n+----\n+999\n+100\n+\ndiff --git a/test/sql/alter/rename_view/test_rename_view_transactions.test b/test/sql/alter/rename_view/test_rename_view_transactions.test\nnew file mode 100644\nindex 000000000000..a92e0cbe7820\n--- /dev/null\n+++ b/test/sql/alter/rename_view/test_rename_view_transactions.test\n@@ -0,0 +1,64 @@\n+# name: test/sql/alter/rename_view/test_rename_view_transactions.test\n+# description: Test RENAME VIEW two parallel transactions\n+# group: [rename_view]\n+\n+statement ok con1\n+CREATE TABLE tbl(i INTEGER)\n+\n+statement ok con1\n+INSERT INTO tbl VALUES (999), (100)\n+\n+statement ok con1\n+CREATE VIEW vw AS SELECT * FROM tbl\n+\n+statement ok con1\n+BEGIN TRANSACTION\n+\n+statement ok con2\n+BEGIN TRANSACTION\n+\n+statement ok con1\n+ALTER VIEW vw RENAME TO vw2\n+\n+query I con1\n+SELECT * FROM vw2\n+----\n+999\n+100\n+\n+statement error con1\n+SELECT * FROM vw\n+\n+query I con2\n+SELECT * FROM vw\n+----\n+999\n+100\n+\n+statement error con2\n+SELECT * FROM vw2\n+\n+statement ok con1\n+COMMIT\n+\n+statement ok con2\n+COMMIT\n+\n+statement error con1\n+SELECT * FROM vw\n+\n+statement error con2\n+SELECT * FROM vw\n+\n+query I con1\n+SELECT * FROM vw2\n+----\n+999\n+100\n+\n+query I con2\n+SELECT * FROM vw2\n+----\n+999\n+100\n+\ndiff --git a/test/sql/storage/catalog/test_store_rename_table.test b/test/sql/storage/catalog/test_store_rename_table.test\nindex 7b624c0d29b7..aa358ca16847 100644\n--- a/test/sql/storage/catalog/test_store_rename_table.test\n+++ b/test/sql/storage/catalog/test_store_rename_table.test\n@@ -1,5 +1,5 @@\n-# name: test/sql/storage/catalog/test_rename_column.test\n-# description: Test storage of alter table rename column\n+# name: test/sql/storage/catalog/test_rename_table.test\n+# description: Test storage of alter table rename table\n # group: [catalog]\n \n #  FIXME: right now rename is implemented as drop + create\ndiff --git a/test/sql/storage/catalog/test_store_rename_view.test b/test/sql/storage/catalog/test_store_rename_view.test\nnew file mode 100644\nindex 000000000000..e7f1d85eade6\n--- /dev/null\n+++ b/test/sql/storage/catalog/test_store_rename_view.test\n@@ -0,0 +1,76 @@\n+# name: test/sql/storage/catalog/test_rename_view.test\n+# description: Test storage of alter view\n+# group: [catalog]\n+\n+# load the DB from disk\n+load __TEST_DIR__/test_rename_view.db\n+\n+statement ok\n+CREATE TABLE test (a INTEGER, b INTEGER);\n+\n+statement ok\n+INSERT INTO test VALUES (11, 22), (13, 22), (12, 21)\n+\n+statement ok\n+CREATE VIEW vtest AS SELECT * FROM test\n+\n+statement ok\n+BEGIN TRANSACTION\n+\n+query I\n+SELECT a FROM vtest ORDER BY a\n+----\n+11\n+12\n+13\n+\n+statement ok\n+ALTER VIEW vtest RENAME TO new_name\n+\n+query I\n+SELECT a FROM new_name ORDER BY 1\n+----\n+11\n+12\n+13\n+\n+statement ok\n+ROLLBACK\n+\n+# restart the database\n+restart\n+\n+statement ok\n+BEGIN TRANSACTION\n+\n+# verify that the table is still there in the original form\n+query I\n+SELECT a FROM vtest ORDER BY a\n+----\n+11\n+12\n+13\n+\n+# now repeat the process, but this time commit\n+statement ok\n+ALTER VIEW vtest RENAME TO new_name\n+\n+query I\n+SELECT a FROM new_name ORDER BY 1\n+----\n+11\n+12\n+13\n+\n+statement ok\n+COMMIT\n+\n+restart\n+\n+# after a restart, the renamed table is still here\n+query I\n+SELECT a FROM new_name ORDER BY 1\n+----\n+11\n+12\n+13\n",
  "problem_statement": "Support renaming views\nI'm still cranking away on my [dbt](https://www.getdbt.com/) adapter for DuckDB and hit another bit of functionality I need: the ability to rename views. I found the `AlterTableInfo` code and put together some code that I _think_ implements the functionality I need; I'll post a PR shortly for review.\n",
  "hints_text": "",
  "created_at": "2020-09-17T19:40:08Z"
}