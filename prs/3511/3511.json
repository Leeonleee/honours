{
  "repo": "duckdb/duckdb",
  "pull_number": 3511,
  "instance_id": "duckdb__duckdb-3511",
  "issue_numbers": [
    "3505",
    "3505"
  ],
  "base_commit": "e4ba94a4f4540fe6d34fb2f6b7abf18e00ad3ca9",
  "patch": "diff --git a/src/execution/index/art/art.cpp b/src/execution/index/art/art.cpp\nindex 6bd016bc54ab..a27e377b7ad2 100644\n--- a/src/execution/index/art/art.cpp\n+++ b/src/execution/index/art/art.cpp\n@@ -899,7 +899,7 @@ void ART::VerifyExistence(DataChunk &chunk, VerifyExistenceType verify_type, str\n \t\tcase VerifyExistenceType::APPEND_FK: {\n \t\t\t// found node no exists in tree\n \t\t\texception_msg =\n-\t\t\t    \"violates foreign key constraint because key \\\"\" + key_name + \"\\\" no exist in referenced table\";\n+\t\t\t    \"violates foreign key constraint because key \\\"\" + key_name + \"\\\" does not exist in referenced table\";\n \t\t\tbreak;\n \t\t}\n \t\tcase VerifyExistenceType::DELETE_FK: {\ndiff --git a/src/parser/transform/constraint/transform_constraint.cpp b/src/parser/transform/constraint/transform_constraint.cpp\nindex e54706df5516..109ee1f519a7 100644\n--- a/src/parser/transform/constraint/transform_constraint.cpp\n+++ b/src/parser/transform/constraint/transform_constraint.cpp\n@@ -37,10 +37,12 @@ unique_ptr<Constraint> Transformer::TransformConstraint(duckdb_libpgquery::PGLis\n \t\tfor (auto kc = constraint->fk_attrs->head; kc; kc = kc->next) {\n \t\t\tfk_columns.emplace_back(reinterpret_cast<duckdb_libpgquery::PGValue *>(kc->data.ptr_value)->val.str);\n \t\t}\n-\t\tfor (auto kc = constraint->pk_attrs->head; kc; kc = kc->next) {\n-\t\t\tpk_columns.emplace_back(reinterpret_cast<duckdb_libpgquery::PGValue *>(kc->data.ptr_value)->val.str);\n+\t\tif (constraint->pk_attrs) {\n+\t\t\tfor (auto kc = constraint->pk_attrs->head; kc; kc = kc->next) {\n+\t\t\t\tpk_columns.emplace_back(reinterpret_cast<duckdb_libpgquery::PGValue *>(kc->data.ptr_value)->val.str);\n+\t\t\t}\n \t\t}\n-\t\tif (pk_columns.size() != fk_columns.size()) {\n+\t\tif (!pk_columns.empty() && pk_columns.size() != fk_columns.size()) {\n \t\t\tthrow ParserException(\"The number of referencing and referenced columns for foreign keys must be the same\");\n \t\t}\n \t\tif (fk_columns.empty()) {\ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex 3f5a56ee8811..d0c18bb11712 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -27,6 +27,7 @@\n #include \"duckdb/parser/constraints/foreign_key_constraint.hpp\"\n #include \"duckdb/function/scalar_macro_function.hpp\"\n #include \"duckdb/storage/data_table.hpp\"\n+#include \"duckdb/parser/constraints/unique_constraint.hpp\"\n \n namespace duckdb {\n \n@@ -152,6 +153,35 @@ void Binder::BindLogicalType(ClientContext &context, LogicalType &type, const st\n \t}\n }\n \n+static void FindMatchingPrimaryKeyColumns(vector<unique_ptr<Constraint>> &constraints, ForeignKeyConstraint &fk) {\n+\tif (!fk.pk_columns.empty()) {\n+\t\treturn;\n+\t}\n+\t// find the matching primary key constraint\n+\tfor (auto &constr : constraints) {\n+\t\tif (constr->type != ConstraintType::UNIQUE) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tauto &unique = (UniqueConstraint &)*constr;\n+\t\tif (!unique.is_primary_key) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tidx_t column_count;\n+\t\tif (unique.index != DConstants::INVALID_INDEX) {\n+\t\t\tfk.info.pk_keys.push_back(unique.index);\n+\t\t\tcolumn_count = 1;\n+\t\t} else {\n+\t\t\tfk.pk_columns = unique.columns;\n+\t\t\tcolumn_count = unique.columns.size();\n+\t\t}\n+\t\tif (column_count != fk.fk_columns.size()) {\n+\t\t\tthrow BinderException(\"The number of referencing and referenced columns for foreign keys must be the same\");\n+\t\t}\n+\t\treturn;\n+\t}\n+\tthrow BinderException(\"there is no primary key for referenced table \\\"%s\\\"\", fk.info.table);\n+}\n+\n BoundStatement Binder::Bind(CreateStatement &stmt) {\n \tBoundStatement result;\n \tresult.names = {\"Count\"};\n@@ -232,13 +262,15 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {\n \t\t\tif (fk.info.type != ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE) {\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tD_ASSERT(fk.info.pk_keys.empty() && !fk.pk_columns.empty());\n+\t\t\tD_ASSERT(fk.info.pk_keys.empty());\n \t\t\tif (create_info.table == fk.info.table) {\n \t\t\t\tfk.info.type = ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE;\n+\t\t\t\tFindMatchingPrimaryKeyColumns(create_info.constraints, fk);\n \t\t\t} else {\n \t\t\t\t// have to resolve referenced table\n \t\t\t\tauto pk_table_entry_ptr = catalog.GetEntry<TableCatalogEntry>(context, fk.info.schema, fk.info.table);\n-\t\t\t\tD_ASSERT(!fk.pk_columns.empty() && fk.info.pk_keys.empty());\n+\t\t\t\tD_ASSERT(fk.info.pk_keys.empty());\n+\t\t\t\tFindMatchingPrimaryKeyColumns(pk_table_entry_ptr->constraints, fk);\n \t\t\t\tfor (auto &keyname : fk.pk_columns) {\n \t\t\t\t\tauto entry = pk_table_entry_ptr->name_map.find(keyname);\n \t\t\t\t\tif (entry == pk_table_entry_ptr->name_map.end()) {\n",
  "test_patch": "diff --git a/test/sql/constraints/foreignkey/foreign_key_matching_columns.test b/test/sql/constraints/foreignkey/foreign_key_matching_columns.test\nnew file mode 100644\nindex 000000000000..03277ec1d760\n--- /dev/null\n+++ b/test/sql/constraints/foreignkey/foreign_key_matching_columns.test\n@@ -0,0 +1,107 @@\n+# name: test/sql/constraints/foreignkey/foreign_key_matching_columns.test\n+# description: Issue #3505: foreign key support without an explicit column name\n+# group: [foreignkey]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# non-existant reference\n+statement error\n+CREATE TABLE routes (\n+\troute_id TEXT PRIMARY KEY,\n+\tagency_id TEXT,\n+\tFOREIGN KEY (agency_id) REFERENCES agency\n+);\n+\n+statement ok\n+CREATE TABLE agency (\n+\tagency_id TEXT PRIMARY KEY,\n+\tagency_name TEXT UNIQUE NOT NULL\n+);\n+\n+# column count mismatch\n+statement error\n+CREATE TABLE routes (\n+\troute_id TEXT PRIMARY KEY,\n+\tagency_id TEXT,\n+\tFOREIGN KEY (route_id, agency_id) REFERENCES agency\n+);\n+\n+statement ok\n+CREATE TABLE routes (\n+\troute_id TEXT PRIMARY KEY,\n+\tagency_id TEXT,\n+\tFOREIGN KEY (agency_id) REFERENCES agency\n+);\n+\n+# verify foreign key functionality\n+statement error\n+INSERT INTO routes VALUES (1, 1);\n+\n+statement ok\n+INSERT INTO agency VALUES (1, 1);\n+\n+statement ok\n+INSERT INTO routes VALUES (1, 1);\n+\n+# now without a primary key\n+statement error\n+DROP TABLE agency;\n+\n+statement ok\n+DROP TABLE routes;\n+\n+statement ok\n+DROP TABLE agency;\n+\n+statement ok\n+CREATE TABLE agency (\n+\tagency_id TEXT,\n+\tagency_name TEXT NOT NULL\n+);\n+\n+statement error\n+CREATE TABLE routes (\n+\troute_id TEXT PRIMARY KEY,\n+\tagency_id TEXT,\n+\tFOREIGN KEY (agency_id) REFERENCES agency\n+);\n+\n+# self-referential primary key\n+statement ok\n+CREATE TABLE routes (\n+\troute_id TEXT PRIMARY KEY,\n+\tagency_id TEXT,\n+\tFOREIGN KEY (agency_id) REFERENCES routes\n+);\n+\n+statement ok\n+INSERT INTO routes VALUES (1, NULL);\n+\n+statement error\n+INSERT INTO routes VALUES (2, 2);\n+\n+statement ok\n+INSERT INTO routes VALUES (2, 1);\n+\n+# multi-column primary key constraint\n+statement ok\n+DROP TABLE routes;\n+\n+statement ok\n+DROP TABLE agency;\n+\n+statement ok\n+CREATE TABLE agency (\n+\tagency_id TEXT,\n+\tagency_id_2 TEXT,\n+\tagency_name TEXT NOT NULL,\n+\tPRIMARY KEY (agency_id, agency_id_2)\n+);\n+\n+statement ok\n+CREATE TABLE routes (\n+\troute_id TEXT PRIMARY KEY,\n+\tagency_id TEXT,\n+\tFOREIGN KEY (route_id, agency_id) REFERENCES agency\n+);\n",
  "problem_statement": "Segfault when creating table with foreign key constraint\n#### What happens?\r\n\r\nWhen creating a table with a `FOREIGN KEY` constraint, DuckDB segfaults ~~if the constraint references a nonexistent table.~~ see followup comment -- even in a minimal case where the referenced table exists I'm getting a segfault.\r\n\r\n#### To Reproduce\r\n\r\ngiven an `init.sql` file containing the following:\r\n\r\n```sql\r\nCREATE TABLE routes (\r\n\troute_id TEXT PRIMARY KEY,\r\n\tagency_id TEXT,\r\n\tFOREIGN KEY (agency_id) REFERENCES agency,\r\n);\r\n```\r\n\r\nrunning\r\n\r\n```sh\r\nduckdb < init.sql\r\n```\r\n\r\noutputs\r\n\r\n```\r\nSegmentation fault (core dumped)\r\n```\r\n\r\ninstead of a segfault, as a user I would expect an informative error message that would allow me to diagnose the issue.\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: 0.3.4\r\n - DuckDB Client: CLI\r\n\r\n#### Before Submitting\r\n\r\n- **Have you tried this on the latest `master` branch?**\r\n\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n  :warning: fyi, the link in the above \"other platforms\" point seems to just point to a four-year-old source tarball: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\r\n  the [link to download binaries built off master on the duckdb website](https://duckdb.org/docs/installation/) also fails with a 404 for me: https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_cli-linux-amd64.zip\r\n\r\n  given these points, I don't know how to test against master, sorry. I'm not going to attempt to build it myself -- we're just evaluating whether DuckDB is in a usable state for our company (I would love for it to be but have to admit landing on this issue in the first few minutes and then hitting broken downloads on the website is not a promising start).\r\n\r\n- **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nSegfault when creating table with foreign key constraint\n#### What happens?\r\n\r\nWhen creating a table with a `FOREIGN KEY` constraint, DuckDB segfaults ~~if the constraint references a nonexistent table.~~ see followup comment -- even in a minimal case where the referenced table exists I'm getting a segfault.\r\n\r\n#### To Reproduce\r\n\r\ngiven an `init.sql` file containing the following:\r\n\r\n```sql\r\nCREATE TABLE routes (\r\n\troute_id TEXT PRIMARY KEY,\r\n\tagency_id TEXT,\r\n\tFOREIGN KEY (agency_id) REFERENCES agency,\r\n);\r\n```\r\n\r\nrunning\r\n\r\n```sh\r\nduckdb < init.sql\r\n```\r\n\r\noutputs\r\n\r\n```\r\nSegmentation fault (core dumped)\r\n```\r\n\r\ninstead of a segfault, as a user I would expect an informative error message that would allow me to diagnose the issue.\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: 0.3.4\r\n - DuckDB Client: CLI\r\n\r\n#### Before Submitting\r\n\r\n- **Have you tried this on the latest `master` branch?**\r\n\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n  :warning: fyi, the link in the above \"other platforms\" point seems to just point to a four-year-old source tarball: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\r\n  the [link to download binaries built off master on the duckdb website](https://duckdb.org/docs/installation/) also fails with a 404 for me: https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_cli-linux-amd64.zip\r\n\r\n  given these points, I don't know how to test against master, sorry. I'm not going to attempt to build it myself -- we're just evaluating whether DuckDB is in a usable state for our company (I would love for it to be but have to admit landing on this issue in the first few minutes and then hitting broken downloads on the website is not a promising start).\r\n\r\n- **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "Uh... actually, this also causes a segfault:\r\n\r\n```sql\r\nCREATE TABLE agency (\r\n\tagency_id TEXT PRIMARY KEY,\r\n\tagency_name TEXT NOT NULL\r\n);\r\n\r\nCREATE TABLE routes (\r\n\troute_id TEXT PRIMARY KEY,\r\n\tagency_id TEXT,\r\n\tFOREIGN KEY (agency_id) REFERENCES agency\r\n);\r\n```\r\n\r\nSo clearly it's not about the constraint referencing a valid table. Maybe I'm missing something obvious here -- are foreign key constraints supported? I see now that they were recently added in https://github.com/duckdb/duckdb/pull/3195, but it's hard to imagine a more minimal test of them than this.\nThanks for the report! Foreign key support is very new so some rough edges are to be expected. This particular syntax was not considered, you need to explicitly specify the column names for now:\r\n\r\n```sql\r\nCREATE TABLE agency (\r\n\tagency_id TEXT PRIMARY KEY,\r\n\tagency_name TEXT NOT NULL\r\n);\r\n\r\nCREATE TABLE routes (\r\n\troute_id TEXT PRIMARY KEY,\r\n\tagency_id TEXT,\r\n\tFOREIGN KEY (agency_id) REFERENCES agency(agency_id)\r\n);\r\n```\nUh... actually, this also causes a segfault:\r\n\r\n```sql\r\nCREATE TABLE agency (\r\n\tagency_id TEXT PRIMARY KEY,\r\n\tagency_name TEXT NOT NULL\r\n);\r\n\r\nCREATE TABLE routes (\r\n\troute_id TEXT PRIMARY KEY,\r\n\tagency_id TEXT,\r\n\tFOREIGN KEY (agency_id) REFERENCES agency\r\n);\r\n```\r\n\r\nSo clearly it's not about the constraint referencing a valid table. Maybe I'm missing something obvious here -- are foreign key constraints supported? I see now that they were recently added in https://github.com/duckdb/duckdb/pull/3195, but it's hard to imagine a more minimal test of them than this.\nThanks for the report! Foreign key support is very new so some rough edges are to be expected. This particular syntax was not considered, you need to explicitly specify the column names for now:\r\n\r\n```sql\r\nCREATE TABLE agency (\r\n\tagency_id TEXT PRIMARY KEY,\r\n\tagency_name TEXT NOT NULL\r\n);\r\n\r\nCREATE TABLE routes (\r\n\troute_id TEXT PRIMARY KEY,\r\n\tagency_id TEXT,\r\n\tFOREIGN KEY (agency_id) REFERENCES agency(agency_id)\r\n);\r\n```",
  "created_at": "2022-04-26T10:14:34Z"
}