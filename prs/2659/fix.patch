diff --git a/src/function/scalar/struct/struct_extract.cpp b/src/function/scalar/struct/struct_extract.cpp
index 034fb3a45c56..81ffdee73dc0 100644
--- a/src/function/scalar/struct/struct_extract.cpp
+++ b/src/function/scalar/struct/struct_extract.cpp
@@ -3,6 +3,7 @@
 #include "duckdb/function/scalar/nested_functions.hpp"
 #include "duckdb/planner/expression/bound_function_expression.hpp"
 #include "duckdb/storage/statistics/struct_statistics.hpp"
+#include "duckdb/common/string_util.hpp"
 
 namespace duckdb {
 
@@ -67,12 +68,12 @@ static unique_ptr<FunctionData> StructExtractBind(ClientContext &context, Scalar
 
 	if (key_child->return_type.id() != LogicalTypeId::VARCHAR ||
 	    key_child->return_type.id() != LogicalTypeId::VARCHAR || !key_child->IsFoldable()) {
-		throw Exception("Key name for struct_extract needs to be a constant string");
+		throw BinderException("Key name for struct_extract needs to be a constant string");
 	}
 	Value key_val = ExpressionExecutor::EvaluateScalar(*key_child.get());
 	D_ASSERT(key_val.type().id() == LogicalTypeId::VARCHAR);
 	if (key_val.is_null || key_val.str_value.length() < 1) {
-		throw Exception("Key name for struct_extract needs to be neither NULL nor empty");
+		throw BinderException("Key name for struct_extract needs to be neither NULL nor empty");
 	}
 	string key = StringUtil::Lower(key_val.str_value);
 
@@ -82,15 +83,23 @@ static unique_ptr<FunctionData> StructExtractBind(ClientContext &context, Scalar
 
 	for (size_t i = 0; i < struct_children.size(); i++) {
 		auto &child = struct_children[i];
-		if (child.first == key) {
+		if (StringUtil::Lower(child.first) == key) {
 			found_key = true;
 			key_index = i;
 			return_type = child.second;
 			break;
 		}
 	}
+
 	if (!found_key) {
-		throw Exception("Could not find key in struct");
+		vector<string> candidates;
+		candidates.reserve(struct_children.size());
+		for (auto &struct_child : struct_children) {
+			candidates.push_back(struct_child.first);
+		}
+		auto closest_settings = StringUtil::TopNLevenshtein(candidates, key);
+		auto message = StringUtil::CandidatesMessage(closest_settings, "Candidate Entries");
+		throw BinderException("Could not find key \"%s\" in struct
%s", key, message);
 	}
 
 	bound_function.return_type = return_type;
diff --git a/src/function/scalar/struct/struct_pack.cpp b/src/function/scalar/struct/struct_pack.cpp
index 9ad35f1ba907..a18391344c4a 100644
--- a/src/function/scalar/struct/struct_pack.cpp
+++ b/src/function/scalar/struct/struct_pack.cpp
@@ -2,7 +2,7 @@
 #include "duckdb/common/string_util.hpp"
 #include "duckdb/parser/expression/bound_expression.hpp"
 #include "duckdb/function/scalar/nested_functions.hpp"
-#include "duckdb/common/unordered_set.hpp"
+#include "duckdb/common/case_insensitive_map.hpp"
 #include "duckdb/storage/statistics/struct_statistics.hpp"
 #include "duckdb/planner/expression_binder.hpp"
 
@@ -31,7 +31,7 @@ static void StructPackFunction(DataChunk &args, ExpressionState &state, Vector &
 
 static unique_ptr<FunctionData> StructPackBind(ClientContext &context, ScalarFunction &bound_function,
                                                vector<unique_ptr<Expression>> &arguments) {
-	unordered_set<string> name_collision_set;
+	case_insensitive_set_t name_collision_set;
 
 	// collect names and deconflict, construct return type
 	if (arguments.empty()) {
