{
  "repo": "duckdb/duckdb",
  "pull_number": 2659,
  "instance_id": "duckdb__duckdb-2659",
  "issue_numbers": [
    "2652",
    "2652"
  ],
  "base_commit": "3c9727ac219b26994e7431064c9209272e83d5cb",
  "patch": "diff --git a/src/function/scalar/struct/struct_extract.cpp b/src/function/scalar/struct/struct_extract.cpp\nindex 034fb3a45c56..81ffdee73dc0 100644\n--- a/src/function/scalar/struct/struct_extract.cpp\n+++ b/src/function/scalar/struct/struct_extract.cpp\n@@ -3,6 +3,7 @@\n #include \"duckdb/function/scalar/nested_functions.hpp\"\n #include \"duckdb/planner/expression/bound_function_expression.hpp\"\n #include \"duckdb/storage/statistics/struct_statistics.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n \n namespace duckdb {\n \n@@ -67,12 +68,12 @@ static unique_ptr<FunctionData> StructExtractBind(ClientContext &context, Scalar\n \n \tif (key_child->return_type.id() != LogicalTypeId::VARCHAR ||\n \t    key_child->return_type.id() != LogicalTypeId::VARCHAR || !key_child->IsFoldable()) {\n-\t\tthrow Exception(\"Key name for struct_extract needs to be a constant string\");\n+\t\tthrow BinderException(\"Key name for struct_extract needs to be a constant string\");\n \t}\n \tValue key_val = ExpressionExecutor::EvaluateScalar(*key_child.get());\n \tD_ASSERT(key_val.type().id() == LogicalTypeId::VARCHAR);\n \tif (key_val.is_null || key_val.str_value.length() < 1) {\n-\t\tthrow Exception(\"Key name for struct_extract needs to be neither NULL nor empty\");\n+\t\tthrow BinderException(\"Key name for struct_extract needs to be neither NULL nor empty\");\n \t}\n \tstring key = StringUtil::Lower(key_val.str_value);\n \n@@ -82,15 +83,23 @@ static unique_ptr<FunctionData> StructExtractBind(ClientContext &context, Scalar\n \n \tfor (size_t i = 0; i < struct_children.size(); i++) {\n \t\tauto &child = struct_children[i];\n-\t\tif (child.first == key) {\n+\t\tif (StringUtil::Lower(child.first) == key) {\n \t\t\tfound_key = true;\n \t\t\tkey_index = i;\n \t\t\treturn_type = child.second;\n \t\t\tbreak;\n \t\t}\n \t}\n+\n \tif (!found_key) {\n-\t\tthrow Exception(\"Could not find key in struct\");\n+\t\tvector<string> candidates;\n+\t\tcandidates.reserve(struct_children.size());\n+\t\tfor (auto &struct_child : struct_children) {\n+\t\t\tcandidates.push_back(struct_child.first);\n+\t\t}\n+\t\tauto closest_settings = StringUtil::TopNLevenshtein(candidates, key);\n+\t\tauto message = StringUtil::CandidatesMessage(closest_settings, \"Candidate Entries\");\n+\t\tthrow BinderException(\"Could not find key \\\"%s\\\" in struct\\n%s\", key, message);\n \t}\n \n \tbound_function.return_type = return_type;\ndiff --git a/src/function/scalar/struct/struct_pack.cpp b/src/function/scalar/struct/struct_pack.cpp\nindex 9ad35f1ba907..a18391344c4a 100644\n--- a/src/function/scalar/struct/struct_pack.cpp\n+++ b/src/function/scalar/struct/struct_pack.cpp\n@@ -2,7 +2,7 @@\n #include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/parser/expression/bound_expression.hpp\"\n #include \"duckdb/function/scalar/nested_functions.hpp\"\n-#include \"duckdb/common/unordered_set.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n #include \"duckdb/storage/statistics/struct_statistics.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n \n@@ -31,7 +31,7 @@ static void StructPackFunction(DataChunk &args, ExpressionState &state, Vector &\n \n static unique_ptr<FunctionData> StructPackBind(ClientContext &context, ScalarFunction &bound_function,\n                                                vector<unique_ptr<Expression>> &arguments) {\n-\tunordered_set<string> name_collision_set;\n+\tcase_insensitive_set_t name_collision_set;\n \n \t// collect names and deconflict, construct return type\n \tif (arguments.empty()) {\n",
  "test_patch": "diff --git a/test/sql/types/struct/struct_case_insensitivity.test b/test/sql/types/struct/struct_case_insensitivity.test\nnew file mode 100644\nindex 000000000000..63f7f848710e\n--- /dev/null\n+++ b/test/sql/types/struct/struct_case_insensitivity.test\n@@ -0,0 +1,41 @@\n+# name: test/sql/types/struct/struct_case_insensitivity.test\n+# description: Test struct case insensitivity\n+# group: [struct]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE tbl AS SELECT ({'HELLO': 3}) col;\n+\n+query I\n+SELECT col['HELLO'] FROM tbl\n+----\n+3\n+\n+query I\n+SELECT col['hello'] FROM tbl\n+----\n+3\n+\n+query I\n+SELECT col.hello FROM tbl\n+----\n+3\n+\n+query I\n+SELECT \"COL\".\"HELLO\" FROM tbl\n+----\n+3\n+\n+statement error\n+SELECT ({'hello': 3, 'hello': 4}) col;\n+\n+statement error\n+SELECT ({'HELLO': 3, 'HELLO': 4}) col;\n+\n+statement error\n+SELECT ({'HELLO': 3, 'hello': 4}) col;\n+\n+statement error\n+SELECT col['HELL'] FROM tbl\n",
  "problem_statement": "parquet struct fields with Uppercase chars can't be referenced\n#### What happens?\r\nA short, clear and concise description of what the bug is.\r\n\r\nSeems like when a parquet file has a struct containing a field name with an uppercase letter, duckdb can't reference it.\r\n\r\n#### To Reproduce\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n\r\n>>> duckdb.__version__\r\n'0.3.1'\r\n>>> data={'one':[{'Three':3,'four':10}], 'Two':[{'Three':4,'four':10}]}\r\n>>> t=pa.Table.from_pydict(data)\r\n>>> pq.write_table(t, 'data.parquet')\r\n>>> rel=duckdb.connect()\r\n>>> rel.query(\"select one from 'data.parquet'\")\r\n---------------------\r\n-- Expression Tree --\r\n---------------------\r\nSubquery [select one from 'data.parquet']\r\n\r\n---------------------\r\n-- Result Columns  --\r\n---------------------\r\n- one (STRUCT<Three: BIGINT, four: BIGINT>)\r\n\r\n---------------------\r\n-- Result Preview  --\r\n---------------------\r\none\r\nSTRUCT<Three: BIGINT, four: BIGINT>\r\n[ Rows: 1]\r\n{'Three': 3, 'four': 10}\r\n\r\n\r\n\r\n>>> rel.query(\"select one['Three'] from 'data.parquet'\")\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nRuntimeError: Could not find key in struct\r\n>>> rel.query(\"select one['Three'] from 'data.parquet'\")\r\n\r\n#### Environment (please complete the following information):\r\n - OS: [e.g. iOS]\r\n - DuckDB Version: [e.g. 22]\r\n - DuckDB Client: [e.g. Python]\r\n\r\n#### Before Submitting\r\n\r\n- [ ] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [ ] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nparquet struct fields with Uppercase chars can't be referenced\n#### What happens?\r\nA short, clear and concise description of what the bug is.\r\n\r\nSeems like when a parquet file has a struct containing a field name with an uppercase letter, duckdb can't reference it.\r\n\r\n#### To Reproduce\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n\r\n>>> duckdb.__version__\r\n'0.3.1'\r\n>>> data={'one':[{'Three':3,'four':10}], 'Two':[{'Three':4,'four':10}]}\r\n>>> t=pa.Table.from_pydict(data)\r\n>>> pq.write_table(t, 'data.parquet')\r\n>>> rel=duckdb.connect()\r\n>>> rel.query(\"select one from 'data.parquet'\")\r\n---------------------\r\n-- Expression Tree --\r\n---------------------\r\nSubquery [select one from 'data.parquet']\r\n\r\n---------------------\r\n-- Result Columns  --\r\n---------------------\r\n- one (STRUCT<Three: BIGINT, four: BIGINT>)\r\n\r\n---------------------\r\n-- Result Preview  --\r\n---------------------\r\none\r\nSTRUCT<Three: BIGINT, four: BIGINT>\r\n[ Rows: 1]\r\n{'Three': 3, 'four': 10}\r\n\r\n\r\n\r\n>>> rel.query(\"select one['Three'] from 'data.parquet'\")\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nRuntimeError: Could not find key in struct\r\n>>> rel.query(\"select one['Three'] from 'data.parquet'\")\r\n\r\n#### Environment (please complete the following information):\r\n - OS: [e.g. iOS]\r\n - DuckDB Version: [e.g. 22]\r\n - DuckDB Client: [e.g. Python]\r\n\r\n#### Before Submitting\r\n\r\n- [ ] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [ ] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "\n",
  "created_at": "2021-11-23T14:29:30Z"
}