{
  "repo": "duckdb/duckdb",
  "pull_number": 6278,
  "instance_id": "duckdb__duckdb-6278",
  "issue_numbers": [
    "6198"
  ],
  "base_commit": "14a51626cd67b934a52659467e23dbb658a2c9f7",
  "patch": "diff --git a/tools/nodejs/src/statement.cpp b/tools/nodejs/src/statement.cpp\nindex a471b36ca51e..fcdb5b24ae9d 100644\n--- a/tools/nodejs/src/statement.cpp\n+++ b/tools/nodejs/src/statement.cpp\n@@ -8,6 +8,8 @@\n #include <string>\n #include <regex>\n \n+using std::unique_ptr;\n+\n namespace node_duckdb {\n \n Napi::FunctionReference Statement::constructor;\n@@ -28,13 +30,45 @@ Napi::Object Statement::Init(Napi::Env env, Napi::Object exports) {\n \treturn exports;\n }\n \n+static unique_ptr<duckdb::PreparedStatement> PrepareManyInternal(Statement &statement) {\n+\tauto &connection = statement.connection_ref->connection;\n+\tstd::vector<unique_ptr<duckdb::SQLStatement>> statements;\n+\ttry {\n+\t\tif (connection == nullptr) {\n+\t\t\tthrow duckdb::ConnectionException(\"Connection was never established or has been closed already\");\n+\t\t}\n+\n+\t\t// Prepare all statements\n+\t\tstatements = connection->ExtractStatements(statement.sql);\n+\t\tif (statements.empty()) {\n+\t\t\tthrow duckdb::InvalidInputException(\"No statement to prepare!\");\n+\t\t}\n+\n+\t\t// if there are multiple statements, we directly execute the statements besides the last one\n+\t\t// we only return the result of the last statement to the user, unless one of the previous statements fails\n+\t\tfor (idx_t i = 0; i + 1 < statements.size(); i++) {\n+\t\t\tauto pending_query = connection->PendingQuery(std::move(statements[i]));\n+\t\t\tauto res = pending_query->Execute();\n+\t\t\tif (res->HasError()) {\n+\t\t\t\treturn duckdb::make_unique<duckdb::PreparedStatement>(res->GetErrorObject());\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn connection->Prepare(std::move(statements.back()));\n+\t} catch (const duckdb::Exception &ex) {\n+\t\treturn duckdb::make_unique<duckdb::PreparedStatement>(duckdb::PreservedError(ex));\n+\t} catch (std::exception &ex) {\n+\t\treturn duckdb::make_unique<duckdb::PreparedStatement>(duckdb::PreservedError(ex));\n+\t}\n+}\n+\n struct PrepareTask : public Task {\n \tPrepareTask(Statement &statement, Napi::Function callback) : Task(statement, callback) {\n \t}\n \n \tvoid DoWork() override {\n \t\tauto &statement = Get<Statement>();\n-\t\tstatement.statement = statement.connection_ref->connection->Prepare(statement.sql);\n+\t\tstatement.statement = PrepareManyInternal(statement);\n \t}\n \n \tvoid Callback() override {\n@@ -221,7 +255,7 @@ struct StatementParam {\n };\n \n struct RunPreparedTask : public Task {\n-\tRunPreparedTask(Statement &statement, duckdb::unique_ptr<StatementParam> params, RunType run_type)\n+\tRunPreparedTask(Statement &statement, unique_ptr<StatementParam> params, RunType run_type)\n \t    : Task(statement, params->callback), params(std::move(params)), run_type(run_type) {\n \t}\n \n@@ -366,13 +400,13 @@ struct RunPreparedTask : public Task {\n \t\t} break;\n \t\t}\n \t}\n-\tstd::unique_ptr<duckdb::QueryResult> result;\n-\tduckdb::unique_ptr<StatementParam> params;\n+\tunique_ptr<duckdb::QueryResult> result;\n+\tunique_ptr<StatementParam> params;\n \tRunType run_type;\n };\n \n struct RunQueryTask : public Task {\n-\tRunQueryTask(Statement &statement, duckdb::unique_ptr<StatementParam> params, Napi::Promise::Deferred deferred)\n+\tRunQueryTask(Statement &statement, unique_ptr<StatementParam> params, Napi::Promise::Deferred deferred)\n \t    : Task(statement), deferred(deferred), params(std::move(params)) {\n \t}\n \n@@ -406,11 +440,11 @@ struct RunQueryTask : public Task {\n \t}\n \n \tNapi::Promise::Deferred deferred;\n-\tstd::unique_ptr<duckdb::QueryResult> result;\n-\tduckdb::unique_ptr<StatementParam> params;\n+\tunique_ptr<duckdb::QueryResult> result;\n+\tunique_ptr<StatementParam> params;\n };\n \n-duckdb::unique_ptr<StatementParam> Statement::HandleArgs(const Napi::CallbackInfo &info) {\n+unique_ptr<StatementParam> Statement::HandleArgs(const Napi::CallbackInfo &info) {\n \tsize_t start_idx = ignore_first_param ? 1 : 0;\n \tauto params = duckdb::make_unique<StatementParam>();\n \n@@ -541,7 +575,7 @@ struct GetChunkTask : public Task {\n \t}\n \n \tNapi::Promise::Deferred deferred;\n-\tstd::unique_ptr<duckdb::DataChunk> chunk;\n+\tunique_ptr<duckdb::DataChunk> chunk;\n };\n \n struct GetNextArrowIpcTask : public Task {\n@@ -571,10 +605,10 @@ struct GetNextArrowIpcTask : public Task {\n \t\tduckdb::string_t blob = *(duckdb::string_t *)(chunk->data[0].GetData());\n \n \t\t// Transfer ownership and Construct ArrayBuffer\n-\t\tauto data_chunk_ptr = new std::unique_ptr<duckdb::DataChunk>();\n+\t\tauto data_chunk_ptr = new unique_ptr<duckdb::DataChunk>();\n \t\t*data_chunk_ptr = std::move(chunk);\n \t\tauto deleter = [](Napi::Env, void *finalizeData, void *hint) {\n-\t\t\tdelete static_cast<std::unique_ptr<duckdb::DataChunk> *>(hint);\n+\t\t\tdelete static_cast<unique_ptr<duckdb::DataChunk> *>(hint);\n \t\t};\n \t\tauto array_buffer =\n \t\t    Napi::ArrayBuffer::New(env, (void *)blob.GetDataUnsafe(), blob.GetSize(), deleter, data_chunk_ptr);\n@@ -583,7 +617,7 @@ struct GetNextArrowIpcTask : public Task {\n \t}\n \n \tNapi::Promise::Deferred deferred;\n-\tstd::unique_ptr<duckdb::DataChunk> chunk;\n+\tunique_ptr<duckdb::DataChunk> chunk;\n };\n \n Napi::Value QueryResult::NextChunk(const Napi::CallbackInfo &info) {\n",
  "test_patch": "diff --git a/tools/nodejs/test/prepare.test.ts b/tools/nodejs/test/prepare.test.ts\nindex a41b7bb95507..e063b521f0a0 100644\n--- a/tools/nodejs/test/prepare.test.ts\n+++ b/tools/nodejs/test/prepare.test.ts\n@@ -66,7 +66,6 @@ describe('prepare', function() {\n             }\n         });\n \n-\n         it('should prepare a statement and return values again', function(done) {\n             var stmt = db.prepare(\"SELECT txt, num, flt, blb FROM foo ORDER BY num\", function(err: null | Error) {\n                 if (err) throw err;\n@@ -343,6 +342,45 @@ describe('prepare', function() {\n         after(function(done) { db.close(done); });\n     });\n \n+    describe('prepare multiple statements', function() {\n+        var db: sqlite3.Database;\n+        before(function(done) { db = new sqlite3.Database(':memory:',\n+            function(err) {\n+                db.run(\"CREATE TABLE foo (a integer)\", done)\n+            }\n+            ); });\n+\n+        it('should directly execute first statements', function(done) {\n+            db.prepare(\"insert into foo values (3); insert into foo values (4); select * from foo\")\n+                .all(function(err: null | Error, rows: TableData) {\n+                    if (err) throw err;\n+                    assert.equal(rows[0].a, 3);\n+                    assert.equal(rows[1].a, 4);\n+                })\n+                .finalize(done);\n+        });\n+\n+        it('should fail in prepare, when executing the first statement', function(done) {\n+            let prepared = db.prepare(\"SELECT * FROM non_existent_table; SELECT 42\", function(err: null | Error) {\n+\t\t\t\tif (err) {\n+\t\t\t\t\tdone();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t});\n+        });\n+\n+        it('should fail in prepare, when preparing the first statement', function(done) {\n+            let prepared = db.prepare(\"SELCET * FROM foo; SELECT 42\", function(err: null | Error) {\n+\t\t\t\tif (err) {\n+\t\t\t\t\tdone();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t});\n+        });\n+\n+        after(function(done) { db.close(done); });\n+    });\n+\n     describe('all()', function() {\n         var db: sqlite3.Database;\n         before(function(done) { db = new sqlite3.Database(':memory:',\ndiff --git a/tools/nodejs/test/typescript_decls.test.ts b/tools/nodejs/test/typescript_decls.test.ts\nindex c94754f6153a..ffdb612539f4 100644\n--- a/tools/nodejs/test/typescript_decls.test.ts\n+++ b/tools/nodejs/test/typescript_decls.test.ts\n@@ -2,7 +2,7 @@ import * as duckdb from \"..\";\n import assert from \"assert\";\n import fs from \"fs\";\n \n-describe(\"TypeScript declarataions\", function () {\n+describe(\"TypeScript declarations\", function () {\n   var db: duckdb.Database;\n   before(function (done) {\n     db = new duckdb.Database(\":memory:\", duckdb.OPEN_READWRITE, done);\n",
  "problem_statement": "Nodejs client: Import fails with \"Cannot prepare multiple statements\" \n### What happens?\n\nUsing the node client, exporting a database with multiple tables works fine. Importing it fails with:\r\n\r\n>  Invalid Error: Cannot prepare multiple statements at once!\r\n\r\n```javascript\r\n{\r\n  errno: -1,\r\n  code: 'DUCKDB_NODEJS_ERROR'\r\n}\r\n```\r\n\r\n\n\n### To Reproduce\n\n**Current OS and Node Version**\r\n\r\nOS: MacOS Ventura 13.2 (22D49)\r\nDevice: M1 Max\r\nNode: v18.13.0\r\n\r\n**Steps**\r\n\r\n```javascript\r\nimport duckdb from 'duckdb';\r\n\r\nasync function getConnection(file) {\r\n    console.log(`creating new connection for: ${ file }`);\r\n    return new Promise((resolve, reject) => {\r\n        const db = new duckdb.Database(file, duckdb.OPEN_READWRITE, () => {\r\n            resolve(db);\r\n        });\r\n    });\r\n}\r\n\r\nasync function timeAsync(block) {\r\n    const start = process.hrtime();\r\n    await block();\r\n    const end = process.hrtime(start);\r\n    const elapsedMs = (end[0] * 1000000000 + end[1]) / 1000000;\r\n    return elapsedMs;\r\n}\r\n\r\nasync function runQuery(connection, func, sql, args) {\r\n    args ||= [];\r\n    func = func.bind(connection);\r\n    return new Promise((resolve, reject) => {\r\n        func(sql, ...args, (err, res) => {\r\n            if (err) {\r\n                reject(err);\r\n                return;\r\n            }\r\n            resolve(res);\r\n        });\r\n    });\r\n}\r\n\r\nasync function executeQuery(con, query) {\r\n    let data = null;\r\n    let error = null;\r\n    const time = await timeAsync(async () => {\r\n        try {\r\n            data = await runQuery(con, con.all, query);\r\n        } catch (err) {\r\n            error = err;\r\n        }\r\n    });\r\n    if (error) {\r\n        console.log(`query failed with error`, error);\r\n        console.log(`query executed was: ${ query }\\n`);\r\n        return;\r\n    }\r\n    console.log(`query executed was: ${ query }\\n`);\r\n    console.log(`query executed in ${time}ms`, data);\r\n}\r\n\r\nconst bugCon = await getConnection(\"bug.db\");\r\nawait executeQuery(\r\n    bugCon,\r\n    'create table test (id int);'\r\n);\r\nawait executeQuery(\r\n    bugCon,\r\n    'create table test2 (id int);'\r\n);\r\nawait executeQuery(\r\n    bugCon,\r\n    \"export database './tmp' (format csv, compression zstd)\"\r\n);\r\nconsole.log(\"creating new database to import from\");\r\nconst bug2Con = await getConnection(\"bug2.db\");\r\n\r\n// ---------------------------------\r\n// \ud83d\udc1e\ud83d\udc1e\ud83d\udc1e\ud83d\udc1eTHIS SHOULD WORK BUT DOESN'T\r\n// --------------------------------\r\n\r\nawait executeQuery(\r\n    bug2Con,\r\n    \"import database './tmp'\"\r\n);\r\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\n0.6.1\n\n### DuckDB Client:\n\nNode (18.13.0)\n\n### Full Name:\n\nRohland de Charmoy\n\n### Affiliation:\n\nCodeo\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Can you provide the resulting `load.sql` and `schema.sql` files produced at `EXPORT`?\n@Tishj \r\n\r\nload.sql\r\n\r\n```sql\r\nCOPY test2 FROM './tmp/test_.csv' (FORMAT 'csv', delimiter ',', header 0, quote '\"', compression 'zstd');\r\nCOPY test FROM './tmp/test.csv' (FORMAT 'csv', delimiter ',', header 0, quote '\"', compression 'zstd');\r\n```\r\nschema.sql\r\n\r\n```sql\r\nCREATE TABLE test2(id INTEGER);\r\nCREATE TABLE test(id INTEGER);\r\n```\nare there any other files in that folder?\r\n`test_.csv` and `test.csv` should be the only other ones\r\n(Though I think those also shouldn't be present, as we did not populate the table at all)\n@Tishj - yeah, there are two files (attached)\r\n\r\n[test_.csv](https://github.com/duckdb/duckdb/files/10712956/test_.csv)\r\n[test.csv](https://github.com/duckdb/duckdb/files/10712957/test.csv)\r\n\r\nThese are the only two additional files in the folder: \r\n\r\n<img width=\"433\" alt=\"Screenshot_WebStorm_20230211_102729@2x\" src=\"https://user-images.githubusercontent.com/231471/218248390-26058aa8-8ad2-43c5-811c-46bd0745daf0.png\">\r\n\r\n\nI'm looking into this now, and this error is thrown when ClientContext::Prepare is called with a string containing multiple queries.\r\n\r\nI'm still not sure how that happens here, as your example looks correct\nAh the bug is starting to make sense (but it is definitely a bug)\r\n\r\nIn Prepare we call ParseStatementsInternal, which resolves pragmas\r\n`import` is a pragma, and resolves to an amalgamation of all the queries contained in the folder.\r\n\r\nAnd as stated above, Prepare throws an error when the query to prepare contains multiple statements, which it does.\r\n```\r\n(lldb) p statements[2]->ToString()\r\n(std::string) $2 = \"COPY test FROM './tmp/test.csv' ( FORMAT csv, delimiter \\\",\\\", header 0, quote \\\"\\\"\\\"\\\", compression zstd )\"\r\n(lldb) p statements[3]->ToString()\r\n(std::string) $3 = \"COPY test2 FROM './tmp/test_.csv' ( FORMAT csv, delimiter \\\",\\\", header 0, quote \\\"\\\"\\\"\\\", compression zstd )\"\r\n```\r\n\r\nLikely we should change the `Statement` class in `duckdb_node.hpp` from containing a single `unique_ptr<PreparedStatement>` into a vector of them, and then call ExtractStatements, Prepare'ing them separately afterwards.\r\n\r\nJust not sure how this change propagates throughout the rest of the Statement handling code",
  "created_at": "2023-02-14T13:45:57Z"
}