{
  "repo": "duckdb/duckdb",
  "pull_number": 2279,
  "instance_id": "duckdb__duckdb-2279",
  "issue_numbers": [
    "2277"
  ],
  "base_commit": "4d9d3e6428298490a4474a62cf977aed7cf22800",
  "patch": "diff --git a/src/function/scalar/list/list_extract.cpp b/src/function/scalar/list/list_extract.cpp\nindex b23bc1ff0786..f6cd728d9188 100644\n--- a/src/function/scalar/list/list_extract.cpp\n+++ b/src/function/scalar/list/list_extract.cpp\n@@ -12,21 +12,23 @@\n \n namespace duckdb {\n \n-template <class T, bool HEAP_REF = false>\n-void ListExtractTemplate(idx_t count, Vector &list, Vector &offsets, Vector &result) {\n-\tVectorData list_data, offsets_data, child_data;\n+template <class T, bool HEAP_REF = false, bool VALIDITY_ONLY = false>\n+void ListExtractTemplate(idx_t count, VectorData &list_data, VectorData &offsets_data, Vector &child_vector,\n+                         idx_t list_size, Vector &result) {\n+\tVectorData child_data;\n+\tchild_vector.Orrify(list_size, child_data);\n \n-\tlist.Orrify(count, list_data);\n-\toffsets.Orrify(count, offsets_data);\n+\tT *result_data;\n \n \tresult.SetVectorType(VectorType::FLAT_VECTOR);\n-\tauto result_data = FlatVector::GetData<T>(result);\n+\tif (!VALIDITY_ONLY) {\n+\t\tresult_data = FlatVector::GetData<T>(result);\n+\t}\n \tauto &result_mask = FlatVector::Validity(result);\n \n-\tauto &vec = ListVector::GetEntry(list);\n \t// heap-ref once\n \tif (HEAP_REF) {\n-\t\tStringVector::AddHeapReference(result, vec);\n+\t\tStringVector::AddHeapReference(result, child_vector);\n \t}\n \n \t// this is lifted from ExecuteGenericLoop because we can't push the list child data into this otherwise\n@@ -51,9 +53,10 @@ void ListExtractTemplate(idx_t count, Vector &list, Vector &offsets, Vector &res\n \t\t\t\t}\n \t\t\t\tchild_offset = list_entry.offset + offsets_entry;\n \t\t\t}\n-\t\t\tvec.Orrify(ListVector::GetListSize(list), child_data);\n \t\t\tif (child_data.validity.RowIsValid(child_offset)) {\n-\t\t\t\tresult_data[i] = ((T *)child_data.data)[child_offset];\n+\t\t\t\tif (!VALIDITY_ONLY) {\n+\t\t\t\t\tresult_data[i] = ((T *)child_data.data)[child_offset];\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tresult_mask.SetInvalid(i);\n \t\t\t}\n@@ -65,74 +68,94 @@ void ListExtractTemplate(idx_t count, Vector &list, Vector &offsets, Vector &res\n \t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n \t}\n }\n-\n-static void ExecuteListExtract(Vector &result, Vector &list, Vector &offsets, const idx_t count) {\n-\tD_ASSERT(list.GetType().id() == LogicalTypeId::LIST);\n-\n+static void ExecuteListExtractInternal(const idx_t count, VectorData &list, VectorData &offsets, Vector &child_vector,\n+                                       idx_t list_size, Vector &result) {\n+\tD_ASSERT(child_vector.GetType() == result.GetType());\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::UTINYINT:\n-\t\tListExtractTemplate<uint8_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<uint8_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::TINYINT:\n-\t\tListExtractTemplate<int8_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<int8_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::USMALLINT:\n-\t\tListExtractTemplate<uint16_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<uint16_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::SMALLINT:\n-\t\tListExtractTemplate<int16_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<int16_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::UINTEGER:\n-\t\tListExtractTemplate<uint32_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<uint32_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::INTEGER:\n-\t\tListExtractTemplate<int32_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<int32_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::UBIGINT:\n-\t\tListExtractTemplate<uint64_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<uint64_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::BIGINT:\n-\t\tListExtractTemplate<int64_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<int64_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::HUGEINT:\n-\t\tListExtractTemplate<hugeint_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<hugeint_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::FLOAT:\n-\t\tListExtractTemplate<float>(count, list, offsets, result);\n+\t\tListExtractTemplate<float>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::DOUBLE:\n-\t\tListExtractTemplate<double>(count, list, offsets, result);\n+\t\tListExtractTemplate<double>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::DATE:\n-\t\tListExtractTemplate<date_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<date_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::TIME:\n-\t\tListExtractTemplate<dtime_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<dtime_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::TIMESTAMP:\n-\t\tListExtractTemplate<timestamp_t>(count, list, offsets, result);\n+\t\tListExtractTemplate<timestamp_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::BLOB:\n \tcase LogicalTypeId::VARCHAR:\n-\t\tListExtractTemplate<string_t, true>(count, list, offsets, result);\n+\t\tListExtractTemplate<string_t, true>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \tcase LogicalTypeId::SQLNULL:\n \t\tresult.Reference(Value());\n \t\tbreak;\n+\tcase LogicalTypeId::STRUCT: {\n+\t\tauto &entries = StructVector::GetEntries(child_vector);\n+\t\tauto &result_entries = StructVector::GetEntries(result);\n+\t\tD_ASSERT(entries.size() == result_entries.size());\n+\t\t// extract the child entries of the struct\n+\t\tfor (idx_t i = 0; i < entries.size(); i++) {\n+\t\t\tExecuteListExtractInternal(count, list, offsets, *entries[i], list_size, *result_entries[i]);\n+\t\t}\n+\t\t// extract the validity mask\n+\t\tListExtractTemplate<bool, false, true>(count, list, offsets, child_vector, list_size, result);\n+\t\tbreak;\n+\t}\n \tcase LogicalTypeId::LIST: {\n \t\t// nested list: we have to reference the child\n-\t\tauto &child_list = ListVector::GetEntry(list);\n-\t\tauto &child_child_list = ListVector::GetEntry(child_list);\n+\t\tauto &child_child_list = ListVector::GetEntry(child_vector);\n \n \t\tListVector::GetEntry(result).Reference(child_child_list);\n-\t\tListVector::SetListSize(result, ListVector::GetListSize(child_list));\n-\t\tListExtractTemplate<list_entry_t>(count, list, offsets, result);\n+\t\tListVector::SetListSize(result, ListVector::GetListSize(child_vector));\n+\t\tListExtractTemplate<list_entry_t>(count, list, offsets, child_vector, list_size, result);\n \t\tbreak;\n \t}\n \tdefault:\n \t\tthrow NotImplementedException(\"Unimplemented type for LIST_EXTRACT\");\n \t}\n+}\n+\n+static void ExecuteListExtract(Vector &result, Vector &list, Vector &offsets, const idx_t count) {\n+\tD_ASSERT(list.GetType().id() == LogicalTypeId::LIST);\n+\tVectorData list_data;\n+\tVectorData offsets_data;\n \n+\tlist.Orrify(count, list_data);\n+\toffsets.Orrify(count, offsets_data);\n+\tExecuteListExtractInternal(count, list_data, offsets_data, ListVector::GetEntry(list),\n+\t                           ListVector::GetListSize(list), result);\n \tresult.Verify(count);\n }\n \n",
  "test_patch": "diff --git a/test/sql/copy/parquet/parquet_2267.test b/test/sql/copy/parquet/parquet_2267.test\nindex cf6efc81a0ef..766e237a423c 100644\n--- a/test/sql/copy/parquet/parquet_2267.test\n+++ b/test/sql/copy/parquet/parquet_2267.test\n@@ -8,3 +8,8 @@ query I\n SELECT * FROM parquet_scan('data/parquet-testing/bug2267.parquet')\n ----\n [{'disabledPlans': [bea4c11e-220a-4e6d-8eb8-8ea15d019f90], 'skuId': c7df2760-2c81-4ef7-b578-5b5392b571df}, {'disabledPlans': [8a256a2b-b617-496d-b51b-e76466e88db0, 41781fb2-bc02-4b7c-bd55-b576c07bb09d, eec0eb4f-6444-4f95-aba0-50c24d67f998], 'skuId': 84a661c4-e949-4bd2-a560-ed7766fcaf2b}, {'disabledPlans': NULL, 'skuId': b05e124f-c7cc-45a0-a6aa-8cf78c946968}, {'disabledPlans': NULL, 'skuId': f30db892-07e9-47e9-837c-80727f46fd3d}]\n+\n+query I\n+SELECT assignedLicenses[0] FROM parquet_scan('data/parquet-testing/bug2267.parquet')\n+----\n+{'disabledPlans': [bea4c11e-220a-4e6d-8eb8-8ea15d019f90], 'skuId': c7df2760-2c81-4ef7-b578-5b5392b571df}\ndiff --git a/test/sql/types/list/list_extract_struct.test b/test/sql/types/list/list_extract_struct.test\nnew file mode 100644\nindex 000000000000..d36c015cb10a\n--- /dev/null\n+++ b/test/sql/types/list/list_extract_struct.test\n@@ -0,0 +1,78 @@\n+# name: test/sql/types/list/list_extract_struct.test\n+# description: Test list extract on list of structs\n+# group: [list]\n+\n+# list extract for structs\n+statement ok\n+CREATE TABLE a AS SELECT\n+\t[\n+\t\t{'a': 3, 'b': NULL},\n+\t\tNULL,\n+\t\t{'a': NULL, 'b': 'hello'}\n+\t] l;\n+\n+query I\n+SELECT * FROM a\n+----\n+[{'a': 3, 'b': NULL}, NULL, {'a': NULL, 'b': hello}]\n+\n+query I\n+SELECT l[0] FROM a\n+----\n+{'a': 3, 'b': NULL}\n+\n+query I\n+SELECT l[1] FROM a\n+----\n+NULL\n+\n+query I\n+SELECT l[2] FROM a\n+----\n+{'a': NULL, 'b': hello}\n+\n+# nested structs\n+statement ok\n+CREATE TABLE nested AS SELECT\n+\t[\n+\t\t{'a': 3, 'b': {'x': 3, 'y': [1, 2, 3]}},\n+\t\tNULL,\n+\t\t{'a': NULL, 'b': {'x': NULL, 'y': [4, 5]}},\n+\t\t{'a': 27, 'b': NULL},\n+\t\t{'a': NULL, 'b': {'x': 7, 'y': NULL}}\n+\t] l;\n+\n+query I\n+SELECT * FROM nested\n+----\n+[{'a': 3, 'b': {'x': 3, 'y': [1, 2, 3]}}, NULL, {'a': NULL, 'b': {'x': NULL, 'y': [4, 5]}}, {'a': 27, 'b': NULL}, {'a': NULL, 'b': {'x': 7, 'y': NULL}}]\n+\n+query I\n+SELECT l[0] FROM nested\n+----\n+{'a': 3, 'b': {'x': 3, 'y': [1, 2, 3]}}\n+\n+query I\n+SELECT l[1] FROM nested\n+----\n+NULL\n+\n+query I\n+SELECT l[2] FROM nested\n+----\n+{'a': NULL, 'b': {'x': NULL, 'y': [4, 5]}}\n+\n+query I\n+SELECT l[3] FROM nested\n+----\n+{'a': 27, 'b': NULL}\n+\n+query I\n+SELECT l[4] FROM nested\n+----\n+{'a': NULL, 'b': {'x': 7, 'y': NULL}}\n+\n+query I\n+SELECT l[4]['b'] FROM nested\n+----\n+{'x': 7, 'y': NULL}\n",
  "problem_statement": "\"Unimplemented type for LIST_EXTRACT\" with column of type list<struct> \n```\r\nselect array_extract(assignedLicenses,0) from 'test.parquet';\r\nError: Not implemented Error: Unimplemented type for LIST_EXTRACT\r\n```\r\n\r\nDuckdb should return the first element of each list.\r\nMinimal parquet file attached.\r\n[test.parquet.zip](https://github.com/duckdb/duckdb/files/7156933/test.parquet.zip)\r\n\r\n\r\n**Environment (please complete the following information):**\r\n - OS: MacOS 11.5\r\n - DuckDB Version: Mytherin:issue2267 (this fix needed to read the column in the first place)\r\n\r\n**Before submitting**\r\n- [x ] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\n",
  "hints_text": "",
  "created_at": "2021-09-14T07:46:39Z"
}