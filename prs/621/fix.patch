diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp
index 323189376e0f..b037f5c976b5 100644
--- a/src/catalog/catalog_entry/table_catalog_entry.cpp
+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp
@@ -62,7 +62,7 @@ TableCatalogEntry::TableCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schem
 					column_ids.push_back(key);
 				}
 				// create an adaptive radix tree around the expressions
-				auto art = make_unique<ART>(*storage, column_ids, move(unbound_expressions), true);
+				auto art = make_unique<ART>(column_ids, move(unbound_expressions), true);
 				storage->AddIndex(move(art), bound_expressions);
 			}
 		}
@@ -246,9 +246,21 @@ unique_ptr<CatalogEntry> TableCatalogEntry::RemoveColumn(ClientContext &context,
 			}
 			break;
 		}
-		case ConstraintType::UNIQUE:
-			create_info->constraints.push_back(constraint->Copy());
+		case ConstraintType::UNIQUE: {
+			auto copy = constraint->Copy();
+			auto &unique = (UniqueConstraint &) *copy;
+			if (unique.index != INVALID_INDEX) {
+				if (unique.index == removed_index) {
+					throw CatalogException(
+					    "Cannot drop column \"%s\" because there is a UNIQUE constraint that depends on it",
+					    info.removed_column.c_str());
+				} else if (unique.index > removed_index) {
+					unique.index--;
+				}
+			}
+			create_info->constraints.push_back(move(copy));
 			break;
+		}
 		default:
 			throw InternalException("Unsupported constraint for entry!");
 		}
@@ -337,10 +349,13 @@ unique_ptr<CatalogEntry> TableCatalogEntry::ChangeColumnType(ClientContext &cont
 	AlterBinder expr_binder(binder, context, name, columns, bound_columns, info.target_type);
 	auto expression = info.expression->Copy();
 	auto bound_expression = expr_binder.Bind(expression);
+	auto bound_create_info = binder.BindCreateTableInfo(move(create_info));
+	if (bound_columns.size() == 0) {
+		bound_columns.push_back(COLUMN_IDENTIFIER_ROW_ID);
+	}
+
 	auto new_storage =
 	    make_shared<DataTable>(context, *storage, change_idx, info.target_type, move(bound_columns), *bound_expression);
-
-	auto bound_create_info = binder.BindCreateTableInfo(move(create_info));
 	return make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(),
 	                                      new_storage);
 }
diff --git a/src/execution/index/art/art.cpp b/src/execution/index/art/art.cpp
index 74d3a161cdc1..dfa900a9d05e 100644
--- a/src/execution/index/art/art.cpp
+++ b/src/execution/index/art/art.cpp
@@ -7,9 +7,9 @@
 using namespace duckdb;
 using namespace std;
 
-ART::ART(DataTable &table, vector<column_t> column_ids, vector<unique_ptr<Expression>> unbound_expressions,
+ART::ART(vector<column_t> column_ids, vector<unique_ptr<Expression>> unbound_expressions,
          bool is_unique)
-    : Index(IndexType::ART, table, column_ids, move(unbound_expressions)), is_unique(is_unique) {
+    : Index(IndexType::ART, column_ids, move(unbound_expressions)), is_unique(is_unique) {
 	tree = nullptr;
 	expression_result.Initialize(types);
 	int n = 1;
@@ -724,7 +724,7 @@ void ART::SearchCloseRange(vector<row_t> &result_ids, ARTIndexScanState *state,
 	}
 }
 
-void ART::Scan(Transaction &transaction, TableIndexScanState &table_state, DataChunk &result) {
+void ART::Scan(Transaction &transaction, DataTable &table, TableIndexScanState &table_state, DataChunk &result) {
 	auto state = (ARTIndexScanState *)table_state.index_state.get();
 
 	// scan the index
diff --git a/src/execution/operator/schema/physical_create_index.cpp b/src/execution/operator/schema/physical_create_index.cpp
index bed54e94b995..4b82fb920f63 100644
--- a/src/execution/operator/schema/physical_create_index.cpp
+++ b/src/execution/operator/schema/physical_create_index.cpp
@@ -24,7 +24,7 @@ void PhysicalCreateIndex::GetChunkInternal(ClientContext &context, DataChunk &ch
 	unique_ptr<Index> index;
 	switch (info->index_type) {
 	case IndexType::ART: {
-		index = make_unique<ART>(*table.storage, column_ids, move(unbound_expressions), info->unique);
+		index = make_unique<ART>(column_ids, move(unbound_expressions), info->unique);
 		break;
 	}
 	default:
diff --git a/src/include/duckdb/execution/index/art/art.hpp b/src/include/duckdb/execution/index/art/art.hpp
index 895a4e7f8b01..a867d0c75dd9 100644
--- a/src/include/duckdb/execution/index/art/art.hpp
+++ b/src/include/duckdb/execution/index/art/art.hpp
@@ -54,8 +54,7 @@ struct ARTIndexScanState : public IndexScanState {
 
 class ART : public Index {
 public:
-	ART(DataTable &table, vector<column_t> column_ids, vector<unique_ptr<Expression>> unbound_expressions,
-	    bool is_unique = false);
+	ART(vector<column_t> column_ids, vector<unique_ptr<Expression>> unbound_expressions, bool is_unique = false);
 	~ART();
 
 	//! Root of the tree
@@ -79,7 +78,7 @@ class ART : public Index {
 	                                                       ExpressionType high_expression_type) override;
 
 	//! Perform a lookup on the index
-	void Scan(Transaction &transaction, TableIndexScanState &state, DataChunk &result) override;
+	void Scan(Transaction &transaction, DataTable &table, TableIndexScanState &state, DataChunk &result) override;
 	//! Append entries to the index
 	bool Append(IndexLock &lock, DataChunk &entries, Vector &row_identifiers) override;
 	//! Verify that data can be appended to the index
diff --git a/src/include/duckdb/storage/index.hpp b/src/include/duckdb/storage/index.hpp
index f8e80a728b06..0f12d477adb8 100644
--- a/src/include/duckdb/storage/index.hpp
+++ b/src/include/duckdb/storage/index.hpp
@@ -19,7 +19,6 @@
 namespace duckdb {
 
 class ClientContext;
-class DataTable;
 class Transaction;
 
 struct IndexLock;
@@ -27,7 +26,7 @@ struct IndexLock;
 //! The index is an abstract base class that serves as the basis for indexes
 class Index {
 public:
-	Index(IndexType type, DataTable &table, vector<column_t> column_ids,
+	Index(IndexType type, vector<column_t> column_ids,
 	      vector<unique_ptr<Expression>> unbound_expressions);
 	virtual ~Index() = default;
 
@@ -35,8 +34,6 @@ class Index {
 	std::mutex lock;
 	//! The type of the index
 	IndexType type;
-	//! The table
-	DataTable &table;
 	//! Column identifiers to extract from the base table
 	vector<column_t> column_ids;
 	//! unordered_set of column_ids used by the index
@@ -59,7 +56,7 @@ class Index {
 	                                                               ExpressionType low_expression_type, Value high_value,
 	                                                               ExpressionType high_expression_type) = 0;
 	//! Perform a lookup on the index
-	virtual void Scan(Transaction &transaction, TableIndexScanState &state, DataChunk &result) = 0;
+	virtual void Scan(Transaction &transaction, DataTable &table, TableIndexScanState &state, DataChunk &result) = 0;
 
 	//! Obtain a lock on the index
 	virtual void InitializeLock(IndexLock &state);
diff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp
index 908e9cf9c813..27e0ccea6e01 100644
--- a/src/storage/data_table.cpp
+++ b/src/storage/data_table.cpp
@@ -47,8 +47,6 @@ DataTable::DataTable(ClientContext &context, DataTable &parent, ColumnDefinition
       transient_manager(parent.transient_manager), columns(parent.columns), is_root(true) {
 	// prevent any new tuples from being added to the parent
 	lock_guard<mutex> parent_lock(parent.append_lock);
-	// this table replaces the previous table, hence the parent is no longer the root DataTable
-	parent.is_root = false;
 	// add the new column to this DataTable
 	auto new_column_type = GetInternalType(new_column.type);
 	idx_t new_column_idx = columns.size();
@@ -84,6 +82,9 @@ DataTable::DataTable(ClientContext &context, DataTable &parent, ColumnDefinition
 	}
 	// also add this column to client local storage
 	Transaction::GetTransaction(context).storage.AddColumn(&parent, this, new_column, default_value);
+
+	// this table replaces the previous table, hence the parent is no longer the root DataTable
+	parent.is_root = false;
 }
 
 DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t removed_column)
@@ -101,12 +102,13 @@ DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t removed_co
 			}
 		}
 	}
-	// this table replaces the previous table, hence the parent is no longer the root DataTable
-	parent.is_root = false;
 	// erase the column from this DataTable
 	assert(removed_column < types.size());
 	types.erase(types.begin() + removed_column);
 	columns.erase(columns.begin() + removed_column);
+
+	// this table replaces the previous table, hence the parent is no longer the root DataTable
+	parent.is_root = false;
 }
 
 DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t changed_idx, SQLType target_type,
@@ -115,9 +117,9 @@ DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t changed_id
       transient_manager(parent.transient_manager), columns(parent.columns), is_root(true) {
 
 	// prevent any new tuples from being added to the parent
-	lock_guard<mutex> parent_lock(parent.append_lock);
-	// this table replaces the previous table, hence the parent is no longer the root DataTable
-	parent.is_root = false;
+	CreateIndexScanState scan_state;
+	parent.InitializeCreateIndexScan(scan_state, bound_columns);
+
 	// first check if there are any indexes that exist that point to the changed column
 	for (auto &index : info->indexes) {
 		for (auto &column_id : index->column_ids) {
@@ -140,17 +142,18 @@ DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t changed_id
 
 	// scan the original table, and fill the new column with the transformed value
 	auto &transaction = Transaction::GetTransaction(context);
-	TableScanState scan_state;
 
 	vector<TypeId> types;
 	for (idx_t i = 0; i < bound_columns.size(); i++) {
-		types.push_back(parent.types[i]);
+		if (bound_columns[i] == COLUMN_IDENTIFIER_ROW_ID) {
+			types.push_back(ROW_TYPE);
+		} else {
+			types.push_back(parent.types[bound_columns[i]]);
+		}
 	}
-	parent.InitializeScan(transaction, scan_state, bound_columns, nullptr);
 
 	DataChunk scan_chunk;
 	scan_chunk.Initialize(types);
-	unordered_map<idx_t, vector<TableFilter>> dummy_filters;
 
 	ExpressionExecutor executor;
 	executor.AddExpression(cast_expr);
@@ -158,7 +161,8 @@ DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t changed_id
 	Vector append_vector(new_type);
 	while (true) {
 		// scan the table
-		parent.Scan(transaction, scan_chunk, scan_state, dummy_filters);
+		scan_chunk.Reset();
+		parent.CreateIndexScan(scan_state, scan_chunk);
 		if (scan_chunk.size() == 0) {
 			break;
 		}
@@ -170,6 +174,9 @@ DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t changed_id
 	transaction.storage.ChangeType(&parent, this, changed_idx, target_type, bound_columns, cast_expr);
 
 	columns[changed_idx] = move(column_data);
+
+	// this table replaces the previous table, hence the parent is no longer the root DataTable
+	parent.is_root = false;
 }
 
 //===--------------------------------------------------------------------===//
@@ -448,7 +455,7 @@ void DataTable::IndexScan(Transaction &transaction, DataChunk &result, TableInde
 	// clear any previously pinned blocks
 	state.fetch_state.handles.clear();
 	// scan the index
-	state.index->Scan(transaction, state, result);
+	state.index->Scan(transaction, *this, state, result);
 	if (result.size() > 0) {
 		return;
 	}
diff --git a/src/storage/index.cpp b/src/storage/index.cpp
index 805442c019f7..fa0176b74ca2 100644
--- a/src/storage/index.cpp
+++ b/src/storage/index.cpp
@@ -8,9 +8,9 @@
 using namespace duckdb;
 using namespace std;
 
-Index::Index(IndexType type, DataTable &table, vector<column_t> column_ids,
+Index::Index(IndexType type, vector<column_t> column_ids,
              vector<unique_ptr<Expression>> unbound_expressions)
-    : type(type), table(table), column_ids(column_ids), unbound_expressions(move(unbound_expressions)) {
+    : type(type), column_ids(column_ids), unbound_expressions(move(unbound_expressions)) {
 	for (auto &expr : this->unbound_expressions) {
 		types.push_back(expr->return_type);
 		bound_expressions.push_back(BindExpression(expr->Copy()));
diff --git a/src/storage/local_storage.cpp b/src/storage/local_storage.cpp
index 9f9b4a1dc4bc..90003c6faa47 100644
--- a/src/storage/local_storage.cpp
+++ b/src/storage/local_storage.cpp
@@ -18,7 +18,7 @@ LocalTableStorage::LocalTableStorage(DataTable &table) : max_row(0) {
 			for (auto &expr : art.unbound_expressions) {
 				unbound_expressions.push_back(expr->Copy());
 			}
-			indexes.push_back(make_unique<ART>(table, art.column_ids, move(unbound_expressions), true));
+			indexes.push_back(make_unique<ART>(art.column_ids, move(unbound_expressions), true));
 		}
 	}
 }
