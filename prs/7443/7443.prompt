You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
[Python] InternalException on simple `read_json`
### What happens?

```py
import duckdb

duckdb.read_json('https://jsonplaceholder.typicode.com/todos')
```
```
duckdb.InternalException: INTERNAL Error: State was not defined in this HTTP File Handle
```

Most likely related to <https://github.com/duckdb/duckdb/commit/7882080cda3598a56c0156a2b8606d2ae35752ea>

### OS:

MacOS

### DuckDB Version:

master

### DuckDB Client:

Python

### Full Name:

Thijs Bruineman

### Affiliation:

DuckDB Labs

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
11:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
12:   </a>
13:   <a href="https://discord.gg/tcvwpjfnZx">
14:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
15:   </a>
16:   <a href="https://github.com/duckdb/duckdb/releases/">
17:     <img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release">
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of src/main/client_context.cpp]
1: #include "duckdb/main/client_context.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_search_path.hpp"
6: #include "duckdb/common/file_system.hpp"
7: #include "duckdb/common/http_state.hpp"
8: #include "duckdb/common/preserved_error.hpp"
9: #include "duckdb/common/progress_bar/progress_bar.hpp"
10: #include "duckdb/common/serializer/buffered_deserializer.hpp"
11: #include "duckdb/common/serializer/buffered_file_writer.hpp"
12: #include "duckdb/common/serializer/buffered_serializer.hpp"
13: #include "duckdb/common/types/column/column_data_collection.hpp"
14: #include "duckdb/execution/column_binding_resolver.hpp"
15: #include "duckdb/execution/operator/helper/physical_result_collector.hpp"
16: #include "duckdb/execution/physical_plan_generator.hpp"
17: #include "duckdb/main/appender.hpp"
18: #include "duckdb/main/attached_database.hpp"
19: #include "duckdb/main/client_context_file_opener.hpp"
20: #include "duckdb/main/client_data.hpp"
21: #include "duckdb/main/database.hpp"
22: #include "duckdb/main/database_manager.hpp"
23: #include "duckdb/main/error_manager.hpp"
24: #include "duckdb/main/materialized_query_result.hpp"
25: #include "duckdb/main/query_profiler.hpp"
26: #include "duckdb/main/query_result.hpp"
27: #include "duckdb/main/relation.hpp"
28: #include "duckdb/main/stream_query_result.hpp"
29: #include "duckdb/optimizer/optimizer.hpp"
30: #include "duckdb/parallel/task_scheduler.hpp"
31: #include "duckdb/parser/expression/constant_expression.hpp"
32: #include "duckdb/parser/expression/parameter_expression.hpp"
33: #include "duckdb/parser/parsed_data/create_function_info.hpp"
34: #include "duckdb/parser/parsed_expression_iterator.hpp"
35: #include "duckdb/parser/parser.hpp"
36: #include "duckdb/parser/query_node/select_node.hpp"
37: #include "duckdb/parser/statement/drop_statement.hpp"
38: #include "duckdb/parser/statement/execute_statement.hpp"
39: #include "duckdb/parser/statement/explain_statement.hpp"
40: #include "duckdb/parser/statement/prepare_statement.hpp"
41: #include "duckdb/parser/statement/relation_statement.hpp"
42: #include "duckdb/parser/statement/select_statement.hpp"
43: #include "duckdb/planner/operator/logical_execute.hpp"
44: #include "duckdb/planner/planner.hpp"
45: #include "duckdb/planner/pragma_handler.hpp"
46: #include "duckdb/storage/data_table.hpp"
47: #include "duckdb/transaction/meta_transaction.hpp"
48: #include "duckdb/transaction/transaction.hpp"
49: #include "duckdb/transaction/transaction_manager.hpp"
50: 
51: namespace duckdb {
52: 
53: struct ActiveQueryContext {
54: 	//! The query that is currently being executed
55: 	string query;
56: 	//! The currently open result
57: 	BaseQueryResult *open_result = nullptr;
58: 	//! Prepared statement data
59: 	shared_ptr<PreparedStatementData> prepared;
60: 	//! The query executor
61: 	unique_ptr<Executor> executor;
62: 	//! The progress bar
63: 	unique_ptr<ProgressBar> progress_bar;
64: };
65: 
66: ClientContext::ClientContext(shared_ptr<DatabaseInstance> database)
67:     : db(std::move(database)), interrupted(false), client_data(make_uniq<ClientData>(*this)), transaction(*this) {
68: }
69: 
70: ClientContext::~ClientContext() {
71: 	if (Exception::UncaughtException()) {
72: 		return;
73: 	}
74: 	// destroy the client context and rollback if there is an active transaction
75: 	// but only if we are not destroying this client context as part of an exception stack unwind
76: 	Destroy();
77: }
78: 
79: unique_ptr<ClientContextLock> ClientContext::LockContext() {
80: 	return make_uniq<ClientContextLock>(context_lock);
81: }
82: 
83: void ClientContext::Destroy() {
84: 	auto lock = LockContext();
85: 	if (transaction.HasActiveTransaction()) {
86: 		transaction.ResetActiveQuery();
87: 		if (!transaction.IsAutoCommit()) {
88: 			transaction.Rollback();
89: 		}
90: 	}
91: 	CleanupInternal(*lock);
92: }
93: 
94: unique_ptr<DataChunk> ClientContext::Fetch(ClientContextLock &lock, StreamQueryResult &result) {
95: 	D_ASSERT(IsActiveResult(lock, &result));
96: 	D_ASSERT(active_query->executor);
97: 	return FetchInternal(lock, *active_query->executor, result);
98: }
99: 
100: unique_ptr<DataChunk> ClientContext::FetchInternal(ClientContextLock &lock, Executor &executor,
101:                                                    BaseQueryResult &result) {
102: 	bool invalidate_query = true;
103: 	try {
104: 		// fetch the chunk and return it
105: 		auto chunk = executor.FetchChunk();
106: 		if (!chunk || chunk->size() == 0) {
107: 			CleanupInternal(lock, &result);
108: 		}
109: 		return chunk;
110: 	} catch (StandardException &ex) {
111: 		// standard exceptions do not invalidate the current transaction
112: 		result.SetError(PreservedError(ex));
113: 		invalidate_query = false;
114: 	} catch (FatalException &ex) {
115: 		// fatal exceptions invalidate the entire database
116: 		result.SetError(PreservedError(ex));
117: 		auto &db = DatabaseInstance::GetDatabase(*this);
118: 		ValidChecker::Invalidate(db, ex.what());
119: 	} catch (const Exception &ex) {
120: 		result.SetError(PreservedError(ex));
121: 	} catch (std::exception &ex) {
122: 		result.SetError(PreservedError(ex));
123: 	} catch (...) { // LCOV_EXCL_START
124: 		result.SetError(PreservedError("Unhandled exception in FetchInternal"));
125: 	} // LCOV_EXCL_STOP
126: 	CleanupInternal(lock, &result, invalidate_query);
127: 	return nullptr;
128: }
129: 
130: void ClientContext::BeginTransactionInternal(ClientContextLock &lock, bool requires_valid_transaction) {
131: 	// check if we are on AutoCommit. In this case we should start a transaction
132: 	D_ASSERT(!active_query);
133: 	auto &db = DatabaseInstance::GetDatabase(*this);
134: 	if (ValidChecker::IsInvalidated(db)) {
135: 		throw FatalException(ErrorManager::FormatException(*this, ErrorType::INVALIDATED_DATABASE,
136: 		                                                   ValidChecker::InvalidatedMessage(db)));
137: 	}
138: 	if (requires_valid_transaction && transaction.HasActiveTransaction() &&
139: 	    ValidChecker::IsInvalidated(transaction.ActiveTransaction())) {
140: 		throw Exception(ErrorManager::FormatException(*this, ErrorType::INVALIDATED_TRANSACTION));
141: 	}
142: 	active_query = make_uniq<ActiveQueryContext>();
143: 	if (transaction.IsAutoCommit()) {
144: 		transaction.BeginTransaction();
145: 	}
146: }
147: 
148: void ClientContext::BeginQueryInternal(ClientContextLock &lock, const string &query) {
149: 	BeginTransactionInternal(lock, false);
150: 	LogQueryInternal(lock, query);
151: 	active_query->query = query;
152: 	query_progress = -1;
153: 	transaction.SetActiveQuery(db->GetDatabaseManager().GetNewQueryNumber());
154: }
155: 
156: PreservedError ClientContext::EndQueryInternal(ClientContextLock &lock, bool success, bool invalidate_transaction) {
157: 	client_data->profiler->EndQuery();
158: 
159: 	if (client_data->http_state) {
160: 		client_data->http_state->Reset();
161: 	}
162: 
163: 	// Notify any registered state of query end
164: 	for (auto const &s : registered_state) {
165: 		s.second->QueryEnd();
166: 	}
167: 
168: 	D_ASSERT(active_query.get());
169: 	active_query.reset();
170: 	query_progress = -1;
171: 	PreservedError error;
172: 	try {
173: 		if (transaction.HasActiveTransaction()) {
174: 			// Move the query profiler into the history
175: 			auto &prev_profilers = client_data->query_profiler_history->GetPrevProfilers();
176: 			prev_profilers.emplace_back(transaction.GetActiveQuery(), std::move(client_data->profiler));
177: 			// Reinitialize the query profiler
178: 			client_data->profiler = make_shared<QueryProfiler>(*this);
179: 			// Propagate settings of the saved query into the new profiler.
180: 			client_data->profiler->Propagate(*prev_profilers.back().second);
181: 			if (prev_profilers.size() >= client_data->query_profiler_history->GetPrevProfilersSize()) {
182: 				prev_profilers.pop_front();
183: 			}
184: 
185: 			transaction.ResetActiveQuery();
186: 			if (transaction.IsAutoCommit()) {
187: 				if (success) {
188: 					transaction.Commit();
189: 				} else {
190: 					transaction.Rollback();
191: 				}
192: 			} else if (invalidate_transaction) {
193: 				D_ASSERT(!success);
194: 				ValidChecker::Invalidate(ActiveTransaction(), "Failed to commit");
195: 			}
196: 		}
197: 	} catch (FatalException &ex) {
198: 		auto &db = DatabaseInstance::GetDatabase(*this);
199: 		ValidChecker::Invalidate(db, ex.what());
200: 		error = PreservedError(ex);
201: 	} catch (const Exception &ex) {
202: 		error = PreservedError(ex);
203: 	} catch (std::exception &ex) {
204: 		error = PreservedError(ex);
205: 	} catch (...) { // LCOV_EXCL_START
206: 		error = PreservedError("Unhandled exception!");
207: 	} // LCOV_EXCL_STOP
208: 	return error;
209: }
210: 
211: void ClientContext::CleanupInternal(ClientContextLock &lock, BaseQueryResult *result, bool invalidate_transaction) {
212: 	client_data->http_state = make_uniq<HTTPState>();
213: 	if (!active_query) {
214: 		// no query currently active
215: 		return;
216: 	}
217: 	if (active_query->executor) {
218: 		active_query->executor->CancelTasks();
219: 	}
220: 	active_query->progress_bar.reset();
221: 
222: 	auto error = EndQueryInternal(lock, result ? !result->HasError() : false, invalidate_transaction);
223: 	if (result && !result->HasError()) {
224: 		// if an error occurred while committing report it in the result
225: 		result->SetError(error);
226: 	}
227: 	D_ASSERT(!active_query);
228: }
229: 
230: Executor &ClientContext::GetExecutor() {
231: 	D_ASSERT(active_query);
232: 	D_ASSERT(active_query->executor);
233: 	return *active_query->executor;
234: }
235: 
236: const string &ClientContext::GetCurrentQuery() {
237: 	D_ASSERT(active_query);
238: 	return active_query->query;
239: }
240: 
241: unique_ptr<QueryResult> ClientContext::FetchResultInternal(ClientContextLock &lock, PendingQueryResult &pending) {
242: 	D_ASSERT(active_query);
243: 	D_ASSERT(active_query->open_result == &pending);
244: 	D_ASSERT(active_query->prepared);
245: 	auto &executor = GetExecutor();
246: 	auto &prepared = *active_query->prepared;
247: 	bool create_stream_result = prepared.properties.allow_stream_result && pending.allow_stream_result;
248: 	if (create_stream_result) {
249: 		D_ASSERT(!executor.HasResultCollector());
250: 		active_query->progress_bar.reset();
251: 		query_progress = -1;
252: 
253: 		// successfully compiled SELECT clause, and it is the last statement
254: 		// return a StreamQueryResult so the client can call Fetch() on it and stream the result
255: 		auto stream_result = make_uniq<StreamQueryResult>(pending.statement_type, pending.properties,
256: 		                                                  shared_from_this(), pending.types, pending.names);
257: 		active_query->open_result = stream_result.get();
258: 		return std::move(stream_result);
259: 	}
260: 	unique_ptr<QueryResult> result;
261: 	if (executor.HasResultCollector()) {
262: 		// we have a result collector - fetch the result directly from the result collector
263: 		result = executor.GetResult();
264: 		CleanupInternal(lock, result.get(), false);
265: 	} else {
266: 		// no result collector - create a materialized result by continuously fetching
267: 		auto result_collection = make_uniq<ColumnDataCollection>(Allocator::DefaultAllocator(), pending.types);
268: 		D_ASSERT(!result_collection->Types().empty());
269: 		auto materialized_result =
270: 		    make_uniq<MaterializedQueryResult>(pending.statement_type, pending.properties, pending.names,
271: 		                                       std::move(result_collection), GetClientProperties());
272: 
273: 		auto &collection = materialized_result->Collection();
274: 		D_ASSERT(!collection.Types().empty());
275: 		ColumnDataAppendState append_state;
276: 		collection.InitializeAppend(append_state);
277: 		while (true) {
278: 			auto chunk = FetchInternal(lock, GetExecutor(), *materialized_result);
279: 			if (!chunk || chunk->size() == 0) {
280: 				break;
281: 			}
282: #ifdef DEBUG
283: 			for (idx_t i = 0; i < chunk->ColumnCount(); i++) {
284: 				if (pending.types[i].id() == LogicalTypeId::VARCHAR) {
285: 					chunk->data[i].UTFVerify(chunk->size());
286: 				}
287: 			}
288: #endif
289: 			collection.Append(append_state, *chunk);
290: 		}
291: 		result = std::move(materialized_result);
292: 	}
293: 	return result;
294: }
295: 
296: static bool IsExplainAnalyze(SQLStatement *statement) {
297: 	if (!statement) {
298: 		return false;
299: 	}
300: 	if (statement->type != StatementType::EXPLAIN_STATEMENT) {
301: 		return false;
302: 	}
303: 	auto &explain = statement->Cast<ExplainStatement>();
304: 	return explain.explain_type == ExplainType::EXPLAIN_ANALYZE;
305: }
306: 
307: shared_ptr<PreparedStatementData> ClientContext::CreatePreparedStatement(ClientContextLock &lock, const string &query,
308:                                                                          unique_ptr<SQLStatement> statement,
309:                                                                          vector<Value> *values) {
310: 	StatementType statement_type = statement->type;
311: 	auto result = make_shared<PreparedStatementData>(statement_type);
312: 
313: 	auto &profiler = QueryProfiler::Get(*this);
314: 	profiler.StartQuery(query, IsExplainAnalyze(statement.get()), true);
315: 	profiler.StartPhase("planner");
316: 	Planner planner(*this);
317: 	if (values) {
318: 		for (auto &value : *values) {
319: 			planner.parameter_data.emplace_back(value);
320: 		}
321: 	}
322: 	planner.CreatePlan(std::move(statement));
323: 	D_ASSERT(planner.plan || !planner.properties.bound_all_parameters);
324: 	profiler.EndPhase();
325: 
326: 	auto plan = std::move(planner.plan);
327: 	// extract the result column names from the plan
328: 	result->properties = planner.properties;
329: 	result->names = planner.names;
330: 	result->types = planner.types;
331: 	result->value_map = std::move(planner.value_map);
332: 	result->catalog_version = MetaTransaction::Get(*this).catalog_version;
333: 
334: 	if (!planner.properties.bound_all_parameters) {
335: 		return result;
336: 	}
337: #ifdef DEBUG
338: 	plan->Verify(*this);
339: #endif
340: 	if (config.enable_optimizer && plan->RequireOptimizer()) {
341: 		profiler.StartPhase("optimizer");
342: 		Optimizer optimizer(*planner.binder, *this);
343: 		plan = optimizer.Optimize(std::move(plan));
344: 		D_ASSERT(plan);
345: 		profiler.EndPhase();
346: 
347: #ifdef DEBUG
348: 		plan->Verify(*this);
349: #endif
350: 	}
351: 
352: 	profiler.StartPhase("physical_planner");
353: 	// now convert logical query plan into a physical query plan
354: 	PhysicalPlanGenerator physical_planner(*this);
355: 	auto physical_plan = physical_planner.CreatePlan(std::move(plan));
356: 	profiler.EndPhase();
357: 
358: #ifdef DEBUG
359: 	D_ASSERT(!physical_plan->ToString().empty());
360: #endif
361: 	result->plan = std::move(physical_plan);
362: 	return result;
363: }
364: 
365: double ClientContext::GetProgress() {
366: 	return query_progress.load();
367: }
368: 
369: unique_ptr<PendingQueryResult> ClientContext::PendingPreparedStatement(ClientContextLock &lock,
370:                                                                        shared_ptr<PreparedStatementData> statement_p,
371:                                                                        PendingQueryParameters parameters) {
372: 	D_ASSERT(active_query);
373: 	auto &statement = *statement_p;
374: 	if (ValidChecker::IsInvalidated(ActiveTransaction()) && statement.properties.requires_valid_transaction) {
375: 		throw Exception(ErrorManager::FormatException(*this, ErrorType::INVALIDATED_TRANSACTION));
376: 	}
377: 	auto &transaction = MetaTransaction::Get(*this);
378: 	auto &manager = DatabaseManager::Get(*this);
379: 	for (auto &modified_database : statement.properties.modified_databases) {
380: 		auto entry = manager.GetDatabase(*this, modified_database);
381: 		if (!entry) {
382: 			throw InternalException("Database \"%s\" not found", modified_database);
383: 		}
384: 		if (entry->IsReadOnly()) {
385: 			throw Exception(StringUtil::Format(
386: 			    "Cannot execute statement of type \"%s\" on database \"%s\" which is attached in read-only mode!",
387: 			    StatementTypeToString(statement.statement_type), modified_database));
388: 		}
389: 		transaction.ModifyDatabase(*entry);
390: 	}
391: 
392: 	// bind the bound values before execution
393: 	statement.Bind(parameters.parameters ? *parameters.parameters : vector<Value>());
394: 
395: 	active_query->executor = make_uniq<Executor>(*this);
396: 	auto &executor = *active_query->executor;
397: 	if (config.enable_progress_bar) {
398: 		progress_bar_display_create_func_t display_create_func = nullptr;
399: 		if (config.print_progress_bar) {
400: 			// If a custom display is set, use that, otherwise just use the default
401: 			display_create_func =
402: 			    config.display_create_func ? config.display_create_func : ProgressBar::DefaultProgressBarDisplay;
403: 		}
404: 		active_query->progress_bar = make_uniq<ProgressBar>(executor, config.wait_time, display_create_func);
405: 		active_query->progress_bar->Start();
406: 		query_progress = 0;
407: 	}
408: 	auto stream_result = parameters.allow_stream_result && statement.properties.allow_stream_result;
409: 	if (!stream_result && statement.properties.return_type == StatementReturnType::QUERY_RESULT) {
410: 		unique_ptr<PhysicalResultCollector> collector;
411: 		auto &config = ClientConfig::GetConfig(*this);
412: 		auto get_method =
413: 		    config.result_collector ? config.result_collector : PhysicalResultCollector::GetResultCollector;
414: 		collector = get_method(*this, statement);
415: 		D_ASSERT(collector->type == PhysicalOperatorType::RESULT_COLLECTOR);
416: 		executor.Initialize(std::move(collector));
417: 	} else {
418: 		executor.Initialize(*statement.plan);
419: 	}
420: 	auto types = executor.GetTypes();
421: 	D_ASSERT(types == statement.types);
422: 	D_ASSERT(!active_query->open_result);
423: 
424: 	auto pending_result =
425: 	    make_uniq<PendingQueryResult>(shared_from_this(), *statement_p, std::move(types), stream_result);
426: 	active_query->prepared = std::move(statement_p);
427: 	active_query->open_result = pending_result.get();
428: 	return pending_result;
429: }
430: 
431: PendingExecutionResult ClientContext::ExecuteTaskInternal(ClientContextLock &lock, PendingQueryResult &result) {
432: 	D_ASSERT(active_query);
433: 	D_ASSERT(active_query->open_result == &result);
434: 	try {
435: 		auto result = active_query->executor->ExecuteTask();
436: 		if (active_query->progress_bar) {
437: 			active_query->progress_bar->Update(result == PendingExecutionResult::RESULT_READY);
438: 			query_progress = active_query->progress_bar->GetCurrentPercentage();
439: 		}
440: 		return result;
441: 	} catch (FatalException &ex) {
442: 		// fatal exceptions invalidate the entire database
443: 		result.SetError(PreservedError(ex));
444: 		auto &db = DatabaseInstance::GetDatabase(*this);
445: 		ValidChecker::Invalidate(db, ex.what());
446: 	} catch (const Exception &ex) {
447: 		result.SetError(PreservedError(ex));
448: 	} catch (std::exception &ex) {
449: 		result.SetError(PreservedError(ex));
450: 	} catch (...) { // LCOV_EXCL_START
451: 		result.SetError(PreservedError("Unhandled exception in ExecuteTaskInternal"));
452: 	} // LCOV_EXCL_STOP
453: 	EndQueryInternal(lock, false, true);
454: 	return PendingExecutionResult::EXECUTION_ERROR;
455: }
456: 
457: void ClientContext::InitialCleanup(ClientContextLock &lock) {
458: 	//! Cleanup any open results and reset the interrupted flag
459: 	CleanupInternal(lock);
460: 	interrupted = false;
461: }
462: 
463: vector<unique_ptr<SQLStatement>> ClientContext::ParseStatements(const string &query) {
464: 	auto lock = LockContext();
465: 	return ParseStatementsInternal(*lock, query);
466: }
467: 
468: vector<unique_ptr<SQLStatement>> ClientContext::ParseStatementsInternal(ClientContextLock &lock, const string &query) {
469: 	Parser parser(GetParserOptions());
470: 	parser.ParseQuery(query);
471: 
472: 	PragmaHandler handler(*this);
473: 	handler.HandlePragmaStatements(lock, parser.statements);
474: 
475: 	return std::move(parser.statements);
476: }
477: 
478: void ClientContext::HandlePragmaStatements(vector<unique_ptr<SQLStatement>> &statements) {
479: 	auto lock = LockContext();
480: 
481: 	PragmaHandler handler(*this);
482: 	handler.HandlePragmaStatements(*lock, statements);
483: }
484: 
485: unique_ptr<LogicalOperator> ClientContext::ExtractPlan(const string &query) {
486: 	auto lock = LockContext();
487: 
488: 	auto statements = ParseStatementsInternal(*lock, query);
489: 	if (statements.size() != 1) {
490: 		throw Exception("ExtractPlan can only prepare a single statement");
491: 	}
492: 
493: 	unique_ptr<LogicalOperator> plan;
494: 	client_data->http_state = make_uniq<HTTPState>();
495: 	RunFunctionInTransactionInternal(*lock, [&]() {
496: 		Planner planner(*this);
497: 		planner.CreatePlan(std::move(statements[0]));
498: 		D_ASSERT(planner.plan);
499: 
500: 		plan = std::move(planner.plan);
501: 
502: 		if (config.enable_optimizer) {
503: 			Optimizer optimizer(*planner.binder, *this);
504: 			plan = optimizer.Optimize(std::move(plan));
505: 		}
506: 
507: 		ColumnBindingResolver resolver;
508: 		resolver.Verify(*plan);
509: 		resolver.VisitOperator(*plan);
510: 
511: 		plan->ResolveOperatorTypes();
512: 	});
513: 	return plan;
514: }
515: 
516: unique_ptr<PreparedStatement> ClientContext::PrepareInternal(ClientContextLock &lock,
517:                                                              unique_ptr<SQLStatement> statement) {
518: 	auto n_param = statement->n_param;
519: 	auto named_param_map = std::move(statement->named_param_map);
520: 	auto statement_query = statement->query;
521: 	shared_ptr<PreparedStatementData> prepared_data;
522: 	auto unbound_statement = statement->Copy();
523: 	RunFunctionInTransactionInternal(
524: 	    lock, [&]() { prepared_data = CreatePreparedStatement(lock, statement_query, std::move(statement)); }, false);
525: 	prepared_data->unbound_statement = std::move(unbound_statement);
526: 	return make_uniq<PreparedStatement>(shared_from_this(), std::move(prepared_data), std::move(statement_query),
527: 	                                    n_param, std::move(named_param_map));
528: }
529: 
530: unique_ptr<PreparedStatement> ClientContext::Prepare(unique_ptr<SQLStatement> statement) {
531: 	auto lock = LockContext();
532: 	// prepare the query
533: 	try {
534: 		InitialCleanup(*lock);
535: 		return PrepareInternal(*lock, std::move(statement));
536: 	} catch (const Exception &ex) {
537: 		return make_uniq<PreparedStatement>(PreservedError(ex));
538: 	} catch (std::exception &ex) {
539: 		return make_uniq<PreparedStatement>(PreservedError(ex));
540: 	}
541: }
542: 
543: unique_ptr<PreparedStatement> ClientContext::Prepare(const string &query) {
544: 	auto lock = LockContext();
545: 	// prepare the query
546: 	try {
547: 		InitialCleanup(*lock);
548: 
549: 		// first parse the query
550: 		auto statements = ParseStatementsInternal(*lock, query);
551: 		if (statements.empty()) {
552: 			throw Exception("No statement to prepare!");
553: 		}
554: 		if (statements.size() > 1) {
555: 			throw Exception("Cannot prepare multiple statements at once!");
556: 		}
557: 		return PrepareInternal(*lock, std::move(statements[0]));
558: 	} catch (const Exception &ex) {
559: 		return make_uniq<PreparedStatement>(PreservedError(ex));
560: 	} catch (std::exception &ex) {
561: 		return make_uniq<PreparedStatement>(PreservedError(ex));
562: 	}
563: }
564: 
565: unique_ptr<PendingQueryResult> ClientContext::PendingQueryPreparedInternal(ClientContextLock &lock, const string &query,
566:                                                                            shared_ptr<PreparedStatementData> &prepared,
567:                                                                            PendingQueryParameters parameters) {
568: 	try {
569: 		InitialCleanup(lock);
570: 	} catch (const Exception &ex) {
571: 		return make_uniq<PendingQueryResult>(PreservedError(ex));
572: 	} catch (std::exception &ex) {
573: 		return make_uniq<PendingQueryResult>(PreservedError(ex));
574: 	}
575: 	return PendingStatementOrPreparedStatementInternal(lock, query, nullptr, prepared, parameters);
576: }
577: 
578: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const string &query,
579:                                                            shared_ptr<PreparedStatementData> &prepared,
580:                                                            PendingQueryParameters parameters) {
581: 	auto lock = LockContext();
582: 	return PendingQueryPreparedInternal(*lock, query, prepared, parameters);
583: }
584: 
585: unique_ptr<QueryResult> ClientContext::Execute(const string &query, shared_ptr<PreparedStatementData> &prepared,
586:                                                PendingQueryParameters parameters) {
587: 	auto lock = LockContext();
588: 	auto pending = PendingQueryPreparedInternal(*lock, query, prepared, parameters);
589: 	if (pending->HasError()) {
590: 		return make_uniq<MaterializedQueryResult>(pending->GetErrorObject());
591: 	}
592: 	return pending->ExecuteInternal(*lock);
593: }
594: 
595: unique_ptr<QueryResult> ClientContext::Execute(const string &query, shared_ptr<PreparedStatementData> &prepared,
596:                                                vector<Value> &values, bool allow_stream_result) {
597: 	PendingQueryParameters parameters;
598: 	parameters.parameters = &values;
599: 	parameters.allow_stream_result = allow_stream_result;
600: 	return Execute(query, prepared, parameters);
601: }
602: 
603: unique_ptr<PendingQueryResult> ClientContext::PendingStatementInternal(ClientContextLock &lock, const string &query,
604:                                                                        unique_ptr<SQLStatement> statement,
605:                                                                        PendingQueryParameters parameters) {
606: 	// prepare the query for execution
607: 	auto prepared = CreatePreparedStatement(lock, query, std::move(statement), parameters.parameters);
608: 	if (prepared->properties.parameter_count > 0 && !parameters.parameters) {
609: 		string error_message = StringUtil::Format("Expected %lld parameters, but none were supplied",
610: 		                                          prepared->properties.parameter_count);
611: 		return make_uniq<PendingQueryResult>(PreservedError(error_message));
612: 	}
613: 	if (!prepared->properties.bound_all_parameters) {
614: 		return make_uniq<PendingQueryResult>(PreservedError("Not all parameters were bound"));
615: 	}
616: 	// execute the prepared statement
617: 	return PendingPreparedStatement(lock, std::move(prepared), parameters);
618: }
619: 
620: unique_ptr<QueryResult> ClientContext::RunStatementInternal(ClientContextLock &lock, const string &query,
621:                                                             unique_ptr<SQLStatement> statement,
622:                                                             bool allow_stream_result, bool verify) {
623: 	PendingQueryParameters parameters;
624: 	parameters.allow_stream_result = allow_stream_result;
625: 	auto pending = PendingQueryInternal(lock, std::move(statement), parameters, verify);
626: 	if (pending->HasError()) {
627: 		return make_uniq<MaterializedQueryResult>(pending->GetErrorObject());
628: 	}
629: 	return ExecutePendingQueryInternal(lock, *pending);
630: }
631: 
632: bool ClientContext::IsActiveResult(ClientContextLock &lock, BaseQueryResult *result) {
633: 	if (!active_query) {
634: 		return false;
635: 	}
636: 	return active_query->open_result == result;
637: }
638: 
639: unique_ptr<PendingQueryResult> ClientContext::PendingStatementOrPreparedStatementInternal(
640:     ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,
641:     shared_ptr<PreparedStatementData> &prepared, PendingQueryParameters parameters) {
642: 	// check if we are on AutoCommit. In this case we should start a transaction.
643: 	if (statement && config.AnyVerification()) {
644: 		// query verification is enabled
645: 		// create a copy of the statement, and use the copy
646: 		// this way we verify that the copy correctly copies all properties
647: 		auto copied_statement = statement->Copy();
648: 		switch (statement->type) {
649: 		case StatementType::SELECT_STATEMENT: {
650: 			// in case this is a select query, we verify the original statement
651: 			PreservedError error;
652: 			try {
653: 				error = VerifyQuery(lock, query, std::move(statement));
654: 			} catch (const Exception &ex) {
655: 				error = PreservedError(ex);
656: 			} catch (std::exception &ex) {
657: 				error = PreservedError(ex);
658: 			}
659: 			if (error) {
660: 				// error in verifying query
661: 				return make_uniq<PendingQueryResult>(error);
662: 			}
663: 			statement = std::move(copied_statement);
664: 			break;
665: 		}
666: #ifndef DUCKDB_ALTERNATIVE_VERIFY
667: 		case StatementType::COPY_STATEMENT:
668: 		case StatementType::INSERT_STATEMENT:
669: 		case StatementType::DELETE_STATEMENT:
670: 		case StatementType::UPDATE_STATEMENT: {
671: 			Parser parser;
672: 			PreservedError error;
673: 			try {
674: 				parser.ParseQuery(statement->ToString());
675: 			} catch (const Exception &ex) {
676: 				error = PreservedError(ex);
677: 			} catch (std::exception &ex) {
678: 				error = PreservedError(ex);
679: 			}
680: 			if (error) {
681: 				// error in verifying query
682: 				return make_uniq<PendingQueryResult>(error);
683: 			}
684: 			statement = std::move(parser.statements[0]);
685: 			break;
686: 		}
687: #endif
688: 		default:
689: 			statement = std::move(copied_statement);
690: 			break;
691: 		}
692: 	}
693: 	return PendingStatementOrPreparedStatement(lock, query, std::move(statement), prepared, parameters);
694: }
695: 
696: unique_ptr<PendingQueryResult> ClientContext::PendingStatementOrPreparedStatement(
697:     ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,
698:     shared_ptr<PreparedStatementData> &prepared, PendingQueryParameters parameters) {
699: 	unique_ptr<PendingQueryResult> result;
700: 
701: 	try {
702: 		BeginQueryInternal(lock, query);
703: 	} catch (FatalException &ex) {
704: 		// fatal exceptions invalidate the entire database
705: 		auto &db = DatabaseInstance::GetDatabase(*this);
706: 		ValidChecker::Invalidate(db, ex.what());
707: 		result = make_uniq<PendingQueryResult>(PreservedError(ex));
708: 		return result;
709: 	} catch (const Exception &ex) {
710: 		return make_uniq<PendingQueryResult>(PreservedError(ex));
711: 	} catch (std::exception &ex) {
712: 		return make_uniq<PendingQueryResult>(PreservedError(ex));
713: 	}
714: 	// start the profiler
715: 	auto &profiler = QueryProfiler::Get(*this);
716: 	profiler.StartQuery(query, IsExplainAnalyze(statement ? statement.get() : prepared->unbound_statement.get()));
717: 
718: 	bool invalidate_query = true;
719: 	try {
720: 		if (statement) {
721: 			result = PendingStatementInternal(lock, query, std::move(statement), parameters);
722: 		} else {
723: 			if (prepared->RequireRebind(*this, *parameters.parameters)) {
724: 				// catalog was modified: rebind the statement before execution
725: 				auto new_prepared =
726: 				    CreatePreparedStatement(lock, query, prepared->unbound_statement->Copy(), parameters.parameters);
727: 				D_ASSERT(new_prepared->properties.bound_all_parameters);
728: 				new_prepared->unbound_statement = std::move(prepared->unbound_statement);
729: 				prepared = std::move(new_prepared);
730: 				prepared->properties.bound_all_parameters = false;
731: 			}
732: 			result = PendingPreparedStatement(lock, prepared, parameters);
733: 		}
734: 	} catch (StandardException &ex) {
735: 		// standard exceptions do not invalidate the current transaction
736: 		result = make_uniq<PendingQueryResult>(PreservedError(ex));
737: 		invalidate_query = false;
738: 	} catch (FatalException &ex) {
739: 		// fatal exceptions invalidate the entire database
740: 		if (!config.query_verification_enabled) {
741: 			auto &db = DatabaseInstance::GetDatabase(*this);
742: 			ValidChecker::Invalidate(db, ex.what());
743: 		}
744: 		result = make_uniq<PendingQueryResult>(PreservedError(ex));
745: 	} catch (const Exception &ex) {
746: 		// other types of exceptions do invalidate the current transaction
747: 		result = make_uniq<PendingQueryResult>(PreservedError(ex));
748: 	} catch (std::exception &ex) {
749: 		// other types of exceptions do invalidate the current transaction
750: 		result = make_uniq<PendingQueryResult>(PreservedError(ex));
751: 	}
752: 	if (result->HasError()) {
753: 		// query failed: abort now
754: 		EndQueryInternal(lock, false, invalidate_query);
755: 		return result;
756: 	}
757: 	D_ASSERT(active_query->open_result == result.get());
758: 	return result;
759: }
760: 
761: void ClientContext::LogQueryInternal(ClientContextLock &, const string &query) {
762: 	if (!client_data->log_query_writer) {
763: #ifdef DUCKDB_FORCE_QUERY_LOG
764: 		try {
765: 			string log_path(DUCKDB_FORCE_QUERY_LOG);
766: 			client_data->log_query_writer =
767: 			    make_uniq<BufferedFileWriter>(FileSystem::GetFileSystem(*this), log_path,
768: 			                                  BufferedFileWriter::DEFAULT_OPEN_FLAGS, client_data->file_opener.get());
769: 		} catch (...) {
770: 			return;
771: 		}
772: #else
773: 		return;
774: #endif
775: 	}
776: 	// log query path is set: log the query
777: 	client_data->log_query_writer->WriteData((const_data_ptr_t)query.c_str(), query.size());
778: 	client_data->log_query_writer->WriteData((const_data_ptr_t) "\n", 1);
779: 	client_data->log_query_writer->Flush();
780: 	client_data->log_query_writer->Sync();
781: }
782: 
783: unique_ptr<QueryResult> ClientContext::Query(unique_ptr<SQLStatement> statement, bool allow_stream_result) {
784: 	auto pending_query = PendingQuery(std::move(statement), allow_stream_result);
785: 	if (pending_query->HasError()) {
786: 		return make_uniq<MaterializedQueryResult>(pending_query->GetErrorObject());
787: 	}
788: 	return pending_query->Execute();
789: }
790: 
791: unique_ptr<QueryResult> ClientContext::Query(const string &query, bool allow_stream_result) {
792: 	auto lock = LockContext();
793: 
794: 	PreservedError error;
795: 	vector<unique_ptr<SQLStatement>> statements;
796: 	if (!ParseStatements(*lock, query, statements, error)) {
797: 		return make_uniq<MaterializedQueryResult>(std::move(error));
798: 	}
799: 	if (statements.empty()) {
800: 		// no statements, return empty successful result
801: 		StatementProperties properties;
802: 		vector<string> names;
803: 		auto collection = make_uniq<ColumnDataCollection>(Allocator::DefaultAllocator());
804: 		return make_uniq<MaterializedQueryResult>(StatementType::INVALID_STATEMENT, properties, std::move(names),
805: 		                                          std::move(collection), GetClientProperties());
806: 	}
807: 
808: 	unique_ptr<QueryResult> result;
809: 	QueryResult *last_result = nullptr;
810: 	bool last_had_result = false;
811: 	for (idx_t i = 0; i < statements.size(); i++) {
812: 		auto &statement = statements[i];
813: 		bool is_last_statement = i + 1 == statements.size();
814: 		PendingQueryParameters parameters;
815: 		parameters.allow_stream_result = allow_stream_result && is_last_statement;
816: 		auto pending_query = PendingQueryInternal(*lock, std::move(statement), parameters);
817: 		auto has_result = pending_query->properties.return_type == StatementReturnType::QUERY_RESULT;
818: 		unique_ptr<QueryResult> current_result;
819: 		if (pending_query->HasError()) {
820: 			current_result = make_uniq<MaterializedQueryResult>(pending_query->GetErrorObject());
821: 		} else {
822: 			current_result = ExecutePendingQueryInternal(*lock, *pending_query);
823: 		}
824: 		// now append the result to the list of results
825: 		if (!last_result || !last_had_result) {
826: 			// first result of the query
827: 			result = std::move(current_result);
828: 			last_result = result.get();
829: 			last_had_result = has_result;
830: 		} else {
831: 			// later results; attach to the result chain
832: 			// but only if there is a result
833: 			if (!has_result) {
834: 				continue;
835: 			}
836: 			last_result->next = std::move(current_result);
837: 			last_result = last_result->next.get();
838: 		}
839: 	}
840: 	return result;
841: }
842: 
843: bool ClientContext::ParseStatements(ClientContextLock &lock, const string &query,
844:                                     vector<unique_ptr<SQLStatement>> &result, PreservedError &error) {
845: 	try {
846: 		InitialCleanup(lock);
847: 		// parse the query and transform it into a set of statements
848: 		result = ParseStatementsInternal(lock, query);
849: 		return true;
850: 	} catch (const Exception &ex) {
851: 		error = PreservedError(ex);
852: 		return false;
853: 	} catch (std::exception &ex) {
854: 		error = PreservedError(ex);
855: 		return false;
856: 	}
857: }
858: 
859: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const string &query, bool allow_stream_result) {
860: 	auto lock = LockContext();
861: 
862: 	PreservedError error;
863: 	vector<unique_ptr<SQLStatement>> statements;
864: 	if (!ParseStatements(*lock, query, statements, error)) {
865: 		return make_uniq<PendingQueryResult>(std::move(error));
866: 	}
867: 	if (statements.size() != 1) {
868: 		return make_uniq<PendingQueryResult>(PreservedError("PendingQuery can only take a single statement"));
869: 	}
870: 	PendingQueryParameters parameters;
871: 	parameters.allow_stream_result = allow_stream_result;
872: 	return PendingQueryInternal(*lock, std::move(statements[0]), parameters);
873: }
874: 
875: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(unique_ptr<SQLStatement> statement,
876:                                                            bool allow_stream_result) {
877: 	auto lock = LockContext();
878: 	PendingQueryParameters parameters;
879: 	parameters.allow_stream_result = allow_stream_result;
880: 	return PendingQueryInternal(*lock, std::move(statement), parameters);
881: }
882: 
883: unique_ptr<PendingQueryResult> ClientContext::PendingQueryInternal(ClientContextLock &lock,
884:                                                                    unique_ptr<SQLStatement> statement,
885:                                                                    PendingQueryParameters parameters, bool verify) {
886: 	auto query = statement->query;
887: 	shared_ptr<PreparedStatementData> prepared;
888: 	if (verify) {
889: 		return PendingStatementOrPreparedStatementInternal(lock, query, std::move(statement), prepared, parameters);
890: 	} else {
891: 		return PendingStatementOrPreparedStatement(lock, query, std::move(statement), prepared, parameters);
892: 	}
893: }
894: 
895: unique_ptr<QueryResult> ClientContext::ExecutePendingQueryInternal(ClientContextLock &lock, PendingQueryResult &query) {
896: 	return query.ExecuteInternal(lock);
897: }
898: 
899: void ClientContext::Interrupt() {
900: 	interrupted = true;
901: }
902: 
903: void ClientContext::EnableProfiling() {
904: 	auto lock = LockContext();
905: 	auto &config = ClientConfig::GetConfig(*this);
906: 	config.enable_profiler = true;
907: 	config.emit_profiler_output = true;
908: }
909: 
910: void ClientContext::DisableProfiling() {
911: 	auto lock = LockContext();
912: 	auto &config = ClientConfig::GetConfig(*this);
913: 	config.enable_profiler = false;
914: }
915: 
916: void ClientContext::RegisterFunction(CreateFunctionInfo &info) {
917: 	RunFunctionInTransaction([&]() {
918: 		auto existing_function = Catalog::GetEntry<ScalarFunctionCatalogEntry>(*this, INVALID_CATALOG, info.schema,
919: 		                                                                       info.name, OnEntryNotFound::RETURN_NULL);
920: 		if (existing_function) {
921: 			auto &new_info = (CreateScalarFunctionInfo &)info;
922: 			if (new_info.functions.MergeFunctionSet(existing_function->functions)) {
923: 				// function info was updated from catalog entry, rewrite is needed
924: 				info.on_conflict = OnCreateConflict::REPLACE_ON_CONFLICT;
925: 			}
926: 		}
927: 		// create function
928: 		auto &catalog = Catalog::GetSystemCatalog(*this);
929: 		catalog.CreateFunction(*this, info);
930: 	});
931: }
932: 
933: void ClientContext::RunFunctionInTransactionInternal(ClientContextLock &lock, const std::function<void(void)> &fun,
934:                                                      bool requires_valid_transaction) {
935: 	if (requires_valid_transaction && transaction.HasActiveTransaction() &&
936: 	    ValidChecker::IsInvalidated(ActiveTransaction())) {
937: 		throw Exception(ErrorManager::FormatException(*this, ErrorType::INVALIDATED_TRANSACTION));
938: 	}
939: 	// check if we are on AutoCommit. In this case we should start a transaction
940: 	bool require_new_transaction = transaction.IsAutoCommit() && !transaction.HasActiveTransaction();
941: 	if (require_new_transaction) {
942: 		D_ASSERT(!active_query);
943: 		transaction.BeginTransaction();
944: 	}
945: 	try {
946: 		fun();
947: 	} catch (StandardException &ex) {
948: 		if (require_new_transaction) {
949: 			transaction.Rollback();
950: 		}
951: 		throw;
952: 	} catch (FatalException &ex) {
953: 		auto &db = DatabaseInstance::GetDatabase(*this);
954: 		ValidChecker::Invalidate(db, ex.what());
955: 		throw;
956: 	} catch (std::exception &ex) {
957: 		if (require_new_transaction) {
958: 			transaction.Rollback();
959: 		} else {
960: 			ValidChecker::Invalidate(ActiveTransaction(), ex.what());
961: 		}
962: 		throw;
963: 	}
964: 	if (require_new_transaction) {
965: 		transaction.Commit();
966: 	}
967: }
968: 
969: void ClientContext::RunFunctionInTransaction(const std::function<void(void)> &fun, bool requires_valid_transaction) {
970: 	auto lock = LockContext();
971: 	RunFunctionInTransactionInternal(*lock, fun, requires_valid_transaction);
972: }
973: 
974: unique_ptr<TableDescription> ClientContext::TableInfo(const string &schema_name, const string &table_name) {
975: 	unique_ptr<TableDescription> result;
976: 	RunFunctionInTransaction([&]() {
977: 		// obtain the table info
978: 		auto table = Catalog::GetEntry<TableCatalogEntry>(*this, INVALID_CATALOG, schema_name, table_name,
979: 		                                                  OnEntryNotFound::RETURN_NULL);
980: 		if (!table) {
981: 			return;
982: 		}
983: 		// write the table info to the result
984: 		result = make_uniq<TableDescription>();
985: 		result->schema = schema_name;
986: 		result->table = table_name;
987: 		for (auto &column : table->GetColumns().Logical()) {
988: 			result->columns.emplace_back(column.Name(), column.Type());
989: 		}
990: 	});
991: 	return result;
992: }
993: 
994: void ClientContext::Append(TableDescription &description, ColumnDataCollection &collection) {
995: 	RunFunctionInTransaction([&]() {
996: 		auto &table_entry =
997: 		    Catalog::GetEntry<TableCatalogEntry>(*this, INVALID_CATALOG, description.schema, description.table);
998: 		// verify that the table columns and types match up
999: 		if (description.columns.size() != table_entry.GetColumns().PhysicalColumnCount()) {
1000: 			throw Exception("Failed to append: table entry has different number of columns!");
1001: 		}
1002: 		for (idx_t i = 0; i < description.columns.size(); i++) {
1003: 			if (description.columns[i].Type() != table_entry.GetColumns().GetColumn(PhysicalIndex(i)).Type()) {
1004: 				throw Exception("Failed to append: table entry has different number of columns!");
1005: 			}
1006: 		}
1007: 		table_entry.GetStorage().LocalAppend(table_entry, *this, collection);
1008: 	});
1009: }
1010: 
1011: void ClientContext::TryBindRelation(Relation &relation, vector<ColumnDefinition> &result_columns) {
1012: #ifdef DEBUG
1013: 	D_ASSERT(!relation.GetAlias().empty());
1014: 	D_ASSERT(!relation.ToString().empty());
1015: #endif
1016: 	RunFunctionInTransaction([&]() {
1017: 		// bind the expressions
1018: 		auto binder = Binder::CreateBinder(*this);
1019: 		auto result = relation.Bind(*binder);
1020: 		D_ASSERT(result.names.size() == result.types.size());
1021: 
1022: 		result_columns.reserve(result_columns.size() + result.names.size());
1023: 		for (idx_t i = 0; i < result.names.size(); i++) {
1024: 			result_columns.emplace_back(result.names[i], result.types[i]);
1025: 		}
1026: 	});
1027: }
1028: 
1029: unordered_set<string> ClientContext::GetTableNames(const string &query) {
1030: 	auto lock = LockContext();
1031: 
1032: 	auto statements = ParseStatementsInternal(*lock, query);
1033: 	if (statements.size() != 1) {
1034: 		throw InvalidInputException("Expected a single statement");
1035: 	}
1036: 
1037: 	unordered_set<string> result;
1038: 	RunFunctionInTransactionInternal(*lock, [&]() {
1039: 		// bind the expressions
1040: 		auto binder = Binder::CreateBinder(*this);
1041: 		binder->SetBindingMode(BindingMode::EXTRACT_NAMES);
1042: 		binder->Bind(*statements[0]);
1043: 		result = binder->GetTableNames();
1044: 	});
1045: 	return result;
1046: }
1047: 
1048: unique_ptr<PendingQueryResult> ClientContext::PendingQueryInternal(ClientContextLock &lock,
1049:                                                                    const shared_ptr<Relation> &relation,
1050:                                                                    bool allow_stream_result) {
1051: 	InitialCleanup(lock);
1052: 
1053: 	string query;
1054: 	if (config.query_verification_enabled) {
1055: 		// run the ToString method of any relation we run, mostly to ensure it doesn't crash
1056: 		relation->ToString();
1057: 		relation->GetAlias();
1058: 		if (relation->IsReadOnly()) {
1059: 			// verify read only statements by running a select statement
1060: 			auto select = make_uniq<SelectStatement>();
1061: 			select->node = relation->GetQueryNode();
1062: 			RunStatementInternal(lock, query, std::move(select), false);
1063: 		}
1064: 	}
1065: 
1066: 	auto relation_stmt = make_uniq<RelationStatement>(relation);
1067: 	PendingQueryParameters parameters;
1068: 	parameters.allow_stream_result = allow_stream_result;
1069: 	return PendingQueryInternal(lock, std::move(relation_stmt), parameters);
1070: }
1071: 
1072: unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const shared_ptr<Relation> &relation,
1073:                                                            bool allow_stream_result) {
1074: 	auto lock = LockContext();
1075: 	return PendingQueryInternal(*lock, relation, allow_stream_result);
1076: }
1077: 
1078: unique_ptr<QueryResult> ClientContext::Execute(const shared_ptr<Relation> &relation) {
1079: 	auto lock = LockContext();
1080: 	auto &expected_columns = relation->Columns();
1081: 	auto pending = PendingQueryInternal(*lock, relation, false);
1082: 	if (!pending->success) {
1083: 		return make_uniq<MaterializedQueryResult>(pending->GetErrorObject());
1084: 	}
1085: 
1086: 	unique_ptr<QueryResult> result;
1087: 	result = ExecutePendingQueryInternal(*lock, *pending);
1088: 	if (result->HasError()) {
1089: 		return result;
1090: 	}
1091: 	// verify that the result types and result names of the query match the expected result types/names
1092: 	if (result->types.size() == expected_columns.size()) {
1093: 		bool mismatch = false;
1094: 		for (idx_t i = 0; i < result->types.size(); i++) {
1095: 			if (result->types[i] != expected_columns[i].Type() || result->names[i] != expected_columns[i].Name()) {
1096: 				mismatch = true;
1097: 				break;
1098: 			}
1099: 		}
1100: 		if (!mismatch) {
1101: 			// all is as expected: return the result
1102: 			return result;
1103: 		}
1104: 	}
1105: 	// result mismatch
1106: 	string err_str = "Result mismatch in query!\nExpected the following columns: [";
1107: 	for (idx_t i = 0; i < expected_columns.size(); i++) {
1108: 		if (i > 0) {
1109: 			err_str += ", ";
1110: 		}
1111: 		err_str += expected_columns[i].Name() + " " + expected_columns[i].Type().ToString();
1112: 	}
1113: 	err_str += "]\nBut result contained the following: ";
1114: 	for (idx_t i = 0; i < result->types.size(); i++) {
1115: 		err_str += i == 0 ? "[" : ", ";
1116: 		err_str += result->names[i] + " " + result->types[i].ToString();
1117: 	}
1118: 	err_str += "]";
1119: 	return make_uniq<MaterializedQueryResult>(PreservedError(err_str));
1120: }
1121: 
1122: bool ClientContext::TryGetCurrentSetting(const std::string &key, Value &result) {
1123: 	// first check the built-in settings
1124: 	auto &db_config = DBConfig::GetConfig(*this);
1125: 	auto option = db_config.GetOptionByName(key);
1126: 	if (option) {
1127: 		result = option->get_setting(*this);
1128: 		return true;
1129: 	}
1130: 
1131: 	// check the client session values
1132: 	const auto &session_config_map = config.set_variables;
1133: 
1134: 	auto session_value = session_config_map.find(key);
1135: 	bool found_session_value = session_value != session_config_map.end();
1136: 	if (found_session_value) {
1137: 		result = session_value->second;
1138: 		return true;
1139: 	}
1140: 	// finally check the global session values
1141: 	return db->TryGetCurrentSetting(key, result);
1142: }
1143: 
1144: ParserOptions ClientContext::GetParserOptions() const {
1145: 	auto &client_config = ClientConfig::GetConfig(*this);
1146: 	ParserOptions options;
1147: 	options.preserve_identifier_case = client_config.preserve_identifier_case;
1148: 	options.integer_division = client_config.integer_division;
1149: 	options.max_expression_depth = client_config.max_expression_depth;
1150: 	options.extensions = &DBConfig::GetConfig(*this).parser_extensions;
1151: 	return options;
1152: }
1153: 
1154: ClientProperties ClientContext::GetClientProperties() const {
1155: 	ClientProperties properties;
1156: 	properties.time_zone = ClientConfig::GetConfig(*this).ExtractTimezone();
1157: 	return properties;
1158: }
1159: 
1160: bool ClientContext::ExecutionIsFinished() {
1161: 	if (!active_query || !active_query->executor) {
1162: 		return false;
1163: 	}
1164: 	return active_query->executor->ExecutionIsFinished();
1165: }
1166: 
1167: } // namespace duckdb
[end of src/main/client_context.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.py
+++ b/file.py
@@ -1,27 +1,35 @@
def euclidean(a, b):
-    while b:
-        a, b = b, a % b
-    return a
+    if b == 0:
+        return a
+    return euclidean(b, a % b)

def bresenham(x0, y0, x1, y1):
    points = []
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
-    sx = 1 if x0 < x1 else -1
-    sy = 1 if y0 < y1 else -1
-    err = dx - dy
+    x, y = x0, y0
+    sx = -1 if x0 > x1 else 1
+    sy = -1 if y0 > y1 else 1
    
-    while True:
-        points.append((x, y))
-        if x == x1 and y == y1:
-            break
-        e2 = 2 * err
-        if e2 > -dy:
+    if dx > dy:
+        err = dx / 2.0
+        while x != x1:
+            points.append((x, y))
             err -= dy
-            x0 += sx
-        if e2 < dx:
-            err += dx
-            y0 += sy
+            if err < 0:
+               y += sy
+               err += dx
+            x += sx       
+    else:
+        err = dy / 2.0
+        while y != y1:
+            points.append((x, y))
+            err -= dx
+            if err < 0:
+                x += sx
+                err += dy
+            y += sy

+    points.append((x, y))
    return points
</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.

Respond below: