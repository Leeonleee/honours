{
  "repo": "duckdb/duckdb",
  "pull_number": 13230,
  "instance_id": "duckdb__duckdb-13230",
  "issue_numbers": [
    "13200",
    "13200"
  ],
  "base_commit": "f92559f42c118075baaa8daafc437954eb5c85ec",
  "patch": "diff --git a/src/include/duckdb/transaction/duck_transaction.hpp b/src/include/duckdb/transaction/duck_transaction.hpp\nindex 17acf5d04359..63dbc0226348 100644\n--- a/src/include/duckdb/transaction/duck_transaction.hpp\n+++ b/src/include/duckdb/transaction/duck_transaction.hpp\n@@ -12,6 +12,7 @@\n #include \"duckdb/common/reference_map.hpp\"\n \n namespace duckdb {\n+class RowGroupCollection;\n class RowVersionManager;\n class DuckTransactionManager;\n class StorageLockKey;\n@@ -76,6 +77,8 @@ class DuckTransaction : public Transaction {\n \t\treturn write_lock.get();\n \t}\n \n+\tvoid UpdateCollection(shared_ptr<RowGroupCollection> &collection);\n+\n private:\n \tDuckTransactionManager &transaction_manager;\n \t//! The undo buffer is used to store old versions of rows that are updated\n@@ -89,6 +92,8 @@ class DuckTransaction : public Transaction {\n \tmutex sequence_lock;\n \t//! Map of all sequences that were used during the transaction and the value they had in this transaction\n \treference_map_t<SequenceCatalogEntry, reference<SequenceValue>> sequence_usage;\n+\t//! Collections that are updated by this transaction\n+\treference_map_t<RowGroupCollection, shared_ptr<RowGroupCollection>> updated_collections;\n };\n \n } // namespace duckdb\ndiff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp\nindex 50cf8ee30bcb..093ff643496a 100644\n--- a/src/storage/data_table.cpp\n+++ b/src/storage/data_table.cpp\n@@ -1335,13 +1335,14 @@ void DataTable::Update(TableUpdateState &state, ClientContext &context, Vector &\n \n \t// otherwise global storage\n \tif (n_global_update > 0) {\n+\t\tauto &transaction = DuckTransaction::Get(context, db);\n \t\tupdates_slice.Slice(updates, sel_global_update, n_global_update);\n \t\tupdates_slice.Flatten();\n \t\trow_ids_slice.Slice(row_ids, sel_global_update, n_global_update);\n \t\trow_ids_slice.Flatten(n_global_update);\n \n-\t\trow_groups->Update(DuckTransaction::Get(context, db), FlatVector::GetData<row_t>(row_ids_slice), column_ids,\n-\t\t                   updates_slice);\n+\t\ttransaction.UpdateCollection(row_groups);\n+\t\trow_groups->Update(transaction, FlatVector::GetData<row_t>(row_ids_slice), column_ids, updates_slice);\n \t}\n }\n \ndiff --git a/src/transaction/duck_transaction.cpp b/src/transaction/duck_transaction.cpp\nindex 7c317d537f05..0acef6fd328b 100644\n--- a/src/transaction/duck_transaction.cpp\n+++ b/src/transaction/duck_transaction.cpp\n@@ -142,6 +142,16 @@ void DuckTransaction::PushSequenceUsage(SequenceCatalogEntry &sequence, const Se\n \t}\n }\n \n+void DuckTransaction::UpdateCollection(shared_ptr<RowGroupCollection> &collection) {\n+\tauto collection_ref = reference<RowGroupCollection>(*collection);\n+\tauto entry = updated_collections.find(collection_ref);\n+\tif (entry != updated_collections.end()) {\n+\t\t// already exists\n+\t\treturn;\n+\t}\n+\tupdated_collections.insert(make_pair(collection_ref, collection));\n+}\n+\n bool DuckTransaction::ChangesMade() {\n \treturn undo_buffer.ChangesMade() || storage->ChangesMade();\n }\n",
  "test_patch": "diff --git a/test/sql/parallelism/interquery/concurrent_update_drop.test_slow b/test/sql/parallelism/interquery/concurrent_update_drop.test_slow\nnew file mode 100644\nindex 000000000000..845558d1a967\n--- /dev/null\n+++ b/test/sql/parallelism/interquery/concurrent_update_drop.test_slow\n@@ -0,0 +1,21 @@\n+# name: test/sql/parallelism/interquery/concurrent_update_drop.test_slow\n+# description: Test concurrent updates and drops\n+# group: [interquery]\n+\n+statement ok\n+CREATE TABLE t1(i INTEGER)\n+\n+statement ok\n+INSERT INTO t1 VALUES (1), (2), (3)\n+\n+concurrentloop threadid 0 2\n+\n+onlyif threadid=0\n+statement ok\n+UPDATE t1 SET i = 4 WHERE i = 2\n+\n+onlyif threadid=1\n+statement ok\n+DROP TABLE t1\n+\n+endloop\n\\ No newline at end of file\n",
  "problem_statement": "Segfault for simultaneous UPDATE and DROP on same table\n### What happens?\r\n\r\nWhen doing these simultaneously, the `UPDATE` query segfaults in `duckdb::StorageLock::GetExclusiveLock()`.\r\n\r\nStack trace:\r\n```\r\n         21:   threads.emplace_back([&]() {\r\n         22:     duckdb::Connection con(db);\r\n      >  23:     auto result = con.Query(\"UPDATE t1 SET i = 4 WHERE i = 2\");\r\n         24:     if (result->HasError()) {\r\n         25:       std::cerr << result->GetError() << \"\\n\";\r\n         26:       return;\r\n#14   Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750ae046, in duckdb::Connection::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)\r\n#13   Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750ada3f, in duckdb::ClientContext::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool)\r\n#12   Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750ab213, in duckdb::ClientContext::ExecutePendingQueryInternal(duckdb::ClientContextLock&, duckdb::PendingQueryResult&)\r\n#11   Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750ab1a7, in duckdb::PendingQueryResult::ExecuteInternal(duckdb::ClientContextLock&)\r\n#10   Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750aa547, in duckdb::ClientContext::FetchResultInternal(duckdb::ClientContextLock&, duckdb::PendingQueryResult&)\r\n#9    Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750a9fe7, in duckdb::ClientContext::CleanupInternal(duckdb::ClientContextLock&, duckdb::BaseQueryResult*, bool)\r\n#8    Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750a9e1f, in duckdb::ClientContext::EndQueryInternal(duckdb::ClientContextLock&, bool, bool)\r\n#7    Object \"/opt/duckdb/libduckdb.so\", at 0x7c9675235a77, in duckdb::TransactionContext::Commit()\r\n#6    Object \"/opt/duckdb/libduckdb.so\", at 0x7c967523550c, in duckdb::MetaTransaction::Commit()\r\n#5    Object \"/opt/duckdb/libduckdb.so\", at 0x7c9675236f36, in duckdb::DuckTransactionManager::CommitTransaction(duckdb::ClientContext&, duckdb::Transaction&)\r\n#4    Object \"/opt/duckdb/libduckdb.so\", at 0x7c9675234ceb, in duckdb::DuckTransactionManager::RemoveTransaction(duckdb::DuckTransaction&, bool)\r\n#3    Object \"/opt/duckdb/libduckdb.so\", at 0x7c96752336f3, in duckdb::UndoBuffer::Cleanup()\r\n#2    Object \"/opt/duckdb/libduckdb.so\", at 0x7c96751cd0c4, in duckdb::UpdateSegment::CleanupUpdate(duckdb::UpdateInfo&)\r\n#1    Object \"/opt/duckdb/libduckdb.so\", at 0x7c967520a4e5, in duckdb::StorageLock::GetExclusiveLock()\r\n#0    Source \"./nptl/pthread_mutex_lock.c\", line 80, in ___pthread_mutex_lock [0x7c967309ffe4]\r\nSegmentation fault (Signal sent by the kernel [(nil)])\r\nSegmentation fault (core dumped)\r\n```\r\n\r\nDocumentation I can find says that snapshot isolation is used for data, and specifies what forms of concurrent DML can cause conflicts, but doesn't say anything about DDL.\r\n\r\nI understand if this is undefined and the segfault is the best that can be done, but the docs don't mention it so I figure maybe it's a bug and something more graceful can be done here.\r\n\r\n### To Reproduce\r\n\r\n```\r\n#include <deque>\r\n#include <iostream>\r\n#include <thread>\r\n\r\n#include \"duckdb/main/appender.hpp\"\r\n#include \"duckdb/main/connection.hpp\"\r\n#include \"duckdb/main/database.hpp\"\r\n\r\nint main() {\r\n  duckdb::DuckDB db(/*path=*/nullptr);\r\n  duckdb::Connection con(db);\r\n  con.Query(\"CREATE TABLE t1 (i INT)\");\r\n  duckdb::Appender appender(con, \"t1\");\r\n  appender.AppendRow(1);\r\n  appender.AppendRow(2);\r\n  appender.AppendRow(3);\r\n  appender.Close();\r\n\r\n  std::deque<std::thread> threads;\r\n\r\n  threads.emplace_back([&]() {\r\n    duckdb::Connection con(db);\r\n    auto result = con.Query(\"UPDATE t1 SET i = 4 WHERE i = 2\");\r\n    if (result->HasError()) {\r\n      std::cerr << result->GetError() << \"\\n\";\r\n      return;\r\n    }\r\n  });\r\n\r\n  threads.emplace_back([&]() {\r\n    duckdb::Connection con(db);\r\n    auto result = con.Query(\"DROP TABLE t1\");\r\n    if (result->HasError()) {\r\n      std::cerr << result->GetError() << \"\\n\";\r\n      return;\r\n    }\r\n  });\r\n\r\n  for (auto& thread : threads) {\r\n    thread.join();\r\n  }\r\n  return 0;\r\n}\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu 24.04, x86\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0\r\n\r\n### DuckDB Client:\r\n\r\nC++\r\n\r\n### Full Name:\r\n\r\nJames Hill\r\n\r\n### Affiliation:\r\n\r\nPromoted.ai\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a source build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\nSegfault for simultaneous UPDATE and DROP on same table\n### What happens?\r\n\r\nWhen doing these simultaneously, the `UPDATE` query segfaults in `duckdb::StorageLock::GetExclusiveLock()`.\r\n\r\nStack trace:\r\n```\r\n         21:   threads.emplace_back([&]() {\r\n         22:     duckdb::Connection con(db);\r\n      >  23:     auto result = con.Query(\"UPDATE t1 SET i = 4 WHERE i = 2\");\r\n         24:     if (result->HasError()) {\r\n         25:       std::cerr << result->GetError() << \"\\n\";\r\n         26:       return;\r\n#14   Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750ae046, in duckdb::Connection::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)\r\n#13   Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750ada3f, in duckdb::ClientContext::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool)\r\n#12   Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750ab213, in duckdb::ClientContext::ExecutePendingQueryInternal(duckdb::ClientContextLock&, duckdb::PendingQueryResult&)\r\n#11   Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750ab1a7, in duckdb::PendingQueryResult::ExecuteInternal(duckdb::ClientContextLock&)\r\n#10   Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750aa547, in duckdb::ClientContext::FetchResultInternal(duckdb::ClientContextLock&, duckdb::PendingQueryResult&)\r\n#9    Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750a9fe7, in duckdb::ClientContext::CleanupInternal(duckdb::ClientContextLock&, duckdb::BaseQueryResult*, bool)\r\n#8    Object \"/opt/duckdb/libduckdb.so\", at 0x7c96750a9e1f, in duckdb::ClientContext::EndQueryInternal(duckdb::ClientContextLock&, bool, bool)\r\n#7    Object \"/opt/duckdb/libduckdb.so\", at 0x7c9675235a77, in duckdb::TransactionContext::Commit()\r\n#6    Object \"/opt/duckdb/libduckdb.so\", at 0x7c967523550c, in duckdb::MetaTransaction::Commit()\r\n#5    Object \"/opt/duckdb/libduckdb.so\", at 0x7c9675236f36, in duckdb::DuckTransactionManager::CommitTransaction(duckdb::ClientContext&, duckdb::Transaction&)\r\n#4    Object \"/opt/duckdb/libduckdb.so\", at 0x7c9675234ceb, in duckdb::DuckTransactionManager::RemoveTransaction(duckdb::DuckTransaction&, bool)\r\n#3    Object \"/opt/duckdb/libduckdb.so\", at 0x7c96752336f3, in duckdb::UndoBuffer::Cleanup()\r\n#2    Object \"/opt/duckdb/libduckdb.so\", at 0x7c96751cd0c4, in duckdb::UpdateSegment::CleanupUpdate(duckdb::UpdateInfo&)\r\n#1    Object \"/opt/duckdb/libduckdb.so\", at 0x7c967520a4e5, in duckdb::StorageLock::GetExclusiveLock()\r\n#0    Source \"./nptl/pthread_mutex_lock.c\", line 80, in ___pthread_mutex_lock [0x7c967309ffe4]\r\nSegmentation fault (Signal sent by the kernel [(nil)])\r\nSegmentation fault (core dumped)\r\n```\r\n\r\nDocumentation I can find says that snapshot isolation is used for data, and specifies what forms of concurrent DML can cause conflicts, but doesn't say anything about DDL.\r\n\r\nI understand if this is undefined and the segfault is the best that can be done, but the docs don't mention it so I figure maybe it's a bug and something more graceful can be done here.\r\n\r\n### To Reproduce\r\n\r\n```\r\n#include <deque>\r\n#include <iostream>\r\n#include <thread>\r\n\r\n#include \"duckdb/main/appender.hpp\"\r\n#include \"duckdb/main/connection.hpp\"\r\n#include \"duckdb/main/database.hpp\"\r\n\r\nint main() {\r\n  duckdb::DuckDB db(/*path=*/nullptr);\r\n  duckdb::Connection con(db);\r\n  con.Query(\"CREATE TABLE t1 (i INT)\");\r\n  duckdb::Appender appender(con, \"t1\");\r\n  appender.AppendRow(1);\r\n  appender.AppendRow(2);\r\n  appender.AppendRow(3);\r\n  appender.Close();\r\n\r\n  std::deque<std::thread> threads;\r\n\r\n  threads.emplace_back([&]() {\r\n    duckdb::Connection con(db);\r\n    auto result = con.Query(\"UPDATE t1 SET i = 4 WHERE i = 2\");\r\n    if (result->HasError()) {\r\n      std::cerr << result->GetError() << \"\\n\";\r\n      return;\r\n    }\r\n  });\r\n\r\n  threads.emplace_back([&]() {\r\n    duckdb::Connection con(db);\r\n    auto result = con.Query(\"DROP TABLE t1\");\r\n    if (result->HasError()) {\r\n      std::cerr << result->GetError() << \"\\n\";\r\n      return;\r\n    }\r\n  });\r\n\r\n  for (auto& thread : threads) {\r\n    thread.join();\r\n  }\r\n  return 0;\r\n}\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu 24.04, x86\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0\r\n\r\n### DuckDB Client:\r\n\r\nC++\r\n\r\n### Full Name:\r\n\r\nJames Hill\r\n\r\n### Affiliation:\r\n\r\nPromoted.ai\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a source build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Thanks for reporting, can confirm this is an issue - looks like a use-after-free bug\nThanks for reporting, can confirm this is an issue - looks like a use-after-free bug",
  "created_at": "2024-07-31T13:59:11Z"
}