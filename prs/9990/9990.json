{
  "repo": "duckdb/duckdb",
  "pull_number": 9990,
  "instance_id": "duckdb__duckdb-9990",
  "issue_numbers": [
    "9380",
    "9738"
  ],
  "base_commit": "78cf9118ce1b5cc291984dae7ffa8da22acd8d36",
  "patch": "diff --git a/src/function/function_binder.cpp b/src/function/function_binder.cpp\nindex 8b57bf92f35d..4b723cd32fff 100644\n--- a/src/function/function_binder.cpp\n+++ b/src/function/function_binder.cpp\n@@ -279,10 +279,28 @@ unique_ptr<Expression> FunctionBinder::BindScalarFunction(ScalarFunctionCatalogE\n \t// found a matching function!\n \tauto bound_function = func.functions.GetFunctionByOffset(best_function);\n \n+\t// If any of the parameters are NULL, the function will just be replaced with a NULL constant\n+\t// But this NULL constant needs to have to correct type, because we use LogicalType::SQLNULL for binding macro's\n+\t// However, some functions may have an invalid return type, so we default to SQLNULL for those\n+\tLogicalType return_type_if_null;\n+\tswitch (bound_function.return_type.id()) {\n+\tcase LogicalTypeId::ANY:\n+\tcase LogicalTypeId::DECIMAL:\n+\tcase LogicalTypeId::STRUCT:\n+\tcase LogicalTypeId::LIST:\n+\tcase LogicalTypeId::MAP:\n+\tcase LogicalTypeId::UNION:\n+\tcase LogicalTypeId::ARRAY:\n+\t\treturn_type_if_null = LogicalType::SQLNULL;\n+\t\tbreak;\n+\tdefault:\n+\t\treturn_type_if_null = bound_function.return_type;\n+\t}\n+\n \tif (bound_function.null_handling == FunctionNullHandling::DEFAULT_NULL_HANDLING) {\n \t\tfor (auto &child : children) {\n \t\t\tif (child->return_type == LogicalTypeId::SQLNULL) {\n-\t\t\t\treturn make_uniq<BoundConstantExpression>(Value(LogicalType::SQLNULL));\n+\t\t\t\treturn make_uniq<BoundConstantExpression>(Value(return_type_if_null));\n \t\t\t}\n \t\t\tif (!child->IsFoldable()) {\n \t\t\t\tcontinue;\n@@ -292,7 +310,7 @@ unique_ptr<Expression> FunctionBinder::BindScalarFunction(ScalarFunctionCatalogE\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (result.IsNull()) {\n-\t\t\t\treturn make_uniq<BoundConstantExpression>(Value(LogicalType::SQLNULL));\n+\t\t\t\treturn make_uniq<BoundConstantExpression>(Value(return_type_if_null));\n \t\t\t}\n \t\t}\n \t}\ndiff --git a/src/include/duckdb/function/macro_function.hpp b/src/include/duckdb/function/macro_function.hpp\nindex 0a9bdb5a51c1..e6a0f1854659 100644\n--- a/src/include/duckdb/function/macro_function.hpp\n+++ b/src/include/duckdb/function/macro_function.hpp\n@@ -8,12 +8,12 @@\n \n #pragma once\n \n-#include \"duckdb/parser/query_node.hpp\"\n #include \"duckdb/function/function.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n+#include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/query_node.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n-#include \"duckdb/parser/expression/constant_expression.hpp\"\n \n namespace duckdb {\n \n@@ -28,7 +28,7 @@ class MacroFunction {\n \t//! The positional parameters\n \tvector<unique_ptr<ParsedExpression>> parameters;\n \t//! The default parameters and their associated values\n-\tunordered_map<string, unique_ptr<ParsedExpression>> default_parameters;\n+\tcase_insensitive_map_t<unique_ptr<ParsedExpression>> default_parameters;\n \n public:\n \tvirtual ~MacroFunction() {\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 1c567181b8da..16b9db820a4c 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -90,7 +90,7 @@ class ExpressionBinder {\n \tunique_ptr<ParsedExpression> QualifyColumnName(ColumnRefExpression &colref, string &error_message);\n \n \t// Bind table names to ColumnRefExpressions\n-\tvoid QualifyColumnNames(unique_ptr<ParsedExpression> &expr);\n+\tvoid QualifyColumnNames(unique_ptr<ParsedExpression> &expr, bool within_function_expression = false);\n \tstatic void QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr);\n \n \tstatic bool PushCollation(ClientContext &context, unique_ptr<Expression> &source, const LogicalType &sql_type,\ndiff --git a/src/include/duckdb/storage/serialization/macro_function.json b/src/include/duckdb/storage/serialization/macro_function.json\nindex df0caeca0182..948cfb7e1083 100644\n--- a/src/include/duckdb/storage/serialization/macro_function.json\n+++ b/src/include/duckdb/storage/serialization/macro_function.json\n@@ -19,7 +19,7 @@\n       {\n         \"id\": 102,\n         \"name\": \"default_parameters\",\n-        \"type\": \"unordered_map<string, ParsedExpression*>\"\n+        \"type\": \"case_insensitive_map_t<ParsedExpression*>\"\n       }\n     ]\n   },\ndiff --git a/src/planner/binder/expression/bind_columnref_expression.cpp b/src/planner/binder/expression/bind_columnref_expression.cpp\nindex 1f7113be4a1f..cf86a8119392 100644\n--- a/src/planner/binder/expression/bind_columnref_expression.cpp\n+++ b/src/planner/binder/expression/bind_columnref_expression.cpp\n@@ -122,7 +122,8 @@ unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(const string &c\n \treturn binder.bind_context.CreateColumnReference(table_name, column_name);\n }\n \n-void ExpressionBinder::QualifyColumnNames(unique_ptr<ParsedExpression> &expr) {\n+void ExpressionBinder::QualifyColumnNames(unique_ptr<ParsedExpression> &expr, bool within_function_expression) {\n+\tbool next_within_function_expression = false;\n \tswitch (expr->type) {\n \tcase ExpressionType::COLUMN_REF: {\n \t\tauto &colref = expr->Cast<ColumnRefExpression>();\n@@ -130,7 +131,12 @@ void ExpressionBinder::QualifyColumnNames(unique_ptr<ParsedExpression> &expr) {\n \t\tauto new_expr = QualifyColumnName(colref, error_message);\n \t\tif (new_expr) {\n \t\t\tif (!expr->alias.empty()) {\n+\t\t\t\t// Pre-existing aliases are added to the qualified colref\n \t\t\t\tnew_expr->alias = expr->alias;\n+\t\t\t} else if (within_function_expression) {\n+\t\t\t\t// Qualifying the colref may add an alias, but this needs to be removed within function expressions,\n+\t\t\t\t// because the alias here means a named parameter instead of a positional parameter\n+\t\t\t\tnew_expr->alias = \"\";\n \t\t\t}\n \t\t\tnew_expr->query_location = colref.query_location;\n \t\t\texpr = std::move(new_expr);\n@@ -148,11 +154,15 @@ void ExpressionBinder::QualifyColumnNames(unique_ptr<ParsedExpression> &expr) {\n \t\t}\n \t\tbreak;\n \t}\n+\tcase ExpressionType::FUNCTION:\n+\t\tnext_within_function_expression = true;\n+\t\tbreak;\n \tdefault:\n \t\tbreak;\n \t}\n-\tParsedExpressionIterator::EnumerateChildren(\n-\t    *expr, [&](unique_ptr<ParsedExpression> &child) { QualifyColumnNames(child); });\n+\tParsedExpressionIterator::EnumerateChildren(*expr, [&](unique_ptr<ParsedExpression> &child) {\n+\t\tQualifyColumnNames(child, next_within_function_expression);\n+\t});\n }\n \n void ExpressionBinder::QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr) {\ndiff --git a/src/storage/serialization/serialize_macro_function.cpp b/src/storage/serialization/serialize_macro_function.cpp\nindex 79484d8084ed..8be5988db71a 100644\n--- a/src/storage/serialization/serialize_macro_function.cpp\n+++ b/src/storage/serialization/serialize_macro_function.cpp\n@@ -14,13 +14,13 @@ namespace duckdb {\n void MacroFunction::Serialize(Serializer &serializer) const {\n \tserializer.WriteProperty<MacroType>(100, \"type\", type);\n \tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(101, \"parameters\", parameters);\n-\tserializer.WritePropertyWithDefault<unordered_map<string, unique_ptr<ParsedExpression>>>(102, \"default_parameters\", default_parameters);\n+\tserializer.WritePropertyWithDefault<case_insensitive_map_t<unique_ptr<ParsedExpression>>>(102, \"default_parameters\", default_parameters);\n }\n \n unique_ptr<MacroFunction> MacroFunction::Deserialize(Deserializer &deserializer) {\n \tauto type = deserializer.ReadProperty<MacroType>(100, \"type\");\n \tauto parameters = deserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(101, \"parameters\");\n-\tauto default_parameters = deserializer.ReadPropertyWithDefault<unordered_map<string, unique_ptr<ParsedExpression>>>(102, \"default_parameters\");\n+\tauto default_parameters = deserializer.ReadPropertyWithDefault<case_insensitive_map_t<unique_ptr<ParsedExpression>>>(102, \"default_parameters\");\n \tunique_ptr<MacroFunction> result;\n \tswitch (type) {\n \tcase MacroType::SCALAR_MACRO:\n",
  "test_patch": "diff --git a/test/issues/general/test_9380.test b/test/issues/general/test_9380.test\nnew file mode 100644\nindex 000000000000..0bd64973b9a9\n--- /dev/null\n+++ b/test/issues/general/test_9380.test\n@@ -0,0 +1,9 @@\n+# name: test/issues/general/test_9380.test\n+# description: Issue 9380: \"Could not choose a best candidate function for the function call\" after upgrading to 0.9\n+# group: [general]\n+\n+statement ok\n+CREATE MACRO time_to_datetime(date, string) AS\n+   date::TIMESTAMP +\n+   TRY_CAST(regexp_replace(string, '^2400$', '0000').substr(1, 2).concat(' hours') AS INTERVAL) +\n+   TRY_CAST(regexp_replace(string, '^2400$', '0000').substr(3, 2).concat(' minutes') AS INTERVAL);\ndiff --git a/test/issues/general/test_9738.test b/test/issues/general/test_9738.test\nnew file mode 100644\nindex 000000000000..f10ca4b127fd\n--- /dev/null\n+++ b/test/issues/general/test_9738.test\n@@ -0,0 +1,32 @@\n+# name: test/issues/general/test_9738.test\n+# description: Issue 9738: Column identifier is case sensitive when used as a macro parameter.\n+# group: [general]\n+\n+statement ok\n+create table MY_TABLE(NAME String);\n+\n+statement ok\n+insert into my_table(name) values('Someone');\n+\n+statement ok\n+create or replace macro do_nothing(input) as input;\n+\n+query I\n+select name from my_table;\n+----\n+Someone\n+\n+query I\n+select NAME from my_table;\n+----\n+Someone\n+\n+query I\n+select do_nothing(NAME) from my_table;\n+----\n+Someone\n+\n+query I\n+select do_nothing(name) from my_table;\n+----\n+Someone\n",
  "problem_statement": "\"Could not choose a best candidate function for the function call\" after upgrading to 0.9\n### What happens?\r\n\r\nAfter upgrading DuckDB from 0.8 to 0.9, I noticed that the definition of the following macro fails.\r\n\r\nhttps://github.com/eitsupi/querying-with-prql/blob/3c9d53d32c487b869db17999aad88b9ed8169ebe/docs/method_chaining.qmd#L163-L169\r\n\r\n```\r\nv0.9.2-dev48 7127284469\r\nEnter \".help\" for usage hints.\r\nConnected to a transient in-memory database.\r\nUse \".open FILENAME\" to reopen on a persistent database.\r\nD CREATE MACRO time_to_datetime(date, string) AS\r\n>   date::TIMESTAMP +\r\n>   TRY_CAST(regexp_replace(string, '^2400$', '0000').substr(1, 2).concat(' hours') AS INTERVAL) +\r\n>   TRY_CAST(regexp_replace(string, '^2400$', '0000').substr(3, 2).concat(' minutes') AS INTERVAL);\r\nError: Binder Error: Could not choose a best candidate function for the function call \"+(NULL, INTERVAL)\". In order to select one, please add explicit type casts.\r\n        Candidate functions:\r\n        +(DATE, INTERVAL) -> DATE\r\n        +(TIME, INTERVAL) -> TIME\r\n        +(TIMESTAMP WITH TIME ZONE, INTERVAL) -> TIMESTAMP WITH TIME ZONE\r\n        +(INTERVAL, INTERVAL) -> INTERVAL\r\n```\r\n\r\nIt was working fine in 0.8, so I think maybe something is going wrong with 0.9.\r\n\r\n```\r\nv0.8.1 6536a77232\r\nEnter \".help\" for usage hints.\r\nConnected to a transient in-memory database.\r\nUse \".open FILENAME\" to reopen on a persistent database.\r\nD CREATE MACRO time_to_datetime(date, string) AS\r\n>   date::TIMESTAMP +\r\n>   TRY_CAST(regexp_replace(string, '^2400$', '0000').substr(1, 2).concat(' hours') AS INTERVAL) +\r\n>   TRY_CAST(regexp_replace(string, '^2400$', '0000').substr(3, 2).concat(' minutes') AS INTERVAL);\r\nD\r\n```\r\n\r\n### To Reproduce\r\n\r\nExecute this SQL\r\n\r\n```sql\r\nCREATE MACRO time_to_datetime(date, string) AS\r\n  date::TIMESTAMP +\r\n  TRY_CAST(regexp_replace(string, '^2400$', '0000').substr(1, 2).concat(' hours') AS INTERVAL) +\r\n  TRY_CAST(regexp_replace(string, '^2400$', '0000').substr(3, 2).concat(' minutes') AS INTERVAL);\r\n```\r\n\r\n### OS:\r\n\r\nWindows, Linux\r\n\r\n### DuckDB Version:\r\n\r\n0.9\r\n\r\n### DuckDB Client:\r\n\r\nCLI, R\r\n\r\n### Full Name:\r\n\r\nSHIMA Tatsuya\r\n\r\n### Affiliation:\r\n\r\nPersonal use\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\nColumn identifier is case sensitive when used as a macro parameter.\n### What happens?\n\nYou have to match the exact casing of the column identifier when using them as macro parameter.\r\n\r\nThe following error is thrown when the casing does not match:\r\n`Error: Binder Error: Macro do_nothing does not have default parameter NAME!`\r\n\r\nWhen the casing does not match it is seen as the parameter name rather than a column.\r\n\r\nIs this intended behaviour?\n\n### To Reproduce\n\nUsing CLI:\r\n\r\n```\r\ncreate table MY_TABLE(NAME String);\r\ninsert into my_table(name) values('Someone');\r\ncreate or replace macro do_nothing(input) as input;\r\n```\r\n\r\n`select name from my_table; `\r\n-- Works\r\n`select NAME from my_table; `\r\n-- Works\r\n`select do_nothing(NAME) from my_table;`\r\n-- Works\r\n`select do_nothing(name) from my_table;`\r\n-- Error: Binder Error: Macro do_nothing does not have default parameter NAME!\r\n\r\nThe casing did not matter when creating the table and inserting data. But the macro does expect the exact column name.\n\n### OS:\n\nWindows 10\n\n### DuckDB Version:\n\n0.9.2\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nPieter Bellon\n\n### Affiliation:\n\nDXC Technology\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "Hmm I agree this behavior is a little strange, and probably a consequence of another change\r\n\r\nWhen binding the expressions for the table macro `string` is of type SQLNULL, because it could be anything.\r\nThat in turns probably causes `regexp_replace` to be SQLNULL.\r\n\r\nTurning the reference of `string` into `string::VARCHAR` makes the statement succeed for me, is that a valid workaround for your issue?\n> Turning the reference of `string` into `string::VARCHAR` makes the statement succeed for me, is that a valid workaround for your issue?\r\n\r\nThank you for finding this. For me this is a nice workaround at the moment.\nThanks, that indeed sounds like unexpected behavior \ud83d\udc4d ",
  "created_at": "2023-12-14T10:27:05Z"
}