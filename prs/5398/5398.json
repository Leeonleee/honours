{
  "repo": "duckdb/duckdb",
  "pull_number": 5398,
  "instance_id": "duckdb__duckdb-5398",
  "issue_numbers": [
    "5371",
    "5371"
  ],
  "base_commit": "7fbaefc8a134adb5d0eed2ad9308d7cf9b40635f",
  "patch": "diff --git a/src/include/duckdb/main/db_instance_cache.hpp b/src/include/duckdb/main/db_instance_cache.hpp\nindex e5ec1fa8be63..46cc3d980d17 100644\n--- a/src/include/duckdb/main/db_instance_cache.hpp\n+++ b/src/include/duckdb/main/db_instance_cache.hpp\n@@ -23,11 +23,18 @@ class DBInstanceCache {\n \t//! Creates and caches a new DB Instance (Fails if a cached instance already exists)\n \tshared_ptr<DuckDB> CreateInstance(const string &database, DBConfig &config_dict, bool cache_instance = true);\n \n+\t//! Creates and caches a new DB Instance (Fails if a cached instance already exists)\n+\tshared_ptr<DuckDB> GetOrCreateInstance(const string &database, DBConfig &config_dict, bool cache_instance);\n+\n private:\n \t//! A map with the cached instances <absolute_path/instance>\n \tunordered_map<string, weak_ptr<DuckDB>> db_instances;\n \n \t//! Lock to alter cache\n \tmutex cache_lock;\n+\n+private:\n+\tshared_ptr<DuckDB> GetInstanceInternal(const string &database, const DBConfig &config_dict);\n+\tshared_ptr<DuckDB> CreateInstanceInternal(const string &database, DBConfig &config_dict, bool cache_instance);\n };\n } // namespace duckdb\ndiff --git a/src/main/db_instance_cache.cpp b/src/main/db_instance_cache.cpp\nindex 4d2a0f8510c5..1479203b6b05 100644\n--- a/src/main/db_instance_cache.cpp\n+++ b/src/main/db_instance_cache.cpp\n@@ -16,8 +16,7 @@ string GetDBAbsolutePath(const string &database) {\n \treturn FileSystem::JoinPath(FileSystem::GetWorkingDirectory(), database);\n }\n \n-shared_ptr<DuckDB> DBInstanceCache::GetInstance(const string &database, const DBConfig &config) {\n-\tlock_guard<mutex> l(cache_lock);\n+shared_ptr<DuckDB> DBInstanceCache::GetInstanceInternal(const string &database, const DBConfig &config) {\n \tshared_ptr<DuckDB> db_instance;\n \tauto abs_database_path = GetDBAbsolutePath(database);\n \tif (db_instances.find(abs_database_path) != db_instances.end()) {\n@@ -36,8 +35,13 @@ shared_ptr<DuckDB> DBInstanceCache::GetInstance(const string &database, const DB\n \treturn db_instance;\n }\n \n-shared_ptr<DuckDB> DBInstanceCache::CreateInstance(const string &database, DBConfig &config, bool cache_instance) {\n+shared_ptr<DuckDB> DBInstanceCache::GetInstance(const string &database, const DBConfig &config) {\n \tlock_guard<mutex> l(cache_lock);\n+\treturn GetInstanceInternal(database, config);\n+}\n+\n+shared_ptr<DuckDB> DBInstanceCache::CreateInstanceInternal(const string &database, DBConfig &config,\n+                                                           bool cache_instance) {\n \tauto abs_database_path = GetDBAbsolutePath(database);\n \tif (db_instances.find(abs_database_path) != db_instances.end()) {\n \t\tthrow duckdb::Exception(ExceptionType::CONNECTION,\n@@ -55,4 +59,21 @@ shared_ptr<DuckDB> DBInstanceCache::CreateInstance(const string &database, DBCon\n \treturn db_instance;\n }\n \n+shared_ptr<DuckDB> DBInstanceCache::CreateInstance(const string &database, DBConfig &config, bool cache_instance) {\n+\tlock_guard<mutex> l(cache_lock);\n+\treturn CreateInstanceInternal(database, config, cache_instance);\n+}\n+\n+shared_ptr<DuckDB> DBInstanceCache::GetOrCreateInstance(const string &database, DBConfig &config_dict,\n+                                                        bool cache_instance) {\n+\tlock_guard<mutex> l(cache_lock);\n+\tif (cache_instance) {\n+\t\tauto instance = GetInstanceInternal(database, config_dict);\n+\t\tif (instance) {\n+\t\t\treturn instance;\n+\t\t}\n+\t}\n+\treturn CreateInstanceInternal(database, config_dict, cache_instance);\n+}\n+\n } // namespace duckdb\ndiff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp\nindex 9fee95e45558..91d6253fe937 100644\n--- a/tools/jdbc/src/jni/duckdb_java.cpp\n+++ b/tools/jdbc/src/jni/duckdb_java.cpp\n@@ -284,7 +284,7 @@ JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1startup(JNI\n \t\t\t}\n \t\t}\n \t\tbool cache_instance = database != \":memory:\" && !database.empty();\n-\t\tauto shared_db = instance_cache.CreateInstance(database, config, cache_instance);\n+\t\tauto shared_db = instance_cache.GetOrCreateInstance(database, config, cache_instance);\n \t\tauto db = shared_db.get();\n \t\tstd::lock_guard<std::mutex> lock(db_map_lock);\n \t\tdb_map[db] = move(shared_db);\ndiff --git a/tools/odbc/driver.cpp b/tools/odbc/driver.cpp\nindex aaf698c2a68c..a30bceaa551c 100644\n--- a/tools/odbc/driver.cpp\n+++ b/tools/odbc/driver.cpp\n@@ -211,7 +211,7 @@ static SQLRETURN SetConnection(SQLHDBC connection_handle, SQLCHAR *conn_str) {\n \t\t\tconfig.options.access_mode = duckdb::AccessMode::READ_ONLY;\n \t\t}\n \t\tbool cache_instance = db_name != \":memory:\" && !db_name.empty();\n-\t\tdbc->env->db = instance_cache.CreateInstance(db_name, config, cache_instance);\n+\t\tdbc->env->db = instance_cache.GetOrCreateInstance(db_name, config, cache_instance);\n \t}\n \n \tif (!dbc->conn) {\n",
  "test_patch": "diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex 9e01b205c22c..a10fadb56c1f 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -2446,6 +2446,19 @@ public static void test_get_functions() throws Exception {\n \t\t}\n \t}\n \n+\tpublic static void test_instance_cache() throws Exception {\n+\t\tPath database_file = Files.createTempFile(\"duckdb-instance-cache-test-\", \".duckdb\");\n+\t\tdatabase_file.toFile().delete();\n+\n+\t\tString jdbc_url = \"jdbc:duckdb:\" + database_file.toString();\n+\n+\t\tConnection conn = DriverManager.getConnection(jdbc_url);\n+\t\tConnection conn2 = DriverManager.getConnection(jdbc_url);\n+\n+\t\tconn.close();\n+\t\tconn2.close();\n+\t}\n+\n \tpublic static void main(String[] args) throws Exception {\n \t\t// Woo I can do reflection too, take this, JUnit!\n \t\tMethod[] methods = TestDuckDBJDBC.class.getMethods();\n",
  "problem_statement": "Instance caching prevents multiple connections, closing and re-opening with JDBC\n### What happens?\n\nIt looks like the instance caching is failing to allow either multiple connections, or closing the connection and subsequently opening the database again.\n\n### To Reproduce\n\nThis throws an error:\r\n```\r\nimport java.sql.Connection;\r\nimport java.sql.DriverManager;\r\n\r\nclass duckdb {\r\n    public static void main(String[] args) {\r\n        try {\r\n            Connection conn = DriverManager.getConnection(\"jdbc:duckdb:test-temp.db\");\r\n            Connection conn2 = DriverManager.getConnection(\"jdbc:duckdb:test-temp.db\");\r\n\r\n            conn.close();\r\n            conn2.close();\r\n        } catch (Exception e) {\r\n            System.out.println(e);\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe error thrown:\r\n\r\n```\r\njava.sql.SQLException: Connection Error: Instance with path: /Users/pellsworth/test-duckdb/test-temp.db already exists.\r\n\tat org.duckdb.DuckDBNative.duckdb_jdbc_startup(Native Method)\r\n\tat org.duckdb.DuckDBDatabase.<init>(DuckDBDatabase.java:28)\r\n\tat org.duckdb.DuckDBDriver.connect(DuckDBDriver.java:36)\r\n\tat java.sql/java.sql.DriverManager.getConnection(DriverManager.java:677)\r\n\tat java.sql/java.sql.DriverManager.getConnection(DriverManager.java:251)\r\n\tat duckdb.main(duckdb.java:8)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566)\r\n\tat jdk.compiler/com.sun.tools.javac.launcher.Main.execute(Main.java:404)\r\n\tat jdk.compiler/com.sun.tools.javac.launcher.Main.run(Main.java:179)\r\n\tat jdk.compiler/com.sun.tools.javac.launcher.Main.main(Main.java:119)\r\n```\r\n\r\n(it also will throw the same error if you try to close the first connection before opening the second).\n\n### OS:\n\nOSX, x64\n\n### DuckDB Version:\n\n0.6.0\n\n### DuckDB Client:\n\nJava\n\n### Full Name:\n\nPaul Ellsworth\n\n### Affiliation:\n\nTenable\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nInstance caching prevents multiple connections, closing and re-opening with JDBC\n### What happens?\n\nIt looks like the instance caching is failing to allow either multiple connections, or closing the connection and subsequently opening the database again.\n\n### To Reproduce\n\nThis throws an error:\r\n```\r\nimport java.sql.Connection;\r\nimport java.sql.DriverManager;\r\n\r\nclass duckdb {\r\n    public static void main(String[] args) {\r\n        try {\r\n            Connection conn = DriverManager.getConnection(\"jdbc:duckdb:test-temp.db\");\r\n            Connection conn2 = DriverManager.getConnection(\"jdbc:duckdb:test-temp.db\");\r\n\r\n            conn.close();\r\n            conn2.close();\r\n        } catch (Exception e) {\r\n            System.out.println(e);\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe error thrown:\r\n\r\n```\r\njava.sql.SQLException: Connection Error: Instance with path: /Users/pellsworth/test-duckdb/test-temp.db already exists.\r\n\tat org.duckdb.DuckDBNative.duckdb_jdbc_startup(Native Method)\r\n\tat org.duckdb.DuckDBDatabase.<init>(DuckDBDatabase.java:28)\r\n\tat org.duckdb.DuckDBDriver.connect(DuckDBDriver.java:36)\r\n\tat java.sql/java.sql.DriverManager.getConnection(DriverManager.java:677)\r\n\tat java.sql/java.sql.DriverManager.getConnection(DriverManager.java:251)\r\n\tat duckdb.main(duckdb.java:8)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566)\r\n\tat jdk.compiler/com.sun.tools.javac.launcher.Main.execute(Main.java:404)\r\n\tat jdk.compiler/com.sun.tools.javac.launcher.Main.run(Main.java:179)\r\n\tat jdk.compiler/com.sun.tools.javac.launcher.Main.main(Main.java:119)\r\n```\r\n\r\n(it also will throw the same error if you try to close the first connection before opening the second).\n\n### OS:\n\nOSX, x64\n\n### DuckDB Version:\n\n0.6.0\n\n### DuckDB Client:\n\nJava\n\n### Full Name:\n\nPaul Ellsworth\n\n### Affiliation:\n\nTenable\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "(I might also just be totally missing how it's supposed to work :) )\nThanks for raising this! There were a number of changes around automatically closing JDBC connections and caching them in the 0.6.0 release, so it's possible something broke\nLooks like this is a bug introduced in https://github.com/duckdb/duckdb/pull/5004, maybe @Mytherin can take a look?\n(I might also just be totally missing how it's supposed to work :) )\nThanks for raising this! There were a number of changes around automatically closing JDBC connections and caching them in the 0.6.0 release, so it's possible something broke\nLooks like this is a bug introduced in https://github.com/duckdb/duckdb/pull/5004, maybe @Mytherin can take a look?",
  "created_at": "2022-11-17T17:07:43Z"
}