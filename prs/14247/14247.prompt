You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
No function matches 'bitstring(BIT, INTEGER_LITERAL)'
### What happens?

The [bitstring function](https://duckdb.org/docs/sql/functions/bitstring.html#bitstringbitstring-length) doesn't work. The given example results in this error:

```
Binder Error: No function matches the given name and argument types 'bitstring(BIT, INTEGER_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	bitstring(VARCHAR, INTEGER) -> BIT

LINE 1: SELECT bitstring('1010'::BITSTRING, 7);
```

### To Reproduce

```sql
SELECT bitstring('1010'::BITSTRING, 7);
```

### OS:

Linux

### DuckDB Version:

1.0.0

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

Liam Diprose

### Affiliation:

Liam Diprose

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/common/types/bit.cpp]
1: #include "duckdb/common/assert.hpp"
2: #include "duckdb/common/numeric_utils.hpp"
3: #include "duckdb/common/operator/cast_operators.hpp"
4: #include "duckdb/common/typedefs.hpp"
5: #include "duckdb/common/types/bit.hpp"
6: #include "duckdb/common/types/string_type.hpp"
7: 
8: namespace duckdb {
9: 
10: // **** helper functions ****
11: static char ComputePadding(idx_t len) {
12: 	return UnsafeNumericCast<char>((8 - (len % 8)) % 8);
13: }
14: 
15: idx_t Bit::ComputeBitstringLen(idx_t len) {
16: 	idx_t result = len / 8;
17: 	if (len % 8 != 0) {
18: 		result++;
19: 	}
20: 	// additional first byte to store info on zero padding
21: 	result++;
22: 	return result;
23: }
24: 
25: static inline idx_t GetBitPadding(const string_t &bit_string) {
26: 	auto data = const_data_ptr_cast(bit_string.GetData());
27: 	D_ASSERT(idx_t(data[0]) <= 8);
28: 	return data[0];
29: }
30: 
31: static inline idx_t GetBitSize(const string_t &str) {
32: 	string error_message;
33: 	idx_t str_len;
34: 	if (!Bit::TryGetBitStringSize(str, str_len, &error_message)) {
35: 		throw ConversionException(error_message);
36: 	}
37: 	return str_len;
38: }
39: 
40: uint8_t Bit::GetFirstByte(const string_t &str) {
41: 	D_ASSERT(str.GetSize() > 1);
42: 
43: 	auto data = const_data_ptr_cast(str.GetData());
44: 	return data[1] & ((1 << (8 - data[0])) - 1);
45: }
46: 
47: void Bit::Finalize(string_t &str) {
48: 	// bit strings require all padding bits to be set to 1
49: 	// this method sets all padding bits to 1
50: 	auto padding = GetBitPadding(str);
51: 	for (idx_t i = 0; i < idx_t(padding); i++) {
52: 		Bit::SetBitInternal(str, i, 1);
53: 	}
54: 	str.Finalize();
55: 	Bit::Verify(str);
56: }
57: 
58: void Bit::SetEmptyBitString(string_t &target, string_t &input) {
59: 	char *res_buf = target.GetDataWriteable();
60: 	const char *buf = input.GetData();
61: 	memset(res_buf, 0, input.GetSize());
62: 	res_buf[0] = buf[0];
63: 	Bit::Finalize(target);
64: }
65: 
66: void Bit::SetEmptyBitString(string_t &target, idx_t len) {
67: 	char *res_buf = target.GetDataWriteable();
68: 	memset(res_buf, 0, target.GetSize());
69: 	res_buf[0] = ComputePadding(len);
70: 	Bit::Finalize(target);
71: }
72: 
73: // **** casting functions ****
74: void Bit::ToString(string_t bits, char *output) {
75: 	auto data = const_data_ptr_cast(bits.GetData());
76: 	auto len = bits.GetSize();
77: 
78: 	idx_t padding = GetBitPadding(bits);
79: 	idx_t output_idx = 0;
80: 	for (idx_t bit_idx = padding; bit_idx < 8; bit_idx++) {
81: 		output[output_idx++] = data[1] & (1 << (7 - bit_idx)) ? '1' : '0';
82: 	}
83: 	for (idx_t byte_idx = 2; byte_idx < len; byte_idx++) {
84: 		for (idx_t bit_idx = 0; bit_idx < 8; bit_idx++) {
85: 			output[output_idx++] = data[byte_idx] & (1 << (7 - bit_idx)) ? '1' : '0';
86: 		}
87: 	}
88: }
89: 
90: string Bit::ToString(string_t str) {
91: 	auto len = BitLength(str);
92: 	auto buffer = make_unsafe_uniq_array_uninitialized<char>(len);
93: 	ToString(str, buffer.get());
94: 	return string(buffer.get(), len);
95: }
96: 
97: bool Bit::TryGetBitStringSize(string_t str, idx_t &str_len, string *error_message) {
98: 	auto data = const_data_ptr_cast(str.GetData());
99: 	auto len = str.GetSize();
100: 	str_len = 0;
101: 	for (idx_t i = 0; i < len; i++) {
102: 		if (data[i] == '0' || data[i] == '1') {
103: 			str_len++;
104: 		} else {
105: 			string error = StringUtil::Format("Invalid character encountered in string -> bit conversion: '%s'",
106: 			                                  string(const_char_ptr_cast(data) + i, 1));
107: 			HandleCastError::AssignError(error, error_message);
108: 			return false;
109: 		}
110: 	}
111: 	if (str_len == 0) {
112: 		string error = "Cannot cast empty string to BIT";
113: 		HandleCastError::AssignError(error, error_message);
114: 		return false;
115: 	}
116: 	str_len = ComputeBitstringLen(str_len);
117: 	return true;
118: }
119: 
120: void Bit::ToBit(string_t str, string_t &output_str) {
121: 	auto data = const_data_ptr_cast(str.GetData());
122: 	auto len = str.GetSize();
123: 	auto output = output_str.GetDataWriteable();
124: 
125: 	char byte = 0;
126: 	idx_t padded_byte = len % 8;
127: 	for (idx_t i = 0; i < padded_byte; i++) {
128: 		byte <<= 1;
129: 		if (data[i] == '1') {
130: 			byte |= 1;
131: 		}
132: 	}
133: 	if (padded_byte != 0) {
134: 		*(output++) = UnsafeNumericCast<char>((8 - padded_byte)); // the first byte contains the number of padded zeroes
135: 	}
136: 	*(output++) = byte;
137: 
138: 	for (idx_t byte_idx = padded_byte; byte_idx < len; byte_idx += 8) {
139: 		byte = 0;
140: 		for (idx_t bit_idx = 0; bit_idx < 8; bit_idx++) {
141: 			byte <<= 1;
142: 			if (data[byte_idx + bit_idx] == '1') {
143: 				byte |= 1;
144: 			}
145: 		}
146: 		*(output++) = byte;
147: 	}
148: 	Bit::Finalize(output_str);
149: }
150: 
151: string Bit::ToBit(string_t str) {
152: 	auto bit_len = GetBitSize(str);
153: 	auto buffer = make_unsafe_uniq_array_uninitialized<char>(bit_len);
154: 	string_t output_str(buffer.get(), UnsafeNumericCast<uint32_t>(bit_len));
155: 	Bit::ToBit(str, output_str);
156: 	return output_str.GetString();
157: }
158: 
159: void Bit::BlobToBit(string_t blob, string_t &output_str) {
160: 	auto data = const_data_ptr_cast(blob.GetData());
161: 	auto output = output_str.GetDataWriteable();
162: 	idx_t size = blob.GetSize();
163: 
164: 	*output = 0; // No padding
165: 	memcpy(output + 1, data, size);
166: }
167: 
168: string Bit::BlobToBit(string_t blob) {
169: 	auto buffer = make_unsafe_uniq_array_uninitialized<char>(blob.GetSize() + 1);
170: 	string_t output_str(buffer.get(), UnsafeNumericCast<uint32_t>(blob.GetSize() + 1));
171: 	Bit::BlobToBit(blob, output_str);
172: 	return output_str.GetString();
173: }
174: 
175: void Bit::BitToBlob(string_t bit, string_t &output_blob) {
176: 	D_ASSERT(bit.GetSize() == output_blob.GetSize() + 1);
177: 
178: 	auto data = const_data_ptr_cast(bit.GetData());
179: 	auto output = output_blob.GetDataWriteable();
180: 	idx_t size = output_blob.GetSize();
181: 
182: 	output[0] = UnsafeNumericCast<char>(GetFirstByte(bit));
183: 	if (size >= 2) {
184: 		++output;
185: 		// First byte in bitstring contains amount of padded bits,
186: 		// second byte in bitstring is the padded byte,
187: 		// therefore the rest of the data starts at data + 2 (third byte)
188: 		memcpy(output, data + 2, size - 1);
189: 	}
190: }
191: 
192: string Bit::BitToBlob(string_t bit) {
193: 	D_ASSERT(bit.GetSize() > 1);
194: 
195: 	auto buffer = make_unsafe_uniq_array_uninitialized<char>(bit.GetSize() - 1);
196: 	string_t output_str(buffer.get(), UnsafeNumericCast<uint32_t>(bit.GetSize() - 1));
197: 	Bit::BitToBlob(bit, output_str);
198: 	return output_str.GetString();
199: }
200: 
201: // **** scalar functions ****
202: void Bit::BitString(const string_t &input, const idx_t &bit_length, string_t &result) {
203: 	char *res_buf = result.GetDataWriteable();
204: 	const char *buf = input.GetData();
205: 
206: 	auto padding = ComputePadding(bit_length);
207: 	res_buf[0] = padding;
208: 	for (idx_t i = 0; i < bit_length; i++) {
209: 		if (i < bit_length - input.GetSize()) {
210: 			Bit::SetBit(result, i, 0);
211: 		} else {
212: 			idx_t bit = buf[i - (bit_length - input.GetSize())] == '1' ? 1 : 0;
213: 			Bit::SetBit(result, i, bit);
214: 		}
215: 	}
216: 	Bit::Finalize(result);
217: }
218: 
219: idx_t Bit::BitLength(string_t bits) {
220: 	return ((bits.GetSize() - 1) * 8) - GetBitPadding(bits);
221: }
222: 
223: idx_t Bit::OctetLength(string_t bits) {
224: 	return bits.GetSize() - 1;
225: }
226: 
227: idx_t Bit::BitCount(string_t bits) {
228: 	idx_t count = 0;
229: 	const char *buf = bits.GetData();
230: 	for (idx_t byte_idx = 1; byte_idx < OctetLength(bits) + 1; byte_idx++) {
231: 		for (idx_t bit_idx = 0; bit_idx < 8; bit_idx++) {
232: 			count += (buf[byte_idx] & (1 << bit_idx)) ? 1 : 0;
233: 		}
234: 	}
235: 	return count - GetBitPadding(bits);
236: }
237: 
238: idx_t Bit::BitPosition(string_t substring, string_t bits) {
239: 	const char *buf = bits.GetData();
240: 	auto len = bits.GetSize();
241: 	auto substr_len = BitLength(substring);
242: 	idx_t substr_idx = 0;
243: 
244: 	for (idx_t bit_idx = GetBitPadding(bits); bit_idx < 8; bit_idx++) {
245: 		idx_t bit = buf[1] & (1 << (7 - bit_idx)) ? 1 : 0;
246: 		if (bit == GetBit(substring, substr_idx)) {
247: 			substr_idx++;
248: 			if (substr_idx == substr_len) {
249: 				return (bit_idx - GetBitPadding(bits)) - substr_len + 2;
250: 			}
251: 		} else {
252: 			substr_idx = 0;
253: 		}
254: 	}
255: 
256: 	for (idx_t byte_idx = 2; byte_idx < len; byte_idx++) {
257: 		for (idx_t bit_idx = 0; bit_idx < 8; bit_idx++) {
258: 			idx_t bit = buf[byte_idx] & (1 << (7 - bit_idx)) ? 1 : 0;
259: 			if (bit == GetBit(substring, substr_idx)) {
260: 				substr_idx++;
261: 				if (substr_idx == substr_len) {
262: 					return (((byte_idx - 1) * 8) + bit_idx - GetBitPadding(bits)) - substr_len + 2;
263: 				}
264: 			} else {
265: 				substr_idx = 0;
266: 			}
267: 		}
268: 	}
269: 	return 0;
270: }
271: 
272: idx_t Bit::GetBit(string_t bit_string, idx_t n) {
273: 	return Bit::GetBitInternal(bit_string, n + GetBitPadding(bit_string));
274: }
275: 
276: idx_t Bit::GetBitIndex(idx_t n) {
277: 	return n / 8 + 1;
278: }
279: 
280: idx_t Bit::GetBitInternal(string_t bit_string, idx_t n) {
281: 	const char *buf = bit_string.GetData();
282: 	auto idx = Bit::GetBitIndex(n);
283: 	D_ASSERT(idx < bit_string.GetSize());
284: 	auto byte = buf[idx] >> (7 - (n % 8));
285: 	return (byte & 1 ? 1 : 0);
286: }
287: 
288: void Bit::SetBit(string_t &bit_string, idx_t n, idx_t new_value) {
289: 	SetBitInternal(bit_string, n + GetBitPadding(bit_string), new_value);
290: 	Bit::Finalize(bit_string);
291: }
292: 
293: void Bit::SetBitInternal(string_t &bit_string, idx_t n, idx_t new_value) {
294: 	uint8_t *buf = reinterpret_cast<uint8_t *>(bit_string.GetDataWriteable());
295: 
296: 	auto idx = Bit::GetBitIndex(n);
297: 	D_ASSERT(idx < bit_string.GetSize());
298: 	auto shift_byte = UnsafeNumericCast<uint8_t>(1 << (7 - (n % 8)));
299: 	if (new_value == 0) {
300: 		shift_byte = ~shift_byte;
301: 		buf[idx] &= shift_byte;
302: 	} else {
303: 		buf[idx] |= shift_byte;
304: 	}
305: }
306: 
307: // **** BITWISE operators ****
308: void Bit::RightShift(const string_t &bit_string, const idx_t &shift, string_t &result) {
309: 	uint8_t *res_buf = reinterpret_cast<uint8_t *>(result.GetDataWriteable());
310: 	const uint8_t *buf = reinterpret_cast<const uint8_t *>(bit_string.GetData());
311: 
312: 	res_buf[0] = buf[0];
313: 	for (idx_t i = 0; i < Bit::BitLength(result); i++) {
314: 		if (i < shift) {
315: 			Bit::SetBit(result, i, 0);
316: 		} else {
317: 			idx_t bit = Bit::GetBit(bit_string, i - shift);
318: 			Bit::SetBit(result, i, bit);
319: 		}
320: 	}
321: 	Bit::Finalize(result);
322: }
323: 
324: void Bit::LeftShift(const string_t &bit_string, const idx_t &shift, string_t &result) {
325: 	uint8_t *res_buf = reinterpret_cast<uint8_t *>(result.GetDataWriteable());
326: 	const uint8_t *buf = reinterpret_cast<const uint8_t *>(bit_string.GetData());
327: 
328: 	res_buf[0] = buf[0];
329: 	for (idx_t i = 0; i < Bit::BitLength(bit_string); i++) {
330: 		if (i < (Bit::BitLength(bit_string) - shift)) {
331: 			idx_t bit = Bit::GetBit(bit_string, shift + i);
332: 			Bit::SetBit(result, i, bit);
333: 		} else {
334: 			Bit::SetBit(result, i, 0);
335: 		}
336: 	}
337: 	Bit::Finalize(result);
338: }
339: 
340: void Bit::BitwiseAnd(const string_t &rhs, const string_t &lhs, string_t &result) {
341: 	if (Bit::BitLength(lhs) != Bit::BitLength(rhs)) {
342: 		throw InvalidInputException("Cannot AND bit strings of different sizes");
343: 	}
344: 
345: 	uint8_t *buf = reinterpret_cast<uint8_t *>(result.GetDataWriteable());
346: 	const uint8_t *r_buf = reinterpret_cast<const uint8_t *>(rhs.GetData());
347: 	const uint8_t *l_buf = reinterpret_cast<const uint8_t *>(lhs.GetData());
348: 
349: 	buf[0] = l_buf[0];
350: 	for (idx_t i = 1; i < lhs.GetSize(); i++) {
351: 		buf[i] = l_buf[i] & r_buf[i];
352: 	}
353: 	Bit::Finalize(result);
354: }
355: 
356: void Bit::BitwiseOr(const string_t &rhs, const string_t &lhs, string_t &result) {
357: 	if (Bit::BitLength(lhs) != Bit::BitLength(rhs)) {
358: 		throw InvalidInputException("Cannot OR bit strings of different sizes");
359: 	}
360: 
361: 	uint8_t *buf = reinterpret_cast<uint8_t *>(result.GetDataWriteable());
362: 	const uint8_t *r_buf = reinterpret_cast<const uint8_t *>(rhs.GetData());
363: 	const uint8_t *l_buf = reinterpret_cast<const uint8_t *>(lhs.GetData());
364: 
365: 	buf[0] = l_buf[0];
366: 	for (idx_t i = 1; i < lhs.GetSize(); i++) {
367: 		buf[i] = l_buf[i] | r_buf[i];
368: 	}
369: 	Bit::Finalize(result);
370: }
371: 
372: void Bit::BitwiseXor(const string_t &rhs, const string_t &lhs, string_t &result) {
373: 	if (Bit::BitLength(lhs) != Bit::BitLength(rhs)) {
374: 		throw InvalidInputException("Cannot XOR bit strings of different sizes");
375: 	}
376: 
377: 	uint8_t *buf = reinterpret_cast<uint8_t *>(result.GetDataWriteable());
378: 	const uint8_t *r_buf = reinterpret_cast<const uint8_t *>(rhs.GetData());
379: 	const uint8_t *l_buf = reinterpret_cast<const uint8_t *>(lhs.GetData());
380: 
381: 	buf[0] = l_buf[0];
382: 	for (idx_t i = 1; i < lhs.GetSize(); i++) {
383: 		buf[i] = l_buf[i] ^ r_buf[i];
384: 	}
385: 	Bit::Finalize(result);
386: }
387: 
388: void Bit::BitwiseNot(const string_t &input, string_t &result) {
389: 	uint8_t *result_buf = reinterpret_cast<uint8_t *>(result.GetDataWriteable());
390: 	const uint8_t *buf = reinterpret_cast<const uint8_t *>(input.GetData());
391: 
392: 	result_buf[0] = buf[0];
393: 	for (idx_t i = 1; i < input.GetSize(); i++) {
394: 		result_buf[i] = ~buf[i];
395: 	}
396: 	Bit::Finalize(result);
397: }
398: 
399: void Bit::Verify(const string_t &input) {
400: #ifdef DEBUG
401: 	// bit strings require all padding bits to be set to 1
402: 	auto padding = GetBitPadding(input);
403: 	for (idx_t i = 0; i < padding; i++) {
404: 		D_ASSERT(Bit::GetBitInternal(input, i));
405: 	}
406: 	// verify bit respects the "normal" string_t rules (i.e. null padding for inlined strings, prefix matches)
407: 	input.VerifyCharacters();
408: #endif
409: }
410: 
411: } // namespace duckdb
[end of src/common/types/bit.cpp]
[start of src/core_functions/function_list.cpp]
1: #include "duckdb/core_functions/function_list.hpp"
2: #include "duckdb/core_functions/aggregate/algebraic_functions.hpp"
3: #include "duckdb/core_functions/aggregate/distributive_functions.hpp"
4: #include "duckdb/core_functions/aggregate/holistic_functions.hpp"
5: #include "duckdb/core_functions/aggregate/nested_functions.hpp"
6: #include "duckdb/core_functions/aggregate/regression_functions.hpp"
7: #include "duckdb/core_functions/scalar/bit_functions.hpp"
8: #include "duckdb/core_functions/scalar/blob_functions.hpp"
9: #include "duckdb/core_functions/scalar/date_functions.hpp"
10: #include "duckdb/core_functions/scalar/enum_functions.hpp"
11: #include "duckdb/core_functions/scalar/generic_functions.hpp"
12: #include "duckdb/core_functions/scalar/list_functions.hpp"
13: #include "duckdb/core_functions/scalar/map_functions.hpp"
14: #include "duckdb/core_functions/scalar/math_functions.hpp"
15: #include "duckdb/core_functions/scalar/operators_functions.hpp"
16: #include "duckdb/core_functions/scalar/random_functions.hpp"
17: #include "duckdb/core_functions/scalar/secret_functions.hpp"
18: #include "duckdb/core_functions/scalar/string_functions.hpp"
19: #include "duckdb/core_functions/scalar/struct_functions.hpp"
20: #include "duckdb/core_functions/scalar/union_functions.hpp"
21: #include "duckdb/core_functions/scalar/array_functions.hpp"
22: #include "duckdb/core_functions/scalar/debug_functions.hpp"
23: 
24: namespace duckdb {
25: 
26: // Scalar Function
27: #define DUCKDB_SCALAR_FUNCTION_BASE(_PARAM, _NAME)                                                                     \
28: 	{ _NAME, _PARAM::Parameters, _PARAM::Description, _PARAM::Example, _PARAM::GetFunction, nullptr, nullptr, nullptr }
29: #define DUCKDB_SCALAR_FUNCTION(_PARAM)       DUCKDB_SCALAR_FUNCTION_BASE(_PARAM, _PARAM::Name)
30: #define DUCKDB_SCALAR_FUNCTION_ALIAS(_PARAM) DUCKDB_SCALAR_FUNCTION_BASE(_PARAM::ALIAS, _PARAM::Name)
31: // Scalar Function Set
32: #define DUCKDB_SCALAR_FUNCTION_SET_BASE(_PARAM, _NAME)                                                                 \
33: 	{ _NAME, _PARAM::Parameters, _PARAM::Description, _PARAM::Example, nullptr, _PARAM::GetFunctions, nullptr, nullptr }
34: #define DUCKDB_SCALAR_FUNCTION_SET(_PARAM)       DUCKDB_SCALAR_FUNCTION_SET_BASE(_PARAM, _PARAM::Name)
35: #define DUCKDB_SCALAR_FUNCTION_SET_ALIAS(_PARAM) DUCKDB_SCALAR_FUNCTION_SET_BASE(_PARAM::ALIAS, _PARAM::Name)
36: // Aggregate Function
37: #define DUCKDB_AGGREGATE_FUNCTION_BASE(_PARAM, _NAME)                                                                  \
38: 	{ _NAME, _PARAM::Parameters, _PARAM::Description, _PARAM::Example, nullptr, nullptr, _PARAM::GetFunction, nullptr }
39: #define DUCKDB_AGGREGATE_FUNCTION(_PARAM)       DUCKDB_AGGREGATE_FUNCTION_BASE(_PARAM, _PARAM::Name)
40: #define DUCKDB_AGGREGATE_FUNCTION_ALIAS(_PARAM) DUCKDB_AGGREGATE_FUNCTION_BASE(_PARAM::ALIAS, _PARAM::Name)
41: // Aggregate Function Set
42: #define DUCKDB_AGGREGATE_FUNCTION_SET_BASE(_PARAM, _NAME)                                                              \
43: 	{ _NAME, _PARAM::Parameters, _PARAM::Description, _PARAM::Example, nullptr, nullptr, nullptr, _PARAM::GetFunctions }
44: #define DUCKDB_AGGREGATE_FUNCTION_SET(_PARAM)       DUCKDB_AGGREGATE_FUNCTION_SET_BASE(_PARAM, _PARAM::Name)
45: #define DUCKDB_AGGREGATE_FUNCTION_SET_ALIAS(_PARAM) DUCKDB_AGGREGATE_FUNCTION_SET_BASE(_PARAM::ALIAS, _PARAM::Name)
46: #define FINAL_FUNCTION                                                                                                 \
47: 	{ nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr }
48: 
49: // this list is generated by scripts/generate_functions.py
50: static const StaticFunctionDefinition internal_functions[] = {
51: 	DUCKDB_SCALAR_FUNCTION(FactorialOperatorFun),
52: 	DUCKDB_SCALAR_FUNCTION_SET(BitwiseAndFun),
53: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ListHasAnyFunAlias),
54: 	DUCKDB_SCALAR_FUNCTION(PowOperatorFun),
55: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ListDistanceFunAlias),
56: 	DUCKDB_SCALAR_FUNCTION_SET(LeftShiftFun),
57: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ListCosineDistanceFunAlias),
58: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ListHasAllFunAlias2),
59: 	DUCKDB_SCALAR_FUNCTION_SET(RightShiftFun),
60: 	DUCKDB_SCALAR_FUNCTION_SET(AbsOperatorFun),
61: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ListHasAllFunAlias),
62: 	DUCKDB_SCALAR_FUNCTION_ALIAS(PowOperatorFunAlias),
63: 	DUCKDB_SCALAR_FUNCTION(StartsWithOperatorFun),
64: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(AbsFun),
65: 	DUCKDB_SCALAR_FUNCTION(AcosFun),
66: 	DUCKDB_SCALAR_FUNCTION(AcoshFun),
67: 	DUCKDB_SCALAR_FUNCTION_SET(AgeFun),
68: 	DUCKDB_SCALAR_FUNCTION_ALIAS(AggregateFun),
69: 	DUCKDB_SCALAR_FUNCTION(AliasFun),
70: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ApplyFun),
71: 	DUCKDB_AGGREGATE_FUNCTION(ApproxCountDistinctFun),
72: 	DUCKDB_AGGREGATE_FUNCTION_SET(ApproxQuantileFun),
73: 	DUCKDB_AGGREGATE_FUNCTION(ApproxTopKFun),
74: 	DUCKDB_AGGREGATE_FUNCTION_SET(ArgMaxFun),
75: 	DUCKDB_AGGREGATE_FUNCTION_SET(ArgMaxNullFun),
76: 	DUCKDB_AGGREGATE_FUNCTION_SET(ArgMinFun),
77: 	DUCKDB_AGGREGATE_FUNCTION_SET(ArgMinNullFun),
78: 	DUCKDB_AGGREGATE_FUNCTION_SET_ALIAS(ArgmaxFun),
79: 	DUCKDB_AGGREGATE_FUNCTION_SET_ALIAS(ArgminFun),
80: 	DUCKDB_AGGREGATE_FUNCTION_ALIAS(ArrayAggFun),
81: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ArrayAggrFun),
82: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ArrayAggregateFun),
83: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ArrayApplyFun),
84: 	DUCKDB_SCALAR_FUNCTION_SET(ArrayCosineDistanceFun),
85: 	DUCKDB_SCALAR_FUNCTION_SET(ArrayCosineSimilarityFun),
86: 	DUCKDB_SCALAR_FUNCTION_SET(ArrayCrossProductFun),
87: 	DUCKDB_SCALAR_FUNCTION_SET(ArrayDistanceFun),
88: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ArrayDistinctFun),
89: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ArrayDotProductFun),
90: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ArrayFilterFun),
91: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ArrayGradeUpFun),
92: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ArrayHasAllFun),
93: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ArrayHasAnyFun),
94: 	DUCKDB_SCALAR_FUNCTION_SET(ArrayInnerProductFun),
95: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ArrayNegativeDotProductFun),
96: 	DUCKDB_SCALAR_FUNCTION_SET(ArrayNegativeInnerProductFun),
97: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ArrayReduceFun),
98: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ArrayReverseSortFun),
99: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ArraySliceFun),
100: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ArraySortFun),
101: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ArrayTransformFun),
102: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ArrayUniqueFun),
103: 	DUCKDB_SCALAR_FUNCTION(ArrayValueFun),
104: 	DUCKDB_SCALAR_FUNCTION(ASCIIFun),
105: 	DUCKDB_SCALAR_FUNCTION(AsinFun),
106: 	DUCKDB_SCALAR_FUNCTION(AsinhFun),
107: 	DUCKDB_SCALAR_FUNCTION(AtanFun),
108: 	DUCKDB_SCALAR_FUNCTION(Atan2Fun),
109: 	DUCKDB_SCALAR_FUNCTION(AtanhFun),
110: 	DUCKDB_AGGREGATE_FUNCTION_SET(AvgFun),
111: 	DUCKDB_SCALAR_FUNCTION_SET(BarFun),
112: 	DUCKDB_SCALAR_FUNCTION_ALIAS(Base64Fun),
113: 	DUCKDB_SCALAR_FUNCTION_SET(BinFun),
114: 	DUCKDB_AGGREGATE_FUNCTION_SET(BitAndFun),
115: 	DUCKDB_SCALAR_FUNCTION_SET(BitCountFun),
116: 	DUCKDB_AGGREGATE_FUNCTION_SET(BitOrFun),
117: 	DUCKDB_SCALAR_FUNCTION(BitPositionFun),
118: 	DUCKDB_AGGREGATE_FUNCTION_SET(BitXorFun),
119: 	DUCKDB_SCALAR_FUNCTION(BitStringFun),
120: 	DUCKDB_AGGREGATE_FUNCTION_SET(BitstringAggFun),
121: 	DUCKDB_AGGREGATE_FUNCTION(BoolAndFun),
122: 	DUCKDB_AGGREGATE_FUNCTION(BoolOrFun),
123: 	DUCKDB_SCALAR_FUNCTION(CanCastImplicitlyFun),
124: 	DUCKDB_SCALAR_FUNCTION(CardinalityFun),
125: 	DUCKDB_SCALAR_FUNCTION(CbrtFun),
126: 	DUCKDB_SCALAR_FUNCTION_SET(CeilFun),
127: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(CeilingFun),
128: 	DUCKDB_SCALAR_FUNCTION_SET(CenturyFun),
129: 	DUCKDB_SCALAR_FUNCTION(ChrFun),
130: 	DUCKDB_AGGREGATE_FUNCTION(CorrFun),
131: 	DUCKDB_SCALAR_FUNCTION(CosFun),
132: 	DUCKDB_SCALAR_FUNCTION(CoshFun),
133: 	DUCKDB_SCALAR_FUNCTION(CotFun),
134: 	DUCKDB_AGGREGATE_FUNCTION(CovarPopFun),
135: 	DUCKDB_AGGREGATE_FUNCTION(CovarSampFun),
136: 	DUCKDB_SCALAR_FUNCTION(CreateSortKeyFun),
137: 	DUCKDB_SCALAR_FUNCTION(CurrentDatabaseFun),
138: 	DUCKDB_SCALAR_FUNCTION(CurrentDateFun),
139: 	DUCKDB_SCALAR_FUNCTION(CurrentQueryFun),
140: 	DUCKDB_SCALAR_FUNCTION(CurrentSchemaFun),
141: 	DUCKDB_SCALAR_FUNCTION(CurrentSchemasFun),
142: 	DUCKDB_SCALAR_FUNCTION(CurrentSettingFun),
143: 	DUCKDB_SCALAR_FUNCTION(DamerauLevenshteinFun),
144: 	DUCKDB_SCALAR_FUNCTION_SET(DateDiffFun),
145: 	DUCKDB_SCALAR_FUNCTION_SET(DatePartFun),
146: 	DUCKDB_SCALAR_FUNCTION_SET(DateSubFun),
147: 	DUCKDB_SCALAR_FUNCTION_SET(DateTruncFun),
148: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(DatediffFun),
149: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(DatepartFun),
150: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(DatesubFun),
151: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(DatetruncFun),
152: 	DUCKDB_SCALAR_FUNCTION_SET(DayFun),
153: 	DUCKDB_SCALAR_FUNCTION_SET(DayNameFun),
154: 	DUCKDB_SCALAR_FUNCTION_SET(DayOfMonthFun),
155: 	DUCKDB_SCALAR_FUNCTION_SET(DayOfWeekFun),
156: 	DUCKDB_SCALAR_FUNCTION_SET(DayOfYearFun),
157: 	DUCKDB_SCALAR_FUNCTION_SET(DecadeFun),
158: 	DUCKDB_SCALAR_FUNCTION(DecodeFun),
159: 	DUCKDB_SCALAR_FUNCTION(DegreesFun),
160: 	DUCKDB_SCALAR_FUNCTION_ALIAS(Editdist3Fun),
161: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ElementAtFun),
162: 	DUCKDB_SCALAR_FUNCTION(EncodeFun),
163: 	DUCKDB_AGGREGATE_FUNCTION_SET(EntropyFun),
164: 	DUCKDB_SCALAR_FUNCTION(EnumCodeFun),
165: 	DUCKDB_SCALAR_FUNCTION(EnumFirstFun),
166: 	DUCKDB_SCALAR_FUNCTION(EnumLastFun),
167: 	DUCKDB_SCALAR_FUNCTION(EnumRangeFun),
168: 	DUCKDB_SCALAR_FUNCTION(EnumRangeBoundaryFun),
169: 	DUCKDB_SCALAR_FUNCTION_SET(EpochFun),
170: 	DUCKDB_SCALAR_FUNCTION_SET(EpochMsFun),
171: 	DUCKDB_SCALAR_FUNCTION_SET(EpochNsFun),
172: 	DUCKDB_SCALAR_FUNCTION_SET(EpochUsFun),
173: 	DUCKDB_SCALAR_FUNCTION_SET(EquiWidthBinsFun),
174: 	DUCKDB_SCALAR_FUNCTION_SET(EraFun),
175: 	DUCKDB_SCALAR_FUNCTION(ErrorFun),
176: 	DUCKDB_SCALAR_FUNCTION(EvenFun),
177: 	DUCKDB_SCALAR_FUNCTION(ExpFun),
178: 	DUCKDB_SCALAR_FUNCTION_ALIAS(FactorialFun),
179: 	DUCKDB_AGGREGATE_FUNCTION(FAvgFun),
180: 	DUCKDB_SCALAR_FUNCTION_ALIAS(FilterFun),
181: 	DUCKDB_SCALAR_FUNCTION(ListFlattenFun),
182: 	DUCKDB_SCALAR_FUNCTION_SET(FloorFun),
183: 	DUCKDB_SCALAR_FUNCTION(FormatFun),
184: 	DUCKDB_SCALAR_FUNCTION(FormatreadabledecimalsizeFun),
185: 	DUCKDB_SCALAR_FUNCTION_ALIAS(FormatreadablesizeFun),
186: 	DUCKDB_SCALAR_FUNCTION(FormatBytesFun),
187: 	DUCKDB_SCALAR_FUNCTION(FromBase64Fun),
188: 	DUCKDB_SCALAR_FUNCTION_ALIAS(FromBinaryFun),
189: 	DUCKDB_SCALAR_FUNCTION_ALIAS(FromHexFun),
190: 	DUCKDB_AGGREGATE_FUNCTION_ALIAS(FsumFun),
191: 	DUCKDB_SCALAR_FUNCTION(GammaFun),
192: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(GcdFun),
193: 	DUCKDB_SCALAR_FUNCTION_ALIAS(GenRandomUuidFun),
194: 	DUCKDB_SCALAR_FUNCTION_SET(GenerateSeriesFun),
195: 	DUCKDB_SCALAR_FUNCTION(GetBitFun),
196: 	DUCKDB_SCALAR_FUNCTION(CurrentTimeFun),
197: 	DUCKDB_SCALAR_FUNCTION(GetCurrentTimestampFun),
198: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(GradeUpFun),
199: 	DUCKDB_SCALAR_FUNCTION_SET(GreatestFun),
200: 	DUCKDB_SCALAR_FUNCTION_SET(GreatestCommonDivisorFun),
201: 	DUCKDB_AGGREGATE_FUNCTION_SET_ALIAS(GroupConcatFun),
202: 	DUCKDB_SCALAR_FUNCTION(HammingFun),
203: 	DUCKDB_SCALAR_FUNCTION(HashFun),
204: 	DUCKDB_SCALAR_FUNCTION_SET(HexFun),
205: 	DUCKDB_AGGREGATE_FUNCTION_SET(HistogramFun),
206: 	DUCKDB_AGGREGATE_FUNCTION(HistogramExactFun),
207: 	DUCKDB_SCALAR_FUNCTION_SET(HoursFun),
208: 	DUCKDB_SCALAR_FUNCTION(InSearchPathFun),
209: 	DUCKDB_SCALAR_FUNCTION(InstrFun),
210: 	DUCKDB_SCALAR_FUNCTION(IsHistogramOtherBinFun),
211: 	DUCKDB_SCALAR_FUNCTION_SET(IsFiniteFun),
212: 	DUCKDB_SCALAR_FUNCTION_SET(IsInfiniteFun),
213: 	DUCKDB_SCALAR_FUNCTION_SET(IsNanFun),
214: 	DUCKDB_SCALAR_FUNCTION_SET(ISODayOfWeekFun),
215: 	DUCKDB_SCALAR_FUNCTION_SET(ISOYearFun),
216: 	DUCKDB_SCALAR_FUNCTION(JaccardFun),
217: 	DUCKDB_SCALAR_FUNCTION(JaroSimilarityFun),
218: 	DUCKDB_SCALAR_FUNCTION(JaroWinklerSimilarityFun),
219: 	DUCKDB_SCALAR_FUNCTION_SET(JulianDayFun),
220: 	DUCKDB_AGGREGATE_FUNCTION(KahanSumFun),
221: 	DUCKDB_AGGREGATE_FUNCTION(KurtosisFun),
222: 	DUCKDB_AGGREGATE_FUNCTION(KurtosisPopFun),
223: 	DUCKDB_SCALAR_FUNCTION_SET(LastDayFun),
224: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(LcmFun),
225: 	DUCKDB_SCALAR_FUNCTION_SET(LeastFun),
226: 	DUCKDB_SCALAR_FUNCTION_SET(LeastCommonMultipleFun),
227: 	DUCKDB_SCALAR_FUNCTION(LeftFun),
228: 	DUCKDB_SCALAR_FUNCTION(LeftGraphemeFun),
229: 	DUCKDB_SCALAR_FUNCTION(LevenshteinFun),
230: 	DUCKDB_SCALAR_FUNCTION(LogGammaFun),
231: 	DUCKDB_AGGREGATE_FUNCTION(ListFun),
232: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ListAggrFun),
233: 	DUCKDB_SCALAR_FUNCTION(ListAggregateFun),
234: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ListApplyFun),
235: 	DUCKDB_SCALAR_FUNCTION_SET(ListCosineDistanceFun),
236: 	DUCKDB_SCALAR_FUNCTION_SET(ListCosineSimilarityFun),
237: 	DUCKDB_SCALAR_FUNCTION_SET(ListDistanceFun),
238: 	DUCKDB_SCALAR_FUNCTION(ListDistinctFun),
239: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ListDotProductFun),
240: 	DUCKDB_SCALAR_FUNCTION(ListFilterFun),
241: 	DUCKDB_SCALAR_FUNCTION_SET(ListGradeUpFun),
242: 	DUCKDB_SCALAR_FUNCTION(ListHasAllFun),
243: 	DUCKDB_SCALAR_FUNCTION(ListHasAnyFun),
244: 	DUCKDB_SCALAR_FUNCTION_SET(ListInnerProductFun),
245: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ListNegativeDotProductFun),
246: 	DUCKDB_SCALAR_FUNCTION_SET(ListNegativeInnerProductFun),
247: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ListPackFun),
248: 	DUCKDB_SCALAR_FUNCTION(ListReduceFun),
249: 	DUCKDB_SCALAR_FUNCTION_SET(ListReverseSortFun),
250: 	DUCKDB_SCALAR_FUNCTION_SET(ListSliceFun),
251: 	DUCKDB_SCALAR_FUNCTION_SET(ListSortFun),
252: 	DUCKDB_SCALAR_FUNCTION(ListTransformFun),
253: 	DUCKDB_SCALAR_FUNCTION(ListUniqueFun),
254: 	DUCKDB_SCALAR_FUNCTION(ListValueFun),
255: 	DUCKDB_AGGREGATE_FUNCTION_SET_ALIAS(ListaggFun),
256: 	DUCKDB_SCALAR_FUNCTION(LnFun),
257: 	DUCKDB_SCALAR_FUNCTION_SET(LogFun),
258: 	DUCKDB_SCALAR_FUNCTION(Log10Fun),
259: 	DUCKDB_SCALAR_FUNCTION(Log2Fun),
260: 	DUCKDB_SCALAR_FUNCTION(LpadFun),
261: 	DUCKDB_SCALAR_FUNCTION_SET(LtrimFun),
262: 	DUCKDB_AGGREGATE_FUNCTION_SET(MadFun),
263: 	DUCKDB_SCALAR_FUNCTION_SET(MakeDateFun),
264: 	DUCKDB_SCALAR_FUNCTION(MakeTimeFun),
265: 	DUCKDB_SCALAR_FUNCTION_SET(MakeTimestampFun),
266: 	DUCKDB_SCALAR_FUNCTION(MapFun),
267: 	DUCKDB_SCALAR_FUNCTION(MapConcatFun),
268: 	DUCKDB_SCALAR_FUNCTION(MapContainsFun),
269: 	DUCKDB_SCALAR_FUNCTION(MapEntriesFun),
270: 	DUCKDB_SCALAR_FUNCTION(MapExtractFun),
271: 	DUCKDB_SCALAR_FUNCTION(MapFromEntriesFun),
272: 	DUCKDB_SCALAR_FUNCTION(MapKeysFun),
273: 	DUCKDB_SCALAR_FUNCTION(MapValuesFun),
274: 	DUCKDB_AGGREGATE_FUNCTION_SET(MaxFun),
275: 	DUCKDB_AGGREGATE_FUNCTION_SET_ALIAS(MaxByFun),
276: 	DUCKDB_SCALAR_FUNCTION_SET(MD5Fun),
277: 	DUCKDB_SCALAR_FUNCTION_SET(MD5NumberFun),
278: 	DUCKDB_AGGREGATE_FUNCTION_SET_ALIAS(MeanFun),
279: 	DUCKDB_AGGREGATE_FUNCTION_SET(MedianFun),
280: 	DUCKDB_SCALAR_FUNCTION_SET(MicrosecondsFun),
281: 	DUCKDB_SCALAR_FUNCTION_SET(MillenniumFun),
282: 	DUCKDB_SCALAR_FUNCTION_SET(MillisecondsFun),
283: 	DUCKDB_AGGREGATE_FUNCTION_SET(MinFun),
284: 	DUCKDB_AGGREGATE_FUNCTION_SET_ALIAS(MinByFun),
285: 	DUCKDB_SCALAR_FUNCTION_SET(MinutesFun),
286: 	DUCKDB_SCALAR_FUNCTION_ALIAS(MismatchesFun),
287: 	DUCKDB_AGGREGATE_FUNCTION_SET(ModeFun),
288: 	DUCKDB_SCALAR_FUNCTION_SET(MonthFun),
289: 	DUCKDB_SCALAR_FUNCTION_SET(MonthNameFun),
290: 	DUCKDB_SCALAR_FUNCTION_SET(NanosecondsFun),
291: 	DUCKDB_SCALAR_FUNCTION_SET(NextAfterFun),
292: 	DUCKDB_SCALAR_FUNCTION_ALIAS(NowFun),
293: 	DUCKDB_SCALAR_FUNCTION_ALIAS(OrdFun),
294: 	DUCKDB_SCALAR_FUNCTION_SET(ParseDirnameFun),
295: 	DUCKDB_SCALAR_FUNCTION_SET(ParseDirpathFun),
296: 	DUCKDB_SCALAR_FUNCTION_SET(ParseFilenameFun),
297: 	DUCKDB_SCALAR_FUNCTION_SET(ParsePathFun),
298: 	DUCKDB_SCALAR_FUNCTION(PiFun),
299: 	DUCKDB_SCALAR_FUNCTION_ALIAS(PositionFun),
300: 	DUCKDB_SCALAR_FUNCTION_ALIAS(PowFun),
301: 	DUCKDB_SCALAR_FUNCTION_ALIAS(PowerFun),
302: 	DUCKDB_SCALAR_FUNCTION(PrintfFun),
303: 	DUCKDB_AGGREGATE_FUNCTION(ProductFun),
304: 	DUCKDB_AGGREGATE_FUNCTION_SET_ALIAS(QuantileFun),
305: 	DUCKDB_AGGREGATE_FUNCTION_SET(QuantileContFun),
306: 	DUCKDB_AGGREGATE_FUNCTION_SET(QuantileDiscFun),
307: 	DUCKDB_SCALAR_FUNCTION_SET(QuarterFun),
308: 	DUCKDB_SCALAR_FUNCTION(RadiansFun),
309: 	DUCKDB_SCALAR_FUNCTION(RandomFun),
310: 	DUCKDB_SCALAR_FUNCTION_SET(ListRangeFun),
311: 	DUCKDB_SCALAR_FUNCTION_ALIAS(ReduceFun),
312: 	DUCKDB_SCALAR_FUNCTION(RegexpEscapeFun),
313: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(RegexpSplitToArrayFun),
314: 	DUCKDB_AGGREGATE_FUNCTION(RegrAvgxFun),
315: 	DUCKDB_AGGREGATE_FUNCTION(RegrAvgyFun),
316: 	DUCKDB_AGGREGATE_FUNCTION(RegrCountFun),
317: 	DUCKDB_AGGREGATE_FUNCTION(RegrInterceptFun),
318: 	DUCKDB_AGGREGATE_FUNCTION(RegrR2Fun),
319: 	DUCKDB_AGGREGATE_FUNCTION(RegrSlopeFun),
320: 	DUCKDB_AGGREGATE_FUNCTION(RegrSXXFun),
321: 	DUCKDB_AGGREGATE_FUNCTION(RegrSXYFun),
322: 	DUCKDB_AGGREGATE_FUNCTION(RegrSYYFun),
323: 	DUCKDB_SCALAR_FUNCTION_SET(RepeatFun),
324: 	DUCKDB_SCALAR_FUNCTION(ReplaceFun),
325: 	DUCKDB_AGGREGATE_FUNCTION_SET(ReservoirQuantileFun),
326: 	DUCKDB_SCALAR_FUNCTION(ReverseFun),
327: 	DUCKDB_SCALAR_FUNCTION(RightFun),
328: 	DUCKDB_SCALAR_FUNCTION(RightGraphemeFun),
329: 	DUCKDB_SCALAR_FUNCTION_SET(RoundFun),
330: 	DUCKDB_SCALAR_FUNCTION(RowFun),
331: 	DUCKDB_SCALAR_FUNCTION(RpadFun),
332: 	DUCKDB_SCALAR_FUNCTION_SET(RtrimFun),
333: 	DUCKDB_SCALAR_FUNCTION_SET(SecondsFun),
334: 	DUCKDB_AGGREGATE_FUNCTION(StandardErrorOfTheMeanFun),
335: 	DUCKDB_SCALAR_FUNCTION(SetBitFun),
336: 	DUCKDB_SCALAR_FUNCTION(SetseedFun),
337: 	DUCKDB_SCALAR_FUNCTION_SET(SHA1Fun),
338: 	DUCKDB_SCALAR_FUNCTION_SET(SHA256Fun),
339: 	DUCKDB_SCALAR_FUNCTION_SET(SignFun),
340: 	DUCKDB_SCALAR_FUNCTION_SET(SignBitFun),
341: 	DUCKDB_SCALAR_FUNCTION(SinFun),
342: 	DUCKDB_SCALAR_FUNCTION(SinhFun),
343: 	DUCKDB_AGGREGATE_FUNCTION(SkewnessFun),
344: 	DUCKDB_SCALAR_FUNCTION_ALIAS(SplitFun),
345: 	DUCKDB_SCALAR_FUNCTION(SqrtFun),
346: 	DUCKDB_SCALAR_FUNCTION_ALIAS(StartsWithFun),
347: 	DUCKDB_SCALAR_FUNCTION(StatsFun),
348: 	DUCKDB_AGGREGATE_FUNCTION_ALIAS(StddevFun),
349: 	DUCKDB_AGGREGATE_FUNCTION(StdDevPopFun),
350: 	DUCKDB_AGGREGATE_FUNCTION(StdDevSampFun),
351: 	DUCKDB_SCALAR_FUNCTION_ALIAS(StrSplitFun),
352: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(StrSplitRegexFun),
353: 	DUCKDB_SCALAR_FUNCTION_SET(StrfTimeFun),
354: 	DUCKDB_AGGREGATE_FUNCTION_SET(StringAggFun),
355: 	DUCKDB_SCALAR_FUNCTION(StringSplitFun),
356: 	DUCKDB_SCALAR_FUNCTION_SET(StringSplitRegexFun),
357: 	DUCKDB_SCALAR_FUNCTION_ALIAS(StringToArrayFun),
358: 	DUCKDB_SCALAR_FUNCTION_ALIAS(StrposFun),
359: 	DUCKDB_SCALAR_FUNCTION_SET(StrpTimeFun),
360: 	DUCKDB_SCALAR_FUNCTION(StructInsertFun),
361: 	DUCKDB_SCALAR_FUNCTION(StructPackFun),
362: 	DUCKDB_AGGREGATE_FUNCTION_SET(SumFun),
363: 	DUCKDB_AGGREGATE_FUNCTION_SET(SumNoOverflowFun),
364: 	DUCKDB_AGGREGATE_FUNCTION_ALIAS(SumkahanFun),
365: 	DUCKDB_SCALAR_FUNCTION(TanFun),
366: 	DUCKDB_SCALAR_FUNCTION(TanhFun),
367: 	DUCKDB_SCALAR_FUNCTION_SET(TimeBucketFun),
368: 	DUCKDB_SCALAR_FUNCTION(TimeTZSortKeyFun),
369: 	DUCKDB_SCALAR_FUNCTION_SET(TimezoneFun),
370: 	DUCKDB_SCALAR_FUNCTION_SET(TimezoneHourFun),
371: 	DUCKDB_SCALAR_FUNCTION_SET(TimezoneMinuteFun),
372: 	DUCKDB_SCALAR_FUNCTION_SET(ToBaseFun),
373: 	DUCKDB_SCALAR_FUNCTION(ToBase64Fun),
374: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ToBinaryFun),
375: 	DUCKDB_SCALAR_FUNCTION(ToCenturiesFun),
376: 	DUCKDB_SCALAR_FUNCTION(ToDaysFun),
377: 	DUCKDB_SCALAR_FUNCTION(ToDecadesFun),
378: 	DUCKDB_SCALAR_FUNCTION_SET_ALIAS(ToHexFun),
379: 	DUCKDB_SCALAR_FUNCTION(ToHoursFun),
380: 	DUCKDB_SCALAR_FUNCTION(ToMicrosecondsFun),
381: 	DUCKDB_SCALAR_FUNCTION(ToMillenniaFun),
382: 	DUCKDB_SCALAR_FUNCTION(ToMillisecondsFun),
383: 	DUCKDB_SCALAR_FUNCTION(ToMinutesFun),
384: 	DUCKDB_SCALAR_FUNCTION(ToMonthsFun),
385: 	DUCKDB_SCALAR_FUNCTION(ToQuartersFun),
386: 	DUCKDB_SCALAR_FUNCTION(ToSecondsFun),
387: 	DUCKDB_SCALAR_FUNCTION(ToTimestampFun),
388: 	DUCKDB_SCALAR_FUNCTION(ToWeeksFun),
389: 	DUCKDB_SCALAR_FUNCTION(ToYearsFun),
390: 	DUCKDB_SCALAR_FUNCTION_ALIAS(TodayFun),
391: 	DUCKDB_SCALAR_FUNCTION_ALIAS(TransactionTimestampFun),
392: 	DUCKDB_SCALAR_FUNCTION(TranslateFun),
393: 	DUCKDB_SCALAR_FUNCTION_SET(TrimFun),
394: 	DUCKDB_SCALAR_FUNCTION_SET(TruncFun),
395: 	DUCKDB_SCALAR_FUNCTION_SET(TryStrpTimeFun),
396: 	DUCKDB_SCALAR_FUNCTION(CurrentTransactionIdFun),
397: 	DUCKDB_SCALAR_FUNCTION(TypeOfFun),
398: 	DUCKDB_SCALAR_FUNCTION(UnbinFun),
399: 	DUCKDB_SCALAR_FUNCTION(UnhexFun),
400: 	DUCKDB_SCALAR_FUNCTION(UnicodeFun),
401: 	DUCKDB_SCALAR_FUNCTION(UnionExtractFun),
402: 	DUCKDB_SCALAR_FUNCTION(UnionTagFun),
403: 	DUCKDB_SCALAR_FUNCTION(UnionValueFun),
404: 	DUCKDB_SCALAR_FUNCTION(UnpivotListFun),
405: 	DUCKDB_SCALAR_FUNCTION(UrlDecodeFun),
406: 	DUCKDB_SCALAR_FUNCTION(UrlEncodeFun),
407: 	DUCKDB_SCALAR_FUNCTION(UUIDFun),
408: 	DUCKDB_AGGREGATE_FUNCTION(VarPopFun),
409: 	DUCKDB_AGGREGATE_FUNCTION(VarSampFun),
410: 	DUCKDB_AGGREGATE_FUNCTION_ALIAS(VarianceFun),
411: 	DUCKDB_SCALAR_FUNCTION(VectorTypeFun),
412: 	DUCKDB_SCALAR_FUNCTION(VersionFun),
413: 	DUCKDB_SCALAR_FUNCTION_SET(WeekFun),
414: 	DUCKDB_SCALAR_FUNCTION_SET(WeekDayFun),
415: 	DUCKDB_SCALAR_FUNCTION_SET(WeekOfYearFun),
416: 	DUCKDB_SCALAR_FUNCTION_SET(BitwiseXorFun),
417: 	DUCKDB_SCALAR_FUNCTION_SET(YearFun),
418: 	DUCKDB_SCALAR_FUNCTION_SET(YearWeekFun),
419: 	DUCKDB_SCALAR_FUNCTION_SET(BitwiseOrFun),
420: 	DUCKDB_SCALAR_FUNCTION_SET(BitwiseNotFun),
421: 	FINAL_FUNCTION
422: };
423: 
424: const StaticFunctionDefinition *StaticFunctionDefinition::GetFunctionList() {
425: 	return internal_functions;
426: }
427: 
428: } // namespace duckdb
[end of src/core_functions/function_list.cpp]
[start of src/core_functions/scalar/bit/bitstring.cpp]
1: #include "duckdb/core_functions/scalar/bit_functions.hpp"
2: #include "duckdb/common/types/bit.hpp"
3: #include "duckdb/common/types/cast_helpers.hpp"
4: 
5: namespace duckdb {
6: 
7: //===--------------------------------------------------------------------===//
8: // BitStringFunction
9: //===--------------------------------------------------------------------===//
10: static void BitStringFunction(DataChunk &args, ExpressionState &state, Vector &result) {
11: 	BinaryExecutor::Execute<string_t, int32_t, string_t>(
12: 	    args.data[0], args.data[1], result, args.size(), [&](string_t input, int32_t n) {
13: 		    if (n < 0) {
14: 			    throw InvalidInputException("The bitstring length cannot be negative");
15: 		    }
16: 		    if (idx_t(n) < input.GetSize()) {
17: 			    throw InvalidInputException("Length must be equal or larger than input string");
18: 		    }
19: 		    idx_t len;
20: 		    Bit::TryGetBitStringSize(input, len, nullptr); // string verification
21: 
22: 		    len = Bit::ComputeBitstringLen(UnsafeNumericCast<idx_t>(n));
23: 		    string_t target = StringVector::EmptyString(result, len);
24: 		    Bit::BitString(input, UnsafeNumericCast<idx_t>(n), target);
25: 		    target.Finalize();
26: 		    return target;
27: 	    });
28: }
29: 
30: ScalarFunction BitStringFun::GetFunction() {
31: 	return ScalarFunction({LogicalType::VARCHAR, LogicalType::INTEGER}, LogicalType::BIT, BitStringFunction);
32: }
33: 
34: //===--------------------------------------------------------------------===//
35: // get_bit
36: //===--------------------------------------------------------------------===//
37: struct GetBitOperator {
38: 	template <class TA, class TB, class TR>
39: 	static inline TR Operation(TA input, TB n) {
40: 		if (n < 0 || (idx_t)n > Bit::BitLength(input) - 1) {
41: 			throw OutOfRangeException("bit index %s out of valid range (0..%s)", NumericHelper::ToString(n),
42: 			                          NumericHelper::ToString(Bit::BitLength(input) - 1));
43: 		}
44: 		return UnsafeNumericCast<TR>(Bit::GetBit(input, UnsafeNumericCast<idx_t>(n)));
45: 	}
46: };
47: 
48: ScalarFunction GetBitFun::GetFunction() {
49: 	return ScalarFunction({LogicalType::BIT, LogicalType::INTEGER}, LogicalType::INTEGER,
50: 	                      ScalarFunction::BinaryFunction<string_t, int32_t, int32_t, GetBitOperator>);
51: }
52: 
53: //===--------------------------------------------------------------------===//
54: // set_bit
55: //===--------------------------------------------------------------------===//
56: static void SetBitOperation(DataChunk &args, ExpressionState &state, Vector &result) {
57: 	TernaryExecutor::Execute<string_t, int32_t, int32_t, string_t>(
58: 	    args.data[0], args.data[1], args.data[2], result, args.size(),
59: 	    [&](string_t input, int32_t n, int32_t new_value) {
60: 		    if (new_value != 0 && new_value != 1) {
61: 			    throw InvalidInputException("The new bit must be 1 or 0");
62: 		    }
63: 		    if (n < 0 || (idx_t)n > Bit::BitLength(input) - 1) {
64: 			    throw OutOfRangeException("bit index %s out of valid range (0..%s)", NumericHelper::ToString(n),
65: 			                              NumericHelper::ToString(Bit::BitLength(input) - 1));
66: 		    }
67: 		    string_t target = StringVector::EmptyString(result, input.GetSize());
68: 		    memcpy(target.GetDataWriteable(), input.GetData(), input.GetSize());
69: 		    Bit::SetBit(target, UnsafeNumericCast<idx_t>(n), UnsafeNumericCast<idx_t>(new_value));
70: 		    return target;
71: 	    });
72: }
73: 
74: ScalarFunction SetBitFun::GetFunction() {
75: 	return ScalarFunction({LogicalType::BIT, LogicalType::INTEGER, LogicalType::INTEGER}, LogicalType::BIT,
76: 	                      SetBitOperation);
77: }
78: 
79: //===--------------------------------------------------------------------===//
80: // bit_position
81: //===--------------------------------------------------------------------===//
82: struct BitPositionOperator {
83: 	template <class TA, class TB, class TR>
84: 	static inline TR Operation(TA substring, TB input) {
85: 		if (substring.GetSize() > input.GetSize()) {
86: 			return 0;
87: 		}
88: 		return UnsafeNumericCast<TR>(Bit::BitPosition(substring, input));
89: 	}
90: };
91: 
92: ScalarFunction BitPositionFun::GetFunction() {
93: 	return ScalarFunction({LogicalType::BIT, LogicalType::BIT}, LogicalType::INTEGER,
94: 	                      ScalarFunction::BinaryFunction<string_t, string_t, int32_t, BitPositionOperator>);
95: }
96: 
97: } // namespace duckdb
[end of src/core_functions/scalar/bit/bitstring.cpp]
[start of src/core_functions/scalar/bit/functions.json]
1: [
2:     {
3:         "name": "get_bit",
4:         "parameters": "bitstring,index",
5:         "description": "Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0",
6:         "example": "get_bit('0110010'::BIT, 2)",
7:         "type": "scalar_function"
8:     },
9:     {
10:         "name": "set_bit",
11:         "parameters": "bitstring,index,new_value",
12:         "description": "Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0. Returns a new bitstring",
13:         "example": "set_bit('0110010'::BIT, 2, 0)",
14:         "type": "scalar_function"
15:     },
16:     {
17:         "name": "bit_position",
18:         "parameters": "substring,bitstring",
19:         "description": "Returns first starting index of the specified substring within bits, or zero if it is not present. The first (leftmost) bit is indexed 1",
20:         "example": "bit_position('010'::BIT, '1110101'::BIT)",
21:         "type": "scalar_function"
22:     },
23:     {
24:         "name": "bitstring",
25:         "parameters": "bitstring,length",
26:         "description": "Pads the bitstring until the specified length",
27:         "example": "bitstring('1010'::BIT, 7)",
28:         "struct": "BitStringFun",
29:         "type": "scalar_function"
30:     }
31: ]
[end of src/core_functions/scalar/bit/functions.json]
[start of src/include/duckdb/common/types/bit.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/bit.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/assert.hpp"
12: #include "duckdb/common/common.hpp"
13: #include "duckdb/common/hugeint.hpp"
14: #include "duckdb/common/limits.hpp"
15: #include "duckdb/common/types.hpp"
16: #include "duckdb/common/types/string_type.hpp"
17: 
18: namespace duckdb {
19: 
20: //! The Bit class is a static class that holds helper functions for the BIT type.
21: class Bit {
22: public:
23: 	//! Returns the number of bits in the bit string
24: 	DUCKDB_API static idx_t BitLength(string_t bits);
25: 	//! Returns the number of set bits in the bit string
26: 	DUCKDB_API static idx_t BitCount(string_t bits);
27: 	//! Returns the number of bytes in the bit string
28: 	DUCKDB_API static idx_t OctetLength(string_t bits);
29: 	//! Extracts the nth bit from bit string; the first (leftmost) bit is indexed 0
30: 	DUCKDB_API static idx_t GetBit(string_t bit_string, idx_t n);
31: 	//! Sets the nth bit in bit string to newvalue; the first (leftmost) bit is indexed 0
32: 	DUCKDB_API static void SetBit(string_t &bit_string, idx_t n, idx_t new_value);
33: 	//! Returns first starting index of the specified substring within bits, or zero if it's not present.
34: 	DUCKDB_API static idx_t BitPosition(string_t substring, string_t bits);
35: 	//! Converts bits to a string, writing the output to the designated output string.
36: 	//! The string needs to have space for at least GetStringSize(bits) bytes.
37: 	DUCKDB_API static void ToString(string_t bits, char *output);
38: 	DUCKDB_API static string ToString(string_t str);
39: 	//! Returns the bit size of a string -> bit conversion
40: 	DUCKDB_API static bool TryGetBitStringSize(string_t str, idx_t &result_size, string *error_message);
41: 	//! Convert a string to a bit. This function should ONLY be called after calling GetBitSize, since it does NOT
42: 	//! perform data validation.
43: 	DUCKDB_API static void ToBit(string_t str, string_t &output);
44: 
45: 	DUCKDB_API static string ToBit(string_t str);
46: 
47: 	//! output needs to have enough space allocated before calling this function (blob size + 1)
48: 	DUCKDB_API static void BlobToBit(string_t blob, string_t &output);
49: 
50: 	DUCKDB_API static string BlobToBit(string_t blob);
51: 
52: 	//! output_str needs to have enough space allocated before calling this function (sizeof(T) + 1)
53: 	template <class T>
54: 	static void NumericToBit(T numeric, string_t &output_str);
55: 
56: 	template <class T>
57: 	static string NumericToBit(T numeric);
58: 
59: 	//! bit is expected to fit inside of output num (bit size <= sizeof(T) + 1)
60: 	template <class T>
61: 	static void BitToNumeric(string_t bit, T &output_num);
62: 
63: 	template <class T>
64: 	static T BitToNumeric(string_t bit);
65: 
66: 	//! bit is expected to fit inside of output_blob (bit size = output_blob + 1)
67: 	static void BitToBlob(string_t bit, string_t &output_blob);
68: 
69: 	static string BitToBlob(string_t bit);
70: 
71: 	//! Creates a new bitstring of determined length
72: 	DUCKDB_API static void BitString(const string_t &input, const idx_t &len, string_t &result);
73: 	DUCKDB_API static void SetEmptyBitString(string_t &target, string_t &input);
74: 	DUCKDB_API static void SetEmptyBitString(string_t &target, idx_t len);
75: 	DUCKDB_API static idx_t ComputeBitstringLen(idx_t len);
76: 
77: 	DUCKDB_API static void RightShift(const string_t &bit_string, const idx_t &shif, string_t &result);
78: 	DUCKDB_API static void LeftShift(const string_t &bit_string, const idx_t &shift, string_t &result);
79: 	DUCKDB_API static void BitwiseAnd(const string_t &rhs, const string_t &lhs, string_t &result);
80: 	DUCKDB_API static void BitwiseOr(const string_t &rhs, const string_t &lhs, string_t &result);
81: 	DUCKDB_API static void BitwiseXor(const string_t &rhs, const string_t &lhs, string_t &result);
82: 	DUCKDB_API static void BitwiseNot(const string_t &rhs, string_t &result);
83: 
84: 	DUCKDB_API static void Verify(const string_t &input);
85: 
86: private:
87: 	static void Finalize(string_t &str);
88: 	static idx_t GetBitInternal(string_t bit_string, idx_t n);
89: 	static void SetBitInternal(string_t &bit_string, idx_t n, idx_t new_value);
90: 	static idx_t GetBitIndex(idx_t n);
91: 	static uint8_t GetFirstByte(const string_t &str);
92: };
93: 
94: //===--------------------------------------------------------------------===//
95: // Bit Template definitions
96: //===--------------------------------------------------------------------===//
97: template <class T>
98: void Bit::NumericToBit(T numeric, string_t &output_str) {
99: 	D_ASSERT(output_str.GetSize() >= sizeof(T) + 1);
100: 
101: 	auto output = output_str.GetDataWriteable();
102: 	auto data = const_data_ptr_cast(&numeric);
103: 
104: 	*output = 0; // set padding to 0
105: 	++output;
106: 	for (idx_t idx = 0; idx < sizeof(T); ++idx) {
107: 		output[idx] = static_cast<char>(data[sizeof(T) - idx - 1]);
108: 	}
109: 	Bit::Finalize(output_str);
110: }
111: 
112: template <class T>
113: string Bit::NumericToBit(T numeric) {
114: 	auto bit_len = sizeof(T) + 1;
115: 	auto buffer = make_unsafe_uniq_array_uninitialized<char>(bit_len);
116: 	string_t output_str(buffer.get(), UnsafeNumericCast<uint32_t>(bit_len));
117: 	Bit::NumericToBit(numeric, output_str);
118: 	return output_str.GetString();
119: }
120: 
121: template <class T>
122: T Bit::BitToNumeric(string_t bit) {
123: 	T output;
124: 	Bit::BitToNumeric(bit, output);
125: 	return (output);
126: }
127: 
128: template <class T>
129: void Bit::BitToNumeric(string_t bit, T &output_num) {
130: 	D_ASSERT(bit.GetSize() <= sizeof(T) + 1);
131: 
132: 	output_num = 0;
133: 	auto data = const_data_ptr_cast(bit.GetData());
134: 	auto output = data_ptr_cast(&output_num);
135: 
136: 	idx_t padded_byte_idx = sizeof(T) - bit.GetSize() + 1;
137: 	output[sizeof(T) - 1 - padded_byte_idx] = GetFirstByte(bit);
138: 	for (idx_t idx = padded_byte_idx + 1; idx < sizeof(T); ++idx) {
139: 		output[sizeof(T) - 1 - idx] = data[1 + idx - padded_byte_idx];
140: 	}
141: }
142: 
143: } // namespace duckdb
[end of src/include/duckdb/common/types/bit.hpp]
[start of src/include/duckdb/core_functions/scalar/bit_functions.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/core_functions/scalar/bit_functions.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: // This file is automatically generated by scripts/generate_functions.py
9: // Do not edit this file manually, your changes will be overwritten
10: //===----------------------------------------------------------------------===//
11: 
12: #pragma once
13: 
14: #include "duckdb/function/function_set.hpp"
15: 
16: namespace duckdb {
17: 
18: struct GetBitFun {
19: 	static constexpr const char *Name = "get_bit";
20: 	static constexpr const char *Parameters = "bitstring,index";
21: 	static constexpr const char *Description = "Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0";
22: 	static constexpr const char *Example = "get_bit('0110010'::BIT, 2)";
23: 
24: 	static ScalarFunction GetFunction();
25: };
26: 
27: struct SetBitFun {
28: 	static constexpr const char *Name = "set_bit";
29: 	static constexpr const char *Parameters = "bitstring,index,new_value";
30: 	static constexpr const char *Description = "Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0. Returns a new bitstring";
31: 	static constexpr const char *Example = "set_bit('0110010'::BIT, 2, 0)";
32: 
33: 	static ScalarFunction GetFunction();
34: };
35: 
36: struct BitPositionFun {
37: 	static constexpr const char *Name = "bit_position";
38: 	static constexpr const char *Parameters = "substring,bitstring";
39: 	static constexpr const char *Description = "Returns first starting index of the specified substring within bits, or zero if it is not present. The first (leftmost) bit is indexed 1";
40: 	static constexpr const char *Example = "bit_position('010'::BIT, '1110101'::BIT)";
41: 
42: 	static ScalarFunction GetFunction();
43: };
44: 
45: struct BitStringFun {
46: 	static constexpr const char *Name = "bitstring";
47: 	static constexpr const char *Parameters = "bitstring,length";
48: 	static constexpr const char *Description = "Pads the bitstring until the specified length";
49: 	static constexpr const char *Example = "bitstring('1010'::BIT, 7)";
50: 
51: 	static ScalarFunction GetFunction();
52: };
53: 
54: } // namespace duckdb
[end of src/include/duckdb/core_functions/scalar/bit_functions.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: