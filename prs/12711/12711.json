{
  "repo": "duckdb/duckdb",
  "pull_number": 12711,
  "instance_id": "duckdb__duckdb-12711",
  "issue_numbers": [
    "12702"
  ],
  "base_commit": "1c9b593ebaaa2530b1bd8164848af8b26eee9db7",
  "patch": "diff --git a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\nindex ae6b5ed46fa5..b3115ac9a67a 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n@@ -44,7 +44,7 @@ struct DuckDBPyConnection : public enable_shared_from_this<DuckDBPyConnection> {\n \tshared_ptr<DuckDB> database;\n \tunique_ptr<Connection> connection;\n \tunique_ptr<DuckDBPyRelation> result;\n-\tvector<shared_ptr<DuckDBPyConnection>> cursors;\n+\tvector<weak_ptr<DuckDBPyConnection>> cursors;\n \tunordered_map<string, shared_ptr<Relation>> temporary_views;\n \tstd::mutex py_connection_lock;\n \t//! MemoryFileSystem used to temporarily store file-like objects for reading\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 5702983377bf..b4fd95c1d425 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -1380,7 +1380,12 @@ void DuckDBPyConnection::Close() {\n \ttemporary_views.clear();\n \t// https://peps.python.org/pep-0249/#Connection.close\n \tfor (auto &cur : cursors) {\n-\t\tcur->Close();\n+\t\tauto cursor = cur.lock();\n+\t\tif (!cursor) {\n+\t\t\t// The cursor has already been closed\n+\t\t\tcontinue;\n+\t\t}\n+\t\tcursor->Close();\n \t}\n \tregistered_functions.clear();\n \tcursors.clear();\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_duckdb_connection.py b/tools/pythonpkg/tests/fast/api/test_duckdb_connection.py\nindex c5f8e6375d69..76e9b750b4e8 100644\n--- a/tools/pythonpkg/tests/fast/api/test_duckdb_connection.py\n+++ b/tools/pythonpkg/tests/fast/api/test_duckdb_connection.py\n@@ -69,6 +69,21 @@ def test_cursor(self):\n             # 'tbl' no longer exists\n             duckdb.table(\"tbl\")\n \n+    def test_cursor_lifetime(self):\n+        con = duckdb.connect()\n+\n+        def use_cursors():\n+            cursors = []\n+            for _ in range(10):\n+                cursors.append(con.cursor())\n+\n+            for cursor in cursors:\n+                print(\"closing cursor\")\n+                cursor.close()\n+\n+        use_cursors()\n+        con.close()\n+\n     def test_df(self):\n         ref = [([1, 2, 3],)]\n         duckdb.execute(\"select [1,2,3]\")\n",
  "problem_statement": "Resolve leaking of cursors in the Python interface\nThe current Python interface duplicates the current DuckDBPyConnection when the Cursor-function is invoked. For memory tracking this new DuckDBPyConnection is added to the vector of cursors of the current or \"actual\" DuckDBPyConnection. When the cursor is closed, it will be handled as if the DuckDBPyConnection is closed, it processes all child cursors.\r\n\r\nThis fails because the DuckDBPyConnection was added to the parent cursors vector, and since the \"actual\" DuckDBPyConnection is never closed, the vector grows until going out of memory.\r\n\r\nThis code introduces a parent per DuckDBPyConnection which allows the Cursor-close function to remove itself from the parent's cursors vector.\r\n\r\nFixed #10223\r\n\r\nVirtually zero production code experience with C++, hence it found the cause of the memory leak using heaptrack, this is a working proposal. \n",
  "hints_text": "Thanks for raising this issue, I don't think this is the fix, but the problem is clear\r\n\r\nI believe the \"cursors\" vector in the parent should be of `weak_ptr` instead.\r\nThat makes it so that the parent doesn't have an owning reference, and wont prevent deletion of the cursor anymore.\r\n\r\nIn the parent the `.lock()` on the parent will result in null if the cursor was already cleaned up\nI am also noticing another issue, which we probably want to fix in a separate PR\r\n\r\n`cursor` isn't thread safe.\r\nThe created cursor object *is*, but the `cursor` method itself isn't\r\n\r\nWe should probably create a lock in the connection, to protect the modification of the \"cursors\" vector against race conditions\n> Thanks for raising this issue, I don't think this is the fix, but the problem is clear\r\n\r\nThe reproducible issue was raised in #10223 over six months ago, and since it affects the _entire_ Python community, always, in my opinion it needed more priority than it received. And the least I can do in an open source setting is do an attempt to investigate and fix it. \r\n\r\n> I believe the \"cursors\" vector in the parent should be of `weak_ptr` instead. That makes it so that the parent doesn't have an owning reference, and wont prevent deletion of the cursor anymore.\r\n> \r\n> In the parent the `.lock()` on the parent will result in null if the cursor was already cleaned up\r\n\r\nAs mentioned, not a C++ developer myself but I share your conclusion that it might be able to be solved in a more elegant way after realisng what has caused it. Thanks for reviewing and noticing the thread safety issues. \n> As mentioned, not a C++ developer myself but I share your conclusion that it might be able to be solved in a more elegant way after realisng what has caused it. Thanks for reviewing and noticing the thread safety issues.\r\n\r\nI understand, that is why I spelled out the fix.\r\nI'd be happy to make the changes myself if you don't feel up to the task though \ud83d\udc4d \r\n\r\n> and since it affects the *entire* Python community, always\r\n\r\nI think that's over-exaggerating, this becomes an issue when you create many cursors over a period of time without every closing the main connection.\r\nWe recommend using one cursor per thread, so this should never become an issue.\r\n\r\nThat being said, it is a bug and we should fix it, so thank you for bringing attention to it",
  "created_at": "2024-06-26T10:29:39Z"
}