diff --git a/extension/parquet/column_reader.cpp b/extension/parquet/column_reader.cpp
index 70deb57b08df..26f457f0d7ea 100644
--- a/extension/parquet/column_reader.cpp
+++ b/extension/parquet/column_reader.cpp
@@ -51,6 +51,25 @@ ColumnReader::ColumnReader(ParquetReader &reader, LogicalType type_p, const Sche
 ColumnReader::~ColumnReader() {
 }
 
+template <class T>
+unique_ptr<ColumnReader> CreateDecimalReader(ParquetReader &reader, const LogicalType &type_p,
+                                             const SchemaElement &schema_p, idx_t file_idx_p, idx_t max_define,
+                                             idx_t max_repeat) {
+	switch (type_p.InternalType()) {
+	case PhysicalType::INT16:
+		return make_unique<TemplatedColumnReader<int16_t, TemplatedParquetValueConversion<T>>>(
+		    reader, type_p, schema_p, file_idx_p, max_define, max_repeat);
+	case PhysicalType::INT32:
+		return make_unique<TemplatedColumnReader<int32_t, TemplatedParquetValueConversion<T>>>(
+		    reader, type_p, schema_p, file_idx_p, max_define, max_repeat);
+	case PhysicalType::INT64:
+		return make_unique<TemplatedColumnReader<int64_t, TemplatedParquetValueConversion<T>>>(
+		    reader, type_p, schema_p, file_idx_p, max_define, max_repeat);
+	default:
+		throw NotImplementedException("Unimplemented internal type for CreateDecimalReader");
+	}
+}
+
 unique_ptr<ColumnReader> ColumnReader::CreateReader(ParquetReader &reader, const LogicalType &type_p,
                                                     const SchemaElement &schema_p, idx_t file_idx_p, idx_t max_define,
                                                     idx_t max_repeat) {
@@ -69,6 +88,12 @@ unique_ptr<ColumnReader> ColumnReader::CreateReader(ParquetReader &reader, const
 	case LogicalTypeId::UBIGINT:
 		return make_unique<TemplatedColumnReader<uint64_t, TemplatedParquetValueConversion<uint64_t>>>(
 		    reader, type_p, schema_p, file_idx_p, max_define, max_repeat);
+	case LogicalTypeId::TINYINT:
+		return make_unique<TemplatedColumnReader<int8_t, TemplatedParquetValueConversion<int32_t>>>(
+		    reader, type_p, schema_p, file_idx_p, max_define, max_repeat);
+	case LogicalTypeId::SMALLINT:
+		return make_unique<TemplatedColumnReader<int16_t, TemplatedParquetValueConversion<int32_t>>>(
+		    reader, type_p, schema_p, file_idx_p, max_define, max_repeat);
 	case LogicalTypeId::INTEGER:
 		return make_unique<TemplatedColumnReader<int32_t, TemplatedParquetValueConversion<int32_t>>>(
 		    reader, type_p, schema_p, file_idx_p, max_define, max_repeat);
@@ -109,22 +134,30 @@ unique_ptr<ColumnReader> ColumnReader::CreateReader(ParquetReader &reader, const
 		return make_unique<StringColumnReader>(reader, type_p, schema_p, file_idx_p, max_define, max_repeat);
 	case LogicalTypeId::DECIMAL:
 		// we have to figure out what kind of int we need
-		switch (type_p.InternalType()) {
-		case PhysicalType::INT16:
-			return make_unique<DecimalColumnReader<int16_t>>(reader, type_p, schema_p, file_idx_p, max_define,
-			                                                 max_repeat);
-		case PhysicalType::INT32:
-			return make_unique<DecimalColumnReader<int32_t>>(reader, type_p, schema_p, file_idx_p, max_define,
-			                                                 max_repeat);
-		case PhysicalType::INT64:
-			return make_unique<DecimalColumnReader<int64_t>>(reader, type_p, schema_p, file_idx_p, max_define,
-			                                                 max_repeat);
-		case PhysicalType::INT128:
-			return make_unique<DecimalColumnReader<hugeint_t>>(reader, type_p, schema_p, file_idx_p, max_define,
-			                                                   max_repeat);
-
+		switch (schema_p.type) {
+		case Type::INT32:
+			return CreateDecimalReader<int32_t>(reader, type_p, schema_p, file_idx_p, max_define, max_repeat);
+		case Type::INT64:
+			return CreateDecimalReader<int64_t>(reader, type_p, schema_p, file_idx_p, max_define, max_repeat);
+		case Type::FIXED_LEN_BYTE_ARRAY:
+			switch (type_p.InternalType()) {
+			case PhysicalType::INT16:
+				return make_unique<DecimalColumnReader<int16_t>>(reader, type_p, schema_p, file_idx_p, max_define,
+				                                                 max_repeat);
+			case PhysicalType::INT32:
+				return make_unique<DecimalColumnReader<int32_t>>(reader, type_p, schema_p, file_idx_p, max_define,
+				                                                 max_repeat);
+			case PhysicalType::INT64:
+				return make_unique<DecimalColumnReader<int64_t>>(reader, type_p, schema_p, file_idx_p, max_define,
+				                                                 max_repeat);
+			case PhysicalType::INT128:
+				return make_unique<DecimalColumnReader<hugeint_t>>(reader, type_p, schema_p, file_idx_p, max_define,
+				                                                   max_repeat);
+			default:
+				throw InternalException("Unrecognized type for Decimal");
+			}
 		default:
-			break;
+			throw NotImplementedException("Unrecognized type for Decimal");
 		}
 		break;
 	default:
diff --git a/extension/parquet/parquet_reader.cpp b/extension/parquet/parquet_reader.cpp
index ab3847f8f847..52c9dda92c2c 100644
--- a/extension/parquet/parquet_reader.cpp
+++ b/extension/parquet/parquet_reader.cpp
@@ -89,70 +89,131 @@ static shared_ptr<ParquetFileMetadataCache> LoadMetadata(Allocator &allocator, F
 LogicalType ParquetReader::DeriveLogicalType(const SchemaElement &s_ele) {
 	// inner node
 	D_ASSERT(s_ele.__isset.type && s_ele.num_children == 0);
-	switch (s_ele.type) {
-	case Type::BOOLEAN:
-		return LogicalType::BOOLEAN;
-	case Type::INT32:
-		if (s_ele.__isset.converted_type) {
-			switch (s_ele.converted_type) {
-			case ConvertedType::DATE:
-				return LogicalType::DATE;
-			case ConvertedType::UINT_8:
+	if (s_ele.type == Type::FIXED_LEN_BYTE_ARRAY && !s_ele.__isset.type_length) {
+		throw IOException("FIXED_LEN_BYTE_ARRAY requires length to be set");
+	}
+	if (s_ele.__isset.converted_type) {
+		switch (s_ele.converted_type) {
+		case ConvertedType::INT_8:
+			if (s_ele.type == Type::INT32) {
+				return LogicalType::TINYINT;
+			} else {
+				throw IOException("INT8 converted type can only be set for value of Type::INT32");
+			}
+		case ConvertedType::INT_16:
+			if (s_ele.type == Type::INT32) {
+				return LogicalType::SMALLINT;
+			} else {
+				throw IOException("INT16 converted type can only be set for value of Type::INT32");
+			}
+		case ConvertedType::INT_32:
+			if (s_ele.type == Type::INT32) {
+				return LogicalType::INTEGER;
+			} else {
+				throw IOException("INT32 converted type can only be set for value of Type::INT32");
+			}
+		case ConvertedType::INT_64:
+			if (s_ele.type == Type::INT64) {
+				return LogicalType::BIGINT;
+			} else {
+				throw IOException("INT64 converted type can only be set for value of Type::INT32");
+			}
+		case ConvertedType::UINT_8:
+			if (s_ele.type == Type::INT32) {
 				return LogicalType::UTINYINT;
-			case ConvertedType::UINT_16:
+			} else {
+				throw IOException("UINT8 converted type can only be set for value of Type::INT32");
+			}
+		case ConvertedType::UINT_16:
+			if (s_ele.type == Type::INT32) {
 				return LogicalType::USMALLINT;
-			default:
-				return LogicalType::INTEGER;
+			} else {
+				throw IOException("UINT16 converted type can only be set for value of Type::INT32");
 			}
-		}
-		return LogicalType::INTEGER;
-	case Type::INT64:
-		if (s_ele.__isset.converted_type) {
-			switch (s_ele.converted_type) {
-			case ConvertedType::TIMESTAMP_MICROS:
-			case ConvertedType::TIMESTAMP_MILLIS:
-				return LogicalType::TIMESTAMP;
-			case ConvertedType::UINT_32:
+		case ConvertedType::UINT_32:
+			if (s_ele.type == Type::INT32) {
 				return LogicalType::UINTEGER;
-			case ConvertedType::UINT_64:
+			} else {
+				throw IOException("UINT32 converted type can only be set for value of Type::INT32");
+			}
+		case ConvertedType::UINT_64:
+			if (s_ele.type == Type::INT64) {
 				return LogicalType::UBIGINT;
+			} else {
+				throw IOException("UINT64 converted type can only be set for value of Type::INT64");
+			}
+		case ConvertedType::DATE:
+			if (s_ele.type == Type::INT32) {
+				return LogicalType::DATE;
+			} else {
+				throw IOException("DATE converted type can only be set for value of Type::INT32");
+			}
+		case ConvertedType::TIMESTAMP_MICROS:
+		case ConvertedType::TIMESTAMP_MILLIS:
+			if (s_ele.type == Type::INT64) {
+				return LogicalType::TIMESTAMP;
+			} else {
+				throw IOException("TIMESTAMP converted type can only be set for value of Type::INT64");
+			}
+		case ConvertedType::DECIMAL:
+			if (!s_ele.__isset.precision || !s_ele.__isset.scale) {
+				throw IOException("DECIMAL requires a length and scale specifier!");
+			}
+			switch (s_ele.type) {
+			case Type::BYTE_ARRAY:
+			case Type::FIXED_LEN_BYTE_ARRAY:
+			case Type::INT32:
+			case Type::INT64:
+				return LogicalType::DECIMAL(s_ele.precision, s_ele.scale);
 			default:
-				return LogicalType::BIGINT;
+				throw IOException(
+				    "DECIMAL converted type can only be set for value of Type::(FIXED_LEN_)BYTE_ARRAY/INT32/INT64");
 			}
-		}
-		return LogicalType::BIGINT;
-
-	case Type::INT96: // always a timestamp it would seem
-		return LogicalType::TIMESTAMP;
-	case Type::FLOAT:
-		return LogicalType::FLOAT;
-	case Type::DOUBLE:
-		return LogicalType::DOUBLE;
-	case Type::BYTE_ARRAY:
-	case Type::FIXED_LEN_BYTE_ARRAY:
-		if (s_ele.type == Type::FIXED_LEN_BYTE_ARRAY && !s_ele.__isset.type_length) {
-			return LogicalType::INVALID;
-		}
-		if (s_ele.__isset.converted_type) {
-			switch (s_ele.converted_type) {
-			case ConvertedType::DECIMAL:
-				if (s_ele.type == Type::FIXED_LEN_BYTE_ARRAY && s_ele.__isset.scale && s_ele.__isset.type_length) {
-					return LogicalType::DECIMAL(s_ele.precision, s_ele.scale);
-				}
-				return LogicalType::INVALID;
-
-			case ConvertedType::UTF8:
+		case ConvertedType::UTF8:
+			switch (s_ele.type) {
+			case Type::BYTE_ARRAY:
+			case Type::FIXED_LEN_BYTE_ARRAY:
 				return LogicalType::VARCHAR;
 			default:
-				return LogicalType::BLOB;
+				throw IOException("UTF8 converted type can only be set for Type::(FIXED_LEN_)BYTE_ARRAY");
 			}
+		case ConvertedType::MAP:
+		case ConvertedType::MAP_KEY_VALUE:
+		case ConvertedType::LIST:
+		case ConvertedType::ENUM:
+		case ConvertedType::TIME_MILLIS:
+		case ConvertedType::TIME_MICROS:
+		case ConvertedType::JSON:
+		case ConvertedType::BSON:
+		case ConvertedType::INTERVAL:
+		default:
+			throw IOException("Unsupported converted type");
 		}
-		if (parquet_options.binary_as_string) {
-			return LogicalType::VARCHAR;
+	} else {
+		// no converted type set
+		// use default type for each physical type
+		switch (s_ele.type) {
+		case Type::BOOLEAN:
+			return LogicalType::BOOLEAN;
+		case Type::INT32:
+			return LogicalType::INTEGER;
+		case Type::INT64:
+			return LogicalType::BIGINT;
+		case Type::INT96: // always a timestamp it would seem
+			return LogicalType::TIMESTAMP;
+		case Type::FLOAT:
+			return LogicalType::FLOAT;
+		case Type::DOUBLE:
+			return LogicalType::DOUBLE;
+		case Type::BYTE_ARRAY:
+		case Type::FIXED_LEN_BYTE_ARRAY:
+			if (parquet_options.binary_as_string) {
+				return LogicalType::VARCHAR;
+			}
+			return LogicalType::BLOB;
+		default:
+			return LogicalType::INVALID;
 		}
-		return LogicalType::BLOB;
-	default:
-		return LogicalType::INVALID;
 	}
 }
 
@@ -461,6 +522,12 @@ static void FilterOperationSwitch(Vector &v, Value &constant, parquet_filter_t &
 	case LogicalTypeId::UBIGINT:
 		TemplatedFilterOperation<uint64_t, OP>(v, constant.value_.ubigint, filter_mask, count);
 		break;
+	case LogicalTypeId::TINYINT:
+		TemplatedFilterOperation<int8_t, OP>(v, constant.value_.tinyint, filter_mask, count);
+		break;
+	case LogicalTypeId::SMALLINT:
+		TemplatedFilterOperation<int16_t, OP>(v, constant.value_.smallint, filter_mask, count);
+		break;
 	case LogicalTypeId::INTEGER:
 		TemplatedFilterOperation<int32_t, OP>(v, constant.value_.integer, filter_mask, count);
 		break;
diff --git a/extension/parquet/parquet_writer.cpp b/extension/parquet/parquet_writer.cpp
index 75aa18b3bb58..7f6ce5a8ea56 100644
--- a/extension/parquet/parquet_writer.cpp
+++ b/extension/parquet/parquet_writer.cpp
@@ -11,6 +11,7 @@
 #include "duckdb/common/file_system.hpp"
 #include "duckdb/common/string_util.hpp"
 #include "duckdb/common/types/date.hpp"
+#include "duckdb/common/types/hugeint.hpp"
 #include "duckdb/common/types/time.hpp"
 #include "duckdb/common/types/timestamp.hpp"
 #include "duckdb/common/serializer/buffered_file_writer.hpp"
@@ -69,6 +70,7 @@ static Type::type DuckDBTypeToParquetType(const LogicalType &duckdb_type) {
 	case LogicalTypeId::TINYINT:
 	case LogicalTypeId::SMALLINT:
 	case LogicalTypeId::INTEGER:
+	case LogicalTypeId::DATE:
 		return Type::INT32;
 	case LogicalTypeId::BIGINT:
 		return Type::INT64;
@@ -76,13 +78,22 @@ static Type::type DuckDBTypeToParquetType(const LogicalType &duckdb_type) {
 		return Type::FLOAT;
 	case LogicalTypeId::DECIMAL: // for now...
 	case LogicalTypeId::DOUBLE:
+	case LogicalTypeId::HUGEINT:
 		return Type::DOUBLE;
 	case LogicalTypeId::VARCHAR:
 	case LogicalTypeId::BLOB:
 		return Type::BYTE_ARRAY;
-	case LogicalTypeId::DATE:
 	case LogicalTypeId::TIMESTAMP:
-		return Type::INT96;
+	case LogicalTypeId::TIMESTAMP_MS:
+	case LogicalTypeId::TIMESTAMP_NS:
+	case LogicalTypeId::TIMESTAMP_SEC:
+		return Type::INT64;
+	case LogicalTypeId::UTINYINT:
+	case LogicalTypeId::USMALLINT:
+	case LogicalTypeId::UINTEGER:
+		return Type::INT32;
+	case LogicalTypeId::UBIGINT:
+		return Type::INT64;
 	default:
 		throw NotImplementedException(duckdb_type.ToString());
 	}
@@ -90,9 +101,44 @@ static Type::type DuckDBTypeToParquetType(const LogicalType &duckdb_type) {
 
 static bool DuckDBTypeToConvertedType(const LogicalType &duckdb_type, ConvertedType::type &result) {
 	switch (duckdb_type.id()) {
+	case LogicalTypeId::TINYINT:
+		result = ConvertedType::INT_8;
+		return true;
+	case LogicalTypeId::SMALLINT:
+		result = ConvertedType::INT_16;
+		return true;
+	case LogicalTypeId::INTEGER:
+		result = ConvertedType::INT_32;
+		return true;
+	case LogicalTypeId::BIGINT:
+		result = ConvertedType::INT_64;
+		return true;
+	case LogicalTypeId::UTINYINT:
+		result = ConvertedType::UINT_8;
+		return true;
+	case LogicalTypeId::USMALLINT:
+		result = ConvertedType::UINT_16;
+		return true;
+	case LogicalTypeId::UINTEGER:
+		result = ConvertedType::UINT_32;
+		return true;
+	case LogicalTypeId::UBIGINT:
+		result = ConvertedType::UINT_64;
+		return true;
+	case LogicalTypeId::DATE:
+		result = ConvertedType::DATE;
+		return true;
 	case LogicalTypeId::VARCHAR:
 		result = ConvertedType::UTF8;
 		return true;
+	case LogicalTypeId::TIMESTAMP:
+	case LogicalTypeId::TIMESTAMP_NS:
+	case LogicalTypeId::TIMESTAMP_SEC:
+		result = ConvertedType::TIMESTAMP_MICROS;
+		return true;
+	case LogicalTypeId::TIMESTAMP_MS:
+		result = ConvertedType::TIMESTAMP_MILLIS;
+		return true;
 	default:
 		return false;
 	}
@@ -122,12 +168,40 @@ static uint8_t GetVarintSize(uint32_t val) {
 	return res;
 }
 
-template <class SRC, class TGT>
+struct ParquetCastOperator {
+	template <class SRC, class TGT>
+	static TGT Operation(SRC input) {
+		return TGT(input);
+	}
+};
+
+struct ParquetTimestampNSOperator {
+	template <class SRC, class TGT>
+	static TGT Operation(SRC input) {
+		return Timestamp::FromEpochNanoSeconds(input).value;
+	}
+};
+
+struct ParquetTimestampSOperator {
+	template <class SRC, class TGT>
+	static TGT Operation(SRC input) {
+		return Timestamp::FromEpochSeconds(input).value;
+	}
+};
+
+struct ParquetHugeintOperator {
+	template <class SRC, class TGT>
+	static TGT Operation(SRC input) {
+		return Hugeint::Cast<double>(input);
+	}
+};
+
+template <class SRC, class TGT, class OP = ParquetCastOperator>
 static void TemplatedWritePlain(Vector &col, idx_t length, ValidityMask &mask, Serializer &ser) {
 	auto *ptr = FlatVector::GetData<SRC>(col);
 	for (idx_t r = 0; r < length; r++) {
 		if (mask.RowIsValid(r)) {
-			ser.Write<TGT>((TGT)ptr[r]);
+			ser.Write<TGT>(OP::template Operation<SRC, TGT>(ptr[r]));
 		}
 	}
 }
@@ -273,11 +347,38 @@ void ParquetWriter::Flush(ChunkCollection &buffer) {
 				TemplatedWritePlain<int16_t, int32_t>(input_column, input.size(), mask, temp_writer);
 				break;
 			case LogicalTypeId::INTEGER:
+			case LogicalTypeId::DATE:
 				TemplatedWritePlain<int32_t, int32_t>(input_column, input.size(), mask, temp_writer);
 				break;
 			case LogicalTypeId::BIGINT:
+			case LogicalTypeId::TIMESTAMP:
+			case LogicalTypeId::TIMESTAMP_MS:
 				TemplatedWritePlain<int64_t, int64_t>(input_column, input.size(), mask, temp_writer);
 				break;
+			case LogicalTypeId::HUGEINT:
+				TemplatedWritePlain<hugeint_t, double, ParquetHugeintOperator>(input_column, input.size(), mask,
+				                                                               temp_writer);
+				break;
+			case LogicalTypeId::TIMESTAMP_NS:
+				TemplatedWritePlain<int64_t, int64_t, ParquetTimestampNSOperator>(input_column, input.size(), mask,
+				                                                                  temp_writer);
+				break;
+			case LogicalTypeId::TIMESTAMP_SEC:
+				TemplatedWritePlain<int64_t, int64_t, ParquetTimestampSOperator>(input_column, input.size(), mask,
+				                                                                 temp_writer);
+				break;
+			case LogicalTypeId::UTINYINT:
+				TemplatedWritePlain<uint8_t, int32_t>(input_column, input.size(), mask, temp_writer);
+				break;
+			case LogicalTypeId::USMALLINT:
+				TemplatedWritePlain<uint16_t, int32_t>(input_column, input.size(), mask, temp_writer);
+				break;
+			case LogicalTypeId::UINTEGER:
+				TemplatedWritePlain<uint32_t, uint32_t>(input_column, input.size(), mask, temp_writer);
+				break;
+			case LogicalTypeId::UBIGINT:
+				TemplatedWritePlain<uint64_t, uint64_t>(input_column, input.size(), mask, temp_writer);
+				break;
 			case LogicalTypeId::FLOAT:
 				TemplatedWritePlain<float, float>(input_column, input.size(), mask, temp_writer);
 				break;
@@ -291,25 +392,6 @@ void ParquetWriter::Flush(ChunkCollection &buffer) {
 			case LogicalTypeId::DOUBLE:
 				TemplatedWritePlain<double, double>(input_column, input.size(), mask, temp_writer);
 				break;
-			case LogicalTypeId::DATE: {
-				auto *ptr = FlatVector::GetData<date_t>(input_column);
-				for (idx_t r = 0; r < input.size(); r++) {
-					if (mask.RowIsValid(r)) {
-						auto ts = Timestamp::FromDatetime(ptr[r], dtime_t(0));
-						temp_writer.Write<Int96>(TimestampToImpalaTimestamp(ts));
-					}
-				}
-				break;
-			}
-			case LogicalTypeId::TIMESTAMP: {
-				auto *ptr = FlatVector::GetData<timestamp_t>(input_column);
-				for (idx_t r = 0; r < input.size(); r++) {
-					if (mask.RowIsValid(r)) {
-						temp_writer.Write<Int96>(TimestampToImpalaTimestamp(ptr[r]));
-					}
-				}
-				break;
-			}
 			case LogicalTypeId::BLOB:
 			case LogicalTypeId::VARCHAR: {
 				auto *ptr = FlatVector::GetData<string_t>(input_column);
