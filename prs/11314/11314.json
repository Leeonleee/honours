{
  "repo": "duckdb/duckdb",
  "pull_number": 11314,
  "instance_id": "duckdb__duckdb-11314",
  "issue_numbers": [
    "10695",
    "10695"
  ],
  "base_commit": "9bc963f1a44fbb0248c1c6d11f97b1b22b156b64",
  "patch": "diff --git a/src/parser/transform/expression/transform_function.cpp b/src/parser/transform/expression/transform_function.cpp\nindex 606477fd8f7f..2d2cfef24843 100644\n--- a/src/parser/transform/expression/transform_function.cpp\n+++ b/src/parser/transform/expression/transform_function.cpp\n@@ -298,6 +298,13 @@ unique_ptr<ParsedExpression> Transformer::TransformFuncCall(duckdb_libpgquery::P\n \t\tauto construct_array = make_uniq<OperatorExpression>(ExpressionType::ARRAY_CONSTRUCTOR);\n \t\tconstruct_array->children = std::move(children);\n \t\treturn std::move(construct_array);\n+\t} else if (lowercase_name == \"__internal_position_operator\") {\n+\t\tif (children.size() != 2) {\n+\t\t\tthrow ParserException(\"Wrong number of arguments to __internal_position_operator.\");\n+\t\t}\n+\t\t// swap arguments for POSITION(x IN y)\n+\t\tstd::swap(children[0], children[1]);\n+\t\tlowercase_name = \"position\";\n \t} else if (lowercase_name == \"ifnull\") {\n \t\tif (children.size() != 2) {\n \t\t\tthrow ParserException(\"Wrong number of arguments to IFNULL.\");\ndiff --git a/third_party/libpg_query/grammar/statements/select.y b/third_party/libpg_query/grammar/statements/select.y\nindex 0ef3db6b2fcf..de363cab6d53 100644\n--- a/third_party/libpg_query/grammar/statements/select.y\n+++ b/third_party/libpg_query/grammar/statements/select.y\n@@ -2969,8 +2969,8 @@ func_expr_common_subexpr:\n \t\t\t\t}\n \t\t\t| POSITION '(' position_list ')'\n \t\t\t\t{\n-\t\t\t\t\t/* position(A in B) is converted to position(B, A) */\n-\t\t\t\t\t$$ = (PGNode *) makeFuncCall(SystemFuncName(\"position\"), $3, @1);\n+\t\t\t\t\t/* position(A in B) is converted to position_inverse(A, B) */\n+\t\t\t\t\t$$ = (PGNode *) makeFuncCall(SystemFuncName(\"__internal_position_operator\"), $3, @1);\n \t\t\t\t}\n \t\t\t| SUBSTRING '(' substr_list ')'\n \t\t\t\t{\n@@ -3595,7 +3595,7 @@ overlay_placing:\n /* position_list uses b_expr not a_expr to avoid conflict with general IN */\n \n position_list:\n-\t\t\tb_expr IN_P b_expr\t\t\t\t\t\t{ $$ = list_make2($3, $1); }\n+\t\t\tb_expr IN_P b_expr\t\t\t\t\t\t{ $$ = list_make2($1, $3); }\n \t\t\t| /*EMPTY*/\t\t\t\t\t\t\t\t{ $$ = NIL; }\n \t\t;\n \ndiff --git a/third_party/libpg_query/src_backend_parser_gram.cpp b/third_party/libpg_query/src_backend_parser_gram.cpp\nindex bf569d2b5a10..c8ff5ddd3f0f 100644\n--- a/third_party/libpg_query/src_backend_parser_gram.cpp\n+++ b/third_party/libpg_query/src_backend_parser_gram.cpp\n@@ -27535,8 +27535,8 @@ YYLTYPE yylloc;\n   case 1036:\n #line 2971 \"third_party/libpg_query/grammar/statements/select.y\"\n     {\n-\t\t\t\t\t/* position(A in B) is converted to position(B, A) */\n-\t\t\t\t\t(yyval.node) = (PGNode *) makeFuncCall(SystemFuncName(\"position\"), (yyvsp[(3) - (4)].list), (yylsp[(1) - (4)]));\n+\t\t\t\t\t/* position(A in B) is converted to position_inverse(A, B) */\n+\t\t\t\t\t(yyval.node) = (PGNode *) makeFuncCall(SystemFuncName(\"__internal_position_operator\"), (yyvsp[(3) - (4)].list), (yylsp[(1) - (4)]));\n \t\t\t\t;}\n     break;\n \n@@ -28447,7 +28447,7 @@ YYLTYPE yylloc;\n \n   case 1168:\n #line 3598 \"third_party/libpg_query/grammar/statements/select.y\"\n-    { (yyval.list) = list_make2((yyvsp[(3) - (3)].node), (yyvsp[(1) - (3)].node)); ;}\n+    { (yyval.list) = list_make2((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node)); ;}\n     break;\n \n   case 1169:\n",
  "test_patch": "diff --git a/test/sql/parser/position_prepare.test b/test/sql/parser/position_prepare.test\nnew file mode 100644\nindex 000000000000..091ab3958e0e\n--- /dev/null\n+++ b/test/sql/parser/position_prepare.test\n@@ -0,0 +1,14 @@\n+# name: test/sql/parser/position_prepare.test\n+# description: Test prepared statement parameters in POSITION\n+# group: [parser]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+PREPARE v1 AS SELECT POSITION(? in ?)\n+\n+query I\n+EXECUTE v1('e', 'hello world')\n+----\n+2\n",
  "problem_statement": "Wrong result when using POSITION() function with only bind values from JDBC\n### What happens?\r\n\r\nWhen using the `POSITION()` function with only bind value arguments, the result is wrong\r\n\r\n### To Reproduce\r\n\r\n```java\r\nimport java.sql.DriverManager;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\n\r\nimport org.duckdb.DuckDBConnection;\r\n\r\n\r\nDuckDBConnection connection = (DuckDBConnection) DriverManager.getConnection(\"jdbc:duckdb:\");\r\ntry (PreparedStatement s = connection.prepareStatement(\"\"\"\r\n    select\r\n        position(? in ?),\r\n        position(? in 'abc'),\r\n        position('b' in ?),\r\n        position('b' in 'abc')\r\n    \"\"\")) {\r\n    s.setString(1, \"b\");\r\n    s.setString(2, \"abc\");\r\n    s.setString(3, \"b\");\r\n    s.setString(4, \"abc\");\r\n\r\n    try (ResultSet rs = s.executeQuery()) {\r\n        while (rs.next()) {\r\n            System.out.println(rs.getInt(1));\r\n            System.out.println(rs.getInt(2));\r\n            System.out.println(rs.getInt(3));\r\n            System.out.println(rs.getInt(4));\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis prints:\r\n\r\n```\r\n0\r\n2\r\n2\r\n2\r\n```\r\n\r\nBut it should print:\r\n\r\n```\r\n2\r\n2\r\n2\r\n2\r\n```\r\n\r\n### OS:\r\n\r\nMicrosoft Windows [Version 10.0.22631.3007]\r\n\r\n### DuckDB Version:\r\n\r\n0.10.0\r\n\r\n### DuckDB Client:\r\n\r\njdbc\r\n\r\n### Full Name:\r\n\r\nLukas Eder\r\n\r\n### Affiliation:\r\n\r\nData Geekery\r\n\r\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\r\n\r\nI have tested with a nightly build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\nWrong result when using POSITION() function with only bind values from JDBC\n### What happens?\r\n\r\nWhen using the `POSITION()` function with only bind value arguments, the result is wrong\r\n\r\n### To Reproduce\r\n\r\n```java\r\nimport java.sql.DriverManager;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\n\r\nimport org.duckdb.DuckDBConnection;\r\n\r\n\r\nDuckDBConnection connection = (DuckDBConnection) DriverManager.getConnection(\"jdbc:duckdb:\");\r\ntry (PreparedStatement s = connection.prepareStatement(\"\"\"\r\n    select\r\n        position(? in ?),\r\n        position(? in 'abc'),\r\n        position('b' in ?),\r\n        position('b' in 'abc')\r\n    \"\"\")) {\r\n    s.setString(1, \"b\");\r\n    s.setString(2, \"abc\");\r\n    s.setString(3, \"b\");\r\n    s.setString(4, \"abc\");\r\n\r\n    try (ResultSet rs = s.executeQuery()) {\r\n        while (rs.next()) {\r\n            System.out.println(rs.getInt(1));\r\n            System.out.println(rs.getInt(2));\r\n            System.out.println(rs.getInt(3));\r\n            System.out.println(rs.getInt(4));\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis prints:\r\n\r\n```\r\n0\r\n2\r\n2\r\n2\r\n```\r\n\r\nBut it should print:\r\n\r\n```\r\n2\r\n2\r\n2\r\n2\r\n```\r\n\r\n### OS:\r\n\r\nMicrosoft Windows [Version 10.0.22631.3007]\r\n\r\n### DuckDB Version:\r\n\r\n0.10.0\r\n\r\n### DuckDB Client:\r\n\r\njdbc\r\n\r\n### Full Name:\r\n\r\nLukas Eder\r\n\r\n### Affiliation:\r\n\r\nData Geekery\r\n\r\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\r\n\r\nI have tested with a nightly build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "I looked at the code, this seems to be a bug. The `position(search_string in string)` function under the hood is `instr(string, search_string)` function ([code_ref](https://github.com/duckdb/duckdb/blob/d79d225fbb1e796ac80d3f15db0a56035f8e0b5c/src/include/duckdb/core_functions/scalar/string_functions.hpp#L147-L166)) ([docs](https://duckdb.org/docs/sql/functions/char.html)), but their parameters are reversed. This leads to the fact that when using `?` place holder in `PreparedStatement`, parameters will not be passed as expected.\r\n@lukaseder In this case I recommend you use the `instr`/`strpos` function instead of `position` until this issue is resolved, or if you still want to use the `position` code that looks like this should work...\r\n\r\n```java\r\nDuckDBConnection connection = (DuckDBConnection) DriverManager.getConnection(\"jdbc:duckdb:\");\r\ntry (PreparedStatement s = connection.prepareStatement(\"select position(? in ?)\")) {\r\n    s.setString(1, \"abc\");\r\n    s.setString(2, \"b\");\r\n    \r\n    try (ResultSet rs = s.executeQuery()) {\r\n        while (rs.next()) {\r\n            System.out.println(rs.getInt(1));\r\n        }\r\n    }\r\n}\r\ncatch (SQLException e) {\r\n    throw new RuntimeException(e);\r\n}\r\n```\r\n@szarnyasg Can you take a look at this problem? I'm willing to discuss and resolve this issue.\nI looked at the code, this seems to be a bug. The `position(search_string in string)` function under the hood is `instr(string, search_string)` function ([code_ref](https://github.com/duckdb/duckdb/blob/d79d225fbb1e796ac80d3f15db0a56035f8e0b5c/src/include/duckdb/core_functions/scalar/string_functions.hpp#L147-L166)) ([docs](https://duckdb.org/docs/sql/functions/char.html)), but their parameters are reversed. This leads to the fact that when using `?` place holder in `PreparedStatement`, parameters will not be passed as expected.\r\n@lukaseder In this case I recommend you use the `instr`/`strpos` function instead of `position` until this issue is resolved, or if you still want to use the `position` code that looks like this should work...\r\n\r\n```java\r\nDuckDBConnection connection = (DuckDBConnection) DriverManager.getConnection(\"jdbc:duckdb:\");\r\ntry (PreparedStatement s = connection.prepareStatement(\"select position(? in ?)\")) {\r\n    s.setString(1, \"abc\");\r\n    s.setString(2, \"b\");\r\n    \r\n    try (ResultSet rs = s.executeQuery()) {\r\n        while (rs.next()) {\r\n            System.out.println(rs.getInt(1));\r\n        }\r\n    }\r\n}\r\ncatch (SQLException e) {\r\n    throw new RuntimeException(e);\r\n}\r\n```\r\n@szarnyasg Can you take a look at this problem? I'm willing to discuss and resolve this issue.",
  "created_at": "2024-03-22T17:36:53Z"
}