{
  "repo": "duckdb/duckdb",
  "pull_number": 12790,
  "instance_id": "duckdb__duckdb-12790",
  "issue_numbers": [
    "11404"
  ],
  "base_commit": "6660e89bb90ab799dadbf424cac2a7a02eb09179",
  "patch": "diff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp\nindex 15986fc487e9..95e48495f5cf 100644\n--- a/src/include/duckdb/main/config.hpp\n+++ b/src/include/duckdb/main/config.hpp\n@@ -228,7 +228,7 @@ struct DBConfigOptions {\n \t//! The set of user-provided options\n \tcase_insensitive_map_t<Value> user_options;\n \t//! The set of unrecognized (other) options\n-\tunordered_map<string, Value> unrecognized_options;\n+\tcase_insensitive_map_t<Value> unrecognized_options;\n \t//! Whether or not the configuration settings can be altered\n \tbool lock_configuration = false;\n \t//! Whether to print bindings when printing the plan (debug mode only)\ndiff --git a/src/include/duckdb/main/database.hpp b/src/include/duckdb/main/database.hpp\nindex b7d6be0890da..222a36c0511c 100644\n--- a/src/include/duckdb/main/database.hpp\n+++ b/src/include/duckdb/main/database.hpp\n@@ -76,6 +76,7 @@ class DatabaseInstance : public enable_shared_from_this<DatabaseInstance> {\n \n private:\n \tvoid Initialize(const char *path, DBConfig *config);\n+\tvoid LoadExtensionSettings();\n \tvoid CreateMainDatabase();\n \n \tvoid Configure(DBConfig &config, const char *path);\ndiff --git a/src/include/duckdb/main/extension_helper.hpp b/src/include/duckdb/main/extension_helper.hpp\nindex d625f8698daa..4658357293df 100644\n--- a/src/include/duckdb/main/extension_helper.hpp\n+++ b/src/include/duckdb/main/extension_helper.hpp\n@@ -14,8 +14,6 @@\n \n #include <string>\n \n-#include <string>\n-\n namespace duckdb {\n \n class DuckDB;\n@@ -104,6 +102,7 @@ class ExtensionHelper {\n \tstatic void AutoLoadExtension(DatabaseInstance &db, const string &extension_name);\n \n \t//! Autoload an extension (depending on config, potentially a nop. Returns false on failure)\n+\tDUCKDB_API static bool TryAutoLoadExtension(DatabaseInstance &db, const string &extension_name) noexcept;\n \tDUCKDB_API static bool TryAutoLoadExtension(ClientContext &context, const string &extension_name) noexcept;\n \n \t//! Update all extensions, return a vector of extension names that were updated;\ndiff --git a/src/main/database.cpp b/src/main/database.cpp\nindex 3f22d29e26ab..0d13aece47f7 100644\n--- a/src/main/database.cpp\n+++ b/src/main/database.cpp\n@@ -202,13 +202,60 @@ void DatabaseInstance::CreateMainDatabase() {\n \tinitial_database->Initialize();\n }\n \n-void ThrowExtensionSetUnrecognizedOptions(const unordered_map<string, Value> &unrecognized_options) {\n-\tauto unrecognized_options_iter = unrecognized_options.begin();\n-\tstring unrecognized_option_keys = unrecognized_options_iter->first;\n-\twhile (++unrecognized_options_iter != unrecognized_options.end()) {\n-\t\tunrecognized_option_keys = \",\" + unrecognized_options_iter->first;\n+static void ThrowExtensionSetUnrecognizedOptions(const case_insensitive_map_t<Value> &unrecognized_options) {\n+\tD_ASSERT(!unrecognized_options.empty());\n+\n+\tvector<string> options;\n+\tfor (auto &kv : unrecognized_options) {\n+\t\toptions.push_back(kv.first);\n+\t}\n+\tauto concatenated = StringUtil::Join(options, \", \");\n+\tthrow InvalidInputException(\"The following options were not recognized: \" + concatenated);\n+}\n+\n+void DatabaseInstance::LoadExtensionSettings() {\n+\tauto &unrecognized_options = config.options.unrecognized_options;\n+\n+\tif (config.options.autoload_known_extensions) {\n+\t\tif (unrecognized_options.empty()) {\n+\t\t\t// Nothing to do\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tConnection con(*this);\n+\t\tcon.BeginTransaction();\n+\n+\t\tvector<string> extension_options;\n+\t\tfor (auto &option : unrecognized_options) {\n+\t\t\tauto &name = option.first;\n+\t\t\tauto &value = option.second;\n+\n+\t\t\tauto extension_name = ExtensionHelper::FindExtensionInEntries(name, EXTENSION_SETTINGS);\n+\t\t\tif (extension_name.empty()) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (!ExtensionHelper::TryAutoLoadExtension(*this, extension_name)) {\n+\t\t\t\tthrow InvalidInputException(\n+\t\t\t\t    \"To set the %s setting, the %s extension needs to be loaded. But it could not be autoloaded.\", name,\n+\t\t\t\t    extension_name);\n+\t\t\t}\n+\t\t\tauto it = config.extension_parameters.find(name);\n+\t\t\tif (it == config.extension_parameters.end()) {\n+\t\t\t\tthrow InternalException(\"Extension %s did not provide the '%s' config setting\", extension_name, name);\n+\t\t\t}\n+\t\t\tauto &context = *con.context;\n+\t\t\tPhysicalSet::SetExtensionVariable(context, it->second, name, SetScope::GLOBAL, value);\n+\t\t\textension_options.push_back(name);\n+\t\t}\n+\n+\t\tfor (auto &option : extension_options) {\n+\t\t\tunrecognized_options.erase(option);\n+\t\t}\n+\t\tcon.Commit();\n+\t}\n+\tif (!unrecognized_options.empty()) {\n+\t\tThrowExtensionSetUnrecognizedOptions(unrecognized_options);\n \t}\n-\tthrow InvalidInputException(\"Unrecognized configuration property \\\"%s\\\"\", unrecognized_option_keys);\n }\n \n void DatabaseInstance::Initialize(const char *database_path, DBConfig *user_config) {\n@@ -254,9 +301,7 @@ void DatabaseInstance::Initialize(const char *database_path, DBConfig *user_conf\n \t\tExtensionHelper::LoadExternalExtension(*this, *config.file_system, config.options.database_type);\n \t}\n \n-\tif (!config.options.unrecognized_options.empty()) {\n-\t\tThrowExtensionSetUnrecognizedOptions(config.options.unrecognized_options);\n-\t}\n+\tLoadExtensionSettings();\n \n \tif (!db_manager->HasDefaultDatabase()) {\n \t\tCreateMainDatabase();\ndiff --git a/src/main/extension/extension_helper.cpp b/src/main/extension/extension_helper.cpp\nindex d844c41f734e..17b7ccda4346 100644\n--- a/src/main/extension/extension_helper.cpp\n+++ b/src/main/extension/extension_helper.cpp\n@@ -220,6 +220,25 @@ bool ExtensionHelper::TryAutoLoadExtension(ClientContext &context, const string\n \t}\n }\n \n+bool ExtensionHelper::TryAutoLoadExtension(DatabaseInstance &instance, const string &extension_name) noexcept {\n+\tif (instance.ExtensionIsLoaded(extension_name)) {\n+\t\treturn true;\n+\t}\n+\tauto &dbconfig = DBConfig::GetConfig(instance);\n+\ttry {\n+\t\tauto &fs = FileSystem::GetFileSystem(instance);\n+\t\tif (dbconfig.options.autoinstall_known_extensions) {\n+\t\t\tauto autoinstall_repo =\n+\t\t\t    ExtensionRepository::GetRepositoryByUrl(dbconfig.options.autoinstall_extension_repo);\n+\t\t\tExtensionHelper::InstallExtension(dbconfig, fs, extension_name, false, autoinstall_repo, false);\n+\t\t}\n+\t\tExtensionHelper::LoadExternalExtension(instance, fs, extension_name);\n+\t\treturn true;\n+\t} catch (...) {\n+\t\treturn false;\n+\t}\n+}\n+\n static ExtensionUpdateResult UpdateExtensionInternal(ClientContext &context, DatabaseInstance &db, FileSystem &fs,\n                                                      const string &full_extension_path, const string &extension_name) {\n \tExtensionUpdateResult result;\n",
  "test_patch": "diff --git a/test/api/CMakeLists.txt b/test/api/CMakeLists.txt\nindex 49cbd7aa7353..a8fe73c493c3 100644\n--- a/test/api/CMakeLists.txt\n+++ b/test/api/CMakeLists.txt\n@@ -8,6 +8,7 @@ set(TEST_API_OBJECTS\n     test_api.cpp\n     test_config.cpp\n     test_custom_allocator.cpp\n+    test_extension_setting_autoload.cpp\n     test_instance_cache.cpp\n     test_results.cpp\n     test_reset.cpp\ndiff --git a/test/api/capi/test_capi.cpp b/test/api/capi/test_capi.cpp\nindex ae884be3145a..801b0d229b6b 100644\n--- a/test/api/capi/test_capi.cpp\n+++ b/test/api/capi/test_capi.cpp\n@@ -567,7 +567,7 @@ TEST_CASE(\"Test C API config\", \"[capi]\") {\n \tREQUIRE(duckdb_set_config(config, \"aaaa_invalidoption\", \"read_only\") == DuckDBSuccess);\n \tREQUIRE(((DBConfig *)config)->options.unrecognized_options[\"aaaa_invalidoption\"] == \"read_only\");\n \tREQUIRE(duckdb_open_ext(dbdir.c_str(), &db, config, &error) == DuckDBError);\n-\tREQUIRE_THAT(error, Catch::Matchers::Contains(\"Unrecognized configuration property\"));\n+\tREQUIRE_THAT(error, Catch::Matchers::Contains(\"The following options were not recognized\"));\n \tduckdb_free(error);\n \n \t// we can destroy the config right after duckdb_open\ndiff --git a/test/api/test_extension_setting_autoload.cpp b/test/api/test_extension_setting_autoload.cpp\nnew file mode 100644\nindex 000000000000..add13fc929b8\n--- /dev/null\n+++ b/test/api/test_extension_setting_autoload.cpp\n@@ -0,0 +1,31 @@\n+#include \"catch.hpp\"\n+#include \"test_helpers.hpp\"\n+\n+#include <iostream>\n+#include <map>\n+#include <set>\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+TEST_CASE(\"Test autoload of extension settings\", \"[api]\") {\n+\tDBConfig config;\n+\tconfig.SetOptionByName(\"timezone\", \"America/Los_Angeles\");\n+\n+\tconfig.options.allow_unsigned_extensions = true;\n+\tconfig.options.autoload_known_extensions = true;\n+\tauto env_var = std::getenv(\"LOCAL_EXTENSION_REPO\");\n+\tif (!env_var) {\n+\t\treturn;\n+\t}\n+\tconfig.options.autoinstall_extension_repo = std::string(env_var);\n+\tREQUIRE(config.options.unrecognized_options.count(\"timezone\"));\n+\n+\t// Create a connection\n+\tduckdb::unique_ptr<DuckDB> db;\n+\tREQUIRE_NOTHROW(db = make_uniq<DuckDB>(nullptr, &config));\n+\tConnection con(*db);\n+\n+\tauto res = con.Query(\"select current_setting('timezone')\");\n+\tREQUIRE(CHECK_COLUMN(res, 0, {Value(\"America/Los_Angeles\")}));\n+}\ndiff --git a/tools/pythonpkg/tests/fast/api/test_config.py b/tools/pythonpkg/tests/fast/api/test_config.py\nindex d7963c6b9df4..b9772297163a 100644\n--- a/tools/pythonpkg/tests/fast/api/test_config.py\n+++ b/tools/pythonpkg/tests/fast/api/test_config.py\n@@ -4,6 +4,7 @@\n import numpy\n import pytest\n import re\n+import os\n from conftest import NumpyPandas, ArrowPandas\n \n \n@@ -45,6 +46,13 @@ def test_external_access(self, duckdb_cursor, pandas):\n             query_failed = True\n         assert query_failed == True\n \n+    def test_extension_setting(self):\n+        repository = os.environ.get('LOCAL_EXTENSION_REPO')\n+        if not repository:\n+            return\n+        con = duckdb.connect(config={\"TimeZone\": \"UTC\", 'autoinstall_extension_repository': repository})\n+        assert 'UTC' == con.sql(\"select current_setting('TimeZone')\").fetchone()[0]\n+\n     def test_unrecognized_option(self, duckdb_cursor):\n         success = True\n         try:\n",
  "problem_statement": "Error setting config `TimeZone` with Python client on `connect`\n### What happens?\n\nTrying to set `TimeZone` with Python client with `connect()` by passing a config dictionary causes `InvalidInputException`;\r\n\r\nAFAIK from docs ICU extension is loaded by default on Python and reference to configuration options in Python docs contains `TimeZone` as a configuration option;\r\nhttps://duckdb.org/docs/api/python/overview.html#configuration\r\nhttps://duckdb.org/docs/configuration/overview#configuration-reference\r\n\r\n```python\r\nimport duckdb\r\nconn.sql(\"select * from duckdb_extensions() where extension_name = 'icu'\").show()\r\n```\r\n\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 extension_name \u2502 loaded  \u2502 installed \u2502 install_path \u2502                           description                            \u2502  aliases  \u2502\r\n\u2502    varchar     \u2502 boolean \u2502  boolean  \u2502   varchar    \u2502                             varchar                              \u2502 varchar[] \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 icu            \u2502 true    \u2502 true      \u2502 (BUILT-IN)   \u2502 Adds support for time zones and collations using the ICU library \u2502 []        \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nSetting it with `SET ...` directive seems to work fine;\r\n```python\r\nimport duckdb\r\n\r\nconn = duckdb.connect()\r\nconn.sql(\"select current_timestamp\").show()\r\nconn.sql(\"set TimeZone = 'UTC'\")\r\nconn.sql(\"select current_timestamp\").show()\r\n```\r\n\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502     current_timestamp      \u2502\r\n\u2502  timestamp with time zone  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 2024-03-28 16:41:07.292+03 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502     current_timestamp      \u2502\r\n\u2502  timestamp with time zone  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 2024-03-28 13:41:07.293+00 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\n\n### To Reproduce\n\n```python\r\nimport duckdb\r\nconn = duckdb.connect(config={\"TimeZone\" : \"UTC\"})\r\n```\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"repro.py\", line 3, in <module>\r\n    conn = duckdb.connect(config={\"TimeZone\" : \"UTC\"})\r\nduckdb.duckdb.InvalidInputException: Invalid Input Error: Unrecognized configuration property \"TimeZone\"\r\n```\r\n\n\n### OS:\n\nmacOS\n\n### DuckDB Version:\n\n0.10.1\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nSelman Kayrancioglu\n\n### Affiliation:\n\nPeak\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a release build (and could not test with a nightly build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "I suspect the problem is just that the ICU extension has not been loaded yet. It is what defines the `Calendar` and `TimeZone` settings.\nYea Gabor ran into this issue about a week ago actually and I suspect as much, I'll have to see if we can delay setting these settings until the extension is loaded.\r\n\r\nIt's a little difficult because some settings have to be set before the database is started.\r\nSince these are `connect` options, it also makes some sense to say these only accept options that can be set on Database creation.\r\n\r\nYou have the option to set the other settings after startup",
  "created_at": "2024-07-01T15:57:36Z"
}