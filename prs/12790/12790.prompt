You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Error setting config `TimeZone` with Python client on `connect`
### What happens?

Trying to set `TimeZone` with Python client with `connect()` by passing a config dictionary causes `InvalidInputException`;

AFAIK from docs ICU extension is loaded by default on Python and reference to configuration options in Python docs contains `TimeZone` as a configuration option;
https://duckdb.org/docs/api/python/overview.html#configuration
https://duckdb.org/docs/configuration/overview#configuration-reference

```python
import duckdb
conn.sql("select * from duckdb_extensions() where extension_name = 'icu'").show()
```

```
┌────────────────┬─────────┬───────────┬──────────────┬──────────────────────────────────────────────────────────────────┬───────────┐
│ extension_name │ loaded  │ installed │ install_path │                           description                            │  aliases  │
│    varchar     │ boolean │  boolean  │   varchar    │                             varchar                              │ varchar[] │
├────────────────┼─────────┼───────────┼──────────────┼──────────────────────────────────────────────────────────────────┼───────────┤
│ icu            │ true    │ true      │ (BUILT-IN)   │ Adds support for time zones and collations using the ICU library │ []        │
└────────────────┴─────────┴───────────┴──────────────┴──────────────────────────────────────────────────────────────────┴───────────┘
```

Setting it with `SET ...` directive seems to work fine;
```python
import duckdb

conn = duckdb.connect()
conn.sql("select current_timestamp").show()
conn.sql("set TimeZone = 'UTC'")
conn.sql("select current_timestamp").show()
```

```
┌────────────────────────────┐
│     current_timestamp      │
│  timestamp with time zone  │
├────────────────────────────┤
│ 2024-03-28 16:41:07.292+03 │
└────────────────────────────┘

┌────────────────────────────┐
│     current_timestamp      │
│  timestamp with time zone  │
├────────────────────────────┤
│ 2024-03-28 13:41:07.293+00 │
└────────────────────────────┘
```


### To Reproduce

```python
import duckdb
conn = duckdb.connect(config={"TimeZone" : "UTC"})
```

```
Traceback (most recent call last):
  File "repro.py", line 3, in <module>
    conn = duckdb.connect(config={"TimeZone" : "UTC"})
duckdb.duckdb.InvalidInputException: Invalid Input Error: Unrecognized configuration property "TimeZone"
```


### OS:

macOS

### DuckDB Version:

0.10.1

### DuckDB Client:

Python

### Full Name:

Selman Kayrancioglu

### Affiliation:

Peak

### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?

I have tested with a release build (and could not test with a nightly build)

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/include/duckdb/main/config.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/config.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/allocator.hpp"
12: #include "duckdb/common/case_insensitive_map.hpp"
13: #include "duckdb/common/cgroups.hpp"
14: #include "duckdb/common/common.hpp"
15: #include "duckdb/common/encryption_state.hpp"
16: #include "duckdb/common/enums/access_mode.hpp"
17: #include "duckdb/common/enums/compression_type.hpp"
18: #include "duckdb/common/enums/optimizer_type.hpp"
19: #include "duckdb/common/enums/order_type.hpp"
20: #include "duckdb/common/enums/set_scope.hpp"
21: #include "duckdb/common/enums/window_aggregation_mode.hpp"
22: #include "duckdb/common/file_system.hpp"
23: #include "duckdb/common/set.hpp"
24: #include "duckdb/common/types/value.hpp"
25: #include "duckdb/common/vector.hpp"
26: #include "duckdb/common/winapi.hpp"
27: #include "duckdb/function/cast/default_casts.hpp"
28: #include "duckdb/function/replacement_scan.hpp"
29: #include "duckdb/optimizer/optimizer_extension.hpp"
30: #include "duckdb/parser/parsed_data/create_info.hpp"
31: #include "duckdb/parser/parser_extension.hpp"
32: #include "duckdb/planner/operator_extension.hpp"
33: #include "duckdb/storage/compression/bitpacking.hpp"
34: #include "duckdb/main/client_properties.hpp"
35: #include "duckdb/execution/index/index_type_set.hpp"
36: 
37: namespace duckdb {
38: 
39: class BufferManager;
40: class BufferPool;
41: class CastFunctionSet;
42: class CollationBinding;
43: class ClientContext;
44: class ErrorManager;
45: class CompressionFunction;
46: class TableFunctionRef;
47: class OperatorExtension;
48: class StorageExtension;
49: class ExtensionCallback;
50: class SecretManager;
51: class CompressionInfo;
52: class EncryptionUtil;
53: 
54: struct CompressionFunctionSet;
55: struct DBConfig;
56: 
57: enum class CheckpointAbort : uint8_t {
58: 	NO_ABORT = 0,
59: 	DEBUG_ABORT_BEFORE_TRUNCATE = 1,
60: 	DEBUG_ABORT_BEFORE_HEADER = 2,
61: 	DEBUG_ABORT_AFTER_FREE_LIST_WRITE = 3
62: };
63: 
64: typedef void (*set_global_function_t)(DatabaseInstance *db, DBConfig &config, const Value &parameter);
65: typedef void (*set_local_function_t)(ClientContext &context, const Value &parameter);
66: typedef void (*reset_global_function_t)(DatabaseInstance *db, DBConfig &config);
67: typedef void (*reset_local_function_t)(ClientContext &context);
68: typedef Value (*get_setting_function_t)(const ClientContext &context);
69: 
70: struct ConfigurationOption {
71: 	const char *name;
72: 	const char *description;
73: 	LogicalTypeId parameter_type;
74: 	set_global_function_t set_global;
75: 	set_local_function_t set_local;
76: 	reset_global_function_t reset_global;
77: 	reset_local_function_t reset_local;
78: 	get_setting_function_t get_setting;
79: };
80: 
81: typedef void (*set_option_callback_t)(ClientContext &context, SetScope scope, Value &parameter);
82: 
83: struct ExtensionOption {
84: 	// NOLINTNEXTLINE: work around bug in clang-tidy
85: 	ExtensionOption(string description_p, LogicalType type_p, set_option_callback_t set_function_p,
86: 	                Value default_value_p)
87: 	    : description(std::move(description_p)), type(std::move(type_p)), set_function(set_function_p),
88: 	      default_value(std::move(default_value_p)) {
89: 	}
90: 
91: 	string description;
92: 	LogicalType type;
93: 	set_option_callback_t set_function;
94: 	Value default_value;
95: };
96: 
97: class SerializationCompatibility {
98: public:
99: 	static SerializationCompatibility FromString(const string &input);
100: 	static SerializationCompatibility Default();
101: 	static SerializationCompatibility Latest();
102: 
103: public:
104: 	bool Compare(idx_t property_version) const;
105: 
106: public:
107: 	//! The user provided version
108: 	string duckdb_version;
109: 	//! The max version that should be serialized
110: 	idx_t serialization_version;
111: 	//! Whether this was set by a manual SET/PRAGMA or default
112: 	bool manually_set;
113: 
114: protected:
115: 	SerializationCompatibility() = default;
116: };
117: 
118: struct DBConfigOptions {
119: 	//! Database file path. May be empty for in-memory mode
120: 	string database_path;
121: 	//! Database type. If empty, automatically extracted from `database_path`, where a `type:path` syntax is expected
122: 	string database_type;
123: 	//! Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE)
124: 	AccessMode access_mode = AccessMode::AUTOMATIC;
125: 	//! Checkpoint when WAL reaches this size (default: 16MB)
126: 	idx_t checkpoint_wal_size = 1 << 24;
127: 	//! Whether or not to use Direct IO, bypassing operating system buffers
128: 	bool use_direct_io = false;
129: 	//! Whether extensions should be loaded on start-up
130: 	bool load_extensions = true;
131: #ifdef DUCKDB_EXTENSION_AUTOLOAD_DEFAULT
132: 	//! Whether known extensions are allowed to be automatically loaded when a query depends on them
133: 	bool autoload_known_extensions = DUCKDB_EXTENSION_AUTOLOAD_DEFAULT;
134: #else
135: 	bool autoload_known_extensions = false;
136: #endif
137: #ifdef DUCKDB_EXTENSION_AUTOINSTALL_DEFAULT
138: 	//! Whether known extensions are allowed to be automatically installed when a query depends on them
139: 	bool autoinstall_known_extensions = DUCKDB_EXTENSION_AUTOINSTALL_DEFAULT;
140: #else
141: 	bool autoinstall_known_extensions = false;
142: #endif
143: 	//! Override for the default extension repository
144: 	string custom_extension_repo = "";
145: 	//! Override for the default autoload extension repository
146: 	string autoinstall_extension_repo = "";
147: 	//! The maximum memory used by the database system (in bytes). Default: 80% of System available memory
148: 	idx_t maximum_memory = DConstants::INVALID_INDEX;
149: 	//! The maximum size of the 'temp_directory' folder when set (in bytes). Default: 90% of available disk space.
150: 	idx_t maximum_swap_space = DConstants::INVALID_INDEX;
151: 	//! The maximum amount of CPU threads used by the database system. Default: all available.
152: 	idx_t maximum_threads = DConstants::INVALID_INDEX;
153: 	//! The number of external threads that work on DuckDB tasks. Default: 1.
154: 	//! Must be smaller or equal to maximum_threads.
155: 	idx_t external_threads = 1;
156: 	//! Whether or not to create and use a temporary directory to store intermediates that do not fit in memory
157: 	bool use_temporary_directory = true;
158: 	//! Directory to store temporary structures that do not fit in memory
159: 	string temporary_directory;
160: 	//! Whether or not to invoke filesystem trim on free blocks after checkpoint. This will reclaim
161: 	//! space for sparse files, on platforms that support it.
162: 	bool trim_free_blocks = false;
163: 	//! Record timestamps of buffer manager unpin() events. Usable by custom eviction policies.
164: 	bool buffer_manager_track_eviction_timestamps = false;
165: 	//! Whether or not to allow printing unredacted secrets
166: 	bool allow_unredacted_secrets = false;
167: 	//! The collation type of the database
168: 	string collation = string();
169: 	//! The order type used when none is specified (default: ASC)
170: 	OrderType default_order_type = OrderType::ASCENDING;
171: 	//! Null ordering used when none is specified (default: NULLS LAST)
172: 	DefaultOrderByNullType default_null_order = DefaultOrderByNullType::NULLS_LAST;
173: 	//! enable COPY and related commands
174: 	bool enable_external_access = true;
175: 	//! Whether or not object cache is used
176: 	bool object_cache_enable = false;
177: 	//! Whether or not the global http metadata cache is used
178: 	bool http_metadata_cache_enable = false;
179: 	//! Force checkpoint when CHECKPOINT is called or on shutdown, even if no changes have been made
180: 	bool force_checkpoint = false;
181: 	//! Run a checkpoint on successful shutdown and delete the WAL, to leave only a single database file behind
182: 	bool checkpoint_on_shutdown = true;
183: 	//! Serialize the metadata on checkpoint with compatibility for a given DuckDB version.
184: 	SerializationCompatibility serialization_compatibility = SerializationCompatibility::Default();
185: 	//! Debug flag that decides when a checkpoing should be aborted. Only used for testing purposes.
186: 	CheckpointAbort checkpoint_abort = CheckpointAbort::NO_ABORT;
187: 	//! Initialize the database with the standard set of DuckDB functions
188: 	//! You should probably not touch this unless you know what you are doing
189: 	bool initialize_default_database = true;
190: 	//! The set of disabled optimizers (default empty)
191: 	set<OptimizerType> disabled_optimizers;
192: 	//! Force a specific compression method to be used when checkpointing (if available)
193: 	CompressionType force_compression = CompressionType::COMPRESSION_AUTO;
194: 	//! Force a specific bitpacking mode to be used when using the bitpacking compression method
195: 	BitpackingMode force_bitpacking_mode = BitpackingMode::AUTO;
196: 	//! Debug setting for window aggregation mode: (window, combine, separate)
197: 	WindowAggregationMode window_mode = WindowAggregationMode::WINDOW;
198: 	//! Whether or not preserving insertion order should be preserved
199: 	bool preserve_insertion_order = true;
200: 	//! Whether Arrow Arrays use Large or Regular buffers
201: 	ArrowOffsetSize arrow_offset_size = ArrowOffsetSize::REGULAR;
202: 	//! Whether LISTs should produce Arrow ListViews
203: 	bool arrow_use_list_view = false;
204: 	//! Whether when producing arrow objects we produce string_views or regular strings
205: 	bool produce_arrow_string_views = false;
206: 	//! Database configuration variables as controlled by SET
207: 	case_insensitive_map_t<Value> set_variables;
208: 	//! Database configuration variable default values;
209: 	case_insensitive_map_t<Value> set_variable_defaults;
210: 	//! Directory to store extension binaries in
211: 	string extension_directory;
212: 	//! Whether unsigned extensions should be loaded
213: 	bool allow_unsigned_extensions = false;
214: 	//! Whether community extensions should be loaded
215: 	bool allow_community_extensions = true;
216: 	//! Whether extensions with missing metadata should be loaded
217: 	bool allow_extensions_metadata_mismatch = false;
218: 	//! Enable emitting FSST Vectors
219: 	bool enable_fsst_vectors = false;
220: 	//! Enable VIEWs to create dependencies
221: 	bool enable_view_dependencies = false;
222: 	//! Enable macros to create dependencies
223: 	bool enable_macro_dependencies = false;
224: 	//! Start transactions immediately in all attached databases - instead of lazily when a database is referenced
225: 	bool immediate_transaction_mode = false;
226: 	//! Debug setting - how to initialize  blocks in the storage layer when allocating
227: 	DebugInitialize debug_initialize = DebugInitialize::NO_INITIALIZE;
228: 	//! The set of user-provided options
229: 	case_insensitive_map_t<Value> user_options;
230: 	//! The set of unrecognized (other) options
231: 	unordered_map<string, Value> unrecognized_options;
232: 	//! Whether or not the configuration settings can be altered
233: 	bool lock_configuration = false;
234: 	//! Whether to print bindings when printing the plan (debug mode only)
235: 	static bool debug_print_bindings; // NOLINT: debug setting
236: 	//! The peak allocation threshold at which to flush the allocator after completing a task (1 << 27, ~128MB)
237: 	idx_t allocator_flush_threshold = 134217728;
238: 	//! Whether the allocator background thread is enabled
239: 	bool allocator_background_threads = false;
240: 	//! DuckDB API surface
241: 	string duckdb_api;
242: 	//! Metadata from DuckDB callers
243: 	string custom_user_agent;
244: 	//! Use old implicit casting style (i.e. allow everything to be implicitly casted to VARCHAR)
245: 	bool old_implicit_casting = false;
246: 	//! The default block allocation size for new duckdb database files (new as-in, they do not yet exist).
247: 	idx_t default_block_alloc_size = DUCKDB_BLOCK_ALLOC_SIZE;
248: 	//!  Whether or not to abort if a serialization exception is thrown during WAL playback (when reading truncated WAL)
249: 	bool abort_on_wal_failure = false;
250: 	//! The index_scan_percentage sets a threshold for index scans.
251: 	//! If fewer than MAX(index_scan_max_count, index_scan_percentage * total_row_count)
252: 	// rows match, we perform an index scan instead of a table scan.
253: 	double index_scan_percentage = 0.001;
254: 	//! The index_scan_max_count sets a threshold for index scans.
255: 	//! If fewer than MAX(index_scan_max_count, index_scan_percentage * total_row_count)
256: 	// rows match, we perform an index scan instead of a table scan.
257: 	idx_t index_scan_max_count = STANDARD_VECTOR_SIZE;
258: 	//! Whether or not we initialize table functions in the main thread
259: 	//! This is a work-around that exists for certain clients (specifically R)
260: 	//! Because those clients do not like it when threads other than the main thread call into R, for e.g., arrow scans
261: 	bool initialize_in_main_thread = false;
262: 	//! The maximum number of schemas we will look through for "did you mean..." style errors in the catalog
263: 	idx_t catalog_error_max_schemas = 100;
264: 	//!  Whether or not to always write to the WAL file, even if this is not required
265: 	bool debug_skip_checkpoint_on_commit = false;
266: 
267: 	bool operator==(const DBConfigOptions &other) const;
268: };
269: 
270: struct DBConfig {
271: 	friend class DatabaseInstance;
272: 	friend class StorageManager;
273: 
274: public:
275: 	DUCKDB_API DBConfig();
276: 	explicit DUCKDB_API DBConfig(bool read_only);
277: 	DUCKDB_API DBConfig(const case_insensitive_map_t<Value> &config_dict, bool read_only);
278: 	DUCKDB_API ~DBConfig();
279: 
280: 	mutex config_lock;
281: 	//! Replacement table scans are automatically attempted when a table name cannot be found in the schema
282: 	vector<ReplacementScan> replacement_scans;
283: 
284: 	//! Extra parameters that can be SET for loaded extensions
285: 	case_insensitive_map_t<ExtensionOption> extension_parameters;
286: 	//! The FileSystem to use, can be overwritten to allow for injecting custom file systems for testing purposes (e.g.
287: 	//! RamFS or something similar)
288: 	unique_ptr<FileSystem> file_system;
289: 	//! Secret manager
290: 	unique_ptr<SecretManager> secret_manager;
291: 	//! The allocator used by the system
292: 	unique_ptr<Allocator> allocator;
293: 	//! Database configuration options
294: 	DBConfigOptions options;
295: 	//! Extensions made to the parser
296: 	vector<ParserExtension> parser_extensions;
297: 	//! Extensions made to the optimizer
298: 	vector<OptimizerExtension> optimizer_extensions;
299: 	//! Error manager
300: 	unique_ptr<ErrorManager> error_manager;
301: 	//! A reference to the (shared) default allocator (Allocator::DefaultAllocator)
302: 	shared_ptr<Allocator> default_allocator;
303: 	//! Extensions made to binder
304: 	vector<unique_ptr<OperatorExtension>> operator_extensions;
305: 	//! Extensions made to storage
306: 	case_insensitive_map_t<duckdb::unique_ptr<StorageExtension>> storage_extensions;
307: 	//! A buffer pool can be shared across multiple databases (if desired).
308: 	shared_ptr<BufferPool> buffer_pool;
309: 	//! Provide a custom buffer manager implementation (if desired).
310: 	shared_ptr<BufferManager> buffer_manager;
311: 	//! Set of callbacks that can be installed by extensions
312: 	vector<unique_ptr<ExtensionCallback>> extension_callbacks;
313: 	//! Encryption Util for OpenSSL
314: 	shared_ptr<EncryptionUtil> encryption_util;
315: 
316: public:
317: 	DUCKDB_API static DBConfig &GetConfig(ClientContext &context);
318: 	DUCKDB_API static DBConfig &GetConfig(DatabaseInstance &db);
319: 	DUCKDB_API static DBConfig &Get(AttachedDatabase &db);
320: 	DUCKDB_API static const DBConfig &GetConfig(const ClientContext &context);
321: 	DUCKDB_API static const DBConfig &GetConfig(const DatabaseInstance &db);
322: 	DUCKDB_API static vector<ConfigurationOption> GetOptions();
323: 	DUCKDB_API static idx_t GetOptionCount();
324: 	DUCKDB_API static vector<string> GetOptionNames();
325: 	DUCKDB_API static bool IsInMemoryDatabase(const char *database_path);
326: 
327: 	DUCKDB_API void AddExtensionOption(const string &name, string description, LogicalType parameter,
328: 	                                   const Value &default_value = Value(), set_option_callback_t function = nullptr);
329: 	//! Fetch an option by index. Returns a pointer to the option, or nullptr if out of range
330: 	DUCKDB_API static optional_ptr<const ConfigurationOption> GetOptionByIndex(idx_t index);
331: 	//! Fetch an option by name. Returns a pointer to the option, or nullptr if none exists.
332: 	DUCKDB_API static optional_ptr<const ConfigurationOption> GetOptionByName(const string &name);
333: 	DUCKDB_API void SetOption(const ConfigurationOption &option, const Value &value);
334: 	DUCKDB_API void SetOption(DatabaseInstance *db, const ConfigurationOption &option, const Value &value);
335: 	DUCKDB_API void SetOptionByName(const string &name, const Value &value);
336: 	DUCKDB_API void SetOptionsByName(const case_insensitive_map_t<Value> &values);
337: 	DUCKDB_API void ResetOption(DatabaseInstance *db, const ConfigurationOption &option);
338: 	DUCKDB_API void SetOption(const string &name, Value value);
339: 	DUCKDB_API void ResetOption(const string &name);
340: 
341: 	DUCKDB_API void CheckLock(const string &name);
342: 
343: 	DUCKDB_API static idx_t ParseMemoryLimit(const string &arg);
344: 
345: 	//! Returns the list of possible compression functions for the physical type.
346: 	DUCKDB_API vector<reference<CompressionFunction>> GetCompressionFunctions(const PhysicalType physical_type);
347: 	//! Returns the compression function matching the compression and physical type.
348: 	DUCKDB_API optional_ptr<CompressionFunction> GetCompressionFunction(CompressionType type,
349: 	                                                                    const PhysicalType physical_type);
350: 
351: 	bool operator==(const DBConfig &other);
352: 	bool operator!=(const DBConfig &other);
353: 
354: 	DUCKDB_API CastFunctionSet &GetCastFunctions();
355: 	DUCKDB_API CollationBinding &GetCollationBinding();
356: 	DUCKDB_API IndexTypeSet &GetIndexTypes();
357: 	static idx_t GetSystemMaxThreads(FileSystem &fs);
358: 	static idx_t GetSystemAvailableMemory(FileSystem &fs);
359: 	static idx_t ParseMemoryLimitSlurm(const string &arg);
360: 	void SetDefaultMaxMemory();
361: 	void SetDefaultTempDirectory();
362: 
363: 	OrderType ResolveOrder(OrderType order_type) const;
364: 	OrderByNullType ResolveNullOrder(OrderType order_type, OrderByNullType null_type) const;
365: 	const string UserAgent() const;
366: 
367: private:
368: 	unique_ptr<CompressionFunctionSet> compression_functions;
369: 	unique_ptr<CastFunctionSet> cast_functions;
370: 	unique_ptr<CollationBinding> collation_bindings;
371: 	unique_ptr<IndexTypeSet> index_types;
372: 	bool is_user_config = true;
373: };
374: 
375: } // namespace duckdb
[end of src/include/duckdb/main/config.hpp]
[start of src/include/duckdb/main/database.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/database.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/main/config.hpp"
12: #include "duckdb/main/valid_checker.hpp"
13: #include "duckdb/common/winapi.hpp"
14: #include "duckdb/main/extension.hpp"
15: #include "duckdb/main/extension_install_info.hpp"
16: #include "duckdb/main/settings.hpp"
17: 
18: namespace duckdb {
19: class BufferManager;
20: class DatabaseManager;
21: class StorageManager;
22: class Catalog;
23: class TransactionManager;
24: class ConnectionManager;
25: class FileSystem;
26: class TaskScheduler;
27: class ObjectCache;
28: struct AttachInfo;
29: struct AttachOptions;
30: class DatabaseFileSystem;
31: struct DatabaseCacheEntry;
32: 
33: struct ExtensionInfo {
34: 	bool is_loaded;
35: 	unique_ptr<ExtensionInstallInfo> install_info;
36: 	unique_ptr<ExtensionLoadedInfo> load_info;
37: };
38: 
39: class DatabaseInstance : public enable_shared_from_this<DatabaseInstance> {
40: 	friend class DuckDB;
41: 
42: public:
43: 	DUCKDB_API DatabaseInstance();
44: 	DUCKDB_API ~DatabaseInstance();
45: 
46: 	DBConfig config;
47: 
48: public:
49: 	BufferPool &GetBufferPool() const;
50: 	DUCKDB_API SecretManager &GetSecretManager();
51: 	DUCKDB_API BufferManager &GetBufferManager();
52: 	DUCKDB_API const BufferManager &GetBufferManager() const;
53: 	DUCKDB_API DatabaseManager &GetDatabaseManager();
54: 	DUCKDB_API FileSystem &GetFileSystem();
55: 	DUCKDB_API TaskScheduler &GetScheduler();
56: 	DUCKDB_API ObjectCache &GetObjectCache();
57: 	DUCKDB_API ConnectionManager &GetConnectionManager();
58: 	DUCKDB_API ValidChecker &GetValidChecker();
59: 	DUCKDB_API void SetExtensionLoaded(const string &extension_name, ExtensionInstallInfo &install_info);
60: 
61: 	idx_t NumberOfThreads();
62: 
63: 	DUCKDB_API static DatabaseInstance &GetDatabase(ClientContext &context);
64: 	DUCKDB_API static const DatabaseInstance &GetDatabase(const ClientContext &context);
65: 
66: 	DUCKDB_API const unordered_map<string, ExtensionInfo> &GetExtensions();
67: 	DUCKDB_API bool ExtensionIsLoaded(const string &name);
68: 
69: 	DUCKDB_API SettingLookupResult TryGetCurrentSetting(const string &key, Value &result) const;
70: 
71: 	unique_ptr<AttachedDatabase> CreateAttachedDatabase(ClientContext &context, const AttachInfo &info,
72: 	                                                    const AttachOptions &options);
73: 
74: 	void AddExtensionInfo(const string &name, const ExtensionLoadedInfo &info);
75: 	void SetDatabaseCacheEntry(shared_ptr<DatabaseCacheEntry> entry);
76: 
77: private:
78: 	void Initialize(const char *path, DBConfig *config);
79: 	void CreateMainDatabase();
80: 
81: 	void Configure(DBConfig &config, const char *path);
82: 
83: private:
84: 	shared_ptr<BufferManager> buffer_manager;
85: 	unique_ptr<DatabaseManager> db_manager;
86: 	unique_ptr<TaskScheduler> scheduler;
87: 	unique_ptr<ObjectCache> object_cache;
88: 	unique_ptr<ConnectionManager> connection_manager;
89: 	unordered_map<string, ExtensionInfo> loaded_extensions_info;
90: 	ValidChecker db_validity;
91: 	unique_ptr<DatabaseFileSystem> db_file_system;
92: 	shared_ptr<DatabaseCacheEntry> db_cache_entry;
93: };
94: 
95: //! The database object. This object holds the catalog and all the
96: //! database-specific meta information.
97: class DuckDB {
98: public:
99: 	DUCKDB_API explicit DuckDB(const char *path = nullptr, DBConfig *config = nullptr);
100: 	DUCKDB_API explicit DuckDB(const string &path, DBConfig *config = nullptr);
101: 	DUCKDB_API explicit DuckDB(DatabaseInstance &instance);
102: 
103: 	DUCKDB_API ~DuckDB();
104: 
105: 	//! Reference to the actual database instance
106: 	shared_ptr<DatabaseInstance> instance;
107: 
108: public:
109: 	// Load a statically loaded extension by its class
110: 	template <class T>
111: 	void LoadStaticExtension() {
112: 		T extension;
113: 		if (ExtensionIsLoaded(extension.Name())) {
114: 			return;
115: 		}
116: 		extension.Load(*this);
117: 		ExtensionInstallInfo install_info;
118: 		install_info.mode = ExtensionInstallMode::STATICALLY_LINKED;
119: 		install_info.version = extension.Version();
120: 		instance->SetExtensionLoaded(extension.Name(), install_info);
121: 	}
122: 
123: 	// DEPRECATED function that some extensions may still use to call their own Load method from the
124: 	// _init function of their loadable extension. Don't use this. Instead opt for a static LoadInternal function called
125: 	// from both the _init function and the Extension::Load. (see autocomplete extension)
126: 	// TODO: when to remove this function?
127: 	template <class T>
128: 	void LoadExtension() {
129: 		T extension;
130: 		extension.Load(*this);
131: 	}
132: 
133: 	DUCKDB_API FileSystem &GetFileSystem();
134: 
135: 	DUCKDB_API idx_t NumberOfThreads();
136: 	DUCKDB_API static const char *SourceID();
137: 	DUCKDB_API static const char *LibraryVersion();
138: 	DUCKDB_API static idx_t StandardVectorSize();
139: 	DUCKDB_API static string Platform();
140: 	DUCKDB_API bool ExtensionIsLoaded(const string &name);
141: };
142: 
143: } // namespace duckdb
[end of src/include/duckdb/main/database.hpp]
[start of src/include/duckdb/main/extension_helper.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/extension_helper.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb.hpp"
12: #include "duckdb/main/extension_entries.hpp"
13: #include "duckdb/main/extension_install_info.hpp"
14: 
15: #include <string>
16: 
17: #include <string>
18: 
19: namespace duckdb {
20: 
21: class DuckDB;
22: class HTTPLogger;
23: 
24: enum class ExtensionLoadResult : uint8_t { LOADED_EXTENSION = 0, EXTENSION_UNKNOWN = 1, NOT_LOADED = 2 };
25: 
26: struct DefaultExtension {
27: 	const char *name;
28: 	const char *description;
29: 	bool statically_loaded;
30: };
31: 
32: struct ExtensionAlias {
33: 	const char *alias;
34: 	const char *extension;
35: };
36: 
37: struct ExtensionInitResult {
38: 	string filename;
39: 	string filebase;
40: 
41: 	// The deserialized install from the `<ext>.duckdb_extension.info` file
42: 	unique_ptr<ExtensionInstallInfo> install_info;
43: 
44: 	void *lib_hdl;
45: };
46: 
47: // Tags describe what happened during the updating process
48: enum class ExtensionUpdateResultTag : uint8_t {
49: 	// Fallback for when installation information is missing
50: 	UNKNOWN = 0,
51: 
52: 	// Either a fresh file was downloaded and versions are identical
53: 	NO_UPDATE_AVAILABLE = 1,
54: 	// Only extensions from repositories can be updated
55: 	NOT_A_REPOSITORY = 2,
56: 	// Only known, currently installed extensions can be updated
57: 	NOT_INSTALLED = 3,
58: 	// Statically loaded extensions can not be updated; they are baked into the DuckDB executable
59: 	STATICALLY_LOADED = 4,
60: 	// This means the .info file written during installation was missing or malformed
61: 	MISSING_INSTALL_INFO = 5,
62: 
63: 	// The extension was re-downloaded from the repository, but due to a lack of version information
64: 	// its impossible to tell if the extension is actually updated
65: 	REDOWNLOADED = 254,
66: 	// The version was updated to a new version
67: 	UPDATED = 255,
68: };
69: 
70: struct ExtensionUpdateResult {
71: 	ExtensionUpdateResultTag tag = ExtensionUpdateResultTag::UNKNOWN;
72: 
73: 	string extension_name;
74: 	string repository;
75: 
76: 	string extension_version;
77: 	string prev_version;
78: 	string installed_version;
79: };
80: 
81: class ExtensionHelper {
82: public:
83: 	static void LoadAllExtensions(DuckDB &db);
84: 
85: 	static ExtensionLoadResult LoadExtension(DuckDB &db, const std::string &extension);
86: 
87: 	//! Install an extension
88: 	static unique_ptr<ExtensionInstallInfo> InstallExtension(ClientContext &context, const string &extension,
89: 	                                                         bool force_install,
90: 	                                                         optional_ptr<ExtensionRepository> repository = nullptr,
91: 	                                                         bool throw_on_origin_mismatch = false,
92: 	                                                         const string &version = "");
93: 	static unique_ptr<ExtensionInstallInfo> InstallExtension(DBConfig &config, FileSystem &fs, const string &extension,
94: 	                                                         bool force_install,
95: 	                                                         optional_ptr<ExtensionRepository> repository = nullptr,
96: 	                                                         bool throw_on_origin_mismatch = false,
97: 	                                                         const string &version = "");
98: 	//! Load an extension
99: 	static void LoadExternalExtension(ClientContext &context, const string &extension);
100: 	static void LoadExternalExtension(DatabaseInstance &db, FileSystem &fs, const string &extension);
101: 
102: 	//! Autoload an extension (depending on config, potentially a nop. Throws when installation fails)
103: 	static void AutoLoadExtension(ClientContext &context, const string &extension_name);
104: 	static void AutoLoadExtension(DatabaseInstance &db, const string &extension_name);
105: 
106: 	//! Autoload an extension (depending on config, potentially a nop. Returns false on failure)
107: 	DUCKDB_API static bool TryAutoLoadExtension(ClientContext &context, const string &extension_name) noexcept;
108: 
109: 	//! Update all extensions, return a vector of extension names that were updated;
110: 	static vector<ExtensionUpdateResult> UpdateExtensions(ClientContext &context);
111: 	//! Update a specific extension
112: 	static ExtensionUpdateResult UpdateExtension(ClientContext &context, const string &extension_name);
113: 
114: 	//! Get the extension directory base on the current config
115: 	static string ExtensionDirectory(ClientContext &context);
116: 	static string ExtensionDirectory(DBConfig &config, FileSystem &fs);
117: 
118: 	static bool CheckExtensionSignature(FileHandle &handle, ParsedExtensionMetaData &parsed_metadata,
119: 	                                    const bool allow_community_extensions);
120: 	static ParsedExtensionMetaData ParseExtensionMetaData(const char *metadata);
121: 	static ParsedExtensionMetaData ParseExtensionMetaData(FileHandle &handle);
122: 
123: 	//! Get the extension url template, containing placeholders for version, platform and extension name
124: 	static string ExtensionUrlTemplate(optional_ptr<const DBConfig> config, const ExtensionRepository &repository,
125: 	                                   const string &version);
126: 	//! Return the extension url template with the variables replaced
127: 	static string ExtensionFinalizeUrlTemplate(const string &url, const string &name);
128: 
129: 	//! Default extensions are all extensions that DuckDB knows and expect to be available (both in-tree and
130: 	//! out-of-tree)
131: 	static idx_t DefaultExtensionCount();
132: 	static DefaultExtension GetDefaultExtension(idx_t index);
133: 
134: 	//! Extension can have aliases
135: 	static idx_t ExtensionAliasCount();
136: 	static ExtensionAlias GetExtensionAlias(idx_t index);
137: 
138: 	//! Get public signing keys for extension signing
139: 	static const vector<string> GetPublicKeys(bool allow_community_extension = false);
140: 
141: 	// Returns extension name, or empty string if not a replacement open path
142: 	static string ExtractExtensionPrefixFromPath(const string &path);
143: 
144: 	// Returns the user-readable name of a repository URL
145: 	static string GetRepositoryName(const string &repository_base_url);
146: 
147: 	//! Apply any known extension aliases, return the lowercase name
148: 	static string ApplyExtensionAlias(const string &extension_name);
149: 
150: 	static string GetExtensionName(const string &extension);
151: 	static bool IsFullPath(const string &extension);
152: 
153: 	//! Lookup a name + type in an ExtensionFunctionEntry list
154: 	template <size_t N>
155: 	static vector<pair<string, CatalogType>>
156: 	FindExtensionInFunctionEntries(const string &name, const ExtensionFunctionEntry (&entries)[N]) {
157: 		auto lcase = StringUtil::Lower(name);
158: 
159: 		vector<pair<string, CatalogType>> result;
160: 		for (idx_t i = 0; i < N; i++) {
161: 			auto &element = entries[i];
162: 			if (element.name == lcase) {
163: 				result.push_back(make_pair(element.extension, element.type));
164: 			}
165: 		}
166: 		return result;
167: 	}
168: 
169: 	//! Lookup a name in an ExtensionEntry list
170: 	template <idx_t N>
171: 	static string FindExtensionInEntries(const string &name, const ExtensionEntry (&entries)[N]) {
172: 		auto lcase = StringUtil::Lower(name);
173: 
174: 		auto it =
175: 		    std::find_if(entries, entries + N, [&](const ExtensionEntry &element) { return element.name == lcase; });
176: 
177: 		if (it != entries + N && it->name == lcase) {
178: 			return it->extension;
179: 		}
180: 		return "";
181: 	}
182: 
183: 	//! Lookup a name in an extension entry and try to autoload it
184: 	template <idx_t N>
185: 	static void TryAutoloadFromEntry(DatabaseInstance &db, const string &entry, const ExtensionEntry (&entries)[N]) {
186: 		auto &dbconfig = DBConfig::GetConfig(db);
187: #ifndef DUCKDB_DISABLE_EXTENSION_LOAD
188: 		if (dbconfig.options.autoload_known_extensions) {
189: 			auto extension_name = ExtensionHelper::FindExtensionInEntries(entry, entries);
190: 			if (ExtensionHelper::CanAutoloadExtension(extension_name)) {
191: 				ExtensionHelper::AutoLoadExtension(db, extension_name);
192: 			}
193: 		}
194: #endif
195: 	}
196: 
197: 	//! Whether an extension can be autoloaded (i.e. it's registered as an autoloadable extension in
198: 	//! extension_entries.hpp)
199: 	static bool CanAutoloadExtension(const string &ext_name);
200: 
201: 	//! Utility functions for creating meaningful error messages regarding missing extensions
202: 	static string WrapAutoLoadExtensionErrorMsg(ClientContext &context, const string &base_error,
203: 	                                            const string &extension_name);
204: 	static string AddExtensionInstallHintToErrorMsg(ClientContext &context, const string &base_error,
205: 	                                                const string &extension_name);
206: 	static string AddExtensionInstallHintToErrorMsg(DBConfig &config, const string &base_error,
207: 	                                                const string &extension_name);
208: 
209: 	//! For tagged releases we use the tag, else we use the git commit hash
210: 	static const string GetVersionDirectoryName();
211: 
212: 	static bool IsRelease(const string &version_tag);
213: 	static bool CreateSuggestions(const string &extension_name, string &message);
214: 
215: private:
216: 	static unique_ptr<ExtensionInstallInfo> InstallExtensionInternal(
217: 	    DBConfig &config, FileSystem &fs, const string &local_path, const string &extension, bool force_install,
218: 	    bool throw_on_origin_mismatch, const string &version, optional_ptr<ExtensionRepository> repository,
219: 	    optional_ptr<HTTPLogger> http_logger = nullptr, optional_ptr<ClientContext> context = nullptr);
220: 	static const vector<string> PathComponents();
221: 	static string DefaultExtensionFolder(FileSystem &fs);
222: 	static bool AllowAutoInstall(const string &extension);
223: 	static ExtensionInitResult InitialLoad(DBConfig &config, FileSystem &fs, const string &extension);
224: 	static bool TryInitialLoad(DBConfig &config, FileSystem &fs, const string &extension, ExtensionInitResult &result,
225: 	                           string &error);
226: 	//! Version tags occur with and without 'v', tag in extension path is always with 'v'
227: 	static const string NormalizeVersionTag(const string &version_tag);
228: 
229: private:
230: 	static ExtensionLoadResult LoadExtensionInternal(DuckDB &db, const std::string &extension, bool initial_load);
231: };
232: 
233: } // namespace duckdb
[end of src/include/duckdb/main/extension_helper.hpp]
[start of src/main/database.cpp]
1: #include "duckdb/main/database.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/common/virtual_file_system.hpp"
5: #include "duckdb/execution/operator/helper/physical_set.hpp"
6: #include "duckdb/function/cast/cast_function_set.hpp"
7: #include "duckdb/function/compression_function.hpp"
8: #include "duckdb/main/attached_database.hpp"
9: #include "duckdb/main/client_context.hpp"
10: #include "duckdb/main/connection_manager.hpp"
11: #include "duckdb/main/database_manager.hpp"
12: #include "duckdb/main/database_path_and_type.hpp"
13: #include "duckdb/main/error_manager.hpp"
14: #include "duckdb/main/extension_helper.hpp"
15: #include "duckdb/main/secret/secret_manager.hpp"
16: #include "duckdb/parallel/task_scheduler.hpp"
17: #include "duckdb/parser/parsed_data/attach_info.hpp"
18: #include "duckdb/planner/extension_callback.hpp"
19: #include "duckdb/storage/object_cache.hpp"
20: #include "duckdb/storage/standard_buffer_manager.hpp"
21: #include "duckdb/storage/storage_extension.hpp"
22: #include "duckdb/storage/storage_manager.hpp"
23: #include "duckdb/transaction/transaction_manager.hpp"
24: #include "duckdb/execution/index/index_type_set.hpp"
25: #include "duckdb/main/database_file_opener.hpp"
26: #include "duckdb/planner/collation_binding.hpp"
27: #include "duckdb/main/db_instance_cache.hpp"
28: 
29: #ifndef DUCKDB_NO_THREADS
30: #include "duckdb/common/thread.hpp"
31: #endif
32: 
33: namespace duckdb {
34: 
35: DBConfig::DBConfig() {
36: 	compression_functions = make_uniq<CompressionFunctionSet>();
37: 	cast_functions = make_uniq<CastFunctionSet>(*this);
38: 	collation_bindings = make_uniq<CollationBinding>();
39: 	index_types = make_uniq<IndexTypeSet>();
40: 	error_manager = make_uniq<ErrorManager>();
41: 	secret_manager = make_uniq<SecretManager>();
42: }
43: 
44: DBConfig::DBConfig(bool read_only) : DBConfig::DBConfig() {
45: 	if (read_only) {
46: 		options.access_mode = AccessMode::READ_ONLY;
47: 	}
48: }
49: 
50: DBConfig::DBConfig(const case_insensitive_map_t<Value> &config_dict, bool read_only) : DBConfig::DBConfig(read_only) {
51: 	SetOptionsByName(config_dict);
52: }
53: 
54: DBConfig::~DBConfig() {
55: }
56: 
57: DatabaseInstance::DatabaseInstance() {
58: 	config.is_user_config = false;
59: }
60: 
61: DatabaseInstance::~DatabaseInstance() {
62: 	// destroy all attached databases
63: 	GetDatabaseManager().ResetDatabases(scheduler);
64: 	// destroy child elements
65: 	connection_manager.reset();
66: 	object_cache.reset();
67: 	scheduler.reset();
68: 	db_manager.reset();
69: 	buffer_manager.reset();
70: 	// flush allocations and disable the background thread
71: 	if (Allocator::SupportsFlush()) {
72: 		Allocator::FlushAll();
73: 	}
74: 	Allocator::SetBackgroundThreads(false);
75: 	// after all destruction is complete clear the cache entry
76: 	db_cache_entry.reset();
77: }
78: 
79: BufferManager &BufferManager::GetBufferManager(DatabaseInstance &db) {
80: 	return db.GetBufferManager();
81: }
82: 
83: const BufferManager &BufferManager::GetBufferManager(const DatabaseInstance &db) {
84: 	return db.GetBufferManager();
85: }
86: 
87: BufferManager &BufferManager::GetBufferManager(AttachedDatabase &db) {
88: 	return BufferManager::GetBufferManager(db.GetDatabase());
89: }
90: 
91: DatabaseInstance &DatabaseInstance::GetDatabase(ClientContext &context) {
92: 	return *context.db;
93: }
94: 
95: const DatabaseInstance &DatabaseInstance::GetDatabase(const ClientContext &context) {
96: 	return *context.db;
97: }
98: 
99: void DatabaseInstance::SetDatabaseCacheEntry(shared_ptr<DatabaseCacheEntry> entry) {
100: 	db_cache_entry = std::move(entry);
101: }
102: 
103: DatabaseManager &DatabaseInstance::GetDatabaseManager() {
104: 	if (!db_manager) {
105: 		throw InternalException("Missing DB manager");
106: 	}
107: 	return *db_manager;
108: }
109: 
110: Catalog &Catalog::GetSystemCatalog(DatabaseInstance &db) {
111: 	return db.GetDatabaseManager().GetSystemCatalog();
112: }
113: 
114: Catalog &Catalog::GetCatalog(AttachedDatabase &db) {
115: 	return db.GetCatalog();
116: }
117: 
118: FileSystem &FileSystem::GetFileSystem(DatabaseInstance &db) {
119: 	return db.GetFileSystem();
120: }
121: 
122: FileSystem &FileSystem::Get(AttachedDatabase &db) {
123: 	return FileSystem::GetFileSystem(db.GetDatabase());
124: }
125: 
126: DBConfig &DBConfig::GetConfig(DatabaseInstance &db) {
127: 	return db.config;
128: }
129: 
130: ClientConfig &ClientConfig::GetConfig(ClientContext &context) {
131: 	return context.config;
132: }
133: 
134: DBConfig &DBConfig::Get(AttachedDatabase &db) {
135: 	return DBConfig::GetConfig(db.GetDatabase());
136: }
137: 
138: const DBConfig &DBConfig::GetConfig(const DatabaseInstance &db) {
139: 	return db.config;
140: }
141: 
142: const ClientConfig &ClientConfig::GetConfig(const ClientContext &context) {
143: 	return context.config;
144: }
145: 
146: TransactionManager &TransactionManager::Get(AttachedDatabase &db) {
147: 	return db.GetTransactionManager();
148: }
149: 
150: ConnectionManager &ConnectionManager::Get(DatabaseInstance &db) {
151: 	return db.GetConnectionManager();
152: }
153: 
154: ConnectionManager &ConnectionManager::Get(ClientContext &context) {
155: 	return ConnectionManager::Get(DatabaseInstance::GetDatabase(context));
156: }
157: 
158: unique_ptr<AttachedDatabase> DatabaseInstance::CreateAttachedDatabase(ClientContext &context, const AttachInfo &info,
159:                                                                       const AttachOptions &options) {
160: 	unique_ptr<AttachedDatabase> attached_database;
161: 	auto &catalog = Catalog::GetSystemCatalog(*this);
162: 
163: 	if (!options.db_type.empty()) {
164: 		// Find the storage extension for this database file.
165: 		auto extension_name = ExtensionHelper::ApplyExtensionAlias(options.db_type);
166: 		auto entry = config.storage_extensions.find(extension_name);
167: 		if (entry == config.storage_extensions.end()) {
168: 			throw BinderException("Unrecognized storage type \"%s\"", options.db_type);
169: 		}
170: 
171: 		if (entry->second->attach != nullptr && entry->second->create_transaction_manager != nullptr) {
172: 			// Use the storage extension to create the initial database.
173: 			attached_database =
174: 			    make_uniq<AttachedDatabase>(*this, catalog, *entry->second, context, info.name, info, options);
175: 			return attached_database;
176: 		}
177: 
178: 		attached_database = make_uniq<AttachedDatabase>(*this, catalog, info.name, info.path, options);
179: 		return attached_database;
180: 	}
181: 
182: 	// An empty db_type defaults to a duckdb database file.
183: 	attached_database = make_uniq<AttachedDatabase>(*this, catalog, info.name, info.path, options);
184: 	return attached_database;
185: }
186: 
187: void DatabaseInstance::CreateMainDatabase() {
188: 	AttachInfo info;
189: 	info.name = AttachedDatabase::ExtractDatabaseName(config.options.database_path, GetFileSystem());
190: 	info.path = config.options.database_path;
191: 
192: 	optional_ptr<AttachedDatabase> initial_database;
193: 	{
194: 		Connection con(*this);
195: 		con.BeginTransaction();
196: 		AttachOptions options(config.options);
197: 		initial_database = db_manager->AttachDatabase(*con.context, info, options);
198: 		con.Commit();
199: 	}
200: 
201: 	initial_database->SetInitialDatabase();
202: 	initial_database->Initialize();
203: }
204: 
205: void ThrowExtensionSetUnrecognizedOptions(const unordered_map<string, Value> &unrecognized_options) {
206: 	auto unrecognized_options_iter = unrecognized_options.begin();
207: 	string unrecognized_option_keys = unrecognized_options_iter->first;
208: 	while (++unrecognized_options_iter != unrecognized_options.end()) {
209: 		unrecognized_option_keys = "," + unrecognized_options_iter->first;
210: 	}
211: 	throw InvalidInputException("Unrecognized configuration property \"%s\"", unrecognized_option_keys);
212: }
213: 
214: void DatabaseInstance::Initialize(const char *database_path, DBConfig *user_config) {
215: 	DBConfig default_config;
216: 	DBConfig *config_ptr = &default_config;
217: 	if (user_config) {
218: 		config_ptr = user_config;
219: 	}
220: 
221: 	Configure(*config_ptr, database_path);
222: 
223: 	if (user_config && !user_config->options.use_temporary_directory) {
224: 		// temporary directories explicitly disabled
225: 		config.options.temporary_directory = string();
226: 	}
227: 
228: 	db_file_system = make_uniq<DatabaseFileSystem>(*this);
229: 	db_manager = make_uniq<DatabaseManager>(*this);
230: 	if (config.buffer_manager) {
231: 		buffer_manager = config.buffer_manager;
232: 	} else {
233: 		buffer_manager = make_uniq<StandardBufferManager>(*this, config.options.temporary_directory);
234: 	}
235: 	scheduler = make_uniq<TaskScheduler>(*this);
236: 	object_cache = make_uniq<ObjectCache>();
237: 	connection_manager = make_uniq<ConnectionManager>();
238: 
239: 	// initialize the secret manager
240: 	config.secret_manager->Initialize(*this);
241: 
242: 	// resolve the type of teh database we are opening
243: 	auto &fs = FileSystem::GetFileSystem(*this);
244: 	DBPathAndType::ResolveDatabaseType(fs, config.options.database_path, config.options.database_type);
245: 
246: 	// initialize the system catalog
247: 	db_manager->InitializeSystemCatalog();
248: 
249: 	if (!config.options.database_type.empty()) {
250: 		// if we are opening an extension database - load the extension
251: 		if (!config.file_system) {
252: 			throw InternalException("No file system!?");
253: 		}
254: 		ExtensionHelper::LoadExternalExtension(*this, *config.file_system, config.options.database_type);
255: 	}
256: 
257: 	if (!config.options.unrecognized_options.empty()) {
258: 		ThrowExtensionSetUnrecognizedOptions(config.options.unrecognized_options);
259: 	}
260: 
261: 	if (!db_manager->HasDefaultDatabase()) {
262: 		CreateMainDatabase();
263: 	}
264: 
265: 	// only increase thread count after storage init because we get races on catalog otherwise
266: 	scheduler->SetThreads(config.options.maximum_threads, config.options.external_threads);
267: 	scheduler->RelaunchThreads();
268: }
269: 
270: DuckDB::DuckDB(const char *path, DBConfig *new_config) : instance(make_shared_ptr<DatabaseInstance>()) {
271: 	instance->Initialize(path, new_config);
272: 	if (instance->config.options.load_extensions) {
273: 		ExtensionHelper::LoadAllExtensions(*this);
274: 	}
275: }
276: 
277: DuckDB::DuckDB(const string &path, DBConfig *config) : DuckDB(path.c_str(), config) {
278: }
279: 
280: DuckDB::DuckDB(DatabaseInstance &instance_p) : instance(instance_p.shared_from_this()) {
281: }
282: 
283: DuckDB::~DuckDB() {
284: }
285: 
286: SecretManager &DatabaseInstance::GetSecretManager() {
287: 	return *config.secret_manager;
288: }
289: 
290: BufferManager &DatabaseInstance::GetBufferManager() {
291: 	return *buffer_manager;
292: }
293: 
294: const BufferManager &DatabaseInstance::GetBufferManager() const {
295: 	return *buffer_manager;
296: }
297: 
298: BufferPool &DatabaseInstance::GetBufferPool() const {
299: 	return *config.buffer_pool;
300: }
301: 
302: DatabaseManager &DatabaseManager::Get(DatabaseInstance &db) {
303: 	return db.GetDatabaseManager();
304: }
305: 
306: DatabaseManager &DatabaseManager::Get(ClientContext &db) {
307: 	return DatabaseManager::Get(*db.db);
308: }
309: 
310: TaskScheduler &DatabaseInstance::GetScheduler() {
311: 	return *scheduler;
312: }
313: 
314: ObjectCache &DatabaseInstance::GetObjectCache() {
315: 	return *object_cache;
316: }
317: 
318: FileSystem &DatabaseInstance::GetFileSystem() {
319: 	return *db_file_system;
320: }
321: 
322: ConnectionManager &DatabaseInstance::GetConnectionManager() {
323: 	return *connection_manager;
324: }
325: 
326: FileSystem &DuckDB::GetFileSystem() {
327: 	return instance->GetFileSystem();
328: }
329: 
330: Allocator &Allocator::Get(ClientContext &context) {
331: 	return Allocator::Get(*context.db);
332: }
333: 
334: Allocator &Allocator::Get(DatabaseInstance &db) {
335: 	return *db.config.allocator;
336: }
337: 
338: Allocator &Allocator::Get(AttachedDatabase &db) {
339: 	return Allocator::Get(db.GetDatabase());
340: }
341: 
342: void DatabaseInstance::Configure(DBConfig &new_config, const char *database_path) {
343: 	config.options = new_config.options;
344: 
345: 	if (config.options.duckdb_api.empty()) {
346: 		config.SetOptionByName("duckdb_api", "cpp");
347: 	}
348: 
349: 	if (database_path) {
350: 		config.options.database_path = database_path;
351: 	} else {
352: 		config.options.database_path.clear();
353: 	}
354: 
355: 	if (new_config.options.temporary_directory.empty()) {
356: 		config.SetDefaultTempDirectory();
357: 	}
358: 
359: 	if (config.options.access_mode == AccessMode::UNDEFINED) {
360: 		config.options.access_mode = AccessMode::READ_WRITE;
361: 	}
362: 	config.extension_parameters = new_config.extension_parameters;
363: 	if (new_config.file_system) {
364: 		config.file_system = std::move(new_config.file_system);
365: 	} else {
366: 		config.file_system = make_uniq<VirtualFileSystem>();
367: 	}
368: 	if (new_config.secret_manager) {
369: 		config.secret_manager = std::move(new_config.secret_manager);
370: 	}
371: 	if (config.options.maximum_memory == DConstants::INVALID_INDEX) {
372: 		config.SetDefaultMaxMemory();
373: 	}
374: 	if (new_config.options.maximum_threads == DConstants::INVALID_INDEX) {
375: 		config.options.maximum_threads = config.GetSystemMaxThreads(*config.file_system);
376: 	}
377: 	config.allocator = std::move(new_config.allocator);
378: 	if (!config.allocator) {
379: 		config.allocator = make_uniq<Allocator>();
380: 	}
381: 	config.replacement_scans = std::move(new_config.replacement_scans);
382: 	config.parser_extensions = std::move(new_config.parser_extensions);
383: 	config.error_manager = std::move(new_config.error_manager);
384: 	if (!config.error_manager) {
385: 		config.error_manager = make_uniq<ErrorManager>();
386: 	}
387: 	if (!config.default_allocator) {
388: 		config.default_allocator = Allocator::DefaultAllocatorReference();
389: 	}
390: 	if (new_config.buffer_pool) {
391: 		config.buffer_pool = std::move(new_config.buffer_pool);
392: 	} else {
393: 		config.buffer_pool = make_shared_ptr<BufferPool>(config.options.maximum_memory,
394: 		                                                 config.options.buffer_manager_track_eviction_timestamps);
395: 	}
396: }
397: 
398: DBConfig &DBConfig::GetConfig(ClientContext &context) {
399: 	return context.db->config;
400: }
401: 
402: const DBConfig &DBConfig::GetConfig(const ClientContext &context) {
403: 	return context.db->config;
404: }
405: 
406: idx_t DatabaseInstance::NumberOfThreads() {
407: 	return NumericCast<idx_t>(scheduler->NumberOfThreads());
408: }
409: 
410: const unordered_map<string, ExtensionInfo> &DatabaseInstance::GetExtensions() {
411: 	return loaded_extensions_info;
412: }
413: 
414: void DatabaseInstance::AddExtensionInfo(const string &name, const ExtensionLoadedInfo &info) {
415: 	loaded_extensions_info[name].load_info = make_uniq<ExtensionLoadedInfo>(info);
416: }
417: 
418: idx_t DuckDB::NumberOfThreads() {
419: 	return instance->NumberOfThreads();
420: }
421: 
422: bool DatabaseInstance::ExtensionIsLoaded(const std::string &name) {
423: 	auto extension_name = ExtensionHelper::GetExtensionName(name);
424: 	auto it = loaded_extensions_info.find(extension_name);
425: 	return it != loaded_extensions_info.end() && it->second.is_loaded;
426: }
427: 
428: bool DuckDB::ExtensionIsLoaded(const std::string &name) {
429: 	return instance->ExtensionIsLoaded(name);
430: }
431: 
432: void DatabaseInstance::SetExtensionLoaded(const string &name, ExtensionInstallInfo &install_info) {
433: 	auto extension_name = ExtensionHelper::GetExtensionName(name);
434: 	loaded_extensions_info[extension_name].is_loaded = true;
435: 	loaded_extensions_info[extension_name].install_info = make_uniq<ExtensionInstallInfo>(install_info);
436: 
437: 	auto &callbacks = DBConfig::GetConfig(*this).extension_callbacks;
438: 	for (auto &callback : callbacks) {
439: 		callback->OnExtensionLoaded(*this, name);
440: 	}
441: }
442: 
443: SettingLookupResult DatabaseInstance::TryGetCurrentSetting(const std::string &key, Value &result) const {
444: 	// check the session values
445: 	auto &db_config = DBConfig::GetConfig(*this);
446: 	const auto &global_config_map = db_config.options.set_variables;
447: 
448: 	auto global_value = global_config_map.find(key);
449: 	bool found_global_value = global_value != global_config_map.end();
450: 	if (!found_global_value) {
451: 		return SettingLookupResult();
452: 	}
453: 	result = global_value->second;
454: 	return SettingLookupResult(SettingScope::GLOBAL);
455: }
456: 
457: ValidChecker &DatabaseInstance::GetValidChecker() {
458: 	return db_validity;
459: }
460: 
461: ValidChecker &ValidChecker::Get(DatabaseInstance &db) {
462: 	return db.GetValidChecker();
463: }
464: 
465: } // namespace duckdb
[end of src/main/database.cpp]
[start of src/main/extension/extension_helper.cpp]
1: #include "duckdb/main/extension_helper.hpp"
2: 
3: #include "duckdb/common/file_system.hpp"
4: #include "duckdb/common/serializer/binary_deserializer.hpp"
5: #include "duckdb/common/serializer/buffered_file_reader.hpp"
6: #include "duckdb/common/string_util.hpp"
7: #include "duckdb/common/windows.hpp"
8: #include "duckdb/main/client_context.hpp"
9: #include "duckdb/main/database.hpp"
10: #include "duckdb/main/extension.hpp"
11: #include "duckdb/main/extension_install_info.hpp"
12: 
13: // Note that c++ preprocessor doesn't have a nice way to clean this up so we need to set the defines we use to false
14: // explicitly when they are undefined
15: #ifndef DUCKDB_EXTENSION_ICU_LINKED
16: #define DUCKDB_EXTENSION_ICU_LINKED false
17: #endif
18: 
19: #ifndef DUCKDB_EXTENSION_EXCEL_LINKED
20: #define DUCKDB_EXTENSION_EXCEL_LINKED false
21: #endif
22: 
23: #ifndef DUCKDB_EXTENSION_PARQUET_LINKED
24: #define DUCKDB_EXTENSION_PARQUET_LINKED false
25: #endif
26: 
27: #ifndef DUCKDB_EXTENSION_TPCH_LINKED
28: #define DUCKDB_EXTENSION_TPCH_LINKED false
29: #endif
30: 
31: #ifndef DUCKDB_EXTENSION_TPCDS_LINKED
32: #define DUCKDB_EXTENSION_TPCDS_LINKED false
33: #endif
34: 
35: #ifndef DUCKDB_EXTENSION_FTS_LINKED
36: #define DUCKDB_EXTENSION_FTS_LINKED false
37: #endif
38: 
39: #ifndef DUCKDB_EXTENSION_HTTPFS_LINKED
40: #define DUCKDB_EXTENSION_HTTPFS_LINKED false
41: #endif
42: 
43: #ifndef DUCKDB_EXTENSION_JSON_LINKED
44: #define DUCKDB_EXTENSION_JSON_LINKED false
45: #endif
46: 
47: #ifndef DUCKDB_EXTENSION_JEMALLOC_LINKED
48: #define DUCKDB_EXTENSION_JEMALLOC_LINKED false
49: #endif
50: 
51: #ifndef DUCKDB_EXTENSION_AUTOCOMPLETE_LINKED
52: #define DUCKDB_EXTENSION_AUTOCOMPLETE_LINKED false
53: #endif
54: 
55: // Load the generated header file containing our list of extension headers
56: #if defined(GENERATED_EXTENSION_HEADERS) && GENERATED_EXTENSION_HEADERS && !defined(DUCKDB_AMALGAMATION)
57: #include "duckdb/main/extension/generated_extension_loader.hpp"
58: #else
59: // TODO: rewrite package_build.py to allow also loading out-of-tree extensions in non-cmake builds, after that
60: //		 these can be removed
61: #if DUCKDB_EXTENSION_ICU_LINKED
62: #include "icu_extension.hpp"
63: #endif
64: 
65: #if DUCKDB_EXTENSION_PARQUET_LINKED
66: #include "parquet_extension.hpp"
67: #endif
68: 
69: #if DUCKDB_EXTENSION_TPCH_LINKED
70: #include "tpch_extension.hpp"
71: #endif
72: 
73: #if DUCKDB_EXTENSION_TPCDS_LINKED
74: #include "tpcds_extension.hpp"
75: #endif
76: 
77: #if DUCKDB_EXTENSION_FTS_LINKED
78: #include "fts_extension.hpp"
79: #endif
80: 
81: #if DUCKDB_EXTENSION_HTTPFS_LINKED
82: #include "httpfs_extension.hpp"
83: #endif
84: 
85: #if DUCKDB_EXTENSION_JSON_LINKED
86: #include "json_extension.hpp"
87: #endif
88: 
89: #if DUCKDB_EXTENSION_JEMALLOC_LINKED
90: #include "jemalloc_extension.hpp"
91: #endif
92: 
93: #if DUCKDB_EXTENSION_AUTOCOMPLETE_LINKED
94: #include "autocomplete_extension.hpp"
95: #endif
96: #endif
97: 
98: namespace duckdb {
99: 
100: //===--------------------------------------------------------------------===//
101: // Default Extensions
102: //===--------------------------------------------------------------------===//
103: static const DefaultExtension internal_extensions[] = {
104:     {"icu", "Adds support for time zones and collations using the ICU library", DUCKDB_EXTENSION_ICU_LINKED},
105:     {"excel", "Adds support for Excel-like format strings", DUCKDB_EXTENSION_EXCEL_LINKED},
106:     {"parquet", "Adds support for reading and writing parquet files", DUCKDB_EXTENSION_PARQUET_LINKED},
107:     {"tpch", "Adds TPC-H data generation and query support", DUCKDB_EXTENSION_TPCH_LINKED},
108:     {"tpcds", "Adds TPC-DS data generation and query support", DUCKDB_EXTENSION_TPCDS_LINKED},
109:     {"fts", "Adds support for Full-Text Search Indexes", DUCKDB_EXTENSION_FTS_LINKED},
110:     {"httpfs", "Adds support for reading and writing files over a HTTP(S) connection", DUCKDB_EXTENSION_HTTPFS_LINKED},
111:     {"json", "Adds support for JSON operations", DUCKDB_EXTENSION_JSON_LINKED},
112:     {"jemalloc", "Overwrites system allocator with JEMalloc", DUCKDB_EXTENSION_JEMALLOC_LINKED},
113:     {"autocomplete", "Adds support for autocomplete in the shell", DUCKDB_EXTENSION_AUTOCOMPLETE_LINKED},
114:     {"motherduck", "Enables motherduck integration with the system", false},
115:     {"mysql_scanner", "Adds support for connecting to a MySQL database", false},
116:     {"sqlite_scanner", "Adds support for reading and writing SQLite database files", false},
117:     {"postgres_scanner", "Adds support for connecting to a Postgres database", false},
118:     {"inet", "Adds support for IP-related data types and functions", false},
119:     {"spatial", "Geospatial extension that adds support for working with spatial data and functions", false},
120:     {"substrait", "Adds support for the Substrait integration", false},
121:     {"aws", "Provides features that depend on the AWS SDK", false},
122:     {"arrow", "A zero-copy data integration between Apache Arrow and DuckDB", false},
123:     {"azure", "Adds a filesystem abstraction for Azure blob storage to DuckDB", false},
124:     {"iceberg", "Adds support for Apache Iceberg", false},
125:     {"vss", "Adds indexing support to accelerate Vector Similarity Search", false},
126:     {"delta", "Adds support for Delta Lake", false},
127:     {nullptr, nullptr, false}};
128: 
129: idx_t ExtensionHelper::DefaultExtensionCount() {
130: 	idx_t index;
131: 	for (index = 0; internal_extensions[index].name != nullptr; index++) {
132: 	}
133: 	return index;
134: }
135: 
136: DefaultExtension ExtensionHelper::GetDefaultExtension(idx_t index) {
137: 	D_ASSERT(index < DefaultExtensionCount());
138: 	return internal_extensions[index];
139: }
140: 
141: //===--------------------------------------------------------------------===//
142: // Allow Auto-Install Extensions
143: //===--------------------------------------------------------------------===//
144: static const char *const auto_install[] = {"motherduck", "postgres_scanner", "mysql_scanner", "sqlite_scanner",
145:                                            nullptr};
146: 
147: // TODO: unify with new autoload mechanism
148: bool ExtensionHelper::AllowAutoInstall(const string &extension) {
149: 	auto lcase = StringUtil::Lower(extension);
150: 	for (idx_t i = 0; auto_install[i]; i++) {
151: 		if (lcase == auto_install[i]) {
152: 			return true;
153: 		}
154: 	}
155: 	return false;
156: }
157: 
158: bool ExtensionHelper::CanAutoloadExtension(const string &ext_name) {
159: #ifdef DUCKDB_DISABLE_EXTENSION_LOAD
160: 	return false;
161: #endif
162: 
163: 	if (ext_name.empty()) {
164: 		return false;
165: 	}
166: 	for (const auto &ext : AUTOLOADABLE_EXTENSIONS) {
167: 		if (ext_name == ext) {
168: 			return true;
169: 		}
170: 	}
171: 	return false;
172: }
173: 
174: string ExtensionHelper::AddExtensionInstallHintToErrorMsg(ClientContext &context, const string &base_error,
175:                                                           const string &extension_name) {
176: 
177: 	return AddExtensionInstallHintToErrorMsg(DBConfig::GetConfig(context), base_error, extension_name);
178: }
179: string ExtensionHelper::AddExtensionInstallHintToErrorMsg(DBConfig &config, const string &base_error,
180:                                                           const string &extension_name) {
181: 	string install_hint;
182: 
183: 	if (!ExtensionHelper::CanAutoloadExtension(extension_name)) {
184: 		install_hint = "Please try installing and loading the " + extension_name + " extension:\nINSTALL " +
185: 		               extension_name + ";\nLOAD " + extension_name + ";\n\n";
186: 	} else if (!config.options.autoload_known_extensions) {
187: 		install_hint =
188: 		    "Please try installing and loading the " + extension_name + " extension by running:\nINSTALL " +
189: 		    extension_name + ";\nLOAD " + extension_name +
190: 		    ";\n\nAlternatively, consider enabling auto-install "
191: 		    "and auto-load by running:\nSET autoinstall_known_extensions=1;\nSET autoload_known_extensions=1;";
192: 	} else if (!config.options.autoinstall_known_extensions) {
193: 		install_hint =
194: 		    "Please try installing the " + extension_name + " extension by running:\nINSTALL " + extension_name +
195: 		    ";\n\nAlternatively, consider enabling autoinstall by running:\nSET autoinstall_known_extensions=1;";
196: 	}
197: 
198: 	if (!install_hint.empty()) {
199: 		return base_error + "\n\n" + install_hint;
200: 	}
201: 
202: 	return base_error;
203: }
204: 
205: bool ExtensionHelper::TryAutoLoadExtension(ClientContext &context, const string &extension_name) noexcept {
206: 	if (context.db->ExtensionIsLoaded(extension_name)) {
207: 		return true;
208: 	}
209: 	auto &dbconfig = DBConfig::GetConfig(context);
210: 	try {
211: 		if (dbconfig.options.autoinstall_known_extensions) {
212: 			auto &config = DBConfig::GetConfig(context);
213: 			auto autoinstall_repo = ExtensionRepository::GetRepositoryByUrl(config.options.autoinstall_extension_repo);
214: 			ExtensionHelper::InstallExtension(context, extension_name, false, autoinstall_repo, false);
215: 		}
216: 		ExtensionHelper::LoadExternalExtension(context, extension_name);
217: 		return true;
218: 	} catch (...) {
219: 		return false;
220: 	}
221: }
222: 
223: static ExtensionUpdateResult UpdateExtensionInternal(ClientContext &context, DatabaseInstance &db, FileSystem &fs,
224:                                                      const string &full_extension_path, const string &extension_name) {
225: 	ExtensionUpdateResult result;
226: 	result.extension_name = extension_name;
227: 
228: 	auto &config = DBConfig::GetConfig(db);
229: 
230: 	if (!fs.FileExists(full_extension_path)) {
231: 		result.tag = ExtensionUpdateResultTag::NOT_INSTALLED;
232: 		return result;
233: 	}
234: 
235: 	// Extension exists, check for .info file
236: 	const string info_file_path = full_extension_path + ".info";
237: 	if (!fs.FileExists(info_file_path)) {
238: 		result.tag = ExtensionUpdateResultTag::MISSING_INSTALL_INFO;
239: 		return result;
240: 	}
241: 
242: 	// Parse the version of the extension before updating
243: 	auto ext_binary_handle = fs.OpenFile(full_extension_path, FileOpenFlags::FILE_FLAGS_READ);
244: 	auto parsed_metadata = ExtensionHelper::ParseExtensionMetaData(*ext_binary_handle);
245: 	if (!parsed_metadata.AppearsValid() && !config.options.allow_extensions_metadata_mismatch) {
246: 		throw IOException(
247: 		    "Failed to update extension: '%s', the metadata of the extension appears invalid! To resolve this, either "
248: 		    "reinstall the extension using 'FORCE INSTALL %s', manually remove the file '%s', or enable '"
249: 		    "SET allow_extensions_metadata_mismatch=true'",
250: 		    extension_name, extension_name, full_extension_path);
251: 	}
252: 
253: 	result.prev_version = parsed_metadata.AppearsValid() ? parsed_metadata.extension_version : "";
254: 
255: 	auto extension_install_info = ExtensionInstallInfo::TryReadInfoFile(fs, info_file_path, extension_name);
256: 
257: 	// Early out: no info file found
258: 	if (extension_install_info->mode == ExtensionInstallMode::UNKNOWN) {
259: 		result.tag = ExtensionUpdateResultTag::MISSING_INSTALL_INFO;
260: 		return result;
261: 	}
262: 
263: 	// Early out: we can only update extensions from repositories
264: 	if (extension_install_info->mode != ExtensionInstallMode::REPOSITORY) {
265: 		result.tag = ExtensionUpdateResultTag::NOT_A_REPOSITORY;
266: 		result.installed_version = result.prev_version;
267: 		return result;
268: 	}
269: 
270: 	auto repository_from_info = ExtensionRepository::GetRepositoryByUrl(extension_install_info->repository_url);
271: 	result.repository = repository_from_info.ToReadableString();
272: 
273: 	// We force install the full url found in this file, throwing
274: 	unique_ptr<ExtensionInstallInfo> install_result;
275: 	try {
276: 		install_result = ExtensionHelper::InstallExtension(context, extension_name, true, repository_from_info);
277: 	} catch (std::exception &e) {
278: 		ErrorData error(e);
279: 		error.Throw("Extension updating failed when trying to install '" + extension_name + "', original error: ");
280: 	}
281: 
282: 	result.installed_version = install_result->version;
283: 
284: 	if (result.installed_version.empty()) {
285: 		result.tag = ExtensionUpdateResultTag::REDOWNLOADED;
286: 	} else if (result.installed_version != result.prev_version) {
287: 		result.tag = ExtensionUpdateResultTag::UPDATED;
288: 	} else {
289: 		result.tag = ExtensionUpdateResultTag::NO_UPDATE_AVAILABLE;
290: 	}
291: 
292: 	return result;
293: }
294: 
295: vector<ExtensionUpdateResult> ExtensionHelper::UpdateExtensions(ClientContext &context) {
296: 	auto &fs = FileSystem::GetFileSystem(context);
297: 
298: 	vector<ExtensionUpdateResult> result;
299: 	DatabaseInstance &db = DatabaseInstance::GetDatabase(context);
300: 
301: 	auto &config = DBConfig::GetConfig(db);
302: 
303: #ifndef WASM_LOADABLE_EXTENSIONS
304: 	case_insensitive_set_t seen_extensions;
305: 
306: 	// scan the install directory for installed extensions
307: 	auto ext_directory = ExtensionHelper::ExtensionDirectory(config, fs);
308: 	fs.ListFiles(ext_directory, [&](const string &path, bool is_directory) {
309: 		if (!StringUtil::EndsWith(path, ".duckdb_extension")) {
310: 			return;
311: 		}
312: 
313: 		auto extension_file_name = StringUtil::GetFileName(path);
314: 		auto extension_name = StringUtil::Split(extension_file_name, ".")[0];
315: 
316: 		seen_extensions.insert(extension_name);
317: 
318: 		result.push_back(UpdateExtensionInternal(context, db, fs, fs.JoinPath(ext_directory, path), extension_name));
319: 	});
320: #endif
321: 
322: 	return result;
323: }
324: 
325: ExtensionUpdateResult ExtensionHelper::UpdateExtension(ClientContext &context, const string &extension_name) {
326: 	auto &fs = FileSystem::GetFileSystem(context);
327: 	DatabaseInstance &db = DatabaseInstance::GetDatabase(context);
328: 	auto &config = DBConfig::GetConfig(db);
329: 	auto ext_directory = ExtensionHelper::ExtensionDirectory(config, fs);
330: 
331: 	auto full_extension_path = fs.JoinPath(ext_directory, extension_name + ".duckdb_extension");
332: 
333: 	auto update_result = UpdateExtensionInternal(context, db, fs, full_extension_path, extension_name);
334: 
335: 	if (update_result.tag == ExtensionUpdateResultTag::NOT_INSTALLED) {
336: 		throw InvalidInputException("Failed to update the extension '%s', the extension is not installed!",
337: 		                            extension_name);
338: 	} else if (update_result.tag == ExtensionUpdateResultTag::UNKNOWN) {
339: 		throw InternalException("Failed to update extension '%s', an unknown error ocurred", extension_name);
340: 	}
341: 	return update_result;
342: }
343: 
344: void ExtensionHelper::AutoLoadExtension(ClientContext &context, const string &extension_name) {
345: 	return ExtensionHelper::AutoLoadExtension(*context.db, extension_name);
346: }
347: 
348: void ExtensionHelper::AutoLoadExtension(DatabaseInstance &db, const string &extension_name) {
349: 	if (db.ExtensionIsLoaded(extension_name)) {
350: 		// Avoid downloading again
351: 		return;
352: 	}
353: 	auto &dbconfig = DBConfig::GetConfig(db);
354: 	try {
355: 		auto fs = FileSystem::CreateLocal();
356: #ifndef DUCKDB_WASM
357: 		if (dbconfig.options.autoinstall_known_extensions) {
358: 			//! Get the autoloading repository
359: 			auto repository = ExtensionRepository::GetRepositoryByUrl(dbconfig.options.autoinstall_extension_repo);
360: 			ExtensionHelper::InstallExtension(db.config, *fs, extension_name, false, repository);
361: 		}
362: #endif
363: 		ExtensionHelper::LoadExternalExtension(db, *fs, extension_name);
364: 	} catch (std::exception &e) {
365: 		ErrorData error(e);
366: 		throw AutoloadException(extension_name, error.RawMessage());
367: 	}
368: }
369: 
370: //===--------------------------------------------------------------------===//
371: // Load Statically Compiled Extension
372: //===--------------------------------------------------------------------===//
373: void ExtensionHelper::LoadAllExtensions(DuckDB &db) {
374: 	// The in-tree extensions that we check. Non-cmake builds are currently limited to these for static linking
375: 	// TODO: rewrite package_build.py to allow also loading out-of-tree extensions in non-cmake builds, after that
376: 	//		 these can be removed
377: 	unordered_set<string> extensions {"parquet", "icu",   "tpch", "tpcds",    "fts",         "httpfs",
378: 	                                  "json",    "excel", "inet", "jemalloc", "autocomplete"};
379: 	for (auto &ext : extensions) {
380: 		LoadExtensionInternal(db, ext, true);
381: 	}
382: 
383: #if defined(GENERATED_EXTENSION_HEADERS) && GENERATED_EXTENSION_HEADERS
384: 	for (const auto &ext : LinkedExtensions()) {
385: 		LoadExtensionInternal(db, ext, true);
386: 	}
387: #endif
388: }
389: 
390: ExtensionLoadResult ExtensionHelper::LoadExtension(DuckDB &db, const std::string &extension) {
391: 	return LoadExtensionInternal(db, extension, false);
392: }
393: 
394: ExtensionLoadResult ExtensionHelper::LoadExtensionInternal(DuckDB &db, const std::string &extension,
395:                                                            bool initial_load) {
396: #ifdef DUCKDB_TEST_REMOTE_INSTALL
397: 	if (!initial_load && StringUtil::Contains(DUCKDB_TEST_REMOTE_INSTALL, extension)) {
398: 		Connection con(db);
399: 		auto result = con.Query("INSTALL " + extension);
400: 		if (result->HasError()) {
401: 			result->Print();
402: 			return ExtensionLoadResult::EXTENSION_UNKNOWN;
403: 		}
404: 		result = con.Query("LOAD " + extension);
405: 		if (result->HasError()) {
406: 			result->Print();
407: 			return ExtensionLoadResult::EXTENSION_UNKNOWN;
408: 		}
409: 		return ExtensionLoadResult::LOADED_EXTENSION;
410: 	}
411: #endif
412: 
413: #ifdef DUCKDB_EXTENSIONS_TEST_WITH_LOADABLE
414: 	// Note: weird comma's are on purpose to do easy string contains on a list of extension names
415: 	if (!initial_load && StringUtil::Contains(DUCKDB_EXTENSIONS_TEST_WITH_LOADABLE, "," + extension + ",")) {
416: 		Connection con(db);
417: 		auto result = con.Query((string) "LOAD '" + DUCKDB_EXTENSIONS_BUILD_PATH + "/" + extension + "/" + extension +
418: 		                        ".duckdb_extension'");
419: 		if (result->HasError()) {
420: 			result->Print();
421: 			return ExtensionLoadResult::EXTENSION_UNKNOWN;
422: 		}
423: 		return ExtensionLoadResult::LOADED_EXTENSION;
424: 	}
425: #endif
426: 
427: 	// This is the main extension loading mechanism that loads the extension that are statically linked.
428: #if defined(GENERATED_EXTENSION_HEADERS) && GENERATED_EXTENSION_HEADERS
429: 	if (TryLoadLinkedExtension(db, extension)) {
430: 		return ExtensionLoadResult::LOADED_EXTENSION;
431: 	} else {
432: 		return ExtensionLoadResult::NOT_LOADED;
433: 	}
434: #endif
435: 
436: 	// This is the fallback to the "old" extension loading mechanism for non-cmake builds
437: 	// TODO: rewrite package_build.py to allow also loading out-of-tree extensions in non-cmake builds
438: 	if (extension == "parquet") {
439: #if DUCKDB_EXTENSION_PARQUET_LINKED
440: 		db.LoadStaticExtension<ParquetExtension>();
441: #else
442: 		// parquet extension required but not build: skip this test
443: 		return ExtensionLoadResult::NOT_LOADED;
444: #endif
445: 	} else if (extension == "icu") {
446: #if DUCKDB_EXTENSION_ICU_LINKED
447: 		db.LoadStaticExtension<IcuExtension>();
448: #else
449: 		// icu extension required but not build: skip this test
450: 		return ExtensionLoadResult::NOT_LOADED;
451: #endif
452: 	} else if (extension == "tpch") {
453: #if DUCKDB_EXTENSION_TPCH_LINKED
454: 		db.LoadStaticExtension<TpchExtension>();
455: #else
456: 		// icu extension required but not build: skip this test
457: 		return ExtensionLoadResult::NOT_LOADED;
458: #endif
459: 	} else if (extension == "tpcds") {
460: #if DUCKDB_EXTENSION_TPCDS_LINKED
461: 		db.LoadStaticExtension<TpcdsExtension>();
462: #else
463: 		// icu extension required but not build: skip this test
464: 		return ExtensionLoadResult::NOT_LOADED;
465: #endif
466: 	} else if (extension == "fts") {
467: #if DUCKDB_EXTENSION_FTS_LINKED
468: //		db.LoadStaticExtension<FtsExtension>();
469: #else
470: 		// fts extension required but not build: skip this test
471: 		return ExtensionLoadResult::NOT_LOADED;
472: #endif
473: 	} else if (extension == "httpfs") {
474: #if DUCKDB_EXTENSION_HTTPFS_LINKED
475: 		db.LoadStaticExtension<HttpfsExtension>();
476: #else
477: 		return ExtensionLoadResult::NOT_LOADED;
478: #endif
479: 	} else if (extension == "json") {
480: #if DUCKDB_EXTENSION_JSON_LINKED
481: 		db.LoadStaticExtension<JsonExtension>();
482: #else
483: 		// json extension required but not build: skip this test
484: 		return ExtensionLoadResult::NOT_LOADED;
485: #endif
486: 	} else if (extension == "excel") {
487: #if DUCKDB_EXTENSION_EXCEL_LINKED
488: 		db.LoadStaticExtension<ExcelExtension>();
489: #else
490: 		// excel extension required but not build: skip this test
491: 		return ExtensionLoadResult::NOT_LOADED;
492: #endif
493: 	} else if (extension == "jemalloc") {
494: #if DUCKDB_EXTENSION_JEMALLOC_LINKED
495: 		db.LoadStaticExtension<JemallocExtension>();
496: #else
497: 		// jemalloc extension required but not build: skip this test
498: 		return ExtensionLoadResult::NOT_LOADED;
499: #endif
500: 	} else if (extension == "autocomplete") {
501: #if DUCKDB_EXTENSION_AUTOCOMPLETE_LINKED
502: 		db.LoadStaticExtension<AutocompleteExtension>();
503: #else
504: 		// autocomplete extension required but not build: skip this test
505: 		return ExtensionLoadResult::NOT_LOADED;
506: #endif
507: 	} else if (extension == "inet") {
508: #if DUCKDB_EXTENSION_INET_LINKED
509: 		db.LoadStaticExtension<InetExtension>();
510: #else
511: 		// inet extension required but not build: skip this test
512: 		return ExtensionLoadResult::NOT_LOADED;
513: #endif
514: 	}
515: 
516: 	return ExtensionLoadResult::LOADED_EXTENSION;
517: }
518: 
519: static const char *const public_keys[] = {
520:     R"(
521: -----BEGIN PUBLIC KEY-----
522: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6aZuHUa1cLR9YDDYaEfi
523: UDbWY8m2t7b71S+k1ZkXfHqu+5drAxm+dIDzdOHOKZSIdwnJbT3sSqwFoG6PlXF3
524: g3dsJjax5qESIhbVvf98nyipwNINxoyHCkcCIPkX17QP2xpnT7V59+CqcfDJXLqB
525: ymjqoFSlaH8dUCHybM4OXlWnAtVHW/nmw0khF8CetcWn4LxaTUHptByaBz8CasSs
526: gWpXgSfaHc3R9eArsYhtsVFGyL/DEWgkEHWolxY3Llenhgm/zOf3s7PsAMe7EJX4
527: qlSgiXE6OVBXnqd85z4k20lCw/LAOe5hoTMmRWXIj74MudWe2U91J6GrrGEZa7zT
528: 7QIDAQAB
529: -----END PUBLIC KEY-----
530: )",
531:     R"(
532: -----BEGIN PUBLIC KEY-----
533: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq8Gg1S/LI6ApMAYsFc9m
534: PrkFIY+nc0LXSpxm77twU8D5M0Xkz/Av4f88DQmj1OE3164bEtR7sl7xDPZojFHj
535: YYyucJxEI97l5OU1d3Pc1BdKXL4+mnW5FlUGj218u8qD+G1hrkySXQkrUzIjPPNw
536: o6knF3G/xqQF+KI+tc7ajnTni8CAlnUSxfnstycqbVS86m238PLASVPK9/SmIRgO
537: XCEV+ZNMlerq8EwsW4cJPHH0oNVMcaG+QT4z79roW1rbJghn9ubAVdQU6VLUAikI
538: b8keUyY+D0XdY9DpDBeiorb1qPYt8BPLOAQrIUAw1CgpMM9KFp9TNvW47KcG4bcB
539: dQIDAQAB
540: -----END PUBLIC KEY-----
541: )",
542:     R"(
543: -----BEGIN PUBLIC KEY-----
544: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyYATA9KOQ0Azf97QAPfY
545: Jc/WeZyE4E1qlRgKWKqNtYSXZqk5At0V7w2ntAWtYSpczFrVepCJ0oPMDpZTigEr
546: NgOgfo5LEhPx5XmtCf62xY/xL3kgtfz9Mm5TBkuQy4KwY4z1npGr4NYYDXtF7kkf
547: LQE+FnD8Yr4E0wHBib7ey7aeeKWmwqvUjzDqG+TzaqwzO/RCUsSctqSS0t1oo2hv
548: 4q1ofanUXsV8MXk/ujtgxu7WkVvfiSpK1zRazgeZjcrQFO9qL/pla0vBUxa1U8He
549: GMLnL0oRfcMg7yKrbIMrvlEl2ZmiR9im44dXJWfY42quObwr1PuEkEoCMcMisSWl
550: jwIDAQAB
551: -----END PUBLIC KEY-----
552: )",
553:     R"(
554: -----BEGIN PUBLIC KEY-----
555: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4RvbWx3zLblDHH/lGUF5
556: Q512MT+v3YPriuibROMllv8WiCLAMeJ0QXbVaIzBOeHDeLx8yvoZZN+TENKxtT6u
557: IfMMneUzxHBqy0AQNfIsSsOnG5nqoeE/AwbS6VqCdH1aLfoCoPffacHYa0XvTcsi
558: aVlZfr+UzJS+ty8pRmFVi1UKSOADDdK8XfIovJl/zMP2TxYX2Y3fnjeLtl8Sqs2e
559: P+eHDoy7Wi4EPTyY7tNTCfxwKNHn1HQ5yrv5dgvMxFWIWXGz24yikFvtwLGHe8uJ
560: Wi+fBX+0PF0diZ6pIthZ149VU8qCqYAXjgpxZ0EZdrsiF6Ewz0cfg20SYApFcmW4
561: pwIDAQAB
562: -----END PUBLIC KEY-----
563: )",
564:     R"(
565: -----BEGIN PUBLIC KEY-----
566: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyhd5AfwrUohG3O4DE0K9
567: O3FmgB7zE4aDnkL8UUfGCh5kdP8q7ewMjekY+c6LwWOmpdJpSwqhfV1q5ZU1l6rk
568: 3hlt03LO3sgs28kcfOVH15hqfxts6Sg5KcRjxStE50ORmXGwXDcS9vqkJ60J1EHA
569: lcZqbCRSO73ZPLhdepfd0/C6tM0L7Ge6cAE62/MTmYNGv8fDzwQr/kYIJMdoS8Zp
570: thRpctFZJtPs3b0fffZA/TCLVKMvEVgTWs48751qKid7N/Lm/iEGx/tOf4o23Nec
571: Pz1IQaGLP+UOLVQbqQBHJWNOqigm7kWhDgs3N4YagWgxPEQ0WVLtFji/ZjlKZc7h
572: dwIDAQAB
573: -----END PUBLIC KEY-----
574: )",
575:     R"(
576: -----BEGIN PUBLIC KEY-----
577: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnFDg3LhyV6BVE2Z3zQvN
578: 6urrKvPhygTa5+wIPGwYTzJ8DfGALqlsX3VOXMvcJTca6SbuwwkoXHuSU5wQxfcs
579: bt4jTXD3NIoRwQPl+D9IbgIMuX0ACl27rJmr/f9zkY7qui4k1X82pQkxBe+/qJ4r
580: TBwVNONVx1fekTMnSCEhwg5yU3TNbkObu0qlQeJfuMWLDQbW/8v/qfr/Nz0JqHDN
581: yYKfKvFMlORxyJYiOyeOsbzNGEhkGQGOmKhRUhS35kD+oA0jqwPwMCM9O4kFg/L8
582: iZbpBBX2By1K3msejWMRAewTOyPas6YMQOYq9BMmWQqzVtG5xcaSJwN/YnMpJyqb
583: sQIDAQAB
584: -----END PUBLIC KEY-----
585: )",
586:     R"(
587: -----BEGIN PUBLIC KEY-----
588: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1z0RU8vGrfEkrscEoZKA
589: GiOcGh2EMcKwjQpl4nKuR9H4o/dg+CZregVSHg7MP2f8mhLZZyoFev49oWOV4Rmi
590: qs99UNxm7DyKW1fF1ovowsUW5lsDoKYLvpuzHo0s4laiV4AnIYP7tHGLdzsnK2Os
591: Cp5dSuMwKHPZ9N25hXxFB/dRrAdIiXHvbSqr4N29XzfQloQpL3bGHLKY6guFHluH
592: X5dJ9eirVakWWou7BR2rnD0k9vER6oRdVnJ6YKb5uhWEOQ3NmV961oyr+uiDTcep
593: qqtGHWuFhENixtiWGjFJJcACwqxEAW3bz9lyrfnPDsHSW/rlQVDIAkik+fOp+R7L
594: kQIDAQAB
595: -----END PUBLIC KEY-----
596: )",
597:     R"(
598: -----BEGIN PUBLIC KEY-----
599: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxwO27e1vnbNcpiDg7Wwx
600: K/w5aEGukXotu3529ieq+O39H0+Bak4vIbzGhDUh3/ElmxaFMAs4PYrWe/hc2WFD
601: H4JCOoFIn4y9gQeE855DGGFgeIVd1BnSs5S+5wUEMxLNyHdHSmINN6FsoZ535iUg
602: KdYjRh1iZevezg7ln8o/O36uthu925ehFBXSy6jLJgQlwmq0KxZJE0OAZhuDBM60
603: MtIunNa/e5y+Gw3GknFwtRLmn/nEckZx1nEtepYvvUa7UGy+8KuGuhOerCZTutbG
604: k8liCVgGenRve8unA2LrBbpL+AUf3CrZU/uAxxTqWmw6Z/S6TeW5ozeeyOCh8ii6
605: TwIDAQAB
606: -----END PUBLIC KEY-----
607: )",
608:     R"(
609: -----BEGIN PUBLIC KEY-----
610: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsGIFOfIQ4RI5qu4klOxf
611: ge6eXwBMAkuTXyhyIIJDtE8CurnwQvUXVlt+Kf0SfuIFW6MY5ErcWE/vMFbc81IR
612: 9wByOAAV2CTyiLGZT63uE8pN6FSHd6yGYCLjXd3P3cnP3Qj5pBncpLuAUDfHG4wP
613: bs9jIADw3HysD+eCNja8p7ZC7CzWxTcO7HsEu9deAAU19YywdpagXvQ0pJ9zV5qU
614: jrHxBygl31t6TmmX+3d+azjGu9Hu36E+5wcSOOhuwAFXDejb40Ixv53ItJ3fZzzH
615: PF2nj9sQvQ8c5ptjyOvQCBRdqkEWXIVHClxqWb+o59pDIh1G0UGcmiDN7K9Gz5HA
616: ZQIDAQAB
617: -----END PUBLIC KEY-----
618: )",
619:     R"(
620: -----BEGIN PUBLIC KEY-----
621: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAt9uUnlW/CoUXT68yaZh9
622: SeXHzGRCPNEI98Tara+dgYxDX1z7nfOh8o15liT0QsAzx34EewZOxcKCNiV/dZX5
623: z4clCkD8uUbZut6IVx8Eu+7Qcd5jZthRc6hQrN9Ltv7ZQEh7KGXOHa53kT2K01ws
624: 4jbVmd/7Nx7y0Yyqhja01pIu/CUaTkODfQxBXwriLdIzp7y/iJeF/TLqCwZWHKQx
625: QOZnsPEveB1F00Va9MeAtTlXFUJ/TQXquqTjeLj4HuIRtbyuNgWoc0JyF+mcafAl
626: bnrNEBIfxZhAT81aUCIAzRJp6AqfdeZxnZ/WwohtZQZLXAxFQPTWCcP+Z9M7OIQL
627: WwIDAQAB
628: -----END PUBLIC KEY-----
629: )",
630:     R"(
631: -----BEGIN PUBLIC KEY-----
632: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA56NhfACkeCyZM07l2wmd
633: iTp24E2tLLKU3iByKlIRWRAvXsOejRMJTHTNHWa3cQ7uLP++Tf2St7ksNsyPMNZy
634: 9QRTLNCYr9rN9loLwdb2sMWxFBwwzCaAOTahGI7GJQy30UB7FEND0X/5U2rZvQij
635: Q6K+O4aa+K9M5qyOHNMmXywmTnAgWKNaNxQHPRtD2+dSj60T6zXdtIuCrPfcNGg5
636: gj07qWGEXX83V/L7nSqCiIVYg/wqds1x52Yjk1nhXYNBTqlnhmOd8LynGxz/sXC7
637: h2Q9XsHjXIChW4FHyLIOl6b4zPMBSxzCigYm3QZJWfAkZv5PBRtnq7vhYOLHzLQj
638: CwIDAQAB
639: -----END PUBLIC KEY-----
640: )",
641:     R"(
642: -----BEGIN PUBLIC KEY-----
643: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmfPLe0IWGYC0MZC6YiM3
644: QGfhT6zSKB0I2DW44nlBlWUcF+32jW2bFJtgE76qGGKFeU4kJBWYr99ufHoAodNg
645: M1Ehl/JfQ5KmbC1WIqnFTrgbmqJde79jeCvCpbFLuqnzidwO1PbXDbfRFQcgWaXT
646: mDVLNNVmLxA0GkCv+kydE2gtcOD9BDceg7F/56TDvclyI5QqAnjE2XIRMPZlXQP4
647: oF2kgz4Cn7LxLHYmkU2sS9NYLzHoyUqFplWlxkQjA4eQ0neutV1Ydmc1IX8W7R38
648: A7nFtaT8iI8w6Vkv7ijYN6xf5cVBPKZ3Dv7AdwPet86JD5mf5v+r7iwg5xl3r77Z
649: iwIDAQAB
650: -----END PUBLIC KEY-----
651: )",
652:     R"(
653: -----BEGIN PUBLIC KEY-----
654: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoB1kWsX8YmCcFOD9ilBY
655: xK076HmUAN026uJ8JpmU9Hz+QT1FNXOsnj1h2G6U6btYVIdHUTHy/BvAumrDKqRz
656: qcEAzCuhxUjPjss54a/Zqu6nQcoIPHuG/Er39oZHIVkPR1WCvWj8wmyYv6T//dPH
657: unO6tW29sXXxS+J1Gah6vpbtJw1pI/liah1DZzb13KWPDI6ZzviTNnW4S05r6js/
658: 30He+Yud6aywrdaP/7G90qcrteEFcjFy4Xf+5vG960oKoGoDplwX5poay1oCP9tb
659: g8AC8VSRAGi3oviTeSWZcrLXS8AtJhGvF48cXQj2q+8YeVKVDpH6fPQxJ9Sh9aeU
660: awIDAQAB
661: -----END PUBLIC KEY-----
662: )",
663:     R"(
664: -----BEGIN PUBLIC KEY-----
665: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4NTMAIYIlCMID00ufy/I
666: AZXc8pocDx9N1Q5x5/cL3aIpLmx02AKo9BvTJaJuHiTjlwYhPtlhIrHV4HUVTkOX
667: sISp8B8v9i2I1RIvCTAcvy3gcH6rdRWZ0cdTUiMEqnnxBX9zdzl8oMzZcyauv19D
668: BeqJvzflIT96b8g8K3mvgJHs9a1j9f0gN8FuTA0c52DouKnrh8UwH7mlrumYerJw
669: 6goJGQuK1HEOt6bcQuvogkbgJWOoEYwjNrPwQvIcP4wyrgSnOHg1yXOFE84oVynJ
670: czQEOz9ke42I3h8wrnQxilEYBVo2uX8MenqTyfGnE32lPRt3Wv1iEVQls8Cxiuy2
671: CQIDAQAB
672: -----END PUBLIC KEY-----
673: )",
674:     R"(
675: -----BEGIN PUBLIC KEY-----
676: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3bUtfp66OtRyvIF/oucn
677: id8mo7gvbNEH04QMLO3Ok43dlWgWI3hekJAqOYc0mvoI5anqr98h8FI7aCYZm/bY
678: vpz0I1aXBaEPh3aWh8f/w9HME7ykBvmhMe3J+VFGWWL4eswfRl//GCtnSMBzDFhM
679: SaQOTvADWHkC0njeI5yXjf/lNm6fMACP1cnhuvCtnx7VP/DAtvUk9usDKG56MJnZ
680: UoVM3HHjbJeRwxCdlSWe12ilCdwMRKSDY92Hk38/zBLenH04C3HRQLjBGewACUmx
681: uvNInehZ4kSYFGa+7UxBxFtzJhlKzGR73qUjpWzZivCe1K0WfRVP5IWsKNCCESJ/
682: nQIDAQAB
683: -----END PUBLIC KEY-----
684: )",
685:     R"(
686: -----BEGIN PUBLIC KEY-----
687: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyV2dE/CRUAUE8ybq/DoS
688: Lc7QlYXh04K+McbhN724TbHahLTuDk5mR5TAunA8Nea4euRzknKdMFAz1eh9gyy3
689: 5x4UfXQW1fIZqNo6WNrGxYJgWAXU+pov+OvxsMQWzqS4jrTHDHbblCCLKp1akwJk
690: aFNyqgjAL373PcqXC+XAn8vHx4xHFoFP5lq4lLcJCOW5ee9v9El3w0USLwS+t1cF
691: RY3kuV6Njlr4zsRH9iM6/zaSuCALYWJ/JrPEurSJXzFZnWsvn6aQdeNeAn08+z0F
692: k2NwaauEo0xmLqzqTRGzjHqKKmeefN3/+M/FN2FrApDlxWQfhD2Y3USdAiN547Nj
693: 1wIDAQAB
694: -----END PUBLIC KEY-----
695: )",
696:     R"(
697: -----BEGIN PUBLIC KEY-----
698: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvm2+kTrEQWZXuxhWzBdl
699: PCbQGqbrukbeS6JKSlQLJDC8ayZIxFxatqg1Q8UPyv89MVRsHOGlG1OqFaOEtPjQ
700: Oo6j/moFwB4GPyJhJHOGpCKa4CLB5clhfDCLJw6ty7PcDU3T6yW4X4Qc5k4LRRWy
701: yzC8lVHfBdarN+1iEe0ALMOGoeiJjVn6i/AFxktRwgd8njqv/oWQyfjJZXkNMsb6
702: 7ZDxNVAUrp/WXpE4Kq694bB9xa/pWsqv7FjQJUgTnEzvbN+qXnVPtA7dHcOYYJ8Z
703: SbrJUfHrf8TS5B54AiopFpWG+hIbjqqdigqabBqFpmjiRDZgDy4zJJj52xJZMnrp
704: rwIDAQAB
705: -----END PUBLIC KEY-----
706: )",
707:     R"(
708: -----BEGIN PUBLIC KEY-----
709: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwEAcVmY3589O02pLA22f
710: MlarLyJUgy0BeJDG5AUsi17ct8sHZzRiv9zKQVCBk1CtZY//jyqnrM7iCBLWsyby
711: TiTOtGYHHApaLnNjjtaHdQ6zplhbc3g2XLy+4ab8GNKG3zc8iXpsQM6r+JO5n9pm
712: V9vollz9dkFxS9l+1P17lZdIgCh9O3EIFJv5QCd5c9l2ezHAan2OhkWhiDtldnH/
713: MfRXbz7X5sqlwWLa/jhPtvY45x7dZaCHGqNzbupQZs0vHnAVdDu3vAWDmT/3sXHG
714: vmGxswKA9tPU0prSvQWLz4LUCnGi/cC5R+fiu+fovFM/BwvaGtqBFIF/1oWVq7bZ
715: 4wIDAQAB
716: -----END PUBLIC KEY-----
717: )",
718:     R"(
719: -----BEGIN PUBLIC KEY-----
720: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA25qGwNO1+qHygC8mjm8L
721: 3I66mV/IzslgBDHC91mE8YcI5Fq0sdrtsbUhK3z89wIN/zOhbHX0NEiXm2GxUnsI
722: vb5tDZXAh7AbTnXTMVbxO/e/8sPLUiObGjDvjVzyzrxOeG87yK/oIiilwk9wTsIb
723: wMn2Grj4ht9gVKx3oGHYV7STNdWBlzSaJj4Ou7+5M1InjPDRFZG1K31D2d3IHByX
724: lmcRPZtPFTa5C1uVJw00fI4F4uEFlPclZQlR5yA0G9v+0uDgLcjIUB4eqwMthUWc
725: dHhlmrPp04LI19eksWHCtG30RzmUaxDiIC7J2Ut0zHDqUe7aXn8tOVI7dE9tTKQD
726: KQIDAQAB
727: -----END PUBLIC KEY-----
728: )",
729:     R"(
730: -----BEGIN PUBLIC KEY-----
731: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7EC2bx7aRnf3TcRg5gmw
732: QOKNCUheCelK8hoXLMsKSJqmufyJ+IHUejpXGOpvyYRbACiJ5GiNcww20MVpTBU7
733: YESWB2QSU2eEJJXMq84qsZSO8WGmAuKpUckI+hNHKQYJBEDOougV6/vVVEm5c5bc
734: SLWQo0+/ciQ21Zwz5SwimX8ep1YpqYirO04gcyGZzAfGboXRvdUwA+1bZvuUXdKC
735: 4zsCw2QALlcVpzPwjB5mqA/3a+SPgdLAiLOwWXFDRMnQw44UjsnPJFoXgEZiUpZm
736: EMS5gLv50CzQqJXK9mNzPuYXNUIc4Pw4ssVWe0OfN3Od90gl5uFUwk/G9lWSYnBN
737: 3wIDAQAB
738: -----END PUBLIC KEY-----
739: )", nullptr};
740: 
741: static const char *const community_public_keys[] = {
742:     R"(
743: -----BEGIN PUBLIC KEY-----
744: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAv+Jki3aiZt0eOzShgD2g
745: BYPjPpkhHowOwPzUKtTVPob7vxyzd2wPyWDF/Zn6sN8QzravAdlXFE3SNF7ayO86
746: IPHhMxO6P2YlxbipyKzPOUJsasXBiwYw2aSvb0RtwnYwD5lJs8Tz2ET1RQCFgXGc
747: LW7bDjKRbHSME0Me5rLRWVztOqULeoMeY1oCOmKKeAYxjFOASJJfQF9oQxkuu3j1
748: qpcXnfHldlPGzFM77OFlWFtlc9QW4WNoxkO3HwskFW6ZRaQipM8vgSzkIfPFESGL
749: TtDRw+RcUPqmS6NVW8nhaiptBIMXy+9cP/l1LGmGwrZRhWP0YBlk6V9MUMzjyo+R
750: JQIDAQAB
751: -----END PUBLIC KEY-----
752: )",
753:     R"(
754: -----BEGIN PUBLIC KEY-----
755: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtXl28loGwAH3ZGQXXgJQ
756: 3omhIEiUb3z9Petjl+jmdtEQnMNUFEZiXkfJB02UFWBL1OoKKnjiGhcr5oGiIZKR
757: CoaL6SfmWe//7o8STM44stE0exzZcv8W4tWwjrzSWQnwh2JgSnHN64xoDQjdvG3X
758: 9uQ1xXMXghWOKqEpgArpJQkHoPW3CD5sCS2NLFrBG6KgX0W+GTV5HaKhTMr2754F
759: l260drcBJZhLFCeesze2DXtQC+R9D25Zwn2ehHHd2Fd1M10ZL/iKN8NeerB4Jnph
760: w6E3orA0DusDLDLtpJUHhmpLoU/1eYQFQOpGw2ce5I88Tkx7SKnCRy1UiE7BA82W
761: YQIDAQAB
762: -----END PUBLIC KEY-----
763: )",
764:     R"(
765: -----BEGIN PUBLIC KEY-----
766: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvTgQ+mJs8vG/TQTJ6sV+
767: tACTZTbmp8NkgTuwEyHZSNhX6W8FYwAqPzbePo7wudsUdBWV8j+kUYaBiqeiPUp0
768: 7neO/3oTUQkMJLq9FeIXfoYkS3+/5CIuvsfas6PJP9U2ge6MV1Ndgbd7a12cmX8V
769: 4eNwQRDv/H4zgL7YI2ZZSG1loxgMffZrpflNB87t/f0QYdmnwphMC5RqxiCkDZPA
770: a5/5KbmD6kjLh8RRRw3lAZbPQe5r7o2Xqqwg9gc6rQ/WFBB1Oj+Q5Bggqznl6dCB
771: JcLOA7rhYatv/mvt1h6ogQwQ9FGRM3PifV9boZxOQGBAkMD6ngpd5kVoOxdygC7v
772: twIDAQAB
773: -----END PUBLIC KEY-----
774: )",
775:     R"(
776: -----BEGIN PUBLIC KEY-----
777: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7KvnA+Ixj4ZCLR+aXSFz
778: ICGbQdVrZ/hhjImDQcWgWY+z/bEbybslDvy5KEPrxTNxKZ0VfFFAVEUj2cw8B5KI
779: naK8U2VIpdD6LpEJvkOuWKg3bym4COhyAcRNqKKu/GPzS90wICJ2aaayF1mVoCIL
780: dsp2ZShSIVRJa55gVvfRN1ZEkqBnZryKNt/h3DNqqq2Sn3n3HIZ8H9oEO+L+2Efe
781: kyET7o9OHy6QZXhf4SJ8QlQAwxxe/L4bln8CBlBHKrUNNqxpjhC37EnY2jpuu3a9
782: EZcNFj8R4qIJx7hcltntZyKrEIXqc6I6x4oZ4qhZj3RQ5Lr+pJ++idoc1LmBS3k5
783: yQIDAQAB
784: -----END PUBLIC KEY-----
785: )",
786:     R"(
787: -----BEGIN PUBLIC KEY-----
788: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7SF+5RZ9jXyruBkhxhk2
789: BSWPbohevxxv++7Uw0HXC/3Xw4jzii0tYaJ6O8QWXyggEAkvmONblAN1rfiz+h5M
790: oJUQwHjTTZ8BmKUmWrNayVokUXLu4IpCAHk4uSXfx4U/AINnNfWW7z8mUJf6nGsM
791: XePuKPBRUsw+JmTWOXEIVrkc/66B+gpgi+DwRFLUPh96D8XRAhp7QbHE9UMD3HpA
792: mPMX7ICVsVS+NGdCHNsdWfH4noaESjgmMdApKekgeeo8Zu1pvQ3y8iew1xOQVBoR
793: V+PCGWAJYB7ulqBBkRz+NhPLWw7wRA4yLNcZVlZuDFxH9EoavWdfIyYYUn4efSz9
794: tQIDAQAB
795: -----END PUBLIC KEY-----
796: )",
797:     R"(
798: -----BEGIN PUBLIC KEY-----
799: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAszmZ6Slv/oJvFpOLtSMx
800: 58AKMia9y+qcVfw77/Alb3b+Qi5L2uy6nHfJElT7RIeeXhJ8mFglZ70MecTfj0jl
801: 5WhW+yMg6jmPCJL2JMt/oeC4iY4Cf/3C9RHU4IO13VN4dnVQ5S+SEEmSbXnno9Pe
802: 06yyVgZeJ0REJMV1JZj9gOPc/wbeLHsx4UC5qsu32Ammy6J7tS+k7JvRc9CPOEpe
803: IhWoZmpONydcI6IRfyH2xl4uLY3hWDrRei0I2zGH45G2hPNeTtRh27t+SzXO7h9j
804: y072CgHytRgQBiH711i8fe4bHMmtVPhPjFrbuzbJSgE7SyikrWIHMDsnPz443bdR
805: cQIDAQAB
806: -----END PUBLIC KEY-----
807: )",
808:     R"(
809: -----BEGIN PUBLIC KEY-----
810: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAleywAb7xZKYTFE08gGA9
811: ffTeYPRcECl/J060fUziIiFu0NHTOZO+a4BH2X+E1WjjNNQkbn00g+op4nqg3/U+
812: UaKuXNjWY2Rvd8s91fUD0YOdRpPmsTm2QqhgmYYzO8Oh3YXBNRpXaqALbjL9Nahw
813: YEAsI3o5yenZGUIEk3JaZFHsAZPL5wGgDVpZgmVUHJ0EO8N5LQh01aHxnP5+ey2z
814: L5h6IdWLubb07wEBk5bnmIvdhd6dIBzUql27BAqvxKJbW0/okjrhIgcIANDCavfV
815: L8UP7MCGnfozK7VIl5DG85gCQVAD8+lGUDzOuhzZjl7XKpkFAIWaS8pl4AJbJuG8
816: nwIDAQAB
817: -----END PUBLIC KEY-----
818: )",
819:     R"(
820: -----BEGIN PUBLIC KEY-----
821: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxiKgcR7Kb1CGTNczbuX+
822: S7OFpnVLDD5XGVKvYWxL+2By2QRFPWtMs8c24omLIgZ/CWBFPraMiNKS4+V9ar2C
823: wJhToJnAOKyayA0Gw2wNZx1mgHAZ/5mT+ImfkmZu2HPwtzJmJDQlESD4p40BWBNa
824: ZpWFGPMKn4GqvOOSGevC/r9inXm6NaPkM+B/piVDEgiJ7g/kpoqImmNb/c2/3XG5
825: 3kbDIHdbd2m3A3jWCjNGSANKsR5C0/rZtvsA8tjDlNWIuKmkU3C2nfj3UduU4dNP
826: Cisod/pDY8ov0U9sdkM9XZsTXjtbAIGLzMshmOv4ajRFUueGnsZW0GRqp9DSnKmj
827: 2QIDAQAB
828: -----END PUBLIC KEY-----
829: )",
830:     R"(
831: -----BEGIN PUBLIC KEY-----
832: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuh334hUmJcdDJUSmeXqE
833: GUfGnASD2QrnuoS+gsXgW5BQW8YMDFASvADQhoDUdcwZMlAF+p+CxKCX/gBp40nC
834: 5eyPXv1e0K6PFcCdHtJq8MhGYAr1sy+7cOpzv0r9whobYUykGoHjdwZeu3VbA3uz
835: go80oYQlwY+v4zZFafCz3cXw8u7n/9PlddgeqHuIPsNZLocICuBUxwg5rHTzycg2
836: Pa68CRselONGN12V0/wlOg+NZpKCym58CM9SS/0v4YZ6LnmINo8gdRYnGE2zhvey
837: pHR8IJ8WSJXbl8NwyIY1AmtT/Z0dbAclfD8Wt/w5KA/sttnQzrB7fPsLRyLP1Alq
838: iQIDAQAB
839: -----END PUBLIC KEY-----
840: )",
841:     R"(
842: -----BEGIN PUBLIC KEY-----
843: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvWuRMEbez/Ud2o/0KA04
844: K9u3HePWud9rEqMsPv2HlclH3k+cezoUJzVre0lopv3R4aG3LDoFETrgGgUVrfPG
845: z3Zh7vyk0kb4IGkv+kLQu/cWQXyNzigxV+WQnpIWQ28vrP45y5f+GhwwgzFaDAQR
846: u1o1HH1FEnP7SSzHVvisNTecY95+F5AOvtOOUg4VlegXdUeGZHEza/0D9V8gODPL
847: DzbOJDDiqX8ahhRnIZyGEg6y7QqftZFz7j0siCHTXXYJBOcPjD4TqTUNpGvBox44
848: wgLlLcDsZ/n2Ck4doLXxVz9F80VKOriHSk+qIwseykKVzWQDQTOMOsjCmQsDvram
849: RwIDAQAB
850: -----END PUBLIC KEY-----
851: )",
852:     R"(
853: -----BEGIN PUBLIC KEY-----
854: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyJmGd1GuBv/WD80IcVyr
855: dZcmuYe/7azLuV1wsgtH4gsUx+ifUwLZUhLFGOTAPFitbFYPPdhQKncO+BcbvOIo
856: 9FGKj9jGVpMU6C+0JQfi+koESevtO1tYzG8c2dMOGNUO0Hlj2Hezm3tZY4nAbo1J
857: DYqQSY7qvOYZPFvOS/zL+q2vMx93w9jDHJK4iU02ovAqK9xCWfTp4W7rtbDeTgiX
858: W/75rMG8DWI1ZHA2JXAOFPsiOHa0/yyvCvUIWvRuNHqTTN5NFiJRIcbTCKKbNwNM
859: xcNkBQCx4xwOqD9TkDbHpBOC/pfW7j3ygJdYRjFFqm10+KwPACYo/f0n4n4DI8Zz
860: twIDAQAB
861: -----END PUBLIC KEY-----
862: )",
863:     R"(
864: -----BEGIN PUBLIC KEY-----
865: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnmxbunsK+2pL8Cva9F8E
866: 9o/dQ35TuIqcgpl9/oIc++x+6G5/8UT5mgGCQTITJRIAPnHsZ9XEnMxTAuSCDkYG
867: CA3JMl1MT7Zxu8TQJBPiXxOaAE1UmA13JuQ2Uu0v7T6TucQxR9KMvcdCxOZ5cBU4
868: uyJObnZVy/WjM2vWcWDUaYGfMss3eYxcDpavspBANdtSZfv11+8/VC+gEGBOe+oW
869: zDR+BlQx//MAzwSP5HVQcmLHsT073IvkoUWJUxSCCwlLe60ylpY16BLT6dB0RU8B
870: sxFcIwmYg0kq19EEPPvZLvRKjG/TJRm1MFzOE5LP2VxLGdMltWYEVsBZHTcWU7HR
871: 8wIDAQAB
872: -----END PUBLIC KEY-----
873: )",
874:     R"(
875: -----BEGIN PUBLIC KEY-----
876: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlo7eDZOpCptanajUtDK3
877: q8Q/ykxmDDw6lVSiLBm54zwMxaqfM+tV/xqalvIVv3BrucRkCs6H+R0bpd7XhbE5
878: a7ZFSrWCBf1V6y/NZrEn4qcRbk/WsG4UFqu7CG4r+EgQ4nmoIH/A5+e8FUcur3Y8
879: 2ie9Foi1CUpZojWYZJeHKbb2yYn4MFHszEb5w9HVxY+i9jR1B8Rvn6OEK3OYDrtA
880: KnPXp4OiDx6CviYEmipX815PPj7Sv8KKL96JqGWjC4kYw6ALgV/GxiX++tv6rh2O
881: paW9MBv1y+5oZ8ls5S2T/LXbxDpjUEKC9guSSWmsPHRMxOumXsw0H43grC3Ce8Ui
882: CwIDAQAB
883: -----END PUBLIC KEY-----
884: )",
885:     R"(
886: -----BEGIN PUBLIC KEY-----
887: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0ACgf0kJeQgDh+vHj2aj
888: K/6FQ794MknLxlwTARGlktoVwZgW/qc6vMZsILRUP1gb/gPXdpSTqqad/GLG4f5R
889: 1Ji1It6BniJOPWu1YyTz0C/BXzTGWbwPnIaawbpQE8n4A+tjGGvAoauPtzr0bWfV
890: XOXPfIW9XB51dcaVTZgHN55Y8Yd/Pcu9/lqXqXyE23tDLXR/QgGpwK9VxTSbRmuC
891: WspwqWY6L3MIw+3HIXERTM1uNhc9oHxMOCRbJmUghG0wCWB0ed3Xhbnl9mHlX+l1
892: rfCJAP4lVWKFjkKBNUejaf+WHxASMjrQubgHLZ2fpf3Ra8TfI3rgPABsAqEIFw3T
893: QwIDAQAB
894: -----END PUBLIC KEY-----
895: )",
896:     R"(
897: -----BEGIN PUBLIC KEY-----
898: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAt635/P50bMbEDTapjAQz
899: ARTb3y8jMHxVruX0tJU1tycmkX3J8tBALmc6TkSHNTJcQmR8L8Sj3h76l/vuL373
900: HFSGZ4xghBQqR1lUd2kVomoh+rzEte+0rHWm0JMhjmTQBx+AkDCOw4z3vi5AxWx0
901: 4EbYpQm2akVGKXQrQPyds0UirmdLACCH6WM6exgAXr75DB4PUpG85oI9Q+5ee1Km
902: +4atVJ4FNa6ZnjWccrlMYT0W7a0Y7feJPAPvfizrs2MG9/ijyBX34eCWA5dtUSIm
903: 2uqI6DxITZlLTvXVDSKQGlq5TEGMvRULWTatqWy4g+tOZ8rSbRuj32pcBnXlwuVu
904: 7QIDAQAB
905: -----END PUBLIC KEY-----
906: )",
907:     R"(
908: -----BEGIN PUBLIC KEY-----
909: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwqO3yWSLKqz1uQ54iFd/
910: VcQzgT6chLVuhktt7EFvi3tKaQqz2h2KPkDR+MssRV/BZ/41GNlR6r6p5CaPVDDe
911: Cuj5IcxrIFZIOBMBi1YZ/bknF9edJacINxNfGK/lXBNEAdUvxcOxX8WeP69uvl2l
912: SKyO3yAdx6HOyL9if95bYQD19HYPZzbfccPX1aD4pjnej6uMfd7yZErH7i8y0oj4
913: eSKSe1CisjFlR9NzRGO42jU9rtqnAFH9sK5wU9xKQ7bQwlz7yKBF2RuuQweMpXb6
914: lSObI7ZqYN+7jkf9F5hKRx4kX3+MMBeYmFOy1aYZ08u6sdJ2ua/hFNSDRg7e/UCe
915: AwIDAQAB
916: -----END PUBLIC KEY-----
917: )",
918:     R"(
919: -----BEGIN PUBLIC KEY-----
920: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkJihnfMECaa6YCg6avam
921: cb8Sy1GshJ7c7+EW6C4vnspSSvEi04AEBB29pnEF9+VO6VSUHLxunVCpbmKFaLH+
922: 5fDLnc/wCkjPQww49da9MEScCmVGjROlmog65cxQbv4lfxyw55sFV3s/5CPcGlVc
923: 1gojHRABrx4YocpeYies04mEVoOYg1DBG4Uf+aFd5+hm3ZtBa4mqTK2iQa4ILkHa
924: a0/Us1drRuDjjI4zSbgRzy9x0JVDvqDdLubHyaEf7d7SdrKzodhydG84qpsPFxIj
925: LK7Bu5v7P4ZTJmxMG3PBM2kB//hlYVR4vO4VEu66mQIM6km+vT9cwxz77qIJhLn3
926: ywIDAQAB
927: -----END PUBLIC KEY-----
928: )",
929:     R"(
930: -----BEGIN PUBLIC KEY-----
931: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA9NbP7ijUxZh4j0NVF6yO
932: IZ0rzROwl4pP4HGeN+Woyi9+qpdE874WlVoquGEpsshF4Ojzbu2BtXuihb783awa
933: GLx66MYPeID1FjTKmuCJ2aluOP+DkVo6K1EoqVJXyeIxZzVSqhSIuAdb/vmPlgLz
934: Fzdk3FgNNOERuGV363DRGz1YxZVnJeSs76g+/9ddhMk8cqIRup5S4YgTOSr0vKem
935: 1E6lyE8IbLoq9J7w5Ur8VjzE2cI+eLKGFqr46Q8pf0pJq72gd+Z3mH5D2LmvEtAR
936: 9jAQXVlLfHauQR2M0K6mqDy9GxL19OU4tGO+GY86VvDTU+wZppAZRz9AKoL1fwfI
937: BQIDAQAB
938: -----END PUBLIC KEY-----
939: )",
940:     R"(
941: -----BEGIN PUBLIC KEY-----
942: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjrI16GdC2zJriLbyzcre
943: AqvckBSTMd4bdGaodUBNBTBVbITsOw/k7D62y2hSZHt2nHOyEVkJINJHADrpNZuY
944: ybS4ssEXxD8+NnjATqQxDMuSz8lUj/Jnf49uzLh84fep3DTksDcQX6Nvio5q8Xbh
945: HRgvl5I+tPfLtme0oW9cVuVja2i5lHB3SzYCW9Kk/V4/d2WiceYf91a1Nae6m7QV
946: 5bmbYoHmsxT8refTQq+5lAhzVXYU9QRgiKdbE8sSmkV+YiZEtGijefUXgmOxx3I9
947: B3y03796WBS/RHpSzdMNJw/xPWJcSEMqaUdSYr0DuPCnrn7ojFeF/EFC47CBq5DU
948: swIDAQAB
949: -----END PUBLIC KEY-----
950: )",
951:     R"(
952: -----BEGIN PUBLIC KEY-----
953: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjS1+My6OhQCCD1DgrzKu
954: db4Fvc3aqqEhQyjqMLnalp0uoGFpSLoPsZiPGloTE8FSs1ZBFKQ8h2SsGwSdhRKF
955: xIqoOnS0B/ORjGJxTj7Q2YWjzkCZUD4Ul2AxIbv3TmZM2LeyHJL3A71tSuck8EQY
956: PE2aj1tLzXsSfRaByy5xwXiU6UpnwCY1xb8tK8QxavRCo5T9Si9tNsolStoNVXV0
957: k9EbTcRNnxCvab/oqjvgyRuSmIES00v8jZOGQZQUpw02RN6yCBeX2i8GPsGjj/T9
958: 6Gu1Z3G4zUjLlJxl8vjo8KIDaQ8NVWT0j7gx9Knvb5tWnAORI1aJA8AHQvaoOT1W
959: 1wIDAQAB
960: -----END PUBLIC KEY-----
961: )", nullptr};
962: 
963: const vector<string> ExtensionHelper::GetPublicKeys(bool allow_community_extensions) {
964: 	vector<string> keys;
965: 	for (idx_t i = 0; public_keys[i]; i++) {
966: 		keys.emplace_back(public_keys[i]);
967: 	}
968: 	if (allow_community_extensions) {
969: 		for (idx_t i = 0; community_public_keys[i]; i++) {
970: 			keys.emplace_back(community_public_keys[i]);
971: 		}
972: 	}
973: 	return keys;
974: }
975: 
976: } // namespace duckdb
[end of src/main/extension/extension_helper.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: