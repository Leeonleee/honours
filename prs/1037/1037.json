{
  "repo": "duckdb/duckdb",
  "pull_number": 1037,
  "instance_id": "duckdb__duckdb-1037",
  "issue_numbers": [
    "1035"
  ],
  "base_commit": "88176fd65011e289dfb5ccca55bd1ea2c6632d3e",
  "patch": "diff --git a/src/include/duckdb/parser/statement/update_statement.hpp b/src/include/duckdb/parser/statement/update_statement.hpp\nindex 1db2e2a3ffcf..6ef940af8174 100644\n--- a/src/include/duckdb/parser/statement/update_statement.hpp\n+++ b/src/include/duckdb/parser/statement/update_statement.hpp\n@@ -22,7 +22,7 @@ class UpdateStatement : public SQLStatement {\n \n \tunique_ptr<ParsedExpression> condition;\n \tunique_ptr<TableRef> table;\n-\n+\tunique_ptr<TableRef> from_table;\n \tvector<string> columns;\n \tvector<unique_ptr<ParsedExpression>> expressions;\n };\ndiff --git a/src/parser/transform/statement/transform_update.cpp b/src/parser/transform/statement/transform_update.cpp\nindex 71900ac2b852..5486e29f03b7 100644\n--- a/src/parser/transform/statement/transform_update.cpp\n+++ b/src/parser/transform/statement/transform_update.cpp\n@@ -12,6 +12,10 @@ unique_ptr<UpdateStatement> Transformer::TransformUpdate(PGNode *node) {\n \tauto result = make_unique<UpdateStatement>();\n \n \tresult->table = TransformRangeVar(stmt->relation);\n+\tif (stmt->fromClause) {\n+\t\tresult->from_table = TransformFrom(stmt->fromClause);\n+\t}\n+\n \tresult->condition = TransformExpression(stmt->whereClause);\n \n \tauto root = stmt->targetList;\ndiff --git a/src/planner/binder/statement/bind_update.cpp b/src/planner/binder/statement/bind_update.cpp\nindex 4ef6a8de956a..af65f37fabba 100644\n--- a/src/planner/binder/statement/bind_update.cpp\n+++ b/src/planner/binder/statement/bind_update.cpp\n@@ -13,7 +13,7 @@\n #include \"duckdb/storage/data_table.hpp\"\n #include \"duckdb/planner/bound_tableref.hpp\"\n #include \"duckdb/planner/tableref/bound_basetableref.hpp\"\n-\n+#include \"duckdb/planner/tableref/bound_crossproductref.hpp\"\n #include <algorithm>\n \n using namespace std;\n@@ -90,6 +90,9 @@ static void BindUpdateConstraints(TableCatalogEntry &table, LogicalGet &get, Log\n \n BoundStatement Binder::Bind(UpdateStatement &stmt) {\n \tBoundStatement result;\n+\tunique_ptr<LogicalOperator> root;\n+\tLogicalGet *get;\n+\n \t// visit the table reference\n \tauto bound_table = Bind(*stmt.table);\n \tif (bound_table->type != TableReferenceType::BASE_TABLE) {\n@@ -98,9 +101,16 @@ BoundStatement Binder::Bind(UpdateStatement &stmt) {\n \tauto &table_binding = (BoundBaseTableRef &)*bound_table;\n \tauto table = table_binding.table;\n \n-\tauto root = CreatePlan(*bound_table);\n-\tauto &get = (LogicalGet &)*root;\n-\tassert(root->type == LogicalOperatorType::GET);\n+\tif (stmt.from_table) {\n+\t\tBoundCrossProductRef bound_crossproduct;\n+\t\tbound_crossproduct.left = move(bound_table);\n+\t\tbound_crossproduct.right = Bind(*stmt.from_table);\n+\t\troot = CreatePlan(bound_crossproduct);\n+\t\tget = (LogicalGet *)root->children[0].get();\n+\t} else {\n+\t\troot = CreatePlan(*bound_table);\n+\t\tget = (LogicalGet *)root.get();\n+\t}\n \n \tif (!table->temporary) {\n \t\t// update of persistent table: not read only!\n@@ -155,12 +165,12 @@ BoundStatement Binder::Bind(UpdateStatement &stmt) {\n \tproj->AddChild(move(root));\n \n \t// bind any extra columns necessary for CHECK constraints or indexes\n-\tBindUpdateConstraints(*table, get, *proj, *update);\n+\tBindUpdateConstraints(*table, *get, *proj, *update);\n \n \t// finally add the row id column to the projection list\n-\tproj->expressions.push_back(\n-\t    make_unique<BoundColumnRefExpression>(LOGICAL_ROW_TYPE, ColumnBinding(get.table_index, get.column_ids.size())));\n-\tget.column_ids.push_back(COLUMN_IDENTIFIER_ROW_ID);\n+\tproj->expressions.push_back(make_unique<BoundColumnRefExpression>(\n+\t    LOGICAL_ROW_TYPE, ColumnBinding(get->table_index, get->column_ids.size())));\n+\tget->column_ids.push_back(COLUMN_IDENTIFIER_ROW_ID);\n \n \t// set the projection as child of the update node and finalize the result\n \tupdate->AddChild(move(proj));\n",
  "test_patch": "diff --git a/test/sql/update/test_update_from.test b/test/sql/update/test_update_from.test\nnew file mode 100644\nindex 000000000000..351f73300e09\n--- /dev/null\n+++ b/test/sql/update/test_update_from.test\n@@ -0,0 +1,154 @@\n+# name: test/sql/update/test_update.test\n+# description: Test updates that use a from clause\n+# group: [update]\n+\n+# create a table\n+statement ok\n+CREATE TABLE test (a INTEGER);\n+\n+statement ok\n+INSERT INTO test VALUES (3)\n+\n+statement ok\n+CREATE  TABLE src (a INTEGER);\n+\n+statement ok\n+INSERT INTO src VALUES (2)\n+\n+query I\n+SELECT * FROM test\n+----\n+3\n+\n+query I\n+SELECT * FROM src\n+----\n+2\n+\n+# test simple update\n+statement ok\n+UPDATE test SET a=test.a+s.a FROM src s\n+\n+query I\n+SELECT * FROM test\n+----\n+5\n+\n+# test self join via alias\n+statement ok\n+UPDATE test SET a=test.a+t.a FROM test t\n+\n+query I\n+SELECT * FROM test\n+----\n+10\n+\n+# test multiple tables\n+statement ok\n+UPDATE test SET a=t.a+s.a FROM test t, src s\n+\n+query I\n+SELECT * FROM test\n+----\n+12\n+\n+# test subquery\n+statement ok\n+UPDATE test SET a=s.q FROM (SELECT a+1 as q FROM src) s\n+\n+query I\n+SELECT * FROM test\n+----\n+3\n+\n+# test view\n+statement ok\n+CREATE VIEW vt AS (SELECT 17 as v)\n+\n+statement ok\n+UPDATE test SET a=v FROM vt\n+\n+query I\n+SELECT * FROM test\n+----\n+17\n+\n+# with a where clause on the from table\n+statement ok\n+UPDATE test SET a=s.a FROM src s WHERE s.a = 2\n+\n+query I\n+SELECT * FROM test\n+----\n+2\n+\n+# with a where clause that involves both tables\n+statement ok\n+UPDATE test t SET a=1 FROM src s WHERE s.a = t.a\n+\n+query I\n+SELECT * FROM test\n+----\n+1\n+\n+# with a where clause that evaluates to false\n+statement ok\n+UPDATE test t SET a=9 FROM src s WHERE s.a=t.a\n+\n+query I\n+SELECT * FROM test\n+----\n+1\n+\n+# test with multiple updates per row (which is undefined),\n+# but in this case the last value in the table will win\n+statement ok\n+INSERT INTO src VALUES (7)\n+\n+statement ok\n+UPDATE test SET a=s.a FROM src s\n+\n+query I\n+SELECT * FROM test\n+----\n+7\n+\n+# test described in issue 1035\n+\n+statement ok\n+CREATE TABLE terms(docid INTEGER, term INTEGER);\n+\n+statement ok\n+CREATE TABLE docs(id INTEGER, len INTEGER);\n+\n+statement ok\n+insert into docs values (1, 0), (2, 0);\n+\n+statement ok\n+insert into terms values (1, 1);\n+\n+statement ok\n+insert into terms values (2, 1);\n+\n+statement ok\n+insert into terms values (2, 2);\n+\n+statement ok\n+insert into terms values (2, 3);\n+\n+statement ok\n+UPDATE docs \n+SET len = sq.len \n+FROM ( \n+    SELECT docid AS id, count(term) AS len \n+    FROM terms \n+    GROUP BY docid \n+    ORDER BY docid \n+) AS sq \n+WHERE docs.id = sq.id;\n+\n+query II\n+select * from docs;\n+----\n+1\t1\n+2\t3\n",
  "problem_statement": "Support FROM clause in UPDATE statement\nThe FROM clause in the UPDATE statement currently gets silently ignored. It should either throw an error (as in SQLite) or be supported (as in Postgres).\r\n\r\n```sql\r\nCREATE TABLE terms(docid INTEGER, term INTEGER);\r\nCREATE TABLE docs(id INTEGER, len INTEGER);\r\ninsert into docs values (1, 0), (2, 0);\r\ninsert into terms values (1, 1);\r\ninsert into terms values (2, 1);\r\ninsert into terms values (2, 2);\r\ninsert into terms values (2, 3);\r\n\r\nUPDATE docs \r\nSET len = sq.len \r\nFROM ( \r\n    SELECT docid AS id, count(term) AS len \r\n    FROM terms \r\n    GROUP BY docid \r\n    ORDER BY docid \r\n) AS sq \r\nWHERE docs.id = sq.id;\r\nselect * from docs;\r\n-- expected answer:\r\n-- 1, 1\r\n-- 2, 3\r\n```\n",
  "hints_text": "So funny-- I was literally just about to post this issue since I need it for incremental updates in dbt. Is it something I could implement? I'd love to get into the weeds of the query planner.\nGo right ahead! @lnkuiper ran into it and we managed to solve this using a subquery instead, but it would be great if you could have a look. ",
  "created_at": "2020-10-21T20:43:42Z"
}