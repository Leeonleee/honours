{
  "repo": "duckdb/duckdb",
  "pull_number": 11671,
  "instance_id": "duckdb__duckdb-11671",
  "issue_numbers": [
    "11621"
  ],
  "base_commit": "5bcfd7434790fabb0ea99998abb78e3a31bad47a",
  "patch": "diff --git a/src/storage/compression/bitpacking.cpp b/src/storage/compression/bitpacking.cpp\nindex fa7f4a7c79f3..5a82482ebf7e 100644\n--- a/src/storage/compression/bitpacking.cpp\n+++ b/src/storage/compression/bitpacking.cpp\n@@ -514,7 +514,8 @@ struct BitpackingCompressState : public CompressionState {\n \t\tauto base_ptr = handle.Ptr();\n \n \t\t// Compact the segment by moving the metadata next to the data.\n-\t\tidx_t metadata_offset = AlignValue(data_ptr - base_ptr);\n+\t\tidx_t unaligned_offset = data_ptr - base_ptr;\n+\t\tidx_t metadata_offset = AlignValue(unaligned_offset);\n \t\tidx_t metadata_size = base_ptr + Storage::BLOCK_SIZE - metadata_ptr;\n \t\tidx_t total_segment_size = metadata_offset + metadata_size;\n \n@@ -523,6 +524,10 @@ struct BitpackingCompressState : public CompressionState {\n \t\t\tthrow InternalException(\"Error in bitpacking size calculation\");\n \t\t}\n \n+\t\tif (unaligned_offset != metadata_offset) {\n+\t\t\t// zero initialize any padding bits\n+\t\t\tmemset(base_ptr + unaligned_offset, 0, metadata_offset - unaligned_offset);\n+\t\t}\n \t\tmemmove(base_ptr + metadata_offset, metadata_ptr, metadata_size);\n \n \t\t// Store the offset of the metadata of the first group (which is at the highest address).\ndiff --git a/tools/shell/linenoise/linenoise.cpp b/tools/shell/linenoise/linenoise.cpp\nindex 090965c0ca3a..17ecc3e209e6 100644\n--- a/tools/shell/linenoise/linenoise.cpp\n+++ b/tools/shell/linenoise/linenoise.cpp\n@@ -1061,6 +1061,7 @@ Linenoise::Linenoise(int stdin_fd, int stdout_fd, char *buf, size_t buflen, cons\n \trender = true;\n \tcontinuation_markers = true;\n \tinsert = false;\n+\tsearch_index = 0;\n \n \t/* Buffer starts empty. */\n \tbuf[0] = '\\0';\n",
  "test_patch": "diff --git a/scripts/test_zero_initialize.py b/scripts/test_zero_initialize.py\nindex 397e14e6c68b..966e1cde187d 100644\n--- a/scripts/test_zero_initialize.py\n+++ b/scripts/test_zero_initialize.py\n@@ -27,6 +27,7 @@\n     'test/sql/storage/update/test_store_null_updates.test',\n     'test/sql/storage/test_store_integers.test',\n     'test/sql/storage/mix/test_update_delete_string.test',\n+    'test/sql/storage/nested/struct_of_lists_unaligned.test',\n ]\n \n \ndiff --git a/test/sql/storage/nested/struct_of_lists_unaligned.test b/test/sql/storage/nested/struct_of_lists_unaligned.test\nnew file mode 100644\nindex 000000000000..40d09347a4a7\n--- /dev/null\n+++ b/test/sql/storage/nested/struct_of_lists_unaligned.test\n@@ -0,0 +1,15 @@\n+# name: test/sql/storage/nested/struct_of_lists_unaligned.test\n+# description: Test storage of structs with lists in it\n+# group: [nested]\n+\n+# load the DB from disk\n+load __TEST_DIR__/test_store_list_of_structs.db\n+\n+statement ok\n+CREATE TABLE test_list_2 (a integer, b STRUCT(c VARCHAR[], d VARCHAR[], e INTEGER[]));\n+\n+statement ok\n+INSERT INTO test_list_2 SELECT 1, row(['a', 'b', 'c', 'd', 'e', 'f'], ['A', 'B'], [1, 5, 9]) FROM range(10);\n+\n+statement ok\n+CHECKPOINT;\n",
  "problem_statement": "UB when persisting nested data\n### What happens?\n\nWriting a nested table to a database on disk leads to errors in Valgrind, and to crashes in the R client.\r\n\r\nDownstream: https://github.com/duckdb/duckdb-r/issues/141.\n\n### To Reproduce\n\nThe error only occurs when writing to disk.\r\n\r\n```sh\r\nrm my.duckdb;\r\necho \"CREATE TABLE test_list_2 (a integer, b STRUCT(c VARCHAR[], d VARCHAR[], e INTEGER[]))\" | duckdb/duckdb my.duckdb;\r\nfor i in $(seq 1 10); do echo \"INSERT INTO test_list_2 VALUES (1, row(['a', 'b', 'c', 'd', 'e', 'f'], ['A', 'B'], [1, 5, 9]))\" | duckdb/duckdb my.duckdb; done;\r\necho \"INSERT INTO test_list_2 VALUES (1, row(['a', 'b', 'c', 'd', 'e', 'f'], ['A', 'B'], [1, 5, 9]))\" | valgrind duckdb/duckdb my.duckdb\r\n```\r\n\r\nRelevant Valgrind output:\r\n\r\n```\r\n==28183== Syscall param pwrite64(buf) points to uninitialised byte(s)\r\n==28183==    at 0x4CB083F: __libc_pwrite64 (pwrite64.c:25)\r\n==28183==    by 0x4CB083F: pwrite (pwrite64.c:23)\r\n==28183==    by 0x8ABF00: duckdb::LocalFileSystem::Write(duckdb::FileHandle&, void*, long, unsigned long) (in /duckdb/duckdb)\r\n==28183==    by 0xB578C8: duckdb::BlockManager::ConvertToPersistent(long, std::shared_ptr<duckdb::BlockHandle>) (in /duckdb/duckdb)\r\n==28183==    by 0xC1840F: duckdb::ColumnSegment::ConvertToPersistent(duckdb::optional_ptr<duckdb::BlockManager>, long) (in /duckdb/duckdb)\r\n==28183==    by 0xC2583C: duckdb::PartialBlockForCheckpoint::Flush(unsigned long) (in /duckdb/duckdb)\r\n==28183==    by 0xC57316: duckdb::PartialBlockManager::FlushPartialBlocks() (in /duckdb/duckdb)\r\n==28183==    by 0xC6F9B2: duckdb::SingleFileCheckpointWriter::CreateCheckpoint() (in /duckdb/duckdb)\r\n==28183==    by 0xC6FC58: duckdb::SingleFileStorageManager::CreateCheckpoint(bool, bool) (in /duckdb/duckdb)\r\n==28183==    by 0xAF755E: duckdb::AttachedDatabase::Close() (in /duckdb/duckdb)\r\n==28183==    by 0xAF7AC7: duckdb::DatabaseManager::ResetDatabases(duckdb::unique_ptr<duckdb::TaskScheduler, std::default_delete<duckdb::TaskScheduler>, true>&) (in /duckdb/duckdb)\r\n==28183==    by 0xAF7B64: duckdb::DatabaseInstance::~DatabaseInstance() (in /duckdb/duckdb)\r\n==28183==    by 0xAEB399: duckdb::DuckDB::~DuckDB() (in /duckdb/duckdb)\r\n==28183==  Address 0x5c00800 is in a rw- anonymous segment\r\n```\r\n\r\nThere's another UB regarding rendering boxes if we add a `SELECT * FROM test_list_2` at the end:\r\n\r\n```\r\n==27977== Conditional jump or move depends on uninitialised value(s)\r\n==27977==    at 0x8AB796: duckdb::BoxRenderer::ComputeRenderWidths(duckdb::vector<std::string, true> const&, duckdb::vector<duckdb::LogicalType, true> const&, std::list<duckdb::ColumnDataCollection, std::allocator<duckdb::ColumnDataCollection> >&, unsigned long, unsigned long, duckdb::vector<unsigned long, true>&, unsigned long&) (in /duckdb/duckdb)\r\n==27977==    by 0x8B614B: duckdb::BoxRenderer::Render(duckdb::ClientContext&, duckdb::vector<std::string, true> const&, duckdb::ColumnDataCollection const&, std::ostream&) (in /duckdb/duckdb)\r\n==27977==    by 0x8B6E58: duckdb::BoxRenderer::ToString(duckdb::ClientContext&, duckdb::vector<std::string, true> const&, duckdb::ColumnDataCollection const&) (in /duckdb/duckdb)\r\n==27977==    by 0x6D4B2A: duckdb_shell_sqlite3_print_duckbox (in /duckdb/duckdb)\r\n==27977==    by 0x6C4321: exec_prepared_stmt (in /duckdb/duckdb)\r\n==27977==    by 0x6C54D4: shell_exec (in /duckdb/duckdb)\r\n==27977==    by 0x6C6FAF: runOneSqlLine.constprop.0 (in /duckdb/duckdb)\r\n==27977==    by 0x6CF440: process_input (in /duckdb/duckdb)\r\n==27977==    by 0x6A2FB0: main (in /duckdb/duckdb)\r\n```\r\n\n\n### OS:\n\nUbuntu Linux amd64\n\n### DuckDB Version:\n\nv0.10.2-dev684\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nKirill M\u00fcller\n\n### Affiliation:\n\ncynkra GmbH\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a nightly build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-04-16T09:51:09Z"
}