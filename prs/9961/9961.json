{
  "repo": "duckdb/duckdb",
  "pull_number": 9961,
  "instance_id": "duckdb__duckdb-9961",
  "issue_numbers": [
    "9824"
  ],
  "base_commit": "5d9cd9308d80eaef8b58c158b97e0b66ab73b276",
  "patch": "diff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp\nindex 79cd4ef6d3a5..bb52d77478a4 100644\n--- a/src/include/duckdb/main/config.hpp\n+++ b/src/include/duckdb/main/config.hpp\n@@ -187,7 +187,8 @@ struct DBConfig {\n \n public:\n \tDUCKDB_API DBConfig();\n-\tDUCKDB_API DBConfig(std::unordered_map<string, string> &config_dict, bool read_only);\n+\tDUCKDB_API DBConfig(bool read_only);\n+\tDUCKDB_API DBConfig(const case_insensitive_map_t<Value> &config_dict, bool read_only);\n \tDUCKDB_API ~DBConfig();\n \n \tmutex config_lock;\n@@ -240,6 +241,7 @@ struct DBConfig {\n \tDUCKDB_API void SetOption(const ConfigurationOption &option, const Value &value);\n \tDUCKDB_API void SetOption(DatabaseInstance *db, const ConfigurationOption &option, const Value &value);\n \tDUCKDB_API void SetOptionByName(const string &name, const Value &value);\n+\tDUCKDB_API void SetOptionsByName(const case_insensitive_map_t<Value> &values);\n \tDUCKDB_API void ResetOption(DatabaseInstance *db, const ConfigurationOption &option);\n \tDUCKDB_API void SetOption(const string &name, Value value);\n \tDUCKDB_API void ResetOption(const string &name);\ndiff --git a/src/main/config.cpp b/src/main/config.cpp\nindex 65871c8c6ecf..66fd433837e0 100644\n--- a/src/main/config.cpp\n+++ b/src/main/config.cpp\n@@ -183,6 +183,14 @@ void DBConfig::SetOptionByName(const string &name, const Value &value) {\n \t}\n }\n \n+void DBConfig::SetOptionsByName(const case_insensitive_map_t<Value> &values) {\n+\tfor (auto &kv : values) {\n+\t\tauto &name = kv.first;\n+\t\tauto &value = kv.second;\n+\t\tSetOptionByName(name, value);\n+\t}\n+}\n+\n void DBConfig::SetOption(DatabaseInstance *db, const ConfigurationOption &option, const Value &value) {\n \tlock_guard<mutex> l(config_lock);\n \tif (!option.set_global) {\ndiff --git a/src/main/database.cpp b/src/main/database.cpp\nindex de2e1854f382..7b5744068339 100644\n--- a/src/main/database.cpp\n+++ b/src/main/database.cpp\n@@ -34,16 +34,14 @@ DBConfig::DBConfig() {\n \toptions.duckdb_api = StringUtil::Format(\"duckdb/%s(%s)\", DuckDB::LibraryVersion(), DuckDB::Platform());\n }\n \n-DBConfig::DBConfig(std::unordered_map<string, string> &config_dict, bool read_only) : DBConfig::DBConfig() {\n+DBConfig::DBConfig(bool read_only) : DBConfig::DBConfig() {\n \tif (read_only) {\n \t\toptions.access_mode = AccessMode::READ_ONLY;\n \t}\n-\tfor (auto &kv : config_dict) {\n-\t\tstring key = kv.first;\n-\t\tstring val = kv.second;\n-\t\tauto opt_val = Value(val);\n-\t\tDBConfig::SetOptionByName(key, opt_val);\n-\t}\n+}\n+\n+DBConfig::DBConfig(const case_insensitive_map_t<Value> &config_dict, bool read_only) : DBConfig::DBConfig(read_only) {\n+\tSetOptionsByName(config_dict);\n }\n \n DBConfig::~DBConfig() {\n@@ -307,6 +305,7 @@ void DatabaseInstance::Configure(DBConfig &new_config) {\n \tif (config.options.access_mode == AccessMode::UNDEFINED) {\n \t\tconfig.options.access_mode = AccessMode::READ_WRITE;\n \t}\n+\tconfig.extension_parameters = new_config.extension_parameters;\n \tif (new_config.file_system) {\n \t\tconfig.file_system = std::move(new_config.file_system);\n \t} else {\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 3b268a8aa33f..4e390f9b4bde 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -1453,12 +1453,12 @@ static unique_ptr<TableRef> ScanReplacement(ClientContext &context, const string\n \treturn nullptr;\n }\n \n-unordered_map<string, string> TransformPyConfigDict(const py::dict &py_config_dict) {\n-\tunordered_map<string, string> config_dict;\n+case_insensitive_map_t<Value> TransformPyConfigDict(const py::dict &py_config_dict) {\n+\tcase_insensitive_map_t<Value> config_dict;\n \tfor (auto &kv : py_config_dict) {\n \t\tauto key = py::str(kv.first);\n \t\tauto val = py::str(kv.second);\n-\t\tconfig_dict[key] = val;\n+\t\tconfig_dict[key] = Value(val);\n \t}\n \treturn config_dict;\n }\n@@ -1466,6 +1466,9 @@ unordered_map<string, string> TransformPyConfigDict(const py::dict &py_config_di\n void CreateNewInstance(DuckDBPyConnection &res, const string &database, DBConfig &config) {\n \t// We don't cache unnamed memory instances (i.e., :memory:)\n \tbool cache_instance = database != \":memory:\" && !database.empty();\n+\tif (config.options.enable_external_access) {\n+\t\tconfig.replacement_scans.emplace_back(ScanReplacement);\n+\t}\n \tres.database = instance_cache.CreateInstance(database, config, cache_instance);\n \tres.connection = make_uniq<Connection>(*res.database);\n \tauto &context = *res.connection->context;\n@@ -1478,13 +1481,6 @@ void CreateNewInstance(DuckDBPyConnection &res, const string &database, DBConfig\n \tcatalog.CreateTableFunction(context, &scan_info);\n \tcatalog.CreateTableFunction(context, &map_info);\n \tcontext.transaction.Commit();\n-\tauto &db_config = res.database->instance->config;\n-\tdb_config.AddExtensionOption(\"pandas_analyze_sample\",\n-\t                             \"The maximum number of rows to sample when analyzing a pandas object column.\",\n-\t                             LogicalType::UBIGINT, Value::UBIGINT(1000));\n-\tif (db_config.options.enable_external_access) {\n-\t\tdb_config.replacement_scans.emplace_back(ScanReplacement);\n-\t}\n }\n \n static bool HasJupyterProgressBarDependencies() {\n@@ -1532,7 +1528,7 @@ static shared_ptr<DuckDBPyConnection> FetchOrCreateInstance(const string &databa\n \treturn res;\n }\n \n-bool IsDefaultConnectionString(const string &database, bool read_only, unordered_map<string, string> &config) {\n+bool IsDefaultConnectionString(const string &database, bool read_only, case_insensitive_map_t<Value> &config) {\n \tbool is_default = StringUtil::CIEquals(database, \":default:\");\n \tif (!is_default) {\n \t\treturn false;\n@@ -1551,8 +1547,13 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const string &databas\n \t\treturn DuckDBPyConnection::DefaultConnection();\n \t}\n \n-\tDBConfig config(config_dict, read_only);\n-\tconfig.SetOptionByName(\"duckdb_api\", \"python\");\n+\tDBConfig config(read_only);\n+\tconfig.AddExtensionOption(\"pandas_analyze_sample\",\n+\t                          \"The maximum number of rows to sample when analyzing a pandas object column.\",\n+\t                          LogicalType::UBIGINT, Value::UBIGINT(1000));\n+\tconfig_dict[\"duckdb_api\"] = Value(\"python\");\n+\tconfig.SetOptionsByName(config_dict);\n+\n \tauto res = FetchOrCreateInstance(database, config);\n \tauto &client_context = *res->connection->context;\n \tSetDefaultConfigArguments(client_context);\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_duckdb_connection.py b/tools/pythonpkg/tests/fast/api/test_duckdb_connection.py\nindex d297b6558a0e..ce5b38ec7c10 100644\n--- a/tools/pythonpkg/tests/fast/api/test_duckdb_connection.py\n+++ b/tools/pythonpkg/tests/fast/api/test_duckdb_connection.py\n@@ -277,3 +277,16 @@ def test_wrap_coverage(self):\n         for method in filtered_methods:\n             # Assert that every method of DuckDBPyConnection is wrapped by the 'duckdb' module\n             assert method in dir(duckdb)\n+\n+    def test_set_pandas_analyze_sample_size(self):\n+        con = duckdb.connect(\":memory:named\", config={\"pandas_analyze_sample\": 0})\n+        res = con.sql(\"select current_setting('pandas_analyze_sample')\").fetchone()\n+        assert res == (0,)\n+\n+        # Find the cached config\n+        con2 = duckdb.connect(\":memory:named\", config={\"pandas_analyze_sample\": 0})\n+        con2.execute(f\"SET GLOBAL pandas_analyze_sample=2\")\n+\n+        # This change is reflected in 'con' because the instance was cached\n+        res = con.sql(\"select current_setting('pandas_analyze_sample')\").fetchone()\n+        assert res == (2,)\n",
  "problem_statement": "Unrecognized configuration property \"pandas_analyze_sample\"\n### What happens?\n\nUsing the duckdb package in Python. When passing the configuration setting `pandas_analyze_sample` on connection creation, I get the following exception:\r\n\r\n```\r\nInvalidInputException: Invalid Input Error: Unrecognized configuration property \"pandas_analyze_sample\"\r\n```\r\n\r\nI'm working with sparse tables where some columns are identified as `NULL` with the default `pandas_analyze_sample` set to 1000. I understand the documentation [shows an alternative method](https://duckdb.org/docs/api/python/data_ingestion#pandas-dataframes--object-columns) to set this configuration, but my use case necessitates passing the configuration as an argument to a connection.\r\n\r\nA workaround could be an alternative way of turning off this scanning behavior and casting any `Object` column to `VARCHAR`, but I've not been able to figure out how.  This is [observed here](https://github.com/duckdb/duckdb/issues/6811#issuecomment-1478721336) when `pandas_analyze_sample` is set to 0, but still with a `SET` statement. \n\n### To Reproduce\n\n``` python\r\nimport duckdb\r\n\r\ncon = duckdb.connect(\"empty_db.duckdb\", config={\"pandas_analyze_sample\":0})\r\n```\n\n### OS:\n\nMacOS 14.1.1\n\n### DuckDB Version:\n\n0.9.3.dev42\n\n### DuckDB Client:\n\nv0.9.2 3c695d7ba9\n\n### Full Name:\n\nBen Evans\n\n### Affiliation:\n\nSarepta Therapeutics\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2023-12-12T09:40:00Z"
}