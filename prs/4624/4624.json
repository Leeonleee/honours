{
  "repo": "duckdb/duckdb",
  "pull_number": 4624,
  "instance_id": "duckdb__duckdb-4624",
  "issue_numbers": [
    "4623"
  ],
  "base_commit": "9656abd17652e620e9d56b0ffa3a2974a80d38ea",
  "patch": "diff --git a/tools/pythonpkg/src/include/duckdb_python/python_conversion.hpp b/tools/pythonpkg/src/include/duckdb_python/python_conversion.hpp\nindex e7db49b0f823..b5b5d6433bed 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/python_conversion.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/python_conversion.hpp\n@@ -21,6 +21,7 @@ namespace duckdb {\n \n bool TryTransformPythonNumeric(Value &res, py::handle ele);\n bool DictionaryHasMapFormat(const PyDictionary &dict);\n-Value TransformPythonValue(py::handle ele, const LogicalType &target_type = LogicalType::UNKNOWN);\n+Value TransformPythonValue(py::handle ele, const LogicalType &target_type = LogicalType::UNKNOWN,\n+                           bool nan_as_null = true);\n \n } // namespace duckdb\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 56c4898969c4..6559237aab8a 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -669,7 +669,7 @@ vector<Value> DuckDBPyConnection::TransformPythonParamList(py::handle params) {\n \targs.reserve(py::len(params));\n \n \tfor (auto param : params) {\n-\t\targs.emplace_back(TransformPythonValue(param));\n+\t\targs.emplace_back(TransformPythonValue(param, LogicalType::UNKNOWN, false));\n \t}\n \treturn args;\n }\ndiff --git a/tools/pythonpkg/src/python_conversion.cpp b/tools/pythonpkg/src/python_conversion.cpp\nindex a0fec39f8812..1d5d96f39201 100644\n--- a/tools/pythonpkg/src/python_conversion.cpp\n+++ b/tools/pythonpkg/src/python_conversion.cpp\n@@ -201,7 +201,7 @@ bool TryTransformPythonNumeric(Value &res, py::handle ele) {\n \treturn true;\n }\n \n-Value TransformPythonValue(py::handle ele, const LogicalType &target_type) {\n+Value TransformPythonValue(py::handle ele, const LogicalType &target_type, bool nan_as_null) {\n \tauto &import_cache = *DuckDBPyConnection::ImportCache();\n \n \tif (ele.is_none()) {\n@@ -215,7 +215,7 @@ Value TransformPythonValue(py::handle ele, const LogicalType &target_type) {\n \t\t}\n \t\treturn integer;\n \t} else if (py::isinstance<py::float_>(ele)) {\n-\t\tif (std::isnan(PyFloat_AsDouble(ele.ptr()))) {\n+\t\tif (nan_as_null && std::isnan(PyFloat_AsDouble(ele.ptr()))) {\n \t\t\treturn Value();\n \t\t}\n \t\treturn Value::DOUBLE(ele.cast<double>());\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_all_types.py b/tools/pythonpkg/tests/fast/test_all_types.py\nindex d13f3049af78..cf1da547874b 100644\n--- a/tools/pythonpkg/tests/fast/test_all_types.py\n+++ b/tools/pythonpkg/tests/fast/test_all_types.py\n@@ -356,7 +356,7 @@ def test_arrow(self, duckdb_cursor):\n                 round_trip_arrow_table = conn.execute(\"select * from arrow_table\").arrow()\n                 assert arrow_table.equals(round_trip_arrow_table, check_metadata=True)\n \n-    def test_pandas(self, duckdb_cursor):\n+    def test_pandas(self):\n         # We skip those since the extreme ranges are not supported in python.\n         replacement_values = { 'timestamp': \"'1990-01-01 00:00:00'::TIMESTAMP\",\n             'timestamp_s': \"'1990-01-01 00:00:00'::TIMESTAMP_S\",\n@@ -378,5 +378,6 @@ def test_pandas(self, duckdb_cursor):\n             print(cur_type)\n             round_trip_dataframe = conn.execute(\"select * from dataframe\").df()\n             result_dataframe = conn.execute(\"select * from dataframe\").fetchall()\n+            print(round_trip_dataframe)\n             result_roundtrip = conn.execute(\"select * from round_trip_dataframe\").fetchall()\n             assert recursive_equality(result_dataframe, result_roundtrip)\ndiff --git a/tools/pythonpkg/tests/fast/test_parameter_list.py b/tools/pythonpkg/tests/fast/test_parameter_list.py\nindex e18839817ac5..95f6c77462bc 100644\n--- a/tools/pythonpkg/tests/fast/test_parameter_list.py\n+++ b/tools/pythonpkg/tests/fast/test_parameter_list.py\n@@ -17,3 +17,8 @@ def test_exception(self, duckdb_cursor):\n         conn.execute(\"insert into bool_table values (TRUE)\")\n         with pytest.raises(duckdb.NotImplementedException, match='Unable to transform'):\n             res = conn.execute(\"select count(*) from bool_table where a =?\",[df_in])\n+\n+    def test_explicit_nan_param(self):\n+        con = duckdb.default_connection\n+        res = con.execute('select isnan(cast(? as double))', (float(\"nan\"),))\n+        assert(res.fetchone()[0] == True)\n",
  "problem_statement": "isnan seems to treat nan parameters as `NULL`\n### What happens?\n\nWhen `nan` is used as a bind parameter in the Python client it appears to be treated as null.\n\n### To Reproduce\n\n```\r\n>>> import duckdb\r\n>>> con = duckdb.connect()\r\n>>> con.execute('select isnan(cast(? as double))', (float(\"nan\"),)).fetchall()\r\n[(None,)]\r\n>>> duckdb.__version__\r\n'0.5.0'\r\n```\n\n### OS:\n\nNixOS\n\n### DuckDB Version:\n\n0.5.0\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nPhillip Cloud\n\n### Affiliation:\n\nVoltron Data\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "The problem is caused by functionality added to be able to roundtrip from pandas back to duckdb\r\nIf we transform a result containing NULL to pandas, it turns into NaN.\r\n\r\nWhen we read this DataFrame back to duckdb, we have to treat these NaN's as NULL.\r\nIt might be fixed by adding an extra flag to differentiate between the contexts of the python conversions",
  "created_at": "2022-09-06T11:17:36Z"
}