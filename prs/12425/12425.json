{
  "repo": "duckdb/duckdb",
  "pull_number": 12425,
  "instance_id": "duckdb__duckdb-12425",
  "issue_numbers": [
    "11687"
  ],
  "base_commit": "59f3e94d149a52b3bd030c0ab5bffed9973ca72d",
  "patch": "diff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex d671b44815be..66693a5702a8 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -1522,6 +1522,9 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const string &databas\n \tconfig.AddExtensionOption(\"pandas_analyze_sample\",\n \t                          \"The maximum number of rows to sample when analyzing a pandas object column.\",\n \t                          LogicalType::UBIGINT, Value::UBIGINT(1000));\n+\tconfig.AddExtensionOption(\"python_enable_replacements\",\n+\t                          \"Whether variables visible to the current stack should be used for replacement scans.\",\n+\t                          LogicalType::BOOLEAN, Value::BOOLEAN(true));\n \tif (!DuckDBPyConnection::IsJupyter()) {\n \t\tconfig_dict[\"duckdb_api\"] = Value(\"python\");\n \t} else {\ndiff --git a/tools/pythonpkg/src/python_replacement_scan.cpp b/tools/pythonpkg/src/python_replacement_scan.cpp\nindex 2119f7e5855a..bfa317c60b3f 100644\n--- a/tools/pythonpkg/src/python_replacement_scan.cpp\n+++ b/tools/pythonpkg/src/python_replacement_scan.cpp\n@@ -153,31 +153,37 @@ static unique_ptr<TableRef> TryReplacement(py::dict &dict, const string &name, C\n }\n \n static unique_ptr<TableRef> ReplaceInternal(ClientContext &context, const string &table_name) {\n+\tValue result;\n+\tauto lookup_result = context.TryGetCurrentSetting(\"python_enable_replacements\", result);\n+\tD_ASSERT((bool)lookup_result);\n+\tauto enabled = result.GetValue<bool>();\n+\n+\tif (!enabled) {\n+\t\treturn nullptr;\n+\t}\n+\n \tpy::gil_scoped_acquire acquire;\n-\t// Here we do an exhaustive search on the frame lineage\n \tauto current_frame = py::module::import(\"inspect\").attr(\"currentframe\")();\n-\twhile (hasattr(current_frame, \"f_locals\")) {\n-\t\tauto local_dict = py::reinterpret_borrow<py::dict>(current_frame.attr(\"f_locals\"));\n-\t\t// search local dictionary\n-\t\tif (local_dict) {\n-\t\t\tauto result = TryReplacement(local_dict, table_name, context, current_frame);\n-\t\t\tif (result) {\n-\t\t\t\treturn result;\n-\t\t\t}\n+\n+\tauto local_dict = py::reinterpret_borrow<py::dict>(current_frame.attr(\"f_locals\"));\n+\t// search local dictionary\n+\tif (local_dict) {\n+\t\tauto result = TryReplacement(local_dict, table_name, context, current_frame);\n+\t\tif (result) {\n+\t\t\treturn result;\n \t\t}\n-\t\t// search global dictionary\n-\t\tauto global_dict = py::reinterpret_borrow<py::dict>(current_frame.attr(\"f_globals\"));\n-\t\tif (global_dict) {\n-\t\t\tauto result = TryReplacement(global_dict, table_name, context, current_frame);\n-\t\t\tif (result) {\n-\t\t\t\treturn result;\n-\t\t\t}\n+\t}\n+\t// search global dictionary\n+\tauto global_dict = py::reinterpret_borrow<py::dict>(current_frame.attr(\"f_globals\"));\n+\tif (global_dict) {\n+\t\tauto result = TryReplacement(global_dict, table_name, context, current_frame);\n+\t\tif (result) {\n+\t\t\treturn result;\n \t\t}\n-\t\tcurrent_frame = current_frame.attr(\"f_back\");\n \t}\n-\t// Not found :(\n \treturn nullptr;\n }\n+\n unique_ptr<TableRef> PythonReplacementScan::Replace(ClientContext &context, ReplacementScanInput &input,\n                                                     optional_ptr<ReplacementScanData> data) {\n \tauto &table_name = input.table_name;\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_replacement_scan.py b/tools/pythonpkg/tests/fast/test_replacement_scan.py\nindex f02db7e0338f..defb9c5d34bb 100644\n--- a/tools/pythonpkg/tests/fast/test_replacement_scan.py\n+++ b/tools/pythonpkg/tests/fast/test_replacement_scan.py\n@@ -47,6 +47,16 @@ def fetch_relation(rel):\n     return rel\n \n \n+global_polars_df = pl.DataFrame(\n+    {\n+        \"A\": [1],\n+        \"fruits\": [\"banana\"],\n+        \"B\": [5],\n+        \"cars\": [\"beetle\"],\n+    }\n+)\n+\n+\n def from_pandas():\n     df = pd.DataFrame({'a': [1, 2, 3]})\n     return df\n@@ -91,6 +101,43 @@ def test_table_replacement_scans(self, duckdb_cursor, get_relation, fetch_method\n         res = rel.fetchall()\n         assert res == [(1, 2, 3)]\n \n+    def test_scan_global(self, duckdb_cursor):\n+        duckdb_cursor.execute(\"set python_enable_replacements=false\")\n+        with pytest.raises(duckdb.CatalogException, match='Table with name global_polars_df does not exist'):\n+            # We set the depth to look for global variables to 0 so it's never found\n+            duckdb_cursor.sql(\"select * from global_polars_df\")\n+        duckdb_cursor.execute(\"set python_enable_replacements=true\")\n+        # Now the depth is 1, which is enough to locate the variable\n+        rel = duckdb_cursor.sql(\"select * from global_polars_df\")\n+        res = rel.fetchone()\n+        assert res == (1, 'banana', 5, 'beetle')\n+\n+    def test_scan_local(self, duckdb_cursor):\n+        df = pd.DataFrame({'a': [1, 2, 3]})\n+\n+        def inner_func(duckdb_cursor):\n+            duckdb_cursor.execute(\"set python_enable_replacements=false\")\n+            with pytest.raises(duckdb.CatalogException, match='Table with name df does not exist'):\n+                # We set the depth to look for local variables to 0 so it's never found\n+                duckdb_cursor.sql(\"select * from df\")\n+            duckdb_cursor.execute(\"set python_enable_replacements=true\")\n+            with pytest.raises(duckdb.CatalogException, match='Table with name df does not exist'):\n+                # We set the depth to look for local variables to 1 so it's still not found because it wasn't defined in this function\n+                duckdb_cursor.sql(\"select * from df\")\n+            duckdb_cursor.execute(\"set python_enable_replacements=true\")\n+            with pytest.raises(duckdb.CatalogException, match='Table with name df does not exist'):\n+                # Here it's still not found, because it's not visible to this frame\n+                duckdb_cursor.sql(\"select * from df\")\n+\n+            df = pd.DataFrame({'a': [4, 5, 6]})\n+            duckdb_cursor.execute(\"set python_enable_replacements=true\")\n+            # We can find the newly defined 'df' with depth 1\n+            rel = duckdb_cursor.sql(\"select * from df\")\n+            res = rel.fetchall()\n+            assert res == [(4,), (5,), (6,)]\n+\n+        inner_func(duckdb_cursor)\n+\n     def test_replacement_scan_relapi(self):\n         con = duckdb.connect()\n         pyrel1 = con.query('from (values (42), (84), (120)) t(i)')\n",
  "problem_statement": "Variables can 'leak' through the stack in Python\n### What happens?\n\nThe Python API will use Python variables in `sql` even if they aren't available in the local scope in Python,\r\nthey just have to be in scope somewhere in the call stack.\r\n\r\nThis makes code unpredictable because you need to be aware of all in scope variables in the entire call stack when using `sql`, and a change in a caller could easily 'leak' a variable in to SQL if the names happen to match \ud83d\ude31 \n\n### To Reproduce\n\nHere I demonstrate how I was handling the optional existence of a `data` table,\r\nbut then I introduce a `data` variable in the calling `main` function which  'leaks' in to `foo`,\r\neven though Python knows it's out of scope (`NameError`):\r\n\r\n```py\r\nfrom duckdb import CatalogException, connect\r\n\r\n\r\ndef foo():\r\n    try:\r\n        print(f'foo {data}')\r\n    except NameError:\r\n        print('foo name error')\r\n\r\n    con = connect()\r\n\r\n    try:\r\n        con.sql('select * from data')\r\n    except CatalogException:\r\n        print('no data table')\r\n\r\n\r\ndef main():\r\n    try:\r\n        print(f'main {data}')\r\n    except NameError:\r\n        print('main name error')\r\n\r\n    foo()  # no data table, correct\r\n\r\n    data = [1, 2, 3, 4, 5]\r\n    print(f'main {data}')\r\n\r\n    foo() # Unexpected InvalidInputException\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n```\r\n\r\n```\r\nmain name error\r\nfoo name error\r\nno data table\r\nmain [1, 2, 3, 4, 5]\r\nfoo name error\r\nTraceback (most recent call last):\r\n  File \"/workspaces/ng/leaky_var.py\", line 33, in <module>\r\n    main()\r\n  File \"/workspaces/ng/leaky_var.py\", line 29, in main\r\n    foo()  # InvalidInputException: Invalid Input Error: Python Object \"data\" of type \"list\"\r\n    ^^^^^\r\n  File \"/workspaces/ng/leaky_var.py\", line 13, in foo\r\n    con.sql('select * from data')\r\nduckdb.duckdb.InvalidInputException: Invalid Input Error: Python Object \"data\" of type \"list\" found on line \"/workspaces/ng/leaky_var.py:29\" not suitable for replacement scans.\r\nMake sure that \"data\" is either a pandas.DataFrame, duckdb.DuckDBPyRelation, pyarrow Table, Dataset, RecordBatchReader, Scanner, or NumPy ndarrays with supported format\r\n```\n\n### OS:\n\nUbuntu\n\n### DuckDB Version:\n\n0.9.2\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nDave Tapley\n\n### Affiliation:\n\nJE Fuller\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a nightly build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "In a previous discussion at \r\nhttps://github.com/duckdb/duckdb/discussions/10962 (for example MWE2b there)  I was told this is expected given that `query` is lazy. I personally think it should only be lazy in execution of the SQL not in binding variables and hope this new ticket might convince the maintainers (since your ticket is more to the point than previous tickets and discussions started by myself about my confusion with the Python API). \r\n\r\nIn the meantime, the solution to your problem is supposed to be calling `execute` on the query. Unfortunately, that's currently broken and tracked at https://github.com/duckdb/duckdb/issues/11224\nI have seen a proposal to add an optional context to be used by `sql`/`execute` replacement scans\r\n\r\nI think that might be a good addition, or a maximum depth of stacks to traverse in the effort to look up the variable, which would be 1 here.\r\nOne difficulty in this is that we traverse both local and global stacks, perhaps both should have a corresponding stack depth setting\r\n\r\nThat would also tie in to another request I have seen which is to entirely disable replacement scans\r\n<https://github.com/duckdb/duckdb/discussions/8100>\r\nIf the traversal depth was set to 0 that would also satisfy that request\nFeature proposal for context parameter here: https://github.com/duckdb/duckdb/discussions/10191 ",
  "created_at": "2024-06-07T08:46:33Z"
}