{
  "repo": "duckdb/duckdb",
  "pull_number": 5299,
  "instance_id": "duckdb__duckdb-5299",
  "issue_numbers": [
    "5296"
  ],
  "base_commit": "0a75d208959870dfbbf3638b08a2fa6801dbd59f",
  "patch": "diff --git a/tools/pythonpkg/src/pandas_type.cpp b/tools/pythonpkg/src/pandas_type.cpp\nindex f6a410324fdc..405827050b20 100644\n--- a/tools/pythonpkg/src/pandas_type.cpp\n+++ b/tools/pythonpkg/src/pandas_type.cpp\n@@ -11,13 +11,13 @@ PandasType ConvertPandasType(const py::object &col_type) {\n \n \tif (col_type_str == \"bool\" || col_type_str == \"boolean\") {\n \t\treturn PandasType::BOOL;\n-\t} else if (col_type_str == \"uint8\" || col_type_str == \"Uint8\") {\n+\t} else if (col_type_str == \"uint8\" || col_type_str == \"UInt8\") {\n \t\treturn PandasType::UINT_8;\n-\t} else if (col_type_str == \"uint16\" || col_type_str == \"Uint16\") {\n+\t} else if (col_type_str == \"uint16\" || col_type_str == \"UInt16\") {\n \t\treturn PandasType::UINT_16;\n-\t} else if (col_type_str == \"uint32\" || col_type_str == \"Uint32\") {\n+\t} else if (col_type_str == \"uint32\" || col_type_str == \"UInt32\") {\n \t\treturn PandasType::UINT_32;\n-\t} else if (col_type_str == \"uint64\" || col_type_str == \"Uint64\") {\n+\t} else if (col_type_str == \"uint64\" || col_type_str == \"UInt64\") {\n \t\treturn PandasType::UINT_64;\n \t} else if (col_type_str == \"int8\" || col_type_str == \"Int8\") {\n \t\treturn PandasType::INT_8;\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py b/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py\nindex f27c2ee2611e..a10829e00590 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py\n@@ -1,6 +1,7 @@\n import duckdb\n import pandas as pd\n import numpy\n+import string\n \n def round_trip(data,pandas_type):\n     df_in = pd.DataFrame({\n@@ -13,6 +14,52 @@ def round_trip(data,pandas_type):\n     assert df_out.equals(df_in)\n \n class TestPandasTypes(object):\n+    def test_pandas_numeric(self):\n+        base_df = pd.DataFrame(\n+            {'a':range(10)}\n+        )\n+\n+        data_types = [\n+            \"uint8\",\n+            \"UInt8\",\n+            \"uint16\",\n+            \"UInt16\",\n+            \"uint32\",\n+            \"UInt32\",\n+            \"uint64\",\n+            \"UInt64\",\n+            \"int8\",\n+            \"Int8\",\n+            \"int16\",\n+            \"Int16\",\n+            \"int32\",\n+            \"Int32\",\n+            \"int64\",\n+            \"Int64\",\n+            \"float32\",\n+            \"Float32\",\n+            \"float64\",\n+            \"Float64\"\n+        ]\n+\n+        # Generate a dataframe with all the types, in the form of:\n+        # b=type1,\n+        # c=type2\n+        # ..\n+        data = {}\n+        for letter, dtype in zip(string.ascii_lowercase, data_types):\n+            data[letter] = base_df.a.astype(dtype)\n+\n+        df = pd.DataFrame.from_dict(data)\n+        conn = duckdb.connect()\n+        out_df = conn.execute('select * from df').df()\n+\n+        # Verify that the types in the out_df are correct\n+        # FIXME: we don't support outputting pandas specific types (i.e UInt64)\n+        for letter, item in zip(string.ascii_lowercase, data_types):\n+            column_name = letter\n+            assert(str(out_df[column_name].dtype) == item.lower())\n+\n     def test_pandas_unsigned(self, duckdb_cursor):\n         unsigned_types = ['uint8','uint16','uint32','uint64']\n         data = numpy.array([0,1,2,3])\n",
  "problem_statement": "Support pandas nullable unsigned integer types (such as `UInt64` )\n### What happens?\r\n\r\nPandas dataframes with nullable unsigned integers can't be queried with duckdb\r\n\r\n### To Reproduce\r\n\r\n```python\r\nimport duckdb, pandas as pd, numpy as np\r\ndb = duckdb.connect()\r\ndf = pd.DataFrame({'a':range(10)}).pipe(lambda df: df.assign(b=df.a.astype('Int64'), c=df.a.astype('UInt64'), d=df.a.astype('uint64')))\r\ndb.execute('select * from df').df()\r\n```\r\n### Result:\r\n```python\r\n---------------------------------------------------------------------------\r\nNotImplementedException                   Traceback (most recent call last)\r\n/tmp/ipykernel_103/56270558.py in <module>\r\n      2 db = duckdb.connect()\r\n      3 df = pd.DataFrame({'a':range(10)}).pipe(lambda df: df.assign(b=df.a.astype('Int64'), c=df.a.astype('UInt64'), d=df.a.astype('uint64')))\r\n----> 4 db.execute('select * from df').df()\r\n\r\nNotImplementedException: Not implemented Error: Data type 'UInt64' not recognized\r\n```\r\n\r\n### OS:\r\n\r\nLinux (Linux-5.4.188+-x86_64-with-debian-buster-sid)\r\n\r\n### DuckDB Version:\r\n\r\n0.5.2-dev2131\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nPankaj Pandey\r\n\r\n### Affiliation:\r\n\r\nCadence\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "I read this and my first thought was: Didn't I add support for this?\r\n```c++\r\n\t} else if (col_type_str == \"uint8\" || col_type_str == \"Uint8\") {\r\n\t\treturn PandasType::UINT_8;\r\n\t} else if (col_type_str == \"uint16\" || col_type_str == \"Uint16\") {\r\n\t\treturn PandasType::UINT_16;\r\n\t} else if (col_type_str == \"uint32\" || col_type_str == \"Uint32\") {\r\n\t\treturn PandasType::UINT_32;\r\n\t} else if (col_type_str == \"uint64\" || col_type_str == \"Uint64\") {\r\n\t\treturn PandasType::UINT_64;\r\n```\r\nThe answer is yes, but it seems I didn't test it thoroughly enough?",
  "created_at": "2022-11-11T10:29:16Z"
}