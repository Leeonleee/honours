{
  "repo": "duckdb/duckdb",
  "pull_number": 8979,
  "instance_id": "duckdb__duckdb-8979",
  "issue_numbers": [
    "8328"
  ],
  "base_commit": "474a0bd68377edb26f6047263a4c19784bb17aea",
  "patch": "diff --git a/.github/config/uncovered_files.csv b/.github/config/uncovered_files.csv\nindex 5d27e881b3f6..5a4b77774e74 100644\n--- a/.github/config/uncovered_files.csv\n+++ b/.github/config/uncovered_files.csv\n@@ -49,7 +49,7 @@ common/re2_regex.cpp\t37\n common/row_operations/row_aggregate.cpp\t2\n common/row_operations/row_external.cpp\t26\n common/row_operations/row_gather.cpp\t11\n-common/row_operations/row_match.cpp\t4\n+common/row_operations/row_matcher.cpp\t13\n common/serializer/deserializer.cpp\t13\n common/serializer/serializer.cpp\t21\n common/serializer/buffered_file_reader.cpp\t11\ndiff --git a/src/common/radix_partitioning.cpp b/src/common/radix_partitioning.cpp\nindex 6fae9a154a95..b4dc39bd3a16 100644\n--- a/src/common/radix_partitioning.cpp\n+++ b/src/common/radix_partitioning.cpp\n@@ -188,7 +188,7 @@ void RadixPartitionedTupleData::InitializeAppendStateInternal(PartitionedTupleDa\n \tfor (idx_t col_idx = 0; col_idx < column_count; col_idx++) {\n \t\tcolumn_ids.emplace_back(col_idx);\n \t}\n-\tpartitions[0]->InitializeAppend(state.chunk_state, std::move(column_ids));\n+\tpartitions[0]->InitializeChunkState(state.chunk_state, std::move(column_ids));\n \n \t// Initialize fixed-size map\n \tstate.fixed_partition_entries.resize(RadixPartitioning::NumberOfPartitions(radix_bits));\ndiff --git a/src/common/row_operations/CMakeLists.txt b/src/common/row_operations/CMakeLists.txt\nindex fcf4026908b3..b07cd84aa466 100644\n--- a/src/common/row_operations/CMakeLists.txt\n+++ b/src/common/row_operations/CMakeLists.txt\n@@ -4,7 +4,7 @@ add_library_unity(\n   row_aggregate.cpp\n   row_scatter.cpp\n   row_gather.cpp\n-  row_match.cpp\n+  row_matcher.cpp\n   row_external.cpp\n   row_radix_scatter.cpp\n   row_heap_scatter.cpp\ndiff --git a/src/common/row_operations/row_match.cpp b/src/common/row_operations/row_match.cpp\ndeleted file mode 100644\nindex b7727e79dfe9..000000000000\n--- a/src/common/row_operations/row_match.cpp\n+++ /dev/null\n@@ -1,359 +0,0 @@\n-//===--------------------------------------------------------------------===//\n-// row_match.cpp\n-// Description: This file contains the implementation of the match operators\n-//===--------------------------------------------------------------------===//\n-\n-#include \"duckdb/common/exception.hpp\"\n-#include \"duckdb/common/operator/comparison_operators.hpp\"\n-#include \"duckdb/common/operator/constant_operators.hpp\"\n-#include \"duckdb/common/row_operations/row_operations.hpp\"\n-#include \"duckdb/common/types/row/tuple_data_collection.hpp\"\n-\n-namespace duckdb {\n-\n-using ValidityBytes = RowLayout::ValidityBytes;\n-using Predicates = RowOperations::Predicates;\n-\n-template <typename OP>\n-static idx_t SelectComparison(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n-                              SelectionVector *true_sel, SelectionVector *false_sel) {\n-\tthrow NotImplementedException(\"Unsupported nested comparison operand for RowOperations::Match\");\n-}\n-\n-template <>\n-idx_t SelectComparison<Equals>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n-                               SelectionVector *true_sel, SelectionVector *false_sel) {\n-\treturn VectorOperations::NestedEquals(left, right, sel, count, true_sel, false_sel);\n-}\n-\n-template <>\n-idx_t SelectComparison<NotEquals>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n-                                  SelectionVector *true_sel, SelectionVector *false_sel) {\n-\treturn VectorOperations::NestedNotEquals(left, right, sel, count, true_sel, false_sel);\n-}\n-\n-template <>\n-idx_t SelectComparison<GreaterThan>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n-                                    SelectionVector *true_sel, SelectionVector *false_sel) {\n-\treturn VectorOperations::DistinctGreaterThan(left, right, &sel, count, true_sel, false_sel);\n-}\n-\n-template <>\n-idx_t SelectComparison<GreaterThanEquals>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n-                                          SelectionVector *true_sel, SelectionVector *false_sel) {\n-\treturn VectorOperations::DistinctGreaterThanEquals(left, right, &sel, count, true_sel, false_sel);\n-}\n-\n-template <>\n-idx_t SelectComparison<LessThan>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n-                                 SelectionVector *true_sel, SelectionVector *false_sel) {\n-\treturn VectorOperations::DistinctLessThan(left, right, &sel, count, true_sel, false_sel);\n-}\n-\n-template <>\n-idx_t SelectComparison<LessThanEquals>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n-                                       SelectionVector *true_sel, SelectionVector *false_sel) {\n-\treturn VectorOperations::DistinctLessThanEquals(left, right, &sel, count, true_sel, false_sel);\n-}\n-\n-template <class T, class OP, bool NO_MATCH_SEL>\n-static void TemplatedMatchType(UnifiedVectorFormat &col, Vector &rows, SelectionVector &sel, idx_t &count,\n-                               idx_t col_offset, idx_t col_no, SelectionVector *no_match, idx_t &no_match_count) {\n-\t// Precompute row_mask indexes\n-\tidx_t entry_idx;\n-\tidx_t idx_in_entry;\n-\tValidityBytes::GetEntryIndex(col_no, entry_idx, idx_in_entry);\n-\n-\tauto data = UnifiedVectorFormat::GetData<T>(col);\n-\tauto ptrs = FlatVector::GetData<data_ptr_t>(rows);\n-\tidx_t match_count = 0;\n-\tif (!col.validity.AllValid()) {\n-\t\tfor (idx_t i = 0; i < count; i++) {\n-\t\t\tauto idx = sel.get_index(i);\n-\n-\t\t\tauto row = ptrs[idx];\n-\t\t\tValidityBytes row_mask(row);\n-\t\t\tauto isnull = !row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry);\n-\n-\t\t\tauto col_idx = col.sel->get_index(idx);\n-\t\t\tif (!col.validity.RowIsValid(col_idx)) {\n-\t\t\t\tif (isnull) {\n-\t\t\t\t\t// match: move to next value to compare\n-\t\t\t\t\tsel.set_index(match_count++, idx);\n-\t\t\t\t} else {\n-\t\t\t\t\tif (NO_MATCH_SEL) {\n-\t\t\t\t\t\tno_match->set_index(no_match_count++, idx);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tauto value = Load<T>(row + col_offset);\n-\t\t\t\tif (!isnull && OP::template Operation<T>(data[col_idx], value)) {\n-\t\t\t\t\tsel.set_index(match_count++, idx);\n-\t\t\t\t} else {\n-\t\t\t\t\tif (NO_MATCH_SEL) {\n-\t\t\t\t\t\tno_match->set_index(no_match_count++, idx);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t} else {\n-\t\tfor (idx_t i = 0; i < count; i++) {\n-\t\t\tauto idx = sel.get_index(i);\n-\n-\t\t\tauto row = ptrs[idx];\n-\t\t\tValidityBytes row_mask(row);\n-\t\t\tauto isnull = !row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry);\n-\n-\t\t\tauto col_idx = col.sel->get_index(idx);\n-\t\t\tauto value = Load<T>(row + col_offset);\n-\t\t\tif (!isnull && OP::template Operation<T>(data[col_idx], value)) {\n-\t\t\t\tsel.set_index(match_count++, idx);\n-\t\t\t} else {\n-\t\t\t\tif (NO_MATCH_SEL) {\n-\t\t\t\t\tno_match->set_index(no_match_count++, idx);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\tcount = match_count;\n-}\n-\n-//! Forward declaration for recursion\n-template <class OP, bool NO_MATCH_SEL>\n-static void TemplatedMatchOp(Vector &vec, UnifiedVectorFormat &col, const TupleDataLayout &layout, Vector &rows,\n-                             SelectionVector &sel, idx_t &count, idx_t col_no, SelectionVector *no_match,\n-                             idx_t &no_match_count, const idx_t original_count);\n-\n-template <class OP, bool NO_MATCH_SEL>\n-static void TemplatedMatchStruct(Vector &vec, UnifiedVectorFormat &col, const TupleDataLayout &layout, Vector &rows,\n-                                 SelectionVector &sel, idx_t &count, const idx_t col_no, SelectionVector *no_match,\n-                                 idx_t &no_match_count, const idx_t original_count) {\n-\t// Precompute row_mask indexes\n-\tidx_t entry_idx;\n-\tidx_t idx_in_entry;\n-\tValidityBytes::GetEntryIndex(col_no, entry_idx, idx_in_entry);\n-\n-\t// Work our way through the validity of the whole struct\n-\tauto ptrs = FlatVector::GetData<data_ptr_t>(rows);\n-\tidx_t match_count = 0;\n-\tif (!col.validity.AllValid()) {\n-\t\tfor (idx_t i = 0; i < count; i++) {\n-\t\t\tauto idx = sel.get_index(i);\n-\n-\t\t\tauto row = ptrs[idx];\n-\t\t\tValidityBytes row_mask(row);\n-\t\t\tauto isnull = !row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry);\n-\n-\t\t\tauto col_idx = col.sel->get_index(idx);\n-\t\t\tif (!col.validity.RowIsValid(col_idx)) {\n-\t\t\t\tif (isnull) {\n-\t\t\t\t\t// match: move to next value to compare\n-\t\t\t\t\tsel.set_index(match_count++, idx);\n-\t\t\t\t} else {\n-\t\t\t\t\tif (NO_MATCH_SEL) {\n-\t\t\t\t\t\tno_match->set_index(no_match_count++, idx);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tif (!isnull) {\n-\t\t\t\t\tsel.set_index(match_count++, idx);\n-\t\t\t\t} else {\n-\t\t\t\t\tif (NO_MATCH_SEL) {\n-\t\t\t\t\t\tno_match->set_index(no_match_count++, idx);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t} else {\n-\t\tfor (idx_t i = 0; i < count; i++) {\n-\t\t\tauto idx = sel.get_index(i);\n-\n-\t\t\tauto row = ptrs[idx];\n-\t\t\tValidityBytes row_mask(row);\n-\t\t\tauto isnull = !row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry);\n-\n-\t\t\tif (!isnull) {\n-\t\t\t\tsel.set_index(match_count++, idx);\n-\t\t\t} else {\n-\t\t\t\tif (NO_MATCH_SEL) {\n-\t\t\t\t\tno_match->set_index(no_match_count++, idx);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\tcount = match_count;\n-\n-\t// Now we construct row pointers to the structs\n-\tVector struct_rows(LogicalTypeId::POINTER);\n-\tauto struct_ptrs = FlatVector::GetData<data_ptr_t>(struct_rows);\n-\n-\tconst auto col_offset = layout.GetOffsets()[col_no];\n-\tfor (idx_t i = 0; i < count; i++) {\n-\t\tauto idx = sel.get_index(i);\n-\t\tauto row = ptrs[idx];\n-\t\tstruct_ptrs[idx] = row + col_offset;\n-\t}\n-\n-\t// Get the struct layout, child columns, then recurse\n-\tconst auto &struct_layout = layout.GetStructLayout(col_no);\n-\tauto &struct_entries = StructVector::GetEntries(vec);\n-\tD_ASSERT(struct_layout.ColumnCount() == struct_entries.size());\n-\tfor (idx_t struct_col_no = 0; struct_col_no < struct_layout.ColumnCount(); struct_col_no++) {\n-\t\tauto &struct_vec = *struct_entries[struct_col_no];\n-\t\tUnifiedVectorFormat struct_col;\n-\t\tstruct_vec.ToUnifiedFormat(original_count, struct_col);\n-\t\tTemplatedMatchOp<OP, NO_MATCH_SEL>(struct_vec, struct_col, struct_layout, struct_rows, sel, count,\n-\t\t                                   struct_col_no, no_match, no_match_count, original_count);\n-\t}\n-}\n-\n-template <class OP, bool NO_MATCH_SEL>\n-static void TemplatedMatchList(Vector &col, Vector &rows, SelectionVector &sel, idx_t &count,\n-                               const TupleDataLayout &layout, const idx_t col_no, SelectionVector *no_match,\n-                               idx_t &no_match_count) {\n-\t// Gather a dense Vector containing the column values being matched\n-\tVector key(col.GetType());\n-\tconst auto gather_function = TupleDataCollection::GetGatherFunction(col.GetType());\n-\tgather_function.function(layout, rows, col_no, sel, count, key, *FlatVector::IncrementalSelectionVector(), key,\n-\t                         gather_function.child_functions);\n-\n-\t// Densify the input column\n-\tVector sliced(col, sel, count);\n-\n-\tif (NO_MATCH_SEL) {\n-\t\tSelectionVector no_match_sel_offset(no_match->data() + no_match_count);\n-\t\tauto match_count = SelectComparison<OP>(sliced, key, sel, count, &sel, &no_match_sel_offset);\n-\t\tno_match_count += count - match_count;\n-\t\tcount = match_count;\n-\t} else {\n-\t\tcount = SelectComparison<OP>(sliced, key, sel, count, &sel, nullptr);\n-\t}\n-}\n-\n-template <class OP, bool NO_MATCH_SEL>\n-static void TemplatedMatchOp(Vector &vec, UnifiedVectorFormat &col, const TupleDataLayout &layout, Vector &rows,\n-                             SelectionVector &sel, idx_t &count, idx_t col_no, SelectionVector *no_match,\n-                             idx_t &no_match_count, const idx_t original_count) {\n-\tif (count == 0) {\n-\t\treturn;\n-\t}\n-\tauto col_offset = layout.GetOffsets()[col_no];\n-\tswitch (layout.GetTypes()[col_no].InternalType()) {\n-\tcase PhysicalType::BOOL:\n-\tcase PhysicalType::INT8:\n-\t\tTemplatedMatchType<int8_t, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                             no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::INT16:\n-\t\tTemplatedMatchType<int16_t, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                              no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::INT32:\n-\t\tTemplatedMatchType<int32_t, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                              no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::INT64:\n-\t\tTemplatedMatchType<int64_t, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                              no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::UINT8:\n-\t\tTemplatedMatchType<uint8_t, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                              no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::UINT16:\n-\t\tTemplatedMatchType<uint16_t, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                               no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::UINT32:\n-\t\tTemplatedMatchType<uint32_t, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                               no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::UINT64:\n-\t\tTemplatedMatchType<uint64_t, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                               no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::INT128:\n-\t\tTemplatedMatchType<hugeint_t, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                                no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::FLOAT:\n-\t\tTemplatedMatchType<float, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                            no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::DOUBLE:\n-\t\tTemplatedMatchType<double, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                             no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::INTERVAL:\n-\t\tTemplatedMatchType<interval_t, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                                 no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::VARCHAR:\n-\t\tTemplatedMatchType<string_t, OP, NO_MATCH_SEL>(col, rows, sel, count, col_offset, col_no, no_match,\n-\t\t                                               no_match_count);\n-\t\tbreak;\n-\tcase PhysicalType::STRUCT:\n-\t\tTemplatedMatchStruct<OP, NO_MATCH_SEL>(vec, col, layout, rows, sel, count, col_no, no_match, no_match_count,\n-\t\t                                       original_count);\n-\t\tbreak;\n-\tcase PhysicalType::LIST:\n-\t\tTemplatedMatchList<OP, NO_MATCH_SEL>(vec, rows, sel, count, layout, col_no, no_match, no_match_count);\n-\t\tbreak;\n-\tdefault:\n-\t\tthrow InternalException(\"Unsupported column type for RowOperations::Match\");\n-\t}\n-}\n-\n-template <bool NO_MATCH_SEL>\n-static void TemplatedMatch(DataChunk &columns, UnifiedVectorFormat col_data[], const TupleDataLayout &layout,\n-                           Vector &rows, const Predicates &predicates, SelectionVector &sel, idx_t &count,\n-                           SelectionVector *no_match, idx_t &no_match_count) {\n-\tfor (idx_t col_no = 0; col_no < predicates.size(); ++col_no) {\n-\t\tauto &vec = columns.data[col_no];\n-\t\tauto &col = col_data[col_no];\n-\t\tswitch (predicates[col_no]) {\n-\t\tcase ExpressionType::COMPARE_EQUAL:\n-\t\tcase ExpressionType::COMPARE_NOT_DISTINCT_FROM:\n-\t\tcase ExpressionType::COMPARE_DISTINCT_FROM:\n-\t\t\tTemplatedMatchOp<Equals, NO_MATCH_SEL>(vec, col, layout, rows, sel, count, col_no, no_match, no_match_count,\n-\t\t\t                                       count);\n-\t\t\tbreak;\n-\t\tcase ExpressionType::COMPARE_NOTEQUAL:\n-\t\t\tTemplatedMatchOp<NotEquals, NO_MATCH_SEL>(vec, col, layout, rows, sel, count, col_no, no_match,\n-\t\t\t                                          no_match_count, count);\n-\t\t\tbreak;\n-\t\tcase ExpressionType::COMPARE_GREATERTHAN:\n-\t\t\tTemplatedMatchOp<GreaterThan, NO_MATCH_SEL>(vec, col, layout, rows, sel, count, col_no, no_match,\n-\t\t\t                                            no_match_count, count);\n-\t\t\tbreak;\n-\t\tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n-\t\t\tTemplatedMatchOp<GreaterThanEquals, NO_MATCH_SEL>(vec, col, layout, rows, sel, count, col_no, no_match,\n-\t\t\t                                                  no_match_count, count);\n-\t\t\tbreak;\n-\t\tcase ExpressionType::COMPARE_LESSTHAN:\n-\t\t\tTemplatedMatchOp<LessThan, NO_MATCH_SEL>(vec, col, layout, rows, sel, count, col_no, no_match,\n-\t\t\t                                         no_match_count, count);\n-\t\t\tbreak;\n-\t\tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n-\t\t\tTemplatedMatchOp<LessThanEquals, NO_MATCH_SEL>(vec, col, layout, rows, sel, count, col_no, no_match,\n-\t\t\t                                               no_match_count, count);\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\tthrow InternalException(\"Unsupported comparison type for RowOperations::Match\");\n-\t\t}\n-\t}\n-}\n-\n-idx_t RowOperations::Match(DataChunk &columns, UnifiedVectorFormat col_data[], const TupleDataLayout &layout,\n-                           Vector &rows, const Predicates &predicates, SelectionVector &sel, idx_t count,\n-                           SelectionVector *no_match, idx_t &no_match_count) {\n-\tif (no_match) {\n-\t\tTemplatedMatch<true>(columns, col_data, layout, rows, predicates, sel, count, no_match, no_match_count);\n-\t} else {\n-\t\tTemplatedMatch<false>(columns, col_data, layout, rows, predicates, sel, count, no_match, no_match_count);\n-\t}\n-\n-\treturn count;\n-}\n-\n-} // namespace duckdb\ndiff --git a/src/common/row_operations/row_matcher.cpp b/src/common/row_operations/row_matcher.cpp\nnew file mode 100644\nindex 000000000000..19d9882d04f4\n--- /dev/null\n+++ b/src/common/row_operations/row_matcher.cpp\n@@ -0,0 +1,408 @@\n+#include \"duckdb/common/row_operations/row_matcher.hpp\"\n+\n+#include \"duckdb/common/enum_util.hpp\"\n+#include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/types/row/tuple_data_collection.hpp\"\n+\n+namespace duckdb {\n+\n+using ValidityBytes = TupleDataLayout::ValidityBytes;\n+\n+template <class OP>\n+struct RowMatchOperator {\n+\tstatic constexpr const bool COMPARE_NULL = false;\n+\n+\ttemplate <class T>\n+\tstatic inline bool Operation(const T &left, const T &right, bool left_null, bool right_null) {\n+\t\tif (right_null || left_null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn OP::template Operation<T>(left, right);\n+\t}\n+};\n+\n+template <>\n+struct RowMatchOperator<DistinctFrom> {\n+\tstatic constexpr const bool COMPARE_NULL = true;\n+\n+\ttemplate <class T>\n+\tstatic inline bool Operation(const T &left, const T &right, bool left_null, bool right_null) {\n+\t\treturn DistinctFrom::template Operation<T>(left, right, left_null, right_null);\n+\t}\n+};\n+\n+template <>\n+struct RowMatchOperator<NotDistinctFrom> {\n+\tstatic constexpr const bool COMPARE_NULL = true;\n+\n+\ttemplate <class T>\n+\tstatic inline bool Operation(const T &left, const T &right, bool left_null, bool right_null) {\n+\t\treturn NotDistinctFrom::template Operation<T>(left, right, left_null, right_null);\n+\t}\n+};\n+\n+template <bool NO_MATCH_SEL, class T, class OP>\n+static idx_t TemplatedMatch(Vector &, const TupleDataVectorFormat &lhs_format, SelectionVector &sel, const idx_t count,\n+                            const TupleDataLayout &rhs_layout, Vector &rhs_row_locations, const idx_t col_idx,\n+                            const vector<MatchFunction> &, SelectionVector *no_match_sel, idx_t &no_match_count) {\n+\tusing MATCH_OP = RowMatchOperator<OP>;\n+\n+\t// LHS\n+\tconst auto &lhs_sel = *lhs_format.unified.sel;\n+\tconst auto lhs_data = UnifiedVectorFormat::GetData<T>(lhs_format.unified);\n+\tconst auto &lhs_validity = lhs_format.unified.validity;\n+\n+\t// RHS\n+\tconst auto rhs_locations = FlatVector::GetData<data_ptr_t>(rhs_row_locations);\n+\tconst auto rhs_offset_in_row = rhs_layout.GetOffsets()[col_idx];\n+\tidx_t entry_idx;\n+\tidx_t idx_in_entry;\n+\tValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry);\n+\n+\tidx_t match_count = 0;\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tconst auto idx = sel.get_index(i);\n+\n+\t\tconst auto lhs_idx = lhs_sel.get_index(idx);\n+\t\tconst auto lhs_null = lhs_validity.AllValid() ? false : !lhs_validity.RowIsValid(lhs_idx);\n+\n+\t\tconst auto &rhs_location = rhs_locations[idx];\n+\t\tconst ValidityBytes rhs_mask(rhs_location);\n+\t\tconst auto rhs_null = !rhs_mask.RowIsValid(rhs_mask.GetValidityEntryUnsafe(entry_idx), idx_in_entry);\n+\n+\t\tif (MATCH_OP::template Operation<T>(lhs_data[lhs_idx], Load<T>(rhs_location + rhs_offset_in_row), lhs_null,\n+\t\t                                    rhs_null)) {\n+\t\t\tsel.set_index(match_count++, idx);\n+\t\t} else if (NO_MATCH_SEL) {\n+\t\t\tno_match_sel->set_index(no_match_count++, idx);\n+\t\t}\n+\t}\n+\treturn match_count;\n+}\n+\n+template <bool NO_MATCH_SEL, class OP>\n+static idx_t StructMatchEquality(Vector &lhs_vector, const TupleDataVectorFormat &lhs_format, SelectionVector &sel,\n+                                 const idx_t count, const TupleDataLayout &rhs_layout, Vector &rhs_row_locations,\n+                                 const idx_t col_idx, const vector<MatchFunction> &child_functions,\n+                                 SelectionVector *no_match_sel, idx_t &no_match_count) {\n+\tusing MATCH_OP = RowMatchOperator<OP>;\n+\n+\t// LHS\n+\tconst auto &lhs_sel = *lhs_format.unified.sel;\n+\tconst auto &lhs_validity = lhs_format.unified.validity;\n+\n+\t// RHS\n+\tconst auto rhs_locations = FlatVector::GetData<data_ptr_t>(rhs_row_locations);\n+\tidx_t entry_idx;\n+\tidx_t idx_in_entry;\n+\tValidityBytes::GetEntryIndex(col_idx, entry_idx, idx_in_entry);\n+\n+\tidx_t match_count = 0;\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tconst auto idx = sel.get_index(i);\n+\n+\t\tconst auto lhs_idx = lhs_sel.get_index(idx);\n+\t\tconst auto lhs_null = lhs_validity.AllValid() ? false : !lhs_validity.RowIsValid(lhs_idx);\n+\n+\t\tconst auto &rhs_location = rhs_locations[idx];\n+\t\tconst ValidityBytes rhs_mask(rhs_location);\n+\t\tconst auto rhs_null = !rhs_mask.RowIsValid(rhs_mask.GetValidityEntryUnsafe(entry_idx), idx_in_entry);\n+\n+\t\t// For structs there is no value to compare, here we match NULLs and let recursion do the rest\n+\t\t// So we use the comparison only if rhs or LHS is NULL and COMPARE_NULL is true\n+\t\tif (!(lhs_null || rhs_null) ||\n+\t\t    (MATCH_OP::COMPARE_NULL && MATCH_OP::template Operation<uint32_t>(0, 0, lhs_null, rhs_null))) {\n+\t\t\tsel.set_index(match_count++, idx);\n+\t\t} else if (NO_MATCH_SEL) {\n+\t\t\tno_match_sel->set_index(no_match_count++, idx);\n+\t\t}\n+\t}\n+\n+\t// Create a Vector of pointers to the start of the TupleDataLayout of the STRUCT\n+\tVector rhs_struct_row_locations(LogicalType::POINTER);\n+\tconst auto rhs_offset_in_row = rhs_layout.GetOffsets()[col_idx];\n+\tauto rhs_struct_locations = FlatVector::GetData<data_ptr_t>(rhs_struct_row_locations);\n+\tfor (idx_t i = 0; i < match_count; i++) {\n+\t\tconst auto idx = sel.get_index(i);\n+\t\trhs_struct_locations[idx] = rhs_locations[idx] + rhs_offset_in_row;\n+\t}\n+\n+\t// Get the struct layout and struct entries\n+\tconst auto &rhs_struct_layout = rhs_layout.GetStructLayout(col_idx);\n+\tauto &lhs_struct_vectors = StructVector::GetEntries(lhs_vector);\n+\tD_ASSERT(rhs_struct_layout.ColumnCount() == lhs_struct_vectors.size());\n+\n+\tfor (idx_t struct_col_idx = 0; struct_col_idx < rhs_struct_layout.ColumnCount(); struct_col_idx++) {\n+\t\tauto &lhs_struct_vector = *lhs_struct_vectors[struct_col_idx];\n+\t\tauto &lhs_struct_format = lhs_format.children[struct_col_idx];\n+\t\tconst auto &child_function = child_functions[struct_col_idx];\n+\t\tmatch_count = child_function.function(lhs_struct_vector, lhs_struct_format, sel, match_count, rhs_struct_layout,\n+\t\t                                      rhs_struct_row_locations, struct_col_idx, child_function.child_functions,\n+\t\t                                      no_match_sel, no_match_count);\n+\t}\n+\n+\treturn match_count;\n+}\n+\n+template <typename OP>\n+static idx_t SelectComparison(Vector &, Vector &, const SelectionVector &, idx_t, SelectionVector *,\n+                              SelectionVector *) {\n+\tthrow NotImplementedException(\"Unsupported list comparison operand for RowMatcher::GetMatchFunction\");\n+}\n+\n+template <>\n+idx_t SelectComparison<Equals>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n+                               SelectionVector *true_sel, SelectionVector *false_sel) {\n+\treturn VectorOperations::NestedEquals(left, right, sel, count, true_sel, false_sel);\n+}\n+\n+template <>\n+idx_t SelectComparison<NotEquals>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n+                                  SelectionVector *true_sel, SelectionVector *false_sel) {\n+\treturn VectorOperations::NestedNotEquals(left, right, sel, count, true_sel, false_sel);\n+}\n+\n+template <>\n+idx_t SelectComparison<DistinctFrom>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n+                                     SelectionVector *true_sel, SelectionVector *false_sel) {\n+\treturn VectorOperations::DistinctFrom(left, right, &sel, count, true_sel, false_sel);\n+}\n+\n+template <>\n+idx_t SelectComparison<NotDistinctFrom>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n+                                        SelectionVector *true_sel, SelectionVector *false_sel) {\n+\treturn VectorOperations::NotDistinctFrom(left, right, &sel, count, true_sel, false_sel);\n+}\n+\n+template <>\n+idx_t SelectComparison<GreaterThan>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n+                                    SelectionVector *true_sel, SelectionVector *false_sel) {\n+\treturn VectorOperations::DistinctGreaterThan(left, right, &sel, count, true_sel, false_sel);\n+}\n+\n+template <>\n+idx_t SelectComparison<GreaterThanEquals>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n+                                          SelectionVector *true_sel, SelectionVector *false_sel) {\n+\treturn VectorOperations::DistinctGreaterThanEquals(left, right, &sel, count, true_sel, false_sel);\n+}\n+\n+template <>\n+idx_t SelectComparison<LessThan>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n+                                 SelectionVector *true_sel, SelectionVector *false_sel) {\n+\treturn VectorOperations::DistinctLessThan(left, right, &sel, count, true_sel, false_sel);\n+}\n+\n+template <>\n+idx_t SelectComparison<LessThanEquals>(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,\n+                                       SelectionVector *true_sel, SelectionVector *false_sel) {\n+\treturn VectorOperations::DistinctLessThanEquals(left, right, &sel, count, true_sel, false_sel);\n+}\n+\n+template <bool NO_MATCH_SEL, class OP>\n+static idx_t GenericNestedMatch(Vector &lhs_vector, const TupleDataVectorFormat &, SelectionVector &sel,\n+                                const idx_t count, const TupleDataLayout &rhs_layout, Vector &rhs_row_locations,\n+                                const idx_t col_idx, const vector<MatchFunction> &, SelectionVector *no_match_sel,\n+                                idx_t &no_match_count) {\n+\tconst auto &type = rhs_layout.GetTypes()[col_idx];\n+\n+\t// Gather a dense Vector containing the column values being matched\n+\tVector key(type);\n+\tconst auto gather_function = TupleDataCollection::GetGatherFunction(type);\n+\tgather_function.function(rhs_layout, rhs_row_locations, col_idx, sel, count, key,\n+\t                         *FlatVector::IncrementalSelectionVector(), key, gather_function.child_functions);\n+\n+\t// Densify the input column\n+\tVector sliced(lhs_vector, sel, count);\n+\n+\tif (NO_MATCH_SEL) {\n+\t\tSelectionVector no_match_sel_offset(no_match_sel->data() + no_match_count);\n+\t\tauto match_count = SelectComparison<OP>(sliced, key, sel, count, &sel, &no_match_sel_offset);\n+\t\tno_match_count += count - match_count;\n+\t\treturn match_count;\n+\t}\n+\treturn SelectComparison<OP>(sliced, key, sel, count, &sel, nullptr);\n+}\n+\n+void RowMatcher::Initialize(const bool no_match_sel, const TupleDataLayout &layout, const Predicates &predicates) {\n+\tmatch_functions.reserve(predicates.size());\n+\tfor (idx_t col_idx = 0; col_idx < predicates.size(); col_idx++) {\n+\t\tmatch_functions.push_back(GetMatchFunction(no_match_sel, layout.GetTypes()[col_idx], predicates[col_idx]));\n+\t}\n+}\n+\n+idx_t RowMatcher::Match(DataChunk &lhs, const vector<TupleDataVectorFormat> &lhs_formats, SelectionVector &sel,\n+                        idx_t count, const TupleDataLayout &rhs_layout, Vector &rhs_row_locations,\n+                        SelectionVector *no_match_sel, idx_t &no_match_count) {\n+\tD_ASSERT(!match_functions.empty());\n+\tfor (idx_t col_idx = 0; col_idx < match_functions.size(); col_idx++) {\n+\t\tconst auto &match_function = match_functions[col_idx];\n+\t\tcount =\n+\t\t    match_function.function(lhs.data[col_idx], lhs_formats[col_idx], sel, count, rhs_layout, rhs_row_locations,\n+\t\t                            col_idx, match_function.child_functions, no_match_sel, no_match_count);\n+\t}\n+\treturn count;\n+}\n+\n+MatchFunction RowMatcher::GetMatchFunction(const bool no_match_sel, const LogicalType &type,\n+                                           const ExpressionType predicate) {\n+\treturn no_match_sel ? GetMatchFunction<true>(type, predicate) : GetMatchFunction<false>(type, predicate);\n+}\n+\n+template <bool NO_MATCH_SEL>\n+MatchFunction RowMatcher::GetMatchFunction(const LogicalType &type, const ExpressionType predicate) {\n+\tswitch (type.InternalType()) {\n+\tcase PhysicalType::BOOL:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, bool>(predicate);\n+\tcase PhysicalType::INT8:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, int8_t>(predicate);\n+\tcase PhysicalType::INT16:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, int16_t>(predicate);\n+\tcase PhysicalType::INT32:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, int32_t>(predicate);\n+\tcase PhysicalType::INT64:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, int64_t>(predicate);\n+\tcase PhysicalType::INT128:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, hugeint_t>(predicate);\n+\tcase PhysicalType::UINT8:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, uint8_t>(predicate);\n+\tcase PhysicalType::UINT16:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, uint16_t>(predicate);\n+\tcase PhysicalType::UINT32:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, uint32_t>(predicate);\n+\tcase PhysicalType::UINT64:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, uint64_t>(predicate);\n+\tcase PhysicalType::FLOAT:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, float>(predicate);\n+\tcase PhysicalType::DOUBLE:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, double>(predicate);\n+\tcase PhysicalType::INTERVAL:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, interval_t>(predicate);\n+\tcase PhysicalType::VARCHAR:\n+\t\treturn GetMatchFunction<NO_MATCH_SEL, string_t>(predicate);\n+\tcase PhysicalType::STRUCT:\n+\t\treturn GetStructMatchFunction<NO_MATCH_SEL>(type, predicate);\n+\tcase PhysicalType::LIST:\n+\t\treturn GetListMatchFunction<NO_MATCH_SEL>(predicate);\n+\tdefault:\n+\t\tthrow InternalException(\"Unsupported PhysicalType for RowMatcher::GetMatchFunction: %s\",\n+\t\t                        EnumUtil::ToString(type.InternalType()));\n+\t}\n+}\n+\n+template <bool NO_MATCH_SEL, class T>\n+MatchFunction RowMatcher::GetMatchFunction(const ExpressionType predicate) {\n+\tMatchFunction result;\n+\tswitch (predicate) {\n+\tcase ExpressionType::COMPARE_EQUAL:\n+\t\tresult.function = TemplatedMatch<NO_MATCH_SEL, T, Equals>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_NOTEQUAL:\n+\t\tresult.function = TemplatedMatch<NO_MATCH_SEL, T, NotEquals>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_DISTINCT_FROM:\n+\t\tresult.function = TemplatedMatch<NO_MATCH_SEL, T, DistinctFrom>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_NOT_DISTINCT_FROM:\n+\t\tresult.function = TemplatedMatch<NO_MATCH_SEL, T, NotDistinctFrom>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_GREATERTHAN:\n+\t\tresult.function = TemplatedMatch<NO_MATCH_SEL, T, GreaterThan>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n+\t\tresult.function = TemplatedMatch<NO_MATCH_SEL, T, GreaterThanEquals>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_LESSTHAN:\n+\t\tresult.function = TemplatedMatch<NO_MATCH_SEL, T, LessThan>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n+\t\tresult.function = TemplatedMatch<NO_MATCH_SEL, T, LessThanEquals>;\n+\t\tbreak;\n+\tdefault:\n+\t\tthrow InternalException(\"Unsupported ExpressionType for RowMatcher::GetMatchFunction: %s\",\n+\t\t                        EnumUtil::ToString(predicate));\n+\t}\n+\treturn result;\n+}\n+\n+template <bool NO_MATCH_SEL>\n+MatchFunction RowMatcher::GetStructMatchFunction(const LogicalType &type, const ExpressionType predicate) {\n+\t// We perform equality conditions like it's just a row, but we cannot perform inequality conditions like a row,\n+\t// because for equality conditions we need to always loop through all columns, but for inequality conditions,\n+\t// we need to find the first inequality, so the loop looks very different\n+\tMatchFunction result;\n+\tExpressionType child_predicate = predicate;\n+\tswitch (predicate) {\n+\tcase ExpressionType::COMPARE_EQUAL:\n+\t\tresult.function = StructMatchEquality<NO_MATCH_SEL, Equals>;\n+\t\tchild_predicate = ExpressionType::COMPARE_NOT_DISTINCT_FROM;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_NOTEQUAL:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, NotEquals>;\n+\t\treturn result;\n+\tcase ExpressionType::COMPARE_DISTINCT_FROM:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, DistinctFrom>;\n+\t\treturn result;\n+\tcase ExpressionType::COMPARE_NOT_DISTINCT_FROM:\n+\t\tresult.function = StructMatchEquality<NO_MATCH_SEL, NotDistinctFrom>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_GREATERTHAN:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, GreaterThan>;\n+\t\treturn result;\n+\tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, GreaterThanEquals>;\n+\t\treturn result;\n+\tcase ExpressionType::COMPARE_LESSTHAN:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, LessThan>;\n+\t\treturn result;\n+\tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, LessThanEquals>;\n+\t\treturn result;\n+\tdefault:\n+\t\tthrow InternalException(\"Unsupported ExpressionType for RowMatcher::GetStructMatchFunction: %s\",\n+\t\t                        EnumUtil::ToString(predicate));\n+\t}\n+\n+\tresult.child_functions.reserve(StructType::GetChildCount(type));\n+\tfor (const auto &child_type : StructType::GetChildTypes(type)) {\n+\t\tresult.child_functions.push_back(GetMatchFunction<NO_MATCH_SEL>(child_type.second, child_predicate));\n+\t}\n+\n+\treturn result;\n+}\n+\n+template <bool NO_MATCH_SEL>\n+MatchFunction RowMatcher::GetListMatchFunction(const ExpressionType predicate) {\n+\tMatchFunction result;\n+\tswitch (predicate) {\n+\tcase ExpressionType::COMPARE_EQUAL:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, Equals>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_NOTEQUAL:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, NotEquals>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_DISTINCT_FROM:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, DistinctFrom>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_NOT_DISTINCT_FROM:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, NotDistinctFrom>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_GREATERTHAN:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, GreaterThan>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, GreaterThanEquals>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_LESSTHAN:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, LessThan>;\n+\t\tbreak;\n+\tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n+\t\tresult.function = GenericNestedMatch<NO_MATCH_SEL, LessThanEquals>;\n+\t\tbreak;\n+\tdefault:\n+\t\tthrow InternalException(\"Unsupported ExpressionType for RowMatcher::GetListMatchFunction: %s\",\n+\t\t                        EnumUtil::ToString(predicate));\n+\t}\n+\treturn result;\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/common/types/row/tuple_data_allocator.cpp b/src/common/types/row/tuple_data_allocator.cpp\nindex e9569372c159..b30af49cbc12 100644\n--- a/src/common/types/row/tuple_data_allocator.cpp\n+++ b/src/common/types/row/tuple_data_allocator.cpp\n@@ -294,7 +294,7 @@ static inline void VerifyStrings(const LogicalTypeId type_id, const data_ptr_t r\n \tfor (idx_t i = 0; i < count; i++) {\n \t\tconst auto &row_location = row_locations[offset + i] + base_col_offset;\n \t\tValidityBytes row_mask(row_location);\n-\t\tif (row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {\n+\t\tif (row_mask.RowIsValid(row_mask.GetValidityEntryUnsafe(entry_idx), idx_in_entry)) {\n \t\t\tauto recomputed_string = Load<string_t>(row_location + col_offset);\n \t\t\trecomputed_string.Verify();\n \t\t}\n@@ -328,7 +328,7 @@ void TupleDataAllocator::RecomputeHeapPointers(Vector &old_heap_ptrs, const Sele\n \t\t\t\tconst auto idx = offset + i;\n \t\t\t\tconst auto &row_location = row_locations[idx] + base_col_offset;\n \t\t\t\tValidityBytes row_mask(row_location);\n-\t\t\t\tif (!row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {\n+\t\t\t\tif (!row_mask.RowIsValid(row_mask.GetValidityEntryUnsafe(entry_idx), idx_in_entry)) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \n@@ -352,7 +352,7 @@ void TupleDataAllocator::RecomputeHeapPointers(Vector &old_heap_ptrs, const Sele\n \t\t\t\tconst auto idx = offset + i;\n \t\t\t\tconst auto &row_location = row_locations[idx] + base_col_offset;\n \t\t\t\tValidityBytes row_mask(row_location);\n-\t\t\t\tif (!row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {\n+\t\t\t\tif (!row_mask.RowIsValid(row_mask.GetValidityEntryUnsafe(entry_idx), idx_in_entry)) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \ndiff --git a/src/common/types/row/tuple_data_collection.cpp b/src/common/types/row/tuple_data_collection.cpp\nindex f4bae7f6c29d..97858151a550 100644\n--- a/src/common/types/row/tuple_data_collection.cpp\n+++ b/src/common/types/row/tuple_data_collection.cpp\n@@ -37,13 +37,17 @@ void TupleDataCollection::Initialize() {\n \t}\n }\n \n-void TupleDataCollection::GetAllColumnIDs(vector<column_t> &column_ids) {\n-\tcolumn_ids.reserve(layout.ColumnCount());\n-\tfor (idx_t col_idx = 0; col_idx < layout.ColumnCount(); col_idx++) {\n+void GetAllColumnIDsInternal(vector<column_t> &column_ids, const idx_t column_count) {\n+\tcolumn_ids.reserve(column_count);\n+\tfor (idx_t col_idx = 0; col_idx < column_count; col_idx++) {\n \t\tcolumn_ids.emplace_back(col_idx);\n \t}\n }\n \n+void TupleDataCollection::GetAllColumnIDs(vector<column_t> &column_ids) {\n+\tGetAllColumnIDsInternal(column_ids, layout.ColumnCount());\n+}\n+\n const TupleDataLayout &TupleDataCollection::GetLayout() const {\n \treturn layout;\n }\n@@ -108,7 +112,7 @@ void TupleDataCollection::InitializeAppend(TupleDataAppendState &append_state, v\n                                            TupleDataPinProperties properties) {\n \tVerifyAppendColumns(layout, column_ids);\n \tInitializeAppend(append_state.pin_state, properties);\n-\tInitializeAppend(append_state.chunk_state, std::move(column_ids));\n+\tInitializeChunkState(append_state.chunk_state, std::move(column_ids));\n }\n \n void TupleDataCollection::InitializeAppend(TupleDataPinState &pin_state, TupleDataPinProperties properties) {\n@@ -130,11 +134,11 @@ static void InitializeVectorFormat(vector<TupleDataVectorFormat> &vector_data, c\n \t\t\tfor (const auto &child_entry : child_list) {\n \t\t\t\tchild_types.emplace_back(child_entry.second);\n \t\t\t}\n-\t\t\tInitializeVectorFormat(vector_data[col_idx].child_formats, child_types);\n+\t\t\tInitializeVectorFormat(vector_data[col_idx].children, child_types);\n \t\t\tbreak;\n \t\t}\n \t\tcase PhysicalType::LIST:\n-\t\t\tInitializeVectorFormat(vector_data[col_idx].child_formats, {ListType::GetChildType(type)});\n+\t\t\tInitializeVectorFormat(vector_data[col_idx].children, {ListType::GetChildType(type)});\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tbreak;\n@@ -142,11 +146,16 @@ static void InitializeVectorFormat(vector<TupleDataVectorFormat> &vector_data, c\n \t}\n }\n \n-void TupleDataCollection::InitializeAppend(TupleDataChunkState &chunk_state, vector<column_t> column_ids) {\n+void TupleDataCollection::InitializeChunkState(TupleDataChunkState &chunk_state, vector<column_t> column_ids) {\n+\tTupleDataCollection::InitializeChunkState(chunk_state, layout.GetTypes(), std::move(column_ids));\n+}\n+\n+void TupleDataCollection::InitializeChunkState(TupleDataChunkState &chunk_state, const vector<LogicalType> &types,\n+                                               vector<column_t> column_ids) {\n \tif (column_ids.empty()) {\n-\t\tGetAllColumnIDs(column_ids);\n+\t\tGetAllColumnIDsInternal(column_ids, types.size());\n \t}\n-\tInitializeVectorFormat(chunk_state.vector_data, layout.GetTypes());\n+\tInitializeVectorFormat(chunk_state.vector_data, types);\n \tchunk_state.column_ids = std::move(column_ids);\n }\n \n@@ -211,21 +220,23 @@ void TupleDataCollection::AppendUnified(TupleDataPinState &pin_state, TupleDataC\n }\n \n static inline void ToUnifiedFormatInternal(TupleDataVectorFormat &format, Vector &vector, const idx_t count) {\n-\tvector.ToUnifiedFormat(count, format.data);\n-\tformat.original_sel = format.data.sel;\n-\tformat.original_owned_sel.Initialize(format.data.owned_sel);\n+\tvector.ToUnifiedFormat(count, format.unified);\n+\tformat.original_sel = format.unified.sel;\n+\tformat.original_owned_sel.Initialize(format.unified.owned_sel);\n \tswitch (vector.GetType().InternalType()) {\n \tcase PhysicalType::STRUCT: {\n \t\tauto &entries = StructVector::GetEntries(vector);\n-\t\tD_ASSERT(format.child_formats.size() == entries.size());\n+\t\tD_ASSERT(format.children.size() == entries.size());\n \t\tfor (idx_t struct_col_idx = 0; struct_col_idx < entries.size(); struct_col_idx++) {\n-\t\t\tToUnifiedFormatInternal(format.child_formats[struct_col_idx], *entries[struct_col_idx], count);\n+\t\t\tToUnifiedFormatInternal(reinterpret_cast<TupleDataVectorFormat &>(format.children[struct_col_idx]),\n+\t\t\t                        *entries[struct_col_idx], count);\n \t\t}\n \t\tbreak;\n \t}\n \tcase PhysicalType::LIST:\n-\t\tD_ASSERT(format.child_formats.size() == 1);\n-\t\tToUnifiedFormatInternal(format.child_formats[0], ListVector::GetEntry(vector), ListVector::GetListSize(vector));\n+\t\tD_ASSERT(format.children.size() == 1);\n+\t\tToUnifiedFormatInternal(reinterpret_cast<TupleDataVectorFormat &>(format.children[0]),\n+\t\t                        ListVector::GetEntry(vector), ListVector::GetListSize(vector));\n \t\tbreak;\n \tdefault:\n \t\tbreak;\n@@ -242,7 +253,7 @@ void TupleDataCollection::ToUnifiedFormat(TupleDataChunkState &chunk_state, Data\n void TupleDataCollection::GetVectorData(const TupleDataChunkState &chunk_state, UnifiedVectorFormat result[]) {\n \tconst auto &vector_data = chunk_state.vector_data;\n \tfor (idx_t i = 0; i < vector_data.size(); i++) {\n-\t\tconst auto &source = vector_data[i].data;\n+\t\tconst auto &source = vector_data[i].unified;\n \t\tauto &target = result[i];\n \t\ttarget.sel = source.sel;\n \t\ttarget.data = source.data;\ndiff --git a/src/common/types/row/tuple_data_scatter_gather.cpp b/src/common/types/row/tuple_data_scatter_gather.cpp\nindex ab04e40e42ce..849d5d480c4c 100644\n--- a/src/common/types/row/tuple_data_scatter_gather.cpp\n+++ b/src/common/types/row/tuple_data_scatter_gather.cpp\n@@ -66,7 +66,7 @@ inline string_t TupleDataWithinListValueLoad(const data_ptr_t &location, data_pt\n static void ResetCombinedListData(vector<TupleDataVectorFormat> &vector_data) {\n \tfor (auto &vd : vector_data) {\n \t\tvd.combined_list_data = nullptr;\n-\t\tResetCombinedListData(vd.child_formats);\n+\t\tResetCombinedListData(vd.children);\n \t}\n }\n #endif\n@@ -102,7 +102,7 @@ void TupleDataCollection::ComputeHeapSizes(Vector &heap_sizes_v, const Vector &s\n \n \tauto heap_sizes = FlatVector::GetData<idx_t>(heap_sizes_v);\n \n-\tconst auto &source_vector_data = source_format.data;\n+\tconst auto &source_vector_data = source_format.unified;\n \tconst auto &source_sel = *source_vector_data.sel;\n \tconst auto &source_validity = source_vector_data.validity;\n \n@@ -125,7 +125,7 @@ void TupleDataCollection::ComputeHeapSizes(Vector &heap_sizes_v, const Vector &s\n \t\tauto &struct_sources = StructVector::GetEntries(source_v);\n \t\tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_sources.size(); struct_col_idx++) {\n \t\t\tconst auto &struct_source = struct_sources[struct_col_idx];\n-\t\t\tauto &struct_format = source_format.child_formats[struct_col_idx];\n+\t\t\tauto &struct_format = source_format.children[struct_col_idx];\n \t\t\tTupleDataCollection::ComputeHeapSizes(heap_sizes_v, *struct_source, struct_format, append_sel,\n \t\t\t                                      append_count);\n \t\t}\n@@ -141,9 +141,9 @@ void TupleDataCollection::ComputeHeapSizes(Vector &heap_sizes_v, const Vector &s\n \t\t}\n \n \t\t// Recurse\n-\t\tD_ASSERT(source_format.child_formats.size() == 1);\n+\t\tD_ASSERT(source_format.children.size() == 1);\n \t\tauto &child_source_v = ListVector::GetEntry(source_v);\n-\t\tauto &child_format = source_format.child_formats[0];\n+\t\tauto &child_format = source_format.children[0];\n \t\tTupleDataCollection::WithinListHeapComputeSizes(heap_sizes_v, child_source_v, child_format, append_sel,\n \t\t                                                append_count, source_vector_data);\n \t\tbreak;\n@@ -217,8 +217,8 @@ void TupleDataCollection::StringWithinListComputeHeapSizes(Vector &heap_sizes_v,\n                                                            const SelectionVector &append_sel, const idx_t append_count,\n                                                            const UnifiedVectorFormat &list_data) {\n \t// Source\n-\tconst auto &source_data = source_format.data;\n-\tconst auto source_sel = *source_data.sel;\n+\tconst auto &source_data = source_format.unified;\n+\tconst auto &source_sel = *source_data.sel;\n \tconst auto data = UnifiedVectorFormat::GetData<string_t>(source_data);\n \tconst auto &source_validity = source_data.validity;\n \n@@ -285,7 +285,7 @@ void TupleDataCollection::StructWithinListComputeHeapSizes(Vector &heap_sizes_v,\n \tauto &struct_sources = StructVector::GetEntries(source_v);\n \tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_sources.size(); struct_col_idx++) {\n \t\tauto &struct_source = *struct_sources[struct_col_idx];\n-\t\tauto &struct_format = source_format.child_formats[struct_col_idx];\n+\t\tauto &struct_format = source_format.children[struct_col_idx];\n \t\tTupleDataCollection::WithinListHeapComputeSizes(heap_sizes_v, struct_source, struct_format, append_sel,\n \t\t                                                append_count, list_data);\n \t}\n@@ -297,22 +297,22 @@ static void ApplySliceRecursive(const Vector &source_v, TupleDataVectorFormat &s\n \tauto &combined_list_data = *source_format.combined_list_data;\n \n \tcombined_list_data.selection_data = source_format.original_sel->Slice(combined_sel, count);\n-\tsource_format.data.owned_sel.Initialize(combined_list_data.selection_data);\n-\tsource_format.data.sel = &source_format.data.owned_sel;\n+\tsource_format.unified.owned_sel.Initialize(combined_list_data.selection_data);\n+\tsource_format.unified.sel = &source_format.unified.owned_sel;\n \n \tif (source_v.GetType().InternalType() == PhysicalType::STRUCT) {\n \t\t// We have to apply it to the child vectors too\n \t\tauto &struct_sources = StructVector::GetEntries(source_v);\n \t\tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_sources.size(); struct_col_idx++) {\n \t\t\tauto &struct_source = *struct_sources[struct_col_idx];\n-\t\t\tauto &struct_format = source_format.child_formats[struct_col_idx];\n+\t\t\tauto &struct_format = source_format.children[struct_col_idx];\n #ifdef DEBUG\n \t\t\tD_ASSERT(!struct_format.combined_list_data);\n #endif\n \t\t\tif (!struct_format.combined_list_data) {\n \t\t\t\tstruct_format.combined_list_data = make_uniq<CombinedListData>();\n \t\t\t}\n-\t\t\tApplySliceRecursive(struct_source, struct_format, *source_format.data.sel, count);\n+\t\t\tApplySliceRecursive(struct_source, struct_format, *source_format.unified.sel, count);\n \t\t}\n \t}\n }\n@@ -327,7 +327,7 @@ void TupleDataCollection::ListWithinListComputeHeapSizes(Vector &heap_sizes_v, c\n \tconst auto &list_validity = list_data.validity;\n \n \t// Child list (\"source_v\")\n-\tconst auto &child_list_data = source_format.data;\n+\tconst auto &child_list_data = source_format.unified;\n \tconst auto child_list_sel = *child_list_data.sel;\n \tconst auto child_list_entries = UnifiedVectorFormat::GetData<list_entry_t>(child_list_data);\n \tconst auto &child_list_validity = child_list_data.validity;\n@@ -362,7 +362,7 @@ void TupleDataCollection::ListWithinListComputeHeapSizes(Vector &heap_sizes_v, c\n \tauto heap_sizes = FlatVector::GetData<idx_t>(heap_sizes_v);\n \n \t// Construct combined list entries and a selection vector for the child list child\n-\tauto &child_format = source_format.child_formats[0];\n+\tauto &child_format = source_format.children[0];\n #ifdef DEBUG\n \t// In debug mode this should be deleted by ResetCombinedListData\n \tD_ASSERT(!child_format.combined_list_data);\n@@ -425,7 +425,7 @@ void TupleDataCollection::ListWithinListComputeHeapSizes(Vector &heap_sizes_v, c\n \tcombined_child_list_data.validity = list_data.validity;\n \n \t// Combine the selection vectors\n-\tD_ASSERT(source_format.child_formats.size() == 1);\n+\tD_ASSERT(source_format.children.size() == 1);\n \tauto &child_source = ListVector::GetEntry(source_v);\n \tApplySliceRecursive(child_source, child_format, combined_sel, child_list_child_count);\n \n@@ -464,18 +464,18 @@ void TupleDataCollection::Scatter(TupleDataChunkState &chunk_state, const Vector\n \tconst auto &scatter_function = scatter_functions[column_id];\n \tscatter_function.function(source, chunk_state.vector_data[column_id], append_sel, append_count, layout,\n \t                          chunk_state.row_locations, chunk_state.heap_locations, column_id,\n-\t                          chunk_state.vector_data[column_id].data, scatter_function.child_functions);\n+\t                          chunk_state.vector_data[column_id].unified, scatter_function.child_functions);\n }\n \n template <class T>\n static void TupleDataTemplatedScatter(const Vector &source, const TupleDataVectorFormat &source_format,\n                                       const SelectionVector &append_sel, const idx_t append_count,\n-                                      const TupleDataLayout &layout, Vector &row_locations, Vector &heap_locations,\n-                                      const idx_t col_idx, const UnifiedVectorFormat &dummy_arg,\n+                                      const TupleDataLayout &layout, const Vector &row_locations,\n+                                      Vector &heap_locations, const idx_t col_idx, const UnifiedVectorFormat &dummy_arg,\n                                       const vector<TupleDataScatterFunction> &child_functions) {\n \t// Source\n-\tconst auto &source_data = source_format.data;\n-\tconst auto source_sel = *source_data.sel;\n+\tconst auto &source_data = source_format.unified;\n+\tconst auto &source_sel = *source_data.sel;\n \tconst auto data = UnifiedVectorFormat::GetData<T>(source_data);\n \tconst auto &validity = source_data.validity;\n \n@@ -509,12 +509,12 @@ static void TupleDataTemplatedScatter(const Vector &source, const TupleDataVecto\n \n static void TupleDataStructScatter(const Vector &source, const TupleDataVectorFormat &source_format,\n                                    const SelectionVector &append_sel, const idx_t append_count,\n-                                   const TupleDataLayout &layout, Vector &row_locations, Vector &heap_locations,\n+                                   const TupleDataLayout &layout, const Vector &row_locations, Vector &heap_locations,\n                                    const idx_t col_idx, const UnifiedVectorFormat &dummy_arg,\n                                    const vector<TupleDataScatterFunction> &child_functions) {\n \t// Source\n-\tconst auto &source_data = source_format.data;\n-\tconst auto source_sel = *source_data.sel;\n+\tconst auto &source_data = source_format.unified;\n+\tconst auto &source_sel = *source_data.sel;\n \tconst auto &validity = source_data.validity;\n \n \t// Target\n@@ -556,7 +556,7 @@ static void TupleDataStructScatter(const Vector &source, const TupleDataVectorFo\n \t// Recurse through the struct children\n \tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_layout.ColumnCount(); struct_col_idx++) {\n \t\tauto &struct_source = *struct_sources[struct_col_idx];\n-\t\tconst auto &struct_source_format = source_format.child_formats[struct_col_idx];\n+\t\tconst auto &struct_source_format = source_format.children[struct_col_idx];\n \t\tconst auto &struct_scatter_function = child_functions[struct_col_idx];\n \t\tstruct_scatter_function.function(struct_source, struct_source_format, append_sel, append_count, struct_layout,\n \t\t                                 struct_row_locations, heap_locations, struct_col_idx, dummy_arg,\n@@ -566,12 +566,12 @@ static void TupleDataStructScatter(const Vector &source, const TupleDataVectorFo\n \n static void TupleDataListScatter(const Vector &source, const TupleDataVectorFormat &source_format,\n                                  const SelectionVector &append_sel, const idx_t append_count,\n-                                 const TupleDataLayout &layout, Vector &row_locations, Vector &heap_locations,\n+                                 const TupleDataLayout &layout, const Vector &row_locations, Vector &heap_locations,\n                                  const idx_t col_idx, const UnifiedVectorFormat &dummy_arg,\n                                  const vector<TupleDataScatterFunction> &child_functions) {\n \t// Source\n-\tconst auto &source_data = source_format.data;\n-\tconst auto source_sel = *source_data.sel;\n+\tconst auto &source_data = source_format.unified;\n+\tconst auto &source_sel = *source_data.sel;\n \tconst auto data = UnifiedVectorFormat::GetData<list_entry_t>(source_data);\n \tconst auto &validity = source_data.validity;\n \n@@ -603,22 +603,22 @@ static void TupleDataListScatter(const Vector &source, const TupleDataVectorForm\n \t// Recurse\n \tD_ASSERT(child_functions.size() == 1);\n \tauto &child_source = ListVector::GetEntry(source);\n-\tauto &child_format = source_format.child_formats[0];\n+\tauto &child_format = source_format.children[0];\n \tconst auto &child_function = child_functions[0];\n \tchild_function.function(child_source, child_format, append_sel, append_count, layout, row_locations, heap_locations,\n-\t                        col_idx, source_format.data, child_function.child_functions);\n+\t                        col_idx, source_format.unified, child_function.child_functions);\n }\n \n template <class T>\n static void TupleDataTemplatedWithinListScatter(const Vector &source, const TupleDataVectorFormat &source_format,\n                                                 const SelectionVector &append_sel, const idx_t append_count,\n-                                                const TupleDataLayout &layout, Vector &row_locations,\n+                                                const TupleDataLayout &layout, const Vector &row_locations,\n                                                 Vector &heap_locations, const idx_t col_idx,\n                                                 const UnifiedVectorFormat &list_data,\n                                                 const vector<TupleDataScatterFunction> &child_functions) {\n \t// Source\n-\tconst auto &source_data = source_format.data;\n-\tconst auto source_sel = *source_data.sel;\n+\tconst auto &source_data = source_format.unified;\n+\tconst auto &source_sel = *source_data.sel;\n \tconst auto data = UnifiedVectorFormat::GetData<T>(source_data);\n \tconst auto &source_validity = source_data.validity;\n \n@@ -667,13 +667,13 @@ static void TupleDataTemplatedWithinListScatter(const Vector &source, const Tupl\n \n static void TupleDataStructWithinListScatter(const Vector &source, const TupleDataVectorFormat &source_format,\n                                              const SelectionVector &append_sel, const idx_t append_count,\n-                                             const TupleDataLayout &layout, Vector &row_locations,\n+                                             const TupleDataLayout &layout, const Vector &row_locations,\n                                              Vector &heap_locations, const idx_t col_idx,\n                                              const UnifiedVectorFormat &list_data,\n                                              const vector<TupleDataScatterFunction> &child_functions) {\n \t// Source\n-\tconst auto &source_data = source_format.data;\n-\tconst auto source_sel = *source_data.sel;\n+\tconst auto &source_data = source_format.unified;\n+\tconst auto &source_sel = *source_data.sel;\n \tconst auto &source_validity = source_data.validity;\n \n \t// List data\n@@ -715,7 +715,7 @@ static void TupleDataStructWithinListScatter(const Vector &source, const TupleDa\n \tauto &struct_sources = StructVector::GetEntries(source);\n \tfor (idx_t struct_col_idx = 0; struct_col_idx < struct_sources.size(); struct_col_idx++) {\n \t\tauto &struct_source = *struct_sources[struct_col_idx];\n-\t\tauto &struct_format = source_format.child_formats[struct_col_idx];\n+\t\tauto &struct_format = source_format.children[struct_col_idx];\n \t\tconst auto &struct_scatter_function = child_functions[struct_col_idx];\n \t\tstruct_scatter_function.function(struct_source, struct_format, append_sel, append_count, layout, row_locations,\n \t\t                                 heap_locations, struct_col_idx, list_data,\n@@ -725,8 +725,9 @@ static void TupleDataStructWithinListScatter(const Vector &source, const TupleDa\n \n static void TupleDataListWithinListScatter(const Vector &child_list, const TupleDataVectorFormat &child_list_format,\n                                            const SelectionVector &append_sel, const idx_t append_count,\n-                                           const TupleDataLayout &layout, Vector &row_locations, Vector &heap_locations,\n-                                           const idx_t col_idx, const UnifiedVectorFormat &list_data,\n+                                           const TupleDataLayout &layout, const Vector &row_locations,\n+                                           Vector &heap_locations, const idx_t col_idx,\n+                                           const UnifiedVectorFormat &list_data,\n                                            const vector<TupleDataScatterFunction> &child_functions) {\n \t// List data (of the list Vector that \"child_list\" is in)\n \tconst auto list_sel = *list_data.sel;\n@@ -734,7 +735,7 @@ static void TupleDataListWithinListScatter(const Vector &child_list, const Tuple\n \tconst auto &list_validity = list_data.validity;\n \n \t// Child list\n-\tconst auto &child_list_data = child_list_format.data;\n+\tconst auto &child_list_data = child_list_format.unified;\n \tconst auto child_list_sel = *child_list_data.sel;\n \tconst auto child_list_entries = UnifiedVectorFormat::GetData<list_entry_t>(child_list_data);\n \tconst auto &child_list_validity = child_list_data.validity;\n@@ -777,7 +778,7 @@ static void TupleDataListWithinListScatter(const Vector &child_list, const Tuple\n \t// Recurse\n \tD_ASSERT(child_functions.size() == 1);\n \tauto &child_vec = ListVector::GetEntry(child_list);\n-\tauto &child_format = child_list_format.child_formats[0];\n+\tauto &child_format = child_list_format.children[0];\n \tauto &combined_child_list_data = child_format.combined_list_data->combined_data;\n \tconst auto &child_function = child_functions[0];\n \tchild_function.function(child_vec, child_format, append_sel, append_count, layout, row_locations, heap_locations,\n@@ -899,7 +900,7 @@ static void TupleDataTemplatedGather(const TupleDataLayout &layout, Vector &row_\n \t\tconst auto &source_row = source_locations[scan_sel.get_index(i)];\n \t\tconst auto target_idx = target_sel.get_index(i);\n \t\tValidityBytes row_mask(source_row);\n-\t\tif (row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {\n+\t\tif (row_mask.RowIsValid(row_mask.GetValidityEntryUnsafe(entry_idx), idx_in_entry)) {\n \t\t\ttarget_data[target_idx] = Load<T>(source_row + offset_in_row);\n \t\t} else {\n \t\t\ttarget_validity.SetInvalid(target_idx);\n@@ -932,7 +933,7 @@ static void TupleDataStructGather(const TupleDataLayout &layout, Vector &row_loc\n \n \t\t// Set the validity\n \t\tValidityBytes row_mask(source_row);\n-\t\tif (!row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {\n+\t\tif (!row_mask.RowIsValid(row_mask.GetValidityEntryUnsafe(entry_idx), idx_in_entry)) {\n \t\t\tconst auto target_idx = target_sel.get_index(i);\n \t\t\ttarget_validity.SetInvalid(target_idx);\n \t\t}\n@@ -985,7 +986,7 @@ static void TupleDataListGather(const TupleDataLayout &layout, Vector &row_locat\n \n \t\tconst auto &source_row = source_locations[source_idx];\n \t\tValidityBytes row_mask(source_row);\n-\t\tif (row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {\n+\t\tif (row_mask.RowIsValid(row_mask.GetValidityEntryUnsafe(entry_idx), idx_in_entry)) {\n \t\t\tauto &source_heap_location = source_heap_locations[source_idx];\n \t\t\tsource_heap_location = Load<data_ptr_t>(source_row + offset_in_row);\n \ndiff --git a/src/common/vector_operations/vector_hash.cpp b/src/common/vector_operations/vector_hash.cpp\nindex cae008ca1c25..f489d8f27d18 100644\n--- a/src/common/vector_operations/vector_hash.cpp\n+++ b/src/common/vector_operations/vector_hash.cpp\n@@ -103,6 +103,7 @@ static inline void ListLoopHash(Vector &input, Vector &hashes, const SelectionVe\n \tVector child_hashes(LogicalType::HASH, child_count);\n \tif (child_count > 0) {\n \t\tVectorOperations::Hash(child, child_hashes, child_count);\n+\t\tchild_hashes.Flatten(child_count);\n \t}\n \tauto chdata = FlatVector::GetData<hash_t>(child_hashes);\n \ndiff --git a/src/execution/aggregate_hashtable.cpp b/src/execution/aggregate_hashtable.cpp\nindex 1aeb08c9044a..be5aa9681029 100644\n--- a/src/execution/aggregate_hashtable.cpp\n+++ b/src/execution/aggregate_hashtable.cpp\n@@ -45,6 +45,7 @@ GroupedAggregateHashTable::GroupedAggregateHashTable(ClientContext &context, All\n \t// Append hash column to the end and initialise the row layout\n \tgroup_types_p.emplace_back(LogicalType::HASH);\n \tlayout.Initialize(std::move(group_types_p), std::move(aggregate_objects_p));\n+\n \thash_offset = layout.GetOffsets()[layout.ColumnCount() - 1];\n \n \t// Partitioned data and pointer table\n@@ -52,7 +53,8 @@ GroupedAggregateHashTable::GroupedAggregateHashTable(ClientContext &context, All\n \tResize(initial_capacity);\n \n \t// Predicates\n-\tpredicates.resize(layout.ColumnCount() - 1, ExpressionType::COMPARE_EQUAL);\n+\tpredicates.resize(layout.ColumnCount() - 1, ExpressionType::COMPARE_NOT_DISTINCT_FROM);\n+\trow_matcher.Initialize(true, layout, predicates);\n }\n \n void GroupedAggregateHashTable::InitializePartitionedData() {\n@@ -414,9 +416,8 @@ idx_t GroupedAggregateHashTable::FindOrCreateGroupsInternal(DataChunk &groups, V\n \t\t\t}\n \n \t\t\t// Perform group comparisons\n-\t\t\tRowOperations::Match(state.group_chunk, state.group_data.get(), layout, addresses_v, predicates,\n-\t\t\t                     state.group_compare_vector, need_compare_count, &state.no_match_vector,\n-\t\t\t                     no_match_count);\n+\t\t\trow_matcher.Match(state.group_chunk, chunk_state.vector_data, state.group_compare_vector,\n+\t\t\t                  need_compare_count, layout, addresses_v, &state.no_match_vector, no_match_count);\n \t\t}\n \n \t\t// Linear probing: each of the entries that do not match move to the next entry in the HT\ndiff --git a/src/execution/join_hashtable.cpp b/src/execution/join_hashtable.cpp\nindex 1cfb66b93484..dc17aa62d9ef 100644\n--- a/src/execution/join_hashtable.cpp\n+++ b/src/execution/join_hashtable.cpp\n@@ -19,15 +19,15 @@ JoinHashTable::JoinHashTable(BufferManager &buffer_manager_p, const vector<JoinC\n     : buffer_manager(buffer_manager_p), conditions(conditions_p), build_types(std::move(btypes)), entry_size(0),\n       tuple_size(0), vfound(Value::BOOLEAN(false)), join_type(type_p), finalized(false), has_null(false),\n       external(false), radix_bits(4), partition_start(0), partition_end(0) {\n+\n \tfor (auto &condition : conditions) {\n \t\tD_ASSERT(condition.left->return_type == condition.right->return_type);\n \t\tauto type = condition.left->return_type;\n \t\tif (condition.comparison == ExpressionType::COMPARE_EQUAL ||\n-\t\t    condition.comparison == ExpressionType::COMPARE_NOT_DISTINCT_FROM ||\n-\t\t    condition.comparison == ExpressionType::COMPARE_DISTINCT_FROM) {\n-\t\t\t// all equality conditions should be at the front\n-\t\t\t// all other conditions at the back\n-\t\t\t// this assert checks that\n+\t\t    condition.comparison == ExpressionType::COMPARE_NOT_DISTINCT_FROM) {\n+\n+\t\t\t// ensure that all equality conditions are at the front,\n+\t\t\t// and that all other conditions are at the back\n \t\t\tD_ASSERT(equality_types.size() == condition_types.size());\n \t\t\tequality_types.push_back(type);\n \t\t}\n@@ -51,6 +51,8 @@ JoinHashTable::JoinHashTable(BufferManager &buffer_manager_p, const vector<JoinC\n \t}\n \tlayout_types.emplace_back(LogicalType::HASH);\n \tlayout.Initialize(layout_types, false);\n+\trow_matcher.Initialize(false, layout, predicates);\n+\trow_matcher_no_match_sel.Initialize(true, layout, predicates);\n \n \tconst auto &offsets = layout.GetOffsets();\n \ttuple_size = offsets[condition_types.size() + build_types.size()];\n@@ -142,30 +144,6 @@ static idx_t FilterNullValues(UnifiedVectorFormat &vdata, const SelectionVector\n \treturn result_count;\n }\n \n-idx_t JoinHashTable::PrepareKeys(DataChunk &keys, unsafe_unique_array<UnifiedVectorFormat> &key_data,\n-                                 const SelectionVector *&current_sel, SelectionVector &sel, bool build_side) {\n-\tkey_data = keys.ToUnifiedFormat();\n-\n-\t// figure out which keys are NULL, and create a selection vector out of them\n-\tcurrent_sel = FlatVector::IncrementalSelectionVector();\n-\tidx_t added_count = keys.size();\n-\tif (build_side && IsRightOuterJoin(join_type)) {\n-\t\t// in case of a right or full outer join, we cannot remove NULL keys from the build side\n-\t\treturn added_count;\n-\t}\n-\tfor (idx_t i = 0; i < keys.ColumnCount(); i++) {\n-\t\tif (!null_values_are_equal[i]) {\n-\t\t\tif (key_data[i].validity.AllValid()) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tadded_count = FilterNullValues(key_data[i], *current_sel, added_count, sel);\n-\t\t\t// null values are NOT equal for this column, filter them out\n-\t\t\tcurrent_sel = &sel;\n-\t\t}\n-\t}\n-\treturn added_count;\n-}\n-\n void JoinHashTable::Build(PartitionedTupleDataAppendState &append_state, DataChunk &keys, DataChunk &payload) {\n \tD_ASSERT(!finalized);\n \tD_ASSERT(keys.size() == payload.size());\n@@ -194,23 +172,6 @@ void JoinHashTable::Build(PartitionedTupleDataAppendState &append_state, DataChu\n \t\tinfo.correlated_counts->AddChunk(info.group_chunk, info.correlated_payload, AggregateType::NON_DISTINCT);\n \t}\n \n-\t// prepare the keys for processing\n-\tunsafe_unique_array<UnifiedVectorFormat> key_data;\n-\tconst SelectionVector *current_sel;\n-\tSelectionVector sel(STANDARD_VECTOR_SIZE);\n-\tidx_t added_count = PrepareKeys(keys, key_data, current_sel, sel, true);\n-\tif (added_count < keys.size()) {\n-\t\thas_null = true;\n-\t}\n-\tif (added_count == 0) {\n-\t\treturn;\n-\t}\n-\n-\t// hash the keys and obtain an entry in the list\n-\t// note that we only hash the keys used in the equality comparison\n-\tVector hash_values(LogicalType::HASH);\n-\tHash(keys, *current_sel, added_count, hash_values);\n-\n \t// build a chunk to append to the data collection [keys, payload, (optional \"found\" boolean), hash]\n \tDataChunk source_chunk;\n \tsource_chunk.InitializeEmpty(layout.GetTypes());\n@@ -228,13 +189,58 @@ void JoinHashTable::Build(PartitionedTupleDataAppendState &append_state, DataChu\n \t\tsource_chunk.data[col_offset].Reference(vfound);\n \t\tcol_offset++;\n \t}\n+\tVector hash_values(LogicalType::HASH);\n \tsource_chunk.data[col_offset].Reference(hash_values);\n \tsource_chunk.SetCardinality(keys);\n \n+\t// ToUnifiedFormat the source chunk\n+\tTupleDataCollection::ToUnifiedFormat(append_state.chunk_state, source_chunk);\n+\n+\t// prepare the keys for processing\n+\tconst SelectionVector *current_sel;\n+\tSelectionVector sel(STANDARD_VECTOR_SIZE);\n+\tidx_t added_count = PrepareKeys(keys, append_state.chunk_state.vector_data, current_sel, sel, true);\n \tif (added_count < keys.size()) {\n-\t\tsource_chunk.Slice(*current_sel, added_count);\n+\t\thas_null = true;\n+\t}\n+\tif (added_count == 0) {\n+\t\treturn;\n \t}\n-\tsink_collection->Append(append_state, source_chunk);\n+\n+\t// hash the keys and obtain an entry in the list\n+\t// note that we only hash the keys used in the equality comparison\n+\tHash(keys, *current_sel, added_count, hash_values);\n+\n+\t// Re-reference and ToUnifiedFormat the hash column after computing it\n+\tsource_chunk.data[col_offset].Reference(hash_values);\n+\thash_values.ToUnifiedFormat(source_chunk.size(), append_state.chunk_state.vector_data.back().unified);\n+\n+\t// We already called TupleDataCollection::ToUnifiedFormat, so we can AppendUnified here\n+\tsink_collection->AppendUnified(append_state, source_chunk, *current_sel, added_count);\n+}\n+\n+idx_t JoinHashTable::PrepareKeys(DataChunk &keys, vector<TupleDataVectorFormat> &vector_data,\n+                                 const SelectionVector *&current_sel, SelectionVector &sel, bool build_side) {\n+\t// figure out which keys are NULL, and create a selection vector out of them\n+\tcurrent_sel = FlatVector::IncrementalSelectionVector();\n+\tidx_t added_count = keys.size();\n+\tif (build_side && IsRightOuterJoin(join_type)) {\n+\t\t// in case of a right or full outer join, we cannot remove NULL keys from the build side\n+\t\treturn added_count;\n+\t}\n+\n+\tfor (idx_t col_idx = 0; col_idx < keys.ColumnCount(); col_idx++) {\n+\t\tif (!null_values_are_equal[col_idx]) {\n+\t\t\tauto &col_key_data = vector_data[col_idx].unified;\n+\t\t\tif (col_key_data.validity.AllValid()) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tadded_count = FilterNullValues(col_key_data, *current_sel, added_count, sel);\n+\t\t\t// null values are NOT equal for this column, filter them out\n+\t\t\tcurrent_sel = &sel;\n+\t\t}\n+\t}\n+\treturn added_count;\n }\n \n template <bool PARALLEL>\n@@ -322,12 +328,13 @@ void JoinHashTable::Finalize(idx_t chunk_idx_from, idx_t chunk_idx_to, bool para\n \t} while (iterator.Next());\n }\n \n-unique_ptr<ScanStructure> JoinHashTable::InitializeScanStructure(DataChunk &keys, const SelectionVector *&current_sel) {\n+unique_ptr<ScanStructure> JoinHashTable::InitializeScanStructure(DataChunk &keys, TupleDataChunkState &key_state,\n+                                                                 const SelectionVector *&current_sel) {\n \tD_ASSERT(Count() > 0); // should be handled before\n \tD_ASSERT(finalized);\n \n \t// set up the scan structure\n-\tauto ss = make_uniq<ScanStructure>(*this);\n+\tauto ss = make_uniq<ScanStructure>(*this, key_state);\n \n \tif (join_type != JoinType::INNER) {\n \t\tss->found_match = make_unsafe_uniq_array<bool>(STANDARD_VECTOR_SIZE);\n@@ -335,13 +342,15 @@ unique_ptr<ScanStructure> JoinHashTable::InitializeScanStructure(DataChunk &keys\n \t}\n \n \t// first prepare the keys for probing\n-\tss->count = PrepareKeys(keys, ss->key_data, current_sel, ss->sel_vector, false);\n+\tTupleDataCollection::ToUnifiedFormat(key_state, keys);\n+\tss->count = PrepareKeys(keys, key_state.vector_data, current_sel, ss->sel_vector, false);\n \treturn ss;\n }\n \n-unique_ptr<ScanStructure> JoinHashTable::Probe(DataChunk &keys, Vector *precomputed_hashes) {\n+unique_ptr<ScanStructure> JoinHashTable::Probe(DataChunk &keys, TupleDataChunkState &key_state,\n+                                               Vector *precomputed_hashes) {\n \tconst SelectionVector *current_sel;\n-\tauto ss = InitializeScanStructure(keys, current_sel);\n+\tauto ss = InitializeScanStructure(keys, key_state, current_sel);\n \tif (ss->count == 0) {\n \t\treturn ss;\n \t}\n@@ -363,8 +372,9 @@ unique_ptr<ScanStructure> JoinHashTable::Probe(DataChunk &keys, Vector *precompu\n \treturn ss;\n }\n \n-ScanStructure::ScanStructure(JoinHashTable &ht)\n-    : pointers(LogicalType::POINTER), sel_vector(STANDARD_VECTOR_SIZE), ht(ht), finished(false) {\n+ScanStructure::ScanStructure(JoinHashTable &ht_p, TupleDataChunkState &key_state_p)\n+    : key_state(key_state_p), pointers(LogicalType::POINTER), sel_vector(STANDARD_VECTOR_SIZE), ht(ht_p),\n+      finished(false) {\n }\n \n void ScanStructure::Next(DataChunk &keys, DataChunk &left, DataChunk &result) {\n@@ -404,8 +414,9 @@ idx_t ScanStructure::ResolvePredicates(DataChunk &keys, SelectionVector &match_s\n \t}\n \tidx_t no_match_count = 0;\n \n-\treturn RowOperations::Match(keys, key_data.get(), ht.layout, pointers, ht.predicates, match_sel, this->count,\n-\t                            no_match_sel, no_match_count);\n+\tauto &matcher = no_match_sel ? ht.row_matcher_no_match_sel : ht.row_matcher;\n+\treturn matcher.Match(keys, key_state.vector_data, match_sel, this->count, ht.layout, pointers, no_match_sel,\n+\t                     no_match_count);\n }\n \n idx_t ScanStructure::ScanInnerJoin(DataChunk &keys, SelectionVector &result_vector) {\n@@ -990,7 +1001,8 @@ static void CreateSpillChunk(DataChunk &spill_chunk, DataChunk &keys, DataChunk\n \tspill_chunk.data[spill_col_idx].Reference(hashes);\n }\n \n-unique_ptr<ScanStructure> JoinHashTable::ProbeAndSpill(DataChunk &keys, DataChunk &payload, ProbeSpill &probe_spill,\n+unique_ptr<ScanStructure> JoinHashTable::ProbeAndSpill(DataChunk &keys, TupleDataChunkState &key_state,\n+                                                       DataChunk &payload, ProbeSpill &probe_spill,\n                                                        ProbeSpillLocalAppendState &spill_state,\n                                                        DataChunk &spill_chunk) {\n \t// hash all the keys\n@@ -1019,7 +1031,7 @@ unique_ptr<ScanStructure> JoinHashTable::ProbeAndSpill(DataChunk &keys, DataChun\n \tpayload.Slice(true_sel, true_count);\n \n \tconst SelectionVector *current_sel;\n-\tauto ss = InitializeScanStructure(keys, current_sel);\n+\tauto ss = InitializeScanStructure(keys, key_state, current_sel);\n \tif (ss->count == 0) {\n \t\treturn ss;\n \t}\ndiff --git a/src/execution/operator/join/physical_hash_join.cpp b/src/execution/operator/join/physical_hash_join.cpp\nindex 18726c206b10..d6faee754ed4 100644\n--- a/src/execution/operator/join/physical_hash_join.cpp\n+++ b/src/execution/operator/join/physical_hash_join.cpp\n@@ -420,6 +420,8 @@ class HashJoinOperatorState : public CachingOperatorState {\n \t}\n \n \tDataChunk join_keys;\n+\tTupleDataChunkState join_key_state;\n+\n \tExpressionExecutor probe_executor;\n \tunique_ptr<JoinHashTable::ScanStructure> scan_structure;\n \tunique_ptr<OperatorState> perfect_hash_join_state;\n@@ -446,6 +448,7 @@ unique_ptr<OperatorState> PhysicalHashJoin::GetOperatorState(ExecutionContext &c\n \t\tfor (auto &cond : conditions) {\n \t\t\tstate->probe_executor.AddExpression(*cond.left);\n \t\t}\n+\t\tTupleDataCollection::InitializeChunkState(state->join_key_state, condition_types);\n \t}\n \tif (sink.external) {\n \t\tstate->spill_chunk.Initialize(allocator, sink.probe_types);\n@@ -502,10 +505,10 @@ OperatorResultType PhysicalHashJoin::ExecuteInternal(ExecutionContext &context,\n \n \t// perform the actual probe\n \tif (sink.external) {\n-\t\tstate.scan_structure = sink.hash_table->ProbeAndSpill(state.join_keys, input, *sink.probe_spill,\n-\t\t                                                      state.spill_state, state.spill_chunk);\n+\t\tstate.scan_structure = sink.hash_table->ProbeAndSpill(state.join_keys, state.join_key_state, input,\n+\t\t                                                      *sink.probe_spill, state.spill_state, state.spill_chunk);\n \t} else {\n-\t\tstate.scan_structure = sink.hash_table->Probe(state.join_keys);\n+\t\tstate.scan_structure = sink.hash_table->Probe(state.join_keys, state.join_key_state);\n \t}\n \tstate.scan_structure->Next(state.join_keys, input, chunk);\n \treturn OperatorResultType::HAVE_MORE_OUTPUT;\n@@ -605,6 +608,7 @@ class HashJoinLocalSourceState : public LocalSourceState {\n \tDataChunk probe_chunk;\n \tDataChunk join_keys;\n \tDataChunk payload;\n+\tTupleDataChunkState join_key_state;\n \t//! Column indices to easily reference the join keys/payload columns in probe_chunk\n \tvector<idx_t> join_key_indices;\n \tvector<idx_t> payload_indices;\n@@ -782,6 +786,7 @@ HashJoinLocalSourceState::HashJoinLocalSourceState(const PhysicalHashJoin &op, A\n \tprobe_chunk.Initialize(allocator, sink.probe_types);\n \tjoin_keys.Initialize(allocator, op.condition_types);\n \tpayload.Initialize(allocator, op.children[0]->types);\n+\tTupleDataCollection::InitializeChunkState(join_key_state, op.condition_types);\n \n \t// Store the indices of the columns to reference them easily\n \tidx_t col_idx = 0;\n@@ -871,7 +876,7 @@ void HashJoinLocalSourceState::ExternalProbe(HashJoinGlobalSinkState &sink, Hash\n \t}\n \n \t// Perform the probe\n-\tscan_structure = sink.hash_table->Probe(join_keys, precomputed_hashes);\n+\tscan_structure = sink.hash_table->Probe(join_keys, join_key_state, precomputed_hashes);\n \tscan_structure->Next(join_keys, payload, chunk);\n }\n \ndiff --git a/src/execution/physical_plan/plan_comparison_join.cpp b/src/execution/physical_plan/plan_comparison_join.cpp\nindex 48df353b1c28..405ae9ef7cce 100644\n--- a/src/execution/physical_plan/plan_comparison_join.cpp\n+++ b/src/execution/physical_plan/plan_comparison_join.cpp\n@@ -254,7 +254,6 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::PlanComparisonJoin(LogicalCo\n \t}\n \n \tbool has_equality = false;\n-\t// bool has_inequality = false;\n \tsize_t has_range = 0;\n \tfor (size_t c = 0; c < op.conditions.size(); ++c) {\n \t\tauto &cond = op.conditions[c];\n@@ -271,7 +270,6 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::PlanComparisonJoin(LogicalCo\n \t\t\tbreak;\n \t\tcase ExpressionType::COMPARE_NOTEQUAL:\n \t\tcase ExpressionType::COMPARE_DISTINCT_FROM:\n-\t\t\t// has_inequality = true;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tthrow NotImplementedException(\"Unimplemented comparison join\");\ndiff --git a/src/include/duckdb/common/row_operations/row_matcher.hpp b/src/include/duckdb/common/row_operations/row_matcher.hpp\nnew file mode 100644\nindex 000000000000..006e2f6dcb23\n--- /dev/null\n+++ b/src/include/duckdb/common/row_operations/row_matcher.hpp\n@@ -0,0 +1,63 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/row_operations/row_matcher.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/enums/expression_type.hpp\"\n+#include \"duckdb/common/types.hpp\"\n+\n+namespace duckdb {\n+\n+class Vector;\n+class DataChunk;\n+class TupleDataLayout;\n+struct TupleDataVectorFormat;\n+struct SelectionVector;\n+struct MatchFunction;\n+\n+typedef idx_t (*match_function_t)(Vector &lhs_vector, const TupleDataVectorFormat &lhs_format, SelectionVector &sel,\n+                                  const idx_t count, const TupleDataLayout &rhs_layout, Vector &rhs_row_locations,\n+                                  const idx_t col_idx, const vector<MatchFunction> &child_functions,\n+                                  SelectionVector *no_match_sel, idx_t &no_match_count);\n+\n+struct MatchFunction {\n+\tmatch_function_t function;\n+\tvector<MatchFunction> child_functions;\n+};\n+\n+struct RowMatcher {\n+public:\n+\tusing Predicates = vector<ExpressionType>;\n+\n+\t//! Initializes the RowMatcher, filling match_functions using layout and predicates\n+\tvoid Initialize(const bool no_match_sel, const TupleDataLayout &layout, const Predicates &predicates);\n+\t//! Given a DataChunk on the LHS, on which we've called TupleDataCollection::ToUnifiedFormat,\n+\t//! we match it with rows on the RHS, according to the given layout and locations.\n+\t//! Initially, 'sel' has 'count' entries which point to what needs to be compared.\n+\t//! After matching is done, this returns how many matching entries there are, which 'sel' is modified to point to\n+\tidx_t Match(DataChunk &lhs, const vector<TupleDataVectorFormat> &lhs_formats, SelectionVector &sel, idx_t count,\n+\t            const TupleDataLayout &rhs_layout, Vector &rhs_row_locations, SelectionVector *no_match_sel,\n+\t            idx_t &no_match_count);\n+\n+private:\n+\t//! Gets the templated match function for a given column\n+\tMatchFunction GetMatchFunction(const bool no_match_sel, const LogicalType &type, const ExpressionType predicate);\n+\ttemplate <bool NO_MATCH_SEL>\n+\tMatchFunction GetMatchFunction(const LogicalType &type, const ExpressionType predicate);\n+\ttemplate <bool NO_MATCH_SEL, class T>\n+\tMatchFunction GetMatchFunction(const ExpressionType predicate);\n+\ttemplate <bool NO_MATCH_SEL>\n+\tMatchFunction GetStructMatchFunction(const LogicalType &type, const ExpressionType predicate);\n+\ttemplate <bool NO_MATCH_SEL>\n+\tMatchFunction GetListMatchFunction(const ExpressionType predicate);\n+\n+private:\n+\tvector<MatchFunction> match_functions;\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/common/types/row/tuple_data_collection.hpp b/src/include/duckdb/common/types/row/tuple_data_collection.hpp\nindex f49f1b00791b..34efa90d28f3 100644\n--- a/src/include/duckdb/common/types/row/tuple_data_collection.hpp\n+++ b/src/include/duckdb/common/types/row/tuple_data_collection.hpp\n@@ -21,7 +21,7 @@ struct RowOperationsState;\n \n typedef void (*tuple_data_scatter_function_t)(const Vector &source, const TupleDataVectorFormat &source_format,\n                                               const SelectionVector &append_sel, const idx_t append_count,\n-                                              const TupleDataLayout &layout, Vector &row_locations,\n+                                              const TupleDataLayout &layout, const Vector &row_locations,\n                                               Vector &heap_locations, const idx_t col_idx,\n                                               const UnifiedVectorFormat &list_format,\n                                               const vector<TupleDataScatterFunction> &child_functions);\n@@ -84,7 +84,11 @@ class TupleDataCollection {\n \t                      TupleDataPinProperties = TupleDataPinProperties::UNPIN_AFTER_DONE);\n \t//! Initializes the Chunk state of an Append state\n \t//! - Useful for optimizing many appends made to the same tuple data collection\n-\tvoid InitializeAppend(TupleDataChunkState &chunk_state, vector<column_t> column_ids = {});\n+\tvoid InitializeChunkState(TupleDataChunkState &chunk_state, vector<column_t> column_ids = {});\n+\t//! Initializes the Chunk state of an Append state\n+\t//! - Useful for optimizing many appends made to the same tuple data collection\n+\tstatic void InitializeChunkState(TupleDataChunkState &chunk_state, const vector<LogicalType> &types,\n+\t                                 vector<column_t> column_ids = {});\n \t//! Append a DataChunk directly to this TupleDataCollection - calls InitializeAppend and Append internally\n \tvoid Append(DataChunk &new_chunk, const SelectionVector &append_sel = *FlatVector::IncrementalSelectionVector(),\n \t            idx_t append_count = DConstants::INVALID_INDEX);\ndiff --git a/src/include/duckdb/common/types/row/tuple_data_states.hpp b/src/include/duckdb/common/types/row/tuple_data_states.hpp\nindex 1bd5cf333f54..6d29d36c8b81 100644\n--- a/src/include/duckdb/common/types/row/tuple_data_states.hpp\n+++ b/src/include/duckdb/common/types/row/tuple_data_states.hpp\n@@ -42,8 +42,8 @@ struct TupleDataVectorFormat {\n \tconst SelectionVector *original_sel;\n \tSelectionVector original_owned_sel;\n \n-\tUnifiedVectorFormat data;\n-\tvector<TupleDataVectorFormat> child_formats;\n+\tUnifiedVectorFormat unified;\n+\tvector<TupleDataVectorFormat> children;\n \tunique_ptr<CombinedListData> combined_list_data;\n };\n \ndiff --git a/src/include/duckdb/common/types/validity_mask.hpp b/src/include/duckdb/common/types/validity_mask.hpp\nindex c3fcc25b8c96..d23c862ce2a6 100644\n--- a/src/include/duckdb/common/types/validity_mask.hpp\n+++ b/src/include/duckdb/common/types/validity_mask.hpp\n@@ -148,6 +148,9 @@ struct TemplatedValidityMask {\n \t\tif (!validity_mask) {\n \t\t\treturn ValidityBuffer::MAX_ENTRY;\n \t\t}\n+\t\treturn GetValidityEntryUnsafe(entry_idx);\n+\t}\n+\tinline V &GetValidityEntryUnsafe(idx_t entry_idx) const {\n \t\treturn validity_mask[entry_idx];\n \t}\n \tstatic inline bool AllValid(V entry) {\n@@ -156,7 +159,7 @@ struct TemplatedValidityMask {\n \tstatic inline bool NoneValid(V entry) {\n \t\treturn entry == 0;\n \t}\n-\tstatic inline bool RowIsValid(V entry, idx_t idx_in_entry) {\n+\tstatic inline bool RowIsValid(const V &entry, const idx_t &idx_in_entry) {\n \t\treturn entry & (V(1) << V(idx_in_entry));\n \t}\n \tstatic inline void GetEntryIndex(idx_t row_idx, idx_t &entry_idx, idx_t &idx_in_entry) {\ndiff --git a/src/include/duckdb/execution/aggregate_hashtable.hpp b/src/include/duckdb/execution/aggregate_hashtable.hpp\nindex d5fabe5182b5..b8a4a8fa4834 100644\n--- a/src/include/duckdb/execution/aggregate_hashtable.hpp\n+++ b/src/include/duckdb/execution/aggregate_hashtable.hpp\n@@ -8,6 +8,7 @@\n \n #pragma once\n \n+#include \"duckdb/common/row_operations/row_matcher.hpp\"\n #include \"duckdb/common/types/row/partitioned_tuple_data.hpp\"\n #include \"duckdb/execution/base_aggregate_hashtable.hpp\"\n #include \"duckdb/storage/arena_allocator.hpp\"\n@@ -143,6 +144,9 @@ class GroupedAggregateHashTable : public BaseAggregateHashTable {\n \tvoid UnpinData();\n \n private:\n+\t//! Efficiently matches groups\n+\tRowMatcher row_matcher;\n+\n \t//! Append state\n \tstruct AggregateHTAppendState {\n \t\tAggregateHTAppendState();\ndiff --git a/src/include/duckdb/execution/join_hashtable.hpp b/src/include/duckdb/execution/join_hashtable.hpp\nindex c51a26c6935f..a602ae18ba79 100644\n--- a/src/include/duckdb/execution/join_hashtable.hpp\n+++ b/src/include/duckdb/execution/join_hashtable.hpp\n@@ -65,7 +65,7 @@ class JoinHashTable {\n \t//! returned by the JoinHashTable::Scan function and can be used to resume a\n \t//! probe.\n \tstruct ScanStructure {\n-\t\tunsafe_unique_array<UnifiedVectorFormat> key_data;\n+\t\tTupleDataChunkState &key_state;\n \t\tVector pointers;\n \t\tidx_t count;\n \t\tSelectionVector sel_vector;\n@@ -74,7 +74,7 @@ class JoinHashTable {\n \t\tJoinHashTable &ht;\n \t\tbool finished;\n \n-\t\texplicit ScanStructure(JoinHashTable &ht);\n+\t\texplicit ScanStructure(JoinHashTable &ht, TupleDataChunkState &key_state);\n \t\t//! Get the next batch of data from the scan structure\n \t\tvoid Next(DataChunk &keys, DataChunk &left, DataChunk &result);\n \n@@ -130,7 +130,8 @@ class JoinHashTable {\n \t//! ever called.\n \tvoid Finalize(idx_t chunk_idx_from, idx_t chunk_idx_to, bool parallel);\n \t//! Probe the HT with the given input chunk, resulting in the given result\n-\tunique_ptr<ScanStructure> Probe(DataChunk &keys, Vector *precomputed_hashes = nullptr);\n+\tunique_ptr<ScanStructure> Probe(DataChunk &keys, TupleDataChunkState &key_state,\n+\t                                Vector *precomputed_hashes = nullptr);\n \t//! Scan the HT to construct the full outer join result\n \tvoid ScanFullOuter(JoinHTScanState &state, Vector &addresses, DataChunk &result);\n \n@@ -166,6 +167,9 @@ class JoinHashTable {\n \tvector<ExpressionType> predicates;\n \t//! Data column layout\n \tTupleDataLayout layout;\n+\t//! Efficiently matches rows\n+\tRowMatcher row_matcher;\n+\tRowMatcher row_matcher_no_match_sel;\n \t//! The size of an entry as stored in the HashTable\n \tidx_t entry_size;\n \t//! The total tuple size\n@@ -201,7 +205,8 @@ class JoinHashTable {\n \t} correlated_mark_join_info;\n \n private:\n-\tunique_ptr<ScanStructure> InitializeScanStructure(DataChunk &keys, const SelectionVector *&current_sel);\n+\tunique_ptr<ScanStructure> InitializeScanStructure(DataChunk &keys, TupleDataChunkState &key_state,\n+\t                                                  const SelectionVector *&current_sel);\n \tvoid Hash(DataChunk &keys, const SelectionVector &sel, idx_t count, Vector &hashes);\n \n \t//! Apply a bitmask to the hashes\n@@ -212,8 +217,8 @@ class JoinHashTable {\n \t//! Insert the given set of locations into the HT with the given set of hashes\n \tvoid InsertHashes(Vector &hashes, idx_t count, data_ptr_t key_locations[], bool parallel);\n \n-\tidx_t PrepareKeys(DataChunk &keys, unsafe_unique_array<UnifiedVectorFormat> &key_data,\n-\t                  const SelectionVector *&current_sel, SelectionVector &sel, bool build_side);\n+\tidx_t PrepareKeys(DataChunk &keys, vector<TupleDataVectorFormat> &vector_data, const SelectionVector *&current_sel,\n+\t                  SelectionVector &sel, bool build_side);\n \n \t//! Lock for combining data_collection when merging HTs\n \tmutex data_lock;\n@@ -316,8 +321,9 @@ class JoinHashTable {\n \t//! Build HT for the next partitioned probe round\n \tbool PrepareExternalFinalize();\n \t//! Probe whatever we can, sink the rest into a thread-local HT\n-\tunique_ptr<ScanStructure> ProbeAndSpill(DataChunk &keys, DataChunk &payload, ProbeSpill &probe_spill,\n-\t                                        ProbeSpillLocalAppendState &spill_state, DataChunk &spill_chunk);\n+\tunique_ptr<ScanStructure> ProbeAndSpill(DataChunk &keys, TupleDataChunkState &key_state, DataChunk &payload,\n+\t                                        ProbeSpill &probe_spill, ProbeSpillLocalAppendState &spill_state,\n+\t                                        DataChunk &spill_chunk);\n \n private:\n \t//! First and last partition of the current probe round\ndiff --git a/src/planner/binder/tableref/plan_joinref.cpp b/src/planner/binder/tableref/plan_joinref.cpp\nindex 53804ef9d434..9bc0b1303a93 100644\n--- a/src/planner/binder/tableref/plan_joinref.cpp\n+++ b/src/planner/binder/tableref/plan_joinref.cpp\n@@ -51,6 +51,7 @@ void LogicalComparisonJoin::ExtractJoinConditions(\n     unique_ptr<LogicalOperator> &right_child, const unordered_set<idx_t> &left_bindings,\n     const unordered_set<idx_t> &right_bindings, vector<unique_ptr<Expression>> &expressions,\n     vector<JoinCondition> &conditions, vector<unique_ptr<Expression>> &arbitrary_expressions) {\n+\n \tfor (auto &expr : expressions) {\n \t\tauto total_side = JoinSide::GetJoinSide(*expr, left_bindings, right_bindings);\n \t\tif (total_side != JoinSide::BOTH) {\n@@ -77,10 +78,17 @@ void LogicalComparisonJoin::ExtractJoinConditions(\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n-\t\t} else if ((expr->type >= ExpressionType::COMPARE_EQUAL &&\n-\t\t            expr->type <= ExpressionType::COMPARE_GREATERTHANOREQUALTO) ||\n-\t\t           expr->type == ExpressionType::COMPARE_DISTINCT_FROM ||\n-\t\t           expr->type == ExpressionType::COMPARE_NOT_DISTINCT_FROM) {\n+\t\t} else if (expr->type == ExpressionType::COMPARE_EQUAL || expr->type == ExpressionType::COMPARE_NOTEQUAL ||\n+\t\t           expr->type == ExpressionType::COMPARE_BOUNDARY_START ||\n+\t\t           expr->type == ExpressionType::COMPARE_LESSTHAN ||\n+\t\t           expr->type == ExpressionType::COMPARE_GREATERTHAN ||\n+\t\t           expr->type == ExpressionType::COMPARE_LESSTHANOREQUALTO ||\n+\t\t           expr->type == ExpressionType::COMPARE_GREATERTHANOREQUALTO ||\n+\t\t           expr->type == ExpressionType::COMPARE_BOUNDARY_START ||\n+\t\t           expr->type == ExpressionType::COMPARE_NOT_DISTINCT_FROM ||\n+\t\t           expr->type == ExpressionType::COMPARE_DISTINCT_FROM)\n+\n+\t\t{\n \t\t\t// comparison, check if we can create a comparison JoinCondition\n \t\t\tif (CreateJoinCondition(*expr, left_bindings, right_bindings, conditions)) {\n \t\t\t\t// successfully created the join condition\n",
  "test_patch": "diff --git a/test/sql/join/inner/test_join_is_distinct.test b/test/sql/join/inner/test_join_is_distinct.test\nnew file mode 100644\nindex 000000000000..55f719aaaa8e\n--- /dev/null\n+++ b/test/sql/join/inner/test_join_is_distinct.test\n@@ -0,0 +1,357 @@\n+# name: test/sql/join/inner/test_join_is_distinct.test\n+# description: Test using two join predicates, of which one is IS DISTINCT\n+# group: [inner]\n+\n+# issue #8328\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+statement ok\n+CREATE TABLE tbl (col0 INTEGER, col1 INTEGER);\n+\n+statement ok\n+INSERT INTO tbl VALUES (1, 0), (1, 1);\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl x JOIN tbl y\n+ON x.col0 = y.col0 AND (x.col1 IS DISTINCT FROM y.col1)\n+ORDER BY x.col1;\n+----\n+0\t1\n+1\t0\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl x JOIN tbl y\n+ON x.col0 = y.col0 AND x.col1 != y.col1\n+ORDER BY x.col1;\n+----\n+0\t1\n+1\t0\n+\n+statement ok\n+INSERT INTO tbl VALUES (1, 0), (1, 1);\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl x JOIN tbl y\n+ON x.col0 = y.col0 AND (x.col1 IS DISTINCT FROM y.col1)\n+ORDER BY x.col1;\n+----\n+0\t1\n+0\t1\n+0\t1\n+0\t1\n+1\t0\n+1\t0\n+1\t0\n+1\t0\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl x JOIN tbl y\n+ON x.col0 = y.col0 AND x.col1 != y.col1\n+ORDER BY x.col1;\n+----\n+0\t1\n+0\t1\n+0\t1\n+0\t1\n+1\t0\n+1\t0\n+1\t0\n+1\t0\n+\n+# same but with structs\n+statement ok\n+CREATE TABLE tbl_s (col0 STRUCT(x INTEGER), col1 STRUCT(x INTEGER));\n+\n+statement ok\n+INSERT INTO tbl_s VALUES ({x: 1}, {x: 0}), ({x: 1}, {x: 1});\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_s x JOIN tbl_s y\n+ON x.col0 = y.col0 AND (x.col1 IS DISTINCT FROM y.col1)\n+ORDER BY x.col1;\n+----\n+{'x': 0}\t{'x': 1}\n+{'x': 1}\t{'x': 0}\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_s x JOIN tbl_s y\n+ON x.col0 = y.col0 AND x.col1 != y.col1\n+ORDER BY x.col1;\n+----\n+{'x': 0}\t{'x': 1}\n+{'x': 1}\t{'x': 0}\n+\n+statement ok\n+INSERT INTO tbl_s VALUES ({x: 1}, {x: 0}), ({x: 1}, {x: 1});\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_s x JOIN tbl_s y\n+ON x.col0 = y.col0 AND (x.col1 IS DISTINCT FROM y.col1)\n+ORDER BY x.col1;\n+----\n+{'x': 0}\t{'x': 1}\n+{'x': 0}\t{'x': 1}\n+{'x': 0}\t{'x': 1}\n+{'x': 0}\t{'x': 1}\n+{'x': 1}\t{'x': 0}\n+{'x': 1}\t{'x': 0}\n+{'x': 1}\t{'x': 0}\n+{'x': 1}\t{'x': 0}\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_s x JOIN tbl_s y\n+ON x.col0 = y.col0 AND x.col1 != y.col1\n+ORDER BY x.col1;\n+----\n+{'x': 0}\t{'x': 1}\n+{'x': 0}\t{'x': 1}\n+{'x': 0}\t{'x': 1}\n+{'x': 0}\t{'x': 1}\n+{'x': 1}\t{'x': 0}\n+{'x': 1}\t{'x': 0}\n+{'x': 1}\t{'x': 0}\n+{'x': 1}\t{'x': 0}\n+\n+# same but with lists\n+statement ok\n+CREATE TABLE tbl_l (col0 INTEGER[], col1 INTEGER[]);\n+\n+statement ok\n+INSERT INTO tbl_l VALUES ([1], [0]), ([1], [1]);\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_l x JOIN tbl_l y\n+ON x.col0 = y.col0 AND (x.col1 IS DISTINCT FROM y.col1)\n+ORDER BY x.col1;\n+----\n+[0]\t[1]\n+[1]\t[0]\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_l x JOIN tbl_l y\n+ON x.col0 = y.col0 AND x.col1 != y.col1\n+ORDER BY x.col1;\n+----\n+[0]\t[1]\n+[1]\t[0]\n+\n+statement ok\n+INSERT INTO tbl_l VALUES ([1], [0]), ([1], [1]);\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_l x JOIN tbl_l y\n+ON x.col0 = y.col0 AND (x.col1 IS DISTINCT FROM y.col1)\n+ORDER BY x.col1;\n+----\n+[0]\t[1]\n+[0]\t[1]\n+[0]\t[1]\n+[0]\t[1]\n+[1]\t[0]\n+[1]\t[0]\n+[1]\t[0]\n+[1]\t[0]\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_l x JOIN tbl_l y\n+ON x.col0 = y.col0 AND x.col1 != y.col1\n+ORDER BY x.col1;\n+----\n+[0]\t[1]\n+[0]\t[1]\n+[0]\t[1]\n+[0]\t[1]\n+[1]\t[0]\n+[1]\t[0]\n+[1]\t[0]\n+[1]\t[0]\n+\n+query IIII\n+WITH abc AS (\n+\tSELECT * FROM (\n+    \tVALUES (1, 'x'), (1, 'x'), (1, '0'), (1, '0')\n+    ) AS tbl(col0, col1)\n+)\n+SELECT x.col0 AS c1, x.col1 AS c2, y.col0 AS c3, y.col1 AS c4\n+FROM abc x JOIN abc y ON x.col0 = y.col0\n+\tAND (x.col1 IS DISTINCT FROM y.col1)\n+ORDER BY c1, c2, c3, c4;\n+----\n+1\t0\t1\tx\n+1\t0\t1\tx\n+1\t0\t1\tx\n+1\t0\t1\tx\n+1\tx\t1\t0\n+1\tx\t1\t0\n+1\tx\t1\t0\n+1\tx\t1\t0\n+\n+# tests with NULLs\n+\n+statement ok\n+CREATE TABLE tbl_null (col0 INTEGER, col1 INTEGER);\n+\n+statement ok\n+INSERT INTO tbl_null VALUES (1, 0), (1, 1), (1, NULL), (NULL, 1), (0, NULL), (NULL, 0), (NULL, NULL);\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_null x JOIN tbl_null y\n+ON x.col0 = y.col0 AND (x.col1 IS DISTINCT FROM y.col1)\n+ORDER BY x.col1, y.col1;\n+----\n+0\t1\n+0\tNULL\n+1\t0\n+1\tNULL\n+NULL\t0\n+NULL\t1\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_null x JOIN tbl_null y\n+ON x.col0 = y.col0 AND x.col1 != y.col1\n+ORDER BY x.col1;\n+----\n+0\t1\n+1\t0\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_null x JOIN tbl_null y\n+ON x.col0 = y.col0 AND (x.col1 IS NOT DISTINCT FROM y.col1)\n+ORDER BY x.col1;\n+----\n+0\t0\n+1\t1\n+NULL\tNULL\n+NULL\tNULL\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_null x JOIN tbl_null y\n+ON x.col0 = y.col0 AND x.col1 = y.col1\n+ORDER BY x.col1;\n+----\n+0\t0\n+1\t1\n+\n+# similar but with structs\n+statement ok\n+CREATE TABLE tbl_s_null (col0 STRUCT(x INTEGER), col1 STRUCT(x INTEGER));\n+\n+statement ok\n+INSERT INTO tbl_s_null VALUES ({x: 1}, {x: 0}), ({x: 1}, {x: 1}), ({x: 1}, NULL), ({x: 1}, {x: NULL});\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_s_null x JOIN tbl_s_null y\n+ON x.col0 = y.col0 AND (x.col1 IS DISTINCT FROM y.col1)\n+ORDER BY x.col1, y.col1;\n+----\n+{'x': 0}\t{'x': 1}\n+{'x': 0}\t{'x': NULL}\n+{'x': 0}\tNULL\n+{'x': 1}\t{'x': 0}\n+{'x': 1}\t{'x': NULL}\n+{'x': 1}\tNULL\n+{'x': NULL}\t{'x': 0}\n+{'x': NULL}\t{'x': 1}\n+{'x': NULL}\tNULL\n+NULL\t{'x': 0}\n+NULL\t{'x': 1}\n+NULL\t{'x': NULL}\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_s_null x JOIN tbl_s_null y\n+ON x.col0 = y.col0 AND x.col1 != y.col1\n+ORDER BY x.col1;\n+----\n+{'x': 0}\t{'x': NULL}\n+{'x': 0}\t{'x': 1}\n+{'x': 1}\t{'x': NULL}\n+{'x': 1}\t{'x': 0}\n+{'x': NULL}\t{'x': 1}\n+{'x': NULL}\t{'x': 0}\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_s_null x JOIN tbl_s_null y\n+ON x.col0 = y.col0 AND x.col1 > y.col1\n+ORDER BY x.col1;\n+----\n+{'x': 1}\t{'x': 0}\n+{'x': NULL}\t{'x': 1}\n+{'x': NULL}\t{'x': 0}\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_s_null x JOIN tbl_s_null y\n+ON x.col0 = y.col0 AND (x.col1 IS NOT DISTINCT FROM y.col1)\n+ORDER BY x.col1;\n+----\n+{'x': 0}\t{'x': 0}\n+{'x': 1}\t{'x': 1}\n+{'x': NULL}\t{'x': NULL}\n+NULL\tNULL\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_s_null x JOIN tbl_s_null y\n+ON x.col0 = y.col0 AND x.col1 = y.col1\n+ORDER BY x.col1;\n+----\n+{'x': 0}\t{'x': 0}\n+{'x': 1}\t{'x': 1}\n+{'x': NULL}\t{'x': NULL}\n+\n+# same but with lists\n+\n+statement ok\n+CREATE TABLE tbl_l_null (col0 INTEGER[], col1 INTEGER[]);\n+\n+statement ok\n+INSERT INTO tbl_l_null VALUES ([1], [0]), ([1], [1]), ([1], NULL), ([1], [NULL]);\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_l_null x JOIN tbl_l_null y\n+ON x.col0 = y.col0 AND (x.col1 IS DISTINCT FROM y.col1)\n+ORDER BY x.col1, y.col1;\n+----\n+[0]\t[1]\n+[0]\t[NULL]\n+[0]\tNULL\n+[1]\t[0]\n+[1]\t[NULL]\n+[1]\tNULL\n+[NULL]\t[0]\n+[NULL]\t[1]\n+[NULL]\tNULL\n+NULL\t[0]\n+NULL\t[1]\n+NULL\t[NULL]\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_l_null x JOIN tbl_l_null y\n+ON x.col0 = y.col0 AND x.col1 != y.col1\n+ORDER BY x.col1;\n+----\n+[0]\t[NULL]\n+[0]\t[1]\n+[1]\t[NULL]\n+[1]\t[0]\n+[NULL]\t[1]\n+[NULL]\t[0]\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_l_null x JOIN tbl_l_null y\n+ON x.col0 = y.col0 AND (x.col1 IS NOT DISTINCT FROM y.col1)\n+ORDER BY x.col1;\n+----\n+[0]\t[0]\n+[1]\t[1]\n+[NULL]\t[NULL]\n+NULL\tNULL\n+\n+query II\n+SELECT x.col1, y.col1 FROM tbl_l_null x JOIN tbl_l_null y\n+ON x.col0 = y.col0 AND x.col1 = y.col1\n+ORDER BY x.col1;\n+----\n+[0]\t[0]\n+[1]\t[1]\n+[NULL]\t[NULL]\n",
  "problem_statement": "Join bug using DISTINCT FROM condition\n### What happens?\r\n\r\nA query using a `join` with a `distinct from` clause produces incorrect results. It looks like this happens only when there are at least 2 join conditions, and one of them uses `distinct from`.\r\n\r\n[Link to Discord discussion](https://discord.com/channels/909674491309850675/1032659480539824208/1131907371095048202).\r\n\r\n### To Reproduce\r\n\r\nThis query produces incorrect results:\r\n\r\n```sql\r\nWITH abc as (\r\n  SELECT * FROM (\r\n    values\r\n    (1, 'x'),\r\n    (1, 'x'), \r\n    (1, '0'), \r\n    (1, '0')\r\n    )\r\n)\r\nSELECT\r\n  x.col0 as c1\r\n  , x.col1 as c2\r\n  , y.col0 as c3\r\n  , y.col1 as c4\r\nFROM abc x\r\nJOIN abc y\r\nON x.col0 = y.col0\r\nAND (x.col1 IS DISTINCT FROM y.col1)\r\n```\r\n\r\nIf I remove the first join condition, it produces correct results:\r\n\r\n```sql\r\nWITH abc as (\r\n  SELECT * FROM (\r\n    values\r\n    (1, 'x'),\r\n    (1, 'x'), \r\n    (1, '0'), \r\n    (1, '0')\r\n    )\r\n)\r\nSELECT\r\n  x.col0 as c1\r\n  , x.col1 as c2\r\n  , y.col0 as c3\r\n  , y.col1 as c4\r\nFROM abc x\r\nJOIN abc y\r\nON (x.col1 IS DISTINCT FROM y.col1)\r\n```\r\n\r\nThe \"X\"s and \"O\"s should NOT line up in the results.\r\n\r\n### OS:\r\n\r\niOS arm64\r\n\r\n### DuckDB Version:\r\n\r\n0.8.1\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nCarlin Eng\r\n\r\n### Affiliation:\r\n\r\nGoogle\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-09-18T12:56:25Z"
}