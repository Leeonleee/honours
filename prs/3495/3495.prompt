You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
R - support structs
#### What happens?

R package does not support structs.

Like #2734 and #3132 - should be fairly easy to add. Will try when I have some time.

#### To Reproduce

```sql
SELECT struct_pack(i := 4, s := 'string')
```

fails with: Error: duckdb_prepare_R: Unknown column type for prepare: STRUCT<i: INTEGER, s: VARCHAR>

#### Environment (please complete the following information):
 - OS: Windows 10
 - DuckDB Version: 0.3.2
 - DuckDB Client: R

#### Before Submitting

- [ ] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [X] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of tools/rpkg/DESCRIPTION]
1: Package: duckdb
2: Title: DBI Package for the DuckDB Database Management System
3: Version: 0.4.0
4: Authors@R:
5:     c(person(given = "Hannes",
6:              family = "MÃ¼hleisen",
7:              role = c("aut", "cre"),
8:              email = "hannes@cwi.nl",
9:              comment = c(ORCID = "0000-0001-8552-0029")),
10:       person(given = "Mark",
11:              family = "Raasveldt",
12:              role = "aut",
13:              email = "mark.raasveldt@cwi.nl",
14:              comment = c(ORCID = "0000-0001-5005-6844")),
15:       person("Stichting DuckDB Foundation", role = "cph"),
16:       person("Apache Software Foundation", role = "cph"),
17:       person("PostgreSQL Global Development Group", role = "cph"),
18:       person("The Regents of the University of California", role = "cph"),
19:       person("Cameron Desrochers", role = "cph"),
20:       person("Victor Zverovich", role = "cph"),
21:       person("RAD Game Tools", role = "cph"),
22:       person("Valve Software", role = "cph"),
23:       person("Rich Geldreich", role = "cph"),
24:       person("Tenacious Software LLC", role = "cph"),
25:       person("The RE2 Authors", role = "cph"),
26:       person("Google Inc.", role = "cph"),
27:       person("Facebook Inc.", role = "cph"),
28:       person("Steven G. Johnson", role = "cph"),
29:       person("Jiahao Chen", role = "cph"),
30:       person("Tony Kelman", role = "cph"),
31:       person("Jonas Fonseca", role = "cph"),
32:       person("Lukas Fittl", role = "cph"),
33:       person("Salvatore Sanfilippo", role = "cph"),
34:       person("Art.sy, Inc.", role = "cph"),
35:       person("Oran Agra", role = "cph"),
36:       person("Redis Labs, Inc.", role = "cph"),
37:       person("Melissa O'Neill", role = "cph"),
38:       person("PCG Project contributors", role = "cph"))
39: Description: The DuckDB project is an embedded analytical data
40:     management system with support for the Structured Query Language (SQL). This package includes all of
41:     DuckDB and a R Database Interface (DBI) connector.
42: License: MIT + file LICENSE
43: URL: https://duckdb.org/, https://github.com/duckdb/duckdb
44: BugReports: https://github.com/duckdb/duckdb/issues
45: Depends:
46:     DBI,
47:     R (>= 3.6.0)
48: Imports:
49:     methods,
50:     utils
51: Suggests:
52:     arrow,
53:     callr,
54:     DBItest,
55:     dplyr,
56:     dbplyr,
57:     nycflights13,
58:     testthat,
59:     withr
60: Encoding: UTF-8
61: Roxygen: list(markdown = TRUE)
62: RoxygenNote: 7.1.2
63: SystemRequirements: C++11, GCC on Solaris
[end of tools/rpkg/DESCRIPTION]
[start of tools/rpkg/R/Result.R]
1: #' DuckDB Result Set
2: #'
3: #' Methods for accessing result sets for queries on DuckDB connections.
4: #' Implements \linkS4class{DBIResult}.
5: #'
6: #' @aliases duckdb_result
7: #' @keywords internal
8: #' @export
9: setClass("duckdb_result",
10:   contains = "DBIResult",
11:   slots = list(
12:     connection = "duckdb_connection",
13:     stmt_lst = "list",
14:     env = "environment",
15:     arrow = "logical",
16:     query_result = "externalptr"
17:   )
18: )
19: 
20: duckdb_result <- function(connection, stmt_lst, arrow) {
21:   env <- new.env(parent = emptyenv())
22:   env$rows_fetched <- 0
23:   env$open <- TRUE
24:   env$rows_affected <- 0
25: 
26:   res <- new("duckdb_result", connection = connection, stmt_lst = stmt_lst, env = env, arrow = arrow)
27: 
28:   if (stmt_lst$n_param == 0) {
29:     if (arrow) {
30:       query_result <- duckdb_execute(res)
31:       new_res <- new("duckdb_result", connection = connection, stmt_lst = stmt_lst, env = env, arrow = arrow, query_result = query_result)
32:       return(new_res)
33:     } else {
34:       duckdb_execute(res)
35:     }
36:   }
37: 
38: 
39:   return(res)
40: }
41: 
42: duckdb_execute <- function(res) {
43:   out <- rapi_execute(res@stmt_lst$ref, res@arrow)
44:   duckdb_post_execute(res, out)
45: }
46: 
47: duckdb_post_execute <- function(res, out) {
48:   if (!res@arrow) {
49:     out <- list_to_df(out)
50: 
51:     if (!res@stmt_lst$type %in% c("SELECT", "EXPLAIN")) {
52:       res@env$rows_affected <- sum(as.numeric(out[[1]]))
53:     }
54: 
55:     res@env$resultset <- out
56:   }
57: 
58:   out
59: }
60: 
61: list_to_df <- function(x) {
62:   if (is.data.frame(x)) {
63:     return(x)
64:   }
65:   attr(x, "row.names") <- c(NA_integer_, -length(x[[1]]))
66:   class(x) <- c( "data.frame")
67:   x
68: }
69: 
70: # as per is.integer documentation
71: is_wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - round(x)) < tol
72: 
73: fix_rownames <- function(df) {
74:   attr(df, "row.names") <- c(NA, as.integer(-nrow(df)))
75:   return(df)
76: }
77: 
78: #' @rdname duckdb_result-class
79: #' @param res Query result to be converted to an Arrow Table
80: #' @param chunk_size The chunk size
81: #' @export
82: duckdb_fetch_arrow <- function(res, chunk_size = 1000000) {
83:   if (chunk_size <= 0) {
84:     stop("Chunk Size must be higher than 0")
85:   }
86:   rapi_execute_arrow(res@query_result, chunk_size)
87: }
88: 
89: #' @rdname duckdb_result-class
90: #' @param res Query result to be converted to a Record Batch Reader
91: #' @param chunk_size The chunk size
92: #' @export
93: duckdb_fetch_record_batch <- function(res, chunk_size = 1000000) {
94:   if (chunk_size <= 0) {
95:     stop("Chunk Size must be higher than 0")
96:   }
97:   rapi_record_batch(res@query_result, chunk_size)
98: }
99: 
100: set_output_tz <- function(x, timezone, convert) {
101:   if (timezone == "UTC") {
102:     return(x)
103:   }
104: 
105:   tz_convert <- switch(convert,
106:     with = tz_convert,
107:     force = tz_force
108:   )
109: 
110:   is_datetime <- which(vapply(x, inherits, "POSIXt", FUN.VALUE = logical(1)))
111: 
112:   if (length(is_datetime) > 0) {
113:     x[is_datetime] <- lapply(x[is_datetime], tz_convert, timezone)
114:   }
115:   x
116: }
117: 
118: tz_convert <- function(x, timezone) {
119:   attr(x, "tzone") <- timezone
120:   x
121: }
122: 
123: tz_force <- function(x, timezone) {
124:   # convert to character, stripping the timezone
125:   ct <- as.character(x, usetz = FALSE)
126:   # recreate the POSIXct with specified timezone
127:   as.POSIXct(ct, tz = timezone)
128: }
[end of tools/rpkg/R/Result.R]
[start of tools/rpkg/R/dbBind__duckdb_result.R]
1: #' @rdname duckdb_result-class
2: #' @inheritParams DBI::dbBind
3: #' @usage NULL
4: dbBind__duckdb_result <- function(res, params, ...) {
5:   if (!res@env$open) {
6:     stop("result has already been cleared")
7:   }
8:   res@env$rows_fetched <- 0
9:   res@env$resultset <- data.frame()
10: 
11:   params <- as.list(params)
12:   if (!is.null(names(params))) {
13:     stop("`params` must not be named")
14:   }
15: 
16:   params <- encode_values(params)
17: 
18:   out <- rapi_bind(res@stmt_lst$ref, params, res@arrow)
19:   if (length(out) == 1) {
20:     out <- out[[1]]
21:   } else if (length(out) == 0) {
22:     out <- data.frame()
23:   } else {
24:     out <- do.call(rbind, lapply(out, list_to_df))
25:   }
26:   duckdb_post_execute(res, out)
27:   invisible(res)
28: }
29: 
30: #' @rdname duckdb_result-class
31: #' @export
32: setMethod("dbBind", "duckdb_result", dbBind__duckdb_result)
[end of tools/rpkg/R/dbBind__duckdb_result.R]
[start of tools/rpkg/R/dbFetch__duckdb_result.R]
1: #' @rdname duckdb_result-class
2: #' @inheritParams DBI::dbFetch
3: #' @importFrom utils head
4: #' @usage NULL
5: dbFetch__duckdb_result <- function(res, n = -1, ...) {
6:   if (!res@env$open) {
7:     stop("result set was closed")
8:   }
9:   if (is.null(res@env$resultset)) {
10:     stop("Need to call `dbBind()` before `dbFetch()`")
11:   }
12:   if (res@stmt_lst$type == "EXPLAIN") {
13:     df <- res@env$resultset
14:     attr(df, "query") <- res@stmt_lst$str
15:     class(df) <- c("duckdb_explain", class(df))
16:     return(df)
17:   }
18:   if (length(n) != 1) {
19:     stop("need exactly one value in n")
20:   }
21:   if (is.infinite(n)) {
22:     n <- -1
23:   }
24:   if (n < -1) {
25:     stop("cannot fetch negative n other than -1")
26:   }
27:   if (!is_wholenumber(n)) {
28:     stop("n needs to be not a whole number")
29:   }
30:   if (res@stmt_lst$type != "SELECT") {
31:     warning("Should not call dbFetch() on results that do not come from SELECT")
32:     return(data.frame())
33:   }
34: 
35:   if (res@arrow) {
36:     stop("Cannot dbFetch() an Arrow result")
37:   }
38: 
39:   timezone_out <- res@connection@timezone_out
40:   tz_out_convert <- res@connection@tz_out_convert
41: 
42:   # FIXME this is ugly
43:   if (n == 0) {
44:     return(utils::head(res@env$resultset, 0))
45:   }
46:   if (res@env$rows_fetched < 0) {
47:     res@env$rows_fetched <- 0
48:   }
49:   if (res@env$rows_fetched >= nrow(res@env$resultset)) {
50:     df <- fix_rownames(res@env$resultset[F, , drop = F])
51:     df <- set_output_tz(df, timezone_out, tz_out_convert)
52:     return(df)
53:   }
54:   # special case, return everything
55:   if (n == -1 && res@env$rows_fetched == 0) {
56:     res@env$rows_fetched <- nrow(res@env$resultset)
57:     df <- res@env$resultset
58:     df <- set_output_tz(df, timezone_out, tz_out_convert)
59:     return(df)
60:   }
61:   if (n > -1) {
62:     n <- min(n, nrow(res@env$resultset) - res@env$rows_fetched)
63:     res@env$rows_fetched <- res@env$rows_fetched + n
64:     df <- res@env$resultset[(res@env$rows_fetched - n + 1):(res@env$rows_fetched), , drop = F]
65:     df <- set_output_tz(df, timezone_out, tz_out_convert)
66:     return(fix_rownames(df))
67:   }
68:   start <- res@env$rows_fetched + 1
69:   res@env$rows_fetched <- nrow(res@env$resultset)
70:   df <- res@env$resultset[nrow(res@env$resultset), , drop = F]
71: 
72:   df <- set_output_tz(df, timezone_out, tz_out_convert)
73:   return(fix_rownames(df))
74: }
75: 
76: #' @rdname duckdb_result-class
77: #' @export
78: setMethod("dbFetch", "duckdb_result", dbFetch__duckdb_result)
[end of tools/rpkg/R/dbFetch__duckdb_result.R]
[start of tools/rpkg/src/include/rapi.hpp]
1: #pragma once
2: 
3: #include "cpp11.hpp"
4: 
5: #include <Rdefines.h>
6: #include <R_ext/Altrep.h>
7: 
8: #include "duckdb.hpp"
9: #include "duckdb/function/table_function.hpp"
10: #include "duckdb/common/unordered_map.hpp"
11: #include "duckdb/parser/tableref/table_function_ref.hpp"
12: #include "duckdb/common/mutex.hpp"
13: 
14: namespace duckdb {
15: 
16: typedef unordered_map<std::string, SEXP> arrow_scans_t;
17: 
18: struct DBWrapper {
19: 	unique_ptr<DuckDB> db;
20: 	arrow_scans_t arrow_scans;
21: 	mutex lock;
22: };
23: 
24: void DBDeleter(DBWrapper *);
25: typedef cpp11::external_pointer<DBWrapper, DBDeleter> db_eptr_t;
26: 
27: struct ConnWrapper {
28: 	unique_ptr<Connection> conn;
29: 	db_eptr_t db_eptr;
30: };
31: 
32: void ConnDeleter(ConnWrapper *);
33: typedef cpp11::external_pointer<ConnWrapper, ConnDeleter> conn_eptr_t;
34: 
35: struct RStatement {
36: 	unique_ptr<PreparedStatement> stmt;
37: 	vector<Value> parameters;
38: };
39: 
40: struct RelationWrapper {
41: 	RelationWrapper(std::shared_ptr<Relation> rel_p) : rel(move(rel_p)) {
42: 	}
43: 	shared_ptr<Relation> rel;
44: };
45: 
46: typedef cpp11::external_pointer<ParsedExpression> expr_extptr_t;
47: typedef cpp11::external_pointer<RelationWrapper> rel_extptr_t;
48: 
49: typedef cpp11::external_pointer<RStatement> stmt_eptr_t;
50: 
51: struct RQueryResult {
52: 	unique_ptr<QueryResult> result;
53: };
54: 
55: typedef cpp11::external_pointer<RQueryResult> rqry_eptr_t;
56: 
57: // internal
58: unique_ptr<TableFunctionRef> ArrowScanReplacement(ClientContext &context, const std::string &table_name,
59:                                                   ReplacementScanData *data);
60: 
61: struct ArrowScanReplacementData : public ReplacementScanData {
62: 	DBWrapper *wrapper;
63: };
64: 
65: SEXP StringsToSexp(vector<std::string> s);
66: 
67: SEXP ToUtf8(SEXP string_sexp);
68: 
69: struct RProtector {
70: 	RProtector() : protect_count(0) {
71: 	}
72: 	~RProtector() {
73: 		if (protect_count > 0) {
74: 			UNPROTECT(protect_count);
75: 		}
76: 	}
77: 
78: 	SEXP Protect(SEXP sexp) {
79: 		protect_count++;
80: 		return PROTECT(sexp);
81: 	}
82: 
83: private:
84: 	int protect_count;
85: };
86: 
87: struct DataFrameScanFunction : public TableFunction {
88: 	DataFrameScanFunction();
89: };
90: 
91: struct RStrings {
92: 	SEXP secs; // Rf_mkChar
93: 	SEXP mins;
94: 	SEXP hours;
95: 	SEXP days;
96: 	SEXP weeks;
97: 	SEXP POSIXct;
98: 	SEXP POSIXt;
99: 	SEXP UTC_str; // Rf_mkString
100: 	SEXP Date_str;
101: 	SEXP factor_str;
102: 	SEXP difftime_str;
103: 	SEXP secs_str;
104: 	SEXP arrow_str; // StringsToSexp
105: 	SEXP POSIXct_POSIXt_str;
106: 	SEXP enc2utf8_sym; // Rf_install
107: 	SEXP tzone_sym;
108: 	SEXP units_sym;
109: 	SEXP getNamespace_sym;
110: 	SEXP Table__from_record_batches_sym;
111: 	SEXP ImportSchema_sym;
112: 	SEXP ImportRecordBatch_sym;
113: 	SEXP ImportRecordBatchReader_sym;
114: 
115: 	static const RStrings &get() {
116: 		// On demand
117: 		static RStrings strings;
118: 		return strings;
119: 	}
120: 
121: private:
122: 	RStrings();
123: };
124: 
125: SEXP duckdb_execute_R_impl(MaterializedQueryResult *result);
126: 
127: } // namespace duckdb
128: 
129: // moved out of duckdb namespace for the time being (r-lib/cpp11#262)
130: 
131: duckdb::db_eptr_t rapi_startup(std::string, bool, cpp11::list);
132: 
133: void rapi_shutdown(duckdb::db_eptr_t);
134: 
135: duckdb::conn_eptr_t rapi_connect(duckdb::db_eptr_t);
136: 
137: void rapi_disconnect(duckdb::conn_eptr_t);
138: 
139: cpp11::list rapi_prepare(duckdb::conn_eptr_t, std::string);
140: 
141: cpp11::list rapi_bind(duckdb::stmt_eptr_t, SEXP paramsexp, bool);
142: 
143: SEXP rapi_execute(duckdb::stmt_eptr_t, bool);
144: 
145: void rapi_release(duckdb::stmt_eptr_t);
146: 
147: void rapi_register_df(duckdb::conn_eptr_t, std::string, cpp11::data_frame);
148: 
149: void rapi_unregister_df(duckdb::conn_eptr_t, std::string);
150: 
151: void rapi_register_arrow(duckdb::conn_eptr_t, SEXP namesexp, SEXP export_funsexp, SEXP valuesexp);
152: 
153: void rapi_unregister_arrow(duckdb::conn_eptr_t, SEXP namesexp);
154: 
155: SEXP rapi_execute_arrow(duckdb::rqry_eptr_t, int);
156: 
157: SEXP rapi_record_batch(duckdb::rqry_eptr_t, int);
158: 
159: cpp11::r_string rapi_ptr_to_str(SEXP extptr);
[end of tools/rpkg/src/include/rapi.hpp]
[start of tools/rpkg/src/statement.cpp]
1: #include "rapi.hpp"
2: #include "typesr.hpp"
3: #include "altrepstring.hpp"
4: 
5: #include <R_ext/Utils.h>
6: 
7: #include "duckdb/common/arrow.hpp"
8: #include "duckdb/common/types/timestamp.hpp"
9: #include "duckdb/common/arrow_wrapper.hpp"
10: #include "duckdb/common/result_arrow_wrapper.hpp"
11: #include "duckdb/main/stream_query_result.hpp"
12: 
13: using namespace duckdb;
14: using namespace cpp11::literals;
15: 
16: // converter for primitive types
17: template <class SRC, class DEST>
18: static void VectorToR(Vector &src_vec, size_t count, void *dest, uint64_t dest_offset, DEST na_val) {
19: 	auto src_ptr = FlatVector::GetData<SRC>(src_vec);
20: 	auto &mask = FlatVector::Validity(src_vec);
21: 	auto dest_ptr = ((DEST *)dest) + dest_offset;
22: 	for (size_t row_idx = 0; row_idx < count; row_idx++) {
23: 		dest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? na_val : src_ptr[row_idx];
24: 	}
25: }
26: 
27: [[cpp11::register]] void rapi_release(duckdb::stmt_eptr_t stmt) {
28: 	auto stmt_ptr = stmt.release();
29: 	if (stmt_ptr) {
30: 		delete stmt_ptr;
31: 	}
32: }
33: 
34: [[cpp11::register]] cpp11::list rapi_prepare(duckdb::conn_eptr_t conn, std::string query) {
35: 	if (!conn || !conn->conn) {
36: 		cpp11::stop("rapi_prepare: Invalid connection");
37: 	}
38: 
39: 	auto statements = conn->conn->ExtractStatements(query.c_str());
40: 	if (statements.empty()) {
41: 		// no statements to execute
42: 		cpp11::stop("rapi_prepare: No statements to execute");
43: 	}
44: 	// if there are multiple statements, we directly execute the statements besides the last one
45: 	// we only return the result of the last statement to the user, unless one of the previous statements fails
46: 	for (idx_t i = 0; i + 1 < statements.size(); i++) {
47: 		auto res = conn->conn->Query(move(statements[i]));
48: 		if (!res->success) {
49: 			cpp11::stop("rapi_prepare: Failed to execute statement %s\nError: %s", query.c_str(), res->error.c_str());
50: 		}
51: 	}
52: 	auto stmt = conn->conn->Prepare(move(statements.back()));
53: 	if (!stmt->success) {
54: 		cpp11::stop("rapi_prepare: Failed to prepare query %s\nError: %s", query.c_str(), stmt->error.c_str());
55: 	}
56: 
57: 	cpp11::writable::list retlist;
58: 	retlist.reserve(6);
59: 	retlist.push_back({"str"_nm = query});
60: 
61: 	auto stmtholder = new RStatement();
62: 	stmtholder->stmt = move(stmt);
63: 
64: 	retlist.push_back({"ref"_nm = stmt_eptr_t(stmtholder)});
65: 	retlist.push_back({"type"_nm = StatementTypeToString(stmtholder->stmt->GetStatementType())});
66: 	retlist.push_back({"names"_nm = cpp11::as_sexp(stmtholder->stmt->GetNames())});
67: 
68: 	cpp11::writable::strings rtypes;
69: 
70: 	for (auto &stype : stmtholder->stmt->GetTypes()) {
71: 		string rtype = "";
72: 		switch (stype.id()) {
73: 		case LogicalTypeId::BOOLEAN:
74: 			rtype = "logical";
75: 			break;
76: 		case LogicalTypeId::UTINYINT:
77: 		case LogicalTypeId::TINYINT:
78: 		case LogicalTypeId::USMALLINT:
79: 		case LogicalTypeId::SMALLINT:
80: 		case LogicalTypeId::INTEGER:
81: 			rtype = "integer";
82: 			break;
83: 		case LogicalTypeId::TIMESTAMP_SEC:
84: 		case LogicalTypeId::TIMESTAMP_MS:
85: 		case LogicalTypeId::TIMESTAMP:
86: 		case LogicalTypeId::TIMESTAMP_TZ:
87: 		case LogicalTypeId::TIMESTAMP_NS:
88: 			rtype = "POSIXct";
89: 			break;
90: 		case LogicalTypeId::DATE:
91: 			rtype = "Date";
92: 			break;
93: 		case LogicalTypeId::TIME:
94: 			rtype = "difftime";
95: 			break;
96: 		case LogicalTypeId::UINTEGER:
97: 		case LogicalTypeId::UBIGINT:
98: 		case LogicalTypeId::BIGINT:
99: 		case LogicalTypeId::HUGEINT:
100: 		case LogicalTypeId::FLOAT:
101: 		case LogicalTypeId::DOUBLE:
102: 		case LogicalTypeId::DECIMAL:
103: 			rtype = "numeric";
104: 			break;
105: 		case LogicalTypeId::VARCHAR:
106: 			rtype = "character";
107: 			break;
108: 		case LogicalTypeId::BLOB:
109: 			rtype = "raw";
110: 			break;
111: 		case LogicalTypeId::LIST:
112: 			rtype = "list";
113: 			break;
114: 		case LogicalTypeId::ENUM:
115: 			rtype = "factor";
116: 			break;
117: 		case LogicalTypeId::UNKNOWN:
118: 			rtype = "unknown";
119: 			break;
120: 		default:
121: 			cpp11::stop("rapi_prepare: Unknown column type for prepare: %s", stype.ToString().c_str());
122: 			break;
123: 		}
124: 		rtypes.push_back(rtype);
125: 	}
126: 
127: 	retlist.push_back({"rtypes"_nm = rtypes});
128: 	retlist.push_back({"n_param"_nm = stmtholder->stmt->n_param});
129: 
130: 	return retlist;
131: }
132: 
133: [[cpp11::register]] cpp11::list rapi_bind(duckdb::stmt_eptr_t stmt, cpp11::list params, bool arrow) {
134: 	if (!stmt || !stmt->stmt) {
135: 		cpp11::stop("rapi_bind: Invalid statement");
136: 	}
137: 
138: 	stmt->parameters.clear();
139: 	stmt->parameters.resize(stmt->stmt->n_param);
140: 
141: 	if (stmt->stmt->n_param == 0) {
142: 		cpp11::stop("rapi_bind: dbBind called but query takes no parameters");
143: 	}
144: 
145: 	if (params.size() != stmt->stmt->n_param) {
146: 		cpp11::stop("rapi_bind: Bind parameters need to be a list of length %i", stmt->stmt->n_param);
147: 	}
148: 
149: 	R_len_t n_rows = Rf_length(params[0]);
150: 
151: 	for (auto param = std::next(params.begin()); param != params.end(); ++param) {
152: 		if (Rf_length(*param) != n_rows) {
153: 			cpp11::stop("rapi_bind: Bind parameter values need to have the same length");
154: 		}
155: 	}
156: 
157: 	if (n_rows != 1 && arrow) {
158: 		cpp11::stop("rapi_bind: Bind parameter values need to have length one for arrow queries");
159: 	}
160: 
161: 	cpp11::writable::list out;
162: 	out.reserve(n_rows);
163: 
164: 	for (idx_t row_idx = 0; row_idx < (size_t)n_rows; ++row_idx) {
165: 		for (idx_t param_idx = 0; param_idx < (idx_t)params.size(); param_idx++) {
166: 			SEXP valsexp = params[(size_t)param_idx];
167: 			auto val = RApiTypes::SexpToValue(valsexp, row_idx);
168: 			stmt->parameters[param_idx] = val;
169: 		}
170: 
171: 		// No protection, assigned immediately
172: 		out.push_back(rapi_execute(stmt, arrow));
173: 	}
174: 
175: 	return out;
176: }
177: 
178: static SEXP allocate(const LogicalType &type, RProtector &r_varvalue, idx_t nrows) {
179: 	SEXP varvalue = NULL;
180: 	switch (type.id()) {
181: 	case LogicalTypeId::BOOLEAN:
182: 		varvalue = r_varvalue.Protect(NEW_LOGICAL(nrows));
183: 		break;
184: 	case LogicalTypeId::UTINYINT:
185: 	case LogicalTypeId::TINYINT:
186: 	case LogicalTypeId::SMALLINT:
187: 	case LogicalTypeId::USMALLINT:
188: 	case LogicalTypeId::INTEGER:
189: 		varvalue = r_varvalue.Protect(NEW_INTEGER(nrows));
190: 		break;
191: 	case LogicalTypeId::UINTEGER:
192: 	case LogicalTypeId::UBIGINT:
193: 	case LogicalTypeId::BIGINT:
194: 	case LogicalTypeId::HUGEINT:
195: 	case LogicalTypeId::FLOAT:
196: 	case LogicalTypeId::DOUBLE:
197: 	case LogicalTypeId::DECIMAL:
198: 	case LogicalTypeId::TIMESTAMP_SEC:
199: 	case LogicalTypeId::TIMESTAMP_MS:
200: 	case LogicalTypeId::TIMESTAMP:
201: 	case LogicalTypeId::TIMESTAMP_TZ:
202: 	case LogicalTypeId::TIMESTAMP_NS:
203: 	case LogicalTypeId::DATE:
204: 	case LogicalTypeId::TIME:
205: 		varvalue = r_varvalue.Protect(NEW_NUMERIC(nrows));
206: 		break;
207: 	case LogicalTypeId::LIST:
208: 		varvalue = r_varvalue.Protect(NEW_LIST(nrows));
209: 		break;
210: 	case LogicalTypeId::VARCHAR: {
211: 		auto wrapper = new DuckDBAltrepStringWrapper();
212: 		wrapper->length = nrows;
213: 
214: 		cpp11::external_pointer<DuckDBAltrepStringWrapper> ptr(wrapper);
215: 		varvalue = r_varvalue.Protect(R_new_altrep(AltrepString::rclass, ptr, R_NilValue));
216: 		break;
217: 	}
218: 
219: 	case LogicalTypeId::BLOB:
220: 		varvalue = r_varvalue.Protect(NEW_LIST(nrows));
221: 		break;
222: 	case LogicalTypeId::ENUM: {
223: 		auto physical_type = type.InternalType();
224: 		if (physical_type == PhysicalType::UINT64) { // DEDUP_POINTER_ENUM
225: 			varvalue = r_varvalue.Protect(NEW_STRING(nrows));
226: 		} else {
227: 			varvalue = r_varvalue.Protect(NEW_INTEGER(nrows));
228: 		}
229: 		break;
230: 	}
231: 	default:
232: 		cpp11::stop("rapi_execute: Unknown column type for execute: %s", type.ToString().c_str());
233: 	}
234: 	if (!varvalue) {
235: 		throw std::bad_alloc();
236: 	}
237: 	return varvalue;
238: }
239: 
240: // Convert DuckDB's timestamp to R's timestamp (POSIXct). This is a represented as the number of seconds since the
241: // epoch, stored as a double.
242: template <LogicalTypeId>
243: double ConvertTimestampValue(int64_t timestamp);
244: 
245: template <>
246: double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_SEC>(int64_t timestamp) {
247: 	return static_cast<double>(timestamp);
248: }
249: 
250: template <>
251: double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_MS>(int64_t timestamp) {
252: 	return static_cast<double>(timestamp) / Interval::MSECS_PER_SEC;
253: }
254: 
255: template <>
256: double ConvertTimestampValue<LogicalTypeId::TIMESTAMP>(int64_t timestamp) {
257: 	return static_cast<double>(timestamp) / Interval::MICROS_PER_SEC;
258: }
259: 
260: template <>
261: double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_TZ>(int64_t timestamp) {
262: 	return ConvertTimestampValue<LogicalTypeId::TIMESTAMP>(timestamp);
263: }
264: 
265: template <>
266: double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_NS>(int64_t timestamp) {
267: 	return static_cast<double>(timestamp) / Interval::NANOS_PER_SEC;
268: }
269: 
270: template <LogicalTypeId LT>
271: void ConvertTimestampVector(Vector &src_vec, size_t count, SEXP &dest, uint64_t dest_offset) {
272: 	auto src_data = FlatVector::GetData<int64_t>(src_vec);
273: 	auto &mask = FlatVector::Validity(src_vec);
274: 	double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
275: 	for (size_t row_idx = 0; row_idx < count; row_idx++) {
276: 		dest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? NA_REAL : ConvertTimestampValue<LT>(src_data[row_idx]);
277: 	}
278: 
279: 	// some dresssup for R
280: 	SET_CLASS(dest, RStrings::get().POSIXct_POSIXt_str);
281: 	Rf_setAttrib(dest, RStrings::get().tzone_sym, RStrings::get().UTC_str);
282: }
283: 
284: std::once_flag nanosecond_coercion_warning;
285: 
286: static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n) {
287: 	switch (src_vec.GetType().id()) {
288: 	case LogicalTypeId::BOOLEAN:
289: 		VectorToR<int8_t, uint32_t>(src_vec, n, LOGICAL_POINTER(dest), dest_offset, NA_LOGICAL);
290: 		break;
291: 	case LogicalTypeId::UTINYINT:
292: 		VectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
293: 		break;
294: 	case LogicalTypeId::TINYINT:
295: 		VectorToR<int8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
296: 		break;
297: 	case LogicalTypeId::USMALLINT:
298: 		VectorToR<uint16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
299: 		break;
300: 	case LogicalTypeId::SMALLINT:
301: 		VectorToR<int16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
302: 		break;
303: 	case LogicalTypeId::INTEGER:
304: 		VectorToR<int32_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
305: 		break;
306: 	case LogicalTypeId::TIMESTAMP_SEC:
307: 		ConvertTimestampVector<LogicalTypeId::TIMESTAMP_SEC>(src_vec, n, dest, dest_offset);
308: 		break;
309: 	case LogicalTypeId::TIMESTAMP_MS:
310: 		ConvertTimestampVector<LogicalTypeId::TIMESTAMP_MS>(src_vec, n, dest, dest_offset);
311: 		break;
312: 	case LogicalTypeId::TIMESTAMP:
313: 		ConvertTimestampVector<LogicalTypeId::TIMESTAMP>(src_vec, n, dest, dest_offset);
314: 		break;
315: 	case LogicalTypeId::TIMESTAMP_TZ:
316: 		ConvertTimestampVector<LogicalTypeId::TIMESTAMP_TZ>(src_vec, n, dest, dest_offset);
317: 		break;
318: 	case LogicalTypeId::TIMESTAMP_NS:
319: 		ConvertTimestampVector<LogicalTypeId::TIMESTAMP_NS>(src_vec, n, dest, dest_offset);
320: 		std::call_once(nanosecond_coercion_warning, Rf_warning,
321: 		               "Coercing nanoseconds to a lower resolution may result in a loss of data.");
322: 		break;
323: 	case LogicalTypeId::DATE: {
324: 		auto src_data = FlatVector::GetData<date_t>(src_vec);
325: 		auto &mask = FlatVector::Validity(src_vec);
326: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
327: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
328: 			dest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? NA_REAL : (double)int32_t(src_data[row_idx]);
329: 		}
330: 
331: 		// some dresssup for R
332: 		SET_CLASS(dest, RStrings::get().Date_str);
333: 		break;
334: 	}
335: 	case LogicalTypeId::TIME: {
336: 		auto src_data = FlatVector::GetData<dtime_t>(src_vec);
337: 		auto &mask = FlatVector::Validity(src_vec);
338: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
339: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
340: 			if (!mask.RowIsValid(row_idx)) {
341: 				dest_ptr[row_idx] = NA_REAL;
342: 			} else {
343: 				dtime_t n = src_data[row_idx];
344: 				dest_ptr[row_idx] = n.micros / Interval::MICROS_PER_SEC;
345: 			}
346: 		}
347: 
348: 		// some dress-up for R
349: 		SET_CLASS(dest, RStrings::get().difftime_str);
350: 		Rf_setAttrib(dest, RStrings::get().units_sym, RStrings::get().secs_str);
351: 		break;
352: 	}
353: 	case LogicalTypeId::UINTEGER:
354: 		VectorToR<uint32_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
355: 		break;
356: 	case LogicalTypeId::UBIGINT:
357: 		VectorToR<uint64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
358: 		break;
359: 	case LogicalTypeId::BIGINT:
360: 		VectorToR<int64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
361: 		break;
362: 	case LogicalTypeId::HUGEINT: {
363: 		auto src_data = FlatVector::GetData<hugeint_t>(src_vec);
364: 		auto &mask = FlatVector::Validity(src_vec);
365: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
366: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
367: 			if (!mask.RowIsValid(row_idx)) {
368: 				dest_ptr[row_idx] = NA_REAL;
369: 			} else {
370: 				Hugeint::TryCast(src_data[row_idx], dest_ptr[row_idx]);
371: 			}
372: 		}
373: 		break;
374: 	}
375: 	case LogicalTypeId::DECIMAL: {
376: 		auto &decimal_type = src_vec.GetType();
377: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
378: 		auto dec_scale = DecimalType::GetScale(decimal_type);
379: 		switch (decimal_type.InternalType()) {
380: 		case PhysicalType::INT16:
381: 			RDecimalCastLoop<int16_t>(src_vec, n, dest_ptr, dec_scale);
382: 			break;
383: 		case PhysicalType::INT32:
384: 			RDecimalCastLoop<int32_t>(src_vec, n, dest_ptr, dec_scale);
385: 			break;
386: 		case PhysicalType::INT64:
387: 			RDecimalCastLoop<int64_t>(src_vec, n, dest_ptr, dec_scale);
388: 			break;
389: 		case PhysicalType::INT128:
390: 			RDecimalCastLoop<hugeint_t>(src_vec, n, dest_ptr, dec_scale);
391: 			break;
392: 		default:
393: 			throw NotImplementedException("Unimplemented internal type for DECIMAL");
394: 		}
395: 		break;
396: 	}
397: 	case LogicalTypeId::FLOAT:
398: 		VectorToR<float, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
399: 		break;
400: 
401: 	case LogicalTypeId::DOUBLE:
402: 		VectorToR<double, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
403: 		break;
404: 	case LogicalTypeId::VARCHAR: {
405: 		auto wrapper = (DuckDBAltrepStringWrapper *)R_ExternalPtrAddr(R_altrep_data1(dest));
406: 		wrapper->vectors.emplace_back(LogicalType::VARCHAR, nullptr);
407: 		wrapper->vectors.back().Reference(src_vec);
408: 		break;
409: 	}
410: 	case LogicalTypeId::LIST: {
411: 		// figure out the total and max element length of the list vector child
412: 		auto src_data = ListVector::GetData(src_vec);
413: 		auto &child_type = ListType::GetChildType(src_vec.GetType());
414: 		Vector child_vector(child_type, nullptr);
415: 
416: 		// actual loop over rows
417: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
418: 			if (!FlatVector::Validity(src_vec).RowIsValid(row_idx)) {
419: 				SET_ELEMENT(dest, dest_offset + row_idx, Rf_ScalarLogical(NA_LOGICAL));
420: 			} else {
421: 				child_vector.Slice(ListVector::GetEntry(src_vec), src_data[row_idx].offset);
422: 
423: 				RProtector ele_prot;
424: 				// transform the list child vector to a single R SEXP
425: 				auto list_element =
426: 				    allocate(ListType::GetChildType(src_vec.GetType()), ele_prot, src_data[row_idx].length);
427: 				transform(child_vector, list_element, 0, src_data[row_idx].length);
428: 
429: 				// call R's own extract subset method
430: 				SET_ELEMENT(dest, dest_offset + row_idx, list_element);
431: 			}
432: 		}
433: 		break;
434: 	}
435: 	case LogicalTypeId::BLOB: {
436: 		auto src_ptr = FlatVector::GetData<string_t>(src_vec);
437: 		auto &mask = FlatVector::Validity(src_vec);
438: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
439: 			if (!mask.RowIsValid(row_idx)) {
440: 				SET_VECTOR_ELT(dest, dest_offset + row_idx, Rf_ScalarLogical(NA_LOGICAL));
441: 			} else {
442: 				SEXP rawval = NEW_RAW(src_ptr[row_idx].GetSize());
443: 				if (!rawval) {
444: 					throw std::bad_alloc();
445: 				}
446: 				memcpy(RAW_POINTER(rawval), src_ptr[row_idx].GetDataUnsafe(), src_ptr[row_idx].GetSize());
447: 				SET_VECTOR_ELT(dest, dest_offset + row_idx, rawval);
448: 			}
449: 		}
450: 		break;
451: 	}
452: 	case LogicalTypeId::ENUM: {
453: 		auto physical_type = src_vec.GetType().InternalType();
454: 		auto dummy = NEW_STRING(1);
455: 		ptrdiff_t sexp_header_size = (data_ptr_t)DATAPTR(dummy) - (data_ptr_t)dummy; // don't tell anyone
456: 		if (physical_type == PhysicalType::UINT64) {                                 // DEDUP_POINTER_ENUM
457: 			auto src_ptr = FlatVector::GetData<uint64_t>(src_vec);
458: 			auto &mask = FlatVector::Validity(src_vec);
459: 			/* we have to use SET_STRING_ELT here because otherwise those SEXPs dont get referenced */
460: 			for (size_t row_idx = 0; row_idx < n; row_idx++) {
461: 				if (!mask.RowIsValid(row_idx)) {
462: 					SET_STRING_ELT(dest, dest_offset + row_idx, NA_STRING);
463: 				} else {
464: 					SET_STRING_ELT(dest, dest_offset + row_idx,
465: 					               (SEXP)((data_ptr_t)src_ptr[row_idx] - sexp_header_size));
466: 				}
467: 			}
468: 			break;
469: 		}
470: 
471: 		switch (physical_type) {
472: 		case PhysicalType::UINT8:
473: 			VectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
474: 			break;
475: 
476: 		case PhysicalType::UINT16:
477: 			VectorToR<uint16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
478: 			break;
479: 
480: 		case PhysicalType::UINT32:
481: 			VectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
482: 			break;
483: 
484: 		default:
485: 			cpp11::stop("rapi_execute: Unknown enum type for convert: %s", TypeIdToString(physical_type).c_str());
486: 		}
487: 		// increment by one cause R factor offsets start at 1
488: 		auto dest_ptr = ((int32_t *)INTEGER_POINTER(dest)) + dest_offset;
489: 		for (idx_t i = 0; i < n; i++) {
490: 			if (dest_ptr[i] == NA_INTEGER) {
491: 				continue;
492: 			}
493: 			dest_ptr[i]++;
494: 		}
495: 
496: 		auto &str_vec = EnumType::GetValuesInsertOrder(src_vec.GetType());
497: 		auto size = EnumType::GetSize(src_vec.GetType());
498: 		vector<string> str_c_vec(size);
499: 		for (idx_t i = 0; i < size; i++) {
500: 			str_c_vec[i] = str_vec.GetValue(i).ToString();
501: 		}
502: 
503: 		SET_LEVELS(dest, StringsToSexp(str_c_vec));
504: 		SET_CLASS(dest, RStrings::get().factor_str);
505: 		break;
506: 	}
507: 	default:
508: 		cpp11::stop("rapi_execute: Unknown column type for convert: %s", src_vec.GetType().ToString().c_str());
509: 		break;
510: 	}
511: }
512: 
513: SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result) {
514: 	// step 2: create result data frame and allocate columns
515: 	uint32_t ncols = result->types.size();
516: 	if (ncols == 0) {
517: 		return Rf_ScalarReal(0); // no need for protection because no allocation can happen afterwards
518: 	}
519: 
520: 	uint64_t nrows = result->collection.Count();
521: 	cpp11::list retlist(NEW_LIST(ncols));
522: 	SET_NAMES(retlist, StringsToSexp(result->names));
523: 
524: 	for (size_t col_idx = 0; col_idx < ncols; col_idx++) {
525: 		// TODO move the protector to allocate?
526: 		RProtector r_varvalue;
527: 		auto varvalue = allocate(result->types[col_idx], r_varvalue, nrows);
528: 		SET_VECTOR_ELT(retlist, col_idx, varvalue);
529: 	}
530: 
531: 	// at this point retlist is fully allocated and the only protected SEXP
532: 
533: 	// step 3: set values from chunks
534: 	uint64_t dest_offset = 0;
535: 	idx_t chunk_idx = 0;
536: 	while (true) {
537: 		auto chunk = result->Fetch();
538: 		if (!chunk || chunk->size() == 0) {
539: 			break;
540: 		}
541: 
542: 		D_ASSERT(chunk->ColumnCount() == ncols);
543: 		D_ASSERT(chunk->ColumnCount() == (idx_t)Rf_length(retlist));
544: 		for (size_t col_idx = 0; col_idx < chunk->ColumnCount(); col_idx++) {
545: 			SEXP dest = VECTOR_ELT(retlist, col_idx);
546: 			transform(chunk->data[col_idx], dest, dest_offset, chunk->size());
547: 		}
548: 		dest_offset += chunk->size();
549: 		chunk_idx++;
550: 	}
551: 
552: 	D_ASSERT(dest_offset == nrows);
553: 	return retlist;
554: }
555: 
556: struct AppendableRList {
557: 	AppendableRList() {
558: 		the_list = r.Protect(NEW_LIST(capacity));
559: 	}
560: 	void PrepAppend() {
561: 		if (size >= capacity) {
562: 			capacity = capacity * 2;
563: 			SEXP new_list = r.Protect(NEW_LIST(capacity));
564: 			D_ASSERT(new_list);
565: 			for (idx_t i = 0; i < size; i++) {
566: 				SET_VECTOR_ELT(new_list, i, VECTOR_ELT(the_list, i));
567: 			}
568: 			the_list = new_list;
569: 		}
570: 	}
571: 
572: 	void Append(SEXP val) {
573: 		D_ASSERT(size < capacity);
574: 		D_ASSERT(the_list != R_NilValue);
575: 		SET_VECTOR_ELT(the_list, size++, val);
576: 	}
577: 	SEXP the_list;
578: 	idx_t capacity = 1000;
579: 	idx_t size = 0;
580: 	RProtector r;
581: };
582: 
583: bool FetchArrowChunk(QueryResult *result, AppendableRList &batches_list, ArrowArray &arrow_data,
584:                      ArrowSchema &arrow_schema, SEXP batch_import_from_c, SEXP arrow_namespace, idx_t chunk_size) {
585: 
586: 	auto data_chunk = ArrowUtil::FetchChunk(result, chunk_size);
587: 	if (!data_chunk || data_chunk->size() == 0) {
588: 		return false;
589: 	}
590: 	string timezone_config = QueryResult::GetConfigTimezone(*result);
591: 	QueryResult::ToArrowSchema(&arrow_schema, result->types, result->names, timezone_config);
592: 	data_chunk->ToArrowArray(&arrow_data);
593: 	batches_list.PrepAppend();
594: 	batches_list.Append(cpp11::safe[Rf_eval](batch_import_from_c, arrow_namespace));
595: 	return true;
596: }
597: 
598: // Turn a DuckDB result set into an Arrow Table
599: [[cpp11::register]] SEXP rapi_execute_arrow(duckdb::rqry_eptr_t qry_res, int chunk_size) {
600: 	if (qry_res->result->type == QueryResultType::STREAM_RESULT) {
601: 		qry_res->result = ((StreamQueryResult *)qry_res->result.get())->Materialize();
602: 	}
603: 	auto result = qry_res->result.get();
604: 	// somewhat dark magic below
605: 	cpp11::function getNamespace = RStrings::get().getNamespace_sym;
606: 	cpp11::sexp arrow_namespace(getNamespace(RStrings::get().arrow_str));
607: 
608: 	// export schema setup
609: 	ArrowSchema arrow_schema;
610: 	cpp11::doubles schema_ptr_sexp(Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&arrow_schema))));
611: 	cpp11::sexp schema_import_from_c(Rf_lang2(RStrings::get().ImportSchema_sym, schema_ptr_sexp));
612: 
613: 	// export data setup
614: 	ArrowArray arrow_data;
615: 	cpp11::doubles data_ptr_sexp(Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&arrow_data))));
616: 	cpp11::sexp batch_import_from_c(Rf_lang3(RStrings::get().ImportRecordBatch_sym, data_ptr_sexp, schema_ptr_sexp));
617: 	// create data batches
618: 	AppendableRList batches_list;
619: 
620: 	while (FetchArrowChunk(result, batches_list, arrow_data, arrow_schema, batch_import_from_c, arrow_namespace,
621: 	                       chunk_size)) {
622: 	}
623: 
624: 	SET_LENGTH(batches_list.the_list, batches_list.size);
625: 	string timezone_config = QueryResult::GetConfigTimezone(*result);
626: 	QueryResult::ToArrowSchema(&arrow_schema, result->types, result->names, timezone_config);
627: 	cpp11::sexp schema_arrow_obj(cpp11::safe[Rf_eval](schema_import_from_c, arrow_namespace));
628: 
629: 	// create arrow::Table
630: 	cpp11::sexp from_record_batches(
631: 	    Rf_lang3(RStrings::get().Table__from_record_batches_sym, batches_list.the_list, schema_arrow_obj));
632: 	return cpp11::safe[Rf_eval](from_record_batches, arrow_namespace);
633: }
634: 
635: // Turn a DuckDB result set into an RecordBatchReader
636: [[cpp11::register]] SEXP rapi_record_batch(duckdb::rqry_eptr_t qry_res, int chunk_size) {
637: 	// somewhat dark magic below
638: 	cpp11::function getNamespace = RStrings::get().getNamespace_sym;
639: 	cpp11::sexp arrow_namespace(getNamespace(RStrings::get().arrow_str));
640: 
641: 	ResultArrowArrayStreamWrapper *result_stream = new ResultArrowArrayStreamWrapper(move(qry_res->result), chunk_size);
642: 	cpp11::sexp stream_ptr_sexp(
643: 	    Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&result_stream->stream))));
644: 	cpp11::sexp record_batch_reader(Rf_lang2(RStrings::get().ImportRecordBatchReader_sym, stream_ptr_sexp));
645: 	return cpp11::safe[Rf_eval](record_batch_reader, arrow_namespace);
646: }
647: 
648: [[cpp11::register]] SEXP rapi_execute(duckdb::stmt_eptr_t stmt, bool arrow) {
649: 	if (!stmt || !stmt->stmt) {
650: 		cpp11::stop("rapi_execute: Invalid statement");
651: 	}
652: 
653: 	auto pending_query = stmt->stmt->PendingQuery(stmt->parameters, arrow);
654: 	duckdb::PendingExecutionResult execution_result;
655: 	do {
656: 		execution_result = pending_query->ExecuteTask();
657: 		R_CheckUserInterrupt();
658: 	} while (execution_result == PendingExecutionResult::RESULT_NOT_READY);
659: 	if (execution_result == PendingExecutionResult::EXECUTION_ERROR) {
660: 		cpp11::stop("rapi_execute: Failed to run query\nError: %s", pending_query->error.c_str());
661: 	}
662: 	auto generic_result = pending_query->Execute();
663: 	if (!generic_result->success) {
664: 		cpp11::stop("rapi_execute: Failed to run query\nError: %s", generic_result->error.c_str());
665: 	}
666: 
667: 	if (arrow) {
668: 		auto query_result = new RQueryResult();
669: 		query_result->result = move(generic_result);
670: 		rqry_eptr_t query_resultsexp(query_result);
671: 		return query_resultsexp;
672: 	} else {
673: 		D_ASSERT(generic_result->type == QueryResultType::MATERIALIZED_RESULT);
674: 		MaterializedQueryResult *result = (MaterializedQueryResult *)generic_result.get();
675: 		return duckdb_execute_R_impl(result);
676: 	}
677: }
[end of tools/rpkg/src/statement.cpp]
[start of tools/rpkg/src/utils.cpp]
1: #include "rapi.hpp"
2: #include "typesr.hpp"
3: #include "duckdb/common/types/timestamp.hpp"
4: 
5: using namespace duckdb;
6: 
7: SEXP duckdb::ToUtf8(SEXP string_sexp) {
8: 	cpp11::function enc2utf8 = RStrings::get().enc2utf8_sym;
9: 	return enc2utf8(string_sexp);
10: }
11: 
12: [[cpp11::register]] cpp11::r_string rapi_ptr_to_str(SEXP extptr) {
13: 	if (TYPEOF(extptr) != EXTPTRSXP) {
14: 		cpp11::stop("rapi_ptr_to_str: Need external pointer parameter");
15: 	}
16: 
17: 	void *ptr = R_ExternalPtrAddr(extptr);
18: 	if (ptr != NULL) {
19: 		char buf[100];
20: 		snprintf(buf, 100, "%p", ptr);
21: 		return cpp11::r_string(buf);
22: 	} else {
23: 		return cpp11::r_string(NA_STRING);
24: 	}
25: }
26: 
27: static SEXP cstr_to_charsexp(const char *s) {
28: 	return Rf_mkCharCE(s, CE_UTF8);
29: }
30: 
31: static SEXP cpp_str_to_charsexp(string s) {
32: 	return cstr_to_charsexp(s.c_str());
33: }
34: 
35: SEXP duckdb::StringsToSexp(vector<string> s) {
36: 	RProtector r;
37: 	SEXP retsexp = r.Protect(NEW_STRING(s.size()));
38: 	for (idx_t i = 0; i < s.size(); i++) {
39: 		SET_STRING_ELT(retsexp, i, cpp_str_to_charsexp(s[i]));
40: 	}
41: 	return retsexp;
42: }
43: 
44: RStrings::RStrings() {
45: 	// allocate strings once
46: 	RProtector r;
47: 
48: 	SEXP strings = r.Protect(Rf_allocVector(STRSXP, 5));
49: 	SET_STRING_ELT(strings, 0, secs = Rf_mkChar("secs"));
50: 	SET_STRING_ELT(strings, 1, mins = Rf_mkChar("mins"));
51: 	SET_STRING_ELT(strings, 2, hours = Rf_mkChar("hours"));
52: 	SET_STRING_ELT(strings, 3, days = Rf_mkChar("days"));
53: 	SET_STRING_ELT(strings, 4, weeks = Rf_mkChar("weeks"));
54: 	R_PreserveObject(strings);
55: 	MARK_NOT_MUTABLE(strings);
56: 
57: 	SEXP chars = r.Protect(Rf_allocVector(VECSXP, 7));
58: 	SET_VECTOR_ELT(chars, 0, UTC_str = Rf_mkString("UTC"));
59: 	SET_VECTOR_ELT(chars, 1, Date_str = Rf_mkString("Date"));
60: 	SET_VECTOR_ELT(chars, 2, difftime_str = Rf_mkString("difftime"));
61: 	SET_VECTOR_ELT(chars, 3, secs_str = Rf_mkString("secs"));
62: 	SET_VECTOR_ELT(chars, 4, arrow_str = Rf_mkString("arrow"));
63: 	SET_VECTOR_ELT(chars, 5, POSIXct_POSIXt_str = StringsToSexp({"POSIXct", "POSIXt"}));
64: 	SET_VECTOR_ELT(chars, 6, factor_str = Rf_mkString("factor"));
65: 
66: 	R_PreserveObject(chars);
67: 	MARK_NOT_MUTABLE(chars);
68: 
69: 	// Symbols don't need to be protected
70: 	enc2utf8_sym = Rf_install("enc2utf8");
71: 	tzone_sym = Rf_install("tzone");
72: 	units_sym = Rf_install("units");
73: 	getNamespace_sym = Rf_install("getNamespace");
74: 	ImportSchema_sym = Rf_install("ImportSchema");
75: 	ImportRecordBatch_sym = Rf_install("ImportRecordBatch");
76: 	ImportRecordBatchReader_sym = Rf_install("ImportRecordBatchReader");
77: 	Table__from_record_batches_sym = Rf_install("Table__from_record_batches");
78: }
79: 
80: template <class SRC, class DST, class RTYPE>
81: static void AppendColumnSegment(SRC *source_data, Vector &result, idx_t count) {
82: 	auto result_data = FlatVector::GetData<DST>(result);
83: 	auto &result_mask = FlatVector::Validity(result);
84: 	for (idx_t i = 0; i < count; i++) {
85: 		auto val = source_data[i];
86: 		if (RTYPE::IsNull(val)) {
87: 			result_mask.SetInvalid(i);
88: 		} else {
89: 			result_data[i] = RTYPE::Convert(val);
90: 		}
91: 	}
92: }
93: 
94: Value RApiTypes::SexpToValue(SEXP valsexp, R_len_t idx) {
95: 	auto rtype = RApiTypes::DetectRType(valsexp);
96: 	switch (rtype) {
97: 	case RType::LOGICAL: {
98: 		auto lgl_val = INTEGER_POINTER(valsexp)[idx];
99: 		return RBooleanType::IsNull(lgl_val) ? Value(LogicalType::BOOLEAN) : Value::BOOLEAN(lgl_val);
100: 	}
101: 	case RType::INTEGER: {
102: 		auto int_val = INTEGER_POINTER(valsexp)[idx];
103: 		return RIntegerType::IsNull(int_val) ? Value(LogicalType::INTEGER) : Value::INTEGER(int_val);
104: 	}
105: 	case RType::NUMERIC: {
106: 		auto dbl_val = NUMERIC_POINTER(valsexp)[idx];
107: 		bool is_null = RDoubleType::IsNull(dbl_val);
108: 		if (is_null) {
109: 			return Value(LogicalType::DOUBLE);
110: 		} else {
111: 			return Value::DOUBLE(dbl_val);
112: 		}
113: 	}
114: 	case RType::STRING: {
115: 		auto str_val = STRING_ELT(ToUtf8(valsexp), idx);
116: 		return str_val == NA_STRING ? Value(LogicalType::VARCHAR) : Value(CHAR(str_val));
117: 		//  TODO this does not deal with NULLs yet
118: 		// return Value::ENUM((uint64_t)DATAPTR(str_val), LogicalType::DEDUP_POINTER_ENUM());
119: 	}
120: 	case RType::FACTOR: {
121: 		auto int_val = INTEGER_POINTER(valsexp)[idx];
122: 		auto levels = GET_LEVELS(valsexp);
123: 		bool is_null = RIntegerType::IsNull(int_val);
124: 		if (!is_null) {
125: 			auto str_val = STRING_ELT(levels, int_val - 1);
126: 			return Value(CHAR(str_val));
127: 		} else {
128: 			return Value(LogicalType::VARCHAR);
129: 		}
130: 	}
131: 	case RType::TIMESTAMP: {
132: 		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
133: 		bool is_null = RTimestampType::IsNull(ts_val);
134: 		if (!is_null) {
135: 			return Value::TIMESTAMP(RTimestampType::Convert(ts_val));
136: 		} else {
137: 			return Value(LogicalType::TIMESTAMP);
138: 		}
139: 	}
140: 	case RType::DATE: {
141: 		auto d_val = NUMERIC_POINTER(valsexp)[idx];
142: 		return RDateType::IsNull(d_val) ? Value(LogicalType::DATE) : Value::DATE(RDateType::Convert(d_val));
143: 	}
144: 	case RType::DATE_INTEGER: {
145: 		auto d_val = INTEGER_POINTER(valsexp)[idx];
146: 		return RIntegerType::IsNull(d_val) ? Value(LogicalType::DATE) : Value::DATE(RDateType::Convert(d_val));
147: 	}
148: 	case RType::TIME_SECONDS: {
149: 		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
150: 		return RTimeSecondsType::IsNull(ts_val) ? Value(LogicalType::TIME)
151: 		                                        : Value::TIME(RTimeSecondsType::Convert(ts_val));
152: 	}
153: 	case RType::TIME_MINUTES: {
154: 		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
155: 		return RTimeMinutesType::IsNull(ts_val) ? Value(LogicalType::TIME)
156: 		                                        : Value::TIME(RTimeMinutesType::Convert(ts_val));
157: 	}
158: 	case RType::TIME_HOURS: {
159: 		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
160: 		return RTimeHoursType::IsNull(ts_val) ? Value(LogicalType::TIME) : Value::TIME(RTimeHoursType::Convert(ts_val));
161: 	}
162: 	case RType::TIME_DAYS: {
163: 		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
164: 		return RTimeDaysType::IsNull(ts_val) ? Value(LogicalType::TIME) : Value::TIME(RTimeDaysType::Convert(ts_val));
165: 	}
166: 	case RType::TIME_WEEKS: {
167: 		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
168: 		return RTimeWeeksType::IsNull(ts_val) ? Value(LogicalType::TIME) : Value::TIME(RTimeWeeksType::Convert(ts_val));
169: 	}
170: 	case RType::TIME_SECONDS_INTEGER: {
171: 		auto ts_val = INTEGER_POINTER(valsexp)[idx];
172: 		return RIntegerType::IsNull(ts_val) ? Value(LogicalType::TIME) : Value::TIME(RTimeSecondsType::Convert(ts_val));
173: 	}
174: 	case RType::TIME_MINUTES_INTEGER: {
175: 		auto ts_val = INTEGER_POINTER(valsexp)[idx];
176: 		return RIntegerType::IsNull(ts_val) ? Value(LogicalType::TIME) : Value::TIME(RTimeMinutesType::Convert(ts_val));
177: 	}
178: 	case RType::TIME_HOURS_INTEGER: {
179: 		auto ts_val = INTEGER_POINTER(valsexp)[idx];
180: 		return RIntegerType::IsNull(ts_val) ? Value(LogicalType::TIME) : Value::TIME(RTimeHoursType::Convert(ts_val));
181: 	}
182: 	case RType::TIME_DAYS_INTEGER: {
183: 		auto ts_val = INTEGER_POINTER(valsexp)[idx];
184: 		return RIntegerType::IsNull(ts_val) ? Value(LogicalType::TIME) : Value::TIME(RTimeDaysType::Convert(ts_val));
185: 	}
186: 	case RType::TIME_WEEKS_INTEGER: {
187: 		auto ts_val = INTEGER_POINTER(valsexp)[idx];
188: 		return RIntegerType::IsNull(ts_val) ? Value(LogicalType::TIME) : Value::TIME(RTimeWeeksType::Convert(ts_val));
189: 	}
190: 	default:
191: 		cpp11::stop("duckdb_sexp_to_value: Unsupported type");
192: 		return Value();
193: 	}
194: }
195: 
196: SEXP RApiTypes::ValueToSexp(Value &val, string &timezone_config) {
197: 	if (val.IsNull()) {
198: 		return R_NilValue;
199: 	}
200: 
201: 	switch (val.type().id()) {
202: 	case LogicalTypeId::BOOLEAN:
203: 		return cpp11::logicals({val.GetValue<bool>()});
204: 	case LogicalTypeId::TINYINT:
205: 	case LogicalTypeId::SMALLINT:
206: 	case LogicalTypeId::INTEGER:
207: 	case LogicalTypeId::UTINYINT:
208: 	case LogicalTypeId::USMALLINT:
209: 	case LogicalTypeId::UINTEGER:
210: 		return cpp11::integers({val.GetValue<int32_t>()});
211: 	case LogicalTypeId::BIGINT:
212: 	case LogicalTypeId::UBIGINT:
213: 	case LogicalTypeId::FLOAT:
214: 	case LogicalTypeId::DOUBLE:
215: 	case LogicalTypeId::DECIMAL:
216: 		return cpp11::doubles({val.GetValue<double>()});
217: 	case LogicalTypeId::VARCHAR:
218: 		return StringsToSexp({val.ToString()});
219: 	case LogicalTypeId::TIMESTAMP: {
220: 		cpp11::doubles res({(double)Timestamp::GetEpochSeconds(val.GetValue<timestamp_t>())});
221: 		// TODO bit of duplication here with statement.cpp, fix this
222: 		// some dresssup for R
223: 		SET_CLASS(res, RStrings::get().POSIXct_POSIXt_str);
224: 		Rf_setAttrib(res, RStrings::get().tzone_sym, StringsToSexp({""}));
225: 		return res;
226: 	}
227: 	case LogicalTypeId::TIMESTAMP_TZ: {
228: 		cpp11::doubles res({(double)Timestamp::GetEpochSeconds(val.GetValue<timestamp_t>())});
229: 		SET_CLASS(res, RStrings::get().POSIXct_POSIXt_str);
230: 		Rf_setAttrib(res, RStrings::get().tzone_sym, StringsToSexp({timezone_config}));
231: 		return res;
232: 	}
233: 	case LogicalTypeId::TIME: {
234: 		cpp11::doubles res({(double)val.GetValue<dtime_t>().micros / Interval::MICROS_PER_SEC});
235: 		// some dresssup for R
236: 		SET_CLASS(res, RStrings::get().difftime_str);
237: 		// we always return difftime as "seconds"
238: 		Rf_setAttrib(res, RStrings::get().units_sym, RStrings::get().secs_str);
239: 		return res;
240: 	}
241: 
242: 	case LogicalTypeId::DATE: {
243: 		cpp11::doubles res({(double)int32_t(val.GetValue<date_t>())});
244: 		// some dresssup for R
245: 		SET_CLASS(res, RStrings::get().Date_str);
246: 		return res;
247: 	}
248: 
249: 	default:
250: 		throw NotImplementedException("Can't convert %s of type %s", val.ToString(), val.type().ToString());
251: 	}
252: }
[end of tools/rpkg/src/utils.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: