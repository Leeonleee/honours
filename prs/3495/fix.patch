diff --git a/tools/rpkg/DESCRIPTION b/tools/rpkg/DESCRIPTION
index 17a60ca08222..71ee4935568f 100644
--- a/tools/rpkg/DESCRIPTION
+++ b/tools/rpkg/DESCRIPTION
@@ -56,6 +56,8 @@ Suggests:
     dbplyr,
     nycflights13,
     testthat,
+    tibble,
+    vctrs,
     withr
 Encoding: UTF-8
 Roxygen: list(markdown = TRUE)
diff --git a/tools/rpkg/R/Result.R b/tools/rpkg/R/Result.R
index 2235452bd0be..02bfb60b876c 100644
--- a/tools/rpkg/R/Result.R
+++ b/tools/rpkg/R/Result.R
@@ -46,7 +46,7 @@ duckdb_execute <- function(res) {
 
 duckdb_post_execute <- function(res, out) {
   if (!res@arrow) {
-    out <- list_to_df(out)
+    stopifnot(is.data.frame(out))
 
     if (!res@stmt_lst$type %in% c("SELECT", "EXPLAIN")) {
       res@env$rows_affected <- sum(as.numeric(out[[1]]))
@@ -58,15 +58,6 @@ duckdb_post_execute <- function(res, out) {
   out
 }
 
-list_to_df <- function(x) {
-  if (is.data.frame(x)) {
-    return(x)
-  }
-  attr(x, "row.names") <- c(NA_integer_, -length(x[[1]]))
-  class(x) <- c( "data.frame")
-  x
-}
-
 # as per is.integer documentation
 is_wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - round(x)) < tol
 
diff --git a/tools/rpkg/R/dbBind__duckdb_result.R b/tools/rpkg/R/dbBind__duckdb_result.R
index 2348c31d3537..8f6abe7ef1d6 100644
--- a/tools/rpkg/R/dbBind__duckdb_result.R
+++ b/tools/rpkg/R/dbBind__duckdb_result.R
@@ -30,3 +30,12 @@ dbBind__duckdb_result <- function(res, params, ...) {
 #' @rdname duckdb_result-class
 #' @export
 setMethod("dbBind", "duckdb_result", dbBind__duckdb_result)
+
+list_to_df <- function(x) {
+  if (is.data.frame(x)) {
+    return(x)
+  }
+  attr(x, "row.names") <- c(NA_integer_, -NROW(x[[1]]))
+  class(x) <- "data.frame"
+  x
+}
diff --git a/tools/rpkg/R/dbFetch__duckdb_result.R b/tools/rpkg/R/dbFetch__duckdb_result.R
index 5820458be472..4b26658de15a 100644
--- a/tools/rpkg/R/dbFetch__duckdb_result.R
+++ b/tools/rpkg/R/dbFetch__duckdb_result.R
@@ -6,6 +6,14 @@ dbFetch__duckdb_result <- function(res, n = -1, ...) {
   if (!res@env$open) {
     stop("result set was closed")
   }
+
+  if (res@arrow) {
+    if (n != -1) {
+      stop("Cannot dbFetch() an Arrow result unless n = -1")
+    }
+    return(as.data.frame(duckdb::duckdb_fetch_arrow(res)))
+  }
+
   if (is.null(res@env$resultset)) {
     stop("Need to call `dbBind()` before `dbFetch()`")
   }
@@ -32,10 +40,6 @@ dbFetch__duckdb_result <- function(res, n = -1, ...) {
     return(data.frame())
   }
 
-  if (res@arrow) {
-    stop("Cannot dbFetch() an Arrow result")
-  }
-
   timezone_out <- res@connection@timezone_out
   tz_out_convert <- res@connection@tz_out_convert
 
diff --git a/tools/rpkg/src/include/rapi.hpp b/tools/rpkg/src/include/rapi.hpp
index c81d50eb076d..a57df5859098 100644
--- a/tools/rpkg/src/include/rapi.hpp
+++ b/tools/rpkg/src/include/rapi.hpp
@@ -99,6 +99,7 @@ struct RStrings {
 	SEXP UTC_str; // Rf_mkString
 	SEXP Date_str;
 	SEXP factor_str;
+	SEXP dataframe_str;
 	SEXP difftime_str;
 	SEXP secs_str;
 	SEXP arrow_str; // StringsToSexp
diff --git a/tools/rpkg/src/statement.cpp b/tools/rpkg/src/statement.cpp
index b21e2fda21f4..02ebdea9fe4d 100644
--- a/tools/rpkg/src/statement.cpp
+++ b/tools/rpkg/src/statement.cpp
@@ -111,6 +111,9 @@ static void VectorToR(Vector &src_vec, size_t count, void *dest, uint64_t dest_o
 		case LogicalTypeId::LIST:
 			rtype = "list";
 			break;
+		case LogicalTypeId::STRUCT:
+			rtype = "data.frame";
+			break;
 		case LogicalTypeId::ENUM:
 			rtype = "factor";
 			break;
@@ -207,6 +210,26 @@ static SEXP allocate(const LogicalType &type, RProtector &r_varvalue, idx_t nrow
 	case LogicalTypeId::LIST:
 		varvalue = r_varvalue.Protect(NEW_LIST(nrows));
 		break;
+	case LogicalTypeId::STRUCT: {
+		cpp11::writable::list dest_list;
+
+		for (const auto &child : StructType::GetChildTypes(type)) {
+			const auto &name = child.first;
+			const auto &child_type = child.second;
+
+			RProtector child_protector;
+			auto dest_child = allocate(child_type, child_protector, nrows);
+			dest_list.push_back(cpp11::named_arg(name.c_str()) = std::move(dest_child));
+		}
+
+		// Note we cannot use cpp11's data frame here as it tries to calculate the number of rows itself,
+		// but gives the wrong answer if the first column is another data frame or the struct is empty.
+		dest_list.attr(R_ClassSymbol) = RStrings::get().dataframe_str;
+		dest_list.attr(R_RowNamesSymbol) = {NA_INTEGER, -static_cast<int>(nrows)};
+
+		varvalue = r_varvalue.Protect(cpp11::as_sexp(dest_list));
+		break;
+	}
 	case LogicalTypeId::VARCHAR: {
 		auto wrapper = new DuckDBAltrepStringWrapper();
 		wrapper->length = nrows;
@@ -432,6 +455,17 @@ static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n) {
 		}
 		break;
 	}
+	case LogicalTypeId::STRUCT: {
+		const auto &children = StructVector::GetEntries(src_vec);
+
+		for (size_t i = 0; i < children.size(); i++) {
+			const auto &struct_child = children[i];
+			SEXP child_dest = VECTOR_ELT(dest, i);
+			transform(*struct_child, child_dest, dest_offset, n);
+		}
+
+		break;
+	}
 	case LogicalTypeId::BLOB: {
 		auto src_ptr = FlatVector::GetData<string_t>(src_vec);
 		auto &mask = FlatVector::Validity(src_vec);
@@ -518,17 +552,23 @@ SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result) {
 	}
 
 	uint64_t nrows = result->collection.Count();
-	cpp11::list retlist(NEW_LIST(ncols));
-	SET_NAMES(retlist, StringsToSexp(result->names));
+
+	// Note we cannot use cpp11's data frame here as it tries to calculate the number of rows itself,
+	// but gives the wrong answer if the first column is another data frame. So we set the necessary
+	// attributes manually.
+	cpp11::writable::list data_frame(NEW_LIST(ncols));
+	data_frame.attr(R_ClassSymbol) = RStrings::get().dataframe_str;
+	data_frame.attr(R_RowNamesSymbol) = {NA_INTEGER, -static_cast<int>(nrows)};
+	SET_NAMES(data_frame, StringsToSexp(result->names));
 
 	for (size_t col_idx = 0; col_idx < ncols; col_idx++) {
 		// TODO move the protector to allocate?
 		RProtector r_varvalue;
 		auto varvalue = allocate(result->types[col_idx], r_varvalue, nrows);
-		SET_VECTOR_ELT(retlist, col_idx, varvalue);
+		SET_VECTOR_ELT(data_frame, col_idx, varvalue);
 	}
 
-	// at this point retlist is fully allocated and the only protected SEXP
+	// at this point data_frame is fully allocated and the only protected SEXP
 
 	// step 3: set values from chunks
 	uint64_t dest_offset = 0;
@@ -540,9 +580,9 @@ SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result) {
 		}
 
 		D_ASSERT(chunk->ColumnCount() == ncols);
-		D_ASSERT(chunk->ColumnCount() == (idx_t)Rf_length(retlist));
+		D_ASSERT(chunk->ColumnCount() == (idx_t)Rf_length(data_frame));
 		for (size_t col_idx = 0; col_idx < chunk->ColumnCount(); col_idx++) {
-			SEXP dest = VECTOR_ELT(retlist, col_idx);
+			SEXP dest = VECTOR_ELT(data_frame, col_idx);
 			transform(chunk->data[col_idx], dest, dest_offset, chunk->size());
 		}
 		dest_offset += chunk->size();
@@ -550,7 +590,7 @@ SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result) {
 	}
 
 	D_ASSERT(dest_offset == nrows);
-	return retlist;
+	return data_frame;
 }
 
 struct AppendableRList {
diff --git a/tools/rpkg/src/utils.cpp b/tools/rpkg/src/utils.cpp
index 7119d4a4520e..fdcaa1ca69fb 100644
--- a/tools/rpkg/src/utils.cpp
+++ b/tools/rpkg/src/utils.cpp
@@ -54,7 +54,7 @@ RStrings::RStrings() {
 	R_PreserveObject(strings);
 	MARK_NOT_MUTABLE(strings);
 
-	SEXP chars = r.Protect(Rf_allocVector(VECSXP, 7));
+	SEXP chars = r.Protect(Rf_allocVector(VECSXP, 8));
 	SET_VECTOR_ELT(chars, 0, UTC_str = Rf_mkString("UTC"));
 	SET_VECTOR_ELT(chars, 1, Date_str = Rf_mkString("Date"));
 	SET_VECTOR_ELT(chars, 2, difftime_str = Rf_mkString("difftime"));
@@ -62,6 +62,7 @@ RStrings::RStrings() {
 	SET_VECTOR_ELT(chars, 4, arrow_str = Rf_mkString("arrow"));
 	SET_VECTOR_ELT(chars, 5, POSIXct_POSIXt_str = StringsToSexp({"POSIXct", "POSIXt"}));
 	SET_VECTOR_ELT(chars, 6, factor_str = Rf_mkString("factor"));
+	SET_VECTOR_ELT(chars, 7, dataframe_str = Rf_mkString("data.frame"));
 
 	R_PreserveObject(chars);
 	MARK_NOT_MUTABLE(chars);
