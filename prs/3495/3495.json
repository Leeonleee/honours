{
  "repo": "duckdb/duckdb",
  "pull_number": 3495,
  "instance_id": "duckdb__duckdb-3495",
  "issue_numbers": [
    "3334"
  ],
  "base_commit": "3191940af93e628c48509a26eb5fbe42f814a2b2",
  "patch": "diff --git a/tools/rpkg/DESCRIPTION b/tools/rpkg/DESCRIPTION\nindex 17a60ca08222..71ee4935568f 100644\n--- a/tools/rpkg/DESCRIPTION\n+++ b/tools/rpkg/DESCRIPTION\n@@ -56,6 +56,8 @@ Suggests:\n     dbplyr,\n     nycflights13,\n     testthat,\n+    tibble,\n+    vctrs,\n     withr\n Encoding: UTF-8\n Roxygen: list(markdown = TRUE)\ndiff --git a/tools/rpkg/R/Result.R b/tools/rpkg/R/Result.R\nindex 2235452bd0be..02bfb60b876c 100644\n--- a/tools/rpkg/R/Result.R\n+++ b/tools/rpkg/R/Result.R\n@@ -46,7 +46,7 @@ duckdb_execute <- function(res) {\n \n duckdb_post_execute <- function(res, out) {\n   if (!res@arrow) {\n-    out <- list_to_df(out)\n+    stopifnot(is.data.frame(out))\n \n     if (!res@stmt_lst$type %in% c(\"SELECT\", \"EXPLAIN\")) {\n       res@env$rows_affected <- sum(as.numeric(out[[1]]))\n@@ -58,15 +58,6 @@ duckdb_post_execute <- function(res, out) {\n   out\n }\n \n-list_to_df <- function(x) {\n-  if (is.data.frame(x)) {\n-    return(x)\n-  }\n-  attr(x, \"row.names\") <- c(NA_integer_, -length(x[[1]]))\n-  class(x) <- c( \"data.frame\")\n-  x\n-}\n-\n # as per is.integer documentation\n is_wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - round(x)) < tol\n \ndiff --git a/tools/rpkg/R/dbBind__duckdb_result.R b/tools/rpkg/R/dbBind__duckdb_result.R\nindex 2348c31d3537..8f6abe7ef1d6 100644\n--- a/tools/rpkg/R/dbBind__duckdb_result.R\n+++ b/tools/rpkg/R/dbBind__duckdb_result.R\n@@ -30,3 +30,12 @@ dbBind__duckdb_result <- function(res, params, ...) {\n #' @rdname duckdb_result-class\n #' @export\n setMethod(\"dbBind\", \"duckdb_result\", dbBind__duckdb_result)\n+\n+list_to_df <- function(x) {\n+  if (is.data.frame(x)) {\n+    return(x)\n+  }\n+  attr(x, \"row.names\") <- c(NA_integer_, -NROW(x[[1]]))\n+  class(x) <- \"data.frame\"\n+  x\n+}\ndiff --git a/tools/rpkg/R/dbFetch__duckdb_result.R b/tools/rpkg/R/dbFetch__duckdb_result.R\nindex 5820458be472..4b26658de15a 100644\n--- a/tools/rpkg/R/dbFetch__duckdb_result.R\n+++ b/tools/rpkg/R/dbFetch__duckdb_result.R\n@@ -6,6 +6,14 @@ dbFetch__duckdb_result <- function(res, n = -1, ...) {\n   if (!res@env$open) {\n     stop(\"result set was closed\")\n   }\n+\n+  if (res@arrow) {\n+    if (n != -1) {\n+      stop(\"Cannot dbFetch() an Arrow result unless n = -1\")\n+    }\n+    return(as.data.frame(duckdb::duckdb_fetch_arrow(res)))\n+  }\n+\n   if (is.null(res@env$resultset)) {\n     stop(\"Need to call `dbBind()` before `dbFetch()`\")\n   }\n@@ -32,10 +40,6 @@ dbFetch__duckdb_result <- function(res, n = -1, ...) {\n     return(data.frame())\n   }\n \n-  if (res@arrow) {\n-    stop(\"Cannot dbFetch() an Arrow result\")\n-  }\n-\n   timezone_out <- res@connection@timezone_out\n   tz_out_convert <- res@connection@tz_out_convert\n \ndiff --git a/tools/rpkg/src/include/rapi.hpp b/tools/rpkg/src/include/rapi.hpp\nindex c81d50eb076d..a57df5859098 100644\n--- a/tools/rpkg/src/include/rapi.hpp\n+++ b/tools/rpkg/src/include/rapi.hpp\n@@ -99,6 +99,7 @@ struct RStrings {\n \tSEXP UTC_str; // Rf_mkString\n \tSEXP Date_str;\n \tSEXP factor_str;\n+\tSEXP dataframe_str;\n \tSEXP difftime_str;\n \tSEXP secs_str;\n \tSEXP arrow_str; // StringsToSexp\ndiff --git a/tools/rpkg/src/statement.cpp b/tools/rpkg/src/statement.cpp\nindex b21e2fda21f4..02ebdea9fe4d 100644\n--- a/tools/rpkg/src/statement.cpp\n+++ b/tools/rpkg/src/statement.cpp\n@@ -111,6 +111,9 @@ static void VectorToR(Vector &src_vec, size_t count, void *dest, uint64_t dest_o\n \t\tcase LogicalTypeId::LIST:\n \t\t\trtype = \"list\";\n \t\t\tbreak;\n+\t\tcase LogicalTypeId::STRUCT:\n+\t\t\trtype = \"data.frame\";\n+\t\t\tbreak;\n \t\tcase LogicalTypeId::ENUM:\n \t\t\trtype = \"factor\";\n \t\t\tbreak;\n@@ -207,6 +210,26 @@ static SEXP allocate(const LogicalType &type, RProtector &r_varvalue, idx_t nrow\n \tcase LogicalTypeId::LIST:\n \t\tvarvalue = r_varvalue.Protect(NEW_LIST(nrows));\n \t\tbreak;\n+\tcase LogicalTypeId::STRUCT: {\n+\t\tcpp11::writable::list dest_list;\n+\n+\t\tfor (const auto &child : StructType::GetChildTypes(type)) {\n+\t\t\tconst auto &name = child.first;\n+\t\t\tconst auto &child_type = child.second;\n+\n+\t\t\tRProtector child_protector;\n+\t\t\tauto dest_child = allocate(child_type, child_protector, nrows);\n+\t\t\tdest_list.push_back(cpp11::named_arg(name.c_str()) = std::move(dest_child));\n+\t\t}\n+\n+\t\t// Note we cannot use cpp11's data frame here as it tries to calculate the number of rows itself,\n+\t\t// but gives the wrong answer if the first column is another data frame or the struct is empty.\n+\t\tdest_list.attr(R_ClassSymbol) = RStrings::get().dataframe_str;\n+\t\tdest_list.attr(R_RowNamesSymbol) = {NA_INTEGER, -static_cast<int>(nrows)};\n+\n+\t\tvarvalue = r_varvalue.Protect(cpp11::as_sexp(dest_list));\n+\t\tbreak;\n+\t}\n \tcase LogicalTypeId::VARCHAR: {\n \t\tauto wrapper = new DuckDBAltrepStringWrapper();\n \t\twrapper->length = nrows;\n@@ -432,6 +455,17 @@ static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n) {\n \t\t}\n \t\tbreak;\n \t}\n+\tcase LogicalTypeId::STRUCT: {\n+\t\tconst auto &children = StructVector::GetEntries(src_vec);\n+\n+\t\tfor (size_t i = 0; i < children.size(); i++) {\n+\t\t\tconst auto &struct_child = children[i];\n+\t\t\tSEXP child_dest = VECTOR_ELT(dest, i);\n+\t\t\ttransform(*struct_child, child_dest, dest_offset, n);\n+\t\t}\n+\n+\t\tbreak;\n+\t}\n \tcase LogicalTypeId::BLOB: {\n \t\tauto src_ptr = FlatVector::GetData<string_t>(src_vec);\n \t\tauto &mask = FlatVector::Validity(src_vec);\n@@ -518,17 +552,23 @@ SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result) {\n \t}\n \n \tuint64_t nrows = result->collection.Count();\n-\tcpp11::list retlist(NEW_LIST(ncols));\n-\tSET_NAMES(retlist, StringsToSexp(result->names));\n+\n+\t// Note we cannot use cpp11's data frame here as it tries to calculate the number of rows itself,\n+\t// but gives the wrong answer if the first column is another data frame. So we set the necessary\n+\t// attributes manually.\n+\tcpp11::writable::list data_frame(NEW_LIST(ncols));\n+\tdata_frame.attr(R_ClassSymbol) = RStrings::get().dataframe_str;\n+\tdata_frame.attr(R_RowNamesSymbol) = {NA_INTEGER, -static_cast<int>(nrows)};\n+\tSET_NAMES(data_frame, StringsToSexp(result->names));\n \n \tfor (size_t col_idx = 0; col_idx < ncols; col_idx++) {\n \t\t// TODO move the protector to allocate?\n \t\tRProtector r_varvalue;\n \t\tauto varvalue = allocate(result->types[col_idx], r_varvalue, nrows);\n-\t\tSET_VECTOR_ELT(retlist, col_idx, varvalue);\n+\t\tSET_VECTOR_ELT(data_frame, col_idx, varvalue);\n \t}\n \n-\t// at this point retlist is fully allocated and the only protected SEXP\n+\t// at this point data_frame is fully allocated and the only protected SEXP\n \n \t// step 3: set values from chunks\n \tuint64_t dest_offset = 0;\n@@ -540,9 +580,9 @@ SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result) {\n \t\t}\n \n \t\tD_ASSERT(chunk->ColumnCount() == ncols);\n-\t\tD_ASSERT(chunk->ColumnCount() == (idx_t)Rf_length(retlist));\n+\t\tD_ASSERT(chunk->ColumnCount() == (idx_t)Rf_length(data_frame));\n \t\tfor (size_t col_idx = 0; col_idx < chunk->ColumnCount(); col_idx++) {\n-\t\t\tSEXP dest = VECTOR_ELT(retlist, col_idx);\n+\t\t\tSEXP dest = VECTOR_ELT(data_frame, col_idx);\n \t\t\ttransform(chunk->data[col_idx], dest, dest_offset, chunk->size());\n \t\t}\n \t\tdest_offset += chunk->size();\n@@ -550,7 +590,7 @@ SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result) {\n \t}\n \n \tD_ASSERT(dest_offset == nrows);\n-\treturn retlist;\n+\treturn data_frame;\n }\n \n struct AppendableRList {\ndiff --git a/tools/rpkg/src/utils.cpp b/tools/rpkg/src/utils.cpp\nindex 7119d4a4520e..fdcaa1ca69fb 100644\n--- a/tools/rpkg/src/utils.cpp\n+++ b/tools/rpkg/src/utils.cpp\n@@ -54,7 +54,7 @@ RStrings::RStrings() {\n \tR_PreserveObject(strings);\n \tMARK_NOT_MUTABLE(strings);\n \n-\tSEXP chars = r.Protect(Rf_allocVector(VECSXP, 7));\n+\tSEXP chars = r.Protect(Rf_allocVector(VECSXP, 8));\n \tSET_VECTOR_ELT(chars, 0, UTC_str = Rf_mkString(\"UTC\"));\n \tSET_VECTOR_ELT(chars, 1, Date_str = Rf_mkString(\"Date\"));\n \tSET_VECTOR_ELT(chars, 2, difftime_str = Rf_mkString(\"difftime\"));\n@@ -62,6 +62,7 @@ RStrings::RStrings() {\n \tSET_VECTOR_ELT(chars, 4, arrow_str = Rf_mkString(\"arrow\"));\n \tSET_VECTOR_ELT(chars, 5, POSIXct_POSIXt_str = StringsToSexp({\"POSIXct\", \"POSIXt\"}));\n \tSET_VECTOR_ELT(chars, 6, factor_str = Rf_mkString(\"factor\"));\n+\tSET_VECTOR_ELT(chars, 7, dataframe_str = Rf_mkString(\"data.frame\"));\n \n \tR_PreserveObject(chars);\n \tMARK_NOT_MUTABLE(chars);\n",
  "test_patch": "diff --git a/tools/rpkg/tests/testthat/test_struct.R b/tools/rpkg/tests/testthat/test_struct.R\nnew file mode 100644\nindex 000000000000..0d0f5e0c7e36\n--- /dev/null\n+++ b/tools/rpkg/tests/testthat/test_struct.R\n@@ -0,0 +1,110 @@\n+test_that(\"structs can be read\", {\n+  skip_if_not_installed(\"vctrs\")\n+\n+  con <- dbConnect(duckdb::duckdb())\n+  on.exit(dbDisconnect(con, shutdown = TRUE))\n+\n+  res <- dbGetQuery(con, \"SELECT {'x': 100, 'y': 'hello', 'z': 3.14} AS s\")\n+  expect_equal(res, vctrs::data_frame(\n+    s = vctrs::data_frame(x = 100L, y = \"hello\", z = 3.14)\n+  ))\n+\n+  res <- dbGetQuery(con, \"SELECT 1 AS n, {'x': 100, 'y': 'hello', 'z': 3.14} AS s\")\n+  expect_equal(res, vctrs::data_frame(\n+    n = 1L,\n+    s = vctrs::data_frame(x = 100L, y = \"hello\", z = 3.14)\n+  ))\n+\n+  res <- dbGetQuery(con, \"values (100, {'x': 100}), (200, {'x': 200}), (300, NULL)\")\n+  expect_equal(res, vctrs::data_frame(\n+    col0 = c(100L, 200L, 300L),\n+    col1 = vctrs::data_frame(x = c(100L, 200L, NA))\n+  ))\n+\n+  res <- dbGetQuery(con, \"values ('a', {'x': 100, 'y': {'a': 1, 'b': 2}}), ('b', {'x': 200, y: NULL}), ('c', NULL)\")\n+  expect_equal(res, vctrs::data_frame(\n+    col0 = c(\"a\", \"b\", \"c\"),\n+    col1 = vctrs::data_frame(\n+      x = c(100L, 200L, NA),\n+      y = vctrs::data_frame(a = c(1L, NA, NA), b = c(2L, NA, NA))\n+    )\n+  ))\n+\n+  res <- dbGetQuery(con, \"select 100 AS other, [{'x': 1, 'y': 'a'}, {'x': 2, 'y': 'b'}] AS s\")\n+  expect_equal(res, vctrs::data_frame(\n+    other = 100L,\n+    s = list(\n+      vctrs::data_frame(x = c(1L, 2L), y = c(\"a\", \"b\"))\n+    )\n+  ))\n+\n+  res <- dbGetQuery(con, \"values ([{'x': 1, 'y': 'a'}, {'x': 2, 'y': 'b'}]), ([]), ([{'x': 1, 'y': 'a'}])\")\n+  expect_equal(res, vctrs::data_frame(\n+    col0 = list(\n+      vctrs::data_frame(x = c(1L, 2L), y = c(\"a\", \"b\")),\n+      vctrs::data_frame(x = integer(0), y = character(0)),\n+      vctrs::data_frame(x = 1L, y = \"a\")\n+    )\n+  ))\n+})\n+\n+test_that(\"structs give the same results via Arrow\", {\n+  skip_if_not_installed(\"vctrs\")\n+  skip_if_not_installed(\"tibble\")\n+  skip_if_not_installed(\"arrow\")\n+\n+  con <- dbConnect(duckdb::duckdb())\n+  on.exit(dbDisconnect(con, shutdown = TRUE))\n+\n+  res <- dbGetQuery(con, \"SELECT {'x': 100, 'y': 'hello', 'z': 3.14} AS s\", arrow = TRUE)\n+  expect_equal(res, tibble::tibble(\n+    s = tibble::tibble(x = 100L, y = \"hello\", z = 3.14)\n+  ))\n+\n+  res <- dbGetQuery(con, \"SELECT 1 AS n, {'x': 100, 'y': 'hello', 'z': 3.14} AS s\", arrow = TRUE)\n+  expect_equal(res, tibble::tibble(\n+    n = 1L,\n+    s = tibble::tibble(x = 100L, y = \"hello\", z = 3.14)\n+  ))\n+\n+  res <- dbGetQuery(con, \"values (100, {'x': 100}), (200, {'x': 200}), (300, NULL)\", arrow = TRUE)\n+  expect_equal(res, tibble::tibble(\n+    col0 = c(100L, 200L, 300L),\n+    col1 = tibble::tibble(x = c(100L, 200L, NA))\n+  ))\n+\n+  res <- dbGetQuery(con, \"values ('a', {'x': 100, 'y': {'a': 1, 'b': 2}}), ('b', {'x': 200, y: NULL}), ('c', NULL)\", arrow = TRUE)\n+  expect_equal(res, tibble::tibble(\n+    col0 = c(\"a\", \"b\", \"c\"),\n+    col1 = tibble::tibble(\n+      x = c(100L, 200L, NA),\n+      y = tibble::tibble(a = c(1L, NA, NA), b = c(2L, NA, NA))\n+    )\n+  ))\n+\n+  res <- dbGetQuery(con, \"select 100 AS other, [{'x': 1, 'y': 'a'}, {'x': 2, 'y': 'b'}] AS s\", arrow = TRUE)\n+  expect_equal(res, tibble::tibble(\n+    other = 100L,\n+    s = vctrs::new_list_of(\n+      list(\n+        tibble::tibble(x = c(1L, 2L), y = c(\"a\", \"b\"))\n+      ),\n+      ptype = tibble::tibble(x = integer(), y = character()),\n+      class = \"arrow_list\"\n+    )\n+  ))\n+\n+  res <- dbGetQuery(con, \"values ([{'x': 1, 'y': 'a'}, {'x': 2, 'y': 'b'}]), ([]), ([{'x': 1, 'y': 'a'}])\", arrow = TRUE)\n+  expect_equal(res, tibble::tibble(\n+    col0 = vctrs::new_list_of(\n+      list(\n+        tibble::tibble(x = c(1L, 2L), y = c(\"a\", \"b\")),\n+        tibble::tibble(x = integer(0), y = character(0)),\n+        tibble::tibble(x = 1L, y = \"a\")\n+      ),\n+      ptype = tibble::tibble(x = integer(), y = character()),\n+      class = \"arrow_list\"\n+    )\n+  ))\n+})\n+\n",
  "problem_statement": "R - support structs\n#### What happens?\r\n\r\nR package does not support structs.\r\n\r\nLike #2734 and #3132 - should be fairly easy to add. Will try when I have some time.\r\n\r\n#### To Reproduce\r\n\r\n```sql\r\nSELECT struct_pack(i := 4, s := 'string')\r\n```\r\n\r\nfails with: Error: duckdb_prepare_R: Unknown column type for prepare: STRUCT<i: INTEGER, s: VARCHAR>\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Windows 10\r\n - DuckDB Version: 0.3.2\r\n - DuckDB Client: R\r\n\r\n#### Before Submitting\r\n\r\n- [ ] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [X] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "",
  "created_at": "2022-04-24T17:02:30Z"
}