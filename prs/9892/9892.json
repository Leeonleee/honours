{
  "repo": "duckdb/duckdb",
  "pull_number": 9892,
  "instance_id": "duckdb__duckdb-9892",
  "issue_numbers": [
    "9878"
  ],
  "base_commit": "26d8316eb1dd8dc019be5aef4d0e222d437772ea",
  "patch": "diff --git a/src/include/duckdb.h b/src/include/duckdb.h\nindex af0ee92803af..3e24925665c4 100644\n--- a/src/include/duckdb.h\n+++ b/src/include/duckdb.h\n@@ -1178,7 +1178,8 @@ DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepar\n                                                 duckdb_result *out_result);\n \n /*!\n-Executes the prepared statement with the given bound parameters, and returns a streaming query result.\n+Executes the prepared statement with the given bound parameters, and returns an optionally-streaming query result.\n+To determine if the resulting query was in fact streamed, use `duckdb_result_is_streaming`\n \n This method can be called multiple times for each prepared statement, and the parameters can be modified\n between calls to this function.\n",
  "test_patch": "diff --git a/test/api/capi/test_capi_prepared.cpp b/test/api/capi/test_capi_prepared.cpp\nindex ae8ac4bca566..73e1c44d91b5 100644\n--- a/test/api/capi/test_capi_prepared.cpp\n+++ b/test/api/capi/test_capi_prepared.cpp\n@@ -370,3 +370,98 @@ TEST_CASE(\"Test prepared statements with named parameters in C API\", \"[capi]\") {\n \n \tduckdb_destroy_prepare(&stmt);\n }\n+\n+TEST_CASE(\"Prepared streaming result\", \"[capi]\") {\n+\tCAPITester tester;\n+\n+\t// open the database in in-memory mode\n+\tREQUIRE(tester.OpenDatabase(nullptr));\n+\n+\tSECTION(\"non streaming result\") {\n+\t\tREQUIRE(tester.Query(\"CREATE TABLE t2 (i INTEGER, j INTEGER);\"));\n+\n+\t\tduckdb_prepared_statement stmt;\n+\t\tREQUIRE(duckdb_prepare(tester.connection,\n+\t\t                       \"INSERT INTO t2  SELECT 2 AS i, 3 AS j  RETURNING *, i * j AS i_times_j\",\n+\t\t                       &stmt) == DuckDBSuccess);\n+\t\tduckdb_result res;\n+\t\tREQUIRE(duckdb_execute_prepared_streaming(stmt, &res) == DuckDBSuccess);\n+\t\tREQUIRE(!duckdb_result_is_streaming(res));\n+\t\tduckdb_destroy_result(&res);\n+\t\tduckdb_destroy_prepare(&stmt);\n+\t}\n+\n+\tSECTION(\"streaming result\") {\n+\t\tduckdb_prepared_statement stmt;\n+\t\tREQUIRE(duckdb_prepare(tester.connection, \"FROM RANGE(0, 10)\", &stmt) == DuckDBSuccess);\n+\n+\t\tduckdb_result res;\n+\t\tREQUIRE(duckdb_execute_prepared_streaming(stmt, &res) == DuckDBSuccess);\n+\t\tREQUIRE(duckdb_result_is_streaming(res));\n+\n+\t\tduckdb_data_chunk chunk;\n+\t\tchunk = duckdb_stream_fetch_chunk(res);\n+\t\tREQUIRE(duckdb_data_chunk_get_size(chunk) == 10);\n+\n+\t\tauto vec = duckdb_data_chunk_get_vector(chunk, 0);\n+\t\tauto column_type = duckdb_vector_get_column_type(vec);\n+\t\tREQUIRE(duckdb_get_type_id(column_type) == DUCKDB_TYPE_BIGINT);\n+\t\tduckdb_destroy_logical_type(&column_type);\n+\n+\t\tauto data = (int64_t *)duckdb_vector_get_data(vec);\n+\t\tREQUIRE(data[0] == 0);\n+\t\tREQUIRE(data[1] == 1);\n+\t\tREQUIRE(data[2] == 2);\n+\t\tREQUIRE(data[3] == 3);\n+\t\tREQUIRE(data[4] == 4);\n+\t\tREQUIRE(data[5] == 5);\n+\t\tREQUIRE(data[6] == 6);\n+\t\tREQUIRE(data[7] == 7);\n+\t\tREQUIRE(data[8] == 8);\n+\t\tREQUIRE(data[9] == 9);\n+\n+\t\tduckdb_destroy_data_chunk(&chunk);\n+\n+\t\tREQUIRE(duckdb_stream_fetch_chunk(res) == nullptr);\n+\n+\t\tduckdb_destroy_result(&res);\n+\t\tduckdb_destroy_prepare(&stmt);\n+\t}\n+\n+\tSECTION(\"streaming extracted statements\") {\n+\t\tduckdb_extracted_statements stmts;\n+\t\tauto n_statements = duckdb_extract_statements(tester.connection, \"Select 1; Select 2;\", &stmts);\n+\t\tREQUIRE(n_statements == 2);\n+\n+\t\tfor (idx_t i = 0; i < n_statements; i++) {\n+\t\t\tduckdb_prepared_statement stmt;\n+\t\t\tREQUIRE(duckdb_prepare_extracted_statement(tester.connection, stmts, i, &stmt) == DuckDBSuccess);\n+\n+\t\t\tduckdb_result res;\n+\t\t\tREQUIRE(duckdb_execute_prepared_streaming(stmt, &res) == DuckDBSuccess);\n+\t\t\tREQUIRE(duckdb_result_is_streaming(res));\n+\n+\t\t\tduckdb_data_chunk chunk;\n+\t\t\tchunk = duckdb_stream_fetch_chunk(res);\n+\t\t\tREQUIRE(chunk != nullptr);\n+\t\t\tREQUIRE(duckdb_data_chunk_get_size(chunk) == 1);\n+\n+\t\t\tauto vec = duckdb_data_chunk_get_vector(chunk, 0);\n+\n+\t\t\tauto type = duckdb_vector_get_column_type(vec);\n+\t\t\tREQUIRE(duckdb_get_type_id(type) == DUCKDB_TYPE_INTEGER);\n+\t\t\tduckdb_destroy_logical_type(&type);\n+\n+\t\t\tauto data = (int32_t *)duckdb_vector_get_data(vec);\n+\t\t\tREQUIRE(data[0] == (int32_t)(i + 1));\n+\n+\t\t\tREQUIRE(duckdb_stream_fetch_chunk(res) == nullptr);\n+\n+\t\t\tduckdb_destroy_data_chunk(&chunk);\n+\t\t\tduckdb_destroy_result(&res);\n+\t\t\tduckdb_destroy_prepare(&stmt);\n+\t\t}\n+\n+\t\tduckdb_destroy_extracted(&stmts);\n+\t}\n+}\n",
  "problem_statement": "Streaming result does not return rows\n### What happens?\r\n\r\nWhen I execute the following command from [RETURNING Clause](https://duckdb.org/docs/sql/statements/insert.html#returning-clause) page, `INSERT INTO t2 \r\n    SELECT 2 AS i, 3 AS j \r\n    RETURNING *, i * j AS i_times_j;` \r\nwith the streaming result, the chunk returned by `duckdb_stream_fetch_chunk` is null and consequently, I can't read any data.\r\n\r\n### To Reproduce\r\n\r\nUse the C api to create a streaming result with `duckdb_execute_prepared_streaming` (available only in main) and use `duckdb_stream_fetch_chunk` to fetch a chunk from it. The chunk will be null and you won't be able to read data from it.\r\n\r\nWorks fine if I use a non-streaming result API: `duckdb_execute_prepared` and `duckdb_result_get_chunk`\r\n\r\n### OS:\r\n\r\nWindows 11 x64\r\n\r\n### DuckDB Version:\r\n\r\nv0.9.3-dev1060\r\n\r\n### DuckDB Client:\r\n\r\nC# client via C API\r\n\r\n### Full Name:\r\n\r\nGiorgi Dalakishvili\r\n\r\n### Affiliation:\r\n\r\nSpace International\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Can you provide a reproduction please? I just wrote a quick test and it seems to work as expected\nOkay, reproduced. Looks like the `duckdb_stream_fetch_chunk` function returns `null` if the result isn't a streaming result. The `allow_stream_result` setting only allows a streamed result, it doesn't force it\nWe actually already have the `duckdb_result_is_streaming` method too: https://duckdb.org/docs/api/c/api#duckdb_result_is_streaming\nSo when I get a result from `duckdb_execute_prepared_streaming` I should check whether it's streaming or not and process accordingly?\nCorrect - `duckdb_execute_prepared_streaming` only allows a streaming result, it doesn't force one",
  "created_at": "2023-12-05T06:34:29Z"
}