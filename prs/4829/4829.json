{
  "repo": "duckdb/duckdb",
  "pull_number": 4829,
  "instance_id": "duckdb__duckdb-4829",
  "issue_numbers": [
    "4827"
  ],
  "base_commit": "5748a740d8bfea4a331e4893cad86632ab1ee8b2",
  "patch": "diff --git a/src/include/duckdb/parser/expression/between_expression.hpp b/src/include/duckdb/parser/expression/between_expression.hpp\nindex ecd116b81a8f..7f0d8a842e18 100644\n--- a/src/include/duckdb/parser/expression/between_expression.hpp\n+++ b/src/include/duckdb/parser/expression/between_expression.hpp\n@@ -34,7 +34,8 @@ class BetweenExpression : public ParsedExpression {\n public:\n \ttemplate <class T, class BASE>\n \tstatic string ToString(const T &entry) {\n-\t\treturn entry.input->ToString() + \" BETWEEN \" + entry.lower->ToString() + \" AND \" + entry.upper->ToString();\n+\t\treturn \"(\" + entry.input->ToString() + \" BETWEEN \" + entry.lower->ToString() + \" AND \" +\n+\t\t       entry.upper->ToString() + \")\";\n \t}\n };\n } // namespace duckdb\ndiff --git a/src/include/duckdb/parser/expression/comparison_expression.hpp b/src/include/duckdb/parser/expression/comparison_expression.hpp\nindex 0e5c4a02c0e3..2c8f883ba9b3 100644\n--- a/src/include/duckdb/parser/expression/comparison_expression.hpp\n+++ b/src/include/duckdb/parser/expression/comparison_expression.hpp\n@@ -34,7 +34,7 @@ class ComparisonExpression : public ParsedExpression {\n public:\n \ttemplate <class T, class BASE>\n \tstatic string ToString(const T &entry) {\n-\t\treturn StringUtil::Format(\"(%s) %s (%s)\", entry.left->ToString(), ExpressionTypeToOperator(entry.type),\n+\t\treturn StringUtil::Format(\"(%s %s %s)\", entry.left->ToString(), ExpressionTypeToOperator(entry.type),\n \t\t                          entry.right->ToString());\n \t}\n };\ndiff --git a/src/include/duckdb/parser/expression/function_expression.hpp b/src/include/duckdb/parser/expression/function_expression.hpp\nindex c329a0fc31bf..eb378cced9b4 100644\n--- a/src/include/duckdb/parser/expression/function_expression.hpp\n+++ b/src/include/duckdb/parser/expression/function_expression.hpp\n@@ -72,7 +72,7 @@ class FunctionExpression : public ParsedExpression {\n \t\t\t\t\treturn function_name + \"(\" + entry.children[0]->ToString() + \")\";\n \t\t\t\t}\n \t\t\t} else if (entry.children.size() == 2) {\n-\t\t\t\treturn StringUtil::Format(\"(%s) %s (%s)\", entry.children[0]->ToString(), function_name,\n+\t\t\t\treturn StringUtil::Format(\"(%s %s %s)\", entry.children[0]->ToString(), function_name,\n \t\t\t\t                          entry.children[1]->ToString());\n \t\t\t}\n \t\t}\ndiff --git a/src/parser/expression/subquery_expression.cpp b/src/parser/expression/subquery_expression.cpp\nindex 2317887a43c1..3ac2127f93a2 100644\n--- a/src/parser/expression/subquery_expression.cpp\n+++ b/src/parser/expression/subquery_expression.cpp\n@@ -13,8 +13,8 @@ SubqueryExpression::SubqueryExpression()\n string SubqueryExpression::ToString() const {\n \tswitch (subquery_type) {\n \tcase SubqueryType::ANY:\n-\t\treturn child->ToString() + \" \" + ExpressionTypeToOperator(comparison_type) + \" ANY(\" + subquery->ToString() +\n-\t\t       \")\";\n+\t\treturn \"(\" + child->ToString() + \" \" + ExpressionTypeToOperator(comparison_type) + \" ANY(\" +\n+\t\t       subquery->ToString() + \"))\";\n \tcase SubqueryType::EXISTS:\n \t\treturn \"EXISTS(\" + subquery->ToString() + \")\";\n \tcase SubqueryType::NOT_EXISTS:\n",
  "test_patch": "diff --git a/test/fuzzer/pedro/comparison_to_string.test b/test/fuzzer/pedro/comparison_to_string.test\nnew file mode 100644\nindex 000000000000..8442994df8f2\n--- /dev/null\n+++ b/test/fuzzer/pedro/comparison_to_string.test\n@@ -0,0 +1,14 @@\n+# name: test/fuzzer/pedro/comparison_to_string.test\n+# description: Issue #4827: Parsed statement differs from original result\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I nosort\n+SELECT 1 WHERE (1 IS DISTINCT FROM 1) > ANY(SELECT 2);\n+----\n+\n+query I nosort\n+SELECT 1 WHERE (1 IS DISTINCT FROM 1) IS NULL;\n+----\ndiff --git a/test/optimizer/statistics/statistics_aggregate.test b/test/optimizer/statistics/statistics_aggregate.test\nindex 3a9fc765df38..e188eaffde6c 100644\n--- a/test/optimizer/statistics/statistics_aggregate.test\n+++ b/test/optimizer/statistics/statistics_aggregate.test\n@@ -22,13 +22,13 @@ logical_opt\t<!REGEX>:.*IS_NULL.*\n query II\n EXPLAIN SELECT i=4 FROM (SELECT i FROM integers GROUP BY i) integers(i);\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) = \\(4\\).*\n+logical_opt\t<!REGEX>:.*\\(i = 4\\).*\n \n # i=3 is in range [1,3]\n query II\n EXPLAIN SELECT i=3 FROM (SELECT i FROM integers GROUP BY i) integers(i);\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) = \\(3\\).*\n+logical_opt\t<REGEX>:.*\\(i = 3\\).*\n \n # count without null values\n query I\ndiff --git a/test/optimizer/statistics/statistics_between.test b/test/optimizer/statistics/statistics_between.test\nindex df8ca6b06463..8e9915f3b2eb 100644\n--- a/test/optimizer/statistics/statistics_between.test\n+++ b/test/optimizer/statistics/statistics_between.test\n@@ -15,13 +15,13 @@ PRAGMA explain_output = OPTIMIZED_ONLY;\n query II\n EXPLAIN SELECT i=3 FROM integers WHERE i BETWEEN 0 AND 2\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) = \\(3\\).*\n+logical_opt\t<!REGEX>:.*\\(i = 3\\).*\n \n # filter is in range: need to execute it\n query II\n EXPLAIN SELECT i=1 FROM integers WHERE i BETWEEN 0 AND 2\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) = \\(1\\).*\n+logical_opt\t<REGEX>:.*\\(i = 1\\).*\n \n # between where lhs is bigger than rhs: we can prune this entirely\n query II\n@@ -50,12 +50,12 @@ SELECT * FROM integers WHERE i BETWEEN 3 AND 2;\n query II\n EXPLAIN SELECT i=3 FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 2\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) = \\(3\\).*\n+logical_opt\t<!REGEX>:.*\\(i = 3\\).*\n \n query II\n EXPLAIN SELECT i=1 FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 2\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) = \\(1\\).*\n+logical_opt\t<REGEX>:.*\\(i = 1\\).*\n \n query II\n EXPLAIN SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 3 AND 2\n@@ -72,13 +72,13 @@ logical_opt\t<!REGEX>:.*FILTER.*\n query II\n EXPLAIN SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 0 AND 2;\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) <= \\(2\\).*\n+logical_opt\t<REGEX>:.*\\(i <= 2\\).*\n \n # upper clause is always true: between should be converted into i >= 2\n query II\n EXPLAIN SELECT * FROM (SELECT * FROM integers LIMIT 10) integers(i) WHERE i BETWEEN 2 AND 10;\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) >= \\(2\\).*\n+logical_opt\t<REGEX>:.*\\(i >= 2\\).*\n \n # between is always false\n query II\ndiff --git a/test/optimizer/statistics/statistics_filter_multicolumn.test b/test/optimizer/statistics/statistics_filter_multicolumn.test\nindex ffc15207791c..a810efeb7f87 100644\n--- a/test/optimizer/statistics/statistics_filter_multicolumn.test\n+++ b/test/optimizer/statistics/statistics_filter_multicolumn.test\n@@ -18,37 +18,37 @@ PRAGMA enable_verification\n query II\n EXPLAIN SELECT i=1 FROM integers JOIN integers2 USING (i);\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) = \\(1\\).*\n+logical_opt\t<!REGEX>:.*\\(i = 1\\).*\n \n # same with i=4\n query II\n EXPLAIN SELECT i=4 FROM integers JOIN integers2 USING (i);\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) = \\(4\\).*\n+logical_opt\t<!REGEX>:.*\\(i = 4\\).*\n \n # and with i>3\n query II\n EXPLAIN SELECT i>3 FROM integers JOIN integers2 USING (i);\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) > \\(3\\).*\n+logical_opt\t<!REGEX>:.*\\(i > 3\\).*\n \n # and with i<2\n query II\n EXPLAIN SELECT i<2 FROM integers JOIN integers2 USING (i);\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) < \\(2\\).*\n+logical_opt\t<!REGEX>:.*\\(i < 2\\).*\n \n # NOT the case for i>2\n query II\n EXPLAIN SELECT i>2 FROM integers JOIN integers2 USING (i);\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) > \\(2\\).*\n+logical_opt\t<REGEX>:.*\\(i > 2\\).*\n \n # OR i<3\n query II\n EXPLAIN SELECT i<3 FROM integers JOIN integers2 USING (i);\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) < \\(3\\).*\n+logical_opt\t<REGEX>:.*\\(i < 3\\).*\n \n # range joins\n # we again join two tables with i:[1, 3] on the left, and i:[2, 4] on the right\n@@ -58,25 +58,25 @@ logical_opt\t<REGEX>:.*\\(i\\) < \\(3\\).*\n query II\n EXPLAIN SELECT i2.i=4 FROM integers i1 JOIN integers2 i2 ON (i2.i<i1.i);\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) = \\(4\\).*\n+logical_opt\t<!REGEX>:.*\\(i = 4\\).*\n \n # or i=1\n query II\n EXPLAIN SELECT i1.i=1 FROM integers i1 JOIN integers2 i2 ON (i2.i<i1.i);\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) = \\(1\\).*\n+logical_opt\t<!REGEX>:.*\\(i = 1\\).*\n \n # but not i=3\n query II\n EXPLAIN SELECT i2.i=3 FROM integers i1 JOIN integers2 i2 ON (i2.i<i1.i);\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) = \\(3\\).*\n+logical_opt\t<REGEX>:.*\\(i = 3\\).*\n \n # or i=2\n query II\n EXPLAIN SELECT i1.i=2 FROM integers i1 JOIN integers2 i2 ON (i2.i<i1.i);\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) = \\(2\\).*\n+logical_opt\t<REGEX>:.*\\(i = 2\\).*\n \n \n query I\ndiff --git a/test/optimizer/statistics/statistics_setop.test b/test/optimizer/statistics/statistics_setop.test\nindex 410e9c958923..4420ef6d9149 100644\n--- a/test/optimizer/statistics/statistics_setop.test\n+++ b/test/optimizer/statistics/statistics_setop.test\n@@ -22,13 +22,13 @@ PRAGMA explain_output = OPTIMIZED_ONLY;\n query II\n EXPLAIN SELECT i=7 FROM (SELECT * FROM integers UNION ALL SELECT * FROM integers2) tbl(i);\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) = \\(7\\).*\n+logical_opt\t<!REGEX>:.*\\(i = 7\\).*\n \n # 5 is in bounds, so this cannot be optimized away\n query II\n EXPLAIN SELECT i=5 FROM (SELECT * FROM integers UNION ALL SELECT * FROM integers2) tbl(i);\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) = \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(i = 5\\).*\n \n # neither integers nor integers2 has null values, so this is false\n query II\n@@ -48,12 +48,12 @@ logical_opt\t<REGEX>:.*IS NULL.*\n query II\n EXPLAIN SELECT i=7 FROM (SELECT * FROM integers2 EXCEPT SELECT * FROM integers3) tbl(i);\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) = \\(7\\).*\n+logical_opt\t<!REGEX>:.*\\(i = 7\\).*\n \n query II\n EXPLAIN SELECT i=5 FROM (SELECT * FROM integers2 EXCEPT SELECT * FROM integers3) tbl(i);\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) = \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(i = 5\\).*\n \n query II\n EXPLAIN SELECT i IS NULL FROM (SELECT * FROM integers2 EXCEPT SELECT * FROM integers3) tbl(i);\n@@ -67,12 +67,12 @@ logical_opt\t<!REGEX>:.*IS NULL.*\n query II\n EXPLAIN SELECT i=7 FROM (SELECT * FROM integers2 INTERSECT SELECT * FROM integers3) tbl(i);\n ----\n-logical_opt\t<!REGEX>:.*\\(i\\) = \\(7\\).*\n+logical_opt\t<!REGEX>:.*\\(i = 7\\).*\n \n query II\n EXPLAIN SELECT i=5 FROM (SELECT * FROM integers2 INTERSECT SELECT * FROM integers3) tbl(i);\n ----\n-logical_opt\t<REGEX>:.*\\(i\\) = \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(i = 5\\).*\n \n # now check the results of all these queries\n query I\ndiff --git a/test/optimizer/transitive_filters.test b/test/optimizer/transitive_filters.test\nindex 05903a64dfce..852e357a498e 100644\n--- a/test/optimizer/transitive_filters.test\n+++ b/test/optimizer/transitive_filters.test\n@@ -9,65 +9,65 @@ PRAGMA explain_output='optimized_only';\n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0=5 AND col1 >= col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) >= \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 >= 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0>5 AND col1 >= col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) > \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 > 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0>=5 AND col1 >= col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) >= \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 >= 5\\).*\n \n ### constant comparison [=, >, >=] followed by j > i #########################\n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0=5 AND col1 > col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) > \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 > 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0>5 AND col1 > col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) > \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 > 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0>=5 AND col1 > col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) > \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 > 5\\).*\n \n ### constant comparison [=, <, <=] followed by j <= i #########################\n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0=5 AND col1 <= col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) <= \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 <= 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0<5 AND col1 <= col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) < \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 < 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0<=5 AND col1 <= col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) <= \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 <= 5\\).*\n \n ### constant comparison [=, <, <=] followed by j < i #########################\n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0=5 AND col1 < col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) < \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 < 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0<5 AND col1 < col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) < \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 < 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col0<=5 AND col1 < col0\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) < \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 < 5\\).*\n \n #################################################################################################\n # Non-scalar comparisons followed by simple constant comparisons\n@@ -77,65 +77,65 @@ logical_opt\t<REGEX>:.*\\(col1\\) < \\(5\\).*\n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 >= col0 AND col0=5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) >= \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 >= 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 >= col0 AND col0>5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) > \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 > 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 >= col0 AND col0>=5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) >= \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 >= 5\\).*\n \n ### j > i followed by constant comparison [=, >, >=]  #########################\n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 > col0 AND col0=5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) > \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 > 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 > col0 AND col0>5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) > \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 > 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 > col0 AND col0>=5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) > \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 > 5\\).*\n \n ### j <= i followed by constant comparison [=, <, <=]  #########################\n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 <= col0 AND col0=5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) <= \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 <= 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 <= col0 AND col0<5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) < \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 < 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 <= col0 AND col0<=5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) <= \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 <= 5\\).*\n \n ### j < i followed by constant comparison [=, <, <=]  #########################\n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 < col0 AND col0=5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) < \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 < 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 < col0 AND col0<5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) < \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 < 5\\).*\n \n query II\n EXPLAIN SELECT * FROM (VALUES(5,5)) tbl(col0, col1) WHERE col1 < col0 AND col0<=5\n ----\n-logical_opt\t<REGEX>:.*\\(col1\\) < \\(5\\).*\n+logical_opt\t<REGEX>:.*\\(col1 < 5\\).*\n \n \n ### Complex transitive filters #################################################\n@@ -147,29 +147,29 @@ logical_opt\t<REGEX>:.*\\(col1\\) < \\(5\\).*\n query II\n EXPLAIN SELECT * FROM (VALUES(5000,5000)) tbl1(i,j), (VALUES(NULL, NULL, 5000, 5000)) tbl2(A, B, k,l) WHERE i>4999 AND j<=l AND k>=i AND l<5001\n ----\n-logical_opt\t<REGEX>:(((.*\\(col1\\) < \\(5001\\).*)(.*\\(col2\\) > \\(4999\\).*))|((.*\\(col2\\) > \\(4999\\).*)(.*\\(col1\\) < 5001.*)))\n+logical_opt\t<REGEX>:(((.*\\(col1 < 5001\\).*)(.*\\(col2 > 4999\\).*))|((.*\\(col2 > 4999\\).*)(.*\\(col1\\) < 5001.*)))\n \n #check for the transivity j > 4999 and k > 4999\n query II\n EXPLAIN SELECT * FROM (VALUES(5000,5000)) tbl1(i,j), (VALUES(NULL, NULL, 5000, 5000)) tbl2(A, B, k,l) WHERE i>4999 AND j>=i AND k>=j\n ----\n-logical_opt\t<REGEX>:(((.*\\(col1\\) > \\(4999\\).*)(.*\\(col2\\) > \\(4999\\).*))|((.*\\(col2\\) > \\(4999\\).*)(.*\\(col1\\) > \\(4999\\).*)))\n+logical_opt\t<REGEX>:(((.*\\(col1 > 4999\\).*)(.*\\(col2 > 4999\\).*))|((.*\\(col2 > 4999\\).*)(.*\\(col1 > 4999\\).*)))\n \n #check for the transivity j > 4999 and k > 4999\n query II\n EXPLAIN SELECT * FROM (VALUES(5000,5000)) tbl1(i,j), (VALUES(NULL, NULL, 5000, 5000)) tbl2(A, B, k,l) WHERE i>4999 AND k>=j AND j>=i\n ----\n-logical_opt\t<REGEX>:(((.*\\(col1\\) > \\(4999\\).*)(.*\\(col2\\) > \\(4999\\).*))|((.*\\(col2\\) > \\(4999\\).*)(.*\\(col1\\) > \\(4999\\).*)))\n+logical_opt\t<REGEX>:(((.*\\(col1 > 4999\\).*)(.*\\(col2 > 4999\\).*))|((.*\\(col2 > 4999\\).*)(.*\\(col1 > 4999\\).*)))\n \n #check for the transivity j > 4999 and k > 4999 and l > 4999\n query II\n EXPLAIN SELECT * FROM (VALUES(5000,5000)) tbl1(i,j), (VALUES(NULL, NULL, 5000, 5000)) tbl2(A, B, k,l) WHERE i>4999 AND k>=j AND j>=i AND l>=k\n ----\n-logical_opt\t<REGEX>:((.*\\(col2\\) > \\(4999\\).*)(.*\\(col3\\) > \\(4999\\).*)|(.*\\(col3\\) > \\(4999\\).*)(.*\\(col2\\) > \\(4999\\).*))\n+logical_opt\t<REGEX>:((.*\\(col2 > 4999\\).*)(.*\\(col3 > 4999\\).*)|(.*\\(col3 > 4999\\).*)(.*\\(col2 > 4999\\).*))\n \n #check for the transivity j < 4999 and k < 4999 and l < 4999\n query II\n EXPLAIN SELECT * FROM (VALUES(5000,5000)) tbl1(i,j), (VALUES(NULL, NULL, 5000, 5000)) tbl2(A, B, k,l) WHERE i<4999 AND k<=j AND j<=i AND l<=k\n ----\n-logical_opt\t<REGEX>:((.*\\(col2\\) < \\(4999\\).*)(.*\\(col3\\) < \\(4999\\).*)|(.*\\(col3\\) < \\(4999\\).*)(.*\\(col2\\) < \\(4999\\).*))\n+logical_opt\t<REGEX>:((.*\\(col2 < 4999\\).*)(.*\\(col3 < 4999\\).*)|(.*\\(col3 < 4999\\).*)(.*\\(col2 < 4999\\).*))\n \ndiff --git a/test/sqlsmith/sql_reduce.test b/test/sqlsmith/sql_reduce.test\nindex 524dc564c114..1f2b1ec48216 100644\n--- a/test/sqlsmith/sql_reduce.test\n+++ b/test/sqlsmith/sql_reduce.test\n@@ -33,15 +33,15 @@ INSERT INTO tbl SELECT NULL FROM (VALUES (1, 2))\n query I\n SELECT * FROM reduce_sql_statement('UPDATE tbl SET i=3, j=4 WHERE z=5') ORDER BY 1\n ----\n-UPDATE tbl SET i=3 WHERE (z) = (5)\n+UPDATE tbl SET i=3 WHERE (z = 5)\n UPDATE tbl SET i=3, j=4\n UPDATE tbl SET i=3, j=4 WHERE NULL\n-UPDATE tbl SET j=4 WHERE (z) = (5)\n+UPDATE tbl SET j=4 WHERE (z = 5)\n \n query I\n SELECT * FROM reduce_sql_statement('DELETE FROM a WHERE i >= 2000 AND i < 5000;') ORDER BY 1\n ----\n DELETE FROM a\n-DELETE FROM a WHERE (i) < (5000)\n-DELETE FROM a WHERE (i) >= (2000)\n+DELETE FROM a WHERE (i < 5000)\n+DELETE FROM a WHERE (i >= 2000)\n DELETE FROM a WHERE NULL\ndiff --git a/tools/pythonpkg/tests/fast/test_relation.py b/tools/pythonpkg/tests/fast/test_relation.py\nindex c3581abe68e6..b6b7cf855675 100644\n--- a/tools/pythonpkg/tests/fast/test_relation.py\n+++ b/tools/pythonpkg/tests/fast/test_relation.py\n@@ -198,7 +198,7 @@ def test_explain(self, duckdb_cursor):\n         rel1 = con.table('t1')\n         rel2 = con.table('t2')\n         join = rel1.join(rel2, 'i=j', 'inner').aggregate('count()')\n-        assert join.explain() == 'Aggregate [count_star()]\\n  Join INNER (i) = (j)\\n    Scan Table [t1]\\n    Scan Table [t2]'\n+        assert join.explain() == 'Aggregate [count_star()]\\n  Join INNER (i = j)\\n    Scan Table [t1]\\n    Scan Table [t2]'\n \n     def test_fetchnumpy(self, duckdb_cursor):\n         start, stop = -1000, 2000\n",
  "problem_statement": "[Fuzzer] Parsed statement differs from original result\n### What happens?\n\nUsing the C++ API\r\n\r\nDuckDB db(nullptr);\r\nConnection con(db);\r\ncon.EnableQueryVerification();\r\ncon.SendQuery(\"SELECT 1 WHERE (1 IS DISTINCT FROM 1) > ANY(SELECT 2);\");\r\n\r\nGives: Invalid Error: Parsed statement differs from original result!\r\n\r\nI have the fix for this. I am going to make a pull request in a few minutes.\n\n### To Reproduce\n\nRun the statements above.\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\nlatest from sources\n\n### DuckDB Client:\n\nC/C++ API\n\n### Full Name:\n\nPedro Ferreira\n\n### Affiliation:\n\nHuawei\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2022-09-28T15:46:41Z"
}