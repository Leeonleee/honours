diff --git a/extension/parquet/column_reader.cpp b/extension/parquet/column_reader.cpp
index 02eaa3e8badb..9e4b76f94d6b 100644
--- a/extension/parquet/column_reader.cpp
+++ b/extension/parquet/column_reader.cpp
@@ -18,6 +18,7 @@
 
 #include "duckdb.hpp"
 #ifndef DUCKDB_AMALGAMATION
+#include "duckdb/common/types/blob.hpp"
 #include "duckdb/common/types/chunk_collection.hpp"
 #endif
 
@@ -344,16 +345,24 @@ void ColumnReader::Skip(idx_t num_values) {
 	}
 }
 
-void StringColumnReader::VerifyString(const char *str_data, idx_t str_len) {
+uint32_t StringColumnReader::VerifyString(const char *str_data, uint32_t str_len) {
 	if (Type() != LogicalTypeId::VARCHAR) {
-		return;
+		return str_len;
 	}
 	// verify if a string is actually UTF8, and if there are no null bytes in the middle of the string
 	// technically Parquet should guarantee this, but reality is often disappointing
-	auto utf_type = Utf8Proc::Analyze(str_data, str_len);
+	UnicodeInvalidReason reason;
+	size_t pos;
+	auto utf_type = Utf8Proc::Analyze(str_data, str_len, &reason, &pos);
 	if (utf_type == UnicodeType::INVALID) {
-		throw InternalException("Invalid string encoding found in Parquet file: value is not valid UTF8!");
+		if (reason == UnicodeInvalidReason::NULL_BYTE) {
+			// for null bytes we just truncate the string
+			return pos;
+		}
+		throw InvalidInputException("Invalid string encoding found in Parquet file: value \"" +
+		                            Blob::ToString(string_t(str_data, str_len)) + "\" is not valid UTF8!");
 	}
+	return str_len;
 }
 
 void StringColumnReader::Dictionary(shared_ptr<ByteBuffer> data, idx_t num_entries) {
@@ -363,8 +372,8 @@ void StringColumnReader::Dictionary(shared_ptr<ByteBuffer> data, idx_t num_entri
 		uint32_t str_len = dict->read<uint32_t>();
 		dict->available(str_len);
 
-		VerifyString(dict->ptr, str_len);
-		dict_strings[dict_idx] = string_t(dict->ptr, str_len);
+		auto actual_str_len = VerifyString(dict->ptr, str_len);
+		dict_strings[dict_idx] = string_t(dict->ptr, actual_str_len);
 		dict->inc(str_len);
 	}
 }
@@ -395,8 +404,8 @@ string_t StringParquetValueConversion::PlainRead(ByteBuffer &plain_data, ColumnR
 	auto &scr = ((StringColumnReader &)reader);
 	uint32_t str_len = scr.fixed_width_string_length == 0 ? plain_data.read<uint32_t>() : scr.fixed_width_string_length;
 	plain_data.available(str_len);
-	((StringColumnReader &)reader).VerifyString(plain_data.ptr, str_len);
-	auto ret_str = string_t(plain_data.ptr, str_len);
+	auto actual_str_len = ((StringColumnReader &)reader).VerifyString(plain_data.ptr, str_len);
+	auto ret_str = string_t(plain_data.ptr, actual_str_len);
 	plain_data.inc(str_len);
 	return ret_str;
 }
diff --git a/extension/parquet/include/string_column_reader.hpp b/extension/parquet/include/string_column_reader.hpp
index d143fa4cd28a..7c53fd6b272c 100644
--- a/extension/parquet/include/string_column_reader.hpp
+++ b/extension/parquet/include/string_column_reader.hpp
@@ -36,7 +36,7 @@ class StringColumnReader : public TemplatedColumnReader<string_t, StringParquetV
 	void Dictionary(shared_ptr<ByteBuffer> dictionary_data, idx_t num_entries) override;
 
 	unique_ptr<string_t[]> dict_strings;
-	void VerifyString(const char *str_data, idx_t str_len);
+	uint32_t VerifyString(const char *str_data, uint32_t str_len);
 	idx_t fixed_width_string_length;
 
 protected:
diff --git a/src/main/materialized_query_result.cpp b/src/main/materialized_query_result.cpp
index 181172a0df82..fe74d24f6b26 100644
--- a/src/main/materialized_query_result.cpp
+++ b/src/main/materialized_query_result.cpp
@@ -48,7 +48,7 @@ unique_ptr<DataChunk> MaterializedQueryResult::Fetch() {
 
 unique_ptr<DataChunk> MaterializedQueryResult::FetchRaw() {
 	if (!success) {
-		throw InvalidInputException("Attempting to fetch from an unsuccessful query result");
+		throw InvalidInputException("Attempting to fetch from an unsuccessful query result
Error: %s", error);
 	}
 	return collection.Fetch();
 }
diff --git a/src/main/stream_query_result.cpp b/src/main/stream_query_result.cpp
index 24dbb453f6f1..7241da97d75a 100644
--- a/src/main/stream_query_result.cpp
+++ b/src/main/stream_query_result.cpp
@@ -29,7 +29,8 @@ string StreamQueryResult::ToString() {
 
 unique_ptr<DataChunk> StreamQueryResult::FetchRaw() {
 	if (!success || !is_open) {
-		throw InvalidInputException("Attempting to fetch from an unsuccessful or closed streaming query result");
+		throw InvalidInputException(
+		    "Attempting to fetch from an unsuccessful or closed streaming query result
Error: %s", error);
 	}
 	auto chunk = context->Fetch();
 	if (!chunk || chunk->ColumnCount() == 0 || chunk->size() == 0) {
diff --git a/third_party/utf8proc/include/utf8proc_wrapper.hpp b/third_party/utf8proc/include/utf8proc_wrapper.hpp
index 94e0da5e1728..0190476cbf42 100644
--- a/third_party/utf8proc/include/utf8proc_wrapper.hpp
+++ b/third_party/utf8proc/include/utf8proc_wrapper.hpp
@@ -6,13 +6,13 @@
 
 namespace duckdb {
 
-enum class UnicodeType {INVALID, ASCII, UNICODE};
-
+enum class UnicodeType { INVALID, ASCII, UNICODE };
+enum class UnicodeInvalidReason { BYTE_MISMATCH, NULL_BYTE };
 
 class Utf8Proc {
 public:
 	//! Distinguishes ASCII, Valid UTF8 and Invalid UTF8 strings
-	static UnicodeType Analyze(const char *s, size_t len);
+	static UnicodeType Analyze(const char *s, size_t len, UnicodeInvalidReason *invalid_reason = nullptr, size_t *invalid_pos = nullptr);
 	//! Performs UTF NFC normalization of string, return value needs to be free'd
 	static char* Normalize(const char* s, size_t len);
 	//! Returns whether or not the UTF8 string is valid
@@ -28,7 +28,7 @@ class Utf8Proc {
 	static int CodepointLength(int cp);
 	//! Transform a UTF8 string to a codepoint; returns the codepoint and writes the length of the codepoint (in UTF8) to sz
 	static int32_t UTF8ToCodepoint(const char *c, int &sz);
-    static size_t RenderWidth(const char *s, size_t len, size_t pos);
+	static size_t RenderWidth(const char *s, size_t len, size_t pos);
 
 };
 
diff --git a/third_party/utf8proc/utf8proc_wrapper.cpp b/third_party/utf8proc/utf8proc_wrapper.cpp
index bfb41bcc935d..3dde822dfe09 100644
--- a/third_party/utf8proc/utf8proc_wrapper.cpp
+++ b/third_party/utf8proc/utf8proc_wrapper.cpp
@@ -21,30 +21,51 @@ namespace duckdb {
 //	3	U+000800	U+00FFFF		1110xxxx
 //	4	U+010000	U+10FFFF		11110xxx
 
-UnicodeType Utf8Proc::Analyze(const char *s, size_t len) {
+static void AssignInvalidUTF8Reason(UnicodeInvalidReason *invalid_reason, size_t *invalid_pos, size_t pos, UnicodeInvalidReason reason) {
+	if (invalid_reason) {
+		*invalid_reason = reason;
+	}
+	if (invalid_pos) {
+		*invalid_pos = pos;
+	}
+}
+
+UnicodeType Utf8Proc::Analyze(const char *s, size_t len, UnicodeInvalidReason *invalid_reason, size_t *invalid_pos) {
 	UnicodeType type = UnicodeType::ASCII;
 	char c;
 	for (size_t i = 0; i < len; i++) {
 		c = s[i];
 		if (c == '\0') {
+			AssignInvalidUTF8Reason(invalid_reason, invalid_pos, i, UnicodeInvalidReason::NULL_BYTE);
 			return UnicodeType::INVALID;
 		}
 		// 1 Byte / ASCII
-		if ((c & 0x80) == 0)
+		if ((c & 0x80) == 0) {
 			continue;
+		}
 		type = UnicodeType::UNICODE;
-		if ((s[++i] & 0xC0) != 0x80)
+		if ((s[++i] & 0xC0) != 0x80) {
+			AssignInvalidUTF8Reason(invalid_reason, invalid_pos, i, UnicodeInvalidReason::BYTE_MISMATCH);
 			return UnicodeType::INVALID;
-		if ((c & 0xE0) == 0xC0)
+		}
+		if ((c & 0xE0) == 0xC0) {
 			continue;
-		if ((s[++i] & 0xC0) != 0x80)
+		}
+		if ((s[++i] & 0xC0) != 0x80) {
+			AssignInvalidUTF8Reason(invalid_reason, invalid_pos, i, UnicodeInvalidReason::BYTE_MISMATCH);
 			return UnicodeType::INVALID;
-		if ((c & 0xF0) == 0xE0)
+		}
+		if ((c & 0xF0) == 0xE0) {
 			continue;
-		if ((s[++i] & 0xC0) != 0x80)
+		}
+		if ((s[++i] & 0xC0) != 0x80) {
+			AssignInvalidUTF8Reason(invalid_reason, invalid_pos, i, UnicodeInvalidReason::BYTE_MISMATCH);
 			return UnicodeType::INVALID;
-		if ((c & 0xF8) == 0xF0)
+		}
+		if ((c & 0xF8) == 0xF0) {
 			continue;
+		}
+		AssignInvalidUTF8Reason(invalid_reason, invalid_pos, i, UnicodeInvalidReason::BYTE_MISMATCH);
 		return UnicodeType::INVALID;
 	}
 
