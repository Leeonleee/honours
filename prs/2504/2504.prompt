You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
`AVG` result has low precision
Function `avg` computes an average that might not be precise if dealing with a large amount of numbers or with numbers in different scales. I am guessing it might be calculating a simple sum with `double` types and dividing by the number of elements, which can make the results inaccurace.

Example in R:
```r
library(DBI)
library(duckdb)
df = data.frame(col1 = c(2^53, 1, 1, 0))
conn = dbConnect(duckdb::duckdb(), dbdir=":memory:", read_only=FALSE)
duckdb_register(conn, "df", df)
res = dbGetQuery(conn, "SELECT avg(col1) from df")
sprintf("%.2f", res)
```
```
[1] "2251799813685248.00"
```

Correct result:
```r
sprintf("%.2f", mean(df$col1))
```
```
[1] "2251799813685248.50"
```

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/common/types/hugeint.cpp]
1: #include "duckdb/common/types/hugeint.hpp"
2: #include "duckdb/common/exception.hpp"
3: #include "duckdb/common/algorithm.hpp"
4: #include "duckdb/common/limits.hpp"
5: #include "duckdb/common/windows_undefs.hpp"
6: 
7: #include <cmath>
8: #include <limits>
9: 
10: namespace duckdb {
11: 
12: //===--------------------------------------------------------------------===//
13: // String Conversion
14: //===--------------------------------------------------------------------===//
15: const hugeint_t Hugeint::POWERS_OF_TEN[] {
16:     hugeint_t(1),
17:     hugeint_t(10),
18:     hugeint_t(100),
19:     hugeint_t(1000),
20:     hugeint_t(10000),
21:     hugeint_t(100000),
22:     hugeint_t(1000000),
23:     hugeint_t(10000000),
24:     hugeint_t(100000000),
25:     hugeint_t(1000000000),
26:     hugeint_t(10000000000),
27:     hugeint_t(100000000000),
28:     hugeint_t(1000000000000),
29:     hugeint_t(10000000000000),
30:     hugeint_t(100000000000000),
31:     hugeint_t(1000000000000000),
32:     hugeint_t(10000000000000000),
33:     hugeint_t(100000000000000000),
34:     hugeint_t(1000000000000000000),
35:     hugeint_t(1000000000000000000) * hugeint_t(10),
36:     hugeint_t(1000000000000000000) * hugeint_t(100),
37:     hugeint_t(1000000000000000000) * hugeint_t(1000),
38:     hugeint_t(1000000000000000000) * hugeint_t(10000),
39:     hugeint_t(1000000000000000000) * hugeint_t(100000),
40:     hugeint_t(1000000000000000000) * hugeint_t(1000000),
41:     hugeint_t(1000000000000000000) * hugeint_t(10000000),
42:     hugeint_t(1000000000000000000) * hugeint_t(100000000),
43:     hugeint_t(1000000000000000000) * hugeint_t(1000000000),
44:     hugeint_t(1000000000000000000) * hugeint_t(10000000000),
45:     hugeint_t(1000000000000000000) * hugeint_t(100000000000),
46:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000),
47:     hugeint_t(1000000000000000000) * hugeint_t(10000000000000),
48:     hugeint_t(1000000000000000000) * hugeint_t(100000000000000),
49:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000),
50:     hugeint_t(1000000000000000000) * hugeint_t(10000000000000000),
51:     hugeint_t(1000000000000000000) * hugeint_t(100000000000000000),
52:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000000),
53:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000000) * hugeint_t(10),
54:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000000) * hugeint_t(100)};
55: 
56: static uint8_t PositiveHugeintHighestBit(hugeint_t bits) {
57: 	uint8_t out = 0;
58: 	if (bits.upper) {
59: 		out = 64;
60: 		uint64_t up = bits.upper;
61: 		while (up) {
62: 			up >>= 1;
63: 			out++;
64: 		}
65: 	} else {
66: 		uint64_t low = bits.lower;
67: 		while (low) {
68: 			low >>= 1;
69: 			out++;
70: 		}
71: 	}
72: 	return out;
73: }
74: 
75: static bool PositiveHugeintIsBitSet(hugeint_t lhs, uint8_t bit_position) {
76: 	if (bit_position < 64) {
77: 		return lhs.lower & (uint64_t(1) << uint64_t(bit_position));
78: 	} else {
79: 		return lhs.upper & (uint64_t(1) << uint64_t(bit_position - 64));
80: 	}
81: }
82: 
83: hugeint_t PositiveHugeintLeftShift(hugeint_t lhs, uint32_t amount) {
84: 	D_ASSERT(amount > 0 && amount < 64);
85: 	hugeint_t result;
86: 	result.lower = lhs.lower << amount;
87: 	result.upper = (lhs.upper << amount) + (lhs.lower >> (64 - amount));
88: 	return result;
89: }
90: 
91: hugeint_t Hugeint::DivModPositive(hugeint_t lhs, uint64_t rhs, uint64_t &remainder) {
92: 	D_ASSERT(lhs.upper >= 0);
93: 	// DivMod code adapted from:
94: 	// https://github.com/calccrypto/uint128_t/blob/master/uint128_t.cpp
95: 
96: 	// initialize the result and remainder to 0
97: 	hugeint_t div_result;
98: 	div_result.lower = 0;
99: 	div_result.upper = 0;
100: 	remainder = 0;
101: 
102: 	uint8_t highest_bit_set = PositiveHugeintHighestBit(lhs);
103: 	// now iterate over the amount of bits that are set in the LHS
104: 	for (uint8_t x = highest_bit_set; x > 0; x--) {
105: 		// left-shift the current result and remainder by 1
106: 		div_result = PositiveHugeintLeftShift(div_result, 1);
107: 		remainder <<= 1;
108: 		// we get the value of the bit at position X, where position 0 is the least-significant bit
109: 		if (PositiveHugeintIsBitSet(lhs, x - 1)) {
110: 			// increment the remainder
111: 			remainder++;
112: 		}
113: 		if (remainder >= rhs) {
114: 			// the remainder has passed the division multiplier: add one to the divide result
115: 			remainder -= rhs;
116: 			div_result.lower++;
117: 			if (div_result.lower == 0) {
118: 				// overflow
119: 				div_result.upper++;
120: 			}
121: 		}
122: 	}
123: 	return div_result;
124: }
125: 
126: string Hugeint::ToString(hugeint_t input) {
127: 	uint64_t remainder;
128: 	string result;
129: 	bool negative = input.upper < 0;
130: 	if (negative) {
131: 		NegateInPlace(input);
132: 	}
133: 	while (true) {
134: 		if (!input.lower && !input.upper) {
135: 			break;
136: 		}
137: 		input = Hugeint::DivModPositive(input, 10, remainder);
138: 		result = string(1, '0' + remainder) + result; // NOLINT
139: 	}
140: 	if (result.empty()) {
141: 		// value is zero
142: 		return "0";
143: 	}
144: 	return negative ? "-" + result : result;
145: }
146: 
147: //===--------------------------------------------------------------------===//
148: // Multiply
149: //===--------------------------------------------------------------------===//
150: bool Hugeint::TryMultiply(hugeint_t lhs, hugeint_t rhs, hugeint_t &result) {
151: 	bool lhs_negative = lhs.upper < 0;
152: 	bool rhs_negative = rhs.upper < 0;
153: 	if (lhs_negative) {
154: 		NegateInPlace(lhs);
155: 	}
156: 	if (rhs_negative) {
157: 		NegateInPlace(rhs);
158: 	}
159: #if ((__GNUC__ >= 5) || defined(__clang__)) && defined(__SIZEOF_INT128__)
160: 	__uint128_t left = __uint128_t(lhs.lower) + (__uint128_t(lhs.upper) << 64);
161: 	__uint128_t right = __uint128_t(rhs.lower) + (__uint128_t(rhs.upper) << 64);
162: 	__uint128_t result_i128;
163: 	if (__builtin_mul_overflow(left, right, &result_i128)) {
164: 		return false;
165: 	}
166: 	uint64_t upper = uint64_t(result_i128 >> 64);
167: 	if (upper & 0x8000000000000000) {
168: 		return false;
169: 	}
170: 	result.upper = int64_t(upper);
171: 	result.lower = uint64_t(result_i128 & 0xffffffffffffffff);
172: #else
173: 	// Multiply code adapted from:
174: 	// https://github.com/calccrypto/uint128_t/blob/master/uint128_t.cpp
175: 
176: 	// split values into 4 32-bit parts
177: 	uint64_t top[4] = {uint64_t(lhs.upper) >> 32, uint64_t(lhs.upper) & 0xffffffff, lhs.lower >> 32,
178: 	                   lhs.lower & 0xffffffff};
179: 	uint64_t bottom[4] = {uint64_t(rhs.upper) >> 32, uint64_t(rhs.upper) & 0xffffffff, rhs.lower >> 32,
180: 	                      rhs.lower & 0xffffffff};
181: 	uint64_t products[4][4];
182: 
183: 	// multiply each component of the values
184: 	for (auto x = 0; x < 4; x++) {
185: 		for (auto y = 0; y < 4; y++) {
186: 			products[x][y] = top[x] * bottom[y];
187: 		}
188: 	}
189: 
190: 	// if any of these products are set to a non-zero value, there is always an overflow
191: 	if (products[0][0] || products[0][1] || products[0][2] || products[1][0] || products[2][0] || products[1][1]) {
192: 		return false;
193: 	}
194: 	// if the high bits of any of these are set, there is always an overflow
195: 	if ((products[0][3] & 0xffffffff80000000) || (products[1][2] & 0xffffffff80000000) ||
196: 	    (products[2][1] & 0xffffffff80000000) || (products[3][0] & 0xffffffff80000000)) {
197: 		return false;
198: 	}
199: 
200: 	// otherwise we merge the result of the different products together in-order
201: 
202: 	// first row
203: 	uint64_t fourth32 = (products[3][3] & 0xffffffff);
204: 	uint64_t third32 = (products[3][2] & 0xffffffff) + (products[3][3] >> 32);
205: 	uint64_t second32 = (products[3][1] & 0xffffffff) + (products[3][2] >> 32);
206: 	uint64_t first32 = (products[3][0] & 0xffffffff) + (products[3][1] >> 32);
207: 
208: 	// second row
209: 	third32 += (products[2][3] & 0xffffffff);
210: 	second32 += (products[2][2] & 0xffffffff) + (products[2][3] >> 32);
211: 	first32 += (products[2][1] & 0xffffffff) + (products[2][2] >> 32);
212: 
213: 	// third row
214: 	second32 += (products[1][3] & 0xffffffff);
215: 	first32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
216: 
217: 	// fourth row
218: 	first32 += (products[0][3] & 0xffffffff);
219: 
220: 	// move carry to next digit
221: 	third32 += fourth32 >> 32;
222: 	second32 += third32 >> 32;
223: 	first32 += second32 >> 32;
224: 
225: 	// check if the combination of the different products resulted in an overflow
226: 	if (first32 & 0xffffff80000000) {
227: 		return false;
228: 	}
229: 
230: 	// remove carry from current digit
231: 	fourth32 &= 0xffffffff;
232: 	third32 &= 0xffffffff;
233: 	second32 &= 0xffffffff;
234: 	first32 &= 0xffffffff;
235: 
236: 	// combine components
237: 	result.lower = (third32 << 32) | fourth32;
238: 	result.upper = (first32 << 32) | second32;
239: #endif
240: 	if (lhs_negative ^ rhs_negative) {
241: 		NegateInPlace(result);
242: 	}
243: 	return true;
244: }
245: 
246: hugeint_t Hugeint::Multiply(hugeint_t lhs, hugeint_t rhs) {
247: 	hugeint_t result;
248: 	if (!TryMultiply(lhs, rhs, result)) {
249: 		throw OutOfRangeException("Overflow in HUGEINT multiplication!");
250: 	}
251: 	return result;
252: }
253: 
254: //===--------------------------------------------------------------------===//
255: // Divide
256: //===--------------------------------------------------------------------===//
257: hugeint_t Hugeint::DivMod(hugeint_t lhs, hugeint_t rhs, hugeint_t &remainder) {
258: 	// division by zero not allowed
259: 	D_ASSERT(!(rhs.upper == 0 && rhs.lower == 0));
260: 
261: 	bool lhs_negative = lhs.upper < 0;
262: 	bool rhs_negative = rhs.upper < 0;
263: 	if (lhs_negative) {
264: 		Hugeint::NegateInPlace(lhs);
265: 	}
266: 	if (rhs_negative) {
267: 		Hugeint::NegateInPlace(rhs);
268: 	}
269: 	// DivMod code adapted from:
270: 	// https://github.com/calccrypto/uint128_t/blob/master/uint128_t.cpp
271: 
272: 	// initialize the result and remainder to 0
273: 	hugeint_t div_result;
274: 	div_result.lower = 0;
275: 	div_result.upper = 0;
276: 	remainder.lower = 0;
277: 	remainder.upper = 0;
278: 
279: 	uint8_t highest_bit_set = PositiveHugeintHighestBit(lhs);
280: 	// now iterate over the amount of bits that are set in the LHS
281: 	for (uint8_t x = highest_bit_set; x > 0; x--) {
282: 		// left-shift the current result and remainder by 1
283: 		div_result = PositiveHugeintLeftShift(div_result, 1);
284: 		remainder = PositiveHugeintLeftShift(remainder, 1);
285: 
286: 		// we get the value of the bit at position X, where position 0 is the least-significant bit
287: 		if (PositiveHugeintIsBitSet(lhs, x - 1)) {
288: 			// increment the remainder
289: 			Hugeint::AddInPlace(remainder, 1);
290: 		}
291: 		if (Hugeint::GreaterThanEquals(remainder, rhs)) {
292: 			// the remainder has passed the division multiplier: add one to the divide result
293: 			remainder = Hugeint::Subtract(remainder, rhs);
294: 			Hugeint::AddInPlace(div_result, 1);
295: 		}
296: 	}
297: 	if (lhs_negative ^ rhs_negative) {
298: 		Hugeint::NegateInPlace(div_result);
299: 	}
300: 	if (lhs_negative) {
301: 		Hugeint::NegateInPlace(remainder);
302: 	}
303: 	return div_result;
304: }
305: 
306: hugeint_t Hugeint::Divide(hugeint_t lhs, hugeint_t rhs) {
307: 	hugeint_t remainder;
308: 	return Hugeint::DivMod(lhs, rhs, remainder);
309: }
310: 
311: hugeint_t Hugeint::Modulo(hugeint_t lhs, hugeint_t rhs) {
312: 	hugeint_t remainder;
313: 	Hugeint::DivMod(lhs, rhs, remainder);
314: 	return remainder;
315: }
316: 
317: //===--------------------------------------------------------------------===//
318: // Add/Subtract
319: //===--------------------------------------------------------------------===//
320: bool Hugeint::AddInPlace(hugeint_t &lhs, hugeint_t rhs) {
321: 	int overflow = lhs.lower + rhs.lower < lhs.lower;
322: 	if (rhs.upper >= 0) {
323: 		// RHS is positive: check for overflow
324: 		if (lhs.upper > (std::numeric_limits<int64_t>::max() - rhs.upper - overflow)) {
325: 			return false;
326: 		}
327: 		lhs.upper = lhs.upper + overflow + rhs.upper;
328: 	} else {
329: 		// RHS is negative: check for underflow
330: 		if (lhs.upper < std::numeric_limits<int64_t>::min() - rhs.upper - overflow) {
331: 			return false;
332: 		}
333: 		lhs.upper = lhs.upper + (overflow + rhs.upper);
334: 	}
335: 	lhs.lower += rhs.lower;
336: 	if (lhs.upper == std::numeric_limits<int64_t>::min() && lhs.lower == 0) {
337: 		return false;
338: 	}
339: 	return true;
340: }
341: 
342: bool Hugeint::SubtractInPlace(hugeint_t &lhs, hugeint_t rhs) {
343: 	// underflow
344: 	int underflow = lhs.lower - rhs.lower > lhs.lower;
345: 	if (rhs.upper >= 0) {
346: 		// RHS is positive: check for underflow
347: 		if (lhs.upper < (std::numeric_limits<int64_t>::min() + rhs.upper + underflow)) {
348: 			return false;
349: 		}
350: 		lhs.upper = (lhs.upper - rhs.upper) - underflow;
351: 	} else {
352: 		// RHS is negative: check for overflow
353: 		if (lhs.upper > std::numeric_limits<int64_t>::min() &&
354: 		    lhs.upper - 1 >= (std::numeric_limits<int64_t>::max() + rhs.upper + underflow)) {
355: 			return false;
356: 		}
357: 		lhs.upper = lhs.upper - (rhs.upper + underflow);
358: 	}
359: 	lhs.lower -= rhs.lower;
360: 	if (lhs.upper == std::numeric_limits<int64_t>::min() && lhs.lower == 0) {
361: 		return false;
362: 	}
363: 	return true;
364: }
365: 
366: hugeint_t Hugeint::Add(hugeint_t lhs, hugeint_t rhs) {
367: 	if (!AddInPlace(lhs, rhs)) {
368: 		throw OutOfRangeException("Overflow in HUGEINT addition");
369: 	}
370: 	return lhs;
371: }
372: 
373: hugeint_t Hugeint::Subtract(hugeint_t lhs, hugeint_t rhs) {
374: 	if (!SubtractInPlace(lhs, rhs)) {
375: 		throw OutOfRangeException("Underflow in HUGEINT addition");
376: 	}
377: 	return lhs;
378: }
379: 
380: //===--------------------------------------------------------------------===//
381: // Hugeint Cast/Conversion
382: //===--------------------------------------------------------------------===//
383: template <class DST, bool SIGNED = true>
384: bool HugeintTryCastInteger(hugeint_t input, DST &result) {
385: 	switch (input.upper) {
386: 	case 0:
387: 		// positive number: check if the positive number is in range
388: 		if (input.lower <= uint64_t(NumericLimits<DST>::Maximum())) {
389: 			result = DST(input.lower);
390: 			return true;
391: 		}
392: 		break;
393: 	case -1:
394: 		if (!SIGNED) {
395: 			return false;
396: 		}
397: 		// negative number: check if the negative number is in range
398: 		if (input.lower >= NumericLimits<uint64_t>::Maximum() - uint64_t(NumericLimits<DST>::Maximum())) {
399: 			result = -DST(NumericLimits<uint64_t>::Maximum() - input.lower) - 1;
400: 			return true;
401: 		}
402: 		break;
403: 	default:
404: 		break;
405: 	}
406: 	return false;
407: }
408: 
409: template <>
410: bool Hugeint::TryCast(hugeint_t input, int8_t &result) {
411: 	return HugeintTryCastInteger<int8_t>(input, result);
412: }
413: 
414: template <>
415: bool Hugeint::TryCast(hugeint_t input, int16_t &result) {
416: 	return HugeintTryCastInteger<int16_t>(input, result);
417: }
418: 
419: template <>
420: bool Hugeint::TryCast(hugeint_t input, int32_t &result) {
421: 	return HugeintTryCastInteger<int32_t>(input, result);
422: }
423: 
424: template <>
425: bool Hugeint::TryCast(hugeint_t input, int64_t &result) {
426: 	return HugeintTryCastInteger<int64_t>(input, result);
427: }
428: 
429: template <>
430: bool Hugeint::TryCast(hugeint_t input, uint8_t &result) {
431: 	return HugeintTryCastInteger<uint8_t, false>(input, result);
432: }
433: 
434: template <>
435: bool Hugeint::TryCast(hugeint_t input, uint16_t &result) {
436: 	return HugeintTryCastInteger<uint16_t, false>(input, result);
437: }
438: 
439: template <>
440: bool Hugeint::TryCast(hugeint_t input, uint32_t &result) {
441: 	return HugeintTryCastInteger<uint32_t, false>(input, result);
442: }
443: 
444: template <>
445: bool Hugeint::TryCast(hugeint_t input, uint64_t &result) {
446: 	return HugeintTryCastInteger<uint64_t, false>(input, result);
447: }
448: 
449: template <>
450: bool Hugeint::TryCast(hugeint_t input, hugeint_t &result) {
451: 	result = input;
452: 	return true;
453: }
454: 
455: template <>
456: bool Hugeint::TryCast(hugeint_t input, float &result) {
457: 	double dbl_result;
458: 	Hugeint::TryCast(input, dbl_result);
459: 	result = (float)dbl_result;
460: 	return true;
461: }
462: 
463: template <>
464: bool Hugeint::TryCast(hugeint_t input, double &result) {
465: 	switch (input.upper) {
466: 	case -1:
467: 		// special case for upper = -1 to avoid rounding issues in small negative numbers
468: 		result = -double(NumericLimits<uint64_t>::Maximum() - input.lower) - 1;
469: 		break;
470: 	default:
471: 		result = double(input.lower) + double(input.upper) * double(NumericLimits<uint64_t>::Maximum());
472: 		break;
473: 	}
474: 	return true;
475: }
476: 
477: template <class DST>
478: hugeint_t HugeintConvertInteger(DST input) {
479: 	hugeint_t result;
480: 	result.lower = (uint64_t)input;
481: 	result.upper = (input < 0) * -1;
482: 	return result;
483: }
484: 
485: template <>
486: bool Hugeint::TryConvert(int8_t value, hugeint_t &result) {
487: 	result = HugeintConvertInteger<int8_t>(value);
488: 	return true;
489: }
490: 
491: template <>
492: bool Hugeint::TryConvert(int16_t value, hugeint_t &result) {
493: 	result = HugeintConvertInteger<int16_t>(value);
494: 	return true;
495: }
496: 
497: template <>
498: bool Hugeint::TryConvert(int32_t value, hugeint_t &result) {
499: 	result = HugeintConvertInteger<int32_t>(value);
500: 	return true;
501: }
502: 
503: template <>
504: bool Hugeint::TryConvert(int64_t value, hugeint_t &result) {
505: 	result = HugeintConvertInteger<int64_t>(value);
506: 	return true;
507: }
508: template <>
509: bool Hugeint::TryConvert(uint8_t value, hugeint_t &result) {
510: 	result = HugeintConvertInteger<uint8_t>(value);
511: 	return true;
512: }
513: template <>
514: bool Hugeint::TryConvert(uint16_t value, hugeint_t &result) {
515: 	result = HugeintConvertInteger<uint16_t>(value);
516: 	return true;
517: }
518: template <>
519: bool Hugeint::TryConvert(uint32_t value, hugeint_t &result) {
520: 	result = HugeintConvertInteger<uint32_t>(value);
521: 	return true;
522: }
523: template <>
524: bool Hugeint::TryConvert(uint64_t value, hugeint_t &result) {
525: 	result = HugeintConvertInteger<uint64_t>(value);
526: 	return true;
527: }
528: 
529: template <>
530: bool Hugeint::TryConvert(float value, hugeint_t &result) {
531: 	return Hugeint::TryConvert(double(value), result);
532: }
533: 
534: template <>
535: bool Hugeint::TryConvert(double value, hugeint_t &result) {
536: 	if (value <= -170141183460469231731687303715884105728.0 || value >= 170141183460469231731687303715884105727.0) {
537: 		return false;
538: 	}
539: 	bool negative = value < 0;
540: 	if (negative) {
541: 		value = -value;
542: 	}
543: 	result.lower = (uint64_t)fmod(value, double(NumericLimits<uint64_t>::Maximum()));
544: 	result.upper = (uint64_t)(value / double(NumericLimits<uint64_t>::Maximum()));
545: 	if (negative) {
546: 		NegateInPlace(result);
547: 	}
548: 	return true;
549: }
550: 
551: //===--------------------------------------------------------------------===//
552: // hugeint_t operators
553: //===--------------------------------------------------------------------===//
554: hugeint_t::hugeint_t(int64_t value) {
555: 	auto result = Hugeint::Convert(value);
556: 	this->lower = result.lower;
557: 	this->upper = result.upper;
558: }
559: 
560: bool hugeint_t::operator==(const hugeint_t &rhs) const {
561: 	return Hugeint::Equals(*this, rhs);
562: }
563: 
564: bool hugeint_t::operator!=(const hugeint_t &rhs) const {
565: 	return Hugeint::NotEquals(*this, rhs);
566: }
567: 
568: bool hugeint_t::operator<(const hugeint_t &rhs) const {
569: 	return Hugeint::LessThan(*this, rhs);
570: }
571: 
572: bool hugeint_t::operator<=(const hugeint_t &rhs) const {
573: 	return Hugeint::LessThanEquals(*this, rhs);
574: }
575: 
576: bool hugeint_t::operator>(const hugeint_t &rhs) const {
577: 	return Hugeint::GreaterThan(*this, rhs);
578: }
579: 
580: bool hugeint_t::operator>=(const hugeint_t &rhs) const {
581: 	return Hugeint::GreaterThanEquals(*this, rhs);
582: }
583: 
584: hugeint_t hugeint_t::operator+(const hugeint_t &rhs) const {
585: 	return Hugeint::Add(*this, rhs);
586: }
587: 
588: hugeint_t hugeint_t::operator-(const hugeint_t &rhs) const {
589: 	return Hugeint::Subtract(*this, rhs);
590: }
591: 
592: hugeint_t hugeint_t::operator*(const hugeint_t &rhs) const {
593: 	return Hugeint::Multiply(*this, rhs);
594: }
595: 
596: hugeint_t hugeint_t::operator/(const hugeint_t &rhs) const {
597: 	return Hugeint::Divide(*this, rhs);
598: }
599: 
600: hugeint_t hugeint_t::operator%(const hugeint_t &rhs) const {
601: 	return Hugeint::Modulo(*this, rhs);
602: }
603: 
604: hugeint_t hugeint_t::operator-() const {
605: 	return Hugeint::Negate(*this);
606: }
607: 
608: hugeint_t hugeint_t::operator>>(const hugeint_t &rhs) const {
609: 	if (upper < 0) {
610: 		return hugeint_t(0);
611: 	}
612: 	hugeint_t result;
613: 	uint64_t shift = rhs.lower;
614: 	if (rhs.upper != 0 || shift >= 128) {
615: 		return hugeint_t(0);
616: 	} else if (shift == 64) {
617: 		result.upper = 0;
618: 		result.lower = upper;
619: 	} else if (shift == 0) {
620: 		return *this;
621: 	} else if (shift < 64) {
622: 		// perform upper shift in unsigned integer, and mask away the most significant bit
623: 		result.lower = (uint64_t(upper) << (64 - shift)) + (lower >> shift);
624: 		result.upper = uint64_t(upper) >> shift;
625: 	} else {
626: 		D_ASSERT(shift < 128);
627: 		result.lower = uint64_t(upper) >> (shift - 64);
628: 		result.upper = 0;
629: 	}
630: 	return result;
631: }
632: 
633: hugeint_t hugeint_t::operator<<(const hugeint_t &rhs) const {
634: 	if (upper < 0) {
635: 		return hugeint_t(0);
636: 	}
637: 	hugeint_t result;
638: 	uint64_t shift = rhs.lower;
639: 	if (rhs.upper != 0 || shift >= 128) {
640: 		return hugeint_t(0);
641: 	} else if (shift == 64) {
642: 		result.upper = lower;
643: 		result.lower = 0;
644: 	} else if (shift == 0) {
645: 		return *this;
646: 	} else if (shift < 64) {
647: 		// perform upper shift in unsigned integer, and mask away the most significant bit
648: 		uint64_t upper_shift = ((uint64_t(upper) << shift) + (lower >> (64 - shift))) & 0x7FFFFFFFFFFFFFFF;
649: 		result.lower = lower << shift;
650: 		result.upper = upper_shift;
651: 	} else {
652: 		D_ASSERT(shift < 128);
653: 		result.lower = 0;
654: 		result.upper = (lower << (shift - 64)) & 0x7FFFFFFFFFFFFFFF;
655: 	}
656: 	return result;
657: }
658: 
659: hugeint_t hugeint_t::operator&(const hugeint_t &rhs) const {
660: 	hugeint_t result;
661: 	result.lower = lower & rhs.lower;
662: 	result.upper = upper & rhs.upper;
663: 	return result;
664: }
665: 
666: hugeint_t hugeint_t::operator|(const hugeint_t &rhs) const {
667: 	hugeint_t result;
668: 	result.lower = lower | rhs.lower;
669: 	result.upper = upper | rhs.upper;
670: 	return result;
671: }
672: 
673: hugeint_t hugeint_t::operator^(const hugeint_t &rhs) const {
674: 	hugeint_t result;
675: 	result.lower = lower ^ rhs.lower;
676: 	result.upper = upper ^ rhs.upper;
677: 	return result;
678: }
679: 
680: hugeint_t hugeint_t::operator~() const {
681: 	hugeint_t result;
682: 	result.lower = ~lower;
683: 	result.upper = ~upper;
684: 	return result;
685: }
686: 
687: hugeint_t &hugeint_t::operator+=(const hugeint_t &rhs) {
688: 	Hugeint::AddInPlace(*this, rhs);
689: 	return *this;
690: }
691: hugeint_t &hugeint_t::operator-=(const hugeint_t &rhs) {
692: 	Hugeint::SubtractInPlace(*this, rhs);
693: 	return *this;
694: }
695: hugeint_t &hugeint_t::operator*=(const hugeint_t &rhs) {
696: 	*this = Hugeint::Multiply(*this, rhs);
697: 	return *this;
698: }
699: hugeint_t &hugeint_t::operator/=(const hugeint_t &rhs) {
700: 	*this = Hugeint::Divide(*this, rhs);
701: 	return *this;
702: }
703: hugeint_t &hugeint_t::operator%=(const hugeint_t &rhs) {
704: 	*this = Hugeint::Modulo(*this, rhs);
705: 	return *this;
706: }
707: hugeint_t &hugeint_t::operator>>=(const hugeint_t &rhs) {
708: 	*this = *this >> rhs;
709: 	return *this;
710: }
711: hugeint_t &hugeint_t::operator<<=(const hugeint_t &rhs) {
712: 	*this = *this << rhs;
713: 	return *this;
714: }
715: hugeint_t &hugeint_t::operator&=(const hugeint_t &rhs) {
716: 	lower &= rhs.lower;
717: 	upper &= rhs.upper;
718: 	return *this;
719: }
720: hugeint_t &hugeint_t::operator|=(const hugeint_t &rhs) {
721: 	lower |= rhs.lower;
722: 	upper |= rhs.upper;
723: 	return *this;
724: }
725: hugeint_t &hugeint_t::operator^=(const hugeint_t &rhs) {
726: 	lower ^= rhs.lower;
727: 	upper ^= rhs.upper;
728: 	return *this;
729: }
730: 
731: string hugeint_t::ToString() const {
732: 	return Hugeint::ToString(*this);
733: }
734: 
735: } // namespace duckdb
[end of src/common/types/hugeint.cpp]
[start of src/function/aggregate/algebraic/avg.cpp]
1: #include "duckdb/function/aggregate/algebraic_functions.hpp"
2: #include "duckdb/function/aggregate/sum_helpers.hpp"
3: #include "duckdb/common/types/hugeint.hpp"
4: #include "duckdb/common/exception.hpp"
5: #include "duckdb/function/function_set.hpp"
6: #include "duckdb/planner/expression.hpp"
7: 
8: namespace duckdb {
9: 
10: template <class T>
11: struct AvgState {
12: 	T value;
13: 	uint64_t count;
14: };
15: 
16: struct AverageDecimalBindData : public FunctionData {
17: 	explicit AverageDecimalBindData(double scale) : scale(scale) {
18: 	}
19: 
20: 	double scale;
21: 
22: public:
23: 	unique_ptr<FunctionData> Copy() override {
24: 		return make_unique<AverageDecimalBindData>(scale);
25: 	};
26: };
27: 
28: struct AverageSetOperation {
29: 	template <class STATE>
30: 	static void Initialize(STATE *state) {
31: 		state->count = 0;
32: 	}
33: 	template <class STATE>
34: 	static void Combine(const STATE &source, STATE *target) {
35: 		target->count += source.count;
36: 		target->value += source.value;
37: 	}
38: 	template <class STATE>
39: 	static void AddValues(STATE *state, idx_t count) {
40: 		state->count += count;
41: 	}
42: };
43: 
44: static double GetAverageDivident(uint64_t count, FunctionData *bind_data) {
45: 	double divident = double(count);
46: 	if (bind_data) {
47: 		auto &avg_bind_data = (AverageDecimalBindData &)*bind_data;
48: 		divident *= avg_bind_data.scale;
49: 	}
50: 	return divident;
51: }
52: 
53: struct IntegerAverageOperation : public BaseSumOperation<AverageSetOperation, RegularAdd> {
54: 	template <class T, class STATE>
55: 	static void Finalize(Vector &result, FunctionData *bind_data, STATE *state, T *target, ValidityMask &mask,
56: 	                     idx_t idx) {
57: 		if (state->count == 0) {
58: 			mask.SetInvalid(idx);
59: 		} else {
60: 			double divident = GetAverageDivident(state->count, bind_data);
61: 			target[idx] = double(state->value) / divident;
62: 		}
63: 	}
64: };
65: 
66: struct IntegerAverageOperationHugeint : public BaseSumOperation<AverageSetOperation, HugeintAdd> {
67: 	template <class T, class STATE>
68: 	static void Finalize(Vector &result, FunctionData *bind_data, STATE *state, T *target, ValidityMask &mask,
69: 	                     idx_t idx) {
70: 		if (state->count == 0) {
71: 			mask.SetInvalid(idx);
72: 		} else {
73: 			double divident = GetAverageDivident(state->count, bind_data);
74: 			target[idx] = Hugeint::Cast<double>(state->value) / divident;
75: 		}
76: 	}
77: };
78: 
79: struct HugeintAverageOperation : public BaseSumOperation<AverageSetOperation, RegularAdd> {
80: 	template <class T, class STATE>
81: 	static void Finalize(Vector &result, FunctionData *bind_data, STATE *state, T *target, ValidityMask &mask,
82: 	                     idx_t idx) {
83: 		if (state->count == 0) {
84: 			mask.SetInvalid(idx);
85: 		} else {
86: 			double divident = GetAverageDivident(state->count, bind_data);
87: 			target[idx] = Hugeint::Cast<double>(state->value) / divident;
88: 		}
89: 	}
90: };
91: 
92: struct NumericAverageOperation : public BaseSumOperation<AverageSetOperation, RegularAdd> {
93: 	template <class T, class STATE>
94: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
95: 		if (state->count == 0) {
96: 			mask.SetInvalid(idx);
97: 		} else {
98: 			if (!Value::DoubleIsValid(state->value)) {
99: 				throw OutOfRangeException("AVG is out of range!");
100: 			}
101: 			target[idx] = state->value / state->count;
102: 		}
103: 	}
104: };
105: 
106: AggregateFunction GetAverageAggregate(PhysicalType type) {
107: 	switch (type) {
108: 	case PhysicalType::INT16:
109: 		return AggregateFunction::UnaryAggregate<AvgState<int64_t>, int16_t, double, IntegerAverageOperation>(
110: 		    LogicalType::SMALLINT, LogicalType::DOUBLE);
111: 	case PhysicalType::INT32: {
112: 		auto function =
113: 		    AggregateFunction::UnaryAggregate<AvgState<hugeint_t>, int32_t, double, IntegerAverageOperationHugeint>(
114: 		        LogicalType::INTEGER, LogicalType::DOUBLE);
115: 		return function;
116: 	}
117: 	case PhysicalType::INT64: {
118: 		auto function =
119: 		    AggregateFunction::UnaryAggregate<AvgState<hugeint_t>, int64_t, double, IntegerAverageOperationHugeint>(
120: 		        LogicalType::BIGINT, LogicalType::DOUBLE);
121: 		return function;
122: 	}
123: 	case PhysicalType::INT128:
124: 		return AggregateFunction::UnaryAggregate<AvgState<hugeint_t>, hugeint_t, double, HugeintAverageOperation>(
125: 		    LogicalType::HUGEINT, LogicalType::DOUBLE);
126: 	default:
127: 		throw InternalException("Unimplemented average aggregate");
128: 	}
129: }
130: 
131: unique_ptr<FunctionData> BindDecimalAvg(ClientContext &context, AggregateFunction &function,
132:                                         vector<unique_ptr<Expression>> &arguments) {
133: 	auto decimal_type = arguments[0]->return_type;
134: 	function = GetAverageAggregate(decimal_type.InternalType());
135: 	function.name = "avg";
136: 	function.arguments[0] = decimal_type;
137: 	function.return_type = LogicalType::DOUBLE;
138: 	return make_unique<AverageDecimalBindData>(
139: 	    Hugeint::Cast<double>(Hugeint::POWERS_OF_TEN[DecimalType::GetScale(decimal_type)]));
140: }
141: 
142: void AvgFun::RegisterFunction(BuiltinFunctions &set) {
143: 	AggregateFunctionSet avg("avg");
144: 	avg.AddFunction(AggregateFunction({LogicalTypeId::DECIMAL}, LogicalTypeId::DECIMAL, nullptr, nullptr, nullptr,
145: 	                                  nullptr, nullptr, nullptr, BindDecimalAvg));
146: 	avg.AddFunction(GetAverageAggregate(PhysicalType::INT16));
147: 	avg.AddFunction(GetAverageAggregate(PhysicalType::INT32));
148: 	avg.AddFunction(GetAverageAggregate(PhysicalType::INT64));
149: 	avg.AddFunction(GetAverageAggregate(PhysicalType::INT128));
150: 	avg.AddFunction(AggregateFunction::UnaryAggregate<AvgState<double>, double, double, NumericAverageOperation>(
151: 	    LogicalType::DOUBLE, LogicalType::DOUBLE));
152: 	set.AddFunction(avg);
153: }
154: 
155: } // namespace duckdb
[end of src/function/aggregate/algebraic/avg.cpp]
[start of src/function/aggregate/distributive/sum.cpp]
1: #include "duckdb/function/aggregate/distributive_functions.hpp"
2: #include "duckdb/function/aggregate/sum_helpers.hpp"
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/types/decimal.hpp"
5: #include "duckdb/storage/statistics/numeric_statistics.hpp"
6: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
7: #include "duckdb/function/aggregate/algebraic_functions.hpp"
8: 
9: namespace duckdb {
10: 
11: template <class T>
12: struct SumState {
13: 	T value;
14: 	bool isset;
15: };
16: 
17: struct SumSetOperation {
18: 	template <class STATE>
19: 	static void Initialize(STATE *state) {
20: 		state->isset = false;
21: 	}
22: 	template <class STATE>
23: 	static void Combine(const STATE &source, STATE *target) {
24: 		target->isset = source.isset || target->isset;
25: 		target->value += source.value;
26: 	}
27: 	template <class STATE>
28: 	static void AddValues(STATE *state, idx_t count) {
29: 		state->isset = true;
30: 	}
31: };
32: 
33: struct IntegerSumOperation : public BaseSumOperation<SumSetOperation, RegularAdd> {
34: 	template <class T, class STATE>
35: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
36: 		if (!state->isset) {
37: 			mask.SetInvalid(idx);
38: 		} else {
39: 			target[idx] = Hugeint::Convert(state->value);
40: 		}
41: 	}
42: };
43: 
44: struct SumToHugeintOperation : public BaseSumOperation<SumSetOperation, HugeintAdd> {
45: 	template <class T, class STATE>
46: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
47: 		if (!state->isset) {
48: 			mask.SetInvalid(idx);
49: 		} else {
50: 			target[idx] = state->value;
51: 		}
52: 	}
53: };
54: 
55: struct NumericSumOperation : public BaseSumOperation<SumSetOperation, RegularAdd> {
56: 	template <class T, class STATE>
57: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
58: 		if (!state->isset) {
59: 			mask.SetInvalid(idx);
60: 		} else {
61: 			if (!Value::DoubleIsValid(state->value)) {
62: 				throw OutOfRangeException("SUM is out of range!");
63: 			}
64: 			target[idx] = state->value;
65: 		}
66: 	}
67: };
68: 
69: struct HugeintSumOperation : public BaseSumOperation<SumSetOperation, RegularAdd> {
70: 	template <class T, class STATE>
71: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
72: 		if (!state->isset) {
73: 			mask.SetInvalid(idx);
74: 		} else {
75: 			target[idx] = state->value;
76: 		}
77: 	}
78: };
79: 
80: unique_ptr<BaseStatistics> SumPropagateStats(ClientContext &context, BoundAggregateExpression &expr,
81:                                              FunctionData *bind_data, vector<unique_ptr<BaseStatistics>> &child_stats,
82:                                              NodeStatistics *node_stats) {
83: 	if (child_stats[0] && node_stats && node_stats->has_max_cardinality) {
84: 		auto &numeric_stats = (NumericStatistics &)*child_stats[0];
85: 		if (numeric_stats.min.is_null || numeric_stats.max.is_null) {
86: 			return nullptr;
87: 		}
88: 		auto internal_type = numeric_stats.min.type().InternalType();
89: 		hugeint_t max_negative;
90: 		hugeint_t max_positive;
91: 		switch (internal_type) {
92: 		case PhysicalType::INT32:
93: 			max_negative = numeric_stats.min.GetValueUnsafe<int32_t>();
94: 			max_positive = numeric_stats.max.GetValueUnsafe<int32_t>();
95: 			break;
96: 		case PhysicalType::INT64:
97: 			max_negative = numeric_stats.min.GetValueUnsafe<int64_t>();
98: 			max_positive = numeric_stats.max.GetValueUnsafe<int64_t>();
99: 			break;
100: 		default:
101: 			throw InternalException("Unsupported type for propagate sum stats");
102: 		}
103: 		auto max_sum_negative = max_negative * hugeint_t(node_stats->max_cardinality);
104: 		auto max_sum_positive = max_positive * hugeint_t(node_stats->max_cardinality);
105: 		if (max_sum_positive >= NumericLimits<int64_t>::Maximum() ||
106: 		    max_sum_negative <= NumericLimits<int64_t>::Minimum()) {
107: 			// sum can potentially exceed int64_t bounds: use hugeint sum
108: 			return nullptr;
109: 		}
110: 		// total sum is guaranteed to fit in a single int64: use int64 sum instead of hugeint sum
111: 		switch (internal_type) {
112: 		case PhysicalType::INT32:
113: 			expr.function =
114: 			    AggregateFunction::UnaryAggregate<SumState<int64_t>, int32_t, hugeint_t, IntegerSumOperation>(
115: 			        LogicalType::INTEGER, LogicalType::HUGEINT);
116: 			expr.function.name = "sum";
117: 			break;
118: 		case PhysicalType::INT64:
119: 			expr.function =
120: 			    AggregateFunction::UnaryAggregate<SumState<int64_t>, int64_t, hugeint_t, IntegerSumOperation>(
121: 			        LogicalType::BIGINT, LogicalType::HUGEINT);
122: 			expr.function.name = "sum";
123: 			break;
124: 		default:
125: 			throw InternalException("Unsupported type for propagate sum stats");
126: 		}
127: 	}
128: 	return nullptr;
129: }
130: 
131: AggregateFunction SumFun::GetSumAggregate(PhysicalType type) {
132: 	switch (type) {
133: 	case PhysicalType::INT16:
134: 		return AggregateFunction::UnaryAggregate<SumState<int64_t>, int16_t, hugeint_t, IntegerSumOperation>(
135: 		    LogicalType::SMALLINT, LogicalType::HUGEINT);
136: 	case PhysicalType::INT32: {
137: 		auto function =
138: 		    AggregateFunction::UnaryAggregate<SumState<hugeint_t>, int32_t, hugeint_t, SumToHugeintOperation>(
139: 		        LogicalType::INTEGER, LogicalType::HUGEINT);
140: 		function.statistics = SumPropagateStats;
141: 		return function;
142: 	}
143: 	case PhysicalType::INT64: {
144: 		auto function =
145: 		    AggregateFunction::UnaryAggregate<SumState<hugeint_t>, int64_t, hugeint_t, SumToHugeintOperation>(
146: 		        LogicalType::BIGINT, LogicalType::HUGEINT);
147: 		function.statistics = SumPropagateStats;
148: 		return function;
149: 	}
150: 	case PhysicalType::INT128:
151: 		return AggregateFunction::UnaryAggregate<SumState<hugeint_t>, hugeint_t, hugeint_t, HugeintSumOperation>(
152: 		    LogicalType::HUGEINT, LogicalType::HUGEINT);
153: 	default:
154: 		throw InternalException("Unimplemented sum aggregate");
155: 	}
156: }
157: 
158: unique_ptr<FunctionData> BindDecimalSum(ClientContext &context, AggregateFunction &function,
159:                                         vector<unique_ptr<Expression>> &arguments) {
160: 	auto decimal_type = arguments[0]->return_type;
161: 	function = SumFun::GetSumAggregate(decimal_type.InternalType());
162: 	function.name = "sum";
163: 	function.arguments[0] = decimal_type;
164: 	function.return_type = LogicalType::DECIMAL(Decimal::MAX_WIDTH_DECIMAL, DecimalType::GetScale(decimal_type));
165: 	return nullptr;
166: }
167: 
168: void SumFun::RegisterFunction(BuiltinFunctions &set) {
169: 	AggregateFunctionSet sum("sum");
170: 	// decimal
171: 	sum.AddFunction(AggregateFunction({LogicalTypeId::DECIMAL}, LogicalTypeId::DECIMAL, nullptr, nullptr, nullptr,
172: 	                                  nullptr, nullptr, nullptr, BindDecimalSum));
173: 	sum.AddFunction(GetSumAggregate(PhysicalType::INT16));
174: 	sum.AddFunction(GetSumAggregate(PhysicalType::INT32));
175: 	sum.AddFunction(GetSumAggregate(PhysicalType::INT64));
176: 	sum.AddFunction(GetSumAggregate(PhysicalType::INT128));
177: 	// float sums to float
178: 	// FIXME: implement http://ic.ese.upenn.edu/pdf/parallel_fpaccum_tc2016.pdf for parallel FP sums
179: 	sum.AddFunction(AggregateFunction::UnaryAggregate<SumState<double>, double, double, NumericSumOperation>(
180: 	    LogicalType::DOUBLE, LogicalType::DOUBLE));
181: 
182: 	set.AddFunction(sum);
183: }
184: 
185: } // namespace duckdb
[end of src/function/aggregate/distributive/sum.cpp]
[start of src/include/duckdb/common/types/hugeint.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/hugeint.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/types.hpp"
12: #include "duckdb/common/limits.hpp"
13: #include "duckdb/common/exception.hpp"
14: 
15: namespace duckdb {
16: 
17: //! The Hugeint class contains static operations for the INT128 type
18: class Hugeint {
19: public:
20: 	//! Convert a string to a hugeint object
21: 	static bool FromString(string str, hugeint_t &result);
22: 	//! Convert a string to a hugeint object
23: 	static bool FromCString(const char *str, idx_t len, hugeint_t &result);
24: 	//! Convert a hugeint object to a string
25: 	static string ToString(hugeint_t input);
26: 
27: 	static hugeint_t FromString(string str) {
28: 		hugeint_t result;
29: 		FromString(str, result);
30: 		return result;
31: 	}
32: 
33: 	template <class T>
34: 	static bool TryCast(hugeint_t input, T &result);
35: 
36: 	template <class T>
37: 	static T Cast(hugeint_t input) {
38: 		T value;
39: 		TryCast(input, value);
40: 		return value;
41: 	}
42: 
43: 	template <class T>
44: 	static bool TryConvert(T value, hugeint_t &result);
45: 
46: 	template <class T>
47: 	static hugeint_t Convert(T value) {
48: 		hugeint_t result;
49: 		if (!TryConvert(value, result)) { // LCOV_EXCL_START
50: 			throw ValueOutOfRangeException(double(value), GetTypeId<T>(), GetTypeId<hugeint_t>());
51: 		} // LCOV_EXCL_STOP
52: 		return result;
53: 	}
54: 
55: 	static void NegateInPlace(hugeint_t &input) {
56: 		input.lower = NumericLimits<uint64_t>::Maximum() - input.lower + 1;
57: 		input.upper = -1 - input.upper + (input.lower == 0);
58: 	}
59: 	static hugeint_t Negate(hugeint_t input) {
60: 		NegateInPlace(input);
61: 		return input;
62: 	}
63: 
64: 	static bool TryMultiply(hugeint_t lhs, hugeint_t rhs, hugeint_t &result);
65: 
66: 	static hugeint_t Add(hugeint_t lhs, hugeint_t rhs);
67: 	static hugeint_t Subtract(hugeint_t lhs, hugeint_t rhs);
68: 	static hugeint_t Multiply(hugeint_t lhs, hugeint_t rhs);
69: 	static hugeint_t Divide(hugeint_t lhs, hugeint_t rhs);
70: 	static hugeint_t Modulo(hugeint_t lhs, hugeint_t rhs);
71: 
72: 	// DivMod -> returns the result of the division (lhs / rhs), and fills up the remainder
73: 	static hugeint_t DivMod(hugeint_t lhs, hugeint_t rhs, hugeint_t &remainder);
74: 	// DivMod but lhs MUST be positive, and rhs is a uint64_t
75: 	static hugeint_t DivModPositive(hugeint_t lhs, uint64_t rhs, uint64_t &remainder);
76: 
77: 	static bool AddInPlace(hugeint_t &lhs, hugeint_t rhs);
78: 	static bool SubtractInPlace(hugeint_t &lhs, hugeint_t rhs);
79: 
80: 	// comparison operators
81: 	// note that everywhere here we intentionally use bitwise ops
82: 	// this is because they seem to be consistently much faster (benchmarked on a Macbook Pro)
83: 	static bool Equals(hugeint_t lhs, hugeint_t rhs) {
84: 		int lower_equals = lhs.lower == rhs.lower;
85: 		int upper_equals = lhs.upper == rhs.upper;
86: 		return lower_equals & upper_equals;
87: 	}
88: 	static bool NotEquals(hugeint_t lhs, hugeint_t rhs) {
89: 		int lower_not_equals = lhs.lower != rhs.lower;
90: 		int upper_not_equals = lhs.upper != rhs.upper;
91: 		return lower_not_equals | upper_not_equals;
92: 	}
93: 	static bool GreaterThan(hugeint_t lhs, hugeint_t rhs) {
94: 		int upper_bigger = lhs.upper > rhs.upper;
95: 		int upper_equal = lhs.upper == rhs.upper;
96: 		int lower_bigger = lhs.lower > rhs.lower;
97: 		return upper_bigger | (upper_equal & lower_bigger);
98: 	}
99: 	static bool GreaterThanEquals(hugeint_t lhs, hugeint_t rhs) {
100: 		int upper_bigger = lhs.upper > rhs.upper;
101: 		int upper_equal = lhs.upper == rhs.upper;
102: 		int lower_bigger_equals = lhs.lower >= rhs.lower;
103: 		return upper_bigger | (upper_equal & lower_bigger_equals);
104: 	}
105: 	static bool LessThan(hugeint_t lhs, hugeint_t rhs) {
106: 		int upper_smaller = lhs.upper < rhs.upper;
107: 		int upper_equal = lhs.upper == rhs.upper;
108: 		int lower_smaller = lhs.lower < rhs.lower;
109: 		return upper_smaller | (upper_equal & lower_smaller);
110: 	}
111: 	static bool LessThanEquals(hugeint_t lhs, hugeint_t rhs) {
112: 		int upper_smaller = lhs.upper < rhs.upper;
113: 		int upper_equal = lhs.upper == rhs.upper;
114: 		int lower_smaller_equals = lhs.lower <= rhs.lower;
115: 		return upper_smaller | (upper_equal & lower_smaller_equals);
116: 	}
117: 	static const hugeint_t POWERS_OF_TEN[40];
118: };
119: 
120: template <>
121: bool Hugeint::TryCast(hugeint_t input, int8_t &result);
122: template <>
123: bool Hugeint::TryCast(hugeint_t input, int16_t &result);
124: template <>
125: bool Hugeint::TryCast(hugeint_t input, int32_t &result);
126: template <>
127: bool Hugeint::TryCast(hugeint_t input, int64_t &result);
128: template <>
129: bool Hugeint::TryCast(hugeint_t input, uint8_t &result);
130: template <>
131: bool Hugeint::TryCast(hugeint_t input, uint16_t &result);
132: template <>
133: bool Hugeint::TryCast(hugeint_t input, uint32_t &result);
134: template <>
135: bool Hugeint::TryCast(hugeint_t input, uint64_t &result);
136: template <>
137: bool Hugeint::TryCast(hugeint_t input, hugeint_t &result);
138: template <>
139: bool Hugeint::TryCast(hugeint_t input, float &result);
140: template <>
141: bool Hugeint::TryCast(hugeint_t input, double &result);
142: 
143: template <>
144: bool Hugeint::TryConvert(int8_t value, hugeint_t &result);
145: template <>
146: bool Hugeint::TryConvert(int16_t value, hugeint_t &result);
147: template <>
148: bool Hugeint::TryConvert(int32_t value, hugeint_t &result);
149: template <>
150: bool Hugeint::TryConvert(int64_t value, hugeint_t &result);
151: template <>
152: bool Hugeint::TryConvert(uint8_t value, hugeint_t &result);
153: template <>
154: bool Hugeint::TryConvert(uint16_t value, hugeint_t &result);
155: template <>
156: bool Hugeint::TryConvert(uint32_t value, hugeint_t &result);
157: template <>
158: bool Hugeint::TryConvert(uint64_t value, hugeint_t &result);
159: template <>
160: bool Hugeint::TryConvert(float value, hugeint_t &result);
161: template <>
162: bool Hugeint::TryConvert(double value, hugeint_t &result);
163: 
164: } // namespace duckdb
[end of src/include/duckdb/common/types/hugeint.hpp]
[start of src/include/duckdb/function/aggregate/sum_helpers.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/aggregate/sum_helpers.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types.hpp"
13: #include "duckdb/common/types/vector.hpp"
14: 
15: namespace duckdb {
16: 
17: struct RegularAdd {
18: 	template <class STATE, class T>
19: 	static void AddNumber(STATE &state, T input) {
20: 		state.value += input;
21: 	}
22: 
23: 	template <class STATE, class T>
24: 	static void AddConstant(STATE &state, T input, idx_t count) {
25: 		state.value += input * count;
26: 	}
27: };
28: 
29: struct HugeintAdd {
30: 	static void AddValue(hugeint_t &result, uint64_t value, int positive) {
31: 		// integer summation taken from Tim Gubner et al. - Efficient Query Processing
32: 		// with Optimistically Compressed Hash Tables & Strings in the USSR
33: 
34: 		// add the value to the lower part of the hugeint
35: 		result.lower += value;
36: 		// now handle overflows
37: 		int overflow = result.lower < value;
38: 		// we consider two situations:
39: 		// (1) input[idx] is positive, and current value is lower than value: overflow
40: 		// (2) input[idx] is negative, and current value is higher than value: underflow
41: 		if (!(overflow ^ positive)) {
42: 			// in the case of an overflow or underflow we either increment or decrement the upper base
43: 			// positive: +1, negative: -1
44: 			result.upper += -1 + 2 * positive;
45: 		}
46: 	}
47: 
48: 	template <class STATE, class T>
49: 	static void AddNumber(STATE &state, T input) {
50: 		AddValue(state.value, uint64_t(input), input >= 0);
51: 	}
52: 
53: 	template <class STATE, class T>
54: 	static void AddConstant(STATE &state, T input, idx_t count) {
55: 		// add a constant X number of times
56: 		// fast path: check if value * count fits into a uint64_t
57: 		// note that we check if value * VECTOR_SIZE fits in a uint64_t to avoid having to actually do a division
58: 		// this is still a pretty high number (18014398509481984) so most positive numbers will fit
59: 		if (input >= 0 && uint64_t(input) < (NumericLimits<uint64_t>::Maximum() / STANDARD_VECTOR_SIZE)) {
60: 			// if it does just multiply it and add the value
61: 			uint64_t value = uint64_t(input) * count;
62: 			AddValue(state.value, value, 1);
63: 		} else {
64: 			// if it doesn't fit we have two choices
65: 			// either we loop over count and add the values individually
66: 			// or we convert to a hugeint and multiply the hugeint
67: 			// the problem is that hugeint multiplication is expensive
68: 			// hence we switch here: with a low count we do the loop
69: 			// with a high count we do the hugeint multiplication
70: 			if (count < 8) {
71: 				for (idx_t i = 0; i < count; i++) {
72: 					AddValue(state.value, uint64_t(input), input >= 0);
73: 				}
74: 			} else {
75: 				hugeint_t addition = hugeint_t(input) * count;
76: 				state.value += addition;
77: 			}
78: 		}
79: 	}
80: };
81: 
82: template <class STATEOP, class ADDOP>
83: struct BaseSumOperation {
84: 	template <class STATE>
85: 	static void Initialize(STATE *state) {
86: 		state->value = 0;
87: 		STATEOP::template Initialize<STATE>(state);
88: 	}
89: 
90: 	template <class STATE, class OP>
91: 	static void Combine(const STATE &source, STATE *target) {
92: 		STATEOP::template Combine<STATE>(source, target);
93: 	}
94: 
95: 	template <class INPUT_TYPE, class STATE, class OP>
96: 	static void Operation(STATE *state, FunctionData *bind_data, INPUT_TYPE *input, ValidityMask &mask, idx_t idx) {
97: 		STATEOP::template AddValues<STATE>(state, 1);
98: 		ADDOP::template AddNumber<STATE, INPUT_TYPE>(*state, input[idx]);
99: 	}
100: 
101: 	template <class INPUT_TYPE, class STATE, class OP>
102: 	static void ConstantOperation(STATE *state, FunctionData *bind_data, INPUT_TYPE *input, ValidityMask &mask,
103: 	                              idx_t count) {
104: 		STATEOP::template AddValues<STATE>(state, count);
105: 		ADDOP::template AddConstant<STATE, INPUT_TYPE>(*state, *input, count);
106: 	}
107: 
108: 	static bool IgnoreNull() {
109: 		return true;
110: 	}
111: };
112: 
113: } // namespace duckdb
[end of src/include/duckdb/function/aggregate/sum_helpers.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: