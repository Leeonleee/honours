diff --git a/src/common/types/hugeint.cpp b/src/common/types/hugeint.cpp
index 59ea3cf1daa4..e6ba24c4e752 100644
--- a/src/common/types/hugeint.cpp
+++ b/src/common/types/hugeint.cpp
@@ -460,20 +460,30 @@ bool Hugeint::TryCast(hugeint_t input, float &result) {
 	return true;
 }
 
-template <>
-bool Hugeint::TryCast(hugeint_t input, double &result) {
+template <class REAL_T>
+bool CastBigintToFloating(hugeint_t input, REAL_T &result) {
 	switch (input.upper) {
 	case -1:
 		// special case for upper = -1 to avoid rounding issues in small negative numbers
-		result = -double(NumericLimits<uint64_t>::Maximum() - input.lower) - 1;
+		result = -REAL_T(NumericLimits<uint64_t>::Maximum() - input.lower) - 1;
 		break;
 	default:
-		result = double(input.lower) + double(input.upper) * double(NumericLimits<uint64_t>::Maximum());
+		result = REAL_T(input.lower) + REAL_T(input.upper) * REAL_T(NumericLimits<uint64_t>::Maximum());
 		break;
 	}
 	return true;
 }
 
+template <>
+bool Hugeint::TryCast(hugeint_t input, double &result) {
+	return CastBigintToFloating<double>(input, result);
+}
+
+template <>
+bool Hugeint::TryCast(hugeint_t input, long double &result) {
+	return CastBigintToFloating<long double>(input, result);
+}
+
 template <class DST>
 hugeint_t HugeintConvertInteger(DST input) {
 	hugeint_t result;
@@ -531,8 +541,8 @@ bool Hugeint::TryConvert(float value, hugeint_t &result) {
 	return Hugeint::TryConvert(double(value), result);
 }
 
-template <>
-bool Hugeint::TryConvert(double value, hugeint_t &result) {
+template <class REAL_T>
+bool ConvertFloatingToBigint(REAL_T value, hugeint_t &result) {
 	if (value <= -170141183460469231731687303715884105728.0 || value >= 170141183460469231731687303715884105727.0) {
 		return false;
 	}
@@ -540,14 +550,24 @@ bool Hugeint::TryConvert(double value, hugeint_t &result) {
 	if (negative) {
 		value = -value;
 	}
-	result.lower = (uint64_t)fmod(value, double(NumericLimits<uint64_t>::Maximum()));
-	result.upper = (uint64_t)(value / double(NumericLimits<uint64_t>::Maximum()));
+	result.lower = (uint64_t)fmod(value, REAL_T(NumericLimits<uint64_t>::Maximum()));
+	result.upper = (uint64_t)(value / REAL_T(NumericLimits<uint64_t>::Maximum()));
 	if (negative) {
-		NegateInPlace(result);
+		Hugeint::NegateInPlace(result);
 	}
 	return true;
 }
 
+template <>
+bool Hugeint::TryConvert(double value, hugeint_t &result) {
+	return ConvertFloatingToBigint<double>(value, result);
+}
+
+template <>
+bool Hugeint::TryConvert(long double value, hugeint_t &result) {
+	return ConvertFloatingToBigint<long double>(value, result);
+}
+
 //===--------------------------------------------------------------------===//
 // hugeint_t operators
 //===--------------------------------------------------------------------===//
diff --git a/src/function/aggregate/algebraic/avg.cpp b/src/function/aggregate/algebraic/avg.cpp
index d718f22fb81c..0536a58ae089 100644
--- a/src/function/aggregate/algebraic/avg.cpp
+++ b/src/function/aggregate/algebraic/avg.cpp
@@ -9,8 +9,35 @@ namespace duckdb {
 
 template <class T>
 struct AvgState {
+	uint64_t count;
 	T value;
+
+	void Initialize() {
+		this->count = 0;
+	}
+
+	void Combine(const AvgState<T> &other) {
+		this->count += other.count;
+		this->value += other.value;
+	}
+};
+
+template <>
+struct AvgState<double> {
 	uint64_t count;
+	double value;
+	double err;
+
+	void Initialize() {
+		this->count = 0;
+		this->err = 0.0;
+	}
+
+	void Combine(const AvgState<double> &other) {
+		this->count += other.count;
+		KahanAdd(other.value, this->value, this->err);
+		KahanAdd(other.err, this->value, this->err);
+	}
 };
 
 struct AverageDecimalBindData : public FunctionData {
@@ -28,12 +55,11 @@ struct AverageDecimalBindData : public FunctionData {
 struct AverageSetOperation {
 	template <class STATE>
 	static void Initialize(STATE *state) {
-		state->count = 0;
+		state->Initialize();
 	}
 	template <class STATE>
 	static void Combine(const STATE &source, STATE *target) {
-		target->count += source.count;
-		target->value += source.value;
+		target->Combine(source);
 	}
 	template <class STATE>
 	static void AddValues(STATE *state, idx_t count) {
@@ -41,8 +67,9 @@ struct AverageSetOperation {
 	}
 };
 
-static double GetAverageDivident(uint64_t count, FunctionData *bind_data) {
-	double divident = double(count);
+template <class T>
+static T GetAverageDivident(uint64_t count, FunctionData *bind_data) {
+	T divident = T(count);
 	if (bind_data) {
 		auto &avg_bind_data = (AverageDecimalBindData &)*bind_data;
 		divident *= avg_bind_data.scale;
@@ -57,7 +84,7 @@ struct IntegerAverageOperation : public BaseSumOperation<AverageSetOperation, Re
 		if (state->count == 0) {
 			mask.SetInvalid(idx);
 		} else {
-			double divident = GetAverageDivident(state->count, bind_data);
+			double divident = GetAverageDivident<double>(state->count, bind_data);
 			target[idx] = double(state->value) / divident;
 		}
 	}
@@ -70,8 +97,8 @@ struct IntegerAverageOperationHugeint : public BaseSumOperation<AverageSetOperat
 		if (state->count == 0) {
 			mask.SetInvalid(idx);
 		} else {
-			double divident = GetAverageDivident(state->count, bind_data);
-			target[idx] = Hugeint::Cast<double>(state->value) / divident;
+			long double divident = GetAverageDivident<long double>(state->count, bind_data);
+			target[idx] = Hugeint::Cast<long double>(state->value) / divident;
 		}
 	}
 };
@@ -83,13 +110,13 @@ struct HugeintAverageOperation : public BaseSumOperation<AverageSetOperation, Re
 		if (state->count == 0) {
 			mask.SetInvalid(idx);
 		} else {
-			double divident = GetAverageDivident(state->count, bind_data);
-			target[idx] = Hugeint::Cast<double>(state->value) / divident;
+			long double divident = GetAverageDivident<long double>(state->count, bind_data);
+			target[idx] = Hugeint::Cast<long double>(state->value) / divident;
 		}
 	}
 };
 
-struct NumericAverageOperation : public BaseSumOperation<AverageSetOperation, RegularAdd> {
+struct NumericAverageOperation : public BaseSumOperation<AverageSetOperation, DoubleAdd> {
 	template <class T, class STATE>
 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
 		if (state->count == 0) {
@@ -98,7 +125,7 @@ struct NumericAverageOperation : public BaseSumOperation<AverageSetOperation, Re
 			if (!Value::DoubleIsValid(state->value)) {
 				throw OutOfRangeException("AVG is out of range!");
 			}
-			target[idx] = state->value / state->count;
+			target[idx] = (state->value / state->count) + (state->err / state->count);
 		}
 	}
 };
diff --git a/src/function/aggregate/distributive/sum.cpp b/src/function/aggregate/distributive/sum.cpp
index 14cd6c62ce91..eba8d4d8db9d 100644
--- a/src/function/aggregate/distributive/sum.cpp
+++ b/src/function/aggregate/distributive/sum.cpp
@@ -8,21 +8,14 @@
 
 namespace duckdb {
 
-template <class T>
-struct SumState {
-	T value;
-	bool isset;
-};
-
 struct SumSetOperation {
 	template <class STATE>
 	static void Initialize(STATE *state) {
-		state->isset = false;
+		state->Initialize();
 	}
 	template <class STATE>
 	static void Combine(const STATE &source, STATE *target) {
-		target->isset = source.isset || target->isset;
-		target->value += source.value;
+		target->Combine(source);
 	}
 	template <class STATE>
 	static void AddValues(STATE *state, idx_t count) {
@@ -52,7 +45,7 @@ struct SumToHugeintOperation : public BaseSumOperation<SumSetOperation, HugeintA
 	}
 };
 
-struct NumericSumOperation : public BaseSumOperation<SumSetOperation, RegularAdd> {
+struct NumericSumOperation : public BaseSumOperation<SumSetOperation, DoubleAdd> {
 	template <class T, class STATE>
 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
 		if (!state->isset) {
diff --git a/src/include/duckdb/common/types/hugeint.hpp b/src/include/duckdb/common/types/hugeint.hpp
index b766c77bb9be..6d3ff11d4227 100644
--- a/src/include/duckdb/common/types/hugeint.hpp
+++ b/src/include/duckdb/common/types/hugeint.hpp
@@ -139,6 +139,8 @@ template <>
 bool Hugeint::TryCast(hugeint_t input, float &result);
 template <>
 bool Hugeint::TryCast(hugeint_t input, double &result);
+template <>
+bool Hugeint::TryCast(hugeint_t input, long double &result);
 
 template <>
 bool Hugeint::TryConvert(int8_t value, hugeint_t &result);
@@ -160,5 +162,7 @@ template <>
 bool Hugeint::TryConvert(float value, hugeint_t &result);
 template <>
 bool Hugeint::TryConvert(double value, hugeint_t &result);
+template <>
+bool Hugeint::TryConvert(long double value, hugeint_t &result);
 
 } // namespace duckdb
diff --git a/src/include/duckdb/function/aggregate/sum_helpers.hpp b/src/include/duckdb/function/aggregate/sum_helpers.hpp
index 045f596e689c..4babf49c413f 100644
--- a/src/include/duckdb/function/aggregate/sum_helpers.hpp
+++ b/src/include/duckdb/function/aggregate/sum_helpers.hpp
@@ -14,6 +14,47 @@
 
 namespace duckdb {
 
+template <class T>
+static inline void KahanAdd(T input, double &summed, double &err) {
+	double diff = input - err;
+	double newval = summed + diff;
+	err = (newval - summed) - diff;
+	summed = newval;
+}
+
+template <class T>
+struct SumState {
+	bool isset;
+	T value;
+
+	void Initialize() {
+		this->isset = false;
+	}
+
+	void Combine(const SumState<T> &other) {
+		this->isset = other.isset || this->isset;
+		this->value += other.value;
+	}
+};
+
+template <>
+struct SumState<double> {
+	bool isset;
+	double value;
+	double err;
+
+	void Initialize() {
+		this->isset = false;
+		this->err = 0.0;
+	}
+
+	void Combine(const SumState<double> &other) {
+		this->isset = other.isset || this->isset;
+		KahanAdd(other.value, this->value, this->err);
+		KahanAdd(other.err, this->value, this->err);
+	}
+};
+
 struct RegularAdd {
 	template <class STATE, class T>
 	static void AddNumber(STATE &state, T input) {
@@ -26,6 +67,18 @@ struct RegularAdd {
 	}
 };
 
+struct DoubleAdd {
+	template <class STATE, class T>
+	static void AddNumber(STATE &state, T input) {
+		KahanAdd(input, state.value, state.err);
+	}
+
+	template <class STATE, class T>
+	static void AddConstant(STATE &state, T input, idx_t count) {
+		KahanAdd(input * count, state.value, state.err);
+	}
+};
+
 struct HugeintAdd {
 	static void AddValue(hugeint_t &result, uint64_t value, int positive) {
 		// integer summation taken from Tim Gubner et al. - Efficient Query Processing
