{
  "repo": "duckdb/duckdb",
  "pull_number": 9539,
  "instance_id": "duckdb__duckdb-9539",
  "issue_numbers": [
    "9532"
  ],
  "base_commit": "82e85721e40d13d1cd0571c92674c28e9a5c90c5",
  "patch": "diff --git a/extension/icu/icu-timezone.cpp b/extension/icu/icu-timezone.cpp\nindex 5451be5f6c29..032b3ab04013 100644\n--- a/extension/icu/icu-timezone.cpp\n+++ b/extension/icu/icu-timezone.cpp\n@@ -8,6 +8,7 @@\n #include \"duckdb/parser/parsed_data/create_table_function_info.hpp\"\n #include \"include/icu-datefunc.hpp\"\n #include \"duckdb/transaction/meta_transaction.hpp\"\n+#include \"duckdb/common/operator/cast_operators.hpp\"\n \n namespace duckdb {\n \n@@ -138,13 +139,23 @@ struct ICUFromNaiveTimestamp : public ICUDateFunc {\n \t\treturn GetTime(calendar, micros);\n \t}\n \n+\tstruct CastTimestampUsToUs {\n+\t\ttemplate <class SRC, class DST>\n+\t\tstatic inline DST Operation(SRC input) {\n+\t\t\t// no-op\n+\t\t\treturn input;\n+\t\t}\n+\t};\n+\n+\ttemplate <class OP>\n \tstatic bool CastFromNaive(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {\n \t\tauto &cast_data = parameters.cast_data->Cast<CastData>();\n \t\tauto &info = cast_data.info->Cast<BindData>();\n \t\tCalendarPtr calendar(info.calendar->clone());\n \n-\t\tUnaryExecutor::Execute<timestamp_t, timestamp_t>(\n-\t\t    source, result, count, [&](timestamp_t input) { return Operation(calendar.get(), input); });\n+\t\tUnaryExecutor::Execute<timestamp_t, timestamp_t>(source, result, count, [&](timestamp_t input) {\n+\t\t\treturn Operation(calendar.get(), OP::template Operation<timestamp_t, timestamp_t>(input));\n+\t\t});\n \t\treturn true;\n \t}\n \n@@ -154,8 +165,18 @@ struct ICUFromNaiveTimestamp : public ICUDateFunc {\n \t\t}\n \n \t\tauto cast_data = make_uniq<CastData>(make_uniq<BindData>(*input.context));\n-\n-\t\treturn BoundCastInfo(CastFromNaive, std::move(cast_data));\n+\t\tswitch (source.id()) {\n+\t\tcase LogicalTypeId::TIMESTAMP:\n+\t\t\treturn BoundCastInfo(CastFromNaive<CastTimestampUsToUs>, std::move(cast_data));\n+\t\tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\t\treturn BoundCastInfo(CastFromNaive<CastTimestampMsToUs>, std::move(cast_data));\n+\t\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\t\treturn BoundCastInfo(CastFromNaive<CastTimestampNsToUs>, std::move(cast_data));\n+\t\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\t\treturn BoundCastInfo(CastFromNaive<CastTimestampSecToUs>, std::move(cast_data));\n+\t\tdefault:\n+\t\t\tthrow InternalException(\"Type %s not handled in BindCastFromNaive\", LogicalTypeIdToString(source.id()));\n+\t\t}\n \t}\n \n \tstatic void AddCasts(DatabaseInstance &db) {\n@@ -163,6 +184,9 @@ struct ICUFromNaiveTimestamp : public ICUDateFunc {\n \t\tauto &casts = config.GetCastFunctions();\n \n \t\tcasts.RegisterCastFunction(LogicalType::TIMESTAMP, LogicalType::TIMESTAMP_TZ, BindCastFromNaive);\n+\t\tcasts.RegisterCastFunction(LogicalType::TIMESTAMP_MS, LogicalType::TIMESTAMP_TZ, BindCastFromNaive);\n+\t\tcasts.RegisterCastFunction(LogicalType::TIMESTAMP_NS, LogicalType::TIMESTAMP_TZ, BindCastFromNaive);\n+\t\tcasts.RegisterCastFunction(LogicalType::TIMESTAMP_S, LogicalType::TIMESTAMP_TZ, BindCastFromNaive);\n \t}\n };\n \ndiff --git a/extension/parquet/column_writer.cpp b/extension/parquet/column_writer.cpp\nindex bad4e9fac799..ba3d6ff68eb3 100644\n--- a/extension/parquet/column_writer.cpp\n+++ b/extension/parquet/column_writer.cpp\n@@ -790,14 +790,14 @@ struct ParquetCastOperator : public BaseParquetOperator {\n struct ParquetTimestampNSOperator : public BaseParquetOperator {\n \ttemplate <class SRC, class TGT>\n \tstatic TGT Operation(SRC input) {\n-\t\treturn Timestamp::FromEpochNanoSeconds(input).value;\n+\t\treturn Timestamp::FromEpochNanoSecondsPossiblyInfinite(input).value;\n \t}\n };\n \n struct ParquetTimestampSOperator : public BaseParquetOperator {\n \ttemplate <class SRC, class TGT>\n \tstatic TGT Operation(SRC input) {\n-\t\treturn Timestamp::FromEpochSeconds(input).value;\n+\t\treturn Timestamp::FromEpochSecondsPossiblyInfinite(input).value;\n \t}\n };\n \ndiff --git a/extension/parquet/parquet_timestamp.cpp b/extension/parquet/parquet_timestamp.cpp\nindex e8779061d704..3451e26686a0 100644\n--- a/extension/parquet/parquet_timestamp.cpp\n+++ b/extension/parquet/parquet_timestamp.cpp\n@@ -43,10 +43,20 @@ Int96 TimestampToImpalaTimestamp(timestamp_t &ts) {\n timestamp_t ParquetTimestampMicrosToTimestamp(const int64_t &raw_ts) {\n \treturn Timestamp::FromEpochMicroSeconds(raw_ts);\n }\n+\n timestamp_t ParquetTimestampMsToTimestamp(const int64_t &raw_ts) {\n+\ttimestamp_t input(raw_ts);\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn input;\n+\t}\n \treturn Timestamp::FromEpochMs(raw_ts);\n }\n+\n timestamp_t ParquetTimestampNsToTimestamp(const int64_t &raw_ts) {\n+\ttimestamp_t input(raw_ts);\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn input;\n+\t}\n \treturn Timestamp::FromEpochNanoSeconds(raw_ts);\n }\n \ndiff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp\nindex 69ed385b0fa6..d24f8bae1d55 100644\n--- a/src/common/operator/cast_operators.cpp\n+++ b/src/common/operator/cast_operators.cpp\n@@ -1126,37 +1126,49 @@ bool TryCast::Operation(interval_t input, interval_t &result, bool strict) {\n //===--------------------------------------------------------------------===//\n template <>\n duckdb::string_t CastFromTimestampNS::Operation(duckdb::timestamp_t input, Vector &result) {\n-\treturn StringCast::Operation<timestamp_t>(Timestamp::FromEpochNanoSeconds(input.value), result);\n+\treturn StringCast::Operation<timestamp_t>(CastTimestampNsToUs::Operation<timestamp_t, timestamp_t>(input), result);\n }\n template <>\n duckdb::string_t CastFromTimestampMS::Operation(duckdb::timestamp_t input, Vector &result) {\n-\treturn StringCast::Operation<timestamp_t>(Timestamp::FromEpochMs(input.value), result);\n+\treturn StringCast::Operation<timestamp_t>(CastTimestampMsToUs::Operation<timestamp_t, timestamp_t>(input), result);\n }\n template <>\n duckdb::string_t CastFromTimestampSec::Operation(duckdb::timestamp_t input, Vector &result) {\n-\treturn StringCast::Operation<timestamp_t>(Timestamp::FromEpochSeconds(input.value), result);\n+\treturn StringCast::Operation<timestamp_t>(CastTimestampSecToUs::Operation<timestamp_t, timestamp_t>(input), result);\n }\n \n template <>\n timestamp_t CastTimestampUsToMs::Operation(timestamp_t input) {\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn input;\n+\t}\n \ttimestamp_t cast_timestamp(Timestamp::GetEpochMs(input));\n \treturn cast_timestamp;\n }\n \n template <>\n timestamp_t CastTimestampUsToNs::Operation(timestamp_t input) {\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn input;\n+\t}\n \ttimestamp_t cast_timestamp(Timestamp::GetEpochNanoSeconds(input));\n \treturn cast_timestamp;\n }\n \n template <>\n timestamp_t CastTimestampUsToSec::Operation(timestamp_t input) {\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn input;\n+\t}\n \ttimestamp_t cast_timestamp(Timestamp::GetEpochSeconds(input));\n \treturn cast_timestamp;\n }\n \n template <>\n timestamp_t CastTimestampMsToUs::Operation(timestamp_t input) {\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn input;\n+\t}\n \treturn Timestamp::FromEpochMs(input.value);\n }\n \n@@ -1172,17 +1184,36 @@ dtime_t CastTimestampMsToTime::Operation(timestamp_t input) {\n \n template <>\n timestamp_t CastTimestampMsToNs::Operation(timestamp_t input) {\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn input;\n+\t}\n \tauto us = CastTimestampMsToUs::Operation<timestamp_t, timestamp_t>(input);\n \treturn CastTimestampUsToNs::Operation<timestamp_t, timestamp_t>(us);\n }\n \n template <>\n timestamp_t CastTimestampNsToUs::Operation(timestamp_t input) {\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn input;\n+\t}\n \treturn Timestamp::FromEpochNanoSeconds(input.value);\n }\n \n+template <>\n+timestamp_t CastTimestampSecToUs::Operation(timestamp_t input) {\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn input;\n+\t}\n+\treturn Timestamp::FromEpochSeconds(input.value);\n+}\n+\n template <>\n date_t CastTimestampNsToDate::Operation(timestamp_t input) {\n+\tif (input == timestamp_t::infinity()) {\n+\t\treturn date_t::infinity();\n+\t} else if (input == timestamp_t::ninfinity()) {\n+\t\treturn date_t::ninfinity();\n+\t}\n \tconst auto us = CastTimestampNsToUs::Operation<timestamp_t, timestamp_t>(input);\n \treturn Timestamp::GetDate(us);\n }\n@@ -1195,17 +1226,18 @@ dtime_t CastTimestampNsToTime::Operation(timestamp_t input) {\n \n template <>\n timestamp_t CastTimestampSecToMs::Operation(timestamp_t input) {\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn input;\n+\t}\n \tauto us = CastTimestampSecToUs::Operation<timestamp_t, timestamp_t>(input);\n \treturn CastTimestampUsToMs::Operation<timestamp_t, timestamp_t>(us);\n }\n \n-template <>\n-timestamp_t CastTimestampSecToUs::Operation(timestamp_t input) {\n-\treturn Timestamp::FromEpochSeconds(input.value);\n-}\n-\n template <>\n timestamp_t CastTimestampSecToNs::Operation(timestamp_t input) {\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn input;\n+\t}\n \tauto us = CastTimestampSecToUs::Operation<timestamp_t, timestamp_t>(input);\n \treturn CastTimestampUsToNs::Operation<timestamp_t, timestamp_t>(us);\n }\n@@ -1230,7 +1262,15 @@ bool TryCastToTimestampNS::Operation(string_t input, timestamp_t &result, bool s\n \tif (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {\n \t\treturn false;\n \t}\n-\tresult = Timestamp::GetEpochNanoSeconds(result);\n+\tif (!Timestamp::IsFinite(result)) {\n+\t\treturn true;\n+\t}\n+\n+\tint64_t nanoseconds;\n+\tif (!Timestamp::TryGetEpochNanoSeconds(result, nanoseconds)) {\n+\t\tthrow ConversionException(\"Could not convert VARCHAR value '%s' to Timestamp(NS)\", input.GetString());\n+\t}\n+\tresult = nanoseconds;\n \treturn true;\n }\n \n@@ -1239,6 +1279,9 @@ bool TryCastToTimestampMS::Operation(string_t input, timestamp_t &result, bool s\n \tif (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {\n \t\treturn false;\n \t}\n+\tif (!Timestamp::IsFinite(result)) {\n+\t\treturn true;\n+\t}\n \tresult = Timestamp::GetEpochMs(result);\n \treturn true;\n }\n@@ -1248,6 +1291,9 @@ bool TryCastToTimestampSec::Operation(string_t input, timestamp_t &result, bool\n \tif (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {\n \t\treturn false;\n \t}\n+\tif (!Timestamp::IsFinite(result)) {\n+\t\treturn true;\n+\t}\n \tresult = Timestamp::GetEpochSeconds(result);\n \treturn true;\n }\n@@ -1257,6 +1303,9 @@ bool TryCastToTimestampNS::Operation(date_t input, timestamp_t &result, bool str\n \tif (!TryCast::Operation<date_t, timestamp_t>(input, result, strict)) {\n \t\treturn false;\n \t}\n+\tif (!Timestamp::IsFinite(result)) {\n+\t\treturn true;\n+\t}\n \tif (!TryMultiplyOperator::Operation(result.value, Interval::NANOS_PER_MICRO, result.value)) {\n \t\treturn false;\n \t}\n@@ -1268,6 +1317,9 @@ bool TryCastToTimestampMS::Operation(date_t input, timestamp_t &result, bool str\n \tif (!TryCast::Operation<date_t, timestamp_t>(input, result, strict)) {\n \t\treturn false;\n \t}\n+\tif (!Timestamp::IsFinite(result)) {\n+\t\treturn true;\n+\t}\n \tresult.value /= Interval::MICROS_PER_MSEC;\n \treturn true;\n }\n@@ -1277,6 +1329,9 @@ bool TryCastToTimestampSec::Operation(date_t input, timestamp_t &result, bool st\n \tif (!TryCast::Operation<date_t, timestamp_t>(input, result, strict)) {\n \t\treturn false;\n \t}\n+\tif (!Timestamp::IsFinite(result)) {\n+\t\treturn true;\n+\t}\n \tresult.value /= Interval::MICROS_PER_MSEC * Interval::MSECS_PER_SEC;\n \treturn true;\n }\ndiff --git a/src/common/types/timestamp.cpp b/src/common/types/timestamp.cpp\nindex aeb8ef53a177..75b5a0d5ac46 100644\n--- a/src/common/types/timestamp.cpp\n+++ b/src/common/types/timestamp.cpp\n@@ -309,7 +309,7 @@ timestamp_t Timestamp::GetCurrentTimestamp() {\n \treturn Timestamp::FromEpochMs(epoch_ms);\n }\n \n-timestamp_t Timestamp::FromEpochSeconds(int64_t sec) {\n+timestamp_t Timestamp::FromEpochSecondsPossiblyInfinite(int64_t sec) {\n \tint64_t result;\n \tif (!TryMultiplyOperator::Operation(sec, Interval::MICROS_PER_SEC, result)) {\n \t\tthrow ConversionException(\"Could not convert Timestamp(S) to Timestamp(US)\");\n@@ -317,7 +317,12 @@ timestamp_t Timestamp::FromEpochSeconds(int64_t sec) {\n \treturn timestamp_t(result);\n }\n \n-timestamp_t Timestamp::FromEpochMs(int64_t ms) {\n+timestamp_t Timestamp::FromEpochSeconds(int64_t sec) {\n+\tD_ASSERT(Timestamp::IsFinite(timestamp_t(sec)));\n+\treturn FromEpochSecondsPossiblyInfinite(sec);\n+}\n+\n+timestamp_t Timestamp::FromEpochMsPossiblyInfinite(int64_t ms) {\n \tint64_t result;\n \tif (!TryMultiplyOperator::Operation(ms, Interval::MICROS_PER_MSEC, result)) {\n \t\tthrow ConversionException(\"Could not convert Timestamp(MS) to Timestamp(US)\");\n@@ -325,19 +330,31 @@ timestamp_t Timestamp::FromEpochMs(int64_t ms) {\n \treturn timestamp_t(result);\n }\n \n+timestamp_t Timestamp::FromEpochMs(int64_t ms) {\n+\tD_ASSERT(Timestamp::IsFinite(timestamp_t(ms)));\n+\treturn FromEpochMsPossiblyInfinite(ms);\n+}\n+\n timestamp_t Timestamp::FromEpochMicroSeconds(int64_t micros) {\n \treturn timestamp_t(micros);\n }\n \n-timestamp_t Timestamp::FromEpochNanoSeconds(int64_t ns) {\n+timestamp_t Timestamp::FromEpochNanoSecondsPossiblyInfinite(int64_t ns) {\n \treturn timestamp_t(ns / 1000);\n }\n \n+timestamp_t Timestamp::FromEpochNanoSeconds(int64_t ns) {\n+\tD_ASSERT(Timestamp::IsFinite(timestamp_t(ns)));\n+\treturn FromEpochNanoSecondsPossiblyInfinite(ns);\n+}\n+\n int64_t Timestamp::GetEpochSeconds(timestamp_t timestamp) {\n+\tD_ASSERT(Timestamp::IsFinite(timestamp));\n \treturn timestamp.value / Interval::MICROS_PER_SEC;\n }\n \n int64_t Timestamp::GetEpochMs(timestamp_t timestamp) {\n+\tD_ASSERT(Timestamp::IsFinite(timestamp));\n \treturn timestamp.value / Interval::MICROS_PER_MSEC;\n }\n \n@@ -345,10 +362,19 @@ int64_t Timestamp::GetEpochMicroSeconds(timestamp_t timestamp) {\n \treturn timestamp.value;\n }\n \n+bool Timestamp::TryGetEpochNanoSeconds(timestamp_t timestamp, int64_t &result) {\n+\tconstexpr static const int64_t NANOSECONDS_IN_MICROSECOND = 1000;\n+\tD_ASSERT(Timestamp::IsFinite(timestamp));\n+\tif (!TryMultiplyOperator::Operation(timestamp.value, NANOSECONDS_IN_MICROSECOND, result)) {\n+\t\treturn false;\n+\t}\n+\treturn true;\n+}\n+\n int64_t Timestamp::GetEpochNanoSeconds(timestamp_t timestamp) {\n \tint64_t result;\n-\tint64_t ns_in_us = 1000;\n-\tif (!TryMultiplyOperator::Operation(timestamp.value, ns_in_us, result)) {\n+\tD_ASSERT(Timestamp::IsFinite(timestamp));\n+\tif (!TryGetEpochNanoSeconds(timestamp, result)) {\n \t\tthrow ConversionException(\"Could not convert Timestamp(US) to Timestamp(NS)\");\n \t}\n \treturn result;\ndiff --git a/src/core_functions/scalar/date/date_diff.cpp b/src/core_functions/scalar/date/date_diff.cpp\nindex 8fdd808d32ee..d4514b90ef63 100644\n--- a/src/core_functions/scalar/date/date_diff.cpp\n+++ b/src/core_functions/scalar/date/date_diff.cpp\n@@ -202,22 +202,30 @@ int64_t DateDiff::MicrosecondsOperator::Operation(timestamp_t startdate, timesta\n \n template <>\n int64_t DateDiff::MillisecondsOperator::Operation(timestamp_t startdate, timestamp_t enddate) {\n+\tD_ASSERT(Timestamp::IsFinite(startdate));\n+\tD_ASSERT(Timestamp::IsFinite(enddate));\n \treturn Timestamp::GetEpochMs(enddate) - Timestamp::GetEpochMs(startdate);\n }\n \n template <>\n int64_t DateDiff::SecondsOperator::Operation(timestamp_t startdate, timestamp_t enddate) {\n+\tD_ASSERT(Timestamp::IsFinite(startdate));\n+\tD_ASSERT(Timestamp::IsFinite(enddate));\n \treturn Timestamp::GetEpochSeconds(enddate) - Timestamp::GetEpochSeconds(startdate);\n }\n \n template <>\n int64_t DateDiff::MinutesOperator::Operation(timestamp_t startdate, timestamp_t enddate) {\n+\tD_ASSERT(Timestamp::IsFinite(startdate));\n+\tD_ASSERT(Timestamp::IsFinite(enddate));\n \treturn Timestamp::GetEpochSeconds(enddate) / Interval::SECS_PER_MINUTE -\n \t       Timestamp::GetEpochSeconds(startdate) / Interval::SECS_PER_MINUTE;\n }\n \n template <>\n int64_t DateDiff::HoursOperator::Operation(timestamp_t startdate, timestamp_t enddate) {\n+\tD_ASSERT(Timestamp::IsFinite(startdate));\n+\tD_ASSERT(Timestamp::IsFinite(enddate));\n \treturn Timestamp::GetEpochSeconds(enddate) / Interval::SECS_PER_HOUR -\n \t       Timestamp::GetEpochSeconds(startdate) / Interval::SECS_PER_HOUR;\n }\ndiff --git a/src/core_functions/scalar/date/date_part.cpp b/src/core_functions/scalar/date/date_part.cpp\nindex 4ffde4e7353a..0b60834e24bc 100644\n--- a/src/core_functions/scalar/date/date_part.cpp\n+++ b/src/core_functions/scalar/date/date_part.cpp\n@@ -395,8 +395,11 @@ struct DatePart {\n \t\tstatic void Inverse(DataChunk &input, ExpressionState &state, Vector &result) {\n \t\t\tD_ASSERT(input.ColumnCount() == 1);\n \n-\t\t\tUnaryExecutor::Execute<int64_t, timestamp_t>(input.data[0], result, input.size(),\n-\t\t\t                                             [&](int64_t input) { return Timestamp::FromEpochMs(input); });\n+\t\t\tUnaryExecutor::Execute<int64_t, timestamp_t>(input.data[0], result, input.size(), [&](int64_t input) {\n+\t\t\t\t// milisecond amounts provided to epoch_ms should never be considered infinite\n+\t\t\t\t// instead such values will just throw when converted to microseconds\n+\t\t\t\treturn Timestamp::FromEpochMsPossiblyInfinite(input);\n+\t\t\t});\n \t\t}\n \t};\n \n@@ -999,11 +1002,13 @@ int64_t DatePart::YearWeekOperator::Operation(dtime_tz_t input) {\n \n template <>\n int64_t DatePart::EpochNanosecondsOperator::Operation(timestamp_t input) {\n+\tD_ASSERT(Timestamp::IsFinite(input));\n \treturn Timestamp::GetEpochNanoSeconds(input);\n }\n \n template <>\n int64_t DatePart::EpochNanosecondsOperator::Operation(date_t input) {\n+\tD_ASSERT(Date::IsFinite(input));\n \treturn Date::EpochNanoseconds(input);\n }\n \n@@ -1032,6 +1037,12 @@ int64_t DatePart::EpochMicrosecondsOperator::Operation(interval_t input) {\n \treturn Interval::GetMicro(input);\n }\n \n+template <>\n+int64_t DatePart::EpochMillisOperator::Operation(timestamp_t input) {\n+\tD_ASSERT(Timestamp::IsFinite(input));\n+\treturn Timestamp::GetEpochMs(input);\n+}\n+\n template <>\n int64_t DatePart::EpochMicrosecondsOperator::Operation(dtime_t input) {\n \treturn input.micros;\n@@ -1064,6 +1075,7 @@ int64_t DatePart::EpochMillisOperator::Operation(dtime_tz_t input) {\n \n template <>\n int64_t DatePart::MicrosecondsOperator::Operation(timestamp_t input) {\n+\tD_ASSERT(Timestamp::IsFinite(input));\n \tauto time = Timestamp::GetTime(input);\n \t// remove everything but the second & microsecond part\n \treturn time.micros % Interval::MICROS_PER_MINUTE;\n@@ -1088,6 +1100,7 @@ int64_t DatePart::MicrosecondsOperator::Operation(dtime_tz_t input) {\n \n template <>\n int64_t DatePart::MillisecondsOperator::Operation(timestamp_t input) {\n+\tD_ASSERT(Timestamp::IsFinite(input));\n \treturn MicrosecondsOperator::Operation<timestamp_t, int64_t>(input) / Interval::MICROS_PER_MSEC;\n }\n \n@@ -1108,6 +1121,7 @@ int64_t DatePart::MillisecondsOperator::Operation(dtime_tz_t input) {\n \n template <>\n int64_t DatePart::SecondsOperator::Operation(timestamp_t input) {\n+\tD_ASSERT(Timestamp::IsFinite(input));\n \treturn MicrosecondsOperator::Operation<timestamp_t, int64_t>(input) / Interval::MICROS_PER_SEC;\n }\n \n@@ -1128,6 +1142,7 @@ int64_t DatePart::SecondsOperator::Operation(dtime_tz_t input) {\n \n template <>\n int64_t DatePart::MinutesOperator::Operation(timestamp_t input) {\n+\tD_ASSERT(Timestamp::IsFinite(input));\n \tauto time = Timestamp::GetTime(input);\n \t// remove the hour part, and truncate to minutes\n \treturn (time.micros % Interval::MICROS_PER_HOUR) / Interval::MICROS_PER_MINUTE;\n@@ -1152,6 +1167,7 @@ int64_t DatePart::MinutesOperator::Operation(dtime_tz_t input) {\n \n template <>\n int64_t DatePart::HoursOperator::Operation(timestamp_t input) {\n+\tD_ASSERT(Timestamp::IsFinite(input));\n \treturn Timestamp::GetTime(input).micros / Interval::MICROS_PER_HOUR;\n }\n \n@@ -1172,6 +1188,7 @@ int64_t DatePart::HoursOperator::Operation(dtime_tz_t input) {\n \n template <>\n double DatePart::EpochOperator::Operation(timestamp_t input) {\n+\tD_ASSERT(Timestamp::IsFinite(input));\n \treturn Timestamp::GetEpochMicroSeconds(input) / double(Interval::MICROS_PER_SEC);\n }\n \n@@ -1218,6 +1235,7 @@ unique_ptr<BaseStatistics> DatePart::EpochOperator::PropagateStatistics<dtime_t>\n \n template <>\n int64_t DatePart::EraOperator::Operation(timestamp_t input) {\n+\tD_ASSERT(Timestamp::IsFinite(input));\n \treturn EraOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));\n }\n \n@@ -1407,6 +1425,7 @@ void DatePart::StructOperator::Operation(bigint_vec &bigint_values, double_vec &\n template <>\n void DatePart::StructOperator::Operation(bigint_vec &bigint_values, double_vec &double_values, const timestamp_t &input,\n                                          const idx_t idx, const part_mask_t mask) {\n+\tD_ASSERT(Timestamp::IsFinite(input));\n \tdate_t d;\n \tdtime_t t;\n \tTimestamp::Convert(input, d, t);\ndiff --git a/src/function/cast/time_casts.cpp b/src/function/cast/time_casts.cpp\nindex 2d920490841c..4ac38d121d71 100644\n--- a/src/function/cast/time_casts.cpp\n+++ b/src/function/cast/time_casts.cpp\n@@ -125,6 +125,10 @@ BoundCastInfo DefaultCasts::TimestampNsCastSwitch(BindCastInput &input, const Lo\n \t\t// timestamp (ns) to timestamp (us)\n \t\treturn BoundCastInfo(\n \t\t    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampNsToUs>);\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\t\t// timestamp (ns) to timestamp with time zone (us)\n+\t\treturn BoundCastInfo(\n+\t\t    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampNsToUs>);\n \tdefault:\n \t\treturn TryVectorNullCast;\n \t}\n@@ -152,6 +156,10 @@ BoundCastInfo DefaultCasts::TimestampMsCastSwitch(BindCastInput &input, const Lo\n \t\t// timestamp (ms) to timestamp (ns)\n \t\treturn BoundCastInfo(\n \t\t    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampMsToNs>);\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\t\t// timestamp (ms) to timestamp with timezone (us)\n+\t\treturn BoundCastInfo(\n+\t\t    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampMsToUs>);\n \tdefault:\n \t\treturn TryVectorNullCast;\n \t}\n@@ -180,6 +188,10 @@ BoundCastInfo DefaultCasts::TimestampSecCastSwitch(BindCastInput &input, const L\n \t\t// timestamp (s) to timestamp (us)\n \t\treturn BoundCastInfo(\n \t\t    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampSecToUs>);\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\t\t// timestamp (s) to timestamp with timezone (us)\n+\t\treturn BoundCastInfo(\n+\t\t    &VectorCastHelpers::TemplatedCastLoop<timestamp_t, timestamp_t, duckdb::CastTimestampSecToUs>);\n \tcase LogicalTypeId::TIMESTAMP_NS:\n \t\t// timestamp (s) to timestamp (ns)\n \t\treturn BoundCastInfo(\ndiff --git a/src/include/duckdb/common/types/timestamp.hpp b/src/include/duckdb/common/types/timestamp.hpp\nindex 0d0851fa3a93..cf7dce95bdfc 100644\n--- a/src/include/duckdb/common/types/timestamp.hpp\n+++ b/src/include/duckdb/common/types/timestamp.hpp\n@@ -137,14 +137,19 @@ class Timestamp {\n \tDUCKDB_API static timestamp_t GetCurrentTimestamp();\n \n \t//! Convert the epoch (in sec) to a timestamp\n-\tDUCKDB_API static timestamp_t FromEpochSeconds(int64_t ms);\n+\tDUCKDB_API static timestamp_t FromEpochSecondsPossiblyInfinite(int64_t s);\n+\tDUCKDB_API static timestamp_t FromEpochSeconds(int64_t s);\n \t//! Convert the epoch (in ms) to a timestamp\n+\tDUCKDB_API static timestamp_t FromEpochMsPossiblyInfinite(int64_t ms);\n \tDUCKDB_API static timestamp_t FromEpochMs(int64_t ms);\n \t//! Convert the epoch (in microseconds) to a timestamp\n \tDUCKDB_API static timestamp_t FromEpochMicroSeconds(int64_t micros);\n \t//! Convert the epoch (in nanoseconds) to a timestamp\n-\tDUCKDB_API static timestamp_t FromEpochNanoSeconds(int64_t micros);\n+\tDUCKDB_API static timestamp_t FromEpochNanoSecondsPossiblyInfinite(int64_t nanos);\n+\tDUCKDB_API static timestamp_t FromEpochNanoSeconds(int64_t nanos);\n \n+\t//! Try convert a timestamp to epoch (in nanoseconds)\n+\tDUCKDB_API static bool TryGetEpochNanoSeconds(timestamp_t timestamp, int64_t &result);\n \t//! Convert the epoch (in seconds) to a timestamp\n \tDUCKDB_API static int64_t GetEpochSeconds(timestamp_t timestamp);\n \t//! Convert the epoch (in ms) to a timestamp\ndiff --git a/src/main/capi/result-c.cpp b/src/main/capi/result-c.cpp\nindex c3b62c410741..610ecc3b6afc 100644\n--- a/src/main/capi/result-c.cpp\n+++ b/src/main/capi/result-c.cpp\n@@ -54,6 +54,9 @@ struct CBlobConverter {\n struct CTimestampMsConverter : public CBaseConverter {\n \ttemplate <class SRC, class DST>\n \tstatic DST Convert(SRC input) {\n+\t\tif (!Timestamp::IsFinite(input)) {\n+\t\t\treturn input;\n+\t\t}\n \t\treturn Timestamp::FromEpochMs(input.value);\n \t}\n };\n@@ -61,6 +64,9 @@ struct CTimestampMsConverter : public CBaseConverter {\n struct CTimestampNsConverter : public CBaseConverter {\n \ttemplate <class SRC, class DST>\n \tstatic DST Convert(SRC input) {\n+\t\tif (!Timestamp::IsFinite(input)) {\n+\t\t\treturn input;\n+\t\t}\n \t\treturn Timestamp::FromEpochNanoSeconds(input.value);\n \t}\n };\n@@ -68,6 +74,9 @@ struct CTimestampNsConverter : public CBaseConverter {\n struct CTimestampSecConverter : public CBaseConverter {\n \ttemplate <class SRC, class DST>\n \tstatic DST Convert(SRC input) {\n+\t\tif (!Timestamp::IsFinite(input)) {\n+\t\t\treturn input;\n+\t\t}\n \t\treturn Timestamp::FromEpochSeconds(input.value);\n \t}\n };\ndiff --git a/src/optimizer/statistics/expression/propagate_cast.cpp b/src/optimizer/statistics/expression/propagate_cast.cpp\nindex 4daf5ee58e47..94908ea48665 100644\n--- a/src/optimizer/statistics/expression/propagate_cast.cpp\n+++ b/src/optimizer/statistics/expression/propagate_cast.cpp\n@@ -24,7 +24,7 @@ static unique_ptr<BaseStatistics> StatisticsOperationsNumericNumericCast(const B\n static unique_ptr<BaseStatistics> StatisticsNumericCastSwitch(const BaseStatistics &input, const LogicalType &target) {\n \t//\tDowncasting timestamps to times is not a truncation operation\n \tswitch (target.id()) {\n-\tcase LogicalTypeId::TIME:\n+\tcase LogicalTypeId::TIME: {\n \t\tswitch (input.GetType().id()) {\n \t\tcase LogicalTypeId::TIMESTAMP:\n \t\tcase LogicalTypeId::TIMESTAMP_TZ:\n@@ -33,6 +33,76 @@ static unique_ptr<BaseStatistics> StatisticsNumericCastSwitch(const BaseStatisti\n \t\t\tbreak;\n \t\t}\n \t\tbreak;\n+\t}\n+\t// FIXME: perform actual stats propagation for these casts\n+\tcase LogicalTypeId::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP_TZ: {\n+\t\tconst bool to_timestamp = target.id() == LogicalTypeId::TIMESTAMP;\n+\t\tconst bool to_timestamp_tz = target.id() == LogicalTypeId::TIMESTAMP_TZ;\n+\t\t//  Casting to timestamp[_tz] (us) from a different unit can not re-use stats\n+\t\tswitch (input.GetType().id()) {\n+\t\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\t\treturn nullptr;\n+\t\tcase LogicalTypeId::TIMESTAMP: {\n+\t\t\tif (to_timestamp_tz) {\n+\t\t\t\t// Both use INT64 physical type, but should not be treated equal\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase LogicalTypeId::TIMESTAMP_TZ: {\n+\t\t\tif (to_timestamp) {\n+\t\t\t\t// Both use INT64 physical type, but should not be treated equal\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::TIMESTAMP_NS: {\n+\t\t// Same as above ^\n+\t\tswitch (input.GetType().id()) {\n+\t\tcase LogicalTypeId::TIMESTAMP:\n+\t\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\t\tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\t\treturn nullptr;\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::TIMESTAMP_MS: {\n+\t\t// Same as above ^\n+\t\tswitch (input.GetType().id()) {\n+\t\tcase LogicalTypeId::TIMESTAMP:\n+\t\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\t\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\t\treturn nullptr;\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::TIMESTAMP_SEC: {\n+\t\t// Same as above ^\n+\t\tswitch (input.GetType().id()) {\n+\t\tcase LogicalTypeId::TIMESTAMP:\n+\t\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\t\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\t\treturn nullptr;\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\t\tbreak;\n+\t}\n \tdefault:\n \t\tbreak;\n \t}\ndiff --git a/tools/odbc/statement_functions.cpp b/tools/odbc/statement_functions.cpp\nindex a9de5c66fdd5..e1470048f277 100644\n--- a/tools/odbc/statement_functions.cpp\n+++ b/tools/odbc/statement_functions.cpp\n@@ -6,6 +6,7 @@\n #include \"descriptor.hpp\"\n #include \"parameter_descriptor.hpp\"\n \n+#include \"duckdb/common/types/timestamp.hpp\"\n #include \"duckdb/common/types/decimal.hpp\"\n #include \"duckdb/common/types/string_type.hpp\"\n #include \"duckdb/common/operator/cast_operators.hpp\"\n@@ -38,6 +39,7 @@ using duckdb::SQLStateType;\n using duckdb::Store;\n using duckdb::string;\n using duckdb::string_t;\n+using duckdb::Timestamp;\n using duckdb::timestamp_t;\n using duckdb::vector;\n \n@@ -190,7 +192,12 @@ template <class CAST_OP, typename TARGET_TYPE, class CAST_FUNC = std::function<t\n static bool CastTimestampValue(duckdb::OdbcHandleStmt *hstmt, const duckdb::Value &val, TARGET_TYPE &target,\n                                CAST_FUNC cast_timestamp_fun) {\n \ttry {\n-\t\ttimestamp_t timestamp = cast_timestamp_fun(val.GetValue<int64_t>());\n+\t\tauto input = val.GetValue<int64_t>();\n+\t\tauto timestamp = timestamp_t(input);\n+\t\t// FIXME: add test for casting infinity/-infinity timestamp values\n+\t\tif (Timestamp::IsFinite(timestamp)) {\n+\t\t\ttimestamp = cast_timestamp_fun(input);\n+\t\t}\n \t\ttarget = CAST_OP::template Operation<timestamp_t, TARGET_TYPE>(timestamp);\n \t\treturn true;\n \t} catch (std::exception &ex) {\n@@ -527,18 +534,38 @@ SQLRETURN duckdb::GetDataStmtResult(OdbcHandleStmt *hstmt, SQLUSMALLINT col_or_p\n \tcase SQL_C_TYPE_TIMESTAMP: {\n \t\ttimestamp_t timestamp;\n \t\tswitch (val.type().id()) {\n-\t\tcase LogicalTypeId::TIMESTAMP_SEC:\n-\t\t\ttimestamp = duckdb::Timestamp::FromEpochSeconds(val.GetValue<int64_t>());\n+\t\tcase LogicalTypeId::TIMESTAMP_SEC: {\n+\t\t\ttimestamp = timestamp_t(val.GetValue<int64_t>());\n+\t\t\t// FIXME: add test for casting infinity/-infinity timestamp values\n+\t\t\tif (!Timestamp::IsFinite(timestamp)) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\ttimestamp = duckdb::Timestamp::FromEpochSeconds(timestamp.value);\n \t\t\tbreak;\n-\t\tcase LogicalTypeId::TIMESTAMP_MS:\n-\t\t\ttimestamp = duckdb::Timestamp::FromEpochMs(val.GetValue<int64_t>());\n+\t\t}\n+\t\tcase LogicalTypeId::TIMESTAMP_MS: {\n+\t\t\ttimestamp = timestamp_t(val.GetValue<int64_t>());\n+\t\t\t// FIXME: add test for casting infinity/-infinity timestamp values\n+\t\t\tif (!Timestamp::IsFinite(timestamp)) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\ttimestamp = duckdb::Timestamp::FromEpochMs(timestamp.value);\n \t\t\tbreak;\n-\t\tcase LogicalTypeId::TIMESTAMP:\n-\t\t\ttimestamp = duckdb::Timestamp::FromEpochMicroSeconds(val.GetValue<int64_t>());\n+\t\t}\n+\t\tcase LogicalTypeId::TIMESTAMP: {\n+\t\t\ttimestamp = timestamp_t(val.GetValue<int64_t>());\n+\t\t\ttimestamp = duckdb::Timestamp::FromEpochMicroSeconds(timestamp.value);\n \t\t\tbreak;\n-\t\tcase LogicalTypeId::TIMESTAMP_NS:\n-\t\t\ttimestamp = duckdb::Timestamp::FromEpochNanoSeconds(val.GetValue<int64_t>());\n+\t\t}\n+\t\tcase LogicalTypeId::TIMESTAMP_NS: {\n+\t\t\ttimestamp = timestamp_t(val.GetValue<int64_t>());\n+\t\t\t// FIXME: add test for casting infinity/-infinity timestamp values\n+\t\t\tif (!Timestamp::IsFinite(timestamp)) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\ttimestamp = duckdb::Timestamp::FromEpochNanoSeconds(timestamp.value);\n \t\t\tbreak;\n+\t\t}\n \t\tcase LogicalTypeId::DATE: {\n \t\t\tauto date_input = val.GetValue<date_t>();\n \t\t\tif (!TryCast::Operation<date_t, timestamp_t>(date_input, timestamp)) {\ndiff --git a/tools/pythonpkg/src/arrow/arrow_array_stream.cpp b/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\nindex 8f8393b24984..a17e72c5c08c 100644\n--- a/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\n+++ b/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\n@@ -180,15 +180,20 @@ string ConvertTimestampUnit(ArrowDateTimeType unit) {\n }\n \n int64_t ConvertTimestampTZValue(int64_t base_value, ArrowDateTimeType datetime_type) {\n+\tauto input = timestamp_t(base_value);\n+\tif (!Timestamp::IsFinite(input)) {\n+\t\treturn base_value;\n+\t}\n+\n \tswitch (datetime_type) {\n \tcase ArrowDateTimeType::MICROSECONDS:\n-\t\treturn Timestamp::GetEpochMicroSeconds(timestamp_t(base_value));\n+\t\treturn Timestamp::GetEpochMicroSeconds(input);\n \tcase ArrowDateTimeType::MILLISECONDS:\n-\t\treturn Timestamp::GetEpochMs(timestamp_t(base_value));\n+\t\treturn Timestamp::GetEpochMs(input);\n \tcase ArrowDateTimeType::NANOSECONDS:\n-\t\treturn Timestamp::GetEpochNanoSeconds(timestamp_t(base_value));\n+\t\treturn Timestamp::GetEpochNanoSeconds(input);\n \tcase ArrowDateTimeType::SECONDS:\n-\t\treturn Timestamp::GetEpochSeconds(timestamp_t(base_value));\n+\t\treturn Timestamp::GetEpochSeconds(input);\n \tdefault:\n \t\tthrow NotImplementedException(\"DatetimeType not recognized in ConvertTimestampTZValue\");\n \t}\ndiff --git a/tools/pythonpkg/src/native/python_objects.cpp b/tools/pythonpkg/src/native/python_objects.cpp\nindex 9dab0174448e..4c5d7879cdea 100644\n--- a/tools/pythonpkg/src/native/python_objects.cpp\n+++ b/tools/pythonpkg/src/native/python_objects.cpp\n@@ -448,7 +448,14 @@ py::object PythonObject::FromValue(const Value &val, const LogicalType &type,\n \t\tD_ASSERT(type.InternalType() == PhysicalType::INT64);\n \t\tauto timestamp = val.GetValueUnsafe<timestamp_t>();\n \n-\t\tInfinityType infinity = InfinityType::NONE;\n+\t\tInfinityType infinity = GetTimestampInfinityType(timestamp);\n+\t\tif (infinity == InfinityType::POSITIVE) {\n+\t\t\treturn py::reinterpret_borrow<py::object>(import_cache.datetime.datetime.max());\n+\t\t}\n+\t\tif (infinity == InfinityType::NEGATIVE) {\n+\t\t\treturn py::reinterpret_borrow<py::object>(import_cache.datetime.datetime.min());\n+\t\t}\n+\n \t\tif (type.id() == LogicalTypeId::TIMESTAMP_MS) {\n \t\t\ttimestamp = Timestamp::FromEpochMs(timestamp.value);\n \t\t} else if (type.id() == LogicalTypeId::TIMESTAMP_NS) {\n@@ -456,19 +463,7 @@ py::object PythonObject::FromValue(const Value &val, const LogicalType &type,\n \t\t} else if (type.id() == LogicalTypeId::TIMESTAMP_SEC) {\n \t\t\ttimestamp = Timestamp::FromEpochSeconds(timestamp.value);\n \t\t}\n-\t\tinfinity = GetTimestampInfinityType(timestamp);\n \n-\t\t// Deal with infinity\n-\t\tswitch (infinity) {\n-\t\tcase InfinityType::POSITIVE: {\n-\t\t\treturn py::reinterpret_borrow<py::object>(import_cache.datetime.datetime.max());\n-\t\t}\n-\t\tcase InfinityType::NEGATIVE: {\n-\t\t\treturn py::reinterpret_borrow<py::object>(import_cache.datetime.datetime.min());\n-\t\t}\n-\t\tcase InfinityType::NONE:\n-\t\t\tbreak;\n-\t\t}\n \t\tint32_t year, month, day, hour, min, sec, micros;\n \t\tdate_t date;\n \t\tdtime_t time;\ndiff --git a/tools/pythonpkg/src/numpy/array_wrapper.cpp b/tools/pythonpkg/src/numpy/array_wrapper.cpp\nindex cd049a488e71..016544481bb8 100644\n--- a/tools/pythonpkg/src/numpy/array_wrapper.cpp\n+++ b/tools/pythonpkg/src/numpy/array_wrapper.cpp\n@@ -31,6 +31,9 @@ struct RegularConvert {\n struct TimestampConvert {\n \ttemplate <class DUCKDB_T, class NUMPY_T>\n \tstatic int64_t ConvertValue(timestamp_t val) {\n+\t\tif (!Timestamp::IsFinite(val)) {\n+\t\t\treturn val.value;\n+\t\t}\n \t\treturn Timestamp::GetEpochNanoSeconds(val);\n \t}\n \n@@ -44,6 +47,9 @@ struct TimestampConvert {\n struct TimestampConvertSec {\n \ttemplate <class DUCKDB_T, class NUMPY_T>\n \tstatic int64_t ConvertValue(timestamp_t val) {\n+\t\tif (!Timestamp::IsFinite(val)) {\n+\t\t\treturn val.value;\n+\t\t}\n \t\treturn Timestamp::GetEpochNanoSeconds(Timestamp::FromEpochSeconds(val.value));\n \t}\n \n@@ -57,6 +63,9 @@ struct TimestampConvertSec {\n struct TimestampConvertMilli {\n \ttemplate <class DUCKDB_T, class NUMPY_T>\n \tstatic int64_t ConvertValue(timestamp_t val) {\n+\t\tif (!Timestamp::IsFinite(val)) {\n+\t\t\treturn val.value;\n+\t\t}\n \t\treturn Timestamp::GetEpochNanoSeconds(Timestamp::FromEpochMs(val.value));\n \t}\n \ndiff --git a/tools/pythonpkg/src/numpy/numpy_scan.cpp b/tools/pythonpkg/src/numpy/numpy_scan.cpp\nindex e74540318844..032d3b97f014 100644\n--- a/tools/pythonpkg/src/numpy/numpy_scan.cpp\n+++ b/tools/pythonpkg/src/numpy/numpy_scan.cpp\n@@ -285,7 +285,12 @@ void NumpyScan::Scan(PandasColumnBindData &bind_data, idx_t count, idx_t offset,\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\t// Direct conversion, we've already matched the numpy type with the equivalent duckdb type\n-\t\t\ttgt_ptr[row] = convert_func(src_ptr[source_idx]);\n+\t\t\tauto input = timestamp_t(src_ptr[source_idx]);\n+\t\t\tif (Timestamp::IsFinite(input)) {\n+\t\t\t\ttgt_ptr[row] = convert_func(src_ptr[source_idx]);\n+\t\t\t} else {\n+\t\t\t\ttgt_ptr[row] = input;\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \t}\n",
  "test_patch": "diff --git a/test/sql/cast/test_string_cast.test b/test/sql/cast/test_string_cast.test\nindex 730f865fabfe..d558932c0e61 100644\n--- a/test/sql/cast/test_string_cast.test\n+++ b/test/sql/cast/test_string_cast.test\n@@ -231,3 +231,30 @@ SELECT '0'::${inttype};\n 0\n \n endloop\n+\n+# Casting infinities of various timestamp units\n+\n+foreach ts timestamp timestamp_ms timestamp_ns timestamp_s timestamptz\n+\n+query I\n+SELECT ('infinity'::${ts})::VARCHAR\n+----\n+infinity\n+\n+query I\n+SELECT ('-infinity'::${ts})::VARCHAR\n+----\n+-infinity\n+\n+query I\n+SELECT TRY_CAST('infinity' AS ${ts})\n+----\n+infinity\n+\n+query I\n+SELECT TRY_CAST('-infinity' AS ${ts})\n+----\n+-infinity\n+\n+#ts\n+endloop\ndiff --git a/test/sql/function/timestamp/test_date_part.test b/test/sql/function/timestamp/test_date_part.test\nindex 4198cf26338b..178f570ea234 100644\n--- a/test/sql/function/timestamp/test_date_part.test\n+++ b/test/sql/function/timestamp/test_date_part.test\n@@ -755,6 +755,16 @@ NULL\tNULL\n 2022-01-01 00:00:41+00\t1640995241000\n infinity\tNULL\n \n+statement error\n+select epoch_ms(9223372036854775807)\n+----\n+Conversion Error: Could not convert Timestamp(MS) to Timestamp(US)\n+\n+statement error\n+select epoch_ms(-9223372036854775808)\n+----\n+Conversion Error: Could not convert Timestamp(MS) to Timestamp(US)\n+\n query II\n SELECT ts, epoch_ns(ts) FROM timestamps ORDER BY ALL;\n ----\ndiff --git a/test/sql/types/timestamp/infinity_cast_coverage.test b/test/sql/types/timestamp/infinity_cast_coverage.test\nnew file mode 100644\nindex 000000000000..5cd5bbbf5240\n--- /dev/null\n+++ b/test/sql/types/timestamp/infinity_cast_coverage.test\n@@ -0,0 +1,30 @@\n+# name: test/sql/types/timestamp/infinity_cast_coverage.test\n+# description: Test casting to TIMESTAMP WITH TIME ZONE from any unit\n+# group: [timestamp]\n+\n+statement ok\n+pragma enable_verification;\n+\n+require icu\n+\n+foreach infinity_string infinity -infinity\n+\n+foreach base_type TIMESTAMP TIMESTAMP_MS TIMESTAMP_NS TIMESTAMP_S TIMESTAMPTZ\n+\n+# FIXME: this should be expanded with the other base types\n+# Conversion Error: Unimplemented type for cast (TIMESTAMP_MS -> TIMESTAMP_S)\n+foreach target_type TIMESTAMPTZ TIMESTAMP\n+\n+query I\n+select '${infinity_string}'::${base_type}::${target_type} == '${infinity_string}'\n+----\n+true\n+\n+# target_type\n+endloop\n+\n+# base_type\n+endloop\n+\n+# infinity_string\n+endloop\ndiff --git a/test/sql/types/timestamp/test_timestamp_to_tz_cast.test b/test/sql/types/timestamp/test_timestamp_to_tz_cast.test\nnew file mode 100644\nindex 000000000000..fd0afc1857b9\n--- /dev/null\n+++ b/test/sql/types/timestamp/test_timestamp_to_tz_cast.test\n@@ -0,0 +1,244 @@\n+# name: test/sql/types/timestamp/test_timestamp_to_tz_cast.test\n+# description: Test casting to TIMESTAMP WITH TIME ZONE from any unit\n+# group: [timestamp]\n+\n+require icu\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# Note: this also contains TIMESTAMP_NS\n+foreach unit TIMESTAMP TIMESTAMP_NS TIMESTAMP_MS TIMESTAMP_S\n+\n+# Basic value\n+statement ok\n+create table ts_${unit}_tbl_1 as from VALUES\n+\t('1990/12/21'::${unit})\n+as t(ts);\n+\n+# NULL\n+statement ok\n+create table ts_${unit}_tbl_null as FROM VALUES\n+\t(NULL::${unit})\n+as t(ts);\n+\n+# Positive infinity\n+statement ok\n+create table ts_${unit}_tbl_posinf as from VALUES\n+\t('infinity'::${unit})\n+as t(ts);\n+\n+# Negative infinity\n+statement ok\n+create table ts_${unit}_tbl_mininf as from VALUES\n+\t('-infinity'::${unit})\n+as t(ts);\n+\n+endloop\n+\n+foreach unit TIMESTAMP TIMESTAMP_MS TIMESTAMP_S\n+\n+# Extreme positive\n+statement ok\n+create table ts_${unit}_tbl_2 as from VALUES\n+\t('294247-01-10'::${unit})\n+as t(ts);\n+\n+# Extreme negative\n+statement ok\n+create table ts_${unit}_tbl_3 as from VALUES\n+\t('29720-04-05 (BC) 22:13:20'::${unit})\n+as t(ts);\n+\n+endloop\n+\n+statement ok\n+SET Calendar='gregorian';\n+\n+# ---------------- UTC ----------------\n+\n+statement ok\n+SET TimeZone='UTC';\n+\n+# Table 1 | UTC +0\n+foreach unit TIMESTAMP TIMESTAMP_NS TIMESTAMP_MS TIMESTAMP_S\n+\n+query II nosort result_utc_1\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_1;\n+----\n+\n+endloop\n+\n+# Table 2 | UTC +0\n+foreach unit TIMESTAMP TIMESTAMP_MS TIMESTAMP_S\n+\n+query II nosort result_utc_2\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_2;\n+----\n+\n+endloop\n+\n+# Table 3 | UTC +0\n+foreach unit TIMESTAMP TIMESTAMP_MS TIMESTAMP_S\n+\n+query II nosort result_utc_3\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_3;\n+----\n+\n+endloop\n+\n+# Table +inf | UTC +0\n+foreach unit TIMESTAMP TIMESTAMP_NS TIMESTAMP_MS TIMESTAMP_S\n+\n+query II\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_posinf;\n+----\n+infinity\tinfinity\n+\n+endloop\n+\n+# Table -inf | UTC +0\n+foreach unit TIMESTAMP TIMESTAMP_NS TIMESTAMP_MS TIMESTAMP_S\n+\n+query II\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_mininf;\n+----\n+-infinity\t-infinity\n+\n+endloop\n+\n+# Table NULL | UTC +0\n+foreach unit TIMESTAMP TIMESTAMP_NS TIMESTAMP_MS TIMESTAMP_S\n+\n+query II nosort result_utc_null\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_null;\n+----\n+\n+endloop\n+\n+# ---------------- America / Los Angeles ----------------\n+\n+statement ok\n+SET TimeZone='America/Los_Angeles'\n+\n+# Table 1 | America -7/8\n+foreach unit TIMESTAMP TIMESTAMP_MS TIMESTAMP_S\n+\n+query II nosort result_america_1\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_1;\n+----\n+\n+endloop\n+\n+# Table 2 | America -7/8\n+foreach unit TIMESTAMP TIMESTAMP_MS TIMESTAMP_S\n+\n+# This timestamp is near the end of the valid range, this timezone would overflow the value\n+statement error\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_2;\n+----\n+Conversion Error: Unable to convert ICU date to timestamp\n+\n+endloop\n+\n+# Table 3 | America -7/8\n+foreach unit TIMESTAMP TIMESTAMP_MS TIMESTAMP_S\n+\n+query II nosort result_america_3\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_3;\n+----\n+\n+endloop\n+\n+# Table +inf | America -7/8\n+foreach unit TIMESTAMP TIMESTAMP_NS TIMESTAMP_MS TIMESTAMP_S\n+\n+query II\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_posinf;\n+----\n+infinity\tinfinity\n+\n+endloop\n+\n+# Table -inf | America -7/8\n+foreach unit TIMESTAMP TIMESTAMP_NS TIMESTAMP_MS TIMESTAMP_S\n+\n+query II\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_mininf;\n+----\n+-infinity\t-infinity\n+\n+endloop\n+\n+# Table NULL | America -7/8\n+\n+foreach unit TIMESTAMP TIMESTAMP_NS TIMESTAMP_MS TIMESTAMP_S\n+\n+query II nosort result_america_null\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_null;\n+----\n+\n+endloop\n+\n+# ---------------- ETC ----------------\n+\n+statement ok\n+SET TimeZone='Etc/GMT-6'\n+\n+# Table 1 | ETC +6\n+foreach unit TIMESTAMP TIMESTAMP_MS TIMESTAMP_S\n+\n+query II nosort result_etc_1\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_1;\n+----\n+\n+endloop\n+\n+# Table 2 | ETC +6\n+foreach unit TIMESTAMP TIMESTAMP_MS TIMESTAMP_S\n+\n+query II nosort result_etc_2\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_2;\n+----\n+\n+endloop\n+\n+# Table 3 | ETC +6\n+foreach unit TIMESTAMP TIMESTAMP_MS TIMESTAMP_S\n+\n+# FIXME: I would expect this to overflow???\n+query II nosort result_etc_3\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_3;\n+----\n+\n+endloop\n+\n+# Table +inf | ETC +6\n+foreach unit TIMESTAMP TIMESTAMP_NS TIMESTAMP_MS TIMESTAMP_S\n+\n+query II\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_posinf;\n+----\n+infinity\tinfinity\n+\n+endloop\n+\n+# Table -inf | ETC +6\n+foreach unit TIMESTAMP TIMESTAMP_NS TIMESTAMP_MS TIMESTAMP_S\n+\n+query II\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_mininf;\n+----\n+-infinity\t-infinity\n+\n+endloop\n+\n+# Table NULL | ETC +6\n+\n+foreach unit TIMESTAMP TIMESTAMP_NS TIMESTAMP_MS TIMESTAMP_S\n+\n+query II nosort result_etc_null\n+select ts as base, base::TIMESTAMPTZ as tstz from ts_${unit}_tbl_null;\n+----\n+\n+endloop\ndiff --git a/tools/pythonpkg/tests/fast/arrow/test_timestamps.py b/tools/pythonpkg/tests/fast/arrow/test_timestamps.py\nindex 5d404112bdd8..f43ca9514ffd 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_timestamps.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_timestamps.py\n@@ -59,17 +59,19 @@ def test_timestamp_overflow(self, duckdb_cursor):\n         assert arrow_from_duck['b'] == arrow_table['b']\n         assert arrow_from_duck['c'] == arrow_table['c']\n \n-        with pytest.raises(duckdb.ConversionException, match='Could not convert'):\n-            duck_rel = duckdb.from_arrow(arrow_table)\n-            res = duck_rel.project('a::TIMESTAMP_US')\n-            res.fetchone()\n+        expected = (datetime.datetime(9999, 12, 31, 23, 59, 59, 999999),)\n \n-        with pytest.raises(duckdb.ConversionException, match='Could not convert'):\n-            duck_rel = duckdb.from_arrow(arrow_table)\n-            res = duck_rel.project('b::TIMESTAMP_US')\n-            res.fetchone()\n+        duck_rel = duckdb.from_arrow(arrow_table)\n+        res = duck_rel.project('a::TIMESTAMP_US')\n+        result = res.fetchone()\n+        assert result == expected\n \n-        with pytest.raises(duckdb.ConversionException, match='Could not convert'):\n-            duck_rel = duckdb.from_arrow(arrow_table)\n-            res = duck_rel.project('c::TIMESTAMP_NS')\n-            res.fetchone()\n+        duck_rel = duckdb.from_arrow(arrow_table)\n+        res = duck_rel.project('b::TIMESTAMP_US')\n+        result = res.fetchone()\n+        assert result == expected\n+\n+        duck_rel = duckdb.from_arrow(arrow_table)\n+        res = duck_rel.project('c::TIMESTAMP_NS')\n+        result = res.fetchone()\n+        assert result == expected\ndiff --git a/tools/pythonpkg/tests/fast/pandas/test_datetime_timestamp.py b/tools/pythonpkg/tests/fast/pandas/test_datetime_timestamp.py\nindex 523e0e9b0cc3..57ccf565f56c 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_datetime_timestamp.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_datetime_timestamp.py\n@@ -122,3 +122,33 @@ def test_timestamp_timezone_positive_extreme(self, pandas, duckdb_cursor):\n         )\n         df_out = duckdb_cursor.sql(\"\"\"select * from df_in\"\"\").df()\n         pandas.testing.assert_frame_equal(df_out, duckdb_time)\n+\n+    @pytest.mark.skipif(\n+        Version(pd.__version__) < Version('2.0.2'), reason=\"pandas < 2.0.2 does not properly convert timezones\"\n+    )\n+    @pytest.mark.parametrize('unit', ['ms', 'ns', 's'])\n+    def test_timestamp_timezone_coverage(self, unit, duckdb_cursor):\n+        pd = pytest.importorskip(\"pandas\")\n+        ts_df = pd.DataFrame(\n+            {'ts': pd.Series(data=[pd.Timestamp(datetime.datetime(1990, 12, 21))], dtype=f'datetime64[{unit}]')}\n+        )\n+        usecond_df = pd.DataFrame(\n+            {'ts': pd.Series(data=[pd.Timestamp(datetime.datetime(1990, 12, 21))], dtype='datetime64[us]')}\n+        )\n+\n+        query = \"\"\"\n+            select\n+                cast(ts as timestamptz) as tstz\n+            from {}\n+        \"\"\"\n+\n+        duckdb_cursor.sql(\"set TimeZone = 'UTC'\")\n+        utc_usecond = duckdb_cursor.sql(query.format('usecond_df')).df()\n+        utc_other = duckdb_cursor.sql(query.format('ts_df')).df()\n+\n+        duckdb_cursor.sql(\"set TimeZone = 'America/Los_Angeles'\")\n+        us_usecond = duckdb_cursor.sql(query.format('usecond_df')).df()\n+        us_other = duckdb_cursor.sql(query.format('ts_df')).df()\n+\n+        pd.testing.assert_frame_equal(utc_usecond, utc_other)\n+        pd.testing.assert_frame_equal(us_usecond, us_other)\n",
  "problem_statement": "Can no longer cast Pandas Timestamps to timestamptz in 0.9\n### What happens?\n\nPrior to the 0.9 release you could cast Pandas Timestamp columns to `timestamptz` resulting in the same date+time but in the configured session time zone. In version 0.9 the same cast produces a conversion error. I could not find any documentation of this in the changelog.\n\n### To Reproduce\n\nMinimal reproduction:\r\n\r\n```python\r\nimport duckdb\r\nimport pandas as pd\r\n\r\nts_df = pd.DataFrame({ \"ts\": [pd.Timestamp.now()] })\r\nquery = \"select cast(ts as timestamptz) as tstz from ts_df\"\r\n\r\nwith duckdb.connect() as conn:\r\n    print(conn.sql(query).df())\r\n    conn.sql(\"set TimeZone = 'America/Los_Angeles'\")\r\n    print(conn.sql(query).df())\r\n```\r\n\r\nOn version 0.8.1 this produces the output\r\n\r\n```\r\n                              tstz\r\n0 2023-10-31 22:19:37.432103+00:00\r\n                              tstz\r\n0 2023-10-31 22:19:37.432103-07:00\r\n```\r\n\r\nOn version 0.9.1 (and on the latest master) it results in\r\n\r\n```\r\nConversionException: Conversion Error: Unimplemented type for cast (TIMESTAMP_NS -> TIMESTAMP WITH TIME ZONE)\r\n```\n\n### OS:\n\nmacOS, Linux\n\n### DuckDB Version:\n\n0.9.1, 0.9.2.dev231\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nDylan Scott\n\n### Affiliation:\n\nHex Technologies\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "Hi, that's not really supposed to happen, but I understand why.\r\n\r\n<https://github.com/duckdb/duckdb/pull/8620> has added support for non-ns timestamps, so we don't convert these to US now.\r\ntimestamp_ns -> timestamp_tz is not supported, so you'll have to add a cast from timestamp_ns to timestamp_us first\nThanks for the quick reply @Tishj. Is there any way to trigger that conversion implicitly? We have many, many existing queries written by our users that expect to be able to perform this cast, so this represents a significant breaking change for us\nThat's fair, we could add the `TIMESTAMP_NS` -> `TIMESTAMP_TZ` cast so this will still work",
  "created_at": "2023-11-01T12:01:45Z"
}